commit 72e1e2a30f67fc19a958be6c1818e7e6cb1573fe
Author: Manuel Lauss <manuel.lauss@gmail.com>
Date:   Wed Jul 23 16:36:57 2014 +0200

    MIPS: Alchemy: remove old clock support
    
    With the clock framework in place, remove unused functions and bits,
    and drop the CLK_IGNORE_UNUSED flag, which is now unneeded.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/7473/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index e77b920cc9e7..a7eec3364a64 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -470,72 +470,8 @@
 
 /* Clock Controller */
 #define AU1000_SYS_FREQCTRL0	0x20
-#  define SYS_FC_FRDIV2_BIT	22
-#  define SYS_FC_FRDIV2_MASK	(0xff << SYS_FC_FRDIV2_BIT)
-#  define SYS_FC_FE2		(1 << 21)
-#  define SYS_FC_FS2		(1 << 20)
-#  define SYS_FC_FRDIV1_BIT	12
-#  define SYS_FC_FRDIV1_MASK	(0xff << SYS_FC_FRDIV1_BIT)
-#  define SYS_FC_FE1		(1 << 11)
-#  define SYS_FC_FS1		(1 << 10)
-#  define SYS_FC_FRDIV0_BIT	2
-#  define SYS_FC_FRDIV0_MASK	(0xff << SYS_FC_FRDIV0_BIT)
-#  define SYS_FC_FE0		(1 << 1)
-#  define SYS_FC_FS0		(1 << 0)
 #define AU1000_SYS_FREQCTRL1	0x24
-#  define SYS_FC_FRDIV5_BIT	22
-#  define SYS_FC_FRDIV5_MASK	(0xff << SYS_FC_FRDIV5_BIT)
-#  define SYS_FC_FE5		(1 << 21)
-#  define SYS_FC_FS5		(1 << 20)
-#  define SYS_FC_FRDIV4_BIT	12
-#  define SYS_FC_FRDIV4_MASK	(0xff << SYS_FC_FRDIV4_BIT)
-#  define SYS_FC_FE4		(1 << 11)
-#  define SYS_FC_FS4		(1 << 10)
-#  define SYS_FC_FRDIV3_BIT	2
-#  define SYS_FC_FRDIV3_MASK	(0xff << SYS_FC_FRDIV3_BIT)
-#  define SYS_FC_FE3		(1 << 1)
-#  define SYS_FC_FS3		(1 << 0)
 #define AU1000_SYS_CLKSRC	0x28
-#  define SYS_CS_ME1_BIT	27
-#  define SYS_CS_ME1_MASK	(0x7 << SYS_CS_ME1_BIT)
-#  define SYS_CS_DE1		(1 << 26)
-#  define SYS_CS_CE1		(1 << 25)
-#  define SYS_CS_ME0_BIT	22
-#  define SYS_CS_ME0_MASK	(0x7 << SYS_CS_ME0_BIT)
-#  define SYS_CS_DE0		(1 << 21)
-#  define SYS_CS_CE0		(1 << 20)
-#  define SYS_CS_MI2_BIT	17
-#  define SYS_CS_MI2_MASK	(0x7 << SYS_CS_MI2_BIT)
-#  define SYS_CS_DI2		(1 << 16)
-#  define SYS_CS_CI2		(1 << 15)
-
-#  define SYS_CS_ML_BIT		7
-#  define SYS_CS_ML_MASK	(0x7 << SYS_CS_ML_BIT)
-#  define SYS_CS_DL		(1 << 6)
-#  define SYS_CS_CL		(1 << 5)
-
-#  define SYS_CS_MUH_BIT	12
-#  define SYS_CS_MUH_MASK	(0x7 << SYS_CS_MUH_BIT)
-#  define SYS_CS_DUH		(1 << 11)
-#  define SYS_CS_CUH		(1 << 10)
-#  define SYS_CS_MUD_BIT	7
-#  define SYS_CS_MUD_MASK	(0x7 << SYS_CS_MUD_BIT)
-#  define SYS_CS_DUD		(1 << 6)
-#  define SYS_CS_CUD		(1 << 5)
-
-#  define SYS_CS_MIR_BIT	2
-#  define SYS_CS_MIR_MASK	(0x7 << SYS_CS_MIR_BIT)
-#  define SYS_CS_DIR		(1 << 1)
-#  define SYS_CS_CIR		(1 << 0)
-
-#  define SYS_CS_MUX_AUX	0x1
-#  define SYS_CS_MUX_FQ0	0x2
-#  define SYS_CS_MUX_FQ1	0x3
-#  define SYS_CS_MUX_FQ2	0x4
-#  define SYS_CS_MUX_FQ3	0x5
-#  define SYS_CS_MUX_FQ4	0x6
-#  define SYS_CS_MUX_FQ5	0x7
-
 #define AU1000_SYS_CPUPLL	0x60
 #define AU1000_SYS_AUXPLL	0x64
 #define AU1300_SYS_AUXPLL2	0x68
@@ -841,11 +777,6 @@ static inline int alchemy_get_macs(int type)
 	return 0;
 }
 
-/* arch/mips/au1000/common/clocks.c */
-extern void set_au1x00_speed(unsigned int new_freq);
-extern unsigned int get_au1x00_speed(void);
-extern unsigned long au1xxx_calc_clock(void);
-
 /* PM: arch/mips/alchemy/common/sleeper.S, power.c, irq.c */
 void alchemy_sleep_au1000(void);
 void alchemy_sleep_au1550(void);

commit 5a2fb71e7329dbcefbd08db8e44055c72ed52e90
Author: Manuel Lauss <manuel.lauss@gmail.com>
Date:   Wed Jul 23 16:36:49 2014 +0200

    MIPS: Alchemy: platform: use clk framework for uarts
    
    Use the clock framework to get the rate of the peripheral clock.
    Remove the now obsolete get_uart_baud_base function.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/7468/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 1f40c0a00e57..e77b920cc9e7 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -844,8 +844,6 @@ static inline int alchemy_get_macs(int type)
 /* arch/mips/au1000/common/clocks.c */
 extern void set_au1x00_speed(unsigned int new_freq);
 extern unsigned int get_au1x00_speed(void);
-extern void set_au1x00_uart_baud_base(unsigned long new_baud_base);
-extern unsigned long get_au1x00_uart_baud_base(void);
 extern unsigned long au1xxx_calc_clock(void);
 
 /* PM: arch/mips/alchemy/common/sleeper.S, power.c, irq.c */

commit 474402291a0ad4778a4e5fdff6ae507b2a26d809
Author: Manuel Lauss <manuel.lauss@gmail.com>
Date:   Wed Jul 23 16:36:48 2014 +0200

    MIPS: Alchemy: clock framework integration of onchip clocks
    
    This patch introduces common clock framework integration for all
    configurable on-chip clocks on Alchemy chips:
    
    - 2 or 3 PLLs which generate integer multiples of the root rate 12MHz,
    - 6 dividers which take one of the 3 PLLs as input and divide their
      rate by either multiples of 2 or 1 (Au1300).
    - another bank of up to 6 muxes which take either one of the 6
      above dividers or one of the PLLs directly and divide their rate
      further by 1, 2, 3 or 4.
    - a few other sources which are used by onchip peripherals and are
      informational.
    
    This implementation will take the clock tree as it was set up
    by boot firmware: all in-kernel boards should continue to work
    without having to set up the clock tree in board code.
    
    CLK_IGNORE_DISABLED will be removed once all drivers have been
    converted.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: Mike Turquette <mturquette@linaro.org>
    Cc: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/7466/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 754207071b58..1f40c0a00e57 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -47,6 +47,21 @@
 #define ALCHEMY_GPIC_INT_NUM	128
 #define ALCHEMY_GPIC_INT_LAST	(ALCHEMY_GPIC_INT_BASE + ALCHEMY_GPIC_INT_NUM - 1)
 
+/* common clock names, shared among all variants. AUXPLL2 is Au1300 */
+#define ALCHEMY_ROOT_CLK		"root_clk"
+#define ALCHEMY_CPU_CLK			"cpu_clk"
+#define ALCHEMY_AUXPLL_CLK		"auxpll_clk"
+#define ALCHEMY_AUXPLL2_CLK		"auxpll2_clk"
+#define ALCHEMY_SYSBUS_CLK		"sysbus_clk"
+#define ALCHEMY_PERIPH_CLK		"periph_clk"
+#define ALCHEMY_MEM_CLK			"mem_clk"
+#define ALCHEMY_LR_CLK			"lr_clk"
+#define ALCHEMY_FG0_CLK			"fg0_clk"
+#define ALCHEMY_FG1_CLK			"fg1_clk"
+#define ALCHEMY_FG2_CLK			"fg2_clk"
+#define ALCHEMY_FG3_CLK			"fg3_clk"
+#define ALCHEMY_FG4_CLK			"fg4_clk"
+#define ALCHEMY_FG5_CLK			"fg5_clk"
 
 /* Au1300 peripheral interrupt numbers */
 #define AU1300_FIRST_INT	(ALCHEMY_GPIC_INT_BASE)
@@ -523,6 +538,7 @@
 
 #define AU1000_SYS_CPUPLL	0x60
 #define AU1000_SYS_AUXPLL	0x64
+#define AU1300_SYS_AUXPLL2	0x68
 
 
 /**********************************************************************/

commit 2f73bfbe0873452f4cd388ec2f67f8226fe93f79
Author: Manuel Lauss <manuel.lauss@gmail.com>
Date:   Wed Jul 23 16:36:26 2014 +0200

    MIPS: Alchemy: remove au_read/write/sync
    
    replace au_read/write/sync with __raw_read/write and wmb.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/7465/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index d664b11e0baf..754207071b58 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -645,54 +645,6 @@
 
 #include <asm/cpu.h>
 
-/* cpu pipeline flush */
-void static inline au_sync(void)
-{
-	__asm__ volatile ("sync");
-}
-
-void static inline au_sync_udelay(int us)
-{
-	__asm__ volatile ("sync");
-	udelay(us);
-}
-
-void static inline au_sync_delay(int ms)
-{
-	__asm__ volatile ("sync");
-	mdelay(ms);
-}
-
-void static inline au_writeb(u8 val, unsigned long reg)
-{
-	*(volatile u8 *)reg = val;
-}
-
-void static inline au_writew(u16 val, unsigned long reg)
-{
-	*(volatile u16 *)reg = val;
-}
-
-void static inline au_writel(u32 val, unsigned long reg)
-{
-	*(volatile u32 *)reg = val;
-}
-
-static inline u8 au_readb(unsigned long reg)
-{
-	return *(volatile u8 *)reg;
-}
-
-static inline u16 au_readw(unsigned long reg)
-{
-	return *(volatile u16 *)reg;
-}
-
-static inline u32 au_readl(unsigned long reg)
-{
-	return *(volatile u32 *)reg;
-}
-
 /* helpers to access the SYS_* registers */
 static inline unsigned long alchemy_rdsys(int regofs)
 {

commit 9cf12167e909a86fbc4b39cf4cffef4cba40f1b3
Author: Manuel Lauss <manuel.lauss@gmail.com>
Date:   Wed Jul 23 16:36:25 2014 +0200

    MIPS: Alchemy: add helpers to access static memory ctrl registers.
    
    This patch changes the static memory controller registers to offsets
    from base, prefixes them with AU1000_ to avoid silent failures due to
    changed addresses and introduces helpers to access them.
    
    No functional changes, comparing assembly of a few select functions shows
    no differences.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/7463/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index c8cfca9c3167..d664b11e0baf 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -309,25 +309,21 @@
 #define AU1550_MEM_SDSREF		0x08D0
 #define AU1550_MEM_SDSLEEP		MEM_SDSREF
 
-/* Static Bus Controller */
-#define MEM_STCFG0		0xB4001000
-#define MEM_STTIME0		0xB4001004
-#define MEM_STADDR0		0xB4001008
-
-#define MEM_STCFG1		0xB4001010
-#define MEM_STTIME1		0xB4001014
-#define MEM_STADDR1		0xB4001018
-
-#define MEM_STCFG2		0xB4001020
-#define MEM_STTIME2		0xB4001024
-#define MEM_STADDR2		0xB4001028
-
-#define MEM_STCFG3		0xB4001030
-#define MEM_STTIME3		0xB4001034
-#define MEM_STADDR3		0xB4001038
-
-#define MEM_STNDCTL		0xB4001100
-#define MEM_STSTAT		0xB4001104
+/* Static Bus Controller register offsets */
+#define AU1000_MEM_STCFG0	0x000
+#define AU1000_MEM_STTIME0	0x004
+#define AU1000_MEM_STADDR0	0x008
+#define AU1000_MEM_STCFG1	0x010
+#define AU1000_MEM_STTIME1	0x014
+#define AU1000_MEM_STADDR1	0x018
+#define AU1000_MEM_STCFG2	0x020
+#define AU1000_MEM_STTIME2	0x024
+#define AU1000_MEM_STADDR2	0x028
+#define AU1000_MEM_STCFG3	0x030
+#define AU1000_MEM_STTIME3	0x034
+#define AU1000_MEM_STADDR3	0x038
+#define AU1000_MEM_STNDCTL	0x100
+#define AU1000_MEM_STSTAT	0x104
 
 #define MEM_STNAND_CMD		0x0
 #define MEM_STNAND_ADDR		0x4
@@ -713,6 +709,22 @@ static inline void alchemy_wrsys(unsigned long v, int regofs)
 	wmb(); /* drain writebuffer */
 }
 
+/* helpers to access static memctrl registers */
+static inline unsigned long alchemy_rdsmem(int regofs)
+{
+	void __iomem *b = (void __iomem *)KSEG1ADDR(AU1000_STATIC_MEM_PHYS_ADDR);
+
+	return __raw_readl(b + regofs);
+}
+
+static inline void alchemy_wrsmem(unsigned long v, int regofs)
+{
+	void __iomem *b = (void __iomem *)KSEG1ADDR(AU1000_STATIC_MEM_PHYS_ADDR);
+
+	__raw_writel(v, b + regofs);
+	wmb(); /* drain writebuffer */
+}
+
 /* Early Au1000 have a write-only SYS_CPUPLL register. */
 static inline int au1xxx_cpu_has_pll_wo(void)
 {

commit 1d09de7dc76ef96a9a2c7c0244e20f12d68e6ef8
Author: Manuel Lauss <manuel.lauss@gmail.com>
Date:   Wed Jul 23 16:36:24 2014 +0200

    MIPS: Alchemy: introduce helpers to access SYS register block.
    
    This patch changes all absolute SYS_XY registers to offsets from the
    SYS block base, prefixes them with AU1000 to avoid silent failures due
    to changed addresses, and introduces helper functions to read/write
    them.
    
    No functional changes, comparing assembly of a few select functions shows
    no differences.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/7464/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 16cd01236dc3..c8cfca9c3167 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -335,8 +335,7 @@
 
 
 /* Programmable Counters 0 and 1 */
-#define SYS_BASE		0xB1900000
-#define SYS_COUNTER_CNTRL	(SYS_BASE + 0x14)
+#define AU1000_SYS_CNTRCTRL	0x14
 #  define SYS_CNTRL_E1S		(1 << 23)
 #  define SYS_CNTRL_T1S		(1 << 20)
 #  define SYS_CNTRL_M21		(1 << 19)
@@ -358,24 +357,24 @@
 #  define SYS_CNTRL_C0S		(1 << 0)
 
 /* Programmable Counter 0 Registers */
-#define SYS_TOYTRIM		(SYS_BASE + 0)
-#define SYS_TOYWRITE		(SYS_BASE + 4)
-#define SYS_TOYMATCH0		(SYS_BASE + 8)
-#define SYS_TOYMATCH1		(SYS_BASE + 0xC)
-#define SYS_TOYMATCH2		(SYS_BASE + 0x10)
-#define SYS_TOYREAD		(SYS_BASE + 0x40)
+#define AU1000_SYS_TOYTRIM	0x00
+#define AU1000_SYS_TOYWRITE	0x04
+#define AU1000_SYS_TOYMATCH0	0x08
+#define AU1000_SYS_TOYMATCH1	0x0c
+#define AU1000_SYS_TOYMATCH2	0x10
+#define AU1000_SYS_TOYREAD	0x40
 
 /* Programmable Counter 1 Registers */
-#define SYS_RTCTRIM		(SYS_BASE + 0x44)
-#define SYS_RTCWRITE		(SYS_BASE + 0x48)
-#define SYS_RTCMATCH0		(SYS_BASE + 0x4C)
-#define SYS_RTCMATCH1		(SYS_BASE + 0x50)
-#define SYS_RTCMATCH2		(SYS_BASE + 0x54)
-#define SYS_RTCREAD		(SYS_BASE + 0x58)
+#define AU1000_SYS_RTCTRIM	0x44
+#define AU1000_SYS_RTCWRITE	0x48
+#define AU1000_SYS_RTCMATCH0	0x4c
+#define AU1000_SYS_RTCMATCH1	0x50
+#define AU1000_SYS_RTCMATCH2	0x54
+#define AU1000_SYS_RTCREAD	0x58
 
 
 /* GPIO */
-#define SYS_PINFUNC		0xB190002C
+#define AU1000_SYS_PINFUNC	0x2C
 #  define SYS_PF_USB		(1 << 15)	/* 2nd USB device/host */
 #  define SYS_PF_U3		(1 << 14)	/* GPIO23/U3TXD */
 #  define SYS_PF_U2		(1 << 13)	/* GPIO22/U2TXD */
@@ -445,21 +444,21 @@
 #define SYS_PINFUNC_S1B		(1 << 2)
 
 /* Power Management */
-#define SYS_SCRATCH0		0xB1900018
-#define SYS_SCRATCH1		0xB190001C
-#define SYS_WAKEMSK		0xB1900034
-#define SYS_ENDIAN		0xB1900038
-#define SYS_POWERCTRL		0xB190003C
-#define SYS_WAKESRC		0xB190005C
-#define SYS_SLPPWR		0xB1900078
-#define SYS_SLEEP		0xB190007C
+#define AU1000_SYS_SCRATCH0	0x18
+#define AU1000_SYS_SCRATCH1	0x1c
+#define AU1000_SYS_WAKEMSK	0x34
+#define AU1000_SYS_ENDIAN	0x38
+#define AU1000_SYS_POWERCTRL	0x3c
+#define AU1000_SYS_WAKESRC	0x5c
+#define AU1000_SYS_SLPPWR	0x78
+#define AU1000_SYS_SLEEP	0x7c
 
 #define SYS_WAKEMSK_D2		(1 << 9)
 #define SYS_WAKEMSK_M2		(1 << 8)
 #define SYS_WAKEMSK_GPIO(x)	(1 << (x))
 
 /* Clock Controller */
-#define SYS_FREQCTRL0		0xB1900020
+#define AU1000_SYS_FREQCTRL0	0x20
 #  define SYS_FC_FRDIV2_BIT	22
 #  define SYS_FC_FRDIV2_MASK	(0xff << SYS_FC_FRDIV2_BIT)
 #  define SYS_FC_FE2		(1 << 21)
@@ -472,7 +471,7 @@
 #  define SYS_FC_FRDIV0_MASK	(0xff << SYS_FC_FRDIV0_BIT)
 #  define SYS_FC_FE0		(1 << 1)
 #  define SYS_FC_FS0		(1 << 0)
-#define SYS_FREQCTRL1		0xB1900024
+#define AU1000_SYS_FREQCTRL1	0x24
 #  define SYS_FC_FRDIV5_BIT	22
 #  define SYS_FC_FRDIV5_MASK	(0xff << SYS_FC_FRDIV5_BIT)
 #  define SYS_FC_FE5		(1 << 21)
@@ -485,7 +484,7 @@
 #  define SYS_FC_FRDIV3_MASK	(0xff << SYS_FC_FRDIV3_BIT)
 #  define SYS_FC_FE3		(1 << 1)
 #  define SYS_FC_FS3		(1 << 0)
-#define SYS_CLKSRC		0xB1900028
+#define AU1000_SYS_CLKSRC	0x28
 #  define SYS_CS_ME1_BIT	27
 #  define SYS_CS_ME1_MASK	(0x7 << SYS_CS_ME1_BIT)
 #  define SYS_CS_DE1		(1 << 26)
@@ -525,8 +524,12 @@
 #  define SYS_CS_MUX_FQ3	0x5
 #  define SYS_CS_MUX_FQ4	0x6
 #  define SYS_CS_MUX_FQ5	0x7
-#define SYS_CPUPLL		0xB1900060
-#define SYS_AUXPLL		0xB1900064
+
+#define AU1000_SYS_CPUPLL	0x60
+#define AU1000_SYS_AUXPLL	0x64
+
+
+/**********************************************************************/
 
 
 /* The PCI chip selects are outside the 32bit space, and since we can't
@@ -694,6 +697,22 @@ static inline u32 au_readl(unsigned long reg)
 	return *(volatile u32 *)reg;
 }
 
+/* helpers to access the SYS_* registers */
+static inline unsigned long alchemy_rdsys(int regofs)
+{
+	void __iomem *b = (void __iomem *)KSEG1ADDR(AU1000_SYS_PHYS_ADDR);
+
+	return __raw_readl(b + regofs);
+}
+
+static inline void alchemy_wrsys(unsigned long v, int regofs)
+{
+	void __iomem *b = (void __iomem *)KSEG1ADDR(AU1000_SYS_PHYS_ADDR);
+
+	__raw_writel(v, b + regofs);
+	wmb(); /* drain writebuffer */
+}
+
 /* Early Au1000 have a write-only SYS_CPUPLL register. */
 static inline int au1xxx_cpu_has_pll_wo(void)
 {

commit 2ef1bb99116e49226e8bab8ebab255f12fa8a99e
Author: Manuel Lauss <manuel.lauss@gmail.com>
Date:   Wed Jul 23 16:36:23 2014 +0200

    MIPS: Alchemy: au1000.h move C-code after register definitions.
    
    Move the C-code after all macros:  A follow-on patch which
    introduces helpers to access the SYS_* registers needs this to build.
    
    Just code shuffling, no functional changes.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/7461/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index e50671019122..16cd01236dc3 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -34,1246 +34,1250 @@
 #ifndef _AU1000_H_
 #define _AU1000_H_
 
+/* SOC Interrupt numbers */
+/* Au1000-style (IC0/1): 2 controllers with 32 sources each */
+#define AU1000_INTC0_INT_BASE	(MIPS_CPU_IRQ_BASE + 8)
+#define AU1000_INTC0_INT_LAST	(AU1000_INTC0_INT_BASE + 31)
+#define AU1000_INTC1_INT_BASE	(AU1000_INTC0_INT_LAST + 1)
+#define AU1000_INTC1_INT_LAST	(AU1000_INTC1_INT_BASE + 31)
+#define AU1000_MAX_INTR		AU1000_INTC1_INT_LAST
 
-#ifndef _LANGUAGE_ASSEMBLY
+/* Au1300-style (GPIC): 1 controller with up to 128 sources */
+#define ALCHEMY_GPIC_INT_BASE	(MIPS_CPU_IRQ_BASE + 8)
+#define ALCHEMY_GPIC_INT_NUM	128
+#define ALCHEMY_GPIC_INT_LAST	(ALCHEMY_GPIC_INT_BASE + ALCHEMY_GPIC_INT_NUM - 1)
 
-#include <linux/delay.h>
-#include <linux/types.h>
 
-#include <linux/io.h>
-#include <linux/irq.h>
+/* Au1300 peripheral interrupt numbers */
+#define AU1300_FIRST_INT	(ALCHEMY_GPIC_INT_BASE)
+#define AU1300_UART1_INT	(AU1300_FIRST_INT + 17)
+#define AU1300_UART2_INT	(AU1300_FIRST_INT + 25)
+#define AU1300_UART3_INT	(AU1300_FIRST_INT + 27)
+#define AU1300_SD1_INT		(AU1300_FIRST_INT + 32)
+#define AU1300_SD2_INT		(AU1300_FIRST_INT + 38)
+#define AU1300_PSC0_INT		(AU1300_FIRST_INT + 48)
+#define AU1300_PSC1_INT		(AU1300_FIRST_INT + 52)
+#define AU1300_PSC2_INT		(AU1300_FIRST_INT + 56)
+#define AU1300_PSC3_INT		(AU1300_FIRST_INT + 60)
+#define AU1300_NAND_INT		(AU1300_FIRST_INT + 62)
+#define AU1300_DDMA_INT		(AU1300_FIRST_INT + 75)
+#define AU1300_MMU_INT		(AU1300_FIRST_INT + 76)
+#define AU1300_MPU_INT		(AU1300_FIRST_INT + 77)
+#define AU1300_GPU_INT		(AU1300_FIRST_INT + 78)
+#define AU1300_UDMA_INT		(AU1300_FIRST_INT + 79)
+#define AU1300_TOY_INT		(AU1300_FIRST_INT + 80)
+#define AU1300_TOY_MATCH0_INT	(AU1300_FIRST_INT + 81)
+#define AU1300_TOY_MATCH1_INT	(AU1300_FIRST_INT + 82)
+#define AU1300_TOY_MATCH2_INT	(AU1300_FIRST_INT + 83)
+#define AU1300_RTC_INT		(AU1300_FIRST_INT + 84)
+#define AU1300_RTC_MATCH0_INT	(AU1300_FIRST_INT + 85)
+#define AU1300_RTC_MATCH1_INT	(AU1300_FIRST_INT + 86)
+#define AU1300_RTC_MATCH2_INT	(AU1300_FIRST_INT + 87)
+#define AU1300_UART0_INT	(AU1300_FIRST_INT + 88)
+#define AU1300_SD0_INT		(AU1300_FIRST_INT + 89)
+#define AU1300_USB_INT		(AU1300_FIRST_INT + 90)
+#define AU1300_LCD_INT		(AU1300_FIRST_INT + 91)
+#define AU1300_BSA_INT		(AU1300_FIRST_INT + 92)
+#define AU1300_MPE_INT		(AU1300_FIRST_INT + 93)
+#define AU1300_ITE_INT		(AU1300_FIRST_INT + 94)
+#define AU1300_AES_INT		(AU1300_FIRST_INT + 95)
+#define AU1300_CIM_INT		(AU1300_FIRST_INT + 96)
 
-#include <asm/cpu.h>
+/**********************************************************************/
 
-/* cpu pipeline flush */
-void static inline au_sync(void)
-{
-	__asm__ volatile ("sync");
-}
+/*
+ * Physical base addresses for integrated peripherals
+ * 0..au1000 1..au1500 2..au1100 3..au1550 4..au1200 5..au1300
+ */
 
-void static inline au_sync_udelay(int us)
-{
-	__asm__ volatile ("sync");
-	udelay(us);
-}
+#define AU1000_AC97_PHYS_ADDR		0x10000000 /* 012 */
+#define AU1300_ROM_PHYS_ADDR		0x10000000 /* 5 */
+#define AU1300_OTP_PHYS_ADDR		0x10002000 /* 5 */
+#define AU1300_VSS_PHYS_ADDR		0x10003000 /* 5 */
+#define AU1300_UART0_PHYS_ADDR		0x10100000 /* 5 */
+#define AU1300_UART1_PHYS_ADDR		0x10101000 /* 5 */
+#define AU1300_UART2_PHYS_ADDR		0x10102000 /* 5 */
+#define AU1300_UART3_PHYS_ADDR		0x10103000 /* 5 */
+#define AU1000_USB_OHCI_PHYS_ADDR	0x10100000 /* 012 */
+#define AU1000_USB_UDC_PHYS_ADDR	0x10200000 /* 0123 */
+#define AU1300_GPIC_PHYS_ADDR		0x10200000 /* 5 */
+#define AU1000_IRDA_PHYS_ADDR		0x10300000 /* 02 */
+#define AU1200_AES_PHYS_ADDR		0x10300000 /* 45 */
+#define AU1000_IC0_PHYS_ADDR		0x10400000 /* 01234 */
+#define AU1300_GPU_PHYS_ADDR		0x10500000 /* 5 */
+#define AU1000_MAC0_PHYS_ADDR		0x10500000 /* 023 */
+#define AU1000_MAC1_PHYS_ADDR		0x10510000 /* 023 */
+#define AU1000_MACEN_PHYS_ADDR		0x10520000 /* 023 */
+#define AU1100_SD0_PHYS_ADDR		0x10600000 /* 245 */
+#define AU1300_SD1_PHYS_ADDR		0x10601000 /* 5 */
+#define AU1300_SD2_PHYS_ADDR		0x10602000 /* 5 */
+#define AU1100_SD1_PHYS_ADDR		0x10680000 /* 24 */
+#define AU1300_SYS_PHYS_ADDR		0x10900000 /* 5 */
+#define AU1550_PSC2_PHYS_ADDR		0x10A00000 /* 3 */
+#define AU1550_PSC3_PHYS_ADDR		0x10B00000 /* 3 */
+#define AU1300_PSC0_PHYS_ADDR		0x10A00000 /* 5 */
+#define AU1300_PSC1_PHYS_ADDR		0x10A01000 /* 5 */
+#define AU1300_PSC2_PHYS_ADDR		0x10A02000 /* 5 */
+#define AU1300_PSC3_PHYS_ADDR		0x10A03000 /* 5 */
+#define AU1000_I2S_PHYS_ADDR		0x11000000 /* 02 */
+#define AU1500_MAC0_PHYS_ADDR		0x11500000 /* 1 */
+#define AU1500_MAC1_PHYS_ADDR		0x11510000 /* 1 */
+#define AU1500_MACEN_PHYS_ADDR		0x11520000 /* 1 */
+#define AU1000_UART0_PHYS_ADDR		0x11100000 /* 01234 */
+#define AU1200_SWCNT_PHYS_ADDR		0x1110010C /* 4 */
+#define AU1000_UART1_PHYS_ADDR		0x11200000 /* 0234 */
+#define AU1000_UART2_PHYS_ADDR		0x11300000 /* 0 */
+#define AU1000_UART3_PHYS_ADDR		0x11400000 /* 0123 */
+#define AU1000_SSI0_PHYS_ADDR		0x11600000 /* 02 */
+#define AU1000_SSI1_PHYS_ADDR		0x11680000 /* 02 */
+#define AU1500_GPIO2_PHYS_ADDR		0x11700000 /* 1234 */
+#define AU1000_IC1_PHYS_ADDR		0x11800000 /* 01234 */
+#define AU1000_SYS_PHYS_ADDR		0x11900000 /* 012345 */
+#define AU1550_PSC0_PHYS_ADDR		0x11A00000 /* 34 */
+#define AU1550_PSC1_PHYS_ADDR		0x11B00000 /* 34 */
+#define AU1000_MEM_PHYS_ADDR		0x14000000 /* 01234 */
+#define AU1000_STATIC_MEM_PHYS_ADDR	0x14001000 /* 01234 */
+#define AU1300_UDMA_PHYS_ADDR		0x14001800 /* 5 */
+#define AU1000_DMA_PHYS_ADDR		0x14002000 /* 012 */
+#define AU1550_DBDMA_PHYS_ADDR		0x14002000 /* 345 */
+#define AU1550_DBDMA_CONF_PHYS_ADDR	0x14003000 /* 345 */
+#define AU1000_MACDMA0_PHYS_ADDR	0x14004000 /* 0123 */
+#define AU1000_MACDMA1_PHYS_ADDR	0x14004200 /* 0123 */
+#define AU1200_CIM_PHYS_ADDR		0x14004000 /* 45 */
+#define AU1500_PCI_PHYS_ADDR		0x14005000 /* 13 */
+#define AU1550_PE_PHYS_ADDR		0x14008000 /* 3 */
+#define AU1200_MAEBE_PHYS_ADDR		0x14010000 /* 4 */
+#define AU1200_MAEFE_PHYS_ADDR		0x14012000 /* 4 */
+#define AU1300_MAEITE_PHYS_ADDR		0x14010000 /* 5 */
+#define AU1300_MAEMPE_PHYS_ADDR		0x14014000 /* 5 */
+#define AU1550_USB_OHCI_PHYS_ADDR	0x14020000 /* 3 */
+#define AU1200_USB_CTL_PHYS_ADDR	0x14020000 /* 4 */
+#define AU1200_USB_OTG_PHYS_ADDR	0x14020020 /* 4 */
+#define AU1200_USB_OHCI_PHYS_ADDR	0x14020100 /* 4 */
+#define AU1200_USB_EHCI_PHYS_ADDR	0x14020200 /* 4 */
+#define AU1200_USB_UDC_PHYS_ADDR	0x14022000 /* 4 */
+#define AU1300_USB_EHCI_PHYS_ADDR	0x14020000 /* 5 */
+#define AU1300_USB_OHCI0_PHYS_ADDR	0x14020400 /* 5 */
+#define AU1300_USB_OHCI1_PHYS_ADDR	0x14020800 /* 5 */
+#define AU1300_USB_CTL_PHYS_ADDR	0x14021000 /* 5 */
+#define AU1300_USB_OTG_PHYS_ADDR	0x14022000 /* 5 */
+#define AU1300_MAEBSA_PHYS_ADDR		0x14030000 /* 5 */
+#define AU1100_LCD_PHYS_ADDR		0x15000000 /* 2 */
+#define AU1200_LCD_PHYS_ADDR		0x15000000 /* 45 */
+#define AU1500_PCI_MEM_PHYS_ADDR	0x400000000ULL /* 13 */
+#define AU1500_PCI_IO_PHYS_ADDR		0x500000000ULL /* 13 */
+#define AU1500_PCI_CONFIG0_PHYS_ADDR	0x600000000ULL /* 13 */
+#define AU1500_PCI_CONFIG1_PHYS_ADDR	0x680000000ULL /* 13 */
+#define AU1000_PCMCIA_IO_PHYS_ADDR	0xF00000000ULL /* 012345 */
+#define AU1000_PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL /* 012345 */
+#define AU1000_PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL /* 012345 */
 
-void static inline au_sync_delay(int ms)
-{
-	__asm__ volatile ("sync");
-	mdelay(ms);
-}
+/**********************************************************************/
 
-void static inline au_writeb(u8 val, unsigned long reg)
-{
-	*(volatile u8 *)reg = val;
-}
 
-void static inline au_writew(u16 val, unsigned long reg)
-{
-	*(volatile u16 *)reg = val;
-}
+/*
+ * Au1300 GPIO+INT controller (GPIC) register offsets and bits
+ * Registers are 128bits (0x10 bytes), divided into 4 "banks".
+ */
+#define AU1300_GPIC_PINVAL	0x0000
+#define AU1300_GPIC_PINVALCLR	0x0010
+#define AU1300_GPIC_IPEND	0x0020
+#define AU1300_GPIC_PRIENC	0x0030
+#define AU1300_GPIC_IEN		0x0040	/* int_mask in manual */
+#define AU1300_GPIC_IDIS	0x0050	/* int_maskclr in manual */
+#define AU1300_GPIC_DMASEL	0x0060
+#define AU1300_GPIC_DEVSEL	0x0080
+#define AU1300_GPIC_DEVCLR	0x0090
+#define AU1300_GPIC_RSTVAL	0x00a0
+/* pin configuration space. one 32bit register for up to 128 IRQs */
+#define AU1300_GPIC_PINCFG	0x1000
 
-void static inline au_writel(u32 val, unsigned long reg)
-{
-	*(volatile u32 *)reg = val;
-}
+#define GPIC_GPIO_TO_BIT(gpio)	\
+	(1 << ((gpio) & 0x1f))
 
-static inline u8 au_readb(unsigned long reg)
-{
-	return *(volatile u8 *)reg;
-}
+#define GPIC_GPIO_BANKOFF(gpio) \
+	(((gpio) >> 5) * 4)
 
-static inline u16 au_readw(unsigned long reg)
-{
-	return *(volatile u16 *)reg;
-}
+/* Pin Control bits: who owns the pin, what does it do */
+#define GPIC_CFG_PC_GPIN		0
+#define GPIC_CFG_PC_DEV			1
+#define GPIC_CFG_PC_GPOLOW		2
+#define GPIC_CFG_PC_GPOHIGH		3
+#define GPIC_CFG_PC_MASK		3
 
-static inline u32 au_readl(unsigned long reg)
-{
-	return *(volatile u32 *)reg;
-}
+/* assign pin to MIPS IRQ line */
+#define GPIC_CFG_IL_SET(x)	(((x) & 3) << 2)
+#define GPIC_CFG_IL_MASK	(3 << 2)
 
-/* Early Au1000 have a write-only SYS_CPUPLL register. */
-static inline int au1xxx_cpu_has_pll_wo(void)
-{
-	switch (read_c0_prid()) {
-	case 0x00030100:	/* Au1000 DA */
-	case 0x00030201:	/* Au1000 HA */
-	case 0x00030202:	/* Au1000 HB */
-		return 1;
-	}
-	return 0;
-}
+/* pin interrupt type setup */
+#define GPIC_CFG_IC_OFF		(0 << 4)
+#define GPIC_CFG_IC_LEVEL_LOW	(1 << 4)
+#define GPIC_CFG_IC_LEVEL_HIGH	(2 << 4)
+#define GPIC_CFG_IC_EDGE_FALL	(5 << 4)
+#define GPIC_CFG_IC_EDGE_RISE	(6 << 4)
+#define GPIC_CFG_IC_EDGE_BOTH	(7 << 4)
+#define GPIC_CFG_IC_MASK	(7 << 4)
 
-/* does CPU need CONFIG[OD] set to fix tons of errata? */
-static inline int au1xxx_cpu_needs_config_od(void)
-{
-	/*
-	 * c0_config.od (bit 19) was write only (and read as 0) on the
-	 * early revisions of Alchemy SOCs.  It disables the bus trans-
-	 * action overlapping and needs to be set to fix various errata.
-	 */
-	switch (read_c0_prid()) {
-	case 0x00030100: /* Au1000 DA */
-	case 0x00030201: /* Au1000 HA */
-	case 0x00030202: /* Au1000 HB */
-	case 0x01030200: /* Au1500 AB */
-	/*
-	 * Au1100/Au1200 errata actually keep silence about this bit,
-	 * so we set it just in case for those revisions that require
-	 * it to be set according to the (now gone) cpu_table.
-	 */
-	case 0x02030200: /* Au1100 AB */
-	case 0x02030201: /* Au1100 BA */
-	case 0x02030202: /* Au1100 BC */
-	case 0x04030201: /* Au1200 AC */
-		return 1;
-	}
-	return 0;
-}
+/* allow interrupt to wake cpu from 'wait' */
+#define GPIC_CFG_IDLEWAKE	(1 << 7)
 
-#define ALCHEMY_CPU_UNKNOWN	-1
-#define ALCHEMY_CPU_AU1000	0
-#define ALCHEMY_CPU_AU1500	1
-#define ALCHEMY_CPU_AU1100	2
-#define ALCHEMY_CPU_AU1550	3
-#define ALCHEMY_CPU_AU1200	4
-#define ALCHEMY_CPU_AU1300	5
+/***********************************************************************/
 
-static inline int alchemy_get_cputype(void)
-{
-	switch (read_c0_prid() & (PRID_OPT_MASK | PRID_COMP_MASK)) {
-	case 0x00030000:
-		return ALCHEMY_CPU_AU1000;
-		break;
-	case 0x01030000:
-		return ALCHEMY_CPU_AU1500;
-		break;
-	case 0x02030000:
-		return ALCHEMY_CPU_AU1100;
-		break;
-	case 0x03030000:
-		return ALCHEMY_CPU_AU1550;
-		break;
-	case 0x04030000:
-	case 0x05030000:
-		return ALCHEMY_CPU_AU1200;
-		break;
-	case 0x800c0000:
-		return ALCHEMY_CPU_AU1300;
-		break;
-	}
+/* Au1000 SDRAM memory controller register offsets */
+#define AU1000_MEM_SDMODE0		0x0000
+#define AU1000_MEM_SDMODE1		0x0004
+#define AU1000_MEM_SDMODE2		0x0008
+#define AU1000_MEM_SDADDR0		0x000C
+#define AU1000_MEM_SDADDR1		0x0010
+#define AU1000_MEM_SDADDR2		0x0014
+#define AU1000_MEM_SDREFCFG		0x0018
+#define AU1000_MEM_SDPRECMD		0x001C
+#define AU1000_MEM_SDAUTOREF		0x0020
+#define AU1000_MEM_SDWRMD0		0x0024
+#define AU1000_MEM_SDWRMD1		0x0028
+#define AU1000_MEM_SDWRMD2		0x002C
+#define AU1000_MEM_SDSLEEP		0x0030
+#define AU1000_MEM_SDSMCKE		0x0034
 
-	return ALCHEMY_CPU_UNKNOWN;
-}
+/* MEM_SDMODE register content definitions */
+#define MEM_SDMODE_F		(1 << 22)
+#define MEM_SDMODE_SR		(1 << 21)
+#define MEM_SDMODE_BS		(1 << 20)
+#define MEM_SDMODE_RS		(3 << 18)
+#define MEM_SDMODE_CS		(7 << 15)
+#define MEM_SDMODE_TRAS		(15 << 11)
+#define MEM_SDMODE_TMRD		(3 << 9)
+#define MEM_SDMODE_TWR		(3 << 7)
+#define MEM_SDMODE_TRP		(3 << 5)
+#define MEM_SDMODE_TRCD		(3 << 3)
+#define MEM_SDMODE_TCL		(7 << 0)
 
-/* return number of uarts on a given cputype */
-static inline int alchemy_get_uarts(int type)
-{
-	switch (type) {
-	case ALCHEMY_CPU_AU1000:
-	case ALCHEMY_CPU_AU1300:
-		return 4;
-	case ALCHEMY_CPU_AU1500:
-	case ALCHEMY_CPU_AU1200:
-		return 2;
-	case ALCHEMY_CPU_AU1100:
-	case ALCHEMY_CPU_AU1550:
-		return 3;
-	}
-	return 0;
-}
+#define MEM_SDMODE_BS_2Bank	(0 << 20)
+#define MEM_SDMODE_BS_4Bank	(1 << 20)
+#define MEM_SDMODE_RS_11Row	(0 << 18)
+#define MEM_SDMODE_RS_12Row	(1 << 18)
+#define MEM_SDMODE_RS_13Row	(2 << 18)
+#define MEM_SDMODE_RS_N(N)	((N) << 18)
+#define MEM_SDMODE_CS_7Col	(0 << 15)
+#define MEM_SDMODE_CS_8Col	(1 << 15)
+#define MEM_SDMODE_CS_9Col	(2 << 15)
+#define MEM_SDMODE_CS_10Col	(3 << 15)
+#define MEM_SDMODE_CS_11Col	(4 << 15)
+#define MEM_SDMODE_CS_N(N)	((N) << 15)
+#define MEM_SDMODE_TRAS_N(N)	((N) << 11)
+#define MEM_SDMODE_TMRD_N(N)	((N) << 9)
+#define MEM_SDMODE_TWR_N(N)	((N) << 7)
+#define MEM_SDMODE_TRP_N(N)	((N) << 5)
+#define MEM_SDMODE_TRCD_N(N)	((N) << 3)
+#define MEM_SDMODE_TCL_N(N)	((N) << 0)
 
-/* enable an UART block if it isn't already */
-static inline void alchemy_uart_enable(u32 uart_phys)
-{
-	void __iomem *addr = (void __iomem *)KSEG1ADDR(uart_phys);
+/* MEM_SDADDR register contents definitions */
+#define MEM_SDADDR_E		(1 << 20)
+#define MEM_SDADDR_CSBA		(0x03FF << 10)
+#define MEM_SDADDR_CSMASK	(0x03FF << 0)
+#define MEM_SDADDR_CSBA_N(N)	((N) & (0x03FF << 22) >> 12)
+#define MEM_SDADDR_CSMASK_N(N)	((N)&(0x03FF << 22) >> 22)
 
-	/* reset, enable clock, deassert reset */
-	if ((__raw_readl(addr + 0x100) & 3) != 3) {
-		__raw_writel(0, addr + 0x100);
-		wmb();
-		__raw_writel(1, addr + 0x100);
-		wmb();
-	}
-	__raw_writel(3, addr + 0x100);
-	wmb();
-}
+/* MEM_SDREFCFG register content definitions */
+#define MEM_SDREFCFG_TRC	(15 << 28)
+#define MEM_SDREFCFG_TRPM	(3 << 26)
+#define MEM_SDREFCFG_E		(1 << 25)
+#define MEM_SDREFCFG_RE		(0x1ffffff << 0)
+#define MEM_SDREFCFG_TRC_N(N)	((N) << MEM_SDREFCFG_TRC)
+#define MEM_SDREFCFG_TRPM_N(N)	((N) << MEM_SDREFCFG_TRPM)
+#define MEM_SDREFCFG_REF_N(N)	(N)
 
-static inline void alchemy_uart_disable(u32 uart_phys)
-{
-	void __iomem *addr = (void __iomem *)KSEG1ADDR(uart_phys);
-	__raw_writel(0, addr + 0x100);	/* UART_MOD_CNTRL */
-	wmb();
-}
+/* Au1550 SDRAM Register Offsets */
+#define AU1550_MEM_SDMODE0		0x0800
+#define AU1550_MEM_SDMODE1		0x0808
+#define AU1550_MEM_SDMODE2		0x0810
+#define AU1550_MEM_SDADDR0		0x0820
+#define AU1550_MEM_SDADDR1		0x0828
+#define AU1550_MEM_SDADDR2		0x0830
+#define AU1550_MEM_SDCONFIGA		0x0840
+#define AU1550_MEM_SDCONFIGB		0x0848
+#define AU1550_MEM_SDSTAT		0x0850
+#define AU1550_MEM_SDERRADDR		0x0858
+#define AU1550_MEM_SDSTRIDE0		0x0860
+#define AU1550_MEM_SDSTRIDE1		0x0868
+#define AU1550_MEM_SDSTRIDE2		0x0870
+#define AU1550_MEM_SDWRMD0		0x0880
+#define AU1550_MEM_SDWRMD1		0x0888
+#define AU1550_MEM_SDWRMD2		0x0890
+#define AU1550_MEM_SDPRECMD		0x08C0
+#define AU1550_MEM_SDAUTOREF		0x08C8
+#define AU1550_MEM_SDSREF		0x08D0
+#define AU1550_MEM_SDSLEEP		MEM_SDSREF
 
-static inline void alchemy_uart_putchar(u32 uart_phys, u8 c)
-{
-	void __iomem *base = (void __iomem *)KSEG1ADDR(uart_phys);
-	int timeout, i;
+/* Static Bus Controller */
+#define MEM_STCFG0		0xB4001000
+#define MEM_STTIME0		0xB4001004
+#define MEM_STADDR0		0xB4001008
 
-	/* check LSR TX_EMPTY bit */
-	timeout = 0xffffff;
-	do {
-		if (__raw_readl(base + 0x1c) & 0x20)
-			break;
-		/* slow down */
-		for (i = 10000; i; i--)
-			asm volatile ("nop");
-	} while (--timeout);
+#define MEM_STCFG1		0xB4001010
+#define MEM_STTIME1		0xB4001014
+#define MEM_STADDR1		0xB4001018
 
-	__raw_writel(c, base + 0x04);	/* tx */
-	wmb();
-}
+#define MEM_STCFG2		0xB4001020
+#define MEM_STTIME2		0xB4001024
+#define MEM_STADDR2		0xB4001028
 
-/* return number of ethernet MACs on a given cputype */
-static inline int alchemy_get_macs(int type)
-{
-	switch (type) {
-	case ALCHEMY_CPU_AU1000:
-	case ALCHEMY_CPU_AU1500:
-	case ALCHEMY_CPU_AU1550:
-		return 2;
-	case ALCHEMY_CPU_AU1100:
-		return 1;
-	}
-	return 0;
-}
+#define MEM_STCFG3		0xB4001030
+#define MEM_STTIME3		0xB4001034
+#define MEM_STADDR3		0xB4001038
 
-/* arch/mips/au1000/common/clocks.c */
-extern void set_au1x00_speed(unsigned int new_freq);
-extern unsigned int get_au1x00_speed(void);
-extern void set_au1x00_uart_baud_base(unsigned long new_baud_base);
-extern unsigned long get_au1x00_uart_baud_base(void);
-extern unsigned long au1xxx_calc_clock(void);
+#define MEM_STNDCTL		0xB4001100
+#define MEM_STSTAT		0xB4001104
 
-/* PM: arch/mips/alchemy/common/sleeper.S, power.c, irq.c */
-void alchemy_sleep_au1000(void);
-void alchemy_sleep_au1550(void);
-void alchemy_sleep_au1300(void);
-void au_sleep(void);
+#define MEM_STNAND_CMD		0x0
+#define MEM_STNAND_ADDR		0x4
+#define MEM_STNAND_DATA		0x20
 
-/* USB: drivers/usb/host/alchemy-common.c */
-enum alchemy_usb_block {
-	ALCHEMY_USB_OHCI0,
-	ALCHEMY_USB_UDC0,
-	ALCHEMY_USB_EHCI0,
-	ALCHEMY_USB_OTG0,
-	ALCHEMY_USB_OHCI1,
-};
-int alchemy_usb_control(int block, int enable);
 
-/* PCI controller platform data */
-struct alchemy_pci_platdata {
-	int (*board_map_irq)(const struct pci_dev *d, u8 slot, u8 pin);
-	int (*board_pci_idsel)(unsigned int devsel, int assert);
-	/* bits to set/clear in PCI_CONFIG register */
-	unsigned long pci_cfg_set;
-	unsigned long pci_cfg_clr;
-};
+/* Programmable Counters 0 and 1 */
+#define SYS_BASE		0xB1900000
+#define SYS_COUNTER_CNTRL	(SYS_BASE + 0x14)
+#  define SYS_CNTRL_E1S		(1 << 23)
+#  define SYS_CNTRL_T1S		(1 << 20)
+#  define SYS_CNTRL_M21		(1 << 19)
+#  define SYS_CNTRL_M11		(1 << 18)
+#  define SYS_CNTRL_M01		(1 << 17)
+#  define SYS_CNTRL_C1S		(1 << 16)
+#  define SYS_CNTRL_BP		(1 << 14)
+#  define SYS_CNTRL_EN1		(1 << 13)
+#  define SYS_CNTRL_BT1		(1 << 12)
+#  define SYS_CNTRL_EN0		(1 << 11)
+#  define SYS_CNTRL_BT0		(1 << 10)
+#  define SYS_CNTRL_E0		(1 << 8)
+#  define SYS_CNTRL_E0S		(1 << 7)
+#  define SYS_CNTRL_32S		(1 << 5)
+#  define SYS_CNTRL_T0S		(1 << 4)
+#  define SYS_CNTRL_M20		(1 << 3)
+#  define SYS_CNTRL_M10		(1 << 2)
+#  define SYS_CNTRL_M00		(1 << 1)
+#  define SYS_CNTRL_C0S		(1 << 0)
 
-/* Multifunction pins: Each of these pins can either be assigned to the
- * GPIO controller or a on-chip peripheral.
- * Call "au1300_pinfunc_to_dev()" or "au1300_pinfunc_to_gpio()" to
- * assign one of these to either the GPIO controller or the device.
- */
-enum au1300_multifunc_pins {
-	/* wake-from-str pins 0-3 */
-	AU1300_PIN_WAKE0 = 0, AU1300_PIN_WAKE1, AU1300_PIN_WAKE2,
-	AU1300_PIN_WAKE3,
-	/* external clock sources for PSCs: 4-5 */
-	AU1300_PIN_EXTCLK0, AU1300_PIN_EXTCLK1,
-	/* 8bit MMC interface on SD0: 6-9 */
-	AU1300_PIN_SD0DAT4, AU1300_PIN_SD0DAT5, AU1300_PIN_SD0DAT6,
-	AU1300_PIN_SD0DAT7,
-	/* aux clk input for freqgen 3: 10 */
-	AU1300_PIN_FG3AUX,
-	/* UART1 pins: 11-18 */
-	AU1300_PIN_U1RI, AU1300_PIN_U1DCD, AU1300_PIN_U1DSR,
-	AU1300_PIN_U1CTS, AU1300_PIN_U1RTS, AU1300_PIN_U1DTR,
-	AU1300_PIN_U1RX, AU1300_PIN_U1TX,
-	/* UART0 pins: 19-24 */
-	AU1300_PIN_U0RI, AU1300_PIN_U0DCD, AU1300_PIN_U0DSR,
-	AU1300_PIN_U0CTS, AU1300_PIN_U0RTS, AU1300_PIN_U0DTR,
-	/* UART2: 25-26 */
-	AU1300_PIN_U2RX, AU1300_PIN_U2TX,
-	/* UART3: 27-28 */
-	AU1300_PIN_U3RX, AU1300_PIN_U3TX,
-	/* LCD controller PWMs, ext pixclock: 29-31 */
-	AU1300_PIN_LCDPWM0, AU1300_PIN_LCDPWM1, AU1300_PIN_LCDCLKIN,
-	/* SD1 interface: 32-37 */
-	AU1300_PIN_SD1DAT0, AU1300_PIN_SD1DAT1, AU1300_PIN_SD1DAT2,
-	AU1300_PIN_SD1DAT3, AU1300_PIN_SD1CMD, AU1300_PIN_SD1CLK,
-	/* SD2 interface: 38-43 */
-	AU1300_PIN_SD2DAT0, AU1300_PIN_SD2DAT1, AU1300_PIN_SD2DAT2,
-	AU1300_PIN_SD2DAT3, AU1300_PIN_SD2CMD, AU1300_PIN_SD2CLK,
-	/* PSC0/1 clocks: 44-45 */
-	AU1300_PIN_PSC0CLK, AU1300_PIN_PSC1CLK,
-	/* PSCs: 46-49/50-53/54-57/58-61 */
-	AU1300_PIN_PSC0SYNC0, AU1300_PIN_PSC0SYNC1, AU1300_PIN_PSC0D0,
-	AU1300_PIN_PSC0D1,
-	AU1300_PIN_PSC1SYNC0, AU1300_PIN_PSC1SYNC1, AU1300_PIN_PSC1D0,
-	AU1300_PIN_PSC1D1,
-	AU1300_PIN_PSC2SYNC0, AU1300_PIN_PSC2SYNC1, AU1300_PIN_PSC2D0,
-	AU1300_PIN_PSC2D1,
-	AU1300_PIN_PSC3SYNC0, AU1300_PIN_PSC3SYNC1, AU1300_PIN_PSC3D0,
-	AU1300_PIN_PSC3D1,
-	/* PCMCIA interface: 62-70 */
-	AU1300_PIN_PCE2, AU1300_PIN_PCE1, AU1300_PIN_PIOS16,
-	AU1300_PIN_PIOR, AU1300_PIN_PWE, AU1300_PIN_PWAIT,
-	AU1300_PIN_PREG, AU1300_PIN_POE, AU1300_PIN_PIOW,
-	/* camera interface H/V sync inputs: 71-72 */
-	AU1300_PIN_CIMLS, AU1300_PIN_CIMFS,
-	/* PSC2/3 clocks: 73-74 */
-	AU1300_PIN_PSC2CLK, AU1300_PIN_PSC3CLK,
-};
-
-/* GPIC (Au1300) pin management: arch/mips/alchemy/common/gpioint.c */
-extern void au1300_pinfunc_to_gpio(enum au1300_multifunc_pins gpio);
-extern void au1300_pinfunc_to_dev(enum au1300_multifunc_pins gpio);
-extern void au1300_set_irq_priority(unsigned int irq, int p);
-extern void au1300_set_dbdma_gpio(int dchan, unsigned int gpio);
+/* Programmable Counter 0 Registers */
+#define SYS_TOYTRIM		(SYS_BASE + 0)
+#define SYS_TOYWRITE		(SYS_BASE + 4)
+#define SYS_TOYMATCH0		(SYS_BASE + 8)
+#define SYS_TOYMATCH1		(SYS_BASE + 0xC)
+#define SYS_TOYMATCH2		(SYS_BASE + 0x10)
+#define SYS_TOYREAD		(SYS_BASE + 0x40)
 
-/* Au1300 allows to disconnect certain blocks from internal power supply */
-enum au1300_vss_block {
-	AU1300_VSS_MPE = 0,
-	AU1300_VSS_BSA,
-	AU1300_VSS_GPE,
-	AU1300_VSS_MGP,
-};
+/* Programmable Counter 1 Registers */
+#define SYS_RTCTRIM		(SYS_BASE + 0x44)
+#define SYS_RTCWRITE		(SYS_BASE + 0x48)
+#define SYS_RTCMATCH0		(SYS_BASE + 0x4C)
+#define SYS_RTCMATCH1		(SYS_BASE + 0x50)
+#define SYS_RTCMATCH2		(SYS_BASE + 0x54)
+#define SYS_RTCREAD		(SYS_BASE + 0x58)
 
-extern void au1300_vss_block_control(int block, int enable);
 
+/* GPIO */
+#define SYS_PINFUNC		0xB190002C
+#  define SYS_PF_USB		(1 << 15)	/* 2nd USB device/host */
+#  define SYS_PF_U3		(1 << 14)	/* GPIO23/U3TXD */
+#  define SYS_PF_U2		(1 << 13)	/* GPIO22/U2TXD */
+#  define SYS_PF_U1		(1 << 12)	/* GPIO21/U1TXD */
+#  define SYS_PF_SRC		(1 << 11)	/* GPIO6/SROMCKE */
+#  define SYS_PF_CK5		(1 << 10)	/* GPIO3/CLK5 */
+#  define SYS_PF_CK4		(1 << 9)	/* GPIO2/CLK4 */
+#  define SYS_PF_IRF		(1 << 8)	/* GPIO15/IRFIRSEL */
+#  define SYS_PF_UR3		(1 << 7)	/* GPIO[14:9]/UART3 */
+#  define SYS_PF_I2D		(1 << 6)	/* GPIO8/I2SDI */
+#  define SYS_PF_I2S		(1 << 5)	/* I2S/GPIO[29:31] */
+#  define SYS_PF_NI2		(1 << 4)	/* NI2/GPIO[24:28] */
+#  define SYS_PF_U0		(1 << 3)	/* U0TXD/GPIO20 */
+#  define SYS_PF_RD		(1 << 2)	/* IRTXD/GPIO19 */
+#  define SYS_PF_A97		(1 << 1)	/* AC97/SSL1 */
+#  define SYS_PF_S0		(1 << 0)	/* SSI_0/GPIO[16:18] */
 
-/* SOC Interrupt numbers */
-/* Au1000-style (IC0/1): 2 controllers with 32 sources each */
-#define AU1000_INTC0_INT_BASE	(MIPS_CPU_IRQ_BASE + 8)
-#define AU1000_INTC0_INT_LAST	(AU1000_INTC0_INT_BASE + 31)
-#define AU1000_INTC1_INT_BASE	(AU1000_INTC0_INT_LAST + 1)
-#define AU1000_INTC1_INT_LAST	(AU1000_INTC1_INT_BASE + 31)
-#define AU1000_MAX_INTR		AU1000_INTC1_INT_LAST
+/* Au1100 only */
+#  define SYS_PF_PC		(1 << 18)	/* PCMCIA/GPIO[207:204] */
+#  define SYS_PF_LCD		(1 << 17)	/* extern lcd/GPIO[203:200] */
+#  define SYS_PF_CS		(1 << 16)	/* EXTCLK0/32KHz to gpio2 */
+#  define SYS_PF_EX0		(1 << 9)	/* GPIO2/clock */
 
-/* Au1300-style (GPIC): 1 controller with up to 128 sources */
-#define ALCHEMY_GPIC_INT_BASE	(MIPS_CPU_IRQ_BASE + 8)
-#define ALCHEMY_GPIC_INT_NUM	128
-#define ALCHEMY_GPIC_INT_LAST	(ALCHEMY_GPIC_INT_BASE + ALCHEMY_GPIC_INT_NUM - 1)
+/* Au1550 only.	 Redefines lots of pins */
+#  define SYS_PF_PSC2_MASK	(7 << 17)
+#  define SYS_PF_PSC2_AC97	0
+#  define SYS_PF_PSC2_SPI	0
+#  define SYS_PF_PSC2_I2S	(1 << 17)
+#  define SYS_PF_PSC2_SMBUS	(3 << 17)
+#  define SYS_PF_PSC2_GPIO	(7 << 17)
+#  define SYS_PF_PSC3_MASK	(7 << 20)
+#  define SYS_PF_PSC3_AC97	0
+#  define SYS_PF_PSC3_SPI	0
+#  define SYS_PF_PSC3_I2S	(1 << 20)
+#  define SYS_PF_PSC3_SMBUS	(3 << 20)
+#  define SYS_PF_PSC3_GPIO	(7 << 20)
+#  define SYS_PF_PSC1_S1	(1 << 1)
+#  define SYS_PF_MUST_BE_SET	((1 << 5) | (1 << 2))
 
-enum soc_au1000_ints {
-	AU1000_FIRST_INT	= AU1000_INTC0_INT_BASE,
-	AU1000_UART0_INT	= AU1000_FIRST_INT,
-	AU1000_UART1_INT,
-	AU1000_UART2_INT,
-	AU1000_UART3_INT,
-	AU1000_SSI0_INT,
-	AU1000_SSI1_INT,
-	AU1000_DMA_INT_BASE,
+/* Au1200 only */
+#define SYS_PINFUNC_DMA		(1 << 31)
+#define SYS_PINFUNC_S0A		(1 << 30)
+#define SYS_PINFUNC_S1A		(1 << 29)
+#define SYS_PINFUNC_LP0		(1 << 28)
+#define SYS_PINFUNC_LP1		(1 << 27)
+#define SYS_PINFUNC_LD16	(1 << 26)
+#define SYS_PINFUNC_LD8		(1 << 25)
+#define SYS_PINFUNC_LD1		(1 << 24)
+#define SYS_PINFUNC_LD0		(1 << 23)
+#define SYS_PINFUNC_P1A		(3 << 21)
+#define SYS_PINFUNC_P1B		(1 << 20)
+#define SYS_PINFUNC_FS3		(1 << 19)
+#define SYS_PINFUNC_P0A		(3 << 17)
+#define SYS_PINFUNC_CS		(1 << 16)
+#define SYS_PINFUNC_CIM		(1 << 15)
+#define SYS_PINFUNC_P1C		(1 << 14)
+#define SYS_PINFUNC_U1T		(1 << 12)
+#define SYS_PINFUNC_U1R		(1 << 11)
+#define SYS_PINFUNC_EX1		(1 << 10)
+#define SYS_PINFUNC_EX0		(1 << 9)
+#define SYS_PINFUNC_U0R		(1 << 8)
+#define SYS_PINFUNC_MC		(1 << 7)
+#define SYS_PINFUNC_S0B		(1 << 6)
+#define SYS_PINFUNC_S0C		(1 << 5)
+#define SYS_PINFUNC_P0B		(1 << 4)
+#define SYS_PINFUNC_U0T		(1 << 3)
+#define SYS_PINFUNC_S1B		(1 << 2)
 
-	AU1000_TOY_INT		= AU1000_FIRST_INT + 14,
-	AU1000_TOY_MATCH0_INT,
-	AU1000_TOY_MATCH1_INT,
-	AU1000_TOY_MATCH2_INT,
-	AU1000_RTC_INT,
-	AU1000_RTC_MATCH0_INT,
-	AU1000_RTC_MATCH1_INT,
-	AU1000_RTC_MATCH2_INT,
-	AU1000_IRDA_TX_INT,
-	AU1000_IRDA_RX_INT,
-	AU1000_USB_DEV_REQ_INT,
-	AU1000_USB_DEV_SUS_INT,
-	AU1000_USB_HOST_INT,
-	AU1000_ACSYNC_INT,
-	AU1000_MAC0_DMA_INT,
-	AU1000_MAC1_DMA_INT,
-	AU1000_I2S_UO_INT,
-	AU1000_AC97C_INT,
-	AU1000_GPIO0_INT,
-	AU1000_GPIO1_INT,
-	AU1000_GPIO2_INT,
-	AU1000_GPIO3_INT,
-	AU1000_GPIO4_INT,
-	AU1000_GPIO5_INT,
-	AU1000_GPIO6_INT,
-	AU1000_GPIO7_INT,
-	AU1000_GPIO8_INT,
-	AU1000_GPIO9_INT,
-	AU1000_GPIO10_INT,
-	AU1000_GPIO11_INT,
-	AU1000_GPIO12_INT,
-	AU1000_GPIO13_INT,
-	AU1000_GPIO14_INT,
-	AU1000_GPIO15_INT,
-	AU1000_GPIO16_INT,
-	AU1000_GPIO17_INT,
-	AU1000_GPIO18_INT,
-	AU1000_GPIO19_INT,
-	AU1000_GPIO20_INT,
-	AU1000_GPIO21_INT,
-	AU1000_GPIO22_INT,
-	AU1000_GPIO23_INT,
-	AU1000_GPIO24_INT,
-	AU1000_GPIO25_INT,
-	AU1000_GPIO26_INT,
-	AU1000_GPIO27_INT,
-	AU1000_GPIO28_INT,
-	AU1000_GPIO29_INT,
-	AU1000_GPIO30_INT,
-	AU1000_GPIO31_INT,
-};
+/* Power Management */
+#define SYS_SCRATCH0		0xB1900018
+#define SYS_SCRATCH1		0xB190001C
+#define SYS_WAKEMSK		0xB1900034
+#define SYS_ENDIAN		0xB1900038
+#define SYS_POWERCTRL		0xB190003C
+#define SYS_WAKESRC		0xB190005C
+#define SYS_SLPPWR		0xB1900078
+#define SYS_SLEEP		0xB190007C
 
-enum soc_au1100_ints {
-	AU1100_FIRST_INT	= AU1000_INTC0_INT_BASE,
-	AU1100_UART0_INT	= AU1100_FIRST_INT,
-	AU1100_UART1_INT,
-	AU1100_SD_INT,
-	AU1100_UART3_INT,
-	AU1100_SSI0_INT,
-	AU1100_SSI1_INT,
-	AU1100_DMA_INT_BASE,
+#define SYS_WAKEMSK_D2		(1 << 9)
+#define SYS_WAKEMSK_M2		(1 << 8)
+#define SYS_WAKEMSK_GPIO(x)	(1 << (x))
 
-	AU1100_TOY_INT		= AU1100_FIRST_INT + 14,
-	AU1100_TOY_MATCH0_INT,
-	AU1100_TOY_MATCH1_INT,
-	AU1100_TOY_MATCH2_INT,
-	AU1100_RTC_INT,
-	AU1100_RTC_MATCH0_INT,
-	AU1100_RTC_MATCH1_INT,
-	AU1100_RTC_MATCH2_INT,
-	AU1100_IRDA_TX_INT,
-	AU1100_IRDA_RX_INT,
-	AU1100_USB_DEV_REQ_INT,
-	AU1100_USB_DEV_SUS_INT,
-	AU1100_USB_HOST_INT,
-	AU1100_ACSYNC_INT,
-	AU1100_MAC0_DMA_INT,
-	AU1100_GPIO208_215_INT,
-	AU1100_LCD_INT,
-	AU1100_AC97C_INT,
-	AU1100_GPIO0_INT,
-	AU1100_GPIO1_INT,
-	AU1100_GPIO2_INT,
-	AU1100_GPIO3_INT,
-	AU1100_GPIO4_INT,
-	AU1100_GPIO5_INT,
-	AU1100_GPIO6_INT,
-	AU1100_GPIO7_INT,
-	AU1100_GPIO8_INT,
-	AU1100_GPIO9_INT,
-	AU1100_GPIO10_INT,
-	AU1100_GPIO11_INT,
-	AU1100_GPIO12_INT,
-	AU1100_GPIO13_INT,
-	AU1100_GPIO14_INT,
-	AU1100_GPIO15_INT,
-	AU1100_GPIO16_INT,
-	AU1100_GPIO17_INT,
-	AU1100_GPIO18_INT,
-	AU1100_GPIO19_INT,
-	AU1100_GPIO20_INT,
-	AU1100_GPIO21_INT,
-	AU1100_GPIO22_INT,
-	AU1100_GPIO23_INT,
-	AU1100_GPIO24_INT,
-	AU1100_GPIO25_INT,
-	AU1100_GPIO26_INT,
-	AU1100_GPIO27_INT,
-	AU1100_GPIO28_INT,
-	AU1100_GPIO29_INT,
-	AU1100_GPIO30_INT,
-	AU1100_GPIO31_INT,
-};
+/* Clock Controller */
+#define SYS_FREQCTRL0		0xB1900020
+#  define SYS_FC_FRDIV2_BIT	22
+#  define SYS_FC_FRDIV2_MASK	(0xff << SYS_FC_FRDIV2_BIT)
+#  define SYS_FC_FE2		(1 << 21)
+#  define SYS_FC_FS2		(1 << 20)
+#  define SYS_FC_FRDIV1_BIT	12
+#  define SYS_FC_FRDIV1_MASK	(0xff << SYS_FC_FRDIV1_BIT)
+#  define SYS_FC_FE1		(1 << 11)
+#  define SYS_FC_FS1		(1 << 10)
+#  define SYS_FC_FRDIV0_BIT	2
+#  define SYS_FC_FRDIV0_MASK	(0xff << SYS_FC_FRDIV0_BIT)
+#  define SYS_FC_FE0		(1 << 1)
+#  define SYS_FC_FS0		(1 << 0)
+#define SYS_FREQCTRL1		0xB1900024
+#  define SYS_FC_FRDIV5_BIT	22
+#  define SYS_FC_FRDIV5_MASK	(0xff << SYS_FC_FRDIV5_BIT)
+#  define SYS_FC_FE5		(1 << 21)
+#  define SYS_FC_FS5		(1 << 20)
+#  define SYS_FC_FRDIV4_BIT	12
+#  define SYS_FC_FRDIV4_MASK	(0xff << SYS_FC_FRDIV4_BIT)
+#  define SYS_FC_FE4		(1 << 11)
+#  define SYS_FC_FS4		(1 << 10)
+#  define SYS_FC_FRDIV3_BIT	2
+#  define SYS_FC_FRDIV3_MASK	(0xff << SYS_FC_FRDIV3_BIT)
+#  define SYS_FC_FE3		(1 << 1)
+#  define SYS_FC_FS3		(1 << 0)
+#define SYS_CLKSRC		0xB1900028
+#  define SYS_CS_ME1_BIT	27
+#  define SYS_CS_ME1_MASK	(0x7 << SYS_CS_ME1_BIT)
+#  define SYS_CS_DE1		(1 << 26)
+#  define SYS_CS_CE1		(1 << 25)
+#  define SYS_CS_ME0_BIT	22
+#  define SYS_CS_ME0_MASK	(0x7 << SYS_CS_ME0_BIT)
+#  define SYS_CS_DE0		(1 << 21)
+#  define SYS_CS_CE0		(1 << 20)
+#  define SYS_CS_MI2_BIT	17
+#  define SYS_CS_MI2_MASK	(0x7 << SYS_CS_MI2_BIT)
+#  define SYS_CS_DI2		(1 << 16)
+#  define SYS_CS_CI2		(1 << 15)
 
-enum soc_au1500_ints {
-	AU1500_FIRST_INT	= AU1000_INTC0_INT_BASE,
-	AU1500_UART0_INT	= AU1500_FIRST_INT,
-	AU1500_PCI_INTA,
-	AU1500_PCI_INTB,
-	AU1500_UART3_INT,
-	AU1500_PCI_INTC,
-	AU1500_PCI_INTD,
-	AU1500_DMA_INT_BASE,
+#  define SYS_CS_ML_BIT		7
+#  define SYS_CS_ML_MASK	(0x7 << SYS_CS_ML_BIT)
+#  define SYS_CS_DL		(1 << 6)
+#  define SYS_CS_CL		(1 << 5)
 
-	AU1500_TOY_INT		= AU1500_FIRST_INT + 14,
-	AU1500_TOY_MATCH0_INT,
-	AU1500_TOY_MATCH1_INT,
-	AU1500_TOY_MATCH2_INT,
-	AU1500_RTC_INT,
-	AU1500_RTC_MATCH0_INT,
-	AU1500_RTC_MATCH1_INT,
-	AU1500_RTC_MATCH2_INT,
-	AU1500_PCI_ERR_INT,
-	AU1500_RESERVED_INT,
-	AU1500_USB_DEV_REQ_INT,
-	AU1500_USB_DEV_SUS_INT,
-	AU1500_USB_HOST_INT,
-	AU1500_ACSYNC_INT,
-	AU1500_MAC0_DMA_INT,
-	AU1500_MAC1_DMA_INT,
-	AU1500_AC97C_INT	= AU1500_FIRST_INT + 31,
-	AU1500_GPIO0_INT,
-	AU1500_GPIO1_INT,
-	AU1500_GPIO2_INT,
-	AU1500_GPIO3_INT,
-	AU1500_GPIO4_INT,
-	AU1500_GPIO5_INT,
-	AU1500_GPIO6_INT,
-	AU1500_GPIO7_INT,
-	AU1500_GPIO8_INT,
-	AU1500_GPIO9_INT,
-	AU1500_GPIO10_INT,
-	AU1500_GPIO11_INT,
-	AU1500_GPIO12_INT,
-	AU1500_GPIO13_INT,
-	AU1500_GPIO14_INT,
-	AU1500_GPIO15_INT,
-	AU1500_GPIO200_INT,
-	AU1500_GPIO201_INT,
-	AU1500_GPIO202_INT,
-	AU1500_GPIO203_INT,
-	AU1500_GPIO20_INT,
-	AU1500_GPIO204_INT,
-	AU1500_GPIO205_INT,
-	AU1500_GPIO23_INT,
-	AU1500_GPIO24_INT,
-	AU1500_GPIO25_INT,
-	AU1500_GPIO26_INT,
-	AU1500_GPIO27_INT,
-	AU1500_GPIO28_INT,
-	AU1500_GPIO206_INT,
-	AU1500_GPIO207_INT,
-	AU1500_GPIO208_215_INT,
-};
+#  define SYS_CS_MUH_BIT	12
+#  define SYS_CS_MUH_MASK	(0x7 << SYS_CS_MUH_BIT)
+#  define SYS_CS_DUH		(1 << 11)
+#  define SYS_CS_CUH		(1 << 10)
+#  define SYS_CS_MUD_BIT	7
+#  define SYS_CS_MUD_MASK	(0x7 << SYS_CS_MUD_BIT)
+#  define SYS_CS_DUD		(1 << 6)
+#  define SYS_CS_CUD		(1 << 5)
 
-enum soc_au1550_ints {
-	AU1550_FIRST_INT	= AU1000_INTC0_INT_BASE,
-	AU1550_UART0_INT	= AU1550_FIRST_INT,
-	AU1550_PCI_INTA,
-	AU1550_PCI_INTB,
-	AU1550_DDMA_INT,
-	AU1550_CRYPTO_INT,
-	AU1550_PCI_INTC,
-	AU1550_PCI_INTD,
-	AU1550_PCI_RST_INT,
-	AU1550_UART1_INT,
-	AU1550_UART3_INT,
-	AU1550_PSC0_INT,
-	AU1550_PSC1_INT,
-	AU1550_PSC2_INT,
-	AU1550_PSC3_INT,
-	AU1550_TOY_INT,
-	AU1550_TOY_MATCH0_INT,
-	AU1550_TOY_MATCH1_INT,
-	AU1550_TOY_MATCH2_INT,
-	AU1550_RTC_INT,
-	AU1550_RTC_MATCH0_INT,
-	AU1550_RTC_MATCH1_INT,
-	AU1550_RTC_MATCH2_INT,
+#  define SYS_CS_MIR_BIT	2
+#  define SYS_CS_MIR_MASK	(0x7 << SYS_CS_MIR_BIT)
+#  define SYS_CS_DIR		(1 << 1)
+#  define SYS_CS_CIR		(1 << 0)
 
-	AU1550_NAND_INT		= AU1550_FIRST_INT + 23,
-	AU1550_USB_DEV_REQ_INT,
-	AU1550_USB_DEV_SUS_INT,
-	AU1550_USB_HOST_INT,
-	AU1550_MAC0_DMA_INT,
-	AU1550_MAC1_DMA_INT,
-	AU1550_GPIO0_INT	= AU1550_FIRST_INT + 32,
-	AU1550_GPIO1_INT,
-	AU1550_GPIO2_INT,
-	AU1550_GPIO3_INT,
-	AU1550_GPIO4_INT,
-	AU1550_GPIO5_INT,
-	AU1550_GPIO6_INT,
-	AU1550_GPIO7_INT,
-	AU1550_GPIO8_INT,
-	AU1550_GPIO9_INT,
-	AU1550_GPIO10_INT,
-	AU1550_GPIO11_INT,
-	AU1550_GPIO12_INT,
-	AU1550_GPIO13_INT,
-	AU1550_GPIO14_INT,
-	AU1550_GPIO15_INT,
-	AU1550_GPIO200_INT,
-	AU1550_GPIO201_205_INT, /* Logical or of GPIO201:205 */
-	AU1550_GPIO16_INT,
-	AU1550_GPIO17_INT,
-	AU1550_GPIO20_INT,
-	AU1550_GPIO21_INT,
-	AU1550_GPIO22_INT,
-	AU1550_GPIO23_INT,
-	AU1550_GPIO24_INT,
-	AU1550_GPIO25_INT,
-	AU1550_GPIO26_INT,
-	AU1550_GPIO27_INT,
-	AU1550_GPIO28_INT,
-	AU1550_GPIO206_INT,
-	AU1550_GPIO207_INT,
-	AU1550_GPIO208_215_INT, /* Logical or of GPIO208:215 */
-};
+#  define SYS_CS_MUX_AUX	0x1
+#  define SYS_CS_MUX_FQ0	0x2
+#  define SYS_CS_MUX_FQ1	0x3
+#  define SYS_CS_MUX_FQ2	0x4
+#  define SYS_CS_MUX_FQ3	0x5
+#  define SYS_CS_MUX_FQ4	0x6
+#  define SYS_CS_MUX_FQ5	0x7
+#define SYS_CPUPLL		0xB1900060
+#define SYS_AUXPLL		0xB1900064
 
-enum soc_au1200_ints {
-	AU1200_FIRST_INT	= AU1000_INTC0_INT_BASE,
-	AU1200_UART0_INT	= AU1200_FIRST_INT,
-	AU1200_SWT_INT,
-	AU1200_SD_INT,
-	AU1200_DDMA_INT,
-	AU1200_MAE_BE_INT,
-	AU1200_GPIO200_INT,
-	AU1200_GPIO201_INT,
-	AU1200_GPIO202_INT,
-	AU1200_UART1_INT,
-	AU1200_MAE_FE_INT,
-	AU1200_PSC0_INT,
-	AU1200_PSC1_INT,
-	AU1200_AES_INT,
-	AU1200_CAMERA_INT,
-	AU1200_TOY_INT,
-	AU1200_TOY_MATCH0_INT,
-	AU1200_TOY_MATCH1_INT,
-	AU1200_TOY_MATCH2_INT,
-	AU1200_RTC_INT,
-	AU1200_RTC_MATCH0_INT,
-	AU1200_RTC_MATCH1_INT,
-	AU1200_RTC_MATCH2_INT,
-	AU1200_GPIO203_INT,
-	AU1200_NAND_INT,
-	AU1200_GPIO204_INT,
-	AU1200_GPIO205_INT,
-	AU1200_GPIO206_INT,
-	AU1200_GPIO207_INT,
-	AU1200_GPIO208_215_INT, /* Logical OR of 208:215 */
-	AU1200_USB_INT,
-	AU1200_LCD_INT,
-	AU1200_MAE_BOTH_INT,
-	AU1200_GPIO0_INT,
-	AU1200_GPIO1_INT,
-	AU1200_GPIO2_INT,
-	AU1200_GPIO3_INT,
-	AU1200_GPIO4_INT,
-	AU1200_GPIO5_INT,
-	AU1200_GPIO6_INT,
-	AU1200_GPIO7_INT,
-	AU1200_GPIO8_INT,
-	AU1200_GPIO9_INT,
-	AU1200_GPIO10_INT,
-	AU1200_GPIO11_INT,
-	AU1200_GPIO12_INT,
-	AU1200_GPIO13_INT,
-	AU1200_GPIO14_INT,
-	AU1200_GPIO15_INT,
-	AU1200_GPIO16_INT,
-	AU1200_GPIO17_INT,
-	AU1200_GPIO18_INT,
-	AU1200_GPIO19_INT,
-	AU1200_GPIO20_INT,
-	AU1200_GPIO21_INT,
-	AU1200_GPIO22_INT,
-	AU1200_GPIO23_INT,
-	AU1200_GPIO24_INT,
-	AU1200_GPIO25_INT,
-	AU1200_GPIO26_INT,
-	AU1200_GPIO27_INT,
-	AU1200_GPIO28_INT,
-	AU1200_GPIO29_INT,
-	AU1200_GPIO30_INT,
-	AU1200_GPIO31_INT,
-};
-
-#endif /* !defined (_LANGUAGE_ASSEMBLY) */
-
-/* Au1300 peripheral interrupt numbers */
-#define AU1300_FIRST_INT	(ALCHEMY_GPIC_INT_BASE)
-#define AU1300_UART1_INT	(AU1300_FIRST_INT + 17)
-#define AU1300_UART2_INT	(AU1300_FIRST_INT + 25)
-#define AU1300_UART3_INT	(AU1300_FIRST_INT + 27)
-#define AU1300_SD1_INT		(AU1300_FIRST_INT + 32)
-#define AU1300_SD2_INT		(AU1300_FIRST_INT + 38)
-#define AU1300_PSC0_INT		(AU1300_FIRST_INT + 48)
-#define AU1300_PSC1_INT		(AU1300_FIRST_INT + 52)
-#define AU1300_PSC2_INT		(AU1300_FIRST_INT + 56)
-#define AU1300_PSC3_INT		(AU1300_FIRST_INT + 60)
-#define AU1300_NAND_INT		(AU1300_FIRST_INT + 62)
-#define AU1300_DDMA_INT		(AU1300_FIRST_INT + 75)
-#define AU1300_MMU_INT		(AU1300_FIRST_INT + 76)
-#define AU1300_MPU_INT		(AU1300_FIRST_INT + 77)
-#define AU1300_GPU_INT		(AU1300_FIRST_INT + 78)
-#define AU1300_UDMA_INT		(AU1300_FIRST_INT + 79)
-#define AU1300_TOY_INT		(AU1300_FIRST_INT + 80)
-#define AU1300_TOY_MATCH0_INT	(AU1300_FIRST_INT + 81)
-#define AU1300_TOY_MATCH1_INT	(AU1300_FIRST_INT + 82)
-#define AU1300_TOY_MATCH2_INT	(AU1300_FIRST_INT + 83)
-#define AU1300_RTC_INT		(AU1300_FIRST_INT + 84)
-#define AU1300_RTC_MATCH0_INT	(AU1300_FIRST_INT + 85)
-#define AU1300_RTC_MATCH1_INT	(AU1300_FIRST_INT + 86)
-#define AU1300_RTC_MATCH2_INT	(AU1300_FIRST_INT + 87)
-#define AU1300_UART0_INT	(AU1300_FIRST_INT + 88)
-#define AU1300_SD0_INT		(AU1300_FIRST_INT + 89)
-#define AU1300_USB_INT		(AU1300_FIRST_INT + 90)
-#define AU1300_LCD_INT		(AU1300_FIRST_INT + 91)
-#define AU1300_BSA_INT		(AU1300_FIRST_INT + 92)
-#define AU1300_MPE_INT		(AU1300_FIRST_INT + 93)
-#define AU1300_ITE_INT		(AU1300_FIRST_INT + 94)
-#define AU1300_AES_INT		(AU1300_FIRST_INT + 95)
-#define AU1300_CIM_INT		(AU1300_FIRST_INT + 96)
 
-/**********************************************************************/
-
-/*
- * Physical base addresses for integrated peripherals
- * 0..au1000 1..au1500 2..au1100 3..au1550 4..au1200 5..au1300
+/* The PCI chip selects are outside the 32bit space, and since we can't
+ * just program the 36bit addresses into BARs, we have to take a chunk
+ * out of the 32bit space and reserve it for PCI.  When these addresses
+ * are ioremap()ed, they'll be fixed up to the real 36bit address before
+ * being passed to the real ioremap function.
  */
+#define ALCHEMY_PCI_MEMWIN_START	(AU1500_PCI_MEM_PHYS_ADDR >> 4)
+#define ALCHEMY_PCI_MEMWIN_END		(ALCHEMY_PCI_MEMWIN_START + 0x0FFFFFFF)
 
-#define AU1000_AC97_PHYS_ADDR		0x10000000 /* 012 */
-#define AU1300_ROM_PHYS_ADDR		0x10000000 /* 5 */
-#define AU1300_OTP_PHYS_ADDR		0x10002000 /* 5 */
-#define AU1300_VSS_PHYS_ADDR		0x10003000 /* 5 */
-#define AU1300_UART0_PHYS_ADDR		0x10100000 /* 5 */
-#define AU1300_UART1_PHYS_ADDR		0x10101000 /* 5 */
-#define AU1300_UART2_PHYS_ADDR		0x10102000 /* 5 */
-#define AU1300_UART3_PHYS_ADDR		0x10103000 /* 5 */
-#define AU1000_USB_OHCI_PHYS_ADDR	0x10100000 /* 012 */
-#define AU1000_USB_UDC_PHYS_ADDR	0x10200000 /* 0123 */
-#define AU1300_GPIC_PHYS_ADDR		0x10200000 /* 5 */
-#define AU1000_IRDA_PHYS_ADDR		0x10300000 /* 02 */
-#define AU1200_AES_PHYS_ADDR		0x10300000 /* 45 */
-#define AU1000_IC0_PHYS_ADDR		0x10400000 /* 01234 */
-#define AU1300_GPU_PHYS_ADDR		0x10500000 /* 5 */
-#define AU1000_MAC0_PHYS_ADDR		0x10500000 /* 023 */
-#define AU1000_MAC1_PHYS_ADDR		0x10510000 /* 023 */
-#define AU1000_MACEN_PHYS_ADDR		0x10520000 /* 023 */
-#define AU1100_SD0_PHYS_ADDR		0x10600000 /* 245 */
-#define AU1300_SD1_PHYS_ADDR		0x10601000 /* 5 */
-#define AU1300_SD2_PHYS_ADDR		0x10602000 /* 5 */
-#define AU1100_SD1_PHYS_ADDR		0x10680000 /* 24 */
-#define AU1300_SYS_PHYS_ADDR		0x10900000 /* 5 */
-#define AU1550_PSC2_PHYS_ADDR		0x10A00000 /* 3 */
-#define AU1550_PSC3_PHYS_ADDR		0x10B00000 /* 3 */
-#define AU1300_PSC0_PHYS_ADDR		0x10A00000 /* 5 */
-#define AU1300_PSC1_PHYS_ADDR		0x10A01000 /* 5 */
-#define AU1300_PSC2_PHYS_ADDR		0x10A02000 /* 5 */
-#define AU1300_PSC3_PHYS_ADDR		0x10A03000 /* 5 */
-#define AU1000_I2S_PHYS_ADDR		0x11000000 /* 02 */
-#define AU1500_MAC0_PHYS_ADDR		0x11500000 /* 1 */
-#define AU1500_MAC1_PHYS_ADDR		0x11510000 /* 1 */
-#define AU1500_MACEN_PHYS_ADDR		0x11520000 /* 1 */
-#define AU1000_UART0_PHYS_ADDR		0x11100000 /* 01234 */
-#define AU1200_SWCNT_PHYS_ADDR		0x1110010C /* 4 */
-#define AU1000_UART1_PHYS_ADDR		0x11200000 /* 0234 */
-#define AU1000_UART2_PHYS_ADDR		0x11300000 /* 0 */
-#define AU1000_UART3_PHYS_ADDR		0x11400000 /* 0123 */
-#define AU1000_SSI0_PHYS_ADDR		0x11600000 /* 02 */
-#define AU1000_SSI1_PHYS_ADDR		0x11680000 /* 02 */
-#define AU1500_GPIO2_PHYS_ADDR		0x11700000 /* 1234 */
-#define AU1000_IC1_PHYS_ADDR		0x11800000 /* 01234 */
-#define AU1000_SYS_PHYS_ADDR		0x11900000 /* 012345 */
-#define AU1550_PSC0_PHYS_ADDR		0x11A00000 /* 34 */
-#define AU1550_PSC1_PHYS_ADDR		0x11B00000 /* 34 */
-#define AU1000_MEM_PHYS_ADDR		0x14000000 /* 01234 */
-#define AU1000_STATIC_MEM_PHYS_ADDR	0x14001000 /* 01234 */
-#define AU1300_UDMA_PHYS_ADDR		0x14001800 /* 5 */
-#define AU1000_DMA_PHYS_ADDR		0x14002000 /* 012 */
-#define AU1550_DBDMA_PHYS_ADDR		0x14002000 /* 345 */
-#define AU1550_DBDMA_CONF_PHYS_ADDR	0x14003000 /* 345 */
-#define AU1000_MACDMA0_PHYS_ADDR	0x14004000 /* 0123 */
-#define AU1000_MACDMA1_PHYS_ADDR	0x14004200 /* 0123 */
-#define AU1200_CIM_PHYS_ADDR		0x14004000 /* 45 */
-#define AU1500_PCI_PHYS_ADDR		0x14005000 /* 13 */
-#define AU1550_PE_PHYS_ADDR		0x14008000 /* 3 */
-#define AU1200_MAEBE_PHYS_ADDR		0x14010000 /* 4 */
-#define AU1200_MAEFE_PHYS_ADDR		0x14012000 /* 4 */
-#define AU1300_MAEITE_PHYS_ADDR		0x14010000 /* 5 */
-#define AU1300_MAEMPE_PHYS_ADDR		0x14014000 /* 5 */
-#define AU1550_USB_OHCI_PHYS_ADDR	0x14020000 /* 3 */
-#define AU1200_USB_CTL_PHYS_ADDR	0x14020000 /* 4 */
-#define AU1200_USB_OTG_PHYS_ADDR	0x14020020 /* 4 */
-#define AU1200_USB_OHCI_PHYS_ADDR	0x14020100 /* 4 */
-#define AU1200_USB_EHCI_PHYS_ADDR	0x14020200 /* 4 */
-#define AU1200_USB_UDC_PHYS_ADDR	0x14022000 /* 4 */
-#define AU1300_USB_EHCI_PHYS_ADDR	0x14020000 /* 5 */
-#define AU1300_USB_OHCI0_PHYS_ADDR	0x14020400 /* 5 */
-#define AU1300_USB_OHCI1_PHYS_ADDR	0x14020800 /* 5 */
-#define AU1300_USB_CTL_PHYS_ADDR	0x14021000 /* 5 */
-#define AU1300_USB_OTG_PHYS_ADDR	0x14022000 /* 5 */
-#define AU1300_MAEBSA_PHYS_ADDR		0x14030000 /* 5 */
-#define AU1100_LCD_PHYS_ADDR		0x15000000 /* 2 */
-#define AU1200_LCD_PHYS_ADDR		0x15000000 /* 45 */
-#define AU1500_PCI_MEM_PHYS_ADDR	0x400000000ULL /* 13 */
-#define AU1500_PCI_IO_PHYS_ADDR		0x500000000ULL /* 13 */
-#define AU1500_PCI_CONFIG0_PHYS_ADDR	0x600000000ULL /* 13 */
-#define AU1500_PCI_CONFIG1_PHYS_ADDR	0x680000000ULL /* 13 */
-#define AU1000_PCMCIA_IO_PHYS_ADDR	0xF00000000ULL /* 012345 */
-#define AU1000_PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL /* 012345 */
-#define AU1000_PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL /* 012345 */
-
-/**********************************************************************/
-
-
-/*
- * Au1300 GPIO+INT controller (GPIC) register offsets and bits
- * Registers are 128bits (0x10 bytes), divided into 4 "banks".
+/* for PCI IO it's simpler because we get to do the ioremap ourselves and then
+ * adjust the device's resources.
  */
-#define AU1300_GPIC_PINVAL	0x0000
-#define AU1300_GPIC_PINVALCLR	0x0010
-#define AU1300_GPIC_IPEND	0x0020
-#define AU1300_GPIC_PRIENC	0x0030
-#define AU1300_GPIC_IEN		0x0040	/* int_mask in manual */
-#define AU1300_GPIC_IDIS	0x0050	/* int_maskclr in manual */
-#define AU1300_GPIC_DMASEL	0x0060
-#define AU1300_GPIC_DEVSEL	0x0080
-#define AU1300_GPIC_DEVCLR	0x0090
-#define AU1300_GPIC_RSTVAL	0x00a0
-/* pin configuration space. one 32bit register for up to 128 IRQs */
-#define AU1300_GPIC_PINCFG	0x1000
-
-#define GPIC_GPIO_TO_BIT(gpio)	\
-	(1 << ((gpio) & 0x1f))
-
-#define GPIC_GPIO_BANKOFF(gpio) \
-	(((gpio) >> 5) * 4)
-
-/* Pin Control bits: who owns the pin, what does it do */
-#define GPIC_CFG_PC_GPIN		0
-#define GPIC_CFG_PC_DEV			1
-#define GPIC_CFG_PC_GPOLOW		2
-#define GPIC_CFG_PC_GPOHIGH		3
-#define GPIC_CFG_PC_MASK		3
+#define ALCHEMY_PCI_IOWIN_START		0x00001000
+#define ALCHEMY_PCI_IOWIN_END		0x0000FFFF
 
-/* assign pin to MIPS IRQ line */
-#define GPIC_CFG_IL_SET(x)	(((x) & 3) << 2)
-#define GPIC_CFG_IL_MASK	(3 << 2)
+#ifdef CONFIG_PCI
 
-/* pin interrupt type setup */
-#define GPIC_CFG_IC_OFF		(0 << 4)
-#define GPIC_CFG_IC_LEVEL_LOW	(1 << 4)
-#define GPIC_CFG_IC_LEVEL_HIGH	(2 << 4)
-#define GPIC_CFG_IC_EDGE_FALL	(5 << 4)
-#define GPIC_CFG_IC_EDGE_RISE	(6 << 4)
-#define GPIC_CFG_IC_EDGE_BOTH	(7 << 4)
-#define GPIC_CFG_IC_MASK	(7 << 4)
+#define IOPORT_RESOURCE_START	0x00001000	/* skip legacy probing */
+#define IOPORT_RESOURCE_END	0xffffffff
+#define IOMEM_RESOURCE_START	0x10000000
+#define IOMEM_RESOURCE_END	0xfffffffffULL
 
-/* allow interrupt to wake cpu from 'wait' */
-#define GPIC_CFG_IDLEWAKE	(1 << 7)
+#else
 
-/***********************************************************************/
+/* Don't allow any legacy ports probing */
+#define IOPORT_RESOURCE_START	0x10000000
+#define IOPORT_RESOURCE_END	0xffffffff
+#define IOMEM_RESOURCE_START	0x10000000
+#define IOMEM_RESOURCE_END	0xfffffffffULL
 
-/* Au1000 SDRAM memory controller register offsets */
-#define AU1000_MEM_SDMODE0		0x0000
-#define AU1000_MEM_SDMODE1		0x0004
-#define AU1000_MEM_SDMODE2		0x0008
-#define AU1000_MEM_SDADDR0		0x000C
-#define AU1000_MEM_SDADDR1		0x0010
-#define AU1000_MEM_SDADDR2		0x0014
-#define AU1000_MEM_SDREFCFG		0x0018
-#define AU1000_MEM_SDPRECMD		0x001C
-#define AU1000_MEM_SDAUTOREF		0x0020
-#define AU1000_MEM_SDWRMD0		0x0024
-#define AU1000_MEM_SDWRMD1		0x0028
-#define AU1000_MEM_SDWRMD2		0x002C
-#define AU1000_MEM_SDSLEEP		0x0030
-#define AU1000_MEM_SDSMCKE		0x0034
+#endif
 
-/* MEM_SDMODE register content definitions */
-#define MEM_SDMODE_F		(1 << 22)
-#define MEM_SDMODE_SR		(1 << 21)
-#define MEM_SDMODE_BS		(1 << 20)
-#define MEM_SDMODE_RS		(3 << 18)
-#define MEM_SDMODE_CS		(7 << 15)
-#define MEM_SDMODE_TRAS		(15 << 11)
-#define MEM_SDMODE_TMRD		(3 << 9)
-#define MEM_SDMODE_TWR		(3 << 7)
-#define MEM_SDMODE_TRP		(3 << 5)
-#define MEM_SDMODE_TRCD		(3 << 3)
-#define MEM_SDMODE_TCL		(7 << 0)
+/* PCI controller block register offsets */
+#define PCI_REG_CMEM		0x0000
+#define PCI_REG_CONFIG		0x0004
+#define PCI_REG_B2BMASK_CCH	0x0008
+#define PCI_REG_B2BBASE0_VID	0x000C
+#define PCI_REG_B2BBASE1_SID	0x0010
+#define PCI_REG_MWMASK_DEV	0x0014
+#define PCI_REG_MWBASE_REV_CCL	0x0018
+#define PCI_REG_ERR_ADDR	0x001C
+#define PCI_REG_SPEC_INTACK	0x0020
+#define PCI_REG_ID		0x0100
+#define PCI_REG_STATCMD		0x0104
+#define PCI_REG_CLASSREV	0x0108
+#define PCI_REG_PARAM		0x010C
+#define PCI_REG_MBAR		0x0110
+#define PCI_REG_TIMEOUT		0x0140
 
-#define MEM_SDMODE_BS_2Bank	(0 << 20)
-#define MEM_SDMODE_BS_4Bank	(1 << 20)
-#define MEM_SDMODE_RS_11Row	(0 << 18)
-#define MEM_SDMODE_RS_12Row	(1 << 18)
-#define MEM_SDMODE_RS_13Row	(2 << 18)
-#define MEM_SDMODE_RS_N(N)	((N) << 18)
-#define MEM_SDMODE_CS_7Col	(0 << 15)
-#define MEM_SDMODE_CS_8Col	(1 << 15)
-#define MEM_SDMODE_CS_9Col	(2 << 15)
-#define MEM_SDMODE_CS_10Col	(3 << 15)
-#define MEM_SDMODE_CS_11Col	(4 << 15)
-#define MEM_SDMODE_CS_N(N)	((N) << 15)
-#define MEM_SDMODE_TRAS_N(N)	((N) << 11)
-#define MEM_SDMODE_TMRD_N(N)	((N) << 9)
-#define MEM_SDMODE_TWR_N(N)	((N) << 7)
-#define MEM_SDMODE_TRP_N(N)	((N) << 5)
-#define MEM_SDMODE_TRCD_N(N)	((N) << 3)
-#define MEM_SDMODE_TCL_N(N)	((N) << 0)
-
-/* MEM_SDADDR register contents definitions */
-#define MEM_SDADDR_E		(1 << 20)
-#define MEM_SDADDR_CSBA		(0x03FF << 10)
-#define MEM_SDADDR_CSMASK	(0x03FF << 0)
-#define MEM_SDADDR_CSBA_N(N)	((N) & (0x03FF << 22) >> 12)
-#define MEM_SDADDR_CSMASK_N(N)	((N)&(0x03FF << 22) >> 22)
-
-/* MEM_SDREFCFG register content definitions */
-#define MEM_SDREFCFG_TRC	(15 << 28)
-#define MEM_SDREFCFG_TRPM	(3 << 26)
-#define MEM_SDREFCFG_E		(1 << 25)
-#define MEM_SDREFCFG_RE		(0x1ffffff << 0)
-#define MEM_SDREFCFG_TRC_N(N)	((N) << MEM_SDREFCFG_TRC)
-#define MEM_SDREFCFG_TRPM_N(N)	((N) << MEM_SDREFCFG_TRPM)
-#define MEM_SDREFCFG_REF_N(N)	(N)
+/* PCI controller block register bits */
+#define PCI_CMEM_E		(1 << 28)	/* enable cacheable memory */
+#define PCI_CMEM_CMBASE(x)	(((x) & 0x3fff) << 14)
+#define PCI_CMEM_CMMASK(x)	((x) & 0x3fff)
+#define PCI_CONFIG_ERD		(1 << 27) /* pci error during R/W */
+#define PCI_CONFIG_ET		(1 << 26) /* error in target mode */
+#define PCI_CONFIG_EF		(1 << 25) /* fatal error */
+#define PCI_CONFIG_EP		(1 << 24) /* parity error */
+#define PCI_CONFIG_EM		(1 << 23) /* multiple errors */
+#define PCI_CONFIG_BM		(1 << 22) /* bad master error */
+#define PCI_CONFIG_PD		(1 << 20) /* PCI Disable */
+#define PCI_CONFIG_BME		(1 << 19) /* Byte Mask Enable for reads */
+#define PCI_CONFIG_NC		(1 << 16) /* mark mem access non-coherent */
+#define PCI_CONFIG_IA		(1 << 15) /* INTA# enabled (target mode) */
+#define PCI_CONFIG_IP		(1 << 13) /* int on PCI_PERR# */
+#define PCI_CONFIG_IS		(1 << 12) /* int on PCI_SERR# */
+#define PCI_CONFIG_IMM		(1 << 11) /* int on master abort */
+#define PCI_CONFIG_ITM		(1 << 10) /* int on target abort (as master) */
+#define PCI_CONFIG_ITT		(1 << 9)  /* int on target abort (as target) */
+#define PCI_CONFIG_IPB		(1 << 8)  /* int on PERR# in bus master acc */
+#define PCI_CONFIG_SIC_NO	(0 << 6)  /* no byte mask changes */
+#define PCI_CONFIG_SIC_BA_ADR	(1 << 6)  /* on byte/hw acc, invert adr bits */
+#define PCI_CONFIG_SIC_HWA_DAT	(2 << 6)  /* on halfword acc, swap data */
+#define PCI_CONFIG_SIC_ALL	(3 << 6)  /* swap data bytes on all accesses */
+#define PCI_CONFIG_ST		(1 << 5)  /* swap data by target transactions */
+#define PCI_CONFIG_SM		(1 << 4)  /* swap data from PCI ctl */
+#define PCI_CONFIG_AEN		(1 << 3)  /* enable internal arbiter */
+#define PCI_CONFIG_R2H		(1 << 2)  /* REQ2# to hi-prio arbiter */
+#define PCI_CONFIG_R1H		(1 << 1)  /* REQ1# to hi-prio arbiter */
+#define PCI_CONFIG_CH		(1 << 0)  /* PCI ctl to hi-prio arbiter */
+#define PCI_B2BMASK_B2BMASK(x)	(((x) & 0xffff) << 16)
+#define PCI_B2BMASK_CCH(x)	((x) & 0xffff) /* 16 upper bits of class code */
+#define PCI_B2BBASE0_VID_B0(x)	(((x) & 0xffff) << 16)
+#define PCI_B2BBASE0_VID_SV(x)	((x) & 0xffff)
+#define PCI_B2BBASE1_SID_B1(x)	(((x) & 0xffff) << 16)
+#define PCI_B2BBASE1_SID_SI(x)	((x) & 0xffff)
+#define PCI_MWMASKDEV_MWMASK(x) (((x) & 0xffff) << 16)
+#define PCI_MWMASKDEV_DEVID(x)	((x) & 0xffff)
+#define PCI_MWBASEREVCCL_BASE(x) (((x) & 0xffff) << 16)
+#define PCI_MWBASEREVCCL_REV(x)	 (((x) & 0xff) << 8)
+#define PCI_MWBASEREVCCL_CCL(x)	 ((x) & 0xff)
+#define PCI_ID_DID(x)		(((x) & 0xffff) << 16)
+#define PCI_ID_VID(x)		((x) & 0xffff)
+#define PCI_STATCMD_STATUS(x)	(((x) & 0xffff) << 16)
+#define PCI_STATCMD_CMD(x)	((x) & 0xffff)
+#define PCI_CLASSREV_CLASS(x)	(((x) & 0x00ffffff) << 8)
+#define PCI_CLASSREV_REV(x)	((x) & 0xff)
+#define PCI_PARAM_BIST(x)	(((x) & 0xff) << 24)
+#define PCI_PARAM_HT(x)		(((x) & 0xff) << 16)
+#define PCI_PARAM_LT(x)		(((x) & 0xff) << 8)
+#define PCI_PARAM_CLS(x)	((x) & 0xff)
+#define PCI_TIMEOUT_RETRIES(x)	(((x) & 0xff) << 8)	/* max retries */
+#define PCI_TIMEOUT_TO(x)	((x) & 0xff)	/* target ready timeout */
 
-/* Au1550 SDRAM Register Offsets */
-#define AU1550_MEM_SDMODE0		0x0800
-#define AU1550_MEM_SDMODE1		0x0808
-#define AU1550_MEM_SDMODE2		0x0810
-#define AU1550_MEM_SDADDR0		0x0820
-#define AU1550_MEM_SDADDR1		0x0828
-#define AU1550_MEM_SDADDR2		0x0830
-#define AU1550_MEM_SDCONFIGA		0x0840
-#define AU1550_MEM_SDCONFIGB		0x0848
-#define AU1550_MEM_SDSTAT		0x0850
-#define AU1550_MEM_SDERRADDR		0x0858
-#define AU1550_MEM_SDSTRIDE0		0x0860
-#define AU1550_MEM_SDSTRIDE1		0x0868
-#define AU1550_MEM_SDSTRIDE2		0x0870
-#define AU1550_MEM_SDWRMD0		0x0880
-#define AU1550_MEM_SDWRMD1		0x0888
-#define AU1550_MEM_SDWRMD2		0x0890
-#define AU1550_MEM_SDPRECMD		0x08C0
-#define AU1550_MEM_SDAUTOREF		0x08C8
-#define AU1550_MEM_SDSREF		0x08D0
-#define AU1550_MEM_SDSLEEP		MEM_SDSREF
 
-/* Static Bus Controller */
-#define MEM_STCFG0		0xB4001000
-#define MEM_STTIME0		0xB4001004
-#define MEM_STADDR0		0xB4001008
+/**********************************************************************/
 
-#define MEM_STCFG1		0xB4001010
-#define MEM_STTIME1		0xB4001014
-#define MEM_STADDR1		0xB4001018
 
-#define MEM_STCFG2		0xB4001020
-#define MEM_STTIME2		0xB4001024
-#define MEM_STADDR2		0xB4001028
+#ifndef _LANGUAGE_ASSEMBLY
 
-#define MEM_STCFG3		0xB4001030
-#define MEM_STTIME3		0xB4001034
-#define MEM_STADDR3		0xB4001038
+#include <linux/delay.h>
+#include <linux/types.h>
 
-#define MEM_STNDCTL		0xB4001100
-#define MEM_STSTAT		0xB4001104
+#include <linux/io.h>
+#include <linux/irq.h>
 
-#define MEM_STNAND_CMD		0x0
-#define MEM_STNAND_ADDR		0x4
-#define MEM_STNAND_DATA		0x20
+#include <asm/cpu.h>
 
+/* cpu pipeline flush */
+void static inline au_sync(void)
+{
+	__asm__ volatile ("sync");
+}
 
-/* Programmable Counters 0 and 1 */
-#define SYS_BASE		0xB1900000
-#define SYS_COUNTER_CNTRL	(SYS_BASE + 0x14)
-#  define SYS_CNTRL_E1S		(1 << 23)
-#  define SYS_CNTRL_T1S		(1 << 20)
-#  define SYS_CNTRL_M21		(1 << 19)
-#  define SYS_CNTRL_M11		(1 << 18)
-#  define SYS_CNTRL_M01		(1 << 17)
-#  define SYS_CNTRL_C1S		(1 << 16)
-#  define SYS_CNTRL_BP		(1 << 14)
-#  define SYS_CNTRL_EN1		(1 << 13)
-#  define SYS_CNTRL_BT1		(1 << 12)
-#  define SYS_CNTRL_EN0		(1 << 11)
-#  define SYS_CNTRL_BT0		(1 << 10)
-#  define SYS_CNTRL_E0		(1 << 8)
-#  define SYS_CNTRL_E0S		(1 << 7)
-#  define SYS_CNTRL_32S		(1 << 5)
-#  define SYS_CNTRL_T0S		(1 << 4)
-#  define SYS_CNTRL_M20		(1 << 3)
-#  define SYS_CNTRL_M10		(1 << 2)
-#  define SYS_CNTRL_M00		(1 << 1)
-#  define SYS_CNTRL_C0S		(1 << 0)
+void static inline au_sync_udelay(int us)
+{
+	__asm__ volatile ("sync");
+	udelay(us);
+}
 
-/* Programmable Counter 0 Registers */
-#define SYS_TOYTRIM		(SYS_BASE + 0)
-#define SYS_TOYWRITE		(SYS_BASE + 4)
-#define SYS_TOYMATCH0		(SYS_BASE + 8)
-#define SYS_TOYMATCH1		(SYS_BASE + 0xC)
-#define SYS_TOYMATCH2		(SYS_BASE + 0x10)
-#define SYS_TOYREAD		(SYS_BASE + 0x40)
+void static inline au_sync_delay(int ms)
+{
+	__asm__ volatile ("sync");
+	mdelay(ms);
+}
 
-/* Programmable Counter 1 Registers */
-#define SYS_RTCTRIM		(SYS_BASE + 0x44)
-#define SYS_RTCWRITE		(SYS_BASE + 0x48)
-#define SYS_RTCMATCH0		(SYS_BASE + 0x4C)
-#define SYS_RTCMATCH1		(SYS_BASE + 0x50)
-#define SYS_RTCMATCH2		(SYS_BASE + 0x54)
-#define SYS_RTCREAD		(SYS_BASE + 0x58)
+void static inline au_writeb(u8 val, unsigned long reg)
+{
+	*(volatile u8 *)reg = val;
+}
 
+void static inline au_writew(u16 val, unsigned long reg)
+{
+	*(volatile u16 *)reg = val;
+}
 
-/*
- * The IrDA peripheral has an IRFIRSEL pin, but on the DB/PB boards it's not
- * used to select FIR/SIR mode on the transceiver but as a GPIO.  Instead a
- * CPLD has to be told about the mode.
- */
-#define AU1000_IRDA_PHY_MODE_OFF	0
-#define AU1000_IRDA_PHY_MODE_SIR	1
-#define AU1000_IRDA_PHY_MODE_FIR	2
+void static inline au_writel(u32 val, unsigned long reg)
+{
+	*(volatile u32 *)reg = val;
+}
 
-struct au1k_irda_platform_data {
-	void(*set_phy_mode)(int mode);
-};
+static inline u8 au_readb(unsigned long reg)
+{
+	return *(volatile u8 *)reg;
+}
 
+static inline u16 au_readw(unsigned long reg)
+{
+	return *(volatile u16 *)reg;
+}
 
-/* GPIO */
-#define SYS_PINFUNC		0xB190002C
-#  define SYS_PF_USB		(1 << 15)	/* 2nd USB device/host */
-#  define SYS_PF_U3		(1 << 14)	/* GPIO23/U3TXD */
-#  define SYS_PF_U2		(1 << 13)	/* GPIO22/U2TXD */
-#  define SYS_PF_U1		(1 << 12)	/* GPIO21/U1TXD */
-#  define SYS_PF_SRC		(1 << 11)	/* GPIO6/SROMCKE */
-#  define SYS_PF_CK5		(1 << 10)	/* GPIO3/CLK5 */
-#  define SYS_PF_CK4		(1 << 9)	/* GPIO2/CLK4 */
-#  define SYS_PF_IRF		(1 << 8)	/* GPIO15/IRFIRSEL */
-#  define SYS_PF_UR3		(1 << 7)	/* GPIO[14:9]/UART3 */
-#  define SYS_PF_I2D		(1 << 6)	/* GPIO8/I2SDI */
-#  define SYS_PF_I2S		(1 << 5)	/* I2S/GPIO[29:31] */
-#  define SYS_PF_NI2		(1 << 4)	/* NI2/GPIO[24:28] */
-#  define SYS_PF_U0		(1 << 3)	/* U0TXD/GPIO20 */
-#  define SYS_PF_RD		(1 << 2)	/* IRTXD/GPIO19 */
-#  define SYS_PF_A97		(1 << 1)	/* AC97/SSL1 */
-#  define SYS_PF_S0		(1 << 0)	/* SSI_0/GPIO[16:18] */
+static inline u32 au_readl(unsigned long reg)
+{
+	return *(volatile u32 *)reg;
+}
 
-/* Au1100 only */
-#  define SYS_PF_PC		(1 << 18)	/* PCMCIA/GPIO[207:204] */
-#  define SYS_PF_LCD		(1 << 17)	/* extern lcd/GPIO[203:200] */
-#  define SYS_PF_CS		(1 << 16)	/* EXTCLK0/32KHz to gpio2 */
-#  define SYS_PF_EX0		(1 << 9)	/* GPIO2/clock */
+/* Early Au1000 have a write-only SYS_CPUPLL register. */
+static inline int au1xxx_cpu_has_pll_wo(void)
+{
+	switch (read_c0_prid()) {
+	case 0x00030100:	/* Au1000 DA */
+	case 0x00030201:	/* Au1000 HA */
+	case 0x00030202:	/* Au1000 HB */
+		return 1;
+	}
+	return 0;
+}
 
-/* Au1550 only.	 Redefines lots of pins */
-#  define SYS_PF_PSC2_MASK	(7 << 17)
-#  define SYS_PF_PSC2_AC97	0
-#  define SYS_PF_PSC2_SPI	0
-#  define SYS_PF_PSC2_I2S	(1 << 17)
-#  define SYS_PF_PSC2_SMBUS	(3 << 17)
-#  define SYS_PF_PSC2_GPIO	(7 << 17)
-#  define SYS_PF_PSC3_MASK	(7 << 20)
-#  define SYS_PF_PSC3_AC97	0
-#  define SYS_PF_PSC3_SPI	0
-#  define SYS_PF_PSC3_I2S	(1 << 20)
-#  define SYS_PF_PSC3_SMBUS	(3 << 20)
-#  define SYS_PF_PSC3_GPIO	(7 << 20)
-#  define SYS_PF_PSC1_S1	(1 << 1)
-#  define SYS_PF_MUST_BE_SET	((1 << 5) | (1 << 2))
+/* does CPU need CONFIG[OD] set to fix tons of errata? */
+static inline int au1xxx_cpu_needs_config_od(void)
+{
+	/*
+	 * c0_config.od (bit 19) was write only (and read as 0) on the
+	 * early revisions of Alchemy SOCs.  It disables the bus trans-
+	 * action overlapping and needs to be set to fix various errata.
+	 */
+	switch (read_c0_prid()) {
+	case 0x00030100: /* Au1000 DA */
+	case 0x00030201: /* Au1000 HA */
+	case 0x00030202: /* Au1000 HB */
+	case 0x01030200: /* Au1500 AB */
+	/*
+	 * Au1100/Au1200 errata actually keep silence about this bit,
+	 * so we set it just in case for those revisions that require
+	 * it to be set according to the (now gone) cpu_table.
+	 */
+	case 0x02030200: /* Au1100 AB */
+	case 0x02030201: /* Au1100 BA */
+	case 0x02030202: /* Au1100 BC */
+	case 0x04030201: /* Au1200 AC */
+		return 1;
+	}
+	return 0;
+}
 
-/* Au1200 only */
-#define SYS_PINFUNC_DMA		(1 << 31)
-#define SYS_PINFUNC_S0A		(1 << 30)
-#define SYS_PINFUNC_S1A		(1 << 29)
-#define SYS_PINFUNC_LP0		(1 << 28)
-#define SYS_PINFUNC_LP1		(1 << 27)
-#define SYS_PINFUNC_LD16	(1 << 26)
-#define SYS_PINFUNC_LD8		(1 << 25)
-#define SYS_PINFUNC_LD1		(1 << 24)
-#define SYS_PINFUNC_LD0		(1 << 23)
-#define SYS_PINFUNC_P1A		(3 << 21)
-#define SYS_PINFUNC_P1B		(1 << 20)
-#define SYS_PINFUNC_FS3		(1 << 19)
-#define SYS_PINFUNC_P0A		(3 << 17)
-#define SYS_PINFUNC_CS		(1 << 16)
-#define SYS_PINFUNC_CIM		(1 << 15)
-#define SYS_PINFUNC_P1C		(1 << 14)
-#define SYS_PINFUNC_U1T		(1 << 12)
-#define SYS_PINFUNC_U1R		(1 << 11)
-#define SYS_PINFUNC_EX1		(1 << 10)
-#define SYS_PINFUNC_EX0		(1 << 9)
-#define SYS_PINFUNC_U0R		(1 << 8)
-#define SYS_PINFUNC_MC		(1 << 7)
-#define SYS_PINFUNC_S0B		(1 << 6)
-#define SYS_PINFUNC_S0C		(1 << 5)
-#define SYS_PINFUNC_P0B		(1 << 4)
-#define SYS_PINFUNC_U0T		(1 << 3)
-#define SYS_PINFUNC_S1B		(1 << 2)
+#define ALCHEMY_CPU_UNKNOWN	-1
+#define ALCHEMY_CPU_AU1000	0
+#define ALCHEMY_CPU_AU1500	1
+#define ALCHEMY_CPU_AU1100	2
+#define ALCHEMY_CPU_AU1550	3
+#define ALCHEMY_CPU_AU1200	4
+#define ALCHEMY_CPU_AU1300	5
 
-/* Power Management */
-#define SYS_SCRATCH0		0xB1900018
-#define SYS_SCRATCH1		0xB190001C
-#define SYS_WAKEMSK		0xB1900034
-#define SYS_ENDIAN		0xB1900038
-#define SYS_POWERCTRL		0xB190003C
-#define SYS_WAKESRC		0xB190005C
-#define SYS_SLPPWR		0xB1900078
-#define SYS_SLEEP		0xB190007C
+static inline int alchemy_get_cputype(void)
+{
+	switch (read_c0_prid() & (PRID_OPT_MASK | PRID_COMP_MASK)) {
+	case 0x00030000:
+		return ALCHEMY_CPU_AU1000;
+		break;
+	case 0x01030000:
+		return ALCHEMY_CPU_AU1500;
+		break;
+	case 0x02030000:
+		return ALCHEMY_CPU_AU1100;
+		break;
+	case 0x03030000:
+		return ALCHEMY_CPU_AU1550;
+		break;
+	case 0x04030000:
+	case 0x05030000:
+		return ALCHEMY_CPU_AU1200;
+		break;
+	case 0x800c0000:
+		return ALCHEMY_CPU_AU1300;
+		break;
+	}
 
-#define SYS_WAKEMSK_D2		(1 << 9)
-#define SYS_WAKEMSK_M2		(1 << 8)
-#define SYS_WAKEMSK_GPIO(x)	(1 << (x))
+	return ALCHEMY_CPU_UNKNOWN;
+}
 
-/* Clock Controller */
-#define SYS_FREQCTRL0		0xB1900020
-#  define SYS_FC_FRDIV2_BIT	22
-#  define SYS_FC_FRDIV2_MASK	(0xff << SYS_FC_FRDIV2_BIT)
-#  define SYS_FC_FE2		(1 << 21)
-#  define SYS_FC_FS2		(1 << 20)
-#  define SYS_FC_FRDIV1_BIT	12
-#  define SYS_FC_FRDIV1_MASK	(0xff << SYS_FC_FRDIV1_BIT)
-#  define SYS_FC_FE1		(1 << 11)
-#  define SYS_FC_FS1		(1 << 10)
-#  define SYS_FC_FRDIV0_BIT	2
-#  define SYS_FC_FRDIV0_MASK	(0xff << SYS_FC_FRDIV0_BIT)
-#  define SYS_FC_FE0		(1 << 1)
-#  define SYS_FC_FS0		(1 << 0)
-#define SYS_FREQCTRL1		0xB1900024
-#  define SYS_FC_FRDIV5_BIT	22
-#  define SYS_FC_FRDIV5_MASK	(0xff << SYS_FC_FRDIV5_BIT)
-#  define SYS_FC_FE5		(1 << 21)
-#  define SYS_FC_FS5		(1 << 20)
-#  define SYS_FC_FRDIV4_BIT	12
-#  define SYS_FC_FRDIV4_MASK	(0xff << SYS_FC_FRDIV4_BIT)
-#  define SYS_FC_FE4		(1 << 11)
-#  define SYS_FC_FS4		(1 << 10)
-#  define SYS_FC_FRDIV3_BIT	2
-#  define SYS_FC_FRDIV3_MASK	(0xff << SYS_FC_FRDIV3_BIT)
-#  define SYS_FC_FE3		(1 << 1)
-#  define SYS_FC_FS3		(1 << 0)
-#define SYS_CLKSRC		0xB1900028
-#  define SYS_CS_ME1_BIT	27
-#  define SYS_CS_ME1_MASK	(0x7 << SYS_CS_ME1_BIT)
-#  define SYS_CS_DE1		(1 << 26)
-#  define SYS_CS_CE1		(1 << 25)
-#  define SYS_CS_ME0_BIT	22
-#  define SYS_CS_ME0_MASK	(0x7 << SYS_CS_ME0_BIT)
-#  define SYS_CS_DE0		(1 << 21)
-#  define SYS_CS_CE0		(1 << 20)
-#  define SYS_CS_MI2_BIT	17
-#  define SYS_CS_MI2_MASK	(0x7 << SYS_CS_MI2_BIT)
-#  define SYS_CS_DI2		(1 << 16)
-#  define SYS_CS_CI2		(1 << 15)
+/* return number of uarts on a given cputype */
+static inline int alchemy_get_uarts(int type)
+{
+	switch (type) {
+	case ALCHEMY_CPU_AU1000:
+	case ALCHEMY_CPU_AU1300:
+		return 4;
+	case ALCHEMY_CPU_AU1500:
+	case ALCHEMY_CPU_AU1200:
+		return 2;
+	case ALCHEMY_CPU_AU1100:
+	case ALCHEMY_CPU_AU1550:
+		return 3;
+	}
+	return 0;
+}
 
-#  define SYS_CS_ML_BIT		7
-#  define SYS_CS_ML_MASK	(0x7 << SYS_CS_ML_BIT)
-#  define SYS_CS_DL		(1 << 6)
-#  define SYS_CS_CL		(1 << 5)
+/* enable an UART block if it isn't already */
+static inline void alchemy_uart_enable(u32 uart_phys)
+{
+	void __iomem *addr = (void __iomem *)KSEG1ADDR(uart_phys);
 
-#  define SYS_CS_MUH_BIT	12
-#  define SYS_CS_MUH_MASK	(0x7 << SYS_CS_MUH_BIT)
-#  define SYS_CS_DUH		(1 << 11)
-#  define SYS_CS_CUH		(1 << 10)
-#  define SYS_CS_MUD_BIT	7
-#  define SYS_CS_MUD_MASK	(0x7 << SYS_CS_MUD_BIT)
-#  define SYS_CS_DUD		(1 << 6)
-#  define SYS_CS_CUD		(1 << 5)
+	/* reset, enable clock, deassert reset */
+	if ((__raw_readl(addr + 0x100) & 3) != 3) {
+		__raw_writel(0, addr + 0x100);
+		wmb(); /* drain writebuffer */
+		__raw_writel(1, addr + 0x100);
+		wmb(); /* drain writebuffer */
+	}
+	__raw_writel(3, addr + 0x100);
+	wmb(); /* drain writebuffer */
+}
 
-#  define SYS_CS_MIR_BIT	2
-#  define SYS_CS_MIR_MASK	(0x7 << SYS_CS_MIR_BIT)
-#  define SYS_CS_DIR		(1 << 1)
-#  define SYS_CS_CIR		(1 << 0)
+static inline void alchemy_uart_disable(u32 uart_phys)
+{
+	void __iomem *addr = (void __iomem *)KSEG1ADDR(uart_phys);
 
-#  define SYS_CS_MUX_AUX	0x1
-#  define SYS_CS_MUX_FQ0	0x2
-#  define SYS_CS_MUX_FQ1	0x3
-#  define SYS_CS_MUX_FQ2	0x4
-#  define SYS_CS_MUX_FQ3	0x5
-#  define SYS_CS_MUX_FQ4	0x6
-#  define SYS_CS_MUX_FQ5	0x7
-#define SYS_CPUPLL		0xB1900060
-#define SYS_AUXPLL		0xB1900064
+	__raw_writel(0, addr + 0x100);	/* UART_MOD_CNTRL */
+	wmb(); /* drain writebuffer */
+}
 
+static inline void alchemy_uart_putchar(u32 uart_phys, u8 c)
+{
+	void __iomem *base = (void __iomem *)KSEG1ADDR(uart_phys);
+	int timeout, i;
 
-/* The PCI chip selects are outside the 32bit space, and since we can't
- * just program the 36bit addresses into BARs, we have to take a chunk
- * out of the 32bit space and reserve it for PCI.  When these addresses
- * are ioremap()ed, they'll be fixed up to the real 36bit address before
- * being passed to the real ioremap function.
- */
-#define ALCHEMY_PCI_MEMWIN_START	(AU1500_PCI_MEM_PHYS_ADDR >> 4)
-#define ALCHEMY_PCI_MEMWIN_END		(ALCHEMY_PCI_MEMWIN_START + 0x0FFFFFFF)
+	/* check LSR TX_EMPTY bit */
+	timeout = 0xffffff;
+	do {
+		if (__raw_readl(base + 0x1c) & 0x20)
+			break;
+		/* slow down */
+		for (i = 10000; i; i--)
+			asm volatile ("nop");
+	} while (--timeout);
 
-/* for PCI IO it's simpler because we get to do the ioremap ourselves and then
- * adjust the device's resources.
- */
-#define ALCHEMY_PCI_IOWIN_START		0x00001000
-#define ALCHEMY_PCI_IOWIN_END		0x0000FFFF
+	__raw_writel(c, base + 0x04);	/* tx */
+	wmb(); /* drain writebuffer */
+}
 
-#ifdef CONFIG_PCI
+/* return number of ethernet MACs on a given cputype */
+static inline int alchemy_get_macs(int type)
+{
+	switch (type) {
+	case ALCHEMY_CPU_AU1000:
+	case ALCHEMY_CPU_AU1500:
+	case ALCHEMY_CPU_AU1550:
+		return 2;
+	case ALCHEMY_CPU_AU1100:
+		return 1;
+	}
+	return 0;
+}
 
-#define IOPORT_RESOURCE_START	0x00001000	/* skip legacy probing */
-#define IOPORT_RESOURCE_END	0xffffffff
-#define IOMEM_RESOURCE_START	0x10000000
-#define IOMEM_RESOURCE_END	0xfffffffffULL
+/* arch/mips/au1000/common/clocks.c */
+extern void set_au1x00_speed(unsigned int new_freq);
+extern unsigned int get_au1x00_speed(void);
+extern void set_au1x00_uart_baud_base(unsigned long new_baud_base);
+extern unsigned long get_au1x00_uart_baud_base(void);
+extern unsigned long au1xxx_calc_clock(void);
 
-#else
+/* PM: arch/mips/alchemy/common/sleeper.S, power.c, irq.c */
+void alchemy_sleep_au1000(void);
+void alchemy_sleep_au1550(void);
+void alchemy_sleep_au1300(void);
+void au_sleep(void);
 
-/* Don't allow any legacy ports probing */
-#define IOPORT_RESOURCE_START	0x10000000
-#define IOPORT_RESOURCE_END	0xffffffff
-#define IOMEM_RESOURCE_START	0x10000000
-#define IOMEM_RESOURCE_END	0xfffffffffULL
+/* USB: arch/mips/alchemy/common/usb.c */
+enum alchemy_usb_block {
+	ALCHEMY_USB_OHCI0,
+	ALCHEMY_USB_UDC0,
+	ALCHEMY_USB_EHCI0,
+	ALCHEMY_USB_OTG0,
+	ALCHEMY_USB_OHCI1,
+};
+int alchemy_usb_control(int block, int enable);
 
-#endif
+/* PCI controller platform data */
+struct alchemy_pci_platdata {
+	int (*board_map_irq)(const struct pci_dev *d, u8 slot, u8 pin);
+	int (*board_pci_idsel)(unsigned int devsel, int assert);
+	/* bits to set/clear in PCI_CONFIG register */
+	unsigned long pci_cfg_set;
+	unsigned long pci_cfg_clr;
+};
 
-/* PCI controller block register offsets */
-#define PCI_REG_CMEM		0x0000
-#define PCI_REG_CONFIG		0x0004
-#define PCI_REG_B2BMASK_CCH	0x0008
-#define PCI_REG_B2BBASE0_VID	0x000C
-#define PCI_REG_B2BBASE1_SID	0x0010
-#define PCI_REG_MWMASK_DEV	0x0014
-#define PCI_REG_MWBASE_REV_CCL	0x0018
-#define PCI_REG_ERR_ADDR	0x001C
-#define PCI_REG_SPEC_INTACK	0x0020
-#define PCI_REG_ID		0x0100
-#define PCI_REG_STATCMD		0x0104
-#define PCI_REG_CLASSREV	0x0108
-#define PCI_REG_PARAM		0x010C
-#define PCI_REG_MBAR		0x0110
-#define PCI_REG_TIMEOUT		0x0140
+/* The IrDA peripheral has an IRFIRSEL pin, but on the DB/PB boards it's
+ * not used to select FIR/SIR mode on the transceiver but as a GPIO.
+ * Instead a CPLD has to be told about the mode.  The driver calls the
+ * set_phy_mode() function in addition to driving the IRFIRSEL pin.
+ */
+#define AU1000_IRDA_PHY_MODE_OFF	0
+#define AU1000_IRDA_PHY_MODE_SIR	1
+#define AU1000_IRDA_PHY_MODE_FIR	2
 
-/* PCI controller block register bits */
-#define PCI_CMEM_E		(1 << 28)	/* enable cacheable memory */
-#define PCI_CMEM_CMBASE(x)	(((x) & 0x3fff) << 14)
-#define PCI_CMEM_CMMASK(x)	((x) & 0x3fff)
-#define PCI_CONFIG_ERD		(1 << 27) /* pci error during R/W */
-#define PCI_CONFIG_ET		(1 << 26) /* error in target mode */
-#define PCI_CONFIG_EF		(1 << 25) /* fatal error */
-#define PCI_CONFIG_EP		(1 << 24) /* parity error */
-#define PCI_CONFIG_EM		(1 << 23) /* multiple errors */
-#define PCI_CONFIG_BM		(1 << 22) /* bad master error */
-#define PCI_CONFIG_PD		(1 << 20) /* PCI Disable */
-#define PCI_CONFIG_BME		(1 << 19) /* Byte Mask Enable for reads */
-#define PCI_CONFIG_NC		(1 << 16) /* mark mem access non-coherent */
-#define PCI_CONFIG_IA		(1 << 15) /* INTA# enabled (target mode) */
-#define PCI_CONFIG_IP		(1 << 13) /* int on PCI_PERR# */
-#define PCI_CONFIG_IS		(1 << 12) /* int on PCI_SERR# */
-#define PCI_CONFIG_IMM		(1 << 11) /* int on master abort */
-#define PCI_CONFIG_ITM		(1 << 10) /* int on target abort (as master) */
-#define PCI_CONFIG_ITT		(1 << 9)  /* int on target abort (as target) */
-#define PCI_CONFIG_IPB		(1 << 8)  /* int on PERR# in bus master acc */
-#define PCI_CONFIG_SIC_NO	(0 << 6)  /* no byte mask changes */
-#define PCI_CONFIG_SIC_BA_ADR	(1 << 6)  /* on byte/hw acc, invert adr bits */
-#define PCI_CONFIG_SIC_HWA_DAT	(2 << 6)  /* on halfword acc, swap data */
-#define PCI_CONFIG_SIC_ALL	(3 << 6)  /* swap data bytes on all accesses */
-#define PCI_CONFIG_ST		(1 << 5)  /* swap data by target transactions */
-#define PCI_CONFIG_SM		(1 << 4)  /* swap data from PCI ctl */
-#define PCI_CONFIG_AEN		(1 << 3)  /* enable internal arbiter */
-#define PCI_CONFIG_R2H		(1 << 2)  /* REQ2# to hi-prio arbiter */
-#define PCI_CONFIG_R1H		(1 << 1)  /* REQ1# to hi-prio arbiter */
-#define PCI_CONFIG_CH		(1 << 0)  /* PCI ctl to hi-prio arbiter */
-#define PCI_B2BMASK_B2BMASK(x)	(((x) & 0xffff) << 16)
-#define PCI_B2BMASK_CCH(x)	((x) & 0xffff) /* 16 upper bits of class code */
-#define PCI_B2BBASE0_VID_B0(x)	(((x) & 0xffff) << 16)
-#define PCI_B2BBASE0_VID_SV(x)	((x) & 0xffff)
-#define PCI_B2BBASE1_SID_B1(x)	(((x) & 0xffff) << 16)
-#define PCI_B2BBASE1_SID_SI(x)	((x) & 0xffff)
-#define PCI_MWMASKDEV_MWMASK(x) (((x) & 0xffff) << 16)
-#define PCI_MWMASKDEV_DEVID(x)	((x) & 0xffff)
-#define PCI_MWBASEREVCCL_BASE(x) (((x) & 0xffff) << 16)
-#define PCI_MWBASEREVCCL_REV(x)	 (((x) & 0xff) << 8)
-#define PCI_MWBASEREVCCL_CCL(x)	 ((x) & 0xff)
-#define PCI_ID_DID(x)		(((x) & 0xffff) << 16)
-#define PCI_ID_VID(x)		((x) & 0xffff)
-#define PCI_STATCMD_STATUS(x)	(((x) & 0xffff) << 16)
-#define PCI_STATCMD_CMD(x)	((x) & 0xffff)
-#define PCI_CLASSREV_CLASS(x)	(((x) & 0x00ffffff) << 8)
-#define PCI_CLASSREV_REV(x)	((x) & 0xff)
-#define PCI_PARAM_BIST(x)	(((x) & 0xff) << 24)
-#define PCI_PARAM_HT(x)		(((x) & 0xff) << 16)
-#define PCI_PARAM_LT(x)		(((x) & 0xff) << 8)
-#define PCI_PARAM_CLS(x)	((x) & 0xff)
-#define PCI_TIMEOUT_RETRIES(x)	(((x) & 0xff) << 8)	/* max retries */
-#define PCI_TIMEOUT_TO(x)	((x) & 0xff)	/* target ready timeout */
+struct au1k_irda_platform_data {
+	void (*set_phy_mode)(int mode);
+};
+
+
+/* Multifunction pins: Each of these pins can either be assigned to the
+ * GPIO controller or a on-chip peripheral.
+ * Call "au1300_pinfunc_to_dev()" or "au1300_pinfunc_to_gpio()" to
+ * assign one of these to either the GPIO controller or the device.
+ */
+enum au1300_multifunc_pins {
+	/* wake-from-str pins 0-3 */
+	AU1300_PIN_WAKE0 = 0, AU1300_PIN_WAKE1, AU1300_PIN_WAKE2,
+	AU1300_PIN_WAKE3,
+	/* external clock sources for PSCs: 4-5 */
+	AU1300_PIN_EXTCLK0, AU1300_PIN_EXTCLK1,
+	/* 8bit MMC interface on SD0: 6-9 */
+	AU1300_PIN_SD0DAT4, AU1300_PIN_SD0DAT5, AU1300_PIN_SD0DAT6,
+	AU1300_PIN_SD0DAT7,
+	/* aux clk input for freqgen 3: 10 */
+	AU1300_PIN_FG3AUX,
+	/* UART1 pins: 11-18 */
+	AU1300_PIN_U1RI, AU1300_PIN_U1DCD, AU1300_PIN_U1DSR,
+	AU1300_PIN_U1CTS, AU1300_PIN_U1RTS, AU1300_PIN_U1DTR,
+	AU1300_PIN_U1RX, AU1300_PIN_U1TX,
+	/* UART0 pins: 19-24 */
+	AU1300_PIN_U0RI, AU1300_PIN_U0DCD, AU1300_PIN_U0DSR,
+	AU1300_PIN_U0CTS, AU1300_PIN_U0RTS, AU1300_PIN_U0DTR,
+	/* UART2: 25-26 */
+	AU1300_PIN_U2RX, AU1300_PIN_U2TX,
+	/* UART3: 27-28 */
+	AU1300_PIN_U3RX, AU1300_PIN_U3TX,
+	/* LCD controller PWMs, ext pixclock: 29-31 */
+	AU1300_PIN_LCDPWM0, AU1300_PIN_LCDPWM1, AU1300_PIN_LCDCLKIN,
+	/* SD1 interface: 32-37 */
+	AU1300_PIN_SD1DAT0, AU1300_PIN_SD1DAT1, AU1300_PIN_SD1DAT2,
+	AU1300_PIN_SD1DAT3, AU1300_PIN_SD1CMD, AU1300_PIN_SD1CLK,
+	/* SD2 interface: 38-43 */
+	AU1300_PIN_SD2DAT0, AU1300_PIN_SD2DAT1, AU1300_PIN_SD2DAT2,
+	AU1300_PIN_SD2DAT3, AU1300_PIN_SD2CMD, AU1300_PIN_SD2CLK,
+	/* PSC0/1 clocks: 44-45 */
+	AU1300_PIN_PSC0CLK, AU1300_PIN_PSC1CLK,
+	/* PSCs: 46-49/50-53/54-57/58-61 */
+	AU1300_PIN_PSC0SYNC0, AU1300_PIN_PSC0SYNC1, AU1300_PIN_PSC0D0,
+	AU1300_PIN_PSC0D1,
+	AU1300_PIN_PSC1SYNC0, AU1300_PIN_PSC1SYNC1, AU1300_PIN_PSC1D0,
+	AU1300_PIN_PSC1D1,
+	AU1300_PIN_PSC2SYNC0, AU1300_PIN_PSC2SYNC1, AU1300_PIN_PSC2D0,
+	AU1300_PIN_PSC2D1,
+	AU1300_PIN_PSC3SYNC0, AU1300_PIN_PSC3SYNC1, AU1300_PIN_PSC3D0,
+	AU1300_PIN_PSC3D1,
+	/* PCMCIA interface: 62-70 */
+	AU1300_PIN_PCE2, AU1300_PIN_PCE1, AU1300_PIN_PIOS16,
+	AU1300_PIN_PIOR, AU1300_PIN_PWE, AU1300_PIN_PWAIT,
+	AU1300_PIN_PREG, AU1300_PIN_POE, AU1300_PIN_PIOW,
+	/* camera interface H/V sync inputs: 71-72 */
+	AU1300_PIN_CIMLS, AU1300_PIN_CIMFS,
+	/* PSC2/3 clocks: 73-74 */
+	AU1300_PIN_PSC2CLK, AU1300_PIN_PSC3CLK,
+};
+
+/* GPIC (Au1300) pin management: arch/mips/alchemy/common/gpioint.c */
+extern void au1300_pinfunc_to_gpio(enum au1300_multifunc_pins gpio);
+extern void au1300_pinfunc_to_dev(enum au1300_multifunc_pins gpio);
+extern void au1300_set_irq_priority(unsigned int irq, int p);
+extern void au1300_set_dbdma_gpio(int dchan, unsigned int gpio);
+
+/* Au1300 allows to disconnect certain blocks from internal power supply */
+enum au1300_vss_block {
+	AU1300_VSS_MPE = 0,
+	AU1300_VSS_BSA,
+	AU1300_VSS_GPE,
+	AU1300_VSS_MGP,
+};
+
+extern void au1300_vss_block_control(int block, int enable);
+
+enum soc_au1000_ints {
+	AU1000_FIRST_INT	= AU1000_INTC0_INT_BASE,
+	AU1000_UART0_INT	= AU1000_FIRST_INT,
+	AU1000_UART1_INT,
+	AU1000_UART2_INT,
+	AU1000_UART3_INT,
+	AU1000_SSI0_INT,
+	AU1000_SSI1_INT,
+	AU1000_DMA_INT_BASE,
+
+	AU1000_TOY_INT		= AU1000_FIRST_INT + 14,
+	AU1000_TOY_MATCH0_INT,
+	AU1000_TOY_MATCH1_INT,
+	AU1000_TOY_MATCH2_INT,
+	AU1000_RTC_INT,
+	AU1000_RTC_MATCH0_INT,
+	AU1000_RTC_MATCH1_INT,
+	AU1000_RTC_MATCH2_INT,
+	AU1000_IRDA_TX_INT,
+	AU1000_IRDA_RX_INT,
+	AU1000_USB_DEV_REQ_INT,
+	AU1000_USB_DEV_SUS_INT,
+	AU1000_USB_HOST_INT,
+	AU1000_ACSYNC_INT,
+	AU1000_MAC0_DMA_INT,
+	AU1000_MAC1_DMA_INT,
+	AU1000_I2S_UO_INT,
+	AU1000_AC97C_INT,
+	AU1000_GPIO0_INT,
+	AU1000_GPIO1_INT,
+	AU1000_GPIO2_INT,
+	AU1000_GPIO3_INT,
+	AU1000_GPIO4_INT,
+	AU1000_GPIO5_INT,
+	AU1000_GPIO6_INT,
+	AU1000_GPIO7_INT,
+	AU1000_GPIO8_INT,
+	AU1000_GPIO9_INT,
+	AU1000_GPIO10_INT,
+	AU1000_GPIO11_INT,
+	AU1000_GPIO12_INT,
+	AU1000_GPIO13_INT,
+	AU1000_GPIO14_INT,
+	AU1000_GPIO15_INT,
+	AU1000_GPIO16_INT,
+	AU1000_GPIO17_INT,
+	AU1000_GPIO18_INT,
+	AU1000_GPIO19_INT,
+	AU1000_GPIO20_INT,
+	AU1000_GPIO21_INT,
+	AU1000_GPIO22_INT,
+	AU1000_GPIO23_INT,
+	AU1000_GPIO24_INT,
+	AU1000_GPIO25_INT,
+	AU1000_GPIO26_INT,
+	AU1000_GPIO27_INT,
+	AU1000_GPIO28_INT,
+	AU1000_GPIO29_INT,
+	AU1000_GPIO30_INT,
+	AU1000_GPIO31_INT,
+};
+
+enum soc_au1100_ints {
+	AU1100_FIRST_INT	= AU1000_INTC0_INT_BASE,
+	AU1100_UART0_INT	= AU1100_FIRST_INT,
+	AU1100_UART1_INT,
+	AU1100_SD_INT,
+	AU1100_UART3_INT,
+	AU1100_SSI0_INT,
+	AU1100_SSI1_INT,
+	AU1100_DMA_INT_BASE,
+
+	AU1100_TOY_INT		= AU1100_FIRST_INT + 14,
+	AU1100_TOY_MATCH0_INT,
+	AU1100_TOY_MATCH1_INT,
+	AU1100_TOY_MATCH2_INT,
+	AU1100_RTC_INT,
+	AU1100_RTC_MATCH0_INT,
+	AU1100_RTC_MATCH1_INT,
+	AU1100_RTC_MATCH2_INT,
+	AU1100_IRDA_TX_INT,
+	AU1100_IRDA_RX_INT,
+	AU1100_USB_DEV_REQ_INT,
+	AU1100_USB_DEV_SUS_INT,
+	AU1100_USB_HOST_INT,
+	AU1100_ACSYNC_INT,
+	AU1100_MAC0_DMA_INT,
+	AU1100_GPIO208_215_INT,
+	AU1100_LCD_INT,
+	AU1100_AC97C_INT,
+	AU1100_GPIO0_INT,
+	AU1100_GPIO1_INT,
+	AU1100_GPIO2_INT,
+	AU1100_GPIO3_INT,
+	AU1100_GPIO4_INT,
+	AU1100_GPIO5_INT,
+	AU1100_GPIO6_INT,
+	AU1100_GPIO7_INT,
+	AU1100_GPIO8_INT,
+	AU1100_GPIO9_INT,
+	AU1100_GPIO10_INT,
+	AU1100_GPIO11_INT,
+	AU1100_GPIO12_INT,
+	AU1100_GPIO13_INT,
+	AU1100_GPIO14_INT,
+	AU1100_GPIO15_INT,
+	AU1100_GPIO16_INT,
+	AU1100_GPIO17_INT,
+	AU1100_GPIO18_INT,
+	AU1100_GPIO19_INT,
+	AU1100_GPIO20_INT,
+	AU1100_GPIO21_INT,
+	AU1100_GPIO22_INT,
+	AU1100_GPIO23_INT,
+	AU1100_GPIO24_INT,
+	AU1100_GPIO25_INT,
+	AU1100_GPIO26_INT,
+	AU1100_GPIO27_INT,
+	AU1100_GPIO28_INT,
+	AU1100_GPIO29_INT,
+	AU1100_GPIO30_INT,
+	AU1100_GPIO31_INT,
+};
+
+enum soc_au1500_ints {
+	AU1500_FIRST_INT	= AU1000_INTC0_INT_BASE,
+	AU1500_UART0_INT	= AU1500_FIRST_INT,
+	AU1500_PCI_INTA,
+	AU1500_PCI_INTB,
+	AU1500_UART3_INT,
+	AU1500_PCI_INTC,
+	AU1500_PCI_INTD,
+	AU1500_DMA_INT_BASE,
+
+	AU1500_TOY_INT		= AU1500_FIRST_INT + 14,
+	AU1500_TOY_MATCH0_INT,
+	AU1500_TOY_MATCH1_INT,
+	AU1500_TOY_MATCH2_INT,
+	AU1500_RTC_INT,
+	AU1500_RTC_MATCH0_INT,
+	AU1500_RTC_MATCH1_INT,
+	AU1500_RTC_MATCH2_INT,
+	AU1500_PCI_ERR_INT,
+	AU1500_RESERVED_INT,
+	AU1500_USB_DEV_REQ_INT,
+	AU1500_USB_DEV_SUS_INT,
+	AU1500_USB_HOST_INT,
+	AU1500_ACSYNC_INT,
+	AU1500_MAC0_DMA_INT,
+	AU1500_MAC1_DMA_INT,
+	AU1500_AC97C_INT	= AU1500_FIRST_INT + 31,
+	AU1500_GPIO0_INT,
+	AU1500_GPIO1_INT,
+	AU1500_GPIO2_INT,
+	AU1500_GPIO3_INT,
+	AU1500_GPIO4_INT,
+	AU1500_GPIO5_INT,
+	AU1500_GPIO6_INT,
+	AU1500_GPIO7_INT,
+	AU1500_GPIO8_INT,
+	AU1500_GPIO9_INT,
+	AU1500_GPIO10_INT,
+	AU1500_GPIO11_INT,
+	AU1500_GPIO12_INT,
+	AU1500_GPIO13_INT,
+	AU1500_GPIO14_INT,
+	AU1500_GPIO15_INT,
+	AU1500_GPIO200_INT,
+	AU1500_GPIO201_INT,
+	AU1500_GPIO202_INT,
+	AU1500_GPIO203_INT,
+	AU1500_GPIO20_INT,
+	AU1500_GPIO204_INT,
+	AU1500_GPIO205_INT,
+	AU1500_GPIO23_INT,
+	AU1500_GPIO24_INT,
+	AU1500_GPIO25_INT,
+	AU1500_GPIO26_INT,
+	AU1500_GPIO27_INT,
+	AU1500_GPIO28_INT,
+	AU1500_GPIO206_INT,
+	AU1500_GPIO207_INT,
+	AU1500_GPIO208_215_INT,
+};
+
+enum soc_au1550_ints {
+	AU1550_FIRST_INT	= AU1000_INTC0_INT_BASE,
+	AU1550_UART0_INT	= AU1550_FIRST_INT,
+	AU1550_PCI_INTA,
+	AU1550_PCI_INTB,
+	AU1550_DDMA_INT,
+	AU1550_CRYPTO_INT,
+	AU1550_PCI_INTC,
+	AU1550_PCI_INTD,
+	AU1550_PCI_RST_INT,
+	AU1550_UART1_INT,
+	AU1550_UART3_INT,
+	AU1550_PSC0_INT,
+	AU1550_PSC1_INT,
+	AU1550_PSC2_INT,
+	AU1550_PSC3_INT,
+	AU1550_TOY_INT,
+	AU1550_TOY_MATCH0_INT,
+	AU1550_TOY_MATCH1_INT,
+	AU1550_TOY_MATCH2_INT,
+	AU1550_RTC_INT,
+	AU1550_RTC_MATCH0_INT,
+	AU1550_RTC_MATCH1_INT,
+	AU1550_RTC_MATCH2_INT,
+
+	AU1550_NAND_INT		= AU1550_FIRST_INT + 23,
+	AU1550_USB_DEV_REQ_INT,
+	AU1550_USB_DEV_SUS_INT,
+	AU1550_USB_HOST_INT,
+	AU1550_MAC0_DMA_INT,
+	AU1550_MAC1_DMA_INT,
+	AU1550_GPIO0_INT	= AU1550_FIRST_INT + 32,
+	AU1550_GPIO1_INT,
+	AU1550_GPIO2_INT,
+	AU1550_GPIO3_INT,
+	AU1550_GPIO4_INT,
+	AU1550_GPIO5_INT,
+	AU1550_GPIO6_INT,
+	AU1550_GPIO7_INT,
+	AU1550_GPIO8_INT,
+	AU1550_GPIO9_INT,
+	AU1550_GPIO10_INT,
+	AU1550_GPIO11_INT,
+	AU1550_GPIO12_INT,
+	AU1550_GPIO13_INT,
+	AU1550_GPIO14_INT,
+	AU1550_GPIO15_INT,
+	AU1550_GPIO200_INT,
+	AU1550_GPIO201_205_INT, /* Logical or of GPIO201:205 */
+	AU1550_GPIO16_INT,
+	AU1550_GPIO17_INT,
+	AU1550_GPIO20_INT,
+	AU1550_GPIO21_INT,
+	AU1550_GPIO22_INT,
+	AU1550_GPIO23_INT,
+	AU1550_GPIO24_INT,
+	AU1550_GPIO25_INT,
+	AU1550_GPIO26_INT,
+	AU1550_GPIO27_INT,
+	AU1550_GPIO28_INT,
+	AU1550_GPIO206_INT,
+	AU1550_GPIO207_INT,
+	AU1550_GPIO208_215_INT, /* Logical or of GPIO208:215 */
+};
+
+enum soc_au1200_ints {
+	AU1200_FIRST_INT	= AU1000_INTC0_INT_BASE,
+	AU1200_UART0_INT	= AU1200_FIRST_INT,
+	AU1200_SWT_INT,
+	AU1200_SD_INT,
+	AU1200_DDMA_INT,
+	AU1200_MAE_BE_INT,
+	AU1200_GPIO200_INT,
+	AU1200_GPIO201_INT,
+	AU1200_GPIO202_INT,
+	AU1200_UART1_INT,
+	AU1200_MAE_FE_INT,
+	AU1200_PSC0_INT,
+	AU1200_PSC1_INT,
+	AU1200_AES_INT,
+	AU1200_CAMERA_INT,
+	AU1200_TOY_INT,
+	AU1200_TOY_MATCH0_INT,
+	AU1200_TOY_MATCH1_INT,
+	AU1200_TOY_MATCH2_INT,
+	AU1200_RTC_INT,
+	AU1200_RTC_MATCH0_INT,
+	AU1200_RTC_MATCH1_INT,
+	AU1200_RTC_MATCH2_INT,
+	AU1200_GPIO203_INT,
+	AU1200_NAND_INT,
+	AU1200_GPIO204_INT,
+	AU1200_GPIO205_INT,
+	AU1200_GPIO206_INT,
+	AU1200_GPIO207_INT,
+	AU1200_GPIO208_215_INT, /* Logical OR of 208:215 */
+	AU1200_USB_INT,
+	AU1200_LCD_INT,
+	AU1200_MAE_BOTH_INT,
+	AU1200_GPIO0_INT,
+	AU1200_GPIO1_INT,
+	AU1200_GPIO2_INT,
+	AU1200_GPIO3_INT,
+	AU1200_GPIO4_INT,
+	AU1200_GPIO5_INT,
+	AU1200_GPIO6_INT,
+	AU1200_GPIO7_INT,
+	AU1200_GPIO8_INT,
+	AU1200_GPIO9_INT,
+	AU1200_GPIO10_INT,
+	AU1200_GPIO11_INT,
+	AU1200_GPIO12_INT,
+	AU1200_GPIO13_INT,
+	AU1200_GPIO14_INT,
+	AU1200_GPIO15_INT,
+	AU1200_GPIO16_INT,
+	AU1200_GPIO17_INT,
+	AU1200_GPIO18_INT,
+	AU1200_GPIO19_INT,
+	AU1200_GPIO20_INT,
+	AU1200_GPIO21_INT,
+	AU1200_GPIO22_INT,
+	AU1200_GPIO23_INT,
+	AU1200_GPIO24_INT,
+	AU1200_GPIO25_INT,
+	AU1200_GPIO26_INT,
+	AU1200_GPIO27_INT,
+	AU1200_GPIO28_INT,
+	AU1200_GPIO29_INT,
+	AU1200_GPIO30_INT,
+	AU1200_GPIO31_INT,
+};
+
+#endif /* !defined (_LANGUAGE_ASSEMBLY) */
 
 #endif

commit fb1a7602dde1c82f08ba1ec997ac87af06e946e6
Author: Manuel Lauss <manuel.lauss@gmail.com>
Date:   Wed Jul 23 16:36:22 2014 +0200

    MIPS: Alchemy: move ethernet registers to ethernet driver
    
    Move the register offsets and bit descriptions from the au1000.h header
    to their only user, the au1000_eth.c driver.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: netdev@vger.kernel.org
    Cc: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/7460/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 60754fc63981..e50671019122 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -1003,132 +1003,6 @@ enum soc_au1200_ints {
 #define SYS_RTCMATCH2		(SYS_BASE + 0x54)
 #define SYS_RTCREAD		(SYS_BASE + 0x58)
 
-/* Ethernet Controllers  */
-
-/* 4 byte offsets from AU1000_ETH_BASE */
-#define MAC_CONTROL		0x0
-#  define MAC_RX_ENABLE		(1 << 2)
-#  define MAC_TX_ENABLE		(1 << 3)
-#  define MAC_DEF_CHECK		(1 << 5)
-#  define MAC_SET_BL(X)		(((X) & 0x3) << 6)
-#  define MAC_AUTO_PAD		(1 << 8)
-#  define MAC_DISABLE_RETRY	(1 << 10)
-#  define MAC_DISABLE_BCAST	(1 << 11)
-#  define MAC_LATE_COL		(1 << 12)
-#  define MAC_HASH_MODE		(1 << 13)
-#  define MAC_HASH_ONLY		(1 << 15)
-#  define MAC_PASS_ALL		(1 << 16)
-#  define MAC_INVERSE_FILTER	(1 << 17)
-#  define MAC_PROMISCUOUS	(1 << 18)
-#  define MAC_PASS_ALL_MULTI	(1 << 19)
-#  define MAC_FULL_DUPLEX	(1 << 20)
-#  define MAC_NORMAL_MODE	0
-#  define MAC_INT_LOOPBACK	(1 << 21)
-#  define MAC_EXT_LOOPBACK	(1 << 22)
-#  define MAC_DISABLE_RX_OWN	(1 << 23)
-#  define MAC_BIG_ENDIAN	(1 << 30)
-#  define MAC_RX_ALL		(1 << 31)
-#define MAC_ADDRESS_HIGH	0x4
-#define MAC_ADDRESS_LOW		0x8
-#define MAC_MCAST_HIGH		0xC
-#define MAC_MCAST_LOW		0x10
-#define MAC_MII_CNTRL		0x14
-#  define MAC_MII_BUSY		(1 << 0)
-#  define MAC_MII_READ		0
-#  define MAC_MII_WRITE		(1 << 1)
-#  define MAC_SET_MII_SELECT_REG(X) (((X) & 0x1f) << 6)
-#  define MAC_SET_MII_SELECT_PHY(X) (((X) & 0x1f) << 11)
-#define MAC_MII_DATA		0x18
-#define MAC_FLOW_CNTRL		0x1C
-#  define MAC_FLOW_CNTRL_BUSY	(1 << 0)
-#  define MAC_FLOW_CNTRL_ENABLE (1 << 1)
-#  define MAC_PASS_CONTROL	(1 << 2)
-#  define MAC_SET_PAUSE(X)	(((X) & 0xffff) << 16)
-#define MAC_VLAN1_TAG		0x20
-#define MAC_VLAN2_TAG		0x24
-
-/* Ethernet Controller Enable */
-
-#  define MAC_EN_CLOCK_ENABLE	(1 << 0)
-#  define MAC_EN_RESET0		(1 << 1)
-#  define MAC_EN_TOSS		(0 << 2)
-#  define MAC_EN_CACHEABLE	(1 << 3)
-#  define MAC_EN_RESET1		(1 << 4)
-#  define MAC_EN_RESET2		(1 << 5)
-#  define MAC_DMA_RESET		(1 << 6)
-
-/* Ethernet Controller DMA Channels */
-
-#define MAC0_TX_DMA_ADDR	0xB4004000
-#define MAC1_TX_DMA_ADDR	0xB4004200
-/* offsets from MAC_TX_RING_ADDR address */
-#define MAC_TX_BUFF0_STATUS	0x0
-#  define TX_FRAME_ABORTED	(1 << 0)
-#  define TX_JAB_TIMEOUT	(1 << 1)
-#  define TX_NO_CARRIER		(1 << 2)
-#  define TX_LOSS_CARRIER	(1 << 3)
-#  define TX_EXC_DEF		(1 << 4)
-#  define TX_LATE_COLL_ABORT	(1 << 5)
-#  define TX_EXC_COLL		(1 << 6)
-#  define TX_UNDERRUN		(1 << 7)
-#  define TX_DEFERRED		(1 << 8)
-#  define TX_LATE_COLL		(1 << 9)
-#  define TX_COLL_CNT_MASK	(0xF << 10)
-#  define TX_PKT_RETRY		(1 << 31)
-#define MAC_TX_BUFF0_ADDR	0x4
-#  define TX_DMA_ENABLE		(1 << 0)
-#  define TX_T_DONE		(1 << 1)
-#  define TX_GET_DMA_BUFFER(X)	(((X) >> 2) & 0x3)
-#define MAC_TX_BUFF0_LEN	0x8
-#define MAC_TX_BUFF1_STATUS	0x10
-#define MAC_TX_BUFF1_ADDR	0x14
-#define MAC_TX_BUFF1_LEN	0x18
-#define MAC_TX_BUFF2_STATUS	0x20
-#define MAC_TX_BUFF2_ADDR	0x24
-#define MAC_TX_BUFF2_LEN	0x28
-#define MAC_TX_BUFF3_STATUS	0x30
-#define MAC_TX_BUFF3_ADDR	0x34
-#define MAC_TX_BUFF3_LEN	0x38
-
-#define MAC0_RX_DMA_ADDR	0xB4004100
-#define MAC1_RX_DMA_ADDR	0xB4004300
-/* offsets from MAC_RX_RING_ADDR */
-#define MAC_RX_BUFF0_STATUS	0x0
-#  define RX_FRAME_LEN_MASK	0x3fff
-#  define RX_WDOG_TIMER		(1 << 14)
-#  define RX_RUNT		(1 << 15)
-#  define RX_OVERLEN		(1 << 16)
-#  define RX_COLL		(1 << 17)
-#  define RX_ETHER		(1 << 18)
-#  define RX_MII_ERROR		(1 << 19)
-#  define RX_DRIBBLING		(1 << 20)
-#  define RX_CRC_ERROR		(1 << 21)
-#  define RX_VLAN1		(1 << 22)
-#  define RX_VLAN2		(1 << 23)
-#  define RX_LEN_ERROR		(1 << 24)
-#  define RX_CNTRL_FRAME	(1 << 25)
-#  define RX_U_CNTRL_FRAME	(1 << 26)
-#  define RX_MCAST_FRAME	(1 << 27)
-#  define RX_BCAST_FRAME	(1 << 28)
-#  define RX_FILTER_FAIL	(1 << 29)
-#  define RX_PACKET_FILTER	(1 << 30)
-#  define RX_MISSED_FRAME	(1 << 31)
-
-#  define RX_ERROR (RX_WDOG_TIMER | RX_RUNT | RX_OVERLEN |  \
-		    RX_COLL | RX_MII_ERROR | RX_CRC_ERROR | \
-		    RX_LEN_ERROR | RX_U_CNTRL_FRAME | RX_MISSED_FRAME)
-#define MAC_RX_BUFF0_ADDR	0x4
-#  define RX_DMA_ENABLE		(1 << 0)
-#  define RX_T_DONE		(1 << 1)
-#  define RX_GET_DMA_BUFFER(X)	(((X) >> 2) & 0x3)
-#  define RX_SET_BUFF_ADDR(X)	((X) & 0xffffffc0)
-#define MAC_RX_BUFF1_STATUS	0x10
-#define MAC_RX_BUFF1_ADDR	0x14
-#define MAC_RX_BUFF2_STATUS	0x20
-#define MAC_RX_BUFF2_ADDR	0x24
-#define MAC_RX_BUFF3_STATUS	0x30
-#define MAC_RX_BUFF3_ADDR	0x34
-
 
 /*
  * The IrDA peripheral has an IRFIRSEL pin, but on the DB/PB boards it's not

commit 1341a826c70fab298d4fd0a81a276ddc4c6f9d65
Author: Manuel Lauss <manuel.lauss@gmail.com>
Date:   Wed Jul 23 16:36:21 2014 +0200

    MIPS: Alchemy: au1000.h: remove unused register definitions
    
    Remove the unused SSI I2S and AC97C register definitions.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/7462/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index b4c3ecb17d48..60754fc63981 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -1003,38 +1003,6 @@ enum soc_au1200_ints {
 #define SYS_RTCMATCH2		(SYS_BASE + 0x54)
 #define SYS_RTCREAD		(SYS_BASE + 0x58)
 
-/* I2S Controller */
-#define I2S_DATA		0xB1000000
-#  define I2S_DATA_MASK		0xffffff
-#define I2S_CONFIG		0xB1000004
-#  define I2S_CONFIG_XU		(1 << 25)
-#  define I2S_CONFIG_XO		(1 << 24)
-#  define I2S_CONFIG_RU		(1 << 23)
-#  define I2S_CONFIG_RO		(1 << 22)
-#  define I2S_CONFIG_TR		(1 << 21)
-#  define I2S_CONFIG_TE		(1 << 20)
-#  define I2S_CONFIG_TF		(1 << 19)
-#  define I2S_CONFIG_RR		(1 << 18)
-#  define I2S_CONFIG_RE		(1 << 17)
-#  define I2S_CONFIG_RF		(1 << 16)
-#  define I2S_CONFIG_PD		(1 << 11)
-#  define I2S_CONFIG_LB		(1 << 10)
-#  define I2S_CONFIG_IC		(1 << 9)
-#  define I2S_CONFIG_FM_BIT	7
-#  define I2S_CONFIG_FM_MASK	(0x3 << I2S_CONFIG_FM_BIT)
-#    define I2S_CONFIG_FM_I2S	(0x0 << I2S_CONFIG_FM_BIT)
-#    define I2S_CONFIG_FM_LJ	(0x1 << I2S_CONFIG_FM_BIT)
-#    define I2S_CONFIG_FM_RJ	(0x2 << I2S_CONFIG_FM_BIT)
-#  define I2S_CONFIG_TN		(1 << 6)
-#  define I2S_CONFIG_RN		(1 << 5)
-#  define I2S_CONFIG_SZ_BIT	0
-#  define I2S_CONFIG_SZ_MASK	(0x1F << I2S_CONFIG_SZ_BIT)
-
-#define I2S_CONTROL		0xB1000008
-#  define I2S_CONTROL_D		(1 << 1)
-#  define I2S_CONTROL_CE	(1 << 0)
-
-
 /* Ethernet Controllers  */
 
 /* 4 byte offsets from AU1000_ETH_BASE */
@@ -1161,100 +1129,6 @@ enum soc_au1200_ints {
 #define MAC_RX_BUFF3_STATUS	0x30
 #define MAC_RX_BUFF3_ADDR	0x34
 
-/* SSIO */
-#define SSI0_STATUS		0xB1600000
-#  define SSI_STATUS_BF		(1 << 4)
-#  define SSI_STATUS_OF		(1 << 3)
-#  define SSI_STATUS_UF		(1 << 2)
-#  define SSI_STATUS_D		(1 << 1)
-#  define SSI_STATUS_B		(1 << 0)
-#define SSI0_INT		0xB1600004
-#  define SSI_INT_OI		(1 << 3)
-#  define SSI_INT_UI		(1 << 2)
-#  define SSI_INT_DI		(1 << 1)
-#define SSI0_INT_ENABLE		0xB1600008
-#  define SSI_INTE_OIE		(1 << 3)
-#  define SSI_INTE_UIE		(1 << 2)
-#  define SSI_INTE_DIE		(1 << 1)
-#define SSI0_CONFIG		0xB1600020
-#  define SSI_CONFIG_AO		(1 << 24)
-#  define SSI_CONFIG_DO		(1 << 23)
-#  define SSI_CONFIG_ALEN_BIT	20
-#  define SSI_CONFIG_ALEN_MASK	(0x7 << 20)
-#  define SSI_CONFIG_DLEN_BIT	16
-#  define SSI_CONFIG_DLEN_MASK	(0x7 << 16)
-#  define SSI_CONFIG_DD		(1 << 11)
-#  define SSI_CONFIG_AD		(1 << 10)
-#  define SSI_CONFIG_BM_BIT	8
-#  define SSI_CONFIG_BM_MASK	(0x3 << 8)
-#  define SSI_CONFIG_CE		(1 << 7)
-#  define SSI_CONFIG_DP		(1 << 6)
-#  define SSI_CONFIG_DL		(1 << 5)
-#  define SSI_CONFIG_EP		(1 << 4)
-#define SSI0_ADATA		0xB1600024
-#  define SSI_AD_D		(1 << 24)
-#  define SSI_AD_ADDR_BIT	16
-#  define SSI_AD_ADDR_MASK	(0xff << 16)
-#  define SSI_AD_DATA_BIT	0
-#  define SSI_AD_DATA_MASK	(0xfff << 0)
-#define SSI0_CLKDIV		0xB1600028
-#define SSI0_CONTROL		0xB1600100
-#  define SSI_CONTROL_CD	(1 << 1)
-#  define SSI_CONTROL_E		(1 << 0)
-
-/* SSI1 */
-#define SSI1_STATUS		0xB1680000
-#define SSI1_INT		0xB1680004
-#define SSI1_INT_ENABLE		0xB1680008
-#define SSI1_CONFIG		0xB1680020
-#define SSI1_ADATA		0xB1680024
-#define SSI1_CLKDIV		0xB1680028
-#define SSI1_ENABLE		0xB1680100
-
-/*
- * Register content definitions
- */
-#define SSI_STATUS_BF		(1 << 4)
-#define SSI_STATUS_OF		(1 << 3)
-#define SSI_STATUS_UF		(1 << 2)
-#define SSI_STATUS_D		(1 << 1)
-#define SSI_STATUS_B		(1 << 0)
-
-/* SSI_INT */
-#define SSI_INT_OI		(1 << 3)
-#define SSI_INT_UI		(1 << 2)
-#define SSI_INT_DI		(1 << 1)
-
-/* SSI_INTEN */
-#define SSI_INTEN_OIE		(1 << 3)
-#define SSI_INTEN_UIE		(1 << 2)
-#define SSI_INTEN_DIE		(1 << 1)
-
-#define SSI_CONFIG_AO		(1 << 24)
-#define SSI_CONFIG_DO		(1 << 23)
-#define SSI_CONFIG_ALEN		(7 << 20)
-#define SSI_CONFIG_DLEN		(15 << 16)
-#define SSI_CONFIG_DD		(1 << 11)
-#define SSI_CONFIG_AD		(1 << 10)
-#define SSI_CONFIG_BM		(3 << 8)
-#define SSI_CONFIG_CE		(1 << 7)
-#define SSI_CONFIG_DP		(1 << 6)
-#define SSI_CONFIG_DL		(1 << 5)
-#define SSI_CONFIG_EP		(1 << 4)
-#define SSI_CONFIG_ALEN_N(N)	((N-1) << 20)
-#define SSI_CONFIG_DLEN_N(N)	((N-1) << 16)
-#define SSI_CONFIG_BM_HI	(0 << 8)
-#define SSI_CONFIG_BM_LO	(1 << 8)
-#define SSI_CONFIG_BM_CY	(2 << 8)
-
-#define SSI_ADATA_D		(1 << 24)
-#define SSI_ADATA_ADDR		(0xFF << 16)
-#define SSI_ADATA_DATA		0x0FFF
-#define SSI_ADATA_ADDR_N(N)	(N << 16)
-
-#define SSI_ENABLE_CD		(1 << 1)
-#define SSI_ENABLE_E		(1 << 0)
-
 
 /*
  * The IrDA peripheral has an IRFIRSEL pin, but on the DB/PB boards it's not
@@ -1424,37 +1298,6 @@ struct au1k_irda_platform_data {
 #define SYS_CPUPLL		0xB1900060
 #define SYS_AUXPLL		0xB1900064
 
-/* AC97 Controller */
-#define AC97C_CONFIG		0xB0000000
-#  define AC97C_RECV_SLOTS_BIT	13
-#  define AC97C_RECV_SLOTS_MASK (0x3ff << AC97C_RECV_SLOTS_BIT)
-#  define AC97C_XMIT_SLOTS_BIT	3
-#  define AC97C_XMIT_SLOTS_MASK (0x3ff << AC97C_XMIT_SLOTS_BIT)
-#  define AC97C_SG		(1 << 2)
-#  define AC97C_SYNC		(1 << 1)
-#  define AC97C_RESET		(1 << 0)
-#define AC97C_STATUS		0xB0000004
-#  define AC97C_XU		(1 << 11)
-#  define AC97C_XO		(1 << 10)
-#  define AC97C_RU		(1 << 9)
-#  define AC97C_RO		(1 << 8)
-#  define AC97C_READY		(1 << 7)
-#  define AC97C_CP		(1 << 6)
-#  define AC97C_TR		(1 << 5)
-#  define AC97C_TE		(1 << 4)
-#  define AC97C_TF		(1 << 3)
-#  define AC97C_RR		(1 << 2)
-#  define AC97C_RE		(1 << 1)
-#  define AC97C_RF		(1 << 0)
-#define AC97C_DATA		0xB0000008
-#define AC97C_CMD		0xB000000C
-#  define AC97C_WD_BIT		16
-#  define AC97C_READ		(1 << 7)
-#  define AC97C_INDEX_MASK	0x7f
-#define AC97C_CNTRL		0xB0000010
-#  define AC97C_RS		(1 << 1)
-#  define AC97C_CE		(1 << 0)
-
 
 /* The PCI chip selects are outside the 32bit space, and since we can't
  * just program the 36bit addresses into BARs, we have to take a chunk

commit 61d3edb862716c4ab8d7d7fec48101b4d35e9e52
Author: Manuel Lauss <manuel.lauss@gmail.com>
Date:   Thu Mar 27 07:42:29 2014 +0100

    MIPS: Alchemy: remove duplicate UART register offset definitions
    
    The UART register names are identical to the ones in uapi/linux/serial_reg.h,
    which causes build failures in various drivers when they indirectly pull in
    the au1000.h header, for example via gpio.h:
    
    In file included from arch/mips/include/asm/mach-au1x00/gpio.h:13:0,
                     from arch/mips/include/asm/gpio.h:4,
                     from include/linux/gpio.h:48,
                     from include/linux/ssb/ssb.h:9,
                     from drivers/ssb/driver_mipscore.c:11:
    arch/mips/include/asm/mach-au1x00/au1000.h:1171:0: note: this is the location of the previous definition
     #define UART_LSR 0x1C /* Line Status Register */
    
    Get rid of the altogether, nothing in the core Alchemy code depends
    on them any more.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/6664/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 54f9e84db8ac..b4c3ecb17d48 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -1161,18 +1161,6 @@ enum soc_au1200_ints {
 #define MAC_RX_BUFF3_STATUS	0x30
 #define MAC_RX_BUFF3_ADDR	0x34
 
-#define UART_RX		0	/* Receive buffer */
-#define UART_TX		4	/* Transmit buffer */
-#define UART_IER	8	/* Interrupt Enable Register */
-#define UART_IIR	0xC	/* Interrupt ID Register */
-#define UART_FCR	0x10	/* FIFO Control Register */
-#define UART_LCR	0x14	/* Line Control Register */
-#define UART_MCR	0x18	/* Modem Control Register */
-#define UART_LSR	0x1C	/* Line Status Register */
-#define UART_MSR	0x20	/* Modem Status Register */
-#define UART_CLK	0x28	/* Baud Rate Clock Divider */
-#define UART_MOD_CNTRL	0x100	/* Module Control */
-
 /* SSIO */
 #define SSI0_STATUS		0xB1600000
 #  define SSI_STATUS_BF		(1 << 4)

commit 8ff374b9c296b96484d5e63b45b22d0862ffee8f
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Tue Sep 17 16:58:10 2013 +0100

    MIPS: Cleanup CP0 PRId and CP1 FPIR register access masks
    
    Replace hardcoded CP0 PRId and CP1 FPIR register access masks throughout.
    The change does not touch places that use shifted or partial masks.
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/5838/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 3e11a468cdf8..54f9e84db8ac 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -43,6 +43,8 @@
 #include <linux/io.h>
 #include <linux/irq.h>
 
+#include <asm/cpu.h>
+
 /* cpu pipeline flush */
 void static inline au_sync(void)
 {
@@ -140,7 +142,7 @@ static inline int au1xxx_cpu_needs_config_od(void)
 
 static inline int alchemy_get_cputype(void)
 {
-	switch (read_c0_prid() & 0xffff0000) {
+	switch (read_c0_prid() & (PRID_OPT_MASK | PRID_COMP_MASK)) {
 	case 0x00030000:
 		return ALCHEMY_CPU_AU1000;
 		break;

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 569828d3ccab..3e11a468cdf8 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -349,7 +349,7 @@ extern void au1300_vss_block_control(int block, int enable);
 #define AU1000_INTC0_INT_LAST	(AU1000_INTC0_INT_BASE + 31)
 #define AU1000_INTC1_INT_BASE	(AU1000_INTC0_INT_LAST + 1)
 #define AU1000_INTC1_INT_LAST	(AU1000_INTC1_INT_BASE + 31)
-#define AU1000_MAX_INTR 	AU1000_INTC1_INT_LAST
+#define AU1000_MAX_INTR		AU1000_INTC1_INT_LAST
 
 /* Au1300-style (GPIC): 1 controller with up to 128 sources */
 #define ALCHEMY_GPIC_INT_BASE	(MIPS_CPU_IRQ_BASE + 8)
@@ -589,7 +589,7 @@ enum soc_au1550_ints {
 	AU1550_GPIO14_INT,
 	AU1550_GPIO15_INT,
 	AU1550_GPIO200_INT,
-	AU1550_GPIO201_205_INT,	/* Logical or of GPIO201:205 */
+	AU1550_GPIO201_205_INT, /* Logical or of GPIO201:205 */
 	AU1550_GPIO16_INT,
 	AU1550_GPIO17_INT,
 	AU1550_GPIO20_INT,
@@ -603,7 +603,7 @@ enum soc_au1550_ints {
 	AU1550_GPIO28_INT,
 	AU1550_GPIO206_INT,
 	AU1550_GPIO207_INT,
-	AU1550_GPIO208_215_INT,	/* Logical or of GPIO208:215 */
+	AU1550_GPIO208_215_INT, /* Logical or of GPIO208:215 */
 };
 
 enum soc_au1200_ints {
@@ -636,7 +636,7 @@ enum soc_au1200_ints {
 	AU1200_GPIO205_INT,
 	AU1200_GPIO206_INT,
 	AU1200_GPIO207_INT,
-	AU1200_GPIO208_215_INT,	/* Logical OR of 208:215 */
+	AU1200_GPIO208_215_INT, /* Logical OR of 208:215 */
 	AU1200_USB_INT,
 	AU1200_LCD_INT,
 	AU1200_MAE_BOTH_INT,
@@ -823,7 +823,7 @@ enum soc_au1200_ints {
 #define GPIC_GPIO_TO_BIT(gpio)	\
 	(1 << ((gpio) & 0x1f))
 
-#define GPIC_GPIO_BANKOFF(gpio)	\
+#define GPIC_GPIO_BANKOFF(gpio) \
 	(((gpio) >> 5) * 4)
 
 /* Pin Control bits: who owns the pin, what does it do */
@@ -958,32 +958,32 @@ enum soc_au1200_ints {
 #define MEM_STSTAT		0xB4001104
 
 #define MEM_STNAND_CMD		0x0
-#define MEM_STNAND_ADDR 	0x4
-#define MEM_STNAND_DATA 	0x20
+#define MEM_STNAND_ADDR		0x4
+#define MEM_STNAND_DATA		0x20
 
 
 /* Programmable Counters 0 and 1 */
 #define SYS_BASE		0xB1900000
 #define SYS_COUNTER_CNTRL	(SYS_BASE + 0x14)
-#  define SYS_CNTRL_E1S 	(1 << 23)
-#  define SYS_CNTRL_T1S 	(1 << 20)
-#  define SYS_CNTRL_M21 	(1 << 19)
-#  define SYS_CNTRL_M11 	(1 << 18)
-#  define SYS_CNTRL_M01 	(1 << 17)
-#  define SYS_CNTRL_C1S 	(1 << 16)
+#  define SYS_CNTRL_E1S		(1 << 23)
+#  define SYS_CNTRL_T1S		(1 << 20)
+#  define SYS_CNTRL_M21		(1 << 19)
+#  define SYS_CNTRL_M11		(1 << 18)
+#  define SYS_CNTRL_M01		(1 << 17)
+#  define SYS_CNTRL_C1S		(1 << 16)
 #  define SYS_CNTRL_BP		(1 << 14)
-#  define SYS_CNTRL_EN1 	(1 << 13)
-#  define SYS_CNTRL_BT1 	(1 << 12)
-#  define SYS_CNTRL_EN0 	(1 << 11)
-#  define SYS_CNTRL_BT0 	(1 << 10)
+#  define SYS_CNTRL_EN1		(1 << 13)
+#  define SYS_CNTRL_BT1		(1 << 12)
+#  define SYS_CNTRL_EN0		(1 << 11)
+#  define SYS_CNTRL_BT0		(1 << 10)
 #  define SYS_CNTRL_E0		(1 << 8)
-#  define SYS_CNTRL_E0S 	(1 << 7)
-#  define SYS_CNTRL_32S 	(1 << 5)
-#  define SYS_CNTRL_T0S 	(1 << 4)
-#  define SYS_CNTRL_M20 	(1 << 3)
-#  define SYS_CNTRL_M10 	(1 << 2)
-#  define SYS_CNTRL_M00 	(1 << 1)
-#  define SYS_CNTRL_C0S 	(1 << 0)
+#  define SYS_CNTRL_E0S		(1 << 7)
+#  define SYS_CNTRL_32S		(1 << 5)
+#  define SYS_CNTRL_T0S		(1 << 4)
+#  define SYS_CNTRL_M20		(1 << 3)
+#  define SYS_CNTRL_M10		(1 << 2)
+#  define SYS_CNTRL_M00		(1 << 1)
+#  define SYS_CNTRL_C0S		(1 << 0)
 
 /* Programmable Counter 0 Registers */
 #define SYS_TOYTRIM		(SYS_BASE + 0)
@@ -1003,33 +1003,33 @@ enum soc_au1200_ints {
 
 /* I2S Controller */
 #define I2S_DATA		0xB1000000
-#  define I2S_DATA_MASK 	0xffffff
+#  define I2S_DATA_MASK		0xffffff
 #define I2S_CONFIG		0xB1000004
-#  define I2S_CONFIG_XU 	(1 << 25)
-#  define I2S_CONFIG_XO 	(1 << 24)
-#  define I2S_CONFIG_RU 	(1 << 23)
-#  define I2S_CONFIG_RO 	(1 << 22)
-#  define I2S_CONFIG_TR 	(1 << 21)
-#  define I2S_CONFIG_TE 	(1 << 20)
-#  define I2S_CONFIG_TF 	(1 << 19)
-#  define I2S_CONFIG_RR 	(1 << 18)
-#  define I2S_CONFIG_RE 	(1 << 17)
-#  define I2S_CONFIG_RF 	(1 << 16)
-#  define I2S_CONFIG_PD 	(1 << 11)
-#  define I2S_CONFIG_LB 	(1 << 10)
-#  define I2S_CONFIG_IC 	(1 << 9)
+#  define I2S_CONFIG_XU		(1 << 25)
+#  define I2S_CONFIG_XO		(1 << 24)
+#  define I2S_CONFIG_RU		(1 << 23)
+#  define I2S_CONFIG_RO		(1 << 22)
+#  define I2S_CONFIG_TR		(1 << 21)
+#  define I2S_CONFIG_TE		(1 << 20)
+#  define I2S_CONFIG_TF		(1 << 19)
+#  define I2S_CONFIG_RR		(1 << 18)
+#  define I2S_CONFIG_RE		(1 << 17)
+#  define I2S_CONFIG_RF		(1 << 16)
+#  define I2S_CONFIG_PD		(1 << 11)
+#  define I2S_CONFIG_LB		(1 << 10)
+#  define I2S_CONFIG_IC		(1 << 9)
 #  define I2S_CONFIG_FM_BIT	7
 #  define I2S_CONFIG_FM_MASK	(0x3 << I2S_CONFIG_FM_BIT)
 #    define I2S_CONFIG_FM_I2S	(0x0 << I2S_CONFIG_FM_BIT)
 #    define I2S_CONFIG_FM_LJ	(0x1 << I2S_CONFIG_FM_BIT)
 #    define I2S_CONFIG_FM_RJ	(0x2 << I2S_CONFIG_FM_BIT)
-#  define I2S_CONFIG_TN 	(1 << 6)
-#  define I2S_CONFIG_RN 	(1 << 5)
+#  define I2S_CONFIG_TN		(1 << 6)
+#  define I2S_CONFIG_RN		(1 << 5)
 #  define I2S_CONFIG_SZ_BIT	0
 #  define I2S_CONFIG_SZ_MASK	(0x1F << I2S_CONFIG_SZ_BIT)
 
 #define I2S_CONTROL		0xB1000008
-#  define I2S_CONTROL_D 	(1 << 1)
+#  define I2S_CONTROL_D		(1 << 1)
 #  define I2S_CONTROL_CE	(1 << 0)
 
 
@@ -1037,16 +1037,16 @@ enum soc_au1200_ints {
 
 /* 4 byte offsets from AU1000_ETH_BASE */
 #define MAC_CONTROL		0x0
-#  define MAC_RX_ENABLE 	(1 << 2)
-#  define MAC_TX_ENABLE 	(1 << 3)
-#  define MAC_DEF_CHECK 	(1 << 5)
-#  define MAC_SET_BL(X) 	(((X) & 0x3) << 6)
+#  define MAC_RX_ENABLE		(1 << 2)
+#  define MAC_TX_ENABLE		(1 << 3)
+#  define MAC_DEF_CHECK		(1 << 5)
+#  define MAC_SET_BL(X)		(((X) & 0x3) << 6)
 #  define MAC_AUTO_PAD		(1 << 8)
 #  define MAC_DISABLE_RETRY	(1 << 10)
 #  define MAC_DISABLE_BCAST	(1 << 11)
 #  define MAC_LATE_COL		(1 << 12)
-#  define MAC_HASH_MODE 	(1 << 13)
-#  define MAC_HASH_ONLY 	(1 << 15)
+#  define MAC_HASH_MODE		(1 << 13)
+#  define MAC_HASH_ONLY		(1 << 15)
 #  define MAC_PASS_ALL		(1 << 16)
 #  define MAC_INVERSE_FILTER	(1 << 17)
 #  define MAC_PROMISCUOUS	(1 << 18)
@@ -1083,9 +1083,9 @@ enum soc_au1200_ints {
 #  define MAC_EN_RESET0		(1 << 1)
 #  define MAC_EN_TOSS		(0 << 2)
 #  define MAC_EN_CACHEABLE	(1 << 3)
-#  define MAC_EN_RESET1 	(1 << 4)
-#  define MAC_EN_RESET2 	(1 << 5)
-#  define MAC_DMA_RESET 	(1 << 6)
+#  define MAC_EN_RESET1		(1 << 4)
+#  define MAC_EN_RESET2		(1 << 5)
+#  define MAC_DMA_RESET		(1 << 6)
 
 /* Ethernet Controller DMA Channels */
 
@@ -1095,7 +1095,7 @@ enum soc_au1200_ints {
 #define MAC_TX_BUFF0_STATUS	0x0
 #  define TX_FRAME_ABORTED	(1 << 0)
 #  define TX_JAB_TIMEOUT	(1 << 1)
-#  define TX_NO_CARRIER 	(1 << 2)
+#  define TX_NO_CARRIER		(1 << 2)
 #  define TX_LOSS_CARRIER	(1 << 3)
 #  define TX_EXC_DEF		(1 << 4)
 #  define TX_LATE_COLL_ABORT	(1 << 5)
@@ -1106,7 +1106,7 @@ enum soc_au1200_ints {
 #  define TX_COLL_CNT_MASK	(0xF << 10)
 #  define TX_PKT_RETRY		(1 << 31)
 #define MAC_TX_BUFF0_ADDR	0x4
-#  define TX_DMA_ENABLE 	(1 << 0)
+#  define TX_DMA_ENABLE		(1 << 0)
 #  define TX_T_DONE		(1 << 1)
 #  define TX_GET_DMA_BUFFER(X)	(((X) >> 2) & 0x3)
 #define MAC_TX_BUFF0_LEN	0x8
@@ -1125,7 +1125,7 @@ enum soc_au1200_ints {
 /* offsets from MAC_RX_RING_ADDR */
 #define MAC_RX_BUFF0_STATUS	0x0
 #  define RX_FRAME_LEN_MASK	0x3fff
-#  define RX_WDOG_TIMER 	(1 << 14)
+#  define RX_WDOG_TIMER		(1 << 14)
 #  define RX_RUNT		(1 << 15)
 #  define RX_OVERLEN		(1 << 16)
 #  define RX_COLL		(1 << 17)
@@ -1148,7 +1148,7 @@ enum soc_au1200_ints {
 		    RX_COLL | RX_MII_ERROR | RX_CRC_ERROR | \
 		    RX_LEN_ERROR | RX_U_CNTRL_FRAME | RX_MISSED_FRAME)
 #define MAC_RX_BUFF0_ADDR	0x4
-#  define RX_DMA_ENABLE 	(1 << 0)
+#  define RX_DMA_ENABLE		(1 << 0)
 #  define RX_T_DONE		(1 << 1)
 #  define RX_GET_DMA_BUFFER(X)	(((X) >> 2) & 0x3)
 #  define RX_SET_BUFF_ADDR(X)	((X) & 0xffffffc0)
@@ -1173,34 +1173,34 @@ enum soc_au1200_ints {
 
 /* SSIO */
 #define SSI0_STATUS		0xB1600000
-#  define SSI_STATUS_BF 	(1 << 4)
-#  define SSI_STATUS_OF 	(1 << 3)
-#  define SSI_STATUS_UF 	(1 << 2)
+#  define SSI_STATUS_BF		(1 << 4)
+#  define SSI_STATUS_OF		(1 << 3)
+#  define SSI_STATUS_UF		(1 << 2)
 #  define SSI_STATUS_D		(1 << 1)
 #  define SSI_STATUS_B		(1 << 0)
 #define SSI0_INT		0xB1600004
 #  define SSI_INT_OI		(1 << 3)
 #  define SSI_INT_UI		(1 << 2)
 #  define SSI_INT_DI		(1 << 1)
-#define SSI0_INT_ENABLE 	0xB1600008
+#define SSI0_INT_ENABLE		0xB1600008
 #  define SSI_INTE_OIE		(1 << 3)
 #  define SSI_INTE_UIE		(1 << 2)
 #  define SSI_INTE_DIE		(1 << 1)
 #define SSI0_CONFIG		0xB1600020
-#  define SSI_CONFIG_AO 	(1 << 24)
-#  define SSI_CONFIG_DO 	(1 << 23)
+#  define SSI_CONFIG_AO		(1 << 24)
+#  define SSI_CONFIG_DO		(1 << 23)
 #  define SSI_CONFIG_ALEN_BIT	20
 #  define SSI_CONFIG_ALEN_MASK	(0x7 << 20)
 #  define SSI_CONFIG_DLEN_BIT	16
 #  define SSI_CONFIG_DLEN_MASK	(0x7 << 16)
-#  define SSI_CONFIG_DD 	(1 << 11)
-#  define SSI_CONFIG_AD 	(1 << 10)
+#  define SSI_CONFIG_DD		(1 << 11)
+#  define SSI_CONFIG_AD		(1 << 10)
 #  define SSI_CONFIG_BM_BIT	8
 #  define SSI_CONFIG_BM_MASK	(0x3 << 8)
-#  define SSI_CONFIG_CE 	(1 << 7)
-#  define SSI_CONFIG_DP 	(1 << 6)
-#  define SSI_CONFIG_DL 	(1 << 5)
-#  define SSI_CONFIG_EP 	(1 << 4)
+#  define SSI_CONFIG_CE		(1 << 7)
+#  define SSI_CONFIG_DP		(1 << 6)
+#  define SSI_CONFIG_DL		(1 << 5)
+#  define SSI_CONFIG_EP		(1 << 4)
 #define SSI0_ADATA		0xB1600024
 #  define SSI_AD_D		(1 << 24)
 #  define SSI_AD_ADDR_BIT	16
@@ -1210,12 +1210,12 @@ enum soc_au1200_ints {
 #define SSI0_CLKDIV		0xB1600028
 #define SSI0_CONTROL		0xB1600100
 #  define SSI_CONTROL_CD	(1 << 1)
-#  define SSI_CONTROL_E 	(1 << 0)
+#  define SSI_CONTROL_E		(1 << 0)
 
 /* SSI1 */
 #define SSI1_STATUS		0xB1680000
 #define SSI1_INT		0xB1680004
-#define SSI1_INT_ENABLE 	0xB1680008
+#define SSI1_INT_ENABLE		0xB1680008
 #define SSI1_CONFIG		0xB1680020
 #define SSI1_ADATA		0xB1680024
 #define SSI1_CLKDIV		0xB1680028
@@ -1242,8 +1242,8 @@ enum soc_au1200_ints {
 
 #define SSI_CONFIG_AO		(1 << 24)
 #define SSI_CONFIG_DO		(1 << 23)
-#define SSI_CONFIG_ALEN 	(7 << 20)
-#define SSI_CONFIG_DLEN 	(15 << 16)
+#define SSI_CONFIG_ALEN		(7 << 20)
+#define SSI_CONFIG_DLEN		(15 << 16)
 #define SSI_CONFIG_DD		(1 << 11)
 #define SSI_CONFIG_AD		(1 << 10)
 #define SSI_CONFIG_BM		(3 << 8)
@@ -1305,7 +1305,7 @@ struct au1k_irda_platform_data {
 #  define SYS_PF_CS		(1 << 16)	/* EXTCLK0/32KHz to gpio2 */
 #  define SYS_PF_EX0		(1 << 9)	/* GPIO2/clock */
 
-/* Au1550 only.  Redefines lots of pins */
+/* Au1550 only.	 Redefines lots of pins */
 #  define SYS_PF_PSC2_MASK	(7 << 17)
 #  define SYS_PF_PSC2_AC97	0
 #  define SYS_PF_PSC2_SPI	0
@@ -1322,33 +1322,33 @@ struct au1k_irda_platform_data {
 #  define SYS_PF_MUST_BE_SET	((1 << 5) | (1 << 2))
 
 /* Au1200 only */
-#define SYS_PINFUNC_DMA 	(1 << 31)
-#define SYS_PINFUNC_S0A 	(1 << 30)
-#define SYS_PINFUNC_S1A 	(1 << 29)
-#define SYS_PINFUNC_LP0 	(1 << 28)
-#define SYS_PINFUNC_LP1 	(1 << 27)
-#define SYS_PINFUNC_LD16 	(1 << 26)
-#define SYS_PINFUNC_LD8 	(1 << 25)
-#define SYS_PINFUNC_LD1 	(1 << 24)
-#define SYS_PINFUNC_LD0 	(1 << 23)
-#define SYS_PINFUNC_P1A 	(3 << 21)
-#define SYS_PINFUNC_P1B 	(1 << 20)
-#define SYS_PINFUNC_FS3 	(1 << 19)
-#define SYS_PINFUNC_P0A 	(3 << 17)
+#define SYS_PINFUNC_DMA		(1 << 31)
+#define SYS_PINFUNC_S0A		(1 << 30)
+#define SYS_PINFUNC_S1A		(1 << 29)
+#define SYS_PINFUNC_LP0		(1 << 28)
+#define SYS_PINFUNC_LP1		(1 << 27)
+#define SYS_PINFUNC_LD16	(1 << 26)
+#define SYS_PINFUNC_LD8		(1 << 25)
+#define SYS_PINFUNC_LD1		(1 << 24)
+#define SYS_PINFUNC_LD0		(1 << 23)
+#define SYS_PINFUNC_P1A		(3 << 21)
+#define SYS_PINFUNC_P1B		(1 << 20)
+#define SYS_PINFUNC_FS3		(1 << 19)
+#define SYS_PINFUNC_P0A		(3 << 17)
 #define SYS_PINFUNC_CS		(1 << 16)
-#define SYS_PINFUNC_CIM 	(1 << 15)
-#define SYS_PINFUNC_P1C 	(1 << 14)
-#define SYS_PINFUNC_U1T 	(1 << 12)
-#define SYS_PINFUNC_U1R 	(1 << 11)
-#define SYS_PINFUNC_EX1 	(1 << 10)
-#define SYS_PINFUNC_EX0 	(1 << 9)
-#define SYS_PINFUNC_U0R 	(1 << 8)
+#define SYS_PINFUNC_CIM		(1 << 15)
+#define SYS_PINFUNC_P1C		(1 << 14)
+#define SYS_PINFUNC_U1T		(1 << 12)
+#define SYS_PINFUNC_U1R		(1 << 11)
+#define SYS_PINFUNC_EX1		(1 << 10)
+#define SYS_PINFUNC_EX0		(1 << 9)
+#define SYS_PINFUNC_U0R		(1 << 8)
 #define SYS_PINFUNC_MC		(1 << 7)
-#define SYS_PINFUNC_S0B 	(1 << 6)
-#define SYS_PINFUNC_S0C 	(1 << 5)
-#define SYS_PINFUNC_P0B 	(1 << 4)
-#define SYS_PINFUNC_U0T 	(1 << 3)
-#define SYS_PINFUNC_S1B 	(1 << 2)
+#define SYS_PINFUNC_S0B		(1 << 6)
+#define SYS_PINFUNC_S0C		(1 << 5)
+#define SYS_PINFUNC_P0B		(1 << 4)
+#define SYS_PINFUNC_U0T		(1 << 3)
+#define SYS_PINFUNC_S1B		(1 << 2)
 
 /* Power Management */
 #define SYS_SCRATCH0		0xB1900018
@@ -1405,7 +1405,7 @@ struct au1k_irda_platform_data {
 #  define SYS_CS_DI2		(1 << 16)
 #  define SYS_CS_CI2		(1 << 15)
 
-#  define SYS_CS_ML_BIT 	7
+#  define SYS_CS_ML_BIT		7
 #  define SYS_CS_ML_MASK	(0x7 << SYS_CS_ML_BIT)
 #  define SYS_CS_DL		(1 << 6)
 #  define SYS_CS_CL		(1 << 5)
@@ -1554,8 +1554,8 @@ struct au1k_irda_platform_data {
 #define PCI_MWMASKDEV_MWMASK(x) (((x) & 0xffff) << 16)
 #define PCI_MWMASKDEV_DEVID(x)	((x) & 0xffff)
 #define PCI_MWBASEREVCCL_BASE(x) (((x) & 0xffff) << 16)
-#define PCI_MWBASEREVCCL_REV(x)  (((x) & 0xff) << 8)
-#define PCI_MWBASEREVCCL_CCL(x)  ((x) & 0xff)
+#define PCI_MWBASEREVCCL_REV(x)	 (((x) & 0xff) << 8)
+#define PCI_MWBASEREVCCL_CCL(x)	 ((x) & 0xff)
 #define PCI_ID_DID(x)		(((x) & 0xffff) << 16)
 #define PCI_ID_VID(x)		((x) & 0xffff)
 #define PCI_STATCMD_STATUS(x)	(((x) & 0xffff) << 16)

commit cd671c16f0b18c83d949218867b2d88583080b36
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Thu Dec 8 10:42:15 2011 +0000

    net/irda: convert au1k_ir to platform driver.
    
    Moderate driver cleanup:
    convert to platform driver, get rid of board-specific code.
    
    Driver loads and runs on a DB1100 board.  But since I have no other
    IrDA hardware to exchange data with I can't say whether it really sends
    and receives.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@googlemail.com>
    Cc: Samuel Ortiz <samuel@sortiz.org>
    Cc: netdev@vger.kernel.org
    To: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/2877/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 65f126217175..569828d3ccab 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -1265,44 +1265,20 @@ enum soc_au1200_ints {
 #define SSI_ENABLE_CD		(1 << 1)
 #define SSI_ENABLE_E		(1 << 0)
 
-/* IrDA Controller */
-#define IRDA_BASE		0xB0300000
-#define IR_RING_PTR_STATUS	(IRDA_BASE + 0x00)
-#define IR_RING_BASE_ADDR_H	(IRDA_BASE + 0x04)
-#define IR_RING_BASE_ADDR_L	(IRDA_BASE + 0x08)
-#define IR_RING_SIZE		(IRDA_BASE + 0x0C)
-#define IR_RING_PROMPT		(IRDA_BASE + 0x10)
-#define IR_RING_ADDR_CMPR	(IRDA_BASE + 0x14)
-#define IR_INT_CLEAR		(IRDA_BASE + 0x18)
-#define IR_CONFIG_1		(IRDA_BASE + 0x20)
-#  define IR_RX_INVERT_LED	(1 << 0)
-#  define IR_TX_INVERT_LED	(1 << 1)
-#  define IR_ST 		(1 << 2)
-#  define IR_SF 		(1 << 3)
-#  define IR_SIR		(1 << 4)
-#  define IR_MIR		(1 << 5)
-#  define IR_FIR		(1 << 6)
-#  define IR_16CRC		(1 << 7)
-#  define IR_TD 		(1 << 8)
-#  define IR_RX_ALL		(1 << 9)
-#  define IR_DMA_ENABLE 	(1 << 10)
-#  define IR_RX_ENABLE		(1 << 11)
-#  define IR_TX_ENABLE		(1 << 12)
-#  define IR_LOOPBACK		(1 << 14)
-#  define IR_SIR_MODE		(IR_SIR | IR_DMA_ENABLE | \
-				 IR_RX_ALL | IR_RX_ENABLE | IR_SF | IR_16CRC)
-#define IR_SIR_FLAGS		(IRDA_BASE + 0x24)
-#define IR_ENABLE		(IRDA_BASE + 0x28)
-#  define IR_RX_STATUS		(1 << 9)
-#  define IR_TX_STATUS		(1 << 10)
-#define IR_READ_PHY_CONFIG	(IRDA_BASE + 0x2C)
-#define IR_WRITE_PHY_CONFIG	(IRDA_BASE + 0x30)
-#define IR_MAX_PKT_LEN		(IRDA_BASE + 0x34)
-#define IR_RX_BYTE_CNT		(IRDA_BASE + 0x38)
-#define IR_CONFIG_2		(IRDA_BASE + 0x3C)
-#  define IR_MODE_INV		(1 << 0)
-#  define IR_ONE_PIN		(1 << 1)
-#define IR_INTERFACE_CONFIG	(IRDA_BASE + 0x40)
+
+/*
+ * The IrDA peripheral has an IRFIRSEL pin, but on the DB/PB boards it's not
+ * used to select FIR/SIR mode on the transceiver but as a GPIO.  Instead a
+ * CPLD has to be told about the mode.
+ */
+#define AU1000_IRDA_PHY_MODE_OFF	0
+#define AU1000_IRDA_PHY_MODE_SIR	1
+#define AU1000_IRDA_PHY_MODE_FIR	2
+
+struct au1k_irda_platform_data {
+	void(*set_phy_mode)(int mode);
+};
+
 
 /* GPIO */
 #define SYS_PINFUNC		0xB190002C

commit 809f36c6f4a0568178c909ff1096ca83eae33f7d
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Tue Nov 1 20:03:30 2011 +0100

    MIPS: Alchemy: Au1300 SoC support
    
    Add basic support for the Au1300 variant(s):
    - New GPIO/Interrupt controller
    - DBDMA ids
    - USB setup
    - MMC support
    - enable various PSC drivers
    - detection code.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@googlemail.com>
    To: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/2866/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index de24ec57dd2f..65f126217175 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -136,6 +136,7 @@ static inline int au1xxx_cpu_needs_config_od(void)
 #define ALCHEMY_CPU_AU1100	2
 #define ALCHEMY_CPU_AU1550	3
 #define ALCHEMY_CPU_AU1200	4
+#define ALCHEMY_CPU_AU1300	5
 
 static inline int alchemy_get_cputype(void)
 {
@@ -156,6 +157,9 @@ static inline int alchemy_get_cputype(void)
 	case 0x05030000:
 		return ALCHEMY_CPU_AU1200;
 		break;
+	case 0x800c0000:
+		return ALCHEMY_CPU_AU1300;
+		break;
 	}
 
 	return ALCHEMY_CPU_UNKNOWN;
@@ -166,6 +170,7 @@ static inline int alchemy_get_uarts(int type)
 {
 	switch (type) {
 	case ALCHEMY_CPU_AU1000:
+	case ALCHEMY_CPU_AU1300:
 		return 4;
 	case ALCHEMY_CPU_AU1500:
 	case ALCHEMY_CPU_AU1200:
@@ -243,6 +248,7 @@ extern unsigned long au1xxx_calc_clock(void);
 /* PM: arch/mips/alchemy/common/sleeper.S, power.c, irq.c */
 void alchemy_sleep_au1000(void);
 void alchemy_sleep_au1550(void);
+void alchemy_sleep_au1300(void);
 void au_sleep(void);
 
 /* USB: drivers/usb/host/alchemy-common.c */
@@ -251,6 +257,7 @@ enum alchemy_usb_block {
 	ALCHEMY_USB_UDC0,
 	ALCHEMY_USB_EHCI0,
 	ALCHEMY_USB_OTG0,
+	ALCHEMY_USB_OHCI1,
 };
 int alchemy_usb_control(int block, int enable);
 
@@ -263,14 +270,92 @@ struct alchemy_pci_platdata {
 	unsigned long pci_cfg_clr;
 };
 
-/* SOC Interrupt numbers */
+/* Multifunction pins: Each of these pins can either be assigned to the
+ * GPIO controller or a on-chip peripheral.
+ * Call "au1300_pinfunc_to_dev()" or "au1300_pinfunc_to_gpio()" to
+ * assign one of these to either the GPIO controller or the device.
+ */
+enum au1300_multifunc_pins {
+	/* wake-from-str pins 0-3 */
+	AU1300_PIN_WAKE0 = 0, AU1300_PIN_WAKE1, AU1300_PIN_WAKE2,
+	AU1300_PIN_WAKE3,
+	/* external clock sources for PSCs: 4-5 */
+	AU1300_PIN_EXTCLK0, AU1300_PIN_EXTCLK1,
+	/* 8bit MMC interface on SD0: 6-9 */
+	AU1300_PIN_SD0DAT4, AU1300_PIN_SD0DAT5, AU1300_PIN_SD0DAT6,
+	AU1300_PIN_SD0DAT7,
+	/* aux clk input for freqgen 3: 10 */
+	AU1300_PIN_FG3AUX,
+	/* UART1 pins: 11-18 */
+	AU1300_PIN_U1RI, AU1300_PIN_U1DCD, AU1300_PIN_U1DSR,
+	AU1300_PIN_U1CTS, AU1300_PIN_U1RTS, AU1300_PIN_U1DTR,
+	AU1300_PIN_U1RX, AU1300_PIN_U1TX,
+	/* UART0 pins: 19-24 */
+	AU1300_PIN_U0RI, AU1300_PIN_U0DCD, AU1300_PIN_U0DSR,
+	AU1300_PIN_U0CTS, AU1300_PIN_U0RTS, AU1300_PIN_U0DTR,
+	/* UART2: 25-26 */
+	AU1300_PIN_U2RX, AU1300_PIN_U2TX,
+	/* UART3: 27-28 */
+	AU1300_PIN_U3RX, AU1300_PIN_U3TX,
+	/* LCD controller PWMs, ext pixclock: 29-31 */
+	AU1300_PIN_LCDPWM0, AU1300_PIN_LCDPWM1, AU1300_PIN_LCDCLKIN,
+	/* SD1 interface: 32-37 */
+	AU1300_PIN_SD1DAT0, AU1300_PIN_SD1DAT1, AU1300_PIN_SD1DAT2,
+	AU1300_PIN_SD1DAT3, AU1300_PIN_SD1CMD, AU1300_PIN_SD1CLK,
+	/* SD2 interface: 38-43 */
+	AU1300_PIN_SD2DAT0, AU1300_PIN_SD2DAT1, AU1300_PIN_SD2DAT2,
+	AU1300_PIN_SD2DAT3, AU1300_PIN_SD2CMD, AU1300_PIN_SD2CLK,
+	/* PSC0/1 clocks: 44-45 */
+	AU1300_PIN_PSC0CLK, AU1300_PIN_PSC1CLK,
+	/* PSCs: 46-49/50-53/54-57/58-61 */
+	AU1300_PIN_PSC0SYNC0, AU1300_PIN_PSC0SYNC1, AU1300_PIN_PSC0D0,
+	AU1300_PIN_PSC0D1,
+	AU1300_PIN_PSC1SYNC0, AU1300_PIN_PSC1SYNC1, AU1300_PIN_PSC1D0,
+	AU1300_PIN_PSC1D1,
+	AU1300_PIN_PSC2SYNC0, AU1300_PIN_PSC2SYNC1, AU1300_PIN_PSC2D0,
+	AU1300_PIN_PSC2D1,
+	AU1300_PIN_PSC3SYNC0, AU1300_PIN_PSC3SYNC1, AU1300_PIN_PSC3D0,
+	AU1300_PIN_PSC3D1,
+	/* PCMCIA interface: 62-70 */
+	AU1300_PIN_PCE2, AU1300_PIN_PCE1, AU1300_PIN_PIOS16,
+	AU1300_PIN_PIOR, AU1300_PIN_PWE, AU1300_PIN_PWAIT,
+	AU1300_PIN_PREG, AU1300_PIN_POE, AU1300_PIN_PIOW,
+	/* camera interface H/V sync inputs: 71-72 */
+	AU1300_PIN_CIMLS, AU1300_PIN_CIMFS,
+	/* PSC2/3 clocks: 73-74 */
+	AU1300_PIN_PSC2CLK, AU1300_PIN_PSC3CLK,
+};
+
+/* GPIC (Au1300) pin management: arch/mips/alchemy/common/gpioint.c */
+extern void au1300_pinfunc_to_gpio(enum au1300_multifunc_pins gpio);
+extern void au1300_pinfunc_to_dev(enum au1300_multifunc_pins gpio);
+extern void au1300_set_irq_priority(unsigned int irq, int p);
+extern void au1300_set_dbdma_gpio(int dchan, unsigned int gpio);
+
+/* Au1300 allows to disconnect certain blocks from internal power supply */
+enum au1300_vss_block {
+	AU1300_VSS_MPE = 0,
+	AU1300_VSS_BSA,
+	AU1300_VSS_GPE,
+	AU1300_VSS_MGP,
+};
+
+extern void au1300_vss_block_control(int block, int enable);
+
 
+/* SOC Interrupt numbers */
+/* Au1000-style (IC0/1): 2 controllers with 32 sources each */
 #define AU1000_INTC0_INT_BASE	(MIPS_CPU_IRQ_BASE + 8)
 #define AU1000_INTC0_INT_LAST	(AU1000_INTC0_INT_BASE + 31)
 #define AU1000_INTC1_INT_BASE	(AU1000_INTC0_INT_LAST + 1)
 #define AU1000_INTC1_INT_LAST	(AU1000_INTC1_INT_BASE + 31)
 #define AU1000_MAX_INTR 	AU1000_INTC1_INT_LAST
 
+/* Au1300-style (GPIC): 1 controller with up to 128 sources */
+#define ALCHEMY_GPIC_INT_BASE	(MIPS_CPU_IRQ_BASE + 8)
+#define ALCHEMY_GPIC_INT_NUM	128
+#define ALCHEMY_GPIC_INT_LAST	(ALCHEMY_GPIC_INT_BASE + ALCHEMY_GPIC_INT_NUM - 1)
+
 enum soc_au1000_ints {
 	AU1000_FIRST_INT	= AU1000_INTC0_INT_BASE,
 	AU1000_UART0_INT	= AU1000_FIRST_INT,
@@ -591,24 +676,77 @@ enum soc_au1200_ints {
 
 #endif /* !defined (_LANGUAGE_ASSEMBLY) */
 
+/* Au1300 peripheral interrupt numbers */
+#define AU1300_FIRST_INT	(ALCHEMY_GPIC_INT_BASE)
+#define AU1300_UART1_INT	(AU1300_FIRST_INT + 17)
+#define AU1300_UART2_INT	(AU1300_FIRST_INT + 25)
+#define AU1300_UART3_INT	(AU1300_FIRST_INT + 27)
+#define AU1300_SD1_INT		(AU1300_FIRST_INT + 32)
+#define AU1300_SD2_INT		(AU1300_FIRST_INT + 38)
+#define AU1300_PSC0_INT		(AU1300_FIRST_INT + 48)
+#define AU1300_PSC1_INT		(AU1300_FIRST_INT + 52)
+#define AU1300_PSC2_INT		(AU1300_FIRST_INT + 56)
+#define AU1300_PSC3_INT		(AU1300_FIRST_INT + 60)
+#define AU1300_NAND_INT		(AU1300_FIRST_INT + 62)
+#define AU1300_DDMA_INT		(AU1300_FIRST_INT + 75)
+#define AU1300_MMU_INT		(AU1300_FIRST_INT + 76)
+#define AU1300_MPU_INT		(AU1300_FIRST_INT + 77)
+#define AU1300_GPU_INT		(AU1300_FIRST_INT + 78)
+#define AU1300_UDMA_INT		(AU1300_FIRST_INT + 79)
+#define AU1300_TOY_INT		(AU1300_FIRST_INT + 80)
+#define AU1300_TOY_MATCH0_INT	(AU1300_FIRST_INT + 81)
+#define AU1300_TOY_MATCH1_INT	(AU1300_FIRST_INT + 82)
+#define AU1300_TOY_MATCH2_INT	(AU1300_FIRST_INT + 83)
+#define AU1300_RTC_INT		(AU1300_FIRST_INT + 84)
+#define AU1300_RTC_MATCH0_INT	(AU1300_FIRST_INT + 85)
+#define AU1300_RTC_MATCH1_INT	(AU1300_FIRST_INT + 86)
+#define AU1300_RTC_MATCH2_INT	(AU1300_FIRST_INT + 87)
+#define AU1300_UART0_INT	(AU1300_FIRST_INT + 88)
+#define AU1300_SD0_INT		(AU1300_FIRST_INT + 89)
+#define AU1300_USB_INT		(AU1300_FIRST_INT + 90)
+#define AU1300_LCD_INT		(AU1300_FIRST_INT + 91)
+#define AU1300_BSA_INT		(AU1300_FIRST_INT + 92)
+#define AU1300_MPE_INT		(AU1300_FIRST_INT + 93)
+#define AU1300_ITE_INT		(AU1300_FIRST_INT + 94)
+#define AU1300_AES_INT		(AU1300_FIRST_INT + 95)
+#define AU1300_CIM_INT		(AU1300_FIRST_INT + 96)
+
+/**********************************************************************/
+
 /*
  * Physical base addresses for integrated peripherals
- * 0..au1000 1..au1500 2..au1100 3..au1550 4..au1200
+ * 0..au1000 1..au1500 2..au1100 3..au1550 4..au1200 5..au1300
  */
 
 #define AU1000_AC97_PHYS_ADDR		0x10000000 /* 012 */
+#define AU1300_ROM_PHYS_ADDR		0x10000000 /* 5 */
+#define AU1300_OTP_PHYS_ADDR		0x10002000 /* 5 */
+#define AU1300_VSS_PHYS_ADDR		0x10003000 /* 5 */
+#define AU1300_UART0_PHYS_ADDR		0x10100000 /* 5 */
+#define AU1300_UART1_PHYS_ADDR		0x10101000 /* 5 */
+#define AU1300_UART2_PHYS_ADDR		0x10102000 /* 5 */
+#define AU1300_UART3_PHYS_ADDR		0x10103000 /* 5 */
 #define AU1000_USB_OHCI_PHYS_ADDR	0x10100000 /* 012 */
 #define AU1000_USB_UDC_PHYS_ADDR	0x10200000 /* 0123 */
+#define AU1300_GPIC_PHYS_ADDR		0x10200000 /* 5 */
 #define AU1000_IRDA_PHYS_ADDR		0x10300000 /* 02 */
-#define AU1200_AES_PHYS_ADDR		0x10300000 /* 4 */
+#define AU1200_AES_PHYS_ADDR		0x10300000 /* 45 */
 #define AU1000_IC0_PHYS_ADDR		0x10400000 /* 01234 */
+#define AU1300_GPU_PHYS_ADDR		0x10500000 /* 5 */
 #define AU1000_MAC0_PHYS_ADDR		0x10500000 /* 023 */
 #define AU1000_MAC1_PHYS_ADDR		0x10510000 /* 023 */
 #define AU1000_MACEN_PHYS_ADDR		0x10520000 /* 023 */
-#define AU1100_SD0_PHYS_ADDR		0x10600000 /* 24 */
+#define AU1100_SD0_PHYS_ADDR		0x10600000 /* 245 */
+#define AU1300_SD1_PHYS_ADDR		0x10601000 /* 5 */
+#define AU1300_SD2_PHYS_ADDR		0x10602000 /* 5 */
 #define AU1100_SD1_PHYS_ADDR		0x10680000 /* 24 */
+#define AU1300_SYS_PHYS_ADDR		0x10900000 /* 5 */
 #define AU1550_PSC2_PHYS_ADDR		0x10A00000 /* 3 */
 #define AU1550_PSC3_PHYS_ADDR		0x10B00000 /* 3 */
+#define AU1300_PSC0_PHYS_ADDR		0x10A00000 /* 5 */
+#define AU1300_PSC1_PHYS_ADDR		0x10A01000 /* 5 */
+#define AU1300_PSC2_PHYS_ADDR		0x10A02000 /* 5 */
+#define AU1300_PSC3_PHYS_ADDR		0x10A03000 /* 5 */
 #define AU1000_I2S_PHYS_ADDR		0x11000000 /* 02 */
 #define AU1500_MAC0_PHYS_ADDR		0x11500000 /* 1 */
 #define AU1500_MAC1_PHYS_ADDR		0x11510000 /* 1 */
@@ -622,38 +760,97 @@ enum soc_au1200_ints {
 #define AU1000_SSI1_PHYS_ADDR		0x11680000 /* 02 */
 #define AU1500_GPIO2_PHYS_ADDR		0x11700000 /* 1234 */
 #define AU1000_IC1_PHYS_ADDR		0x11800000 /* 01234 */
-#define AU1000_SYS_PHYS_ADDR		0x11900000 /* 01234 */
+#define AU1000_SYS_PHYS_ADDR		0x11900000 /* 012345 */
 #define AU1550_PSC0_PHYS_ADDR		0x11A00000 /* 34 */
 #define AU1550_PSC1_PHYS_ADDR		0x11B00000 /* 34 */
 #define AU1000_MEM_PHYS_ADDR		0x14000000 /* 01234 */
 #define AU1000_STATIC_MEM_PHYS_ADDR	0x14001000 /* 01234 */
+#define AU1300_UDMA_PHYS_ADDR		0x14001800 /* 5 */
 #define AU1000_DMA_PHYS_ADDR		0x14002000 /* 012 */
-#define AU1550_DBDMA_PHYS_ADDR		0x14002000 /* 34 */
-#define AU1550_DBDMA_CONF_PHYS_ADDR	0x14003000 /* 34 */
+#define AU1550_DBDMA_PHYS_ADDR		0x14002000 /* 345 */
+#define AU1550_DBDMA_CONF_PHYS_ADDR	0x14003000 /* 345 */
 #define AU1000_MACDMA0_PHYS_ADDR	0x14004000 /* 0123 */
 #define AU1000_MACDMA1_PHYS_ADDR	0x14004200 /* 0123 */
-#define AU1200_CIM_PHYS_ADDR		0x14004000 /* 4 */
+#define AU1200_CIM_PHYS_ADDR		0x14004000 /* 45 */
 #define AU1500_PCI_PHYS_ADDR		0x14005000 /* 13 */
 #define AU1550_PE_PHYS_ADDR		0x14008000 /* 3 */
 #define AU1200_MAEBE_PHYS_ADDR		0x14010000 /* 4 */
 #define AU1200_MAEFE_PHYS_ADDR		0x14012000 /* 4 */
+#define AU1300_MAEITE_PHYS_ADDR		0x14010000 /* 5 */
+#define AU1300_MAEMPE_PHYS_ADDR		0x14014000 /* 5 */
 #define AU1550_USB_OHCI_PHYS_ADDR	0x14020000 /* 3 */
 #define AU1200_USB_CTL_PHYS_ADDR	0x14020000 /* 4 */
 #define AU1200_USB_OTG_PHYS_ADDR	0x14020020 /* 4 */
 #define AU1200_USB_OHCI_PHYS_ADDR	0x14020100 /* 4 */
 #define AU1200_USB_EHCI_PHYS_ADDR	0x14020200 /* 4 */
 #define AU1200_USB_UDC_PHYS_ADDR	0x14022000 /* 4 */
+#define AU1300_USB_EHCI_PHYS_ADDR	0x14020000 /* 5 */
+#define AU1300_USB_OHCI0_PHYS_ADDR	0x14020400 /* 5 */
+#define AU1300_USB_OHCI1_PHYS_ADDR	0x14020800 /* 5 */
+#define AU1300_USB_CTL_PHYS_ADDR	0x14021000 /* 5 */
+#define AU1300_USB_OTG_PHYS_ADDR	0x14022000 /* 5 */
+#define AU1300_MAEBSA_PHYS_ADDR		0x14030000 /* 5 */
 #define AU1100_LCD_PHYS_ADDR		0x15000000 /* 2 */
-#define AU1200_LCD_PHYS_ADDR		0x15000000 /* 4 */
+#define AU1200_LCD_PHYS_ADDR		0x15000000 /* 45 */
 #define AU1500_PCI_MEM_PHYS_ADDR	0x400000000ULL /* 13 */
 #define AU1500_PCI_IO_PHYS_ADDR		0x500000000ULL /* 13 */
 #define AU1500_PCI_CONFIG0_PHYS_ADDR	0x600000000ULL /* 13 */
 #define AU1500_PCI_CONFIG1_PHYS_ADDR	0x680000000ULL /* 13 */
-#define AU1000_PCMCIA_IO_PHYS_ADDR	0xF00000000ULL /* 01234 */
-#define AU1000_PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL /* 01234 */
-#define AU1000_PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL /* 01234 */
+#define AU1000_PCMCIA_IO_PHYS_ADDR	0xF00000000ULL /* 012345 */
+#define AU1000_PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL /* 012345 */
+#define AU1000_PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL /* 012345 */
+
+/**********************************************************************/
 
 
+/*
+ * Au1300 GPIO+INT controller (GPIC) register offsets and bits
+ * Registers are 128bits (0x10 bytes), divided into 4 "banks".
+ */
+#define AU1300_GPIC_PINVAL	0x0000
+#define AU1300_GPIC_PINVALCLR	0x0010
+#define AU1300_GPIC_IPEND	0x0020
+#define AU1300_GPIC_PRIENC	0x0030
+#define AU1300_GPIC_IEN		0x0040	/* int_mask in manual */
+#define AU1300_GPIC_IDIS	0x0050	/* int_maskclr in manual */
+#define AU1300_GPIC_DMASEL	0x0060
+#define AU1300_GPIC_DEVSEL	0x0080
+#define AU1300_GPIC_DEVCLR	0x0090
+#define AU1300_GPIC_RSTVAL	0x00a0
+/* pin configuration space. one 32bit register for up to 128 IRQs */
+#define AU1300_GPIC_PINCFG	0x1000
+
+#define GPIC_GPIO_TO_BIT(gpio)	\
+	(1 << ((gpio) & 0x1f))
+
+#define GPIC_GPIO_BANKOFF(gpio)	\
+	(((gpio) >> 5) * 4)
+
+/* Pin Control bits: who owns the pin, what does it do */
+#define GPIC_CFG_PC_GPIN		0
+#define GPIC_CFG_PC_DEV			1
+#define GPIC_CFG_PC_GPOLOW		2
+#define GPIC_CFG_PC_GPOHIGH		3
+#define GPIC_CFG_PC_MASK		3
+
+/* assign pin to MIPS IRQ line */
+#define GPIC_CFG_IL_SET(x)	(((x) & 3) << 2)
+#define GPIC_CFG_IL_MASK	(3 << 2)
+
+/* pin interrupt type setup */
+#define GPIC_CFG_IC_OFF		(0 << 4)
+#define GPIC_CFG_IC_LEVEL_LOW	(1 << 4)
+#define GPIC_CFG_IC_LEVEL_HIGH	(2 << 4)
+#define GPIC_CFG_IC_EDGE_FALL	(5 << 4)
+#define GPIC_CFG_IC_EDGE_RISE	(6 << 4)
+#define GPIC_CFG_IC_EDGE_BOTH	(7 << 4)
+#define GPIC_CFG_IC_MASK	(7 << 4)
+
+/* allow interrupt to wake cpu from 'wait' */
+#define GPIC_CFG_IDLEWAKE	(1 << 7)
+
+/***********************************************************************/
+
 /* Au1000 SDRAM memory controller register offsets */
 #define AU1000_MEM_SDMODE0		0x0000
 #define AU1000_MEM_SDMODE1		0x0004

commit 3766386037827fe7064f57f9aec27b3b5e9417aa
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Fri Aug 12 11:39:45 2011 +0200

    MIPS: Alchemy: remove all CONFIG_SOC_AU1??? defines
    
    Now that no driver any longer depends on the CONFIG_SOC_AU1???  symbols,
    it's time to get rid of them: Move some of the platform devices to the
    boards which can use them, Rename a few (unused) constants in the header,
    Replace them with MIPS_ALCHEMY in the various Kconfig files.  Finally
    delete them altogether from the Alchemy Kconfig file.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@googlemail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/2707/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 49a227d681e3..de24ec57dd2f 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -591,113 +591,6 @@ enum soc_au1200_ints {
 
 #endif /* !defined (_LANGUAGE_ASSEMBLY) */
 
-/*
- * SDRAM register offsets
- */
-#if defined(CONFIG_SOC_AU1000) || defined(CONFIG_SOC_AU1500) || \
-    defined(CONFIG_SOC_AU1100)
-#define MEM_SDMODE0		0x0000
-#define MEM_SDMODE1		0x0004
-#define MEM_SDMODE2		0x0008
-#define MEM_SDADDR0		0x000C
-#define MEM_SDADDR1		0x0010
-#define MEM_SDADDR2		0x0014
-#define MEM_SDREFCFG		0x0018
-#define MEM_SDPRECMD		0x001C
-#define MEM_SDAUTOREF		0x0020
-#define MEM_SDWRMD0		0x0024
-#define MEM_SDWRMD1		0x0028
-#define MEM_SDWRMD2		0x002C
-#define MEM_SDSLEEP		0x0030
-#define MEM_SDSMCKE		0x0034
-
-/*
- * MEM_SDMODE register content definitions
- */
-#define MEM_SDMODE_F		(1 << 22)
-#define MEM_SDMODE_SR		(1 << 21)
-#define MEM_SDMODE_BS		(1 << 20)
-#define MEM_SDMODE_RS		(3 << 18)
-#define MEM_SDMODE_CS		(7 << 15)
-#define MEM_SDMODE_TRAS 	(15 << 11)
-#define MEM_SDMODE_TMRD 	(3 << 9)
-#define MEM_SDMODE_TWR		(3 << 7)
-#define MEM_SDMODE_TRP		(3 << 5)
-#define MEM_SDMODE_TRCD 	(3 << 3)
-#define MEM_SDMODE_TCL		(7 << 0)
-
-#define MEM_SDMODE_BS_2Bank	(0 << 20)
-#define MEM_SDMODE_BS_4Bank	(1 << 20)
-#define MEM_SDMODE_RS_11Row	(0 << 18)
-#define MEM_SDMODE_RS_12Row	(1 << 18)
-#define MEM_SDMODE_RS_13Row	(2 << 18)
-#define MEM_SDMODE_RS_N(N)	((N) << 18)
-#define MEM_SDMODE_CS_7Col	(0 << 15)
-#define MEM_SDMODE_CS_8Col	(1 << 15)
-#define MEM_SDMODE_CS_9Col	(2 << 15)
-#define MEM_SDMODE_CS_10Col	(3 << 15)
-#define MEM_SDMODE_CS_11Col	(4 << 15)
-#define MEM_SDMODE_CS_N(N)	((N) << 15)
-#define MEM_SDMODE_TRAS_N(N)	((N) << 11)
-#define MEM_SDMODE_TMRD_N(N)	((N) << 9)
-#define MEM_SDMODE_TWR_N(N)	((N) << 7)
-#define MEM_SDMODE_TRP_N(N)	((N) << 5)
-#define MEM_SDMODE_TRCD_N(N)	((N) << 3)
-#define MEM_SDMODE_TCL_N(N)	((N) << 0)
-
-/*
- * MEM_SDADDR register contents definitions
- */
-#define MEM_SDADDR_E		(1 << 20)
-#define MEM_SDADDR_CSBA 	(0x03FF << 10)
-#define MEM_SDADDR_CSMASK	(0x03FF << 0)
-#define MEM_SDADDR_CSBA_N(N)	((N) & (0x03FF << 22) >> 12)
-#define MEM_SDADDR_CSMASK_N(N)	((N)&(0x03FF << 22) >> 22)
-
-/*
- * MEM_SDREFCFG register content definitions
- */
-#define MEM_SDREFCFG_TRC	(15 << 28)
-#define MEM_SDREFCFG_TRPM	(3 << 26)
-#define MEM_SDREFCFG_E		(1 << 25)
-#define MEM_SDREFCFG_RE 	(0x1ffffff << 0)
-#define MEM_SDREFCFG_TRC_N(N)	((N) << MEM_SDREFCFG_TRC)
-#define MEM_SDREFCFG_TRPM_N(N)	((N) << MEM_SDREFCFG_TRPM)
-#define MEM_SDREFCFG_REF_N(N)	(N)
-#endif
-
-/***********************************************************************/
-
-/*
- * Au1550 SDRAM Register Offsets
- */
-
-/***********************************************************************/
-
-#if defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200)
-#define MEM_SDMODE0		0x0800
-#define MEM_SDMODE1		0x0808
-#define MEM_SDMODE2		0x0810
-#define MEM_SDADDR0		0x0820
-#define MEM_SDADDR1		0x0828
-#define MEM_SDADDR2		0x0830
-#define MEM_SDCONFIGA		0x0840
-#define MEM_SDCONFIGB		0x0848
-#define MEM_SDSTAT		0x0850
-#define MEM_SDERRADDR		0x0858
-#define MEM_SDSTRIDE0		0x0860
-#define MEM_SDSTRIDE1		0x0868
-#define MEM_SDSTRIDE2		0x0870
-#define MEM_SDWRMD0		0x0880
-#define MEM_SDWRMD1		0x0888
-#define MEM_SDWRMD2		0x0890
-#define MEM_SDPRECMD		0x08C0
-#define MEM_SDAUTOREF		0x08C8
-#define MEM_SDSREF		0x08D0
-#define MEM_SDSLEEP		MEM_SDSREF
-
-#endif
-
 /*
  * Physical base addresses for integrated peripherals
  * 0..au1000 1..au1500 2..au1100 3..au1550 4..au1200
@@ -761,6 +654,92 @@ enum soc_au1200_ints {
 #define AU1000_PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL /* 01234 */
 
 
+/* Au1000 SDRAM memory controller register offsets */
+#define AU1000_MEM_SDMODE0		0x0000
+#define AU1000_MEM_SDMODE1		0x0004
+#define AU1000_MEM_SDMODE2		0x0008
+#define AU1000_MEM_SDADDR0		0x000C
+#define AU1000_MEM_SDADDR1		0x0010
+#define AU1000_MEM_SDADDR2		0x0014
+#define AU1000_MEM_SDREFCFG		0x0018
+#define AU1000_MEM_SDPRECMD		0x001C
+#define AU1000_MEM_SDAUTOREF		0x0020
+#define AU1000_MEM_SDWRMD0		0x0024
+#define AU1000_MEM_SDWRMD1		0x0028
+#define AU1000_MEM_SDWRMD2		0x002C
+#define AU1000_MEM_SDSLEEP		0x0030
+#define AU1000_MEM_SDSMCKE		0x0034
+
+/* MEM_SDMODE register content definitions */
+#define MEM_SDMODE_F		(1 << 22)
+#define MEM_SDMODE_SR		(1 << 21)
+#define MEM_SDMODE_BS		(1 << 20)
+#define MEM_SDMODE_RS		(3 << 18)
+#define MEM_SDMODE_CS		(7 << 15)
+#define MEM_SDMODE_TRAS		(15 << 11)
+#define MEM_SDMODE_TMRD		(3 << 9)
+#define MEM_SDMODE_TWR		(3 << 7)
+#define MEM_SDMODE_TRP		(3 << 5)
+#define MEM_SDMODE_TRCD		(3 << 3)
+#define MEM_SDMODE_TCL		(7 << 0)
+
+#define MEM_SDMODE_BS_2Bank	(0 << 20)
+#define MEM_SDMODE_BS_4Bank	(1 << 20)
+#define MEM_SDMODE_RS_11Row	(0 << 18)
+#define MEM_SDMODE_RS_12Row	(1 << 18)
+#define MEM_SDMODE_RS_13Row	(2 << 18)
+#define MEM_SDMODE_RS_N(N)	((N) << 18)
+#define MEM_SDMODE_CS_7Col	(0 << 15)
+#define MEM_SDMODE_CS_8Col	(1 << 15)
+#define MEM_SDMODE_CS_9Col	(2 << 15)
+#define MEM_SDMODE_CS_10Col	(3 << 15)
+#define MEM_SDMODE_CS_11Col	(4 << 15)
+#define MEM_SDMODE_CS_N(N)	((N) << 15)
+#define MEM_SDMODE_TRAS_N(N)	((N) << 11)
+#define MEM_SDMODE_TMRD_N(N)	((N) << 9)
+#define MEM_SDMODE_TWR_N(N)	((N) << 7)
+#define MEM_SDMODE_TRP_N(N)	((N) << 5)
+#define MEM_SDMODE_TRCD_N(N)	((N) << 3)
+#define MEM_SDMODE_TCL_N(N)	((N) << 0)
+
+/* MEM_SDADDR register contents definitions */
+#define MEM_SDADDR_E		(1 << 20)
+#define MEM_SDADDR_CSBA		(0x03FF << 10)
+#define MEM_SDADDR_CSMASK	(0x03FF << 0)
+#define MEM_SDADDR_CSBA_N(N)	((N) & (0x03FF << 22) >> 12)
+#define MEM_SDADDR_CSMASK_N(N)	((N)&(0x03FF << 22) >> 22)
+
+/* MEM_SDREFCFG register content definitions */
+#define MEM_SDREFCFG_TRC	(15 << 28)
+#define MEM_SDREFCFG_TRPM	(3 << 26)
+#define MEM_SDREFCFG_E		(1 << 25)
+#define MEM_SDREFCFG_RE		(0x1ffffff << 0)
+#define MEM_SDREFCFG_TRC_N(N)	((N) << MEM_SDREFCFG_TRC)
+#define MEM_SDREFCFG_TRPM_N(N)	((N) << MEM_SDREFCFG_TRPM)
+#define MEM_SDREFCFG_REF_N(N)	(N)
+
+/* Au1550 SDRAM Register Offsets */
+#define AU1550_MEM_SDMODE0		0x0800
+#define AU1550_MEM_SDMODE1		0x0808
+#define AU1550_MEM_SDMODE2		0x0810
+#define AU1550_MEM_SDADDR0		0x0820
+#define AU1550_MEM_SDADDR1		0x0828
+#define AU1550_MEM_SDADDR2		0x0830
+#define AU1550_MEM_SDCONFIGA		0x0840
+#define AU1550_MEM_SDCONFIGB		0x0848
+#define AU1550_MEM_SDSTAT		0x0850
+#define AU1550_MEM_SDERRADDR		0x0858
+#define AU1550_MEM_SDSTRIDE0		0x0860
+#define AU1550_MEM_SDSTRIDE1		0x0868
+#define AU1550_MEM_SDSTRIDE2		0x0870
+#define AU1550_MEM_SDWRMD0		0x0880
+#define AU1550_MEM_SDWRMD1		0x0888
+#define AU1550_MEM_SDWRMD2		0x0890
+#define AU1550_MEM_SDPRECMD		0x08C0
+#define AU1550_MEM_SDAUTOREF		0x08C8
+#define AU1550_MEM_SDSREF		0x08D0
+#define AU1550_MEM_SDSLEEP		MEM_SDSREF
+
 /* Static Bus Controller */
 #define MEM_STCFG0		0xB4001000
 #define MEM_STTIME0		0xB4001004
@@ -778,14 +757,12 @@ enum soc_au1200_ints {
 #define MEM_STTIME3		0xB4001034
 #define MEM_STADDR3		0xB4001038
 
-#if defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200)
 #define MEM_STNDCTL		0xB4001100
 #define MEM_STSTAT		0xB4001104
 
 #define MEM_STNAND_CMD		0x0
 #define MEM_STNAND_ADDR 	0x4
 #define MEM_STNAND_DATA 	0x20
-#endif
 
 
 /* Programmable Counters 0 and 1 */
@@ -1172,7 +1149,6 @@ enum soc_au1200_ints {
 #  define SYS_PF_MUST_BE_SET	((1 << 5) | (1 << 2))
 
 /* Au1200 only */
-#ifdef CONFIG_SOC_AU1200
 #define SYS_PINFUNC_DMA 	(1 << 31)
 #define SYS_PINFUNC_S0A 	(1 << 30)
 #define SYS_PINFUNC_S1A 	(1 << 29)
@@ -1200,7 +1176,6 @@ enum soc_au1200_ints {
 #define SYS_PINFUNC_P0B 	(1 << 4)
 #define SYS_PINFUNC_U0T 	(1 << 3)
 #define SYS_PINFUNC_S1B 	(1 << 2)
-#endif
 
 /* Power Management */
 #define SYS_SCRATCH0		0xB1900018
@@ -1256,12 +1231,12 @@ enum soc_au1200_ints {
 #  define SYS_CS_MI2_MASK	(0x7 << SYS_CS_MI2_BIT)
 #  define SYS_CS_DI2		(1 << 16)
 #  define SYS_CS_CI2		(1 << 15)
-#ifdef CONFIG_SOC_AU1100
+
 #  define SYS_CS_ML_BIT 	7
 #  define SYS_CS_ML_MASK	(0x7 << SYS_CS_ML_BIT)
 #  define SYS_CS_DL		(1 << 6)
 #  define SYS_CS_CL		(1 << 5)
-#else
+
 #  define SYS_CS_MUH_BIT	12
 #  define SYS_CS_MUH_MASK	(0x7 << SYS_CS_MUH_BIT)
 #  define SYS_CS_DUH		(1 << 11)
@@ -1270,7 +1245,7 @@ enum soc_au1200_ints {
 #  define SYS_CS_MUD_MASK	(0x7 << SYS_CS_MUD_BIT)
 #  define SYS_CS_DUD		(1 << 6)
 #  define SYS_CS_CUD		(1 << 5)
-#endif
+
 #  define SYS_CS_MIR_BIT	2
 #  define SYS_CS_MIR_MASK	(0x7 << SYS_CS_MIR_BIT)
 #  define SYS_CS_DIR		(1 << 1)

commit 7517de348663b08a808aff44b5300e817157a568
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Fri Aug 12 11:39:44 2011 +0200

    MIPS: Alchemy: Redo PCI as platform driver
    
    - Rewrite Alchemy PCI support as a platform driver.
    - Fixup boards which have PCI.
    
    Run-tested on DB1500 and DB1550.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@googlemail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/2706/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    
     delete mode 100644 arch/mips/alchemy/common/pci.c
     delete mode 100644 arch/mips/pci/fixup-au1000.c
     delete mode 100644 arch/mips/pci/ops-au1000.c
     create mode 100644 arch/mips/pci/pci-alchemy.c

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 1bbcb30c4ab9..49a227d681e3 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -254,6 +254,14 @@ enum alchemy_usb_block {
 };
 int alchemy_usb_control(int block, int enable);
 
+/* PCI controller platform data */
+struct alchemy_pci_platdata {
+	int (*board_map_irq)(const struct pci_dev *d, u8 slot, u8 pin);
+	int (*board_pci_idsel)(unsigned int devsel, int assert);
+	/* bits to set/clear in PCI_CONFIG register */
+	unsigned long pci_cfg_set;
+	unsigned long pci_cfg_clr;
+};
 
 /* SOC Interrupt numbers */
 
@@ -1309,58 +1317,30 @@ enum soc_au1200_ints {
 #  define AC97C_RS		(1 << 1)
 #  define AC97C_CE		(1 << 0)
 
-#if defined(CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1550)
-/* Au1500 PCI Controller */
-#define Au1500_CFG_BASE 	0xB4005000	/* virtual, KSEG1 addr */
-#define Au1500_PCI_CMEM 	(Au1500_CFG_BASE + 0)
-#define Au1500_PCI_CFG		(Au1500_CFG_BASE + 4)
-#  define PCI_ERROR		((1 << 22) | (1 << 23) | (1 << 24) | \
-				 (1 << 25) | (1 << 26) | (1 << 27))
-#define Au1500_PCI_B2BMASK_CCH	(Au1500_CFG_BASE + 8)
-#define Au1500_PCI_B2B0_VID	(Au1500_CFG_BASE + 0xC)
-#define Au1500_PCI_B2B1_ID	(Au1500_CFG_BASE + 0x10)
-#define Au1500_PCI_MWMASK_DEV	(Au1500_CFG_BASE + 0x14)
-#define Au1500_PCI_MWBASE_REV_CCL (Au1500_CFG_BASE + 0x18)
-#define Au1500_PCI_ERR_ADDR	(Au1500_CFG_BASE + 0x1C)
-#define Au1500_PCI_SPEC_INTACK	(Au1500_CFG_BASE + 0x20)
-#define Au1500_PCI_ID		(Au1500_CFG_BASE + 0x100)
-#define Au1500_PCI_STATCMD	(Au1500_CFG_BASE + 0x104)
-#define Au1500_PCI_CLASSREV	(Au1500_CFG_BASE + 0x108)
-#define Au1500_PCI_HDRTYPE	(Au1500_CFG_BASE + 0x10C)
-#define Au1500_PCI_MBAR 	(Au1500_CFG_BASE + 0x110)
-
-#define Au1500_PCI_HDR		0xB4005100	/* virtual, KSEG1 addr */
 
-/*
- * All of our structures, like PCI resource, have 32-bit members.
- * Drivers are expected to do an ioremap on the PCI MEM resource, but it's
- * hard to store 0x4 0000 0000 in a 32-bit type.  We require a small patch
- * to __ioremap to check for addresses between (u32)Au1500_PCI_MEM_START and
- * (u32)Au1500_PCI_MEM_END and change those to the full 36-bit PCI MEM
- * addresses.  For PCI I/O, it's simpler because we get to do the ioremap
- * ourselves and then adjust the device's resources.
+/* The PCI chip selects are outside the 32bit space, and since we can't
+ * just program the 36bit addresses into BARs, we have to take a chunk
+ * out of the 32bit space and reserve it for PCI.  When these addresses
+ * are ioremap()ed, they'll be fixed up to the real 36bit address before
+ * being passed to the real ioremap function.
  */
-#define Au1500_EXT_CFG		0x600000000ULL
-#define Au1500_EXT_CFG_TYPE1	0x680000000ULL
-#define Au1500_PCI_IO_START	0x500000000ULL
-#define Au1500_PCI_IO_END	0x5000FFFFFULL
-#define Au1500_PCI_MEM_START	0x440000000ULL
-#define Au1500_PCI_MEM_END	0x44FFFFFFFULL
+#define ALCHEMY_PCI_MEMWIN_START	(AU1500_PCI_MEM_PHYS_ADDR >> 4)
+#define ALCHEMY_PCI_MEMWIN_END		(ALCHEMY_PCI_MEMWIN_START + 0x0FFFFFFF)
 
-#define PCI_IO_START	0x00001000
-#define PCI_IO_END	0x000FFFFF
-#define PCI_MEM_START	0x40000000
-#define PCI_MEM_END	0x4FFFFFFF
+/* for PCI IO it's simpler because we get to do the ioremap ourselves and then
+ * adjust the device's resources.
+ */
+#define ALCHEMY_PCI_IOWIN_START		0x00001000
+#define ALCHEMY_PCI_IOWIN_END		0x0000FFFF
 
-#define PCI_FIRST_DEVFN (0 << 3)
-#define PCI_LAST_DEVFN	(19 << 3)
+#ifdef CONFIG_PCI
 
 #define IOPORT_RESOURCE_START	0x00001000	/* skip legacy probing */
 #define IOPORT_RESOURCE_END	0xffffffff
 #define IOMEM_RESOURCE_START	0x10000000
 #define IOMEM_RESOURCE_END	0xfffffffffULL
 
-#else /* Au1000 and Au1100 and Au1200 */
+#else
 
 /* Don't allow any legacy ports probing */
 #define IOPORT_RESOURCE_START	0x10000000
@@ -1368,13 +1348,77 @@ enum soc_au1200_ints {
 #define IOMEM_RESOURCE_START	0x10000000
 #define IOMEM_RESOURCE_END	0xfffffffffULL
 
-#define PCI_IO_START	0
-#define PCI_IO_END	0
-#define PCI_MEM_START	0
-#define PCI_MEM_END	0
-#define PCI_FIRST_DEVFN 0
-#define PCI_LAST_DEVFN	0
-
 #endif
 
+/* PCI controller block register offsets */
+#define PCI_REG_CMEM		0x0000
+#define PCI_REG_CONFIG		0x0004
+#define PCI_REG_B2BMASK_CCH	0x0008
+#define PCI_REG_B2BBASE0_VID	0x000C
+#define PCI_REG_B2BBASE1_SID	0x0010
+#define PCI_REG_MWMASK_DEV	0x0014
+#define PCI_REG_MWBASE_REV_CCL	0x0018
+#define PCI_REG_ERR_ADDR	0x001C
+#define PCI_REG_SPEC_INTACK	0x0020
+#define PCI_REG_ID		0x0100
+#define PCI_REG_STATCMD		0x0104
+#define PCI_REG_CLASSREV	0x0108
+#define PCI_REG_PARAM		0x010C
+#define PCI_REG_MBAR		0x0110
+#define PCI_REG_TIMEOUT		0x0140
+
+/* PCI controller block register bits */
+#define PCI_CMEM_E		(1 << 28)	/* enable cacheable memory */
+#define PCI_CMEM_CMBASE(x)	(((x) & 0x3fff) << 14)
+#define PCI_CMEM_CMMASK(x)	((x) & 0x3fff)
+#define PCI_CONFIG_ERD		(1 << 27) /* pci error during R/W */
+#define PCI_CONFIG_ET		(1 << 26) /* error in target mode */
+#define PCI_CONFIG_EF		(1 << 25) /* fatal error */
+#define PCI_CONFIG_EP		(1 << 24) /* parity error */
+#define PCI_CONFIG_EM		(1 << 23) /* multiple errors */
+#define PCI_CONFIG_BM		(1 << 22) /* bad master error */
+#define PCI_CONFIG_PD		(1 << 20) /* PCI Disable */
+#define PCI_CONFIG_BME		(1 << 19) /* Byte Mask Enable for reads */
+#define PCI_CONFIG_NC		(1 << 16) /* mark mem access non-coherent */
+#define PCI_CONFIG_IA		(1 << 15) /* INTA# enabled (target mode) */
+#define PCI_CONFIG_IP		(1 << 13) /* int on PCI_PERR# */
+#define PCI_CONFIG_IS		(1 << 12) /* int on PCI_SERR# */
+#define PCI_CONFIG_IMM		(1 << 11) /* int on master abort */
+#define PCI_CONFIG_ITM		(1 << 10) /* int on target abort (as master) */
+#define PCI_CONFIG_ITT		(1 << 9)  /* int on target abort (as target) */
+#define PCI_CONFIG_IPB		(1 << 8)  /* int on PERR# in bus master acc */
+#define PCI_CONFIG_SIC_NO	(0 << 6)  /* no byte mask changes */
+#define PCI_CONFIG_SIC_BA_ADR	(1 << 6)  /* on byte/hw acc, invert adr bits */
+#define PCI_CONFIG_SIC_HWA_DAT	(2 << 6)  /* on halfword acc, swap data */
+#define PCI_CONFIG_SIC_ALL	(3 << 6)  /* swap data bytes on all accesses */
+#define PCI_CONFIG_ST		(1 << 5)  /* swap data by target transactions */
+#define PCI_CONFIG_SM		(1 << 4)  /* swap data from PCI ctl */
+#define PCI_CONFIG_AEN		(1 << 3)  /* enable internal arbiter */
+#define PCI_CONFIG_R2H		(1 << 2)  /* REQ2# to hi-prio arbiter */
+#define PCI_CONFIG_R1H		(1 << 1)  /* REQ1# to hi-prio arbiter */
+#define PCI_CONFIG_CH		(1 << 0)  /* PCI ctl to hi-prio arbiter */
+#define PCI_B2BMASK_B2BMASK(x)	(((x) & 0xffff) << 16)
+#define PCI_B2BMASK_CCH(x)	((x) & 0xffff) /* 16 upper bits of class code */
+#define PCI_B2BBASE0_VID_B0(x)	(((x) & 0xffff) << 16)
+#define PCI_B2BBASE0_VID_SV(x)	((x) & 0xffff)
+#define PCI_B2BBASE1_SID_B1(x)	(((x) & 0xffff) << 16)
+#define PCI_B2BBASE1_SID_SI(x)	((x) & 0xffff)
+#define PCI_MWMASKDEV_MWMASK(x) (((x) & 0xffff) << 16)
+#define PCI_MWMASKDEV_DEVID(x)	((x) & 0xffff)
+#define PCI_MWBASEREVCCL_BASE(x) (((x) & 0xffff) << 16)
+#define PCI_MWBASEREVCCL_REV(x)  (((x) & 0xff) << 8)
+#define PCI_MWBASEREVCCL_CCL(x)  ((x) & 0xff)
+#define PCI_ID_DID(x)		(((x) & 0xffff) << 16)
+#define PCI_ID_VID(x)		((x) & 0xffff)
+#define PCI_STATCMD_STATUS(x)	(((x) & 0xffff) << 16)
+#define PCI_STATCMD_CMD(x)	((x) & 0xffff)
+#define PCI_CLASSREV_CLASS(x)	(((x) & 0x00ffffff) << 8)
+#define PCI_CLASSREV_REV(x)	((x) & 0xff)
+#define PCI_PARAM_BIST(x)	(((x) & 0xff) << 24)
+#define PCI_PARAM_HT(x)		(((x) & 0xff) << 16)
+#define PCI_PARAM_LT(x)		(((x) & 0xff) << 8)
+#define PCI_PARAM_CLS(x)	((x) & 0xff)
+#define PCI_TIMEOUT_RETRIES(x)	(((x) & 0xff) << 8)	/* max retries */
+#define PCI_TIMEOUT_TO(x)	((x) & 0xff)	/* target ready timeout */
+
 #endif

commit 7cc2e272da3d88c0de9e05b32729402785bd9206
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Fri Aug 12 11:39:40 2011 +0200

    MIPS: Alchemy: more base address cleanup
    
    remove all redundant peripheral base address defines, fix
    all affected boards and drivers.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@googlemail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/2700/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 7f610b370382..1bbcb30c4ab9 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -698,114 +698,61 @@ enum soc_au1200_ints {
 #define AU1000_AC97_PHYS_ADDR		0x10000000 /* 012 */
 #define AU1000_USB_OHCI_PHYS_ADDR	0x10100000 /* 012 */
 #define AU1000_USB_UDC_PHYS_ADDR	0x10200000 /* 0123 */
+#define AU1000_IRDA_PHYS_ADDR		0x10300000 /* 02 */
+#define AU1200_AES_PHYS_ADDR		0x10300000 /* 4 */
 #define AU1000_IC0_PHYS_ADDR		0x10400000 /* 01234 */
 #define AU1000_MAC0_PHYS_ADDR		0x10500000 /* 023 */
 #define AU1000_MAC1_PHYS_ADDR		0x10510000 /* 023 */
 #define AU1000_MACEN_PHYS_ADDR		0x10520000 /* 023 */
 #define AU1100_SD0_PHYS_ADDR		0x10600000 /* 24 */
 #define AU1100_SD1_PHYS_ADDR		0x10680000 /* 24 */
+#define AU1550_PSC2_PHYS_ADDR		0x10A00000 /* 3 */
+#define AU1550_PSC3_PHYS_ADDR		0x10B00000 /* 3 */
 #define AU1000_I2S_PHYS_ADDR		0x11000000 /* 02 */
 #define AU1500_MAC0_PHYS_ADDR		0x11500000 /* 1 */
 #define AU1500_MAC1_PHYS_ADDR		0x11510000 /* 1 */
 #define AU1500_MACEN_PHYS_ADDR		0x11520000 /* 1 */
 #define AU1000_UART0_PHYS_ADDR		0x11100000 /* 01234 */
+#define AU1200_SWCNT_PHYS_ADDR		0x1110010C /* 4 */
 #define AU1000_UART1_PHYS_ADDR		0x11200000 /* 0234 */
 #define AU1000_UART2_PHYS_ADDR		0x11300000 /* 0 */
 #define AU1000_UART3_PHYS_ADDR		0x11400000 /* 0123 */
+#define AU1000_SSI0_PHYS_ADDR		0x11600000 /* 02 */
+#define AU1000_SSI1_PHYS_ADDR		0x11680000 /* 02 */
 #define AU1500_GPIO2_PHYS_ADDR		0x11700000 /* 1234 */
 #define AU1000_IC1_PHYS_ADDR		0x11800000 /* 01234 */
 #define AU1000_SYS_PHYS_ADDR		0x11900000 /* 01234 */
+#define AU1550_PSC0_PHYS_ADDR		0x11A00000 /* 34 */
+#define AU1550_PSC1_PHYS_ADDR		0x11B00000 /* 34 */
+#define AU1000_MEM_PHYS_ADDR		0x14000000 /* 01234 */
+#define AU1000_STATIC_MEM_PHYS_ADDR	0x14001000 /* 01234 */
 #define AU1000_DMA_PHYS_ADDR		0x14002000 /* 012 */
 #define AU1550_DBDMA_PHYS_ADDR		0x14002000 /* 34 */
 #define AU1550_DBDMA_CONF_PHYS_ADDR	0x14003000 /* 34 */
 #define AU1000_MACDMA0_PHYS_ADDR	0x14004000 /* 0123 */
 #define AU1000_MACDMA1_PHYS_ADDR	0x14004200 /* 0123 */
+#define AU1200_CIM_PHYS_ADDR		0x14004000 /* 4 */
+#define AU1500_PCI_PHYS_ADDR		0x14005000 /* 13 */
+#define AU1550_PE_PHYS_ADDR		0x14008000 /* 3 */
+#define AU1200_MAEBE_PHYS_ADDR		0x14010000 /* 4 */
+#define AU1200_MAEFE_PHYS_ADDR		0x14012000 /* 4 */
 #define AU1550_USB_OHCI_PHYS_ADDR	0x14020000 /* 3 */
 #define AU1200_USB_CTL_PHYS_ADDR	0x14020000 /* 4 */
 #define AU1200_USB_OTG_PHYS_ADDR	0x14020020 /* 4 */
 #define AU1200_USB_OHCI_PHYS_ADDR	0x14020100 /* 4 */
 #define AU1200_USB_EHCI_PHYS_ADDR	0x14020200 /* 4 */
 #define AU1200_USB_UDC_PHYS_ADDR	0x14022000 /* 4 */
+#define AU1100_LCD_PHYS_ADDR		0x15000000 /* 2 */
+#define AU1200_LCD_PHYS_ADDR		0x15000000 /* 4 */
+#define AU1500_PCI_MEM_PHYS_ADDR	0x400000000ULL /* 13 */
+#define AU1500_PCI_IO_PHYS_ADDR		0x500000000ULL /* 13 */
+#define AU1500_PCI_CONFIG0_PHYS_ADDR	0x600000000ULL /* 13 */
+#define AU1500_PCI_CONFIG1_PHYS_ADDR	0x680000000ULL /* 13 */
+#define AU1000_PCMCIA_IO_PHYS_ADDR	0xF00000000ULL /* 01234 */
+#define AU1000_PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL /* 01234 */
+#define AU1000_PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL /* 01234 */
 
 
-#ifdef CONFIG_SOC_AU1000
-#define	MEM_PHYS_ADDR		0x14000000
-#define	STATIC_MEM_PHYS_ADDR	0x14001000
-#define	IRDA_PHYS_ADDR		0x10300000
-#define	SSI0_PHYS_ADDR		0x11600000
-#define	SSI1_PHYS_ADDR		0x11680000
-#define PCMCIA_IO_PHYS_ADDR	0xF00000000ULL
-#define PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL
-#define PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL
-#endif
-
-/********************************************************************/
-
-#ifdef CONFIG_SOC_AU1500
-#define	MEM_PHYS_ADDR		0x14000000
-#define	STATIC_MEM_PHYS_ADDR	0x14001000
-#define PCI_PHYS_ADDR		0x14005000
-#define PCI_MEM_PHYS_ADDR	0x400000000ULL
-#define PCI_IO_PHYS_ADDR	0x500000000ULL
-#define PCI_CONFIG0_PHYS_ADDR	0x600000000ULL
-#define PCI_CONFIG1_PHYS_ADDR	0x680000000ULL
-#define PCMCIA_IO_PHYS_ADDR	0xF00000000ULL
-#define PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL
-#define PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL
-#endif
-
-/********************************************************************/
-
-#ifdef CONFIG_SOC_AU1100
-#define	MEM_PHYS_ADDR		0x14000000
-#define	STATIC_MEM_PHYS_ADDR	0x14001000
-#define	IRDA_PHYS_ADDR		0x10300000
-#define	SSI0_PHYS_ADDR		0x11600000
-#define	SSI1_PHYS_ADDR		0x11680000
-#define LCD_PHYS_ADDR		0x15000000
-#define PCMCIA_IO_PHYS_ADDR	0xF00000000ULL
-#define PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL
-#define PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL
-#endif
-
-/***********************************************************************/
-
-#ifdef CONFIG_SOC_AU1550
-#define	MEM_PHYS_ADDR		0x14000000
-#define	STATIC_MEM_PHYS_ADDR	0x14001000
-#define PCI_PHYS_ADDR		0x14005000
-#define PE_PHYS_ADDR		0x14008000
-#define PSC0_PHYS_ADDR		0x11A00000
-#define PSC1_PHYS_ADDR		0x11B00000
-#define PSC2_PHYS_ADDR		0x10A00000
-#define PSC3_PHYS_ADDR		0x10B00000
-#define PCI_MEM_PHYS_ADDR	0x400000000ULL
-#define PCI_IO_PHYS_ADDR	0x500000000ULL
-#define PCI_CONFIG0_PHYS_ADDR	0x600000000ULL
-#define PCI_CONFIG1_PHYS_ADDR	0x680000000ULL
-#define PCMCIA_IO_PHYS_ADDR	0xF00000000ULL
-#define PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL
-#define PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL
-#endif
-
-/***********************************************************************/
-
-#ifdef CONFIG_SOC_AU1200
-#define	MEM_PHYS_ADDR		0x14000000
-#define	STATIC_MEM_PHYS_ADDR	0x14001000
-#define AES_PHYS_ADDR		0x10300000
-#define CIM_PHYS_ADDR		0x14004000
-#define PSC0_PHYS_ADDR	 	0x11A00000
-#define PSC1_PHYS_ADDR	 	0x11B00000
-#define LCD_PHYS_ADDR		0x15000000
-#define SWCNT_PHYS_ADDR		0x1110010C
-#define MAEFE_PHYS_ADDR		0x14012000
-#define MAEBE_PHYS_ADDR		0x14010000
-#define PCMCIA_IO_PHYS_ADDR	0xF00000000ULL
-#define PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL
-#define PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL
-#endif
-
 /* Static Bus Controller */
 #define MEM_STCFG0		0xB4001000
 #define MEM_STTIME0		0xB4001004

commit b9581b84884eac4146720817a6eb0672074284fb
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Fri Aug 12 11:39:39 2011 +0200

    MIPS: Alchemy: rewrite USB platform setup.
    
    Use runtime CPU detection to setup all USB parts.
    Remove the Au1200 OTG and UDC platform devices since there are no
    drivers for them anyway.
    Clean up the USB address mess in the au1000 header.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@googlemail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/2703/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 3b0a1e774dc9..7f610b370382 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -833,56 +833,6 @@ enum soc_au1200_ints {
 #endif
 
 
-
-
-/* Au1000 */
-#ifdef CONFIG_SOC_AU1000
-
-#define USB_OHCI_BASE		0x10100000	/* phys addr for ioremap */
-#define USB_HOST_CONFIG 	0xB017FFFC
-#define FOR_PLATFORM_C_USB_HOST_INT AU1000_USB_HOST_INT
-#endif /* CONFIG_SOC_AU1000 */
-
-/* Au1500 */
-#ifdef CONFIG_SOC_AU1500
-
-#define USB_OHCI_BASE		0x10100000	/* phys addr for ioremap */
-#define USB_HOST_CONFIG 	0xB017fffc
-#define FOR_PLATFORM_C_USB_HOST_INT AU1500_USB_HOST_INT
-#endif /* CONFIG_SOC_AU1500 */
-
-/* Au1100 */
-#ifdef CONFIG_SOC_AU1100
-
-#define USB_OHCI_BASE		0x10100000	/* phys addr for ioremap */
-#define USB_HOST_CONFIG 	0xB017FFFC
-#define FOR_PLATFORM_C_USB_HOST_INT AU1100_USB_HOST_INT
-#endif /* CONFIG_SOC_AU1100 */
-
-#ifdef CONFIG_SOC_AU1550
-
-#define USB_OHCI_BASE		0x14020000	/* phys addr for ioremap */
-#define USB_OHCI_LEN		0x00060000
-#define USB_HOST_CONFIG 	0xB4027ffc
-#define FOR_PLATFORM_C_USB_HOST_INT AU1550_USB_HOST_INT
-#endif /* CONFIG_SOC_AU1550 */
-
-
-#ifdef CONFIG_SOC_AU1200
-
-#define USB_UOC_BASE		0x14020020
-#define USB_UOC_LEN		0x20
-#define USB_OHCI_BASE		0x14020100
-#define USB_OHCI_LEN		0x100
-#define USB_EHCI_BASE		0x14020200
-#define USB_EHCI_LEN		0x100
-#define USB_UDC_BASE		0x14022000
-#define USB_UDC_LEN		0x2000
-
-#define FOR_PLATFORM_C_USB_HOST_INT AU1200_USB_INT
-
-#endif /* CONFIG_SOC_AU1200 */
-
 /* Programmable Counters 0 and 1 */
 #define SYS_BASE		0xB1900000
 #define SYS_COUNTER_CNTRL	(SYS_BASE + 0x14)
@@ -953,11 +903,6 @@ enum soc_au1200_ints {
 #  define I2S_CONTROL_D 	(1 << 1)
 #  define I2S_CONTROL_CE	(1 << 0)
 
-/* USB Host Controller */
-#ifndef USB_OHCI_LEN
-#define USB_OHCI_LEN		0x00100000
-#endif
-
 
 /* Ethernet Controllers  */
 

commit ce6bc92285cabd0df1f154a9ef5aeb937b6de57e
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Fri Aug 12 20:12:33 2011 +0200

    MIPS: Alchemy: abstract USB block control register access
    
    Alchemy chips have one or more registers which control access
    to the usb blocks as well as PHY configuration.  I don't want
    the OHCI/EHCI glues to know about the different registers and bits;
    new code hides the gory details of USB configuration from them.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@googlemail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Cc: linux-usb@vger.kernel.org
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Patchwork: https://patchwork.linux-mips.org/patch/2709/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    
     create mode 100644 drivers/usb/host/alchemy-common.c

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index f260ebed713b..3b0a1e774dc9 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -245,6 +245,15 @@ void alchemy_sleep_au1000(void);
 void alchemy_sleep_au1550(void);
 void au_sleep(void);
 
+/* USB: drivers/usb/host/alchemy-common.c */
+enum alchemy_usb_block {
+	ALCHEMY_USB_OHCI0,
+	ALCHEMY_USB_UDC0,
+	ALCHEMY_USB_EHCI0,
+	ALCHEMY_USB_OTG0,
+};
+int alchemy_usb_control(int block, int enable);
+
 
 /* SOC Interrupt numbers */
 
@@ -687,7 +696,8 @@ enum soc_au1200_ints {
  */
 
 #define AU1000_AC97_PHYS_ADDR		0x10000000 /* 012 */
-#define AU1000_USBD_PHYS_ADDR		0x10200000 /* 0123 */
+#define AU1000_USB_OHCI_PHYS_ADDR	0x10100000 /* 012 */
+#define AU1000_USB_UDC_PHYS_ADDR	0x10200000 /* 0123 */
 #define AU1000_IC0_PHYS_ADDR		0x10400000 /* 01234 */
 #define AU1000_MAC0_PHYS_ADDR		0x10500000 /* 023 */
 #define AU1000_MAC1_PHYS_ADDR		0x10510000 /* 023 */
@@ -710,12 +720,17 @@ enum soc_au1200_ints {
 #define AU1550_DBDMA_CONF_PHYS_ADDR	0x14003000 /* 34 */
 #define AU1000_MACDMA0_PHYS_ADDR	0x14004000 /* 0123 */
 #define AU1000_MACDMA1_PHYS_ADDR	0x14004200 /* 0123 */
+#define AU1550_USB_OHCI_PHYS_ADDR	0x14020000 /* 3 */
+#define AU1200_USB_CTL_PHYS_ADDR	0x14020000 /* 4 */
+#define AU1200_USB_OTG_PHYS_ADDR	0x14020020 /* 4 */
+#define AU1200_USB_OHCI_PHYS_ADDR	0x14020100 /* 4 */
+#define AU1200_USB_EHCI_PHYS_ADDR	0x14020200 /* 4 */
+#define AU1200_USB_UDC_PHYS_ADDR	0x14022000 /* 4 */
 
 
 #ifdef CONFIG_SOC_AU1000
 #define	MEM_PHYS_ADDR		0x14000000
 #define	STATIC_MEM_PHYS_ADDR	0x14001000
-#define	USBH_PHYS_ADDR		0x10100000
 #define	IRDA_PHYS_ADDR		0x10300000
 #define	SSI0_PHYS_ADDR		0x11600000
 #define	SSI1_PHYS_ADDR		0x11680000
@@ -729,7 +744,6 @@ enum soc_au1200_ints {
 #ifdef CONFIG_SOC_AU1500
 #define	MEM_PHYS_ADDR		0x14000000
 #define	STATIC_MEM_PHYS_ADDR	0x14001000
-#define	USBH_PHYS_ADDR		0x10100000
 #define PCI_PHYS_ADDR		0x14005000
 #define PCI_MEM_PHYS_ADDR	0x400000000ULL
 #define PCI_IO_PHYS_ADDR	0x500000000ULL
@@ -745,7 +759,6 @@ enum soc_au1200_ints {
 #ifdef CONFIG_SOC_AU1100
 #define	MEM_PHYS_ADDR		0x14000000
 #define	STATIC_MEM_PHYS_ADDR	0x14001000
-#define	USBH_PHYS_ADDR		0x10100000
 #define	IRDA_PHYS_ADDR		0x10300000
 #define	SSI0_PHYS_ADDR		0x11600000
 #define	SSI1_PHYS_ADDR		0x11680000
@@ -760,7 +773,6 @@ enum soc_au1200_ints {
 #ifdef CONFIG_SOC_AU1550
 #define	MEM_PHYS_ADDR		0x14000000
 #define	STATIC_MEM_PHYS_ADDR	0x14001000
-#define	USBH_PHYS_ADDR		0x14020000
 #define PCI_PHYS_ADDR		0x14005000
 #define PE_PHYS_ADDR		0x14008000
 #define PSC0_PHYS_ADDR		0x11A00000
@@ -783,8 +795,6 @@ enum soc_au1200_ints {
 #define	STATIC_MEM_PHYS_ADDR	0x14001000
 #define AES_PHYS_ADDR		0x10300000
 #define CIM_PHYS_ADDR		0x14004000
-#define USBM_PHYS_ADDR		0x14020000
-#define	USBH_PHYS_ADDR		0x14020100
 #define PSC0_PHYS_ADDR	 	0x11A00000
 #define PSC1_PHYS_ADDR	 	0x11B00000
 #define LCD_PHYS_ADDR		0x15000000
@@ -868,21 +878,6 @@ enum soc_au1200_ints {
 #define USB_EHCI_LEN		0x100
 #define USB_UDC_BASE		0x14022000
 #define USB_UDC_LEN		0x2000
-#define USB_MSR_BASE		0xB4020000
-#define USB_MSR_MCFG		4
-#define USBMSRMCFG_OMEMEN	0
-#define USBMSRMCFG_OBMEN	1
-#define USBMSRMCFG_EMEMEN	2
-#define USBMSRMCFG_EBMEN	3
-#define USBMSRMCFG_DMEMEN	4
-#define USBMSRMCFG_DBMEN	5
-#define USBMSRMCFG_GMEMEN	6
-#define USBMSRMCFG_OHCCLKEN	16
-#define USBMSRMCFG_EHCCLKEN	17
-#define USBMSRMCFG_UDCCLKEN	18
-#define USBMSRMCFG_PHYPLLEN	19
-#define USBMSRMCFG_RDCOMB	30
-#define USBMSRMCFG_PFEN 	31
 
 #define FOR_PLATFORM_C_USB_HOST_INT AU1200_USB_INT
 
@@ -963,51 +958,6 @@ enum soc_au1200_ints {
 #define USB_OHCI_LEN		0x00100000
 #endif
 
-#ifndef CONFIG_SOC_AU1200
-
-/* USB Device Controller */
-#define USBD_EP0RD		0xB0200000
-#define USBD_EP0WR		0xB0200004
-#define USBD_EP2WR		0xB0200008
-#define USBD_EP3WR		0xB020000C
-#define USBD_EP4RD		0xB0200010
-#define USBD_EP5RD		0xB0200014
-#define USBD_INTEN		0xB0200018
-#define USBD_INTSTAT		0xB020001C
-#  define USBDEV_INT_SOF	(1 << 12)
-#  define USBDEV_INT_HF_BIT	6
-#  define USBDEV_INT_HF_MASK	(0x3f << USBDEV_INT_HF_BIT)
-#  define USBDEV_INT_CMPLT_BIT	0
-#  define USBDEV_INT_CMPLT_MASK (0x3f << USBDEV_INT_CMPLT_BIT)
-#define USBD_CONFIG		0xB0200020
-#define USBD_EP0CS		0xB0200024
-#define USBD_EP2CS		0xB0200028
-#define USBD_EP3CS		0xB020002C
-#define USBD_EP4CS		0xB0200030
-#define USBD_EP5CS		0xB0200034
-#  define USBDEV_CS_SU		(1 << 14)
-#  define USBDEV_CS_NAK 	(1 << 13)
-#  define USBDEV_CS_ACK 	(1 << 12)
-#  define USBDEV_CS_BUSY	(1 << 11)
-#  define USBDEV_CS_TSIZE_BIT	1
-#  define USBDEV_CS_TSIZE_MASK	(0x3ff << USBDEV_CS_TSIZE_BIT)
-#  define USBDEV_CS_STALL	(1 << 0)
-#define USBD_EP0RDSTAT		0xB0200040
-#define USBD_EP0WRSTAT		0xB0200044
-#define USBD_EP2WRSTAT		0xB0200048
-#define USBD_EP3WRSTAT		0xB020004C
-#define USBD_EP4RDSTAT		0xB0200050
-#define USBD_EP5RDSTAT		0xB0200054
-#  define USBDEV_FSTAT_FLUSH	(1 << 6)
-#  define USBDEV_FSTAT_UF	(1 << 5)
-#  define USBDEV_FSTAT_OF	(1 << 4)
-#  define USBDEV_FSTAT_FCNT_BIT 0
-#  define USBDEV_FSTAT_FCNT_MASK (0x0f << USBDEV_FSTAT_FCNT_BIT)
-#define USBD_ENABLE		0xB0200058
-#  define USBDEV_ENABLE 	(1 << 1)
-#  define USBDEV_CE		(1 << 0)
-
-#endif /* !CONFIG_SOC_AU1200 */
 
 /* Ethernet Controllers  */
 

commit b7f720d68c0042cc8ce496e31a61df79a77f1b48
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Sun May 8 10:42:20 2011 +0200

    MIPS: Alchemy: Clean up GPIO registers and accessors
    
    remove au_readl/au_writel, remove the predefined GPIO1/2 KSEG1 register
    addresses and fix the fallout in all boards and drivers.
    
    This also fixes a bug in the mtx-1_wdt driver which was introduced by
    commit 6ea8115bb6f359df4f45152f2b40e1d4d1891392
    ("Convert mtx1 wdt to be a platform device and use generic GPIO API")
    before this patch mtx-1_wdt only modified GPIO215, the patch then
    used the gpio resource information as bit index into the GPIO2 register
    but the conversion to the GPIO API didn't realize that.
    With this patch the drivers original behaviour is restored and GPIO15
    is left alone.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@googlemail.com>
    Cc: Florian Fainelli <florian@openwrt.org>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Cc: linux-watchdog@vger.kernel.org
    Cc: Wim Van Sebroeck <wim@iguana.be>
    Patchwork: https://patchwork.linux-mips.org/patch/2381/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 2dfff4f26512..f260ebed713b 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -702,7 +702,9 @@ enum soc_au1200_ints {
 #define AU1000_UART1_PHYS_ADDR		0x11200000 /* 0234 */
 #define AU1000_UART2_PHYS_ADDR		0x11300000 /* 0 */
 #define AU1000_UART3_PHYS_ADDR		0x11400000 /* 0123 */
+#define AU1500_GPIO2_PHYS_ADDR		0x11700000 /* 1234 */
 #define AU1000_IC1_PHYS_ADDR		0x11800000 /* 01234 */
+#define AU1000_SYS_PHYS_ADDR		0x11900000 /* 01234 */
 #define AU1000_DMA_PHYS_ADDR		0x14002000 /* 012 */
 #define AU1550_DBDMA_PHYS_ADDR		0x14002000 /* 34 */
 #define AU1550_DBDMA_CONF_PHYS_ADDR	0x14003000 /* 34 */
@@ -717,7 +719,6 @@ enum soc_au1200_ints {
 #define	IRDA_PHYS_ADDR		0x10300000
 #define	SSI0_PHYS_ADDR		0x11600000
 #define	SSI1_PHYS_ADDR		0x11680000
-#define	SYS_PHYS_ADDR		0x11900000
 #define PCMCIA_IO_PHYS_ADDR	0xF00000000ULL
 #define PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL
 #define PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL
@@ -730,8 +731,6 @@ enum soc_au1200_ints {
 #define	STATIC_MEM_PHYS_ADDR	0x14001000
 #define	USBH_PHYS_ADDR		0x10100000
 #define PCI_PHYS_ADDR		0x14005000
-#define GPIO2_PHYS_ADDR		0x11700000
-#define	SYS_PHYS_ADDR		0x11900000
 #define PCI_MEM_PHYS_ADDR	0x400000000ULL
 #define PCI_IO_PHYS_ADDR	0x500000000ULL
 #define PCI_CONFIG0_PHYS_ADDR	0x600000000ULL
@@ -750,8 +749,6 @@ enum soc_au1200_ints {
 #define	IRDA_PHYS_ADDR		0x10300000
 #define	SSI0_PHYS_ADDR		0x11600000
 #define	SSI1_PHYS_ADDR		0x11680000
-#define GPIO2_PHYS_ADDR		0x11700000
-#define	SYS_PHYS_ADDR		0x11900000
 #define LCD_PHYS_ADDR		0x15000000
 #define PCMCIA_IO_PHYS_ADDR	0xF00000000ULL
 #define PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL
@@ -765,8 +762,6 @@ enum soc_au1200_ints {
 #define	STATIC_MEM_PHYS_ADDR	0x14001000
 #define	USBH_PHYS_ADDR		0x14020000
 #define PCI_PHYS_ADDR		0x14005000
-#define GPIO2_PHYS_ADDR		0x11700000
-#define	SYS_PHYS_ADDR		0x11900000
 #define PE_PHYS_ADDR		0x14008000
 #define PSC0_PHYS_ADDR		0x11A00000
 #define PSC1_PHYS_ADDR		0x11B00000
@@ -790,8 +785,6 @@ enum soc_au1200_ints {
 #define CIM_PHYS_ADDR		0x14004000
 #define USBM_PHYS_ADDR		0x14020000
 #define	USBH_PHYS_ADDR		0x14020100
-#define GPIO2_PHYS_ADDR		0x11700000
-#define	SYS_PHYS_ADDR		0x11900000
 #define PSC0_PHYS_ADDR	 	0x11A00000
 #define PSC1_PHYS_ADDR	 	0x11B00000
 #define LCD_PHYS_ADDR		0x15000000
@@ -1359,22 +1352,6 @@ enum soc_au1200_ints {
 #define SYS_PINFUNC_S1B 	(1 << 2)
 #endif
 
-#define SYS_TRIOUTRD		0xB1900100
-#define SYS_TRIOUTCLR		0xB1900100
-#define SYS_OUTPUTRD		0xB1900108
-#define SYS_OUTPUTSET		0xB1900108
-#define SYS_OUTPUTCLR		0xB190010C
-#define SYS_PINSTATERD		0xB1900110
-#define SYS_PININPUTEN		0xB1900110
-
-/* GPIO2, Au1500, Au1550 only */
-#define GPIO2_BASE		0xB1700000
-#define GPIO2_DIR		(GPIO2_BASE + 0)
-#define GPIO2_OUTPUT		(GPIO2_BASE + 8)
-#define GPIO2_PINSTATE		(GPIO2_BASE + 0xC)
-#define GPIO2_INTENABLE 	(GPIO2_BASE + 0x10)
-#define GPIO2_ENABLE		(GPIO2_BASE + 0x14)
-
 /* Power Management */
 #define SYS_SCRATCH0		0xB1900018
 #define SYS_SCRATCH1		0xB190001C

commit 5d4ddcb4279672e69136e746d6de6f01b501b853
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Sun May 8 10:42:19 2011 +0200

    MIPS: Alchemy: Cleanup DMA addresses
    
    According to the databooks, the Au1000 DMA engine must be programmed with
    the physical FIFO addresses.  This patch does that; furthermore this
    opened the possibility to get rid of a lot of now unnecessary address
    defines.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@googlemail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Cc: Florian Fainelli <florian@openwrt.org>
    Cc: Wolfgang Grandegger <wg@grandegger.com>
    Patchwork: https://patchwork.linux-mips.org/patch/2348/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 415d287c272b..2dfff4f26512 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -686,10 +686,15 @@ enum soc_au1200_ints {
  * 0..au1000 1..au1500 2..au1100 3..au1550 4..au1200
  */
 
+#define AU1000_AC97_PHYS_ADDR		0x10000000 /* 012 */
+#define AU1000_USBD_PHYS_ADDR		0x10200000 /* 0123 */
 #define AU1000_IC0_PHYS_ADDR		0x10400000 /* 01234 */
 #define AU1000_MAC0_PHYS_ADDR		0x10500000 /* 023 */
 #define AU1000_MAC1_PHYS_ADDR		0x10510000 /* 023 */
 #define AU1000_MACEN_PHYS_ADDR		0x10520000 /* 023 */
+#define AU1100_SD0_PHYS_ADDR		0x10600000 /* 24 */
+#define AU1100_SD1_PHYS_ADDR		0x10680000 /* 24 */
+#define AU1000_I2S_PHYS_ADDR		0x11000000 /* 02 */
 #define AU1500_MAC0_PHYS_ADDR		0x11500000 /* 1 */
 #define AU1500_MAC1_PHYS_ADDR		0x11510000 /* 1 */
 #define AU1500_MACEN_PHYS_ADDR		0x11520000 /* 1 */
@@ -698,6 +703,7 @@ enum soc_au1200_ints {
 #define AU1000_UART2_PHYS_ADDR		0x11300000 /* 0 */
 #define AU1000_UART3_PHYS_ADDR		0x11400000 /* 0123 */
 #define AU1000_IC1_PHYS_ADDR		0x11800000 /* 01234 */
+#define AU1000_DMA_PHYS_ADDR		0x14002000 /* 012 */
 #define AU1550_DBDMA_PHYS_ADDR		0x14002000 /* 34 */
 #define AU1550_DBDMA_CONF_PHYS_ADDR	0x14003000 /* 34 */
 #define AU1000_MACDMA0_PHYS_ADDR	0x14004000 /* 0123 */
@@ -707,19 +713,8 @@ enum soc_au1200_ints {
 #ifdef CONFIG_SOC_AU1000
 #define	MEM_PHYS_ADDR		0x14000000
 #define	STATIC_MEM_PHYS_ADDR	0x14001000
-#define	DMA0_PHYS_ADDR		0x14002000
-#define	DMA1_PHYS_ADDR		0x14002100
-#define	DMA2_PHYS_ADDR		0x14002200
-#define	DMA3_PHYS_ADDR		0x14002300
-#define	DMA4_PHYS_ADDR		0x14002400
-#define	DMA5_PHYS_ADDR		0x14002500
-#define	DMA6_PHYS_ADDR		0x14002600
-#define	DMA7_PHYS_ADDR		0x14002700
-#define	AC97_PHYS_ADDR		0x10000000
 #define	USBH_PHYS_ADDR		0x10100000
-#define	USBD_PHYS_ADDR		0x10200000
 #define	IRDA_PHYS_ADDR		0x10300000
-#define	I2S_PHYS_ADDR		0x11000000
 #define	SSI0_PHYS_ADDR		0x11600000
 #define	SSI1_PHYS_ADDR		0x11680000
 #define	SYS_PHYS_ADDR		0x11900000
@@ -733,19 +728,8 @@ enum soc_au1200_ints {
 #ifdef CONFIG_SOC_AU1500
 #define	MEM_PHYS_ADDR		0x14000000
 #define	STATIC_MEM_PHYS_ADDR	0x14001000
-#define	DMA0_PHYS_ADDR		0x14002000
-#define	DMA1_PHYS_ADDR		0x14002100
-#define	DMA2_PHYS_ADDR		0x14002200
-#define	DMA3_PHYS_ADDR		0x14002300
-#define	DMA4_PHYS_ADDR		0x14002400
-#define	DMA5_PHYS_ADDR		0x14002500
-#define	DMA6_PHYS_ADDR		0x14002600
-#define	DMA7_PHYS_ADDR		0x14002700
-#define	AC97_PHYS_ADDR		0x10000000
 #define	USBH_PHYS_ADDR		0x10100000
-#define	USBD_PHYS_ADDR		0x10200000
 #define PCI_PHYS_ADDR		0x14005000
-#define	I2S_PHYS_ADDR		0x11000000
 #define GPIO2_PHYS_ADDR		0x11700000
 #define	SYS_PHYS_ADDR		0x11900000
 #define PCI_MEM_PHYS_ADDR	0x400000000ULL
@@ -762,21 +746,8 @@ enum soc_au1200_ints {
 #ifdef CONFIG_SOC_AU1100
 #define	MEM_PHYS_ADDR		0x14000000
 #define	STATIC_MEM_PHYS_ADDR	0x14001000
-#define	DMA0_PHYS_ADDR		0x14002000
-#define	DMA1_PHYS_ADDR		0x14002100
-#define	DMA2_PHYS_ADDR		0x14002200
-#define	DMA3_PHYS_ADDR		0x14002300
-#define	DMA4_PHYS_ADDR		0x14002400
-#define	DMA5_PHYS_ADDR		0x14002500
-#define	DMA6_PHYS_ADDR		0x14002600
-#define	DMA7_PHYS_ADDR		0x14002700
-#define SD0_PHYS_ADDR		0x10600000
-#define SD1_PHYS_ADDR		0x10680000
-#define	AC97_PHYS_ADDR		0x10000000
 #define	USBH_PHYS_ADDR		0x10100000
-#define	USBD_PHYS_ADDR		0x10200000
 #define	IRDA_PHYS_ADDR		0x10300000
-#define	I2S_PHYS_ADDR		0x11000000
 #define	SSI0_PHYS_ADDR		0x11600000
 #define	SSI1_PHYS_ADDR		0x11680000
 #define GPIO2_PHYS_ADDR		0x11700000
@@ -793,7 +764,6 @@ enum soc_au1200_ints {
 #define	MEM_PHYS_ADDR		0x14000000
 #define	STATIC_MEM_PHYS_ADDR	0x14001000
 #define	USBH_PHYS_ADDR		0x14020000
-#define	USBD_PHYS_ADDR		0x10200000
 #define PCI_PHYS_ADDR		0x14005000
 #define GPIO2_PHYS_ADDR		0x11700000
 #define	SYS_PHYS_ADDR		0x11900000
@@ -824,8 +794,6 @@ enum soc_au1200_ints {
 #define	SYS_PHYS_ADDR		0x11900000
 #define PSC0_PHYS_ADDR	 	0x11A00000
 #define PSC1_PHYS_ADDR	 	0x11B00000
-#define SD0_PHYS_ADDR		0x10600000
-#define SD1_PHYS_ADDR		0x10680000
 #define LCD_PHYS_ADDR		0x15000000
 #define SWCNT_PHYS_ADDR		0x1110010C
 #define MAEFE_PHYS_ADDR		0x14012000
@@ -867,9 +835,6 @@ enum soc_au1200_ints {
 /* Au1000 */
 #ifdef CONFIG_SOC_AU1000
 
-#define UART0_ADDR		0xB1100000
-#define UART3_ADDR		0xB1400000
-
 #define USB_OHCI_BASE		0x10100000	/* phys addr for ioremap */
 #define USB_HOST_CONFIG 	0xB017FFFC
 #define FOR_PLATFORM_C_USB_HOST_INT AU1000_USB_HOST_INT
@@ -878,9 +843,6 @@ enum soc_au1200_ints {
 /* Au1500 */
 #ifdef CONFIG_SOC_AU1500
 
-#define UART0_ADDR		0xB1100000
-#define UART3_ADDR		0xB1400000
-
 #define USB_OHCI_BASE		0x10100000	/* phys addr for ioremap */
 #define USB_HOST_CONFIG 	0xB017fffc
 #define FOR_PLATFORM_C_USB_HOST_INT AU1500_USB_HOST_INT
@@ -889,16 +851,12 @@ enum soc_au1200_ints {
 /* Au1100 */
 #ifdef CONFIG_SOC_AU1100
 
-#define UART0_ADDR		0xB1100000
-#define UART3_ADDR		0xB1400000
-
 #define USB_OHCI_BASE		0x10100000	/* phys addr for ioremap */
 #define USB_HOST_CONFIG 	0xB017FFFC
 #define FOR_PLATFORM_C_USB_HOST_INT AU1100_USB_HOST_INT
 #endif /* CONFIG_SOC_AU1100 */
 
 #ifdef CONFIG_SOC_AU1550
-#define UART0_ADDR		0xB1100000
 
 #define USB_OHCI_BASE		0x14020000	/* phys addr for ioremap */
 #define USB_OHCI_LEN		0x00060000
@@ -909,8 +867,6 @@ enum soc_au1200_ints {
 
 #ifdef CONFIG_SOC_AU1200
 
-#define UART0_ADDR		0xB1100000
-
 #define USB_UOC_BASE		0x14020020
 #define USB_UOC_LEN		0x20
 #define USB_OHCI_BASE		0x14020100
@@ -1534,12 +1490,6 @@ enum soc_au1200_ints {
 #  define AC97C_RS		(1 << 1)
 #  define AC97C_CE		(1 << 0)
 
-/* Secure Digital (SD) Controller */
-#define SD0_XMIT_FIFO	0xB0600000
-#define SD0_RECV_FIFO	0xB0600004
-#define SD1_XMIT_FIFO	0xB0680000
-#define SD1_RECV_FIFO	0xB0680004
-
 #if defined(CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1550)
 /* Au1500 PCI Controller */
 #define Au1500_CFG_BASE 	0xB4005000	/* virtual, KSEG1 addr */

commit 40d8bc281711d188f35f035f28d94b111b735484
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Sun May 8 10:42:18 2011 +0200

    MIPS: Alchemy: Rewrite ethernet platform setup
    
    Rewrite ethernet setup to use runtime cpu detection, and also clean up
    the ethernet base address mess as far as possible.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@googlemail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Cc: Florian Fainelli <florian@openwrt.org>
    Cc: Wolfgang Grandegger <wg@grandegger.com>
    Patchwork: https://patchwork.linux-mips.org/patch/2353/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index c4ffb209edf2..415d287c272b 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -219,6 +219,20 @@ static inline void alchemy_uart_putchar(u32 uart_phys, u8 c)
 	wmb();
 }
 
+/* return number of ethernet MACs on a given cputype */
+static inline int alchemy_get_macs(int type)
+{
+	switch (type) {
+	case ALCHEMY_CPU_AU1000:
+	case ALCHEMY_CPU_AU1500:
+	case ALCHEMY_CPU_AU1550:
+		return 2;
+	case ALCHEMY_CPU_AU1100:
+		return 1;
+	}
+	return 0;
+}
+
 /* arch/mips/au1000/common/clocks.c */
 extern void set_au1x00_speed(unsigned int new_freq);
 extern unsigned int get_au1x00_speed(void);
@@ -673,6 +687,12 @@ enum soc_au1200_ints {
  */
 
 #define AU1000_IC0_PHYS_ADDR		0x10400000 /* 01234 */
+#define AU1000_MAC0_PHYS_ADDR		0x10500000 /* 023 */
+#define AU1000_MAC1_PHYS_ADDR		0x10510000 /* 023 */
+#define AU1000_MACEN_PHYS_ADDR		0x10520000 /* 023 */
+#define AU1500_MAC0_PHYS_ADDR		0x11500000 /* 1 */
+#define AU1500_MAC1_PHYS_ADDR		0x11510000 /* 1 */
+#define AU1500_MACEN_PHYS_ADDR		0x11520000 /* 1 */
 #define AU1000_UART0_PHYS_ADDR		0x11100000 /* 01234 */
 #define AU1000_UART1_PHYS_ADDR		0x11200000 /* 0234 */
 #define AU1000_UART2_PHYS_ADDR		0x11300000 /* 0 */
@@ -680,6 +700,8 @@ enum soc_au1200_ints {
 #define AU1000_IC1_PHYS_ADDR		0x11800000 /* 01234 */
 #define AU1550_DBDMA_PHYS_ADDR		0x14002000 /* 34 */
 #define AU1550_DBDMA_CONF_PHYS_ADDR	0x14003000 /* 34 */
+#define AU1000_MACDMA0_PHYS_ADDR	0x14004000 /* 0123 */
+#define AU1000_MACDMA1_PHYS_ADDR	0x14004200 /* 0123 */
 
 
 #ifdef CONFIG_SOC_AU1000
@@ -697,11 +719,6 @@ enum soc_au1200_ints {
 #define	USBH_PHYS_ADDR		0x10100000
 #define	USBD_PHYS_ADDR		0x10200000
 #define	IRDA_PHYS_ADDR		0x10300000
-#define	MAC0_PHYS_ADDR		0x10500000
-#define	MAC1_PHYS_ADDR		0x10510000
-#define	MACEN_PHYS_ADDR		0x10520000
-#define	MACDMA0_PHYS_ADDR	0x14004000
-#define	MACDMA1_PHYS_ADDR	0x14004200
 #define	I2S_PHYS_ADDR		0x11000000
 #define	SSI0_PHYS_ADDR		0x11600000
 #define	SSI1_PHYS_ADDR		0x11680000
@@ -728,11 +745,6 @@ enum soc_au1200_ints {
 #define	USBH_PHYS_ADDR		0x10100000
 #define	USBD_PHYS_ADDR		0x10200000
 #define PCI_PHYS_ADDR		0x14005000
-#define	MAC0_PHYS_ADDR		0x11500000
-#define	MAC1_PHYS_ADDR		0x11510000
-#define	MACEN_PHYS_ADDR		0x11520000
-#define	MACDMA0_PHYS_ADDR	0x14004000
-#define	MACDMA1_PHYS_ADDR	0x14004200
 #define	I2S_PHYS_ADDR		0x11000000
 #define GPIO2_PHYS_ADDR		0x11700000
 #define	SYS_PHYS_ADDR		0x11900000
@@ -764,10 +776,6 @@ enum soc_au1200_ints {
 #define	USBH_PHYS_ADDR		0x10100000
 #define	USBD_PHYS_ADDR		0x10200000
 #define	IRDA_PHYS_ADDR		0x10300000
-#define	MAC0_PHYS_ADDR		0x10500000
-#define	MACEN_PHYS_ADDR		0x10520000
-#define	MACDMA0_PHYS_ADDR	0x14004000
-#define	MACDMA1_PHYS_ADDR	0x14004200
 #define	I2S_PHYS_ADDR		0x11000000
 #define	SSI0_PHYS_ADDR		0x11600000
 #define	SSI1_PHYS_ADDR		0x11680000
@@ -787,11 +795,6 @@ enum soc_au1200_ints {
 #define	USBH_PHYS_ADDR		0x14020000
 #define	USBD_PHYS_ADDR		0x10200000
 #define PCI_PHYS_ADDR		0x14005000
-#define	MAC0_PHYS_ADDR		0x10500000
-#define	MAC1_PHYS_ADDR		0x10510000
-#define	MACEN_PHYS_ADDR		0x10520000
-#define	MACDMA0_PHYS_ADDR	0x14004000
-#define	MACDMA1_PHYS_ADDR	0x14004200
 #define GPIO2_PHYS_ADDR		0x11700000
 #define	SYS_PHYS_ADDR		0x11900000
 #define PE_PHYS_ADDR		0x14008000
@@ -870,12 +873,6 @@ enum soc_au1200_ints {
 #define USB_OHCI_BASE		0x10100000	/* phys addr for ioremap */
 #define USB_HOST_CONFIG 	0xB017FFFC
 #define FOR_PLATFORM_C_USB_HOST_INT AU1000_USB_HOST_INT
-
-#define AU1000_ETH0_BASE	0xB0500000
-#define AU1000_ETH1_BASE	0xB0510000
-#define AU1000_MAC0_ENABLE	0xB0520000
-#define AU1000_MAC1_ENABLE	0xB0520004
-#define NUM_ETH_INTERFACES 2
 #endif /* CONFIG_SOC_AU1000 */
 
 /* Au1500 */
@@ -887,12 +884,6 @@ enum soc_au1200_ints {
 #define USB_OHCI_BASE		0x10100000	/* phys addr for ioremap */
 #define USB_HOST_CONFIG 	0xB017fffc
 #define FOR_PLATFORM_C_USB_HOST_INT AU1500_USB_HOST_INT
-
-#define AU1500_ETH0_BASE	0xB1500000
-#define AU1500_ETH1_BASE	0xB1510000
-#define AU1500_MAC0_ENABLE	0xB1520000
-#define AU1500_MAC1_ENABLE	0xB1520004
-#define NUM_ETH_INTERFACES 2
 #endif /* CONFIG_SOC_AU1500 */
 
 /* Au1100 */
@@ -904,10 +895,6 @@ enum soc_au1200_ints {
 #define USB_OHCI_BASE		0x10100000	/* phys addr for ioremap */
 #define USB_HOST_CONFIG 	0xB017FFFC
 #define FOR_PLATFORM_C_USB_HOST_INT AU1100_USB_HOST_INT
-
-#define AU1100_ETH0_BASE	0xB0500000
-#define AU1100_MAC0_ENABLE	0xB0520000
-#define NUM_ETH_INTERFACES 1
 #endif /* CONFIG_SOC_AU1100 */
 
 #ifdef CONFIG_SOC_AU1550
@@ -917,12 +904,6 @@ enum soc_au1200_ints {
 #define USB_OHCI_LEN		0x00060000
 #define USB_HOST_CONFIG 	0xB4027ffc
 #define FOR_PLATFORM_C_USB_HOST_INT AU1550_USB_HOST_INT
-
-#define AU1550_ETH0_BASE	0xB0500000
-#define AU1550_ETH1_BASE	0xB0510000
-#define AU1550_MAC0_ENABLE	0xB0520000
-#define AU1550_MAC1_ENABLE	0xB0520004
-#define NUM_ETH_INTERFACES 2
 #endif /* CONFIG_SOC_AU1550 */
 
 

commit 80130204b43ce9c3b50924e4c2d44e9f2881f8c3
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Sun May 8 10:42:17 2011 +0200

    MIPS: Alchemy: Rewrite UART setup and constants.
    
    Detect CPU type at runtime and setup uarts accordingly; also clean up the
    uart base address mess in the process as far as possible.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@googlemail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Cc: Florian Fainelli <florian@openwrt.org>
    Cc: Wolfgang Grandegger <wg@grandegger.com>
    Patchwork: https://patchwork.linux-mips.org/patch/2352/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index eb8f1034e1ef..c4ffb209edf2 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -161,6 +161,45 @@ static inline int alchemy_get_cputype(void)
 	return ALCHEMY_CPU_UNKNOWN;
 }
 
+/* return number of uarts on a given cputype */
+static inline int alchemy_get_uarts(int type)
+{
+	switch (type) {
+	case ALCHEMY_CPU_AU1000:
+		return 4;
+	case ALCHEMY_CPU_AU1500:
+	case ALCHEMY_CPU_AU1200:
+		return 2;
+	case ALCHEMY_CPU_AU1100:
+	case ALCHEMY_CPU_AU1550:
+		return 3;
+	}
+	return 0;
+}
+
+/* enable an UART block if it isn't already */
+static inline void alchemy_uart_enable(u32 uart_phys)
+{
+	void __iomem *addr = (void __iomem *)KSEG1ADDR(uart_phys);
+
+	/* reset, enable clock, deassert reset */
+	if ((__raw_readl(addr + 0x100) & 3) != 3) {
+		__raw_writel(0, addr + 0x100);
+		wmb();
+		__raw_writel(1, addr + 0x100);
+		wmb();
+	}
+	__raw_writel(3, addr + 0x100);
+	wmb();
+}
+
+static inline void alchemy_uart_disable(u32 uart_phys)
+{
+	void __iomem *addr = (void __iomem *)KSEG1ADDR(uart_phys);
+	__raw_writel(0, addr + 0x100);	/* UART_MOD_CNTRL */
+	wmb();
+}
+
 static inline void alchemy_uart_putchar(u32 uart_phys, u8 c)
 {
 	void __iomem *base = (void __iomem *)KSEG1ADDR(uart_phys);
@@ -634,6 +673,10 @@ enum soc_au1200_ints {
  */
 
 #define AU1000_IC0_PHYS_ADDR		0x10400000 /* 01234 */
+#define AU1000_UART0_PHYS_ADDR		0x11100000 /* 01234 */
+#define AU1000_UART1_PHYS_ADDR		0x11200000 /* 0234 */
+#define AU1000_UART2_PHYS_ADDR		0x11300000 /* 0 */
+#define AU1000_UART3_PHYS_ADDR		0x11400000 /* 0123 */
 #define AU1000_IC1_PHYS_ADDR		0x11800000 /* 01234 */
 #define AU1550_DBDMA_PHYS_ADDR		0x14002000 /* 34 */
 #define AU1550_DBDMA_CONF_PHYS_ADDR	0x14003000 /* 34 */
@@ -660,10 +703,6 @@ enum soc_au1200_ints {
 #define	MACDMA0_PHYS_ADDR	0x14004000
 #define	MACDMA1_PHYS_ADDR	0x14004200
 #define	I2S_PHYS_ADDR		0x11000000
-#define	UART0_PHYS_ADDR		0x11100000
-#define	UART1_PHYS_ADDR		0x11200000
-#define	UART2_PHYS_ADDR		0x11300000
-#define	UART3_PHYS_ADDR		0x11400000
 #define	SSI0_PHYS_ADDR		0x11600000
 #define	SSI1_PHYS_ADDR		0x11680000
 #define	SYS_PHYS_ADDR		0x11900000
@@ -695,8 +734,6 @@ enum soc_au1200_ints {
 #define	MACDMA0_PHYS_ADDR	0x14004000
 #define	MACDMA1_PHYS_ADDR	0x14004200
 #define	I2S_PHYS_ADDR		0x11000000
-#define	UART0_PHYS_ADDR		0x11100000
-#define	UART3_PHYS_ADDR		0x11400000
 #define GPIO2_PHYS_ADDR		0x11700000
 #define	SYS_PHYS_ADDR		0x11900000
 #define PCI_MEM_PHYS_ADDR	0x400000000ULL
@@ -732,9 +769,6 @@ enum soc_au1200_ints {
 #define	MACDMA0_PHYS_ADDR	0x14004000
 #define	MACDMA1_PHYS_ADDR	0x14004200
 #define	I2S_PHYS_ADDR		0x11000000
-#define	UART0_PHYS_ADDR		0x11100000
-#define	UART1_PHYS_ADDR		0x11200000
-#define	UART3_PHYS_ADDR		0x11400000
 #define	SSI0_PHYS_ADDR		0x11600000
 #define	SSI1_PHYS_ADDR		0x11680000
 #define GPIO2_PHYS_ADDR		0x11700000
@@ -758,9 +792,6 @@ enum soc_au1200_ints {
 #define	MACEN_PHYS_ADDR		0x10520000
 #define	MACDMA0_PHYS_ADDR	0x14004000
 #define	MACDMA1_PHYS_ADDR	0x14004200
-#define	UART0_PHYS_ADDR		0x11100000
-#define	UART1_PHYS_ADDR		0x11200000
-#define	UART3_PHYS_ADDR		0x11400000
 #define GPIO2_PHYS_ADDR		0x11700000
 #define	SYS_PHYS_ADDR		0x11900000
 #define PE_PHYS_ADDR		0x14008000
@@ -786,8 +817,6 @@ enum soc_au1200_ints {
 #define CIM_PHYS_ADDR		0x14004000
 #define USBM_PHYS_ADDR		0x14020000
 #define	USBH_PHYS_ADDR		0x14020100
-#define	UART0_PHYS_ADDR		0x11100000
-#define	UART1_PHYS_ADDR		0x11200000
 #define GPIO2_PHYS_ADDR		0x11700000
 #define	SYS_PHYS_ADDR		0x11900000
 #define PSC0_PHYS_ADDR	 	0x11A00000

commit adcb86279f1e4d7a1a9f267b49441aecf4a5110a
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Sun May 8 10:42:16 2011 +0200

    MIPS: Alchemy: Convert dbdma.c to syscore_ops
    
    Convert the PM sysdev to syscore_ops and clean up the ddma addresses a bit.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@googlemail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Cc: Florian Fainelli <florian@openwrt.org>
    Cc: Wolfgang Grandegger <wg@grandegger.com>
    Patchwork: https://patchwork.linux-mips.org/patch/2351/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 66cfcdc75e4f..eb8f1034e1ef 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -635,6 +635,8 @@ enum soc_au1200_ints {
 
 #define AU1000_IC0_PHYS_ADDR		0x10400000 /* 01234 */
 #define AU1000_IC1_PHYS_ADDR		0x11800000 /* 01234 */
+#define AU1550_DBDMA_PHYS_ADDR		0x14002000 /* 34 */
+#define AU1550_DBDMA_CONF_PHYS_ADDR	0x14003000 /* 34 */
 
 
 #ifdef CONFIG_SOC_AU1000
@@ -761,7 +763,6 @@ enum soc_au1200_ints {
 #define	UART3_PHYS_ADDR		0x11400000
 #define GPIO2_PHYS_ADDR		0x11700000
 #define	SYS_PHYS_ADDR		0x11900000
-#define	DDMA_PHYS_ADDR		0x14002000
 #define PE_PHYS_ADDR		0x14008000
 #define PSC0_PHYS_ADDR		0x11A00000
 #define PSC1_PHYS_ADDR		0x11B00000
@@ -789,7 +790,6 @@ enum soc_au1200_ints {
 #define	UART1_PHYS_ADDR		0x11200000
 #define GPIO2_PHYS_ADDR		0x11700000
 #define	SYS_PHYS_ADDR		0x11900000
-#define	DDMA_PHYS_ADDR		0x14002000
 #define PSC0_PHYS_ADDR	 	0x11A00000
 #define PSC1_PHYS_ADDR	 	0x11B00000
 #define SD0_PHYS_ADDR		0x10600000

commit dca7587185b3a499a09a9e2755316eee31c49c7f
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Sun May 8 10:42:14 2011 +0200

    MIPS: Alchemy: irq code and constant cleanup
    
    replace au_readl/au_writel with __raw_readl/__raw_writel,
    and clean up IC-related stuff from the headers.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@googlemail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Cc: Florian Fainelli <florian@openwrt.org>
    Cc: Wolfgang Grandegger <wg@grandegger.com>
    Patchwork: https://patchwork.linux-mips.org/patch/2354/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index a6976619160a..66cfcdc75e4f 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -630,8 +630,13 @@ enum soc_au1200_ints {
 
 /*
  * Physical base addresses for integrated peripherals
+ * 0..au1000 1..au1500 2..au1100 3..au1550 4..au1200
  */
 
+#define AU1000_IC0_PHYS_ADDR		0x10400000 /* 01234 */
+#define AU1000_IC1_PHYS_ADDR		0x11800000 /* 01234 */
+
+
 #ifdef CONFIG_SOC_AU1000
 #define	MEM_PHYS_ADDR		0x14000000
 #define	STATIC_MEM_PHYS_ADDR	0x14001000
@@ -643,8 +648,6 @@ enum soc_au1200_ints {
 #define	DMA5_PHYS_ADDR		0x14002500
 #define	DMA6_PHYS_ADDR		0x14002600
 #define	DMA7_PHYS_ADDR		0x14002700
-#define	IC0_PHYS_ADDR		0x10400000
-#define	IC1_PHYS_ADDR		0x11800000
 #define	AC97_PHYS_ADDR		0x10000000
 #define	USBH_PHYS_ADDR		0x10100000
 #define	USBD_PHYS_ADDR		0x10200000
@@ -680,8 +683,6 @@ enum soc_au1200_ints {
 #define	DMA5_PHYS_ADDR		0x14002500
 #define	DMA6_PHYS_ADDR		0x14002600
 #define	DMA7_PHYS_ADDR		0x14002700
-#define	IC0_PHYS_ADDR		0x10400000
-#define	IC1_PHYS_ADDR		0x11800000
 #define	AC97_PHYS_ADDR		0x10000000
 #define	USBH_PHYS_ADDR		0x10100000
 #define	USBD_PHYS_ADDR		0x10200000
@@ -718,10 +719,8 @@ enum soc_au1200_ints {
 #define	DMA5_PHYS_ADDR		0x14002500
 #define	DMA6_PHYS_ADDR		0x14002600
 #define	DMA7_PHYS_ADDR		0x14002700
-#define	IC0_PHYS_ADDR		0x10400000
 #define SD0_PHYS_ADDR		0x10600000
 #define SD1_PHYS_ADDR		0x10680000
-#define	IC1_PHYS_ADDR		0x11800000
 #define	AC97_PHYS_ADDR		0x10000000
 #define	USBH_PHYS_ADDR		0x10100000
 #define	USBD_PHYS_ADDR		0x10200000
@@ -749,8 +748,6 @@ enum soc_au1200_ints {
 #ifdef CONFIG_SOC_AU1550
 #define	MEM_PHYS_ADDR		0x14000000
 #define	STATIC_MEM_PHYS_ADDR	0x14001000
-#define	IC0_PHYS_ADDR		0x10400000
-#define	IC1_PHYS_ADDR		0x11800000
 #define	USBH_PHYS_ADDR		0x14020000
 #define	USBD_PHYS_ADDR		0x10200000
 #define PCI_PHYS_ADDR		0x14005000
@@ -786,8 +783,6 @@ enum soc_au1200_ints {
 #define	STATIC_MEM_PHYS_ADDR	0x14001000
 #define AES_PHYS_ADDR		0x10300000
 #define CIM_PHYS_ADDR		0x14004000
-#define	IC0_PHYS_ADDR		0x10400000
-#define	IC1_PHYS_ADDR		0x11800000
 #define USBM_PHYS_ADDR		0x14020000
 #define	USBH_PHYS_ADDR		0x14020100
 #define	UART0_PHYS_ADDR		0x11100000
@@ -835,112 +830,6 @@ enum soc_au1200_ints {
 #endif
 
 
-/* Interrupt Controller register offsets */
-#define IC_CFG0RD		0x40
-#define IC_CFG0SET		0x40
-#define IC_CFG0CLR		0x44
-#define IC_CFG1RD		0x48
-#define IC_CFG1SET		0x48
-#define IC_CFG1CLR		0x4C
-#define IC_CFG2RD		0x50
-#define IC_CFG2SET		0x50
-#define IC_CFG2CLR		0x54
-#define IC_REQ0INT		0x54
-#define IC_SRCRD		0x58
-#define IC_SRCSET		0x58
-#define IC_SRCCLR		0x5C
-#define IC_REQ1INT		0x5C
-#define IC_ASSIGNRD		0x60
-#define IC_ASSIGNSET		0x60
-#define IC_ASSIGNCLR		0x64
-#define IC_WAKERD		0x68
-#define IC_WAKESET		0x68
-#define IC_WAKECLR		0x6C
-#define IC_MASKRD		0x70
-#define IC_MASKSET		0x70
-#define IC_MASKCLR		0x74
-#define IC_RISINGRD		0x78
-#define IC_RISINGCLR		0x78
-#define IC_FALLINGRD		0x7C
-#define IC_FALLINGCLR		0x7C
-#define IC_TESTBIT		0x80
-
-
-/* Interrupt Controller 0 */
-#define IC0_CFG0RD		0xB0400040
-#define IC0_CFG0SET		0xB0400040
-#define IC0_CFG0CLR		0xB0400044
-
-#define IC0_CFG1RD		0xB0400048
-#define IC0_CFG1SET		0xB0400048
-#define IC0_CFG1CLR		0xB040004C
-
-#define IC0_CFG2RD		0xB0400050
-#define IC0_CFG2SET		0xB0400050
-#define IC0_CFG2CLR		0xB0400054
-
-#define IC0_REQ0INT		0xB0400054
-#define IC0_SRCRD		0xB0400058
-#define IC0_SRCSET		0xB0400058
-#define IC0_SRCCLR		0xB040005C
-#define IC0_REQ1INT		0xB040005C
-
-#define IC0_ASSIGNRD		0xB0400060
-#define IC0_ASSIGNSET		0xB0400060
-#define IC0_ASSIGNCLR		0xB0400064
-
-#define IC0_WAKERD		0xB0400068
-#define IC0_WAKESET		0xB0400068
-#define IC0_WAKECLR		0xB040006C
-
-#define IC0_MASKRD		0xB0400070
-#define IC0_MASKSET		0xB0400070
-#define IC0_MASKCLR		0xB0400074
-
-#define IC0_RISINGRD		0xB0400078
-#define IC0_RISINGCLR		0xB0400078
-#define IC0_FALLINGRD		0xB040007C
-#define IC0_FALLINGCLR		0xB040007C
-
-#define IC0_TESTBIT		0xB0400080
-
-/* Interrupt Controller 1 */
-#define IC1_CFG0RD		0xB1800040
-#define IC1_CFG0SET		0xB1800040
-#define IC1_CFG0CLR		0xB1800044
-
-#define IC1_CFG1RD		0xB1800048
-#define IC1_CFG1SET		0xB1800048
-#define IC1_CFG1CLR		0xB180004C
-
-#define IC1_CFG2RD		0xB1800050
-#define IC1_CFG2SET		0xB1800050
-#define IC1_CFG2CLR		0xB1800054
-
-#define IC1_REQ0INT		0xB1800054
-#define IC1_SRCRD		0xB1800058
-#define IC1_SRCSET		0xB1800058
-#define IC1_SRCCLR		0xB180005C
-#define IC1_REQ1INT		0xB180005C
-
-#define IC1_ASSIGNRD            0xB1800060
-#define IC1_ASSIGNSET           0xB1800060
-#define IC1_ASSIGNCLR           0xB1800064
-
-#define IC1_WAKERD		0xB1800068
-#define IC1_WAKESET		0xB1800068
-#define IC1_WAKECLR		0xB180006C
-
-#define IC1_MASKRD		0xB1800070
-#define IC1_MASKSET		0xB1800070
-#define IC1_MASKCLR		0xB1800074
-
-#define IC1_RISINGRD		0xB1800078
-#define IC1_RISINGCLR		0xB1800078
-#define IC1_FALLINGRD		0xB180007C
-#define IC1_FALLINGCLR		0xB180007C
-
-#define IC1_TESTBIT		0xB1800080
 
 
 /* Au1000 */

commit 2e93d1ec080e4b21a34869129bda73f24ebb8950
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Mon May 24 19:42:52 2010 +0200

    MIPS: Alchemy: sleepcode without compile-time cputype dependencies
    
    Split the low-level sleepcode into per-cpu functions instead of
    relying on compile-time-defined cpu type.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: http://patchwork.linux-mips.org/patch/1281/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index e76941db2312..a6976619160a 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -188,7 +188,8 @@ extern unsigned long get_au1x00_uart_baud_base(void);
 extern unsigned long au1xxx_calc_clock(void);
 
 /* PM: arch/mips/alchemy/common/sleeper.S, power.c, irq.c */
-void au1xxx_save_and_sleep(void);
+void alchemy_sleep_au1000(void);
+void alchemy_sleep_au1550(void);
 void au_sleep(void);
 
 

commit 0f0d85bcc332ec8f0957378ea5fa3e553f80ae4b
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Tue Apr 13 20:49:14 2010 +0200

    MIPS: Alchemy: add sysdev for IRQ PM.
    
    Use a sysdev to implement PM methods for the Au1000 interrupt controllers.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: http://patchwork.linux-mips.org/patch/1114/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index ae07423e6e82..e76941db2312 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -190,8 +190,6 @@ extern unsigned long au1xxx_calc_clock(void);
 /* PM: arch/mips/alchemy/common/sleeper.S, power.c, irq.c */
 void au1xxx_save_and_sleep(void);
 void au_sleep(void);
-void save_au1xxx_intctl(void);
-void restore_au1xxx_intctl(void);
 
 
 /* SOC Interrupt numbers */
@@ -835,6 +833,38 @@ enum soc_au1200_ints {
 #define MEM_STNAND_DATA 	0x20
 #endif
 
+
+/* Interrupt Controller register offsets */
+#define IC_CFG0RD		0x40
+#define IC_CFG0SET		0x40
+#define IC_CFG0CLR		0x44
+#define IC_CFG1RD		0x48
+#define IC_CFG1SET		0x48
+#define IC_CFG1CLR		0x4C
+#define IC_CFG2RD		0x50
+#define IC_CFG2SET		0x50
+#define IC_CFG2CLR		0x54
+#define IC_REQ0INT		0x54
+#define IC_SRCRD		0x58
+#define IC_SRCSET		0x58
+#define IC_SRCCLR		0x5C
+#define IC_REQ1INT		0x5C
+#define IC_ASSIGNRD		0x60
+#define IC_ASSIGNSET		0x60
+#define IC_ASSIGNCLR		0x64
+#define IC_WAKERD		0x68
+#define IC_WAKESET		0x68
+#define IC_WAKECLR		0x6C
+#define IC_MASKRD		0x70
+#define IC_MASKSET		0x70
+#define IC_MASKCLR		0x74
+#define IC_RISINGRD		0x78
+#define IC_RISINGCLR		0x78
+#define IC_FALLINGRD		0x7C
+#define IC_FALLINGCLR		0x7C
+#define IC_TESTBIT		0x80
+
+
 /* Interrupt Controller 0 */
 #define IC0_CFG0RD		0xB0400040
 #define IC0_CFG0SET		0xB0400040

commit 11b897cf84c37e6522db914793677e933ef311fb
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Wed Feb 24 17:40:21 2010 +0100

    MIPS: Alchemy: use 36bit addresses for PCMCIA resources.
    
    On Alchemy the PCMCIA area lies at the end of the chips 36bit system bus
    area.  Currently, addresses at the far end of the 32bit area are assumed
    to belong to the PCMCIA area and fixed up to the real 36bit address before
    being passed to ioremap().
    
    A previous commit enabled 64 bit physical size for the resource datatype on
    Alchemy and this allows to use the correct 36bit addresses when registering
    the PCMCIA sockets.
    
    This patch removes the 32-to-36bit address fixup and registers the Alchemy
    demo board pcmcia socket with the correct 36bit physical addresses.
    
    Tested on DB1200, with a CF card (ide-cs driver) and a 3c589 PCMCIA ethernet
    card.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Cc: Manuel Lauss <manuel.lauss@gmail.com>
    Patchwork: http://patchwork.linux-mips.org/patch/994/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 2805fc56484d..ae07423e6e82 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -1678,18 +1678,4 @@ enum soc_au1200_ints {
 
 #endif
 
-/*
- * All Au1xx0 SOCs have a PCMCIA controller.
- * We setup our 32-bit pseudo addresses to be equal to the
- * 36-bit addr >> 4, to make it easier to check the address
- * and fix it.
- * The PCMCIA socket 0 physical attribute address is 0xF 4000 0000.
- * The pseudo address we use is 0xF400 0000. Any address over
- * 0xF400 0000 is a PCMCIA pseudo address.
- */
-#define PCMCIA_IO_PSEUDO_PHYS	(PCMCIA_IO_PHYS_ADDR >> 4)
-#define PCMCIA_ATTR_PSEUDO_PHYS	(PCMCIA_ATTR_PHYS_ADDR >> 4)
-#define PCMCIA_MEM_PSEUDO_PHYS	(PCMCIA_MEM_PHYS_ADDR >> 4)
-#define PCMCIA_PSEUDO_END	(0xffffffff)
-
 #endif

commit 60ec6571c5072cdea9e518d1dac8147b85ca93a2
Author: pascal@pabr.org <pascal@pabr.org>
Date:   Sun Jan 3 13:39:12 2010 +0100

    MIPS: Support 36-bit iomem on 32-bit Au1x00
    
    I believe these changes are needed on Alchemy SoCs in order to
    use iomem above 4G with the usual platform_device machinery:
    
    - Set CONFIG_ARCH_PHYS_ADDR_T_64BIT to make resource_size_t 64-bit.
    - Increase IOMEM_RESOURCE_END so that platforms can register resources.
    
    To: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/814/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 088c8e0f43bb..2805fc56484d 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -1659,7 +1659,7 @@ enum soc_au1200_ints {
 #define IOPORT_RESOURCE_START	0x00001000	/* skip legacy probing */
 #define IOPORT_RESOURCE_END	0xffffffff
 #define IOMEM_RESOURCE_START	0x10000000
-#define IOMEM_RESOURCE_END	0xffffffff
+#define IOMEM_RESOURCE_END	0xfffffffffULL
 
 #else /* Au1000 and Au1100 and Au1200 */
 
@@ -1667,7 +1667,7 @@ enum soc_au1200_ints {
 #define IOPORT_RESOURCE_START	0x10000000
 #define IOPORT_RESOURCE_END	0xffffffff
 #define IOMEM_RESOURCE_START	0x10000000
-#define IOMEM_RESOURCE_END	0xffffffff
+#define IOMEM_RESOURCE_END	0xfffffffffULL
 
 #define PCI_IO_START	0
 #define PCI_IO_END	0

commit 66a1d9baf4962defb3fc41439e3a22e752182f9f
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Thu Oct 15 19:32:01 2009 +0200

    MIPS: Alchemy: remove unused SYS area structure
    
    Nothing in-tree uses it, so get rid of it.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 2c524a87ecb6..088c8e0f43bb 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -1692,53 +1692,4 @@ enum soc_au1200_ints {
 #define PCMCIA_MEM_PSEUDO_PHYS	(PCMCIA_MEM_PHYS_ADDR >> 4)
 #define PCMCIA_PSEUDO_END	(0xffffffff)
 
-#ifndef _LANGUAGE_ASSEMBLY
-typedef volatile struct {
-	/* 0x0000 */ u32 toytrim;
-	/* 0x0004 */ u32 toywrite;
-	/* 0x0008 */ u32 toymatch0;
-	/* 0x000C */ u32 toymatch1;
-	/* 0x0010 */ u32 toymatch2;
-	/* 0x0014 */ u32 cntrctrl;
-	/* 0x0018 */ u32 scratch0;
-	/* 0x001C */ u32 scratch1;
-	/* 0x0020 */ u32 freqctrl0;
-	/* 0x0024 */ u32 freqctrl1;
-	/* 0x0028 */ u32 clksrc;
-	/* 0x002C */ u32 pinfunc;
-	/* 0x0030 */ u32 reserved0;
-	/* 0x0034 */ u32 wakemsk;
-	/* 0x0038 */ u32 endian;
-	/* 0x003C */ u32 powerctrl;
-	/* 0x0040 */ u32 toyread;
-	/* 0x0044 */ u32 rtctrim;
-	/* 0x0048 */ u32 rtcwrite;
-	/* 0x004C */ u32 rtcmatch0;
-	/* 0x0050 */ u32 rtcmatch1;
-	/* 0x0054 */ u32 rtcmatch2;
-	/* 0x0058 */ u32 rtcread;
-	/* 0x005C */ u32 wakesrc;
-	/* 0x0060 */ u32 cpupll;
-	/* 0x0064 */ u32 auxpll;
-	/* 0x0068 */ u32 reserved1;
-	/* 0x006C */ u32 reserved2;
-	/* 0x0070 */ u32 reserved3;
-	/* 0x0074 */ u32 reserved4;
-	/* 0x0078 */ u32 slppwr;
-	/* 0x007C */ u32 sleep;
-	/* 0x0080 */ u32 reserved5[32];
-	/* 0x0100 */ u32 trioutrd;
-#define trioutclr trioutrd
-	/* 0x0104 */ u32 reserved6;
-	/* 0x0108 */ u32 outputrd;
-#define outputset outputrd
-	/* 0x010C */ u32 outputclr;
-	/* 0x0110 */ u32 pinstaterd;
-#define pininputen pinstaterd
-} AU1X00_SYS;
-
-static AU1X00_SYS * const sys = (AU1X00_SYS *)SYS_BASE;
-
-#endif
-
 #endif

commit b6e6d120c8dd9c9cd888645b01299e2a55d873a4
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Thu Oct 15 19:07:34 2009 +0200

    MIPS: Alchemy: get rid of superfluous UART definitions
    
    Remove unused uart bit definitions and base macros.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index e11756d9aaa2..2c524a87ecb6 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -916,8 +916,6 @@ enum soc_au1200_ints {
 #ifdef CONFIG_SOC_AU1000
 
 #define UART0_ADDR		0xB1100000
-#define UART1_ADDR		0xB1200000
-#define UART2_ADDR		0xB1300000
 #define UART3_ADDR		0xB1400000
 
 #define USB_OHCI_BASE		0x10100000	/* phys addr for ioremap */
@@ -952,7 +950,6 @@ enum soc_au1200_ints {
 #ifdef CONFIG_SOC_AU1100
 
 #define UART0_ADDR		0xB1100000
-#define UART1_ADDR		0xB1200000
 #define UART3_ADDR		0xB1400000
 
 #define USB_OHCI_BASE		0x10100000	/* phys addr for ioremap */
@@ -966,8 +963,6 @@ enum soc_au1200_ints {
 
 #ifdef CONFIG_SOC_AU1550
 #define UART0_ADDR		0xB1100000
-#define UART1_ADDR		0xB1200000
-#define UART3_ADDR		0xB1400000
 
 #define USB_OHCI_BASE		0x14020000	/* phys addr for ioremap */
 #define USB_OHCI_LEN		0x00060000
@@ -985,7 +980,6 @@ enum soc_au1200_ints {
 #ifdef CONFIG_SOC_AU1200
 
 #define UART0_ADDR		0xB1100000
-#define UART1_ADDR		0xB1200000
 
 #define USB_UOC_BASE		0x14020020
 #define USB_UOC_LEN		0x20
@@ -1262,14 +1256,6 @@ enum soc_au1200_ints {
 #define MAC_RX_BUFF3_STATUS	0x30
 #define MAC_RX_BUFF3_ADDR	0x34
 
-/* UARTS 0-3 */
-#define UART_BASE		UART0_ADDR
-#ifdef	CONFIG_SOC_AU1200
-#define UART_DEBUG_BASE 	UART1_ADDR
-#else
-#define UART_DEBUG_BASE 	UART3_ADDR
-#endif
-
 #define UART_RX		0	/* Receive buffer */
 #define UART_TX		4	/* Transmit buffer */
 #define UART_IER	8	/* Interrupt Enable Register */
@@ -1282,84 +1268,6 @@ enum soc_au1200_ints {
 #define UART_CLK	0x28	/* Baud Rate Clock Divider */
 #define UART_MOD_CNTRL	0x100	/* Module Control */
 
-#define UART_FCR_ENABLE_FIFO	0x01 /* Enable the FIFO */
-#define UART_FCR_CLEAR_RCVR	0x02 /* Clear the RCVR FIFO */
-#define UART_FCR_CLEAR_XMIT	0x04 /* Clear the XMIT FIFO */
-#define UART_FCR_DMA_SELECT	0x08 /* For DMA applications */
-#define UART_FCR_TRIGGER_MASK	0xF0 /* Mask for the FIFO trigger range */
-#define UART_FCR_R_TRIGGER_1	0x00 /* Mask for receive trigger set at 1 */
-#define UART_FCR_R_TRIGGER_4	0x40 /* Mask for receive trigger set at 4 */
-#define UART_FCR_R_TRIGGER_8	0x80 /* Mask for receive trigger set at 8 */
-#define UART_FCR_R_TRIGGER_14   0xA0 /* Mask for receive trigger set at 14 */
-#define UART_FCR_T_TRIGGER_0	0x00 /* Mask for transmit trigger set at 0 */
-#define UART_FCR_T_TRIGGER_4	0x10 /* Mask for transmit trigger set at 4 */
-#define UART_FCR_T_TRIGGER_8    0x20 /* Mask for transmit trigger set at 8 */
-#define UART_FCR_T_TRIGGER_12	0x30 /* Mask for transmit trigger set at 12 */
-
-/*
- * These are the definitions for the Line Control Register
- */
-#define UART_LCR_SBC	0x40	/* Set break control */
-#define UART_LCR_SPAR	0x20	/* Stick parity (?) */
-#define UART_LCR_EPAR	0x10	/* Even parity select */
-#define UART_LCR_PARITY	0x08	/* Parity Enable */
-#define UART_LCR_STOP	0x04	/* Stop bits: 0=1 stop bit, 1= 2 stop bits */
-#define UART_LCR_WLEN5  0x00	/* Wordlength: 5 bits */
-#define UART_LCR_WLEN6  0x01	/* Wordlength: 6 bits */
-#define UART_LCR_WLEN7  0x02	/* Wordlength: 7 bits */
-#define UART_LCR_WLEN8  0x03	/* Wordlength: 8 bits */
-
-/*
- * These are the definitions for the Line Status Register
- */
-#define UART_LSR_TEMT	0x40	/* Transmitter empty */
-#define UART_LSR_THRE	0x20	/* Transmit-hold-register empty */
-#define UART_LSR_BI	0x10	/* Break interrupt indicator */
-#define UART_LSR_FE	0x08	/* Frame error indicator */
-#define UART_LSR_PE	0x04	/* Parity error indicator */
-#define UART_LSR_OE	0x02	/* Overrun error indicator */
-#define UART_LSR_DR	0x01	/* Receiver data ready */
-
-/*
- * These are the definitions for the Interrupt Identification Register
- */
-#define UART_IIR_NO_INT	0x01	/* No interrupts pending */
-#define UART_IIR_ID	0x06	/* Mask for the interrupt ID */
-#define UART_IIR_MSI	0x00	/* Modem status interrupt */
-#define UART_IIR_THRI	0x02	/* Transmitter holding register empty */
-#define UART_IIR_RDI	0x04	/* Receiver data interrupt */
-#define UART_IIR_RLSI	0x06	/* Receiver line status interrupt */
-
-/*
- * These are the definitions for the Interrupt Enable Register
- */
-#define UART_IER_MSI	0x08	/* Enable Modem status interrupt */
-#define UART_IER_RLSI	0x04	/* Enable receiver line status interrupt */
-#define UART_IER_THRI	0x02	/* Enable Transmitter holding register int. */
-#define UART_IER_RDI	0x01	/* Enable receiver data interrupt */
-
-/*
- * These are the definitions for the Modem Control Register
- */
-#define UART_MCR_LOOP	0x10	/* Enable loopback test mode */
-#define UART_MCR_OUT2	0x08	/* Out2 complement */
-#define UART_MCR_OUT1	0x04	/* Out1 complement */
-#define UART_MCR_RTS	0x02	/* RTS complement */
-#define UART_MCR_DTR	0x01	/* DTR complement */
-
-/*
- * These are the definitions for the Modem Status Register
- */
-#define UART_MSR_DCD	0x80	/* Data Carrier Detect */
-#define UART_MSR_RI	0x40	/* Ring Indicator */
-#define UART_MSR_DSR	0x20	/* Data Set Ready */
-#define UART_MSR_CTS	0x10	/* Clear to Send */
-#define UART_MSR_DDCD	0x08	/* Delta DCD */
-#define UART_MSR_TERI	0x04	/* Trailing edge ring indicator */
-#define UART_MSR_DDSR	0x02	/* Delta DSR */
-#define UART_MSR_DCTS	0x01	/* Delta CTS */
-#define UART_MSR_ANY_DELTA 0x0F	/* Any of the delta bits! */
-
 /* SSIO */
 #define SSI0_STATUS		0xB1600000
 #  define SSI_STATUS_BF 	(1 << 4)

commit 8402a1588a4f63465079e98481dd83d1d9cc9a98
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Thu Oct 15 18:49:27 2009 +0200

    MIPS: Alchemy: prom_putchar is board dependent
    
    This patch replaces the general alchemy prom_putchar() implementation
    in favor of board-specific versions:  The UART where the output of
    prom_putchar is directed to really depends on the board, the current
    implementation hardcodes this on a per-SoC basis which is just wrong.
    
    So a generic uart tx function is provided in the alchemy headers,
    and the boards can provide their own prom_putchar with custom
    destination uart, and all in-kernel alchemy boards support
    early printk.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index c2e233997b6c..e11756d9aaa2 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -161,6 +161,25 @@ static inline int alchemy_get_cputype(void)
 	return ALCHEMY_CPU_UNKNOWN;
 }
 
+static inline void alchemy_uart_putchar(u32 uart_phys, u8 c)
+{
+	void __iomem *base = (void __iomem *)KSEG1ADDR(uart_phys);
+	int timeout, i;
+
+	/* check LSR TX_EMPTY bit */
+	timeout = 0xffffff;
+	do {
+		if (__raw_readl(base + 0x1c) & 0x20)
+			break;
+		/* slow down */
+		for (i = 10000; i; i--)
+			asm volatile ("nop");
+	} while (--timeout);
+
+	__raw_writel(c, base + 0x04);	/* tx */
+	wmb();
+}
+
 /* arch/mips/au1000/common/clocks.c */
 extern void set_au1x00_speed(unsigned int new_freq);
 extern unsigned int get_au1x00_speed(void);

commit 788144656b8a862e724a1296e64ab6375eb541ed
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Wed Oct 7 20:15:15 2009 +0200

    MIPS: Alchemy: Stop IRQ name sharing
    
    Eliminate the sharing of IRQ names among the differenct Alchemy
    variants.  IRQ numbers need no longer be hidden behind a
    CONFIG_SOC_AU1XXX symbol: step 1 in my quest to make the Alchemy
    code less reliant on a hardcoded subtype.
    
    This patch also renames the GPIO irq number constants. It's really
    an interrupt line, NOT a GPIO number!
    
    Code which relied on certain irq numbers to have the same name
    across all supported cpu subtypes is changed to determine current
    cpu subtype at runtime; in some places this isn't possible so
    a "compat" symbol is used.
    
    Run-tested on DB1200.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 2dc87d3b0428..c2e233997b6c 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -174,6 +174,333 @@ void au_sleep(void);
 void save_au1xxx_intctl(void);
 void restore_au1xxx_intctl(void);
 
+
+/* SOC Interrupt numbers */
+
+#define AU1000_INTC0_INT_BASE	(MIPS_CPU_IRQ_BASE + 8)
+#define AU1000_INTC0_INT_LAST	(AU1000_INTC0_INT_BASE + 31)
+#define AU1000_INTC1_INT_BASE	(AU1000_INTC0_INT_LAST + 1)
+#define AU1000_INTC1_INT_LAST	(AU1000_INTC1_INT_BASE + 31)
+#define AU1000_MAX_INTR 	AU1000_INTC1_INT_LAST
+
+enum soc_au1000_ints {
+	AU1000_FIRST_INT	= AU1000_INTC0_INT_BASE,
+	AU1000_UART0_INT	= AU1000_FIRST_INT,
+	AU1000_UART1_INT,
+	AU1000_UART2_INT,
+	AU1000_UART3_INT,
+	AU1000_SSI0_INT,
+	AU1000_SSI1_INT,
+	AU1000_DMA_INT_BASE,
+
+	AU1000_TOY_INT		= AU1000_FIRST_INT + 14,
+	AU1000_TOY_MATCH0_INT,
+	AU1000_TOY_MATCH1_INT,
+	AU1000_TOY_MATCH2_INT,
+	AU1000_RTC_INT,
+	AU1000_RTC_MATCH0_INT,
+	AU1000_RTC_MATCH1_INT,
+	AU1000_RTC_MATCH2_INT,
+	AU1000_IRDA_TX_INT,
+	AU1000_IRDA_RX_INT,
+	AU1000_USB_DEV_REQ_INT,
+	AU1000_USB_DEV_SUS_INT,
+	AU1000_USB_HOST_INT,
+	AU1000_ACSYNC_INT,
+	AU1000_MAC0_DMA_INT,
+	AU1000_MAC1_DMA_INT,
+	AU1000_I2S_UO_INT,
+	AU1000_AC97C_INT,
+	AU1000_GPIO0_INT,
+	AU1000_GPIO1_INT,
+	AU1000_GPIO2_INT,
+	AU1000_GPIO3_INT,
+	AU1000_GPIO4_INT,
+	AU1000_GPIO5_INT,
+	AU1000_GPIO6_INT,
+	AU1000_GPIO7_INT,
+	AU1000_GPIO8_INT,
+	AU1000_GPIO9_INT,
+	AU1000_GPIO10_INT,
+	AU1000_GPIO11_INT,
+	AU1000_GPIO12_INT,
+	AU1000_GPIO13_INT,
+	AU1000_GPIO14_INT,
+	AU1000_GPIO15_INT,
+	AU1000_GPIO16_INT,
+	AU1000_GPIO17_INT,
+	AU1000_GPIO18_INT,
+	AU1000_GPIO19_INT,
+	AU1000_GPIO20_INT,
+	AU1000_GPIO21_INT,
+	AU1000_GPIO22_INT,
+	AU1000_GPIO23_INT,
+	AU1000_GPIO24_INT,
+	AU1000_GPIO25_INT,
+	AU1000_GPIO26_INT,
+	AU1000_GPIO27_INT,
+	AU1000_GPIO28_INT,
+	AU1000_GPIO29_INT,
+	AU1000_GPIO30_INT,
+	AU1000_GPIO31_INT,
+};
+
+enum soc_au1100_ints {
+	AU1100_FIRST_INT	= AU1000_INTC0_INT_BASE,
+	AU1100_UART0_INT	= AU1100_FIRST_INT,
+	AU1100_UART1_INT,
+	AU1100_SD_INT,
+	AU1100_UART3_INT,
+	AU1100_SSI0_INT,
+	AU1100_SSI1_INT,
+	AU1100_DMA_INT_BASE,
+
+	AU1100_TOY_INT		= AU1100_FIRST_INT + 14,
+	AU1100_TOY_MATCH0_INT,
+	AU1100_TOY_MATCH1_INT,
+	AU1100_TOY_MATCH2_INT,
+	AU1100_RTC_INT,
+	AU1100_RTC_MATCH0_INT,
+	AU1100_RTC_MATCH1_INT,
+	AU1100_RTC_MATCH2_INT,
+	AU1100_IRDA_TX_INT,
+	AU1100_IRDA_RX_INT,
+	AU1100_USB_DEV_REQ_INT,
+	AU1100_USB_DEV_SUS_INT,
+	AU1100_USB_HOST_INT,
+	AU1100_ACSYNC_INT,
+	AU1100_MAC0_DMA_INT,
+	AU1100_GPIO208_215_INT,
+	AU1100_LCD_INT,
+	AU1100_AC97C_INT,
+	AU1100_GPIO0_INT,
+	AU1100_GPIO1_INT,
+	AU1100_GPIO2_INT,
+	AU1100_GPIO3_INT,
+	AU1100_GPIO4_INT,
+	AU1100_GPIO5_INT,
+	AU1100_GPIO6_INT,
+	AU1100_GPIO7_INT,
+	AU1100_GPIO8_INT,
+	AU1100_GPIO9_INT,
+	AU1100_GPIO10_INT,
+	AU1100_GPIO11_INT,
+	AU1100_GPIO12_INT,
+	AU1100_GPIO13_INT,
+	AU1100_GPIO14_INT,
+	AU1100_GPIO15_INT,
+	AU1100_GPIO16_INT,
+	AU1100_GPIO17_INT,
+	AU1100_GPIO18_INT,
+	AU1100_GPIO19_INT,
+	AU1100_GPIO20_INT,
+	AU1100_GPIO21_INT,
+	AU1100_GPIO22_INT,
+	AU1100_GPIO23_INT,
+	AU1100_GPIO24_INT,
+	AU1100_GPIO25_INT,
+	AU1100_GPIO26_INT,
+	AU1100_GPIO27_INT,
+	AU1100_GPIO28_INT,
+	AU1100_GPIO29_INT,
+	AU1100_GPIO30_INT,
+	AU1100_GPIO31_INT,
+};
+
+enum soc_au1500_ints {
+	AU1500_FIRST_INT	= AU1000_INTC0_INT_BASE,
+	AU1500_UART0_INT	= AU1500_FIRST_INT,
+	AU1500_PCI_INTA,
+	AU1500_PCI_INTB,
+	AU1500_UART3_INT,
+	AU1500_PCI_INTC,
+	AU1500_PCI_INTD,
+	AU1500_DMA_INT_BASE,
+
+	AU1500_TOY_INT		= AU1500_FIRST_INT + 14,
+	AU1500_TOY_MATCH0_INT,
+	AU1500_TOY_MATCH1_INT,
+	AU1500_TOY_MATCH2_INT,
+	AU1500_RTC_INT,
+	AU1500_RTC_MATCH0_INT,
+	AU1500_RTC_MATCH1_INT,
+	AU1500_RTC_MATCH2_INT,
+	AU1500_PCI_ERR_INT,
+	AU1500_RESERVED_INT,
+	AU1500_USB_DEV_REQ_INT,
+	AU1500_USB_DEV_SUS_INT,
+	AU1500_USB_HOST_INT,
+	AU1500_ACSYNC_INT,
+	AU1500_MAC0_DMA_INT,
+	AU1500_MAC1_DMA_INT,
+	AU1500_AC97C_INT	= AU1500_FIRST_INT + 31,
+	AU1500_GPIO0_INT,
+	AU1500_GPIO1_INT,
+	AU1500_GPIO2_INT,
+	AU1500_GPIO3_INT,
+	AU1500_GPIO4_INT,
+	AU1500_GPIO5_INT,
+	AU1500_GPIO6_INT,
+	AU1500_GPIO7_INT,
+	AU1500_GPIO8_INT,
+	AU1500_GPIO9_INT,
+	AU1500_GPIO10_INT,
+	AU1500_GPIO11_INT,
+	AU1500_GPIO12_INT,
+	AU1500_GPIO13_INT,
+	AU1500_GPIO14_INT,
+	AU1500_GPIO15_INT,
+	AU1500_GPIO200_INT,
+	AU1500_GPIO201_INT,
+	AU1500_GPIO202_INT,
+	AU1500_GPIO203_INT,
+	AU1500_GPIO20_INT,
+	AU1500_GPIO204_INT,
+	AU1500_GPIO205_INT,
+	AU1500_GPIO23_INT,
+	AU1500_GPIO24_INT,
+	AU1500_GPIO25_INT,
+	AU1500_GPIO26_INT,
+	AU1500_GPIO27_INT,
+	AU1500_GPIO28_INT,
+	AU1500_GPIO206_INT,
+	AU1500_GPIO207_INT,
+	AU1500_GPIO208_215_INT,
+};
+
+enum soc_au1550_ints {
+	AU1550_FIRST_INT	= AU1000_INTC0_INT_BASE,
+	AU1550_UART0_INT	= AU1550_FIRST_INT,
+	AU1550_PCI_INTA,
+	AU1550_PCI_INTB,
+	AU1550_DDMA_INT,
+	AU1550_CRYPTO_INT,
+	AU1550_PCI_INTC,
+	AU1550_PCI_INTD,
+	AU1550_PCI_RST_INT,
+	AU1550_UART1_INT,
+	AU1550_UART3_INT,
+	AU1550_PSC0_INT,
+	AU1550_PSC1_INT,
+	AU1550_PSC2_INT,
+	AU1550_PSC3_INT,
+	AU1550_TOY_INT,
+	AU1550_TOY_MATCH0_INT,
+	AU1550_TOY_MATCH1_INT,
+	AU1550_TOY_MATCH2_INT,
+	AU1550_RTC_INT,
+	AU1550_RTC_MATCH0_INT,
+	AU1550_RTC_MATCH1_INT,
+	AU1550_RTC_MATCH2_INT,
+
+	AU1550_NAND_INT		= AU1550_FIRST_INT + 23,
+	AU1550_USB_DEV_REQ_INT,
+	AU1550_USB_DEV_SUS_INT,
+	AU1550_USB_HOST_INT,
+	AU1550_MAC0_DMA_INT,
+	AU1550_MAC1_DMA_INT,
+	AU1550_GPIO0_INT	= AU1550_FIRST_INT + 32,
+	AU1550_GPIO1_INT,
+	AU1550_GPIO2_INT,
+	AU1550_GPIO3_INT,
+	AU1550_GPIO4_INT,
+	AU1550_GPIO5_INT,
+	AU1550_GPIO6_INT,
+	AU1550_GPIO7_INT,
+	AU1550_GPIO8_INT,
+	AU1550_GPIO9_INT,
+	AU1550_GPIO10_INT,
+	AU1550_GPIO11_INT,
+	AU1550_GPIO12_INT,
+	AU1550_GPIO13_INT,
+	AU1550_GPIO14_INT,
+	AU1550_GPIO15_INT,
+	AU1550_GPIO200_INT,
+	AU1550_GPIO201_205_INT,	/* Logical or of GPIO201:205 */
+	AU1550_GPIO16_INT,
+	AU1550_GPIO17_INT,
+	AU1550_GPIO20_INT,
+	AU1550_GPIO21_INT,
+	AU1550_GPIO22_INT,
+	AU1550_GPIO23_INT,
+	AU1550_GPIO24_INT,
+	AU1550_GPIO25_INT,
+	AU1550_GPIO26_INT,
+	AU1550_GPIO27_INT,
+	AU1550_GPIO28_INT,
+	AU1550_GPIO206_INT,
+	AU1550_GPIO207_INT,
+	AU1550_GPIO208_215_INT,	/* Logical or of GPIO208:215 */
+};
+
+enum soc_au1200_ints {
+	AU1200_FIRST_INT	= AU1000_INTC0_INT_BASE,
+	AU1200_UART0_INT	= AU1200_FIRST_INT,
+	AU1200_SWT_INT,
+	AU1200_SD_INT,
+	AU1200_DDMA_INT,
+	AU1200_MAE_BE_INT,
+	AU1200_GPIO200_INT,
+	AU1200_GPIO201_INT,
+	AU1200_GPIO202_INT,
+	AU1200_UART1_INT,
+	AU1200_MAE_FE_INT,
+	AU1200_PSC0_INT,
+	AU1200_PSC1_INT,
+	AU1200_AES_INT,
+	AU1200_CAMERA_INT,
+	AU1200_TOY_INT,
+	AU1200_TOY_MATCH0_INT,
+	AU1200_TOY_MATCH1_INT,
+	AU1200_TOY_MATCH2_INT,
+	AU1200_RTC_INT,
+	AU1200_RTC_MATCH0_INT,
+	AU1200_RTC_MATCH1_INT,
+	AU1200_RTC_MATCH2_INT,
+	AU1200_GPIO203_INT,
+	AU1200_NAND_INT,
+	AU1200_GPIO204_INT,
+	AU1200_GPIO205_INT,
+	AU1200_GPIO206_INT,
+	AU1200_GPIO207_INT,
+	AU1200_GPIO208_215_INT,	/* Logical OR of 208:215 */
+	AU1200_USB_INT,
+	AU1200_LCD_INT,
+	AU1200_MAE_BOTH_INT,
+	AU1200_GPIO0_INT,
+	AU1200_GPIO1_INT,
+	AU1200_GPIO2_INT,
+	AU1200_GPIO3_INT,
+	AU1200_GPIO4_INT,
+	AU1200_GPIO5_INT,
+	AU1200_GPIO6_INT,
+	AU1200_GPIO7_INT,
+	AU1200_GPIO8_INT,
+	AU1200_GPIO9_INT,
+	AU1200_GPIO10_INT,
+	AU1200_GPIO11_INT,
+	AU1200_GPIO12_INT,
+	AU1200_GPIO13_INT,
+	AU1200_GPIO14_INT,
+	AU1200_GPIO15_INT,
+	AU1200_GPIO16_INT,
+	AU1200_GPIO17_INT,
+	AU1200_GPIO18_INT,
+	AU1200_GPIO19_INT,
+	AU1200_GPIO20_INT,
+	AU1200_GPIO21_INT,
+	AU1200_GPIO22_INT,
+	AU1200_GPIO23_INT,
+	AU1200_GPIO24_INT,
+	AU1200_GPIO25_INT,
+	AU1200_GPIO26_INT,
+	AU1200_GPIO27_INT,
+	AU1200_GPIO28_INT,
+	AU1200_GPIO29_INT,
+	AU1200_GPIO30_INT,
+	AU1200_GPIO31_INT,
+};
+
 #endif /* !defined (_LANGUAGE_ASSEMBLY) */
 
 /*
@@ -565,70 +892,9 @@ void restore_au1xxx_intctl(void);
 
 #define IC1_TESTBIT		0xB1800080
 
-/* Interrupt Numbers */
+
 /* Au1000 */
 #ifdef CONFIG_SOC_AU1000
-enum soc_au1000_ints {
-	AU1000_FIRST_INT	= MIPS_CPU_IRQ_BASE + 8,
-	AU1000_UART0_INT	= AU1000_FIRST_INT,
-	AU1000_UART1_INT,				/* au1000 */
-	AU1000_UART2_INT,				/* au1000 */
-	AU1000_UART3_INT,
-	AU1000_SSI0_INT,				/* au1000 */
-	AU1000_SSI1_INT,				/* au1000 */
-	AU1000_DMA_INT_BASE,
-
-	AU1000_TOY_INT		= AU1000_FIRST_INT + 14,
-	AU1000_TOY_MATCH0_INT,
-	AU1000_TOY_MATCH1_INT,
-	AU1000_TOY_MATCH2_INT,
-	AU1000_RTC_INT,
-	AU1000_RTC_MATCH0_INT,
-	AU1000_RTC_MATCH1_INT,
-	AU1000_RTC_MATCH2_INT,
-	AU1000_IRDA_TX_INT,				/* au1000 */
-	AU1000_IRDA_RX_INT,				/* au1000 */
-	AU1000_USB_DEV_REQ_INT,
-	AU1000_USB_DEV_SUS_INT,
-	AU1000_USB_HOST_INT,
-	AU1000_ACSYNC_INT,
-	AU1000_MAC0_DMA_INT,
-	AU1000_MAC1_DMA_INT,
-	AU1000_I2S_UO_INT,				/* au1000 */
-	AU1000_AC97C_INT,
-	AU1000_GPIO_0,
-	AU1000_GPIO_1,
-	AU1000_GPIO_2,
-	AU1000_GPIO_3,
-	AU1000_GPIO_4,
-	AU1000_GPIO_5,
-	AU1000_GPIO_6,
-	AU1000_GPIO_7,
-	AU1000_GPIO_8,
-	AU1000_GPIO_9,
-	AU1000_GPIO_10,
-	AU1000_GPIO_11,
-	AU1000_GPIO_12,
-	AU1000_GPIO_13,
-	AU1000_GPIO_14,
-	AU1000_GPIO_15,
-	AU1000_GPIO_16,
-	AU1000_GPIO_17,
-	AU1000_GPIO_18,
-	AU1000_GPIO_19,
-	AU1000_GPIO_20,
-	AU1000_GPIO_21,
-	AU1000_GPIO_22,
-	AU1000_GPIO_23,
-	AU1000_GPIO_24,
-	AU1000_GPIO_25,
-	AU1000_GPIO_26,
-	AU1000_GPIO_27,
-	AU1000_GPIO_28,
-	AU1000_GPIO_29,
-	AU1000_GPIO_30,
-	AU1000_GPIO_31,
-};
 
 #define UART0_ADDR		0xB1100000
 #define UART1_ADDR		0xB1200000
@@ -637,6 +903,7 @@ enum soc_au1000_ints {
 
 #define USB_OHCI_BASE		0x10100000	/* phys addr for ioremap */
 #define USB_HOST_CONFIG 	0xB017FFFC
+#define FOR_PLATFORM_C_USB_HOST_INT AU1000_USB_HOST_INT
 
 #define AU1000_ETH0_BASE	0xB0500000
 #define AU1000_ETH1_BASE	0xB0510000
@@ -647,78 +914,13 @@ enum soc_au1000_ints {
 
 /* Au1500 */
 #ifdef CONFIG_SOC_AU1500
-enum soc_au1500_ints {
-	AU1500_FIRST_INT	= MIPS_CPU_IRQ_BASE + 8,
-	AU1500_UART0_INT	= AU1500_FIRST_INT,
-	AU1000_PCI_INTA,				/* au1500 */
-	AU1000_PCI_INTB,				/* au1500 */
-	AU1500_UART3_INT,
-	AU1000_PCI_INTC,				/* au1500 */
-	AU1000_PCI_INTD,				/* au1500 */
-	AU1000_DMA_INT_BASE,
-
-	AU1000_TOY_INT		= AU1500_FIRST_INT + 14,
-	AU1000_TOY_MATCH0_INT,
-	AU1000_TOY_MATCH1_INT,
-	AU1000_TOY_MATCH2_INT,
-	AU1000_RTC_INT,
-	AU1000_RTC_MATCH0_INT,
-	AU1000_RTC_MATCH1_INT,
-	AU1000_RTC_MATCH2_INT,
-	AU1500_PCI_ERR_INT,
-	AU1500_RESERVED_INT,
-	AU1000_USB_DEV_REQ_INT,
-	AU1000_USB_DEV_SUS_INT,
-	AU1000_USB_HOST_INT,
-	AU1000_ACSYNC_INT,
-	AU1500_MAC0_DMA_INT,
-	AU1500_MAC1_DMA_INT,
-	AU1000_AC97C_INT	= AU1500_FIRST_INT + 31,
-	AU1000_GPIO_0,
-	AU1000_GPIO_1,
-	AU1000_GPIO_2,
-	AU1000_GPIO_3,
-	AU1000_GPIO_4,
-	AU1000_GPIO_5,
-	AU1000_GPIO_6,
-	AU1000_GPIO_7,
-	AU1000_GPIO_8,
-	AU1000_GPIO_9,
-	AU1000_GPIO_10,
-	AU1000_GPIO_11,
-	AU1000_GPIO_12,
-	AU1000_GPIO_13,
-	AU1000_GPIO_14,
-	AU1000_GPIO_15,
-	AU1500_GPIO_200,
-	AU1500_GPIO_201,
-	AU1500_GPIO_202,
-	AU1500_GPIO_203,
-	AU1500_GPIO_20,
-	AU1500_GPIO_204,
-	AU1500_GPIO_205,
-	AU1500_GPIO_23,
-	AU1500_GPIO_24,
-	AU1500_GPIO_25,
-	AU1500_GPIO_26,
-	AU1500_GPIO_27,
-	AU1500_GPIO_28,
-	AU1500_GPIO_206,
-	AU1500_GPIO_207,
-	AU1500_GPIO_208_215,
-};
-
-/* shortcuts */
-#define INTA AU1000_PCI_INTA
-#define INTB AU1000_PCI_INTB
-#define INTC AU1000_PCI_INTC
-#define INTD AU1000_PCI_INTD
 
 #define UART0_ADDR		0xB1100000
 #define UART3_ADDR		0xB1400000
 
 #define USB_OHCI_BASE		0x10100000	/* phys addr for ioremap */
 #define USB_HOST_CONFIG 	0xB017fffc
+#define FOR_PLATFORM_C_USB_HOST_INT AU1500_USB_HOST_INT
 
 #define AU1500_ETH0_BASE	0xB1500000
 #define AU1500_ETH1_BASE	0xB1510000
@@ -729,67 +931,6 @@ enum soc_au1500_ints {
 
 /* Au1100 */
 #ifdef CONFIG_SOC_AU1100
-enum soc_au1100_ints {
-	AU1100_FIRST_INT	= MIPS_CPU_IRQ_BASE + 8,
-	AU1100_UART0_INT	= AU1100_FIRST_INT,
-	AU1100_UART1_INT,
-	AU1100_SD_INT,
-	AU1100_UART3_INT,
-	AU1000_SSI0_INT,
-	AU1000_SSI1_INT,
-	AU1000_DMA_INT_BASE,
-
-	AU1000_TOY_INT		= AU1100_FIRST_INT + 14,
-	AU1000_TOY_MATCH0_INT,
-	AU1000_TOY_MATCH1_INT,
-	AU1000_TOY_MATCH2_INT,
-	AU1000_RTC_INT,
-	AU1000_RTC_MATCH0_INT,
-	AU1000_RTC_MATCH1_INT,
-	AU1000_RTC_MATCH2_INT,
-	AU1000_IRDA_TX_INT,
-	AU1000_IRDA_RX_INT,
-	AU1000_USB_DEV_REQ_INT,
-	AU1000_USB_DEV_SUS_INT,
-	AU1000_USB_HOST_INT,
-	AU1000_ACSYNC_INT,
-	AU1100_MAC0_DMA_INT,
-	AU1100_GPIO_208_215,
-	AU1100_LCD_INT,
-	AU1000_AC97C_INT,
-	AU1000_GPIO_0,
-	AU1000_GPIO_1,
-	AU1000_GPIO_2,
-	AU1000_GPIO_3,
-	AU1000_GPIO_4,
-	AU1000_GPIO_5,
-	AU1000_GPIO_6,
-	AU1000_GPIO_7,
-	AU1000_GPIO_8,
-	AU1000_GPIO_9,
-	AU1000_GPIO_10,
-	AU1000_GPIO_11,
-	AU1000_GPIO_12,
-	AU1000_GPIO_13,
-	AU1000_GPIO_14,
-	AU1000_GPIO_15,
-	AU1000_GPIO_16,
-	AU1000_GPIO_17,
-	AU1000_GPIO_18,
-	AU1000_GPIO_19,
-	AU1000_GPIO_20,
-	AU1000_GPIO_21,
-	AU1000_GPIO_22,
-	AU1000_GPIO_23,
-	AU1000_GPIO_24,
-	AU1000_GPIO_25,
-	AU1000_GPIO_26,
-	AU1000_GPIO_27,
-	AU1000_GPIO_28,
-	AU1000_GPIO_29,
-	AU1000_GPIO_30,
-	AU1000_GPIO_31,
-};
 
 #define UART0_ADDR		0xB1100000
 #define UART1_ADDR		0xB1200000
@@ -797,6 +938,7 @@ enum soc_au1100_ints {
 
 #define USB_OHCI_BASE		0x10100000	/* phys addr for ioremap */
 #define USB_HOST_CONFIG 	0xB017FFFC
+#define FOR_PLATFORM_C_USB_HOST_INT AU1100_USB_HOST_INT
 
 #define AU1100_ETH0_BASE	0xB0500000
 #define AU1100_MAC0_ENABLE	0xB0520000
@@ -804,80 +946,6 @@ enum soc_au1100_ints {
 #endif /* CONFIG_SOC_AU1100 */
 
 #ifdef CONFIG_SOC_AU1550
-enum soc_au1550_ints {
-	AU1550_FIRST_INT	= MIPS_CPU_IRQ_BASE + 8,
-	AU1550_UART0_INT	= AU1550_FIRST_INT,
-	AU1550_PCI_INTA,
-	AU1550_PCI_INTB,
-	AU1550_DDMA_INT,
-	AU1550_CRYPTO_INT,
-	AU1550_PCI_INTC,
-	AU1550_PCI_INTD,
-	AU1550_PCI_RST_INT,
-	AU1550_UART1_INT,
-	AU1550_UART3_INT,
-	AU1550_PSC0_INT,
-	AU1550_PSC1_INT,
-	AU1550_PSC2_INT,
-	AU1550_PSC3_INT,
-	AU1000_TOY_INT,
-	AU1000_TOY_MATCH0_INT,
-	AU1000_TOY_MATCH1_INT,
-	AU1000_TOY_MATCH2_INT,
-	AU1000_RTC_INT,
-	AU1000_RTC_MATCH0_INT,
-	AU1000_RTC_MATCH1_INT,
-	AU1000_RTC_MATCH2_INT,
-
-	AU1550_NAND_INT			= AU1550_FIRST_INT + 23,
-	AU1550_USB_DEV_REQ_INT,
-	AU1000_USB_DEV_REQ_INT		= AU1550_USB_DEV_REQ_INT,
-	AU1550_USB_DEV_SUS_INT,
-	AU1000_USB_DEV_SUS_INT		= AU1550_USB_DEV_SUS_INT,
-	AU1550_USB_HOST_INT,
-	AU1000_USB_HOST_INT		= AU1550_USB_HOST_INT,
-	AU1550_MAC0_DMA_INT,
-	AU1550_MAC1_DMA_INT,
-	AU1000_GPIO_0			= AU1550_FIRST_INT + 32,
-	AU1000_GPIO_1,
-	AU1000_GPIO_2,
-	AU1000_GPIO_3,
-	AU1000_GPIO_4,
-	AU1000_GPIO_5,
-	AU1000_GPIO_6,
-	AU1000_GPIO_7,
-	AU1000_GPIO_8,
-	AU1000_GPIO_9,
-	AU1000_GPIO_10,
-	AU1000_GPIO_11,
-	AU1000_GPIO_12,
-	AU1000_GPIO_13,
-	AU1000_GPIO_14,
-	AU1000_GPIO_15,
-	AU1550_GPIO_200,
-	AU1500_GPIO_201_205,			/* Logical or of GPIO201:205 */
-	AU1500_GPIO_16,
-	AU1500_GPIO_17,
-	AU1500_GPIO_20,
-	AU1500_GPIO_21,
-	AU1500_GPIO_22,
-	AU1500_GPIO_23,
-	AU1500_GPIO_24,
-	AU1500_GPIO_25,
-	AU1500_GPIO_26,
-	AU1500_GPIO_27,
-	AU1500_GPIO_28,
-	AU1500_GPIO_206,
-	AU1500_GPIO_207,
-	AU1500_GPIO_208_218,			/* Logical or of GPIO208:218 */
-};
-
-/* shortcuts */
-#define INTA AU1550_PCI_INTA
-#define INTB AU1550_PCI_INTB
-#define INTC AU1550_PCI_INTC
-#define INTD AU1550_PCI_INTD
-
 #define UART0_ADDR		0xB1100000
 #define UART1_ADDR		0xB1200000
 #define UART3_ADDR		0xB1400000
@@ -885,6 +953,7 @@ enum soc_au1550_ints {
 #define USB_OHCI_BASE		0x14020000	/* phys addr for ioremap */
 #define USB_OHCI_LEN		0x00060000
 #define USB_HOST_CONFIG 	0xB4027ffc
+#define FOR_PLATFORM_C_USB_HOST_INT AU1550_USB_HOST_INT
 
 #define AU1550_ETH0_BASE	0xB0500000
 #define AU1550_ETH1_BASE	0xB0510000
@@ -893,75 +962,8 @@ enum soc_au1550_ints {
 #define NUM_ETH_INTERFACES 2
 #endif /* CONFIG_SOC_AU1550 */
 
+
 #ifdef CONFIG_SOC_AU1200
-enum soc_au1200_ints {
-	AU1200_FIRST_INT	= MIPS_CPU_IRQ_BASE + 8,
-	AU1200_UART0_INT	= AU1200_FIRST_INT,
-	AU1200_SWT_INT,
-	AU1200_SD_INT,
-	AU1200_DDMA_INT,
-	AU1200_MAE_BE_INT,
-	AU1200_GPIO_200,
-	AU1200_GPIO_201,
-	AU1200_GPIO_202,
-	AU1200_UART1_INT,
-	AU1200_MAE_FE_INT,
-	AU1200_PSC0_INT,
-	AU1200_PSC1_INT,
-	AU1200_AES_INT,
-	AU1200_CAMERA_INT,
-	AU1000_TOY_INT,
-	AU1000_TOY_MATCH0_INT,
-	AU1000_TOY_MATCH1_INT,
-	AU1000_TOY_MATCH2_INT,
-	AU1000_RTC_INT,
-	AU1000_RTC_MATCH0_INT,
-	AU1000_RTC_MATCH1_INT,
-	AU1000_RTC_MATCH2_INT,
-	AU1200_GPIO_203,
-	AU1200_NAND_INT,
-	AU1200_GPIO_204,
-	AU1200_GPIO_205,
-	AU1200_GPIO_206,
-	AU1200_GPIO_207,
-	AU1200_GPIO_208_215,			/* Logical OR of 208:215 */
-	AU1200_USB_INT,
-	AU1000_USB_HOST_INT	= AU1200_USB_INT,
-	AU1200_LCD_INT,
-	AU1200_MAE_BOTH_INT,
-	AU1000_GPIO_0,
-	AU1000_GPIO_1,
-	AU1000_GPIO_2,
-	AU1000_GPIO_3,
-	AU1000_GPIO_4,
-	AU1000_GPIO_5,
-	AU1000_GPIO_6,
-	AU1000_GPIO_7,
-	AU1000_GPIO_8,
-	AU1000_GPIO_9,
-	AU1000_GPIO_10,
-	AU1000_GPIO_11,
-	AU1000_GPIO_12,
-	AU1000_GPIO_13,
-	AU1000_GPIO_14,
-	AU1000_GPIO_15,
-	AU1000_GPIO_16,
-	AU1000_GPIO_17,
-	AU1000_GPIO_18,
-	AU1000_GPIO_19,
-	AU1000_GPIO_20,
-	AU1000_GPIO_21,
-	AU1000_GPIO_22,
-	AU1000_GPIO_23,
-	AU1000_GPIO_24,
-	AU1000_GPIO_25,
-	AU1000_GPIO_26,
-	AU1000_GPIO_27,
-	AU1000_GPIO_28,
-	AU1000_GPIO_29,
-	AU1000_GPIO_30,
-	AU1000_GPIO_31,
-};
 
 #define UART0_ADDR		0xB1100000
 #define UART1_ADDR		0xB1200000
@@ -990,15 +992,9 @@ enum soc_au1200_ints {
 #define USBMSRMCFG_RDCOMB	30
 #define USBMSRMCFG_PFEN 	31
 
-#endif /* CONFIG_SOC_AU1200 */
+#define FOR_PLATFORM_C_USB_HOST_INT AU1200_USB_INT
 
-#define AU1000_INTC0_INT_BASE	(MIPS_CPU_IRQ_BASE + 8)
-#define AU1000_INTC0_INT_LAST	(AU1000_INTC0_INT_BASE + 31)
-#define AU1000_INTC1_INT_BASE	(AU1000_INTC0_INT_BASE + 32)
-#define AU1000_INTC1_INT_LAST	(AU1000_INTC1_INT_BASE + 31)
-
-#define AU1000_MAX_INTR 	AU1000_INTC1_INT_LAST
-#define INTX			0xFF			/* not valid */
+#endif /* CONFIG_SOC_AU1200 */
 
 /* Programmable Counters 0 and 1 */
 #define SYS_BASE		0xB1900000

commit 93e9cd8485b31e5a33f1040bff4d15e65c0b2d19
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Wed Oct 7 20:15:14 2009 +0200

    MIPS: Alchemy: Simple cpu subtype detector
    
    Extract the alchemy chip variant from c0_prid register.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/14/
    Patchwork: http://patchwork.linux-mips.org/patch/707/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index fceeca883359..2dc87d3b0428 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -130,6 +130,37 @@ static inline int au1xxx_cpu_needs_config_od(void)
 	return 0;
 }
 
+#define ALCHEMY_CPU_UNKNOWN	-1
+#define ALCHEMY_CPU_AU1000	0
+#define ALCHEMY_CPU_AU1500	1
+#define ALCHEMY_CPU_AU1100	2
+#define ALCHEMY_CPU_AU1550	3
+#define ALCHEMY_CPU_AU1200	4
+
+static inline int alchemy_get_cputype(void)
+{
+	switch (read_c0_prid() & 0xffff0000) {
+	case 0x00030000:
+		return ALCHEMY_CPU_AU1000;
+		break;
+	case 0x01030000:
+		return ALCHEMY_CPU_AU1500;
+		break;
+	case 0x02030000:
+		return ALCHEMY_CPU_AU1100;
+		break;
+	case 0x03030000:
+		return ALCHEMY_CPU_AU1550;
+		break;
+	case 0x04030000:
+	case 0x05030000:
+		return ALCHEMY_CPU_AU1200;
+		break;
+	}
+
+	return ALCHEMY_CPU_UNKNOWN;
+}
+
 /* arch/mips/au1000/common/clocks.c */
 extern void set_au1x00_speed(unsigned int new_freq);
 extern unsigned int get_au1x00_speed(void);

commit 66213b3ccfc770704025ce9465fa3aaedde21b55
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Sun Oct 4 14:55:27 2009 +0200

    MIPS: PCMCIA: new socket driver for Au1000 demoboards.
    
    New PCMCIA socket driver for all Db/Pb1xxx boards (except Pb1000),
    which replaces au1000_db1x00.c and (most of) au1000_pb1x00.c.
    Notable improvements:
            - supports Db1000, DB/PB1100/1500/1550/1200.
            - support for carddetect and statuschange IRQs.
            - pcmcia socket mem/io/attr areas and irqs passed through
              platform resource information.
            - doesn't freeze system during card insertion/ejection like
              the one it replaces.
            - boardtype is automatically detected using BCSR ID register.
    
    Run-tested on the DB1200.
    
    Cc: Linux-PCMCIA <linux-pcmcia@lists.infradead.org>
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 05078224e933..fceeca883359 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -1724,6 +1724,20 @@ enum soc_au1200_ints {
 
 #endif
 
+/*
+ * All Au1xx0 SOCs have a PCMCIA controller.
+ * We setup our 32-bit pseudo addresses to be equal to the
+ * 36-bit addr >> 4, to make it easier to check the address
+ * and fix it.
+ * The PCMCIA socket 0 physical attribute address is 0xF 4000 0000.
+ * The pseudo address we use is 0xF400 0000. Any address over
+ * 0xF400 0000 is a PCMCIA pseudo address.
+ */
+#define PCMCIA_IO_PSEUDO_PHYS	(PCMCIA_IO_PHYS_ADDR >> 4)
+#define PCMCIA_ATTR_PSEUDO_PHYS	(PCMCIA_ATTR_PHYS_ADDR >> 4)
+#define PCMCIA_MEM_PSEUDO_PHYS	(PCMCIA_MEM_PHYS_ADDR >> 4)
+#define PCMCIA_PSEUDO_END	(0xffffffff)
+
 #ifndef _LANGUAGE_ASSEMBLY
 typedef volatile struct {
 	/* 0x0000 */ u32 toytrim;

commit 7e50b2b741bb4f9dbddc9f56972ef82a7d4b33ed
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Sun Oct 4 14:55:26 2009 +0200

    MIPS: Alchemy: remove board_init_irq() function.
    
    remove board_init_irq():  On all in-kernel boards it is sufficient to
    initialize board interrupts in an arch_initcall by using the default
    linux irq functions.
    
    Some small irqmap.c files have been folded into board_setup files.
    
    Run-tested on DB1200; compile-tested on all other affected boards.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 854e95f1b07c..05078224e933 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -143,21 +143,6 @@ void au_sleep(void);
 void save_au1xxx_intctl(void);
 void restore_au1xxx_intctl(void);
 
-/*
- * Every board describes its IRQ mapping with this table.
- */
-struct au1xxx_irqmap {
-	int	im_irq;
-	int	im_type;
-	int	im_request;
-};
-
-/* core calls this function to let boards initialize other IRQ sources */
-void board_init_irq(void);
-
-/* boards call this to register additional (GPIO) interrupts */
-void au1xxx_setup_irqmap(struct au1xxx_irqmap *map, int count);
-
 #endif /* !defined (_LANGUAGE_ASSEMBLY) */
 
 /*

commit d16797b304a4701a7d156f47773c6d2e456b64ee
Author: Manuel Lauss <mano@roarinelk.homelinux.net>
Date:   Tue Mar 31 18:51:28 2009 +0200

    MIPS: Alchemy: Add missing Au1200 GPIO203 interrupt
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 87a16598ebc3..854e95f1b07c 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -902,8 +902,8 @@ enum soc_au1200_ints {
 	AU1000_RTC_MATCH0_INT,
 	AU1000_RTC_MATCH1_INT,
 	AU1000_RTC_MATCH2_INT,
-
-	AU1200_NAND_INT		= AU1200_FIRST_INT + 23,
+	AU1200_GPIO_203,
+	AU1200_NAND_INT,
 	AU1200_GPIO_204,
 	AU1200_GPIO_205,
 	AU1200_GPIO_206,

commit b7863ee144a99ff54fee90d851e24d73f38af661
Author: Manuel Lauss <mano@roarinelk.homelinux.net>
Date:   Tue Mar 31 18:51:27 2009 +0200

    MIPS: Alchemy: Fix AU1100 interrupt numbers off-by-one
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 62f91f50b5b5..87a16598ebc3 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -715,7 +715,7 @@ enum soc_au1500_ints {
 #ifdef CONFIG_SOC_AU1100
 enum soc_au1100_ints {
 	AU1100_FIRST_INT	= MIPS_CPU_IRQ_BASE + 8,
-	AU1100_UART0_INT,
+	AU1100_UART0_INT	= AU1100_FIRST_INT,
 	AU1100_UART1_INT,
 	AU1100_SD_INT,
 	AU1100_UART3_INT,

commit 61f9c58da57a80b0df1ced18a28cbbaebd4d417a
Author: Manuel Lauss <mano@roarinelk.homelinux.net>
Date:   Sun Dec 21 09:26:27 2008 +0100

    MIPS: Alchemy: new userspace suspend interface for development boards.
    
    Replace the current sysctl-based suspend interface with a new sysfs-
    based one which also uses the Linux-2.6 suspend model.
    
    To configure wakeup sources, a subtree for the demoboards is created
    under /sys/power/db1x:
    
    sys/
    `-- power
        `-- db1x
            |-- gpio0
            |-- gpio1
            |-- gpio2
            |-- gpio3
            |-- gpio4
            |-- gpio5
            |-- gpio6
            |-- gpio7
            |-- timer
            |-- timer_timeout
            |-- wakemsk
            `-- wakesrc
    
    The nodes 'gpio[0-7]' and 'timer' configure the GPIO0..7 and M2
    bits of the SYS_WAKEMSK (wakeup source enable) register.  Writing '1'
    enables a wakesource, 0 disables it.
    
    The 'timer_timeout' node holds the timeout in seconds after which the
    TOYMATCH2 event should wake the system.
    
    The 'wakesrc' node holds the SYS_WAKESRC register after wakeup (in hex),
    the 'wakemsk' node can be used to get/set the wakeup mask directly.
    
    For example, to have the timer wake the system after 10 seconds of sleep,
    the following must be done in userspace:
    
    echo 10 > /sys/power/db1x/timer_timeout
    echo 1 > /sys/power/db1x/timer
    echo mem > /sys/power/sleep
    
    This patch also removes the homebrew CPU frequency switching code.  I don't
    understand how it could have ever worked reliably; it does not communicate
    the clock changes to peripheral devices other than uarts.
    
    Signed-off-by: Manuel Lauss <mano@roarinelk.homelinux.net>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    
     create mode 100644 arch/mips/alchemy/devboards/pm.c

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 515373c6d4a1..62f91f50b5b5 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -1560,6 +1560,10 @@ enum soc_au1200_ints {
 #define SYS_SLPPWR		0xB1900078
 #define SYS_SLEEP		0xB190007C
 
+#define SYS_WAKEMSK_D2		(1 << 9)
+#define SYS_WAKEMSK_M2		(1 << 8)
+#define SYS_WAKEMSK_GPIO(x)	(1 << (x))
+
 /* Clock Controller */
 #define SYS_FREQCTRL0		0xB1900020
 #  define SYS_FC_FRDIV2_BIT	22

commit 564365b0fc3395ed55501ef25705664888cebdbc
Author: Manuel Lauss <mano@roarinelk.homelinux.net>
Date:   Sun Dec 21 09:26:25 2008 +0100

    MIPS: Alchemy: Fix up PM code on Au1550/Au1200
    
    Au1550/Au1200 have a different memory controller which requires additi-
    onal code to properly put memory to sleep (code taken from AMD/RMI's
    Linux-2.6.11 source package).
    
    Also fix up the remaining pm-related paths to compile on Au1200/Au1550
    platforms.
    
    Signed-off-by: Manuel Lauss <mano@roarinelk.homelinux.net>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 2b88c2982cb0..515373c6d4a1 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -137,6 +137,12 @@ extern void set_au1x00_uart_baud_base(unsigned long new_baud_base);
 extern unsigned long get_au1x00_uart_baud_base(void);
 extern unsigned long au1xxx_calc_clock(void);
 
+/* PM: arch/mips/alchemy/common/sleeper.S, power.c, irq.c */
+void au1xxx_save_and_sleep(void);
+void au_sleep(void);
+void save_au1xxx_intctl(void);
+void restore_au1xxx_intctl(void);
+
 /*
  * Every board describes its IRQ mapping with this table.
  */

commit 2699cdfb765c3b7d77d28ea3bc7d84e486697177
Author: Manuel Lauss <mano@roarinelk.homelinux.net>
Date:   Sun Dec 21 09:26:24 2008 +0100

    MIPS: Alchemy: move calc_clock function.
    
    Now that nothing in time.c depends on calc_clock, it can
    be moved to clocks.c where it belongs.
    While at it, give it a better non-generic name and call it
    as soon as possible in plat_mem_init.
    
    Signed-off-by: Manuel Lauss <mano@roarinelk.homelinux.net>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 5db26e60a8c5..2b88c2982cb0 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -135,6 +135,7 @@ extern void set_au1x00_speed(unsigned int new_freq);
 extern unsigned int get_au1x00_speed(void);
 extern void set_au1x00_uart_baud_base(unsigned long new_baud_base);
 extern unsigned long get_au1x00_uart_baud_base(void);
+extern unsigned long au1xxx_calc_clock(void);
 
 /*
  * Every board describes its IRQ mapping with this table.

commit 074cf656700ddd1d2bd7f815f78e785418beb898
Author: Manuel Lauss <mano@roarinelk.homelinux.net>
Date:   Sun Dec 21 09:26:21 2008 +0100

    MIPS: Alchemy: remove cpu_table.
    
    Remove the cpu_table:
    - move detection of whether c0_config[OD] is read-only and should be set
      to fix various chip errata to au1000 headers.
    - move detection of write-only sys_cpupll to au1000 headers.
    - remove the BCLK switching code:  Activation of this features should be
      left to the boards using the chips since it also affects external devices
      tied to BCLK, and only the board designers know whether it is safe to
      enable.
    
    Signed-off-by: Manuel Lauss <mano@roarinelk.homelinux.net>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    
     delete mode 100644 arch/mips/alchemy/common/cputable.c

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index d07632e3230b..5db26e60a8c5 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -91,6 +91,44 @@ static inline u32 au_readl(unsigned long reg)
 	return *(volatile u32 *)reg;
 }
 
+/* Early Au1000 have a write-only SYS_CPUPLL register. */
+static inline int au1xxx_cpu_has_pll_wo(void)
+{
+	switch (read_c0_prid()) {
+	case 0x00030100:	/* Au1000 DA */
+	case 0x00030201:	/* Au1000 HA */
+	case 0x00030202:	/* Au1000 HB */
+		return 1;
+	}
+	return 0;
+}
+
+/* does CPU need CONFIG[OD] set to fix tons of errata? */
+static inline int au1xxx_cpu_needs_config_od(void)
+{
+	/*
+	 * c0_config.od (bit 19) was write only (and read as 0) on the
+	 * early revisions of Alchemy SOCs.  It disables the bus trans-
+	 * action overlapping and needs to be set to fix various errata.
+	 */
+	switch (read_c0_prid()) {
+	case 0x00030100: /* Au1000 DA */
+	case 0x00030201: /* Au1000 HA */
+	case 0x00030202: /* Au1000 HB */
+	case 0x01030200: /* Au1500 AB */
+	/*
+	 * Au1100/Au1200 errata actually keep silence about this bit,
+	 * so we set it just in case for those revisions that require
+	 * it to be set according to the (now gone) cpu_table.
+	 */
+	case 0x02030200: /* Au1100 AB */
+	case 0x02030201: /* Au1100 BA */
+	case 0x02030202: /* Au1100 BC */
+	case 0x04030201: /* Au1200 AC */
+		return 1;
+	}
+	return 0;
+}
 
 /* arch/mips/au1000/common/clocks.c */
 extern void set_au1x00_speed(unsigned int new_freq);
@@ -1739,24 +1777,4 @@ static AU1X00_SYS * const sys = (AU1X00_SYS *)SYS_BASE;
 
 #endif
 
-/*
- * Processor information based on PRID.
- * Copied from PowerPC.
- */
-#ifndef _LANGUAGE_ASSEMBLY
-struct cpu_spec {
-	/* CPU is matched via (PRID & prid_mask) == prid_value */
-	unsigned int	prid_mask;
-	unsigned int	prid_value;
-
-	char		*cpu_name;
-	unsigned char	cpu_od;		/* Set Config[OD] */
-	unsigned char	cpu_bclk;	/* Enable BCLK switching */
-	unsigned char	cpu_pll_wo;	/* sys_cpupll reg. write-only */
-};
-
-extern struct cpu_spec	cpu_specs[];
-extern struct cpu_spec	*cur_cpu_spec[];
-#endif
-
 #endif

commit 1820ec1d2b993f3ec00169e881504aa4541a9bf7
Author: Manuel Lauss <mano@roarinelk.homelinux.net>
Date:   Sun Dec 21 09:26:20 2008 +0100

    MIPS: Alchemy: remove get/set_au1x00_lcd_clock().
    
    There are no in-tree users, so remove them.
    
    Signed-off-by: Manuel Lauss <mano@roarinelk.homelinux.net>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index a7ba35247c8a..d07632e3230b 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -97,8 +97,6 @@ extern void set_au1x00_speed(unsigned int new_freq);
 extern unsigned int get_au1x00_speed(void);
 extern void set_au1x00_uart_baud_base(unsigned long new_baud_base);
 extern unsigned long get_au1x00_uart_baud_base(void);
-extern void set_au1x00_lcd_clock(void);
-extern unsigned int get_au1x00_lcd_clock(void);
 
 /*
  * Every board describes its IRQ mapping with this table.

commit 785e3268e2951d4c0c21417c8e5d8004b2ab2480
Author: Manuel Lauss <mano@roarinelk.homelinux.net>
Date:   Sun Dec 21 09:26:17 2008 +0100

    MIPS: Alchemy: update core interrupt code.
    
    This patch attempts to modernize core Alchemy interrupt handling code.
    
    - add irq_chips for irq controllers instead of irq type,
    - add a set_type() hook to change irq trigger type during runtime,
    - add a set_wake() hook to control GPIO0..7 based wakeup,
    - use linux' IRQF_TRIGGER_ constants instead of homebrew ones,
    - enable GENERIC_HARDIRQS_NO__DO_IRQ.
    - simplify plat_irq_dispatch
    - merge au1xxx_irqmap into irq.c file, the only place where its
      contents are referenced.
    - board_init_irq() is now mandatory for every board; use it to register
      the remaining (gpio-based) interrupt sources; update all boards
      accordingly.
    
    Run-tested on Db1200 and other Au1200 based platforms.
    
    Signed-off-by: Manuel Lauss <mano@roarinelk.homelinux.net>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    
     delete mode 100644 arch/mips/alchemy/common/au1xxx_irqmap.c

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
index 0d302bad4492..a7ba35247c8a 100644
--- a/arch/mips/include/asm/mach-au1x00/au1000.h
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -109,10 +109,11 @@ struct au1xxx_irqmap {
 	int	im_request;
 };
 
-/*
- * init_IRQ looks for a table with this name.
- */
-extern struct au1xxx_irqmap au1xxx_irq_map[];
+/* core calls this function to let boards initialize other IRQ sources */
+void board_init_irq(void);
+
+/* boards call this to register additional (GPIO) interrupts */
+void au1xxx_setup_irqmap(struct au1xxx_irqmap *map, int count);
 
 #endif /* !defined (_LANGUAGE_ASSEMBLY) */
 
@@ -505,15 +506,6 @@ extern struct au1xxx_irqmap au1xxx_irq_map[];
 
 #define IC1_TESTBIT		0xB1800080
 
-/* Interrupt Configuration Modes */
-#define INTC_INT_DISABLED		0x0
-#define INTC_INT_RISE_EDGE		0x1
-#define INTC_INT_FALL_EDGE		0x2
-#define INTC_INT_RISE_AND_FALL_EDGE	0x3
-#define INTC_INT_HIGH_LEVEL		0x5
-#define INTC_INT_LOW_LEVEL		0x6
-#define INTC_INT_HIGH_AND_LOW_LEVEL	0x7
-
 /* Interrupt Numbers */
 /* Au1000 */
 #ifdef CONFIG_SOC_AU1000

commit 384740dc49ea651ba350704d13ff6be9976e37fe
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Sep 16 19:48:51 2008 +0200

    MIPS: Move headfiles to new location below arch/mips/include
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1000.h b/arch/mips/include/asm/mach-au1x00/au1000.h
new file mode 100644
index 000000000000..0d302bad4492
--- /dev/null
+++ b/arch/mips/include/asm/mach-au1x00/au1000.h
@@ -0,0 +1,1772 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Include file for Alchemy Semiconductor's Au1k CPU.
+ *
+ * Copyright 2000-2001, 2006-2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+ /*
+  * some definitions add by takuzo@sm.sony.co.jp and sato@sm.sony.co.jp
+  */
+
+#ifndef _AU1000_H_
+#define _AU1000_H_
+
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+#include <linux/delay.h>
+#include <linux/types.h>
+
+#include <linux/io.h>
+#include <linux/irq.h>
+
+/* cpu pipeline flush */
+void static inline au_sync(void)
+{
+	__asm__ volatile ("sync");
+}
+
+void static inline au_sync_udelay(int us)
+{
+	__asm__ volatile ("sync");
+	udelay(us);
+}
+
+void static inline au_sync_delay(int ms)
+{
+	__asm__ volatile ("sync");
+	mdelay(ms);
+}
+
+void static inline au_writeb(u8 val, unsigned long reg)
+{
+	*(volatile u8 *)reg = val;
+}
+
+void static inline au_writew(u16 val, unsigned long reg)
+{
+	*(volatile u16 *)reg = val;
+}
+
+void static inline au_writel(u32 val, unsigned long reg)
+{
+	*(volatile u32 *)reg = val;
+}
+
+static inline u8 au_readb(unsigned long reg)
+{
+	return *(volatile u8 *)reg;
+}
+
+static inline u16 au_readw(unsigned long reg)
+{
+	return *(volatile u16 *)reg;
+}
+
+static inline u32 au_readl(unsigned long reg)
+{
+	return *(volatile u32 *)reg;
+}
+
+
+/* arch/mips/au1000/common/clocks.c */
+extern void set_au1x00_speed(unsigned int new_freq);
+extern unsigned int get_au1x00_speed(void);
+extern void set_au1x00_uart_baud_base(unsigned long new_baud_base);
+extern unsigned long get_au1x00_uart_baud_base(void);
+extern void set_au1x00_lcd_clock(void);
+extern unsigned int get_au1x00_lcd_clock(void);
+
+/*
+ * Every board describes its IRQ mapping with this table.
+ */
+struct au1xxx_irqmap {
+	int	im_irq;
+	int	im_type;
+	int	im_request;
+};
+
+/*
+ * init_IRQ looks for a table with this name.
+ */
+extern struct au1xxx_irqmap au1xxx_irq_map[];
+
+#endif /* !defined (_LANGUAGE_ASSEMBLY) */
+
+/*
+ * SDRAM register offsets
+ */
+#if defined(CONFIG_SOC_AU1000) || defined(CONFIG_SOC_AU1500) || \
+    defined(CONFIG_SOC_AU1100)
+#define MEM_SDMODE0		0x0000
+#define MEM_SDMODE1		0x0004
+#define MEM_SDMODE2		0x0008
+#define MEM_SDADDR0		0x000C
+#define MEM_SDADDR1		0x0010
+#define MEM_SDADDR2		0x0014
+#define MEM_SDREFCFG		0x0018
+#define MEM_SDPRECMD		0x001C
+#define MEM_SDAUTOREF		0x0020
+#define MEM_SDWRMD0		0x0024
+#define MEM_SDWRMD1		0x0028
+#define MEM_SDWRMD2		0x002C
+#define MEM_SDSLEEP		0x0030
+#define MEM_SDSMCKE		0x0034
+
+/*
+ * MEM_SDMODE register content definitions
+ */
+#define MEM_SDMODE_F		(1 << 22)
+#define MEM_SDMODE_SR		(1 << 21)
+#define MEM_SDMODE_BS		(1 << 20)
+#define MEM_SDMODE_RS		(3 << 18)
+#define MEM_SDMODE_CS		(7 << 15)
+#define MEM_SDMODE_TRAS 	(15 << 11)
+#define MEM_SDMODE_TMRD 	(3 << 9)
+#define MEM_SDMODE_TWR		(3 << 7)
+#define MEM_SDMODE_TRP		(3 << 5)
+#define MEM_SDMODE_TRCD 	(3 << 3)
+#define MEM_SDMODE_TCL		(7 << 0)
+
+#define MEM_SDMODE_BS_2Bank	(0 << 20)
+#define MEM_SDMODE_BS_4Bank	(1 << 20)
+#define MEM_SDMODE_RS_11Row	(0 << 18)
+#define MEM_SDMODE_RS_12Row	(1 << 18)
+#define MEM_SDMODE_RS_13Row	(2 << 18)
+#define MEM_SDMODE_RS_N(N)	((N) << 18)
+#define MEM_SDMODE_CS_7Col	(0 << 15)
+#define MEM_SDMODE_CS_8Col	(1 << 15)
+#define MEM_SDMODE_CS_9Col	(2 << 15)
+#define MEM_SDMODE_CS_10Col	(3 << 15)
+#define MEM_SDMODE_CS_11Col	(4 << 15)
+#define MEM_SDMODE_CS_N(N)	((N) << 15)
+#define MEM_SDMODE_TRAS_N(N)	((N) << 11)
+#define MEM_SDMODE_TMRD_N(N)	((N) << 9)
+#define MEM_SDMODE_TWR_N(N)	((N) << 7)
+#define MEM_SDMODE_TRP_N(N)	((N) << 5)
+#define MEM_SDMODE_TRCD_N(N)	((N) << 3)
+#define MEM_SDMODE_TCL_N(N)	((N) << 0)
+
+/*
+ * MEM_SDADDR register contents definitions
+ */
+#define MEM_SDADDR_E		(1 << 20)
+#define MEM_SDADDR_CSBA 	(0x03FF << 10)
+#define MEM_SDADDR_CSMASK	(0x03FF << 0)
+#define MEM_SDADDR_CSBA_N(N)	((N) & (0x03FF << 22) >> 12)
+#define MEM_SDADDR_CSMASK_N(N)	((N)&(0x03FF << 22) >> 22)
+
+/*
+ * MEM_SDREFCFG register content definitions
+ */
+#define MEM_SDREFCFG_TRC	(15 << 28)
+#define MEM_SDREFCFG_TRPM	(3 << 26)
+#define MEM_SDREFCFG_E		(1 << 25)
+#define MEM_SDREFCFG_RE 	(0x1ffffff << 0)
+#define MEM_SDREFCFG_TRC_N(N)	((N) << MEM_SDREFCFG_TRC)
+#define MEM_SDREFCFG_TRPM_N(N)	((N) << MEM_SDREFCFG_TRPM)
+#define MEM_SDREFCFG_REF_N(N)	(N)
+#endif
+
+/***********************************************************************/
+
+/*
+ * Au1550 SDRAM Register Offsets
+ */
+
+/***********************************************************************/
+
+#if defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200)
+#define MEM_SDMODE0		0x0800
+#define MEM_SDMODE1		0x0808
+#define MEM_SDMODE2		0x0810
+#define MEM_SDADDR0		0x0820
+#define MEM_SDADDR1		0x0828
+#define MEM_SDADDR2		0x0830
+#define MEM_SDCONFIGA		0x0840
+#define MEM_SDCONFIGB		0x0848
+#define MEM_SDSTAT		0x0850
+#define MEM_SDERRADDR		0x0858
+#define MEM_SDSTRIDE0		0x0860
+#define MEM_SDSTRIDE1		0x0868
+#define MEM_SDSTRIDE2		0x0870
+#define MEM_SDWRMD0		0x0880
+#define MEM_SDWRMD1		0x0888
+#define MEM_SDWRMD2		0x0890
+#define MEM_SDPRECMD		0x08C0
+#define MEM_SDAUTOREF		0x08C8
+#define MEM_SDSREF		0x08D0
+#define MEM_SDSLEEP		MEM_SDSREF
+
+#endif
+
+/*
+ * Physical base addresses for integrated peripherals
+ */
+
+#ifdef CONFIG_SOC_AU1000
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define	DMA0_PHYS_ADDR		0x14002000
+#define	DMA1_PHYS_ADDR		0x14002100
+#define	DMA2_PHYS_ADDR		0x14002200
+#define	DMA3_PHYS_ADDR		0x14002300
+#define	DMA4_PHYS_ADDR		0x14002400
+#define	DMA5_PHYS_ADDR		0x14002500
+#define	DMA6_PHYS_ADDR		0x14002600
+#define	DMA7_PHYS_ADDR		0x14002700
+#define	IC0_PHYS_ADDR		0x10400000
+#define	IC1_PHYS_ADDR		0x11800000
+#define	AC97_PHYS_ADDR		0x10000000
+#define	USBH_PHYS_ADDR		0x10100000
+#define	USBD_PHYS_ADDR		0x10200000
+#define	IRDA_PHYS_ADDR		0x10300000
+#define	MAC0_PHYS_ADDR		0x10500000
+#define	MAC1_PHYS_ADDR		0x10510000
+#define	MACEN_PHYS_ADDR		0x10520000
+#define	MACDMA0_PHYS_ADDR	0x14004000
+#define	MACDMA1_PHYS_ADDR	0x14004200
+#define	I2S_PHYS_ADDR		0x11000000
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART1_PHYS_ADDR		0x11200000
+#define	UART2_PHYS_ADDR		0x11300000
+#define	UART3_PHYS_ADDR		0x11400000
+#define	SSI0_PHYS_ADDR		0x11600000
+#define	SSI1_PHYS_ADDR		0x11680000
+#define	SYS_PHYS_ADDR		0x11900000
+#define PCMCIA_IO_PHYS_ADDR	0xF00000000ULL
+#define PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL
+#define PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL
+#endif
+
+/********************************************************************/
+
+#ifdef CONFIG_SOC_AU1500
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define	DMA0_PHYS_ADDR		0x14002000
+#define	DMA1_PHYS_ADDR		0x14002100
+#define	DMA2_PHYS_ADDR		0x14002200
+#define	DMA3_PHYS_ADDR		0x14002300
+#define	DMA4_PHYS_ADDR		0x14002400
+#define	DMA5_PHYS_ADDR		0x14002500
+#define	DMA6_PHYS_ADDR		0x14002600
+#define	DMA7_PHYS_ADDR		0x14002700
+#define	IC0_PHYS_ADDR		0x10400000
+#define	IC1_PHYS_ADDR		0x11800000
+#define	AC97_PHYS_ADDR		0x10000000
+#define	USBH_PHYS_ADDR		0x10100000
+#define	USBD_PHYS_ADDR		0x10200000
+#define PCI_PHYS_ADDR		0x14005000
+#define	MAC0_PHYS_ADDR		0x11500000
+#define	MAC1_PHYS_ADDR		0x11510000
+#define	MACEN_PHYS_ADDR		0x11520000
+#define	MACDMA0_PHYS_ADDR	0x14004000
+#define	MACDMA1_PHYS_ADDR	0x14004200
+#define	I2S_PHYS_ADDR		0x11000000
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART3_PHYS_ADDR		0x11400000
+#define GPIO2_PHYS_ADDR		0x11700000
+#define	SYS_PHYS_ADDR		0x11900000
+#define PCI_MEM_PHYS_ADDR	0x400000000ULL
+#define PCI_IO_PHYS_ADDR	0x500000000ULL
+#define PCI_CONFIG0_PHYS_ADDR	0x600000000ULL
+#define PCI_CONFIG1_PHYS_ADDR	0x680000000ULL
+#define PCMCIA_IO_PHYS_ADDR	0xF00000000ULL
+#define PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL
+#define PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL
+#endif
+
+/********************************************************************/
+
+#ifdef CONFIG_SOC_AU1100
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define	DMA0_PHYS_ADDR		0x14002000
+#define	DMA1_PHYS_ADDR		0x14002100
+#define	DMA2_PHYS_ADDR		0x14002200
+#define	DMA3_PHYS_ADDR		0x14002300
+#define	DMA4_PHYS_ADDR		0x14002400
+#define	DMA5_PHYS_ADDR		0x14002500
+#define	DMA6_PHYS_ADDR		0x14002600
+#define	DMA7_PHYS_ADDR		0x14002700
+#define	IC0_PHYS_ADDR		0x10400000
+#define SD0_PHYS_ADDR		0x10600000
+#define SD1_PHYS_ADDR		0x10680000
+#define	IC1_PHYS_ADDR		0x11800000
+#define	AC97_PHYS_ADDR		0x10000000
+#define	USBH_PHYS_ADDR		0x10100000
+#define	USBD_PHYS_ADDR		0x10200000
+#define	IRDA_PHYS_ADDR		0x10300000
+#define	MAC0_PHYS_ADDR		0x10500000
+#define	MACEN_PHYS_ADDR		0x10520000
+#define	MACDMA0_PHYS_ADDR	0x14004000
+#define	MACDMA1_PHYS_ADDR	0x14004200
+#define	I2S_PHYS_ADDR		0x11000000
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART1_PHYS_ADDR		0x11200000
+#define	UART3_PHYS_ADDR		0x11400000
+#define	SSI0_PHYS_ADDR		0x11600000
+#define	SSI1_PHYS_ADDR		0x11680000
+#define GPIO2_PHYS_ADDR		0x11700000
+#define	SYS_PHYS_ADDR		0x11900000
+#define LCD_PHYS_ADDR		0x15000000
+#define PCMCIA_IO_PHYS_ADDR	0xF00000000ULL
+#define PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL
+#define PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL
+#endif
+
+/***********************************************************************/
+
+#ifdef CONFIG_SOC_AU1550
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define	IC0_PHYS_ADDR		0x10400000
+#define	IC1_PHYS_ADDR		0x11800000
+#define	USBH_PHYS_ADDR		0x14020000
+#define	USBD_PHYS_ADDR		0x10200000
+#define PCI_PHYS_ADDR		0x14005000
+#define	MAC0_PHYS_ADDR		0x10500000
+#define	MAC1_PHYS_ADDR		0x10510000
+#define	MACEN_PHYS_ADDR		0x10520000
+#define	MACDMA0_PHYS_ADDR	0x14004000
+#define	MACDMA1_PHYS_ADDR	0x14004200
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART1_PHYS_ADDR		0x11200000
+#define	UART3_PHYS_ADDR		0x11400000
+#define GPIO2_PHYS_ADDR		0x11700000
+#define	SYS_PHYS_ADDR		0x11900000
+#define	DDMA_PHYS_ADDR		0x14002000
+#define PE_PHYS_ADDR		0x14008000
+#define PSC0_PHYS_ADDR		0x11A00000
+#define PSC1_PHYS_ADDR		0x11B00000
+#define PSC2_PHYS_ADDR		0x10A00000
+#define PSC3_PHYS_ADDR		0x10B00000
+#define PCI_MEM_PHYS_ADDR	0x400000000ULL
+#define PCI_IO_PHYS_ADDR	0x500000000ULL
+#define PCI_CONFIG0_PHYS_ADDR	0x600000000ULL
+#define PCI_CONFIG1_PHYS_ADDR	0x680000000ULL
+#define PCMCIA_IO_PHYS_ADDR	0xF00000000ULL
+#define PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL
+#define PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL
+#endif
+
+/***********************************************************************/
+
+#ifdef CONFIG_SOC_AU1200
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define AES_PHYS_ADDR		0x10300000
+#define CIM_PHYS_ADDR		0x14004000
+#define	IC0_PHYS_ADDR		0x10400000
+#define	IC1_PHYS_ADDR		0x11800000
+#define USBM_PHYS_ADDR		0x14020000
+#define	USBH_PHYS_ADDR		0x14020100
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART1_PHYS_ADDR		0x11200000
+#define GPIO2_PHYS_ADDR		0x11700000
+#define	SYS_PHYS_ADDR		0x11900000
+#define	DDMA_PHYS_ADDR		0x14002000
+#define PSC0_PHYS_ADDR	 	0x11A00000
+#define PSC1_PHYS_ADDR	 	0x11B00000
+#define SD0_PHYS_ADDR		0x10600000
+#define SD1_PHYS_ADDR		0x10680000
+#define LCD_PHYS_ADDR		0x15000000
+#define SWCNT_PHYS_ADDR		0x1110010C
+#define MAEFE_PHYS_ADDR		0x14012000
+#define MAEBE_PHYS_ADDR		0x14010000
+#define PCMCIA_IO_PHYS_ADDR	0xF00000000ULL
+#define PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL
+#define PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL
+#endif
+
+/* Static Bus Controller */
+#define MEM_STCFG0		0xB4001000
+#define MEM_STTIME0		0xB4001004
+#define MEM_STADDR0		0xB4001008
+
+#define MEM_STCFG1		0xB4001010
+#define MEM_STTIME1		0xB4001014
+#define MEM_STADDR1		0xB4001018
+
+#define MEM_STCFG2		0xB4001020
+#define MEM_STTIME2		0xB4001024
+#define MEM_STADDR2		0xB4001028
+
+#define MEM_STCFG3		0xB4001030
+#define MEM_STTIME3		0xB4001034
+#define MEM_STADDR3		0xB4001038
+
+#if defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200)
+#define MEM_STNDCTL		0xB4001100
+#define MEM_STSTAT		0xB4001104
+
+#define MEM_STNAND_CMD		0x0
+#define MEM_STNAND_ADDR 	0x4
+#define MEM_STNAND_DATA 	0x20
+#endif
+
+/* Interrupt Controller 0 */
+#define IC0_CFG0RD		0xB0400040
+#define IC0_CFG0SET		0xB0400040
+#define IC0_CFG0CLR		0xB0400044
+
+#define IC0_CFG1RD		0xB0400048
+#define IC0_CFG1SET		0xB0400048
+#define IC0_CFG1CLR		0xB040004C
+
+#define IC0_CFG2RD		0xB0400050
+#define IC0_CFG2SET		0xB0400050
+#define IC0_CFG2CLR		0xB0400054
+
+#define IC0_REQ0INT		0xB0400054
+#define IC0_SRCRD		0xB0400058
+#define IC0_SRCSET		0xB0400058
+#define IC0_SRCCLR		0xB040005C
+#define IC0_REQ1INT		0xB040005C
+
+#define IC0_ASSIGNRD		0xB0400060
+#define IC0_ASSIGNSET		0xB0400060
+#define IC0_ASSIGNCLR		0xB0400064
+
+#define IC0_WAKERD		0xB0400068
+#define IC0_WAKESET		0xB0400068
+#define IC0_WAKECLR		0xB040006C
+
+#define IC0_MASKRD		0xB0400070
+#define IC0_MASKSET		0xB0400070
+#define IC0_MASKCLR		0xB0400074
+
+#define IC0_RISINGRD		0xB0400078
+#define IC0_RISINGCLR		0xB0400078
+#define IC0_FALLINGRD		0xB040007C
+#define IC0_FALLINGCLR		0xB040007C
+
+#define IC0_TESTBIT		0xB0400080
+
+/* Interrupt Controller 1 */
+#define IC1_CFG0RD		0xB1800040
+#define IC1_CFG0SET		0xB1800040
+#define IC1_CFG0CLR		0xB1800044
+
+#define IC1_CFG1RD		0xB1800048
+#define IC1_CFG1SET		0xB1800048
+#define IC1_CFG1CLR		0xB180004C
+
+#define IC1_CFG2RD		0xB1800050
+#define IC1_CFG2SET		0xB1800050
+#define IC1_CFG2CLR		0xB1800054
+
+#define IC1_REQ0INT		0xB1800054
+#define IC1_SRCRD		0xB1800058
+#define IC1_SRCSET		0xB1800058
+#define IC1_SRCCLR		0xB180005C
+#define IC1_REQ1INT		0xB180005C
+
+#define IC1_ASSIGNRD            0xB1800060
+#define IC1_ASSIGNSET           0xB1800060
+#define IC1_ASSIGNCLR           0xB1800064
+
+#define IC1_WAKERD		0xB1800068
+#define IC1_WAKESET		0xB1800068
+#define IC1_WAKECLR		0xB180006C
+
+#define IC1_MASKRD		0xB1800070
+#define IC1_MASKSET		0xB1800070
+#define IC1_MASKCLR		0xB1800074
+
+#define IC1_RISINGRD		0xB1800078
+#define IC1_RISINGCLR		0xB1800078
+#define IC1_FALLINGRD		0xB180007C
+#define IC1_FALLINGCLR		0xB180007C
+
+#define IC1_TESTBIT		0xB1800080
+
+/* Interrupt Configuration Modes */
+#define INTC_INT_DISABLED		0x0
+#define INTC_INT_RISE_EDGE		0x1
+#define INTC_INT_FALL_EDGE		0x2
+#define INTC_INT_RISE_AND_FALL_EDGE	0x3
+#define INTC_INT_HIGH_LEVEL		0x5
+#define INTC_INT_LOW_LEVEL		0x6
+#define INTC_INT_HIGH_AND_LOW_LEVEL	0x7
+
+/* Interrupt Numbers */
+/* Au1000 */
+#ifdef CONFIG_SOC_AU1000
+enum soc_au1000_ints {
+	AU1000_FIRST_INT	= MIPS_CPU_IRQ_BASE + 8,
+	AU1000_UART0_INT	= AU1000_FIRST_INT,
+	AU1000_UART1_INT,				/* au1000 */
+	AU1000_UART2_INT,				/* au1000 */
+	AU1000_UART3_INT,
+	AU1000_SSI0_INT,				/* au1000 */
+	AU1000_SSI1_INT,				/* au1000 */
+	AU1000_DMA_INT_BASE,
+
+	AU1000_TOY_INT		= AU1000_FIRST_INT + 14,
+	AU1000_TOY_MATCH0_INT,
+	AU1000_TOY_MATCH1_INT,
+	AU1000_TOY_MATCH2_INT,
+	AU1000_RTC_INT,
+	AU1000_RTC_MATCH0_INT,
+	AU1000_RTC_MATCH1_INT,
+	AU1000_RTC_MATCH2_INT,
+	AU1000_IRDA_TX_INT,				/* au1000 */
+	AU1000_IRDA_RX_INT,				/* au1000 */
+	AU1000_USB_DEV_REQ_INT,
+	AU1000_USB_DEV_SUS_INT,
+	AU1000_USB_HOST_INT,
+	AU1000_ACSYNC_INT,
+	AU1000_MAC0_DMA_INT,
+	AU1000_MAC1_DMA_INT,
+	AU1000_I2S_UO_INT,				/* au1000 */
+	AU1000_AC97C_INT,
+	AU1000_GPIO_0,
+	AU1000_GPIO_1,
+	AU1000_GPIO_2,
+	AU1000_GPIO_3,
+	AU1000_GPIO_4,
+	AU1000_GPIO_5,
+	AU1000_GPIO_6,
+	AU1000_GPIO_7,
+	AU1000_GPIO_8,
+	AU1000_GPIO_9,
+	AU1000_GPIO_10,
+	AU1000_GPIO_11,
+	AU1000_GPIO_12,
+	AU1000_GPIO_13,
+	AU1000_GPIO_14,
+	AU1000_GPIO_15,
+	AU1000_GPIO_16,
+	AU1000_GPIO_17,
+	AU1000_GPIO_18,
+	AU1000_GPIO_19,
+	AU1000_GPIO_20,
+	AU1000_GPIO_21,
+	AU1000_GPIO_22,
+	AU1000_GPIO_23,
+	AU1000_GPIO_24,
+	AU1000_GPIO_25,
+	AU1000_GPIO_26,
+	AU1000_GPIO_27,
+	AU1000_GPIO_28,
+	AU1000_GPIO_29,
+	AU1000_GPIO_30,
+	AU1000_GPIO_31,
+};
+
+#define UART0_ADDR		0xB1100000
+#define UART1_ADDR		0xB1200000
+#define UART2_ADDR		0xB1300000
+#define UART3_ADDR		0xB1400000
+
+#define USB_OHCI_BASE		0x10100000	/* phys addr for ioremap */
+#define USB_HOST_CONFIG 	0xB017FFFC
+
+#define AU1000_ETH0_BASE	0xB0500000
+#define AU1000_ETH1_BASE	0xB0510000
+#define AU1000_MAC0_ENABLE	0xB0520000
+#define AU1000_MAC1_ENABLE	0xB0520004
+#define NUM_ETH_INTERFACES 2
+#endif /* CONFIG_SOC_AU1000 */
+
+/* Au1500 */
+#ifdef CONFIG_SOC_AU1500
+enum soc_au1500_ints {
+	AU1500_FIRST_INT	= MIPS_CPU_IRQ_BASE + 8,
+	AU1500_UART0_INT	= AU1500_FIRST_INT,
+	AU1000_PCI_INTA,				/* au1500 */
+	AU1000_PCI_INTB,				/* au1500 */
+	AU1500_UART3_INT,
+	AU1000_PCI_INTC,				/* au1500 */
+	AU1000_PCI_INTD,				/* au1500 */
+	AU1000_DMA_INT_BASE,
+
+	AU1000_TOY_INT		= AU1500_FIRST_INT + 14,
+	AU1000_TOY_MATCH0_INT,
+	AU1000_TOY_MATCH1_INT,
+	AU1000_TOY_MATCH2_INT,
+	AU1000_RTC_INT,
+	AU1000_RTC_MATCH0_INT,
+	AU1000_RTC_MATCH1_INT,
+	AU1000_RTC_MATCH2_INT,
+	AU1500_PCI_ERR_INT,
+	AU1500_RESERVED_INT,
+	AU1000_USB_DEV_REQ_INT,
+	AU1000_USB_DEV_SUS_INT,
+	AU1000_USB_HOST_INT,
+	AU1000_ACSYNC_INT,
+	AU1500_MAC0_DMA_INT,
+	AU1500_MAC1_DMA_INT,
+	AU1000_AC97C_INT	= AU1500_FIRST_INT + 31,
+	AU1000_GPIO_0,
+	AU1000_GPIO_1,
+	AU1000_GPIO_2,
+	AU1000_GPIO_3,
+	AU1000_GPIO_4,
+	AU1000_GPIO_5,
+	AU1000_GPIO_6,
+	AU1000_GPIO_7,
+	AU1000_GPIO_8,
+	AU1000_GPIO_9,
+	AU1000_GPIO_10,
+	AU1000_GPIO_11,
+	AU1000_GPIO_12,
+	AU1000_GPIO_13,
+	AU1000_GPIO_14,
+	AU1000_GPIO_15,
+	AU1500_GPIO_200,
+	AU1500_GPIO_201,
+	AU1500_GPIO_202,
+	AU1500_GPIO_203,
+	AU1500_GPIO_20,
+	AU1500_GPIO_204,
+	AU1500_GPIO_205,
+	AU1500_GPIO_23,
+	AU1500_GPIO_24,
+	AU1500_GPIO_25,
+	AU1500_GPIO_26,
+	AU1500_GPIO_27,
+	AU1500_GPIO_28,
+	AU1500_GPIO_206,
+	AU1500_GPIO_207,
+	AU1500_GPIO_208_215,
+};
+
+/* shortcuts */
+#define INTA AU1000_PCI_INTA
+#define INTB AU1000_PCI_INTB
+#define INTC AU1000_PCI_INTC
+#define INTD AU1000_PCI_INTD
+
+#define UART0_ADDR		0xB1100000
+#define UART3_ADDR		0xB1400000
+
+#define USB_OHCI_BASE		0x10100000	/* phys addr for ioremap */
+#define USB_HOST_CONFIG 	0xB017fffc
+
+#define AU1500_ETH0_BASE	0xB1500000
+#define AU1500_ETH1_BASE	0xB1510000
+#define AU1500_MAC0_ENABLE	0xB1520000
+#define AU1500_MAC1_ENABLE	0xB1520004
+#define NUM_ETH_INTERFACES 2
+#endif /* CONFIG_SOC_AU1500 */
+
+/* Au1100 */
+#ifdef CONFIG_SOC_AU1100
+enum soc_au1100_ints {
+	AU1100_FIRST_INT	= MIPS_CPU_IRQ_BASE + 8,
+	AU1100_UART0_INT,
+	AU1100_UART1_INT,
+	AU1100_SD_INT,
+	AU1100_UART3_INT,
+	AU1000_SSI0_INT,
+	AU1000_SSI1_INT,
+	AU1000_DMA_INT_BASE,
+
+	AU1000_TOY_INT		= AU1100_FIRST_INT + 14,
+	AU1000_TOY_MATCH0_INT,
+	AU1000_TOY_MATCH1_INT,
+	AU1000_TOY_MATCH2_INT,
+	AU1000_RTC_INT,
+	AU1000_RTC_MATCH0_INT,
+	AU1000_RTC_MATCH1_INT,
+	AU1000_RTC_MATCH2_INT,
+	AU1000_IRDA_TX_INT,
+	AU1000_IRDA_RX_INT,
+	AU1000_USB_DEV_REQ_INT,
+	AU1000_USB_DEV_SUS_INT,
+	AU1000_USB_HOST_INT,
+	AU1000_ACSYNC_INT,
+	AU1100_MAC0_DMA_INT,
+	AU1100_GPIO_208_215,
+	AU1100_LCD_INT,
+	AU1000_AC97C_INT,
+	AU1000_GPIO_0,
+	AU1000_GPIO_1,
+	AU1000_GPIO_2,
+	AU1000_GPIO_3,
+	AU1000_GPIO_4,
+	AU1000_GPIO_5,
+	AU1000_GPIO_6,
+	AU1000_GPIO_7,
+	AU1000_GPIO_8,
+	AU1000_GPIO_9,
+	AU1000_GPIO_10,
+	AU1000_GPIO_11,
+	AU1000_GPIO_12,
+	AU1000_GPIO_13,
+	AU1000_GPIO_14,
+	AU1000_GPIO_15,
+	AU1000_GPIO_16,
+	AU1000_GPIO_17,
+	AU1000_GPIO_18,
+	AU1000_GPIO_19,
+	AU1000_GPIO_20,
+	AU1000_GPIO_21,
+	AU1000_GPIO_22,
+	AU1000_GPIO_23,
+	AU1000_GPIO_24,
+	AU1000_GPIO_25,
+	AU1000_GPIO_26,
+	AU1000_GPIO_27,
+	AU1000_GPIO_28,
+	AU1000_GPIO_29,
+	AU1000_GPIO_30,
+	AU1000_GPIO_31,
+};
+
+#define UART0_ADDR		0xB1100000
+#define UART1_ADDR		0xB1200000
+#define UART3_ADDR		0xB1400000
+
+#define USB_OHCI_BASE		0x10100000	/* phys addr for ioremap */
+#define USB_HOST_CONFIG 	0xB017FFFC
+
+#define AU1100_ETH0_BASE	0xB0500000
+#define AU1100_MAC0_ENABLE	0xB0520000
+#define NUM_ETH_INTERFACES 1
+#endif /* CONFIG_SOC_AU1100 */
+
+#ifdef CONFIG_SOC_AU1550
+enum soc_au1550_ints {
+	AU1550_FIRST_INT	= MIPS_CPU_IRQ_BASE + 8,
+	AU1550_UART0_INT	= AU1550_FIRST_INT,
+	AU1550_PCI_INTA,
+	AU1550_PCI_INTB,
+	AU1550_DDMA_INT,
+	AU1550_CRYPTO_INT,
+	AU1550_PCI_INTC,
+	AU1550_PCI_INTD,
+	AU1550_PCI_RST_INT,
+	AU1550_UART1_INT,
+	AU1550_UART3_INT,
+	AU1550_PSC0_INT,
+	AU1550_PSC1_INT,
+	AU1550_PSC2_INT,
+	AU1550_PSC3_INT,
+	AU1000_TOY_INT,
+	AU1000_TOY_MATCH0_INT,
+	AU1000_TOY_MATCH1_INT,
+	AU1000_TOY_MATCH2_INT,
+	AU1000_RTC_INT,
+	AU1000_RTC_MATCH0_INT,
+	AU1000_RTC_MATCH1_INT,
+	AU1000_RTC_MATCH2_INT,
+
+	AU1550_NAND_INT			= AU1550_FIRST_INT + 23,
+	AU1550_USB_DEV_REQ_INT,
+	AU1000_USB_DEV_REQ_INT		= AU1550_USB_DEV_REQ_INT,
+	AU1550_USB_DEV_SUS_INT,
+	AU1000_USB_DEV_SUS_INT		= AU1550_USB_DEV_SUS_INT,
+	AU1550_USB_HOST_INT,
+	AU1000_USB_HOST_INT		= AU1550_USB_HOST_INT,
+	AU1550_MAC0_DMA_INT,
+	AU1550_MAC1_DMA_INT,
+	AU1000_GPIO_0			= AU1550_FIRST_INT + 32,
+	AU1000_GPIO_1,
+	AU1000_GPIO_2,
+	AU1000_GPIO_3,
+	AU1000_GPIO_4,
+	AU1000_GPIO_5,
+	AU1000_GPIO_6,
+	AU1000_GPIO_7,
+	AU1000_GPIO_8,
+	AU1000_GPIO_9,
+	AU1000_GPIO_10,
+	AU1000_GPIO_11,
+	AU1000_GPIO_12,
+	AU1000_GPIO_13,
+	AU1000_GPIO_14,
+	AU1000_GPIO_15,
+	AU1550_GPIO_200,
+	AU1500_GPIO_201_205,			/* Logical or of GPIO201:205 */
+	AU1500_GPIO_16,
+	AU1500_GPIO_17,
+	AU1500_GPIO_20,
+	AU1500_GPIO_21,
+	AU1500_GPIO_22,
+	AU1500_GPIO_23,
+	AU1500_GPIO_24,
+	AU1500_GPIO_25,
+	AU1500_GPIO_26,
+	AU1500_GPIO_27,
+	AU1500_GPIO_28,
+	AU1500_GPIO_206,
+	AU1500_GPIO_207,
+	AU1500_GPIO_208_218,			/* Logical or of GPIO208:218 */
+};
+
+/* shortcuts */
+#define INTA AU1550_PCI_INTA
+#define INTB AU1550_PCI_INTB
+#define INTC AU1550_PCI_INTC
+#define INTD AU1550_PCI_INTD
+
+#define UART0_ADDR		0xB1100000
+#define UART1_ADDR		0xB1200000
+#define UART3_ADDR		0xB1400000
+
+#define USB_OHCI_BASE		0x14020000	/* phys addr for ioremap */
+#define USB_OHCI_LEN		0x00060000
+#define USB_HOST_CONFIG 	0xB4027ffc
+
+#define AU1550_ETH0_BASE	0xB0500000
+#define AU1550_ETH1_BASE	0xB0510000
+#define AU1550_MAC0_ENABLE	0xB0520000
+#define AU1550_MAC1_ENABLE	0xB0520004
+#define NUM_ETH_INTERFACES 2
+#endif /* CONFIG_SOC_AU1550 */
+
+#ifdef CONFIG_SOC_AU1200
+enum soc_au1200_ints {
+	AU1200_FIRST_INT	= MIPS_CPU_IRQ_BASE + 8,
+	AU1200_UART0_INT	= AU1200_FIRST_INT,
+	AU1200_SWT_INT,
+	AU1200_SD_INT,
+	AU1200_DDMA_INT,
+	AU1200_MAE_BE_INT,
+	AU1200_GPIO_200,
+	AU1200_GPIO_201,
+	AU1200_GPIO_202,
+	AU1200_UART1_INT,
+	AU1200_MAE_FE_INT,
+	AU1200_PSC0_INT,
+	AU1200_PSC1_INT,
+	AU1200_AES_INT,
+	AU1200_CAMERA_INT,
+	AU1000_TOY_INT,
+	AU1000_TOY_MATCH0_INT,
+	AU1000_TOY_MATCH1_INT,
+	AU1000_TOY_MATCH2_INT,
+	AU1000_RTC_INT,
+	AU1000_RTC_MATCH0_INT,
+	AU1000_RTC_MATCH1_INT,
+	AU1000_RTC_MATCH2_INT,
+
+	AU1200_NAND_INT		= AU1200_FIRST_INT + 23,
+	AU1200_GPIO_204,
+	AU1200_GPIO_205,
+	AU1200_GPIO_206,
+	AU1200_GPIO_207,
+	AU1200_GPIO_208_215,			/* Logical OR of 208:215 */
+	AU1200_USB_INT,
+	AU1000_USB_HOST_INT	= AU1200_USB_INT,
+	AU1200_LCD_INT,
+	AU1200_MAE_BOTH_INT,
+	AU1000_GPIO_0,
+	AU1000_GPIO_1,
+	AU1000_GPIO_2,
+	AU1000_GPIO_3,
+	AU1000_GPIO_4,
+	AU1000_GPIO_5,
+	AU1000_GPIO_6,
+	AU1000_GPIO_7,
+	AU1000_GPIO_8,
+	AU1000_GPIO_9,
+	AU1000_GPIO_10,
+	AU1000_GPIO_11,
+	AU1000_GPIO_12,
+	AU1000_GPIO_13,
+	AU1000_GPIO_14,
+	AU1000_GPIO_15,
+	AU1000_GPIO_16,
+	AU1000_GPIO_17,
+	AU1000_GPIO_18,
+	AU1000_GPIO_19,
+	AU1000_GPIO_20,
+	AU1000_GPIO_21,
+	AU1000_GPIO_22,
+	AU1000_GPIO_23,
+	AU1000_GPIO_24,
+	AU1000_GPIO_25,
+	AU1000_GPIO_26,
+	AU1000_GPIO_27,
+	AU1000_GPIO_28,
+	AU1000_GPIO_29,
+	AU1000_GPIO_30,
+	AU1000_GPIO_31,
+};
+
+#define UART0_ADDR		0xB1100000
+#define UART1_ADDR		0xB1200000
+
+#define USB_UOC_BASE		0x14020020
+#define USB_UOC_LEN		0x20
+#define USB_OHCI_BASE		0x14020100
+#define USB_OHCI_LEN		0x100
+#define USB_EHCI_BASE		0x14020200
+#define USB_EHCI_LEN		0x100
+#define USB_UDC_BASE		0x14022000
+#define USB_UDC_LEN		0x2000
+#define USB_MSR_BASE		0xB4020000
+#define USB_MSR_MCFG		4
+#define USBMSRMCFG_OMEMEN	0
+#define USBMSRMCFG_OBMEN	1
+#define USBMSRMCFG_EMEMEN	2
+#define USBMSRMCFG_EBMEN	3
+#define USBMSRMCFG_DMEMEN	4
+#define USBMSRMCFG_DBMEN	5
+#define USBMSRMCFG_GMEMEN	6
+#define USBMSRMCFG_OHCCLKEN	16
+#define USBMSRMCFG_EHCCLKEN	17
+#define USBMSRMCFG_UDCCLKEN	18
+#define USBMSRMCFG_PHYPLLEN	19
+#define USBMSRMCFG_RDCOMB	30
+#define USBMSRMCFG_PFEN 	31
+
+#endif /* CONFIG_SOC_AU1200 */
+
+#define AU1000_INTC0_INT_BASE	(MIPS_CPU_IRQ_BASE + 8)
+#define AU1000_INTC0_INT_LAST	(AU1000_INTC0_INT_BASE + 31)
+#define AU1000_INTC1_INT_BASE	(AU1000_INTC0_INT_BASE + 32)
+#define AU1000_INTC1_INT_LAST	(AU1000_INTC1_INT_BASE + 31)
+
+#define AU1000_MAX_INTR 	AU1000_INTC1_INT_LAST
+#define INTX			0xFF			/* not valid */
+
+/* Programmable Counters 0 and 1 */
+#define SYS_BASE		0xB1900000
+#define SYS_COUNTER_CNTRL	(SYS_BASE + 0x14)
+#  define SYS_CNTRL_E1S 	(1 << 23)
+#  define SYS_CNTRL_T1S 	(1 << 20)
+#  define SYS_CNTRL_M21 	(1 << 19)
+#  define SYS_CNTRL_M11 	(1 << 18)
+#  define SYS_CNTRL_M01 	(1 << 17)
+#  define SYS_CNTRL_C1S 	(1 << 16)
+#  define SYS_CNTRL_BP		(1 << 14)
+#  define SYS_CNTRL_EN1 	(1 << 13)
+#  define SYS_CNTRL_BT1 	(1 << 12)
+#  define SYS_CNTRL_EN0 	(1 << 11)
+#  define SYS_CNTRL_BT0 	(1 << 10)
+#  define SYS_CNTRL_E0		(1 << 8)
+#  define SYS_CNTRL_E0S 	(1 << 7)
+#  define SYS_CNTRL_32S 	(1 << 5)
+#  define SYS_CNTRL_T0S 	(1 << 4)
+#  define SYS_CNTRL_M20 	(1 << 3)
+#  define SYS_CNTRL_M10 	(1 << 2)
+#  define SYS_CNTRL_M00 	(1 << 1)
+#  define SYS_CNTRL_C0S 	(1 << 0)
+
+/* Programmable Counter 0 Registers */
+#define SYS_TOYTRIM		(SYS_BASE + 0)
+#define SYS_TOYWRITE		(SYS_BASE + 4)
+#define SYS_TOYMATCH0		(SYS_BASE + 8)
+#define SYS_TOYMATCH1		(SYS_BASE + 0xC)
+#define SYS_TOYMATCH2		(SYS_BASE + 0x10)
+#define SYS_TOYREAD		(SYS_BASE + 0x40)
+
+/* Programmable Counter 1 Registers */
+#define SYS_RTCTRIM		(SYS_BASE + 0x44)
+#define SYS_RTCWRITE		(SYS_BASE + 0x48)
+#define SYS_RTCMATCH0		(SYS_BASE + 0x4C)
+#define SYS_RTCMATCH1		(SYS_BASE + 0x50)
+#define SYS_RTCMATCH2		(SYS_BASE + 0x54)
+#define SYS_RTCREAD		(SYS_BASE + 0x58)
+
+/* I2S Controller */
+#define I2S_DATA		0xB1000000
+#  define I2S_DATA_MASK 	0xffffff
+#define I2S_CONFIG		0xB1000004
+#  define I2S_CONFIG_XU 	(1 << 25)
+#  define I2S_CONFIG_XO 	(1 << 24)
+#  define I2S_CONFIG_RU 	(1 << 23)
+#  define I2S_CONFIG_RO 	(1 << 22)
+#  define I2S_CONFIG_TR 	(1 << 21)
+#  define I2S_CONFIG_TE 	(1 << 20)
+#  define I2S_CONFIG_TF 	(1 << 19)
+#  define I2S_CONFIG_RR 	(1 << 18)
+#  define I2S_CONFIG_RE 	(1 << 17)
+#  define I2S_CONFIG_RF 	(1 << 16)
+#  define I2S_CONFIG_PD 	(1 << 11)
+#  define I2S_CONFIG_LB 	(1 << 10)
+#  define I2S_CONFIG_IC 	(1 << 9)
+#  define I2S_CONFIG_FM_BIT	7
+#  define I2S_CONFIG_FM_MASK	(0x3 << I2S_CONFIG_FM_BIT)
+#    define I2S_CONFIG_FM_I2S	(0x0 << I2S_CONFIG_FM_BIT)
+#    define I2S_CONFIG_FM_LJ	(0x1 << I2S_CONFIG_FM_BIT)
+#    define I2S_CONFIG_FM_RJ	(0x2 << I2S_CONFIG_FM_BIT)
+#  define I2S_CONFIG_TN 	(1 << 6)
+#  define I2S_CONFIG_RN 	(1 << 5)
+#  define I2S_CONFIG_SZ_BIT	0
+#  define I2S_CONFIG_SZ_MASK	(0x1F << I2S_CONFIG_SZ_BIT)
+
+#define I2S_CONTROL		0xB1000008
+#  define I2S_CONTROL_D 	(1 << 1)
+#  define I2S_CONTROL_CE	(1 << 0)
+
+/* USB Host Controller */
+#ifndef USB_OHCI_LEN
+#define USB_OHCI_LEN		0x00100000
+#endif
+
+#ifndef CONFIG_SOC_AU1200
+
+/* USB Device Controller */
+#define USBD_EP0RD		0xB0200000
+#define USBD_EP0WR		0xB0200004
+#define USBD_EP2WR		0xB0200008
+#define USBD_EP3WR		0xB020000C
+#define USBD_EP4RD		0xB0200010
+#define USBD_EP5RD		0xB0200014
+#define USBD_INTEN		0xB0200018
+#define USBD_INTSTAT		0xB020001C
+#  define USBDEV_INT_SOF	(1 << 12)
+#  define USBDEV_INT_HF_BIT	6
+#  define USBDEV_INT_HF_MASK	(0x3f << USBDEV_INT_HF_BIT)
+#  define USBDEV_INT_CMPLT_BIT	0
+#  define USBDEV_INT_CMPLT_MASK (0x3f << USBDEV_INT_CMPLT_BIT)
+#define USBD_CONFIG		0xB0200020
+#define USBD_EP0CS		0xB0200024
+#define USBD_EP2CS		0xB0200028
+#define USBD_EP3CS		0xB020002C
+#define USBD_EP4CS		0xB0200030
+#define USBD_EP5CS		0xB0200034
+#  define USBDEV_CS_SU		(1 << 14)
+#  define USBDEV_CS_NAK 	(1 << 13)
+#  define USBDEV_CS_ACK 	(1 << 12)
+#  define USBDEV_CS_BUSY	(1 << 11)
+#  define USBDEV_CS_TSIZE_BIT	1
+#  define USBDEV_CS_TSIZE_MASK	(0x3ff << USBDEV_CS_TSIZE_BIT)
+#  define USBDEV_CS_STALL	(1 << 0)
+#define USBD_EP0RDSTAT		0xB0200040
+#define USBD_EP0WRSTAT		0xB0200044
+#define USBD_EP2WRSTAT		0xB0200048
+#define USBD_EP3WRSTAT		0xB020004C
+#define USBD_EP4RDSTAT		0xB0200050
+#define USBD_EP5RDSTAT		0xB0200054
+#  define USBDEV_FSTAT_FLUSH	(1 << 6)
+#  define USBDEV_FSTAT_UF	(1 << 5)
+#  define USBDEV_FSTAT_OF	(1 << 4)
+#  define USBDEV_FSTAT_FCNT_BIT 0
+#  define USBDEV_FSTAT_FCNT_MASK (0x0f << USBDEV_FSTAT_FCNT_BIT)
+#define USBD_ENABLE		0xB0200058
+#  define USBDEV_ENABLE 	(1 << 1)
+#  define USBDEV_CE		(1 << 0)
+
+#endif /* !CONFIG_SOC_AU1200 */
+
+/* Ethernet Controllers  */
+
+/* 4 byte offsets from AU1000_ETH_BASE */
+#define MAC_CONTROL		0x0
+#  define MAC_RX_ENABLE 	(1 << 2)
+#  define MAC_TX_ENABLE 	(1 << 3)
+#  define MAC_DEF_CHECK 	(1 << 5)
+#  define MAC_SET_BL(X) 	(((X) & 0x3) << 6)
+#  define MAC_AUTO_PAD		(1 << 8)
+#  define MAC_DISABLE_RETRY	(1 << 10)
+#  define MAC_DISABLE_BCAST	(1 << 11)
+#  define MAC_LATE_COL		(1 << 12)
+#  define MAC_HASH_MODE 	(1 << 13)
+#  define MAC_HASH_ONLY 	(1 << 15)
+#  define MAC_PASS_ALL		(1 << 16)
+#  define MAC_INVERSE_FILTER	(1 << 17)
+#  define MAC_PROMISCUOUS	(1 << 18)
+#  define MAC_PASS_ALL_MULTI	(1 << 19)
+#  define MAC_FULL_DUPLEX	(1 << 20)
+#  define MAC_NORMAL_MODE	0
+#  define MAC_INT_LOOPBACK	(1 << 21)
+#  define MAC_EXT_LOOPBACK	(1 << 22)
+#  define MAC_DISABLE_RX_OWN	(1 << 23)
+#  define MAC_BIG_ENDIAN	(1 << 30)
+#  define MAC_RX_ALL		(1 << 31)
+#define MAC_ADDRESS_HIGH	0x4
+#define MAC_ADDRESS_LOW		0x8
+#define MAC_MCAST_HIGH		0xC
+#define MAC_MCAST_LOW		0x10
+#define MAC_MII_CNTRL		0x14
+#  define MAC_MII_BUSY		(1 << 0)
+#  define MAC_MII_READ		0
+#  define MAC_MII_WRITE		(1 << 1)
+#  define MAC_SET_MII_SELECT_REG(X) (((X) & 0x1f) << 6)
+#  define MAC_SET_MII_SELECT_PHY(X) (((X) & 0x1f) << 11)
+#define MAC_MII_DATA		0x18
+#define MAC_FLOW_CNTRL		0x1C
+#  define MAC_FLOW_CNTRL_BUSY	(1 << 0)
+#  define MAC_FLOW_CNTRL_ENABLE (1 << 1)
+#  define MAC_PASS_CONTROL	(1 << 2)
+#  define MAC_SET_PAUSE(X)	(((X) & 0xffff) << 16)
+#define MAC_VLAN1_TAG		0x20
+#define MAC_VLAN2_TAG		0x24
+
+/* Ethernet Controller Enable */
+
+#  define MAC_EN_CLOCK_ENABLE	(1 << 0)
+#  define MAC_EN_RESET0		(1 << 1)
+#  define MAC_EN_TOSS		(0 << 2)
+#  define MAC_EN_CACHEABLE	(1 << 3)
+#  define MAC_EN_RESET1 	(1 << 4)
+#  define MAC_EN_RESET2 	(1 << 5)
+#  define MAC_DMA_RESET 	(1 << 6)
+
+/* Ethernet Controller DMA Channels */
+
+#define MAC0_TX_DMA_ADDR	0xB4004000
+#define MAC1_TX_DMA_ADDR	0xB4004200
+/* offsets from MAC_TX_RING_ADDR address */
+#define MAC_TX_BUFF0_STATUS	0x0
+#  define TX_FRAME_ABORTED	(1 << 0)
+#  define TX_JAB_TIMEOUT	(1 << 1)
+#  define TX_NO_CARRIER 	(1 << 2)
+#  define TX_LOSS_CARRIER	(1 << 3)
+#  define TX_EXC_DEF		(1 << 4)
+#  define TX_LATE_COLL_ABORT	(1 << 5)
+#  define TX_EXC_COLL		(1 << 6)
+#  define TX_UNDERRUN		(1 << 7)
+#  define TX_DEFERRED		(1 << 8)
+#  define TX_LATE_COLL		(1 << 9)
+#  define TX_COLL_CNT_MASK	(0xF << 10)
+#  define TX_PKT_RETRY		(1 << 31)
+#define MAC_TX_BUFF0_ADDR	0x4
+#  define TX_DMA_ENABLE 	(1 << 0)
+#  define TX_T_DONE		(1 << 1)
+#  define TX_GET_DMA_BUFFER(X)	(((X) >> 2) & 0x3)
+#define MAC_TX_BUFF0_LEN	0x8
+#define MAC_TX_BUFF1_STATUS	0x10
+#define MAC_TX_BUFF1_ADDR	0x14
+#define MAC_TX_BUFF1_LEN	0x18
+#define MAC_TX_BUFF2_STATUS	0x20
+#define MAC_TX_BUFF2_ADDR	0x24
+#define MAC_TX_BUFF2_LEN	0x28
+#define MAC_TX_BUFF3_STATUS	0x30
+#define MAC_TX_BUFF3_ADDR	0x34
+#define MAC_TX_BUFF3_LEN	0x38
+
+#define MAC0_RX_DMA_ADDR	0xB4004100
+#define MAC1_RX_DMA_ADDR	0xB4004300
+/* offsets from MAC_RX_RING_ADDR */
+#define MAC_RX_BUFF0_STATUS	0x0
+#  define RX_FRAME_LEN_MASK	0x3fff
+#  define RX_WDOG_TIMER 	(1 << 14)
+#  define RX_RUNT		(1 << 15)
+#  define RX_OVERLEN		(1 << 16)
+#  define RX_COLL		(1 << 17)
+#  define RX_ETHER		(1 << 18)
+#  define RX_MII_ERROR		(1 << 19)
+#  define RX_DRIBBLING		(1 << 20)
+#  define RX_CRC_ERROR		(1 << 21)
+#  define RX_VLAN1		(1 << 22)
+#  define RX_VLAN2		(1 << 23)
+#  define RX_LEN_ERROR		(1 << 24)
+#  define RX_CNTRL_FRAME	(1 << 25)
+#  define RX_U_CNTRL_FRAME	(1 << 26)
+#  define RX_MCAST_FRAME	(1 << 27)
+#  define RX_BCAST_FRAME	(1 << 28)
+#  define RX_FILTER_FAIL	(1 << 29)
+#  define RX_PACKET_FILTER	(1 << 30)
+#  define RX_MISSED_FRAME	(1 << 31)
+
+#  define RX_ERROR (RX_WDOG_TIMER | RX_RUNT | RX_OVERLEN |  \
+		    RX_COLL | RX_MII_ERROR | RX_CRC_ERROR | \
+		    RX_LEN_ERROR | RX_U_CNTRL_FRAME | RX_MISSED_FRAME)
+#define MAC_RX_BUFF0_ADDR	0x4
+#  define RX_DMA_ENABLE 	(1 << 0)
+#  define RX_T_DONE		(1 << 1)
+#  define RX_GET_DMA_BUFFER(X)	(((X) >> 2) & 0x3)
+#  define RX_SET_BUFF_ADDR(X)	((X) & 0xffffffc0)
+#define MAC_RX_BUFF1_STATUS	0x10
+#define MAC_RX_BUFF1_ADDR	0x14
+#define MAC_RX_BUFF2_STATUS	0x20
+#define MAC_RX_BUFF2_ADDR	0x24
+#define MAC_RX_BUFF3_STATUS	0x30
+#define MAC_RX_BUFF3_ADDR	0x34
+
+/* UARTS 0-3 */
+#define UART_BASE		UART0_ADDR
+#ifdef	CONFIG_SOC_AU1200
+#define UART_DEBUG_BASE 	UART1_ADDR
+#else
+#define UART_DEBUG_BASE 	UART3_ADDR
+#endif
+
+#define UART_RX		0	/* Receive buffer */
+#define UART_TX		4	/* Transmit buffer */
+#define UART_IER	8	/* Interrupt Enable Register */
+#define UART_IIR	0xC	/* Interrupt ID Register */
+#define UART_FCR	0x10	/* FIFO Control Register */
+#define UART_LCR	0x14	/* Line Control Register */
+#define UART_MCR	0x18	/* Modem Control Register */
+#define UART_LSR	0x1C	/* Line Status Register */
+#define UART_MSR	0x20	/* Modem Status Register */
+#define UART_CLK	0x28	/* Baud Rate Clock Divider */
+#define UART_MOD_CNTRL	0x100	/* Module Control */
+
+#define UART_FCR_ENABLE_FIFO	0x01 /* Enable the FIFO */
+#define UART_FCR_CLEAR_RCVR	0x02 /* Clear the RCVR FIFO */
+#define UART_FCR_CLEAR_XMIT	0x04 /* Clear the XMIT FIFO */
+#define UART_FCR_DMA_SELECT	0x08 /* For DMA applications */
+#define UART_FCR_TRIGGER_MASK	0xF0 /* Mask for the FIFO trigger range */
+#define UART_FCR_R_TRIGGER_1	0x00 /* Mask for receive trigger set at 1 */
+#define UART_FCR_R_TRIGGER_4	0x40 /* Mask for receive trigger set at 4 */
+#define UART_FCR_R_TRIGGER_8	0x80 /* Mask for receive trigger set at 8 */
+#define UART_FCR_R_TRIGGER_14   0xA0 /* Mask for receive trigger set at 14 */
+#define UART_FCR_T_TRIGGER_0	0x00 /* Mask for transmit trigger set at 0 */
+#define UART_FCR_T_TRIGGER_4	0x10 /* Mask for transmit trigger set at 4 */
+#define UART_FCR_T_TRIGGER_8    0x20 /* Mask for transmit trigger set at 8 */
+#define UART_FCR_T_TRIGGER_12	0x30 /* Mask for transmit trigger set at 12 */
+
+/*
+ * These are the definitions for the Line Control Register
+ */
+#define UART_LCR_SBC	0x40	/* Set break control */
+#define UART_LCR_SPAR	0x20	/* Stick parity (?) */
+#define UART_LCR_EPAR	0x10	/* Even parity select */
+#define UART_LCR_PARITY	0x08	/* Parity Enable */
+#define UART_LCR_STOP	0x04	/* Stop bits: 0=1 stop bit, 1= 2 stop bits */
+#define UART_LCR_WLEN5  0x00	/* Wordlength: 5 bits */
+#define UART_LCR_WLEN6  0x01	/* Wordlength: 6 bits */
+#define UART_LCR_WLEN7  0x02	/* Wordlength: 7 bits */
+#define UART_LCR_WLEN8  0x03	/* Wordlength: 8 bits */
+
+/*
+ * These are the definitions for the Line Status Register
+ */
+#define UART_LSR_TEMT	0x40	/* Transmitter empty */
+#define UART_LSR_THRE	0x20	/* Transmit-hold-register empty */
+#define UART_LSR_BI	0x10	/* Break interrupt indicator */
+#define UART_LSR_FE	0x08	/* Frame error indicator */
+#define UART_LSR_PE	0x04	/* Parity error indicator */
+#define UART_LSR_OE	0x02	/* Overrun error indicator */
+#define UART_LSR_DR	0x01	/* Receiver data ready */
+
+/*
+ * These are the definitions for the Interrupt Identification Register
+ */
+#define UART_IIR_NO_INT	0x01	/* No interrupts pending */
+#define UART_IIR_ID	0x06	/* Mask for the interrupt ID */
+#define UART_IIR_MSI	0x00	/* Modem status interrupt */
+#define UART_IIR_THRI	0x02	/* Transmitter holding register empty */
+#define UART_IIR_RDI	0x04	/* Receiver data interrupt */
+#define UART_IIR_RLSI	0x06	/* Receiver line status interrupt */
+
+/*
+ * These are the definitions for the Interrupt Enable Register
+ */
+#define UART_IER_MSI	0x08	/* Enable Modem status interrupt */
+#define UART_IER_RLSI	0x04	/* Enable receiver line status interrupt */
+#define UART_IER_THRI	0x02	/* Enable Transmitter holding register int. */
+#define UART_IER_RDI	0x01	/* Enable receiver data interrupt */
+
+/*
+ * These are the definitions for the Modem Control Register
+ */
+#define UART_MCR_LOOP	0x10	/* Enable loopback test mode */
+#define UART_MCR_OUT2	0x08	/* Out2 complement */
+#define UART_MCR_OUT1	0x04	/* Out1 complement */
+#define UART_MCR_RTS	0x02	/* RTS complement */
+#define UART_MCR_DTR	0x01	/* DTR complement */
+
+/*
+ * These are the definitions for the Modem Status Register
+ */
+#define UART_MSR_DCD	0x80	/* Data Carrier Detect */
+#define UART_MSR_RI	0x40	/* Ring Indicator */
+#define UART_MSR_DSR	0x20	/* Data Set Ready */
+#define UART_MSR_CTS	0x10	/* Clear to Send */
+#define UART_MSR_DDCD	0x08	/* Delta DCD */
+#define UART_MSR_TERI	0x04	/* Trailing edge ring indicator */
+#define UART_MSR_DDSR	0x02	/* Delta DSR */
+#define UART_MSR_DCTS	0x01	/* Delta CTS */
+#define UART_MSR_ANY_DELTA 0x0F	/* Any of the delta bits! */
+
+/* SSIO */
+#define SSI0_STATUS		0xB1600000
+#  define SSI_STATUS_BF 	(1 << 4)
+#  define SSI_STATUS_OF 	(1 << 3)
+#  define SSI_STATUS_UF 	(1 << 2)
+#  define SSI_STATUS_D		(1 << 1)
+#  define SSI_STATUS_B		(1 << 0)
+#define SSI0_INT		0xB1600004
+#  define SSI_INT_OI		(1 << 3)
+#  define SSI_INT_UI		(1 << 2)
+#  define SSI_INT_DI		(1 << 1)
+#define SSI0_INT_ENABLE 	0xB1600008
+#  define SSI_INTE_OIE		(1 << 3)
+#  define SSI_INTE_UIE		(1 << 2)
+#  define SSI_INTE_DIE		(1 << 1)
+#define SSI0_CONFIG		0xB1600020
+#  define SSI_CONFIG_AO 	(1 << 24)
+#  define SSI_CONFIG_DO 	(1 << 23)
+#  define SSI_CONFIG_ALEN_BIT	20
+#  define SSI_CONFIG_ALEN_MASK	(0x7 << 20)
+#  define SSI_CONFIG_DLEN_BIT	16
+#  define SSI_CONFIG_DLEN_MASK	(0x7 << 16)
+#  define SSI_CONFIG_DD 	(1 << 11)
+#  define SSI_CONFIG_AD 	(1 << 10)
+#  define SSI_CONFIG_BM_BIT	8
+#  define SSI_CONFIG_BM_MASK	(0x3 << 8)
+#  define SSI_CONFIG_CE 	(1 << 7)
+#  define SSI_CONFIG_DP 	(1 << 6)
+#  define SSI_CONFIG_DL 	(1 << 5)
+#  define SSI_CONFIG_EP 	(1 << 4)
+#define SSI0_ADATA		0xB1600024
+#  define SSI_AD_D		(1 << 24)
+#  define SSI_AD_ADDR_BIT	16
+#  define SSI_AD_ADDR_MASK	(0xff << 16)
+#  define SSI_AD_DATA_BIT	0
+#  define SSI_AD_DATA_MASK	(0xfff << 0)
+#define SSI0_CLKDIV		0xB1600028
+#define SSI0_CONTROL		0xB1600100
+#  define SSI_CONTROL_CD	(1 << 1)
+#  define SSI_CONTROL_E 	(1 << 0)
+
+/* SSI1 */
+#define SSI1_STATUS		0xB1680000
+#define SSI1_INT		0xB1680004
+#define SSI1_INT_ENABLE 	0xB1680008
+#define SSI1_CONFIG		0xB1680020
+#define SSI1_ADATA		0xB1680024
+#define SSI1_CLKDIV		0xB1680028
+#define SSI1_ENABLE		0xB1680100
+
+/*
+ * Register content definitions
+ */
+#define SSI_STATUS_BF		(1 << 4)
+#define SSI_STATUS_OF		(1 << 3)
+#define SSI_STATUS_UF		(1 << 2)
+#define SSI_STATUS_D		(1 << 1)
+#define SSI_STATUS_B		(1 << 0)
+
+/* SSI_INT */
+#define SSI_INT_OI		(1 << 3)
+#define SSI_INT_UI		(1 << 2)
+#define SSI_INT_DI		(1 << 1)
+
+/* SSI_INTEN */
+#define SSI_INTEN_OIE		(1 << 3)
+#define SSI_INTEN_UIE		(1 << 2)
+#define SSI_INTEN_DIE		(1 << 1)
+
+#define SSI_CONFIG_AO		(1 << 24)
+#define SSI_CONFIG_DO		(1 << 23)
+#define SSI_CONFIG_ALEN 	(7 << 20)
+#define SSI_CONFIG_DLEN 	(15 << 16)
+#define SSI_CONFIG_DD		(1 << 11)
+#define SSI_CONFIG_AD		(1 << 10)
+#define SSI_CONFIG_BM		(3 << 8)
+#define SSI_CONFIG_CE		(1 << 7)
+#define SSI_CONFIG_DP		(1 << 6)
+#define SSI_CONFIG_DL		(1 << 5)
+#define SSI_CONFIG_EP		(1 << 4)
+#define SSI_CONFIG_ALEN_N(N)	((N-1) << 20)
+#define SSI_CONFIG_DLEN_N(N)	((N-1) << 16)
+#define SSI_CONFIG_BM_HI	(0 << 8)
+#define SSI_CONFIG_BM_LO	(1 << 8)
+#define SSI_CONFIG_BM_CY	(2 << 8)
+
+#define SSI_ADATA_D		(1 << 24)
+#define SSI_ADATA_ADDR		(0xFF << 16)
+#define SSI_ADATA_DATA		0x0FFF
+#define SSI_ADATA_ADDR_N(N)	(N << 16)
+
+#define SSI_ENABLE_CD		(1 << 1)
+#define SSI_ENABLE_E		(1 << 0)
+
+/* IrDA Controller */
+#define IRDA_BASE		0xB0300000
+#define IR_RING_PTR_STATUS	(IRDA_BASE + 0x00)
+#define IR_RING_BASE_ADDR_H	(IRDA_BASE + 0x04)
+#define IR_RING_BASE_ADDR_L	(IRDA_BASE + 0x08)
+#define IR_RING_SIZE		(IRDA_BASE + 0x0C)
+#define IR_RING_PROMPT		(IRDA_BASE + 0x10)
+#define IR_RING_ADDR_CMPR	(IRDA_BASE + 0x14)
+#define IR_INT_CLEAR		(IRDA_BASE + 0x18)
+#define IR_CONFIG_1		(IRDA_BASE + 0x20)
+#  define IR_RX_INVERT_LED	(1 << 0)
+#  define IR_TX_INVERT_LED	(1 << 1)
+#  define IR_ST 		(1 << 2)
+#  define IR_SF 		(1 << 3)
+#  define IR_SIR		(1 << 4)
+#  define IR_MIR		(1 << 5)
+#  define IR_FIR		(1 << 6)
+#  define IR_16CRC		(1 << 7)
+#  define IR_TD 		(1 << 8)
+#  define IR_RX_ALL		(1 << 9)
+#  define IR_DMA_ENABLE 	(1 << 10)
+#  define IR_RX_ENABLE		(1 << 11)
+#  define IR_TX_ENABLE		(1 << 12)
+#  define IR_LOOPBACK		(1 << 14)
+#  define IR_SIR_MODE		(IR_SIR | IR_DMA_ENABLE | \
+				 IR_RX_ALL | IR_RX_ENABLE | IR_SF | IR_16CRC)
+#define IR_SIR_FLAGS		(IRDA_BASE + 0x24)
+#define IR_ENABLE		(IRDA_BASE + 0x28)
+#  define IR_RX_STATUS		(1 << 9)
+#  define IR_TX_STATUS		(1 << 10)
+#define IR_READ_PHY_CONFIG	(IRDA_BASE + 0x2C)
+#define IR_WRITE_PHY_CONFIG	(IRDA_BASE + 0x30)
+#define IR_MAX_PKT_LEN		(IRDA_BASE + 0x34)
+#define IR_RX_BYTE_CNT		(IRDA_BASE + 0x38)
+#define IR_CONFIG_2		(IRDA_BASE + 0x3C)
+#  define IR_MODE_INV		(1 << 0)
+#  define IR_ONE_PIN		(1 << 1)
+#define IR_INTERFACE_CONFIG	(IRDA_BASE + 0x40)
+
+/* GPIO */
+#define SYS_PINFUNC		0xB190002C
+#  define SYS_PF_USB		(1 << 15)	/* 2nd USB device/host */
+#  define SYS_PF_U3		(1 << 14)	/* GPIO23/U3TXD */
+#  define SYS_PF_U2		(1 << 13)	/* GPIO22/U2TXD */
+#  define SYS_PF_U1		(1 << 12)	/* GPIO21/U1TXD */
+#  define SYS_PF_SRC		(1 << 11)	/* GPIO6/SROMCKE */
+#  define SYS_PF_CK5		(1 << 10)	/* GPIO3/CLK5 */
+#  define SYS_PF_CK4		(1 << 9)	/* GPIO2/CLK4 */
+#  define SYS_PF_IRF		(1 << 8)	/* GPIO15/IRFIRSEL */
+#  define SYS_PF_UR3		(1 << 7)	/* GPIO[14:9]/UART3 */
+#  define SYS_PF_I2D		(1 << 6)	/* GPIO8/I2SDI */
+#  define SYS_PF_I2S		(1 << 5)	/* I2S/GPIO[29:31] */
+#  define SYS_PF_NI2		(1 << 4)	/* NI2/GPIO[24:28] */
+#  define SYS_PF_U0		(1 << 3)	/* U0TXD/GPIO20 */
+#  define SYS_PF_RD		(1 << 2)	/* IRTXD/GPIO19 */
+#  define SYS_PF_A97		(1 << 1)	/* AC97/SSL1 */
+#  define SYS_PF_S0		(1 << 0)	/* SSI_0/GPIO[16:18] */
+
+/* Au1100 only */
+#  define SYS_PF_PC		(1 << 18)	/* PCMCIA/GPIO[207:204] */
+#  define SYS_PF_LCD		(1 << 17)	/* extern lcd/GPIO[203:200] */
+#  define SYS_PF_CS		(1 << 16)	/* EXTCLK0/32KHz to gpio2 */
+#  define SYS_PF_EX0		(1 << 9)	/* GPIO2/clock */
+
+/* Au1550 only.  Redefines lots of pins */
+#  define SYS_PF_PSC2_MASK	(7 << 17)
+#  define SYS_PF_PSC2_AC97	0
+#  define SYS_PF_PSC2_SPI	0
+#  define SYS_PF_PSC2_I2S	(1 << 17)
+#  define SYS_PF_PSC2_SMBUS	(3 << 17)
+#  define SYS_PF_PSC2_GPIO	(7 << 17)
+#  define SYS_PF_PSC3_MASK	(7 << 20)
+#  define SYS_PF_PSC3_AC97	0
+#  define SYS_PF_PSC3_SPI	0
+#  define SYS_PF_PSC3_I2S	(1 << 20)
+#  define SYS_PF_PSC3_SMBUS	(3 << 20)
+#  define SYS_PF_PSC3_GPIO	(7 << 20)
+#  define SYS_PF_PSC1_S1	(1 << 1)
+#  define SYS_PF_MUST_BE_SET	((1 << 5) | (1 << 2))
+
+/* Au1200 only */
+#ifdef CONFIG_SOC_AU1200
+#define SYS_PINFUNC_DMA 	(1 << 31)
+#define SYS_PINFUNC_S0A 	(1 << 30)
+#define SYS_PINFUNC_S1A 	(1 << 29)
+#define SYS_PINFUNC_LP0 	(1 << 28)
+#define SYS_PINFUNC_LP1 	(1 << 27)
+#define SYS_PINFUNC_LD16 	(1 << 26)
+#define SYS_PINFUNC_LD8 	(1 << 25)
+#define SYS_PINFUNC_LD1 	(1 << 24)
+#define SYS_PINFUNC_LD0 	(1 << 23)
+#define SYS_PINFUNC_P1A 	(3 << 21)
+#define SYS_PINFUNC_P1B 	(1 << 20)
+#define SYS_PINFUNC_FS3 	(1 << 19)
+#define SYS_PINFUNC_P0A 	(3 << 17)
+#define SYS_PINFUNC_CS		(1 << 16)
+#define SYS_PINFUNC_CIM 	(1 << 15)
+#define SYS_PINFUNC_P1C 	(1 << 14)
+#define SYS_PINFUNC_U1T 	(1 << 12)
+#define SYS_PINFUNC_U1R 	(1 << 11)
+#define SYS_PINFUNC_EX1 	(1 << 10)
+#define SYS_PINFUNC_EX0 	(1 << 9)
+#define SYS_PINFUNC_U0R 	(1 << 8)
+#define SYS_PINFUNC_MC		(1 << 7)
+#define SYS_PINFUNC_S0B 	(1 << 6)
+#define SYS_PINFUNC_S0C 	(1 << 5)
+#define SYS_PINFUNC_P0B 	(1 << 4)
+#define SYS_PINFUNC_U0T 	(1 << 3)
+#define SYS_PINFUNC_S1B 	(1 << 2)
+#endif
+
+#define SYS_TRIOUTRD		0xB1900100
+#define SYS_TRIOUTCLR		0xB1900100
+#define SYS_OUTPUTRD		0xB1900108
+#define SYS_OUTPUTSET		0xB1900108
+#define SYS_OUTPUTCLR		0xB190010C
+#define SYS_PINSTATERD		0xB1900110
+#define SYS_PININPUTEN		0xB1900110
+
+/* GPIO2, Au1500, Au1550 only */
+#define GPIO2_BASE		0xB1700000
+#define GPIO2_DIR		(GPIO2_BASE + 0)
+#define GPIO2_OUTPUT		(GPIO2_BASE + 8)
+#define GPIO2_PINSTATE		(GPIO2_BASE + 0xC)
+#define GPIO2_INTENABLE 	(GPIO2_BASE + 0x10)
+#define GPIO2_ENABLE		(GPIO2_BASE + 0x14)
+
+/* Power Management */
+#define SYS_SCRATCH0		0xB1900018
+#define SYS_SCRATCH1		0xB190001C
+#define SYS_WAKEMSK		0xB1900034
+#define SYS_ENDIAN		0xB1900038
+#define SYS_POWERCTRL		0xB190003C
+#define SYS_WAKESRC		0xB190005C
+#define SYS_SLPPWR		0xB1900078
+#define SYS_SLEEP		0xB190007C
+
+/* Clock Controller */
+#define SYS_FREQCTRL0		0xB1900020
+#  define SYS_FC_FRDIV2_BIT	22
+#  define SYS_FC_FRDIV2_MASK	(0xff << SYS_FC_FRDIV2_BIT)
+#  define SYS_FC_FE2		(1 << 21)
+#  define SYS_FC_FS2		(1 << 20)
+#  define SYS_FC_FRDIV1_BIT	12
+#  define SYS_FC_FRDIV1_MASK	(0xff << SYS_FC_FRDIV1_BIT)
+#  define SYS_FC_FE1		(1 << 11)
+#  define SYS_FC_FS1		(1 << 10)
+#  define SYS_FC_FRDIV0_BIT	2
+#  define SYS_FC_FRDIV0_MASK	(0xff << SYS_FC_FRDIV0_BIT)
+#  define SYS_FC_FE0		(1 << 1)
+#  define SYS_FC_FS0		(1 << 0)
+#define SYS_FREQCTRL1		0xB1900024
+#  define SYS_FC_FRDIV5_BIT	22
+#  define SYS_FC_FRDIV5_MASK	(0xff << SYS_FC_FRDIV5_BIT)
+#  define SYS_FC_FE5		(1 << 21)
+#  define SYS_FC_FS5		(1 << 20)
+#  define SYS_FC_FRDIV4_BIT	12
+#  define SYS_FC_FRDIV4_MASK	(0xff << SYS_FC_FRDIV4_BIT)
+#  define SYS_FC_FE4		(1 << 11)
+#  define SYS_FC_FS4		(1 << 10)
+#  define SYS_FC_FRDIV3_BIT	2
+#  define SYS_FC_FRDIV3_MASK	(0xff << SYS_FC_FRDIV3_BIT)
+#  define SYS_FC_FE3		(1 << 1)
+#  define SYS_FC_FS3		(1 << 0)
+#define SYS_CLKSRC		0xB1900028
+#  define SYS_CS_ME1_BIT	27
+#  define SYS_CS_ME1_MASK	(0x7 << SYS_CS_ME1_BIT)
+#  define SYS_CS_DE1		(1 << 26)
+#  define SYS_CS_CE1		(1 << 25)
+#  define SYS_CS_ME0_BIT	22
+#  define SYS_CS_ME0_MASK	(0x7 << SYS_CS_ME0_BIT)
+#  define SYS_CS_DE0		(1 << 21)
+#  define SYS_CS_CE0		(1 << 20)
+#  define SYS_CS_MI2_BIT	17
+#  define SYS_CS_MI2_MASK	(0x7 << SYS_CS_MI2_BIT)
+#  define SYS_CS_DI2		(1 << 16)
+#  define SYS_CS_CI2		(1 << 15)
+#ifdef CONFIG_SOC_AU1100
+#  define SYS_CS_ML_BIT 	7
+#  define SYS_CS_ML_MASK	(0x7 << SYS_CS_ML_BIT)
+#  define SYS_CS_DL		(1 << 6)
+#  define SYS_CS_CL		(1 << 5)
+#else
+#  define SYS_CS_MUH_BIT	12
+#  define SYS_CS_MUH_MASK	(0x7 << SYS_CS_MUH_BIT)
+#  define SYS_CS_DUH		(1 << 11)
+#  define SYS_CS_CUH		(1 << 10)
+#  define SYS_CS_MUD_BIT	7
+#  define SYS_CS_MUD_MASK	(0x7 << SYS_CS_MUD_BIT)
+#  define SYS_CS_DUD		(1 << 6)
+#  define SYS_CS_CUD		(1 << 5)
+#endif
+#  define SYS_CS_MIR_BIT	2
+#  define SYS_CS_MIR_MASK	(0x7 << SYS_CS_MIR_BIT)
+#  define SYS_CS_DIR		(1 << 1)
+#  define SYS_CS_CIR		(1 << 0)
+
+#  define SYS_CS_MUX_AUX	0x1
+#  define SYS_CS_MUX_FQ0	0x2
+#  define SYS_CS_MUX_FQ1	0x3
+#  define SYS_CS_MUX_FQ2	0x4
+#  define SYS_CS_MUX_FQ3	0x5
+#  define SYS_CS_MUX_FQ4	0x6
+#  define SYS_CS_MUX_FQ5	0x7
+#define SYS_CPUPLL		0xB1900060
+#define SYS_AUXPLL		0xB1900064
+
+/* AC97 Controller */
+#define AC97C_CONFIG		0xB0000000
+#  define AC97C_RECV_SLOTS_BIT	13
+#  define AC97C_RECV_SLOTS_MASK (0x3ff << AC97C_RECV_SLOTS_BIT)
+#  define AC97C_XMIT_SLOTS_BIT	3
+#  define AC97C_XMIT_SLOTS_MASK (0x3ff << AC97C_XMIT_SLOTS_BIT)
+#  define AC97C_SG		(1 << 2)
+#  define AC97C_SYNC		(1 << 1)
+#  define AC97C_RESET		(1 << 0)
+#define AC97C_STATUS		0xB0000004
+#  define AC97C_XU		(1 << 11)
+#  define AC97C_XO		(1 << 10)
+#  define AC97C_RU		(1 << 9)
+#  define AC97C_RO		(1 << 8)
+#  define AC97C_READY		(1 << 7)
+#  define AC97C_CP		(1 << 6)
+#  define AC97C_TR		(1 << 5)
+#  define AC97C_TE		(1 << 4)
+#  define AC97C_TF		(1 << 3)
+#  define AC97C_RR		(1 << 2)
+#  define AC97C_RE		(1 << 1)
+#  define AC97C_RF		(1 << 0)
+#define AC97C_DATA		0xB0000008
+#define AC97C_CMD		0xB000000C
+#  define AC97C_WD_BIT		16
+#  define AC97C_READ		(1 << 7)
+#  define AC97C_INDEX_MASK	0x7f
+#define AC97C_CNTRL		0xB0000010
+#  define AC97C_RS		(1 << 1)
+#  define AC97C_CE		(1 << 0)
+
+/* Secure Digital (SD) Controller */
+#define SD0_XMIT_FIFO	0xB0600000
+#define SD0_RECV_FIFO	0xB0600004
+#define SD1_XMIT_FIFO	0xB0680000
+#define SD1_RECV_FIFO	0xB0680004
+
+#if defined(CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1550)
+/* Au1500 PCI Controller */
+#define Au1500_CFG_BASE 	0xB4005000	/* virtual, KSEG1 addr */
+#define Au1500_PCI_CMEM 	(Au1500_CFG_BASE + 0)
+#define Au1500_PCI_CFG		(Au1500_CFG_BASE + 4)
+#  define PCI_ERROR		((1 << 22) | (1 << 23) | (1 << 24) | \
+				 (1 << 25) | (1 << 26) | (1 << 27))
+#define Au1500_PCI_B2BMASK_CCH	(Au1500_CFG_BASE + 8)
+#define Au1500_PCI_B2B0_VID	(Au1500_CFG_BASE + 0xC)
+#define Au1500_PCI_B2B1_ID	(Au1500_CFG_BASE + 0x10)
+#define Au1500_PCI_MWMASK_DEV	(Au1500_CFG_BASE + 0x14)
+#define Au1500_PCI_MWBASE_REV_CCL (Au1500_CFG_BASE + 0x18)
+#define Au1500_PCI_ERR_ADDR	(Au1500_CFG_BASE + 0x1C)
+#define Au1500_PCI_SPEC_INTACK	(Au1500_CFG_BASE + 0x20)
+#define Au1500_PCI_ID		(Au1500_CFG_BASE + 0x100)
+#define Au1500_PCI_STATCMD	(Au1500_CFG_BASE + 0x104)
+#define Au1500_PCI_CLASSREV	(Au1500_CFG_BASE + 0x108)
+#define Au1500_PCI_HDRTYPE	(Au1500_CFG_BASE + 0x10C)
+#define Au1500_PCI_MBAR 	(Au1500_CFG_BASE + 0x110)
+
+#define Au1500_PCI_HDR		0xB4005100	/* virtual, KSEG1 addr */
+
+/*
+ * All of our structures, like PCI resource, have 32-bit members.
+ * Drivers are expected to do an ioremap on the PCI MEM resource, but it's
+ * hard to store 0x4 0000 0000 in a 32-bit type.  We require a small patch
+ * to __ioremap to check for addresses between (u32)Au1500_PCI_MEM_START and
+ * (u32)Au1500_PCI_MEM_END and change those to the full 36-bit PCI MEM
+ * addresses.  For PCI I/O, it's simpler because we get to do the ioremap
+ * ourselves and then adjust the device's resources.
+ */
+#define Au1500_EXT_CFG		0x600000000ULL
+#define Au1500_EXT_CFG_TYPE1	0x680000000ULL
+#define Au1500_PCI_IO_START	0x500000000ULL
+#define Au1500_PCI_IO_END	0x5000FFFFFULL
+#define Au1500_PCI_MEM_START	0x440000000ULL
+#define Au1500_PCI_MEM_END	0x44FFFFFFFULL
+
+#define PCI_IO_START	0x00001000
+#define PCI_IO_END	0x000FFFFF
+#define PCI_MEM_START	0x40000000
+#define PCI_MEM_END	0x4FFFFFFF
+
+#define PCI_FIRST_DEVFN (0 << 3)
+#define PCI_LAST_DEVFN	(19 << 3)
+
+#define IOPORT_RESOURCE_START	0x00001000	/* skip legacy probing */
+#define IOPORT_RESOURCE_END	0xffffffff
+#define IOMEM_RESOURCE_START	0x10000000
+#define IOMEM_RESOURCE_END	0xffffffff
+
+#else /* Au1000 and Au1100 and Au1200 */
+
+/* Don't allow any legacy ports probing */
+#define IOPORT_RESOURCE_START	0x10000000
+#define IOPORT_RESOURCE_END	0xffffffff
+#define IOMEM_RESOURCE_START	0x10000000
+#define IOMEM_RESOURCE_END	0xffffffff
+
+#define PCI_IO_START	0
+#define PCI_IO_END	0
+#define PCI_MEM_START	0
+#define PCI_MEM_END	0
+#define PCI_FIRST_DEVFN 0
+#define PCI_LAST_DEVFN	0
+
+#endif
+
+#ifndef _LANGUAGE_ASSEMBLY
+typedef volatile struct {
+	/* 0x0000 */ u32 toytrim;
+	/* 0x0004 */ u32 toywrite;
+	/* 0x0008 */ u32 toymatch0;
+	/* 0x000C */ u32 toymatch1;
+	/* 0x0010 */ u32 toymatch2;
+	/* 0x0014 */ u32 cntrctrl;
+	/* 0x0018 */ u32 scratch0;
+	/* 0x001C */ u32 scratch1;
+	/* 0x0020 */ u32 freqctrl0;
+	/* 0x0024 */ u32 freqctrl1;
+	/* 0x0028 */ u32 clksrc;
+	/* 0x002C */ u32 pinfunc;
+	/* 0x0030 */ u32 reserved0;
+	/* 0x0034 */ u32 wakemsk;
+	/* 0x0038 */ u32 endian;
+	/* 0x003C */ u32 powerctrl;
+	/* 0x0040 */ u32 toyread;
+	/* 0x0044 */ u32 rtctrim;
+	/* 0x0048 */ u32 rtcwrite;
+	/* 0x004C */ u32 rtcmatch0;
+	/* 0x0050 */ u32 rtcmatch1;
+	/* 0x0054 */ u32 rtcmatch2;
+	/* 0x0058 */ u32 rtcread;
+	/* 0x005C */ u32 wakesrc;
+	/* 0x0060 */ u32 cpupll;
+	/* 0x0064 */ u32 auxpll;
+	/* 0x0068 */ u32 reserved1;
+	/* 0x006C */ u32 reserved2;
+	/* 0x0070 */ u32 reserved3;
+	/* 0x0074 */ u32 reserved4;
+	/* 0x0078 */ u32 slppwr;
+	/* 0x007C */ u32 sleep;
+	/* 0x0080 */ u32 reserved5[32];
+	/* 0x0100 */ u32 trioutrd;
+#define trioutclr trioutrd
+	/* 0x0104 */ u32 reserved6;
+	/* 0x0108 */ u32 outputrd;
+#define outputset outputrd
+	/* 0x010C */ u32 outputclr;
+	/* 0x0110 */ u32 pinstaterd;
+#define pininputen pinstaterd
+} AU1X00_SYS;
+
+static AU1X00_SYS * const sys = (AU1X00_SYS *)SYS_BASE;
+
+#endif
+
+/*
+ * Processor information based on PRID.
+ * Copied from PowerPC.
+ */
+#ifndef _LANGUAGE_ASSEMBLY
+struct cpu_spec {
+	/* CPU is matched via (PRID & prid_mask) == prid_value */
+	unsigned int	prid_mask;
+	unsigned int	prid_value;
+
+	char		*cpu_name;
+	unsigned char	cpu_od;		/* Set Config[OD] */
+	unsigned char	cpu_bclk;	/* Enable BCLK switching */
+	unsigned char	cpu_pll_wo;	/* sys_cpupll reg. write-only */
+};
+
+extern struct cpu_spec	cpu_specs[];
+extern struct cpu_spec	*cur_cpu_spec[];
+#endif
+
+#endif
