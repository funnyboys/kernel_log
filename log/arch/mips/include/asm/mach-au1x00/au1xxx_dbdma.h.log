commit 4939788eb8559754a120531c49ffa96bb30fee06
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sun May 22 00:39:18 2016 +0200

    MIPS: Spelling fix lets -> let's
    
    As noticed by Sergei in the discussion of Andrea Gelmini's patch series.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Reported-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>

diff --git a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
index ca8077afac4a..456ddba152c4 100644
--- a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
+++ b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
@@ -100,7 +100,7 @@ typedef volatile struct au1xxx_ddma_desc {
 	u32	dscr_nxtptr;		/* Next descriptor pointer (mostly) */
 	/*
 	 * First 32 bytes are HW specific!!!
-	 * Lets have some SW data following -- make sure it's 32 bytes.
+	 * Let's have some SW data following -- make sure it's 32 bytes.
 	 */
 	u32	sw_status;
 	u32	sw_context;

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
index 217810e18361..ca8077afac4a 100644
--- a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
+++ b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
@@ -103,7 +103,7 @@ typedef volatile struct au1xxx_ddma_desc {
 	 * Lets have some SW data following -- make sure it's 32 bytes.
 	 */
 	u32	sw_status;
-	u32 	sw_context;
+	u32	sw_context;
 	u32	sw_reserved[6];
 } au1x_ddma_desc_t;
 
@@ -123,7 +123,7 @@ typedef volatile struct au1xxx_ddma_desc {
 #define DSCR_CMD0_CV		(0x1 << 2)	/* Clear Valid when done */
 #define DSCR_CMD0_ST_MASK	(0x3 << 0)	/* Status instruction */
 
-#define SW_STATUS_INUSE 	(1 << 0)
+#define SW_STATUS_INUSE		(1 << 0)
 
 /* Command 0 device IDs. */
 #define AU1550_DSCR_CMD0_UART0_TX	0
@@ -195,8 +195,8 @@ typedef volatile struct au1xxx_ddma_desc {
 #define AU1300_DSCR_CMD0_SDMS_RX0      9
 #define AU1300_DSCR_CMD0_SDMS_TX1      10
 #define AU1300_DSCR_CMD0_SDMS_RX1      11
-#define AU1300_DSCR_CMD0_AES_TX        12
-#define AU1300_DSCR_CMD0_AES_RX        13
+#define AU1300_DSCR_CMD0_AES_TX	       12
+#define AU1300_DSCR_CMD0_AES_RX	       13
 #define AU1300_DSCR_CMD0_PSC0_TX       14
 #define AU1300_DSCR_CMD0_PSC0_RX       15
 #define AU1300_DSCR_CMD0_PSC1_TX       16
@@ -205,12 +205,12 @@ typedef volatile struct au1xxx_ddma_desc {
 #define AU1300_DSCR_CMD0_PSC2_RX       19
 #define AU1300_DSCR_CMD0_PSC3_TX       20
 #define AU1300_DSCR_CMD0_PSC3_RX       21
-#define AU1300_DSCR_CMD0_LCD           22
+#define AU1300_DSCR_CMD0_LCD	       22
 #define AU1300_DSCR_CMD0_NAND_FLASH    23
 #define AU1300_DSCR_CMD0_SDMS_TX2      24
 #define AU1300_DSCR_CMD0_SDMS_RX2      25
 #define AU1300_DSCR_CMD0_CIM_SYNC      26
-#define AU1300_DSCR_CMD0_UDMA          27
+#define AU1300_DSCR_CMD0_UDMA	       27
 #define AU1300_DSCR_CMD0_DMA_REQ0      28
 #define AU1300_DSCR_CMD0_DMA_REQ1      29
 
@@ -298,7 +298,7 @@ typedef volatile struct au1xxx_ddma_desc {
 #define DSCR_NXTPTR_MS		(1 << 27)
 
 /* The number of DBDMA channels. */
-#define NUM_DBDMA_CHANS	16
+#define NUM_DBDMA_CHANS 16
 
 /*
  * DDMA API definitions
@@ -316,7 +316,7 @@ typedef struct dbdma_device_table {
 
 
 typedef struct dbdma_chan_config {
-	spinlock_t      lock;
+	spinlock_t	lock;
 
 	u32			chan_flags;
 	u32			chan_index;

commit 809f36c6f4a0568178c909ff1096ca83eae33f7d
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Tue Nov 1 20:03:30 2011 +0100

    MIPS: Alchemy: Au1300 SoC support
    
    Add basic support for the Au1300 variant(s):
    - New GPIO/Interrupt controller
    - DBDMA ids
    - USB setup
    - MMC support
    - enable various PSC drivers
    - detection code.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@googlemail.com>
    To: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/2866/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
index 323ce2d145f2..217810e18361 100644
--- a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
+++ b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
@@ -183,6 +183,37 @@ typedef volatile struct au1xxx_ddma_desc {
 #define AU1200_DSCR_CMD0_PSC1_SYNC	25
 #define AU1200_DSCR_CMD0_CIM_SYNC	26
 
+#define AU1300_DSCR_CMD0_UART0_TX      0
+#define AU1300_DSCR_CMD0_UART0_RX      1
+#define AU1300_DSCR_CMD0_UART1_TX      2
+#define AU1300_DSCR_CMD0_UART1_RX      3
+#define AU1300_DSCR_CMD0_UART2_TX      4
+#define AU1300_DSCR_CMD0_UART2_RX      5
+#define AU1300_DSCR_CMD0_UART3_TX      6
+#define AU1300_DSCR_CMD0_UART3_RX      7
+#define AU1300_DSCR_CMD0_SDMS_TX0      8
+#define AU1300_DSCR_CMD0_SDMS_RX0      9
+#define AU1300_DSCR_CMD0_SDMS_TX1      10
+#define AU1300_DSCR_CMD0_SDMS_RX1      11
+#define AU1300_DSCR_CMD0_AES_TX        12
+#define AU1300_DSCR_CMD0_AES_RX        13
+#define AU1300_DSCR_CMD0_PSC0_TX       14
+#define AU1300_DSCR_CMD0_PSC0_RX       15
+#define AU1300_DSCR_CMD0_PSC1_TX       16
+#define AU1300_DSCR_CMD0_PSC1_RX       17
+#define AU1300_DSCR_CMD0_PSC2_TX       18
+#define AU1300_DSCR_CMD0_PSC2_RX       19
+#define AU1300_DSCR_CMD0_PSC3_TX       20
+#define AU1300_DSCR_CMD0_PSC3_RX       21
+#define AU1300_DSCR_CMD0_LCD           22
+#define AU1300_DSCR_CMD0_NAND_FLASH    23
+#define AU1300_DSCR_CMD0_SDMS_TX2      24
+#define AU1300_DSCR_CMD0_SDMS_RX2      25
+#define AU1300_DSCR_CMD0_CIM_SYNC      26
+#define AU1300_DSCR_CMD0_UDMA          27
+#define AU1300_DSCR_CMD0_DMA_REQ0      28
+#define AU1300_DSCR_CMD0_DMA_REQ1      29
+
 #define DSCR_CMD0_THROTTLE	30
 #define DSCR_CMD0_ALWAYS	31
 #define DSCR_NDEV_IDS		32

commit f2e442fd2ff4ed565835e407114f75c92c9fe443
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Fri Aug 12 11:39:42 2011 +0200

    MIPS: Alchemy: clean DMA code of CONFIG_SOC_AU1??? defines
    
    This patch gets rid of all CONFIG_SOC_AU1XXX defines in
    DMA/DBDMA-related code.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@googlemail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/2704/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
index 2fdacfe85e23..323ce2d145f2 100644
--- a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
+++ b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
@@ -126,66 +126,62 @@ typedef volatile struct au1xxx_ddma_desc {
 #define SW_STATUS_INUSE 	(1 << 0)
 
 /* Command 0 device IDs. */
-#ifdef CONFIG_SOC_AU1550
-#define DSCR_CMD0_UART0_TX	0
-#define DSCR_CMD0_UART0_RX	1
-#define DSCR_CMD0_UART3_TX	2
-#define DSCR_CMD0_UART3_RX	3
-#define DSCR_CMD0_DMA_REQ0	4
-#define DSCR_CMD0_DMA_REQ1	5
-#define DSCR_CMD0_DMA_REQ2	6
-#define DSCR_CMD0_DMA_REQ3	7
-#define DSCR_CMD0_USBDEV_RX0	8
-#define DSCR_CMD0_USBDEV_TX0	9
-#define DSCR_CMD0_USBDEV_TX1	10
-#define DSCR_CMD0_USBDEV_TX2	11
-#define DSCR_CMD0_USBDEV_RX3	12
-#define DSCR_CMD0_USBDEV_RX4	13
-#define DSCR_CMD0_PSC0_TX	14
-#define DSCR_CMD0_PSC0_RX	15
-#define DSCR_CMD0_PSC1_TX	16
-#define DSCR_CMD0_PSC1_RX	17
-#define DSCR_CMD0_PSC2_TX	18
-#define DSCR_CMD0_PSC2_RX	19
-#define DSCR_CMD0_PSC3_TX	20
-#define DSCR_CMD0_PSC3_RX	21
-#define DSCR_CMD0_PCI_WRITE	22
-#define DSCR_CMD0_NAND_FLASH	23
-#define DSCR_CMD0_MAC0_RX	24
-#define DSCR_CMD0_MAC0_TX	25
-#define DSCR_CMD0_MAC1_RX	26
-#define DSCR_CMD0_MAC1_TX	27
-#endif /* CONFIG_SOC_AU1550 */
-
-#ifdef CONFIG_SOC_AU1200
-#define DSCR_CMD0_UART0_TX	0
-#define DSCR_CMD0_UART0_RX	1
-#define DSCR_CMD0_UART1_TX	2
-#define DSCR_CMD0_UART1_RX	3
-#define DSCR_CMD0_DMA_REQ0	4
-#define DSCR_CMD0_DMA_REQ1	5
-#define DSCR_CMD0_MAE_BE	6
-#define DSCR_CMD0_MAE_FE	7
-#define DSCR_CMD0_SDMS_TX0	8
-#define DSCR_CMD0_SDMS_RX0	9
-#define DSCR_CMD0_SDMS_TX1	10
-#define DSCR_CMD0_SDMS_RX1	11
-#define DSCR_CMD0_AES_TX	13
-#define DSCR_CMD0_AES_RX	12
-#define DSCR_CMD0_PSC0_TX	14
-#define DSCR_CMD0_PSC0_RX	15
-#define DSCR_CMD0_PSC1_TX	16
-#define DSCR_CMD0_PSC1_RX	17
-#define DSCR_CMD0_CIM_RXA	18
-#define DSCR_CMD0_CIM_RXB	19
-#define DSCR_CMD0_CIM_RXC	20
-#define DSCR_CMD0_MAE_BOTH	21
-#define DSCR_CMD0_LCD		22
-#define DSCR_CMD0_NAND_FLASH	23
-#define DSCR_CMD0_PSC0_SYNC	24
-#define DSCR_CMD0_PSC1_SYNC	25
-#define DSCR_CMD0_CIM_SYNC	26
-#endif /* CONFIG_SOC_AU1200 */
+#define AU1550_DSCR_CMD0_UART0_TX	0
+#define AU1550_DSCR_CMD0_UART0_RX	1
+#define AU1550_DSCR_CMD0_UART3_TX	2
+#define AU1550_DSCR_CMD0_UART3_RX	3
+#define AU1550_DSCR_CMD0_DMA_REQ0	4
+#define AU1550_DSCR_CMD0_DMA_REQ1	5
+#define AU1550_DSCR_CMD0_DMA_REQ2	6
+#define AU1550_DSCR_CMD0_DMA_REQ3	7
+#define AU1550_DSCR_CMD0_USBDEV_RX0	8
+#define AU1550_DSCR_CMD0_USBDEV_TX0	9
+#define AU1550_DSCR_CMD0_USBDEV_TX1	10
+#define AU1550_DSCR_CMD0_USBDEV_TX2	11
+#define AU1550_DSCR_CMD0_USBDEV_RX3	12
+#define AU1550_DSCR_CMD0_USBDEV_RX4	13
+#define AU1550_DSCR_CMD0_PSC0_TX	14
+#define AU1550_DSCR_CMD0_PSC0_RX	15
+#define AU1550_DSCR_CMD0_PSC1_TX	16
+#define AU1550_DSCR_CMD0_PSC1_RX	17
+#define AU1550_DSCR_CMD0_PSC2_TX	18
+#define AU1550_DSCR_CMD0_PSC2_RX	19
+#define AU1550_DSCR_CMD0_PSC3_TX	20
+#define AU1550_DSCR_CMD0_PSC3_RX	21
+#define AU1550_DSCR_CMD0_PCI_WRITE	22
+#define AU1550_DSCR_CMD0_NAND_FLASH	23
+#define AU1550_DSCR_CMD0_MAC0_RX	24
+#define AU1550_DSCR_CMD0_MAC0_TX	25
+#define AU1550_DSCR_CMD0_MAC1_RX	26
+#define AU1550_DSCR_CMD0_MAC1_TX	27
+
+#define AU1200_DSCR_CMD0_UART0_TX	0
+#define AU1200_DSCR_CMD0_UART0_RX	1
+#define AU1200_DSCR_CMD0_UART1_TX	2
+#define AU1200_DSCR_CMD0_UART1_RX	3
+#define AU1200_DSCR_CMD0_DMA_REQ0	4
+#define AU1200_DSCR_CMD0_DMA_REQ1	5
+#define AU1200_DSCR_CMD0_MAE_BE		6
+#define AU1200_DSCR_CMD0_MAE_FE		7
+#define AU1200_DSCR_CMD0_SDMS_TX0	8
+#define AU1200_DSCR_CMD0_SDMS_RX0	9
+#define AU1200_DSCR_CMD0_SDMS_TX1	10
+#define AU1200_DSCR_CMD0_SDMS_RX1	11
+#define AU1200_DSCR_CMD0_AES_TX		13
+#define AU1200_DSCR_CMD0_AES_RX		12
+#define AU1200_DSCR_CMD0_PSC0_TX	14
+#define AU1200_DSCR_CMD0_PSC0_RX	15
+#define AU1200_DSCR_CMD0_PSC1_TX	16
+#define AU1200_DSCR_CMD0_PSC1_RX	17
+#define AU1200_DSCR_CMD0_CIM_RXA	18
+#define AU1200_DSCR_CMD0_CIM_RXB	19
+#define AU1200_DSCR_CMD0_CIM_RXC	20
+#define AU1200_DSCR_CMD0_MAE_BOTH	21
+#define AU1200_DSCR_CMD0_LCD		22
+#define AU1200_DSCR_CMD0_NAND_FLASH	23
+#define AU1200_DSCR_CMD0_PSC0_SYNC	24
+#define AU1200_DSCR_CMD0_PSC1_SYNC	25
+#define AU1200_DSCR_CMD0_CIM_SYNC	26
 
 #define DSCR_CMD0_THROTTLE	30
 #define DSCR_CMD0_ALWAYS	31

commit adcb86279f1e4d7a1a9f267b49441aecf4a5110a
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Sun May 8 10:42:16 2011 +0200

    MIPS: Alchemy: Convert dbdma.c to syscore_ops
    
    Convert the PM sysdev to syscore_ops and clean up the ddma addresses a bit.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@googlemail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Cc: Florian Fainelli <florian@openwrt.org>
    Cc: Wolfgang Grandegger <wg@grandegger.com>
    Patchwork: https://patchwork.linux-mips.org/patch/2351/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
index c8a553a36ba4..2fdacfe85e23 100644
--- a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
+++ b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
@@ -37,14 +37,6 @@
 
 #ifndef _LANGUAGE_ASSEMBLY
 
-/*
- * The DMA base addresses.
- * The channels are every 256 bytes (0x0100) from the channel 0 base.
- * Interrupt status/enable is bits 15:0 for channels 15 to zero.
- */
-#define DDMA_GLOBAL_BASE	0xb4003000
-#define DDMA_CHANNEL_BASE	0xb4002000
-
 typedef volatile struct dbdma_global {
 	u32	ddma_config;
 	u32	ddma_intstat;

commit 96d660c482e03b2d7b6c0245b95a7cce537606c8
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Wed Apr 14 20:33:44 2010 +0200

    MIPS: Alchemy: add sysdev for DBDMA PM.
    
    Add a sysdev for DBDMA PM.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: http://patchwork.linux-mips.org/patch/1119/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
index 8c6b1105ce0b..c8a553a36ba4 100644
--- a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
+++ b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
@@ -358,10 +358,6 @@ u32 au1xxx_dbdma_put_dscr(u32 chanid, au1x_ddma_desc_t *dscr);
 u32 au1xxx_ddma_add_device(dbdev_tab_t *dev);
 extern void au1xxx_ddma_del_device(u32 devid);
 void *au1xxx_ddma_get_nextptr_virt(au1x_ddma_desc_t *dp);
-#ifdef CONFIG_PM
-void au1xxx_dbdma_suspend(void);
-void au1xxx_dbdma_resume(void);
-#endif
 
 /*
  *	Flags for the put_source/put_dest functions.

commit 963accbc82a0912b39de39d59e2fd6741db3aa4b
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Tue Oct 13 20:22:35 2009 +0200

    MIPS: Alchemy: change dbdma to accept physical memory addresses
    
    DMA can only be done from physical addresses; move the "virt_to_phys"
    source/destination buffer address translation from the dbdma queueing
    functions (since the hardware can only DMA to/from physical addresses)
    to their respective users.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
index b417c3bcdcb9..8c6b1105ce0b 100644
--- a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
+++ b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
@@ -339,8 +339,8 @@ u32 au1xxx_dbdma_set_devwidth(u32 chanid, int bits);
 u32 au1xxx_dbdma_ring_alloc(u32 chanid, int entries);
 
 /* Put buffers on source/destination descriptors. */
-u32 au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes, u32 flags);
-u32 au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes, u32 flags);
+u32 au1xxx_dbdma_put_source(u32 chanid, dma_addr_t buf, int nbytes, u32 flags);
+u32 au1xxx_dbdma_put_dest(u32 chanid, dma_addr_t buf, int nbytes, u32 flags);
 
 /* Get a buffer from the destination descriptor. */
 u32 au1xxx_dbdma_get_dest(u32 chanid, void **buf, int *nbytes);

commit ea071cc705e8bfba0c8bf84be8d4f9f4e9da6962
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Tue Oct 13 20:22:34 2009 +0200

    MIPS: Alchemy: remove dbdma compat macros
    
    Remove dbdma compat macros, move remaining users over to default
    queueing functions and -flags.
    
    (Queueing function signature has changed in order to give
     a build failure instead of silent functional changes due
     to the no longer implicitly specified DDMA_FLAGS_IE flag)
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
index d206000fbfe2..b417c3bcdcb9 100644
--- a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
+++ b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
@@ -339,8 +339,8 @@ u32 au1xxx_dbdma_set_devwidth(u32 chanid, int bits);
 u32 au1xxx_dbdma_ring_alloc(u32 chanid, int entries);
 
 /* Put buffers on source/destination descriptors. */
-u32 _au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes, u32 flags);
-u32 _au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes, u32 flags);
+u32 au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes, u32 flags);
+u32 au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes, u32 flags);
 
 /* Get a buffer from the destination descriptor. */
 u32 au1xxx_dbdma_get_dest(u32 chanid, void **buf, int *nbytes);
@@ -363,25 +363,6 @@ void au1xxx_dbdma_suspend(void);
 void au1xxx_dbdma_resume(void);
 #endif
 
-
-/*
- * Some compatibilty macros -- needed to make changes to API
- * without breaking existing drivers.
- */
-#define au1xxx_dbdma_put_source(chanid, buf, nbytes)			\
-	_au1xxx_dbdma_put_source(chanid, buf, nbytes, DDMA_FLAGS_IE)
-#define au1xxx_dbdma_put_source_flags(chanid, buf, nbytes, flags)	\
-	_au1xxx_dbdma_put_source(chanid, buf, nbytes, flags)
-#define put_source_flags(chanid, buf, nbytes, flags)			\
-	au1xxx_dbdma_put_source_flags(chanid, buf, nbytes, flags)
-
-#define au1xxx_dbdma_put_dest(chanid, buf, nbytes)			\
-	_au1xxx_dbdma_put_dest(chanid, buf, nbytes, DDMA_FLAGS_IE)
-#define au1xxx_dbdma_put_dest_flags(chanid, buf, nbytes, flags) 	\
-	_au1xxx_dbdma_put_dest(chanid, buf, nbytes, flags)
-#define put_dest_flags(chanid, buf, nbytes, flags)			\
-	au1xxx_dbdma_put_dest_flags(chanid, buf, nbytes, flags)
-
 /*
  *	Flags for the put_source/put_dest functions.
  */

commit 22f4bb68b301f4ab896e9b3b0431fdde962242d2
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Tue Jan 26 20:39:33 2010 +0100

    MIPS: Alchemy: Fix dbdma ring destruction memory debugcheck.
    
    DBDMA descriptors need to be located at 32-byte aligned addresses;
    however kmalloc in conjunction with the SLAB allocator and
    CONFIG_DEBUG_SLUB enabled doesn't deliver any.  The dbdma code works
    around that by allocating a larger area and realigning the start
    address within it.
    
    When freeing a channel however this adjustment is not taken into
    account which results in an oops:
    
    Kernel bug detected[#1]:
    [...]
    Call Trace:
    [<80186010>] cache_free_debugcheck+0x284/0x318
    [<801869d8>] kfree+0xe8/0x2a0
    [<8010b31c>] au1xxx_dbdma_chan_free+0x2c/0x7c
    [<80388dc8>] au1x_pcm_dbdma_free+0x34/0x4c
    [<80388fa8>] au1xpsc_pcm_close+0x28/0x38
    [<80383cb8>] soc_codec_close+0x14c/0x1cc
    [<8036dbb4>] snd_pcm_release_substream+0x60/0xac
    [<8036dc40>] snd_pcm_release+0x40/0xa0
    [<8018c7a8>] __fput+0x11c/0x228
    [<80188f60>] filp_close+0x7c/0x98
    [<80189018>] sys_close+0x9c/0xe4
    [<801022a0>] stack_done+0x20/0x3c
    
    Fix this by recording the address delivered by kmalloc() and using
    it as parameter to kfree().
    
    This fix is only necessary with the SLAB allocator and CONFIG_DEBUG_SLAB
    enabled;  non-debug SLAB, SLUB do return nicely aligned addresses,
    debug-enabled SLUB currently panics early in the boot process.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Cc: Manuel Lauss <manuel.lauss@gmail.com>
    Patchwork: http://patchwork.linux-mips.org/patch/878/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
index 06f68f43800a..d206000fbfe2 100644
--- a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
+++ b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
@@ -305,6 +305,7 @@ typedef struct dbdma_chan_config {
 	dbdev_tab_t		*chan_dest;
 	au1x_dma_chan_t		*chan_ptr;
 	au1x_ddma_desc_t	*chan_desc_base;
+	u32			cdb_membase; /* kmalloc base of above */
 	au1x_ddma_desc_t	*get_ptr, *put_ptr, *cur_ptr;
 	void			*chan_callparam;
 	void			(*chan_callback)(int, void *);

commit ac15dad061d351281b0bafbae1ecdd84e601435a
Author: Manuel Lauss <mano@roarinelk.homelinux.net>
Date:   Sun Dec 21 09:26:26 2008 +0100

    MIPS: Alchemy: dbdma suspend/resume support.
    
    Implement suspend/resume for DBDMA controller and its channels.
    
    Signed-off-by: Manuel Lauss <mano@roarinelk.homelinux.net>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
index 44a67bf05dc1..06f68f43800a 100644
--- a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
+++ b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
@@ -357,6 +357,11 @@ u32 au1xxx_dbdma_put_dscr(u32 chanid, au1x_ddma_desc_t *dscr);
 u32 au1xxx_ddma_add_device(dbdev_tab_t *dev);
 extern void au1xxx_ddma_del_device(u32 devid);
 void *au1xxx_ddma_get_nextptr_virt(au1x_ddma_desc_t *dp);
+#ifdef CONFIG_PM
+void au1xxx_dbdma_suspend(void);
+void au1xxx_dbdma_resume(void);
+#endif
+
 
 /*
  * Some compatibilty macros -- needed to make changes to API

commit 384740dc49ea651ba350704d13ff6be9976e37fe
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Sep 16 19:48:51 2008 +0200

    MIPS: Move headfiles to new location below arch/mips/include
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
new file mode 100644
index 000000000000..44a67bf05dc1
--- /dev/null
+++ b/arch/mips/include/asm/mach-au1x00/au1xxx_dbdma.h
@@ -0,0 +1,386 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Include file for Alchemy Semiconductor's Au1550 Descriptor
+ *	Based DMA Controller.
+ *
+ * Copyright 2004 Embedded Edge, LLC
+ *	dan@embeddededge.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Specifics for the Au1xxx Descriptor-Based DMA Controller,
+ * first seen in the AU1550 part.
+ */
+#ifndef _AU1000_DBDMA_H_
+#define _AU1000_DBDMA_H_
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+/*
+ * The DMA base addresses.
+ * The channels are every 256 bytes (0x0100) from the channel 0 base.
+ * Interrupt status/enable is bits 15:0 for channels 15 to zero.
+ */
+#define DDMA_GLOBAL_BASE	0xb4003000
+#define DDMA_CHANNEL_BASE	0xb4002000
+
+typedef volatile struct dbdma_global {
+	u32	ddma_config;
+	u32	ddma_intstat;
+	u32	ddma_throttle;
+	u32	ddma_inten;
+} dbdma_global_t;
+
+/* General Configuration. */
+#define DDMA_CONFIG_AF		(1 << 2)
+#define DDMA_CONFIG_AH		(1 << 1)
+#define DDMA_CONFIG_AL		(1 << 0)
+
+#define DDMA_THROTTLE_EN	(1 << 31)
+
+/* The structure of a DMA Channel. */
+typedef volatile struct au1xxx_dma_channel {
+	u32	ddma_cfg;	/* See below */
+	u32	ddma_desptr;	/* 32-byte aligned pointer to descriptor */
+	u32	ddma_statptr;	/* word aligned pointer to status word */
+	u32	ddma_dbell;	/* A write activates channel operation */
+	u32	ddma_irq;	/* If bit 0 set, interrupt pending */
+	u32	ddma_stat;	/* See below */
+	u32	ddma_bytecnt;	/* Byte count, valid only when chan idle */
+	/* Remainder, up to the 256 byte boundary, is reserved. */
+} au1x_dma_chan_t;
+
+#define DDMA_CFG_SED	(1 << 9)	/* source DMA level/edge detect */
+#define DDMA_CFG_SP	(1 << 8)	/* source DMA polarity */
+#define DDMA_CFG_DED	(1 << 7)	/* destination DMA level/edge detect */
+#define DDMA_CFG_DP	(1 << 6)	/* destination DMA polarity */
+#define DDMA_CFG_SYNC	(1 << 5)	/* Sync static bus controller */
+#define DDMA_CFG_PPR	(1 << 4)	/* PCI posted read/write control */
+#define DDMA_CFG_DFN	(1 << 3)	/* Descriptor fetch non-coherent */
+#define DDMA_CFG_SBE	(1 << 2)	/* Source big endian */
+#define DDMA_CFG_DBE	(1 << 1)	/* Destination big endian */
+#define DDMA_CFG_EN	(1 << 0)	/* Channel enable */
+
+/*
+ * Always set when descriptor processing done, regardless of
+ * interrupt enable state.  Reflected in global intstat, don't
+ * clear this until global intstat is read/used.
+ */
+#define DDMA_IRQ_IN	(1 << 0)
+
+#define DDMA_STAT_DB	(1 << 2)	/* Doorbell pushed */
+#define DDMA_STAT_V	(1 << 1)	/* Descriptor valid */
+#define DDMA_STAT_H	(1 << 0)	/* Channel Halted */
+
+/*
+ * "Standard" DDMA Descriptor.
+ * Must be 32-byte aligned.
+ */
+typedef volatile struct au1xxx_ddma_desc {
+	u32	dscr_cmd0;		/* See below */
+	u32	dscr_cmd1;		/* See below */
+	u32	dscr_source0;		/* source phys address */
+	u32	dscr_source1;		/* See below */
+	u32	dscr_dest0;		/* Destination address */
+	u32	dscr_dest1;		/* See below */
+	u32	dscr_stat;		/* completion status */
+	u32	dscr_nxtptr;		/* Next descriptor pointer (mostly) */
+	/*
+	 * First 32 bytes are HW specific!!!
+	 * Lets have some SW data following -- make sure it's 32 bytes.
+	 */
+	u32	sw_status;
+	u32 	sw_context;
+	u32	sw_reserved[6];
+} au1x_ddma_desc_t;
+
+#define DSCR_CMD0_V		(1 << 31)	/* Descriptor valid */
+#define DSCR_CMD0_MEM		(1 << 30)	/* mem-mem transfer */
+#define DSCR_CMD0_SID_MASK	(0x1f << 25)	/* Source ID */
+#define DSCR_CMD0_DID_MASK	(0x1f << 20)	/* Destination ID */
+#define DSCR_CMD0_SW_MASK	(0x3 << 18)	/* Source Width */
+#define DSCR_CMD0_DW_MASK	(0x3 << 16)	/* Destination Width */
+#define DSCR_CMD0_ARB		(0x1 << 15)	/* Set for Hi Pri */
+#define DSCR_CMD0_DT_MASK	(0x3 << 13)	/* Descriptor Type */
+#define DSCR_CMD0_SN		(0x1 << 12)	/* Source non-coherent */
+#define DSCR_CMD0_DN		(0x1 << 11)	/* Destination non-coherent */
+#define DSCR_CMD0_SM		(0x1 << 10)	/* Stride mode */
+#define DSCR_CMD0_IE		(0x1 << 8)	/* Interrupt Enable */
+#define DSCR_CMD0_SP		(0x1 << 4)	/* Status pointer select */
+#define DSCR_CMD0_CV		(0x1 << 2)	/* Clear Valid when done */
+#define DSCR_CMD0_ST_MASK	(0x3 << 0)	/* Status instruction */
+
+#define SW_STATUS_INUSE 	(1 << 0)
+
+/* Command 0 device IDs. */
+#ifdef CONFIG_SOC_AU1550
+#define DSCR_CMD0_UART0_TX	0
+#define DSCR_CMD0_UART0_RX	1
+#define DSCR_CMD0_UART3_TX	2
+#define DSCR_CMD0_UART3_RX	3
+#define DSCR_CMD0_DMA_REQ0	4
+#define DSCR_CMD0_DMA_REQ1	5
+#define DSCR_CMD0_DMA_REQ2	6
+#define DSCR_CMD0_DMA_REQ3	7
+#define DSCR_CMD0_USBDEV_RX0	8
+#define DSCR_CMD0_USBDEV_TX0	9
+#define DSCR_CMD0_USBDEV_TX1	10
+#define DSCR_CMD0_USBDEV_TX2	11
+#define DSCR_CMD0_USBDEV_RX3	12
+#define DSCR_CMD0_USBDEV_RX4	13
+#define DSCR_CMD0_PSC0_TX	14
+#define DSCR_CMD0_PSC0_RX	15
+#define DSCR_CMD0_PSC1_TX	16
+#define DSCR_CMD0_PSC1_RX	17
+#define DSCR_CMD0_PSC2_TX	18
+#define DSCR_CMD0_PSC2_RX	19
+#define DSCR_CMD0_PSC3_TX	20
+#define DSCR_CMD0_PSC3_RX	21
+#define DSCR_CMD0_PCI_WRITE	22
+#define DSCR_CMD0_NAND_FLASH	23
+#define DSCR_CMD0_MAC0_RX	24
+#define DSCR_CMD0_MAC0_TX	25
+#define DSCR_CMD0_MAC1_RX	26
+#define DSCR_CMD0_MAC1_TX	27
+#endif /* CONFIG_SOC_AU1550 */
+
+#ifdef CONFIG_SOC_AU1200
+#define DSCR_CMD0_UART0_TX	0
+#define DSCR_CMD0_UART0_RX	1
+#define DSCR_CMD0_UART1_TX	2
+#define DSCR_CMD0_UART1_RX	3
+#define DSCR_CMD0_DMA_REQ0	4
+#define DSCR_CMD0_DMA_REQ1	5
+#define DSCR_CMD0_MAE_BE	6
+#define DSCR_CMD0_MAE_FE	7
+#define DSCR_CMD0_SDMS_TX0	8
+#define DSCR_CMD0_SDMS_RX0	9
+#define DSCR_CMD0_SDMS_TX1	10
+#define DSCR_CMD0_SDMS_RX1	11
+#define DSCR_CMD0_AES_TX	13
+#define DSCR_CMD0_AES_RX	12
+#define DSCR_CMD0_PSC0_TX	14
+#define DSCR_CMD0_PSC0_RX	15
+#define DSCR_CMD0_PSC1_TX	16
+#define DSCR_CMD0_PSC1_RX	17
+#define DSCR_CMD0_CIM_RXA	18
+#define DSCR_CMD0_CIM_RXB	19
+#define DSCR_CMD0_CIM_RXC	20
+#define DSCR_CMD0_MAE_BOTH	21
+#define DSCR_CMD0_LCD		22
+#define DSCR_CMD0_NAND_FLASH	23
+#define DSCR_CMD0_PSC0_SYNC	24
+#define DSCR_CMD0_PSC1_SYNC	25
+#define DSCR_CMD0_CIM_SYNC	26
+#endif /* CONFIG_SOC_AU1200 */
+
+#define DSCR_CMD0_THROTTLE	30
+#define DSCR_CMD0_ALWAYS	31
+#define DSCR_NDEV_IDS		32
+/* This macro is used to find/create custom device types */
+#define DSCR_DEV2CUSTOM_ID(x, d) (((((x) & 0xFFFF) << 8) | 0x32000000) | \
+				  ((d) & 0xFF))
+#define DSCR_CUSTOM2DEV_ID(x)	((x) & 0xFF)
+
+#define DSCR_CMD0_SID(x)	(((x) & 0x1f) << 25)
+#define DSCR_CMD0_DID(x)	(((x) & 0x1f) << 20)
+
+/* Source/Destination transfer width. */
+#define DSCR_CMD0_BYTE		0
+#define DSCR_CMD0_HALFWORD	1
+#define DSCR_CMD0_WORD		2
+
+#define DSCR_CMD0_SW(x)		(((x) & 0x3) << 18)
+#define DSCR_CMD0_DW(x)		(((x) & 0x3) << 16)
+
+/* DDMA Descriptor Type. */
+#define DSCR_CMD0_STANDARD	0
+#define DSCR_CMD0_LITERAL	1
+#define DSCR_CMD0_CMP_BRANCH	2
+
+#define DSCR_CMD0_DT(x)		(((x) & 0x3) << 13)
+
+/* Status Instruction. */
+#define DSCR_CMD0_ST_NOCHANGE	0	/* Don't change */
+#define DSCR_CMD0_ST_CURRENT	1	/* Write current status */
+#define DSCR_CMD0_ST_CMD0	2	/* Write cmd0 with V cleared */
+#define DSCR_CMD0_ST_BYTECNT	3	/* Write remaining byte count */
+
+#define DSCR_CMD0_ST(x)		(((x) & 0x3) << 0)
+
+/* Descriptor Command 1. */
+#define DSCR_CMD1_SUPTR_MASK	(0xf << 28)	/* upper 4 bits of src addr */
+#define DSCR_CMD1_DUPTR_MASK	(0xf << 24)	/* upper 4 bits of dest addr */
+#define DSCR_CMD1_FL_MASK	(0x3 << 22)	/* Flag bits */
+#define DSCR_CMD1_BC_MASK	(0x3fffff)	/* Byte count */
+
+/* Flag description. */
+#define DSCR_CMD1_FL_MEM_STRIDE0	0
+#define DSCR_CMD1_FL_MEM_STRIDE1	1
+#define DSCR_CMD1_FL_MEM_STRIDE2	2
+
+#define DSCR_CMD1_FL(x)		(((x) & 0x3) << 22)
+
+/* Source1, 1-dimensional stride. */
+#define DSCR_SRC1_STS_MASK	(3 << 30)	/* Src xfer size */
+#define DSCR_SRC1_SAM_MASK	(3 << 28)	/* Src xfer movement */
+#define DSCR_SRC1_SB_MASK	(0x3fff << 14)	/* Block size */
+#define DSCR_SRC1_SB(x)		(((x) & 0x3fff) << 14)
+#define DSCR_SRC1_SS_MASK	(0x3fff << 0)	/* Stride */
+#define DSCR_SRC1_SS(x)		(((x) & 0x3fff) << 0)
+
+/* Dest1, 1-dimensional stride. */
+#define DSCR_DEST1_DTS_MASK	(3 << 30)	/* Dest xfer size */
+#define DSCR_DEST1_DAM_MASK	(3 << 28)	/* Dest xfer movement */
+#define DSCR_DEST1_DB_MASK	(0x3fff << 14)	/* Block size */
+#define DSCR_DEST1_DB(x)	(((x) & 0x3fff) << 14)
+#define DSCR_DEST1_DS_MASK	(0x3fff << 0)	/* Stride */
+#define DSCR_DEST1_DS(x)	(((x) & 0x3fff) << 0)
+
+#define DSCR_xTS_SIZE1		0
+#define DSCR_xTS_SIZE2		1
+#define DSCR_xTS_SIZE4		2
+#define DSCR_xTS_SIZE8		3
+#define DSCR_SRC1_STS(x)	(((x) & 3) << 30)
+#define DSCR_DEST1_DTS(x)	(((x) & 3) << 30)
+
+#define DSCR_xAM_INCREMENT	0
+#define DSCR_xAM_DECREMENT	1
+#define DSCR_xAM_STATIC		2
+#define DSCR_xAM_BURST		3
+#define DSCR_SRC1_SAM(x)	(((x) & 3) << 28)
+#define DSCR_DEST1_DAM(x)	(((x) & 3) << 28)
+
+/* The next descriptor pointer. */
+#define DSCR_NXTPTR_MASK	(0x07ffffff)
+#define DSCR_NXTPTR(x)		((x) >> 5)
+#define DSCR_GET_NXTPTR(x)	((x) << 5)
+#define DSCR_NXTPTR_MS		(1 << 27)
+
+/* The number of DBDMA channels. */
+#define NUM_DBDMA_CHANS	16
+
+/*
+ * DDMA API definitions
+ * FIXME: may not fit to this header file
+ */
+typedef struct dbdma_device_table {
+	u32	dev_id;
+	u32	dev_flags;
+	u32	dev_tsize;
+	u32	dev_devwidth;
+	u32	dev_physaddr;		/* If FIFO */
+	u32	dev_intlevel;
+	u32	dev_intpolarity;
+} dbdev_tab_t;
+
+
+typedef struct dbdma_chan_config {
+	spinlock_t      lock;
+
+	u32			chan_flags;
+	u32			chan_index;
+	dbdev_tab_t		*chan_src;
+	dbdev_tab_t		*chan_dest;
+	au1x_dma_chan_t		*chan_ptr;
+	au1x_ddma_desc_t	*chan_desc_base;
+	au1x_ddma_desc_t	*get_ptr, *put_ptr, *cur_ptr;
+	void			*chan_callparam;
+	void			(*chan_callback)(int, void *);
+} chan_tab_t;
+
+#define DEV_FLAGS_INUSE		(1 << 0)
+#define DEV_FLAGS_ANYUSE	(1 << 1)
+#define DEV_FLAGS_OUT		(1 << 2)
+#define DEV_FLAGS_IN		(1 << 3)
+#define DEV_FLAGS_BURSTABLE	(1 << 4)
+#define DEV_FLAGS_SYNC		(1 << 5)
+/* end DDMA API definitions */
+
+/*
+ * External functions for drivers to use.
+ * Use this to allocate a DBDMA channel.  The device IDs are one of
+ * the DSCR_CMD0 devices IDs, which is usually redefined to a more
+ * meaningful name.  The 'callback' is called during DMA completion
+ * interrupt.
+ */
+extern u32 au1xxx_dbdma_chan_alloc(u32 srcid, u32 destid,
+				   void (*callback)(int, void *),
+				   void *callparam);
+
+#define DBDMA_MEM_CHAN	DSCR_CMD0_ALWAYS
+
+/* Set the device width of an in/out FIFO. */
+u32 au1xxx_dbdma_set_devwidth(u32 chanid, int bits);
+
+/* Allocate a ring of descriptors for DBDMA. */
+u32 au1xxx_dbdma_ring_alloc(u32 chanid, int entries);
+
+/* Put buffers on source/destination descriptors. */
+u32 _au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes, u32 flags);
+u32 _au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes, u32 flags);
+
+/* Get a buffer from the destination descriptor. */
+u32 au1xxx_dbdma_get_dest(u32 chanid, void **buf, int *nbytes);
+
+void au1xxx_dbdma_stop(u32 chanid);
+void au1xxx_dbdma_start(u32 chanid);
+void au1xxx_dbdma_reset(u32 chanid);
+u32 au1xxx_get_dma_residue(u32 chanid);
+
+void au1xxx_dbdma_chan_free(u32 chanid);
+void au1xxx_dbdma_dump(u32 chanid);
+
+u32 au1xxx_dbdma_put_dscr(u32 chanid, au1x_ddma_desc_t *dscr);
+
+u32 au1xxx_ddma_add_device(dbdev_tab_t *dev);
+extern void au1xxx_ddma_del_device(u32 devid);
+void *au1xxx_ddma_get_nextptr_virt(au1x_ddma_desc_t *dp);
+
+/*
+ * Some compatibilty macros -- needed to make changes to API
+ * without breaking existing drivers.
+ */
+#define au1xxx_dbdma_put_source(chanid, buf, nbytes)			\
+	_au1xxx_dbdma_put_source(chanid, buf, nbytes, DDMA_FLAGS_IE)
+#define au1xxx_dbdma_put_source_flags(chanid, buf, nbytes, flags)	\
+	_au1xxx_dbdma_put_source(chanid, buf, nbytes, flags)
+#define put_source_flags(chanid, buf, nbytes, flags)			\
+	au1xxx_dbdma_put_source_flags(chanid, buf, nbytes, flags)
+
+#define au1xxx_dbdma_put_dest(chanid, buf, nbytes)			\
+	_au1xxx_dbdma_put_dest(chanid, buf, nbytes, DDMA_FLAGS_IE)
+#define au1xxx_dbdma_put_dest_flags(chanid, buf, nbytes, flags) 	\
+	_au1xxx_dbdma_put_dest(chanid, buf, nbytes, flags)
+#define put_dest_flags(chanid, buf, nbytes, flags)			\
+	au1xxx_dbdma_put_dest_flags(chanid, buf, nbytes, flags)
+
+/*
+ *	Flags for the put_source/put_dest functions.
+ */
+#define DDMA_FLAGS_IE	(1 << 0)
+#define DDMA_FLAGS_NOIE (1 << 1)
+
+#endif /* _LANGUAGE_ASSEMBLY */
+#endif /* _AU1000_DBDMA_H_ */
