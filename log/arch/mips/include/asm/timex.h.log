commit 06947aaaf9bf7da0b29e211ee1a44f3ca91c08fa
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Sun Apr 6 21:31:29 2014 +0100

    MIPS: Implement random_get_entropy with CP0 Random
    
    Update to commit 9c9b415c50bc298ac61412dff856eae2f54889ee [MIPS:
    Reimplement get_cycles().]
    
    On systems were for whatever reasons we can't use the cycle counter, fall
    back to the c0_random register as an entropy source.  It has however a
    very small range that makes it suitable for random_get_entropy only and
    not get_cycles.
    
    This optimised version compiles to 8 instructions in the fast path even in
    the worst case of all the conditions to check being variable (including a
    MFC0 move delay slot that is only required for very old processors):
    
         828:       8cf90000        lw      t9,0(a3)
                            828: R_MIPS_LO16        jiffies
         82c:       40057800        mfc0    a1,c0_prid
         830:       3c0200ff        lui     v0,0xff
         834:       00a21024        and     v0,a1,v0
         838:       1040007d        beqz    v0,a30 <add_interrupt_randomness+0x22c>
         83c:       3c030000        lui     v1,0x0
                            83c: R_MIPS_HI16        cpu_data
         840:       40024800        mfc0    v0,c0_count
         844:       00000000        nop
         848:       00409021        move    s2,v0
         84c:       8ce20000        lw      v0,0(a3)
                            84c: R_MIPS_LO16        jiffies
    
    On most targets the sequence will be shorter and on some it will reduce to
    a single `MFC0 <reg>,c0_count', as all MIPS architecture (i.e. non-legacy
    MIPS) processors require the CP0 Count register to be present.
    
    The only known exception that reports MIPS architecture compliance, but
    contrary to that lacks CP0 Count is the Ingenic JZ4740 thingy.  For broken
    platforms like that this code requires cpu_has_counter to be hardcoded to
    0 (i.e. no variable setting is permitted) so as not to penalise all the
    other good platforms out there.
    
    The asm barrier is required so that the compiler does not pull any
    potentially costly (cold cache!) `cpu_data' variable access into the fast
    path.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: John Crispin <blogic@openwrt.org>
    Cc: Andrew McGregor <andrewmcgr@gmail.com>
    Cc: Dave Taht <dave.taht@bufferbloat.net>
    Cc: Felix Fietkau <nbd@nbd.name>
    Cc: Simon Kelley <simon@thekelleys.org.uk>
    Cc: Jim Gettys <jg@freedesktop.org>
    Cc: David Daney <ddaney@caviumnetworks.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/6702/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/timex.h b/arch/mips/include/asm/timex.h
index c5424757da65..b05bb70a2e46 100644
--- a/arch/mips/include/asm/timex.h
+++ b/arch/mips/include/asm/timex.h
@@ -4,12 +4,16 @@
  * for more details.
  *
  * Copyright (C) 1998, 1999, 2003 by Ralf Baechle
+ * Copyright (C) 2014 by Maciej W. Rozycki
  */
 #ifndef _ASM_TIMEX_H
 #define _ASM_TIMEX_H
 
 #ifdef __KERNEL__
 
+#include <linux/compiler.h>
+
+#include <asm/cpu.h>
 #include <asm/cpu-features.h>
 #include <asm/mipsregs.h>
 #include <asm/cpu-type.h>
@@ -45,29 +49,54 @@ typedef unsigned int cycles_t;
  * However for now the implementaton of this function doesn't get these
  * fine details right.
  */
-static inline cycles_t get_cycles(void)
+static inline int can_use_mips_counter(unsigned int prid)
 {
-	switch (boot_cpu_type()) {
-	case CPU_R4400PC:
-	case CPU_R4400SC:
-	case CPU_R4400MC:
-		if ((read_c0_prid() & 0xff) >= 0x0050)
-			return read_c0_count();
-		break;
+	int comp = (prid & PRID_COMP_MASK) != PRID_COMP_LEGACY;
 
-        case CPU_R4000PC:
-        case CPU_R4000SC:
-        case CPU_R4000MC:
-		break;
+	if (__builtin_constant_p(cpu_has_counter) && !cpu_has_counter)
+		return 0;
+	else if (__builtin_constant_p(cpu_has_mips_r) && cpu_has_mips_r)
+		return 1;
+	else if (likely(!__builtin_constant_p(cpu_has_mips_r) && comp))
+		return 1;
+	/* Make sure we don't peek at cpu_data[0].options in the fast path! */
+	if (!__builtin_constant_p(cpu_has_counter))
+		asm volatile("" : "=m" (cpu_data[0].options));
+	if (likely(cpu_has_counter &&
+		   prid >= (PRID_IMP_R4000 | PRID_REV_ENCODE_44(5, 0))))
+		return 1;
+	else
+		return 0;
+}
 
-	default:
-		if (cpu_has_counter)
-			return read_c0_count();
-		break;
-	}
+static inline cycles_t get_cycles(void)
+{
+	if (can_use_mips_counter(read_c0_prid()))
+		return read_c0_count();
+	else
+		return 0;	/* no usable counter */
+}
+
+/*
+ * Like get_cycles - but where c0_count is not available we desperately
+ * use c0_random in an attempt to get at least a little bit of entropy.
+ *
+ * R6000 and R6000A neither have a count register nor a random register.
+ * That leaves no entropy source in the CPU itself.
+ */
+static inline unsigned long random_get_entropy(void)
+{
+	unsigned int prid = read_c0_prid();
+	unsigned int imp = prid & PRID_IMP_MASK;
 
-	return 0;	/* no usable counter */
+	if (can_use_mips_counter(prid))
+		return read_c0_count();
+	else if (likely(imp != PRID_IMP_R6000 && imp != PRID_IMP_R6000A))
+		return read_c0_random();
+	else
+		return 0;	/* no usable register */
 }
+#define random_get_entropy random_get_entropy
 
 #endif /* __KERNEL__ */
 

commit 9c9b415c50bc298ac61412dff856eae2f54889ee
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Sep 12 13:47:32 2013 +0200

    MIPS: Reimplement get_cycles().
    
    This essentially reverts commit efb9ca08b5a2374b29938cdcab417ce4feb14b54
    (kernel.org) / 58020a106879a8b372068741c81f0015c9b0b96dbv [[MIPS] Change
    get_cycles to always return 0.]
    
    Most users of get_cycles() invoke it as a timing interface.  That's why
    in modern kernels it was never very much missed for.  /dev/random however
    uses get_cycles() in the how the jitter in the interrupt timing contains
    some useful entropy.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/timex.h b/arch/mips/include/asm/timex.h
index 6529704aa73a..c5424757da65 100644
--- a/arch/mips/include/asm/timex.h
+++ b/arch/mips/include/asm/timex.h
@@ -10,7 +10,9 @@
 
 #ifdef __KERNEL__
 
+#include <asm/cpu-features.h>
 #include <asm/mipsregs.h>
+#include <asm/cpu-type.h>
 
 /*
  * This is the clock rate of the i8253 PIT.  A MIPS system may not have
@@ -33,9 +35,38 @@
 
 typedef unsigned int cycles_t;
 
+/*
+ * On R4000/R4400 before version 5.0 an erratum exists such that if the
+ * cycle counter is read in the exact moment that it is matching the
+ * compare register, no interrupt will be generated.
+ *
+ * There is a suggested workaround and also the erratum can't strike if
+ * the compare interrupt isn't being used as the clock source device.
+ * However for now the implementaton of this function doesn't get these
+ * fine details right.
+ */
 static inline cycles_t get_cycles(void)
 {
-	return 0;
+	switch (boot_cpu_type()) {
+	case CPU_R4400PC:
+	case CPU_R4400SC:
+	case CPU_R4400MC:
+		if ((read_c0_prid() & 0xff) >= 0x0050)
+			return read_c0_count();
+		break;
+
+        case CPU_R4000PC:
+        case CPU_R4000SC:
+        case CPU_R4000MC:
+		break;
+
+	default:
+		if (cpu_has_counter)
+			return read_c0_count();
+		break;
+	}
+
+	return 0;	/* no usable counter */
 }
 
 #endif /* __KERNEL__ */

commit 384740dc49ea651ba350704d13ff6be9976e37fe
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Sep 16 19:48:51 2008 +0200

    MIPS: Move headfiles to new location below arch/mips/include
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/timex.h b/arch/mips/include/asm/timex.h
new file mode 100644
index 000000000000..6529704aa73a
--- /dev/null
+++ b/arch/mips/include/asm/timex.h
@@ -0,0 +1,43 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1998, 1999, 2003 by Ralf Baechle
+ */
+#ifndef _ASM_TIMEX_H
+#define _ASM_TIMEX_H
+
+#ifdef __KERNEL__
+
+#include <asm/mipsregs.h>
+
+/*
+ * This is the clock rate of the i8253 PIT.  A MIPS system may not have
+ * a PIT by the symbol is used all over the kernel including some APIs.
+ * So keeping it defined to the number for the PIT is the only sane thing
+ * for now.
+ */
+#define CLOCK_TICK_RATE 1193182
+
+/*
+ * Standard way to access the cycle counter.
+ * Currently only used on SMP for scheduling.
+ *
+ * Only the low 32 bits are available as a continuously counting entity.
+ * But this only means we'll force a reschedule every 8 seconds or so,
+ * which isn't an evil thing.
+ *
+ * We know that all SMP capable CPUs have cycle counters.
+ */
+
+typedef unsigned int cycles_t;
+
+static inline cycles_t get_cycles(void)
+{
+	return 0;
+}
+
+#endif /* __KERNEL__ */
+
+#endif /*  _ASM_TIMEX_H */
