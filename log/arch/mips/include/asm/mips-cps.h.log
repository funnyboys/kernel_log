commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/include/asm/mips-cps.h b/arch/mips/include/asm/mips-cps.h
index 8ad4a85eed0c..fd43d876892e 100644
--- a/arch/mips/include/asm/mips-cps.h
+++ b/arch/mips/include/asm/mips-cps.h
@@ -1,11 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Copyright (C) 2017 Imagination Technologies
  * Author: Paul Burton <paul.burton@mips.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
  */
 
 #ifndef __MIPS_ASM_MIPS_CPS_H__

commit fb615d61b5583db92e3793709b97e35dc9499c2a
Author: Paul Burton <paul.burton@mips.com>
Date:   Wed Oct 25 17:04:33 2017 -0700

    Update MIPS email addresses
    
    MIPS will soon not be a part of Imagination Technologies, and as such
    many @imgtec.com email addresses will no longer be valid. This patch
    updates the addresses for those who:
    
     - Have 10 or more patches in mainline authored using an @imgtec.com
       email address, or any patches dated within the past year.
    
     - Are still with Imagination but leaving as part of the MIPS business
       unit, as determined from an internal email address list.
    
     - Haven't already updated their email address (ie. JamesH) or expressed
       a desire to be excluded (ie. Maciej).
    
     - Acked v2 or earlier of this patch, which leaves Deng-Cheng, Matt &
       myself.
    
    New addresses are of the form firstname.lastname@mips.com, and all
    verified against an internal email address list.  An entry is added to
    .mailmap for each person such that get_maintainer.pl will report the new
    addresses rather than @imgtec.com addresses which will soon be dead.
    
    Instances of the affected addresses throughout the tree are then
    mechanically replaced with the new @mips.com address.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Deng-Cheng Zhu <dengcheng.zhu@imgtec.com>
    Cc: Deng-Cheng Zhu <dengcheng.zhu@mips.com>
    Acked-by: Dengcheng Zhu <dengcheng.zhu@mips.com>
    Cc: Matt Redfearn <matt.redfearn@imgtec.com>
    Cc: Matt Redfearn <matt.redfearn@mips.com>
    Acked-by: Matt Redfearn <matt.redfearn@mips.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Cc: trivial@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/include/asm/mips-cps.h b/arch/mips/include/asm/mips-cps.h
index bf02b5070a98..8ad4a85eed0c 100644
--- a/arch/mips/include/asm/mips-cps.h
+++ b/arch/mips/include/asm/mips-cps.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2017 Imagination Technologies
- * Author: Paul Burton <paul.burton@imgtec.com>
+ * Author: Paul Burton <paul.burton@mips.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the

commit 582e2b4aecdacc0a3bd39daa63648a88cad6a26f
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Sat Aug 12 21:36:10 2017 -0700

    MIPS: GIC: Introduce asm/mips-gic.h with accessor functions
    
    This patch introduces a new header providing accessor functions for the
    MIPS Global Interrupt Controller (GIC) mirroring those provided for the
    other 2 components of the MIPS Coherent Processing System (CPS) - the
    Coherence Manager (CM) & Cluster Power Controller (CPC).
    
    This header makes use of the new standardised CPS accessor macros where
    possible, but does require some custom accessors for cases where we have
    either a bit or a register per interrupt.
    
    A major advantage of this over the existing
    include/linux/irqchip/mips-gic.h definitions is that code performing
    accesses can become much simpler, for example this:
    
      gic_update_bits(GIC_REG(SHARED, GIC_SH_SET_TRIGGER) +
                      GIC_INTR_OFS(intr), 1ul << GIC_INTR_BIT(intr),
                      (unsigned long)trig << GIC_INTR_BIT(intr));
    
    ...can become simply:
    
      change_gic_trig(intr, trig);
    
    The accessors handle 32 vs 64 bit in the same way as for CM & CPC code,
    which means that GIC code will also not need to worry about the access
    size in most cases. They are also accessible outside of
    drivers/irqchip/irq-mips-gic.c which will allow for simplification in
    the use of the non-interrupt portions of the GIC (eg. counters) which
    currently require the interrupt controller driver to expose helper
    functions for access.
    
    This patch doesn't change any existing code over to use the new
    accessors yet, since a wholesale change would be invasive & difficult to
    review. Instead follow-on patches will convert code piecemeal to use
    this new header. The one change to existing code is to rename gic_base
    to mips_gic_base & make it global, in order to fit in with the naming
    expected by the standardised CPS accessor macros.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/17020/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mips-cps.h b/arch/mips/include/asm/mips-cps.h
index 2dd737d803e1..bf02b5070a98 100644
--- a/arch/mips/include/asm/mips-cps.h
+++ b/arch/mips/include/asm/mips-cps.h
@@ -107,6 +107,7 @@ static inline void clear_##unit##_##name(uint##sz##_t val)		\
 
 #include <asm/mips-cm.h>
 #include <asm/mips-cpc.h>
+#include <asm/mips-gic.h>
 
 /**
  * mips_cps_numclusters - return the number of clusters present in the system

commit 3c9b4166213d415afa09bf2be104074f3a1161c8
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Sat Aug 12 19:49:42 2017 -0700

    MIPS: CPS: Cluster support for topology functions
    
    Modify the functions we use to read information about the topology of
    the system (the number of cores, VPs & IOCUs that it contains) in order
    to take into account multiple clusters, and provide a new function to
    determine the number of clusters in the system.
    
    Users of these functions are modified only such that they continue to
    build successfully - having them actually handle multiple clusters is
    left to further patches.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/17016/
    Patchwork: https://patchwork.linux-mips.org/patch/17218/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mips-cps.h b/arch/mips/include/asm/mips-cps.h
index 2ac88ed4b381..2dd737d803e1 100644
--- a/arch/mips/include/asm/mips-cps.h
+++ b/arch/mips/include/asm/mips-cps.h
@@ -108,4 +108,132 @@ static inline void clear_##unit##_##name(uint##sz##_t val)		\
 #include <asm/mips-cm.h>
 #include <asm/mips-cpc.h>
 
+/**
+ * mips_cps_numclusters - return the number of clusters present in the system
+ *
+ * Returns the number of clusters in the system.
+ */
+static inline unsigned int mips_cps_numclusters(void)
+{
+	unsigned int num_clusters;
+
+	if (mips_cm_revision() < CM_REV_CM3_5)
+		return 1;
+
+	num_clusters = read_gcr_config() & CM_GCR_CONFIG_NUM_CLUSTERS;
+	num_clusters >>= __ffs(CM_GCR_CONFIG_NUM_CLUSTERS);
+	return num_clusters;
+}
+
+/**
+ * mips_cps_cluster_config - return (GCR|CPC)_CONFIG from a cluster
+ * @cluster: the ID of the cluster whose config we want
+ *
+ * Read the value of GCR_CONFIG (or its CPC_CONFIG mirror) from a @cluster.
+ *
+ * Returns the value of GCR_CONFIG.
+ */
+static inline uint64_t mips_cps_cluster_config(unsigned int cluster)
+{
+	uint64_t config;
+
+	if (mips_cm_revision() < CM_REV_CM3_5) {
+		/*
+		 * Prior to CM 3.5 we don't have the notion of multiple
+		 * clusters so we can trivially read the GCR_CONFIG register
+		 * within this cluster.
+		 */
+		WARN_ON(cluster != 0);
+		config = read_gcr_config();
+	} else {
+		/*
+		 * From CM 3.5 onwards we read the CPC_CONFIG mirror of
+		 * GCR_CONFIG via the redirect region, since the CPC is always
+		 * powered up allowing us not to need to power up the CM.
+		 */
+		mips_cm_lock_other(cluster, 0, 0, CM_GCR_Cx_OTHER_BLOCK_GLOBAL);
+		config = read_cpc_redir_config();
+		mips_cm_unlock_other();
+	}
+
+	return config;
+}
+
+/**
+ * mips_cps_numcores - return the number of cores present in a cluster
+ * @cluster: the ID of the cluster whose core count we want
+ *
+ * Returns the value of the PCORES field of the GCR_CONFIG register plus 1, or
+ * zero if no Coherence Manager is present.
+ */
+static inline unsigned int mips_cps_numcores(unsigned int cluster)
+{
+	if (!mips_cm_present())
+		return 0;
+
+	/* Add one before masking to handle 0xff indicating no cores */
+	return (mips_cps_cluster_config(cluster) + 1) & CM_GCR_CONFIG_PCORES;
+}
+
+/**
+ * mips_cps_numiocu - return the number of IOCUs present in a cluster
+ * @cluster: the ID of the cluster whose IOCU count we want
+ *
+ * Returns the value of the NUMIOCU field of the GCR_CONFIG register, or zero
+ * if no Coherence Manager is present.
+ */
+static inline unsigned int mips_cps_numiocu(unsigned int cluster)
+{
+	unsigned int num_iocu;
+
+	if (!mips_cm_present())
+		return 0;
+
+	num_iocu = mips_cps_cluster_config(cluster) & CM_GCR_CONFIG_NUMIOCU;
+	num_iocu >>= __ffs(CM_GCR_CONFIG_NUMIOCU);
+	return num_iocu;
+}
+
+/**
+ * mips_cps_numvps - return the number of VPs (threads) supported by a core
+ * @cluster: the ID of the cluster containing the core we want to examine
+ * @core: the ID of the core whose VP count we want
+ *
+ * Returns the number of Virtual Processors (VPs, ie. hardware threads) that
+ * are supported by the given @core in the given @cluster. If the core or the
+ * kernel do not support hardware mutlti-threading this returns 1.
+ */
+static inline unsigned int mips_cps_numvps(unsigned int cluster, unsigned int core)
+{
+	unsigned int cfg;
+
+	if (!mips_cm_present())
+		return 1;
+
+	if ((!IS_ENABLED(CONFIG_MIPS_MT_SMP) || !cpu_has_mipsmt)
+		&& (!IS_ENABLED(CONFIG_CPU_MIPSR6) || !cpu_has_vp))
+		return 1;
+
+	mips_cm_lock_other(cluster, core, 0, CM_GCR_Cx_OTHER_BLOCK_LOCAL);
+
+	if (mips_cm_revision() < CM_REV_CM3_5) {
+		/*
+		 * Prior to CM 3.5 we can only have one cluster & don't have
+		 * CPC_Cx_CONFIG, so we read GCR_Cx_CONFIG.
+		 */
+		cfg = read_gcr_co_config();
+	} else {
+		/*
+		 * From CM 3.5 onwards we read CPC_Cx_CONFIG because the CPC is
+		 * always powered, which allows us to not worry about powering
+		 * up the cluster's CM here.
+		 */
+		cfg = read_cpc_co_config();
+	}
+
+	mips_cm_unlock_other();
+
+	return (cfg + 1) & CM_GCR_Cx_CONFIG_PVPE;
+}
+
 #endif /* __MIPS_ASM_MIPS_CPS_H__ */

commit e83f7e02af50c763ed9f953b565a4fbce6235fdf
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Sat Aug 12 19:49:41 2017 -0700

    MIPS: CPS: Have asm/mips-cps.h include CM & CPC headers
    
    With Coherence Manager (CM) 3.5 information about the topology of the
    system, which has previously only been available through & accessed from
    the CM, is now also provided by the Cluster Power Controller (CPC). This
    includes a new CPC_CONFIG register mirroring GCR_CONFIG, and similarly a
    new CPC_Cx_CONFIG register mirroring GCR_Cx_CONFIG.
    
    In preparation for adjusting functions such as mips_cm_numcores(), which
    have previously only needed to access the CM, to also access the CPC
    this patch modifies the way we use the various CPS headers. Rather than
    having users include asm/mips-cm.h or asm/mips-cpc.h individually we
    instead have users include asm/mips-cps.h which in turn includes
    asm/mips-cm.h & asm/mips-cpc.h. This means that users will gain access
    to both CM & CPC registers by including one header, and most importantly
    it makes asm/mips-cps.h an ideal location for helper functions which
    need to access the various components of the CPS.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/17015/
    Patchwork: https://patchwork.linux-mips.org/patch/17217/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mips-cps.h b/arch/mips/include/asm/mips-cps.h
index 7ae32ad15599..2ac88ed4b381 100644
--- a/arch/mips/include/asm/mips-cps.h
+++ b/arch/mips/include/asm/mips-cps.h
@@ -105,4 +105,7 @@ static inline void clear_##unit##_##name(uint##sz##_t val)		\
 	CPS_ACCESSOR_W(unit, sz, name)					\
 	CPS_ACCESSOR_M(unit, sz, name)
 
+#include <asm/mips-cm.h>
+#include <asm/mips-cpc.h>
+
 #endif /* __MIPS_ASM_MIPS_CPS_H__ */

commit ed7eb5aad7d4e4945fac664c9b67d0db2a8a3db8
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Sat Aug 12 19:49:30 2017 -0700

    MIPS: CPS: Introduce register modify (set/clear/change) accessors
    
    For read-write registers introduce accessor functions that simplify the
    task of modifying a subset of bits within the register. set_* functions
    set bits to 1, clear_* functions clear bits to 0 & change_* functions
    set bits specified in a mask to an arbitrary value.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/17004/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mips-cps.h b/arch/mips/include/asm/mips-cps.h
index 6ced7ba102b6..7ae32ad15599 100644
--- a/arch/mips/include/asm/mips-cps.h
+++ b/arch/mips/include/asm/mips-cps.h
@@ -71,6 +71,26 @@ static inline void write_##unit##_##name(uint##sz##_t val)		\
 	}								\
 }
 
+#define CPS_ACCESSOR_M(unit, sz, name)					\
+static inline void change_##unit##_##name(uint##sz##_t mask,		\
+					  uint##sz##_t val)		\
+{									\
+	uint##sz##_t reg_val = read_##unit##_##name();			\
+	reg_val &= ~mask;						\
+	reg_val |= val;							\
+	write_##unit##_##name(reg_val);					\
+}									\
+									\
+static inline void set_##unit##_##name(uint##sz##_t val)		\
+{									\
+	change_##unit##_##name(val, val);				\
+}									\
+									\
+static inline void clear_##unit##_##name(uint##sz##_t val)		\
+{									\
+	change_##unit##_##name(val, 0);					\
+}
+
 #define CPS_ACCESSOR_RO(unit, sz, off, name)				\
 	CPS_ACCESSOR_A(unit, off, name)					\
 	CPS_ACCESSOR_R(unit, sz, name)
@@ -82,6 +102,7 @@ static inline void write_##unit##_##name(uint##sz##_t val)		\
 #define CPS_ACCESSOR_RW(unit, sz, off, name)				\
 	CPS_ACCESSOR_A(unit, off, name)					\
 	CPS_ACCESSOR_R(unit, sz, name)					\
-	CPS_ACCESSOR_W(unit, sz, name)
+	CPS_ACCESSOR_W(unit, sz, name)					\
+	CPS_ACCESSOR_M(unit, sz, name)
 
 #endif /* __MIPS_ASM_MIPS_CPS_H__ */

commit b025d51873d5fe6f05f8e94174282cb00ef1f489
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Sat Aug 12 19:49:26 2017 -0700

    MIPS: CM: Specify register size when generating accessors
    
    Some CM registers are always 32 bits, or at least only use bits in the
    lower 32 bits of the register. For these registers it is wasteful for us
    to generate accessors which bother to check mips_cm_is64 & perform 64
    bit accesses.
    
    This patch modifies the accessor generation to take into account the
    size of the register, and for 32 bit registers we generate accessors
    which only ever perform 32 bit accesses. For 64 bit registers we either
    perform a 64 bit access or two 32 bit accesses, depending upon the value
    of mips_cm_is64. Doing this saves us ~1.5KiB of code in a generic 64r6el
    kernel, and perhaps more importantly simplifies various code paths.
    
    This removes the read64_gcr_* accessors, so mips_cm_error_report() is
    modified to stop using them & instead use the regular read_gcr_*
    accessors which will return 64 bit values from the 64 bit registers.
    
    The new accessor macros are placed in asm/mips-cps.h such that they can
    be shared by CPC & GIC code in later patches.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/17000/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/mips-cps.h b/arch/mips/include/asm/mips-cps.h
new file mode 100644
index 000000000000..6ced7ba102b6
--- /dev/null
+++ b/arch/mips/include/asm/mips-cps.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2017 Imagination Technologies
+ * Author: Paul Burton <paul.burton@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __MIPS_ASM_MIPS_CPS_H__
+#define __MIPS_ASM_MIPS_CPS_H__
+
+#include <linux/io.h>
+#include <linux/types.h>
+
+extern unsigned long __cps_access_bad_size(void)
+	__compiletime_error("Bad size for CPS accessor");
+
+#define CPS_ACCESSOR_A(unit, off, name)					\
+static inline void *addr_##unit##_##name(void)				\
+{									\
+	return mips_##unit##_base + (off);				\
+}
+
+#define CPS_ACCESSOR_R(unit, sz, name)					\
+static inline uint##sz##_t read_##unit##_##name(void)			\
+{									\
+	uint64_t val64;							\
+									\
+	switch (sz) {							\
+	case 32:							\
+		return __raw_readl(addr_##unit##_##name());		\
+									\
+	case 64:							\
+		if (mips_cm_is64)					\
+			return __raw_readq(addr_##unit##_##name());	\
+									\
+		val64 = __raw_readl(addr_##unit##_##name() + 4);	\
+		val64 <<= 32;						\
+		val64 |= __raw_readl(addr_##unit##_##name());		\
+		return val64;						\
+									\
+	default:							\
+		return __cps_access_bad_size();				\
+	}								\
+}
+
+#define CPS_ACCESSOR_W(unit, sz, name)					\
+static inline void write_##unit##_##name(uint##sz##_t val)		\
+{									\
+	switch (sz) {							\
+	case 32:							\
+		__raw_writel(val, addr_##unit##_##name());		\
+		break;							\
+									\
+	case 64:							\
+		if (mips_cm_is64) {					\
+			__raw_writeq(val, addr_##unit##_##name());	\
+			break;						\
+		}							\
+									\
+		__raw_writel((uint64_t)val >> 32,			\
+			     addr_##unit##_##name() + 4);		\
+		__raw_writel(val, addr_##unit##_##name());		\
+		break;							\
+									\
+	default:							\
+		__cps_access_bad_size();				\
+		break;							\
+	}								\
+}
+
+#define CPS_ACCESSOR_RO(unit, sz, off, name)				\
+	CPS_ACCESSOR_A(unit, off, name)					\
+	CPS_ACCESSOR_R(unit, sz, name)
+
+#define CPS_ACCESSOR_WO(unit, sz, off, name)				\
+	CPS_ACCESSOR_A(unit, off, name)					\
+	CPS_ACCESSOR_W(unit, sz, name)
+
+#define CPS_ACCESSOR_RW(unit, sz, off, name)				\
+	CPS_ACCESSOR_A(unit, off, name)					\
+	CPS_ACCESSOR_R(unit, sz, name)					\
+	CPS_ACCESSOR_W(unit, sz, name)
+
+#endif /* __MIPS_ASM_MIPS_CPS_H__ */
