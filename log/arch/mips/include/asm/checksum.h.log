commit 96d4f267e40f9509e8a66e2b39e8b95655617693
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 3 18:57:57 2019 -0800

    Remove 'type' argument from access_ok() function
    
    Nobody has actually used the type (VERIFY_READ vs VERIFY_WRITE) argument
    of the user address range verification function since we got rid of the
    old racy i386-only code to walk page tables by hand.
    
    It existed because the original 80386 would not honor the write protect
    bit when in kernel mode, so you had to do COW by hand before doing any
    user access.  But we haven't supported that in a long time, and these
    days the 'type' argument is a purely historical artifact.
    
    A discussion about extending 'user_access_begin()' to do the range
    checking resulted this patch, because there is no way we're going to
    move the old VERIFY_xyz interface to that model.  And it's best done at
    the end of the merge window when I've done most of my merges, so let's
    just get this done once and for all.
    
    This patch was mostly done with a sed-script, with manual fix-ups for
    the cases that weren't of the trivial 'access_ok(VERIFY_xyz' form.
    
    There were a couple of notable cases:
    
     - csky still had the old "verify_area()" name as an alias.
    
     - the iter_iov code had magical hardcoded knowledge of the actual
       values of VERIFY_{READ,WRITE} (not that they mattered, since nothing
       really used it)
    
     - microblaze used the type argument for a debug printout
    
    but other than those oddities this should be a total no-op patch.
    
    I tried to fix up all architectures, did fairly extensive grepping for
    access_ok() uses, and the changes are trivial, but I may have missed
    something.  Any missed conversion should be trivially fixable, though.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
index e8161e4dfde7..dcebaaf8c862 100644
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -63,7 +63,7 @@ static inline
 __wsum csum_and_copy_from_user(const void __user *src, void *dst,
 			       int len, __wsum sum, int *err_ptr)
 {
-	if (access_ok(VERIFY_READ, src, len))
+	if (access_ok(src, len))
 		return csum_partial_copy_from_user(src, dst, len, sum,
 						   err_ptr);
 	if (len)
@@ -81,7 +81,7 @@ __wsum csum_and_copy_to_user(const void *src, void __user *dst, int len,
 			     __wsum sum, int *err_ptr)
 {
 	might_fault();
-	if (access_ok(VERIFY_WRITE, dst, len)) {
+	if (access_ok(dst, len)) {
 		if (uaccess_kernel())
 			return __csum_partial_copy_kernel(src,
 							  (__force void *)dst,

commit cc4804448c321a82309756be68a5bac7cb1740d0
Author: Luis de Bethencourt <luisbg@kernel.org>
Date:   Tue Jan 23 13:38:03 2018 +0000

    MIPS: Fix trailing semicolon
    
    The trailing semicolon is an empty statement that does no operation.
    Removing it since it doesn't do anything.
    
    Fixes: d0f0f63ac137 ("MIPS: Rewrite csum_fold to plain C.")
    Signed-off-by: Luis de Bethencourt <luisbg@kernel.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/18517/
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
index 77cad232a1c6..e8161e4dfde7 100644
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -110,7 +110,7 @@ __wsum csum_partial_copy_nocheck(const void *src, void *dst,
  */
 static inline __sum16 csum_fold(__wsum csum)
 {
-	u32 sum = (__force u32)csum;;
+	u32 sum = (__force u32)csum;
 
 	sum += (sum << 16);
 	csum = (sum < csum);

commit db68ce10c4f0a27c1ff9fa0e789e5c41f8c4ea63
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Mar 20 21:08:07 2017 -0400

    new helper: uaccess_kernel()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
index c8b574f7e0cc..77cad232a1c6 100644
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -50,7 +50,7 @@ __wsum csum_partial_copy_from_user(const void __user *src, void *dst, int len,
 				   __wsum sum, int *err_ptr)
 {
 	might_fault();
-	if (segment_eq(get_fs(), get_ds()))
+	if (uaccess_kernel())
 		return __csum_partial_copy_kernel((__force void *)src, dst,
 						  len, sum, err_ptr);
 	else
@@ -82,7 +82,7 @@ __wsum csum_and_copy_to_user(const void *src, void __user *dst, int len,
 {
 	might_fault();
 	if (access_ok(VERIFY_WRITE, dst, len)) {
-		if (segment_eq(get_fs(), get_ds()))
+		if (uaccess_kernel())
 			return __csum_partial_copy_kernel(src,
 							  (__force void *)dst,
 							  len, sum, err_ptr);

commit 66fd848cadaa6be974a8c780fbeb328f0af4d3bd
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Jan 26 02:16:47 2017 +0100

    MIPS: Fix special case in 64 bit IP checksumming.
    
    For certain arguments such as saddr = 0xc0a8fd60, daddr = 0xc0a8fda1,
    len = 80, proto = 17, sum = 0x7eae049d there will be a carry when
    folding the intermediate 64 bit checksum to 32 bit but the code doesn't
    add the carry back to the one's complement sum, thus an incorrect result
    will be generated.
    
    Reported-by: Mark Zhang <bomb.zhang@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Reviewed-by: James Hogan <james.hogan@imgtec.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: James Hogan <james.hogan@imgtec.com>

diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
index 7749daf2a465..c8b574f7e0cc 100644
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -186,7 +186,9 @@ static inline __wsum csum_tcpudp_nofold(__be32 saddr, __be32 daddr,
 	"	daddu	%0, %4		\n"
 	"	dsll32	$1, %0, 0	\n"
 	"	daddu	%0, $1		\n"
+	"	sltu	$1, %0, $1	\n"
 	"	dsra32	%0, %0, 0	\n"
+	"	addu	%0, $1		\n"
 #endif
 	"	.set	pop"
 	: "=r" (sum)

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
index bce1ce53149a..7749daf2a465 100644
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -18,7 +18,7 @@
 
 #include <linux/in6.h>
 
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 /*
  * computes the checksum of a memory block at buff, length len,

commit 1e94082963747b551b129528714827f76a090e93
Author: Alexander Duyck <aduyck@mirantis.com>
Date:   Fri Mar 11 14:05:41 2016 -0800

    ipv6: Pass proto to csum_ipv6_magic as __u8 instead of unsigned short
    
    This patch updates csum_ipv6_magic so that it correctly recognizes that
    protocol is a unsigned 8 bit value.
    
    This will allow us to better understand what limitations may or may not be
    present in how we handle the data.  For example there are a number of
    places that call htonl on the protocol value.  This is likely not necessary
    and can be replaced with a multiplication by ntohl(1) which will be
    converted to a shift by the compiler.
    
    Signed-off-by: Alexander Duyck <aduyck@mirantis.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
index c635541d40b8..bce1ce53149a 100644
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -215,7 +215,7 @@ static inline __sum16 ip_compute_csum(const void *buff, int len)
 #define _HAVE_ARCH_IPV6_CSUM
 static __inline__ __sum16 csum_ipv6_magic(const struct in6_addr *saddr,
 					  const struct in6_addr *daddr,
-					  __u32 len, unsigned short proto,
+					  __u32 len, __u8 proto,
 					  __wsum sum)
 {
 	__wsum tmp;

commit 01cfbad79a5e2b835abf6a8154a341d75a6fc8cd
Author: Alexander Duyck <aduyck@mirantis.com>
Date:   Fri Mar 11 14:05:34 2016 -0800

    ipv4: Update parameters for csum_tcpudp_magic to their original types
    
    This patch updates all instances of csum_tcpudp_magic and
    csum_tcpudp_nofold to reflect the types that are usually used as the source
    inputs.  For example the protocol field is populated based on nexthdr which
    is actually an unsigned 8 bit value.  The length is usually populated based
    on skb->len which is an unsigned integer.
    
    This addresses an issue in which the IPv6 function csum_ipv6_magic was
    generating a checksum using the full 32b of skb->len while
    csum_tcpudp_magic was only using the lower 16 bits.  As a result we could
    run into issues when attempting to adjust the checksum as there was no
    protocol agnostic way to update it.
    
    With this change the value is still truncated as many architectures use
    "(len + proto) << 8", however this truncation only occurs for values
    greater than 16776960 in length and as such is unlikely to occur as we stop
    the inner headers at ~64K in size.
    
    I did have to make a few minor changes in the arm, mn10300, nios2, and
    score versions of the function in order to support these changes as they
    were either using things such as an OR to combine the protocol and length,
    or were using ntohs to convert the length which would have truncated the
    value.
    
    I also updated a few spots in terms of whitespace and type differences for
    the addresses.  Most of this was just to make sure all of the definitions
    were in sync going forward.
    
    Signed-off-by: Alexander Duyck <aduyck@mirantis.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
index 3ceacde5eb6e..c635541d40b8 100644
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -160,9 +160,9 @@ static inline __sum16 ip_fast_csum(const void *iph, unsigned int ihl)
 }
 #define ip_fast_csum ip_fast_csum
 
-static inline __wsum csum_tcpudp_nofold(__be32 saddr,
-	__be32 daddr, unsigned short len, unsigned short proto,
-	__wsum sum)
+static inline __wsum csum_tcpudp_nofold(__be32 saddr, __be32 daddr,
+					__u32 len, __u8 proto,
+					__wsum sum)
 {
 	__asm__(
 	"	.set	push		# csum_tcpudp_nofold\n"

commit 20c82d93d3c284700c7749f51d4eff3eaaf3e13f
Author: Daniel Sanders <daniel.sanders@imgtec.com>
Date:   Tue Feb 24 15:25:10 2015 +0000

    MIPS: LLVMLinux: Fix an 'inline asm input/output type mismatch' error.
    
    Replace incorrect matching constraint that caused the error with an alternative
    that still has the required constraints on the inline assembly.
    
    This is the error message reported by clang:
    arch/mips/include/asm/checksum.h:285:27: error: unsupported inline asm: input with type '__be32' (aka 'unsigned int') matching output with type 'unsigned short'
              "0" (htonl(len)), "1" (htonl(proto)), "r" (sum));
                                     ^~~~~~~~~~~~
    
    The changed code can be compiled successfully by both gcc and clang.
    
    Signed-off-by: Daniel Sanders <daniel.sanders@imgtec.com>
    Signed-off-by: Toma Tabacu <toma.tabacu@imgtec.com>
    Suggested-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Markos Chandras <markos.chandras@imgtec.com>
    Cc: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/9313/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
index 5c585c5c1c3e..3ceacde5eb6e 100644
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -218,6 +218,8 @@ static __inline__ __sum16 csum_ipv6_magic(const struct in6_addr *saddr,
 					  __u32 len, unsigned short proto,
 					  __wsum sum)
 {
+	__wsum tmp;
+
 	__asm__(
 	"	.set	push		# csum_ipv6_magic\n"
 	"	.set	noreorder	\n"
@@ -270,9 +272,9 @@ static __inline__ __sum16 csum_ipv6_magic(const struct in6_addr *saddr,
 
 	"	addu	%0, $1		# Add final carry\n"
 	"	.set	pop"
-	: "=r" (sum), "=r" (proto)
+	: "=&r" (sum), "=&r" (tmp)
 	: "r" (saddr), "r" (daddr),
-	  "0" (htonl(len)), "1" (htonl(proto)), "r" (sum));
+	  "0" (htonl(len)), "r" (htonl(proto)), "r" (sum));
 
 	return csum_fold(sum);
 }

commit 4e0748f5beb92a14f6be4716938cbf27177ecd07
Author: Markos Chandras <markos.chandras@imgtec.com>
Date:   Thu Nov 13 11:25:27 2014 +0000

    MIPS: Use generic checksum functions for MIPS R6
    
    The following instructions have been removed from MIPS R6
    
    ulw, ulh, swl, lwr, lwl, swr.
    
    However, all of them are used in the MIPS specific checksum implementation.
    As a result of which, we will use the generic checksum on MIPS R6
    
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>

diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
index 5996252680c6..5c585c5c1c3e 100644
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -12,6 +12,10 @@
 #ifndef _ASM_CHECKSUM_H
 #define _ASM_CHECKSUM_H
 
+#ifdef CONFIG_GENERIC_CSUM
+#include <asm-generic/checksum.h>
+#else
+
 #include <linux/in6.h>
 
 #include <asm/uaccess.h>
@@ -274,5 +278,6 @@ static __inline__ __sum16 csum_ipv6_magic(const struct in6_addr *saddr,
 }
 
 #include <asm-generic/checksum.h>
+#endif /* CONFIG_GENERIC_CSUM */
 
 #endif /* _ASM_CHECKSUM_H */

commit 2f26c48824ece86ccc6e8d5889fbf338ebfc67e5
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Dec 17 23:05:10 2014 +0100

    MIPS: Use generic csum_tcpudp_magic for MIPS.
    
    Its implementation is identical to MIPS.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
index 64ae32c082d1..5996252680c6 100644
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -199,19 +199,6 @@ static inline __wsum csum_tcpudp_nofold(__be32 saddr,
 }
 #define csum_tcpudp_nofold csum_tcpudp_nofold
 
-/*
- * computes the checksum of the TCP/UDP pseudo-header
- * returns a 16-bit checksum, already complemented
- */
-static inline __sum16 csum_tcpudp_magic(__be32 saddr, __be32 daddr,
-						   unsigned short len,
-						   unsigned short proto,
-						   __wsum sum)
-{
-	return csum_fold(csum_tcpudp_nofold(saddr, daddr, len, proto, sum));
-}
-#define csum_tcpudp_magic csum_tcpudp_magic
-
 /*
  * this routine is used for miscellaneous IP-like checksums, mainly
  * in icmp.c

commit b4b5015a1c1450e008ccd414c760f4ef907a461b
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Dec 17 23:03:46 2014 +0100

    MIPS: Use <asm-generic/checksum.h>
    
    Right now the MIPS <asm/checksum.h> still overrides all functions.  This
    will change in the future.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
index ac0f55cc6e78..64ae32c082d1 100644
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -99,6 +99,7 @@ __wsum csum_and_copy_to_user(const void *src, void __user *dst, int len,
  */
 __wsum csum_partial_copy_nocheck(const void *src, void *dst,
 				       int len, __wsum sum);
+#define csum_partial_copy_nocheck csum_partial_copy_nocheck
 
 /*
  *	Fold a partial checksum without adding pseudo headers
@@ -114,6 +115,7 @@ static inline __sum16 csum_fold(__wsum csum)
 
 	return (__force __sum16)~sum;
 }
+#define csum_fold csum_fold
 
 /*
  *	This is a version of ip_compute_csum() optimized for IP headers,
@@ -152,6 +154,7 @@ static inline __sum16 ip_fast_csum(const void *iph, unsigned int ihl)
 
 	return csum_fold(csum);
 }
+#define ip_fast_csum ip_fast_csum
 
 static inline __wsum csum_tcpudp_nofold(__be32 saddr,
 	__be32 daddr, unsigned short len, unsigned short proto,
@@ -194,6 +197,7 @@ static inline __wsum csum_tcpudp_nofold(__be32 saddr,
 
 	return sum;
 }
+#define csum_tcpudp_nofold csum_tcpudp_nofold
 
 /*
  * computes the checksum of the TCP/UDP pseudo-header
@@ -206,6 +210,7 @@ static inline __sum16 csum_tcpudp_magic(__be32 saddr, __be32 daddr,
 {
 	return csum_fold(csum_tcpudp_nofold(saddr, daddr, len, proto, sum));
 }
+#define csum_tcpudp_magic csum_tcpudp_magic
 
 /*
  * this routine is used for miscellaneous IP-like checksums, mainly
@@ -281,4 +286,6 @@ static __inline__ __sum16 csum_ipv6_magic(const struct in6_addr *saddr,
 	return csum_fold(sum);
 }
 
+#include <asm-generic/checksum.h>
+
 #endif /* _ASM_CHECKSUM_H */

commit d0f0f63ac1374c13b7862b48bd7d6514913dbcad
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Dec 17 14:06:00 2014 +0100

    MIPS: Rewrite csum_fold to plain C.
    
    This isn't only short and easier to read and fully portable but also
    shrinks a Malta kernel's by 160 bytes.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
index 3418c51e1151..ac0f55cc6e78 100644
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -103,22 +103,16 @@ __wsum csum_partial_copy_nocheck(const void *src, void *dst,
 /*
  *	Fold a partial checksum without adding pseudo headers
  */
-static inline __sum16 csum_fold(__wsum sum)
+static inline __sum16 csum_fold(__wsum csum)
 {
-	__asm__(
-	"	.set	push		# csum_fold\n"
-	"	.set	noat		\n"
-	"	sll	$1, %0, 16	\n"
-	"	addu	%0, $1		\n"
-	"	sltu	$1, %0, $1	\n"
-	"	srl	%0, %0, 16	\n"
-	"	addu	%0, $1		\n"
-	"	xori	%0, 0xffff	\n"
-	"	.set	pop"
-	: "=r" (sum)
-	: "0" (sum));
+	u32 sum = (__force u32)csum;;
+
+	sum += (sum << 16);
+	csum = (sum < csum);
+	sum >>= 16;
+	sum += csum;
 
-	return (__force __sum16)sum;
+	return (__force __sum16)~sum;
 }
 
 /*

commit c2d85bc1041c38bebf982a0d16242c3189ca1152
Author: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
Date:   Tue Dec 17 09:30:13 2013 +0000

    MIPS: asm: checksum: Add MIPS specific csum_and_copy_from_user function
    
    A MIPS specific csum_and_copy_from_user function is necessary because
    the generic one from include/net/checksum.h will not work for EVA.
    This is because the generic one will link to symbols from lib/checksum.c
    which are not EVA aware.
    
    Signed-off-by: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>

diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
index f5602c6957c7..3418c51e1151 100644
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -54,6 +54,20 @@ __wsum csum_partial_copy_from_user(const void __user *src, void *dst, int len,
 						     len, sum, err_ptr);
 }
 
+#define _HAVE_ARCH_COPY_AND_CSUM_FROM_USER
+static inline
+__wsum csum_and_copy_from_user(const void __user *src, void *dst,
+			       int len, __wsum sum, int *err_ptr)
+{
+	if (access_ok(VERIFY_READ, src, len))
+		return csum_partial_copy_from_user(src, dst, len, sum,
+						   err_ptr);
+	if (len)
+		*err_ptr = -EFAULT;
+
+	return sum;
+}
+
 /*
  * Copy and checksum to user
  */

commit fb316913f820dae1f5772afaffb5700b601af24e
Author: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
Date:   Thu Dec 19 17:09:17 2013 +0000

    MIPS: asm: checksum: Split kernel and user copy operations
    
    In EVA mode, different instructions need to be used to read/write
    from kernel and userland. In non-EVA mode, there is no functional
    difference. The current address limit is checked to decide the
    type of operation that will be performed.
    
    Signed-off-by: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>

diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
index 3c9aea55954f..f5602c6957c7 100644
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -37,7 +37,6 @@ __wsum __csum_partial_copy_from_user(const void *src, void *dst,
 				     int len, __wsum sum, int *err_ptr);
 __wsum __csum_partial_copy_to_user(const void *src, void *dst,
 				   int len, __wsum sum, int *err_ptr);
-
 /*
  * this is a new version of the above that records errors it finds in *errp,
  * but continues and zeros the rest of the buffer.
@@ -47,8 +46,12 @@ __wsum csum_partial_copy_from_user(const void __user *src, void *dst, int len,
 				   __wsum sum, int *err_ptr)
 {
 	might_fault();
-	return __csum_partial_copy_from_user((__force void *)src, dst,
-					     len, sum, err_ptr);
+	if (segment_eq(get_fs(), get_ds()))
+		return __csum_partial_copy_kernel((__force void *)src, dst,
+						  len, sum, err_ptr);
+	else
+		return __csum_partial_copy_from_user((__force void *)src, dst,
+						     len, sum, err_ptr);
 }
 
 /*
@@ -60,9 +63,16 @@ __wsum csum_and_copy_to_user(const void *src, void __user *dst, int len,
 			     __wsum sum, int *err_ptr)
 {
 	might_fault();
-	if (access_ok(VERIFY_WRITE, dst, len))
-		return __csum_partial_copy_to_user(src, (__force void *)dst,
-						   len, sum, err_ptr);
+	if (access_ok(VERIFY_WRITE, dst, len)) {
+		if (segment_eq(get_fs(), get_ds()))
+			return __csum_partial_copy_kernel(src,
+							  (__force void *)dst,
+							  len, sum, err_ptr);
+		else
+			return __csum_partial_copy_to_user(src,
+							   (__force void *)dst,
+							   len, sum, err_ptr);
+	}
 	if (len)
 		*err_ptr = -EFAULT;
 

commit ac85227f7637cfb0d811519b8253c454d0d0a159
Author: Markos Chandras <markos.chandras@imgtec.com>
Date:   Thu Dec 12 16:21:00 2013 +0000

    MIPS: checksum: Split the 'copy_user' symbol
    
    The 'copy_user' symbol can be used to copy from or to
    userland so we will use two different symbols for these
    operations. This makes no difference in the existing code,
    but when the core is operating in EVA mode, different instructions
    need to be used to read and write to userland address space.
    The old function has also been renamed to 'copy_kernel' to denote
    that it is suitable for copy data to and from kernel space.
    
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>

diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
index ac3d2b8a20d4..3c9aea55954f 100644
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -7,6 +7,7 @@
  * Copyright (C) 1999 Silicon Graphics, Inc.
  * Copyright (C) 2001 Thiemo Seufer.
  * Copyright (C) 2002 Maciej W. Rozycki
+ * Copyright (C) 2014 Imagination Technologies Ltd.
  */
 #ifndef _ASM_CHECKSUM_H
 #define _ASM_CHECKSUM_H
@@ -29,8 +30,13 @@
  */
 __wsum csum_partial(const void *buff, int len, __wsum sum);
 
-__wsum __csum_partial_copy_user(const void *src, void *dst,
-				int len, __wsum sum, int *err_ptr);
+__wsum __csum_partial_copy_kernel(const void *src, void *dst,
+				  int len, __wsum sum, int *err_ptr);
+
+__wsum __csum_partial_copy_from_user(const void *src, void *dst,
+				     int len, __wsum sum, int *err_ptr);
+__wsum __csum_partial_copy_to_user(const void *src, void *dst,
+				   int len, __wsum sum, int *err_ptr);
 
 /*
  * this is a new version of the above that records errors it finds in *errp,
@@ -41,8 +47,8 @@ __wsum csum_partial_copy_from_user(const void __user *src, void *dst, int len,
 				   __wsum sum, int *err_ptr)
 {
 	might_fault();
-	return __csum_partial_copy_user((__force void *)src, dst,
-					len, sum, err_ptr);
+	return __csum_partial_copy_from_user((__force void *)src, dst,
+					     len, sum, err_ptr);
 }
 
 /*
@@ -55,8 +61,8 @@ __wsum csum_and_copy_to_user(const void *src, void __user *dst, int len,
 {
 	might_fault();
 	if (access_ok(VERIFY_WRITE, dst, len))
-		return __csum_partial_copy_user(src, (__force void *)dst,
-						len, sum, err_ptr);
+		return __csum_partial_copy_to_user(src, (__force void *)dst,
+						   len, sum, err_ptr);
 	if (len)
 		*err_ptr = -EFAULT;
 

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
index f2f7c6c264da..ac3d2b8a20d4 100644
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -194,7 +194,7 @@ static inline __sum16 ip_compute_csum(const void *buff, int len)
 
 #define _HAVE_ARCH_IPV6_CSUM
 static __inline__ __sum16 csum_ipv6_magic(const struct in6_addr *saddr,
-				          const struct in6_addr *daddr,
+					  const struct in6_addr *daddr,
 					  __u32 len, unsigned short proto,
 					  __wsum sum)
 {

commit ef41f4600f05a4e973c3ac72869c18269567b319
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Apr 28 14:17:54 2009 +0200

    MIPS: uaccess: Switch lock annotations to might_fault().
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
index 290485ac5407..f2f7c6c264da 100644
--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -40,7 +40,7 @@ static inline
 __wsum csum_partial_copy_from_user(const void __user *src, void *dst, int len,
 				   __wsum sum, int *err_ptr)
 {
-	might_sleep();
+	might_fault();
 	return __csum_partial_copy_user((__force void *)src, dst,
 					len, sum, err_ptr);
 }
@@ -53,7 +53,7 @@ static inline
 __wsum csum_and_copy_to_user(const void *src, void __user *dst, int len,
 			     __wsum sum, int *err_ptr)
 {
-	might_sleep();
+	might_fault();
 	if (access_ok(VERIFY_WRITE, dst, len))
 		return __csum_partial_copy_user(src, (__force void *)dst,
 						len, sum, err_ptr);

commit 384740dc49ea651ba350704d13ff6be9976e37fe
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Sep 16 19:48:51 2008 +0200

    MIPS: Move headfiles to new location below arch/mips/include
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h
new file mode 100644
index 000000000000..290485ac5407
--- /dev/null
+++ b/arch/mips/include/asm/checksum.h
@@ -0,0 +1,260 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1995, 96, 97, 98, 99, 2001 by Ralf Baechle
+ * Copyright (C) 1999 Silicon Graphics, Inc.
+ * Copyright (C) 2001 Thiemo Seufer.
+ * Copyright (C) 2002 Maciej W. Rozycki
+ */
+#ifndef _ASM_CHECKSUM_H
+#define _ASM_CHECKSUM_H
+
+#include <linux/in6.h>
+
+#include <asm/uaccess.h>
+
+/*
+ * computes the checksum of a memory block at buff, length len,
+ * and adds in "sum" (32-bit)
+ *
+ * returns a 32-bit number suitable for feeding into itself
+ * or csum_tcpudp_magic
+ *
+ * this function must be called with even lengths, except
+ * for the last fragment, which may be odd
+ *
+ * it's best to have buff aligned on a 32-bit boundary
+ */
+__wsum csum_partial(const void *buff, int len, __wsum sum);
+
+__wsum __csum_partial_copy_user(const void *src, void *dst,
+				int len, __wsum sum, int *err_ptr);
+
+/*
+ * this is a new version of the above that records errors it finds in *errp,
+ * but continues and zeros the rest of the buffer.
+ */
+static inline
+__wsum csum_partial_copy_from_user(const void __user *src, void *dst, int len,
+				   __wsum sum, int *err_ptr)
+{
+	might_sleep();
+	return __csum_partial_copy_user((__force void *)src, dst,
+					len, sum, err_ptr);
+}
+
+/*
+ * Copy and checksum to user
+ */
+#define HAVE_CSUM_COPY_USER
+static inline
+__wsum csum_and_copy_to_user(const void *src, void __user *dst, int len,
+			     __wsum sum, int *err_ptr)
+{
+	might_sleep();
+	if (access_ok(VERIFY_WRITE, dst, len))
+		return __csum_partial_copy_user(src, (__force void *)dst,
+						len, sum, err_ptr);
+	if (len)
+		*err_ptr = -EFAULT;
+
+	return (__force __wsum)-1; /* invalid checksum */
+}
+
+/*
+ * the same as csum_partial, but copies from user space (but on MIPS
+ * we have just one address space, so this is identical to the above)
+ */
+__wsum csum_partial_copy_nocheck(const void *src, void *dst,
+				       int len, __wsum sum);
+
+/*
+ *	Fold a partial checksum without adding pseudo headers
+ */
+static inline __sum16 csum_fold(__wsum sum)
+{
+	__asm__(
+	"	.set	push		# csum_fold\n"
+	"	.set	noat		\n"
+	"	sll	$1, %0, 16	\n"
+	"	addu	%0, $1		\n"
+	"	sltu	$1, %0, $1	\n"
+	"	srl	%0, %0, 16	\n"
+	"	addu	%0, $1		\n"
+	"	xori	%0, 0xffff	\n"
+	"	.set	pop"
+	: "=r" (sum)
+	: "0" (sum));
+
+	return (__force __sum16)sum;
+}
+
+/*
+ *	This is a version of ip_compute_csum() optimized for IP headers,
+ *	which always checksum on 4 octet boundaries.
+ *
+ *	By Jorge Cwik <jorge@laser.satlink.net>, adapted for linux by
+ *	Arnt Gulbrandsen.
+ */
+static inline __sum16 ip_fast_csum(const void *iph, unsigned int ihl)
+{
+	const unsigned int *word = iph;
+	const unsigned int *stop = word + ihl;
+	unsigned int csum;
+	int carry;
+
+	csum = word[0];
+	csum += word[1];
+	carry = (csum < word[1]);
+	csum += carry;
+
+	csum += word[2];
+	carry = (csum < word[2]);
+	csum += carry;
+
+	csum += word[3];
+	carry = (csum < word[3]);
+	csum += carry;
+
+	word += 4;
+	do {
+		csum += *word;
+		carry = (csum < *word);
+		csum += carry;
+		word++;
+	} while (word != stop);
+
+	return csum_fold(csum);
+}
+
+static inline __wsum csum_tcpudp_nofold(__be32 saddr,
+	__be32 daddr, unsigned short len, unsigned short proto,
+	__wsum sum)
+{
+	__asm__(
+	"	.set	push		# csum_tcpudp_nofold\n"
+	"	.set	noat		\n"
+#ifdef CONFIG_32BIT
+	"	addu	%0, %2		\n"
+	"	sltu	$1, %0, %2	\n"
+	"	addu	%0, $1		\n"
+
+	"	addu	%0, %3		\n"
+	"	sltu	$1, %0, %3	\n"
+	"	addu	%0, $1		\n"
+
+	"	addu	%0, %4		\n"
+	"	sltu	$1, %0, %4	\n"
+	"	addu	%0, $1		\n"
+#endif
+#ifdef CONFIG_64BIT
+	"	daddu	%0, %2		\n"
+	"	daddu	%0, %3		\n"
+	"	daddu	%0, %4		\n"
+	"	dsll32	$1, %0, 0	\n"
+	"	daddu	%0, $1		\n"
+	"	dsra32	%0, %0, 0	\n"
+#endif
+	"	.set	pop"
+	: "=r" (sum)
+	: "0" ((__force unsigned long)daddr),
+	  "r" ((__force unsigned long)saddr),
+#ifdef __MIPSEL__
+	  "r" ((proto + len) << 8),
+#else
+	  "r" (proto + len),
+#endif
+	  "r" ((__force unsigned long)sum));
+
+	return sum;
+}
+
+/*
+ * computes the checksum of the TCP/UDP pseudo-header
+ * returns a 16-bit checksum, already complemented
+ */
+static inline __sum16 csum_tcpudp_magic(__be32 saddr, __be32 daddr,
+						   unsigned short len,
+						   unsigned short proto,
+						   __wsum sum)
+{
+	return csum_fold(csum_tcpudp_nofold(saddr, daddr, len, proto, sum));
+}
+
+/*
+ * this routine is used for miscellaneous IP-like checksums, mainly
+ * in icmp.c
+ */
+static inline __sum16 ip_compute_csum(const void *buff, int len)
+{
+	return csum_fold(csum_partial(buff, len, 0));
+}
+
+#define _HAVE_ARCH_IPV6_CSUM
+static __inline__ __sum16 csum_ipv6_magic(const struct in6_addr *saddr,
+				          const struct in6_addr *daddr,
+					  __u32 len, unsigned short proto,
+					  __wsum sum)
+{
+	__asm__(
+	"	.set	push		# csum_ipv6_magic\n"
+	"	.set	noreorder	\n"
+	"	.set	noat		\n"
+	"	addu	%0, %5		# proto (long in network byte order)\n"
+	"	sltu	$1, %0, %5	\n"
+	"	addu	%0, $1		\n"
+
+	"	addu	%0, %6		# csum\n"
+	"	sltu	$1, %0, %6	\n"
+	"	lw	%1, 0(%2)	# four words source address\n"
+	"	addu	%0, $1		\n"
+	"	addu	%0, %1		\n"
+	"	sltu	$1, %0, %1	\n"
+
+	"	lw	%1, 4(%2)	\n"
+	"	addu	%0, $1		\n"
+	"	addu	%0, %1		\n"
+	"	sltu	$1, %0, %1	\n"
+
+	"	lw	%1, 8(%2)	\n"
+	"	addu	%0, $1		\n"
+	"	addu	%0, %1		\n"
+	"	sltu	$1, %0, %1	\n"
+
+	"	lw	%1, 12(%2)	\n"
+	"	addu	%0, $1		\n"
+	"	addu	%0, %1		\n"
+	"	sltu	$1, %0, %1	\n"
+
+	"	lw	%1, 0(%3)	\n"
+	"	addu	%0, $1		\n"
+	"	addu	%0, %1		\n"
+	"	sltu	$1, %0, %1	\n"
+
+	"	lw	%1, 4(%3)	\n"
+	"	addu	%0, $1		\n"
+	"	addu	%0, %1		\n"
+	"	sltu	$1, %0, %1	\n"
+
+	"	lw	%1, 8(%3)	\n"
+	"	addu	%0, $1		\n"
+	"	addu	%0, %1		\n"
+	"	sltu	$1, %0, %1	\n"
+
+	"	lw	%1, 12(%3)	\n"
+	"	addu	%0, $1		\n"
+	"	addu	%0, %1		\n"
+	"	sltu	$1, %0, %1	\n"
+
+	"	addu	%0, $1		# Add final carry\n"
+	"	.set	pop"
+	: "=r" (sum), "=r" (proto)
+	: "r" (saddr), "r" (daddr),
+	  "0" (htonl(len)), "1" (htonl(proto)), "r" (sum));
+
+	return csum_fold(sum);
+}
+
+#endif /* _ASM_CHECKSUM_H */
