commit 3210e2c279fee1076978b49988acdd935a6f7435
Author: Huacai Chen <chenhc@lemote.com>
Date:   Sat May 23 15:56:33 2020 +0800

    KVM: MIPS: Introduce and use cpu_guest_has_ldpte
    
    Loongson-3 has lddir/ldpte instructions and their related CP0 registers
    are the same as HTW. So we introduce a cpu_guest_has_ldpte flag and use
    it to indicate whether we need to save/restore HTW related CP0 registers
    (PWBase, PWSize, PWField and PWCtl).
    
    Acked-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Reviewed-by: Aleksandar Markovic <aleksandar.qemu.devel@gmail.com>
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    Co-developed-by: Jiaxun Yang <jiaxun.yang@flygoat.com>
    Message-Id: <1590220602-3547-7-git-send-email-chenhc@lemote.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index caecbae4b599..724dfddcab92 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -682,6 +682,9 @@
 #ifndef cpu_guest_has_htw
 #define cpu_guest_has_htw	(cpu_data[0].guest.options & MIPS_CPU_HTW)
 #endif
+#ifndef cpu_guest_has_ldpte
+#define cpu_guest_has_ldpte	(cpu_data[0].guest.options & MIPS_CPU_LDPTE)
+#endif
 #ifndef cpu_guest_has_mvh
 #define cpu_guest_has_mvh	(cpu_data[0].guest.options & MIPS_CPU_MVH)
 #endif

commit 742318ad5eeecace49e95da5d3cf4571b0b26b36
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Thu May 21 17:07:17 2020 +0300

    mips: Add CP0 Write Merge config support
    
    CP0 config register may indicate whether write-through merging
    is allowed. Currently there are two types of the merging available:
    SysAD Valid and Full modes. Whether each of them are supported by
    the core is implementation dependent. Moreover whether the ability
    to change the mode also depends on the chip family instance. Taking
    into account all of this we created a dedicated mm_config() method
    to detect and enable merging if it's supported. It is called for
    MIPS-type processors at CPU-probe stage and attempts to detect whether
    the write merging is available. If it's known to be supported and
    switchable, then switch on the full mode. Otherwise just perform the
    CP0.Config.MM field analysis.
    
    In addition there are platforms like InterAptiv/ProAptiv, which do have
    the MM bit field set by default, but having write-through cacheing
    unsupported makes write-merging also unsupported. In this case we just
    ignore the MM field value.
    
    Co-developed-by: Alexey Malahov <Alexey.Malahov@baikalelectronics.ru>
    Signed-off-by: Alexey Malahov <Alexey.Malahov@baikalelectronics.ru>
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Paul Burton <paulburton@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 14532cd25807..caecbae4b599 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -629,6 +629,14 @@
 # endif
 #endif
 
+#ifndef cpu_has_mm_sysad
+# define cpu_has_mm_sysad	__opt(MIPS_CPU_MM_SYSAD)
+#endif
+
+#ifndef cpu_has_mm_full
+# define cpu_has_mm_full	__opt(MIPS_CPU_MM_FULL)
+#endif
+
 /*
  * Guest capabilities
  */

commit a2ac81c6ef4018ea49c034ce165bb9ea1cf99f3e
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Thu May 21 17:07:16 2020 +0300

    mips: Fix cpu_has_mips64r1/2 activation for MIPS32 CPUs
    
    Commit 1aeba347b3a9 ("MIPS: Hardcode cpu_has_mips* where target ISA
    allows") updated the cpu_has_mips* macro to be replaced with a constant
    expression where it's possible. By mistake it wasn't done correctly
    for cpu_has_mips64r1/cpu_has_mips64r2 macro. They are defined to
    be replaced with conditional expression __isa_range_or_flag(), which
    means either ISA revision being within the range or the corresponding
    CPU options flag was set at the probe stage or both being true at the
    same time. But the ISA level value doesn't indicate whether the ISA is
    MIPS32 or MIPS64. Due to this if we select MIPS32r1 - MIPS32r5
    architectures the __isa_range() macro will activate the
    cpu_has_mips64rX flags, which is incorrect. In order to fix the
    problem we make sure the 64bits CPU support is enabled by means of
    checking the flag cpu_has_64bits aside with proper ISA range and specific
    Revision flag being set.
    
    Fixes: 1aeba347b3a9 ("MIPS: Hardcode cpu_has_mips* where target ISA allows")
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Cc: Alexey Malahov <Alexey.Malahov@baikalelectronics.ru>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Paul Burton <paulburton@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 227d7416591c..14532cd25807 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -291,10 +291,12 @@
 # define cpu_has_mips32r6	__isa_ge_or_flag(6, MIPS_CPU_ISA_M32R6)
 #endif
 #ifndef cpu_has_mips64r1
-# define cpu_has_mips64r1	__isa_range_or_flag(1, 6, MIPS_CPU_ISA_M64R1)
+# define cpu_has_mips64r1	(cpu_has_64bits && \
+				 __isa_range_or_flag(1, 6, MIPS_CPU_ISA_M64R1))
 #endif
 #ifndef cpu_has_mips64r2
-# define cpu_has_mips64r2	__isa_range_or_flag(2, 6, MIPS_CPU_ISA_M64R2)
+# define cpu_has_mips64r2	(cpu_has_64bits && \
+				 __isa_range_or_flag(2, 6, MIPS_CPU_ISA_M64R2))
 #endif
 #ifndef cpu_has_mips64r5
 # define cpu_has_mips64r5	(cpu_has_64bits && \

commit ab7c01fdc3cfe02256e777a36366b70e2a539c27
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Thu May 21 17:07:14 2020 +0300

    mips: Add MIPS Release 5 support
    
    There are five MIPS32/64 architecture releases currently available:
    from 1 to 6 except fourth one, which was intentionally skipped.
    Three of them can be called as major: 1st, 2nd and 6th, that not only
    have some system level alterations, but also introduced significant
    core/ISA level updates. The rest of the MIPS architecture releases are
    minor.
    
    Even though they don't have as much ISA/system/core level changes
    as the major ones with respect to the previous releases, they still
    provide a set of updates (I'd say they were intended to be the
    intermediate releases before a major one) that might be useful for the
    kernel and user-level code, when activated by the kernel or compiler.
    In particular the following features were introduced or ended up being
    available at/after MIPS32/64 Release 5 architecture:
    + the last release of the misaligned memory access instructions,
    + virtualisation - VZ ASE - is optional component of the arch,
    + SIMD - MSA ASE - is optional component of the arch,
    + DSP ASE is optional component of the arch,
    + CP0.Status.FR=1 for CP1.FIR.F64=1 (pure 64-bit FPU general registers)
      must be available if FPU is implemented,
    + CP1.FIR.Has2008 support is required so CP1.FCSR.{ABS2008,NAN2008} bits
      are available.
    + UFR/UNFR aliases to access CP0.Status.FR from user-space by means of
      ctc1/cfc1 instructions (enabled by CP0.Config5.UFR),
    + CP0.COnfig5.LLB=1 and eretnc instruction are implemented to without
      accidentally clearing LL-bit when returning from an interrupt,
      exception, or error trap,
    + XPA feature together with extended versions of CPx registers is
      introduced, which needs to have mfhc0/mthc0 instructions available.
    
    So due to these changes GNU GCC provides an extended instructions set
    support for MIPS32/64 Release 5 by default like eretnc/mfhc0/mthc0. Even
    though the architecture alteration isn't that big, it still worth to be
    taken into account by the kernel software. Finally we can't deny that
    some optimization/limitations might be found in future and implemented
    on some level in kernel or compiler. In this case having even
    intermediate MIPS architecture releases support would be more than
    useful.
    
    So the most of the changes provided by this commit can be split into
    either compile- or runtime configs related. The compile-time related
    changes are caused by adding the new CONFIG_CPU_MIPS32_R5/CONFIG_CPU_MIPSR5
    configs and concern the code activating MIPSR2 or MIPSR6 already
    implemented features (like eretnc/LLbit, mthc0/mfhc0). In addition
    CPU_HAS_MSA can be now freely enabled for MIPS32/64 release 5 based
    platforms as this is done for CPU_MIPS32_R6 CPUs. The runtime changes
    concerns the features which are handled with respect to the MIPS ISA
    revision detected at run-time by means of CP0.Config.{AT,AR} bits. Alas
    these fields can be used to detect either r1 or r2 or r6 releases.
    But since we know which CPUs in fact support the R5 arch, we can manually
    set MIPS_CPU_ISA_M32R5/MIPS_CPU_ISA_M64R5 bit of c->isa_level and then
    use cpu_has_mips32r5/cpu_has_mips64r5 where it's appropriate.
    
    Since XPA/EVA provide too complex alterationss and to have them used with
    MIPS32 Release 2 charged kernels (for compatibility with current platform
    configs) they are left to be setup as a separate kernel configs.
    
    Co-developed-by: Alexey Malahov <Alexey.Malahov@baikalelectronics.ru>
    Signed-off-by: Alexey Malahov <Alexey.Malahov@baikalelectronics.ru>
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Paul Burton <paulburton@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 400b123cb6da..227d7416591c 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -284,6 +284,9 @@
 #ifndef cpu_has_mips32r2
 # define cpu_has_mips32r2	__isa_range_or_flag(2, 6, MIPS_CPU_ISA_M32R2)
 #endif
+#ifndef cpu_has_mips32r5
+# define cpu_has_mips32r5	__isa_range_or_flag(5, 6, MIPS_CPU_ISA_M32R5)
+#endif
 #ifndef cpu_has_mips32r6
 # define cpu_has_mips32r6	__isa_ge_or_flag(6, MIPS_CPU_ISA_M32R6)
 #endif
@@ -293,6 +296,10 @@
 #ifndef cpu_has_mips64r2
 # define cpu_has_mips64r2	__isa_range_or_flag(2, 6, MIPS_CPU_ISA_M64R2)
 #endif
+#ifndef cpu_has_mips64r5
+# define cpu_has_mips64r5	(cpu_has_64bits && \
+				 __isa_range_or_flag(5, 6, MIPS_CPU_ISA_M64R5))
+#endif
 #ifndef cpu_has_mips64r6
 # define cpu_has_mips64r6	__isa_ge_and_flag(6, MIPS_CPU_ISA_M64R6)
 #endif
@@ -313,19 +320,25 @@
 				(cpu_has_mips_3 | cpu_has_mips_4_5_64_r2_r6)
 #define cpu_has_mips_4_5_64_r2_r6					\
 				(cpu_has_mips_4_5 | cpu_has_mips64r1 |	\
-				 cpu_has_mips_r2 | cpu_has_mips_r6)
+				 cpu_has_mips_r2 | cpu_has_mips_r5 | \
+				 cpu_has_mips_r6)
 
-#define cpu_has_mips32	(cpu_has_mips32r1 | cpu_has_mips32r2 | cpu_has_mips32r6)
-#define cpu_has_mips64	(cpu_has_mips64r1 | cpu_has_mips64r2 | cpu_has_mips64r6)
+#define cpu_has_mips32	(cpu_has_mips32r1 | cpu_has_mips32r2 | \
+			 cpu_has_mips32r5 | cpu_has_mips32r6)
+#define cpu_has_mips64	(cpu_has_mips64r1 | cpu_has_mips64r2 | \
+			 cpu_has_mips64r5 | cpu_has_mips64r6)
 #define cpu_has_mips_r1 (cpu_has_mips32r1 | cpu_has_mips64r1)
 #define cpu_has_mips_r2 (cpu_has_mips32r2 | cpu_has_mips64r2)
+#define cpu_has_mips_r5	(cpu_has_mips32r5 | cpu_has_mips64r5)
 #define cpu_has_mips_r6	(cpu_has_mips32r6 | cpu_has_mips64r6)
 #define cpu_has_mips_r	(cpu_has_mips32r1 | cpu_has_mips32r2 | \
-			 cpu_has_mips32r6 | cpu_has_mips64r1 | \
-			 cpu_has_mips64r2 | cpu_has_mips64r6)
+			 cpu_has_mips32r5 | cpu_has_mips32r6 | \
+			 cpu_has_mips64r1 | cpu_has_mips64r2 | \
+			 cpu_has_mips64r5 | cpu_has_mips64r6)
 
-/* MIPSR2 and MIPSR6 have a lot of similarities */
-#define cpu_has_mips_r2_r6	(cpu_has_mips_r2 | cpu_has_mips_r6)
+/* MIPSR2 - MIPSR6 have a lot of similarities */
+#define cpu_has_mips_r2_r6	(cpu_has_mips_r2 | cpu_has_mips_r5 | \
+				 cpu_has_mips_r6)
 
 /*
  * cpu_has_mips_r2_exec_hazard - return if IHB is required on current processor

commit b604d4973af7df4bbe970b2c380f5a0477fa53ec
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Apr 16 17:00:06 2020 +0200

    MIPS: remove cpu_has_64bit_addresses
    
    This macro is identical to CONFIG_64BIT, and using a Kconfig variable
    for the only places that checks them (the ioremap implementation) will
    simplify later patches in this series.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index de44c92b1c1f..400b123cb6da 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -435,9 +435,6 @@
 # ifndef cpu_has_64bit_gp_regs
 # define cpu_has_64bit_gp_regs		0
 # endif
-# ifndef cpu_has_64bit_addresses
-# define cpu_has_64bit_addresses	0
-# endif
 # ifndef cpu_vmbits
 # define cpu_vmbits 31
 # endif
@@ -456,9 +453,6 @@
 # ifndef cpu_has_64bit_gp_regs
 # define cpu_has_64bit_gp_regs		1
 # endif
-# ifndef cpu_has_64bit_addresses
-# define cpu_has_64bit_addresses	1
-# endif
 # ifndef cpu_vmbits
 # define cpu_vmbits cpu_data[0].vmbits
 # define __NEED_VMBITS_PROBE

commit ece276de2a1f90b6a7836d388c372b9025345469
Author: Jiaxun Yang <jiaxun.yang@flygoat.com>
Date:   Mon Jan 13 18:16:11 2020 +0800

    MIPS: Add MAC2008 Support
    
    MAC2008 means the processor implemented IEEE754 style Fused MADD
    instruction. It was introduced in Release3 but removed in Release5.
    
    The toolchain support of MAC2008 have never landed except for Loongson
    processors.
    
    This patch aimed to disabled the MAC2008 if it's optional. For
    MAC2008 only processors, we corrected math-emu behavior to align
    with actual hardware behavior.
    
    Signed-off-by: Jiaxun Yang <jiaxun.yang@flygoat.com>
    [paulburton@kernel.org: Fixup MIPSr2-r5 check in cpu_set_fpu_2008.]
    Signed-off-by: Paul Burton <paulburton@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: chenhc@lemote.com
    Cc: paul.burton@mips.com
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 983a6a7f43a1..de44c92b1c1f 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -555,6 +555,10 @@
 # define cpu_has_perf		__opt(MIPS_CPU_PERF)
 #endif
 
+#ifndef cpu_has_mac2008_only
+# define cpu_has_mac2008_only	__opt(MIPS_CPU_MAC_2008_ONLY)
+#endif
+
 #ifdef CONFIG_SMP
 /*
  * Some systems share FTLB RAMs between threads within a core (siblings in

commit 775b089aeffa98d5f69045d9dc4fe3aaba1bc9e1
Author: Paul Burton <paul.burton@mips.com>
Date:   Sat Aug 31 15:40:46 2019 +0000

    MIPS: tlbex: Remove cpu_has_local_ebase
    
    The cpu_has_local_ebase macro is, confusingly, not used to indicate
    whether the EBase register is local to a CPU or not. Instead it
    indicates whether we want to generate the TLB refill exception vector
    each time a CPU is brought online. Doing this makes little sense on any
    system, since we always use the same value for EBase & thus we cannot
    have different TLB refill exception handlers per CPU.
    
    Regenerating the code is not only pointless but also can be actively
    harmful, as commit 8759934e2b6b ("MIPS: Build uasm-generated code only
    once to avoid CPU Hotplug problem") described. That commit introduced
    cpu_has_local_ebase to disable the handler regeneration for Loongson
    machines, but this is by no means a Loongson-specific problem.
    
    Remove cpu_has_local_ebase & simply generate the TLB refill handler once
    during boot, just like the rest of the TLB exception handlers.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Reviewed-by: Philippe Mathieu-Daudé <f4bug@amsat.org>
    Cc: linux-mips@vger.kernel.org

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 4e2bea8875f5..983a6a7f43a1 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -243,9 +243,6 @@
 #ifndef cpu_has_pindexed_dcache
 #define cpu_has_pindexed_dcache	(cpu_data[0].dcache.flags & MIPS_CACHE_PINDEX)
 #endif
-#ifndef cpu_has_local_ebase
-#define cpu_has_local_ebase	1
-#endif
 
 /*
  * I-Cache snoops remote store.	 This only matters on SMP.  Some multiprocessors

commit d2f965549006acb865c4638f1f030ebcefdc71f6
Author: Jiaxun Yang <jiaxun.yang@flygoat.com>
Date:   Wed May 29 16:42:59 2019 +0800

    MIPS: Treat Loongson Extensions as ASEs
    
    Recently, binutils had split Loongson-3 Extensions into four ASEs:
    MMI, CAM, EXT, EXT2. This patch do the samething in kernel and expose
    them in cpuinfo so applications can probe supported ASEs at runtime.
    
    Signed-off-by: Jiaxun Yang <jiaxun.yang@flygoat.com>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Yunqiang Su <ysu@wavecomp.com>
    Cc: stable@vger.kernel.org # v4.14+
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: linux-mips@vger.kernel.org

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 6998a9796499..4e2bea8875f5 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -397,6 +397,22 @@
 #define cpu_has_dsp3		__ase(MIPS_ASE_DSP3)
 #endif
 
+#ifndef cpu_has_loongson_mmi
+#define cpu_has_loongson_mmi		__ase(MIPS_ASE_LOONGSON_MMI)
+#endif
+
+#ifndef cpu_has_loongson_cam
+#define cpu_has_loongson_cam		__ase(MIPS_ASE_LOONGSON_CAM)
+#endif
+
+#ifndef cpu_has_loongson_ext
+#define cpu_has_loongson_ext		__ase(MIPS_ASE_LOONGSON_EXT)
+#endif
+
+#ifndef cpu_has_loongson_ext2
+#define cpu_has_loongson_ext2		__ase(MIPS_ASE_LOONGSON_EXT2)
+#endif
+
 #ifndef cpu_has_mipsmt
 #define cpu_has_mipsmt		__isa_lt_and_ase(6, MIPS_ASE_MIPSMT)
 #endif

commit c8790d657b0a8d42801fb4536f6f106b4b6306e8
Author: Paul Burton <paul.burton@mips.com>
Date:   Sat Feb 2 01:43:28 2019 +0000

    MIPS: MemoryMapID (MMID) Support
    
    Introduce support for using MemoryMapIDs (MMIDs) as an alternative to
    Address Space IDs (ASIDs). The major difference between the two is that
    MMIDs are global - ie. an MMID uniquely identifies an address space
    across all coherent CPUs. In contrast ASIDs are non-global per-CPU IDs,
    wherein each address space is allocated a separate ASID for each CPU
    upon which it is used. This global namespace allows a new GINVT
    instruction be used to globally invalidate TLB entries associated with a
    particular MMID across all coherent CPUs in the system, removing the
    need for IPIs to invalidate entries with separate ASIDs on each CPU.
    
    The allocation scheme used here is largely borrowed from arm64 (see
    arch/arm64/mm/context.c). In essence we maintain a bitmap to track
    available MMIDs, and MMIDs in active use at the time of a rollover to a
    new MMID version are preserved in the new version. The allocation scheme
    requires efficient 64 bit atomics in order to perform reasonably, so
    this support depends upon CONFIG_GENERIC_ATOMIC64=n (ie. currently it
    will only be included in MIPS64 kernels).
    
    The first, and currently only, available CPU with support for MMIDs is
    the MIPS I6500. This CPU supports 16 bit MMIDs, and so for now we cap
    our MMIDs to 16 bits wide in order to prevent the bitmap growing to
    absurd sizes if any future CPU does implement 32 bit MMIDs as the
    architecture manuals suggest is recommended.
    
    When MMIDs are in use we also make use of GINVT instruction which is
    available due to the global nature of MMIDs. By executing a sequence of
    GINVT & SYNC 0x14 instructions we can avoid the overhead of an IPI to
    each remote CPU in many cases. One complication is that GINVT will
    invalidate wired entries (in all cases apart from type 0, which targets
    the entire TLB). In order to avoid GINVT invalidating any wired TLB
    entries we set up, we make sure to create those entries using a reserved
    MMID (0) that we never associate with any address space.
    
    Also of note is that KVM will require further work in order to support
    MMIDs & GINVT, since KVM is involved in allocating IDs for guests & in
    configuring the MMU. That work is not part of this patch, so for now
    when MMIDs are in use KVM is disabled.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: linux-mips@vger.kernel.org

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 701e525641b8..6998a9796499 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -590,6 +590,19 @@
 # define cpu_has_mipsmt_pertccounters 0
 #endif /* CONFIG_MIPS_MT_SMP */
 
+/*
+ * We only enable MMID support for configurations which natively support 64 bit
+ * atomics because getting good performance from the allocator relies upon
+ * efficient atomic64_*() functions.
+ */
+#ifndef cpu_has_mmid
+# ifdef CONFIG_GENERIC_ATOMIC64
+#  define cpu_has_mmid		0
+# else
+#  define cpu_has_mmid		__isa_ge_and_opt(6, MIPS_CPU_MMID)
+# endif
+#endif
+
 /*
  * Guest capabilities
  */

commit 1aeba347b3a90a8b22f1c3eed0dcfba38bb8dbb8
Author: Paul Burton <paul.burton@mips.com>
Date:   Mon Nov 26 18:58:40 2018 +0000

    MIPS: Hardcode cpu_has_mips* where target ISA allows
    
    In the same vein as commit 93e01942a6eb ("MIPS: Hardcode cpu_has_* where
    known at compile time due to ISA"), we can use our knowledge of the ISA
    being targeted by the kernel build to make cpu_has_mips* macros
    compile-time constant in some cases. This allows the compiler greater
    opportunity to optimize out code which will never execute.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Patchwork: https://patchwork.linux-mips.org/patch/21245/
    Cc: linux-mips@linux-mips.org

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index ca348356f76f..701e525641b8 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -15,6 +15,7 @@
 #include <cpu-feature-overrides.h>
 
 #define __ase(ase)			(cpu_data[0].ases & (ase))
+#define __isa(isa)			(cpu_data[0].isa_level & (isa))
 #define __opt(opt)			(cpu_data[0].options & (opt))
 
 /*
@@ -52,6 +53,18 @@
 #define __isa_lt_and_ase(isa, ase)	((MIPS_ISA_REV < (isa)) && __ase(ase))
 #define __isa_lt_and_opt(isa, opt)	((MIPS_ISA_REV < (isa)) && __opt(opt))
 
+/*
+ * Similarly allow for ISA level checks that take into account knowledge of the
+ * ISA targeted by the kernel build, provided by MIPS_ISA_REV.
+ */
+#define __isa_ge_and_flag(isa, flag)	((MIPS_ISA_REV >= (isa)) && __isa(flag))
+#define __isa_ge_or_flag(isa, flag)	((MIPS_ISA_REV >= (isa)) || __isa(flag))
+#define __isa_lt_and_flag(isa, flag)	((MIPS_ISA_REV < (isa)) && __isa(flag))
+#define __isa_range(ge, lt) \
+	((MIPS_ISA_REV >= (ge)) && (MIPS_ISA_REV < (lt)))
+#define __isa_range_or_flag(ge, lt, flag) \
+	(__isa_range(ge, lt) || ((MIPS_ISA_REV < (lt)) && __isa(flag)))
+
 /*
  * SMP assumption: Options of CPU 0 are a superset of all processors.
  * This is true for all known MIPS systems.
@@ -254,37 +267,37 @@
 #endif
 
 #ifndef cpu_has_mips_1
-# define cpu_has_mips_1		(!cpu_has_mips_r6)
+# define cpu_has_mips_1		(MIPS_ISA_REV < 6)
 #endif
 #ifndef cpu_has_mips_2
-# define cpu_has_mips_2		(cpu_data[0].isa_level & MIPS_CPU_ISA_II)
+# define cpu_has_mips_2		__isa_lt_and_flag(6, MIPS_CPU_ISA_II)
 #endif
 #ifndef cpu_has_mips_3
-# define cpu_has_mips_3		(cpu_data[0].isa_level & MIPS_CPU_ISA_III)
+# define cpu_has_mips_3		__isa_lt_and_flag(6, MIPS_CPU_ISA_III)
 #endif
 #ifndef cpu_has_mips_4
-# define cpu_has_mips_4		(cpu_data[0].isa_level & MIPS_CPU_ISA_IV)
+# define cpu_has_mips_4		__isa_lt_and_flag(6, MIPS_CPU_ISA_IV)
 #endif
 #ifndef cpu_has_mips_5
-# define cpu_has_mips_5		(cpu_data[0].isa_level & MIPS_CPU_ISA_V)
+# define cpu_has_mips_5		__isa_lt_and_flag(6, MIPS_CPU_ISA_V)
 #endif
 #ifndef cpu_has_mips32r1
-# define cpu_has_mips32r1	(cpu_data[0].isa_level & MIPS_CPU_ISA_M32R1)
+# define cpu_has_mips32r1	__isa_range_or_flag(1, 6, MIPS_CPU_ISA_M32R1)
 #endif
 #ifndef cpu_has_mips32r2
-# define cpu_has_mips32r2	(cpu_data[0].isa_level & MIPS_CPU_ISA_M32R2)
+# define cpu_has_mips32r2	__isa_range_or_flag(2, 6, MIPS_CPU_ISA_M32R2)
 #endif
 #ifndef cpu_has_mips32r6
-# define cpu_has_mips32r6	(cpu_data[0].isa_level & MIPS_CPU_ISA_M32R6)
+# define cpu_has_mips32r6	__isa_ge_or_flag(6, MIPS_CPU_ISA_M32R6)
 #endif
 #ifndef cpu_has_mips64r1
-# define cpu_has_mips64r1	(cpu_data[0].isa_level & MIPS_CPU_ISA_M64R1)
+# define cpu_has_mips64r1	__isa_range_or_flag(1, 6, MIPS_CPU_ISA_M64R1)
 #endif
 #ifndef cpu_has_mips64r2
-# define cpu_has_mips64r2	(cpu_data[0].isa_level & MIPS_CPU_ISA_M64R2)
+# define cpu_has_mips64r2	__isa_range_or_flag(2, 6, MIPS_CPU_ISA_M64R2)
 #endif
 #ifndef cpu_has_mips64r6
-# define cpu_has_mips64r6	(cpu_data[0].isa_level & MIPS_CPU_ISA_M64R6)
+# define cpu_has_mips64r6	__isa_ge_and_flag(6, MIPS_CPU_ISA_M64R6)
 #endif
 
 /*

commit 57eeacede4db235891ddc37544262413f909763e
Author: Paul Burton <paul.burton@mips.com>
Date:   Thu Nov 8 23:44:55 2018 +0000

    MIPS: Use Kconfig to select CPU_NO_EFFICIENT_FFS
    
    Select CONFIG_CPU_NO_EFFICIENT_FFS via Kconfig when the kernel is
    configured for a pre-MIPS32r1 CPU, rather than defining its equivalent
    in asm/cpu-features.h based upon overrides of cpu_has_mips* macros.
    
    The latter only works if a platform has an cpu-feature-overrides.h
    header which defines cpu_has_mips* macros, which are not generally
    needed. There are many cases where we know that the target ISA for a
    kernel build is MIPS32r1 or later & thus includes the CLZ instruction,
    without requiring any overrides from the platform. Using Kconfig allows
    us to take those into account, and more naturally make a decision about
    instruction support using information about the target ISA.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Patchwork: https://patchwork.linux-mips.org/patch/21045/
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Zhaoxiu Zeng <zhaoxiu.zeng@gmail.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 450e0638f22d..ca348356f76f 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -253,16 +253,6 @@
 #endif
 #endif
 
-/* __builtin_constant_p(cpu_has_mips_r) && cpu_has_mips_r */
-#if !((defined(cpu_has_mips32r1) && cpu_has_mips32r1) || \
-	  (defined(cpu_has_mips32r2) && cpu_has_mips32r2) || \
-	  (defined(cpu_has_mips32r6) && cpu_has_mips32r6) || \
-	  (defined(cpu_has_mips64r1) && cpu_has_mips64r1) || \
-	  (defined(cpu_has_mips64r2) && cpu_has_mips64r2) || \
-	  (defined(cpu_has_mips64r6) && cpu_has_mips64r6))
-#define CPU_NO_EFFICIENT_FFS 1
-#endif
-
 #ifndef cpu_has_mips_1
 # define cpu_has_mips_1		(!cpu_has_mips_r6)
 #endif

commit b372e83b67eb296d85654e2dde8a0e6105083b16
Author: Paul Burton <paul.burton@mips.com>
Date:   Wed Nov 7 23:14:03 2018 +0000

    MIPS: Hardcode cpu_has_fpu=0 when CONFIG_MIPS_FP_SUPPORT=n
    
    When CONFIG_MIPS_FP_SUPPORT=n we don't support floating point, so
    there's no point in detecting presence of an FPU. Hardcode
    cpu_has_fpu=0 such that we optimize out code that makes use of the FPU.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Patchwork: https://patchwork.linux-mips.org/patch/21005/
    Cc: linux-mips@linux-mips.org

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 8669fdb503a5..450e0638f22d 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -115,10 +115,15 @@
 #endif
 /* Don't override `cpu_has_fpu' to 1 or the "nofpu" option won't work.  */
 #ifndef cpu_has_fpu
-#define cpu_has_fpu		(current_cpu_data.options & MIPS_CPU_FPU)
-#define raw_cpu_has_fpu		(raw_current_cpu_data.options & MIPS_CPU_FPU)
+# ifdef CONFIG_MIPS_FP_SUPPORT
+#  define cpu_has_fpu		(current_cpu_data.options & MIPS_CPU_FPU)
+#  define raw_cpu_has_fpu	(raw_current_cpu_data.options & MIPS_CPU_FPU)
+# else
+#  define cpu_has_fpu		0
+#  define raw_cpu_has_fpu	0
+# endif
 #else
-#define raw_cpu_has_fpu		cpu_has_fpu
+# define raw_cpu_has_fpu	cpu_has_fpu
 #endif
 #ifndef cpu_has_32fpr
 #define cpu_has_32fpr		__isa_ge_or_opt(1, MIPS_CPU_32FPR)

commit a013ba392843b2f65088f198a7125a78d48c6533
Author: Paul Burton <paul.burton@mips.com>
Date:   Wed Nov 7 23:19:41 2018 +0000

    MIPS: Hardcode cpu_has_mmips=1 for microMIPS kernels
    
    If we built the kernel targeting the microMIPS ISA then the very fact
    that the kernel is running implies that the CPU supports microMIPS. Thus
    we can hardcode cpu_has_mmips to 1 allowing the compiler greater scope
    for optimisation due to the compile-time constant.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Patchwork: https://patchwork.linux-mips.org/patch/21022/
    Cc: linux-mips@linux-mips.org

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 0edba3e75747..8669fdb503a5 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -195,7 +195,9 @@
 #endif
 
 #ifndef cpu_has_mmips
-# ifdef CONFIG_SYS_SUPPORTS_MICROMIPS
+# if defined(__mips_micromips)
+#  define cpu_has_mmips		1
+# elif defined(CONFIG_SYS_SUPPORTS_MICROMIPS)
 #  define cpu_has_mmips		__opt(MIPS_CPU_MICROMIPS)
 # else
 #  define cpu_has_mmips		0

commit 93e01942a6eb1ce730b42158d0d6c6531fe29ca0
Author: Paul Burton <paul.burton@mips.com>
Date:   Mon Jun 12 11:54:23 2017 -0700

    MIPS: Hardcode cpu_has_* where known at compile time due to ISA
    
    Many architectural features have over time moved from being optional to
    either be required or removed by newer architecture releases. This means
    that in many cases we can know at compile time whether a feature will be
    supported or not purely due to the knowledge we have about the ISA the
    kernel build is targeting.
    
    This patch introduces a bunch of utility macros for checking for
    supported options, ASEs & combinations of those with ISA revisions. It
    then makes use of these in the default definitions of cpu_has_* macros.
    The result is that many of the macros become compile-time constant,
    allowing more optimisation opportunities for the compiler - particularly
    with kernels built for later ISA revisions.
    
    To demonstrate the effect of this patch, the following table shows the
    size in bytes of the kernel binary as reported by scripts/bloat-o-meter
    for v4.12-rc4 maltasmvp_defconfig kernels with & without this patch. A
    variant of maltasmvp_defconfig with CONFIG_CPU_MIPS32_R6 selected is
    also shown, to demonstrate that MIPSr6 systems benefit more due to extra
    features becoming required by that architecture revision. Builds of
    pistachio_defconfig are also shown, as although this is a MIPSr2
    platform it doesn't hardcode any features in a machine-specific
    cpu-feature-overrides.h, which allows it to gain more from this patch
    than the equivalent Malta r2 build.
    
         Config         | Before  | After   |  Change
        ----------------|---------|---------|---------
         maltasmvp      | 7248316 | 7247714 |    -602
         maltasmvp + r6 | 6955595 | 6950777 |   -4818
         pistachio      | 8650977 | 8363898 | -287079
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Patchwork: https://patchwork.linux-mips.org/patch/16360/
    Cc: Joshua Kinard <kumba@gentoo.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 9cdb4e4ce258..0edba3e75747 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -14,39 +14,77 @@
 #include <asm/isa-rev.h>
 #include <cpu-feature-overrides.h>
 
+#define __ase(ase)			(cpu_data[0].ases & (ase))
+#define __opt(opt)			(cpu_data[0].options & (opt))
+
+/*
+ * Check if MIPS_ISA_REV is >= isa *and* an option or ASE is detected during
+ * boot (typically by cpu_probe()).
+ *
+ * Note that these should only be used in cases where a kernel built for an
+ * older ISA *cannot* run on a CPU which supports the feature in question. For
+ * example this may be used for features introduced with MIPSr6, since a kernel
+ * built for an older ISA cannot run on a MIPSr6 CPU. This should not be used
+ * for MIPSr2 features however, since a MIPSr1 or earlier kernel might run on a
+ * MIPSr2 CPU.
+ */
+#define __isa_ge_and_ase(isa, ase)	((MIPS_ISA_REV >= (isa)) && __ase(ase))
+#define __isa_ge_and_opt(isa, opt)	((MIPS_ISA_REV >= (isa)) && __opt(opt))
+
+/*
+ * Check if MIPS_ISA_REV is >= isa *or* an option or ASE is detected during
+ * boot (typically by cpu_probe()).
+ *
+ * These are for use with features that are optional up until a particular ISA
+ * revision & then become required.
+ */
+#define __isa_ge_or_ase(isa, ase)	((MIPS_ISA_REV >= (isa)) || __ase(ase))
+#define __isa_ge_or_opt(isa, opt)	((MIPS_ISA_REV >= (isa)) || __opt(opt))
+
+/*
+ * Check if MIPS_ISA_REV is < isa *and* an option or ASE is detected during
+ * boot (typically by cpu_probe()).
+ *
+ * These are for use with features that are optional up until a particular ISA
+ * revision & are then removed - ie. no longer present in any CPU implementing
+ * the given ISA revision.
+ */
+#define __isa_lt_and_ase(isa, ase)	((MIPS_ISA_REV < (isa)) && __ase(ase))
+#define __isa_lt_and_opt(isa, opt)	((MIPS_ISA_REV < (isa)) && __opt(opt))
+
 /*
  * SMP assumption: Options of CPU 0 are a superset of all processors.
  * This is true for all known MIPS systems.
  */
 #ifndef cpu_has_tlb
-#define cpu_has_tlb		(cpu_data[0].options & MIPS_CPU_TLB)
+#define cpu_has_tlb		__opt(MIPS_CPU_TLB)
 #endif
 #ifndef cpu_has_ftlb
-#define cpu_has_ftlb		(cpu_data[0].options & MIPS_CPU_FTLB)
+#define cpu_has_ftlb		__opt(MIPS_CPU_FTLB)
 #endif
 #ifndef cpu_has_tlbinv
-#define cpu_has_tlbinv		(cpu_data[0].options & MIPS_CPU_TLBINV)
+#define cpu_has_tlbinv		__opt(MIPS_CPU_TLBINV)
 #endif
 #ifndef cpu_has_segments
-#define cpu_has_segments	(cpu_data[0].options & MIPS_CPU_SEGMENTS)
+#define cpu_has_segments	__opt(MIPS_CPU_SEGMENTS)
 #endif
 #ifndef cpu_has_eva
-#define cpu_has_eva		(cpu_data[0].options & MIPS_CPU_EVA)
+#define cpu_has_eva		__opt(MIPS_CPU_EVA)
 #endif
 #ifndef cpu_has_htw
-#define cpu_has_htw		(cpu_data[0].options & MIPS_CPU_HTW)
+#define cpu_has_htw		__opt(MIPS_CPU_HTW)
 #endif
 #ifndef cpu_has_ldpte
-#define cpu_has_ldpte		(cpu_data[0].options & MIPS_CPU_LDPTE)
+#define cpu_has_ldpte		__opt(MIPS_CPU_LDPTE)
 #endif
 #ifndef cpu_has_rixiex
-#define cpu_has_rixiex		(cpu_data[0].options & MIPS_CPU_RIXIEX)
+#define cpu_has_rixiex		__isa_ge_or_opt(6, MIPS_CPU_RIXIEX)
 #endif
 #ifndef cpu_has_maar
-#define cpu_has_maar		(cpu_data[0].options & MIPS_CPU_MAAR)
+#define cpu_has_maar		__opt(MIPS_CPU_MAAR)
 #endif
 #ifndef cpu_has_rw_llb
-#define cpu_has_rw_llb		(cpu_data[0].options & MIPS_CPU_RW_LLB)
+#define cpu_has_rw_llb		__isa_ge_or_opt(6, MIPS_CPU_RW_LLB)
 #endif
 
 /*
@@ -59,18 +97,18 @@
 #define cpu_has_3kex		(!cpu_has_4kex)
 #endif
 #ifndef cpu_has_4kex
-#define cpu_has_4kex		(cpu_data[0].options & MIPS_CPU_4KEX)
+#define cpu_has_4kex		__isa_ge_or_opt(1, MIPS_CPU_4KEX)
 #endif
 #ifndef cpu_has_3k_cache
-#define cpu_has_3k_cache	(cpu_data[0].options & MIPS_CPU_3K_CACHE)
+#define cpu_has_3k_cache	__isa_lt_and_opt(1, MIPS_CPU_3K_CACHE)
 #endif
 #define cpu_has_6k_cache	0
 #define cpu_has_8k_cache	0
 #ifndef cpu_has_4k_cache
-#define cpu_has_4k_cache	(cpu_data[0].options & MIPS_CPU_4K_CACHE)
+#define cpu_has_4k_cache	__isa_ge_or_opt(1, MIPS_CPU_4K_CACHE)
 #endif
 #ifndef cpu_has_tx39_cache
-#define cpu_has_tx39_cache	(cpu_data[0].options & MIPS_CPU_TX39_CACHE)
+#define cpu_has_tx39_cache	__opt(MIPS_CPU_TX39_CACHE)
 #endif
 #ifndef cpu_has_octeon_cache
 #define cpu_has_octeon_cache	0
@@ -83,92 +121,92 @@
 #define raw_cpu_has_fpu		cpu_has_fpu
 #endif
 #ifndef cpu_has_32fpr
-#define cpu_has_32fpr		(cpu_data[0].options & MIPS_CPU_32FPR)
+#define cpu_has_32fpr		__isa_ge_or_opt(1, MIPS_CPU_32FPR)
 #endif
 #ifndef cpu_has_counter
-#define cpu_has_counter		(cpu_data[0].options & MIPS_CPU_COUNTER)
+#define cpu_has_counter		__opt(MIPS_CPU_COUNTER)
 #endif
 #ifndef cpu_has_watch
-#define cpu_has_watch		(cpu_data[0].options & MIPS_CPU_WATCH)
+#define cpu_has_watch		__opt(MIPS_CPU_WATCH)
 #endif
 #ifndef cpu_has_divec
-#define cpu_has_divec		(cpu_data[0].options & MIPS_CPU_DIVEC)
+#define cpu_has_divec		__isa_ge_or_opt(1, MIPS_CPU_DIVEC)
 #endif
 #ifndef cpu_has_vce
-#define cpu_has_vce		(cpu_data[0].options & MIPS_CPU_VCE)
+#define cpu_has_vce		__opt(MIPS_CPU_VCE)
 #endif
 #ifndef cpu_has_cache_cdex_p
-#define cpu_has_cache_cdex_p	(cpu_data[0].options & MIPS_CPU_CACHE_CDEX_P)
+#define cpu_has_cache_cdex_p	__opt(MIPS_CPU_CACHE_CDEX_P)
 #endif
 #ifndef cpu_has_cache_cdex_s
-#define cpu_has_cache_cdex_s	(cpu_data[0].options & MIPS_CPU_CACHE_CDEX_S)
+#define cpu_has_cache_cdex_s	__opt(MIPS_CPU_CACHE_CDEX_S)
 #endif
 #ifndef cpu_has_prefetch
-#define cpu_has_prefetch	(cpu_data[0].options & MIPS_CPU_PREFETCH)
+#define cpu_has_prefetch	__isa_ge_or_opt(1, MIPS_CPU_PREFETCH)
 #endif
 #ifndef cpu_has_mcheck
-#define cpu_has_mcheck		(cpu_data[0].options & MIPS_CPU_MCHECK)
+#define cpu_has_mcheck		__isa_ge_or_opt(1, MIPS_CPU_MCHECK)
 #endif
 #ifndef cpu_has_ejtag
-#define cpu_has_ejtag		(cpu_data[0].options & MIPS_CPU_EJTAG)
+#define cpu_has_ejtag		__opt(MIPS_CPU_EJTAG)
 #endif
 #ifndef cpu_has_llsc
-#define cpu_has_llsc		(cpu_data[0].options & MIPS_CPU_LLSC)
+#define cpu_has_llsc		__isa_ge_or_opt(1, MIPS_CPU_LLSC)
 #endif
 #ifndef cpu_has_bp_ghist
-#define cpu_has_bp_ghist	(cpu_data[0].options & MIPS_CPU_BP_GHIST)
+#define cpu_has_bp_ghist	__opt(MIPS_CPU_BP_GHIST)
 #endif
 #ifndef kernel_uses_llsc
 #define kernel_uses_llsc	cpu_has_llsc
 #endif
 #ifndef cpu_has_guestctl0ext
-#define cpu_has_guestctl0ext	(cpu_data[0].options & MIPS_CPU_GUESTCTL0EXT)
+#define cpu_has_guestctl0ext	__opt(MIPS_CPU_GUESTCTL0EXT)
 #endif
 #ifndef cpu_has_guestctl1
-#define cpu_has_guestctl1	(cpu_data[0].options & MIPS_CPU_GUESTCTL1)
+#define cpu_has_guestctl1	__opt(MIPS_CPU_GUESTCTL1)
 #endif
 #ifndef cpu_has_guestctl2
-#define cpu_has_guestctl2	(cpu_data[0].options & MIPS_CPU_GUESTCTL2)
+#define cpu_has_guestctl2	__opt(MIPS_CPU_GUESTCTL2)
 #endif
 #ifndef cpu_has_guestid
-#define cpu_has_guestid		(cpu_data[0].options & MIPS_CPU_GUESTID)
+#define cpu_has_guestid		__opt(MIPS_CPU_GUESTID)
 #endif
 #ifndef cpu_has_drg
-#define cpu_has_drg		(cpu_data[0].options & MIPS_CPU_DRG)
+#define cpu_has_drg		__opt(MIPS_CPU_DRG)
 #endif
 #ifndef cpu_has_mips16
-#define cpu_has_mips16		(cpu_data[0].ases & MIPS_ASE_MIPS16)
+#define cpu_has_mips16		__isa_lt_and_ase(6, MIPS_ASE_MIPS16)
 #endif
 #ifndef cpu_has_mips16e2
-#define cpu_has_mips16e2	(cpu_data[0].ases & MIPS_ASE_MIPS16E2)
+#define cpu_has_mips16e2	__isa_lt_and_ase(6, MIPS_ASE_MIPS16E2)
 #endif
 #ifndef cpu_has_mdmx
-#define cpu_has_mdmx		(cpu_data[0].ases & MIPS_ASE_MDMX)
+#define cpu_has_mdmx		__isa_lt_and_ase(6, MIPS_ASE_MDMX)
 #endif
 #ifndef cpu_has_mips3d
-#define cpu_has_mips3d		(cpu_data[0].ases & MIPS_ASE_MIPS3D)
+#define cpu_has_mips3d		__isa_lt_and_ase(6, MIPS_ASE_MIPS3D)
 #endif
 #ifndef cpu_has_smartmips
-#define cpu_has_smartmips	(cpu_data[0].ases & MIPS_ASE_SMARTMIPS)
+#define cpu_has_smartmips	__isa_lt_and_ase(6, MIPS_ASE_SMARTMIPS)
 #endif
 
 #ifndef cpu_has_rixi
-#define cpu_has_rixi		(cpu_data[0].options & MIPS_CPU_RIXI)
+#define cpu_has_rixi		__isa_ge_or_opt(6, MIPS_CPU_RIXI)
 #endif
 
 #ifndef cpu_has_mmips
 # ifdef CONFIG_SYS_SUPPORTS_MICROMIPS
-#  define cpu_has_mmips		(cpu_data[0].options & MIPS_CPU_MICROMIPS)
+#  define cpu_has_mmips		__opt(MIPS_CPU_MICROMIPS)
 # else
 #  define cpu_has_mmips		0
 # endif
 #endif
 
 #ifndef cpu_has_lpa
-#define cpu_has_lpa		(cpu_data[0].options & MIPS_CPU_LPA)
+#define cpu_has_lpa		__opt(MIPS_CPU_LPA)
 #endif
 #ifndef cpu_has_mvh
-#define cpu_has_mvh		(cpu_data[0].options & MIPS_CPU_MVH)
+#define cpu_has_mvh		__opt(MIPS_CPU_MVH)
 #endif
 #ifndef cpu_has_xpa
 #define cpu_has_xpa		(cpu_has_lpa && cpu_has_mvh)
@@ -338,32 +376,32 @@
 #endif
 
 #ifndef cpu_has_dsp
-#define cpu_has_dsp		(cpu_data[0].ases & MIPS_ASE_DSP)
+#define cpu_has_dsp		__ase(MIPS_ASE_DSP)
 #endif
 
 #ifndef cpu_has_dsp2
-#define cpu_has_dsp2		(cpu_data[0].ases & MIPS_ASE_DSP2P)
+#define cpu_has_dsp2		__ase(MIPS_ASE_DSP2P)
 #endif
 
 #ifndef cpu_has_dsp3
-#define cpu_has_dsp3		(cpu_data[0].ases & MIPS_ASE_DSP3)
+#define cpu_has_dsp3		__ase(MIPS_ASE_DSP3)
 #endif
 
 #ifndef cpu_has_mipsmt
-#define cpu_has_mipsmt		(cpu_data[0].ases & MIPS_ASE_MIPSMT)
+#define cpu_has_mipsmt		__isa_lt_and_ase(6, MIPS_ASE_MIPSMT)
 #endif
 
 #ifndef cpu_has_vp
-#define cpu_has_vp		(cpu_data[0].options & MIPS_CPU_VP)
+#define cpu_has_vp		__isa_ge_and_opt(6, MIPS_CPU_VP)
 #endif
 
 #ifndef cpu_has_userlocal
-#define cpu_has_userlocal	(cpu_data[0].options & MIPS_CPU_ULRI)
+#define cpu_has_userlocal	__isa_ge_or_opt(6, MIPS_CPU_ULRI)
 #endif
 
 #ifdef CONFIG_32BIT
 # ifndef cpu_has_nofpuex
-# define cpu_has_nofpuex	(cpu_data[0].options & MIPS_CPU_NOFPUEX)
+# define cpu_has_nofpuex	__isa_lt_and_opt(1, MIPS_CPU_NOFPUEX)
 # endif
 # ifndef cpu_has_64bits
 # define cpu_has_64bits		(cpu_data[0].isa_level & MIPS_CPU_ISA_64BIT)
@@ -405,19 +443,19 @@
 #endif
 
 #if defined(CONFIG_CPU_MIPSR2_IRQ_VI) && !defined(cpu_has_vint)
-# define cpu_has_vint		(cpu_data[0].options & MIPS_CPU_VINT)
+# define cpu_has_vint		__opt(MIPS_CPU_VINT)
 #elif !defined(cpu_has_vint)
 # define cpu_has_vint			0
 #endif
 
 #if defined(CONFIG_CPU_MIPSR2_IRQ_EI) && !defined(cpu_has_veic)
-# define cpu_has_veic		(cpu_data[0].options & MIPS_CPU_VEIC)
+# define cpu_has_veic		__opt(MIPS_CPU_VEIC)
 #elif !defined(cpu_has_veic)
 # define cpu_has_veic			0
 #endif
 
 #ifndef cpu_has_inclusive_pcaches
-#define cpu_has_inclusive_pcaches	(cpu_data[0].options & MIPS_CPU_INCLUSIVE_CACHES)
+#define cpu_has_inclusive_pcaches	__opt(MIPS_CPU_INCLUSIVE_CACHES)
 #endif
 
 #ifndef cpu_dcache_line_size
@@ -438,63 +476,63 @@
 #endif
 
 #ifndef cpu_has_perf_cntr_intr_bit
-#define cpu_has_perf_cntr_intr_bit	(cpu_data[0].options & MIPS_CPU_PCI)
+#define cpu_has_perf_cntr_intr_bit	__opt(MIPS_CPU_PCI)
 #endif
 
 #ifndef cpu_has_vz
-#define cpu_has_vz		(cpu_data[0].ases & MIPS_ASE_VZ)
+#define cpu_has_vz		__ase(MIPS_ASE_VZ)
 #endif
 
 #if defined(CONFIG_CPU_HAS_MSA) && !defined(cpu_has_msa)
-# define cpu_has_msa		(cpu_data[0].ases & MIPS_ASE_MSA)
+# define cpu_has_msa		__ase(MIPS_ASE_MSA)
 #elif !defined(cpu_has_msa)
 # define cpu_has_msa		0
 #endif
 
 #ifndef cpu_has_ufr
-# define cpu_has_ufr		(cpu_data[0].options & MIPS_CPU_UFR)
+# define cpu_has_ufr		__opt(MIPS_CPU_UFR)
 #endif
 
 #ifndef cpu_has_fre
-# define cpu_has_fre		(cpu_data[0].options & MIPS_CPU_FRE)
+# define cpu_has_fre		__opt(MIPS_CPU_FRE)
 #endif
 
 #ifndef cpu_has_cdmm
-# define cpu_has_cdmm		(cpu_data[0].options & MIPS_CPU_CDMM)
+# define cpu_has_cdmm		__opt(MIPS_CPU_CDMM)
 #endif
 
 #ifndef cpu_has_small_pages
-# define cpu_has_small_pages	(cpu_data[0].options & MIPS_CPU_SP)
+# define cpu_has_small_pages	__opt(MIPS_CPU_SP)
 #endif
 
 #ifndef cpu_has_nan_legacy
-#define cpu_has_nan_legacy	(cpu_data[0].options & MIPS_CPU_NAN_LEGACY)
+#define cpu_has_nan_legacy	__isa_lt_and_opt(6, MIPS_CPU_NAN_LEGACY)
 #endif
 #ifndef cpu_has_nan_2008
-#define cpu_has_nan_2008	(cpu_data[0].options & MIPS_CPU_NAN_2008)
+#define cpu_has_nan_2008	__isa_ge_or_opt(6, MIPS_CPU_NAN_2008)
 #endif
 
 #ifndef cpu_has_ebase_wg
-# define cpu_has_ebase_wg	(cpu_data[0].options & MIPS_CPU_EBASE_WG)
+# define cpu_has_ebase_wg	__opt(MIPS_CPU_EBASE_WG)
 #endif
 
 #ifndef cpu_has_badinstr
-# define cpu_has_badinstr	(cpu_data[0].options & MIPS_CPU_BADINSTR)
+# define cpu_has_badinstr	__isa_ge_or_opt(6, MIPS_CPU_BADINSTR)
 #endif
 
 #ifndef cpu_has_badinstrp
-# define cpu_has_badinstrp	(cpu_data[0].options & MIPS_CPU_BADINSTRP)
+# define cpu_has_badinstrp	__isa_ge_or_opt(6, MIPS_CPU_BADINSTRP)
 #endif
 
 #ifndef cpu_has_contextconfig
-# define cpu_has_contextconfig	(cpu_data[0].options & MIPS_CPU_CTXTC)
+# define cpu_has_contextconfig	__opt(MIPS_CPU_CTXTC)
 #endif
 
 #ifndef cpu_has_perf
-# define cpu_has_perf		(cpu_data[0].options & MIPS_CPU_PERF)
+# define cpu_has_perf		__opt(MIPS_CPU_PERF)
 #endif
 
-#if defined(CONFIG_SMP) && (MIPS_ISA_REV >= 6)
+#ifdef CONFIG_SMP
 /*
  * Some systems share FTLB RAMs between threads within a core (siblings in
  * kernel parlance). This means that FTLB entries may become invalid at almost
@@ -507,7 +545,7 @@
  */
 # ifndef cpu_has_shared_ftlb_ram
 #  define cpu_has_shared_ftlb_ram \
-	(current_cpu_data.options & MIPS_CPU_SHARED_FTLB_RAM)
+	__isa_ge_and_opt(6, MIPS_CPU_SHARED_FTLB_RAM)
 # endif
 
 /*
@@ -524,9 +562,9 @@
  */
 # ifndef cpu_has_shared_ftlb_entries
 #  define cpu_has_shared_ftlb_entries \
-	(current_cpu_data.options & MIPS_CPU_SHARED_FTLB_ENTRIES)
+	__isa_ge_and_opt(6, MIPS_CPU_SHARED_FTLB_ENTRIES)
 # endif
-#endif /* SMP && MIPS_ISA_REV >= 6 */
+#endif /* SMP */
 
 #ifndef cpu_has_shared_ftlb_ram
 # define cpu_has_shared_ftlb_ram 0
@@ -537,7 +575,7 @@
 
 #ifdef CONFIG_MIPS_MT_SMP
 # define cpu_has_mipsmt_pertccounters \
-	(cpu_data[0].options & MIPS_CPU_MT_PER_TC_PERF_COUNTERS)
+	__isa_lt_and_opt(6, MIPS_CPU_MT_PER_TC_PERF_COUNTERS)
 #else
 # define cpu_has_mipsmt_pertccounters 0
 #endif /* CONFIG_MIPS_MT_SMP */

commit 800fb71281ca2ed5c8a7299e10ebc0de2f61cdda
Author: Matt Redfearn <matt.redfearn@mips.com>
Date:   Fri Apr 20 11:23:04 2018 +0100

    MIPS: perf: More robustly probe for the presence of per-tc counters
    
    The presence of per TC performance counters is now detected by
    cpu-probe.c and indicated by MIPS_CPU_MT_PER_TC_PERF_COUNTERS in
    cpu_data. Switch detection of the feature to use this new flag rather
    than blindly testing the implementation specific config7 register with a
    magic number.
    
    Signed-off-by: Matt Redfearn <matt.redfearn@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Maciej W. Rozycki <macro@mips.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Robert Richter <rric@kernel.org>
    Cc: linux-mips@linux-mips.org
    Cc: oprofile-list@lists.sf.net
    Patchwork: https://patchwork.linux-mips.org/patch/19142/
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 5f74590e0bea..9cdb4e4ce258 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -535,6 +535,13 @@
 # define cpu_has_shared_ftlb_entries 0
 #endif
 
+#ifdef CONFIG_MIPS_MT_SMP
+# define cpu_has_mipsmt_pertccounters \
+	(cpu_data[0].options & MIPS_CPU_MT_PER_TC_PERF_COUNTERS)
+#else
+# define cpu_has_mipsmt_pertccounters 0
+#endif /* CONFIG_MIPS_MT_SMP */
+
 /*
  * Guest capabilities
  */

commit 18ba210a29d08ea96025cb9d19c2eebf65846330
Author: Matt Redfearn <matt.redfearn@mips.com>
Date:   Mon Feb 26 17:02:43 2018 +0000

    MIPS: cpu-features.h: Replace __mips_isa_rev with MIPS_ISA_REV
    
    Remove the need to check that __mips_isa_rev is defined by using the
    newly added MIPS_ISA_REV.
    
    Signed-off-by: Matt Redfearn <matt.redfearn@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: "Maciej W. Rozycki" <macro@mips.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/18675/
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 721b698bfe3c..5f74590e0bea 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -11,6 +11,7 @@
 
 #include <asm/cpu.h>
 #include <asm/cpu-info.h>
+#include <asm/isa-rev.h>
 #include <cpu-feature-overrides.h>
 
 /*
@@ -493,7 +494,7 @@
 # define cpu_has_perf		(cpu_data[0].options & MIPS_CPU_PERF)
 #endif
 
-#if defined(CONFIG_SMP) && defined(__mips_isa_rev) && (__mips_isa_rev >= 6)
+#if defined(CONFIG_SMP) && (MIPS_ISA_REV >= 6)
 /*
  * Some systems share FTLB RAMs between threads within a core (siblings in
  * kernel parlance). This means that FTLB entries may become invalid at almost
@@ -525,7 +526,7 @@
 #  define cpu_has_shared_ftlb_entries \
 	(current_cpu_data.options & MIPS_CPU_SHARED_FTLB_ENTRIES)
 # endif
-#endif /* SMP && __mips_isa_rev >= 6 */
+#endif /* SMP && MIPS_ISA_REV >= 6 */
 
 #ifndef cpu_has_shared_ftlb_ram
 # define cpu_has_shared_ftlb_ram 0

commit 21da5332327b6d183bd93336ecf29c70bc609b7b
Author: Matt Redfearn <matt.redfearn@imgtec.com>
Date:   Wed Jul 26 08:41:08 2017 +0100

    MIPS: Introduce cpu_tcache_line_size
    
    There exist macros to return the cache line size of the L1 dcache and L2
    scache but there is currently no macro for the L3 tcache. Add this macro
    which will be used by the following patch "MIPS: PCI: Fix
    smp_processor_id() in preemptible"
    
    Signed-off-by: Matt Redfearn <matt.redfearn@imgtec.com>
    Cc: Maciej W. Rozycki <macro@imgtec.com>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/16871/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 8baa9033b181..721b698bfe3c 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -428,6 +428,9 @@
 #ifndef cpu_scache_line_size
 #define cpu_scache_line_size()	cpu_data[0].scache.linesz
 #endif
+#ifndef cpu_tcache_line_size
+#define cpu_tcache_line_size()	cpu_data[0].tcache.linesz
+#endif
 
 #ifndef cpu_hwrena_impl_bits
 #define cpu_hwrena_impl_bits		0

commit 8d1630f13754f1435d3ea7078829121c52f38d15
Author: Maciej W. Rozycki <macro@imgtec.com>
Date:   Tue May 23 13:37:05 2017 +0100

    MIPS: MIPS16e2: Identify ASE presence
    
    Identify the presence of the MIPS16e2 ASE as per the architecture
    specification[1], by checking for CP0 Config5.CA2 bit being 1[2].
    
    References:
    
    [1] "MIPS32 Architecture for Programmers: MIPS16e2 Application-Specific
        Extension Technical Reference Manual", Imagination Technologies
        Ltd., Document Number: MD01172, Revision 01.00, April 26, 2016,
        Section 1.2 "Software Detection of the ASE", p. 5
    
    [2] "MIPS32 interAptiv Multiprocessing System Software User's Manual",
        Imagination Technologies Ltd., Document Number: MD00904, Revision
        02.01, June 15, 2016, Section 2.2.1.6 "Device Configuration 5 --
        Config5 (CP0 Register 16, Select 5)", pp. 71-72
    
    Signed-off-by: Maciej W. Rozycki <macro@imgtec.com>
    Reviewed-by: James Hogan <james.hogan@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/16094/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index d6ea8e7c5107..8baa9033b181 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -138,6 +138,9 @@
 #ifndef cpu_has_mips16
 #define cpu_has_mips16		(cpu_data[0].ases & MIPS_ASE_MIPS16)
 #endif
+#ifndef cpu_has_mips16e2
+#define cpu_has_mips16e2	(cpu_data[0].ases & MIPS_ASE_MIPS16E2)
+#endif
 #ifndef cpu_has_mdmx
 #define cpu_has_mdmx		(cpu_data[0].ases & MIPS_ASE_MDMX)
 #endif

commit e7bc8557428f069eaa613b3676ea6931c0f7fe43
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Fri Jun 2 15:38:01 2017 -0700

    MIPS: Add CPU shared FTLB feature detection
    
    Some systems share FTLB RAMs or entries between sibling CPUs (ie.
    hardware threads, or VP(E)s, within a core). These properties require
    kernel handling in various places. As a start this patch introduces
    cpu_has_shared_ftlb_ram & cpu_has_shared_ftlb_entries feature macros
    which we set appropriately for I6400 & I6500 CPUs. Further patches will
    make use of these macros as appropriate.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/16202/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 494d38274142..d6ea8e7c5107 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -487,6 +487,47 @@
 # define cpu_has_perf		(cpu_data[0].options & MIPS_CPU_PERF)
 #endif
 
+#if defined(CONFIG_SMP) && defined(__mips_isa_rev) && (__mips_isa_rev >= 6)
+/*
+ * Some systems share FTLB RAMs between threads within a core (siblings in
+ * kernel parlance). This means that FTLB entries may become invalid at almost
+ * any point when an entry is evicted due to a sibling thread writing an entry
+ * to the shared FTLB RAM.
+ *
+ * This is only relevant to SMP systems, and the only systems that exhibit this
+ * property implement MIPSr6 or higher so we constrain support for this to
+ * kernels that will run on such systems.
+ */
+# ifndef cpu_has_shared_ftlb_ram
+#  define cpu_has_shared_ftlb_ram \
+	(current_cpu_data.options & MIPS_CPU_SHARED_FTLB_RAM)
+# endif
+
+/*
+ * Some systems take this a step further & share FTLB entries between siblings.
+ * This is implemented as TLB writes happening as usual, but if an entry
+ * written by a sibling exists in the shared FTLB for a translation which would
+ * otherwise cause a TLB refill exception then the CPU will use the entry
+ * written by its sibling rather than triggering a refill & writing a matching
+ * TLB entry for itself.
+ *
+ * This is naturally only valid if a TLB entry is known to be suitable for use
+ * on all siblings in a CPU, and so it only takes effect when MMIDs are in use
+ * rather than ASIDs or when a TLB entry is marked global.
+ */
+# ifndef cpu_has_shared_ftlb_entries
+#  define cpu_has_shared_ftlb_entries \
+	(current_cpu_data.options & MIPS_CPU_SHARED_FTLB_ENTRIES)
+# endif
+#endif /* SMP && __mips_isa_rev >= 6 */
+
+#ifndef cpu_has_shared_ftlb_ram
+# define cpu_has_shared_ftlb_ram 0
+#endif
+#ifndef cpu_has_shared_ftlb_entries
+# define cpu_has_shared_ftlb_entries 0
+#endif
+
 /*
  * Guest capabilities
  */

commit a929bdc52be658fd622c2d0f9fdf1d333aea34fd
Author: James Hogan <james.hogan@imgtec.com>
Date:   Tue Mar 14 10:15:11 2017 +0000

    MIPS: Probe guest MVH
    
    Probe for availablility of M{T,F}HC0 instructions used with e.g. XPA in
    the VZ guest context, and make it available via cpu_guest_has_mvh. This
    will be helpful in properly emulating the MAAR registers in KVM for MIPS
    VZ.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: "Radim Krčmář" <rkrcmar@redhat.com>
    Cc: linux-mips@linux-mips.org
    Cc: kvm@vger.kernel.org

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index e898f441cc22..494d38274142 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -532,6 +532,9 @@
 #ifndef cpu_guest_has_htw
 #define cpu_guest_has_htw	(cpu_data[0].guest.options & MIPS_CPU_HTW)
 #endif
+#ifndef cpu_guest_has_mvh
+#define cpu_guest_has_mvh	(cpu_data[0].guest.options & MIPS_CPU_MVH)
+#endif
 #ifndef cpu_guest_has_msa
 #define cpu_guest_has_msa	(cpu_data[0].guest.ases & MIPS_ASE_MSA)
 #endif

commit a7c7ad6c3e0a2ae88625df4e41c1c7305aa26f04
Author: James Hogan <james.hogan@imgtec.com>
Date:   Tue Mar 14 10:15:10 2017 +0000

    MIPS: Probe guest CP0_UserLocal
    
    Probe for presence of guest CP0_UserLocal register and expose via
    cpu_guest_has_userlocal. This register is optional pre-r6, so this will
    allow KVM to only save/restore/expose the guest CP0_UserLocal register
    if it exists.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: "Radim Krčmář" <rkrcmar@redhat.com>
    Cc: linux-mips@linux-mips.org
    Cc: kvm@vger.kernel.org

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index e12d4ec6854d..e898f441cc22 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -547,6 +547,9 @@
 #ifndef cpu_guest_has_maar
 #define cpu_guest_has_maar	(cpu_data[0].guest.options & MIPS_CPU_MAAR)
 #endif
+#ifndef cpu_guest_has_userlocal
+#define cpu_guest_has_userlocal	(cpu_data[0].guest.options & MIPS_CPU_ULRI)
+#endif
 
 /*
  * Guest dynamic capabilities

commit 4e87580e6d144e44820a0d23e756136b6218f4f0
Author: James Hogan <james.hogan@imgtec.com>
Date:   Tue Mar 14 10:15:08 2017 +0000

    MIPS: Add defs & probing of UFR
    
    Add definitions and probing of the UFR bit in Config5. This bit allows
    user mode control of the FR bit (floating point register mode). It is
    present if the UFRP bit is set in the floating point implementation
    register.
    
    This is a capability KVM may want to expose to guest kernels, even
    though Linux is unlikely to ever use it due to the implications for
    multi-threaded programs.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: "Radim Krčmář" <rkrcmar@redhat.com>
    Cc: linux-mips@linux-mips.org
    Cc: kvm@vger.kernel.org

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index e961c8a7ea66..e12d4ec6854d 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -444,6 +444,10 @@
 # define cpu_has_msa		0
 #endif
 
+#ifndef cpu_has_ufr
+# define cpu_has_ufr		(cpu_data[0].options & MIPS_CPU_UFR)
+#endif
+
 #ifndef cpu_has_fre
 # define cpu_has_fre		(cpu_data[0].options & MIPS_CPU_FRE)
 #endif

commit fff7fb0b2d908dec779783d8eaf3d7725230f75e
Author: Zhaoxiu Zeng <zhaoxiu.zeng@gmail.com>
Date:   Fri May 20 17:03:57 2016 -0700

    lib/GCD.c: use binary GCD algorithm instead of Euclidean
    
    The binary GCD algorithm is based on the following facts:
            1. If a and b are all evens, then gcd(a,b) = 2 * gcd(a/2, b/2)
            2. If a is even and b is odd, then gcd(a,b) = gcd(a/2, b)
            3. If a and b are all odds, then gcd(a,b) = gcd((a-b)/2, b) = gcd((a+b)/2, b)
    
    Even on x86 machines with reasonable division hardware, the binary
    algorithm runs about 25% faster (80% the execution time) than the
    division-based Euclidian algorithm.
    
    On platforms like Alpha and ARMv6 where division is a function call to
    emulation code, it's even more significant.
    
    There are two variants of the code here, depending on whether a fast
    __ffs (find least significant set bit) instruction is available.  This
    allows the unpredictable branches in the bit-at-a-time shifting loop to
    be eliminated.
    
    If fast __ffs is not available, the "even/odd" GCD variant is used.
    
    I use the following code to benchmark:
    
            #include <stdio.h>
            #include <stdlib.h>
            #include <stdint.h>
            #include <string.h>
            #include <time.h>
            #include <unistd.h>
    
            #define swap(a, b) \
                    do { \
                            a ^= b; \
                            b ^= a; \
                            a ^= b; \
                    } while (0)
    
            unsigned long gcd0(unsigned long a, unsigned long b)
            {
                    unsigned long r;
    
                    if (a < b) {
                            swap(a, b);
                    }
    
                    if (b == 0)
                            return a;
    
                    while ((r = a % b) != 0) {
                            a = b;
                            b = r;
                    }
    
                    return b;
            }
    
            unsigned long gcd1(unsigned long a, unsigned long b)
            {
                    unsigned long r = a | b;
    
                    if (!a || !b)
                            return r;
    
                    b >>= __builtin_ctzl(b);
    
                    for (;;) {
                            a >>= __builtin_ctzl(a);
                            if (a == b)
                                    return a << __builtin_ctzl(r);
    
                            if (a < b)
                                    swap(a, b);
                            a -= b;
                    }
            }
    
            unsigned long gcd2(unsigned long a, unsigned long b)
            {
                    unsigned long r = a | b;
    
                    if (!a || !b)
                            return r;
    
                    r &= -r;
    
                    while (!(b & r))
                            b >>= 1;
    
                    for (;;) {
                            while (!(a & r))
                                    a >>= 1;
                            if (a == b)
                                    return a;
    
                            if (a < b)
                                    swap(a, b);
                            a -= b;
                            a >>= 1;
                            if (a & r)
                                    a += b;
                            a >>= 1;
                    }
            }
    
            unsigned long gcd3(unsigned long a, unsigned long b)
            {
                    unsigned long r = a | b;
    
                    if (!a || !b)
                            return r;
    
                    b >>= __builtin_ctzl(b);
                    if (b == 1)
                            return r & -r;
    
                    for (;;) {
                            a >>= __builtin_ctzl(a);
                            if (a == 1)
                                    return r & -r;
                            if (a == b)
                                    return a << __builtin_ctzl(r);
    
                            if (a < b)
                                    swap(a, b);
                            a -= b;
                    }
            }
    
            unsigned long gcd4(unsigned long a, unsigned long b)
            {
                    unsigned long r = a | b;
    
                    if (!a || !b)
                            return r;
    
                    r &= -r;
    
                    while (!(b & r))
                            b >>= 1;
                    if (b == r)
                            return r;
    
                    for (;;) {
                            while (!(a & r))
                                    a >>= 1;
                            if (a == r)
                                    return r;
                            if (a == b)
                                    return a;
    
                            if (a < b)
                                    swap(a, b);
                            a -= b;
                            a >>= 1;
                            if (a & r)
                                    a += b;
                            a >>= 1;
                    }
            }
    
            static unsigned long (*gcd_func[])(unsigned long a, unsigned long b) = {
                    gcd0, gcd1, gcd2, gcd3, gcd4,
            };
    
            #define TEST_ENTRIES (sizeof(gcd_func) / sizeof(gcd_func[0]))
    
            #if defined(__x86_64__)
    
            #define rdtscll(val) do { \
                    unsigned long __a,__d; \
                    __asm__ __volatile__("rdtsc" : "=a" (__a), "=d" (__d)); \
                    (val) = ((unsigned long long)__a) | (((unsigned long long)__d)<<32); \
            } while(0)
    
            static unsigned long long benchmark_gcd_func(unsigned long (*gcd)(unsigned long, unsigned long),
                                                                    unsigned long a, unsigned long b, unsigned long *res)
            {
                    unsigned long long start, end;
                    unsigned long long ret;
                    unsigned long gcd_res;
    
                    rdtscll(start);
                    gcd_res = gcd(a, b);
                    rdtscll(end);
    
                    if (end >= start)
                            ret = end - start;
                    else
                            ret = ~0ULL - start + 1 + end;
    
                    *res = gcd_res;
                    return ret;
            }
    
            #else
    
            static inline struct timespec read_time(void)
            {
                    struct timespec time;
                    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &time);
                    return time;
            }
    
            static inline unsigned long long diff_time(struct timespec start, struct timespec end)
            {
                    struct timespec temp;
    
                    if ((end.tv_nsec - start.tv_nsec) < 0) {
                            temp.tv_sec = end.tv_sec - start.tv_sec - 1;
                            temp.tv_nsec = 1000000000ULL + end.tv_nsec - start.tv_nsec;
                    } else {
                            temp.tv_sec = end.tv_sec - start.tv_sec;
                            temp.tv_nsec = end.tv_nsec - start.tv_nsec;
                    }
    
                    return temp.tv_sec * 1000000000ULL + temp.tv_nsec;
            }
    
            static unsigned long long benchmark_gcd_func(unsigned long (*gcd)(unsigned long, unsigned long),
                                                                    unsigned long a, unsigned long b, unsigned long *res)
            {
                    struct timespec start, end;
                    unsigned long gcd_res;
    
                    start = read_time();
                    gcd_res = gcd(a, b);
                    end = read_time();
    
                    *res = gcd_res;
                    return diff_time(start, end);
            }
    
            #endif
    
            static inline unsigned long get_rand()
            {
                    if (sizeof(long) == 8)
                            return (unsigned long)rand() << 32 | rand();
                    else
                            return rand();
            }
    
            int main(int argc, char **argv)
            {
                    unsigned int seed = time(0);
                    int loops = 100;
                    int repeats = 1000;
                    unsigned long (*res)[TEST_ENTRIES];
                    unsigned long long elapsed[TEST_ENTRIES];
                    int i, j, k;
    
                    for (;;) {
                            int opt = getopt(argc, argv, "n:r:s:");
                            /* End condition always first */
                            if (opt == -1)
                                    break;
    
                            switch (opt) {
                            case 'n':
                                    loops = atoi(optarg);
                                    break;
                            case 'r':
                                    repeats = atoi(optarg);
                                    break;
                            case 's':
                                    seed = strtoul(optarg, NULL, 10);
                                    break;
                            default:
                                    /* You won't actually get here. */
                                    break;
                            }
                    }
    
                    res = malloc(sizeof(unsigned long) * TEST_ENTRIES * loops);
                    memset(elapsed, 0, sizeof(elapsed));
    
                    srand(seed);
                    for (j = 0; j < loops; j++) {
                            unsigned long a = get_rand();
                            /* Do we have args? */
                            unsigned long b = argc > optind ? strtoul(argv[optind], NULL, 10) : get_rand();
                            unsigned long long min_elapsed[TEST_ENTRIES];
                            for (k = 0; k < repeats; k++) {
                                    for (i = 0; i < TEST_ENTRIES; i++) {
                                            unsigned long long tmp = benchmark_gcd_func(gcd_func[i], a, b, &res[j][i]);
                                            if (k == 0 || min_elapsed[i] > tmp)
                                                    min_elapsed[i] = tmp;
                                    }
                            }
                            for (i = 0; i < TEST_ENTRIES; i++)
                                    elapsed[i] += min_elapsed[i];
                    }
    
                    for (i = 0; i < TEST_ENTRIES; i++)
                            printf("gcd%d: elapsed %llu\n", i, elapsed[i]);
    
                    k = 0;
                    srand(seed);
                    for (j = 0; j < loops; j++) {
                            unsigned long a = get_rand();
                            unsigned long b = argc > optind ? strtoul(argv[optind], NULL, 10) : get_rand();
                            for (i = 1; i < TEST_ENTRIES; i++) {
                                    if (res[j][i] != res[j][0])
                                            break;
                            }
                            if (i < TEST_ENTRIES) {
                                    if (k == 0) {
                                            k = 1;
                                            fprintf(stderr, "Error:\n");
                                    }
                                    fprintf(stderr, "gcd(%lu, %lu): ", a, b);
                                    for (i = 0; i < TEST_ENTRIES; i++)
                                            fprintf(stderr, "%ld%s", res[j][i], i < TEST_ENTRIES - 1 ? ", " : "\n");
                            }
                    }
    
                    if (k == 0)
                            fprintf(stderr, "PASS\n");
    
                    free(res);
    
                    return 0;
            }
    
    Compiled with "-O2", on "VirtualBox 4.4.0-22-generic #38-Ubuntu x86_64" got:
    
      zhaoxiuzeng@zhaoxiuzeng-VirtualBox:~/develop$ ./gcd -r 500000 -n 10
      gcd0: elapsed 10174
      gcd1: elapsed 2120
      gcd2: elapsed 2902
      gcd3: elapsed 2039
      gcd4: elapsed 2812
      PASS
      zhaoxiuzeng@zhaoxiuzeng-VirtualBox:~/develop$ ./gcd -r 500000 -n 10
      gcd0: elapsed 9309
      gcd1: elapsed 2280
      gcd2: elapsed 2822
      gcd3: elapsed 2217
      gcd4: elapsed 2710
      PASS
      zhaoxiuzeng@zhaoxiuzeng-VirtualBox:~/develop$ ./gcd -r 500000 -n 10
      gcd0: elapsed 9589
      gcd1: elapsed 2098
      gcd2: elapsed 2815
      gcd3: elapsed 2030
      gcd4: elapsed 2718
      PASS
      zhaoxiuzeng@zhaoxiuzeng-VirtualBox:~/develop$ ./gcd -r 500000 -n 10
      gcd0: elapsed 9914
      gcd1: elapsed 2309
      gcd2: elapsed 2779
      gcd3: elapsed 2228
      gcd4: elapsed 2709
      PASS
    
    [akpm@linux-foundation.org: avoid #defining a CONFIG_ variable]
    Signed-off-by: Zhaoxiu Zeng <zhaoxiu.zeng@gmail.com>
    Signed-off-by: George Spelvin <linux@horizon.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index e6f19fc61bf2..e961c8a7ea66 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -204,6 +204,16 @@
 #endif
 #endif
 
+/* __builtin_constant_p(cpu_has_mips_r) && cpu_has_mips_r */
+#if !((defined(cpu_has_mips32r1) && cpu_has_mips32r1) || \
+	  (defined(cpu_has_mips32r2) && cpu_has_mips32r2) || \
+	  (defined(cpu_has_mips32r6) && cpu_has_mips32r6) || \
+	  (defined(cpu_has_mips64r1) && cpu_has_mips64r1) || \
+	  (defined(cpu_has_mips64r2) && cpu_has_mips64r2) || \
+	  (defined(cpu_has_mips64r6) && cpu_has_mips64r6))
+#define CPU_NO_EFFICIENT_FFS 1
+#endif
+
 #ifndef cpu_has_mips_1
 # define cpu_has_mips_1		(!cpu_has_mips_r6)
 #endif

commit 6ad816e77ed77538fe729050cf6631328c6113f7
Author: James Hogan <james.hogan@imgtec.com>
Date:   Wed May 11 15:50:30 2016 +0100

    MIPS: Add probing & defs for VZ & guest features
    
    Add a few new cpu-features.h definitions for VZ sub-features, namely the
    existence of the CP0_GuestCtl0Ext, CP0_GuestCtl1, and CP0_GuestCtl2
    registers, and support for GuestID to dialias TLB entries belonging to
    different guests.
    
    Also add certain features present in the guest, with the naming scheme
    cpu_guest_has_*. These are added separately to the main options bitfield
    since they generally parallel similar features in the root context. A
    few of these (FPU, MSA, watchpoints, perf counters, CP0_[X]ContextConfig
    registers, MAAR registers, and probably others in future) can be
    dynamically configured in the guest context, for which the
    cpu_guest_has_dyn_* macros are added.
    
    [ralf@linux-mips.org: Resolve merge conflict.]
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/13231/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 232b0377346a..e6f19fc61bf2 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -120,6 +120,21 @@
 #ifndef kernel_uses_llsc
 #define kernel_uses_llsc	cpu_has_llsc
 #endif
+#ifndef cpu_has_guestctl0ext
+#define cpu_has_guestctl0ext	(cpu_data[0].options & MIPS_CPU_GUESTCTL0EXT)
+#endif
+#ifndef cpu_has_guestctl1
+#define cpu_has_guestctl1	(cpu_data[0].options & MIPS_CPU_GUESTCTL1)
+#endif
+#ifndef cpu_has_guestctl2
+#define cpu_has_guestctl2	(cpu_data[0].options & MIPS_CPU_GUESTCTL2)
+#endif
+#ifndef cpu_has_guestid
+#define cpu_has_guestid		(cpu_data[0].options & MIPS_CPU_GUESTID)
+#endif
+#ifndef cpu_has_drg
+#define cpu_has_drg		(cpu_data[0].options & MIPS_CPU_DRG)
+#endif
 #ifndef cpu_has_mips16
 #define cpu_has_mips16		(cpu_data[0].ases & MIPS_ASE_MIPS16)
 #endif
@@ -458,4 +473,87 @@
 # define cpu_has_perf		(cpu_data[0].options & MIPS_CPU_PERF)
 #endif
 
+/*
+ * Guest capabilities
+ */
+#ifndef cpu_guest_has_conf1
+#define cpu_guest_has_conf1	(cpu_data[0].guest.conf & (1 << 1))
+#endif
+#ifndef cpu_guest_has_conf2
+#define cpu_guest_has_conf2	(cpu_data[0].guest.conf & (1 << 2))
+#endif
+#ifndef cpu_guest_has_conf3
+#define cpu_guest_has_conf3	(cpu_data[0].guest.conf & (1 << 3))
+#endif
+#ifndef cpu_guest_has_conf4
+#define cpu_guest_has_conf4	(cpu_data[0].guest.conf & (1 << 4))
+#endif
+#ifndef cpu_guest_has_conf5
+#define cpu_guest_has_conf5	(cpu_data[0].guest.conf & (1 << 5))
+#endif
+#ifndef cpu_guest_has_conf6
+#define cpu_guest_has_conf6	(cpu_data[0].guest.conf & (1 << 6))
+#endif
+#ifndef cpu_guest_has_conf7
+#define cpu_guest_has_conf7	(cpu_data[0].guest.conf & (1 << 7))
+#endif
+#ifndef cpu_guest_has_fpu
+#define cpu_guest_has_fpu	(cpu_data[0].guest.options & MIPS_CPU_FPU)
+#endif
+#ifndef cpu_guest_has_watch
+#define cpu_guest_has_watch	(cpu_data[0].guest.options & MIPS_CPU_WATCH)
+#endif
+#ifndef cpu_guest_has_contextconfig
+#define cpu_guest_has_contextconfig (cpu_data[0].guest.options & MIPS_CPU_CTXTC)
+#endif
+#ifndef cpu_guest_has_segments
+#define cpu_guest_has_segments	(cpu_data[0].guest.options & MIPS_CPU_SEGMENTS)
+#endif
+#ifndef cpu_guest_has_badinstr
+#define cpu_guest_has_badinstr	(cpu_data[0].guest.options & MIPS_CPU_BADINSTR)
+#endif
+#ifndef cpu_guest_has_badinstrp
+#define cpu_guest_has_badinstrp	(cpu_data[0].guest.options & MIPS_CPU_BADINSTRP)
+#endif
+#ifndef cpu_guest_has_htw
+#define cpu_guest_has_htw	(cpu_data[0].guest.options & MIPS_CPU_HTW)
+#endif
+#ifndef cpu_guest_has_msa
+#define cpu_guest_has_msa	(cpu_data[0].guest.ases & MIPS_ASE_MSA)
+#endif
+#ifndef cpu_guest_has_kscr
+#define cpu_guest_has_kscr(n)	(cpu_data[0].guest.kscratch_mask & (1u << (n)))
+#endif
+#ifndef cpu_guest_has_rw_llb
+#define cpu_guest_has_rw_llb	(cpu_has_mips_r6 || (cpu_data[0].guest.options & MIPS_CPU_RW_LLB))
+#endif
+#ifndef cpu_guest_has_perf
+#define cpu_guest_has_perf	(cpu_data[0].guest.options & MIPS_CPU_PERF)
+#endif
+#ifndef cpu_guest_has_maar
+#define cpu_guest_has_maar	(cpu_data[0].guest.options & MIPS_CPU_MAAR)
+#endif
+
+/*
+ * Guest dynamic capabilities
+ */
+#ifndef cpu_guest_has_dyn_fpu
+#define cpu_guest_has_dyn_fpu	(cpu_data[0].guest.options_dyn & MIPS_CPU_FPU)
+#endif
+#ifndef cpu_guest_has_dyn_watch
+#define cpu_guest_has_dyn_watch	(cpu_data[0].guest.options_dyn & MIPS_CPU_WATCH)
+#endif
+#ifndef cpu_guest_has_dyn_contextconfig
+#define cpu_guest_has_dyn_contextconfig (cpu_data[0].guest.options_dyn & MIPS_CPU_CTXTC)
+#endif
+#ifndef cpu_guest_has_dyn_perf
+#define cpu_guest_has_dyn_perf	(cpu_data[0].guest.options_dyn & MIPS_CPU_PERF)
+#endif
+#ifndef cpu_guest_has_dyn_msa
+#define cpu_guest_has_dyn_msa	(cpu_data[0].guest.ases_dyn & MIPS_ASE_MSA)
+#endif
+#ifndef cpu_guest_has_dyn_maar
+#define cpu_guest_has_dyn_maar	(cpu_data[0].guest.options_dyn & MIPS_CPU_MAAR)
+#endif
+
 #endif /* __ASM_CPU_FEATURES_H */

commit 30228c40f0c6f0a93910325f120904505a4c39cc
Author: James Hogan <james.hogan@imgtec.com>
Date:   Wed May 11 13:50:53 2016 +0100

    MIPS: Add perf counter feature
    
    Add CPU feature for standard MIPS r2 performance counters, as determined
    by the Config1.PC bit. Both perf_events and oprofile probe this bit, so
    lets combine the probing and change both to use cpu_has_perf.
    
    This will also be used for VZ support in KVM to know whether performance
    counters exist which can be exposed to guests.
    
    [ralf@linux-mips.org: resolve conflict.]
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Robert Richter <rric@kernel.org>
    Cc: linux-mips@linux-mips.org
    Cc: oprofile-list@lists.sf.net
    Patchwork: https://patchwork.linux-mips.org/patch/13226/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 7962b257cc16..232b0377346a 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -454,4 +454,8 @@
 # define cpu_has_contextconfig	(cpu_data[0].options & MIPS_CPU_CTXTC)
 #endif
 
+#ifndef cpu_has_perf
+# define cpu_has_perf		(cpu_data[0].options & MIPS_CPU_PERF)
+#endif
+
 #endif /* __ASM_CPU_FEATURES_H */

commit f18bdfa191df3947879f93519ce4a4985e5f5fce
Author: James Hogan <james.hogan@imgtec.com>
Date:   Wed May 11 13:50:52 2016 +0100

    MIPS: Add defs & probing of [X]ContextConfig
    
    The CP0_[X]ContextConfig registers are present if CP0_Config3.CTXTC or
    CP0_Config3.SM are set, and provide more control over which bits of
    CP0_[X]Context are set to the faulting virtual address on a TLB
    exception.
    
    KVM/VZ will need to be able to save and restore these registers in the
    guest context, so add the relevant definitions and probing of the
    ContextConfig feature in the root context first.
    
    [ralf@linux-mips.org: resolve merge conflict.]
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/13225/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 5d82b01ef8b5..7962b257cc16 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -450,4 +450,8 @@
 # define cpu_has_badinstrp	(cpu_data[0].options & MIPS_CPU_BADINSTRP)
 #endif
 
+#ifndef cpu_has_contextconfig
+# define cpu_has_contextconfig	(cpu_data[0].options & MIPS_CPU_CTXTC)
+#endif
+
 #endif /* __ASM_CPU_FEATURES_H */

commit e06a1548f3043febb658b58ec5ccbc7d03a785af
Author: James Hogan <james.hogan@imgtec.com>
Date:   Wed May 11 13:50:51 2016 +0100

    MIPS: Add defs & probing of BadInstr[P] registers
    
    The optional CP0_BadInstr and CP0_BadInstrP registers are written with
    the encoding of the instruction that caused a synchronous exception to
    occur, and the prior branch instruction if in a delay slot.
    
    These will be useful for instruction emulation in KVM, and especially
    for VZ support where reading guest virtual memory is a bit more awkward.
    
    Add CPU option numbers and cpu_has_* definitions to indicate the
    presence of each registers, and add code to probe for them using bits in
    the CP0_Config3 register.
    
    [ralf@linux-mips.org: resolve merge conflict.]
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/13224/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 676a37b9c37e..5d82b01ef8b5 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -442,4 +442,12 @@
 # define cpu_has_ebase_wg	(cpu_data[0].options & MIPS_CPU_EBASE_WG)
 #endif
 
+#ifndef cpu_has_badinstr
+# define cpu_has_badinstr	(cpu_data[0].options & MIPS_CPU_BADINSTR)
+#endif
+
+#ifndef cpu_has_badinstrp
+# define cpu_has_badinstrp	(cpu_data[0].options & MIPS_CPU_BADINSTRP)
+#endif
+
 #endif /* __ASM_CPU_FEATURES_H */

commit 37fb60f8e3f011c25c120081a73886ad8dbc42fd
Author: James Hogan <james.hogan@imgtec.com>
Date:   Wed May 11 13:50:50 2016 +0100

    MIPS: Add defs & probing of extended CP0_EBase
    
    The CP0_EBase register may optionally have a write gate (WG) bit to
    allow the upper bits to be written, i.e. bits 31:30 on MIPS32 since r3
    (to allow for an exception base outside of KSeg0/KSeg1 when segmentation
    control is in use) and bits 63:30 on MIPS64 (which also implies the
    extension of CP0_EBase to 64 bits long).
    
    The presence of this feature will need to be known about for VZ support
    in order to correctly save and restore all the bits of the guest
    CP0_EBase register, so add CPU feature definition and probing for this
    feature.
    
    Probing the WG bit on MIPS64 can be a bit fiddly, since 64-bit COP0
    register access instructions were UNDEFINED for 32-bit registers prior
    to MIPS r6, and it'd be nice to be able to probe without clobbering the
    existing state, so there are 3 potential paths:
    
    - If we do a 32-bit read of CP0_EBase and the WG bit is already set, the
      register must be 64-bit.
    
    - On MIPS r6 we can do a 64-bit read-modify-write to set CP0_EBase.WG,
      since the upper bits will read 0 and be ignored on write if the
      register is 32-bit.
    
    - On pre-r6 cores, we do a 32-bit read-modify-write of CP0_EBase. This
      avoids the potentially UNDEFINED behaviour, but will clobber the upper
      32-bits of CP0_EBase if it isn't a simple sign extension (which also
      requires us to ensure BEV=1 or modifying the exception base would be
      UNDEFINED too). It is hopefully unlikely a bootloader would set up
      CP0_EBase to a 64-bit segment and leave WG=0.
    
    [ralf@linux-mips.org: Resolved merge conflict.]
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Tested-by: Matt Redfearn <matt.redfearn@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/13223/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index bff73c52b273..676a37b9c37e 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -438,4 +438,8 @@
 #define cpu_has_nan_2008	(cpu_data[0].options & MIPS_CPU_NAN_2008)
 #endif
 
+#ifndef cpu_has_ebase_wg
+# define cpu_has_ebase_wg	(cpu_data[0].options & MIPS_CPU_EBASE_WG)
+#endif
+
 #endif /* __ASM_CPU_FEATURES_H */

commit 12822570a29bdc12c69fca2c021753cb5ce319c5
Author: James Hogan <james.hogan@imgtec.com>
Date:   Tue Apr 19 09:24:59 2016 +0100

    MIPS: Separate XPA CPU feature into LPA and MVH
    
    XPA (eXtended Physical Addressing) should be detected as a combination
    of two architectural features:
    - Large Physical Address (as per Config3.LPA). With XPA this will be set
      on MIPS32r5 cores, but it may also be set for MIPS64r2 cores too.
    - MTHC0/MFHC0 instructions (as per Config5.MVH). With XPA this will be
      set, but it may also be set in VZ guest context even when Config3.LPA
      in the guest context has been cleared by the hypervisor.
    
    As such, XPA is only usable if both bits are set. Update CPU features to
    separate these two features, with cpu_has_xpa requiring both to be set.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Maciej W. Rozycki <macro@imgtec.com>
    Cc: Joshua Kinard <kumba@gentoo.org>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/13112/
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index da92d513a395..bff73c52b273 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -145,8 +145,14 @@
 # endif
 #endif
 
+#ifndef cpu_has_lpa
+#define cpu_has_lpa		(cpu_data[0].options & MIPS_CPU_LPA)
+#endif
+#ifndef cpu_has_mvh
+#define cpu_has_mvh		(cpu_data[0].options & MIPS_CPU_MVH)
+#endif
 #ifndef cpu_has_xpa
-#define cpu_has_xpa		(cpu_data[0].options & MIPS_CPU_XPA)
+#define cpu_has_xpa		(cpu_has_lpa && cpu_has_mvh)
 #endif
 #ifndef cpu_has_vtag_icache
 #define cpu_has_vtag_icache	(cpu_data[0].icache.flags & MIPS_CACHE_VTAG)

commit 380cd582c08831217ae693c86411902e6300ba6b
Author: Huacai Chen <chenhc@lemote.com>
Date:   Thu Mar 3 09:45:12 2016 +0800

    MIPS: Loongson-3: Fast TLB refill handler
    
    Loongson-3A R2 has pwbase/pwfield/pwsize/pwctl registers in CP0 (this
    is very similar to HTW) and lwdir/lwpte/lddir/ldpte instructions which
    can be used for fast TLB refill.
    
    [ralf@linux-mips.org: Resolve conflict.]
    
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    Cc: Aurelien Jarno <aurelien@aurel32.net>
    Cc: Steven J . Hill <sjhill@realitydiluted.com>
    Cc: Fuxin Zhang <zhangfx@lemote.com>
    Cc: Zhangjin Wu <wuzhangjin@gmail.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/12754/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 6ff0504d090d..da92d513a395 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -35,6 +35,9 @@
 #ifndef cpu_has_htw
 #define cpu_has_htw		(cpu_data[0].options & MIPS_CPU_HTW)
 #endif
+#ifndef cpu_has_ldpte
+#define cpu_has_ldpte		(cpu_data[0].options & MIPS_CPU_LDPTE)
+#endif
 #ifndef cpu_has_rixiex
 #define cpu_has_rixiex		(cpu_data[0].options & MIPS_CPU_RIXIEX)
 #endif

commit b5a6455cde3d63466ac31bacdb42afcf30932f75
Author: Zubair Lutfullah Kakakhel <Zubair.Kakakhel@imgtec.com>
Date:   Tue Mar 29 15:50:25 2016 +0100

    MIPS: Detect DSP v3 support
    
    DSPv3 is supported on all MIPSr6 systems which indicate support for DSPv2.
    
    This doesn't require any changes to the kernel's handling of DSP
    resources. The patch is to detect support and indicate it in /proc/cpuinfo
    
    DSP v3 introduces a new instruction BPOSGE32C
    
    Signed-off-by: Zubair Lutfullah Kakakhel <Zubair.Kakakhel@imgtec.com>
    Reviewed-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/12918/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 57cdc5be9545..6ff0504d090d 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -307,6 +307,10 @@
 #define cpu_has_dsp2		(cpu_data[0].ases & MIPS_ASE_DSP2P)
 #endif
 
+#ifndef cpu_has_dsp3
+#define cpu_has_dsp3		(cpu_data[0].ases & MIPS_ASE_DSP3)
+#endif
+
 #ifndef cpu_has_mipsmt
 #define cpu_has_mipsmt		(cpu_data[0].ases & MIPS_ASE_MIPSMT)
 #endif

commit f270d881fa552c9c21c37417af2bf95da9a74347
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Wed Feb 3 03:15:21 2016 +0000

    MIPS: Detect MIPSr6 Virtual Processor support
    
    MIPSr6 introduces support for "Virtual Processors", which are
    conceptually similar to VPEs from the now-deprecated MT ASE. Detect
    whether the system supports VPs using the VP bit in Config5, adding
    cpu_has_vp for use by later patches.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: Maciej W. Rozycki <macro@imgtec.com>
    Cc: Joshua Kinard <kumba@gentoo.org>
    Cc: Steven J. Hill <sjhill@realitydiluted.com>
    Cc: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/12327/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index eeec8c8e2da2..57cdc5be9545 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -311,6 +311,10 @@
 #define cpu_has_mipsmt		(cpu_data[0].ases & MIPS_ASE_MIPSMT)
 #endif
 
+#ifndef cpu_has_vp
+#define cpu_has_vp		(cpu_data[0].options & MIPS_CPU_VP)
+#endif
+
 #ifndef cpu_has_userlocal
 #define cpu_has_userlocal	(cpu_data[0].options & MIPS_CPU_ULRI)
 #endif

commit 9519ef37a4a4e9c3c2d7d89ecbecfaf3c839208a
Author: Maciej W. Rozycki <macro@imgtec.com>
Date:   Fri Nov 13 00:46:55 2015 +0000

    MIPS: Define the legacy-NaN and 2008-NaN features
    
    Allocate CPU option bits and define macros for the legacy-NaN and
    2008-NaN IEEE Std 754 MIPS architecture features.  Unconditionally mark
    the legacy-NaN feature as present across hardware and emulated
    floating-point configurations.
    
    Signed-off-by: Maciej W. Rozycki <macro@imgtec.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Matthew Fortune <Matthew.Fortune@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/11475/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index d1e04c943f5f..eeec8c8e2da2 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -414,4 +414,11 @@
 # define cpu_has_small_pages	(cpu_data[0].options & MIPS_CPU_SP)
 #endif
 
+#ifndef cpu_has_nan_legacy
+#define cpu_has_nan_legacy	(cpu_data[0].options & MIPS_CPU_NAN_LEGACY)
+#endif
+#ifndef cpu_has_nan_2008
+#define cpu_has_nan_2008	(cpu_data[0].options & MIPS_CPU_NAN_2008)
+#endif
+
 #endif /* __ASM_CPU_FEATURES_H */

commit 033549c60969753d9c54053901b2041d91c4fbff
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Tue Sep 22 11:42:53 2015 -0700

    MIPS: Allow RIXI for 32-bit kernels on MIPS64
    
    Commit a68d09a156b2 ("MIPS: Don't use RI/XI with 32-bit kernels on
    64-bit CPUs") prevented use of RIXI on MIPS64 systems, stating that the
    "TLB handlers cannot handle this case". What they actually couldn't
    handle was cases where there were less fill bits in the Entry{Lo,Hi}
    registers than bits used by software in PTEs. The handlers can now deal
    with this case, so enable RIXI for MIPS32 kernels on MIPS64 systems.
    
    Note that beyond the obvious benefits provided by having RIXI on such
    systems, this is required for systems implementing MIPSr6 where RIXI
    cannot be disabled.
    
    This reverts commit a68d09a156b2 ("MIPS: Don't use RI/XI with 32-bit
    kernels on 64-bit CPUs").
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: Joshua Kinard <kumba@gentoo.org>
    Cc: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Cc: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: linux-kernel@vger.kernel.org
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Markos Chandras <markos.chandras@imgtec.com>
    Patchwork: https://patchwork.linux-mips.org/patch/11219/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index fe67f12ac239..d1e04c943f5f 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -131,11 +131,7 @@
 #endif
 
 #ifndef cpu_has_rixi
-# ifdef CONFIG_64BIT
-# define cpu_has_rixi		(cpu_data[0].options & MIPS_CPU_RIXI)
-# else /* CONFIG_32BIT */
-# define cpu_has_rixi		((cpu_data[0].options & MIPS_CPU_RIXI) && !cpu_has_64bits)
-# endif
+#define cpu_has_rixi		(cpu_data[0].options & MIPS_CPU_RIXI)
 #endif
 
 #ifndef cpu_has_mmips

commit 2f6f31363cb7890784458d7805140687b4de5b59
Author: James Hogan <james.hogan@imgtec.com>
Date:   Thu Sep 17 17:49:20 2015 +0100

    MIPS: cpu-features: Add cpu_has_ftlb
    
    Add cpu_has_ftlb, which specifies that an FTLB is present in addition to
    the VTLB, probed based on whether Config.MT == 4 (rather than 1 for
    standard JTLB).
    
    This is necessary since MIPS release 6 removes Config4.MMUExtDef, so the
    presence of the FTLB fields in Config4 must be determined from Config.MT
    instead.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Markos Chandras <markos.chandras@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/11159/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 9801ac982655..fe67f12ac239 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -20,6 +20,9 @@
 #ifndef cpu_has_tlb
 #define cpu_has_tlb		(cpu_data[0].options & MIPS_CPU_TLB)
 #endif
+#ifndef cpu_has_ftlb
+#define cpu_has_ftlb		(cpu_data[0].options & MIPS_CPU_FTLB)
+#endif
 #ifndef cpu_has_tlbinv
 #define cpu_has_tlbinv		(cpu_data[0].options & MIPS_CPU_TLBINV)
 #endif

commit aaa7be48fdbf14836ff1bc61c72969960a5923c6
Author: James Hogan <james.hogan@imgtec.com>
Date:   Wed Jul 15 16:17:44 2015 +0100

    MIPS: Probe for small (1KiB) page support
    
    Probe Config3 for small page support. This will be useful to give clues
    as to whether the PageGrain register exists.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/10722/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index f25de771f7ed..9801ac982655 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -411,4 +411,8 @@
 # define cpu_has_cdmm		(cpu_data[0].options & MIPS_CPU_CDMM)
 #endif
 
+#ifndef cpu_has_small_pages
+# define cpu_has_small_pages	(cpu_data[0].options & MIPS_CPU_SP)
+#endif
+
 #endif /* __ASM_CPU_FEATURES_H */

commit 8d5ded16ee7564736b82c2eae89ba0173b45f157
Author: Joshua Kinard <kumba@gentoo.org>
Date:   Tue Jun 2 18:21:33 2015 -0400

    MIPS: R12000: Enable branch prediction global history
    
    The R12000 added a new feature to enhance branch prediction called
    "global history".  Per the Vr10000 Series User Manual (U10278EJ4V0UM),
    Coprocessor 0, Diagnostic Register (22):
    
    """
    If bit 26 is set, branch prediction uses all eight bits of the global
    history register.  If bit 26 is not set, then bits 25:23 specify a count
    of the number of bits of global history to be used. Thus if bits 26:23
    are all zero, global history is disabled.
    
    The global history contains a record of the taken/not-taken status of
    recently executed branches, and when used is XOR'ed with the PC of a
    branch being predicted to produce a hashed value for indexing the BPT.
    Some programs with small "working set of conditional branches" benefit
    significantly from the use of such hashing, some see slight performance
    degradation.
    """
    
    This patch enables global history on R12000 CPUs and up by setting bit
    26 in the branch prediction diagnostic register (CP0 $22) to '1'.  Bits
    25:23 are left alone so that all eight bits of the global history
    register are available for branch prediction.
    
    Signed-off-by: Joshua Kinard <kumba@gentoo.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 5aeaf19c26b0..f25de771f7ed 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -108,6 +108,9 @@
 #ifndef cpu_has_llsc
 #define cpu_has_llsc		(cpu_data[0].options & MIPS_CPU_LLSC)
 #endif
+#ifndef cpu_has_bp_ghist
+#define cpu_has_bp_ghist	(cpu_data[0].options & MIPS_CPU_BP_GHIST)
+#endif
 #ifndef kernel_uses_llsc
 #define kernel_uses_llsc	cpu_has_llsc
 #endif

commit 3e20a26b02bd4f24945c87407df51948dd488620
Merge: 98b0429b7abd 5306a5450824
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Apr 13 16:03:32 2015 +0200

    Merge branch '4.0-fixes' into mips-for-linux-next

commit 9cdf30bd3bac697fc533988f44a117434a858f69
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Mar 25 13:14:16 2015 +0100

    MIPS: Fix cpu_has_mips_r2_exec_hazard.
    
    Returns a non-zero value if the current processor implementation requires
    an IHB instruction to deal with an instruction hazard as per MIPS R2
    architecture specification, zero otherwise.
    
    For a discussion, see http://patchwork.linux-mips.org/patch/9539/.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index a324751b02ff..49c7a29a1f9e 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -238,8 +238,39 @@
 /* MIPSR2 and MIPSR6 have a lot of similarities */
 #define cpu_has_mips_r2_r6	(cpu_has_mips_r2 | cpu_has_mips_r6)
 
+/*
+ * cpu_has_mips_r2_exec_hazard - return if IHB is required on current processor
+ *
+ * Returns non-zero value if the current processor implementation requires
+ * an IHB instruction to deal with an instruction hazard as per MIPS R2
+ * architecture specification, zero otherwise.
+ */
 #ifndef cpu_has_mips_r2_exec_hazard
-#define cpu_has_mips_r2_exec_hazard (cpu_has_mips_r2 | cpu_has_mips_r6)
+#define cpu_has_mips_r2_exec_hazard					\
+({									\
+	int __res;							\
+									\
+	switch (current_cpu_type()) {					\
+	case CPU_M14KC:							\
+	case CPU_74K:							\
+	case CPU_1074K:							\
+	case CPU_PROAPTIV:						\
+	case CPU_P5600:							\
+	case CPU_M5150:							\
+	case CPU_QEMU_GENERIC:						\
+	case CPU_CAVIUM_OCTEON:						\
+	case CPU_CAVIUM_OCTEON_PLUS:					\
+	case CPU_CAVIUM_OCTEON2:					\
+	case CPU_CAVIUM_OCTEON3:					\
+		__res = 0;						\
+		break;							\
+									\
+	default:							\
+		__res = 1;						\
+	}								\
+									\
+	__res;								\
+})
 #endif
 
 /*

commit 2d83fea786d7aeb5b3b76bd492d9b3bccc0f823c
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Fri Apr 3 23:26:49 2015 +0100

    MIPS: Correct FP ISA requirements
    
    Correct ISA requirements for floating-point instructions:
    
    * the CU3 exception signifies a real COP3 instruction in MIPS I & II,
    
    * the BC1FL and BC1TL instructions are not supported in MIPS I,
    
    * the SQRT.fmt instructions are indeed supported in MIPS II,
    
    * the LDC1 and SDC1 instructions are indeed supported in MIPS32r1,
    
    * the CEIL.W.fmt, FLOOR.W.fmt, ROUND.W.fmt and TRUNC.W.fmt instructions
      are indeed supported in MIPS32,
    
    * the CVT.L.fmt and CVT.fmt.L instructions are indeed supported in
      MIPS32r2 and MIPS32r6,
    
    * the CEIL.L.fmt, FLOOR.L.fmt, ROUND.L.fmt and TRUNC.L.fmt instructions
      are indeed supported in MIPS32r2 and MIPS32r6,
    
    * the RSQRT.fmt and RECIP.fmt instructions are indeed supported in
      MIPS64r1,
    
    Also simplify conditionals for MIPS III and MIPS IV FPU instructions and
    the handling of the MOVCI minor opcode.
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/9700/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 62a4730de86a..fc2ad332541c 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -221,8 +221,11 @@
 #define cpu_has_mips_4_5_r	(cpu_has_mips_4 | cpu_has_mips_5_r)
 #define cpu_has_mips_5_r	(cpu_has_mips_5 | cpu_has_mips_r)
 
-#define cpu_has_mips_4_5_r2_r6	(cpu_has_mips_4_5 | cpu_has_mips_r2 | \
-				 cpu_has_mips_r6)
+#define cpu_has_mips_3_4_5_64_r2_r6					\
+				(cpu_has_mips_3 | cpu_has_mips_4_5_64_r2_r6)
+#define cpu_has_mips_4_5_64_r2_r6					\
+				(cpu_has_mips_4_5 | cpu_has_mips64r1 |	\
+				 cpu_has_mips_r2 | cpu_has_mips_r6)
 
 #define cpu_has_mips32	(cpu_has_mips32r1 | cpu_has_mips32r2 | cpu_has_mips32r6)
 #define cpu_has_mips64	(cpu_has_mips64r1 | cpu_has_mips64r2 | cpu_has_mips64r6)

commit 18a2c2c6b9319503eeac8a38b62fc82c9ff81b0d
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Fri Apr 3 23:26:04 2015 +0100

    MIPS: Correct `nofpu' non-functionality
    
    The `cpu_has_fpu' feature flag must not be hardcoded to 1 or the `nofpu'
    kernel option will be ignored.  Remove any such overrides and add a
    cautionary note.  Hardcoding to 0 is fine for FPU-less platforms.
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/9694/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index ea68a38bb61d..62a4730de86a 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -68,6 +68,7 @@
 #ifndef cpu_has_octeon_cache
 #define cpu_has_octeon_cache	0
 #endif
+/* Don't override `cpu_has_fpu' to 1 or the "nofpu" option won't work.  */
 #ifndef cpu_has_fpu
 #define cpu_has_fpu		(current_cpu_data.options & MIPS_CPU_FPU)
 #define raw_cpu_has_fpu		(raw_current_cpu_data.options & MIPS_CPU_FPU)

commit 9b3274bd585c6dff7848119e837bd5ce6c9173e2
Author: James Hogan <james.hogan@imgtec.com>
Date:   Mon Feb 2 11:45:08 2015 +0000

    MIPS: Add arch CDMM definitions and probing
    
    Add architectural definitions and probing for the MIPS Common Device
    Memory Map (CDMM) region. When supported and enabled at a particular
    physical address, this region allows some number of per-CPU devices to
    be discovered and controlled via MMIO.
    
    A bit exists in Config3 to determine whether the feature is present, and
    a CDMMBase CP0 register allows the region to be enabled at a particular
    physical address.
    
    [ralf@linux-mips.org: Sort conflict with other patches.]
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/9178/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 0d8208de9a3f..ea68a38bb61d 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -366,4 +366,8 @@
 # define cpu_has_fre		(cpu_data[0].options & MIPS_CPU_FRE)
 #endif
 
+#ifndef cpu_has_cdmm
+# define cpu_has_cdmm		(cpu_data[0].options & MIPS_CPU_CDMM)
+#endif
+
 #endif /* __ASM_CPU_FEATURES_H */

commit c5b367835cfc7a8ef53b9670a409ffcc95194344
Author: Steven J. Hill <Steven.Hill@imgtec.com>
Date:   Thu Feb 26 18:16:38 2015 -0600

    MIPS: Add support for XPA.
    
    Add support for extended physical addressing (XPA) so that
    32-bit platforms can access equal to or greater than 40 bits
    of physical addresses.
    
    NOTE:
          1) XPA and EVA are not the same and cannot be used
             simultaneously.
          2) If you configure your kernel for XPA, the PTEs
             and all address sizes become 64-bit.
          3) Your platform MUST have working HIGHMEM support.
    
    Signed-off-by: Steven J. Hill <Steven.Hill@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/9355/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 0d8208de9a3f..a324751b02ff 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -139,6 +139,9 @@
 # endif
 #endif
 
+#ifndef cpu_has_xpa
+#define cpu_has_xpa		(cpu_data[0].options & MIPS_CPU_XPA)
+#endif
 #ifndef cpu_has_vtag_icache
 #define cpu_has_vtag_icache	(cpu_data[0].icache.flags & MIPS_CACHE_VTAG)
 #endif

commit e0d32f33e651a393a23826c06a9301917372f3e2
Author: Markos Chandras <markos.chandras@imgtec.com>
Date:   Thu Jan 15 10:11:17 2015 +0000

    MIPS: Handle MIPS IV, V and R2 FPU instructions on MIPS R6 as well
    
    MIPS R2 FPU instructions are also present in MIPS R6 so amend the
    preprocessor definitions to take MIPS R6 into consideration.
    
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index e686131ff995..0d8208de9a3f 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -220,7 +220,8 @@
 #define cpu_has_mips_4_5_r	(cpu_has_mips_4 | cpu_has_mips_5_r)
 #define cpu_has_mips_5_r	(cpu_has_mips_5 | cpu_has_mips_r)
 
-#define cpu_has_mips_4_5_r2	(cpu_has_mips_4_5 | cpu_has_mips_r2)
+#define cpu_has_mips_4_5_r2_r6	(cpu_has_mips_4_5 | cpu_has_mips_r2 | \
+				 cpu_has_mips_r6)
 
 #define cpu_has_mips32	(cpu_has_mips32r1 | cpu_has_mips32r2 | cpu_has_mips32r6)
 #define cpu_has_mips64	(cpu_has_mips64r1 | cpu_has_mips64r2 | cpu_has_mips64r6)

commit 5aed9da128be27275b0892fb413f3a0af64e00a6
Author: Markos Chandras <markos.chandras@imgtec.com>
Date:   Tue Dec 2 09:46:19 2014 +0000

    MIPS: Add LLB bit and related feature for the Config 5 CP0 register
    
    The LLBIT (bit 4) in the Config5 CP0 register indicates the software
    availability of the Load-Linked bit. This bit is only set by hardware
    and it has the following meaning:
    
    0: LLB functionality is not supported
    1: LLB functionality is supported. The following feature are also
    supported:
    
    - ERETNC instruction. Similar to ERET but it does not clear the LLB
    bit in the LLAddr register.
    - CP0 LLAddr/LLB bit must be set
    - LLbit is software accessible through the LLAddr[0]
    
    This will be used later on to emulate R2 LL/SC instructions.
    
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 08d1bbe905eb..e686131ff995 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -38,6 +38,9 @@
 #ifndef cpu_has_maar
 #define cpu_has_maar		(cpu_data[0].options & MIPS_CPU_MAAR)
 #endif
+#ifndef cpu_has_rw_llb
+#define cpu_has_rw_llb		(cpu_data[0].options & MIPS_CPU_RW_LLB)
+#endif
 
 /*
  * For the moment we don't consider R6000 and R8000 so we can assume that

commit 515a6393dbac4f4492237c7b305bbf9c4c558a1c
Author: Markos Chandras <markos.chandras@imgtec.com>
Date:   Fri Nov 14 10:10:02 2014 +0000

    MIPS: kernel: proc: Add MIPS R6 support to /proc/cpuinfo
    
    Print 'mips64r6' and/or 'mips32r6' if the kernel is running on
    a MIPS R6 core.
    
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 799dc6db7847..08d1bbe905eb 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -171,6 +171,9 @@
 #endif
 #endif
 
+#ifndef cpu_has_mips_1
+# define cpu_has_mips_1		(!cpu_has_mips_r6)
+#endif
 #ifndef cpu_has_mips_2
 # define cpu_has_mips_2		(cpu_data[0].isa_level & MIPS_CPU_ISA_II)
 #endif

commit 34c56fc1c167facc375d927687df0a3891d164ac
Author: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
Date:   Thu Nov 13 11:49:21 2014 +0000

    MIPS: asm: cpu: Add MIPSR6 ISA definitions
    
    Add MIPS R6 to the ISA definitions
    
    Signed-off-by: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 2897cfafcaf0..799dc6db7847 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -189,12 +189,18 @@
 #ifndef cpu_has_mips32r2
 # define cpu_has_mips32r2	(cpu_data[0].isa_level & MIPS_CPU_ISA_M32R2)
 #endif
+#ifndef cpu_has_mips32r6
+# define cpu_has_mips32r6	(cpu_data[0].isa_level & MIPS_CPU_ISA_M32R6)
+#endif
 #ifndef cpu_has_mips64r1
 # define cpu_has_mips64r1	(cpu_data[0].isa_level & MIPS_CPU_ISA_M64R1)
 #endif
 #ifndef cpu_has_mips64r2
 # define cpu_has_mips64r2	(cpu_data[0].isa_level & MIPS_CPU_ISA_M64R2)
 #endif
+#ifndef cpu_has_mips64r6
+# define cpu_has_mips64r6	(cpu_data[0].isa_level & MIPS_CPU_ISA_M64R6)
+#endif
 
 /*
  * Shortcuts ...
@@ -210,15 +216,20 @@
 
 #define cpu_has_mips_4_5_r2	(cpu_has_mips_4_5 | cpu_has_mips_r2)
 
-#define cpu_has_mips32	(cpu_has_mips32r1 | cpu_has_mips32r2)
-#define cpu_has_mips64	(cpu_has_mips64r1 | cpu_has_mips64r2)
+#define cpu_has_mips32	(cpu_has_mips32r1 | cpu_has_mips32r2 | cpu_has_mips32r6)
+#define cpu_has_mips64	(cpu_has_mips64r1 | cpu_has_mips64r2 | cpu_has_mips64r6)
 #define cpu_has_mips_r1 (cpu_has_mips32r1 | cpu_has_mips64r1)
 #define cpu_has_mips_r2 (cpu_has_mips32r2 | cpu_has_mips64r2)
+#define cpu_has_mips_r6	(cpu_has_mips32r6 | cpu_has_mips64r6)
 #define cpu_has_mips_r	(cpu_has_mips32r1 | cpu_has_mips32r2 | \
-			 cpu_has_mips64r1 | cpu_has_mips64r2)
+			 cpu_has_mips32r6 | cpu_has_mips64r1 | \
+			 cpu_has_mips64r2 | cpu_has_mips64r6)
+
+/* MIPSR2 and MIPSR6 have a lot of similarities */
+#define cpu_has_mips_r2_r6	(cpu_has_mips_r2 | cpu_has_mips_r6)
 
 #ifndef cpu_has_mips_r2_exec_hazard
-#define cpu_has_mips_r2_exec_hazard cpu_has_mips_r2
+#define cpu_has_mips_r2_exec_hazard (cpu_has_mips_r2 | cpu_has_mips_r6)
 #endif
 
 /*

commit adac5d535d4e364324b92798bfb68336197e815e
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Thu Sep 11 08:30:18 2014 +0100

    MIPS: detect presence of the FRE & UFR bits
    
    Detect the presence of the Config5 FRE & UFE bits, as indicated by the
    FREP bit in FPIR. Record this as a CPU option bit, and provide a
    cpu_has_fre macro to ease checking of that option bit.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: linux-fsdevel@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/7678/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 3325f3eb248c..2897cfafcaf0 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -344,4 +344,8 @@
 # define cpu_has_msa		0
 #endif
 
+#ifndef cpu_has_fre
+# define cpu_has_fre		(cpu_data[0].options & MIPS_CPU_FRE)
+#endif
+
 #endif /* __ASM_CPU_FEATURES_H */

commit 3c09bae43ba92a07a6a7b7d42360deb32d289cc0
Author: Chen Jie <chenj@lemote.com>
Date:   Fri Aug 15 16:56:58 2014 +0800

    MIPS: Use WSBH/DSBH/DSHD on Loongson 3A
    
    Signed-off-by: chenj <chenj@lemote.com>
    Cc: linux-mips@linux-mips.org
    Cc: chenhc@lemote.com
    Patchwork: https://patchwork.linux-mips.org/patch/7542/
    Patchwork: https://patchwork.linux-mips.org/patch/7550/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index e079598ae051..3325f3eb248c 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -231,6 +231,16 @@
 #define cpu_has_clo_clz	cpu_has_mips_r
 #endif
 
+/*
+ * MIPS32 R2, MIPS64 R2, Loongson 3A and Octeon have WSBH.
+ * MIPS64 R2, Loongson 3A and Octeon have WSBH, DSBH and DSHD.
+ * This indicates the availability of WSBH and in case of 64 bit CPUs also
+ * DSBH and DSHD.
+ */
+#ifndef cpu_has_wsbh
+#define cpu_has_wsbh		cpu_has_mips_r2
+#endif
+
 #ifndef cpu_has_dsp
 #define cpu_has_dsp		(cpu_data[0].ases & MIPS_ASE_DSP)
 #endif

commit 1f6c52ff7225789d20c1d69883f263d502b7eda7
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Mon Jul 14 10:32:14 2014 +0100

    MIPS: detect presence of MAARs
    
    Detect the presence of MAAR using the MRP bit in Config5, and record
    that presence using a CPU option bit. A cpu_has_maar macro will then
    allow code to conditionalise upon the presence of MAARs.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/7330/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index eeb5400ed4ee..e079598ae051 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -35,6 +35,9 @@
 #ifndef cpu_has_rixiex
 #define cpu_has_rixiex		(cpu_data[0].options & MIPS_CPU_RIXIEX)
 #endif
+#ifndef cpu_has_maar
+#define cpu_has_maar		(cpu_data[0].options & MIPS_CPU_MAAR)
+#endif
 
 /*
  * For the moment we don't consider R6000 and R8000 so we can assume that

commit 6ee729aa6c06c9bc2bc1dd27e809e8fe976a9e04
Author: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
Date:   Tue Jul 15 14:09:55 2014 +0100

    MIPS: Add new option for unique RI/XI exceptions
    
    MIPSr5 added support for unique exception codes for the Read-Inhibit
    and Execute-Inhibit exceptions.
    
    Signed-off-by: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/7338/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 3b9768e92e9e..eeb5400ed4ee 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -32,6 +32,9 @@
 #ifndef cpu_has_htw
 #define cpu_has_htw		(cpu_data[0].options & MIPS_CPU_HTW)
 #endif
+#ifndef cpu_has_rixiex
+#define cpu_has_rixiex		(cpu_data[0].options & MIPS_CPU_RIXIEX)
+#endif
 
 /*
  * For the moment we don't consider R6000 and R8000 so we can assume that

commit e647e6b5b355bbf58d5c20c181e69474e5aee5fe
Author: Markos Chandras <markos.chandras@imgtec.com>
Date:   Mon Jul 14 12:43:28 2014 +0100

    MIPS: cpu: Add new cpu option for Hardware Table Walker.
    
    Moreover, report hardware page table walker support as 'htw' in the ASE
    list of /proc/cpuinfo, if the core implements this feature.
    
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/7334/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index c7d8c997d93e..3b9768e92e9e 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -29,6 +29,9 @@
 #ifndef cpu_has_eva
 #define cpu_has_eva		(cpu_data[0].options & MIPS_CPU_EVA)
 #endif
+#ifndef cpu_has_htw
+#define cpu_has_htw		(cpu_data[0].options & MIPS_CPU_HTW)
+#endif
 
 /*
  * For the moment we don't consider R6000 and R8000 so we can assume that

commit a68d09a156b2a543117bb98df4c8c4cd1b857124
Author: David Daney <david.daney@cavium.com>
Date:   Wed May 28 23:52:07 2014 +0200

    MIPS: Don't use RI/XI with 32-bit kernels on 64-bit CPUs
    
    The TLB handlers cannot handle this case, so disable it for now.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Signed-off-by: Andreas Herrmann <andreas.herrmann@caviumnetworks.com>
    Cc: linux-mips@linux-mips.org
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: kvm@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/7007/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index f75dd7055508..c7d8c997d93e 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -110,9 +110,15 @@
 #ifndef cpu_has_smartmips
 #define cpu_has_smartmips	(cpu_data[0].ases & MIPS_ASE_SMARTMIPS)
 #endif
+
 #ifndef cpu_has_rixi
-#define cpu_has_rixi		(cpu_data[0].options & MIPS_CPU_RIXI)
+# ifdef CONFIG_64BIT
+# define cpu_has_rixi		(cpu_data[0].options & MIPS_CPU_RIXI)
+# else /* CONFIG_32BIT */
+# define cpu_has_rixi		((cpu_data[0].options & MIPS_CPU_RIXI) && !cpu_has_64bits)
+# endif
 #endif
+
 #ifndef cpu_has_mmips
 # ifdef CONFIG_SYS_SUPPORTS_MICROMIPS
 #  define cpu_has_mmips		(cpu_data[0].options & MIPS_CPU_MICROMIPS)
@@ -120,6 +126,7 @@
 #  define cpu_has_mmips		0
 # endif
 #endif
+
 #ifndef cpu_has_vtag_icache
 #define cpu_has_vtag_icache	(cpu_data[0].icache.flags & MIPS_CACHE_VTAG)
 #endif

commit 08a07904e182895e1205f399465a3d622c0115b8
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Apr 19 13:11:37 2014 +0200

    MIPS: math-emu: Remove most ifdefery.
    
    Most of these tests should be runtime tests.  This also finally means
    that on a MIPS III systems MIPS IV opcodes are going to result in an
    exception as they're supposed to.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index f56cc975b92f..f75dd7055508 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -183,6 +183,17 @@
 /*
  * Shortcuts ...
  */
+#define cpu_has_mips_2_3_4_5	(cpu_has_mips_2 | cpu_has_mips_3_4_5)
+#define cpu_has_mips_3_4_5	(cpu_has_mips_3 | cpu_has_mips_4_5)
+#define cpu_has_mips_4_5	(cpu_has_mips_4 | cpu_has_mips_5)
+
+#define cpu_has_mips_2_3_4_5_r	(cpu_has_mips_2 | cpu_has_mips_3_4_5_r)
+#define cpu_has_mips_3_4_5_r	(cpu_has_mips_3 | cpu_has_mips_4_5_r)
+#define cpu_has_mips_4_5_r	(cpu_has_mips_4 | cpu_has_mips_5_r)
+#define cpu_has_mips_5_r	(cpu_has_mips_5 | cpu_has_mips_r)
+
+#define cpu_has_mips_4_5_r2	(cpu_has_mips_4_5 | cpu_has_mips_r2)
+
 #define cpu_has_mips32	(cpu_has_mips32r1 | cpu_has_mips32r2)
 #define cpu_has_mips64	(cpu_has_mips64r1 | cpu_has_mips64r2)
 #define cpu_has_mips_r1 (cpu_has_mips32r1 | cpu_has_mips64r1)

commit 7ae669665698b72d81e2080ebb220dfad49248dc
Author: Markos Chandras <markos.chandras@imgtec.com>
Date:   Thu Jan 9 16:01:29 2014 +0000

    MIPS: asm: cpu: Add cpu flag for Enhanced Virtual Addressing
    
    The MIPS *Aptiv family uses bit 28 in Config5 CP0 register to
    indicate whether the core supports EVA or not.
    
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 390795dfa2e9..f56cc975b92f 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -26,7 +26,9 @@
 #ifndef cpu_has_segments
 #define cpu_has_segments	(cpu_data[0].options & MIPS_CPU_SEGMENTS)
 #endif
-
+#ifndef cpu_has_eva
+#define cpu_has_eva		(cpu_data[0].options & MIPS_CPU_EVA)
+#endif
 
 /*
  * For the moment we don't consider R6000 and R8000 so we can assume that

commit a5e9a69e2cb64c15246291fdc0e27134b9cdce37
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Mon Jan 27 15:23:10 2014 +0000

    MIPS: Detect the MSA ASE
    
    This patch adds support for probing the MSAP bit within the Config3
    register in order to detect the presence of the MSA ASE. Presence of the
    ASE will be indicated in /proc/cpuinfo. The value of the MSA
    implementation register will be displayed at boot to aid debugging and
    verification of a correct setup, as is done for the FPU.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/6430/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 6e70b03b6aab..390795dfa2e9 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -299,4 +299,10 @@
 #define cpu_has_vz		(cpu_data[0].ases & MIPS_ASE_VZ)
 #endif
 
+#if defined(CONFIG_CPU_HAS_MSA) && !defined(cpu_has_msa)
+# define cpu_has_msa		(cpu_data[0].ases & MIPS_ASE_MSA)
+#elif !defined(cpu_has_msa)
+# define cpu_has_msa		0
+#endif
+
 #endif /* __ASM_CPU_FEATURES_H */

commit 4a0156fbfb78b8006ce9b2ffac9383b7d4a8192b
Author: Steven J. Hill <Steven.Hill@imgtec.com>
Date:   Thu Nov 14 16:12:24 2013 +0000

    MIPS: features: Add initial support for Segmentation Control registers
    
    MIPS32R3 introduced a new set of Segmentation Control registers which
    increase the flexibility of the segmented-based memory scheme.
    
    Signed-off-by: Steven J. Hill <Steven.Hill@imgtec.com>
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/6131/

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 296606b19186..6e70b03b6aab 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -23,6 +23,10 @@
 #ifndef cpu_has_tlbinv
 #define cpu_has_tlbinv		(cpu_data[0].options & MIPS_CPU_TLBINV)
 #endif
+#ifndef cpu_has_segments
+#define cpu_has_segments	(cpu_data[0].options & MIPS_CPU_SEGMENTS)
+#endif
+
 
 /*
  * For the moment we don't consider R6000 and R8000 so we can assume that

commit 1745c1ef88c095a99c95d13b275774d18774465d
Author: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
Date:   Thu Nov 14 16:12:23 2013 +0000

    MIPS: features: Add initial support for TLBINVF capable cores
    
    New Aptiv cores support the TLBINVF instruction for flushing
    the VTLB.
    
    Signed-off-by: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/6130/

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index d445d060e346..296606b19186 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -20,6 +20,9 @@
 #ifndef cpu_has_tlb
 #define cpu_has_tlb		(cpu_data[0].options & MIPS_CPU_TLB)
 #endif
+#ifndef cpu_has_tlbinv
+#define cpu_has_tlbinv		(cpu_data[0].options & MIPS_CPU_TLBINV)
+#endif
 
 /*
  * For the moment we don't consider R6000 and R8000 so we can assume that

commit becee6b8c7b2b4adc9a3e0bec633abecd591b9ef
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Sun Sep 22 22:04:27 2013 +0100

    MIPS: cpu-features.h: s/MIPS53/MIPS64/
    
    No support for MIPS53 processors yet.
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/5876/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 51680d15ca8e..d445d060e346 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -187,7 +187,7 @@
 
 /*
  * MIPS32, MIPS64, VR5500, IDT32332, IDT32334 and maybe a few other
- * pre-MIPS32/MIPS53 processors have CLO, CLZ.	The IDT RC64574 is 64-bit and
+ * pre-MIPS32/MIPS64 processors have CLO, CLZ.	The IDT RC64574 is 64-bit and
  * has CLO and CLZ but not DCLO nor DCLZ.  For 64-bit kernels
  * cpu_has_clo_clz also indicates the availability of DCLO and DCLZ.
  */

commit 69f24d1784b631b81a54eb57c49bf46536dd2382
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Sep 17 10:25:47 2013 +0200

    MIPS: Optimize current_cpu_type() for better code.
    
     o Move current_cpu_type() to a separate header file
     o #ifdefing on supported CPU types lets modern GCC know that certain
       code in callers may be discarded ideally turning current_cpu_type() into
       a function returning a constant.
     o Use current_cpu_type() rather than direct access to struct cpuinfo_mips.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Cc: Steven J. Hill <Steven.Hill@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/5833/

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index fa44f3ec5302..51680d15ca8e 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -13,12 +13,6 @@
 #include <asm/cpu-info.h>
 #include <cpu-feature-overrides.h>
 
-#ifndef current_cpu_type
-#define current_cpu_type()	current_cpu_data.cputype
-#endif
-
-#define boot_cpu_type()		cpu_data[0].cputype
-
 /*
  * SMP assumption: Options of CPU 0 are a superset of all processors.
  * This is true for all known MIPS systems.

commit cf5b2d23a75cbb53785d270e76e4911e84797b72
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Aug 1 18:31:05 2013 +0200

    MIPS: oprofile: Fix BUG due to smp_processor_id() in preemptible code.
    
    current_cpu_type() is not preemption-safe.
    If CONFIG_PREEMPT is enabled then mipsxx_reg_setup() can be called from preemptible state.
    Added get_cpu()/put_cpu() pair to make it preemption-safe.
    
    This was found while testing oprofile with CONFIG_DEBUG_PREEMPT enable.
    
    /usr/zntestsuite # opcontrol --init
    /usr/zntestsuite # opcontrol --setup --event=L2_CACHE_ACCESSES:500 --event=L2_CACHE_MISSES:500 --no-vmlinux
    /usr/zntestsuite # opcontrol --start
    Using 2.6+ OProfile kernel interface.
    BUG: using smp_processor_id() in preemptible [00000000] code: oprofiled/1362
    caller is mipsxx_reg_setup+0x11c/0x164
    CPU: 0 PID: 1362 Comm: oprofiled Not tainted 3.10.4 #18
    Stack : 00000006 70757465 00000000 00000000 00000000 00000000 80b173f6 00000037
              80b10000 00000000 80b21614 88f5a220 00000000 00000000 00000000 00000000
              00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
              00000000 00000000 00000000 89c49c00 89c49c2c 80721254 807b7927 8012c1d0
              80b10000 80721254 00000000 00000552 88f5a220 80b1335c 807b78e6 89c49ba8
              ...
    Call Trace:
    [<801099a4>] show_stack+0x64/0x7c
    [<80665520>] dump_stack+0x20/0x2c
    [<803a2250>] debug_smp_processor_id+0xe0/0xf0
    [<8052df24>] mipsxx_reg_setup+0x11c/0x164
    [<8052cd70>] op_mips_setup+0x24/0x4c
    [<80529cfc>] oprofile_setup+0x5c/0x12c
    [<8052b9f8>] event_buffer_open+0x78/0xf8
    [<801c3150>] do_dentry_open.isra.15+0x2b8/0x3b0
    [<801c3270>] finish_open+0x28/0x4c
    [<801d49b8>] do_last.isra.41+0x2cc/0xd00
    [<801d54a0>] path_openat+0xb4/0x4c4
    [<801d5c44>] do_filp_open+0x3c/0xac
    [<801c4744>] do_sys_open+0x110/0x1f4
    [<8010f47c>] stack_done+0x20/0x44
    
    Bug reported and original patch by Jerin Jacob <jerinjacobk@gmail.com>.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: Jerin Jacob <jerinjacobk@gmail.com>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 1dc086087a72..fa44f3ec5302 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -17,6 +17,8 @@
 #define current_cpu_type()	current_cpu_data.cputype
 #endif
 
+#define boot_cpu_type()		cpu_data[0].cputype
+
 /*
  * SMP assumption: Options of CPU 0 are a superset of all processors.
  * This is true for all known MIPS systems.

commit fc192e50f868d8f34b15a18c38407f4b9468a31d
Author: Tony Wu <tung7970@gmail.com>
Date:   Fri Jun 21 10:10:46 2013 +0000

    MIPS: Cleanup indentation and whitespace
    
    Signed-off-by: Tony Wu <tung7970@gmail.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/5536/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 8e0c125c59a1..1dc086087a72 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -97,13 +97,13 @@
 #define cpu_has_mips16		(cpu_data[0].ases & MIPS_ASE_MIPS16)
 #endif
 #ifndef cpu_has_mdmx
-#define cpu_has_mdmx	       (cpu_data[0].ases & MIPS_ASE_MDMX)
+#define cpu_has_mdmx		(cpu_data[0].ases & MIPS_ASE_MDMX)
 #endif
 #ifndef cpu_has_mips3d
-#define cpu_has_mips3d	       (cpu_data[0].ases & MIPS_ASE_MIPS3D)
+#define cpu_has_mips3d		(cpu_data[0].ases & MIPS_ASE_MIPS3D)
 #endif
 #ifndef cpu_has_smartmips
-#define cpu_has_smartmips      (cpu_data[0].ases & MIPS_ASE_SMARTMIPS)
+#define cpu_has_smartmips	(cpu_data[0].ases & MIPS_ASE_SMARTMIPS)
 #endif
 #ifndef cpu_has_rixi
 #define cpu_has_rixi		(cpu_data[0].options & MIPS_CPU_RIXI)
@@ -125,7 +125,7 @@
 #define cpu_has_ic_fills_f_dc	(cpu_data[0].icache.flags & MIPS_CACHE_IC_F_DC)
 #endif
 #ifndef cpu_has_pindexed_dcache
-#define cpu_has_pindexed_dcache (cpu_data[0].dcache.flags & MIPS_CACHE_PINDEX)
+#define cpu_has_pindexed_dcache	(cpu_data[0].dcache.flags & MIPS_CACHE_PINDEX)
 #endif
 #ifndef cpu_has_local_ebase
 #define cpu_has_local_ebase	1
@@ -162,18 +162,18 @@
 #ifndef cpu_has_mips_5
 # define cpu_has_mips_5		(cpu_data[0].isa_level & MIPS_CPU_ISA_V)
 #endif
-# ifndef cpu_has_mips32r1
+#ifndef cpu_has_mips32r1
 # define cpu_has_mips32r1	(cpu_data[0].isa_level & MIPS_CPU_ISA_M32R1)
-# endif
-# ifndef cpu_has_mips32r2
+#endif
+#ifndef cpu_has_mips32r2
 # define cpu_has_mips32r2	(cpu_data[0].isa_level & MIPS_CPU_ISA_M32R2)
-# endif
-# ifndef cpu_has_mips64r1
+#endif
+#ifndef cpu_has_mips64r1
 # define cpu_has_mips64r1	(cpu_data[0].isa_level & MIPS_CPU_ISA_M64R1)
-# endif
-# ifndef cpu_has_mips64r2
+#endif
+#ifndef cpu_has_mips64r2
 # define cpu_has_mips64r2	(cpu_data[0].isa_level & MIPS_CPU_ISA_M64R2)
-# endif
+#endif
 
 /*
  * Shortcuts ...
@@ -195,9 +195,9 @@
  * has CLO and CLZ but not DCLO nor DCLZ.  For 64-bit kernels
  * cpu_has_clo_clz also indicates the availability of DCLO and DCLZ.
  */
-# ifndef cpu_has_clo_clz
-# define cpu_has_clo_clz	cpu_has_mips_r
-# endif
+#ifndef cpu_has_clo_clz
+#define cpu_has_clo_clz	cpu_has_mips_r
+#endif
 
 #ifndef cpu_has_dsp
 #define cpu_has_dsp		(cpu_data[0].ases & MIPS_ASE_DSP)
@@ -223,7 +223,7 @@
 # define cpu_has_64bits		(cpu_data[0].isa_level & MIPS_CPU_ISA_64BIT)
 # endif
 # ifndef cpu_has_64bit_zero_reg
-# define cpu_has_64bit_zero_reg (cpu_data[0].isa_level & MIPS_CPU_ISA_64BIT)
+# define cpu_has_64bit_zero_reg	(cpu_data[0].isa_level & MIPS_CPU_ISA_64BIT)
 # endif
 # ifndef cpu_has_64bit_gp_regs
 # define cpu_has_64bit_gp_regs		0

commit 3ddc14add5e6341cf8ef4058c34c67ba7fd15317
Author: David Daney <david.daney@cavium.com>
Date:   Fri May 24 20:54:10 2013 +0000

    MIPS: Only set cpu_has_mmips if SYS_SUPPORTS_MICROMIPS
    
    As Jonas Gorske said in his patch:
    
       Disable cpu_has_mmips for everything but SEAD3 and MALTA. Most of
       these platforms are from before the micromips introduction, so they
       are very unlikely to implement it.
    
       Reduces an -Os compiled, uncompressed kernel image by 8KiB for
       BCM63XX.
    
    This patch taks a different approach than his, we gate the runtime
    test for microMIPS by the config symbol SYS_SUPPORTS_MICROMIPS.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Cc: Jonas Gorski <jogo@openwrt.org>
    Cc: Steven J. Hill <Steven.Hill@imgtec.com>
    Acked-by: Steven J. Hill <Steven.Hill@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/5327/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 9609812bc8f2..8e0c125c59a1 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -109,7 +109,11 @@
 #define cpu_has_rixi		(cpu_data[0].options & MIPS_CPU_RIXI)
 #endif
 #ifndef cpu_has_mmips
-#define cpu_has_mmips		(cpu_data[0].options & MIPS_CPU_MICROMIPS)
+# ifdef CONFIG_SYS_SUPPORTS_MICROMIPS
+#  define cpu_has_mmips		(cpu_data[0].options & MIPS_CPU_MICROMIPS)
+# else
+#  define cpu_has_mmips		0
+# endif
 #endif
 #ifndef cpu_has_vtag_icache
 #define cpu_has_vtag_icache	(cpu_data[0].icache.flags & MIPS_CACHE_VTAG)

commit 1990e5429c2149a30a81ff634215c1aa76560a89
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Jun 26 17:06:34 2013 +0200

    MIPS: Get rid of MIPS I flag and test macros.
    
    MIPS I is the ancestor of all MIPS ISA and architecture variants.  Anything
    ever build in the MIPS empire is either MIPS I or at least contains MIPS I.
    If it's running Linux, that is.
    
    So there is little point in having cpu_has_mips_1 because it will always
    evaluate as true - though usually only at runtime.  Thus there is no
    point in having the MIPS_CPU_ISA_I ISA flag, so get rid of it.
    
    Little complication: traps.c was using a test for a pure MIPS I ISA as
    a test for an R3000-style cp0.  To deal with that, use a check for
    cpu_has_3kex or cpu_has_4kex instead.
    
    cpu_has_3kex is a new macro.  At the moment its default implementation is
    !cpu_has_4kex but this may eventually change if Linux is ever going to
    support the oddball MIPS processors R6000 and R8000 so users of either
    of these macros should not make any assumptions.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/5551/

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index e5ec8fcd8afa..9609812bc8f2 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -24,6 +24,16 @@
 #ifndef cpu_has_tlb
 #define cpu_has_tlb		(cpu_data[0].options & MIPS_CPU_TLB)
 #endif
+
+/*
+ * For the moment we don't consider R6000 and R8000 so we can assume that
+ * anything that doesn't support R4000-style exceptions and interrupts is
+ * R3000-like.  Users should still treat these two macro definitions as
+ * opaque.
+ */
+#ifndef cpu_has_3kex
+#define cpu_has_3kex		(!cpu_has_4kex)
+#endif
 #ifndef cpu_has_4kex
 #define cpu_has_4kex		(cpu_data[0].options & MIPS_CPU_4KEX)
 #endif
@@ -136,7 +146,6 @@
 #endif
 #endif
 
-# define cpu_has_mips_1		(cpu_data[0].isa_level & MIPS_CPU_ISA_I)
 #ifndef cpu_has_mips_2
 # define cpu_has_mips_2		(cpu_data[0].isa_level & MIPS_CPU_ISA_II)
 #endif

commit 8759934e2b6bdb3a08a81fc14a6588f3321719b1
Author: Huacai Chen <chenhc@lemote.com>
Date:   Sun Mar 17 11:49:38 2013 +0000

    MIPS: Build uasm-generated code only once to avoid CPU Hotplug problem
    
    This and the next patch resolve memory corruption problems while CPU
    hotplug. Without these patches, memory corruption can triggered easily
    as below:
    
    On a quad-core MIPS platform, use "spawn" of UnixBench-5.1.3 (http://
    code.google.com/p/byte-unixbench/) and a CPU hotplug script like this
    (hotplug.sh):
    while true; do
    echo 0 >/sys/devices/system/cpu/cpu1/online
    echo 0 >/sys/devices/system/cpu/cpu2/online
    echo 0 >/sys/devices/system/cpu/cpu3/online
    sleep 1
    echo 1 >/sys/devices/system/cpu/cpu1/online
    echo 1 >/sys/devices/system/cpu/cpu2/online
    echo 1 >/sys/devices/system/cpu/cpu3/online
    sleep 1
    done
    
    Run "hotplug.sh" and then run "spawn 10000", spawn will get segfault
    after a few minutes.
    
    This patch:
    Currently, clear_page()/copy_page() are generated by Micro-assembler
    dynamically. But they are unavailable until uasm_resolve_relocs() has
    finished because jump labels are illegal before that. Since these
    functions are shared by every CPU, we only call build_clear_page()/
    build_copy_page() only once at boot time. Without this patch, programs
    will get random memory corruption (segmentation fault, bus error, etc.)
    while CPU Hotplug (e.g. one CPU is using clear_page() while another is
    generating it in cpu_cache_init()).
    
    For similar reasons we modify build_tlb_refill_handler()'s invocation.
    
    V2:
    1, Rework the code to make CPU#0 can be online/offline.
    2, Introduce cpu_has_local_ebase feature since some types of MIPS CPU
       need a per-CPU tlb_refill_handler().
    
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    Signed-off-by: Hongbing Hu <huhb@lemote.com>
    Acked-by: David Daney <david.daney@cavium.com>
    Patchwork: http://patchwork.linux-mips.org/patch/4994/
    Acked-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 1a57e8b4d092..e5ec8fcd8afa 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -113,6 +113,9 @@
 #ifndef cpu_has_pindexed_dcache
 #define cpu_has_pindexed_dcache (cpu_data[0].dcache.flags & MIPS_CACHE_PINDEX)
 #endif
+#ifndef cpu_has_local_ebase
+#define cpu_has_local_ebase	1
+#endif
 
 /*
  * I-Cache snoops remote store.	 This only matters on SMP.  Some multiprocessors

commit 8bfc245f9ad7bd4e461179e4e7852ef99b8b6144
Merge: 612663a97406 535237cecab2
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Feb 21 12:51:33 2013 +0100

    Merge branch 'mips-next-3.9' of git://git.linux-mips.org/pub/scm/john/linux-john into mips-for-linux-next

commit 1e7decdb27ae89b2a0626635a8cf527f930bff1c
Author: David Daney <david.daney@cavium.com>
Date:   Sat Feb 16 23:42:43 2013 +0100

    MIPS: Probe for and report hardware virtualization support.
    
    The presence of the MIPS Virtualization Application-Specific Extension
    is indicated by CP0_Config3[23].  Probe for this and report it in
    /proc/cpuinfo.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Patchwork: http://patchwork.linux-mips.org/patch/4904/
    Signed-off-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 00171cddb6d5..c6f64ef0681e 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -263,4 +263,8 @@
 #define cpu_has_perf_cntr_intr_bit	(cpu_data[0].options & MIPS_CPU_PCI)
 #endif
 
+#ifndef cpu_has_vz
+#define cpu_has_vz		(cpu_data[0].ases & MIPS_ASE_VZ)
+#endif
+
 #endif /* __ASM_CPU_FEATURES_H */

commit f8fa4811dbb264aef13f982e963389fd828b1ac0
Author: Steven J. Hill <sjhill@mips.com>
Date:   Fri Dec 7 03:51:35 2012 +0000

    MIPS: Add support for the M14KEc core.
    
    Signed-off-by: Steven J. Hill <sjhill@mips.com>
    Patchwork: http://patchwork.linux-mips.org/patch/4682/
    Signed-off-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index c507b931b484..00171cddb6d5 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -98,6 +98,9 @@
 #ifndef cpu_has_rixi
 #define cpu_has_rixi		(cpu_data[0].options & MIPS_CPU_RIXI)
 #endif
+#ifndef cpu_has_mmips
+#define cpu_has_mmips		(cpu_data[0].options & MIPS_CPU_MICROMIPS)
+#endif
 #ifndef cpu_has_vtag_icache
 #define cpu_has_vtag_icache	(cpu_data[0].icache.flags & MIPS_CACHE_VTAG)
 #endif

commit a96102be700f87283f168942cd09a2b30f86f324
Author: Steven J. Hill <sjhill@mips.com>
Date:   Fri Dec 7 04:31:36 2012 +0000

    MIPS: Add printing of ISA version in cpuinfo.
    
    Display the MIPS ISA version release in the /proc/cpuinfo file.
    
    [ralf@linux-mips.org: Add support for MIPS I ... IV legacy architecture
    revisions.  Also differenciate between MIPS32 and MIPS64 versions instead
    of lumping them together as just r1 and r2.
    
    Note to application programmers: this indicates the CPU's ISA level
    It does not imply the current execution environment does support it.  For
    example an O32 application seeing "mips64r2" would still be restricted by
    by the execution environment to 32-bit - but the kernel could run mips64r2
    code.  The same for a 32-bit kernel running on a 64-bit processor.  This
    field doesn't include ASEs or optional architecture modules nor other
    detailed flags such as the availability of an FPU.]
    
    Signed-off-by: Steven J. Hill <sjhill@mips.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/4714/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index e0ac24759d92..1e83b24fa461 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -130,6 +130,19 @@
 #endif
 #endif
 
+# define cpu_has_mips_1		(cpu_data[0].isa_level & MIPS_CPU_ISA_I)
+#ifndef cpu_has_mips_2
+# define cpu_has_mips_2		(cpu_data[0].isa_level & MIPS_CPU_ISA_II)
+#endif
+#ifndef cpu_has_mips_3
+# define cpu_has_mips_3		(cpu_data[0].isa_level & MIPS_CPU_ISA_III)
+#endif
+#ifndef cpu_has_mips_4
+# define cpu_has_mips_4		(cpu_data[0].isa_level & MIPS_CPU_ISA_IV)
+#endif
+#ifndef cpu_has_mips_5
+# define cpu_has_mips_5		(cpu_data[0].isa_level & MIPS_CPU_ISA_V)
+#endif
 # ifndef cpu_has_mips32r1
 # define cpu_has_mips32r1	(cpu_data[0].isa_level & MIPS_CPU_ISA_M32R1)
 # endif

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index c507b931b484..e0ac24759d92 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -14,7 +14,7 @@
 #include <cpu-feature-overrides.h>
 
 #ifndef current_cpu_type
-#define current_cpu_type()      current_cpu_data.cputype
+#define current_cpu_type()	current_cpu_data.cputype
 #endif
 
 /*
@@ -87,10 +87,10 @@
 #define cpu_has_mips16		(cpu_data[0].ases & MIPS_ASE_MIPS16)
 #endif
 #ifndef cpu_has_mdmx
-#define cpu_has_mdmx           (cpu_data[0].ases & MIPS_ASE_MDMX)
+#define cpu_has_mdmx	       (cpu_data[0].ases & MIPS_ASE_MDMX)
 #endif
 #ifndef cpu_has_mips3d
-#define cpu_has_mips3d         (cpu_data[0].ases & MIPS_ASE_MIPS3D)
+#define cpu_has_mips3d	       (cpu_data[0].ases & MIPS_ASE_MIPS3D)
 #endif
 #ifndef cpu_has_smartmips
 #define cpu_has_smartmips      (cpu_data[0].ases & MIPS_ASE_SMARTMIPS)
@@ -108,11 +108,11 @@
 #define cpu_has_ic_fills_f_dc	(cpu_data[0].icache.flags & MIPS_CACHE_IC_F_DC)
 #endif
 #ifndef cpu_has_pindexed_dcache
-#define cpu_has_pindexed_dcache	(cpu_data[0].dcache.flags & MIPS_CACHE_PINDEX)
+#define cpu_has_pindexed_dcache (cpu_data[0].dcache.flags & MIPS_CACHE_PINDEX)
 #endif
 
 /*
- * I-Cache snoops remote store.  This only matters on SMP.  Some multiprocessors
+ * I-Cache snoops remote store.	 This only matters on SMP.  Some multiprocessors
  * such as the R10000 have I-Caches that snoop local stores; the embedded ones
  * don't.  For maintaining I-cache coherency this means we need to flush the
  * D-cache all the way back to whever the I-cache does refills from, so the
@@ -148,8 +148,8 @@
  */
 #define cpu_has_mips32	(cpu_has_mips32r1 | cpu_has_mips32r2)
 #define cpu_has_mips64	(cpu_has_mips64r1 | cpu_has_mips64r2)
-#define cpu_has_mips_r1	(cpu_has_mips32r1 | cpu_has_mips64r1)
-#define cpu_has_mips_r2	(cpu_has_mips32r2 | cpu_has_mips64r2)
+#define cpu_has_mips_r1 (cpu_has_mips32r1 | cpu_has_mips64r1)
+#define cpu_has_mips_r2 (cpu_has_mips32r2 | cpu_has_mips64r2)
 #define cpu_has_mips_r	(cpu_has_mips32r1 | cpu_has_mips32r2 | \
 			 cpu_has_mips64r1 | cpu_has_mips64r2)
 
@@ -159,7 +159,7 @@
 
 /*
  * MIPS32, MIPS64, VR5500, IDT32332, IDT32334 and maybe a few other
- * pre-MIPS32/MIPS53 processors have CLO, CLZ.  The IDT RC64574 is 64-bit and
+ * pre-MIPS32/MIPS53 processors have CLO, CLZ.	The IDT RC64574 is 64-bit and
  * has CLO and CLZ but not DCLO nor DCLZ.  For 64-bit kernels
  * cpu_has_clo_clz also indicates the availability of DCLO and DCLZ.
  */
@@ -191,7 +191,7 @@
 # define cpu_has_64bits		(cpu_data[0].isa_level & MIPS_CPU_ISA_64BIT)
 # endif
 # ifndef cpu_has_64bit_zero_reg
-# define cpu_has_64bit_zero_reg	(cpu_data[0].isa_level & MIPS_CPU_ISA_64BIT)
+# define cpu_has_64bit_zero_reg (cpu_data[0].isa_level & MIPS_CPU_ISA_64BIT)
 # endif
 # ifndef cpu_has_64bit_gp_regs
 # define cpu_has_64bit_gp_regs		0

commit ee80f7c73dc1b1f0ba9f82079c9bd1c0d1aedef8
Author: Steven J. Hill <sjhill@mips.com>
Date:   Fri Aug 3 10:26:04 2012 -0500

    MIPS: Add detection of DSP ASE Revision 2.
    
    [ralf@linux-mips.org: This patch really only detects the ASE and passes its
    existence on to userland via /proc/cpuinfo.  The DSP ASE Rev 2. adds new
    resources but no resources that would need management by the kernel.]
    
    Signed-off-by: Steven J. Hill <sjhill@mips.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/4165/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 089125a6ae6a..c507b931b484 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -171,6 +171,10 @@
 #define cpu_has_dsp		(cpu_data[0].ases & MIPS_ASE_DSP)
 #endif
 
+#ifndef cpu_has_dsp2
+#define cpu_has_dsp2		(cpu_data[0].ases & MIPS_ASE_DSP2P)
+#endif
+
 #ifndef cpu_has_mipsmt
 #define cpu_has_mipsmt		(cpu_data[0].ases & MIPS_ASE_MIPSMT)
 #endif

commit da4b62cd6762ce327f660c6e45c8d5a739197159
Author: Al Cooper <alcooperx@gmail.com>
Date:   Fri Jul 13 16:44:51 2012 -0400

    MIPS: perf: Add cpu feature bit for PCI (performance counter interrupt)
    
    The PCI (Program Counter Interrupt) bit in the "cause" register
    is mandatory for MIPS32R2 cores, but has also been added to some R1
    cores (BMIPS5000). This change adds a cpu feature bit to make it
    easier to check for and use this feature.
    
    Signed-off-by: Al Cooper <alcooperx@gmail.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/4106/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 63002a240c73..089125a6ae6a 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -252,4 +252,8 @@
 #define cpu_hwrena_impl_bits		0
 #endif
 
+#ifndef cpu_has_perf_cntr_intr_bit
+#define cpu_has_perf_cntr_intr_bit	(cpu_data[0].options & MIPS_CPU_PCI)
+#endif
+
 #endif /* __ASM_CPU_FEATURES_H */

commit 05857c64ecf897209c16ffad9bb3e8d359dd5dca
Author: Steven J. Hill <sjhill@mips.com>
Date:   Thu Sep 13 16:51:46 2012 -0500

    MIPS: Replace 'kernel_uses_smartmips_rixi' with 'cpu_has_rixi'.
    
    Remove usage of the 'kernel_uses_smartmips_rixi' macro from all files
    and use new 'cpu_has_rixi' instead.
    
    Signed-off-by: Steven J. Hill <sjhill@mips.com>
    Acked-by: David Daney <david.daney@cavium.com>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 3af9aca65ab5..63002a240c73 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -98,9 +98,6 @@
 #ifndef cpu_has_rixi
 #define cpu_has_rixi		(cpu_data[0].options & MIPS_CPU_RIXI)
 #endif
-#ifndef kernel_uses_smartmips_rixi
-#define kernel_uses_smartmips_rixi 0
-#endif
 #ifndef cpu_has_vtag_icache
 #define cpu_has_vtag_icache	(cpu_data[0].icache.flags & MIPS_CACHE_VTAG)
 #endif

commit b2ab4f08e84d4031f82255447180c559bd076bbf
Author: Steven J. Hill <sjhill@mips.com>
Date:   Thu Sep 13 16:47:58 2012 -0500

    MIPS: Add base architecture support for RI and XI.
    
    Originally both Read Inhibit (RI) and Execute Inhibit (XI) were
    supported by the TLB only for a SmartMIPS core. The MIPSr3(TM)
    Architecture now defines an optional feature to implement these
    TLB bits separately. Support for one or both features can be
    checked by looking at the Config3.RXI bit.
    
    Signed-off-by: Steven J. Hill <sjhill@mips.com>
    Acked-by: David Daney <david.daney@cavium.com>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index ca400f7c3f59..3af9aca65ab5 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -95,6 +95,9 @@
 #ifndef cpu_has_smartmips
 #define cpu_has_smartmips      (cpu_data[0].ases & MIPS_ASE_SMARTMIPS)
 #endif
+#ifndef cpu_has_rixi
+#define cpu_has_rixi		(cpu_data[0].options & MIPS_CPU_RIXI)
+#endif
 #ifndef kernel_uses_smartmips_rixi
 #define kernel_uses_smartmips_rixi 0
 #endif

commit 417a5eb02ce8e5fbaf3d97d8dacc813b0a273ec3
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Aug 5 13:26:01 2010 +0100

    MIPS: Update comment for cpu_has_clo_clz
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index ac73cede3a0a..ca400f7c3f59 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -159,7 +159,8 @@
 
 /*
  * MIPS32, MIPS64, VR5500, IDT32332, IDT32334 and maybe a few other
- * pre-MIPS32/MIPS53 processors have CLO, CLZ.  For 64-bit kernels
+ * pre-MIPS32/MIPS53 processors have CLO, CLZ.  The IDT RC64574 is 64-bit and
+ * has CLO and CLZ but not DCLO nor DCLZ.  For 64-bit kernels
  * cpu_has_clo_clz also indicates the availability of DCLO and DCLZ.
  */
 # ifndef cpu_has_clo_clz

commit 6dd9344cfc41bcc60a01cdc828cb278be7a10e01
Author: David Daney <ddaney@caviumnetworks.com>
Date:   Wed Feb 10 15:12:47 2010 -0800

    MIPS: Implement Read Inhibit/eXecute Inhibit
    
    The SmartMIPS ASE specifies how Read Inhibit (RI) and eXecute Inhibit
    (XI) bits in the page tables work.  The upper two bits of EntryLo{0,1}
    are RI and XI when the feature is enabled in the PageGrain register.
    SmartMIPS only covers 32-bit systems.  Cavium Octeon+ extends this to
    64-bit systems by continuing to place the RI and XI bits in the top of
    EntryLo even when EntryLo is 64-bits wide.
    
    Because we need to carry the RI and XI bits in the PTE, the layout of
    the PTE is changed.  There is a two instruction overhead in the TLB
    refill hot path to get the EntryLo bits into the proper position.
    Also the TLB load exception has to probe the TLB to check if RI or XI
    caused the exception.
    
    Also of note is that the layout of the PTE bits is done at compile and
    runtime rather than statically.  In the 32-bit case this allows for
    the same number of PFN bits as before the patch as the _PAGE_HUGE is
    not supported in 32-bit kernels (we have _PAGE_NO_EXEC and
    _PAGE_NO_READ instead of _PAGE_READ and _PAGE_HUGE).
    
    The patch is tested on Cavium Octeon+, but should also work on 32-bit
    systems with the Smart-MIPS ASE.
    
    Signed-off-by: David Daney <ddaney@caviumnetworks.com>
    To: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/952/
    Patchwork: http://patchwork.linux-mips.org/patch/956/
    Patchwork: http://patchwork.linux-mips.org/patch/962/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 272c5ef35bbb..ac73cede3a0a 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -95,6 +95,9 @@
 #ifndef cpu_has_smartmips
 #define cpu_has_smartmips      (cpu_data[0].ases & MIPS_ASE_SMARTMIPS)
 #endif
+#ifndef kernel_uses_smartmips_rixi
+#define kernel_uses_smartmips_rixi 0
+#endif
 #ifndef cpu_has_vtag_icache
 #define cpu_has_vtag_icache	(cpu_data[0].icache.flags & MIPS_CACHE_VTAG)
 #endif

commit 91dfc423cc8cfd399fb308a837102a7ab7fa067e
Author: Guenter Roeck <guenter.roeck@ericsson.com>
Date:   Tue Feb 2 08:52:20 2010 -0800

    MIPS: 64-bit: Detect virtual memory size
    
    Linux kernel 2.6.32 and later allocate address space from the top of the
    kernel virtual memory address space.
    
    This patch implements virtual memory size detection for 64 bit MIPS CPUs
    to avoid resulting crashes.
    
    Signed-off-by: Guenter Roeck <guenter.roeck@ericsson.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/935/
    Reviewed-by: David Daney <ddaney@caviumnetworks.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 1f4df647c384..272c5ef35bbb 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -191,6 +191,9 @@
 # ifndef cpu_has_64bit_addresses
 # define cpu_has_64bit_addresses	0
 # endif
+# ifndef cpu_vmbits
+# define cpu_vmbits 31
+# endif
 #endif
 
 #ifdef CONFIG_64BIT
@@ -209,6 +212,10 @@
 # ifndef cpu_has_64bit_addresses
 # define cpu_has_64bit_addresses	1
 # endif
+# ifndef cpu_vmbits
+# define cpu_vmbits cpu_data[0].vmbits
+# define __NEED_VMBITS_PROBE
+# endif
 #endif
 
 #if defined(CONFIG_CPU_MIPSR2_IRQ_VI) && !defined(cpu_has_vint)

commit b791d1193af9772040e592d5aa161790f800b762
Author: David Daney <ddaney@caviumnetworks.com>
Date:   Mon Jul 13 11:15:19 2009 -0700

    MIPS: Allow kernel use of LL/SC to be separate from the presence of LL/SC.
    
    On some CPUs, it is more efficient to disable and enable interrupts in the
    kernel rather than use ll/sc for atomic operations.  But if we were to set
    cpu_has_llsc to false, we would break the userspace futex interface (in
    asm/futex.h).
    
    We separate the two concepts, with a new predicate kernel_uses_llsc, that
    lets us disable the kernel's use of ll/sc while still allowing the futex
    code to use it.
    
    Also there were a couple of cases in bitops.h where we were using ll/sc
    unconditionally even if cpu_has_llsc were false.
    
    Signed-off-by: David Daney <ddaney@caviumnetworks.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 8ab1d12ba7f4..1f4df647c384 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -80,6 +80,9 @@
 #ifndef cpu_has_llsc
 #define cpu_has_llsc		(cpu_data[0].options & MIPS_CPU_LLSC)
 #endif
+#ifndef kernel_uses_llsc
+#define kernel_uses_llsc	cpu_has_llsc
+#endif
 #ifndef cpu_has_mips16
 #define cpu_has_mips16		(cpu_data[0].ases & MIPS_ASE_MIPS16)
 #endif

commit fbeda19f82aa07082d2e1607a9f5114141dae2ac
Author: David Daney <ddaney@caviumnetworks.com>
Date:   Wed May 13 15:59:55 2009 -0700

    MIPS: Allow CPU specific overriding of CP0 hwrena impl bits.
    
    Some CPUs have implementation dependent rdhwr registers.  Allow them
    to be enabled on a per CPU basis.
    
    Signed-off-by: David Daney <ddaney@caviumnetworks.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 1cba4b2ffd1e..8ab1d12ba7f4 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -234,4 +234,8 @@
 #define cpu_scache_line_size()	cpu_data[0].scache.linesz
 #endif
 
+#ifndef cpu_hwrena_impl_bits
+#define cpu_hwrena_impl_bits		0
+#endif
+
 #endif /* __ASM_CPU_FEATURES_H */

commit 41f0e4d041aa30507a34998c29d0b7ac0bede277
Author: David Daney <ddaney@caviumnetworks.com>
Date:   Tue May 12 12:41:53 2009 -0700

    MIPS: Allow R2 CPUs to turn off generation of 'ehb' instructions.
    
    Some CPUs do not need ehb instructions after writing CP0 registers.
    By allowing ehb generation to be overridden in
    cpu-feature-overrides.h, we can save a few instructions in the TLB
    handler hot paths.
    
    Signed-off-by: David Daney <ddaney@caviumnetworks.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index c0047f861337..1cba4b2ffd1e 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -147,6 +147,10 @@
 #define cpu_has_mips_r	(cpu_has_mips32r1 | cpu_has_mips32r2 | \
 			 cpu_has_mips64r1 | cpu_has_mips64r2)
 
+#ifndef cpu_has_mips_r2_exec_hazard
+#define cpu_has_mips_r2_exec_hazard cpu_has_mips_r2
+#endif
+
 /*
  * MIPS32, MIPS64, VR5500, IDT32332, IDT32334 and maybe a few other
  * pre-MIPS32/MIPS53 processors have CLO, CLZ.  For 64-bit kernels

commit 47740eb887796608fb4c629aa6b8507a2fb6c0eb
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sun Apr 19 03:21:22 2009 +0200

    MIPS: Enable CLO / CLZ instructions via separate CPU property
    
    This is useful for IDT RC32332, RC32334 and NEC VR5500 processors which do
    not implement the full MIPS32 / MIPS64 architecture.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index a0d14f85b781..c0047f861337 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -147,6 +147,15 @@
 #define cpu_has_mips_r	(cpu_has_mips32r1 | cpu_has_mips32r2 | \
 			 cpu_has_mips64r1 | cpu_has_mips64r2)
 
+/*
+ * MIPS32, MIPS64, VR5500, IDT32332, IDT32334 and maybe a few other
+ * pre-MIPS32/MIPS53 processors have CLO, CLZ.  For 64-bit kernels
+ * cpu_has_clo_clz also indicates the availability of DCLO and DCLZ.
+ */
+# ifndef cpu_has_clo_clz
+# define cpu_has_clo_clz	cpu_has_mips_r
+# endif
+
 #ifndef cpu_has_dsp
 #define cpu_has_dsp		(cpu_data[0].ases & MIPS_ASE_DSP)
 #endif

commit 47d979eca33f8df49bfead2d5efa23a70b413882
Author: David Daney <ddaney@caviumnetworks.com>
Date:   Thu Dec 11 15:33:27 2008 -0800

    MIPS: Hook Cavium OCTEON cache init into cache.c
    
    Follow precedent of other boards, and hook-up the CPU specific cache
    init.
    
    Signed-off-by: Tomaso Paoletti <tpaoletti@caviumnetworks.com>
    Signed-off-by: David Daney <ddaney@caviumnetworks.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 12d12dfe73c0..a0d14f85b781 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -38,6 +38,9 @@
 #ifndef cpu_has_tx39_cache
 #define cpu_has_tx39_cache	(cpu_data[0].options & MIPS_CPU_TX39_CACHE)
 #endif
+#ifndef cpu_has_octeon_cache
+#define cpu_has_octeon_cache	0
+#endif
 #ifndef cpu_has_fpu
 #define cpu_has_fpu		(current_cpu_data.options & MIPS_CPU_FPU)
 #define raw_cpu_has_fpu		(raw_current_cpu_data.options & MIPS_CPU_FPU)

commit c46b302b948e2070cb713171207c42e9586f131a
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Oct 28 09:37:47 2008 +0000

    MIPS: New feature test macro cpu_has_mips_r
    
    cpu_has_mips_r is true if a processor is MIPS32 or MIPS64, any architecture
    revision.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index 5ea701fc3425..12d12dfe73c0 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -141,6 +141,8 @@
 #define cpu_has_mips64	(cpu_has_mips64r1 | cpu_has_mips64r2)
 #define cpu_has_mips_r1	(cpu_has_mips32r1 | cpu_has_mips64r1)
 #define cpu_has_mips_r2	(cpu_has_mips32r2 | cpu_has_mips64r2)
+#define cpu_has_mips_r	(cpu_has_mips32r1 | cpu_has_mips32r2 | \
+			 cpu_has_mips64r1 | cpu_has_mips64r2)
 
 #ifndef cpu_has_dsp
 #define cpu_has_dsp		(cpu_data[0].ases & MIPS_ASE_DSP)

commit 384740dc49ea651ba350704d13ff6be9976e37fe
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Sep 16 19:48:51 2008 +0200

    MIPS: Move headfiles to new location below arch/mips/include
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
new file mode 100644
index 000000000000..5ea701fc3425
--- /dev/null
+++ b/arch/mips/include/asm/cpu-features.h
@@ -0,0 +1,219 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2003, 2004 Ralf Baechle
+ * Copyright (C) 2004  Maciej W. Rozycki
+ */
+#ifndef __ASM_CPU_FEATURES_H
+#define __ASM_CPU_FEATURES_H
+
+#include <asm/cpu.h>
+#include <asm/cpu-info.h>
+#include <cpu-feature-overrides.h>
+
+#ifndef current_cpu_type
+#define current_cpu_type()      current_cpu_data.cputype
+#endif
+
+/*
+ * SMP assumption: Options of CPU 0 are a superset of all processors.
+ * This is true for all known MIPS systems.
+ */
+#ifndef cpu_has_tlb
+#define cpu_has_tlb		(cpu_data[0].options & MIPS_CPU_TLB)
+#endif
+#ifndef cpu_has_4kex
+#define cpu_has_4kex		(cpu_data[0].options & MIPS_CPU_4KEX)
+#endif
+#ifndef cpu_has_3k_cache
+#define cpu_has_3k_cache	(cpu_data[0].options & MIPS_CPU_3K_CACHE)
+#endif
+#define cpu_has_6k_cache	0
+#define cpu_has_8k_cache	0
+#ifndef cpu_has_4k_cache
+#define cpu_has_4k_cache	(cpu_data[0].options & MIPS_CPU_4K_CACHE)
+#endif
+#ifndef cpu_has_tx39_cache
+#define cpu_has_tx39_cache	(cpu_data[0].options & MIPS_CPU_TX39_CACHE)
+#endif
+#ifndef cpu_has_fpu
+#define cpu_has_fpu		(current_cpu_data.options & MIPS_CPU_FPU)
+#define raw_cpu_has_fpu		(raw_current_cpu_data.options & MIPS_CPU_FPU)
+#else
+#define raw_cpu_has_fpu		cpu_has_fpu
+#endif
+#ifndef cpu_has_32fpr
+#define cpu_has_32fpr		(cpu_data[0].options & MIPS_CPU_32FPR)
+#endif
+#ifndef cpu_has_counter
+#define cpu_has_counter		(cpu_data[0].options & MIPS_CPU_COUNTER)
+#endif
+#ifndef cpu_has_watch
+#define cpu_has_watch		(cpu_data[0].options & MIPS_CPU_WATCH)
+#endif
+#ifndef cpu_has_divec
+#define cpu_has_divec		(cpu_data[0].options & MIPS_CPU_DIVEC)
+#endif
+#ifndef cpu_has_vce
+#define cpu_has_vce		(cpu_data[0].options & MIPS_CPU_VCE)
+#endif
+#ifndef cpu_has_cache_cdex_p
+#define cpu_has_cache_cdex_p	(cpu_data[0].options & MIPS_CPU_CACHE_CDEX_P)
+#endif
+#ifndef cpu_has_cache_cdex_s
+#define cpu_has_cache_cdex_s	(cpu_data[0].options & MIPS_CPU_CACHE_CDEX_S)
+#endif
+#ifndef cpu_has_prefetch
+#define cpu_has_prefetch	(cpu_data[0].options & MIPS_CPU_PREFETCH)
+#endif
+#ifndef cpu_has_mcheck
+#define cpu_has_mcheck		(cpu_data[0].options & MIPS_CPU_MCHECK)
+#endif
+#ifndef cpu_has_ejtag
+#define cpu_has_ejtag		(cpu_data[0].options & MIPS_CPU_EJTAG)
+#endif
+#ifndef cpu_has_llsc
+#define cpu_has_llsc		(cpu_data[0].options & MIPS_CPU_LLSC)
+#endif
+#ifndef cpu_has_mips16
+#define cpu_has_mips16		(cpu_data[0].ases & MIPS_ASE_MIPS16)
+#endif
+#ifndef cpu_has_mdmx
+#define cpu_has_mdmx           (cpu_data[0].ases & MIPS_ASE_MDMX)
+#endif
+#ifndef cpu_has_mips3d
+#define cpu_has_mips3d         (cpu_data[0].ases & MIPS_ASE_MIPS3D)
+#endif
+#ifndef cpu_has_smartmips
+#define cpu_has_smartmips      (cpu_data[0].ases & MIPS_ASE_SMARTMIPS)
+#endif
+#ifndef cpu_has_vtag_icache
+#define cpu_has_vtag_icache	(cpu_data[0].icache.flags & MIPS_CACHE_VTAG)
+#endif
+#ifndef cpu_has_dc_aliases
+#define cpu_has_dc_aliases	(cpu_data[0].dcache.flags & MIPS_CACHE_ALIASES)
+#endif
+#ifndef cpu_has_ic_fills_f_dc
+#define cpu_has_ic_fills_f_dc	(cpu_data[0].icache.flags & MIPS_CACHE_IC_F_DC)
+#endif
+#ifndef cpu_has_pindexed_dcache
+#define cpu_has_pindexed_dcache	(cpu_data[0].dcache.flags & MIPS_CACHE_PINDEX)
+#endif
+
+/*
+ * I-Cache snoops remote store.  This only matters on SMP.  Some multiprocessors
+ * such as the R10000 have I-Caches that snoop local stores; the embedded ones
+ * don't.  For maintaining I-cache coherency this means we need to flush the
+ * D-cache all the way back to whever the I-cache does refills from, so the
+ * I-cache has a chance to see the new data at all.  Then we have to flush the
+ * I-cache also.
+ * Note we may have been rescheduled and may no longer be running on the CPU
+ * that did the store so we can't optimize this into only doing the flush on
+ * the local CPU.
+ */
+#ifndef cpu_icache_snoops_remote_store
+#ifdef CONFIG_SMP
+#define cpu_icache_snoops_remote_store	(cpu_data[0].icache.flags & MIPS_IC_SNOOPS_REMOTE)
+#else
+#define cpu_icache_snoops_remote_store	1
+#endif
+#endif
+
+# ifndef cpu_has_mips32r1
+# define cpu_has_mips32r1	(cpu_data[0].isa_level & MIPS_CPU_ISA_M32R1)
+# endif
+# ifndef cpu_has_mips32r2
+# define cpu_has_mips32r2	(cpu_data[0].isa_level & MIPS_CPU_ISA_M32R2)
+# endif
+# ifndef cpu_has_mips64r1
+# define cpu_has_mips64r1	(cpu_data[0].isa_level & MIPS_CPU_ISA_M64R1)
+# endif
+# ifndef cpu_has_mips64r2
+# define cpu_has_mips64r2	(cpu_data[0].isa_level & MIPS_CPU_ISA_M64R2)
+# endif
+
+/*
+ * Shortcuts ...
+ */
+#define cpu_has_mips32	(cpu_has_mips32r1 | cpu_has_mips32r2)
+#define cpu_has_mips64	(cpu_has_mips64r1 | cpu_has_mips64r2)
+#define cpu_has_mips_r1	(cpu_has_mips32r1 | cpu_has_mips64r1)
+#define cpu_has_mips_r2	(cpu_has_mips32r2 | cpu_has_mips64r2)
+
+#ifndef cpu_has_dsp
+#define cpu_has_dsp		(cpu_data[0].ases & MIPS_ASE_DSP)
+#endif
+
+#ifndef cpu_has_mipsmt
+#define cpu_has_mipsmt		(cpu_data[0].ases & MIPS_ASE_MIPSMT)
+#endif
+
+#ifndef cpu_has_userlocal
+#define cpu_has_userlocal	(cpu_data[0].options & MIPS_CPU_ULRI)
+#endif
+
+#ifdef CONFIG_32BIT
+# ifndef cpu_has_nofpuex
+# define cpu_has_nofpuex	(cpu_data[0].options & MIPS_CPU_NOFPUEX)
+# endif
+# ifndef cpu_has_64bits
+# define cpu_has_64bits		(cpu_data[0].isa_level & MIPS_CPU_ISA_64BIT)
+# endif
+# ifndef cpu_has_64bit_zero_reg
+# define cpu_has_64bit_zero_reg	(cpu_data[0].isa_level & MIPS_CPU_ISA_64BIT)
+# endif
+# ifndef cpu_has_64bit_gp_regs
+# define cpu_has_64bit_gp_regs		0
+# endif
+# ifndef cpu_has_64bit_addresses
+# define cpu_has_64bit_addresses	0
+# endif
+#endif
+
+#ifdef CONFIG_64BIT
+# ifndef cpu_has_nofpuex
+# define cpu_has_nofpuex		0
+# endif
+# ifndef cpu_has_64bits
+# define cpu_has_64bits			1
+# endif
+# ifndef cpu_has_64bit_zero_reg
+# define cpu_has_64bit_zero_reg		1
+# endif
+# ifndef cpu_has_64bit_gp_regs
+# define cpu_has_64bit_gp_regs		1
+# endif
+# ifndef cpu_has_64bit_addresses
+# define cpu_has_64bit_addresses	1
+# endif
+#endif
+
+#if defined(CONFIG_CPU_MIPSR2_IRQ_VI) && !defined(cpu_has_vint)
+# define cpu_has_vint		(cpu_data[0].options & MIPS_CPU_VINT)
+#elif !defined(cpu_has_vint)
+# define cpu_has_vint			0
+#endif
+
+#if defined(CONFIG_CPU_MIPSR2_IRQ_EI) && !defined(cpu_has_veic)
+# define cpu_has_veic		(cpu_data[0].options & MIPS_CPU_VEIC)
+#elif !defined(cpu_has_veic)
+# define cpu_has_veic			0
+#endif
+
+#ifndef cpu_has_inclusive_pcaches
+#define cpu_has_inclusive_pcaches	(cpu_data[0].options & MIPS_CPU_INCLUSIVE_CACHES)
+#endif
+
+#ifndef cpu_dcache_line_size
+#define cpu_dcache_line_size()	cpu_data[0].dcache.linesz
+#endif
+#ifndef cpu_icache_line_size
+#define cpu_icache_line_size()	cpu_data[0].icache.linesz
+#endif
+#ifndef cpu_scache_line_size
+#define cpu_scache_line_size()	cpu_data[0].scache.linesz
+#endif
+
+#endif /* __ASM_CPU_FEATURES_H */
