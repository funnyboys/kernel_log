commit 5210edcd527773c227465ad18e416a894966324f
Author: David Daney <david.daney@cavium.com>
Date:   Fri Sep 28 11:34:10 2012 -0700

    MIPS: Make __{,n,u}delay declarations match definitions and generic delay.h
    
    At some recent point arch/mips/include/asm/delay.h has started being
    included into csrc-octeon.c where the __?delay() functions are defined.
    This causes a compile failure due to conflicting declarations and
    definitions of the functions.
    
    It turns out that the generic definitions in arch/mips/lib/delay.c also
    conflict.
    
    Proposed fix: Declare the functions to take unsigned long parameters
    just like asm-generic (and x86) does.  Update __delay to agree
    (__ndelay and __udelay need no change).
    
    Bonus: Get rid of 'inline' from __delay() definition, as it is globally
    visible, and the compiler should be making this decision itself (it does
    in fact inline the function without being told to).
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/4354/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/delay.h b/arch/mips/include/asm/delay.h
index e7cd78277c23..dc0a5f77a35c 100644
--- a/arch/mips/include/asm/delay.h
+++ b/arch/mips/include/asm/delay.h
@@ -13,9 +13,9 @@
 
 #include <linux/param.h>
 
-extern void __delay(unsigned int loops);
-extern void __ndelay(unsigned int ns);
-extern void __udelay(unsigned int us);
+extern void __delay(unsigned long loops);
+extern void __ndelay(unsigned long ns);
+extern void __udelay(unsigned long us);
 
 #define ndelay(ns) __ndelay(ns)
 #define udelay(us) __udelay(us)

commit e3bf887d73309808d47c74f2f024d2497c8f7048
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Aug 28 12:29:58 2009 +0100

    MIPS: Fix potencial build error in <asm/delay.h>
    
    <asm/delay.h> will break if HZ isn't defined.  In 2.6.26 and later we're
    usually lucky ...
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/delay.h b/arch/mips/include/asm/delay.h
index d2d8949be6b7..e7cd78277c23 100644
--- a/arch/mips/include/asm/delay.h
+++ b/arch/mips/include/asm/delay.h
@@ -11,6 +11,8 @@
 #ifndef _ASM_DELAY_H
 #define _ASM_DELAY_H
 
+#include <linux/param.h>
+
 extern void __delay(unsigned int loops);
 extern void __ndelay(unsigned int ns);
 extern void __udelay(unsigned int us);

commit 39027ff07b572d5015f29a5bbbc36394f4e6f32e
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Jun 12 17:28:00 2009 +0100

    MIPS: Fix typo resulting in far too long ndelay times.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/delay.h b/arch/mips/include/asm/delay.h
index a07e51b2be13..d2d8949be6b7 100644
--- a/arch/mips/include/asm/delay.h
+++ b/arch/mips/include/asm/delay.h
@@ -15,7 +15,7 @@ extern void __delay(unsigned int loops);
 extern void __ndelay(unsigned int ns);
 extern void __udelay(unsigned int us);
 
-#define ndelay(ns) __udelay(ns)
+#define ndelay(ns) __ndelay(ns)
 #define udelay(us) __udelay(us)
 
 /* make sure "usecs *= ..." in udelay do not overflow. */

commit 5636919b5c909fee54a6ef5226475ecae012ad02
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Feb 28 09:44:28 2009 +0000

    MIPS: Outline udelay and fix a few issues.
    
    Outlining fixes the issue were on certain CPUs such as the R10000 family
    the delay loop would need an extra cycle if it overlaps a cacheline
    boundary.
    
    The rewrite also fixes build errors with GCC 4.4 which was changed in
    way incompatible with the kernel's inline assembly.
    
    Relying on pure C for computation of the delay value removes the need for
    explicit.  The price we pay is a slight slowdown of the computation - to
    be fixed on another day.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/delay.h b/arch/mips/include/asm/delay.h
index b0bccd2c4ed5..a07e51b2be13 100644
--- a/arch/mips/include/asm/delay.h
+++ b/arch/mips/include/asm/delay.h
@@ -11,94 +11,12 @@
 #ifndef _ASM_DELAY_H
 #define _ASM_DELAY_H
 
-#include <linux/param.h>
-#include <linux/smp.h>
+extern void __delay(unsigned int loops);
+extern void __ndelay(unsigned int ns);
+extern void __udelay(unsigned int us);
 
-#include <asm/compiler.h>
-#include <asm/war.h>
-
-static inline void __delay(unsigned long loops)
-{
-	if (sizeof(long) == 4)
-		__asm__ __volatile__ (
-		"	.set	noreorder				\n"
-		"	.align	3					\n"
-		"1:	bnez	%0, 1b					\n"
-		"	subu	%0, 1					\n"
-		"	.set	reorder					\n"
-		: "=r" (loops)
-		: "0" (loops));
-	else if (sizeof(long) == 8 && !DADDI_WAR)
-		__asm__ __volatile__ (
-		"	.set	noreorder				\n"
-		"	.align	3					\n"
-		"1:	bnez	%0, 1b					\n"
-		"	dsubu	%0, 1					\n"
-		"	.set	reorder					\n"
-		: "=r" (loops)
-		: "0" (loops));
-	else if (sizeof(long) == 8 && DADDI_WAR)
-		__asm__ __volatile__ (
-		"	.set	noreorder				\n"
-		"	.align	3					\n"
-		"1:	bnez	%0, 1b					\n"
-		"	dsubu	%0, %2					\n"
-		"	.set	reorder					\n"
-		: "=r" (loops)
-		: "0" (loops), "r" (1));
-}
-
-
-/*
- * Division by multiplication: you don't have to worry about
- * loss of precision.
- *
- * Use only for very small delays ( < 1 msec).  Should probably use a
- * lookup table, really, as the multiplications take much too long with
- * short delays.  This is a "reasonable" implementation, though (and the
- * first constant multiplications gets optimized away if the delay is
- * a constant)
- */
-
-static inline void __udelay(unsigned long usecs, unsigned long lpj)
-{
-	unsigned long hi, lo;
-
-	/*
-	 * The rates of 128 is rounded wrongly by the catchall case
-	 * for 64-bit.  Excessive precission?  Probably ...
-	 */
-#if defined(CONFIG_64BIT) && (HZ == 128)
-	usecs *= 0x0008637bd05af6c7UL;		/* 2**64 / (1000000 / HZ) */
-#elif defined(CONFIG_64BIT)
-	usecs *= (0x8000000000000000UL / (500000 / HZ));
-#else /* 32-bit junk follows here */
-	usecs *= (unsigned long) (((0x8000000000000000ULL / (500000 / HZ)) +
-	                           0x80000000ULL) >> 32);
-#endif
-
-	if (sizeof(long) == 4)
-		__asm__("multu\t%2, %3"
-		: "=h" (usecs), "=l" (lo)
-		: "r" (usecs), "r" (lpj)
-		: GCC_REG_ACCUM);
-	else if (sizeof(long) == 8 && !R4000_WAR)
-		__asm__("dmultu\t%2, %3"
-		: "=h" (usecs), "=l" (lo)
-		: "r" (usecs), "r" (lpj)
-		: GCC_REG_ACCUM);
-	else if (sizeof(long) == 8 && R4000_WAR)
-		__asm__("dmultu\t%3, %4\n\tmfhi\t%0"
-		: "=r" (usecs), "=h" (hi), "=l" (lo)
-		: "r" (usecs), "r" (lpj)
-		: GCC_REG_ACCUM);
-
-	__delay(usecs);
-}
-
-#define __udelay_val cpu_data[raw_smp_processor_id()].udelay_val
-
-#define udelay(usecs) __udelay((usecs), __udelay_val)
+#define ndelay(ns) __udelay(ns)
+#define udelay(us) __udelay(us)
 
 /* make sure "usecs *= ..." in udelay do not overflow. */
 #if HZ >= 1000

commit 384740dc49ea651ba350704d13ff6be9976e37fe
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Sep 16 19:48:51 2008 +0200

    MIPS: Move headfiles to new location below arch/mips/include
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/delay.h b/arch/mips/include/asm/delay.h
new file mode 100644
index 000000000000..b0bccd2c4ed5
--- /dev/null
+++ b/arch/mips/include/asm/delay.h
@@ -0,0 +1,112 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1994 by Waldorf Electronics
+ * Copyright (C) 1995 - 2000, 01, 03 by Ralf Baechle
+ * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
+ * Copyright (C) 2007  Maciej W. Rozycki
+ */
+#ifndef _ASM_DELAY_H
+#define _ASM_DELAY_H
+
+#include <linux/param.h>
+#include <linux/smp.h>
+
+#include <asm/compiler.h>
+#include <asm/war.h>
+
+static inline void __delay(unsigned long loops)
+{
+	if (sizeof(long) == 4)
+		__asm__ __volatile__ (
+		"	.set	noreorder				\n"
+		"	.align	3					\n"
+		"1:	bnez	%0, 1b					\n"
+		"	subu	%0, 1					\n"
+		"	.set	reorder					\n"
+		: "=r" (loops)
+		: "0" (loops));
+	else if (sizeof(long) == 8 && !DADDI_WAR)
+		__asm__ __volatile__ (
+		"	.set	noreorder				\n"
+		"	.align	3					\n"
+		"1:	bnez	%0, 1b					\n"
+		"	dsubu	%0, 1					\n"
+		"	.set	reorder					\n"
+		: "=r" (loops)
+		: "0" (loops));
+	else if (sizeof(long) == 8 && DADDI_WAR)
+		__asm__ __volatile__ (
+		"	.set	noreorder				\n"
+		"	.align	3					\n"
+		"1:	bnez	%0, 1b					\n"
+		"	dsubu	%0, %2					\n"
+		"	.set	reorder					\n"
+		: "=r" (loops)
+		: "0" (loops), "r" (1));
+}
+
+
+/*
+ * Division by multiplication: you don't have to worry about
+ * loss of precision.
+ *
+ * Use only for very small delays ( < 1 msec).  Should probably use a
+ * lookup table, really, as the multiplications take much too long with
+ * short delays.  This is a "reasonable" implementation, though (and the
+ * first constant multiplications gets optimized away if the delay is
+ * a constant)
+ */
+
+static inline void __udelay(unsigned long usecs, unsigned long lpj)
+{
+	unsigned long hi, lo;
+
+	/*
+	 * The rates of 128 is rounded wrongly by the catchall case
+	 * for 64-bit.  Excessive precission?  Probably ...
+	 */
+#if defined(CONFIG_64BIT) && (HZ == 128)
+	usecs *= 0x0008637bd05af6c7UL;		/* 2**64 / (1000000 / HZ) */
+#elif defined(CONFIG_64BIT)
+	usecs *= (0x8000000000000000UL / (500000 / HZ));
+#else /* 32-bit junk follows here */
+	usecs *= (unsigned long) (((0x8000000000000000ULL / (500000 / HZ)) +
+	                           0x80000000ULL) >> 32);
+#endif
+
+	if (sizeof(long) == 4)
+		__asm__("multu\t%2, %3"
+		: "=h" (usecs), "=l" (lo)
+		: "r" (usecs), "r" (lpj)
+		: GCC_REG_ACCUM);
+	else if (sizeof(long) == 8 && !R4000_WAR)
+		__asm__("dmultu\t%2, %3"
+		: "=h" (usecs), "=l" (lo)
+		: "r" (usecs), "r" (lpj)
+		: GCC_REG_ACCUM);
+	else if (sizeof(long) == 8 && R4000_WAR)
+		__asm__("dmultu\t%3, %4\n\tmfhi\t%0"
+		: "=r" (usecs), "=h" (hi), "=l" (lo)
+		: "r" (usecs), "r" (lpj)
+		: GCC_REG_ACCUM);
+
+	__delay(usecs);
+}
+
+#define __udelay_val cpu_data[raw_smp_processor_id()].udelay_val
+
+#define udelay(usecs) __udelay((usecs), __udelay_val)
+
+/* make sure "usecs *= ..." in udelay do not overflow. */
+#if HZ >= 1000
+#define MAX_UDELAY_MS	1
+#elif HZ <= 200
+#define MAX_UDELAY_MS	5
+#else
+#define MAX_UDELAY_MS	(1000 / HZ)
+#endif
+
+#endif /* _ASM_DELAY_H */
