commit 9321f1aaf63e74ec3884347490e4ebb039f01b6e
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Fri Jul 10 15:34:41 2020 -0700

    mips: Remove compiler check in unroll macro
    
    CONFIG_CC_IS_GCC is undefined when Clang is used, which breaks the build
    (see our Travis link below).
    
    Clang 8 was chosen as a minimum version for this check because there
    were some improvements around __builtin_constant_p in that release. In
    reality, MIPS was not even buildable until clang 9 so that check was not
    technically necessary. Just remove all compiler checks and just assume
    that we have a working compiler.
    
    Fixes: d4e60453266b ("Restore gcc check in mips asm/unroll.h")
    Link: https://travis-ci.com/github/ClangBuiltLinux/continuous-integration/jobs/359642821
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/include/asm/unroll.h b/arch/mips/include/asm/unroll.h
index 49009319ac2c..7dd4a80e05d6 100644
--- a/arch/mips/include/asm/unroll.h
+++ b/arch/mips/include/asm/unroll.h
@@ -25,9 +25,7 @@
 	 * generate reasonable code for the switch statement,	\
 	 * so we skip the sanity check for those compilers.	\
 	 */							\
-	BUILD_BUG_ON((CONFIG_CC_IS_GCC ||			\
-		      CONFIG_CLANG_VERSION >= 80000) &&		\
-		     !__builtin_constant_p(times));		\
+	BUILD_BUG_ON(!__builtin_constant_p(times));		\
 								\
 	switch (times) {					\
 	case 32: fn(__VA_ARGS__); /* fall through */		\

commit d4e60453266b95b9dc19e0af2a819617e556bc4e
Author: Cesar Eduardo Barros <cesarb@cesarb.eti.br>
Date:   Thu Jul 9 19:11:02 2020 -0300

    Restore gcc check in mips asm/unroll.h
    
    While raising the gcc version requirement to 4.9, the compile-time check
    in the unroll macro was accidentally changed from being used on gcc and
    clang to being used on clang only.
    
    Restore the gcc check, changing it from "gcc >= 4.7" to "all gcc".
    
    [ We should probably remove this all entirely: if we remove the check
      for CLANG, then the check for GCC can go away. Older versions of clang
      are not really appropriate or supported for kernel builds - Linus ]
    
    Fixes: 6ec4476ac825 ("Raise gcc version requirement to 4.9")
    Signed-off-by: Cesar Eduardo Barros <cesarb@cesarb.eti.br>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/include/asm/unroll.h b/arch/mips/include/asm/unroll.h
index 8ed660adc84f..49009319ac2c 100644
--- a/arch/mips/include/asm/unroll.h
+++ b/arch/mips/include/asm/unroll.h
@@ -25,7 +25,8 @@
 	 * generate reasonable code for the switch statement,	\
 	 * so we skip the sanity check for those compilers.	\
 	 */							\
-	BUILD_BUG_ON((CONFIG_CLANG_VERSION >= 80000) &&		\
+	BUILD_BUG_ON((CONFIG_CC_IS_GCC ||			\
+		      CONFIG_CLANG_VERSION >= 80000) &&		\
 		     !__builtin_constant_p(times));		\
 								\
 	switch (times) {					\

commit 6ec4476ac82512f09c94aff5972654b70f3772b2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 8 10:48:35 2020 -0700

    Raise gcc version requirement to 4.9
    
    I realize that we fairly recently raised it to 4.8, but the fact is, 4.9
    is a much better minimum version to target.
    
    We have a number of workarounds for actual bugs in pre-4.9 gcc versions
    (including things like internal compiler errors on ARM), but we also
    have some syntactic workarounds for lacking features.
    
    In particular, raising the minimum to 4.9 means that we can now just
    assume _Generic() exists, which is likely the much better replacement
    for a lot of very convoluted built-time magic with conditionals on
    sizeof and/or __builtin_choose_expr() with same_type() etc.
    
    Using _Generic also means that you will need to have a very recent
    version of 'sparse', but thats easy to build yourself, and much less of
    a hassle than some old gcc version can be.
    
    The latest (in a long string) of reasons for minimum compiler version
    upgrades was commit 5435f73d5c4a ("efi/x86: Fix build with gcc 4").
    
    Ard points out that RHEL 7 uses gcc-4.8, but the people who stay back on
    old RHEL versions persumably also don't build their own kernels anyway.
    And maybe they should cross-built or just have a little side affair with
    a newer compiler?
    
    Acked-by: Ard Biesheuvel <ardb@kernel.org>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/include/asm/unroll.h b/arch/mips/include/asm/unroll.h
index c628747d4ecd..8ed660adc84f 100644
--- a/arch/mips/include/asm/unroll.h
+++ b/arch/mips/include/asm/unroll.h
@@ -19,14 +19,13 @@
 								\
 	/*							\
 	 * We can't unroll if the number of iterations isn't	\
-	 * compile-time constant. Unfortunately GCC versions	\
-	 * up until 4.6 tend to miss obvious constants & cause	\
+	 * compile-time constant. Unfortunately clang versions	\
+	 * up until 8.0 tend to miss obvious constants & cause	\
 	 * this check to fail, even though they go on to	\
 	 * generate reasonable code for the switch statement,	\
 	 * so we skip the sanity check for those compilers.	\
 	 */							\
-	BUILD_BUG_ON((CONFIG_GCC_VERSION >= 40700 ||		\
-		      CONFIG_CLANG_VERSION >= 80000) &&		\
+	BUILD_BUG_ON((CONFIG_CLANG_VERSION >= 80000) &&		\
 		     !__builtin_constant_p(times));		\
 								\
 	switch (times) {					\

commit df3da04880b45b059b8b064c2dd67289a793109e
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Thu Oct 10 13:31:59 2019 -0700

    mips: Fix unroll macro when building with Clang
    
    Building with Clang errors after commit 6baaeadae911 ("MIPS: Provide
    unroll() macro, use it for cache ops") since the GCC_VERSION macro
    is defined in include/linux/compiler-gcc.h, which is only included
    in compiler.h when using GCC:
    
    In file included from arch/mips/kernel/mips-mt.c:20:
    ./arch/mips/include/asm/r4kcache.h:254:1: error: use of undeclared
    identifier 'GCC_VERSION'; did you mean 'S_VERSION'?
    __BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 32,
    )
    ^
    ./arch/mips/include/asm/r4kcache.h:219:4: note: expanded from macro
    '__BUILD_BLAST_CACHE'
                            cache_unroll(32, kernel_cache, indexop,
                            ^
    ./arch/mips/include/asm/r4kcache.h:203:2: note: expanded from macro
    'cache_unroll'
            unroll(times, _cache_op, insn, op, (addr) + (i++ * (lsize)));
            ^
    ./arch/mips/include/asm/unroll.h:28:15: note: expanded from macro
    'unroll'
            BUILD_BUG_ON(GCC_VERSION >= 40700 &&                    \
                         ^
    
    Use CONFIG_GCC_VERSION, which will always be set by Kconfig.
    Additionally, Clang 8 had improvements around __builtin_constant_p so
    use that as a lower limit for this check with Clang (although MIPS
    wasn't buildable until Clang 9); building a kernel with Clang 9.0.0
    has no issues after this change.
    
    Fixes: 6baaeadae911 ("MIPS: Provide unroll() macro, use it for cache ops")
    Link: https://github.com/ClangBuiltLinux/linux/issues/736
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Cc: clang-built-linux@googlegroups.com
    Cc: Nick Desaulniers <ndesaulniers@google.com>

diff --git a/arch/mips/include/asm/unroll.h b/arch/mips/include/asm/unroll.h
index df1cdcfc5a47..c628747d4ecd 100644
--- a/arch/mips/include/asm/unroll.h
+++ b/arch/mips/include/asm/unroll.h
@@ -25,7 +25,8 @@
 	 * generate reasonable code for the switch statement,	\
 	 * so we skip the sanity check for those compilers.	\
 	 */							\
-	BUILD_BUG_ON(GCC_VERSION >= 40700 &&			\
+	BUILD_BUG_ON((CONFIG_GCC_VERSION >= 40700 ||		\
+		      CONFIG_CLANG_VERSION >= 80000) &&		\
 		     !__builtin_constant_p(times));		\
 								\
 	switch (times) {					\

commit 6baaeadae911ba9cedfead881f3bf305a18fd011
Author: Paul Burton <paul.burton@mips.com>
Date:   Tue Oct 8 18:22:00 2019 +0000

    MIPS: Provide unroll() macro, use it for cache ops
    
    Currently we have a lot of duplication in asm/r4kcache.h to handle
    manually unrolling loops of cache ops for various line sizes, and we
    have to explicitly handle the difference in cache op immediate width
    between MIPSr6 & earlier ISA revisions with further duplication.
    
    Introduce an unroll() macro in asm/unroll.h which expands to a switch
    statement which is used to call a function or expand a preprocessor
    macro a compile-time constant number of times in a row - effectively
    explicitly unrolling a loop. We make use of this here to remove the
    cache op duplication & will use it further in later patches.
    
    A nice side effect of this is that calculating the cache op offset
    immediate is now the compiler's responsibility, so we're no longer
    sensitive to the width change of that immediate in MIPSr6 & will be
    similarly agnostic to immediate width in any future supported ISA.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: linux-mips@vger.kernel.org

diff --git a/arch/mips/include/asm/unroll.h b/arch/mips/include/asm/unroll.h
new file mode 100644
index 000000000000..df1cdcfc5a47
--- /dev/null
+++ b/arch/mips/include/asm/unroll.h
@@ -0,0 +1,76 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+#ifndef __ASM_UNROLL_H__
+#define __ASM_UNROLL_H__
+
+/*
+ * Explicitly unroll a loop, for use in cases where doing so is performance
+ * critical.
+ *
+ * Ideally we'd rely upon the compiler to provide this but there's no commonly
+ * available means to do so. For example GCC's "#pragma GCC unroll"
+ * functionality would be ideal but is only available from GCC 8 onwards. Using
+ * -funroll-loops is an option but GCC tends to make poor choices when
+ * compiling our string functions. -funroll-all-loops leads to massive code
+ * bloat, even if only applied to the string functions.
+ */
+#define unroll(times, fn, ...) do {				\
+	extern void bad_unroll(void)				\
+		__compiletime_error("Unsupported unroll");	\
+								\
+	/*							\
+	 * We can't unroll if the number of iterations isn't	\
+	 * compile-time constant. Unfortunately GCC versions	\
+	 * up until 4.6 tend to miss obvious constants & cause	\
+	 * this check to fail, even though they go on to	\
+	 * generate reasonable code for the switch statement,	\
+	 * so we skip the sanity check for those compilers.	\
+	 */							\
+	BUILD_BUG_ON(GCC_VERSION >= 40700 &&			\
+		     !__builtin_constant_p(times));		\
+								\
+	switch (times) {					\
+	case 32: fn(__VA_ARGS__); /* fall through */		\
+	case 31: fn(__VA_ARGS__); /* fall through */		\
+	case 30: fn(__VA_ARGS__); /* fall through */		\
+	case 29: fn(__VA_ARGS__); /* fall through */		\
+	case 28: fn(__VA_ARGS__); /* fall through */		\
+	case 27: fn(__VA_ARGS__); /* fall through */		\
+	case 26: fn(__VA_ARGS__); /* fall through */		\
+	case 25: fn(__VA_ARGS__); /* fall through */		\
+	case 24: fn(__VA_ARGS__); /* fall through */		\
+	case 23: fn(__VA_ARGS__); /* fall through */		\
+	case 22: fn(__VA_ARGS__); /* fall through */		\
+	case 21: fn(__VA_ARGS__); /* fall through */		\
+	case 20: fn(__VA_ARGS__); /* fall through */		\
+	case 19: fn(__VA_ARGS__); /* fall through */		\
+	case 18: fn(__VA_ARGS__); /* fall through */		\
+	case 17: fn(__VA_ARGS__); /* fall through */		\
+	case 16: fn(__VA_ARGS__); /* fall through */		\
+	case 15: fn(__VA_ARGS__); /* fall through */		\
+	case 14: fn(__VA_ARGS__); /* fall through */		\
+	case 13: fn(__VA_ARGS__); /* fall through */		\
+	case 12: fn(__VA_ARGS__); /* fall through */		\
+	case 11: fn(__VA_ARGS__); /* fall through */		\
+	case 10: fn(__VA_ARGS__); /* fall through */		\
+	case 9: fn(__VA_ARGS__); /* fall through */		\
+	case 8: fn(__VA_ARGS__); /* fall through */		\
+	case 7: fn(__VA_ARGS__); /* fall through */		\
+	case 6: fn(__VA_ARGS__); /* fall through */		\
+	case 5: fn(__VA_ARGS__); /* fall through */		\
+	case 4: fn(__VA_ARGS__); /* fall through */		\
+	case 3: fn(__VA_ARGS__); /* fall through */		\
+	case 2: fn(__VA_ARGS__); /* fall through */		\
+	case 1: fn(__VA_ARGS__); /* fall through */		\
+	case 0: break;						\
+								\
+	default:						\
+		/*						\
+		 * Either the iteration count is unreasonable	\
+		 * or we need to add more cases above.		\
+		 */						\
+		bad_unroll();					\
+		break;						\
+	}							\
+} while (0)
+
+#endif /* __ASM_UNROLL_H__ */
