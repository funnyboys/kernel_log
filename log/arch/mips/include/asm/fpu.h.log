commit ab7c01fdc3cfe02256e777a36366b70e2a539c27
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Thu May 21 17:07:14 2020 +0300

    mips: Add MIPS Release 5 support
    
    There are five MIPS32/64 architecture releases currently available:
    from 1 to 6 except fourth one, which was intentionally skipped.
    Three of them can be called as major: 1st, 2nd and 6th, that not only
    have some system level alterations, but also introduced significant
    core/ISA level updates. The rest of the MIPS architecture releases are
    minor.
    
    Even though they don't have as much ISA/system/core level changes
    as the major ones with respect to the previous releases, they still
    provide a set of updates (I'd say they were intended to be the
    intermediate releases before a major one) that might be useful for the
    kernel and user-level code, when activated by the kernel or compiler.
    In particular the following features were introduced or ended up being
    available at/after MIPS32/64 Release 5 architecture:
    + the last release of the misaligned memory access instructions,
    + virtualisation - VZ ASE - is optional component of the arch,
    + SIMD - MSA ASE - is optional component of the arch,
    + DSP ASE is optional component of the arch,
    + CP0.Status.FR=1 for CP1.FIR.F64=1 (pure 64-bit FPU general registers)
      must be available if FPU is implemented,
    + CP1.FIR.Has2008 support is required so CP1.FCSR.{ABS2008,NAN2008} bits
      are available.
    + UFR/UNFR aliases to access CP0.Status.FR from user-space by means of
      ctc1/cfc1 instructions (enabled by CP0.Config5.UFR),
    + CP0.COnfig5.LLB=1 and eretnc instruction are implemented to without
      accidentally clearing LL-bit when returning from an interrupt,
      exception, or error trap,
    + XPA feature together with extended versions of CPx registers is
      introduced, which needs to have mfhc0/mthc0 instructions available.
    
    So due to these changes GNU GCC provides an extended instructions set
    support for MIPS32/64 Release 5 by default like eretnc/mfhc0/mthc0. Even
    though the architecture alteration isn't that big, it still worth to be
    taken into account by the kernel software. Finally we can't deny that
    some optimization/limitations might be found in future and implemented
    on some level in kernel or compiler. In this case having even
    intermediate MIPS architecture releases support would be more than
    useful.
    
    So the most of the changes provided by this commit can be split into
    either compile- or runtime configs related. The compile-time related
    changes are caused by adding the new CONFIG_CPU_MIPS32_R5/CONFIG_CPU_MIPSR5
    configs and concern the code activating MIPSR2 or MIPSR6 already
    implemented features (like eretnc/LLbit, mthc0/mfhc0). In addition
    CPU_HAS_MSA can be now freely enabled for MIPS32/64 release 5 based
    platforms as this is done for CPU_MIPS32_R6 CPUs. The runtime changes
    concerns the features which are handled with respect to the MIPS ISA
    revision detected at run-time by means of CP0.Config.{AT,AR} bits. Alas
    these fields can be used to detect either r1 or r2 or r6 releases.
    But since we know which CPUs in fact support the R5 arch, we can manually
    set MIPS_CPU_ISA_M32R5/MIPS_CPU_ISA_M64R5 bit of c->isa_level and then
    use cpu_has_mips32r5/cpu_has_mips64r5 where it's appropriate.
    
    Since XPA/EVA provide too complex alterationss and to have them used with
    MIPS32 Release 2 charged kernels (for compatibility with current platform
    configs) they are left to be setup as a separate kernel configs.
    
    Co-developed-by: Alexey Malahov <Alexey.Malahov@baikalelectronics.ru>
    Signed-off-by: Alexey Malahov <Alexey.Malahov@baikalelectronics.ru>
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Paul Burton <paulburton@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index a9d5123e2a2a..08f9dd6903b7 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -71,8 +71,8 @@ static inline int __enable_fpu(enum fpu_mode mode)
 		goto fr_common;
 
 	case FPU_64BIT:
-#if !(defined(CONFIG_CPU_MIPSR2) || defined(CONFIG_CPU_MIPSR6) \
-      || defined(CONFIG_64BIT))
+#if !(defined(CONFIG_CPU_MIPSR2) || defined(CONFIG_CPU_MIPSR5) || \
+      defined(CONFIG_CPU_MIPSR6) || defined(CONFIG_64BIT))
 		/* we only have a 32-bit FPU */
 		return SIGFPE;
 #endif

commit c9b0299034665d594e56ee343f28033d1b24de6d
Author: Liangliang Huang <huanglllzu@gmail.com>
Date:   Mon May 4 16:51:29 2020 +0800

    MIPS: Use fallthrough for arch/mips
    
    Convert the various /* fallthrough */ comments to the pseudo-keyword
    fallthrough;
    
    Done via script:
    https://lore.kernel.org/lkml/b56602fcf79f849e733e7b521bb0e17895d390fa.1582230379.git.joe@perches.com/
    
    Signed-off-by: Liangliang Huang <huangll@lemote.com>
    Reviewed-by: Huacai Chen <chenhc@lemote.com>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 9476e0498d59..a9d5123e2a2a 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -76,7 +76,7 @@ static inline int __enable_fpu(enum fpu_mode mode)
 		/* we only have a 32-bit FPU */
 		return SIGFPE;
 #endif
-		/* fall through */
+		fallthrough;
 	case FPU_32BIT:
 		if (cpu_has_fre) {
 			/* clear FRE */

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 42bc2bbbd3d7..9476e0498d59 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -1,11 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Copyright (C) 2002 MontaVista Software Inc.
  * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
  */
 #ifndef _ASM_FPU_H
 #define _ASM_FPU_H

commit 9ec55930e023a18dfc7cca60afdd8c9f9da54f3e
Author: Paul Burton <paul.burton@mips.com>
Date:   Wed Nov 7 23:14:04 2018 +0000

    MIPS: Stub asm/fpu.h functions
    
    Provide stub versions of functions in asm/fpu.h when
    CONFIG_MIPS_FP_SUPPORT=n. Two approaches are taken to the functions
    provided:
    
      - Functions which can safely be called when FP is not enabled provide
        stubs which return an error where appropriate or are simple no-ops.
    
      - Functions which should only ever be called in cases where
        cpu_has_fpu is true or the FPU was successfully enabled are declared
        extern & annotated with __compiletime_error() to detect cases in
        which they are called incorrectly.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Patchwork: https://patchwork.linux-mips.org/patch/21006/
    Cc: linux-mips@linux-mips.org

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 2a631adb1fa8..42bc2bbbd3d7 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -30,9 +30,6 @@
 #include <asm/mips_mt.h>
 #endif
 
-extern void _save_fp(struct task_struct *);
-extern void _restore_fp(struct task_struct *);
-
 /*
  * This enum specifies a mode in which we want the FPU to operate, for cores
  * which implement the Status.FR bit. Note that the bottom bit of the value
@@ -47,6 +44,11 @@ enum fpu_mode {
 #define FPU_FR_MASK		0x1
 };
 
+#ifdef CONFIG_MIPS_FP_SUPPORT
+
+extern void _save_fp(struct task_struct *);
+extern void _restore_fp(struct task_struct *);
+
 #define __disable_fpu()							\
 do {									\
 	clear_c0_status(ST0_CU1);					\
@@ -250,4 +252,81 @@ static inline union fpureg *get_fpu_regs(struct task_struct *tsk)
 	return tsk->thread.fpu.fpr;
 }
 
+#else /* !CONFIG_MIPS_FP_SUPPORT */
+
+/*
+ * When FP support is disabled we provide only a minimal set of stub functions
+ * to avoid callers needing to care too much about CONFIG_MIPS_FP_SUPPORT.
+ */
+
+static inline int __enable_fpu(enum fpu_mode mode)
+{
+	return SIGILL;
+}
+
+static inline void __disable_fpu(void)
+{
+	/* no-op */
+}
+
+
+static inline int is_fpu_owner(void)
+{
+	return 0;
+}
+
+static inline void clear_fpu_owner(void)
+{
+	/* no-op */
+}
+
+static inline int own_fpu_inatomic(int restore)
+{
+	return SIGILL;
+}
+
+static inline int own_fpu(int restore)
+{
+	return SIGILL;
+}
+
+static inline void lose_fpu_inatomic(int save, struct task_struct *tsk)
+{
+	/* no-op */
+}
+
+static inline void lose_fpu(int save)
+{
+	/* no-op */
+}
+
+static inline bool init_fp_ctx(struct task_struct *target)
+{
+	return false;
+}
+
+/*
+ * The following functions should only be called in paths where we know that FP
+ * support is enabled, typically a path where own_fpu() or __enable_fpu() have
+ * returned successfully. When CONFIG_MIPS_FP_SUPPORT=n it is known at compile
+ * time that this should never happen, so calls to these functions should be
+ * optimized away & never actually be emitted.
+ */
+
+extern void save_fp(struct task_struct *tsk)
+	__compiletime_error("save_fp() should not be called when CONFIG_MIPS_FP_SUPPORT=n");
+
+extern void _save_fp(struct task_struct *)
+	__compiletime_error("_save_fp() should not be called when CONFIG_MIPS_FP_SUPPORT=n");
+
+extern void restore_fp(struct task_struct *tsk)
+	__compiletime_error("restore_fp() should not be called when CONFIG_MIPS_FP_SUPPORT=n");
+
+extern void _restore_fp(struct task_struct *)
+	__compiletime_error("_restore_fp() should not be called when CONFIG_MIPS_FP_SUPPORT=n");
+
+extern union fpureg *get_fpu_regs(struct task_struct *tsk)
+	__compiletime_error("get_fpu_regs() should not be called when CONFIG_MIPS_FP_SUPPORT=n");
+
+#endif /* !CONFIG_MIPS_FP_SUPPORT */
 #endif /* _ASM_FPU_H */

commit 7d3713a4aad2a00997f0df1bbafd5fdf926dc14d
Author: Paul Burton <paul.burton@mips.com>
Date:   Wed Nov 7 23:14:00 2018 +0000

    MIPS: Drop forward declarations of sigcontext in asm/fpu.h
    
    asm/fpu.h contains forward declarations of struct sigcontext & struct
    sigcontext32 which appear to have been unused since commit 137f6f3e284e
    ("MIPS: Cleanup signal code initialization"). Remove the dead code.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Patchwork: https://patchwork.linux-mips.org/patch/21015/
    Cc: linux-mips@linux-mips.org

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 84de64606ccf..2a631adb1fa8 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -30,9 +30,6 @@
 #include <asm/mips_mt.h>
 #endif
 
-struct sigcontext;
-struct sigcontext32;
-
 extern void _save_fp(struct task_struct *);
 extern void _restore_fp(struct task_struct *);
 

commit cc97ab235f3fe32401ca198cebe6f42642e95770
Author: Paul Burton <paul.burton@mips.com>
Date:   Wed Nov 7 23:13:59 2018 +0000

    MIPS: Simplify FP context initialization
    
    MIPS has up until now had 3 different ways for a task's floating point
    context to be initialized:
    
      - If the task's first use of FP involves it gaining ownership of an
        FPU then _init_fpu() is used to initialize the FPU's registers such
        that they all contain ~0, and the FPU registers will be stored to
        struct thread_info later (eg. when context switching).
    
      - If the task first uses FP on a CPU without an associated FPU then
        fpu_emulator_init_fpu() initializes the task's floating point
        register state in struct thread_info such that all floating point
        register contain the bit pattern 0x7ff800007ff80000, different to
        the _init_fpu() behaviour.
    
      - If a task's floating point context is first accessed via ptrace then
        init_fp_ctx() initializes the floating point register state in
        struct thread_info to ~0, giving equivalent state to _init_fpu().
    
    The _init_fpu() path has 2 separate implementations - one for r2k/r3k
    style systems & one for r4k style systems. The _init_fpu() path also
    requires that we be careful to clear & restore the value of the
    Config5.FRE bit on modern systems in order to avoid inadvertently
    triggering floating point exceptions.
    
    None of this code is in a performance critical hot path - it runs only
    the first time a task uses floating point. As such it doesn't seem to
    warrant the complications of maintaining the _init_fpu() path.
    
    Remove _init_fpu() & fpu_emulator_init_fpu(), instead using
    init_fp_ctx() consistently to initialize floating point register state
    in struct thread_info. Upon a task's first use of floating point this
    will typically mean that we initialize state in memory & then load it
    into FPU registers using _restore_fp() just as we would on a context
    switch. For other paths such as __compute_return_epc_for_insn() or
    mipsr2_decoder() this results in a significant simplification of the
    work to be done.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Patchwork: https://patchwork.linux-mips.org/patch/21002/
    Cc: linux-mips@linux-mips.org

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index a2813fe381cf..84de64606ccf 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -33,7 +33,6 @@
 struct sigcontext;
 struct sigcontext32;
 
-extern void _init_fpu(unsigned int);
 extern void _save_fp(struct task_struct *);
 extern void _restore_fp(struct task_struct *);
 
@@ -198,42 +197,36 @@ static inline void lose_fpu(int save)
 	preempt_enable();
 }
 
-static inline int init_fpu(void)
+/**
+ * init_fp_ctx() - Initialize task FP context
+ * @target: The task whose FP context should be initialized.
+ *
+ * Initializes the FP context of the target task to sane default values if that
+ * target task does not already have valid FP context. Once the context has
+ * been initialized, the task will be marked as having used FP & thus having
+ * valid FP context.
+ *
+ * Returns: true if context is initialized, else false.
+ */
+static inline bool init_fp_ctx(struct task_struct *target)
 {
-	unsigned int fcr31 = current->thread.fpu.fcr31;
-	int ret = 0;
-
-	if (cpu_has_fpu) {
-		unsigned int config5;
-
-		ret = __own_fpu();
-		if (ret)
-			return ret;
+	/* If FP has been used then the target already has context */
+	if (tsk_used_math(target))
+		return false;
 
-		if (!cpu_has_fre) {
-			_init_fpu(fcr31);
+	/* Begin with data registers set to all 1s... */
+	memset(&target->thread.fpu.fpr, ~0, sizeof(target->thread.fpu.fpr));
 
-			return 0;
-		}
-
-		/*
-		 * Ensure FRE is clear whilst running _init_fpu, since
-		 * single precision FP instructions are used. If FRE
-		 * was set then we'll just end up initialising all 32
-		 * 64b registers.
-		 */
-		config5 = clear_c0_config5(MIPS_CONF5_FRE);
-		enable_fpu_hazard();
+	/* FCSR has been preset by `mips_set_personality_nan'.  */
 
-		_init_fpu(fcr31);
+	/*
+	 * Record that the target has "used" math, such that the context
+	 * just initialised, and any modifications made by the caller,
+	 * aren't discarded.
+	 */
+	set_stopped_child_used_math(target);
 
-		/* Restore FRE */
-		write_c0_config5(config5);
-		enable_fpu_hazard();
-	} else
-		fpu_emulator_init_fpu();
-
-	return ret;
+	return true;
 }
 
 static inline void save_fp(struct task_struct *tsk)

commit 977674c06b189dd54729a91331c05761688ad064
Merge: 4691f4a6d4aa db8466c581cc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 6 13:16:34 2017 -0700

    Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus
    
    Pull MIPS fixes from Ralf Baechle:
     "Lantiq:
        - Fix adding xbar resoures causing a panic
    
      Loongson3:
        - Some Loongson 3A don't identify themselves as having an FTLB so
          hardwire that knowledge into CPU probing.
        - Handle Loongson 3 TLB peculiarities in the fast path of the RDHWR
          emulation.
        - Fix invalid FTLB entries with huge page on VTLB+FTLB platforms
        - Add missing calculation of S-cache and V-cache cache-way size
    
      Ralink:
        - Fix typos in rt3883 pinctrl data
    
      Generic:
        - Force o32 fp64 support on 32bit MIPS64r6 kernels
        - Yet another build fix after the linux/sched.h changes
        - Wire up statx system call
        - Fix stack unwinding after introduction of IRQ stack
        - Fix spinlock code to build even for microMIPS with recent binutils
    
      SMP-CPS:
        - Fix retrieval of VPE mask on big endian CPUs"
    
    * 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus:
      MIPS: IRQ Stack: Unwind IRQ stack onto task stack
      MIPS: c-r4k: Fix Loongson-3's vcache/scache waysize calculation
      MIPS: Flush wrong invalid FTLB entry for huge page
      MIPS: Check TLB before handle_ri_rdhwr() for Loongson-3
      MIPS: Add MIPS_CPU_FTLB for Loongson-3A R2
      MIPS: Lantiq: fix missing xbar kernel panic
      MIPS: smp-cps: Fix retrieval of VPE mask on big endian CPUs
      MIPS: Wire up statx system call
      MIPS: Include asm/ptrace.h now linux/sched.h doesn't
      MIPS: ralink: Fix typos in rt3883 pinctrl
      MIPS: End spinlocks with .insn
      MIPS: Force o32 fp64 support on 32bit MIPS64r6 kernels

commit 0c7e2bc87ea6c2eb6f369998f74a0278e64863e4
Author: James Hogan <james.hogan@imgtec.com>
Date:   Sat Mar 4 00:32:03 2017 +0000

    MIPS: Include asm/ptrace.h now linux/sched.h doesn't
    
    Use of the task_pt_regs() based macros in MIPS' asm/processor.h for
    accessing the user context on the kernel stack need the definition of
    struct pt_regs from asm/ptrace.h. __own_fpu() in asm/fpu.h uses these
    macros but implicitly depended on linux/sched.h to include asm/ptrace.h.
    
    Since commit f780d89a0e82 ("sched/headers: Remove <asm/ptrace.h> from
    <linux/sched.h>") however linux/sched.h no longer includes asm/ptrace.h,
    so include it explicitly from asm/fpu.h where it is needed instead.
    
    This fixes build errors such as:
    
    ./arch/mips/include/asm/fpu.h: In function '__own_fpu':
    ./arch/mips/include/asm/processor.h:385:31: error: invalid application of 'sizeof' to incomplete type 'struct pt_regs'
         THREAD_SIZE - 32 - sizeof(struct pt_regs))
                                   ^
    
    Fixes: f780d89a0e82 ("sched/headers: Remove <asm/ptrace.h> from <linux/sched.h>")
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/15386/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 321752bcbab6..1527efaf4af4 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -20,6 +20,7 @@
 #include <asm/cpu-features.h>
 #include <asm/fpu_emulator.h>
 #include <asm/hazards.h>
+#include <asm/ptrace.h>
 #include <asm/processor.h>
 #include <asm/current.h>
 #include <asm/msa.h>

commit fc69910f329d61821897871e0e957eda39beb3d8
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Mar 8 08:29:31 2017 +0100

    MIPS: Add missing include files
    
    After the split of linux/sched.h, several platforms in arch/mips stopped building.
    
    Add the respective additional #include statements to fix the problem I first
    tried adding these into asm/processor.h, but ran into circular header
    dependencies with that which I could not figure out.
    
    The commit I listed as causing the problem is the branch merge, as there is
    likely a combination of multiple patches in that branch.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-mips@linux-mips.org
    Cc: ralf@linux-mips.org
    Fixes: 1827adb11ad2 ("Merge branch 'WIP.sched-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip")
    Link: http://lkml.kernel.org/r/20170308072931.3836696-1-arnd@arndb.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 321752bcbab6..f94455f964ec 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -12,6 +12,7 @@
 
 #include <linux/sched.h>
 #include <linux/sched/task_stack.h>
+#include <linux/ptrace.h>
 #include <linux/thread_info.h>
 #include <linux/bitops.h>
 

commit 68db0cf10678630d286f4bbbbdfa102951a35faa
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 8 18:51:37 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <linux/sched/task_stack.h>
    
    We are going to split <linux/sched/task_stack.h> out of <linux/sched.h>, which
    will have to be picked up from other headers and a couple of .c files.
    
    Create a trivial placeholder <linux/sched/task_stack.h> file that just
    maps to <linux/sched.h> to make this patch obviously correct and
    bisectable.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index f06f97bd62df..321752bcbab6 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -11,6 +11,7 @@
 #define _ASM_FPU_H
 
 #include <linux/sched.h>
+#include <linux/sched/task_stack.h>
 #include <linux/thread_info.h>
 #include <linux/bitops.h>
 

commit 00fe56dca6a845d5f10ef0398eef26e559e8f98c
Author: James Hogan <james.hogan@imgtec.com>
Date:   Mon Feb 1 13:50:37 2016 +0000

    MIPS: Fix FPU disable with preemption
    
    The FPU should not be left enabled after a task context switch. This
    isn't usually a problem as the FPU enable bit is updated before
    returning to userland, however it can potentially mask kernel bugs, and
    in fact KVM assumes it won't happen and won't clear the FPU enable bit
    before returning to the guest, which allows the guest to use stale FPU
    context.
    
    Interrupts and exceptions save and restore most bits of the CP0 Status
    register which contains the FPU enable bit (CU1). When the kernel needs
    to enable or disable the FPU (for example due to attempted FPU use by
    userland, or the scheduler being invoked) both the actual Status
    register and the saved value in the userland context are updated.
    
    However this doesn't work correctly with full kernel preemption enabled,
    since the FPU enable bit can be cleared from within an interrupt when
    the scheduler is invoked, and only the userland context is updated, not
    the interrupt context.
    
    For example:
    1) Enter kernel with FPU already enabled, TIF_USEDFPU=1, Status.CU1=1
       saved.
    2) Take a timer interrupt while in kernel mode, Status.CU1=1 saved.
    3) Timer interrupt invokes scheduler to preempt the task, which clears
       TIF_USEDFPU, disables the FPU in Status register (Status.CU1=0), and
       the value stored in user context from step (1), but not the interrupt
       context from step (2).
    4) When the process is scheduled back in again Status.CU1=0.
    5) The interrupt context from step (2) is restored, which sets
       Status.CU1=1. So from user context point of view, preemption has
       re-enabled FPU!
    6) If the scheduler is invoked again (via preemption or voluntarily)
       before returning to userland, TIF_USEDFPU=0 so the FPU is not
       disabled before the task context switch.
    7) The next task resumes from the context switch with FPU enabled!
    
    The restoring of the Status register on return from interrupt/exception
    is already selective about which bits to restore, leaving the interrupt
    mask bits alone so enabling/disabling of CPU interrupt lines can
    persist. Extend this to also leave both the CU1 bit (FPU enable) and the
    FR bit (which specifies the FPU mode and gets changed with CU1). This
    prevents a stale Status value being restored in step (5) above and
    persisting through subsequent context switches.
    
    Also switch to the use of definitions from asm/mipsregs.h while we're at
    it.
    
    Since this change also affects the restoration of Status register on the
    path back to userland, it increases the sensitivity of the kernel to the
    problem of the FPU being left enabled, allowing it to propagate to
    userland, therefore a warning is also added to lose_fpu_inatomic() to
    point out any future reoccurances before they do any damage.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Reviewed-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/12303/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 9cbf383b8834..f06f97bd62df 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -179,6 +179,10 @@ static inline void lose_fpu_inatomic(int save, struct task_struct *tsk)
 		if (save)
 			_save_fp(tsk);
 		__disable_fpu();
+	} else {
+		/* FPU should not have been left enabled with no owner */
+		WARN(read_c0_status() & ST0_CU1,
+		     "Orphaned FPU left enabled");
 	}
 	KSTK_STATUS(tsk) &= ~ST0_CU1;
 	clear_tsk_thread_flag(tsk, TIF_USEDFPU);

commit 1a3d59579b9f436da038f377309cf2270c76318e
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Mon Aug 3 08:49:30 2015 -0700

    MIPS: Tidy up FPU context switching
    
    Rather than saving the scalar FP or vector context in the assembly
    resume function, reuse the existing C code we have in fpu.h to do
    exactly that. This reduces duplication, results in a much easier to read
    resume function & should allow the compiler to optimise out more MSA
    code due to is_msa_enabled()/cpu_has_msa being known-zero at compile
    time for kernels without MSA support.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Cc: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: linux-kernel@vger.kernel.org
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Markos Chandras <markos.chandras@imgtec.com>
    Cc: Manuel Lauss <manuel.lauss@gmail.com>
    Patchwork: https://patchwork.linux-mips.org/patch/10830/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 1b0625189835..9cbf383b8834 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -164,25 +164,30 @@ static inline int own_fpu(int restore)
 	return ret;
 }
 
-static inline void lose_fpu(int save)
+static inline void lose_fpu_inatomic(int save, struct task_struct *tsk)
 {
-	preempt_disable();
 	if (is_msa_enabled()) {
 		if (save) {
-			save_msa(current);
-			current->thread.fpu.fcr31 =
+			save_msa(tsk);
+			tsk->thread.fpu.fcr31 =
 					read_32bit_cp1_register(CP1_STATUS);
 		}
 		disable_msa();
-		clear_thread_flag(TIF_USEDMSA);
+		clear_tsk_thread_flag(tsk, TIF_USEDMSA);
 		__disable_fpu();
 	} else if (is_fpu_owner()) {
 		if (save)
-			_save_fp(current);
+			_save_fp(tsk);
 		__disable_fpu();
 	}
-	KSTK_STATUS(current) &= ~ST0_CU1;
-	clear_thread_flag(TIF_USEDFPU);
+	KSTK_STATUS(tsk) &= ~ST0_CU1;
+	clear_tsk_thread_flag(tsk, TIF_USEDFPU);
+}
+
+static inline void lose_fpu(int save)
+{
+	preempt_disable();
+	lose_fpu_inatomic(save, current);
 	preempt_enable();
 }
 

commit fcc53b5f6c38acbf5d311ffc3e0da517491c6f7b
Author: Markos Chandras <markos.chandras@imgtec.com>
Date:   Thu Jul 16 15:30:04 2015 +0100

    MIPS: fpu.h: Allow 64-bit FPU on a 64-bit MIPS R6 CPU
    
    Commit 6134d94923d0 ("MIPS: asm: fpu: Allow 64-bit FPU on MIPS32 R6")
    added support for 64-bit FPU on a 32-bit MIPS R6 processor but it missed
    the 64-bit CPU case leading to FPU failures when requesting FR=1 mode
    (which is always the case for MIPS R6 userland) when running a 32-bit
    kernel on a 64-bit CPU. We also fix the MIPS R2 case.
    
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>
    Fixes: 6134d94923d0 ("MIPS: asm: fpu: Allow 64-bit FPU on MIPS32 R6")
    Reviewed-by: Paul Burton <paul.burton@imgtec.com>
    Cc: <stable@vger.kernel.org> # 4.0+
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/10734/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 084780b355aa..1b0625189835 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -74,7 +74,7 @@ static inline int __enable_fpu(enum fpu_mode mode)
 		goto fr_common;
 
 	case FPU_64BIT:
-#if !(defined(CONFIG_CPU_MIPS32_R2) || defined(CONFIG_CPU_MIPS32_R6) \
+#if !(defined(CONFIG_CPU_MIPSR2) || defined(CONFIG_CPU_MIPSR6) \
       || defined(CONFIG_64BIT))
 		/* we only have a 32-bit FPU */
 		return SIGFPE;

commit 98b0429b7abd5c05efdb23f3eba02ec3f696748e
Merge: 3cf295434132 1f3a2c6e229c
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Apr 13 16:01:37 2015 +0200

    Merge branch '4.1-fp' into mips-for-linux-next

commit 9b26616c8d9dae53fbac7f7cb2c6dd1308102976
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Fri Apr 3 23:27:48 2015 +0100

    MIPS: Respect the ISA level in FCSR handling
    
    Define the central place the default FCSR value is set from, initialised
    in `cpu_probe'.  Determine the FCSR mask applied to values written to
    the register with CTC1 in the full emulation mode and via ptrace(2),
    according to the ISA level of processor hardware or the writability of
    bits 31:18 if actual FPU hardware is used.
    
    Software may rely on FCSR bits whose functions our emulator does not
    implement, so it should not allow them to be set or software may get
    confused.  For ptrace(2) it's just sanity.
    
    [ralf@linux-mips.org: Fixed double inclusion of <asm/current.h>.]
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/9711/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index dd083e999b08..83d50d563a0f 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -30,7 +30,7 @@
 struct sigcontext;
 struct sigcontext32;
 
-extern void _init_fpu(void);
+extern void _init_fpu(unsigned int);
 extern void _save_fp(struct task_struct *);
 extern void _restore_fp(struct task_struct *);
 
@@ -182,6 +182,7 @@ static inline void lose_fpu(int save)
 
 static inline int init_fpu(void)
 {
+	unsigned int fcr31 = current->thread.fpu.fcr31;
 	int ret = 0;
 
 	if (cpu_has_fpu) {
@@ -192,7 +193,7 @@ static inline int init_fpu(void)
 			return ret;
 
 		if (!cpu_has_fre) {
-			_init_fpu();
+			_init_fpu(fcr31);
 
 			return 0;
 		}
@@ -206,7 +207,7 @@ static inline int init_fpu(void)
 		config5 = clear_c0_config5(MIPS_CONF5_FRE);
 		enable_fpu_hazard();
 
-		_init_fpu();
+		_init_fpu(fcr31);
 
 		/* Restore FRE */
 		write_c0_config5(config5);

commit 84ab45b33858a87632e1f5e207e302bf48eaf52e
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Fri Jan 30 12:09:37 2015 +0000

    MIPS: disable FPU if the mode is unsupported
    
    The expected semantics of __enable_fpu are for the FPU to be enabled
    in the given mode if possible, otherwise for the FPU to be left
    disabled and SIGFPE returned. The FPU was incorrectly being left
    enabled in cases where the desired value for FR was unavailable.
    Without ensuring the FPU is disabled in this case, it would be
    possible for userland to go on to execute further FP instructions
    natively in the incorrect mode, rather than those instructions being
    trapped & emulated as they need to be.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/9167/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 9f26b079cc6a..b104ad9d655f 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -48,6 +48,12 @@ enum fpu_mode {
 #define FPU_FR_MASK		0x1
 };
 
+#define __disable_fpu()							\
+do {									\
+	clear_c0_status(ST0_CU1);					\
+	disable_fpu_hazard();						\
+} while (0)
+
 static inline int __enable_fpu(enum fpu_mode mode)
 {
 	int fr;
@@ -86,7 +92,12 @@ static inline int __enable_fpu(enum fpu_mode mode)
 		enable_fpu_hazard();
 
 		/* check FR has the desired value */
-		return (!!(read_c0_status() & ST0_FR) == !!fr) ? 0 : SIGFPE;
+		if (!!(read_c0_status() & ST0_FR) == !!fr)
+			return 0;
+
+		/* unsupported FR value */
+		__disable_fpu();
+		return SIGFPE;
 
 	default:
 		BUG();
@@ -95,12 +106,6 @@ static inline int __enable_fpu(enum fpu_mode mode)
 	return SIGFPE;
 }
 
-#define __disable_fpu()							\
-do {									\
-	clear_c0_status(ST0_CU1);					\
-	disable_fpu_hazard();						\
-} while (0)
-
 #define clear_fpu_owner()	clear_thread_flag(TIF_USEDFPU)
 
 static inline int __is_fpu_owner(void)

commit acaf6a97d623af123314c2f8ce4cf7254f6b2fc1
Author: James Hogan <james.hogan@imgtec.com>
Date:   Wed Feb 25 13:08:05 2015 +0000

    MIPS: lose_fpu(): Disable FPU when MSA enabled
    
    The lose_fpu() function only disables the FPU in CP0_Status.CU1 if the
    FPU is in use and MSA isn't enabled.
    
    This isn't necessarily a problem because KSTK_STATUS(current), the
    version of CP0_Status stored on the kernel stack on entry from user
    mode, does always get updated and gets restored when returning to user
    mode, but I don't think it was intended, and it is inconsistent with the
    case of only the FPU being in use. Sometimes leaving the FPU enabled may
    also mask kernel bugs where FPU operations are executed when the FPU
    might not be enabled.
    
    So lets disable the FPU in the MSA case too.
    
    Fixes: 33c771ba5c5d ("MIPS: save/disable MSA in lose_fpu")
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/9323/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index dd083e999b08..9f26b079cc6a 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -170,6 +170,7 @@ static inline void lose_fpu(int save)
 		}
 		disable_msa();
 		clear_thread_flag(TIF_USEDMSA);
+		__disable_fpu();
 	} else if (is_fpu_owner()) {
 		if (save)
 			_save_fp(current);

commit a135c717d5cdb311cff7661af4c17fef0562e590
Merge: 217703323308 44923c9cfa1a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Feb 21 19:41:38 2015 -0800

    Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus
    
    Pull MIPS updates from Ralf Baechle:
     "This is the main pull request for MIPS:
    
       - a number of fixes that didn't make the 3.19 release.
    
       - a number of cleanups.
    
       - preliminary support for Cavium's Octeon 3 SOCs which feature up to
         48 MIPS64 R3 cores with FPU and hardware virtualization.
    
       - support for MIPS R6 processors.
    
         Revision 6 of the MIPS architecture is a major revision of the MIPS
         architecture which does away with many of original sins of the
         architecture such as branch delay slots.  This and other changes in
         R6 require major changes throughout the entire MIPS core
         architecture code and make up for the lion share of this pull
         request.
    
       - finally some preparatory work for eXtendend Physical Address
         support, which allows support of up to 40 bit of physical address
         space on 32 bit processors"
    
         [ Ahh, MIPS can't leave the PAE brain damage alone.  It's like
           every CPU architect has to make that mistake, but pee in the snow
           by changing the TLA.  But whether it's called PAE, LPAE or XPA,
           it's horrid crud   - Linus ]
    
    * 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus: (114 commits)
      MIPS: sead3: Corrected get_c0_perfcount_int
      MIPS: mm: Remove dead macro definitions
      MIPS: OCTEON: irq: add CIB and other fixes
      MIPS: OCTEON: Don't do acknowledge operations for level triggered irqs.
      MIPS: OCTEON: More OCTEONIII support
      MIPS: OCTEON: Remove setting of processor specific CVMCTL icache bits.
      MIPS: OCTEON: Core-15169 Workaround and general CVMSEG cleanup.
      MIPS: OCTEON: Update octeon-model.h code for new SoCs.
      MIPS: OCTEON: Implement DCache errata workaround for all CN6XXX
      MIPS: OCTEON: Add little-endian support to asm/octeon/octeon.h
      MIPS: OCTEON: Implement the core-16057 workaround
      MIPS: OCTEON: Delete unused COP2 saving code
      MIPS: OCTEON: Use correct instruction to read 64-bit COP0 register
      MIPS: OCTEON: Save and restore CP2 SHA3 state
      MIPS: OCTEON: Fix FP context save.
      MIPS: OCTEON: Save/Restore wider multiply registers in OCTEON III CPUs
      MIPS: boot: Provide more uImage options
      MIPS: Remove unneeded #ifdef __KERNEL__ from asm/processor.h
      MIPS: ip22-gio: Remove legacy suspend/resume support
      mips: pci: Add ifdef around pci_proc_domain
      ...

commit 6134d94923d03556b4f74a7864759dc333030c98
Author: Markos Chandras <markos.chandras@imgtec.com>
Date:   Fri Jan 30 10:20:28 2015 +0000

    MIPS: asm: fpu: Allow 64-bit FPU on MIPS32 R6
    
    MIPS32 R6 has a 64-bit FPU so add the necessary MIPS R6
    definition.
    
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 994d21939676..b96d9d327626 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -68,7 +68,8 @@ static inline int __enable_fpu(enum fpu_mode mode)
 		goto fr_common;
 
 	case FPU_64BIT:
-#if !(defined(CONFIG_CPU_MIPS32_R2) || defined(CONFIG_64BIT))
+#if !(defined(CONFIG_CPU_MIPS32_R2) || defined(CONFIG_CPU_MIPS32_R6) \
+      || defined(CONFIG_64BIT))
 		/* we only have a 32-bit FPU */
 		return SIGFPE;
 #endif

commit d33e6fe3ca74108e8e6ea1f5560b21c834b579a5
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Dec 17 11:46:40 2014 +0100

    MIPS: FRE: Use set/clear_c0_config5 instead of open coded sequences.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 5528f4e2af6a..affebb78f5d6 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -64,7 +64,7 @@ static inline int __enable_fpu(enum fpu_mode mode)
 			return SIGFPE;
 
 		/* set FRE */
-		write_c0_config5(read_c0_config5() | MIPS_CONF5_FRE);
+		set_c0_config5(MIPS_CONF5_FRE);
 		goto fr_common;
 
 	case FPU_64BIT:
@@ -76,7 +76,7 @@ static inline int __enable_fpu(enum fpu_mode mode)
 	case FPU_32BIT:
 		if (cpu_has_fre) {
 			/* clear FRE */
-			write_c0_config5(read_c0_config5() & ~MIPS_CONF5_FRE);
+			clear_c0_config5(MIPS_CONF5_FRE);
 		}
 fr_common:
 		/* set CU1 & change FR appropriately */
@@ -196,15 +196,13 @@ static inline int init_fpu(void)
 			return 0;
 		}
 
-		config5 = read_c0_config5();
-
 		/*
 		 * Ensure FRE is clear whilst running _init_fpu, since
 		 * single precision FP instructions are used. If FRE
 		 * was set then we'll just end up initialising all 32
 		 * 64b registers.
 		 */
-		write_c0_config5(config5 & ~MIPS_CONF5_FRE);
+		config5 = clear_c0_config5(MIPS_CONF5_FRE);
 		enable_fpu_hazard();
 
 		_init_fpu();

commit b0c34f6155e2d8bbe096a85a770d63ee6be6c726
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Dec 17 11:39:30 2014 +0100

    MIPS: Do not fiddle with FRE unless FRE is actually available.
    
    Commit 4227a2d4efc9c84f35826dc4d1e6dc183f6c1c05 (MIPS: Support for hybrid
    FPRs) changes the kernel to execute read_c0_config5() even on processors
    that don't have a Config5 register.  According to the arch spec the
    behaviour of trying to read or write this register is UNDEFINED where this
    register doesn't exist, that is merely looking at this register is
    already cruel because that might kill a kitten.
    
    In case of Qemu older than v2.2 Qemu has elected to implement this
    UNDEFINED behaviour by taking a RI exception - which then fries the
    kernel:
    
    [...]
    Freeing YAMON memory: 956k freed
    Freeing unused kernel memory: 240K (80674000 - 806b0000)
    Reserved instruction in kernel code[#1]:
    CPU: 0 PID: 1 Comm: init Not tainted 3.18.0-rc6-00058-g4227a2d #26
    task: 86047588 ti: 86048000 task.ti: 86048000
    $ 0   : 00000000 77a638cc 00000000 00000000
    [...]
    
    For qemu v2.2.0 commit f31b035a9f10dc9b57f01c426110af845d453ce2
    (target-mips: correctly handle access to unimplemented CP0 register)
    changed the behaviour to returning zero on read and ignoring writes
    which more matches how typical hardware implementations actually behave.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 994d21939676..5528f4e2af6a 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -74,8 +74,10 @@ static inline int __enable_fpu(enum fpu_mode mode)
 #endif
 		/* fall through */
 	case FPU_32BIT:
-		/* clear FRE */
-		write_c0_config5(read_c0_config5() & ~MIPS_CONF5_FRE);
+		if (cpu_has_fre) {
+			/* clear FRE */
+			write_c0_config5(read_c0_config5() & ~MIPS_CONF5_FRE);
+		}
 fr_common:
 		/* set CU1 & change FR appropriately */
 		fr = (int)mode & FPU_FR_MASK;
@@ -182,25 +184,34 @@ static inline int init_fpu(void)
 	int ret = 0;
 
 	if (cpu_has_fpu) {
+		unsigned int config5;
+
 		ret = __own_fpu();
-		if (!ret) {
-			unsigned int config5 = read_c0_config5();
-
-			/*
-			 * Ensure FRE is clear whilst running _init_fpu, since
-			 * single precision FP instructions are used. If FRE
-			 * was set then we'll just end up initialising all 32
-			 * 64b registers.
-			 */
-			write_c0_config5(config5 & ~MIPS_CONF5_FRE);
-			enable_fpu_hazard();
+		if (ret)
+			return ret;
 
+		if (!cpu_has_fre) {
 			_init_fpu();
 
-			/* Restore FRE */
-			write_c0_config5(config5);
-			enable_fpu_hazard();
+			return 0;
 		}
+
+		config5 = read_c0_config5();
+
+		/*
+		 * Ensure FRE is clear whilst running _init_fpu, since
+		 * single precision FP instructions are used. If FRE
+		 * was set then we'll just end up initialising all 32
+		 * 64b registers.
+		 */
+		write_c0_config5(config5 & ~MIPS_CONF5_FRE);
+		enable_fpu_hazard();
+
+		_init_fpu();
+
+		/* Restore FRE */
+		write_c0_config5(config5);
+		enable_fpu_hazard();
 	} else
 		fpu_emulator_init_fpu();
 

commit 4227a2d4efc9c84f35826dc4d1e6dc183f6c1c05
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Thu Sep 11 08:30:20 2014 +0100

    MIPS: Support for hybrid FPRs
    
    Hybrid FPRs is a scheme where scalar FP registers are 64b wide, but
    accesses to odd indexed single registers use bits 63:32 of the
    preceeding even indexed 64b register. In this mode all FP code
    except that built for the plain FP64 ABI can execute correctly. Most
    notably a combination of FP64A & FP32 code can execute correctly,
    allowing for existing FP32 binaries to be linked with new FP64A binaries
    that can make use of 64 bit FP & MSA.
    
    Hybrid FPRs are implemented by setting both the FR & FRE bits, trapping
    & emulating single precision FP instructions (via Reserved Instruction
    exceptions) whilst allowing others to execute natively. It therefore has
    a penalty in terms of execution speed, and should only be used when no
    fully native mode can be. As more binaries are recompiled to use either
    the FPXX or FP64(A) ABIs, the need for hybrid FPRs should diminish.
    However in the short to mid term it allows for a gradual transition
    towards that world, rather than a complete ABI break which is not
    feasible for some users & not desirable for many.
    
    A task will be executed using the hybrid FPR scheme when its
    TIF_HYBRID_FPREGS flag is set & TIF_32BIT_FPREGS is clear. A further
    patch will set the flags as necessary, this patch simply adds the
    infrastructure necessary for the hybrid FPR mode to work.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: linux-fsdevel@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/7683/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index dd562414cd5e..994d21939676 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -36,14 +36,16 @@ extern void _restore_fp(struct task_struct *);
 
 /*
  * This enum specifies a mode in which we want the FPU to operate, for cores
- * which implement the Status.FR bit. Note that FPU_32BIT & FPU_64BIT
- * purposefully have the values 0 & 1 respectively, so that an integer value
- * of Status.FR can be trivially casted to the corresponding enum fpu_mode.
+ * which implement the Status.FR bit. Note that the bottom bit of the value
+ * purposefully matches the desired value of the Status.FR bit.
  */
 enum fpu_mode {
 	FPU_32BIT = 0,		/* FR = 0 */
-	FPU_64BIT,		/* FR = 1 */
+	FPU_64BIT,		/* FR = 1, FRE = 0 */
 	FPU_AS_IS,
+	FPU_HYBRID,		/* FR = 1, FRE = 1 */
+
+#define FPU_FR_MASK		0x1
 };
 
 static inline int __enable_fpu(enum fpu_mode mode)
@@ -57,6 +59,14 @@ static inline int __enable_fpu(enum fpu_mode mode)
 		enable_fpu_hazard();
 		return 0;
 
+	case FPU_HYBRID:
+		if (!cpu_has_fre)
+			return SIGFPE;
+
+		/* set FRE */
+		write_c0_config5(read_c0_config5() | MIPS_CONF5_FRE);
+		goto fr_common;
+
 	case FPU_64BIT:
 #if !(defined(CONFIG_CPU_MIPS32_R2) || defined(CONFIG_64BIT))
 		/* we only have a 32-bit FPU */
@@ -64,8 +74,11 @@ static inline int __enable_fpu(enum fpu_mode mode)
 #endif
 		/* fall through */
 	case FPU_32BIT:
+		/* clear FRE */
+		write_c0_config5(read_c0_config5() & ~MIPS_CONF5_FRE);
+fr_common:
 		/* set CU1 & change FR appropriately */
-		fr = (int)mode;
+		fr = (int)mode & FPU_FR_MASK;
 		change_c0_status(ST0_CU1 | ST0_FR, ST0_CU1 | (fr ? ST0_FR : 0));
 		enable_fpu_hazard();
 
@@ -102,13 +115,17 @@ static inline int __own_fpu(void)
 	enum fpu_mode mode;
 	int ret;
 
-	mode = !test_thread_flag(TIF_32BIT_FPREGS);
+	if (test_thread_flag(TIF_HYBRID_FPREGS))
+		mode = FPU_HYBRID;
+	else
+		mode = !test_thread_flag(TIF_32BIT_FPREGS);
+
 	ret = __enable_fpu(mode);
 	if (ret)
 		return ret;
 
 	KSTK_STATUS(current) |= ST0_CU1;
-	if (mode == FPU_64BIT)
+	if (mode == FPU_64BIT || mode == FPU_HYBRID)
 		KSTK_STATUS(current) |= ST0_FR;
 	else /* mode == FPU_32BIT */
 		KSTK_STATUS(current) &= ~ST0_FR;
@@ -166,8 +183,24 @@ static inline int init_fpu(void)
 
 	if (cpu_has_fpu) {
 		ret = __own_fpu();
-		if (!ret)
+		if (!ret) {
+			unsigned int config5 = read_c0_config5();
+
+			/*
+			 * Ensure FRE is clear whilst running _init_fpu, since
+			 * single precision FP instructions are used. If FRE
+			 * was set then we'll just end up initialising all 32
+			 * 64b registers.
+			 */
+			write_c0_config5(config5 & ~MIPS_CONF5_FRE);
+			enable_fpu_hazard();
+
 			_init_fpu();
+
+			/* Restore FRE */
+			write_c0_config5(config5);
+			enable_fpu_hazard();
+		}
 	} else
 		fpu_emulator_init_fpu();
 

commit 842dfc11ea9a21f9825167c8a4f2834b205b0a79
Author: Manuel Lauss <manuel.lauss@gmail.com>
Date:   Fri Nov 7 14:13:54 2014 +0100

    MIPS: Fix build with binutils 2.24.51+
    
    Starting with version 2.24.51.20140728 MIPS binutils complain loudly
    about mixing soft-float and hard-float object files, leading to this
    build failure since GCC is invoked with "-msoft-float" on MIPS:
    
    {standard input}: Warning: .gnu_attribute 4,3 requires `softfloat'
      LD      arch/mips/alchemy/common/built-in.o
    mipsel-softfloat-linux-gnu-ld: Warning: arch/mips/alchemy/common/built-in.o
     uses -msoft-float (set by arch/mips/alchemy/common/prom.o),
     arch/mips/alchemy/common/sleeper.o uses -mhard-float
    
    To fix this, we detect if GAS is new enough to support "-msoft-float" command
    option, and if it does, we can let GCC pass it to GAS;  but then we also need
    to sprinkle the files which make use of floating point registers with the
    necessary ".set hardfloat" directives.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: Linux-MIPS <linux-mips@linux-mips.org>
    Cc: Matthew Fortune <Matthew.Fortune@imgtec.com>
    Cc: Markos Chandras <Markos.Chandras@imgtec.com>
    Cc: Maciej W. Rozycki <macro@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/8355/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 4d0aeda68397..dd562414cd5e 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -145,8 +145,8 @@ static inline void lose_fpu(int save)
 	if (is_msa_enabled()) {
 		if (save) {
 			save_msa(current);
-			asm volatile("cfc1 %0, $31"
-				: "=r"(current->thread.fpu.fcr31));
+			current->thread.fpu.fcr31 =
+					read_32bit_cp1_register(CP1_STATUS);
 		}
 		disable_msa();
 		clear_thread_flag(TIF_USEDMSA);

commit 762a1f4388a22690cd4f848ba858e5f02d4bfc22
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Fri Jul 11 16:44:35 2014 +0100

    MIPS: disable preemption whilst initialising MSA
    
    Preemption must be disabled throughout the process of enabling the FPU,
    enabling MSA & initialising the vector registers. Without doing so it
    is possible to lose the FPU or MSA whilst initialising them causing
    that initialisation to fail.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/7307/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 71d97ebd9090..4d0aeda68397 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -164,8 +164,6 @@ static inline int init_fpu(void)
 {
 	int ret = 0;
 
-	preempt_disable();
-
 	if (cpu_has_fpu) {
 		ret = __own_fpu();
 		if (!ret)
@@ -173,8 +171,6 @@ static inline int init_fpu(void)
 	} else
 		fpu_emulator_init_fpu();
 
-	preempt_enable();
-
 	return ret;
 }
 

commit 33c771ba5c5d067f85a5a6c4b11047219b5b8f4e
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Fri Jul 11 16:44:30 2014 +0100

    MIPS: save/disable MSA in lose_fpu
    
    The kernel depends upon MSA never being enabled when the FPU is not, a
    condition which is currently violated in a few places (whilst saving
    sigcontext, following mips_cpu_save). Catch all the problem cases by
    disabling MSA in lose_fpu, after saving context if necessary.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/7302/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index a939574f8293..71d97ebd9090 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -21,6 +21,7 @@
 #include <asm/hazards.h>
 #include <asm/processor.h>
 #include <asm/current.h>
+#include <asm/msa.h>
 
 #ifdef CONFIG_MIPS_MT_FPAFF
 #include <asm/mips_mt.h>
@@ -141,13 +142,21 @@ static inline int own_fpu(int restore)
 static inline void lose_fpu(int save)
 {
 	preempt_disable();
-	if (is_fpu_owner()) {
+	if (is_msa_enabled()) {
+		if (save) {
+			save_msa(current);
+			asm volatile("cfc1 %0, $31"
+				: "=r"(current->thread.fpu.fcr31));
+		}
+		disable_msa();
+		clear_thread_flag(TIF_USEDMSA);
+	} else if (is_fpu_owner()) {
 		if (save)
 			_save_fp(current);
-		KSTK_STATUS(current) &= ~ST0_CU1;
-		clear_thread_flag(TIF_USEDFPU);
 		__disable_fpu();
 	}
+	KSTK_STATUS(current) &= ~ST0_CU1;
+	clear_thread_flag(TIF_USEDFPU);
 	preempt_enable();
 }
 

commit e0cc3a42eb50593a50e2b99d9dc92b4279f2efda
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Apr 28 22:34:01 2014 +0200

    MIPS: math-emu: Inline fpu_emulator_init_fpu()
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 4d86b72750c7..a939574f8293 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -17,6 +17,7 @@
 #include <asm/mipsregs.h>
 #include <asm/cpu.h>
 #include <asm/cpu-features.h>
+#include <asm/fpu_emulator.h>
 #include <asm/hazards.h>
 #include <asm/processor.h>
 #include <asm/current.h>
@@ -28,7 +29,6 @@
 struct sigcontext;
 struct sigcontext32;
 
-extern void fpu_emulator_init_fpu(void);
 extern void _init_fpu(void);
 extern void _save_fp(struct task_struct *);
 extern void _restore_fp(struct task_struct *);
@@ -156,15 +156,16 @@ static inline int init_fpu(void)
 	int ret = 0;
 
 	preempt_disable();
+
 	if (cpu_has_fpu) {
 		ret = __own_fpu();
 		if (!ret)
 			_init_fpu();
-	} else {
+	} else
 		fpu_emulator_init_fpu();
-	}
 
 	preempt_enable();
+
 	return ret;
 }
 

commit ade63aada79c61bcd5f51cbd310f237399892268
Merge: 9a1724c7506b c14af233fbe2
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Mar 31 18:17:33 2014 +0200

    Merge branch '3.14-fixes' into mips-for-linux-next

commit bbd426f542cb61f2322e15dab4507f2661090c06
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Thu Feb 13 11:26:41 2014 +0000

    MIPS: Simplify FP context access
    
    This patch replaces the fpureg_t typedef with a "union fpureg" enabling
    easier access to 32 & 64 bit values. This allows the access macros used
    in cp1emu.c to be simplified somewhat. It will also make it easier to
    expand the width of the FP registers as will be done in a future
    patch in order to support the 128 bit registers introduced with MSA.
    
    No behavioural change is intended by this patch.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Reviewed-by: Qais Yousef <qais.yousef@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/6532/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 6b9749540edf..8a3d61f0017f 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -180,7 +180,7 @@ static inline void restore_fp(struct task_struct *tsk)
 		_restore_fp(tsk);
 }
 
-static inline fpureg_t *get_fpu_regs(struct task_struct *tsk)
+static inline union fpureg *get_fpu_regs(struct task_struct *tsk)
 {
 	if (tsk == current) {
 		preempt_disable();

commit f5868f05dc976ecd849d2a8115fab80301c127cd
Author: Paul Bolle <pebolle@tiscali.nl>
Date:   Sun Feb 9 14:32:25 2014 +0100

    MIPS: Replace CONFIG_MIPS64 and CONFIG_MIPS32_R2
    
    Commit 597ce1723e0f ("MIPS: Support for 64-bit FP with O32 binaries")
    introduced references to two undefined Kconfig macros. CONFIG_MIPS32_R2
    should clearly be replaced with CONFIG_CPU_MIPS32_R2. And CONFIG_MIPS64
    should be replaced with CONFIG_64BIT.
    
    Signed-off-by: Paul Bolle <pebolle@tiscali.nl>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/6522/
    Tested-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 6b9749540edf..58e50cbdb1a6 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -57,7 +57,7 @@ static inline int __enable_fpu(enum fpu_mode mode)
 		return 0;
 
 	case FPU_64BIT:
-#if !(defined(CONFIG_CPU_MIPS32_R2) || defined(CONFIG_MIPS64))
+#if !(defined(CONFIG_CPU_MIPS32_R2) || defined(CONFIG_64BIT))
 		/* we only have a 32-bit FPU */
 		return SIGFPE;
 #endif

commit 97b8b16bfcb7f5ccc1b3c10c08580f9f1acb61ac
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Wed Feb 5 22:05:44 2014 +0200

    MIPS: fpu.h: Fix build when CONFIG_BUG is not set
    
    __enable_fpu produces a build failure when CONFIG_BUG is not set:
    
    In file included from arch/mips/kernel/cpu-probe.c:24:0:
    arch/mips/include/asm/fpu.h: In function '__enable_fpu':
    arch/mips/include/asm/fpu.h:77:1: error: control reaches end of non-void function [-Werror=return-type]
    
    This is regression introduced in 3.14-rc1. Fix that.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Acked-by: Paul Burton <paul.burton@imgtec.com>
    Cc: John Crispin <blogic@openwrt.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/6504/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index cfe092fc720d..6b9749540edf 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -74,6 +74,8 @@ static inline int __enable_fpu(enum fpu_mode mode)
 	default:
 		BUG();
 	}
+
+	return SIGFPE;
 }
 
 #define __disable_fpu()							\

commit 597ce1723e0fa0bdbe2ae4c94f18da6e29b92635
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Fri Nov 22 13:12:07 2013 +0000

    MIPS: Support for 64-bit FP with O32 binaries
    
    CPUs implementing MIPS32 R2 may include a 64-bit FPU, just as MIPS64 CPUs
    do. In order to preserve backwards compatibility a 64-bit FPU will act
    like a 32-bit FPU (by accessing doubles from the least significant 32
    bits of an even-odd pair of FP registers) when the Status.FR bit is
    zero, again just like a mips64 CPU. The standard O32 ABI is defined
    expecting a 32-bit FPU, however recent toolchains support use of a
    64-bit FPU from an O32 MIPS32 executable. When an ELF executable is
    built to use a 64-bit FPU a new flag (EF_MIPS_FP64) is set in the ELF
    header.
    
    With this patch the kernel will check the EF_MIPS_FP64 flag when
    executing an O32 binary, and set Status.FR accordingly. The addition
    of O32 64-bit FP support lessens the opportunity for optimisation in
    the FPU emulator, so a CONFIG_MIPS_O32_FP64_SUPPORT Kconfig option is
    introduced to allow this support to be disabled for those that don't
    require it.
    
    Inspired by an earlier patch by Leonid Yegoshin, but implemented more
    cleanly & correctly.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: Paul Burton <paul.burton@imgtec.com>
    Patchwork: https://patchwork.linux-mips.org/patch/6154/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 3bf023fde482..cfe092fc720d 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -33,11 +33,48 @@ extern void _init_fpu(void);
 extern void _save_fp(struct task_struct *);
 extern void _restore_fp(struct task_struct *);
 
-#define __enable_fpu()							\
-do {									\
-	set_c0_status(ST0_CU1);						\
-	enable_fpu_hazard();						\
-} while (0)
+/*
+ * This enum specifies a mode in which we want the FPU to operate, for cores
+ * which implement the Status.FR bit. Note that FPU_32BIT & FPU_64BIT
+ * purposefully have the values 0 & 1 respectively, so that an integer value
+ * of Status.FR can be trivially casted to the corresponding enum fpu_mode.
+ */
+enum fpu_mode {
+	FPU_32BIT = 0,		/* FR = 0 */
+	FPU_64BIT,		/* FR = 1 */
+	FPU_AS_IS,
+};
+
+static inline int __enable_fpu(enum fpu_mode mode)
+{
+	int fr;
+
+	switch (mode) {
+	case FPU_AS_IS:
+		/* just enable the FPU in its current mode */
+		set_c0_status(ST0_CU1);
+		enable_fpu_hazard();
+		return 0;
+
+	case FPU_64BIT:
+#if !(defined(CONFIG_CPU_MIPS32_R2) || defined(CONFIG_MIPS64))
+		/* we only have a 32-bit FPU */
+		return SIGFPE;
+#endif
+		/* fall through */
+	case FPU_32BIT:
+		/* set CU1 & change FR appropriately */
+		fr = (int)mode;
+		change_c0_status(ST0_CU1 | ST0_FR, ST0_CU1 | (fr ? ST0_FR : 0));
+		enable_fpu_hazard();
+
+		/* check FR has the desired value */
+		return (!!(read_c0_status() & ST0_FR) == !!fr) ? 0 : SIGFPE;
+
+	default:
+		BUG();
+	}
+}
 
 #define __disable_fpu()							\
 do {									\
@@ -57,27 +94,46 @@ static inline int is_fpu_owner(void)
 	return cpu_has_fpu && __is_fpu_owner();
 }
 
-static inline void __own_fpu(void)
+static inline int __own_fpu(void)
 {
-	__enable_fpu();
+	enum fpu_mode mode;
+	int ret;
+
+	mode = !test_thread_flag(TIF_32BIT_FPREGS);
+	ret = __enable_fpu(mode);
+	if (ret)
+		return ret;
+
 	KSTK_STATUS(current) |= ST0_CU1;
+	if (mode == FPU_64BIT)
+		KSTK_STATUS(current) |= ST0_FR;
+	else /* mode == FPU_32BIT */
+		KSTK_STATUS(current) &= ~ST0_FR;
+
 	set_thread_flag(TIF_USEDFPU);
+	return 0;
 }
 
-static inline void own_fpu_inatomic(int restore)
+static inline int own_fpu_inatomic(int restore)
 {
+	int ret = 0;
+
 	if (cpu_has_fpu && !__is_fpu_owner()) {
-		__own_fpu();
-		if (restore)
+		ret = __own_fpu();
+		if (restore && !ret)
 			_restore_fp(current);
 	}
+	return ret;
 }
 
-static inline void own_fpu(int restore)
+static inline int own_fpu(int restore)
 {
+	int ret;
+
 	preempt_disable();
-	own_fpu_inatomic(restore);
+	ret = own_fpu_inatomic(restore);
 	preempt_enable();
+	return ret;
 }
 
 static inline void lose_fpu(int save)
@@ -93,16 +149,21 @@ static inline void lose_fpu(int save)
 	preempt_enable();
 }
 
-static inline void init_fpu(void)
+static inline int init_fpu(void)
 {
+	int ret = 0;
+
 	preempt_disable();
 	if (cpu_has_fpu) {
-		__own_fpu();
-		_init_fpu();
+		ret = __own_fpu();
+		if (!ret)
+			_init_fpu();
 	} else {
 		fpu_emulator_init_fpu();
 	}
+
 	preempt_enable();
+	return ret;
 }
 
 static inline void save_fp(struct task_struct *tsk)

commit 56a22d21bf9744315f56b2bbd6416170f27b7765
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Thu Nov 7 12:48:30 2013 +0000

    MIPS: Remove unused {en,dis}able_fpu macros
    
    These macros are not used anywhere in the kernel. Remove them.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/6111/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index d088e5db4903..3bf023fde482 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -45,19 +45,6 @@ do {									\
 	disable_fpu_hazard();						\
 } while (0)
 
-#define enable_fpu()							\
-do {									\
-	if (cpu_has_fpu)						\
-		__enable_fpu();						\
-} while (0)
-
-#define disable_fpu()							\
-do {									\
-	if (cpu_has_fpu)						\
-		__disable_fpu();					\
-} while (0)
-
-
 #define clear_fpu_owner()	clear_thread_flag(TIF_USEDFPU)
 
 static inline int __is_fpu_owner(void)

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 7fcef8ef3fab..d088e5db4903 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -35,14 +35,14 @@ extern void _restore_fp(struct task_struct *);
 
 #define __enable_fpu()							\
 do {									\
-        set_c0_status(ST0_CU1);						\
-        enable_fpu_hazard();						\
+	set_c0_status(ST0_CU1);						\
+	enable_fpu_hazard();						\
 } while (0)
 
 #define __disable_fpu()							\
 do {									\
 	clear_c0_status(ST0_CU1);					\
-        disable_fpu_hazard();						\
+	disable_fpu_hazard();						\
 } while (0)
 
 #define enable_fpu()							\

commit 137f6f3e284e8215a940cf20dbf2aef449fe5a60
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Nov 24 19:35:41 2009 +0000

    MIPS: Cleanup signal code initialization
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/709/

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
index 8a3ef247659a..7fcef8ef3fab 100644
--- a/arch/mips/include/asm/fpu.h
+++ b/arch/mips/include/asm/fpu.h
@@ -28,15 +28,7 @@
 struct sigcontext;
 struct sigcontext32;
 
-extern asmlinkage int (*save_fp_context)(struct sigcontext __user *sc);
-extern asmlinkage int (*restore_fp_context)(struct sigcontext __user *sc);
-
-extern asmlinkage int (*save_fp_context32)(struct sigcontext32 __user *sc);
-extern asmlinkage int (*restore_fp_context32)(struct sigcontext32 __user *sc);
-
 extern void fpu_emulator_init_fpu(void);
-extern int fpu_emulator_save_context(struct sigcontext __user *sc);
-extern int fpu_emulator_restore_context(struct sigcontext __user *sc);
 extern void _init_fpu(void);
 extern void _save_fp(struct task_struct *);
 extern void _restore_fp(struct task_struct *);

commit 384740dc49ea651ba350704d13ff6be9976e37fe
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Sep 16 19:48:51 2008 +0200

    MIPS: Move headfiles to new location below arch/mips/include
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h
new file mode 100644
index 000000000000..8a3ef247659a
--- /dev/null
+++ b/arch/mips/include/asm/fpu.h
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2002 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#ifndef _ASM_FPU_H
+#define _ASM_FPU_H
+
+#include <linux/sched.h>
+#include <linux/thread_info.h>
+#include <linux/bitops.h>
+
+#include <asm/mipsregs.h>
+#include <asm/cpu.h>
+#include <asm/cpu-features.h>
+#include <asm/hazards.h>
+#include <asm/processor.h>
+#include <asm/current.h>
+
+#ifdef CONFIG_MIPS_MT_FPAFF
+#include <asm/mips_mt.h>
+#endif
+
+struct sigcontext;
+struct sigcontext32;
+
+extern asmlinkage int (*save_fp_context)(struct sigcontext __user *sc);
+extern asmlinkage int (*restore_fp_context)(struct sigcontext __user *sc);
+
+extern asmlinkage int (*save_fp_context32)(struct sigcontext32 __user *sc);
+extern asmlinkage int (*restore_fp_context32)(struct sigcontext32 __user *sc);
+
+extern void fpu_emulator_init_fpu(void);
+extern int fpu_emulator_save_context(struct sigcontext __user *sc);
+extern int fpu_emulator_restore_context(struct sigcontext __user *sc);
+extern void _init_fpu(void);
+extern void _save_fp(struct task_struct *);
+extern void _restore_fp(struct task_struct *);
+
+#define __enable_fpu()							\
+do {									\
+        set_c0_status(ST0_CU1);						\
+        enable_fpu_hazard();						\
+} while (0)
+
+#define __disable_fpu()							\
+do {									\
+	clear_c0_status(ST0_CU1);					\
+        disable_fpu_hazard();						\
+} while (0)
+
+#define enable_fpu()							\
+do {									\
+	if (cpu_has_fpu)						\
+		__enable_fpu();						\
+} while (0)
+
+#define disable_fpu()							\
+do {									\
+	if (cpu_has_fpu)						\
+		__disable_fpu();					\
+} while (0)
+
+
+#define clear_fpu_owner()	clear_thread_flag(TIF_USEDFPU)
+
+static inline int __is_fpu_owner(void)
+{
+	return test_thread_flag(TIF_USEDFPU);
+}
+
+static inline int is_fpu_owner(void)
+{
+	return cpu_has_fpu && __is_fpu_owner();
+}
+
+static inline void __own_fpu(void)
+{
+	__enable_fpu();
+	KSTK_STATUS(current) |= ST0_CU1;
+	set_thread_flag(TIF_USEDFPU);
+}
+
+static inline void own_fpu_inatomic(int restore)
+{
+	if (cpu_has_fpu && !__is_fpu_owner()) {
+		__own_fpu();
+		if (restore)
+			_restore_fp(current);
+	}
+}
+
+static inline void own_fpu(int restore)
+{
+	preempt_disable();
+	own_fpu_inatomic(restore);
+	preempt_enable();
+}
+
+static inline void lose_fpu(int save)
+{
+	preempt_disable();
+	if (is_fpu_owner()) {
+		if (save)
+			_save_fp(current);
+		KSTK_STATUS(current) &= ~ST0_CU1;
+		clear_thread_flag(TIF_USEDFPU);
+		__disable_fpu();
+	}
+	preempt_enable();
+}
+
+static inline void init_fpu(void)
+{
+	preempt_disable();
+	if (cpu_has_fpu) {
+		__own_fpu();
+		_init_fpu();
+	} else {
+		fpu_emulator_init_fpu();
+	}
+	preempt_enable();
+}
+
+static inline void save_fp(struct task_struct *tsk)
+{
+	if (cpu_has_fpu)
+		_save_fp(tsk);
+}
+
+static inline void restore_fp(struct task_struct *tsk)
+{
+	if (cpu_has_fpu)
+		_restore_fp(tsk);
+}
+
+static inline fpureg_t *get_fpu_regs(struct task_struct *tsk)
+{
+	if (tsk == current) {
+		preempt_disable();
+		if (is_fpu_owner())
+			_save_fp(current);
+		preempt_enable();
+	}
+
+	return tsk->thread.fpu.fpr;
+}
+
+#endif /* _ASM_FPU_H */
