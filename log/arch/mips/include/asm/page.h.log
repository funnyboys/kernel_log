commit c9b0299034665d594e56ee343f28033d1b24de6d
Author: Liangliang Huang <huanglllzu@gmail.com>
Date:   Mon May 4 16:51:29 2020 +0800

    MIPS: Use fallthrough for arch/mips
    
    Convert the various /* fallthrough */ comments to the pseudo-keyword
    fallthrough;
    
    Done via script:
    https://lore.kernel.org/lkml/b56602fcf79f849e733e7b521bb0e17895d390fa.1582230379.git.joe@perches.com/
    
    Signed-off-by: Liangliang Huang <huangll@lemote.com>
    Reviewed-by: Huacai Chen <chenhc@lemote.com>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index e2f503fc7a84..6a77bc4a6eec 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -49,7 +49,7 @@ static inline unsigned int page_size_ftlb(unsigned int mmuextdef)
 			return 6;
 		if (PAGE_SIZE > (256 << 10))
 			return 7; /* reserved */
-			/* fall through */
+		fallthrough;
 	case MIPS_CONF4_MMUEXTDEF_VTLBSIZEEXT:
 		return (PAGE_SHIFT - 10) / 2;
 	default:

commit c62da0c35d58518ddb26ff641d2485596567fd96
Author: Anshuman Khandual <anshuman.khandual@arm.com>
Date:   Fri Apr 10 14:33:05 2020 -0700

    mm/vma: define a default value for VM_DATA_DEFAULT_FLAGS
    
    There are many platforms with exact same value for VM_DATA_DEFAULT_FLAGS
    This creates a default value for VM_DATA_DEFAULT_FLAGS in line with the
    existing VM_STACK_DEFAULT_FLAGS.  While here, also define some more
    macros with standard VMA access flag combinations that are used
    frequently across many platforms.  Apart from simplification, this
    reduces code duplication as well.
    
    Signed-off-by: Anshuman Khandual <anshuman.khandual@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Vlastimil Babka <vbabka@suse.cz>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paulburton@kernel.org>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: "James E.J. Bottomley" <James.Bottomley@HansenPartnership.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Rich Felker <dalias@libc.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Chris Zankel <chris@zankel.net>
    Link: http://lkml.kernel.org/r/1583391014-8170-2-git-send-email-anshuman.khandual@arm.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index 0ba4ce6e2bf3..e2f503fc7a84 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -253,10 +253,7 @@ extern bool __virt_addr_valid(const volatile void *kaddr);
 #define virt_addr_valid(kaddr)						\
 	__virt_addr_valid((const volatile void *) (kaddr))
 
-#define VM_DATA_DEFAULT_FLAGS \
-	(VM_READ | VM_WRITE | \
-	 ((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0) | \
-	 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+#define VM_DATA_DEFAULT_FLAGS	VM_DATA_FLAGS_TSK_EXEC
 
 #include <asm-generic/memory_model.h>
 #include <asm-generic/getorder.h>

commit 9e3a25dc992dd9f3170fb643bdd95da5ca9c5576
Merge: 9787aed57dd3 15ffe5e1acf5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 12 15:13:55 2019 -0700

    Merge tag 'dma-mapping-5.3' of git://git.infradead.org/users/hch/dma-mapping
    
    Pull dma-mapping updates from Christoph Hellwig:
    
     - move the USB special case that bounced DMA through a device bar into
       the USB code instead of handling it in the common DMA code (Laurentiu
       Tudor and Fredrik Noring)
    
     - don't dip into the global CMA pool for single page allocations
       (Nicolin Chen)
    
     - fix a crash when allocating memory for the atomic pool failed during
       boot (Florian Fainelli)
    
     - move support for MIPS-style uncached segments to the common code and
       use that for MIPS and nios2 (me)
    
     - make support for DMA_ATTR_NON_CONSISTENT and
       DMA_ATTR_NO_KERNEL_MAPPING generic (me)
    
     - convert nds32 to the generic remapping allocator (me)
    
    * tag 'dma-mapping-5.3' of git://git.infradead.org/users/hch/dma-mapping: (29 commits)
      dma-mapping: mark dma_alloc_need_uncached as __always_inline
      MIPS: only select ARCH_HAS_UNCACHED_SEGMENT for non-coherent platforms
      usb: host: Fix excessive alignment restriction for local memory allocations
      lib/genalloc.c: Add algorithm, align and zeroed family of DMA allocators
      nios2: use the generic uncached segment support in dma-direct
      nds32: use the generic remapping allocator for coherent DMA allocations
      arc: use the generic remapping allocator for coherent DMA allocations
      dma-direct: handle DMA_ATTR_NO_KERNEL_MAPPING in common code
      dma-direct: handle DMA_ATTR_NON_CONSISTENT in common code
      dma-mapping: add a dma_alloc_need_uncached helper
      openrisc: remove the partial DMA_ATTR_NON_CONSISTENT support
      arc: remove the partial DMA_ATTR_NON_CONSISTENT support
      arm-nommu: remove the partial DMA_ATTR_NON_CONSISTENT support
      ARM: dma-mapping: allow larger DMA mask than supported
      dma-mapping: truncate dma masks to what dma_addr_t can hold
      iommu/dma: Apply dma_{alloc,free}_contiguous functions
      dma-remap: Avoid de-referencing NULL atomic_pool
      MIPS: use the generic uncached segment support in dma-direct
      dma-direct: provide generic support for uncached kernel segments
      au1100fb: fix DMA API abuse
      ...

commit 2e96e04d25caaca8039ba9561e7e02ee8a192553
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Apr 28 13:57:39 2019 -0500

    MIPS: use the generic uncached segment support in dma-direct
    
    Stop providing the arch alloc/free hooks and just expose the segment
    offset instead.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Paul Burton <paul.burton@mips.com>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index 6b31c93b5eaa..23e0f1386e04 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -258,9 +258,6 @@ extern int __virt_addr_valid(const volatile void *kaddr);
 	 ((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0) | \
 	 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
-#define UNCAC_ADDR(addr)	(UNCAC_BASE + __pa(addr))
-#define CAC_ADDR(addr)		((unsigned long)__va((addr) - UNCAC_BASE))
-
 #include <asm-generic/memory_model.h>
 #include <asm-generic/getorder.h>
 

commit 31875a5432248e7b0fff2f4f4e8cd96e5d82ceb0
Author: Paul Burton <paul.burton@mips.com>
Date:   Tue May 28 17:05:04 2019 +0000

    MIPS: Make virt_addr_valid() return bool
    
    virt_addr_valid() really returns a boolean value, but currently uses an
    integer to represent it. Switch to the bool type to make it clearer that
    we really are returning a true or false value.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Reviewed-by: Philippe Mathieu-Daudé <f4bug@amsat.org>
    Tested-by: Philippe Mathieu-Daudé <f4bug@amsat.org>
    Cc: linux-mips@vger.kernel.org

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index 6b31c93b5eaa..a25643d258cb 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -249,7 +249,7 @@ static inline int pfn_valid(unsigned long pfn)
 #define virt_to_pfn(kaddr)   	PFN_DOWN(virt_to_phys((void *)(kaddr)))
 #define virt_to_page(kaddr)	pfn_to_page(virt_to_pfn(kaddr))
 
-extern int __virt_addr_valid(const volatile void *kaddr);
+extern bool __virt_addr_valid(const volatile void *kaddr);
 #define virt_addr_valid(kaddr)						\
 	__virt_addr_valid((const volatile void *) (kaddr))
 

commit b3a428b4b18d495a06f39515568850f8db4c98ea
Author: Hassan Naveed <hnaveed@wavecomp.com>
Date:   Mon Oct 29 18:27:41 2018 -0700

    MIPS: Enable IOREMAP_PROT config option for MIPS cpus
    
    Allows the users of ptrace to access memory mapped by the ptraced process
    using the same cache coherency attributes as the original process.
    For example while using gdb with ioremap_prot() incorporated, both gdb and
    the process being traced will have same cache coherency attributes.
    
    Signed-off-by: Hassan Naveed <hnaveed@wavecomp.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Patchwork: https://patchwork.linux-mips.org/patch/20955/
    Cc: <linux-mips@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index e8cc328fce2d..6b31c93b5eaa 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -154,6 +154,7 @@ typedef struct { unsigned long pgd; } pgd_t;
 typedef struct { unsigned long pgprot; } pgprot_t;
 #define pgprot_val(x)	((x).pgprot)
 #define __pgprot(x)	((pgprot_t) { (x) } )
+#define pte_pgprot(x)	__pgprot(pte_val(x) & ~_PFN_MASK)
 
 /*
  * On R4000-style MMUs where a TLB entry is mapping a adjacent even / odd

commit 6c359eb1dcdb721908f4336171ed8eb6d78190c5
Author: Paul Burton <paul.burton@mips.com>
Date:   Fri Jul 27 18:23:20 2018 -0700

    MIPS: Allow auto-dection of ARCH_PFN_OFFSET & PHYS_OFFSET
    
    On systems where physical memory begins at a non-zero address, defining
    PHYS_OFFSET (which influences ARCH_PFN_OFFSET) can save us time & memory
    by avoiding book-keeping for pages from address zero to the start of
    memory.
    
    Some MIPS platforms already make use of this, but with the definition of
    PHYS_OFFSET being compile-time constant it hasn't been possible to
    enable this optimization for a kernel which may run on systems with
    varying physical memory base addresses.
    
    Introduce a new Kconfig option CONFIG_MIPS_AUTO_PFN_OFFSET which, when
    enabled, makes ARCH_PFN_OFFSET a variable & detects it from the boot
    memory map (which for example may have been populated from DT). The
    relationship with PHYS_OFFSET is reversed, with PHYS_OFFSET now being
    based on ARCH_PFN_OFFSET. This is because ARCH_PFN_OFFSET is used far
    more often, so avoiding the need for runtime calculation gives us a
    smaller impact on kernel text size (0.1% rather than 0.15% for
    64r6el_defconfig).
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Suggested-by: Vladimir Kondratiev <vladimir.kondratiev@intel.com>
    Patchwork: https://patchwork.linux-mips.org/patch/20048/
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index a051b82f8009..e8cc328fce2d 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -80,7 +80,12 @@ extern void build_copy_page(void);
  * used in our early mem init code for all memory models.
  * So always define it.
  */
-#define ARCH_PFN_OFFSET		PFN_UP(PHYS_OFFSET)
+#ifdef CONFIG_MIPS_AUTO_PFN_OFFSET
+extern unsigned long ARCH_PFN_OFFSET;
+# define ARCH_PFN_OFFSET	ARCH_PFN_OFFSET
+#else
+# define ARCH_PFN_OFFSET	PFN_UP(PHYS_OFFSET)
+#endif
 
 extern void clear_page(void * page);
 extern void copy_page(void * to, void * from);

commit 0d0e14770d4487a7ede8df93d82305cbfac2d453
Author: Paul Burton <paul.burton@mips.com>
Date:   Fri Jul 27 18:23:18 2018 -0700

    MIPS: Make (UN)CAC_ADDR() PHYS_OFFSET-agnostic
    
    Converting an address between cached & uncached (typically addresses in
    (c)kseg0 & (c)kseg1 or 2 xkphys regions) should not depend upon
    PHYS_OFFSET in any way - we're converting from a virtual address in one
    unmapped region to a virtual address in another unmapped region.
    
    For some reason our CAC_ADDR() & UNCAC_ADDR() macros make use of
    PAGE_OFFSET, which typically includes PHYS_OFFSET. This means that
    platforms with a non-zero PHYS_OFFSET typically have to workaround
    miscalculation by these 2 macros by also defining UNCAC_BASE to a value
    that isn't really correct.
    
    It appears that an attempt has previously been made to address this with
    commit 3f4579252aa1 ("MIPS: make CAC_ADDR and UNCAC_ADDR account for
    PHYS_OFFSET") which was later undone by commit ed3ce16c3d2b ("Revert
    "MIPS: make CAC_ADDR and UNCAC_ADDR account for PHYS_OFFSET"") which
    also introduced the ar7 workaround. That attempt at a fix was roughly
    equivalent, but essentially caused the CAC_ADDR() & UNCAC_ADDR() macros
    to cancel out PHYS_OFFSET by adding & then subtracting it again. In his
    revert Leonid is correct that using PHYS_OFFSET makes no sense in the
    context of these macros, but appears to have missed its inclusion via
    PAGE_OFFSET which means PHYS_OFFSET actually had an effect after the
    revert rather than before it.
    
    Here we fix this by modifying CAC_ADDR() & UNCAC_ADDR() to stop using
    PAGE_OFFSET (& thus PHYS_OFFSET), instead using __pa() & __va() along
    with UNCAC_BASE.
    
    For UNCAC_ADDR(), __pa() will convert a cached address to a physical
    address which we can simply use as an offset from UNCAC_BASE to obtain
    an address in the uncached region.
    
    For CAC_ADDR() we can undo the effect of UNCAC_ADDR() by subtracting
    UNCAC_BASE and using __va() on the result.
    
    With this change made, remove definitions of UNCAC_BASE from the ar7 &
    pic32 platforms which appear to have defined them only to workaround
    this problem.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    References: 3f4579252aa1 ("MIPS: make CAC_ADDR and UNCAC_ADDR account for PHYS_OFFSET")
    References: ed3ce16c3d2b ("Revert "MIPS: make CAC_ADDR and UNCAC_ADDR account for PHYS_OFFSET"")
    Patchwork: https://patchwork.linux-mips.org/patch/20046/
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Cc: Vladimir Kondratiev <vladimir.kondratiev@intel.com>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index ad461216b5a1..a051b82f8009 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -252,8 +252,8 @@ extern int __virt_addr_valid(const volatile void *kaddr);
 	 ((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0) | \
 	 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
-#define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE)
-#define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET)
+#define UNCAC_ADDR(addr)	(UNCAC_BASE + __pa(addr))
+#define CAC_ADDR(addr)		((unsigned long)__va((addr) - UNCAC_BASE))
 
 #include <asm-generic/memory_model.h>
 #include <asm-generic/getorder.h>

commit 37d15948eb72533757ff352cf6f92dc64daa291f
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu Mar 9 13:11:49 2017 -0800

    MIPS: page.h: Define virt_to_pfn()
    
    Define virt_to_pfn() based on the existing definition of virt_to_page()
    which already does a PFN_DOWN(vir_to_phys(kaddr)).
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/15409/
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index 5f987598054f..ad461216b5a1 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -240,8 +240,8 @@ static inline int pfn_valid(unsigned long pfn)
 
 #endif
 
-#define virt_to_page(kaddr)	pfn_to_page(PFN_DOWN(virt_to_phys((void *)     \
-								  (kaddr))))
+#define virt_to_pfn(kaddr)   	PFN_DOWN(virt_to_phys((void *)(kaddr)))
+#define virt_to_page(kaddr)	pfn_to_page(virt_to_pfn(kaddr))
 
 extern int __virt_addr_valid(const volatile void *kaddr);
 #define virt_addr_valid(kaddr)						\

commit a5ff1b34e16c203397542d98c49c5c7783193946
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Aug 25 15:17:02 2016 -0700

    treewide: replace config_enabled() with IS_ENABLED() (2nd round)
    
    Commit 97f2645f358b ("tree-wide: replace config_enabled() with
    IS_ENABLED()") mostly killed config_enabled(), but some new users have
    appeared for v4.8-rc1.  They are all used for a boolean option, so can
    be replaced with IS_ENABLED() safely.
    
    Link: http://lkml.kernel.org/r/1471970749-24867-1-git-send-email-yamada.masahiro@socionext.com
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Peter Oberparleiter <oberpar@linux.vnet.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index ea0cd9773914..5f987598054f 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -164,7 +164,7 @@ typedef struct { unsigned long pgprot; } pgprot_t;
  */
 static inline unsigned long ___pa(unsigned long x)
 {
-	if (config_enabled(CONFIG_64BIT)) {
+	if (IS_ENABLED(CONFIG_64BIT)) {
 		/*
 		 * For MIPS64 the virtual address may either be in one of
 		 * the compatibility segements ckseg0 or ckseg1, or it may
@@ -173,7 +173,7 @@ static inline unsigned long ___pa(unsigned long x)
 		return x < CKSEG0 ? XPHYSADDR(x) : CPHYSADDR(x);
 	}
 
-	if (!config_enabled(CONFIG_EVA)) {
+	if (!IS_ENABLED(CONFIG_EVA)) {
 		/*
 		 * We're using the standard MIPS32 legacy memory map, ie.
 		 * the address x is going to be in kseg0 or kseg1. We can

commit 0d8d83d0447deb526c3125250eb391b5d76a3472
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Tue Aug 2 11:40:57 2016 +0100

    MIPS: Use CPHYSADDR to implement mips32 __pa
    
    Use CPHYSADDR to implement the __pa macro converting from a virtual to a
    physical address for MIPS32, much as is already done for MIPS64 (though
    without the complication of having both compatibility & XKPHYS
    segments).
    
    This allows for __pa to work regardless of whether the address being
    translated is in kseg0 or kseg1, unlike the previous subtraction based
    approach which only worked for addresses in kseg0. Working for kseg1
    addresses is important if __pa is used on addresses allocated by
    dma_alloc_coherent, where on systems with non-coherent I/O we provide
    addresses in kseg1. If this address is then used with
    dma_map_single_attrs then it is provided to virt_to_page, which in turn
    calls virt_to_phys which is a wrapper around __pa. The result is that we
    end up with a physical address 0x20000000 bytes (ie. the size of kseg0)
    too high.
    
    In addition to providing consistency with MIPS64 & fixing the kseg1 case
    above this has the added bonus of generating smaller code for systems
    implementing MIPS32r2 & beyond, where a single ext instruction can
    extract the physical address rather than needing to load an immediate
    into a temp register & subtract it. This results in ~1.3KB savings for a
    boston_defconfig kernel adjusted to set CONFIG_32BIT=y.
    
    This patch does not change the EVA case, which may or may not have
    similar issues around handling both cached & uncached addresses but is
    beyond the scope of this patch.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/13836/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index 74cb004c2868..ea0cd9773914 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -162,16 +162,34 @@ typedef struct { unsigned long pgprot; } pgprot_t;
 /*
  * __pa()/__va() should be used only during mem init.
  */
-#ifdef CONFIG_64BIT
-#define __pa(x)								\
-({									\
-    unsigned long __x = (unsigned long)(x);				\
-    __x < CKSEG0 ? XPHYSADDR(__x) : CPHYSADDR(__x);			\
-})
-#else
-#define __pa(x)								\
-    ((unsigned long)(x) - PAGE_OFFSET + PHYS_OFFSET)
-#endif
+static inline unsigned long ___pa(unsigned long x)
+{
+	if (config_enabled(CONFIG_64BIT)) {
+		/*
+		 * For MIPS64 the virtual address may either be in one of
+		 * the compatibility segements ckseg0 or ckseg1, or it may
+		 * be in xkphys.
+		 */
+		return x < CKSEG0 ? XPHYSADDR(x) : CPHYSADDR(x);
+	}
+
+	if (!config_enabled(CONFIG_EVA)) {
+		/*
+		 * We're using the standard MIPS32 legacy memory map, ie.
+		 * the address x is going to be in kseg0 or kseg1. We can
+		 * handle either case by masking out the desired bits using
+		 * CPHYSADDR.
+		 */
+		return CPHYSADDR(x);
+	}
+
+	/*
+	 * EVA is in use so the memory map could be anything, making it not
+	 * safe to just mask out bits.
+	 */
+	return x - PAGE_OFFSET + PHYS_OFFSET;
+}
+#define __pa(x)		___pa((unsigned long)(x))
 #define __va(x)		((void *)((unsigned long)(x) + PAGE_OFFSET - PHYS_OFFSET))
 #include <asm/io.h>
 

commit 1a770b85c1f1c1ee37afd7cef5237ffc4c970f04
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Fri Jul 8 11:06:20 2016 +0100

    MIPS: non-exec stack & heap when non-exec PT_GNU_STACK is present
    
    The stack and heap have both been executable by default on MIPS until
    now. This patch changes the default to be non-executable, but only for
    ELF binaries with a non-executable PT_GNU_STACK header present. This
    does apply to both the heap & the stack, despite the name PT_GNU_STACK,
    and this matches the behaviour of other architectures like ARM & x86.
    
    Current MIPS toolchains do not produce the PT_GNU_STACK header, which
    means that we can rely upon this patch not changing the behaviour of
    existing binaries. The new default will only take effect for newly
    compiled binaries once toolchains are updated to support PT_GNU_STACK,
    and since those binaries are newly compiled they can be compiled
    expecting the change in default behaviour. Again this matches the way in
    which the ARM & x86 architectures handled their implementations of
    non-executable memory.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: Leonid Yegoshin <leonid.yegoshin@imgtec.com>
    Cc: Maciej Rozycki <maciej.rozycki@imgtec.com>
    Cc: Faraz Shahbazker <faraz.shahbazker@imgtec.com>
    Cc: Raghu Gandham <raghu.gandham@imgtec.com>
    Cc: Matthew Fortune <matthew.fortune@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/13765/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index 21ed7150fec3..74cb004c2868 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -229,8 +229,10 @@ extern int __virt_addr_valid(const volatile void *kaddr);
 #define virt_addr_valid(kaddr)						\
 	__virt_addr_valid((const volatile void *) (kaddr))
 
-#define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
-				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+#define VM_DATA_DEFAULT_FLAGS \
+	(VM_READ | VM_WRITE | \
+	 ((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0) | \
+	 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
 #define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE)
 #define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET)

commit 800dc4f49cc002879e1e5e6b79926f86b60528e6
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jan 22 09:20:37 2016 -0800

    Revert "MIPS: Fix PAGE_MASK definition"
    
    This reverts commit 22b14523994588279ae9c5ccfe64073c1e5b3c00.
    
    It was originally sent in an earlier revision of the pfn_t patchset.
    Besides being broken, the warning is also fixed by PFN_FLAGS_MASK
    casting the PAGE_MASK to an unsigned long.
    
    Reported-by: Manuel Lauss <manuel.lauss@gmail.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Cc: linux-kernel@vger.kernel.org
    Cc: Linux-MIPS <linux-mips@linux-mips.org>
    Cc: stable@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/12182/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index 2046c0230224..21ed7150fec3 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -33,7 +33,7 @@
 #define PAGE_SHIFT	16
 #endif
 #define PAGE_SIZE	(_AC(1,UL) << PAGE_SHIFT)
-#define PAGE_MASK	(~(PAGE_SIZE - 1))
+#define PAGE_MASK	(~((1 << PAGE_SHIFT) - 1))
 
 /*
  * This is used for calculating the real page sizes

commit 95486e4979e56e7da2fbb4fd32eb54d672b1e074
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Nov 16 12:07:10 2015 +0100

    MIPS: Fix flood of warnings about comparsion being always true.
    
    ./arch/mips/include/asm/page.h:204:13: warning: comparison of unsigned expression &gt;= 0 is always true [-Wtype-limits]
    
    The default value of ARCH_PFN_OFFSET is 0 thus triggering this warning
    for all platforms using the default value.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index ad1fccdb8d13..2046c0230224 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -200,8 +200,9 @@ static inline int pfn_valid(unsigned long pfn)
 {
 	/* avoid <linux/mm.h> include hell */
 	extern unsigned long max_mapnr;
+	unsigned long pfn_offset = ARCH_PFN_OFFSET;
 
-	return pfn >= ARCH_PFN_OFFSET && pfn < max_mapnr;
+	return pfn >= pfn_offset && pfn < max_mapnr;
 }
 
 #elif defined(CONFIG_SPARSEMEM)

commit 22b14523994588279ae9c5ccfe64073c1e5b3c00
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Oct 9 20:56:28 2015 -0400

    MIPS: Fix PAGE_MASK definition
    
    Make PAGE_MASK an unsigned long, like it is on x86, to avoid:
    
    In file included from arch/mips/kernel/asm-offsets.c:14:0:
    include/linux/mm.h: In function '__pfn_to_pfn_t':
    include/linux/mm.h:1050:2: warning: left shift count >= width of type
      pfn_t pfn_t = { .val = pfn | (flags & PFN_FLAGS_MASK), };
    
    ...where PFN_FLAGS_MASK is:
    
    #define PFN_FLAGS_MASK (~PAGE_MASK << (BITS_PER_LONG - PAGE_SHIFT))
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Cc: ross.zwisler@linux.intel.com
    Cc: hch@lst.de
    Cc: linux-mips@linux-mips.org
    Cc: linux-nvdimm@lists.01.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-mm@kvack.org
    Patchwork: https://patchwork.linux-mips.org/patch/11280/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index 89dd7fed1a57..ad1fccdb8d13 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -33,7 +33,7 @@
 #define PAGE_SHIFT	16
 #endif
 #define PAGE_SIZE	(_AC(1,UL) << PAGE_SHIFT)
-#define PAGE_MASK	(~((1 << PAGE_SHIFT) - 1))
+#define PAGE_MASK	(~(PAGE_SIZE - 1))
 
 /*
  * This is used for calculating the real page sizes

commit 12a8471de9e8dc3c867e15bbf4a37152d2f690b8
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Wed Feb 11 13:27:19 2015 -0800

    MIPS: Remove prototype for copy_user_page
    
    MIPS architecture code does not provide copy_user_page,
    so it should not provide a prototype for it either.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/9266/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index 154b70a10483..89dd7fed1a57 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -105,8 +105,6 @@ static inline void clear_user_page(void *addr, unsigned long vaddr,
 		flush_data_cache_page((unsigned long)addr);
 }
 
-extern void copy_user_page(void *vto, void *vfrom, unsigned long vaddr,
-	struct page *to);
 struct vm_area_struct;
 extern void copy_user_highpage(struct page *to, struct page *from,
 	unsigned long vaddr, struct vm_area_struct *vma);

commit 34adb28d500e644cc260da4ceb66ba6dc0beaf93
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Nov 22 00:16:48 2014 +0100

    MIPS: Replace MIPS-specific 64BIT_PHYS_ADDR with generic PHYS_ADDR_T_64BIT
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index 3be81803595d..154b70a10483 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -116,7 +116,7 @@ extern void copy_user_highpage(struct page *to, struct page *from,
 /*
  * These are used to make use of C type-checking..
  */
-#ifdef CONFIG_64BIT_PHYS_ADDR
+#ifdef CONFIG_PHYS_ADDR_T_64BIT
   #ifdef CONFIG_CPU_MIPS32
     typedef struct { unsigned long pte_low, pte_high; } pte_t;
     #define pte_val(x)	  ((x).pte_low | ((unsigned long long)(x).pte_high << 32))

commit 4d5b3bdc0ecb0cf5b1e1598eeaaac4b5cb33868d
Author: Zubair Lutfullah Kakakhel <Zubair.Kakakhel@imgtec.com>
Date:   Mon Jul 14 16:39:19 2014 +0100

    MIPS: Fix a warning for virt_to_page
    
    Compiling mm/highmem.c gives a warning: passing argument 1 of
    'virt_to_phys' makes pointer from integer without a cast
    
    Fixed by casting to void*
    
    Signed-off-by: Zubair Lutfullah Kakakhel <Zubair.Kakakhel@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/7337/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index e4ef8343ad51..3be81803595d 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -223,7 +223,8 @@ static inline int pfn_valid(unsigned long pfn)
 
 #endif
 
-#define virt_to_page(kaddr)	pfn_to_page(PFN_DOWN(virt_to_phys(kaddr)))
+#define virt_to_page(kaddr)	pfn_to_page(PFN_DOWN(virt_to_phys((void *)     \
+								  (kaddr))))
 
 extern int __virt_addr_valid(const volatile void *kaddr);
 #define virt_addr_valid(kaddr)						\

commit 91ff7ac0a35fe375caeb649cca17d8c00c79fa32
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Aug 25 10:50:12 2014 +0200

    MIPS: Spelling s/confugrations/configurations/
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Jiri Kosina <trivial@kernel.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/7573/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index 5699ec3a71af..e4ef8343ad51 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -37,7 +37,7 @@
 
 /*
  * This is used for calculating the real page sizes
- * for FTLB or VTLB + FTLB confugrations.
+ * for FTLB or VTLB + FTLB configurations.
  */
 static inline unsigned int page_size_ftlb(unsigned int mmuextdef)
 {

commit 27b3db2031d3c293fd19ff99a6bd0752384db56f
Author: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
Date:   Thu Jan 9 13:06:34 2014 +0000

    MIPS: asm: page: Allow __pa_symbol overrides
    
    This will allow platforms to use an alternative way to get
    the physical address of a symbol.
    
    Signed-off-by: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index 5e08bcc74897..5699ec3a71af 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -190,7 +190,9 @@ typedef struct { unsigned long pgprot; } pgprot_t;
  * https://patchwork.linux-mips.org/patch/1541/
  */
 
+#ifndef __pa_symbol
 #define __pa_symbol(x)	__pa(RELOC_HIDE((unsigned long)(x), 0))
+#endif
 
 #define pfn_to_kaddr(pfn)	__va((pfn) << PAGE_SHIFT)
 

commit 75b5b5e0a262790fa11043fe45700499c7e3d818
Author: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
Date:   Thu Nov 14 16:12:31 2013 +0000

    MIPS: Add support for FTLBs
    
    The Fixed Page Size TLB (FTLB) is a set-associative dual entry TLB. Its
    purpose is to reduce the number of TLB misses by increasing the effective
    TLB size and keep the implementation complexity to minimum levels.
    A supported core can have both VTLB and FTLB.
    
    Reviewed-by: James Hogan <james.hogan@imgtec.com>
    Reviewed-by: Paul Burton <paul.burton@imgtec.com>
    Signed-off-by: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/6139/

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index f6be4741f7e8..5e08bcc74897 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -11,6 +11,8 @@
 
 #include <spaces.h>
 #include <linux/const.h>
+#include <linux/kernel.h>
+#include <asm/mipsregs.h>
 
 /*
  * PAGE_SHIFT determines the page size
@@ -33,6 +35,29 @@
 #define PAGE_SIZE	(_AC(1,UL) << PAGE_SHIFT)
 #define PAGE_MASK	(~((1 << PAGE_SHIFT) - 1))
 
+/*
+ * This is used for calculating the real page sizes
+ * for FTLB or VTLB + FTLB confugrations.
+ */
+static inline unsigned int page_size_ftlb(unsigned int mmuextdef)
+{
+	switch (mmuextdef) {
+	case MIPS_CONF4_MMUEXTDEF_FTLBSIZEEXT:
+		if (PAGE_SIZE == (1 << 30))
+			return 5;
+		if (PAGE_SIZE == (1llu << 32))
+			return 6;
+		if (PAGE_SIZE > (256 << 10))
+			return 7; /* reserved */
+			/* fall through */
+	case MIPS_CONF4_MMUEXTDEF_VTLBSIZEEXT:
+		return (PAGE_SHIFT - 10) / 2;
+	default:
+		panic("Invalid FTLB configuration with Conf4_mmuextdef=%d value\n",
+		      mmuextdef >> 14);
+	}
+}
+
 #ifdef CONFIG_MIPS_HUGE_TLB_SUPPORT
 #define HPAGE_SHIFT	(PAGE_SHIFT + PAGE_SHIFT - 3)
 #define HPAGE_SIZE	(_AC(1,UL) << HPAGE_SHIFT)

commit ed3ce16c3d2ba7cac321d29ec0a7d21408ea8437
Author: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
Date:   Thu Jun 20 14:36:30 2013 +0000

    Revert "MIPS: make CAC_ADDR and UNCAC_ADDR account for PHYS_OFFSET"
    
    This reverts commit 3f4579252aa166641861a64f1c2883365ca126c2. It is
    invalid because the macros CAC_ADDR and UNCAC_ADDR have a kernel
    virtual address as an argument and also returns a kernel virtual
    address. Using and physical address PHYS_OFFSET is blatantly wrong
    for a macro common to multiple platforms.
    
    Signed-off-by: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Acked-by: Steven J. Hill <Steven.Hill@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: Florian Fainelli <florian@openwrt.org>
    Patchwork: https://patchwork.linux-mips.org/patch/5528/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index f59552fae917..f6be4741f7e8 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -205,10 +205,8 @@ extern int __virt_addr_valid(const volatile void *kaddr);
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
-#define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE +	\
-								PHYS_OFFSET)
-#define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET -	\
-								PHYS_OFFSET)
+#define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE)
+#define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET)
 
 #include <asm-generic/memory_model.h>
 #include <asm-generic/getorder.h>

commit 8b9232141bf40788cce31f893c13f344ec31ee66
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat May 18 17:02:59 2013 +0200

    MIPS: Rewrite pfn_valid to work in modules, too.
    
    This fixes:
    
      MODPOST 393 modules
    ERROR: "min_low_pfn" [arch/mips/kvm/kvm.ko] undefined!
    make[3]: *** [__modpost] Error 1
    
    It would have been possible to just export min_low_pfn but in the end
    pfn_valid should return 1 for any pfn argument for which a struct page
    exists so using min_low_pfn was wrong anyway.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index ec1ca537fbc1..f59552fae917 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -171,14 +171,13 @@ typedef struct { unsigned long pgprot; } pgprot_t;
 
 #ifdef CONFIG_FLATMEM
 
-#define pfn_valid(pfn)							\
-({									\
-	unsigned long __pfn = (pfn);					\
-	/* avoid <linux/bootmem.h> include hell */			\
-	extern unsigned long min_low_pfn;				\
-									\
-	__pfn >= min_low_pfn && __pfn < max_mapnr;			\
-})
+static inline int pfn_valid(unsigned long pfn)
+{
+	/* avoid <linux/mm.h> include hell */
+	extern unsigned long max_mapnr;
+
+	return pfn >= ARCH_PFN_OFFSET && pfn < max_mapnr;
+}
 
 #elif defined(CONFIG_SPARSEMEM)
 

commit 49c426ba445f83d304a5eab3d49efa123329cf2b
Author: David Daney <david.daney@cavium.com>
Date:   Tue May 7 17:11:16 2013 +0000

    MIPS: Make virt_to_phys() work for all unmapped addresses.
    
    As reported:
      This problem was discovered when doing BGP traffic with the TCP MD5 option
      activated, where the following call chain caused a crash:
    
       * tcp_v4_rcv
       *  tcp_v4_timewait_ack
       *   tcp_v4_send_ack -> follow stack variable rep.th
       *    tcp_v4_md5_hash_hdr
       *     tcp_md5_hash_header
       *      sg_init_one
       *       sg_set_buf
       *        virt_to_page
    
      I noticed that tcp_v4_send_reset uses a similar stack variable and
      also calls tcp_v4_md5_hash_hdr, so it has the same problem.
    
    The networking core can indirectly call virt_to_phys() on stack
    addresses, if this is done from PID 0, the stack will usually be in
    CKSEG0, so virt_to_phys() needs to work there as well
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Cc: linux-mips@linux-mips.org
    Cc: Jiang Liu <liuj97@gmail.com>
    Cc: eunb.song@samsung.com
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/5220/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index eab99e536b5c..ec1ca537fbc1 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -46,7 +46,6 @@
 #endif /* CONFIG_MIPS_HUGE_TLB_SUPPORT */
 
 #include <linux/pfn.h>
-#include <asm/io.h>
 
 extern void build_clear_page(void);
 extern void build_copy_page(void);
@@ -151,6 +150,7 @@ typedef struct { unsigned long pgprot; } pgprot_t;
     ((unsigned long)(x) - PAGE_OFFSET + PHYS_OFFSET)
 #endif
 #define __va(x)		((void *)((unsigned long)(x) + PAGE_OFFSET - PHYS_OFFSET))
+#include <asm/io.h>
 
 /*
  * RELOC_HIDE was originally added by 6007b903dfe5f1d13e0c711ac2894bdd4a61b1ad

commit 3b5e50edaf500f392f4a372296afc0b99ffa7e70
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Apr 22 17:57:54 2013 +0200

    Revert "MIPS: page.h: Provide more readable definition for PAGE_MASK."
    
    This reverts commit c17a6554782ad531f4713b33fd6339ba67ef6391.
    
    Manuel Lauss writes:
    
    lmo commit c17a6554 (MIPS: page.h: Provide more readable definition for
    PAGE_MASK) apparently breaks ioremap of 36-bit addresses on my Alchemy
    systems (PCI and PCMCIA) The reason is that in arch/mips/mm/ioremap.c
    line 157  (phys_addr &= PAGE_MASK) bits 32-35 are cut off.  Seems the
    new PAGE_MASK is explicitly 32bit, or one could make it signed instead
    of unsigned long.

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index 99fc547af9d3..eab99e536b5c 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -31,7 +31,7 @@
 #define PAGE_SHIFT	16
 #endif
 #define PAGE_SIZE	(_AC(1,UL) << PAGE_SHIFT)
-#define PAGE_MASK	(~(PAGE_SIZE - 1))
+#define PAGE_MASK	(~((1 << PAGE_SHIFT) - 1))
 
 #ifdef CONFIG_MIPS_HUGE_TLB_SUPPORT
 #define HPAGE_SHIFT	(PAGE_SHIFT + PAGE_SHIFT - 3)

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index dbaec94046da..99fc547af9d3 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -31,7 +31,7 @@
 #define PAGE_SHIFT	16
 #endif
 #define PAGE_SIZE	(_AC(1,UL) << PAGE_SHIFT)
-#define PAGE_MASK       (~(PAGE_SIZE - 1))
+#define PAGE_MASK	(~(PAGE_SIZE - 1))
 
 #ifdef CONFIG_MIPS_HUGE_TLB_SUPPORT
 #define HPAGE_SHIFT	(PAGE_SHIFT + PAGE_SHIFT - 3)
@@ -95,11 +95,11 @@ extern void copy_user_highpage(struct page *to, struct page *from,
 #ifdef CONFIG_64BIT_PHYS_ADDR
   #ifdef CONFIG_CPU_MIPS32
     typedef struct { unsigned long pte_low, pte_high; } pte_t;
-    #define pte_val(x)    ((x).pte_low | ((unsigned long long)(x).pte_high << 32))
-    #define __pte(x)      ({ pte_t __pte = {(x), ((unsigned long long)(x)) >> 32}; __pte; })
+    #define pte_val(x)	  ((x).pte_low | ((unsigned long long)(x).pte_high << 32))
+    #define __pte(x)	  ({ pte_t __pte = {(x), ((unsigned long long)(x)) >> 32}; __pte; })
   #else
      typedef struct { unsigned long long pte; } pte_t;
-     #define pte_val(x)	((x).pte)
+     #define pte_val(x) ((x).pte)
      #define __pte(x)	((pte_t) { (x) } )
   #endif
 #else
@@ -191,8 +191,8 @@ typedef struct { unsigned long pgprot; } pgprot_t;
 	unsigned long __pfn = (pfn);					\
 	int __n = pfn_to_nid(__pfn);					\
 	((__n >= 0) ? (__pfn < NODE_DATA(__n)->node_start_pfn +		\
-	                       NODE_DATA(__n)->node_spanned_pages)	\
-	            : 0);						\
+			       NODE_DATA(__n)->node_spanned_pages)	\
+		    : 0);						\
 })
 
 #endif
@@ -206,7 +206,7 @@ extern int __virt_addr_valid(const volatile void *kaddr);
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
-#define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE + 	\
+#define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE +	\
 								PHYS_OFFSET)
 #define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET -	\
 								PHYS_OFFSET)

commit d3ce88431892b703b04769566338a89eda6b0477
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Dec 28 15:34:40 2012 +0100

    MIPS: Fix modpost error in modules attepting to use virt_addr_valid().
    
    ERROR: "min_low_pfn" [drivers/block/aoe/aoe.ko] undefined!
    
    Fixed by moving the implementation of virt_addr_valid() into the kernel
    proper and exporting it which removes the pains of an inline or macro
    implementation.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index bf84e48ad669..dbaec94046da 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -198,7 +198,10 @@ typedef struct { unsigned long pgprot; } pgprot_t;
 #endif
 
 #define virt_to_page(kaddr)	pfn_to_page(PFN_DOWN(virt_to_phys(kaddr)))
-#define virt_addr_valid(kaddr)	pfn_valid(PFN_DOWN(virt_to_phys(kaddr)))
+
+extern int __virt_addr_valid(const volatile void *kaddr);
+#define virt_addr_valid(kaddr)						\
+	__virt_addr_valid((const volatile void *) (kaddr))
 
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)

commit 730b8dfe016dd1e91f73d8d3e6724da91397171c
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Dec 28 15:18:02 2012 +0100

    MIPS: page.h: Remove now unnecessary #ifndef __ASSEMBLY__ wrapper.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index 31ab10f02bad..bf84e48ad669 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -45,8 +45,6 @@
 #define HUGETLB_PAGE_ORDER	({BUILD_BUG(); 0; })
 #endif /* CONFIG_MIPS_HUGE_TLB_SUPPORT */
 
-#ifndef __ASSEMBLY__
-
 #include <linux/pfn.h>
 #include <asm/io.h>
 
@@ -139,8 +137,6 @@ typedef struct { unsigned long pgprot; } pgprot_t;
  */
 #define ptep_buddy(x)	((pte_t *)((unsigned long)(x) ^ sizeof(pte_t)))
 
-#endif /* !__ASSEMBLY__ */
-
 /*
  * __pa()/__va() should be used only during mem init.
  */

commit aa1762f49c81a14d0453e4f67f922e4f155510a3
Author: David Daney <david.daney@cavium.com>
Date:   Wed Oct 17 00:48:10 2012 +0200

    MIPS: Control huge tlb support via Kconfig symbol MIPS_HUGE_TLB_SUPPORT
    
    We need Huge TLBs for HUGETLB_PAGE, or the soon to follow
    TRANSPARENT_HUGEPAGE.  collect this information under a single Kconfig
    symbol.
    
    Signed-off-by: David Daney <david.daney@cavium.com>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index c48a7f0bcf3c..31ab10f02bad 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -33,17 +33,17 @@
 #define PAGE_SIZE	(_AC(1,UL) << PAGE_SHIFT)
 #define PAGE_MASK       (~(PAGE_SIZE - 1))
 
-#ifdef CONFIG_HUGETLB_PAGE
+#ifdef CONFIG_MIPS_HUGE_TLB_SUPPORT
 #define HPAGE_SHIFT	(PAGE_SHIFT + PAGE_SHIFT - 3)
 #define HPAGE_SIZE	(_AC(1,UL) << HPAGE_SHIFT)
 #define HPAGE_MASK	(~(HPAGE_SIZE - 1))
 #define HUGETLB_PAGE_ORDER	(HPAGE_SHIFT - PAGE_SHIFT)
-#else /* !CONFIG_HUGETLB_PAGE */
+#else /* !CONFIG_MIPS_HUGE_TLB_SUPPORT */
 #define HPAGE_SHIFT	({BUILD_BUG(); 0; })
 #define HPAGE_SIZE	({BUILD_BUG(); 0; })
 #define HPAGE_MASK	({BUILD_BUG(); 0; })
 #define HUGETLB_PAGE_ORDER	({BUILD_BUG(); 0; })
-#endif /* CONFIG_HUGETLB_PAGE */
+#endif /* CONFIG_MIPS_HUGE_TLB_SUPPORT */
 
 #ifndef __ASSEMBLY__
 

commit c17a6554782ad531f4713b33fd6339ba67ef6391
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Oct 16 22:20:27 2012 +0200

    MIPS: page.h: Provide more readable definition for PAGE_MASK.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index da9bd7d270d1..c48a7f0bcf3c 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -31,7 +31,7 @@
 #define PAGE_SHIFT	16
 #endif
 #define PAGE_SIZE	(_AC(1,UL) << PAGE_SHIFT)
-#define PAGE_MASK       (~((1 << PAGE_SHIFT) - 1))
+#define PAGE_MASK       (~(PAGE_SIZE - 1))
 
 #ifdef CONFIG_HUGETLB_PAGE
 #define HPAGE_SHIFT	(PAGE_SHIFT + PAGE_SHIFT - 3)

commit 35d1a455b987e6a3768370f05eeced8908e77bcc
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Jan 16 12:38:05 2012 +0100

    MIPS: Remove temporary kludge from <asm/page.h>
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index d41790928c64..da9bd7d270d1 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -39,9 +39,6 @@
 #define HPAGE_MASK	(~(HPAGE_SIZE - 1))
 #define HUGETLB_PAGE_ORDER	(HPAGE_SHIFT - PAGE_SHIFT)
 #else /* !CONFIG_HUGETLB_PAGE */
-# ifndef BUILD_BUG
-#  define BUILD_BUG() do { extern void __build_bug(void); __build_bug(); } while (0)
-# endif
 #define HPAGE_SHIFT	({BUILD_BUG(); 0; })
 #define HPAGE_SIZE	({BUILD_BUG(); 0; })
 #define HPAGE_MASK	({BUILD_BUG(); 0; })

commit f467e4bfb50ca6af042f1b19b3556bd4aca854c3
Author: Hillf Danton <dhillf@gmail.com>
Date:   Wed Jan 11 15:37:13 2012 +0100

    MIPS: Flush huge TLB
    
    When flushing TLB, if @vma is backed by huge page, we could flush huge
    TLB, due to that huge page is defined to be far from normal page.
    
    Signed-off-by: Hillf Danton <dhillf@gmail.com>
    Acked-by: David Daney <david.daney@cavium.com>
    Cc: linux-mips@linux-mips.org
    Cc: "Jayachandran C." <jayachandranc@netlogicmicro.com>
    Patchwork: https://patchwork.linux-mips.org/patch/2825/
    Signed-off-by: David Daney <david.daney@cavium.com>
    Acked-by: Hillf Danton <dhillf@gmail.com>
    Patchwork: https://patchwork.linux-mips.org/patch/3114/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index e59cd1ac09c2..d41790928c64 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -38,6 +38,14 @@
 #define HPAGE_SIZE	(_AC(1,UL) << HPAGE_SHIFT)
 #define HPAGE_MASK	(~(HPAGE_SIZE - 1))
 #define HUGETLB_PAGE_ORDER	(HPAGE_SHIFT - PAGE_SHIFT)
+#else /* !CONFIG_HUGETLB_PAGE */
+# ifndef BUILD_BUG
+#  define BUILD_BUG() do { extern void __build_bug(void); __build_bug(); } while (0)
+# endif
+#define HPAGE_SHIFT	({BUILD_BUG(); 0; })
+#define HPAGE_SIZE	({BUILD_BUG(); 0; })
+#define HPAGE_MASK	({BUILD_BUG(); 0; })
+#define HUGETLB_PAGE_ORDER	({BUILD_BUG(); 0; })
 #endif /* CONFIG_HUGETLB_PAGE */
 
 #ifndef __ASSEMBLY__

commit 5707bf6bcecd85d01ea22e8b28cf66170068475f
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Aug 17 16:01:59 2010 +0100

    MIPS: Document why RELOC_HIDE is there.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index a16beafcea91..e59cd1ac09c2 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -150,6 +150,20 @@ typedef struct { unsigned long pgprot; } pgprot_t;
     ((unsigned long)(x) - PAGE_OFFSET + PHYS_OFFSET)
 #endif
 #define __va(x)		((void *)((unsigned long)(x) + PAGE_OFFSET - PHYS_OFFSET))
+
+/*
+ * RELOC_HIDE was originally added by 6007b903dfe5f1d13e0c711ac2894bdd4a61b1ad
+ * (lmo) rsp. 8431fd094d625b94d364fe393076ccef88e6ce18 (kernel.org).  The
+ * discussion can be found in lkml posting
+ * <a2ebde260608230500o3407b108hc03debb9da6e62c@mail.gmail.com> which is
+ * archived at http://lists.linuxcoding.com/kernel/2006-q3/msg17360.html
+ *
+ * It is unclear if the misscompilations mentioned in
+ * http://lkml.org/lkml/2010/8/8/138 also affect MIPS so we keep this one
+ * until GCC 3.x has been retired before we can apply
+ * https://patchwork.linux-mips.org/patch/1541/
+ */
+
 #define __pa_symbol(x)	__pa(RELOC_HIDE((unsigned long)(x), 0))
 
 #define pfn_to_kaddr(pfn)	__va((pfn) << PAGE_SHIFT)

commit 86f7d75eb7c43a54a7b37a2287787004f4310de6
Author: Florian Fainelli <florian@openwrt.org>
Date:   Wed Mar 10 09:51:09 2010 +0100

    MIPS: make CAC_ADDR and UNCAC_ADDR account for PHYS_OFFSET
    
    On AR7, we already redefine PHYS_OFFSET to match the system specifities, it
    is however not sufficient when unsing dma_{map,unmap}_single, specifically
    in the ethernet driver, we must also adjust CAC_ADDR and UNCAC_ADDR for DMA
    to work correctly. This patch fixes the following issue, seen in cpmac_open:
    
    ops[#1]:
    Cpu 0
    $ 0   : 00000000 10008400 a0f5b120 00000000
    $ 4   : 94c59000 94270f64 00000020 00000010
    $ 8   : 00000010 94103ce0 0000000a 94c03400
    $12   : ffffffff 94c03408 94c03410 00000001
    $16   : a0f5ba20 00000041 94c592c0 94c59200
    $20   : 94c59000 000005ee 00002000 9438c8f0
    $24   : 00000010 00000000
    $28   : 94fac000 94fadd58 94390000 942724a8
    Hi    : 00000000
    Lo    : 00000001
    epc   : 94272518 cpmac_open+0x208/0x3f8
        Not tainted
    ra    : 942724a8 cpmac_open+0x198/0x3f8
    Status: 10008403    KERNEL EXL IE
    Cause : 3080000c
    BadVA : 00000000
    PrId  : 00018448 (MIPS 4KEc)
    Modules linked in:
    Process ifconfig (pid: 278, threadinfo=94fac000, task=94e79590, tls=00000000)
    Stack : 7f8da120 2ab05cb0 94c59000 943356f0 00000000 943d0000 94c59000 943356f0
            94c59030 943d0000 943c27c0 94fade10 00000000 94fade20 94c59000 9428e5a4
            00000000 94c59000 00000041 94289768 94c59000 00000041 00001002 00001043
            00000000 9428d810 00000000 94fade10 7f8da4e8 9428e6b8 00000000 7f8da4a8
            7f8da4e8 00008914 00000000 942f7f2c 00000000 00000008 00408000 00008913
            ...
    Call Trace:
    [<94272518>] cpmac_open+0x208/0x3f8
    [<9428e5a4>] dev_open+0x164/0x264
    [<9428d810>] dev_change_flags+0xd0/0x1bc
    [<942f7f2c>] devinet_ioctl+0x2d8/0x908
    [<942771f8>] sock_ioctl+0x29c/0x2fc
    [<941a0fb4>] vfs_ioctl+0x2c/0x7c
    [<941a16ec>] do_vfs_ioctl+0x5dc/0x630
    [<941a1790>] sys_ioctl+0x50/0x88
    [<94101e10>] stack_done+0x20/0x3c
    
    Signed-off-by: peter fuerst <post@pfrst.de>
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    To: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/1050/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index ac32572430f4..a16beafcea91 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -188,8 +188,10 @@ typedef struct { unsigned long pgprot; } pgprot_t;
 #define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
 				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
-#define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE)
-#define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET)
+#define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE + 	\
+								PHYS_OFFSET)
+#define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET -	\
+								PHYS_OFFSET)
 
 #include <asm-generic/memory_model.h>
 #include <asm-generic/getorder.h>

commit 325f8a0a31df567dbafafc48f8e60f3c1f101a46
Author: David Daney <ddaney@caviumnetworks.com>
Date:   Fri Dec 4 13:52:36 2009 -0800

    MIPS: Two-level pagetables for 64-bit kernels with 64KB pages.
    
    For 64-bit kernels with 64KB pages and two level page tables, there are
    42 bits worth of virtual address space This is larger than the 40 bits of
    virtual address space obtained with the default 4KB Page size and three
    levels, so there are no draw backs for using two level tables with this
    configuration.
    
    Signed-off-by: David Daney <ddaney@caviumnetworks.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/761/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index f266295cce51..ac32572430f4 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -106,18 +106,6 @@ typedef struct { unsigned long pte; } pte_t;
 #endif
 typedef struct page *pgtable_t;
 
-/*
- * For 3-level pagetables we defines these ourselves, for 2-level the
- * definitions are supplied by <asm-generic/pgtable-nopmd.h>.
- */
-#ifdef CONFIG_64BIT
-
-typedef struct { unsigned long pmd; } pmd_t;
-#define pmd_val(x)	((x).pmd)
-#define __pmd(x)	((pmd_t) { (x) } )
-
-#endif
-
 /*
  * Right now we don't support 4-level pagetables, so all pud-related
  * definitions come from <asm-generic/pgtable-nopud.h>.

commit 99502d94c3649c5c5e6e81e323caf422a2f1591c
Author: Nelson Elhage <nelhage@ksplice.com>
Date:   Fri Jul 31 16:58:17 2009 -0400

    MIPS: make page.h constants available to assembly.
    
    page.h includes ifndef __ASSEMBLY__ guards, but PAGE_SIZE and some other
    constants are defined using "1UL", which the assembler does not support.
    Use the _AC macro from const.h to make them available to assembly (and
    linker scripts).
    
    Signed-off-by: Nelson Elhage <nelhage@ksplice.com>
    Signed-off-by: Tim Abbott <tabbott@ksplice.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index 4320239cf4ef..f266295cce51 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -10,6 +10,7 @@
 #define _ASM_PAGE_H
 
 #include <spaces.h>
+#include <linux/const.h>
 
 /*
  * PAGE_SHIFT determines the page size
@@ -29,12 +30,12 @@
 #ifdef CONFIG_PAGE_SIZE_64KB
 #define PAGE_SHIFT	16
 #endif
-#define PAGE_SIZE	(1UL << PAGE_SHIFT)
+#define PAGE_SIZE	(_AC(1,UL) << PAGE_SHIFT)
 #define PAGE_MASK       (~((1 << PAGE_SHIFT) - 1))
 
 #ifdef CONFIG_HUGETLB_PAGE
 #define HPAGE_SHIFT	(PAGE_SHIFT + PAGE_SHIFT - 3)
-#define HPAGE_SIZE	((1UL) << HPAGE_SHIFT)
+#define HPAGE_SIZE	(_AC(1,UL) << HPAGE_SHIFT)
 #define HPAGE_MASK	(~(HPAGE_SIZE - 1))
 #define HUGETLB_PAGE_ORDER	(HPAGE_SHIFT - PAGE_SHIFT)
 #endif /* CONFIG_HUGETLB_PAGE */

commit 87c62a66edd645a9b1ff1f9b00ab20c5a93d8845
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Tue Jul 14 22:37:09 2009 +0900

    MIPS: Fix HPAGE_SIZE redefinition
    
    This patch fixes warnings like this:
      CC      fs/proc/meminfo.o
    In file included from /work/linux/include/linux/mmzone.h:20,
                     from /work/linux/include/linux/gfp.h:4,
                     from /work/linux/include/linux/mm.h:8,
                     from /work/linux/fs/proc/meminfo.c:5:
    /work/linux/arch/mips/include/asm/page.h:36:1: warning: "HPAGE_SIZE" redefined
    In file included from /work/linux/fs/proc/meminfo.c:2:
    /work/linux/include/linux/hugetlb.h:107:1: warning: this is the location of the previous definition
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Acked-by: David Daney <ddaney@caviumnetworks.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index 96a14a426a7c..4320239cf4ef 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -32,10 +32,12 @@
 #define PAGE_SIZE	(1UL << PAGE_SHIFT)
 #define PAGE_MASK       (~((1 << PAGE_SHIFT) - 1))
 
+#ifdef CONFIG_HUGETLB_PAGE
 #define HPAGE_SHIFT	(PAGE_SHIFT + PAGE_SHIFT - 3)
 #define HPAGE_SIZE	((1UL) << HPAGE_SHIFT)
 #define HPAGE_MASK	(~(HPAGE_SIZE - 1))
 #define HUGETLB_PAGE_ORDER	(HPAGE_SHIFT - PAGE_SHIFT)
+#endif /* CONFIG_HUGETLB_PAGE */
 
 #ifndef __ASSEMBLY__
 

commit baf922780251d12bc1c24c83df60c4c278abb745
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Jul 3 07:11:15 2009 +0100

    MIPS: Fix CONFIG_FLATMEM version of pfn_valid()
    
    For systems which do not define PHYS_OFFSET as 0 pfn_valid() may falsely
    have returned 0 on most configurations.  Bug introduced by commit
    752fbeb2e3555c0d236e992f1195fd7ce30e728d (linux-mips.org) rsp.
    6f284a2ce7b8bc49cb8455b1763357897a899abb (kernel.org) titled "[MIPS]
    FLATMEM: introduce PHYS_OFFSET."
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index dc0eaa731281..96a14a426a7c 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -165,7 +165,14 @@ typedef struct { unsigned long pgprot; } pgprot_t;
 
 #ifdef CONFIG_FLATMEM
 
-#define pfn_valid(pfn)		((pfn) >= ARCH_PFN_OFFSET && (pfn) < max_mapnr)
+#define pfn_valid(pfn)							\
+({									\
+	unsigned long __pfn = (pfn);					\
+	/* avoid <linux/bootmem.h> include hell */			\
+	extern unsigned long min_low_pfn;				\
+									\
+	__pfn >= min_low_pfn && __pfn < max_mapnr;			\
+})
 
 #elif defined(CONFIG_SPARSEMEM)
 

commit dd7943920b492d9d8a79080fe05e25ecd7e10bc3
Author: David Daney <ddaney@caviumnetworks.com>
Date:   Wed May 27 17:47:43 2009 -0700

    MIPS: Add hugetlbfs page defines.
    
    Signed-off-by: David Daney <ddaney@caviumnetworks.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index 72c80d2034c2..dc0eaa731281 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -32,6 +32,11 @@
 #define PAGE_SIZE	(1UL << PAGE_SHIFT)
 #define PAGE_MASK       (~((1 << PAGE_SHIFT) - 1))
 
+#define HPAGE_SHIFT	(PAGE_SHIFT + PAGE_SHIFT - 3)
+#define HPAGE_SIZE	((1UL) << HPAGE_SHIFT)
+#define HPAGE_MASK	(~(HPAGE_SIZE - 1))
+#define HUGETLB_PAGE_ORDER	(HPAGE_SHIFT - PAGE_SHIFT)
+
 #ifndef __ASSEMBLY__
 
 #include <linux/pfn.h>

commit 5b17e1cd8928ae65932758ce6478ac6d3e9a86b2
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed May 13 22:56:30 2009 +0000

    asm-generic: rename page.h and uaccess.h
    
    The current asm-generic/page.h only contains the get_order
    function, and asm-generic/uaccess.h only implements
    unaligned accesses. This renames the file to getorder.h
    and uaccess-unaligned.h to make room for new page.h
    and uaccess.h file that will be usable by all simple
    (e.g. nommu) architectures.
    
    Signed-off-by: Remis Lima Baima <remis.developer@googlemail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index 9f946e4ca057..72c80d2034c2 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -189,6 +189,6 @@ typedef struct { unsigned long pgprot; } pgprot_t;
 #define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET)
 
 #include <asm-generic/memory_model.h>
-#include <asm-generic/page.h>
+#include <asm-generic/getorder.h>
 
 #endif /* _ASM_PAGE_H */

commit c52399bece85cd4b157dd772e9f20551f9f18d2f
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Apr 2 14:07:10 2009 +0200

    MIPS: Cavium: Add support for 8k and 32k page sizes.
    
    Beyond the requirements of the architecture standard Cavium also supports
    8k and 32k pages.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: David Daney <ddaney@caviumnetworks.com>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index fe7a88ea066e..9f946e4ca057 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -23,6 +23,9 @@
 #ifdef CONFIG_PAGE_SIZE_16KB
 #define PAGE_SHIFT	14
 #endif
+#ifdef CONFIG_PAGE_SIZE_32KB
+#define PAGE_SHIFT	15
+#endif
 #ifdef CONFIG_PAGE_SIZE_64KB
 #define PAGE_SHIFT	16
 #endif

commit 384740dc49ea651ba350704d13ff6be9976e37fe
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Sep 16 19:48:51 2008 +0200

    MIPS: Move headfiles to new location below arch/mips/include
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
new file mode 100644
index 000000000000..fe7a88ea066e
--- /dev/null
+++ b/arch/mips/include/asm/page.h
@@ -0,0 +1,191 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1994 - 1999, 2000, 03 Ralf Baechle
+ * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
+ */
+#ifndef _ASM_PAGE_H
+#define _ASM_PAGE_H
+
+#include <spaces.h>
+
+/*
+ * PAGE_SHIFT determines the page size
+ */
+#ifdef CONFIG_PAGE_SIZE_4KB
+#define PAGE_SHIFT	12
+#endif
+#ifdef CONFIG_PAGE_SIZE_8KB
+#define PAGE_SHIFT	13
+#endif
+#ifdef CONFIG_PAGE_SIZE_16KB
+#define PAGE_SHIFT	14
+#endif
+#ifdef CONFIG_PAGE_SIZE_64KB
+#define PAGE_SHIFT	16
+#endif
+#define PAGE_SIZE	(1UL << PAGE_SHIFT)
+#define PAGE_MASK       (~((1 << PAGE_SHIFT) - 1))
+
+#ifndef __ASSEMBLY__
+
+#include <linux/pfn.h>
+#include <asm/io.h>
+
+extern void build_clear_page(void);
+extern void build_copy_page(void);
+
+/*
+ * It's normally defined only for FLATMEM config but it's
+ * used in our early mem init code for all memory models.
+ * So always define it.
+ */
+#define ARCH_PFN_OFFSET		PFN_UP(PHYS_OFFSET)
+
+extern void clear_page(void * page);
+extern void copy_page(void * to, void * from);
+
+extern unsigned long shm_align_mask;
+
+static inline unsigned long pages_do_alias(unsigned long addr1,
+	unsigned long addr2)
+{
+	return (addr1 ^ addr2) & shm_align_mask;
+}
+
+struct page;
+
+static inline void clear_user_page(void *addr, unsigned long vaddr,
+	struct page *page)
+{
+	extern void (*flush_data_cache_page)(unsigned long addr);
+
+	clear_page(addr);
+	if (pages_do_alias((unsigned long) addr, vaddr & PAGE_MASK))
+		flush_data_cache_page((unsigned long)addr);
+}
+
+extern void copy_user_page(void *vto, void *vfrom, unsigned long vaddr,
+	struct page *to);
+struct vm_area_struct;
+extern void copy_user_highpage(struct page *to, struct page *from,
+	unsigned long vaddr, struct vm_area_struct *vma);
+
+#define __HAVE_ARCH_COPY_USER_HIGHPAGE
+
+/*
+ * These are used to make use of C type-checking..
+ */
+#ifdef CONFIG_64BIT_PHYS_ADDR
+  #ifdef CONFIG_CPU_MIPS32
+    typedef struct { unsigned long pte_low, pte_high; } pte_t;
+    #define pte_val(x)    ((x).pte_low | ((unsigned long long)(x).pte_high << 32))
+    #define __pte(x)      ({ pte_t __pte = {(x), ((unsigned long long)(x)) >> 32}; __pte; })
+  #else
+     typedef struct { unsigned long long pte; } pte_t;
+     #define pte_val(x)	((x).pte)
+     #define __pte(x)	((pte_t) { (x) } )
+  #endif
+#else
+typedef struct { unsigned long pte; } pte_t;
+#define pte_val(x)	((x).pte)
+#define __pte(x)	((pte_t) { (x) } )
+#endif
+typedef struct page *pgtable_t;
+
+/*
+ * For 3-level pagetables we defines these ourselves, for 2-level the
+ * definitions are supplied by <asm-generic/pgtable-nopmd.h>.
+ */
+#ifdef CONFIG_64BIT
+
+typedef struct { unsigned long pmd; } pmd_t;
+#define pmd_val(x)	((x).pmd)
+#define __pmd(x)	((pmd_t) { (x) } )
+
+#endif
+
+/*
+ * Right now we don't support 4-level pagetables, so all pud-related
+ * definitions come from <asm-generic/pgtable-nopud.h>.
+ */
+
+/*
+ * Finall the top of the hierarchy, the pgd
+ */
+typedef struct { unsigned long pgd; } pgd_t;
+#define pgd_val(x)	((x).pgd)
+#define __pgd(x)	((pgd_t) { (x) } )
+
+/*
+ * Manipulate page protection bits
+ */
+typedef struct { unsigned long pgprot; } pgprot_t;
+#define pgprot_val(x)	((x).pgprot)
+#define __pgprot(x)	((pgprot_t) { (x) } )
+
+/*
+ * On R4000-style MMUs where a TLB entry is mapping a adjacent even / odd
+ * pair of pages we only have a single global bit per pair of pages.  When
+ * writing to the TLB make sure we always have the bit set for both pages
+ * or none.  This macro is used to access the `buddy' of the pte we're just
+ * working on.
+ */
+#define ptep_buddy(x)	((pte_t *)((unsigned long)(x) ^ sizeof(pte_t)))
+
+#endif /* !__ASSEMBLY__ */
+
+/*
+ * __pa()/__va() should be used only during mem init.
+ */
+#ifdef CONFIG_64BIT
+#define __pa(x)								\
+({									\
+    unsigned long __x = (unsigned long)(x);				\
+    __x < CKSEG0 ? XPHYSADDR(__x) : CPHYSADDR(__x);			\
+})
+#else
+#define __pa(x)								\
+    ((unsigned long)(x) - PAGE_OFFSET + PHYS_OFFSET)
+#endif
+#define __va(x)		((void *)((unsigned long)(x) + PAGE_OFFSET - PHYS_OFFSET))
+#define __pa_symbol(x)	__pa(RELOC_HIDE((unsigned long)(x), 0))
+
+#define pfn_to_kaddr(pfn)	__va((pfn) << PAGE_SHIFT)
+
+#ifdef CONFIG_FLATMEM
+
+#define pfn_valid(pfn)		((pfn) >= ARCH_PFN_OFFSET && (pfn) < max_mapnr)
+
+#elif defined(CONFIG_SPARSEMEM)
+
+/* pfn_valid is defined in linux/mmzone.h */
+
+#elif defined(CONFIG_NEED_MULTIPLE_NODES)
+
+#define pfn_valid(pfn)							\
+({									\
+	unsigned long __pfn = (pfn);					\
+	int __n = pfn_to_nid(__pfn);					\
+	((__n >= 0) ? (__pfn < NODE_DATA(__n)->node_start_pfn +		\
+	                       NODE_DATA(__n)->node_spanned_pages)	\
+	            : 0);						\
+})
+
+#endif
+
+#define virt_to_page(kaddr)	pfn_to_page(PFN_DOWN(virt_to_phys(kaddr)))
+#define virt_addr_valid(kaddr)	pfn_valid(PFN_DOWN(virt_to_phys(kaddr)))
+
+#define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
+				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+
+#define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE)
+#define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET)
+
+#include <asm-generic/memory_model.h>
+#include <asm-generic/page.h>
+
+#endif /* _ASM_PAGE_H */
