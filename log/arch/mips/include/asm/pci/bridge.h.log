commit 2634e5a651e74efc415b2eff37116fcb8206b614
Author: Thomas Bogendoerfer <tbogendoerfer@suse.de>
Date:   Thu Jan 9 11:34:27 2020 +0100

    MIPS: PCI: Support mapping of INTB/C/D for pci-xtalk-bridge
    
    Implented mapping of PCI INTB/C/D, which is needed for PCI multifunction
    devices, PCI-PCI bridges and IOC3.
    
    Signed-off-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    Signed-off-by: Paul Burton <paulburton@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/include/asm/pci/bridge.h b/arch/mips/include/asm/pci/bridge.h
index 3bc630ff9ad4..9c476a0400e0 100644
--- a/arch/mips/include/asm/pci/bridge.h
+++ b/arch/mips/include/asm/pci/bridge.h
@@ -806,7 +806,8 @@ struct bridge_controller {
 	unsigned long		baddr;
 	unsigned long		intr_addr;
 	struct irq_domain	*domain;
-	unsigned int		pci_int[8];
+	unsigned int		pci_int[8][2];
+	unsigned int		int_mapping[8][2];
 	u32			ioc3_sid[8];
 	nasid_t			nasid;
 };

commit 5dc76a96e95ae041c1d8e52714bd77576b35919b
Author: Thomas Bogendoerfer <tbogendoerfer@suse.de>
Date:   Thu Oct 3 11:52:30 2019 +0200

    MIPS: PCI: use information from 1-wire PROM for IOC3 detection
    
    IOC3 chips in SGI system are conntected to a bridge ASIC, which has
    a 1-wire prom attached with part number information. This changeset
    uses this information to create PCI subsystem information, which
    the MFD driver uses for further platform device setup.
    
    Signed-off-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Lee Jones <lee.jones@linaro.org>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: linux-doc@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-mips@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Cc: linux-rtc@vger.kernel.org
    Cc: linux-serial@vger.kernel.org

diff --git a/arch/mips/include/asm/pci/bridge.h b/arch/mips/include/asm/pci/bridge.h
index a92cd30b48c9..3bc630ff9ad4 100644
--- a/arch/mips/include/asm/pci/bridge.h
+++ b/arch/mips/include/asm/pci/bridge.h
@@ -807,6 +807,7 @@ struct bridge_controller {
 	unsigned long		intr_addr;
 	struct irq_domain	*domain;
 	unsigned int		pci_int[8];
+	u32			ioc3_sid[8];
 	nasid_t			nasid;
 };
 

commit e6308b6d35ea706c23a589a8c709fa444ff13e17
Author: Thomas Bogendoerfer <tbogendoerfer@suse.de>
Date:   Tue May 7 23:09:15 2019 +0200

    MIPS: SGI-IP27: abstract chipset irq from bridge
    
    Bridge ASIC is widely used in different SGI systems, but the connected
    chipset is either HUB, HEART or BEDROCK. This commit switches to
    irq domain hierarchy for hub and bridge interrupts to get bridge
    setup out of hub interrupt code.
    
    Signed-off-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    [paul.burton@mips.com:
      Resolve conflict with commit 69a07a41d908 ("MIPS: SGI-IP27: rework HUB
      interrupts").]
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/include/asm/pci/bridge.h b/arch/mips/include/asm/pci/bridge.h
index d42b27c97c23..a92cd30b48c9 100644
--- a/arch/mips/include/asm/pci/bridge.h
+++ b/arch/mips/include/asm/pci/bridge.h
@@ -805,6 +805,7 @@ struct bridge_controller {
 	struct bridge_regs	*base;
 	unsigned long		baddr;
 	unsigned long		intr_addr;
+	struct irq_domain	*domain;
 	unsigned int		pci_int[8];
 	nasid_t			nasid;
 };
@@ -819,6 +820,4 @@ struct bridge_controller {
 #define bridge_clr(bc, reg, val)	\
 	__raw_writel(__raw_readl(&bc->base->reg) & ~(val), &bc->base->reg)
 
-extern int request_bridge_irq(struct bridge_controller *bc, int pin);
-
 #endif /* _ASM_PCI_BRIDGE_H */

commit a57140e9a850582ddafdd8f115b78713baaf0d00
Author: Thomas Bogendoerfer <tbogendoerfer@suse.de>
Date:   Tue May 7 23:09:13 2019 +0200

    MIPS: SGI-IP27: use generic PCI driver
    
    Converted bridge code to a platform driver using the PCI generic driver
    framework and use adding platform devices during xtalk scan. This allows
    easier sharing bridge driver for other SGI platforms like IP30 (Octane) and
    IP35 (Origin 3k, Fuel, Tezro).
    
    Signed-off-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    [paul.burton@mips.com:
      - Leave __phys_to_dma(), __dma_to_phys() & pcibus_to_node() in
        arch/mips/pci/pci-ip27.c since the motivation for moving them
        disappeared when the driver stopped being moved to drivers/pci.]
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/include/asm/pci/bridge.h b/arch/mips/include/asm/pci/bridge.h
index 23574c27eb40..d42b27c97c23 100644
--- a/arch/mips/include/asm/pci/bridge.h
+++ b/arch/mips/include/asm/pci/bridge.h
@@ -801,15 +801,12 @@ struct bridge_err_cmdword {
 #define PCI64_ATTR_RMF_SHFT	48
 
 struct bridge_controller {
-	struct pci_controller	pc;
-	struct resource		mem;
-	struct resource		io;
 	struct resource		busn;
 	struct bridge_regs	*base;
-	nasid_t			nasid;
-	unsigned int		widget_id;
-	u64			baddr;
+	unsigned long		baddr;
+	unsigned long		intr_addr;
 	unsigned int		pci_int[8];
+	nasid_t			nasid;
 };
 
 #define BRIDGE_CONTROLLER(bus) \
@@ -824,6 +821,4 @@ struct bridge_controller {
 
 extern int request_bridge_irq(struct bridge_controller *bc, int pin);
 
-extern struct pci_ops bridge_pci_ops;
-
 #endif /* _ASM_PCI_BRIDGE_H */

commit 69a07a41d908f9df48393bbab179daded8cfab66
Author: Thomas Bogendoerfer <tbogendoerfer@suse.de>
Date:   Tue Feb 19 16:57:20 2019 +0100

    MIPS: SGI-IP27: rework HUB interrupts
    
    This commit rearranges the HUB interrupt code by using MIPS_IRQ_CPU
    interrupt handling code and modern Linux IRQ framework features to get
    rid of global arrays. It also adds support for irq affinity setting.
    
    Signed-off-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/include/asm/pci/bridge.h b/arch/mips/include/asm/pci/bridge.h
index 0c5fe3a2d2a9..23574c27eb40 100644
--- a/arch/mips/include/asm/pci/bridge.h
+++ b/arch/mips/include/asm/pci/bridge.h
@@ -808,7 +808,6 @@ struct bridge_controller {
 	struct bridge_regs	*base;
 	nasid_t			nasid;
 	unsigned int		widget_id;
-	unsigned int		irq_cpu;
 	u64			baddr;
 	unsigned int		pci_int[8];
 };
@@ -823,8 +822,7 @@ struct bridge_controller {
 #define bridge_clr(bc, reg, val)	\
 	__raw_writel(__raw_readl(&bc->base->reg) & ~(val), &bc->base->reg)
 
-extern void register_bridge_irq(unsigned int irq);
-extern int request_bridge_irq(struct bridge_controller *bc);
+extern int request_bridge_irq(struct bridge_controller *bc, int pin);
 
 extern struct pci_ops bridge_pci_ops;
 

commit a44d924c81d43ddffc985aca14aeeaf1abd6dd22
Author: Thomas Bogendoerfer <tbogendoerfer@suse.de>
Date:   Tue Feb 19 16:57:16 2019 +0100

    MIPS: SGI-IP27: clean up bridge access and header files
    
    Introduced bridge_read/bridge_write/bridge_set/bridge_clr for accessing
    bridge register and get rid of volatile declarations. Also removed
    all typedefs from arch/mips/include/asm/pci/bridge.h and cleaned up
    language in arch/mips/pci/ops-bridge.c
    
    Signed-off-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/include/asm/pci/bridge.h b/arch/mips/include/asm/pci/bridge.h
index 3206245d1ed6..0c5fe3a2d2a9 100644
--- a/arch/mips/include/asm/pci/bridge.h
+++ b/arch/mips/include/asm/pci/bridge.h
@@ -45,18 +45,21 @@
 
 #ifndef __ASSEMBLY__
 
-/*
- * All accesses to bridge hardware registers must be done
- * using 32-bit loads and stores.
- */
-typedef u32	bridgereg_t;
+#define ATE_V		0x01
+#define ATE_CO		0x02
+#define ATE_PREC	0x04
+#define ATE_PREF	0x08
+#define ATE_BAR		0x10
+
+#define ATE_PFNSHIFT		12
+#define ATE_TIDSHIFT		8
+#define ATE_RMFSHIFT		48
 
-typedef u64	bridge_ate_t;
+#define mkate(xaddr, xid, attr) (((xaddr) & 0x0000fffffffff000ULL) | \
+				 ((xid)<<ATE_TIDSHIFT) | \
+				 (attr))
 
-/* pointers to bridge ATEs
- * are always "pointer to volatile"
- */
-typedef volatile bridge_ate_t  *bridge_ate_p;
+#define BRIDGE_INTERNAL_ATES	128
 
 /*
  * It is generally preferred that hardware registers on the bridge
@@ -65,7 +68,7 @@ typedef volatile bridge_ate_t  *bridge_ate_p;
  * Generated from Bridge spec dated 04oct95
  */
 
-typedef volatile struct bridge_s {
+struct bridge_regs {
 	/* Local Registers			       0x000000-0x00FFFF */
 
 	/* standard widget configuration	       0x000000-0x000057 */
@@ -86,105 +89,105 @@ typedef volatile struct bridge_s {
 #define b_wid_tflush			b_widget.w_tflush
 
 	/* bridge-specific widget configuration 0x000058-0x00007F */
-	bridgereg_t	    _pad_000058;
-	bridgereg_t	    b_wid_aux_err;		/* 0x00005C */
-	bridgereg_t	    _pad_000060;
-	bridgereg_t	    b_wid_resp_upper;		/* 0x000064 */
-	bridgereg_t	    _pad_000068;
-	bridgereg_t	    b_wid_resp_lower;		/* 0x00006C */
-	bridgereg_t	    _pad_000070;
-	bridgereg_t	    b_wid_tst_pin_ctrl;		/* 0x000074 */
-	bridgereg_t	_pad_000078[2];
+	u32	_pad_000058;
+	u32	b_wid_aux_err;		/* 0x00005C */
+	u32	_pad_000060;
+	u32	b_wid_resp_upper;		/* 0x000064 */
+	u32	_pad_000068;
+	u32	b_wid_resp_lower;		/* 0x00006C */
+	u32	_pad_000070;
+	u32	 b_wid_tst_pin_ctrl;		/* 0x000074 */
+	u32	_pad_000078[2];
 
 	/* PMU & Map 0x000080-0x00008F */
-	bridgereg_t	_pad_000080;
-	bridgereg_t	b_dir_map;			/* 0x000084 */
-	bridgereg_t	_pad_000088[2];
+	u32	_pad_000080;
+	u32	b_dir_map;			/* 0x000084 */
+	u32	_pad_000088[2];
 
 	/* SSRAM 0x000090-0x00009F */
-	bridgereg_t	_pad_000090;
-	bridgereg_t	b_ram_perr;			/* 0x000094 */
-	bridgereg_t	_pad_000098[2];
+	u32	_pad_000090;
+	u32	b_ram_perr;			/* 0x000094 */
+	u32	_pad_000098[2];
 
 	/* Arbitration 0x0000A0-0x0000AF */
-	bridgereg_t	_pad_0000A0;
-	bridgereg_t	b_arb;				/* 0x0000A4 */
-	bridgereg_t	_pad_0000A8[2];
+	u32	_pad_0000A0;
+	u32	b_arb;				/* 0x0000A4 */
+	u32	_pad_0000A8[2];
 
 	/* Number In A Can 0x0000B0-0x0000BF */
-	bridgereg_t	_pad_0000B0;
-	bridgereg_t	b_nic;				/* 0x0000B4 */
-	bridgereg_t	_pad_0000B8[2];
+	u32	_pad_0000B0;
+	u32	b_nic;				/* 0x0000B4 */
+	u32	_pad_0000B8[2];
 
 	/* PCI/GIO 0x0000C0-0x0000FF */
-	bridgereg_t	_pad_0000C0;
-	bridgereg_t	b_bus_timeout;			/* 0x0000C4 */
+	u32	_pad_0000C0;
+	u32	b_bus_timeout;			/* 0x0000C4 */
 #define b_pci_bus_timeout b_bus_timeout
 
-	bridgereg_t	_pad_0000C8;
-	bridgereg_t	b_pci_cfg;			/* 0x0000CC */
-	bridgereg_t	_pad_0000D0;
-	bridgereg_t	b_pci_err_upper;		/* 0x0000D4 */
-	bridgereg_t	_pad_0000D8;
-	bridgereg_t	b_pci_err_lower;		/* 0x0000DC */
-	bridgereg_t	_pad_0000E0[8];
+	u32	_pad_0000C8;
+	u32	b_pci_cfg;			/* 0x0000CC */
+	u32	_pad_0000D0;
+	u32	b_pci_err_upper;		/* 0x0000D4 */
+	u32	_pad_0000D8;
+	u32	b_pci_err_lower;		/* 0x0000DC */
+	u32	_pad_0000E0[8];
 #define b_gio_err_lower b_pci_err_lower
 #define b_gio_err_upper b_pci_err_upper
 
 	/* Interrupt 0x000100-0x0001FF */
-	bridgereg_t	_pad_000100;
-	bridgereg_t	b_int_status;			/* 0x000104 */
-	bridgereg_t	_pad_000108;
-	bridgereg_t	b_int_enable;			/* 0x00010C */
-	bridgereg_t	_pad_000110;
-	bridgereg_t	b_int_rst_stat;			/* 0x000114 */
-	bridgereg_t	_pad_000118;
-	bridgereg_t	b_int_mode;			/* 0x00011C */
-	bridgereg_t	_pad_000120;
-	bridgereg_t	b_int_device;			/* 0x000124 */
-	bridgereg_t	_pad_000128;
-	bridgereg_t	b_int_host_err;			/* 0x00012C */
+	u32	_pad_000100;
+	u32	b_int_status;			/* 0x000104 */
+	u32	_pad_000108;
+	u32	b_int_enable;			/* 0x00010C */
+	u32	_pad_000110;
+	u32	b_int_rst_stat;			/* 0x000114 */
+	u32	_pad_000118;
+	u32	b_int_mode;			/* 0x00011C */
+	u32	_pad_000120;
+	u32	b_int_device;			/* 0x000124 */
+	u32	_pad_000128;
+	u32	b_int_host_err;			/* 0x00012C */
 
 	struct {
-		bridgereg_t	__pad;			/* 0x0001{30,,,68} */
-		bridgereg_t	addr;			/* 0x0001{34,,,6C} */
+		u32	__pad;			/* 0x0001{30,,,68} */
+		u32	addr;			/* 0x0001{34,,,6C} */
 	} b_int_addr[8];				/* 0x000130 */
 
-	bridgereg_t	_pad_000170[36];
+	u32	_pad_000170[36];
 
 	/* Device 0x000200-0x0003FF */
 	struct {
-		bridgereg_t	__pad;			/* 0x0002{00,,,38} */
-		bridgereg_t	reg;			/* 0x0002{04,,,3C} */
+		u32	__pad;			/* 0x0002{00,,,38} */
+		u32	reg;			/* 0x0002{04,,,3C} */
 	} b_device[8];					/* 0x000200 */
 
 	struct {
-		bridgereg_t	__pad;			/* 0x0002{40,,,78} */
-		bridgereg_t	reg;			/* 0x0002{44,,,7C} */
+		u32	__pad;			/* 0x0002{40,,,78} */
+		u32	reg;			/* 0x0002{44,,,7C} */
 	} b_wr_req_buf[8];				/* 0x000240 */
 
 	struct {
-		bridgereg_t	__pad;			/* 0x0002{80,,,88} */
-		bridgereg_t	reg;			/* 0x0002{84,,,8C} */
+		u32	__pad;			/* 0x0002{80,,,88} */
+		u32	reg;			/* 0x0002{84,,,8C} */
 	} b_rrb_map[2];					/* 0x000280 */
 #define b_even_resp	b_rrb_map[0].reg		/* 0x000284 */
 #define b_odd_resp	b_rrb_map[1].reg		/* 0x00028C */
 
-	bridgereg_t	_pad_000290;
-	bridgereg_t	b_resp_status;			/* 0x000294 */
-	bridgereg_t	_pad_000298;
-	bridgereg_t	b_resp_clear;			/* 0x00029C */
+	u32	_pad_000290;
+	u32	b_resp_status;			/* 0x000294 */
+	u32	_pad_000298;
+	u32	b_resp_clear;			/* 0x00029C */
 
-	bridgereg_t	_pad_0002A0[24];
+	u32	_pad_0002A0[24];
 
 	char		_pad_000300[0x10000 - 0x000300];
 
 	/* Internal Address Translation Entry RAM 0x010000-0x0103FF */
 	union {
-		bridge_ate_t	wr;			/* write-only */
+		u64	wr;			/* write-only */
 		struct {
-			bridgereg_t	_p_pad;
-			bridgereg_t	rd;		/* read-only */
+			u32	_p_pad;
+			u32	rd;		/* read-only */
 		}			hi;
 	}			    b_int_ate_ram[128];
 
@@ -192,8 +195,8 @@ typedef volatile struct bridge_s {
 
 	/* Internal Address Translation Entry RAM LOW 0x011000-0x0113FF */
 	struct {
-		bridgereg_t	_p_pad;
-		bridgereg_t	rd;		/* read-only */
+		u32	_p_pad;
+		u32	rd;		/* read-only */
 	} b_int_ate_ram_lo[128];
 
 	char	_pad_011400[0x20000 - 0x011400];
@@ -212,7 +215,7 @@ typedef volatile struct bridge_s {
 		} f[8];
 	} b_type0_cfg_dev[8];					/* 0x020000 */
 
-    /* PCI Type 1 Configuration Space 0x028000-0x028FFF */
+	/* PCI Type 1 Configuration Space 0x028000-0x028FFF */
 	union {				/* make all access sizes available. */
 		u8	c[0x1000 / 1];
 		u16	s[0x1000 / 2];
@@ -233,7 +236,7 @@ typedef volatile struct bridge_s {
 	u8	_pad_030007[0x04fff8];			/* 0x030008-0x07FFFF */
 
 	/* External Address Translation Entry RAM 0x080000-0x0FFFFF */
-	bridge_ate_t	b_ext_ate_ram[0x10000];
+	u64	b_ext_ate_ram[0x10000];
 
 	/* Reserved 0x100000-0x1FFFFF */
 	char	_pad_100000[0x200000-0x100000];
@@ -259,13 +262,13 @@ typedef volatile struct bridge_s {
 		u32	l[0x400000 / 4];	/* read-only */
 		u64	d[0x400000 / 8];	/* read-only */
 	} b_external_flash;			/* 0xC00000 */
-} bridge_t;
+};
 
 /*
  * Field formats for Error Command Word and Auxiliary Error Command Word
  * of bridge.
  */
-typedef struct bridge_err_cmdword_s {
+struct bridge_err_cmdword {
 	union {
 		u32		cmd_word;
 		struct {
@@ -282,7 +285,7 @@ typedef struct bridge_err_cmdword_s {
 				rsvd:8;
 		} berr_st;
 	} berr_un;
-} bridge_err_cmdword_t;
+};
 
 #define berr_field	berr_un.berr_st
 #endif /* !__ASSEMBLY__ */
@@ -290,7 +293,7 @@ typedef struct bridge_err_cmdword_s {
 /*
  * The values of these macros can and should be crosschecked
  * regularly against the offsets of the like-named fields
- * within the "bridge_t" structure above.
+ * within the bridge_regs structure above.
  */
 
 /* Byte offset macros for Bridge internal registers */
@@ -797,46 +800,12 @@ typedef struct bridge_err_cmdword_s {
 #define PCI64_ATTR_RMF_MASK	0x00ff000000000000
 #define PCI64_ATTR_RMF_SHFT	48
 
-#ifndef __ASSEMBLY__
-/* Address translation entry for mapped pci32 accesses */
-typedef union ate_u {
-	u64	ent;
-	struct ate_s {
-		u64	rmf:16;
-		u64	addr:36;
-		u64	targ:4;
-		u64	reserved:3;
-		u64	barrier:1;
-		u64	prefetch:1;
-		u64	precise:1;
-		u64	coherent:1;
-		u64	valid:1;
-	} field;
-} ate_t;
-#endif /* !__ASSEMBLY__ */
-
-#define ATE_V		0x01
-#define ATE_CO		0x02
-#define ATE_PREC	0x04
-#define ATE_PREF	0x08
-#define ATE_BAR		0x10
-
-#define ATE_PFNSHIFT		12
-#define ATE_TIDSHIFT		8
-#define ATE_RMFSHIFT		48
-
-#define mkate(xaddr, xid, attr) ((xaddr) & 0x0000fffffffff000ULL) | \
-				((xid)<<ATE_TIDSHIFT) | \
-				(attr)
-
-#define BRIDGE_INTERNAL_ATES	128
-
 struct bridge_controller {
 	struct pci_controller	pc;
 	struct resource		mem;
 	struct resource		io;
 	struct resource		busn;
-	bridge_t		*base;
+	struct bridge_regs	*base;
 	nasid_t			nasid;
 	unsigned int		widget_id;
 	unsigned int		irq_cpu;
@@ -847,6 +816,13 @@ struct bridge_controller {
 #define BRIDGE_CONTROLLER(bus) \
 	((struct bridge_controller *)((bus)->sysdata))
 
+#define bridge_read(bc, reg)		__raw_readl(&bc->base->reg)
+#define bridge_write(bc, reg, val)	__raw_writel(val, &bc->base->reg)
+#define bridge_set(bc, reg, val)	\
+	__raw_writel(__raw_readl(&bc->base->reg) | (val), &bc->base->reg)
+#define bridge_clr(bc, reg, val)	\
+	__raw_writel(__raw_readl(&bc->base->reg) & ~(val), &bc->base->reg)
+
 extern void register_bridge_irq(unsigned int irq);
 extern int request_bridge_irq(struct bridge_controller *bc);
 

commit 92a76f6d8545efc67f03278009e9a828bdad3419
Author: Adam Buchbinder <adam.buchbinder@gmail.com>
Date:   Thu Feb 25 00:44:58 2016 -0800

    MIPS: Fix misspellings in comments.
    
    Signed-off-by: Adam Buchbinder <adam.buchbinder@gmail.com>
    Cc: linux-mips@linux-mips.org
    Cc: trivial@kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/12617/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/pci/bridge.h b/arch/mips/include/asm/pci/bridge.h
index 8d7a63b52ac7..3206245d1ed6 100644
--- a/arch/mips/include/asm/pci/bridge.h
+++ b/arch/mips/include/asm/pci/bridge.h
@@ -269,16 +269,16 @@ typedef struct bridge_err_cmdword_s {
 	union {
 		u32		cmd_word;
 		struct {
-			u32	didn:4,		/* Destination ID */
-				sidn:4,		/* Source ID	  */
-				pactyp:4,	/* Packet type	  */
-				tnum:5,		/* Trans Number	  */
-				coh:1,		/* Coh Transacti  */
-				ds:2,		/* Data size	  */
-				gbr:1,		/* GBR enable	  */
-				vbpm:1,		/* VBPM message	  */
+			u32	didn:4,		/* Destination ID  */
+				sidn:4,		/* Source ID	   */
+				pactyp:4,	/* Packet type	   */
+				tnum:5,		/* Trans Number	   */
+				coh:1,		/* Coh Transaction */
+				ds:2,		/* Data size	   */
+				gbr:1,		/* GBR enable	   */
+				vbpm:1,		/* VBPM message	   */
 				error:1,	/* Error occurred  */
-				barr:1,		/* Barrier op	  */
+				barr:1,		/* Barrier op	   */
 				rsvd:8;
 		} berr_st;
 	} berr_un;

commit a2e50f53d535fa885a432fb9fc3e3ca5ed97364c
Author: Joshua Kinard <kumba@gentoo.org>
Date:   Mon Jan 19 04:19:20 2015 -0500

    MIPS: PCI: Add a hook for IORESOURCE_BUS in pci_controller/bridge_controller
    
    On SGI Origin 2k/Onyx2 and SGI Octane systems, there can exist multiple PCI
    buses attached to the Xtalk bus.  The current code will stop counting PCI buses
    after it finds the first one.  If one installs the optional PCI cardcage
    ("shoebox") into these systems, because of the order of the Xtalk widgets, the
    current PCI code will find the cardcage first, and fail to detect the BaseIO
    PCI devices, which are on a higher Xtalk widget ID.
    
    This patch adds the hooks needed for resolving this issue in the IP27 PCI code
    (in a later patch).
    
    Verified on both an SGI Onyx2 and an SGI Octane.
    
    Signed-off-by: Joshua Kinard <kumba@gentoo.org>
    Cc: Linux MIPS List <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/9074/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/pci/bridge.h b/arch/mips/include/asm/pci/bridge.h
index af2c8a351ca7..8d7a63b52ac7 100644
--- a/arch/mips/include/asm/pci/bridge.h
+++ b/arch/mips/include/asm/pci/bridge.h
@@ -835,6 +835,7 @@ struct bridge_controller {
 	struct pci_controller	pc;
 	struct resource		mem;
 	struct resource		io;
+	struct resource		busn;
 	bridge_t		*base;
 	nasid_t			nasid;
 	unsigned int		widget_id;

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/pci/bridge.h b/arch/mips/include/asm/pci/bridge.h
index be44fb0266da..af2c8a351ca7 100644
--- a/arch/mips/include/asm/pci/bridge.h
+++ b/arch/mips/include/asm/pci/bridge.h
@@ -85,7 +85,7 @@ typedef volatile struct bridge_s {
 #define b_wid_llp			b_widget.w_llp_cfg
 #define b_wid_tflush			b_widget.w_tflush
 
-	/* bridge-specific widget configuration	0x000058-0x00007F */
+	/* bridge-specific widget configuration 0x000058-0x00007F */
 	bridgereg_t	    _pad_000058;
 	bridgereg_t	    b_wid_aux_err;		/* 0x00005C */
 	bridgereg_t	    _pad_000060;
@@ -167,8 +167,8 @@ typedef volatile struct bridge_s {
 		bridgereg_t	__pad;			/* 0x0002{80,,,88} */
 		bridgereg_t	reg;			/* 0x0002{84,,,8C} */
 	} b_rrb_map[2];					/* 0x000280 */
-#define	b_even_resp	b_rrb_map[0].reg		/* 0x000284 */
-#define	b_odd_resp	b_rrb_map[1].reg		/* 0x00028C */
+#define b_even_resp	b_rrb_map[0].reg		/* 0x000284 */
+#define b_odd_resp	b_rrb_map[1].reg		/* 0x00028C */
 
 	bridgereg_t	_pad_000290;
 	bridgereg_t	b_resp_status;			/* 0x000294 */
@@ -233,7 +233,7 @@ typedef volatile struct bridge_s {
 	u8	_pad_030007[0x04fff8];			/* 0x030008-0x07FFFF */
 
 	/* External Address Translation Entry RAM 0x080000-0x0FFFFF */
-	bridge_ate_t    b_ext_ate_ram[0x10000];
+	bridge_ate_t	b_ext_ate_ram[0x10000];
 
 	/* Reserved 0x100000-0x1FFFFF */
 	char	_pad_100000[0x200000-0x100000];
@@ -400,7 +400,7 @@ typedef struct bridge_err_cmdword_s {
 #define BRIDGE_REV_A			0x1
 #define BRIDGE_REV_B			0x2
 #define BRIDGE_REV_C			0x3
-#define	BRIDGE_REV_D			0x4
+#define BRIDGE_REV_D			0x4
 
 /* Bridge widget status register bits definition */
 
@@ -691,21 +691,21 @@ typedef struct bridge_err_cmdword_s {
 #define BRIDGE_CREDIT	3
 
 /* RRB assignment register */
-#define	BRIDGE_RRB_EN	0x8	/* after shifting down */
-#define	BRIDGE_RRB_DEV	0x7	/* after shifting down */
-#define	BRIDGE_RRB_VDEV	0x4	/* after shifting down */
-#define	BRIDGE_RRB_PDEV	0x3	/* after shifting down */
+#define BRIDGE_RRB_EN	0x8	/* after shifting down */
+#define BRIDGE_RRB_DEV	0x7	/* after shifting down */
+#define BRIDGE_RRB_VDEV 0x4	/* after shifting down */
+#define BRIDGE_RRB_PDEV 0x3	/* after shifting down */
 
 /* RRB status register */
-#define	BRIDGE_RRB_VALID(r)	(0x00010000<<(r))
-#define	BRIDGE_RRB_INUSE(r)	(0x00000001<<(r))
+#define BRIDGE_RRB_VALID(r)	(0x00010000<<(r))
+#define BRIDGE_RRB_INUSE(r)	(0x00000001<<(r))
 
 /* RRB clear register */
-#define	BRIDGE_RRB_CLEAR(r)	(0x00000001<<(r))
+#define BRIDGE_RRB_CLEAR(r)	(0x00000001<<(r))
 
 /* xbox system controller declarations */
-#define XBOX_BRIDGE_WID         8
-#define FLASH_PROM1_BASE        0xE00000 /* To read the xbox sysctlr status */
+#define XBOX_BRIDGE_WID		8
+#define FLASH_PROM1_BASE	0xE00000 /* To read the xbox sysctlr status */
 #define XBOX_RPS_EXISTS		1 << 6	 /* RPS bit in status register */
 #define XBOX_RPS_FAIL		1 << 4	 /* RPS status bit in register */
 
@@ -838,7 +838,7 @@ struct bridge_controller {
 	bridge_t		*base;
 	nasid_t			nasid;
 	unsigned int		widget_id;
-	unsigned int 		irq_cpu;
+	unsigned int		irq_cpu;
 	u64			baddr;
 	unsigned int		pci_int[8];
 };

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/arch/mips/include/asm/pci/bridge.h b/arch/mips/include/asm/pci/bridge.h
index f1f508e4f971..be44fb0266da 100644
--- a/arch/mips/include/asm/pci/bridge.h
+++ b/arch/mips/include/asm/pci/bridge.h
@@ -262,7 +262,7 @@ typedef volatile struct bridge_s {
 } bridge_t;
 
 /*
- * Field formats for Error Command Word and Auxillary Error Command Word
+ * Field formats for Error Command Word and Auxiliary Error Command Word
  * of bridge.
  */
 typedef struct bridge_err_cmdword_s {

commit c1c7438dbbd03442ff86066843485db7fadd67bd
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Wed Oct 27 15:34:47 2010 -0700

    mips: remove dma64_addr_t usage
    
    dma64_addr_t looks pointless (at least there is no point that an
    architecture has the own dma64_addr_t typedef).
    
    dma_addr_t is set to 32 or 64 bits appropriately.  You can use u64 at
    places where you know that 64 bit address is always necessary.
    
    Let's use u64 instead for mips.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/include/asm/pci/bridge.h b/arch/mips/include/asm/pci/bridge.h
index 5f4b9d4e4114..f1f508e4f971 100644
--- a/arch/mips/include/asm/pci/bridge.h
+++ b/arch/mips/include/asm/pci/bridge.h
@@ -839,7 +839,7 @@ struct bridge_controller {
 	nasid_t			nasid;
 	unsigned int		widget_id;
 	unsigned int 		irq_cpu;
-	dma64_addr_t		baddr;
+	u64			baddr;
 	unsigned int		pci_int[8];
 };
 

commit 384740dc49ea651ba350704d13ff6be9976e37fe
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Sep 16 19:48:51 2008 +0200

    MIPS: Move headfiles to new location below arch/mips/include
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/include/asm/pci/bridge.h b/arch/mips/include/asm/pci/bridge.h
new file mode 100644
index 000000000000..5f4b9d4e4114
--- /dev/null
+++ b/arch/mips/include/asm/pci/bridge.h
@@ -0,0 +1,854 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * bridge.h - bridge chip header file, derived from IRIX <sys/PCI/bridge.h>,
+ * revision 1.76.
+ *
+ * Copyright (C) 1996, 1999 Silcon Graphics, Inc.
+ * Copyright (C) 1999 Ralf Baechle (ralf@gnu.org)
+ */
+#ifndef _ASM_PCI_BRIDGE_H
+#define _ASM_PCI_BRIDGE_H
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <asm/xtalk/xwidget.h>		/* generic widget header */
+#include <asm/sn/types.h>
+
+/* I/O page size */
+
+#define IOPFNSHIFT		12	/* 4K per mapped page */
+
+#define IOPGSIZE		(1 << IOPFNSHIFT)
+#define IOPG(x)			((x) >> IOPFNSHIFT)
+#define IOPGOFF(x)		((x) & (IOPGSIZE-1))
+
+/* Bridge RAM sizes */
+
+#define BRIDGE_ATE_RAM_SIZE	0x00000400	/* 1kB ATE RAM */
+
+#define BRIDGE_CONFIG_BASE	0x20000
+#define BRIDGE_CONFIG1_BASE	0x28000
+#define BRIDGE_CONFIG_END	0x30000
+#define BRIDGE_CONFIG_SLOT_SIZE 0x1000
+
+#define BRIDGE_SSRAM_512K	0x00080000	/* 512kB */
+#define BRIDGE_SSRAM_128K	0x00020000	/* 128kB */
+#define BRIDGE_SSRAM_64K	0x00010000	/* 64kB */
+#define BRIDGE_SSRAM_0K		0x00000000	/* 0kB */
+
+/* ========================================================================
+ *    Bridge address map
+ */
+
+#ifndef __ASSEMBLY__
+
+/*
+ * All accesses to bridge hardware registers must be done
+ * using 32-bit loads and stores.
+ */
+typedef u32	bridgereg_t;
+
+typedef u64	bridge_ate_t;
+
+/* pointers to bridge ATEs
+ * are always "pointer to volatile"
+ */
+typedef volatile bridge_ate_t  *bridge_ate_p;
+
+/*
+ * It is generally preferred that hardware registers on the bridge
+ * are located from C code via this structure.
+ *
+ * Generated from Bridge spec dated 04oct95
+ */
+
+typedef volatile struct bridge_s {
+	/* Local Registers			       0x000000-0x00FFFF */
+
+	/* standard widget configuration	       0x000000-0x000057 */
+	widget_cfg_t	    b_widget;			/* 0x000000 */
+
+	/* helper fieldnames for accessing bridge widget */
+
+#define b_wid_id			b_widget.w_id
+#define b_wid_stat			b_widget.w_status
+#define b_wid_err_upper			b_widget.w_err_upper_addr
+#define b_wid_err_lower			b_widget.w_err_lower_addr
+#define b_wid_control			b_widget.w_control
+#define b_wid_req_timeout		b_widget.w_req_timeout
+#define b_wid_int_upper			b_widget.w_intdest_upper_addr
+#define b_wid_int_lower			b_widget.w_intdest_lower_addr
+#define b_wid_err_cmdword		b_widget.w_err_cmd_word
+#define b_wid_llp			b_widget.w_llp_cfg
+#define b_wid_tflush			b_widget.w_tflush
+
+	/* bridge-specific widget configuration	0x000058-0x00007F */
+	bridgereg_t	    _pad_000058;
+	bridgereg_t	    b_wid_aux_err;		/* 0x00005C */
+	bridgereg_t	    _pad_000060;
+	bridgereg_t	    b_wid_resp_upper;		/* 0x000064 */
+	bridgereg_t	    _pad_000068;
+	bridgereg_t	    b_wid_resp_lower;		/* 0x00006C */
+	bridgereg_t	    _pad_000070;
+	bridgereg_t	    b_wid_tst_pin_ctrl;		/* 0x000074 */
+	bridgereg_t	_pad_000078[2];
+
+	/* PMU & Map 0x000080-0x00008F */
+	bridgereg_t	_pad_000080;
+	bridgereg_t	b_dir_map;			/* 0x000084 */
+	bridgereg_t	_pad_000088[2];
+
+	/* SSRAM 0x000090-0x00009F */
+	bridgereg_t	_pad_000090;
+	bridgereg_t	b_ram_perr;			/* 0x000094 */
+	bridgereg_t	_pad_000098[2];
+
+	/* Arbitration 0x0000A0-0x0000AF */
+	bridgereg_t	_pad_0000A0;
+	bridgereg_t	b_arb;				/* 0x0000A4 */
+	bridgereg_t	_pad_0000A8[2];
+
+	/* Number In A Can 0x0000B0-0x0000BF */
+	bridgereg_t	_pad_0000B0;
+	bridgereg_t	b_nic;				/* 0x0000B4 */
+	bridgereg_t	_pad_0000B8[2];
+
+	/* PCI/GIO 0x0000C0-0x0000FF */
+	bridgereg_t	_pad_0000C0;
+	bridgereg_t	b_bus_timeout;			/* 0x0000C4 */
+#define b_pci_bus_timeout b_bus_timeout
+
+	bridgereg_t	_pad_0000C8;
+	bridgereg_t	b_pci_cfg;			/* 0x0000CC */
+	bridgereg_t	_pad_0000D0;
+	bridgereg_t	b_pci_err_upper;		/* 0x0000D4 */
+	bridgereg_t	_pad_0000D8;
+	bridgereg_t	b_pci_err_lower;		/* 0x0000DC */
+	bridgereg_t	_pad_0000E0[8];
+#define b_gio_err_lower b_pci_err_lower
+#define b_gio_err_upper b_pci_err_upper
+
+	/* Interrupt 0x000100-0x0001FF */
+	bridgereg_t	_pad_000100;
+	bridgereg_t	b_int_status;			/* 0x000104 */
+	bridgereg_t	_pad_000108;
+	bridgereg_t	b_int_enable;			/* 0x00010C */
+	bridgereg_t	_pad_000110;
+	bridgereg_t	b_int_rst_stat;			/* 0x000114 */
+	bridgereg_t	_pad_000118;
+	bridgereg_t	b_int_mode;			/* 0x00011C */
+	bridgereg_t	_pad_000120;
+	bridgereg_t	b_int_device;			/* 0x000124 */
+	bridgereg_t	_pad_000128;
+	bridgereg_t	b_int_host_err;			/* 0x00012C */
+
+	struct {
+		bridgereg_t	__pad;			/* 0x0001{30,,,68} */
+		bridgereg_t	addr;			/* 0x0001{34,,,6C} */
+	} b_int_addr[8];				/* 0x000130 */
+
+	bridgereg_t	_pad_000170[36];
+
+	/* Device 0x000200-0x0003FF */
+	struct {
+		bridgereg_t	__pad;			/* 0x0002{00,,,38} */
+		bridgereg_t	reg;			/* 0x0002{04,,,3C} */
+	} b_device[8];					/* 0x000200 */
+
+	struct {
+		bridgereg_t	__pad;			/* 0x0002{40,,,78} */
+		bridgereg_t	reg;			/* 0x0002{44,,,7C} */
+	} b_wr_req_buf[8];				/* 0x000240 */
+
+	struct {
+		bridgereg_t	__pad;			/* 0x0002{80,,,88} */
+		bridgereg_t	reg;			/* 0x0002{84,,,8C} */
+	} b_rrb_map[2];					/* 0x000280 */
+#define	b_even_resp	b_rrb_map[0].reg		/* 0x000284 */
+#define	b_odd_resp	b_rrb_map[1].reg		/* 0x00028C */
+
+	bridgereg_t	_pad_000290;
+	bridgereg_t	b_resp_status;			/* 0x000294 */
+	bridgereg_t	_pad_000298;
+	bridgereg_t	b_resp_clear;			/* 0x00029C */
+
+	bridgereg_t	_pad_0002A0[24];
+
+	char		_pad_000300[0x10000 - 0x000300];
+
+	/* Internal Address Translation Entry RAM 0x010000-0x0103FF */
+	union {
+		bridge_ate_t	wr;			/* write-only */
+		struct {
+			bridgereg_t	_p_pad;
+			bridgereg_t	rd;		/* read-only */
+		}			hi;
+	}			    b_int_ate_ram[128];
+
+	char	_pad_010400[0x11000 - 0x010400];
+
+	/* Internal Address Translation Entry RAM LOW 0x011000-0x0113FF */
+	struct {
+		bridgereg_t	_p_pad;
+		bridgereg_t	rd;		/* read-only */
+	} b_int_ate_ram_lo[128];
+
+	char	_pad_011400[0x20000 - 0x011400];
+
+	/* PCI Device Configuration Spaces 0x020000-0x027FFF */
+	union {				/* make all access sizes available. */
+		u8	c[0x1000 / 1];
+		u16	s[0x1000 / 2];
+		u32	l[0x1000 / 4];
+		u64	d[0x1000 / 8];
+		union {
+			u8	c[0x100 / 1];
+			u16	s[0x100 / 2];
+			u32	l[0x100 / 4];
+			u64	d[0x100 / 8];
+		} f[8];
+	} b_type0_cfg_dev[8];					/* 0x020000 */
+
+    /* PCI Type 1 Configuration Space 0x028000-0x028FFF */
+	union {				/* make all access sizes available. */
+		u8	c[0x1000 / 1];
+		u16	s[0x1000 / 2];
+		u32	l[0x1000 / 4];
+		u64	d[0x1000 / 8];
+	} b_type1_cfg;					/* 0x028000-0x029000 */
+
+	char	_pad_029000[0x007000];			/* 0x029000-0x030000 */
+
+	/* PCI Interrupt Acknowledge Cycle 0x030000 */
+	union {
+		u8	c[8 / 1];
+		u16	s[8 / 2];
+		u32	l[8 / 4];
+		u64	d[8 / 8];
+	} b_pci_iack;						/* 0x030000 */
+
+	u8	_pad_030007[0x04fff8];			/* 0x030008-0x07FFFF */
+
+	/* External Address Translation Entry RAM 0x080000-0x0FFFFF */
+	bridge_ate_t    b_ext_ate_ram[0x10000];
+
+	/* Reserved 0x100000-0x1FFFFF */
+	char	_pad_100000[0x200000-0x100000];
+
+	/* PCI/GIO Device Spaces 0x200000-0xBFFFFF */
+	union {				/* make all access sizes available. */
+		u8	c[0x100000 / 1];
+		u16	s[0x100000 / 2];
+		u32	l[0x100000 / 4];
+		u64	d[0x100000 / 8];
+	} b_devio_raw[10];				/* 0x200000 */
+
+	/* b_devio macro is a bit strange; it reflects the
+	 * fact that the Bridge ASIC provides 2M for the
+	 * first two DevIO windows and 1M for the other six.
+	 */
+#define b_devio(n)	b_devio_raw[((n)<2)?(n*2):(n+2)]
+
+	/* External Flash Proms 1,0 0xC00000-0xFFFFFF */
+	union {		/* make all access sizes available. */
+		u8	c[0x400000 / 1];	/* read-only */
+		u16	s[0x400000 / 2];	/* read-write */
+		u32	l[0x400000 / 4];	/* read-only */
+		u64	d[0x400000 / 8];	/* read-only */
+	} b_external_flash;			/* 0xC00000 */
+} bridge_t;
+
+/*
+ * Field formats for Error Command Word and Auxillary Error Command Word
+ * of bridge.
+ */
+typedef struct bridge_err_cmdword_s {
+	union {
+		u32		cmd_word;
+		struct {
+			u32	didn:4,		/* Destination ID */
+				sidn:4,		/* Source ID	  */
+				pactyp:4,	/* Packet type	  */
+				tnum:5,		/* Trans Number	  */
+				coh:1,		/* Coh Transacti  */
+				ds:2,		/* Data size	  */
+				gbr:1,		/* GBR enable	  */
+				vbpm:1,		/* VBPM message	  */
+				error:1,	/* Error occurred  */
+				barr:1,		/* Barrier op	  */
+				rsvd:8;
+		} berr_st;
+	} berr_un;
+} bridge_err_cmdword_t;
+
+#define berr_field	berr_un.berr_st
+#endif /* !__ASSEMBLY__ */
+
+/*
+ * The values of these macros can and should be crosschecked
+ * regularly against the offsets of the like-named fields
+ * within the "bridge_t" structure above.
+ */
+
+/* Byte offset macros for Bridge internal registers */
+
+#define BRIDGE_WID_ID		WIDGET_ID
+#define BRIDGE_WID_STAT		WIDGET_STATUS
+#define BRIDGE_WID_ERR_UPPER	WIDGET_ERR_UPPER_ADDR
+#define BRIDGE_WID_ERR_LOWER	WIDGET_ERR_LOWER_ADDR
+#define BRIDGE_WID_CONTROL	WIDGET_CONTROL
+#define BRIDGE_WID_REQ_TIMEOUT	WIDGET_REQ_TIMEOUT
+#define BRIDGE_WID_INT_UPPER	WIDGET_INTDEST_UPPER_ADDR
+#define BRIDGE_WID_INT_LOWER	WIDGET_INTDEST_LOWER_ADDR
+#define BRIDGE_WID_ERR_CMDWORD	WIDGET_ERR_CMD_WORD
+#define BRIDGE_WID_LLP		WIDGET_LLP_CFG
+#define BRIDGE_WID_TFLUSH	WIDGET_TFLUSH
+
+#define BRIDGE_WID_AUX_ERR	0x00005C	/* Aux Error Command Word */
+#define BRIDGE_WID_RESP_UPPER	0x000064	/* Response Buf Upper Addr */
+#define BRIDGE_WID_RESP_LOWER	0x00006C	/* Response Buf Lower Addr */
+#define BRIDGE_WID_TST_PIN_CTRL 0x000074	/* Test pin control */
+
+#define BRIDGE_DIR_MAP		0x000084	/* Direct Map reg */
+
+#define BRIDGE_RAM_PERR		0x000094	/* SSRAM Parity Error */
+
+#define BRIDGE_ARB		0x0000A4	/* Arbitration Priority reg */
+
+#define BRIDGE_NIC		0x0000B4	/* Number In A Can */
+
+#define BRIDGE_BUS_TIMEOUT	0x0000C4	/* Bus Timeout Register */
+#define BRIDGE_PCI_BUS_TIMEOUT	BRIDGE_BUS_TIMEOUT
+#define BRIDGE_PCI_CFG		0x0000CC	/* PCI Type 1 Config reg */
+#define BRIDGE_PCI_ERR_UPPER	0x0000D4	/* PCI error Upper Addr */
+#define BRIDGE_PCI_ERR_LOWER	0x0000DC	/* PCI error Lower Addr */
+
+#define BRIDGE_INT_STATUS	0x000104	/* Interrupt Status */
+#define BRIDGE_INT_ENABLE	0x00010C	/* Interrupt Enables */
+#define BRIDGE_INT_RST_STAT	0x000114	/* Reset Intr Status */
+#define BRIDGE_INT_MODE		0x00011C	/* Interrupt Mode */
+#define BRIDGE_INT_DEVICE	0x000124	/* Interrupt Device */
+#define BRIDGE_INT_HOST_ERR	0x00012C	/* Host Error Field */
+
+#define BRIDGE_INT_ADDR0	0x000134	/* Host Address Reg */
+#define BRIDGE_INT_ADDR_OFF	0x000008	/* Host Addr offset (1..7) */
+#define BRIDGE_INT_ADDR(x)	(BRIDGE_INT_ADDR0+(x)*BRIDGE_INT_ADDR_OFF)
+
+#define BRIDGE_DEVICE0		0x000204	/* Device 0 */
+#define BRIDGE_DEVICE_OFF	0x000008	/* Device offset (1..7) */
+#define BRIDGE_DEVICE(x)	(BRIDGE_DEVICE0+(x)*BRIDGE_DEVICE_OFF)
+
+#define BRIDGE_WR_REQ_BUF0	0x000244	/* Write Request Buffer 0 */
+#define BRIDGE_WR_REQ_BUF_OFF	0x000008	/* Buffer Offset (1..7) */
+#define BRIDGE_WR_REQ_BUF(x)	(BRIDGE_WR_REQ_BUF0+(x)*BRIDGE_WR_REQ_BUF_OFF)
+
+#define BRIDGE_EVEN_RESP	0x000284	/* Even Device Response Buf */
+#define BRIDGE_ODD_RESP		0x00028C	/* Odd Device Response Buf */
+
+#define BRIDGE_RESP_STATUS	0x000294	/* Read Response Status reg */
+#define BRIDGE_RESP_CLEAR	0x00029C	/* Read Response Clear reg */
+
+/* Byte offset macros for Bridge I/O space */
+
+#define BRIDGE_ATE_RAM		0x00010000	/* Internal Addr Xlat Ram */
+
+#define BRIDGE_TYPE0_CFG_DEV0	0x00020000	/* Type 0 Cfg, Device 0 */
+#define BRIDGE_TYPE0_CFG_SLOT_OFF	0x00001000	/* Type 0 Cfg Slot Offset (1..7) */
+#define BRIDGE_TYPE0_CFG_FUNC_OFF	0x00000100	/* Type 0 Cfg Func Offset (1..7) */
+#define BRIDGE_TYPE0_CFG_DEV(s)		(BRIDGE_TYPE0_CFG_DEV0+\
+					 (s)*BRIDGE_TYPE0_CFG_SLOT_OFF)
+#define BRIDGE_TYPE0_CFG_DEVF(s, f)	(BRIDGE_TYPE0_CFG_DEV0+\
+					 (s)*BRIDGE_TYPE0_CFG_SLOT_OFF+\
+					 (f)*BRIDGE_TYPE0_CFG_FUNC_OFF)
+
+#define BRIDGE_TYPE1_CFG	0x00028000	/* Type 1 Cfg space */
+
+#define BRIDGE_PCI_IACK		0x00030000	/* PCI Interrupt Ack */
+#define BRIDGE_EXT_SSRAM	0x00080000	/* Extern SSRAM (ATE) */
+
+/* Byte offset macros for Bridge device IO spaces */
+
+#define BRIDGE_DEV_CNT		8	/* Up to 8 devices per bridge */
+#define BRIDGE_DEVIO0		0x00200000	/* Device IO 0 Addr */
+#define BRIDGE_DEVIO1		0x00400000	/* Device IO 1 Addr */
+#define BRIDGE_DEVIO2		0x00600000	/* Device IO 2 Addr */
+#define BRIDGE_DEVIO_OFF	0x00100000	/* Device IO Offset (3..7) */
+
+#define BRIDGE_DEVIO_2MB	0x00200000	/* Device IO Offset (0..1) */
+#define BRIDGE_DEVIO_1MB	0x00100000	/* Device IO Offset (2..7) */
+
+#define BRIDGE_DEVIO(x)		((x)<=1 ? BRIDGE_DEVIO0+(x)*BRIDGE_DEVIO_2MB : BRIDGE_DEVIO2+((x)-2)*BRIDGE_DEVIO_1MB)
+
+#define BRIDGE_EXTERNAL_FLASH	0x00C00000	/* External Flash PROMS */
+
+/* ========================================================================
+ *    Bridge register bit field definitions
+ */
+
+/* Widget part number of bridge */
+#define BRIDGE_WIDGET_PART_NUM		0xc002
+#define XBRIDGE_WIDGET_PART_NUM		0xd002
+
+/* Manufacturer of bridge */
+#define BRIDGE_WIDGET_MFGR_NUM		0x036
+#define XBRIDGE_WIDGET_MFGR_NUM		0x024
+
+/* Revision numbers for known Bridge revisions */
+#define BRIDGE_REV_A			0x1
+#define BRIDGE_REV_B			0x2
+#define BRIDGE_REV_C			0x3
+#define	BRIDGE_REV_D			0x4
+
+/* Bridge widget status register bits definition */
+
+#define BRIDGE_STAT_LLP_REC_CNT		(0xFFu << 24)
+#define BRIDGE_STAT_LLP_TX_CNT		(0xFF << 16)
+#define BRIDGE_STAT_FLASH_SELECT	(0x1 << 6)
+#define BRIDGE_STAT_PCI_GIO_N		(0x1 << 5)
+#define BRIDGE_STAT_PENDING		(0x1F << 0)
+
+/* Bridge widget control register bits definition */
+#define BRIDGE_CTRL_FLASH_WR_EN		(0x1ul << 31)
+#define BRIDGE_CTRL_EN_CLK50		(0x1 << 30)
+#define BRIDGE_CTRL_EN_CLK40		(0x1 << 29)
+#define BRIDGE_CTRL_EN_CLK33		(0x1 << 28)
+#define BRIDGE_CTRL_RST(n)		((n) << 24)
+#define BRIDGE_CTRL_RST_MASK		(BRIDGE_CTRL_RST(0xF))
+#define BRIDGE_CTRL_RST_PIN(x)		(BRIDGE_CTRL_RST(0x1 << (x)))
+#define BRIDGE_CTRL_IO_SWAP		(0x1 << 23)
+#define BRIDGE_CTRL_MEM_SWAP		(0x1 << 22)
+#define BRIDGE_CTRL_PAGE_SIZE		(0x1 << 21)
+#define BRIDGE_CTRL_SS_PAR_BAD		(0x1 << 20)
+#define BRIDGE_CTRL_SS_PAR_EN		(0x1 << 19)
+#define BRIDGE_CTRL_SSRAM_SIZE(n)	((n) << 17)
+#define BRIDGE_CTRL_SSRAM_SIZE_MASK	(BRIDGE_CTRL_SSRAM_SIZE(0x3))
+#define BRIDGE_CTRL_SSRAM_512K		(BRIDGE_CTRL_SSRAM_SIZE(0x3))
+#define BRIDGE_CTRL_SSRAM_128K		(BRIDGE_CTRL_SSRAM_SIZE(0x2))
+#define BRIDGE_CTRL_SSRAM_64K		(BRIDGE_CTRL_SSRAM_SIZE(0x1))
+#define BRIDGE_CTRL_SSRAM_1K		(BRIDGE_CTRL_SSRAM_SIZE(0x0))
+#define BRIDGE_CTRL_F_BAD_PKT		(0x1 << 16)
+#define BRIDGE_CTRL_LLP_XBAR_CRD(n)	((n) << 12)
+#define BRIDGE_CTRL_LLP_XBAR_CRD_MASK	(BRIDGE_CTRL_LLP_XBAR_CRD(0xf))
+#define BRIDGE_CTRL_CLR_RLLP_CNT	(0x1 << 11)
+#define BRIDGE_CTRL_CLR_TLLP_CNT	(0x1 << 10)
+#define BRIDGE_CTRL_SYS_END		(0x1 << 9)
+#define BRIDGE_CTRL_MAX_TRANS(n)	((n) << 4)
+#define BRIDGE_CTRL_MAX_TRANS_MASK	(BRIDGE_CTRL_MAX_TRANS(0x1f))
+#define BRIDGE_CTRL_WIDGET_ID(n)	((n) << 0)
+#define BRIDGE_CTRL_WIDGET_ID_MASK	(BRIDGE_CTRL_WIDGET_ID(0xf))
+
+/* Bridge Response buffer Error Upper Register bit fields definition */
+#define BRIDGE_RESP_ERRUPPR_DEVNUM_SHFT (20)
+#define BRIDGE_RESP_ERRUPPR_DEVNUM_MASK (0x7 << BRIDGE_RESP_ERRUPPR_DEVNUM_SHFT)
+#define BRIDGE_RESP_ERRUPPR_BUFNUM_SHFT (16)
+#define BRIDGE_RESP_ERRUPPR_BUFNUM_MASK (0xF << BRIDGE_RESP_ERRUPPR_BUFNUM_SHFT)
+#define BRIDGE_RESP_ERRRUPPR_BUFMASK	(0xFFFF)
+
+#define BRIDGE_RESP_ERRUPPR_BUFNUM(x)	\
+			(((x) & BRIDGE_RESP_ERRUPPR_BUFNUM_MASK) >> \
+				BRIDGE_RESP_ERRUPPR_BUFNUM_SHFT)
+
+#define BRIDGE_RESP_ERRUPPR_DEVICE(x)	\
+			(((x) &	 BRIDGE_RESP_ERRUPPR_DEVNUM_MASK) >> \
+				 BRIDGE_RESP_ERRUPPR_DEVNUM_SHFT)
+
+/* Bridge direct mapping register bits definition */
+#define BRIDGE_DIRMAP_W_ID_SHFT		20
+#define BRIDGE_DIRMAP_W_ID		(0xf << BRIDGE_DIRMAP_W_ID_SHFT)
+#define BRIDGE_DIRMAP_RMF_64		(0x1 << 18)
+#define BRIDGE_DIRMAP_ADD512		(0x1 << 17)
+#define BRIDGE_DIRMAP_OFF		(0x1ffff << 0)
+#define BRIDGE_DIRMAP_OFF_ADDRSHFT	(31)	/* lsbit of DIRMAP_OFF is xtalk address bit 31 */
+
+/* Bridge Arbitration register bits definition */
+#define BRIDGE_ARB_REQ_WAIT_TICK(x)	((x) << 16)
+#define BRIDGE_ARB_REQ_WAIT_TICK_MASK	BRIDGE_ARB_REQ_WAIT_TICK(0x3)
+#define BRIDGE_ARB_REQ_WAIT_EN(x)	((x) << 8)
+#define BRIDGE_ARB_REQ_WAIT_EN_MASK	BRIDGE_ARB_REQ_WAIT_EN(0xff)
+#define BRIDGE_ARB_FREEZE_GNT		(1 << 6)
+#define BRIDGE_ARB_HPRI_RING_B2		(1 << 5)
+#define BRIDGE_ARB_HPRI_RING_B1		(1 << 4)
+#define BRIDGE_ARB_HPRI_RING_B0		(1 << 3)
+#define BRIDGE_ARB_LPRI_RING_B2		(1 << 2)
+#define BRIDGE_ARB_LPRI_RING_B1		(1 << 1)
+#define BRIDGE_ARB_LPRI_RING_B0		(1 << 0)
+
+/* Bridge Bus time-out register bits definition */
+#define BRIDGE_BUS_PCI_RETRY_HLD(x)	((x) << 16)
+#define BRIDGE_BUS_PCI_RETRY_HLD_MASK	BRIDGE_BUS_PCI_RETRY_HLD(0x1f)
+#define BRIDGE_BUS_GIO_TIMEOUT		(1 << 12)
+#define BRIDGE_BUS_PCI_RETRY_CNT(x)	((x) << 0)
+#define BRIDGE_BUS_PCI_RETRY_MASK	BRIDGE_BUS_PCI_RETRY_CNT(0x3ff)
+
+/* Bridge interrupt status register bits definition */
+#define BRIDGE_ISR_MULTI_ERR		(0x1u << 31)
+#define BRIDGE_ISR_PMU_ESIZE_FAULT	(0x1 << 30)
+#define BRIDGE_ISR_UNEXP_RESP		(0x1 << 29)
+#define BRIDGE_ISR_BAD_XRESP_PKT	(0x1 << 28)
+#define BRIDGE_ISR_BAD_XREQ_PKT		(0x1 << 27)
+#define BRIDGE_ISR_RESP_XTLK_ERR	(0x1 << 26)
+#define BRIDGE_ISR_REQ_XTLK_ERR		(0x1 << 25)
+#define BRIDGE_ISR_INVLD_ADDR		(0x1 << 24)
+#define BRIDGE_ISR_UNSUPPORTED_XOP	(0x1 << 23)
+#define BRIDGE_ISR_XREQ_FIFO_OFLOW	(0x1 << 22)
+#define BRIDGE_ISR_LLP_REC_SNERR	(0x1 << 21)
+#define BRIDGE_ISR_LLP_REC_CBERR	(0x1 << 20)
+#define BRIDGE_ISR_LLP_RCTY		(0x1 << 19)
+#define BRIDGE_ISR_LLP_TX_RETRY		(0x1 << 18)
+#define BRIDGE_ISR_LLP_TCTY		(0x1 << 17)
+#define BRIDGE_ISR_SSRAM_PERR		(0x1 << 16)
+#define BRIDGE_ISR_PCI_ABORT		(0x1 << 15)
+#define BRIDGE_ISR_PCI_PARITY		(0x1 << 14)
+#define BRIDGE_ISR_PCI_SERR		(0x1 << 13)
+#define BRIDGE_ISR_PCI_PERR		(0x1 << 12)
+#define BRIDGE_ISR_PCI_MST_TIMEOUT	(0x1 << 11)
+#define BRIDGE_ISR_GIO_MST_TIMEOUT	BRIDGE_ISR_PCI_MST_TIMEOUT
+#define BRIDGE_ISR_PCI_RETRY_CNT	(0x1 << 10)
+#define BRIDGE_ISR_XREAD_REQ_TIMEOUT	(0x1 << 9)
+#define BRIDGE_ISR_GIO_B_ENBL_ERR	(0x1 << 8)
+#define BRIDGE_ISR_INT_MSK		(0xff << 0)
+#define BRIDGE_ISR_INT(x)		(0x1 << (x))
+
+#define BRIDGE_ISR_LINK_ERROR		\
+		(BRIDGE_ISR_LLP_REC_SNERR|BRIDGE_ISR_LLP_REC_CBERR|	\
+		 BRIDGE_ISR_LLP_RCTY|BRIDGE_ISR_LLP_TX_RETRY|		\
+		 BRIDGE_ISR_LLP_TCTY)
+
+#define BRIDGE_ISR_PCIBUS_PIOERR	\
+		(BRIDGE_ISR_PCI_MST_TIMEOUT|BRIDGE_ISR_PCI_ABORT)
+
+#define BRIDGE_ISR_PCIBUS_ERROR		\
+		(BRIDGE_ISR_PCIBUS_PIOERR|BRIDGE_ISR_PCI_PERR|		\
+		 BRIDGE_ISR_PCI_SERR|BRIDGE_ISR_PCI_RETRY_CNT|		\
+		 BRIDGE_ISR_PCI_PARITY)
+
+#define BRIDGE_ISR_XTALK_ERROR		\
+		(BRIDGE_ISR_XREAD_REQ_TIMEOUT|BRIDGE_ISR_XREQ_FIFO_OFLOW|\
+		 BRIDGE_ISR_UNSUPPORTED_XOP|BRIDGE_ISR_INVLD_ADDR|	\
+		 BRIDGE_ISR_REQ_XTLK_ERR|BRIDGE_ISR_RESP_XTLK_ERR|	\
+		 BRIDGE_ISR_BAD_XREQ_PKT|BRIDGE_ISR_BAD_XRESP_PKT|	\
+		 BRIDGE_ISR_UNEXP_RESP)
+
+#define BRIDGE_ISR_ERRORS		\
+		(BRIDGE_ISR_LINK_ERROR|BRIDGE_ISR_PCIBUS_ERROR|		\
+		 BRIDGE_ISR_XTALK_ERROR|BRIDGE_ISR_SSRAM_PERR|		\
+		 BRIDGE_ISR_PMU_ESIZE_FAULT)
+
+/*
+ * List of Errors which are fatal and kill the system
+ */
+#define BRIDGE_ISR_ERROR_FATAL		\
+		((BRIDGE_ISR_XTALK_ERROR & ~BRIDGE_ISR_XREAD_REQ_TIMEOUT)|\
+		 BRIDGE_ISR_PCI_SERR|BRIDGE_ISR_PCI_PARITY )
+
+#define BRIDGE_ISR_ERROR_DUMP		\
+		(BRIDGE_ISR_PCIBUS_ERROR|BRIDGE_ISR_PMU_ESIZE_FAULT|	\
+		 BRIDGE_ISR_XTALK_ERROR|BRIDGE_ISR_SSRAM_PERR)
+
+/* Bridge interrupt enable register bits definition */
+#define BRIDGE_IMR_UNEXP_RESP		BRIDGE_ISR_UNEXP_RESP
+#define BRIDGE_IMR_PMU_ESIZE_FAULT	BRIDGE_ISR_PMU_ESIZE_FAULT
+#define BRIDGE_IMR_BAD_XRESP_PKT	BRIDGE_ISR_BAD_XRESP_PKT
+#define BRIDGE_IMR_BAD_XREQ_PKT		BRIDGE_ISR_BAD_XREQ_PKT
+#define BRIDGE_IMR_RESP_XTLK_ERR	BRIDGE_ISR_RESP_XTLK_ERR
+#define BRIDGE_IMR_REQ_XTLK_ERR		BRIDGE_ISR_REQ_XTLK_ERR
+#define BRIDGE_IMR_INVLD_ADDR		BRIDGE_ISR_INVLD_ADDR
+#define BRIDGE_IMR_UNSUPPORTED_XOP	BRIDGE_ISR_UNSUPPORTED_XOP
+#define BRIDGE_IMR_XREQ_FIFO_OFLOW	BRIDGE_ISR_XREQ_FIFO_OFLOW
+#define BRIDGE_IMR_LLP_REC_SNERR	BRIDGE_ISR_LLP_REC_SNERR
+#define BRIDGE_IMR_LLP_REC_CBERR	BRIDGE_ISR_LLP_REC_CBERR
+#define BRIDGE_IMR_LLP_RCTY		BRIDGE_ISR_LLP_RCTY
+#define BRIDGE_IMR_LLP_TX_RETRY		BRIDGE_ISR_LLP_TX_RETRY
+#define BRIDGE_IMR_LLP_TCTY		BRIDGE_ISR_LLP_TCTY
+#define BRIDGE_IMR_SSRAM_PERR		BRIDGE_ISR_SSRAM_PERR
+#define BRIDGE_IMR_PCI_ABORT		BRIDGE_ISR_PCI_ABORT
+#define BRIDGE_IMR_PCI_PARITY		BRIDGE_ISR_PCI_PARITY
+#define BRIDGE_IMR_PCI_SERR		BRIDGE_ISR_PCI_SERR
+#define BRIDGE_IMR_PCI_PERR		BRIDGE_ISR_PCI_PERR
+#define BRIDGE_IMR_PCI_MST_TIMEOUT	BRIDGE_ISR_PCI_MST_TIMEOUT
+#define BRIDGE_IMR_GIO_MST_TIMEOUT	BRIDGE_ISR_GIO_MST_TIMEOUT
+#define BRIDGE_IMR_PCI_RETRY_CNT	BRIDGE_ISR_PCI_RETRY_CNT
+#define BRIDGE_IMR_XREAD_REQ_TIMEOUT	BRIDGE_ISR_XREAD_REQ_TIMEOUT
+#define BRIDGE_IMR_GIO_B_ENBL_ERR	BRIDGE_ISR_GIO_B_ENBL_ERR
+#define BRIDGE_IMR_INT_MSK		BRIDGE_ISR_INT_MSK
+#define BRIDGE_IMR_INT(x)		BRIDGE_ISR_INT(x)
+
+/* Bridge interrupt reset register bits definition */
+#define BRIDGE_IRR_MULTI_CLR		(0x1 << 6)
+#define BRIDGE_IRR_CRP_GRP_CLR		(0x1 << 5)
+#define BRIDGE_IRR_RESP_BUF_GRP_CLR	(0x1 << 4)
+#define BRIDGE_IRR_REQ_DSP_GRP_CLR	(0x1 << 3)
+#define BRIDGE_IRR_LLP_GRP_CLR		(0x1 << 2)
+#define BRIDGE_IRR_SSRAM_GRP_CLR	(0x1 << 1)
+#define BRIDGE_IRR_PCI_GRP_CLR		(0x1 << 0)
+#define BRIDGE_IRR_GIO_GRP_CLR		(0x1 << 0)
+#define BRIDGE_IRR_ALL_CLR		0x7f
+
+#define BRIDGE_IRR_CRP_GRP		(BRIDGE_ISR_UNEXP_RESP | \
+					 BRIDGE_ISR_XREQ_FIFO_OFLOW)
+#define BRIDGE_IRR_RESP_BUF_GRP		(BRIDGE_ISR_BAD_XRESP_PKT | \
+					 BRIDGE_ISR_RESP_XTLK_ERR | \
+					 BRIDGE_ISR_XREAD_REQ_TIMEOUT)
+#define BRIDGE_IRR_REQ_DSP_GRP		(BRIDGE_ISR_UNSUPPORTED_XOP | \
+					 BRIDGE_ISR_BAD_XREQ_PKT | \
+					 BRIDGE_ISR_REQ_XTLK_ERR | \
+					 BRIDGE_ISR_INVLD_ADDR)
+#define BRIDGE_IRR_LLP_GRP		(BRIDGE_ISR_LLP_REC_SNERR | \
+					 BRIDGE_ISR_LLP_REC_CBERR | \
+					 BRIDGE_ISR_LLP_RCTY | \
+					 BRIDGE_ISR_LLP_TX_RETRY | \
+					 BRIDGE_ISR_LLP_TCTY)
+#define BRIDGE_IRR_SSRAM_GRP		(BRIDGE_ISR_SSRAM_PERR | \
+					 BRIDGE_ISR_PMU_ESIZE_FAULT)
+#define BRIDGE_IRR_PCI_GRP		(BRIDGE_ISR_PCI_ABORT | \
+					 BRIDGE_ISR_PCI_PARITY | \
+					 BRIDGE_ISR_PCI_SERR | \
+					 BRIDGE_ISR_PCI_PERR | \
+					 BRIDGE_ISR_PCI_MST_TIMEOUT | \
+					 BRIDGE_ISR_PCI_RETRY_CNT)
+
+#define BRIDGE_IRR_GIO_GRP		(BRIDGE_ISR_GIO_B_ENBL_ERR | \
+					 BRIDGE_ISR_GIO_MST_TIMEOUT)
+
+/* Bridge INT_DEV register bits definition */
+#define BRIDGE_INT_DEV_SHFT(n)		((n)*3)
+#define BRIDGE_INT_DEV_MASK(n)		(0x7 << BRIDGE_INT_DEV_SHFT(n))
+#define BRIDGE_INT_DEV_SET(_dev, _line) (_dev << BRIDGE_INT_DEV_SHFT(_line))
+
+/* Bridge interrupt(x) register bits definition */
+#define BRIDGE_INT_ADDR_HOST		0x0003FF00
+#define BRIDGE_INT_ADDR_FLD		0x000000FF
+
+#define BRIDGE_TMO_PCI_RETRY_HLD_MASK	0x1f0000
+#define BRIDGE_TMO_GIO_TIMEOUT_MASK	0x001000
+#define BRIDGE_TMO_PCI_RETRY_CNT_MASK	0x0003ff
+
+#define BRIDGE_TMO_PCI_RETRY_CNT_MAX	0x3ff
+
+/*
+ * The NASID should be shifted by this amount and stored into the
+ * interrupt(x) register.
+ */
+#define BRIDGE_INT_ADDR_NASID_SHFT	8
+
+/*
+ * The BRIDGE_INT_ADDR_DEST_IO bit should be set to send an interrupt to
+ * memory.
+ */
+#define BRIDGE_INT_ADDR_DEST_IO		(1 << 17)
+#define BRIDGE_INT_ADDR_DEST_MEM	0
+#define BRIDGE_INT_ADDR_MASK		(1 << 17)
+
+/* Bridge device(x) register bits definition */
+#define BRIDGE_DEV_ERR_LOCK_EN		0x10000000
+#define BRIDGE_DEV_PAGE_CHK_DIS		0x08000000
+#define BRIDGE_DEV_FORCE_PCI_PAR	0x04000000
+#define BRIDGE_DEV_VIRTUAL_EN		0x02000000
+#define BRIDGE_DEV_PMU_WRGA_EN		0x01000000
+#define BRIDGE_DEV_DIR_WRGA_EN		0x00800000
+#define BRIDGE_DEV_DEV_SIZE		0x00400000
+#define BRIDGE_DEV_RT			0x00200000
+#define BRIDGE_DEV_SWAP_PMU		0x00100000
+#define BRIDGE_DEV_SWAP_DIR		0x00080000
+#define BRIDGE_DEV_PREF			0x00040000
+#define BRIDGE_DEV_PRECISE		0x00020000
+#define BRIDGE_DEV_COH			0x00010000
+#define BRIDGE_DEV_BARRIER		0x00008000
+#define BRIDGE_DEV_GBR			0x00004000
+#define BRIDGE_DEV_DEV_SWAP		0x00002000
+#define BRIDGE_DEV_DEV_IO_MEM		0x00001000
+#define BRIDGE_DEV_OFF_MASK		0x00000fff
+#define BRIDGE_DEV_OFF_ADDR_SHFT	20
+
+#define BRIDGE_DEV_PMU_BITS		(BRIDGE_DEV_PMU_WRGA_EN		| \
+					 BRIDGE_DEV_SWAP_PMU)
+#define BRIDGE_DEV_D32_BITS		(BRIDGE_DEV_DIR_WRGA_EN		| \
+					 BRIDGE_DEV_SWAP_DIR		| \
+					 BRIDGE_DEV_PREF		| \
+					 BRIDGE_DEV_PRECISE		| \
+					 BRIDGE_DEV_COH			| \
+					 BRIDGE_DEV_BARRIER)
+#define BRIDGE_DEV_D64_BITS		(BRIDGE_DEV_DIR_WRGA_EN		| \
+					 BRIDGE_DEV_SWAP_DIR		| \
+					 BRIDGE_DEV_COH			| \
+					 BRIDGE_DEV_BARRIER)
+
+/* Bridge Error Upper register bit field definition */
+#define BRIDGE_ERRUPPR_DEVMASTER	(0x1 << 20)	/* Device was master */
+#define BRIDGE_ERRUPPR_PCIVDEV		(0x1 << 19)	/* Virtual Req value */
+#define BRIDGE_ERRUPPR_DEVNUM_SHFT	(16)
+#define BRIDGE_ERRUPPR_DEVNUM_MASK	(0x7 << BRIDGE_ERRUPPR_DEVNUM_SHFT)
+#define BRIDGE_ERRUPPR_DEVICE(err)	(((err) >> BRIDGE_ERRUPPR_DEVNUM_SHFT) & 0x7)
+#define BRIDGE_ERRUPPR_ADDRMASK		(0xFFFF)
+
+/* Bridge interrupt mode register bits definition */
+#define BRIDGE_INTMODE_CLR_PKT_EN(x)	(0x1 << (x))
+
+/* this should be written to the xbow's link_control(x) register */
+#define BRIDGE_CREDIT	3
+
+/* RRB assignment register */
+#define	BRIDGE_RRB_EN	0x8	/* after shifting down */
+#define	BRIDGE_RRB_DEV	0x7	/* after shifting down */
+#define	BRIDGE_RRB_VDEV	0x4	/* after shifting down */
+#define	BRIDGE_RRB_PDEV	0x3	/* after shifting down */
+
+/* RRB status register */
+#define	BRIDGE_RRB_VALID(r)	(0x00010000<<(r))
+#define	BRIDGE_RRB_INUSE(r)	(0x00000001<<(r))
+
+/* RRB clear register */
+#define	BRIDGE_RRB_CLEAR(r)	(0x00000001<<(r))
+
+/* xbox system controller declarations */
+#define XBOX_BRIDGE_WID         8
+#define FLASH_PROM1_BASE        0xE00000 /* To read the xbox sysctlr status */
+#define XBOX_RPS_EXISTS		1 << 6	 /* RPS bit in status register */
+#define XBOX_RPS_FAIL		1 << 4	 /* RPS status bit in register */
+
+/* ========================================================================
+ */
+/*
+ * Macros for Xtalk to Bridge bus (PCI/GIO) PIO
+ * refer to section 4.2.1 of Bridge Spec for xtalk to PCI/GIO PIO mappings
+ */
+/* XTALK addresses that map into Bridge Bus addr space */
+#define BRIDGE_PIO32_XTALK_ALIAS_BASE	0x000040000000L
+#define BRIDGE_PIO32_XTALK_ALIAS_LIMIT	0x00007FFFFFFFL
+#define BRIDGE_PIO64_XTALK_ALIAS_BASE	0x000080000000L
+#define BRIDGE_PIO64_XTALK_ALIAS_LIMIT	0x0000BFFFFFFFL
+#define BRIDGE_PCIIO_XTALK_ALIAS_BASE	0x000100000000L
+#define BRIDGE_PCIIO_XTALK_ALIAS_LIMIT	0x0001FFFFFFFFL
+
+/* Ranges of PCI bus space that can be accessed via PIO from xtalk */
+#define BRIDGE_MIN_PIO_ADDR_MEM		0x00000000	/* 1G PCI memory space */
+#define BRIDGE_MAX_PIO_ADDR_MEM		0x3fffffff
+#define BRIDGE_MIN_PIO_ADDR_IO		0x00000000	/* 4G PCI IO space */
+#define BRIDGE_MAX_PIO_ADDR_IO		0xffffffff
+
+/* XTALK addresses that map into PCI addresses */
+#define BRIDGE_PCI_MEM32_BASE		BRIDGE_PIO32_XTALK_ALIAS_BASE
+#define BRIDGE_PCI_MEM32_LIMIT		BRIDGE_PIO32_XTALK_ALIAS_LIMIT
+#define BRIDGE_PCI_MEM64_BASE		BRIDGE_PIO64_XTALK_ALIAS_BASE
+#define BRIDGE_PCI_MEM64_LIMIT		BRIDGE_PIO64_XTALK_ALIAS_LIMIT
+#define BRIDGE_PCI_IO_BASE		BRIDGE_PCIIO_XTALK_ALIAS_BASE
+#define BRIDGE_PCI_IO_LIMIT		BRIDGE_PCIIO_XTALK_ALIAS_LIMIT
+
+/*
+ * Macros for Bridge bus (PCI/GIO) to Xtalk DMA
+ */
+/* Bridge Bus DMA addresses */
+#define BRIDGE_LOCAL_BASE		0
+#define BRIDGE_DMA_MAPPED_BASE		0x40000000
+#define BRIDGE_DMA_MAPPED_SIZE		0x40000000	/* 1G Bytes */
+#define BRIDGE_DMA_DIRECT_BASE		0x80000000
+#define BRIDGE_DMA_DIRECT_SIZE		0x80000000	/* 2G Bytes */
+
+#define PCI32_LOCAL_BASE		BRIDGE_LOCAL_BASE
+
+/* PCI addresses of regions decoded by Bridge for DMA */
+#define PCI32_MAPPED_BASE		BRIDGE_DMA_MAPPED_BASE
+#define PCI32_DIRECT_BASE		BRIDGE_DMA_DIRECT_BASE
+
+#define IS_PCI32_LOCAL(x)	((ulong_t)(x) < PCI32_MAPPED_BASE)
+#define IS_PCI32_MAPPED(x)	((ulong_t)(x) < PCI32_DIRECT_BASE && \
+					(ulong_t)(x) >= PCI32_MAPPED_BASE)
+#define IS_PCI32_DIRECT(x)	((ulong_t)(x) >= PCI32_MAPPED_BASE)
+#define IS_PCI64(x)		((ulong_t)(x) >= PCI64_BASE)
+
+/*
+ * The GIO address space.
+ */
+/* Xtalk to GIO PIO */
+#define BRIDGE_GIO_MEM32_BASE		BRIDGE_PIO32_XTALK_ALIAS_BASE
+#define BRIDGE_GIO_MEM32_LIMIT		BRIDGE_PIO32_XTALK_ALIAS_LIMIT
+
+#define GIO_LOCAL_BASE			BRIDGE_LOCAL_BASE
+
+/* GIO addresses of regions decoded by Bridge for DMA */
+#define GIO_MAPPED_BASE			BRIDGE_DMA_MAPPED_BASE
+#define GIO_DIRECT_BASE			BRIDGE_DMA_DIRECT_BASE
+
+#define IS_GIO_LOCAL(x)		((ulong_t)(x) < GIO_MAPPED_BASE)
+#define IS_GIO_MAPPED(x)	((ulong_t)(x) < GIO_DIRECT_BASE && \
+					(ulong_t)(x) >= GIO_MAPPED_BASE)
+#define IS_GIO_DIRECT(x)	((ulong_t)(x) >= GIO_MAPPED_BASE)
+
+/* PCI to xtalk mapping */
+
+/* given a DIR_OFF value and a pci/gio 32 bits direct address, determine
+ * which xtalk address is accessed
+ */
+#define BRIDGE_DIRECT_32_SEG_SIZE	BRIDGE_DMA_DIRECT_SIZE
+#define BRIDGE_DIRECT_32_TO_XTALK(dir_off,adr)		\
+	((dir_off) * BRIDGE_DIRECT_32_SEG_SIZE +	\
+		((adr) & (BRIDGE_DIRECT_32_SEG_SIZE - 1)) + PHYS_RAMBASE)
+
+/* 64-bit address attribute masks */
+#define PCI64_ATTR_TARG_MASK	0xf000000000000000
+#define PCI64_ATTR_TARG_SHFT	60
+#define PCI64_ATTR_PREF		0x0800000000000000
+#define PCI64_ATTR_PREC		0x0400000000000000
+#define PCI64_ATTR_VIRTUAL	0x0200000000000000
+#define PCI64_ATTR_BAR		0x0100000000000000
+#define PCI64_ATTR_RMF_MASK	0x00ff000000000000
+#define PCI64_ATTR_RMF_SHFT	48
+
+#ifndef __ASSEMBLY__
+/* Address translation entry for mapped pci32 accesses */
+typedef union ate_u {
+	u64	ent;
+	struct ate_s {
+		u64	rmf:16;
+		u64	addr:36;
+		u64	targ:4;
+		u64	reserved:3;
+		u64	barrier:1;
+		u64	prefetch:1;
+		u64	precise:1;
+		u64	coherent:1;
+		u64	valid:1;
+	} field;
+} ate_t;
+#endif /* !__ASSEMBLY__ */
+
+#define ATE_V		0x01
+#define ATE_CO		0x02
+#define ATE_PREC	0x04
+#define ATE_PREF	0x08
+#define ATE_BAR		0x10
+
+#define ATE_PFNSHIFT		12
+#define ATE_TIDSHIFT		8
+#define ATE_RMFSHIFT		48
+
+#define mkate(xaddr, xid, attr) ((xaddr) & 0x0000fffffffff000ULL) | \
+				((xid)<<ATE_TIDSHIFT) | \
+				(attr)
+
+#define BRIDGE_INTERNAL_ATES	128
+
+struct bridge_controller {
+	struct pci_controller	pc;
+	struct resource		mem;
+	struct resource		io;
+	bridge_t		*base;
+	nasid_t			nasid;
+	unsigned int		widget_id;
+	unsigned int 		irq_cpu;
+	dma64_addr_t		baddr;
+	unsigned int		pci_int[8];
+};
+
+#define BRIDGE_CONTROLLER(bus) \
+	((struct bridge_controller *)((bus)->sysdata))
+
+extern void register_bridge_irq(unsigned int irq);
+extern int request_bridge_irq(struct bridge_controller *bc);
+
+extern struct pci_ops bridge_pci_ops;
+
+#endif /* _ASM_PCI_BRIDGE_H */
