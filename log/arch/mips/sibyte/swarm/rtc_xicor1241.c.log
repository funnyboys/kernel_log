commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/sibyte/swarm/rtc_xicor1241.c b/arch/mips/sibyte/swarm/rtc_xicor1241.c
index 2dcaaa7e3bfa..e2164200ceec 100644
--- a/arch/mips/sibyte/swarm/rtc_xicor1241.c
+++ b/arch/mips/sibyte/swarm/rtc_xicor1241.c
@@ -1,13 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (C) 2000, 2001 Broadcom Corporation
  *
  * Copyright (C) 2002 MontaVista Software Inc.
  * Author: jsun@mvista.com or jsun@junsun.net
- *
- * This program is free software; you can redistribute	it and/or modify it
- * under  the terms of	the GNU General	 Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
  */
 #include <linux/bcd.h>
 #include <linux/types.h>

commit f06e7aa47f3cad55c5737eb87280e90e25882d60
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Mon May 7 17:28:28 2018 +0800

    MIPS: Convert update_persistent_clock() to update_persistent_clock64()
    
    Since struct timespec is not y2038 safe on 32bit machines, this patch
    converts update_persistent_clock() to update_persistent_clock64() using
    struct timespec64.
    
    The rtc_mips_set_time() and rtc_mips_set_mmss() interfaces were using
    'unsigned long' type that is not y2038 safe on 32bit machines, moreover
    there is only one platform implementing rtc_mips_set_time() and two
    platforms implementing rtc_mips_set_mmss(), so we can just make them each
    implement update_persistent_clock64() directly, to get that helper out
    of the common mips code by removing rtc_mips_set_time() and
    rtc_mips_set_mmss() interfaces.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: linux-mips@linux-mips.org
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/sibyte/swarm/rtc_xicor1241.c b/arch/mips/sibyte/swarm/rtc_xicor1241.c
index a2121c1345a9..2dcaaa7e3bfa 100644
--- a/arch/mips/sibyte/swarm/rtc_xicor1241.c
+++ b/arch/mips/sibyte/swarm/rtc_xicor1241.c
@@ -109,13 +109,13 @@ static int xicor_write(uint8_t addr, int b)
 	}
 }
 
-int xicor_set_time(unsigned long t)
+int xicor_set_time(time64_t t)
 {
 	struct rtc_time tm;
 	int tmp;
 	unsigned long flags;
 
-	rtc_time_to_tm(t, &tm);
+	rtc_time64_to_tm(t, &tm);
 	tm.tm_year += 1900;
 
 	spin_lock_irqsave(&rtc_lock, flags);

commit 09adad17191942cac01ccfbb897b976ac8f42c22
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Mon May 7 17:28:27 2018 +0800

    MIPS: Convert read_persistent_clock() to read_persistent_clock64()
    
    Since struct timespec is not y2038 safe on 32bit machines, this patch
    converts read_persistent_clock() to read_persistent_clock64() using
    struct timespec64, as well as converting mktime() to mktime64().
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: linux-mips@linux-mips.org
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/sibyte/swarm/rtc_xicor1241.c b/arch/mips/sibyte/swarm/rtc_xicor1241.c
index 50a82c495427..a2121c1345a9 100644
--- a/arch/mips/sibyte/swarm/rtc_xicor1241.c
+++ b/arch/mips/sibyte/swarm/rtc_xicor1241.c
@@ -168,7 +168,7 @@ int xicor_set_time(unsigned long t)
 	return 0;
 }
 
-unsigned long xicor_get_time(void)
+time64_t xicor_get_time(void)
 {
 	unsigned int year, mon, day, hour, min, sec, y2k;
 	unsigned long flags;
@@ -201,7 +201,7 @@ unsigned long xicor_get_time(void)
 
 	year += (y2k * 100);
 
-	return mktime(year, mon, day, hour, min, sec);
+	return mktime64(year, mon, day, hour, min, sec);
 }
 
 int xicor_probe(void)

commit 635c99070600ff04b4c1d5afe67f051631a8397c
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Oct 21 14:12:49 2014 +0200

    MIPS: Remove useless parentheses
    
    Based on the spatch
    
    @@
    expression e;
    @@
    - return (e);
    + return e;
    
    with heavy hand editing because some of the changes are either whitespace
    or identation only or result in excessivly long lines.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/swarm/rtc_xicor1241.c b/arch/mips/sibyte/swarm/rtc_xicor1241.c
index 178a824b28d4..50a82c495427 100644
--- a/arch/mips/sibyte/swarm/rtc_xicor1241.c
+++ b/arch/mips/sibyte/swarm/rtc_xicor1241.c
@@ -84,7 +84,7 @@ static int xicor_read(uint8_t addr)
 		return -1;
 	}
 
-	return (__raw_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
+	return __raw_readq(SMB_CSR(R_SMB_DATA)) & 0xff;
 }
 
 static int xicor_write(uint8_t addr, int b)
@@ -206,5 +206,5 @@ unsigned long xicor_get_time(void)
 
 int xicor_probe(void)
 {
-	return (xicor_read(X1241REG_SC) != -1);
+	return xicor_read(X1241REG_SC) != -1;
 }

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/swarm/rtc_xicor1241.c b/arch/mips/sibyte/swarm/rtc_xicor1241.c
index 4438b2195c44..178a824b28d4 100644
--- a/arch/mips/sibyte/swarm/rtc_xicor1241.c
+++ b/arch/mips/sibyte/swarm/rtc_xicor1241.c
@@ -4,8 +4,8 @@
  * Copyright (C) 2002 MontaVista Software Inc.
  * Author: jsun@mvista.com or jsun@junsun.net
  *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
+ * This program is free software; you can redistribute	it and/or modify it
+ * under  the terms of	the GNU General	 Public License as published by the
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
  */
@@ -28,15 +28,15 @@
  * Register bits
  */
 
-#define X1241REG_SR_BAT	0x80		/* currently on battery power */
+#define X1241REG_SR_BAT 0x80		/* currently on battery power */
 #define X1241REG_SR_RWEL 0x04		/* r/w latch is enabled, can write RTC */
 #define X1241REG_SR_WEL 0x02		/* r/w latch is unlocked, can enable r/w now */
 #define X1241REG_SR_RTCF 0x01		/* clock failed */
 #define X1241REG_BL_BP2 0x80		/* block protect 2 */
 #define X1241REG_BL_BP1 0x40		/* block protect 1 */
 #define X1241REG_BL_BP0 0x20		/* block protect 0 */
-#define X1241REG_BL_WD1	0x10
-#define X1241REG_BL_WD0	0x08
+#define X1241REG_BL_WD1 0x10
+#define X1241REG_BL_WD0 0x08
 #define X1241REG_HR_MIL 0x80		/* military time format */
 
 /*
@@ -61,50 +61,50 @@
 
 static int xicor_read(uint8_t addr)
 {
-        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
-                ;
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+		;
 
 	__raw_writeq((addr >> 8) & 0x7, SMB_CSR(R_SMB_CMD));
 	__raw_writeq(addr & 0xff, SMB_CSR(R_SMB_DATA));
 	__raw_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR2BYTE,
 		     SMB_CSR(R_SMB_START));
 
-        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
-                ;
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+		;
 
 	__raw_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_RD1BYTE,
 		     SMB_CSR(R_SMB_START));
 
-        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
-                ;
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+		;
 
-        if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
-                /* Clear error bit by writing a 1 */
-                __raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
-                return -1;
-        }
+	if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+		/* Clear error bit by writing a 1 */
+		__raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+		return -1;
+	}
 
 	return (__raw_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
 }
 
 static int xicor_write(uint8_t addr, int b)
 {
-        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
-                ;
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+		;
 
 	__raw_writeq(addr, SMB_CSR(R_SMB_CMD));
 	__raw_writeq((addr & 0xff) | ((b & 0xff) << 8), SMB_CSR(R_SMB_DATA));
 	__raw_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR3BYTE,
 		     SMB_CSR(R_SMB_START));
 
-        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
-                ;
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+		;
 
-        if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
-                /* Clear error bit by writing a 1 */
-                __raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
-                return -1;
-        } else {
+	if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+		/* Clear error bit by writing a 1 */
+		__raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+		return -1;
+	} else {
 		return 0;
 	}
 }

commit 02112dbc925f664bc4d24ff098686b9d21bfbfb1
Author: Adrian Bunk <bunk@kernel.org>
Date:   Sat Oct 18 20:28:44 2008 -0700

    mips: use bcd2bin/bin2bcd
    
    Changes mips to use the new bcd2bin/bin2bcd functions instead of the
    obsolete BCD_TO_BIN/BIN_TO_BCD/BCD2BIN/BIN2BCD macros.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/sibyte/swarm/rtc_xicor1241.c b/arch/mips/sibyte/swarm/rtc_xicor1241.c
index ff3e5dabb348..4438b2195c44 100644
--- a/arch/mips/sibyte/swarm/rtc_xicor1241.c
+++ b/arch/mips/sibyte/swarm/rtc_xicor1241.c
@@ -124,18 +124,18 @@ int xicor_set_time(unsigned long t)
 	xicor_write(X1241REG_SR, X1241REG_SR_WEL | X1241REG_SR_RWEL);
 
 	/* trivial ones */
-	tm.tm_sec = BIN2BCD(tm.tm_sec);
+	tm.tm_sec = bin2bcd(tm.tm_sec);
 	xicor_write(X1241REG_SC, tm.tm_sec);
 
-	tm.tm_min = BIN2BCD(tm.tm_min);
+	tm.tm_min = bin2bcd(tm.tm_min);
 	xicor_write(X1241REG_MN, tm.tm_min);
 
-	tm.tm_mday = BIN2BCD(tm.tm_mday);
+	tm.tm_mday = bin2bcd(tm.tm_mday);
 	xicor_write(X1241REG_DT, tm.tm_mday);
 
 	/* tm_mon starts from 0, *ick* */
 	tm.tm_mon ++;
-	tm.tm_mon = BIN2BCD(tm.tm_mon);
+	tm.tm_mon = bin2bcd(tm.tm_mon);
 	xicor_write(X1241REG_MO, tm.tm_mon);
 
 	/* year is split */
@@ -148,7 +148,7 @@ int xicor_set_time(unsigned long t)
 	tmp = xicor_read(X1241REG_HR);
 	if (tmp & X1241REG_HR_MIL) {
 		/* 24 hour format */
-		tm.tm_hour = BIN2BCD(tm.tm_hour);
+		tm.tm_hour = bin2bcd(tm.tm_hour);
 		tmp = (tmp & ~0x3f) | (tm.tm_hour & 0x3f);
 	} else {
 		/* 12 hour format, with 0x2 for pm */
@@ -157,7 +157,7 @@ int xicor_set_time(unsigned long t)
 			tmp |= 0x20;
 			tm.tm_hour -= 12;
 		}
-		tm.tm_hour = BIN2BCD(tm.tm_hour);
+		tm.tm_hour = bin2bcd(tm.tm_hour);
 		tmp |= tm.tm_hour;
 	}
 	xicor_write(X1241REG_HR, tmp);
@@ -191,13 +191,13 @@ unsigned long xicor_get_time(void)
 	y2k = xicor_read(X1241REG_Y2K);
 	spin_unlock_irqrestore(&rtc_lock, flags);
 
-	sec = BCD2BIN(sec);
-	min = BCD2BIN(min);
-	hour = BCD2BIN(hour);
-	day = BCD2BIN(day);
-	mon = BCD2BIN(mon);
-	year = BCD2BIN(year);
-	y2k = BCD2BIN(y2k);
+	sec = bcd2bin(sec);
+	min = bcd2bin(min);
+	hour = bcd2bin(hour);
+	day = bcd2bin(day);
+	mon = bcd2bin(mon);
+	year = bcd2bin(year);
+	y2k = bcd2bin(y2k);
 
 	year += (y2k * 100);
 

commit 90b02340dcc6ce00bf22c48f4865915f5989e5e4
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Oct 11 23:46:09 2007 +0100

    [MIPS] Switch from to_tm to rtc_time_to_tm
    
    This replaces the MIPS-specific to_tm function with the generic
    rtc_time_to_tm function.  The big difference between the two functions is
    that rtc_time_to_tm uses epoch 70 while to_tm uses 1970, so the result of
    rtc_time_to_tm needs to be fixed up.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/swarm/rtc_xicor1241.c b/arch/mips/sibyte/swarm/rtc_xicor1241.c
index f4a178836415..ff3e5dabb348 100644
--- a/arch/mips/sibyte/swarm/rtc_xicor1241.c
+++ b/arch/mips/sibyte/swarm/rtc_xicor1241.c
@@ -115,7 +115,8 @@ int xicor_set_time(unsigned long t)
 	int tmp;
 	unsigned long flags;
 
-	to_tm(t, &tm);
+	rtc_time_to_tm(t, &tm);
+	tm.tm_year += 1900;
 
 	spin_lock_irqsave(&rtc_lock, flags);
 	/* unlock writes to the CCR */

commit 53c2df2f4ebbc1d8231ca7cc13ac5381230888b1
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Nov 3 01:01:15 2005 +0900

    Use rtc_lock to protect RTC operations
    
    Many RTC routines were not protected against each other, so there are
    potential races, for example, ntp-update against /dev/rtc.  This patch
    fixes them using rtc_lock.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/swarm/rtc_xicor1241.c b/arch/mips/sibyte/swarm/rtc_xicor1241.c
index d9ff9323f24e..f4a178836415 100644
--- a/arch/mips/sibyte/swarm/rtc_xicor1241.c
+++ b/arch/mips/sibyte/swarm/rtc_xicor1241.c
@@ -113,9 +113,11 @@ int xicor_set_time(unsigned long t)
 {
 	struct rtc_time tm;
 	int tmp;
+	unsigned long flags;
 
 	to_tm(t, &tm);
 
+	spin_lock_irqsave(&rtc_lock, flags);
 	/* unlock writes to the CCR */
 	xicor_write(X1241REG_SR, X1241REG_SR_WEL);
 	xicor_write(X1241REG_SR, X1241REG_SR_WEL | X1241REG_SR_RWEL);
@@ -160,6 +162,7 @@ int xicor_set_time(unsigned long t)
 	xicor_write(X1241REG_HR, tmp);
 
 	xicor_write(X1241REG_SR, 0);
+	spin_unlock_irqrestore(&rtc_lock, flags);
 
 	return 0;
 }
@@ -167,7 +170,9 @@ int xicor_set_time(unsigned long t)
 unsigned long xicor_get_time(void)
 {
 	unsigned int year, mon, day, hour, min, sec, y2k;
+	unsigned long flags;
 
+	spin_lock_irqsave(&rtc_lock, flags);
 	sec = xicor_read(X1241REG_SC);
 	min = xicor_read(X1241REG_MN);
 	hour = xicor_read(X1241REG_HR);
@@ -183,6 +188,7 @@ unsigned long xicor_get_time(void)
 	mon = xicor_read(X1241REG_MO);
 	year = xicor_read(X1241REG_YR);
 	y2k = xicor_read(X1241REG_Y2K);
+	spin_unlock_irqrestore(&rtc_lock, flags);
 
 	sec = BCD2BIN(sec);
 	min = BCD2BIN(min);

commit 65bda1a95d395c256818d1d8129487a4497b29d8
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Tue Feb 22 21:51:30 2005 +0000

    Switch SiByte drivers back to __raw_*() functions.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/swarm/rtc_xicor1241.c b/arch/mips/sibyte/swarm/rtc_xicor1241.c
index 981d21f16e64..d9ff9323f24e 100644
--- a/arch/mips/sibyte/swarm/rtc_xicor1241.c
+++ b/arch/mips/sibyte/swarm/rtc_xicor1241.c
@@ -57,52 +57,52 @@
 
 #define X1241_CCR_ADDRESS	0x6F
 
-#define SMB_CSR(reg) ((u8 *) (IOADDR(A_SMB_REGISTER(1, reg))))
+#define SMB_CSR(reg)	IOADDR(A_SMB_REGISTER(1, reg))
 
 static int xicor_read(uint8_t addr)
 {
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	bus_writeq((addr >> 8) & 0x7, SMB_CSR(R_SMB_CMD));
-	bus_writeq((addr & 0xff), SMB_CSR(R_SMB_DATA));
-	bus_writeq((V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR2BYTE),
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq((addr >> 8) & 0x7, SMB_CSR(R_SMB_CMD));
+	__raw_writeq(addr & 0xff, SMB_CSR(R_SMB_DATA));
+	__raw_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR2BYTE,
+		     SMB_CSR(R_SMB_START));
 
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	bus_writeq((V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_RD1BYTE),
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_RD1BYTE,
+		     SMB_CSR(R_SMB_START));
 
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-        if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+        if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
                 /* Clear error bit by writing a 1 */
-                bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+                __raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
                 return -1;
         }
 
-	return (bus_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
+	return (__raw_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
 }
 
 static int xicor_write(uint8_t addr, int b)
 {
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	bus_writeq(addr, SMB_CSR(R_SMB_CMD));
-	bus_writeq((addr & 0xff) | ((b & 0xff) << 8), SMB_CSR(R_SMB_DATA));
-	bus_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR3BYTE,
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(addr, SMB_CSR(R_SMB_CMD));
+	__raw_writeq((addr & 0xff) | ((b & 0xff) << 8), SMB_CSR(R_SMB_DATA));
+	__raw_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR3BYTE,
+		     SMB_CSR(R_SMB_START));
 
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-        if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+        if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
                 /* Clear error bit by writing a 1 */
-                bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+                __raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
                 return -1;
         } else {
 		return 0;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/mips/sibyte/swarm/rtc_xicor1241.c b/arch/mips/sibyte/swarm/rtc_xicor1241.c
new file mode 100644
index 000000000000..981d21f16e64
--- /dev/null
+++ b/arch/mips/sibyte/swarm/rtc_xicor1241.c
@@ -0,0 +1,203 @@
+/*
+ * Copyright (C) 2000, 2001 Broadcom Corporation
+ *
+ * Copyright (C) 2002 MontaVista Software Inc.
+ * Author: jsun@mvista.com or jsun@junsun.net
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/bcd.h>
+#include <linux/types.h>
+#include <linux/time.h>
+
+#include <asm/time.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+
+#include <asm/sibyte/sb1250.h>
+#include <asm/sibyte/sb1250_regs.h>
+#include <asm/sibyte/sb1250_smbus.h>
+
+
+/* Xicor 1241 definitions */
+
+/*
+ * Register bits
+ */
+
+#define X1241REG_SR_BAT	0x80		/* currently on battery power */
+#define X1241REG_SR_RWEL 0x04		/* r/w latch is enabled, can write RTC */
+#define X1241REG_SR_WEL 0x02		/* r/w latch is unlocked, can enable r/w now */
+#define X1241REG_SR_RTCF 0x01		/* clock failed */
+#define X1241REG_BL_BP2 0x80		/* block protect 2 */
+#define X1241REG_BL_BP1 0x40		/* block protect 1 */
+#define X1241REG_BL_BP0 0x20		/* block protect 0 */
+#define X1241REG_BL_WD1	0x10
+#define X1241REG_BL_WD0	0x08
+#define X1241REG_HR_MIL 0x80		/* military time format */
+
+/*
+ * Register numbers
+ */
+
+#define X1241REG_BL	0x10		/* block protect bits */
+#define X1241REG_INT	0x11		/*  */
+#define X1241REG_SC	0x30		/* Seconds */
+#define X1241REG_MN	0x31		/* Minutes */
+#define X1241REG_HR	0x32		/* Hours */
+#define X1241REG_DT	0x33		/* Day of month */
+#define X1241REG_MO	0x34		/* Month */
+#define X1241REG_YR	0x35		/* Year */
+#define X1241REG_DW	0x36		/* Day of Week */
+#define X1241REG_Y2K	0x37		/* Year 2K */
+#define X1241REG_SR	0x3F		/* Status register */
+
+#define X1241_CCR_ADDRESS	0x6F
+
+#define SMB_CSR(reg) ((u8 *) (IOADDR(A_SMB_REGISTER(1, reg))))
+
+static int xicor_read(uint8_t addr)
+{
+        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+                ;
+
+	bus_writeq((addr >> 8) & 0x7, SMB_CSR(R_SMB_CMD));
+	bus_writeq((addr & 0xff), SMB_CSR(R_SMB_DATA));
+	bus_writeq((V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR2BYTE),
+		   SMB_CSR(R_SMB_START));
+
+        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+                ;
+
+	bus_writeq((V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_RD1BYTE),
+		   SMB_CSR(R_SMB_START));
+
+        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+                ;
+
+        if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+                /* Clear error bit by writing a 1 */
+                bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+                return -1;
+        }
+
+	return (bus_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
+}
+
+static int xicor_write(uint8_t addr, int b)
+{
+        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+                ;
+
+	bus_writeq(addr, SMB_CSR(R_SMB_CMD));
+	bus_writeq((addr & 0xff) | ((b & 0xff) << 8), SMB_CSR(R_SMB_DATA));
+	bus_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR3BYTE,
+		   SMB_CSR(R_SMB_START));
+
+        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+                ;
+
+        if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+                /* Clear error bit by writing a 1 */
+                bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+                return -1;
+        } else {
+		return 0;
+	}
+}
+
+int xicor_set_time(unsigned long t)
+{
+	struct rtc_time tm;
+	int tmp;
+
+	to_tm(t, &tm);
+
+	/* unlock writes to the CCR */
+	xicor_write(X1241REG_SR, X1241REG_SR_WEL);
+	xicor_write(X1241REG_SR, X1241REG_SR_WEL | X1241REG_SR_RWEL);
+
+	/* trivial ones */
+	tm.tm_sec = BIN2BCD(tm.tm_sec);
+	xicor_write(X1241REG_SC, tm.tm_sec);
+
+	tm.tm_min = BIN2BCD(tm.tm_min);
+	xicor_write(X1241REG_MN, tm.tm_min);
+
+	tm.tm_mday = BIN2BCD(tm.tm_mday);
+	xicor_write(X1241REG_DT, tm.tm_mday);
+
+	/* tm_mon starts from 0, *ick* */
+	tm.tm_mon ++;
+	tm.tm_mon = BIN2BCD(tm.tm_mon);
+	xicor_write(X1241REG_MO, tm.tm_mon);
+
+	/* year is split */
+	tmp = tm.tm_year / 100;
+	tm.tm_year %= 100;
+	xicor_write(X1241REG_YR, tm.tm_year);
+	xicor_write(X1241REG_Y2K, tmp);
+
+	/* hour is the most tricky one */
+	tmp = xicor_read(X1241REG_HR);
+	if (tmp & X1241REG_HR_MIL) {
+		/* 24 hour format */
+		tm.tm_hour = BIN2BCD(tm.tm_hour);
+		tmp = (tmp & ~0x3f) | (tm.tm_hour & 0x3f);
+	} else {
+		/* 12 hour format, with 0x2 for pm */
+		tmp = tmp & ~0x3f;
+		if (tm.tm_hour >= 12) {
+			tmp |= 0x20;
+			tm.tm_hour -= 12;
+		}
+		tm.tm_hour = BIN2BCD(tm.tm_hour);
+		tmp |= tm.tm_hour;
+	}
+	xicor_write(X1241REG_HR, tmp);
+
+	xicor_write(X1241REG_SR, 0);
+
+	return 0;
+}
+
+unsigned long xicor_get_time(void)
+{
+	unsigned int year, mon, day, hour, min, sec, y2k;
+
+	sec = xicor_read(X1241REG_SC);
+	min = xicor_read(X1241REG_MN);
+	hour = xicor_read(X1241REG_HR);
+
+	if (hour & X1241REG_HR_MIL) {
+		hour &= 0x3f;
+	} else {
+		if (hour & 0x20)
+			hour = (hour & 0xf) + 0x12;
+	}
+
+	day = xicor_read(X1241REG_DT);
+	mon = xicor_read(X1241REG_MO);
+	year = xicor_read(X1241REG_YR);
+	y2k = xicor_read(X1241REG_Y2K);
+
+	sec = BCD2BIN(sec);
+	min = BCD2BIN(min);
+	hour = BCD2BIN(hour);
+	day = BCD2BIN(day);
+	mon = BCD2BIN(mon);
+	year = BCD2BIN(year);
+	y2k = BCD2BIN(y2k);
+
+	year += (y2k * 100);
+
+	return mktime(year, mon, day, hour, min, sec);
+}
+
+int xicor_probe(void)
+{
+	return (xicor_read(X1241REG_SC) != -1);
+}
