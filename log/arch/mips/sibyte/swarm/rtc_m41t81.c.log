commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/sibyte/swarm/rtc_m41t81.c b/arch/mips/sibyte/swarm/rtc_m41t81.c
index 4ac8ccdf56bb..afe1e3460bd4 100644
--- a/arch/mips/sibyte/swarm/rtc_m41t81.c
+++ b/arch/mips/sibyte/swarm/rtc_m41t81.c
@@ -1,14 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (C) 2000, 2001 Broadcom Corporation
  *
  * Copyright (C) 2002 MontaVista Software Inc.
  * Author: jsun@mvista.com or jsun@junsun.net
- *
- * This program is free software; you can redistribute	it and/or modify it
- * under  the terms of	the GNU General	 Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
- *
  */
 #include <linux/bcd.h>
 #include <linux/types.h>

commit f06e7aa47f3cad55c5737eb87280e90e25882d60
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Mon May 7 17:28:28 2018 +0800

    MIPS: Convert update_persistent_clock() to update_persistent_clock64()
    
    Since struct timespec is not y2038 safe on 32bit machines, this patch
    converts update_persistent_clock() to update_persistent_clock64() using
    struct timespec64.
    
    The rtc_mips_set_time() and rtc_mips_set_mmss() interfaces were using
    'unsigned long' type that is not y2038 safe on 32bit machines, moreover
    there is only one platform implementing rtc_mips_set_time() and two
    platforms implementing rtc_mips_set_mmss(), so we can just make them each
    implement update_persistent_clock64() directly, to get that helper out
    of the common mips code by removing rtc_mips_set_time() and
    rtc_mips_set_mmss() interfaces.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: linux-mips@linux-mips.org
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/sibyte/swarm/rtc_m41t81.c b/arch/mips/sibyte/swarm/rtc_m41t81.c
index aa27a2226472..4ac8ccdf56bb 100644
--- a/arch/mips/sibyte/swarm/rtc_m41t81.c
+++ b/arch/mips/sibyte/swarm/rtc_m41t81.c
@@ -141,13 +141,13 @@ static int m41t81_write(uint8_t addr, int b)
 	return 0;
 }
 
-int m41t81_set_time(unsigned long t)
+int m41t81_set_time(time64_t t)
 {
 	struct rtc_time tm;
 	unsigned long flags;
 
 	/* Note we don't care about the century */
-	rtc_time_to_tm(t, &tm);
+	rtc_time64_to_tm(t, &tm);
 
 	/*
 	 * Note the write order matters as it ensures the correctness.

commit 09adad17191942cac01ccfbb897b976ac8f42c22
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Mon May 7 17:28:27 2018 +0800

    MIPS: Convert read_persistent_clock() to read_persistent_clock64()
    
    Since struct timespec is not y2038 safe on 32bit machines, this patch
    converts read_persistent_clock() to read_persistent_clock64() using
    struct timespec64, as well as converting mktime() to mktime64().
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: linux-mips@linux-mips.org
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/sibyte/swarm/rtc_m41t81.c b/arch/mips/sibyte/swarm/rtc_m41t81.c
index e62466445f08..aa27a2226472 100644
--- a/arch/mips/sibyte/swarm/rtc_m41t81.c
+++ b/arch/mips/sibyte/swarm/rtc_m41t81.c
@@ -188,7 +188,7 @@ int m41t81_set_time(unsigned long t)
 	return 0;
 }
 
-unsigned long m41t81_get_time(void)
+time64_t m41t81_get_time(void)
 {
 	unsigned int year, mon, day, hour, min, sec;
 	unsigned long flags;
@@ -218,7 +218,7 @@ unsigned long m41t81_get_time(void)
 
 	year += 2000;
 
-	return mktime(year, mon, day, hour, min, sec);
+	return mktime64(year, mon, day, hour, min, sec);
 }
 
 int m41t81_probe(void)

commit 635c99070600ff04b4c1d5afe67f051631a8397c
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Oct 21 14:12:49 2014 +0200

    MIPS: Remove useless parentheses
    
    Based on the spatch
    
    @@
    expression e;
    @@
    - return (e);
    + return e;
    
    with heavy hand editing because some of the changes are either whitespace
    or identation only or result in excessivly long lines.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/swarm/rtc_m41t81.c b/arch/mips/sibyte/swarm/rtc_m41t81.c
index b732600b47f5..e62466445f08 100644
--- a/arch/mips/sibyte/swarm/rtc_m41t81.c
+++ b/arch/mips/sibyte/swarm/rtc_m41t81.c
@@ -109,7 +109,7 @@ static int m41t81_read(uint8_t addr)
 		return -1;
 	}
 
-	return (__raw_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
+	return __raw_readq(SMB_CSR(R_SMB_DATA)) & 0xff;
 }
 
 static int m41t81_write(uint8_t addr, int b)
@@ -229,5 +229,5 @@ int m41t81_probe(void)
 	tmp = m41t81_read(M41T81REG_SC);
 	m41t81_write(M41T81REG_SC, tmp & 0x7f);
 
-	return (m41t81_read(M41T81REG_SC) != -1);
+	return m41t81_read(M41T81REG_SC) != -1;
 }

commit 02112dbc925f664bc4d24ff098686b9d21bfbfb1
Author: Adrian Bunk <bunk@kernel.org>
Date:   Sat Oct 18 20:28:44 2008 -0700

    mips: use bcd2bin/bin2bcd
    
    Changes mips to use the new bcd2bin/bin2bcd functions instead of the
    obsolete BCD_TO_BIN/BIN_TO_BCD/BCD2BIN/BIN2BCD macros.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/sibyte/swarm/rtc_m41t81.c b/arch/mips/sibyte/swarm/rtc_m41t81.c
index 26fbff4c15b1..b732600b47f5 100644
--- a/arch/mips/sibyte/swarm/rtc_m41t81.c
+++ b/arch/mips/sibyte/swarm/rtc_m41t81.c
@@ -156,32 +156,32 @@ int m41t81_set_time(unsigned long t)
 	 */
 
 	spin_lock_irqsave(&rtc_lock, flags);
-	tm.tm_sec = BIN2BCD(tm.tm_sec);
+	tm.tm_sec = bin2bcd(tm.tm_sec);
 	m41t81_write(M41T81REG_SC, tm.tm_sec);
 
-	tm.tm_min = BIN2BCD(tm.tm_min);
+	tm.tm_min = bin2bcd(tm.tm_min);
 	m41t81_write(M41T81REG_MN, tm.tm_min);
 
-	tm.tm_hour = BIN2BCD(tm.tm_hour);
+	tm.tm_hour = bin2bcd(tm.tm_hour);
 	tm.tm_hour = (tm.tm_hour & 0x3f) | (m41t81_read(M41T81REG_HR) & 0xc0);
 	m41t81_write(M41T81REG_HR, tm.tm_hour);
 
 	/* tm_wday starts from 0 to 6 */
 	if (tm.tm_wday == 0) tm.tm_wday = 7;
-	tm.tm_wday = BIN2BCD(tm.tm_wday);
+	tm.tm_wday = bin2bcd(tm.tm_wday);
 	m41t81_write(M41T81REG_DY, tm.tm_wday);
 
-	tm.tm_mday = BIN2BCD(tm.tm_mday);
+	tm.tm_mday = bin2bcd(tm.tm_mday);
 	m41t81_write(M41T81REG_DT, tm.tm_mday);
 
 	/* tm_mon starts from 0, *ick* */
 	tm.tm_mon ++;
-	tm.tm_mon = BIN2BCD(tm.tm_mon);
+	tm.tm_mon = bin2bcd(tm.tm_mon);
 	m41t81_write(M41T81REG_MO, tm.tm_mon);
 
 	/* we don't do century, everything is beyond 2000 */
 	tm.tm_year %= 100;
-	tm.tm_year = BIN2BCD(tm.tm_year);
+	tm.tm_year = bin2bcd(tm.tm_year);
 	m41t81_write(M41T81REG_YR, tm.tm_year);
 	spin_unlock_irqrestore(&rtc_lock, flags);
 
@@ -209,12 +209,12 @@ unsigned long m41t81_get_time(void)
 	year = m41t81_read(M41T81REG_YR);
 	spin_unlock_irqrestore(&rtc_lock, flags);
 
-	sec = BCD2BIN(sec);
-	min = BCD2BIN(min);
-	hour = BCD2BIN(hour);
-	day = BCD2BIN(day);
-	mon = BCD2BIN(mon);
-	year = BCD2BIN(year);
+	sec = bcd2bin(sec);
+	min = bcd2bin(min);
+	hour = bcd2bin(hour);
+	day = bcd2bin(day);
+	mon = bcd2bin(mon);
+	year = bcd2bin(year);
 
 	year += 2000;
 

commit 90b02340dcc6ce00bf22c48f4865915f5989e5e4
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Oct 11 23:46:09 2007 +0100

    [MIPS] Switch from to_tm to rtc_time_to_tm
    
    This replaces the MIPS-specific to_tm function with the generic
    rtc_time_to_tm function.  The big difference between the two functions is
    that rtc_time_to_tm uses epoch 70 while to_tm uses 1970, so the result of
    rtc_time_to_tm needs to be fixed up.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/swarm/rtc_m41t81.c b/arch/mips/sibyte/swarm/rtc_m41t81.c
index c13914bdda59..26fbff4c15b1 100644
--- a/arch/mips/sibyte/swarm/rtc_m41t81.c
+++ b/arch/mips/sibyte/swarm/rtc_m41t81.c
@@ -146,7 +146,8 @@ int m41t81_set_time(unsigned long t)
 	struct rtc_time tm;
 	unsigned long flags;
 
-	to_tm(t, &tm);
+	/* Note we don't care about the century */
+	rtc_time_to_tm(t, &tm);
 
 	/*
 	 * Note the write order matters as it ensures the correctness.

commit 53c2df2f4ebbc1d8231ca7cc13ac5381230888b1
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Nov 3 01:01:15 2005 +0900

    Use rtc_lock to protect RTC operations
    
    Many RTC routines were not protected against each other, so there are
    potential races, for example, ntp-update against /dev/rtc.  This patch
    fixes them using rtc_lock.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/swarm/rtc_m41t81.c b/arch/mips/sibyte/swarm/rtc_m41t81.c
index 5b4fc26c1b36..c13914bdda59 100644
--- a/arch/mips/sibyte/swarm/rtc_m41t81.c
+++ b/arch/mips/sibyte/swarm/rtc_m41t81.c
@@ -144,6 +144,7 @@ static int m41t81_write(uint8_t addr, int b)
 int m41t81_set_time(unsigned long t)
 {
 	struct rtc_time tm;
+	unsigned long flags;
 
 	to_tm(t, &tm);
 
@@ -153,6 +154,7 @@ int m41t81_set_time(unsigned long t)
 	 * believe we should finish writing min within a second.
 	 */
 
+	spin_lock_irqsave(&rtc_lock, flags);
 	tm.tm_sec = BIN2BCD(tm.tm_sec);
 	m41t81_write(M41T81REG_SC, tm.tm_sec);
 
@@ -180,6 +182,7 @@ int m41t81_set_time(unsigned long t)
 	tm.tm_year %= 100;
 	tm.tm_year = BIN2BCD(tm.tm_year);
 	m41t81_write(M41T81REG_YR, tm.tm_year);
+	spin_unlock_irqrestore(&rtc_lock, flags);
 
 	return 0;
 }
@@ -187,19 +190,23 @@ int m41t81_set_time(unsigned long t)
 unsigned long m41t81_get_time(void)
 {
 	unsigned int year, mon, day, hour, min, sec;
+	unsigned long flags;
 
 	/*
 	 * min is valid if two reads of sec are the same.
 	 */
 	for (;;) {
+		spin_lock_irqsave(&rtc_lock, flags);
 		sec = m41t81_read(M41T81REG_SC);
 		min = m41t81_read(M41T81REG_MN);
 		if (sec == m41t81_read(M41T81REG_SC)) break;
+		spin_unlock_irqrestore(&rtc_lock, flags);
 	}
 	hour = m41t81_read(M41T81REG_HR) & 0x3f;
 	day = m41t81_read(M41T81REG_DT);
 	mon = m41t81_read(M41T81REG_MO);
 	year = m41t81_read(M41T81REG_YR);
+	spin_unlock_irqrestore(&rtc_lock, flags);
 
 	sec = BCD2BIN(sec);
 	min = BCD2BIN(min);

commit 65bda1a95d395c256818d1d8129487a4497b29d8
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Tue Feb 22 21:51:30 2005 +0000

    Switch SiByte drivers back to __raw_*() functions.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/swarm/rtc_m41t81.c b/arch/mips/sibyte/swarm/rtc_m41t81.c
index a686bb716ec6..5b4fc26c1b36 100644
--- a/arch/mips/sibyte/swarm/rtc_m41t81.c
+++ b/arch/mips/sibyte/swarm/rtc_m41t81.c
@@ -82,59 +82,60 @@
 #define M41T81REG_SQW	0x13		/* square wave register */
 
 #define M41T81_CCR_ADDRESS	0x68
-#define SMB_CSR(reg) ((u8 *) (IOADDR(A_SMB_REGISTER(1, reg))))
+
+#define SMB_CSR(reg)	IOADDR(A_SMB_REGISTER(1, reg))
 
 static int m41t81_read(uint8_t addr)
 {
-	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
-	bus_writeq(addr & 0xff, SMB_CSR(R_SMB_CMD));
-	bus_writeq((V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_WR1BYTE),
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(addr & 0xff, SMB_CSR(R_SMB_CMD));
+	__raw_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_WR1BYTE,
+		     SMB_CSR(R_SMB_START));
 
-	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
-	bus_writeq((V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_RD1BYTE),
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_RD1BYTE,
+		     SMB_CSR(R_SMB_START));
 
-	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
-	if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+	if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
 		/* Clear error bit by writing a 1 */
-		bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+		__raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
 		return -1;
 	}
 
-	return (bus_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
+	return (__raw_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
 }
 
 static int m41t81_write(uint8_t addr, int b)
 {
-	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
-	bus_writeq((addr & 0xFF), SMB_CSR(R_SMB_CMD));
-	bus_writeq((b & 0xff), SMB_CSR(R_SMB_DATA));
-	bus_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_WR2BYTE,
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(addr & 0xff, SMB_CSR(R_SMB_CMD));
+	__raw_writeq(b & 0xff, SMB_CSR(R_SMB_DATA));
+	__raw_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_WR2BYTE,
+		     SMB_CSR(R_SMB_START));
 
-	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
-	if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+	if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
 		/* Clear error bit by writing a 1 */
-		bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+		__raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
 		return -1;
 	}
 
 	/* read the same byte again to make sure it is written */
-	bus_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_RD1BYTE,
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_RD1BYTE,
+		     SMB_CSR(R_SMB_START));
 
-	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
 	return 0;

commit 42a3b4f25af8f8d77feddf27f839fa0628dbff1a
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Sep 3 15:56:17 2005 -0700

    [PATCH] mips: nuke trailing whitespace
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/sibyte/swarm/rtc_m41t81.c b/arch/mips/sibyte/swarm/rtc_m41t81.c
index 0e633ee8d83c..a686bb716ec6 100644
--- a/arch/mips/sibyte/swarm/rtc_m41t81.c
+++ b/arch/mips/sibyte/swarm/rtc_m41t81.c
@@ -128,7 +128,7 @@ static int m41t81_write(uint8_t addr, int b)
 		/* Clear error bit by writing a 1 */
 		bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
 		return -1;
-	} 
+	}
 
 	/* read the same byte again to make sure it is written */
 	bus_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_RD1BYTE,
@@ -136,7 +136,7 @@ static int m41t81_write(uint8_t addr, int b)
 
 	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
-	
+
 	return 0;
 }
 
@@ -148,13 +148,13 @@ int m41t81_set_time(unsigned long t)
 
 	/*
 	 * Note the write order matters as it ensures the correctness.
-	 * When we write sec, 10th sec is clear.  It is reasonable to 
+	 * When we write sec, 10th sec is clear.  It is reasonable to
 	 * believe we should finish writing min within a second.
 	 */
 
 	tm.tm_sec = BIN2BCD(tm.tm_sec);
 	m41t81_write(M41T81REG_SC, tm.tm_sec);
-	
+
 	tm.tm_min = BIN2BCD(tm.tm_min);
 	m41t81_write(M41T81REG_MN, tm.tm_min);
 
@@ -187,7 +187,7 @@ unsigned long m41t81_get_time(void)
 {
 	unsigned int year, mon, day, hour, min, sec;
 
-	/* 
+	/*
 	 * min is valid if two reads of sec are the same.
 	 */
 	for (;;) {

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/mips/sibyte/swarm/rtc_m41t81.c b/arch/mips/sibyte/swarm/rtc_m41t81.c
new file mode 100644
index 000000000000..0e633ee8d83c
--- /dev/null
+++ b/arch/mips/sibyte/swarm/rtc_m41t81.c
@@ -0,0 +1,224 @@
+/*
+ * Copyright (C) 2000, 2001 Broadcom Corporation
+ *
+ * Copyright (C) 2002 MontaVista Software Inc.
+ * Author: jsun@mvista.com or jsun@junsun.net
+ *
+ * This program is free software; you can redistribute	it and/or modify it
+ * under  the terms of	the GNU General	 Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#include <linux/bcd.h>
+#include <linux/types.h>
+#include <linux/time.h>
+
+#include <asm/time.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+
+#include <asm/sibyte/sb1250.h>
+#include <asm/sibyte/sb1250_regs.h>
+#include <asm/sibyte/sb1250_smbus.h>
+
+
+/* M41T81 definitions */
+
+/*
+ * Register bits
+ */
+
+#define M41T81REG_SC_ST		0x80		/* stop bit */
+#define M41T81REG_HR_CB		0x40		/* century bit */
+#define M41T81REG_HR_CEB	0x80		/* century enable bit */
+#define M41T81REG_CTL_S		0x20		/* sign bit */
+#define M41T81REG_CTL_FT	0x40		/* frequency test bit */
+#define M41T81REG_CTL_OUT	0x80		/* output level */
+#define M41T81REG_WD_RB0	0x01		/* watchdog resolution bit 0 */
+#define M41T81REG_WD_RB1	0x02		/* watchdog resolution bit 1 */
+#define M41T81REG_WD_BMB0	0x04		/* watchdog multiplier bit 0 */
+#define M41T81REG_WD_BMB1	0x08		/* watchdog multiplier bit 1 */
+#define M41T81REG_WD_BMB2	0x10		/* watchdog multiplier bit 2 */
+#define M41T81REG_WD_BMB3	0x20		/* watchdog multiplier bit 3 */
+#define M41T81REG_WD_BMB4	0x40		/* watchdog multiplier bit 4 */
+#define M41T81REG_AMO_ABE	0x20		/* alarm in "battery back-up mode" enable bit */
+#define M41T81REG_AMO_SQWE	0x40		/* square wave enable */
+#define M41T81REG_AMO_AFE	0x80		/* alarm flag enable flag */
+#define M41T81REG_ADT_RPT5	0x40		/* alarm repeat mode bit 5 */
+#define M41T81REG_ADT_RPT4	0x80		/* alarm repeat mode bit 4 */
+#define M41T81REG_AHR_RPT3	0x80		/* alarm repeat mode bit 3 */
+#define M41T81REG_AHR_HT	0x40		/* halt update bit */
+#define M41T81REG_AMN_RPT2	0x80		/* alarm repeat mode bit 2 */
+#define M41T81REG_ASC_RPT1	0x80		/* alarm repeat mode bit 1 */
+#define M41T81REG_FLG_AF	0x40		/* alarm flag (read only) */
+#define M41T81REG_FLG_WDF	0x80		/* watchdog flag (read only) */
+#define M41T81REG_SQW_RS0	0x10		/* sqw frequency bit 0 */
+#define M41T81REG_SQW_RS1	0x20		/* sqw frequency bit 1 */
+#define M41T81REG_SQW_RS2	0x40		/* sqw frequency bit 2 */
+#define M41T81REG_SQW_RS3	0x80		/* sqw frequency bit 3 */
+
+
+/*
+ * Register numbers
+ */
+
+#define M41T81REG_TSC	0x00		/* tenths/hundredths of second */
+#define M41T81REG_SC	0x01		/* seconds */
+#define M41T81REG_MN	0x02		/* minute */
+#define M41T81REG_HR	0x03		/* hour/century */
+#define M41T81REG_DY	0x04		/* day of week */
+#define M41T81REG_DT	0x05		/* date of month */
+#define M41T81REG_MO	0x06		/* month */
+#define M41T81REG_YR	0x07		/* year */
+#define M41T81REG_CTL	0x08		/* control */
+#define M41T81REG_WD	0x09		/* watchdog */
+#define M41T81REG_AMO	0x0A		/* alarm: month */
+#define M41T81REG_ADT	0x0B		/* alarm: date */
+#define M41T81REG_AHR	0x0C		/* alarm: hour */
+#define M41T81REG_AMN	0x0D		/* alarm: minute */
+#define M41T81REG_ASC	0x0E		/* alarm: second */
+#define M41T81REG_FLG	0x0F		/* flags */
+#define M41T81REG_SQW	0x13		/* square wave register */
+
+#define M41T81_CCR_ADDRESS	0x68
+#define SMB_CSR(reg) ((u8 *) (IOADDR(A_SMB_REGISTER(1, reg))))
+
+static int m41t81_read(uint8_t addr)
+{
+	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+		;
+
+	bus_writeq(addr & 0xff, SMB_CSR(R_SMB_CMD));
+	bus_writeq((V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_WR1BYTE),
+		   SMB_CSR(R_SMB_START));
+
+	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+		;
+
+	bus_writeq((V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_RD1BYTE),
+		   SMB_CSR(R_SMB_START));
+
+	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+		;
+
+	if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+		/* Clear error bit by writing a 1 */
+		bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+		return -1;
+	}
+
+	return (bus_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
+}
+
+static int m41t81_write(uint8_t addr, int b)
+{
+	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+		;
+
+	bus_writeq((addr & 0xFF), SMB_CSR(R_SMB_CMD));
+	bus_writeq((b & 0xff), SMB_CSR(R_SMB_DATA));
+	bus_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_WR2BYTE,
+		   SMB_CSR(R_SMB_START));
+
+	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+		;
+
+	if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+		/* Clear error bit by writing a 1 */
+		bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+		return -1;
+	} 
+
+	/* read the same byte again to make sure it is written */
+	bus_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_RD1BYTE,
+		   SMB_CSR(R_SMB_START));
+
+	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+		;
+	
+	return 0;
+}
+
+int m41t81_set_time(unsigned long t)
+{
+	struct rtc_time tm;
+
+	to_tm(t, &tm);
+
+	/*
+	 * Note the write order matters as it ensures the correctness.
+	 * When we write sec, 10th sec is clear.  It is reasonable to 
+	 * believe we should finish writing min within a second.
+	 */
+
+	tm.tm_sec = BIN2BCD(tm.tm_sec);
+	m41t81_write(M41T81REG_SC, tm.tm_sec);
+	
+	tm.tm_min = BIN2BCD(tm.tm_min);
+	m41t81_write(M41T81REG_MN, tm.tm_min);
+
+	tm.tm_hour = BIN2BCD(tm.tm_hour);
+	tm.tm_hour = (tm.tm_hour & 0x3f) | (m41t81_read(M41T81REG_HR) & 0xc0);
+	m41t81_write(M41T81REG_HR, tm.tm_hour);
+
+	/* tm_wday starts from 0 to 6 */
+	if (tm.tm_wday == 0) tm.tm_wday = 7;
+	tm.tm_wday = BIN2BCD(tm.tm_wday);
+	m41t81_write(M41T81REG_DY, tm.tm_wday);
+
+	tm.tm_mday = BIN2BCD(tm.tm_mday);
+	m41t81_write(M41T81REG_DT, tm.tm_mday);
+
+	/* tm_mon starts from 0, *ick* */
+	tm.tm_mon ++;
+	tm.tm_mon = BIN2BCD(tm.tm_mon);
+	m41t81_write(M41T81REG_MO, tm.tm_mon);
+
+	/* we don't do century, everything is beyond 2000 */
+	tm.tm_year %= 100;
+	tm.tm_year = BIN2BCD(tm.tm_year);
+	m41t81_write(M41T81REG_YR, tm.tm_year);
+
+	return 0;
+}
+
+unsigned long m41t81_get_time(void)
+{
+	unsigned int year, mon, day, hour, min, sec;
+
+	/* 
+	 * min is valid if two reads of sec are the same.
+	 */
+	for (;;) {
+		sec = m41t81_read(M41T81REG_SC);
+		min = m41t81_read(M41T81REG_MN);
+		if (sec == m41t81_read(M41T81REG_SC)) break;
+	}
+	hour = m41t81_read(M41T81REG_HR) & 0x3f;
+	day = m41t81_read(M41T81REG_DT);
+	mon = m41t81_read(M41T81REG_MO);
+	year = m41t81_read(M41T81REG_YR);
+
+	sec = BCD2BIN(sec);
+	min = BCD2BIN(min);
+	hour = BCD2BIN(hour);
+	day = BCD2BIN(day);
+	mon = BCD2BIN(mon);
+	year = BCD2BIN(year);
+
+	year += 2000;
+
+	return mktime(year, mon, day, hour, min, sec);
+}
+
+int m41t81_probe(void)
+{
+	unsigned int tmp;
+
+	/* enable chip if it is not enabled yet */
+	tmp = m41t81_read(M41T81REG_SC);
+	m41t81_write(M41T81REG_SC, tmp & 0x7f);
+
+	return (m41t81_read(M41T81REG_SC) != -1);
+}
