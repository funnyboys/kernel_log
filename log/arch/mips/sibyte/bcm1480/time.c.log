commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/sibyte/bcm1480/time.c b/arch/mips/sibyte/bcm1480/time.c
index 1680a68952ae..e6450d79fb4f 100644
--- a/arch/mips/sibyte/bcm1480/time.c
+++ b/arch/mips/sibyte/bcm1480/time.c
@@ -1,19 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (C) 2000,2001,2004 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  */
 #include <linux/init.h>
 

commit 217dd11e9d0442767fa13c9c188be0b92dc93d7e
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Nov 1 01:57:55 2007 +0000

    [MIPS] Sibyte: Split and move clock code.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/bcm1480/time.c b/arch/mips/sibyte/bcm1480/time.c
index 2bcaf5419ac1..1680a68952ae 100644
--- a/arch/mips/sibyte/bcm1480/time.c
+++ b/arch/mips/sibyte/bcm1480/time.c
@@ -15,164 +15,10 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  */
-#include <linux/clockchips.h>
-#include <linux/interrupt.h>
-#include <linux/percpu.h>
+#include <linux/init.h>
 
-#include <asm/addrspace.h>
-#include <asm/io.h>
-#include <asm/time.h>
-
-#include <asm/sibyte/bcm1480_regs.h>
-#include <asm/sibyte/sb1250_regs.h>
-#include <asm/sibyte/bcm1480_int.h>
-#include <asm/sibyte/bcm1480_scd.h>
-
-#include <asm/sibyte/sb1250.h>
-
-
-#define IMR_IP2_VAL	K_BCM1480_INT_MAP_I0
-#define IMR_IP3_VAL	K_BCM1480_INT_MAP_I1
-#define IMR_IP4_VAL	K_BCM1480_INT_MAP_I2
-
-/*
- * The general purpose timer ticks at 1MHz independent if
- * the rest of the system
- */
-static void sibyte_set_mode(enum clock_event_mode mode,
-                           struct clock_event_device *evt)
-{
-	unsigned int cpu = smp_processor_id();
-	void __iomem *cfg, *init;
-
-	cfg = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG));
-	init = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT));
-
-	switch (mode) {
-	case CLOCK_EVT_MODE_PERIODIC:
-		__raw_writeq(0, cfg);
-		__raw_writeq((V_SCD_TIMER_FREQ / HZ) - 1, init);
-		__raw_writeq(M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS,
-			     cfg);
-		break;
-
-	case CLOCK_EVT_MODE_ONESHOT:
-		/* Stop the timer until we actually program a shot */
-	case CLOCK_EVT_MODE_SHUTDOWN:
-		__raw_writeq(0, cfg);
-		break;
-
-	case CLOCK_EVT_MODE_UNUSED:	/* shuddup gcc */
-	case CLOCK_EVT_MODE_RESUME:
-		;
-	}
-}
-
-static int sibyte_next_event(unsigned long delta, struct clock_event_device *cd)
-{
-	unsigned int cpu = smp_processor_id();
-	void __iomem *cfg, *init;
-
-	cfg = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG));
-	init = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT));
-
-	__raw_writeq(delta - 1, init);
-	__raw_writeq(M_SCD_TIMER_ENABLE, cfg);
-
-	return 0;
-}
-
-static irqreturn_t sibyte_counter_handler(int irq, void *dev_id)
-{
-	unsigned int cpu = smp_processor_id();
-	struct clock_event_device *cd = dev_id;
-	void __iomem *cfg;
-	unsigned long tmode;
-
-	if (cd->mode == CLOCK_EVT_MODE_PERIODIC)
-		tmode = M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS;
-	else
-		tmode = 0;
-
-	/* ACK interrupt */
-	cfg = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG));
-	____raw_writeq(tmode, cfg);
-
-	cd->event_handler(cd);
-
-	return IRQ_HANDLED;
-}
-
-static DEFINE_PER_CPU(struct clock_event_device, sibyte_hpt_clockevent);
-static DEFINE_PER_CPU(struct irqaction, sibyte_hpt_irqaction);
-static DEFINE_PER_CPU(char [18], sibyte_hpt_name);
-
-void __cpuinit sb1480_clockevent_init(void)
-{
-	unsigned int cpu = smp_processor_id();
-	unsigned int irq = K_BCM1480_INT_TIMER_0 + cpu;
-	struct irqaction *action = &per_cpu(sibyte_hpt_irqaction, cpu);
-	struct clock_event_device *cd = &per_cpu(sibyte_hpt_clockevent, cpu);
-	unsigned char *name = per_cpu(sibyte_hpt_name, cpu);
-
-	BUG_ON(cpu > 3);	/* Only have 4 general purpose timers */
-
-	sprintf(name, "bcm1480-counter-%d", cpu);
-	cd->name		= name;
-	cd->features		= CLOCK_EVT_FEAT_PERIODIC |
-				  CLOCK_EVT_FEAT_ONESHOT;
-	clockevent_set_clock(cd, V_SCD_TIMER_FREQ);
-	cd->max_delta_ns	= clockevent_delta2ns(0x7fffff, cd);
-	cd->min_delta_ns	= clockevent_delta2ns(1, cd);
-	cd->rating		= 200;
-	cd->irq			= irq;
-	cd->cpumask		= cpumask_of_cpu(cpu);
-	cd->set_next_event	= sibyte_next_event;
-	cd->set_mode		= sibyte_set_mode;
-	clockevents_register_device(cd);
-
-	bcm1480_mask_irq(cpu, irq);
-
-	/*
-	 * Map the timer interrupt to IP[4] of this cpu
-	 */
-	__raw_writeq(IMR_IP4_VAL,
-		     IOADDR(A_BCM1480_IMR_REGISTER(cpu,
-			R_BCM1480_IMR_INTERRUPT_MAP_BASE_H) + (irq << 3)));
-
-	bcm1480_unmask_irq(cpu, irq);
-
-	action->handler	= sibyte_counter_handler;
-	action->flags	= IRQF_DISABLED | IRQF_PERCPU;
-	action->name	= name;
-	action->dev_id	= cd;
-	setup_irq(irq, action);
-}
-
-static cycle_t bcm1480_hpt_read(void)
-{
-	return (cycle_t) __raw_readq(IOADDR(A_SCD_ZBBUS_CYCLE_COUNT));
-}
-
-struct clocksource bcm1480_clocksource = {
-	.name	= "zbbus-cycles",
-	.rating	= 200,
-	.read	= bcm1480_hpt_read,
-	.mask	= CLOCKSOURCE_MASK(64),
-	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,
-};
-
-void __init sb1480_clocksource_init(void)
-{
-	struct clocksource *cs = &bcm1480_clocksource;
-	unsigned int plldiv;
-	unsigned long zbbus;
-
-	plldiv = G_BCM1480_SYS_PLL_DIV(__raw_readq(IOADDR(A_SCD_SYSTEM_CFG)));
-	zbbus = ((plldiv >> 1) * 50000000) + ((plldiv & 1) * 25000000);
-	clocksource_set_clock(cs, zbbus);
-	clocksource_register(cs);
-}
+extern void sb1480_clockevent_init(void);
+extern void sb1480_clocksource_init(void);
 
 void __init plat_time_init(void)
 {

commit f3f9ad0edcc1b7bf154bb34fe3b3f71e5379c9f0
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Nov 1 00:24:50 2007 +0000

    [MIPS] Sibyte: Fixes for oneshot timer mode.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/bcm1480/time.c b/arch/mips/sibyte/bcm1480/time.c
index 39e77d9bd944..2bcaf5419ac1 100644
--- a/arch/mips/sibyte/bcm1480/time.c
+++ b/arch/mips/sibyte/bcm1480/time.c
@@ -17,13 +17,11 @@
  */
 #include <linux/clockchips.h>
 #include <linux/interrupt.h>
-#include <linux/irq.h>
 #include <linux/percpu.h>
-#include <linux/spinlock.h>
 
 #include <asm/addrspace.h>
-#include <asm/time.h>
 #include <asm/io.h>
+#include <asm/time.h>
 
 #include <asm/sibyte/bcm1480_regs.h>
 #include <asm/sibyte/sb1250_regs.h>
@@ -45,23 +43,23 @@ static void sibyte_set_mode(enum clock_event_mode mode,
                            struct clock_event_device *evt)
 {
 	unsigned int cpu = smp_processor_id();
-	void __iomem *timer_cfg, *timer_init;
+	void __iomem *cfg, *init;
 
-	timer_cfg = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG));
-	timer_init = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT));
+	cfg = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG));
+	init = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT));
 
 	switch (mode) {
 	case CLOCK_EVT_MODE_PERIODIC:
-		__raw_writeq(0, timer_cfg);
-		__raw_writeq((V_SCD_TIMER_FREQ / HZ) - 1, timer_init);
+		__raw_writeq(0, cfg);
+		__raw_writeq((V_SCD_TIMER_FREQ / HZ) - 1, init);
 		__raw_writeq(M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS,
-			     timer_cfg);
+			     cfg);
 		break;
 
 	case CLOCK_EVT_MODE_ONESHOT:
 		/* Stop the timer until we actually program a shot */
 	case CLOCK_EVT_MODE_SHUTDOWN:
-		__raw_writeq(0, timer_cfg);
+		__raw_writeq(0, cfg);
 		break;
 
 	case CLOCK_EVT_MODE_UNUSED:	/* shuddup gcc */
@@ -73,30 +71,33 @@ static void sibyte_set_mode(enum clock_event_mode mode,
 static int sibyte_next_event(unsigned long delta, struct clock_event_device *cd)
 {
 	unsigned int cpu = smp_processor_id();
-	void __iomem *timer_init;
-	unsigned int cnt;
-	int res;
+	void __iomem *cfg, *init;
 
-	timer_init = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT));
-	cnt = __raw_readq(timer_init);
-	cnt += delta;
-	__raw_writeq(cnt, timer_init);
-	res = ((long)(__raw_readq(timer_init) - cnt ) > 0) ? -ETIME : 0;
+	cfg = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG));
+	init = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT));
 
-	return res;
+	__raw_writeq(delta - 1, init);
+	__raw_writeq(M_SCD_TIMER_ENABLE, cfg);
+
+	return 0;
 }
 
 static irqreturn_t sibyte_counter_handler(int irq, void *dev_id)
 {
 	unsigned int cpu = smp_processor_id();
 	struct clock_event_device *cd = dev_id;
-	void __iomem *timer_cfg;
+	void __iomem *cfg;
+	unsigned long tmode;
+
+	if (cd->mode == CLOCK_EVT_MODE_PERIODIC)
+		tmode = M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS;
+	else
+		tmode = 0;
 
-	timer_cfg = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG));
+	/* ACK interrupt */
+	cfg = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG));
+	____raw_writeq(tmode, cfg);
 
-	/* Reset the timer */
-	__raw_writeq(M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS,
-	             timer_cfg);
 	cd->event_handler(cd);
 
 	return IRQ_HANDLED;
@@ -133,7 +134,7 @@ void __cpuinit sb1480_clockevent_init(void)
 	bcm1480_mask_irq(cpu, irq);
 
 	/*
-	 * Map timer interrupt to IP[4] of this cpu
+	 * Map the timer interrupt to IP[4] of this cpu
 	 */
 	__raw_writeq(IMR_IP4_VAL,
 		     IOADDR(A_BCM1480_IMR_REGISTER(cpu,

commit 2e5dcd2b4ce97ebc43703f2645bf2fe978da1627
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Oct 31 12:34:42 2007 +0000

    [MIPS] Sibyte: Fix names of the clockevent devices.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/bcm1480/time.c b/arch/mips/sibyte/bcm1480/time.c
index bbf19bfabccb..39e77d9bd944 100644
--- a/arch/mips/sibyte/bcm1480/time.c
+++ b/arch/mips/sibyte/bcm1480/time.c
@@ -116,7 +116,7 @@ void __cpuinit sb1480_clockevent_init(void)
 
 	BUG_ON(cpu > 3);	/* Only have 4 general purpose timers */
 
-	sprintf(name, "bcm1480-counter %d", cpu);
+	sprintf(name, "bcm1480-counter-%d", cpu);
 	cd->name		= name;
 	cd->features		= CLOCK_EVT_FEAT_PERIODIC |
 				  CLOCK_EVT_FEAT_ONESHOT;

commit 1238d5d868a56dcbc743d3ffc9bd3c920258b4cb
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Oct 29 11:36:24 2007 +0000

    [MIPS] time: Fix cut'n'paste bug in Sibyte clockevent driver.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/bcm1480/time.c b/arch/mips/sibyte/bcm1480/time.c
index 699b5d242dd8..bbf19bfabccb 100644
--- a/arch/mips/sibyte/bcm1480/time.c
+++ b/arch/mips/sibyte/bcm1480/time.c
@@ -119,7 +119,7 @@ void __cpuinit sb1480_clockevent_init(void)
 	sprintf(name, "bcm1480-counter %d", cpu);
 	cd->name		= name;
 	cd->features		= CLOCK_EVT_FEAT_PERIODIC |
-				  CLOCK_EVT_MODE_ONESHOT;
+				  CLOCK_EVT_FEAT_ONESHOT;
 	clockevent_set_clock(cd, V_SCD_TIMER_FREQ);
 	cd->max_delta_ns	= clockevent_delta2ns(0x7fffff, cd);
 	cd->min_delta_ns	= clockevent_delta2ns(1, cd);

commit 11ca25aa312d912c192ccfd5781669d794126118
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sun Oct 28 23:02:46 2007 +0000

    [MIPS] Sibyte: Delete {sb1250,bcm1480}_steal_irq().
    
    They break the timer interrupt initialization and only seem to be a kludge
    for initialization happening in the wrong order.  Further testing done by
    Thiemo confirms the suspicion that the other invocations also seem to have
    useless.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/bcm1480/time.c b/arch/mips/sibyte/bcm1480/time.c
index 610f0253954d..699b5d242dd8 100644
--- a/arch/mips/sibyte/bcm1480/time.c
+++ b/arch/mips/sibyte/bcm1480/time.c
@@ -37,8 +37,6 @@
 #define IMR_IP3_VAL	K_BCM1480_INT_MAP_I1
 #define IMR_IP4_VAL	K_BCM1480_INT_MAP_I2
 
-extern int bcm1480_steal_irq(int irq);
-
 /*
  * The general purpose timer ticks at 1MHz independent if
  * the rest of the system
@@ -142,7 +140,6 @@ void __cpuinit sb1480_clockevent_init(void)
 			R_BCM1480_IMR_INTERRUPT_MAP_BASE_H) + (irq << 3)));
 
 	bcm1480_unmask_irq(cpu, irq);
-	bcm1480_steal_irq(irq);
 
 	action->handler	= sibyte_counter_handler;
 	action->flags	= IRQF_DISABLED | IRQF_PERCPU;

commit d04533650f64fe3367e180f3e488d92205152cd3
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Oct 22 10:38:44 2007 +0100

    [MIPS] time: SMP-proofing of Sibyte clockevent/clocksource code.
    
    The BCM148 has 4 cores but there are also just 4 generic timers available
    so use the ZBbus cycle counter instead of it.  In addition the ZBbus
    counter also offers a much higher resolution and 64-bit counting so I'm
    considering a later complete conversion to it once I figure out if all
    members of the Sibyte SOC family support it - the docs seem to agree but
    the headers files seem to disagree ...
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/bcm1480/time.c b/arch/mips/sibyte/bcm1480/time.c
index c730744aa474..610f0253954d 100644
--- a/arch/mips/sibyte/bcm1480/time.c
+++ b/arch/mips/sibyte/bcm1480/time.c
@@ -15,22 +15,12 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  */
-
-/*
- * These are routines to set up and handle interrupts from the
- * bcm1480 general purpose timer 0.  We're using the timer as a
- * system clock, so we set it up to run at 100 Hz.  On every
- * interrupt, we update our idea of what the time of day is,
- * then call do_timer() in the architecture-independent kernel
- * code to do general bookkeeping (e.g. update jiffies, run
- * bottom halves, etc.)
- */
 #include <linux/clockchips.h>
 #include <linux/interrupt.h>
+#include <linux/irq.h>
 #include <linux/percpu.h>
 #include <linux/spinlock.h>
 
-#include <asm/irq.h>
 #include <asm/addrspace.h>
 #include <asm/time.h>
 #include <asm/io.h>
@@ -47,33 +37,10 @@
 #define IMR_IP3_VAL	K_BCM1480_INT_MAP_I1
 #define IMR_IP4_VAL	K_BCM1480_INT_MAP_I2
 
-#ifdef CONFIG_SIMULATION
-#define BCM1480_HPT_VALUE	50000
-#else
-#define BCM1480_HPT_VALUE	1000000
-#endif
-
 extern int bcm1480_steal_irq(int irq);
 
-void __init plat_time_init(void)
-{
-	unsigned int cpu = smp_processor_id();
-	unsigned int irq = K_BCM1480_INT_TIMER_0 + cpu;
-
-	BUG_ON(cpu > 3);	/* Only have 4 general purpose timers */
-
-	bcm1480_mask_irq(cpu, irq);
-
-	/* Map the timer interrupt to ip[4] of this cpu */
-	__raw_writeq(IMR_IP4_VAL, IOADDR(A_BCM1480_IMR_REGISTER(cpu, R_BCM1480_IMR_INTERRUPT_MAP_BASE_H)
-	      + (irq<<3)));
-
-	bcm1480_unmask_irq(cpu, irq);
-	bcm1480_steal_irq(irq);
-}
-
 /*
- * The general purpose timer ticks at 1 Mhz independent if
+ * The general purpose timer ticks at 1MHz independent if
  * the rest of the system
  */
 static void sibyte_set_mode(enum clock_event_mode mode,
@@ -88,7 +55,7 @@ static void sibyte_set_mode(enum clock_event_mode mode,
 	switch (mode) {
 	case CLOCK_EVT_MODE_PERIODIC:
 		__raw_writeq(0, timer_cfg);
-		__raw_writeq(BCM1480_HPT_VALUE / HZ - 1, timer_init);
+		__raw_writeq((V_SCD_TIMER_FREQ / HZ) - 1, timer_init);
 		__raw_writeq(M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS,
 			     timer_cfg);
 		break;
@@ -121,80 +88,96 @@ static int sibyte_next_event(unsigned long delta, struct clock_event_device *cd)
 	return res;
 }
 
-static DEFINE_PER_CPU(struct clock_event_device, sibyte_hpt_clockevent);
-
 static irqreturn_t sibyte_counter_handler(int irq, void *dev_id)
 {
 	unsigned int cpu = smp_processor_id();
-	struct clock_event_device *cd = &per_cpu(sibyte_hpt_clockevent, cpu);
+	struct clock_event_device *cd = dev_id;
+	void __iomem *timer_cfg;
+
+	timer_cfg = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG));
 
 	/* Reset the timer */
 	__raw_writeq(M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS,
-	             IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
+	             timer_cfg);
 	cd->event_handler(cd);
 
 	return IRQ_HANDLED;
 }
 
-static struct irqaction sibyte_counter_irqaction = {
-	.handler	= sibyte_counter_handler,
-	.flags		= IRQF_DISABLED | IRQF_PERCPU,
-	.name		= "timer",
-};
+static DEFINE_PER_CPU(struct clock_event_device, sibyte_hpt_clockevent);
+static DEFINE_PER_CPU(struct irqaction, sibyte_hpt_irqaction);
+static DEFINE_PER_CPU(char [18], sibyte_hpt_name);
 
-/*
- * This interrupt is "special" in that it doesn't use the request_irq
- * way to hook the irq line.  The timer interrupt is initialized early
- * enough to make this a major pain, and it's also firing enough to
- * warrant a bit of special case code.  bcm1480_timer_interrupt is
- * called directly from irq_handler.S when IP[4] is set during an
- * interrupt
- */
 void __cpuinit sb1480_clockevent_init(void)
 {
 	unsigned int cpu = smp_processor_id();
 	unsigned int irq = K_BCM1480_INT_TIMER_0 + cpu;
+	struct irqaction *action = &per_cpu(sibyte_hpt_irqaction, cpu);
 	struct clock_event_device *cd = &per_cpu(sibyte_hpt_clockevent, cpu);
+	unsigned char *name = per_cpu(sibyte_hpt_name, cpu);
+
+	BUG_ON(cpu > 3);	/* Only have 4 general purpose timers */
 
-	cd->name		= "bcm1480-counter";
+	sprintf(name, "bcm1480-counter %d", cpu);
+	cd->name		= name;
 	cd->features		= CLOCK_EVT_FEAT_PERIODIC |
 				  CLOCK_EVT_MODE_ONESHOT;
+	clockevent_set_clock(cd, V_SCD_TIMER_FREQ);
+	cd->max_delta_ns	= clockevent_delta2ns(0x7fffff, cd);
+	cd->min_delta_ns	= clockevent_delta2ns(1, cd);
+	cd->rating		= 200;
+	cd->irq			= irq;
+	cd->cpumask		= cpumask_of_cpu(cpu);
 	cd->set_next_event	= sibyte_next_event;
 	cd->set_mode		= sibyte_set_mode;
-	cd->irq			= irq;
-	clockevent_set_clock(cd, BCM1480_HPT_VALUE);
+	clockevents_register_device(cd);
+
+	bcm1480_mask_irq(cpu, irq);
+
+	/*
+	 * Map timer interrupt to IP[4] of this cpu
+	 */
+	__raw_writeq(IMR_IP4_VAL,
+		     IOADDR(A_BCM1480_IMR_REGISTER(cpu,
+			R_BCM1480_IMR_INTERRUPT_MAP_BASE_H) + (irq << 3)));
 
-	setup_irq(irq, &sibyte_counter_irqaction);
+	bcm1480_unmask_irq(cpu, irq);
+	bcm1480_steal_irq(irq);
+
+	action->handler	= sibyte_counter_handler;
+	action->flags	= IRQF_DISABLED | IRQF_PERCPU;
+	action->name	= name;
+	action->dev_id	= cd;
+	setup_irq(irq, action);
 }
 
 static cycle_t bcm1480_hpt_read(void)
 {
-	/* We assume this function is called xtime_lock held. */
-	unsigned long count =
-		__raw_readq(IOADDR(A_SCD_TIMER_REGISTER(0, R_SCD_TIMER_CNT)));
-	return (jiffies + 1) * (BCM1480_HPT_VALUE / HZ) - count;
+	return (cycle_t) __raw_readq(IOADDR(A_SCD_ZBBUS_CYCLE_COUNT));
 }
 
 struct clocksource bcm1480_clocksource = {
-	.name	= "MIPS",
+	.name	= "zbbus-cycles",
 	.rating	= 200,
 	.read	= bcm1480_hpt_read,
-	.mask	= CLOCKSOURCE_MASK(32),
-	.shift	= 32,
+	.mask	= CLOCKSOURCE_MASK(64),
 	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
 void __init sb1480_clocksource_init(void)
 {
 	struct clocksource *cs = &bcm1480_clocksource;
+	unsigned int plldiv;
+	unsigned long zbbus;
 
-	clocksource_set_clock(cs, BCM1480_HPT_VALUE);
+	plldiv = G_BCM1480_SYS_PLL_DIV(__raw_readq(IOADDR(A_SCD_SYSTEM_CFG)));
+	zbbus = ((plldiv >> 1) * 50000000) + ((plldiv & 1) * 25000000);
+	clocksource_set_clock(cs, zbbus);
 	clocksource_register(cs);
 }
 
-void __init bcm1480_hpt_setup(void)
+void __init plat_time_init(void)
 {
-	mips_hpt_frequency = BCM1480_HPT_VALUE;
 	sb1480_clocksource_init();
 	sb1480_clockevent_init();
 }

commit d527eef5b7f151320921f0ff7a88297cefc5be72
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Oct 19 08:22:38 2007 +0100

    [MIPS] Sibyte: Finish conversion to modern time APIs.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/bcm1480/time.c b/arch/mips/sibyte/bcm1480/time.c
index 5b4bfbbb5a24..c730744aa474 100644
--- a/arch/mips/sibyte/bcm1480/time.c
+++ b/arch/mips/sibyte/bcm1480/time.c
@@ -27,9 +27,8 @@
  */
 #include <linux/clockchips.h>
 #include <linux/interrupt.h>
-#include <linux/sched.h>
+#include <linux/percpu.h>
 #include <linux/spinlock.h>
-#include <linux/kernel_stat.h>
 
 #include <asm/irq.h>
 #include <asm/addrspace.h>
@@ -101,25 +100,36 @@ static void sibyte_set_mode(enum clock_event_mode mode,
 		break;
 
 	case CLOCK_EVT_MODE_UNUSED:	/* shuddup gcc */
+	case CLOCK_EVT_MODE_RESUME:
 		;
 	}
 }
 
-struct clock_event_device sibyte_hpt_clockevent = {
-	.name		= "bcm1480-counter",
-	.features	= CLOCK_EVT_FEAT_PERIODIC,
-	.set_mode	= sibyte_set_mode,
-	.shift		= 32,
-	.irq		= 0,
-};
+static int sibyte_next_event(unsigned long delta, struct clock_event_device *cd)
+{
+	unsigned int cpu = smp_processor_id();
+	void __iomem *timer_init;
+	unsigned int cnt;
+	int res;
+
+	timer_init = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT));
+	cnt = __raw_readq(timer_init);
+	cnt += delta;
+	__raw_writeq(cnt, timer_init);
+	res = ((long)(__raw_readq(timer_init) - cnt ) > 0) ? -ETIME : 0;
+
+	return res;
+}
+
+static DEFINE_PER_CPU(struct clock_event_device, sibyte_hpt_clockevent);
 
 static irqreturn_t sibyte_counter_handler(int irq, void *dev_id)
 {
-	struct clock_event_device *cd = &sibyte_hpt_clockevent;
 	unsigned int cpu = smp_processor_id();
+	struct clock_event_device *cd = &per_cpu(sibyte_hpt_clockevent, cpu);
 
 	/* Reset the timer */
-	__raw_writeq(M_SCD_TIMER_ENABLE|M_SCD_TIMER_MODE_CONTINUOUS,
+	__raw_writeq(M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS,
 	             IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
 	cd->event_handler(cd);
 
@@ -140,24 +150,21 @@ static struct irqaction sibyte_counter_irqaction = {
  * called directly from irq_handler.S when IP[4] is set during an
  * interrupt
  */
-static void __init sb1480_clockevent_init(void)
+void __cpuinit sb1480_clockevent_init(void)
 {
 	unsigned int cpu = smp_processor_id();
 	unsigned int irq = K_BCM1480_INT_TIMER_0 + cpu;
+	struct clock_event_device *cd = &per_cpu(sibyte_hpt_clockevent, cpu);
 
-	setup_irq(irq, &sibyte_counter_irqaction);
-}
+	cd->name		= "bcm1480-counter";
+	cd->features		= CLOCK_EVT_FEAT_PERIODIC |
+				  CLOCK_EVT_MODE_ONESHOT;
+	cd->set_next_event	= sibyte_next_event;
+	cd->set_mode		= sibyte_set_mode;
+	cd->irq			= irq;
+	clockevent_set_clock(cd, BCM1480_HPT_VALUE);
 
-void bcm1480_timer_interrupt(void)
-{
-	int cpu = smp_processor_id();
-	int irq = K_BCM1480_INT_TIMER_0 + cpu;
-
-	/* Reset the timer */
-	__raw_writeq(M_SCD_TIMER_ENABLE|M_SCD_TIMER_MODE_CONTINUOUS,
-	      IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
-
-	ll_timer_interrupt(irq);
+	setup_irq(irq, &sibyte_counter_irqaction);
 }
 
 static cycle_t bcm1480_hpt_read(void)
@@ -168,9 +175,26 @@ static cycle_t bcm1480_hpt_read(void)
 	return (jiffies + 1) * (BCM1480_HPT_VALUE / HZ) - count;
 }
 
+struct clocksource bcm1480_clocksource = {
+	.name	= "MIPS",
+	.rating	= 200,
+	.read	= bcm1480_hpt_read,
+	.mask	= CLOCKSOURCE_MASK(32),
+	.shift	= 32,
+	.flags	= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+void __init sb1480_clocksource_init(void)
+{
+	struct clocksource *cs = &bcm1480_clocksource;
+
+	clocksource_set_clock(cs, BCM1480_HPT_VALUE);
+	clocksource_register(cs);
+}
+
 void __init bcm1480_hpt_setup(void)
 {
-	clocksource_mips.read = bcm1480_hpt_read;
 	mips_hpt_frequency = BCM1480_HPT_VALUE;
+	sb1480_clocksource_init();
 	sb1480_clockevent_init();
 }

commit 9ee5389c58d7e74ae06887541fbb0ff6ecc6a499
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Oct 18 00:57:07 2007 +0900

    [MIPS] Sibyte: Fix typos in sibyte clockevent drivers
    
    Fix some typo introduced on clockevent conversion.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/bcm1480/time.c b/arch/mips/sibyte/bcm1480/time.c
index 40d7126cd5bf..5b4bfbbb5a24 100644
--- a/arch/mips/sibyte/bcm1480/time.c
+++ b/arch/mips/sibyte/bcm1480/time.c
@@ -84,7 +84,7 @@ static void sibyte_set_mode(enum clock_event_mode mode,
 	void __iomem *timer_cfg, *timer_init;
 
 	timer_cfg = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG));
-	timer_init = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG));
+	timer_init = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT));
 
 	switch (mode) {
 	case CLOCK_EVT_MODE_PERIODIC:

commit e9f874b6f761f7f8394157d28641491c9babc1d3
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Oct 11 23:46:10 2007 +0100

    [MIPS] Clockevent driver for BCM1480
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/bcm1480/time.c b/arch/mips/sibyte/bcm1480/time.c
index 8519091d848b..40d7126cd5bf 100644
--- a/arch/mips/sibyte/bcm1480/time.c
+++ b/arch/mips/sibyte/bcm1480/time.c
@@ -25,6 +25,7 @@
  * code to do general bookkeeping (e.g. update jiffies, run
  * bottom halves, etc.)
  */
+#include <linux/clockchips.h>
 #include <linux/interrupt.h>
 #include <linux/sched.h>
 #include <linux/spinlock.h>
@@ -55,15 +56,12 @@
 
 extern int bcm1480_steal_irq(int irq);
 
-void bcm1480_time_init(void)
+void __init plat_time_init(void)
 {
-	int cpu = smp_processor_id();
-	int irq = K_BCM1480_INT_TIMER_0+cpu;
+	unsigned int cpu = smp_processor_id();
+	unsigned int irq = K_BCM1480_INT_TIMER_0 + cpu;
 
-	/* Only have 4 general purpose timers */
-	if (cpu > 3) {
-		BUG();
-	}
+	BUG_ON(cpu > 3);	/* Only have 4 general purpose timers */
 
 	bcm1480_mask_irq(cpu, irq);
 
@@ -71,27 +69,83 @@ void bcm1480_time_init(void)
 	__raw_writeq(IMR_IP4_VAL, IOADDR(A_BCM1480_IMR_REGISTER(cpu, R_BCM1480_IMR_INTERRUPT_MAP_BASE_H)
 	      + (irq<<3)));
 
-	/* the general purpose timer ticks at 1 Mhz independent of the rest of the system */
-	/* Disable the timer and set up the count */
-	__raw_writeq(0, IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
-	__raw_writeq(
-		BCM1480_HPT_VALUE/HZ
-		, IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT)));
+	bcm1480_unmask_irq(cpu, irq);
+	bcm1480_steal_irq(irq);
+}
 
-	/* Set the timer running */
+/*
+ * The general purpose timer ticks at 1 Mhz independent if
+ * the rest of the system
+ */
+static void sibyte_set_mode(enum clock_event_mode mode,
+                           struct clock_event_device *evt)
+{
+	unsigned int cpu = smp_processor_id();
+	void __iomem *timer_cfg, *timer_init;
+
+	timer_cfg = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG));
+	timer_init = IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG));
+
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		__raw_writeq(0, timer_cfg);
+		__raw_writeq(BCM1480_HPT_VALUE / HZ - 1, timer_init);
+		__raw_writeq(M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS,
+			     timer_cfg);
+		break;
+
+	case CLOCK_EVT_MODE_ONESHOT:
+		/* Stop the timer until we actually program a shot */
+	case CLOCK_EVT_MODE_SHUTDOWN:
+		__raw_writeq(0, timer_cfg);
+		break;
+
+	case CLOCK_EVT_MODE_UNUSED:	/* shuddup gcc */
+		;
+	}
+}
+
+struct clock_event_device sibyte_hpt_clockevent = {
+	.name		= "bcm1480-counter",
+	.features	= CLOCK_EVT_FEAT_PERIODIC,
+	.set_mode	= sibyte_set_mode,
+	.shift		= 32,
+	.irq		= 0,
+};
+
+static irqreturn_t sibyte_counter_handler(int irq, void *dev_id)
+{
+	struct clock_event_device *cd = &sibyte_hpt_clockevent;
+	unsigned int cpu = smp_processor_id();
+
+	/* Reset the timer */
 	__raw_writeq(M_SCD_TIMER_ENABLE|M_SCD_TIMER_MODE_CONTINUOUS,
-	      IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
+	             IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
+	cd->event_handler(cd);
 
-	bcm1480_unmask_irq(cpu, irq);
-	bcm1480_steal_irq(irq);
-	/*
-	 * This interrupt is "special" in that it doesn't use the request_irq
-	 * way to hook the irq line.  The timer interrupt is initialized early
-	 * enough to make this a major pain, and it's also firing enough to
-	 * warrant a bit of special case code.  bcm1480_timer_interrupt is
-	 * called directly from irq_handler.S when IP[4] is set during an
-	 * interrupt
-	 */
+	return IRQ_HANDLED;
+}
+
+static struct irqaction sibyte_counter_irqaction = {
+	.handler	= sibyte_counter_handler,
+	.flags		= IRQF_DISABLED | IRQF_PERCPU,
+	.name		= "timer",
+};
+
+/*
+ * This interrupt is "special" in that it doesn't use the request_irq
+ * way to hook the irq line.  The timer interrupt is initialized early
+ * enough to make this a major pain, and it's also firing enough to
+ * warrant a bit of special case code.  bcm1480_timer_interrupt is
+ * called directly from irq_handler.S when IP[4] is set during an
+ * interrupt
+ */
+static void __init sb1480_clockevent_init(void)
+{
+	unsigned int cpu = smp_processor_id();
+	unsigned int irq = K_BCM1480_INT_TIMER_0 + cpu;
+
+	setup_irq(irq, &sibyte_counter_irqaction);
 }
 
 void bcm1480_timer_interrupt(void)
@@ -118,4 +172,5 @@ void __init bcm1480_hpt_setup(void)
 {
 	clocksource_mips.read = bcm1480_hpt_read;
 	mips_hpt_frequency = BCM1480_HPT_VALUE;
+	sb1480_clockevent_init();
 }

commit 91a2fcc88634663e9e13dcdfad0e4a860e64aeee
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Oct 11 23:46:09 2007 +0100

    [MIPS] Consolidate all variants of MIPS cp0 timer interrupt handlers.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/bcm1480/time.c b/arch/mips/sibyte/bcm1480/time.c
index 6f3f71bf4244..8519091d848b 100644
--- a/arch/mips/sibyte/bcm1480/time.c
+++ b/arch/mips/sibyte/bcm1480/time.c
@@ -103,18 +103,7 @@ void bcm1480_timer_interrupt(void)
 	__raw_writeq(M_SCD_TIMER_ENABLE|M_SCD_TIMER_MODE_CONTINUOUS,
 	      IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
 
-	if (cpu == 0) {
-		/*
-		 * CPU 0 handles the global timer interrupt job
-		 */
-		ll_timer_interrupt(irq);
-	}
-	else {
-		/*
-		 * other CPUs should just do profiling and process accounting
-		 */
-		ll_local_timer_interrupt(irq);
-	}
+	ll_timer_interrupt(irq);
 }
 
 static cycle_t bcm1480_hpt_read(void)

commit 005985609ff72df3257fde6b29aa9d71342c2a6b
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Sun Nov 12 00:10:28 2006 +0900

    [MIPS] mips HPT cleanup: make clocksource_mips public
    
    Make clocksource_mips public and get rid of mips_hpt_read,
    mips_hpt_mask.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/bcm1480/time.c b/arch/mips/sibyte/bcm1480/time.c
index 03d5822d3a73..6f3f71bf4244 100644
--- a/arch/mips/sibyte/bcm1480/time.c
+++ b/arch/mips/sibyte/bcm1480/time.c
@@ -117,7 +117,7 @@ void bcm1480_timer_interrupt(void)
 	}
 }
 
-static unsigned int bcm1480_hpt_read(void)
+static cycle_t bcm1480_hpt_read(void)
 {
 	/* We assume this function is called xtime_lock held. */
 	unsigned long count =
@@ -127,6 +127,6 @@ static unsigned int bcm1480_hpt_read(void)
 
 void __init bcm1480_hpt_setup(void)
 {
-	mips_hpt_read = bcm1480_hpt_read;
+	clocksource_mips.read = bcm1480_hpt_read;
 	mips_hpt_frequency = BCM1480_HPT_VALUE;
 }

commit dd6bfd627c4f4df771b9b73e4df75c6c0c177b09
Author: Nicolas Kaiser <nikai@nikai.net>
Date:   Tue Nov 7 09:56:24 2006 +0100

    [MIPS] Fix double inclusions
    
    Signed-off-by: Nicolas Kaiser <nikai@nikai.net>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/bcm1480/time.c b/arch/mips/sibyte/bcm1480/time.c
index e136bde5248e..03d5822d3a73 100644
--- a/arch/mips/sibyte/bcm1480/time.c
+++ b/arch/mips/sibyte/bcm1480/time.c
@@ -94,8 +94,6 @@ void bcm1480_time_init(void)
 	 */
 }
 
-#include <asm/sibyte/sb1250.h>
-
 void bcm1480_timer_interrupt(void)
 {
 	int cpu = smp_processor_id();

commit 16b7b2ac0148e839da86af8747b6fa4aad43a9b7
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Tue Oct 24 00:21:27 2006 +0900

    [MIPS] Fixup migration to GENERIC_TIME
    
    Since we already moved to GENERIC_TIME, we should implement alternatives
    of old do_gettimeoffset routines to get sub-jiffies resolution from
    gettimeofday().  This patch includes:
    
     * MIPS clocksource support (based on works by Manish Lachwani).
     * remove unused gettimeoffset routines and related codes.
     * remove unised 64bit do_div64_32().
     * simplify mips_hpt_init. (no argument needed, __init tag)
     * simplify c0_hpt_timer_init. (no need to write to c0_count)
     * remove some hpt_init routines.
     * mips_hpt_mask variable to specify bitmask of hpt value.
     * convert jmr3927_do_gettimeoffset to jmr3927_hpt_read.
     * convert ip27_do_gettimeoffset to ip27_hpt_read.
     * convert bcm1480_do_gettimeoffset to bcm1480_hpt_read.
     * simplify sb1250 hpt functions. (no need to subtract and shift)
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/bcm1480/time.c b/arch/mips/sibyte/bcm1480/time.c
index bf12af46132e..e136bde5248e 100644
--- a/arch/mips/sibyte/bcm1480/time.c
+++ b/arch/mips/sibyte/bcm1480/time.c
@@ -47,6 +47,12 @@
 #define IMR_IP3_VAL	K_BCM1480_INT_MAP_I1
 #define IMR_IP4_VAL	K_BCM1480_INT_MAP_I2
 
+#ifdef CONFIG_SIMULATION
+#define BCM1480_HPT_VALUE	50000
+#else
+#define BCM1480_HPT_VALUE	1000000
+#endif
+
 extern int bcm1480_steal_irq(int irq);
 
 void bcm1480_time_init(void)
@@ -59,11 +65,6 @@ void bcm1480_time_init(void)
 		BUG();
 	}
 
-	if (!cpu) {
-		/* Use our own gettimeoffset() routine */
-		do_gettimeoffset = bcm1480_gettimeoffset;
-	}
-
 	bcm1480_mask_irq(cpu, irq);
 
 	/* Map the timer interrupt to ip[4] of this cpu */
@@ -74,11 +75,7 @@ void bcm1480_time_init(void)
 	/* Disable the timer and set up the count */
 	__raw_writeq(0, IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
 	__raw_writeq(
-#ifndef CONFIG_SIMULATION
-		1000000/HZ
-#else
-		50000/HZ
-#endif
+		BCM1480_HPT_VALUE/HZ
 		, IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT)));
 
 	/* Set the timer running */
@@ -122,16 +119,16 @@ void bcm1480_timer_interrupt(void)
 	}
 }
 
-/*
- * We use our own do_gettimeoffset() instead of the generic one,
- * because the generic one does not work for SMP case.
- * In addition, since we use general timer 0 for system time,
- * we can get accurate intra-jiffy offset without calibration.
- */
-unsigned long bcm1480_gettimeoffset(void)
+static unsigned int bcm1480_hpt_read(void)
 {
+	/* We assume this function is called xtime_lock held. */
 	unsigned long count =
 		__raw_readq(IOADDR(A_SCD_TIMER_REGISTER(0, R_SCD_TIMER_CNT)));
+	return (jiffies + 1) * (BCM1480_HPT_VALUE / HZ) - count;
+}
 
-	return 1000000/HZ - count;
+void __init bcm1480_hpt_setup(void)
+{
+	mips_hpt_read = bcm1480_hpt_read;
+	mips_hpt_frequency = BCM1480_HPT_VALUE;
 }

commit 27f768192fe2d96936cef5d4713e228daee07ae2
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Oct 9 00:03:05 2006 +0100

    [MIPS] Cleanup unnecessary <asm/ptrace.h> inclusions.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/bcm1480/time.c b/arch/mips/sibyte/bcm1480/time.c
index f228f711dc34..bf12af46132e 100644
--- a/arch/mips/sibyte/bcm1480/time.c
+++ b/arch/mips/sibyte/bcm1480/time.c
@@ -31,7 +31,6 @@
 #include <linux/kernel_stat.h>
 
 #include <asm/irq.h>
-#include <asm/ptrace.h>
 #include <asm/addrspace.h>
 #include <asm/time.h>
 #include <asm/io.h>

commit 937a801576f954bd030d7c4a5a94571710d87c0b
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Oct 7 19:44:33 2006 +0100

    [MIPS] Complete fixes after removal of pt_regs argument to int handlers.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/bcm1480/time.c b/arch/mips/sibyte/bcm1480/time.c
index 7e088f6c4a86..f228f711dc34 100644
--- a/arch/mips/sibyte/bcm1480/time.c
+++ b/arch/mips/sibyte/bcm1480/time.c
@@ -100,10 +100,10 @@ void bcm1480_time_init(void)
 
 #include <asm/sibyte/sb1250.h>
 
-void bcm1480_timer_interrupt(struct pt_regs *regs)
+void bcm1480_timer_interrupt(void)
 {
 	int cpu = smp_processor_id();
-	int irq = K_BCM1480_INT_TIMER_0+cpu;
+	int irq = K_BCM1480_INT_TIMER_0 + cpu;
 
 	/* Reset the timer */
 	__raw_writeq(M_SCD_TIMER_ENABLE|M_SCD_TIMER_MODE_CONTINUOUS,
@@ -113,13 +113,13 @@ void bcm1480_timer_interrupt(struct pt_regs *regs)
 		/*
 		 * CPU 0 handles the global timer interrupt job
 		 */
-		ll_timer_interrupt(irq, regs);
+		ll_timer_interrupt(irq);
 	}
 	else {
 		/*
 		 * other CPUs should just do profiling and process accounting
 		 */
-		ll_local_timer_interrupt(irq, regs);
+		ll_local_timer_interrupt(irq);
 	}
 }
 

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/mips/sibyte/bcm1480/time.c b/arch/mips/sibyte/bcm1480/time.c
index efaf83efd2e4..7e088f6c4a86 100644
--- a/arch/mips/sibyte/bcm1480/time.c
+++ b/arch/mips/sibyte/bcm1480/time.c
@@ -25,7 +25,6 @@
  * code to do general bookkeeping (e.g. update jiffies, run
  * bottom halves, etc.)
  */
-#include <linux/config.h>
 #include <linux/interrupt.h>
 #include <linux/sched.h>
 #include <linux/spinlock.h>

commit e1701fb2e2f3c02760684e26007e3379be23b690
Author: [MIPS] James E Wilson <wilson@specifix.com>
Date:   Mon Feb 27 15:04:38 2006 -0800

    [PATCH] Fix BCM1480 doubled process accounting times.
    
    Running a UP kernel on a bcm1480 board, I get nonsensical timing
    results, like this:
    release@unknown:~/tmp$ time ./a.out
    real    0m22.906s
    user    0m45.792s
    sys     0m0.010s
    According to my watch, this program took 23 seconds to run, so the real
    time clock is OK.  It is process accounting that is broken.
    
    I tracked this down to a problem with the function
    bcm1480_timer_interrupt in the file sibyte/bcm1480/time.c.  This
    function calls ll_timer_interrupt for cpu0, and ll_local_timer_interrupt
    for all cpus.  However, both of these functions do process accounting.
    Thus processes running on cpu0 end up with doubled times.  This is very
    obvious in a UP kernel where all processes run on cpu0.
    
    The correct way to do this is to only call ll_local_timer interrupt if
    this is not cpu0.  This can be seen in the mips-board/generic/time.c
    file, and also in the sibyte/sb1250/time.c file, both of which handle
    this correctly.  I fixed the bcm1480/time.c file by copying over the
    correct code from the sb1250/time.c file.
    
    With this fix, I now get sensible results.
    release@unknown:~/tmp$ time ./a.out
    real    0m22.903s
    user    0m22.894s
    sys     0m0.006s
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/bcm1480/time.c b/arch/mips/sibyte/bcm1480/time.c
index e545752695a1..efaf83efd2e4 100644
--- a/arch/mips/sibyte/bcm1480/time.c
+++ b/arch/mips/sibyte/bcm1480/time.c
@@ -110,17 +110,18 @@ void bcm1480_timer_interrupt(struct pt_regs *regs)
 	__raw_writeq(M_SCD_TIMER_ENABLE|M_SCD_TIMER_MODE_CONTINUOUS,
 	      IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
 
-	/*
-	 * CPU 0 handles the global timer interrupt job
-	 */
 	if (cpu == 0) {
+		/*
+		 * CPU 0 handles the global timer interrupt job
+		 */
 		ll_timer_interrupt(irq, regs);
 	}
-
-	/*
-	 * every CPU should do profiling and process accouting
-	 */
-	ll_local_timer_interrupt(irq, regs);
+	else {
+		/*
+		 * other CPUs should just do profiling and process accounting
+		 */
+		ll_local_timer_interrupt(irq, regs);
+	}
 }
 
 /*

commit f137e463b50aadba91bd116f99c59ccb9c15a12f
Author: Andrew Isaacson <adi@broadcom.com>
Date:   Wed Oct 19 23:56:38 2005 -0700

    Add support for BCM1480 family of chips.
    
     - Kconfig and Makefile changes
     - arch/mips/sibyte/bcm1480/
     - changes to sibyte common code to support 1480
    
    Signed-Off-By: Andy Isaacson <adi@broadcom.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sibyte/bcm1480/time.c b/arch/mips/sibyte/bcm1480/time.c
new file mode 100644
index 000000000000..e545752695a1
--- /dev/null
+++ b/arch/mips/sibyte/bcm1480/time.c
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2000,2001,2004 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * These are routines to set up and handle interrupts from the
+ * bcm1480 general purpose timer 0.  We're using the timer as a
+ * system clock, so we set it up to run at 100 Hz.  On every
+ * interrupt, we update our idea of what the time of day is,
+ * then call do_timer() in the architecture-independent kernel
+ * code to do general bookkeeping (e.g. update jiffies, run
+ * bottom halves, etc.)
+ */
+#include <linux/config.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/kernel_stat.h>
+
+#include <asm/irq.h>
+#include <asm/ptrace.h>
+#include <asm/addrspace.h>
+#include <asm/time.h>
+#include <asm/io.h>
+
+#include <asm/sibyte/bcm1480_regs.h>
+#include <asm/sibyte/sb1250_regs.h>
+#include <asm/sibyte/bcm1480_int.h>
+#include <asm/sibyte/bcm1480_scd.h>
+
+#include <asm/sibyte/sb1250.h>
+
+
+#define IMR_IP2_VAL	K_BCM1480_INT_MAP_I0
+#define IMR_IP3_VAL	K_BCM1480_INT_MAP_I1
+#define IMR_IP4_VAL	K_BCM1480_INT_MAP_I2
+
+extern int bcm1480_steal_irq(int irq);
+
+void bcm1480_time_init(void)
+{
+	int cpu = smp_processor_id();
+	int irq = K_BCM1480_INT_TIMER_0+cpu;
+
+	/* Only have 4 general purpose timers */
+	if (cpu > 3) {
+		BUG();
+	}
+
+	if (!cpu) {
+		/* Use our own gettimeoffset() routine */
+		do_gettimeoffset = bcm1480_gettimeoffset;
+	}
+
+	bcm1480_mask_irq(cpu, irq);
+
+	/* Map the timer interrupt to ip[4] of this cpu */
+	__raw_writeq(IMR_IP4_VAL, IOADDR(A_BCM1480_IMR_REGISTER(cpu, R_BCM1480_IMR_INTERRUPT_MAP_BASE_H)
+	      + (irq<<3)));
+
+	/* the general purpose timer ticks at 1 Mhz independent of the rest of the system */
+	/* Disable the timer and set up the count */
+	__raw_writeq(0, IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
+	__raw_writeq(
+#ifndef CONFIG_SIMULATION
+		1000000/HZ
+#else
+		50000/HZ
+#endif
+		, IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT)));
+
+	/* Set the timer running */
+	__raw_writeq(M_SCD_TIMER_ENABLE|M_SCD_TIMER_MODE_CONTINUOUS,
+	      IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
+
+	bcm1480_unmask_irq(cpu, irq);
+	bcm1480_steal_irq(irq);
+	/*
+	 * This interrupt is "special" in that it doesn't use the request_irq
+	 * way to hook the irq line.  The timer interrupt is initialized early
+	 * enough to make this a major pain, and it's also firing enough to
+	 * warrant a bit of special case code.  bcm1480_timer_interrupt is
+	 * called directly from irq_handler.S when IP[4] is set during an
+	 * interrupt
+	 */
+}
+
+#include <asm/sibyte/sb1250.h>
+
+void bcm1480_timer_interrupt(struct pt_regs *regs)
+{
+	int cpu = smp_processor_id();
+	int irq = K_BCM1480_INT_TIMER_0+cpu;
+
+	/* Reset the timer */
+	__raw_writeq(M_SCD_TIMER_ENABLE|M_SCD_TIMER_MODE_CONTINUOUS,
+	      IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
+
+	/*
+	 * CPU 0 handles the global timer interrupt job
+	 */
+	if (cpu == 0) {
+		ll_timer_interrupt(irq, regs);
+	}
+
+	/*
+	 * every CPU should do profiling and process accouting
+	 */
+	ll_local_timer_interrupt(irq, regs);
+}
+
+/*
+ * We use our own do_gettimeoffset() instead of the generic one,
+ * because the generic one does not work for SMP case.
+ * In addition, since we use general timer 0 for system time,
+ * we can get accurate intra-jiffy offset without calibration.
+ */
+unsigned long bcm1480_gettimeoffset(void)
+{
+	unsigned long count =
+		__raw_readq(IOADDR(A_SCD_TIMER_REGISTER(0, R_SCD_TIMER_CNT)));
+
+	return 1000000/HZ - count;
+}
