commit ac8fd122e070ce0e60c608d4f085f7af77290844
Author: afzal mohammed <afzal.mohd.ma@gmail.com>
Date:   Thu Mar 5 17:27:53 2020 +0530

    MIPS: Replace setup_irq() by request_irq()
    
    request_irq() is preferred over setup_irq(). Invocations of setup_irq()
    occur after memory allocators are ready.
    
    Per tglx[1], setup_irq() existed in olden days when allocators were not
    ready by the time early interrupts were initialized.
    
    Hence replace setup_irq() by request_irq().
    
    remove_irq() has been replaced by free_irq() as well.
    
    There were build error's during previous version, couple of which was
    reported by kbuild test robot <lkp@intel.com> of which one was reported
    by Thomas Bogendoerfer <tsbogend@alpha.franken.de> as well. There were a
    few more issues including build errors, those also have been fixed.
    
    [1] https://lkml.kernel.org/r/alpine.DEB.2.20.1710191609480.1971@nanos
    
    Signed-off-by: afzal mohammed <afzal.mohd.ma@gmail.com>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/cobalt/irq.c b/arch/mips/cobalt/irq.c
index 965c777d3561..ead5ae41378d 100644
--- a/arch/mips/cobalt/irq.c
+++ b/arch/mips/cobalt/irq.c
@@ -45,18 +45,20 @@ asmlinkage void plat_irq_dispatch(void)
 		spurious_interrupt();
 }
 
-static struct irqaction cascade = {
-	.handler	= no_action,
-	.name		= "cascade",
-	.flags		= IRQF_NO_THREAD,
-};
-
 void __init arch_init_irq(void)
 {
 	mips_cpu_irq_init();
 	gt641xx_irq_init();
 	init_i8259_irqs();
 
-	setup_irq(GT641XX_CASCADE_IRQ, &cascade);
-	setup_irq(I8259_CASCADE_IRQ, &cascade);
+	if (request_irq(GT641XX_CASCADE_IRQ, no_action, IRQF_NO_THREAD,
+			"cascade", NULL)) {
+		pr_err("Failed to request irq %d (cascade)\n",
+		       GT641XX_CASCADE_IRQ);
+	}
+	if (request_irq(I8259_CASCADE_IRQ, no_action, IRQF_NO_THREAD,
+			"cascade", NULL)) {
+		pr_err("Failed to request irq %d (cascade)\n",
+		       I8259_CASCADE_IRQ);
+	}
 }

commit 5a4a4ad851dd8db2d888fb86c8bd946b2ae79f60
Author: Wu Zhangjin <wuzhangjin@gmail.com>
Date:   Sat Jul 23 12:41:24 2011 +0000

    MIPS: Mark cascade and low level interrupts IRQF_NO_THREAD
    
    Mark interrupts with no_action handler, cascade interrupts, low level
    interrupts (bus error, halt ..) with IRQF_NO_THREAD to exclude them
    from forced threading.
    
    Signed-off-by: Wu Zhangjin <wuzhangjin@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-mips@linux-mips.org
    Cc: Wu Zhangjin <wuzhangjin@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/cobalt/irq.c b/arch/mips/cobalt/irq.c
index cb9bf820fe53..965c777d3561 100644
--- a/arch/mips/cobalt/irq.c
+++ b/arch/mips/cobalt/irq.c
@@ -48,6 +48,7 @@ asmlinkage void plat_irq_dispatch(void)
 static struct irqaction cascade = {
 	.handler	= no_action,
 	.name		= "cascade",
+	.flags		= IRQF_NO_THREAD,
 };
 
 void __init arch_init_irq(void)

commit 1a8a51004a18b627ea81444201f7867875212f46
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Mon Mar 30 22:05:13 2009 -0600

    cpumask: remove references to struct irqaction's mask field.
    
    Impact: cleanup
    
    It's unused, since about 1995.  So remove all initialization of it in
    preparation for actually removing the field.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/mips/cobalt/irq.c b/arch/mips/cobalt/irq.c
index ac4fb912649d..cb9bf820fe53 100644
--- a/arch/mips/cobalt/irq.c
+++ b/arch/mips/cobalt/irq.c
@@ -47,7 +47,6 @@ asmlinkage void plat_irq_dispatch(void)
 
 static struct irqaction cascade = {
 	.handler	= no_action,
-	.mask		= CPU_MASK_NONE,
 	.name		= "cascade",
 };
 

commit d5ab1a6910fe850fa092888f210cf6c43136a7ab
Author: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
Date:   Thu Sep 13 23:51:26 2007 +0900

    [MIPS] Add GT641xx IRQ routines.
    
    Signed-off-by: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/cobalt/irq.c b/arch/mips/cobalt/irq.c
index 48763cd10eaa..ac4fb912649d 100644
--- a/arch/mips/cobalt/irq.c
+++ b/arch/mips/cobalt/irq.c
@@ -15,104 +15,48 @@
 
 #include <asm/i8259.h>
 #include <asm/irq_cpu.h>
+#include <asm/irq_gt641xx.h>
 #include <asm/gt64120.h>
 
-#include <cobalt.h>
-
-/*
- * We have two types of interrupts that we handle, ones that come in through
- * the CPU interrupt lines, and ones that come in on the via chip. The CPU
- * mappings are:
- *
- *    16   - Software interrupt 0 (unused)	IE_SW0
- *    17   - Software interrupt 1 (unused)	IE_SW1
- *    18   - Galileo chip (timer)		IE_IRQ0
- *    19   - Tulip 0 + NCR SCSI			IE_IRQ1
- *    20   - Tulip 1				IE_IRQ2
- *    21   - 16550 UART				IE_IRQ3
- *    22   - VIA southbridge PIC		IE_IRQ4
- *    23   - unused				IE_IRQ5
- *
- * The VIA chip is a master/slave 8259 setup and has the following interrupts:
- *
- *     8  - RTC
- *     9  - PCI
- *    14  - IDE0
- *    15  - IDE1
- */
-
-static inline void galileo_irq(void)
-{
-	unsigned int mask, pending, devfn;
-
-	mask = GT_READ(GT_INTRMASK_OFS);
-	pending = GT_READ(GT_INTRCAUSE_OFS) & mask;
-
-	if (pending & GT_INTR_T0EXP_MSK) {
-		GT_WRITE(GT_INTRCAUSE_OFS, ~GT_INTR_T0EXP_MSK);
-		do_IRQ(COBALT_GALILEO_IRQ);
-	} else if (pending & GT_INTR_RETRYCTR0_MSK) {
-		devfn = GT_READ(GT_PCI0_CFGADDR_OFS) >> 8;
-		GT_WRITE(GT_INTRCAUSE_OFS, ~GT_INTR_RETRYCTR0_MSK);
-		printk(KERN_WARNING
-		       "Galileo: PCI retry count exceeded (%02x.%u)\n",
-		       PCI_SLOT(devfn), PCI_FUNC(devfn));
-	} else {
-		GT_WRITE(GT_INTRMASK_OFS, mask & ~pending);
-		printk(KERN_WARNING
-		       "Galileo: masking unexpected interrupt %08x\n", pending);
-	}
-}
-
-static inline void via_pic_irq(void)
-{
-	int irq;
-
-	irq = i8259_irq();
-	if (irq >= 0)
-		do_IRQ(irq);
-}
+#include <irq.h>
 
 asmlinkage void plat_irq_dispatch(void)
 {
-	unsigned pending = read_c0_status() & read_c0_cause();
+	unsigned pending = read_c0_status() & read_c0_cause() & ST0_IM;
+	int irq;
 
-	if (pending & CAUSEF_IP2)		/* COBALT_GALILEO_IRQ (18) */
-		galileo_irq();
-	else if (pending & CAUSEF_IP6)		/* COBALT_VIA_IRQ (22) */
-		via_pic_irq();
-	else if (pending & CAUSEF_IP3)		/* COBALT_ETH0_IRQ (19) */
-		do_IRQ(COBALT_CPU_IRQ + 3);
-	else if (pending & CAUSEF_IP4)		/* COBALT_ETH1_IRQ (20) */
-		do_IRQ(COBALT_CPU_IRQ + 4);
-	else if (pending & CAUSEF_IP5)		/* COBALT_SERIAL_IRQ (21) */
-		do_IRQ(COBALT_CPU_IRQ + 5);
-	else if (pending & CAUSEF_IP7)		/* IRQ 23 */
-		do_IRQ(COBALT_CPU_IRQ + 7);
+	if (pending & CAUSEF_IP2)
+		gt641xx_irq_dispatch();
+	else if (pending & CAUSEF_IP6) {
+		irq = i8259_irq();
+		if (irq < 0)
+			spurious_interrupt();
+		else
+			do_IRQ(irq);
+	} else if (pending & CAUSEF_IP3)
+		do_IRQ(MIPS_CPU_IRQ_BASE + 3);
+	else if (pending & CAUSEF_IP4)
+		do_IRQ(MIPS_CPU_IRQ_BASE + 4);
+	else if (pending & CAUSEF_IP5)
+		do_IRQ(MIPS_CPU_IRQ_BASE + 5);
+	else if (pending & CAUSEF_IP7)
+		do_IRQ(MIPS_CPU_IRQ_BASE + 7);
+	else
+		spurious_interrupt();
 }
 
-static struct irqaction irq_via = {
-	.handler = no_action,
-	.mask = CPU_MASK_NONE,
-	.name = "cascade"
+static struct irqaction cascade = {
+	.handler	= no_action,
+	.mask		= CPU_MASK_NONE,
+	.name		= "cascade",
 };
 
 void __init arch_init_irq(void)
 {
-	/*
-	 * Mask all Galileo interrupts. The Galileo
-	 * handler is set in cobalt_timer_setup()
-	 */
-	GT_WRITE(GT_INTRMASK_OFS, 0);
-
-	init_i8259_irqs();				/*  0 ... 15 */
-	mips_cpu_irq_init();		/* 16 ... 23 */
-
-	/*
-	 * Mask all cpu interrupts
-	 *  (except IE4, we already masked those at VIA level)
-	 */
-	change_c0_status(ST0_IM, IE_IRQ4);
+	mips_cpu_irq_init();
+	gt641xx_irq_init();
+	init_i8259_irqs();
 
-	setup_irq(COBALT_VIA_IRQ, &irq_via);
+	setup_irq(GT641XX_CASCADE_IRQ, &cascade);
+	setup_irq(I8259_CASCADE_IRQ, &cascade);
 }

commit 4e45171c4e31578157189ca22cfb7b2bcc5f69f2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Aug 28 09:03:01 2007 +0000

    [MIPS] cleanup struct irqaction initializers
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    CC: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/cobalt/irq.c b/arch/mips/cobalt/irq.c
index 950ad1e8be44..48763cd10eaa 100644
--- a/arch/mips/cobalt/irq.c
+++ b/arch/mips/cobalt/irq.c
@@ -92,7 +92,9 @@ asmlinkage void plat_irq_dispatch(void)
 }
 
 static struct irqaction irq_via = {
-	no_action, 0, { { 0, } }, "cascade", NULL, NULL
+	.handler = no_action,
+	.mask = CPU_MASK_NONE,
+	.name = "cascade"
 };
 
 void __init arch_init_irq(void)

commit cc50b67dcd84c6215232c0e1c95e24786e555782
Author: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
Date:   Tue Mar 6 21:34:44 2007 +0900

    [MIPS] Cobalt: clean up include files
    
    Signed-off-by: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>

diff --git a/arch/mips/cobalt/irq.c b/arch/mips/cobalt/irq.c
index fe93b846923b..950ad1e8be44 100644
--- a/arch/mips/cobalt/irq.c
+++ b/arch/mips/cobalt/irq.c
@@ -17,7 +17,7 @@
 #include <asm/irq_cpu.h>
 #include <asm/gt64120.h>
 
-#include <asm/mach-cobalt/cobalt.h>
+#include <cobalt.h>
 
 /*
  * We have two types of interrupts that we handle, ones that come in through

commit 97dcb82de6cc99a5669eb8e342efc24cceb1e77e
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Mon Jan 8 02:14:29 2007 +0900

    [MIPS] Define MIPS_CPU_IRQ_BASE in generic header
    
    The irq_base for {mips,rm7k,rm9k}_cpu_irq_init() are constant on all
    platforms and are same value on most platforms (0 or 16, depends on
    CONFIG_I8259).  Define them in asm-mips/mach-generic/irq.h and make
    them customizable.  This will save a few cycle on each CPU interrupt.
    
    A good side effect is removing some dependencies to MALTA in generic
    SMTC code.
    
    Although MIPS_CPU_IRQ_BASE is customizable, this patch changes irq
    mappings on DDB5477, EMMA2RH and MIPS_SIM, since really customizing
    them might cause some header dependency problem and there seems no
    good reason to customize it.  So currently only VR41XX is using custom
    MIPS_CPU_IRQ_BASE value, which is 0 regardless of CONFIG_I8259.
    
    Testing this patch on those platforms is greatly appreciated.  Thank
    you.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/cobalt/irq.c b/arch/mips/cobalt/irq.c
index 4c46f0e73783..fe93b846923b 100644
--- a/arch/mips/cobalt/irq.c
+++ b/arch/mips/cobalt/irq.c
@@ -104,7 +104,7 @@ void __init arch_init_irq(void)
 	GT_WRITE(GT_INTRMASK_OFS, 0);
 
 	init_i8259_irqs();				/*  0 ... 15 */
-	mips_cpu_irq_init(COBALT_CPU_IRQ);		/* 16 ... 23 */
+	mips_cpu_irq_init();		/* 16 ... 23 */
 
 	/*
 	 * Mask all cpu interrupts

commit 56ae58333031bb0564c141f955d1e42276cade55
Author: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
Date:   Sat Oct 14 00:25:04 2006 +0900

    [MIPS] Rewrite GALILEO_INL/GALILEO_OUTL  to GT_READ/GT_WRITE
    
    This patch has rewritten GALILEO_INL/GALILEO_OUTL using GT_READ/GT_WRITE.
    This patch tested on Cobalt Qube2.
    
    Signed-off-by: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/cobalt/irq.c b/arch/mips/cobalt/irq.c
index 82e569d5b02c..4c46f0e73783 100644
--- a/arch/mips/cobalt/irq.c
+++ b/arch/mips/cobalt/irq.c
@@ -45,25 +45,22 @@ static inline void galileo_irq(void)
 {
 	unsigned int mask, pending, devfn;
 
-	mask = GALILEO_INL(GT_INTRMASK_OFS);
-	pending = GALILEO_INL(GT_INTRCAUSE_OFS) & mask;
+	mask = GT_READ(GT_INTRMASK_OFS);
+	pending = GT_READ(GT_INTRCAUSE_OFS) & mask;
 
-	if (pending & GALILEO_INTR_T0EXP) {
-
-		GALILEO_OUTL(~GALILEO_INTR_T0EXP, GT_INTRCAUSE_OFS);
+	if (pending & GT_INTR_T0EXP_MSK) {
+		GT_WRITE(GT_INTRCAUSE_OFS, ~GT_INTR_T0EXP_MSK);
 		do_IRQ(COBALT_GALILEO_IRQ);
-
-	} else if (pending & GALILEO_INTR_RETRY_CTR) {
-
-		devfn = GALILEO_INL(GT_PCI0_CFGADDR_OFS) >> 8;
-		GALILEO_OUTL(~GALILEO_INTR_RETRY_CTR, GT_INTRCAUSE_OFS);
-		printk(KERN_WARNING "Galileo: PCI retry count exceeded (%02x.%u)\n",
-			PCI_SLOT(devfn), PCI_FUNC(devfn));
-
+	} else if (pending & GT_INTR_RETRYCTR0_MSK) {
+		devfn = GT_READ(GT_PCI0_CFGADDR_OFS) >> 8;
+		GT_WRITE(GT_INTRCAUSE_OFS, ~GT_INTR_RETRYCTR0_MSK);
+		printk(KERN_WARNING
+		       "Galileo: PCI retry count exceeded (%02x.%u)\n",
+		       PCI_SLOT(devfn), PCI_FUNC(devfn));
 	} else {
-
-		GALILEO_OUTL(mask & ~pending, GT_INTRMASK_OFS);
-		printk(KERN_WARNING "Galileo: masking unexpected interrupt %08x\n", pending);
+		GT_WRITE(GT_INTRMASK_OFS, mask & ~pending);
+		printk(KERN_WARNING
+		       "Galileo: masking unexpected interrupt %08x\n", pending);
 	}
 }
 
@@ -104,7 +101,7 @@ void __init arch_init_irq(void)
 	 * Mask all Galileo interrupts. The Galileo
 	 * handler is set in cobalt_timer_setup()
 	 */
-	GALILEO_OUTL(0, GT_INTRMASK_OFS);
+	GT_WRITE(GT_INTRMASK_OFS, 0);
 
 	init_i8259_irqs();				/*  0 ... 15 */
 	mips_cpu_irq_init(COBALT_CPU_IRQ);		/* 16 ... 23 */

commit 27f768192fe2d96936cef5d4713e228daee07ae2
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Oct 9 00:03:05 2006 +0100

    [MIPS] Cleanup unnecessary <asm/ptrace.h> inclusions.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/cobalt/irq.c b/arch/mips/cobalt/irq.c
index 1117fab19733..82e569d5b02c 100644
--- a/arch/mips/cobalt/irq.c
+++ b/arch/mips/cobalt/irq.c
@@ -16,7 +16,6 @@
 #include <asm/i8259.h>
 #include <asm/irq_cpu.h>
 #include <asm/gt64120.h>
-#include <asm/ptrace.h>
 
 #include <asm/mach-cobalt/cobalt.h>
 

commit 937a801576f954bd030d7c4a5a94571710d87c0b
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Oct 7 19:44:33 2006 +0100

    [MIPS] Complete fixes after removal of pt_regs argument to int handlers.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/cobalt/irq.c b/arch/mips/cobalt/irq.c
index 0b75f4fb7195..1117fab19733 100644
--- a/arch/mips/cobalt/irq.c
+++ b/arch/mips/cobalt/irq.c
@@ -42,7 +42,7 @@
  *    15  - IDE1
  */
 
-static inline void galileo_irq(struct pt_regs *regs)
+static inline void galileo_irq(void)
 {
 	unsigned int mask, pending, devfn;
 
@@ -52,7 +52,7 @@ static inline void galileo_irq(struct pt_regs *regs)
 	if (pending & GALILEO_INTR_T0EXP) {
 
 		GALILEO_OUTL(~GALILEO_INTR_T0EXP, GT_INTRCAUSE_OFS);
-		do_IRQ(COBALT_GALILEO_IRQ, regs);
+		do_IRQ(COBALT_GALILEO_IRQ);
 
 	} else if (pending & GALILEO_INTR_RETRY_CTR) {
 
@@ -68,44 +68,31 @@ static inline void galileo_irq(struct pt_regs *regs)
 	}
 }
 
-static inline void via_pic_irq(struct pt_regs *regs)
+static inline void via_pic_irq(void)
 {
 	int irq;
 
 	irq = i8259_irq();
 	if (irq >= 0)
-		do_IRQ(irq, regs);
+		do_IRQ(irq);
 }
 
-asmlinkage void plat_irq_dispatch(struct pt_regs *regs)
+asmlinkage void plat_irq_dispatch(void)
 {
-	unsigned pending;
-
-	pending = read_c0_status() & read_c0_cause();
-
-	if (pending & CAUSEF_IP2)			/* COBALT_GALILEO_IRQ (18) */
-
-		galileo_irq(regs);
-
-	else if (pending & CAUSEF_IP6)			/* COBALT_VIA_IRQ (22) */
-
-		via_pic_irq(regs);
-
-	else if (pending & CAUSEF_IP3)			/* COBALT_ETH0_IRQ (19) */
-
-		do_IRQ(COBALT_CPU_IRQ + 3, regs);
-
-	else if (pending & CAUSEF_IP4)			/* COBALT_ETH1_IRQ (20) */
-
-		do_IRQ(COBALT_CPU_IRQ + 4, regs);
-
-	else if (pending & CAUSEF_IP5)			/* COBALT_SERIAL_IRQ (21) */
-
-		do_IRQ(COBALT_CPU_IRQ + 5, regs);
-
-	else if (pending & CAUSEF_IP7)			/* IRQ 23 */
-
-		do_IRQ(COBALT_CPU_IRQ + 7, regs);
+	unsigned pending = read_c0_status() & read_c0_cause();
+
+	if (pending & CAUSEF_IP2)		/* COBALT_GALILEO_IRQ (18) */
+		galileo_irq();
+	else if (pending & CAUSEF_IP6)		/* COBALT_VIA_IRQ (22) */
+		via_pic_irq();
+	else if (pending & CAUSEF_IP3)		/* COBALT_ETH0_IRQ (19) */
+		do_IRQ(COBALT_CPU_IRQ + 3);
+	else if (pending & CAUSEF_IP4)		/* COBALT_ETH1_IRQ (20) */
+		do_IRQ(COBALT_CPU_IRQ + 4);
+	else if (pending & CAUSEF_IP5)		/* COBALT_SERIAL_IRQ (21) */
+		do_IRQ(COBALT_CPU_IRQ + 5);
+	else if (pending & CAUSEF_IP7)		/* IRQ 23 */
+		do_IRQ(COBALT_CPU_IRQ + 7);
 }
 
 static struct irqaction irq_via = {

commit e4ac58afdfac792c0583af30dbd9eae53e24c78b
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Apr 3 17:56:36 2006 +0100

    [MIPS] Rewrite all the assembler interrupt handlers to C.
    
    Saves like 1,600 lines of code, is way easier to debug, compilers
    frequently do a better job than the cut and paste type of handlers many
    boards had.  And finally having all the stuff done in a single place
    also means alot of bug potencial for the MT ASE is gone.
    
    The only surviving handler in assembler is the DECstation one; I hope
    Maciej will rewrite it.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/cobalt/irq.c b/arch/mips/cobalt/irq.c
index f9a108820d6e..0b75f4fb7195 100644
--- a/arch/mips/cobalt/irq.c
+++ b/arch/mips/cobalt/irq.c
@@ -20,8 +20,6 @@
 
 #include <asm/mach-cobalt/cobalt.h>
 
-extern void cobalt_handle_int(void);
-
 /*
  * We have two types of interrupts that we handle, ones that come in through
  * the CPU interrupt lines, and ones that come in on the via chip. The CPU
@@ -79,7 +77,7 @@ static inline void via_pic_irq(struct pt_regs *regs)
 		do_IRQ(irq, regs);
 }
 
-asmlinkage void cobalt_irq(struct pt_regs *regs)
+asmlinkage void plat_irq_dispatch(struct pt_regs *regs)
 {
 	unsigned pending;
 
@@ -122,8 +120,6 @@ void __init arch_init_irq(void)
 	 */
 	GALILEO_OUTL(0, GT_INTRMASK_OFS);
 
-	set_except_vector(0, cobalt_handle_int);
-
 	init_i8259_irqs();				/*  0 ... 15 */
 	mips_cpu_irq_init(COBALT_CPU_IRQ);		/* 16 ... 23 */
 

commit 11ed6d5bb01c5f347fd5c47e0005f06687c66f1f
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Jan 18 23:26:43 2006 +0000

    [MIPS] Rename include/asm-mips/cobalt to include/asm-mips/mach-cobalt.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/cobalt/irq.c b/arch/mips/cobalt/irq.c
index 0d90851f925e..f9a108820d6e 100644
--- a/arch/mips/cobalt/irq.c
+++ b/arch/mips/cobalt/irq.c
@@ -18,7 +18,7 @@
 #include <asm/gt64120.h>
 #include <asm/ptrace.h>
 
-#include <asm/cobalt/cobalt.h>
+#include <asm/mach-cobalt/cobalt.h>
 
 extern void cobalt_handle_int(void);
 

commit c4ed38a0c6e2e5c4906296758f816ee71373792f
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Feb 21 16:18:36 2005 +0000

    Resurrect Cobalt support for 2.6.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/cobalt/irq.c b/arch/mips/cobalt/irq.c
index 6d2a81581397..0d90851f925e 100644
--- a/arch/mips/cobalt/irq.c
+++ b/arch/mips/cobalt/irq.c
@@ -10,6 +10,8 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
 
 #include <asm/i8259.h>
 #include <asm/irq_cpu.h>
@@ -25,8 +27,8 @@ extern void cobalt_handle_int(void);
  * the CPU interrupt lines, and ones that come in on the via chip. The CPU
  * mappings are:
  *
- *    16,  - Software interrupt 0 (unused)	IE_SW0
- *    17   - Software interrupt 1 (unused)	IE_SW0
+ *    16   - Software interrupt 0 (unused)	IE_SW0
+ *    17   - Software interrupt 1 (unused)	IE_SW1
  *    18   - Galileo chip (timer)		IE_IRQ0
  *    19   - Tulip 0 + NCR SCSI			IE_IRQ1
  *    20   - Tulip 1				IE_IRQ2
@@ -42,61 +44,94 @@ extern void cobalt_handle_int(void);
  *    15  - IDE1
  */
 
-asmlinkage void cobalt_irq(struct pt_regs *regs)
+static inline void galileo_irq(struct pt_regs *regs)
 {
-	unsigned int pending = read_c0_status() & read_c0_cause();
-
-	if (pending & CAUSEF_IP2) {			/* int 18 */
-		unsigned long irq_src = GALILEO_INL(GT_INTRCAUSE_OFS);
-
-		/* Check for timer irq ... */
-		if (irq_src & GALILEO_T0EXP) {
-			/* Clear the int line */
-			GALILEO_OUTL(0, GT_INTRCAUSE_OFS);
-			do_IRQ(COBALT_TIMER_IRQ, regs);
-		}
-		return;
-	}
+	unsigned int mask, pending, devfn;
 
-	if (pending & CAUSEF_IP6) {			/* int 22 */
-		int irq = i8259_irq();
+	mask = GALILEO_INL(GT_INTRMASK_OFS);
+	pending = GALILEO_INL(GT_INTRCAUSE_OFS) & mask;
 
-		if (irq >= 0)
-			do_IRQ(irq, regs);
-		return;
-	}
+	if (pending & GALILEO_INTR_T0EXP) {
 
-	if (pending & CAUSEF_IP3) {			/* int 19 */
-		do_IRQ(COBALT_ETH0_IRQ, regs);
-		return;
-	}
+		GALILEO_OUTL(~GALILEO_INTR_T0EXP, GT_INTRCAUSE_OFS);
+		do_IRQ(COBALT_GALILEO_IRQ, regs);
 
-	if (pending & CAUSEF_IP4) {			/* int 20 */
-		do_IRQ(COBALT_ETH1_IRQ, regs);
-		return;
-	}
+	} else if (pending & GALILEO_INTR_RETRY_CTR) {
 
-	if (pending & CAUSEF_IP5) {			/* int 21 */
-		do_IRQ(COBALT_SERIAL_IRQ, regs);
-		return;
-	}
+		devfn = GALILEO_INL(GT_PCI0_CFGADDR_OFS) >> 8;
+		GALILEO_OUTL(~GALILEO_INTR_RETRY_CTR, GT_INTRCAUSE_OFS);
+		printk(KERN_WARNING "Galileo: PCI retry count exceeded (%02x.%u)\n",
+			PCI_SLOT(devfn), PCI_FUNC(devfn));
+
+	} else {
 
-	if (pending & CAUSEF_IP7) {			/* int 23 */
-		do_IRQ(COBALT_QUBE_SLOT_IRQ, regs);
-		return;
+		GALILEO_OUTL(mask & ~pending, GT_INTRMASK_OFS);
+		printk(KERN_WARNING "Galileo: masking unexpected interrupt %08x\n", pending);
 	}
 }
 
+static inline void via_pic_irq(struct pt_regs *regs)
+{
+	int irq;
+
+	irq = i8259_irq();
+	if (irq >= 0)
+		do_IRQ(irq, regs);
+}
+
+asmlinkage void cobalt_irq(struct pt_regs *regs)
+{
+	unsigned pending;
+
+	pending = read_c0_status() & read_c0_cause();
+
+	if (pending & CAUSEF_IP2)			/* COBALT_GALILEO_IRQ (18) */
+
+		galileo_irq(regs);
+
+	else if (pending & CAUSEF_IP6)			/* COBALT_VIA_IRQ (22) */
+
+		via_pic_irq(regs);
+
+	else if (pending & CAUSEF_IP3)			/* COBALT_ETH0_IRQ (19) */
+
+		do_IRQ(COBALT_CPU_IRQ + 3, regs);
+
+	else if (pending & CAUSEF_IP4)			/* COBALT_ETH1_IRQ (20) */
+
+		do_IRQ(COBALT_CPU_IRQ + 4, regs);
+
+	else if (pending & CAUSEF_IP5)			/* COBALT_SERIAL_IRQ (21) */
+
+		do_IRQ(COBALT_CPU_IRQ + 5, regs);
+
+	else if (pending & CAUSEF_IP7)			/* IRQ 23 */
+
+		do_IRQ(COBALT_CPU_IRQ + 7, regs);
+}
+
+static struct irqaction irq_via = {
+	no_action, 0, { { 0, } }, "cascade", NULL, NULL
+};
+
 void __init arch_init_irq(void)
 {
+	/*
+	 * Mask all Galileo interrupts. The Galileo
+	 * handler is set in cobalt_timer_setup()
+	 */
+	GALILEO_OUTL(0, GT_INTRMASK_OFS);
+
 	set_except_vector(0, cobalt_handle_int);
 
 	init_i8259_irqs();				/*  0 ... 15 */
-	mips_cpu_irq_init(16);				/* 16 ... 23 */
+	mips_cpu_irq_init(COBALT_CPU_IRQ);		/* 16 ... 23 */
 
 	/*
 	 * Mask all cpu interrupts
 	 *  (except IE4, we already masked those at VIA level)
 	 */
 	change_c0_status(ST0_IM, IE_IRQ4);
+
+	setup_irq(COBALT_VIA_IRQ, &irq_via);
 }

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/mips/cobalt/irq.c b/arch/mips/cobalt/irq.c
new file mode 100644
index 000000000000..6d2a81581397
--- /dev/null
+++ b/arch/mips/cobalt/irq.c
@@ -0,0 +1,102 @@
+/*
+ * IRQ vector handles
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1995, 1996, 1997, 2003 by Ralf Baechle
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+
+#include <asm/i8259.h>
+#include <asm/irq_cpu.h>
+#include <asm/gt64120.h>
+#include <asm/ptrace.h>
+
+#include <asm/cobalt/cobalt.h>
+
+extern void cobalt_handle_int(void);
+
+/*
+ * We have two types of interrupts that we handle, ones that come in through
+ * the CPU interrupt lines, and ones that come in on the via chip. The CPU
+ * mappings are:
+ *
+ *    16,  - Software interrupt 0 (unused)	IE_SW0
+ *    17   - Software interrupt 1 (unused)	IE_SW0
+ *    18   - Galileo chip (timer)		IE_IRQ0
+ *    19   - Tulip 0 + NCR SCSI			IE_IRQ1
+ *    20   - Tulip 1				IE_IRQ2
+ *    21   - 16550 UART				IE_IRQ3
+ *    22   - VIA southbridge PIC		IE_IRQ4
+ *    23   - unused				IE_IRQ5
+ *
+ * The VIA chip is a master/slave 8259 setup and has the following interrupts:
+ *
+ *     8  - RTC
+ *     9  - PCI
+ *    14  - IDE0
+ *    15  - IDE1
+ */
+
+asmlinkage void cobalt_irq(struct pt_regs *regs)
+{
+	unsigned int pending = read_c0_status() & read_c0_cause();
+
+	if (pending & CAUSEF_IP2) {			/* int 18 */
+		unsigned long irq_src = GALILEO_INL(GT_INTRCAUSE_OFS);
+
+		/* Check for timer irq ... */
+		if (irq_src & GALILEO_T0EXP) {
+			/* Clear the int line */
+			GALILEO_OUTL(0, GT_INTRCAUSE_OFS);
+			do_IRQ(COBALT_TIMER_IRQ, regs);
+		}
+		return;
+	}
+
+	if (pending & CAUSEF_IP6) {			/* int 22 */
+		int irq = i8259_irq();
+
+		if (irq >= 0)
+			do_IRQ(irq, regs);
+		return;
+	}
+
+	if (pending & CAUSEF_IP3) {			/* int 19 */
+		do_IRQ(COBALT_ETH0_IRQ, regs);
+		return;
+	}
+
+	if (pending & CAUSEF_IP4) {			/* int 20 */
+		do_IRQ(COBALT_ETH1_IRQ, regs);
+		return;
+	}
+
+	if (pending & CAUSEF_IP5) {			/* int 21 */
+		do_IRQ(COBALT_SERIAL_IRQ, regs);
+		return;
+	}
+
+	if (pending & CAUSEF_IP7) {			/* int 23 */
+		do_IRQ(COBALT_QUBE_SLOT_IRQ, regs);
+		return;
+	}
+}
+
+void __init arch_init_irq(void)
+{
+	set_except_vector(0, cobalt_handle_int);
+
+	init_i8259_irqs();				/*  0 ... 15 */
+	mips_cpu_irq_init(16);				/* 16 ... 23 */
+
+	/*
+	 * Mask all cpu interrupts
+	 *  (except IE4, we already masked those at VIA level)
+	 */
+	change_c0_status(ST0_IM, IE_IRQ4);
+}
