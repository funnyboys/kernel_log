commit c9b0299034665d594e56ee343f28033d1b24de6d
Author: Liangliang Huang <huanglllzu@gmail.com>
Date:   Mon May 4 16:51:29 2020 +0800

    MIPS: Use fallthrough for arch/mips
    
    Convert the various /* fallthrough */ comments to the pseudo-keyword
    fallthrough;
    
    Done via script:
    https://lore.kernel.org/lkml/b56602fcf79f849e733e7b521bb0e17895d390fa.1582230379.git.joe@perches.com/
    
    Signed-off-by: Liangliang Huang <huangll@lemote.com>
    Reviewed-by: Huacai Chen <chenhc@lemote.com>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index a537bf98912c..1493c49ca47a 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -172,15 +172,15 @@ static void mipsxx_cpu_setup(void *args)
 	case 4:
 		w_c0_perfctrl3(0);
 		w_c0_perfcntr3(reg.counter[3]);
-		/* fall through */
+		fallthrough;
 	case 3:
 		w_c0_perfctrl2(0);
 		w_c0_perfcntr2(reg.counter[2]);
-		/* fall through */
+		fallthrough;
 	case 2:
 		w_c0_perfctrl1(0);
 		w_c0_perfcntr1(reg.counter[1]);
-		/* fall through */
+		fallthrough;
 	case 1:
 		w_c0_perfctrl0(0);
 		w_c0_perfcntr0(reg.counter[0]);
@@ -198,13 +198,13 @@ static void mipsxx_cpu_start(void *args)
 	switch (counters) {
 	case 4:
 		w_c0_perfctrl3(WHAT | reg.control[3]);
-		/* fall through */
+		fallthrough;
 	case 3:
 		w_c0_perfctrl2(WHAT | reg.control[2]);
-		/* fall through */
+		fallthrough;
 	case 2:
 		w_c0_perfctrl1(WHAT | reg.control[1]);
-		/* fall through */
+		fallthrough;
 	case 1:
 		w_c0_perfctrl0(WHAT | reg.control[0]);
 	}
@@ -221,13 +221,13 @@ static void mipsxx_cpu_stop(void *args)
 	switch (counters) {
 	case 4:
 		w_c0_perfctrl3(0);
-		/* fall through */
+		fallthrough;
 	case 3:
 		w_c0_perfctrl2(0);
-		/* fall through */
+		fallthrough;
 	case 2:
 		w_c0_perfctrl1(0);
-		/* fall through */
+		fallthrough;
 	case 1:
 		w_c0_perfctrl0(0);
 	}
@@ -245,7 +245,7 @@ static int mipsxx_perfcount_handler(void)
 
 	switch (counters) {
 #define HANDLE_COUNTER(n)						\
-	/* fall through */						\
+	fallthrough;							\
 	case n + 1:							\
 		control = r_c0_perfctrl ## n();				\
 		counter = r_c0_perfcntr ## n();				\
@@ -307,15 +307,15 @@ static void reset_counters(void *arg)
 	case 4:
 		w_c0_perfctrl3(0);
 		w_c0_perfcntr3(0);
-		/* fall through */
+		fallthrough;
 	case 3:
 		w_c0_perfctrl2(0);
 		w_c0_perfcntr2(0);
-		/* fall through */
+		fallthrough;
 	case 2:
 		w_c0_perfctrl1(0);
 		w_c0_perfcntr1(0);
-		/* fall through */
+		fallthrough;
 	case 1:
 		w_c0_perfctrl0(0);
 		w_c0_perfcntr0(0);

commit b2afb64cccd243afd8a4337d8ee4c2f2afbe991d
Author: Huacai Chen <chenhc@lemote.com>
Date:   Mon Nov 4 14:11:20 2019 +0800

    MIPS: Loongson: Rename LOONGSON1 to LOONGSON32
    
    Now old Loongson-2E/2F use LOONGSON2EF and will be removed in future,
    newer Loongson-2/3 use LOONGSON64. So rename LOONGSON1 to LOONGSON32
    will make the naming style more unified.
    
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    [paulburton@kernel.org: Fix checkpatch whitespace warning in irqflags.h]
    Signed-off-by: Paul Burton <paulburton@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@linux-mips.org
    Cc: linux-mips@vger.kernel.org
    Cc: Fuxin Zhang <zhangfx@lemote.com>
    Cc: Zhangjin Wu <wuzhangjin@gmail.com>
    Cc: Huacai Chen <chenhuacai@gmail.com>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 96c13a0ab078..a537bf98912c 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -420,7 +420,7 @@ static int __init mipsxx_init(void)
 		op_model_mipsxx_ops.cpu_type = "mips/sb1";
 		break;
 
-	case CPU_LOONGSON1:
+	case CPU_LOONGSON32:
 		op_model_mipsxx_ops.cpu_type = "mips/loongson1";
 		break;
 

commit 2d291e6cc183608e1f6eb8580268df7c68bdf7c3
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Mon Jul 29 18:32:10 2019 -0500

    MIPS: OProfile: Mark expected switch fall-throughs
    
    Mark switch cases where we are expecting to fall through.
    
    This patch fixes the following warning (Building: mips):
    
    arch/mips/oprofile/op_model_mipsxx.c: In function ‘mipsxx_cpu_stop’:
    arch/mips/oprofile/op_model_mipsxx.c:217:3: warning: this statement may fall through [-Wimplicit-fallthrough=]
       w_c0_perfctrl3(0);
       ^~~~~~~~~~~~~~~~~
    arch/mips/oprofile/op_model_mipsxx.c:218:2: note: here
      case 3:
      ^~~~
    arch/mips/oprofile/op_model_mipsxx.c:219:3: warning: this statement may fall through [-Wimplicit-fallthrough=]
       w_c0_perfctrl2(0);
       ^~~~~~~~~~~~~~~~~
    arch/mips/oprofile/op_model_mipsxx.c:220:2: note: here
      case 2:
      ^~~~
    arch/mips/oprofile/op_model_mipsxx.c:221:3: warning: this statement may fall through [-Wimplicit-fallthrough=]
       w_c0_perfctrl1(0);
       ^~~~~~~~~~~~~~~~~
    arch/mips/oprofile/op_model_mipsxx.c:222:2: note: here
      case 1:
      ^~~~
    arch/mips/oprofile/op_model_mipsxx.c: In function ‘mipsxx_cpu_start’:
    arch/mips/oprofile/op_model_mipsxx.c:197:3: warning: this statement may fall through [-Wimplicit-fallthrough=]
       w_c0_perfctrl3(WHAT | reg.control[3]);
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    arch/mips/oprofile/op_model_mipsxx.c:198:2: note: here
      case 3:
      ^~~~
    arch/mips/oprofile/op_model_mipsxx.c:199:3: warning: this statement may fall through [-Wimplicit-fallthrough=]
       w_c0_perfctrl2(WHAT | reg.control[2]);
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    arch/mips/oprofile/op_model_mipsxx.c:200:2: note: here
      case 2:
      ^~~~
    arch/mips/oprofile/op_model_mipsxx.c:201:3: warning: this statement may fall through [-Wimplicit-fallthrough=]
       w_c0_perfctrl1(WHAT | reg.control[1]);
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    arch/mips/oprofile/op_model_mipsxx.c:202:2: note: here
      case 1:
      ^~~~
    arch/mips/oprofile/op_model_mipsxx.c: In function ‘reset_counters’:
    arch/mips/oprofile/op_model_mipsxx.c:299:3: warning: this statement may fall through [-Wimplicit-fallthrough=]
       w_c0_perfcntr3(0);
       ^~~~~~~~~~~~~~~~~
    arch/mips/oprofile/op_model_mipsxx.c:300:2: note: here
      case 3:
      ^~~~
    arch/mips/oprofile/op_model_mipsxx.c:302:3: warning: this statement may fall through [-Wimplicit-fallthrough=]
       w_c0_perfcntr2(0);
       ^~~~~~~~~~~~~~~~~
    arch/mips/oprofile/op_model_mipsxx.c:303:2: note: here
      case 2:
      ^~~~
    arch/mips/oprofile/op_model_mipsxx.c:305:3: warning: this statement may fall through [-Wimplicit-fallthrough=]
       w_c0_perfcntr1(0);
       ^~~~~~~~~~~~~~~~~
    arch/mips/oprofile/op_model_mipsxx.c:306:2: note: here
      case 1:
      ^~~~
    arch/mips/oprofile/op_model_mipsxx.c: In function ‘mipsxx_perfcount_handler’:
    arch/mips/oprofile/op_model_mipsxx.c:242:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
       if ((control & MIPS_PERFCTRL_IE) &&   \
          ^
    arch/mips/oprofile/op_model_mipsxx.c:248:2: note: in expansion of macro ‘HANDLE_COUNTER’
      HANDLE_COUNTER(3)
      ^~~~~~~~~~~~~~
    arch/mips/oprofile/op_model_mipsxx.c:239:2: note: here
      case n + 1:       \
      ^
    arch/mips/oprofile/op_model_mipsxx.c:249:2: note: in expansion of macro ‘HANDLE_COUNTER’
      HANDLE_COUNTER(2)
      ^~~~~~~~~~~~~~
    arch/mips/oprofile/op_model_mipsxx.c:242:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
       if ((control & MIPS_PERFCTRL_IE) &&   \
          ^
    arch/mips/oprofile/op_model_mipsxx.c:249:2: note: in expansion of macro ‘HANDLE_COUNTER’
      HANDLE_COUNTER(2)
      ^~~~~~~~~~~~~~
    arch/mips/oprofile/op_model_mipsxx.c:239:2: note: here
      case n + 1:       \
      ^
    arch/mips/oprofile/op_model_mipsxx.c:250:2: note: in expansion of macro ‘HANDLE_COUNTER’
      HANDLE_COUNTER(1)
      ^~~~~~~~~~~~~~
    arch/mips/oprofile/op_model_mipsxx.c:242:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
       if ((control & MIPS_PERFCTRL_IE) &&   \
          ^
    arch/mips/oprofile/op_model_mipsxx.c:250:2: note: in expansion of macro ‘HANDLE_COUNTER’
      HANDLE_COUNTER(1)
      ^~~~~~~~~~~~~~
    arch/mips/oprofile/op_model_mipsxx.c:239:2: note: here
      case n + 1:       \
      ^
    arch/mips/oprofile/op_model_mipsxx.c:251:2: note: in expansion of macro ‘HANDLE_COUNTER’
      HANDLE_COUNTER(0)
      ^~~~~~~~~~~~~~
      CC      usr/include/linux/pmu.h.s
    arch/mips/oprofile/op_model_mipsxx.c: In function ‘mipsxx_cpu_setup’:
    arch/mips/oprofile/op_model_mipsxx.c:174:3: warning: this statement may fall through [-Wimplicit-fallthrough=]
       w_c0_perfcntr3(reg.counter[3]);
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    arch/mips/oprofile/op_model_mipsxx.c:175:2: note: here
      case 3:
      ^~~~
    arch/mips/oprofile/op_model_mipsxx.c:177:3: warning: this statement may fall through [-Wimplicit-fallthrough=]
       w_c0_perfcntr2(reg.counter[2]);
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    arch/mips/oprofile/op_model_mipsxx.c:178:2: note: here
      case 2:
      ^~~~
    arch/mips/oprofile/op_model_mipsxx.c:180:3: warning: this statement may fall through [-Wimplicit-fallthrough=]
       w_c0_perfcntr1(reg.counter[1]);
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    arch/mips/oprofile/op_model_mipsxx.c:181:2: note: here
      case 1:
      ^~~~
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Robert Richter <rric@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: oprofile-list@lists.sf.net
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Cc: Kees Cook <keescook@chromium.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 7c04b17f4a48..96c13a0ab078 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -172,12 +172,15 @@ static void mipsxx_cpu_setup(void *args)
 	case 4:
 		w_c0_perfctrl3(0);
 		w_c0_perfcntr3(reg.counter[3]);
+		/* fall through */
 	case 3:
 		w_c0_perfctrl2(0);
 		w_c0_perfcntr2(reg.counter[2]);
+		/* fall through */
 	case 2:
 		w_c0_perfctrl1(0);
 		w_c0_perfcntr1(reg.counter[1]);
+		/* fall through */
 	case 1:
 		w_c0_perfctrl0(0);
 		w_c0_perfcntr0(reg.counter[0]);
@@ -195,10 +198,13 @@ static void mipsxx_cpu_start(void *args)
 	switch (counters) {
 	case 4:
 		w_c0_perfctrl3(WHAT | reg.control[3]);
+		/* fall through */
 	case 3:
 		w_c0_perfctrl2(WHAT | reg.control[2]);
+		/* fall through */
 	case 2:
 		w_c0_perfctrl1(WHAT | reg.control[1]);
+		/* fall through */
 	case 1:
 		w_c0_perfctrl0(WHAT | reg.control[0]);
 	}
@@ -215,10 +221,13 @@ static void mipsxx_cpu_stop(void *args)
 	switch (counters) {
 	case 4:
 		w_c0_perfctrl3(0);
+		/* fall through */
 	case 3:
 		w_c0_perfctrl2(0);
+		/* fall through */
 	case 2:
 		w_c0_perfctrl1(0);
+		/* fall through */
 	case 1:
 		w_c0_perfctrl0(0);
 	}
@@ -236,6 +245,7 @@ static int mipsxx_perfcount_handler(void)
 
 	switch (counters) {
 #define HANDLE_COUNTER(n)						\
+	/* fall through */						\
 	case n + 1:							\
 		control = r_c0_perfctrl ## n();				\
 		counter = r_c0_perfcntr ## n();				\
@@ -297,12 +307,15 @@ static void reset_counters(void *arg)
 	case 4:
 		w_c0_perfctrl3(0);
 		w_c0_perfcntr3(0);
+		/* fall through */
 	case 3:
 		w_c0_perfctrl2(0);
 		w_c0_perfcntr2(0);
+		/* fall through */
 	case 2:
 		w_c0_perfctrl1(0);
 		w_c0_perfcntr1(0);
+		/* fall through */
 	case 1:
 		w_c0_perfctrl0(0);
 		w_c0_perfcntr0(0);

commit 800fb71281ca2ed5c8a7299e10ebc0de2f61cdda
Author: Matt Redfearn <matt.redfearn@mips.com>
Date:   Fri Apr 20 11:23:04 2018 +0100

    MIPS: perf: More robustly probe for the presence of per-tc counters
    
    The presence of per TC performance counters is now detected by
    cpu-probe.c and indicated by MIPS_CPU_MT_PER_TC_PERF_COUNTERS in
    cpu_data. Switch detection of the feature to use this new flag rather
    than blindly testing the implementation specific config7 register with a
    magic number.
    
    Signed-off-by: Matt Redfearn <matt.redfearn@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Maciej W. Rozycki <macro@mips.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: Robert Richter <rric@kernel.org>
    Cc: linux-mips@linux-mips.org
    Cc: oprofile-list@lists.sf.net
    Patchwork: https://patchwork.linux-mips.org/patch/19142/
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index c3e4c18ef8d4..7c04b17f4a48 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -36,7 +36,6 @@ static int perfcount_irq;
 #endif
 
 #ifdef CONFIG_MIPS_MT_SMP
-static int cpu_has_mipsmt_pertccounters;
 #define WHAT		(MIPS_PERFCTRL_MT_EN_VPE | \
 			 M_PERFCTL_VPEID(cpu_vpe_id(&current_cpu_data)))
 #define vpe_id()	(cpu_has_mipsmt_pertccounters ? \
@@ -326,7 +325,6 @@ static int __init mipsxx_init(void)
 	}
 
 #ifdef CONFIG_MIPS_MT_SMP
-	cpu_has_mipsmt_pertccounters = read_c0_config7() & (1<<19);
 	if (!cpu_has_mipsmt_pertccounters)
 		counters = counters_total_to_per_cpu(counters);
 #endif

commit f875a832d2028523f9b53c261b67e05a359bab8b
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Sat Aug 12 19:49:35 2017 -0700

    MIPS: Abstract CPU core & VP(E) ID access through accessor functions
    
    We currently have fields in struct cpuinfo_mips for the core & VP(E) ID
    of a particular CPU, and various pieces of code directly access those
    fields. This patch abstracts such access by introducing accessor
    functions cpu_core(), cpu_set_core(), cpu_vpe_id() & cpu_set_vpe_id()
    and having code that needs to access these values call those functions
    rather than directly accessing the struct cpuinfo_mips fields. This
    prepares us for changes to the way in which those values are stored in
    later patches.
    
    The cpu_vpe_id() function is introduced even though we already had a
    cpu_vpe_id() macro for a couple of reasons:
    
      1) It's more consistent with the core, and future cluster, accessors.
    
      2) It ensures a sensible return type without explicit casts.
    
      3) It's generally preferable to use functions rather than macros.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/17009/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index c57da6f13929..c3e4c18ef8d4 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -38,9 +38,9 @@ static int perfcount_irq;
 #ifdef CONFIG_MIPS_MT_SMP
 static int cpu_has_mipsmt_pertccounters;
 #define WHAT		(MIPS_PERFCTRL_MT_EN_VPE | \
-			 M_PERFCTL_VPEID(cpu_data[smp_processor_id()].vpe_id))
+			 M_PERFCTL_VPEID(cpu_vpe_id(&current_cpu_data)))
 #define vpe_id()	(cpu_has_mipsmt_pertccounters ? \
-			0 : cpu_data[smp_processor_id()].vpe_id)
+			0 : cpu_vpe_id(&current_cpu_data))
 
 /*
  * The number of bits to shift to convert between counters per core and

commit 2654294bac83a64101c360eac4d42d5ac1b1b911
Author: James Hogan <james.hogan@imgtec.com>
Date:   Mon Feb 6 12:37:45 2017 +0000

    MIPS: Unify perf counter register definitions
    
    Unify definitions for MIPS performance counter register fields in
    mipsregs.h rather than duplicating them in perf_events and oprofile.
    This will allow future patches to use them to expose performance
    counters to KVM guests.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Robert Richter <rric@kernel.org>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Cc: oprofile-list@lists.sf.net
    Patchwork: https://patchwork.linux-mips.org/patch/15212/
    Signed-off-by: James Hogan <james.hogan@imgtec.com>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 45cb27469fba..c57da6f13929 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -15,26 +15,12 @@
 
 #include "op_impl.h"
 
-#define M_PERFCTL_EXL			(1UL	  <<  0)
-#define M_PERFCTL_KERNEL		(1UL	  <<  1)
-#define M_PERFCTL_SUPERVISOR		(1UL	  <<  2)
-#define M_PERFCTL_USER			(1UL	  <<  3)
-#define M_PERFCTL_INTERRUPT_ENABLE	(1UL	  <<  4)
-#define M_PERFCTL_EVENT(event)		(((event) & 0x3ff)  << 5)
-#define M_PERFCTL_VPEID(vpe)		((vpe)	  << 16)
-#define M_PERFCTL_MT_EN(filter)		((filter) << 20)
-#define	   M_TC_EN_ALL			M_PERFCTL_MT_EN(0)
-#define	   M_TC_EN_VPE			M_PERFCTL_MT_EN(1)
-#define	   M_TC_EN_TC			M_PERFCTL_MT_EN(2)
-#define M_PERFCTL_TCID(tcid)		((tcid)	  << 22)
-#define M_PERFCTL_WIDE			(1UL	  << 30)
-#define M_PERFCTL_MORE			(1UL	  << 31)
+#define M_PERFCTL_EVENT(event)		(((event) << MIPS_PERFCTRL_EVENT_S) & \
+					 MIPS_PERFCTRL_EVENT)
+#define M_PERFCTL_VPEID(vpe)		((vpe)	  << MIPS_PERFCTRL_VPEID_S)
 
 #define M_COUNTER_OVERFLOW		(1UL	  << 31)
 
-/* Netlogic XLR specific, count events in all threads in a core */
-#define M_PERFCTL_COUNT_ALL_THREADS	(1UL	  << 13)
-
 static int (*save_perf_irq)(void);
 static int perfcount_irq;
 
@@ -51,7 +37,7 @@ static int perfcount_irq;
 
 #ifdef CONFIG_MIPS_MT_SMP
 static int cpu_has_mipsmt_pertccounters;
-#define WHAT		(M_TC_EN_VPE | \
+#define WHAT		(MIPS_PERFCTRL_MT_EN_VPE | \
 			 M_PERFCTL_VPEID(cpu_data[smp_processor_id()].vpe_id))
 #define vpe_id()	(cpu_has_mipsmt_pertccounters ? \
 			0 : cpu_data[smp_processor_id()].vpe_id)
@@ -161,15 +147,15 @@ static void mipsxx_reg_setup(struct op_counter_config *ctr)
 			continue;
 
 		reg.control[i] = M_PERFCTL_EVENT(ctr[i].event) |
-				 M_PERFCTL_INTERRUPT_ENABLE;
+				 MIPS_PERFCTRL_IE;
 		if (ctr[i].kernel)
-			reg.control[i] |= M_PERFCTL_KERNEL;
+			reg.control[i] |= MIPS_PERFCTRL_K;
 		if (ctr[i].user)
-			reg.control[i] |= M_PERFCTL_USER;
+			reg.control[i] |= MIPS_PERFCTRL_U;
 		if (ctr[i].exl)
-			reg.control[i] |= M_PERFCTL_EXL;
+			reg.control[i] |= MIPS_PERFCTRL_EXL;
 		if (boot_cpu_type() == CPU_XLR)
-			reg.control[i] |= M_PERFCTL_COUNT_ALL_THREADS;
+			reg.control[i] |= XLR_PERFCTRL_ALLTHREADS;
 		reg.counter[i] = 0x80000000 - ctr[i].count;
 	}
 }
@@ -254,7 +240,7 @@ static int mipsxx_perfcount_handler(void)
 	case n + 1:							\
 		control = r_c0_perfctrl ## n();				\
 		counter = r_c0_perfcntr ## n();				\
-		if ((control & M_PERFCTL_INTERRUPT_ENABLE) &&		\
+		if ((control & MIPS_PERFCTRL_IE) &&			\
 		    (counter & M_COUNTER_OVERFLOW)) {			\
 			oprofile_add_sample(get_irq_regs(), n);		\
 			w_c0_perfcntr ## n(reg.counter[n]);		\
@@ -273,11 +259,11 @@ static inline int __n_counters(void)
 {
 	if (!cpu_has_perf)
 		return 0;
-	if (!(read_c0_perfctrl0() & M_PERFCTL_MORE))
+	if (!(read_c0_perfctrl0() & MIPS_PERFCTRL_M))
 		return 1;
-	if (!(read_c0_perfctrl1() & M_PERFCTL_MORE))
+	if (!(read_c0_perfctrl1() & MIPS_PERFCTRL_M))
 		return 2;
-	if (!(read_c0_perfctrl2() & M_PERFCTL_MORE))
+	if (!(read_c0_perfctrl2() & MIPS_PERFCTRL_M))
 		return 3;
 
 	return 4;

commit 30228c40f0c6f0a93910325f120904505a4c39cc
Author: James Hogan <james.hogan@imgtec.com>
Date:   Wed May 11 13:50:53 2016 +0100

    MIPS: Add perf counter feature
    
    Add CPU feature for standard MIPS r2 performance counters, as determined
    by the Config1.PC bit. Both perf_events and oprofile probe this bit, so
    lets combine the probing and change both to use cpu_has_perf.
    
    This will also be used for VZ support in KVM to know whether performance
    counters exist which can be exposed to guests.
    
    [ralf@linux-mips.org: resolve conflict.]
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Robert Richter <rric@kernel.org>
    Cc: linux-mips@linux-mips.org
    Cc: oprofile-list@lists.sf.net
    Patchwork: https://patchwork.linux-mips.org/patch/13226/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 8f988a61b7a8..45cb27469fba 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -269,11 +269,9 @@ static int mipsxx_perfcount_handler(void)
 	return handled;
 }
 
-#define M_CONFIG1_PC	(1 << 4)
-
 static inline int __n_counters(void)
 {
-	if (!(read_c0_config1() & M_CONFIG1_PC))
+	if (!cpu_has_perf)
 		return 0;
 	if (!(read_c0_perfctrl0() & M_PERFCTL_MORE))
 		return 1;

commit 4e88a8621301b992e8e3422e08bfb604772f3338
Author: Markos Chandras <markos.chandras@imgtec.com>
Date:   Thu Jul 9 10:40:36 2015 +0100

    MIPS: Add cases for CPU_I6400
    
    Add a CPU_I6400 case to various switch statements, doing the same thing
    as for CPU_P5600.
    
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/10635/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 6a6e2cc55b89..8f988a61b7a8 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -392,6 +392,10 @@ static int __init mipsxx_init(void)
 		op_model_mipsxx_ops.cpu_type = "mips/P5600";
 		break;
 
+	case CPU_I6400:
+		op_model_mipsxx_ops.cpu_type = "mips/I6400";
+		break;
+
 	case CPU_M5150:
 		op_model_mipsxx_ops.cpu_type = "mips/M5150";
 		break;

commit 3057739138eb8fbaa5154b149a864f5218898c73
Author: Joshua Kinard <kumba@gentoo.org>
Date:   Wed Jan 21 07:59:45 2015 -0500

    MIPS: Add R16000 detection
    
    This allows the kernel to correctly detect an R16000 MIPS CPU on systems that
    have those.  Otherwise, such systems will detect the CPU as an R14000, due to
    similarities in the CPU PRId value.
    
    Signed-off-by: Joshua Kinard <kumba@gentoo.org>
    Cc: Linux MIPS List <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/9092/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index d6b9e69e7c69..6a6e2cc55b89 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -296,6 +296,7 @@ static inline int n_counters(void)
 
 	case CPU_R12000:
 	case CPU_R14000:
+	case CPU_R16000:
 		counters = 4;
 		break;
 
@@ -411,6 +412,10 @@ static int __init mipsxx_init(void)
 		op_model_mipsxx_ops.cpu_type = "mips/r12000";
 		break;
 
+	case CPU_R16000:
+		op_model_mipsxx_ops.cpu_type = "mips/r16000";
+		break;
+
 	case CPU_SB1:
 	case CPU_SB1A:
 		op_model_mipsxx_ops.cpu_type = "mips/sb1";

commit 369a93bbc78dd7848d433d60e3c88a0c698dde57
Author: James Hogan <james.hogan@imgtec.com>
Date:   Tue Jan 27 21:45:54 2015 +0000

    MIPS: OProfile: Allow sharing IRQ with timer
    
    When requesting the performance counter overflow interrupt, pass flags
    which are compatible with the cevt-r4k driver, in particular
    IRQF_SHARED so that the two handlers can share the same IRQ. This is
    possible since release 2 of the architecture where there are separate
    pending interrupt bits for the timer interrupt and the performance
    counter interrupt.
    
    This will be necessary since the FDC interrupt can also be arbitrarily
    routed to a CPU interrupt, possibly sharing with the timer, the
    performance counters, or both, and it isn't scalable to have all the
    handlers able to call other handlers that may be on the same IRQ line.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Robert Richter <rric@kernel.org>
    Cc: linux-mips@linux-mips.org
    Cc: oprofile-list@lists.sf.net
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/9130/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 24729f023d93..d6b9e69e7c69 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -442,7 +442,10 @@ static int __init mipsxx_init(void)
 
 	if (perfcount_irq >= 0)
 		return request_irq(perfcount_irq, mipsxx_perfcount_int,
-			0, "Perfcounter", save_perf_irq);
+				   IRQF_PERCPU | IRQF_NOBALANCING |
+				   IRQF_NO_THREAD | IRQF_NO_SUSPEND |
+				   IRQF_SHARED,
+				   "Perfcounter", save_perf_irq);
 
 	return 0;
 }

commit 7eca5b1460f3f1ad3891252743c36f309df53d53
Author: James Hogan <james.hogan@imgtec.com>
Date:   Tue Jan 27 21:45:49 2015 +0000

    MIPS: Remove redundant IPTI==IPPCI logic
    
    The situation where the timer interrupt is on the same line as the
    performance counter interrupt is handled in per_cpu_trap_init() by
    setting cp0_perfcount_irq to -1, so there is no need to duplicate the
    logic conditional upon cp0_perfcount_irq >= 0 in perf
    (init_hw_perf_events()) and oprofile (mipsxx_init()).
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/9125/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index faf0d4ad0cc2..24729f023d93 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -435,8 +435,7 @@ static int __init mipsxx_init(void)
 
 	if (get_c0_perfcount_int)
 		perfcount_irq = get_c0_perfcount_int();
-	else if ((cp0_perfcount_irq >= 0) &&
-		 (cp0_compare_irq != cp0_perfcount_irq))
+	else if (cp0_perfcount_irq >= 0)
 		perfcount_irq = MIPS_CPU_IRQ_BASE + cp0_perfcount_irq;
 	else
 		perfcount_irq = -1;

commit 3ba5040af01fb06a36198f5f6065e25b0655ca0d
Author: James Hogan <james.hogan@imgtec.com>
Date:   Tue Jan 27 21:45:48 2015 +0000

    MIPS: cevt-r4k: Use CAUSEF_TI, CAUSEF_PCI constants
    
    Use CAUSEF_TI and CAUSEF_PCI constants from asm/mipsregs.h rather than
    the magic values (1 << 30) and (1 << 26).
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/9124/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 01f721a85c5b..faf0d4ad0cc2 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -246,7 +246,7 @@ static int mipsxx_perfcount_handler(void)
 	unsigned int counter;
 	int handled = IRQ_NONE;
 
-	if (cpu_has_mips_r2 && !(read_c0_cause() & (1 << 26)))
+	if (cpu_has_mips_r2 && !(read_c0_cause() & CAUSEF_PCI))
 		return handled;
 
 	switch (counters) {

commit a669efc4a3b49de9226b280bb683f5b1d5a5d143
Author: Andrew Bresticker <abrestic@chromium.org>
Date:   Thu Sep 18 14:47:12 2014 -0700

    MIPS: Add hook to get C0 performance counter interrupt
    
    The hardware perf event driver and oprofile interpret the global
    cp0_perfcount_irq differently: in the hardware perf event driver
    it is an offset from MIPS_CPU_IRQ_BASE and in oprofile it is the
    actual IRQ number.  This still works most of the time since
    MIPS_CPU_IRQ_BASE is usually 0, but is clearly wrong.  Since the
    performance counter interrupt may vary from platform to platform
    like the C0 timer interrupt, add the optional get_c0_perfcount_int
    hook which returns the IRQ number of the performance counter.
    The hook should return < 0 if the performance counter interrupt is
    shared with the timer.  If the hook is not present, the CPU vector
    reported in C0_IntCtl (cp0_perfcount_irq) is used.
    
    Signed-off-by: Andrew Bresticker <abrestic@chromium.org>
    Reviewed-by: Qais Yousef <qais.yousef@imgtec.com>
    Tested-by: Qais Yousef <qais.yousef@imgtec.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Bresticker <abrestic@chromium.org>
    Cc: Jeffrey Deans <jeffrey.deans@imgtec.com>
    Cc: Markos Chandras <markos.chandras@imgtec.com>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Qais Yousef <qais.yousef@imgtec.com>
    Cc: Jonas Gorski <jogo@openwrt.org>
    Cc: John Crispin <blogic@openwrt.org>
    Cc: David Daney <ddaney.cavm@gmail.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/7805/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 42821ae2d77e..01f721a85c5b 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -11,6 +11,7 @@
 #include <linux/interrupt.h>
 #include <linux/smp.h>
 #include <asm/irq_regs.h>
+#include <asm/time.h>
 
 #include "op_impl.h"
 
@@ -35,6 +36,7 @@
 #define M_PERFCTL_COUNT_ALL_THREADS	(1UL	  << 13)
 
 static int (*save_perf_irq)(void);
+static int perfcount_irq;
 
 /*
  * XLR has only one set of counters per core. Designate the
@@ -431,8 +433,16 @@ static int __init mipsxx_init(void)
 	save_perf_irq = perf_irq;
 	perf_irq = mipsxx_perfcount_handler;
 
-	if ((cp0_perfcount_irq >= 0) && (cp0_compare_irq != cp0_perfcount_irq))
-		return request_irq(cp0_perfcount_irq, mipsxx_perfcount_int,
+	if (get_c0_perfcount_int)
+		perfcount_irq = get_c0_perfcount_int();
+	else if ((cp0_perfcount_irq >= 0) &&
+		 (cp0_compare_irq != cp0_perfcount_irq))
+		perfcount_irq = MIPS_CPU_IRQ_BASE + cp0_perfcount_irq;
+	else
+		perfcount_irq = -1;
+
+	if (perfcount_irq >= 0)
+		return request_irq(perfcount_irq, mipsxx_perfcount_int,
 			0, "Perfcounter", save_perf_irq);
 
 	return 0;
@@ -442,8 +452,8 @@ static void mipsxx_exit(void)
 {
 	int counters = op_model_mipsxx_ops.num_counters;
 
-	if ((cp0_perfcount_irq >= 0) && (cp0_compare_irq != cp0_perfcount_irq))
-		free_irq(cp0_perfcount_irq, save_perf_irq);
+	if (perfcount_irq >= 0)
+		free_irq(perfcount_irq, save_perf_irq);
 
 	counters = counters_per_cpu_to_total(counters);
 	on_each_cpu(reset_counters, (void *)(long)counters, 1);

commit f36c4720fca325579faddc880d4e178e4ccbda88
Author: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
Date:   Tue Mar 4 13:34:43 2014 +0000

    MIPS: Add support for the M5150 processor
    
    The M5150 core is a 32-bit MIPS RISC which implements the
    MIPS Architecture Release-5  in a 5-stage pipeline.
    In addition, it includes the MIPS Architecture Virtualization Module
    that enables virtualization of operating systems,
    which provides a scalable, trusted, and secure execution environment.
    
    Signed-off-by: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/6596/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 9797493546e4..42821ae2d77e 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -389,6 +389,10 @@ static int __init mipsxx_init(void)
 		op_model_mipsxx_ops.cpu_type = "mips/P5600";
 		break;
 
+	case CPU_M5150:
+		op_model_mipsxx_ops.cpu_type = "mips/M5150";
+		break;
+
 	case CPU_5KC:
 		op_model_mipsxx_ops.cpu_type = "mips/5K";
 		break;

commit 8c7f6ba3427b2a70aac0016f959b6977c395e8cb
Author: James Hogan <james.hogan@imgtec.com>
Date:   Wed Jan 22 16:19:41 2014 +0000

    MIPS: OProfile: Add CPU_P5600 cases
    
    Add a CPU_P5600 cpu type case in oprofile_arch_init() to use the MIPS
    model, and in mipsxx_init() to set the cpu_type string to "mips/P5600".
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Reviewed-by: Markos Chandras <markos.chandras@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: Robert Richter <rric@kernel.org>
    Cc: oprofile-list@lists.sf.net
    Patchwork: https://patchwork.linux-mips.org/patch/6410/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 3a040ebb8378..9797493546e4 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -385,6 +385,10 @@ static int __init mipsxx_init(void)
 		op_model_mipsxx_ops.cpu_type = "mips/proAptiv";
 		break;
 
+	case CPU_P5600:
+		op_model_mipsxx_ops.cpu_type = "mips/P5600";
+		break;
+
 	case CPU_5KC:
 		op_model_mipsxx_ops.cpu_type = "mips/5K";
 		break;

commit 442e14a2c55e55f208bf87e3686396b4ff17ebf6
Author: Steven J. Hill <Steven.Hill@imgtec.com>
Date:   Fri Jan 17 15:03:50 2014 -0600

    MIPS: Add 1074K CPU support explicitly.
    
    The 1074K is a multiprocessing coherent processing system (CPS) based
    on modified 74K cores. This patch makes the 1074K an actual unique
    CPU type, instead of a 74K derivative, which it is not.
    
    Signed-off-by: Steven J. Hill <Steven.Hill@imgtec.com>
    Reviewed-by: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/6389/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 4d94d75ec6f9..3a040ebb8378 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -372,6 +372,7 @@ static int __init mipsxx_init(void)
 		op_model_mipsxx_ops.cpu_type = "mips/34K";
 		break;
 
+	case CPU_1074K:
 	case CPU_74K:
 		op_model_mipsxx_ops.cpu_type = "mips/74K";
 		break;

commit 26ab96dfa9f98d74ef38efbe830d356547a292c1
Author: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
Date:   Wed Nov 27 10:07:53 2013 +0000

    MIPS: Add support for interAptiv cores
    
    The interAptiv is a power-efficient multi-core microprocessor
    for use in system-on-chip (SoC) applications. The interAptiv combines
    a multi-threading pipeline with a coherence manager to deliver improved
    computational throughput and power efficiency. The interAptiv can
    contain one to four MIPS32R3 interAptiv cores, system level
    coherence manager with L2 cache, optional coherent I/O port,
    and optional floating point unit.
    
    Signed-off-by: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/6163/

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 3e28aaa39bc9..4d94d75ec6f9 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -376,6 +376,10 @@ static int __init mipsxx_init(void)
 		op_model_mipsxx_ops.cpu_type = "mips/74K";
 		break;
 
+	case CPU_INTERAPTIV:
+		op_model_mipsxx_ops.cpu_type = "mips/interAptiv";
+		break;
+
 	case CPU_PROAPTIV:
 		op_model_mipsxx_ops.cpu_type = "mips/proAptiv";
 		break;

commit 708ac4b8703ea3204eee7c1c00c29912468a759d
Author: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
Date:   Thu Nov 14 16:12:27 2013 +0000

    MIPS: Add support for the proAptiv cores
    
    The proAptiv Multiprocessing System is a power efficient multi-core
    microprocessor for use in system-on-chip (SoC) applications.
    The proAptiv Multiprocessing System combines a deep pipeline
    with multi-issue out of order execution for improved computational
    throughput. The proAptiv Multiprocessing System can contain one to
    six MIPS32r3 proAptiv cores, system level coherence
    manager with L2 cache, optional coherent I/O port, and optional
    floating point unit.
    
    Signed-off-by: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/6134/

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 3a2b6e9f25cf..3e28aaa39bc9 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -376,6 +376,10 @@ static int __init mipsxx_init(void)
 		op_model_mipsxx_ops.cpu_type = "mips/74K";
 		break;
 
+	case CPU_PROAPTIV:
+		op_model_mipsxx_ops.cpu_type = "mips/proAptiv";
+		break;
+
 	case CPU_5KC:
 		op_model_mipsxx_ops.cpu_type = "mips/5K";
 		break;

commit cf5b2d23a75cbb53785d270e76e4911e84797b72
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Aug 1 18:31:05 2013 +0200

    MIPS: oprofile: Fix BUG due to smp_processor_id() in preemptible code.
    
    current_cpu_type() is not preemption-safe.
    If CONFIG_PREEMPT is enabled then mipsxx_reg_setup() can be called from preemptible state.
    Added get_cpu()/put_cpu() pair to make it preemption-safe.
    
    This was found while testing oprofile with CONFIG_DEBUG_PREEMPT enable.
    
    /usr/zntestsuite # opcontrol --init
    /usr/zntestsuite # opcontrol --setup --event=L2_CACHE_ACCESSES:500 --event=L2_CACHE_MISSES:500 --no-vmlinux
    /usr/zntestsuite # opcontrol --start
    Using 2.6+ OProfile kernel interface.
    BUG: using smp_processor_id() in preemptible [00000000] code: oprofiled/1362
    caller is mipsxx_reg_setup+0x11c/0x164
    CPU: 0 PID: 1362 Comm: oprofiled Not tainted 3.10.4 #18
    Stack : 00000006 70757465 00000000 00000000 00000000 00000000 80b173f6 00000037
              80b10000 00000000 80b21614 88f5a220 00000000 00000000 00000000 00000000
              00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
              00000000 00000000 00000000 89c49c00 89c49c2c 80721254 807b7927 8012c1d0
              80b10000 80721254 00000000 00000552 88f5a220 80b1335c 807b78e6 89c49ba8
              ...
    Call Trace:
    [<801099a4>] show_stack+0x64/0x7c
    [<80665520>] dump_stack+0x20/0x2c
    [<803a2250>] debug_smp_processor_id+0xe0/0xf0
    [<8052df24>] mipsxx_reg_setup+0x11c/0x164
    [<8052cd70>] op_mips_setup+0x24/0x4c
    [<80529cfc>] oprofile_setup+0x5c/0x12c
    [<8052b9f8>] event_buffer_open+0x78/0xf8
    [<801c3150>] do_dentry_open.isra.15+0x2b8/0x3b0
    [<801c3270>] finish_open+0x28/0x4c
    [<801d49b8>] do_last.isra.41+0x2cc/0xd00
    [<801d54a0>] path_openat+0xb4/0x4c4
    [<801d5c44>] do_filp_open+0x3c/0xac
    [<801c4744>] do_sys_open+0x110/0x1f4
    [<8010f47c>] stack_done+0x20/0x44
    
    Bug reported and original patch by Jerin Jacob <jerinjacobk@gmail.com>.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: Jerin Jacob <jerinjacobk@gmail.com>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index e4b1140cdae0..3a2b6e9f25cf 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -166,7 +166,7 @@ static void mipsxx_reg_setup(struct op_counter_config *ctr)
 			reg.control[i] |= M_PERFCTL_USER;
 		if (ctr[i].exl)
 			reg.control[i] |= M_PERFCTL_EXL;
-		if (current_cpu_type() == CPU_XLR)
+		if (boot_cpu_type() == CPU_XLR)
 			reg.control[i] |= M_PERFCTL_COUNT_ALL_THREADS;
 		reg.counter[i] = 0x80000000 - ctr[i].count;
 	}

commit 83a18415ba295c25d94bdc81fdb3a18fc1c2ce4e
Author: Jayachandran C <jchandra@broadcom.com>
Date:   Mon Mar 25 06:51:52 2013 +0000

    MIPS: Netlogic: Fix oprofile compile on XLR uniprocessor
    
    The commit c783390a0ecef08df5c804f8c5f647431a04f502 [MIPS: oprofile:
    Support for XLR/XLS processors] causes a compilation failure when
    oprofile is enabled and SMP is not configured.
    
    arch/mips/oprofile/op_model_mipsxx.c: In function 'mipsxx_cpu_setup':
    arch/mips/oprofile/op_model_mipsxx.c:181:2: error: implicit declaration of function 'cpu_logical_map'
    
    To fix this, update oprofile_skip_cpu to not call cpu_logical_map when
    CONFIG_SMP is not defined.
    
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Patchwork: http://patchwork.linux-mips.org/patch/5037/
    Acked-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 1fd361462c03..e4b1140cdae0 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -41,7 +41,7 @@ static int (*save_perf_irq)(void);
  * first hardware thread in the core for setup and init.
  * Skip CPUs with non-zero hardware thread id (4 hwt per core)
  */
-#ifdef CONFIG_CPU_XLR
+#if defined(CONFIG_CPU_XLR) && defined(CONFIG_SMP)
 #define oprofile_skip_cpu(c)	((cpu_logical_map(c) & 0x3) != 0)
 #else
 #define oprofile_skip_cpu(c)	0

commit 8bfc245f9ad7bd4e461179e4e7852ef99b8b6144
Merge: 612663a97406 535237cecab2
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Feb 21 12:51:33 2013 +0100

    Merge branch 'mips-next-3.9' of git://git.linux-mips.org/pub/scm/john/linux-john into mips-for-linux-next

commit f8fa4811dbb264aef13f982e963389fd828b1ac0
Author: Steven J. Hill <sjhill@mips.com>
Date:   Fri Dec 7 03:51:35 2012 +0000

    MIPS: Add support for the M14KEc core.
    
    Signed-off-by: Steven J. Hill <sjhill@mips.com>
    Patchwork: http://patchwork.linux-mips.org/patch/4682/
    Signed-off-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 786254630403..18c3afefa67d 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -351,6 +351,10 @@ static int __init mipsxx_init(void)
 		op_model_mipsxx_ops.cpu_type = "mips/M14Kc";
 		break;
 
+	case CPU_M14KEC:
+		op_model_mipsxx_ops.cpu_type = "mips/M14KEc";
+		break;
+
 	case CPU_20KC:
 		op_model_mipsxx_ops.cpu_type = "mips/20K";
 		break;

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 786254630403..1cfab95755b9 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -14,25 +14,25 @@
 
 #include "op_impl.h"
 
-#define M_PERFCTL_EXL			(1UL      <<  0)
-#define M_PERFCTL_KERNEL		(1UL      <<  1)
-#define M_PERFCTL_SUPERVISOR		(1UL      <<  2)
-#define M_PERFCTL_USER			(1UL      <<  3)
-#define M_PERFCTL_INTERRUPT_ENABLE	(1UL      <<  4)
+#define M_PERFCTL_EXL			(1UL	  <<  0)
+#define M_PERFCTL_KERNEL		(1UL	  <<  1)
+#define M_PERFCTL_SUPERVISOR		(1UL	  <<  2)
+#define M_PERFCTL_USER			(1UL	  <<  3)
+#define M_PERFCTL_INTERRUPT_ENABLE	(1UL	  <<  4)
 #define M_PERFCTL_EVENT(event)		(((event) & 0x3ff)  << 5)
-#define M_PERFCTL_VPEID(vpe)		((vpe)    << 16)
+#define M_PERFCTL_VPEID(vpe)		((vpe)	  << 16)
 #define M_PERFCTL_MT_EN(filter)		((filter) << 20)
-#define    M_TC_EN_ALL			M_PERFCTL_MT_EN(0)
-#define    M_TC_EN_VPE			M_PERFCTL_MT_EN(1)
-#define    M_TC_EN_TC			M_PERFCTL_MT_EN(2)
-#define M_PERFCTL_TCID(tcid)		((tcid)   << 22)
-#define M_PERFCTL_WIDE			(1UL      << 30)
-#define M_PERFCTL_MORE			(1UL      << 31)
+#define	   M_TC_EN_ALL			M_PERFCTL_MT_EN(0)
+#define	   M_TC_EN_VPE			M_PERFCTL_MT_EN(1)
+#define	   M_TC_EN_TC			M_PERFCTL_MT_EN(2)
+#define M_PERFCTL_TCID(tcid)		((tcid)	  << 22)
+#define M_PERFCTL_WIDE			(1UL	  << 30)
+#define M_PERFCTL_MORE			(1UL	  << 31)
 
-#define M_COUNTER_OVERFLOW		(1UL      << 31)
+#define M_COUNTER_OVERFLOW		(1UL	  << 31)
 
 /* Netlogic XLR specific, count events in all threads in a core */
-#define M_PERFCTL_COUNT_ALL_THREADS	(1UL      << 13)
+#define M_PERFCTL_COUNT_ALL_THREADS	(1UL	  << 13)
 
 static int (*save_perf_irq)(void);
 
@@ -143,7 +143,7 @@ static struct mipsxx_register_config {
 	unsigned int counter[4];
 } reg;
 
-/* Compute all of the registers in preparation for enabling profiling.  */
+/* Compute all of the registers in preparation for enabling profiling.	*/
 
 static void mipsxx_reg_setup(struct op_counter_config *ctr)
 {
@@ -159,7 +159,7 @@ static void mipsxx_reg_setup(struct op_counter_config *ctr)
 			continue;
 
 		reg.control[i] = M_PERFCTL_EVENT(ctr[i].event) |
-		                 M_PERFCTL_INTERRUPT_ENABLE;
+				 M_PERFCTL_INTERRUPT_ENABLE;
 		if (ctr[i].kernel)
 			reg.control[i] |= M_PERFCTL_KERNEL;
 		if (ctr[i].user)
@@ -172,7 +172,7 @@ static void mipsxx_reg_setup(struct op_counter_config *ctr)
 	}
 }
 
-/* Program all of the registers in preparation for enabling profiling.  */
+/* Program all of the registers in preparation for enabling profiling.	*/
 
 static void mipsxx_cpu_setup(void *args)
 {

commit c783390a0ecef08df5c804f8c5f647431a04f502
Author: Madhusudan Bhat <mbhat@netlogicmicro.com>
Date:   Wed Oct 31 12:01:27 2012 +0000

    MIPS: oprofile: Support for XLR/XLS processors
    
    Add support for XLR and XLS processors in MIPS Oprofile code. These
    processors are multi-threaded and have two counters per core. Each
    counter can track either all the events in the core (global mode),
    or events in just one thread.
    
    We use the counters in the global mode, and use only the first thread
    in each core to handle the configuration etc.
    
    Signed-off-by: Madhusudan Bhat <mbhat@netlogicmicro.com>
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Patchwork: http://patchwork.linux-mips.org/patch/4471
    Signed-off-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 28ea1a4cc576..786254630403 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -31,8 +31,22 @@
 
 #define M_COUNTER_OVERFLOW		(1UL      << 31)
 
+/* Netlogic XLR specific, count events in all threads in a core */
+#define M_PERFCTL_COUNT_ALL_THREADS	(1UL      << 13)
+
 static int (*save_perf_irq)(void);
 
+/*
+ * XLR has only one set of counters per core. Designate the
+ * first hardware thread in the core for setup and init.
+ * Skip CPUs with non-zero hardware thread id (4 hwt per core)
+ */
+#ifdef CONFIG_CPU_XLR
+#define oprofile_skip_cpu(c)	((cpu_logical_map(c) & 0x3) != 0)
+#else
+#define oprofile_skip_cpu(c)	0
+#endif
+
 #ifdef CONFIG_MIPS_MT_SMP
 static int cpu_has_mipsmt_pertccounters;
 #define WHAT		(M_TC_EN_VPE | \
@@ -152,6 +166,8 @@ static void mipsxx_reg_setup(struct op_counter_config *ctr)
 			reg.control[i] |= M_PERFCTL_USER;
 		if (ctr[i].exl)
 			reg.control[i] |= M_PERFCTL_EXL;
+		if (current_cpu_type() == CPU_XLR)
+			reg.control[i] |= M_PERFCTL_COUNT_ALL_THREADS;
 		reg.counter[i] = 0x80000000 - ctr[i].count;
 	}
 }
@@ -162,6 +178,9 @@ static void mipsxx_cpu_setup(void *args)
 {
 	unsigned int counters = op_model_mipsxx_ops.num_counters;
 
+	if (oprofile_skip_cpu(smp_processor_id()))
+		return;
+
 	switch (counters) {
 	case 4:
 		w_c0_perfctrl3(0);
@@ -183,6 +202,9 @@ static void mipsxx_cpu_start(void *args)
 {
 	unsigned int counters = op_model_mipsxx_ops.num_counters;
 
+	if (oprofile_skip_cpu(smp_processor_id()))
+		return;
+
 	switch (counters) {
 	case 4:
 		w_c0_perfctrl3(WHAT | reg.control[3]);
@@ -200,6 +222,9 @@ static void mipsxx_cpu_stop(void *args)
 {
 	unsigned int counters = op_model_mipsxx_ops.num_counters;
 
+	if (oprofile_skip_cpu(smp_processor_id()))
+		return;
+
 	switch (counters) {
 	case 4:
 		w_c0_perfctrl3(0);
@@ -372,6 +397,10 @@ static int __init mipsxx_init(void)
 		op_model_mipsxx_ops.cpu_type = "mips/loongson1";
 		break;
 
+	case CPU_XLR:
+		op_model_mipsxx_ops.cpu_type = "mips/xlr";
+		break;
+
 	default:
 		printk(KERN_ERR "Profiling unsupported for this CPU\n");
 

commit 68d8848567ef03eb2c2303173934428d0bf0a531
Merge: 28a33cbc24e4 71a1c776d51a 6c2be5cf1d4e 2f74b770aa6d b59b28410145 f9c9affc5799 6cd3c7e2b1dc 9afd40811538 7e6507ad76a2
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Jul 25 16:37:46 2012 +0200

    Merge branches 'next/generic', 'next/alchemy', 'next/bcm63xx', 'next/cavium', 'next/jz4740', 'next/lantiq', 'next/loongson1b' and 'next/netlogic' into mips-for-linux-next

commit 2fa36399e63c911134f28b6878aada9b395c4209
Author: Kelvin Cheung <keguang.zhang@gmail.com>
Date:   Wed Jun 20 20:05:32 2012 +0100

    MIPS: Add CPU support for Loongson1B
    
    Loongson 1B is a 32-bit SoC designed by Institute of Computing Technology
    (ICT) and the Chinese Academy of Sciences (CAS), which implements the
    MIPS32 release 2 instruction set.
    
    [ralf@linux-mips.org: But which is not strictly a MIPS32 compliant device
    which also is why it identifies itself with the Legacy Vendor ID in the
    PrID register.  When applying the patch I shoveled some code around to
    keep things in alphabetical order and avoid forward declarations.]
    
    Signed-off-by: Kelvin Cheung <keguang.zhang@gmail.com>
    Cc: To: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Cc: wuzhangjin@gmail.com
    Cc: zhzhl555@gmail.com
    Cc: Kelvin Cheung <keguang.zhang@gmail.com>
    Patchwork: https://patchwork.linux-mips.org/patch/3976/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 4d80a856048d..056da6224163 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -374,6 +374,10 @@ static int __init mipsxx_init(void)
 		op_model_mipsxx_ops.cpu_type = "mips/sb1";
 		break;
 
+	case CPU_LOONGSON1:
+		op_model_mipsxx_ops.cpu_type = "mips/loongson1";
+		break;
+
 	default:
 		printk(KERN_ERR "Profiling unsupported for this CPU\n");
 

commit 2244f1286509673c0b40fb9504a9be0b7b633aeb
Author: Steven J. Hill <sjhill@mips.com>
Date:   Mon May 21 10:33:16 2012 -0500

    MIPS: Remove dead code related to 1004K oprofile support.
    
    Signed-off-by: Steven J. Hill <sjhill@mips.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/3854/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 4d80a856048d..52da646167f9 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -339,12 +339,6 @@ static int __init mipsxx_init(void)
 		break;
 
 	case CPU_1004K:
-#if 0
-		/* FIXME: report as 34K for now */
-		op_model_mipsxx_ops.cpu_type = "mips/1004K";
-		break;
-#endif
-
 	case CPU_34K:
 		op_model_mipsxx_ops.cpu_type = "mips/34K";
 		break;

commit 113c62d9844d9037508fa156e47db1b5407a27c3
Author: Steven J. Hill <sjhill@mips.com>
Date:   Fri Jul 6 23:56:00 2012 +0200

    MIPS: Add support for the M14Kc core.
    
    [ralf@linux-mips.org: Fixed whitespace damage.]
    
    Signed-off-by: Steven J. Hill <sjhill@mips.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/3773/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index baba3bcaa3c2..4d80a856048d 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -322,6 +322,10 @@ static int __init mipsxx_init(void)
 
 	op_model_mipsxx_ops.num_counters = counters;
 	switch (current_cpu_type()) {
+	case CPU_M14KC:
+		op_model_mipsxx_ops.cpu_type = "mips/M14Kc";
+		break;
+
 	case CPU_20KC:
 		op_model_mipsxx_ops.cpu_type = "mips/20K";
 		break;

commit 3572a2c37f667ee49333f8863722b8f43eac506b
Author: Felix Fietkau <nbd@openwrt.org>
Date:   Wed May 2 17:33:04 2012 +0200

    MIPS: make oprofile use cp0_perfcount_irq if it is set
    
    Make the oprofile code use the performance counters irq.
    
    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/3723/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 54759f1669d3..baba3bcaa3c2 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -298,6 +298,11 @@ static void reset_counters(void *arg)
 	}
 }
 
+static irqreturn_t mipsxx_perfcount_int(int irq, void *dev_id)
+{
+	return mipsxx_perfcount_handler();
+}
+
 static int __init mipsxx_init(void)
 {
 	int counters;
@@ -374,6 +379,10 @@ static int __init mipsxx_init(void)
 	save_perf_irq = perf_irq;
 	perf_irq = mipsxx_perfcount_handler;
 
+	if ((cp0_perfcount_irq >= 0) && (cp0_compare_irq != cp0_perfcount_irq))
+		return request_irq(cp0_perfcount_irq, mipsxx_perfcount_int,
+			0, "Perfcounter", save_perf_irq);
+
 	return 0;
 }
 
@@ -381,6 +390,9 @@ static void mipsxx_exit(void)
 {
 	int counters = op_model_mipsxx_ops.num_counters;
 
+	if ((cp0_perfcount_irq >= 0) && (cp0_compare_irq != cp0_perfcount_irq))
+		free_irq(cp0_perfcount_irq, save_perf_irq);
+
 	counters = counters_per_cpu_to_total(counters);
 	on_each_cpu(reset_counters, (void *)(long)counters, 1);
 

commit f6f88e9bfb6ced9871ed65ebe85c371de3c9e4be
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Jul 15 22:08:52 2008 +0200

    generic-ipi: more merge fallout
    
    fix more API change fallout in recently merged upstream changes.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index b40df7d2cf44..54759f1669d3 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -313,7 +313,7 @@ static int __init mipsxx_init(void)
 	if (!cpu_has_mipsmt_pertccounters)
 		counters = counters_total_to_per_cpu(counters);
 #endif
-	on_each_cpu(reset_counters, (void *)(long)counters, 0, 1);
+	on_each_cpu(reset_counters, (void *)(long)counters, 1);
 
 	op_model_mipsxx_ops.num_counters = counters;
 	switch (current_cpu_type()) {
@@ -382,7 +382,7 @@ static void mipsxx_exit(void)
 	int counters = op_model_mipsxx_ops.num_counters;
 
 	counters = counters_per_cpu_to_total(counters);
-	on_each_cpu(reset_counters, (void *)(long)counters, 0, 1);
+	on_each_cpu(reset_counters, (void *)(long)counters, 1);
 
 	perf_irq = save_perf_irq;
 }

commit 005ca9a3f1238ffebd9c4d09d581f708277d2985
Author: Thiemo Seufer <ths@networkno.de>
Date:   Tue May 6 11:23:33 2008 +0100

    [MIPS] Fix build failure in mips oprofile code
    
    This patch fixes a warning-as-error induced build failure of 64bit MIPS
    kernels.
    
    Signed-off-by: Thiemo Seufer <ths@networkno.de>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index da8cbb6899dc..b40df7d2cf44 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -281,7 +281,7 @@ static inline int n_counters(void)
 
 static void reset_counters(void *arg)
 {
-	int counters = (int)arg;
+	int counters = (int)(long)arg;
 	switch (counters) {
 	case 4:
 		w_c0_perfctrl3(0);
@@ -313,7 +313,7 @@ static int __init mipsxx_init(void)
 	if (!cpu_has_mipsmt_pertccounters)
 		counters = counters_total_to_per_cpu(counters);
 #endif
-	on_each_cpu(reset_counters, (void *)counters, 0, 1);
+	on_each_cpu(reset_counters, (void *)(long)counters, 0, 1);
 
 	op_model_mipsxx_ops.num_counters = counters;
 	switch (current_cpu_type()) {
@@ -382,7 +382,7 @@ static void mipsxx_exit(void)
 	int counters = op_model_mipsxx_ops.num_counters;
 
 	counters = counters_per_cpu_to_total(counters);
-	on_each_cpu(reset_counters, (void *)counters, 0, 1);
+	on_each_cpu(reset_counters, (void *)(long)counters, 0, 1);
 
 	perf_irq = save_perf_irq;
 }

commit 46684734dd6a55af09c3fe799af7d74cb938684c
Author: Dmitri Vorobiev <dmitri.vorobiev@gmail.com>
Date:   Wed Apr 2 03:58:38 2008 +0400

    [MIPS] unexport null_perf_irq() and make it static
    
    This patch unexports the null_perf_irq() symbol, and simultaneously
    makes this function static.
    
    Signed-off-by: Dmitri Vorobiev <dmitri.vorobiev@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index ca65469d7e30..da8cbb6899dc 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -31,6 +31,8 @@
 
 #define M_COUNTER_OVERFLOW		(1UL      << 31)
 
+static int (*save_perf_irq)(void);
+
 #ifdef CONFIG_MIPS_MT_SMP
 static int cpu_has_mipsmt_pertccounters;
 #define WHAT		(M_TC_EN_VPE | \
@@ -369,6 +371,7 @@ static int __init mipsxx_init(void)
 		return -ENODEV;
 	}
 
+	save_perf_irq = perf_irq;
 	perf_irq = mipsxx_perfcount_handler;
 
 	return 0;
@@ -381,7 +384,7 @@ static void mipsxx_exit(void)
 	counters = counters_per_cpu_to_total(counters);
 	on_each_cpu(reset_counters, (void *)counters, 0, 1);
 
-	perf_irq = null_perf_irq;
+	perf_irq = save_perf_irq;
 }
 
 struct op_mips_model op_model_mipsxx_ops = {

commit 39b8d5254246ac56342b72f812255c8f7a74dca9
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Apr 28 17:14:26 2008 +0100

    [MIPS] Add support for MIPS CMP platform.
    
    Signed-off-by: Chris Dearman <chris@mips.com>
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index ccbea229a0e6..ca65469d7e30 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -32,8 +32,11 @@
 #define M_COUNTER_OVERFLOW		(1UL      << 31)
 
 #ifdef CONFIG_MIPS_MT_SMP
-#define WHAT		(M_TC_EN_VPE | M_PERFCTL_VPEID(smp_processor_id()))
-#define vpe_id()	smp_processor_id()
+static int cpu_has_mipsmt_pertccounters;
+#define WHAT		(M_TC_EN_VPE | \
+			 M_PERFCTL_VPEID(cpu_data[smp_processor_id()].vpe_id))
+#define vpe_id()	(cpu_has_mipsmt_pertccounters ? \
+			0 : cpu_data[smp_processor_id()].vpe_id)
 
 /*
  * The number of bits to shift to convert between counters per core and
@@ -243,11 +246,11 @@ static inline int __n_counters(void)
 {
 	if (!(read_c0_config1() & M_CONFIG1_PC))
 		return 0;
-	if (!(r_c0_perfctrl0() & M_PERFCTL_MORE))
+	if (!(read_c0_perfctrl0() & M_PERFCTL_MORE))
 		return 1;
-	if (!(r_c0_perfctrl1() & M_PERFCTL_MORE))
+	if (!(read_c0_perfctrl1() & M_PERFCTL_MORE))
 		return 2;
-	if (!(r_c0_perfctrl2() & M_PERFCTL_MORE))
+	if (!(read_c0_perfctrl2() & M_PERFCTL_MORE))
 		return 3;
 
 	return 4;
@@ -274,8 +277,9 @@ static inline int n_counters(void)
 	return counters;
 }
 
-static inline void reset_counters(int counters)
+static void reset_counters(void *arg)
 {
+	int counters = (int)arg;
 	switch (counters) {
 	case 4:
 		w_c0_perfctrl3(0);
@@ -302,9 +306,12 @@ static int __init mipsxx_init(void)
 		return -ENODEV;
 	}
 
-	reset_counters(counters);
-
-	counters = counters_total_to_per_cpu(counters);
+#ifdef CONFIG_MIPS_MT_SMP
+	cpu_has_mipsmt_pertccounters = read_c0_config7() & (1<<19);
+	if (!cpu_has_mipsmt_pertccounters)
+		counters = counters_total_to_per_cpu(counters);
+#endif
+	on_each_cpu(reset_counters, (void *)counters, 0, 1);
 
 	op_model_mipsxx_ops.num_counters = counters;
 	switch (current_cpu_type()) {
@@ -320,6 +327,13 @@ static int __init mipsxx_init(void)
 		op_model_mipsxx_ops.cpu_type = "mips/25K";
 		break;
 
+	case CPU_1004K:
+#if 0
+		/* FIXME: report as 34K for now */
+		op_model_mipsxx_ops.cpu_type = "mips/1004K";
+		break;
+#endif
+
 	case CPU_34K:
 		op_model_mipsxx_ops.cpu_type = "mips/34K";
 		break;
@@ -365,7 +379,7 @@ static void mipsxx_exit(void)
 	int counters = op_model_mipsxx_ops.num_counters;
 
 	counters = counters_per_cpu_to_total(counters);
-	reset_counters(counters);
+	on_each_cpu(reset_counters, (void *)counters, 0, 1);
 
 	perf_irq = null_perf_irq;
 }

commit 39a51109dd14001185b0cd122ca46cce1d0795bf
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 29 10:14:59 2008 +0000

    [MIPS] Extend performance counter event field.
    
    The latest draft version of the MIPS Architecture Specification extends the
    6 bit event field by adding a directly adjacent 4-bit EventExt field for a
    total of 10 bits.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index bdfa07aecd97..ccbea229a0e6 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -19,7 +19,7 @@
 #define M_PERFCTL_SUPERVISOR		(1UL      <<  2)
 #define M_PERFCTL_USER			(1UL      <<  3)
 #define M_PERFCTL_INTERRUPT_ENABLE	(1UL      <<  4)
-#define M_PERFCTL_EVENT(event)		(((event) & 0x3f)  << 5)
+#define M_PERFCTL_EVENT(event)		(((event) & 0x3ff)  << 5)
 #define M_PERFCTL_VPEID(vpe)		((vpe)    << 16)
 #define M_PERFCTL_MT_EN(filter)		((filter) << 20)
 #define    M_TC_EN_ALL			M_PERFCTL_MT_EN(0)

commit 5e2862eb5a263a0339a85545d96fb20995d67b1f
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Dec 6 09:12:28 2007 +0000

    [MIPS] Oprofile: Fix computation of number of counters.
    
    VSMP kernels will split the available performance counters between the two
    processors / cores.  But don't do this when we're not on a VSMP system ...
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 423bc2c473df..bdfa07aecd97 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -6,6 +6,7 @@
  * Copyright (C) 2004, 05, 06 by Ralf Baechle
  * Copyright (C) 2005 by MIPS Technologies, Inc.
  */
+#include <linux/cpumask.h>
 #include <linux/oprofile.h>
 #include <linux/interrupt.h>
 #include <linux/smp.h>
@@ -33,11 +34,45 @@
 #ifdef CONFIG_MIPS_MT_SMP
 #define WHAT		(M_TC_EN_VPE | M_PERFCTL_VPEID(smp_processor_id()))
 #define vpe_id()	smp_processor_id()
+
+/*
+ * The number of bits to shift to convert between counters per core and
+ * counters per VPE.  There is no reasonable interface atm to obtain the
+ * number of VPEs used by Linux and in the 34K this number is fixed to two
+ * anyways so we hardcore a few things here for the moment.  The way it's
+ * done here will ensure that oprofile VSMP kernel will run right on a lesser
+ * core like a 24K also or with maxcpus=1.
+ */
+static inline unsigned int vpe_shift(void)
+{
+	if (num_possible_cpus() > 1)
+		return 1;
+
+	return 0;
+}
+
 #else
+
 #define WHAT		0
 #define vpe_id()	0
+
+static inline unsigned int vpe_shift(void)
+{
+	return 0;
+}
+
 #endif
 
+static inline unsigned int counters_total_to_per_cpu(unsigned int counters)
+{
+	return counters >> vpe_shift();
+}
+
+static inline unsigned int counters_per_cpu_to_total(unsigned int counters)
+{
+	return counters << vpe_shift();
+}
+
 #define __define_perf_accessors(r, n, np)				\
 									\
 static inline unsigned int r_c0_ ## r ## n(void)			\
@@ -269,9 +304,7 @@ static int __init mipsxx_init(void)
 
 	reset_counters(counters);
 
-#ifdef CONFIG_MIPS_MT_SMP
-	counters >>= 1;
-#endif
+	counters = counters_total_to_per_cpu(counters);
 
 	op_model_mipsxx_ops.num_counters = counters;
 	switch (current_cpu_type()) {
@@ -330,9 +363,8 @@ static int __init mipsxx_init(void)
 static void mipsxx_exit(void)
 {
 	int counters = op_model_mipsxx_ops.num_counters;
-#ifdef CONFIG_MIPS_MT_SMP
-	counters <<= 1;
-#endif
+
+	counters = counters_per_cpu_to_total(counters);
 	reset_counters(counters);
 
 	perf_irq = null_perf_irq;

commit 49a89efbbbcc178a39555c43bd59a7593c429664
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Oct 11 23:46:15 2007 +0100

    [MIPS] Fix "no space between function name and open parenthesis" warnings.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 6383000422ab..423bc2c473df 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -118,7 +118,7 @@ static void mipsxx_reg_setup(struct op_counter_config *ctr)
 
 /* Program all of the registers in preparation for enabling profiling.  */
 
-static void mipsxx_cpu_setup (void *args)
+static void mipsxx_cpu_setup(void *args)
 {
 	unsigned int counters = op_model_mipsxx_ops.num_counters;
 

commit 10cc3529072d5415fb040018a8a99aa7a60190b6
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Oct 11 23:46:15 2007 +0100

    [MIPS] Allow hardwiring of the CPU type to a single type for optimization.
    
    This saves a few k on systems which only ever ship with a single CPU type.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 1ea5c9c1010b..6383000422ab 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -222,7 +222,7 @@ static inline int n_counters(void)
 {
 	int counters;
 
-	switch (current_cpu_data.cputype) {
+	switch (current_cpu_type()) {
 	case CPU_R10000:
 		counters = 2;
 		break;
@@ -274,7 +274,7 @@ static int __init mipsxx_init(void)
 #endif
 
 	op_model_mipsxx_ops.num_counters = counters;
-	switch (current_cpu_data.cputype) {
+	switch (current_cpu_type()) {
 	case CPU_20KC:
 		op_model_mipsxx_ops.cpu_type = "mips/20K";
 		break;

commit ffe9ee4709cf513fb80e9b7e04d214dd8b76a10d
Author: Chris Dearman <chris@mips.com>
Date:   Thu May 24 22:24:20 2007 +0100

    [MIPS] Separate performance counter interrupts
    
    Support for performance counter overflow interrupt that is on a separate
    interrupt from the timer.
    
    Signed-off-by: Chris Dearman <chris@mips.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 4f94fa261aae..1ea5c9c1010b 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -177,7 +177,10 @@ static int mipsxx_perfcount_handler(void)
 	unsigned int counters = op_model_mipsxx_ops.num_counters;
 	unsigned int control;
 	unsigned int counter;
-	int handled = 0;
+	int handled = IRQ_NONE;
+
+	if (cpu_has_mips_r2 && !(read_c0_cause() & (1 << 26)))
+		return handled;
 
 	switch (counters) {
 #define HANDLE_COUNTER(n)						\
@@ -188,7 +191,7 @@ static int mipsxx_perfcount_handler(void)
 		    (counter & M_COUNTER_OVERFLOW)) {			\
 			oprofile_add_sample(get_irq_regs(), n);		\
 			w_c0_perfcntr ## n(reg.counter[n]);		\
-			handled = 1;					\
+			handled = IRQ_HANDLED;				\
 		}
 	HANDLE_COUNTER(3)
 	HANDLE_COUNTER(2)

commit 6f4c5bdef2943d9ec074be32c437ca897016aaad
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Apr 24 21:42:20 2007 +0100

    [MIPS] Fix oprofile logic to physical counter remapping
    
    This did cause oprofile to fail on non-multithreaded systems with more
    than 2 processors such as the BCM1480.
    
    Reported by Manish Lachwani (mlachwani@mvista.com).
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 69a8bcfe72b2..4f94fa261aae 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -35,7 +35,7 @@
 #define vpe_id()	smp_processor_id()
 #else
 #define WHAT		0
-#define vpe_id()	smp_processor_id()
+#define vpe_id()	0
 #endif
 
 #define __define_perf_accessors(r, n, np)				\

commit 795a22583ba11deb82d57dd70632c7ac390bb8c8
Author: Chris Dearman <chris@mips.com>
Date:   Thu Mar 1 17:58:24 2007 +0000

    [MIPS] Oprofile: Reset all performance registers for MIPS_MT_SMP configs
    
    Signed-off-by: Chris Dearman <chris@mips.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 9d08608aaa51..69a8bcfe72b2 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -74,13 +74,13 @@ static inline void w_c0_ ## r ## n(unsigned int value)			\
 
 __define_perf_accessors(perfcntr, 0, 2)
 __define_perf_accessors(perfcntr, 1, 3)
-__define_perf_accessors(perfcntr, 2, 2)
-__define_perf_accessors(perfcntr, 3, 2)
+__define_perf_accessors(perfcntr, 2, 0)
+__define_perf_accessors(perfcntr, 3, 1)
 
 __define_perf_accessors(perfctrl, 0, 2)
 __define_perf_accessors(perfctrl, 1, 3)
-__define_perf_accessors(perfctrl, 2, 2)
-__define_perf_accessors(perfctrl, 3, 2)
+__define_perf_accessors(perfctrl, 2, 0)
+__define_perf_accessors(perfctrl, 3, 1)
 
 struct op_mips_model op_model_mipsxx_ops;
 
@@ -97,7 +97,6 @@ static void mipsxx_reg_setup(struct op_counter_config *ctr)
 	int i;
 
 	/* Compute the performance counter control word.  */
-	/* For now count kernel and user mode */
 	for (i = 0; i < counters; i++) {
 		reg.control[i] = 0;
 		reg.counter[i] = 0;
@@ -234,9 +233,6 @@ static inline int n_counters(void)
 		counters = __n_counters();
 	}
 
-#ifdef CONFIG_MIPS_MT_SMP
-	counters >> 1;
-#endif
 	return counters;
 }
 
@@ -270,6 +266,10 @@ static int __init mipsxx_init(void)
 
 	reset_counters(counters);
 
+#ifdef CONFIG_MIPS_MT_SMP
+	counters >>= 1;
+#endif
+
 	op_model_mipsxx_ops.num_counters = counters;
 	switch (current_cpu_data.cputype) {
 	case CPU_20KC:
@@ -326,7 +326,11 @@ static int __init mipsxx_init(void)
 
 static void mipsxx_exit(void)
 {
-	reset_counters(op_model_mipsxx_ops.num_counters);
+	int counters = op_model_mipsxx_ops.num_counters;
+#ifdef CONFIG_MIPS_MT_SMP
+	counters <<= 1;
+#endif
+	reset_counters(counters);
 
 	perf_irq = null_perf_irq;
 }

commit 148171b2ac1fb6a1a9f987f8daedc146c810a8ae
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Feb 28 15:34:22 2007 +0000

    [MIPS] Oprofile: Add missing break statements.
    
    This was causing oprofile to fail on R10000, R12000, R14000.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 455d76ad06d8..9d08608aaa51 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -223,10 +223,12 @@ static inline int n_counters(void)
 	switch (current_cpu_data.cputype) {
 	case CPU_R10000:
 		counters = 2;
+		break;
 
 	case CPU_R12000:
 	case CPU_R14000:
 		counters = 4;
+		break;
 
 	default:
 		counters = __n_counters();

commit 714cfe7865e5182a3b25be6a95c0b17aa8e64aa9
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Oct 23 00:44:02 2006 +0100

    [MIPS] Oprofile: kernel support for the R10000.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 1fb240c57bac..455d76ad06d8 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -18,7 +18,7 @@
 #define M_PERFCTL_SUPERVISOR		(1UL      <<  2)
 #define M_PERFCTL_USER			(1UL      <<  3)
 #define M_PERFCTL_INTERRUPT_ENABLE	(1UL      <<  4)
-#define M_PERFCTL_EVENT(event)		((event)  << 5)
+#define M_PERFCTL_EVENT(event)		(((event) & 0x3f)  << 5)
 #define M_PERFCTL_VPEID(vpe)		((vpe)    << 16)
 #define M_PERFCTL_MT_EN(filter)		((filter) << 20)
 #define    M_TC_EN_ALL			M_PERFCTL_MT_EN(0)
@@ -218,13 +218,23 @@ static inline int __n_counters(void)
 
 static inline int n_counters(void)
 {
-	int counters = __n_counters();
+	int counters;
+
+	switch (current_cpu_data.cputype) {
+	case CPU_R10000:
+		counters = 2;
+
+	case CPU_R12000:
+	case CPU_R14000:
+		counters = 4;
+
+	default:
+		counters = __n_counters();
+	}
 
 #ifdef CONFIG_MIPS_MT_SMP
-	if (current_cpu_data.cputype == CPU_34K)
-		return counters >> 1;
+	counters >> 1;
 #endif
-
 	return counters;
 }
 
@@ -284,6 +294,18 @@ static int __init mipsxx_init(void)
 		op_model_mipsxx_ops.cpu_type = "mips/5K";
 		break;
 
+	case CPU_R10000:
+		if ((current_cpu_data.processor_id & 0xff) == 0x20)
+			op_model_mipsxx_ops.cpu_type = "mips/r10000-v2.x";
+		else
+			op_model_mipsxx_ops.cpu_type = "mips/r10000";
+		break;
+
+	case CPU_R12000:
+	case CPU_R14000:
+		op_model_mipsxx_ops.cpu_type = "mips/r12000";
+		break;
+
 	case CPU_SB1:
 	case CPU_SB1A:
 		op_model_mipsxx_ops.cpu_type = "mips/sb1";

commit ea3df4ac7d4adad915e2d0431a9407b10617114c
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Oct 23 23:21:21 2006 +0100

    [MIPS] Oprofile: Fix MIPSxx counter number detection.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index ebce715f076d..1fb240c57bac 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -220,7 +220,7 @@ static inline int n_counters(void)
 {
 	int counters = __n_counters();
 
-#ifndef CONFIG_SMP
+#ifdef CONFIG_MIPS_MT_SMP
 	if (current_cpu_data.cputype == CPU_34K)
 		return counters >> 1;
 #endif

commit be609f3546d3dd96afd7df8856a91fa2b8825fbc
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Oct 23 13:22:06 2006 +0100

    [MIPS] Oprofile: fix on non-VSMP / non-SMTC SMP configurations.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index dd0aec9c3ce1..ebce715f076d 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -31,16 +31,18 @@
 #define M_COUNTER_OVERFLOW		(1UL      << 31)
 
 #ifdef CONFIG_MIPS_MT_SMP
-#define WHAT	(M_TC_EN_VPE | M_PERFCTL_VPEID(smp_processor_id()))
+#define WHAT		(M_TC_EN_VPE | M_PERFCTL_VPEID(smp_processor_id()))
+#define vpe_id()	smp_processor_id()
 #else
-#define WHAT	0
+#define WHAT		0
+#define vpe_id()	smp_processor_id()
 #endif
 
 #define __define_perf_accessors(r, n, np)				\
 									\
 static inline unsigned int r_c0_ ## r ## n(void)			\
 {									\
-	unsigned int cpu = smp_processor_id();				\
+	unsigned int cpu = vpe_id();					\
 									\
 	switch (cpu) {							\
 	case 0:								\
@@ -55,7 +57,7 @@ static inline unsigned int r_c0_ ## r ## n(void)			\
 									\
 static inline void w_c0_ ## r ## n(unsigned int value)			\
 {									\
-	unsigned int cpu = smp_processor_id();				\
+	unsigned int cpu = vpe_id();					\
 									\
 	switch (cpu) {							\
 	case 0:								\

commit 937a801576f954bd030d7c4a5a94571710d87c0b
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Oct 7 19:44:33 2006 +0100

    [MIPS] Complete fixes after removal of pt_regs argument to int handlers.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index a175d673540f..dd0aec9c3ce1 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -3,12 +3,13 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2004, 2005 by Ralf Baechle
+ * Copyright (C) 2004, 05, 06 by Ralf Baechle
  * Copyright (C) 2005 by MIPS Technologies, Inc.
  */
 #include <linux/oprofile.h>
 #include <linux/interrupt.h>
 #include <linux/smp.h>
+#include <asm/irq_regs.h>
 
 #include "op_impl.h"
 
@@ -170,7 +171,7 @@ static void mipsxx_cpu_stop(void *args)
 	}
 }
 
-static int mipsxx_perfcount_handler(struct pt_regs *regs)
+static int mipsxx_perfcount_handler(void)
 {
 	unsigned int counters = op_model_mipsxx_ops.num_counters;
 	unsigned int control;
@@ -184,7 +185,7 @@ static int mipsxx_perfcount_handler(struct pt_regs *regs)
 		counter = r_c0_perfcntr ## n();				\
 		if ((control & M_PERFCTL_INTERRUPT_ENABLE) &&		\
 		    (counter & M_COUNTER_OVERFLOW)) {			\
-			oprofile_add_sample(regs, n);			\
+			oprofile_add_sample(get_irq_regs(), n);		\
 			w_c0_perfcntr ## n(reg.counter[n]);		\
 			handled = 1;					\
 		}

commit 30f244aed36f569c2e3ea6e8457bf66adaf98a3d
Author: Thiemo Seufer <ths@networkno.de>
Date:   Fri Jul 7 10:38:51 2006 +0100

    [MIPS] Oprofile: Fix build failure due to warning and -Werror.
    
    Signed-off-by: Thiemo Seufer <ths@networkno.de>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index a09c5f901233..a175d673540f 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -49,6 +49,7 @@ static inline unsigned int r_c0_ ## r ## n(void)			\
 	default:							\
 		BUG();							\
 	}								\
+	return 0;							\
 }									\
 									\
 static inline void w_c0_ ## r ## n(unsigned int value)			\
@@ -65,6 +66,7 @@ static inline void w_c0_ ## r ## n(unsigned int value)			\
 	default:							\
 		BUG();							\
 	}								\
+	return;								\
 }									\
 
 __define_perf_accessors(perfcntr, 0, 2)

commit 92c7b62fd1a6898fbfaf1db790ba4e70e90f39d2
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Jun 23 18:39:00 2006 +0100

    [MIPS] Oprofile: Support VSMP on 34K.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index f26a00e13204..a09c5f901233 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -12,16 +12,70 @@
 
 #include "op_impl.h"
 
-#define M_PERFCTL_EXL			(1UL    <<  0)
-#define M_PERFCTL_KERNEL		(1UL    <<  1)
-#define M_PERFCTL_SUPERVISOR		(1UL    <<  2)
-#define M_PERFCTL_USER			(1UL    <<  3)
-#define M_PERFCTL_INTERRUPT_ENABLE	(1UL    <<  4)
-#define M_PERFCTL_EVENT(event)		((event) << 5)
-#define M_PERFCTL_WIDE			(1UL    << 30)
-#define M_PERFCTL_MORE			(1UL    << 31)
+#define M_PERFCTL_EXL			(1UL      <<  0)
+#define M_PERFCTL_KERNEL		(1UL      <<  1)
+#define M_PERFCTL_SUPERVISOR		(1UL      <<  2)
+#define M_PERFCTL_USER			(1UL      <<  3)
+#define M_PERFCTL_INTERRUPT_ENABLE	(1UL      <<  4)
+#define M_PERFCTL_EVENT(event)		((event)  << 5)
+#define M_PERFCTL_VPEID(vpe)		((vpe)    << 16)
+#define M_PERFCTL_MT_EN(filter)		((filter) << 20)
+#define    M_TC_EN_ALL			M_PERFCTL_MT_EN(0)
+#define    M_TC_EN_VPE			M_PERFCTL_MT_EN(1)
+#define    M_TC_EN_TC			M_PERFCTL_MT_EN(2)
+#define M_PERFCTL_TCID(tcid)		((tcid)   << 22)
+#define M_PERFCTL_WIDE			(1UL      << 30)
+#define M_PERFCTL_MORE			(1UL      << 31)
+
+#define M_COUNTER_OVERFLOW		(1UL      << 31)
+
+#ifdef CONFIG_MIPS_MT_SMP
+#define WHAT	(M_TC_EN_VPE | M_PERFCTL_VPEID(smp_processor_id()))
+#else
+#define WHAT	0
+#endif
 
-#define M_COUNTER_OVERFLOW		(1UL    << 31)
+#define __define_perf_accessors(r, n, np)				\
+									\
+static inline unsigned int r_c0_ ## r ## n(void)			\
+{									\
+	unsigned int cpu = smp_processor_id();				\
+									\
+	switch (cpu) {							\
+	case 0:								\
+		return read_c0_ ## r ## n();				\
+	case 1:								\
+		return read_c0_ ## r ## np();				\
+	default:							\
+		BUG();							\
+	}								\
+}									\
+									\
+static inline void w_c0_ ## r ## n(unsigned int value)			\
+{									\
+	unsigned int cpu = smp_processor_id();				\
+									\
+	switch (cpu) {							\
+	case 0:								\
+		write_c0_ ## r ## n(value);				\
+		return;							\
+	case 1:								\
+		write_c0_ ## r ## np(value);				\
+		return;							\
+	default:							\
+		BUG();							\
+	}								\
+}									\
+
+__define_perf_accessors(perfcntr, 0, 2)
+__define_perf_accessors(perfcntr, 1, 3)
+__define_perf_accessors(perfcntr, 2, 2)
+__define_perf_accessors(perfcntr, 3, 2)
+
+__define_perf_accessors(perfctrl, 0, 2)
+__define_perf_accessors(perfctrl, 1, 3)
+__define_perf_accessors(perfctrl, 2, 2)
+__define_perf_accessors(perfctrl, 3, 2)
 
 struct op_mips_model op_model_mipsxx_ops;
 
@@ -66,17 +120,17 @@ static void mipsxx_cpu_setup (void *args)
 
 	switch (counters) {
 	case 4:
-		write_c0_perfctrl3(0);
-		write_c0_perfcntr3(reg.counter[3]);
+		w_c0_perfctrl3(0);
+		w_c0_perfcntr3(reg.counter[3]);
 	case 3:
-		write_c0_perfctrl2(0);
-		write_c0_perfcntr2(reg.counter[2]);
+		w_c0_perfctrl2(0);
+		w_c0_perfcntr2(reg.counter[2]);
 	case 2:
-		write_c0_perfctrl1(0);
-		write_c0_perfcntr1(reg.counter[1]);
+		w_c0_perfctrl1(0);
+		w_c0_perfcntr1(reg.counter[1]);
 	case 1:
-		write_c0_perfctrl0(0);
-		write_c0_perfcntr0(reg.counter[0]);
+		w_c0_perfctrl0(0);
+		w_c0_perfcntr0(reg.counter[0]);
 	}
 }
 
@@ -87,13 +141,13 @@ static void mipsxx_cpu_start(void *args)
 
 	switch (counters) {
 	case 4:
-		write_c0_perfctrl3(reg.control[3]);
+		w_c0_perfctrl3(WHAT | reg.control[3]);
 	case 3:
-		write_c0_perfctrl2(reg.control[2]);
+		w_c0_perfctrl2(WHAT | reg.control[2]);
 	case 2:
-		write_c0_perfctrl1(reg.control[1]);
+		w_c0_perfctrl1(WHAT | reg.control[1]);
 	case 1:
-		write_c0_perfctrl0(reg.control[0]);
+		w_c0_perfctrl0(WHAT | reg.control[0]);
 	}
 }
 
@@ -104,13 +158,13 @@ static void mipsxx_cpu_stop(void *args)
 
 	switch (counters) {
 	case 4:
-		write_c0_perfctrl3(0);
+		w_c0_perfctrl3(0);
 	case 3:
-		write_c0_perfctrl2(0);
+		w_c0_perfctrl2(0);
 	case 2:
-		write_c0_perfctrl1(0);
+		w_c0_perfctrl1(0);
 	case 1:
-		write_c0_perfctrl0(0);
+		w_c0_perfctrl0(0);
 	}
 }
 
@@ -124,12 +178,12 @@ static int mipsxx_perfcount_handler(struct pt_regs *regs)
 	switch (counters) {
 #define HANDLE_COUNTER(n)						\
 	case n + 1:							\
-		control = read_c0_perfctrl ## n();			\
-		counter = read_c0_perfcntr ## n();			\
+		control = r_c0_perfctrl ## n();				\
+		counter = r_c0_perfcntr ## n();				\
 		if ((control & M_PERFCTL_INTERRUPT_ENABLE) &&		\
 		    (counter & M_COUNTER_OVERFLOW)) {			\
 			oprofile_add_sample(regs, n);			\
-			write_c0_perfcntr ## n(reg.counter[n]);		\
+			w_c0_perfcntr ## n(reg.counter[n]);		\
 			handled = 1;					\
 		}
 	HANDLE_COUNTER(3)
@@ -143,35 +197,47 @@ static int mipsxx_perfcount_handler(struct pt_regs *regs)
 
 #define M_CONFIG1_PC	(1 << 4)
 
-static inline int n_counters(void)
+static inline int __n_counters(void)
 {
 	if (!(read_c0_config1() & M_CONFIG1_PC))
 		return 0;
-	if (!(read_c0_perfctrl0() & M_PERFCTL_MORE))
+	if (!(r_c0_perfctrl0() & M_PERFCTL_MORE))
 		return 1;
-	if (!(read_c0_perfctrl1() & M_PERFCTL_MORE))
+	if (!(r_c0_perfctrl1() & M_PERFCTL_MORE))
 		return 2;
-	if (!(read_c0_perfctrl2() & M_PERFCTL_MORE))
+	if (!(r_c0_perfctrl2() & M_PERFCTL_MORE))
 		return 3;
 
 	return 4;
 }
 
+static inline int n_counters(void)
+{
+	int counters = __n_counters();
+
+#ifndef CONFIG_SMP
+	if (current_cpu_data.cputype == CPU_34K)
+		return counters >> 1;
+#endif
+
+	return counters;
+}
+
 static inline void reset_counters(int counters)
 {
 	switch (counters) {
 	case 4:
-		write_c0_perfctrl3(0);
-		write_c0_perfcntr3(0);
+		w_c0_perfctrl3(0);
+		w_c0_perfcntr3(0);
 	case 3:
-		write_c0_perfctrl2(0);
-		write_c0_perfcntr2(0);
+		w_c0_perfctrl2(0);
+		w_c0_perfcntr2(0);
 	case 2:
-		write_c0_perfctrl1(0);
-		write_c0_perfcntr1(0);
+		w_c0_perfctrl1(0);
+		w_c0_perfcntr1(0);
 	case 1:
-		write_c0_perfctrl0(0);
-		write_c0_perfcntr0(0);
+		w_c0_perfctrl0(0);
+		w_c0_perfcntr0(0);
 	}
 }
 
@@ -201,7 +267,6 @@ static int __init mipsxx_init(void)
 		op_model_mipsxx_ops.cpu_type = "mips/25K";
 		break;
 
-#ifndef CONFIG_SMP
 	case CPU_34K:
 		op_model_mipsxx_ops.cpu_type = "mips/34K";
 		break;
@@ -209,7 +274,6 @@ static int __init mipsxx_init(void)
 	case CPU_74K:
 		op_model_mipsxx_ops.cpu_type = "mips/74K";
 		break;
-#endif
 
 	case CPU_5KC:
 		op_model_mipsxx_ops.cpu_type = "mips/5K";

commit 1acf1ca7e906cf7453d76d76a6c953996295c220
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Tue May 23 16:42:38 2006 +0900

    [MIPS] Fix modpost warning: Rename op_model_xxx to op_model_xxx_ops.
    
    The modpost uses a whitelist for commonly used suffix on checking the
    section mismatch.  Adding "_ops" suffix to op_modex_xxx get rid of
    this modpost warning.
    
    WARNING: arch/mips/oprofile/oprofile.o - Section mismatch: reference to .init.text: from .data after 'op_model_mipsxx' (at offset 0x528)
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index e7ce92391303..f26a00e13204 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -23,7 +23,7 @@
 
 #define M_COUNTER_OVERFLOW		(1UL    << 31)
 
-struct op_mips_model op_model_mipsxx;
+struct op_mips_model op_model_mipsxx_ops;
 
 static struct mipsxx_register_config {
 	unsigned int control[4];
@@ -34,7 +34,7 @@ static struct mipsxx_register_config {
 
 static void mipsxx_reg_setup(struct op_counter_config *ctr)
 {
-	unsigned int counters = op_model_mipsxx.num_counters;
+	unsigned int counters = op_model_mipsxx_ops.num_counters;
 	int i;
 
 	/* Compute the performance counter control word.  */
@@ -62,7 +62,7 @@ static void mipsxx_reg_setup(struct op_counter_config *ctr)
 
 static void mipsxx_cpu_setup (void *args)
 {
-	unsigned int counters = op_model_mipsxx.num_counters;
+	unsigned int counters = op_model_mipsxx_ops.num_counters;
 
 	switch (counters) {
 	case 4:
@@ -83,7 +83,7 @@ static void mipsxx_cpu_setup (void *args)
 /* Start all counters on current CPU */
 static void mipsxx_cpu_start(void *args)
 {
-	unsigned int counters = op_model_mipsxx.num_counters;
+	unsigned int counters = op_model_mipsxx_ops.num_counters;
 
 	switch (counters) {
 	case 4:
@@ -100,7 +100,7 @@ static void mipsxx_cpu_start(void *args)
 /* Stop all counters on current CPU */
 static void mipsxx_cpu_stop(void *args)
 {
-	unsigned int counters = op_model_mipsxx.num_counters;
+	unsigned int counters = op_model_mipsxx_ops.num_counters;
 
 	switch (counters) {
 	case 4:
@@ -116,7 +116,7 @@ static void mipsxx_cpu_stop(void *args)
 
 static int mipsxx_perfcount_handler(struct pt_regs *regs)
 {
-	unsigned int counters = op_model_mipsxx.num_counters;
+	unsigned int counters = op_model_mipsxx_ops.num_counters;
 	unsigned int control;
 	unsigned int counter;
 	int handled = 0;
@@ -187,37 +187,37 @@ static int __init mipsxx_init(void)
 
 	reset_counters(counters);
 
-	op_model_mipsxx.num_counters = counters;
+	op_model_mipsxx_ops.num_counters = counters;
 	switch (current_cpu_data.cputype) {
 	case CPU_20KC:
-		op_model_mipsxx.cpu_type = "mips/20K";
+		op_model_mipsxx_ops.cpu_type = "mips/20K";
 		break;
 
 	case CPU_24K:
-		op_model_mipsxx.cpu_type = "mips/24K";
+		op_model_mipsxx_ops.cpu_type = "mips/24K";
 		break;
 
 	case CPU_25KF:
-		op_model_mipsxx.cpu_type = "mips/25K";
+		op_model_mipsxx_ops.cpu_type = "mips/25K";
 		break;
 
 #ifndef CONFIG_SMP
 	case CPU_34K:
-		op_model_mipsxx.cpu_type = "mips/34K";
+		op_model_mipsxx_ops.cpu_type = "mips/34K";
 		break;
 
 	case CPU_74K:
-		op_model_mipsxx.cpu_type = "mips/74K";
+		op_model_mipsxx_ops.cpu_type = "mips/74K";
 		break;
 #endif
 
 	case CPU_5KC:
-		op_model_mipsxx.cpu_type = "mips/5K";
+		op_model_mipsxx_ops.cpu_type = "mips/5K";
 		break;
 
 	case CPU_SB1:
 	case CPU_SB1A:
-		op_model_mipsxx.cpu_type = "mips/sb1";
+		op_model_mipsxx_ops.cpu_type = "mips/sb1";
 		break;
 
 	default:
@@ -233,12 +233,12 @@ static int __init mipsxx_init(void)
 
 static void mipsxx_exit(void)
 {
-	reset_counters(op_model_mipsxx.num_counters);
+	reset_counters(op_model_mipsxx_ops.num_counters);
 
 	perf_irq = null_perf_irq;
 }
 
-struct op_mips_model op_model_mipsxx = {
+struct op_mips_model op_model_mipsxx_ops = {
 	.reg_setup	= mipsxx_reg_setup,
 	.cpu_setup	= mipsxx_cpu_setup,
 	.init		= mipsxx_init,

commit c620953c32d301c2a7bc73f9f780301e110b7d7c
Author: Chris Dearman <chris@mips.com>
Date:   Tue May 2 14:08:46 2006 +0100

    [MIPS] Fix detection and handling of the 74K processor.
    
    Nothing exciting; Linux just didn't know it yet so this is most adding
    a value to a case statement.
    
    Signed-off-by: Chris Dearman <chris@mips.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 95d488ca0754..e7ce92391303 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -205,6 +205,10 @@ static int __init mipsxx_init(void)
 	case CPU_34K:
 		op_model_mipsxx.cpu_type = "mips/34K";
 		break;
+
+	case CPU_74K:
+		op_model_mipsxx.cpu_type = "mips/74K";
+		break;
 #endif
 
 	case CPU_5KC:

commit fcfd980c833bd5ca1df9ca877b3e968e4da05b24
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Feb 1 17:54:30 2006 +0000

    [MIPS] Oprofile: Support for 34K UP kernels.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index dd6d189dccf8..95d488ca0754 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -201,6 +201,12 @@ static int __init mipsxx_init(void)
 		op_model_mipsxx.cpu_type = "mips/25K";
 		break;
 
+#ifndef CONFIG_SMP
+	case CPU_34K:
+		op_model_mipsxx.cpu_type = "mips/34K";
+		break;
+#endif
+
 	case CPU_5KC:
 		op_model_mipsxx.cpu_type = "mips/5K";
 		break;

commit c03bc121212ecb36120b118a94c1b91a2e07b7b2
Author: Mark Mason <mason@broadcom.com>
Date:   Tue Jan 17 12:06:32 2006 -0800

    [MIPS] SB1: Add oprofile support.
    
    Signed-off-by: Mark Mason <mason@broadcom.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 1d1eee407faf..dd6d189dccf8 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -205,6 +205,11 @@ static int __init mipsxx_init(void)
 		op_model_mipsxx.cpu_type = "mips/5K";
 		break;
 
+	case CPU_SB1:
+	case CPU_SB1A:
+		op_model_mipsxx.cpu_type = "mips/sb1";
+		break;
+
 	default:
 		printk(KERN_ERR "Profiling unsupported for this CPU\n");
 

commit 2065988e9fb1628de7958b0f7f709b93302f7b97
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Dec 9 12:42:13 2005 +0000

    MIPS: Oprofile: Add 5K, 20K and 25K support.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index d97bbff031e5..1d1eee407faf 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -189,10 +189,22 @@ static int __init mipsxx_init(void)
 
 	op_model_mipsxx.num_counters = counters;
 	switch (current_cpu_data.cputype) {
+	case CPU_20KC:
+		op_model_mipsxx.cpu_type = "mips/20K";
+		break;
+
 	case CPU_24K:
 		op_model_mipsxx.cpu_type = "mips/24K";
 		break;
 
+	case CPU_25KF:
+		op_model_mipsxx.cpu_type = "mips/25K";
+		break;
+
+	case CPU_5KC:
+		op_model_mipsxx.cpu_type = "mips/5K";
+		break;
+
 	default:
 		printk(KERN_ERR "Profiling unsupported for this CPU\n");
 

commit 9efeae9a5cae7e7bdacff666a1d689f5b2901c64
Author: Ralf Baechle <ralf@ongar.mips.com>
Date:   Fri Dec 9 12:34:45 2005 +0000

    MIPS: Oprofile: Print error message if the CPU happen to have no counters.
    
    Signed-off-by: Ralf Baechle <ralf@ongar.mips.com>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index a4a4aa99ab03..d97bbff031e5 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -180,8 +180,10 @@ static int __init mipsxx_init(void)
 	int counters;
 
 	counters = n_counters();
-	if (counters == 0)
+	if (counters == 0) {
+		printk(KERN_ERR "Oprofile: CPU has no performance counters\n");
 		return -ENODEV;
+	}
 
 	reset_counters(counters);
 

commit ba339c03e2e8ede8ccd37ed6c4e564e3b1545495
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Dec 9 12:29:38 2005 +0000

    MIPS: Oprofile: Fixup the loose ends in the plumbing.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index d36b64dfcb2f..a4a4aa99ab03 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -114,11 +114,12 @@ static void mipsxx_cpu_stop(void *args)
 	}
 }
 
-static void mipsxx_perfcount_handler(struct pt_regs *regs)
+static int mipsxx_perfcount_handler(struct pt_regs *regs)
 {
 	unsigned int counters = op_model_mipsxx.num_counters;
 	unsigned int control;
 	unsigned int counter;
+	int handled = 0;
 
 	switch (counters) {
 #define HANDLE_COUNTER(n)						\
@@ -129,12 +130,15 @@ static void mipsxx_perfcount_handler(struct pt_regs *regs)
 		    (counter & M_COUNTER_OVERFLOW)) {			\
 			oprofile_add_sample(regs, n);			\
 			write_c0_perfcntr ## n(reg.counter[n]);		\
+			handled = 1;					\
 		}
 	HANDLE_COUNTER(3)
 	HANDLE_COUNTER(2)
 	HANDLE_COUNTER(1)
 	HANDLE_COUNTER(0)
 	}
+
+	return handled;
 }
 
 #define M_CONFIG1_PC	(1 << 4)

commit 54176736f734ca3a1f27416d8e5804981a627076
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Feb 7 02:54:29 2005 +0000

    More oprofile bits for MIPS32-style performance counters.  The code to
    bolt this into the actual hardware interrupt is yet missing from this
    commit.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    
     FEXPORT(ret_from_fork)

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
new file mode 100644
index 000000000000..d36b64dfcb2f
--- /dev/null
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -0,0 +1,215 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004, 2005 by Ralf Baechle
+ * Copyright (C) 2005 by MIPS Technologies, Inc.
+ */
+#include <linux/oprofile.h>
+#include <linux/interrupt.h>
+#include <linux/smp.h>
+
+#include "op_impl.h"
+
+#define M_PERFCTL_EXL			(1UL    <<  0)
+#define M_PERFCTL_KERNEL		(1UL    <<  1)
+#define M_PERFCTL_SUPERVISOR		(1UL    <<  2)
+#define M_PERFCTL_USER			(1UL    <<  3)
+#define M_PERFCTL_INTERRUPT_ENABLE	(1UL    <<  4)
+#define M_PERFCTL_EVENT(event)		((event) << 5)
+#define M_PERFCTL_WIDE			(1UL    << 30)
+#define M_PERFCTL_MORE			(1UL    << 31)
+
+#define M_COUNTER_OVERFLOW		(1UL    << 31)
+
+struct op_mips_model op_model_mipsxx;
+
+static struct mipsxx_register_config {
+	unsigned int control[4];
+	unsigned int counter[4];
+} reg;
+
+/* Compute all of the registers in preparation for enabling profiling.  */
+
+static void mipsxx_reg_setup(struct op_counter_config *ctr)
+{
+	unsigned int counters = op_model_mipsxx.num_counters;
+	int i;
+
+	/* Compute the performance counter control word.  */
+	/* For now count kernel and user mode */
+	for (i = 0; i < counters; i++) {
+		reg.control[i] = 0;
+		reg.counter[i] = 0;
+
+		if (!ctr[i].enabled)
+			continue;
+
+		reg.control[i] = M_PERFCTL_EVENT(ctr[i].event) |
+		                 M_PERFCTL_INTERRUPT_ENABLE;
+		if (ctr[i].kernel)
+			reg.control[i] |= M_PERFCTL_KERNEL;
+		if (ctr[i].user)
+			reg.control[i] |= M_PERFCTL_USER;
+		if (ctr[i].exl)
+			reg.control[i] |= M_PERFCTL_EXL;
+		reg.counter[i] = 0x80000000 - ctr[i].count;
+	}
+}
+
+/* Program all of the registers in preparation for enabling profiling.  */
+
+static void mipsxx_cpu_setup (void *args)
+{
+	unsigned int counters = op_model_mipsxx.num_counters;
+
+	switch (counters) {
+	case 4:
+		write_c0_perfctrl3(0);
+		write_c0_perfcntr3(reg.counter[3]);
+	case 3:
+		write_c0_perfctrl2(0);
+		write_c0_perfcntr2(reg.counter[2]);
+	case 2:
+		write_c0_perfctrl1(0);
+		write_c0_perfcntr1(reg.counter[1]);
+	case 1:
+		write_c0_perfctrl0(0);
+		write_c0_perfcntr0(reg.counter[0]);
+	}
+}
+
+/* Start all counters on current CPU */
+static void mipsxx_cpu_start(void *args)
+{
+	unsigned int counters = op_model_mipsxx.num_counters;
+
+	switch (counters) {
+	case 4:
+		write_c0_perfctrl3(reg.control[3]);
+	case 3:
+		write_c0_perfctrl2(reg.control[2]);
+	case 2:
+		write_c0_perfctrl1(reg.control[1]);
+	case 1:
+		write_c0_perfctrl0(reg.control[0]);
+	}
+}
+
+/* Stop all counters on current CPU */
+static void mipsxx_cpu_stop(void *args)
+{
+	unsigned int counters = op_model_mipsxx.num_counters;
+
+	switch (counters) {
+	case 4:
+		write_c0_perfctrl3(0);
+	case 3:
+		write_c0_perfctrl2(0);
+	case 2:
+		write_c0_perfctrl1(0);
+	case 1:
+		write_c0_perfctrl0(0);
+	}
+}
+
+static void mipsxx_perfcount_handler(struct pt_regs *regs)
+{
+	unsigned int counters = op_model_mipsxx.num_counters;
+	unsigned int control;
+	unsigned int counter;
+
+	switch (counters) {
+#define HANDLE_COUNTER(n)						\
+	case n + 1:							\
+		control = read_c0_perfctrl ## n();			\
+		counter = read_c0_perfcntr ## n();			\
+		if ((control & M_PERFCTL_INTERRUPT_ENABLE) &&		\
+		    (counter & M_COUNTER_OVERFLOW)) {			\
+			oprofile_add_sample(regs, n);			\
+			write_c0_perfcntr ## n(reg.counter[n]);		\
+		}
+	HANDLE_COUNTER(3)
+	HANDLE_COUNTER(2)
+	HANDLE_COUNTER(1)
+	HANDLE_COUNTER(0)
+	}
+}
+
+#define M_CONFIG1_PC	(1 << 4)
+
+static inline int n_counters(void)
+{
+	if (!(read_c0_config1() & M_CONFIG1_PC))
+		return 0;
+	if (!(read_c0_perfctrl0() & M_PERFCTL_MORE))
+		return 1;
+	if (!(read_c0_perfctrl1() & M_PERFCTL_MORE))
+		return 2;
+	if (!(read_c0_perfctrl2() & M_PERFCTL_MORE))
+		return 3;
+
+	return 4;
+}
+
+static inline void reset_counters(int counters)
+{
+	switch (counters) {
+	case 4:
+		write_c0_perfctrl3(0);
+		write_c0_perfcntr3(0);
+	case 3:
+		write_c0_perfctrl2(0);
+		write_c0_perfcntr2(0);
+	case 2:
+		write_c0_perfctrl1(0);
+		write_c0_perfcntr1(0);
+	case 1:
+		write_c0_perfctrl0(0);
+		write_c0_perfcntr0(0);
+	}
+}
+
+static int __init mipsxx_init(void)
+{
+	int counters;
+
+	counters = n_counters();
+	if (counters == 0)
+		return -ENODEV;
+
+	reset_counters(counters);
+
+	op_model_mipsxx.num_counters = counters;
+	switch (current_cpu_data.cputype) {
+	case CPU_24K:
+		op_model_mipsxx.cpu_type = "mips/24K";
+		break;
+
+	default:
+		printk(KERN_ERR "Profiling unsupported for this CPU\n");
+
+		return -ENODEV;
+	}
+
+	perf_irq = mipsxx_perfcount_handler;
+
+	return 0;
+}
+
+static void mipsxx_exit(void)
+{
+	reset_counters(op_model_mipsxx.num_counters);
+
+	perf_irq = null_perf_irq;
+}
+
+struct op_mips_model op_model_mipsxx = {
+	.reg_setup	= mipsxx_reg_setup,
+	.cpu_setup	= mipsxx_cpu_setup,
+	.init		= mipsxx_init,
+	.exit		= mipsxx_exit,
+	.cpu_start	= mipsxx_cpu_start,
+	.cpu_stop	= mipsxx_cpu_stop,
+};
