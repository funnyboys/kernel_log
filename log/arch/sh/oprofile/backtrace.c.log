commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sh/oprofile/backtrace.c b/arch/sh/oprofile/backtrace.c
index 8279a7e91043..f1205f92631d 100644
--- a/arch/sh/oprofile/backtrace.c
+++ b/arch/sh/oprofile/backtrace.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * SH specific backtracing code for oprofile
  *
@@ -7,11 +8,6 @@
  *
  * Based on ARM oprofile backtrace code by Richard Purdie and in turn, i386
  * oprofile backtrace code by John Levon, David Smith
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  */
 #include <linux/oprofile.h>
 #include <linux/sched.h>

commit 96d4f267e40f9509e8a66e2b39e8b95655617693
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 3 18:57:57 2019 -0800

    Remove 'type' argument from access_ok() function
    
    Nobody has actually used the type (VERIFY_READ vs VERIFY_WRITE) argument
    of the user address range verification function since we got rid of the
    old racy i386-only code to walk page tables by hand.
    
    It existed because the original 80386 would not honor the write protect
    bit when in kernel mode, so you had to do COW by hand before doing any
    user access.  But we haven't supported that in a long time, and these
    days the 'type' argument is a purely historical artifact.
    
    A discussion about extending 'user_access_begin()' to do the range
    checking resulted this patch, because there is no way we're going to
    move the old VERIFY_xyz interface to that model.  And it's best done at
    the end of the merge window when I've done most of my merges, so let's
    just get this done once and for all.
    
    This patch was mostly done with a sed-script, with manual fix-ups for
    the cases that weren't of the trivial 'access_ok(VERIFY_xyz' form.
    
    There were a couple of notable cases:
    
     - csky still had the old "verify_area()" name as an alias.
    
     - the iter_iov code had magical hardcoded knowledge of the actual
       values of VERIFY_{READ,WRITE} (not that they mattered, since nothing
       really used it)
    
     - microblaze used the type argument for a debug printout
    
    but other than those oddities this should be a total no-op patch.
    
    I tried to fix up all architectures, did fairly extensive grepping for
    access_ok() uses, and the changes are trivial, but I may have missed
    something.  Any missed conversion should be trivially fixable, though.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/oprofile/backtrace.c b/arch/sh/oprofile/backtrace.c
index c7695f99c8c3..8279a7e91043 100644
--- a/arch/sh/oprofile/backtrace.c
+++ b/arch/sh/oprofile/backtrace.c
@@ -51,7 +51,7 @@ user_backtrace(unsigned long *stackaddr, struct pt_regs *regs)
 	unsigned long buf_stack;
 
 	/* Also check accessibility of address */
-	if (!access_ok(VERIFY_READ, stackaddr, sizeof(unsigned long)))
+	if (!access_ok(stackaddr, sizeof(unsigned long)))
 		return NULL;
 
 	if (__copy_from_user_inatomic(&buf_stack, stackaddr, sizeof(unsigned long)))

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/oprofile/backtrace.c b/arch/sh/oprofile/backtrace.c
index 9c88dcd56e86..c7695f99c8c3 100644
--- a/arch/sh/oprofile/backtrace.c
+++ b/arch/sh/oprofile/backtrace.c
@@ -19,7 +19,7 @@
 #include <linux/mm.h>
 #include <asm/unwinder.h>
 #include <asm/ptrace.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <asm/sections.h>
 #include <asm/stacktrace.h>
 

commit d39e17c7f8f8fb4012618d25ddc4436407b174a6
Author: Richard Weinberger <richard@nod.at>
Date:   Thu May 12 13:11:11 2011 +0000

    sh: remove warning and warning_symbol from struct stacktrace_ops
    
    Both warning and warning_symbol are nowhere used.
    Let's get rid of them.
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/oprofile/backtrace.c b/arch/sh/oprofile/backtrace.c
index 37f3a75ea6cb..9c88dcd56e86 100644
--- a/arch/sh/oprofile/backtrace.c
+++ b/arch/sh/oprofile/backtrace.c
@@ -23,17 +23,6 @@
 #include <asm/sections.h>
 #include <asm/stacktrace.h>
 
-static void backtrace_warning_symbol(void *data, char *msg,
-				     unsigned long symbol)
-{
-	/* Ignore warnings */
-}
-
-static void backtrace_warning(void *data, char *msg)
-{
-	/* Ignore warnings */
-}
-
 static int backtrace_stack(void *data, char *name)
 {
 	/* Yes, we want all stacks */
@@ -49,8 +38,6 @@ static void backtrace_address(void *data, unsigned long addr, int reliable)
 }
 
 static struct stacktrace_ops backtrace_ops = {
-	.warning = backtrace_warning,
-	.warning_symbol = backtrace_warning_symbol,
 	.stack = backtrace_stack,
 	.address = backtrace_address,
 };

commit d1ba71f7645696020864fe3cea3049befbe50408
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Oct 27 16:58:22 2010 +0900

    sh64: oprofile: Fix up kernel stack pointer size mismatch.
    
    For the backtrace code its assumed that the stack pointer is 32-bits,
    which is not the case with the sh64 registers. Use the shared
    kernel_stack_pointer() helper to get at the actual register, which
    already takes care of the necessary typecasting.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/oprofile/backtrace.c b/arch/sh/oprofile/backtrace.c
index 2bc74de23f08..37f3a75ea6cb 100644
--- a/arch/sh/oprofile/backtrace.c
+++ b/arch/sh/oprofile/backtrace.c
@@ -91,7 +91,7 @@ void sh_backtrace(struct pt_regs * const regs, unsigned int depth)
 	if (depth > backtrace_limit)
 		depth = backtrace_limit;
 
-	stackaddr = (unsigned long *)regs->regs[15];
+	stackaddr = (unsigned long *)kernel_stack_pointer(regs);
 	if (!user_mode(regs)) {
 		if (depth)
 			unwind_stack(NULL, regs, stackaddr,

commit f54aab4a7486fb7947d6d746f3423f67676811c8
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Aug 14 04:59:50 2009 +0900

    sh: oprofile: Kill off dead valid_kernel_stack().
    
    This is no longer used, kill it off.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/oprofile/backtrace.c b/arch/sh/oprofile/backtrace.c
index 37cd75d7930e..2bc74de23f08 100644
--- a/arch/sh/oprofile/backtrace.c
+++ b/arch/sh/oprofile/backtrace.c
@@ -81,33 +81,6 @@ user_backtrace(unsigned long *stackaddr, struct pt_regs *regs)
 	return stackaddr;
 }
 
-/*
- * |             | /\ Higher addresses
- * |             |
- * --------------- stack base (address of current_thread_info)
- * | thread info |
- * .             .
- * |    stack    |
- * --------------- saved regs->regs[15] value if valid
- * .             .
- * --------------- struct pt_regs stored on stack (struct pt_regs *)
- * |             |
- * .             .
- * |             |
- * --------------- ???
- * |             |
- * |             | \/ Lower addresses
- *
- * Thus, &pt_regs <-> stack base restricts the valid(ish) fp values
- */
-static int valid_kernel_stack(unsigned long *stackaddr, struct pt_regs *regs)
-{
-	unsigned long stack = (unsigned long)regs;
-	unsigned long stack_base = (stack & ~(THREAD_SIZE - 1)) + THREAD_SIZE;
-
-	return ((unsigned long)stackaddr > stack) && ((unsigned long)stackaddr < stack_base);
-}
-
 void sh_backtrace(struct pt_regs * const regs, unsigned int depth)
 {
 	unsigned long *stackaddr;

commit 0eff9f66de79a0707a9c3a2f8528ccfd62100f0b
Author: Matt Fleming <matt@console-pimps.org>
Date:   Tue Aug 11 22:43:20 2009 +0100

    sh: Use the new stack unwinder API
    
    Instead of implementing our own stack unwinder via dump_trace() we
    should use the new stack unwinder API because it is more modular. This
    change allows us to decouple the interface for generating stacktraces
    from the implementation of a stack unwinder.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/oprofile/backtrace.c b/arch/sh/oprofile/backtrace.c
index 62e4e4d0273e..37cd75d7930e 100644
--- a/arch/sh/oprofile/backtrace.c
+++ b/arch/sh/oprofile/backtrace.c
@@ -17,6 +17,7 @@
 #include <linux/sched.h>
 #include <linux/kallsyms.h>
 #include <linux/mm.h>
+#include <asm/unwinder.h>
 #include <asm/ptrace.h>
 #include <asm/uaccess.h>
 #include <asm/sections.h>
@@ -120,8 +121,8 @@ void sh_backtrace(struct pt_regs * const regs, unsigned int depth)
 	stackaddr = (unsigned long *)regs->regs[15];
 	if (!user_mode(regs)) {
 		if (depth)
-			dump_trace(NULL, regs, stackaddr,
-				   &backtrace_ops, &depth);
+			unwind_stack(NULL, regs, stackaddr,
+				     &backtrace_ops, &depth);
 		return;
 	}
 

commit 4e14dfc722b8e9e07a355f97aa60a3d9f0739071
Author: Matt Fleming <matt@console-pimps.org>
Date:   Fri Aug 7 16:11:19 2009 +0100

    sh: Use the generalized stacktrace ops
    
    Copy the stacktrace ops code from x86 and provide a central function for
    use by functions that need to dump a callstack.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/oprofile/backtrace.c b/arch/sh/oprofile/backtrace.c
index 9499a2914f89..62e4e4d0273e 100644
--- a/arch/sh/oprofile/backtrace.c
+++ b/arch/sh/oprofile/backtrace.c
@@ -20,6 +20,39 @@
 #include <asm/ptrace.h>
 #include <asm/uaccess.h>
 #include <asm/sections.h>
+#include <asm/stacktrace.h>
+
+static void backtrace_warning_symbol(void *data, char *msg,
+				     unsigned long symbol)
+{
+	/* Ignore warnings */
+}
+
+static void backtrace_warning(void *data, char *msg)
+{
+	/* Ignore warnings */
+}
+
+static int backtrace_stack(void *data, char *name)
+{
+	/* Yes, we want all stacks */
+	return 0;
+}
+
+static void backtrace_address(void *data, unsigned long addr, int reliable)
+{
+	unsigned int *depth = data;
+
+	if ((*depth)--)
+		oprofile_add_trace(addr);
+}
+
+static struct stacktrace_ops backtrace_ops = {
+	.warning = backtrace_warning,
+	.warning_symbol = backtrace_warning_symbol,
+	.stack = backtrace_stack,
+	.address = backtrace_address,
+};
 
 /* Limit to stop backtracing too far. */
 static int backtrace_limit = 20;
@@ -74,23 +107,6 @@ static int valid_kernel_stack(unsigned long *stackaddr, struct pt_regs *regs)
 	return ((unsigned long)stackaddr > stack) && ((unsigned long)stackaddr < stack_base);
 }
 
-static unsigned long *
-kernel_backtrace(unsigned long *stackaddr, struct pt_regs *regs)
-{
-	unsigned long addr;
-
-	/*
-	 * If not a valid kernel address, keep going till we find one
-	 * or the SP stops being a valid address.
-	 */
-	do {
-		addr = *stackaddr++;
-		oprofile_add_trace(addr);
-	} while (valid_kernel_stack(stackaddr, regs));
-
-	return stackaddr;
-}
-
 void sh_backtrace(struct pt_regs * const regs, unsigned int depth)
 {
 	unsigned long *stackaddr;
@@ -103,9 +119,9 @@ void sh_backtrace(struct pt_regs * const regs, unsigned int depth)
 
 	stackaddr = (unsigned long *)regs->regs[15];
 	if (!user_mode(regs)) {
-		while (depth-- && valid_kernel_stack(stackaddr, regs))
-			stackaddr = kernel_backtrace(stackaddr, regs);
-
+		if (depth)
+			dump_trace(NULL, regs, stackaddr,
+				   &backtrace_ops, &depth);
 		return;
 	}
 

commit 59de580af1c2fd671b0cb27c41ff958859ae5288
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Dec 22 19:32:27 2008 +0900

    sh: oprofile: Fix up the module build.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/oprofile/backtrace.c b/arch/sh/oprofile/backtrace.c
index 418e834654c1..9499a2914f89 100644
--- a/arch/sh/oprofile/backtrace.c
+++ b/arch/sh/oprofile/backtrace.c
@@ -85,11 +85,7 @@ kernel_backtrace(unsigned long *stackaddr, struct pt_regs *regs)
 	 */
 	do {
 		addr = *stackaddr++;
-
-		if (__kernel_text_address(addr)) {
-			oprofile_add_trace(addr);
-			break;
-		}
+		oprofile_add_trace(addr);
 	} while (valid_kernel_stack(stackaddr, regs));
 
 	return stackaddr;

commit 40a8b421b6a85f7786bf3007d316cd799efe8ea1
Author: Dave Peverley <dpeverley@mpc-data.co.uk>
Date:   Tue Dec 16 09:35:40 2008 +0900

    sh: oprofile: Backtrace support.
    
    This patch improves the oprofile support on sh and adds backtrace
    support.
    
    Signed-off-by: Dave Peverley <dpeverley@mpc-data.co.uk>
    Signed-off-by: Chris Smith <chris.smith@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/oprofile/backtrace.c b/arch/sh/oprofile/backtrace.c
new file mode 100644
index 000000000000..418e834654c1
--- /dev/null
+++ b/arch/sh/oprofile/backtrace.c
@@ -0,0 +1,118 @@
+/*
+ * SH specific backtracing code for oprofile
+ *
+ * Copyright 2007 STMicroelectronics Ltd.
+ *
+ * Author: Dave Peverley <dpeverley@mpc-data.co.uk>
+ *
+ * Based on ARM oprofile backtrace code by Richard Purdie and in turn, i386
+ * oprofile backtrace code by John Levon, David Smith
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/oprofile.h>
+#include <linux/sched.h>
+#include <linux/kallsyms.h>
+#include <linux/mm.h>
+#include <asm/ptrace.h>
+#include <asm/uaccess.h>
+#include <asm/sections.h>
+
+/* Limit to stop backtracing too far. */
+static int backtrace_limit = 20;
+
+static unsigned long *
+user_backtrace(unsigned long *stackaddr, struct pt_regs *regs)
+{
+	unsigned long buf_stack;
+
+	/* Also check accessibility of address */
+	if (!access_ok(VERIFY_READ, stackaddr, sizeof(unsigned long)))
+		return NULL;
+
+	if (__copy_from_user_inatomic(&buf_stack, stackaddr, sizeof(unsigned long)))
+		return NULL;
+
+	/* Quick paranoia check */
+	if (buf_stack & 3)
+		return NULL;
+
+	oprofile_add_trace(buf_stack);
+
+	stackaddr++;
+
+	return stackaddr;
+}
+
+/*
+ * |             | /\ Higher addresses
+ * |             |
+ * --------------- stack base (address of current_thread_info)
+ * | thread info |
+ * .             .
+ * |    stack    |
+ * --------------- saved regs->regs[15] value if valid
+ * .             .
+ * --------------- struct pt_regs stored on stack (struct pt_regs *)
+ * |             |
+ * .             .
+ * |             |
+ * --------------- ???
+ * |             |
+ * |             | \/ Lower addresses
+ *
+ * Thus, &pt_regs <-> stack base restricts the valid(ish) fp values
+ */
+static int valid_kernel_stack(unsigned long *stackaddr, struct pt_regs *regs)
+{
+	unsigned long stack = (unsigned long)regs;
+	unsigned long stack_base = (stack & ~(THREAD_SIZE - 1)) + THREAD_SIZE;
+
+	return ((unsigned long)stackaddr > stack) && ((unsigned long)stackaddr < stack_base);
+}
+
+static unsigned long *
+kernel_backtrace(unsigned long *stackaddr, struct pt_regs *regs)
+{
+	unsigned long addr;
+
+	/*
+	 * If not a valid kernel address, keep going till we find one
+	 * or the SP stops being a valid address.
+	 */
+	do {
+		addr = *stackaddr++;
+
+		if (__kernel_text_address(addr)) {
+			oprofile_add_trace(addr);
+			break;
+		}
+	} while (valid_kernel_stack(stackaddr, regs));
+
+	return stackaddr;
+}
+
+void sh_backtrace(struct pt_regs * const regs, unsigned int depth)
+{
+	unsigned long *stackaddr;
+
+	/*
+	 * Paranoia - clip max depth as we could get lost in the weeds.
+	 */
+	if (depth > backtrace_limit)
+		depth = backtrace_limit;
+
+	stackaddr = (unsigned long *)regs->regs[15];
+	if (!user_mode(regs)) {
+		while (depth-- && valid_kernel_stack(stackaddr, regs))
+			stackaddr = kernel_backtrace(stackaddr, regs);
+
+		return;
+	}
+
+	while (depth-- && (stackaddr != NULL))
+		stackaddr = user_backtrace(stackaddr, regs);
+}
