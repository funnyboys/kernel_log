commit 55205c916e179e09773d98d290334d319f45ac6b
Author: Vladimir Zapolskiy <vladimir.zapolskiy@nokia.com>
Date:   Thu Dec 22 16:15:40 2011 +0100

    oprofile, arm/sh: Fix oprofile_arch_exit() linkage issue
    
    This change fixes a linking problem, which happens if oprofile
    is selected to be compiled as built-in:
    
      `oprofile_arch_exit' referenced in section `.init.text' of
      arch/arm/oprofile/built-in.o: defined in discarded section
      `.exit.text' of arch/arm/oprofile/built-in.o
    
    The problem is appeared after commit 87121ca504, which
    introduced oprofile_arch_exit() calls from __init function. Note
    that the aforementioned commit has been backported to stable
    branches, and the problem is known to be reproduced at least
    with 3.0.13 and 3.1.5 kernels.
    
    Signed-off-by: Vladimir Zapolskiy <vladimir.zapolskiy@nokia.com>
    Signed-off-by: Robert Richter <robert.richter@amd.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: oprofile-list <oprofile-list@lists.sourceforge.net>
    Cc: <stable@kernel.org>
    Link: http://lkml.kernel.org/r/20111222151540.GB16765@erda.amd.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/sh/oprofile/common.c b/arch/sh/oprofile/common.c
index b4c2d2b946dd..e4dd5d5a1115 100644
--- a/arch/sh/oprofile/common.c
+++ b/arch/sh/oprofile/common.c
@@ -49,7 +49,7 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	return oprofile_perf_init(ops);
 }
 
-void __exit oprofile_arch_exit(void)
+void oprofile_arch_exit(void)
 {
 	oprofile_perf_exit();
 	kfree(sh_pmu_op_name);
@@ -60,5 +60,5 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	ops->backtrace = sh_backtrace;
 	return -ENODEV;
 }
-void __exit oprofile_arch_exit(void) {}
+void oprofile_arch_exit(void) {}
 #endif /* CONFIG_HW_PERF_EVENTS */

commit 7c842470f3ec7457585c277b9c5f535e94796f59
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Oct 13 07:43:50 2010 +0900

    sh: oprofile: Make sure the backtrace op is available for timer-fallback.
    
    Presently with hardware counter support disabled the backtrace op never
    gets initialized. This is a regression over the previous behaviour, so
    simply add it back in.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/oprofile/common.c b/arch/sh/oprofile/common.c
index 84533142da9b..b4c2d2b946dd 100644
--- a/arch/sh/oprofile/common.c
+++ b/arch/sh/oprofile/common.c
@@ -21,9 +21,9 @@
 #include <linux/slab.h>
 #include <asm/processor.h>
 
-#ifdef CONFIG_HW_PERF_EVENTS
 extern void sh_backtrace(struct pt_regs * const regs, unsigned int depth);
 
+#ifdef CONFIG_HW_PERF_EVENTS
 /*
  * This will need to be reworked when multiple PMUs are supported.
  */
@@ -57,7 +57,7 @@ void __exit oprofile_arch_exit(void)
 #else
 int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
-	pr_info("oprofile: hardware counters not available\n");
+	ops->backtrace = sh_backtrace;
 	return -ENODEV;
 }
 void __exit oprofile_arch_exit(void) {}

commit 2e4f17d230d84579fef07836fb5f69bf1a0a47ad
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Oct 13 03:46:25 2010 +0900

    sh: oprofile: Fix up and extend op_name_from_perf_id().
    
    op_name_from_perf_id() currently returns a local variable, which isn't
    terribly productive. As we only handle a single PMU case for now, simply
    allocate and free the string from the arch init/exit context and have
    op_name_from_perf_id() hand back the cached string.
    
    This also takes UTS_MACHINE in to account, given that we build for
    multiple architectures.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/oprofile/common.c b/arch/sh/oprofile/common.c
index e10d89376f9b..84533142da9b 100644
--- a/arch/sh/oprofile/common.c
+++ b/arch/sh/oprofile/common.c
@@ -1,7 +1,7 @@
 /*
  * arch/sh/oprofile/init.c
  *
- * Copyright (C) 2003 - 2008  Paul Mundt
+ * Copyright (C) 2003 - 2010  Paul Mundt
  *
  * Based on arch/mips/oprofile/common.c:
  *
@@ -18,38 +18,41 @@
 #include <linux/errno.h>
 #include <linux/smp.h>
 #include <linux/perf_event.h>
+#include <linux/slab.h>
 #include <asm/processor.h>
 
 #ifdef CONFIG_HW_PERF_EVENTS
 extern void sh_backtrace(struct pt_regs * const regs, unsigned int depth);
 
+/*
+ * This will need to be reworked when multiple PMUs are supported.
+ */
+static char *sh_pmu_op_name;
+
 char *op_name_from_perf_id(void)
 {
-	const char *pmu;
-	char buf[20];
-	int size;
-
-	pmu = perf_pmu_name();
-	if (!pmu)
-		return NULL;
-
-	size = snprintf(buf, sizeof(buf), "sh/%s", pmu);
-	if (size > -1 && size < sizeof(buf))
-		return buf;
-
-	return NULL;
+	return sh_pmu_op_name;
 }
 
 int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
 	ops->backtrace = sh_backtrace;
 
+	if (perf_num_counters() == 0)
+		return -ENODEV;
+
+	sh_pmu_op_name = kasprintf(GFP_KERNEL, "%s/%s",
+				   UTS_MACHINE, perf_pmu_name());
+	if (unlikely(!sh_pmu_op_name))
+		return -ENOMEM;
+
 	return oprofile_perf_init(ops);
 }
 
 void __exit oprofile_arch_exit(void)
 {
 	oprofile_perf_exit();
+	kfree(sh_pmu_op_name);
 }
 #else
 int __init oprofile_arch_init(struct oprofile_operations *ops)

commit 86c8c04792f152c5469023885510140dd34817bc
Author: Matt Fleming <matt@console-pimps.org>
Date:   Fri Sep 10 20:36:23 2010 +0100

    sh: oprofile: Use perf-events oprofile backend
    
    Now that we've got a generic perf-events based oprofile backend we might
    as well make use of it seeing as SH doesn't do anything special with its
    oprofile backend. Also introduce a new CONFIG_HW_PERF_EVENTS symbol so
    that we can fallback to using the timer interrupt for oprofile if the
    CPU doesn't support perf events.
    
    Also, to avoid a section mismatch warning we need to annotate
    oprofile_arch_exit() with an __exit marker.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/arch/sh/oprofile/common.c b/arch/sh/oprofile/common.c
index ac604937f3ee..e10d89376f9b 100644
--- a/arch/sh/oprofile/common.c
+++ b/arch/sh/oprofile/common.c
@@ -17,114 +17,45 @@
 #include <linux/init.h>
 #include <linux/errno.h>
 #include <linux/smp.h>
+#include <linux/perf_event.h>
 #include <asm/processor.h>
-#include "op_impl.h"
-
-static struct op_sh_model *model;
-
-static struct op_counter_config ctr[20];
 
+#ifdef CONFIG_HW_PERF_EVENTS
 extern void sh_backtrace(struct pt_regs * const regs, unsigned int depth);
 
-static int op_sh_setup(void)
-{
-	/* Pre-compute the values to stuff in the hardware registers.  */
-	model->reg_setup(ctr);
-
-	/* Configure the registers on all cpus.  */
-	on_each_cpu(model->cpu_setup, NULL, 1);
-
-        return 0;
-}
-
-static int op_sh_create_files(struct super_block *sb, struct dentry *root)
+char *op_name_from_perf_id(void)
 {
-	int i, ret = 0;
+	const char *pmu;
+	char buf[20];
+	int size;
 
-	for (i = 0; i < model->num_counters; i++) {
-		struct dentry *dir;
-		char buf[4];
+	pmu = perf_pmu_name();
+	if (!pmu)
+		return NULL;
 
-		snprintf(buf, sizeof(buf), "%d", i);
-		dir = oprofilefs_mkdir(sb, root, buf);
+	size = snprintf(buf, sizeof(buf), "sh/%s", pmu);
+	if (size > -1 && size < sizeof(buf))
+		return buf;
 
-		ret |= oprofilefs_create_ulong(sb, dir, "enabled", &ctr[i].enabled);
-		ret |= oprofilefs_create_ulong(sb, dir, "event", &ctr[i].event);
-		ret |= oprofilefs_create_ulong(sb, dir, "kernel", &ctr[i].kernel);
-		ret |= oprofilefs_create_ulong(sb, dir, "user", &ctr[i].user);
-
-		if (model->create_files)
-			ret |= model->create_files(sb, dir);
-		else
-			ret |= oprofilefs_create_ulong(sb, dir, "count", &ctr[i].count);
-
-		/* Dummy entries */
-		ret |= oprofilefs_create_ulong(sb, dir, "unit_mask", &ctr[i].unit_mask);
-	}
-
-	return ret;
+	return NULL;
 }
 
-static int op_sh_start(void)
+int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
-	/* Enable performance monitoring for all counters.  */
-	on_each_cpu(model->cpu_start, NULL, 1);
+	ops->backtrace = sh_backtrace;
 
-	return 0;
+	return oprofile_perf_init(ops);
 }
 
-static void op_sh_stop(void)
+void __exit oprofile_arch_exit(void)
 {
-	/* Disable performance monitoring for all counters.  */
-	on_each_cpu(model->cpu_stop, NULL, 1);
+	oprofile_perf_exit();
 }
-
+#else
 int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
-	struct op_sh_model *lmodel = NULL;
-	int ret;
-
-	/*
-	 * Always assign the backtrace op. If the counter initialization
-	 * fails, we fall back to the timer which will still make use of
-	 * this.
-	 */
-	ops->backtrace = sh_backtrace;
-
-	/*
-	 * XXX
-	 *
-	 * All of the SH7750/SH-4A counters have been converted to perf,
-	 * this infrastructure hook is left for other users until they've
-	 * had a chance to convert over, at which point all of this
-	 * will be deleted.
-	 */
-
-	if (!lmodel)
-		return -ENODEV;
-	if (!(current_cpu_data.flags & CPU_HAS_PERF_COUNTER))
-		return -ENODEV;
-
-	ret = lmodel->init();
-	if (unlikely(ret != 0))
-		return ret;
-
-	model = lmodel;
-
-	ops->setup		= op_sh_setup;
-	ops->create_files	= op_sh_create_files;
-	ops->start		= op_sh_start;
-	ops->stop		= op_sh_stop;
-	ops->cpu_type		= lmodel->cpu_type;
-
-	printk(KERN_INFO "oprofile: using %s performance monitoring.\n",
-	       lmodel->cpu_type);
-
-	return 0;
-}
-
-void oprofile_arch_exit(void)
-{
-	if (model && model->exit)
-		model->exit();
+	pr_info("oprofile: hardware counters not available\n");
+	return -ENODEV;
 }
+void __exit oprofile_arch_exit(void) {}
+#endif /* CONFIG_HW_PERF_EVENTS */

commit 093aed1937cc7ae9290ede24ad45f040e097510b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Nov 5 17:09:59 2009 +0900

    sh: oprofile: Kill off bitrotted SH7750 driver.
    
    This kills off the old SH7750 oprofile driver, preferring perf instead.
    As this driver has a number of bugs that no one seems to have noticed,
    it's safe to kill this off now rather than providing an extended
    transition period.
    
    The old oprofile framework is still kept in place for now, primarily to
    give out-of-tree drivers a chance to transition off. But this too will be
    killed off in short order.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/oprofile/common.c b/arch/sh/oprofile/common.c
index 44f4e31c6d63..ac604937f3ee 100644
--- a/arch/sh/oprofile/common.c
+++ b/arch/sh/oprofile/common.c
@@ -20,9 +20,6 @@
 #include <asm/processor.h>
 #include "op_impl.h"
 
-extern struct op_sh_model op_model_sh7750_ops __weak;
-extern struct op_sh_model op_model_sh4a_ops __weak;
-
 static struct op_sh_model *model;
 
 static struct op_counter_config ctr[20];
@@ -94,33 +91,14 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	 */
 	ops->backtrace = sh_backtrace;
 
-	switch (current_cpu_data.type) {
-	/* SH-4 types */
-	case CPU_SH7750:
-	case CPU_SH7750S:
-		lmodel = &op_model_sh7750_ops;
-		break;
-
-        /* SH-4A types */
-	case CPU_SH7763:
-	case CPU_SH7770:
-	case CPU_SH7780:
-	case CPU_SH7781:
-	case CPU_SH7785:
-	case CPU_SH7786:
-	case CPU_SH7723:
-	case CPU_SH7724:
-	case CPU_SHX3:
-		lmodel = &op_model_sh4a_ops;
-		break;
-
-	/* SH4AL-DSP types */
-	case CPU_SH7343:
-	case CPU_SH7722:
-	case CPU_SH7366:
-		lmodel = &op_model_sh4a_ops;
-		break;
-	}
+	/*
+	 * XXX
+	 *
+	 * All of the SH7750/SH-4A counters have been converted to perf,
+	 * this infrastructure hook is left for other users until they've
+	 * had a chance to convert over, at which point all of this
+	 * will be deleted.
+	 */
 
 	if (!lmodel)
 		return -ENODEV;

commit 0207a2efb43d81e29e23662b5d035945688a103f
Author: Kuninori Morimoto <morimoto.kuninori@renesas.com>
Date:   Thu Apr 16 14:40:56 2009 +0900

    sh: Add support for SH7724 (SH-Mobile R2R) CPU subtype.
    
    This implements initial support for the SH-Mobile R2R CPU.
    Based on Rev 0.11 of the initial SH7724 hardware manual.
    
    Signed-off-by: Kuninori Morimoto <morimoto.kuninori@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/oprofile/common.c b/arch/sh/oprofile/common.c
index 1b9d4304b3bf..44f4e31c6d63 100644
--- a/arch/sh/oprofile/common.c
+++ b/arch/sh/oprofile/common.c
@@ -109,6 +109,7 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	case CPU_SH7785:
 	case CPU_SH7786:
 	case CPU_SH7723:
+	case CPU_SH7724:
 	case CPU_SHX3:
 		lmodel = &op_model_sh4a_ops;
 		break;

commit 55ba99eb211a06709237cb322ecd8c8b6faf6159
Author: Kuninori Morimoto <morimoto.kuninori@renesas.com>
Date:   Tue Mar 3 15:40:25 2009 +0900

    sh: Add support for SH7786 CPU subtype.
    
    This adds preliminary support for the SH7786 CPU subtype.
    
    While this is a dual-core CPU, only UP is supported for now. L2 cache
    support is likewise not yet implemented.
    
    More information on this particular CPU subtype is available at:
    
            http://www.renesas.com/fmwk.jsp?cnt=sh7786_root.jsp&fp=/products/mpumcu/superh_family/sh7780_series/sh7786_group/
    
    Signed-off-by: Kuninori Morimoto <morimoto.kuninori@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/oprofile/common.c b/arch/sh/oprofile/common.c
index 1d97d64cb95f..1b9d4304b3bf 100644
--- a/arch/sh/oprofile/common.c
+++ b/arch/sh/oprofile/common.c
@@ -107,6 +107,7 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	case CPU_SH7780:
 	case CPU_SH7781:
 	case CPU_SH7785:
+	case CPU_SH7786:
 	case CPU_SH7723:
 	case CPU_SHX3:
 		lmodel = &op_model_sh4a_ops;

commit 40a8b421b6a85f7786bf3007d316cd799efe8ea1
Author: Dave Peverley <dpeverley@mpc-data.co.uk>
Date:   Tue Dec 16 09:35:40 2008 +0900

    sh: oprofile: Backtrace support.
    
    This patch improves the oprofile support on sh and adds backtrace
    support.
    
    Signed-off-by: Dave Peverley <dpeverley@mpc-data.co.uk>
    Signed-off-by: Chris Smith <chris.smith@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/oprofile/common.c b/arch/sh/oprofile/common.c
index a4d8c0c9a63c..1d97d64cb95f 100644
--- a/arch/sh/oprofile/common.c
+++ b/arch/sh/oprofile/common.c
@@ -27,6 +27,8 @@ static struct op_sh_model *model;
 
 static struct op_counter_config ctr[20];
 
+extern void sh_backtrace(struct pt_regs * const regs, unsigned int depth);
+
 static int op_sh_setup(void)
 {
 	/* Pre-compute the values to stuff in the hardware registers.  */
@@ -85,6 +87,13 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	struct op_sh_model *lmodel = NULL;
 	int ret;
 
+	/*
+	 * Always assign the backtrace op. If the counter initialization
+	 * fails, we fall back to the timer which will still make use of
+	 * this.
+	 */
+	ops->backtrace = sh_backtrace;
+
 	switch (current_cpu_data.type) {
 	/* SH-4 types */
 	case CPU_SH7750:

commit 60a51fbe5dd2baef0f35bcf79f25ac1ee239a660
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Dec 16 09:33:53 2008 +0900

    sh: oprofile: Refactor common setup code for multiple driver support.
    
    This re-implements the old op_model_null code in to something more
    generic, where multiple drivers, backtrace, etc. can all be interfaced.
    Based largely on arch/mips/oprofile/common.c.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/oprofile/common.c b/arch/sh/oprofile/common.c
new file mode 100644
index 000000000000..a4d8c0c9a63c
--- /dev/null
+++ b/arch/sh/oprofile/common.c
@@ -0,0 +1,141 @@
+/*
+ * arch/sh/oprofile/init.c
+ *
+ * Copyright (C) 2003 - 2008  Paul Mundt
+ *
+ * Based on arch/mips/oprofile/common.c:
+ *
+ *	Copyright (C) 2004, 2005 Ralf Baechle
+ *	Copyright (C) 2005 MIPS Technologies, Inc.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/oprofile.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+#include <asm/processor.h>
+#include "op_impl.h"
+
+extern struct op_sh_model op_model_sh7750_ops __weak;
+extern struct op_sh_model op_model_sh4a_ops __weak;
+
+static struct op_sh_model *model;
+
+static struct op_counter_config ctr[20];
+
+static int op_sh_setup(void)
+{
+	/* Pre-compute the values to stuff in the hardware registers.  */
+	model->reg_setup(ctr);
+
+	/* Configure the registers on all cpus.  */
+	on_each_cpu(model->cpu_setup, NULL, 1);
+
+        return 0;
+}
+
+static int op_sh_create_files(struct super_block *sb, struct dentry *root)
+{
+	int i, ret = 0;
+
+	for (i = 0; i < model->num_counters; i++) {
+		struct dentry *dir;
+		char buf[4];
+
+		snprintf(buf, sizeof(buf), "%d", i);
+		dir = oprofilefs_mkdir(sb, root, buf);
+
+		ret |= oprofilefs_create_ulong(sb, dir, "enabled", &ctr[i].enabled);
+		ret |= oprofilefs_create_ulong(sb, dir, "event", &ctr[i].event);
+		ret |= oprofilefs_create_ulong(sb, dir, "kernel", &ctr[i].kernel);
+		ret |= oprofilefs_create_ulong(sb, dir, "user", &ctr[i].user);
+
+		if (model->create_files)
+			ret |= model->create_files(sb, dir);
+		else
+			ret |= oprofilefs_create_ulong(sb, dir, "count", &ctr[i].count);
+
+		/* Dummy entries */
+		ret |= oprofilefs_create_ulong(sb, dir, "unit_mask", &ctr[i].unit_mask);
+	}
+
+	return ret;
+}
+
+static int op_sh_start(void)
+{
+	/* Enable performance monitoring for all counters.  */
+	on_each_cpu(model->cpu_start, NULL, 1);
+
+	return 0;
+}
+
+static void op_sh_stop(void)
+{
+	/* Disable performance monitoring for all counters.  */
+	on_each_cpu(model->cpu_stop, NULL, 1);
+}
+
+int __init oprofile_arch_init(struct oprofile_operations *ops)
+{
+	struct op_sh_model *lmodel = NULL;
+	int ret;
+
+	switch (current_cpu_data.type) {
+	/* SH-4 types */
+	case CPU_SH7750:
+	case CPU_SH7750S:
+		lmodel = &op_model_sh7750_ops;
+		break;
+
+        /* SH-4A types */
+	case CPU_SH7763:
+	case CPU_SH7770:
+	case CPU_SH7780:
+	case CPU_SH7781:
+	case CPU_SH7785:
+	case CPU_SH7723:
+	case CPU_SHX3:
+		lmodel = &op_model_sh4a_ops;
+		break;
+
+	/* SH4AL-DSP types */
+	case CPU_SH7343:
+	case CPU_SH7722:
+	case CPU_SH7366:
+		lmodel = &op_model_sh4a_ops;
+		break;
+	}
+
+	if (!lmodel)
+		return -ENODEV;
+	if (!(current_cpu_data.flags & CPU_HAS_PERF_COUNTER))
+		return -ENODEV;
+
+	ret = lmodel->init();
+	if (unlikely(ret != 0))
+		return ret;
+
+	model = lmodel;
+
+	ops->setup		= op_sh_setup;
+	ops->create_files	= op_sh_create_files;
+	ops->start		= op_sh_start;
+	ops->stop		= op_sh_stop;
+	ops->cpu_type		= lmodel->cpu_type;
+
+	printk(KERN_INFO "oprofile: using %s performance monitoring.\n",
+	       lmodel->cpu_type);
+
+	return 0;
+}
+
+void oprofile_arch_exit(void)
+{
+	if (model && model->exit)
+		model->exit();
+}
