commit 87dfb311b707cd4c4b666c9af0fa15acbe6eee99
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue May 14 15:46:51 2019 -0700

    treewide: replace #include <asm/sizes.h> with #include <linux/sizes.h>
    
    Since commit dccd2304cc90 ("ARM: 7430/1: sizes.h: move from asm-generic
    to <linux/sizes.h>"), <asm/sizes.h> and <asm-generic/sizes.h> are just
    wrappers of <linux/sizes.h>.
    
    This commit replaces all <asm/sizes.h> and <asm-generic/sizes.h> to
    prepare for the removal.
    
    Link: http://lkml.kernel.org/r/1553267665-27228-1-git-send-email-yamada.masahiro@socionext.com
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index a58b77cea295..e0b568aaa701 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -18,7 +18,7 @@
 #include <linux/sh_intc.h>
 #include <cpu/sh7786.h>
 #include "pcie-sh7786.h"
-#include <asm/sizes.h>
+#include <linux/sizes.h>
 
 struct sh7786_pcie_port {
 	struct pci_channel	*hose;

commit ff4a7481c3898ffc3cc271d6aca431d190c37247
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 28 00:31:49 2018 -0800

    sh: drivers: convert to SPDX identifiers
    
    Update license to use SPDX-License-Identifier instead of verbose license
    text.
    
    As original license mentioned, it is GPL-2.0 in SPDX.
    Then, MODULE_LICENSE() should be "GPL v2" instead of "GPL".
    See ${LINUX}/include/linux/module.h
    
            "GPL"           [GNU Public License v2 or later]
            "GPL v2"        [GNU Public License v2]
    
    Link: http://lkml.kernel.org/r/87h8fsct0a.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 3d81a8b80942..a58b77cea295 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -1,11 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Low-Level PCI Express Support for the SH7786
  *
  *  Copyright (C) 2009 - 2011  Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 #define pr_fmt(fmt) "PCI: " fmt
 

commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:03:40 2018 -0700

    treewide: kzalloc() -> kcalloc()
    
    The kzalloc() function has a 2-factor argument form, kcalloc(). This
    patch replaces cases of:
    
            kzalloc(a * b, gfp)
    
    with:
            kcalloc(a * b, gfp)
    
    as well as handling cases of:
    
            kzalloc(a * b * c, gfp)
    
    with:
    
            kzalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kzalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kzalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kzalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kzalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kzalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kzalloc
    + kcalloc
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kzalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(sizeof(THING) * C2, ...)
    |
      kzalloc(sizeof(TYPE) * C2, ...)
    |
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(C1 * C2, ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 382e7ecf4c82..3d81a8b80942 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -561,7 +561,7 @@ static int __init sh7786_pcie_init(void)
 	if (unlikely(nr_ports == 0))
 		return -ENODEV;
 
-	sh7786_pcie_ports = kzalloc(nr_ports * sizeof(struct sh7786_pcie_port),
+	sh7786_pcie_ports = kcalloc(nr_ports, sizeof(struct sh7786_pcie_port),
 				    GFP_KERNEL);
 	if (unlikely(!sh7786_pcie_ports))
 		return -ENOMEM;

commit bf9c7e3d7924f72225f8f9c28438b4a711192ad3
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon Dec 4 16:09:07 2017 +0100

    arch/sh: pcie-sh7786: handle non-zero DMA offset
    
    On SuperH, the base of the physical memory might be different from
    zero. In this case, PCI address zero will map to a non-zero physical
    address. In order to make sure that the DMA mapping API takes care of
    this DMA offset, we must fill in the dev->dma_pfn_offset field for PCI
    devices. This gets done in the pcibios_bus_add_device() hook, called
    for each new PCI device detected.
    
    The dma_pfn_offset global variable is re-calculated for every PCI
    controller available on the platform, but that's not an issue because
    its value will each time be exactly the same, as it only depends on
    the memory start address and memory size.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Rich Felker <dalias@libc.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index b8f411451647..382e7ecf4c82 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -33,6 +33,7 @@ struct sh7786_pcie_port {
 
 static struct sh7786_pcie_port *sh7786_pcie_ports;
 static unsigned int nr_ports;
+static unsigned long dma_pfn_offset;
 
 static struct sh7786_pcie_hwops {
 	int (*core_init)(void);
@@ -370,6 +371,8 @@ static int __init pcie_init(struct sh7786_pcie_port *port)
 	memstart = ALIGN_DOWN(memstart, memsize);
 	memsize = roundup_pow_of_two(memend - memstart);
 
+	dma_pfn_offset = memstart >> PAGE_SHIFT;
+
 	/*
 	 * If there's more than 512MB of memory, we need to roll over to
 	 * LAR1/LAMR1.
@@ -485,6 +488,11 @@ int pcibios_map_platform_irq(const struct pci_dev *pdev, u8 slot, u8 pin)
         return evt2irq(0xae0);
 }
 
+void pcibios_bus_add_device(struct pci_dev *pdev)
+{
+	pdev->dev.dma_pfn_offset = dma_pfn_offset;
+}
+
 static int __init sh7786_pcie_core_init(void)
 {
 	/* Return the number of ports */

commit 79e1c5e70b2a0fadb7b61c69de8442703e7d0dc4
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon Dec 4 16:09:06 2017 +0100

    arch/sh: pcie-sh7786: adjust the memory mapping
    
    The code setting up the PCI -> SuperHighway mapping doesn't take into
    account the fact that the address stored in PCIELARx must be aligned
    with the size stored in PCIELAMRx.
    
    For example, when your physical memory starts at 0x0800_0000 (128 MB),
    a size of 64 MB or 128 MB is fine. However, if you have 256 MB of
    memory, it doesn't work because the base address is not aligned on the
    size.
    
    In such situation, we have to round down the base address to make sure
    it is aligned on the size of the area. For for a 0x0800_0000 base
    address with 256 MB of memory, we will round down to 0x0, and extend
    the size of the mapping to 512 MB.
    
    This allows the mapping to work on platforms that have 256 MB of
    RAM. The current setup would only work with 128 MB of RAM or less.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Rich Felker <dalias@libc.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 57abae2f6822..b8f411451647 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -302,7 +302,7 @@ static int __init pcie_init(struct sh7786_pcie_port *port)
 {
 	struct pci_channel *chan = port->hose;
 	unsigned int data;
-	phys_addr_t memphys;
+	phys_addr_t memstart, memend;
 	size_t memsize;
 	int ret, i, win;
 
@@ -358,15 +358,24 @@ static int __init pcie_init(struct sh7786_pcie_port *port)
 	data |= (0xff << 16);
 	pci_write_reg(chan, data, SH4A_PCIEMACCTLR);
 
-	memphys = __pa(memory_start);
-	memsize = roundup_pow_of_two(memory_end - memory_start);
+	memstart = __pa(memory_start);
+	memend   = __pa(memory_end);
+	memsize = roundup_pow_of_two(memend - memstart);
+
+	/*
+	 * The start address must be aligned on its size. So we round
+	 * it down, and then recalculate the size so that it covers
+	 * the entire memory.
+	 */
+	memstart = ALIGN_DOWN(memstart, memsize);
+	memsize = roundup_pow_of_two(memend - memstart);
 
 	/*
 	 * If there's more than 512MB of memory, we need to roll over to
 	 * LAR1/LAMR1.
 	 */
 	if (memsize > SZ_512M) {
-		pci_write_reg(chan, memphys + SZ_512M, SH4A_PCIELAR1);
+		pci_write_reg(chan, memstart + SZ_512M, SH4A_PCIELAR1);
 		pci_write_reg(chan, ((memsize - SZ_512M) - SZ_256) | 1,
 			      SH4A_PCIELAMR1);
 		memsize = SZ_512M;
@@ -382,7 +391,7 @@ static int __init pcie_init(struct sh7786_pcie_port *port)
 	 * LAR0/LAMR0 covers up to the first 512MB, which is enough to
 	 * cover all of lowmem on most platforms.
 	 */
-	pci_write_reg(chan, memphys, SH4A_PCIELAR0);
+	pci_write_reg(chan, memstart, SH4A_PCIELAR0);
 	pci_write_reg(chan, (memsize - SZ_256) | 1, SH4A_PCIELAMR0);
 
 	/* Finish initialization */

commit 5da1bb96dc8dfce9d1b9d7c410803e8fa88f678c
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon Dec 4 16:09:05 2017 +0100

    arch/sh: pcie-sh7786: adjust PCI MEM and IO regions
    
    The current definition of the PCIe IO and MEM resources for SH7786
    doesn't match what the datasheet says. For example, for PCIe0
    0xfe100000 is advertised by the datasheet as a PCI IO region, while
    0xfd000000 is advertised as a PCI MEM region. The code currently
    inverts the two.
    
    The SH4A_PCIEPARL and SH4A_PCIEPTCTLR registers allow to define the
    base address and role of the different regions (including whether it's
    a MEM or IO region). However, practical experience on a SH7786 shows
    that if 0xfe100000 is used for LEL and 0xfd000000 for IO, a PCIe
    device using two MEM BARs cannot be accessed at all. Simply using
    0xfe100000 for IO and 0xfd000000 for MEM makes the PCIe device
    accessible.
    
    It is very likely that this was never seen because there are two other
    PCI MEM region listed in the resources. However, for different
    reasons, none of the two other MEM regions are usable on the specific
    SH7786 platform the problem was encountered. Therefore, the last MEM
    region at 0xfe100000 was used to place the BARs, making the device
    non-functional.
    
    This commit therefore adjusts those PCI MEM and IO resources
    definitions so that they match what the datasheet says. They have only
    been tested with PCIe 0.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Rich Felker <dalias@libc.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 72a1d794a7ba..57abae2f6822 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -41,73 +41,73 @@ static struct sh7786_pcie_hwops {
 
 static struct resource sh7786_pci0_resources[] = {
 	{
-		.name	= "PCIe0 IO",
+		.name	= "PCIe0 MEM 0",
 		.start	= 0xfd000000,
 		.end	= 0xfd000000 + SZ_8M - 1,
-		.flags	= IORESOURCE_IO,
+		.flags	= IORESOURCE_MEM,
 	}, {
-		.name	= "PCIe0 MEM 0",
+		.name	= "PCIe0 MEM 1",
 		.start	= 0xc0000000,
 		.end	= 0xc0000000 + SZ_512M - 1,
 		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
 	}, {
-		.name	= "PCIe0 MEM 1",
+		.name	= "PCIe0 MEM 2",
 		.start	= 0x10000000,
 		.end	= 0x10000000 + SZ_64M - 1,
 		.flags	= IORESOURCE_MEM,
 	}, {
-		.name	= "PCIe0 MEM 2",
+		.name	= "PCIe0 IO",
 		.start	= 0xfe100000,
 		.end	= 0xfe100000 + SZ_1M - 1,
-		.flags	= IORESOURCE_MEM,
+		.flags	= IORESOURCE_IO,
 	},
 };
 
 static struct resource sh7786_pci1_resources[] = {
 	{
-		.name	= "PCIe1 IO",
+		.name	= "PCIe1 MEM 0",
 		.start	= 0xfd800000,
 		.end	= 0xfd800000 + SZ_8M - 1,
-		.flags	= IORESOURCE_IO,
+		.flags	= IORESOURCE_MEM,
 	}, {
-		.name	= "PCIe1 MEM 0",
+		.name	= "PCIe1 MEM 1",
 		.start	= 0xa0000000,
 		.end	= 0xa0000000 + SZ_512M - 1,
 		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
 	}, {
-		.name	= "PCIe1 MEM 1",
+		.name	= "PCIe1 MEM 2",
 		.start	= 0x30000000,
 		.end	= 0x30000000 + SZ_256M - 1,
 		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
 	}, {
-		.name	= "PCIe1 MEM 2",
+		.name	= "PCIe1 IO",
 		.start	= 0xfe300000,
 		.end	= 0xfe300000 + SZ_1M - 1,
-		.flags	= IORESOURCE_MEM,
+		.flags	= IORESOURCE_IO,
 	},
 };
 
 static struct resource sh7786_pci2_resources[] = {
 	{
-		.name	= "PCIe2 IO",
+		.name	= "PCIe2 MEM 0",
 		.start	= 0xfc800000,
 		.end	= 0xfc800000 + SZ_4M - 1,
-		.flags	= IORESOURCE_IO,
+		.flags	= IORESOURCE_MEM,
 	}, {
-		.name	= "PCIe2 MEM 0",
+		.name	= "PCIe2 MEM 1",
 		.start	= 0x80000000,
 		.end	= 0x80000000 + SZ_512M - 1,
 		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
 	}, {
-		.name	= "PCIe2 MEM 1",
+		.name	= "PCIe2 MEM 2",
 		.start	= 0x20000000,
 		.end	= 0x20000000 + SZ_256M - 1,
 		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
 	}, {
-		.name	= "PCIe2 MEM 2",
+		.name	= "PCIe2 IO",
 		.start	= 0xfcd00000,
 		.end	= 0xfcd00000 + SZ_1M - 1,
-		.flags	= IORESOURCE_MEM,
+		.flags	= IORESOURCE_IO,
 	},
 };
 

commit d62e9bf5dd4c0298465dd70b78b5532ea6708d63
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon Dec 4 16:09:04 2017 +0100

    arch/sh: pcie-sh7786: exclude unusable PCI MEM areas
    
    Depending on the physical memory layout, some PCI MEM areas are not
    usable. According to the SH7786 datasheet, the PCI MEM area from
    1000_0000 to 13FF_FFFF is only usable if the physical memory layout
    (in MMSELR) is 1, 2, 5 or 6. In all other configurations, this PCI MEM
    area is not usable (because it overlaps with DRAM).
    
    Therefore, this commit adjusts the PCI SH7786 initialization to mark
    the relevant PCI resource as IORESOURCE_DISABLED if we can't use it.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Rich Felker <dalias@libc.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index e713c398a6b9..72a1d794a7ba 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -19,6 +19,7 @@
 #include <linux/clk.h>
 #include <linux/sh_clk.h>
 #include <linux/sh_intc.h>
+#include <cpu/sh7786.h>
 #include "pcie-sh7786.h"
 #include <asm/sizes.h>
 
@@ -530,6 +531,7 @@ static struct sh7786_pcie_hwops sh7786_65nm_pcie_hwops __initdata = {
 static int __init sh7786_pcie_init(void)
 {
 	struct clk *platclk;
+	u32 mm_sel;
 	int i;
 
 	printk(KERN_NOTICE "PCI: Starting initialization.\n");
@@ -563,6 +565,16 @@ static int __init sh7786_pcie_init(void)
 
 	clk_enable(platclk);
 
+	mm_sel = sh7786_mm_sel();
+
+	/*
+	 * Depending on the MMSELR register value, the PCIe0 MEM 1
+	 * area may not be available. See Table 13.11 of the SH7786
+	 * datasheet.
+	 */
+	if (mm_sel != 1 && mm_sel != 2 && mm_sel != 5 && mm_sel != 6)
+		sh7786_pci0_resources[2].flags |= IORESOURCE_DISABLED;
+
 	printk(KERN_NOTICE "PCI: probing %d ports.\n", nr_ports);
 
 	for (i = 0; i < nr_ports; i++) {

commit 7dd7f69809b4e3bed5c28dd8600a3a8b20f6441c
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon Dec 4 16:09:03 2017 +0100

    arch/sh: pcie-sh7786: mark unavailable PCI resource as disabled
    
    Some PCI MEM resources are marked as IORESOURCE_MEM_32BIT, which means
    they are only usable when the SH core runs in 32-bit mode. In 29-bit
    mode, such memory regions are not usable.
    
    The existing code for SH7786 properly skips such regions when
    configuring the PCIe controller registers. However, because such
    regions are still described in the resource array, the
    pcibios_scanbus() function in the SuperH pci.c will register them to
    the PCI core. Due to this, the PCI core will allocate MEM areas from
    this resource, and assign BARs pointing to this area, even though it's
    unusable.
    
    In order to prevent this from happening, we mark such regions as
    IORESOURCE_DISABLED, which tells the SuperH pci.c pcibios_scanbus()
    function to skip them.
    
    Note that we separate marking the region as disabled from skipping it,
    because other regions will be marked as disabled in follow-up patches.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Rich Felker <dalias@libc.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 0167a7352719..e713c398a6b9 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -438,6 +438,9 @@ static int __init pcie_init(struct sh7786_pcie_port *port)
 		 * mode, so just skip them entirely.
 		 */
 		if ((res->flags & IORESOURCE_MEM_32BIT) && __in_29bit_mode())
+			res->flags |= IORESOURCE_DISABLED;
+
+		if (res->flags & IORESOURCE_DISABLED)
 			continue;
 
 		pci_write_reg(chan, 0x00000000, SH4A_PCIEPTCTLR(win));

commit 2b8ff9f2769135a08fc7b9c989560f759b80cc1a
Author: Matthew Minter <matt@masarand.com>
Date:   Mon Jul 31 17:37:49 2017 +0100

    sh/PCI: Remove __init optimisations from IRQ mapping functions/data
    
    Currently many IRQ mapping functions and data structures use the __init and
    __initdata optimisations. These result in the relevant functions being
    innaccessible after boot time.
    
    However for deferred IRQ assignment it is important to have access to these
    functions at PCI device enable time.
    
    Therefore, remove the optimisation from the relevant data structures and
    functions to prepare for deferred IRQ assignment.
    
    Signed-off-by: Matthew Minter <matt@masarand.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index a162a7f86b2e..0167a7352719 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -467,7 +467,7 @@ static int __init pcie_init(struct sh7786_pcie_port *port)
 	return 0;
 }
 
-int __init pcibios_map_platform_irq(const struct pci_dev *pdev, u8 slot, u8 pin)
+int pcibios_map_platform_irq(const struct pci_dev *pdev, u8 slot, u8 pin)
 {
         return evt2irq(0xae0);
 }

commit 362f2b098b188ede9c4350cc20e58040dbfa515e
Author: Lai Jiangshan <laijs@cn.fujitsu.com>
Date:   Tue Mar 12 13:59:14 2013 -0700

    async: rename and redefine async_func_ptr
    
    A function type is typically defined as
    typedef ret_type (*func)(args..)
    
    but async_func_ptr is not.  Redefine it.
    
    Also rename async_func_ptr to async_func_t for _func_t suffix is more generic.
    
    Signed-off-by: Lai Jiangshan <laijs@cn.fujitsu.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Arjan van de Ven <arjan@linux.intel.com>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index c2c85f6cd738..a162a7f86b2e 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -35,7 +35,7 @@ static unsigned int nr_ports;
 
 static struct sh7786_pcie_hwops {
 	int (*core_init)(void);
-	async_func_ptr *port_init_hw;
+	async_func_t port_init_hw;
 } *sh7786_pcie_hwops;
 
 static struct resource sh7786_pci0_resources[] = {

commit b881bc469bdbdcca60e75047885509eb9886d3a2
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 14:06:37 2012 -0800

    ARCH: drivers remove __dev* attributes.
    
    This fixes up all of the smaller arches that had __dev* markings for
    their platform-specific drivers.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Haavard Skinnemoen <hskinnemoen@gmail.com>
    Cc: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Cc: Mike Frysinger <vapier@gentoo.org>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Jesper Nilsson <jesper.nilsson@axis.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Hirokazu Takata <takata@linux-m32r.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Koichi Yasutake <yasutake.koichi@jp.panasonic.com>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Chen Liqin <liqin.chen@sunplusct.com>
    Cc: Lennox Wu <lennox.wu@gmail.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Cc: Bob Liu <lliubbo@gmail.com>
    Cc: Srinivas Kandagatla <srinivas.kandagatla@st.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Myron Stowe <myron.stowe@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Thierry Reding <thierry.reding@avionic-design.de>
    Cc: Greg Ungerer <gerg@uclinux.org>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: "Srivatsa S. Bhat" <srivatsa.bhat@linux.vnet.ibm.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Yong Zhang <yong.zhang0@gmail.com>
    Cc: Michael Holzheu <holzheu@linux.vnet.ibm.com>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Jan Glauber <jang@linux.vnet.ibm.com>
    Cc: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Cc: Nobuhiro Iwamatsu <nobuhiro.iwamatsu.yj@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 9e702f2f8045..c2c85f6cd738 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -132,7 +132,7 @@ static struct clk fixed_pciexclkp = {
 	.rate = 100000000,	/* 100 MHz reference clock */
 };
 
-static void __devinit sh7786_pci_fixup(struct pci_dev *dev)
+static void sh7786_pci_fixup(struct pci_dev *dev)
 {
 	/*
 	 * Prevent enumeration of root complex resources.

commit ad3337cb38bf1f4c677ce2d05f9c049b35f7147e
Author: Nobuhiro Iwamatsu <nobuhiro.iwamatsu.yj@renesas.com>
Date:   Wed Jun 27 09:59:40 2012 +0900

    sh: Convert sh_clk_mstp32_register to sh_clk_mstp_register
    
    sh_clk_mstp32_register is deprecated. This convert to sh_clk_mstp_register.
    
    Signed-off-by: Nobuhiro Iwamatsu <nobuhiro.iwamatsu.yj@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index c045142f7338..9e702f2f8045 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -239,7 +239,7 @@ static int __init pcie_clk_init(struct sh7786_pcie_port *port)
 	clk->enable_reg = (void __iomem *)(chan->reg_base + SH4A_PCIEPHYCTLR);
 	clk->enable_bit = BITS_CKE;
 
-	ret = sh_clk_mstp32_register(clk, 1);
+	ret = sh_clk_mstp_register(clk, 1);
 	if (unlikely(ret < 0))
 		goto err_phy;
 

commit 58796ce67a80e8725220af83c5a550bf6a4dab12
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri May 18 17:42:29 2012 +0900

    sh: legacy PCI evt2irq migration.
    
    This converts over the legacy PCI IRQs to evt2irq() backed hwirq lookups.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 4df27c4fbf99..c045142f7338 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -18,6 +18,7 @@
 #include <linux/slab.h>
 #include <linux/clk.h>
 #include <linux/sh_clk.h>
+#include <linux/sh_intc.h>
 #include "pcie-sh7786.h"
 #include <asm/sizes.h>
 
@@ -468,7 +469,7 @@ static int __init pcie_init(struct sh7786_pcie_port *port)
 
 int __init pcibios_map_platform_irq(const struct pci_dev *pdev, u8 slot, u8 pin)
 {
-        return 71;
+        return evt2irq(0xae0);
 }
 
 static int __init sh7786_pcie_core_init(void)

commit d5341942d784134f2997b3ff82cd63cf71d1f932
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Jun 10 15:30:21 2011 +0100

    PCI: Make the struct pci_dev * argument of pci_fixup_irqs const.
    
    Aside of the usual motivation for constification,  this function has a
    history of being abused a hook for interrupt and other fixups so I turned
    this function const ages ago in the MIPS code but it should be done
    treewide.
    
    Due to function pointer passing in varous places a few other functions
    had to be constified as well.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    To: Anton Vorontsov <avorontsov@mvista.com>
    To: Chris Metcalf <cmetcalf@tilera.com>
    To: Colin Cross <ccross@android.com>
    Acked-by: "David S. Miller" <davem@davemloft.net>
    To: Eric Miao <eric.y.miao@gmail.com>
    To: Erik Gilling <konkers@android.com>
    Acked-by: Guan Xuetao <gxt@mprc.pku.edu.cn>
    To: "H. Peter Anvin" <hpa@zytor.com>
    To: Imre Kaloz <kaloz@openwrt.org>
    To: Ingo Molnar <mingo@redhat.com>
    To: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    To: Jesse Barnes <jbarnes@virtuousgeek.org>
    To: Krzysztof Halasa <khc@pm.waw.pl>
    To: Lennert Buytenhek <kernel@wantstofly.org>
    To: Matt Turner <mattst88@gmail.com>
    To: Nicolas Pitre <nico@fluxnic.net>
    To: Olof Johansson <olof@lixom.net>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    To: Richard Henderson <rth@twiddle.net>
    To: Russell King <linux@arm.linux.org.uk>
    To: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: linux-alpha@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Cc: linux-pci@vger.kernel.org
    Cc: linux-sh@vger.kernel.org
    Cc: linux-tegra@vger.kernel.org
    Cc: sparclinux@vger.kernel.org
    Cc: x86@kernel.org
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 4418f9070ed1..4df27c4fbf99 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -466,7 +466,7 @@ static int __init pcie_init(struct sh7786_pcie_port *port)
 	return 0;
 }
 
-int __init pcibios_map_platform_irq(struct pci_dev *pdev, u8 slot, u8 pin)
+int __init pcibios_map_platform_irq(const struct pci_dev *pdev, u8 slot, u8 pin)
 {
         return 71;
 }

commit cd7bb53ff88a5acef942a87c1d04e6211b6470dc
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Jan 28 15:14:08 2011 +0900

    sh: Fix up async PCIe probing on SMP.
    
    For the SMP case we run in to a lockup without a full synchronization
    prior to continuing with the boot.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index ada2e6926f00..4418f9070ed1 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -571,6 +571,8 @@ static int __init sh7786_pcie_init(void)
 		async_schedule(sh7786_pcie_hwops->port_init_hw, port);
 	}
 
+	async_synchronize_full();
+
 	return 0;
 }
 arch_initcall(sh7786_pcie_init);

commit 1da09c43ce5f4fcd98143feb7d2513fe6fd62848
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jan 18 19:56:04 2011 +0900

    sh: pci: Support asynchronous initialization of SH-X3 PCIe channels.
    
    SH-X3 controllers all have pretty dire delays needed for PHY wakeup, so
    we attempt to mitigate the damage by bringing them up asynchronously,
    simply using the synchronization points for persistent bridge to channel
    numbering.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 96e9b058aa1d..ada2e6926f00 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -1,16 +1,19 @@
 /*
  * Low-Level PCI Express Support for the SH7786
  *
- *  Copyright (C) 2009 - 2010  Paul Mundt
+ *  Copyright (C) 2009 - 2011  Paul Mundt
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  */
+#define pr_fmt(fmt) "PCI: " fmt
+
 #include <linux/pci.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/io.h>
+#include <linux/async.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/clk.h>
@@ -31,7 +34,7 @@ static unsigned int nr_ports;
 
 static struct sh7786_pcie_hwops {
 	int (*core_init)(void);
-	int (*port_init_hw)(struct sh7786_pcie_port *port);
+	async_func_ptr *port_init_hw;
 } *sh7786_pcie_hwops;
 
 static struct resource sh7786_pci0_resources[] = {
@@ -474,8 +477,9 @@ static int __init sh7786_pcie_core_init(void)
 	return test_mode_pin(MODE_PIN12) ? 3 : 2;
 }
 
-static int __init sh7786_pcie_init_hw(struct sh7786_pcie_port *port)
+static void __init sh7786_pcie_init_hw(void *data, async_cookie_t cookie)
 {
+	struct sh7786_pcie_port *port = data;
 	int ret;
 
 	/*
@@ -488,18 +492,30 @@ static int __init sh7786_pcie_init_hw(struct sh7786_pcie_port *port)
 	 * Setup clocks, needed both for PHY and PCIe registers.
 	 */
 	ret = pcie_clk_init(port);
-	if (unlikely(ret < 0))
-		return ret;
+	if (unlikely(ret < 0)) {
+		pr_err("clock initialization failed for port#%d\n",
+		       port->index);
+		return;
+	}
 
 	ret = phy_init(port);
-	if (unlikely(ret < 0))
-		return ret;
+	if (unlikely(ret < 0)) {
+		pr_err("phy initialization failed for port#%d\n",
+		       port->index);
+		return;
+	}
 
 	ret = pcie_init(port);
-	if (unlikely(ret < 0))
-		return ret;
+	if (unlikely(ret < 0)) {
+		pr_err("core initialization failed for port#%d\n",
+			       port->index);
+		return;
+	}
 
-	return register_pci_controller(port->hose);
+	/* In the interest of preserving device ordering, synchronize */
+	async_synchronize_cookie(cookie);
+
+	register_pci_controller(port->hose);
 }
 
 static struct sh7786_pcie_hwops sh7786_65nm_pcie_hwops __initdata = {
@@ -510,7 +526,7 @@ static struct sh7786_pcie_hwops sh7786_65nm_pcie_hwops __initdata = {
 static int __init sh7786_pcie_init(void)
 {
 	struct clk *platclk;
-	int ret = 0, i;
+	int i;
 
 	printk(KERN_NOTICE "PCI: Starting initialization.\n");
 
@@ -552,13 +568,7 @@ static int __init sh7786_pcie_init(void)
 		port->hose		= sh7786_pci_channels + i;
 		port->hose->io_map_base	= port->hose->resources[0].start;
 
-		ret |= sh7786_pcie_hwops->port_init_hw(port);
-	}
-
-	if (unlikely(ret)) {
-		clk_disable(platclk);
-		clk_put(platclk);
-		return ret;
+		async_schedule(sh7786_pcie_hwops->port_init_hw, port);
 	}
 
 	return 0;

commit a80be1680502f99de5f9565c491208e90a9a3afe
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Oct 15 06:15:56 2010 +0900

    sh: pci: Convert to upper/lower_32_bits() helpers.
    
    Instead of hand-rolling our own, just use the generic ones instead.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index ae0b2c9b70a0..96e9b058aa1d 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -446,9 +446,9 @@ static int __init pcie_init(struct sh7786_pcie_port *port)
 		mask = (roundup_pow_of_two(size) / SZ_256K) - 1;
 		pci_write_reg(chan, mask << 18, SH4A_PCIEPAMR(win));
 
-		pci_write_reg(chan, RES_TO_U32_HIGH(res->start),
+		pci_write_reg(chan, upper_32_bits(res->start),
 			      SH4A_PCIEPARH(win));
-		pci_write_reg(chan, RES_TO_U32_LOW(res->start),
+		pci_write_reg(chan, lower_32_bits(res->start),
 			      SH4A_PCIEPARL(win));
 
 		mask = MASK_PARE;

commit b6b77b2d5ffd2f8ee74fcc27661f7f4962c34705
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Oct 14 08:44:55 2010 +0900

    sh: pci: Support secondary FPGA-driven PCIe clocks on SDK7786.
    
    The SDK7786 FPGA has secondary control over the PCIe clocks, specifically
    relating to the slots and oscillator. This ties the FPGA clocks in to the
    clock framework and balances the refcounting similar to how the primary
    on-chip clocks are managed. While the on-chip clocks are per-port, the
    FPGA clock enable/disable is global for the entire block.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 8ec4af197388..ae0b2c9b70a0 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -17,7 +17,6 @@
 #include <linux/sh_clk.h>
 #include "pcie-sh7786.h"
 #include <asm/sizes.h>
-#include <asm/clock.h>
 
 struct sh7786_pcie_port {
 	struct pci_channel	*hose;
@@ -510,6 +509,7 @@ static struct sh7786_pcie_hwops sh7786_65nm_pcie_hwops __initdata = {
 
 static int __init sh7786_pcie_init(void)
 {
+	struct clk *platclk;
 	int ret = 0, i;
 
 	printk(KERN_NOTICE "PCI: Starting initialization.\n");
@@ -527,6 +527,22 @@ static int __init sh7786_pcie_init(void)
 	if (unlikely(!sh7786_pcie_ports))
 		return -ENOMEM;
 
+	/*
+	 * Fetch any optional platform clock associated with this block.
+	 *
+	 * This is a rather nasty hack for boards with spec-mocking FPGAs
+	 * that have a secondary set of clocks outside of the on-chip
+	 * ones that need to be accounted for before there is any chance
+	 * of touching the existing MSTP bits or CPG clocks.
+	 */
+	platclk = clk_get(NULL, "pcie_plat_clk");
+	if (IS_ERR(platclk)) {
+		/* Sane hardware should probably get a WARN_ON.. */
+		platclk = NULL;
+	}
+
+	clk_enable(platclk);
+
 	printk(KERN_NOTICE "PCI: probing %d ports.\n", nr_ports);
 
 	for (i = 0; i < nr_ports; i++) {
@@ -539,8 +555,11 @@ static int __init sh7786_pcie_init(void)
 		ret |= sh7786_pcie_hwops->port_init_hw(port);
 	}
 
-	if (unlikely(ret))
+	if (unlikely(ret)) {
+		clk_disable(platclk);
+		clk_put(platclk);
 		return ret;
+	}
 
 	return 0;
 }

commit c524ebf5a6b78d25219d64a05b3876cde719b5ff
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Sep 20 18:45:11 2010 +0900

    sh: pci: clock framework support for SH7786 PCIe.
    
    This gets each port handling its MSTP bit, as well as moving the PHY
    clock management in to the clock framework.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index b0ef380eff28..8ec4af197388 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -13,11 +13,15 @@
 #include <linux/io.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/sh_clk.h>
 #include "pcie-sh7786.h"
 #include <asm/sizes.h>
+#include <asm/clock.h>
 
 struct sh7786_pcie_port {
 	struct pci_channel	*hose;
+	struct clk		*fclk, phy_clk;
 	unsigned int		index;
 	int			endpoint;
 	int			link;
@@ -121,6 +125,10 @@ static struct pci_channel sh7786_pci_channels[] = {
 	DEFINE_CONTROLLER(0xfcc00000, 2),
 };
 
+static struct clk fixed_pciexclkp = {
+	.rate = 100000000,	/* 100 MHz reference clock */
+};
+
 static void __devinit sh7786_pci_fixup(struct pci_dev *dev)
 {
 	/*
@@ -139,7 +147,7 @@ static void __devinit sh7786_pci_fixup(struct pci_dev *dev)
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_RENESAS, PCI_DEVICE_ID_RENESAS_SH7786,
 			 sh7786_pci_fixup);
 
-static int phy_wait_for_ack(struct pci_channel *chan)
+static int __init phy_wait_for_ack(struct pci_channel *chan)
 {
 	unsigned int timeout = 100;
 
@@ -153,7 +161,7 @@ static int phy_wait_for_ack(struct pci_channel *chan)
 	return -ETIMEDOUT;
 }
 
-static int pci_wait_for_irq(struct pci_channel *chan, unsigned int mask)
+static int __init pci_wait_for_irq(struct pci_channel *chan, unsigned int mask)
 {
 	unsigned int timeout = 100;
 
@@ -167,8 +175,8 @@ static int pci_wait_for_irq(struct pci_channel *chan, unsigned int mask)
 	return -ETIMEDOUT;
 }
 
-static void phy_write_reg(struct pci_channel *chan, unsigned int addr,
-			  unsigned int lane, unsigned int data)
+static void __init phy_write_reg(struct pci_channel *chan, unsigned int addr,
+				 unsigned int lane, unsigned int data)
 {
 	unsigned long phyaddr;
 
@@ -188,15 +196,67 @@ static void phy_write_reg(struct pci_channel *chan, unsigned int addr,
 	phy_wait_for_ack(chan);
 }
 
-static int phy_init(struct pci_channel *chan)
+static int __init pcie_clk_init(struct sh7786_pcie_port *port)
+{
+	struct pci_channel *chan = port->hose;
+	struct clk *clk;
+	char fclk_name[16];
+	int ret;
+
+	/*
+	 * First register the fixed clock
+	 */
+	ret = clk_register(&fixed_pciexclkp);
+	if (unlikely(ret != 0))
+		return ret;
+
+	/*
+	 * Grab the port's function clock, which the PHY clock depends
+	 * on. clock lookups don't help us much at this point, since no
+	 * dev_id is available this early. Lame.
+	 */
+	snprintf(fclk_name, sizeof(fclk_name), "pcie%d_fck", port->index);
+
+	port->fclk = clk_get(NULL, fclk_name);
+	if (IS_ERR(port->fclk)) {
+		ret = PTR_ERR(port->fclk);
+		goto err_fclk;
+	}
+
+	clk_enable(port->fclk);
+
+	/*
+	 * And now, set up the PHY clock
+	 */
+	clk = &port->phy_clk;
+
+	memset(clk, 0, sizeof(struct clk));
+
+	clk->parent = &fixed_pciexclkp;
+	clk->enable_reg = (void __iomem *)(chan->reg_base + SH4A_PCIEPHYCTLR);
+	clk->enable_bit = BITS_CKE;
+
+	ret = sh_clk_mstp32_register(clk, 1);
+	if (unlikely(ret < 0))
+		goto err_phy;
+
+	return 0;
+
+err_phy:
+	clk_disable(port->fclk);
+	clk_put(port->fclk);
+err_fclk:
+	clk_unregister(&fixed_pciexclkp);
+
+	return ret;
+}
+
+static int __init phy_init(struct sh7786_pcie_port *port)
 {
-	unsigned long ctrl;
+	struct pci_channel *chan = port->hose;
 	unsigned int timeout = 100;
 
-	/* Enable clock */
-	ctrl = pci_read_reg(chan, SH4A_PCIEPHYCTLR);
-	ctrl |= (1 << BITS_CKE);
-	pci_write_reg(chan, ctrl, SH4A_PCIEPHYCTLR);
+	clk_enable(&port->phy_clk);
 
 	/* Initialize the phy */
 	phy_write_reg(chan, 0x60, 0xf, 0x004b008b);
@@ -212,9 +272,7 @@ static int phy_init(struct pci_channel *chan)
 	phy_write_reg(chan, 0x67, 0x1, 0x00000400);
 
 	/* Disable clock */
-	ctrl = pci_read_reg(chan, SH4A_PCIEPHYCTLR);
-	ctrl &= ~(1 << BITS_CKE);
-	pci_write_reg(chan, ctrl, SH4A_PCIEPHYCTLR);
+	clk_disable(&port->phy_clk);
 
 	while (timeout--) {
 		if (pci_read_reg(chan, SH4A_PCIEPHYSR))
@@ -226,7 +284,7 @@ static int phy_init(struct pci_channel *chan)
 	return -ETIMEDOUT;
 }
 
-static void pcie_reset(struct sh7786_pcie_port *port)
+static void __init pcie_reset(struct sh7786_pcie_port *port)
 {
 	struct pci_channel *chan = port->hose;
 
@@ -236,7 +294,7 @@ static void pcie_reset(struct sh7786_pcie_port *port)
 	pci_write_reg(chan, 0, SH4A_PCIETXVC0SR);
 }
 
-static int pcie_init(struct sh7786_pcie_port *port)
+static int __init pcie_init(struct sh7786_pcie_port *port)
 {
 	struct pci_channel *chan = port->hose;
 	unsigned int data;
@@ -411,26 +469,33 @@ int __init pcibios_map_platform_irq(struct pci_dev *pdev, u8 slot, u8 pin)
         return 71;
 }
 
-static int sh7786_pcie_core_init(void)
+static int __init sh7786_pcie_core_init(void)
 {
 	/* Return the number of ports */
 	return test_mode_pin(MODE_PIN12) ? 3 : 2;
 }
 
-static int __devinit sh7786_pcie_init_hw(struct sh7786_pcie_port *port)
+static int __init sh7786_pcie_init_hw(struct sh7786_pcie_port *port)
 {
 	int ret;
 
-	ret = phy_init(port->hose);
-	if (unlikely(ret < 0))
-		return ret;
-
 	/*
 	 * Check if we are configured in endpoint or root complex mode,
 	 * this is a fixed pin setting that applies to all PCIe ports.
 	 */
 	port->endpoint = test_mode_pin(MODE_PIN11);
 
+	/*
+	 * Setup clocks, needed both for PHY and PCIe registers.
+	 */
+	ret = pcie_clk_init(port);
+	if (unlikely(ret < 0))
+		return ret;
+
+	ret = phy_init(port);
+	if (unlikely(ret < 0))
+		return ret;
+
 	ret = pcie_init(port);
 	if (unlikely(ret < 0))
 		return ret;

commit cecf48e23fd9270053850643a56e8e791322e3d5
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Sep 20 17:10:02 2010 +0900

    sh: pci: Use I/O accessors consistently in SH7786 PCIe init code.
    
    Some of the existing code is flipping between __raw_xxx() and
    pci_{read,write}_reg(). As the latter are just wrappers for the former,
    flip over to using them consistently.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index aacd0fc4cdd5..b0ef380eff28 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -304,24 +304,24 @@ static int pcie_init(struct sh7786_pcie_port *port)
 	 * LAR1/LAMR1.
 	 */
 	if (memsize > SZ_512M) {
-		__raw_writel(memphys + SZ_512M, chan->reg_base + SH4A_PCIELAR1);
-		__raw_writel(((memsize - SZ_512M) - SZ_256) | 1,
-			     chan->reg_base + SH4A_PCIELAMR1);
+		pci_write_reg(chan, memphys + SZ_512M, SH4A_PCIELAR1);
+		pci_write_reg(chan, ((memsize - SZ_512M) - SZ_256) | 1,
+			      SH4A_PCIELAMR1);
 		memsize = SZ_512M;
 	} else {
 		/*
 		 * Otherwise just zero it out and disable it.
 		 */
-		__raw_writel(0, chan->reg_base + SH4A_PCIELAR1);
-		__raw_writel(0, chan->reg_base + SH4A_PCIELAMR1);
+		pci_write_reg(chan, 0, SH4A_PCIELAR1);
+		pci_write_reg(chan, 0, SH4A_PCIELAMR1);
 	}
 
 	/*
 	 * LAR0/LAMR0 covers up to the first 512MB, which is enough to
 	 * cover all of lowmem on most platforms.
 	 */
-	__raw_writel(memphys, chan->reg_base + SH4A_PCIELAR0);
-	__raw_writel((memsize - SZ_256) | 1, chan->reg_base + SH4A_PCIELAMR0);
+	pci_write_reg(chan, memphys, SH4A_PCIELAR0);
+	pci_write_reg(chan, (memsize - SZ_256) | 1, SH4A_PCIELAMR0);
 
 	/* Finish initialization */
 	data = pci_read_reg(chan, SH4A_PCIETCTLR);
@@ -370,7 +370,7 @@ static int pcie_init(struct sh7786_pcie_port *port)
 	for (i = win = 0; i < chan->nr_resources; i++) {
 		struct resource *res = chan->resources + i;
 		resource_size_t size;
-		u32 enable_mask;
+		u32 mask;
 
 		/*
 		 * We can't use the 32-bit mode windows in legacy 29-bit
@@ -381,23 +381,24 @@ static int pcie_init(struct sh7786_pcie_port *port)
 
 		pci_write_reg(chan, 0x00000000, SH4A_PCIEPTCTLR(win));
 
-		size = resource_size(res);
-
 		/*
 		 * The PAMR mask is calculated in units of 256kB, which
 		 * keeps things pretty simple.
 		 */
-		__raw_writel(((roundup_pow_of_two(size) / SZ_256K) - 1) << 18,
-			     chan->reg_base + SH4A_PCIEPAMR(win));
+		size = resource_size(res);
+		mask = (roundup_pow_of_two(size) / SZ_256K) - 1;
+		pci_write_reg(chan, mask << 18, SH4A_PCIEPAMR(win));
 
-		pci_write_reg(chan, res->start, SH4A_PCIEPARL(win));
-		pci_write_reg(chan, 0x00000000, SH4A_PCIEPARH(win));
+		pci_write_reg(chan, RES_TO_U32_HIGH(res->start),
+			      SH4A_PCIEPARH(win));
+		pci_write_reg(chan, RES_TO_U32_LOW(res->start),
+			      SH4A_PCIEPARL(win));
 
-		enable_mask = MASK_PARE;
+		mask = MASK_PARE;
 		if (res->flags & IORESOURCE_IO)
-			enable_mask |= MASK_SPC;
+			mask |= MASK_SPC;
 
-		pci_write_reg(chan, enable_mask, SH4A_PCIEPTCTLR(win));
+		pci_write_reg(chan, mask, SH4A_PCIEPTCTLR(win));
 
 		win++;
 	}

commit bd792aea441a3dcdede462486ab8c63045803844
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Sep 20 16:12:58 2010 +0900

    sh: pci: Support ports with disabled links on SH7786 PCIe.
    
    Presently we error out if a link is disabled and simply drop the port
    registration outright. This follows the PPC changes and simply reports on
    the link state on boot, leaving the port registered, in order to more
    easily deal with hotplug on future parts.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 21854ebbaa7c..aacd0fc4cdd5 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -341,9 +341,12 @@ static int pcie_init(struct sh7786_pcie_port *port)
 	data |= PCIEMACCTLR_SCR_DIS | (0xff << 16);
 	pci_write_reg(chan, data, SH4A_PCIEMACCTLR);
 
+	/*
+	 * This will timeout if we don't have a link, but we permit the
+	 * port to register anyways in order to support hotplug on future
+	 * hardware.
+	 */
 	ret = pci_wait_for_irq(chan, MASK_INT_TX_CTRL);
-	if (unlikely(ret != 0))
-		return -ENODEV;
 
 	data = pci_read_reg(chan, SH4A_PCIEPCICONF1);
 	data &= ~(PCI_STATUS_DEVSEL_MASK << 16);
@@ -356,9 +359,13 @@ static int pcie_init(struct sh7786_pcie_port *port)
 
 	wmb();
 
-	data = pci_read_reg(chan, SH4A_PCIEMACSR);
-	printk(KERN_NOTICE "PCI: PCIe#%d link width %d\n",
-	       port->index, (data >> 20) & 0x3f);
+	if (ret == 0) {
+		data = pci_read_reg(chan, SH4A_PCIEMACSR);
+		printk(KERN_NOTICE "PCI: PCIe#%d x%d link detected\n",
+		       port->index, (data >> 20) & 0x3f);
+	} else
+		printk(KERN_NOTICE "PCI: PCIe#%d link down\n",
+		       port->index);
 
 	for (i = win = 0; i < chan->nr_resources; i++) {
 		struct resource *res = chan->resources + i;

commit beb54ad9c6fb60901d9445056d40bdaccdc3e819
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Sep 20 16:00:42 2010 +0900

    sh: pci: Discard initial PCICONF4/5 settings for SH7786 PCIe.
    
    These settings are properly propagated by the hardware already, so
    there's no need to bother with them manually.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 3dfc250b897a..21854ebbaa7c 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -323,9 +323,6 @@ static int pcie_init(struct sh7786_pcie_port *port)
 	__raw_writel(memphys, chan->reg_base + SH4A_PCIELAR0);
 	__raw_writel((memsize - SZ_256) | 1, chan->reg_base + SH4A_PCIELAMR0);
 
-	__raw_writel(memphys, chan->reg_base + SH4A_PCIEPCICONF4);
-	__raw_writel(0, chan->reg_base + SH4A_PCIEPCICONF5);
-
 	/* Finish initialization */
 	data = pci_read_reg(chan, SH4A_PCIETCTLR);
 	data |= 0x1;

commit 2c65d75ec4dde5e619a462e70cdd7b67e0e64bb8
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Sep 20 15:39:54 2010 +0900

    sh: pci: Support root complex config accesses on SH7786 PCIe.
    
    The SH7786 PCIe is presently unable to enumerate itself in root complex
    mode, and has no visibility through either type 0 or type 1 accesses,
    despite having a mostly sensible extended config space for each port.
    Attempts to generate type 0 or type 1 config cycles result in completer
    aborts, so we're ultimately forced to use SuperHyway transactions
    instead.
    
    As each port has a single port <-> device mapping that resolves for any
    PCI_SLOT definition, we simply hijack devfn 0 for the SuperHyway
    transaction and bump up the devfn limit.
    
    With enumeration of the root complex now possible, we also need to insert
    an early fixup to hide the BARs from the kernel. With all of that done,
    it's now possible to use the pcieport services with all of the PCIe
    ports, which is the first step to power management support.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 4e6cf8804979..3dfc250b897a 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -121,6 +121,24 @@ static struct pci_channel sh7786_pci_channels[] = {
 	DEFINE_CONTROLLER(0xfcc00000, 2),
 };
 
+static void __devinit sh7786_pci_fixup(struct pci_dev *dev)
+{
+	/*
+	 * Prevent enumeration of root complex resources.
+	 */
+	if (pci_is_root_bus(dev->bus) && dev->devfn == 0) {
+		int i;
+
+		for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
+			dev->resource[i].start	= 0;
+			dev->resource[i].end	= 0;
+			dev->resource[i].flags	= 0;
+		}
+	}
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_RENESAS, PCI_DEVICE_ID_RENESAS_SH7786,
+			 sh7786_pci_fixup);
+
 static int phy_wait_for_ack(struct pci_channel *chan)
 {
 	unsigned int timeout = 100;
@@ -229,11 +247,12 @@ static int pcie_init(struct sh7786_pcie_port *port)
 	/* Begin initialization */
 	pcie_reset(port);
 
-	/* Initialize as type1. */
-	data = pci_read_reg(chan, SH4A_PCIEPCICONF3);
-	data &= ~(0x7f << 16);
-	data |= PCI_HEADER_TYPE_BRIDGE << 16;
-	pci_write_reg(chan, data, SH4A_PCIEPCICONF3);
+	/*
+	 * Initial header for port config space is type 1, set the device
+	 * class to match. Hardware takes care of propagating the IDSETR
+	 * settings, so there is no need to bother with a quirk.
+	 */
+	pci_write_reg(chan, PCI_CLASS_BRIDGE_PCI << 16, SH4A_PCIEIDSETR1);
 
 	/* Initialize default capabilities. */
 	data = pci_read_reg(chan, SH4A_PCIEEXPCAP0);

commit 81df84f4060f4f19c7e6f39c7c527a6098436a2a
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sun Sep 19 13:57:51 2010 +0900

    sh: pci: Give SH7786 PHY some time to settle.
    
    The spec suggests waiting up to 500ms for the PHY to settle before
    testing link state, but practice shows that 100ms is sufficient (this is
    the delay value we also use on the other SH-4A PCI controllers, too).
    This makes device detection much more reliable, although in the future it
    should be a bit faster to simply serialize with a TLP IRQ.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 5ae58ec025c8..4e6cf8804979 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -312,6 +312,9 @@ static int pcie_init(struct sh7786_pcie_port *port)
 	data |= 0x1;
 	pci_write_reg(chan, data, SH4A_PCIETCTLR);
 
+	/* Let things settle down a bit.. */
+	mdelay(100);
+
 	/* Enable DL_Active Interrupt generation */
 	data = pci_read_reg(chan, SH4A_PCIEDLINTENR);
 	data |= PCIEDLINTENR_DLL_ACT_ENABLE;

commit 52204705b2fef6cb70b49dfa19c363fc88e72bde
Merge: b9afa3e01527 1c3bb3871af5
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Sep 7 17:56:27 2010 +0900

    Merge branch 'sh/pci-express-integration'

commit 1c3bb3871af53a2a8620bc48b5535f6d83386773
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Sep 7 17:07:05 2010 +0900

    sh: Hook up 3rd memory window for all SH7786 PCIe channels.
    
    Now that the resource assignment issues are resolved, we can finally wire
    up the small third memory window -- in the future we may reclaim this for
    MSI.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index c1e862af9b63..5acbaa2dc08e 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -51,6 +51,7 @@ static struct resource sh7786_pci0_resources[] = {
 		.name	= "PCIe0 MEM 2",
 		.start	= 0xfe100000,
 		.end	= 0xfe100000 + SZ_1M - 1,
+		.flags	= IORESOURCE_MEM,
 	},
 };
 
@@ -74,6 +75,7 @@ static struct resource sh7786_pci1_resources[] = {
 		.name	= "PCIe1 MEM 2",
 		.start	= 0xfe300000,
 		.end	= 0xfe300000 + SZ_1M - 1,
+		.flags	= IORESOURCE_MEM,
 	},
 };
 
@@ -97,6 +99,7 @@ static struct resource sh7786_pci2_resources[] = {
 		.name	= "PCIe2 MEM 2",
 		.start	= 0xfcd00000,
 		.end	= 0xfcd00000 + SZ_1M - 1,
+		.flags	= IORESOURCE_MEM,
 	},
 };
 

commit f048519309dbaedd03807ddbb9fa22f5616cfd43
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Sep 7 17:05:08 2010 +0900

    sh: Properly wire up channel 2's I/O window on SH7786 PCIe.
    
    An IORESOURCE_IO was missing here, which meant that we weren't properly
    establishing the I/O window for this particular slot. With this
    corrected, cards with I/O BARs have them actually assigned and
    accessible.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 4f79fd9059e0..c1e862af9b63 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -82,6 +82,7 @@ static struct resource sh7786_pci2_resources[] = {
 		.name	= "PCIe2 IO",
 		.start	= 0xfc800000,
 		.end	= 0xfc800000 + SZ_4M - 1,
+		.flags	= IORESOURCE_IO,
 	}, {
 		.name	= "PCIe2 MEM 0",
 		.start	= 0x80000000,

commit da03a63ac843711887a85e5d90dd69399b1b9164
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Sep 7 17:03:10 2010 +0900

    sh: Ignore 32-bit windows in 29-bit mode for SH7786 PCIe.
    
    Certain memory windows are only available for 32-bit space, so skip over
    these in 29-bit mode. This will severely restrict the amount of memory
    that can be mapped, but since a boot loader bug makes booting in 29-bit
    mode close to impossible anyways, everything is ok.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 4cd83140579b..4f79fd9059e0 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -220,7 +220,7 @@ static int pcie_init(struct sh7786_pcie_port *port)
 	unsigned int data;
 	phys_addr_t memphys;
 	size_t memsize;
-	int ret, i;
+	int ret, i, win;
 
 	/* Begin initialization */
 	pcie_reset(port);
@@ -337,13 +337,19 @@ static int pcie_init(struct sh7786_pcie_port *port)
 	printk(KERN_NOTICE "PCI: PCIe#%d link width %d\n",
 	       port->index, (data >> 20) & 0x3f);
 
-
-	for (i = 0; i < chan->nr_resources; i++) {
+	for (i = win = 0; i < chan->nr_resources; i++) {
 		struct resource *res = chan->resources + i;
 		resource_size_t size;
 		u32 enable_mask;
 
-		pci_write_reg(chan, 0x00000000, SH4A_PCIEPTCTLR(i));
+		/*
+		 * We can't use the 32-bit mode windows in legacy 29-bit
+		 * mode, so just skip them entirely.
+		 */
+		if ((res->flags & IORESOURCE_MEM_32BIT) && __in_29bit_mode())
+			continue;
+
+		pci_write_reg(chan, 0x00000000, SH4A_PCIEPTCTLR(win));
 
 		size = resource_size(res);
 
@@ -352,16 +358,18 @@ static int pcie_init(struct sh7786_pcie_port *port)
 		 * keeps things pretty simple.
 		 */
 		__raw_writel(((roundup_pow_of_two(size) / SZ_256K) - 1) << 18,
-			     chan->reg_base + SH4A_PCIEPAMR(i));
+			     chan->reg_base + SH4A_PCIEPAMR(win));
 
-		pci_write_reg(chan, res->start, SH4A_PCIEPARL(i));
-		pci_write_reg(chan, 0x00000000, SH4A_PCIEPARH(i));
+		pci_write_reg(chan, res->start, SH4A_PCIEPARL(win));
+		pci_write_reg(chan, 0x00000000, SH4A_PCIEPARH(win));
 
 		enable_mask = MASK_PARE;
 		if (res->flags & IORESOURCE_IO)
 			enable_mask |= MASK_SPC;
 
-		pci_write_reg(chan, enable_mask, SH4A_PCIEPTCTLR(i));
+		pci_write_reg(chan, enable_mask, SH4A_PCIEPTCTLR(win));
+
+		win++;
 	}
 
 	return 0;

commit 2c5f674339d5e4c02cca7af13ec02bd9b5a96b60
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Sep 7 16:12:26 2010 +0900

    sh: Establish a SuperHyway<->PCIe window mapping on SH7786 PCIe.
    
    This bumps up the low address to match the physical memory windows for
    SHway<->PCIe transfers. The previous implementation was banking on a 1:1
    virt<->phys SHway mapping, which doesn't apply here.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 40b0ed042236..4cd83140579b 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -354,8 +354,8 @@ static int pcie_init(struct sh7786_pcie_port *port)
 		__raw_writel(((roundup_pow_of_two(size) / SZ_256K) - 1) << 18,
 			     chan->reg_base + SH4A_PCIEPAMR(i));
 
+		pci_write_reg(chan, res->start, SH4A_PCIEPARL(i));
 		pci_write_reg(chan, 0x00000000, SH4A_PCIEPARH(i));
-		pci_write_reg(chan, 0x00000000, SH4A_PCIEPARL(i));
 
 		enable_mask = MASK_PARE;
 		if (res->flags & IORESOURCE_IO)

commit 2dbfa1e37dc703631d5421e0b04aecc5a7aff37d
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Sep 7 16:11:04 2010 +0900

    sh: Make SH7786 PCIe port reset logic more aggressive.
    
    This attempts a more complete port reset, building on top of the existing
    approach.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 03e6d8217b0c..40b0ed042236 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -204,6 +204,16 @@ static int phy_init(struct pci_channel *chan)
 	return -ETIMEDOUT;
 }
 
+static void pcie_reset(struct sh7786_pcie_port *port)
+{
+	struct pci_channel *chan = port->hose;
+
+	pci_write_reg(chan, 1, SH4A_PCIESRSTR);
+	pci_write_reg(chan, 0, SH4A_PCIETCTLR);
+	pci_write_reg(chan, 0, SH4A_PCIESRSTR);
+	pci_write_reg(chan, 0, SH4A_PCIETXVC0SR);
+}
+
 static int pcie_init(struct sh7786_pcie_port *port)
 {
 	struct pci_channel *chan = port->hose;
@@ -213,7 +223,7 @@ static int pcie_init(struct sh7786_pcie_port *port)
 	int ret, i;
 
 	/* Begin initialization */
-	pci_write_reg(chan, 0, SH4A_PCIETCTLR);
+	pcie_reset(port);
 
 	/* Initialize as type1. */
 	data = pci_read_reg(chan, SH4A_PCIEPCICONF3);

commit 144c7494239f12d554806439a17ad8203c7b2d3a
Merge: d2d5bc58d793 65c23f54c01f
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Aug 20 20:39:22 2010 +0900

    Merge branch 'sh/pci-express-integration'

commit 53178d71b9f2d5c96bfcd2dd2c4b99c4e95a77d5
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Aug 20 16:04:59 2010 +0900

    sh: Fix up SH7786 PCIe PHY initialization.
    
    This brings the clocking and register setting in line with the somewhat
    factually ambiguous specification.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 68cb9b0ac9d2..03e6d8217b0c 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -148,16 +148,11 @@ static int pci_wait_for_irq(struct pci_channel *chan, unsigned int mask)
 static void phy_write_reg(struct pci_channel *chan, unsigned int addr,
 			  unsigned int lane, unsigned int data)
 {
-	unsigned long phyaddr, ctrl;
+	unsigned long phyaddr;
 
 	phyaddr = (1 << BITS_CMD) + ((lane & 0xf) << BITS_LANE) +
 			((addr & 0xff) << BITS_ADR);
 
-	/* Enable clock */
-	ctrl = pci_read_reg(chan, SH4A_PCIEPHYCTLR);
-	ctrl |= (1 << BITS_CKE);
-	pci_write_reg(chan, ctrl, SH4A_PCIEPHYCTLR);
-
 	/* Set write data */
 	pci_write_reg(chan, data, SH4A_PCIEPHYDOUTR);
 	pci_write_reg(chan, phyaddr, SH4A_PCIEPHYADRR);
@@ -165,20 +160,22 @@ static void phy_write_reg(struct pci_channel *chan, unsigned int addr,
 	phy_wait_for_ack(chan);
 
 	/* Clear command */
+	pci_write_reg(chan, 0, SH4A_PCIEPHYDOUTR);
 	pci_write_reg(chan, 0, SH4A_PCIEPHYADRR);
 
 	phy_wait_for_ack(chan);
-
-	/* Disable clock */
-	ctrl = pci_read_reg(chan, SH4A_PCIEPHYCTLR);
-	ctrl &= ~(1 << BITS_CKE);
-	pci_write_reg(chan, ctrl, SH4A_PCIEPHYCTLR);
 }
 
 static int phy_init(struct pci_channel *chan)
 {
+	unsigned long ctrl;
 	unsigned int timeout = 100;
 
+	/* Enable clock */
+	ctrl = pci_read_reg(chan, SH4A_PCIEPHYCTLR);
+	ctrl |= (1 << BITS_CKE);
+	pci_write_reg(chan, ctrl, SH4A_PCIEPHYCTLR);
+
 	/* Initialize the phy */
 	phy_write_reg(chan, 0x60, 0xf, 0x004b008b);
 	phy_write_reg(chan, 0x61, 0xf, 0x00007b41);
@@ -187,9 +184,15 @@ static int phy_init(struct pci_channel *chan)
 	phy_write_reg(chan, 0x66, 0xf, 0x00000010);
 	phy_write_reg(chan, 0x74, 0xf, 0x0007001c);
 	phy_write_reg(chan, 0x79, 0xf, 0x01fc000d);
+	phy_write_reg(chan, 0xb0, 0xf, 0x00000610);
 
 	/* Deassert Standby */
-	phy_write_reg(chan, 0x67, 0xf, 0x00000400);
+	phy_write_reg(chan, 0x67, 0x1, 0x00000400);
+
+	/* Disable clock */
+	ctrl = pci_read_reg(chan, SH4A_PCIEPHYCTLR);
+	ctrl &= ~(1 << BITS_CKE);
+	pci_write_reg(chan, ctrl, SH4A_PCIEPHYCTLR);
 
 	while (timeout--) {
 		if (pci_read_reg(chan, SH4A_PCIEPHYSR))
@@ -287,6 +290,9 @@ static int pcie_init(struct sh7786_pcie_port *port)
 	__raw_writel(memphys, chan->reg_base + SH4A_PCIELAR0);
 	__raw_writel((memsize - SZ_256) | 1, chan->reg_base + SH4A_PCIELAMR0);
 
+	__raw_writel(memphys, chan->reg_base + SH4A_PCIEPCICONF4);
+	__raw_writel(0, chan->reg_base + SH4A_PCIEPCICONF5);
+
 	/* Finish initialization */
 	data = pci_read_reg(chan, SH4A_PCIETCTLR);
 	data |= 0x1;

commit 3b554c33dcde9d67efcb8d0a5acca201afd44730
Author: Matt Fleming <matt@console-pimps.org>
Date:   Sat Jun 19 00:01:03 2010 +0100

    sh: Fix typos in PCI initialization message
    
    This typo seems to have been copy and pasted in the PCI initialization
    code. Replace 'intialization' with 'initialization'.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 68cb9b0ac9d2..78f378731858 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -392,7 +392,7 @@ static int __init sh7786_pcie_init(void)
 {
 	int ret = 0, i;
 
-	printk(KERN_NOTICE "PCI: Starting intialization.\n");
+	printk(KERN_NOTICE "PCI: Starting initialization.\n");
 
 	sh7786_pcie_hwops = &sh7786_65nm_pcie_hwops;
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index ae91a2dd9183..68cb9b0ac9d2 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -12,6 +12,7 @@
 #include <linux/kernel.h>
 #include <linux/io.h>
 #include <linux/delay.h>
+#include <linux/slab.h>
 #include "pcie-sh7786.h"
 #include <asm/sizes.h>
 

commit 7578a4c625a5cc32812946338a4549f3090be113
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Feb 10 16:00:58 2010 +0900

    sh: Fix up multi-resource mapping for SH7786 PCIe.
    
    This reworks some of the SH7786 PCIe initialization code to dynamically
    setup and size the various resource windows, as opposed to the original
    code that simply wired in a couple of them statically.
    
    At the same time, we tidy up the initialization code a bit, kill off some
    read-only register twiddling that was gleaned from the bus analyzer, and
    also propagate the physical slot/channel mapping.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index 95d095f26d66..ae91a2dd9183 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -204,7 +204,9 @@ static int pcie_init(struct sh7786_pcie_port *port)
 {
 	struct pci_channel *chan = port->hose;
 	unsigned int data;
-	int ret;
+	phys_addr_t memphys;
+	size_t memsize;
+	int ret, i;
 
 	/* Begin initialization */
 	pci_write_reg(chan, 0, SH4A_PCIETCTLR);
@@ -227,15 +229,24 @@ static int pcie_init(struct sh7786_pcie_port *port)
 	data |= PCI_CAP_ID_EXP;
 	pci_write_reg(chan, data, SH4A_PCIEEXPCAP0);
 
-	/* Enable x4 link width and extended sync. */
+	/* Enable data link layer active state reporting */
+	pci_write_reg(chan, PCI_EXP_LNKCAP_DLLLARC, SH4A_PCIEEXPCAP3);
+
+	/* Enable extended sync and ASPM L0s support */
 	data = pci_read_reg(chan, SH4A_PCIEEXPCAP4);
-	data &= ~(PCI_EXP_LNKSTA_NLW << 16);
-	data |= (1 << 22) | PCI_EXP_LNKCTL_ES;
+	data &= ~PCI_EXP_LNKCTL_ASPMC;
+	data |= PCI_EXP_LNKCTL_ES | 1;
 	pci_write_reg(chan, data, SH4A_PCIEEXPCAP4);
 
+	/* Write out the physical slot number */
+	data = pci_read_reg(chan, SH4A_PCIEEXPCAP5);
+	data &= ~PCI_EXP_SLTCAP_PSN;
+	data |= (port->index + 1) << 19;
+	pci_write_reg(chan, data, SH4A_PCIEEXPCAP5);
+
 	/* Set the completion timer timeout to the maximum 32ms. */
 	data = pci_read_reg(chan, SH4A_PCIETLCTLR);
-	data &= ~0xffff;
+	data &= ~0x3f00;
 	data |= 0x32 << 8;
 	pci_write_reg(chan, data, SH4A_PCIETLCTLR);
 
@@ -248,6 +259,33 @@ static int pcie_init(struct sh7786_pcie_port *port)
 	data |= (0xff << 16);
 	pci_write_reg(chan, data, SH4A_PCIEMACCTLR);
 
+	memphys = __pa(memory_start);
+	memsize = roundup_pow_of_two(memory_end - memory_start);
+
+	/*
+	 * If there's more than 512MB of memory, we need to roll over to
+	 * LAR1/LAMR1.
+	 */
+	if (memsize > SZ_512M) {
+		__raw_writel(memphys + SZ_512M, chan->reg_base + SH4A_PCIELAR1);
+		__raw_writel(((memsize - SZ_512M) - SZ_256) | 1,
+			     chan->reg_base + SH4A_PCIELAMR1);
+		memsize = SZ_512M;
+	} else {
+		/*
+		 * Otherwise just zero it out and disable it.
+		 */
+		__raw_writel(0, chan->reg_base + SH4A_PCIELAR1);
+		__raw_writel(0, chan->reg_base + SH4A_PCIELAMR1);
+	}
+
+	/*
+	 * LAR0/LAMR0 covers up to the first 512MB, which is enough to
+	 * cover all of lowmem on most platforms.
+	 */
+	__raw_writel(memphys, chan->reg_base + SH4A_PCIELAR0);
+	__raw_writel((memsize - SZ_256) | 1, chan->reg_base + SH4A_PCIELAMR0);
+
 	/* Finish initialization */
 	data = pci_read_reg(chan, SH4A_PCIETCTLR);
 	data |= 0x1;
@@ -267,10 +305,14 @@ static int pcie_init(struct sh7786_pcie_port *port)
 	if (unlikely(ret != 0))
 		return -ENODEV;
 
-	pci_write_reg(chan, 0x00100007, SH4A_PCIEPCICONF1);
+	data = pci_read_reg(chan, SH4A_PCIEPCICONF1);
+	data &= ~(PCI_STATUS_DEVSEL_MASK << 16);
+	data |= PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER |
+		(PCI_STATUS_CAP_LIST | PCI_STATUS_DEVSEL_FAST) << 16;
+	pci_write_reg(chan, data, SH4A_PCIEPCICONF1);
+
 	pci_write_reg(chan, 0x80888000, SH4A_PCIETXVC0DCTLR);
 	pci_write_reg(chan, 0x00222000, SH4A_PCIERXVC0DCTLR);
-	pci_write_reg(chan, 0x000050A0, SH4A_PCIEEXPCAP2);
 
 	wmb();
 
@@ -278,15 +320,32 @@ static int pcie_init(struct sh7786_pcie_port *port)
 	printk(KERN_NOTICE "PCI: PCIe#%d link width %d\n",
 	       port->index, (data >> 20) & 0x3f);
 
-	pci_write_reg(chan, 0x007c0000, SH4A_PCIEPAMR0);
-	pci_write_reg(chan, 0x00000000, SH4A_PCIEPARH0);
-	pci_write_reg(chan, 0x00000000, SH4A_PCIEPARL0);
-	pci_write_reg(chan, 0x80000100, SH4A_PCIEPTCTLR0);
 
-	pci_write_reg(chan, 0x03fc0000, SH4A_PCIEPAMR2);
-	pci_write_reg(chan, 0x00000000, SH4A_PCIEPARH2);
-	pci_write_reg(chan, 0x00000000, SH4A_PCIEPARL2);
-	pci_write_reg(chan, 0x80000000, SH4A_PCIEPTCTLR2);
+	for (i = 0; i < chan->nr_resources; i++) {
+		struct resource *res = chan->resources + i;
+		resource_size_t size;
+		u32 enable_mask;
+
+		pci_write_reg(chan, 0x00000000, SH4A_PCIEPTCTLR(i));
+
+		size = resource_size(res);
+
+		/*
+		 * The PAMR mask is calculated in units of 256kB, which
+		 * keeps things pretty simple.
+		 */
+		__raw_writel(((roundup_pow_of_two(size) / SZ_256K) - 1) << 18,
+			     chan->reg_base + SH4A_PCIEPAMR(i));
+
+		pci_write_reg(chan, 0x00000000, SH4A_PCIEPARH(i));
+		pci_write_reg(chan, 0x00000000, SH4A_PCIEPARL(i));
+
+		enable_mask = MASK_PARE;
+		if (res->flags & IORESOURCE_IO)
+			enable_mask |= MASK_SPC;
+
+		pci_write_reg(chan, enable_mask, SH4A_PCIEPTCTLR(i));
+	}
 
 	return 0;
 }

commit 7561f2dd393bd0c6397e6b2a6b021cdb827a2eb1
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Feb 8 16:36:56 2010 +0900

    sh: Fix up SH7786 PCI resource definitions.
    
    This adds in some of the missing memory resources for channels 1/2 and
    gets the code building again for the recent changes.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index feac1fef21eb..95d095f26d66 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -1,7 +1,7 @@
 /*
  * Low-Level PCI Express Support for the SH7786
  *
- *  Copyright (C) 2009  Paul Mundt
+ *  Copyright (C) 2009 - 2010  Paul Mundt
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -30,60 +30,84 @@ static struct sh7786_pcie_hwops {
 	int (*port_init_hw)(struct sh7786_pcie_port *port);
 } *sh7786_pcie_hwops;
 
-static struct resource sh7786_pci_32bit_mem_resources[] = {
+static struct resource sh7786_pci0_resources[] = {
 	{
-		.name	= "pci0_mem",
-		.start	= SH4A_PCIMEM_BASEA,
-		.end	= SH4A_PCIMEM_BASEA + SZ_64M - 1,
-		.flags	= IORESOURCE_MEM,
+		.name	= "PCIe0 IO",
+		.start	= 0xfd000000,
+		.end	= 0xfd000000 + SZ_8M - 1,
+		.flags	= IORESOURCE_IO,
 	}, {
-		.name	= "pci1_mem",
-		.start	= SH4A_PCIMEM_BASEA1,
-		.end	= SH4A_PCIMEM_BASEA1 + SZ_64M - 1,
-		.flags	= IORESOURCE_MEM,
+		.name	= "PCIe0 MEM 0",
+		.start	= 0xc0000000,
+		.end	= 0xc0000000 + SZ_512M - 1,
+		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
 	}, {
-		.name	= "pci2_mem",
-		.start	= SH4A_PCIMEM_BASEA2,
-		.end	= SH4A_PCIMEM_BASEA2 + SZ_64M - 1,
+		.name	= "PCIe0 MEM 1",
+		.start	= 0x10000000,
+		.end	= 0x10000000 + SZ_64M - 1,
 		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "PCIe0 MEM 2",
+		.start	= 0xfe100000,
+		.end	= 0xfe100000 + SZ_1M - 1,
 	},
 };
 
-static struct resource sh7786_pci_29bit_mem_resource = {
-	.start	= SH4A_PCIMEM_BASE,
-	.end	= SH4A_PCIMEM_BASE + SZ_64M - 1,
-	.flags	= IORESOURCE_MEM,
+static struct resource sh7786_pci1_resources[] = {
+	{
+		.name	= "PCIe1 IO",
+		.start	= 0xfd800000,
+		.end	= 0xfd800000 + SZ_8M - 1,
+		.flags	= IORESOURCE_IO,
+	}, {
+		.name	= "PCIe1 MEM 0",
+		.start	= 0xa0000000,
+		.end	= 0xa0000000 + SZ_512M - 1,
+		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
+	}, {
+		.name	= "PCIe1 MEM 1",
+		.start	= 0x30000000,
+		.end	= 0x30000000 + SZ_256M - 1,
+		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
+	}, {
+		.name	= "PCIe1 MEM 2",
+		.start	= 0xfe300000,
+		.end	= 0xfe300000 + SZ_1M - 1,
+	},
 };
 
-static struct resource sh7786_pci_io_resources[] = {
+static struct resource sh7786_pci2_resources[] = {
 	{
-		.name	= "pci0_io",
-		.start	= SH4A_PCIIO_BASE,
-		.end	= SH4A_PCIIO_BASE + SZ_8M - 1,
-		.flags	= IORESOURCE_IO,
+		.name	= "PCIe2 IO",
+		.start	= 0xfc800000,
+		.end	= 0xfc800000 + SZ_4M - 1,
 	}, {
-		.name	= "pci1_io",
-		.start	= SH4A_PCIIO_BASE1,
-		.end	= SH4A_PCIIO_BASE1 + SZ_8M - 1,
-		.flags	= IORESOURCE_IO,
+		.name	= "PCIe2 MEM 0",
+		.start	= 0x80000000,
+		.end	= 0x80000000 + SZ_512M - 1,
+		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
 	}, {
-		.name	= "pci2_io",
-		.start	= SH4A_PCIIO_BASE2,
-		.end	= SH4A_PCIIO_BASE2 + SZ_4M - 1,
-		.flags	= IORESOURCE_IO,
+		.name	= "PCIe2 MEM 1",
+		.start	= 0x20000000,
+		.end	= 0x20000000 + SZ_256M - 1,
+		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
+	}, {
+		.name	= "PCIe2 MEM 2",
+		.start	= 0xfcd00000,
+		.end	= 0xfcd00000 + SZ_1M - 1,
 	},
 };
 
 extern struct pci_ops sh7786_pci_ops;
 
-#define DEFINE_CONTROLLER(start, idx)				\
-{								\
-	.pci_ops	= &sh7786_pci_ops,			\
-	.reg_base	= start,				\
-	/* mem_resource filled in at probe time */		\
-	.mem_offset	= 0,					\
-	.io_resource	= &sh7786_pci_io_resources[idx],	\
-	.io_offset	= 0,					\
+#define DEFINE_CONTROLLER(start, idx)					\
+{									\
+	.pci_ops	= &sh7786_pci_ops,				\
+	.resources	= sh7786_pci##idx##_resources,			\
+	.nr_resources	= ARRAY_SIZE(sh7786_pci##idx##_resources),	\
+	.reg_base	= start,					\
+	.mem_offset	= 0,						\
+	.io_offset	= 0,						\
 }
 
 static struct pci_channel sh7786_pci_channels[] = {
@@ -330,17 +354,7 @@ static int __init sh7786_pcie_init(void)
 
 		port->index		= i;
 		port->hose		= sh7786_pci_channels + i;
-		port->hose->io_map_base	= port->hose->io_resource->start;
-
-		/*
-		 * Check if we are booting in 29 or 32-bit mode
-		 *
-		 * 32-bit mode provides each controller with its own
-		 * memory window, while 29-bit mode uses a shared one.
-		 */
-		port->hose->mem_resource = test_mode_pin(MODE_PIN10) ?
-			&sh7786_pci_32bit_mem_resources[i] :
-			&sh7786_pci_29bit_mem_resource;
+		port->hose->io_map_base	= port->hose->resources[0].start;
 
 		ret |= sh7786_pcie_hwops->port_init_hw(port);
 	}

commit bcf39352eb9e9026f7a1028d4bce3707b65f104b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Feb 1 13:11:25 2010 +0900

    sh: Handle PCI controller resource conflicts.
    
    register_pci_controller() can fail, but presently is a void function.
    Change this over to an int so that we can bail early before continuing on
    with post-registration initialization (such as throwing the controller in
    to 66MHz mode in the case of the SH7780 host controller).
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index ac37ee879bab..feac1fef21eb 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -296,9 +296,7 @@ static int __devinit sh7786_pcie_init_hw(struct sh7786_pcie_port *port)
 	if (unlikely(ret < 0))
 		return ret;
 
-	register_pci_controller(port->hose);
-
-	return 0;
+	return register_pci_controller(port->hose);
 }
 
 static struct sh7786_pcie_hwops sh7786_65nm_pcie_hwops __initdata = {

commit 5713e602106545ff601c158d0864ce8e79de6d0a
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Jun 17 18:20:48 2009 +0900

    sh: pci: Initial PCI-Express support for SH7786 Urquell board.
    
    This adds initial support for the PCI-Express module in the SH7786,
    particularly as it relates to the urquell platform. Presently it is
    only supported in root complex mode, with endpoint mode still requiring
    more debugging. 29/32-bit mode and lane configurations are selectable via
    board mode pins, and are otherwise fixed.
    
    Only 4x and 1x PCI channels are presently handled, the PCI bridge still
    requires additional debugging and stabilization in hardware.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
new file mode 100644
index 000000000000..ac37ee879bab
--- /dev/null
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -0,0 +1,355 @@
+/*
+ * Low-Level PCI Express Support for the SH7786
+ *
+ *  Copyright (C) 2009  Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include "pcie-sh7786.h"
+#include <asm/sizes.h>
+
+struct sh7786_pcie_port {
+	struct pci_channel	*hose;
+	unsigned int		index;
+	int			endpoint;
+	int			link;
+};
+
+static struct sh7786_pcie_port *sh7786_pcie_ports;
+static unsigned int nr_ports;
+
+static struct sh7786_pcie_hwops {
+	int (*core_init)(void);
+	int (*port_init_hw)(struct sh7786_pcie_port *port);
+} *sh7786_pcie_hwops;
+
+static struct resource sh7786_pci_32bit_mem_resources[] = {
+	{
+		.name	= "pci0_mem",
+		.start	= SH4A_PCIMEM_BASEA,
+		.end	= SH4A_PCIMEM_BASEA + SZ_64M - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "pci1_mem",
+		.start	= SH4A_PCIMEM_BASEA1,
+		.end	= SH4A_PCIMEM_BASEA1 + SZ_64M - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "pci2_mem",
+		.start	= SH4A_PCIMEM_BASEA2,
+		.end	= SH4A_PCIMEM_BASEA2 + SZ_64M - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct resource sh7786_pci_29bit_mem_resource = {
+	.start	= SH4A_PCIMEM_BASE,
+	.end	= SH4A_PCIMEM_BASE + SZ_64M - 1,
+	.flags	= IORESOURCE_MEM,
+};
+
+static struct resource sh7786_pci_io_resources[] = {
+	{
+		.name	= "pci0_io",
+		.start	= SH4A_PCIIO_BASE,
+		.end	= SH4A_PCIIO_BASE + SZ_8M - 1,
+		.flags	= IORESOURCE_IO,
+	}, {
+		.name	= "pci1_io",
+		.start	= SH4A_PCIIO_BASE1,
+		.end	= SH4A_PCIIO_BASE1 + SZ_8M - 1,
+		.flags	= IORESOURCE_IO,
+	}, {
+		.name	= "pci2_io",
+		.start	= SH4A_PCIIO_BASE2,
+		.end	= SH4A_PCIIO_BASE2 + SZ_4M - 1,
+		.flags	= IORESOURCE_IO,
+	},
+};
+
+extern struct pci_ops sh7786_pci_ops;
+
+#define DEFINE_CONTROLLER(start, idx)				\
+{								\
+	.pci_ops	= &sh7786_pci_ops,			\
+	.reg_base	= start,				\
+	/* mem_resource filled in at probe time */		\
+	.mem_offset	= 0,					\
+	.io_resource	= &sh7786_pci_io_resources[idx],	\
+	.io_offset	= 0,					\
+}
+
+static struct pci_channel sh7786_pci_channels[] = {
+	DEFINE_CONTROLLER(0xfe000000, 0),
+	DEFINE_CONTROLLER(0xfe200000, 1),
+	DEFINE_CONTROLLER(0xfcc00000, 2),
+};
+
+static int phy_wait_for_ack(struct pci_channel *chan)
+{
+	unsigned int timeout = 100;
+
+	while (timeout--) {
+		if (pci_read_reg(chan, SH4A_PCIEPHYADRR) & (1 << BITS_ACK))
+			return 0;
+
+		udelay(100);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static int pci_wait_for_irq(struct pci_channel *chan, unsigned int mask)
+{
+	unsigned int timeout = 100;
+
+	while (timeout--) {
+		if ((pci_read_reg(chan, SH4A_PCIEINTR) & mask) == mask)
+			return 0;
+
+		udelay(100);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static void phy_write_reg(struct pci_channel *chan, unsigned int addr,
+			  unsigned int lane, unsigned int data)
+{
+	unsigned long phyaddr, ctrl;
+
+	phyaddr = (1 << BITS_CMD) + ((lane & 0xf) << BITS_LANE) +
+			((addr & 0xff) << BITS_ADR);
+
+	/* Enable clock */
+	ctrl = pci_read_reg(chan, SH4A_PCIEPHYCTLR);
+	ctrl |= (1 << BITS_CKE);
+	pci_write_reg(chan, ctrl, SH4A_PCIEPHYCTLR);
+
+	/* Set write data */
+	pci_write_reg(chan, data, SH4A_PCIEPHYDOUTR);
+	pci_write_reg(chan, phyaddr, SH4A_PCIEPHYADRR);
+
+	phy_wait_for_ack(chan);
+
+	/* Clear command */
+	pci_write_reg(chan, 0, SH4A_PCIEPHYADRR);
+
+	phy_wait_for_ack(chan);
+
+	/* Disable clock */
+	ctrl = pci_read_reg(chan, SH4A_PCIEPHYCTLR);
+	ctrl &= ~(1 << BITS_CKE);
+	pci_write_reg(chan, ctrl, SH4A_PCIEPHYCTLR);
+}
+
+static int phy_init(struct pci_channel *chan)
+{
+	unsigned int timeout = 100;
+
+	/* Initialize the phy */
+	phy_write_reg(chan, 0x60, 0xf, 0x004b008b);
+	phy_write_reg(chan, 0x61, 0xf, 0x00007b41);
+	phy_write_reg(chan, 0x64, 0xf, 0x00ff4f00);
+	phy_write_reg(chan, 0x65, 0xf, 0x09070907);
+	phy_write_reg(chan, 0x66, 0xf, 0x00000010);
+	phy_write_reg(chan, 0x74, 0xf, 0x0007001c);
+	phy_write_reg(chan, 0x79, 0xf, 0x01fc000d);
+
+	/* Deassert Standby */
+	phy_write_reg(chan, 0x67, 0xf, 0x00000400);
+
+	while (timeout--) {
+		if (pci_read_reg(chan, SH4A_PCIEPHYSR))
+			return 0;
+
+		udelay(100);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static int pcie_init(struct sh7786_pcie_port *port)
+{
+	struct pci_channel *chan = port->hose;
+	unsigned int data;
+	int ret;
+
+	/* Begin initialization */
+	pci_write_reg(chan, 0, SH4A_PCIETCTLR);
+
+	/* Initialize as type1. */
+	data = pci_read_reg(chan, SH4A_PCIEPCICONF3);
+	data &= ~(0x7f << 16);
+	data |= PCI_HEADER_TYPE_BRIDGE << 16;
+	pci_write_reg(chan, data, SH4A_PCIEPCICONF3);
+
+	/* Initialize default capabilities. */
+	data = pci_read_reg(chan, SH4A_PCIEEXPCAP0);
+	data &= ~(PCI_EXP_FLAGS_TYPE << 16);
+
+	if (port->endpoint)
+		data |= PCI_EXP_TYPE_ENDPOINT << 20;
+	else
+		data |= PCI_EXP_TYPE_ROOT_PORT << 20;
+
+	data |= PCI_CAP_ID_EXP;
+	pci_write_reg(chan, data, SH4A_PCIEEXPCAP0);
+
+	/* Enable x4 link width and extended sync. */
+	data = pci_read_reg(chan, SH4A_PCIEEXPCAP4);
+	data &= ~(PCI_EXP_LNKSTA_NLW << 16);
+	data |= (1 << 22) | PCI_EXP_LNKCTL_ES;
+	pci_write_reg(chan, data, SH4A_PCIEEXPCAP4);
+
+	/* Set the completion timer timeout to the maximum 32ms. */
+	data = pci_read_reg(chan, SH4A_PCIETLCTLR);
+	data &= ~0xffff;
+	data |= 0x32 << 8;
+	pci_write_reg(chan, data, SH4A_PCIETLCTLR);
+
+	/*
+	 * Set fast training sequences to the maximum 255,
+	 * and enable MAC data scrambling.
+	 */
+	data = pci_read_reg(chan, SH4A_PCIEMACCTLR);
+	data &= ~PCIEMACCTLR_SCR_DIS;
+	data |= (0xff << 16);
+	pci_write_reg(chan, data, SH4A_PCIEMACCTLR);
+
+	/* Finish initialization */
+	data = pci_read_reg(chan, SH4A_PCIETCTLR);
+	data |= 0x1;
+	pci_write_reg(chan, data, SH4A_PCIETCTLR);
+
+	/* Enable DL_Active Interrupt generation */
+	data = pci_read_reg(chan, SH4A_PCIEDLINTENR);
+	data |= PCIEDLINTENR_DLL_ACT_ENABLE;
+	pci_write_reg(chan, data, SH4A_PCIEDLINTENR);
+
+	/* Disable MAC data scrambling. */
+	data = pci_read_reg(chan, SH4A_PCIEMACCTLR);
+	data |= PCIEMACCTLR_SCR_DIS | (0xff << 16);
+	pci_write_reg(chan, data, SH4A_PCIEMACCTLR);
+
+	ret = pci_wait_for_irq(chan, MASK_INT_TX_CTRL);
+	if (unlikely(ret != 0))
+		return -ENODEV;
+
+	pci_write_reg(chan, 0x00100007, SH4A_PCIEPCICONF1);
+	pci_write_reg(chan, 0x80888000, SH4A_PCIETXVC0DCTLR);
+	pci_write_reg(chan, 0x00222000, SH4A_PCIERXVC0DCTLR);
+	pci_write_reg(chan, 0x000050A0, SH4A_PCIEEXPCAP2);
+
+	wmb();
+
+	data = pci_read_reg(chan, SH4A_PCIEMACSR);
+	printk(KERN_NOTICE "PCI: PCIe#%d link width %d\n",
+	       port->index, (data >> 20) & 0x3f);
+
+	pci_write_reg(chan, 0x007c0000, SH4A_PCIEPAMR0);
+	pci_write_reg(chan, 0x00000000, SH4A_PCIEPARH0);
+	pci_write_reg(chan, 0x00000000, SH4A_PCIEPARL0);
+	pci_write_reg(chan, 0x80000100, SH4A_PCIEPTCTLR0);
+
+	pci_write_reg(chan, 0x03fc0000, SH4A_PCIEPAMR2);
+	pci_write_reg(chan, 0x00000000, SH4A_PCIEPARH2);
+	pci_write_reg(chan, 0x00000000, SH4A_PCIEPARL2);
+	pci_write_reg(chan, 0x80000000, SH4A_PCIEPTCTLR2);
+
+	return 0;
+}
+
+int __init pcibios_map_platform_irq(struct pci_dev *pdev, u8 slot, u8 pin)
+{
+        return 71;
+}
+
+static int sh7786_pcie_core_init(void)
+{
+	/* Return the number of ports */
+	return test_mode_pin(MODE_PIN12) ? 3 : 2;
+}
+
+static int __devinit sh7786_pcie_init_hw(struct sh7786_pcie_port *port)
+{
+	int ret;
+
+	ret = phy_init(port->hose);
+	if (unlikely(ret < 0))
+		return ret;
+
+	/*
+	 * Check if we are configured in endpoint or root complex mode,
+	 * this is a fixed pin setting that applies to all PCIe ports.
+	 */
+	port->endpoint = test_mode_pin(MODE_PIN11);
+
+	ret = pcie_init(port);
+	if (unlikely(ret < 0))
+		return ret;
+
+	register_pci_controller(port->hose);
+
+	return 0;
+}
+
+static struct sh7786_pcie_hwops sh7786_65nm_pcie_hwops __initdata = {
+	.core_init	= sh7786_pcie_core_init,
+	.port_init_hw	= sh7786_pcie_init_hw,
+};
+
+static int __init sh7786_pcie_init(void)
+{
+	int ret = 0, i;
+
+	printk(KERN_NOTICE "PCI: Starting intialization.\n");
+
+	sh7786_pcie_hwops = &sh7786_65nm_pcie_hwops;
+
+	nr_ports = sh7786_pcie_hwops->core_init();
+	BUG_ON(nr_ports > ARRAY_SIZE(sh7786_pci_channels));
+
+	if (unlikely(nr_ports == 0))
+		return -ENODEV;
+
+	sh7786_pcie_ports = kzalloc(nr_ports * sizeof(struct sh7786_pcie_port),
+				    GFP_KERNEL);
+	if (unlikely(!sh7786_pcie_ports))
+		return -ENOMEM;
+
+	printk(KERN_NOTICE "PCI: probing %d ports.\n", nr_ports);
+
+	for (i = 0; i < nr_ports; i++) {
+		struct sh7786_pcie_port *port = sh7786_pcie_ports + i;
+
+		port->index		= i;
+		port->hose		= sh7786_pci_channels + i;
+		port->hose->io_map_base	= port->hose->io_resource->start;
+
+		/*
+		 * Check if we are booting in 29 or 32-bit mode
+		 *
+		 * 32-bit mode provides each controller with its own
+		 * memory window, while 29-bit mode uses a shared one.
+		 */
+		port->hose->mem_resource = test_mode_pin(MODE_PIN10) ?
+			&sh7786_pci_32bit_mem_resources[i] :
+			&sh7786_pci_29bit_mem_resource;
+
+		ret |= sh7786_pcie_hwops->port_init_hw(port);
+	}
+
+	if (unlikely(ret))
+		return ret;
+
+	return 0;
+}
+arch_initcall(sh7786_pcie_init);
