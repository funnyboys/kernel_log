commit 87dfb311b707cd4c4b666c9af0fa15acbe6eee99
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue May 14 15:46:51 2019 -0700

    treewide: replace #include <asm/sizes.h> with #include <linux/sizes.h>
    
    Since commit dccd2304cc90 ("ARM: 7430/1: sizes.h: move from asm-generic
    to <linux/sizes.h>"), <asm/sizes.h> and <asm-generic/sizes.h> are just
    wrappers of <linux/sizes.h>.
    
    This commit replaces all <asm/sizes.h> and <asm-generic/sizes.h> to
    prepare for the removal.
    
    Link: http://lkml.kernel.org/r/1553267665-27228-1-git-send-email-yamada.masahiro@socionext.com
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 3fd0f392a0ee..287b3a68570c 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -16,7 +16,7 @@
 #include <linux/log2.h>
 #include "pci-sh4.h"
 #include <asm/mmu.h>
-#include <asm/sizes.h>
+#include <linux/sizes.h>
 
 #if defined(CONFIG_CPU_BIG_ENDIAN)
 # define PCICR_ENDIANNESS SH4_PCICR_BSWP

commit ff4a7481c3898ffc3cc271d6aca431d190c37247
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 28 00:31:49 2018 -0800

    sh: drivers: convert to SPDX identifiers
    
    Update license to use SPDX-License-Identifier instead of verbose license
    text.
    
    As original license mentioned, it is GPL-2.0 in SPDX.
    Then, MODULE_LICENSE() should be "GPL v2" instead of "GPL".
    See ${LINUX}/include/linux/module.h
    
            "GPL"           [GNU Public License v2 or later]
            "GPL v2"        [GNU Public License v2]
    
    Link: http://lkml.kernel.org/r/87h8fsct0a.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 5a6dab6e27d9..3fd0f392a0ee 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -1,11 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Low-Level PCI Support for the SH7780
  *
  *  Copyright (C) 2005 - 2010  Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 #include <linux/types.h>
 #include <linux/kernel.h>

commit bfc906d885762cd5e9381c1815b18bd7753cedf5
Author: Thomas Schwinge <thomas@codesourcery.com>
Date:   Fri Mar 9 17:38:52 2012 +0100

    SH: pci-sh7780: enable big-endian operation.
    
    If in big-endian mode, switch the PCI bus, too.
    
    Tested on both litte-endian and big-endian sh7785lcr.
    
    Signed-off-by: Thomas Schwinge <thomas@codesourcery.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: linux-sh@vger.kernel.org
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index fb8f14990743..5a6dab6e27d9 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -21,6 +21,13 @@
 #include <asm/mmu.h>
 #include <asm/sizes.h>
 
+#if defined(CONFIG_CPU_BIG_ENDIAN)
+# define PCICR_ENDIANNESS SH4_PCICR_BSWP
+#else
+# define PCICR_ENDIANNESS 0
+#endif
+
+
 static struct resource sh7785_pci_resources[] = {
 	{
 		.name	= "PCI IO",
@@ -254,7 +261,7 @@ static int __init sh7780_pci_init(void)
 	__raw_writel(PCIECR_ENBL, PCIECR);
 
 	/* Reset */
-	__raw_writel(SH4_PCICR_PREFIX | SH4_PCICR_PRST,
+	__raw_writel(SH4_PCICR_PREFIX | SH4_PCICR_PRST | PCICR_ENDIANNESS,
 		     chan->reg_base + SH4_PCICR);
 
 	/*
@@ -290,7 +297,8 @@ static int __init sh7780_pci_init(void)
 	 * Now throw it in to register initialization mode and
 	 * start the real work.
 	 */
-	__raw_writel(SH4_PCICR_PREFIX, chan->reg_base + SH4_PCICR);
+	__raw_writel(SH4_PCICR_PREFIX | PCICR_ENDIANNESS,
+		     chan->reg_base + SH4_PCICR);
 
 	memphys = __pa(memory_start);
 	memsize = roundup_pow_of_two(memory_end - memory_start);
@@ -380,7 +388,8 @@ static int __init sh7780_pci_init(void)
 	 * Initialization mode complete, release the control register and
 	 * enable round robin mode to stop device overruns/starvation.
 	 */
-	__raw_writel(SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_FTO,
+	__raw_writel(SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_FTO |
+		     PCICR_ENDIANNESS,
 		     chan->reg_base + SH4_PCICR);
 
 	ret = register_pci_controller(chan);

commit ecfb68c673dc71579b53a46fa22168e7a11f2f19
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Sat Feb 4 21:40:24 2012 +0900

    sh: Fix typo in pci-sh7780.c
    
    Correct spelling "erorr" to "error" in
    arch/sh/drivers/pci/pci-sh7780.c
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index fa7b978cc727..fb8f14990743 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -74,7 +74,7 @@ struct pci_errors {
 	{ SH4_PCIINT_MLCK,	"master lock error" },
 	{ SH4_PCIINT_TABT,	"target-target abort" },
 	{ SH4_PCIINT_TRET,	"target retry time out" },
-	{ SH4_PCIINT_MFDE,	"master function disable erorr" },
+	{ SH4_PCIINT_MFDE,	"master function disable error" },
 	{ SH4_PCIINT_PRTY,	"address parity error" },
 	{ SH4_PCIINT_SERR,	"SERR" },
 	{ SH4_PCIINT_TWDP,	"data parity error for target write" },

commit d11584a0449f881181dc94dd697d3f3896c15c73
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Sat Oct 22 17:56:28 2011 +0800

    SH: irq: Remove IRQF_DISABLED
    
    Since commit [e58aa3d2: genirq: Run irq handlers with interrupts disabled],
    We run all interrupt handlers with interrupts disabled
    and we even check and yell when an interrupt handler
    returns with interrupts enabled (see commit [b738a50a:
    genirq: Warn when handler enables interrupts]).
    
    So now this flag is a NOOP and can be removed.
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index edb7cca14882..fa7b978cc727 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -172,7 +172,7 @@ static int __init sh7780_pci_setup_irqs(struct pci_channel *hose)
 		     PCI_STATUS_SIG_TARGET_ABORT | \
 		     PCI_STATUS_PARITY, hose->reg_base + PCI_STATUS);
 
-	ret = request_irq(hose->serr_irq, sh7780_pci_serr_irq, IRQF_DISABLED,
+	ret = request_irq(hose->serr_irq, sh7780_pci_serr_irq, 0,
 			  "PCI SERR interrupt", hose);
 	if (unlikely(ret)) {
 		printk(KERN_ERR "PCI: Failed hooking SERR IRQ\n");

commit 3b554c33dcde9d67efcb8d0a5acca201afd44730
Author: Matt Fleming <matt@console-pimps.org>
Date:   Sat Jun 19 00:01:03 2010 +0100

    sh: Fix typos in PCI initialization message
    
    This typo seems to have been copy and pasted in the PCI initialization
    code. Replace 'intialization' with 'initialization'.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index ffdcbf10b95e..edb7cca14882 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -246,7 +246,7 @@ static int __init sh7780_pci_init(void)
 	const char *type;
 	int ret, i;
 
-	printk(KERN_NOTICE "PCI: Starting intialization.\n");
+	printk(KERN_NOTICE "PCI: Starting initialization.\n");
 
 	chan->reg_base = 0xfe040000;
 

commit 3b0be1a4f2f7d8280574aa6e5eac2dd3dd57e2b7
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Feb 5 16:11:25 2010 +0900

    sh: Fix an off-by-1 in SH7780 PCIC memory resource mapping.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 1e147f445c1a..ffdcbf10b95e 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -23,7 +23,7 @@
 
 static struct resource sh7785_pci_resources[] = {
 	{
-		.name	= "SH7785_IO",
+		.name	= "PCI IO",
 		.start	= 0x1000,
 		.end	= SZ_4M - 1,
 		.flags	= IORESOURCE_IO,
@@ -338,8 +338,8 @@ static int __init sh7780_pci_init(void)
 	/*
 	 * Setup the memory BARs
 	 */
-	for (i = 0; i < chan->nr_resources; i++) {
-		struct resource *res = chan->resources + (i + 1);
+	for (i = 1; i < chan->nr_resources; i++) {
+		struct resource *res = chan->resources + i;
 		resource_size_t size;
 
 		if (unlikely(res->flags & IORESOURCE_IO))
@@ -361,8 +361,8 @@ static int __init sh7780_pci_init(void)
 		 * keeps things pretty simple.
 		 */
 		__raw_writel(((roundup_pow_of_two(size) / SZ_256K) - 1) << 18,
-			     chan->reg_base + SH7780_PCIMBMR(i));
-		__raw_writel(res->start, chan->reg_base + SH7780_PCIMBR(i));
+			     chan->reg_base + SH7780_PCIMBMR(i - 1));
+		__raw_writel(res->start, chan->reg_base + SH7780_PCIMBR(i - 1));
 	}
 
 	/*

commit 9ad62ec4f752c82b39aa5927f23d894b46ae10b9
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Feb 3 16:46:20 2010 +0900

    sh: Fix up early PCI PERR/SERR IRQ handling.
    
    This adds support for handling early PERR/SERR triggering in between
    controller registration and the initial bus scan. Buggy cards end up
    asserting these as soon as the M66EN scan is undertaken, resulting in
    an early crash.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 472f67aec337..1e147f445c1a 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -150,7 +150,7 @@ static irqreturn_t sh7780_pci_serr_irq(int irq, void *dev_id)
 	__raw_writel(SH4_PCIINTM_SDIM, hose->reg_base + SH4_PCIINTM);
 
 	/* Back off the IRQ for awhile */
-	disable_irq(irq);
+	disable_irq_nosync(irq);
 	hose->serr_timer.expires = jiffies + HZ;
 	add_timer(&hose->serr_timer);
 

commit b6c58b1d987a5795086c5c2babd8c7367d2fdb8c
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Feb 1 20:01:50 2010 +0900

    sh: Improved multi-resource handling for SH7780 PCI.
    
    The SH7780 PCI controller supports 3 different ranges of PCI memory in
    addition to its PCI I/O window. In the case of 29-bit mode, only 2 memory
    windows are supported, while in 32-bit mode all 3 are visible. This
    attempts to make the resource handling completely dynamic and to permit
    platforms to map in as many apertures as they can handle.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 86373314f458..472f67aec337 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -21,27 +21,40 @@
 #include <asm/mmu.h>
 #include <asm/sizes.h>
 
-static struct resource sh7785_io_resource = {
-	.name	= "SH7785_IO",
-	.start	= 0x1000,
-	.end	= SH7780_PCI_IO_SIZE - 1,
-	.flags	= IORESOURCE_IO
-};
-
-static struct resource sh7785_mem_resource = {
-	.name	= "SH7785_mem",
-	.start	= SH7780_PCI_MEMORY_BASE,
-	.end	= SH7780_PCI_MEMORY_BASE + SH7780_PCI_MEM_SIZE - 1,
-	.flags	= IORESOURCE_MEM
+static struct resource sh7785_pci_resources[] = {
+	{
+		.name	= "SH7785_IO",
+		.start	= 0x1000,
+		.end	= SZ_4M - 1,
+		.flags	= IORESOURCE_IO,
+	}, {
+		.name	= "PCI MEM 0",
+		.start	= 0xfd000000,
+		.end	= 0xfd000000 + SZ_16M - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "PCI MEM 1",
+		.start	= 0x10000000,
+		.end	= 0x10000000 + SZ_64M - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		/*
+		 * 32-bit only resources must be last.
+		 */
+		.name	= "PCI MEM 2",
+		.start	= 0xc0000000,
+		.end	= 0xc0000000 + SZ_512M - 1,
+		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
+	},
 };
 
 static struct pci_channel sh7780_pci_controller = {
 	.pci_ops	= &sh4_pci_ops,
-	.mem_resource	= &sh7785_mem_resource,
-	.mem_offset	= 0x00000000,
-	.io_resource	= &sh7785_io_resource,
-	.io_offset	= 0x00000000,
-	.io_map_base	= SH7780_PCI_IO_BASE,
+	.resources	= sh7785_pci_resources,
+	.nr_resources	= ARRAY_SIZE(sh7785_pci_resources),
+	.io_offset	= 0,
+	.mem_offset	= 0,
+	.io_map_base	= 0xfe200000,
 	.serr_irq	= evt2irq(0xa00),
 	.err_irq	= evt2irq(0xaa0),
 };
@@ -231,7 +244,7 @@ static int __init sh7780_pci_init(void)
 	size_t memsize;
 	unsigned int id;
 	const char *type;
-	int ret;
+	int ret, i;
 
 	printk(KERN_NOTICE "PCI: Starting intialization.\n");
 
@@ -279,8 +292,6 @@ static int __init sh7780_pci_init(void)
 	 */
 	__raw_writel(SH4_PCICR_PREFIX, chan->reg_base + SH4_PCICR);
 
-	__raw_writel(0, chan->reg_base + PCI_BASE_ADDRESS_0);
-
 	memphys = __pa(memory_start);
 	memsize = roundup_pow_of_two(memory_end - memory_start);
 
@@ -324,9 +335,40 @@ static int __init sh7780_pci_init(void)
 	__raw_writel(0, chan->reg_base + SH7780_PCICSCR1);
 	__raw_writel(0, chan->reg_base + SH7780_PCICSAR1);
 
-	__raw_writel(0xfd000000, chan->reg_base + SH7780_PCIMBR0);
-	__raw_writel(0x00fc0000, chan->reg_base + SH7780_PCIMBMR0);
+	/*
+	 * Setup the memory BARs
+	 */
+	for (i = 0; i < chan->nr_resources; i++) {
+		struct resource *res = chan->resources + (i + 1);
+		resource_size_t size;
+
+		if (unlikely(res->flags & IORESOURCE_IO))
+			continue;
+
+		/*
+		 * Make sure we're in the right physical addressing mode
+		 * for dealing with the resource.
+		 */
+		if ((res->flags & IORESOURCE_MEM_32BIT) && __in_29bit_mode()) {
+			chan->nr_resources--;
+			continue;
+		}
 
+		size = resource_size(res);
+
+		/*
+		 * The MBMR mask is calculated in units of 256kB, which
+		 * keeps things pretty simple.
+		 */
+		__raw_writel(((roundup_pow_of_two(size) / SZ_256K) - 1) << 18,
+			     chan->reg_base + SH7780_PCIMBMR(i));
+		__raw_writel(res->start, chan->reg_base + SH7780_PCIMBR(i));
+	}
+
+	/*
+	 * And I/O.
+	 */
+	__raw_writel(0, chan->reg_base + PCI_BASE_ADDRESS_0);
 	__raw_writel(0, chan->reg_base + SH7780_PCIIOBR);
 	__raw_writel(0, chan->reg_base + SH7780_PCIIOBMR);
 

commit ef407beefbd9928792ccc93857e408e0057bc17b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Feb 1 16:39:46 2010 +0900

    sh: Hook up ERR/PERR/SERR detection for SH7780 PCI host controllers.
    
    These were never handled before, so implement some common infrastructure
    to support them, then make use of that in the SH7780-specific code. In
    practice there is little here that can not be generalized for SH4 parts,
    which will be an incremental change as the 7780/7751 code is gradually
    unified.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 0e0ddd67e6e1..86373314f458 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -11,6 +11,9 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/irq.h>
 #include <linux/errno.h>
 #include <linux/delay.h>
 #include <linux/log2.h>
@@ -39,8 +42,165 @@ static struct pci_channel sh7780_pci_controller = {
 	.io_resource	= &sh7785_io_resource,
 	.io_offset	= 0x00000000,
 	.io_map_base	= SH7780_PCI_IO_BASE,
+	.serr_irq	= evt2irq(0xa00),
+	.err_irq	= evt2irq(0xaa0),
 };
 
+struct pci_errors {
+	unsigned int	mask;
+	const char	*str;
+} pci_arbiter_errors[] = {
+	{ SH4_PCIAINT_MBKN,	"master broken" },
+	{ SH4_PCIAINT_TBTO,	"target bus time out" },
+	{ SH4_PCIAINT_MBTO,	"master bus time out" },
+	{ SH4_PCIAINT_TABT,	"target abort" },
+	{ SH4_PCIAINT_MABT,	"master abort" },
+	{ SH4_PCIAINT_RDPE,	"read data parity error" },
+	{ SH4_PCIAINT_WDPE,	"write data parity error" },
+}, pci_interrupt_errors[] = {
+	{ SH4_PCIINT_MLCK,	"master lock error" },
+	{ SH4_PCIINT_TABT,	"target-target abort" },
+	{ SH4_PCIINT_TRET,	"target retry time out" },
+	{ SH4_PCIINT_MFDE,	"master function disable erorr" },
+	{ SH4_PCIINT_PRTY,	"address parity error" },
+	{ SH4_PCIINT_SERR,	"SERR" },
+	{ SH4_PCIINT_TWDP,	"data parity error for target write" },
+	{ SH4_PCIINT_TRDP,	"PERR detected for target read" },
+	{ SH4_PCIINT_MTABT,	"target abort for master" },
+	{ SH4_PCIINT_MMABT,	"master abort for master" },
+	{ SH4_PCIINT_MWPD,	"master write data parity error" },
+	{ SH4_PCIINT_MRPD,	"master read data parity error" },
+};
+
+static irqreturn_t sh7780_pci_err_irq(int irq, void *dev_id)
+{
+	struct pci_channel *hose = dev_id;
+	unsigned long addr;
+	unsigned int status;
+	unsigned int cmd;
+	int i;
+
+	addr = __raw_readl(hose->reg_base + SH4_PCIALR);
+
+	/*
+	 * Handle status errors.
+	 */
+	status = __raw_readw(hose->reg_base + PCI_STATUS);
+	if (status & (PCI_STATUS_PARITY |
+		      PCI_STATUS_DETECTED_PARITY |
+		      PCI_STATUS_SIG_TARGET_ABORT |
+		      PCI_STATUS_REC_TARGET_ABORT |
+		      PCI_STATUS_REC_MASTER_ABORT)) {
+		cmd = pcibios_handle_status_errors(addr, status, hose);
+		if (likely(cmd))
+			__raw_writew(cmd, hose->reg_base + PCI_STATUS);
+	}
+
+	/*
+	 * Handle arbiter errors.
+	 */
+	status = __raw_readl(hose->reg_base + SH4_PCIAINT);
+	for (i = cmd = 0; i < ARRAY_SIZE(pci_arbiter_errors); i++) {
+		if (status & pci_arbiter_errors[i].mask) {
+			printk(KERN_DEBUG "PCI: %s, addr=%08lx\n",
+			       pci_arbiter_errors[i].str, addr);
+			cmd |= pci_arbiter_errors[i].mask;
+		}
+	}
+	__raw_writel(cmd, hose->reg_base + SH4_PCIAINT);
+
+	/*
+	 * Handle the remaining PCI errors.
+	 */
+	status = __raw_readl(hose->reg_base + SH4_PCIINT);
+	for (i = cmd = 0; i < ARRAY_SIZE(pci_interrupt_errors); i++) {
+		if (status & pci_interrupt_errors[i].mask) {
+			printk(KERN_DEBUG "PCI: %s, addr=%08lx\n",
+			       pci_interrupt_errors[i].str, addr);
+			cmd |= pci_interrupt_errors[i].mask;
+		}
+	}
+	__raw_writel(cmd, hose->reg_base + SH4_PCIINT);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t sh7780_pci_serr_irq(int irq, void *dev_id)
+{
+	struct pci_channel *hose = dev_id;
+
+	printk(KERN_DEBUG "PCI: system error received: ");
+	pcibios_report_status(PCI_STATUS_SIG_SYSTEM_ERROR, 1);
+	printk("\n");
+
+	/* Deassert SERR */
+	__raw_writel(SH4_PCIINTM_SDIM, hose->reg_base + SH4_PCIINTM);
+
+	/* Back off the IRQ for awhile */
+	disable_irq(irq);
+	hose->serr_timer.expires = jiffies + HZ;
+	add_timer(&hose->serr_timer);
+
+	return IRQ_HANDLED;
+}
+
+static int __init sh7780_pci_setup_irqs(struct pci_channel *hose)
+{
+	int ret;
+
+	/* Clear out PCI arbiter IRQs */
+	__raw_writel(0, hose->reg_base + SH4_PCIAINT);
+
+	/* Clear all error conditions */
+	__raw_writew(PCI_STATUS_DETECTED_PARITY  | \
+		     PCI_STATUS_SIG_SYSTEM_ERROR | \
+		     PCI_STATUS_REC_MASTER_ABORT | \
+		     PCI_STATUS_REC_TARGET_ABORT | \
+		     PCI_STATUS_SIG_TARGET_ABORT | \
+		     PCI_STATUS_PARITY, hose->reg_base + PCI_STATUS);
+
+	ret = request_irq(hose->serr_irq, sh7780_pci_serr_irq, IRQF_DISABLED,
+			  "PCI SERR interrupt", hose);
+	if (unlikely(ret)) {
+		printk(KERN_ERR "PCI: Failed hooking SERR IRQ\n");
+		return ret;
+	}
+
+	/*
+	 * The PCI ERR IRQ needs to be IRQF_SHARED since all of the power
+	 * down IRQ vectors are routed through the ERR IRQ vector. We
+	 * only request_irq() once as there is only a single masking
+	 * source for multiple events.
+	 */
+	ret = request_irq(hose->err_irq, sh7780_pci_err_irq, IRQF_SHARED,
+			  "PCI ERR interrupt", hose);
+	if (unlikely(ret)) {
+		free_irq(hose->serr_irq, hose);
+		return ret;
+	}
+
+	/* Unmask all of the arbiter IRQs. */
+	__raw_writel(SH4_PCIAINT_MBKN | SH4_PCIAINT_TBTO | SH4_PCIAINT_MBTO | \
+		     SH4_PCIAINT_TABT | SH4_PCIAINT_MABT | SH4_PCIAINT_RDPE | \
+		     SH4_PCIAINT_WDPE, hose->reg_base + SH4_PCIAINTM);
+
+	/* Unmask all of the PCI IRQs */
+	__raw_writel(SH4_PCIINTM_TTADIM  | SH4_PCIINTM_TMTOIM  | \
+		     SH4_PCIINTM_MDEIM   | SH4_PCIINTM_APEDIM  | \
+		     SH4_PCIINTM_SDIM    | SH4_PCIINTM_DPEITWM | \
+		     SH4_PCIINTM_PEDITRM | SH4_PCIINTM_TADIMM  | \
+		     SH4_PCIINTM_MADIMM  | SH4_PCIINTM_MWPDIM  | \
+		     SH4_PCIINTM_MRDPEIM, hose->reg_base + SH4_PCIINTM);
+
+	return ret;
+}
+
+static inline void __init sh7780_pci_teardown_irqs(struct pci_channel *hose)
+{
+	free_irq(hose->err_irq, hose);
+	free_irq(hose->serr_irq, hose);
+}
+
 static void __init sh7780_pci66_init(struct pci_channel *hose)
 {
 	unsigned int tmp;
@@ -149,33 +309,12 @@ static int __init sh7780_pci_init(void)
 	__raw_writel(((memsize - SZ_1M) & 0x1ff00000) | 1,
 		     chan->reg_base + SH4_PCILSR0);
 
-	/* Clear out PCI arbiter IRQs */
-	__raw_writel(0, chan->reg_base + SH4_PCIAINT);
-
-	/* Unmask all of the arbiter IRQs. */
-	__raw_writel(SH4_PCIAINT_MBKN | SH4_PCIAINT_TBTO | SH4_PCIAINT_MBTO | \
-		     SH4_PCIAINT_TABT | SH4_PCIAINT_MABT | SH4_PCIAINT_RDPE | \
-		     SH4_PCIAINT_WDPE, chan->reg_base + SH4_PCIAINTM);
-
-	/* Clear all error conditions */
-	__raw_writew(PCI_STATUS_DETECTED_PARITY  | \
-		     PCI_STATUS_SIG_SYSTEM_ERROR | \
-		     PCI_STATUS_REC_MASTER_ABORT | \
-		     PCI_STATUS_REC_TARGET_ABORT | \
-		     PCI_STATUS_SIG_TARGET_ABORT | \
-		     PCI_STATUS_PARITY, chan->reg_base + PCI_STATUS);
-
-	__raw_writew(PCI_COMMAND_SERR | PCI_COMMAND_WAIT | \
-		     PCI_COMMAND_PARITY | PCI_COMMAND_MASTER | \
-		     PCI_COMMAND_MEMORY, chan->reg_base + PCI_COMMAND);
-
-	/* Unmask all of the PCI IRQs */
-	__raw_writel(SH4_PCIINTM_TTADIM  | SH4_PCIINTM_TMTOIM  | \
-		     SH4_PCIINTM_MDEIM   | SH4_PCIINTM_APEDIM  | \
-		     SH4_PCIINTM_SDIM    | SH4_PCIINTM_DPEITWM | \
-		     SH4_PCIINTM_PEDITRM | SH4_PCIINTM_TADIMM  | \
-		     SH4_PCIINTM_MADIMM  | SH4_PCIINTM_MWPDIM  | \
-		     SH4_PCIINTM_MRDPEIM, chan->reg_base + SH4_PCIINTM);
+	/*
+	 * Hook up the ERR and SERR IRQs.
+	 */
+	ret = sh7780_pci_setup_irqs(chan);
+	if (unlikely(ret))
+		return ret;
 
 	/*
 	 * Disable the cache snoop controller for non-coherent DMA.
@@ -191,6 +330,10 @@ static int __init sh7780_pci_init(void)
 	__raw_writel(0, chan->reg_base + SH7780_PCIIOBR);
 	__raw_writel(0, chan->reg_base + SH7780_PCIIOBMR);
 
+	__raw_writew(PCI_COMMAND_SERR   | PCI_COMMAND_WAIT   | \
+		     PCI_COMMAND_PARITY | PCI_COMMAND_MASTER | \
+		     PCI_COMMAND_MEMORY, chan->reg_base + PCI_COMMAND);
+
 	/*
 	 * Initialization mode complete, release the control register and
 	 * enable round robin mode to stop device overruns/starvation.
@@ -200,7 +343,7 @@ static int __init sh7780_pci_init(void)
 
 	ret = register_pci_controller(chan);
 	if (unlikely(ret))
-		return ret;
+		goto err;
 
 	sh7780_pci66_init(chan);
 
@@ -209,5 +352,9 @@ static int __init sh7780_pci_init(void)
 	       66 : 33);
 
 	return 0;
+
+err:
+	sh7780_pci_teardown_irqs(chan);
+	return ret;
 }
 arch_initcall(sh7780_pci_init);

commit bcf39352eb9e9026f7a1028d4bce3707b65f104b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Feb 1 13:11:25 2010 +0900

    sh: Handle PCI controller resource conflicts.
    
    register_pci_controller() can fail, but presently is a void function.
    Change this over to an int so that we can bail early before continuing on
    with post-registration initialization (such as throwing the controller in
    to 66MHz mode in the case of the SH7780 host controller).
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index b68f45b6451a..0e0ddd67e6e1 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -71,6 +71,7 @@ static int __init sh7780_pci_init(void)
 	size_t memsize;
 	unsigned int id;
 	const char *type;
+	int ret;
 
 	printk(KERN_NOTICE "PCI: Starting intialization.\n");
 
@@ -197,7 +198,9 @@ static int __init sh7780_pci_init(void)
 	__raw_writel(SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_FTO,
 		     chan->reg_base + SH4_PCICR);
 
-	register_pci_controller(chan);
+	ret = register_pci_controller(chan);
+	if (unlikely(ret))
+		return ret;
 
 	sh7780_pci66_init(chan);
 

commit 85b59f5bb24aeca1a987cbb206e228bf630c8327
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Feb 1 13:01:42 2010 +0900

    sh: Enable PCI66 support for SH7780 host controller.
    
    This adds some helper glue for scanning the bus and determining if all
    of the devices are 66MHz capable or not before flipping on 66MHz mode.
    This isn't quite to spec, but it's fairly consistent with what other
    embedded controllers end up having to do.
    
    Scanning code cribbed from the MIPS txx9 PCI code.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 8405c8fded6f..b68f45b6451a 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -41,6 +41,29 @@ static struct pci_channel sh7780_pci_controller = {
 	.io_map_base	= SH7780_PCI_IO_BASE,
 };
 
+static void __init sh7780_pci66_init(struct pci_channel *hose)
+{
+	unsigned int tmp;
+
+	if (!pci_is_66mhz_capable(hose, 0, 0))
+		return;
+
+	/* Enable register access */
+	tmp = __raw_readl(hose->reg_base + SH4_PCICR);
+	tmp |= SH4_PCICR_PREFIX;
+	__raw_writel(tmp, hose->reg_base + SH4_PCICR);
+
+	/* Enable 66MHz operation */
+	tmp = __raw_readw(hose->reg_base + PCI_STATUS);
+	tmp |= PCI_STATUS_66MHZ;
+	__raw_writew(tmp, hose->reg_base + PCI_STATUS);
+
+	/* Done */
+	tmp = __raw_readl(hose->reg_base + SH4_PCICR);
+	tmp |= SH4_PCICR_PREFIX | SH4_PCICR_CFIN;
+	__raw_writel(tmp, hose->reg_base + SH4_PCICR);
+}
+
 static int __init sh7780_pci_init(void)
 {
 	struct pci_channel *chan = &sh7780_pci_controller;
@@ -176,6 +199,12 @@ static int __init sh7780_pci_init(void)
 
 	register_pci_controller(chan);
 
+	sh7780_pci66_init(chan);
+
+	printk(KERN_NOTICE "PCI: Running at %dMHz.\n",
+	       (__raw_readw(chan->reg_base + PCI_STATUS) & PCI_STATUS_66MHZ) ?
+	       66 : 33);
+
 	return 0;
 }
 arch_initcall(sh7780_pci_init);

commit aee4467b5ce5047401efb4175b1360ec1734affc
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Feb 1 11:33:22 2010 +0900

    sh: Fix up large system memory handling for SH7780 PCI.
    
    For systems that have more than 512MB we need to set up an additional
    mapping, this fixes up the rounding to the next power of two and splits
    out the mapping accordingly between the two local bus mapping windows.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 40531cd367b7..8405c8fded6f 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -13,6 +13,7 @@
 #include <linux/pci.h>
 #include <linux/errno.h>
 #include <linux/delay.h>
+#include <linux/log2.h>
 #include "pci-sh4.h"
 #include <asm/mmu.h>
 #include <asm/sizes.h>
@@ -59,7 +60,11 @@ static int __init sh7780_pci_init(void)
 	__raw_writel(SH4_PCICR_PREFIX | SH4_PCICR_PRST,
 		     chan->reg_base + SH4_PCICR);
 
-	/* Wait for it to come back up.. */
+	/*
+	 * Wait for it to come back up. The spec says to allow for up to
+	 * 1 second after toggling the reset pin, but in practice 100ms
+	 * is more than enough.
+	 */
 	mdelay(100);
 
 	id = __raw_readw(chan->reg_base + PCI_VENDOR_ID);
@@ -90,17 +95,34 @@ static int __init sh7780_pci_init(void)
 	 */
 	__raw_writel(SH4_PCICR_PREFIX, chan->reg_base + SH4_PCICR);
 
+	__raw_writel(0, chan->reg_base + PCI_BASE_ADDRESS_0);
+
 	memphys = __pa(memory_start);
-	memsize = memory_end - memory_start;
+	memsize = roundup_pow_of_two(memory_end - memory_start);
 
 	/*
-	 * Set IO and Mem windows to local address
-	 * Make PCI and local address the same for easy 1 to 1 mapping
+	 * If there's more than 512MB of memory, we need to roll over to
+	 * LAR1/LSR1.
 	 */
-	__raw_writel(0, chan->reg_base + PCI_BASE_ADDRESS_0);
+	if (memsize > SZ_512M) {
+		__raw_writel(memphys + SZ_512M, chan->reg_base + SH4_PCILAR1);
+		__raw_writel((((memsize - SZ_512M) - SZ_1M) & 0x1ff00000) | 1,
+			     chan->reg_base + SH4_PCILSR1);
+		memsize = SZ_512M;
+	} else {
+		/*
+		 * Otherwise just zero it out and disable it.
+		 */
+		__raw_writel(0, chan->reg_base + SH4_PCILAR1);
+		__raw_writel(0, chan->reg_base + SH4_PCILSR1);
+	}
 
+	/*
+	 * LAR0/LSR0 covers up to the first 512MB, which is enough to
+	 * cover all of lowmem on most platforms.
+	 */
 	__raw_writel(memphys, chan->reg_base + SH4_PCILAR0);
-	__raw_writel((memsize - 1) << 9 | 1,
+	__raw_writel(((memsize - SZ_1M) & 0x1ff00000) | 1,
 		     chan->reg_base + SH4_PCILSR0);
 
 	/* Clear out PCI arbiter IRQs */

commit 396c56a9c69ebb0baf9171a6365ac9fda322728d
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sat Jan 30 01:41:21 2010 +0900

    sh: Kill off broken type 1 PCI config access checks.
    
    The host controllers only support type 1, so there's not much else to
    test for. Some of the older controllers also supported type 2 accesses,
    but we've never supported those, and likely never will. Beyond that, the
    P1SEG test is meaningless for 32-bit mode, so rather than refactoring it,
    just kill the type 1 test off completely.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 019e1afcd0a3..40531cd367b7 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -47,7 +47,6 @@ static int __init sh7780_pci_init(void)
 	size_t memsize;
 	unsigned int id;
 	const char *type;
-	int ret;
 
 	printk(KERN_NOTICE "PCI: Starting intialization.\n");
 
@@ -85,9 +84,6 @@ static int __init sh7780_pci_init(void)
 	       "controller, revision %d.\n", type,
 	       __raw_readb(chan->reg_base + PCI_REVISION_ID));
 
-	if ((ret = sh4_pci_check_direct(chan)) != 0)
-		return ret;
-
 	/*
 	 * Now throw it in to register initialization mode and
 	 * start the real work.

commit a45635dfb08a1fa2cf77bf1f2c4074961ce2e625
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Jan 29 22:19:04 2010 +0900

    sh: Reworked SH7780 PCI initialization.
    
    This consolidates the PCI initialization code for all of the pci-sh7780
    users, and sets up the memory window dynamically as opposed to using
    hardcoded window positions.
    
    A number of bugs were fixed at the same time, including the PIO handling
    and master abort timeout settings being incorrect.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 323b92d565fe..019e1afcd0a3 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -1,7 +1,7 @@
 /*
  * Low-Level PCI Support for the SH7780
  *
- *  Copyright (C) 2005 - 2009  Paul Mundt
+ *  Copyright (C) 2005 - 2010  Paul Mundt
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -14,11 +14,13 @@
 #include <linux/errno.h>
 #include <linux/delay.h>
 #include "pci-sh4.h"
+#include <asm/mmu.h>
+#include <asm/sizes.h>
 
 static struct resource sh7785_io_resource = {
 	.name	= "SH7785_IO",
-	.start	= SH7780_PCI_IO_BASE,
-	.end	= SH7780_PCI_IO_BASE + SH7780_PCI_IO_SIZE - 1,
+	.start	= 0x1000,
+	.end	= SH7780_PCI_IO_SIZE - 1,
 	.flags	= IORESOURCE_IO
 };
 
@@ -38,25 +40,14 @@ static struct pci_channel sh7780_pci_controller = {
 	.io_map_base	= SH7780_PCI_IO_BASE,
 };
 
-static struct sh4_pci_address_map sh7780_pci_map = {
-	.window0	= {
-#if defined(CONFIG_32BIT)
-		.base	= SH7780_32BIT_DDR_BASE_ADDR,
-		.size	= 0x40000000,
-#else
-		.base	= SH7780_CS0_BASE_ADDR,
-		.size	= 0x20000000,
-#endif
-	},
-};
-
 static int __init sh7780_pci_init(void)
 {
 	struct pci_channel *chan = &sh7780_pci_controller;
+	phys_addr_t memphys;
+	size_t memsize;
 	unsigned int id;
-	const char *type = NULL;
+	const char *type;
 	int ret;
-	u32 word;
 
 	printk(KERN_NOTICE "PCI: Starting intialization.\n");
 
@@ -65,17 +56,24 @@ static int __init sh7780_pci_init(void)
 	/* Enable CPU access to the PCIC registers. */
 	__raw_writel(PCIECR_ENBL, PCIECR);
 
-	id = __raw_readw(chan->reg_base + SH7780_PCIVID);
-	if (id != SH7780_VENDOR_ID) {
+	/* Reset */
+	__raw_writel(SH4_PCICR_PREFIX | SH4_PCICR_PRST,
+		     chan->reg_base + SH4_PCICR);
+
+	/* Wait for it to come back up.. */
+	mdelay(100);
+
+	id = __raw_readw(chan->reg_base + PCI_VENDOR_ID);
+	if (id != PCI_VENDOR_ID_RENESAS) {
 		printk(KERN_ERR "PCI: Unknown vendor ID 0x%04x.\n", id);
 		return -ENODEV;
 	}
 
-	id = __raw_readw(chan->reg_base + SH7780_PCIDID);
-	type = (id == SH7763_DEVICE_ID)	? "SH7763" :
-	       (id == SH7780_DEVICE_ID) ? "SH7780" :
-	       (id == SH7781_DEVICE_ID) ? "SH7781" :
-	       (id == SH7785_DEVICE_ID) ? "SH7785" :
+	id = __raw_readw(chan->reg_base + PCI_DEVICE_ID);
+	type = (id == PCI_DEVICE_ID_RENESAS_SH7763) ? "SH7763" :
+	       (id == PCI_DEVICE_ID_RENESAS_SH7780) ? "SH7780" :
+	       (id == PCI_DEVICE_ID_RENESAS_SH7781) ? "SH7781" :
+	       (id == PCI_DEVICE_ID_RENESAS_SH7785) ? "SH7785" :
 					  NULL;
 	if (unlikely(!type)) {
 		printk(KERN_ERR "PCI: Found an unsupported Renesas host "
@@ -85,59 +83,78 @@ static int __init sh7780_pci_init(void)
 
 	printk(KERN_NOTICE "PCI: Found a Renesas %s host "
 	       "controller, revision %d.\n", type,
-	       __raw_readb(chan->reg_base + SH7780_PCIRID));
+	       __raw_readb(chan->reg_base + PCI_REVISION_ID));
 
 	if ((ret = sh4_pci_check_direct(chan)) != 0)
 		return ret;
 
 	/*
-	 * Set the class and sub-class codes.
+	 * Now throw it in to register initialization mode and
+	 * start the real work.
 	 */
-	__raw_writeb(PCI_CLASS_BRIDGE_HOST >> 8,
-		     chan->reg_base + SH7780_PCIBCC);
-	__raw_writeb(PCI_CLASS_BRIDGE_HOST & 0xff,
-		     chan->reg_base + SH7780_PCISUB);
+	__raw_writel(SH4_PCICR_PREFIX, chan->reg_base + SH4_PCICR);
+
+	memphys = __pa(memory_start);
+	memsize = memory_end - memory_start;
 
 	/*
 	 * Set IO and Mem windows to local address
 	 * Make PCI and local address the same for easy 1 to 1 mapping
 	 */
-	pci_write_reg(chan, sh7780_pci_map.window0.size - 0xfffff, SH4_PCILSR0);
-	/* Set the values on window 0 PCI config registers */
-	pci_write_reg(chan, sh7780_pci_map.window0.base, SH4_PCILAR0);
-	pci_write_reg(chan, sh7780_pci_map.window0.base, SH7780_PCIMBAR0);
-
-	pci_write_reg(chan, 0x0000380f, SH4_PCIAINTM);
-
-	/* Set up standard PCI config registers */
-	__raw_writew(0xFB00, chan->reg_base + SH7780_PCISTATUS);
-	__raw_writew(0x0047, chan->reg_base + SH7780_PCICMD);
-	__raw_writew(0x1912, chan->reg_base + SH7780_PCISVID);
-	__raw_writew(0x0001, chan->reg_base + SH7780_PCISID);
-
-	__raw_writeb(0x00, chan->reg_base + SH7780_PCIPIF);
-
-	/* Apply any last-minute PCIC fixups */
-	pci_fixup_pcic(chan);
-
-	pci_write_reg(chan, 0xfd000000, SH7780_PCIMBR0);
-	pci_write_reg(chan, 0x00fc0000, SH7780_PCIMBMR0);
-
-#ifdef CONFIG_32BIT
-	pci_write_reg(chan, 0xc0000000, SH7780_PCIMBR2);
-	pci_write_reg(chan, 0x20000000 - SH7780_PCI_IO_SIZE, SH7780_PCIMBMR2);
-#endif
-
-	/* Set IOBR for windows containing area specified in pci.h */
-	pci_write_reg(chan, chan->io_resource->start & ~(SH7780_PCI_IO_SIZE-1),
-		      SH7780_PCIIOBR);
-	pci_write_reg(chan, ((SH7780_PCI_IO_SIZE-1) & (7<<18)),
-		      SH7780_PCIIOBMR);
-
-	/* SH7780 init done, set central function init complete */
-	/* use round robin mode to stop a device starving/overruning */
-	word = SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_FTO;
-	pci_write_reg(chan, word, SH4_PCICR);
+	__raw_writel(0, chan->reg_base + PCI_BASE_ADDRESS_0);
+
+	__raw_writel(memphys, chan->reg_base + SH4_PCILAR0);
+	__raw_writel((memsize - 1) << 9 | 1,
+		     chan->reg_base + SH4_PCILSR0);
+
+	/* Clear out PCI arbiter IRQs */
+	__raw_writel(0, chan->reg_base + SH4_PCIAINT);
+
+	/* Unmask all of the arbiter IRQs. */
+	__raw_writel(SH4_PCIAINT_MBKN | SH4_PCIAINT_TBTO | SH4_PCIAINT_MBTO | \
+		     SH4_PCIAINT_TABT | SH4_PCIAINT_MABT | SH4_PCIAINT_RDPE | \
+		     SH4_PCIAINT_WDPE, chan->reg_base + SH4_PCIAINTM);
+
+	/* Clear all error conditions */
+	__raw_writew(PCI_STATUS_DETECTED_PARITY  | \
+		     PCI_STATUS_SIG_SYSTEM_ERROR | \
+		     PCI_STATUS_REC_MASTER_ABORT | \
+		     PCI_STATUS_REC_TARGET_ABORT | \
+		     PCI_STATUS_SIG_TARGET_ABORT | \
+		     PCI_STATUS_PARITY, chan->reg_base + PCI_STATUS);
+
+	__raw_writew(PCI_COMMAND_SERR | PCI_COMMAND_WAIT | \
+		     PCI_COMMAND_PARITY | PCI_COMMAND_MASTER | \
+		     PCI_COMMAND_MEMORY, chan->reg_base + PCI_COMMAND);
+
+	/* Unmask all of the PCI IRQs */
+	__raw_writel(SH4_PCIINTM_TTADIM  | SH4_PCIINTM_TMTOIM  | \
+		     SH4_PCIINTM_MDEIM   | SH4_PCIINTM_APEDIM  | \
+		     SH4_PCIINTM_SDIM    | SH4_PCIINTM_DPEITWM | \
+		     SH4_PCIINTM_PEDITRM | SH4_PCIINTM_TADIMM  | \
+		     SH4_PCIINTM_MADIMM  | SH4_PCIINTM_MWPDIM  | \
+		     SH4_PCIINTM_MRDPEIM, chan->reg_base + SH4_PCIINTM);
+
+	/*
+	 * Disable the cache snoop controller for non-coherent DMA.
+	 */
+	__raw_writel(0, chan->reg_base + SH7780_PCICSCR0);
+	__raw_writel(0, chan->reg_base + SH7780_PCICSAR0);
+	__raw_writel(0, chan->reg_base + SH7780_PCICSCR1);
+	__raw_writel(0, chan->reg_base + SH7780_PCICSAR1);
+
+	__raw_writel(0xfd000000, chan->reg_base + SH7780_PCIMBR0);
+	__raw_writel(0x00fc0000, chan->reg_base + SH7780_PCIMBMR0);
+
+	__raw_writel(0, chan->reg_base + SH7780_PCIIOBR);
+	__raw_writel(0, chan->reg_base + SH7780_PCIIOBMR);
+
+	/*
+	 * Initialization mode complete, release the control register and
+	 * enable round robin mode to stop device overruns/starvation.
+	 */
+	__raw_writel(SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_FTO,
+		     chan->reg_base + SH4_PCICR);
 
 	register_pci_controller(chan);
 

commit 5582b0648de6248c67c0b47fa170e5fb15ab4bf1
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed May 27 00:12:58 2009 +0900

    sh: pci-sh7780: Fix up for PCI_DISABLE_MWI changes.
    
    This fixes a build error where references to pci_cache_line_size are
    undefined, as this ceases to be exported when PCI_DISABLE_MWI is enabled,
    as is now the default.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index ae13ff925c61..323b92d565fe 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -15,8 +15,6 @@
 #include <linux/delay.h>
 #include "pci-sh4.h"
 
-extern u8 pci_cache_line_size;
-
 static struct resource sh7785_io_resource = {
 	.name	= "SH7785_IO",
 	.start	= SH7780_PCI_IO_BASE,
@@ -37,6 +35,7 @@ static struct pci_channel sh7780_pci_controller = {
 	.mem_offset	= 0x00000000,
 	.io_resource	= &sh7785_io_resource,
 	.io_offset	= 0x00000000,
+	.io_map_base	= SH7780_PCI_IO_BASE,
 };
 
 static struct sh4_pci_address_map sh7780_pci_map = {
@@ -99,8 +98,6 @@ static int __init sh7780_pci_init(void)
 	__raw_writeb(PCI_CLASS_BRIDGE_HOST & 0xff,
 		     chan->reg_base + SH7780_PCISUB);
 
-	pci_cache_line_size = pci_read_reg(chan, SH7780_PCICLS) / 4;
-
 	/*
 	 * Set IO and Mem windows to local address
 	 * Make PCI and local address the same for easy 1 to 1 mapping
@@ -142,8 +139,6 @@ static int __init sh7780_pci_init(void)
 	word = SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_FTO;
 	pci_write_reg(chan, word, SH4_PCICR);
 
-	__set_io_port_base(SH7780_PCI_IO_BASE);
-
 	register_pci_controller(chan);
 
 	return 0;

commit 5ba7205fc49ff72e88784c94fb661f93e7ae7d36
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Apr 20 19:00:32 2009 +0900

    sh: pci: Kill off the now unused hose->io_base.
    
    Nothing is using this any more, so kill it off.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 57a3b870a276..ae13ff925c61 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -62,7 +62,6 @@ static int __init sh7780_pci_init(void)
 	printk(KERN_NOTICE "PCI: Starting intialization.\n");
 
 	chan->reg_base = 0xfe040000;
-	chan->io_base = 0xfe200000;
 
 	/* Enable CPU access to the PCIC registers. */
 	__raw_writel(PCIECR_ENBL, PCIECR);

commit 09cfeb133e3cac39b8b9a2cb1d8ab4f77e396248
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Apr 20 18:42:00 2009 +0900

    sh: pci: Track io and mem_offset per-channel.
    
    This implements a per-hose offset for I/O and mem resources.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 4dd6e3b94a67..57a3b870a276 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -34,7 +34,9 @@ static struct resource sh7785_mem_resource = {
 static struct pci_channel sh7780_pci_controller = {
 	.pci_ops	= &sh4_pci_ops,
 	.mem_resource	= &sh7785_mem_resource,
+	.mem_offset	= 0x00000000,
 	.io_resource	= &sh7785_io_resource,
+	.io_offset	= 0x00000000,
 };
 
 static struct sh4_pci_address_map sh7780_pci_map = {

commit e79066a659b893debe19010179d3f3f015d76d1c
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Apr 20 18:29:22 2009 +0900

    sh: pci: New-style controller registration.
    
    This moves off of the board_pci_channels[] approach for bus registration
    and over to a cleaner register_pci_controller(), all derived from the
    MIPS code.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index f02d9dfcf252..4dd6e3b94a67 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -15,11 +15,47 @@
 #include <linux/delay.h>
 #include "pci-sh4.h"
 
-static int __init sh7780_pci_init(struct pci_channel *chan)
+extern u8 pci_cache_line_size;
+
+static struct resource sh7785_io_resource = {
+	.name	= "SH7785_IO",
+	.start	= SH7780_PCI_IO_BASE,
+	.end	= SH7780_PCI_IO_BASE + SH7780_PCI_IO_SIZE - 1,
+	.flags	= IORESOURCE_IO
+};
+
+static struct resource sh7785_mem_resource = {
+	.name	= "SH7785_mem",
+	.start	= SH7780_PCI_MEMORY_BASE,
+	.end	= SH7780_PCI_MEMORY_BASE + SH7780_PCI_MEM_SIZE - 1,
+	.flags	= IORESOURCE_MEM
+};
+
+static struct pci_channel sh7780_pci_controller = {
+	.pci_ops	= &sh4_pci_ops,
+	.mem_resource	= &sh7785_mem_resource,
+	.io_resource	= &sh7785_io_resource,
+};
+
+static struct sh4_pci_address_map sh7780_pci_map = {
+	.window0	= {
+#if defined(CONFIG_32BIT)
+		.base	= SH7780_32BIT_DDR_BASE_ADDR,
+		.size	= 0x40000000,
+#else
+		.base	= SH7780_CS0_BASE_ADDR,
+		.size	= 0x20000000,
+#endif
+	},
+};
+
+static int __init sh7780_pci_init(void)
 {
+	struct pci_channel *chan = &sh7780_pci_controller;
 	unsigned int id;
 	const char *type = NULL;
 	int ret;
+	u32 word;
 
 	printk(KERN_NOTICE "PCI: Starting intialization.\n");
 
@@ -54,52 +90,6 @@ static int __init sh7780_pci_init(struct pci_channel *chan)
 	if ((ret = sh4_pci_check_direct(chan)) != 0)
 		return ret;
 
-	/*
-	 * Platform specific initialization (BSC registers, and memory space
-	 * mapping) will be called via the platform defined function
-	 * pcibios_init_platform().
-	 */
-	return pcibios_init_platform();
-}
-
-extern u8 pci_cache_line_size;
-
-static struct resource sh7785_io_resource = {
-	.name	= "SH7785_IO",
-	.start	= SH7780_PCI_IO_BASE,
-	.end	= SH7780_PCI_IO_BASE + SH7780_PCI_IO_SIZE - 1,
-	.flags	= IORESOURCE_IO
-};
-
-static struct resource sh7785_mem_resource = {
-	.name	= "SH7785_mem",
-	.start	= SH7780_PCI_MEMORY_BASE,
-	.end	= SH7780_PCI_MEMORY_BASE + SH7780_PCI_MEM_SIZE - 1,
-	.flags	= IORESOURCE_MEM
-};
-
-struct pci_channel board_pci_channels[] = {
-	{ sh7780_pci_init, &sh4_pci_ops, &sh7785_io_resource, &sh7785_mem_resource, 0, 0xff },
-	{ NULL, NULL, NULL, 0, 0 },
-};
-
-static struct sh4_pci_address_map sh7780_pci_map = {
-	.window0	= {
-#if defined(CONFIG_32BIT)
-		.base	= SH7780_32BIT_DDR_BASE_ADDR,
-		.size	= 0x40000000,
-#else
-		.base	= SH7780_CS0_BASE_ADDR,
-		.size	= 0x20000000,
-#endif
-	},
-};
-
-int __init pcibios_init_platform(void)
-{
-	struct pci_channel *chan = &board_pci_channels[0];
-	u32 word;
-
 	/*
 	 * Set the class and sub-class codes.
 	 */
@@ -153,5 +143,8 @@ int __init pcibios_init_platform(void)
 
 	__set_io_port_base(SH7780_PCI_IO_BASE);
 
+	register_pci_controller(chan);
+
 	return 0;
 }
+arch_initcall(sh7780_pci_init);

commit 62c7ae87cb5962d3dfaa6d916a15e4faa9e07363
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Apr 17 20:37:16 2009 +0900

    sh: pci: Start unifying the SH7780 PCIC initialization.
    
    This starts moving out the common initialization bits from the various
    fixup paths in to the shared init path.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 07c5529a273b..f02d9dfcf252 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -1,19 +1,12 @@
 /*
- *	Low-Level PCI Support for the SH7780
+ * Low-Level PCI Support for the SH7780
  *
- *  Dustin McIntire (dustin@sensoria.com)
- *	Derived from arch/i386/kernel/pci-*.c which bore the message:
- *	(c) 1999--2000 Martin Mares <mj@ucw.cz>
- *
- *  Ported to the new API by Paul Mundt <lethal@linux-sh.org>
- *  With cleanup by Paul van Gool <pvangool@mimotech.com>
- *
- *  May be copied or modified under the terms of the GNU General Public
- *  License.  See linux/COPYING for more information.
+ *  Copyright (C) 2005 - 2009  Paul Mundt
  *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
  */
-#undef DEBUG
-
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -117,13 +110,8 @@ int __init pcibios_init_platform(void)
 
 	pci_cache_line_size = pci_read_reg(chan, SH7780_PCICLS) / 4;
 
-	/* set the command/status bits to:
-	 * Wait Cycle Control + Parity Enable + Bus Master +
-	 * Mem space enable
-	 */
-	pci_write_reg(chan, 0x00000046, SH7780_PCICMD);
-
-	/* Set IO and Mem windows to local address
+	/*
+	 * Set IO and Mem windows to local address
 	 * Make PCI and local address the same for easy 1 to 1 mapping
 	 */
 	pci_write_reg(chan, sh7780_pci_map.window0.size - 0xfffff, SH4_PCILSR0);
@@ -131,9 +119,33 @@ int __init pcibios_init_platform(void)
 	pci_write_reg(chan, sh7780_pci_map.window0.base, SH4_PCILAR0);
 	pci_write_reg(chan, sh7780_pci_map.window0.base, SH7780_PCIMBAR0);
 
+	pci_write_reg(chan, 0x0000380f, SH4_PCIAINTM);
+
+	/* Set up standard PCI config registers */
+	__raw_writew(0xFB00, chan->reg_base + SH7780_PCISTATUS);
+	__raw_writew(0x0047, chan->reg_base + SH7780_PCICMD);
+	__raw_writew(0x1912, chan->reg_base + SH7780_PCISVID);
+	__raw_writew(0x0001, chan->reg_base + SH7780_PCISID);
+
+	__raw_writeb(0x00, chan->reg_base + SH7780_PCIPIF);
+
 	/* Apply any last-minute PCIC fixups */
 	pci_fixup_pcic(chan);
 
+	pci_write_reg(chan, 0xfd000000, SH7780_PCIMBR0);
+	pci_write_reg(chan, 0x00fc0000, SH7780_PCIMBMR0);
+
+#ifdef CONFIG_32BIT
+	pci_write_reg(chan, 0xc0000000, SH7780_PCIMBR2);
+	pci_write_reg(chan, 0x20000000 - SH7780_PCI_IO_SIZE, SH7780_PCIMBMR2);
+#endif
+
+	/* Set IOBR for windows containing area specified in pci.h */
+	pci_write_reg(chan, chan->io_resource->start & ~(SH7780_PCI_IO_SIZE-1),
+		      SH7780_PCIIOBR);
+	pci_write_reg(chan, ((SH7780_PCI_IO_SIZE-1) & (7<<18)),
+		      SH7780_PCIIOBMR);
+
 	/* SH7780 init done, set central function init complete */
 	/* use round robin mode to stop a device starving/overruning */
 	word = SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_FTO;

commit 4c7a47de897e89c25a40e228ac5319cbac7257fe
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Apr 17 17:21:36 2009 +0900

    sh: pci: Kill off platform-specific multi-window mappings.
    
    Commit 68b42d1b548be1840aff7122fdebeb804daf0fa3 ("sh: sh7785lcr: Map
    whole PCI address space.") changed around the semantics of how various
    chip-selects are made accessible to PCI. Now that there is a single
    large mapping covering from CS0-CS6, there is no longer any need to
    do multi-window mapping. Subsequently, all of the differing
    implementations can be consolidated in to pci-sh7780.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index eb217ddf025f..07c5529a273b 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -90,7 +90,19 @@ struct pci_channel board_pci_channels[] = {
 	{ NULL, NULL, NULL, 0, 0 },
 };
 
-int __init sh7780_pcic_init(struct sh4_pci_address_map *map)
+static struct sh4_pci_address_map sh7780_pci_map = {
+	.window0	= {
+#if defined(CONFIG_32BIT)
+		.base	= SH7780_32BIT_DDR_BASE_ADDR,
+		.size	= 0x40000000,
+#else
+		.base	= SH7780_CS0_BASE_ADDR,
+		.size	= 0x20000000,
+#endif
+	},
+};
+
+int __init pcibios_init_platform(void)
 {
 	struct pci_channel *chan = &board_pci_channels[0];
 	u32 word;
@@ -114,14 +126,10 @@ int __init sh7780_pcic_init(struct sh4_pci_address_map *map)
 	/* Set IO and Mem windows to local address
 	 * Make PCI and local address the same for easy 1 to 1 mapping
 	 */
-	pci_write_reg(chan, map->window0.size - 0xfffff, SH4_PCILSR0);
-	pci_write_reg(chan, map->window1.size - 0xfffff, SH4_PCILSR1);
+	pci_write_reg(chan, sh7780_pci_map.window0.size - 0xfffff, SH4_PCILSR0);
 	/* Set the values on window 0 PCI config registers */
-	pci_write_reg(chan, map->window0.base, SH4_PCILAR0);
-	pci_write_reg(chan, map->window0.base, SH7780_PCIMBAR0);
-	/* Set the values on window 1 PCI config registers */
-	pci_write_reg(chan, map->window1.base, SH4_PCILAR1);
-	pci_write_reg(chan, map->window1.base, SH7780_PCIMBAR1);
+	pci_write_reg(chan, sh7780_pci_map.window0.base, SH4_PCILAR0);
+	pci_write_reg(chan, sh7780_pci_map.window0.base, SH7780_PCIMBAR0);
 
 	/* Apply any last-minute PCIC fixups */
 	pci_fixup_pcic(chan);

commit ab1363a8929f32cc163cd3f50ca72f20d901b00c
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Apr 17 17:07:47 2009 +0900

    sh: pci: Consolidate PCI I/O and mem window definitions for SH7780.
    
    This consolidates all of the PCI I/O and memory window definitions across
    the pci-sh7780 users in pci-sh7780 itself. No functional changes, in that
    every platform had exactly the same implementation.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 207b7206fbda..eb217ddf025f 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -22,7 +22,7 @@
 #include <linux/delay.h>
 #include "pci-sh4.h"
 
-int __init sh7780_pci_init(struct pci_channel *chan)
+static int __init sh7780_pci_init(struct pci_channel *chan)
 {
 	unsigned int id;
 	const char *type = NULL;
@@ -71,9 +71,28 @@ int __init sh7780_pci_init(struct pci_channel *chan)
 
 extern u8 pci_cache_line_size;
 
-int __init sh7780_pcic_init(struct pci_channel *chan,
-			    struct sh4_pci_address_map *map)
+static struct resource sh7785_io_resource = {
+	.name	= "SH7785_IO",
+	.start	= SH7780_PCI_IO_BASE,
+	.end	= SH7780_PCI_IO_BASE + SH7780_PCI_IO_SIZE - 1,
+	.flags	= IORESOURCE_IO
+};
+
+static struct resource sh7785_mem_resource = {
+	.name	= "SH7785_mem",
+	.start	= SH7780_PCI_MEMORY_BASE,
+	.end	= SH7780_PCI_MEMORY_BASE + SH7780_PCI_MEM_SIZE - 1,
+	.flags	= IORESOURCE_MEM
+};
+
+struct pci_channel board_pci_channels[] = {
+	{ sh7780_pci_init, &sh4_pci_ops, &sh7785_io_resource, &sh7785_mem_resource, 0, 0xff },
+	{ NULL, NULL, NULL, 0, 0 },
+};
+
+int __init sh7780_pcic_init(struct sh4_pci_address_map *map)
 {
+	struct pci_channel *chan = &board_pci_channels[0];
 	u32 word;
 
 	/*

commit f1dcab756687622b658154ded1657538984edcdb
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Apr 17 17:00:27 2009 +0900

    sh: pci: Set the I/O port base to the SH7780 I/O window default.
    
    Presently the I/O port base isn't being set anywhere, which allows things
    like generic_inl() to blow up. Fix this up to point at the PCI IO window.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index fa73b0d15888..207b7206fbda 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -112,5 +112,7 @@ int __init sh7780_pcic_init(struct pci_channel *chan,
 	word = SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_FTO;
 	pci_write_reg(chan, word, SH4_PCICR);
 
+	__set_io_port_base(SH7780_PCI_IO_BASE);
+
 	return 0;
 }

commit c66c1d79a94a7a302e2dc6c93da40902423eac3e
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Apr 17 16:38:00 2009 +0900

    sh: pci: Set pci_cache_line_size on SH7780 via the PCICLS register.
    
    The SH7780 PCIC contains a read-only cache line size register that we can
    derive pci_cache_line_size from. So, make sure that the software idea of
    the cache line size actually matches the host controller's idea.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 19bac2168f4f..fa73b0d15888 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -22,15 +22,6 @@
 #include <linux/delay.h>
 #include "pci-sh4.h"
 
-/*
- * Initialization. Try all known PCI access methods. Note that we support
- * using both PCI BIOS and direct access: in such cases, we use I/O ports
- * to access config space.
- *
- * Note that the platform specific initialization (BSC registers, and memory
- * space mapping) will be called via the platform defined function
- * pcibios_init_platform().
- */
 int __init sh7780_pci_init(struct pci_channel *chan)
 {
 	unsigned int id;
@@ -70,19 +61,31 @@ int __init sh7780_pci_init(struct pci_channel *chan)
 	if ((ret = sh4_pci_check_direct(chan)) != 0)
 		return ret;
 
+	/*
+	 * Platform specific initialization (BSC registers, and memory space
+	 * mapping) will be called via the platform defined function
+	 * pcibios_init_platform().
+	 */
 	return pcibios_init_platform();
 }
 
+extern u8 pci_cache_line_size;
+
 int __init sh7780_pcic_init(struct pci_channel *chan,
 			    struct sh4_pci_address_map *map)
 {
 	u32 word;
 
+	/*
+	 * Set the class and sub-class codes.
+	 */
 	__raw_writeb(PCI_CLASS_BRIDGE_HOST >> 8,
 		     chan->reg_base + SH7780_PCIBCC);
 	__raw_writeb(PCI_CLASS_BRIDGE_HOST & 0xff,
 		     chan->reg_base + SH7780_PCISUB);
 
+	pci_cache_line_size = pci_read_reg(chan, SH7780_PCICLS) / 4;
+
 	/* set the command/status bits to:
 	 * Wait Cycle Control + Parity Enable + Bus Master +
 	 * Mem space enable

commit ab78cbcf6877334fc20868b7df7887349e2e01c8
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Apr 17 15:08:01 2009 +0900

    sh: pci: Use the proper write size for class/sub-class code.
    
    Don't use pci_write_reg() for these, as it defaults to 32-bit. Rather
    than using the helper, use __raw_writeb() directly.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 63b5151e9aaa..19bac2168f4f 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -78,8 +78,10 @@ int __init sh7780_pcic_init(struct pci_channel *chan,
 {
 	u32 word;
 
-	pci_write_reg(chan, PCI_CLASS_BRIDGE_HOST >> 8, SH7780_PCIBCC);
-	pci_write_reg(chan, PCI_CLASS_BRIDGE_HOST & 0xff, SH7780_PCISUB);
+	__raw_writeb(PCI_CLASS_BRIDGE_HOST >> 8,
+		     chan->reg_base + SH7780_PCIBCC);
+	__raw_writeb(PCI_CLASS_BRIDGE_HOST & 0xff,
+		     chan->reg_base + SH7780_PCISUB);
 
 	/* set the command/status bits to:
 	 * Wait Cycle Control + Parity Enable + Bus Master +

commit 4e7b7fdb129995640f144b7de114e109c6b46a2a
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Apr 17 15:05:19 2009 +0900

    sh: pci: Rework SH7780 host controller detection.
    
    This reworks how the host controller is probed, and makes it a bit more
    verbose in the event a new type of controller is detected. Additionally,
    we also log the revision information.
    
    This now uses the proper access sizes for the vendor/device registers,
    rather than relying on a larger access that encapsulated both of them.
    Not all devices support 32-bit read cycles for these registers.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 7f4f59037544..63b5151e9aaa 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -34,33 +34,39 @@
 int __init sh7780_pci_init(struct pci_channel *chan)
 {
 	unsigned int id;
-	int ret, match = 0;
+	const char *type = NULL;
+	int ret;
 
-	pr_debug("PCI: Starting intialization.\n");
+	printk(KERN_NOTICE "PCI: Starting intialization.\n");
 
 	chan->reg_base = 0xfe040000;
 	chan->io_base = 0xfe200000;
 
-	ctrl_outl(0x00000001, SH7780_PCI_VCR2); /* Enable PCIC */
-
-	/* check for SH7780/SH7780R hardware */
-	id = pci_read_reg(chan, SH7780_PCIVID);
-	if ((id & 0xffff) == SH7780_VENDOR_ID) {
-		switch ((id >> 16) & 0xffff) {
-		case SH7763_DEVICE_ID:
-		case SH7780_DEVICE_ID:
-		case SH7781_DEVICE_ID:
-		case SH7785_DEVICE_ID:
-			match = 1;
-			break;
-		}
-	}
+	/* Enable CPU access to the PCIC registers. */
+	__raw_writel(PCIECR_ENBL, PCIECR);
 
-	if (unlikely(!match)) {
-		printk(KERN_ERR "PCI: This is not an SH7780 (%x)\n", id);
+	id = __raw_readw(chan->reg_base + SH7780_PCIVID);
+	if (id != SH7780_VENDOR_ID) {
+		printk(KERN_ERR "PCI: Unknown vendor ID 0x%04x.\n", id);
 		return -ENODEV;
 	}
 
+	id = __raw_readw(chan->reg_base + SH7780_PCIDID);
+	type = (id == SH7763_DEVICE_ID)	? "SH7763" :
+	       (id == SH7780_DEVICE_ID) ? "SH7780" :
+	       (id == SH7781_DEVICE_ID) ? "SH7781" :
+	       (id == SH7785_DEVICE_ID) ? "SH7785" :
+					  NULL;
+	if (unlikely(!type)) {
+		printk(KERN_ERR "PCI: Found an unsupported Renesas host "
+		       "controller, device id 0x%04x.\n", id);
+		return -EINVAL;
+	}
+
+	printk(KERN_NOTICE "PCI: Found a Renesas %s host "
+	       "controller, revision %d.\n", type,
+	       __raw_readb(chan->reg_base + SH7780_PCIRID));
+
 	if ((ret = sh4_pci_check_direct(chan)) != 0)
 		return ret;
 

commit 0bbc9bc3189f24de946777af43c9033c8c4871e4
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Apr 17 14:09:09 2009 +0900

    sh: pci: Set class/sub-class code correctly for SH7780 PCIC.
    
    The SH7780 PCI host controller implements a configuration header that
    requires a fair bit of hand-holding to initialize properly. By default
    it appears as a pre-2.0 host controller given the zeroed out class code,
    so fix this up properly.
    
    Some boards that happened to be using the R7780RP version of the PCIC
    fixups had set this correctly, but this belongs in the standard
    initialization, and is by no means board specific.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 45fa423f2e53..7f4f59037544 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -72,16 +72,15 @@ int __init sh7780_pcic_init(struct pci_channel *chan,
 {
 	u32 word;
 
+	pci_write_reg(chan, PCI_CLASS_BRIDGE_HOST >> 8, SH7780_PCIBCC);
+	pci_write_reg(chan, PCI_CLASS_BRIDGE_HOST & 0xff, SH7780_PCISUB);
+
 	/* set the command/status bits to:
 	 * Wait Cycle Control + Parity Enable + Bus Master +
 	 * Mem space enable
 	 */
 	pci_write_reg(chan, 0x00000046, SH7780_PCICMD);
 
-	/* define this host as the host bridge */
-	word = PCI_BASE_CLASS_BRIDGE << 24;
-	pci_write_reg(chan, word, SH7780_PCIRID);
-
 	/* Set IO and Mem windows to local address
 	 * Make PCI and local address the same for easy 1 to 1 mapping
 	 */

commit b627b4ed3d056c5d00e8f3cb32d033b0ee6619a9
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Apr 17 13:00:18 2009 +0900

    sh: pci: Move se7780 INTC fixups out of pci-sh7780.c.
    
    These fixups belong in the board INTC setup code, not in the middle of
    pci-sh7780.c.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index b826c7bc62b9..45fa423f2e53 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -22,20 +22,6 @@
 #include <linux/delay.h>
 #include "pci-sh4.h"
 
-#define INTC_BASE	0xffd00000
-#define INTC_ICR0	(INTC_BASE+0x0)
-#define INTC_ICR1	(INTC_BASE+0x1c)
-#define INTC_INTPRI	(INTC_BASE+0x10)
-#define INTC_INTREQ	(INTC_BASE+0x24)
-#define INTC_INTMSK0	(INTC_BASE+0x44)
-#define INTC_INTMSK1	(INTC_BASE+0x48)
-#define INTC_INTMSK2	(INTC_BASE+0x40080)
-#define INTC_INTMSKCLR0	(INTC_BASE+0x64)
-#define INTC_INTMSKCLR1	(INTC_BASE+0x68)
-#define INTC_INTMSKCLR2	(INTC_BASE+0x40084)
-#define INTC_INT2MSKR	(INTC_BASE+0x40038)
-#define INTC_INT2MSKCR	(INTC_BASE+0x4003c)
-
 /*
  * Initialization. Try all known PCI access methods. Note that we support
  * using both PCI BIOS and direct access: in such cases, we use I/O ports
@@ -75,16 +61,6 @@ int __init sh7780_pci_init(struct pci_channel *chan)
 		return -ENODEV;
 	}
 
-	/* Setup the INTC */
-	if (mach_is_7780se()) {
-		/* ICR0: IRL=use separately */
-		ctrl_outl(0x00C00020, INTC_ICR0);
-		/* ICR1: detect low level(for 2ndcut) */
-		ctrl_outl(0xAAAA0000, INTC_ICR1);
-		/* INTPRI: priority=3(all) */
-		ctrl_outl(0x33333333, INTC_INTPRI);
-	}
-
 	if ((ret = sh4_pci_check_direct(chan)) != 0)
 		return ret;
 

commit 84971bb401866d79c6b353cb1d8861c2b4621867
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Apr 17 12:44:25 2009 +0900

    sh: pci: Kill off useless debugging printk() in pci-sh7780 init.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 282cabe15e36..b826c7bc62b9 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -118,18 +118,6 @@ int __init sh7780_pcic_init(struct pci_channel *chan,
 	pci_write_reg(chan, map->window1.base, SH4_PCILAR1);
 	pci_write_reg(chan, map->window1.base, SH7780_PCIMBAR1);
 
-	/* Map IO space into PCI IO window:
-	 * IO addresses will be translated to the PCI IO window base address
-	 */
-	pr_debug("PCI: Mapping IO address 0x%x - 0x%x to base 0x%lx\n",
-		 chan->io_resource->start, chan->io_resource->end,
-		 chan->io_base + chan->io_resource->start);
-
-	/* NOTE: I'm ignoring the PCI error IRQs for now..
-	 * TODO: add support for the internal error interrupts and
-	 * DMA interrupts...
-	 */
-
 	/* Apply any last-minute PCIC fixups */
 	pci_fixup_pcic(chan);
 

commit 0232ba9ce031d0fd8f331fa8b3c00e16901f54e6
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Apr 16 18:01:31 2009 +0900

    sh: pci: Kill off unused SH4_PCIC_NO_RESET code.
    
    Nothing ended up using this anymore, so just kill it off.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 87a7f3b7a38f..282cabe15e36 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -96,21 +96,6 @@ int __init sh7780_pcic_init(struct pci_channel *chan,
 {
 	u32 word;
 
-	/*
-	 * This code is unused for some boards as it is done in the
-	 * bootloader and doing it here means the MAC addresses loaded
-	 * by the bootloader get lost.
-	 */
-	if (!(map->flags & SH4_PCIC_NO_RESET)) {
-		/* toggle PCI reset pin */
-		word = SH4_PCICR_PREFIX | SH4_PCICR_PRST;
-		pci_write_reg(chan, word, SH4_PCICR);
-		/* Wait for a long time... not 1 sec. but long enough */
-		mdelay(100);
-		word = SH4_PCICR_PREFIX;
-		pci_write_reg(chan, word, SH4_PCICR);
-	}
-
 	/* set the command/status bits to:
 	 * Wait Cycle Control + Parity Enable + Bus Master +
 	 * Mem space enable

commit ef53fdeb7e0cb139aff33665635b886700137abb
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Tue Feb 19 21:35:14 2008 +0900

    sh: add io_base member to pci_channel
    
    Store the io window base address in struct pci_channel and use that one
    instead of SH77xx_PCI_IO_BASE.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 9d6483a26cf9..87a7f3b7a38f 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -53,6 +53,7 @@ int __init sh7780_pci_init(struct pci_channel *chan)
 	pr_debug("PCI: Starting intialization.\n");
 
 	chan->reg_base = 0xfe040000;
+	chan->io_base = 0xfe200000;
 
 	ctrl_outl(0x00000001, SH7780_PCI_VCR2); /* Enable PCIC */
 
@@ -135,9 +136,9 @@ int __init sh7780_pcic_init(struct pci_channel *chan,
 	/* Map IO space into PCI IO window:
 	 * IO addresses will be translated to the PCI IO window base address
 	 */
-	pr_debug("PCI: Mapping IO address 0x%x - 0x%x to base 0x%x\n",
+	pr_debug("PCI: Mapping IO address 0x%x - 0x%x to base 0x%lx\n",
 		 chan->io_resource->start, chan->io_resource->end,
-		 SH7780_PCI_IO_BASE + chan->io_resource->start);
+		 chan->io_base + chan->io_resource->start);
 
 	/* NOTE: I'm ignoring the PCI error IRQs for now..
 	 * TODO: add support for the internal error interrupts and

commit e4c6a3604e07185046e2ce4be82a201f4447d788
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Tue Feb 19 21:35:04 2008 +0900

    sh: add reg_base member to pci_channel
    
    Store the base address of the pci host controller registers in struct
    pci_channel and use the address in pci_read_reg() and pci_write_reg().
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index e8f3a308c075..9d6483a26cf9 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -52,6 +52,8 @@ int __init sh7780_pci_init(struct pci_channel *chan)
 
 	pr_debug("PCI: Starting intialization.\n");
 
+	chan->reg_base = 0xfe040000;
+
 	ctrl_outl(0x00000001, SH7780_PCI_VCR2); /* Enable PCIC */
 
 	/* check for SH7780/SH7780R hardware */

commit 710fa3c81151948ac4d836ef52b57cef91b0ab72
Author: Magnus Damm <damm@igel.co.jp>
Date:   Wed Mar 11 15:47:23 2009 +0900

    sh: avoid using PCIBIOS_MIN_xxx
    
    Replaces PCIBIOS_MIN_IO and PCIBIOS_MIN_MEM with direct struct
    pci_channel access. This allows us to have more than one pci
    channel.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 4706e880b087..e8f3a308c075 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -130,14 +130,12 @@ int __init sh7780_pcic_init(struct pci_channel *chan,
 	pci_write_reg(chan, map->window1.base, SH4_PCILAR1);
 	pci_write_reg(chan, map->window1.base, SH7780_PCIMBAR1);
 
-	/* Map IO space into PCI IO window
-	 * The IO window is 64K-PCIBIOS_MIN_IO in size
-	 * IO addresses will be translated to the
-	 * PCI IO window base address
+	/* Map IO space into PCI IO window:
+	 * IO addresses will be translated to the PCI IO window base address
 	 */
 	pr_debug("PCI: Mapping IO address 0x%x - 0x%x to base 0x%x\n",
-		 PCIBIOS_MIN_IO, (64 << 10),
-		 SH7780_PCI_IO_BASE + PCIBIOS_MIN_IO);
+		 chan->io_resource->start, chan->io_resource->end,
+		 SH7780_PCI_IO_BASE + chan->io_resource->start);
 
 	/* NOTE: I'm ignoring the PCI error IRQs for now..
 	 * TODO: add support for the internal error interrupts and

commit d0e3db40e2a1352aa2a2f425a7d4631bddc03d51
Author: Magnus Damm <damm@igel.co.jp>
Date:   Wed Mar 11 15:46:14 2009 +0900

    sh: add init member to pci_channel data
    
    This patch adds an init callback to struct pci_channel and makes sure
    it is initialized properly. Code is added to call this init function
    from pcibios_init(). Return values are adjusted and a warning is is
    printed if init fails.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 56f673f66cb5..4706e880b087 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -45,7 +45,7 @@
  * space mapping) will be called via the platform defined function
  * pcibios_init_platform().
  */
-static int __init sh7780_pci_init(void)
+int __init sh7780_pci_init(struct pci_channel *chan)
 {
 	unsigned int id;
 	int ret, match = 0;
@@ -55,7 +55,7 @@ static int __init sh7780_pci_init(void)
 	ctrl_outl(0x00000001, SH7780_PCI_VCR2); /* Enable PCIC */
 
 	/* check for SH7780/SH7780R hardware */
-	id = pci_read_reg(NULL, SH7780_PCIVID);
+	id = pci_read_reg(chan, SH7780_PCIVID);
 	if ((id & 0xffff) == SH7780_VENDOR_ID) {
 		switch ((id >> 16) & 0xffff) {
 		case SH7763_DEVICE_ID:
@@ -82,12 +82,11 @@ static int __init sh7780_pci_init(void)
 		ctrl_outl(0x33333333, INTC_INTPRI);
 	}
 
-	if ((ret = sh4_pci_check_direct(NULL)) != 0)
+	if ((ret = sh4_pci_check_direct(chan)) != 0)
 		return ret;
 
 	return pcibios_init_platform();
 }
-core_initcall(sh7780_pci_init);
 
 int __init sh7780_pcic_init(struct pci_channel *chan,
 			    struct sh4_pci_address_map *map)
@@ -153,5 +152,5 @@ int __init sh7780_pcic_init(struct pci_channel *chan,
 	word = SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_FTO;
 	pci_write_reg(chan, word, SH4_PCICR);
 
-	return 1;
+	return 0;
 }

commit b8b47bfbe4eb1ae0e6891e49c86a5f4fb00413be
Author: Magnus Damm <damm@igel.co.jp>
Date:   Wed Mar 11 15:41:51 2009 +0900

    sh: pass along struct pci_channel
    
    These patches rework the pci code for the sh architecture.
    
    Currently each board implements some kind of ioport to address mapping.
    Some boards use generic_io_base others try passing addresses as io ports.
    This is the first set of patches that try to unify the pci code as much
    as possible to avoid duplicated code. This will in the end lead to fewer
    lines board specific code and more generic code.
    
    This patch makes sure a struct pci_channel pointer is passed along to
    various pci functions such as pci_read_reg(), pci_write_reg(),
    pci_fixup_pcic(), sh7751_pcic_init() and sh7780_pcic_init().
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index bae6a2cf047d..56f673f66cb5 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -55,7 +55,7 @@ static int __init sh7780_pci_init(void)
 	ctrl_outl(0x00000001, SH7780_PCI_VCR2); /* Enable PCIC */
 
 	/* check for SH7780/SH7780R hardware */
-	id = pci_read_reg(SH7780_PCIVID);
+	id = pci_read_reg(NULL, SH7780_PCIVID);
 	if ((id & 0xffff) == SH7780_VENDOR_ID) {
 		switch ((id >> 16) & 0xffff) {
 		case SH7763_DEVICE_ID:
@@ -82,14 +82,15 @@ static int __init sh7780_pci_init(void)
 		ctrl_outl(0x33333333, INTC_INTPRI);
 	}
 
-	if ((ret = sh4_pci_check_direct()) != 0)
+	if ((ret = sh4_pci_check_direct(NULL)) != 0)
 		return ret;
 
 	return pcibios_init_platform();
 }
 core_initcall(sh7780_pci_init);
 
-int __init sh7780_pcic_init(struct sh4_pci_address_map *map)
+int __init sh7780_pcic_init(struct pci_channel *chan,
+			    struct sh4_pci_address_map *map)
 {
 	u32 word;
 
@@ -101,34 +102,34 @@ int __init sh7780_pcic_init(struct sh4_pci_address_map *map)
 	if (!(map->flags & SH4_PCIC_NO_RESET)) {
 		/* toggle PCI reset pin */
 		word = SH4_PCICR_PREFIX | SH4_PCICR_PRST;
-		pci_write_reg(word, SH4_PCICR);
+		pci_write_reg(chan, word, SH4_PCICR);
 		/* Wait for a long time... not 1 sec. but long enough */
 		mdelay(100);
 		word = SH4_PCICR_PREFIX;
-		pci_write_reg(word, SH4_PCICR);
+		pci_write_reg(chan, word, SH4_PCICR);
 	}
 
 	/* set the command/status bits to:
 	 * Wait Cycle Control + Parity Enable + Bus Master +
 	 * Mem space enable
 	 */
-	pci_write_reg(0x00000046, SH7780_PCICMD);
+	pci_write_reg(chan, 0x00000046, SH7780_PCICMD);
 
 	/* define this host as the host bridge */
 	word = PCI_BASE_CLASS_BRIDGE << 24;
-	pci_write_reg(word, SH7780_PCIRID);
+	pci_write_reg(chan, word, SH7780_PCIRID);
 
 	/* Set IO and Mem windows to local address
 	 * Make PCI and local address the same for easy 1 to 1 mapping
 	 */
-	pci_write_reg(map->window0.size - 0xfffff, SH4_PCILSR0);
-	pci_write_reg(map->window1.size - 0xfffff, SH4_PCILSR1);
+	pci_write_reg(chan, map->window0.size - 0xfffff, SH4_PCILSR0);
+	pci_write_reg(chan, map->window1.size - 0xfffff, SH4_PCILSR1);
 	/* Set the values on window 0 PCI config registers */
-	pci_write_reg(map->window0.base, SH4_PCILAR0);
-	pci_write_reg(map->window0.base, SH7780_PCIMBAR0);
+	pci_write_reg(chan, map->window0.base, SH4_PCILAR0);
+	pci_write_reg(chan, map->window0.base, SH7780_PCIMBAR0);
 	/* Set the values on window 1 PCI config registers */
-	pci_write_reg(map->window1.base, SH4_PCILAR1);
-	pci_write_reg(map->window1.base, SH7780_PCIMBAR1);
+	pci_write_reg(chan, map->window1.base, SH4_PCILAR1);
+	pci_write_reg(chan, map->window1.base, SH7780_PCIMBAR1);
 
 	/* Map IO space into PCI IO window
 	 * The IO window is 64K-PCIBIOS_MIN_IO in size
@@ -145,12 +146,12 @@ int __init sh7780_pcic_init(struct sh4_pci_address_map *map)
 	 */
 
 	/* Apply any last-minute PCIC fixups */
-	pci_fixup_pcic();
+	pci_fixup_pcic(chan);
 
 	/* SH7780 init done, set central function init complete */
 	/* use round robin mode to stop a device starving/overruning */
 	word = SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_FTO;
-	pci_write_reg(word, SH4_PCICR);
+	pci_write_reg(chan, word, SH4_PCICR);
 
 	return 1;
 }

commit 68b42d1b548be1840aff7122fdebeb804daf0fa3
Author: Takashi Yoshii <yoshii.takashi@renesas.com>
Date:   Thu Apr 2 09:03:30 2009 +0000

    sh: sh7785lcr: Map whole PCI address space.
    
    PCI still doesn't work on sh7785lcr 29bit 256M map mode.
    
    On SH7785, PCI -> SHwy address translation is not base+offset but
    somewhat like base|offset (See HW Manual (rej09b0261) Fig. 13.11).
    So, you can't export CS2,3,4,5 by 256M at CS2 (results CS0,1,2,3
    exported, I guess).  There are two candidates.
    
    a) 128M@CS2 + 128M@CS4
    b) 512M@CS0
    
    Attached patch is B. It maps 512M Byte at 0 independently of memory
    size. It results CS0 to CS6 and perhaps some more being accessible
    from PCI.
    
    Tested on
    7785lcr 29bit 128M map
    7785lcr 29bit 256M map
    (NOT tested on 32bit)
    
    Signed-off-by: Takashi YOSHII <yoshii.takashi@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 773d575a04b9..bae6a2cf047d 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -120,19 +120,15 @@ int __init sh7780_pcic_init(struct sh4_pci_address_map *map)
 
 	/* Set IO and Mem windows to local address
 	 * Make PCI and local address the same for easy 1 to 1 mapping
-	 * Window0 = map->window0.size @ non-cached area base = SDRAM
-	 * Window1 = map->window1.size @ cached area base = SDRAM
 	 */
-	word = (CONFIG_MEMORY_SIZE - 0x00100000) | 0x00000001;
-	pci_write_reg(word, SH4_PCILSR0);
-	pci_write_reg(0x00000001, SH4_PCILSR1);
+	pci_write_reg(map->window0.size - 0xfffff, SH4_PCILSR0);
+	pci_write_reg(map->window1.size - 0xfffff, SH4_PCILSR1);
 	/* Set the values on window 0 PCI config registers */
-	word = CONFIG_MEMORY_START | (CONFIG_MEMORY_SIZE - 0x01000000);
-	pci_write_reg(word, SH4_PCILAR0);
-	pci_write_reg(word, SH7780_PCIMBAR0);
+	pci_write_reg(map->window0.base, SH4_PCILAR0);
+	pci_write_reg(map->window0.base, SH7780_PCIMBAR0);
 	/* Set the values on window 1 PCI config registers */
-	pci_write_reg(0x00000000, SH4_PCILAR1);
-	pci_write_reg(0x00000000, SH7780_PCIMBAR1);
+	pci_write_reg(map->window1.base, SH4_PCILAR1);
+	pci_write_reg(map->window1.base, SH7780_PCIMBAR1);
 
 	/* Map IO space into PCI IO window
 	 * The IO window is 64K-PCIBIOS_MIN_IO in size

commit 8ffe31334262108be343d92e81649f9dc3efe826
Author: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
Date:   Tue Mar 10 15:51:49 2009 +0900

    sh: pci-sh7780: fix pci memory address for fixed PMB
    
    Fix the problem that cannot work a PCI device when 32-bit physical
    address mode.
    
    Signed-off-by: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 078dc44d6b08..773d575a04b9 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -127,8 +127,8 @@ int __init sh7780_pcic_init(struct sh4_pci_address_map *map)
 	pci_write_reg(word, SH4_PCILSR0);
 	pci_write_reg(0x00000001, SH4_PCILSR1);
 	/* Set the values on window 0 PCI config registers */
-	word = (CONFIG_MEMORY_SIZE > 0x08000000) ? 0x10000000 : 0x08000000;
-	pci_write_reg(word | 0xa0000000, SH4_PCILAR0);
+	word = CONFIG_MEMORY_START | (CONFIG_MEMORY_SIZE - 0x01000000);
+	pci_write_reg(word, SH4_PCILAR0);
 	pci_write_reg(word, SH7780_PCIMBAR0);
 	/* Set the values on window 1 PCI config registers */
 	pci_write_reg(0x00000000, SH4_PCILAR1);

commit 331ff103c7737294c8ecd7921564dae07b9e4632
Author: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
Date:   Thu Nov 27 18:57:35 2008 +0900

    sh: pci-sh7780: fix pci memory address mask
    
    Fix the problem that cannot work a PCI device when system memory size is
    256Mbyte in 29bit address mode.
    
    Signed-off-by: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index b2a2bfa3c1bd..078dc44d6b08 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -123,16 +123,14 @@ int __init sh7780_pcic_init(struct sh4_pci_address_map *map)
 	 * Window0 = map->window0.size @ non-cached area base = SDRAM
 	 * Window1 = map->window1.size @ cached area base = SDRAM
 	 */
-	word = ((map->window0.size - 1) & 0x1ff00001) | 0x01;
-	pci_write_reg(0x07f00001, SH4_PCILSR0);
-	word = ((map->window1.size - 1) & 0x1ff00001) | 0x01;
+	word = (CONFIG_MEMORY_SIZE - 0x00100000) | 0x00000001;
+	pci_write_reg(word, SH4_PCILSR0);
 	pci_write_reg(0x00000001, SH4_PCILSR1);
 	/* Set the values on window 0 PCI config registers */
-	word = P2SEGADDR(map->window0.base);
-	pci_write_reg(0xa8000000, SH4_PCILAR0);
-	pci_write_reg(0x08000000, SH7780_PCIMBAR0);
+	word = (CONFIG_MEMORY_SIZE > 0x08000000) ? 0x10000000 : 0x08000000;
+	pci_write_reg(word | 0xa0000000, SH4_PCILAR0);
+	pci_write_reg(word, SH7780_PCIMBAR0);
 	/* Set the values on window 1 PCI config registers */
-	word = P2SEGADDR(map->window1.base);
 	pci_write_reg(0x00000000, SH4_PCILAR1);
 	pci_write_reg(0x00000000, SH7780_PCIMBAR1);
 

commit e036eaa681a17f71b64f6d9040fe605555623919
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Thu Feb 14 13:52:43 2008 +0900

    sh: use ctrl_in/out for on chip pci access
    
    This patch makes sure ctrl_inN/outN are used instead of inN/outN for on chip
    pci registers. Without this patch addresses may be adjusted using the value
    in generic_io_base. This patch makes it possible to set generic_io_base and
    have pci without reading and writing all over the place.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Acked-by: Katsuya MATSUBARA <matsu@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 7d797f4de5e7..b2a2bfa3c1bd 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -52,7 +52,7 @@ static int __init sh7780_pci_init(void)
 
 	pr_debug("PCI: Starting intialization.\n");
 
-	outl(0x00000001, SH7780_PCI_VCR2); /* Enable PCIC */
+	ctrl_outl(0x00000001, SH7780_PCI_VCR2); /* Enable PCIC */
 
 	/* check for SH7780/SH7780R hardware */
 	id = pci_read_reg(SH7780_PCIVID);

commit 7d740a066fb9c6681c2898c7977209725c9e552f
Author: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
Date:   Mon Jan 7 14:40:07 2008 +0900

    sh: Add support for SH7763 CPU subtype.
    
    Signed-off-by: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index e516087fb435..7d797f4de5e7 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -58,6 +58,7 @@ static int __init sh7780_pci_init(void)
 	id = pci_read_reg(SH7780_PCIVID);
 	if ((id & 0xffff) == SH7780_VENDOR_ID) {
 		switch ((id >> 16) & 0xffff) {
+		case SH7763_DEVICE_ID:
 		case SH7780_DEVICE_ID:
 		case SH7781_DEVICE_ID:
 		case SH7785_DEVICE_ID:

commit 9d4c82625914c31fd21e341765d476784cc74f14
Author: Magnus Damm <damm@igel.co.jp>
Date:   Mon Sep 10 12:06:44 2007 +0900

    sh: remove sh7780 interrupt controller hack from pci code
    
    This patch removes the sh778x specific pci code that pokes in the
    interrupt controller and overwrites things. The new and improved IRL
    code manages this in plat_irq_setup() and plat_irq_setup_pins()
    instead.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 5508e45d4838..e516087fb435 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -79,19 +79,6 @@ static int __init sh7780_pci_init(void)
 		ctrl_outl(0xAAAA0000, INTC_ICR1);
 		/* INTPRI: priority=3(all) */
 		ctrl_outl(0x33333333, INTC_INTPRI);
-	} else {
-		/* INTC SH-4 Mode */
-		ctrl_outl(0x00200000, INTC_ICR0);
-		/* enable PCIINTA - PCIINTD */
-		ctrl_outl(0x00078000, INTC_INT2MSKCR);
-		/* disable IRL4-7 Interrupt */
-		ctrl_outl(0x40000000, INTC_INTMSK1);
-		/* disable IRL4-7 Interrupt */
-		ctrl_outl(0x0000fffe, INTC_INTMSK2);
-		/* enable IRL0-3 Interrupt */
-		ctrl_outl(0x80000000, INTC_INTMSKCLR1);
-		/* enable IRL0-3 Interrupt */
-		ctrl_outl(0xfffe0000, INTC_INTMSKCLR2);
 	}
 
 	if ((ret = sh4_pci_check_direct()) != 0)

commit b75762302e144b73f12b72c59b99401d036680aa
Author: Nobuhiro Iwamatsu <nobuhiro.iwamatsu.zh@hitachi.com>
Date:   Thu Mar 29 00:07:35 2007 +0900

    sh: SH7780 Solution Engine board support.
    
    This adds support for the SH7780-based Solution Engine reference board.
    
    Signed-off-by: Nobuhiro Iwamatsu <nobuhiro.iwamatsu.zh@hitachi.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 16b30a9e94bb..5508e45d4838 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -72,12 +72,27 @@ static int __init sh7780_pci_init(void)
 	}
 
 	/* Setup the INTC */
-	ctrl_outl(0x00200000, INTC_ICR0);	/* INTC SH-4 Mode */
-	ctrl_outl(0x00078000, INTC_INT2MSKCR);	/* enable PCIINTA - PCIINTD */
-	ctrl_outl(0x40000000, INTC_INTMSK1);	/* disable IRL4-7 Interrupt */
-	ctrl_outl(0x0000fffe, INTC_INTMSK2);	/* disable IRL4-7 Interrupt */
-	ctrl_outl(0x80000000, INTC_INTMSKCLR1);	/* enable IRL0-3 Interrupt */
-	ctrl_outl(0xfffe0000, INTC_INTMSKCLR2);	/* enable IRL0-3 Interrupt */
+	if (mach_is_7780se()) {
+		/* ICR0: IRL=use separately */
+		ctrl_outl(0x00C00020, INTC_ICR0);
+		/* ICR1: detect low level(for 2ndcut) */
+		ctrl_outl(0xAAAA0000, INTC_ICR1);
+		/* INTPRI: priority=3(all) */
+		ctrl_outl(0x33333333, INTC_INTPRI);
+	} else {
+		/* INTC SH-4 Mode */
+		ctrl_outl(0x00200000, INTC_ICR0);
+		/* enable PCIINTA - PCIINTD */
+		ctrl_outl(0x00078000, INTC_INT2MSKCR);
+		/* disable IRL4-7 Interrupt */
+		ctrl_outl(0x40000000, INTC_INTMSK1);
+		/* disable IRL4-7 Interrupt */
+		ctrl_outl(0x0000fffe, INTC_INTMSK2);
+		/* enable IRL0-3 Interrupt */
+		ctrl_outl(0x80000000, INTC_INTMSKCLR1);
+		/* enable IRL0-3 Interrupt */
+		ctrl_outl(0xfffe0000, INTC_INTMSKCLR2);
+	}
 
 	if ((ret = sh4_pci_check_direct()) != 0)
 		return ret;
@@ -147,9 +162,8 @@ int __init sh7780_pcic_init(struct sh4_pci_address_map *map)
 	 * DMA interrupts...
 	 */
 
-#ifdef CONFIG_SH_HIGHLANDER
+	/* Apply any last-minute PCIC fixups */
 	pci_fixup_pcic();
-#endif
 
 	/* SH7780 init done, set central function init complete */
 	/* use round robin mode to stop a device starving/overruning */

commit 32351a28a7e1f2c68afbe559dd35e1ad0301be6d
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Mar 12 14:38:59 2007 +0900

    sh: Add SH7785 Highlander board support (R7785RP).
    
    This adds preliminary support for the SH7785-based Highlander board.
    Some of the Highlander support code is reordered so that most of it
    can be reused directly.
    
    This also plugs in missing SH7785 checks in the places that need it,
    as this is the first board to support the CPU.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index 602b644c35ad..16b30a9e94bb 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -48,7 +48,7 @@
 static int __init sh7780_pci_init(void)
 {
 	unsigned int id;
-	int ret;
+	int ret, match = 0;
 
 	pr_debug("PCI: Starting intialization.\n");
 
@@ -56,8 +56,17 @@ static int __init sh7780_pci_init(void)
 
 	/* check for SH7780/SH7780R hardware */
 	id = pci_read_reg(SH7780_PCIVID);
-	if ((id != ((SH7780_DEVICE_ID << 16) | SH7780_VENDOR_ID)) &&
-	    (id != ((SH7781_DEVICE_ID << 16) | SH7780_VENDOR_ID))) {
+	if ((id & 0xffff) == SH7780_VENDOR_ID) {
+		switch ((id >> 16) & 0xffff) {
+		case SH7780_DEVICE_ID:
+		case SH7781_DEVICE_ID:
+		case SH7785_DEVICE_ID:
+			match = 1;
+			break;
+		}
+	}
+
+	if (unlikely(!match)) {
 		printk(KERN_ERR "PCI: This is not an SH7780 (%x)\n", id);
 		return -ENODEV;
 	}
@@ -138,7 +147,7 @@ int __init sh7780_pcic_init(struct sh4_pci_address_map *map)
 	 * DMA interrupts...
 	 */
 
-#ifdef CONFIG_SH_R7780RP
+#ifdef CONFIG_SH_HIGHLANDER
 	pci_fixup_pcic();
 #endif
 

commit 9a7ef6d59f9d4780ff5bc9c4d05266b52dcb9211
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Nov 20 13:55:34 2006 +0900

    sh: Drop CPU subtype IRQ headers.
    
    This drops the various IRQ headers that were floating around
    and primarily providing hardcoded IRQ definitions for the
    various CPU subtypes. This quickly got to be an unmaintainable
    mess, made even more evident by the subtle breakage introduced
    by the SH-2 and SH-2A changes.
    
    Now that subtypes are able to register IRQ maps directly, just
    rip all of the headers out.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index d6e635296534..602b644c35ad 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -22,6 +22,20 @@
 #include <linux/delay.h>
 #include "pci-sh4.h"
 
+#define INTC_BASE	0xffd00000
+#define INTC_ICR0	(INTC_BASE+0x0)
+#define INTC_ICR1	(INTC_BASE+0x1c)
+#define INTC_INTPRI	(INTC_BASE+0x10)
+#define INTC_INTREQ	(INTC_BASE+0x24)
+#define INTC_INTMSK0	(INTC_BASE+0x44)
+#define INTC_INTMSK1	(INTC_BASE+0x48)
+#define INTC_INTMSK2	(INTC_BASE+0x40080)
+#define INTC_INTMSKCLR0	(INTC_BASE+0x64)
+#define INTC_INTMSKCLR1	(INTC_BASE+0x68)
+#define INTC_INTMSKCLR2	(INTC_BASE+0x40084)
+#define INTC_INT2MSKR	(INTC_BASE+0x40038)
+#define INTC_INT2MSKCR	(INTC_BASE+0x4003c)
+
 /*
  * Initialization. Try all known PCI access methods. Note that we support
  * using both PCI BIOS and direct access: in such cases, we use I/O ports

commit 2914d4da172f53f71d0563d3c3bae14e496cbc86
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Oct 3 13:19:02 2006 +0900

    sh: Kill off remaining config.h references.
    
    A few of these managed to sneak back in, get rid of them once
    and for all.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index bd3064a82087..d6e635296534 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -12,10 +12,8 @@
  *  License.  See linux/COPYING for more information.
  *
  */
-
 #undef DEBUG
 
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/init.h>

commit 959f85f8a3223c116bbe95dd8a9b207790b5d4d3
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 16:43:28 2006 +0900

    sh: Consolidated SH7751/SH7780 PCI support.
    
    This cleans up quite a lot of the PCI mess that we
    currently have, and attempts to consolidate the
    duplication in the SH7780 and SH7751 PCI controllers.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
index e09721330ac2..bd3064a82087 100644
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -20,197 +20,36 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/pci.h>
-#include <linux/sched.h>
-#include <linux/ioport.h>
 #include <linux/errno.h>
-#include <linux/irq.h>
 #include <linux/delay.h>
-
-#include <asm/machvec.h>
-#include <asm/io.h>
-#include "pci-sh7780.h"
-
-static unsigned int pci_probe = PCI_PROBE_CONF1;
-extern int pci_fixup_pcic(void);
-
-/*
- * Direct access to PCI hardware...
- */
-
-#define CONFIG_CMD(bus, devfn, where) (0x80000000 | (bus->number << 16) | (devfn << 8) | (where & ~3))
-
-/*
- * Functions for accessing PCI configuration space with type 1 accesses
- */
-static int sh7780_pci_read(struct pci_bus *bus, unsigned int devfn,
-			   int where, int size, u32 *val)
-{
-	unsigned long flags;
-	u32 data;
-
-	/*
-	 * PCIPDR may only be accessed as 32 bit words,
-	 * so we must do byte alignment by hand
-	 */
-	local_irq_save(flags);
-	outl(CONFIG_CMD(bus, devfn, where), PCI_REG(SH7780_PCIPAR));
-	data = inl(PCI_REG(SH7780_PCIPDR));
-	local_irq_restore(flags);
-
-	switch (size) {
-	case 1:
-		*val = (data >> ((where & 3) << 3)) & 0xff;
-		break;
-	case 2:
-		*val = (data >> ((where & 2) << 3)) & 0xffff;
-		break;
-	case 4:
-		*val = data;
-		break;
-	default:
-		return PCIBIOS_FUNC_NOT_SUPPORTED;
-	}
-
-	return PCIBIOS_SUCCESSFUL;
-}
+#include "pci-sh4.h"
 
 /*
- * Since SH7780 only does 32bit access we'll have to do a read,
- * mask,write operation.
- * We'll allow an odd byte offset, though it should be illegal.
+ * Initialization. Try all known PCI access methods. Note that we support
+ * using both PCI BIOS and direct access: in such cases, we use I/O ports
+ * to access config space.
+ *
+ * Note that the platform specific initialization (BSC registers, and memory
+ * space mapping) will be called via the platform defined function
+ * pcibios_init_platform().
  */
-static int sh7780_pci_write(struct pci_bus *bus, unsigned int devfn,
-			    int where, int size, u32 val)
+static int __init sh7780_pci_init(void)
 {
-	unsigned long flags;
-	int shift;
-	u32 data;
-
-	local_irq_save(flags);
-	outl(CONFIG_CMD(bus, devfn, where), PCI_REG(SH7780_PCIPAR));
-	data = inl(PCI_REG(SH7780_PCIPDR));
-	local_irq_restore(flags);
-
-	switch (size) {
-	case 1:
-		shift = (where & 3) << 3;
-		data &= ~(0xff << shift);
-		data |= ((val & 0xff) << shift);
-		break;
-	case 2:
-		shift = (where & 2) << 3;
-		data &= ~(0xffff << shift);
-		data |= ((val & 0xffff) << shift);
-		break;
-	case 4:
-		data = val;
-		break;
-	default:
-		return PCIBIOS_FUNC_NOT_SUPPORTED;
-	}
-
-	outl(data, PCI_REG(SH7780_PCIPDR));
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-#undef CONFIG_CMD
-
-struct pci_ops sh7780_pci_ops = {
-	.read		= sh7780_pci_read,
-	.write		= sh7780_pci_write,
-};
+	unsigned int id;
+	int ret;
 
-static int __init pci_check_direct(void)
-{
-	unsigned int tmp, id;
+	pr_debug("PCI: Starting intialization.\n");
 
 	outl(0x00000001, SH7780_PCI_VCR2); /* Enable PCIC */
 
 	/* check for SH7780/SH7780R hardware */
-	id = inl(PCI_REG(SH7780_PCIVID));
+	id = pci_read_reg(SH7780_PCIVID);
 	if ((id != ((SH7780_DEVICE_ID << 16) | SH7780_VENDOR_ID)) &&
 	    (id != ((SH7781_DEVICE_ID << 16) | SH7780_VENDOR_ID))) {
 		printk(KERN_ERR "PCI: This is not an SH7780 (%x)\n", id);
 		return -ENODEV;
 	}
 
-	/*
-	 * Check if configuration works.
-	 */
-	if (pci_probe & PCI_PROBE_CONF1) {
-		tmp = inl(PCI_REG(SH7780_PCIPAR));
-		outl(0x80000000, PCI_REG(SH7780_PCIPAR));
-		if (inl(PCI_REG(SH7780_PCIPAR)) == 0x80000000) {
-			outl(tmp, PCI_REG(SH7780_PCIPAR));
-			printk(KERN_INFO "PCI: Using configuration type 1\n");
-			request_region(PCI_REG(SH7780_PCIPAR), 8, "PCI conf1");
-			return 0;
-		}
-		outl(tmp, PCI_REG(SH7780_PCIPAR));
-	}
-
-	pr_debug("PCI: pci_check_direct failed\n");
-	return -EINVAL;
-}
-
-/***************************************************************************************/
-
-/*
- *  Handle bus scanning and fixups ....
- */
-
-static void __init pci_fixup_ide_bases(struct pci_dev *d)
-{
-	int i;
-
-	/*
-	 * PCI IDE controllers use non-standard I/O port decoding, respect it.
-	 */
-	if ((d->class >> 8) != PCI_CLASS_STORAGE_IDE)
-		return;
-	pr_debug("PCI: IDE base address fixup for %s\n", pci_name(d));
-	for(i=0; i<4; i++) {
-		struct resource *r = &d->resource[i];
-		if ((r->start & ~0x80) == 0x374) {
-			r->start |= 2;
-			r->end = r->start;
-		}
-	}
-}
-
-DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, pci_fixup_ide_bases);
-
-/*
- *  Called after each bus is probed, but before its children
- *  are examined.
- */
-
-void __init pcibios_fixup_bus(struct pci_bus *b)
-{
-	pci_read_bridge_bases(b);
-}
-
-/*
- * Initialization. Try all known PCI access methods. Note that we support
- * using both PCI BIOS and direct access: in such cases, we use I/O ports
- * to access config space.
- *
- * Note that the platform specific initialization (BSC registers, and memory
- * space mapping) will be called via the machine vectors (sh_mv.mv_pci_init()) if it
- * exists and via the platform defined function pcibios_init_platform().
- * See pci_bigsur.c for implementation;
- *
- * The BIOS version of the pci functions is not yet implemented but it is left
- * in for completeness.  Currently an error will be genereated at compile time.
- */
-
-static int __init sh7780_pci_init(void)
-{
-	int ret;
-
-	pr_debug("PCI: Starting intialization.\n");
-
 	/* Setup the INTC */
 	ctrl_outl(0x00200000, INTC_ICR0);	/* INTC SH-4 Mode */
 	ctrl_outl(0x00078000, INTC_INT2MSKCR);	/* enable PCIINTA - PCIINTD */
@@ -219,15 +58,14 @@ static int __init sh7780_pci_init(void)
 	ctrl_outl(0x80000000, INTC_INTMSKCLR1);	/* enable IRL0-3 Interrupt */
 	ctrl_outl(0xfffe0000, INTC_INTMSKCLR2);	/* enable IRL0-3 Interrupt */
 
-	if ((ret = pci_check_direct()) != 0)
+	if ((ret = sh4_pci_check_direct()) != 0)
 		return ret;
 
 	return pcibios_init_platform();
 }
-
 core_initcall(sh7780_pci_init);
 
-int __init sh7780_pcic_init(struct sh7780_pci_address_map *map)
+int __init sh7780_pcic_init(struct sh4_pci_address_map *map)
 {
 	u32 word;
 
@@ -236,25 +74,25 @@ int __init sh7780_pcic_init(struct sh7780_pci_address_map *map)
 	 * bootloader and doing it here means the MAC addresses loaded
 	 * by the bootloader get lost.
 	 */
-	if (!(map->flags & SH7780_PCIC_NO_RESET)) {
+	if (!(map->flags & SH4_PCIC_NO_RESET)) {
 		/* toggle PCI reset pin */
-		word = SH7780_PCICR_PREFIX | SH7780_PCICR_PRST;
-		outl(word,PCI_REG(SH7780_PCICR));
+		word = SH4_PCICR_PREFIX | SH4_PCICR_PRST;
+		pci_write_reg(word, SH4_PCICR);
 		/* Wait for a long time... not 1 sec. but long enough */
 		mdelay(100);
-		word = SH7780_PCICR_PREFIX;
-		outl(word,PCI_REG(SH7780_PCICR));
+		word = SH4_PCICR_PREFIX;
+		pci_write_reg(word, SH4_PCICR);
 	}
 
 	/* set the command/status bits to:
 	 * Wait Cycle Control + Parity Enable + Bus Master +
 	 * Mem space enable
 	 */
-	outl(0x00000046, PCI_REG(SH7780_PCICMD));
+	pci_write_reg(0x00000046, SH7780_PCICMD);
 
 	/* define this host as the host bridge */
-	word = SH7780_PCI_HOST_BRIDGE << 24;
-	outl(word, PCI_REG(SH7780_PCIRID));
+	word = PCI_BASE_CLASS_BRIDGE << 24;
+	pci_write_reg(word, SH7780_PCIRID);
 
 	/* Set IO and Mem windows to local address
 	 * Make PCI and local address the same for easy 1 to 1 mapping
@@ -262,25 +100,26 @@ int __init sh7780_pcic_init(struct sh7780_pci_address_map *map)
 	 * Window1 = map->window1.size @ cached area base = SDRAM
 	 */
 	word = ((map->window0.size - 1) & 0x1ff00001) | 0x01;
-	outl(0x07f00001, PCI_REG(SH7780_PCILSR0));
+	pci_write_reg(0x07f00001, SH4_PCILSR0);
 	word = ((map->window1.size - 1) & 0x1ff00001) | 0x01;
-	outl(0x00000001, PCI_REG(SH7780_PCILSR1));
+	pci_write_reg(0x00000001, SH4_PCILSR1);
 	/* Set the values on window 0 PCI config registers */
 	word = P2SEGADDR(map->window0.base);
-	outl(0xa8000000, PCI_REG(SH7780_PCILAR0));
-	outl(0x08000000, PCI_REG(SH7780_PCIMBAR0));
+	pci_write_reg(0xa8000000, SH4_PCILAR0);
+	pci_write_reg(0x08000000, SH7780_PCIMBAR0);
 	/* Set the values on window 1 PCI config registers */
 	word = P2SEGADDR(map->window1.base);
-	outl(0x00000000, PCI_REG(SH7780_PCILAR1));
-	outl(0x00000000, PCI_REG(SH7780_PCIMBAR1));
+	pci_write_reg(0x00000000, SH4_PCILAR1);
+	pci_write_reg(0x00000000, SH7780_PCIMBAR1);
 
 	/* Map IO space into PCI IO window
 	 * The IO window is 64K-PCIBIOS_MIN_IO in size
 	 * IO addresses will be translated to the
 	 * PCI IO window base address
 	 */
-	PCIDBG(3,"PCI: Mapping IO address 0x%x - 0x%x to base 0x%x\n", PCIBIOS_MIN_IO,
-	    (64*1024), SH7780_PCI_IO_BASE+PCIBIOS_MIN_IO);
+	pr_debug("PCI: Mapping IO address 0x%x - 0x%x to base 0x%x\n",
+		 PCIBIOS_MIN_IO, (64 << 10),
+		 SH7780_PCI_IO_BASE + PCIBIOS_MIN_IO);
 
 	/* NOTE: I'm ignoring the PCI error IRQs for now..
 	 * TODO: add support for the internal error interrupts and
@@ -293,49 +132,8 @@ int __init sh7780_pcic_init(struct sh7780_pci_address_map *map)
 
 	/* SH7780 init done, set central function init complete */
 	/* use round robin mode to stop a device starving/overruning */
-	word = SH7780_PCICR_PREFIX | SH7780_PCICR_CFIN | /* SH7780_PCICR_ARBM |*/ SH7780_PCICR_FTO;
-	outl(word, PCI_REG(SH7780_PCICR));
+	word = SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_FTO;
+	pci_write_reg(word, SH4_PCICR);
 
 	return 1;
 }
-
-char * __init pcibios_setup(char *str)
-{
-	if (!strcmp(str, "off")) {
-		pci_probe = 0;
-		return NULL;
-	}
-
-	return str;
-}
-
-/*
- *	IRQ functions
- */
-static u8 __init sh7780_no_swizzle(struct pci_dev *dev, u8 *pin)
-{
-	/* no swizzling */
-	return PCI_SLOT(dev->devfn);
-}
-
-static int sh7780_pci_lookup_irq(struct pci_dev *dev, u8 slot, u8 pin)
-{
-	int irq = -1;
-
-	/* now lookup the actual IRQ on a platform specific basis (pci-'platform'.c) */
-	irq = pcibios_map_platform_irq(slot,pin);
-	if( irq < 0 ) {
-		pr_debug("PCI: Error mapping IRQ on device %s\n", pci_name(dev));
-		return irq;
-	}
-
-	pr_debug("Setting IRQ for slot %s to %d\n", pci_name(dev), irq);
-
-	return irq;
-}
-
-void __init pcibios_fixup_irqs(void)
-{
-	pci_fixup_irqs(sh7780_no_swizzle, sh7780_pci_lookup_irq);
-}
-

commit 5283ecb5ccbdb90d49fce6488d3944bba63a591c
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 15:59:17 2006 +0900

    sh: Add support for R7780RP and R7780MP boards.
    
    This adds support for the Renesas SH7780 development boards,
    R7780RP and R7780MP.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
new file mode 100644
index 000000000000..e09721330ac2
--- /dev/null
+++ b/arch/sh/drivers/pci/pci-sh7780.c
@@ -0,0 +1,341 @@
+/*
+ *	Low-Level PCI Support for the SH7780
+ *
+ *  Dustin McIntire (dustin@sensoria.com)
+ *	Derived from arch/i386/kernel/pci-*.c which bore the message:
+ *	(c) 1999--2000 Martin Mares <mj@ucw.cz>
+ *
+ *  Ported to the new API by Paul Mundt <lethal@linux-sh.org>
+ *  With cleanup by Paul van Gool <pvangool@mimotech.com>
+ *
+ *  May be copied or modified under the terms of the GNU General Public
+ *  License.  See linux/COPYING for more information.
+ *
+ */
+
+#undef DEBUG
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/errno.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+
+#include <asm/machvec.h>
+#include <asm/io.h>
+#include "pci-sh7780.h"
+
+static unsigned int pci_probe = PCI_PROBE_CONF1;
+extern int pci_fixup_pcic(void);
+
+/*
+ * Direct access to PCI hardware...
+ */
+
+#define CONFIG_CMD(bus, devfn, where) (0x80000000 | (bus->number << 16) | (devfn << 8) | (where & ~3))
+
+/*
+ * Functions for accessing PCI configuration space with type 1 accesses
+ */
+static int sh7780_pci_read(struct pci_bus *bus, unsigned int devfn,
+			   int where, int size, u32 *val)
+{
+	unsigned long flags;
+	u32 data;
+
+	/*
+	 * PCIPDR may only be accessed as 32 bit words,
+	 * so we must do byte alignment by hand
+	 */
+	local_irq_save(flags);
+	outl(CONFIG_CMD(bus, devfn, where), PCI_REG(SH7780_PCIPAR));
+	data = inl(PCI_REG(SH7780_PCIPDR));
+	local_irq_restore(flags);
+
+	switch (size) {
+	case 1:
+		*val = (data >> ((where & 3) << 3)) & 0xff;
+		break;
+	case 2:
+		*val = (data >> ((where & 2) << 3)) & 0xffff;
+		break;
+	case 4:
+		*val = data;
+		break;
+	default:
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+/*
+ * Since SH7780 only does 32bit access we'll have to do a read,
+ * mask,write operation.
+ * We'll allow an odd byte offset, though it should be illegal.
+ */
+static int sh7780_pci_write(struct pci_bus *bus, unsigned int devfn,
+			    int where, int size, u32 val)
+{
+	unsigned long flags;
+	int shift;
+	u32 data;
+
+	local_irq_save(flags);
+	outl(CONFIG_CMD(bus, devfn, where), PCI_REG(SH7780_PCIPAR));
+	data = inl(PCI_REG(SH7780_PCIPDR));
+	local_irq_restore(flags);
+
+	switch (size) {
+	case 1:
+		shift = (where & 3) << 3;
+		data &= ~(0xff << shift);
+		data |= ((val & 0xff) << shift);
+		break;
+	case 2:
+		shift = (where & 2) << 3;
+		data &= ~(0xffff << shift);
+		data |= ((val & 0xffff) << shift);
+		break;
+	case 4:
+		data = val;
+		break;
+	default:
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+	}
+
+	outl(data, PCI_REG(SH7780_PCIPDR));
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+#undef CONFIG_CMD
+
+struct pci_ops sh7780_pci_ops = {
+	.read		= sh7780_pci_read,
+	.write		= sh7780_pci_write,
+};
+
+static int __init pci_check_direct(void)
+{
+	unsigned int tmp, id;
+
+	outl(0x00000001, SH7780_PCI_VCR2); /* Enable PCIC */
+
+	/* check for SH7780/SH7780R hardware */
+	id = inl(PCI_REG(SH7780_PCIVID));
+	if ((id != ((SH7780_DEVICE_ID << 16) | SH7780_VENDOR_ID)) &&
+	    (id != ((SH7781_DEVICE_ID << 16) | SH7780_VENDOR_ID))) {
+		printk(KERN_ERR "PCI: This is not an SH7780 (%x)\n", id);
+		return -ENODEV;
+	}
+
+	/*
+	 * Check if configuration works.
+	 */
+	if (pci_probe & PCI_PROBE_CONF1) {
+		tmp = inl(PCI_REG(SH7780_PCIPAR));
+		outl(0x80000000, PCI_REG(SH7780_PCIPAR));
+		if (inl(PCI_REG(SH7780_PCIPAR)) == 0x80000000) {
+			outl(tmp, PCI_REG(SH7780_PCIPAR));
+			printk(KERN_INFO "PCI: Using configuration type 1\n");
+			request_region(PCI_REG(SH7780_PCIPAR), 8, "PCI conf1");
+			return 0;
+		}
+		outl(tmp, PCI_REG(SH7780_PCIPAR));
+	}
+
+	pr_debug("PCI: pci_check_direct failed\n");
+	return -EINVAL;
+}
+
+/***************************************************************************************/
+
+/*
+ *  Handle bus scanning and fixups ....
+ */
+
+static void __init pci_fixup_ide_bases(struct pci_dev *d)
+{
+	int i;
+
+	/*
+	 * PCI IDE controllers use non-standard I/O port decoding, respect it.
+	 */
+	if ((d->class >> 8) != PCI_CLASS_STORAGE_IDE)
+		return;
+	pr_debug("PCI: IDE base address fixup for %s\n", pci_name(d));
+	for(i=0; i<4; i++) {
+		struct resource *r = &d->resource[i];
+		if ((r->start & ~0x80) == 0x374) {
+			r->start |= 2;
+			r->end = r->start;
+		}
+	}
+}
+
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, pci_fixup_ide_bases);
+
+/*
+ *  Called after each bus is probed, but before its children
+ *  are examined.
+ */
+
+void __init pcibios_fixup_bus(struct pci_bus *b)
+{
+	pci_read_bridge_bases(b);
+}
+
+/*
+ * Initialization. Try all known PCI access methods. Note that we support
+ * using both PCI BIOS and direct access: in such cases, we use I/O ports
+ * to access config space.
+ *
+ * Note that the platform specific initialization (BSC registers, and memory
+ * space mapping) will be called via the machine vectors (sh_mv.mv_pci_init()) if it
+ * exists and via the platform defined function pcibios_init_platform().
+ * See pci_bigsur.c for implementation;
+ *
+ * The BIOS version of the pci functions is not yet implemented but it is left
+ * in for completeness.  Currently an error will be genereated at compile time.
+ */
+
+static int __init sh7780_pci_init(void)
+{
+	int ret;
+
+	pr_debug("PCI: Starting intialization.\n");
+
+	/* Setup the INTC */
+	ctrl_outl(0x00200000, INTC_ICR0);	/* INTC SH-4 Mode */
+	ctrl_outl(0x00078000, INTC_INT2MSKCR);	/* enable PCIINTA - PCIINTD */
+	ctrl_outl(0x40000000, INTC_INTMSK1);	/* disable IRL4-7 Interrupt */
+	ctrl_outl(0x0000fffe, INTC_INTMSK2);	/* disable IRL4-7 Interrupt */
+	ctrl_outl(0x80000000, INTC_INTMSKCLR1);	/* enable IRL0-3 Interrupt */
+	ctrl_outl(0xfffe0000, INTC_INTMSKCLR2);	/* enable IRL0-3 Interrupt */
+
+	if ((ret = pci_check_direct()) != 0)
+		return ret;
+
+	return pcibios_init_platform();
+}
+
+core_initcall(sh7780_pci_init);
+
+int __init sh7780_pcic_init(struct sh7780_pci_address_map *map)
+{
+	u32 word;
+
+	/*
+	 * This code is unused for some boards as it is done in the
+	 * bootloader and doing it here means the MAC addresses loaded
+	 * by the bootloader get lost.
+	 */
+	if (!(map->flags & SH7780_PCIC_NO_RESET)) {
+		/* toggle PCI reset pin */
+		word = SH7780_PCICR_PREFIX | SH7780_PCICR_PRST;
+		outl(word,PCI_REG(SH7780_PCICR));
+		/* Wait for a long time... not 1 sec. but long enough */
+		mdelay(100);
+		word = SH7780_PCICR_PREFIX;
+		outl(word,PCI_REG(SH7780_PCICR));
+	}
+
+	/* set the command/status bits to:
+	 * Wait Cycle Control + Parity Enable + Bus Master +
+	 * Mem space enable
+	 */
+	outl(0x00000046, PCI_REG(SH7780_PCICMD));
+
+	/* define this host as the host bridge */
+	word = SH7780_PCI_HOST_BRIDGE << 24;
+	outl(word, PCI_REG(SH7780_PCIRID));
+
+	/* Set IO and Mem windows to local address
+	 * Make PCI and local address the same for easy 1 to 1 mapping
+	 * Window0 = map->window0.size @ non-cached area base = SDRAM
+	 * Window1 = map->window1.size @ cached area base = SDRAM
+	 */
+	word = ((map->window0.size - 1) & 0x1ff00001) | 0x01;
+	outl(0x07f00001, PCI_REG(SH7780_PCILSR0));
+	word = ((map->window1.size - 1) & 0x1ff00001) | 0x01;
+	outl(0x00000001, PCI_REG(SH7780_PCILSR1));
+	/* Set the values on window 0 PCI config registers */
+	word = P2SEGADDR(map->window0.base);
+	outl(0xa8000000, PCI_REG(SH7780_PCILAR0));
+	outl(0x08000000, PCI_REG(SH7780_PCIMBAR0));
+	/* Set the values on window 1 PCI config registers */
+	word = P2SEGADDR(map->window1.base);
+	outl(0x00000000, PCI_REG(SH7780_PCILAR1));
+	outl(0x00000000, PCI_REG(SH7780_PCIMBAR1));
+
+	/* Map IO space into PCI IO window
+	 * The IO window is 64K-PCIBIOS_MIN_IO in size
+	 * IO addresses will be translated to the
+	 * PCI IO window base address
+	 */
+	PCIDBG(3,"PCI: Mapping IO address 0x%x - 0x%x to base 0x%x\n", PCIBIOS_MIN_IO,
+	    (64*1024), SH7780_PCI_IO_BASE+PCIBIOS_MIN_IO);
+
+	/* NOTE: I'm ignoring the PCI error IRQs for now..
+	 * TODO: add support for the internal error interrupts and
+	 * DMA interrupts...
+	 */
+
+#ifdef CONFIG_SH_R7780RP
+	pci_fixup_pcic();
+#endif
+
+	/* SH7780 init done, set central function init complete */
+	/* use round robin mode to stop a device starving/overruning */
+	word = SH7780_PCICR_PREFIX | SH7780_PCICR_CFIN | /* SH7780_PCICR_ARBM |*/ SH7780_PCICR_FTO;
+	outl(word, PCI_REG(SH7780_PCICR));
+
+	return 1;
+}
+
+char * __init pcibios_setup(char *str)
+{
+	if (!strcmp(str, "off")) {
+		pci_probe = 0;
+		return NULL;
+	}
+
+	return str;
+}
+
+/*
+ *	IRQ functions
+ */
+static u8 __init sh7780_no_swizzle(struct pci_dev *dev, u8 *pin)
+{
+	/* no swizzling */
+	return PCI_SLOT(dev->devfn);
+}
+
+static int sh7780_pci_lookup_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int irq = -1;
+
+	/* now lookup the actual IRQ on a platform specific basis (pci-'platform'.c) */
+	irq = pcibios_map_platform_irq(slot,pin);
+	if( irq < 0 ) {
+		pr_debug("PCI: Error mapping IRQ on device %s\n", pci_name(dev));
+		return irq;
+	}
+
+	pr_debug("Setting IRQ for slot %s to %d\n", pci_name(dev), irq);
+
+	return irq;
+}
+
+void __init pcibios_fixup_irqs(void)
+{
+	pci_fixup_irqs(sh7780_no_swizzle, sh7780_pci_lookup_irq);
+}
+
