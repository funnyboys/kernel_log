commit ff4a7481c3898ffc3cc271d6aca431d190c37247
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 28 00:31:49 2018 -0800

    sh: drivers: convert to SPDX identifiers
    
    Update license to use SPDX-License-Identifier instead of verbose license
    text.
    
    As original license mentioned, it is GPL-2.0 in SPDX.
    Then, MODULE_LICENSE() should be "GPL v2" instead of "GPL".
    See ${LINUX}/include/linux/module.h
    
            "GPL"           [GNU Public License v2 or later]
            "GPL v2"        [GNU Public License v2]
    
    Link: http://lkml.kernel.org/r/87h8fsct0a.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 8256626bc53c..c7784e156964 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * New-style PCI core.
  *
@@ -6,10 +7,6 @@
  *
  * Modelled after arch/mips/pci/pci.c:
  *  Copyright (C) 2003, 04 Ralf Baechle (ralf@linux-mips.org)
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 #include <linux/kernel.h>
 #include <linux/mm.h>

commit a8651194f9f61406cb8926feeeb7829258295b2a
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jul 30 09:38:42 2018 +0200

    PCI: Call dma_debug_add_bus() for pci_bus_type from PCI core
    
    There is nothing arch-specific about PCI or dma-debug, so call
    dma_debug_add_bus() from the PCI core just after registering the bus type.
    
    Most of dma-debug is already generic; this just adds reporting of pending
    dma-allocations on driver unload for arches other than powerpc, sh, and
    x86.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index e5b7437ab4af..8256626bc53c 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -160,8 +160,6 @@ static int __init pcibios_init(void)
 	for (hose = hose_head; hose; hose = hose->next)
 		pcibios_scanbus(hose);
 
-	dma_debug_add_bus(&pci_bus_type);
-
 	pci_initialized = 1;
 
 	return 0;

commit 3aeb93a014058eb889cbb12c1f61f59666b9a081
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon Dec 4 16:09:02 2017 +0100

    arch/sh: pci: don't use disabled resources
    
    In pcibios_scanbus(), we provide to the PCI core the usable MEM and IO
    regions using pci_add_resource_offset(). We travel through all
    resources available in the "struct pci_channel".
    
    Also, in register_pci_controller(), we travel through all resources to
    request them, making sure they don't conflict with already requested
    resources.
    
    However, some resources may be disabled, in which case they should not
    be requested nor provided to the PCI core.
    
    In the current situation, none of the resources are disabled. However,
    follow-up patches in this series will make some resources disabled,
    making this preliminary change necessary.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Rich Felker <dalias@libc.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 5976a2c8a3e3..e5b7437ab4af 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -49,6 +49,8 @@ static void pcibios_scanbus(struct pci_channel *hose)
 	for (i = 0; i < hose->nr_resources; i++) {
 		res = hose->resources + i;
 		offset = 0;
+		if (res->flags & IORESOURCE_DISABLED)
+			continue;
 		if (res->flags & IORESOURCE_IO)
 			offset = hose->io_offset;
 		else if (res->flags & IORESOURCE_MEM)
@@ -102,6 +104,9 @@ int register_pci_controller(struct pci_channel *hose)
 	for (i = 0; i < hose->nr_resources; i++) {
 		struct resource *res = hose->resources + i;
 
+		if (res->flags & IORESOURCE_DISABLED)
+			continue;
+
 		if (res->flags & IORESOURCE_IO) {
 			if (request_resource(&ioport_resource, res) < 0)
 				goto out;

commit 9198407e23ec89f0e1562f439771aeea83345d0d
Merge: d872694bac21 c775697b713b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Sep 7 13:24:19 2017 -0500

    Merge branch 'pci/resource' into next
    
    * pci/resource:
      microblaze/PCI: Remove pcibios_setup_bus_{self/devices} dead code
      ARC: Remove empty kernel/pcibios.c
      PCI: Add a generic weak pcibios_align_resource()
      PCI: Add a generic weak pcibios_fixup_bus()

commit 20d693225ab78f0651b0e116b74196aaf8a950bb
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Jul 31 17:37:50 2017 +0100

    sh/PCI: Replace pci_fixup_irqs() call with host bridge IRQ mapping hooks
    
    The pci_fixup_irqs() function allocates IRQs for all PCI devices present in
    a system; those PCI devices possibly belong to different PCI bus trees (and
    possibly rooted at different host bridges) and may well be enabled (ie
    probed and bound to a driver) by the time pci_fixup_irqs() is called when
    probing a given host bridge driver.
    
    Furthermore, current kernel code relying on pci_fixup_irqs() to assign
    legacy PCI IRQs to devices does not work at all for hotplugged devices in
    that the code carrying out the IRQ fixup is called at host bridge driver
    probe time, which just cannot take into account devices hotplugged after
    the system has booted.
    
    The introduction of map/swizzle function hooks in struct pci_host_bridge
    allows us to define per-bridge map/swizzle functions that can be used at
    device probe time in PCI core code to allocate IRQs for a given device
    (through pci_assign_irq()).
    
    Convert PCI host bridge initialization code to the
    pci_scan_root_bus_bridge() API (that allows to pass a struct
    pci_host_bridge with initialized map/swizzle pointers) and remove the
    pci_fixup_irqs() call from arch code.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index c99ee286b69f..357278c88e98 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -39,8 +39,12 @@ static void pcibios_scanbus(struct pci_channel *hose)
 	LIST_HEAD(resources);
 	struct resource *res;
 	resource_size_t offset;
-	int i;
-	struct pci_bus *bus;
+	int i, ret;
+	struct pci_host_bridge *bridge;
+
+	bridge = pci_alloc_host_bridge(0);
+	if (!bridge)
+		return;
 
 	for (i = 0; i < hose->nr_resources; i++) {
 		res = hose->resources + i;
@@ -52,19 +56,26 @@ static void pcibios_scanbus(struct pci_channel *hose)
 		pci_add_resource_offset(&resources, res, offset);
 	}
 
-	bus = pci_scan_root_bus(NULL, next_busno, hose->pci_ops, hose,
-				&resources);
-	hose->bus = bus;
+	list_splice_init(&resources, &bridge->windows);
+	bridge->dev.parent = NULL;
+	bridge->sysdata = hose;
+	bridge->busnr = next_busno;
+	bridge->ops = hose->pci_ops;
+	bridge->swizzle_irq = pci_common_swizzle;
+	bridge->map_irq = pcibios_map_platform_irq;
+
+	ret = pci_scan_root_bus_bridge(bridge);
+	if (ret) {
+		pci_free_host_bridge(bridge);
+		return;
+	}
+
+	hose->bus = bridge->bus;
 
 	need_domain_info = need_domain_info || hose->index;
 	hose->need_domain_info = need_domain_info;
 
-	if (!bus) {
-		pci_free_resource_list(&resources);
-		return;
-	}
-
-	next_busno = bus->busn_res.end + 1;
+	next_busno = hose->bus->busn_res.end + 1;
 	/* Don't allow 8-bit bus number overflow inside the hose -
 	   reserve some space for bridges. */
 	if (next_busno > 224) {
@@ -72,9 +83,9 @@ static void pcibios_scanbus(struct pci_channel *hose)
 		need_domain_info = 1;
 	}
 
-	pci_bus_size_bridges(bus);
-	pci_bus_assign_resources(bus);
-	pci_bus_add_devices(bus);
+	pci_bus_size_bridges(hose->bus);
+	pci_bus_assign_resources(hose->bus);
+	pci_bus_add_devices(hose->bus);
 }
 
 /*
@@ -144,8 +155,6 @@ static int __init pcibios_init(void)
 	for (hose = hose_head; hose; hose = hose->next)
 		pcibios_scanbus(hose);
 
-	pci_fixup_irqs(pci_common_swizzle, pcibios_map_platform_irq);
-
 	dma_debug_add_bus(&pci_bus_type);
 
 	pci_initialized = 1;

commit bccf90d6e063d278b9ddc78dd266d0adef29886c
Author: Palmer Dabbelt <palmer@dabbelt.com>
Date:   Fri Jun 23 18:50:42 2017 -0700

    PCI: Add a generic weak pcibios_fixup_bus()
    
    Multiple architectures define this as an empty function, and I'm adding
    another one as part of the RISC-V port.  Add a __weak version of
    pcibios_fixup_bus() and delete the now-obselete ones in a handful of
    ports.
    
    The only functional change should be that microblaze used to export
    pcibios_fixup_bus().  None of the other architectures exports this, so I
    just dropped it.
    
    Signed-off-by: Palmer Dabbelt <palmer@dabbelt.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index c99ee286b69f..749642e1272e 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -154,14 +154,6 @@ static int __init pcibios_init(void)
 }
 subsys_initcall(pcibios_init);
 
-/*
- *  Called after each bus is probed, but before its children
- *  are examined.
- */
-void pcibios_fixup_bus(struct pci_bus *bus)
-{
-}
-
 /*
  * We need to avoid collisions with `mirrored' VGA ports
  * and other strange ISA hardware, so we always want the

commit adf7bde63f049ab0c3284a67898055bb11614c15
Author: David Woodhouse <dwmw@amazon.co.uk>
Date:   Wed Apr 12 13:26:05 2017 +0100

    sh/PCI: Use generic pci_mmap_resource_range()
    
    Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index c8b36b7ceb98..c99ee286b69f 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -269,28 +269,6 @@ void __ref pcibios_report_status(unsigned int status_mask, int warn)
 	}
 }
 
-int pci_mmap_page_range(struct pci_dev *dev, int bar,
-			struct vm_area_struct *vma,
-			enum pci_mmap_state mmap_state, int write_combine)
-{
-	/*
-	 * I/O space can be accessed via normal processor loads and stores on
-	 * this platform but for now we elect not to do this and portable
-	 * drivers should not do this anyway.
-	 */
-	if (mmap_state == pci_mmap_io)
-		return -EINVAL;
-
-	/*
-	 * Ignore write-combine; for now only return uncached mappings.
-	 */
-	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
-
-	return remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
-			       vma->vm_end - vma->vm_start,
-			       vma->vm_page_prot);
-}
-
 #ifndef CONFIG_GENERIC_IOMAP
 
 void __iomem *__pci_ioport_map(struct pci_dev *dev,

commit f66e225828c1b046c7db1db65b0dd2d135f6a2da
Author: David Woodhouse <dwmw@amazon.co.uk>
Date:   Wed Apr 12 13:25:58 2017 +0100

    PCI: Add BAR index argument to pci_mmap_page_range()
    
    In all cases we know which BAR it is.  Passing it in means that arch code
    (or generic code; watch this space) won't have to go looking for it again.
    
    Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 84563e39a5b8..c8b36b7ceb98 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -269,7 +269,8 @@ void __ref pcibios_report_status(unsigned int status_mask, int warn)
 	}
 }
 
-int pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,
+int pci_mmap_page_range(struct pci_dev *dev, int bar,
+			struct vm_area_struct *vma,
 			enum pci_mmap_state mmap_state, int write_combine)
 {
 	/*

commit bd721ea73e1f965569b40620538c942001f76294
Author: Fabian Frederick <fabf@skynet.be>
Date:   Tue Aug 2 14:03:33 2016 -0700

    treewide: replace obsolete _refok by __ref
    
    There was only one use of __initdata_refok and __exit_refok
    
    __init_refok was used 46 times against 82 for __ref.
    
    Those definitions are obsolete since commit 312b1485fb50 ("Introduce new
    section reference annotations tags: __ref, __refdata, __refconst")
    
    This patch removes the following compatibility definitions and replaces
    them treewide.
    
    /* compatibility defines */
    #define __init_refok     __ref
    #define __initdata_refok __refdata
    #define __exit_refok     __ref
    
    I can also provide separate patches if necessary.
    (One patch per tree and check in 1 month or 2 to remove old definitions)
    
    [akpm@linux-foundation.org: coding-style fixes]
    Link: http://lkml.kernel.org/r/1466796271-3043-1-git-send-email-fabf@skynet.be
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index d5462b7bc514..84563e39a5b8 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -221,7 +221,7 @@ pcibios_bus_report_status_early(struct pci_channel *hose,
  * We can't use pci_find_device() here since we are
  * called from interrupt context.
  */
-static void __init_refok
+static void __ref
 pcibios_bus_report_status(struct pci_bus *bus, unsigned int status_mask,
 			  int warn)
 {
@@ -256,7 +256,7 @@ pcibios_bus_report_status(struct pci_bus *bus, unsigned int status_mask,
 			pcibios_bus_report_status(dev->subordinate, status_mask, warn);
 }
 
-void __init_refok pcibios_report_status(unsigned int status_mask, int warn)
+void __ref pcibios_report_status(unsigned int status_mask, int warn)
 {
 	struct pci_channel *hose;
 

commit 9e808eb6a7689b61399f772a2576d779161769ec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Mar 12 15:07:04 2015 -0500

    PCI: Cleanup control flow
    
    Return errors immediately so the straightline path is the normal,
    no-error path.  No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index efc10519916a..d5462b7bc514 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -58,21 +58,23 @@ static void pcibios_scanbus(struct pci_channel *hose)
 
 	need_domain_info = need_domain_info || hose->index;
 	hose->need_domain_info = need_domain_info;
-	if (bus) {
-		next_busno = bus->busn_res.end + 1;
-		/* Don't allow 8-bit bus number overflow inside the hose -
-		   reserve some space for bridges. */
-		if (next_busno > 224) {
-			next_busno = 0;
-			need_domain_info = 1;
-		}
 
-		pci_bus_size_bridges(bus);
-		pci_bus_assign_resources(bus);
-		pci_bus_add_devices(bus);
-	} else {
+	if (!bus) {
 		pci_free_resource_list(&resources);
+		return;
+	}
+
+	next_busno = bus->busn_res.end + 1;
+	/* Don't allow 8-bit bus number overflow inside the hose -
+	   reserve some space for bridges. */
+	if (next_busno > 224) {
+		next_busno = 0;
+		need_domain_info = 1;
 	}
+
+	pci_bus_size_bridges(bus);
+	pci_bus_assign_resources(bus);
+	pci_bus_add_devices(bus);
 }
 
 /*

commit b97ea289cf6aff8d4cbcefe2b707bb9b00a73c73
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Mon Mar 16 11:18:56 2015 +0800

    PCI: Assign resources before drivers claim devices (pci_scan_root_bus())
    
    Previously, pci_scan_root_bus() created a root PCI bus, enumerated the
    devices on it, and called pci_bus_add_devices(), which made the devices
    available for drivers to claim them.
    
    Most callers assigned resources to devices after pci_scan_root_bus()
    returns, which may be after drivers have claimed the devices.  This is
    incorrect; the PCI core should not change device resources while a driver
    is managing the device.
    
    Remove pci_bus_add_devices() from pci_scan_root_bus() and do it after any
    resource assignment in the callers.
    
    Note that ARM's pci_common_init_dev() already called pci_bus_add_devices()
    after pci_scan_root_bus(), so we only need to remove the first call:
    
      pci_common_init_dev
        pcibios_init_hw
          pci_scan_root_bus
            pci_bus_add_devices        # first call
        pci_bus_assign_resources
        pci_bus_add_devices            # second call
    
    [bhelgaas: changelog, drop "root_bus" var in alpha common_init_pci(),
    return failure earlier in mn10300, add "return" in x86 pcibios_scan_root(),
    return early if xtensa platform_pcibios_fixup() fails]
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Richard Henderson <rth@twiddle.net>
    CC: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    CC: Matt Turner <mattst88@gmail.com>
    CC: David Howells <dhowells@redhat.com>
    CC: Tony Luck <tony.luck@intel.com>
    CC: Michal Simek <monstr@monstr.eu>
    CC: Ralf Baechle <ralf@linux-mips.org>
    CC: Koichi Yasutake <yasutake.koichi@jp.panasonic.com>
    CC: Sebastian Ott <sebott@linux.vnet.ibm.com>
    CC: "David S. Miller" <davem@davemloft.net>
    CC: Chris Metcalf <cmetcalf@ezchip.com>
    CC: Chris Zankel <chris@zankel.net>
    CC: Max Filippov <jcmvbkbc@gmail.com>
    CC: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 1bc09ee7948f..efc10519916a 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -69,6 +69,7 @@ static void pcibios_scanbus(struct pci_channel *hose)
 
 		pci_bus_size_bridges(bus);
 		pci_bus_assign_resources(bus);
+		pci_bus_add_devices(bus);
 	} else {
 		pci_free_resource_list(&resources);
 	}

commit 3a6fc2fb7eb2a4973e29c0fb0c8d0f61d5babeb0
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Feb 26 11:26:02 2014 -0700

    sh/PCI: Use default pcibios_enable_device()
    
    We don't need anything arch-specific in pcibios_enable_device(), so drop
    the arch implementation and use the default generic one.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Paul Mundt <lethal@linux-sh.org>
    CC: linux-sh@vger.kernel.org

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 60ed3e1c4b75..1bc09ee7948f 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -186,11 +186,6 @@ resource_size_t pcibios_align_resource(void *data, const struct resource *res,
 	return start;
 }
 
-int pcibios_enable_device(struct pci_dev *dev, int mask)
-{
-	return pci_enable_resources(dev, mask);
-}
-
 static void __init
 pcibios_bus_report_status_early(struct pci_channel *hose,
 				int top_bus, int current_bus,

commit 928bea964827d7824b548c1f8e06eccbbc4d0d7d
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Jul 22 14:37:17 2013 -0700

    PCI: Delay enabling bridges until they're needed
    
    We currently enable PCI bridges after scanning a bus and assigning
    resources.  This is often done in arch code.
    
    This patch changes this so we don't enable a bridge until necessary, i.e.,
    until we enable a PCI device behind the bridge.  We do this in the generic
    pci_enable_device() path, so this also removes the arch-specific code to
    enable bridges.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 102f5d58b037..60ed3e1c4b75 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -69,7 +69,6 @@ static void pcibios_scanbus(struct pci_channel *hose)
 
 		pci_bus_size_bridges(bus);
 		pci_bus_assign_resources(bus);
-		pci_enable_bridges(bus);
 	} else {
 		pci_free_resource_list(&resources);
 	}

commit b881bc469bdbdcca60e75047885509eb9886d3a2
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 14:06:37 2012 -0800

    ARCH: drivers remove __dev* attributes.
    
    This fixes up all of the smaller arches that had __dev* markings for
    their platform-specific drivers.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Haavard Skinnemoen <hskinnemoen@gmail.com>
    Cc: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Cc: Mike Frysinger <vapier@gentoo.org>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Jesper Nilsson <jesper.nilsson@axis.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Hirokazu Takata <takata@linux-m32r.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Koichi Yasutake <yasutake.koichi@jp.panasonic.com>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Chen Liqin <liqin.chen@sunplusct.com>
    Cc: Lennox Wu <lennox.wu@gmail.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Cc: Bob Liu <lliubbo@gmail.com>
    Cc: Srinivas Kandagatla <srinivas.kandagatla@st.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Myron Stowe <myron.stowe@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Thierry Reding <thierry.reding@avionic-design.de>
    Cc: Greg Ungerer <gerg@uclinux.org>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: "Srivatsa S. Bhat" <srivatsa.bhat@linux.vnet.ibm.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Yong Zhang <yong.zhang0@gmail.com>
    Cc: Michael Holzheu <holzheu@linux.vnet.ibm.com>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Jan Glauber <jang@linux.vnet.ibm.com>
    Cc: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Cc: Nobuhiro Iwamatsu <nobuhiro.iwamatsu.yj@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 81e5dafed3e4..102f5d58b037 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -32,7 +32,7 @@ static struct pci_channel *hose_head, **hose_tail = &hose_head;
 
 static int pci_initialized;
 
-static void __devinit pcibios_scanbus(struct pci_channel *hose)
+static void pcibios_scanbus(struct pci_channel *hose)
 {
 	static int next_busno;
 	static int need_domain_info;
@@ -82,7 +82,7 @@ static void __devinit pcibios_scanbus(struct pci_channel *hose)
 DEFINE_RAW_SPINLOCK(pci_config_lock);
 static DEFINE_MUTEX(pci_scan_mutex);
 
-int __devinit register_pci_controller(struct pci_channel *hose)
+int register_pci_controller(struct pci_channel *hose)
 {
 	int i;
 
@@ -156,7 +156,7 @@ subsys_initcall(pcibios_init);
  *  Called after each bus is probed, but before its children
  *  are examined.
  */
-void __devinit pcibios_fixup_bus(struct pci_bus *bus)
+void pcibios_fixup_bus(struct pci_bus *bus)
 {
 }
 

commit 48bee693abca6e4f0f4d1f393f44b4be128b0a39
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Nov 21 15:34:55 2012 -0500

    sh/PCI: Remove CONFIG_HOTPLUG ifdefs
    
    Remove conditional code based on CONFIG_HOTPLUG being false.  It's
    always on now in preparation of it going away as an option.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index a7e078f2e2e4..81e5dafed3e4 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -319,7 +319,5 @@ EXPORT_SYMBOL(pci_iounmap);
 
 #endif /* CONFIG_GENERIC_IOMAP */
 
-#ifdef CONFIG_HOTPLUG
 EXPORT_SYMBOL(PCIBIOS_MIN_IO);
 EXPORT_SYMBOL(PCIBIOS_MIN_MEM);
-#endif

commit 8885b7b637fa9aca7e1b00581a0173c6956966d3
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Mon Sep 17 13:22:54 2012 +0200

    PCI: Provide a default pcibios_update_irq()
    
    Most architectures implement this in exactly the same way. Instead of
    having each architecture duplicate this function, provide a single
    implementation in the core and make it a weak symbol so that it can be
    overridden on architectures where it is required.
    
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 1bd3e089b74f..a7e078f2e2e4 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -192,11 +192,6 @@ int pcibios_enable_device(struct pci_dev *dev, int mask)
 	return pci_enable_resources(dev, mask);
 }
 
-void pcibios_update_irq(struct pci_dev *dev, int irq)
-{
-	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
-}
-
 static void __init
 pcibios_bus_report_status_early(struct pci_channel *hose,
 				int top_bus, int current_bus,

commit 3ddbebf878ac8d958bb34e87a742a6b3adc283a3
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Mon Sep 17 13:22:53 2012 +0200

    PCI: Discard __init annotations for pci_fixup_irqs() and related functions
    
    Remove the __init annotations in order to keep pci_fixup_irqs() around
    after init (e.g. for hotplug). This requires the same change for the
    implementation of pcibios_update_irq() on all architectures. While at
    it, all __devinit annotations are removed as well, since they will be
    useless now that HOTPLUG is always on.
    
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 40db2d0aef3f..1bd3e089b74f 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -192,7 +192,7 @@ int pcibios_enable_device(struct pci_dev *dev, int mask)
 	return pci_enable_resources(dev, mask);
 }
 
-void __init pcibios_update_irq(struct pci_dev *dev, int irq)
+void pcibios_update_irq(struct pci_dev *dev, int irq)
 {
 	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
 }

commit 85a00dd391d2de1e177c5ad8db5672428934ac20
Merge: 35e7f73c32ad 29e8d7bff2f5
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Jul 5 15:31:05 2012 -0600

    Merge branch 'pci/myron-pcibios_setup' into next
    
    * pci/myron-pcibios_setup:
      xtensa/PCI: factor out pcibios_setup()
      x86/PCI: adjust section annotations for pcibios_setup()
      unicore32/PCI: adjust section annotations for pcibios_setup()
      tile/PCI: factor out pcibios_setup()
      sparc/PCI: factor out pcibios_setup()
      sh/PCI: adjust section annotations for pcibios_setup()
      sh/PCI: factor out pcibios_setup()
      powerpc/PCI: factor out pcibios_setup()
      parisc/PCI: factor out pcibios_setup()
      MIPS/PCI: adjust section annotations for pcibios_setup()
      MIPS/PCI: factor out pcibios_setup()
      microblaze/PCI: factor out pcibios_setup()
      ia64/PCI: factor out pcibios_setup()
      cris/PCI: factor out pcibios_setup()
      alpha/PCI: factor out pcibios_setup()
      PCI: pull pcibios_setup() up into core

commit 86927f9344ebfc1e4059eb774dbd975d50b7766b
Author: Myron Stowe <myron.stowe@redhat.com>
Date:   Mon Jun 25 21:31:58 2012 -0600

    sh/PCI: factor out pcibios_setup()
    
    The PCI core provides a generic pcibios_setup() routine.  Drop this
    architecture-specific version in favor of that.
    
    Tested-by: Nobuhiro Iwamatsu <nobuhiro.iwamatsu.yj@renesas.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 9d10a3cb8797..7d42288e1057 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -197,11 +197,6 @@ void __init pcibios_update_irq(struct pci_dev *dev, int irq)
 	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
 }
 
-char * __devinit __weak pcibios_setup(char *str)
-{
-	return str;
-}
-
 static void __init
 pcibios_bus_report_status_early(struct pci_channel *hose,
 				int top_bus, int current_bus,

commit b918c62e086b2130a7bae44110ca516ef10bfe5a
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 17 18:51:11 2012 -0700

    PCI: replace struct pci_bus secondary/subordinate with busn_res
    
    Replace the struct pci_bus secondary/subordinate members with the
    struct resource busn_res.  Later we'll build a resource tree of these
    bus numbers.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 9d10a3cb8797..43068dcb451c 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -59,7 +59,7 @@ static void __devinit pcibios_scanbus(struct pci_channel *hose)
 	need_domain_info = need_domain_info || hose->index;
 	hose->need_domain_info = need_domain_info;
 	if (bus) {
-		next_busno = bus->subordinate + 1;
+		next_busno = bus->busn_res.end + 1;
 		/* Don't allow 8-bit bus number overflow inside the hose -
 		   reserve some space for bridges. */
 		if (next_busno > 224) {

commit 475c77edf826333aa61625f49d6a2bec26ecb5a6
Merge: 934e18b5cb45 1488d5158dcd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 23 14:02:12 2012 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci
    
    Pull PCI changes (including maintainer change) from Jesse Barnes:
     "This pull has some good cleanups from Bjorn and Yinghai, as well as
      some more code from Yinghai to better handle resource re-allocation
      when enabled.
    
      There's also a new initcall_debug feature from Arjan which will print
      out quirk timing information to help identify slow quirks for fixing
      or refinement (Yinghai sent in a few patches to do just that once the
      new debug code landed).
    
      Beyond that, I'm handing off PCI maintainership to Bjorn Helgaas.
      He's been a core PCI and Linux contributor for some time now, and has
      kindly volunteered to take over.  I just don't feel I have the time
      for PCI review and work that it deserves lately (I've taken on some
      other projects), and haven't been as responsive lately as I'd like, so
      I approached Bjorn asking if he'd like to manage things.  He's going
      to give it a try, and I'm confident he'll do at least as well as I
      have in keeping the tree managed, patches flowing, and keeping things
      stable."
    
    Fix up some fairly trivial conflicts due to other cleanups (mips device
    resource fixup cleanups clashing with list handling cleanup, ppc iseries
    removal clashing with pci_probe_only cleanup etc)
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci: (112 commits)
      PCI: Bjorn gets PCI hotplug too
      PCI: hand PCI maintenance over to Bjorn Helgaas
      unicore32/PCI: move <asm-generic/pci-bridge.h> include to asm/pci.h
      sparc/PCI: convert devtree and arch-probed bus addresses to resource
      powerpc/PCI: allow reallocation on PA Semi
      powerpc/PCI: convert devtree bus addresses to resource
      powerpc/PCI: compute I/O space bus-to-resource offset consistently
      arm/PCI: don't export pci_flags
      PCI: fix bridge I/O window bus-to-resource conversion
      x86/PCI: add spinlock held check to 'pcibios_fwaddrmap_lookup()'
      PCI / PCIe: Introduce command line option to disable ARI
      PCI: make acpihp use __pci_remove_bus_device instead
      PCI: export __pci_remove_bus_device
      PCI: Rename pci_remove_behind_bridge to pci_stop_and_remove_behind_bridge
      PCI: Rename pci_remove_bus_device to pci_stop_and_remove_bus_device
      PCI: print out PCI device info along with duration
      PCI: Move "pci reassigndev resource alignment" out of quirks.c
      PCI: Use class for quirk for usb host controller fixup
      PCI: Use class for quirk for ti816x class fixup
      PCI: Use class for quirk for intel e100 interrupt fixup
      ...

commit 7fa6a50eb3625638d5c8fec6187d3da9d1733dca
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 23 20:19:03 2012 -0700

    sh/PCI: get rid of device resource fixups
    
    Tell the PCI core about host bridge address translation so it can take
    care of bus-to-resource conversion for us.
    
    CC: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 8f18dd090a66..e5aacef1d04b 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -37,11 +37,20 @@ static void __devinit pcibios_scanbus(struct pci_channel *hose)
 	static int next_busno;
 	static int need_domain_info;
 	LIST_HEAD(resources);
+	struct resource *res;
+	resource_size_t offset;
 	int i;
 	struct pci_bus *bus;
 
-	for (i = 0; i < hose->nr_resources; i++)
-		pci_add_resource(&resources, hose->resources + i);
+	for (i = 0; i < hose->nr_resources; i++) {
+		res = hose->resources + i;
+		offset = 0;
+		if (res->flags & IORESOURCE_IO)
+			offset = hose->io_offset;
+		else if (res->flags & IORESOURCE_MEM)
+			offset = hose->mem_offset;
+		pci_add_resource_offset(&resources, res, offset);
+	}
 
 	bus = pci_scan_root_bus(NULL, next_busno, hose->pci_ops, hose,
 				&resources);
@@ -143,42 +152,12 @@ static int __init pcibios_init(void)
 }
 subsys_initcall(pcibios_init);
 
-static void pcibios_fixup_device_resources(struct pci_dev *dev,
-	struct pci_bus *bus)
-{
-	/* Update device resources.  */
-	struct pci_channel *hose = bus->sysdata;
-	unsigned long offset = 0;
-	int i;
-
-	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
-		if (!dev->resource[i].start)
-			continue;
-		if (dev->resource[i].flags & IORESOURCE_IO)
-			offset = hose->io_offset;
-		else if (dev->resource[i].flags & IORESOURCE_MEM)
-			offset = hose->mem_offset;
-
-		dev->resource[i].start += offset;
-		dev->resource[i].end += offset;
-	}
-}
-
 /*
  *  Called after each bus is probed, but before its children
  *  are examined.
  */
 void __devinit pcibios_fixup_bus(struct pci_bus *bus)
 {
-	struct pci_dev *dev;
-	struct list_head *ln;
-
-	for (ln = bus->devices.next; ln != &bus->devices; ln = ln->next) {
-		dev = pci_dev_b(ln);
-
-		if ((dev->class >> 8) != PCI_CLASS_BRIDGE_PCI)
-			pcibios_fixup_device_resources(dev, bus);
-	}
 }
 
 /*
@@ -208,36 +187,6 @@ resource_size_t pcibios_align_resource(void *data, const struct resource *res,
 	return start;
 }
 
-void pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
-			     struct resource *res)
-{
-	struct pci_channel *hose = dev->sysdata;
-	unsigned long offset = 0;
-
-	if (res->flags & IORESOURCE_IO)
-		offset = hose->io_offset;
-	else if (res->flags & IORESOURCE_MEM)
-		offset = hose->mem_offset;
-
-	region->start = res->start - offset;
-	region->end = res->end - offset;
-}
-
-void pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,
-			     struct pci_bus_region *region)
-{
-	struct pci_channel *hose = dev->sysdata;
-	unsigned long offset = 0;
-
-	if (res->flags & IORESOURCE_IO)
-		offset = hose->io_offset;
-	else if (res->flags & IORESOURCE_MEM)
-		offset = hose->mem_offset;
-
-	res->start = region->start + offset;
-	res->end = region->end + offset;
-}
-
 int pcibios_enable_device(struct pci_dev *dev, int mask)
 {
 	return pci_enable_resources(dev, mask);
@@ -381,8 +330,6 @@ EXPORT_SYMBOL(pci_iounmap);
 #endif /* CONFIG_GENERIC_IOMAP */
 
 #ifdef CONFIG_HOTPLUG
-EXPORT_SYMBOL(pcibios_resource_to_bus);
-EXPORT_SYMBOL(pcibios_bus_to_resource);
 EXPORT_SYMBOL(PCIBIOS_MIN_IO);
 EXPORT_SYMBOL(PCIBIOS_MIN_MEM);
 #endif

commit 1e05b62ae4bd4c1209229de367b0989b39644f88
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Mon Jan 30 00:29:10 2012 +0200

    sh: use the the PCI channels's io_map_base
    
    commit 43db595e8b5d78ce5ad2feab719814a76e3ad2e5
    (sh: switch to GENERIC_PCI_IOMAP)
    failed to take into account the PCI channels's
    io_map_base for mapping IO BARs.
    This also caused a new warning on sh.
    
    Fix this, without re-introducing code duplication,
    by setting NO_GENERIC_PCI_IOPORT_MAP
    and supplying a sh-specific __pci_ioport_map.
    
    Reported-by: Kevin Cernekee <cernekee@gmail.com>
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 8f18dd090a66..1e7b0e2e764d 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -356,8 +356,8 @@ int pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,
 
 #ifndef CONFIG_GENERIC_IOMAP
 
-static void __iomem *ioport_map_pci(struct pci_dev *dev,
-				    unsigned long port, unsigned int nr)
+void __iomem *__pci_ioport_map(struct pci_dev *dev,
+			       unsigned long port, unsigned int nr)
 {
 	struct pci_channel *chan = dev->sysdata;
 

commit 7b67e751479d50b7f84d1a3cc5216eed5e534b66
Merge: 9f13a1fd452f 76ccc297018d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 11 18:50:26 2012 -0800

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci: (80 commits)
      x86/PCI: Expand the x86_msi_ops to have a restore MSIs.
      PCI: Increase resource array mask bit size in pcim_iomap_regions()
      PCI: DEVICE_COUNT_RESOURCE should be equal to PCI_NUM_RESOURCES
      PCI: pci_ids: add device ids for STA2X11 device (aka ConneXT)
      PNP: work around Dell 1536/1546 BIOS MMCONFIG bug that breaks USB
      x86/PCI: amd: factor out MMCONFIG discovery
      PCI: Enable ATS at the device state restore
      PCI: msi: fix imbalanced refcount of msi irq sysfs objects
      PCI: kconfig: English typo in pci/pcie/Kconfig
      PCI/PM/Runtime: make PCI traces quieter
      PCI: remove pci_create_bus()
      xtensa/PCI: convert to pci_scan_root_bus() for correct root bus resources
      x86/PCI: convert to pci_create_root_bus() and pci_scan_root_bus()
      x86/PCI: use pci_scan_bus() instead of pci_scan_bus_parented()
      x86/PCI: read Broadcom CNB20LE host bridge info before PCI scan
      sparc32, leon/PCI: convert to pci_scan_root_bus() for correct root bus resources
      sparc/PCI: convert to pci_create_root_bus()
      sh/PCI: convert to pci_scan_root_bus() for correct root bus resources
      powerpc/PCI: convert to pci_create_root_bus()
      powerpc/PCI: split PHB part out of pcibios_map_io_space()
      ...
    
    Fix up conflicts in drivers/pci/msi.c and include/linux/pci_regs.h due
    to the same patches being applied in other branches.

commit 6f17dd1ba96bb857fc1e8ab0357a6a0a09935baf
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 28 16:27:48 2011 -0600

    sh/PCI: convert to pci_scan_root_bus() for correct root bus resources
    
    Convert from pci_scan_bus() to pci_scan_root_bus() and remove root bus
    resource fixups.  This fixes the problem of "early" and "header" quirks
    seeing incorrect root bus resources.
    
    CC: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 05de3b2d82c5..5872c798d62d 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -36,9 +36,15 @@ static void __devinit pcibios_scanbus(struct pci_channel *hose)
 {
 	static int next_busno;
 	static int need_domain_info;
+	LIST_HEAD(resources);
+	int i;
 	struct pci_bus *bus;
 
-	bus = pci_scan_bus(next_busno, hose->pci_ops, hose);
+	for (i = 0; i < hose->nr_resources; i++)
+		pci_add_resource(&resources, hose->resources + i);
+
+	bus = pci_scan_root_bus(NULL, next_busno, hose->pci_ops, hose,
+				&resources);
 	hose->bus = bus;
 
 	need_domain_info = need_domain_info || hose->index;
@@ -55,6 +61,8 @@ static void __devinit pcibios_scanbus(struct pci_channel *hose)
 		pci_bus_size_bridges(bus);
 		pci_bus_assign_resources(bus);
 		pci_enable_bridges(bus);
+	} else {
+		pci_free_resource_list(&resources);
 	}
 }
 
@@ -162,16 +170,8 @@ static void pcibios_fixup_device_resources(struct pci_dev *dev,
  */
 void __devinit pcibios_fixup_bus(struct pci_bus *bus)
 {
-	struct pci_dev *dev = bus->self;
+	struct pci_dev *dev;
 	struct list_head *ln;
-	struct pci_channel *hose = bus->sysdata;
-
-	if (!dev) {
-		int i;
-
-		for (i = 0; i < hose->nr_resources; i++)
-			bus->resource[i] = hose->resources + i;
-	}
 
 	for (ln = bus->devices.next; ln != &bus->devices; ln = ln->next) {
 		dev = pci_dev_b(ln);

commit dab0311d65715d240989a136a41616853ad72347
Author: Myron Stowe <mstowe@redhat.com>
Date:   Fri Oct 28 15:49:06 2011 -0600

    PCI: sh: use generic pcibios_set_master()
    
    This patch removes sh's architecture-specific 'pcibios_set_master()'
    routine and lets the default PCI core based implementation handle PCI
    device 'latency timer' setup.
    
    No functional change.
    
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index cfdb2f652949..05de3b2d82c5 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -243,21 +243,6 @@ int pcibios_enable_device(struct pci_dev *dev, int mask)
 	return pci_enable_resources(dev, mask);
 }
 
-void pcibios_set_master(struct pci_dev *dev)
-{
-	u8 lat;
-	pci_read_config_byte(dev, PCI_LATENCY_TIMER, &lat);
-	if (lat < 16)
-		lat = (64 <= pcibios_max_latency) ? 64 : pcibios_max_latency;
-	else if (lat > pcibios_max_latency)
-		lat = pcibios_max_latency;
-	else
-		return;
-	printk(KERN_INFO "PCI: Setting latency timer of device %s to %d\n",
-	       pci_name(dev), lat);
-	pci_write_config_byte(dev, PCI_LATENCY_TIMER, lat);
-}
-
 void __init pcibios_update_irq(struct pci_dev *dev, int irq)
 {
 	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);

commit 96c5590058d7fded14f43af2ab521436cecf3125
Author: Myron Stowe <mstowe@redhat.com>
Date:   Fri Oct 28 15:48:38 2011 -0600

    PCI: Pull PCI 'latency timer' setup up into the core
    
    The 'latency timer' of PCI devices, both Type 0 and Type 1,
    is setup in architecture-specific code [see: 'pcibios_set_master()'].
    There are two approaches being taken by all the architectures - check
    if the 'latency timer' is currently set between 16 and 255 and if not
    bring it within bounds, or, do nothing (and then there is the
    gratuitously different PA-RISC implementation).
    
    There is nothing architecture-specific about PCI's 'latency timer' so
    this patch pulls its setup functionality up into the PCI core by
    creating a generic 'pcibios_set_master()' function using the '__weak'
    attribute which can be used by all architectures as a default which,
    if necessary, can then be over-ridden by architecture-specific code.
    
    No functional change.
    
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index c2691afe8f79..cfdb2f652949 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -243,12 +243,6 @@ int pcibios_enable_device(struct pci_dev *dev, int mask)
 	return pci_enable_resources(dev, mask);
 }
 
-/*
- *  If we set up a device for bus mastering, we need to check and set
- *  the latency timer as it may not be properly set.
- */
-static unsigned int pcibios_max_latency = 255;
-
 void pcibios_set_master(struct pci_dev *dev)
 {
 	u8 lat;

commit 43db595e8b5d78ce5ad2feab719814a76e3ad2e5
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Thu Nov 24 21:10:12 2011 +0200

    sh: switch to GENERIC_PCI_IOMAP
    
    sh copied pci_iomap from generic code, probably to avoid
    pulling the rest of iomap.c in.  Since that's in
    a separate file now, we can reuse the common implementation.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index c2691afe8f79..11aaf2fdec84 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -393,29 +393,6 @@ static void __iomem *ioport_map_pci(struct pci_dev *dev,
 	return (void __iomem *)(chan->io_map_base + port);
 }
 
-void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen)
-{
-	resource_size_t start = pci_resource_start(dev, bar);
-	resource_size_t len = pci_resource_len(dev, bar);
-	unsigned long flags = pci_resource_flags(dev, bar);
-
-	if (unlikely(!len || !start))
-		return NULL;
-	if (maxlen && len > maxlen)
-		len = maxlen;
-
-	if (flags & IORESOURCE_IO)
-		return ioport_map_pci(dev, start, len);
-	if (flags & IORESOURCE_MEM) {
-		if (flags & IORESOURCE_CACHEABLE)
-			return ioremap(start, len);
-		return ioremap_nocache(start, len);
-	}
-
-	return NULL;
-}
-EXPORT_SYMBOL(pci_iomap);
-
 void pci_iounmap(struct pci_dev *dev, void __iomem *addr)
 {
 	iounmap(addr);

commit f7be345515ab6d5c3a0973bb2b32510fcb7c0481
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 31 19:20:02 2011 -0400

    sh: Add export.h to arch/sh specific files as required.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 194231cb5a70..c2691afe8f79 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -20,6 +20,7 @@
 #include <linux/io.h>
 #include <linux/mutex.h>
 #include <linux/spinlock.h>
+#include <linux/export.h>
 
 unsigned long PCIBIOS_MIN_IO = 0x0000;
 unsigned long PCIBIOS_MIN_MEM = 0;

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index a09c77dd09db..194231cb5a70 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -84,7 +84,7 @@ int __devinit register_pci_controller(struct pci_channel *hose)
 	hose_tail = &hose->next;
 
 	/*
-	 * Do not panic here but later - this might hapen before console init.
+	 * Do not panic here but later - this might happen before console init.
 	 */
 	if (!hose->io_map_base) {
 		printk(KERN_WARNING

commit 37b7a97884ba64bf7d403351ac2a9476ab4f1bba
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Nov 1 09:49:04 2010 -0400

    sh: machvec IO death.
    
    This takes a bit of a sledgehammer to the machvec I/O routines. The
    iomem case requires no special casing and so can just be dropped
    outright. This only leaves the ioport casing for PCI and SuperIO
    mangling. With the SuperIO case going through the standard ioport
    mapping, it's possible to replace everything with generic routines.
    
    With this done the standard I/O routines are tidied up and NO_IOPORT
    now gets default-enabled for the vast majority of boards.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 60ee09a4e121..a09c77dd09db 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -382,14 +382,13 @@ static void __iomem *ioport_map_pci(struct pci_dev *dev,
 	struct pci_channel *chan = dev->sysdata;
 
 	if (unlikely(!chan->io_map_base)) {
-		chan->io_map_base = generic_io_base;
+		chan->io_map_base = sh_io_port_base;
 
 		if (pci_domains_supported)
 			panic("To avoid data corruption io_map_base MUST be "
 			      "set with multiple PCI domains.");
 	}
 
-
 	return (void __iomem *)(chan->io_map_base + port);
 }
 

commit 61a46766c9d5d8fb5dad23da1b7cc4cb8b0107da
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Oct 14 07:37:01 2010 +0900

    sh: pci: Support slot 4 routing on SDK7786.
    
    SDK7786 supports connecting either slot3 or 4 to the same PCIe port by
    way of FPGA muxing. By default the vertical slot 3 on the baseboard is
    enabled, so this adds in a command line option for forcibly enabling the
    slot 4 edge connector.
    
    If nothing has been specified on the command line, we fall back to
    reading the resistor values for card presence to figure out where to
    route the port to.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index af4191bbb179..60ee09a4e121 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -268,7 +268,7 @@ void __init pcibios_update_irq(struct pci_dev *dev, int irq)
 	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
 }
 
-char * __devinit pcibios_setup(char *str)
+char * __devinit __weak pcibios_setup(char *str)
 {
 	return str;
 }

commit 39a90865f07f05343c450e91a56578bb8f69c5e8
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Sep 20 18:56:13 2010 +0900

    sh: pci: Use a generic raw spinlock for PCI config access locking.
    
    This copies the pci_config_lock idea from x86 over, allowing us to kill
    off a couple of existing private locks. At the same time, these need to
    be converted to raw spinlocks for -rt kernels, so we make that change at
    the same time. This should make it easier for future parts to get the
    locking right instead of inevitable ending up with lock type mismatches.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index e4c988d46ad5..af4191bbb179 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -19,6 +19,7 @@
 #include <linux/dma-debug.h>
 #include <linux/io.h>
 #include <linux/mutex.h>
+#include <linux/spinlock.h>
 
 unsigned long PCIBIOS_MIN_IO = 0x0000;
 unsigned long PCIBIOS_MIN_MEM = 0;
@@ -56,6 +57,11 @@ static void __devinit pcibios_scanbus(struct pci_channel *hose)
 	}
 }
 
+/*
+ * This interrupt-safe spinlock protects all accesses to PCI
+ * configuration space.
+ */
+DEFINE_RAW_SPINLOCK(pci_config_lock);
 static DEFINE_MUTEX(pci_scan_mutex);
 
 int __devinit register_pci_controller(struct pci_channel *hose)

commit c62e3fae58198fc1f5d7922f84fe91b3fcf61177
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sun Sep 19 13:51:15 2010 +0900

    sh: pci: Use generic pci_enable_resources() for pcibios_enable_device().
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 1e9598d2bbf4..e4c988d46ad5 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -233,40 +233,7 @@ void pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,
 
 int pcibios_enable_device(struct pci_dev *dev, int mask)
 {
-	u16 cmd, old_cmd;
-	int idx;
-	struct resource *r;
-
-	pci_read_config_word(dev, PCI_COMMAND, &cmd);
-	old_cmd = cmd;
-	for (idx=0; idx < PCI_NUM_RESOURCES; idx++) {
-		/* Only set up the requested stuff */
-		if (!(mask & (1<<idx)))
-			continue;
-
-		r = &dev->resource[idx];
-		if (!(r->flags & (IORESOURCE_IO | IORESOURCE_MEM)))
-			continue;
-		if ((idx == PCI_ROM_RESOURCE) &&
-				(!(r->flags & IORESOURCE_ROM_ENABLE)))
-			continue;
-		if (!r->start && r->end) {
-			printk(KERN_ERR "PCI: Device %s not available "
-			       "because of resource collisions\n",
-			       pci_name(dev));
-			return -EINVAL;
-		}
-		if (r->flags & IORESOURCE_IO)
-			cmd |= PCI_COMMAND_IO;
-		if (r->flags & IORESOURCE_MEM)
-			cmd |= PCI_COMMAND_MEMORY;
-	}
-	if (cmd != old_cmd) {
-		printk("PCI: Enabling device %s (%04x -> %04x)\n",
-		       pci_name(dev), old_cmd, cmd);
-		pci_write_config_word(dev, PCI_COMMAND, cmd);
-	}
-	return 0;
+	return pci_enable_resources(dev, mask);
 }
 
 /*

commit 9973e38575070b70c68bad177fb5056548fea349
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Jun 7 11:42:01 2010 +0900

    sh: Fix up IORESOURCE_PCI_FIXED usage in pcibios_fixup_device_resources().
    
    pcibios_fixup_device_resources() presently skips over resources flagged
    with IORESOURCE_PCI_FIXED, which is a remnant of the old PCI-auto code.
    The only user for this at present is the Dreamast GAPSPCI code which
    can't tolerate any adjustments to the BARs, but a combination of the
    IORESOURCE_PCI_FIXED and zeroed out hose offsets does the right thing for
    this case already, so we simply kill off the special casing.
    
    Reported-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 953af139e230..1e9598d2bbf4 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -139,8 +139,6 @@ static void pcibios_fixup_device_resources(struct pci_dev *dev,
 	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
 		if (!dev->resource[i].start)
 			continue;
-		if (dev->resource[i].flags & IORESOURCE_PCI_FIXED)
-			continue;
 		if (dev->resource[i].flags & IORESOURCE_IO)
 			offset = hose->io_offset;
 		else if (dev->resource[i].flags & IORESOURCE_MEM)

commit 64d497f55379b1e320a08ec2426468d96f5642ec
Merge: 37d400848497 b5f5fe80fa98
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Feb 26 16:54:27 2010 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/lethal/sh-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/lethal/sh-2.6: (187 commits)
      sh: remove dead LED code for migo-r and ms7724se
      sh: ecovec build fix for CONFIG_I2C=n
      sh: ecovec r-standby support
      sh: ms7724se r-standby support
      sh: SH-Mobile R-standby register save/restore
      clocksource: Fix up a registration/IRQ race in the sh drivers.
      sh: ms7724: modify scan_timing for KEYSC
      sh: ms7724: Add sh_sir support
      sh: mach-ecovec24: Add sh_sir support
      sh: wire up SET/GET_UNALIGN_CTL.
      sh: allow alignment fault mode to be configured at kernel boot.
      sh: sh7724: Update FSI/SPU2 clock
      sh: always enable sh7724 vpu_clk and set to 166MHz on Ecovec
      sh: add sh7724 kick callback to clk_div4_table
      sh: introduce struct clk_div4_table
      sh: clock-cpg div4 set_rate() shift fix
      sh: Turn on speculative return for SH7785 and SH7786
      sh: Merge legacy and dynamic PMB modes.
      sh: Use uncached I/O helpers in PMB setup.
      sh: Provide uncached I/O helpers.
      ...

commit 3b7a17fcdae532d29dffab9d564a28be08960988
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Fri Jan 1 17:40:50 2010 +0100

    resource/PCI: mark struct resource as const
    
    Now that we return the new resource start position, there is no
    need to update "struct resource" inside the align function.
    Therefore, mark the struct resource as const.
    
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index b36ca825b3d3..96213fd172ce 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -148,7 +148,7 @@ void __devinit pcibios_fixup_bus(struct pci_bus *bus)
  * addresses to be allocated in the 0x000-0x0ff region
  * modulo 0x400.
  */
-resource_size_t pcibios_align_resource(void *data, struct resource *res,
+resource_size_t pcibios_align_resource(void *data, const struct resource *res,
 				resource_size_t size, resource_size_t align)
 {
 	struct pci_dev *dev = data;

commit b26b2d494b659f988b4d75eb394dfa0ddac415c9
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Fri Jan 1 17:40:49 2010 +0100

    resource/PCI: align functions now return start of resource
    
    As suggested by Linus, align functions should return the start
    of a resource, not void. An update of "res->start" is no longer
    necessary.
    
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index c481df639022..b36ca825b3d3 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -148,8 +148,8 @@ void __devinit pcibios_fixup_bus(struct pci_bus *bus)
  * addresses to be allocated in the 0x000-0x0ff region
  * modulo 0x400.
  */
-void pcibios_align_resource(void *data, struct resource *res,
-			    resource_size_t size, resource_size_t align)
+resource_size_t pcibios_align_resource(void *data, struct resource *res,
+				resource_size_t size, resource_size_t align)
 {
 	struct pci_dev *dev = data;
 	struct pci_channel *chan = dev->sysdata;
@@ -171,7 +171,7 @@ void pcibios_align_resource(void *data, struct resource *res,
 			start = PCIBIOS_MIN_MEM + chan->mem_resource->start;
 	}
 
-	res->start = start;
+	return start;
 }
 
 void pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,

commit 9ad62ec4f752c82b39aa5927f23d894b46ae10b9
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Feb 3 16:46:20 2010 +0900

    sh: Fix up early PCI PERR/SERR IRQ handling.
    
    This adds support for handling early PERR/SERR triggering in between
    controller registration and the initial bus scan. Buggy cards end up
    asserting these as soon as the M66EN scan is undertaken, resulting in
    an early crash.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index f4a69833fce2..41d8f014f1df 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -204,7 +204,7 @@ void pcibios_align_resource(void *data, struct resource *res,
 }
 
 void pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
-			 struct resource *res)
+			     struct resource *res)
 {
 	struct pci_channel *hose = dev->sysdata;
 	unsigned long offset = 0;
@@ -218,9 +218,8 @@ void pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
 	region->end = res->end - offset;
 }
 
-void __devinit
-pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,
-			struct pci_bus_region *region)
+void pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,
+			     struct pci_bus_region *region)
 {
 	struct pci_channel *hose = dev->sysdata;
 	unsigned long offset = 0;
@@ -303,12 +302,41 @@ char * __devinit pcibios_setup(char *str)
 	return str;
 }
 
+static void __init
+pcibios_bus_report_status_early(struct pci_channel *hose,
+				int top_bus, int current_bus,
+				unsigned int status_mask, int warn)
+{
+	unsigned int pci_devfn;
+	u16 status;
+	int ret;
+
+	for (pci_devfn = 0; pci_devfn < 0xff; pci_devfn++) {
+		if (PCI_FUNC(pci_devfn))
+			continue;
+		ret = early_read_config_word(hose, top_bus, current_bus,
+					     pci_devfn, PCI_STATUS, &status);
+		if (ret != PCIBIOS_SUCCESSFUL)
+			continue;
+		if (status == 0xffff)
+			continue;
+
+		early_write_config_word(hose, top_bus, current_bus,
+					pci_devfn, PCI_STATUS,
+					status & status_mask);
+		if (warn)
+			printk("(%02x:%02x: %04X) ", current_bus,
+			       pci_devfn, status);
+	}
+}
+
 /*
  * We can't use pci_find_device() here since we are
  * called from interrupt context.
  */
-static void pcibios_bus_report_status(struct pci_bus *bus,
-		unsigned int status_mask, int warn)
+static void __init_refok
+pcibios_bus_report_status(struct pci_bus *bus, unsigned int status_mask,
+			  int warn)
 {
 	struct pci_dev *dev;
 
@@ -341,12 +369,17 @@ static void pcibios_bus_report_status(struct pci_bus *bus,
 			pcibios_bus_report_status(dev->subordinate, status_mask, warn);
 }
 
-void pcibios_report_status(unsigned int status_mask, int warn)
+void __init_refok pcibios_report_status(unsigned int status_mask, int warn)
 {
 	struct pci_channel *hose;
 
-	for (hose = hose_head; hose; hose = hose->next)
-		pcibios_bus_report_status(hose->bus, status_mask, warn);
+	for (hose = hose_head; hose; hose = hose->next) {
+		if (unlikely(!hose->bus))
+			pcibios_bus_report_status_early(hose, hose_head->index,
+					hose->index, status_mask, warn);
+		else
+			pcibios_bus_report_status(hose->bus, status_mask, warn);
+	}
 }
 
 int pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,

commit b6c58b1d987a5795086c5c2babd8c7367d2fdb8c
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Feb 1 20:01:50 2010 +0900

    sh: Improved multi-resource handling for SH7780 PCI.
    
    The SH7780 PCI controller supports 3 different ranges of PCI memory in
    addition to its PCI I/O window. In the case of 29-bit mode, only 2 memory
    windows are supported, while in 32-bit mode all 3 are visible. This
    attempts to make the resource handling completely dynamic and to permit
    platforms to map in as many apertures as they can handle.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 8e42dfbbe76a..f4a69833fce2 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -60,11 +60,18 @@ static DEFINE_MUTEX(pci_scan_mutex);
 
 int __devinit register_pci_controller(struct pci_channel *hose)
 {
-	if (request_resource(&iomem_resource, hose->mem_resource) < 0)
-		goto out;
-	if (request_resource(&ioport_resource, hose->io_resource) < 0) {
-		release_resource(hose->mem_resource);
-		goto out;
+	int i;
+
+	for (i = 0; i < hose->nr_resources; i++) {
+		struct resource *res = hose->resources + i;
+
+		if (res->flags & IORESOURCE_IO) {
+			if (request_resource(&ioport_resource, res) < 0)
+				goto out;
+		} else {
+			if (request_resource(&iomem_resource, res) < 0)
+				goto out;
+		}
 	}
 
 	*hose_tail = hose;
@@ -96,6 +103,9 @@ int __devinit register_pci_controller(struct pci_channel *hose)
 	return 0;
 
 out:
+	for (--i; i >= 0; i--)
+		release_resource(&hose->resources[i]);
+
 	printk(KERN_WARNING "Skipping PCI bus scan due to resource conflict\n");
 	return -1;
 }
@@ -149,11 +159,13 @@ void __devinit pcibios_fixup_bus(struct pci_bus *bus)
 {
 	struct pci_dev *dev = bus->self;
 	struct list_head *ln;
-	struct pci_channel *chan = bus->sysdata;
+	struct pci_channel *hose = bus->sysdata;
 
 	if (!dev) {
-		bus->resource[0] = chan->io_resource;
-		bus->resource[1] = chan->mem_resource;
+		int i;
+
+		for (i = 0; i < hose->nr_resources; i++)
+			bus->resource[i] = hose->resources + i;
 	}
 
 	for (ln = bus->devices.next; ln != &bus->devices; ln = ln->next) {
@@ -174,21 +186,18 @@ void pcibios_align_resource(void *data, struct resource *res,
 			    resource_size_t size, resource_size_t align)
 {
 	struct pci_dev *dev = data;
-	struct pci_channel *chan = dev->sysdata;
+	struct pci_channel *hose = dev->sysdata;
 	resource_size_t start = res->start;
 
 	if (res->flags & IORESOURCE_IO) {
-		if (start < PCIBIOS_MIN_IO + chan->io_resource->start)
-			start = PCIBIOS_MIN_IO + chan->io_resource->start;
+		if (start < PCIBIOS_MIN_IO + hose->resources[0].start)
+			start = PCIBIOS_MIN_IO + hose->resources[0].start;
 
 		/*
                  * Put everything into 0x00-0xff region modulo 0x400.
 		 */
 		if (start & 0x300)
 			start = (start + 0x3ff) & ~0x3ff;
-	} else if (res->flags & IORESOURCE_MEM) {
-		if (start < PCIBIOS_MIN_MEM + chan->mem_resource->start)
-			start = PCIBIOS_MIN_MEM + chan->mem_resource->start;
 	}
 
 	res->start = start;

commit ef407beefbd9928792ccc93857e408e0057bc17b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Feb 1 16:39:46 2010 +0900

    sh: Hook up ERR/PERR/SERR detection for SH7780 PCI host controllers.
    
    These were never handled before, so implement some common infrastructure
    to support them, then make use of that in the SH7780-specific code. In
    practice there is little here that can not be generalized for SH4 parts,
    which will be an incremental change as the 7780/7751 code is gradually
    unified.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 488331c45033..8e42dfbbe76a 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -78,6 +78,11 @@ int __devinit register_pci_controller(struct pci_channel *hose)
 		       "registering PCI controller with io_map_base unset\n");
 	}
 
+	/*
+	 * Setup the ERR/PERR and SERR timers, if available.
+	 */
+	pcibios_enable_timers(hose);
+
 	/*
 	 * Scan the bus if it is register after the PCI subsystem
 	 * initialization.
@@ -289,6 +294,52 @@ char * __devinit pcibios_setup(char *str)
 	return str;
 }
 
+/*
+ * We can't use pci_find_device() here since we are
+ * called from interrupt context.
+ */
+static void pcibios_bus_report_status(struct pci_bus *bus,
+		unsigned int status_mask, int warn)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		u16 status;
+
+		/*
+		 * ignore host bridge - we handle
+		 * that separately
+		 */
+		if (dev->bus->number == 0 && dev->devfn == 0)
+			continue;
+
+		pci_read_config_word(dev, PCI_STATUS, &status);
+		if (status == 0xffff)
+			continue;
+
+		if ((status & status_mask) == 0)
+			continue;
+
+		/* clear the status errors */
+		pci_write_config_word(dev, PCI_STATUS, status & status_mask);
+
+		if (warn)
+			printk("(%s: %04X) ", pci_name(dev), status);
+	}
+
+	list_for_each_entry(dev, &bus->devices, bus_list)
+		if (dev->subordinate)
+			pcibios_bus_report_status(dev->subordinate, status_mask, warn);
+}
+
+void pcibios_report_status(unsigned int status_mask, int warn)
+{
+	struct pci_channel *hose;
+
+	for (hose = hose_head; hose; hose = hose->next)
+		pcibios_bus_report_status(hose->bus, status_mask, warn);
+}
+
 int pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,
 			enum pci_mmap_state mmap_state, int write_combine)
 {

commit bcf39352eb9e9026f7a1028d4bce3707b65f104b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Feb 1 13:11:25 2010 +0900

    sh: Handle PCI controller resource conflicts.
    
    register_pci_controller() can fail, but presently is a void function.
    Change this over to an int so that we can bail early before continuing on
    with post-registration initialization (such as throwing the controller in
    to 66MHz mode in the case of the SH7780 host controller).
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 63b11fddffec..488331c45033 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -58,7 +58,7 @@ static void __devinit pcibios_scanbus(struct pci_channel *hose)
 
 static DEFINE_MUTEX(pci_scan_mutex);
 
-void __devinit register_pci_controller(struct pci_channel *hose)
+int __devinit register_pci_controller(struct pci_channel *hose)
 {
 	if (request_resource(&iomem_resource, hose->mem_resource) < 0)
 		goto out;
@@ -88,10 +88,11 @@ void __devinit register_pci_controller(struct pci_channel *hose)
 		mutex_unlock(&pci_scan_mutex);
 	}
 
-	return;
+	return 0;
 
 out:
 	printk(KERN_WARNING "Skipping PCI bus scan due to resource conflict\n");
+	return -1;
 }
 
 static int __init pcibios_init(void)

commit 85b59f5bb24aeca1a987cbb206e228bf630c8327
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Feb 1 13:01:42 2010 +0900

    sh: Enable PCI66 support for SH7780 host controller.
    
    This adds some helper glue for scanning the bus and determining if all
    of the devices are 66MHz capable or not before flipping on 66MHz mode.
    This isn't quite to spec, but it's fairly consistent with what other
    embedded controllers end up having to do.
    
    Scanning code cribbed from the MIPS txx9 PCI code.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 45a15cab01df..63b11fddffec 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -88,6 +88,8 @@ void __devinit register_pci_controller(struct pci_channel *hose)
 		mutex_unlock(&pci_scan_mutex);
 	}
 
+	return;
+
 out:
 	printk(KERN_WARNING "Skipping PCI bus scan due to resource conflict\n");
 }

commit 320e68da59353fe6ad51b81f6865c4b674ad66ea
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Jan 29 22:38:13 2010 +0900

    sh: support PCI domains.
    
    Newer SH parts are now commonly shipping with multiple controllers, so
    we wire up PCI domain support to deal with them. Shamelessly cloned from
    the MIPS implementation.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 82e59bc6210e..45a15cab01df 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -33,15 +33,22 @@ static int pci_initialized;
 static void __devinit pcibios_scanbus(struct pci_channel *hose)
 {
 	static int next_busno;
+	static int need_domain_info;
 	struct pci_bus *bus;
 
 	bus = pci_scan_bus(next_busno, hose->pci_ops, hose);
+	hose->bus = bus;
+
+	need_domain_info = need_domain_info || hose->index;
+	hose->need_domain_info = need_domain_info;
 	if (bus) {
 		next_busno = bus->subordinate + 1;
 		/* Don't allow 8-bit bus number overflow inside the hose -
 		   reserve some space for bridges. */
-		if (next_busno > 224)
+		if (next_busno > 224) {
 			next_busno = 0;
+			need_domain_info = 1;
+		}
 
 		pci_bus_size_bridges(bus);
 		pci_bus_assign_resources(bus);
@@ -307,9 +314,15 @@ static void __iomem *ioport_map_pci(struct pci_dev *dev,
 {
 	struct pci_channel *chan = dev->sysdata;
 
-	if (!chan->io_map_base)
+	if (unlikely(!chan->io_map_base)) {
 		chan->io_map_base = generic_io_base;
 
+		if (pci_domains_supported)
+			panic("To avoid data corruption io_map_base MUST be "
+			      "set with multiple PCI domains.");
+	}
+
+
 	return (void __iomem *)(chan->io_map_base + port);
 }
 

commit ac8ab54a8e41a5ed0ee2161d45b6dc855490989f
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Jan 29 22:22:27 2010 +0900

    sh: Bail out early on PCI resource conflicts.
    
    Presently we just call in to request_resource() for the ioport and iomem
    resources without checking for errors. This has already hidden a couple
    of bugs, so add some error handling in for good measure.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 191075e91cda..82e59bc6210e 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -53,8 +53,12 @@ static DEFINE_MUTEX(pci_scan_mutex);
 
 void __devinit register_pci_controller(struct pci_channel *hose)
 {
-	request_resource(&iomem_resource, hose->mem_resource);
-	request_resource(&ioport_resource, hose->io_resource);
+	if (request_resource(&iomem_resource, hose->mem_resource) < 0)
+		goto out;
+	if (request_resource(&ioport_resource, hose->io_resource) < 0) {
+		release_resource(hose->mem_resource);
+		goto out;
+	}
 
 	*hose_tail = hose;
 	hose_tail = &hose->next;
@@ -76,6 +80,9 @@ void __devinit register_pci_controller(struct pci_channel *hose)
 		pcibios_scanbus(hose);
 		mutex_unlock(&pci_scan_mutex);
 	}
+
+out:
+	printk(KERN_WARNING "Skipping PCI bus scan due to resource conflict\n");
 }
 
 static int __init pcibios_init(void)
@@ -319,20 +326,9 @@ void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen)
 
 	if (flags & IORESOURCE_IO)
 		return ioport_map_pci(dev, start, len);
-
-	/*
-	 * Presently the IORESOURCE_MEM case is a bit special, most
-	 * SH7751 style PCI controllers have PCI memory at a fixed
-	 * location in the address space where no remapping is desired.
-	 * With the IORESOURCE_MEM case more care has to be taken
-	 * to inhibit page table mapping for legacy cores, but this is
-	 * punted off to __ioremap().
-	 *					-- PFM.
-	 */
 	if (flags & IORESOURCE_MEM) {
 		if (flags & IORESOURCE_CACHEABLE)
 			return ioremap(start, len);
-
 		return ioremap_nocache(start, len);
 	}
 

commit 849593591ce3b5f9352966c9d410284dc04d03b6
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Jan 28 18:15:05 2010 +0900

    sh: Fix up read-only variable assignment in pcibios_align_resource().
    
    arch/sh/drivers/pci/pci.c:167: error: assignment of read-only location '*res'
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index c481df639022..191075e91cda 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -162,10 +162,8 @@ void pcibios_align_resource(void *data, struct resource *res,
 		/*
                  * Put everything into 0x00-0xff region modulo 0x400.
 		 */
-		if (start & 0x300) {
+		if (start & 0x300)
 			start = (start + 0x3ff) & ~0x3ff;
-			res->start = start;
-		}
 	} else if (res->flags & IORESOURCE_MEM) {
 		if (start < PCIBIOS_MIN_MEM + chan->mem_resource->start)
 			start = PCIBIOS_MIN_MEM + chan->mem_resource->start;

commit 15444a8973dcfbd286b3e638cbadac2446a9271a
Author: David McKay <david.mckay@st.com>
Date:   Mon Aug 24 16:10:40 2009 +0900

    sh: Allow use of GENERIC_IOMAP
    
    The synopsys PCI cell used in the later STMicro chips requires code to
    be run in order to do IO cycles, rather than just memory mapping the IO
    space. Rather than extending the existing SH infrastructure to allow
    this, use the GENERIC_IOMAP implmentation to save re-inventing the
    wheel.
    
    This set of changes allows the SH to be built with GENERIC_IOMAP
    enabled, it just ifdef's out the functions provided by the GENERIC_IOMAP
    implementation, and provides a few required missing functions.
    
    Signed-off-by: David McKay <david.mckay@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 9a1c423ad167..c481df639022 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -295,6 +295,8 @@ int pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,
 			       vma->vm_page_prot);
 }
 
+#ifndef CONFIG_GENERIC_IOMAP
+
 static void __iomem *ioport_map_pci(struct pci_dev *dev,
 				    unsigned long port, unsigned int nr)
 {
@@ -346,6 +348,8 @@ void pci_iounmap(struct pci_dev *dev, void __iomem *addr)
 }
 EXPORT_SYMBOL(pci_iounmap);
 
+#endif /* CONFIG_GENERIC_IOMAP */
+
 #ifdef CONFIG_HOTPLUG
 EXPORT_SYMBOL(pcibios_resource_to_bus);
 EXPORT_SYMBOL(pcibios_bus_to_resource);

commit 8c6b44d00aca45edf69b35220ba4dce962c482f8
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jun 16 06:01:58 2009 +0900

    sh: pci: Allow register_pci_controller() to handle overlapping regions.
    
    Some host controllers (such as SH7786) have overlapping regions that are
    fixed in hardware. The resource allocator does the right thing in
    managing this space already, so the conflict case is non-fatal.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 54d77cbb8b39..9a1c423ad167 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -53,12 +53,8 @@ static DEFINE_MUTEX(pci_scan_mutex);
 
 void __devinit register_pci_controller(struct pci_channel *hose)
 {
-	if (request_resource(&iomem_resource, hose->mem_resource) < 0)
-		goto out;
-	if (request_resource(&ioport_resource, hose->io_resource) < 0) {
-		release_resource(hose->mem_resource);
-		goto out;
-	}
+	request_resource(&iomem_resource, hose->mem_resource);
+	request_resource(&ioport_resource, hose->io_resource);
 
 	*hose_tail = hose;
 	hose_tail = &hose->next;
@@ -80,12 +76,6 @@ void __devinit register_pci_controller(struct pci_channel *hose)
 		pcibios_scanbus(hose);
 		mutex_unlock(&pci_scan_mutex);
 	}
-
-	return;
-
-out:
-	printk(KERN_WARNING
-	       "Skipping PCI bus scan due to resource conflict\n");
 }
 
 static int __init pcibios_init(void)

commit cf242007a1eb29dcf93d1cb34713ec9b3f4a0e1b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Apr 20 21:53:33 2009 +0900

    sh: pci: Rename pci-new.c to pci.c.
    
    pci-new.c is now in a state to replace the old pci.c, rename it
    accordingly.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
new file mode 100644
index 000000000000..54d77cbb8b39
--- /dev/null
+++ b/arch/sh/drivers/pci/pci.c
@@ -0,0 +1,364 @@
+/*
+ * New-style PCI core.
+ *
+ * Copyright (c) 2004 - 2009  Paul Mundt
+ * Copyright (c) 2002  M. R. Brown
+ *
+ * Modelled after arch/mips/pci/pci.c:
+ *  Copyright (C) 2003, 04 Ralf Baechle (ralf@linux-mips.org)
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/dma-debug.h>
+#include <linux/io.h>
+#include <linux/mutex.h>
+
+unsigned long PCIBIOS_MIN_IO = 0x0000;
+unsigned long PCIBIOS_MIN_MEM = 0;
+
+/*
+ * The PCI controller list.
+ */
+static struct pci_channel *hose_head, **hose_tail = &hose_head;
+
+static int pci_initialized;
+
+static void __devinit pcibios_scanbus(struct pci_channel *hose)
+{
+	static int next_busno;
+	struct pci_bus *bus;
+
+	bus = pci_scan_bus(next_busno, hose->pci_ops, hose);
+	if (bus) {
+		next_busno = bus->subordinate + 1;
+		/* Don't allow 8-bit bus number overflow inside the hose -
+		   reserve some space for bridges. */
+		if (next_busno > 224)
+			next_busno = 0;
+
+		pci_bus_size_bridges(bus);
+		pci_bus_assign_resources(bus);
+		pci_enable_bridges(bus);
+	}
+}
+
+static DEFINE_MUTEX(pci_scan_mutex);
+
+void __devinit register_pci_controller(struct pci_channel *hose)
+{
+	if (request_resource(&iomem_resource, hose->mem_resource) < 0)
+		goto out;
+	if (request_resource(&ioport_resource, hose->io_resource) < 0) {
+		release_resource(hose->mem_resource);
+		goto out;
+	}
+
+	*hose_tail = hose;
+	hose_tail = &hose->next;
+
+	/*
+	 * Do not panic here but later - this might hapen before console init.
+	 */
+	if (!hose->io_map_base) {
+		printk(KERN_WARNING
+		       "registering PCI controller with io_map_base unset\n");
+	}
+
+	/*
+	 * Scan the bus if it is register after the PCI subsystem
+	 * initialization.
+	 */
+	if (pci_initialized) {
+		mutex_lock(&pci_scan_mutex);
+		pcibios_scanbus(hose);
+		mutex_unlock(&pci_scan_mutex);
+	}
+
+	return;
+
+out:
+	printk(KERN_WARNING
+	       "Skipping PCI bus scan due to resource conflict\n");
+}
+
+static int __init pcibios_init(void)
+{
+	struct pci_channel *hose;
+
+	/* Scan all of the recorded PCI controllers.  */
+	for (hose = hose_head; hose; hose = hose->next)
+		pcibios_scanbus(hose);
+
+	pci_fixup_irqs(pci_common_swizzle, pcibios_map_platform_irq);
+
+	dma_debug_add_bus(&pci_bus_type);
+
+	pci_initialized = 1;
+
+	return 0;
+}
+subsys_initcall(pcibios_init);
+
+static void pcibios_fixup_device_resources(struct pci_dev *dev,
+	struct pci_bus *bus)
+{
+	/* Update device resources.  */
+	struct pci_channel *hose = bus->sysdata;
+	unsigned long offset = 0;
+	int i;
+
+	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
+		if (!dev->resource[i].start)
+			continue;
+		if (dev->resource[i].flags & IORESOURCE_PCI_FIXED)
+			continue;
+		if (dev->resource[i].flags & IORESOURCE_IO)
+			offset = hose->io_offset;
+		else if (dev->resource[i].flags & IORESOURCE_MEM)
+			offset = hose->mem_offset;
+
+		dev->resource[i].start += offset;
+		dev->resource[i].end += offset;
+	}
+}
+
+/*
+ *  Called after each bus is probed, but before its children
+ *  are examined.
+ */
+void __devinit pcibios_fixup_bus(struct pci_bus *bus)
+{
+	struct pci_dev *dev = bus->self;
+	struct list_head *ln;
+	struct pci_channel *chan = bus->sysdata;
+
+	if (!dev) {
+		bus->resource[0] = chan->io_resource;
+		bus->resource[1] = chan->mem_resource;
+	}
+
+	for (ln = bus->devices.next; ln != &bus->devices; ln = ln->next) {
+		dev = pci_dev_b(ln);
+
+		if ((dev->class >> 8) != PCI_CLASS_BRIDGE_PCI)
+			pcibios_fixup_device_resources(dev, bus);
+	}
+}
+
+/*
+ * We need to avoid collisions with `mirrored' VGA ports
+ * and other strange ISA hardware, so we always want the
+ * addresses to be allocated in the 0x000-0x0ff region
+ * modulo 0x400.
+ */
+void pcibios_align_resource(void *data, struct resource *res,
+			    resource_size_t size, resource_size_t align)
+{
+	struct pci_dev *dev = data;
+	struct pci_channel *chan = dev->sysdata;
+	resource_size_t start = res->start;
+
+	if (res->flags & IORESOURCE_IO) {
+		if (start < PCIBIOS_MIN_IO + chan->io_resource->start)
+			start = PCIBIOS_MIN_IO + chan->io_resource->start;
+
+		/*
+                 * Put everything into 0x00-0xff region modulo 0x400.
+		 */
+		if (start & 0x300) {
+			start = (start + 0x3ff) & ~0x3ff;
+			res->start = start;
+		}
+	} else if (res->flags & IORESOURCE_MEM) {
+		if (start < PCIBIOS_MIN_MEM + chan->mem_resource->start)
+			start = PCIBIOS_MIN_MEM + chan->mem_resource->start;
+	}
+
+	res->start = start;
+}
+
+void pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
+			 struct resource *res)
+{
+	struct pci_channel *hose = dev->sysdata;
+	unsigned long offset = 0;
+
+	if (res->flags & IORESOURCE_IO)
+		offset = hose->io_offset;
+	else if (res->flags & IORESOURCE_MEM)
+		offset = hose->mem_offset;
+
+	region->start = res->start - offset;
+	region->end = res->end - offset;
+}
+
+void __devinit
+pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,
+			struct pci_bus_region *region)
+{
+	struct pci_channel *hose = dev->sysdata;
+	unsigned long offset = 0;
+
+	if (res->flags & IORESOURCE_IO)
+		offset = hose->io_offset;
+	else if (res->flags & IORESOURCE_MEM)
+		offset = hose->mem_offset;
+
+	res->start = region->start + offset;
+	res->end = region->end + offset;
+}
+
+int pcibios_enable_device(struct pci_dev *dev, int mask)
+{
+	u16 cmd, old_cmd;
+	int idx;
+	struct resource *r;
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	old_cmd = cmd;
+	for (idx=0; idx < PCI_NUM_RESOURCES; idx++) {
+		/* Only set up the requested stuff */
+		if (!(mask & (1<<idx)))
+			continue;
+
+		r = &dev->resource[idx];
+		if (!(r->flags & (IORESOURCE_IO | IORESOURCE_MEM)))
+			continue;
+		if ((idx == PCI_ROM_RESOURCE) &&
+				(!(r->flags & IORESOURCE_ROM_ENABLE)))
+			continue;
+		if (!r->start && r->end) {
+			printk(KERN_ERR "PCI: Device %s not available "
+			       "because of resource collisions\n",
+			       pci_name(dev));
+			return -EINVAL;
+		}
+		if (r->flags & IORESOURCE_IO)
+			cmd |= PCI_COMMAND_IO;
+		if (r->flags & IORESOURCE_MEM)
+			cmd |= PCI_COMMAND_MEMORY;
+	}
+	if (cmd != old_cmd) {
+		printk("PCI: Enabling device %s (%04x -> %04x)\n",
+		       pci_name(dev), old_cmd, cmd);
+		pci_write_config_word(dev, PCI_COMMAND, cmd);
+	}
+	return 0;
+}
+
+/*
+ *  If we set up a device for bus mastering, we need to check and set
+ *  the latency timer as it may not be properly set.
+ */
+static unsigned int pcibios_max_latency = 255;
+
+void pcibios_set_master(struct pci_dev *dev)
+{
+	u8 lat;
+	pci_read_config_byte(dev, PCI_LATENCY_TIMER, &lat);
+	if (lat < 16)
+		lat = (64 <= pcibios_max_latency) ? 64 : pcibios_max_latency;
+	else if (lat > pcibios_max_latency)
+		lat = pcibios_max_latency;
+	else
+		return;
+	printk(KERN_INFO "PCI: Setting latency timer of device %s to %d\n",
+	       pci_name(dev), lat);
+	pci_write_config_byte(dev, PCI_LATENCY_TIMER, lat);
+}
+
+void __init pcibios_update_irq(struct pci_dev *dev, int irq)
+{
+	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
+}
+
+char * __devinit pcibios_setup(char *str)
+{
+	return str;
+}
+
+int pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,
+			enum pci_mmap_state mmap_state, int write_combine)
+{
+	/*
+	 * I/O space can be accessed via normal processor loads and stores on
+	 * this platform but for now we elect not to do this and portable
+	 * drivers should not do this anyway.
+	 */
+	if (mmap_state == pci_mmap_io)
+		return -EINVAL;
+
+	/*
+	 * Ignore write-combine; for now only return uncached mappings.
+	 */
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	return remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+			       vma->vm_end - vma->vm_start,
+			       vma->vm_page_prot);
+}
+
+static void __iomem *ioport_map_pci(struct pci_dev *dev,
+				    unsigned long port, unsigned int nr)
+{
+	struct pci_channel *chan = dev->sysdata;
+
+	if (!chan->io_map_base)
+		chan->io_map_base = generic_io_base;
+
+	return (void __iomem *)(chan->io_map_base + port);
+}
+
+void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen)
+{
+	resource_size_t start = pci_resource_start(dev, bar);
+	resource_size_t len = pci_resource_len(dev, bar);
+	unsigned long flags = pci_resource_flags(dev, bar);
+
+	if (unlikely(!len || !start))
+		return NULL;
+	if (maxlen && len > maxlen)
+		len = maxlen;
+
+	if (flags & IORESOURCE_IO)
+		return ioport_map_pci(dev, start, len);
+
+	/*
+	 * Presently the IORESOURCE_MEM case is a bit special, most
+	 * SH7751 style PCI controllers have PCI memory at a fixed
+	 * location in the address space where no remapping is desired.
+	 * With the IORESOURCE_MEM case more care has to be taken
+	 * to inhibit page table mapping for legacy cores, but this is
+	 * punted off to __ioremap().
+	 *					-- PFM.
+	 */
+	if (flags & IORESOURCE_MEM) {
+		if (flags & IORESOURCE_CACHEABLE)
+			return ioremap(start, len);
+
+		return ioremap_nocache(start, len);
+	}
+
+	return NULL;
+}
+EXPORT_SYMBOL(pci_iomap);
+
+void pci_iounmap(struct pci_dev *dev, void __iomem *addr)
+{
+	iounmap(addr);
+}
+EXPORT_SYMBOL(pci_iounmap);
+
+#ifdef CONFIG_HOTPLUG
+EXPORT_SYMBOL(pcibios_resource_to_bus);
+EXPORT_SYMBOL(pcibios_bus_to_resource);
+EXPORT_SYMBOL(PCIBIOS_MIN_IO);
+EXPORT_SYMBOL(PCIBIOS_MIN_MEM);
+#endif

commit 805fcc88999162b361ef0b0ce25782ef65f147d7
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Apr 20 21:46:42 2009 +0900

    sh: pci: Kill off the last remnants of the now unused pci-auto code.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
deleted file mode 100644
index 8c332b2a4641..000000000000
--- a/arch/sh/drivers/pci/pci.c
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * arch/sh/drivers/pci/pci.c
- *
- * Copyright (c) 2002 M. R. Brown  <mrbrown@linux-sh.org>
- * Copyright (c) 2004 - 2006 Paul Mundt  <lethal@linux-sh.org>
- *
- * These functions are collected here to reduce duplication of common
- * code amongst the many platform-specific PCI support code files.
- *
- * These routines require the following board-specific routines:
- * void pcibios_fixup_irqs();
- *
- * See include/asm-sh/pci.h for more information.
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- */
-#include <linux/kernel.h>
-#include <linux/pci.h>
-#include <linux/init.h>
-#include <linux/dma-debug.h>
-#include <asm/io.h>
-
-static int __init pcibios_init(void)
-{
-	struct pci_channel *p;
-	struct pci_bus *bus;
-	int busno;
-
-	/* init channels */
-	busno = 0;
-	for (p = board_pci_channels; p->init; p++) {
-		if (p->init(p) == 0)
-			p->enabled = 1;
-		else
-			pr_err("Unable to init pci channel %d\n", busno);
-		busno++;
-	}
-
-#ifdef CONFIG_PCI_AUTO
-	/* assign resources */
-	busno = 0;
-	for (p = board_pci_channels; p->init; p++)
-		if (p->enabled)
-			busno = pciauto_assign_resources(busno, p) + 1;
-#endif
-
-	/* scan the buses */
-	busno = 0;
-	for (p = board_pci_channels; p->init; p++) {
-		if (p->enabled) {
-			bus = pci_scan_bus(busno, p->pci_ops, p);
-			busno = bus->subordinate + 1;
-		}
-	}
-
-	pci_fixup_irqs(pci_common_swizzle, pcibios_map_platform_irq);
-
-	dma_debug_add_bus(&pci_bus_type);
-
-	return 0;
-}
-subsys_initcall(pcibios_init);
-
-/*
- *  Called after each bus is probed, but before its children
- *  are examined.
- */
-void __devinit __weak pcibios_fixup_bus(struct pci_bus *bus)
-{
-	pci_read_bridge_bases(bus);
-}
-
-EXPORT_SYMBOL(board_pci_channels);

commit 3f8daeacd7ed7a502daf0998e2515cea4f467f21
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Apr 20 18:53:41 2009 +0900

    sh: pci: Consolidate the remaining common bits.
    
    This moves the remaining common bits in to pci-lib. Thereby reducing
    pci.c/pci-new.c to simple bus fixups and controller registration.
    
    As more platforms are moved over, the old code will disappear completely
    and the pci-new bits will be rolled in to pci-lib, eventually replacing
    pci.c completely.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index c15a6f0ad500..8c332b2a4641 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -72,62 +72,4 @@ void __devinit __weak pcibios_fixup_bus(struct pci_bus *bus)
 	pci_read_bridge_bases(bus);
 }
 
-int pcibios_enable_device(struct pci_dev *dev, int mask)
-{
-	u16 cmd, old_cmd;
-	int idx;
-	struct resource *r;
-
-	pci_read_config_word(dev, PCI_COMMAND, &cmd);
-	old_cmd = cmd;
-	for(idx=0; idx<6; idx++) {
-		if (!(mask & (1 << idx)))
-			continue;
-		r = &dev->resource[idx];
-		if (!r->start && r->end) {
-			printk(KERN_ERR "PCI: Device %s not available because "
-			       "of resource collisions\n", pci_name(dev));
-			return -EINVAL;
-		}
-		if (r->flags & IORESOURCE_IO)
-			cmd |= PCI_COMMAND_IO;
-		if (r->flags & IORESOURCE_MEM)
-			cmd |= PCI_COMMAND_MEMORY;
-	}
-	if (dev->resource[PCI_ROM_RESOURCE].start)
-		cmd |= PCI_COMMAND_MEMORY;
-	if (cmd != old_cmd) {
-		printk(KERN_INFO "PCI: Enabling device %s (%04x -> %04x)\n",
-		       pci_name(dev), old_cmd, cmd);
-		pci_write_config_word(dev, PCI_COMMAND, cmd);
-	}
-	return 0;
-}
-
-/*
- *  If we set up a device for bus mastering, we need to check and set
- *  the latency timer as it may not be properly set.
- */
-static unsigned int pcibios_max_latency = 255;
-
-void pcibios_set_master(struct pci_dev *dev)
-{
-	u8 lat;
-	pci_read_config_byte(dev, PCI_LATENCY_TIMER, &lat);
-	if (lat < 16)
-		lat = (64 <= pcibios_max_latency) ? 64 : pcibios_max_latency;
-	else if (lat > pcibios_max_latency)
-		lat = pcibios_max_latency;
-	else
-		return;
-	printk(KERN_INFO "PCI: Setting latency timer of device %s to %d\n",
-	       pci_name(dev), lat);
-	pci_write_config_byte(dev, PCI_LATENCY_TIMER, lat);
-}
-
-void __init pcibios_update_irq(struct pci_dev *dev, int irq)
-{
-	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
-}
-
 EXPORT_SYMBOL(board_pci_channels);

commit 5160d3f782a5e0cdb3bdaa8a891a1fb9d9ab83ec
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Apr 20 18:47:21 2009 +0900

    sh: pci: Consolidate bus<->resource mapping in pci-lib.
    
    Now that the io and mem offsets are tracked accordingly, the pci-new
    version of the bus<->resource mappers can be used generically. This
    moves them in to pci-lib.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index d39f24091ade..c15a6f0ad500 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -72,20 +72,6 @@ void __devinit __weak pcibios_fixup_bus(struct pci_bus *bus)
 	pci_read_bridge_bases(bus);
 }
 
-void pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
-			     struct resource *res)
-{
-	region->start = res->start;
-	region->end = res->end;
-}
-
-void pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,
-			     struct pci_bus_region *region)
-{
-	res->start = region->start;
-	res->end = region->end;
-}
-
 int pcibios_enable_device(struct pci_dev *dev, int mask)
 {
 	u16 cmd, old_cmd;

commit 0bb34a6bf1f71d5ad2abfda582a2c2794957bc7b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Apr 20 16:38:00 2009 +0900

    sh: pci: Consolidate pci_iomap() and use the generic I/O base.
    
    This consolidates the pci_iomap() definitions and reworks how the I/O
    port base is handled. PCI channels can register their own I/O map base,
    or if none is provided, the system-wide generic I/O base is used instead.
    
    Functionally nothing changes, while this allows us to kill off lots of
    I/O address special casing and lookups.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index f670988e033d..d39f24091ade 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -144,39 +144,4 @@ void __init pcibios_update_irq(struct pci_dev *dev, int irq)
 	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
 }
 
-void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen)
-{
-	resource_size_t start = pci_resource_start(dev, bar);
-	resource_size_t len = pci_resource_len(dev, bar);
-	unsigned long flags = pci_resource_flags(dev, bar);
-
-	if (unlikely(!len || !start))
-		return NULL;
-	if (maxlen && len > maxlen)
-		len = maxlen;
-
-	/*
-	 * Presently the IORESOURCE_MEM case is a bit special, most
-	 * SH7751 style PCI controllers have PCI memory at a fixed
-	 * location in the address space where no remapping is desired.
-	 * With the IORESOURCE_MEM case more care has to be taken
-	 * to inhibit page table mapping for legacy cores, but this is
-	 * punted off to __ioremap().
-	 *					-- PFM.
-	 */
-	if (flags & IORESOURCE_IO)
-		return ioport_map(start, len);
-	if (flags & IORESOURCE_MEM)
-		return ioremap(start, len);
-
-	return NULL;
-}
-EXPORT_SYMBOL(pci_iomap);
-
-void pci_iounmap(struct pci_dev *dev, void __iomem *addr)
-{
-	iounmap(addr);
-}
-EXPORT_SYMBOL(pci_iounmap);
-
 EXPORT_SYMBOL(board_pci_channels);

commit a3c0e0d0032d5bbfd7dc04827a257c717d432a5b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Apr 20 16:14:29 2009 +0900

    sh: pci: Consolidate pcibios_align_resource() definitions.
    
    This introduces a saner pcibios_align_resource() that can be used
    regardless of whether pci-auto or pci-new are being used, and
    consolidates it in pci-lib.c.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 6d659cd93c9d..f670988e033d 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -86,29 +86,6 @@ void pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,
 	res->end = region->end;
 }
 
-void pcibios_align_resource(void *data, struct resource *res,
-			    resource_size_t size, resource_size_t align)
-			    __attribute__ ((weak));
-
-/*
- * We need to avoid collisions with `mirrored' VGA ports
- * and other strange ISA hardware, so we always want the
- * addresses to be allocated in the 0x000-0x0ff region
- * modulo 0x400.
- */
-void pcibios_align_resource(void *data, struct resource *res,
-			    resource_size_t size, resource_size_t align)
-{
-	if (res->flags & IORESOURCE_IO) {
-		resource_size_t start = res->start;
-
-		if (start & 0x300) {
-			start = (start + 0x3ff) & ~0x3ff;
-			res->start = start;
-		}
-	}
-}
-
 int pcibios_enable_device(struct pci_dev *dev, int mask)
 {
 	u16 cmd, old_cmd;

commit 9ade1217c9ba39ad2f004a898ddfbb815fd5fe74
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Apr 20 15:38:25 2009 +0900

    sh: pci: Drop asm-generic/pci.h, so we can use our own fixups.
    
    The new PCI code wants its own bus<->resource mappings instead of the
    generic equivalents, so drop the asm-generic include in preparation.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 8aaacc99b710..6d659cd93c9d 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -72,6 +72,20 @@ void __devinit __weak pcibios_fixup_bus(struct pci_bus *bus)
 	pci_read_bridge_bases(bus);
 }
 
+void pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
+			     struct resource *res)
+{
+	region->start = res->start;
+	region->end = res->end;
+}
+
+void pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,
+			     struct pci_bus_region *region)
+{
+	res->start = region->start;
+	res->end = region->end;
+}
+
 void pcibios_align_resource(void *data, struct resource *res,
 			    resource_size_t size, resource_size_t align)
 			    __attribute__ ((weak));

commit aa5d3ff99cc1f3dfe262ab9dd9179131fcfe39fd
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Tue Feb 19 21:35:40 2008 +0900

    sh: export board_pci_channels in one place
    
    Instead of sometimes exporting board_pci_channels[] in the board specific
    code just export it in one place.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index b9aca5478048..8aaacc99b710 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -187,3 +187,5 @@ void pci_iounmap(struct pci_dev *dev, void __iomem *addr)
 	iounmap(addr);
 }
 EXPORT_SYMBOL(pci_iounmap);
+
+EXPORT_SYMBOL(board_pci_channels);

commit ef339f241b08a16af58897e6288ba200e0c7a8c7
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Tue Feb 19 21:35:22 2008 +0900

    sh: pci memory range checking code
    
    This patch changes the code to use __is_pci_memory() instead of
    is_pci_memaddr(). __is_pci_memory() loops through all the pci
    channels on the system to match memory windows.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 29ec16e69afa..b9aca5478048 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -167,9 +167,8 @@ void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen)
 	/*
 	 * Presently the IORESOURCE_MEM case is a bit special, most
 	 * SH7751 style PCI controllers have PCI memory at a fixed
-	 * location in the address space where no remapping is desired
-	 * (typically at 0xfd000000, but is_pci_memaddr() will know
-	 * best). With the IORESOURCE_MEM case more care has to be taken
+	 * location in the address space where no remapping is desired.
+	 * With the IORESOURCE_MEM case more care has to be taken
 	 * to inhibit page table mapping for legacy cores, but this is
 	 * punted off to __ioremap().
 	 *					-- PFM.

commit d0e3db40e2a1352aa2a2f425a7d4631bddc03d51
Author: Magnus Damm <damm@igel.co.jp>
Date:   Wed Mar 11 15:46:14 2009 +0900

    sh: add init member to pci_channel data
    
    This patch adds an init callback to struct pci_channel and makes sure
    it is initialized properly. Code is added to call this init function
    from pcibios_init(). Return values are adjusted and a warning is is
    printed if init fails.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 0d6ac7a1db49..29ec16e69afa 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -28,18 +28,31 @@ static int __init pcibios_init(void)
 	struct pci_bus *bus;
 	int busno;
 
+	/* init channels */
+	busno = 0;
+	for (p = board_pci_channels; p->init; p++) {
+		if (p->init(p) == 0)
+			p->enabled = 1;
+		else
+			pr_err("Unable to init pci channel %d\n", busno);
+		busno++;
+	}
+
 #ifdef CONFIG_PCI_AUTO
 	/* assign resources */
 	busno = 0;
-	for (p = board_pci_channels; p->pci_ops != NULL; p++)
-		busno = pciauto_assign_resources(busno, p) + 1;
+	for (p = board_pci_channels; p->init; p++)
+		if (p->enabled)
+			busno = pciauto_assign_resources(busno, p) + 1;
 #endif
 
 	/* scan the buses */
 	busno = 0;
-	for (p = board_pci_channels; p->pci_ops != NULL; p++) {
-		bus = pci_scan_bus(busno, p->pci_ops, p);
-		busno = bus->subordinate + 1;
+	for (p = board_pci_channels; p->init; p++) {
+		if (p->enabled) {
+			bus = pci_scan_bus(busno, p->pci_ops, p);
+			busno = bus->subordinate + 1;
+		}
 	}
 
 	pci_fixup_irqs(pci_common_swizzle, pcibios_map_platform_irq);

commit e588a00fe546695e93077b3f7b7009f0c31d9370
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Apr 14 15:23:40 2009 +0900

    sh: Add in PCI bus for DMA API debugging.
    
    This adds in the pci_bus_type for DMA API debug.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index e36c7b870861..0d6ac7a1db49 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -19,6 +19,7 @@
 #include <linux/kernel.h>
 #include <linux/pci.h>
 #include <linux/init.h>
+#include <linux/dma-debug.h>
 #include <asm/io.h>
 
 static int __init pcibios_init(void)
@@ -43,6 +44,8 @@ static int __init pcibios_init(void)
 
 	pci_fixup_irqs(pci_common_swizzle, pcibios_map_platform_irq);
 
+	dma_debug_add_bus(&pci_bus_type);
+
 	return 0;
 }
 subsys_initcall(pcibios_init);

commit e55823492dde22f841ec7deeb4d61f195ecb7ed4
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Dec 16 21:37:15 2008 -0700

    PCI: sh: use generic INTx swizzle from PCI core
    
    Use the generic pci_common_swizzle() instead of arch-specific code.
    
    Note that pci_common_swizzle() loops based on dev->bus->self, not
    dev->bus->parent as the sh simple_swizzle() did.  I think they
    are equivalent for this purpose.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index aea3b6b3033a..e36c7b870861 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -21,21 +21,6 @@
 #include <linux/init.h>
 #include <asm/io.h>
 
-static u8 __init simple_swizzle(struct pci_dev *dev, u8 *pinp)
-{
-	u8 pin = *pinp;
-
-	while (dev->bus->parent) {
-		pin = pci_swizzle_interrupt_pin(dev, pin);
-		/* Move up the chain of bridges. */
-		dev = dev->bus->self;
-	}
-	*pinp = pin;
-
-	/* The slot is the slot of the last bridge. */
-	return PCI_SLOT(dev->devfn);
-}
-
 static int __init pcibios_init(void)
 {
 	struct pci_channel *p;
@@ -56,7 +41,7 @@ static int __init pcibios_init(void)
 		busno = bus->subordinate + 1;
 	}
 
-	pci_fixup_irqs(simple_swizzle, pcibios_map_platform_irq);
+	pci_fixup_irqs(pci_common_swizzle, pcibios_map_platform_irq);
 
 	return 0;
 }

commit 6aa6e4981741013e4a8c7c3ee7b90c24e89fae24
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Dec 9 16:12:32 2008 -0700

    PCI: sh: use generic pci_swizzle_interrupt_pin()
    
    Use the generic pci_swizzle_interrupt_pin() instead of arch-specific code.
    
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index d3839e609aac..aea3b6b3033a 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -21,17 +21,12 @@
 #include <linux/init.h>
 #include <asm/io.h>
 
-static inline u8 bridge_swizzle(u8 pin, u8 slot)
-{
-	return (((pin - 1) + slot) % 4) + 1;
-}
-
 static u8 __init simple_swizzle(struct pci_dev *dev, u8 *pinp)
 {
 	u8 pin = *pinp;
 
 	while (dev->bus->parent) {
-		pin = bridge_swizzle(pin, PCI_SLOT(dev->devfn));
+		pin = pci_swizzle_interrupt_pin(dev, pin);
 		/* Move up the chain of bridges. */
 		dev = dev->bus->self;
 	}

commit 62410034e79d9249647d1fe6f6f35a06b3747e68
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Jun 18 01:33:40 2008 +0300

    sh: make pcibios_max_latency static
    
    This patch makes the needlessly global pcibios_max_latency static.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index f57095a2617c..d3839e609aac 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -135,7 +135,7 @@ int pcibios_enable_device(struct pci_dev *dev, int mask)
  *  If we set up a device for bus mastering, we need to check and set
  *  the latency timer as it may not be properly set.
  */
-unsigned int pcibios_max_latency = 255;
+static unsigned int pcibios_max_latency = 255;
 
 void pcibios_set_master(struct pci_dev *dev)
 {

commit 0aea531326d1a17ccef7d9a538429c5b32cf4f12
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Jun 18 01:33:32 2008 +0300

    PCI: remove unused arch pcibios_update_resource() functions
    
    Russell King did the following back in 2003:
    
    <--  snip  -->
    
        [PCI] pci-9: Kill per-architecture pcibios_update_resource()
    
        Kill pcibios_update_resource(), replacing it with pci_update_resource().
        pci_update_resource() uses pcibios_resource_to_bus() to convert a
        resource to a device BAR - the transformation should be exactly the
        same as the transformation used for the PCI bridges.
    
        pci_update_resource "knows" about 64-bit BARs, but doesn't attempt to
        set the high 32-bits to anything non-zero - currently no architecture
        attempts to do something different.  If anyone cares, please fix; I'm
        going to reflect current behaviour for the time being.
    
        Ivan pointed out the following architectures need to examine their
        pcibios_update_resource() implementation - they should make sure that
        this new implementation does the right thing.  #warning's have been
        added where appropriate.
    
            ia64
            mips
            mips64
    
        This cset also includes a fix for the problem reported by AKPM where
        64-bit arch compilers complain about the resource mask being placed
        in a u32.
    
    <--  snip  -->
    
    This patch removes the unused pcibios_update_resource() functions the
    kernel gained since, from FRV, m68k, mips & sh architectures.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: David Howells <dhowells@redhat.com>
    Acked-by: Greg Ungerer <gerg@uclinux.org>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 08d2e7325252..f57095a2617c 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -76,38 +76,6 @@ void __devinit __weak pcibios_fixup_bus(struct pci_bus *bus)
 	pci_read_bridge_bases(bus);
 }
 
-void
-pcibios_update_resource(struct pci_dev *dev, struct resource *root,
-			struct resource *res, int resource)
-{
-	u32 new, check;
-	int reg;
-
-	new = res->start | (res->flags & PCI_REGION_FLAG_MASK);
-	if (resource < 6) {
-		reg = PCI_BASE_ADDRESS_0 + 4*resource;
-	} else if (resource == PCI_ROM_RESOURCE) {
-		res->flags |= IORESOURCE_ROM_ENABLE;
-		new |= PCI_ROM_ADDRESS_ENABLE;
-		reg = dev->rom_base_reg;
-	} else {
-		/*
-		 * Somebody might have asked allocation of a non-standard
-		 * resource
-		 */
-		return;
-	}
-
-	pci_write_config_dword(dev, reg, new);
-	pci_read_config_dword(dev, reg, &check);
-	if ((new ^ check) & ((new & PCI_BASE_ADDRESS_SPACE_IO) ?
-		PCI_BASE_ADDRESS_IO_MASK : PCI_BASE_ADDRESS_MEM_MASK)) {
-		printk(KERN_ERR "PCI: Error while updating region "
-		       "%s/%d (%08x != %08x)\n", pci_name(dev), resource,
-		       new, check);
-	}
-}
-
 void pcibios_align_resource(void *data, struct resource *res,
 			    resource_size_t size, resource_size_t align)
 			    __attribute__ ((weak));

commit b70d3a2c596fb52b02488ad4aef13fa0d602090c
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Apr 29 00:59:11 2008 -0700

    iomap: fix 64 bits resources on 32 bits
    
    Almost all implementations of pci_iomap() in the kernel, including the generic
    lib/iomap.c one, copies the content of a struct resource into unsigned long's
    which will break on 32 bits platforms with 64 bits resources.
    
    This fixes all definitions of pci_iomap() to use resource_size_t.  I also
    "fixed" the 64bits arch for consistency.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 49b435c3a57a..08d2e7325252 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -191,8 +191,8 @@ void __init pcibios_update_irq(struct pci_dev *dev, int irq)
 
 void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen)
 {
-	unsigned long start = pci_resource_start(dev, bar);
-	unsigned long len = pci_resource_len(dev, bar);
+	resource_size_t start = pci_resource_start(dev, bar);
+	resource_size_t len = pci_resource_len(dev, bar);
 	unsigned long flags = pci_resource_flags(dev, bar);
 
 	if (unlikely(!len || !start))

commit b6d7b666097e79a8908e3c43fd55fd291a95e133
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Nov 22 16:29:10 2007 +0900

    sh: Get the SH-5 PCI support building.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index ccaba368ac9b..49b435c3a57a 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -71,7 +71,7 @@ subsys_initcall(pcibios_init);
  *  Called after each bus is probed, but before its children
  *  are examined.
  */
-void __devinit pcibios_fixup_bus(struct pci_bus *bus)
+void __devinit __weak pcibios_fixup_bus(struct pci_bus *bus)
 {
 	pci_read_bridge_bases(bus);
 }

commit bd5f0d1c256fdf286fab358a04e87476e3535075
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Jul 20 13:22:47 2007 +0900

    sh: Fix up PCI section mismatch warnings.
    
    Flag pcibios_setup() and pcibios_fixup_bus() as __devinit.
    Follows the sh64 change.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index d439336d2e18..ccaba368ac9b 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -71,7 +71,7 @@ subsys_initcall(pcibios_init);
  *  Called after each bus is probed, but before its children
  *  are examined.
  */
-void __init pcibios_fixup_bus(struct pci_bus *bus)
+void __devinit pcibios_fixup_bus(struct pci_bus *bus)
 {
 	pci_read_bridge_bases(bus);
 }

commit a3e61d50dc82475ebca3ff8b18c174c02c5ff511
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 16:45:22 2006 +0900

    sh: Inhibit mapping PCI apertures through page tables.
    
    Inhibit mapping through page tables in __ioremap() for PCI memory
    apertures on SH7751 and SH7780-style PCI controllers, translation is
    not possible for these areas. For other users that map a small window
    in P1/P2 space, ioremap() traps that already, and should never make
    it to __ioremap().
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 7377a8a8e161..d439336d2e18 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -195,7 +195,7 @@ void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen)
 	unsigned long len = pci_resource_len(dev, bar);
 	unsigned long flags = pci_resource_flags(dev, bar);
 
-	if (!len || !start)
+	if (unlikely(!len || !start))
 		return NULL;
 	if (maxlen && len > maxlen)
 		len = maxlen;
@@ -204,18 +204,16 @@ void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen)
 	 * Presently the IORESOURCE_MEM case is a bit special, most
 	 * SH7751 style PCI controllers have PCI memory at a fixed
 	 * location in the address space where no remapping is desired
-	 * (traditionally at 0xfd000000). Once this changes, the
-	 * IORESOURCE_MEM case will have to switch to using ioremap() and
-	 * more care will have to be taken to inhibit page table mapping
-	 * for legacy cores.
-	 *
-	 * For now everything wraps to ioport_map(), since boards that
-	 * have PCI will be able to check the address range properly on
-	 * their own.
-	 *			-- PFM.
+	 * (typically at 0xfd000000, but is_pci_memaddr() will know
+	 * best). With the IORESOURCE_MEM case more care has to be taken
+	 * to inhibit page table mapping for legacy cores, but this is
+	 * punted off to __ioremap().
+	 *					-- PFM.
 	 */
-	if (flags & (IORESOURCE_IO | IORESOURCE_MEM))
+	if (flags & IORESOURCE_IO)
 		return ioport_map(start, len);
+	if (flags & IORESOURCE_MEM)
+		return ioremap(start, len);
 
 	return NULL;
 }

commit 959f85f8a3223c116bbe95dd8a9b207790b5d4d3
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 16:43:28 2006 +0900

    sh: Consolidated SH7751/SH7780 PCI support.
    
    This cleans up quite a lot of the PCI mess that we
    currently have, and attempts to consolidate the
    duplication in the SH7780 and SH7751 PCI controllers.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 285dffd12bd8..7377a8a8e161 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -21,6 +21,26 @@
 #include <linux/init.h>
 #include <asm/io.h>
 
+static inline u8 bridge_swizzle(u8 pin, u8 slot)
+{
+	return (((pin - 1) + slot) % 4) + 1;
+}
+
+static u8 __init simple_swizzle(struct pci_dev *dev, u8 *pinp)
+{
+	u8 pin = *pinp;
+
+	while (dev->bus->parent) {
+		pin = bridge_swizzle(pin, PCI_SLOT(dev->devfn));
+		/* Move up the chain of bridges. */
+		dev = dev->bus->self;
+	}
+	*pinp = pin;
+
+	/* The slot is the slot of the last bridge. */
+	return PCI_SLOT(dev->devfn);
+}
+
 static int __init pcibios_init(void)
 {
 	struct pci_channel *p;
@@ -36,19 +56,26 @@ static int __init pcibios_init(void)
 
 	/* scan the buses */
 	busno = 0;
-	for (p= board_pci_channels; p->pci_ops != NULL; p++) {
+	for (p = board_pci_channels; p->pci_ops != NULL; p++) {
 		bus = pci_scan_bus(busno, p->pci_ops, p);
-		busno = bus->subordinate+1;
+		busno = bus->subordinate + 1;
 	}
 
-	/* board-specific fixups */
-	pcibios_fixup_irqs();
+	pci_fixup_irqs(simple_swizzle, pcibios_map_platform_irq);
 
 	return 0;
 }
-
 subsys_initcall(pcibios_init);
 
+/*
+ *  Called after each bus is probed, but before its children
+ *  are examined.
+ */
+void __init pcibios_fixup_bus(struct pci_bus *bus)
+{
+	pci_read_bridge_bases(bus);
+}
+
 void
 pcibios_update_resource(struct pci_dev *dev, struct resource *root,
 			struct resource *res, int resource)
@@ -192,11 +219,10 @@ void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen)
 
 	return NULL;
 }
+EXPORT_SYMBOL(pci_iomap);
 
 void pci_iounmap(struct pci_dev *dev, void __iomem *addr)
 {
 	iounmap(addr);
 }
-
-EXPORT_SYMBOL(pci_iomap);
 EXPORT_SYMBOL(pci_iounmap);

commit d7cdc9e8ac82c43fdcd4fde6b5b53d2dcba7f707
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 15:16:42 2006 +0900

    sh: ioremap() overhaul.
    
    ioremap() overhaul. Add support for transparent PMB mapping, get rid of
    p3_ioremap(), etc. Also drop ioremap() and iounmap() routines from the
    machvec, as everyone can use the generic ioremap() API instead. For PCI
    memory apertures and other special cases, use the pci_iomap() API, as
    boards are already required to get the mapping right there.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 1f5e23e8b163..285dffd12bd8 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -2,7 +2,7 @@
  * arch/sh/drivers/pci/pci.c
  *
  * Copyright (c) 2002 M. R. Brown  <mrbrown@linux-sh.org>
- * Copyright (c) 2004, 2005 Paul Mundt  <lethal@linux-sh.org>
+ * Copyright (c) 2004 - 2006 Paul Mundt  <lethal@linux-sh.org>
  *
  * These functions are collected here to reduce duplication of common
  * code amongst the many platform-specific PCI support code files.
@@ -172,10 +172,23 @@ void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen)
 		return NULL;
 	if (maxlen && len > maxlen)
 		len = maxlen;
-	if (flags & IORESOURCE_IO)
+
+	/*
+	 * Presently the IORESOURCE_MEM case is a bit special, most
+	 * SH7751 style PCI controllers have PCI memory at a fixed
+	 * location in the address space where no remapping is desired
+	 * (traditionally at 0xfd000000). Once this changes, the
+	 * IORESOURCE_MEM case will have to switch to using ioremap() and
+	 * more care will have to be taken to inhibit page table mapping
+	 * for legacy cores.
+	 *
+	 * For now everything wraps to ioport_map(), since boards that
+	 * have PCI will be able to check the address range properly on
+	 * their own.
+	 *			-- PFM.
+	 */
+	if (flags & (IORESOURCE_IO | IORESOURCE_MEM))
 		return ioport_map(start, len);
-	if (flags & IORESOURCE_MEM)
-		return ioremap(start, len);
 
 	return NULL;
 }

commit a09749dd86e9e93de10f12ab4ce4e90815b5650a
Author: Jamie Lenehan <lenehan@twibble.org>
Date:   Wed Sep 27 15:05:39 2006 +0900

    sh: Titan board support.
    
    Add support for the titan board.
    
    Signed-off-by: Jamie Lenehan <lenehan@twibble.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index 3d546ba329cf..1f5e23e8b163 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -1,21 +1,25 @@
-/* arch/sh/kernel/pci.c
- * $Id: pci.c,v 1.1 2003/08/24 19:15:45 lethal Exp $
+/*
+ * arch/sh/drivers/pci/pci.c
  *
  * Copyright (c) 2002 M. R. Brown  <mrbrown@linux-sh.org>
- * 
- * 
+ * Copyright (c) 2004, 2005 Paul Mundt  <lethal@linux-sh.org>
+ *
  * These functions are collected here to reduce duplication of common
  * code amongst the many platform-specific PCI support code files.
- * 
+ *
  * These routines require the following board-specific routines:
  * void pcibios_fixup_irqs();
  *
  * See include/asm-sh/pci.h for more information.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
  */
-
 #include <linux/kernel.h>
 #include <linux/pci.h>
 #include <linux/init.h>
+#include <asm/io.h>
 
 static int __init pcibios_init(void)
 {
@@ -26,9 +30,8 @@ static int __init pcibios_init(void)
 #ifdef CONFIG_PCI_AUTO
 	/* assign resources */
 	busno = 0;
-	for (p = board_pci_channels; p->pci_ops != NULL; p++) {
+	for (p = board_pci_channels; p->pci_ops != NULL; p++)
 		busno = pciauto_assign_resources(busno, p) + 1;
-	}
 #endif
 
 	/* scan the buses */
@@ -61,13 +64,17 @@ pcibios_update_resource(struct pci_dev *dev, struct resource *root,
 		new |= PCI_ROM_ADDRESS_ENABLE;
 		reg = dev->rom_base_reg;
 	} else {
-		/* Somebody might have asked allocation of a non-standard resource */
+		/*
+		 * Somebody might have asked allocation of a non-standard
+		 * resource
+		 */
 		return;
 	}
-	
+
 	pci_write_config_dword(dev, reg, new);
 	pci_read_config_dword(dev, reg, &check);
-	if ((new ^ check) & ((new & PCI_BASE_ADDRESS_SPACE_IO) ? PCI_BASE_ADDRESS_IO_MASK : PCI_BASE_ADDRESS_MEM_MASK)) {
+	if ((new ^ check) & ((new & PCI_BASE_ADDRESS_SPACE_IO) ?
+		PCI_BASE_ADDRESS_IO_MASK : PCI_BASE_ADDRESS_MEM_MASK)) {
 		printk(KERN_ERR "PCI: Error while updating region "
 		       "%s/%d (%08x != %08x)\n", pci_name(dev), resource,
 		       new, check);
@@ -145,7 +152,8 @@ void pcibios_set_master(struct pci_dev *dev)
 		lat = pcibios_max_latency;
 	else
 		return;
-	printk(KERN_INFO "PCI: Setting latency timer of device %s to %d\n", pci_name(dev), lat);
+	printk(KERN_INFO "PCI: Setting latency timer of device %s to %d\n",
+	       pci_name(dev), lat);
 	pci_write_config_byte(dev, PCI_LATENCY_TIMER, lat);
 }
 
@@ -153,3 +161,29 @@ void __init pcibios_update_irq(struct pci_dev *dev, int irq)
 {
 	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
 }
+
+void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen)
+{
+	unsigned long start = pci_resource_start(dev, bar);
+	unsigned long len = pci_resource_len(dev, bar);
+	unsigned long flags = pci_resource_flags(dev, bar);
+
+	if (!len || !start)
+		return NULL;
+	if (maxlen && len > maxlen)
+		len = maxlen;
+	if (flags & IORESOURCE_IO)
+		return ioport_map(start, len);
+	if (flags & IORESOURCE_MEM)
+		return ioremap(start, len);
+
+	return NULL;
+}
+
+void pci_iounmap(struct pci_dev *dev, void __iomem *addr)
+{
+	iounmap(addr);
+}
+
+EXPORT_SYMBOL(pci_iomap);
+EXPORT_SYMBOL(pci_iounmap);

commit e31dd6e4520439ceae4753f32dd2da2c345e929a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 12 17:06:02 2006 -0700

    [PATCH] 64bit resource: change pci core and arch code to use resource_size_t
    
    Based on a patch series originally from Vivek Goyal <vgoyal@in.ibm.com>
    
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
index c1669905abe4..3d546ba329cf 100644
--- a/arch/sh/drivers/pci/pci.c
+++ b/arch/sh/drivers/pci/pci.c
@@ -75,7 +75,7 @@ pcibios_update_resource(struct pci_dev *dev, struct resource *root,
 }
 
 void pcibios_align_resource(void *data, struct resource *res,
-			    unsigned long size, unsigned long align)
+			    resource_size_t size, resource_size_t align)
 			    __attribute__ ((weak));
 
 /*
@@ -85,10 +85,10 @@ void pcibios_align_resource(void *data, struct resource *res,
  * modulo 0x400.
  */
 void pcibios_align_resource(void *data, struct resource *res,
-			    unsigned long size, unsigned long align)
+			    resource_size_t size, resource_size_t align)
 {
 	if (res->flags & IORESOURCE_IO) {
-		unsigned long start = res->start;
+		resource_size_t start = res->start;
 
 		if (start & 0x300) {
 			start = (start + 0x3ff) & ~0x3ff;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
new file mode 100644
index 000000000000..c1669905abe4
--- /dev/null
+++ b/arch/sh/drivers/pci/pci.c
@@ -0,0 +1,155 @@
+/* arch/sh/kernel/pci.c
+ * $Id: pci.c,v 1.1 2003/08/24 19:15:45 lethal Exp $
+ *
+ * Copyright (c) 2002 M. R. Brown  <mrbrown@linux-sh.org>
+ * 
+ * 
+ * These functions are collected here to reduce duplication of common
+ * code amongst the many platform-specific PCI support code files.
+ * 
+ * These routines require the following board-specific routines:
+ * void pcibios_fixup_irqs();
+ *
+ * See include/asm-sh/pci.h for more information.
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+
+static int __init pcibios_init(void)
+{
+	struct pci_channel *p;
+	struct pci_bus *bus;
+	int busno;
+
+#ifdef CONFIG_PCI_AUTO
+	/* assign resources */
+	busno = 0;
+	for (p = board_pci_channels; p->pci_ops != NULL; p++) {
+		busno = pciauto_assign_resources(busno, p) + 1;
+	}
+#endif
+
+	/* scan the buses */
+	busno = 0;
+	for (p= board_pci_channels; p->pci_ops != NULL; p++) {
+		bus = pci_scan_bus(busno, p->pci_ops, p);
+		busno = bus->subordinate+1;
+	}
+
+	/* board-specific fixups */
+	pcibios_fixup_irqs();
+
+	return 0;
+}
+
+subsys_initcall(pcibios_init);
+
+void
+pcibios_update_resource(struct pci_dev *dev, struct resource *root,
+			struct resource *res, int resource)
+{
+	u32 new, check;
+	int reg;
+
+	new = res->start | (res->flags & PCI_REGION_FLAG_MASK);
+	if (resource < 6) {
+		reg = PCI_BASE_ADDRESS_0 + 4*resource;
+	} else if (resource == PCI_ROM_RESOURCE) {
+		res->flags |= IORESOURCE_ROM_ENABLE;
+		new |= PCI_ROM_ADDRESS_ENABLE;
+		reg = dev->rom_base_reg;
+	} else {
+		/* Somebody might have asked allocation of a non-standard resource */
+		return;
+	}
+	
+	pci_write_config_dword(dev, reg, new);
+	pci_read_config_dword(dev, reg, &check);
+	if ((new ^ check) & ((new & PCI_BASE_ADDRESS_SPACE_IO) ? PCI_BASE_ADDRESS_IO_MASK : PCI_BASE_ADDRESS_MEM_MASK)) {
+		printk(KERN_ERR "PCI: Error while updating region "
+		       "%s/%d (%08x != %08x)\n", pci_name(dev), resource,
+		       new, check);
+	}
+}
+
+void pcibios_align_resource(void *data, struct resource *res,
+			    unsigned long size, unsigned long align)
+			    __attribute__ ((weak));
+
+/*
+ * We need to avoid collisions with `mirrored' VGA ports
+ * and other strange ISA hardware, so we always want the
+ * addresses to be allocated in the 0x000-0x0ff region
+ * modulo 0x400.
+ */
+void pcibios_align_resource(void *data, struct resource *res,
+			    unsigned long size, unsigned long align)
+{
+	if (res->flags & IORESOURCE_IO) {
+		unsigned long start = res->start;
+
+		if (start & 0x300) {
+			start = (start + 0x3ff) & ~0x3ff;
+			res->start = start;
+		}
+	}
+}
+
+int pcibios_enable_device(struct pci_dev *dev, int mask)
+{
+	u16 cmd, old_cmd;
+	int idx;
+	struct resource *r;
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	old_cmd = cmd;
+	for(idx=0; idx<6; idx++) {
+		if (!(mask & (1 << idx)))
+			continue;
+		r = &dev->resource[idx];
+		if (!r->start && r->end) {
+			printk(KERN_ERR "PCI: Device %s not available because "
+			       "of resource collisions\n", pci_name(dev));
+			return -EINVAL;
+		}
+		if (r->flags & IORESOURCE_IO)
+			cmd |= PCI_COMMAND_IO;
+		if (r->flags & IORESOURCE_MEM)
+			cmd |= PCI_COMMAND_MEMORY;
+	}
+	if (dev->resource[PCI_ROM_RESOURCE].start)
+		cmd |= PCI_COMMAND_MEMORY;
+	if (cmd != old_cmd) {
+		printk(KERN_INFO "PCI: Enabling device %s (%04x -> %04x)\n",
+		       pci_name(dev), old_cmd, cmd);
+		pci_write_config_word(dev, PCI_COMMAND, cmd);
+	}
+	return 0;
+}
+
+/*
+ *  If we set up a device for bus mastering, we need to check and set
+ *  the latency timer as it may not be properly set.
+ */
+unsigned int pcibios_max_latency = 255;
+
+void pcibios_set_master(struct pci_dev *dev)
+{
+	u8 lat;
+	pci_read_config_byte(dev, PCI_LATENCY_TIMER, &lat);
+	if (lat < 16)
+		lat = (64 <= pcibios_max_latency) ? 64 : pcibios_max_latency;
+	else if (lat > pcibios_max_latency)
+		lat = pcibios_max_latency;
+	else
+		return;
+	printk(KERN_INFO "PCI: Setting latency timer of device %s to %d\n", pci_name(dev), lat);
+	pci_write_config_byte(dev, PCI_LATENCY_TIMER, lat);
+}
+
+void __init pcibios_update_irq(struct pci_dev *dev, int irq)
+{
+	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
+}
