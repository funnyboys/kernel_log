commit 87dfb311b707cd4c4b666c9af0fa15acbe6eee99
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue May 14 15:46:51 2019 -0700

    treewide: replace #include <asm/sizes.h> with #include <linux/sizes.h>
    
    Since commit dccd2304cc90 ("ARM: 7430/1: sizes.h: move from asm-generic
    to <linux/sizes.h>"), <asm/sizes.h> and <asm-generic/sizes.h> are just
    wrappers of <linux/sizes.h>.
    
    This commit replaces all <asm/sizes.h> and <asm-generic/sizes.h> to
    prepare for the removal.
    
    Link: http://lkml.kernel.org/r/1553267665-27228-1-git-send-email-yamada.masahiro@socionext.com
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index 1b9e5caac389..11ed21c2e9bb 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -14,7 +14,7 @@
 #include <linux/io.h>
 #include "pci-sh4.h"
 #include <asm/addrspace.h>
-#include <asm/sizes.h>
+#include <linux/sizes.h>
 
 static int __init __area_sdram_check(struct pci_channel *chan,
 				     unsigned int area)

commit ff4a7481c3898ffc3cc271d6aca431d190c37247
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 28 00:31:49 2018 -0800

    sh: drivers: convert to SPDX identifiers
    
    Update license to use SPDX-License-Identifier instead of verbose license
    text.
    
    As original license mentioned, it is GPL-2.0 in SPDX.
    Then, MODULE_LICENSE() should be "GPL v2" instead of "GPL".
    See ${LINUX}/include/linux/module.h
    
            "GPL"           [GNU Public License v2 or later]
            "GPL v2"        [GNU Public License v2]
    
    Link: http://lkml.kernel.org/r/87h8fsct0a.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index 86adb1e235cd..1b9e5caac389 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Low-Level PCI Support for the SH7751
  *
@@ -5,10 +6,6 @@
  *  Copyright (C) 2001  Dustin McIntire
  *
  *  With cleanup by Paul van Gool <pvangool@mimotech.com>, 2003.
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 #include <linux/init.h>
 #include <linux/pci.h>

commit 3b554c33dcde9d67efcb8d0a5acca201afd44730
Author: Matt Fleming <matt@console-pimps.org>
Date:   Sat Jun 19 00:01:03 2010 +0100

    sh: Fix typos in PCI initialization message
    
    This typo seems to have been copy and pasted in the PCI initialization
    code. Replace 'intialization' with 'initialization'.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index f98141b3b7d7..86adb1e235cd 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -81,7 +81,7 @@ static int __init sh7751_pci_init(void)
 	unsigned int id;
 	u32 word, reg;
 
-	printk(KERN_NOTICE "PCI: Starting intialization.\n");
+	printk(KERN_NOTICE "PCI: Starting initialization.\n");
 
 	chan->reg_base = 0xfe200000;
 

commit e3a4317e1d9970c56ba19d29393e4289809a1aa5
Author: Magnus Damm <damm@opensource.se>
Date:   Thu Apr 22 06:21:10 2010 +0000

    sh: sh7751 pci controller io port fix
    
    This patch updates the sh7751 pci code to handle io ports
    correctly. The code is based on the sh7788x implementation.
    
    Tested on a R2D-1 board with CONFIG_8139TOO_PIO=y.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index 17811e5d287b..f98141b3b7d7 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -17,6 +17,7 @@
 #include <linux/io.h>
 #include "pci-sh4.h"
 #include <asm/addrspace.h>
+#include <asm/sizes.h>
 
 static int __init __area_sdram_check(struct pci_channel *chan,
 				     unsigned int area)
@@ -47,8 +48,8 @@ static int __init __area_sdram_check(struct pci_channel *chan,
 static struct resource sh7751_pci_resources[] = {
 	{
 		.name	= "SH7751_IO",
-		.start	= SH7751_PCI_IO_BASE,
-		.end	= SH7751_PCI_IO_BASE + SH7751_PCI_IO_SIZE - 1,
+		.start	= 0x1000,
+		.end	= SZ_4M - 1,
 		.flags	= IORESOURCE_IO
 	}, {
 		.name	= "SH7751_mem",

commit b6c58b1d987a5795086c5c2babd8c7367d2fdb8c
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Feb 1 20:01:50 2010 +0900

    sh: Improved multi-resource handling for SH7780 PCI.
    
    The SH7780 PCI controller supports 3 different ranges of PCI memory in
    addition to its PCI I/O window. In the case of 29-bit mode, only 2 memory
    windows are supported, while in 32-bit mode all 3 are visible. This
    attempts to make the resource handling completely dynamic and to permit
    platforms to map in as many apertures as they can handle.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index 6ad5beb524aa..17811e5d287b 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -44,25 +44,25 @@ static int __init __area_sdram_check(struct pci_channel *chan,
 	return 1;
 }
 
-static struct resource sh7751_io_resource = {
-	.name	= "SH7751_IO",
-	.start	= SH7751_PCI_IO_BASE,
-	.end	= SH7751_PCI_IO_BASE + SH7751_PCI_IO_SIZE - 1,
-	.flags	= IORESOURCE_IO
-};
-
-static struct resource sh7751_mem_resource = {
-	.name	= "SH7751_mem",
-	.start	= SH7751_PCI_MEMORY_BASE,
-	.end	= SH7751_PCI_MEMORY_BASE + SH7751_PCI_MEM_SIZE - 1,
-	.flags	= IORESOURCE_MEM
+static struct resource sh7751_pci_resources[] = {
+	{
+		.name	= "SH7751_IO",
+		.start	= SH7751_PCI_IO_BASE,
+		.end	= SH7751_PCI_IO_BASE + SH7751_PCI_IO_SIZE - 1,
+		.flags	= IORESOURCE_IO
+	}, {
+		.name	= "SH7751_mem",
+		.start	= SH7751_PCI_MEMORY_BASE,
+		.end	= SH7751_PCI_MEMORY_BASE + SH7751_PCI_MEM_SIZE - 1,
+		.flags	= IORESOURCE_MEM
+	},
 };
 
 static struct pci_channel sh7751_pci_controller = {
 	.pci_ops	= &sh4_pci_ops,
-	.mem_resource	= &sh7751_mem_resource,
+	.resources	= sh7751_pci_resources,
+	.nr_resources	= ARRAY_SIZE(sh7751_pci_resources),
 	.mem_offset	= 0x00000000,
-	.io_resource	= &sh7751_io_resource,
 	.io_offset	= 0x00000000,
 	.io_map_base	= SH7751_PCI_IO_BASE,
 };
@@ -128,13 +128,13 @@ static int __init sh7751_pci_init(void)
 	/* Set the local 16MB PCI memory space window to
 	 * the lowest PCI mapped address
 	 */
-	word = chan->mem_resource->start & SH4_PCIMBR_MASK;
+	word = chan->resources[1].start & SH4_PCIMBR_MASK;
 	pr_debug("PCI: Setting upper bits of Memory window to 0x%x\n", word);
 	pci_write_reg(chan, word , SH4_PCIMBR);
 
 	/* Make sure the MSB's of IO window are set to access PCI space
 	 * correctly */
-	word = chan->io_resource->start & SH4_PCIIOBR_MASK;
+	word = chan->resources[0].start & SH4_PCIIOBR_MASK;
 	pr_debug("PCI: Setting upper bits of IO window to 0x%x\n", word);
 	pci_write_reg(chan, word, SH4_PCIIOBR);
 

commit bcf39352eb9e9026f7a1028d4bce3707b65f104b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Feb 1 13:11:25 2010 +0900

    sh: Handle PCI controller resource conflicts.
    
    register_pci_controller() can fail, but presently is a void function.
    Change this over to an int so that we can bail early before continuing on
    with post-registration initialization (such as throwing the controller in
    to 66MHz mode in the case of the SH7780 host controller).
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index 02306ddb4011..6ad5beb524aa 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -176,8 +176,6 @@ static int __init sh7751_pci_init(void)
 	word = SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_ARBM;
 	pci_write_reg(chan, word, SH4_PCICR);
 
-	register_pci_controller(chan);
-
-	return 0;
+	return register_pci_controller(chan);
 }
 arch_initcall(sh7751_pci_init);

commit 396c56a9c69ebb0baf9171a6365ac9fda322728d
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sat Jan 30 01:41:21 2010 +0900

    sh: Kill off broken type 1 PCI config access checks.
    
    The host controllers only support type 1, so there's not much else to
    test for. Some of the older controllers also supported type 2 accesses,
    but we've never supported those, and likely never will. Beyond that, the
    P1SEG test is meaningless for 32-bit mode, so rather than refactoring it,
    just kill the type 1 test off completely.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index 2455cf32db5a..02306ddb4011 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -79,7 +79,6 @@ static int __init sh7751_pci_init(void)
 	struct pci_channel *chan = &sh7751_pci_controller;
 	unsigned int id;
 	u32 word, reg;
-	int ret;
 
 	printk(KERN_NOTICE "PCI: Starting intialization.\n");
 
@@ -93,9 +92,6 @@ static int __init sh7751_pci_init(void)
 		return -ENODEV;
 	}
 
-	if ((ret = sh4_pci_check_direct(chan)) != 0)
-		return ret;
-
 	/* Set the BCR's to enable PCI access */
 	reg = __raw_readl(SH7751_BCR1);
 	reg |= 0x80000;

commit 9d56dd3b083a3bec56e9da35ce07baca81030b03
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jan 26 12:58:40 2010 +0900

    sh: Mass ctrl_in/outX to __raw_read/writeX conversion.
    
    The old ctrl in/out routines are non-portable and unsuitable for
    cross-platform use. While drivers/sh has already been sanitized, there
    is still quite a lot of code that is not. This converts the arch/sh/ bits
    over, which permits us to flag the routines as deprecated whilst still
    building with -Werror for the architecture code, and to ensure that
    future users are not added.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index 70c1999a0ec4..2455cf32db5a 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -97,9 +97,9 @@ static int __init sh7751_pci_init(void)
 		return ret;
 
 	/* Set the BCR's to enable PCI access */
-	reg = ctrl_inl(SH7751_BCR1);
+	reg = __raw_readl(SH7751_BCR1);
 	reg |= 0x80000;
-	ctrl_outl(reg, SH7751_BCR1);
+	__raw_writel(reg, SH7751_BCR1);
 
 	/* Turn the clocks back on (not done in reset)*/
 	pci_write_reg(chan, 0, SH4_PCICLKR);
@@ -159,13 +159,13 @@ static int __init sh7751_pci_init(void)
 		return -1;
 
 	/* configure the wait control registers */
-	word = ctrl_inl(SH7751_WCR1);
+	word = __raw_readl(SH7751_WCR1);
 	pci_write_reg(chan, word, SH4_PCIWCR1);
-	word = ctrl_inl(SH7751_WCR2);
+	word = __raw_readl(SH7751_WCR2);
 	pci_write_reg(chan, word, SH4_PCIWCR2);
-	word = ctrl_inl(SH7751_WCR3);
+	word = __raw_readl(SH7751_WCR3);
 	pci_write_reg(chan, word, SH4_PCIWCR3);
-	word = ctrl_inl(SH7751_MCR);
+	word = __raw_readl(SH7751_MCR);
 	pci_write_reg(chan, word, SH4_PCIMCR);
 
 	/* NOTE: I'm ignoring the PCI error IRQs for now..

commit d076d2bd0d9379314df5f2ab8b9c83f617c70923
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 26 23:10:15 2009 +0900

    sh: pci-sh7751: Initialize io_map_base in controller definition.
    
    As there is only a single controller and remapping has no impact for the
    address range in question, just initialize it directly in the controller
    definition. This fixes up boot time warnings about not having the field
    initialized.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index c4fa0bb13976..70c1999a0ec4 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -52,7 +52,7 @@ static struct resource sh7751_io_resource = {
 };
 
 static struct resource sh7751_mem_resource = {
-	.name	= "SH7785_mem",
+	.name	= "SH7751_mem",
 	.start	= SH7751_PCI_MEMORY_BASE,
 	.end	= SH7751_PCI_MEMORY_BASE + SH7751_PCI_MEM_SIZE - 1,
 	.flags	= IORESOURCE_MEM
@@ -64,6 +64,7 @@ static struct pci_channel sh7751_pci_controller = {
 	.mem_offset	= 0x00000000,
 	.io_resource	= &sh7751_io_resource,
 	.io_offset	= 0x00000000,
+	.io_map_base	= SH7751_PCI_IO_BASE,
 };
 
 static struct sh4_pci_address_map sh7751_pci_map = {
@@ -179,8 +180,6 @@ static int __init sh7751_pci_init(void)
 	word = SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_ARBM;
 	pci_write_reg(chan, word, SH4_PCICR);
 
-	__set_io_port_base(SH7751_PCI_IO_BASE);
-
 	register_pci_controller(chan);
 
 	return 0;

commit 757e3c16f8bafa2a470aebf9b04671c5d4d18f49
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Apr 20 21:11:07 2009 +0900

    sh: pci: Rewrite SH7751 PCI support to follow SH7780.
    
    This follows the similar sort of scheme that the refactored SH7780 code
    uses, using a 64MB CS3 mapping to handle the window0 case, and simply
    discarding window1. This vastly simplifies the code, and allows most of
    the board-specific setup to go die.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index 4c08fd7f665d..c4fa0bb13976 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -1,78 +1,41 @@
 /*
- *	Low-Level PCI Support for the SH7751
+ * Low-Level PCI Support for the SH7751
  *
- *  Dustin McIntire (dustin@sensoria.com)
- *	Derived from arch/i386/kernel/pci-*.c which bore the message:
- *	(c) 1999--2000 Martin Mares <mj@ucw.cz>
+ *  Copyright (C) 2003 - 2009  Paul Mundt
+ *  Copyright (C) 2001  Dustin McIntire
  *
- *  Ported to the new API by Paul Mundt <lethal@linux-sh.org>
- *  With cleanup by Paul van Gool <pvangool@mimotech.com>
- *
- *  May be copied or modified under the terms of the GNU General Public
- *  License.  See linux/COPYING for more information.
+ *  With cleanup by Paul van Gool <pvangool@mimotech.com>, 2003.
  *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
  */
-#undef DEBUG
-
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/types.h>
 #include <linux/errno.h>
-#include <linux/delay.h>
+#include <linux/io.h>
 #include "pci-sh4.h"
 #include <asm/addrspace.h>
-#include <asm/io.h>
-
-/*
- * Initialization. Try all known PCI access methods. Note that we support
- * using both PCI BIOS and direct access: in such cases, we use I/O ports
- * to access config space.
- *
- * Note that the platform specific initialization (BSC registers, and memory
- * space mapping) will be called via the platform defined function
- * pcibios_init_platform().
- */
-int __init sh7751_pci_init(struct pci_channel *chan)
-{
-	unsigned int id;
-	int ret;
-
-	pr_debug("PCI: Starting intialization.\n");
-
-	chan->reg_base = 0xfe200000;
-
-	/* check for SH7751/SH7751R hardware */
-	id = pci_read_reg(chan, SH7751_PCICONF0);
-	if (id != ((SH7751_DEVICE_ID << 16) | SH7751_VENDOR_ID) &&
-	    id != ((SH7751R_DEVICE_ID << 16) | SH7751_VENDOR_ID)) {
-		pr_debug("PCI: This is not an SH7751(R) (%x)\n", id);
-		return -ENODEV;
-	}
-
-	if ((ret = sh4_pci_check_direct(chan)) != 0)
-		return ret;
-
-	return pcibios_init_platform();
-}
 
 static int __init __area_sdram_check(struct pci_channel *chan,
 				     unsigned int area)
 {
-	u32 word;
+	unsigned long word;
 
-	word = ctrl_inl(SH7751_BCR1);
+	word = __raw_readl(SH7751_BCR1);
 	/* check BCR for SDRAM in area */
 	if (((word >> area) & 1) == 0) {
-		printk("PCI: Area %d is not configured for SDRAM. BCR1=0x%x\n",
+		printk("PCI: Area %d is not configured for SDRAM. BCR1=0x%lx\n",
 		       area, word);
 		return 0;
 	}
 	pci_write_reg(chan, word, SH4_PCIBCR1);
 
-	word = (u16)ctrl_inw(SH7751_BCR2);
+	word = __raw_readw(SH7751_BCR2);
 	/* check BCR2 for 32bit SDRAM interface*/
 	if (((word >> (area << 1)) & 0x3) != 0x3) {
-		printk("PCI: Area %d is not 32 bit SDRAM. BCR2=0x%x\n",
+		printk("PCI: Area %d is not 32 bit SDRAM. BCR2=0x%lx\n",
 		       area, word);
 		return 0;
 	}
@@ -81,11 +44,56 @@ static int __init __area_sdram_check(struct pci_channel *chan,
 	return 1;
 }
 
-int __init sh7751_pcic_init(struct pci_channel *chan,
-			    struct sh4_pci_address_map *map)
+static struct resource sh7751_io_resource = {
+	.name	= "SH7751_IO",
+	.start	= SH7751_PCI_IO_BASE,
+	.end	= SH7751_PCI_IO_BASE + SH7751_PCI_IO_SIZE - 1,
+	.flags	= IORESOURCE_IO
+};
+
+static struct resource sh7751_mem_resource = {
+	.name	= "SH7785_mem",
+	.start	= SH7751_PCI_MEMORY_BASE,
+	.end	= SH7751_PCI_MEMORY_BASE + SH7751_PCI_MEM_SIZE - 1,
+	.flags	= IORESOURCE_MEM
+};
+
+static struct pci_channel sh7751_pci_controller = {
+	.pci_ops	= &sh4_pci_ops,
+	.mem_resource	= &sh7751_mem_resource,
+	.mem_offset	= 0x00000000,
+	.io_resource	= &sh7751_io_resource,
+	.io_offset	= 0x00000000,
+};
+
+static struct sh4_pci_address_map sh7751_pci_map = {
+	.window0	= {
+		.base	= SH7751_CS3_BASE_ADDR,
+		.size	= 0x04000000,
+	},
+};
+
+static int __init sh7751_pci_init(void)
 {
-	u32 reg;
-	u32 word;
+	struct pci_channel *chan = &sh7751_pci_controller;
+	unsigned int id;
+	u32 word, reg;
+	int ret;
+
+	printk(KERN_NOTICE "PCI: Starting intialization.\n");
+
+	chan->reg_base = 0xfe200000;
+
+	/* check for SH7751/SH7751R hardware */
+	id = pci_read_reg(chan, SH7751_PCICONF0);
+	if (id != ((SH7751_DEVICE_ID << 16) | SH7751_VENDOR_ID) &&
+	    id != ((SH7751R_DEVICE_ID << 16) | SH7751_VENDOR_ID)) {
+		pr_debug("PCI: This is not an SH7751(R) (%x)\n", id);
+		return -ENODEV;
+	}
+
+	if ((ret = sh4_pci_check_direct(chan)) != 0)
+		return ret;
 
 	/* Set the BCR's to enable PCI access */
 	reg = ctrl_inl(SH7751_BCR1);
@@ -112,21 +120,13 @@ int __init sh7751_pcic_init(struct pci_channel *chan,
 
 	/* Set IO and Mem windows to local address
 	 * Make PCI and local address the same for easy 1 to 1 mapping
-	 * Window0 = map->window0.size @ non-cached area base = SDRAM
-	 * Window1 = map->window1.size @ cached area base = SDRAM
 	 */
-	word = map->window0.size - 1;
+	word = sh7751_pci_map.window0.size - 1;
 	pci_write_reg(chan, word, SH4_PCILSR0);
-	word = map->window1.size - 1;
-	pci_write_reg(chan, word, SH4_PCILSR1);
 	/* Set the values on window 0 PCI config registers */
-	word = P2SEGADDR(map->window0.base);
+	word = P2SEGADDR(sh7751_pci_map.window0.base);
 	pci_write_reg(chan, word, SH4_PCILAR0);
 	pci_write_reg(chan, word, SH7751_PCICONF5);
-	/* Set the values on window 1 PCI config registers */
-	word =  PHYSADDR(map->window1.base);
-	pci_write_reg(chan, word, SH4_PCILAR1);
-	pci_write_reg(chan, word, SH7751_PCICONF6);
 
 	/* Set the local 16MB PCI memory space window to
 	 * the lowest PCI mapped address
@@ -144,7 +144,7 @@ int __init sh7751_pcic_init(struct pci_channel *chan,
 	/* Set PCI WCRx, BCRx's, copy from BSC locations */
 
 	/* check BCR for SDRAM in specified area */
-	switch (map->window0.base) {
+	switch (sh7751_pci_map.window0.base) {
 	case SH7751_CS0_BASE_ADDR: word = __area_sdram_check(chan, 0); break;
 	case SH7751_CS1_BASE_ADDR: word = __area_sdram_check(chan, 1); break;
 	case SH7751_CS2_BASE_ADDR: word = __area_sdram_check(chan, 2); break;
@@ -179,5 +179,10 @@ int __init sh7751_pcic_init(struct pci_channel *chan,
 	word = SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_ARBM;
 	pci_write_reg(chan, word, SH4_PCICR);
 
+	__set_io_port_base(SH7751_PCI_IO_BASE);
+
+	register_pci_controller(chan);
+
 	return 0;
 }
+arch_initcall(sh7751_pci_init);

commit 5ba7205fc49ff72e88784c94fb661f93e7ae7d36
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Apr 20 19:00:32 2009 +0900

    sh: pci: Kill off the now unused hose->io_base.
    
    Nothing is using this any more, so kill it off.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index af8874436d2f..4c08fd7f665d 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -40,7 +40,6 @@ int __init sh7751_pci_init(struct pci_channel *chan)
 	pr_debug("PCI: Starting intialization.\n");
 
 	chan->reg_base = 0xfe200000;
-	chan->io_base = 0xfe240000;
 
 	/* check for SH7751/SH7751R hardware */
 	id = pci_read_reg(chan, SH7751_PCICONF0);
@@ -136,13 +135,6 @@ int __init sh7751_pcic_init(struct pci_channel *chan,
 	pr_debug("PCI: Setting upper bits of Memory window to 0x%x\n", word);
 	pci_write_reg(chan, word , SH4_PCIMBR);
 
-	/* Map IO space into PCI IO window:
-	 * IO addresses will be translated to the PCI IO window base address
-	 */
-	pr_debug("PCI: Mapping IO address 0x%x - 0x%x to base 0x%lx\n",
-		 chan->io_resource->start, chan->io_resource->end,
-		 chan->io_base + chan->io_resource->start);
-
 	/* Make sure the MSB's of IO window are set to access PCI space
 	 * correctly */
 	word = chan->io_resource->start & SH4_PCIIOBR_MASK;

commit 0232ba9ce031d0fd8f331fa8b3c00e16901f54e6
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Apr 16 18:01:31 2009 +0900

    sh: pci: Kill off unused SH4_PCIC_NO_RESET code.
    
    Nothing ended up using this anymore, so just kill it off.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index 2a6c7aab2d75..af8874436d2f 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -99,21 +99,6 @@ int __init sh7751_pcic_init(struct pci_channel *chan,
 	word = SH4_PCIPINT_D3 | SH4_PCIPINT_D0;
 	pci_write_reg(chan, word, SH4_PCIPINT);
 
-	/*
-	 * This code is unused for some boards as it is done in the
-	 * bootloader and doing it here means the MAC addresses loaded
-	 * by the bootloader get lost.
-	 */
-	if (!(map->flags & SH4_PCIC_NO_RESET)) {
-		/* toggle PCI reset pin */
-		word = SH4_PCICR_PREFIX | SH4_PCICR_PRST;
-		pci_write_reg(chan, word, SH4_PCICR);
-		/* Wait for a long time... not 1 sec. but long enough */
-		mdelay(100);
-		word = SH4_PCICR_PREFIX;
-		pci_write_reg(chan, word, SH4_PCICR);
-	}
-
 	/* set the command/status bits to:
 	 * Wait Cycle Control + Parity Enable + Bus Master +
 	 * Mem space enable

commit ef53fdeb7e0cb139aff33665635b886700137abb
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Tue Feb 19 21:35:14 2008 +0900

    sh: add io_base member to pci_channel
    
    Store the io window base address in struct pci_channel and use that one
    instead of SH77xx_PCI_IO_BASE.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index 201266b020f3..2a6c7aab2d75 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -40,6 +40,7 @@ int __init sh7751_pci_init(struct pci_channel *chan)
 	pr_debug("PCI: Starting intialization.\n");
 
 	chan->reg_base = 0xfe200000;
+	chan->io_base = 0xfe240000;
 
 	/* check for SH7751/SH7751R hardware */
 	id = pci_read_reg(chan, SH7751_PCICONF0);
@@ -153,9 +154,9 @@ int __init sh7751_pcic_init(struct pci_channel *chan,
 	/* Map IO space into PCI IO window:
 	 * IO addresses will be translated to the PCI IO window base address
 	 */
-	pr_debug("PCI: Mapping IO address 0x%x - 0x%x to base 0x%x\n",
+	pr_debug("PCI: Mapping IO address 0x%x - 0x%x to base 0x%lx\n",
 		 chan->io_resource->start, chan->io_resource->end,
-		 SH7751_PCI_IO_BASE + chan->io_resource->start);
+		 chan->io_base + chan->io_resource->start);
 
 	/* Make sure the MSB's of IO window are set to access PCI space
 	 * correctly */

commit e4c6a3604e07185046e2ce4be82a201f4447d788
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Tue Feb 19 21:35:04 2008 +0900

    sh: add reg_base member to pci_channel
    
    Store the base address of the pci host controller registers in struct
    pci_channel and use the address in pci_read_reg() and pci_write_reg().
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index 447234c69ab1..201266b020f3 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -39,6 +39,8 @@ int __init sh7751_pci_init(struct pci_channel *chan)
 
 	pr_debug("PCI: Starting intialization.\n");
 
+	chan->reg_base = 0xfe200000;
+
 	/* check for SH7751/SH7751R hardware */
 	id = pci_read_reg(chan, SH7751_PCICONF0);
 	if (id != ((SH7751_DEVICE_ID << 16) | SH7751_VENDOR_ID) &&

commit 710fa3c81151948ac4d836ef52b57cef91b0ab72
Author: Magnus Damm <damm@igel.co.jp>
Date:   Wed Mar 11 15:47:23 2009 +0900

    sh: avoid using PCIBIOS_MIN_xxx
    
    Replaces PCIBIOS_MIN_IO and PCIBIOS_MIN_MEM with direct struct
    pci_channel access. This allows us to have more than one pci
    channel.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index 230db8bd9744..447234c69ab1 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -144,22 +144,20 @@ int __init sh7751_pcic_init(struct pci_channel *chan,
 	/* Set the local 16MB PCI memory space window to
 	 * the lowest PCI mapped address
 	 */
-	word = PCIBIOS_MIN_MEM & SH4_PCIMBR_MASK;
+	word = chan->mem_resource->start & SH4_PCIMBR_MASK;
 	pr_debug("PCI: Setting upper bits of Memory window to 0x%x\n", word);
 	pci_write_reg(chan, word , SH4_PCIMBR);
 
-	/* Map IO space into PCI IO window
-	 * The IO window is 64K-PCIBIOS_MIN_IO in size
-	 * IO addresses will be translated to the
-	 * PCI IO window base address
+	/* Map IO space into PCI IO window:
+	 * IO addresses will be translated to the PCI IO window base address
 	 */
 	pr_debug("PCI: Mapping IO address 0x%x - 0x%x to base 0x%x\n",
-		 PCIBIOS_MIN_IO, (64 << 10),
-		 SH7751_PCI_IO_BASE + PCIBIOS_MIN_IO);
+		 chan->io_resource->start, chan->io_resource->end,
+		 SH7751_PCI_IO_BASE + chan->io_resource->start);
 
 	/* Make sure the MSB's of IO window are set to access PCI space
 	 * correctly */
-	word = PCIBIOS_MIN_IO & SH4_PCIIOBR_MASK;
+	word = chan->io_resource->start & SH4_PCIIOBR_MASK;
 	pr_debug("PCI: Setting upper bits of IO window to 0x%x\n", word);
 	pci_write_reg(chan, word, SH4_PCIIOBR);
 

commit d0e3db40e2a1352aa2a2f425a7d4631bddc03d51
Author: Magnus Damm <damm@igel.co.jp>
Date:   Wed Mar 11 15:46:14 2009 +0900

    sh: add init member to pci_channel data
    
    This patch adds an init callback to struct pci_channel and makes sure
    it is initialized properly. Code is added to call this init function
    from pcibios_init(). Return values are adjusted and a warning is is
    printed if init fails.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index 9c2c01490d62..230db8bd9744 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -32,7 +32,7 @@
  * space mapping) will be called via the platform defined function
  * pcibios_init_platform().
  */
-static int __init sh7751_pci_init(void)
+int __init sh7751_pci_init(struct pci_channel *chan)
 {
 	unsigned int id;
 	int ret;
@@ -40,19 +40,18 @@ static int __init sh7751_pci_init(void)
 	pr_debug("PCI: Starting intialization.\n");
 
 	/* check for SH7751/SH7751R hardware */
-	id = pci_read_reg(NULL, SH7751_PCICONF0);
+	id = pci_read_reg(chan, SH7751_PCICONF0);
 	if (id != ((SH7751_DEVICE_ID << 16) | SH7751_VENDOR_ID) &&
 	    id != ((SH7751R_DEVICE_ID << 16) | SH7751_VENDOR_ID)) {
 		pr_debug("PCI: This is not an SH7751(R) (%x)\n", id);
 		return -ENODEV;
 	}
 
-	if ((ret = sh4_pci_check_direct(NULL)) != 0)
+	if ((ret = sh4_pci_check_direct(chan)) != 0)
 		return ret;
 
 	return pcibios_init_platform();
 }
-subsys_initcall(sh7751_pci_init);
 
 static int __init __area_sdram_check(struct pci_channel *chan,
 				     unsigned int area)
@@ -178,7 +177,7 @@ int __init sh7751_pcic_init(struct pci_channel *chan,
 	}
 
 	if (!word)
-		return 0;
+		return -1;
 
 	/* configure the wait control registers */
 	word = ctrl_inl(SH7751_WCR1);
@@ -202,5 +201,5 @@ int __init sh7751_pcic_init(struct pci_channel *chan,
 	word = SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_ARBM;
 	pci_write_reg(chan, word, SH4_PCICR);
 
-	return 1;
+	return 0;
 }

commit b8b47bfbe4eb1ae0e6891e49c86a5f4fb00413be
Author: Magnus Damm <damm@igel.co.jp>
Date:   Wed Mar 11 15:41:51 2009 +0900

    sh: pass along struct pci_channel
    
    These patches rework the pci code for the sh architecture.
    
    Currently each board implements some kind of ioport to address mapping.
    Some boards use generic_io_base others try passing addresses as io ports.
    This is the first set of patches that try to unify the pci code as much
    as possible to avoid duplicated code. This will in the end lead to fewer
    lines board specific code and more generic code.
    
    This patch makes sure a struct pci_channel pointer is passed along to
    various pci functions such as pci_read_reg(), pci_write_reg(),
    pci_fixup_pcic(), sh7751_pcic_init() and sh7780_pcic_init().
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index 3065eb184f01..9c2c01490d62 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -40,21 +40,22 @@ static int __init sh7751_pci_init(void)
 	pr_debug("PCI: Starting intialization.\n");
 
 	/* check for SH7751/SH7751R hardware */
-	id = pci_read_reg(SH7751_PCICONF0);
+	id = pci_read_reg(NULL, SH7751_PCICONF0);
 	if (id != ((SH7751_DEVICE_ID << 16) | SH7751_VENDOR_ID) &&
 	    id != ((SH7751R_DEVICE_ID << 16) | SH7751_VENDOR_ID)) {
 		pr_debug("PCI: This is not an SH7751(R) (%x)\n", id);
 		return -ENODEV;
 	}
 
-	if ((ret = sh4_pci_check_direct()) != 0)
+	if ((ret = sh4_pci_check_direct(NULL)) != 0)
 		return ret;
 
 	return pcibios_init_platform();
 }
 subsys_initcall(sh7751_pci_init);
 
-static int __init __area_sdram_check(unsigned int area)
+static int __init __area_sdram_check(struct pci_channel *chan,
+				     unsigned int area)
 {
 	u32 word;
 
@@ -65,7 +66,7 @@ static int __init __area_sdram_check(unsigned int area)
 		       area, word);
 		return 0;
 	}
-	pci_write_reg(word, SH4_PCIBCR1);
+	pci_write_reg(chan, word, SH4_PCIBCR1);
 
 	word = (u16)ctrl_inw(SH7751_BCR2);
 	/* check BCR2 for 32bit SDRAM interface*/
@@ -74,12 +75,13 @@ static int __init __area_sdram_check(unsigned int area)
 		       area, word);
 		return 0;
 	}
-	pci_write_reg(word, SH4_PCIBCR2);
+	pci_write_reg(chan, word, SH4_PCIBCR2);
 
 	return 1;
 }
 
-int __init sh7751_pcic_init(struct sh4_pci_address_map *map)
+int __init sh7751_pcic_init(struct pci_channel *chan,
+			    struct sh4_pci_address_map *map)
 {
 	u32 reg;
 	u32 word;
@@ -90,10 +92,10 @@ int __init sh7751_pcic_init(struct sh4_pci_address_map *map)
 	ctrl_outl(reg, SH7751_BCR1);
 
 	/* Turn the clocks back on (not done in reset)*/
-	pci_write_reg(0, SH4_PCICLKR);
+	pci_write_reg(chan, 0, SH4_PCICLKR);
 	/* Clear Powerdown IRQ's (not done in reset) */
 	word = SH4_PCIPINT_D3 | SH4_PCIPINT_D0;
-	pci_write_reg(word, SH4_PCIPINT);
+	pci_write_reg(chan, word, SH4_PCIPINT);
 
 	/*
 	 * This code is unused for some boards as it is done in the
@@ -103,11 +105,11 @@ int __init sh7751_pcic_init(struct sh4_pci_address_map *map)
 	if (!(map->flags & SH4_PCIC_NO_RESET)) {
 		/* toggle PCI reset pin */
 		word = SH4_PCICR_PREFIX | SH4_PCICR_PRST;
-		pci_write_reg(word, SH4_PCICR);
+		pci_write_reg(chan, word, SH4_PCICR);
 		/* Wait for a long time... not 1 sec. but long enough */
 		mdelay(100);
 		word = SH4_PCICR_PREFIX;
-		pci_write_reg(word, SH4_PCICR);
+		pci_write_reg(chan, word, SH4_PCICR);
 	}
 
 	/* set the command/status bits to:
@@ -116,11 +118,11 @@ int __init sh7751_pcic_init(struct sh4_pci_address_map *map)
 	 */
 	word = SH7751_PCICONF1_WCC | SH7751_PCICONF1_PER |
 	       SH7751_PCICONF1_BUM | SH7751_PCICONF1_MES;
-	pci_write_reg(word, SH7751_PCICONF1);
+	pci_write_reg(chan, word, SH7751_PCICONF1);
 
 	/* define this host as the host bridge */
 	word = PCI_BASE_CLASS_BRIDGE << 24;
-	pci_write_reg(word, SH7751_PCICONF2);
+	pci_write_reg(chan, word, SH7751_PCICONF2);
 
 	/* Set IO and Mem windows to local address
 	 * Make PCI and local address the same for easy 1 to 1 mapping
@@ -128,24 +130,24 @@ int __init sh7751_pcic_init(struct sh4_pci_address_map *map)
 	 * Window1 = map->window1.size @ cached area base = SDRAM
 	 */
 	word = map->window0.size - 1;
-	pci_write_reg(word, SH4_PCILSR0);
+	pci_write_reg(chan, word, SH4_PCILSR0);
 	word = map->window1.size - 1;
-	pci_write_reg(word, SH4_PCILSR1);
+	pci_write_reg(chan, word, SH4_PCILSR1);
 	/* Set the values on window 0 PCI config registers */
 	word = P2SEGADDR(map->window0.base);
-	pci_write_reg(word, SH4_PCILAR0);
-	pci_write_reg(word, SH7751_PCICONF5);
+	pci_write_reg(chan, word, SH4_PCILAR0);
+	pci_write_reg(chan, word, SH7751_PCICONF5);
 	/* Set the values on window 1 PCI config registers */
 	word =  PHYSADDR(map->window1.base);
-	pci_write_reg(word, SH4_PCILAR1);
-	pci_write_reg(word, SH7751_PCICONF6);
+	pci_write_reg(chan, word, SH4_PCILAR1);
+	pci_write_reg(chan, word, SH7751_PCICONF6);
 
 	/* Set the local 16MB PCI memory space window to
 	 * the lowest PCI mapped address
 	 */
 	word = PCIBIOS_MIN_MEM & SH4_PCIMBR_MASK;
 	pr_debug("PCI: Setting upper bits of Memory window to 0x%x\n", word);
-	pci_write_reg(word , SH4_PCIMBR);
+	pci_write_reg(chan, word , SH4_PCIMBR);
 
 	/* Map IO space into PCI IO window
 	 * The IO window is 64K-PCIBIOS_MIN_IO in size
@@ -160,19 +162,19 @@ int __init sh7751_pcic_init(struct sh4_pci_address_map *map)
 	 * correctly */
 	word = PCIBIOS_MIN_IO & SH4_PCIIOBR_MASK;
 	pr_debug("PCI: Setting upper bits of IO window to 0x%x\n", word);
-	pci_write_reg(word, SH4_PCIIOBR);
+	pci_write_reg(chan, word, SH4_PCIIOBR);
 
 	/* Set PCI WCRx, BCRx's, copy from BSC locations */
 
 	/* check BCR for SDRAM in specified area */
 	switch (map->window0.base) {
-	case SH7751_CS0_BASE_ADDR: word = __area_sdram_check(0); break;
-	case SH7751_CS1_BASE_ADDR: word = __area_sdram_check(1); break;
-	case SH7751_CS2_BASE_ADDR: word = __area_sdram_check(2); break;
-	case SH7751_CS3_BASE_ADDR: word = __area_sdram_check(3); break;
-	case SH7751_CS4_BASE_ADDR: word = __area_sdram_check(4); break;
-	case SH7751_CS5_BASE_ADDR: word = __area_sdram_check(5); break;
-	case SH7751_CS6_BASE_ADDR: word = __area_sdram_check(6); break;
+	case SH7751_CS0_BASE_ADDR: word = __area_sdram_check(chan, 0); break;
+	case SH7751_CS1_BASE_ADDR: word = __area_sdram_check(chan, 1); break;
+	case SH7751_CS2_BASE_ADDR: word = __area_sdram_check(chan, 2); break;
+	case SH7751_CS3_BASE_ADDR: word = __area_sdram_check(chan, 3); break;
+	case SH7751_CS4_BASE_ADDR: word = __area_sdram_check(chan, 4); break;
+	case SH7751_CS5_BASE_ADDR: word = __area_sdram_check(chan, 5); break;
+	case SH7751_CS6_BASE_ADDR: word = __area_sdram_check(chan, 6); break;
 	}
 
 	if (!word)
@@ -180,25 +182,25 @@ int __init sh7751_pcic_init(struct sh4_pci_address_map *map)
 
 	/* configure the wait control registers */
 	word = ctrl_inl(SH7751_WCR1);
-	pci_write_reg(word, SH4_PCIWCR1);
+	pci_write_reg(chan, word, SH4_PCIWCR1);
 	word = ctrl_inl(SH7751_WCR2);
-	pci_write_reg(word, SH4_PCIWCR2);
+	pci_write_reg(chan, word, SH4_PCIWCR2);
 	word = ctrl_inl(SH7751_WCR3);
-	pci_write_reg(word, SH4_PCIWCR3);
+	pci_write_reg(chan, word, SH4_PCIWCR3);
 	word = ctrl_inl(SH7751_MCR);
-	pci_write_reg(word, SH4_PCIMCR);
+	pci_write_reg(chan, word, SH4_PCIMCR);
 
 	/* NOTE: I'm ignoring the PCI error IRQs for now..
 	 * TODO: add support for the internal error interrupts and
 	 * DMA interrupts...
 	 */
 
-	pci_fixup_pcic();
+	pci_fixup_pcic(chan);
 
 	/* SH7751 init done, set central function init complete */
 	/* use round robin mode to stop a device starving/overruning */
 	word = SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_ARBM;
-	pci_write_reg(word, SH4_PCICR);
+	pci_write_reg(chan, word, SH4_PCICR);
 
 	return 1;
 }

commit e036eaa681a17f71b64f6d9040fe605555623919
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Thu Feb 14 13:52:43 2008 +0900

    sh: use ctrl_in/out for on chip pci access
    
    This patch makes sure ctrl_inN/outN are used instead of inN/outN for on chip
    pci registers. Without this patch addresses may be adjusted using the value
    in generic_io_base. This patch makes it possible to set generic_io_base and
    have pci without reading and writing all over the place.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Acked-by: Katsuya MATSUBARA <matsu@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index 1aca7fe5783b..3065eb184f01 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -58,7 +58,7 @@ static int __init __area_sdram_check(unsigned int area)
 {
 	u32 word;
 
-	word = inl(SH7751_BCR1);
+	word = ctrl_inl(SH7751_BCR1);
 	/* check BCR for SDRAM in area */
 	if (((word >> area) & 1) == 0) {
 		printk("PCI: Area %d is not configured for SDRAM. BCR1=0x%x\n",
@@ -67,7 +67,7 @@ static int __init __area_sdram_check(unsigned int area)
 	}
 	pci_write_reg(word, SH4_PCIBCR1);
 
-	word = (u16)inw(SH7751_BCR2);
+	word = (u16)ctrl_inw(SH7751_BCR2);
 	/* check BCR2 for 32bit SDRAM interface*/
 	if (((word >> (area << 1)) & 0x3) != 0x3) {
 		printk("PCI: Area %d is not 32 bit SDRAM. BCR2=0x%x\n",
@@ -85,9 +85,9 @@ int __init sh7751_pcic_init(struct sh4_pci_address_map *map)
 	u32 word;
 
 	/* Set the BCR's to enable PCI access */
-	reg = inl(SH7751_BCR1);
+	reg = ctrl_inl(SH7751_BCR1);
 	reg |= 0x80000;
-	outl(reg, SH7751_BCR1);
+	ctrl_outl(reg, SH7751_BCR1);
 
 	/* Turn the clocks back on (not done in reset)*/
 	pci_write_reg(0, SH4_PCICLKR);
@@ -179,13 +179,13 @@ int __init sh7751_pcic_init(struct sh4_pci_address_map *map)
 		return 0;
 
 	/* configure the wait control registers */
-	word = inl(SH7751_WCR1);
+	word = ctrl_inl(SH7751_WCR1);
 	pci_write_reg(word, SH4_PCIWCR1);
-	word = inl(SH7751_WCR2);
+	word = ctrl_inl(SH7751_WCR2);
 	pci_write_reg(word, SH4_PCIWCR2);
-	word = inl(SH7751_WCR3);
+	word = ctrl_inl(SH7751_WCR3);
 	pci_write_reg(word, SH4_PCIWCR3);
-	word = inl(SH7751_MCR);
+	word = ctrl_inl(SH7751_MCR);
 	pci_write_reg(word, SH4_PCIMCR);
 
 	/* NOTE: I'm ignoring the PCI error IRQs for now..

commit cd6c7ea234dc8a8607283e056d8010b2bd3c6369
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Mar 29 00:04:39 2007 +0900

    sh: Add a dummy SH-4 PCIC fixup.
    
    By default we don't have anything to fix up for the SH-4 PCIC, boards can
    overload this as necessary.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index f3ead58a9519..1aca7fe5783b 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -12,7 +12,6 @@
  *  License.  See linux/COPYING for more information.
  *
  */
-
 #undef DEBUG
 
 #include <linux/init.h>
@@ -28,7 +27,7 @@
  * Initialization. Try all known PCI access methods. Note that we support
  * using both PCI BIOS and direct access: in such cases, we use I/O ports
  * to access config space.
- * 
+ *
  * Note that the platform specific initialization (BSC registers, and memory
  * space mapping) will be called via the platform defined function
  * pcibios_init_platform().
@@ -115,7 +114,7 @@ int __init sh7751_pcic_init(struct sh4_pci_address_map *map)
 	 * Wait Cycle Control + Parity Enable + Bus Master +
 	 * Mem space enable
 	 */
-	word = SH7751_PCICONF1_WCC | SH7751_PCICONF1_PER | 
+	word = SH7751_PCICONF1_WCC | SH7751_PCICONF1_PER |
 	       SH7751_PCICONF1_BUM | SH7751_PCICONF1_MES;
 	pci_write_reg(word, SH7751_PCICONF1);
 
@@ -123,10 +122,10 @@ int __init sh7751_pcic_init(struct sh4_pci_address_map *map)
 	word = PCI_BASE_CLASS_BRIDGE << 24;
 	pci_write_reg(word, SH7751_PCICONF2);
 
-	/* Set IO and Mem windows to local address 
-	 * Make PCI and local address the same for easy 1 to 1 mapping 
+	/* Set IO and Mem windows to local address
+	 * Make PCI and local address the same for easy 1 to 1 mapping
 	 * Window0 = map->window0.size @ non-cached area base = SDRAM
-	 * Window1 = map->window1.size @ cached area base = SDRAM 
+	 * Window1 = map->window1.size @ cached area base = SDRAM
 	 */
 	word = map->window0.size - 1;
 	pci_write_reg(word, SH4_PCILSR0);
@@ -175,7 +174,7 @@ int __init sh7751_pcic_init(struct sh4_pci_address_map *map)
 	case SH7751_CS5_BASE_ADDR: word = __area_sdram_check(5); break;
 	case SH7751_CS6_BASE_ADDR: word = __area_sdram_check(6); break;
 	}
-	
+
 	if (!word)
 		return 0;
 
@@ -194,9 +193,7 @@ int __init sh7751_pcic_init(struct sh4_pci_address_map *map)
 	 * DMA interrupts...
 	 */
 
-#if defined(CONFIG_SH_RTS7751R2D) || defined(CONFIG_SH_LBOX_RE2)
 	pci_fixup_pcic();
-#endif
 
 	/* SH7751 init done, set central function init complete */
 	/* use round robin mode to stop a device starving/overruning */

commit c86c5a910451dd5a30e62a9e36d8e9b3c7a0c1d1
Author: Nobuhiro Iwamatsu <iwamatsu@nigauri.org>
Date:   Mon Mar 26 14:27:43 2007 +0900

    sh: L-BOX RE2 support.
    
    This adds support for the L-BOX RE2 router.
    
            http://www.nttcom.co.jp/l-box/
    
    L-BOX RE2 is a SH7751R-based router. It has CF, Cardbus, serial,
    and LAN x2. This is one of the very few SH boards that a general
    person can obtain now.
    
    The L-BOX shipped with a 2.4.28 kernel, this is a rewritten patch
    adding it to current git.
    
    Signed-off-by: Nobuhiro Iwamatsu <iwamatsu@nigauri.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index 9ddff760d3c6..f3ead58a9519 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -194,7 +194,7 @@ int __init sh7751_pcic_init(struct sh4_pci_address_map *map)
 	 * DMA interrupts...
 	 */
 
-#ifdef CONFIG_SH_RTS7751R2D
+#if defined(CONFIG_SH_RTS7751R2D) || defined(CONFIG_SH_LBOX_RE2)
 	pci_fixup_pcic();
 #endif
 

commit e65fa9f59e9230b72ac298d445b4a18a4eefeb34
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Feb 14 15:06:09 2007 +0900

    sh: Kill off dead bigsur and ec3104 boards.
    
    Neither of these have had any maintenance in years, and there's
    no interest in keeping them straggling along. These have already
    been slated for removal some time, so finally just get rid of them.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index 85e1ee2e2e7b..9ddff760d3c6 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -157,15 +157,6 @@ int __init sh7751_pcic_init(struct sh4_pci_address_map *map)
 		 PCIBIOS_MIN_IO, (64 << 10),
 		 SH7751_PCI_IO_BASE + PCIBIOS_MIN_IO);
 
-	/*
-	 * XXX: For now, leave this board-specific. In the event we have other
-	 * boards that need to do similar work, this can be wrapped.
-	 */
-#ifdef CONFIG_SH_BIGSUR
-	bigsur_port_map(PCIBIOS_MIN_IO, (64 << 10),
-			SH7751_PCI_IO_BASE + PCIBIOS_MIN_IO, 0);
-#endif
-
 	/* Make sure the MSB's of IO window are set to access PCI space
 	 * correctly */
 	word = PCIBIOS_MIN_IO & SH4_PCIIOBR_MASK;

commit 580410005daecd8e9f0e1baa9ddadbb7f706e7e2
Author: Jamie Lenehan <lenehan@twibble.org>
Date:   Fri Oct 6 15:36:15 2006 +0900

    sh: Fix pr_debug statements for sh4
    
    Fix a problem uncovered by the recent change to always check the
    arguments to pr_debug. The sh7751 was using the wrong name for the
    PCI IO base address.
    
    Signed-off-by: Jamie Lenehan <lenehan@twibble.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index dbe837884983..85e1ee2e2e7b 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -155,7 +155,7 @@ int __init sh7751_pcic_init(struct sh4_pci_address_map *map)
 	 */
 	pr_debug("PCI: Mapping IO address 0x%x - 0x%x to base 0x%x\n",
 		 PCIBIOS_MIN_IO, (64 << 10),
-		 SH4_PCI_IO_BASE + PCIBIOS_MIN_IO);
+		 SH7751_PCI_IO_BASE + PCIBIOS_MIN_IO);
 
 	/*
 	 * XXX: For now, leave this board-specific. In the event we have other
@@ -163,7 +163,7 @@ int __init sh7751_pcic_init(struct sh4_pci_address_map *map)
 	 */
 #ifdef CONFIG_SH_BIGSUR
 	bigsur_port_map(PCIBIOS_MIN_IO, (64 << 10),
-			SH4_PCI_IO_BASE + PCIBIOS_MIN_IO, 0);
+			SH7751_PCI_IO_BASE + PCIBIOS_MIN_IO, 0);
 #endif
 
 	/* Make sure the MSB's of IO window are set to access PCI space

commit 959f85f8a3223c116bbe95dd8a9b207790b5d4d3
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 16:43:28 2006 +0900

    sh: Consolidated SH7751/SH7780 PCI support.
    
    This cleans up quite a lot of the PCI mess that we
    currently have, and attempts to consolidate the
    duplication in the SH7780 and SH7751 PCI controllers.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index 65093ec1b55e..dbe837884983 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -15,180 +15,14 @@
 
 #undef DEBUG
 
-#include <linux/types.h>
-#include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/pci.h>
-#include <linux/sched.h>
-#include <linux/ioport.h>
+#include <linux/types.h>
 #include <linux/errno.h>
-#include <linux/irq.h>
 #include <linux/delay.h>
-
-#include <asm/machvec.h>
+#include "pci-sh4.h"
+#include <asm/addrspace.h>
 #include <asm/io.h>
-#include "pci-sh7751.h"
-
-static unsigned int pci_probe = PCI_PROBE_CONF1;
-extern int pci_fixup_pcic(void);
-
-void pcibios_fixup_irqs(void) __attribute__ ((weak));
-
-/*
- * Direct access to PCI hardware...
- */
-
-#define CONFIG_CMD(bus, devfn, where) (0x80000000 | (bus->number << 16) | (devfn << 8) | (where & ~3))
-
-/*
- * Functions for accessing PCI configuration space with type 1 accesses
- */
-static int sh7751_pci_read(struct pci_bus *bus, unsigned int devfn,
-			   int where, int size, u32 *val)
-{
-	unsigned long flags;
-	u32 data;
-
-	/* 
-	 * PCIPDR may only be accessed as 32 bit words, 
-	 * so we must do byte alignment by hand 
-	 */
-	local_irq_save(flags);
-	outl(CONFIG_CMD(bus,devfn,where), PCI_REG(SH7751_PCIPAR));
-	data = inl(PCI_REG(SH7751_PCIPDR));
-	local_irq_restore(flags);
-
-	switch (size) {
-	case 1:
-		*val = (data >> ((where & 3) << 3)) & 0xff;
-		break;
-	case 2:
-		*val = (data >> ((where & 2) << 3)) & 0xffff;
-		break;
-	case 4:
-		*val = data;
-		break;
-	default:
-		return PCIBIOS_FUNC_NOT_SUPPORTED;
-	}
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-/* 
- * Since SH7751 only does 32bit access we'll have to do a read,
- * mask,write operation.
- * We'll allow an odd byte offset, though it should be illegal.
- */ 
-static int sh7751_pci_write(struct pci_bus *bus, unsigned int devfn,
-			    int where, int size, u32 val)
-{
-	unsigned long flags;
-	int shift;
-	u32 data;
-
-	local_irq_save(flags);
-	outl(CONFIG_CMD(bus,devfn,where), PCI_REG(SH7751_PCIPAR));
-	data = inl(PCI_REG(SH7751_PCIPDR));
-	local_irq_restore(flags);
-
-	switch (size) {
-	case 1:
-		shift = (where & 3) << 3;
-		data &= ~(0xff << shift);
-		data |= ((val & 0xff) << shift);
-		break;
-	case 2:
-		shift = (where & 2) << 3;
-		data &= ~(0xffff << shift);
-		data |= ((val & 0xffff) << shift);
-		break;
-	case 4:
-		data = val;
-		break;
-	default:
-		return PCIBIOS_FUNC_NOT_SUPPORTED;
-	}
-
-	outl(data, PCI_REG(SH7751_PCIPDR));
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-#undef CONFIG_CMD
-
-struct pci_ops sh7751_pci_ops = {
-	.read 		= sh7751_pci_read,
-	.write		= sh7751_pci_write,
-};
-
-static int __init pci_check_direct(void)
-{
-	unsigned int tmp, id;
-
-	/* check for SH7751/SH7751R hardware */
-	id = inl(SH7751_PCIREG_BASE+SH7751_PCICONF0);
-	if (id != ((SH7751_DEVICE_ID << 16) | SH7751_VENDOR_ID) &&
-	    id != ((SH7751R_DEVICE_ID << 16) | SH7751_VENDOR_ID)) {
-		pr_debug("PCI: This is not an SH7751(R) (%x)\n", id);
-		return -ENODEV;
-	}
-
-	/*
-	 * Check if configuration works.
-	 */
-	if (pci_probe & PCI_PROBE_CONF1) {
-		tmp = inl (PCI_REG(SH7751_PCIPAR));
-		outl (0x80000000, PCI_REG(SH7751_PCIPAR));
-		if (inl (PCI_REG(SH7751_PCIPAR)) == 0x80000000) {
-			outl (tmp, PCI_REG(SH7751_PCIPAR));
-			printk(KERN_INFO "PCI: Using configuration type 1\n");
-			request_region(PCI_REG(SH7751_PCIPAR), 8, "PCI conf1");
-			return 0;
-		}
-		outl (tmp, PCI_REG(SH7751_PCIPAR));
-	}
-
-	pr_debug("PCI: pci_check_direct failed\n");
-	return -EINVAL;
-}
-
-/***************************************************************************************/
-
-/*
- *  Handle bus scanning and fixups ....
- */
-
-static void __init pci_fixup_ide_bases(struct pci_dev *d)
-{
-	int i;
-
-	/*
-	 * PCI IDE controllers use non-standard I/O port decoding, respect it.
-	 */
-	if ((d->class >> 8) != PCI_CLASS_STORAGE_IDE)
-		return;
-	pr_debug("PCI: IDE base address fixup for %s\n", pci_name(d));
-	for(i=0; i<4; i++) {
-		struct resource *r = &d->resource[i];
-		if ((r->start & ~0x80) == 0x374) {
-			r->start |= 2;
-			r->end = r->start;
-		}
-	}
-}
-
-DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, pci_fixup_ide_bases);
-
-/*
- *  Called after each bus is probed, but before its children
- *  are examined.
- */
-
-void __init pcibios_fixup_bus(struct pci_bus *b)
-{
-	pci_read_bridge_bases(b);
-}
 
 /*
  * Initialization. Try all known PCI access methods. Note that we support
@@ -196,25 +30,29 @@ void __init pcibios_fixup_bus(struct pci_bus *b)
  * to access config space.
  * 
  * Note that the platform specific initialization (BSC registers, and memory
- * space mapping) will be called via the machine vectors (sh_mv.mv_pci_init()) if it
- * exitst and via the platform defined function pcibios_init_platform().  
- * See pci_bigsur.c for implementation;
- * 
- * The BIOS version of the pci functions is not yet implemented but it is left
- * in for completeness.  Currently an error will be genereated at compile time. 
+ * space mapping) will be called via the platform defined function
+ * pcibios_init_platform().
  */
-
 static int __init sh7751_pci_init(void)
 {
+	unsigned int id;
 	int ret;
 
 	pr_debug("PCI: Starting intialization.\n");
-	if ((ret = pci_check_direct()) != 0)
+
+	/* check for SH7751/SH7751R hardware */
+	id = pci_read_reg(SH7751_PCICONF0);
+	if (id != ((SH7751_DEVICE_ID << 16) | SH7751_VENDOR_ID) &&
+	    id != ((SH7751R_DEVICE_ID << 16) | SH7751_VENDOR_ID)) {
+		pr_debug("PCI: This is not an SH7751(R) (%x)\n", id);
+		return -ENODEV;
+	}
+
+	if ((ret = sh4_pci_check_direct()) != 0)
 		return ret;
 
 	return pcibios_init_platform();
 }
-
 subsys_initcall(sh7751_pci_init);
 
 static int __init __area_sdram_check(unsigned int area)
@@ -228,7 +66,7 @@ static int __init __area_sdram_check(unsigned int area)
 		       area, word);
 		return 0;
 	}
-	outl(word, PCI_REG(SH7751_PCIBCR1));
+	pci_write_reg(word, SH4_PCIBCR1);
 
 	word = (u16)inw(SH7751_BCR2);
 	/* check BCR2 for 32bit SDRAM interface*/
@@ -237,12 +75,12 @@ static int __init __area_sdram_check(unsigned int area)
 		       area, word);
 		return 0;
 	}
-	outl(word, PCI_REG(SH7751_PCIBCR2));
+	pci_write_reg(word, SH4_PCIBCR2);
 
 	return 1;
 }
 
-int __init sh7751_pcic_init(struct sh7751_pci_address_map *map)
+int __init sh7751_pcic_init(struct sh4_pci_address_map *map)
 {
 	u32 reg;
 	u32 word;
@@ -251,39 +89,39 @@ int __init sh7751_pcic_init(struct sh7751_pci_address_map *map)
 	reg = inl(SH7751_BCR1);
 	reg |= 0x80000;
 	outl(reg, SH7751_BCR1);
-	
+
 	/* Turn the clocks back on (not done in reset)*/
-	outl(0, PCI_REG(SH7751_PCICLKR));
+	pci_write_reg(0, SH4_PCICLKR);
 	/* Clear Powerdown IRQ's (not done in reset) */
-	word = SH7751_PCIPINT_D3 | SH7751_PCIPINT_D0;
-	outl(word, PCI_REG(SH7751_PCIPINT));
+	word = SH4_PCIPINT_D3 | SH4_PCIPINT_D0;
+	pci_write_reg(word, SH4_PCIPINT);
 
 	/*
 	 * This code is unused for some boards as it is done in the
 	 * bootloader and doing it here means the MAC addresses loaded
 	 * by the bootloader get lost.
 	 */
-	if (!(map->flags & SH7751_PCIC_NO_RESET)) {
+	if (!(map->flags & SH4_PCIC_NO_RESET)) {
 		/* toggle PCI reset pin */
-		word = SH7751_PCICR_PREFIX | SH7751_PCICR_PRST;
-		outl(word,PCI_REG(SH7751_PCICR));
+		word = SH4_PCICR_PREFIX | SH4_PCICR_PRST;
+		pci_write_reg(word, SH4_PCICR);
 		/* Wait for a long time... not 1 sec. but long enough */
 		mdelay(100);
-		word = SH7751_PCICR_PREFIX;
-		outl(word,PCI_REG(SH7751_PCICR));
+		word = SH4_PCICR_PREFIX;
+		pci_write_reg(word, SH4_PCICR);
 	}
-	
+
 	/* set the command/status bits to:
 	 * Wait Cycle Control + Parity Enable + Bus Master +
 	 * Mem space enable
 	 */
 	word = SH7751_PCICONF1_WCC | SH7751_PCICONF1_PER | 
 	       SH7751_PCICONF1_BUM | SH7751_PCICONF1_MES;
-	outl(word, PCI_REG(SH7751_PCICONF1));
+	pci_write_reg(word, SH7751_PCICONF1);
 
 	/* define this host as the host bridge */
-	word = SH7751_PCI_HOST_BRIDGE << 24;
-	outl(word, PCI_REG(SH7751_PCICONF2));
+	word = PCI_BASE_CLASS_BRIDGE << 24;
+	pci_write_reg(word, SH7751_PCICONF2);
 
 	/* Set IO and Mem windows to local address 
 	 * Make PCI and local address the same for easy 1 to 1 mapping 
@@ -291,46 +129,49 @@ int __init sh7751_pcic_init(struct sh7751_pci_address_map *map)
 	 * Window1 = map->window1.size @ cached area base = SDRAM 
 	 */
 	word = map->window0.size - 1;
-	outl(word, PCI_REG(SH7751_PCILSR0));
+	pci_write_reg(word, SH4_PCILSR0);
 	word = map->window1.size - 1;
-	outl(word, PCI_REG(SH7751_PCILSR1));
+	pci_write_reg(word, SH4_PCILSR1);
 	/* Set the values on window 0 PCI config registers */
 	word = P2SEGADDR(map->window0.base);
-	outl(word, PCI_REG(SH7751_PCILAR0));
-	outl(word, PCI_REG(SH7751_PCICONF5));
+	pci_write_reg(word, SH4_PCILAR0);
+	pci_write_reg(word, SH7751_PCICONF5);
 	/* Set the values on window 1 PCI config registers */
 	word =  PHYSADDR(map->window1.base);
-	outl(word, PCI_REG(SH7751_PCILAR1));
-	outl(word, PCI_REG(SH7751_PCICONF6));
+	pci_write_reg(word, SH4_PCILAR1);
+	pci_write_reg(word, SH7751_PCICONF6);
 
-	/* Set the local 16MB PCI memory space window to 
+	/* Set the local 16MB PCI memory space window to
 	 * the lowest PCI mapped address
 	 */
-	word = PCIBIOS_MIN_MEM & SH7751_PCIMBR_MASK;
-	PCIDBG(2,"PCI: Setting upper bits of Memory window to 0x%x\n", word);
-	outl(word , PCI_REG(SH7751_PCIMBR));
+	word = PCIBIOS_MIN_MEM & SH4_PCIMBR_MASK;
+	pr_debug("PCI: Setting upper bits of Memory window to 0x%x\n", word);
+	pci_write_reg(word , SH4_PCIMBR);
 
 	/* Map IO space into PCI IO window
 	 * The IO window is 64K-PCIBIOS_MIN_IO in size
-	 * IO addresses will be translated to the 
+	 * IO addresses will be translated to the
 	 * PCI IO window base address
 	 */
-	PCIDBG(3,"PCI: Mapping IO address 0x%x - 0x%x to base 0x%x\n", PCIBIOS_MIN_IO,
-	    (64*1024), SH7751_PCI_IO_BASE+PCIBIOS_MIN_IO);
+	pr_debug("PCI: Mapping IO address 0x%x - 0x%x to base 0x%x\n",
+		 PCIBIOS_MIN_IO, (64 << 10),
+		 SH4_PCI_IO_BASE + PCIBIOS_MIN_IO);
 
-	/* 
+	/*
 	 * XXX: For now, leave this board-specific. In the event we have other
 	 * boards that need to do similar work, this can be wrapped.
 	 */
 #ifdef CONFIG_SH_BIGSUR
-	bigsur_port_map(PCIBIOS_MIN_IO, (64*1024), SH7751_PCI_IO_BASE+PCIBIOS_MIN_IO,0);
+	bigsur_port_map(PCIBIOS_MIN_IO, (64 << 10),
+			SH4_PCI_IO_BASE + PCIBIOS_MIN_IO, 0);
 #endif
 
-	/* Make sure the MSB's of IO window are set to access PCI space correctly */
-	word = PCIBIOS_MIN_IO & SH7751_PCIIOBR_MASK;
-	PCIDBG(2,"PCI: Setting upper bits of IO window to 0x%x\n", word);
-	outl(word, PCI_REG(SH7751_PCIIOBR));
-	
+	/* Make sure the MSB's of IO window are set to access PCI space
+	 * correctly */
+	word = PCIBIOS_MIN_IO & SH4_PCIIOBR_MASK;
+	pr_debug("PCI: Setting upper bits of IO window to 0x%x\n", word);
+	pci_write_reg(word, SH4_PCIIOBR);
+
 	/* Set PCI WCRx, BCRx's, copy from BSC locations */
 
 	/* check BCR for SDRAM in specified area */
@@ -349,13 +190,13 @@ int __init sh7751_pcic_init(struct sh7751_pci_address_map *map)
 
 	/* configure the wait control registers */
 	word = inl(SH7751_WCR1);
-	outl(word, PCI_REG(SH7751_PCIWCR1));
+	pci_write_reg(word, SH4_PCIWCR1);
 	word = inl(SH7751_WCR2);
-	outl(word, PCI_REG(SH7751_PCIWCR2));
+	pci_write_reg(word, SH4_PCIWCR2);
 	word = inl(SH7751_WCR3);
-	outl(word, PCI_REG(SH7751_PCIWCR3));
+	pci_write_reg(word, SH4_PCIWCR3);
 	word = inl(SH7751_MCR);
-	outl(word, PCI_REG(SH7751_PCIMCR));
+	pci_write_reg(word, SH4_PCIMCR);
 
 	/* NOTE: I'm ignoring the PCI error IRQs for now..
 	 * TODO: add support for the internal error interrupts and
@@ -368,49 +209,8 @@ int __init sh7751_pcic_init(struct sh7751_pci_address_map *map)
 
 	/* SH7751 init done, set central function init complete */
 	/* use round robin mode to stop a device starving/overruning */
-	word = SH7751_PCICR_PREFIX | SH7751_PCICR_CFIN | SH7751_PCICR_ARBM;
-	outl(word,PCI_REG(SH7751_PCICR)); 
+	word = SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_ARBM;
+	pci_write_reg(word, SH4_PCICR);
 
 	return 1;
 }
-
-char * __init pcibios_setup(char *str)
-{
-	if (!strcmp(str, "off")) {
-		pci_probe = 0;
-		return NULL;
-	}
-
-	return str;
-}
-
-/* 
- * 	IRQ functions 
- */
-static u8 __init sh7751_no_swizzle(struct pci_dev *dev, u8 *pin)
-{
-	/* no swizzling */
-	return PCI_SLOT(dev->devfn);
-}
-
-static int sh7751_pci_lookup_irq(struct pci_dev *dev, u8 slot, u8 pin)
-{
-	int irq = -1;
-
-	/* now lookup the actual IRQ on a platform specific basis (pci-'platform'.c) */
-	irq = pcibios_map_platform_irq(slot,pin);
-	if( irq < 0 ) {
-		pr_debug("PCI: Error mapping IRQ on device %s\n", pci_name(dev));
-		return irq;
-	}
-
-	pr_debug("Setting IRQ for slot %s to %d\n", pci_name(dev), irq);
-
-	return irq;
-}
-
-void __init pcibios_fixup_irqs(void)
-{
-	pci_fixup_irqs(sh7751_no_swizzle, sh7751_pci_lookup_irq);
-}
-

commit 5283ecb5ccbdb90d49fce6488d3944bba63a591c
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 15:59:17 2006 +0900

    sh: Add support for R7780RP and R7780MP boards.
    
    This adds support for the Renesas SH7780 development boards,
    R7780RP and R7780MP.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index 682f3dae305d..65093ec1b55e 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -223,7 +223,7 @@ static int __init __area_sdram_check(unsigned int area)
 
 	word = inl(SH7751_BCR1);
 	/* check BCR for SDRAM in area */
-	if(((word >> area) & 1) == 0) {
+	if (((word >> area) & 1) == 0) {
 		printk("PCI: Area %d is not configured for SDRAM. BCR1=0x%x\n",
 		       area, word);
 		return 0;
@@ -232,7 +232,7 @@ static int __init __area_sdram_check(unsigned int area)
 
 	word = (u16)inw(SH7751_BCR2);
 	/* check BCR2 for 32bit SDRAM interface*/
-	if(((word >> (area << 1)) & 0x3) != 0x3) {
+	if (((word >> (area << 1)) & 0x3) != 0x3) {
 		printk("PCI: Area %d is not 32 bit SDRAM. BCR2=0x%x\n",
 		       area, word);
 		return 0;

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
index 30b14ac7ae5a..682f3dae305d 100644
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -15,7 +15,6 @@
 
 #undef DEBUG
 
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/init.h>

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
new file mode 100644
index 000000000000..30b14ac7ae5a
--- /dev/null
+++ b/arch/sh/drivers/pci/pci-sh7751.c
@@ -0,0 +1,417 @@
+/*
+ *	Low-Level PCI Support for the SH7751
+ *
+ *  Dustin McIntire (dustin@sensoria.com)
+ *	Derived from arch/i386/kernel/pci-*.c which bore the message:
+ *	(c) 1999--2000 Martin Mares <mj@ucw.cz>
+ *
+ *  Ported to the new API by Paul Mundt <lethal@linux-sh.org>
+ *  With cleanup by Paul van Gool <pvangool@mimotech.com>
+ *
+ *  May be copied or modified under the terms of the GNU General Public
+ *  License.  See linux/COPYING for more information.
+ *
+ */
+
+#undef DEBUG
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/errno.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+
+#include <asm/machvec.h>
+#include <asm/io.h>
+#include "pci-sh7751.h"
+
+static unsigned int pci_probe = PCI_PROBE_CONF1;
+extern int pci_fixup_pcic(void);
+
+void pcibios_fixup_irqs(void) __attribute__ ((weak));
+
+/*
+ * Direct access to PCI hardware...
+ */
+
+#define CONFIG_CMD(bus, devfn, where) (0x80000000 | (bus->number << 16) | (devfn << 8) | (where & ~3))
+
+/*
+ * Functions for accessing PCI configuration space with type 1 accesses
+ */
+static int sh7751_pci_read(struct pci_bus *bus, unsigned int devfn,
+			   int where, int size, u32 *val)
+{
+	unsigned long flags;
+	u32 data;
+
+	/* 
+	 * PCIPDR may only be accessed as 32 bit words, 
+	 * so we must do byte alignment by hand 
+	 */
+	local_irq_save(flags);
+	outl(CONFIG_CMD(bus,devfn,where), PCI_REG(SH7751_PCIPAR));
+	data = inl(PCI_REG(SH7751_PCIPDR));
+	local_irq_restore(flags);
+
+	switch (size) {
+	case 1:
+		*val = (data >> ((where & 3) << 3)) & 0xff;
+		break;
+	case 2:
+		*val = (data >> ((where & 2) << 3)) & 0xffff;
+		break;
+	case 4:
+		*val = data;
+		break;
+	default:
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+/* 
+ * Since SH7751 only does 32bit access we'll have to do a read,
+ * mask,write operation.
+ * We'll allow an odd byte offset, though it should be illegal.
+ */ 
+static int sh7751_pci_write(struct pci_bus *bus, unsigned int devfn,
+			    int where, int size, u32 val)
+{
+	unsigned long flags;
+	int shift;
+	u32 data;
+
+	local_irq_save(flags);
+	outl(CONFIG_CMD(bus,devfn,where), PCI_REG(SH7751_PCIPAR));
+	data = inl(PCI_REG(SH7751_PCIPDR));
+	local_irq_restore(flags);
+
+	switch (size) {
+	case 1:
+		shift = (where & 3) << 3;
+		data &= ~(0xff << shift);
+		data |= ((val & 0xff) << shift);
+		break;
+	case 2:
+		shift = (where & 2) << 3;
+		data &= ~(0xffff << shift);
+		data |= ((val & 0xffff) << shift);
+		break;
+	case 4:
+		data = val;
+		break;
+	default:
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+	}
+
+	outl(data, PCI_REG(SH7751_PCIPDR));
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+#undef CONFIG_CMD
+
+struct pci_ops sh7751_pci_ops = {
+	.read 		= sh7751_pci_read,
+	.write		= sh7751_pci_write,
+};
+
+static int __init pci_check_direct(void)
+{
+	unsigned int tmp, id;
+
+	/* check for SH7751/SH7751R hardware */
+	id = inl(SH7751_PCIREG_BASE+SH7751_PCICONF0);
+	if (id != ((SH7751_DEVICE_ID << 16) | SH7751_VENDOR_ID) &&
+	    id != ((SH7751R_DEVICE_ID << 16) | SH7751_VENDOR_ID)) {
+		pr_debug("PCI: This is not an SH7751(R) (%x)\n", id);
+		return -ENODEV;
+	}
+
+	/*
+	 * Check if configuration works.
+	 */
+	if (pci_probe & PCI_PROBE_CONF1) {
+		tmp = inl (PCI_REG(SH7751_PCIPAR));
+		outl (0x80000000, PCI_REG(SH7751_PCIPAR));
+		if (inl (PCI_REG(SH7751_PCIPAR)) == 0x80000000) {
+			outl (tmp, PCI_REG(SH7751_PCIPAR));
+			printk(KERN_INFO "PCI: Using configuration type 1\n");
+			request_region(PCI_REG(SH7751_PCIPAR), 8, "PCI conf1");
+			return 0;
+		}
+		outl (tmp, PCI_REG(SH7751_PCIPAR));
+	}
+
+	pr_debug("PCI: pci_check_direct failed\n");
+	return -EINVAL;
+}
+
+/***************************************************************************************/
+
+/*
+ *  Handle bus scanning and fixups ....
+ */
+
+static void __init pci_fixup_ide_bases(struct pci_dev *d)
+{
+	int i;
+
+	/*
+	 * PCI IDE controllers use non-standard I/O port decoding, respect it.
+	 */
+	if ((d->class >> 8) != PCI_CLASS_STORAGE_IDE)
+		return;
+	pr_debug("PCI: IDE base address fixup for %s\n", pci_name(d));
+	for(i=0; i<4; i++) {
+		struct resource *r = &d->resource[i];
+		if ((r->start & ~0x80) == 0x374) {
+			r->start |= 2;
+			r->end = r->start;
+		}
+	}
+}
+
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, pci_fixup_ide_bases);
+
+/*
+ *  Called after each bus is probed, but before its children
+ *  are examined.
+ */
+
+void __init pcibios_fixup_bus(struct pci_bus *b)
+{
+	pci_read_bridge_bases(b);
+}
+
+/*
+ * Initialization. Try all known PCI access methods. Note that we support
+ * using both PCI BIOS and direct access: in such cases, we use I/O ports
+ * to access config space.
+ * 
+ * Note that the platform specific initialization (BSC registers, and memory
+ * space mapping) will be called via the machine vectors (sh_mv.mv_pci_init()) if it
+ * exitst and via the platform defined function pcibios_init_platform().  
+ * See pci_bigsur.c for implementation;
+ * 
+ * The BIOS version of the pci functions is not yet implemented but it is left
+ * in for completeness.  Currently an error will be genereated at compile time. 
+ */
+
+static int __init sh7751_pci_init(void)
+{
+	int ret;
+
+	pr_debug("PCI: Starting intialization.\n");
+	if ((ret = pci_check_direct()) != 0)
+		return ret;
+
+	return pcibios_init_platform();
+}
+
+subsys_initcall(sh7751_pci_init);
+
+static int __init __area_sdram_check(unsigned int area)
+{
+	u32 word;
+
+	word = inl(SH7751_BCR1);
+	/* check BCR for SDRAM in area */
+	if(((word >> area) & 1) == 0) {
+		printk("PCI: Area %d is not configured for SDRAM. BCR1=0x%x\n",
+		       area, word);
+		return 0;
+	}
+	outl(word, PCI_REG(SH7751_PCIBCR1));
+
+	word = (u16)inw(SH7751_BCR2);
+	/* check BCR2 for 32bit SDRAM interface*/
+	if(((word >> (area << 1)) & 0x3) != 0x3) {
+		printk("PCI: Area %d is not 32 bit SDRAM. BCR2=0x%x\n",
+		       area, word);
+		return 0;
+	}
+	outl(word, PCI_REG(SH7751_PCIBCR2));
+
+	return 1;
+}
+
+int __init sh7751_pcic_init(struct sh7751_pci_address_map *map)
+{
+	u32 reg;
+	u32 word;
+
+	/* Set the BCR's to enable PCI access */
+	reg = inl(SH7751_BCR1);
+	reg |= 0x80000;
+	outl(reg, SH7751_BCR1);
+	
+	/* Turn the clocks back on (not done in reset)*/
+	outl(0, PCI_REG(SH7751_PCICLKR));
+	/* Clear Powerdown IRQ's (not done in reset) */
+	word = SH7751_PCIPINT_D3 | SH7751_PCIPINT_D0;
+	outl(word, PCI_REG(SH7751_PCIPINT));
+
+	/*
+	 * This code is unused for some boards as it is done in the
+	 * bootloader and doing it here means the MAC addresses loaded
+	 * by the bootloader get lost.
+	 */
+	if (!(map->flags & SH7751_PCIC_NO_RESET)) {
+		/* toggle PCI reset pin */
+		word = SH7751_PCICR_PREFIX | SH7751_PCICR_PRST;
+		outl(word,PCI_REG(SH7751_PCICR));
+		/* Wait for a long time... not 1 sec. but long enough */
+		mdelay(100);
+		word = SH7751_PCICR_PREFIX;
+		outl(word,PCI_REG(SH7751_PCICR));
+	}
+	
+	/* set the command/status bits to:
+	 * Wait Cycle Control + Parity Enable + Bus Master +
+	 * Mem space enable
+	 */
+	word = SH7751_PCICONF1_WCC | SH7751_PCICONF1_PER | 
+	       SH7751_PCICONF1_BUM | SH7751_PCICONF1_MES;
+	outl(word, PCI_REG(SH7751_PCICONF1));
+
+	/* define this host as the host bridge */
+	word = SH7751_PCI_HOST_BRIDGE << 24;
+	outl(word, PCI_REG(SH7751_PCICONF2));
+
+	/* Set IO and Mem windows to local address 
+	 * Make PCI and local address the same for easy 1 to 1 mapping 
+	 * Window0 = map->window0.size @ non-cached area base = SDRAM
+	 * Window1 = map->window1.size @ cached area base = SDRAM 
+	 */
+	word = map->window0.size - 1;
+	outl(word, PCI_REG(SH7751_PCILSR0));
+	word = map->window1.size - 1;
+	outl(word, PCI_REG(SH7751_PCILSR1));
+	/* Set the values on window 0 PCI config registers */
+	word = P2SEGADDR(map->window0.base);
+	outl(word, PCI_REG(SH7751_PCILAR0));
+	outl(word, PCI_REG(SH7751_PCICONF5));
+	/* Set the values on window 1 PCI config registers */
+	word =  PHYSADDR(map->window1.base);
+	outl(word, PCI_REG(SH7751_PCILAR1));
+	outl(word, PCI_REG(SH7751_PCICONF6));
+
+	/* Set the local 16MB PCI memory space window to 
+	 * the lowest PCI mapped address
+	 */
+	word = PCIBIOS_MIN_MEM & SH7751_PCIMBR_MASK;
+	PCIDBG(2,"PCI: Setting upper bits of Memory window to 0x%x\n", word);
+	outl(word , PCI_REG(SH7751_PCIMBR));
+
+	/* Map IO space into PCI IO window
+	 * The IO window is 64K-PCIBIOS_MIN_IO in size
+	 * IO addresses will be translated to the 
+	 * PCI IO window base address
+	 */
+	PCIDBG(3,"PCI: Mapping IO address 0x%x - 0x%x to base 0x%x\n", PCIBIOS_MIN_IO,
+	    (64*1024), SH7751_PCI_IO_BASE+PCIBIOS_MIN_IO);
+
+	/* 
+	 * XXX: For now, leave this board-specific. In the event we have other
+	 * boards that need to do similar work, this can be wrapped.
+	 */
+#ifdef CONFIG_SH_BIGSUR
+	bigsur_port_map(PCIBIOS_MIN_IO, (64*1024), SH7751_PCI_IO_BASE+PCIBIOS_MIN_IO,0);
+#endif
+
+	/* Make sure the MSB's of IO window are set to access PCI space correctly */
+	word = PCIBIOS_MIN_IO & SH7751_PCIIOBR_MASK;
+	PCIDBG(2,"PCI: Setting upper bits of IO window to 0x%x\n", word);
+	outl(word, PCI_REG(SH7751_PCIIOBR));
+	
+	/* Set PCI WCRx, BCRx's, copy from BSC locations */
+
+	/* check BCR for SDRAM in specified area */
+	switch (map->window0.base) {
+	case SH7751_CS0_BASE_ADDR: word = __area_sdram_check(0); break;
+	case SH7751_CS1_BASE_ADDR: word = __area_sdram_check(1); break;
+	case SH7751_CS2_BASE_ADDR: word = __area_sdram_check(2); break;
+	case SH7751_CS3_BASE_ADDR: word = __area_sdram_check(3); break;
+	case SH7751_CS4_BASE_ADDR: word = __area_sdram_check(4); break;
+	case SH7751_CS5_BASE_ADDR: word = __area_sdram_check(5); break;
+	case SH7751_CS6_BASE_ADDR: word = __area_sdram_check(6); break;
+	}
+	
+	if (!word)
+		return 0;
+
+	/* configure the wait control registers */
+	word = inl(SH7751_WCR1);
+	outl(word, PCI_REG(SH7751_PCIWCR1));
+	word = inl(SH7751_WCR2);
+	outl(word, PCI_REG(SH7751_PCIWCR2));
+	word = inl(SH7751_WCR3);
+	outl(word, PCI_REG(SH7751_PCIWCR3));
+	word = inl(SH7751_MCR);
+	outl(word, PCI_REG(SH7751_PCIMCR));
+
+	/* NOTE: I'm ignoring the PCI error IRQs for now..
+	 * TODO: add support for the internal error interrupts and
+	 * DMA interrupts...
+	 */
+
+#ifdef CONFIG_SH_RTS7751R2D
+	pci_fixup_pcic();
+#endif
+
+	/* SH7751 init done, set central function init complete */
+	/* use round robin mode to stop a device starving/overruning */
+	word = SH7751_PCICR_PREFIX | SH7751_PCICR_CFIN | SH7751_PCICR_ARBM;
+	outl(word,PCI_REG(SH7751_PCICR)); 
+
+	return 1;
+}
+
+char * __init pcibios_setup(char *str)
+{
+	if (!strcmp(str, "off")) {
+		pci_probe = 0;
+		return NULL;
+	}
+
+	return str;
+}
+
+/* 
+ * 	IRQ functions 
+ */
+static u8 __init sh7751_no_swizzle(struct pci_dev *dev, u8 *pin)
+{
+	/* no swizzling */
+	return PCI_SLOT(dev->devfn);
+}
+
+static int sh7751_pci_lookup_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int irq = -1;
+
+	/* now lookup the actual IRQ on a platform specific basis (pci-'platform'.c) */
+	irq = pcibios_map_platform_irq(slot,pin);
+	if( irq < 0 ) {
+		pr_debug("PCI: Error mapping IRQ on device %s\n", pci_name(dev));
+		return irq;
+	}
+
+	pr_debug("Setting IRQ for slot %s to %d\n", pci_name(dev), irq);
+
+	return irq;
+}
+
+void __init pcibios_fixup_irqs(void)
+{
+	pci_fixup_irqs(sh7751_no_swizzle, sh7751_pci_lookup_irq);
+}
+
