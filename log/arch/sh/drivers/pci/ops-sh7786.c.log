commit ff4a7481c3898ffc3cc271d6aca431d190c37247
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 28 00:31:49 2018 -0800

    sh: drivers: convert to SPDX identifiers
    
    Update license to use SPDX-License-Identifier instead of verbose license
    text.
    
    As original license mentioned, it is GPL-2.0 in SPDX.
    Then, MODULE_LICENSE() should be "GPL v2" instead of "GPL".
    See ${LINUX}/include/linux/module.h
    
            "GPL"           [GNU Public License v2 or later]
            "GPL v2"        [GNU Public License v2]
    
    Link: http://lkml.kernel.org/r/87h8fsct0a.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/drivers/pci/ops-sh7786.c b/arch/sh/drivers/pci/ops-sh7786.c
index 128421009e3f..a10f9f4ebd7f 100644
--- a/arch/sh/drivers/pci/ops-sh7786.c
+++ b/arch/sh/drivers/pci/ops-sh7786.c
@@ -1,11 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Generic SH7786 PCI-Express operations.
  *
  *  Copyright (C) 2009 - 2010  Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License v2. See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 #include <linux/kernel.h>
 #include <linux/init.h>

commit 39a90865f07f05343c450e91a56578bb8f69c5e8
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Sep 20 18:56:13 2010 +0900

    sh: pci: Use a generic raw spinlock for PCI config access locking.
    
    This copies the pci_config_lock idea from x86 over, allowing us to kill
    off a couple of existing private locks. At the same time, these need to
    be converted to raw spinlocks for -rt kernels, so we make that change at
    the same time. This should make it easier for future parts to get the
    locking right instead of inevitable ending up with lock type mismatches.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/ops-sh7786.c b/arch/sh/drivers/pci/ops-sh7786.c
index 01cb70fbd803..128421009e3f 100644
--- a/arch/sh/drivers/pci/ops-sh7786.c
+++ b/arch/sh/drivers/pci/ops-sh7786.c
@@ -19,8 +19,6 @@ enum {
 	PCI_ACCESS_WRITE,
 };
 
-static DEFINE_SPINLOCK(sh7786_pcie_lock);
-
 static int sh7786_pcie_config_access(unsigned char access_type,
 		struct pci_bus *bus, unsigned int devfn, int where, u32 *data)
 {
@@ -103,7 +101,7 @@ static int sh7786_pcie_read(struct pci_bus *bus, unsigned int devfn,
 	else if ((size == 4) && (where & 3))
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 
-	spin_lock_irqsave(&sh7786_pcie_lock, flags);
+	raw_spin_lock_irqsave(&pci_config_lock, flags);
 	ret = sh7786_pcie_config_access(PCI_ACCESS_READ, bus,
 					devfn, where, &data);
 	if (ret != PCIBIOS_SUCCESSFUL) {
@@ -123,7 +121,7 @@ static int sh7786_pcie_read(struct pci_bus *bus, unsigned int devfn,
 		devfn, where, size, (unsigned long)*val);
 
 out:
-	spin_unlock_irqrestore(&sh7786_pcie_lock, flags);
+	raw_spin_unlock_irqrestore(&pci_config_lock, flags);
 	return ret;
 }
 
@@ -139,7 +137,7 @@ static int sh7786_pcie_write(struct pci_bus *bus, unsigned int devfn,
 	else if ((size == 4) && (where & 3))
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 
-	spin_lock_irqsave(&sh7786_pcie_lock, flags);
+	raw_spin_lock_irqsave(&pci_config_lock, flags);
 	ret = sh7786_pcie_config_access(PCI_ACCESS_READ, bus,
 					devfn, where, &data);
 	if (ret != PCIBIOS_SUCCESSFUL)
@@ -163,7 +161,7 @@ static int sh7786_pcie_write(struct pci_bus *bus, unsigned int devfn,
 	ret = sh7786_pcie_config_access(PCI_ACCESS_WRITE, bus,
 					devfn, where, &data);
 out:
-	spin_unlock_irqrestore(&sh7786_pcie_lock, flags);
+	raw_spin_unlock_irqrestore(&pci_config_lock, flags);
 	return ret;
 }
 

commit 2c65d75ec4dde5e619a462e70cdd7b67e0e64bb8
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Sep 20 15:39:54 2010 +0900

    sh: pci: Support root complex config accesses on SH7786 PCIe.
    
    The SH7786 PCIe is presently unable to enumerate itself in root complex
    mode, and has no visibility through either type 0 or type 1 accesses,
    despite having a mostly sensible extended config space for each port.
    Attempts to generate type 0 or type 1 config cycles result in completer
    aborts, so we're ultimately forced to use SuperHyway transactions
    instead.
    
    As each port has a single port <-> device mapping that resolves for any
    PCI_SLOT definition, we simply hijack devfn 0 for the SuperHyway
    transaction and bump up the devfn limit.
    
    With enumeration of the root complex now possible, we also need to insert
    an early fixup to hide the BARs from the kernel. With all of that done,
    it's now possible to use the pcieport services with all of the PCIe
    ports, which is the first step to power management support.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/ops-sh7786.c b/arch/sh/drivers/pci/ops-sh7786.c
index 4728199f71a6..01cb70fbd803 100644
--- a/arch/sh/drivers/pci/ops-sh7786.c
+++ b/arch/sh/drivers/pci/ops-sh7786.c
@@ -25,23 +25,49 @@ static int sh7786_pcie_config_access(unsigned char access_type,
 		struct pci_bus *bus, unsigned int devfn, int where, u32 *data)
 {
 	struct pci_channel *chan = bus->sysdata;
-	int dev, func, type;
+	int dev, func, type, reg;
 
 	dev = PCI_SLOT(devfn);
 	func = PCI_FUNC(devfn);
 	type = !!bus->parent;
+	reg = where & ~3;
 
 	if (bus->number > 255 || dev > 31 || func > 7)
 		return PCIBIOS_FUNC_NOT_SUPPORTED;
-	if (bus->parent == NULL && dev)
-		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/*
+	 * While each channel has its own memory-mapped extended config
+	 * space, it's generally only accessible when in endpoint mode.
+	 * When in root complex mode, the controller is unable to target
+	 * itself with either type 0 or type 1 accesses, and indeed, any
+	 * controller initiated target transfer to its own config space
+	 * result in a completer abort.
+	 *
+	 * Each channel effectively only supports a single device, but as
+	 * the same channel <-> device access works for any PCI_SLOT()
+	 * value, we cheat a bit here and bind the controller's config
+	 * space to devfn 0 in order to enable self-enumeration. In this
+	 * case the regular PAR/PDR path is sidelined and the mangled
+	 * config access itself is initiated as a SuperHyway transaction.
+	 */
+	if (pci_is_root_bus(bus)) {
+		if (dev == 0) {
+			if (access_type == PCI_ACCESS_READ)
+				*data = pci_read_reg(chan, PCI_REG(reg));
+			else
+				pci_write_reg(chan, *data, PCI_REG(reg));
+
+			return PCIBIOS_SUCCESSFUL;
+		} else if (dev > 1)
+			return PCIBIOS_DEVICE_NOT_FOUND;
+	}
 
 	/* Clear errors */
 	pci_write_reg(chan, pci_read_reg(chan, SH4A_PCIEERRFR), SH4A_PCIEERRFR);
 
 	/* Set the PIO address */
 	pci_write_reg(chan, (bus->number << 24) | (dev << 19) |
-				(func << 16) | (where & ~3), SH4A_PCIEPAR);
+				(func << 16) | reg, SH4A_PCIEPAR);
 
 	/* Enable the configuration access */
 	pci_write_reg(chan, (1 << 31) | (type << 8), SH4A_PCIEPCTLR);
@@ -49,6 +75,7 @@ static int sh7786_pcie_config_access(unsigned char access_type,
 	/* Check for errors */
 	if (pci_read_reg(chan, SH4A_PCIEERRFR) & 0x10)
 		return PCIBIOS_DEVICE_NOT_FOUND;
+
 	/* Check for master and target aborts */
 	if (pci_read_reg(chan, SH4A_PCIEPCICONF1) & ((1 << 29) | (1 << 28)))
 		return PCIBIOS_DEVICE_NOT_FOUND;

commit bdf7499081fc3c521d0f8fc28c6950c7c9bd7e97
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sun Sep 19 13:54:50 2010 +0900

    sh: pci: Toggle configuration accesses on SH7786.
    
    After configuration accesses have been completed deassert the
    configuration access enable cleanly.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/ops-sh7786.c b/arch/sh/drivers/pci/ops-sh7786.c
index 79a5ddae733d..4728199f71a6 100644
--- a/arch/sh/drivers/pci/ops-sh7786.c
+++ b/arch/sh/drivers/pci/ops-sh7786.c
@@ -58,6 +58,9 @@ static int sh7786_pcie_config_access(unsigned char access_type,
 	else
 		pci_write_reg(chan, *data, SH4A_PCIEPDR);
 
+	/* Disable the configuration access */
+	pci_write_reg(chan, 0, SH4A_PCIEPCTLR);
+
 	return PCIBIOS_SUCCESSFUL;
 }
 

commit 65c23f54c01fabae171d54c0e78df354b3709b93
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Aug 20 20:26:41 2010 +0900

    sh: Relax devfn constraints for SH7786 PCIe.
    
    SH7786 PCIe has 1 slot per port, but no specific restriction on function.
    Relax the devfn restriction and look to the slot number instead when
    configured as a root complex.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/ops-sh7786.c b/arch/sh/drivers/pci/ops-sh7786.c
index 57134a38686a..79a5ddae733d 100644
--- a/arch/sh/drivers/pci/ops-sh7786.c
+++ b/arch/sh/drivers/pci/ops-sh7786.c
@@ -25,14 +25,15 @@ static int sh7786_pcie_config_access(unsigned char access_type,
 		struct pci_bus *bus, unsigned int devfn, int where, u32 *data)
 {
 	struct pci_channel *chan = bus->sysdata;
-	int dev, func;
+	int dev, func, type;
 
 	dev = PCI_SLOT(devfn);
 	func = PCI_FUNC(devfn);
+	type = !!bus->parent;
 
 	if (bus->number > 255 || dev > 31 || func > 7)
 		return PCIBIOS_FUNC_NOT_SUPPORTED;
-	if (devfn)
+	if (bus->parent == NULL && dev)
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
 	/* Clear errors */
@@ -43,13 +44,7 @@ static int sh7786_pcie_config_access(unsigned char access_type,
 				(func << 16) | (where & ~3), SH4A_PCIEPAR);
 
 	/* Enable the configuration access */
-	if (bus->number) {
-		/* Type 1 */
-		pci_write_reg(chan, (1 << 31) | (1 << 8), SH4A_PCIEPCTLR);
-	} else {
-		/* Type 0 */
-		pci_write_reg(chan, (1 << 31), SH4A_PCIEPCTLR);
-	}
+	pci_write_reg(chan, (1 << 31) | (type << 8), SH4A_PCIEPCTLR);
 
 	/* Check for errors */
 	if (pci_read_reg(chan, SH4A_PCIEERRFR) & 0x10)

commit 7656e2486cb1ab7cdee65652ee695bdff894ea73
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Aug 20 15:59:40 2010 +0900

    sh: Support type 1 accesses for SH7786 PCI.
    
    This enables support for type 1 config space accesses on the SH7786
    PCI controller. At the same time, add in some extra sanity checks for
    controller asserted errors.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/ops-sh7786.c b/arch/sh/drivers/pci/ops-sh7786.c
index 48f594b9582b..57134a38686a 100644
--- a/arch/sh/drivers/pci/ops-sh7786.c
+++ b/arch/sh/drivers/pci/ops-sh7786.c
@@ -1,7 +1,7 @@
 /*
  * Generic SH7786 PCI-Express operations.
  *
- *  Copyright (C) 2009  Paul Mundt
+ *  Copyright (C) 2009 - 2010  Paul Mundt
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License v2. See the file "COPYING" in the main directory of this archive
@@ -35,22 +35,34 @@ static int sh7786_pcie_config_access(unsigned char access_type,
 	if (devfn)
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
+	/* Clear errors */
+	pci_write_reg(chan, pci_read_reg(chan, SH4A_PCIEERRFR), SH4A_PCIEERRFR);
+
 	/* Set the PIO address */
 	pci_write_reg(chan, (bus->number << 24) | (dev << 19) |
 				(func << 16) | (where & ~3), SH4A_PCIEPAR);
 
 	/* Enable the configuration access */
-	pci_write_reg(chan, (1 << 31), SH4A_PCIEPCTLR);
+	if (bus->number) {
+		/* Type 1 */
+		pci_write_reg(chan, (1 << 31) | (1 << 8), SH4A_PCIEPCTLR);
+	} else {
+		/* Type 0 */
+		pci_write_reg(chan, (1 << 31), SH4A_PCIEPCTLR);
+	}
+
+	/* Check for errors */
+	if (pci_read_reg(chan, SH4A_PCIEERRFR) & 0x10)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	/* Check for master and target aborts */
+	if (pci_read_reg(chan, SH4A_PCIEPCICONF1) & ((1 << 29) | (1 << 28)))
+		return PCIBIOS_DEVICE_NOT_FOUND;
 
 	if (access_type == PCI_ACCESS_READ)
 		*data = pci_read_reg(chan, SH4A_PCIEPDR);
 	else
 		pci_write_reg(chan, *data, SH4A_PCIEPDR);
 
-	/* Check for master and target aborts */
-	if (pci_read_reg(chan, SH4A_PCIEPCICONF1) & ((1 << 29) | (1 << 28)))
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
 	return PCIBIOS_SUCCESSFUL;
 }
 
@@ -69,8 +81,10 @@ static int sh7786_pcie_read(struct pci_bus *bus, unsigned int devfn,
 	spin_lock_irqsave(&sh7786_pcie_lock, flags);
 	ret = sh7786_pcie_config_access(PCI_ACCESS_READ, bus,
 					devfn, where, &data);
-	if (ret != PCIBIOS_SUCCESSFUL)
+	if (ret != PCIBIOS_SUCCESSFUL) {
+		*val = 0xffffffff;
 		goto out;
+	}
 
 	if (size == 1)
 		*val = (data >> ((where & 3) << 3)) & 0xff;

commit 66765fe1b62e4c0eee3b7e3aa1eb34e5428f52ec
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jun 16 06:26:08 2009 +0900

    sh: pci: SH7786 PCI ops.
    
    This adds in preliminary support for the SH7786 PCIe module PCI ops,
    and the corresponding module definitions.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/pci/ops-sh7786.c b/arch/sh/drivers/pci/ops-sh7786.c
new file mode 100644
index 000000000000..48f594b9582b
--- /dev/null
+++ b/arch/sh/drivers/pci/ops-sh7786.c
@@ -0,0 +1,134 @@
+/*
+ * Generic SH7786 PCI-Express operations.
+ *
+ *  Copyright (C) 2009  Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/io.h>
+#include <linux/spinlock.h>
+#include "pcie-sh7786.h"
+
+enum {
+	PCI_ACCESS_READ,
+	PCI_ACCESS_WRITE,
+};
+
+static DEFINE_SPINLOCK(sh7786_pcie_lock);
+
+static int sh7786_pcie_config_access(unsigned char access_type,
+		struct pci_bus *bus, unsigned int devfn, int where, u32 *data)
+{
+	struct pci_channel *chan = bus->sysdata;
+	int dev, func;
+
+	dev = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
+
+	if (bus->number > 255 || dev > 31 || func > 7)
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+	if (devfn)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/* Set the PIO address */
+	pci_write_reg(chan, (bus->number << 24) | (dev << 19) |
+				(func << 16) | (where & ~3), SH4A_PCIEPAR);
+
+	/* Enable the configuration access */
+	pci_write_reg(chan, (1 << 31), SH4A_PCIEPCTLR);
+
+	if (access_type == PCI_ACCESS_READ)
+		*data = pci_read_reg(chan, SH4A_PCIEPDR);
+	else
+		pci_write_reg(chan, *data, SH4A_PCIEPDR);
+
+	/* Check for master and target aborts */
+	if (pci_read_reg(chan, SH4A_PCIEPCICONF1) & ((1 << 29) | (1 << 28)))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int sh7786_pcie_read(struct pci_bus *bus, unsigned int devfn,
+			    int where, int size, u32 *val)
+{
+	unsigned long flags;
+	int ret;
+	u32 data;
+
+        if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	spin_lock_irqsave(&sh7786_pcie_lock, flags);
+	ret = sh7786_pcie_config_access(PCI_ACCESS_READ, bus,
+					devfn, where, &data);
+	if (ret != PCIBIOS_SUCCESSFUL)
+		goto out;
+
+	if (size == 1)
+		*val = (data >> ((where & 3) << 3)) & 0xff;
+	else if (size == 2)
+		*val = (data >> ((where & 2) << 3)) & 0xffff;
+	else
+		*val = data;
+
+	dev_dbg(&bus->dev, "pcie-config-read: bus=%3d devfn=0x%04x "
+		"where=0x%04x size=%d val=0x%08lx\n", bus->number,
+		devfn, where, size, (unsigned long)*val);
+
+out:
+	spin_unlock_irqrestore(&sh7786_pcie_lock, flags);
+	return ret;
+}
+
+static int sh7786_pcie_write(struct pci_bus *bus, unsigned int devfn,
+			     int where, int size, u32 val)
+{
+	unsigned long flags;
+	int shift, ret;
+	u32 data;
+
+        if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	spin_lock_irqsave(&sh7786_pcie_lock, flags);
+	ret = sh7786_pcie_config_access(PCI_ACCESS_READ, bus,
+					devfn, where, &data);
+	if (ret != PCIBIOS_SUCCESSFUL)
+		goto out;
+
+	dev_dbg(&bus->dev, "pcie-config-write: bus=%3d devfn=0x%04x "
+		"where=0x%04x size=%d val=%08lx\n", bus->number,
+		devfn, where, size, (unsigned long)val);
+
+	if (size == 1) {
+		shift = (where & 3) << 3;
+		data &= ~(0xff << shift);
+		data |= ((val & 0xff) << shift);
+	} else if (size == 2) {
+		shift = (where & 2) << 3;
+		data &= ~(0xffff << shift);
+		data |= ((val & 0xffff) << shift);
+	} else
+		data = val;
+
+	ret = sh7786_pcie_config_access(PCI_ACCESS_WRITE, bus,
+					devfn, where, &data);
+out:
+	spin_unlock_irqrestore(&sh7786_pcie_lock, flags);
+	return ret;
+}
+
+struct pci_ops sh7786_pci_ops = {
+	.read	= sh7786_pcie_read,
+	.write	= sh7786_pcie_write,
+};
