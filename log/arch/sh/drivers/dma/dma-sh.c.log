commit ff4a7481c3898ffc3cc271d6aca431d190c37247
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 28 00:31:49 2018 -0800

    sh: drivers: convert to SPDX identifiers
    
    Update license to use SPDX-License-Identifier instead of verbose license
    text.
    
    As original license mentioned, it is GPL-2.0 in SPDX.
    Then, MODULE_LICENSE() should be "GPL v2" instead of "GPL".
    See ${LINUX}/include/linux/module.h
    
            "GPL"           [GNU Public License v2 or later]
            "GPL v2"        [GNU Public License v2]
    
    Link: http://lkml.kernel.org/r/87h8fsct0a.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index afde2a7d3eb3..96c626c2cd0a 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * arch/sh/drivers/dma/dma-sh.c
  *
@@ -6,10 +7,6 @@
  * Copyright (C) 2000 Takashi YOSHII
  * Copyright (C) 2003, 2004 Paul Mundt
  * Copyright (C) 2005 Andriy Skulysh
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 #include <linux/init.h>
 #include <linux/interrupt.h>
@@ -414,4 +411,4 @@ module_exit(sh_dmac_exit);
 
 MODULE_AUTHOR("Takashi YOSHII, Paul Mundt, Andriy Skulysh");
 MODULE_DESCRIPTION("SuperH On-Chip DMAC Support");
-MODULE_LICENSE("GPL");
+MODULE_LICENSE("GPL v2");

commit 28564f0893750f52085744d5d5728fc7631eefb6
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jun 20 14:37:40 2014 +0200

    sh: dma: Use defines instead of hardcoded numbers
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index b22565623142..afde2a7d3eb3 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -25,7 +25,7 @@
  * Define the default configuration for dual address memory-memory transfer.
  * The 0x400 value represents auto-request, external->external.
  */
-#define RS_DUAL	(DM_INC | SM_INC | 0x400 | TS_INDEX2VAL(XMIT_SZ_32BIT))
+#define RS_DUAL	(DM_INC | SM_INC | RS_AUTO | TS_INDEX2VAL(XMIT_SZ_32BIT))
 
 static unsigned long dma_find_base(unsigned int chan)
 {

commit 800fb3ddee2c50918d651fbd70515f1e38857305
Author: Mike Frysinger <vapier@gentoo.org>
Date:   Sat Aug 4 21:54:05 2012 -0400

    sh: dma: fix request_irq usage
    
    When calling request_irq with IRQF_SHARED, the dev cookie must be set
    (i.e. non-NULL), otherwise the code rejects it immediately with -EINVAL.
    So restore the logic here where we'd pass a pointer to the name as a
    dummy unique val.
    
    Otherwise, booting up on my LANDISK system would fail with:
            DMAC Address Error0 request_irq fail
    
    This was introduced in commit 7f47c7189b3e8f19a589f77a3ad169d7b691b582.
    
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index 4c171f13b0e8..b22565623142 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -335,7 +335,7 @@ static int dmae_irq_init(void)
 
 	for (n = 0; n < NR_DMAE; n++) {
 		int i = request_irq(get_dma_error_irq(n), dma_err,
-				    IRQF_SHARED, dmae_name[n], NULL);
+				    IRQF_SHARED, dmae_name[n], (void *)dmae_name[n]);
 		if (unlikely(i < 0)) {
 			printk(KERN_ERR "%s request_irq fail\n", dmae_name[n]);
 			return i;

commit 7f47c7189b3e8f19a589f77a3ad169d7b691b582
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sat May 19 20:38:50 2012 +0900

    sh: dma: More legacy cpu dma chainsawing.
    
    Attempt to "tidy" up some of the multi IRQ handling and base + IRQ
    management. This should keep it limping along without too much hassle,
    and no new parts should ever be enabling or using this API anyways.
    
    It doesn't get any closer to lipstick on a pig as this.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index a60da6dd4d17..4c171f13b0e8 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -14,35 +14,72 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/io.h>
 #include <mach-dreamcast/mach/dma.h>
 #include <asm/dma.h>
-#include <asm/io.h>
-#include <asm/dma-sh.h>
+#include <asm/dma-register.h>
+#include <cpu/dma-register.h>
+#include <cpu/dma.h>
 
-#if defined(DMAE1_IRQ)
-#define NR_DMAE		2
-#else
-#define NR_DMAE		1
+/*
+ * Define the default configuration for dual address memory-memory transfer.
+ * The 0x400 value represents auto-request, external->external.
+ */
+#define RS_DUAL	(DM_INC | SM_INC | 0x400 | TS_INDEX2VAL(XMIT_SZ_32BIT))
+
+static unsigned long dma_find_base(unsigned int chan)
+{
+	unsigned long base = SH_DMAC_BASE0;
+
+#ifdef SH_DMAC_BASE1
+	if (chan >= 6)
+		base = SH_DMAC_BASE1;
 #endif
 
-static const char *dmae_name[] = {
-	"DMAC Address Error0", "DMAC Address Error1"
-};
+	return base;
+}
+
+static unsigned long dma_base_addr(unsigned int chan)
+{
+	unsigned long base = dma_find_base(chan);
+
+	/* Normalize offset calculation */
+	if (chan >= 9)
+		chan -= 6;
+	if (chan >= 4)
+		base += 0x10;
+
+	return base + (chan * 0x10);
+}
 
+#ifdef CONFIG_SH_DMA_IRQ_MULTI
 static inline unsigned int get_dmte_irq(unsigned int chan)
 {
-	unsigned int irq = 0;
-	if (chan < ARRAY_SIZE(dmte_irq_map))
-		irq = dmte_irq_map[chan];
-
-#if defined(CONFIG_SH_DMA_IRQ_MULTI)
-	if (irq > DMTE6_IRQ)
-		return DMTE6_IRQ;
-	return DMTE0_IRQ;
+	return chan >= 6 ? DMTE6_IRQ : DMTE0_IRQ;
+}
 #else
-	return irq;
+
+static unsigned int dmte_irq_map[] = {
+	DMTE0_IRQ, DMTE0_IRQ + 1, DMTE0_IRQ + 2, DMTE0_IRQ + 3,
+
+#ifdef DMTE4_IRQ
+	DMTE4_IRQ, DMTE4_IRQ + 1,
+#endif
+
+#ifdef DMTE6_IRQ
+	DMTE6_IRQ, DMTE6_IRQ + 1,
+#endif
+
+#ifdef DMTE8_IRQ
+	DMTE8_IRQ, DMTE9_IRQ, DMTE10_IRQ, DMTE11_IRQ,
 #endif
+};
+
+static inline unsigned int get_dmte_irq(unsigned int chan)
+{
+	return dmte_irq_map[chan];
 }
+#endif
 
 /*
  * We determine the correct shift size based off of the CHCR transmit size
@@ -53,9 +90,10 @@ static inline unsigned int get_dmte_irq(unsigned int chan)
  * iterations to complete the transfer.
  */
 static unsigned int ts_shift[] = TS_SHIFT;
+
 static inline unsigned int calc_xmit_shift(struct dma_channel *chan)
 {
-	u32 chcr = __raw_readl(dma_base_addr[chan->chan] + CHCR);
+	u32 chcr = __raw_readl(dma_base_addr(chan->chan) + CHCR);
 	int cnt = ((chcr & CHCR_TS_LOW_MASK) >> CHCR_TS_LOW_SHIFT) |
 		((chcr & CHCR_TS_HIGH_MASK) >> CHCR_TS_HIGH_SHIFT);
 
@@ -73,13 +111,13 @@ static irqreturn_t dma_tei(int irq, void *dev_id)
 	struct dma_channel *chan = dev_id;
 	u32 chcr;
 
-	chcr = __raw_readl(dma_base_addr[chan->chan] + CHCR);
+	chcr = __raw_readl(dma_base_addr(chan->chan) + CHCR);
 
 	if (!(chcr & CHCR_TE))
 		return IRQ_NONE;
 
 	chcr &= ~(CHCR_IE | CHCR_DE);
-	__raw_writel(chcr, (dma_base_addr[chan->chan] + CHCR));
+	__raw_writel(chcr, (dma_base_addr(chan->chan) + CHCR));
 
 	wake_up(&chan->wait_queue);
 
@@ -91,13 +129,8 @@ static int sh_dmac_request_dma(struct dma_channel *chan)
 	if (unlikely(!(chan->flags & DMA_TEI_CAPABLE)))
 		return 0;
 
-	return request_irq(get_dmte_irq(chan->chan), dma_tei,
-#if defined(CONFIG_SH_DMA_IRQ_MULTI)
-				IRQF_SHARED,
-#else
-				0,
-#endif
-				chan->dev_id, chan);
+	return request_irq(get_dmte_irq(chan->chan), dma_tei, IRQF_SHARED,
+			   chan->dev_id, chan);
 }
 
 static void sh_dmac_free_dma(struct dma_channel *chan)
@@ -118,7 +151,7 @@ sh_dmac_configure_channel(struct dma_channel *chan, unsigned long chcr)
 		chan->flags &= ~DMA_TEI_CAPABLE;
 	}
 
-	__raw_writel(chcr, (dma_base_addr[chan->chan] + CHCR));
+	__raw_writel(chcr, (dma_base_addr(chan->chan) + CHCR));
 
 	chan->flags |= DMA_CONFIGURED;
 	return 0;
@@ -129,13 +162,13 @@ static void sh_dmac_enable_dma(struct dma_channel *chan)
 	int irq;
 	u32 chcr;
 
-	chcr = __raw_readl(dma_base_addr[chan->chan] + CHCR);
+	chcr = __raw_readl(dma_base_addr(chan->chan) + CHCR);
 	chcr |= CHCR_DE;
 
 	if (chan->flags & DMA_TEI_CAPABLE)
 		chcr |= CHCR_IE;
 
-	__raw_writel(chcr, (dma_base_addr[chan->chan] + CHCR));
+	__raw_writel(chcr, (dma_base_addr(chan->chan) + CHCR));
 
 	if (chan->flags & DMA_TEI_CAPABLE) {
 		irq = get_dmte_irq(chan->chan);
@@ -153,9 +186,9 @@ static void sh_dmac_disable_dma(struct dma_channel *chan)
 		disable_irq(irq);
 	}
 
-	chcr = __raw_readl(dma_base_addr[chan->chan] + CHCR);
+	chcr = __raw_readl(dma_base_addr(chan->chan) + CHCR);
 	chcr &= ~(CHCR_DE | CHCR_TE | CHCR_IE);
-	__raw_writel(chcr, (dma_base_addr[chan->chan] + CHCR));
+	__raw_writel(chcr, (dma_base_addr(chan->chan) + CHCR));
 }
 
 static int sh_dmac_xfer_dma(struct dma_channel *chan)
@@ -186,13 +219,13 @@ static int sh_dmac_xfer_dma(struct dma_channel *chan)
 	 */
 	if (chan->sar || (mach_is_dreamcast() &&
 			  chan->chan == PVR2_CASCADE_CHAN))
-		__raw_writel(chan->sar, (dma_base_addr[chan->chan]+SAR));
+		__raw_writel(chan->sar, (dma_base_addr(chan->chan) + SAR));
 	if (chan->dar || (mach_is_dreamcast() &&
 			  chan->chan == PVR2_CASCADE_CHAN))
-		__raw_writel(chan->dar, (dma_base_addr[chan->chan] + DAR));
+		__raw_writel(chan->dar, (dma_base_addr(chan->chan) + DAR));
 
 	__raw_writel(chan->count >> calc_xmit_shift(chan),
-		(dma_base_addr[chan->chan] + TCR));
+		(dma_base_addr(chan->chan) + TCR));
 
 	sh_dmac_enable_dma(chan);
 
@@ -201,13 +234,32 @@ static int sh_dmac_xfer_dma(struct dma_channel *chan)
 
 static int sh_dmac_get_dma_residue(struct dma_channel *chan)
 {
-	if (!(__raw_readl(dma_base_addr[chan->chan] + CHCR) & CHCR_DE))
+	if (!(__raw_readl(dma_base_addr(chan->chan) + CHCR) & CHCR_DE))
 		return 0;
 
-	return __raw_readl(dma_base_addr[chan->chan] + TCR)
+	return __raw_readl(dma_base_addr(chan->chan) + TCR)
 		 << calc_xmit_shift(chan);
 }
 
+/*
+ * DMAOR handling
+ */
+#if defined(CONFIG_CPU_SUBTYPE_SH7723)	|| \
+    defined(CONFIG_CPU_SUBTYPE_SH7724)	|| \
+    defined(CONFIG_CPU_SUBTYPE_SH7780)	|| \
+    defined(CONFIG_CPU_SUBTYPE_SH7785)
+#define NR_DMAOR	2
+#else
+#define NR_DMAOR	1
+#endif
+
+/*
+ * DMAOR bases are broken out amongst channel groups. DMAOR0 manages
+ * channels 0 - 5, DMAOR1 6 - 11 (optional).
+ */
+#define dmaor_read_reg(n)		__raw_readw(dma_find_base((n)*6))
+#define dmaor_write_reg(n, data)	__raw_writew(data, dma_find_base(n)*6)
+
 static inline int dmaor_reset(int no)
 {
 	unsigned long dmaor = dmaor_read_reg(no);
@@ -228,36 +280,86 @@ static inline int dmaor_reset(int no)
 	return 0;
 }
 
-#if defined(CONFIG_CPU_SH4)
-static irqreturn_t dma_err(int irq, void *dummy)
-{
-#if defined(CONFIG_SH_DMA_IRQ_MULTI)
-	int cnt = 0;
-	switch (irq) {
-#if defined(DMTE6_IRQ) && defined(DMAE1_IRQ)
-	case DMTE6_IRQ:
-		cnt++;
+/*
+ * DMAE handling
+ */
+#ifdef CONFIG_CPU_SH4
+
+#if defined(DMAE1_IRQ)
+#define NR_DMAE		2
+#else
+#define NR_DMAE		1
 #endif
-	case DMTE0_IRQ:
-		if (dmaor_read_reg(cnt) & (DMAOR_NMIF | DMAOR_AE)) {
-			disable_irq(irq);
-			/* DMA multi and error IRQ */
-			return IRQ_HANDLED;
-		}
-	default:
-		return IRQ_NONE;
-	}
+
+static const char *dmae_name[] = {
+	"DMAC Address Error0",
+	"DMAC Address Error1"
+};
+
+#ifdef CONFIG_SH_DMA_IRQ_MULTI
+static inline unsigned int get_dma_error_irq(int n)
+{
+	return get_dmte_irq(n * 6);
+}
 #else
-	dmaor_reset(0);
-#if defined(CONFIG_CPU_SUBTYPE_SH7723)	|| \
-		defined(CONFIG_CPU_SUBTYPE_SH7780)	|| \
-		defined(CONFIG_CPU_SUBTYPE_SH7785)
-	dmaor_reset(1);
+
+static unsigned int dmae_irq_map[] = {
+	DMAE0_IRQ,
+
+#ifdef DMAE1_IRQ
+	DMAE1_IRQ,
+#endif
+};
+
+static inline unsigned int get_dma_error_irq(int n)
+{
+	return dmae_irq_map[n];
+}
 #endif
+
+static irqreturn_t dma_err(int irq, void *dummy)
+{
+	int i;
+
+	for (i = 0; i < NR_DMAOR; i++)
+		dmaor_reset(i);
+
 	disable_irq(irq);
 
 	return IRQ_HANDLED;
-#endif
+}
+
+static int dmae_irq_init(void)
+{
+	int n;
+
+	for (n = 0; n < NR_DMAE; n++) {
+		int i = request_irq(get_dma_error_irq(n), dma_err,
+				    IRQF_SHARED, dmae_name[n], NULL);
+		if (unlikely(i < 0)) {
+			printk(KERN_ERR "%s request_irq fail\n", dmae_name[n]);
+			return i;
+		}
+	}
+
+	return 0;
+}
+
+static void dmae_irq_free(void)
+{
+	int n;
+
+	for (n = 0; n < NR_DMAE; n++)
+		free_irq(get_dma_error_irq(n), NULL);
+}
+#else
+static inline int dmae_irq_init(void)
+{
+	return 0;
+}
+
+static void dmae_irq_free(void)
+{
 }
 #endif
 
@@ -276,72 +378,34 @@ static struct dma_info sh_dmac_info = {
 	.flags		= DMAC_CHANNELS_TEI_CAPABLE,
 };
 
-#ifdef CONFIG_CPU_SH4
-static unsigned int get_dma_error_irq(int n)
-{
-#if defined(CONFIG_SH_DMA_IRQ_MULTI)
-	return (n == 0) ? get_dmte_irq(0) : get_dmte_irq(6);
-#else
-	return (n == 0) ? DMAE0_IRQ :
-#if defined(DMAE1_IRQ)
-				DMAE1_IRQ;
-#else
-				-1;
-#endif
-#endif
-}
-#endif
-
 static int __init sh_dmac_init(void)
 {
 	struct dma_info *info = &sh_dmac_info;
-	int i;
-
-#ifdef CONFIG_CPU_SH4
-	int n;
+	int i, rc;
 
-	for (n = 0; n < NR_DMAE; n++) {
-		i = request_irq(get_dma_error_irq(n), dma_err,
-#if defined(CONFIG_SH_DMA_IRQ_MULTI)
-				IRQF_SHARED,
-#else
-				0,
-#endif
-				dmae_name[n], (void *)dmae_name[n]);
-		if (unlikely(i < 0)) {
-			printk(KERN_ERR "%s request_irq fail\n", dmae_name[n]);
-			return i;
-		}
-	}
-#endif /* CONFIG_CPU_SH4 */
+	/*
+	 * Initialize DMAE, for parts that support it.
+	 */
+	rc = dmae_irq_init();
+	if (unlikely(rc != 0))
+		return rc;
 
 	/*
 	 * Initialize DMAOR, and clean up any error flags that may have
 	 * been set.
 	 */
-	i = dmaor_reset(0);
-	if (unlikely(i != 0))
-		return i;
-#if defined(CONFIG_CPU_SUBTYPE_SH7723)	|| \
-		defined(CONFIG_CPU_SUBTYPE_SH7780)	|| \
-		defined(CONFIG_CPU_SUBTYPE_SH7785)
-	i = dmaor_reset(1);
-	if (unlikely(i != 0))
-		return i;
-#endif
+	for (i = 0; i < NR_DMAOR; i++) {
+		rc = dmaor_reset(i);
+		if (unlikely(rc != 0))
+			return rc;
+	}
 
 	return register_dmac(info);
 }
 
 static void __exit sh_dmac_exit(void)
 {
-#ifdef CONFIG_CPU_SH4
-	int n;
-
-	for (n = 0; n < NR_DMAE; n++) {
-		free_irq(get_dma_error_irq(n), (void *)dmae_name[n]);
-	}
-#endif /* CONFIG_CPU_SH4 */
+	dmae_irq_free();
 	unregister_dmac(&sh_dmac_info);
 }
 

commit d11584a0449f881181dc94dd697d3f3896c15c73
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Sat Oct 22 17:56:28 2011 +0800

    SH: irq: Remove IRQF_DISABLED
    
    Since commit [e58aa3d2: genirq: Run irq handlers with interrupts disabled],
    We run all interrupt handlers with interrupts disabled
    and we even check and yell when an interrupt handler
    returns with interrupts enabled (see commit [b738a50a:
    genirq: Warn when handler enables interrupts]).
    
    So now this flag is a NOOP and can be removed.
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index 827208781ed5..a60da6dd4d17 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -95,7 +95,7 @@ static int sh_dmac_request_dma(struct dma_channel *chan)
 #if defined(CONFIG_SH_DMA_IRQ_MULTI)
 				IRQF_SHARED,
 #else
-				IRQF_DISABLED,
+				0,
 #endif
 				chan->dev_id, chan);
 }
@@ -305,7 +305,7 @@ static int __init sh_dmac_init(void)
 #if defined(CONFIG_SH_DMA_IRQ_MULTI)
 				IRQF_SHARED,
 #else
-				IRQF_DISABLED,
+				0,
 #endif
 				dmae_name[n], (void *)dmae_name[n]);
 		if (unlikely(i < 0)) {

commit 2e18e047981ae04be9bd0d9760057f7c1a7b3785
Merge: b06ede84dd14 cfefe9979525
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Feb 8 11:34:03 2010 +0900

    Merge branch 'sh/dmaengine'
    
    Conflicts:
            arch/sh/drivers/dma/dma-sh.c

commit 623b4ac4bf9e767991c66e29b47dd4b19458fb42
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Wed Feb 3 14:44:12 2010 +0000

    sh: fix Transfer Size calculation in both DMA drivers
    
    Both the original arch/sh/drivers/dma/dma-sh.c and the new SH dmaengine drivers
    do not take into account bits 3:2 of the Transfer Size field in the CHCR
    register, besides, bit-field defines set bit 2, but the mask only passes bits
    1:0 through. TS_16BLK and TS_32BLK macros are bogus too. This patch fixes all
    these issues for sh7722 and sh7724, other CPUs stay unchanged and might need to
    be fixed too.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Acked-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index 37fb5b8bbc3f..31830cb0af89 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -52,11 +52,14 @@ static inline unsigned int get_dmte_irq(unsigned int chan)
  *
  * iterations to complete the transfer.
  */
+static unsigned int ts_shift[] = TS_SHIFT;
 static inline unsigned int calc_xmit_shift(struct dma_channel *chan)
 {
 	u32 chcr = ctrl_inl(dma_base_addr[chan->chan] + CHCR);
+	int cnt = ((chcr & CHCR_TS_LOW_MASK) >> CHCR_TS_LOW_SHIFT) |
+		((chcr & CHCR_TS_HIGH_MASK) >> CHCR_TS_HIGH_SHIFT);
 
-	return ts_shift[(chcr & CHCR_TS_MASK)>>CHCR_TS_SHIFT];
+	return ts_shift[cnt];
 }
 
 /*

commit 9d56dd3b083a3bec56e9da35ce07baca81030b03
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jan 26 12:58:40 2010 +0900

    sh: Mass ctrl_in/outX to __raw_read/writeX conversion.
    
    The old ctrl in/out routines are non-portable and unsuitable for
    cross-platform use. While drivers/sh has already been sanitized, there
    is still quite a lot of code that is not. This converts the arch/sh/ bits
    over, which permits us to flag the routines as deprecated whilst still
    building with -Werror for the architecture code, and to ensure that
    future users are not added.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index 37fb5b8bbc3f..565cc1a4cbba 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -54,7 +54,7 @@ static inline unsigned int get_dmte_irq(unsigned int chan)
  */
 static inline unsigned int calc_xmit_shift(struct dma_channel *chan)
 {
-	u32 chcr = ctrl_inl(dma_base_addr[chan->chan] + CHCR);
+	u32 chcr = __raw_readl(dma_base_addr[chan->chan] + CHCR);
 
 	return ts_shift[(chcr & CHCR_TS_MASK)>>CHCR_TS_SHIFT];
 }
@@ -70,13 +70,13 @@ static irqreturn_t dma_tei(int irq, void *dev_id)
 	struct dma_channel *chan = dev_id;
 	u32 chcr;
 
-	chcr = ctrl_inl(dma_base_addr[chan->chan] + CHCR);
+	chcr = __raw_readl(dma_base_addr[chan->chan] + CHCR);
 
 	if (!(chcr & CHCR_TE))
 		return IRQ_NONE;
 
 	chcr &= ~(CHCR_IE | CHCR_DE);
-	ctrl_outl(chcr, (dma_base_addr[chan->chan] + CHCR));
+	__raw_writel(chcr, (dma_base_addr[chan->chan] + CHCR));
 
 	wake_up(&chan->wait_queue);
 
@@ -115,7 +115,7 @@ sh_dmac_configure_channel(struct dma_channel *chan, unsigned long chcr)
 		chan->flags &= ~DMA_TEI_CAPABLE;
 	}
 
-	ctrl_outl(chcr, (dma_base_addr[chan->chan] + CHCR));
+	__raw_writel(chcr, (dma_base_addr[chan->chan] + CHCR));
 
 	chan->flags |= DMA_CONFIGURED;
 	return 0;
@@ -126,13 +126,13 @@ static void sh_dmac_enable_dma(struct dma_channel *chan)
 	int irq;
 	u32 chcr;
 
-	chcr = ctrl_inl(dma_base_addr[chan->chan] + CHCR);
+	chcr = __raw_readl(dma_base_addr[chan->chan] + CHCR);
 	chcr |= CHCR_DE;
 
 	if (chan->flags & DMA_TEI_CAPABLE)
 		chcr |= CHCR_IE;
 
-	ctrl_outl(chcr, (dma_base_addr[chan->chan] + CHCR));
+	__raw_writel(chcr, (dma_base_addr[chan->chan] + CHCR));
 
 	if (chan->flags & DMA_TEI_CAPABLE) {
 		irq = get_dmte_irq(chan->chan);
@@ -150,9 +150,9 @@ static void sh_dmac_disable_dma(struct dma_channel *chan)
 		disable_irq(irq);
 	}
 
-	chcr = ctrl_inl(dma_base_addr[chan->chan] + CHCR);
+	chcr = __raw_readl(dma_base_addr[chan->chan] + CHCR);
 	chcr &= ~(CHCR_DE | CHCR_TE | CHCR_IE);
-	ctrl_outl(chcr, (dma_base_addr[chan->chan] + CHCR));
+	__raw_writel(chcr, (dma_base_addr[chan->chan] + CHCR));
 }
 
 static int sh_dmac_xfer_dma(struct dma_channel *chan)
@@ -183,12 +183,12 @@ static int sh_dmac_xfer_dma(struct dma_channel *chan)
 	 */
 	if (chan->sar || (mach_is_dreamcast() &&
 			  chan->chan == PVR2_CASCADE_CHAN))
-		ctrl_outl(chan->sar, (dma_base_addr[chan->chan]+SAR));
+		__raw_writel(chan->sar, (dma_base_addr[chan->chan]+SAR));
 	if (chan->dar || (mach_is_dreamcast() &&
 			  chan->chan == PVR2_CASCADE_CHAN))
-		ctrl_outl(chan->dar, (dma_base_addr[chan->chan] + DAR));
+		__raw_writel(chan->dar, (dma_base_addr[chan->chan] + DAR));
 
-	ctrl_outl(chan->count >> calc_xmit_shift(chan),
+	__raw_writel(chan->count >> calc_xmit_shift(chan),
 		(dma_base_addr[chan->chan] + TCR));
 
 	sh_dmac_enable_dma(chan);
@@ -198,10 +198,10 @@ static int sh_dmac_xfer_dma(struct dma_channel *chan)
 
 static int sh_dmac_get_dma_residue(struct dma_channel *chan)
 {
-	if (!(ctrl_inl(dma_base_addr[chan->chan] + CHCR) & CHCR_DE))
+	if (!(__raw_readl(dma_base_addr[chan->chan] + CHCR) & CHCR_DE))
 		return 0;
 
-	return ctrl_inl(dma_base_addr[chan->chan] + TCR)
+	return __raw_readl(dma_base_addr[chan->chan] + TCR)
 		 << calc_xmit_shift(chan);
 }
 

commit 988f831df398ff36f67b095245060c24c354e9e9
Author: Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
Date:   Mon Mar 16 03:22:07 2009 +0000

    sh: Move IRQ multi definition of DMAC to defconfig
    
    When SuperH CPU has IRQ multi of DMAC, SH_DMA_IRQ_MULTI becomes enable.
    The following CPU's are Multi IRQ of DMAC now.
     - SH775X and SH7091
     - SH776X
     - SH7780
     - SH7785
    
    If SH_DMA_IRQ_MULTI becomes enable, dma-sh api driver is optimized
    for Multi IRQ.
    
    Signed-off-by: Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index 31c2930f2f54..37fb5b8bbc3f 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -19,13 +19,6 @@
 #include <asm/io.h>
 #include <asm/dma-sh.h>
 
-#if defined(CONFIG_CPU_SUBTYPE_SH7763)	|| \
-		defined(CONFIG_CPU_SUBTYPE_SH7764)	|| \
-		defined(CONFIG_CPU_SUBTYPE_SH7780)	|| \
-		defined(CONFIG_CPU_SUBTYPE_SH7785)
-#define DMAC_IRQ_MULTI	1
-#endif
-
 #if defined(DMAE1_IRQ)
 #define NR_DMAE		2
 #else
@@ -42,7 +35,7 @@ static inline unsigned int get_dmte_irq(unsigned int chan)
 	if (chan < ARRAY_SIZE(dmte_irq_map))
 		irq = dmte_irq_map[chan];
 
-#if defined(DMAC_IRQ_MULTI)
+#if defined(CONFIG_SH_DMA_IRQ_MULTI)
 	if (irq > DMTE6_IRQ)
 		return DMTE6_IRQ;
 	return DMTE0_IRQ;
@@ -96,7 +89,7 @@ static int sh_dmac_request_dma(struct dma_channel *chan)
 		return 0;
 
 	return request_irq(get_dmte_irq(chan->chan), dma_tei,
-#if defined(DMAC_IRQ_MULTI)
+#if defined(CONFIG_SH_DMA_IRQ_MULTI)
 				IRQF_SHARED,
 #else
 				IRQF_DISABLED,
@@ -235,7 +228,7 @@ static inline int dmaor_reset(int no)
 #if defined(CONFIG_CPU_SH4)
 static irqreturn_t dma_err(int irq, void *dummy)
 {
-#if defined(DMAC_IRQ_MULTI)
+#if defined(CONFIG_SH_DMA_IRQ_MULTI)
 	int cnt = 0;
 	switch (irq) {
 #if defined(DMTE6_IRQ) && defined(DMAE1_IRQ)
@@ -283,7 +276,7 @@ static struct dma_info sh_dmac_info = {
 #ifdef CONFIG_CPU_SH4
 static unsigned int get_dma_error_irq(int n)
 {
-#if defined(DMAC_IRQ_MULTI)
+#if defined(CONFIG_SH_DMA_IRQ_MULTI)
 	return (n == 0) ? get_dmte_irq(0) : get_dmte_irq(6);
 #else
 	return (n == 0) ? DMAE0_IRQ :
@@ -306,7 +299,7 @@ static int __init sh_dmac_init(void)
 
 	for (n = 0; n < NR_DMAE; n++) {
 		i = request_irq(get_dma_error_irq(n), dma_err,
-#if defined(DMAC_IRQ_MULTI)
+#if defined(CONFIG_SH_DMA_IRQ_MULTI)
 				IRQF_SHARED,
 #else
 				IRQF_DISABLED,

commit 02ebd32f52c10f90f810e85d0281e9e81dd6e741
Author: Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
Date:   Fri Mar 13 04:31:34 2009 +0000

    sh: Disable get_dma_error_irq for non-SH4 targets.
    
    dma-sh's get_dma_error_irq() is only used by SH4, as the SH3
    doesn't have the DMA Error interrupt.
    
    Disable it out for non-SH4 builds.
    
    Signed-off-by: Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index ab7b18dcbaba..31c2930f2f54 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -280,6 +280,7 @@ static struct dma_info sh_dmac_info = {
 	.flags		= DMAC_CHANNELS_TEI_CAPABLE,
 };
 
+#ifdef CONFIG_CPU_SH4
 static unsigned int get_dma_error_irq(int n)
 {
 #if defined(DMAC_IRQ_MULTI)
@@ -293,6 +294,7 @@ static unsigned int get_dma_error_irq(int n)
 #endif
 #endif
 }
+#endif
 
 static int __init sh_dmac_init(void)
 {

commit 71b973a42c5456824c8712e00659d9616d395919
Author: Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
Date:   Tue Mar 10 17:26:49 2009 +0900

    sh: dma-sh updates for multi IRQ and new SH-4A CPUs.
    
    This adds DMA support for newer SH-4A CPUs, particularly SH7763/64/80/85.
    
    This also enables multi IRQ support for platforms that have multiple
    vectors bound to the same IRQ source.
    
    Signed-off-by: Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
    Signed-off-by: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index 50887a592dd0..ab7b18dcbaba 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -17,28 +17,23 @@
 #include <mach-dreamcast/mach/dma.h>
 #include <asm/dma.h>
 #include <asm/io.h>
-#include "dma-sh.h"
-
-static int dmte_irq_map[] = {
-	DMTE0_IRQ,
-	DMTE1_IRQ,
-	DMTE2_IRQ,
-	DMTE3_IRQ,
-#if defined(CONFIG_CPU_SUBTYPE_SH7720)  ||	\
-    defined(CONFIG_CPU_SUBTYPE_SH7721)  ||	\
-    defined(CONFIG_CPU_SUBTYPE_SH7751R) ||	\
-    defined(CONFIG_CPU_SUBTYPE_SH7760)  ||	\
-    defined(CONFIG_CPU_SUBTYPE_SH7709)  ||	\
-    defined(CONFIG_CPU_SUBTYPE_SH7780)
-	DMTE4_IRQ,
-	DMTE5_IRQ,
+#include <asm/dma-sh.h>
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7763)	|| \
+		defined(CONFIG_CPU_SUBTYPE_SH7764)	|| \
+		defined(CONFIG_CPU_SUBTYPE_SH7780)	|| \
+		defined(CONFIG_CPU_SUBTYPE_SH7785)
+#define DMAC_IRQ_MULTI	1
 #endif
-#if defined(CONFIG_CPU_SUBTYPE_SH7751R) ||	\
-    defined(CONFIG_CPU_SUBTYPE_SH7760)  ||	\
-    defined(CONFIG_CPU_SUBTYPE_SH7780)
-	DMTE6_IRQ,
-	DMTE7_IRQ,
+
+#if defined(DMAE1_IRQ)
+#define NR_DMAE		2
+#else
+#define NR_DMAE		1
 #endif
+
+static const char *dmae_name[] = {
+	"DMAC Address Error0", "DMAC Address Error1"
 };
 
 static inline unsigned int get_dmte_irq(unsigned int chan)
@@ -46,7 +41,14 @@ static inline unsigned int get_dmte_irq(unsigned int chan)
 	unsigned int irq = 0;
 	if (chan < ARRAY_SIZE(dmte_irq_map))
 		irq = dmte_irq_map[chan];
+
+#if defined(DMAC_IRQ_MULTI)
+	if (irq > DMTE6_IRQ)
+		return DMTE6_IRQ;
+	return DMTE0_IRQ;
+#else
 	return irq;
+#endif
 }
 
 /*
@@ -59,7 +61,7 @@ static inline unsigned int get_dmte_irq(unsigned int chan)
  */
 static inline unsigned int calc_xmit_shift(struct dma_channel *chan)
 {
-	u32 chcr = ctrl_inl(CHCR[chan->chan]);
+	u32 chcr = ctrl_inl(dma_base_addr[chan->chan] + CHCR);
 
 	return ts_shift[(chcr & CHCR_TS_MASK)>>CHCR_TS_SHIFT];
 }
@@ -75,13 +77,13 @@ static irqreturn_t dma_tei(int irq, void *dev_id)
 	struct dma_channel *chan = dev_id;
 	u32 chcr;
 
-	chcr = ctrl_inl(CHCR[chan->chan]);
+	chcr = ctrl_inl(dma_base_addr[chan->chan] + CHCR);
 
 	if (!(chcr & CHCR_TE))
 		return IRQ_NONE;
 
 	chcr &= ~(CHCR_IE | CHCR_DE);
-	ctrl_outl(chcr, CHCR[chan->chan]);
+	ctrl_outl(chcr, (dma_base_addr[chan->chan] + CHCR));
 
 	wake_up(&chan->wait_queue);
 
@@ -94,7 +96,12 @@ static int sh_dmac_request_dma(struct dma_channel *chan)
 		return 0;
 
 	return request_irq(get_dmte_irq(chan->chan), dma_tei,
-			   IRQF_DISABLED, chan->dev_id, chan);
+#if defined(DMAC_IRQ_MULTI)
+				IRQF_SHARED,
+#else
+				IRQF_DISABLED,
+#endif
+				chan->dev_id, chan);
 }
 
 static void sh_dmac_free_dma(struct dma_channel *chan)
@@ -115,7 +122,7 @@ sh_dmac_configure_channel(struct dma_channel *chan, unsigned long chcr)
 		chan->flags &= ~DMA_TEI_CAPABLE;
 	}
 
-	ctrl_outl(chcr, CHCR[chan->chan]);
+	ctrl_outl(chcr, (dma_base_addr[chan->chan] + CHCR));
 
 	chan->flags |= DMA_CONFIGURED;
 	return 0;
@@ -126,13 +133,13 @@ static void sh_dmac_enable_dma(struct dma_channel *chan)
 	int irq;
 	u32 chcr;
 
-	chcr = ctrl_inl(CHCR[chan->chan]);
+	chcr = ctrl_inl(dma_base_addr[chan->chan] + CHCR);
 	chcr |= CHCR_DE;
 
 	if (chan->flags & DMA_TEI_CAPABLE)
 		chcr |= CHCR_IE;
 
-	ctrl_outl(chcr, CHCR[chan->chan]);
+	ctrl_outl(chcr, (dma_base_addr[chan->chan] + CHCR));
 
 	if (chan->flags & DMA_TEI_CAPABLE) {
 		irq = get_dmte_irq(chan->chan);
@@ -150,9 +157,9 @@ static void sh_dmac_disable_dma(struct dma_channel *chan)
 		disable_irq(irq);
 	}
 
-	chcr = ctrl_inl(CHCR[chan->chan]);
+	chcr = ctrl_inl(dma_base_addr[chan->chan] + CHCR);
 	chcr &= ~(CHCR_DE | CHCR_TE | CHCR_IE);
-	ctrl_outl(chcr, CHCR[chan->chan]);
+	ctrl_outl(chcr, (dma_base_addr[chan->chan] + CHCR));
 }
 
 static int sh_dmac_xfer_dma(struct dma_channel *chan)
@@ -183,12 +190,13 @@ static int sh_dmac_xfer_dma(struct dma_channel *chan)
 	 */
 	if (chan->sar || (mach_is_dreamcast() &&
 			  chan->chan == PVR2_CASCADE_CHAN))
-		ctrl_outl(chan->sar, SAR[chan->chan]);
+		ctrl_outl(chan->sar, (dma_base_addr[chan->chan]+SAR));
 	if (chan->dar || (mach_is_dreamcast() &&
 			  chan->chan == PVR2_CASCADE_CHAN))
-		ctrl_outl(chan->dar, DAR[chan->chan]);
+		ctrl_outl(chan->dar, (dma_base_addr[chan->chan] + DAR));
 
-	ctrl_outl(chan->count >> calc_xmit_shift(chan), DMATCR[chan->chan]);
+	ctrl_outl(chan->count >> calc_xmit_shift(chan),
+		(dma_base_addr[chan->chan] + TCR));
 
 	sh_dmac_enable_dma(chan);
 
@@ -197,36 +205,26 @@ static int sh_dmac_xfer_dma(struct dma_channel *chan)
 
 static int sh_dmac_get_dma_residue(struct dma_channel *chan)
 {
-	if (!(ctrl_inl(CHCR[chan->chan]) & CHCR_DE))
+	if (!(ctrl_inl(dma_base_addr[chan->chan] + CHCR) & CHCR_DE))
 		return 0;
 
-	return ctrl_inl(DMATCR[chan->chan]) << calc_xmit_shift(chan);
+	return ctrl_inl(dma_base_addr[chan->chan] + TCR)
+		 << calc_xmit_shift(chan);
 }
 
-#if defined(CONFIG_CPU_SUBTYPE_SH7720) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7721) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7780) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7709)
-#define dmaor_read_reg()	ctrl_inw(DMAOR)
-#define dmaor_write_reg(data)	ctrl_outw(data, DMAOR)
-#else
-#define dmaor_read_reg()	ctrl_inl(DMAOR)
-#define dmaor_write_reg(data)	ctrl_outl(data, DMAOR)
-#endif
-
-static inline int dmaor_reset(void)
+static inline int dmaor_reset(int no)
 {
-	unsigned long dmaor = dmaor_read_reg();
+	unsigned long dmaor = dmaor_read_reg(no);
 
 	/* Try to clear the error flags first, incase they are set */
 	dmaor &= ~(DMAOR_NMIF | DMAOR_AE);
-	dmaor_write_reg(dmaor);
+	dmaor_write_reg(no, dmaor);
 
 	dmaor |= DMAOR_INIT;
-	dmaor_write_reg(dmaor);
+	dmaor_write_reg(no, dmaor);
 
 	/* See if we got an error again */
-	if ((dmaor_read_reg() & (DMAOR_AE | DMAOR_NMIF))) {
+	if ((dmaor_read_reg(no) & (DMAOR_AE | DMAOR_NMIF))) {
 		printk(KERN_ERR "dma-sh: Can't initialize DMAOR.\n");
 		return -EINVAL;
 	}
@@ -237,10 +235,33 @@ static inline int dmaor_reset(void)
 #if defined(CONFIG_CPU_SH4)
 static irqreturn_t dma_err(int irq, void *dummy)
 {
-	dmaor_reset();
+#if defined(DMAC_IRQ_MULTI)
+	int cnt = 0;
+	switch (irq) {
+#if defined(DMTE6_IRQ) && defined(DMAE1_IRQ)
+	case DMTE6_IRQ:
+		cnt++;
+#endif
+	case DMTE0_IRQ:
+		if (dmaor_read_reg(cnt) & (DMAOR_NMIF | DMAOR_AE)) {
+			disable_irq(irq);
+			/* DMA multi and error IRQ */
+			return IRQ_HANDLED;
+		}
+	default:
+		return IRQ_NONE;
+	}
+#else
+	dmaor_reset(0);
+#if defined(CONFIG_CPU_SUBTYPE_SH7723)	|| \
+		defined(CONFIG_CPU_SUBTYPE_SH7780)	|| \
+		defined(CONFIG_CPU_SUBTYPE_SH7785)
+	dmaor_reset(1);
+#endif
 	disable_irq(irq);
 
 	return IRQ_HANDLED;
+#endif
 }
 #endif
 
@@ -259,24 +280,57 @@ static struct dma_info sh_dmac_info = {
 	.flags		= DMAC_CHANNELS_TEI_CAPABLE,
 };
 
+static unsigned int get_dma_error_irq(int n)
+{
+#if defined(DMAC_IRQ_MULTI)
+	return (n == 0) ? get_dmte_irq(0) : get_dmte_irq(6);
+#else
+	return (n == 0) ? DMAE0_IRQ :
+#if defined(DMAE1_IRQ)
+				DMAE1_IRQ;
+#else
+				-1;
+#endif
+#endif
+}
+
 static int __init sh_dmac_init(void)
 {
 	struct dma_info *info = &sh_dmac_info;
 	int i;
 
 #ifdef CONFIG_CPU_SH4
-	i = request_irq(DMAE_IRQ, dma_err, IRQF_DISABLED, "DMAC Address Error", 0);
-	if (unlikely(i < 0))
-		return i;
+	int n;
+
+	for (n = 0; n < NR_DMAE; n++) {
+		i = request_irq(get_dma_error_irq(n), dma_err,
+#if defined(DMAC_IRQ_MULTI)
+				IRQF_SHARED,
+#else
+				IRQF_DISABLED,
 #endif
+				dmae_name[n], (void *)dmae_name[n]);
+		if (unlikely(i < 0)) {
+			printk(KERN_ERR "%s request_irq fail\n", dmae_name[n]);
+			return i;
+		}
+	}
+#endif /* CONFIG_CPU_SH4 */
 
 	/*
 	 * Initialize DMAOR, and clean up any error flags that may have
 	 * been set.
 	 */
-	i = dmaor_reset();
+	i = dmaor_reset(0);
+	if (unlikely(i != 0))
+		return i;
+#if defined(CONFIG_CPU_SUBTYPE_SH7723)	|| \
+		defined(CONFIG_CPU_SUBTYPE_SH7780)	|| \
+		defined(CONFIG_CPU_SUBTYPE_SH7785)
+	i = dmaor_reset(1);
 	if (unlikely(i != 0))
 		return i;
+#endif
 
 	return register_dmac(info);
 }
@@ -284,8 +338,12 @@ static int __init sh_dmac_init(void)
 static void __exit sh_dmac_exit(void)
 {
 #ifdef CONFIG_CPU_SH4
-	free_irq(DMAE_IRQ, 0);
-#endif
+	int n;
+
+	for (n = 0; n < NR_DMAE; n++) {
+		free_irq(get_dma_error_irq(n), (void *)dmae_name[n]);
+	}
+#endif /* CONFIG_CPU_SH4 */
 	unregister_dmac(&sh_dmac_info);
 }
 

commit c2c5883b3fce61388eb02ca328072400eb54769c
Author: Steve Glendinning <steve.glendinning@smsc.com>
Date:   Sun Nov 23 14:27:22 2008 +0000

    sh: fix DMAOR register access on SH7709
    
    sh7709 hardware manual says DMAOR is 16 bits long on this platform.
    
    Tested and working with a modified smsc911x ethernet driver (sh-dma
    support patch for this driver is coming soon).
    
    Signed-off-by: Steve Glendinning <steve.glendinning@smsc.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index b2ffe649c7c0..50887a592dd0 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -205,7 +205,8 @@ static int sh_dmac_get_dma_residue(struct dma_channel *chan)
 
 #if defined(CONFIG_CPU_SUBTYPE_SH7720) || \
     defined(CONFIG_CPU_SUBTYPE_SH7721) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7780)
+    defined(CONFIG_CPU_SUBTYPE_SH7780) || \
+    defined(CONFIG_CPU_SUBTYPE_SH7709)
 #define dmaor_read_reg()	ctrl_inw(DMAOR)
 #define dmaor_write_reg(data)	ctrl_outw(data, DMAOR)
 #else

commit 71b8064e7df5698520d73b4c1566a3dbc98eb9ef
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jul 29 20:20:36 2008 +0900

    sh: dma-sh: Fix up dreamcast dma.h mach path.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index bd305483c144..b2ffe649c7c0 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -14,7 +14,7 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
-#include <mach/dma.h>
+#include <mach-dreamcast/mach/dma.h>
 #include <asm/dma.h>
 #include <asm/io.h>
 #include "dma-sh.h"

commit f15cbe6f1a4b4d9df59142fc8e4abb973302cf44
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jul 29 08:09:44 2008 +0900

    sh: migrate to arch/sh/include/
    
    This follows the sparc changes a439fe51a1f8eb087c22dd24d69cebae4a3addac.
    
    Most of the moving about was done with Sam's directions at:
    
    http://marc.info/?l=linux-sh&m=121724823706062&w=2
    
    with subsequent hacking and fixups entirely my fault.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index 71ff3d6f26e2..bd305483c144 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -14,7 +14,7 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
-#include <asm/dreamcast/dma.h>
+#include <mach/dma.h>
 #include <asm/dma.h>
 #include <asm/io.h>
 #include "dma-sh.h"

commit b2d7c7f7a69fd953626c3e507bac70e18b21f70e
Author: Julia Lawall <julia@diku.dk>
Date:   Tue Feb 26 21:42:11 2008 +0100

    arch/sh/drivers/dma/dma-sh.c: Correct use of ! and &
    
    In commit e6bafba5b4765a5a252f1b8d31cbf6d2459da337, a bug was fixed that
    involved converting !x & y to !(x & y).  The code below shows the same
    pattern, and thus should perhaps be fixed in the same way.
    
    This is not tested and clearly changes the semantics, so it is only
    something to consider.
    
    The semantic patch that makes this change is as follows:
    (http://www.emn.fr/x-info/coccinelle/)
    
    // <smpl>
    @@ expression E1,E2; @@
    (
      !E1 & !E2
    |
    - !E1 & E2
    + !(E1 & E2)
    )
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index 5c3359756a92..71ff3d6f26e2 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -90,7 +90,7 @@ static irqreturn_t dma_tei(int irq, void *dev_id)
 
 static int sh_dmac_request_dma(struct dma_channel *chan)
 {
-	if (unlikely(!chan->flags & DMA_TEI_CAPABLE))
+	if (unlikely(!(chan->flags & DMA_TEI_CAPABLE)))
 		return 0;
 
 	return request_irq(get_dmte_irq(chan->chan), dma_tei,

commit 31a49c4bf8f964b7a9897baa889916d71b51d9c1
Author: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
Date:   Wed Dec 26 11:45:06 2007 +0900

    sh: Add support for SH7721 CPU subtype.
    
    Signed-off-by: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index 958bac1c585a..5c3359756a92 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -25,6 +25,7 @@ static int dmte_irq_map[] = {
 	DMTE2_IRQ,
 	DMTE3_IRQ,
 #if defined(CONFIG_CPU_SUBTYPE_SH7720)  ||	\
+    defined(CONFIG_CPU_SUBTYPE_SH7721)  ||	\
     defined(CONFIG_CPU_SUBTYPE_SH7751R) ||	\
     defined(CONFIG_CPU_SUBTYPE_SH7760)  ||	\
     defined(CONFIG_CPU_SUBTYPE_SH7709)  ||	\
@@ -203,6 +204,7 @@ static int sh_dmac_get_dma_residue(struct dma_channel *chan)
 }
 
 #if defined(CONFIG_CPU_SUBTYPE_SH7720) || \
+    defined(CONFIG_CPU_SUBTYPE_SH7721) || \
     defined(CONFIG_CPU_SUBTYPE_SH7780)
 #define dmaor_read_reg()	ctrl_inw(DMAOR)
 #define dmaor_write_reg(data)	ctrl_outw(data, DMAOR)

commit 4f247e84bdb81aab8880f556882a449782a1ea8b
Author: Kristoffer Ericson <Kristoffer.Ericson@gmail.com>
Date:   Tue Sep 11 12:49:59 2007 +0900

    sh: dma: Fix up build for SH7709 support.
    
    Trivial build fixes for SH7709.
    
    Signed-off-by: Kristoffer Ericson <Kristoffer.Ericson@gmail.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index 6e5f16cb0aa5..958bac1c585a 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -27,6 +27,7 @@ static int dmte_irq_map[] = {
 #if defined(CONFIG_CPU_SUBTYPE_SH7720)  ||	\
     defined(CONFIG_CPU_SUBTYPE_SH7751R) ||	\
     defined(CONFIG_CPU_SUBTYPE_SH7760)  ||	\
+    defined(CONFIG_CPU_SUBTYPE_SH7709)  ||	\
     defined(CONFIG_CPU_SUBTYPE_SH7780)
 	DMTE4_IRQ,
 	DMTE5_IRQ,

commit 3ea6bc3de4f15fcae84fb31eeea4d420685a3da2
Author: Markus Brunner <super.firetwister@gmail.com>
Date:   Mon Aug 20 08:59:33 2007 +0900

    sh: Add SH7720 CPU support.
    
    This adds support for the SH7720 (SH3-DSP) CPU.
    
    Signed-off by: Markus Brunner <super.firetwister@gmail.com>
    Signed-off by: Mark Jonas <toertel@gmail.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index 06ed0609a95d..6e5f16cb0aa5 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -24,13 +24,18 @@ static int dmte_irq_map[] = {
 	DMTE1_IRQ,
 	DMTE2_IRQ,
 	DMTE3_IRQ,
-#if defined(CONFIG_CPU_SUBTYPE_SH7751R) ||	\
+#if defined(CONFIG_CPU_SUBTYPE_SH7720)  ||	\
+    defined(CONFIG_CPU_SUBTYPE_SH7751R) ||	\
     defined(CONFIG_CPU_SUBTYPE_SH7760)  ||	\
     defined(CONFIG_CPU_SUBTYPE_SH7780)
 	DMTE4_IRQ,
 	DMTE5_IRQ,
+#endif
+#if defined(CONFIG_CPU_SUBTYPE_SH7751R) ||	\
+    defined(CONFIG_CPU_SUBTYPE_SH7760)  ||	\
+    defined(CONFIG_CPU_SUBTYPE_SH7780)
 	DMTE6_IRQ,
-	DMTE7_IRQ,    
+	DMTE7_IRQ,
 #endif
 };
 
@@ -196,7 +201,8 @@ static int sh_dmac_get_dma_residue(struct dma_channel *chan)
 	return ctrl_inl(DMATCR[chan->chan]) << calc_xmit_shift(chan);
 }
 
-#ifdef CONFIG_CPU_SUBTYPE_SH7780
+#if defined(CONFIG_CPU_SUBTYPE_SH7720) || \
+    defined(CONFIG_CPU_SUBTYPE_SH7780)
 #define dmaor_read_reg()	ctrl_inw(DMAOR)
 #define dmaor_write_reg(data)	ctrl_outw(data, DMAOR)
 #else

commit 9f8a5e3a44d81bbf19fddeb74645dec6b0e23b23
Author: Manuel Lauss <mano@roarinelk.homelinux.net>
Date:   Thu Jan 25 15:22:11 2007 +0900

    sh: SH-DMAC compile fixes
    
    This patch does the following:
    - remove the make_ipr_irq stuff from dma-sh.c and replace it
      with a simple channel<->irq mapping table.
    - add DMTEx_IRQ constants for sh4 cpus
    - fix sh7751 DMAE irq number
    
    The SH7780 uses the same IRQs for DMA as other SH4 types, so
    I put the constants on top of the dma.h file.
    
    Other CPU types need to #define their own DMTEx_IRQ contants
    in their appropriate header.
    
    Signed-off-by: Manuel Lauss <mano@roarinelk.homelinux.net>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index f63721ed86c2..06ed0609a95d 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -19,34 +19,26 @@
 #include <asm/io.h>
 #include "dma-sh.h"
 
-
-
-#ifdef CONFIG_CPU_SH4
-static struct ipr_data dmae_ipr_map[] = {
-	{ DMAE_IRQ, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
-};
+static int dmte_irq_map[] = {
+	DMTE0_IRQ,
+	DMTE1_IRQ,
+	DMTE2_IRQ,
+	DMTE3_IRQ,
+#if defined(CONFIG_CPU_SUBTYPE_SH7751R) ||	\
+    defined(CONFIG_CPU_SUBTYPE_SH7760)  ||	\
+    defined(CONFIG_CPU_SUBTYPE_SH7780)
+	DMTE4_IRQ,
+	DMTE5_IRQ,
+	DMTE6_IRQ,
+	DMTE7_IRQ,    
 #endif
-static struct ipr_data dmte_ipr_map[] = {
-	/*
-	 * Normally we could just do DMTE0_IRQ + chan outright, though in the
-	 * case of the 7751R, the DMTE IRQs for channels > 4 start right above
-	 * the SCIF
-	 */
-	{ DMTE0_IRQ + 0, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
-	{ DMTE0_IRQ + 1, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
-	{ DMTE0_IRQ + 2, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
-	{ DMTE0_IRQ + 3, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
-	{ DMTE4_IRQ + 0, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
-	{ DMTE4_IRQ + 1, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
-	{ DMTE4_IRQ + 2, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
-	{ DMTE4_IRQ + 3, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
 };
 
 static inline unsigned int get_dmte_irq(unsigned int chan)
 {
 	unsigned int irq = 0;
-	if (chan < ARRAY_SIZE(dmte_ipr_map))
-		irq = dmte_ipr_map[chan].irq;
+	if (chan < ARRAY_SIZE(dmte_irq_map))
+		irq = dmte_irq_map[chan];
 	return irq;
 }
 
@@ -103,7 +95,7 @@ static void sh_dmac_free_dma(struct dma_channel *chan)
 	free_irq(get_dmte_irq(chan->chan), chan);
 }
 
-static void
+static int
 sh_dmac_configure_channel(struct dma_channel *chan, unsigned long chcr)
 {
 	if (!chcr)
@@ -119,6 +111,7 @@ sh_dmac_configure_channel(struct dma_channel *chan, unsigned long chcr)
 	ctrl_outl(chcr, CHCR[chan->chan]);
 
 	chan->flags |= DMA_CONFIGURED;
+	return 0;
 }
 
 static void sh_dmac_enable_dma(struct dma_channel *chan)
@@ -262,17 +255,11 @@ static int __init sh_dmac_init(void)
 	int i;
 
 #ifdef CONFIG_CPU_SH4
-	make_ipr_irq(dmae_ipr_map, ARRAY_SIZE(dmae_ipr_map));
 	i = request_irq(DMAE_IRQ, dma_err, IRQF_DISABLED, "DMAC Address Error", 0);
 	if (unlikely(i < 0))
 		return i;
 #endif
 
-	i = info->nr_channels;
-	if (i > ARRAY_SIZE(dmte_ipr_map))
-		i = ARRAY_SIZE(dmte_ipr_map);
-	make_ipr_irq(dmte_ipr_map, i);
-
 	/*
 	 * Initialize DMAOR, and clean up any error flags that may have
 	 * been set.

commit e803aaf63a18b26668fbfbfd41c65527bcc10532
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Nov 24 14:50:05 2006 +0900

    sh: Drop name overload in dma-sh.
    
    Pass along the dev_id from request_dma() all the way down,
    rather than inserting an artificial name relating to the TEI
    line that we were doing before.
    
    This makes the line a bit less obvious, but dev_id is the proper
    behaviour for this regardless.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index 660786013350..f63721ed86c2 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -94,20 +94,13 @@ static int sh_dmac_request_dma(struct dma_channel *chan)
 	if (unlikely(!chan->flags & DMA_TEI_CAPABLE))
 		return 0;
 
-	chan->name = kzalloc(32, GFP_KERNEL);
-	if (unlikely(chan->name == NULL))
-		return -ENOMEM;
-	snprintf(chan->name, 32, "DMAC Transfer End (Channel %d)",
-		 chan->chan);
-
 	return request_irq(get_dmte_irq(chan->chan), dma_tei,
-			   IRQF_DISABLED, chan->name, chan);
+			   IRQF_DISABLED, chan->dev_id, chan);
 }
 
 static void sh_dmac_free_dma(struct dma_channel *chan)
 {
 	free_irq(get_dmte_irq(chan->chan), chan);
-	kfree(chan->name);
 }
 
 static void

commit bd71ab88deab3358241f22ed6c035c427aacc4e7
Author: Jamie Lenehan <lenehan@twibble.org>
Date:   Tue Oct 31 12:35:02 2006 +0900

    sh: Fix IPR-IRQ's for IRQ-chip change breakage.
    
    The conversion from IPR-IRQ to IRQ-chip resulted in the
    ipr data being allocated in a local variable in
    make_ipr_irq - breaking anything using IPR interrupts.
    
    This changes all of the callers of make_ipr_irq to
    allocate a static structure containing the IPR data which
    is then passed to make_ipr_irq. This removes the need for
    make_ipr_irq to allocate any additional space for the IPR
    information.
    
    Signed-off-by: Jamie Lenehan <lenehan@twibble.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index d8ece20bb2cf..660786013350 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -19,23 +19,34 @@
 #include <asm/io.h>
 #include "dma-sh.h"
 
-static inline unsigned int get_dmte_irq(unsigned int chan)
-{
-	unsigned int irq = 0;
 
+
+#ifdef CONFIG_CPU_SH4
+static struct ipr_data dmae_ipr_map[] = {
+	{ DMAE_IRQ, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
+};
+#endif
+static struct ipr_data dmte_ipr_map[] = {
 	/*
 	 * Normally we could just do DMTE0_IRQ + chan outright, though in the
 	 * case of the 7751R, the DMTE IRQs for channels > 4 start right above
 	 * the SCIF
 	 */
-	if (chan < 4) {
-		irq = DMTE0_IRQ + chan;
-	} else {
-#ifdef DMTE4_IRQ
-		irq = DMTE4_IRQ + chan - 4;
-#endif
-	}
+	{ DMTE0_IRQ + 0, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
+	{ DMTE0_IRQ + 1, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
+	{ DMTE0_IRQ + 2, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
+	{ DMTE0_IRQ + 3, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
+	{ DMTE4_IRQ + 0, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
+	{ DMTE4_IRQ + 1, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
+	{ DMTE4_IRQ + 2, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
+	{ DMTE4_IRQ + 3, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
+};
 
+static inline unsigned int get_dmte_irq(unsigned int chan)
+{
+	unsigned int irq = 0;
+	if (chan < ARRAY_SIZE(dmte_ipr_map))
+		irq = dmte_ipr_map[chan].irq;
 	return irq;
 }
 
@@ -258,17 +269,16 @@ static int __init sh_dmac_init(void)
 	int i;
 
 #ifdef CONFIG_CPU_SH4
-	make_ipr_irq(DMAE_IRQ, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY);
+	make_ipr_irq(dmae_ipr_map, ARRAY_SIZE(dmae_ipr_map));
 	i = request_irq(DMAE_IRQ, dma_err, IRQF_DISABLED, "DMAC Address Error", 0);
 	if (unlikely(i < 0))
 		return i;
 #endif
 
-	for (i = 0; i < info->nr_channels; i++) {
-		int irq = get_dmte_irq(i);
-
-		make_ipr_irq(irq, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY);
-	}
+	i = info->nr_channels;
+	if (i > ARRAY_SIZE(dmte_ipr_map))
+		i = ARRAY_SIZE(dmte_ipr_map);
+	make_ipr_irq(dmte_ipr_map, i);
 
 	/*
 	 * Initialize DMAOR, and clean up any error flags that may have

commit 35f3c5185b1e28e6591aa649db8bf4fa16f1a7f3
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Oct 6 15:31:16 2006 +0900

    sh: Updates for IRQ handler changes.
    
    Trivial fixes for build breakage introduced by IRQ handler changes.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index cbbe8bce3d67..d8ece20bb2cf 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -60,9 +60,9 @@ static inline unsigned int calc_xmit_shift(struct dma_channel *chan)
  * Besides that it needs to waken any waiting process, which should handle
  * setting up the next transfer.
  */
-static irqreturn_t dma_tei(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t dma_tei(int irq, void *dev_id)
 {
-	struct dma_channel *chan = (struct dma_channel *)dev_id;
+	struct dma_channel *chan = dev_id;
 	u32 chcr;
 
 	chcr = ctrl_inl(CHCR[chan->chan]);
@@ -228,7 +228,7 @@ static inline int dmaor_reset(void)
 }
 
 #if defined(CONFIG_CPU_SH4)
-static irqreturn_t dma_err(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t dma_err(int irq, void *dummy)
 {
 	dmaor_reset();
 	disable_irq(irq);

commit 0f08f338083cc1d68788ccbccc44bd0502fc57ae
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 17:03:56 2006 +0900

    sh: More cosmetic cleanups and trivial fixes.
    
    Nothing exciting here, just trivial fixes..
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index 40a480d20aaf..cbbe8bce3d67 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -80,21 +80,23 @@ static irqreturn_t dma_tei(int irq, void *dev_id, struct pt_regs *regs)
 
 static int sh_dmac_request_dma(struct dma_channel *chan)
 {
-	char name[32];
-
 	if (unlikely(!chan->flags & DMA_TEI_CAPABLE))
 		return 0;
 
-	snprintf(name, sizeof(name), "DMAC Transfer End (Channel %d)",
+	chan->name = kzalloc(32, GFP_KERNEL);
+	if (unlikely(chan->name == NULL))
+		return -ENOMEM;
+	snprintf(chan->name, 32, "DMAC Transfer End (Channel %d)",
 		 chan->chan);
 
 	return request_irq(get_dmte_irq(chan->chan), dma_tei,
-			   IRQF_DISABLED, name, chan);
+			   IRQF_DISABLED, chan->name, chan);
 }
 
 static void sh_dmac_free_dma(struct dma_channel *chan)
 {
 	free_irq(get_dmte_irq(chan->chan), chan);
+	kfree(chan->name);
 }
 
 static void

commit 9e3043c091819729ecf4fc5063d0a2d0954dfd7f
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 16:55:24 2006 +0900

    sh: Fixup TEI IRQ requests in request_dma().
    
    If a channel is not TEI capable, don't try to request_irq()..
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index 4428ee809651..40a480d20aaf 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -82,6 +82,9 @@ static int sh_dmac_request_dma(struct dma_channel *chan)
 {
 	char name[32];
 
+	if (unlikely(!chan->flags & DMA_TEI_CAPABLE))
+		return 0;
+
 	snprintf(name, sizeof(name), "DMAC Transfer End (Channel %d)",
 		 chan->chan);
 
@@ -255,7 +258,7 @@ static int __init sh_dmac_init(void)
 #ifdef CONFIG_CPU_SH4
 	make_ipr_irq(DMAE_IRQ, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY);
 	i = request_irq(DMAE_IRQ, dma_err, IRQF_DISABLED, "DMAC Address Error", 0);
-	if (i < 0)
+	if (unlikely(i < 0))
 		return i;
 #endif
 
@@ -270,7 +273,7 @@ static int __init sh_dmac_init(void)
 	 * been set.
 	 */
 	i = dmaor_reset();
-	if (i < 0)
+	if (unlikely(i != 0))
 		return i;
 
 	return register_dmac(info);

commit 5283ecb5ccbdb90d49fce6488d3944bba63a591c
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 15:59:17 2006 +0900

    sh: Add support for R7780RP and R7780MP boards.
    
    This adds support for the Renesas SH7780 development boards,
    R7780RP and R7780MP.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index e028a2d2a4ea..4428ee809651 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -11,14 +11,10 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  */
-
 #include <linux/init.h>
-#include <linux/irq.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
 #include <asm/dreamcast/dma.h>
-#include <asm/signal.h>
-#include <asm/irq.h>
 #include <asm/dma.h>
 #include <asm/io.h>
 #include "dma-sh.h"

commit 6d20819f8050092d40e9c99c55d82c8e26d42599
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:25 2006 -0700

    [PATCH] irq-flags: SH: Use the new IRQF_ constants
    
    Use the new IRQF_ constants and remove the SA_INTERRUPT define
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Kazumoto Kojima <kkojima@rr.iij4u.or.jp>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index fecd8f8d0466..e028a2d2a4ea 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -90,7 +90,7 @@ static int sh_dmac_request_dma(struct dma_channel *chan)
 		 chan->chan);
 
 	return request_irq(get_dmte_irq(chan->chan), dma_tei,
-			   SA_INTERRUPT, name, chan);
+			   IRQF_DISABLED, name, chan);
 }
 
 static void sh_dmac_free_dma(struct dma_channel *chan)
@@ -258,7 +258,7 @@ static int __init sh_dmac_init(void)
 
 #ifdef CONFIG_CPU_SH4
 	make_ipr_irq(DMAE_IRQ, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY);
-	i = request_irq(DMAE_IRQ, dma_err, SA_INTERRUPT, "DMAC Address Error", 0);
+	i = request_irq(DMAE_IRQ, dma_err, IRQF_DISABLED, "DMAC Address Error", 0);
 	if (i < 0)
 		return i;
 #endif

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index cca26c4c9d1b..fecd8f8d0466 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -12,7 +12,6 @@
  * for more details.
  */
 
-#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/irq.h>
 #include <linux/interrupt.h>

commit 0d831770b154a057562236e8cf50905c8f1ae1b0
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Jan 16 22:14:09 2006 -0800

    [PATCH] sh: DMA updates
    
    This extends the current SH DMA API somewhat to support a proper virtual
    channel abstraction, and also works to represent this through the driver model
    by giving each DMAC its own platform device.
    
    There's also a few other minor changes to support a few new CPU subtypes, and
    make TEI generation for the SH DMAC configurable.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
index 31dacd4444b2..cca26c4c9d1b 100644
--- a/arch/sh/drivers/dma/dma-sh.c
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -5,6 +5,7 @@
  *
  * Copyright (C) 2000 Takashi YOSHII
  * Copyright (C) 2003, 2004 Paul Mundt
+ * Copyright (C) 2005 Andriy Skulysh
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -16,51 +17,28 @@
 #include <linux/irq.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <asm/dreamcast/dma.h>
 #include <asm/signal.h>
 #include <asm/irq.h>
 #include <asm/dma.h>
 #include <asm/io.h>
 #include "dma-sh.h"
 
-/*
- * The SuperH DMAC supports a number of transmit sizes, we list them here,
- * with their respective values as they appear in the CHCR registers.
- *
- * Defaults to a 64-bit transfer size.
- */
-enum {
-	XMIT_SZ_64BIT,
-	XMIT_SZ_8BIT,
-	XMIT_SZ_16BIT,
-	XMIT_SZ_32BIT,
-	XMIT_SZ_256BIT,
-};
-
-/*
- * The DMA count is defined as the number of bytes to transfer.
- */
-static unsigned int ts_shift[] = {
-	[XMIT_SZ_64BIT]		= 3,
-	[XMIT_SZ_8BIT]		= 0,
-	[XMIT_SZ_16BIT]		= 1,
-	[XMIT_SZ_32BIT]		= 2,
-	[XMIT_SZ_256BIT]	= 5,
-};
-
 static inline unsigned int get_dmte_irq(unsigned int chan)
 {
-	unsigned int irq;
+	unsigned int irq = 0;
 
 	/*
 	 * Normally we could just do DMTE0_IRQ + chan outright, though in the
 	 * case of the 7751R, the DMTE IRQs for channels > 4 start right above
 	 * the SCIF
 	 */
-
 	if (chan < 4) {
 		irq = DMTE0_IRQ + chan;
 	} else {
+#ifdef DMTE4_IRQ
 		irq = DMTE4_IRQ + chan - 4;
+#endif
 	}
 
 	return irq;
@@ -78,9 +56,7 @@ static inline unsigned int calc_xmit_shift(struct dma_channel *chan)
 {
 	u32 chcr = ctrl_inl(CHCR[chan->chan]);
 
-	chcr >>= 4;
-
-	return ts_shift[chcr & 0x0007];
+	return ts_shift[(chcr & CHCR_TS_MASK)>>CHCR_TS_SHIFT];
 }
 
 /*
@@ -109,8 +85,13 @@ static irqreturn_t dma_tei(int irq, void *dev_id, struct pt_regs *regs)
 
 static int sh_dmac_request_dma(struct dma_channel *chan)
 {
+	char name[32];
+
+	snprintf(name, sizeof(name), "DMAC Transfer End (Channel %d)",
+		 chan->chan);
+
 	return request_irq(get_dmte_irq(chan->chan), dma_tei,
-			   SA_INTERRUPT, "DMAC Transfer End", chan);
+			   SA_INTERRUPT, name, chan);
 }
 
 static void sh_dmac_free_dma(struct dma_channel *chan)
@@ -118,10 +99,18 @@ static void sh_dmac_free_dma(struct dma_channel *chan)
 	free_irq(get_dmte_irq(chan->chan), chan);
 }
 
-static void sh_dmac_configure_channel(struct dma_channel *chan, unsigned long chcr)
+static void
+sh_dmac_configure_channel(struct dma_channel *chan, unsigned long chcr)
 {
 	if (!chcr)
-		chcr = RS_DUAL;
+		chcr = RS_DUAL | CHCR_IE;
+
+	if (chcr & CHCR_IE) {
+		chcr &= ~CHCR_IE;
+		chan->flags |= DMA_TEI_CAPABLE;
+	} else {
+		chan->flags &= ~DMA_TEI_CAPABLE;
+	}
 
 	ctrl_outl(chcr, CHCR[chan->chan]);
 
@@ -130,22 +119,32 @@ static void sh_dmac_configure_channel(struct dma_channel *chan, unsigned long ch
 
 static void sh_dmac_enable_dma(struct dma_channel *chan)
 {
-	int irq = get_dmte_irq(chan->chan);
+	int irq;
 	u32 chcr;
 
 	chcr = ctrl_inl(CHCR[chan->chan]);
-	chcr |= CHCR_DE | CHCR_IE;
+	chcr |= CHCR_DE;
+
+	if (chan->flags & DMA_TEI_CAPABLE)
+		chcr |= CHCR_IE;
+
 	ctrl_outl(chcr, CHCR[chan->chan]);
 
-	enable_irq(irq);
+	if (chan->flags & DMA_TEI_CAPABLE) {
+		irq = get_dmte_irq(chan->chan);
+		enable_irq(irq);
+	}
 }
 
 static void sh_dmac_disable_dma(struct dma_channel *chan)
 {
-	int irq = get_dmte_irq(chan->chan);
+	int irq;
 	u32 chcr;
 
-	disable_irq(irq);
+	if (chan->flags & DMA_TEI_CAPABLE) {
+		irq = get_dmte_irq(chan->chan);
+		disable_irq(irq);
+	}
 
 	chcr = ctrl_inl(CHCR[chan->chan]);
 	chcr &= ~(CHCR_DE | CHCR_TE | CHCR_IE);
@@ -158,7 +157,7 @@ static int sh_dmac_xfer_dma(struct dma_channel *chan)
 	 * If we haven't pre-configured the channel with special flags, use
 	 * the defaults.
 	 */
-	if (!(chan->flags & DMA_CONFIGURED))
+	if (unlikely(!(chan->flags & DMA_CONFIGURED)))
 		sh_dmac_configure_channel(chan, 0);
 
 	sh_dmac_disable_dma(chan);
@@ -178,9 +177,11 @@ static int sh_dmac_xfer_dma(struct dma_channel *chan)
 	 * cascading to the PVR2 DMAC. In this case, we still need to write
 	 * SAR and DAR, regardless of value, in order for cascading to work.
 	 */
-	if (chan->sar || (mach_is_dreamcast() && chan->chan == 2))
+	if (chan->sar || (mach_is_dreamcast() &&
+			  chan->chan == PVR2_CASCADE_CHAN))
 		ctrl_outl(chan->sar, SAR[chan->chan]);
-	if (chan->dar || (mach_is_dreamcast() && chan->chan == 2))
+	if (chan->dar || (mach_is_dreamcast() &&
+			  chan->chan == PVR2_CASCADE_CHAN))
 		ctrl_outl(chan->dar, DAR[chan->chan]);
 
 	ctrl_outl(chan->count >> calc_xmit_shift(chan), DMATCR[chan->chan]);
@@ -198,17 +199,38 @@ static int sh_dmac_get_dma_residue(struct dma_channel *chan)
 	return ctrl_inl(DMATCR[chan->chan]) << calc_xmit_shift(chan);
 }
 
-#if defined(CONFIG_CPU_SH4)
-static irqreturn_t dma_err(int irq, void *dev_id, struct pt_regs *regs)
+#ifdef CONFIG_CPU_SUBTYPE_SH7780
+#define dmaor_read_reg()	ctrl_inw(DMAOR)
+#define dmaor_write_reg(data)	ctrl_outw(data, DMAOR)
+#else
+#define dmaor_read_reg()	ctrl_inl(DMAOR)
+#define dmaor_write_reg(data)	ctrl_outl(data, DMAOR)
+#endif
+
+static inline int dmaor_reset(void)
 {
-	unsigned long dmaor = ctrl_inl(DMAOR);
+	unsigned long dmaor = dmaor_read_reg();
+
+	/* Try to clear the error flags first, incase they are set */
+	dmaor &= ~(DMAOR_NMIF | DMAOR_AE);
+	dmaor_write_reg(dmaor);
 
-	printk("DMAE: DMAOR=%lx\n", dmaor);
+	dmaor |= DMAOR_INIT;
+	dmaor_write_reg(dmaor);
 
-	ctrl_outl(ctrl_inl(DMAOR)&~DMAOR_NMIF, DMAOR);
-	ctrl_outl(ctrl_inl(DMAOR)&~DMAOR_AE, DMAOR);
-	ctrl_outl(ctrl_inl(DMAOR)|DMAOR_DME, DMAOR);
+	/* See if we got an error again */
+	if ((dmaor_read_reg() & (DMAOR_AE | DMAOR_NMIF))) {
+		printk(KERN_ERR "dma-sh: Can't initialize DMAOR.\n");
+		return -EINVAL;
+	}
 
+	return 0;
+}
+
+#if defined(CONFIG_CPU_SH4)
+static irqreturn_t dma_err(int irq, void *dev_id, struct pt_regs *regs)
+{
+	dmaor_reset();
 	disable_irq(irq);
 
 	return IRQ_HANDLED;
@@ -224,8 +246,8 @@ static struct dma_ops sh_dmac_ops = {
 };
 
 static struct dma_info sh_dmac_info = {
-	.name		= "SuperH DMAC",
-	.nr_channels	= 4,
+	.name		= "sh_dmac",
+	.nr_channels	= CONFIG_NR_ONCHIP_DMA_CHANNELS,
 	.ops		= &sh_dmac_ops,
 	.flags		= DMAC_CHANNELS_TEI_CAPABLE,
 };
@@ -248,7 +270,13 @@ static int __init sh_dmac_init(void)
 		make_ipr_irq(irq, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY);
 	}
 
-	ctrl_outl(0x8000 | DMAOR_DME, DMAOR);
+	/*
+	 * Initialize DMAOR, and clean up any error flags that may have
+	 * been set.
+	 */
+	i = dmaor_reset();
+	if (i < 0)
+		return i;
 
 	return register_dmac(info);
 }
@@ -258,10 +286,12 @@ static void __exit sh_dmac_exit(void)
 #ifdef CONFIG_CPU_SH4
 	free_irq(DMAE_IRQ, 0);
 #endif
+	unregister_dmac(&sh_dmac_info);
 }
 
 subsys_initcall(sh_dmac_init);
 module_exit(sh_dmac_exit);
 
+MODULE_AUTHOR("Takashi YOSHII, Paul Mundt, Andriy Skulysh");
+MODULE_DESCRIPTION("SuperH On-Chip DMAC Support");
 MODULE_LICENSE("GPL");
-

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
new file mode 100644
index 000000000000..31dacd4444b2
--- /dev/null
+++ b/arch/sh/drivers/dma/dma-sh.c
@@ -0,0 +1,267 @@
+/*
+ * arch/sh/drivers/dma/dma-sh.c
+ *
+ * SuperH On-chip DMAC Support
+ *
+ * Copyright (C) 2000 Takashi YOSHII
+ * Copyright (C) 2003, 2004 Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <asm/signal.h>
+#include <asm/irq.h>
+#include <asm/dma.h>
+#include <asm/io.h>
+#include "dma-sh.h"
+
+/*
+ * The SuperH DMAC supports a number of transmit sizes, we list them here,
+ * with their respective values as they appear in the CHCR registers.
+ *
+ * Defaults to a 64-bit transfer size.
+ */
+enum {
+	XMIT_SZ_64BIT,
+	XMIT_SZ_8BIT,
+	XMIT_SZ_16BIT,
+	XMIT_SZ_32BIT,
+	XMIT_SZ_256BIT,
+};
+
+/*
+ * The DMA count is defined as the number of bytes to transfer.
+ */
+static unsigned int ts_shift[] = {
+	[XMIT_SZ_64BIT]		= 3,
+	[XMIT_SZ_8BIT]		= 0,
+	[XMIT_SZ_16BIT]		= 1,
+	[XMIT_SZ_32BIT]		= 2,
+	[XMIT_SZ_256BIT]	= 5,
+};
+
+static inline unsigned int get_dmte_irq(unsigned int chan)
+{
+	unsigned int irq;
+
+	/*
+	 * Normally we could just do DMTE0_IRQ + chan outright, though in the
+	 * case of the 7751R, the DMTE IRQs for channels > 4 start right above
+	 * the SCIF
+	 */
+
+	if (chan < 4) {
+		irq = DMTE0_IRQ + chan;
+	} else {
+		irq = DMTE4_IRQ + chan - 4;
+	}
+
+	return irq;
+}
+
+/*
+ * We determine the correct shift size based off of the CHCR transmit size
+ * for the given channel. Since we know that it will take:
+ *
+ *	info->count >> ts_shift[transmit_size]
+ *
+ * iterations to complete the transfer.
+ */
+static inline unsigned int calc_xmit_shift(struct dma_channel *chan)
+{
+	u32 chcr = ctrl_inl(CHCR[chan->chan]);
+
+	chcr >>= 4;
+
+	return ts_shift[chcr & 0x0007];
+}
+
+/*
+ * The transfer end interrupt must read the chcr register to end the
+ * hardware interrupt active condition.
+ * Besides that it needs to waken any waiting process, which should handle
+ * setting up the next transfer.
+ */
+static irqreturn_t dma_tei(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct dma_channel *chan = (struct dma_channel *)dev_id;
+	u32 chcr;
+
+	chcr = ctrl_inl(CHCR[chan->chan]);
+
+	if (!(chcr & CHCR_TE))
+		return IRQ_NONE;
+
+	chcr &= ~(CHCR_IE | CHCR_DE);
+	ctrl_outl(chcr, CHCR[chan->chan]);
+
+	wake_up(&chan->wait_queue);
+
+	return IRQ_HANDLED;
+}
+
+static int sh_dmac_request_dma(struct dma_channel *chan)
+{
+	return request_irq(get_dmte_irq(chan->chan), dma_tei,
+			   SA_INTERRUPT, "DMAC Transfer End", chan);
+}
+
+static void sh_dmac_free_dma(struct dma_channel *chan)
+{
+	free_irq(get_dmte_irq(chan->chan), chan);
+}
+
+static void sh_dmac_configure_channel(struct dma_channel *chan, unsigned long chcr)
+{
+	if (!chcr)
+		chcr = RS_DUAL;
+
+	ctrl_outl(chcr, CHCR[chan->chan]);
+
+	chan->flags |= DMA_CONFIGURED;
+}
+
+static void sh_dmac_enable_dma(struct dma_channel *chan)
+{
+	int irq = get_dmte_irq(chan->chan);
+	u32 chcr;
+
+	chcr = ctrl_inl(CHCR[chan->chan]);
+	chcr |= CHCR_DE | CHCR_IE;
+	ctrl_outl(chcr, CHCR[chan->chan]);
+
+	enable_irq(irq);
+}
+
+static void sh_dmac_disable_dma(struct dma_channel *chan)
+{
+	int irq = get_dmte_irq(chan->chan);
+	u32 chcr;
+
+	disable_irq(irq);
+
+	chcr = ctrl_inl(CHCR[chan->chan]);
+	chcr &= ~(CHCR_DE | CHCR_TE | CHCR_IE);
+	ctrl_outl(chcr, CHCR[chan->chan]);
+}
+
+static int sh_dmac_xfer_dma(struct dma_channel *chan)
+{
+	/*
+	 * If we haven't pre-configured the channel with special flags, use
+	 * the defaults.
+	 */
+	if (!(chan->flags & DMA_CONFIGURED))
+		sh_dmac_configure_channel(chan, 0);
+
+	sh_dmac_disable_dma(chan);
+
+	/*
+	 * Single-address mode usage note!
+	 *
+	 * It's important that we don't accidentally write any value to SAR/DAR
+	 * (this includes 0) that hasn't been directly specified by the user if
+	 * we're in single-address mode.
+	 *
+	 * In this case, only one address can be defined, anything else will
+	 * result in a DMA address error interrupt (at least on the SH-4),
+	 * which will subsequently halt the transfer.
+	 *
+	 * Channel 2 on the Dreamcast is a special case, as this is used for
+	 * cascading to the PVR2 DMAC. In this case, we still need to write
+	 * SAR and DAR, regardless of value, in order for cascading to work.
+	 */
+	if (chan->sar || (mach_is_dreamcast() && chan->chan == 2))
+		ctrl_outl(chan->sar, SAR[chan->chan]);
+	if (chan->dar || (mach_is_dreamcast() && chan->chan == 2))
+		ctrl_outl(chan->dar, DAR[chan->chan]);
+
+	ctrl_outl(chan->count >> calc_xmit_shift(chan), DMATCR[chan->chan]);
+
+	sh_dmac_enable_dma(chan);
+
+	return 0;
+}
+
+static int sh_dmac_get_dma_residue(struct dma_channel *chan)
+{
+	if (!(ctrl_inl(CHCR[chan->chan]) & CHCR_DE))
+		return 0;
+
+	return ctrl_inl(DMATCR[chan->chan]) << calc_xmit_shift(chan);
+}
+
+#if defined(CONFIG_CPU_SH4)
+static irqreturn_t dma_err(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned long dmaor = ctrl_inl(DMAOR);
+
+	printk("DMAE: DMAOR=%lx\n", dmaor);
+
+	ctrl_outl(ctrl_inl(DMAOR)&~DMAOR_NMIF, DMAOR);
+	ctrl_outl(ctrl_inl(DMAOR)&~DMAOR_AE, DMAOR);
+	ctrl_outl(ctrl_inl(DMAOR)|DMAOR_DME, DMAOR);
+
+	disable_irq(irq);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+static struct dma_ops sh_dmac_ops = {
+	.request	= sh_dmac_request_dma,
+	.free		= sh_dmac_free_dma,
+	.get_residue	= sh_dmac_get_dma_residue,
+	.xfer		= sh_dmac_xfer_dma,
+	.configure	= sh_dmac_configure_channel,
+};
+
+static struct dma_info sh_dmac_info = {
+	.name		= "SuperH DMAC",
+	.nr_channels	= 4,
+	.ops		= &sh_dmac_ops,
+	.flags		= DMAC_CHANNELS_TEI_CAPABLE,
+};
+
+static int __init sh_dmac_init(void)
+{
+	struct dma_info *info = &sh_dmac_info;
+	int i;
+
+#ifdef CONFIG_CPU_SH4
+	make_ipr_irq(DMAE_IRQ, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY);
+	i = request_irq(DMAE_IRQ, dma_err, SA_INTERRUPT, "DMAC Address Error", 0);
+	if (i < 0)
+		return i;
+#endif
+
+	for (i = 0; i < info->nr_channels; i++) {
+		int irq = get_dmte_irq(i);
+
+		make_ipr_irq(irq, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY);
+	}
+
+	ctrl_outl(0x8000 | DMAOR_DME, DMAOR);
+
+	return register_dmac(info);
+}
+
+static void __exit sh_dmac_exit(void)
+{
+#ifdef CONFIG_CPU_SH4
+	free_irq(DMAE_IRQ, 0);
+#endif
+}
+
+subsys_initcall(sh_dmac_init);
+module_exit(sh_dmac_exit);
+
+MODULE_LICENSE("GPL");
+
