commit 874e2cc18972d30ecd4d572d1286fe9b594d309c
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Thu Jun 4 16:46:56 2020 -0700

    sh: add support for folded p4d page tables
    
    Implement primitives necessary for the 4th level folding, add walks of p4d
    level where appropriate and remove usage of __ARCH_USE_5LEVEL_HACK.
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Christophe Leroy <christophe.leroy@c-s.fr>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: James Morse <james.morse@arm.com>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Julien Thierry <julien.thierry.kdev@gmail.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Marc Zyngier <maz@kernel.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Stefan Kristiansson <stefan.kristiansson@saunalahti.fi>
    Cc: Suzuki K Poulose <suzuki.poulose@arm.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200414153455.21744-12-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/io_trapped.c b/arch/sh/kernel/io_trapped.c
index 60c828a2b8a2..037aab2708b7 100644
--- a/arch/sh/kernel/io_trapped.c
+++ b/arch/sh/kernel/io_trapped.c
@@ -136,6 +136,7 @@ EXPORT_SYMBOL_GPL(match_trapped_io_handler);
 static struct trapped_io *lookup_tiop(unsigned long address)
 {
 	pgd_t *pgd_k;
+	p4d_t *p4d_k;
 	pud_t *pud_k;
 	pmd_t *pmd_k;
 	pte_t *pte_k;
@@ -145,7 +146,11 @@ static struct trapped_io *lookup_tiop(unsigned long address)
 	if (!pgd_present(*pgd_k))
 		return NULL;
 
-	pud_k = pud_offset(pgd_k, address);
+	p4d_k = p4d_offset(pgd_k, address);
+	if (!p4d_present(*p4d_k))
+		return NULL;
+
+	pud_k = pud_offset(p4d_k, address);
 	if (!pud_present(*pud_k))
 		return NULL;
 

commit 6d80f20c5328ad24dde0fddb980f60734a17b911
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Fri Oct 18 11:18:22 2019 +0800

    sh: Use pr_warn instead of pr_warning
    
    As said in commit f2c2cbcc35d4 ("powerpc: Use pr_warn instead of
    pr_warning"), removing pr_warning so all logging messages use a
    consistent <prefix>_warn style. Let's do it.
    
    Link: http://lkml.kernel.org/r/20191018031850.48498-5-wangkefeng.wang@huawei.com
    To: linux-kernel@vger.kernel.org
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Rich Felker <dalias@libc.org>
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/arch/sh/kernel/io_trapped.c b/arch/sh/kernel/io_trapped.c
index bacad6da4fe4..60c828a2b8a2 100644
--- a/arch/sh/kernel/io_trapped.c
+++ b/arch/sh/kernel/io_trapped.c
@@ -99,7 +99,7 @@ int register_trapped_io(struct trapped_io *tiop)
 
 	return 0;
  bad:
-	pr_warning("unable to install trapped io filter\n");
+	pr_warn("unable to install trapped io filter\n");
 	return -1;
 }
 EXPORT_SYMBOL_GPL(register_trapped_io);

commit 5933f6d220403b55772d2caf48a9a39d777fd630
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 28 00:32:24 2018 -0800

    sh: kernel: convert to SPDX identifiers
    
    Update license to use SPDX-License-Identifier instead of verbose license
    text.
    
    Link: http://lkml.kernel.org/r/8736rccswn.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/io_trapped.c b/arch/sh/kernel/io_trapped.c
index 4d4e7a2a774b..bacad6da4fe4 100644
--- a/arch/sh/kernel/io_trapped.c
+++ b/arch/sh/kernel/io_trapped.c
@@ -1,13 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Trapped io support
  *
  * Copyright (C) 2008 Magnus Damm
  *
  * Intercept io operations by trapping.
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 #include <linux/kernel.h>
 #include <linux/mm.h>

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/io_trapped.c b/arch/sh/kernel/io_trapped.c
index f8ce36286cea..4d4e7a2a774b 100644
--- a/arch/sh/kernel/io_trapped.c
+++ b/arch/sh/kernel/io_trapped.c
@@ -16,7 +16,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <asm/mmu_context.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <asm/io.h>
 #include <asm/io_trapped.h>
 

commit ce816fa88cca083c47ab9000b2138a83043a78be
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Apr 7 15:39:19 2014 -0700

    Kconfig: rename HAS_IOPORT to HAS_IOPORT_MAP
    
    If the renamed symbol is defined lib/iomap.c implements ioport_map and
    ioport_unmap and currently (nearly) all platforms define the port
    accessor functions outb/inb and friend unconditionally.  So
    HAS_IOPORT_MAP is the better name for this.
    
    Consequently NO_IOPORT is renamed to NO_IOPORT_MAP.
    
    The motivation for this change is to reintroduce a symbol HAS_IOPORT
    that signals if outb/int et al are available.  I will address that at
    least one merge window later though to keep surprises to a minimum and
    catch new introductions of (HAS|NO)_IOPORT.
    
    The changes in this commit were done using:
    
            $ git grep -l -E '(NO|HAS)_IOPORT' | xargs perl -p -i -e 's/\b((?:CONFIG_)?(?:NO|HAS)_IOPORT)\b/$1_MAP/'
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/io_trapped.c b/arch/sh/kernel/io_trapped.c
index c0a9761f2f8a..f8ce36286cea 100644
--- a/arch/sh/kernel/io_trapped.c
+++ b/arch/sh/kernel/io_trapped.c
@@ -22,7 +22,7 @@
 
 #define TRAPPED_PAGES_MAX 16
 
-#ifdef CONFIG_HAS_IOPORT
+#ifdef CONFIG_HAS_IOPORT_MAP
 LIST_HEAD(trapped_io);
 EXPORT_SYMBOL_GPL(trapped_io);
 #endif
@@ -90,7 +90,7 @@ int register_trapped_io(struct trapped_io *tiop)
 	tiop->magic = IO_TRAPPED_MAGIC;
 	INIT_LIST_HEAD(&tiop->list);
 	spin_lock_irq(&trapped_lock);
-#ifdef CONFIG_HAS_IOPORT
+#ifdef CONFIG_HAS_IOPORT_MAP
 	if (flags & IORESOURCE_IO)
 		list_add(&tiop->list, &trapped_io);
 #endif

commit e839ca528718e68cad32a307dc9aabf01ef3eb05
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Disintegrate asm/system.h for SH
    
    Disintegrate asm/system.h for SH.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-sh@vger.kernel.org

diff --git a/arch/sh/kernel/io_trapped.c b/arch/sh/kernel/io_trapped.c
index 0f62f4672754..c0a9761f2f8a 100644
--- a/arch/sh/kernel/io_trapped.c
+++ b/arch/sh/kernel/io_trapped.c
@@ -15,7 +15,6 @@
 #include <linux/vmalloc.h>
 #include <linux/module.h>
 #include <linux/init.h>
-#include <asm/system.h>
 #include <asm/mmu_context.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>

commit 28f65c11f2ffb3957259dece647a24f8ad2e241b
Author: Joe Perches <joe@perches.com>
Date:   Thu Jun 9 09:13:32 2011 -0700

    treewide: Convert uses of struct resource to resource_size(ptr)
    
    Several fixes as well where the +1 was missing.
    
    Done via coccinelle scripts like:
    
    @@
    struct resource *ptr;
    @@
    
    - ptr->end - ptr->start + 1
    + resource_size(ptr)
    
    and some grep and typing.
    
    Mostly uncompiled, no cross-compilers.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/arch/sh/kernel/io_trapped.c b/arch/sh/kernel/io_trapped.c
index 32c385ef1011..0f62f4672754 100644
--- a/arch/sh/kernel/io_trapped.c
+++ b/arch/sh/kernel/io_trapped.c
@@ -58,7 +58,7 @@ int register_trapped_io(struct trapped_io *tiop)
 
 	for (k = 0; k < tiop->num_resources; k++) {
 		res = tiop->resource + k;
-		len += roundup((res->end - res->start) + 1, PAGE_SIZE);
+		len += roundup(resource_size(res), PAGE_SIZE);
 		flags |= res->flags;
 	}
 
@@ -85,7 +85,7 @@ int register_trapped_io(struct trapped_io *tiop)
 		       (unsigned long)(tiop->virt_base + len),
 		       res->flags & IORESOURCE_IO ? "io" : "mmio",
 		       (unsigned long)res->start);
-		len += roundup((res->end - res->start) + 1, PAGE_SIZE);
+		len += roundup(resource_size(res), PAGE_SIZE);
 	}
 
 	tiop->magic = IO_TRAPPED_MAGIC;
@@ -128,7 +128,7 @@ void __iomem *match_trapped_io_handler(struct list_head *list,
 				return tiop->virt_base + voffs;
 			}
 
-			len = (res->end - res->start) + 1;
+			len = resource_size(res);
 			voffs += roundup(len, PAGE_SIZE);
 		}
 	}
@@ -173,7 +173,7 @@ static unsigned long lookup_address(struct trapped_io *tiop,
 
 	for (k = 0; k < tiop->num_resources; k++) {
 		res = tiop->resource + k;
-		len = roundup((res->end - res->start) + 1, PAGE_SIZE);
+		len = roundup(resource_size(res), PAGE_SIZE);
 		if (address < (vaddr + len))
 			return res->start + (address - vaddr);
 		vaddr += len;

commit ace2dc7d12693545b67f15ab8cdb3d255c937713
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Oct 13 06:55:26 2010 +0900

    sh: wire up perf alignment and emulation faults.
    
    This plugs in the alignment and emulation fault reporting for perf sw
    events.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io_trapped.c b/arch/sh/kernel/io_trapped.c
index 2947d2bd1291..32c385ef1011 100644
--- a/arch/sh/kernel/io_trapped.c
+++ b/arch/sh/kernel/io_trapped.c
@@ -291,7 +291,7 @@ int handle_trapped_io(struct pt_regs *regs, unsigned long address)
 	}
 
 	tmp = handle_unaligned_access(instruction, regs,
-				      &trapped_io_access, 1);
+				      &trapped_io_access, 1, address);
 	set_fs(oldfs);
 	return tmp == 0;
 }

commit 86e4dd5add77ab809f5427391dfabb8f78cbcb58
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 25 20:06:13 2010 +0900

    sh: support for platforms without PIO.
    
    This extends some of the existing special casing for HAS_IOPORT
    platforms and gets it to the point where platforms can begin to
    conditionally select it.
    
    The major changes here are that the PIO routines themselves go away
    completely, including all of the machvec port mapping wrappers. With this
    in place it's possible for any non-machvec abusing platform to disable
    PIO completely. At present this is left as an opt-in until the abusers
    are the odd ones out instead of the majority.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io_trapped.c b/arch/sh/kernel/io_trapped.c
index 4a8bb4eeb8ad..2947d2bd1291 100644
--- a/arch/sh/kernel/io_trapped.c
+++ b/arch/sh/kernel/io_trapped.c
@@ -91,10 +91,14 @@ int register_trapped_io(struct trapped_io *tiop)
 	tiop->magic = IO_TRAPPED_MAGIC;
 	INIT_LIST_HEAD(&tiop->list);
 	spin_lock_irq(&trapped_lock);
+#ifdef CONFIG_HAS_IOPORT
 	if (flags & IORESOURCE_IO)
 		list_add(&tiop->list, &trapped_io);
+#endif
+#ifdef CONFIG_HAS_IOMEM
 	if (flags & IORESOURCE_MEM)
 		list_add(&tiop->list, &trapped_mem);
+#endif
 	spin_unlock_irq(&trapped_lock);
 
 	return 0;

commit 08b36c4a02b5a9db609fc6d93b9c41d7fa75713c
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Jan 27 21:56:57 2010 +0900

    sh: Optimize runtime disabling of trapped I/O.
    
    Presently trapped I/O is only registered if it's not explicitly disabled
    for the platforms that select it openly. From the fault path this runs
    through an address lookup before figuring out that nothing matches and
    falls back through the error path, but we can forego the lookup
    completely by testing if it's been explicitly disabled. This provides a
    measurable speedup for things like qemu that rely on runtime disabling.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io_trapped.c b/arch/sh/kernel/io_trapped.c
index 16b83cc89a41..4a8bb4eeb8ad 100644
--- a/arch/sh/kernel/io_trapped.c
+++ b/arch/sh/kernel/io_trapped.c
@@ -271,6 +271,8 @@ int handle_trapped_io(struct pt_regs *regs, unsigned long address)
 	insn_size_t instruction;
 	int tmp;
 
+	if (trapped_io_disable)
+		return 0;
 	if (!lookup_tiop(address))
 		return 0;
 

commit 9d56dd3b083a3bec56e9da35ce07baca81030b03
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jan 26 12:58:40 2010 +0900

    sh: Mass ctrl_in/outX to __raw_read/writeX conversion.
    
    The old ctrl in/out routines are non-portable and unsuitable for
    cross-platform use. While drivers/sh has already been sanitized, there
    is still quite a lot of code that is not. This converts the arch/sh/ bits
    over, which permits us to flag the routines as deprecated whilst still
    building with -Werror for the architecture code, and to ensure that
    future users are not added.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io_trapped.c b/arch/sh/kernel/io_trapped.c
index 69be603aa2d7..16b83cc89a41 100644
--- a/arch/sh/kernel/io_trapped.c
+++ b/arch/sh/kernel/io_trapped.c
@@ -184,31 +184,31 @@ static unsigned long long copy_word(unsigned long src_addr, int src_len,
 
 	switch (src_len) {
 	case 1:
-		tmp = ctrl_inb(src_addr);
+		tmp = __raw_readb(src_addr);
 		break;
 	case 2:
-		tmp = ctrl_inw(src_addr);
+		tmp = __raw_readw(src_addr);
 		break;
 	case 4:
-		tmp = ctrl_inl(src_addr);
+		tmp = __raw_readl(src_addr);
 		break;
 	case 8:
-		tmp = ctrl_inq(src_addr);
+		tmp = __raw_readq(src_addr);
 		break;
 	}
 
 	switch (dst_len) {
 	case 1:
-		ctrl_outb(tmp, dst_addr);
+		__raw_writeb(tmp, dst_addr);
 		break;
 	case 2:
-		ctrl_outw(tmp, dst_addr);
+		__raw_writew(tmp, dst_addr);
 		break;
 	case 4:
-		ctrl_outl(tmp, dst_addr);
+		__raw_writel(tmp, dst_addr);
 		break;
 	case 8:
-		ctrl_outq(tmp, dst_addr);
+		__raw_writeq(tmp, dst_addr);
 		break;
 	}
 

commit 4aa5ac4ef44dd8c986241c54298abd7910b78b3f
Author: Matt Fleming <matt@console-pimps.org>
Date:   Fri Aug 28 21:37:20 2009 +0000

    sh: Only shout about fixing up unexpected unaligned accesses
    
    Some unaligned accesses are completely expected. For example, the
    trapped_io code uses the unaligned access fixup code path so there's no
    need to warn about having to fixup the unaligned access.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io_trapped.c b/arch/sh/kernel/io_trapped.c
index e27a19e1f46e..69be603aa2d7 100644
--- a/arch/sh/kernel/io_trapped.c
+++ b/arch/sh/kernel/io_trapped.c
@@ -284,7 +284,8 @@ int handle_trapped_io(struct pt_regs *regs, unsigned long address)
 		return 0;
 	}
 
-	tmp = handle_unaligned_access(instruction, regs, &trapped_io_access);
+	tmp = handle_unaligned_access(instruction, regs,
+				      &trapped_io_access, 1);
 	set_fs(oldfs);
 	return tmp == 0;
 }

commit fd78a76aefb5bf28a11d6960d29e03a11db62320
Author: Stuart Menefy <stuart.menefy@st.com>
Date:   Wed Jul 29 23:01:24 2009 +0900

    sh: Rework irqflags tracing to fix up CONFIG_PROVE_LOCKING.
    
    This cleans up the irqflags tracing code quite a bit and ties it
    in to various missing callsites that caused an imbalance when
    CONFIG_PROVE_LOCKING was enabled.
    
    Previously this was catching on:
    
     987 #ifdef CONFIG_PROVE_LOCKING
     988     DEBUG_LOCKS_WARN_ON(!p->hardirqs_enabled);
     989     DEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);
     990 #endif
     991     retval = -EAGAIN;
    
    with hardirqs being doubly enabled, and subsequently bailing out
    with the following call trace:
    
            Call trace:
            [<88035224>] __lock_acquire+0x616/0x6a6
            [<88015a8c>] do_fork+0xf8/0x2b0
            [<880331ec>] trace_hardirqs_on_caller+0xd4/0x114
            [<88241074>] _spin_unlock_irq+0x20/0x64
            [<88035224>] __lock_acquire+0x616/0x6a6
            [<8800386c>] kernel_thread+0x48/0x70
            [<88024ecc>] ____call_usermodehelper+0x0/0x110
            [<88024ecc>] ____call_usermodehelper+0x0/0x110
            [<88003894>] kernel_thread_helper+0x0/0x14
            [<88024bac>] __call_usermodehelper+0x38/0x70
            [<88025dc0>] worker_thread+0x150/0x274
            [<88035b9c>] lock_release+0x0/0x198
            [<88024b74>] __call_usermodehelper+0x0/0x70
            [<88028cf0>] autoremove_wake_function+0x0/0x30
            [<88028bf2>] kthread+0x3e/0x70
            [<88025c70>] worker_thread+0x0/0x274
            [<8800389c>] kernel_thread_helper+0x8/0x14
            [<88028bb4>] kthread+0x0/0x70
            [<88003894>] kernel_thread_helper+0x0/0x14
    
    Reported-by: Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
    Signed-off-by: Stuart Menefy <stuart.menefy@st.com>
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io_trapped.c b/arch/sh/kernel/io_trapped.c
index 77dfecb64373..e27a19e1f46e 100644
--- a/arch/sh/kernel/io_trapped.c
+++ b/arch/sh/kernel/io_trapped.c
@@ -112,14 +112,15 @@ void __iomem *match_trapped_io_handler(struct list_head *list,
 	struct trapped_io *tiop;
 	struct resource *res;
 	int k, len;
+	unsigned long flags;
 
-	spin_lock_irq(&trapped_lock);
+	spin_lock_irqsave(&trapped_lock, flags);
 	list_for_each_entry(tiop, list, list) {
 		voffs = 0;
 		for (k = 0; k < tiop->num_resources; k++) {
 			res = tiop->resource + k;
 			if (res->start == offset) {
-				spin_unlock_irq(&trapped_lock);
+				spin_unlock_irqrestore(&trapped_lock, flags);
 				return tiop->virt_base + voffs;
 			}
 
@@ -127,7 +128,7 @@ void __iomem *match_trapped_io_handler(struct list_head *list,
 			voffs += roundup(len, PAGE_SIZE);
 		}
 	}
-	spin_unlock_irq(&trapped_lock);
+	spin_unlock_irqrestore(&trapped_lock, flags);
 	return NULL;
 }
 EXPORT_SYMBOL_GPL(match_trapped_io_handler);

commit 2bcfffa42309b6f73042c62459bf5207762a271d
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sat May 9 16:02:08 2009 +0900

    sh: Rename opcode_t to insn_size_t.
    
    This is now clashing with a driver, so just rename it.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io_trapped.c b/arch/sh/kernel/io_trapped.c
index c22853b059ef..77dfecb64373 100644
--- a/arch/sh/kernel/io_trapped.c
+++ b/arch/sh/kernel/io_trapped.c
@@ -267,7 +267,7 @@ static struct mem_access trapped_io_access = {
 int handle_trapped_io(struct pt_regs *regs, unsigned long address)
 {
 	mm_segment_t oldfs;
-	opcode_t instruction;
+	insn_size_t instruction;
 	int tmp;
 
 	if (!lookup_tiop(address))

commit eeee7853c4ffaf5b9eb58f39708e3c78f66cee15
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Apr 2 12:31:16 2009 +0900

    sh: Add a command line option for disabling I/O trapping.
    
    This adds a 'noiotrap' kernel command line option to permit disabling of
    I/O trapping. This is mostly useful for running on emulators where the
    physical device limitations are not an issue.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io_trapped.c b/arch/sh/kernel/io_trapped.c
index 39cd7f3aec7b..c22853b059ef 100644
--- a/arch/sh/kernel/io_trapped.c
+++ b/arch/sh/kernel/io_trapped.c
@@ -14,6 +14,7 @@
 #include <linux/bitops.h>
 #include <linux/vmalloc.h>
 #include <linux/module.h>
+#include <linux/init.h>
 #include <asm/system.h>
 #include <asm/mmu_context.h>
 #include <asm/uaccess.h>
@@ -32,6 +33,15 @@ EXPORT_SYMBOL_GPL(trapped_mem);
 #endif
 static DEFINE_SPINLOCK(trapped_lock);
 
+static int trapped_io_disable __read_mostly;
+
+static int __init trapped_io_setup(char *__unused)
+{
+	trapped_io_disable = 1;
+	return 1;
+}
+__setup("noiotrap", trapped_io_setup);
+
 int register_trapped_io(struct trapped_io *tiop)
 {
 	struct resource *res;
@@ -39,6 +49,9 @@ int register_trapped_io(struct trapped_io *tiop)
 	struct page *pages[TRAPPED_PAGES_MAX];
 	int k, n;
 
+	if (unlikely(trapped_io_disable))
+		return 0;
+
 	/* structure must be page aligned */
 	if ((unsigned long)tiop & (PAGE_SIZE - 1))
 		goto bad;

commit b2839ed83f54d40870747ac8d655504dff63d1c5
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Mar 6 12:43:38 2008 +0900

    sh: Fix up section mismatches.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io_trapped.c b/arch/sh/kernel/io_trapped.c
index 86a665d92201..39cd7f3aec7b 100644
--- a/arch/sh/kernel/io_trapped.c
+++ b/arch/sh/kernel/io_trapped.c
@@ -32,7 +32,7 @@ EXPORT_SYMBOL_GPL(trapped_mem);
 #endif
 static DEFINE_SPINLOCK(trapped_lock);
 
-int __init register_trapped_io(struct trapped_io *tiop)
+int register_trapped_io(struct trapped_io *tiop)
 {
 	struct resource *res;
 	unsigned long len = 0, flags = 0;

commit ecc14e8cf7f7865b8b7a9e1796c0b18cbb477d2f
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Feb 12 16:02:02 2008 +0900

    sh: Symbol exports for trapped I/O.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io_trapped.c b/arch/sh/kernel/io_trapped.c
index 227547bae548..86a665d92201 100644
--- a/arch/sh/kernel/io_trapped.c
+++ b/arch/sh/kernel/io_trapped.c
@@ -13,6 +13,7 @@
 #include <linux/mm.h>
 #include <linux/bitops.h>
 #include <linux/vmalloc.h>
+#include <linux/module.h>
 #include <asm/system.h>
 #include <asm/mmu_context.h>
 #include <asm/uaccess.h>
@@ -23,9 +24,11 @@
 
 #ifdef CONFIG_HAS_IOPORT
 LIST_HEAD(trapped_io);
+EXPORT_SYMBOL_GPL(trapped_io);
 #endif
 #ifdef CONFIG_HAS_IOMEM
 LIST_HEAD(trapped_mem);
+EXPORT_SYMBOL_GPL(trapped_mem);
 #endif
 static DEFINE_SPINLOCK(trapped_lock);
 
@@ -86,6 +89,7 @@ int __init register_trapped_io(struct trapped_io *tiop)
 	pr_warning("unable to install trapped io filter\n");
 	return -1;
 }
+EXPORT_SYMBOL_GPL(register_trapped_io);
 
 void __iomem *match_trapped_io_handler(struct list_head *list,
 				       unsigned long offset,
@@ -113,6 +117,7 @@ void __iomem *match_trapped_io_handler(struct list_head *list,
 	spin_unlock_irq(&trapped_lock);
 	return NULL;
 }
+EXPORT_SYMBOL_GPL(match_trapped_io_handler);
 
 static struct trapped_io *lookup_tiop(unsigned long address)
 {

commit f1cdd63fe904869310fefb0361c94c51744eada4
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sat Feb 9 19:10:52 2008 +0900

    sh: Use max_t in io_trapped.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io_trapped.c b/arch/sh/kernel/io_trapped.c
index 0bfdc9a34e1a..227547bae548 100644
--- a/arch/sh/kernel/io_trapped.c
+++ b/arch/sh/kernel/io_trapped.c
@@ -20,7 +20,6 @@
 #include <asm/io_trapped.h>
 
 #define TRAPPED_PAGES_MAX 16
-#define MAX(a, b) (((a) >= (b)) ? (a) : (b))
 
 #ifdef CONFIG_HAS_IOPORT
 LIST_HEAD(trapped_io);
@@ -211,7 +210,9 @@ static unsigned long from_device(void *dst, const void *src, unsigned long cnt)
 	if (!src_addr)
 		return cnt;
 
-	tmp = copy_word(src_addr, MAX(cnt, (tiop->minimum_bus_width / 8)),
+	tmp = copy_word(src_addr,
+			max_t(unsigned long, cnt,
+			      (tiop->minimum_bus_width / 8)),
 			(unsigned long)dst, cnt);
 
 	pr_debug("trapped io read 0x%08lx -> 0x%08llx\n", src_addr, tmp);
@@ -233,7 +234,8 @@ static unsigned long to_device(void *dst, const void *src, unsigned long cnt)
 		return cnt;
 
 	tmp = copy_word((unsigned long)src, cnt,
-			dst_addr, MAX(cnt, (tiop->minimum_bus_width / 8)));
+			dst_addr, max_t(unsigned long, cnt,
+					(tiop->minimum_bus_width / 8)));
 
 	pr_debug("trapped io write 0x%08lx -> 0x%08llx\n", dst_addr, tmp);
 	return 0;

commit e7cc9a7340b8ec018caa9eb1d035fdaef1f2fc51
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Thu Feb 7 20:18:21 2008 +0900

    sh: trapped io support V2
    
    The idea is that we want to get rid of the in/out/readb/writeb callbacks from
    the machvec and replace that with simple inline read and write operations to
    memory. Fast and simple for most hardware devices (think pci).
    
    Some devices require special treatment though - like 16-bit only CF devices -
    so we need to have some method to hook in callbacks.
    
    This patch makes it possible to add a per-device trap generating filter. This
    way we can get maximum performance of sane hardware - which doesn't need this
    filter - and crappy hardware works but gets punished by a performance hit.
    
    V2 changes things around a bit and replaces io access callbacks with a
    simple minimum_bus_width value. In the future we can add stride as well.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io_trapped.c b/arch/sh/kernel/io_trapped.c
new file mode 100644
index 000000000000..0bfdc9a34e1a
--- /dev/null
+++ b/arch/sh/kernel/io_trapped.c
@@ -0,0 +1,269 @@
+/*
+ * Trapped io support
+ *
+ * Copyright (C) 2008 Magnus Damm
+ *
+ * Intercept io operations by trapping.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/bitops.h>
+#include <linux/vmalloc.h>
+#include <asm/system.h>
+#include <asm/mmu_context.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/io_trapped.h>
+
+#define TRAPPED_PAGES_MAX 16
+#define MAX(a, b) (((a) >= (b)) ? (a) : (b))
+
+#ifdef CONFIG_HAS_IOPORT
+LIST_HEAD(trapped_io);
+#endif
+#ifdef CONFIG_HAS_IOMEM
+LIST_HEAD(trapped_mem);
+#endif
+static DEFINE_SPINLOCK(trapped_lock);
+
+int __init register_trapped_io(struct trapped_io *tiop)
+{
+	struct resource *res;
+	unsigned long len = 0, flags = 0;
+	struct page *pages[TRAPPED_PAGES_MAX];
+	int k, n;
+
+	/* structure must be page aligned */
+	if ((unsigned long)tiop & (PAGE_SIZE - 1))
+		goto bad;
+
+	for (k = 0; k < tiop->num_resources; k++) {
+		res = tiop->resource + k;
+		len += roundup((res->end - res->start) + 1, PAGE_SIZE);
+		flags |= res->flags;
+	}
+
+	/* support IORESOURCE_IO _or_ MEM, not both */
+	if (hweight_long(flags) != 1)
+		goto bad;
+
+	n = len >> PAGE_SHIFT;
+
+	if (n >= TRAPPED_PAGES_MAX)
+		goto bad;
+
+	for (k = 0; k < n; k++)
+		pages[k] = virt_to_page(tiop);
+
+	tiop->virt_base = vmap(pages, n, VM_MAP, PAGE_NONE);
+	if (!tiop->virt_base)
+		goto bad;
+
+	len = 0;
+	for (k = 0; k < tiop->num_resources; k++) {
+		res = tiop->resource + k;
+		pr_info("trapped io 0x%08lx overrides %s 0x%08lx\n",
+		       (unsigned long)(tiop->virt_base + len),
+		       res->flags & IORESOURCE_IO ? "io" : "mmio",
+		       (unsigned long)res->start);
+		len += roundup((res->end - res->start) + 1, PAGE_SIZE);
+	}
+
+	tiop->magic = IO_TRAPPED_MAGIC;
+	INIT_LIST_HEAD(&tiop->list);
+	spin_lock_irq(&trapped_lock);
+	if (flags & IORESOURCE_IO)
+		list_add(&tiop->list, &trapped_io);
+	if (flags & IORESOURCE_MEM)
+		list_add(&tiop->list, &trapped_mem);
+	spin_unlock_irq(&trapped_lock);
+
+	return 0;
+ bad:
+	pr_warning("unable to install trapped io filter\n");
+	return -1;
+}
+
+void __iomem *match_trapped_io_handler(struct list_head *list,
+				       unsigned long offset,
+				       unsigned long size)
+{
+	unsigned long voffs;
+	struct trapped_io *tiop;
+	struct resource *res;
+	int k, len;
+
+	spin_lock_irq(&trapped_lock);
+	list_for_each_entry(tiop, list, list) {
+		voffs = 0;
+		for (k = 0; k < tiop->num_resources; k++) {
+			res = tiop->resource + k;
+			if (res->start == offset) {
+				spin_unlock_irq(&trapped_lock);
+				return tiop->virt_base + voffs;
+			}
+
+			len = (res->end - res->start) + 1;
+			voffs += roundup(len, PAGE_SIZE);
+		}
+	}
+	spin_unlock_irq(&trapped_lock);
+	return NULL;
+}
+
+static struct trapped_io *lookup_tiop(unsigned long address)
+{
+	pgd_t *pgd_k;
+	pud_t *pud_k;
+	pmd_t *pmd_k;
+	pte_t *pte_k;
+	pte_t entry;
+
+	pgd_k = swapper_pg_dir + pgd_index(address);
+	if (!pgd_present(*pgd_k))
+		return NULL;
+
+	pud_k = pud_offset(pgd_k, address);
+	if (!pud_present(*pud_k))
+		return NULL;
+
+	pmd_k = pmd_offset(pud_k, address);
+	if (!pmd_present(*pmd_k))
+		return NULL;
+
+	pte_k = pte_offset_kernel(pmd_k, address);
+	entry = *pte_k;
+
+	return pfn_to_kaddr(pte_pfn(entry));
+}
+
+static unsigned long lookup_address(struct trapped_io *tiop,
+				    unsigned long address)
+{
+	struct resource *res;
+	unsigned long vaddr = (unsigned long)tiop->virt_base;
+	unsigned long len;
+	int k;
+
+	for (k = 0; k < tiop->num_resources; k++) {
+		res = tiop->resource + k;
+		len = roundup((res->end - res->start) + 1, PAGE_SIZE);
+		if (address < (vaddr + len))
+			return res->start + (address - vaddr);
+		vaddr += len;
+	}
+	return 0;
+}
+
+static unsigned long long copy_word(unsigned long src_addr, int src_len,
+				    unsigned long dst_addr, int dst_len)
+{
+	unsigned long long tmp = 0;
+
+	switch (src_len) {
+	case 1:
+		tmp = ctrl_inb(src_addr);
+		break;
+	case 2:
+		tmp = ctrl_inw(src_addr);
+		break;
+	case 4:
+		tmp = ctrl_inl(src_addr);
+		break;
+	case 8:
+		tmp = ctrl_inq(src_addr);
+		break;
+	}
+
+	switch (dst_len) {
+	case 1:
+		ctrl_outb(tmp, dst_addr);
+		break;
+	case 2:
+		ctrl_outw(tmp, dst_addr);
+		break;
+	case 4:
+		ctrl_outl(tmp, dst_addr);
+		break;
+	case 8:
+		ctrl_outq(tmp, dst_addr);
+		break;
+	}
+
+	return tmp;
+}
+
+static unsigned long from_device(void *dst, const void *src, unsigned long cnt)
+{
+	struct trapped_io *tiop;
+	unsigned long src_addr = (unsigned long)src;
+	unsigned long long tmp;
+
+	pr_debug("trapped io read 0x%08lx (%ld)\n", src_addr, cnt);
+	tiop = lookup_tiop(src_addr);
+	WARN_ON(!tiop || (tiop->magic != IO_TRAPPED_MAGIC));
+
+	src_addr = lookup_address(tiop, src_addr);
+	if (!src_addr)
+		return cnt;
+
+	tmp = copy_word(src_addr, MAX(cnt, (tiop->minimum_bus_width / 8)),
+			(unsigned long)dst, cnt);
+
+	pr_debug("trapped io read 0x%08lx -> 0x%08llx\n", src_addr, tmp);
+	return 0;
+}
+
+static unsigned long to_device(void *dst, const void *src, unsigned long cnt)
+{
+	struct trapped_io *tiop;
+	unsigned long dst_addr = (unsigned long)dst;
+	unsigned long long tmp;
+
+	pr_debug("trapped io write 0x%08lx (%ld)\n", dst_addr, cnt);
+	tiop = lookup_tiop(dst_addr);
+	WARN_ON(!tiop || (tiop->magic != IO_TRAPPED_MAGIC));
+
+	dst_addr = lookup_address(tiop, dst_addr);
+	if (!dst_addr)
+		return cnt;
+
+	tmp = copy_word((unsigned long)src, cnt,
+			dst_addr, MAX(cnt, (tiop->minimum_bus_width / 8)));
+
+	pr_debug("trapped io write 0x%08lx -> 0x%08llx\n", dst_addr, tmp);
+	return 0;
+}
+
+static struct mem_access trapped_io_access = {
+	from_device,
+	to_device,
+};
+
+int handle_trapped_io(struct pt_regs *regs, unsigned long address)
+{
+	mm_segment_t oldfs;
+	opcode_t instruction;
+	int tmp;
+
+	if (!lookup_tiop(address))
+		return 0;
+
+	WARN_ON(user_mode(regs));
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	if (copy_from_user(&instruction, (void *)(regs->pc),
+			   sizeof(instruction))) {
+		set_fs(oldfs);
+		return 0;
+	}
+
+	tmp = handle_unaligned_access(instruction, regs, &trapped_io_access);
+	set_fs(oldfs);
+	return tmp == 0;
+}
