commit 5933f6d220403b55772d2caf48a9a39d777fd630
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 28 00:32:24 2018 -0800

    sh: kernel: convert to SPDX identifiers
    
    Update license to use SPDX-License-Identifier instead of verbose license
    text.
    
    Link: http://lkml.kernel.org/r/8736rccswn.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/io.c b/arch/sh/kernel/io.c
index 5c51b794ba2a..da22f3b32d30 100644
--- a/arch/sh/kernel/io.c
+++ b/arch/sh/kernel/io.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * arch/sh/kernel/io.c - Machine independent I/O functions.
  *
  * Copyright (C) 2000 - 2009  Stuart Menefy
  * Copyright (C) 2005  Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 #include <linux/module.h>
 #include <linux/pci.h>

commit 86e4dd5add77ab809f5427391dfabb8f78cbcb58
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 25 20:06:13 2010 +0900

    sh: support for platforms without PIO.
    
    This extends some of the existing special casing for HAS_IOPORT
    platforms and gets it to the point where platforms can begin to
    conditionally select it.
    
    The major changes here are that the PIO routines themselves go away
    completely, including all of the machvec port mapping wrappers. With this
    in place it's possible for any non-machvec abusing platform to disable
    PIO completely. At present this is left as an opt-in until the abusers
    are the odd ones out instead of the majority.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io.c b/arch/sh/kernel/io.c
index 4770c241c679..5c51b794ba2a 100644
--- a/arch/sh/kernel/io.c
+++ b/arch/sh/kernel/io.c
@@ -112,25 +112,3 @@ void memset_io(volatile void __iomem *dst, int c, unsigned long count)
         }
 }
 EXPORT_SYMBOL(memset_io);
-
-#ifndef CONFIG_GENERIC_IOMAP
-
-void __iomem *ioport_map(unsigned long port, unsigned int nr)
-{
-	void __iomem *ret;
-
-	ret = __ioport_map_trapped(port, nr);
-	if (ret)
-		return ret;
-
-	return __ioport_map(port, nr);
-}
-EXPORT_SYMBOL(ioport_map);
-
-void ioport_unmap(void __iomem *addr)
-{
-	sh_mv.mv_ioport_unmap(addr);
-}
-EXPORT_SYMBOL(ioport_unmap);
-
-#endif /* CONFIG_GENERIC_IOMAP */

commit 5e9377ec6f84e5334e9347e84e77d34e9a089ca7
Author: Stuart Menefy <stuart.menefy@st.com>
Date:   Mon Aug 24 17:35:07 2009 +0900

    sh: Optimise memcpy_to/fromio for SH4
    
    Optimise memcpy_to/fromio. This is used extensivly by MTD, so is a
    worthwhile performance gain. The main savings come from not repeatedly
    calling readl/writel, and doing word instead of byte at a time
    transfers. Also using "movca.l" on SH4 gives a small performance win.
    
    Signed-off-by: Stuart Menefy <stuart.menefy@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io.c b/arch/sh/kernel/io.c
index d0ca9684b781..4770c241c679 100644
--- a/arch/sh/kernel/io.c
+++ b/arch/sh/kernel/io.c
@@ -1,12 +1,9 @@
 /*
- * linux/arch/sh/kernel/io.c
+ * arch/sh/kernel/io.c - Machine independent I/O functions.
  *
- * Copyright (C) 2000  Stuart Menefy
+ * Copyright (C) 2000 - 2009  Stuart Menefy
  * Copyright (C) 2005  Paul Mundt
  *
- * Provide real functions which expand to whatever the header file defined.
- * Also definitions of machine independent IO functions.
- *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
@@ -18,33 +15,87 @@
 
 /*
  * Copy data from IO memory space to "real" memory space.
- * This needs to be optimized.
  */
 void memcpy_fromio(void *to, const volatile void __iomem *from, unsigned long count)
 {
-	unsigned char *p = to;
-        while (count) {
-                count--;
-                *p = readb(from);
-                p++;
-                from++;
-        }
+	/*
+	 * Would it be worthwhile doing byte and long transfers first
+	 * to try and get aligned?
+	 */
+#ifdef CONFIG_CPU_SH4
+	if ((count >= 0x20) &&
+	     (((u32)to & 0x1f) == 0) && (((u32)from & 0x3) == 0)) {
+		int tmp2, tmp3, tmp4, tmp5, tmp6;
+
+		__asm__ __volatile__(
+			"1:			\n\t"
+			"mov.l	@%7+, r0	\n\t"
+			"mov.l	@%7+, %2	\n\t"
+			"movca.l r0, @%0	\n\t"
+			"mov.l	@%7+, %3	\n\t"
+			"mov.l	@%7+, %4	\n\t"
+			"mov.l	@%7+, %5	\n\t"
+			"mov.l	@%7+, %6	\n\t"
+			"mov.l	@%7+, r7	\n\t"
+			"mov.l	@%7+, r0	\n\t"
+			"mov.l	%2, @(0x04,%0)	\n\t"
+			"mov	#0x20, %2	\n\t"
+			"mov.l	%3, @(0x08,%0)	\n\t"
+			"sub	%2, %1		\n\t"
+			"mov.l	%4, @(0x0c,%0)	\n\t"
+			"cmp/hi	%1, %2		! T if 32 > count	\n\t"
+			"mov.l	%5, @(0x10,%0)	\n\t"
+			"mov.l	%6, @(0x14,%0)	\n\t"
+			"mov.l	r7, @(0x18,%0)	\n\t"
+			"mov.l	r0, @(0x1c,%0)	\n\t"
+			"bf.s	1b		\n\t"
+			" add	#0x20, %0	\n\t"
+			: "=&r" (to), "=&r" (count),
+			  "=&r" (tmp2), "=&r" (tmp3), "=&r" (tmp4),
+			  "=&r" (tmp5), "=&r" (tmp6), "=&r" (from)
+			: "7"(from), "0" (to), "1" (count)
+			: "r0", "r7", "t", "memory");
+	}
+#endif
+
+	if ((((u32)to | (u32)from) & 0x3) == 0) {
+		for (; count > 3; count -= 4) {
+			*(u32 *)to = *(volatile u32 *)from;
+			to += 4;
+			from += 4;
+		}
+	}
+
+	for (; count > 0; count--) {
+		*(u8 *)to = *(volatile u8 *)from;
+		to++;
+		from++;
+	}
+
+	mb();
 }
 EXPORT_SYMBOL(memcpy_fromio);
 
 /*
  * Copy data from "real" memory space to IO memory space.
- * This needs to be optimized.
  */
 void memcpy_toio(volatile void __iomem *to, const void *from, unsigned long count)
 {
-	const unsigned char *p = from;
-        while (count) {
-                count--;
-                writeb(*p, to);
-                p++;
-                to++;
-        }
+	if ((((u32)to | (u32)from) & 0x3) == 0) {
+		for ( ; count > 3; count -= 4) {
+			*(volatile u32 *)to = *(u32 *)from;
+			to += 4;
+			from += 4;
+		}
+	}
+
+	for (; count > 0; count--) {
+		*(volatile u8 *)to = *(u8 *)from;
+		to++;
+		from++;
+	}
+
+	mb();
 }
 EXPORT_SYMBOL(memcpy_toio);
 

commit 15444a8973dcfbd286b3e638cbadac2446a9271a
Author: David McKay <david.mckay@st.com>
Date:   Mon Aug 24 16:10:40 2009 +0900

    sh: Allow use of GENERIC_IOMAP
    
    The synopsys PCI cell used in the later STMicro chips requires code to
    be run in order to do IO cycles, rather than just memory mapping the IO
    space. Rather than extending the existing SH infrastructure to allow
    this, use the GENERIC_IOMAP implmentation to save re-inventing the
    wheel.
    
    This set of changes allows the SH to be built with GENERIC_IOMAP
    enabled, it just ifdef's out the functions provided by the GENERIC_IOMAP
    implementation, and provides a few required missing functions.
    
    Signed-off-by: David McKay <david.mckay@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io.c b/arch/sh/kernel/io.c
index 4f85fffaa557..d0ca9684b781 100644
--- a/arch/sh/kernel/io.c
+++ b/arch/sh/kernel/io.c
@@ -62,6 +62,8 @@ void memset_io(volatile void __iomem *dst, int c, unsigned long count)
 }
 EXPORT_SYMBOL(memset_io);
 
+#ifndef CONFIG_GENERIC_IOMAP
+
 void __iomem *ioport_map(unsigned long port, unsigned int nr)
 {
 	void __iomem *ret;
@@ -79,3 +81,5 @@ void ioport_unmap(void __iomem *addr)
 	sh_mv.mv_ioport_unmap(addr);
 }
 EXPORT_SYMBOL(ioport_unmap);
+
+#endif /* CONFIG_GENERIC_IOMAP */

commit 0bb34a6bf1f71d5ad2abfda582a2c2794957bc7b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Apr 20 16:38:00 2009 +0900

    sh: pci: Consolidate pci_iomap() and use the generic I/O base.
    
    This consolidates the pci_iomap() definitions and reworks how the I/O
    port base is handled. PCI channels can register their own I/O map base,
    or if none is provided, the system-wide generic I/O base is used instead.
    
    Functionally nothing changes, while this allows us to kill off lots of
    I/O address special casing and lookups.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io.c b/arch/sh/kernel/io.c
index 59fb020718a3..4f85fffaa557 100644
--- a/arch/sh/kernel/io.c
+++ b/arch/sh/kernel/io.c
@@ -70,10 +70,6 @@ void __iomem *ioport_map(unsigned long port, unsigned int nr)
 	if (ret)
 		return ret;
 
-	ret = __get_pci_io_base(port, nr);
-	if (ret)
-		return ret;
-
 	return __ioport_map(port, nr);
 }
 EXPORT_SYMBOL(ioport_map);

commit 8ce0143b11cdc519b8e1fd94a262b654ef0bc3ab
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Tue Feb 19 21:35:31 2008 +0900

    sh: pci io port base address code
    
    Adds a __get_pci_io_base() function which is used to match a port range
    against struct pci_channel. This allows us to detect if a port range is
    assigned to pci or happens to be legacy port io. While at it, remove unused
    cpu-specific cruft.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io.c b/arch/sh/kernel/io.c
index 29cf4588fc05..59fb020718a3 100644
--- a/arch/sh/kernel/io.c
+++ b/arch/sh/kernel/io.c
@@ -12,6 +12,7 @@
  * for more details.
  */
 #include <linux/module.h>
+#include <linux/pci.h>
 #include <asm/machvec.h>
 #include <asm/io.h>
 
@@ -69,6 +70,10 @@ void __iomem *ioport_map(unsigned long port, unsigned int nr)
 	if (ret)
 		return ret;
 
+	ret = __get_pci_io_base(port, nr);
+	if (ret)
+		return ret;
+
 	return __ioport_map(port, nr);
 }
 EXPORT_SYMBOL(ioport_map);

commit 14866543ad22014a0b12e10657a917eb6b487248
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sat Oct 4 05:25:52 2008 +0900

    sh: More I/O routine overhauling.
    
    This tidies up a lot of the PIO/MMIO split. No in-tree platforms were
    making use of the MMIO overloading through the machvec (nor have any of
    them been in some time), so we just kill all of that off. The ISA I/O
    routine wrapping remains unaffected, which remains the only special
    casing outside of the iomap API that boards need to think about.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io.c b/arch/sh/kernel/io.c
index 2b8991229900..29cf4588fc05 100644
--- a/arch/sh/kernel/io.c
+++ b/arch/sh/kernel/io.c
@@ -19,12 +19,12 @@
  * Copy data from IO memory space to "real" memory space.
  * This needs to be optimized.
  */
-void memcpy_fromio(void *to, volatile void __iomem *from, unsigned long count)
+void memcpy_fromio(void *to, const volatile void __iomem *from, unsigned long count)
 {
-	char *p = to;
+	unsigned char *p = to;
         while (count) {
                 count--;
-                *p = readb((void __iomem *)from);
+                *p = readb(from);
                 p++;
                 from++;
         }
@@ -37,10 +37,10 @@ EXPORT_SYMBOL(memcpy_fromio);
  */
 void memcpy_toio(volatile void __iomem *to, const void *from, unsigned long count)
 {
-	const char *p = from;
+	const unsigned char *p = from;
         while (count) {
                 count--;
-                writeb(*p, (void __iomem *)to);
+                writeb(*p, to);
                 p++;
                 to++;
         }
@@ -55,7 +55,7 @@ void memset_io(volatile void __iomem *dst, int c, unsigned long count)
 {
         while (count) {
                 count--;
-                writeb(c, (void __iomem *)dst);
+                writeb(c, dst);
                 dst++;
         }
 }

commit e7cc9a7340b8ec018caa9eb1d035fdaef1f2fc51
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Thu Feb 7 20:18:21 2008 +0900

    sh: trapped io support V2
    
    The idea is that we want to get rid of the in/out/readb/writeb callbacks from
    the machvec and replace that with simple inline read and write operations to
    memory. Fast and simple for most hardware devices (think pci).
    
    Some devices require special treatment though - like 16-bit only CF devices -
    so we need to have some method to hook in callbacks.
    
    This patch makes it possible to add a per-device trap generating filter. This
    way we can get maximum performance of sane hardware - which doesn't need this
    filter - and crappy hardware works but gets punished by a performance hit.
    
    V2 changes things around a bit and replaces io access callbacks with a
    simple minimum_bus_width value. In the future we can add stride as well.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io.c b/arch/sh/kernel/io.c
index 71c9fde2fd90..2b8991229900 100644
--- a/arch/sh/kernel/io.c
+++ b/arch/sh/kernel/io.c
@@ -63,7 +63,13 @@ EXPORT_SYMBOL(memset_io);
 
 void __iomem *ioport_map(unsigned long port, unsigned int nr)
 {
-	return sh_mv.mv_ioport_map(port, nr);
+	void __iomem *ret;
+
+	ret = __ioport_map_trapped(port, nr);
+	if (ret)
+		return ret;
+
+	return __ioport_map(port, nr);
 }
 EXPORT_SYMBOL(ioport_map);
 

commit 62d6b66edc68f906138df7ba01efd41a45981586
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Nov 9 14:06:24 2007 +0900

    sh: Move sh32 optimized I/O routines to arch/sh/lib/
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io.c b/arch/sh/kernel/io.c
index 501fe03e3715..71c9fde2fd90 100644
--- a/arch/sh/kernel/io.c
+++ b/arch/sh/kernel/io.c
@@ -61,73 +61,6 @@ void memset_io(volatile void __iomem *dst, int c, unsigned long count)
 }
 EXPORT_SYMBOL(memset_io);
 
-void __raw_readsl(unsigned long addr, void *datap, int len)
-{
-	u32 *data;
-
-	for (data = datap; (len != 0) && (((u32)data & 0x1f) != 0); len--)
-		*data++ = ctrl_inl(addr);
-
-	if (likely(len >= (0x20 >> 2))) {
-		int tmp2, tmp3, tmp4, tmp5, tmp6;
-
-		__asm__ __volatile__(
-			"1:			\n\t"
-			"mov.l	@%7, r0		\n\t"
-			"mov.l	@%7, %2		\n\t"
-#ifdef CONFIG_CPU_SH4
-			"movca.l r0, @%0	\n\t"
-#else
-			"mov.l	r0, @%0		\n\t"
-#endif
-			"mov.l	@%7, %3		\n\t"
-			"mov.l	@%7, %4		\n\t"
-			"mov.l	@%7, %5		\n\t"
-			"mov.l	@%7, %6		\n\t"
-			"mov.l	@%7, r7		\n\t"
-			"mov.l	@%7, r0		\n\t"
-			"mov.l	%2, @(0x04,%0)	\n\t"
-			"mov	#0x20>>2, %2	\n\t"
-			"mov.l	%3, @(0x08,%0)	\n\t"
-			"sub	%2, %1		\n\t"
-			"mov.l	%4, @(0x0c,%0)	\n\t"
-			"cmp/hi	%1, %2		! T if 32 > len	\n\t"
-			"mov.l	%5, @(0x10,%0)	\n\t"
-			"mov.l	%6, @(0x14,%0)	\n\t"
-			"mov.l	r7, @(0x18,%0)	\n\t"
-			"mov.l	r0, @(0x1c,%0)	\n\t"
-			"bf.s	1b		\n\t"
-			" add	#0x20, %0	\n\t"
-			: "=&r" (data), "=&r" (len),
-			  "=&r" (tmp2), "=&r" (tmp3), "=&r" (tmp4),
-			  "=&r" (tmp5), "=&r" (tmp6)
-			: "r"(addr), "0" (data), "1" (len)
-			: "r0", "r7", "t", "memory");
-	}
-
-	for (; len != 0; len--)
-		*data++ = ctrl_inl(addr);
-}
-EXPORT_SYMBOL(__raw_readsl);
-
-void __raw_writesl(unsigned long addr, const void *data, int len)
-{
-	if (likely(len != 0)) {
-		int tmp1;
-
-		__asm__ __volatile__ (
-			"1:				\n\t"
-			"mov.l	@%0+, %1	\n\t"
-			"dt		%3		\n\t"
-			"bf.s		1b		\n\t"
-			" mov.l	%1, @%4		\n\t"
-			: "=&r" (data), "=&r" (tmp1)
-			: "0" (data), "r" (len), "r"(addr)
-			: "t", "memory");
-	}
-}
-EXPORT_SYMBOL(__raw_writesl);
-
 void __iomem *ioport_map(unsigned long port, unsigned int nr)
 {
 	return sh_mv.mv_ioport_map(port, nr);

commit 05ae91585167410dadd1bc8f2e207a062e638a16
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 18:25:24 2006 +0900

    sh: Optimized readsl()/writesl() support.
    
    Implement optimized copies of readsl()/writesl().
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/io.c b/arch/sh/kernel/io.c
index 71c9fde2fd90..501fe03e3715 100644
--- a/arch/sh/kernel/io.c
+++ b/arch/sh/kernel/io.c
@@ -61,6 +61,73 @@ void memset_io(volatile void __iomem *dst, int c, unsigned long count)
 }
 EXPORT_SYMBOL(memset_io);
 
+void __raw_readsl(unsigned long addr, void *datap, int len)
+{
+	u32 *data;
+
+	for (data = datap; (len != 0) && (((u32)data & 0x1f) != 0); len--)
+		*data++ = ctrl_inl(addr);
+
+	if (likely(len >= (0x20 >> 2))) {
+		int tmp2, tmp3, tmp4, tmp5, tmp6;
+
+		__asm__ __volatile__(
+			"1:			\n\t"
+			"mov.l	@%7, r0		\n\t"
+			"mov.l	@%7, %2		\n\t"
+#ifdef CONFIG_CPU_SH4
+			"movca.l r0, @%0	\n\t"
+#else
+			"mov.l	r0, @%0		\n\t"
+#endif
+			"mov.l	@%7, %3		\n\t"
+			"mov.l	@%7, %4		\n\t"
+			"mov.l	@%7, %5		\n\t"
+			"mov.l	@%7, %6		\n\t"
+			"mov.l	@%7, r7		\n\t"
+			"mov.l	@%7, r0		\n\t"
+			"mov.l	%2, @(0x04,%0)	\n\t"
+			"mov	#0x20>>2, %2	\n\t"
+			"mov.l	%3, @(0x08,%0)	\n\t"
+			"sub	%2, %1		\n\t"
+			"mov.l	%4, @(0x0c,%0)	\n\t"
+			"cmp/hi	%1, %2		! T if 32 > len	\n\t"
+			"mov.l	%5, @(0x10,%0)	\n\t"
+			"mov.l	%6, @(0x14,%0)	\n\t"
+			"mov.l	r7, @(0x18,%0)	\n\t"
+			"mov.l	r0, @(0x1c,%0)	\n\t"
+			"bf.s	1b		\n\t"
+			" add	#0x20, %0	\n\t"
+			: "=&r" (data), "=&r" (len),
+			  "=&r" (tmp2), "=&r" (tmp3), "=&r" (tmp4),
+			  "=&r" (tmp5), "=&r" (tmp6)
+			: "r"(addr), "0" (data), "1" (len)
+			: "r0", "r7", "t", "memory");
+	}
+
+	for (; len != 0; len--)
+		*data++ = ctrl_inl(addr);
+}
+EXPORT_SYMBOL(__raw_readsl);
+
+void __raw_writesl(unsigned long addr, const void *data, int len)
+{
+	if (likely(len != 0)) {
+		int tmp1;
+
+		__asm__ __volatile__ (
+			"1:				\n\t"
+			"mov.l	@%0+, %1	\n\t"
+			"dt		%3		\n\t"
+			"bf.s		1b		\n\t"
+			" mov.l	%1, @%4		\n\t"
+			: "=&r" (data), "=&r" (tmp1)
+			: "0" (data), "r" (len), "r"(addr)
+			: "t", "memory");
+	}
+}
+EXPORT_SYMBOL(__raw_writesl);
+
 void __iomem *ioport_map(unsigned long port, unsigned int nr)
 {
 	return sh_mv.mv_ioport_map(port, nr);

commit b66c1a3919abb40f9bd8fb92a0d9fd77eb899c54
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Jan 16 22:14:15 2006 -0800

    [PATCH] sh: I/O routine cleanups and ioremap() overhaul
    
    This introduces a few changes in the way that the I/O routines are defined on
    SH, specifically so that things like the iomap API properly wrap through the
    machvec for board-specific quirks.
    
    In addition to this, the old p3_ioremap() work is converted to a more generic
    __ioremap() that will map through the PMB if it's available, or fall back on
    page tables for everything else.
    
    An alpha-like IO_CONCAT is also added so we can start to clean up the
    board-specific io.h mess, which will be handled in board update patches..
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/kernel/io.c b/arch/sh/kernel/io.c
index d9932f25993b..71c9fde2fd90 100644
--- a/arch/sh/kernel/io.c
+++ b/arch/sh/kernel/io.c
@@ -2,58 +2,73 @@
  * linux/arch/sh/kernel/io.c
  *
  * Copyright (C) 2000  Stuart Menefy
+ * Copyright (C) 2005  Paul Mundt
  *
  * Provide real functions which expand to whatever the header file defined.
  * Also definitions of machine independent IO functions.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
  */
-
-#include <asm/io.h>
 #include <linux/module.h>
+#include <asm/machvec.h>
+#include <asm/io.h>
 
 /*
  * Copy data from IO memory space to "real" memory space.
  * This needs to be optimized.
  */
-void  memcpy_fromio(void * to, unsigned long from, unsigned long count)
+void memcpy_fromio(void *to, volatile void __iomem *from, unsigned long count)
 {
 	char *p = to;
         while (count) {
                 count--;
-                *p = readb(from);
+                *p = readb((void __iomem *)from);
                 p++;
                 from++;
         }
 }
- 
+EXPORT_SYMBOL(memcpy_fromio);
+
 /*
  * Copy data from "real" memory space to IO memory space.
  * This needs to be optimized.
  */
-void  memcpy_toio(unsigned long to, const void * from, unsigned long count)
+void memcpy_toio(volatile void __iomem *to, const void *from, unsigned long count)
 {
 	const char *p = from;
         while (count) {
                 count--;
-                writeb(*p, to);
+                writeb(*p, (void __iomem *)to);
                 p++;
                 to++;
         }
 }
- 
+EXPORT_SYMBOL(memcpy_toio);
+
 /*
  * "memset" on IO memory space.
  * This needs to be optimized.
  */
-void  memset_io(unsigned long dst, int c, unsigned long count)
+void memset_io(volatile void __iomem *dst, int c, unsigned long count)
 {
         while (count) {
                 count--;
-                writeb(c, dst);
+                writeb(c, (void __iomem *)dst);
                 dst++;
         }
 }
-
-EXPORT_SYMBOL(memcpy_fromio);
-EXPORT_SYMBOL(memcpy_toio);
 EXPORT_SYMBOL(memset_io);
 
+void __iomem *ioport_map(unsigned long port, unsigned int nr)
+{
+	return sh_mv.mv_ioport_map(port, nr);
+}
+EXPORT_SYMBOL(ioport_map);
+
+void ioport_unmap(void __iomem *addr)
+{
+	sh_mv.mv_ioport_unmap(addr);
+}
+EXPORT_SYMBOL(ioport_unmap);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/sh/kernel/io.c b/arch/sh/kernel/io.c
new file mode 100644
index 000000000000..d9932f25993b
--- /dev/null
+++ b/arch/sh/kernel/io.c
@@ -0,0 +1,59 @@
+/*
+ * linux/arch/sh/kernel/io.c
+ *
+ * Copyright (C) 2000  Stuart Menefy
+ *
+ * Provide real functions which expand to whatever the header file defined.
+ * Also definitions of machine independent IO functions.
+ */
+
+#include <asm/io.h>
+#include <linux/module.h>
+
+/*
+ * Copy data from IO memory space to "real" memory space.
+ * This needs to be optimized.
+ */
+void  memcpy_fromio(void * to, unsigned long from, unsigned long count)
+{
+	char *p = to;
+        while (count) {
+                count--;
+                *p = readb(from);
+                p++;
+                from++;
+        }
+}
+ 
+/*
+ * Copy data from "real" memory space to IO memory space.
+ * This needs to be optimized.
+ */
+void  memcpy_toio(unsigned long to, const void * from, unsigned long count)
+{
+	const char *p = from;
+        while (count) {
+                count--;
+                writeb(*p, to);
+                p++;
+                to++;
+        }
+}
+ 
+/*
+ * "memset" on IO memory space.
+ * This needs to be optimized.
+ */
+void  memset_io(unsigned long dst, int c, unsigned long count)
+{
+        while (count) {
+                count--;
+                writeb(c, dst);
+                dst++;
+        }
+}
+
+EXPORT_SYMBOL(memcpy_fromio);
+EXPORT_SYMBOL(memcpy_toio);
+EXPORT_SYMBOL(memset_io);
+
