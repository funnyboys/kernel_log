commit 201e91091b1d47047f55580b5474e1239f4d17aa
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Oct 3 11:29:13 2019 +0200

    sh: add the sh_ prefix to early platform symbols
    
    Old early platform device support is now sh-specific. Before moving on
    to implementing new early platform framework based on real platform
    devices, prefix all early platform symbols with 'sh_'.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Cc: Rich Felker <dalias@libc.org>
    Link: https://lore.kernel.org/r/20191003092913.10731-3-brgl@bgdev.pl
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index e82398d80b74..7014d6d199b3 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -153,7 +153,7 @@ arch_initcall(shx3_devices_setup);
 
 void __init plat_early_device_setup(void)
 {
-	early_platform_add_devices(shx3_early_devices,
+	sh_early_platform_add_devices(shx3_early_devices,
 				   ARRAY_SIZE(shx3_early_devices));
 }
 

commit 507fd01d5333338753a1cc26322dfc9f856c109f
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Oct 3 11:29:12 2019 +0200

    drivers: move the early platform device support to arch/sh
    
    SuperH is the only user of the current implementation of early platform
    device support. We want to introduce a more robust approach to early
    probing. As the first step - move all the current early platform code
    to arch/sh.
    
    In order not to export internal drivers/base functions to arch code for
    this temporary solution - copy the two needed routines for driver
    matching from drivers/base/platform.c to arch/sh/drivers/platform_early.c.
    
    Also: call early_platform_cleanup() from subsys_initcall() so that it's
    called after all early devices are probed.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Cc: Rich Felker <dalias@libc.org>
    Link: https://lore.kernel.org/r/20191003092913.10731-2-brgl@bgdev.pl
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 14aa4552bc45..e82398d80b74 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -14,6 +14,7 @@
 #include <linux/sh_intc.h>
 #include <cpu/shx3.h>
 #include <asm/mmzone.h>
+#include <asm/platform_early.h>
 
 /*
  * This intentionally only registers SCIF ports 0, 1, and 3. SCIF 2

commit add5ca2c48870cc6632179eccd0f0048a03fe43f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 28 00:32:11 2018 -0800

    sh: sh4a: convert to SPDX identifiers
    
    Update license to use SPDX-License-Identifier instead of verbose license
    text.
    
    Link: http://lkml.kernel.org/r/878t14csxy.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index ee14d92d840f..14aa4552bc45 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -1,11 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * SH-X3 Prototype Setup
  *
  *  Copyright (C) 2007 - 2010  Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 #include <linux/platform_device.h>
 #include <linux/init.h>

commit 9c21ac508c6a75ba2670efe25f6de902ce32e98e
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Wed Jan 11 16:43:28 2017 +0200

    sh: Don't set the sh-sci pdata UPF_BOOT_AUTOCONF flags
    
    The flag is set by the driver internally, don't set it in platform data.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 5495d6693086..ee14d92d840f 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -28,7 +28,6 @@
  * all rather than adding infrastructure to hack around it.
  */
 static struct plat_sci_port scif0_platform_data = {
-	.flags		= UPF_BOOT_AUTOCONF,
 	.scscr		= SCSCR_REIE,
 	.type		= PORT_SCIF,
 };
@@ -52,7 +51,6 @@ static struct platform_device scif0_device = {
 };
 
 static struct plat_sci_port scif1_platform_data = {
-	.flags		= UPF_BOOT_AUTOCONF,
 	.scscr		= SCSCR_REIE,
 	.type		= PORT_SCIF,
 };
@@ -76,7 +74,6 @@ static struct platform_device scif1_device = {
 };
 
 static struct plat_sci_port scif2_platform_data = {
-	.flags		= UPF_BOOT_AUTOCONF,
 	.scscr		= SCSCR_REIE,
 	.type		= PORT_SCIF,
 };

commit c3fa400b276325b57a20e1e54e6fcc18a98e962c
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Wed Jan 11 16:43:25 2017 +0200

    sh: Don't set sh-sci pdata scscr TE and RE bits
    
    The bits are set by the driver internally, don't set them in platform
    data.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index a78c5feb4e3b..5495d6693086 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -29,7 +29,7 @@
  */
 static struct plat_sci_port scif0_platform_data = {
 	.flags		= UPF_BOOT_AUTOCONF,
-	.scscr		= SCSCR_RE | SCSCR_TE | SCSCR_REIE,
+	.scscr		= SCSCR_REIE,
 	.type		= PORT_SCIF,
 };
 
@@ -53,7 +53,7 @@ static struct platform_device scif0_device = {
 
 static struct plat_sci_port scif1_platform_data = {
 	.flags		= UPF_BOOT_AUTOCONF,
-	.scscr		= SCSCR_RE | SCSCR_TE | SCSCR_REIE,
+	.scscr		= SCSCR_REIE,
 	.type		= PORT_SCIF,
 };
 
@@ -77,7 +77,7 @@ static struct platform_device scif1_device = {
 
 static struct plat_sci_port scif2_platform_data = {
 	.flags		= UPF_BOOT_AUTOCONF,
-	.scscr		= SCSCR_RE | SCSCR_TE | SCSCR_REIE,
+	.scscr		= SCSCR_REIE,
 	.type		= PORT_SCIF,
 };
 

commit 1399c195ef5009bf44a41649da4718f6e67c0bff
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Wed Apr 23 13:15:15 2014 +0200

    sh: Switch to new style TMU device
    
    The TMU (Timer Unit) driver implements a new style of platform data that
    handles the timer as a single device with multiple channel. Switch from
    the old-style platform data to the new-style platform data.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 0856bcbb1da0..a78c5feb4e3b 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -100,25 +100,18 @@ static struct platform_device scif2_device = {
 };
 
 static struct sh_timer_config tmu0_platform_data = {
-	.channel_offset = 0x04,
-	.timer_bit = 0,
-	.clockevent_rating = 200,
+	.channels_mask = 7,
 };
 
 static struct resource tmu0_resources[] = {
-	[0] = {
-		.start	= 0xffc10008,
-		.end	= 0xffc10013,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0x400),
-		.flags	= IORESOURCE_IRQ,
-	},
+	DEFINE_RES_MEM(0xffc10000, 0x30),
+	DEFINE_RES_IRQ(evt2irq(0x400)),
+	DEFINE_RES_IRQ(evt2irq(0x420)),
+	DEFINE_RES_IRQ(evt2irq(0x440)),
 };
 
 static struct platform_device tmu0_device = {
-	.name		= "sh_tmu",
+	.name		= "sh-tmu",
 	.id		= 0,
 	.dev = {
 		.platform_data	= &tmu0_platform_data,
@@ -128,25 +121,18 @@ static struct platform_device tmu0_device = {
 };
 
 static struct sh_timer_config tmu1_platform_data = {
-	.channel_offset = 0x10,
-	.timer_bit = 1,
-	.clocksource_rating = 200,
+	.channels_mask = 7,
 };
 
 static struct resource tmu1_resources[] = {
-	[0] = {
-		.start	= 0xffc10014,
-		.end	= 0xffc1001f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0x420),
-		.flags	= IORESOURCE_IRQ,
-	},
+	DEFINE_RES_MEM(0xffc20000, 0x2c),
+	DEFINE_RES_IRQ(evt2irq(0x460)),
+	DEFINE_RES_IRQ(evt2irq(0x480)),
+	DEFINE_RES_IRQ(evt2irq(0x4a0)),
 };
 
 static struct platform_device tmu1_device = {
-	.name		= "sh_tmu",
+	.name		= "sh-tmu",
 	.id		= 1,
 	.dev = {
 		.platform_data	= &tmu1_platform_data,
@@ -155,124 +141,12 @@ static struct platform_device tmu1_device = {
 	.num_resources	= ARRAY_SIZE(tmu1_resources),
 };
 
-static struct sh_timer_config tmu2_platform_data = {
-	.channel_offset = 0x1c,
-	.timer_bit = 2,
-};
-
-static struct resource tmu2_resources[] = {
-	[0] = {
-		.start	= 0xffc10020,
-		.end	= 0xffc1002f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0x440),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device tmu2_device = {
-	.name		= "sh_tmu",
-	.id		= 2,
-	.dev = {
-		.platform_data	= &tmu2_platform_data,
-	},
-	.resource	= tmu2_resources,
-	.num_resources	= ARRAY_SIZE(tmu2_resources),
-};
-
-static struct sh_timer_config tmu3_platform_data = {
-	.channel_offset = 0x04,
-	.timer_bit = 0,
-};
-
-static struct resource tmu3_resources[] = {
-	[0] = {
-		.start	= 0xffc20008,
-		.end	= 0xffc20013,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0x460),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device tmu3_device = {
-	.name		= "sh_tmu",
-	.id		= 3,
-	.dev = {
-		.platform_data	= &tmu3_platform_data,
-	},
-	.resource	= tmu3_resources,
-	.num_resources	= ARRAY_SIZE(tmu3_resources),
-};
-
-static struct sh_timer_config tmu4_platform_data = {
-	.channel_offset = 0x10,
-	.timer_bit = 1,
-};
-
-static struct resource tmu4_resources[] = {
-	[0] = {
-		.start	= 0xffc20014,
-		.end	= 0xffc2001f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0x480),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device tmu4_device = {
-	.name		= "sh_tmu",
-	.id		= 4,
-	.dev = {
-		.platform_data	= &tmu4_platform_data,
-	},
-	.resource	= tmu4_resources,
-	.num_resources	= ARRAY_SIZE(tmu4_resources),
-};
-
-static struct sh_timer_config tmu5_platform_data = {
-	.channel_offset = 0x1c,
-	.timer_bit = 2,
-};
-
-static struct resource tmu5_resources[] = {
-	[0] = {
-		.start	= 0xffc20020,
-		.end	= 0xffc2002b,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0x4a0),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device tmu5_device = {
-	.name		= "sh_tmu",
-	.id		= 5,
-	.dev = {
-		.platform_data	= &tmu5_platform_data,
-	},
-	.resource	= tmu5_resources,
-	.num_resources	= ARRAY_SIZE(tmu5_resources),
-};
-
 static struct platform_device *shx3_early_devices[] __initdata = {
 	&scif0_device,
 	&scif1_device,
 	&scif2_device,
 	&tmu0_device,
 	&tmu1_device,
-	&tmu2_device,
-	&tmu3_device,
-	&tmu4_device,
-	&tmu5_device,
 };
 
 static int __init shx3_devices_setup(void)

commit d5917ef318b850fc72bd10db438580f7d1c406d9
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Dec 6 10:59:50 2013 +0100

    sh: Don't set plat_sci_port scbrr_algo_id field
    
    The field will be removed from the sh-sci driver. Don't set it and let
    the driver handle baud rate calculation internally.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 4d65be9be001..0856bcbb1da0 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -30,7 +30,6 @@
 static struct plat_sci_port scif0_platform_data = {
 	.flags		= UPF_BOOT_AUTOCONF,
 	.scscr		= SCSCR_RE | SCSCR_TE | SCSCR_REIE,
-	.scbrr_algo_id	= SCBRR_ALGO_2,
 	.type		= PORT_SCIF,
 };
 
@@ -55,7 +54,6 @@ static struct platform_device scif0_device = {
 static struct plat_sci_port scif1_platform_data = {
 	.flags		= UPF_BOOT_AUTOCONF,
 	.scscr		= SCSCR_RE | SCSCR_TE | SCSCR_REIE,
-	.scbrr_algo_id	= SCBRR_ALGO_2,
 	.type		= PORT_SCIF,
 };
 
@@ -80,7 +78,6 @@ static struct platform_device scif1_device = {
 static struct plat_sci_port scif2_platform_data = {
 	.flags		= UPF_BOOT_AUTOCONF,
 	.scscr		= SCSCR_RE | SCSCR_TE | SCSCR_REIE,
-	.scbrr_algo_id	= SCBRR_ALGO_2,
 	.type		= PORT_SCIF,
 };
 

commit d850acf975bee46e43c3cd80d2d287010195c63b
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Dec 6 10:59:48 2013 +0100

    sh: Declare SCIF register base and IRQ as resources
    
    Passing the register base address and IRQ through platform data is
    deprecated. Use resources instead.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 688f7ed1bab1..4d65be9be001 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -28,60 +28,75 @@
  * all rather than adding infrastructure to hack around it.
  */
 static struct plat_sci_port scif0_platform_data = {
-	.mapbase	= 0xffc30000,
 	.flags		= UPF_BOOT_AUTOCONF,
 	.scscr		= SCSCR_RE | SCSCR_TE | SCSCR_REIE,
 	.scbrr_algo_id	= SCBRR_ALGO_2,
 	.type		= PORT_SCIF,
-	.irqs		= { evt2irq(0x700),
-			    evt2irq(0x720),
-			    evt2irq(0x760),
-			    evt2irq(0x740) },
+};
+
+static struct resource scif0_resources[] = {
+	DEFINE_RES_MEM(0xffc30000, 0x100),
+	DEFINE_RES_IRQ(evt2irq(0x700)),
+	DEFINE_RES_IRQ(evt2irq(0x720)),
+	DEFINE_RES_IRQ(evt2irq(0x760)),
+	DEFINE_RES_IRQ(evt2irq(0x740)),
 };
 
 static struct platform_device scif0_device = {
 	.name		= "sh-sci",
 	.id		= 0,
+	.resource	= scif0_resources,
+	.num_resources	= ARRAY_SIZE(scif0_resources),
 	.dev		= {
 		.platform_data	= &scif0_platform_data,
 	},
 };
 
 static struct plat_sci_port scif1_platform_data = {
-	.mapbase	= 0xffc40000,
 	.flags		= UPF_BOOT_AUTOCONF,
 	.scscr		= SCSCR_RE | SCSCR_TE | SCSCR_REIE,
 	.scbrr_algo_id	= SCBRR_ALGO_2,
 	.type		= PORT_SCIF,
-	.irqs		= { evt2irq(0x780),
-			    evt2irq(0x7a0),
-			    evt2irq(0x7e0),
-			    evt2irq(0x7c0) },
+};
+
+static struct resource scif1_resources[] = {
+	DEFINE_RES_MEM(0xffc40000, 0x100),
+	DEFINE_RES_IRQ(evt2irq(0x780)),
+	DEFINE_RES_IRQ(evt2irq(0x7a0)),
+	DEFINE_RES_IRQ(evt2irq(0x7e0)),
+	DEFINE_RES_IRQ(evt2irq(0x7c0)),
 };
 
 static struct platform_device scif1_device = {
 	.name		= "sh-sci",
 	.id		= 1,
+	.resource	= scif1_resources,
+	.num_resources	= ARRAY_SIZE(scif1_resources),
 	.dev		= {
 		.platform_data	= &scif1_platform_data,
 	},
 };
 
 static struct plat_sci_port scif2_platform_data = {
-	.mapbase	= 0xffc60000,
 	.flags		= UPF_BOOT_AUTOCONF,
 	.scscr		= SCSCR_RE | SCSCR_TE | SCSCR_REIE,
 	.scbrr_algo_id	= SCBRR_ALGO_2,
 	.type		= PORT_SCIF,
-	.irqs		= { evt2irq(0x880),
-			    evt2irq(0x8a0),
-			    evt2irq(0x8e0),
-			    evt2irq(0x8c0) },
+};
+
+static struct resource scif2_resources[] = {
+	DEFINE_RES_MEM(0xffc60000, 0x100),
+	DEFINE_RES_IRQ(evt2irq(0x880)),
+	DEFINE_RES_IRQ(evt2irq(0x8a0)),
+	DEFINE_RES_IRQ(evt2irq(0x8e0)),
+	DEFINE_RES_IRQ(evt2irq(0x8c0)),
 };
 
 static struct platform_device scif2_device = {
 	.name		= "sh-sci",
 	.id		= 2,
+	.resource	= scif2_resources,
+	.num_resources	= ARRAY_SIZE(scif2_resources),
 	.dev		= {
 		.platform_data	= &scif2_platform_data,
 	},

commit 5f19f14fed7786652b9617c633db101d26a42251
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 22 19:07:55 2012 +0900

    sh: intc: Kill off special reservation interface.
    
    At present reserving the IRLs in the IRQ bitmap in addition to the
    dropping of the legacy IRQ pre-allocation prevent IRL IRQs from being
    allocated for the x3proto board.
    
    The only reason to permit reservations was to lock down possible hardware
    vectors prior to dynamic IRQ scanning, but this doesn't matter much given
    that the hardware controller configuration is sorted before we get around
    to doing any dynamic IRQ allocation anyways. Beyond that, all of the
    tables are __init annotated, so quite a bit more work would need to be
    done to support reconfiguring things like IRL controllers on the fly,
    much more than would ever make it worth the hassle.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 7ca7dd20fb08..688f7ed1bab1 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -494,9 +494,6 @@ void __init plat_irq_setup_pins(int mode)
 
 void __init plat_irq_setup(void)
 {
-	reserve_intc_vectors(vectors_irq, ARRAY_SIZE(vectors_irq));
-	reserve_intc_vectors(vectors_irl, ARRAY_SIZE(vectors_irl));
-
 	register_intc_controller(&intc_desc);
 }
 

commit d8be10bbf3ba7eb4f1a9e609813fcbf916472e2f
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri May 18 14:11:22 2012 +0900

    sh: sh-x3 evt2irq migration.
    
    Migrate SH-X3 to evt2irq() backed hwirq lookups.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index bb208806dc1a..7ca7dd20fb08 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -14,6 +14,7 @@
 #include <linux/io.h>
 #include <linux/gpio.h>
 #include <linux/sh_timer.h>
+#include <linux/sh_intc.h>
 #include <cpu/shx3.h>
 #include <asm/mmzone.h>
 
@@ -32,7 +33,10 @@ static struct plat_sci_port scif0_platform_data = {
 	.scscr		= SCSCR_RE | SCSCR_TE | SCSCR_REIE,
 	.scbrr_algo_id	= SCBRR_ALGO_2,
 	.type		= PORT_SCIF,
-	.irqs		= { 40, 41, 43, 42 },
+	.irqs		= { evt2irq(0x700),
+			    evt2irq(0x720),
+			    evt2irq(0x760),
+			    evt2irq(0x740) },
 };
 
 static struct platform_device scif0_device = {
@@ -49,7 +53,10 @@ static struct plat_sci_port scif1_platform_data = {
 	.scscr		= SCSCR_RE | SCSCR_TE | SCSCR_REIE,
 	.scbrr_algo_id	= SCBRR_ALGO_2,
 	.type		= PORT_SCIF,
-	.irqs		= { 44, 45, 47, 46 },
+	.irqs		= { evt2irq(0x780),
+			    evt2irq(0x7a0),
+			    evt2irq(0x7e0),
+			    evt2irq(0x7c0) },
 };
 
 static struct platform_device scif1_device = {
@@ -66,7 +73,10 @@ static struct plat_sci_port scif2_platform_data = {
 	.scscr		= SCSCR_RE | SCSCR_TE | SCSCR_REIE,
 	.scbrr_algo_id	= SCBRR_ALGO_2,
 	.type		= PORT_SCIF,
-	.irqs		= { 52, 53, 55, 54 },
+	.irqs		= { evt2irq(0x880),
+			    evt2irq(0x8a0),
+			    evt2irq(0x8e0),
+			    evt2irq(0x8c0) },
 };
 
 static struct platform_device scif2_device = {
@@ -90,7 +100,7 @@ static struct resource tmu0_resources[] = {
 		.flags	= IORESOURCE_MEM,
 	},
 	[1] = {
-		.start	= 16,
+		.start	= evt2irq(0x400),
 		.flags	= IORESOURCE_IRQ,
 	},
 };
@@ -118,7 +128,7 @@ static struct resource tmu1_resources[] = {
 		.flags	= IORESOURCE_MEM,
 	},
 	[1] = {
-		.start	= 17,
+		.start	= evt2irq(0x420),
 		.flags	= IORESOURCE_IRQ,
 	},
 };
@@ -145,7 +155,7 @@ static struct resource tmu2_resources[] = {
 		.flags	= IORESOURCE_MEM,
 	},
 	[1] = {
-		.start	= 18,
+		.start	= evt2irq(0x440),
 		.flags	= IORESOURCE_IRQ,
 	},
 };
@@ -172,7 +182,7 @@ static struct resource tmu3_resources[] = {
 		.flags	= IORESOURCE_MEM,
 	},
 	[1] = {
-		.start	= 19,
+		.start	= evt2irq(0x460),
 		.flags	= IORESOURCE_IRQ,
 	},
 };
@@ -199,7 +209,7 @@ static struct resource tmu4_resources[] = {
 		.flags	= IORESOURCE_MEM,
 	},
 	[1] = {
-		.start	= 20,
+		.start	= evt2irq(0x480),
 		.flags	= IORESOURCE_IRQ,
 	},
 };
@@ -226,7 +236,7 @@ static struct resource tmu5_resources[] = {
 		.flags	= IORESOURCE_MEM,
 	},
 	[1] = {
-		.start	= 21,
+		.start	= evt2irq(0x4a0),
 		.flags	= IORESOURCE_IRQ,
 	},
 };

commit f43dc23d5ea91fca257be02138a255f02d98e806
Merge: f8e53553f452 4162cf64973d
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Jan 13 15:06:28 2011 +0900

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/torvalds/linux-2.6 into common/serial-rework
    
    Conflicts:
            arch/sh/kernel/cpu/sh2/setup-sh7619.c
            arch/sh/kernel/cpu/sh2a/setup-mxg.c
            arch/sh/kernel/cpu/sh2a/setup-sh7201.c
            arch/sh/kernel/cpu/sh2a/setup-sh7203.c
            arch/sh/kernel/cpu/sh2a/setup-sh7206.c
            arch/sh/kernel/cpu/sh3/setup-sh7705.c
            arch/sh/kernel/cpu/sh3/setup-sh770x.c
            arch/sh/kernel/cpu/sh3/setup-sh7710.c
            arch/sh/kernel/cpu/sh3/setup-sh7720.c
            arch/sh/kernel/cpu/sh4/setup-sh4-202.c
            arch/sh/kernel/cpu/sh4/setup-sh7750.c
            arch/sh/kernel/cpu/sh4/setup-sh7760.c
            arch/sh/kernel/cpu/sh4a/setup-sh7343.c
            arch/sh/kernel/cpu/sh4a/setup-sh7366.c
            arch/sh/kernel/cpu/sh4a/setup-sh7722.c
            arch/sh/kernel/cpu/sh4a/setup-sh7723.c
            arch/sh/kernel/cpu/sh4a/setup-sh7724.c
            arch/sh/kernel/cpu/sh4a/setup-sh7763.c
            arch/sh/kernel/cpu/sh4a/setup-sh7770.c
            arch/sh/kernel/cpu/sh4a/setup-sh7780.c
            arch/sh/kernel/cpu/sh4a/setup-sh7785.c
            arch/sh/kernel/cpu/sh4a/setup-sh7786.c
            arch/sh/kernel/cpu/sh4a/setup-shx3.c
            arch/sh/kernel/cpu/sh5/setup-sh5.c
            drivers/serial/sh-sci.c
            drivers/serial/sh-sci.h
            include/linux/serial_sci.h

commit 4bacd796ccd6976b03dd490708a1abc291d5521e
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sat Oct 2 22:02:07 2010 +0900

    sh: Support early IRQ vector map reservation for delayed controllers.
    
    Some controllers will need to be initialized lazily due to pinmux
    constraints, while others may simply have no need to be brought online if
    there are no backing devices for them attached. In this case it's still
    necessary to be able to reserve their hardware vector map before dynamic
    IRQs get a hold of them.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index f159ea2cebc7..013f0b144489 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -478,6 +478,9 @@ void __init plat_irq_setup_pins(int mode)
 
 void __init plat_irq_setup(void)
 {
+	reserve_intc_vectors(vectors_irq, ARRAY_SIZE(vectors_irq));
+	reserve_intc_vectors(vectors_irl, ARRAY_SIZE(vectors_irl));
+
 	register_intc_controller(&intc_desc);
 }
 

commit 742759eae6b58a172d8f79ff0938d1e25dc9abc5
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sat Oct 2 19:43:40 2010 +0900

    sh: Handle pinmux for SH-X3 proto IRQ/IRL modes.
    
    The SH-X3 proto CPU has all of the external IRQ and IRL pins muxed, make
    sure that we're able to grab them before attempting to register their
    respective IRQ controllers.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 04a487445aa6..f159ea2cebc7 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -12,7 +12,9 @@
 #include <linux/serial.h>
 #include <linux/serial_sci.h>
 #include <linux/io.h>
+#include <linux/gpio.h>
 #include <linux/sh_timer.h>
+#include <cpu/shx3.h>
 #include <asm/mmzone.h>
 
 /*
@@ -440,11 +442,33 @@ static DECLARE_INTC_DESC(intc_desc_irl, "shx3-irl", vectors_irl, groups,
 
 void __init plat_irq_setup_pins(int mode)
 {
+	int ret = 0;
+
 	switch (mode) {
 	case IRQ_MODE_IRQ:
+		ret |= gpio_request(GPIO_FN_IRQ3, intc_desc_irq.name);
+		ret |= gpio_request(GPIO_FN_IRQ2, intc_desc_irq.name);
+		ret |= gpio_request(GPIO_FN_IRQ1, intc_desc_irq.name);
+		ret |= gpio_request(GPIO_FN_IRQ0, intc_desc_irq.name);
+
+		if (unlikely(ret)) {
+			pr_err("Failed to set IRQ mode\n");
+			return;
+		}
+
 		register_intc_controller(&intc_desc_irq);
 		break;
 	case IRQ_MODE_IRL3210:
+		ret |= gpio_request(GPIO_FN_IRL3, intc_desc_irl.name);
+		ret |= gpio_request(GPIO_FN_IRL2, intc_desc_irl.name);
+		ret |= gpio_request(GPIO_FN_IRL1, intc_desc_irl.name);
+		ret |= gpio_request(GPIO_FN_IRL0, intc_desc_irl.name);
+
+		if (unlikely(ret)) {
+			pr_err("Failed to set IRL mode\n");
+			return;
+		}
+
 		register_intc_controller(&intc_desc_irl);
 		break;
 	default:

commit f9d885c3e59e50863565bddd2672656b57b15035
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sat Oct 2 01:04:30 2010 +0900

    sh: Support IRQ balancing for SH-X3 proto cores, too.
    
    This adds in hardware IRQ auto-distribution support for SH-X3 proto CPUs,
    following the SH7786 support.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 9158bc5ea38b..04a487445aa6 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -1,7 +1,7 @@
 /*
  * SH-X3 Prototype Setup
  *
- *  Copyright (C) 2007 - 2009  Paul Mundt
+ *  Copyright (C) 2007 - 2010  Paul Mundt
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -354,6 +354,10 @@ static struct intc_group groups[] __initdata = {
 		   DMAC1_DMINT9, DMAC1_DMINT10, DMAC1_DMINT11),
 };
 
+#define INT2DISTCR0	0xfe4108a0
+#define INT2DISTCR1	0xfe4108a4
+#define INT2DISTCR2	0xfe4108a8
+
 static struct intc_mask_reg mask_registers[] __initdata = {
 	{ 0xfe410030, 0xfe410050, 32, /* CnINTMSK0 / CnINTMSKCLR0 */
 	  { IRQ0, IRQ1, IRQ2, IRQ3 } },
@@ -363,20 +367,23 @@ static struct intc_mask_reg mask_registers[] __initdata = {
 	  { FE1, FE0, 0, ATAPI, VCORE0, VIN1, VIN0, IIC,
 	    DU, GPIO3, GPIO2, GPIO1, GPIO0, PAM, 0, 0,
 	    0, 0, 0, 0, 0, 0, 0, 0, /* HUDI bits ignored */
-	    0, TMU5, TMU4, TMU3, TMU2, TMU1, TMU0, 0, } },
+	    0, TMU5, TMU4, TMU3, TMU2, TMU1, TMU0, 0, },
+	    INTC_SMP_BALANCING(INT2DISTCR0) },
 	{ 0xfe410830, 0xfe410860, 32, /* CnINT2MSK1 / CnINT2MSKCLR1 */
 	  { 0, 0, 0, 0, DTU3, DTU2, DTU1, DTU0, /* IRM bits ignored */
 	    PCII9, PCII8, PCII7, PCII6, PCII5, PCII4, PCII3, PCII2,
 	    PCII1, PCII0, DMAC1_DMAE, DMAC1_DMINT11,
 	    DMAC1_DMINT10, DMAC1_DMINT9, DMAC1_DMINT8, DMAC1_DMINT7,
 	    DMAC1_DMINT6, DMAC0_DMAE, DMAC0_DMINT5, DMAC0_DMINT4,
-	    DMAC0_DMINT3, DMAC0_DMINT2, DMAC0_DMINT1, DMAC0_DMINT0 } },
+	    DMAC0_DMINT3, DMAC0_DMINT2, DMAC0_DMINT1, DMAC0_DMINT0 },
+	    INTC_SMP_BALANCING(INT2DISTCR1) },
 	{ 0xfe410840, 0xfe410870, 32, /* CnINT2MSK2 / CnINT2MSKCLR2 */
 	  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 	    SCIF3_TXI, SCIF3_BRI, SCIF3_RXI, SCIF3_ERI,
 	    SCIF2_TXI, SCIF2_BRI, SCIF2_RXI, SCIF2_ERI,
 	    SCIF1_TXI, SCIF1_BRI, SCIF1_RXI, SCIF1_ERI,
-	    SCIF0_TXI, SCIF0_BRI, SCIF0_RXI, SCIF0_ERI } },
+	    SCIF0_TXI, SCIF0_BRI, SCIF0_RXI, SCIF0_ERI },
+	    INTC_SMP_BALANCING(INT2DISTCR2) },
 };
 
 static struct intc_prio_reg prio_registers[] __initdata = {

commit 4dc50a068ad8fbbd2dd6dd5ac8ac2652589ba046
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Mar 29 17:25:03 2010 +0900

    sh: Kill off timer clock strings for legacy CPG parts.
    
    Now with the lookup aliases in place there is no longer any need to
    provide the clock string, kill it off for all legacy CPG CPUs.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index ba545b5ccc15..9158bc5ea38b 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -72,7 +72,6 @@ static struct platform_device scif2_device = {
 static struct sh_timer_config tmu0_platform_data = {
 	.channel_offset = 0x04,
 	.timer_bit = 0,
-	.clk = "peripheral_clk",
 	.clockevent_rating = 200,
 };
 
@@ -101,7 +100,6 @@ static struct platform_device tmu0_device = {
 static struct sh_timer_config tmu1_platform_data = {
 	.channel_offset = 0x10,
 	.timer_bit = 1,
-	.clk = "peripheral_clk",
 	.clocksource_rating = 200,
 };
 
@@ -130,7 +128,6 @@ static struct platform_device tmu1_device = {
 static struct sh_timer_config tmu2_platform_data = {
 	.channel_offset = 0x1c,
 	.timer_bit = 2,
-	.clk = "peripheral_clk",
 };
 
 static struct resource tmu2_resources[] = {
@@ -158,7 +155,6 @@ static struct platform_device tmu2_device = {
 static struct sh_timer_config tmu3_platform_data = {
 	.channel_offset = 0x04,
 	.timer_bit = 0,
-	.clk = "peripheral_clk",
 };
 
 static struct resource tmu3_resources[] = {
@@ -186,7 +182,6 @@ static struct platform_device tmu3_device = {
 static struct sh_timer_config tmu4_platform_data = {
 	.channel_offset = 0x10,
 	.timer_bit = 1,
-	.clk = "peripheral_clk",
 };
 
 static struct resource tmu4_resources[] = {
@@ -214,7 +209,6 @@ static struct platform_device tmu4_device = {
 static struct sh_timer_config tmu5_platform_data = {
 	.channel_offset = 0x1c,
 	.timer_bit = 2,
-	.clk = "peripheral_clk",
 };
 
 static struct resource tmu5_resources[] = {

commit ec0ffe2ee0e0fb9da4409d86bfd72636450f32df
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Mar 10 16:28:16 2010 +0900

    sh: Kill off all timer name clobbering.
    
    Now that dev_name() can be used early, we no longer require a static
    string. Kill off all of the superfluous timer names.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 780ba17a5599..ba545b5ccc15 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -70,7 +70,6 @@ static struct platform_device scif2_device = {
 };
 
 static struct sh_timer_config tmu0_platform_data = {
-	.name = "TMU0",
 	.channel_offset = 0x04,
 	.timer_bit = 0,
 	.clk = "peripheral_clk",
@@ -79,7 +78,6 @@ static struct sh_timer_config tmu0_platform_data = {
 
 static struct resource tmu0_resources[] = {
 	[0] = {
-		.name	= "TMU0",
 		.start	= 0xffc10008,
 		.end	= 0xffc10013,
 		.flags	= IORESOURCE_MEM,
@@ -101,7 +99,6 @@ static struct platform_device tmu0_device = {
 };
 
 static struct sh_timer_config tmu1_platform_data = {
-	.name = "TMU1",
 	.channel_offset = 0x10,
 	.timer_bit = 1,
 	.clk = "peripheral_clk",
@@ -110,7 +107,6 @@ static struct sh_timer_config tmu1_platform_data = {
 
 static struct resource tmu1_resources[] = {
 	[0] = {
-		.name	= "TMU1",
 		.start	= 0xffc10014,
 		.end	= 0xffc1001f,
 		.flags	= IORESOURCE_MEM,
@@ -132,7 +128,6 @@ static struct platform_device tmu1_device = {
 };
 
 static struct sh_timer_config tmu2_platform_data = {
-	.name = "TMU2",
 	.channel_offset = 0x1c,
 	.timer_bit = 2,
 	.clk = "peripheral_clk",
@@ -140,7 +135,6 @@ static struct sh_timer_config tmu2_platform_data = {
 
 static struct resource tmu2_resources[] = {
 	[0] = {
-		.name	= "TMU2",
 		.start	= 0xffc10020,
 		.end	= 0xffc1002f,
 		.flags	= IORESOURCE_MEM,
@@ -162,7 +156,6 @@ static struct platform_device tmu2_device = {
 };
 
 static struct sh_timer_config tmu3_platform_data = {
-	.name = "TMU3",
 	.channel_offset = 0x04,
 	.timer_bit = 0,
 	.clk = "peripheral_clk",
@@ -170,7 +163,6 @@ static struct sh_timer_config tmu3_platform_data = {
 
 static struct resource tmu3_resources[] = {
 	[0] = {
-		.name	= "TMU3",
 		.start	= 0xffc20008,
 		.end	= 0xffc20013,
 		.flags	= IORESOURCE_MEM,
@@ -192,7 +184,6 @@ static struct platform_device tmu3_device = {
 };
 
 static struct sh_timer_config tmu4_platform_data = {
-	.name = "TMU4",
 	.channel_offset = 0x10,
 	.timer_bit = 1,
 	.clk = "peripheral_clk",
@@ -200,7 +191,6 @@ static struct sh_timer_config tmu4_platform_data = {
 
 static struct resource tmu4_resources[] = {
 	[0] = {
-		.name	= "TMU4",
 		.start	= 0xffc20014,
 		.end	= 0xffc2001f,
 		.flags	= IORESOURCE_MEM,
@@ -222,7 +212,6 @@ static struct platform_device tmu4_device = {
 };
 
 static struct sh_timer_config tmu5_platform_data = {
-	.name = "TMU5",
 	.channel_offset = 0x1c,
 	.timer_bit = 2,
 	.clk = "peripheral_clk",
@@ -230,7 +219,6 @@ static struct sh_timer_config tmu5_platform_data = {
 
 static struct resource tmu5_resources[] = {
 	[0] = {
-		.name	= "TMU5",
 		.start	= 0xffc20020,
 		.end	= 0xffc2002b,
 		.flags	= IORESOURCE_MEM,

commit a9571d7b045eb3b38d856c6dfda1798fb67ca44c
Author: Magnus Damm <damm@opensource.se>
Date:   Mon Dec 14 12:30:31 2009 +0000

    sh: sh4a scif pdata (sh7757/sh7763/sh7770/sh7780/sh7785/sh7786/x3)
    
    This patch breaks out the sh4a scif serial port platform
    data from a shared platform device to one platform
    device per port. Also, add serial ports to the list of
    early platform devices.
    
    All sh4a except SuperH Mobile processors are modified by
    this patch.
    
    While at it, sh7757 gets early platform device support.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index c7ba9166e18a..780ba17a5599 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -24,32 +24,48 @@
  * silicon in the first place, we just refuse to deal with the port at
  * all rather than adding infrastructure to hack around it.
  */
-static struct plat_sci_port sci_platform_data[] = {
-	{
-		.mapbase	= 0xffc30000,
-		.flags		= UPF_BOOT_AUTOCONF,
-		.type		= PORT_SCIF,
-		.irqs		= { 40, 41, 43, 42 },
-	}, {
-		.mapbase	= 0xffc40000,
-		.flags		= UPF_BOOT_AUTOCONF,
-		.type		= PORT_SCIF,
-		.irqs		= { 44, 45, 47, 46 },
-	}, {
-		.mapbase	= 0xffc60000,
-		.flags		= UPF_BOOT_AUTOCONF,
-		.type		= PORT_SCIF,
-		.irqs		= { 52, 53, 55, 54 },
-	}, {
-		.flags = 0,
-	}
+static struct plat_sci_port scif0_platform_data = {
+	.mapbase	= 0xffc30000,
+	.flags		= UPF_BOOT_AUTOCONF,
+	.type		= PORT_SCIF,
+	.irqs		= { 40, 41, 43, 42 },
+};
+
+static struct platform_device scif0_device = {
+	.name		= "sh-sci",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &scif0_platform_data,
+	},
+};
+
+static struct plat_sci_port scif1_platform_data = {
+	.mapbase	= 0xffc40000,
+	.flags		= UPF_BOOT_AUTOCONF,
+	.type		= PORT_SCIF,
+	.irqs		= { 44, 45, 47, 46 },
+};
+
+static struct platform_device scif1_device = {
+	.name		= "sh-sci",
+	.id		= 1,
+	.dev		= {
+		.platform_data	= &scif1_platform_data,
+	},
+};
+
+static struct plat_sci_port scif2_platform_data = {
+	.mapbase	= 0xffc60000,
+	.flags		= UPF_BOOT_AUTOCONF,
+	.type		= PORT_SCIF,
+	.irqs		= { 52, 53, 55, 54 },
 };
 
-static struct platform_device sci_device = {
+static struct platform_device scif2_device = {
 	.name		= "sh-sci",
-	.id		= -1,
+	.id		= 2,
 	.dev		= {
-		.platform_data	= sci_platform_data,
+		.platform_data	= &scif2_platform_data,
 	},
 };
 
@@ -236,6 +252,9 @@ static struct platform_device tmu5_device = {
 };
 
 static struct platform_device *shx3_early_devices[] __initdata = {
+	&scif0_device,
+	&scif1_device,
+	&scif2_device,
 	&tmu0_device,
 	&tmu1_device,
 	&tmu2_device,
@@ -244,21 +263,10 @@ static struct platform_device *shx3_early_devices[] __initdata = {
 	&tmu5_device,
 };
 
-static struct platform_device *shx3_devices[] __initdata = {
-	&sci_device,
-};
-
 static int __init shx3_devices_setup(void)
 {
-	int ret;
-
-	ret = platform_add_devices(shx3_early_devices,
+	return platform_add_devices(shx3_early_devices,
 				   ARRAY_SIZE(shx3_early_devices));
-	if (unlikely(ret != 0))
-		return ret;
-
-	return platform_add_devices(shx3_devices,
-				    ARRAY_SIZE(shx3_devices));
 }
 arch_initcall(shx3_devices_setup);
 

commit 15dfdddbf0c2be680d5d2fe2bbe3aad3dba3cf0e
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sun Oct 18 15:13:28 2009 +0900

    sh: Disable SCIF2 on the SH-X3 proto CPU.
    
    SCIF2 and the FPU exceptions happen to share vector numbers, one in
    EXPEVT and the other in INTEVT. This is a violation of the interface and
    should have never made it in to silicon. On top of that, the demux hack
    that was added for special dispatch is rather error prone, and introduces
    more problems than it solves. Kill all of it off, and just refuse to deal
    with SCIF2 outright.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 485330cf8549..c7ba9166e18a 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -15,6 +15,15 @@
 #include <linux/sh_timer.h>
 #include <asm/mmzone.h>
 
+/*
+ * This intentionally only registers SCIF ports 0, 1, and 3. SCIF 2
+ * INTEVT values overlap with the FPU EXPEVT ones, requiring special
+ * demuxing in the exception dispatch path.
+ *
+ * As this overlap is something that never should have made it in to
+ * silicon in the first place, we just refuse to deal with the port at
+ * all rather than adding infrastructure to hack around it.
+ */
 static struct plat_sci_port sci_platform_data[] = {
 	{
 		.mapbase	= 0xffc30000,
@@ -26,11 +35,6 @@ static struct plat_sci_port sci_platform_data[] = {
 		.flags		= UPF_BOOT_AUTOCONF,
 		.type		= PORT_SCIF,
 		.irqs		= { 44, 45, 47, 46 },
-	}, {
-		.mapbase	= 0xffc50000,
-		.flags		= UPF_BOOT_AUTOCONF,
-		.type		= PORT_SCIF,
-		.irqs		= { 48, 49, 51, 50 },
 	}, {
 		.mapbase	= 0xffc60000,
 		.flags		= UPF_BOOT_AUTOCONF,
@@ -313,8 +317,6 @@ static struct intc_vect vectors[] __initdata = {
 	INTC_VECT(SCIF0_BRI, 0x740), INTC_VECT(SCIF0_TXI, 0x760),
 	INTC_VECT(SCIF1_ERI, 0x780), INTC_VECT(SCIF1_RXI, 0x7a0),
 	INTC_VECT(SCIF1_BRI, 0x7c0), INTC_VECT(SCIF1_TXI, 0x7e0),
-	INTC_VECT(SCIF2_ERI, 0x800), INTC_VECT(SCIF2_RXI, 0x820),
-	INTC_VECT(SCIF2_BRI, 0x840), INTC_VECT(SCIF2_TXI, 0x860),
 	INTC_VECT(SCIF3_ERI, 0x880), INTC_VECT(SCIF3_RXI, 0x8a0),
 	INTC_VECT(SCIF3_BRI, 0x8c0), INTC_VECT(SCIF3_TXI, 0x8e0),
 	INTC_VECT(DMAC0_DMINT0, 0x900), INTC_VECT(DMAC0_DMINT1, 0x920),
@@ -355,7 +357,6 @@ static struct intc_group groups[] __initdata = {
 	INTC_GROUP(PCII56789, PCII5, PCII6, PCII7, PCII8, PCII9),
 	INTC_GROUP(SCIF0, SCIF0_ERI, SCIF0_RXI, SCIF0_BRI, SCIF0_TXI),
 	INTC_GROUP(SCIF1, SCIF1_ERI, SCIF1_RXI, SCIF1_BRI, SCIF1_TXI),
-	INTC_GROUP(SCIF2, SCIF2_ERI, SCIF2_RXI, SCIF2_BRI, SCIF2_TXI),
 	INTC_GROUP(SCIF3, SCIF3_ERI, SCIF3_RXI, SCIF3_BRI, SCIF3_TXI),
 	INTC_GROUP(DMAC0, DMAC0_DMINT0, DMAC0_DMINT1, DMAC0_DMINT2,
 		   DMAC0_DMINT3, DMAC0_DMINT4, DMAC0_DMINT5, DMAC0_DMAE),

commit 3d4e0cfb3372ee7754f743ab90944540cef4ecc6
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sat Oct 10 22:45:41 2009 +0900

    sh: Reinstate ILSEL -> IRL intc mappings for SH-X3 proto CPU.
    
    In the multi-evt conversion for the SH-X3 proto CPU, IRLs were dropped
    down to a single unique masking source, which ended up blowing up on
    ILSEL-based IRQs which have special semantics that otherwise confuse the
    intc code. While this does result in intc spewing about not having a
    unique masking source, we don't really care.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index e848443deeb9..485330cf8549 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -268,7 +268,11 @@ enum {
 	UNUSED = 0,
 
 	/* interrupt sources */
-	IRL, IRQ0, IRQ1, IRQ2, IRQ3,
+	IRL_LLLL, IRL_LLLH, IRL_LLHL, IRL_LLHH,
+	IRL_LHLL, IRL_LHLH, IRL_LHHL, IRL_LHHH,
+	IRL_HLLL, IRL_HLLH, IRL_HLHL, IRL_HLHH,
+	IRL_HHLL, IRL_HHLH, IRL_HHHL,
+	IRQ0, IRQ1, IRQ2, IRQ3,
 	HUDII,
 	TMU0, TMU1, TMU2, TMU3, TMU4, TMU5,
 	PCII0, PCII1, PCII2, PCII3, PCII4,
@@ -291,7 +295,7 @@ enum {
 	INTICI4, INTICI5, INTICI6, INTICI7,
 
 	/* interrupt groups */
-	PCII56789, SCIF0, SCIF1, SCIF2, SCIF3,
+	IRL, PCII56789, SCIF0, SCIF1, SCIF2, SCIF3,
 	DMAC0, DMAC1,
 };
 
@@ -344,6 +348,10 @@ static struct intc_vect vectors[] __initdata = {
 };
 
 static struct intc_group groups[] __initdata = {
+	INTC_GROUP(IRL, IRL_LLLL, IRL_LLLH, IRL_LLHL, IRL_LLHH,
+		   IRL_LHLL, IRL_LHLH, IRL_LHHL, IRL_LHHH,
+		   IRL_HLLL, IRL_HLLH, IRL_HLHL, IRL_HLHH,
+		   IRL_HHLL, IRL_HHLH, IRL_HHHL),
 	INTC_GROUP(PCII56789, PCII5, PCII6, PCII7, PCII8, PCII9),
 	INTC_GROUP(SCIF0, SCIF0_ERI, SCIF0_RXI, SCIF0_BRI, SCIF0_TXI),
 	INTC_GROUP(SCIF1, SCIF1_ERI, SCIF1_RXI, SCIF1_BRI, SCIF1_TXI),
@@ -419,14 +427,14 @@ static DECLARE_INTC_DESC(intc_desc_irq, "shx3-irq", vectors_irq, groups,
 
 /* External interrupt pins in IRL mode */
 static struct intc_vect vectors_irl[] __initdata = {
-	INTC_VECT(IRL, 0x200), INTC_VECT(IRL, 0x220),
-	INTC_VECT(IRL, 0x240), INTC_VECT(IRL, 0x260),
-	INTC_VECT(IRL, 0x280), INTC_VECT(IRL, 0x2a0),
-	INTC_VECT(IRL, 0x2c0), INTC_VECT(IRL, 0x2e0),
-	INTC_VECT(IRL, 0x300), INTC_VECT(IRL, 0x320),
-	INTC_VECT(IRL, 0x340), INTC_VECT(IRL, 0x360),
-	INTC_VECT(IRL, 0x380), INTC_VECT(IRL, 0x3a0),
-	INTC_VECT(IRL, 0x3c0),
+	INTC_VECT(IRL_LLLL, 0x200), INTC_VECT(IRL_LLLH, 0x220),
+	INTC_VECT(IRL_LLHL, 0x240), INTC_VECT(IRL_LLHH, 0x260),
+	INTC_VECT(IRL_LHLL, 0x280), INTC_VECT(IRL_LHLH, 0x2a0),
+	INTC_VECT(IRL_LHHL, 0x2c0), INTC_VECT(IRL_LHHH, 0x2e0),
+	INTC_VECT(IRL_HLLL, 0x300), INTC_VECT(IRL_HLLH, 0x320),
+	INTC_VECT(IRL_HLHL, 0x340), INTC_VECT(IRL_HLHH, 0x360),
+	INTC_VECT(IRL_HHLL, 0x380), INTC_VECT(IRL_HHLH, 0x3a0),
+	INTC_VECT(IRL_HHHL, 0x3c0),
 };
 
 static DECLARE_INTC_DESC(intc_desc_irl, "shx3-irl", vectors_irl, groups,

commit 3639dfb57d39747a3069678237e8ab810525fcb0
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Sep 14 17:29:35 2009 +0900

    sh: multi-evt support for SH-X3 proto CPU.
    
    This adds support for multiple vectors per unique IRQ masking source on
    the SH-X3 proto CPU.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 07f078961c71..e848443deeb9 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -268,11 +268,7 @@ enum {
 	UNUSED = 0,
 
 	/* interrupt sources */
-	IRL_LLLL, IRL_LLLH, IRL_LLHL, IRL_LLHH,
-	IRL_LHLL, IRL_LHLH, IRL_LHHL, IRL_LHHH,
-	IRL_HLLL, IRL_HLLH, IRL_HLHL, IRL_HLHH,
-	IRL_HHLL, IRL_HHLH, IRL_HHHL,
-	IRQ0, IRQ1, IRQ2, IRQ3,
+	IRL, IRQ0, IRQ1, IRQ2, IRQ3,
 	HUDII,
 	TMU0, TMU1, TMU2, TMU3, TMU4, TMU5,
 	PCII0, PCII1, PCII2, PCII3, PCII4,
@@ -287,10 +283,7 @@ enum {
 	DMAC1_DMINT6, DMAC1_DMINT7, DMAC1_DMINT8, DMAC1_DMINT9,
 	DMAC1_DMINT10, DMAC1_DMINT11, DMAC1_DMAE,
 	IIC, VIN0, VIN1, VCORE0, ATAPI,
-	DTU0_TEND, DTU0_AE, DTU0_TMISS,
-	DTU1_TEND, DTU1_AE, DTU1_TMISS,
-	DTU2_TEND, DTU2_AE, DTU2_TMISS,
-	DTU3_TEND, DTU3_AE, DTU3_TMISS,
+	DTU0, DTU1, DTU2, DTU3,
 	FE0, FE1,
 	GPIO0, GPIO1, GPIO2, GPIO3,
 	PAM, IRM,
@@ -298,8 +291,8 @@ enum {
 	INTICI4, INTICI5, INTICI6, INTICI7,
 
 	/* interrupt groups */
-	IRL, PCII56789, SCIF0, SCIF1, SCIF2, SCIF3,
-	DMAC0, DMAC1, DTU0, DTU1, DTU2, DTU3,
+	PCII56789, SCIF0, SCIF1, SCIF2, SCIF3,
+	DMAC0, DMAC1,
 };
 
 static struct intc_vect vectors[] __initdata = {
@@ -332,14 +325,14 @@ static struct intc_vect vectors[] __initdata = {
 	INTC_VECT(IIC, 0xae0),
 	INTC_VECT(VIN0, 0xb00), INTC_VECT(VIN1, 0xb20),
 	INTC_VECT(VCORE0, 0xb00), INTC_VECT(ATAPI, 0xb60),
-	INTC_VECT(DTU0_TEND, 0xc00), INTC_VECT(DTU0_AE, 0xc20),
-	INTC_VECT(DTU0_TMISS, 0xc40),
-	INTC_VECT(DTU1_TEND, 0xc60), INTC_VECT(DTU1_AE, 0xc80),
-	INTC_VECT(DTU1_TMISS, 0xca0),
-	INTC_VECT(DTU2_TEND, 0xcc0), INTC_VECT(DTU2_AE, 0xce0),
-	INTC_VECT(DTU2_TMISS, 0xd00),
-	INTC_VECT(DTU3_TEND, 0xd20), INTC_VECT(DTU3_AE, 0xd40),
-	INTC_VECT(DTU3_TMISS, 0xd60),
+	INTC_VECT(DTU0, 0xc00), INTC_VECT(DTU0, 0xc20),
+	INTC_VECT(DTU0, 0xc40),
+	INTC_VECT(DTU1, 0xc60), INTC_VECT(DTU1, 0xc80),
+	INTC_VECT(DTU1, 0xca0),
+	INTC_VECT(DTU2, 0xcc0), INTC_VECT(DTU2, 0xce0),
+	INTC_VECT(DTU2, 0xd00),
+	INTC_VECT(DTU3, 0xd20), INTC_VECT(DTU3, 0xd40),
+	INTC_VECT(DTU3, 0xd60),
 	INTC_VECT(FE0, 0xe00), INTC_VECT(FE1, 0xe20),
 	INTC_VECT(GPIO0, 0xe40), INTC_VECT(GPIO1, 0xe60),
 	INTC_VECT(GPIO2, 0xe80), INTC_VECT(GPIO3, 0xea0),
@@ -351,10 +344,6 @@ static struct intc_vect vectors[] __initdata = {
 };
 
 static struct intc_group groups[] __initdata = {
-	INTC_GROUP(IRL, IRL_LLLL, IRL_LLLH, IRL_LLHL, IRL_LLHH,
-		   IRL_LHLL, IRL_LHLH, IRL_LHHL, IRL_LHHH,
-		   IRL_HLLL, IRL_HLLH, IRL_HLHL, IRL_HLHH,
-		   IRL_HHLL, IRL_HHLH, IRL_HHHL),
 	INTC_GROUP(PCII56789, PCII5, PCII6, PCII7, PCII8, PCII9),
 	INTC_GROUP(SCIF0, SCIF0_ERI, SCIF0_RXI, SCIF0_BRI, SCIF0_TXI),
 	INTC_GROUP(SCIF1, SCIF1_ERI, SCIF1_RXI, SCIF1_BRI, SCIF1_TXI),
@@ -364,10 +353,6 @@ static struct intc_group groups[] __initdata = {
 		   DMAC0_DMINT3, DMAC0_DMINT4, DMAC0_DMINT5, DMAC0_DMAE),
 	INTC_GROUP(DMAC1, DMAC1_DMINT6, DMAC1_DMINT7, DMAC1_DMINT8,
 		   DMAC1_DMINT9, DMAC1_DMINT10, DMAC1_DMINT11),
-	INTC_GROUP(DTU0, DTU0_TEND, DTU0_AE, DTU0_TMISS),
-	INTC_GROUP(DTU1, DTU1_TEND, DTU1_AE, DTU1_TMISS),
-	INTC_GROUP(DTU2, DTU2_TEND, DTU2_AE, DTU2_TMISS),
-	INTC_GROUP(DTU3, DTU3_TEND, DTU3_AE, DTU3_TMISS),
 };
 
 static struct intc_mask_reg mask_registers[] __initdata = {
@@ -434,14 +419,14 @@ static DECLARE_INTC_DESC(intc_desc_irq, "shx3-irq", vectors_irq, groups,
 
 /* External interrupt pins in IRL mode */
 static struct intc_vect vectors_irl[] __initdata = {
-	INTC_VECT(IRL_LLLL, 0x200), INTC_VECT(IRL_LLLH, 0x220),
-	INTC_VECT(IRL_LLHL, 0x240), INTC_VECT(IRL_LLHH, 0x260),
-	INTC_VECT(IRL_LHLL, 0x280), INTC_VECT(IRL_LHLH, 0x2a0),
-	INTC_VECT(IRL_LHHL, 0x2c0), INTC_VECT(IRL_LHHH, 0x2e0),
-	INTC_VECT(IRL_HLLL, 0x300), INTC_VECT(IRL_HLLH, 0x320),
-	INTC_VECT(IRL_HLHL, 0x340), INTC_VECT(IRL_HLHH, 0x360),
-	INTC_VECT(IRL_HHLL, 0x380), INTC_VECT(IRL_HHLH, 0x3a0),
-	INTC_VECT(IRL_HHHL, 0x3c0),
+	INTC_VECT(IRL, 0x200), INTC_VECT(IRL, 0x220),
+	INTC_VECT(IRL, 0x240), INTC_VECT(IRL, 0x260),
+	INTC_VECT(IRL, 0x280), INTC_VECT(IRL, 0x2a0),
+	INTC_VECT(IRL, 0x2c0), INTC_VECT(IRL, 0x2e0),
+	INTC_VECT(IRL, 0x300), INTC_VECT(IRL, 0x320),
+	INTC_VECT(IRL, 0x340), INTC_VECT(IRL, 0x360),
+	INTC_VECT(IRL, 0x380), INTC_VECT(IRL, 0x3a0),
+	INTC_VECT(IRL, 0x3c0),
 };
 
 static DECLARE_INTC_DESC(intc_desc_irl, "shx3-irl", vectors_irl, groups,

commit 955c9863bb5855a994751843e7066017edc00410
Author: Magnus Damm <damm@igel.co.jp>
Date:   Wed Jul 22 15:14:29 2009 +0000

    sh: convert processor device setup functions to arch_initcall()
    
    Convert the processor platform device setup
    functions from __initcall() and sometimes
    device_initcall() to arch_initcall().
    
    This makes sure that the platform devices are
    registered a bit earlier so the devices are
    available when drivers register using initcall
    levels earlier than device_initcall().
    
    A good example is platform devices needed by
    i2c-sh_mobile.c which registers a bit earlier
    using subsys_initcall().
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 53c65fd9ccef..07f078961c71 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -256,7 +256,7 @@ static int __init shx3_devices_setup(void)
 	return platform_add_devices(shx3_devices,
 				    ARRAY_SIZE(shx3_devices));
 }
-__initcall(shx3_devices_setup);
+arch_initcall(shx3_devices_setup);
 
 void __init plat_early_device_setup(void)
 {

commit 26c92f3728d738aaa7e4859d5581323cd68096dd
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Jun 24 18:23:52 2009 +0900

    serial: sh-sci: Move SCBRR calculation algo in to platform data.
    
    This permits each port to select its own SCBRR calculation algorithm,
    rather than having it all ifdef'ed in the header. There are presently
    only 5 different variations that all parts fall under.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index eef94934f542..4a26cc304139 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -20,24 +20,28 @@ static struct plat_sci_port sci_platform_data[] = {
 		.mapbase	= 0xffc30000,
 		.flags		= UPF_BOOT_AUTOCONF,
 		.scscr		= SCSCR_RE | SCSCR_TE | SCSCR_REIE,
+		.scbrr_algo_id	= SCBRR_ALGO_2,
 		.type		= PORT_SCIF,
 		.irqs		= { 40, 41, 43, 42 },
 	}, {
 		.mapbase	= 0xffc40000,
 		.flags		= UPF_BOOT_AUTOCONF,
 		.scscr		= SCSCR_RE | SCSCR_TE | SCSCR_REIE,
+		.scbrr_algo_id	= SCBRR_ALGO_2,
 		.type		= PORT_SCIF,
 		.irqs		= { 44, 45, 47, 46 },
 	}, {
 		.mapbase	= 0xffc50000,
 		.flags		= UPF_BOOT_AUTOCONF,
 		.scscr		= SCSCR_RE | SCSCR_TE | SCSCR_REIE,
+		.scbrr_algo_id	= SCBRR_ALGO_2,
 		.type		= PORT_SCIF,
 		.irqs		= { 48, 49, 51, 50 },
 	}, {
 		.mapbase	= 0xffc60000,
 		.flags		= UPF_BOOT_AUTOCONF,
 		.scscr		= SCSCR_RE | SCSCR_TE | SCSCR_REIE,
+		.scbrr_algo_id	= SCBRR_ALGO_2,
 		.type		= PORT_SCIF,
 		.irqs		= { 52, 53, 55, 54 },
 	}, {

commit 00b9de9c249f51f09c19aa41cbbb3e3eb4eea807
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Jun 24 17:53:33 2009 +0900

    serial: sh-sci: Move SCSCR_INIT in to platform data.
    
    This moves all of the SCSCR_INIT definitions in to the platform data,
    for future consolidation.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 53c65fd9ccef..eef94934f542 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -19,21 +19,25 @@ static struct plat_sci_port sci_platform_data[] = {
 	{
 		.mapbase	= 0xffc30000,
 		.flags		= UPF_BOOT_AUTOCONF,
+		.scscr		= SCSCR_RE | SCSCR_TE | SCSCR_REIE,
 		.type		= PORT_SCIF,
 		.irqs		= { 40, 41, 43, 42 },
 	}, {
 		.mapbase	= 0xffc40000,
 		.flags		= UPF_BOOT_AUTOCONF,
+		.scscr		= SCSCR_RE | SCSCR_TE | SCSCR_REIE,
 		.type		= PORT_SCIF,
 		.irqs		= { 44, 45, 47, 46 },
 	}, {
 		.mapbase	= 0xffc50000,
 		.flags		= UPF_BOOT_AUTOCONF,
+		.scscr		= SCSCR_RE | SCSCR_TE | SCSCR_REIE,
 		.type		= PORT_SCIF,
 		.irqs		= { 48, 49, 51, 50 },
 	}, {
 		.mapbase	= 0xffc60000,
 		.flags		= UPF_BOOT_AUTOCONF,
+		.scscr		= SCSCR_RE | SCSCR_TE | SCSCR_REIE,
 		.type		= PORT_SCIF,
 		.irqs		= { 52, 53, 55, 54 },
 	}, {

commit af777ce42d3d51cdef353ce296d6f99dc503feef
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed May 13 16:59:40 2009 +0900

    sh: clkfwk: module_clk -> peripheral_clk rename.
    
    For consistenct naming, and to allow us to fix up some confusion in the
    SH-Mobile clock framework, amongst other places.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 9d5185b42f13..53c65fd9ccef 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -53,7 +53,7 @@ static struct sh_timer_config tmu0_platform_data = {
 	.name = "TMU0",
 	.channel_offset = 0x04,
 	.timer_bit = 0,
-	.clk = "module_clk",
+	.clk = "peripheral_clk",
 	.clockevent_rating = 200,
 };
 
@@ -84,7 +84,7 @@ static struct sh_timer_config tmu1_platform_data = {
 	.name = "TMU1",
 	.channel_offset = 0x10,
 	.timer_bit = 1,
-	.clk = "module_clk",
+	.clk = "peripheral_clk",
 	.clocksource_rating = 200,
 };
 
@@ -115,7 +115,7 @@ static struct sh_timer_config tmu2_platform_data = {
 	.name = "TMU2",
 	.channel_offset = 0x1c,
 	.timer_bit = 2,
-	.clk = "module_clk",
+	.clk = "peripheral_clk",
 };
 
 static struct resource tmu2_resources[] = {
@@ -145,7 +145,7 @@ static struct sh_timer_config tmu3_platform_data = {
 	.name = "TMU3",
 	.channel_offset = 0x04,
 	.timer_bit = 0,
-	.clk = "module_clk",
+	.clk = "peripheral_clk",
 };
 
 static struct resource tmu3_resources[] = {
@@ -175,7 +175,7 @@ static struct sh_timer_config tmu4_platform_data = {
 	.name = "TMU4",
 	.channel_offset = 0x10,
 	.timer_bit = 1,
-	.clk = "module_clk",
+	.clk = "peripheral_clk",
 };
 
 static struct resource tmu4_resources[] = {
@@ -205,7 +205,7 @@ static struct sh_timer_config tmu5_platform_data = {
 	.name = "TMU5",
 	.channel_offset = 0x1c,
 	.timer_bit = 2,
-	.clk = "module_clk",
+	.clk = "peripheral_clk",
 };
 
 static struct resource tmu5_resources[] = {

commit ccdaeb4c8f982900a2abf722e34b60131394d8eb
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri May 8 22:09:30 2009 +0900

    sh: TMU platform data for SH-X3 proto CPU.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index bd35f32534b9..9d5185b42f13 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -1,7 +1,7 @@
 /*
- * SH-X3 Setup
+ * SH-X3 Prototype Setup
  *
- *  Copyright (C) 2007  Paul Mundt
+ *  Copyright (C) 2007 - 2009  Paul Mundt
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -12,6 +12,7 @@
 #include <linux/serial.h>
 #include <linux/serial_sci.h>
 #include <linux/io.h>
+#include <linux/sh_timer.h>
 #include <asm/mmzone.h>
 
 static struct plat_sci_port sci_platform_data[] = {
@@ -48,17 +49,221 @@ static struct platform_device sci_device = {
 	},
 };
 
+static struct sh_timer_config tmu0_platform_data = {
+	.name = "TMU0",
+	.channel_offset = 0x04,
+	.timer_bit = 0,
+	.clk = "module_clk",
+	.clockevent_rating = 200,
+};
+
+static struct resource tmu0_resources[] = {
+	[0] = {
+		.name	= "TMU0",
+		.start	= 0xffc10008,
+		.end	= 0xffc10013,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 16,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device tmu0_device = {
+	.name		= "sh_tmu",
+	.id		= 0,
+	.dev = {
+		.platform_data	= &tmu0_platform_data,
+	},
+	.resource	= tmu0_resources,
+	.num_resources	= ARRAY_SIZE(tmu0_resources),
+};
+
+static struct sh_timer_config tmu1_platform_data = {
+	.name = "TMU1",
+	.channel_offset = 0x10,
+	.timer_bit = 1,
+	.clk = "module_clk",
+	.clocksource_rating = 200,
+};
+
+static struct resource tmu1_resources[] = {
+	[0] = {
+		.name	= "TMU1",
+		.start	= 0xffc10014,
+		.end	= 0xffc1001f,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 17,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device tmu1_device = {
+	.name		= "sh_tmu",
+	.id		= 1,
+	.dev = {
+		.platform_data	= &tmu1_platform_data,
+	},
+	.resource	= tmu1_resources,
+	.num_resources	= ARRAY_SIZE(tmu1_resources),
+};
+
+static struct sh_timer_config tmu2_platform_data = {
+	.name = "TMU2",
+	.channel_offset = 0x1c,
+	.timer_bit = 2,
+	.clk = "module_clk",
+};
+
+static struct resource tmu2_resources[] = {
+	[0] = {
+		.name	= "TMU2",
+		.start	= 0xffc10020,
+		.end	= 0xffc1002f,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 18,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device tmu2_device = {
+	.name		= "sh_tmu",
+	.id		= 2,
+	.dev = {
+		.platform_data	= &tmu2_platform_data,
+	},
+	.resource	= tmu2_resources,
+	.num_resources	= ARRAY_SIZE(tmu2_resources),
+};
+
+static struct sh_timer_config tmu3_platform_data = {
+	.name = "TMU3",
+	.channel_offset = 0x04,
+	.timer_bit = 0,
+	.clk = "module_clk",
+};
+
+static struct resource tmu3_resources[] = {
+	[0] = {
+		.name	= "TMU3",
+		.start	= 0xffc20008,
+		.end	= 0xffc20013,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 19,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device tmu3_device = {
+	.name		= "sh_tmu",
+	.id		= 3,
+	.dev = {
+		.platform_data	= &tmu3_platform_data,
+	},
+	.resource	= tmu3_resources,
+	.num_resources	= ARRAY_SIZE(tmu3_resources),
+};
+
+static struct sh_timer_config tmu4_platform_data = {
+	.name = "TMU4",
+	.channel_offset = 0x10,
+	.timer_bit = 1,
+	.clk = "module_clk",
+};
+
+static struct resource tmu4_resources[] = {
+	[0] = {
+		.name	= "TMU4",
+		.start	= 0xffc20014,
+		.end	= 0xffc2001f,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 20,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device tmu4_device = {
+	.name		= "sh_tmu",
+	.id		= 4,
+	.dev = {
+		.platform_data	= &tmu4_platform_data,
+	},
+	.resource	= tmu4_resources,
+	.num_resources	= ARRAY_SIZE(tmu4_resources),
+};
+
+static struct sh_timer_config tmu5_platform_data = {
+	.name = "TMU5",
+	.channel_offset = 0x1c,
+	.timer_bit = 2,
+	.clk = "module_clk",
+};
+
+static struct resource tmu5_resources[] = {
+	[0] = {
+		.name	= "TMU5",
+		.start	= 0xffc20020,
+		.end	= 0xffc2002b,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 21,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device tmu5_device = {
+	.name		= "sh_tmu",
+	.id		= 5,
+	.dev = {
+		.platform_data	= &tmu5_platform_data,
+	},
+	.resource	= tmu5_resources,
+	.num_resources	= ARRAY_SIZE(tmu5_resources),
+};
+
+static struct platform_device *shx3_early_devices[] __initdata = {
+	&tmu0_device,
+	&tmu1_device,
+	&tmu2_device,
+	&tmu3_device,
+	&tmu4_device,
+	&tmu5_device,
+};
+
 static struct platform_device *shx3_devices[] __initdata = {
 	&sci_device,
 };
 
 static int __init shx3_devices_setup(void)
 {
+	int ret;
+
+	ret = platform_add_devices(shx3_early_devices,
+				   ARRAY_SIZE(shx3_early_devices));
+	if (unlikely(ret != 0))
+		return ret;
+
 	return platform_add_devices(shx3_devices,
 				    ARRAY_SIZE(shx3_devices));
 }
 __initcall(shx3_devices_setup);
 
+void __init plat_early_device_setup(void)
+{
+	early_platform_add_devices(shx3_early_devices,
+				   ARRAY_SIZE(shx3_early_devices));
+}
+
 enum {
 	UNUSED = 0,
 

commit 96de1a8f0275bd67f243833e7088baced518f873
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Feb 26 14:52:45 2008 +0900

    serial: Move asm-sh/sci.h to linux/serial_sci.h.
    
    This header is needed on other architectures as well (namely h8300),
    which currently fails to build without this in place. Rather than
    duplicating the port definition completely there, just move this to a
    common location instead.
    
    This should get h8300 working again for 2.6.25, in addition to the
    changes already pushed by Sato-san in -rc2.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 4dc958b6b314..bd35f32534b9 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -10,9 +10,9 @@
 #include <linux/platform_device.h>
 #include <linux/init.h>
 #include <linux/serial.h>
+#include <linux/serial_sci.h>
 #include <linux/io.h>
 #include <asm/mmzone.h>
-#include <asm/sci.h>
 
 static struct plat_sci_port sci_platform_data[] = {
 	{

commit 7f3edee81fbd49114c28057512906f169caa0bed
Author: Magnus Damm <damm@igel.co.jp>
Date:   Thu Jan 10 14:08:55 2008 +0900

    sh: intc - remove default interrupt priority tables
    
    This patch removes interrupt priority tables from the intc code.
    Optimal priority assignment varies with embedded application anyway,
    so keeping the interrupt priority tables together with cpu-specific
    code doesn't make sense.
    
    The function intc_set_priority() should be used instead to set the
    desired interrupt priority level.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index c6cdd7e3b049..4dc958b6b314 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -165,13 +165,6 @@ static struct intc_group groups[] __initdata = {
 	INTC_GROUP(DTU3, DTU3_TEND, DTU3_AE, DTU3_TMISS),
 };
 
-static struct intc_prio priorities[] __initdata = {
-	INTC_PRIO(SCIF0, 3),
-	INTC_PRIO(SCIF1, 3),
-	INTC_PRIO(SCIF2, 3),
-	INTC_PRIO(SCIF3, 3),
-};
-
 static struct intc_mask_reg mask_registers[] __initdata = {
 	{ 0xfe410030, 0xfe410050, 32, /* CnINTMSK0 / CnINTMSKCLR0 */
 	  { IRQ0, IRQ1, IRQ2, IRQ3 } },
@@ -218,7 +211,7 @@ static struct intc_prio_reg prio_registers[] __initdata = {
 	    INTICI3, INTICI2, INTICI1, INTICI0 }, INTC_SMP(4, 4) },
 };
 
-static DECLARE_INTC_DESC(intc_desc, "shx3", vectors, groups, priorities,
+static DECLARE_INTC_DESC(intc_desc, "shx3", vectors, groups,
 			 mask_registers, prio_registers, NULL);
 
 /* Support for external interrupt pins in IRQ mode */
@@ -232,8 +225,7 @@ static struct intc_sense_reg sense_registers[] __initdata = {
 };
 
 static DECLARE_INTC_DESC(intc_desc_irq, "shx3-irq", vectors_irq, groups,
-			 priorities, mask_registers, prio_registers,
-			 sense_registers);
+			 mask_registers, prio_registers, sense_registers);
 
 /* External interrupt pins in IRL mode */
 static struct intc_vect vectors_irl[] __initdata = {
@@ -248,7 +240,7 @@ static struct intc_vect vectors_irl[] __initdata = {
 };
 
 static DECLARE_INTC_DESC(intc_desc_irl, "shx3-irl", vectors_irl, groups,
-			 priorities, mask_registers, prio_registers, NULL);
+			 mask_registers, prio_registers, NULL);
 
 void __init plat_irq_setup_pins(int mode)
 {

commit ceb9b974513de6bd0ee86c30e84c34dd6e974fb5
Author: Magnus Damm <damm@igel.co.jp>
Date:   Fri Sep 21 18:34:48 2007 +0900

    sh: Hook up the SH-X3 SMP intc register groups.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 4cfd532086fa..c6cdd7e3b049 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -215,7 +215,7 @@ static struct intc_prio_reg prio_registers[] __initdata = {
 						 GPIO2, GPIO1, GPIO0, IRM } },
 	{ 0xfe410090, 0xfe4100a0, 32, 4, /* CnICIPRI / CnICIPRICLR */
 	  { INTICI7, INTICI6, INTICI5, INTICI4,
-	    INTICI3, INTICI2, INTICI1, INTICI0 } },
+	    INTICI3, INTICI2, INTICI1, INTICI0 }, INTC_SMP(4, 4) },
 };
 
 static DECLARE_INTC_DESC(intc_desc, "shx3", vectors, groups, priorities,

commit 5c37e025352b993d8726b0207ff2270b2f2bc7d6
Author: Magnus Damm <damm@igel.co.jp>
Date:   Fri Aug 17 00:45:35 2007 +0900

    sh: intc - mark data structures as __initdata
    
    With the intc core improved it is now possible to put the intc data
    structures in the initdata section.
    
    Version two of this patch puts the __initdata inside DECLARE_INTC_DESC()
    and removes the __initdata included in the board specific r2d code.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 3c8a2edff2c9..4cfd532086fa 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -97,7 +97,7 @@ enum {
 	DMAC0, DMAC1, DTU0, DTU1, DTU2, DTU3,
 };
 
-static struct intc_vect vectors[] = {
+static struct intc_vect vectors[] __initdata = {
 	INTC_VECT(HUDII, 0x3e0),
 	INTC_VECT(TMU0, 0x400), INTC_VECT(TMU1, 0x420),
 	INTC_VECT(TMU2, 0x440), INTC_VECT(TMU3, 0x460),
@@ -145,7 +145,7 @@ static struct intc_vect vectors[] = {
 	INTC_VECT(INTICI6, 0xfc0), INTC_VECT(INTICI7, 0xfe0),
 };
 
-static struct intc_group groups[] = {
+static struct intc_group groups[] __initdata = {
 	INTC_GROUP(IRL, IRL_LLLL, IRL_LLLH, IRL_LLHL, IRL_LLHH,
 		   IRL_LHLL, IRL_LHLH, IRL_LHHL, IRL_LHHH,
 		   IRL_HLLL, IRL_HLLH, IRL_HLHL, IRL_HLHH,
@@ -165,14 +165,14 @@ static struct intc_group groups[] = {
 	INTC_GROUP(DTU3, DTU3_TEND, DTU3_AE, DTU3_TMISS),
 };
 
-static struct intc_prio priorities[] = {
+static struct intc_prio priorities[] __initdata = {
 	INTC_PRIO(SCIF0, 3),
 	INTC_PRIO(SCIF1, 3),
 	INTC_PRIO(SCIF2, 3),
 	INTC_PRIO(SCIF3, 3),
 };
 
-static struct intc_mask_reg mask_registers[] = {
+static struct intc_mask_reg mask_registers[] __initdata = {
 	{ 0xfe410030, 0xfe410050, 32, /* CnINTMSK0 / CnINTMSKCLR0 */
 	  { IRQ0, IRQ1, IRQ2, IRQ3 } },
 	{ 0xfe410040, 0xfe410060, 32, /* CnINTMSK1 / CnINTMSKCLR1 */
@@ -197,7 +197,7 @@ static struct intc_mask_reg mask_registers[] = {
 	    SCIF0_TXI, SCIF0_BRI, SCIF0_RXI, SCIF0_ERI } },
 };
 
-static struct intc_prio_reg prio_registers[] = {
+static struct intc_prio_reg prio_registers[] __initdata = {
 	{ 0xfe410010, 0, 32, 4, /* INTPRI */ { IRQ0, IRQ1, IRQ2, IRQ3 } },
 
 	{ 0xfe410800, 0, 32, 4, /* INT2PRI0 */ { 0, HUDII, TMU5, TMU4,
@@ -222,12 +222,12 @@ static DECLARE_INTC_DESC(intc_desc, "shx3", vectors, groups, priorities,
 			 mask_registers, prio_registers, NULL);
 
 /* Support for external interrupt pins in IRQ mode */
-static struct intc_vect vectors_irq[] = {
+static struct intc_vect vectors_irq[] __initdata = {
 	INTC_VECT(IRQ0, 0x240), INTC_VECT(IRQ1, 0x280),
 	INTC_VECT(IRQ2, 0x2c0), INTC_VECT(IRQ3, 0x300),
 };
 
-static struct intc_sense_reg sense_registers[] = {
+static struct intc_sense_reg sense_registers[] __initdata = {
 	{ 0xfe41001c, 32, 2, /* ICR1 */   { IRQ0, IRQ1, IRQ2, IRQ3 } },
 };
 
@@ -236,7 +236,7 @@ static DECLARE_INTC_DESC(intc_desc_irq, "shx3-irq", vectors_irq, groups,
 			 sense_registers);
 
 /* External interrupt pins in IRL mode */
-static struct intc_vect vectors_irl[] = {
+static struct intc_vect vectors_irl[] __initdata = {
 	INTC_VECT(IRL_LLLL, 0x200), INTC_VECT(IRL_LLLH, 0x220),
 	INTC_VECT(IRL_LLHL, 0x240), INTC_VECT(IRL_LLHH, 0x260),
 	INTC_VECT(IRL_LHLL, 0x280), INTC_VECT(IRL_LHLH, 0x2a0),

commit 46420e49c9fd76defecfb3f048ab20c5a72dfd0a
Author: Magnus Damm <damm@igel.co.jp>
Date:   Sun Aug 12 15:31:29 2007 +0900

    sh: x3 - add ipi vectors
    
    With the intc dual prio register support in place it is now possible
    to add the ipi vectors to x3.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 2c13f9ceac74..3c8a2edff2c9 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -89,6 +89,8 @@ enum {
 	FE0, FE1,
 	GPIO0, GPIO1, GPIO2, GPIO3,
 	PAM, IRM,
+	INTICI0, INTICI1, INTICI2, INTICI3,
+	INTICI4, INTICI5, INTICI6, INTICI7,
 
 	/* interrupt groups */
 	IRL, PCII56789, SCIF0, SCIF1, SCIF2, SCIF3,
@@ -137,6 +139,10 @@ static struct intc_vect vectors[] = {
 	INTC_VECT(GPIO0, 0xe40), INTC_VECT(GPIO1, 0xe60),
 	INTC_VECT(GPIO2, 0xe80), INTC_VECT(GPIO3, 0xea0),
 	INTC_VECT(PAM, 0xec0), INTC_VECT(IRM, 0xee0),
+	INTC_VECT(INTICI0, 0xf00), INTC_VECT(INTICI1, 0xf20),
+	INTC_VECT(INTICI2, 0xf40), INTC_VECT(INTICI3, 0xf60),
+	INTC_VECT(INTICI4, 0xf80), INTC_VECT(INTICI5, 0xfa0),
+	INTC_VECT(INTICI6, 0xfc0), INTC_VECT(INTICI7, 0xfe0),
 };
 
 static struct intc_group groups[] = {
@@ -207,6 +213,9 @@ static struct intc_prio_reg prio_registers[] = {
 						 VIN1, VIN0, IIC, DU} },
 	{ 0xfe410810, 0, 32, 4, /* INT2PRI4 */ { 0, 0, PAM, GPIO3,
 						 GPIO2, GPIO1, GPIO0, IRM } },
+	{ 0xfe410090, 0xfe4100a0, 32, 4, /* CnICIPRI / CnICIPRICLR */
+	  { INTICI7, INTICI6, INTICI5, INTICI4,
+	    INTICI3, INTICI2, INTICI1, INTICI0 } },
 };
 
 static DECLARE_INTC_DESC(intc_desc, "shx3", vectors, groups, priorities,

commit 6ef5fb2cfcedaab4a43493c8f2305a67c0ce1af6
Author: Magnus Damm <damm@igel.co.jp>
Date:   Sun Aug 12 15:22:02 2007 +0900

    sh: intc - add a clear register to struct intc_prio_reg
    
    We need a secondary register member in struct intc_prio_reg to support
    dual priority registers used by ipi on x3.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 610343ea9a84..2c13f9ceac74 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -192,18 +192,21 @@ static struct intc_mask_reg mask_registers[] = {
 };
 
 static struct intc_prio_reg prio_registers[] = {
-	{ 0xfe410010, 32, 4, /* INTPRI */ { IRQ0, IRQ1, IRQ2, IRQ3 } },
+	{ 0xfe410010, 0, 32, 4, /* INTPRI */ { IRQ0, IRQ1, IRQ2, IRQ3 } },
 
-	{ 0xfe410800, 32, 4, /* INT2PRI0 */ { 0, HUDII, TMU5, TMU4,
-					      TMU3, TMU2, TMU1, TMU0 } },
-	{ 0xfe410804, 32, 4, /* INT2PRI1 */ { DTU3, DTU2, DTU1, DTU0,
-					      SCIF3, SCIF2, SCIF1, SCIF0 } },
-	{ 0xfe410808, 32, 4, /* INT2PRI2 */ { DMAC1, DMAC0, PCII56789, PCII4,
-					      PCII3, PCII2, PCII1, PCII0 } },
-	{ 0xfe41080c, 32, 4, /* INT2PRI3 */ { FE1, FE0, ATAPI, VCORE0,
-					      VIN1, VIN0, IIC, DU} },
-	{ 0xfe410810, 32, 4, /* INT2PRI4 */ { 0, 0, PAM, GPIO3,
-					      GPIO2, GPIO1, GPIO0, IRM } },
+	{ 0xfe410800, 0, 32, 4, /* INT2PRI0 */ { 0, HUDII, TMU5, TMU4,
+						 TMU3, TMU2, TMU1, TMU0 } },
+	{ 0xfe410804, 0, 32, 4, /* INT2PRI1 */ { DTU3, DTU2, DTU1, DTU0,
+						 SCIF3, SCIF2,
+						 SCIF1, SCIF0 } },
+	{ 0xfe410808, 0, 32, 4, /* INT2PRI2 */ { DMAC1, DMAC0,
+						 PCII56789, PCII4,
+						 PCII3, PCII2,
+						 PCII1, PCII0 } },
+	{ 0xfe41080c, 0, 32, 4, /* INT2PRI3 */ { FE1, FE0, ATAPI, VCORE0,
+						 VIN1, VIN0, IIC, DU} },
+	{ 0xfe410810, 0, 32, 4, /* INT2PRI4 */ { 0, 0, PAM, GPIO3,
+						 GPIO2, GPIO1, GPIO0, IRM } },
 };
 
 static DECLARE_INTC_DESC(intc_desc, "shx3", vectors, groups, priorities,

commit d6aee69ca11550f3ca325ceaa020ea74e173478f
Author: Magnus Damm <damm@igel.co.jp>
Date:   Sun Aug 12 15:18:33 2007 +0900

    sh: x3 - fix setup_bootmem_node() compile error with shx3_defconfig
    
    This makes sure the function prototype for setup_bootmem_node() gets
    included. The file setup-shx3.c does not compile otherwise for
    CONFIG_NUMA=n.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 98f153554deb..610343ea9a84 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -11,6 +11,7 @@
 #include <linux/init.h>
 #include <linux/serial.h>
 #include <linux/io.h>
+#include <asm/mmzone.h>
 #include <asm/sci.h>
 
 static struct plat_sci_port sci_platform_data[] = {

commit d3428e91017f2ecf5655b3ffdf6ed65f5430ade1
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Aug 8 17:06:54 2007 +0900

    sh: Wire up CSM node for SH-X3.
    
    Now that NODES_SHIFT is bumped up, we can plug in the CSM block as
    a separate node, too.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index f7a2cc221d22..98f153554deb 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -258,14 +258,17 @@ void __init plat_irq_setup(void)
 
 void __init plat_mem_setup(void)
 {
+	unsigned int nid = 1;
+
 	/* Register CPU#0 URAM space as Node 1 */
-	setup_bootmem_node(1, 0x145f0000, 0x14610000);	/* CPU0 */
+	setup_bootmem_node(nid++, 0x145f0000, 0x14610000);	/* CPU0 */
 
 #if 0
 	/* XXX: Not yet.. */
-	setup_bootmem_node(2, 0x14df0000, 0x14e10000);	/* CPU1 */
-	setup_bootmem_node(3, 0x155f0000, 0x15610000);	/* CPU2 */
-	setup_bootmem_node(4, 0x15df0000, 0x15e10000);	/* CPU3 */
-	setup_bootmem_node(5, 0x16000000, 0x16020000);	/* CSM */
+	setup_bootmem_node(nid++, 0x14df0000, 0x14e10000);	/* CPU1 */
+	setup_bootmem_node(nid++, 0x155f0000, 0x15610000);	/* CPU2 */
+	setup_bootmem_node(nid++, 0x15df0000, 0x15e10000);	/* CPU3 */
 #endif
+
+	setup_bootmem_node(nid++, 0x16000000, 0x16020000);	/* CSM */
 }

commit 7da3b8ef662af6252aa17c55cc0aa6d74cbf02e4
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Aug 1 17:52:47 2007 +0900

    sh: Initial multiple-node support for SH-X3.
    
    Wire up CPU#0 URAM as node 1 on SH-X3.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 7f3fa5167c6b..f7a2cc221d22 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -255,3 +255,17 @@ void __init plat_irq_setup(void)
 {
 	register_intc_controller(&intc_desc);
 }
+
+void __init plat_mem_setup(void)
+{
+	/* Register CPU#0 URAM space as Node 1 */
+	setup_bootmem_node(1, 0x145f0000, 0x14610000);	/* CPU0 */
+
+#if 0
+	/* XXX: Not yet.. */
+	setup_bootmem_node(2, 0x14df0000, 0x14e10000);	/* CPU1 */
+	setup_bootmem_node(3, 0x155f0000, 0x15610000);	/* CPU2 */
+	setup_bootmem_node(4, 0x15df0000, 0x15e10000);	/* CPU3 */
+	setup_bootmem_node(5, 0x16000000, 0x16020000);	/* CSM */
+#endif
+}

commit 1ee010087e2d26f0d8182bb189d5606e3586253c
Author: Magnus Damm <damm@igel.co.jp>
Date:   Wed Aug 1 17:02:22 2007 +0900

    sh: intc - add support for x3
    
    This patch converts the cpu specific interrupt setup code for x3 from
    intc2 to intc. New vectors are also added to match the preliminary
    information.
    
    Use plat_irq_setup_pins() to select between IRQ and IRL mode for IRQ0-3.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 704c064f70dc..7f3fa5167c6b 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -58,28 +58,200 @@ static int __init shx3_devices_setup(void)
 }
 __initcall(shx3_devices_setup);
 
-static struct intc2_data intc2_irq_table[] = {
-	{ 16, 0, 0, 0, 1, 2 },		/* TMU0 */
-	{ 40, 4, 0, 0x20, 0, 3 },	/* SCIF0 ERI */
-	{ 41, 4, 0, 0x20, 1, 3 },	/* SCIF0 RXI */
-	{ 42, 4, 0, 0x20, 2, 3 },	/* SCIF0 BRI */
-	{ 43, 4, 0, 0x20, 3, 3 },	/* SCIF0 TXI */
+enum {
+	UNUSED = 0,
+
+	/* interrupt sources */
+	IRL_LLLL, IRL_LLLH, IRL_LLHL, IRL_LLHH,
+	IRL_LHLL, IRL_LHLH, IRL_LHHL, IRL_LHHH,
+	IRL_HLLL, IRL_HLLH, IRL_HLHL, IRL_HLHH,
+	IRL_HHLL, IRL_HHLH, IRL_HHHL,
+	IRQ0, IRQ1, IRQ2, IRQ3,
+	HUDII,
+	TMU0, TMU1, TMU2, TMU3, TMU4, TMU5,
+	PCII0, PCII1, PCII2, PCII3, PCII4,
+	PCII5, PCII6, PCII7, PCII8, PCII9,
+	SCIF0_ERI, SCIF0_RXI, SCIF0_BRI, SCIF0_TXI,
+	SCIF1_ERI, SCIF1_RXI, SCIF1_BRI, SCIF1_TXI,
+	SCIF2_ERI, SCIF2_RXI, SCIF2_BRI, SCIF2_TXI,
+	SCIF3_ERI, SCIF3_RXI, SCIF3_BRI, SCIF3_TXI,
+	DMAC0_DMINT0, DMAC0_DMINT1, DMAC0_DMINT2, DMAC0_DMINT3,
+	DMAC0_DMINT4, DMAC0_DMINT5, DMAC0_DMAE,
+	DU,
+	DMAC1_DMINT6, DMAC1_DMINT7, DMAC1_DMINT8, DMAC1_DMINT9,
+	DMAC1_DMINT10, DMAC1_DMINT11, DMAC1_DMAE,
+	IIC, VIN0, VIN1, VCORE0, ATAPI,
+	DTU0_TEND, DTU0_AE, DTU0_TMISS,
+	DTU1_TEND, DTU1_AE, DTU1_TMISS,
+	DTU2_TEND, DTU2_AE, DTU2_TMISS,
+	DTU3_TEND, DTU3_AE, DTU3_TMISS,
+	FE0, FE1,
+	GPIO0, GPIO1, GPIO2, GPIO3,
+	PAM, IRM,
+
+	/* interrupt groups */
+	IRL, PCII56789, SCIF0, SCIF1, SCIF2, SCIF3,
+	DMAC0, DMAC1, DTU0, DTU1, DTU2, DTU3,
 };
 
-static struct intc2_desc intc2_irq_desc __read_mostly = {
-	.prio_base	= 0xfe410000,
-	.msk_base	= 0xfe410820,
-	.mskclr_base	= 0xfe410850,
+static struct intc_vect vectors[] = {
+	INTC_VECT(HUDII, 0x3e0),
+	INTC_VECT(TMU0, 0x400), INTC_VECT(TMU1, 0x420),
+	INTC_VECT(TMU2, 0x440), INTC_VECT(TMU3, 0x460),
+	INTC_VECT(TMU4, 0x480), INTC_VECT(TMU5, 0x4a0),
+	INTC_VECT(PCII0, 0x500), INTC_VECT(PCII1, 0x520),
+	INTC_VECT(PCII2, 0x540), INTC_VECT(PCII3, 0x560),
+	INTC_VECT(PCII4, 0x580), INTC_VECT(PCII5, 0x5a0),
+	INTC_VECT(PCII6, 0x5c0), INTC_VECT(PCII7, 0x5e0),
+	INTC_VECT(PCII8, 0x600), INTC_VECT(PCII9, 0x620),
+	INTC_VECT(SCIF0_ERI, 0x700), INTC_VECT(SCIF0_RXI, 0x720),
+	INTC_VECT(SCIF0_BRI, 0x740), INTC_VECT(SCIF0_TXI, 0x760),
+	INTC_VECT(SCIF1_ERI, 0x780), INTC_VECT(SCIF1_RXI, 0x7a0),
+	INTC_VECT(SCIF1_BRI, 0x7c0), INTC_VECT(SCIF1_TXI, 0x7e0),
+	INTC_VECT(SCIF2_ERI, 0x800), INTC_VECT(SCIF2_RXI, 0x820),
+	INTC_VECT(SCIF2_BRI, 0x840), INTC_VECT(SCIF2_TXI, 0x860),
+	INTC_VECT(SCIF3_ERI, 0x880), INTC_VECT(SCIF3_RXI, 0x8a0),
+	INTC_VECT(SCIF3_BRI, 0x8c0), INTC_VECT(SCIF3_TXI, 0x8e0),
+	INTC_VECT(DMAC0_DMINT0, 0x900), INTC_VECT(DMAC0_DMINT1, 0x920),
+	INTC_VECT(DMAC0_DMINT2, 0x940), INTC_VECT(DMAC0_DMINT3, 0x960),
+	INTC_VECT(DMAC0_DMINT4, 0x980), INTC_VECT(DMAC0_DMINT5, 0x9a0),
+	INTC_VECT(DMAC0_DMAE, 0x9c0),
+	INTC_VECT(DU, 0x9e0),
+	INTC_VECT(DMAC1_DMINT6, 0xa00), INTC_VECT(DMAC1_DMINT7, 0xa20),
+	INTC_VECT(DMAC1_DMINT8, 0xa40), INTC_VECT(DMAC1_DMINT9, 0xa60),
+	INTC_VECT(DMAC1_DMINT10, 0xa80), INTC_VECT(DMAC1_DMINT11, 0xaa0),
+	INTC_VECT(DMAC1_DMAE, 0xac0),
+	INTC_VECT(IIC, 0xae0),
+	INTC_VECT(VIN0, 0xb00), INTC_VECT(VIN1, 0xb20),
+	INTC_VECT(VCORE0, 0xb00), INTC_VECT(ATAPI, 0xb60),
+	INTC_VECT(DTU0_TEND, 0xc00), INTC_VECT(DTU0_AE, 0xc20),
+	INTC_VECT(DTU0_TMISS, 0xc40),
+	INTC_VECT(DTU1_TEND, 0xc60), INTC_VECT(DTU1_AE, 0xc80),
+	INTC_VECT(DTU1_TMISS, 0xca0),
+	INTC_VECT(DTU2_TEND, 0xcc0), INTC_VECT(DTU2_AE, 0xce0),
+	INTC_VECT(DTU2_TMISS, 0xd00),
+	INTC_VECT(DTU3_TEND, 0xd20), INTC_VECT(DTU3_AE, 0xd40),
+	INTC_VECT(DTU3_TMISS, 0xd60),
+	INTC_VECT(FE0, 0xe00), INTC_VECT(FE1, 0xe20),
+	INTC_VECT(GPIO0, 0xe40), INTC_VECT(GPIO1, 0xe60),
+	INTC_VECT(GPIO2, 0xe80), INTC_VECT(GPIO3, 0xea0),
+	INTC_VECT(PAM, 0xec0), INTC_VECT(IRM, 0xee0),
+};
 
-	.intc2_data	= intc2_irq_table,
-	.nr_irqs	= ARRAY_SIZE(intc2_irq_table),
+static struct intc_group groups[] = {
+	INTC_GROUP(IRL, IRL_LLLL, IRL_LLLH, IRL_LLHL, IRL_LLHH,
+		   IRL_LHLL, IRL_LHLH, IRL_LHHL, IRL_LHHH,
+		   IRL_HLLL, IRL_HLLH, IRL_HLHL, IRL_HLHH,
+		   IRL_HHLL, IRL_HHLH, IRL_HHHL),
+	INTC_GROUP(PCII56789, PCII5, PCII6, PCII7, PCII8, PCII9),
+	INTC_GROUP(SCIF0, SCIF0_ERI, SCIF0_RXI, SCIF0_BRI, SCIF0_TXI),
+	INTC_GROUP(SCIF1, SCIF1_ERI, SCIF1_RXI, SCIF1_BRI, SCIF1_TXI),
+	INTC_GROUP(SCIF2, SCIF2_ERI, SCIF2_RXI, SCIF2_BRI, SCIF2_TXI),
+	INTC_GROUP(SCIF3, SCIF3_ERI, SCIF3_RXI, SCIF3_BRI, SCIF3_TXI),
+	INTC_GROUP(DMAC0, DMAC0_DMINT0, DMAC0_DMINT1, DMAC0_DMINT2,
+		   DMAC0_DMINT3, DMAC0_DMINT4, DMAC0_DMINT5, DMAC0_DMAE),
+	INTC_GROUP(DMAC1, DMAC1_DMINT6, DMAC1_DMINT7, DMAC1_DMINT8,
+		   DMAC1_DMINT9, DMAC1_DMINT10, DMAC1_DMINT11),
+	INTC_GROUP(DTU0, DTU0_TEND, DTU0_AE, DTU0_TMISS),
+	INTC_GROUP(DTU1, DTU1_TEND, DTU1_AE, DTU1_TMISS),
+	INTC_GROUP(DTU2, DTU2_TEND, DTU2_AE, DTU2_TMISS),
+	INTC_GROUP(DTU3, DTU3_TEND, DTU3_AE, DTU3_TMISS),
+};
 
-	.chip = {
-		.name	= "INTC2-SHX3",
-	},
+static struct intc_prio priorities[] = {
+	INTC_PRIO(SCIF0, 3),
+	INTC_PRIO(SCIF1, 3),
+	INTC_PRIO(SCIF2, 3),
+	INTC_PRIO(SCIF3, 3),
+};
+
+static struct intc_mask_reg mask_registers[] = {
+	{ 0xfe410030, 0xfe410050, 32, /* CnINTMSK0 / CnINTMSKCLR0 */
+	  { IRQ0, IRQ1, IRQ2, IRQ3 } },
+	{ 0xfe410040, 0xfe410060, 32, /* CnINTMSK1 / CnINTMSKCLR1 */
+	  { IRL } },
+	{ 0xfe410820, 0xfe410850, 32, /* CnINT2MSK0 / CnINT2MSKCLR0 */
+	  { FE1, FE0, 0, ATAPI, VCORE0, VIN1, VIN0, IIC,
+	    DU, GPIO3, GPIO2, GPIO1, GPIO0, PAM, 0, 0,
+	    0, 0, 0, 0, 0, 0, 0, 0, /* HUDI bits ignored */
+	    0, TMU5, TMU4, TMU3, TMU2, TMU1, TMU0, 0, } },
+	{ 0xfe410830, 0xfe410860, 32, /* CnINT2MSK1 / CnINT2MSKCLR1 */
+	  { 0, 0, 0, 0, DTU3, DTU2, DTU1, DTU0, /* IRM bits ignored */
+	    PCII9, PCII8, PCII7, PCII6, PCII5, PCII4, PCII3, PCII2,
+	    PCII1, PCII0, DMAC1_DMAE, DMAC1_DMINT11,
+	    DMAC1_DMINT10, DMAC1_DMINT9, DMAC1_DMINT8, DMAC1_DMINT7,
+	    DMAC1_DMINT6, DMAC0_DMAE, DMAC0_DMINT5, DMAC0_DMINT4,
+	    DMAC0_DMINT3, DMAC0_DMINT2, DMAC0_DMINT1, DMAC0_DMINT0 } },
+	{ 0xfe410840, 0xfe410870, 32, /* CnINT2MSK2 / CnINT2MSKCLR2 */
+	  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	    SCIF3_TXI, SCIF3_BRI, SCIF3_RXI, SCIF3_ERI,
+	    SCIF2_TXI, SCIF2_BRI, SCIF2_RXI, SCIF2_ERI,
+	    SCIF1_TXI, SCIF1_BRI, SCIF1_RXI, SCIF1_ERI,
+	    SCIF0_TXI, SCIF0_BRI, SCIF0_RXI, SCIF0_ERI } },
+};
+
+static struct intc_prio_reg prio_registers[] = {
+	{ 0xfe410010, 32, 4, /* INTPRI */ { IRQ0, IRQ1, IRQ2, IRQ3 } },
+
+	{ 0xfe410800, 32, 4, /* INT2PRI0 */ { 0, HUDII, TMU5, TMU4,
+					      TMU3, TMU2, TMU1, TMU0 } },
+	{ 0xfe410804, 32, 4, /* INT2PRI1 */ { DTU3, DTU2, DTU1, DTU0,
+					      SCIF3, SCIF2, SCIF1, SCIF0 } },
+	{ 0xfe410808, 32, 4, /* INT2PRI2 */ { DMAC1, DMAC0, PCII56789, PCII4,
+					      PCII3, PCII2, PCII1, PCII0 } },
+	{ 0xfe41080c, 32, 4, /* INT2PRI3 */ { FE1, FE0, ATAPI, VCORE0,
+					      VIN1, VIN0, IIC, DU} },
+	{ 0xfe410810, 32, 4, /* INT2PRI4 */ { 0, 0, PAM, GPIO3,
+					      GPIO2, GPIO1, GPIO0, IRM } },
 };
 
+static DECLARE_INTC_DESC(intc_desc, "shx3", vectors, groups, priorities,
+			 mask_registers, prio_registers, NULL);
+
+/* Support for external interrupt pins in IRQ mode */
+static struct intc_vect vectors_irq[] = {
+	INTC_VECT(IRQ0, 0x240), INTC_VECT(IRQ1, 0x280),
+	INTC_VECT(IRQ2, 0x2c0), INTC_VECT(IRQ3, 0x300),
+};
+
+static struct intc_sense_reg sense_registers[] = {
+	{ 0xfe41001c, 32, 2, /* ICR1 */   { IRQ0, IRQ1, IRQ2, IRQ3 } },
+};
+
+static DECLARE_INTC_DESC(intc_desc_irq, "shx3-irq", vectors_irq, groups,
+			 priorities, mask_registers, prio_registers,
+			 sense_registers);
+
+/* External interrupt pins in IRL mode */
+static struct intc_vect vectors_irl[] = {
+	INTC_VECT(IRL_LLLL, 0x200), INTC_VECT(IRL_LLLH, 0x220),
+	INTC_VECT(IRL_LLHL, 0x240), INTC_VECT(IRL_LLHH, 0x260),
+	INTC_VECT(IRL_LHLL, 0x280), INTC_VECT(IRL_LHLH, 0x2a0),
+	INTC_VECT(IRL_LHHL, 0x2c0), INTC_VECT(IRL_LHHH, 0x2e0),
+	INTC_VECT(IRL_HLLL, 0x300), INTC_VECT(IRL_HLLH, 0x320),
+	INTC_VECT(IRL_HLHL, 0x340), INTC_VECT(IRL_HLHH, 0x360),
+	INTC_VECT(IRL_HHLL, 0x380), INTC_VECT(IRL_HHLH, 0x3a0),
+	INTC_VECT(IRL_HHHL, 0x3c0),
+};
+
+static DECLARE_INTC_DESC(intc_desc_irl, "shx3-irl", vectors_irl, groups,
+			 priorities, mask_registers, prio_registers, NULL);
+
+void __init plat_irq_setup_pins(int mode)
+{
+	switch (mode) {
+	case IRQ_MODE_IRQ:
+		register_intc_controller(&intc_desc_irq);
+		break;
+	case IRQ_MODE_IRL3210:
+		register_intc_controller(&intc_desc_irl);
+		break;
+	default:
+		BUG();
+	}
+}
+
 void __init plat_irq_setup(void)
 {
-	register_intc2_controller(&intc2_irq_desc);
+	register_intc_controller(&intc_desc);
 }

commit 90015c89386ffb8967422fbe9f5e7babf1dc2c5e
Author: Magnus Damm <damm@igel.co.jp>
Date:   Wed Jul 18 17:57:34 2007 +0900

    sh: IPR/INTC2 IRQ setup consolidation.
    
    This patch unifies the cpu specific interrupt setup functions for
    interrupt controller blocks such as ipr, intc2 and intc. There is no
    point in having separate functions for each interrupt controller, so
    let's clean this up.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
index 70683ea12b83..704c064f70dc 100644
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -79,7 +79,7 @@ static struct intc2_desc intc2_irq_desc __read_mostly = {
 	},
 };
 
-void __init init_IRQ_intc2(void)
+void __init plat_irq_setup(void)
 {
 	register_intc2_controller(&intc2_irq_desc);
 }

commit 2b1bd1ac5d4bffe3fd542bfe1784a583bd7df4fa
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Jun 20 18:27:10 2007 +0900

    sh: Preliminary support for the SH-X3 CPU.
    
    This adds basic support for UP SH-X3.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
new file mode 100644
index 000000000000..70683ea12b83
--- /dev/null
+++ b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
@@ -0,0 +1,85 @@
+/*
+ * SH-X3 Setup
+ *
+ *  Copyright (C) 2007  Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/serial.h>
+#include <linux/io.h>
+#include <asm/sci.h>
+
+static struct plat_sci_port sci_platform_data[] = {
+	{
+		.mapbase	= 0xffc30000,
+		.flags		= UPF_BOOT_AUTOCONF,
+		.type		= PORT_SCIF,
+		.irqs		= { 40, 41, 43, 42 },
+	}, {
+		.mapbase	= 0xffc40000,
+		.flags		= UPF_BOOT_AUTOCONF,
+		.type		= PORT_SCIF,
+		.irqs		= { 44, 45, 47, 46 },
+	}, {
+		.mapbase	= 0xffc50000,
+		.flags		= UPF_BOOT_AUTOCONF,
+		.type		= PORT_SCIF,
+		.irqs		= { 48, 49, 51, 50 },
+	}, {
+		.mapbase	= 0xffc60000,
+		.flags		= UPF_BOOT_AUTOCONF,
+		.type		= PORT_SCIF,
+		.irqs		= { 52, 53, 55, 54 },
+	}, {
+		.flags = 0,
+	}
+};
+
+static struct platform_device sci_device = {
+	.name		= "sh-sci",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= sci_platform_data,
+	},
+};
+
+static struct platform_device *shx3_devices[] __initdata = {
+	&sci_device,
+};
+
+static int __init shx3_devices_setup(void)
+{
+	return platform_add_devices(shx3_devices,
+				    ARRAY_SIZE(shx3_devices));
+}
+__initcall(shx3_devices_setup);
+
+static struct intc2_data intc2_irq_table[] = {
+	{ 16, 0, 0, 0, 1, 2 },		/* TMU0 */
+	{ 40, 4, 0, 0x20, 0, 3 },	/* SCIF0 ERI */
+	{ 41, 4, 0, 0x20, 1, 3 },	/* SCIF0 RXI */
+	{ 42, 4, 0, 0x20, 2, 3 },	/* SCIF0 BRI */
+	{ 43, 4, 0, 0x20, 3, 3 },	/* SCIF0 TXI */
+};
+
+static struct intc2_desc intc2_irq_desc __read_mostly = {
+	.prio_base	= 0xfe410000,
+	.msk_base	= 0xfe410820,
+	.mskclr_base	= 0xfe410850,
+
+	.intc2_data	= intc2_irq_table,
+	.nr_irqs	= ARRAY_SIZE(intc2_irq_table),
+
+	.chip = {
+		.name	= "INTC2-SHX3",
+	},
+};
+
+void __init init_IRQ_intc2(void)
+{
+	register_intc2_controller(&intc2_irq_desc);
+}
