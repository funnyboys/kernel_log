commit 6ecc0a4dbb076ef658cb5e140a7560d6326c8240
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 28 00:32:07 2018 -0800

    sh: sh4: convert to SPDX identifiers
    
    Update license to use SPDX-License-Identifier instead of verbose license
    text, excepting ${LINUX}/arch/sh/kernel/cpu/sh4/softfloat.c which is not
    GPL license
    
    Link: http://lkml.kernel.org/r/87a7lkcsya.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
index 4b5bab5f875f..c1cdef763cb2 100644
--- a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
+++ b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
@@ -1,13 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * arch/sh/kernel/cpu/sh4/clock-sh4-202.c
  *
  * Additional SH4-202 support for the clock framework
  *
  *  Copyright (C) 2005  Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 #include <linux/init.h>
 #include <linux/kernel.h>

commit 3b8744156dad0f86f55ea5bebf68670156a0f915
Author: Magnus Damm <damm@opensource.se>
Date:   Wed Feb 29 22:17:47 2012 +0900

    sh: sh4 sh_clk_ops rename
    
    Convert sh4 SoCs to use sh_clk_ops.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
index f4e262adb39e..4b5bab5f875f 100644
--- a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
+++ b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
@@ -41,7 +41,7 @@ static inline int frqcr3_lookup(struct clk *clk, unsigned long rate)
 	return 5;
 }
 
-static struct clk_ops sh4202_emi_clk_ops = {
+static struct sh_clk_ops sh4202_emi_clk_ops = {
 	.recalc		= emi_clk_recalc,
 };
 
@@ -56,7 +56,7 @@ static unsigned long femi_clk_recalc(struct clk *clk)
 	return clk->parent->rate / frqcr3_divisors[idx];
 }
 
-static struct clk_ops sh4202_femi_clk_ops = {
+static struct sh_clk_ops sh4202_femi_clk_ops = {
 	.recalc		= femi_clk_recalc,
 };
 
@@ -130,7 +130,7 @@ static int shoc_clk_set_rate(struct clk *clk, unsigned long rate)
 	return 0;
 }
 
-static struct clk_ops sh4202_shoc_clk_ops = {
+static struct sh_clk_ops sh4202_shoc_clk_ops = {
 	.init		= shoc_clk_init,
 	.recalc		= shoc_clk_recalc,
 	.set_rate	= shoc_clk_set_rate,

commit 1522043bf73ef0e9e61dc512a0f3cdbec1cbf89f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Wed Jul 6 02:54:11 2011 +0000

    sh: move CLKDEV_xxx_ID macro to sh_clk.h
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
index 3f6f8e98635c..f4e262adb39e 100644
--- a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
+++ b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
@@ -147,8 +147,6 @@ static struct clk *sh4202_onchip_clocks[] = {
 	&sh4202_shoc_clk,
 };
 
-#define CLKDEV_CON_ID(_id, _clk) { .con_id = _id, .clk = _clk }
-
 static struct clk_lookup lookups[] = {
 	/* main clocks */
 	CLKDEV_CON_ID("emi_clk", &sh4202_emi_clk),

commit 4073723acb9cdcdbe4df9c0e0c376c65d1697e43
Merge: 58daf18cdcab 4ec3eb136345
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jan 6 22:32:52 2011 +0000

    Merge branch 'misc' into devel
    
    Conflicts:
            arch/arm/Kconfig
            arch/arm/common/Makefile
            arch/arm/kernel/Makefile
            arch/arm/kernel/smp.c

commit 4ec3eb13634529c0bc7466658d84d0bbe3244aea
Merge: 24056f525051 15095bb0fe77
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jan 6 22:31:35 2011 +0000

    Merge branch 'smp' into misc
    
    Conflicts:
            arch/arm/kernel/entry-armv.S
            arch/arm/mm/ioremap.c

commit 638fa4aad5bbb75c8f0d558aa15dcb543de5fc31
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Dec 24 11:27:29 2010 +0900

    sh: Fix up SH4-202 clkfwk build.
    
    Some of the SH4-202 code was overlooked in the set_rate() API conversion,
    resulting in:
    
    arch/sh/kernel/cpu/sh4/clock-sh4-202.c: error: too many arguments to function 'clk->ops->set_rate'
    
    Fix it up.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
index b601fa3978d1..6282a839e08e 100644
--- a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
+++ b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
@@ -81,8 +81,7 @@ static void shoc_clk_init(struct clk *clk)
 	for (i = 0; i < ARRAY_SIZE(frqcr3_divisors); i++) {
 		int divisor = frqcr3_divisors[i];
 
-		if (clk->ops->set_rate(clk, clk->parent->rate /
-						divisor, 0) == 0)
+		if (clk->ops->set_rate(clk, clk->parent->rate / divisor) == 0)
 			break;
 	}
 

commit 6d803ba736abb5e122dede70a4720e4843dd6df4
Author: Jean-Christop PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Wed Nov 17 10:04:33 2010 +0100

    ARM: 6483/1: arm & sh: factorised duplicated clkdev.c
    
    factorise some generic infrastructure to assist looking up struct clks
    for the ARM & SH architecture.
    
    as the code is identical at 99%
    
    put the arch specific code for allocation as example in asm/clkdev.h
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
index 4eabc68cd753..6c1492b8431a 100644
--- a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
+++ b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
@@ -13,7 +13,7 @@
 #include <linux/kernel.h>
 #include <linux/err.h>
 #include <linux/io.h>
-#include <asm/clkdev.h>
+#include <linux/clkdev.h>
 #include <asm/clock.h>
 #include <asm/freq.h>
 

commit 35a96c739fd7624b8edff990a74b86b5a85342da
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Nov 15 18:18:32 2010 +0900

    sh: clkfwk: Kill off now unused algo_id in set_rate op.
    
    Now that clk_set_rate_ex() is gone, there is also no way to get at rate
    setting algo id, which is now also completely unused. Kill it off before
    new clock ops start using it.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
index 4eabc68cd753..b601fa3978d1 100644
--- a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
+++ b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
@@ -110,7 +110,7 @@ static int shoc_clk_verify_rate(struct clk *clk, unsigned long rate)
 	return 0;
 }
 
-static int shoc_clk_set_rate(struct clk *clk, unsigned long rate, int algo_id)
+static int shoc_clk_set_rate(struct clk *clk, unsigned long rate)
 {
 	unsigned long frqcr3;
 	unsigned int tmp;

commit 9c352bcab7f28e472b06c91d57210b93e08f0fbb
Author: Magnus Damm <damm@opensource.se>
Date:   Tue May 11 09:36:57 2010 +0000

    sh: switch sh4-202 to clkdev
    
    This patch converts the remaining sh4-202 clocks
    to use clkdev for lookup. The now unused name
    and id from struct clk are also removed.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
index 6b80850294da..4eabc68cd753 100644
--- a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
+++ b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
@@ -12,9 +12,10 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/err.h>
+#include <linux/io.h>
+#include <asm/clkdev.h>
 #include <asm/clock.h>
 #include <asm/freq.h>
-#include <asm/io.h>
 
 #define CPG2_FRQCR3	0xfe0a0018
 
@@ -45,7 +46,6 @@ static struct clk_ops sh4202_emi_clk_ops = {
 };
 
 static struct clk sh4202_emi_clk = {
-	.name		= "emi_clk",
 	.flags		= CLK_ENABLE_ON_INIT,
 	.ops		= &sh4202_emi_clk_ops,
 };
@@ -61,7 +61,6 @@ static struct clk_ops sh4202_femi_clk_ops = {
 };
 
 static struct clk sh4202_femi_clk = {
-	.name		= "femi_clk",
 	.flags		= CLK_ENABLE_ON_INIT,
 	.ops		= &sh4202_femi_clk_ops,
 };
@@ -139,7 +138,6 @@ static struct clk_ops sh4202_shoc_clk_ops = {
 };
 
 static struct clk sh4202_shoc_clk = {
-	.name		= "shoc_clk",
 	.flags		= CLK_ENABLE_ON_INIT,
 	.ops		= &sh4202_shoc_clk_ops,
 };
@@ -150,6 +148,15 @@ static struct clk *sh4202_onchip_clocks[] = {
 	&sh4202_shoc_clk,
 };
 
+#define CLKDEV_CON_ID(_id, _clk) { .con_id = _id, .clk = _clk }
+
+static struct clk_lookup lookups[] = {
+	/* main clocks */
+	CLKDEV_CON_ID("emi_clk", &sh4202_emi_clk),
+	CLKDEV_CON_ID("femi_clk", &sh4202_femi_clk),
+	CLKDEV_CON_ID("shoc_clk", &sh4202_shoc_clk),
+};
+
 int __init arch_clk_init(void)
 {
 	struct clk *clk;
@@ -167,5 +174,7 @@ int __init arch_clk_init(void)
 
 	clk_put(clk);
 
+	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
+
 	return ret;
 }

commit 9d56dd3b083a3bec56e9da35ce07baca81030b03
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jan 26 12:58:40 2010 +0900

    sh: Mass ctrl_in/outX to __raw_read/writeX conversion.
    
    The old ctrl in/out routines are non-portable and unsuitable for
    cross-platform use. While drivers/sh has already been sanitized, there
    is still quite a lot of code that is not. This converts the arch/sh/ bits
    over, which permits us to flag the routines as deprecated whilst still
    building with -Werror for the architecture code, and to ensure that
    future users are not added.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
index 21421e34e7d5..6b80850294da 100644
--- a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
+++ b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
@@ -23,7 +23,7 @@ static int frqcr3_values[]   = { 0, 1, 2, 3, 4, 5, 6  };
 
 static unsigned long emi_clk_recalc(struct clk *clk)
 {
-	int idx = ctrl_inl(CPG2_FRQCR3) & 0x0007;
+	int idx = __raw_readl(CPG2_FRQCR3) & 0x0007;
 	return clk->parent->rate / frqcr3_divisors[idx];
 }
 
@@ -52,7 +52,7 @@ static struct clk sh4202_emi_clk = {
 
 static unsigned long femi_clk_recalc(struct clk *clk)
 {
-	int idx = (ctrl_inl(CPG2_FRQCR3) >> 3) & 0x0007;
+	int idx = (__raw_readl(CPG2_FRQCR3) >> 3) & 0x0007;
 	return clk->parent->rate / frqcr3_divisors[idx];
 }
 
@@ -92,7 +92,7 @@ static void shoc_clk_init(struct clk *clk)
 
 static unsigned long shoc_clk_recalc(struct clk *clk)
 {
-	int idx = (ctrl_inl(CPG2_FRQCR3) >> 6) & 0x0007;
+	int idx = (__raw_readl(CPG2_FRQCR3) >> 6) & 0x0007;
 	return clk->parent->rate / frqcr3_divisors[idx];
 }
 
@@ -122,10 +122,10 @@ static int shoc_clk_set_rate(struct clk *clk, unsigned long rate, int algo_id)
 
 	tmp = frqcr3_lookup(clk, rate);
 
-	frqcr3 = ctrl_inl(CPG2_FRQCR3);
+	frqcr3 = __raw_readl(CPG2_FRQCR3);
 	frqcr3 &= ~(0x0007 << 6);
 	frqcr3 |= tmp << 6;
-	ctrl_outl(frqcr3, CPG2_FRQCR3);
+	__raw_writel(frqcr3, CPG2_FRQCR3);
 
 	clk->rate = clk->parent->rate / frqcr3_divisors[tmp];
 

commit 253b0887b3736160feac9ccdcf146a2073e41463
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed May 13 17:38:11 2009 +0900

    sh: clkfwk: Rework legacy CPG clock handling.
    
    This moves out the old legacy CPG clocks to their own file, and converts
    over the existing users. With these clocks going away and each CPU
    dealing with them on their own, CPUs can gradually move over to the new
    interface.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
index a72dc326d0b3..21421e34e7d5 100644
--- a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
+++ b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
@@ -152,9 +152,12 @@ static struct clk *sh4202_onchip_clocks[] = {
 
 int __init arch_clk_init(void)
 {
-	struct clk *clk = clk_get(NULL, "master_clk");
+	struct clk *clk;
 	int i, ret = 0;
 
+	cpg_clk_init();
+
+	clk = clk_get(NULL, "master_clk");
 	for (i = 0; i < ARRAY_SIZE(sh4202_onchip_clocks); i++) {
 		struct clk *clkp = sh4202_onchip_clocks[i];
 

commit 9fe5ee0efb1b1d4a0939bc4252a8427e3337d96a
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 12 19:29:04 2009 +0900

    sh: clkfwk: Use arch_clk_init() for on-chip clock registration.
    
    CPUs registering on-chip clocks should be using arch_clk_init() with the
    new scheme so that the CPUs have the opportunity to establish the
    topology prior to the initial root clock rate propagation. This ensures
    that CPUs with on-chip clocks that use CLK_ENABLE_ON_INIT are properly
    enabled at the initial propagation time, without having to further poke
    the root clocks.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
index 435f4f12ffb8..a72dc326d0b3 100644
--- a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
+++ b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
@@ -150,7 +150,7 @@ static struct clk *sh4202_onchip_clocks[] = {
 	&sh4202_shoc_clk,
 };
 
-static int __init sh4202_clk_init(void)
+int __init arch_clk_init(void)
 {
 	struct clk *clk = clk_get(NULL, "master_clk");
 	int i, ret = 0;
@@ -166,4 +166,3 @@ static int __init sh4202_clk_init(void)
 
 	return ret;
 }
-arch_initcall(sh4202_clk_init);

commit f5c84cf50812c80133e64683d0500b2416d55cb3
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 12 05:59:27 2009 +0900

    sh: clkfwk: Tidy up on-chip clock registration and rate propagation.
    
    This tidies up the set_rate hack that the on-chip clocks were abusing to
    trigger rate propagation, which is now handled generically.
    
    Additionally, now that CLK_ENABLE_ON_INIT is wired up where it needs to
    be for these clocks, the clk_enable() can go away. In some cases this was
    bumping up the refcount higher than it should have been.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
index 0caca9f99fe8..435f4f12ffb8 100644
--- a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
+++ b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
@@ -127,7 +127,7 @@ static int shoc_clk_set_rate(struct clk *clk, unsigned long rate, int algo_id)
 	frqcr3 |= tmp << 6;
 	ctrl_outl(frqcr3, CPG2_FRQCR3);
 
-	return clk->parent->rate / frqcr3_divisors[tmp];
+	clk->rate = clk->parent->rate / frqcr3_divisors[tmp];
 
 	return 0;
 }
@@ -153,28 +153,17 @@ static struct clk *sh4202_onchip_clocks[] = {
 static int __init sh4202_clk_init(void)
 {
 	struct clk *clk = clk_get(NULL, "master_clk");
-	int i;
+	int i, ret = 0;
 
 	for (i = 0; i < ARRAY_SIZE(sh4202_onchip_clocks); i++) {
 		struct clk *clkp = sh4202_onchip_clocks[i];
 
 		clkp->parent = clk;
-		clk_register(clkp);
-		clk_enable(clkp);
+		ret |= clk_register(clkp);
 	}
 
-	/*
-	 * Now that we have the rest of the clocks registered, we need to
-	 * force the parent clock to propagate so that these clocks will
-	 * automatically figure out their rate. We cheat by handing the
-	 * parent clock its current rate and forcing child propagation.
-	 */
-	clk_set_rate(clk, clk_get_rate(clk));
-
 	clk_put(clk);
 
-	return 0;
+	return ret;
 }
-
 arch_initcall(sh4202_clk_init);
-

commit 4ff29ff8e8723a41e7defd8bc78a7b16cbf940a2
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 12 05:14:53 2009 +0900

    sh: clkfwk: Consolidate the ALWAYS_ENABLED / NEEDS_INIT mess.
    
    There is no real distinction here in behaviour, either a clock needs to
    be enabled on initialiation or not. The ALWAYS_ENABLED flag was always
    intended to only apply to clocks that were physically always on and could
    simply not be disabled at all from software. Unfortunately over time this
    was abused and the meaning became a bit blurry.
    
    So, we kill off both of all of those paths now, as well as the newer
    NEEDS_INIT flag, and consolidate on a CLK_ENABLE_ON_INIT. Clocks that
    need to be enabled on initialization can set this, and it will purposely
    enable them and bump the refcount up.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
index 628d50ea6f6b..0caca9f99fe8 100644
--- a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
+++ b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
@@ -46,7 +46,7 @@ static struct clk_ops sh4202_emi_clk_ops = {
 
 static struct clk sh4202_emi_clk = {
 	.name		= "emi_clk",
-	.flags		= CLK_ALWAYS_ENABLED,
+	.flags		= CLK_ENABLE_ON_INIT,
 	.ops		= &sh4202_emi_clk_ops,
 };
 
@@ -62,7 +62,7 @@ static struct clk_ops sh4202_femi_clk_ops = {
 
 static struct clk sh4202_femi_clk = {
 	.name		= "femi_clk",
-	.flags		= CLK_ALWAYS_ENABLED,
+	.flags		= CLK_ENABLE_ON_INIT,
 	.ops		= &sh4202_femi_clk_ops,
 };
 
@@ -140,7 +140,7 @@ static struct clk_ops sh4202_shoc_clk_ops = {
 
 static struct clk sh4202_shoc_clk = {
 	.name		= "shoc_clk",
-	.flags		= CLK_ALWAYS_ENABLED,
+	.flags		= CLK_ENABLE_ON_INIT,
 	.ops		= &sh4202_shoc_clk_ops,
 };
 

commit b68d8201433a91cabbcbeae48b53d8c1c426433a
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 12 03:45:08 2009 +0900

    sh: clkfwk: Make recalc return an unsigned long.
    
    This is prep work for cleaning up some of the rate propagation bits.
    Trivial conversion.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
index a33429463e96..628d50ea6f6b 100644
--- a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
+++ b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
@@ -21,10 +21,10 @@
 static int frqcr3_divisors[] = { 1, 2, 3, 4, 6, 8, 16 };
 static int frqcr3_values[]   = { 0, 1, 2, 3, 4, 5, 6  };
 
-static void emi_clk_recalc(struct clk *clk)
+static unsigned long emi_clk_recalc(struct clk *clk)
 {
 	int idx = ctrl_inl(CPG2_FRQCR3) & 0x0007;
-	clk->rate = clk->parent->rate / frqcr3_divisors[idx];
+	return clk->parent->rate / frqcr3_divisors[idx];
 }
 
 static inline int frqcr3_lookup(struct clk *clk, unsigned long rate)
@@ -50,10 +50,10 @@ static struct clk sh4202_emi_clk = {
 	.ops		= &sh4202_emi_clk_ops,
 };
 
-static void femi_clk_recalc(struct clk *clk)
+static unsigned long femi_clk_recalc(struct clk *clk)
 {
 	int idx = (ctrl_inl(CPG2_FRQCR3) >> 3) & 0x0007;
-	clk->rate = clk->parent->rate / frqcr3_divisors[idx];
+	return clk->parent->rate / frqcr3_divisors[idx];
 }
 
 static struct clk_ops sh4202_femi_clk_ops = {
@@ -90,10 +90,10 @@ static void shoc_clk_init(struct clk *clk)
 	WARN_ON(i == ARRAY_SIZE(frqcr3_divisors));	/* Undefined clock */
 }
 
-static void shoc_clk_recalc(struct clk *clk)
+static unsigned long shoc_clk_recalc(struct clk *clk)
 {
 	int idx = (ctrl_inl(CPG2_FRQCR3) >> 6) & 0x0007;
-	clk->rate = clk->parent->rate / frqcr3_divisors[idx];
+	return clk->parent->rate / frqcr3_divisors[idx];
 }
 
 static int shoc_clk_verify_rate(struct clk *clk, unsigned long rate)
@@ -127,7 +127,7 @@ static int shoc_clk_set_rate(struct clk *clk, unsigned long rate, int algo_id)
 	frqcr3 |= tmp << 6;
 	ctrl_outl(frqcr3, CPG2_FRQCR3);
 
-	clk->rate = clk->parent->rate / frqcr3_divisors[tmp];
+	return clk->parent->rate / frqcr3_divisors[tmp];
 
 	return 0;
 }

commit 907c9d70042e38efc6a981d425a3d8d98b089cba
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Jun 4 10:51:59 2007 +0900

    sh: Fix SH4-202 clock fwk set_rate() mismatch.
    
    With the SH7722 changes, ->set_rate() also takes an algo_id,
    SH4-202 was overlooked when this change went in.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
index fcb2c41bc34e..a33429463e96 100644
--- a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
+++ b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
@@ -111,7 +111,7 @@ static int shoc_clk_verify_rate(struct clk *clk, unsigned long rate)
 	return 0;
 }
 
-static int shoc_clk_set_rate(struct clk *clk, unsigned long rate)
+static int shoc_clk_set_rate(struct clk *clk, unsigned long rate, int algo_id)
 {
 	unsigned long frqcr3;
 	unsigned int tmp;

commit 1929cb340b74904c130fdf3de3fe5bbedb68a5aa
Author: dmitry pervushin <dimka@nomadgs.com>
Date:   Tue Apr 24 13:39:09 2007 +0900

    sh: SH7722 clock framework support.
    
    This adds support for the SH7722 (MobileR) to the clock framework.
    
    Signed-off-by: dmitry pervushin <dimka@nomadgs.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
index fa2019aabd74..fcb2c41bc34e 100644
--- a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
+++ b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
@@ -82,7 +82,8 @@ static void shoc_clk_init(struct clk *clk)
 	for (i = 0; i < ARRAY_SIZE(frqcr3_divisors); i++) {
 		int divisor = frqcr3_divisors[i];
 
-		if (clk->ops->set_rate(clk, clk->parent->rate / divisor) == 0)
+		if (clk->ops->set_rate(clk, clk->parent->rate /
+						divisor, 0) == 0)
 			break;
 	}
 

commit 1d118562c2067a42d0e8f70671a4ce27d7c6ffee
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Dec 1 13:15:14 2006 +0900

    sh: Clock framework tidying.
    
    This syncs up the SH clock framework with the linux/clk.h API,
    for which there were only some minor changes required, namely
    the clk_get() dev_id and subsequent callsites.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
index bfdf5fe8d948..fa2019aabd74 100644
--- a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
+++ b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
@@ -97,7 +97,7 @@ static void shoc_clk_recalc(struct clk *clk)
 
 static int shoc_clk_verify_rate(struct clk *clk, unsigned long rate)
 {
-	struct clk *bclk = clk_get("bus_clk");
+	struct clk *bclk = clk_get(NULL, "bus_clk");
 	unsigned long bclk_rate = clk_get_rate(bclk);
 
 	clk_put(bclk);
@@ -151,7 +151,7 @@ static struct clk *sh4202_onchip_clocks[] = {
 
 static int __init sh4202_clk_init(void)
 {
-	struct clk *clk = clk_get("master_clk");
+	struct clk *clk = clk_get(NULL, "master_clk");
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(sh4202_onchip_clocks); i++) {

commit 36ddf31b689a8c11d424e43565d2aa440b77bbf4
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Jan 16 22:14:17 2006 -0800

    [PATCH] sh: Simplistic clock framework
    
    This adds a relatively simplistic clock framework for sh.  The initial goal
    behind this is to clean up the arch/sh/kernel/time.c mess and to get the CPU
    subtype-specific frequency setting and calculation code moved somewhere more
    sensible.
    
    This only deals with the core clocks at the moment, though it's trivial for
    other drivers to define their own clocks as desired.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
new file mode 100644
index 000000000000..bfdf5fe8d948
--- /dev/null
+++ b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
@@ -0,0 +1,179 @@
+/*
+ * arch/sh/kernel/cpu/sh4/clock-sh4-202.c
+ *
+ * Additional SH4-202 support for the clock framework
+ *
+ *  Copyright (C) 2005  Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <asm/clock.h>
+#include <asm/freq.h>
+#include <asm/io.h>
+
+#define CPG2_FRQCR3	0xfe0a0018
+
+static int frqcr3_divisors[] = { 1, 2, 3, 4, 6, 8, 16 };
+static int frqcr3_values[]   = { 0, 1, 2, 3, 4, 5, 6  };
+
+static void emi_clk_recalc(struct clk *clk)
+{
+	int idx = ctrl_inl(CPG2_FRQCR3) & 0x0007;
+	clk->rate = clk->parent->rate / frqcr3_divisors[idx];
+}
+
+static inline int frqcr3_lookup(struct clk *clk, unsigned long rate)
+{
+	int divisor = clk->parent->rate / rate;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(frqcr3_divisors); i++)
+		if (frqcr3_divisors[i] == divisor)
+			return frqcr3_values[i];
+
+	/* Safe fallback */
+	return 5;
+}
+
+static struct clk_ops sh4202_emi_clk_ops = {
+	.recalc		= emi_clk_recalc,
+};
+
+static struct clk sh4202_emi_clk = {
+	.name		= "emi_clk",
+	.flags		= CLK_ALWAYS_ENABLED,
+	.ops		= &sh4202_emi_clk_ops,
+};
+
+static void femi_clk_recalc(struct clk *clk)
+{
+	int idx = (ctrl_inl(CPG2_FRQCR3) >> 3) & 0x0007;
+	clk->rate = clk->parent->rate / frqcr3_divisors[idx];
+}
+
+static struct clk_ops sh4202_femi_clk_ops = {
+	.recalc		= femi_clk_recalc,
+};
+
+static struct clk sh4202_femi_clk = {
+	.name		= "femi_clk",
+	.flags		= CLK_ALWAYS_ENABLED,
+	.ops		= &sh4202_femi_clk_ops,
+};
+
+static void shoc_clk_init(struct clk *clk)
+{
+	int i;
+
+	/*
+	 * For some reason, the shoc_clk seems to be set to some really
+	 * insane value at boot (values outside of the allowable frequency
+	 * range for instance). We deal with this by scaling it back down
+	 * to something sensible just in case.
+	 *
+	 * Start scaling from the high end down until we find something
+	 * that passes rate verification..
+	 */
+	for (i = 0; i < ARRAY_SIZE(frqcr3_divisors); i++) {
+		int divisor = frqcr3_divisors[i];
+
+		if (clk->ops->set_rate(clk, clk->parent->rate / divisor) == 0)
+			break;
+	}
+
+	WARN_ON(i == ARRAY_SIZE(frqcr3_divisors));	/* Undefined clock */
+}
+
+static void shoc_clk_recalc(struct clk *clk)
+{
+	int idx = (ctrl_inl(CPG2_FRQCR3) >> 6) & 0x0007;
+	clk->rate = clk->parent->rate / frqcr3_divisors[idx];
+}
+
+static int shoc_clk_verify_rate(struct clk *clk, unsigned long rate)
+{
+	struct clk *bclk = clk_get("bus_clk");
+	unsigned long bclk_rate = clk_get_rate(bclk);
+
+	clk_put(bclk);
+
+	if (rate > bclk_rate)
+		return 1;
+	if (rate > 66000000)
+		return 1;
+
+	return 0;
+}
+
+static int shoc_clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long frqcr3;
+	unsigned int tmp;
+
+	/* Make sure we have something sensible to switch to */
+	if (shoc_clk_verify_rate(clk, rate) != 0)
+		return -EINVAL;
+
+	tmp = frqcr3_lookup(clk, rate);
+
+	frqcr3 = ctrl_inl(CPG2_FRQCR3);
+	frqcr3 &= ~(0x0007 << 6);
+	frqcr3 |= tmp << 6;
+	ctrl_outl(frqcr3, CPG2_FRQCR3);
+
+	clk->rate = clk->parent->rate / frqcr3_divisors[tmp];
+
+	return 0;
+}
+
+static struct clk_ops sh4202_shoc_clk_ops = {
+	.init		= shoc_clk_init,
+	.recalc		= shoc_clk_recalc,
+	.set_rate	= shoc_clk_set_rate,
+};
+
+static struct clk sh4202_shoc_clk = {
+	.name		= "shoc_clk",
+	.flags		= CLK_ALWAYS_ENABLED,
+	.ops		= &sh4202_shoc_clk_ops,
+};
+
+static struct clk *sh4202_onchip_clocks[] = {
+	&sh4202_emi_clk,
+	&sh4202_femi_clk,
+	&sh4202_shoc_clk,
+};
+
+static int __init sh4202_clk_init(void)
+{
+	struct clk *clk = clk_get("master_clk");
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(sh4202_onchip_clocks); i++) {
+		struct clk *clkp = sh4202_onchip_clocks[i];
+
+		clkp->parent = clk;
+		clk_register(clkp);
+		clk_enable(clkp);
+	}
+
+	/*
+	 * Now that we have the rest of the clocks registered, we need to
+	 * force the parent clock to propagate so that these clocks will
+	 * automatically figure out their rate. We cheat by handing the
+	 * parent clock its current rate and forcing child propagation.
+	 */
+	clk_set_rate(clk, clk_get_rate(clk));
+
+	clk_put(clk);
+
+	return 0;
+}
+
+arch_initcall(sh4202_clk_init);
+
