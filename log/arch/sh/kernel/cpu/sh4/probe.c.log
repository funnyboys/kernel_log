commit 6ecc0a4dbb076ef658cb5e140a7560d6326c8240
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 28 00:32:07 2018 -0800

    sh: sh4: convert to SPDX identifiers
    
    Update license to use SPDX-License-Identifier instead of verbose license
    text, excepting ${LINUX}/arch/sh/kernel/cpu/sh4/softfloat.c which is not
    GPL license
    
    Link: http://lkml.kernel.org/r/87a7lkcsya.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index a521bcf50695..ef4dd6295263 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * arch/sh/kernel/cpu/sh4/probe.c
  *
@@ -5,10 +6,6 @@
  *
  * Copyright (C) 2001 - 2007  Paul Mundt
  * Copyright (C) 2003  Richard Curnow
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 #include <linux/init.h>
 #include <linux/io.h>

commit 4603f53a1dc3c76dfba841d123db9fa6204934f5
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Jun 18 17:10:12 2013 -0400

    sh: delete __cpuinit usage from all sh files
    
    The __cpuinit type of throwaway sections might have made sense
    some time ago when RAM was more constrained, but now the savings
    do not offset the cost and complications.  For example, the fix in
    commit 5e427ec2d0 ("x86: Fix bit corruption at CPU resume time")
    is a good example of the nasty type of bugs that can be created
    with improper use of the various __init prefixes.
    
    After a discussion on LKML[1] it was decided that cpuinit should go
    the way of devinit and be phased out.  Once all the users are gone,
    we can then finally remove the macros themselves from linux/init.h.
    
    Note that some harmless section mismatch warnings may result, since
    notify_cpu_starting() and cpu_up() are arch independent (kernel/cpu.c)
    are flagged as __cpuinit  -- so if we remove the __cpuinit from
    arch specific callers, we will also get section mismatch warnings.
    As an intermediate step, we intend to turn the linux/init.h cpuinit
    content into no-ops as early as possible, since that will get rid
    of these warnings.  In any case, they are temporary and harmless.
    
    This removes all the arch/sh uses of the __cpuinit macros from
    all C files.  Currently sh does not have any __CPUINIT used in
    assembly files.
    
    [1] https://lkml.org/lkml/2013/5/20/589
    
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: linux-sh@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 0fbbd50bc8ad..a521bcf50695 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -15,7 +15,7 @@
 #include <asm/processor.h>
 #include <asm/cache.h>
 
-void __cpuinit cpu_probe(void)
+void cpu_probe(void)
 {
 	unsigned long pvr, prr, cvr;
 	unsigned long size;

commit fea88a0c02822fbb91a0b8301bf9af04377876a3
Author: Nobuhiro Iwamatsu <nobuhiro.iwamatsu.yj@renesas.com>
Date:   Thu Apr 12 15:45:32 2012 +0900

    sh: Add initial support for SH7734 CPU subtype
    
    This implements initial support for the SH7734.
    This adds support SCIF, TMU and RTC.
    
    Signed-off-by: Nobuhiro Iwamatsu <nobuhiro.iwamatsu.yj@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 971cf0fce4f5..0fbbd50bc8ad 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -158,6 +158,9 @@ void __cpuinit cpu_probe(void)
 		case 0x40: /* yon-ten-go */
 			boot_cpu_data.type = CPU_SH7372;
 			break;
+		case 0xE0: /* 0x4E0 */
+			boot_cpu_data.type = CPU_SH7734; /* SH7733/SH7734 */
+			break;
 
 		}
 		break;

commit fac6c2a891a3e7255e4440f09a4c7da954043ba9
Author: Magnus Damm <damm@opensource.se>
Date:   Wed Jan 12 10:54:21 2011 +0000

    sh: sh7372 SH4AL-DSP probe support
    
    Add probe support for the sh7372 SH4AL-DSP core.
    
    The most common use case for this is when the system
    boots from the ARM core in the sh7372 and uses the
    SH core for application offload as a slave CPU.
    
    May also be used to boot the sh7372 from the SH core.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index b1edc90d482b..971cf0fce4f5 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -154,6 +154,11 @@ void __cpuinit cpu_probe(void)
 		case 0x11:
 			boot_cpu_data.type = CPU_SH7757;
 			break;
+		case 0xd0:
+		case 0x40: /* yon-ten-go */
+			boot_cpu_data.type = CPU_SH7372;
+			break;
+
 		}
 		break;
 	case 0x4000:	/* 1st cut */

commit 538e790605be792fc90fe29db42f7e404ab7e5cc
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Fri Jan 7 10:26:24 2011 +0000

    sh: add PVR probing for SH7757 3rd cut
    
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index b93458f33b74..b1edc90d482b 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -151,6 +151,7 @@ void __cpuinit cpu_probe(void)
 			boot_cpu_data.flags |= CPU_HAS_L2_CACHE;
 			break;
 		case 0x10:
+		case 0x11:
 			boot_cpu_data.type = CPU_SH7757;
 			break;
 		}

commit e81e5ce23f8950bd9f5b9f1846be49ac078f2d11
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Tue Jul 6 04:31:29 2010 +0000

    sh: change PVR of SH7757 for 2nd cut
    
    All 1st cut silicon in the wild has been replaced by the 2nd cut, so it's
    safe to replace all of the 1st cut references and support.
    
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index d180f16281ed..b93458f33b74 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -150,7 +150,7 @@ void __cpuinit cpu_probe(void)
 			boot_cpu_data.type = CPU_SH7724;
 			boot_cpu_data.flags |= CPU_HAS_L2_CACHE;
 			break;
-		case 0x50:
+		case 0x10:
 			boot_cpu_data.type = CPU_SH7757;
 			break;
 		}

commit a9079ca0cb15feda15e7a380092e02d5cd834148
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Apr 21 12:01:06 2010 +0900

    sh: Tidy CPU probing and fixup section annotations.
    
    This does a detect_cpu_and_cache_system() -> cpu_probe() rename, tidies
    up the unused return value, and stuffs it under __cpuinit in preparation
    for CPU hotplug.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 822977a06d84..d180f16281ed 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -15,7 +15,7 @@
 #include <asm/processor.h>
 #include <asm/cache.h>
 
-int __init detect_cpu_and_cache_system(void)
+void __cpuinit cpu_probe(void)
 {
 	unsigned long pvr, prr, cvr;
 	unsigned long size;
@@ -251,6 +251,4 @@ int __init detect_cpu_and_cache_system(void)
 				 boot_cpu_data.scache.linesz);
 		}
 	}
-
-	return 0;
 }

commit 9d56dd3b083a3bec56e9da35ce07baca81030b03
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jan 26 12:58:40 2010 +0900

    sh: Mass ctrl_in/outX to __raw_read/writeX conversion.
    
    The old ctrl in/out routines are non-portable and unsuitable for
    cross-platform use. While drivers/sh has already been sanitized, there
    is still quite a lot of code that is not. This converts the arch/sh/ bits
    over, which permits us to flag the routines as deprecated whilst still
    building with -Werror for the architecture code, and to ensure that
    future users are not added.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index cc02b3145cca..822977a06d84 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -28,9 +28,9 @@ int __init detect_cpu_and_cache_system(void)
 		[9] = (1 << 16)
 	};
 
-	pvr = (ctrl_inl(CCN_PVR) >> 8) & 0xffffff;
-	prr = (ctrl_inl(CCN_PRR) >> 4) & 0xff;
-	cvr = (ctrl_inl(CCN_CVR));
+	pvr = (__raw_readl(CCN_PVR) >> 8) & 0xffffff;
+	prr = (__raw_readl(CCN_PRR) >> 4) & 0xff;
+	cvr = (__raw_readl(CCN_CVR));
 
 	/*
 	 * Setup some sane SH-4 defaults for the icache

commit bdc27300f5718626a3817e6478e339f6cca6b994
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Jan 20 03:38:56 2010 +0900

    sh: Handle SH-4 FPU variants with broken CVR values.
    
    Usually we can look to the CVR to work out whether we have an FPU or not.
    Unfortunately not all parts comply with this, so just set the flag
    manually for all SH-4 parts and clear it on the only SH-4 that doesn't
    have one (SH4-501).
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 21371f8cf010..cc02b3145cca 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -71,11 +71,11 @@ int __init detect_cpu_and_cache_system(void)
 		boot_cpu_data.dcache.ways = 4;
 	} else {
 		/* And some SH-4 defaults.. */
-		boot_cpu_data.flags |= CPU_HAS_PTEA;
+		boot_cpu_data.flags |= CPU_HAS_PTEA | CPU_HAS_FPU;
 		boot_cpu_data.family = CPU_FAMILY_SH4;
 	}
 
-	/* FPU detection works for everyone */
+	/* FPU detection works for almost everyone */
 	if ((cvr & 0x20000000))
 		boot_cpu_data.flags |= CPU_HAS_FPU;
 
@@ -161,6 +161,7 @@ int __init detect_cpu_and_cache_system(void)
 		break;
 	case 0x700:
 		boot_cpu_data.type = CPU_SH4_501;
+		boot_cpu_data.flags &= ~CPU_HAS_FPU;
 		boot_cpu_data.icache.ways = 2;
 		boot_cpu_data.dcache.ways = 2;
 		break;

commit 88f73d22853cb080432e91d68759323477a8b835
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Jan 13 18:37:19 2010 +0900

    sh: Fix up L2 cache comment typo.
    
    Valid sizes include 256kB, not 258kB.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 75189c4691da..21371f8cf010 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -228,7 +228,7 @@ int __init detect_cpu_and_cache_system(void)
 			 * Size calculation is much more sensible
 			 * than it is for the L1.
 			 *
-			 * Sizes are 128KB, 258KB, 512KB, and 1MB.
+			 * Sizes are 128KB, 256KB, 512KB, and 1MB.
 			 */
 			size = (cvr & 0xf) << 17;
 

commit 7f33306ee57bce9c79825e89c457a91025aa5aad
Author: Matt Fleming <matt@console-pimps.org>
Date:   Wed Jan 13 16:35:58 2010 +0900

    sh: PVR detection for 2nd cut SH7786.
    
    The mass produced cuts use an updated PVR value, add them to the list.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index d36f0c45f55f..75189c4691da 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -124,6 +124,7 @@ int __init detect_cpu_and_cache_system(void)
 		boot_cpu_data.type = CPU_SH7785;
 		break;
 	case 0x4004:
+	case 0x4005:
 		boot_cpu_data.type = CPU_SH7786;
 		boot_cpu_data.flags |= CPU_HAS_PTEAEX | CPU_HAS_L2_CACHE;
 		break;

commit ac6a0cf6716bb46813d0161024c66c2af66e53d1
Merge: e76a0136a3cf ce3f7cb96e67
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Sep 1 13:54:14 2009 +0900

    Merge branch 'master' into sh/smp
    
    Conflicts:
            arch/sh/mm/cache-sh4.c

commit b37c7c66f08df66ba7a8269b6d1af949ef8dbd95
Author: Kuninori Morimoto <morimoto.kuninori@renesas.com>
Date:   Wed Aug 26 10:49:44 2009 +0000

    sh: fix CPU_SH7723/7724 numbering bug
    
    Signed-off-by: Kuninori Morimoto <morimoto.kuninori@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 10e6795b56aa..afd3e73d5ad4 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -141,7 +141,7 @@ int __init detect_cpu_and_cache_system(void)
 	case 0x300b:
 		switch (prr) {
 		case 0x20:
-			boot_cpu_data.type = CPU_SH7723;
+			boot_cpu_data.type = CPU_SH7724;
 			boot_cpu_data.flags |= CPU_HAS_L2_CACHE;
 			break;
 		case 0x50:

commit c01f0f1a4a96eb3acc5850e18cc43f24366966d0
Author: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
Date:   Fri Aug 21 16:30:28 2009 +0900

    sh: Add initial support for SH7757 CPU subtype
    
    Signed-off-by: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 6c78d0a9c857..10e6795b56aa 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -139,8 +139,15 @@ int __init detect_cpu_and_cache_system(void)
 		}
 		break;
 	case 0x300b:
-		boot_cpu_data.type = CPU_SH7724;
-		boot_cpu_data.flags |= CPU_HAS_L2_CACHE;
+		switch (prr) {
+		case 0x20:
+			boot_cpu_data.type = CPU_SH7723;
+			boot_cpu_data.flags |= CPU_HAS_L2_CACHE;
+			break;
+		case 0x50:
+			boot_cpu_data.type = CPU_SH7757;
+			break;
+		}
 		break;
 	case 0x4000:	/* 1st cut */
 	case 0x4001:	/* 2nd cut */

commit eccee7457df2b1e1505522ab0064e577e16eed75
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sat Aug 15 13:15:02 2009 +0900

    sh: Kill off the unhandled pvr case in SH-4 CPU probing.
    
    This is superfluous, as the default CPU type and family are already
    established by the initial cpuinfo definition. Given that we are still
    able to probe for the CPU family even if we are not able to detect the
    subtype, it's preferable to let the probing code fill out what it can and
    leave the rest.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 1148607c36bf..695026a3f02d 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -177,9 +177,6 @@ int __init detect_cpu_and_cache_system(void)
 		boot_cpu_data.icache.ways = 2;
 		boot_cpu_data.dcache.ways = 2;
 
-		break;
-	default:
-		boot_cpu_data.type = boot_cpu_data.family = CPU_SH_NONE;
 		break;
 	}
 

commit e82da214d2fe3dc2610df966100c4f36bc0fad91
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sat Aug 15 10:48:13 2009 +0900

    sh: Track the CPU family in sh_cpuinfo.
    
    This adds a family member to struct sh_cpuinfo, which allows us to fall
    back more on the probe routines to work out what sort of subtype we are
    running on. This will be used by the CPU cache initialization code in
    order to first do family-level initialization, followed by subtype-level
    optimizations.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 6c78d0a9c857..1148607c36bf 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -57,8 +57,12 @@ int __init detect_cpu_and_cache_system(void)
 	 * Setup some generic flags we can probe on SH-4A parts
 	 */
 	if (((pvr >> 16) & 0xff) == 0x10) {
-		if ((cvr & 0x10000000) == 0)
+		boot_cpu_data.family = CPU_FAMILY_SH4A;
+
+		if ((cvr & 0x10000000) == 0) {
 			boot_cpu_data.flags |= CPU_HAS_DSP;
+			boot_cpu_data.family = CPU_FAMILY_SH4AL_DSP;
+		}
 
 		boot_cpu_data.flags |= CPU_HAS_LLSC | CPU_HAS_PERF_COUNTER;
 		boot_cpu_data.cut_major = pvr & 0x7f;
@@ -68,6 +72,7 @@ int __init detect_cpu_and_cache_system(void)
 	} else {
 		/* And some SH-4 defaults.. */
 		boot_cpu_data.flags |= CPU_HAS_PTEA;
+		boot_cpu_data.family = CPU_FAMILY_SH4;
 	}
 
 	/* FPU detection works for everyone */
@@ -174,7 +179,7 @@ int __init detect_cpu_and_cache_system(void)
 
 		break;
 	default:
-		boot_cpu_data.type = CPU_SH_NONE;
+		boot_cpu_data.type = boot_cpu_data.family = CPU_SH_NONE;
 		break;
 	}
 

commit 0bf8513ed0df64b38edce63411d4b7b368464f47
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Jun 1 19:50:08 2009 +0900

    sh: Tidy up SH-4A boot_cpu_data.flags probing.
    
    This tidies up the boot_cpu_data.flags probing on SH-4A. All of them have
    a few things in common, which we can blindly set, rather than having each
    subtype have to set the same flags. We can also make assumptions about
    cache ways and the validity of PTEA, so this also kills off CPU_HAS_PTEA
    as a config option. There was also a bug in the FPU probing, which is now
    tidied up.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 28a2f0db01db..6c78d0a9c857 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -60,12 +60,18 @@ int __init detect_cpu_and_cache_system(void)
 		if ((cvr & 0x10000000) == 0)
 			boot_cpu_data.flags |= CPU_HAS_DSP;
 
-		boot_cpu_data.flags |= CPU_HAS_LLSC;
+		boot_cpu_data.flags |= CPU_HAS_LLSC | CPU_HAS_PERF_COUNTER;
 		boot_cpu_data.cut_major = pvr & 0x7f;
+
+		boot_cpu_data.icache.ways = 4;
+		boot_cpu_data.dcache.ways = 4;
+	} else {
+		/* And some SH-4 defaults.. */
+		boot_cpu_data.flags |= CPU_HAS_PTEA;
 	}
 
 	/* FPU detection works for everyone */
-	if ((cvr & 0x20000000) == 1)
+	if ((cvr & 0x20000000))
 		boot_cpu_data.flags |= CPU_HAS_FPU;
 
 	/* Mask off the upper chip ID */
@@ -78,25 +84,20 @@ int __init detect_cpu_and_cache_system(void)
 	switch (pvr) {
 	case 0x205:
 		boot_cpu_data.type = CPU_SH7750;
-		boot_cpu_data.flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_FPU |
-				   CPU_HAS_PERF_COUNTER;
+		boot_cpu_data.flags |= CPU_HAS_P2_FLUSH_BUG |
+				       CPU_HAS_PERF_COUNTER;
 		break;
 	case 0x206:
 		boot_cpu_data.type = CPU_SH7750S;
-		boot_cpu_data.flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_FPU |
-				   CPU_HAS_PERF_COUNTER;
+		boot_cpu_data.flags |= CPU_HAS_P2_FLUSH_BUG |
+				       CPU_HAS_PERF_COUNTER;
 		break;
 	case 0x1100:
 		boot_cpu_data.type = CPU_SH7751;
-		boot_cpu_data.flags |= CPU_HAS_FPU;
 		break;
 	case 0x2001:
 	case 0x2004:
 		boot_cpu_data.type = CPU_SH7770;
-		boot_cpu_data.icache.ways = 4;
-		boot_cpu_data.dcache.ways = 4;
-
-		boot_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_LLSC;
 		break;
 	case 0x2006:
 	case 0x200A:
@@ -107,45 +108,26 @@ int __init detect_cpu_and_cache_system(void)
 		else
 			boot_cpu_data.type = CPU_SH7780;
 
-		boot_cpu_data.icache.ways = 4;
-		boot_cpu_data.dcache.ways = 4;
-
-		boot_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER |
-				   CPU_HAS_LLSC;
 		break;
 	case 0x3000:
 	case 0x3003:
 	case 0x3009:
 		boot_cpu_data.type = CPU_SH7343;
-		boot_cpu_data.icache.ways = 4;
-		boot_cpu_data.dcache.ways = 4;
-		boot_cpu_data.flags |= CPU_HAS_LLSC;
 		break;
 	case 0x3004:
 	case 0x3007:
 		boot_cpu_data.type = CPU_SH7785;
-		boot_cpu_data.icache.ways = 4;
-		boot_cpu_data.dcache.ways = 4;
-		boot_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER |
-					  CPU_HAS_LLSC;
 		break;
 	case 0x4004:
 		boot_cpu_data.type = CPU_SH7786;
-		boot_cpu_data.icache.ways = 4;
-		boot_cpu_data.dcache.ways = 4;
-		boot_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER |
-			CPU_HAS_LLSC | CPU_HAS_PTEAEX | CPU_HAS_L2_CACHE;
+		boot_cpu_data.flags |= CPU_HAS_PTEAEX | CPU_HAS_L2_CACHE;
 		break;
 	case 0x3008:
-		boot_cpu_data.icache.ways = 4;
-		boot_cpu_data.dcache.ways = 4;
-		boot_cpu_data.flags |= CPU_HAS_LLSC;
-
 		switch (prr) {
 		case 0x50:
 		case 0x51:
 			boot_cpu_data.type = CPU_SH7723;
-			boot_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_L2_CACHE;
+			boot_cpu_data.flags |= CPU_HAS_L2_CACHE;
 			break;
 		case 0x70:
 			boot_cpu_data.type = CPU_SH7366;
@@ -158,17 +140,11 @@ int __init detect_cpu_and_cache_system(void)
 		break;
 	case 0x300b:
 		boot_cpu_data.type = CPU_SH7724;
-		boot_cpu_data.icache.ways = 4;
-		boot_cpu_data.dcache.ways = 4;
-		boot_cpu_data.flags |= CPU_HAS_LLSC | CPU_HAS_FPU | CPU_HAS_L2_CACHE;
+		boot_cpu_data.flags |= CPU_HAS_L2_CACHE;
 		break;
 	case 0x4000:	/* 1st cut */
 	case 0x4001:	/* 2nd cut */
 		boot_cpu_data.type = CPU_SHX3;
-		boot_cpu_data.icache.ways = 4;
-		boot_cpu_data.dcache.ways = 4;
-		boot_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER |
-					  CPU_HAS_LLSC;
 		break;
 	case 0x700:
 		boot_cpu_data.type = CPU_SH4_501;
@@ -179,7 +155,6 @@ int __init detect_cpu_and_cache_system(void)
 		boot_cpu_data.type = CPU_SH4_202;
 		boot_cpu_data.icache.ways = 2;
 		boot_cpu_data.dcache.ways = 2;
-		boot_cpu_data.flags |= CPU_HAS_FPU;
 		break;
 	case 0x500 ... 0x501:
 		switch (prr) {
@@ -197,18 +172,12 @@ int __init detect_cpu_and_cache_system(void)
 		boot_cpu_data.icache.ways = 2;
 		boot_cpu_data.dcache.ways = 2;
 
-		boot_cpu_data.flags |= CPU_HAS_FPU;
-
 		break;
 	default:
 		boot_cpu_data.type = CPU_SH_NONE;
 		break;
 	}
 
-#ifdef CONFIG_CPU_HAS_PTEA
-	boot_cpu_data.flags |= CPU_HAS_PTEA;
-#endif
-
 	/*
 	 * On anything that's not a direct-mapped cache, look to the CVR
 	 * for I/D-cache specifics.

commit 7863d3f7aeae05099a38693a0a7eb7bdc7b2ab05
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Jun 1 19:38:41 2009 +0900

    sh: Tidy up the optional L2 probing, wire it up for SH7786.
    
    This tidies up the L2 probing, as it may or may not be implemented on a
    CPU, regardless of whether it is supported. This converts the cvr
    validity checks from BUG_ON()'s to simply clearing the CPU_HAS_L2_CACHE
    flag and moving on with life.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 7d821ce8434f..28a2f0db01db 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -134,7 +134,7 @@ int __init detect_cpu_and_cache_system(void)
 		boot_cpu_data.icache.ways = 4;
 		boot_cpu_data.dcache.ways = 4;
 		boot_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER |
-			CPU_HAS_LLSC | CPU_HAS_PTEAEX;
+			CPU_HAS_LLSC | CPU_HAS_PTEAEX | CPU_HAS_L2_CACHE;
 		break;
 	case 0x3008:
 		boot_cpu_data.icache.ways = 4;
@@ -228,43 +228,48 @@ int __init detect_cpu_and_cache_system(void)
 	}
 
 	/*
-	 * Setup the L2 cache desc
-	 *
 	 * SH-4A's have an optional PIPT L2.
 	 */
 	if (boot_cpu_data.flags & CPU_HAS_L2_CACHE) {
-		/* Bug if we can't decode the L2 info */
-		BUG_ON(!(cvr & 0xf));
-
-		/* Silicon and specifications have clearly never met.. */
-		cvr ^= 0xf;
-
 		/*
-		 * Size calculation is much more sensible
-		 * than it is for the L1.
-		 *
-		 * Sizes are 128KB, 258KB, 512KB, and 1MB.
+		 * Verify that it really has something hooked up, this
+		 * is the safety net for CPUs that have optional L2
+		 * support yet do not implement it.
 		 */
-		size = (cvr & 0xf) << 17;
+		if ((cvr & 0xf) == 0)
+			boot_cpu_data.flags &= ~CPU_HAS_L2_CACHE;
+		else {
+			/*
+			 * Silicon and specifications have clearly never
+			 * met..
+			 */
+			cvr ^= 0xf;
 
-		BUG_ON(!size);
+			/*
+			 * Size calculation is much more sensible
+			 * than it is for the L1.
+			 *
+			 * Sizes are 128KB, 258KB, 512KB, and 1MB.
+			 */
+			size = (cvr & 0xf) << 17;
 
-		boot_cpu_data.scache.way_incr		= (1 << 16);
-		boot_cpu_data.scache.entry_shift	= 5;
-		boot_cpu_data.scache.ways		= 4;
-		boot_cpu_data.scache.linesz		= L1_CACHE_BYTES;
+			boot_cpu_data.scache.way_incr		= (1 << 16);
+			boot_cpu_data.scache.entry_shift	= 5;
+			boot_cpu_data.scache.ways		= 4;
+			boot_cpu_data.scache.linesz		= L1_CACHE_BYTES;
 
-		boot_cpu_data.scache.entry_mask	=
-			(boot_cpu_data.scache.way_incr -
-			 boot_cpu_data.scache.linesz);
+			boot_cpu_data.scache.entry_mask	=
+				(boot_cpu_data.scache.way_incr -
+				 boot_cpu_data.scache.linesz);
 
-		boot_cpu_data.scache.sets	= size /
-			(boot_cpu_data.scache.linesz *
-			 boot_cpu_data.scache.ways);
+			boot_cpu_data.scache.sets	= size /
+				(boot_cpu_data.scache.linesz *
+				 boot_cpu_data.scache.ways);
 
-		boot_cpu_data.scache.way_size	=
-			(boot_cpu_data.scache.sets *
-			 boot_cpu_data.scache.linesz);
+			boot_cpu_data.scache.way_size	=
+				(boot_cpu_data.scache.sets *
+				 boot_cpu_data.scache.linesz);
+		}
 	}
 
 	return 0;

commit 98fbe45bea77c1804eae0e71f27673db1824a2a8
Author: Kuninori Morimoto <morimoto.kuninori@renesas.com>
Date:   Fri May 29 07:41:23 2009 +0000

    sh: SH7724 has an L2 cache.
    
    Add the CPU_HAS_L2_CACHE flag to SH7724.
    
    Signed-off-by: Kuninori Morimoto <morimoto.kuninori@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 973ff831c8a8..7d821ce8434f 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -160,7 +160,7 @@ int __init detect_cpu_and_cache_system(void)
 		boot_cpu_data.type = CPU_SH7724;
 		boot_cpu_data.icache.ways = 4;
 		boot_cpu_data.dcache.ways = 4;
-		boot_cpu_data.flags |= CPU_HAS_LLSC | CPU_HAS_FPU;
+		boot_cpu_data.flags |= CPU_HAS_LLSC | CPU_HAS_FPU | CPU_HAS_L2_CACHE;
 		break;
 	case 0x4000:	/* 1st cut */
 	case 0x4001:	/* 2nd cut */

commit 0207a2efb43d81e29e23662b5d035945688a103f
Author: Kuninori Morimoto <morimoto.kuninori@renesas.com>
Date:   Thu Apr 16 14:40:56 2009 +0900

    sh: Add support for SH7724 (SH-Mobile R2R) CPU subtype.
    
    This implements initial support for the SH-Mobile R2R CPU.
    Based on Rev 0.11 of the initial SH7724 hardware manual.
    
    Signed-off-by: Kuninori Morimoto <morimoto.kuninori@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 91e3677ae09d..973ff831c8a8 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -156,6 +156,12 @@ int __init detect_cpu_and_cache_system(void)
 			break;
 		}
 		break;
+	case 0x300b:
+		boot_cpu_data.type = CPU_SH7724;
+		boot_cpu_data.icache.ways = 4;
+		boot_cpu_data.dcache.ways = 4;
+		boot_cpu_data.flags |= CPU_HAS_LLSC | CPU_HAS_FPU;
+		break;
 	case 0x4000:	/* 1st cut */
 	case 0x4001:	/* 2nd cut */
 		boot_cpu_data.type = CPU_SHX3;

commit e8208828dc014dc0193dc5558995556df0fbe3a5
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Apr 2 17:40:16 2009 +0900

    sh: Kill off broken direct-mapped cache mode.
    
    Forcing direct-mapped worked on certain older 2-way set associative
    parts, but was always error prone on 4-way parts. As these are the
    norm these days, there is not much point in continuing to support this
    mode. Most of the folks that used direct-mapped mode generally just
    wanted writethrough caching in the first place..
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 3d3a3c4425a9..91e3677ae09d 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -199,11 +199,6 @@ int __init detect_cpu_and_cache_system(void)
 		break;
 	}
 
-#ifdef CONFIG_SH_DIRECT_MAPPED
-	boot_cpu_data.icache.ways = 1;
-	boot_cpu_data.dcache.ways = 1;
-#endif
-
 #ifdef CONFIG_CPU_HAS_PTEA
 	boot_cpu_data.flags |= CPU_HAS_PTEA;
 #endif

commit 8263a67e169fdf0d06d172acbf6c03ae172a69d4
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Mar 17 17:49:49 2009 +0900

    sh: Support for extended ASIDs on PTEAEX-capable SH-X3 cores.
    
    This adds support for extended ASIDs (up to 16-bits) on newer SH-X3 cores
    that implement the PTAEX register and respective functionality. Presently
    only the 65nm SH7786 (90nm only supports legacy 8-bit ASIDs).
    
    The main change is in how the PTE is written out when loading the entry
    in to the TLB, as well as in how the TLB entry is selectively flushed.
    
    While SH-X2 extended mode splits out the memory-mapped U and I-TLB data
    arrays for extra bits, extended ASID mode splits out the address arrays.
    While we don't use the memory-mapped data array access, the address
    array accesses are necessary for selective TLB flushes, so these are
    implemented newly and replace the generic SH-4 implementation.
    
    With this, TLB flushes in switch_mm() are almost non-existent on newer
    parts.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 2bd0ec962639..3d3a3c4425a9 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -134,7 +134,7 @@ int __init detect_cpu_and_cache_system(void)
 		boot_cpu_data.icache.ways = 4;
 		boot_cpu_data.dcache.ways = 4;
 		boot_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER |
-			CPU_HAS_LLSC;
+			CPU_HAS_LLSC | CPU_HAS_PTEAEX;
 		break;
 	case 0x3008:
 		boot_cpu_data.icache.ways = 4;

commit 55ba99eb211a06709237cb322ecd8c8b6faf6159
Author: Kuninori Morimoto <morimoto.kuninori@renesas.com>
Date:   Tue Mar 3 15:40:25 2009 +0900

    sh: Add support for SH7786 CPU subtype.
    
    This adds preliminary support for the SH7786 CPU subtype.
    
    While this is a dual-core CPU, only UP is supported for now. L2 cache
    support is likewise not yet implemented.
    
    More information on this particular CPU subtype is available at:
    
            http://www.renesas.com/fmwk.jsp?cnt=sh7786_root.jsp&fp=/products/mpumcu/superh_family/sh7780_series/sh7786_group/
    
    Signed-off-by: Kuninori Morimoto <morimoto.kuninori@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 2e42572b1b11..2bd0ec962639 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -129,6 +129,13 @@ int __init detect_cpu_and_cache_system(void)
 		boot_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER |
 					  CPU_HAS_LLSC;
 		break;
+	case 0x4004:
+		boot_cpu_data.type = CPU_SH7786;
+		boot_cpu_data.icache.ways = 4;
+		boot_cpu_data.dcache.ways = 4;
+		boot_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER |
+			CPU_HAS_LLSC;
+		break;
 	case 0x3008:
 		boot_cpu_data.icache.ways = 4;
 		boot_cpu_data.dcache.ways = 4;

commit 068f59143d821553e7a55cdbd69142b05e245d47
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Jul 2 17:46:40 2008 +0900

    sh: Record the major cut revision for probed SH-4A parts.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index db442f37852d..2e42572b1b11 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -50,23 +50,24 @@ int __init detect_cpu_and_cache_system(void)
 	boot_cpu_data.dcache.ways		= 1;
 	boot_cpu_data.dcache.linesz		= L1_CACHE_BYTES;
 
+	/* We don't know the chip cut */
+	boot_cpu_data.cut_major = boot_cpu_data.cut_minor = -1;
+
 	/*
 	 * Setup some generic flags we can probe on SH-4A parts
 	 */
-	if (((pvr >> 24) & 0xff) == 0x10) {
+	if (((pvr >> 16) & 0xff) == 0x10) {
 		if ((cvr & 0x10000000) == 0)
 			boot_cpu_data.flags |= CPU_HAS_DSP;
 
 		boot_cpu_data.flags |= CPU_HAS_LLSC;
+		boot_cpu_data.cut_major = pvr & 0x7f;
 	}
 
 	/* FPU detection works for everyone */
 	if ((cvr & 0x20000000) == 1)
 		boot_cpu_data.flags |= CPU_HAS_FPU;
 
-	/* We don't know the chip cut */
-	boot_cpu_data.cut_major = boot_cpu_data.cut_minor = -1;
-
 	/* Mask off the upper chip ID */
 	pvr &= 0xffff;
 

commit 3611ee7acc113e5e482b7d20d5133935226f3129
Author: Stuart Menefy <stuart.menefy@st.com>
Date:   Wed Jul 2 15:15:09 2008 +0900

    sh: Stub in silicon cut in CPU info.
    
    Signed-off-by: Stuart Menefy <stuart.menefy@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index be4926969181..db442f37852d 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -64,6 +64,9 @@ int __init detect_cpu_and_cache_system(void)
 	if ((cvr & 0x20000000) == 1)
 		boot_cpu_data.flags |= CPU_HAS_FPU;
 
+	/* We don't know the chip cut */
+	boot_cpu_data.cut_major = boot_cpu_data.cut_minor = -1;
+
 	/* Mask off the upper chip ID */
 	pvr &= 0xffff;
 

commit b76baf4cf5978efeabf5a3e054551e40ef599b69
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Thu May 22 22:24:51 2008 +0900

    sh: add probe support for new sh7723 cut
    
    This patch adds support for sh7723 silicon with a prr value of 0x51.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index ebceb0dadff5..be4926969181 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -132,6 +132,7 @@ int __init detect_cpu_and_cache_system(void)
 
 		switch (prr) {
 		case 0x50:
+		case 0x51:
 			boot_cpu_data.type = CPU_SH7723;
 			boot_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_L2_CACHE;
 			break;

commit 440fc172ae333c52c458401fe059afcc6e91eebf
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Apr 9 17:58:22 2008 +0900

    sh: Fix up L2 cache probe.
    
    SH7723 is the first hard silicon to implement the L2, and unsurprisingly,
    does the precise inverse of what the specification alleges. XOR the
    URAM/L2 size bits to get back in line with the existing parsing logic.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 6ea87af7247e..ebceb0dadff5 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -220,6 +220,12 @@ int __init detect_cpu_and_cache_system(void)
 	 * SH-4A's have an optional PIPT L2.
 	 */
 	if (boot_cpu_data.flags & CPU_HAS_L2_CACHE) {
+		/* Bug if we can't decode the L2 info */
+		BUG_ON(!(cvr & 0xf));
+
+		/* Silicon and specifications have clearly never met.. */
+		cvr ^= 0xf;
+
 		/*
 		 * Size calculation is much more sensible
 		 * than it is for the L1.

commit e5a4c65bef19366112ba002bc06d87450f02ad74
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Apr 9 17:57:05 2008 +0900

    sh: Fix up SH-4A part probe.
    
    The SH-4A series probe we were relying on doesn't work any more on the
    newer parts, bump this up to use CVR.CHIP instead so we have consistent
    behaviour across all of the parts, which is what this should have been
    testing in the first place.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index c478b16dbf4b..6ea87af7247e 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -53,7 +53,7 @@ int __init detect_cpu_and_cache_system(void)
 	/*
 	 * Setup some generic flags we can probe on SH-4A parts
 	 */
-	if (((pvr >> 16) & 0xff) == 0x10) {
+	if (((pvr >> 24) & 0xff) == 0x10) {
 		if ((cvr & 0x10000000) == 0)
 			boot_cpu_data.flags |= CPU_HAS_DSP;
 

commit 178dd0cd28168287a0be6444a7eef8918b6c544e
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Apr 9 17:56:18 2008 +0900

    sh: Add support for SH7723 CPU subtype.
    
    This adds basic support for the SH7723 MobileR2 CPU.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 9e89984c4f1d..c478b16dbf4b 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -126,17 +126,22 @@ int __init detect_cpu_and_cache_system(void)
 					  CPU_HAS_LLSC;
 		break;
 	case 0x3008:
-		if (prr == 0xa0 || prr == 0xa1) {
-			boot_cpu_data.type = CPU_SH7722;
-			boot_cpu_data.icache.ways = 4;
-			boot_cpu_data.dcache.ways = 4;
-			boot_cpu_data.flags |= CPU_HAS_LLSC;
-		}
-		else if (prr == 0x70) {
+		boot_cpu_data.icache.ways = 4;
+		boot_cpu_data.dcache.ways = 4;
+		boot_cpu_data.flags |= CPU_HAS_LLSC;
+
+		switch (prr) {
+		case 0x50:
+			boot_cpu_data.type = CPU_SH7723;
+			boot_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_L2_CACHE;
+			break;
+		case 0x70:
 			boot_cpu_data.type = CPU_SH7366;
-			boot_cpu_data.icache.ways = 4;
-			boot_cpu_data.dcache.ways = 4;
-			boot_cpu_data.flags |= CPU_HAS_LLSC;
+			break;
+		case 0xa0:
+		case 0xa1:
+			boot_cpu_data.type = CPU_SH7722;
+			break;
 		}
 		break;
 	case 0x4000:	/* 1st cut */

commit 9109a30e5a548b39463b5a777943cf103da507af
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Fri Feb 8 17:31:24 2008 +0900

    sh: add support for sh7366 processor
    
    This patch adds sh7366 cpu supports. Just the most basic things like interrupt
    controller, clocks and serial port are included at this point.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 89b454b1f0f1..9e89984c4f1d 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -132,6 +132,12 @@ int __init detect_cpu_and_cache_system(void)
 			boot_cpu_data.dcache.ways = 4;
 			boot_cpu_data.flags |= CPU_HAS_LLSC;
 		}
+		else if (prr == 0x70) {
+			boot_cpu_data.type = CPU_SH7366;
+			boot_cpu_data.icache.ways = 4;
+			boot_cpu_data.dcache.ways = 4;
+			boot_cpu_data.flags |= CPU_HAS_LLSC;
+		}
 		break;
 	case 0x4000:	/* 1st cut */
 	case 0x4001:	/* 2nd cut */

commit 1cfb629cfa4a8d9b65c0f60c65ec731bde82d60c
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Wed Feb 6 23:57:57 2008 +0900

    sh: add probe support for new sh7722 cut
    
    This patch adds support for sh7722 devices with prr value 0xa1.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index f2b9238cda04..89b454b1f0f1 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -126,7 +126,7 @@ int __init detect_cpu_and_cache_system(void)
 					  CPU_HAS_LLSC;
 		break;
 	case 0x3008:
-		if (prr == 0xa0) {
+		if (prr == 0xa0 || prr == 0xa1) {
 			boot_cpu_data.type = CPU_SH7722;
 			boot_cpu_data.icache.ways = 4;
 			boot_cpu_data.dcache.ways = 4;

commit 7d740a066fb9c6681c2898c7977209725c9e552f
Author: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
Date:   Mon Jan 7 14:40:07 2008 +0900

    sh: Add support for SH7763 CPU subtype.
    
    Signed-off-by: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index bc9c28a69bf1..f2b9238cda04 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -98,6 +98,8 @@ int __init detect_cpu_and_cache_system(void)
 	case 0x200A:
 		if (prr == 0x61)
 			boot_cpu_data.type = CPU_SH7781;
+		else if (prr == 0xa1)
+			boot_cpu_data.type = CPU_SH7763;
 		else
 			boot_cpu_data.type = CPU_SH7780;
 

commit f96691872439ab2071171d4531c4a95b5d493ae5
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Nov 7 11:05:32 2007 +0900

    sh: Kill off the remaining ST40 cruft.
    
    The ST40 stuff in-tree hasn't built for some time, and hasn't been
    updated for over 3 years. ST maintains their own out-of-tree changes
    and rebases occasionally, and that's ultimately where all of the ST40
    users go anyways.
    
    In order for the ST40 code to be brought up to date most of the stuff
    removed in this changeset would have to be rewritten anyways, so there's
    very little benefit in keeping the remnants around either.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 21375d777e99..bc9c28a69bf1 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -139,14 +139,6 @@ int __init detect_cpu_and_cache_system(void)
 		boot_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER |
 					  CPU_HAS_LLSC;
 		break;
-	case 0x8000:
-		boot_cpu_data.type = CPU_ST40RA;
-		boot_cpu_data.flags |= CPU_HAS_FPU;
-		break;
-	case 0x8100:
-		boot_cpu_data.type = CPU_ST40GX1;
-		boot_cpu_data.flags |= CPU_HAS_FPU;
-		break;
 	case 0x700:
 		boot_cpu_data.type = CPU_SH4_501;
 		boot_cpu_data.icache.ways = 2;

commit cb7af21f7d370edb3a6a6d3e15cb17c8fd61591e
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Sep 27 18:18:39 2007 +0900

    sh: Use boot_cpu_data for CPU probe.
    
    This moves off of smp_processor_id() and only sets the probe
    information for the boot CPU directly. This will be copied out
    for the secondaries, so there's no reason to do this each time.
    
    This also allows for some header tidying.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 8f318a4fe722..21375d777e99 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -12,7 +12,6 @@
  */
 #include <linux/init.h>
 #include <linux/io.h>
-#include <linux/smp.h>
 #include <asm/processor.h>
 #include <asm/cache.h>
 
@@ -36,34 +35,34 @@ int __init detect_cpu_and_cache_system(void)
 	/*
 	 * Setup some sane SH-4 defaults for the icache
 	 */
-	current_cpu_data.icache.way_incr	= (1 << 13);
-	current_cpu_data.icache.entry_shift	= 5;
-	current_cpu_data.icache.sets		= 256;
-	current_cpu_data.icache.ways		= 1;
-	current_cpu_data.icache.linesz		= L1_CACHE_BYTES;
+	boot_cpu_data.icache.way_incr		= (1 << 13);
+	boot_cpu_data.icache.entry_shift	= 5;
+	boot_cpu_data.icache.sets		= 256;
+	boot_cpu_data.icache.ways		= 1;
+	boot_cpu_data.icache.linesz		= L1_CACHE_BYTES;
 
 	/*
 	 * And again for the dcache ..
 	 */
-	current_cpu_data.dcache.way_incr	= (1 << 14);
-	current_cpu_data.dcache.entry_shift	= 5;
-	current_cpu_data.dcache.sets		= 512;
-	current_cpu_data.dcache.ways		= 1;
-	current_cpu_data.dcache.linesz		= L1_CACHE_BYTES;
+	boot_cpu_data.dcache.way_incr		= (1 << 14);
+	boot_cpu_data.dcache.entry_shift	= 5;
+	boot_cpu_data.dcache.sets		= 512;
+	boot_cpu_data.dcache.ways		= 1;
+	boot_cpu_data.dcache.linesz		= L1_CACHE_BYTES;
 
 	/*
 	 * Setup some generic flags we can probe on SH-4A parts
 	 */
 	if (((pvr >> 16) & 0xff) == 0x10) {
 		if ((cvr & 0x10000000) == 0)
-			current_cpu_data.flags |= CPU_HAS_DSP;
+			boot_cpu_data.flags |= CPU_HAS_DSP;
 
-		current_cpu_data.flags |= CPU_HAS_LLSC;
+		boot_cpu_data.flags |= CPU_HAS_LLSC;
 	}
 
 	/* FPU detection works for everyone */
 	if ((cvr & 0x20000000) == 1)
-		current_cpu_data.flags |= CPU_HAS_FPU;
+		boot_cpu_data.flags |= CPU_HAS_FPU;
 
 	/* Mask off the upper chip ID */
 	pvr &= 0xffff;
@@ -74,140 +73,140 @@ int __init detect_cpu_and_cache_system(void)
 	 */
 	switch (pvr) {
 	case 0x205:
-		current_cpu_data.type = CPU_SH7750;
-		current_cpu_data.flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_FPU |
+		boot_cpu_data.type = CPU_SH7750;
+		boot_cpu_data.flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_FPU |
 				   CPU_HAS_PERF_COUNTER;
 		break;
 	case 0x206:
-		current_cpu_data.type = CPU_SH7750S;
-		current_cpu_data.flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_FPU |
+		boot_cpu_data.type = CPU_SH7750S;
+		boot_cpu_data.flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_FPU |
 				   CPU_HAS_PERF_COUNTER;
 		break;
 	case 0x1100:
-		current_cpu_data.type = CPU_SH7751;
-		current_cpu_data.flags |= CPU_HAS_FPU;
+		boot_cpu_data.type = CPU_SH7751;
+		boot_cpu_data.flags |= CPU_HAS_FPU;
 		break;
 	case 0x2001:
 	case 0x2004:
-		current_cpu_data.type = CPU_SH7770;
-		current_cpu_data.icache.ways = 4;
-		current_cpu_data.dcache.ways = 4;
+		boot_cpu_data.type = CPU_SH7770;
+		boot_cpu_data.icache.ways = 4;
+		boot_cpu_data.dcache.ways = 4;
 
-		current_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_LLSC;
+		boot_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_LLSC;
 		break;
 	case 0x2006:
 	case 0x200A:
 		if (prr == 0x61)
-			current_cpu_data.type = CPU_SH7781;
+			boot_cpu_data.type = CPU_SH7781;
 		else
-			current_cpu_data.type = CPU_SH7780;
+			boot_cpu_data.type = CPU_SH7780;
 
-		current_cpu_data.icache.ways = 4;
-		current_cpu_data.dcache.ways = 4;
+		boot_cpu_data.icache.ways = 4;
+		boot_cpu_data.dcache.ways = 4;
 
-		current_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER |
+		boot_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER |
 				   CPU_HAS_LLSC;
 		break;
 	case 0x3000:
 	case 0x3003:
 	case 0x3009:
-		current_cpu_data.type = CPU_SH7343;
-		current_cpu_data.icache.ways = 4;
-		current_cpu_data.dcache.ways = 4;
-		current_cpu_data.flags |= CPU_HAS_LLSC;
+		boot_cpu_data.type = CPU_SH7343;
+		boot_cpu_data.icache.ways = 4;
+		boot_cpu_data.dcache.ways = 4;
+		boot_cpu_data.flags |= CPU_HAS_LLSC;
 		break;
 	case 0x3004:
 	case 0x3007:
-		current_cpu_data.type = CPU_SH7785;
-		current_cpu_data.icache.ways = 4;
-		current_cpu_data.dcache.ways = 4;
-		current_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER |
+		boot_cpu_data.type = CPU_SH7785;
+		boot_cpu_data.icache.ways = 4;
+		boot_cpu_data.dcache.ways = 4;
+		boot_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER |
 					  CPU_HAS_LLSC;
 		break;
 	case 0x3008:
 		if (prr == 0xa0) {
-			current_cpu_data.type = CPU_SH7722;
-			current_cpu_data.icache.ways = 4;
-			current_cpu_data.dcache.ways = 4;
-			current_cpu_data.flags |= CPU_HAS_LLSC;
+			boot_cpu_data.type = CPU_SH7722;
+			boot_cpu_data.icache.ways = 4;
+			boot_cpu_data.dcache.ways = 4;
+			boot_cpu_data.flags |= CPU_HAS_LLSC;
 		}
 		break;
 	case 0x4000:	/* 1st cut */
 	case 0x4001:	/* 2nd cut */
-		current_cpu_data.type = CPU_SHX3;
-		current_cpu_data.icache.ways = 4;
-		current_cpu_data.dcache.ways = 4;
-		current_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER |
+		boot_cpu_data.type = CPU_SHX3;
+		boot_cpu_data.icache.ways = 4;
+		boot_cpu_data.dcache.ways = 4;
+		boot_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER |
 					  CPU_HAS_LLSC;
 		break;
 	case 0x8000:
-		current_cpu_data.type = CPU_ST40RA;
-		current_cpu_data.flags |= CPU_HAS_FPU;
+		boot_cpu_data.type = CPU_ST40RA;
+		boot_cpu_data.flags |= CPU_HAS_FPU;
 		break;
 	case 0x8100:
-		current_cpu_data.type = CPU_ST40GX1;
-		current_cpu_data.flags |= CPU_HAS_FPU;
+		boot_cpu_data.type = CPU_ST40GX1;
+		boot_cpu_data.flags |= CPU_HAS_FPU;
 		break;
 	case 0x700:
-		current_cpu_data.type = CPU_SH4_501;
-		current_cpu_data.icache.ways = 2;
-		current_cpu_data.dcache.ways = 2;
+		boot_cpu_data.type = CPU_SH4_501;
+		boot_cpu_data.icache.ways = 2;
+		boot_cpu_data.dcache.ways = 2;
 		break;
 	case 0x600:
-		current_cpu_data.type = CPU_SH4_202;
-		current_cpu_data.icache.ways = 2;
-		current_cpu_data.dcache.ways = 2;
-		current_cpu_data.flags |= CPU_HAS_FPU;
+		boot_cpu_data.type = CPU_SH4_202;
+		boot_cpu_data.icache.ways = 2;
+		boot_cpu_data.dcache.ways = 2;
+		boot_cpu_data.flags |= CPU_HAS_FPU;
 		break;
 	case 0x500 ... 0x501:
 		switch (prr) {
 		case 0x10:
-			current_cpu_data.type = CPU_SH7750R;
+			boot_cpu_data.type = CPU_SH7750R;
 			break;
 		case 0x11:
-			current_cpu_data.type = CPU_SH7751R;
+			boot_cpu_data.type = CPU_SH7751R;
 			break;
 		case 0x50 ... 0x5f:
-			current_cpu_data.type = CPU_SH7760;
+			boot_cpu_data.type = CPU_SH7760;
 			break;
 		}
 
-		current_cpu_data.icache.ways = 2;
-		current_cpu_data.dcache.ways = 2;
+		boot_cpu_data.icache.ways = 2;
+		boot_cpu_data.dcache.ways = 2;
 
-		current_cpu_data.flags |= CPU_HAS_FPU;
+		boot_cpu_data.flags |= CPU_HAS_FPU;
 
 		break;
 	default:
-		current_cpu_data.type = CPU_SH_NONE;
+		boot_cpu_data.type = CPU_SH_NONE;
 		break;
 	}
 
 #ifdef CONFIG_SH_DIRECT_MAPPED
-	current_cpu_data.icache.ways = 1;
-	current_cpu_data.dcache.ways = 1;
+	boot_cpu_data.icache.ways = 1;
+	boot_cpu_data.dcache.ways = 1;
 #endif
 
 #ifdef CONFIG_CPU_HAS_PTEA
-	current_cpu_data.flags |= CPU_HAS_PTEA;
+	boot_cpu_data.flags |= CPU_HAS_PTEA;
 #endif
 
 	/*
 	 * On anything that's not a direct-mapped cache, look to the CVR
 	 * for I/D-cache specifics.
 	 */
-	if (current_cpu_data.icache.ways > 1) {
+	if (boot_cpu_data.icache.ways > 1) {
 		size = sizes[(cvr >> 20) & 0xf];
-		current_cpu_data.icache.way_incr	= (size >> 1);
-		current_cpu_data.icache.sets		= (size >> 6);
+		boot_cpu_data.icache.way_incr	= (size >> 1);
+		boot_cpu_data.icache.sets	= (size >> 6);
 
 	}
 
 	/* And the rest of the D-cache */
-	if (current_cpu_data.dcache.ways > 1) {
+	if (boot_cpu_data.dcache.ways > 1) {
 		size = sizes[(cvr >> 16) & 0xf];
-		current_cpu_data.dcache.way_incr	= (size >> 1);
-		current_cpu_data.dcache.sets		= (size >> 6);
+		boot_cpu_data.dcache.way_incr	= (size >> 1);
+		boot_cpu_data.dcache.sets	= (size >> 6);
 	}
 
 	/*
@@ -215,7 +214,7 @@ int __init detect_cpu_and_cache_system(void)
 	 *
 	 * SH-4A's have an optional PIPT L2.
 	 */
-	if (current_cpu_data.flags & CPU_HAS_L2_CACHE) {
+	if (boot_cpu_data.flags & CPU_HAS_L2_CACHE) {
 		/*
 		 * Size calculation is much more sensible
 		 * than it is for the L1.
@@ -226,22 +225,22 @@ int __init detect_cpu_and_cache_system(void)
 
 		BUG_ON(!size);
 
-		current_cpu_data.scache.way_incr	= (1 << 16);
-		current_cpu_data.scache.entry_shift	= 5;
-		current_cpu_data.scache.ways		= 4;
-		current_cpu_data.scache.linesz		= L1_CACHE_BYTES;
+		boot_cpu_data.scache.way_incr		= (1 << 16);
+		boot_cpu_data.scache.entry_shift	= 5;
+		boot_cpu_data.scache.ways		= 4;
+		boot_cpu_data.scache.linesz		= L1_CACHE_BYTES;
 
-		current_cpu_data.scache.entry_mask	=
-			(current_cpu_data.scache.way_incr -
-			 current_cpu_data.scache.linesz);
+		boot_cpu_data.scache.entry_mask	=
+			(boot_cpu_data.scache.way_incr -
+			 boot_cpu_data.scache.linesz);
 
-		current_cpu_data.scache.sets		= size /
-			(current_cpu_data.scache.linesz *
-			 current_cpu_data.scache.ways);
+		boot_cpu_data.scache.sets	= size /
+			(boot_cpu_data.scache.linesz *
+			 boot_cpu_data.scache.ways);
 
-		current_cpu_data.scache.way_size	=
-			(current_cpu_data.scache.sets *
-			 current_cpu_data.scache.linesz);
+		boot_cpu_data.scache.way_size	=
+			(boot_cpu_data.scache.sets *
+			 boot_cpu_data.scache.linesz);
 	}
 
 	return 0;

commit 26fad19d8c3ca9abd7ffb85a63f8e25f1b4910dc
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Sep 27 10:29:58 2007 +0900

    sh: Disable L2 reporting for present URAM only parts.
    
    The probing logic works for both URAM and L2, with no way to
    distinguish between the two. Disable the probing for now and
    let the CPU subtypes that have this in a real L2 configuration
    explicitly say so.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 98d28fb1ce16..8f318a4fe722 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -3,7 +3,7 @@
  *
  * CPU Subtype Probing for SH-4.
  *
- * Copyright (C) 2001 - 2006  Paul Mundt
+ * Copyright (C) 2001 - 2007  Paul Mundt
  * Copyright (C) 2003  Richard Curnow
  *
  * This file is subject to the terms and conditions of the GNU General Public
@@ -52,12 +52,9 @@ int __init detect_cpu_and_cache_system(void)
 	current_cpu_data.dcache.linesz		= L1_CACHE_BYTES;
 
 	/*
-	 * Setup some generic flags we can probe
-	 * (L2 and DSP detection only work on SH-4A)
+	 * Setup some generic flags we can probe on SH-4A parts
 	 */
 	if (((pvr >> 16) & 0xff) == 0x10) {
-		if ((cvr & 0x02000000) == 0)
-			current_cpu_data.flags |= CPU_HAS_L2_CACHE;
 		if ((cvr & 0x10000000) == 0)
 			current_cpu_data.flags |= CPU_HAS_DSP;
 

commit 870e8a24380cf1854dc1bb5fa5abebb44d82674b
Author: Magnus Damm <damm@igel.co.jp>
Date:   Wed Jul 25 10:49:21 2007 +0900

    sh: remove support for sh73180 and solution engine 73180
    
    This patch removes old dead code:
    - kill off sh73180 cpu support
    - get rid of broken solution engine 73180 board support
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 66c3f75647b2..98d28fb1ce16 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -90,12 +90,6 @@ int __init detect_cpu_and_cache_system(void)
 		current_cpu_data.type = CPU_SH7751;
 		current_cpu_data.flags |= CPU_HAS_FPU;
 		break;
-	case 0x2000:
-		current_cpu_data.type = CPU_SH73180;
-		current_cpu_data.icache.ways = 4;
-		current_cpu_data.dcache.ways = 4;
-		current_cpu_data.flags |= CPU_HAS_LLSC;
-		break;
 	case 0x2001:
 	case 0x2004:
 		current_cpu_data.type = CPU_SH7770;

commit 2b1bd1ac5d4bffe3fd542bfe1784a583bd7df4fa
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Jun 20 18:27:10 2007 +0900

    sh: Preliminary support for the SH-X3 CPU.
    
    This adds basic support for UP SH-X3.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index fab2eb07196b..66c3f75647b2 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -141,6 +141,14 @@ int __init detect_cpu_and_cache_system(void)
 			current_cpu_data.flags |= CPU_HAS_LLSC;
 		}
 		break;
+	case 0x4000:	/* 1st cut */
+	case 0x4001:	/* 2nd cut */
+		current_cpu_data.type = CPU_SHX3;
+		current_cpu_data.icache.ways = 4;
+		current_cpu_data.dcache.ways = 4;
+		current_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER |
+					  CPU_HAS_LLSC;
+		break;
 	case 0x8000:
 		current_cpu_data.type = CPU_ST40RA;
 		current_cpu_data.flags |= CPU_HAS_FPU;

commit 66c5227ecd3041b0467a091ad81b8d312e572ea8
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Thu May 31 13:46:21 2007 +0900

    sh: trivial build cleanups.
    
    Several errors were spotted during building for custom config (SMP
    included). Although SMP still does not compile (no ipi and
    __smp_call_function) and does not work, this looks a bit cleaner.
    Some other errors obtained via gcc-4.1.0 build.
    
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 8cd04904c77a..fab2eb07196b 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -12,6 +12,7 @@
  */
 #include <linux/init.h>
 #include <linux/io.h>
+#include <linux/smp.h>
 #include <asm/processor.h>
 #include <asm/cache.h>
 

commit 32351a28a7e1f2c68afbe559dd35e1ad0301be6d
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Mar 12 14:38:59 2007 +0900

    sh: Add SH7785 Highlander board support (R7785RP).
    
    This adds preliminary support for the SH7785-based Highlander board.
    Some of the Highlander support code is reordered so that most of it
    can be reused directly.
    
    This also plugs in missing SH7785 checks in the places that need it,
    as this is the first board to support the CPU.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 58950de2696d..8cd04904c77a 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -124,6 +124,14 @@ int __init detect_cpu_and_cache_system(void)
 		current_cpu_data.dcache.ways = 4;
 		current_cpu_data.flags |= CPU_HAS_LLSC;
 		break;
+	case 0x3004:
+	case 0x3007:
+		current_cpu_data.type = CPU_SH7785;
+		current_cpu_data.icache.ways = 4;
+		current_cpu_data.dcache.ways = 4;
+		current_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER |
+					  CPU_HAS_LLSC;
+		break;
 	case 0x3008:
 		if (prr == 0xa0) {
 			current_cpu_data.type = CPU_SH7722;

commit ffe1b4e9f436fd7bb784f3bf7ee963c149fbca5f
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Mar 12 16:15:22 2007 +0900

    sh: Fix SH-3 cache entry_mask and way_size calculation.
    
    The code for performing the calculation was only in the SH-4 probe
    path, move it out to the common path so the other parts get this
    right too.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 9d28c88d2f9d..58950de2696d 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -195,13 +195,6 @@ int __init detect_cpu_and_cache_system(void)
 
 	}
 
-	/* Setup the rest of the I-cache info */
-	current_cpu_data.icache.entry_mask = current_cpu_data.icache.way_incr -
-				      current_cpu_data.icache.linesz;
-
-	current_cpu_data.icache.way_size = current_cpu_data.icache.sets *
-				    current_cpu_data.icache.linesz;
-
 	/* And the rest of the D-cache */
 	if (current_cpu_data.dcache.ways > 1) {
 		size = sizes[(cvr >> 16) & 0xf];
@@ -209,12 +202,6 @@ int __init detect_cpu_and_cache_system(void)
 		current_cpu_data.dcache.sets		= (size >> 6);
 	}
 
-	current_cpu_data.dcache.entry_mask = current_cpu_data.dcache.way_incr -
-				      current_cpu_data.dcache.linesz;
-
-	current_cpu_data.dcache.way_size = current_cpu_data.dcache.sets *
-				    current_cpu_data.dcache.linesz;
-
 	/*
 	 * Setup the L2 cache desc
 	 *

commit 11c1965687b0a472add948d4240dfe65a2fcb298
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Dec 25 10:19:56 2006 +0900

    sh: Fixup cpu_data references for the non-boot CPUs.
    
    There are a lot of bogus cpu_data-> references that only end up working
    for the boot CPU, convert these to current_cpu_data to fixup SMP.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index b26e2bc5894d..9d28c88d2f9d 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -10,11 +10,10 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  */
-
 #include <linux/init.h>
+#include <linux/io.h>
 #include <asm/processor.h>
 #include <asm/cache.h>
-#include <asm/io.h>
 
 int __init detect_cpu_and_cache_system(void)
 {
@@ -36,20 +35,20 @@ int __init detect_cpu_and_cache_system(void)
 	/*
 	 * Setup some sane SH-4 defaults for the icache
 	 */
-	cpu_data->icache.way_incr	= (1 << 13);
-	cpu_data->icache.entry_shift	= 5;
-	cpu_data->icache.sets		= 256;
-	cpu_data->icache.ways		= 1;
-	cpu_data->icache.linesz		= L1_CACHE_BYTES;
+	current_cpu_data.icache.way_incr	= (1 << 13);
+	current_cpu_data.icache.entry_shift	= 5;
+	current_cpu_data.icache.sets		= 256;
+	current_cpu_data.icache.ways		= 1;
+	current_cpu_data.icache.linesz		= L1_CACHE_BYTES;
 
 	/*
 	 * And again for the dcache ..
 	 */
-	cpu_data->dcache.way_incr	= (1 << 14);
-	cpu_data->dcache.entry_shift	= 5;
-	cpu_data->dcache.sets		= 512;
-	cpu_data->dcache.ways		= 1;
-	cpu_data->dcache.linesz		= L1_CACHE_BYTES;
+	current_cpu_data.dcache.way_incr	= (1 << 14);
+	current_cpu_data.dcache.entry_shift	= 5;
+	current_cpu_data.dcache.sets		= 512;
+	current_cpu_data.dcache.ways		= 1;
+	current_cpu_data.dcache.linesz		= L1_CACHE_BYTES;
 
 	/*
 	 * Setup some generic flags we can probe
@@ -57,16 +56,16 @@ int __init detect_cpu_and_cache_system(void)
 	 */
 	if (((pvr >> 16) & 0xff) == 0x10) {
 		if ((cvr & 0x02000000) == 0)
-			cpu_data->flags |= CPU_HAS_L2_CACHE;
+			current_cpu_data.flags |= CPU_HAS_L2_CACHE;
 		if ((cvr & 0x10000000) == 0)
-			cpu_data->flags |= CPU_HAS_DSP;
+			current_cpu_data.flags |= CPU_HAS_DSP;
 
-		cpu_data->flags |= CPU_HAS_LLSC;
+		current_cpu_data.flags |= CPU_HAS_LLSC;
 	}
 
 	/* FPU detection works for everyone */
 	if ((cvr & 0x20000000) == 1)
-		cpu_data->flags |= CPU_HAS_FPU;
+		current_cpu_data.flags |= CPU_HAS_FPU;
 
 	/* Mask off the upper chip ID */
 	pvr &= 0xffff;
@@ -77,147 +76,151 @@ int __init detect_cpu_and_cache_system(void)
 	 */
 	switch (pvr) {
 	case 0x205:
-		cpu_data->type = CPU_SH7750;
-		cpu_data->flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_FPU |
+		current_cpu_data.type = CPU_SH7750;
+		current_cpu_data.flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_FPU |
 				   CPU_HAS_PERF_COUNTER;
 		break;
 	case 0x206:
-		cpu_data->type = CPU_SH7750S;
-		cpu_data->flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_FPU |
+		current_cpu_data.type = CPU_SH7750S;
+		current_cpu_data.flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_FPU |
 				   CPU_HAS_PERF_COUNTER;
 		break;
 	case 0x1100:
-		cpu_data->type = CPU_SH7751;
-		cpu_data->flags |= CPU_HAS_FPU;
+		current_cpu_data.type = CPU_SH7751;
+		current_cpu_data.flags |= CPU_HAS_FPU;
 		break;
 	case 0x2000:
-		cpu_data->type = CPU_SH73180;
-		cpu_data->icache.ways = 4;
-		cpu_data->dcache.ways = 4;
-		cpu_data->flags |= CPU_HAS_LLSC;
+		current_cpu_data.type = CPU_SH73180;
+		current_cpu_data.icache.ways = 4;
+		current_cpu_data.dcache.ways = 4;
+		current_cpu_data.flags |= CPU_HAS_LLSC;
 		break;
 	case 0x2001:
 	case 0x2004:
-		cpu_data->type = CPU_SH7770;
-		cpu_data->icache.ways = 4;
-		cpu_data->dcache.ways = 4;
+		current_cpu_data.type = CPU_SH7770;
+		current_cpu_data.icache.ways = 4;
+		current_cpu_data.dcache.ways = 4;
 
-		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_LLSC;
+		current_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_LLSC;
 		break;
 	case 0x2006:
 	case 0x200A:
 		if (prr == 0x61)
-			cpu_data->type = CPU_SH7781;
+			current_cpu_data.type = CPU_SH7781;
 		else
-			cpu_data->type = CPU_SH7780;
+			current_cpu_data.type = CPU_SH7780;
 
-		cpu_data->icache.ways = 4;
-		cpu_data->dcache.ways = 4;
+		current_cpu_data.icache.ways = 4;
+		current_cpu_data.dcache.ways = 4;
 
-		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER |
+		current_cpu_data.flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER |
 				   CPU_HAS_LLSC;
 		break;
 	case 0x3000:
 	case 0x3003:
 	case 0x3009:
-		cpu_data->type = CPU_SH7343;
-		cpu_data->icache.ways = 4;
-		cpu_data->dcache.ways = 4;
-		cpu_data->flags |= CPU_HAS_LLSC;
+		current_cpu_data.type = CPU_SH7343;
+		current_cpu_data.icache.ways = 4;
+		current_cpu_data.dcache.ways = 4;
+		current_cpu_data.flags |= CPU_HAS_LLSC;
 		break;
 	case 0x3008:
 		if (prr == 0xa0) {
-			cpu_data->type = CPU_SH7722;
-			cpu_data->icache.ways = 4;
-			cpu_data->dcache.ways = 4;
-			cpu_data->flags |= CPU_HAS_LLSC;
+			current_cpu_data.type = CPU_SH7722;
+			current_cpu_data.icache.ways = 4;
+			current_cpu_data.dcache.ways = 4;
+			current_cpu_data.flags |= CPU_HAS_LLSC;
 		}
 		break;
 	case 0x8000:
-		cpu_data->type = CPU_ST40RA;
-		cpu_data->flags |= CPU_HAS_FPU;
+		current_cpu_data.type = CPU_ST40RA;
+		current_cpu_data.flags |= CPU_HAS_FPU;
 		break;
 	case 0x8100:
-		cpu_data->type = CPU_ST40GX1;
-		cpu_data->flags |= CPU_HAS_FPU;
+		current_cpu_data.type = CPU_ST40GX1;
+		current_cpu_data.flags |= CPU_HAS_FPU;
 		break;
 	case 0x700:
-		cpu_data->type = CPU_SH4_501;
-		cpu_data->icache.ways = 2;
-		cpu_data->dcache.ways = 2;
+		current_cpu_data.type = CPU_SH4_501;
+		current_cpu_data.icache.ways = 2;
+		current_cpu_data.dcache.ways = 2;
 		break;
 	case 0x600:
-		cpu_data->type = CPU_SH4_202;
-		cpu_data->icache.ways = 2;
-		cpu_data->dcache.ways = 2;
-		cpu_data->flags |= CPU_HAS_FPU;
+		current_cpu_data.type = CPU_SH4_202;
+		current_cpu_data.icache.ways = 2;
+		current_cpu_data.dcache.ways = 2;
+		current_cpu_data.flags |= CPU_HAS_FPU;
 		break;
 	case 0x500 ... 0x501:
 		switch (prr) {
 		case 0x10:
-			cpu_data->type = CPU_SH7750R;
+			current_cpu_data.type = CPU_SH7750R;
 			break;
 		case 0x11:
-			cpu_data->type = CPU_SH7751R;
+			current_cpu_data.type = CPU_SH7751R;
 			break;
 		case 0x50 ... 0x5f:
-			cpu_data->type = CPU_SH7760;
+			current_cpu_data.type = CPU_SH7760;
 			break;
 		}
 
-		cpu_data->icache.ways = 2;
-		cpu_data->dcache.ways = 2;
+		current_cpu_data.icache.ways = 2;
+		current_cpu_data.dcache.ways = 2;
 
-		cpu_data->flags |= CPU_HAS_FPU;
+		current_cpu_data.flags |= CPU_HAS_FPU;
 
 		break;
 	default:
-		cpu_data->type = CPU_SH_NONE;
+		current_cpu_data.type = CPU_SH_NONE;
 		break;
 	}
 
 #ifdef CONFIG_SH_DIRECT_MAPPED
-	cpu_data->icache.ways = 1;
-	cpu_data->dcache.ways = 1;
+	current_cpu_data.icache.ways = 1;
+	current_cpu_data.dcache.ways = 1;
+#endif
+
+#ifdef CONFIG_CPU_HAS_PTEA
+	current_cpu_data.flags |= CPU_HAS_PTEA;
 #endif
 
 	/*
 	 * On anything that's not a direct-mapped cache, look to the CVR
 	 * for I/D-cache specifics.
 	 */
-	if (cpu_data->icache.ways > 1) {
+	if (current_cpu_data.icache.ways > 1) {
 		size = sizes[(cvr >> 20) & 0xf];
-		cpu_data->icache.way_incr	= (size >> 1);
-		cpu_data->icache.sets		= (size >> 6);
+		current_cpu_data.icache.way_incr	= (size >> 1);
+		current_cpu_data.icache.sets		= (size >> 6);
 
 	}
 
 	/* Setup the rest of the I-cache info */
-	cpu_data->icache.entry_mask = cpu_data->icache.way_incr -
-				      cpu_data->icache.linesz;
+	current_cpu_data.icache.entry_mask = current_cpu_data.icache.way_incr -
+				      current_cpu_data.icache.linesz;
 
-	cpu_data->icache.way_size = cpu_data->icache.sets *
-				    cpu_data->icache.linesz;
+	current_cpu_data.icache.way_size = current_cpu_data.icache.sets *
+				    current_cpu_data.icache.linesz;
 
 	/* And the rest of the D-cache */
-	if (cpu_data->dcache.ways > 1) {
+	if (current_cpu_data.dcache.ways > 1) {
 		size = sizes[(cvr >> 16) & 0xf];
-		cpu_data->dcache.way_incr	= (size >> 1);
-		cpu_data->dcache.sets		= (size >> 6);
+		current_cpu_data.dcache.way_incr	= (size >> 1);
+		current_cpu_data.dcache.sets		= (size >> 6);
 	}
 
-	cpu_data->dcache.entry_mask = cpu_data->dcache.way_incr -
-				      cpu_data->dcache.linesz;
+	current_cpu_data.dcache.entry_mask = current_cpu_data.dcache.way_incr -
+				      current_cpu_data.dcache.linesz;
 
-	cpu_data->dcache.way_size = cpu_data->dcache.sets *
-				    cpu_data->dcache.linesz;
+	current_cpu_data.dcache.way_size = current_cpu_data.dcache.sets *
+				    current_cpu_data.dcache.linesz;
 
 	/*
 	 * Setup the L2 cache desc
 	 *
 	 * SH-4A's have an optional PIPT L2.
 	 */
-	if (cpu_data->flags & CPU_HAS_L2_CACHE) {
+	if (current_cpu_data.flags & CPU_HAS_L2_CACHE) {
 		/*
 		 * Size calculation is much more sensible
 		 * than it is for the L1.
@@ -228,16 +231,22 @@ int __init detect_cpu_and_cache_system(void)
 
 		BUG_ON(!size);
 
-		cpu_data->scache.way_incr	= (1 << 16);
-		cpu_data->scache.entry_shift	= 5;
-		cpu_data->scache.ways		= 4;
-		cpu_data->scache.linesz		= L1_CACHE_BYTES;
-		cpu_data->scache.entry_mask	=
-			(cpu_data->scache.way_incr - cpu_data->scache.linesz);
-		cpu_data->scache.sets		= size /
-			(cpu_data->scache.linesz * cpu_data->scache.ways);
-		cpu_data->scache.way_size	=
-			(cpu_data->scache.sets * cpu_data->scache.linesz);
+		current_cpu_data.scache.way_incr	= (1 << 16);
+		current_cpu_data.scache.entry_shift	= 5;
+		current_cpu_data.scache.ways		= 4;
+		current_cpu_data.scache.linesz		= L1_CACHE_BYTES;
+
+		current_cpu_data.scache.entry_mask	=
+			(current_cpu_data.scache.way_incr -
+			 current_cpu_data.scache.linesz);
+
+		current_cpu_data.scache.sets		= size /
+			(current_cpu_data.scache.linesz *
+			 current_cpu_data.scache.ways);
+
+		current_cpu_data.scache.way_size	=
+			(current_cpu_data.scache.sets *
+			 current_cpu_data.scache.linesz);
 	}
 
 	return 0;

commit 26b7a78c55fbc0e23a7dc19e89fd50f200efc002
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Dec 28 10:31:48 2006 +0900

    sh: Lazy dcache writeback optimizations.
    
    This converts the lazy dcache handling to the model described in
    Documentation/cachetlb.txt and drops the ptep_get_and_clear() hacks
    used for the aliasing dcaches on SH-4 and SH7705 in 32kB mode. As a
    bonus, this slightly cuts down on the cache flushing frequency.
    
    With that and the PTEA handling out of the way, the update_mmu_cache()
    implementations can be consolidated, and we no longer have to worry
    about which configuration the cache is in for the SH7705 case.
    
    And finally, explicitly disable the lazy writeback on SMP (SH-4A).
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 9031a22a2ce7..b26e2bc5894d 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -181,10 +181,6 @@ int __init detect_cpu_and_cache_system(void)
 	cpu_data->dcache.ways = 1;
 #endif
 
-#ifdef CONFIG_CPU_HAS_PTEA
-	cpu_data->flags |= CPU_HAS_PTEA;
-#endif
-
 	/*
 	 * On anything that's not a direct-mapped cache, look to the CVR
 	 * for I/D-cache specifics.

commit 41504c39726a7099e5a42508dd57fe561c8b4129
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Dec 11 20:28:03 2006 +0900

    sh: SH-MobileR SH7722 CPU support.
    
    This adds CPU support for the SH7722.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index afe0f1b1c030..9031a22a2ce7 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -119,11 +119,20 @@ int __init detect_cpu_and_cache_system(void)
 		break;
 	case 0x3000:
 	case 0x3003:
+	case 0x3009:
 		cpu_data->type = CPU_SH7343;
 		cpu_data->icache.ways = 4;
 		cpu_data->dcache.ways = 4;
 		cpu_data->flags |= CPU_HAS_LLSC;
 		break;
+	case 0x3008:
+		if (prr == 0xa0) {
+			cpu_data->type = CPU_SH7722;
+			cpu_data->icache.ways = 4;
+			cpu_data->dcache.ways = 4;
+			cpu_data->flags |= CPU_HAS_LLSC;
+		}
+		break;
 	case 0x8000:
 		cpu_data->type = CPU_ST40RA;
 		cpu_data->flags |= CPU_HAS_FPU;

commit 9b3a53ab76771e3669e50086c131e1574fe25847
Author: Stuart Menefy <stuart.menefy@st.com>
Date:   Fri Nov 24 11:42:24 2006 +0900

    sh: TLB miss fast-path optimizations.
    
    Handle simple TLB miss faults which can be resolved completely
    from the page table in assembler.
    
    Signed-off-by: Stuart Menefy <stuart.menefy@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index c294de1e14a3..afe0f1b1c030 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -79,16 +79,16 @@ int __init detect_cpu_and_cache_system(void)
 	case 0x205:
 		cpu_data->type = CPU_SH7750;
 		cpu_data->flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_FPU |
-				   CPU_HAS_PERF_COUNTER | CPU_HAS_PTEA;
+				   CPU_HAS_PERF_COUNTER;
 		break;
 	case 0x206:
 		cpu_data->type = CPU_SH7750S;
 		cpu_data->flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_FPU |
-				   CPU_HAS_PERF_COUNTER | CPU_HAS_PTEA;
+				   CPU_HAS_PERF_COUNTER;
 		break;
 	case 0x1100:
 		cpu_data->type = CPU_SH7751;
-		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PTEA;
+		cpu_data->flags |= CPU_HAS_FPU;
 		break;
 	case 0x2000:
 		cpu_data->type = CPU_SH73180;
@@ -126,23 +126,22 @@ int __init detect_cpu_and_cache_system(void)
 		break;
 	case 0x8000:
 		cpu_data->type = CPU_ST40RA;
-		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PTEA;
+		cpu_data->flags |= CPU_HAS_FPU;
 		break;
 	case 0x8100:
 		cpu_data->type = CPU_ST40GX1;
-		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PTEA;
+		cpu_data->flags |= CPU_HAS_FPU;
 		break;
 	case 0x700:
 		cpu_data->type = CPU_SH4_501;
 		cpu_data->icache.ways = 2;
 		cpu_data->dcache.ways = 2;
-		cpu_data->flags |= CPU_HAS_PTEA;
 		break;
 	case 0x600:
 		cpu_data->type = CPU_SH4_202;
 		cpu_data->icache.ways = 2;
 		cpu_data->dcache.ways = 2;
-		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PTEA;
+		cpu_data->flags |= CPU_HAS_FPU;
 		break;
 	case 0x500 ... 0x501:
 		switch (prr) {
@@ -160,7 +159,7 @@ int __init detect_cpu_and_cache_system(void)
 		cpu_data->icache.ways = 2;
 		cpu_data->dcache.ways = 2;
 
-		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PTEA;
+		cpu_data->flags |= CPU_HAS_FPU;
 
 		break;
 	default:
@@ -173,6 +172,10 @@ int __init detect_cpu_and_cache_system(void)
 	cpu_data->dcache.ways = 1;
 #endif
 
+#ifdef CONFIG_CPU_HAS_PTEA
+	cpu_data->flags |= CPU_HAS_PTEA;
+#endif
+
 	/*
 	 * On anything that's not a direct-mapped cache, look to the CVR
 	 * for I/D-cache specifics.

commit d15f456043175bdf3464514b92a825b88d0546ae
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 18:28:34 2006 +0900

    sh: More intelligent entry_mask/way_size calculation.
    
    Figure out the cache desc entry_mask at runtime, and remove
    hard-coded assumption about the cacheline size.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index bee00cac0b16..c294de1e14a3 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -38,7 +38,6 @@ int __init detect_cpu_and_cache_system(void)
 	 */
 	cpu_data->icache.way_incr	= (1 << 13);
 	cpu_data->icache.entry_shift	= 5;
-	cpu_data->icache.entry_mask	= 0x1fe0;
 	cpu_data->icache.sets		= 256;
 	cpu_data->icache.ways		= 1;
 	cpu_data->icache.linesz		= L1_CACHE_BYTES;
@@ -48,7 +47,6 @@ int __init detect_cpu_and_cache_system(void)
 	 */
 	cpu_data->dcache.way_incr	= (1 << 14);
 	cpu_data->dcache.entry_shift	= 5;
-	cpu_data->dcache.entry_mask	= 0x3fe0;
 	cpu_data->dcache.sets		= 512;
 	cpu_data->dcache.ways		= 1;
 	cpu_data->dcache.linesz		= L1_CACHE_BYTES;
@@ -183,21 +181,26 @@ int __init detect_cpu_and_cache_system(void)
 		size = sizes[(cvr >> 20) & 0xf];
 		cpu_data->icache.way_incr	= (size >> 1);
 		cpu_data->icache.sets		= (size >> 6);
-		cpu_data->icache.entry_mask	=
-			(cpu_data->icache.way_incr - (1 << 5));
+
 	}
 
+	/* Setup the rest of the I-cache info */
+	cpu_data->icache.entry_mask = cpu_data->icache.way_incr -
+				      cpu_data->icache.linesz;
+
 	cpu_data->icache.way_size = cpu_data->icache.sets *
 				    cpu_data->icache.linesz;
 
+	/* And the rest of the D-cache */
 	if (cpu_data->dcache.ways > 1) {
 		size = sizes[(cvr >> 16) & 0xf];
 		cpu_data->dcache.way_incr	= (size >> 1);
 		cpu_data->dcache.sets		= (size >> 6);
-		cpu_data->dcache.entry_mask	=
-			(cpu_data->dcache.way_incr - (1 << 5));
 	}
 
+	cpu_data->dcache.entry_mask = cpu_data->dcache.way_incr -
+				      cpu_data->dcache.linesz;
+
 	cpu_data->dcache.way_size = cpu_data->dcache.sets *
 				    cpu_data->dcache.linesz;
 
@@ -219,11 +222,14 @@ int __init detect_cpu_and_cache_system(void)
 
 		cpu_data->scache.way_incr	= (1 << 16);
 		cpu_data->scache.entry_shift	= 5;
-		cpu_data->scache.entry_mask	= 0xffe0;
 		cpu_data->scache.ways		= 4;
 		cpu_data->scache.linesz		= L1_CACHE_BYTES;
+		cpu_data->scache.entry_mask	=
+			(cpu_data->scache.way_incr - cpu_data->scache.linesz);
 		cpu_data->scache.sets		= size /
 			(cpu_data->scache.linesz * cpu_data->scache.ways);
+		cpu_data->scache.way_size	=
+			(cpu_data->scache.sets * cpu_data->scache.linesz);
 	}
 
 	return 0;

commit 72c35543f8cf1316773ffbd9619575bb84ac44fb
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 18:27:43 2006 +0900

    sh: Support for L2 cache on newer SH-4A CPUs.
    
    This implements preliminary support for the L2 caches found
    on newer SH-4A CPUs.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 0e65aa6ddcaa..bee00cac0b16 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -29,7 +29,7 @@ int __init detect_cpu_and_cache_system(void)
 		[9] = (1 << 16)
 	};
 
-	pvr = (ctrl_inl(CCN_PVR) >> 8) & 0xffff;
+	pvr = (ctrl_inl(CCN_PVR) >> 8) & 0xffffff;
 	prr = (ctrl_inl(CCN_PRR) >> 4) & 0xff;
 	cvr = (ctrl_inl(CCN_CVR));
 
@@ -53,6 +53,26 @@ int __init detect_cpu_and_cache_system(void)
 	cpu_data->dcache.ways		= 1;
 	cpu_data->dcache.linesz		= L1_CACHE_BYTES;
 
+	/*
+	 * Setup some generic flags we can probe
+	 * (L2 and DSP detection only work on SH-4A)
+	 */
+	if (((pvr >> 16) & 0xff) == 0x10) {
+		if ((cvr & 0x02000000) == 0)
+			cpu_data->flags |= CPU_HAS_L2_CACHE;
+		if ((cvr & 0x10000000) == 0)
+			cpu_data->flags |= CPU_HAS_DSP;
+
+		cpu_data->flags |= CPU_HAS_LLSC;
+	}
+
+	/* FPU detection works for everyone */
+	if ((cvr & 0x20000000) == 1)
+		cpu_data->flags |= CPU_HAS_FPU;
+
+	/* Mask off the upper chip ID */
+	pvr &= 0xffff;
+
 	/*
 	 * Probe the underlying processor version/revision and
 	 * adjust cpu_data setup accordingly.
@@ -181,5 +201,30 @@ int __init detect_cpu_and_cache_system(void)
 	cpu_data->dcache.way_size = cpu_data->dcache.sets *
 				    cpu_data->dcache.linesz;
 
+	/*
+	 * Setup the L2 cache desc
+	 *
+	 * SH-4A's have an optional PIPT L2.
+	 */
+	if (cpu_data->flags & CPU_HAS_L2_CACHE) {
+		/*
+		 * Size calculation is much more sensible
+		 * than it is for the L1.
+		 *
+		 * Sizes are 128KB, 258KB, 512KB, and 1MB.
+		 */
+		size = (cvr & 0xf) << 17;
+
+		BUG_ON(!size);
+
+		cpu_data->scache.way_incr	= (1 << 16);
+		cpu_data->scache.entry_shift	= 5;
+		cpu_data->scache.entry_mask	= 0xffe0;
+		cpu_data->scache.ways		= 4;
+		cpu_data->scache.linesz		= L1_CACHE_BYTES;
+		cpu_data->scache.sets		= size /
+			(cpu_data->scache.linesz * cpu_data->scache.ways);
+	}
+
 	return 0;
 }

commit 315bb96824149614efe4844ded077a13fc908880
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 18:22:53 2006 +0900

    sh: CPU flags in AT_HWCAP in ELF auxvt.
    
    Encode processor flags in AT_HWCAP in the ELF auxiliary vector.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 6e8a2b5268e8..0e65aa6ddcaa 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -76,6 +76,7 @@ int __init detect_cpu_and_cache_system(void)
 		cpu_data->type = CPU_SH73180;
 		cpu_data->icache.ways = 4;
 		cpu_data->dcache.ways = 4;
+		cpu_data->flags |= CPU_HAS_LLSC;
 		break;
 	case 0x2001:
 	case 0x2004:
@@ -83,7 +84,7 @@ int __init detect_cpu_and_cache_system(void)
 		cpu_data->icache.ways = 4;
 		cpu_data->dcache.ways = 4;
 
-		cpu_data->flags |= CPU_HAS_FPU;
+		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_LLSC;
 		break;
 	case 0x2006:
 	case 0x200A:
@@ -95,13 +96,15 @@ int __init detect_cpu_and_cache_system(void)
 		cpu_data->icache.ways = 4;
 		cpu_data->dcache.ways = 4;
 
-		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER;
+		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER |
+				   CPU_HAS_LLSC;
 		break;
 	case 0x3000:
 	case 0x3003:
 		cpu_data->type = CPU_SH7343;
 		cpu_data->icache.ways = 4;
 		cpu_data->dcache.ways = 4;
+		cpu_data->flags |= CPU_HAS_LLSC;
 		break;
 	case 0x8000:
 		cpu_data->type = CPU_ST40RA;
@@ -180,4 +183,3 @@ int __init detect_cpu_and_cache_system(void)
 
 	return 0;
 }
-

commit e5723e0eeb2dc16629e86d66785024ead9169000
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 17:38:11 2006 +0900

    sh: Add support for SH7706/SH7710/SH7343 CPUs.
    
    This adds support for the aforementioned CPU subtypes, and cleans
    up some build issues encountered as a result.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 2a7707a81d8f..6e8a2b5268e8 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -3,7 +3,7 @@
  *
  * CPU Subtype Probing for SH-4.
  *
- * Copyright (C) 2001 - 2005  Paul Mundt
+ * Copyright (C) 2001 - 2006  Paul Mundt
  * Copyright (C) 2003  Richard Curnow
  *
  * This file is subject to the terms and conditions of the GNU General Public
@@ -76,12 +76,6 @@ int __init detect_cpu_and_cache_system(void)
 		cpu_data->type = CPU_SH73180;
 		cpu_data->icache.ways = 4;
 		cpu_data->dcache.ways = 4;
-
-		/*
-		 * XXX: Double check this, none of the SH-4A/SH-4AL processors
-		 * should have this, as it's essentially a legacy thing.
-		 */
-		cpu_data->flags |= CPU_HAS_PTEA;
 		break;
 	case 0x2001:
 	case 0x2004:
@@ -89,8 +83,7 @@ int __init detect_cpu_and_cache_system(void)
 		cpu_data->icache.ways = 4;
 		cpu_data->dcache.ways = 4;
 
-		/* Same note as above applies here for PTEA */
-		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PTEA;
+		cpu_data->flags |= CPU_HAS_FPU;
 		break;
 	case 0x2006:
 	case 0x200A:
@@ -104,6 +97,12 @@ int __init detect_cpu_and_cache_system(void)
 
 		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER;
 		break;
+	case 0x3000:
+	case 0x3003:
+		cpu_data->type = CPU_SH7343;
+		cpu_data->icache.ways = 4;
+		cpu_data->dcache.ways = 4;
+		break;
 	case 0x8000:
 		cpu_data->type = CPU_ST40RA;
 		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PTEA;

commit 749cf486920bf53f16e6a6889d9635a91ffb6c82
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 14:55:41 2006 +0900

    sh: Add flag for MMU PTEA capability.
    
    Add CPU_HAS_PTEA, refactor some of the cpu flag settings.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 85ff48c1533a..2a7707a81d8f 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -3,7 +3,7 @@
  *
  * CPU Subtype Probing for SH-4.
  *
- * Copyright (C) 2001, 2002, 2003, 2004  Paul Mundt
+ * Copyright (C) 2001 - 2005  Paul Mundt
  * Copyright (C) 2003  Richard Curnow
  *
  * This file is subject to the terms and conditions of the GNU General Public
@@ -53,9 +53,6 @@ int __init detect_cpu_and_cache_system(void)
 	cpu_data->dcache.ways		= 1;
 	cpu_data->dcache.linesz		= L1_CACHE_BYTES;
 
-	/* Set the FPU flag, virtually all SH-4's have one */
-	cpu_data->flags |= CPU_HAS_FPU;
-
 	/*
 	 * Probe the underlying processor version/revision and
 	 * adjust cpu_data setup accordingly.
@@ -63,26 +60,37 @@ int __init detect_cpu_and_cache_system(void)
 	switch (pvr) {
 	case 0x205:
 		cpu_data->type = CPU_SH7750;
-		cpu_data->flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_PERF_COUNTER;
+		cpu_data->flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_FPU |
+				   CPU_HAS_PERF_COUNTER | CPU_HAS_PTEA;
 		break;
 	case 0x206:
 		cpu_data->type = CPU_SH7750S;
-		cpu_data->flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_PERF_COUNTER;
+		cpu_data->flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_FPU |
+				   CPU_HAS_PERF_COUNTER | CPU_HAS_PTEA;
 		break;
 	case 0x1100:
 		cpu_data->type = CPU_SH7751;
+		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PTEA;
 		break;
 	case 0x2000:
 		cpu_data->type = CPU_SH73180;
 		cpu_data->icache.ways = 4;
 		cpu_data->dcache.ways = 4;
-		cpu_data->flags &= ~CPU_HAS_FPU;
+
+		/*
+		 * XXX: Double check this, none of the SH-4A/SH-4AL processors
+		 * should have this, as it's essentially a legacy thing.
+		 */
+		cpu_data->flags |= CPU_HAS_PTEA;
 		break;
 	case 0x2001:
 	case 0x2004:
 		cpu_data->type = CPU_SH7770;
 		cpu_data->icache.ways = 4;
 		cpu_data->dcache.ways = 4;
+
+		/* Same note as above applies here for PTEA */
+		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PTEA;
 		break;
 	case 0x2006:
 	case 0x200A:
@@ -90,27 +98,31 @@ int __init detect_cpu_and_cache_system(void)
 			cpu_data->type = CPU_SH7781;
 		else
 			cpu_data->type = CPU_SH7780;
+
 		cpu_data->icache.ways = 4;
 		cpu_data->dcache.ways = 4;
+
+		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PERF_COUNTER;
 		break;
 	case 0x8000:
 		cpu_data->type = CPU_ST40RA;
+		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PTEA;
 		break;
 	case 0x8100:
 		cpu_data->type = CPU_ST40GX1;
+		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PTEA;
 		break;
 	case 0x700:
 		cpu_data->type = CPU_SH4_501;
 		cpu_data->icache.ways = 2;
 		cpu_data->dcache.ways = 2;
-
-		/* No FPU on the SH4-500 series.. */
-		cpu_data->flags &= ~CPU_HAS_FPU;
+		cpu_data->flags |= CPU_HAS_PTEA;
 		break;
 	case 0x600:
 		cpu_data->type = CPU_SH4_202;
 		cpu_data->icache.ways = 2;
 		cpu_data->dcache.ways = 2;
+		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PTEA;
 		break;
 	case 0x500 ... 0x501:
 		switch (prr) {
@@ -128,6 +140,8 @@ int __init detect_cpu_and_cache_system(void)
 		cpu_data->icache.ways = 2;
 		cpu_data->dcache.ways = 2;
 
+		cpu_data->flags |= CPU_HAS_FPU | CPU_HAS_PTEA;
+
 		break;
 	default:
 		cpu_data->type = CPU_SH_NONE;

commit 5b19c9081fbd0882c936ec087bf9055a20251dec
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 14:31:40 2006 +0900

    sh: Support for SH7770/SH7780 CPU subtypes.
    
    Merge support for SH7770 and SH7780 SH-4A subtypes.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 89986e70d041..85ff48c1533a 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -78,6 +78,21 @@ int __init detect_cpu_and_cache_system(void)
 		cpu_data->dcache.ways = 4;
 		cpu_data->flags &= ~CPU_HAS_FPU;
 		break;
+	case 0x2001:
+	case 0x2004:
+		cpu_data->type = CPU_SH7770;
+		cpu_data->icache.ways = 4;
+		cpu_data->dcache.ways = 4;
+		break;
+	case 0x2006:
+	case 0x200A:
+		if (prr == 0x61)
+			cpu_data->type = CPU_SH7781;
+		else
+			cpu_data->type = CPU_SH7780;
+		cpu_data->icache.ways = 4;
+		cpu_data->dcache.ways = 4;
+		break;
 	case 0x8000:
 		cpu_data->type = CPU_ST40RA;
 		break;

commit 73388cc7c648861742e584a97fbffed16afc7dc3
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 14:11:33 2006 +0900

    sh: Refactor PRR masking to catch newer SH7760 cuts.
    
    Newer SH7760 cuts have a range of acceptable PRR values..
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 1208da8fe5db..89986e70d041 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -99,9 +99,15 @@ int __init detect_cpu_and_cache_system(void)
 		break;
 	case 0x500 ... 0x501:
 		switch (prr) {
-		    case 0x10: cpu_data->type = CPU_SH7750R; break;
-		    case 0x11: cpu_data->type = CPU_SH7751R; break;
-		    case 0x50: cpu_data->type = CPU_SH7760;  break;
+		case 0x10:
+			cpu_data->type = CPU_SH7750R;
+			break;
+		case 0x11:
+			cpu_data->type = CPU_SH7751R;
+			break;
+		case 0x50 ... 0x5f:
+			cpu_data->type = CPU_SH7760;
+			break;
 		}
 
 		cpu_data->icache.ways = 2;

commit b638d0b921dc95229af0dfd09cd24850336a2f75
Author: Richard Curnow <richard.curnow@st.com>
Date:   Wed Sep 27 14:09:26 2006 +0900

    sh: Optimized cache handling for SH-4/SH-4A caches.
    
    This reworks some of the SH-4 cache handling code to more easily
    accomodate newer-style caches (particularly for the > direct-mapped
    case), as well as optimizing some of the old code.
    
    Signed-off-by: Richard Curnow <richard.curnow@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
index 42427b79697b..1208da8fe5db 100644
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -113,6 +113,11 @@ int __init detect_cpu_and_cache_system(void)
 		break;
 	}
 
+#ifdef CONFIG_SH_DIRECT_MAPPED
+	cpu_data->icache.ways = 1;
+	cpu_data->dcache.ways = 1;
+#endif
+
 	/*
 	 * On anything that's not a direct-mapped cache, look to the CVR
 	 * for I/D-cache specifics.
@@ -125,6 +130,9 @@ int __init detect_cpu_and_cache_system(void)
 			(cpu_data->icache.way_incr - (1 << 5));
 	}
 
+	cpu_data->icache.way_size = cpu_data->icache.sets *
+				    cpu_data->icache.linesz;
+
 	if (cpu_data->dcache.ways > 1) {
 		size = sizes[(cvr >> 16) & 0xf];
 		cpu_data->dcache.way_incr	= (size >> 1);
@@ -133,6 +141,9 @@ int __init detect_cpu_and_cache_system(void)
 			(cpu_data->dcache.way_incr - (1 << 5));
 	}
 
+	cpu_data->dcache.way_size = cpu_data->dcache.sets *
+				    cpu_data->dcache.linesz;
+
 	return 0;
 }
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
new file mode 100644
index 000000000000..42427b79697b
--- /dev/null
+++ b/arch/sh/kernel/cpu/sh4/probe.c
@@ -0,0 +1,138 @@
+/*
+ * arch/sh/kernel/cpu/sh4/probe.c
+ *
+ * CPU Subtype Probing for SH-4.
+ *
+ * Copyright (C) 2001, 2002, 2003, 2004  Paul Mundt
+ * Copyright (C) 2003  Richard Curnow
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/init.h>
+#include <asm/processor.h>
+#include <asm/cache.h>
+#include <asm/io.h>
+
+int __init detect_cpu_and_cache_system(void)
+{
+	unsigned long pvr, prr, cvr;
+	unsigned long size;
+
+	static unsigned long sizes[16] = {
+		[1] = (1 << 12),
+		[2] = (1 << 13),
+		[4] = (1 << 14),
+		[8] = (1 << 15),
+		[9] = (1 << 16)
+	};
+
+	pvr = (ctrl_inl(CCN_PVR) >> 8) & 0xffff;
+	prr = (ctrl_inl(CCN_PRR) >> 4) & 0xff;
+	cvr = (ctrl_inl(CCN_CVR));
+
+	/*
+	 * Setup some sane SH-4 defaults for the icache
+	 */
+	cpu_data->icache.way_incr	= (1 << 13);
+	cpu_data->icache.entry_shift	= 5;
+	cpu_data->icache.entry_mask	= 0x1fe0;
+	cpu_data->icache.sets		= 256;
+	cpu_data->icache.ways		= 1;
+	cpu_data->icache.linesz		= L1_CACHE_BYTES;
+
+	/*
+	 * And again for the dcache ..
+	 */
+	cpu_data->dcache.way_incr	= (1 << 14);
+	cpu_data->dcache.entry_shift	= 5;
+	cpu_data->dcache.entry_mask	= 0x3fe0;
+	cpu_data->dcache.sets		= 512;
+	cpu_data->dcache.ways		= 1;
+	cpu_data->dcache.linesz		= L1_CACHE_BYTES;
+
+	/* Set the FPU flag, virtually all SH-4's have one */
+	cpu_data->flags |= CPU_HAS_FPU;
+
+	/*
+	 * Probe the underlying processor version/revision and
+	 * adjust cpu_data setup accordingly.
+	 */
+	switch (pvr) {
+	case 0x205:
+		cpu_data->type = CPU_SH7750;
+		cpu_data->flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_PERF_COUNTER;
+		break;
+	case 0x206:
+		cpu_data->type = CPU_SH7750S;
+		cpu_data->flags |= CPU_HAS_P2_FLUSH_BUG | CPU_HAS_PERF_COUNTER;
+		break;
+	case 0x1100:
+		cpu_data->type = CPU_SH7751;
+		break;
+	case 0x2000:
+		cpu_data->type = CPU_SH73180;
+		cpu_data->icache.ways = 4;
+		cpu_data->dcache.ways = 4;
+		cpu_data->flags &= ~CPU_HAS_FPU;
+		break;
+	case 0x8000:
+		cpu_data->type = CPU_ST40RA;
+		break;
+	case 0x8100:
+		cpu_data->type = CPU_ST40GX1;
+		break;
+	case 0x700:
+		cpu_data->type = CPU_SH4_501;
+		cpu_data->icache.ways = 2;
+		cpu_data->dcache.ways = 2;
+
+		/* No FPU on the SH4-500 series.. */
+		cpu_data->flags &= ~CPU_HAS_FPU;
+		break;
+	case 0x600:
+		cpu_data->type = CPU_SH4_202;
+		cpu_data->icache.ways = 2;
+		cpu_data->dcache.ways = 2;
+		break;
+	case 0x500 ... 0x501:
+		switch (prr) {
+		    case 0x10: cpu_data->type = CPU_SH7750R; break;
+		    case 0x11: cpu_data->type = CPU_SH7751R; break;
+		    case 0x50: cpu_data->type = CPU_SH7760;  break;
+		}
+
+		cpu_data->icache.ways = 2;
+		cpu_data->dcache.ways = 2;
+
+		break;
+	default:
+		cpu_data->type = CPU_SH_NONE;
+		break;
+	}
+
+	/*
+	 * On anything that's not a direct-mapped cache, look to the CVR
+	 * for I/D-cache specifics.
+	 */
+	if (cpu_data->icache.ways > 1) {
+		size = sizes[(cvr >> 20) & 0xf];
+		cpu_data->icache.way_incr	= (size >> 1);
+		cpu_data->icache.sets		= (size >> 6);
+		cpu_data->icache.entry_mask	=
+			(cpu_data->icache.way_incr - (1 << 5));
+	}
+
+	if (cpu_data->dcache.ways > 1) {
+		size = sizes[(cvr >> 16) & 0xf];
+		cpu_data->dcache.way_incr	= (size >> 1);
+		cpu_data->dcache.sets		= (size >> 6);
+		cpu_data->dcache.entry_mask	=
+			(cpu_data->dcache.way_incr - (1 << 5));
+	}
+
+	return 0;
+}
+
