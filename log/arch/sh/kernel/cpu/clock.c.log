commit b0a148f80c1526951d6d196ded1d0c93158c2e25
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 28 00:32:21 2018 -0800

    sh: cpu: convert to SPDX identifiers
    
    Update license to use SPDX-License-Identifier instead of verbose license
    text.
    
    Link: http://lkml.kernel.org/r/874lbscswy.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index fca9b1e78a63..6fb34410d630 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * arch/sh/kernel/cpu/clock.c - SuperH clock framework
  *
@@ -9,10 +10,6 @@
  *	Written by Tuukka Tikkanen <tuukka.tikkanen@elektrobit.com>
  *
  *  Modified for omap shared clock framework by Tony Lindgren <tony@atomide.com>
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 #include <linux/kernel.h>
 #include <linux/init.h>

commit 15f0c8f2f378a05fe7b25e545c353a6b5cf5126a
Author: Rich Felker <dalias@libc.org>
Date:   Sun Jul 31 03:11:30 2016 +0000

    sh: use common clock framework with device tree boards
    
    Enable common clk framework for DT-based boards and disable code that
    depends on the legacy sh clk framework when common clk is enabled.
    Once legacy drivers are converted over, the old code can be removed
    entirely.
    
    Signed-off-by: Rich Felker <dalias@libc.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 4187cf4fe185..fca9b1e78a63 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -24,11 +24,13 @@ int __init clk_init(void)
 {
 	int ret;
 
+#ifndef CONFIG_COMMON_CLK
 	ret = arch_clk_init();
 	if (unlikely(ret)) {
 		pr_err("%s: CPU clock registration failed.\n", __func__);
 		return ret;
 	}
+#endif
 
 	if (sh_mv.mv_clk_init) {
 		ret = sh_mv.mv_clk_init();
@@ -39,11 +41,13 @@ int __init clk_init(void)
 		}
 	}
 
+#ifndef CONFIG_COMMON_CLK
 	/* Kick the child clocks.. */
 	recalculate_root_clocks();
 
 	/* Enable the necessary init clocks */
 	clk_enable_init_clocks();
+#endif
 
 	return ret;
 }

commit 6d803ba736abb5e122dede70a4720e4843dd6df4
Author: Jean-Christop PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Wed Nov 17 10:04:33 2010 +0100

    ARM: 6483/1: arm & sh: factorised duplicated clkdev.c
    
    factorise some generic infrastructure to assist looking up struct clks
    for the ARM & SH architecture.
    
    as the code is identical at 99%
    
    put the arch specific code for allocation as example in asm/clkdev.h
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 50f887dda565..4187cf4fe185 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -48,20 +48,4 @@ int __init clk_init(void)
 	return ret;
 }
 
-/*
- * Returns a clock. Note that we first try to use device id on the bus
- * and clock name. If this fails, we try to use clock name only.
- */
-struct clk *clk_get(struct device *dev, const char *con_id)
-{
-	const char *dev_id = dev ? dev_name(dev) : NULL;
-
-	return clk_get_sys(dev_id, con_id);
-}
-EXPORT_SYMBOL_GPL(clk_get);
-
-void clk_put(struct clk *clk)
-{
-}
-EXPORT_SYMBOL_GPL(clk_put);
 

commit 8b5ee113e1b97097e992a0301d0cac2530b31fc2
Author: Magnus Damm <damm@opensource.se>
Date:   Tue May 11 13:29:25 2010 +0000

    sh: move sh clock.c contents to drivers/sh/clk.
    
    This patch is V2 of the SH clock framework move from
    arch/sh/kernel/cpu/clock.c to drivers/sh/clk.c. All
    code except the following functions are moved:
    clk_init(), clk_get() and clk_put().
    
    The init function is still kept in clock.c since it
    depends on the SH-specific machvec implementation.
    
    The symbols clk_get() and clk_put() already exist in
    the common ARM clkdev code, those symbols are left in
    the SH tree to avoid duplicating them for SH-Mobile ARM.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 8cc6935d91ae..50f887dda565 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -16,467 +16,10 @@
  */
 #include <linux/kernel.h>
 #include <linux/init.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/list.h>
-#include <linux/kobject.h>
-#include <linux/sysdev.h>
-#include <linux/seq_file.h>
-#include <linux/err.h>
-#include <linux/platform_device.h>
-#include <linux/debugfs.h>
-#include <linux/cpufreq.h>
 #include <linux/clk.h>
 #include <asm/clock.h>
 #include <asm/machvec.h>
 
-static LIST_HEAD(clock_list);
-static DEFINE_SPINLOCK(clock_lock);
-static DEFINE_MUTEX(clock_list_sem);
-
-void clk_rate_table_build(struct clk *clk,
-			  struct cpufreq_frequency_table *freq_table,
-			  int nr_freqs,
-			  struct clk_div_mult_table *src_table,
-			  unsigned long *bitmap)
-{
-	unsigned long mult, div;
-	unsigned long freq;
-	int i;
-
-	for (i = 0; i < nr_freqs; i++) {
-		div = 1;
-		mult = 1;
-
-		if (src_table->divisors && i < src_table->nr_divisors)
-			div = src_table->divisors[i];
-
-		if (src_table->multipliers && i < src_table->nr_multipliers)
-			mult = src_table->multipliers[i];
-
-		if (!div || !mult || (bitmap && !test_bit(i, bitmap)))
-			freq = CPUFREQ_ENTRY_INVALID;
-		else
-			freq = clk->parent->rate * mult / div;
-
-		freq_table[i].index = i;
-		freq_table[i].frequency = freq;
-	}
-
-	/* Termination entry */
-	freq_table[i].index = i;
-	freq_table[i].frequency = CPUFREQ_TABLE_END;
-}
-
-long clk_rate_table_round(struct clk *clk,
-			  struct cpufreq_frequency_table *freq_table,
-			  unsigned long rate)
-{
-	unsigned long rate_error, rate_error_prev = ~0UL;
-	unsigned long rate_best_fit = rate;
-	unsigned long highest, lowest;
-	int i;
-
-	highest = lowest = 0;
-
-	for (i = 0; freq_table[i].frequency != CPUFREQ_TABLE_END; i++) {
-		unsigned long freq = freq_table[i].frequency;
-
-		if (freq == CPUFREQ_ENTRY_INVALID)
-			continue;
-
-		if (freq > highest)
-			highest = freq;
-		if (freq < lowest)
-			lowest = freq;
-
-		rate_error = abs(freq - rate);
-		if (rate_error < rate_error_prev) {
-			rate_best_fit = freq;
-			rate_error_prev = rate_error;
-		}
-
-		if (rate_error == 0)
-			break;
-	}
-
-	if (rate >= highest)
-		rate_best_fit = highest;
-	if (rate <= lowest)
-		rate_best_fit = lowest;
-
-	return rate_best_fit;
-}
-
-int clk_rate_table_find(struct clk *clk,
-			struct cpufreq_frequency_table *freq_table,
-			unsigned long rate)
-{
-	int i;
-
-	for (i = 0; freq_table[i].frequency != CPUFREQ_TABLE_END; i++) {
-		unsigned long freq = freq_table[i].frequency;
-
-		if (freq == CPUFREQ_ENTRY_INVALID)
-			continue;
-
-		if (freq == rate)
-			return i;
-	}
-
-	return -ENOENT;
-}
-
-/* Used for clocks that always have same value as the parent clock */
-unsigned long followparent_recalc(struct clk *clk)
-{
-	return clk->parent ? clk->parent->rate : 0;
-}
-
-int clk_reparent(struct clk *child, struct clk *parent)
-{
-	list_del_init(&child->sibling);
-	if (parent)
-		list_add(&child->sibling, &parent->children);
-	child->parent = parent;
-
-	/* now do the debugfs renaming to reattach the child
-	   to the proper parent */
-
-	return 0;
-}
-
-/* Propagate rate to children */
-void propagate_rate(struct clk *tclk)
-{
-	struct clk *clkp;
-
-	list_for_each_entry(clkp, &tclk->children, sibling) {
-		if (clkp->ops && clkp->ops->recalc)
-			clkp->rate = clkp->ops->recalc(clkp);
-
-		propagate_rate(clkp);
-	}
-}
-
-static void __clk_disable(struct clk *clk)
-{
-	if (clk->usecount == 0) {
-		printk(KERN_ERR "Trying disable clock %s with 0 usecount\n",
-		       clk->name);
-		WARN_ON(1);
-		return;
-	}
-
-	if (!(--clk->usecount)) {
-		if (likely(clk->ops && clk->ops->disable))
-			clk->ops->disable(clk);
-		if (likely(clk->parent))
-			__clk_disable(clk->parent);
-	}
-}
-
-void clk_disable(struct clk *clk)
-{
-	unsigned long flags;
-
-	if (!clk)
-		return;
-
-	spin_lock_irqsave(&clock_lock, flags);
-	__clk_disable(clk);
-	spin_unlock_irqrestore(&clock_lock, flags);
-}
-EXPORT_SYMBOL_GPL(clk_disable);
-
-static int __clk_enable(struct clk *clk)
-{
-	int ret = 0;
-
-	if (clk->usecount++ == 0) {
-		if (clk->parent) {
-			ret = __clk_enable(clk->parent);
-			if (unlikely(ret))
-				goto err;
-		}
-
-		if (clk->ops && clk->ops->enable) {
-			ret = clk->ops->enable(clk);
-			if (ret) {
-				if (clk->parent)
-					__clk_disable(clk->parent);
-				goto err;
-			}
-		}
-	}
-
-	return ret;
-err:
-	clk->usecount--;
-	return ret;
-}
-
-int clk_enable(struct clk *clk)
-{
-	unsigned long flags;
-	int ret;
-
-	if (!clk)
-		return -EINVAL;
-
-	spin_lock_irqsave(&clock_lock, flags);
-	ret = __clk_enable(clk);
-	spin_unlock_irqrestore(&clock_lock, flags);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(clk_enable);
-
-static LIST_HEAD(root_clks);
-
-/**
- * recalculate_root_clocks - recalculate and propagate all root clocks
- *
- * Recalculates all root clocks (clocks with no parent), which if the
- * clock's .recalc is set correctly, should also propagate their rates.
- * Called at init.
- */
-void recalculate_root_clocks(void)
-{
-	struct clk *clkp;
-
-	list_for_each_entry(clkp, &root_clks, sibling) {
-		if (clkp->ops && clkp->ops->recalc)
-			clkp->rate = clkp->ops->recalc(clkp);
-		propagate_rate(clkp);
-	}
-}
-
-int clk_register(struct clk *clk)
-{
-	if (clk == NULL || IS_ERR(clk))
-		return -EINVAL;
-
-	/*
-	 * trap out already registered clocks
-	 */
-	if (clk->node.next || clk->node.prev)
-		return 0;
-
-	mutex_lock(&clock_list_sem);
-
-	INIT_LIST_HEAD(&clk->children);
-	clk->usecount = 0;
-
-	if (clk->parent)
-		list_add(&clk->sibling, &clk->parent->children);
-	else
-		list_add(&clk->sibling, &root_clks);
-
-	list_add(&clk->node, &clock_list);
-	if (clk->ops && clk->ops->init)
-		clk->ops->init(clk);
-	mutex_unlock(&clock_list_sem);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(clk_register);
-
-void clk_unregister(struct clk *clk)
-{
-	mutex_lock(&clock_list_sem);
-	list_del(&clk->sibling);
-	list_del(&clk->node);
-	mutex_unlock(&clock_list_sem);
-}
-EXPORT_SYMBOL_GPL(clk_unregister);
-
-static void clk_enable_init_clocks(void)
-{
-	struct clk *clkp;
-
-	list_for_each_entry(clkp, &clock_list, node)
-		if (clkp->flags & CLK_ENABLE_ON_INIT)
-			clk_enable(clkp);
-}
-
-unsigned long clk_get_rate(struct clk *clk)
-{
-	return clk->rate;
-}
-EXPORT_SYMBOL_GPL(clk_get_rate);
-
-int clk_set_rate(struct clk *clk, unsigned long rate)
-{
-	return clk_set_rate_ex(clk, rate, 0);
-}
-EXPORT_SYMBOL_GPL(clk_set_rate);
-
-int clk_set_rate_ex(struct clk *clk, unsigned long rate, int algo_id)
-{
-	int ret = -EOPNOTSUPP;
-	unsigned long flags;
-
-	spin_lock_irqsave(&clock_lock, flags);
-
-	if (likely(clk->ops && clk->ops->set_rate)) {
-		ret = clk->ops->set_rate(clk, rate, algo_id);
-		if (ret != 0)
-			goto out_unlock;
-	} else {
-		clk->rate = rate;
-		ret = 0;
-	}
-
-	if (clk->ops && clk->ops->recalc)
-		clk->rate = clk->ops->recalc(clk);
-
-	propagate_rate(clk);
-
-out_unlock:
-	spin_unlock_irqrestore(&clock_lock, flags);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(clk_set_rate_ex);
-
-int clk_set_parent(struct clk *clk, struct clk *parent)
-{
-	unsigned long flags;
-	int ret = -EINVAL;
-
-	if (!parent || !clk)
-		return ret;
-	if (clk->parent == parent)
-		return 0;
-
-	spin_lock_irqsave(&clock_lock, flags);
-	if (clk->usecount == 0) {
-		if (clk->ops->set_parent)
-			ret = clk->ops->set_parent(clk, parent);
-		else
-			ret = clk_reparent(clk, parent);
-
-		if (ret == 0) {
-			pr_debug("clock: set parent of %s to %s (new rate %ld)\n",
-				 clk->name, clk->parent->name, clk->rate);
-			if (clk->ops->recalc)
-				clk->rate = clk->ops->recalc(clk);
-			propagate_rate(clk);
-		}
-	} else
-		ret = -EBUSY;
-	spin_unlock_irqrestore(&clock_lock, flags);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(clk_set_parent);
-
-struct clk *clk_get_parent(struct clk *clk)
-{
-	return clk->parent;
-}
-EXPORT_SYMBOL_GPL(clk_get_parent);
-
-long clk_round_rate(struct clk *clk, unsigned long rate)
-{
-	if (likely(clk->ops && clk->ops->round_rate)) {
-		unsigned long flags, rounded;
-
-		spin_lock_irqsave(&clock_lock, flags);
-		rounded = clk->ops->round_rate(clk, rate);
-		spin_unlock_irqrestore(&clock_lock, flags);
-
-		return rounded;
-	}
-
-	return clk_get_rate(clk);
-}
-EXPORT_SYMBOL_GPL(clk_round_rate);
-
-/*
- * Returns a clock. Note that we first try to use device id on the bus
- * and clock name. If this fails, we try to use clock name only.
- */
-struct clk *clk_get(struct device *dev, const char *con_id)
-{
-	const char *dev_id = dev ? dev_name(dev) : NULL;
-
-	return clk_get_sys(dev_id, con_id);
-}
-EXPORT_SYMBOL_GPL(clk_get);
-
-void clk_put(struct clk *clk)
-{
-}
-EXPORT_SYMBOL_GPL(clk_put);
-
-#ifdef CONFIG_PM
-static int clks_sysdev_suspend(struct sys_device *dev, pm_message_t state)
-{
-	static pm_message_t prev_state;
-	struct clk *clkp;
-
-	switch (state.event) {
-	case PM_EVENT_ON:
-		/* Resumeing from hibernation */
-		if (prev_state.event != PM_EVENT_FREEZE)
-			break;
-
-		list_for_each_entry(clkp, &clock_list, node) {
-			if (likely(clkp->ops)) {
-				unsigned long rate = clkp->rate;
-
-				if (likely(clkp->ops->set_parent))
-					clkp->ops->set_parent(clkp,
-						clkp->parent);
-				if (likely(clkp->ops->set_rate))
-					clkp->ops->set_rate(clkp,
-						rate, NO_CHANGE);
-				else if (likely(clkp->ops->recalc))
-					clkp->rate = clkp->ops->recalc(clkp);
-			}
-		}
-		break;
-	case PM_EVENT_FREEZE:
-		break;
-	case PM_EVENT_SUSPEND:
-		break;
-	}
-
-	prev_state = state;
-	return 0;
-}
-
-static int clks_sysdev_resume(struct sys_device *dev)
-{
-	return clks_sysdev_suspend(dev, PMSG_ON);
-}
-
-static struct sysdev_class clks_sysdev_class = {
-	.name = "clks",
-};
-
-static struct sysdev_driver clks_sysdev_driver = {
-	.suspend = clks_sysdev_suspend,
-	.resume = clks_sysdev_resume,
-};
-
-static struct sys_device clks_sysdev_dev = {
-	.cls = &clks_sysdev_class,
-};
-
-static int __init clk_sysdev_init(void)
-{
-	sysdev_class_register(&clks_sysdev_class);
-	sysdev_driver_register(&clks_sysdev_class, &clks_sysdev_driver);
-	sysdev_register(&clks_sysdev_dev);
-
-	return 0;
-}
-subsys_initcall(clk_sysdev_init);
-#endif
-
 int __init clk_init(void)
 {
 	int ret;
@@ -506,89 +49,19 @@ int __init clk_init(void)
 }
 
 /*
- *	debugfs support to trace clock tree hierarchy and attributes
+ * Returns a clock. Note that we first try to use device id on the bus
+ * and clock name. If this fails, we try to use clock name only.
  */
-static struct dentry *clk_debugfs_root;
-
-static int clk_debugfs_register_one(struct clk *c)
+struct clk *clk_get(struct device *dev, const char *con_id)
 {
-	int err;
-	struct dentry *d, *child, *child_tmp;
-	struct clk *pa = c->parent;
-	char s[255];
-	char *p = s;
-
-	p += sprintf(p, "%s", c->name);
-	if (c->id >= 0)
-		sprintf(p, ":%d", c->id);
-	d = debugfs_create_dir(s, pa ? pa->dentry : clk_debugfs_root);
-	if (!d)
-		return -ENOMEM;
-	c->dentry = d;
-
-	d = debugfs_create_u8("usecount", S_IRUGO, c->dentry, (u8 *)&c->usecount);
-	if (!d) {
-		err = -ENOMEM;
-		goto err_out;
-	}
-	d = debugfs_create_u32("rate", S_IRUGO, c->dentry, (u32 *)&c->rate);
-	if (!d) {
-		err = -ENOMEM;
-		goto err_out;
-	}
-	d = debugfs_create_x32("flags", S_IRUGO, c->dentry, (u32 *)&c->flags);
-	if (!d) {
-		err = -ENOMEM;
-		goto err_out;
-	}
-	return 0;
+	const char *dev_id = dev ? dev_name(dev) : NULL;
 
-err_out:
-	d = c->dentry;
-	list_for_each_entry_safe(child, child_tmp, &d->d_subdirs, d_u.d_child)
-		debugfs_remove(child);
-	debugfs_remove(c->dentry);
-	return err;
+	return clk_get_sys(dev_id, con_id);
 }
+EXPORT_SYMBOL_GPL(clk_get);
 
-static int clk_debugfs_register(struct clk *c)
+void clk_put(struct clk *clk)
 {
-	int err;
-	struct clk *pa = c->parent;
-
-	if (pa && !pa->dentry) {
-		err = clk_debugfs_register(pa);
-		if (err)
-			return err;
-	}
-
-	if (!c->dentry && c->name) {
-		err = clk_debugfs_register_one(c);
-		if (err)
-			return err;
-	}
-	return 0;
 }
+EXPORT_SYMBOL_GPL(clk_put);
 
-static int __init clk_debugfs_init(void)
-{
-	struct clk *c;
-	struct dentry *d;
-	int err;
-
-	d = debugfs_create_dir("clock", NULL);
-	if (!d)
-		return -ENOMEM;
-	clk_debugfs_root = d;
-
-	list_for_each_entry(c, &clock_list, node) {
-		err = clk_debugfs_register(c);
-		if (err)
-			goto err_out;
-	}
-	return 0;
-err_out:
-	debugfs_remove_recursive(clk_debugfs_root);
-	return err;
-}
-late_initcall(clk_debugfs_init);

commit 441c2440aba2efd8d0f48a5e3357deec92283d62
Author: Magnus Damm <damm@opensource.se>
Date:   Tue May 11 09:37:12 2010 +0000

    sh: remove unused clock lookup
    
    Now when all clocks are registered using clkdev,
    get rid of the special SH-specific clock lookup.
    
    Also ditch the unused module ref counting code.
    This patch syncs the SH behaviour with ARM.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index a725c7feb747..8cc6935d91ae 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -398,49 +398,16 @@ EXPORT_SYMBOL_GPL(clk_round_rate);
  * Returns a clock. Note that we first try to use device id on the bus
  * and clock name. If this fails, we try to use clock name only.
  */
-struct clk *clk_get(struct device *dev, const char *id)
+struct clk *clk_get(struct device *dev, const char *con_id)
 {
 	const char *dev_id = dev ? dev_name(dev) : NULL;
-	struct clk *p, *clk = ERR_PTR(-ENOENT);
-	int idno;
 
-	clk = clk_get_sys(dev_id, id);
-	if (clk && !IS_ERR(clk))
-		return clk;
-
-	if (dev == NULL || dev->bus != &platform_bus_type)
-		idno = -1;
-	else
-		idno = to_platform_device(dev)->id;
-
-	mutex_lock(&clock_list_sem);
-	list_for_each_entry(p, &clock_list, node) {
-		if (p->name && p->id == idno &&
-		    strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
-			clk = p;
-			goto found;
-		}
-	}
-
-	list_for_each_entry(p, &clock_list, node) {
-		if (p->name &&
-		    strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
-			clk = p;
-			break;
-		}
-	}
-
-found:
-	mutex_unlock(&clock_list_sem);
-
-	return clk;
+	return clk_get_sys(dev_id, con_id);
 }
 EXPORT_SYMBOL_GPL(clk_get);
 
 void clk_put(struct clk *clk)
 {
-	if (clk && !IS_ERR(clk))
-		module_put(clk->owner);
 }
 EXPORT_SYMBOL_GPL(clk_put);
 

commit 4f615d575c17195f975cf8314be54f362d859a3f
Author: Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
Date:   Mon May 10 14:50:55 2010 +0300

    sh: clkfwk: Use debugfs_remove_recursive() for rewinding
    
    Rewinding each debugfs entries to unregister if an error happens.
    
    Based on the commit ca4caa4e1d45f9542fa54263974d0ef637157b4a
    
    Signed-off-by: Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 073f4ffe956a..a725c7feb747 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -621,7 +621,7 @@ static int __init clk_debugfs_init(void)
 	}
 	return 0;
 err_out:
-	debugfs_remove(clk_debugfs_root); /* REVISIT: Cleanup correctly */
+	debugfs_remove_recursive(clk_debugfs_root);
 	return err;
 }
 late_initcall(clk_debugfs_init);

commit d97432f1014c73bbace9eb1e67742c1bcab0c3cd
Author: Magnus Damm <damm@opensource.se>
Date:   Mon May 10 14:01:34 2010 +0000

    sh: allow registering clocks without name
    
    Modify the SuperH clock code to support struct clk
    with NULL as name. Such clocks will not be hooked
    up to debugfs.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 9ded1bc29260..073f4ffe956a 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -415,7 +415,7 @@ struct clk *clk_get(struct device *dev, const char *id)
 
 	mutex_lock(&clock_list_sem);
 	list_for_each_entry(p, &clock_list, node) {
-		if (p->id == idno &&
+		if (p->name && p->id == idno &&
 		    strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
 			clk = p;
 			goto found;
@@ -423,7 +423,8 @@ struct clk *clk_get(struct device *dev, const char *id)
 	}
 
 	list_for_each_entry(p, &clock_list, node) {
-		if (strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
+		if (p->name &&
+		    strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
 			clk = p;
 			break;
 		}
@@ -594,7 +595,7 @@ static int clk_debugfs_register(struct clk *c)
 			return err;
 	}
 
-	if (!c->dentry) {
+	if (!c->dentry && c->name) {
 		err = clk_debugfs_register_one(c);
 		if (err)
 			return err;

commit 51a5006afcd13176276f0935ee57c4cc6f210e83
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Mar 8 21:45:19 2010 +0900

    sh: Merge clkdev API updates.
    
    This rolls in the remainder of the clkdev API bits from the ARM tree.
    This can more or less be used verbatim, so we just copy it over and nuke
    our local version.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 83da5debeedf..9ded1bc29260 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -10,10 +10,6 @@
  *
  *  Modified for omap shared clock framework by Tony Lindgren <tony@atomide.com>
  *
- *  With clkdev bits:
- *
- *	Copyright (C) 2008 Russell King.
- *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
@@ -30,6 +26,7 @@
 #include <linux/platform_device.h>
 #include <linux/debugfs.h>
 #include <linux/cpufreq.h>
+#include <linux/clk.h>
 #include <asm/clock.h>
 #include <asm/machvec.h>
 
@@ -397,56 +394,6 @@ long clk_round_rate(struct clk *clk, unsigned long rate)
 }
 EXPORT_SYMBOL_GPL(clk_round_rate);
 
-/*
- * Find the correct struct clk for the device and connection ID.
- * We do slightly fuzzy matching here:
- *  An entry with a NULL ID is assumed to be a wildcard.
- *  If an entry has a device ID, it must match
- *  If an entry has a connection ID, it must match
- * Then we take the most specific entry - with the following
- * order of precidence: dev+con > dev only > con only.
- */
-static struct clk *clk_find(const char *dev_id, const char *con_id)
-{
-	struct clk_lookup *p;
-	struct clk *clk = NULL;
-	int match, best = 0;
-
-	list_for_each_entry(p, &clock_list, node) {
-		match = 0;
-		if (p->dev_id) {
-			if (!dev_id || strcmp(p->dev_id, dev_id))
-				continue;
-			match += 2;
-		}
-		if (p->con_id) {
-			if (!con_id || strcmp(p->con_id, con_id))
-				continue;
-			match += 1;
-		}
-		if (match == 0)
-			continue;
-
-		if (match > best) {
-			clk = p->clk;
-			best = match;
-		}
-	}
-	return clk;
-}
-
-struct clk *clk_get_sys(const char *dev_id, const char *con_id)
-{
-	struct clk *clk;
-
-	mutex_lock(&clock_list_sem);
-	clk = clk_find(dev_id, con_id);
-	mutex_unlock(&clock_list_sem);
-
-	return clk ? clk : ERR_PTR(-ENOENT);
-}
-EXPORT_SYMBOL_GPL(clk_get_sys);
-
 /*
  * Returns a clock. Note that we first try to use device id on the bus
  * and clock name. If this fails, we try to use clock name only.

commit bc10e875d4aeaa93a0d418d8b4346b72f5067ea0
Author: Marek Skuczynski <mareksk7@gmail.com>
Date:   Sat Jan 30 22:29:32 2010 +0100

    sh: Fix access to released memory in clk_debugfs_register_one()
    
    Signed-off-by: Marek Skuczynski <mareksk7@gmail.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index f3a46be2ae81..83da5debeedf 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -598,7 +598,7 @@ static struct dentry *clk_debugfs_root;
 static int clk_debugfs_register_one(struct clk *c)
 {
 	int err;
-	struct dentry *d, *child;
+	struct dentry *d, *child, *child_tmp;
 	struct clk *pa = c->parent;
 	char s[255];
 	char *p = s;
@@ -630,7 +630,7 @@ static int clk_debugfs_register_one(struct clk *c)
 
 err_out:
 	d = c->dentry;
-	list_for_each_entry(child, &d->d_subdirs, d_u.d_child)
+	list_for_each_entry_safe(child, child_tmp, &d->d_subdirs, d_u.d_child)
 		debugfs_remove(child);
 	debugfs_remove(c->dentry);
 	return err;

commit 098dee99d14e8324d3793df442d6078d0c134140
Author: Magnus Damm <damm@igel.co.jp>
Date:   Thu Jun 4 05:31:41 2009 +0000

    sh: add enable()/disable()/set_rate() to div6 code
    
    This patch updates the div6 clock helper code to add support
    for enable(), disable() and set_rate() callbacks.
    
    Needed by the camera clock enabling board code on Migo-R.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index aa0fd0893585..f3a46be2ae81 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -111,6 +111,25 @@ long clk_rate_table_round(struct clk *clk,
 	return rate_best_fit;
 }
 
+int clk_rate_table_find(struct clk *clk,
+			struct cpufreq_frequency_table *freq_table,
+			unsigned long rate)
+{
+	int i;
+
+	for (i = 0; freq_table[i].frequency != CPUFREQ_TABLE_END; i++) {
+		unsigned long freq = freq_table[i].frequency;
+
+		if (freq == CPUFREQ_ENTRY_INVALID)
+			continue;
+
+		if (freq == rate)
+			return i;
+	}
+
+	return -ENOENT;
+}
+
 /* Used for clocks that always have same value as the parent clock */
 unsigned long followparent_recalc(struct clk *clk)
 {

commit 61ce5393e4c8914c46ec99cbda76823515109709
Author: Magnus Damm <damm@igel.co.jp>
Date:   Mon May 25 08:10:45 2009 +0000

    sh: remove clk_ops->build_rate_table()
    
    This patch removes the ->build_rate_table() callback,
    ->recalc() may instead be used for this purpose.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 59764d6c5f41..aa0fd0893585 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -138,8 +138,6 @@ void propagate_rate(struct clk *tclk)
 	list_for_each_entry(clkp, &tclk->children, sibling) {
 		if (clkp->ops && clkp->ops->recalc)
 			clkp->rate = clkp->ops->recalc(clkp);
-		if (clkp->ops && clkp->ops->build_rate_table)
-			clkp->ops->build_rate_table(clkp);
 
 		propagate_rate(clkp);
 	}

commit c94a85746f7bdc13035acdf88c130d7b6fa41bde
Author: Magnus Damm <damm@igel.co.jp>
Date:   Mon May 25 08:10:28 2009 +0000

    sh: add shared clock framework frequency table code
    
    Add SuperH-specific clock framework helper functions:
    - clk_rate_table_build() - build cpufreq table from divisors/multipliers
    - clk_rate_table_round() - use cpufreq table to find matching frequency
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 012d23476a72..59764d6c5f41 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -29,6 +29,7 @@
 #include <linux/err.h>
 #include <linux/platform_device.h>
 #include <linux/debugfs.h>
+#include <linux/cpufreq.h>
 #include <asm/clock.h>
 #include <asm/machvec.h>
 
@@ -36,6 +37,80 @@ static LIST_HEAD(clock_list);
 static DEFINE_SPINLOCK(clock_lock);
 static DEFINE_MUTEX(clock_list_sem);
 
+void clk_rate_table_build(struct clk *clk,
+			  struct cpufreq_frequency_table *freq_table,
+			  int nr_freqs,
+			  struct clk_div_mult_table *src_table,
+			  unsigned long *bitmap)
+{
+	unsigned long mult, div;
+	unsigned long freq;
+	int i;
+
+	for (i = 0; i < nr_freqs; i++) {
+		div = 1;
+		mult = 1;
+
+		if (src_table->divisors && i < src_table->nr_divisors)
+			div = src_table->divisors[i];
+
+		if (src_table->multipliers && i < src_table->nr_multipliers)
+			mult = src_table->multipliers[i];
+
+		if (!div || !mult || (bitmap && !test_bit(i, bitmap)))
+			freq = CPUFREQ_ENTRY_INVALID;
+		else
+			freq = clk->parent->rate * mult / div;
+
+		freq_table[i].index = i;
+		freq_table[i].frequency = freq;
+	}
+
+	/* Termination entry */
+	freq_table[i].index = i;
+	freq_table[i].frequency = CPUFREQ_TABLE_END;
+}
+
+long clk_rate_table_round(struct clk *clk,
+			  struct cpufreq_frequency_table *freq_table,
+			  unsigned long rate)
+{
+	unsigned long rate_error, rate_error_prev = ~0UL;
+	unsigned long rate_best_fit = rate;
+	unsigned long highest, lowest;
+	int i;
+
+	highest = lowest = 0;
+
+	for (i = 0; freq_table[i].frequency != CPUFREQ_TABLE_END; i++) {
+		unsigned long freq = freq_table[i].frequency;
+
+		if (freq == CPUFREQ_ENTRY_INVALID)
+			continue;
+
+		if (freq > highest)
+			highest = freq;
+		if (freq < lowest)
+			lowest = freq;
+
+		rate_error = abs(freq - rate);
+		if (rate_error < rate_error_prev) {
+			rate_best_fit = freq;
+			rate_error_prev = rate_error;
+		}
+
+		if (rate_error == 0)
+			break;
+	}
+
+	if (rate >= highest)
+		rate_best_fit = highest;
+	if (rate <= lowest)
+		rate_best_fit = lowest;
+
+	return rate_best_fit;
+}
+
 /* Used for clocks that always have same value as the parent clock */
 unsigned long followparent_recalc(struct clk *clk)
 {

commit 549b5e358d17a8c04953ed80896ce07d37722451
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu May 14 17:38:46 2009 +0900

    sh: clkfwk: Add MSTP bits to SH7785 clock framework.
    
    This plugs in all of the MSTP functions in to the clock framework,
    and hands them off to the platform devices that want them.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 686477f8ae5b..012d23476a72 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -39,7 +39,7 @@ static DEFINE_MUTEX(clock_list_sem);
 /* Used for clocks that always have same value as the parent clock */
 unsigned long followparent_recalc(struct clk *clk)
 {
-	return clk->parent->rate;
+	return clk->parent ? clk->parent->rate : 0;
 }
 
 int clk_reparent(struct clk *child, struct clk *parent)
@@ -512,7 +512,7 @@ static int clk_debugfs_register_one(struct clk *c)
 	char *p = s;
 
 	p += sprintf(p, "%s", c->name);
-	if (c->id > 0)
+	if (c->id >= 0)
 		sprintf(p, ":%d", c->id);
 	d = debugfs_create_dir(s, pa ? pa->dentry : clk_debugfs_root);
 	if (!d)

commit cedcf3366f2191885aff92d33d6078ef08203e52
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed May 13 21:51:28 2009 +0900

    sh: clkfwk: Map tree hierarchy in debugfs.
    
    This adopts the OMAP clock framework debugfs bits and replaces the aging
    procfs bits. The procfs clocks entry was primarily a debugging aid, and
    used to be tied in to cpuinfo before the clock list grew too unweildly.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 56c6e11fa83b..686477f8ae5b 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -28,7 +28,7 @@
 #include <linux/seq_file.h>
 #include <linux/err.h>
 #include <linux/platform_device.h>
-#include <linux/proc_fs.h>
+#include <linux/debugfs.h>
 #include <asm/clock.h>
 #include <asm/machvec.h>
 
@@ -404,24 +404,6 @@ void clk_put(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_put);
 
-
-static int show_clocks(char *buf, char **start, off_t off,
-		       int len, int *eof, void *data)
-{
-	struct clk *clk;
-	char *p = buf;
-
-	list_for_each_entry_reverse(clk, &clock_list, node) {
-		unsigned long rate = clk_get_rate(clk);
-
-		p += sprintf(p, "%-12s\t: %ld.%02ldMHz\t%s\n", clk->name,
-			     rate / 1000000, (rate % 1000000) / 10000,
-			      (clk->usecount > 0) ?  "enabled" : "disabled");
-	}
-
-	return p - buf;
-}
-
 #ifdef CONFIG_PM
 static int clks_sysdev_suspend(struct sys_device *dev, pm_message_t state)
 {
@@ -516,14 +498,90 @@ int __init clk_init(void)
 	return ret;
 }
 
-static int __init clk_proc_init(void)
+/*
+ *	debugfs support to trace clock tree hierarchy and attributes
+ */
+static struct dentry *clk_debugfs_root;
+
+static int clk_debugfs_register_one(struct clk *c)
 {
-	struct proc_dir_entry *p;
-	p = create_proc_read_entry("clocks", S_IRUSR, NULL,
-				   show_clocks, NULL);
-	if (unlikely(!p))
-		return -EINVAL;
+	int err;
+	struct dentry *d, *child;
+	struct clk *pa = c->parent;
+	char s[255];
+	char *p = s;
+
+	p += sprintf(p, "%s", c->name);
+	if (c->id > 0)
+		sprintf(p, ":%d", c->id);
+	d = debugfs_create_dir(s, pa ? pa->dentry : clk_debugfs_root);
+	if (!d)
+		return -ENOMEM;
+	c->dentry = d;
+
+	d = debugfs_create_u8("usecount", S_IRUGO, c->dentry, (u8 *)&c->usecount);
+	if (!d) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+	d = debugfs_create_u32("rate", S_IRUGO, c->dentry, (u32 *)&c->rate);
+	if (!d) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+	d = debugfs_create_x32("flags", S_IRUGO, c->dentry, (u32 *)&c->flags);
+	if (!d) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+	return 0;
+
+err_out:
+	d = c->dentry;
+	list_for_each_entry(child, &d->d_subdirs, d_u.d_child)
+		debugfs_remove(child);
+	debugfs_remove(c->dentry);
+	return err;
+}
+
+static int clk_debugfs_register(struct clk *c)
+{
+	int err;
+	struct clk *pa = c->parent;
+
+	if (pa && !pa->dentry) {
+		err = clk_debugfs_register(pa);
+		if (err)
+			return err;
+	}
 
+	if (!c->dentry) {
+		err = clk_debugfs_register_one(c);
+		if (err)
+			return err;
+	}
+	return 0;
+}
+
+static int __init clk_debugfs_init(void)
+{
+	struct clk *c;
+	struct dentry *d;
+	int err;
+
+	d = debugfs_create_dir("clock", NULL);
+	if (!d)
+		return -ENOMEM;
+	clk_debugfs_root = d;
+
+	list_for_each_entry(c, &clock_list, node) {
+		err = clk_debugfs_register(c);
+		if (err)
+			goto err_out;
+	}
 	return 0;
+err_out:
+	debugfs_remove(clk_debugfs_root); /* REVISIT: Cleanup correctly */
+	return err;
 }
-subsys_initcall(clk_proc_init);
+late_initcall(clk_debugfs_init);

commit cc96eace48fdf0f8925a74c6c1f7ffa512e458d2
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed May 13 20:28:15 2009 +0900

    sh: clkfwk: rate table construction and rounding for SH7785.
    
    This adds support for constructing a rate table by looking at potential
    divisors for a specified clock. Each FQRMR clock is given its own table.
    Presently each table is rebuilt when the parent propagates down a new
    rate, so some more logic needs to be added to do this more intelligently.
    
    Additionally, a fairly generic round_rate() implementation is then
    layered on top of it, which subsequently provides us with cpufreq support.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 033f4662b59d..56c6e11fa83b 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -63,6 +63,9 @@ void propagate_rate(struct clk *tclk)
 	list_for_each_entry(clkp, &tclk->children, sibling) {
 		if (clkp->ops && clkp->ops->recalc)
 			clkp->rate = clkp->ops->recalc(clkp);
+		if (clkp->ops && clkp->ops->build_rate_table)
+			clkp->ops->build_rate_table(clkp);
+
 		propagate_rate(clkp);
 	}
 }

commit 253b0887b3736160feac9ccdcf146a2073e41463
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed May 13 17:38:11 2009 +0900

    sh: clkfwk: Rework legacy CPG clock handling.
    
    This moves out the old legacy CPG clocks to their own file, and converts
    over the existing users. With these clocks going away and each CPU
    dealing with them on their own, CPUs can gradually move over to the new
    interface.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 0a7755cc8a25..033f4662b59d 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -30,54 +30,12 @@
 #include <linux/platform_device.h>
 #include <linux/proc_fs.h>
 #include <asm/clock.h>
+#include <asm/machvec.h>
 
 static LIST_HEAD(clock_list);
 static DEFINE_SPINLOCK(clock_lock);
 static DEFINE_MUTEX(clock_list_sem);
 
-/*
- * Each subtype is expected to define the init routines for these clocks,
- * as each subtype (or processor family) will have these clocks at the
- * very least. These are all provided through the CPG, which even some of
- * the more quirky parts (such as ST40, SH4-202, etc.) still have.
- *
- * The processor-specific code is expected to register any additional
- * clock sources that are of interest.
- */
-static struct clk master_clk = {
-	.name		= "master_clk",
-	.flags		= CLK_ENABLE_ON_INIT,
-	.rate		= CONFIG_SH_PCLK_FREQ,
-};
-
-static struct clk peripheral_clk = {
-	.name		= "peripheral_clk",
-	.parent		= &master_clk,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-static struct clk bus_clk = {
-	.name		= "bus_clk",
-	.parent		= &master_clk,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-static struct clk cpu_clk = {
-	.name		= "cpu_clk",
-	.parent		= &master_clk,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-/*
- * The ordering of these clocks matters, do not change it.
- */
-static struct clk *onchip_clocks[] = {
-	&master_clk,
-	&peripheral_clk,
-	&bus_clk,
-	&cpu_clk,
-};
-
 /* Used for clocks that always have same value as the parent clock */
 unsigned long followparent_recalc(struct clk *clk)
 {
@@ -443,10 +401,6 @@ void clk_put(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_put);
 
-int __init __weak arch_clk_init(void)
-{
-	return 0;
-}
 
 static int show_clocks(char *buf, char **start, off_t off,
 		       int len, int *eof, void *data)
@@ -533,18 +487,22 @@ subsys_initcall(clk_sysdev_init);
 
 int __init clk_init(void)
 {
-	int i, ret = 0;
-
-	BUG_ON(!master_clk.rate);
-
-	for (i = 0; i < ARRAY_SIZE(onchip_clocks); i++) {
-		struct clk *clk = onchip_clocks[i];
+	int ret;
 
-		arch_init_clk_ops(&clk->ops, i);
-		ret |= clk_register(clk);
+	ret = arch_clk_init();
+	if (unlikely(ret)) {
+		pr_err("%s: CPU clock registration failed.\n", __func__);
+		return ret;
 	}
 
-	ret |= arch_clk_init();
+	if (sh_mv.mv_clk_init) {
+		ret = sh_mv.mv_clk_init();
+		if (unlikely(ret)) {
+			pr_err("%s: machvec clock initialization failed.\n",
+			       __func__);
+			return ret;
+		}
+	}
 
 	/* Kick the child clocks.. */
 	recalculate_root_clocks();

commit 100890c55e326a9acb4429593c5ad2012c194564
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed May 13 17:05:51 2009 +0900

    sh: clkfwk: Provide a generic clk_set_rate_ex() path for root clocks.
    
    In the case of root clocks (such as clkin oscillators, extal, etc.), the
    rate information is entirely platform dependent and needs to be lazily
    set and propagated from the platform code. This provides a method for
    establishing the rate update on these types of clocks that define no
    set_rate() op of their own.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 2ced20f870d1..0a7755cc8a25 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -265,20 +265,27 @@ EXPORT_SYMBOL_GPL(clk_set_rate);
 int clk_set_rate_ex(struct clk *clk, unsigned long rate, int algo_id)
 {
 	int ret = -EOPNOTSUPP;
+	unsigned long flags;
 
-	if (likely(clk->ops && clk->ops->set_rate)) {
-		unsigned long flags;
+	spin_lock_irqsave(&clock_lock, flags);
 
-		spin_lock_irqsave(&clock_lock, flags);
+	if (likely(clk->ops && clk->ops->set_rate)) {
 		ret = clk->ops->set_rate(clk, rate, algo_id);
-		if (ret == 0) {
-			if (clk->ops->recalc)
-				clk->rate = clk->ops->recalc(clk);
-			propagate_rate(clk);
-		}
-		spin_unlock_irqrestore(&clock_lock, flags);
+		if (ret != 0)
+			goto out_unlock;
+	} else {
+		clk->rate = rate;
+		ret = 0;
 	}
 
+	if (clk->ops && clk->ops->recalc)
+		clk->rate = clk->ops->recalc(clk);
+
+	propagate_rate(clk);
+
+out_unlock:
+	spin_unlock_irqrestore(&clock_lock, flags);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(clk_set_rate_ex);

commit d672fef02738582bdeae6e77176e141eeb9169bc
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed May 13 17:03:09 2009 +0900

    sh: clkfwk: Handle NULL clkops for root clocks.
    
    root clocks may simply be placeholders for rate and ancestry information,
    and have no real associated operations of their own. Account for this,
    so we are still able to use these sorts of clocks for rate propagation.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 0eedf9392647..2ced20f870d1 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -103,7 +103,7 @@ void propagate_rate(struct clk *tclk)
 	struct clk *clkp;
 
 	list_for_each_entry(clkp, &tclk->children, sibling) {
-		if (clkp->ops->recalc)
+		if (clkp->ops && clkp->ops->recalc)
 			clkp->rate = clkp->ops->recalc(clkp);
 		propagate_rate(clkp);
 	}
@@ -196,7 +196,7 @@ void recalculate_root_clocks(void)
 	struct clk *clkp;
 
 	list_for_each_entry(clkp, &root_clks, sibling) {
-		if (clkp->ops->recalc)
+		if (clkp->ops && clkp->ops->recalc)
 			clkp->rate = clkp->ops->recalc(clkp);
 		propagate_rate(clkp);
 	}
@@ -224,7 +224,7 @@ int clk_register(struct clk *clk)
 		list_add(&clk->sibling, &root_clks);
 
 	list_add(&clk->node, &clock_list);
-	if (clk->ops->init)
+	if (clk->ops && clk->ops->init)
 		clk->ops->init(clk);
 	mutex_unlock(&clock_list_sem);
 

commit af777ce42d3d51cdef353ce296d6f99dc503feef
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed May 13 16:59:40 2009 +0900

    sh: clkfwk: module_clk -> peripheral_clk rename.
    
    For consistenct naming, and to allow us to fix up some confusion in the
    SH-Mobile clock framework, amongst other places.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 61ff227561dc..0eedf9392647 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -50,8 +50,8 @@ static struct clk master_clk = {
 	.rate		= CONFIG_SH_PCLK_FREQ,
 };
 
-static struct clk module_clk = {
-	.name		= "module_clk",
+static struct clk peripheral_clk = {
+	.name		= "peripheral_clk",
 	.parent		= &master_clk,
 	.flags		= CLK_ENABLE_ON_INIT,
 };
@@ -73,7 +73,7 @@ static struct clk cpu_clk = {
  */
 static struct clk *onchip_clocks[] = {
 	&master_clk,
-	&module_clk,
+	&peripheral_clk,
 	&bus_clk,
 	&cpu_clk,
 };

commit fd5b12458b25a88eb6f6b56464846d98a45e8928
Merge: 9fe5ee0efb1b 8be5f1a68f2c
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 12 19:54:36 2009 +0900

    Merge branch 'master' into sh/clkfwk

commit 8be5f1a68f2c14082939dd54e7037dcee2eb54f8
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 12 19:53:55 2009 +0900

    sh: Kill off the remnants of the old timer code.
    
    Now with all of the TMU users moved over to the new TMU driver, and the
    old TMU driver killed off, the left-over infrastructure can go along
    with it.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 133dbe403341..f54769f455b1 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -26,7 +26,6 @@
 #include <linux/platform_device.h>
 #include <linux/proc_fs.h>
 #include <asm/clock.h>
-#include <asm/timer.h>
 
 static LIST_HEAD(clock_list);
 static DEFINE_SPINLOCK(clock_lock);

commit 9fe5ee0efb1b1d4a0939bc4252a8427e3337d96a
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 12 19:29:04 2009 +0900

    sh: clkfwk: Use arch_clk_init() for on-chip clock registration.
    
    CPUs registering on-chip clocks should be using arch_clk_init() with the
    new scheme so that the CPUs have the opportunity to establish the
    topology prior to the initial root clock rate propagation. This ensures
    that CPUs with on-chip clocks that use CLK_ENABLE_ON_INIT are properly
    enabled at the initial propagation time, without having to further poke
    the root clocks.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 9e1fc133a473..f833843a194a 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -437,13 +437,7 @@ void clk_put(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_put);
 
-void __init __attribute__ ((weak))
-arch_init_clk_ops(struct clk_ops **ops, int type)
-{
-}
-
-int __init __attribute__ ((weak))
-arch_clk_init(void)
+int __init __weak arch_clk_init(void)
 {
 	return 0;
 }

commit f3f8290cb3fa4aa627321530bb85d5f35e487433
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 12 16:07:40 2009 +0900

    sh: clkfwk: Handle clk_get_sys() returning an ERR_PTR.
    
    clk_get() needs to also perform an IS_ERR() check to see whether
    clk_get_sys() failed or not.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 34707b867760..9e1fc133a473 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -399,7 +399,7 @@ struct clk *clk_get(struct device *dev, const char *id)
 	int idno;
 
 	clk = clk_get_sys(dev_id, id);
-	if (clk)
+	if (clk && !IS_ERR(clk))
 		return clk;
 
 	if (dev == NULL || dev->bus != &platform_bus_type)

commit 0dae89572cbcd5f676ea52a9448d9639d97a53d6
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 12 06:18:09 2009 +0900

    sh: clkfwk: Wire up clk_get_sys() support.
    
    This stubs in clk_get_sys() from the ARM clkdev implementation.
    Tentatively conver the clk_get() lookup code to use this, and once the
    rest of the in-tree users are happy with this, it can replace the
    fallback lookups.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 7a356de99d7d..34707b867760 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -10,6 +10,10 @@
  *
  *  Modified for omap shared clock framework by Tony Lindgren <tony@atomide.com>
  *
+ *  With clkdev bits:
+ *
+ *	Copyright (C) 2008 Russell King.
+ *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
@@ -334,15 +338,70 @@ long clk_round_rate(struct clk *clk, unsigned long rate)
 }
 EXPORT_SYMBOL_GPL(clk_round_rate);
 
+/*
+ * Find the correct struct clk for the device and connection ID.
+ * We do slightly fuzzy matching here:
+ *  An entry with a NULL ID is assumed to be a wildcard.
+ *  If an entry has a device ID, it must match
+ *  If an entry has a connection ID, it must match
+ * Then we take the most specific entry - with the following
+ * order of precidence: dev+con > dev only > con only.
+ */
+static struct clk *clk_find(const char *dev_id, const char *con_id)
+{
+	struct clk_lookup *p;
+	struct clk *clk = NULL;
+	int match, best = 0;
+
+	list_for_each_entry(p, &clock_list, node) {
+		match = 0;
+		if (p->dev_id) {
+			if (!dev_id || strcmp(p->dev_id, dev_id))
+				continue;
+			match += 2;
+		}
+		if (p->con_id) {
+			if (!con_id || strcmp(p->con_id, con_id))
+				continue;
+			match += 1;
+		}
+		if (match == 0)
+			continue;
+
+		if (match > best) {
+			clk = p->clk;
+			best = match;
+		}
+	}
+	return clk;
+}
+
+struct clk *clk_get_sys(const char *dev_id, const char *con_id)
+{
+	struct clk *clk;
+
+	mutex_lock(&clock_list_sem);
+	clk = clk_find(dev_id, con_id);
+	mutex_unlock(&clock_list_sem);
+
+	return clk ? clk : ERR_PTR(-ENOENT);
+}
+EXPORT_SYMBOL_GPL(clk_get_sys);
+
 /*
  * Returns a clock. Note that we first try to use device id on the bus
  * and clock name. If this fails, we try to use clock name only.
  */
 struct clk *clk_get(struct device *dev, const char *id)
 {
+	const char *dev_id = dev ? dev_name(dev) : NULL;
 	struct clk *p, *clk = ERR_PTR(-ENOENT);
 	int idno;
 
+	clk = clk_get_sys(dev_id, id);
+	if (clk)
+		return clk;
+
 	if (dev == NULL || dev->bus != &platform_bus_type)
 		idno = -1;
 	else

commit 007e8363b656768fe3f59c180824ff704680bb25
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 12 06:05:32 2009 +0900

    sh: clkfwk: Kill off clk_recalc_rate().
    
    The only user for this is the SH-Mobile r_clk, which is now added as a
    root clock and can be kicked via propagate_rate() as usual. Given that,
    there is no longer any need for the special clk_recalc_rate(), so we kill
    it off.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index e3d1de8a46fd..7a356de99d7d 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -280,20 +280,6 @@ int clk_set_rate_ex(struct clk *clk, unsigned long rate, int algo_id)
 }
 EXPORT_SYMBOL_GPL(clk_set_rate_ex);
 
-void clk_recalc_rate(struct clk *clk)
-{
-	unsigned long flags;
-
-	if (!clk->ops->recalc)
-		return;
-
-	spin_lock_irqsave(&clock_lock, flags);
-	clk->rate = clk->ops->recalc(clk);
-	propagate_rate(clk);
-	spin_unlock_irqrestore(&clock_lock, flags);
-}
-EXPORT_SYMBOL_GPL(clk_recalc_rate);
-
 int clk_set_parent(struct clk *clk, struct clk *parent)
 {
 	unsigned long flags;

commit aa87aa343f2cd236b5eccd643abd4df918ed5c4f
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 12 05:51:05 2009 +0900

    sh: clkfwk: Improve the generic clk_set_parent() implementation.
    
    This causes the generic clk_set_parent() implementation to be a bit more
    intelligent. A clk_reparent() is added to move the clock over to the new
    parent's sibling list, which then allows the generic rate propagation
    code to succeed. This also becomes a nop if the new and old parents are
    unchanged.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index e027fe5898d6..e3d1de8a46fd 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -81,6 +81,19 @@ unsigned long followparent_recalc(struct clk *clk)
 	return clk->parent->rate;
 }
 
+int clk_reparent(struct clk *child, struct clk *parent)
+{
+	list_del_init(&child->sibling);
+	if (parent)
+		list_add(&child->sibling, &parent->children);
+	child->parent = parent;
+
+	/* now do the debugfs renaming to reattach the child
+	   to the proper parent */
+
+	return 0;
+}
+
 /* Propagate rate to children */
 void propagate_rate(struct clk *tclk)
 {
@@ -288,12 +301,19 @@ int clk_set_parent(struct clk *clk, struct clk *parent)
 
 	if (!parent || !clk)
 		return ret;
+	if (clk->parent == parent)
+		return 0;
 
 	spin_lock_irqsave(&clock_lock, flags);
 	if (clk->usecount == 0) {
 		if (clk->ops->set_parent)
 			ret = clk->ops->set_parent(clk, parent);
+		else
+			ret = clk_reparent(clk, parent);
+
 		if (ret == 0) {
+			pr_debug("clock: set parent of %s to %s (new rate %ld)\n",
+				 clk->name, clk->parent->name, clk->rate);
 			if (clk->ops->recalc)
 				clk->rate = clk->ops->recalc(clk);
 			propagate_rate(clk);

commit ae891a4264c91246c0b4c22be68b9838747ae48d
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 12 05:30:10 2009 +0900

    sh: clkfwk: Fix up the clk_enable() error path.
    
    There are a couple of instances where a clk_enable() can fail, which the
    SH-Mobile code presently handles, but doesn't get reported all the way
    back up. This fixes up the return type so the errors make it all the way
    down to the drivers.
    
    Additionally, we now also error out properly if the parent enable fails.
    Prep work for aggressively turning off unused clocks on boot.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index c683be5ba8b2..e027fe5898d6 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -93,57 +93,78 @@ void propagate_rate(struct clk *tclk)
 	}
 }
 
-static int __clk_enable(struct clk *clk)
+static void __clk_disable(struct clk *clk)
 {
-	if (clk->usecount++ == 0) {
-		if (clk->parent)
-			__clk_enable(clk->parent);
-
-		if (clk->ops && clk->ops->enable)
-			clk->ops->enable(clk);
+	if (clk->usecount == 0) {
+		printk(KERN_ERR "Trying disable clock %s with 0 usecount\n",
+		       clk->name);
+		WARN_ON(1);
+		return;
 	}
 
-	return 0;
+	if (!(--clk->usecount)) {
+		if (likely(clk->ops && clk->ops->disable))
+			clk->ops->disable(clk);
+		if (likely(clk->parent))
+			__clk_disable(clk->parent);
+	}
 }
 
-int clk_enable(struct clk *clk)
+void clk_disable(struct clk *clk)
 {
 	unsigned long flags;
-	int ret;
 
 	if (!clk)
-		return -EINVAL;
+		return;
 
 	spin_lock_irqsave(&clock_lock, flags);
-	ret = __clk_enable(clk);
+	__clk_disable(clk);
 	spin_unlock_irqrestore(&clock_lock, flags);
-
-	return ret;
 }
-EXPORT_SYMBOL_GPL(clk_enable);
+EXPORT_SYMBOL_GPL(clk_disable);
 
-static void __clk_disable(struct clk *clk)
+static int __clk_enable(struct clk *clk)
 {
-	if (clk->usecount > 0 && !(--clk->usecount)) {
-		if (likely(clk->ops && clk->ops->disable))
-			clk->ops->disable(clk);
-		if (likely(clk->parent))
-			__clk_disable(clk->parent);
+	int ret = 0;
+
+	if (clk->usecount++ == 0) {
+		if (clk->parent) {
+			ret = __clk_enable(clk->parent);
+			if (unlikely(ret))
+				goto err;
+		}
+
+		if (clk->ops && clk->ops->enable) {
+			ret = clk->ops->enable(clk);
+			if (ret) {
+				if (clk->parent)
+					__clk_disable(clk->parent);
+				goto err;
+			}
+		}
 	}
+
+	return ret;
+err:
+	clk->usecount--;
+	return ret;
 }
 
-void clk_disable(struct clk *clk)
+int clk_enable(struct clk *clk)
 {
 	unsigned long flags;
+	int ret;
 
 	if (!clk)
-		return;
+		return -EINVAL;
 
 	spin_lock_irqsave(&clock_lock, flags);
-	__clk_disable(clk);
+	ret = __clk_enable(clk);
 	spin_unlock_irqrestore(&clock_lock, flags);
+
+	return ret;
 }
-EXPORT_SYMBOL_GPL(clk_disable);
+EXPORT_SYMBOL_GPL(clk_enable);
 
 static LIST_HEAD(root_clks);
 

commit 4ff29ff8e8723a41e7defd8bc78a7b16cbf940a2
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 12 05:14:53 2009 +0900

    sh: clkfwk: Consolidate the ALWAYS_ENABLED / NEEDS_INIT mess.
    
    There is no real distinction here in behaviour, either a clock needs to
    be enabled on initialiation or not. The ALWAYS_ENABLED flag was always
    intended to only apply to clocks that were physically always on and could
    simply not be disabled at all from software. Unfortunately over time this
    was abused and the meaning became a bit blurry.
    
    So, we kill off both of all of those paths now, as well as the newer
    NEEDS_INIT flag, and consolidate on a CLK_ENABLE_ON_INIT. Clocks that
    need to be enabled on initialization can set this, and it will purposely
    enable them and bump the refcount up.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 0a06df8cde2b..c683be5ba8b2 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -43,26 +43,26 @@ static DEFINE_MUTEX(clock_list_sem);
  */
 static struct clk master_clk = {
 	.name		= "master_clk",
-	.flags		= CLK_ALWAYS_ENABLED,
+	.flags		= CLK_ENABLE_ON_INIT,
 	.rate		= CONFIG_SH_PCLK_FREQ,
 };
 
 static struct clk module_clk = {
 	.name		= "module_clk",
 	.parent		= &master_clk,
-	.flags		= CLK_ALWAYS_ENABLED,
+	.flags		= CLK_ENABLE_ON_INIT,
 };
 
 static struct clk bus_clk = {
 	.name		= "bus_clk",
 	.parent		= &master_clk,
-	.flags		= CLK_ALWAYS_ENABLED,
+	.flags		= CLK_ENABLE_ON_INIT,
 };
 
 static struct clk cpu_clk = {
 	.name		= "cpu_clk",
 	.parent		= &master_clk,
-	.flags		= CLK_ALWAYS_ENABLED,
+	.flags		= CLK_ENABLE_ON_INIT,
 };
 
 /*
@@ -93,39 +93,11 @@ void propagate_rate(struct clk *tclk)
 	}
 }
 
-static void __clk_init(struct clk *clk)
-{
-	/*
-	 * See if this is the first time we're enabling the clock, some
-	 * clocks that are always enabled still require "special"
-	 * initialization. This is especially true if the clock mode
-	 * changes and the clock needs to hunt for the proper set of
-	 * divisors to use before it can effectively recalc.
-	 */
-
-	if (clk->flags & CLK_NEEDS_INIT) {
-		if (clk->ops && clk->ops->init)
-			clk->ops->init(clk);
-
-		clk->flags &= ~CLK_NEEDS_INIT;
-	}
-}
-
 static int __clk_enable(struct clk *clk)
 {
-	if (!clk)
-		return -EINVAL;
-
-	clk->usecount++;
-
-	/* nothing to do if always enabled */
-	if (clk->flags & CLK_ALWAYS_ENABLED)
-		return 0;
-
-	if (clk->usecount == 1) {
-		__clk_init(clk);
-
-		__clk_enable(clk->parent);
+	if (clk->usecount++ == 0) {
+		if (clk->parent)
+			__clk_enable(clk->parent);
 
 		if (clk->ops && clk->ops->enable)
 			clk->ops->enable(clk);
@@ -139,6 +111,9 @@ int clk_enable(struct clk *clk)
 	unsigned long flags;
 	int ret;
 
+	if (!clk)
+		return -EINVAL;
+
 	spin_lock_irqsave(&clock_lock, flags);
 	ret = __clk_enable(clk);
 	spin_unlock_irqrestore(&clock_lock, flags);
@@ -149,21 +124,11 @@ EXPORT_SYMBOL_GPL(clk_enable);
 
 static void __clk_disable(struct clk *clk)
 {
-	if (!clk)
-		return;
-
-	clk->usecount--;
-
-	WARN_ON(clk->usecount < 0);
-
-	if (clk->flags & CLK_ALWAYS_ENABLED)
-		return;
-
-	if (clk->usecount == 0) {
+	if (clk->usecount > 0 && !(--clk->usecount)) {
 		if (likely(clk->ops && clk->ops->disable))
 			clk->ops->disable(clk);
-
-		__clk_disable(clk->parent);
+		if (likely(clk->parent))
+			__clk_disable(clk->parent);
 	}
 }
 
@@ -171,6 +136,9 @@ void clk_disable(struct clk *clk)
 {
 	unsigned long flags;
 
+	if (!clk)
+		return;
+
 	spin_lock_irqsave(&clock_lock, flags);
 	__clk_disable(clk);
 	spin_unlock_irqrestore(&clock_lock, flags);
@@ -211,6 +179,7 @@ int clk_register(struct clk *clk)
 	mutex_lock(&clock_list_sem);
 
 	INIT_LIST_HEAD(&clk->children);
+	clk->usecount = 0;
 
 	if (clk->parent)
 		list_add(&clk->sibling, &clk->parent->children);
@@ -218,19 +187,10 @@ int clk_register(struct clk *clk)
 		list_add(&clk->sibling, &root_clks);
 
 	list_add(&clk->node, &clock_list);
-	clk->usecount = 0;
-	clk->flags |= CLK_NEEDS_INIT;
-
+	if (clk->ops->init)
+		clk->ops->init(clk);
 	mutex_unlock(&clock_list_sem);
 
-	if (clk->flags & CLK_ALWAYS_ENABLED) {
-		__clk_init(clk);
-		pr_debug( "Clock '%s' is ALWAYS_ENABLED\n", clk->name);
-		if (clk->ops && clk->ops->enable)
-			clk->ops->enable(clk);
-		pr_debug( "Enabled.");
-	}
-
 	return 0;
 }
 EXPORT_SYMBOL_GPL(clk_register);
@@ -244,6 +204,15 @@ void clk_unregister(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_unregister);
 
+static void clk_enable_init_clocks(void)
+{
+	struct clk *clkp;
+
+	list_for_each_entry(clkp, &clock_list, node)
+		if (clkp->flags & CLK_ENABLE_ON_INIT)
+			clk_enable(clkp);
+}
+
 unsigned long clk_get_rate(struct clk *clk)
 {
 	return clk->rate;
@@ -404,9 +373,7 @@ static int show_clocks(char *buf, char **start, off_t off,
 
 		p += sprintf(p, "%-12s\t: %ld.%02ldMHz\t%s\n", clk->name,
 			     rate / 1000000, (rate % 1000000) / 10000,
-			     ((clk->flags & CLK_ALWAYS_ENABLED) ||
-			      clk->usecount > 0) ?
-			     "enabled" : "disabled");
+			      (clk->usecount > 0) ?  "enabled" : "disabled");
 	}
 
 	return p - buf;
@@ -496,6 +463,9 @@ int __init clk_init(void)
 	/* Kick the child clocks.. */
 	recalculate_root_clocks();
 
+	/* Enable the necessary init clocks */
+	clk_enable_init_clocks();
+
 	return ret;
 }
 

commit b1f6cfe48c3cb1dfa77db3d2f42f765febaef9bc
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 12 04:27:43 2009 +0900

    sh: clkfwk: refactor rate propagation.
    
    This resyncs the rate propagation strategy with the scheme used by the
    OMAP clock framework. Child clocks are tracked on a list under each
    parent and propagation happens there specifically rather than constantly
    iterating over the global clock list.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 17f6c078e851..0a06df8cde2b 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -1,11 +1,11 @@
 /*
  * arch/sh/kernel/cpu/clock.c - SuperH clock framework
  *
- *  Copyright (C) 2005, 2006, 2007  Paul Mundt
+ *  Copyright (C) 2005 - 2009  Paul Mundt
  *
  * This clock framework is derived from the OMAP version by:
  *
- *	Copyright (C) 2004 - 2005 Nokia Corporation
+ *	Copyright (C) 2004 - 2008 Nokia Corporation
  *	Written by Tuukka Tikkanen <tuukka.tikkanen@elektrobit.com>
  *
  *  Modified for omap shared clock framework by Tony Lindgren <tony@atomide.com>
@@ -43,20 +43,20 @@ static DEFINE_MUTEX(clock_list_sem);
  */
 static struct clk master_clk = {
 	.name		= "master_clk",
-	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+	.flags		= CLK_ALWAYS_ENABLED,
 	.rate		= CONFIG_SH_PCLK_FREQ,
 };
 
 static struct clk module_clk = {
 	.name		= "module_clk",
 	.parent		= &master_clk,
-	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+	.flags		= CLK_ALWAYS_ENABLED,
 };
 
 static struct clk bus_clk = {
 	.name		= "bus_clk",
 	.parent		= &master_clk,
-	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+	.flags		= CLK_ALWAYS_ENABLED,
 };
 
 static struct clk cpu_clk = {
@@ -75,27 +75,24 @@ static struct clk *onchip_clocks[] = {
 	&cpu_clk,
 };
 
+/* Used for clocks that always have same value as the parent clock */
+unsigned long followparent_recalc(struct clk *clk)
+{
+	return clk->parent->rate;
+}
+
 /* Propagate rate to children */
-static void propagate_rate(struct clk *clk)
+void propagate_rate(struct clk *tclk)
 {
 	struct clk *clkp;
 
-	list_for_each_entry(clkp, &clock_list, node) {
-		if (likely(clkp->parent != clk))
-			continue;
-		if (likely(clkp->ops && clkp->ops->recalc))
+	list_for_each_entry(clkp, &tclk->children, sibling) {
+		if (clkp->ops->recalc)
 			clkp->rate = clkp->ops->recalc(clkp);
-		if (unlikely(clkp->flags & CLK_RATE_PROPAGATES))
-			propagate_rate(clkp);
+		propagate_rate(clkp);
 	}
 }
 
-/* Used for clocks that always have same value as the parent clock */
-unsigned long followparent_recalc(struct clk *clk)
-{
-	return clk->parent->rate;
-}
-
 static void __clk_init(struct clk *clk)
 {
 	/*
@@ -180,10 +177,46 @@ void clk_disable(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_disable);
 
+static LIST_HEAD(root_clks);
+
+/**
+ * recalculate_root_clocks - recalculate and propagate all root clocks
+ *
+ * Recalculates all root clocks (clocks with no parent), which if the
+ * clock's .recalc is set correctly, should also propagate their rates.
+ * Called at init.
+ */
+void recalculate_root_clocks(void)
+{
+	struct clk *clkp;
+
+	list_for_each_entry(clkp, &root_clks, sibling) {
+		if (clkp->ops->recalc)
+			clkp->rate = clkp->ops->recalc(clkp);
+		propagate_rate(clkp);
+	}
+}
+
 int clk_register(struct clk *clk)
 {
+	if (clk == NULL || IS_ERR(clk))
+		return -EINVAL;
+
+	/*
+	 * trap out already registered clocks
+	 */
+	if (clk->node.next || clk->node.prev)
+		return 0;
+
 	mutex_lock(&clock_list_sem);
 
+	INIT_LIST_HEAD(&clk->children);
+
+	if (clk->parent)
+		list_add(&clk->sibling, &clk->parent->children);
+	else
+		list_add(&clk->sibling, &root_clks);
+
 	list_add(&clk->node, &clock_list);
 	clk->usecount = 0;
 	clk->flags |= CLK_NEEDS_INIT;
@@ -205,6 +238,7 @@ EXPORT_SYMBOL_GPL(clk_register);
 void clk_unregister(struct clk *clk)
 {
 	mutex_lock(&clock_list_sem);
+	list_del(&clk->sibling);
 	list_del(&clk->node);
 	mutex_unlock(&clock_list_sem);
 }
@@ -231,50 +265,53 @@ int clk_set_rate_ex(struct clk *clk, unsigned long rate, int algo_id)
 
 		spin_lock_irqsave(&clock_lock, flags);
 		ret = clk->ops->set_rate(clk, rate, algo_id);
+		if (ret == 0) {
+			if (clk->ops->recalc)
+				clk->rate = clk->ops->recalc(clk);
+			propagate_rate(clk);
+		}
 		spin_unlock_irqrestore(&clock_lock, flags);
 	}
 
-	if (unlikely(clk->flags & CLK_RATE_PROPAGATES))
-		propagate_rate(clk);
-
 	return ret;
 }
 EXPORT_SYMBOL_GPL(clk_set_rate_ex);
 
 void clk_recalc_rate(struct clk *clk)
 {
-	if (likely(clk->ops && clk->ops->recalc)) {
-		unsigned long flags;
+	unsigned long flags;
 
-		spin_lock_irqsave(&clock_lock, flags);
-		clk->rate = clk->ops->recalc(clk);
-		spin_unlock_irqrestore(&clock_lock, flags);
-	}
+	if (!clk->ops->recalc)
+		return;
 
-	if (unlikely(clk->flags & CLK_RATE_PROPAGATES))
-		propagate_rate(clk);
+	spin_lock_irqsave(&clock_lock, flags);
+	clk->rate = clk->ops->recalc(clk);
+	propagate_rate(clk);
+	spin_unlock_irqrestore(&clock_lock, flags);
 }
 EXPORT_SYMBOL_GPL(clk_recalc_rate);
 
 int clk_set_parent(struct clk *clk, struct clk *parent)
 {
+	unsigned long flags;
 	int ret = -EINVAL;
-	struct clk *old;
 
 	if (!parent || !clk)
 		return ret;
 
-	old = clk->parent;
-	if (likely(clk->ops && clk->ops->set_parent)) {
-		unsigned long flags;
-		spin_lock_irqsave(&clock_lock, flags);
-		ret = clk->ops->set_parent(clk, parent);
-		spin_unlock_irqrestore(&clock_lock, flags);
-		clk->parent = (ret ? old : parent);
-	}
+	spin_lock_irqsave(&clock_lock, flags);
+	if (clk->usecount == 0) {
+		if (clk->ops->set_parent)
+			ret = clk->ops->set_parent(clk, parent);
+		if (ret == 0) {
+			if (clk->ops->recalc)
+				clk->rate = clk->ops->recalc(clk);
+			propagate_rate(clk);
+		}
+	} else
+		ret = -EBUSY;
+	spin_unlock_irqrestore(&clock_lock, flags);
 
-	if (unlikely(clk->flags & CLK_RATE_PROPAGATES))
-		propagate_rate(clk);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(clk_set_parent);
@@ -457,8 +494,7 @@ int __init clk_init(void)
 	ret |= arch_clk_init();
 
 	/* Kick the child clocks.. */
-	propagate_rate(&master_clk);
-	propagate_rate(&bus_clk);
+	recalculate_root_clocks();
 
 	return ret;
 }

commit a02cb230bb4fca04f091746c593de720a0e3a94a
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 12 03:50:44 2009 +0900

    sh: clkfwk: Add a followparent_recalc() helper.
    
    This adds a followparent_recalc() helper for clocks that just follow the
    parent's rate. Switch over the few CPUs that use this scheme for some of
    their clocks.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index b022affb44cd..17f6c078e851 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -90,6 +90,12 @@ static void propagate_rate(struct clk *clk)
 	}
 }
 
+/* Used for clocks that always have same value as the parent clock */
+unsigned long followparent_recalc(struct clk *clk)
+{
+	return clk->parent->rate;
+}
+
 static void __clk_init(struct clk *clk)
 {
 	/*

commit b68d8201433a91cabbcbeae48b53d8c1c426433a
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 12 03:45:08 2009 +0900

    sh: clkfwk: Make recalc return an unsigned long.
    
    This is prep work for cleaning up some of the rate propagation bits.
    Trivial conversion.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 133dbe403341..b022affb44cd 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -75,6 +75,7 @@ static struct clk *onchip_clocks[] = {
 	&cpu_clk,
 };
 
+/* Propagate rate to children */
 static void propagate_rate(struct clk *clk)
 {
 	struct clk *clkp;
@@ -83,7 +84,7 @@ static void propagate_rate(struct clk *clk)
 		if (likely(clkp->parent != clk))
 			continue;
 		if (likely(clkp->ops && clkp->ops->recalc))
-			clkp->ops->recalc(clkp);
+			clkp->rate = clkp->ops->recalc(clkp);
 		if (unlikely(clkp->flags & CLK_RATE_PROPAGATES))
 			propagate_rate(clkp);
 	}
@@ -240,7 +241,7 @@ void clk_recalc_rate(struct clk *clk)
 		unsigned long flags;
 
 		spin_lock_irqsave(&clock_lock, flags);
-		clk->ops->recalc(clk);
+		clk->rate = clk->ops->recalc(clk);
 		spin_unlock_irqrestore(&clock_lock, flags);
 	}
 
@@ -377,20 +378,22 @@ static int clks_sysdev_suspend(struct sys_device *dev, pm_message_t state)
 	switch (state.event) {
 	case PM_EVENT_ON:
 		/* Resumeing from hibernation */
-		if (prev_state.event == PM_EVENT_FREEZE) {
-			list_for_each_entry(clkp, &clock_list, node)
-				if (likely(clkp->ops)) {
-					unsigned long rate = clkp->rate;
-
-					if (likely(clkp->ops->set_parent))
-						clkp->ops->set_parent(clkp,
-							clkp->parent);
-					if (likely(clkp->ops->set_rate))
-						clkp->ops->set_rate(clkp,
-							rate, NO_CHANGE);
-					else if (likely(clkp->ops->recalc))
-						clkp->ops->recalc(clkp);
-					}
+		if (prev_state.event != PM_EVENT_FREEZE)
+			break;
+
+		list_for_each_entry(clkp, &clock_list, node) {
+			if (likely(clkp->ops)) {
+				unsigned long rate = clkp->rate;
+
+				if (likely(clkp->ops->set_parent))
+					clkp->ops->set_parent(clkp,
+						clkp->parent);
+				if (likely(clkp->ops->set_rate))
+					clkp->ops->set_rate(clkp,
+						rate, NO_CHANGE);
+				else if (likely(clkp->ops->recalc))
+					clkp->rate = clkp->ops->recalc(clkp);
+			}
 		}
 		break;
 	case PM_EVENT_FREEZE:

commit 4f5ecaa05493dfddf155b40224b951592bfce325
Author: Magnus Damm <damm@igel.co.jp>
Date:   Fri May 8 08:23:29 2009 +0000

    sh: clock framework update, fix count and kill off kref
    
    This patch updates the clock framework use count code.
    With this patch the enable() and disable() callbacks
    only get called when counting from and to zero.
    While at it the kref stuff gets replaced with an int.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 099373ae57d8..133dbe403341 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -19,7 +19,6 @@
 #include <linux/module.h>
 #include <linux/mutex.h>
 #include <linux/list.h>
-#include <linux/kref.h>
 #include <linux/kobject.h>
 #include <linux/sysdev.h>
 #include <linux/seq_file.h>
@@ -90,7 +89,7 @@ static void propagate_rate(struct clk *clk)
 	}
 }
 
-static int __clk_enable(struct clk *clk)
+static void __clk_init(struct clk *clk)
 {
 	/*
 	 * See if this is the first time we're enabling the clock, some
@@ -100,19 +99,33 @@ static int __clk_enable(struct clk *clk)
 	 * divisors to use before it can effectively recalc.
 	 */
 
-	if (clk->flags & CLK_ALWAYS_ENABLED) {
-		kref_get(&clk->kref);
-		return 0;
-	}
-
-	if (unlikely(atomic_read(&clk->kref.refcount) == 1))
+	if (clk->flags & CLK_NEEDS_INIT) {
 		if (clk->ops && clk->ops->init)
 			clk->ops->init(clk);
 
-	kref_get(&clk->kref);
+		clk->flags &= ~CLK_NEEDS_INIT;
+	}
+}
+
+static int __clk_enable(struct clk *clk)
+{
+	if (!clk)
+		return -EINVAL;
+
+	clk->usecount++;
+
+	/* nothing to do if always enabled */
+	if (clk->flags & CLK_ALWAYS_ENABLED)
+		return 0;
+
+	if (clk->usecount == 1) {
+		__clk_init(clk);
 
-	if (likely(clk->ops && clk->ops->enable))
-		clk->ops->enable(clk);
+		__clk_enable(clk->parent);
+
+		if (clk->ops && clk->ops->enable)
+			clk->ops->enable(clk);
+	}
 
 	return 0;
 }
@@ -122,11 +135,6 @@ int clk_enable(struct clk *clk)
 	unsigned long flags;
 	int ret;
 
-	if (!clk)
-		return -EINVAL;
-
-	clk_enable(clk->parent);
-
 	spin_lock_irqsave(&clock_lock, flags);
 	ret = __clk_enable(clk);
 	spin_unlock_irqrestore(&clock_lock, flags);
@@ -135,21 +143,23 @@ int clk_enable(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_enable);
 
-static void clk_kref_release(struct kref *kref)
-{
-	/* Nothing to do */
-}
-
 static void __clk_disable(struct clk *clk)
 {
-	int count = kref_put(&clk->kref, clk_kref_release);
+	if (!clk)
+		return;
+
+	clk->usecount--;
+
+	WARN_ON(clk->usecount < 0);
 
 	if (clk->flags & CLK_ALWAYS_ENABLED)
 		return;
 
-	if (!count) {	/* count reaches zero, disable the clock */
+	if (clk->usecount == 0) {
 		if (likely(clk->ops && clk->ops->disable))
 			clk->ops->disable(clk);
+
+		__clk_disable(clk->parent);
 	}
 }
 
@@ -157,14 +167,9 @@ void clk_disable(struct clk *clk)
 {
 	unsigned long flags;
 
-	if (!clk)
-		return;
-
 	spin_lock_irqsave(&clock_lock, flags);
 	__clk_disable(clk);
 	spin_unlock_irqrestore(&clock_lock, flags);
-
-	clk_disable(clk->parent);
 }
 EXPORT_SYMBOL_GPL(clk_disable);
 
@@ -173,14 +178,14 @@ int clk_register(struct clk *clk)
 	mutex_lock(&clock_list_sem);
 
 	list_add(&clk->node, &clock_list);
-	kref_init(&clk->kref);
+	clk->usecount = 0;
+	clk->flags |= CLK_NEEDS_INIT;
 
 	mutex_unlock(&clock_list_sem);
 
 	if (clk->flags & CLK_ALWAYS_ENABLED) {
+		__clk_init(clk);
 		pr_debug( "Clock '%s' is ALWAYS_ENABLED\n", clk->name);
-		if (clk->ops && clk->ops->init)
-			clk->ops->init(clk);
 		if (clk->ops && clk->ops->enable)
 			clk->ops->enable(clk);
 		pr_debug( "Enabled.");
@@ -356,7 +361,7 @@ static int show_clocks(char *buf, char **start, off_t off,
 		p += sprintf(p, "%-12s\t: %ld.%02ldMHz\t%s\n", clk->name,
 			     rate / 1000000, (rate % 1000000) / 10000,
 			     ((clk->flags & CLK_ALWAYS_ENABLED) ||
-			      (atomic_read(&clk->kref.refcount) != 1)) ?
+			      clk->usecount > 0) ?
 			     "enabled" : "disabled");
 	}
 

commit b3cacf318172757783d8272fc333284dd4f50140
Author: Magnus Damm <damm@igel.co.jp>
Date:   Thu May 7 10:31:39 2009 +0000

    sh: call clock framework init() callback once
    
    Make sure that clk->ops->init() only gets called once in
    the case of CLK_ALWAYS_ENABLED. Without this patch the
    init() callback may be called multiple times.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 1dc896483b59..099373ae57d8 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -99,15 +99,18 @@ static int __clk_enable(struct clk *clk)
 	 * changes and the clock needs to hunt for the proper set of
 	 * divisors to use before it can effectively recalc.
 	 */
+
+	if (clk->flags & CLK_ALWAYS_ENABLED) {
+		kref_get(&clk->kref);
+		return 0;
+	}
+
 	if (unlikely(atomic_read(&clk->kref.refcount) == 1))
 		if (clk->ops && clk->ops->init)
 			clk->ops->init(clk);
 
 	kref_get(&clk->kref);
 
-	if (clk->flags & CLK_ALWAYS_ENABLED)
-		return 0;
-
 	if (likely(clk->ops && clk->ops->enable))
 		clk->ops->enable(clk);
 

commit 50cca715a64b66ccf173767d94d4020ea0a6129c
Author: Francesco VIRLINZI <francesco.virlinzi@st.com>
Date:   Fri Mar 13 08:08:01 2009 +0000

    sh: clkfwk: Safer resume from hibernation.
    
    This patch fixes a possible problem in the resume from
    hibenration. It temporaneally saves the clk->rate on the
    stack to avoid any possible change during the clk->set_parent(..)
    call.
    
    Signed-off-by: Francesco Virlinzi <francesco.virlinzi@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 3209a8740fa4..1dc896483b59 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -372,12 +372,14 @@ static int clks_sysdev_suspend(struct sys_device *dev, pm_message_t state)
 		if (prev_state.event == PM_EVENT_FREEZE) {
 			list_for_each_entry(clkp, &clock_list, node)
 				if (likely(clkp->ops)) {
+					unsigned long rate = clkp->rate;
+
 					if (likely(clkp->ops->set_parent))
 						clkp->ops->set_parent(clkp,
 							clkp->parent);
 					if (likely(clkp->ops->set_rate))
 						clkp->ops->set_rate(clkp,
-							clkp->rate, NO_CHANGE);
+							rate, NO_CHANGE);
 					else if (likely(clkp->ops->recalc))
 						clkp->ops->recalc(clkp);
 					}

commit 4a55026fd7a08074676e87932578ff9e327e82a3
Author: Francesco VIRLINZI <francesco.virlinzi@st.com>
Date:   Wed Mar 11 07:42:05 2009 +0000

    sh: clkfwk: Add resume from hibernation support.
    
    This patch adds PM support to the clock framework.
    With this, resume from hibernation is properly supported.
    
    Signed-off-by: Francesco Virlinzi <francesco.virlinzi@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 332a1798547c..3209a8740fa4 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -20,6 +20,8 @@
 #include <linux/mutex.h>
 #include <linux/list.h>
 #include <linux/kref.h>
+#include <linux/kobject.h>
+#include <linux/sysdev.h>
 #include <linux/seq_file.h>
 #include <linux/err.h>
 #include <linux/platform_device.h>
@@ -358,6 +360,68 @@ static int show_clocks(char *buf, char **start, off_t off,
 	return p - buf;
 }
 
+#ifdef CONFIG_PM
+static int clks_sysdev_suspend(struct sys_device *dev, pm_message_t state)
+{
+	static pm_message_t prev_state;
+	struct clk *clkp;
+
+	switch (state.event) {
+	case PM_EVENT_ON:
+		/* Resumeing from hibernation */
+		if (prev_state.event == PM_EVENT_FREEZE) {
+			list_for_each_entry(clkp, &clock_list, node)
+				if (likely(clkp->ops)) {
+					if (likely(clkp->ops->set_parent))
+						clkp->ops->set_parent(clkp,
+							clkp->parent);
+					if (likely(clkp->ops->set_rate))
+						clkp->ops->set_rate(clkp,
+							clkp->rate, NO_CHANGE);
+					else if (likely(clkp->ops->recalc))
+						clkp->ops->recalc(clkp);
+					}
+		}
+		break;
+	case PM_EVENT_FREEZE:
+		break;
+	case PM_EVENT_SUSPEND:
+		break;
+	}
+
+	prev_state = state;
+	return 0;
+}
+
+static int clks_sysdev_resume(struct sys_device *dev)
+{
+	return clks_sysdev_suspend(dev, PMSG_ON);
+}
+
+static struct sysdev_class clks_sysdev_class = {
+	.name = "clks",
+};
+
+static struct sysdev_driver clks_sysdev_driver = {
+	.suspend = clks_sysdev_suspend,
+	.resume = clks_sysdev_resume,
+};
+
+static struct sys_device clks_sysdev_dev = {
+	.cls = &clks_sysdev_class,
+};
+
+static int __init clk_sysdev_init(void)
+{
+	sysdev_class_register(&clks_sysdev_class);
+	sysdev_driver_register(&clks_sysdev_class, &clks_sysdev_driver);
+	sysdev_register(&clks_sysdev_dev);
+
+	return 0;
+}
+subsys_initcall(clk_sysdev_init);
+#endif
+
 int __init clk_init(void)
 {
 	int i, ret = 0;

commit d680c76eccd9222031ee30dcee5fdedba2467610
Author: Francesco VIRLINZI <francesco.virlinzi@st.com>
Date:   Wed Mar 11 07:40:54 2009 +0000

    sh: clkfwk: add clk_set_parent/clk_get_parent
    
    This patch adds the clk_set_parent/clk_get_parent routines to the sh
    clock framework.
    
    Signed-off-by: Francesco Virlinzi <francesco.virlinzi@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 7b17137536d6..332a1798547c 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -239,6 +239,35 @@ void clk_recalc_rate(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_recalc_rate);
 
+int clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	int ret = -EINVAL;
+	struct clk *old;
+
+	if (!parent || !clk)
+		return ret;
+
+	old = clk->parent;
+	if (likely(clk->ops && clk->ops->set_parent)) {
+		unsigned long flags;
+		spin_lock_irqsave(&clock_lock, flags);
+		ret = clk->ops->set_parent(clk, parent);
+		spin_unlock_irqrestore(&clock_lock, flags);
+		clk->parent = (ret ? old : parent);
+	}
+
+	if (unlikely(clk->flags & CLK_RATE_PROPAGATES))
+		propagate_rate(clk);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(clk_set_parent);
+
+struct clk *clk_get_parent(struct clk *clk)
+{
+	return clk->parent;
+}
+EXPORT_SYMBOL_GPL(clk_get_parent);
+
 long clk_round_rate(struct clk *clk, unsigned long rate)
 {
 	if (likely(clk->ops && clk->ops->round_rate)) {

commit 00e825c6b99b39f12751ea45d38bb4d900de70f4
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Nov 18 14:21:34 2008 +0900

    sh: Fix clock framework compiler warnings.
    
      CC      arch/sh/kernel/cpu/clock.o
      arch/sh/kernel/cpu/clock.c: In function 'clk_disable':
      arch/sh/kernel/cpu/clock.c:156: warning: 'return' with a value, in function returning void
    
    Introduced by ("sh: enable and disable clocks recursively").
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 717056b3d400..7b17137536d6 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -153,7 +153,7 @@ void clk_disable(struct clk *clk)
 	unsigned long flags;
 
 	if (!clk)
-		return -EINVAL;
+		return;
 
 	spin_lock_irqsave(&clock_lock, flags);
 	__clk_disable(clk);

commit d12cfac146d2b512496bf974b83ee1210032065f
Author: Magnus Damm <damm@igel.co.jp>
Date:   Fri Oct 31 20:13:32 2008 +0900

    sh: enable and disable clocks recursively
    
    Recurse and make sure parent clocks get enabled/disabled.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index b7e46d5bba43..717056b3d400 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -117,6 +117,11 @@ int clk_enable(struct clk *clk)
 	unsigned long flags;
 	int ret;
 
+	if (!clk)
+		return -EINVAL;
+
+	clk_enable(clk->parent);
+
 	spin_lock_irqsave(&clock_lock, flags);
 	ret = __clk_enable(clk);
 	spin_unlock_irqrestore(&clock_lock, flags);
@@ -147,9 +152,14 @@ void clk_disable(struct clk *clk)
 {
 	unsigned long flags;
 
+	if (!clk)
+		return -EINVAL;
+
 	spin_lock_irqsave(&clock_lock, flags);
 	__clk_disable(clk);
 	spin_unlock_irqrestore(&clock_lock, flags);
+
+	clk_disable(clk->parent);
 }
 EXPORT_SYMBOL_GPL(clk_disable);
 

commit fa43972fab24a3c050e880a7831f9378c6cebc0b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Sep 4 18:53:58 2008 +0900

    sh: fixup many sparse errors.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index f5eb56e6bc59..b7e46d5bba43 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -294,9 +294,10 @@ arch_init_clk_ops(struct clk_ops **ops, int type)
 {
 }
 
-void __init __attribute__ ((weak))
+int __init __attribute__ ((weak))
 arch_clk_init(void)
 {
+	return 0;
 }
 
 static int show_clocks(char *buf, char **start, off_t off,
@@ -331,7 +332,7 @@ int __init clk_init(void)
 		ret |= clk_register(clk);
 	}
 
-	arch_clk_init();
+	ret |= arch_clk_init();
 
 	/* Kick the child clocks.. */
 	propagate_rate(&master_clk);

commit 152fe36ebee82b63a9c6e510c52aaa82f4b1940d
Author: Magnus Damm <damm@igel.co.jp>
Date:   Thu Jul 17 19:05:54 2008 +0900

    sh: Show all clocks and their state in /proc/clocks
    
    Show all clocks in /proc/clocks, and also show if they are enabled or
    disabled. This is useful to show MSTPCR bits on SuperH Mobile processors.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 73334c689e9d..f5eb56e6bc59 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -308,15 +308,11 @@ static int show_clocks(char *buf, char **start, off_t off,
 	list_for_each_entry_reverse(clk, &clock_list, node) {
 		unsigned long rate = clk_get_rate(clk);
 
-		/*
-		 * Don't bother listing dummy clocks with no ancestry
-		 * that only support enable and disable ops.
-		 */
-		if (unlikely(!rate && !clk->parent))
-			continue;
-
-		p += sprintf(p, "%-12s\t: %ld.%02ldMHz\n", clk->name,
-			     rate / 1000000, (rate % 1000000) / 10000);
+		p += sprintf(p, "%-12s\t: %ld.%02ldMHz\t%s\n", clk->name,
+			     rate / 1000000, (rate % 1000000) / 10000,
+			     ((clk->flags & CLK_ALWAYS_ENABLED) ||
+			      (atomic_read(&clk->kref.refcount) != 1)) ?
+			     "enabled" : "disabled");
 	}
 
 	return p - buf;

commit 4c1cfab1e0f9a41246cfdcca78f3700fb67f0a5c
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Jun 18 03:36:50 2008 +0300

    sh/kernel/ cleanups
    
    This patch contains the following cleanups:
    - make the following needlessly global code static:
      - cf-enabler.c: cf_init()
      - cpu/clock.c: __clk_enable()
      - cpu/clock.c: __clk_disable()
      - process_32.c: default_idle()
      - time_32.c: struct clocksource_sh
      - timers/timer-tmu.c: struct tmu_timer_ops
    - remove the following unused functions (no CONFIG_BLK_DEV_FD on sh):
      - process_{32,64}.c: disable_hlt()
      - process_{32,64}.c: enable_hlt()
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index b5f1e23ed57c..73334c689e9d 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -88,7 +88,7 @@ static void propagate_rate(struct clk *clk)
 	}
 }
 
-int __clk_enable(struct clk *clk)
+static int __clk_enable(struct clk *clk)
 {
 	/*
 	 * See if this is the first time we're enabling the clock, some
@@ -111,7 +111,6 @@ int __clk_enable(struct clk *clk)
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(__clk_enable);
 
 int clk_enable(struct clk *clk)
 {
@@ -131,7 +130,7 @@ static void clk_kref_release(struct kref *kref)
 	/* Nothing to do */
 }
 
-void __clk_disable(struct clk *clk)
+static void __clk_disable(struct clk *clk)
 {
 	int count = kref_put(&clk->kref, clk_kref_release);
 
@@ -143,7 +142,6 @@ void __clk_disable(struct clk *clk)
 			clk->ops->disable(clk);
 	}
 }
-EXPORT_SYMBOL_GPL(__clk_disable);
 
 void clk_disable(struct clk *clk)
 {

commit 24eb17e0813490497f4d5b2fad218bdba402cece
Author: Stuart Menefy <stuart.menefy@st.com>
Date:   Fri Sep 28 11:51:52 2007 +0900

    sh: clkfwk: Support multi-level clock propagation.
    
    Currently clock propagation only works for one level, but we have some
    clocks which need to propagate multiple levels, so make this recursive.
    
    Signed-off-by: Stuart Menefy <stuart.menefy@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 92807ffa8e20..b5f1e23ed57c 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -83,6 +83,8 @@ static void propagate_rate(struct clk *clk)
 			continue;
 		if (likely(clkp->ops && clkp->ops->recalc))
 			clkp->ops->recalc(clkp);
+		if (unlikely(clkp->flags & CLK_RATE_PROPAGATES))
+			propagate_rate(clkp);
 	}
 }
 

commit f6991b0456416186b578d38717efcda2b012b79c
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Jul 20 13:29:09 2007 +0900

    sh: Implement clk_round_rate() in the clock framework.
    
    This is an optional component of the clock framework. However,
    as we're going to be using this in the cpufreq drivers, add
    support for it to the framework.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 63251549e9a8..92807ffa8e20 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -229,6 +229,22 @@ void clk_recalc_rate(struct clk *clk)
 }
 EXPORT_SYMBOL_GPL(clk_recalc_rate);
 
+long clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	if (likely(clk->ops && clk->ops->round_rate)) {
+		unsigned long flags, rounded;
+
+		spin_lock_irqsave(&clock_lock, flags);
+		rounded = clk->ops->round_rate(clk, rate);
+		spin_unlock_irqrestore(&clock_lock, flags);
+
+		return rounded;
+	}
+
+	return clk_get_rate(clk);
+}
+EXPORT_SYMBOL_GPL(clk_round_rate);
+
 /*
  * Returns a clock. Note that we first try to use device id on the bus
  * and clock name. If this fails, we try to use clock name only.

commit dfbbbe92956b849a6704dbd5352348d6ba1165da
Author: dmitry pervushin <dimka@nomadgs.com>
Date:   Tue May 15 08:42:22 2007 +0900

    sh: Fix clock multiplier on SH7722.
    
    This fixes up the master clock multiplier and initial rate
    propagation for the SH7722 clocks.
    
    Signed-off-by: dmitry pervushin <dimka@nomadgs.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 014f318f5a05..63251549e9a8 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -278,6 +278,11 @@ arch_init_clk_ops(struct clk_ops **ops, int type)
 {
 }
 
+void __init __attribute__ ((weak))
+arch_clk_init(void)
+{
+}
+
 static int show_clocks(char *buf, char **start, off_t off,
 		       int len, int *eof, void *data)
 {
@@ -314,6 +319,8 @@ int __init clk_init(void)
 		ret |= clk_register(clk);
 	}
 
+	arch_clk_init();
+
 	/* Kick the child clocks.. */
 	propagate_rate(&master_clk);
 	propagate_rate(&bus_clk);

commit db62e5bd297d1f325811c5495ad23de36db0fdd4
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Apr 26 12:17:20 2007 +0900

    sh: Move clock reporting to its own proc entry.
    
    Previously this was done in cpuinfo, but with the number of clocks
    growing, it makes more sense to place this in a different proc entry.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 2075f90d76c7..014f318f5a05 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -1,7 +1,7 @@
 /*
  * arch/sh/kernel/cpu/clock.c - SuperH clock framework
  *
- *  Copyright (C) 2005, 2006  Paul Mundt
+ *  Copyright (C) 2005, 2006, 2007  Paul Mundt
  *
  * This clock framework is derived from the OMAP version by:
  *
@@ -23,6 +23,7 @@
 #include <linux/seq_file.h>
 #include <linux/err.h>
 #include <linux/platform_device.h>
+#include <linux/proc_fs.h>
 #include <asm/clock.h>
 #include <asm/timer.h>
 
@@ -108,6 +109,7 @@ int __clk_enable(struct clk *clk)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(__clk_enable);
 
 int clk_enable(struct clk *clk)
 {
@@ -120,6 +122,7 @@ int clk_enable(struct clk *clk)
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(clk_enable);
 
 static void clk_kref_release(struct kref *kref)
 {
@@ -138,6 +141,7 @@ void __clk_disable(struct clk *clk)
 			clk->ops->disable(clk);
 	}
 }
+EXPORT_SYMBOL_GPL(__clk_disable);
 
 void clk_disable(struct clk *clk)
 {
@@ -147,6 +151,7 @@ void clk_disable(struct clk *clk)
 	__clk_disable(clk);
 	spin_unlock_irqrestore(&clock_lock, flags);
 }
+EXPORT_SYMBOL_GPL(clk_disable);
 
 int clk_register(struct clk *clk)
 {
@@ -168,6 +173,7 @@ int clk_register(struct clk *clk)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(clk_register);
 
 void clk_unregister(struct clk *clk)
 {
@@ -175,16 +181,19 @@ void clk_unregister(struct clk *clk)
 	list_del(&clk->node);
 	mutex_unlock(&clock_list_sem);
 }
+EXPORT_SYMBOL_GPL(clk_unregister);
 
-inline unsigned long clk_get_rate(struct clk *clk)
+unsigned long clk_get_rate(struct clk *clk)
 {
 	return clk->rate;
 }
+EXPORT_SYMBOL_GPL(clk_get_rate);
 
 int clk_set_rate(struct clk *clk, unsigned long rate)
 {
 	return clk_set_rate_ex(clk, rate, 0);
 }
+EXPORT_SYMBOL_GPL(clk_set_rate);
 
 int clk_set_rate_ex(struct clk *clk, unsigned long rate, int algo_id)
 {
@@ -203,6 +212,7 @@ int clk_set_rate_ex(struct clk *clk, unsigned long rate, int algo_id)
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(clk_set_rate_ex);
 
 void clk_recalc_rate(struct clk *clk)
 {
@@ -217,6 +227,7 @@ void clk_recalc_rate(struct clk *clk)
 	if (unlikely(clk->flags & CLK_RATE_PROPAGATES))
 		propagate_rate(clk);
 }
+EXPORT_SYMBOL_GPL(clk_recalc_rate);
 
 /*
  * Returns a clock. Note that we first try to use device id on the bus
@@ -253,18 +264,43 @@ struct clk *clk_get(struct device *dev, const char *id)
 
 	return clk;
 }
+EXPORT_SYMBOL_GPL(clk_get);
 
 void clk_put(struct clk *clk)
 {
 	if (clk && !IS_ERR(clk))
 		module_put(clk->owner);
 }
+EXPORT_SYMBOL_GPL(clk_put);
 
 void __init __attribute__ ((weak))
 arch_init_clk_ops(struct clk_ops **ops, int type)
 {
 }
 
+static int show_clocks(char *buf, char **start, off_t off,
+		       int len, int *eof, void *data)
+{
+	struct clk *clk;
+	char *p = buf;
+
+	list_for_each_entry_reverse(clk, &clock_list, node) {
+		unsigned long rate = clk_get_rate(clk);
+
+		/*
+		 * Don't bother listing dummy clocks with no ancestry
+		 * that only support enable and disable ops.
+		 */
+		if (unlikely(!rate && !clk->parent))
+			continue;
+
+		p += sprintf(p, "%-12s\t: %ld.%02ldMHz\n", clk->name,
+			     rate / 1000000, (rate % 1000000) / 10000);
+	}
+
+	return p - buf;
+}
+
 int __init clk_init(void)
 {
 	int i, ret = 0;
@@ -285,36 +321,14 @@ int __init clk_init(void)
 	return ret;
 }
 
-int show_clocks(struct seq_file *m)
+static int __init clk_proc_init(void)
 {
-	struct clk *clk;
-
-	list_for_each_entry_reverse(clk, &clock_list, node) {
-		unsigned long rate = clk_get_rate(clk);
-
-		/*
-		 * Don't bother listing dummy clocks with no ancestry
-		 * that only support enable and disable ops.
-		 */
-		if (unlikely(!rate && !clk->parent))
-			continue;
-
-		seq_printf(m, "%-12s\t: %ld.%02ldMHz\n", clk->name,
-			   rate / 1000000, (rate % 1000000) / 10000);
-	}
+	struct proc_dir_entry *p;
+	p = create_proc_read_entry("clocks", S_IRUSR, NULL,
+				   show_clocks, NULL);
+	if (unlikely(!p))
+		return -EINVAL;
 
 	return 0;
 }
-
-EXPORT_SYMBOL_GPL(clk_register);
-EXPORT_SYMBOL_GPL(clk_unregister);
-EXPORT_SYMBOL_GPL(clk_get);
-EXPORT_SYMBOL_GPL(clk_put);
-EXPORT_SYMBOL_GPL(clk_enable);
-EXPORT_SYMBOL_GPL(clk_disable);
-EXPORT_SYMBOL_GPL(__clk_enable);
-EXPORT_SYMBOL_GPL(__clk_disable);
-EXPORT_SYMBOL_GPL(clk_get_rate);
-EXPORT_SYMBOL_GPL(clk_set_rate);
-EXPORT_SYMBOL_GPL(clk_recalc_rate);
-EXPORT_SYMBOL_GPL(clk_set_rate_ex);
+subsys_initcall(clk_proc_init);

commit 1929cb340b74904c130fdf3de3fe5bbedb68a5aa
Author: dmitry pervushin <dimka@nomadgs.com>
Date:   Tue Apr 24 13:39:09 2007 +0900

    sh: SH7722 clock framework support.
    
    This adds support for the SH7722 (MobileR) to the clock framework.
    
    Signed-off-by: dmitry pervushin <dimka@nomadgs.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index abb586b12565..2075f90d76c7 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -98,13 +98,14 @@ int __clk_enable(struct clk *clk)
 		if (clk->ops && clk->ops->init)
 			clk->ops->init(clk);
 
+	kref_get(&clk->kref);
+
 	if (clk->flags & CLK_ALWAYS_ENABLED)
 		return 0;
 
 	if (likely(clk->ops && clk->ops->enable))
 		clk->ops->enable(clk);
 
-	kref_get(&clk->kref);
 	return 0;
 }
 
@@ -127,10 +128,15 @@ static void clk_kref_release(struct kref *kref)
 
 void __clk_disable(struct clk *clk)
 {
+	int count = kref_put(&clk->kref, clk_kref_release);
+
 	if (clk->flags & CLK_ALWAYS_ENABLED)
 		return;
 
-	kref_put(&clk->kref, clk_kref_release);
+	if (!count) {	/* count reaches zero, disable the clock */
+		if (likely(clk->ops && clk->ops->disable))
+			clk->ops->disable(clk);
+	}
 }
 
 void clk_disable(struct clk *clk)
@@ -151,6 +157,15 @@ int clk_register(struct clk *clk)
 
 	mutex_unlock(&clock_list_sem);
 
+	if (clk->flags & CLK_ALWAYS_ENABLED) {
+		pr_debug( "Clock '%s' is ALWAYS_ENABLED\n", clk->name);
+		if (clk->ops && clk->ops->init)
+			clk->ops->init(clk);
+		if (clk->ops && clk->ops->enable)
+			clk->ops->enable(clk);
+		pr_debug( "Enabled.");
+	}
+
 	return 0;
 }
 
@@ -167,6 +182,11 @@ inline unsigned long clk_get_rate(struct clk *clk)
 }
 
 int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	return clk_set_rate_ex(clk, rate, 0);
+}
+
+int clk_set_rate_ex(struct clk *clk, unsigned long rate, int algo_id)
 {
 	int ret = -EOPNOTSUPP;
 
@@ -174,7 +194,7 @@ int clk_set_rate(struct clk *clk, unsigned long rate)
 		unsigned long flags;
 
 		spin_lock_irqsave(&clock_lock, flags);
-		ret = clk->ops->set_rate(clk, rate);
+		ret = clk->ops->set_rate(clk, rate, algo_id);
 		spin_unlock_irqrestore(&clock_lock, flags);
 	}
 
@@ -256,7 +276,6 @@ int __init clk_init(void)
 
 		arch_init_clk_ops(&clk->ops, i);
 		ret |= clk_register(clk);
-		clk_enable(clk);
 	}
 
 	/* Kick the child clocks.. */
@@ -298,3 +317,4 @@ EXPORT_SYMBOL_GPL(__clk_disable);
 EXPORT_SYMBOL_GPL(clk_get_rate);
 EXPORT_SYMBOL_GPL(clk_set_rate);
 EXPORT_SYMBOL_GPL(clk_recalc_rate);
+EXPORT_SYMBOL_GPL(clk_set_rate_ex);

commit 1d118562c2067a42d0e8f70671a4ce27d7c6ffee
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Dec 1 13:15:14 2006 +0900

    sh: Clock framework tidying.
    
    This syncs up the SH clock framework with the linux/clk.h API,
    for which there were only some minor changes required, namely
    the clk_get() dev_id and subsequent callsites.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 51ec64cdf348..abb586b12565 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -5,9 +5,11 @@
  *
  * This clock framework is derived from the OMAP version by:
  *
- *	Copyright (C) 2004 Nokia Corporation
+ *	Copyright (C) 2004 - 2005 Nokia Corporation
  *	Written by Tuukka Tikkanen <tuukka.tikkanen@elektrobit.com>
  *
+ *  Modified for omap shared clock framework by Tony Lindgren <tony@atomide.com>
+ *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
@@ -20,6 +22,7 @@
 #include <linux/kref.h>
 #include <linux/seq_file.h>
 #include <linux/err.h>
+#include <linux/platform_device.h>
 #include <asm/clock.h>
 #include <asm/timer.h>
 
@@ -195,17 +198,37 @@ void clk_recalc_rate(struct clk *clk)
 		propagate_rate(clk);
 }
 
-struct clk *clk_get(const char *id)
+/*
+ * Returns a clock. Note that we first try to use device id on the bus
+ * and clock name. If this fails, we try to use clock name only.
+ */
+struct clk *clk_get(struct device *dev, const char *id)
 {
 	struct clk *p, *clk = ERR_PTR(-ENOENT);
+	int idno;
+
+	if (dev == NULL || dev->bus != &platform_bus_type)
+		idno = -1;
+	else
+		idno = to_platform_device(dev)->id;
 
 	mutex_lock(&clock_list_sem);
+	list_for_each_entry(p, &clock_list, node) {
+		if (p->id == idno &&
+		    strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
+			clk = p;
+			goto found;
+		}
+	}
+
 	list_for_each_entry(p, &clock_list, node) {
 		if (strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
 			clk = p;
 			break;
 		}
 	}
+
+found:
 	mutex_unlock(&clock_list_sem);
 
 	return clk;

commit 237b98f61d02499ee248ae33cad616d950c15f49
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 17:28:20 2006 +0900

    sh: sem2mutex conversion for clock framework.
    
    Simple sem2mutex conversion.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index e7eef07536f5..51ec64cdf348 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -1,7 +1,7 @@
 /*
  * arch/sh/kernel/cpu/clock.c - SuperH clock framework
  *
- *  Copyright (C) 2005  Paul Mundt
+ *  Copyright (C) 2005, 2006  Paul Mundt
  *
  * This clock framework is derived from the OMAP version by:
  *
@@ -15,6 +15,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/module.h>
+#include <linux/mutex.h>
 #include <linux/list.h>
 #include <linux/kref.h>
 #include <linux/seq_file.h>
@@ -24,7 +25,7 @@
 
 static LIST_HEAD(clock_list);
 static DEFINE_SPINLOCK(clock_lock);
-static DECLARE_MUTEX(clock_list_sem);
+static DEFINE_MUTEX(clock_list_sem);
 
 /*
  * Each subtype is expected to define the init routines for these clocks,
@@ -140,21 +141,21 @@ void clk_disable(struct clk *clk)
 
 int clk_register(struct clk *clk)
 {
-	down(&clock_list_sem);
+	mutex_lock(&clock_list_sem);
 
 	list_add(&clk->node, &clock_list);
 	kref_init(&clk->kref);
 
-	up(&clock_list_sem);
+	mutex_unlock(&clock_list_sem);
 
 	return 0;
 }
 
 void clk_unregister(struct clk *clk)
 {
-	down(&clock_list_sem);
+	mutex_lock(&clock_list_sem);
 	list_del(&clk->node);
-	up(&clock_list_sem);
+	mutex_unlock(&clock_list_sem);
 }
 
 inline unsigned long clk_get_rate(struct clk *clk)
@@ -198,14 +199,14 @@ struct clk *clk_get(const char *id)
 {
 	struct clk *p, *clk = ERR_PTR(-ENOENT);
 
-	down(&clock_list_sem);
+	mutex_lock(&clock_list_sem);
 	list_for_each_entry(p, &clock_list, node) {
 		if (strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
 			clk = p;
 			break;
 		}
 	}
-	up(&clock_list_sem);
+	mutex_unlock(&clock_list_sem);
 
 	return clk;
 }

commit e4c2cfee5d5cf3e4c16b423be23551aeddf2717b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 12:31:01 2006 +0900

    sh: Various cosmetic cleanups.
    
    We had quite a bit of whitespace damage, clean most of it up..
    
    Signed-off-by: Stuart Menefy <stuart.menefy@st.com>
    Signed-off-by: Arthur Othieno <a.othieno@bluewin.ch>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 97fa37f42b84..e7eef07536f5 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -225,7 +225,7 @@ int __init clk_init(void)
 {
 	int i, ret = 0;
 
-	BUG_ON(unlikely(!master_clk.rate));
+	BUG_ON(!master_clk.rate);
 
 	for (i = 0; i < ARRAY_SIZE(onchip_clocks); i++) {
 		struct clk *clk = onchip_clocks[i];

commit 134ed1420eb5a3dd9827aa185dd37fe2dd0ab4d5
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Feb 1 03:06:01 2006 -0800

    [PATCH] sh: Make peripheral clock frequency setting mandatory
    
    Pretty much every subtype does this now anyways, and as we depend on it in a
    few places being set to something sensible quite early on, it's better for a
    new subtype to simply set a sensible default.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
index 989e7fdd524d..97fa37f42b84 100644
--- a/arch/sh/kernel/cpu/clock.c
+++ b/arch/sh/kernel/cpu/clock.c
@@ -38,9 +38,7 @@ static DECLARE_MUTEX(clock_list_sem);
 static struct clk master_clk = {
 	.name		= "master_clk",
 	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
-#ifdef CONFIG_SH_PCLK_FREQ_BOOL
 	.rate		= CONFIG_SH_PCLK_FREQ,
-#endif
 };
 
 static struct clk module_clk = {
@@ -227,16 +225,7 @@ int __init clk_init(void)
 {
 	int i, ret = 0;
 
-	if (unlikely(!master_clk.rate))
-		/*
-		 * NOTE: This will break if the default divisor has been
-		 * changed.
-		 *
-		 * No one should be changing the default on us however,
-		 * expect that a sane value for CONFIG_SH_PCLK_FREQ will
-		 * be defined in the event of a different divisor.
-		 */
-		master_clk.rate = get_timer_frequency() * 4;
+	BUG_ON(unlikely(!master_clk.rate));
 
 	for (i = 0; i < ARRAY_SIZE(onchip_clocks); i++) {
 		struct clk *clk = onchip_clocks[i];

commit 36ddf31b689a8c11d424e43565d2aa440b77bbf4
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Jan 16 22:14:17 2006 -0800

    [PATCH] sh: Simplistic clock framework
    
    This adds a relatively simplistic clock framework for sh.  The initial goal
    behind this is to clean up the arch/sh/kernel/time.c mess and to get the CPU
    subtype-specific frequency setting and calculation code moved somewhere more
    sensible.
    
    This only deals with the core clocks at the moment, though it's trivial for
    other drivers to define their own clocks as desired.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
new file mode 100644
index 000000000000..989e7fdd524d
--- /dev/null
+++ b/arch/sh/kernel/cpu/clock.c
@@ -0,0 +1,287 @@
+/*
+ * arch/sh/kernel/cpu/clock.c - SuperH clock framework
+ *
+ *  Copyright (C) 2005  Paul Mundt
+ *
+ * This clock framework is derived from the OMAP version by:
+ *
+ *	Copyright (C) 2004 Nokia Corporation
+ *	Written by Tuukka Tikkanen <tuukka.tikkanen@elektrobit.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/kref.h>
+#include <linux/seq_file.h>
+#include <linux/err.h>
+#include <asm/clock.h>
+#include <asm/timer.h>
+
+static LIST_HEAD(clock_list);
+static DEFINE_SPINLOCK(clock_lock);
+static DECLARE_MUTEX(clock_list_sem);
+
+/*
+ * Each subtype is expected to define the init routines for these clocks,
+ * as each subtype (or processor family) will have these clocks at the
+ * very least. These are all provided through the CPG, which even some of
+ * the more quirky parts (such as ST40, SH4-202, etc.) still have.
+ *
+ * The processor-specific code is expected to register any additional
+ * clock sources that are of interest.
+ */
+static struct clk master_clk = {
+	.name		= "master_clk",
+	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+#ifdef CONFIG_SH_PCLK_FREQ_BOOL
+	.rate		= CONFIG_SH_PCLK_FREQ,
+#endif
+};
+
+static struct clk module_clk = {
+	.name		= "module_clk",
+	.parent		= &master_clk,
+	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+};
+
+static struct clk bus_clk = {
+	.name		= "bus_clk",
+	.parent		= &master_clk,
+	.flags		= CLK_ALWAYS_ENABLED | CLK_RATE_PROPAGATES,
+};
+
+static struct clk cpu_clk = {
+	.name		= "cpu_clk",
+	.parent		= &master_clk,
+	.flags		= CLK_ALWAYS_ENABLED,
+};
+
+/*
+ * The ordering of these clocks matters, do not change it.
+ */
+static struct clk *onchip_clocks[] = {
+	&master_clk,
+	&module_clk,
+	&bus_clk,
+	&cpu_clk,
+};
+
+static void propagate_rate(struct clk *clk)
+{
+	struct clk *clkp;
+
+	list_for_each_entry(clkp, &clock_list, node) {
+		if (likely(clkp->parent != clk))
+			continue;
+		if (likely(clkp->ops && clkp->ops->recalc))
+			clkp->ops->recalc(clkp);
+	}
+}
+
+int __clk_enable(struct clk *clk)
+{
+	/*
+	 * See if this is the first time we're enabling the clock, some
+	 * clocks that are always enabled still require "special"
+	 * initialization. This is especially true if the clock mode
+	 * changes and the clock needs to hunt for the proper set of
+	 * divisors to use before it can effectively recalc.
+	 */
+	if (unlikely(atomic_read(&clk->kref.refcount) == 1))
+		if (clk->ops && clk->ops->init)
+			clk->ops->init(clk);
+
+	if (clk->flags & CLK_ALWAYS_ENABLED)
+		return 0;
+
+	if (likely(clk->ops && clk->ops->enable))
+		clk->ops->enable(clk);
+
+	kref_get(&clk->kref);
+	return 0;
+}
+
+int clk_enable(struct clk *clk)
+{
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&clock_lock, flags);
+	ret = __clk_enable(clk);
+	spin_unlock_irqrestore(&clock_lock, flags);
+
+	return ret;
+}
+
+static void clk_kref_release(struct kref *kref)
+{
+	/* Nothing to do */
+}
+
+void __clk_disable(struct clk *clk)
+{
+	if (clk->flags & CLK_ALWAYS_ENABLED)
+		return;
+
+	kref_put(&clk->kref, clk_kref_release);
+}
+
+void clk_disable(struct clk *clk)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&clock_lock, flags);
+	__clk_disable(clk);
+	spin_unlock_irqrestore(&clock_lock, flags);
+}
+
+int clk_register(struct clk *clk)
+{
+	down(&clock_list_sem);
+
+	list_add(&clk->node, &clock_list);
+	kref_init(&clk->kref);
+
+	up(&clock_list_sem);
+
+	return 0;
+}
+
+void clk_unregister(struct clk *clk)
+{
+	down(&clock_list_sem);
+	list_del(&clk->node);
+	up(&clock_list_sem);
+}
+
+inline unsigned long clk_get_rate(struct clk *clk)
+{
+	return clk->rate;
+}
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	int ret = -EOPNOTSUPP;
+
+	if (likely(clk->ops && clk->ops->set_rate)) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&clock_lock, flags);
+		ret = clk->ops->set_rate(clk, rate);
+		spin_unlock_irqrestore(&clock_lock, flags);
+	}
+
+	if (unlikely(clk->flags & CLK_RATE_PROPAGATES))
+		propagate_rate(clk);
+
+	return ret;
+}
+
+void clk_recalc_rate(struct clk *clk)
+{
+	if (likely(clk->ops && clk->ops->recalc)) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&clock_lock, flags);
+		clk->ops->recalc(clk);
+		spin_unlock_irqrestore(&clock_lock, flags);
+	}
+
+	if (unlikely(clk->flags & CLK_RATE_PROPAGATES))
+		propagate_rate(clk);
+}
+
+struct clk *clk_get(const char *id)
+{
+	struct clk *p, *clk = ERR_PTR(-ENOENT);
+
+	down(&clock_list_sem);
+	list_for_each_entry(p, &clock_list, node) {
+		if (strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
+			clk = p;
+			break;
+		}
+	}
+	up(&clock_list_sem);
+
+	return clk;
+}
+
+void clk_put(struct clk *clk)
+{
+	if (clk && !IS_ERR(clk))
+		module_put(clk->owner);
+}
+
+void __init __attribute__ ((weak))
+arch_init_clk_ops(struct clk_ops **ops, int type)
+{
+}
+
+int __init clk_init(void)
+{
+	int i, ret = 0;
+
+	if (unlikely(!master_clk.rate))
+		/*
+		 * NOTE: This will break if the default divisor has been
+		 * changed.
+		 *
+		 * No one should be changing the default on us however,
+		 * expect that a sane value for CONFIG_SH_PCLK_FREQ will
+		 * be defined in the event of a different divisor.
+		 */
+		master_clk.rate = get_timer_frequency() * 4;
+
+	for (i = 0; i < ARRAY_SIZE(onchip_clocks); i++) {
+		struct clk *clk = onchip_clocks[i];
+
+		arch_init_clk_ops(&clk->ops, i);
+		ret |= clk_register(clk);
+		clk_enable(clk);
+	}
+
+	/* Kick the child clocks.. */
+	propagate_rate(&master_clk);
+	propagate_rate(&bus_clk);
+
+	return ret;
+}
+
+int show_clocks(struct seq_file *m)
+{
+	struct clk *clk;
+
+	list_for_each_entry_reverse(clk, &clock_list, node) {
+		unsigned long rate = clk_get_rate(clk);
+
+		/*
+		 * Don't bother listing dummy clocks with no ancestry
+		 * that only support enable and disable ops.
+		 */
+		if (unlikely(!rate && !clk->parent))
+			continue;
+
+		seq_printf(m, "%-12s\t: %ld.%02ldMHz\n", clk->name,
+			   rate / 1000000, (rate % 1000000) / 10000);
+	}
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(clk_register);
+EXPORT_SYMBOL_GPL(clk_unregister);
+EXPORT_SYMBOL_GPL(clk_get);
+EXPORT_SYMBOL_GPL(clk_put);
+EXPORT_SYMBOL_GPL(clk_enable);
+EXPORT_SYMBOL_GPL(clk_disable);
+EXPORT_SYMBOL_GPL(__clk_enable);
+EXPORT_SYMBOL_GPL(__clk_disable);
+EXPORT_SYMBOL_GPL(clk_get_rate);
+EXPORT_SYMBOL_GPL(clk_set_rate);
+EXPORT_SYMBOL_GPL(clk_recalc_rate);
