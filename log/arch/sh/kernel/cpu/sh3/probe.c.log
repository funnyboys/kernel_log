commit 5ab5d57cc0c6a4c36fcd52588734f8ab706516f0
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 28 00:32:03 2018 -0800

    sh: sh3: convert to SPDX identifiers
    
    Update license to use SPDX-License-Identifier instead of verbose license
    text.
    
    Link: http://lkml.kernel.org/r/87bm60csyl.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/cpu/sh3/probe.c b/arch/sh/kernel/cpu/sh3/probe.c
index 426e1e1dcedc..5e7ad591ab16 100644
--- a/arch/sh/kernel/cpu/sh3/probe.c
+++ b/arch/sh/kernel/cpu/sh3/probe.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * arch/sh/kernel/cpu/sh3/probe.c
  *
@@ -5,10 +6,6 @@
  *
  * Copyright (C) 1999, 2000  Niibe Yutaka
  * Copyright (C) 2002  Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 
 #include <linux/init.h>

commit 4603f53a1dc3c76dfba841d123db9fa6204934f5
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Jun 18 17:10:12 2013 -0400

    sh: delete __cpuinit usage from all sh files
    
    The __cpuinit type of throwaway sections might have made sense
    some time ago when RAM was more constrained, but now the savings
    do not offset the cost and complications.  For example, the fix in
    commit 5e427ec2d0 ("x86: Fix bit corruption at CPU resume time")
    is a good example of the nasty type of bugs that can be created
    with improper use of the various __init prefixes.
    
    After a discussion on LKML[1] it was decided that cpuinit should go
    the way of devinit and be phased out.  Once all the users are gone,
    we can then finally remove the macros themselves from linux/init.h.
    
    Note that some harmless section mismatch warnings may result, since
    notify_cpu_starting() and cpu_up() are arch independent (kernel/cpu.c)
    are flagged as __cpuinit  -- so if we remove the __cpuinit from
    arch specific callers, we will also get section mismatch warnings.
    As an intermediate step, we intend to turn the linux/init.h cpuinit
    content into no-ops as early as possible, since that will get rid
    of these warnings.  In any case, they are temporary and harmless.
    
    This removes all the arch/sh uses of the __cpuinit macros from
    all C files.  Currently sh does not have any __CPUINIT used in
    assembly files.
    
    [1] https://lkml.org/lkml/2013/5/20/589
    
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: linux-sh@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/sh/kernel/cpu/sh3/probe.c b/arch/sh/kernel/cpu/sh3/probe.c
index bf23c322e164..426e1e1dcedc 100644
--- a/arch/sh/kernel/cpu/sh3/probe.c
+++ b/arch/sh/kernel/cpu/sh3/probe.c
@@ -16,7 +16,7 @@
 #include <asm/cache.h>
 #include <asm/io.h>
 
-void __cpuinit cpu_probe(void)
+void cpu_probe(void)
 {
 	unsigned long addr0, addr1, data0, data1, data2, data3;
 

commit a9079ca0cb15feda15e7a380092e02d5cd834148
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Apr 21 12:01:06 2010 +0900

    sh: Tidy CPU probing and fixup section annotations.
    
    This does a detect_cpu_and_cache_system() -> cpu_probe() rename, tidies
    up the unused return value, and stuffs it under __cpuinit in preparation
    for CPU hotplug.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh3/probe.c b/arch/sh/kernel/cpu/sh3/probe.c
index 295ec4c99e98..bf23c322e164 100644
--- a/arch/sh/kernel/cpu/sh3/probe.c
+++ b/arch/sh/kernel/cpu/sh3/probe.c
@@ -16,7 +16,7 @@
 #include <asm/cache.h>
 #include <asm/io.h>
 
-int detect_cpu_and_cache_system(void)
+void __cpuinit cpu_probe(void)
 {
 	unsigned long addr0, addr1, data0, data1, data2, data3;
 
@@ -108,6 +108,4 @@ int detect_cpu_and_cache_system(void)
 	boot_cpu_data.icache = boot_cpu_data.dcache;
 
 	boot_cpu_data.family = CPU_FAMILY_SH3;
-
-	return 0;
 }

commit 9d56dd3b083a3bec56e9da35ce07baca81030b03
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jan 26 12:58:40 2010 +0900

    sh: Mass ctrl_in/outX to __raw_read/writeX conversion.
    
    The old ctrl in/out routines are non-portable and unsuitable for
    cross-platform use. While drivers/sh has already been sanitized, there
    is still quite a lot of code that is not. This converts the arch/sh/ bits
    over, which permits us to flag the routines as deprecated whilst still
    building with -Werror for the architecture code, and to ensure that
    future users are not added.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh3/probe.c b/arch/sh/kernel/cpu/sh3/probe.c
index c2db65719f4d..295ec4c99e98 100644
--- a/arch/sh/kernel/cpu/sh3/probe.c
+++ b/arch/sh/kernel/cpu/sh3/probe.c
@@ -30,23 +30,23 @@ int detect_cpu_and_cache_system(void)
 	addr1 = CACHE_OC_ADDRESS_ARRAY + (1 << 12);
 
 	/* First, write back & invalidate */
-	data0  = ctrl_inl(addr0);
-	ctrl_outl(data0&~(SH_CACHE_VALID|SH_CACHE_UPDATED), addr0);
-	data1  = ctrl_inl(addr1);
-	ctrl_outl(data1&~(SH_CACHE_VALID|SH_CACHE_UPDATED), addr1);
+	data0  = __raw_readl(addr0);
+	__raw_writel(data0&~(SH_CACHE_VALID|SH_CACHE_UPDATED), addr0);
+	data1  = __raw_readl(addr1);
+	__raw_writel(data1&~(SH_CACHE_VALID|SH_CACHE_UPDATED), addr1);
 
 	/* Next, check if there's shadow or not */
-	data0 = ctrl_inl(addr0);
+	data0 = __raw_readl(addr0);
 	data0 ^= SH_CACHE_VALID;
-	ctrl_outl(data0, addr0);
-	data1 = ctrl_inl(addr1);
+	__raw_writel(data0, addr0);
+	data1 = __raw_readl(addr1);
 	data2 = data1 ^ SH_CACHE_VALID;
-	ctrl_outl(data2, addr1);
-	data3 = ctrl_inl(addr0);
+	__raw_writel(data2, addr1);
+	data3 = __raw_readl(addr0);
 
 	/* Lastly, invaliate them. */
-	ctrl_outl(data0&~SH_CACHE_VALID, addr0);
-	ctrl_outl(data2&~SH_CACHE_VALID, addr1);
+	__raw_writel(data0&~SH_CACHE_VALID, addr0);
+	__raw_writel(data2&~SH_CACHE_VALID, addr1);
 
 	back_to_cached();
 
@@ -94,9 +94,9 @@ int detect_cpu_and_cache_system(void)
 		boot_cpu_data.dcache.way_incr	= (1 << 13);
 		boot_cpu_data.dcache.entry_mask	= 0x1ff0;
 		boot_cpu_data.dcache.sets	= 512;
-		ctrl_outl(CCR_CACHE_32KB, CCR3_REG);
+		__raw_writel(CCR_CACHE_32KB, CCR3_REG);
 #else
-		ctrl_outl(CCR_CACHE_16KB, CCR3_REG);
+		__raw_writel(CCR_CACHE_16KB, CCR3_REG);
 #endif
 #endif
 	}

commit 2dc2f8e0c46864e2a3722c84eaa96513d4cf8b2f
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Jan 21 16:05:25 2010 +0900

    sh: Kill off the special uncached section and fixmap.
    
    Now that cached_to_uncached works as advertized in 32-bit mode and we're
    never going to be able to map < 16MB anyways, there's no need for the
    special uncached section. Kill it off.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh3/probe.c b/arch/sh/kernel/cpu/sh3/probe.c
index f9c7df64eb01..c2db65719f4d 100644
--- a/arch/sh/kernel/cpu/sh3/probe.c
+++ b/arch/sh/kernel/cpu/sh3/probe.c
@@ -16,7 +16,7 @@
 #include <asm/cache.h>
 #include <asm/io.h>
 
-int __uses_jump_to_uncached detect_cpu_and_cache_system(void)
+int detect_cpu_and_cache_system(void)
 {
 	unsigned long addr0, addr1, data0, data1, data2, data3;
 

commit e82da214d2fe3dc2610df966100c4f36bc0fad91
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sat Aug 15 10:48:13 2009 +0900

    sh: Track the CPU family in sh_cpuinfo.
    
    This adds a family member to struct sh_cpuinfo, which allows us to fall
    back more on the probe routines to work out what sort of subtype we are
    running on. This will be used by the CPU cache initialization code in
    order to first do family-level initialization, followed by subtype-level
    optimizations.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh3/probe.c b/arch/sh/kernel/cpu/sh3/probe.c
index 10f2a760c5ee..f9c7df64eb01 100644
--- a/arch/sh/kernel/cpu/sh3/probe.c
+++ b/arch/sh/kernel/cpu/sh3/probe.c
@@ -107,5 +107,7 @@ int __uses_jump_to_uncached detect_cpu_and_cache_system(void)
 	boot_cpu_data.dcache.flags |= SH_CACHE_COMBINED;
 	boot_cpu_data.icache = boot_cpu_data.dcache;
 
+	boot_cpu_data.family = CPU_FAMILY_SH3;
+
 	return 0;
 }

commit cc645a020510cf68332a71394a32c1eacb92c6ed
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Feb 14 15:09:27 2008 +0900

    sh: Rename SH-3 CCR3 reg to avoid synclink_cs clash.
    
    drivers/char/pcmcia/synclink_cs.c:284:1: warning: "CCR3" redefined
    In file included from include/asm/cache.h:13,
                     from include/asm/processor_32.h:15,
                     from include/asm/processor.h:60,
                     from include/linux/prefetch.h:14,
                     from include/linux/list.h:8,
                     from include/linux/module.h:9,
                     from drivers/char/pcmcia/synclink_cs.c:38:
    include/asm/cpu/cache.h:38:1: warning: this is the location of the previous definition
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh3/probe.c b/arch/sh/kernel/cpu/sh3/probe.c
index fcc80bb7bee7..10f2a760c5ee 100644
--- a/arch/sh/kernel/cpu/sh3/probe.c
+++ b/arch/sh/kernel/cpu/sh3/probe.c
@@ -94,9 +94,9 @@ int __uses_jump_to_uncached detect_cpu_and_cache_system(void)
 		boot_cpu_data.dcache.way_incr	= (1 << 13);
 		boot_cpu_data.dcache.entry_mask	= 0x1ff0;
 		boot_cpu_data.dcache.sets	= 512;
-		ctrl_outl(CCR_CACHE_32KB, CCR3);
+		ctrl_outl(CCR_CACHE_32KB, CCR3_REG);
 #else
-		ctrl_outl(CCR_CACHE_16KB, CCR3);
+		ctrl_outl(CCR_CACHE_16KB, CCR3_REG);
 #endif
 #endif
 	}

commit 31a49c4bf8f964b7a9897baa889916d71b51d9c1
Author: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
Date:   Wed Dec 26 11:45:06 2007 +0900

    sh: Add support for SH7721 CPU subtype.
    
    Signed-off-by: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh3/probe.c b/arch/sh/kernel/cpu/sh3/probe.c
index 22070e43e34d..fcc80bb7bee7 100644
--- a/arch/sh/kernel/cpu/sh3/probe.c
+++ b/arch/sh/kernel/cpu/sh3/probe.c
@@ -84,6 +84,9 @@ int __uses_jump_to_uncached detect_cpu_and_cache_system(void)
 #if defined(CONFIG_CPU_SUBTYPE_SH7720)
 		boot_cpu_data.type = CPU_SH7720;
 #endif
+#if defined(CONFIG_CPU_SUBTYPE_SH7721)
+		boot_cpu_data.type = CPU_SH7721;
+#endif
 #if defined(CONFIG_CPU_SUBTYPE_SH7705)
 		boot_cpu_data.type = CPU_SH7705;
 

commit cbaa118ecfd99fc5ed7adbd9c34a30e1c05e3c93
Author: Stuart Menefy <stuart.menefy@st.com>
Date:   Fri Nov 30 17:06:36 2007 +0900

    sh: Preparation for uncached jumps through PMB.
    
    Presently most of the 29-bit physical parts do P1/P2 segmentation
    with a 1:1 cached/uncached mapping, jumping between the two to
    control the caching behaviour. This provides the basic infrastructure
    to maintain this behaviour on 32-bit physical parts that don't map
    P1/P2 at all, using a shiny new linker section and corresponding
    fixmap entry.
    
    Signed-off-by: Stuart Menefy <stuart.menefy@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh3/probe.c b/arch/sh/kernel/cpu/sh3/probe.c
index bf579e061e09..22070e43e34d 100644
--- a/arch/sh/kernel/cpu/sh3/probe.c
+++ b/arch/sh/kernel/cpu/sh3/probe.c
@@ -16,11 +16,11 @@
 #include <asm/cache.h>
 #include <asm/io.h>
 
-int __init detect_cpu_and_cache_system(void)
+int __uses_jump_to_uncached detect_cpu_and_cache_system(void)
 {
 	unsigned long addr0, addr1, data0, data1, data2, data3;
 
-	jump_to_P2();
+	jump_to_uncached();
 	/*
 	 * Check if the entry shadows or not.
 	 * When shadowed, it's 128-entry system.
@@ -48,7 +48,7 @@ int __init detect_cpu_and_cache_system(void)
 	ctrl_outl(data0&~SH_CACHE_VALID, addr0);
 	ctrl_outl(data2&~SH_CACHE_VALID, addr1);
 
-	back_to_P1();
+	back_to_cached();
 
 	boot_cpu_data.dcache.ways		= 4;
 	boot_cpu_data.dcache.entry_shift	= 4;

commit cb7af21f7d370edb3a6a6d3e15cb17c8fd61591e
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Sep 27 18:18:39 2007 +0900

    sh: Use boot_cpu_data for CPU probe.
    
    This moves off of smp_processor_id() and only sets the probe
    information for the boot CPU directly. This will be copied out
    for the secondaries, so there's no reason to do this each time.
    
    This also allows for some header tidying.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh3/probe.c b/arch/sh/kernel/cpu/sh3/probe.c
index 1a66cf636a9d..bf579e061e09 100644
--- a/arch/sh/kernel/cpu/sh3/probe.c
+++ b/arch/sh/kernel/cpu/sh3/probe.c
@@ -50,47 +50,47 @@ int __init detect_cpu_and_cache_system(void)
 
 	back_to_P1();
 
-	current_cpu_data.dcache.ways		= 4;
-	current_cpu_data.dcache.entry_shift	= 4;
-	current_cpu_data.dcache.linesz		= L1_CACHE_BYTES;
-	current_cpu_data.dcache.flags		= 0;
+	boot_cpu_data.dcache.ways		= 4;
+	boot_cpu_data.dcache.entry_shift	= 4;
+	boot_cpu_data.dcache.linesz		= L1_CACHE_BYTES;
+	boot_cpu_data.dcache.flags		= 0;
 
 	/*
 	 * 7709A/7729 has 16K cache (256-entry), while 7702 has only
 	 * 2K(direct) 7702 is not supported (yet)
 	 */
 	if (data0 == data1 && data2 == data3) {	/* Shadow */
-		current_cpu_data.dcache.way_incr	= (1 << 11);
-		current_cpu_data.dcache.entry_mask	= 0x7f0;
-		current_cpu_data.dcache.sets		= 128;
-		current_cpu_data.type = CPU_SH7708;
+		boot_cpu_data.dcache.way_incr	= (1 << 11);
+		boot_cpu_data.dcache.entry_mask	= 0x7f0;
+		boot_cpu_data.dcache.sets	= 128;
+		boot_cpu_data.type = CPU_SH7708;
 
-		current_cpu_data.flags |= CPU_HAS_MMU_PAGE_ASSOC;
+		boot_cpu_data.flags |= CPU_HAS_MMU_PAGE_ASSOC;
 	} else {				/* 7709A or 7729  */
-		current_cpu_data.dcache.way_incr	= (1 << 12);
-		current_cpu_data.dcache.entry_mask	= 0xff0;
-		current_cpu_data.dcache.sets		= 256;
-		current_cpu_data.type = CPU_SH7729;
+		boot_cpu_data.dcache.way_incr	= (1 << 12);
+		boot_cpu_data.dcache.entry_mask	= 0xff0;
+		boot_cpu_data.dcache.sets	= 256;
+		boot_cpu_data.type = CPU_SH7729;
 
 #if defined(CONFIG_CPU_SUBTYPE_SH7706)
-		current_cpu_data.type = CPU_SH7706;
+		boot_cpu_data.type = CPU_SH7706;
 #endif
 #if defined(CONFIG_CPU_SUBTYPE_SH7710)
-		current_cpu_data.type = CPU_SH7710;
+		boot_cpu_data.type = CPU_SH7710;
 #endif
 #if defined(CONFIG_CPU_SUBTYPE_SH7712)
-		current_cpu_data.type = CPU_SH7712;
+		boot_cpu_data.type = CPU_SH7712;
 #endif
 #if defined(CONFIG_CPU_SUBTYPE_SH7720)
-		current_cpu_data.type = CPU_SH7720;
+		boot_cpu_data.type = CPU_SH7720;
 #endif
 #if defined(CONFIG_CPU_SUBTYPE_SH7705)
-		current_cpu_data.type = CPU_SH7705;
+		boot_cpu_data.type = CPU_SH7705;
 
 #if defined(CONFIG_SH7705_CACHE_32KB)
-		current_cpu_data.dcache.way_incr	= (1 << 13);
-		current_cpu_data.dcache.entry_mask	= 0x1ff0;
-		current_cpu_data.dcache.sets		= 512;
+		boot_cpu_data.dcache.way_incr	= (1 << 13);
+		boot_cpu_data.dcache.entry_mask	= 0x1ff0;
+		boot_cpu_data.dcache.sets	= 512;
 		ctrl_outl(CCR_CACHE_32KB, CCR3);
 #else
 		ctrl_outl(CCR_CACHE_16KB, CCR3);
@@ -101,9 +101,8 @@ int __init detect_cpu_and_cache_system(void)
 	/*
 	 * SH-3 doesn't have separate caches
 	 */
-	current_cpu_data.dcache.flags |= SH_CACHE_COMBINED;
-	current_cpu_data.icache = current_cpu_data.dcache;
+	boot_cpu_data.dcache.flags |= SH_CACHE_COMBINED;
+	boot_cpu_data.icache = boot_cpu_data.dcache;
 
 	return 0;
 }
-

commit 3ea6bc3de4f15fcae84fb31eeea4d420685a3da2
Author: Markus Brunner <super.firetwister@gmail.com>
Date:   Mon Aug 20 08:59:33 2007 +0900

    sh: Add SH7720 CPU support.
    
    This adds support for the SH7720 (SH3-DSP) CPU.
    
    Signed-off by: Markus Brunner <super.firetwister@gmail.com>
    Signed-off by: Mark Jonas <toertel@gmail.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh3/probe.c b/arch/sh/kernel/cpu/sh3/probe.c
index 647623b22edc..1a66cf636a9d 100644
--- a/arch/sh/kernel/cpu/sh3/probe.c
+++ b/arch/sh/kernel/cpu/sh3/probe.c
@@ -81,6 +81,9 @@ int __init detect_cpu_and_cache_system(void)
 #if defined(CONFIG_CPU_SUBTYPE_SH7712)
 		current_cpu_data.type = CPU_SH7712;
 #endif
+#if defined(CONFIG_CPU_SUBTYPE_SH7720)
+		current_cpu_data.type = CPU_SH7720;
+#endif
 #if defined(CONFIG_CPU_SUBTYPE_SH7705)
 		current_cpu_data.type = CPU_SH7705;
 

commit 9465a54fa4a9da628091c372baa84120f8304587
Author: Nobuhiro Iwamatsu <iwamatsu@nigauri.org>
Date:   Tue Mar 27 18:13:51 2007 +0900

    sh: MS7712SE01 board support.
    
    Support the SH7712 (SH3-DSP) Solution Engine reference board.
    
    Signed-off-by: Nobuhiro Iwamatsu <iwamatsu@nigauri.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh3/probe.c b/arch/sh/kernel/cpu/sh3/probe.c
index 821b0ab7b528..647623b22edc 100644
--- a/arch/sh/kernel/cpu/sh3/probe.c
+++ b/arch/sh/kernel/cpu/sh3/probe.c
@@ -78,6 +78,9 @@ int __init detect_cpu_and_cache_system(void)
 #if defined(CONFIG_CPU_SUBTYPE_SH7710)
 		current_cpu_data.type = CPU_SH7710;
 #endif
+#if defined(CONFIG_CPU_SUBTYPE_SH7712)
+		current_cpu_data.type = CPU_SH7712;
+#endif
 #if defined(CONFIG_CPU_SUBTYPE_SH7705)
 		current_cpu_data.type = CPU_SH7705;
 

commit 11c1965687b0a472add948d4240dfe65a2fcb298
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Dec 25 10:19:56 2006 +0900

    sh: Fixup cpu_data references for the non-boot CPUs.
    
    There are a lot of bogus cpu_data-> references that only end up working
    for the boot CPU, convert these to current_cpu_data to fixup SMP.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh3/probe.c b/arch/sh/kernel/cpu/sh3/probe.c
index e67098836290..821b0ab7b528 100644
--- a/arch/sh/kernel/cpu/sh3/probe.c
+++ b/arch/sh/kernel/cpu/sh3/probe.c
@@ -50,41 +50,41 @@ int __init detect_cpu_and_cache_system(void)
 
 	back_to_P1();
 
-	cpu_data->dcache.ways		= 4;
-	cpu_data->dcache.entry_shift	= 4;
-	cpu_data->dcache.linesz		= L1_CACHE_BYTES;
-	cpu_data->dcache.flags		= 0;
+	current_cpu_data.dcache.ways		= 4;
+	current_cpu_data.dcache.entry_shift	= 4;
+	current_cpu_data.dcache.linesz		= L1_CACHE_BYTES;
+	current_cpu_data.dcache.flags		= 0;
 
 	/*
 	 * 7709A/7729 has 16K cache (256-entry), while 7702 has only
 	 * 2K(direct) 7702 is not supported (yet)
 	 */
 	if (data0 == data1 && data2 == data3) {	/* Shadow */
-		cpu_data->dcache.way_incr	= (1 << 11);
-		cpu_data->dcache.entry_mask	= 0x7f0;
-		cpu_data->dcache.sets		= 128;
-		cpu_data->type = CPU_SH7708;
+		current_cpu_data.dcache.way_incr	= (1 << 11);
+		current_cpu_data.dcache.entry_mask	= 0x7f0;
+		current_cpu_data.dcache.sets		= 128;
+		current_cpu_data.type = CPU_SH7708;
 
-		cpu_data->flags |= CPU_HAS_MMU_PAGE_ASSOC;
+		current_cpu_data.flags |= CPU_HAS_MMU_PAGE_ASSOC;
 	} else {				/* 7709A or 7729  */
-		cpu_data->dcache.way_incr	= (1 << 12);
-		cpu_data->dcache.entry_mask	= 0xff0;
-		cpu_data->dcache.sets		= 256;
-		cpu_data->type = CPU_SH7729;
+		current_cpu_data.dcache.way_incr	= (1 << 12);
+		current_cpu_data.dcache.entry_mask	= 0xff0;
+		current_cpu_data.dcache.sets		= 256;
+		current_cpu_data.type = CPU_SH7729;
 
 #if defined(CONFIG_CPU_SUBTYPE_SH7706)
-		cpu_data->type = CPU_SH7706;
+		current_cpu_data.type = CPU_SH7706;
 #endif
 #if defined(CONFIG_CPU_SUBTYPE_SH7710)
-		cpu_data->type = CPU_SH7710;
+		current_cpu_data.type = CPU_SH7710;
 #endif
 #if defined(CONFIG_CPU_SUBTYPE_SH7705)
-		cpu_data->type = CPU_SH7705;
+		current_cpu_data.type = CPU_SH7705;
 
 #if defined(CONFIG_SH7705_CACHE_32KB)
-		cpu_data->dcache.way_incr	= (1 << 13);
-		cpu_data->dcache.entry_mask	= 0x1ff0;
-		cpu_data->dcache.sets		= 512;
+		current_cpu_data.dcache.way_incr	= (1 << 13);
+		current_cpu_data.dcache.entry_mask	= 0x1ff0;
+		current_cpu_data.dcache.sets		= 512;
 		ctrl_outl(CCR_CACHE_32KB, CCR3);
 #else
 		ctrl_outl(CCR_CACHE_16KB, CCR3);
@@ -95,8 +95,8 @@ int __init detect_cpu_and_cache_system(void)
 	/*
 	 * SH-3 doesn't have separate caches
 	 */
-	cpu_data->dcache.flags |= SH_CACHE_COMBINED;
-	cpu_data->icache = cpu_data->dcache;
+	current_cpu_data.dcache.flags |= SH_CACHE_COMBINED;
+	current_cpu_data.icache = current_cpu_data.dcache;
 
 	return 0;
 }

commit e5723e0eeb2dc16629e86d66785024ead9169000
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 17:38:11 2006 +0900

    sh: Add support for SH7706/SH7710/SH7343 CPUs.
    
    This adds support for the aforementioned CPU subtypes, and cleans
    up some build issues encountered as a result.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/cpu/sh3/probe.c b/arch/sh/kernel/cpu/sh3/probe.c
index 5cdc88638601..e67098836290 100644
--- a/arch/sh/kernel/cpu/sh3/probe.c
+++ b/arch/sh/kernel/cpu/sh3/probe.c
@@ -72,6 +72,12 @@ int __init detect_cpu_and_cache_system(void)
 		cpu_data->dcache.sets		= 256;
 		cpu_data->type = CPU_SH7729;
 
+#if defined(CONFIG_CPU_SUBTYPE_SH7706)
+		cpu_data->type = CPU_SH7706;
+#endif
+#if defined(CONFIG_CPU_SUBTYPE_SH7710)
+		cpu_data->type = CPU_SH7710;
+#endif
 #if defined(CONFIG_CPU_SUBTYPE_SH7705)
 		cpu_data->type = CPU_SH7705;
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/sh/kernel/cpu/sh3/probe.c b/arch/sh/kernel/cpu/sh3/probe.c
new file mode 100644
index 000000000000..5cdc88638601
--- /dev/null
+++ b/arch/sh/kernel/cpu/sh3/probe.c
@@ -0,0 +1,97 @@
+/*
+ * arch/sh/kernel/cpu/sh3/probe.c
+ *
+ * CPU Subtype Probing for SH-3.
+ *
+ * Copyright (C) 1999, 2000  Niibe Yutaka
+ * Copyright (C) 2002  Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/init.h>
+#include <asm/processor.h>
+#include <asm/cache.h>
+#include <asm/io.h>
+
+int __init detect_cpu_and_cache_system(void)
+{
+	unsigned long addr0, addr1, data0, data1, data2, data3;
+
+	jump_to_P2();
+	/*
+	 * Check if the entry shadows or not.
+	 * When shadowed, it's 128-entry system.
+	 * Otherwise, it's 256-entry system.
+	 */
+	addr0 = CACHE_OC_ADDRESS_ARRAY + (3 << 12);
+	addr1 = CACHE_OC_ADDRESS_ARRAY + (1 << 12);
+
+	/* First, write back & invalidate */
+	data0  = ctrl_inl(addr0);
+	ctrl_outl(data0&~(SH_CACHE_VALID|SH_CACHE_UPDATED), addr0);
+	data1  = ctrl_inl(addr1);
+	ctrl_outl(data1&~(SH_CACHE_VALID|SH_CACHE_UPDATED), addr1);
+
+	/* Next, check if there's shadow or not */
+	data0 = ctrl_inl(addr0);
+	data0 ^= SH_CACHE_VALID;
+	ctrl_outl(data0, addr0);
+	data1 = ctrl_inl(addr1);
+	data2 = data1 ^ SH_CACHE_VALID;
+	ctrl_outl(data2, addr1);
+	data3 = ctrl_inl(addr0);
+
+	/* Lastly, invaliate them. */
+	ctrl_outl(data0&~SH_CACHE_VALID, addr0);
+	ctrl_outl(data2&~SH_CACHE_VALID, addr1);
+
+	back_to_P1();
+
+	cpu_data->dcache.ways		= 4;
+	cpu_data->dcache.entry_shift	= 4;
+	cpu_data->dcache.linesz		= L1_CACHE_BYTES;
+	cpu_data->dcache.flags		= 0;
+
+	/*
+	 * 7709A/7729 has 16K cache (256-entry), while 7702 has only
+	 * 2K(direct) 7702 is not supported (yet)
+	 */
+	if (data0 == data1 && data2 == data3) {	/* Shadow */
+		cpu_data->dcache.way_incr	= (1 << 11);
+		cpu_data->dcache.entry_mask	= 0x7f0;
+		cpu_data->dcache.sets		= 128;
+		cpu_data->type = CPU_SH7708;
+
+		cpu_data->flags |= CPU_HAS_MMU_PAGE_ASSOC;
+	} else {				/* 7709A or 7729  */
+		cpu_data->dcache.way_incr	= (1 << 12);
+		cpu_data->dcache.entry_mask	= 0xff0;
+		cpu_data->dcache.sets		= 256;
+		cpu_data->type = CPU_SH7729;
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7705)
+		cpu_data->type = CPU_SH7705;
+
+#if defined(CONFIG_SH7705_CACHE_32KB)
+		cpu_data->dcache.way_incr	= (1 << 13);
+		cpu_data->dcache.entry_mask	= 0x1ff0;
+		cpu_data->dcache.sets		= 512;
+		ctrl_outl(CCR_CACHE_32KB, CCR3);
+#else
+		ctrl_outl(CCR_CACHE_16KB, CCR3);
+#endif
+#endif
+	}
+
+	/*
+	 * SH-3 doesn't have separate caches
+	 */
+	cpu_data->dcache.flags |= SH_CACHE_COMBINED;
+	cpu_data->icache = cpu_data->dcache;
+
+	return 0;
+}
+
