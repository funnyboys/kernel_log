commit 5933f6d220403b55772d2caf48a9a39d777fd630
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 28 00:32:24 2018 -0800

    sh: kernel: convert to SPDX identifiers
    
    Update license to use SPDX-License-Identifier instead of verbose license
    text.
    
    Link: http://lkml.kernel.org/r/8736rccswn.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/machvec.c b/arch/sh/kernel/machvec.c
index ec05f491c347..beadbbdb4486 100644
--- a/arch/sh/kernel/machvec.c
+++ b/arch/sh/kernel/machvec.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * arch/sh/kernel/machvec.c
  *
@@ -5,10 +6,6 @@
  *
  *  Copyright (C) 1999  Niibe Yutaka
  *  Copyright (C) 2002 - 2007 Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 #include <linux/init.h>
 #include <linux/string.h>

commit 63dc02bde6af1e41d28ebc3774c5f094f362e8c3
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon May 21 17:54:01 2012 +0900

    sh: Kill off machvec IRQ hinting.
    
    Everything is using sparseirq these days, so we have no need to
    arbitrarily size nr_irqs ahead of time. The legacy IRQ pre-allocation
    likewise has no meaning for us, so that's killed off too. We now depend
    on nr_irqs expansion by the generic hardirq layer instead.
    
    It's also worth noting that the majority of boards had completely bogus
    values for their nr_irqs relative to their CPU and configurations, so
    this ends up correcting behaviour for quite a few platforms.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/machvec.c b/arch/sh/kernel/machvec.c
index 3d722e49db08..ec05f491c347 100644
--- a/arch/sh/kernel/machvec.c
+++ b/arch/sh/kernel/machvec.c
@@ -121,7 +121,4 @@ void __init sh_mv_setup(void)
 	mv_set(irq_demux);
 	mv_set(mode_pins);
 	mv_set(mem_init);
-
-	if (!sh_mv.mv_nr_irqs)
-		sh_mv.mv_nr_irqs = NR_IRQS;
 }

commit 37b7a97884ba64bf7d403351ac2a9476ab4f1bba
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Nov 1 09:49:04 2010 -0400

    sh: machvec IO death.
    
    This takes a bit of a sledgehammer to the machvec I/O routines. The
    iomem case requires no special casing and so can just be dropped
    outright. This only leaves the ioport casing for PCI and SuperIO
    mangling. With the SuperIO case going through the standard ioport
    mapping, it's possible to replace everything with generic routines.
    
    With this done the standard I/O routines are tidied up and NO_IOPORT
    now gets default-enabled for the vast majority of boards.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/machvec.c b/arch/sh/kernel/machvec.c
index 9f9bb63616ad..3d722e49db08 100644
--- a/arch/sh/kernel/machvec.c
+++ b/arch/sh/kernel/machvec.c
@@ -118,28 +118,6 @@ void __init sh_mv_setup(void)
 		sh_mv.mv_##elem = generic_##elem; \
 } while (0)
 
-#ifdef CONFIG_HAS_IOPORT
-
-#ifdef P2SEG
-	__set_io_port_base(P2SEG);
-#else
-	__set_io_port_base(0);
-#endif
-
-	mv_set(inb);	mv_set(inw);	mv_set(inl);
-	mv_set(outb);	mv_set(outw);	mv_set(outl);
-
-	mv_set(inb_p);	mv_set(inw_p);	mv_set(inl_p);
-	mv_set(outb_p);	mv_set(outw_p);	mv_set(outl_p);
-
-	mv_set(insb);	mv_set(insw);	mv_set(insl);
-	mv_set(outsb);	mv_set(outsw);	mv_set(outsl);
-
-	mv_set(ioport_map);
-	mv_set(ioport_unmap);
-
-#endif
-
 	mv_set(irq_demux);
 	mv_set(mode_pins);
 	mv_set(mem_init);

commit 86e4dd5add77ab809f5427391dfabb8f78cbcb58
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 25 20:06:13 2010 +0900

    sh: support for platforms without PIO.
    
    This extends some of the existing special casing for HAS_IOPORT
    platforms and gets it to the point where platforms can begin to
    conditionally select it.
    
    The major changes here are that the PIO routines themselves go away
    completely, including all of the machvec port mapping wrappers. With this
    in place it's possible for any non-machvec abusing platform to disable
    PIO completely. At present this is left as an opt-in until the abusers
    are the odd ones out instead of the majority.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/machvec.c b/arch/sh/kernel/machvec.c
index 85cfaf916fdc..9f9bb63616ad 100644
--- a/arch/sh/kernel/machvec.c
+++ b/arch/sh/kernel/machvec.c
@@ -118,6 +118,14 @@ void __init sh_mv_setup(void)
 		sh_mv.mv_##elem = generic_##elem; \
 } while (0)
 
+#ifdef CONFIG_HAS_IOPORT
+
+#ifdef P2SEG
+	__set_io_port_base(P2SEG);
+#else
+	__set_io_port_base(0);
+#endif
+
 	mv_set(inb);	mv_set(inw);	mv_set(inl);
 	mv_set(outb);	mv_set(outw);	mv_set(outl);
 
@@ -129,16 +137,13 @@ void __init sh_mv_setup(void)
 
 	mv_set(ioport_map);
 	mv_set(ioport_unmap);
+
+#endif
+
 	mv_set(irq_demux);
 	mv_set(mode_pins);
 	mv_set(mem_init);
 
 	if (!sh_mv.mv_nr_irqs)
 		sh_mv.mv_nr_irqs = NR_IRQS;
-
-#ifdef P2SEG
-	__set_io_port_base(P2SEG);
-#else
-	__set_io_port_base(0);
-#endif
 }

commit 19d8f84f86af867abee174be8bf1e4941a59143d
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon May 10 15:39:05 2010 +0900

    sh: enable LMB region setup via machvec.
    
    This plugs in a memory init callback in the machvec to permit boards to
    wire up various bits of memory directly in to LMB. A generic machvec
    implementation is provided that simply wraps around the normal
    Kconfig-derived memory start/size.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/machvec.c b/arch/sh/kernel/machvec.c
index 1652340ba3f2..85cfaf916fdc 100644
--- a/arch/sh/kernel/machvec.c
+++ b/arch/sh/kernel/machvec.c
@@ -131,6 +131,7 @@ void __init sh_mv_setup(void)
 	mv_set(ioport_unmap);
 	mv_set(irq_demux);
 	mv_set(mode_pins);
+	mv_set(mem_init);
 
 	if (!sh_mv.mv_nr_irqs)
 		sh_mv.mv_nr_irqs = NR_IRQS;

commit e9c58fc57b17bfa75c256fb4f45ce22de6626858
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Nov 12 16:36:26 2009 +0900

    sh: Use the generic I/O port base for slowdown.
    
    This fixes up the build and behaviour for various configurations. Namely
    the CONFIG_32BIT cases where legacy mappings do not exist, as well as the
    sh64 build.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/machvec.c b/arch/sh/kernel/machvec.c
index cbce639b108a..1652340ba3f2 100644
--- a/arch/sh/kernel/machvec.c
+++ b/arch/sh/kernel/machvec.c
@@ -135,5 +135,9 @@ void __init sh_mv_setup(void)
 	if (!sh_mv.mv_nr_irqs)
 		sh_mv.mv_nr_irqs = NR_IRQS;
 
+#ifdef P2SEG
 	__set_io_port_base(P2SEG);
+#else
+	__set_io_port_base(0);
+#endif
 }

commit d44ee12ad61ff7aa7a6344560bd430cb72fcbc27
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Sep 28 15:05:41 2009 +0900

    sh: Set the default I/O port base to P2SEG.
    
    This bumps up the default I/O base to P2SEG, which allows legacy probing
    to bail out gracefully rather than oopsing. Platforms that have a real
    PIO offset still need to fix this up on their own, although most
    platforms are content with P2SEG already.
    
    The previous change to teach ioport_map() about >= P1SEG offsets in
    combination with this patch allows both the already remapped and the
    legacy address probing to pass through and succeed.
    
    Fixes up an oops with i8042 on the sh7785lcr board.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/machvec.c b/arch/sh/kernel/machvec.c
index 548f6607fd0f..cbce639b108a 100644
--- a/arch/sh/kernel/machvec.c
+++ b/arch/sh/kernel/machvec.c
@@ -14,6 +14,7 @@
 #include <linux/string.h>
 #include <asm/machvec.h>
 #include <asm/sections.h>
+#include <asm/addrspace.h>
 #include <asm/setup.h>
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -133,4 +134,6 @@ void __init sh_mv_setup(void)
 
 	if (!sh_mv.mv_nr_irqs)
 		sh_mv.mv_nr_irqs = NR_IRQS;
+
+	__set_io_port_base(P2SEG);
 }

commit eb9b9b56eed280e65a9e194aaeb50a5a75111859
Author: Magnus Damm <damm@igel.co.jp>
Date:   Thu May 28 11:51:51 2009 +0000

    sh: boot word / mode pin support V2
    
    Add mode pin support for the SuperH architecture V2.
    
    With this patch applied the board code can add their
    own function to export the cpu mode pin configuration.
    In most cases this will be a constant bitmap, but
    boards that allow reading this from a register can
    instead read out the pin state from hardware.
    
    The code warns if a pin is tested but no board specific
    mode pin function has been provided.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/machvec.c b/arch/sh/kernel/machvec.c
index c1ea41e5812a..548f6607fd0f 100644
--- a/arch/sh/kernel/machvec.c
+++ b/arch/sh/kernel/machvec.c
@@ -129,6 +129,7 @@ void __init sh_mv_setup(void)
 	mv_set(ioport_map);
 	mv_set(ioport_unmap);
 	mv_set(irq_demux);
+	mv_set(mode_pins);
 
 	if (!sh_mv.mv_nr_irqs)
 		sh_mv.mv_nr_irqs = NR_IRQS;

commit 14866543ad22014a0b12e10657a917eb6b487248
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sat Oct 4 05:25:52 2008 +0900

    sh: More I/O routine overhauling.
    
    This tidies up a lot of the PIO/MMIO split. No in-tree platforms were
    making use of the MMIO overloading through the machvec (nor have any of
    them been in some time), so we just kill all of that off. The ISA I/O
    routine wrapping remains unaffected, which remains the only special
    casing outside of the iomap API that boards need to think about.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/machvec.c b/arch/sh/kernel/machvec.c
index 8bfdd275e940..c1ea41e5812a 100644
--- a/arch/sh/kernel/machvec.c
+++ b/arch/sh/kernel/machvec.c
@@ -126,9 +126,6 @@ void __init sh_mv_setup(void)
 	mv_set(insb);	mv_set(insw);	mv_set(insl);
 	mv_set(outsb);	mv_set(outsw);	mv_set(outsl);
 
-	mv_set(readb);	mv_set(readw);	mv_set(readl);
-	mv_set(writeb);	mv_set(writew);	mv_set(writel);
-
 	mv_set(ioport_map);
 	mv_set(ioport_unmap);
 	mv_set(irq_demux);

commit fa43972fab24a3c050e880a7831f9378c6cebc0b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Sep 4 18:53:58 2008 +0900

    sh: fixup many sparse errors.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/machvec.c b/arch/sh/kernel/machvec.c
index 129b2cfd18a8..8bfdd275e940 100644
--- a/arch/sh/kernel/machvec.c
+++ b/arch/sh/kernel/machvec.c
@@ -14,6 +14,7 @@
 #include <linux/string.h>
 #include <asm/machvec.h>
 #include <asm/sections.h>
+#include <asm/setup.h>
 #include <asm/io.h>
 #include <asm/irq.h>
 

commit 5556410e2203877e7606bb1008f2e024fe87953a
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Aug 7 19:13:23 2007 +0900

    sh: panic on machvec section misalignment.
    
    Now that __initmv references the machvec section unconditionally
    there have been cases where folks have been mistakenly flagging
    non-machvec structures with the machvec section attribute (presumably
    to shut up modpost). This leads to obscure breakage in earlyprintk
    amongst other places and is rather non-obvious.
    
    Add a simple sanity check to try and catch __initmv misuse and
    panic early.
    
    Reported-by: Markus Brunner <super.firetwister@gmail.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/machvec.c b/arch/sh/kernel/machvec.c
index 23c5948f0124..129b2cfd18a8 100644
--- a/arch/sh/kernel/machvec.c
+++ b/arch/sh/kernel/machvec.c
@@ -90,6 +90,13 @@ void __init sh_mv_setup(void)
 		machvec_size = ((unsigned long)&__machvec_end -
 				(unsigned long)&__machvec_start);
 
+		/*
+		 * Sanity check for machvec section alignment. Ensure
+		 * __initmv hasn't been misused.
+		 */
+		if (machvec_size % sizeof(struct sh_machine_vector))
+			panic("machvec misaligned, invalid __initmv use?");
+
 		/*
 		 * If the machvec hasn't been preselected, use the first
 		 * vector (usually the only one) from .machvec.init.

commit fd8f20e8e2f8f1d9201086bff444c8d35f0a6a45
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 15 15:38:30 2007 +0900

    sh: Rip out special unknown machvec.
    
    This kills off the BareCPU board as a "special" machvec, rather,
    we leave this as a default for when no other vector is available,
    or when we want to use it in combination with other vectors for
    testing with generic ops. As sh_mv is copied out anyways (or
    overloaded when an alternate vector is explicitly selected), this
    doesn't consume any additional memory.
    
    The generic machvec can be forcibly selected with sh_mv=generic,
    or by not having any other boards enabled.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/machvec.c b/arch/sh/kernel/machvec.c
index e8121de5faa4..23c5948f0124 100644
--- a/arch/sh/kernel/machvec.c
+++ b/arch/sh/kernel/machvec.c
@@ -35,6 +35,8 @@ static struct sh_machine_vector * __init get_mv_byname(const char *name)
 	return NULL;
 }
 
+static unsigned int __initdata machvec_selected;
+
 static int __init early_parse_mv(char *from)
 {
 	char mv_name[MV_NAME_SIZE] = "";
@@ -55,9 +57,15 @@ static int __init early_parse_mv(char *from)
 	mv_name[mv_len] = '\0';
 	from = mv_end;
 
+	machvec_selected = 1;
+
+	/* Boot with the generic vector */
+	if (strcmp(mv_name, "generic") == 0)
+		return 0;
+
 	mvp = get_mv_byname(mv_name);
 	if (unlikely(!mvp)) {
-		printk("Available vectors:\n\n\t");
+		printk("Available vectors:\n\n\t'%s', ", sh_mv.mv_name);
 		for_each_mv(mvp)
 			printk("'%s', ", mvp->mv_name);
 		printk("\n\n");
@@ -76,7 +84,7 @@ void __init sh_mv_setup(void)
 	 * Only overload the machvec if one hasn't been selected on
 	 * the command line with sh_mv=
 	 */
-	if (strcmp(sh_mv.mv_name, "Unknown") != 0) {
+	if (!machvec_selected) {
 		unsigned long machvec_size;
 
 		machvec_size = ((unsigned long)&__machvec_end -

commit 82f81f4784479df17a80caff4a7156da0a2f7dea
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 15 15:19:34 2007 +0900

    sh: Kill off machvec aliases.
    
    We now throw all of the machvecs in to .machvec.init and either
    select one on the command line, or copy out the first (and
    usually only) one to sh_mv. The rest are freed as usual.
    
    This gets rid of all of the silly sh_mv aliasing and makes the
    selection explicit rather than link-order dependent.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/machvec.c b/arch/sh/kernel/machvec.c
index 1e78191154e3..e8121de5faa4 100644
--- a/arch/sh/kernel/machvec.c
+++ b/arch/sh/kernel/machvec.c
@@ -29,7 +29,7 @@ static struct sh_machine_vector * __init get_mv_byname(const char *name)
 	struct sh_machine_vector *mv;
 
 	for_each_mv(mv)
-		if (strcasecmp(name, get_system_type()) == 0)
+		if (strcasecmp(name, mv->mv_name) == 0)
 			return mv;
 
 	return NULL;
@@ -55,26 +55,43 @@ static int __init early_parse_mv(char *from)
 	mv_name[mv_len] = '\0';
 	from = mv_end;
 
-	if (strcmp(sh_mv.mv_name, mv_name) != 0) {
-		mvp = get_mv_byname(mv_name);
-		if (unlikely(!mvp)) {
-			printk("Available vectors:\n\n\t");
-			for_each_mv(mvp)
-				printk("'%s', ", mvp->mv_name);
-			printk("\n\n");
-			panic("Failed to select machvec '%s' -- halting.\n",
-			      mv_name);
-		} else
-			sh_mv = *mvp;
-	}
+	mvp = get_mv_byname(mv_name);
+	if (unlikely(!mvp)) {
+		printk("Available vectors:\n\n\t");
+		for_each_mv(mvp)
+			printk("'%s', ", mvp->mv_name);
+		printk("\n\n");
+		panic("Failed to select machvec '%s' -- halting.\n",
+		      mv_name);
+	} else
+		sh_mv = *mvp;
 
-	printk(KERN_NOTICE "Booting machvec: %s\n", sh_mv.mv_name);
 	return 0;
 }
 early_param("sh_mv", early_parse_mv);
 
 void __init sh_mv_setup(void)
 {
+	/*
+	 * Only overload the machvec if one hasn't been selected on
+	 * the command line with sh_mv=
+	 */
+	if (strcmp(sh_mv.mv_name, "Unknown") != 0) {
+		unsigned long machvec_size;
+
+		machvec_size = ((unsigned long)&__machvec_end -
+				(unsigned long)&__machvec_start);
+
+		/*
+		 * If the machvec hasn't been preselected, use the first
+		 * vector (usually the only one) from .machvec.init.
+		 */
+		if (machvec_size >= sizeof(struct sh_machine_vector))
+			sh_mv = *(struct sh_machine_vector *)&__machvec_start;
+	}
+
+	printk(KERN_NOTICE "Booting machvec: %s\n", get_system_type());
+
 	/*
 	 * Manually walk the vec, fill in anything that the board hasn't yet
 	 * by hand, wrapping to the generic implementation.

commit 9655ad03af2d232c3b26e7562ab4f8c29b107e49
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon May 14 15:59:09 2007 +0900

    sh: Fixup machvec support.
    
    This fixes up much of the machvec handling, allowing for it to be
    overloaded on boot. Making practical use of this still requires
    some Kconfig munging, however.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/machvec.c b/arch/sh/kernel/machvec.c
new file mode 100644
index 000000000000..1e78191154e3
--- /dev/null
+++ b/arch/sh/kernel/machvec.c
@@ -0,0 +1,105 @@
+/*
+ * arch/sh/kernel/machvec.c
+ *
+ * The SuperH machine vector setup handlers, yanked from setup.c
+ *
+ *  Copyright (C) 1999  Niibe Yutaka
+ *  Copyright (C) 2002 - 2007 Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/init.h>
+#include <linux/string.h>
+#include <asm/machvec.h>
+#include <asm/sections.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#define MV_NAME_SIZE 32
+
+#define for_each_mv(mv) \
+	for ((mv) = (struct sh_machine_vector *)&__machvec_start; \
+	     (mv) && (unsigned long)(mv) < (unsigned long)&__machvec_end; \
+	     (mv)++)
+
+static struct sh_machine_vector * __init get_mv_byname(const char *name)
+{
+	struct sh_machine_vector *mv;
+
+	for_each_mv(mv)
+		if (strcasecmp(name, get_system_type()) == 0)
+			return mv;
+
+	return NULL;
+}
+
+static int __init early_parse_mv(char *from)
+{
+	char mv_name[MV_NAME_SIZE] = "";
+	char *mv_end;
+	char *mv_comma;
+	int mv_len;
+	struct sh_machine_vector *mvp;
+
+	mv_end = strchr(from, ' ');
+	if (mv_end == NULL)
+		mv_end = from + strlen(from);
+
+	mv_comma = strchr(from, ',');
+	mv_len = mv_end - from;
+	if (mv_len > (MV_NAME_SIZE-1))
+		mv_len = MV_NAME_SIZE-1;
+	memcpy(mv_name, from, mv_len);
+	mv_name[mv_len] = '\0';
+	from = mv_end;
+
+	if (strcmp(sh_mv.mv_name, mv_name) != 0) {
+		mvp = get_mv_byname(mv_name);
+		if (unlikely(!mvp)) {
+			printk("Available vectors:\n\n\t");
+			for_each_mv(mvp)
+				printk("'%s', ", mvp->mv_name);
+			printk("\n\n");
+			panic("Failed to select machvec '%s' -- halting.\n",
+			      mv_name);
+		} else
+			sh_mv = *mvp;
+	}
+
+	printk(KERN_NOTICE "Booting machvec: %s\n", sh_mv.mv_name);
+	return 0;
+}
+early_param("sh_mv", early_parse_mv);
+
+void __init sh_mv_setup(void)
+{
+	/*
+	 * Manually walk the vec, fill in anything that the board hasn't yet
+	 * by hand, wrapping to the generic implementation.
+	 */
+#define mv_set(elem) do { \
+	if (!sh_mv.mv_##elem) \
+		sh_mv.mv_##elem = generic_##elem; \
+} while (0)
+
+	mv_set(inb);	mv_set(inw);	mv_set(inl);
+	mv_set(outb);	mv_set(outw);	mv_set(outl);
+
+	mv_set(inb_p);	mv_set(inw_p);	mv_set(inl_p);
+	mv_set(outb_p);	mv_set(outw_p);	mv_set(outl_p);
+
+	mv_set(insb);	mv_set(insw);	mv_set(insl);
+	mv_set(outsb);	mv_set(outsw);	mv_set(outsl);
+
+	mv_set(readb);	mv_set(readw);	mv_set(readl);
+	mv_set(writeb);	mv_set(writew);	mv_set(writel);
+
+	mv_set(ioport_map);
+	mv_set(ioport_unmap);
+	mv_set(irq_demux);
+
+	if (!sh_mv.mv_nr_irqs)
+		sh_mv.mv_nr_irqs = NR_IRQS;
+}
