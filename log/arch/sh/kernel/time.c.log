commit 201e91091b1d47047f55580b5474e1239f4d17aa
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Oct 3 11:29:13 2019 +0200

    sh: add the sh_ prefix to early platform symbols
    
    Old early platform device support is now sh-specific. Before moving on
    to implementing new early platform framework based on real platform
    devices, prefix all early platform symbols with 'sh_'.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Cc: Rich Felker <dalias@libc.org>
    Link: https://lore.kernel.org/r/20191003092913.10731-3-brgl@bgdev.pl
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 8ad9fd5c4ff6..821a09cbd605 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -31,8 +31,8 @@ static void __init sh_late_time_init(void)
 	 * clocksource and the jiffies clocksource is used transparently
 	 * instead. No error handling is necessary here.
 	 */
-	early_platform_driver_register_all("earlytimer");
-	early_platform_driver_probe("earlytimer", 2, 0);
+	sh_early_platform_driver_register_all("earlytimer");
+	sh_early_platform_driver_probe("earlytimer", 2, 0);
 }
 
 void __init time_init(void)

commit 507fd01d5333338753a1cc26322dfc9f856c109f
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Oct 3 11:29:12 2019 +0200

    drivers: move the early platform device support to arch/sh
    
    SuperH is the only user of the current implementation of early platform
    device support. We want to introduce a more robust approach to early
    probing. As the first step - move all the current early platform code
    to arch/sh.
    
    In order not to export internal drivers/base functions to arch code for
    this temporary solution - copy the two needed routines for driver
    matching from drivers/base/platform.c to arch/sh/drivers/platform_early.c.
    
    Also: call early_platform_cleanup() from subsys_initcall() so that it's
    called after all early devices are probed.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Cc: Rich Felker <dalias@libc.org>
    Link: https://lore.kernel.org/r/20191003092913.10731-2-brgl@bgdev.pl
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index e16b2cd269a3..8ad9fd5c4ff6 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -18,6 +18,7 @@
 #include <linux/rtc.h>
 #include <asm/clock.h>
 #include <asm/rtc.h>
+#include <asm/platform_early.h>
 
 static void __init sh_late_time_init(void)
 {

commit f346b0becb1bc62e45495f9cdbae3eef35d0b635
Merge: 00d59fde8532 0f4991e8fd48
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 28 16:55:46 2018 -0800

    Merge branch 'akpm' (patches from Andrew)
    
    Merge misc updates from Andrew Morton:
    
     - large KASAN update to use arm's "software tag-based mode"
    
     - a few misc things
    
     - sh updates
    
     - ocfs2 updates
    
     - just about all of MM
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (167 commits)
      kernel/fork.c: mark 'stack_vm_area' with __maybe_unused
      memcg, oom: notify on oom killer invocation from the charge path
      mm, swap: fix swapoff with KSM pages
      include/linux/gfp.h: fix typo
      mm/hmm: fix memremap.h, move dev_page_fault_t callback to hmm
      hugetlbfs: Use i_mmap_rwsem to fix page fault/truncate race
      hugetlbfs: use i_mmap_rwsem for more pmd sharing synchronization
      memory_hotplug: add missing newlines to debugging output
      mm: remove __hugepage_set_anon_rmap()
      include/linux/vmstat.h: remove unused page state adjustment macro
      mm/page_alloc.c: allow error injection
      mm: migrate: drop unused argument of migrate_page_move_mapping()
      blkdev: avoid migration stalls for blkdev pages
      mm: migrate: provide buffer_migrate_page_norefs()
      mm: migrate: move migrate_page_lock_buffers()
      mm: migrate: lock buffers before migrate_page_move_mapping()
      mm: migration: factor out code to compute expected number of page references
      mm, page_alloc: enable pcpu_drain with zone capability
      kmemleak: add config to select auto scan
      mm/page_alloc.c: don't call kasan_free_pages() at deferred mem init
      ...

commit 5933f6d220403b55772d2caf48a9a39d777fd630
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 28 00:32:24 2018 -0800

    sh: kernel: convert to SPDX identifiers
    
    Update license to use SPDX-License-Identifier instead of verbose license
    text.
    
    Link: http://lkml.kernel.org/r/8736rccswn.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index fcd5e41977d1..6742d6e3af17 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *  arch/sh/kernel/time.c
  *
@@ -5,10 +6,6 @@
  *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
  *  Copyright (C) 2002 - 2009  Paul Mundt
  *  Copyright (C) 2002  M. R. Brown  <mrbrown@linux-sh.org>
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 #include <linux/kernel.h>
 #include <linux/init.h>

commit 19f48591e67c83e74e1b612f180b96ce7f1eaf85
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Apr 20 17:46:39 2018 +0200

    sh: remove board_time_init() callback
    
    The only remaining user of board_time_init() is the of-generic
    machine, and that just calls the global timer_init() function.
    Calling that one has no effect on non-DT platforms, so we can
    simply call it unconditionally in place of board_time_init().
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index eb0a91270499..8a1c6c8ab4ec 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -22,8 +22,6 @@
 #include <asm/clock.h>
 #include <asm/rtc.h>
 
-void (*board_time_init)(void);
-
 static void __init sh_late_time_init(void)
 {
 	/*
@@ -41,8 +39,7 @@ static void __init sh_late_time_init(void)
 
 void __init time_init(void)
 {
-	if (board_time_init)
-		board_time_init();
+	timer_probe();
 
 	clk_init();
 

commit 07df7800c6cd0bfc3bfcbfc5f12ebbd73423a5ec
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jan 24 16:18:50 2018 +0100

    sh: remove unused rtc_sh_get/set_time infrastructure
    
    All platforms are now converted to RTC drivers, so this has become
    obsolete. The board_time_init() callback still has one caller, but
    could otherwise also get killed.
    
    This removes one more usage of the deprecated timespec structure,
    which overflows in y2038.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index fcd5e41977d1..eb0a91270499 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -22,75 +22,6 @@
 #include <asm/clock.h>
 #include <asm/rtc.h>
 
-/* Dummy RTC ops */
-static void null_rtc_get_time(struct timespec *tv)
-{
-	tv->tv_sec = mktime(2000, 1, 1, 0, 0, 0);
-	tv->tv_nsec = 0;
-}
-
-static int null_rtc_set_time(const time_t secs)
-{
-	return 0;
-}
-
-void (*rtc_sh_get_time)(struct timespec *) = null_rtc_get_time;
-int (*rtc_sh_set_time)(const time_t) = null_rtc_set_time;
-
-void read_persistent_clock(struct timespec *ts)
-{
-	rtc_sh_get_time(ts);
-}
-
-#ifdef CONFIG_GENERIC_CMOS_UPDATE
-int update_persistent_clock(struct timespec now)
-{
-	return rtc_sh_set_time(now.tv_sec);
-}
-#endif
-
-static int rtc_generic_get_time(struct device *dev, struct rtc_time *tm)
-{
-	struct timespec tv;
-
-	rtc_sh_get_time(&tv);
-	rtc_time_to_tm(tv.tv_sec, tm);
-	return 0;
-}
-
-static int rtc_generic_set_time(struct device *dev, struct rtc_time *tm)
-{
-	unsigned long secs;
-
-	rtc_tm_to_time(tm, &secs);
-	if ((rtc_sh_set_time == null_rtc_set_time) ||
-	    (rtc_sh_set_time(secs) < 0))
-		return -EOPNOTSUPP;
-
-	return 0;
-}
-
-static const struct rtc_class_ops rtc_generic_ops = {
-	.read_time = rtc_generic_get_time,
-	.set_time = rtc_generic_set_time,
-};
-
-static int __init rtc_generic_init(void)
-{
-	struct platform_device *pdev;
-
-	if (rtc_sh_get_time == null_rtc_get_time)
-		return -ENODEV;
-
-	pdev = platform_device_register_data(NULL, "rtc-generic", -1,
-					     &rtc_generic_ops,
-					     sizeof(rtc_generic_ops));
-
-
-	return PTR_ERR_OR_ZERO(pdev);
-}
-device_initcall(rtc_generic_init);
-
 void (*board_time_init)(void);
 
 static void __init sh_late_time_init(void)

commit 1630e843e104528ddf0208dfc692c70c9bd05a89
Merge: 194d6ad32e1e e61c10e468a4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 6 09:00:05 2016 -0400

    Merge tag 'sh-for-4.8' of git://git.libc.org/linux-sh
    
    Pull arch/sh updates from Rich Felker:
     "These changes improve device tree support (including builtin DTB), add
      support for the J-Core J2 processor, an open source synthesizable
      reimplementation of the SH-2 ISA, resolve a longstanding sigcontext
      ABI mismatch issue, and fix various bugs including nommu-specific
      issues and minor regressions introduced in 4.6.
    
      The J-Core arch support is included here but to be usable it needs
      drivers that are waiting on approval/inclusion from their subsystem
      maintainers"
    
    * tag 'sh-for-4.8' of git://git.libc.org/linux-sh: (23 commits)
      sh: add device tree source for J2 FPGA on Mimas v2 board
      sh: add defconfig for J-Core J2
      sh: use common clock framework with device tree boards
      sh: system call wire up
      sh: Delete unnecessary checks before the function call "mempool_destroy"
      sh: do not perform IPI-based cache flush except on boards that need it
      sh: add SMP support for J2
      sh: SMP support for SH2 entry.S
      sh: add working futex atomic ops on userspace addresses for smp
      sh: add J2 atomics using the cas.l instruction
      sh: add AT_HWCAP flag for J-Core cas.l instruction
      sh: add support for J-Core J2 processor
      sh: fix build regression with CONFIG_OF && !CONFIG_OF_FLATTREE
      sh: allow clocksource drivers to register sched_clock backends
      sh: make heartbeat driver explicitly non-modular
      sh: make board-secureedge5410 explicitly non-modular
      sh: make mm/asids-debugfs explicitly non-modular
      sh: make time.c explicitly non-modular
      sh: fix futex/robust_list on nommu models
      sh: disable aliased page logic on NOMMU models
      ...

commit 7a65a34fae03d364c9ed34cea83fb5b978e75f2a
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Apr 22 14:07:01 2016 -0400

    sh: make time.c explicitly non-modular
    
    The Makefile currently controlling compilation of this code is:
    
    obj-y   := debugtraps.o dma-nommu.o dumpstack.o                 \
    [...]
               syscalls_$(BITS).o time.o topology.o traps.o         \
               traps_$(BITS).o unwinder.o
    
    ....meaning that it currently is not being built as a module by anyone.
    
    Lets remove the couple traces of modular code, so that when reading
    the driver there is no doubt it is builtin-only.
    
    Since module_init translates to device_initcall in the non-modular
    case, the init ordering remains unchanged with this commit.
    
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: linux-sh@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Rich Felker <dalias@libc.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index d6d0a986c6e9..bfe1de98d003 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -11,7 +11,6 @@
  * for more details.
  */
 #include <linux/kernel.h>
-#include <linux/module.h>
 #include <linux/init.h>
 #include <linux/profile.h>
 #include <linux/timex.h>
@@ -83,7 +82,7 @@ static int __init rtc_generic_init(void)
 
 	return PTR_ERR_OR_ZERO(pdev);
 }
-module_init(rtc_generic_init);
+device_initcall(rtc_generic_init);
 
 void (*board_time_init)(void);
 

commit d4db68741d381b04d603bc9e75fe2a8a29097a84
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon May 30 20:57:52 2016 +0200

    rtc: sh: provide rtc_class_ops directly
    
    The rtc-generic driver provides an architecture specific
    wrapper on top of the generic rtc_class_ops abstraction,
    and on sh, that goes through another indirection using
    the rtc_sh_get_time/rtc_sh_set_time functions.
    
    This changes the sh rtc-generic device to provide its
    rtc_class_ops directly, skipping one of the abstraction
    levels.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Rich Felker <dalias@libc.org>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index d6d0a986c6e9..a4a7862b489a 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -50,27 +50,31 @@ int update_persistent_clock(struct timespec now)
 }
 #endif
 
-unsigned int get_rtc_time(struct rtc_time *tm)
+static int rtc_generic_get_time(struct device *dev, struct rtc_time *tm)
 {
-	if (rtc_sh_get_time != null_rtc_get_time) {
-		struct timespec tv;
+	struct timespec tv;
 
-		rtc_sh_get_time(&tv);
-		rtc_time_to_tm(tv.tv_sec, tm);
-	}
-
-	return RTC_24H;
+	rtc_sh_get_time(&tv);
+	rtc_time_to_tm(tv.tv_sec, tm);
+	return 0;
 }
-EXPORT_SYMBOL(get_rtc_time);
 
-int set_rtc_time(struct rtc_time *tm)
+static int rtc_generic_set_time(struct device *dev, struct rtc_time *tm)
 {
 	unsigned long secs;
 
 	rtc_tm_to_time(tm, &secs);
-	return rtc_sh_set_time(secs);
+	if ((rtc_sh_set_time == null_rtc_set_time) ||
+	    (rtc_sh_set_time(secs) < 0))
+		return -EOPNOTSUPP;
+
+	return 0;
 }
-EXPORT_SYMBOL(set_rtc_time);
+
+static const struct rtc_class_ops rtc_generic_ops = {
+	.read_time = rtc_generic_get_time,
+	.set_time = rtc_generic_set_time,
+};
 
 static int __init rtc_generic_init(void)
 {
@@ -79,7 +83,10 @@ static int __init rtc_generic_init(void)
 	if (rtc_sh_get_time == null_rtc_get_time)
 		return -ENODEV;
 
-	pdev = platform_device_register_simple("rtc-generic", -1, NULL, 0);
+	pdev = platform_device_register_data(NULL, "rtc-generic", -1,
+					     &rtc_generic_ops,
+					     sizeof(rtc_generic_ops));
+
 
 	return PTR_ERR_OR_ZERO(pdev);
 }

commit 7c0368211de94c1bf646f8de11c9b0dee9d417d9
Author: Fabian Frederick <fabf@skynet.be>
Date:   Wed Aug 6 16:03:43 2014 -0700

    arch/sh/kernel/time.c: use PTR_ERR_OR_ZERO
    
    Replace IS_ERR/PTR_ERR.
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 552c8fcf9416..d6d0a986c6e9 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -80,10 +80,8 @@ static int __init rtc_generic_init(void)
 		return -ENODEV;
 
 	pdev = platform_device_register_simple("rtc-generic", -1, NULL, 0);
-	if (IS_ERR(pdev))
-		return PTR_ERR(pdev);
 
-	return 0;
+	return PTR_ERR_OR_ZERO(pdev);
 }
 module_init(rtc_generic_init);
 

commit cfc806a7ee38e68a9363584dd2b00421fda6dfed
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Nov 18 16:26:00 2011 +0900

    sh: hwblk: Kill off remaining bits of hwblk API.
    
    Now that everything has been migrated, kill off the remaining
    infrastructure bits.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 8a0072de2bcc..552c8fcf9416 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -21,7 +21,6 @@
 #include <linux/smp.h>
 #include <linux/rtc.h>
 #include <asm/clock.h>
-#include <asm/hwblk.h>
 #include <asm/rtc.h>
 
 /* Dummy RTC ops */
@@ -110,7 +109,6 @@ void __init time_init(void)
 	if (board_time_init)
 		board_time_init();
 
-	hwblk_init();
 	clk_init();
 
 	late_time_init = sh_late_time_init;

commit 0272282f7cffb469cd2676dcb6e58bc942fcf8a8
Author: John Stultz <johnstul@us.ibm.com>
Date:   Fri Mar 5 02:04:38 2010 +0900

    sh: Convert sh to use read/update_persistent_clock
    
    This patch converts the sh architecture to use the generic
    read_persistent_clock and update_persistent_clock interfaces, reducing
    the amount of arch specific code we have to maintain, and allowing for
    further cleanups in the future.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 953fa1613312..8a0072de2bcc 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -39,12 +39,12 @@ static int null_rtc_set_time(const time_t secs)
 void (*rtc_sh_get_time)(struct timespec *) = null_rtc_get_time;
 int (*rtc_sh_set_time)(const time_t) = null_rtc_set_time;
 
-#ifdef CONFIG_GENERIC_CMOS_UPDATE
 void read_persistent_clock(struct timespec *ts)
 {
 	rtc_sh_get_time(ts);
 }
 
+#ifdef CONFIG_GENERIC_CMOS_UPDATE
 int update_persistent_clock(struct timespec now)
 {
 	return rtc_sh_set_time(now.tv_sec);
@@ -113,9 +113,5 @@ void __init time_init(void)
 	hwblk_init();
 	clk_init();
 
-	rtc_sh_get_time(&xtime);
-	set_normalized_timespec(&wall_to_monotonic,
-				-xtime.tv_sec, -xtime.tv_nsec);
-
 	late_time_init = sh_late_time_init;
 }

commit 515b696b282f856c3ad1679ccd658120faa387d0
Merge: fa877c71e213 064a16dc41be
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 18 09:43:09 2009 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/lethal/sh-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/lethal/sh-2.6: (262 commits)
      sh: mach-ecovec24: Add user debug switch support
      sh: Kill off unused se_skipped in alignment trap notification code.
      sh: Wire up HAVE_SYSCALL_TRACEPOINTS.
      video: sh_mobile_lcdcfb: use both register sets for display panning
      video: sh_mobile_lcdcfb: implement display panning
      sh: Fix up sh7705 flush_dcache_page() build.
      sh: kfr2r09: document the PLL/FLL <-> RF relationship.
      sh: mach-ecovec24: need asm/clock.h.
      sh: mach-ecovec24: deassert usb irq on boot.
      sh: Add KEYSC support for EcoVec24
      sh: add kycr2_delay for sh_keysc
      sh: cpufreq: Include CPU id in info messages.
      sh: multi-evt support for SH-X3 proto CPU.
      sh: clkfwk: remove bogus set_bus_parent() from SH7709.
      sh: Fix the indication point of the liquid crystal of AP-325RXA(AP3300)
      sh: Add EcoVec24 romImage defconfig
      sh: USB disable process is needed if romImage boot for EcoVec24
      sh: EcoVec24: add HIZA setting for LED
      sh: EcoVec24: write MAC address in boot
      sh: Add romImage support for EcoVec24
      ...

commit 0ceb4c3e3f1ccaf121851e33c3ea269b8ad0f219
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Aug 25 07:32:39 2009 +0900

    timekeeping: Fix up read_persistent_clock() breakage on sh
    
    The recent commit "timekeeping: Increase granularity of
    read_persistent_clock()" introduced read_persistent_clock()
    rework which inadvertently broke the sh conversion:
    
            arch/sh/kernel/time.c:45: error: passing argument 1 of 'rtc_sh_get_time' from incompatible pointer type
            distcc[13470] ERROR: compile arch/sh/kernel/time.c on sprygo/32 failed
            make[2]: *** [arch/sh/kernel/time.o] Error 1
    
    This trivial fix gets it working again.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    LKML-Reference: <20090824223239.GB20832@linux-sh.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 3f4706aa975e..0e0e8581cf7a 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -41,7 +41,7 @@ int (*rtc_sh_set_time)(const time_t) = null_rtc_set_time;
 #ifdef CONFIG_GENERIC_CMOS_UPDATE
 void read_persistent_clock(struct timespec *ts)
 {
-	rtc_sh_get_time(&ts);
+	rtc_sh_get_time(ts);
 }
 
 int update_persistent_clock(struct timespec now)

commit fc6191dd301e3bc8cbb142aab1a2ec4e699cb2de
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Aug 19 17:53:04 2009 +0900

    sh: Fix up clockevents broadcasting.
    
    This fixes up the clockevents broadcasting code as detailed in commit
    ee348d5a1d810bc9958cabb7c27302aab235d36e ("[ARM] realview: fix broadcast
    tick support"). This saves us from having to do strange ordering things
    with the broadcast clockevent device, relying on the rating instead.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 7f95f479060f..632aff533285 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -119,9 +119,5 @@ void __init time_init(void)
 	set_normalized_timespec(&wall_to_monotonic,
 				-xtime.tv_sec, -xtime.tv_nsec);
 
-#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST
-	local_timer_setup(smp_processor_id());
-#endif
-
 	late_time_init = sh_late_time_init;
 }

commit d4f587c67fc39e0030ddd718675e252e208da4d7
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 14 15:47:31 2009 +0200

    timekeeping: Increase granularity of read_persistent_clock()
    
    The persistent clock of some architectures (e.g. s390) have a
    better granularity than seconds. To reduce the delta between the
    host clock and the guest clock in a virtualized system change the
    read_persistent_clock function to return a struct timespec.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    LKML-Reference: <20090814134811.013873340@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 9b352a1e3fb4..3f4706aa975e 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -39,11 +39,9 @@ void (*rtc_sh_get_time)(struct timespec *) = null_rtc_get_time;
 int (*rtc_sh_set_time)(const time_t) = null_rtc_set_time;
 
 #ifdef CONFIG_GENERIC_CMOS_UPDATE
-unsigned long read_persistent_clock(void)
+void read_persistent_clock(struct timespec *ts)
 {
-	struct timespec tv;
-	rtc_sh_get_time(&tv);
-	return tv.tv_sec;
+	rtc_sh_get_time(&ts);
 }
 
 int update_persistent_clock(struct timespec now)

commit 82b242214b6f5b96eb9b76452ac6e2b67dd81abd
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Jul 29 22:43:58 2009 +0900

    Revert "sh: Bump the earlytimer bits back to time_init()."
    
    This reverts commit 1d29ebebcb951ab6b04d22807cafb24b893310a2.
    
    Bumping up the earlytimer initialization causes IRQs to be enabled too
    early, which blows up lockdep:
    
    ...
    NR_IRQS:256 nr_irqs:256
    ------------[ cut here ]------------
    Badness at kernel/lockdep.c:2128
    
    Pid : 0, Comm:          swapper
    CPU : 0                 Not tainted  (2.6.31-rc3-00205-g3ed6e12-dirty #2443)
    
    PC is at trace_hardirqs_on_caller+0x48/0x10c
    PR is at trace_hardirqs_on_caller+0x3c/0x10c
    ...
    
    Revert it back to late_time_init time, which fixes up lockdep.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index d2424b068b7b..7f95f479060f 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -92,6 +92,21 @@ module_init(rtc_generic_init);
 
 void (*board_time_init)(void);
 
+static void __init sh_late_time_init(void)
+{
+	/*
+	 * Make sure all compiled-in early timers register themselves.
+	 *
+	 * Run probe() for two "earlytimer" devices, these will be the
+	 * clockevents and clocksource devices respectively. In the event
+	 * that only a clockevents device is available, we -ENODEV on the
+	 * clocksource and the jiffies clocksource is used transparently
+	 * instead. No error handling is necessary here.
+	 */
+	early_platform_driver_register_all("earlytimer");
+	early_platform_driver_probe("earlytimer", 2, 0);
+}
+
 void __init time_init(void)
 {
 	if (board_time_init)
@@ -108,15 +123,5 @@ void __init time_init(void)
 	local_timer_setup(smp_processor_id());
 #endif
 
-	/*
-	 * Make sure all compiled-in early timers register themselves.
-	 *
-	 * Run probe() for two "earlytimer" devices, these will be the
-	 * clockevents and clocksource devices respectively. In the event
-	 * that only a clockevents device is available, we -ENODEV on the
-	 * clocksource and the jiffies clocksource is used transparently
-	 * instead. No error handling is necessary here.
-	 */
-	early_platform_driver_register_all("earlytimer");
-	early_platform_driver_probe("earlytimer", 2, 0);
+	late_time_init = sh_late_time_init;
 }

commit 79714acbab080ad351acf4bba9a2bbc21d65c93c
Author: Magnus Damm <damm@igel.co.jp>
Date:   Fri Jul 3 10:08:05 2009 +0000

    sh: hwblk base implementation
    
    This patch is the hwblk base implementation, containing
    structures and shared functions dealing with hardware blocks.
    
    A each processor model should provide a list of hwblks and
    describe which module stop bit that is associated with each
    hwblck and how the hwblks are grouped together into areas.
    
    The shared code keeps track of the usage count for each
    hwblk and the areas. Fallback implementations for processor
    specific code are also kept as weak symbols.
    
    The clock framework, the runtime pm code and cpuidle will
    all tie into this hwblk implementation.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 9b352a1e3fb4..d2424b068b7b 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -21,6 +21,7 @@
 #include <linux/smp.h>
 #include <linux/rtc.h>
 #include <asm/clock.h>
+#include <asm/hwblk.h>
 #include <asm/rtc.h>
 
 /* Dummy RTC ops */
@@ -96,6 +97,7 @@ void __init time_init(void)
 	if (board_time_init)
 		board_time_init();
 
+	hwblk_init();
 	clk_init();
 
 	rtc_sh_get_time(&xtime);

commit 6fe32a468521d45edc35d92cdc05cd74e930426a
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sun Jun 14 20:02:30 2009 +0900

    sh: Bump the earlytimer probe devices up.
    
    Presently the earlytimer probe handles the clockevents driver, which
    requires that the clockevents driver be registered first. This bumps it
    up by 1 to include the clocksource device, which can be safely ignored
    if it doesn't exist, as we will simply error out on that path and defer
    to the jiffies clocksource.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 960d9abd1058..9b352a1e3fb4 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -108,8 +108,13 @@ void __init time_init(void)
 
 	/*
 	 * Make sure all compiled-in early timers register themselves.
-	 * Run probe() for one "earlytimer" device.
+	 *
+	 * Run probe() for two "earlytimer" devices, these will be the
+	 * clockevents and clocksource devices respectively. In the event
+	 * that only a clockevents device is available, we -ENODEV on the
+	 * clocksource and the jiffies clocksource is used transparently
+	 * instead. No error handling is necessary here.
 	 */
 	early_platform_driver_register_all("earlytimer");
-	early_platform_driver_probe("earlytimer", 1, 0);
+	early_platform_driver_probe("earlytimer", 2, 0);
 }

commit a34c7e3e7b0e7db67ffef21ba3056eb2f807ba4a
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sun Jun 14 19:48:48 2009 +0900

    sh: Use generic sched_clock().
    
    The generic sched_clock() handles INITIAL_JIFFIES now as well, so we can
    just use that instead.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 0eecbe855f5c..960d9abd1058 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -91,11 +91,6 @@ module_init(rtc_generic_init);
 
 void (*board_time_init)(void);
 
-unsigned long long sched_clock(void)
-{
-	return (jiffies_64 - INITIAL_JIFFIES) * (NSEC_PER_SEC / HZ);
-}
-
 void __init time_init(void)
 {
 	if (board_time_init)

commit 1d29ebebcb951ab6b04d22807cafb24b893310a2
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sun Jun 14 19:45:40 2009 +0900

    sh: Bump the earlytimer bits back to time_init().
    
    These were handled through late_time_init due to kmalloc() and friends
    not being available earlier on previously. Now with slab caches being
    available much earlier, this is no longer necessary, and we can move the
    initialization up to an earlier point. One of the benefits with this is
    that printk times are available a bit earlier!
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 2edde32c764b..0eecbe855f5c 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -96,16 +96,6 @@ unsigned long long sched_clock(void)
 	return (jiffies_64 - INITIAL_JIFFIES) * (NSEC_PER_SEC / HZ);
 }
 
-static void __init sh_late_time_init(void)
-{
-	/*
-	 * Make sure all compiled-in early timers register themselves.
-	 * Run probe() for one "earlytimer" device.
-	 */
-	early_platform_driver_register_all("earlytimer");
-	early_platform_driver_probe("earlytimer", 1, 0);
-}
-
 void __init time_init(void)
 {
 	if (board_time_init)
@@ -121,5 +111,10 @@ void __init time_init(void)
 	local_timer_setup(smp_processor_id());
 #endif
 
-	late_time_init = sh_late_time_init;
+	/*
+	 * Make sure all compiled-in early timers register themselves.
+	 * Run probe() for one "earlytimer" device.
+	 */
+	early_platform_driver_register_all("earlytimer");
+	early_platform_driver_probe("earlytimer", 1, 0);
 }

commit 8be5f1a68f2c14082939dd54e7037dcee2eb54f8
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 12 19:53:55 2009 +0900

    sh: Kill off the remnants of the old timer code.
    
    Now with all of the TMU users moved over to the new TMU driver, and the
    old TMU driver killed off, the left-over infrastructure can go along
    with it.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index a77838f539f8..2edde32c764b 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -22,9 +22,6 @@
 #include <linux/rtc.h>
 #include <asm/clock.h>
 #include <asm/rtc.h>
-#include <asm/timer.h>
-
-struct sys_timer *sys_timer;
 
 /* Dummy RTC ops */
 static void null_rtc_get_time(struct timespec *tv)
@@ -94,20 +91,9 @@ module_init(rtc_generic_init);
 
 void (*board_time_init)(void);
 
-struct clocksource clocksource_sh = {
-	.name		= "SuperH",
-};
-
 unsigned long long sched_clock(void)
 {
-	unsigned long long cycles;
-
-	/* jiffies based sched_clock if no clocksource is installed */
-	if (!clocksource_sh.rating)
-		return (jiffies_64 - INITIAL_JIFFIES) * (NSEC_PER_SEC / HZ);
-
-	cycles = clocksource_sh.read(&clocksource_sh);
-	return cyc2ns(&clocksource_sh, cycles);
+	return (jiffies_64 - INITIAL_JIFFIES) * (NSEC_PER_SEC / HZ);
 }
 
 static void __init sh_late_time_init(void)
@@ -117,18 +103,7 @@ static void __init sh_late_time_init(void)
 	 * Run probe() for one "earlytimer" device.
 	 */
 	early_platform_driver_register_all("earlytimer");
-	if (early_platform_driver_probe("earlytimer", 1, 0))
-		return;
-
-	/*
-	 * Find the timer to use as the system timer, it will be
-	 * initialized for us.
-	 */
-	sys_timer = get_sys_timer();
-	if (unlikely(!sys_timer))
-		panic("System timer missing.\n");
-
-	printk(KERN_INFO "Using %s for system timer\n", sys_timer->name);
+	early_platform_driver_probe("earlytimer", 1, 0);
 }
 
 void __init time_init(void)

commit 780f98ff1fa9cfcab177f6b5ab09b11321f1e5c8
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon May 11 12:15:14 2009 +0900

    sh: Account for INITIAL_JIFFIES when using jiffies clocksource.
    
    In the case where we fall back on the generic jiffies clocksource,
    INITIAL_JIFFIES needs to be accounted for so that printk times aren't
    completely skewed.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index e0aa769481ff..a77838f539f8 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -104,7 +104,7 @@ unsigned long long sched_clock(void)
 
 	/* jiffies based sched_clock if no clocksource is installed */
 	if (!clocksource_sh.rating)
-		return (unsigned long long)jiffies * (NSEC_PER_SEC / HZ);
+		return (jiffies_64 - INITIAL_JIFFIES) * (NSEC_PER_SEC / HZ);
 
 	cycles = clocksource_sh.read(&clocksource_sh);
 	return cyc2ns(&clocksource_sh, cycles);

commit 1af2fe45fec15bdba446c22b9b602699cdabfc9f
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri May 8 16:59:05 2009 +0900

    sh: Kill off the global rtc_lock with extreme prejudice.
    
    Now that all of the possible users for rtc_lock have gone away, it is no
    longer necessary to keep this lock definition around.
    
    This follows several other architectures that have either recently
    dropped it or never supported it in the first place.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index c26576a5a454..e0aa769481ff 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -17,7 +17,6 @@
 #include <linux/timex.h>
 #include <linux/sched.h>
 #include <linux/clockchips.h>
-#include <linux/mc146818rtc.h>	/* for rtc_lock */
 #include <linux/platform_device.h>
 #include <linux/smp.h>
 #include <linux/rtc.h>
@@ -27,10 +26,6 @@
 
 struct sys_timer *sys_timer;
 
-/* Move this somewhere more sensible.. */
-DEFINE_SPINLOCK(rtc_lock);
-EXPORT_SYMBOL(rtc_lock);
-
 /* Dummy RTC ops */
 static void null_rtc_get_time(struct timespec *tv)
 {

commit 6459d7bb72e9767bc7d22f2ee44aab35188e4b8a
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri May 8 16:47:48 2009 +0900

    sh: Kill off dead timer sysclass pm hooks.
    
    With the conversion to generic clockevents these are completely unused,
    so just kill it off.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index f4c304adec42..c26576a5a454 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -97,51 +97,6 @@ static int __init rtc_generic_init(void)
 }
 module_init(rtc_generic_init);
 
-#ifdef CONFIG_PM
-int timer_suspend(struct sys_device *dev, pm_message_t state)
-{
-	struct sys_timer *sys_timer = container_of(dev, struct sys_timer, dev);
-
-	sys_timer->ops->stop();
-
-	return 0;
-}
-
-int timer_resume(struct sys_device *dev)
-{
-	struct sys_timer *sys_timer = container_of(dev, struct sys_timer, dev);
-
-	sys_timer->ops->start();
-
-	return 0;
-}
-#else
-#define timer_suspend NULL
-#define timer_resume NULL
-#endif
-
-static struct sysdev_class timer_sysclass = {
-	.name	 = "timer",
-	.suspend = timer_suspend,
-	.resume	 = timer_resume,
-};
-
-static int __init timer_init_sysfs(void)
-{
-	int ret;
-
-	if (!sys_timer)
-		return 0;
-
-	ret = sysdev_class_register(&timer_sysclass);
-	if (ret != 0)
-		return ret;
-
-	sys_timer->dev.cls = &timer_sysclass;
-	return sysdev_register(&sys_timer->dev);
-}
-device_initcall(timer_init_sysfs);
-
 void (*board_time_init)(void);
 
 struct clocksource clocksource_sh = {

commit 5ac5496411b30d41945a996fe7a7fb5abccf2aaa
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri May 8 16:44:00 2009 +0900

    sh: Kill off dead handle_timer_tick() code.
    
    Nothing is using this anymore now that we have fully converted to generic
    time, so kill it off completely.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 77b841a99c01..f4c304adec42 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -1,13 +1,14 @@
 /*
- *  arch/sh/kernel/time_32.c
+ *  arch/sh/kernel/time.c
  *
  *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
  *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
  *  Copyright (C) 2002 - 2009  Paul Mundt
  *  Copyright (C) 2002  M. R. Brown  <mrbrown@linux-sh.org>
  *
- *  Some code taken from i386 version.
- *    Copyright (C) 1991, 1992, 1995  Linus Torvalds
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
  */
 #include <linux/kernel.h>
 #include <linux/module.h>
@@ -23,7 +24,6 @@
 #include <asm/clock.h>
 #include <asm/rtc.h>
 #include <asm/timer.h>
-#include <asm/kgdb.h>
 
 struct sys_timer *sys_timer;
 
@@ -97,50 +97,6 @@ static int __init rtc_generic_init(void)
 }
 module_init(rtc_generic_init);
 
-/* last time the RTC clock got updated */
-static long last_rtc_update;
-
-/*
- * handle_timer_tick() needs to keep up the real-time clock,
- * as well as call the "do_timer()" routine every clocktick
- */
-void handle_timer_tick(void)
-{
-	if (current->pid)
-		profile_tick(CPU_PROFILING);
-
-	/*
-	 * Here we are in the timer irq handler. We just have irqs locally
-	 * disabled but we don't know if the timer_bh is running on the other
-	 * CPU. We need to avoid to SMP race with it. NOTE: we don' t need
-	 * the irq version of write_lock because as just said we have irq
-	 * locally disabled. -arca
-	 */
-	write_seqlock(&xtime_lock);
-	do_timer(1);
-
-	/*
-	 * If we have an externally synchronized Linux clock, then update
-	 * RTC clock accordingly every ~11 minutes. Set_rtc_mmss() has to be
-	 * called as close as possible to 500 ms before the new second starts.
-	 */
-	if (ntp_synced() &&
-	    xtime.tv_sec > last_rtc_update + 660 &&
-	    (xtime.tv_nsec / 1000) >= 500000 - ((unsigned) TICK_SIZE) / 2 &&
-	    (xtime.tv_nsec / 1000) <= 500000 + ((unsigned) TICK_SIZE) / 2) {
-		if (rtc_sh_set_time(xtime.tv_sec) == 0)
-			last_rtc_update = xtime.tv_sec;
-		else
-			/* do it again in 60s */
-			last_rtc_update = xtime.tv_sec - 600;
-	}
-	write_sequnlock(&xtime_lock);
-
-#ifndef CONFIG_SMP
-	update_process_times(user_mode(get_irq_regs()));
-#endif
-}
-
 #ifdef CONFIG_PM
 int timer_suspend(struct sys_device *dev, pm_message_t state)
 {
@@ -242,4 +198,3 @@ void __init time_init(void)
 
 	late_time_init = sh_late_time_init;
 }
-

commit 6d134b9e8d3f32331ad2faca2db8186f54198931
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri May 8 16:36:13 2009 +0900

    sh: Wire up GENERIC_CMOS_UPDATE for the platforms that need it.
    
    Now that everything has converted over to generic timekeeping, we need an
    alternate method for keeping the RTC updated for those platforms that are
    still using the rtc_sh_get/set_time pairs, presently limited to SH-03 and
    the Dreamcast. This wires up the GENERIC_CMOS_UPDATE hooks for those to
    maintain the same behaviour.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index d41ca4cf20cf..77b841a99c01 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -46,6 +46,20 @@ static int null_rtc_set_time(const time_t secs)
 void (*rtc_sh_get_time)(struct timespec *) = null_rtc_get_time;
 int (*rtc_sh_set_time)(const time_t) = null_rtc_set_time;
 
+#ifdef CONFIG_GENERIC_CMOS_UPDATE
+unsigned long read_persistent_clock(void)
+{
+	struct timespec tv;
+	rtc_sh_get_time(&tv);
+	return tv.tv_sec;
+}
+
+int update_persistent_clock(struct timespec now)
+{
+	return rtc_sh_set_time(now.tv_sec);
+}
+#endif
+
 unsigned int get_rtc_time(struct rtc_time *tm)
 {
 	if (rtc_sh_get_time != null_rtc_get_time) {

commit b179b72fad5c88c3b616fb88a9ae7cbbc1a750d3
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri May 8 16:17:36 2009 +0900

    sh: Rename arch/sh/kernel/time_32.c to arch/sh/kernel/time.c.
    
    This is now fully generic, and used both by _32 and _64 variants.
    Rename it accordingly.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
new file mode 100644
index 000000000000..d41ca4cf20cf
--- /dev/null
+++ b/arch/sh/kernel/time.c
@@ -0,0 +1,231 @@
+/*
+ *  arch/sh/kernel/time_32.c
+ *
+ *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
+ *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
+ *  Copyright (C) 2002 - 2009  Paul Mundt
+ *  Copyright (C) 2002  M. R. Brown  <mrbrown@linux-sh.org>
+ *
+ *  Some code taken from i386 version.
+ *    Copyright (C) 1991, 1992, 1995  Linus Torvalds
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/profile.h>
+#include <linux/timex.h>
+#include <linux/sched.h>
+#include <linux/clockchips.h>
+#include <linux/mc146818rtc.h>	/* for rtc_lock */
+#include <linux/platform_device.h>
+#include <linux/smp.h>
+#include <linux/rtc.h>
+#include <asm/clock.h>
+#include <asm/rtc.h>
+#include <asm/timer.h>
+#include <asm/kgdb.h>
+
+struct sys_timer *sys_timer;
+
+/* Move this somewhere more sensible.. */
+DEFINE_SPINLOCK(rtc_lock);
+EXPORT_SYMBOL(rtc_lock);
+
+/* Dummy RTC ops */
+static void null_rtc_get_time(struct timespec *tv)
+{
+	tv->tv_sec = mktime(2000, 1, 1, 0, 0, 0);
+	tv->tv_nsec = 0;
+}
+
+static int null_rtc_set_time(const time_t secs)
+{
+	return 0;
+}
+
+void (*rtc_sh_get_time)(struct timespec *) = null_rtc_get_time;
+int (*rtc_sh_set_time)(const time_t) = null_rtc_set_time;
+
+unsigned int get_rtc_time(struct rtc_time *tm)
+{
+	if (rtc_sh_get_time != null_rtc_get_time) {
+		struct timespec tv;
+
+		rtc_sh_get_time(&tv);
+		rtc_time_to_tm(tv.tv_sec, tm);
+	}
+
+	return RTC_24H;
+}
+EXPORT_SYMBOL(get_rtc_time);
+
+int set_rtc_time(struct rtc_time *tm)
+{
+	unsigned long secs;
+
+	rtc_tm_to_time(tm, &secs);
+	return rtc_sh_set_time(secs);
+}
+EXPORT_SYMBOL(set_rtc_time);
+
+static int __init rtc_generic_init(void)
+{
+	struct platform_device *pdev;
+
+	if (rtc_sh_get_time == null_rtc_get_time)
+		return -ENODEV;
+
+	pdev = platform_device_register_simple("rtc-generic", -1, NULL, 0);
+	if (IS_ERR(pdev))
+		return PTR_ERR(pdev);
+
+	return 0;
+}
+module_init(rtc_generic_init);
+
+/* last time the RTC clock got updated */
+static long last_rtc_update;
+
+/*
+ * handle_timer_tick() needs to keep up the real-time clock,
+ * as well as call the "do_timer()" routine every clocktick
+ */
+void handle_timer_tick(void)
+{
+	if (current->pid)
+		profile_tick(CPU_PROFILING);
+
+	/*
+	 * Here we are in the timer irq handler. We just have irqs locally
+	 * disabled but we don't know if the timer_bh is running on the other
+	 * CPU. We need to avoid to SMP race with it. NOTE: we don' t need
+	 * the irq version of write_lock because as just said we have irq
+	 * locally disabled. -arca
+	 */
+	write_seqlock(&xtime_lock);
+	do_timer(1);
+
+	/*
+	 * If we have an externally synchronized Linux clock, then update
+	 * RTC clock accordingly every ~11 minutes. Set_rtc_mmss() has to be
+	 * called as close as possible to 500 ms before the new second starts.
+	 */
+	if (ntp_synced() &&
+	    xtime.tv_sec > last_rtc_update + 660 &&
+	    (xtime.tv_nsec / 1000) >= 500000 - ((unsigned) TICK_SIZE) / 2 &&
+	    (xtime.tv_nsec / 1000) <= 500000 + ((unsigned) TICK_SIZE) / 2) {
+		if (rtc_sh_set_time(xtime.tv_sec) == 0)
+			last_rtc_update = xtime.tv_sec;
+		else
+			/* do it again in 60s */
+			last_rtc_update = xtime.tv_sec - 600;
+	}
+	write_sequnlock(&xtime_lock);
+
+#ifndef CONFIG_SMP
+	update_process_times(user_mode(get_irq_regs()));
+#endif
+}
+
+#ifdef CONFIG_PM
+int timer_suspend(struct sys_device *dev, pm_message_t state)
+{
+	struct sys_timer *sys_timer = container_of(dev, struct sys_timer, dev);
+
+	sys_timer->ops->stop();
+
+	return 0;
+}
+
+int timer_resume(struct sys_device *dev)
+{
+	struct sys_timer *sys_timer = container_of(dev, struct sys_timer, dev);
+
+	sys_timer->ops->start();
+
+	return 0;
+}
+#else
+#define timer_suspend NULL
+#define timer_resume NULL
+#endif
+
+static struct sysdev_class timer_sysclass = {
+	.name	 = "timer",
+	.suspend = timer_suspend,
+	.resume	 = timer_resume,
+};
+
+static int __init timer_init_sysfs(void)
+{
+	int ret;
+
+	if (!sys_timer)
+		return 0;
+
+	ret = sysdev_class_register(&timer_sysclass);
+	if (ret != 0)
+		return ret;
+
+	sys_timer->dev.cls = &timer_sysclass;
+	return sysdev_register(&sys_timer->dev);
+}
+device_initcall(timer_init_sysfs);
+
+void (*board_time_init)(void);
+
+struct clocksource clocksource_sh = {
+	.name		= "SuperH",
+};
+
+unsigned long long sched_clock(void)
+{
+	unsigned long long cycles;
+
+	/* jiffies based sched_clock if no clocksource is installed */
+	if (!clocksource_sh.rating)
+		return (unsigned long long)jiffies * (NSEC_PER_SEC / HZ);
+
+	cycles = clocksource_sh.read(&clocksource_sh);
+	return cyc2ns(&clocksource_sh, cycles);
+}
+
+static void __init sh_late_time_init(void)
+{
+	/*
+	 * Make sure all compiled-in early timers register themselves.
+	 * Run probe() for one "earlytimer" device.
+	 */
+	early_platform_driver_register_all("earlytimer");
+	if (early_platform_driver_probe("earlytimer", 1, 0))
+		return;
+
+	/*
+	 * Find the timer to use as the system timer, it will be
+	 * initialized for us.
+	 */
+	sys_timer = get_sys_timer();
+	if (unlikely(!sys_timer))
+		panic("System timer missing.\n");
+
+	printk(KERN_INFO "Using %s for system timer\n", sys_timer->name);
+}
+
+void __init time_init(void)
+{
+	if (board_time_init)
+		board_time_init();
+
+	clk_init();
+
+	rtc_sh_get_time(&xtime);
+	set_normalized_timespec(&wall_to_monotonic,
+				-xtime.tv_sec, -xtime.tv_nsec);
+
+#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST
+	local_timer_setup(smp_processor_id());
+#endif
+
+	late_time_init = sh_late_time_init;
+}
+

commit b4eaa1cc7ce8203ac9af9184c49c635ce79592b1
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Nov 21 23:27:52 2007 +0900

    sh: Kill off the rest of arch/sh64/kernel/.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
deleted file mode 100644
index 2bc04bfee738..000000000000
--- a/arch/sh/kernel/time.c
+++ /dev/null
@@ -1,269 +0,0 @@
-/*
- *  arch/sh/kernel/time.c
- *
- *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
- *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
- *  Copyright (C) 2002 - 2007  Paul Mundt
- *  Copyright (C) 2002  M. R. Brown  <mrbrown@linux-sh.org>
- *
- *  Some code taken from i386 version.
- *    Copyright (C) 1991, 1992, 1995  Linus Torvalds
- */
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/profile.h>
-#include <linux/timex.h>
-#include <linux/sched.h>
-#include <linux/clockchips.h>
-#include <asm/clock.h>
-#include <asm/rtc.h>
-#include <asm/timer.h>
-#include <asm/kgdb.h>
-
-struct sys_timer *sys_timer;
-
-/* Move this somewhere more sensible.. */
-DEFINE_SPINLOCK(rtc_lock);
-EXPORT_SYMBOL(rtc_lock);
-
-/* Dummy RTC ops */
-static void null_rtc_get_time(struct timespec *tv)
-{
-	tv->tv_sec = mktime(2000, 1, 1, 0, 0, 0);
-	tv->tv_nsec = 0;
-}
-
-static int null_rtc_set_time(const time_t secs)
-{
-	return 0;
-}
-
-/*
- * Null high precision timer functions for systems lacking one.
- */
-static cycle_t null_hpt_read(void)
-{
-	return 0;
-}
-
-void (*rtc_sh_get_time)(struct timespec *) = null_rtc_get_time;
-int (*rtc_sh_set_time)(const time_t) = null_rtc_set_time;
-
-#ifndef CONFIG_GENERIC_TIME
-void do_gettimeofday(struct timeval *tv)
-{
-	unsigned long flags;
-	unsigned long seq;
-	unsigned long usec, sec;
-
-	do {
-		/*
-		 * Turn off IRQs when grabbing xtime_lock, so that
-		 * the sys_timer get_offset code doesn't have to handle it.
-		 */
-		seq = read_seqbegin_irqsave(&xtime_lock, flags);
-		usec = get_timer_offset();
-		sec = xtime.tv_sec;
-		usec += xtime.tv_nsec / NSEC_PER_USEC;
-	} while (read_seqretry_irqrestore(&xtime_lock, seq, flags));
-
-	while (usec >= 1000000) {
-		usec -= 1000000;
-		sec++;
-	}
-
-	tv->tv_sec = sec;
-	tv->tv_usec = usec;
-}
-EXPORT_SYMBOL(do_gettimeofday);
-
-int do_settimeofday(struct timespec *tv)
-{
-	time_t wtm_sec, sec = tv->tv_sec;
-	long wtm_nsec, nsec = tv->tv_nsec;
-
-	if ((unsigned long)tv->tv_nsec >= NSEC_PER_SEC)
-		return -EINVAL;
-
-	write_seqlock_irq(&xtime_lock);
-	/*
-	 * This is revolting. We need to set "xtime" correctly. However, the
-	 * value in this location is the value at the most recent update of
-	 * wall time.  Discover what correction gettimeofday() would have
-	 * made, and then undo it!
-	 */
-	nsec -= get_timer_offset() * NSEC_PER_USEC;
-
-	wtm_sec  = wall_to_monotonic.tv_sec + (xtime.tv_sec - sec);
-	wtm_nsec = wall_to_monotonic.tv_nsec + (xtime.tv_nsec - nsec);
-
-	set_normalized_timespec(&xtime, sec, nsec);
-	set_normalized_timespec(&wall_to_monotonic, wtm_sec, wtm_nsec);
-
-	ntp_clear();
-	write_sequnlock_irq(&xtime_lock);
-	clock_was_set();
-
-	return 0;
-}
-EXPORT_SYMBOL(do_settimeofday);
-#endif /* !CONFIG_GENERIC_TIME */
-
-#ifndef CONFIG_GENERIC_CLOCKEVENTS
-/* last time the RTC clock got updated */
-static long last_rtc_update;
-
-/*
- * handle_timer_tick() needs to keep up the real-time clock,
- * as well as call the "do_timer()" routine every clocktick
- */
-void handle_timer_tick(void)
-{
-	do_timer(1);
-#ifndef CONFIG_SMP
-	update_process_times(user_mode(get_irq_regs()));
-#endif
-	if (current->pid)
-		profile_tick(CPU_PROFILING);
-
-#ifdef CONFIG_HEARTBEAT
-	if (sh_mv.mv_heartbeat != NULL)
-		sh_mv.mv_heartbeat();
-#endif
-
-	/*
-	 * If we have an externally synchronized Linux clock, then update
-	 * RTC clock accordingly every ~11 minutes. Set_rtc_mmss() has to be
-	 * called as close as possible to 500 ms before the new second starts.
-	 */
-	if (ntp_synced() &&
-	    xtime.tv_sec > last_rtc_update + 660 &&
-	    (xtime.tv_nsec / 1000) >= 500000 - ((unsigned) TICK_SIZE) / 2 &&
-	    (xtime.tv_nsec / 1000) <= 500000 + ((unsigned) TICK_SIZE) / 2) {
-		if (rtc_sh_set_time(xtime.tv_sec) == 0)
-			last_rtc_update = xtime.tv_sec;
-		else
-			/* do it again in 60s */
-			last_rtc_update = xtime.tv_sec - 600;
-	}
-}
-#endif /* !CONFIG_GENERIC_CLOCKEVENTS */
-
-#ifdef CONFIG_PM
-int timer_suspend(struct sys_device *dev, pm_message_t state)
-{
-	struct sys_timer *sys_timer = container_of(dev, struct sys_timer, dev);
-
-	sys_timer->ops->stop();
-
-	return 0;
-}
-
-int timer_resume(struct sys_device *dev)
-{
-	struct sys_timer *sys_timer = container_of(dev, struct sys_timer, dev);
-
-	sys_timer->ops->start();
-
-	return 0;
-}
-#else
-#define timer_suspend NULL
-#define timer_resume NULL
-#endif
-
-static struct sysdev_class timer_sysclass = {
-	.name	 = "timer",
-	.suspend = timer_suspend,
-	.resume	 = timer_resume,
-};
-
-static int __init timer_init_sysfs(void)
-{
-	int ret = sysdev_class_register(&timer_sysclass);
-	if (ret != 0)
-		return ret;
-
-	sys_timer->dev.cls = &timer_sysclass;
-	return sysdev_register(&sys_timer->dev);
-}
-device_initcall(timer_init_sysfs);
-
-void (*board_time_init)(void);
-
-/*
- * Shamelessly based on the MIPS and Sparc64 work.
- */
-static unsigned long timer_ticks_per_nsec_quotient __read_mostly;
-unsigned long sh_hpt_frequency = 0;
-
-#define NSEC_PER_CYC_SHIFT	10
-
-struct clocksource clocksource_sh = {
-	.name		= "SuperH",
-	.rating		= 200,
-	.mask		= CLOCKSOURCE_MASK(32),
-	.read		= null_hpt_read,
-	.shift		= 16,
-	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
-};
-
-static void __init init_sh_clocksource(void)
-{
-	if (!sh_hpt_frequency || clocksource_sh.read == null_hpt_read)
-		return;
-
-	clocksource_sh.mult = clocksource_hz2mult(sh_hpt_frequency,
-						  clocksource_sh.shift);
-
-	timer_ticks_per_nsec_quotient =
-		clocksource_hz2mult(sh_hpt_frequency, NSEC_PER_CYC_SHIFT);
-
-	clocksource_register(&clocksource_sh);
-}
-
-#ifdef CONFIG_GENERIC_TIME
-unsigned long long sched_clock(void)
-{
-	unsigned long long ticks = clocksource_sh.read();
-	return (ticks * timer_ticks_per_nsec_quotient) >> NSEC_PER_CYC_SHIFT;
-}
-#endif
-
-void __init time_init(void)
-{
-	if (board_time_init)
-		board_time_init();
-
-	clk_init();
-
-	rtc_sh_get_time(&xtime);
-	set_normalized_timespec(&wall_to_monotonic,
-				-xtime.tv_sec, -xtime.tv_nsec);
-
-	/*
-	 * Find the timer to use as the system timer, it will be
-	 * initialized for us.
-	 */
-	sys_timer = get_sys_timer();
-	printk(KERN_INFO "Using %s for system timer\n", sys_timer->name);
-
-	if (sys_timer->ops->read)
-		clocksource_sh.read = sys_timer->ops->read;
-
-	init_sh_clocksource();
-
-	if (sh_hpt_frequency)
-		printk("Using %lu.%03lu MHz high precision timer.\n",
-		       ((sh_hpt_frequency + 500) / 1000) / 1000,
-		       ((sh_hpt_frequency + 500) / 1000) % 1000);
-
-#if defined(CONFIG_SH_KGDB)
-	/*
-	 * Set up kgdb as requested. We do it here because the serial
-	 * init uses the timer vars we just set up for figuring baud.
-	 */
-	kgdb_init();
-#endif
-}

commit af5ca3f4ec5cc4432a42a73b050dd8898ce8fd00
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Dec 20 02:09:39 2007 +0100

    Driver core: change sysdev classes to use dynamic kobject names
    
    All kobjects require a dynamically allocated name now. We no longer
    need to keep track if the name is statically assigned, we can just
    unconditionally free() all kobject names on cleanup.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index a3a67d151e52..2bc04bfee738 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -174,7 +174,7 @@ int timer_resume(struct sys_device *dev)
 #endif
 
 static struct sysdev_class timer_sysclass = {
-	set_kset_name("timer"),
+	.name	 = "timer",
 	.suspend = timer_suspend,
 	.resume	 = timer_resume,
 };

commit 57be2b484a417bffae66359b9b89e7239480b729
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed May 9 17:33:24 2007 +0900

    sh: clockevent/clocksource/hrtimers/nohz TMU support.
    
    This adds basic support for clockevents and clocksources,
    presently only implemented for TMU-based systems (which
    are the majority of SH-3 and SH-4 systems).
    
    The old NO_IDLE_HZ implementation is also dropped completely,
    the only users of this were on TMU-based systems anyways.
    
    More work needs to be done to generalize the TMU handling,
    in that the current implementation is rather tied to the
    notion of TMU0 and TMU1 utilization.
    
    Additionally, as more SH timers switch over to this scheme,
    we'll be able to gut most of the remaining system timer
    infrastructure that existed before.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index d47e775962e9..a3a67d151e52 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
  *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
- *  Copyright (C) 2002 - 2006  Paul Mundt
+ *  Copyright (C) 2002 - 2007  Paul Mundt
  *  Copyright (C) 2002  M. R. Brown  <mrbrown@linux-sh.org>
  *
  *  Some code taken from i386 version.
@@ -15,6 +15,7 @@
 #include <linux/profile.h>
 #include <linux/timex.h>
 #include <linux/sched.h>
+#include <linux/clockchips.h>
 #include <asm/clock.h>
 #include <asm/rtc.h>
 #include <asm/timer.h>
@@ -38,6 +39,14 @@ static int null_rtc_set_time(const time_t secs)
 	return 0;
 }
 
+/*
+ * Null high precision timer functions for systems lacking one.
+ */
+static cycle_t null_hpt_read(void)
+{
+	return 0;
+}
+
 void (*rtc_sh_get_time)(struct timespec *) = null_rtc_get_time;
 int (*rtc_sh_set_time)(const time_t) = null_rtc_set_time;
 
@@ -101,6 +110,7 @@ int do_settimeofday(struct timespec *tv)
 EXPORT_SYMBOL(do_settimeofday);
 #endif /* !CONFIG_GENERIC_TIME */
 
+#ifndef CONFIG_GENERIC_CLOCKEVENTS
 /* last time the RTC clock got updated */
 static long last_rtc_update;
 
@@ -138,6 +148,7 @@ void handle_timer_tick(void)
 			last_rtc_update = xtime.tv_sec - 600;
 	}
 }
+#endif /* !CONFIG_GENERIC_CLOCKEVENTS */
 
 #ifdef CONFIG_PM
 int timer_suspend(struct sys_device *dev, pm_message_t state)
@@ -168,136 +179,58 @@ static struct sysdev_class timer_sysclass = {
 	.resume	 = timer_resume,
 };
 
-#ifdef CONFIG_NO_IDLE_HZ
-static int timer_dyn_tick_enable(void)
+static int __init timer_init_sysfs(void)
 {
-	struct dyn_tick_timer *dyn_tick = sys_timer->dyn_tick;
-	unsigned long flags;
-	int ret = -ENODEV;
-
-	if (dyn_tick) {
-		spin_lock_irqsave(&dyn_tick->lock, flags);
-		ret = 0;
-		if (!(dyn_tick->state & DYN_TICK_ENABLED)) {
-			ret = dyn_tick->enable();
-
-			if (ret == 0)
-				dyn_tick->state |= DYN_TICK_ENABLED;
-		}
-		spin_unlock_irqrestore(&dyn_tick->lock, flags);
-	}
+	int ret = sysdev_class_register(&timer_sysclass);
+	if (ret != 0)
+		return ret;
 
-	return ret;
+	sys_timer->dev.cls = &timer_sysclass;
+	return sysdev_register(&sys_timer->dev);
 }
+device_initcall(timer_init_sysfs);
 
-static int timer_dyn_tick_disable(void)
-{
-	struct dyn_tick_timer *dyn_tick = sys_timer->dyn_tick;
-	unsigned long flags;
-	int ret = -ENODEV;
-
-	if (dyn_tick) {
-		spin_lock_irqsave(&dyn_tick->lock, flags);
-		ret = 0;
-		if (dyn_tick->state & DYN_TICK_ENABLED) {
-			ret = dyn_tick->disable();
-
-			if (ret == 0)
-				dyn_tick->state &= ~DYN_TICK_ENABLED;
-		}
-		spin_unlock_irqrestore(&dyn_tick->lock, flags);
-	}
-
-	return ret;
-}
+void (*board_time_init)(void);
 
 /*
- * Reprogram the system timer for at least the calculated time interval.
- * This function should be called from the idle thread with IRQs disabled,
- * immediately before sleeping.
+ * Shamelessly based on the MIPS and Sparc64 work.
  */
-void timer_dyn_reprogram(void)
-{
-	struct dyn_tick_timer *dyn_tick = sys_timer->dyn_tick;
-	unsigned long next, seq, flags;
-
-	if (!dyn_tick)
-		return;
-
-	spin_lock_irqsave(&dyn_tick->lock, flags);
-	if (dyn_tick->state & DYN_TICK_ENABLED) {
-		next = next_timer_interrupt();
-		do {
-			seq = read_seqbegin(&xtime_lock);
-			dyn_tick->reprogram(next - jiffies);
-		} while (read_seqretry(&xtime_lock, seq));
-	}
-	spin_unlock_irqrestore(&dyn_tick->lock, flags);
-}
+static unsigned long timer_ticks_per_nsec_quotient __read_mostly;
+unsigned long sh_hpt_frequency = 0;
+
+#define NSEC_PER_CYC_SHIFT	10
+
+struct clocksource clocksource_sh = {
+	.name		= "SuperH",
+	.rating		= 200,
+	.mask		= CLOCKSOURCE_MASK(32),
+	.read		= null_hpt_read,
+	.shift		= 16,
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
 
-static ssize_t timer_show_dyn_tick(struct sys_device *dev, char *buf)
+static void __init init_sh_clocksource(void)
 {
-	return sprintf(buf, "%i\n",
-		       (sys_timer->dyn_tick->state & DYN_TICK_ENABLED) >> 1);
-}
+	if (!sh_hpt_frequency || clocksource_sh.read == null_hpt_read)
+		return;
 
-static ssize_t timer_set_dyn_tick(struct sys_device *dev, const char *buf,
-				  size_t count)
-{
-	unsigned int enable = simple_strtoul(buf, NULL, 2);
+	clocksource_sh.mult = clocksource_hz2mult(sh_hpt_frequency,
+						  clocksource_sh.shift);
 
-	if (enable)
-		timer_dyn_tick_enable();
-	else
-		timer_dyn_tick_disable();
+	timer_ticks_per_nsec_quotient =
+		clocksource_hz2mult(sh_hpt_frequency, NSEC_PER_CYC_SHIFT);
 
-	return count;
+	clocksource_register(&clocksource_sh);
 }
-static SYSDEV_ATTR(dyn_tick, 0644, timer_show_dyn_tick, timer_set_dyn_tick);
 
-/*
- * dyntick=enable|disable
- */
-static char dyntick_str[4] __initdata = "";
-
-static int __init dyntick_setup(char *str)
+#ifdef CONFIG_GENERIC_TIME
+unsigned long long sched_clock(void)
 {
-	if (str)
-		strlcpy(dyntick_str, str, sizeof(dyntick_str));
-	return 1;
+	unsigned long long ticks = clocksource_sh.read();
+	return (ticks * timer_ticks_per_nsec_quotient) >> NSEC_PER_CYC_SHIFT;
 }
-
-__setup("dyntick=", dyntick_setup);
-#endif
-
-static int __init timer_init_sysfs(void)
-{
-	int ret = sysdev_class_register(&timer_sysclass);
-	if (ret != 0)
-		return ret;
-
-	sys_timer->dev.cls = &timer_sysclass;
-	ret = sysdev_register(&sys_timer->dev);
-
-#ifdef CONFIG_NO_IDLE_HZ
-	if (ret == 0 && sys_timer->dyn_tick) {
-		ret = sysdev_create_file(&sys_timer->dev, &attr_dyn_tick);
-
-		/*
-		 * Turn on dynamic tick after calibrate delay
-		 * for correct bogomips
-		 */
-		if (ret == 0 && dyntick_str[0] == 'e')
-			ret = timer_dyn_tick_enable();
-	}
 #endif
 
-	return ret;
-}
-device_initcall(timer_init_sysfs);
-
-void (*board_time_init)(void);
-
 void __init time_init(void)
 {
 	if (board_time_init)
@@ -316,10 +249,15 @@ void __init time_init(void)
 	sys_timer = get_sys_timer();
 	printk(KERN_INFO "Using %s for system timer\n", sys_timer->name);
 
-#ifdef CONFIG_NO_IDLE_HZ
-	if (sys_timer->dyn_tick)
-		spin_lock_init(&sys_timer->dyn_tick->lock);
-#endif
+	if (sys_timer->ops->read)
+		clocksource_sh.read = sys_timer->ops->read;
+
+	init_sh_clocksource();
+
+	if (sh_hpt_frequency)
+		printk("Using %lu.%03lu MHz high precision timer.\n",
+		       ((sh_hpt_frequency + 500) / 1000) / 1000,
+		       ((sh_hpt_frequency + 500) / 1000) % 1000);
 
 #if defined(CONFIG_SH_KGDB)
 	/*

commit b035b6de24932ffd4a2b1c6619a2f5711da6920f
Author: Alexey Dobriyan <adobriyan@openvz.org>
Date:   Sat Feb 10 01:45:10 2007 -0800

    [PATCH] Consolidate default sched_clock()
    
    Use attribute(weak).
    
    Signed-off-by: Alexey Dobriyan <adobriyan@openvz.org>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index c206c9504c4b..d47e775962e9 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -41,14 +41,6 @@ static int null_rtc_set_time(const time_t secs)
 void (*rtc_sh_get_time)(struct timespec *) = null_rtc_get_time;
 int (*rtc_sh_set_time)(const time_t) = null_rtc_set_time;
 
-/*
- * Scheduler clock - returns current time in nanosec units.
- */
-unsigned long long __attribute__ ((weak)) sched_clock(void)
-{
-	return (unsigned long long)jiffies * (1000000000 / HZ);
-}
-
 #ifndef CONFIG_GENERIC_TIME
 void do_gettimeofday(struct timeval *tv)
 {

commit 65e5d90de6dba9975332dac4f849b81f663e16fa
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Dec 6 11:24:48 2006 +0900

    sh: compile fixes for header cleanup.
    
    Since some header inclusion paths were cleaned up, compilation
    broke. Add in the headers we need directly to build again.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 1b91c7214979..c206c9504c4b 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -13,6 +13,8 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/profile.h>
+#include <linux/timex.h>
+#include <linux/sched.h>
 #include <asm/clock.h>
 #include <asm/rtc.h>
 #include <asm/timer.h>

commit bd156147eb63ae525e0ac67868e41a808f03c532
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Dec 1 13:23:47 2006 +0900

    sh: dyntick infrastructure.
    
    This adds basic NO_IDLE_HZ support to the SH timer API so timers
    are able to wire it up. Taken from the ARM version, as it fit in
    to our API with very few changes needed.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index c55d6f217a46..1b91c7214979 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -174,6 +174,108 @@ static struct sysdev_class timer_sysclass = {
 	.resume	 = timer_resume,
 };
 
+#ifdef CONFIG_NO_IDLE_HZ
+static int timer_dyn_tick_enable(void)
+{
+	struct dyn_tick_timer *dyn_tick = sys_timer->dyn_tick;
+	unsigned long flags;
+	int ret = -ENODEV;
+
+	if (dyn_tick) {
+		spin_lock_irqsave(&dyn_tick->lock, flags);
+		ret = 0;
+		if (!(dyn_tick->state & DYN_TICK_ENABLED)) {
+			ret = dyn_tick->enable();
+
+			if (ret == 0)
+				dyn_tick->state |= DYN_TICK_ENABLED;
+		}
+		spin_unlock_irqrestore(&dyn_tick->lock, flags);
+	}
+
+	return ret;
+}
+
+static int timer_dyn_tick_disable(void)
+{
+	struct dyn_tick_timer *dyn_tick = sys_timer->dyn_tick;
+	unsigned long flags;
+	int ret = -ENODEV;
+
+	if (dyn_tick) {
+		spin_lock_irqsave(&dyn_tick->lock, flags);
+		ret = 0;
+		if (dyn_tick->state & DYN_TICK_ENABLED) {
+			ret = dyn_tick->disable();
+
+			if (ret == 0)
+				dyn_tick->state &= ~DYN_TICK_ENABLED;
+		}
+		spin_unlock_irqrestore(&dyn_tick->lock, flags);
+	}
+
+	return ret;
+}
+
+/*
+ * Reprogram the system timer for at least the calculated time interval.
+ * This function should be called from the idle thread with IRQs disabled,
+ * immediately before sleeping.
+ */
+void timer_dyn_reprogram(void)
+{
+	struct dyn_tick_timer *dyn_tick = sys_timer->dyn_tick;
+	unsigned long next, seq, flags;
+
+	if (!dyn_tick)
+		return;
+
+	spin_lock_irqsave(&dyn_tick->lock, flags);
+	if (dyn_tick->state & DYN_TICK_ENABLED) {
+		next = next_timer_interrupt();
+		do {
+			seq = read_seqbegin(&xtime_lock);
+			dyn_tick->reprogram(next - jiffies);
+		} while (read_seqretry(&xtime_lock, seq));
+	}
+	spin_unlock_irqrestore(&dyn_tick->lock, flags);
+}
+
+static ssize_t timer_show_dyn_tick(struct sys_device *dev, char *buf)
+{
+	return sprintf(buf, "%i\n",
+		       (sys_timer->dyn_tick->state & DYN_TICK_ENABLED) >> 1);
+}
+
+static ssize_t timer_set_dyn_tick(struct sys_device *dev, const char *buf,
+				  size_t count)
+{
+	unsigned int enable = simple_strtoul(buf, NULL, 2);
+
+	if (enable)
+		timer_dyn_tick_enable();
+	else
+		timer_dyn_tick_disable();
+
+	return count;
+}
+static SYSDEV_ATTR(dyn_tick, 0644, timer_show_dyn_tick, timer_set_dyn_tick);
+
+/*
+ * dyntick=enable|disable
+ */
+static char dyntick_str[4] __initdata = "";
+
+static int __init dyntick_setup(char *str)
+{
+	if (str)
+		strlcpy(dyntick_str, str, sizeof(dyntick_str));
+	return 1;
+}
+
+__setup("dyntick=", dyntick_setup);
+#endif
+
 static int __init timer_init_sysfs(void)
 {
 	int ret = sysdev_class_register(&timer_sysclass);
@@ -181,7 +283,22 @@ static int __init timer_init_sysfs(void)
 		return ret;
 
 	sys_timer->dev.cls = &timer_sysclass;
-	return sysdev_register(&sys_timer->dev);
+	ret = sysdev_register(&sys_timer->dev);
+
+#ifdef CONFIG_NO_IDLE_HZ
+	if (ret == 0 && sys_timer->dyn_tick) {
+		ret = sysdev_create_file(&sys_timer->dev, &attr_dyn_tick);
+
+		/*
+		 * Turn on dynamic tick after calibrate delay
+		 * for correct bogomips
+		 */
+		if (ret == 0 && dyntick_str[0] == 'e')
+			ret = timer_dyn_tick_enable();
+	}
+#endif
+
+	return ret;
 }
 device_initcall(timer_init_sysfs);
 
@@ -205,6 +322,11 @@ void __init time_init(void)
 	sys_timer = get_sys_timer();
 	printk(KERN_INFO "Using %s for system timer\n", sys_timer->name);
 
+#ifdef CONFIG_NO_IDLE_HZ
+	if (sys_timer->dyn_tick)
+		spin_lock_init(&sys_timer->dyn_tick->lock);
+#endif
+
 #if defined(CONFIG_SH_KGDB)
 	/*
 	 * Set up kgdb as requested. We do it here because the serial

commit e74b56800e78a10bc09b56a87831876a1d9d09ae
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Dec 1 13:12:05 2006 +0900

    sh: Turn off IRQs around get_timer_offset() calls.
    
    Since all of the sys_timer sources currently do this on their own
    within the ->get_offset() path, it's more sensible to just have
    the caller take care of it when grabbing xtime_lock. Incidentally,
    this is more in line with what others (ie, ARM) are doing already.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 57e708d7b52d..c55d6f217a46 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -50,15 +50,20 @@ unsigned long long __attribute__ ((weak)) sched_clock(void)
 #ifndef CONFIG_GENERIC_TIME
 void do_gettimeofday(struct timeval *tv)
 {
+	unsigned long flags;
 	unsigned long seq;
 	unsigned long usec, sec;
 
 	do {
-		seq = read_seqbegin(&xtime_lock);
+		/*
+		 * Turn off IRQs when grabbing xtime_lock, so that
+		 * the sys_timer get_offset code doesn't have to handle it.
+		 */
+		seq = read_seqbegin_irqsave(&xtime_lock, flags);
 		usec = get_timer_offset();
 		sec = xtime.tv_sec;
-		usec += xtime.tv_nsec / 1000;
-	} while (read_seqretry(&xtime_lock, seq));
+		usec += xtime.tv_nsec / NSEC_PER_USEC;
+	} while (read_seqretry_irqrestore(&xtime_lock, seq, flags));
 
 	while (usec >= 1000000) {
 		usec -= 1000000;
@@ -85,7 +90,7 @@ int do_settimeofday(struct timespec *tv)
 	 * wall time.  Discover what correction gettimeofday() would have
 	 * made, and then undo it!
 	 */
-	nsec -= 1000 * get_timer_offset();
+	nsec -= get_timer_offset() * NSEC_PER_USEC;
 
 	wtm_sec  = wall_to_monotonic.tv_sec + (xtime.tv_sec - sec);
 	wtm_nsec = wall_to_monotonic.tv_nsec + (xtime.tv_nsec - nsec);

commit 35f3c5185b1e28e6591aa649db8bf4fa16f1a7f3
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Oct 6 15:31:16 2006 +0900

    sh: Updates for IRQ handler changes.
    
    Trivial fixes for build breakage introduced by IRQ handler changes.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 1fbb83c665dd..57e708d7b52d 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -109,13 +109,14 @@ static long last_rtc_update;
  * handle_timer_tick() needs to keep up the real-time clock,
  * as well as call the "do_timer()" routine every clocktick
  */
-void handle_timer_tick(struct pt_regs *regs)
+void handle_timer_tick(void)
 {
 	do_timer(1);
 #ifndef CONFIG_SMP
-	update_process_times(user_mode(regs));
+	update_process_times(user_mode(get_irq_regs()));
 #endif
-	profile_tick(CPU_PROFILING, regs);
+	if (current->pid)
+		profile_tick(CPU_PROFILING);
 
 #ifdef CONFIG_HEARTBEAT
 	if (sh_mv.mv_heartbeat != NULL)

commit 458821452642fd5dc2377b73cd1323fd4a9653e7
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Oct 4 13:21:45 2006 +0900

    sh: First step at generic timeofday support.
    
    At the moment we wrap GENERIC_TIME around our existing timer API.
    As boards start providing their own clocksources, they're able to
    select GENERIC_TIME accordingly and optimize out most of the timer
    API.
    
    Once the current timers have been reworked as proper clocksource
    drivers, the rest of the place holders for the timer API can go
    away and we can flip on GENERIC_TIME unconditionally.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 450c68f1df05..1fbb83c665dd 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -47,6 +47,7 @@ unsigned long long __attribute__ ((weak)) sched_clock(void)
 	return (unsigned long long)jiffies * (1000000000 / HZ);
 }
 
+#ifndef CONFIG_GENERIC_TIME
 void do_gettimeofday(struct timeval *tv)
 {
 	unsigned long seq;
@@ -99,6 +100,7 @@ int do_settimeofday(struct timespec *tv)
 	return 0;
 }
 EXPORT_SYMBOL(do_settimeofday);
+#endif /* !CONFIG_GENERIC_TIME */
 
 /* last time the RTC clock got updated */
 static long last_rtc_update;

commit 8ef386092d7c2891bd7acefb2a87f878f7e9a0d6
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Sat Sep 30 23:28:31 2006 -0700

    [PATCH] kill wall_jiffies
    
    With 2.6.18-rc4-mm2, now wall_jiffies will always be the same as jiffies.
    So we can kill wall_jiffies completely.
    
    This is just a cleanup and logically should not change any real behavior
    except for one thing: RTC updating code in (old) ppc and xtensa use a
    condition "jiffies - wall_jiffies == 1".  This condition is never met so I
    suppose it is just a bug.  I just remove that condition only instead of
    kill the whole "if" block.
    
    [heiko.carstens@de.ibm.com: s390 build fix and cleanup]
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Cc: Andi Kleen <ak@muc.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Ian Molton <spyro@f2s.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Hirokazu Takata <takata.hirokazu@renesas.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Kazumoto Kojima <kkojima@rr.iij4u.or.jp>
    Cc: Richard Curnow <rc@rc0.org.uk>
    Cc: William Lee Irwin III <wli@holomorphy.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Cc: Miles Bader <uclinux-v850@lsi.nec.co.jp>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index f664a196c4f5..450c68f1df05 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -18,7 +18,6 @@
 #include <asm/timer.h>
 #include <asm/kgdb.h>
 
-extern unsigned long wall_jiffies;
 struct sys_timer *sys_timer;
 
 /* Move this somewhere more sensible.. */
@@ -52,16 +51,10 @@ void do_gettimeofday(struct timeval *tv)
 {
 	unsigned long seq;
 	unsigned long usec, sec;
-	unsigned long lost;
 
 	do {
 		seq = read_seqbegin(&xtime_lock);
 		usec = get_timer_offset();
-
-		lost = jiffies - wall_jiffies;
-		if (lost)
-			usec += lost * (1000000 / HZ);
-
 		sec = xtime.tv_sec;
 		usec += xtime.tv_nsec / 1000;
 	} while (read_seqretry(&xtime_lock, seq));
@@ -91,8 +84,7 @@ int do_settimeofday(struct timespec *tv)
 	 * wall time.  Discover what correction gettimeofday() would have
 	 * made, and then undo it!
 	 */
-	nsec -= 1000 * (get_timer_offset() +
-				(jiffies - wall_jiffies) * (1000000 / HZ));
+	nsec -= 1000 * get_timer_offset();
 
 	wtm_sec  = wall_to_monotonic.tv_sec + (xtime.tv_sec - sec);
 	wtm_nsec = wall_to_monotonic.tv_nsec + (xtime.tv_nsec - nsec);

commit 3171a0305d62e6627a24bff35af4f997e4988a80
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Sep 29 02:00:32 2006 -0700

    [PATCH] simplify update_times (avoid jiffies/jiffies_64 aliasing problem)
    
    Pass ticks to do_timer() and update_times(), and adjust x86_64 and s390
    timer interrupt handler with this change.
    
    Currently update_times() calculates ticks by "jiffies - wall_jiffies", but
    callers of do_timer() should know how many ticks to update.  Passing ticks
    get rid of this redundant calculation.  Also there are another redundancy
    pointed out by Martin Schwidefsky.
    
    This cleanup make a barrier added by
    5aee405c662ca644980c184774277fc6d0769a84 needless.  So this patch removes
    it.
    
    As a bonus, this cleanup make wall_jiffies can be removed easily, since now
    wall_jiffies is always synced with jiffies.  (This patch does not really
    remove wall_jiffies.  It would be another cleanup patch)
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Andi Kleen <ak@muc.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Acked-by: Russell King <rmk@arm.linux.org.uk>
    Cc: Ian Molton <spyro@f2s.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Hirokazu Takata <takata.hirokazu@renesas.com>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Kazumoto Kojima <kkojima@rr.iij4u.or.jp>
    Cc: Richard Curnow <rc@rc0.org.uk>
    Cc: William Lee Irwin III <wli@holomorphy.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Cc: Miles Bader <uclinux-v850@lsi.nec.co.jp>
    Cc: Chris Zankel <chris@zankel.net>
    Acked-by: "Luck, Tony" <tony.luck@intel.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 149d9713eddf..f664a196c4f5 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -117,7 +117,7 @@ static long last_rtc_update;
  */
 void handle_timer_tick(struct pt_regs *regs)
 {
-	do_timer(regs);
+	do_timer(1);
 #ifndef CONFIG_SMP
 	update_process_times(user_mode(regs));
 #endif

commit 91550f715b7f7707b5ab5b9b0cd455bda8505954
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 17:45:01 2006 +0900

    sh: Kill off the rest of the legacy rtc mess.
    
    With the new RTC class driver, we can get rid of most of the
    old left over cruft.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 8acd70bffe76..149d9713eddf 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -3,13 +3,12 @@
  *
  *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
  *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
- *  Copyright (C) 2002, 2003, 2004, 2005  Paul Mundt
+ *  Copyright (C) 2002 - 2006  Paul Mundt
  *  Copyright (C) 2002  M. R. Brown  <mrbrown@linux-sh.org>
  *
  *  Some code taken from i386 version.
  *    Copyright (C) 1991, 1992, 1995  Linus Torvalds
  */
-
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -26,15 +25,20 @@ struct sys_timer *sys_timer;
 DEFINE_SPINLOCK(rtc_lock);
 EXPORT_SYMBOL(rtc_lock);
 
-/* XXX: Can we initialize this in a routine somewhere?  Dreamcast doesn't want
- * these routines anywhere... */
-#ifdef CONFIG_SH_RTC
-void (*rtc_sh_get_time)(struct timespec *) = sh_rtc_gettimeofday;
-int (*rtc_sh_set_time)(const time_t) = sh_rtc_settimeofday;
-#else
-void (*rtc_sh_get_time)(struct timespec *);
-int (*rtc_sh_set_time)(const time_t);
-#endif
+/* Dummy RTC ops */
+static void null_rtc_get_time(struct timespec *tv)
+{
+	tv->tv_sec = mktime(2000, 1, 1, 0, 0, 0);
+	tv->tv_nsec = 0;
+}
+
+static int null_rtc_set_time(const time_t secs)
+{
+	return 0;
+}
+
+void (*rtc_sh_get_time)(struct timespec *) = null_rtc_get_time;
+int (*rtc_sh_set_time)(const time_t) = null_rtc_set_time;
 
 /*
  * Scheduler clock - returns current time in nanosec units.
@@ -70,7 +74,6 @@ void do_gettimeofday(struct timeval *tv)
 	tv->tv_sec = sec;
 	tv->tv_usec = usec;
 }
-
 EXPORT_SYMBOL(do_gettimeofday);
 
 int do_settimeofday(struct timespec *tv)
@@ -103,7 +106,6 @@ int do_settimeofday(struct timespec *tv)
 
 	return 0;
 }
-
 EXPORT_SYMBOL(do_settimeofday);
 
 /* last time the RTC clock got updated */
@@ -181,7 +183,6 @@ static int __init timer_init_sysfs(void)
 	sys_timer->dev.cls = &timer_sysclass;
 	return sysdev_register(&sys_timer->dev);
 }
-
 device_initcall(timer_init_sysfs);
 
 void (*board_time_init)(void);
@@ -193,15 +194,9 @@ void __init time_init(void)
 
 	clk_init();
 
-	if (rtc_sh_get_time) {
-		rtc_sh_get_time(&xtime);
-	} else {
-		xtime.tv_sec = mktime(2000, 1, 1, 0, 0, 0);
-		xtime.tv_nsec = 0;
-	}
-
-        set_normalized_timespec(&wall_to_monotonic,
-                                -xtime.tv_sec, -xtime.tv_nsec);
+	rtc_sh_get_time(&xtime);
+	set_normalized_timespec(&wall_to_monotonic,
+				-xtime.tv_sec, -xtime.tv_nsec);
 
 	/*
 	 * Find the timer to use as the system timer, it will be

commit af514ca7d27b31e3c278e1331f0ebdb3ad385a90
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 17:11:32 2006 +0900

    sh: Rename rtc_get/set_time() to avoid RTC_CLASS conflict.
    
    We have a clash with RTC_CLASS over these names, so we
    change them..
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index c8db6ca4f9d1..8acd70bffe76 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -29,11 +29,11 @@ EXPORT_SYMBOL(rtc_lock);
 /* XXX: Can we initialize this in a routine somewhere?  Dreamcast doesn't want
  * these routines anywhere... */
 #ifdef CONFIG_SH_RTC
-void (*rtc_get_time)(struct timespec *) = sh_rtc_gettimeofday;
-int (*rtc_set_time)(const time_t) = sh_rtc_settimeofday;
+void (*rtc_sh_get_time)(struct timespec *) = sh_rtc_gettimeofday;
+int (*rtc_sh_set_time)(const time_t) = sh_rtc_settimeofday;
 #else
-void (*rtc_get_time)(struct timespec *);
-int (*rtc_set_time)(const time_t);
+void (*rtc_sh_get_time)(struct timespec *);
+int (*rtc_sh_set_time)(const time_t);
 #endif
 
 /*
@@ -135,7 +135,7 @@ void handle_timer_tick(struct pt_regs *regs)
 	    xtime.tv_sec > last_rtc_update + 660 &&
 	    (xtime.tv_nsec / 1000) >= 500000 - ((unsigned) TICK_SIZE) / 2 &&
 	    (xtime.tv_nsec / 1000) <= 500000 + ((unsigned) TICK_SIZE) / 2) {
-		if (rtc_set_time(xtime.tv_sec) == 0)
+		if (rtc_sh_set_time(xtime.tv_sec) == 0)
 			last_rtc_update = xtime.tv_sec;
 		else
 			/* do it again in 60s */
@@ -193,8 +193,8 @@ void __init time_init(void)
 
 	clk_init();
 
-	if (rtc_get_time) {
-		rtc_get_time(&xtime);
+	if (rtc_sh_get_time) {
+		rtc_sh_get_time(&xtime);
 	} else {
 		xtime.tv_sec = mktime(2000, 1, 1, 0, 0, 0);
 		xtime.tv_nsec = 0;

commit 3aa770e7972723f479122cf66b529017d2175289
Author: Andriy Skulysh <askulysh@gmail.com>
Date:   Wed Sep 27 16:20:22 2006 +0900

    sh: APM/PM support.
    
    This adds some simple PM stubs and the basic APM interfaces,
    primarily for use by hp6xx, where the existing userland
    expects it.
    
    Signed-off-by: Andriy Skulysh <askulysh@gmail.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index a1589f85499d..c8db6ca4f9d1 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -143,8 +143,33 @@ void handle_timer_tick(struct pt_regs *regs)
 	}
 }
 
+#ifdef CONFIG_PM
+int timer_suspend(struct sys_device *dev, pm_message_t state)
+{
+	struct sys_timer *sys_timer = container_of(dev, struct sys_timer, dev);
+
+	sys_timer->ops->stop();
+
+	return 0;
+}
+
+int timer_resume(struct sys_device *dev)
+{
+	struct sys_timer *sys_timer = container_of(dev, struct sys_timer, dev);
+
+	sys_timer->ops->start();
+
+	return 0;
+}
+#else
+#define timer_suspend NULL
+#define timer_resume NULL
+#endif
+
 static struct sysdev_class timer_sysclass = {
 	set_kset_name("timer"),
+	.suspend = timer_suspend,
+	.resume	 = timer_resume,
 };
 
 static int __init timer_init_sysfs(void)

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 314a275c04e0..a1589f85499d 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -10,7 +10,6 @@
  *    Copyright (C) 1991, 1992, 1995  Linus Torvalds
  */
 
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>

commit 36ddf31b689a8c11d424e43565d2aa440b77bbf4
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Jan 16 22:14:17 2006 -0800

    [PATCH] sh: Simplistic clock framework
    
    This adds a relatively simplistic clock framework for sh.  The initial goal
    behind this is to clean up the arch/sh/kernel/time.c mess and to get the CPU
    subtype-specific frequency setting and calculation code moved somewhere more
    sensible.
    
    This only deals with the core clocks at the moment, though it's trivial for
    other drivers to define their own clocks as desired.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Cc: john stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 671b876416bf..314a275c04e0 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
  *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
- *  Copyright (C) 2002, 2003, 2004  Paul Mundt
+ *  Copyright (C) 2002, 2003, 2004, 2005  Paul Mundt
  *  Copyright (C) 2002  M. R. Brown  <mrbrown@linux-sh.org>
  *
  *  Some code taken from i386 version.
@@ -11,50 +11,21 @@
  */
 
 #include <linux/config.h>
-#include <linux/errno.h>
-#include <linux/module.h>
-#include <linux/sched.h>
 #include <linux/kernel.h>
-#include <linux/param.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/interrupt.h>
-#include <linux/time.h>
-#include <linux/delay.h>
+#include <linux/module.h>
 #include <linux/init.h>
-#include <linux/smp.h>
 #include <linux/profile.h>
-
-#include <asm/processor.h>
-#include <asm/uaccess.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/delay.h>
-#include <asm/machvec.h>
+#include <asm/clock.h>
 #include <asm/rtc.h>
-#include <asm/freq.h>
-#include <asm/cpu/timer.h>
-#ifdef CONFIG_SH_KGDB
+#include <asm/timer.h>
 #include <asm/kgdb.h>
-#endif
-
-#include <linux/timex.h>
-#include <linux/irq.h>
-
-#define TMU_TOCR_INIT	0x00
-#define TMU0_TCR_INIT	0x0020
-#define TMU_TSTR_INIT	1
-
-#define TMU0_TCR_CALIB	0x0000
-
-#ifdef CONFIG_CPU_SUBTYPE_ST40STB1
-#define CLOCKGEN_MEMCLKCR 0xbb040038
-#define MEMCLKCR_RATIO_MASK 0x7
-#endif /* CONFIG_CPU_SUBTYPE_ST40STB1 */
 
 extern unsigned long wall_jiffies;
-#define TICK_SIZE (tick_nsec / 1000)
-DEFINE_SPINLOCK(tmu0_lock);
+struct sys_timer *sys_timer;
+
+/* Move this somewhere more sensible.. */
+DEFINE_SPINLOCK(rtc_lock);
+EXPORT_SYMBOL(rtc_lock);
 
 /* XXX: Can we initialize this in a routine somewhere?  Dreamcast doesn't want
  * these routines anywhere... */
@@ -66,98 +37,14 @@ void (*rtc_get_time)(struct timespec *);
 int (*rtc_set_time)(const time_t);
 #endif
 
-#if defined(CONFIG_CPU_SUBTYPE_SH7300)
-static int md_table[] = { 1, 2, 3, 4, 6, 8, 12 };
-#endif
-#if defined(CONFIG_CPU_SH3)
-static int stc_multipliers[] = { 1, 2, 3, 4, 6, 1, 1, 1 };
-static int stc_values[]      = { 0, 1, 4, 2, 5, 0, 0, 0 };
-#define bfc_divisors stc_multipliers
-#define bfc_values stc_values
-static int ifc_divisors[]    = { 1, 2, 3, 4, 1, 1, 1, 1 };
-static int ifc_values[]      = { 0, 1, 4, 2, 0, 0, 0, 0 };
-static int pfc_divisors[]    = { 1, 2, 3, 4, 6, 1, 1, 1 };
-static int pfc_values[]      = { 0, 1, 4, 2, 5, 0, 0, 0 };
-#elif defined(CONFIG_CPU_SH4)
-#if defined(CONFIG_CPU_SUBTYPE_SH73180)
-static int ifc_divisors[] = { 1, 2, 3, 4, 6, 8, 12, 16 };
-static int ifc_values[] = { 0, 1, 2, 3, 4, 5, 6, 7 };
-#define bfc_divisors ifc_divisors	/* Same */
-#define bfc_values ifc_values
-#define pfc_divisors ifc_divisors	/* Same */
-#define pfc_values ifc_values
-#else
-static int ifc_divisors[] = { 1, 2, 3, 4, 6, 8, 1, 1 };
-static int ifc_values[]   = { 0, 1, 2, 3, 0, 4, 0, 5 };
-#define bfc_divisors ifc_divisors	/* Same */
-#define bfc_values ifc_values
-static int pfc_divisors[] = { 2, 3, 4, 6, 8, 2, 2, 2 };
-static int pfc_values[]   = { 0, 0, 1, 2, 0, 3, 0, 4 };
-#endif
-#else
-#error "Unknown ifc/bfc/pfc/stc values for this processor"
-#endif
-
 /*
  * Scheduler clock - returns current time in nanosec units.
  */
-unsigned long long sched_clock(void)
+unsigned long long __attribute__ ((weak)) sched_clock(void)
 {
 	return (unsigned long long)jiffies * (1000000000 / HZ);
 }
 
-static unsigned long do_gettimeoffset(void)
-{
-	int count;
-	unsigned long flags;
-
-	static int count_p = 0x7fffffff;    /* for the first call after boot */
-	static unsigned long jiffies_p = 0;
-
-	/*
-	 * cache volatile jiffies temporarily; we have IRQs turned off.
-	 */
-	unsigned long jiffies_t;
-
-	spin_lock_irqsave(&tmu0_lock, flags);
-	/* timer count may underflow right here */
-	count = ctrl_inl(TMU0_TCNT);	/* read the latched count */
-
-	jiffies_t = jiffies;
-
-	/*
-	 * avoiding timer inconsistencies (they are rare, but they happen)...
-	 * there is one kind of problem that must be avoided here:
-	 *  1. the timer counter underflows
-	 */
-
-	if( jiffies_t == jiffies_p ) {
-		if( count > count_p ) {
-			/* the nutcase */
-
-			if(ctrl_inw(TMU0_TCR) & 0x100) { /* Check UNF bit */
-				/*
-				 * We cannot detect lost timer interrupts ...
-				 * well, that's why we call them lost, don't we? :)
-				 * [hmm, on the Pentium and Alpha we can ... sort of]
-				 */
-				count -= LATCH;
-			} else {
-				printk("do_slow_gettimeoffset(): hardware timer problem?\n");
-			}
-		}
-	} else
-		jiffies_p = jiffies_t;
-
-	count_p = count;
-	spin_unlock_irqrestore(&tmu0_lock, flags);
-
-	count = ((LATCH-1) - count) * TICK_SIZE;
-	count = (count + LATCH/2) / LATCH;
-
-	return count;
-}
-
 void do_gettimeofday(struct timeval *tv)
 {
 	unsigned long seq;
@@ -166,7 +53,7 @@ void do_gettimeofday(struct timeval *tv)
 
 	do {
 		seq = read_seqbegin(&xtime_lock);
-		usec = do_gettimeoffset();
+		usec = get_timer_offset();
 
 		lost = jiffies - wall_jiffies;
 		if (lost)
@@ -202,7 +89,7 @@ int do_settimeofday(struct timespec *tv)
 	 * wall time.  Discover what correction gettimeofday() would have
 	 * made, and then undo it!
 	 */
-	nsec -= 1000 * (do_gettimeoffset() +
+	nsec -= 1000 * (get_timer_offset() +
 				(jiffies - wall_jiffies) * (1000000 / HZ));
 
 	wtm_sec  = wall_to_monotonic.tv_sec + (xtime.tv_sec - sec);
@@ -224,10 +111,10 @@ EXPORT_SYMBOL(do_settimeofday);
 static long last_rtc_update;
 
 /*
- * timer_interrupt() needs to keep up the real-time clock,
+ * handle_timer_tick() needs to keep up the real-time clock,
  * as well as call the "do_timer()" routine every clocktick
  */
-static inline void do_timer_interrupt(int irq, struct pt_regs *regs)
+void handle_timer_tick(struct pt_regs *regs)
 {
 	do_timer(regs);
 #ifndef CONFIG_SMP
@@ -252,337 +139,35 @@ static inline void do_timer_interrupt(int irq, struct pt_regs *regs)
 		if (rtc_set_time(xtime.tv_sec) == 0)
 			last_rtc_update = xtime.tv_sec;
 		else
-			last_rtc_update = xtime.tv_sec - 600; /* do it again in 60 s */
+			/* do it again in 60s */
+			last_rtc_update = xtime.tv_sec - 600;
 	}
 }
 
-/*
- * This is the same as the above, except we _also_ save the current
- * Time Stamp Counter value at the time of the timer interrupt, so that
- * we later on can estimate the time of day more exactly.
- */
-static irqreturn_t timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-	unsigned long timer_status;
-
-	/* Clear UNF bit */
-	timer_status = ctrl_inw(TMU0_TCR);
-	timer_status &= ~0x100;
-	ctrl_outw(timer_status, TMU0_TCR);
-
-	/*
-	 * Here we are in the timer irq handler. We just have irqs locally
-	 * disabled but we don't know if the timer_bh is running on the other
-	 * CPU. We need to avoid to SMP race with it. NOTE: we don' t need
-	 * the irq version of write_lock because as just said we have irq
-	 * locally disabled. -arca
-	 */
-	write_seqlock(&xtime_lock);
-	do_timer_interrupt(irq, regs);
-	write_sequnlock(&xtime_lock);
-
-	return IRQ_HANDLED;
-}
-
-/*
- * Hah!  We'll see if this works (switching from usecs to nsecs).
- */
-static unsigned int __init get_timer_frequency(void)
-{
-	u32 freq;
-	struct timespec ts1, ts2;
-	unsigned long diff_nsec;
-	unsigned long factor;
-
-	/* Setup the timer:  We don't want to generate interrupts, just
-	 * have it count down at its natural rate.
-	 */
-	ctrl_outb(0, TMU_TSTR);
-#if !defined(CONFIG_CPU_SUBTYPE_SH7300)
-	ctrl_outb(TMU_TOCR_INIT, TMU_TOCR);
-#endif
-	ctrl_outw(TMU0_TCR_CALIB, TMU0_TCR);
-	ctrl_outl(0xffffffff, TMU0_TCOR);
-	ctrl_outl(0xffffffff, TMU0_TCNT);
-
-	rtc_get_time(&ts2);
-
-	do {
-		rtc_get_time(&ts1);
-	} while (ts1.tv_nsec == ts2.tv_nsec && ts1.tv_sec == ts2.tv_sec);
-
-	/* actually start the timer */
-	ctrl_outb(TMU_TSTR_INIT, TMU_TSTR);
-
-	do {
-		rtc_get_time(&ts2);
-	} while (ts1.tv_nsec == ts2.tv_nsec && ts1.tv_sec == ts2.tv_sec);
-
-	freq = 0xffffffff - ctrl_inl(TMU0_TCNT);
-	if (ts2.tv_nsec < ts1.tv_nsec) {
-		ts2.tv_nsec += 1000000000;
-		ts2.tv_sec--;
-	}
-
-	diff_nsec = (ts2.tv_sec - ts1.tv_sec) * 1000000000 + (ts2.tv_nsec - ts1.tv_nsec);
-
-	/* this should work well if the RTC has a precision of n Hz, where
-	 * n is an integer.  I don't think we have to worry about the other
-	 * cases. */
-	factor = (1000000000 + diff_nsec/2) / diff_nsec;
-
-	if (factor * diff_nsec > 1100000000 ||
-	    factor * diff_nsec <  900000000)
-		panic("weird RTC (diff_nsec %ld)", diff_nsec);
-
-	return freq * factor;
-}
-
-void (*board_time_init)(void);
-void (*board_timer_setup)(struct irqaction *irq);
-
-static unsigned int sh_pclk_freq __initdata = CONFIG_SH_PCLK_FREQ;
-
-static int __init sh_pclk_setup(char *str)
-{
-        unsigned int freq;
-
-	if (get_option(&str, &freq))
-		sh_pclk_freq = freq;
-
-	return 1;
-}
-__setup("sh_pclk=", sh_pclk_setup);
-
-static struct irqaction irq0  = { timer_interrupt, SA_INTERRUPT, CPU_MASK_NONE, "timer", NULL, NULL};
-
-void get_current_frequency_divisors(unsigned int *ifc, unsigned int *bfc, unsigned int *pfc)
-{
-	unsigned int frqcr = ctrl_inw(FRQCR);
-
-#if defined(CONFIG_CPU_SH3)
-#if defined(CONFIG_CPU_SUBTYPE_SH7300)
-	*ifc = md_table[((frqcr & 0x0070) >> 4)];
-	*bfc = md_table[((frqcr & 0x0700) >> 8)];
-	*pfc = md_table[frqcr & 0x0007];
-#elif defined(CONFIG_CPU_SUBTYPE_SH7705)
-	*bfc = stc_multipliers[(frqcr & 0x0300) >> 8];
-	*ifc = ifc_divisors[(frqcr & 0x0030) >> 4];
-	*pfc = pfc_divisors[frqcr & 0x0003];
-#else
-	unsigned int tmp;
-
-	tmp  = (frqcr & 0x8000) >> 13;
-	tmp |= (frqcr & 0x0030) >>  4;
-	*bfc = stc_multipliers[tmp];
-	tmp  = (frqcr & 0x4000)  >> 12;
-	tmp |= (frqcr & 0x000c) >> 2;
-	*ifc = ifc_divisors[tmp];
-	tmp  = (frqcr & 0x2000) >> 11;
-	tmp |= frqcr & 0x0003;
-	*pfc = pfc_divisors[tmp];
-#endif
-#elif defined(CONFIG_CPU_SH4)
-#if defined(CONFIG_CPU_SUBTYPE_SH73180)
-	*ifc = ifc_divisors[(frqcr>> 20) & 0x0007];
-	*bfc = bfc_divisors[(frqcr>> 12) & 0x0007];
-	*pfc = pfc_divisors[frqcr & 0x0007];
-#else
-	*ifc = ifc_divisors[(frqcr >> 6) & 0x0007];
-	*bfc = bfc_divisors[(frqcr >> 3) & 0x0007];
-	*pfc = pfc_divisors[frqcr & 0x0007];
-#endif
-#endif
-}
-
-/*
- * This bit of ugliness builds up accessor routines to get at both
- * the divisors and the physical values.
- */
-#define _FREQ_TABLE(x) \
-	unsigned int get_##x##_divisor(unsigned int value)	\
-		{ return x##_divisors[value]; }			\
-								\
-	unsigned int get_##x##_value(unsigned int divisor)	\
-		{ return x##_values[(divisor - 1)]; }
-
-_FREQ_TABLE(ifc);
-_FREQ_TABLE(bfc);
-_FREQ_TABLE(pfc);
-
-#ifdef CONFIG_CPU_SUBTYPE_ST40STB1
-
-/*
- * The ST40 divisors are totally different so we set the cpu data
- * clocks using a different algorithm
- *
- * I've just plugged this from the 2.4 code
- *	- Alex Bennee <kernel-hacker@bennee.com>
- */
-#define CCN_PVR_CHIP_SHIFT 24
-#define CCN_PVR_CHIP_MASK  0xff
-#define CCN_PVR_CHIP_ST40STB1 0x4
-
-
-struct frqcr_data {
-	unsigned short frqcr;
-
-	struct {
-		unsigned char multiplier;
-		unsigned char divisor;
-	} factor[3];
-};
-
-static struct frqcr_data st40_frqcr_table[] = {
-	{ 0x000, {{1,1}, {1,1}, {1,2}}},
-	{ 0x002, {{1,1}, {1,1}, {1,4}}},
-	{ 0x004, {{1,1}, {1,1}, {1,8}}},
-	{ 0x008, {{1,1}, {1,2}, {1,2}}},
-	{ 0x00A, {{1,1}, {1,2}, {1,4}}},
-	{ 0x00C, {{1,1}, {1,2}, {1,8}}},
-	{ 0x011, {{1,1}, {2,3}, {1,6}}},
-	{ 0x013, {{1,1}, {2,3}, {1,3}}},
-	{ 0x01A, {{1,1}, {1,2}, {1,4}}},
-	{ 0x01C, {{1,1}, {1,2}, {1,8}}},
-	{ 0x023, {{1,1}, {2,3}, {1,3}}},
-	{ 0x02C, {{1,1}, {1,2}, {1,8}}},
-	{ 0x048, {{1,2}, {1,2}, {1,4}}},
-	{ 0x04A, {{1,2}, {1,2}, {1,6}}},
-	{ 0x04C, {{1,2}, {1,2}, {1,8}}},
-	{ 0x05A, {{1,2}, {1,3}, {1,6}}},
-	{ 0x05C, {{1,2}, {1,3}, {1,6}}},
-	{ 0x063, {{1,2}, {1,4}, {1,4}}},
-	{ 0x06C, {{1,2}, {1,4}, {1,8}}},
-	{ 0x091, {{1,3}, {1,3}, {1,6}}},
-	{ 0x093, {{1,3}, {1,3}, {1,6}}},
-	{ 0x0A3, {{1,3}, {1,6}, {1,6}}},
-	{ 0x0DA, {{1,4}, {1,4}, {1,8}}},
-	{ 0x0DC, {{1,4}, {1,4}, {1,8}}},
-	{ 0x0EC, {{1,4}, {1,8}, {1,8}}},
-	{ 0x123, {{1,4}, {1,4}, {1,8}}},
-	{ 0x16C, {{1,4}, {1,8}, {1,8}}},
+static struct sysdev_class timer_sysclass = {
+	set_kset_name("timer"),
 };
 
-struct memclk_data {
-	unsigned char multiplier;
-	unsigned char divisor;
-};
-
-static struct memclk_data st40_memclk_table[8] = {
-	{1,1},	// 000
-	{1,2},	// 001
-	{1,3},	// 010
-	{2,3},	// 011
-	{1,4},	// 100
-	{1,6},	// 101
-	{1,8},	// 110
-	{1,8}	// 111
-};
-
-static void st40_specific_time_init(unsigned int module_clock, unsigned short frqcr)
+static int __init timer_init_sysfs(void)
 {
-	unsigned int cpu_clock, master_clock, bus_clock, memory_clock;
-	struct frqcr_data *d;
-	int a;
-	unsigned long memclkcr;
-	struct memclk_data *e;
+	int ret = sysdev_class_register(&timer_sysclass);
+	if (ret != 0)
+		return ret;
 
-	for (a = 0; a < ARRAY_SIZE(st40_frqcr_table); a++) {
-		d = &st40_frqcr_table[a];
-
-		if (d->frqcr == (frqcr & 0x1ff))
-			break;
-	}
+	sys_timer->dev.cls = &timer_sysclass;
+	return sysdev_register(&sys_timer->dev);
+}
 
-	if (a == ARRAY_SIZE(st40_frqcr_table)) {
-		d = st40_frqcr_table;
+device_initcall(timer_init_sysfs);
 
-		printk("ERROR: Unrecognised FRQCR value (0x%x), "
-		       "using default multipliers\n", frqcr);
-	}
-
-	memclkcr = ctrl_inl(CLOCKGEN_MEMCLKCR);
-	e = &st40_memclk_table[memclkcr & MEMCLKCR_RATIO_MASK];
-
-	printk(KERN_INFO "Clock multipliers: CPU: %d/%d Bus: %d/%d "
-	       "Mem: %d/%d Periph: %d/%d\n",
-	       d->factor[0].multiplier, d->factor[0].divisor,
-	       d->factor[1].multiplier, d->factor[1].divisor,
-	       e->multiplier,           e->divisor,
-	       d->factor[2].multiplier, d->factor[2].divisor);
-
-	master_clock = module_clock * d->factor[2].divisor
-				    / d->factor[2].multiplier;
-	bus_clock    = master_clock * d->factor[1].multiplier
-				    / d->factor[1].divisor;
-	memory_clock = master_clock * e->multiplier
-				    / e->divisor;
-	cpu_clock    = master_clock * d->factor[0].multiplier
-				    / d->factor[0].divisor;
-
-	current_cpu_data.cpu_clock    = cpu_clock;
-	current_cpu_data.master_clock = master_clock;
-	current_cpu_data.bus_clock    = bus_clock;
-	current_cpu_data.memory_clock = memory_clock;
-	current_cpu_data.module_clock = module_clock;
-}
-#endif
+void (*board_time_init)(void);
 
 void __init time_init(void)
 {
-	unsigned int timer_freq = 0;
-	unsigned int ifc, pfc, bfc;
-	unsigned long interval;
-#ifdef CONFIG_CPU_SUBTYPE_ST40STB1
-	unsigned long pvr;
-	unsigned short frqcr;
-#endif
-
 	if (board_time_init)
 		board_time_init();
 
-	/*
-	 * If we don't have an RTC (such as with the SH7300), don't attempt to
-	 * probe the timer frequency. Rely on an either hardcoded peripheral
-	 * clock value, or on the sh_pclk command line option. Note that we
-	 * still need to have CONFIG_SH_PCLK_FREQ set in order for things like
-	 * CLOCK_TICK_RATE to be sane.
-	 */
-	current_cpu_data.module_clock = sh_pclk_freq;
-
-#ifdef CONFIG_SH_PCLK_CALC
-	/* XXX: Switch this over to a more generic test. */
-	{
-		unsigned int freq;
-
-		/*
-		 * If we've specified a peripheral clock frequency, and we have
-		 * an RTC, compare it against the autodetected value. Complain
-		 * if there's a mismatch.
-		 */
-		timer_freq = get_timer_frequency();
-		freq = timer_freq * 4;
-
-		if (sh_pclk_freq && (sh_pclk_freq/100*99 > freq || sh_pclk_freq/100*101 < freq)) {
-			printk(KERN_NOTICE "Calculated peripheral clock value "
-			       "%d differs from sh_pclk value %d, fixing..\n",
-			       freq, sh_pclk_freq);
-			current_cpu_data.module_clock = freq;
-		}
-	}
-#endif
-
-#ifdef CONFIG_CPU_SUBTYPE_ST40STB1
-	/* XXX: Update ST40 code to use board_time_init() */
-	pvr = ctrl_inl(CCN_PVR);
-	frqcr = ctrl_inw(FRQCR);
-	printk("time.c ST40 Probe: PVR %08lx, FRQCR %04hx\n", pvr, frqcr);
-
-	if (((pvr >> CCN_PVR_CHIP_SHIFT) & CCN_PVR_CHIP_MASK) == CCN_PVR_CHIP_ST40STB1)
-		st40_specific_time_init(current_cpu_data.module_clock, frqcr);
-	else
-#endif
-		get_current_frequency_divisors(&ifc, &bfc, &pfc);
+	clk_init();
 
 	if (rtc_get_time) {
 		rtc_get_time(&xtime);
@@ -594,51 +179,12 @@ void __init time_init(void)
         set_normalized_timespec(&wall_to_monotonic,
                                 -xtime.tv_sec, -xtime.tv_nsec);
 
-	if (board_timer_setup) {
-		board_timer_setup(&irq0);
-	} else {
-		setup_irq(TIMER_IRQ, &irq0);
-	}
-
 	/*
-	 * for ST40 chips the current_cpu_data should already be set
-	 * so not having valid pfc/bfc/ifc shouldn't be a problem
+	 * Find the timer to use as the system timer, it will be
+	 * initialized for us.
 	 */
-	if (!current_cpu_data.master_clock)
-		current_cpu_data.master_clock = current_cpu_data.module_clock * pfc;
-	if (!current_cpu_data.bus_clock)
-		current_cpu_data.bus_clock = current_cpu_data.master_clock / bfc;
-	if (!current_cpu_data.cpu_clock)
-		current_cpu_data.cpu_clock = current_cpu_data.master_clock / ifc;
-
-	printk("CPU clock: %d.%02dMHz\n",
-	       (current_cpu_data.cpu_clock / 1000000),
-	       (current_cpu_data.cpu_clock % 1000000)/10000);
-	printk("Bus clock: %d.%02dMHz\n",
-	       (current_cpu_data.bus_clock / 1000000),
-	       (current_cpu_data.bus_clock % 1000000)/10000);
-#ifdef CONFIG_CPU_SUBTYPE_ST40STB1
-	printk("Memory clock: %d.%02dMHz\n",
-	       (current_cpu_data.memory_clock / 1000000),
-	       (current_cpu_data.memory_clock % 1000000)/10000);
-#endif
-	printk("Module clock: %d.%02dMHz\n",
-	       (current_cpu_data.module_clock / 1000000),
-	       (current_cpu_data.module_clock % 1000000)/10000);
-
-	interval = (current_cpu_data.module_clock/4 + HZ/2) / HZ;
-
-	printk("Interval = %ld\n", interval);
-
-	/* Start TMU0 */
-	ctrl_outb(0, TMU_TSTR);
-#if !defined(CONFIG_CPU_SUBTYPE_SH7300)
-	ctrl_outb(TMU_TOCR_INIT, TMU_TOCR);
-#endif
-	ctrl_outw(TMU0_TCR_INIT, TMU0_TCR);
-	ctrl_outl(interval, TMU0_TCOR);
-	ctrl_outl(interval, TMU0_TCNT);
-	ctrl_outb(TMU_TSTR_INIT, TMU_TSTR);
+	sys_timer = get_sys_timer();
+	printk(KERN_INFO "Using %s for system timer\n", sys_timer->name);
 
 #if defined(CONFIG_SH_KGDB)
 	/*

commit ecea8d19c9f0ebd62ddaa07fc919ff4e4b820d99
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Oct 30 15:03:00 2005 -0800

    [PATCH] jiffies_64 cleanup
    
    Define jiffies_64 in kernel/timer.c rather than having 24 duplicated
    defines in each architecture.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index 02ca69918d7c..671b876416bf 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -56,10 +56,6 @@ extern unsigned long wall_jiffies;
 #define TICK_SIZE (tick_nsec / 1000)
 DEFINE_SPINLOCK(tmu0_lock);
 
-u64 jiffies_64 = INITIAL_JIFFIES;
-
-EXPORT_SYMBOL(jiffies_64);
-
 /* XXX: Can we initialize this in a routine somewhere?  Dreamcast doesn't want
  * these routines anywhere... */
 #ifdef CONFIG_SH_RTC

commit b149ee2233edf08fb59b11e879a2c5941929bcb8
Author: john stultz <johnstul@us.ibm.com>
Date:   Tue Sep 6 15:17:46 2005 -0700

    [PATCH] NTP: ntp-helper functions
    
    This patch cleans up a commonly repeated set of changes to the NTP state
    variables by adding two helper inline functions:
    
    ntp_clear(): Clears the ntp state variables
    
    ntp_synced(): Returns 1 if the system is synced with a time server.
    
    This was compile tested for alpha, arm, i386, x86-64, ppc64, s390, sparc,
    sparc64.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index d5f5aedde0a3..02ca69918d7c 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -215,10 +215,7 @@ int do_settimeofday(struct timespec *tv)
 	set_normalized_timespec(&xtime, sec, nsec);
 	set_normalized_timespec(&wall_to_monotonic, wtm_sec, wtm_nsec);
 
-	time_adjust = 0;		/* stop active adjtime() */
-	time_status |= STA_UNSYNC;
-	time_maxerror = NTP_PHASE_LIMIT;
-	time_esterror = NTP_PHASE_LIMIT;
+	ntp_clear();
 	write_sequnlock_irq(&xtime_lock);
 	clock_was_set();
 
@@ -252,7 +249,7 @@ static inline void do_timer_interrupt(int irq, struct pt_regs *regs)
 	 * RTC clock accordingly every ~11 minutes. Set_rtc_mmss() has to be
 	 * called as close as possible to 500 ms before the new second starts.
 	 */
-	if ((time_status & STA_UNSYNC) == 0 &&
+	if (ntp_synced() &&
 	    xtime.tv_sec > last_rtc_update + 660 &&
 	    (xtime.tv_nsec / 1000) >= 500000 - ((unsigned) TICK_SIZE) / 2 &&
 	    (xtime.tv_nsec / 1000) <= 500000 + ((unsigned) TICK_SIZE) / 2) {

commit 7f4bde9a3486cd7e70bedd2aff35b38667d50173
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Sep 6 15:17:39 2005 -0700

    [PATCH] remove the second arg of do_timer_interrupt()
    
    The second arg of do_timer_interrupt() is not used in the functions, and
    all callers pass NULL.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Cc: Paul Mundt <lethal@Linux-SH.ORG>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
index df7a9b9d4cbf..d5f5aedde0a3 100644
--- a/arch/sh/kernel/time.c
+++ b/arch/sh/kernel/time.c
@@ -234,7 +234,7 @@ static long last_rtc_update;
  * timer_interrupt() needs to keep up the real-time clock,
  * as well as call the "do_timer()" routine every clocktick
  */
-static inline void do_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static inline void do_timer_interrupt(int irq, struct pt_regs *regs)
 {
 	do_timer(regs);
 #ifndef CONFIG_SMP
@@ -285,7 +285,7 @@ static irqreturn_t timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 	 * locally disabled. -arca
 	 */
 	write_seqlock(&xtime_lock);
-	do_timer_interrupt(irq, NULL, regs);
+	do_timer_interrupt(irq, regs);
 	write_sequnlock(&xtime_lock);
 
 	return IRQ_HANDLED;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
new file mode 100644
index 000000000000..df7a9b9d4cbf
--- /dev/null
+++ b/arch/sh/kernel/time.c
@@ -0,0 +1,657 @@
+/*
+ *  arch/sh/kernel/time.c
+ *
+ *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
+ *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
+ *  Copyright (C) 2002, 2003, 2004  Paul Mundt
+ *  Copyright (C) 2002  M. R. Brown  <mrbrown@linux-sh.org>
+ *
+ *  Some code taken from i386 version.
+ *    Copyright (C) 1991, 1992, 1995  Linus Torvalds
+ */
+
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/param.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/profile.h>
+
+#include <asm/processor.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/delay.h>
+#include <asm/machvec.h>
+#include <asm/rtc.h>
+#include <asm/freq.h>
+#include <asm/cpu/timer.h>
+#ifdef CONFIG_SH_KGDB
+#include <asm/kgdb.h>
+#endif
+
+#include <linux/timex.h>
+#include <linux/irq.h>
+
+#define TMU_TOCR_INIT	0x00
+#define TMU0_TCR_INIT	0x0020
+#define TMU_TSTR_INIT	1
+
+#define TMU0_TCR_CALIB	0x0000
+
+#ifdef CONFIG_CPU_SUBTYPE_ST40STB1
+#define CLOCKGEN_MEMCLKCR 0xbb040038
+#define MEMCLKCR_RATIO_MASK 0x7
+#endif /* CONFIG_CPU_SUBTYPE_ST40STB1 */
+
+extern unsigned long wall_jiffies;
+#define TICK_SIZE (tick_nsec / 1000)
+DEFINE_SPINLOCK(tmu0_lock);
+
+u64 jiffies_64 = INITIAL_JIFFIES;
+
+EXPORT_SYMBOL(jiffies_64);
+
+/* XXX: Can we initialize this in a routine somewhere?  Dreamcast doesn't want
+ * these routines anywhere... */
+#ifdef CONFIG_SH_RTC
+void (*rtc_get_time)(struct timespec *) = sh_rtc_gettimeofday;
+int (*rtc_set_time)(const time_t) = sh_rtc_settimeofday;
+#else
+void (*rtc_get_time)(struct timespec *);
+int (*rtc_set_time)(const time_t);
+#endif
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7300)
+static int md_table[] = { 1, 2, 3, 4, 6, 8, 12 };
+#endif
+#if defined(CONFIG_CPU_SH3)
+static int stc_multipliers[] = { 1, 2, 3, 4, 6, 1, 1, 1 };
+static int stc_values[]      = { 0, 1, 4, 2, 5, 0, 0, 0 };
+#define bfc_divisors stc_multipliers
+#define bfc_values stc_values
+static int ifc_divisors[]    = { 1, 2, 3, 4, 1, 1, 1, 1 };
+static int ifc_values[]      = { 0, 1, 4, 2, 0, 0, 0, 0 };
+static int pfc_divisors[]    = { 1, 2, 3, 4, 6, 1, 1, 1 };
+static int pfc_values[]      = { 0, 1, 4, 2, 5, 0, 0, 0 };
+#elif defined(CONFIG_CPU_SH4)
+#if defined(CONFIG_CPU_SUBTYPE_SH73180)
+static int ifc_divisors[] = { 1, 2, 3, 4, 6, 8, 12, 16 };
+static int ifc_values[] = { 0, 1, 2, 3, 4, 5, 6, 7 };
+#define bfc_divisors ifc_divisors	/* Same */
+#define bfc_values ifc_values
+#define pfc_divisors ifc_divisors	/* Same */
+#define pfc_values ifc_values
+#else
+static int ifc_divisors[] = { 1, 2, 3, 4, 6, 8, 1, 1 };
+static int ifc_values[]   = { 0, 1, 2, 3, 0, 4, 0, 5 };
+#define bfc_divisors ifc_divisors	/* Same */
+#define bfc_values ifc_values
+static int pfc_divisors[] = { 2, 3, 4, 6, 8, 2, 2, 2 };
+static int pfc_values[]   = { 0, 0, 1, 2, 0, 3, 0, 4 };
+#endif
+#else
+#error "Unknown ifc/bfc/pfc/stc values for this processor"
+#endif
+
+/*
+ * Scheduler clock - returns current time in nanosec units.
+ */
+unsigned long long sched_clock(void)
+{
+	return (unsigned long long)jiffies * (1000000000 / HZ);
+}
+
+static unsigned long do_gettimeoffset(void)
+{
+	int count;
+	unsigned long flags;
+
+	static int count_p = 0x7fffffff;    /* for the first call after boot */
+	static unsigned long jiffies_p = 0;
+
+	/*
+	 * cache volatile jiffies temporarily; we have IRQs turned off.
+	 */
+	unsigned long jiffies_t;
+
+	spin_lock_irqsave(&tmu0_lock, flags);
+	/* timer count may underflow right here */
+	count = ctrl_inl(TMU0_TCNT);	/* read the latched count */
+
+	jiffies_t = jiffies;
+
+	/*
+	 * avoiding timer inconsistencies (they are rare, but they happen)...
+	 * there is one kind of problem that must be avoided here:
+	 *  1. the timer counter underflows
+	 */
+
+	if( jiffies_t == jiffies_p ) {
+		if( count > count_p ) {
+			/* the nutcase */
+
+			if(ctrl_inw(TMU0_TCR) & 0x100) { /* Check UNF bit */
+				/*
+				 * We cannot detect lost timer interrupts ...
+				 * well, that's why we call them lost, don't we? :)
+				 * [hmm, on the Pentium and Alpha we can ... sort of]
+				 */
+				count -= LATCH;
+			} else {
+				printk("do_slow_gettimeoffset(): hardware timer problem?\n");
+			}
+		}
+	} else
+		jiffies_p = jiffies_t;
+
+	count_p = count;
+	spin_unlock_irqrestore(&tmu0_lock, flags);
+
+	count = ((LATCH-1) - count) * TICK_SIZE;
+	count = (count + LATCH/2) / LATCH;
+
+	return count;
+}
+
+void do_gettimeofday(struct timeval *tv)
+{
+	unsigned long seq;
+	unsigned long usec, sec;
+	unsigned long lost;
+
+	do {
+		seq = read_seqbegin(&xtime_lock);
+		usec = do_gettimeoffset();
+
+		lost = jiffies - wall_jiffies;
+		if (lost)
+			usec += lost * (1000000 / HZ);
+
+		sec = xtime.tv_sec;
+		usec += xtime.tv_nsec / 1000;
+	} while (read_seqretry(&xtime_lock, seq));
+
+	while (usec >= 1000000) {
+		usec -= 1000000;
+		sec++;
+	}
+
+	tv->tv_sec = sec;
+	tv->tv_usec = usec;
+}
+
+EXPORT_SYMBOL(do_gettimeofday);
+
+int do_settimeofday(struct timespec *tv)
+{
+	time_t wtm_sec, sec = tv->tv_sec;
+	long wtm_nsec, nsec = tv->tv_nsec;
+
+	if ((unsigned long)tv->tv_nsec >= NSEC_PER_SEC)
+		return -EINVAL;
+
+	write_seqlock_irq(&xtime_lock);
+	/*
+	 * This is revolting. We need to set "xtime" correctly. However, the
+	 * value in this location is the value at the most recent update of
+	 * wall time.  Discover what correction gettimeofday() would have
+	 * made, and then undo it!
+	 */
+	nsec -= 1000 * (do_gettimeoffset() +
+				(jiffies - wall_jiffies) * (1000000 / HZ));
+
+	wtm_sec  = wall_to_monotonic.tv_sec + (xtime.tv_sec - sec);
+	wtm_nsec = wall_to_monotonic.tv_nsec + (xtime.tv_nsec - nsec);
+
+	set_normalized_timespec(&xtime, sec, nsec);
+	set_normalized_timespec(&wall_to_monotonic, wtm_sec, wtm_nsec);
+
+	time_adjust = 0;		/* stop active adjtime() */
+	time_status |= STA_UNSYNC;
+	time_maxerror = NTP_PHASE_LIMIT;
+	time_esterror = NTP_PHASE_LIMIT;
+	write_sequnlock_irq(&xtime_lock);
+	clock_was_set();
+
+	return 0;
+}
+
+EXPORT_SYMBOL(do_settimeofday);
+
+/* last time the RTC clock got updated */
+static long last_rtc_update;
+
+/*
+ * timer_interrupt() needs to keep up the real-time clock,
+ * as well as call the "do_timer()" routine every clocktick
+ */
+static inline void do_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	do_timer(regs);
+#ifndef CONFIG_SMP
+	update_process_times(user_mode(regs));
+#endif
+	profile_tick(CPU_PROFILING, regs);
+
+#ifdef CONFIG_HEARTBEAT
+	if (sh_mv.mv_heartbeat != NULL)
+		sh_mv.mv_heartbeat();
+#endif
+
+	/*
+	 * If we have an externally synchronized Linux clock, then update
+	 * RTC clock accordingly every ~11 minutes. Set_rtc_mmss() has to be
+	 * called as close as possible to 500 ms before the new second starts.
+	 */
+	if ((time_status & STA_UNSYNC) == 0 &&
+	    xtime.tv_sec > last_rtc_update + 660 &&
+	    (xtime.tv_nsec / 1000) >= 500000 - ((unsigned) TICK_SIZE) / 2 &&
+	    (xtime.tv_nsec / 1000) <= 500000 + ((unsigned) TICK_SIZE) / 2) {
+		if (rtc_set_time(xtime.tv_sec) == 0)
+			last_rtc_update = xtime.tv_sec;
+		else
+			last_rtc_update = xtime.tv_sec - 600; /* do it again in 60 s */
+	}
+}
+
+/*
+ * This is the same as the above, except we _also_ save the current
+ * Time Stamp Counter value at the time of the timer interrupt, so that
+ * we later on can estimate the time of day more exactly.
+ */
+static irqreturn_t timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned long timer_status;
+
+	/* Clear UNF bit */
+	timer_status = ctrl_inw(TMU0_TCR);
+	timer_status &= ~0x100;
+	ctrl_outw(timer_status, TMU0_TCR);
+
+	/*
+	 * Here we are in the timer irq handler. We just have irqs locally
+	 * disabled but we don't know if the timer_bh is running on the other
+	 * CPU. We need to avoid to SMP race with it. NOTE: we don' t need
+	 * the irq version of write_lock because as just said we have irq
+	 * locally disabled. -arca
+	 */
+	write_seqlock(&xtime_lock);
+	do_timer_interrupt(irq, NULL, regs);
+	write_sequnlock(&xtime_lock);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Hah!  We'll see if this works (switching from usecs to nsecs).
+ */
+static unsigned int __init get_timer_frequency(void)
+{
+	u32 freq;
+	struct timespec ts1, ts2;
+	unsigned long diff_nsec;
+	unsigned long factor;
+
+	/* Setup the timer:  We don't want to generate interrupts, just
+	 * have it count down at its natural rate.
+	 */
+	ctrl_outb(0, TMU_TSTR);
+#if !defined(CONFIG_CPU_SUBTYPE_SH7300)
+	ctrl_outb(TMU_TOCR_INIT, TMU_TOCR);
+#endif
+	ctrl_outw(TMU0_TCR_CALIB, TMU0_TCR);
+	ctrl_outl(0xffffffff, TMU0_TCOR);
+	ctrl_outl(0xffffffff, TMU0_TCNT);
+
+	rtc_get_time(&ts2);
+
+	do {
+		rtc_get_time(&ts1);
+	} while (ts1.tv_nsec == ts2.tv_nsec && ts1.tv_sec == ts2.tv_sec);
+
+	/* actually start the timer */
+	ctrl_outb(TMU_TSTR_INIT, TMU_TSTR);
+
+	do {
+		rtc_get_time(&ts2);
+	} while (ts1.tv_nsec == ts2.tv_nsec && ts1.tv_sec == ts2.tv_sec);
+
+	freq = 0xffffffff - ctrl_inl(TMU0_TCNT);
+	if (ts2.tv_nsec < ts1.tv_nsec) {
+		ts2.tv_nsec += 1000000000;
+		ts2.tv_sec--;
+	}
+
+	diff_nsec = (ts2.tv_sec - ts1.tv_sec) * 1000000000 + (ts2.tv_nsec - ts1.tv_nsec);
+
+	/* this should work well if the RTC has a precision of n Hz, where
+	 * n is an integer.  I don't think we have to worry about the other
+	 * cases. */
+	factor = (1000000000 + diff_nsec/2) / diff_nsec;
+
+	if (factor * diff_nsec > 1100000000 ||
+	    factor * diff_nsec <  900000000)
+		panic("weird RTC (diff_nsec %ld)", diff_nsec);
+
+	return freq * factor;
+}
+
+void (*board_time_init)(void);
+void (*board_timer_setup)(struct irqaction *irq);
+
+static unsigned int sh_pclk_freq __initdata = CONFIG_SH_PCLK_FREQ;
+
+static int __init sh_pclk_setup(char *str)
+{
+        unsigned int freq;
+
+	if (get_option(&str, &freq))
+		sh_pclk_freq = freq;
+
+	return 1;
+}
+__setup("sh_pclk=", sh_pclk_setup);
+
+static struct irqaction irq0  = { timer_interrupt, SA_INTERRUPT, CPU_MASK_NONE, "timer", NULL, NULL};
+
+void get_current_frequency_divisors(unsigned int *ifc, unsigned int *bfc, unsigned int *pfc)
+{
+	unsigned int frqcr = ctrl_inw(FRQCR);
+
+#if defined(CONFIG_CPU_SH3)
+#if defined(CONFIG_CPU_SUBTYPE_SH7300)
+	*ifc = md_table[((frqcr & 0x0070) >> 4)];
+	*bfc = md_table[((frqcr & 0x0700) >> 8)];
+	*pfc = md_table[frqcr & 0x0007];
+#elif defined(CONFIG_CPU_SUBTYPE_SH7705)
+	*bfc = stc_multipliers[(frqcr & 0x0300) >> 8];
+	*ifc = ifc_divisors[(frqcr & 0x0030) >> 4];
+	*pfc = pfc_divisors[frqcr & 0x0003];
+#else
+	unsigned int tmp;
+
+	tmp  = (frqcr & 0x8000) >> 13;
+	tmp |= (frqcr & 0x0030) >>  4;
+	*bfc = stc_multipliers[tmp];
+	tmp  = (frqcr & 0x4000)  >> 12;
+	tmp |= (frqcr & 0x000c) >> 2;
+	*ifc = ifc_divisors[tmp];
+	tmp  = (frqcr & 0x2000) >> 11;
+	tmp |= frqcr & 0x0003;
+	*pfc = pfc_divisors[tmp];
+#endif
+#elif defined(CONFIG_CPU_SH4)
+#if defined(CONFIG_CPU_SUBTYPE_SH73180)
+	*ifc = ifc_divisors[(frqcr>> 20) & 0x0007];
+	*bfc = bfc_divisors[(frqcr>> 12) & 0x0007];
+	*pfc = pfc_divisors[frqcr & 0x0007];
+#else
+	*ifc = ifc_divisors[(frqcr >> 6) & 0x0007];
+	*bfc = bfc_divisors[(frqcr >> 3) & 0x0007];
+	*pfc = pfc_divisors[frqcr & 0x0007];
+#endif
+#endif
+}
+
+/*
+ * This bit of ugliness builds up accessor routines to get at both
+ * the divisors and the physical values.
+ */
+#define _FREQ_TABLE(x) \
+	unsigned int get_##x##_divisor(unsigned int value)	\
+		{ return x##_divisors[value]; }			\
+								\
+	unsigned int get_##x##_value(unsigned int divisor)	\
+		{ return x##_values[(divisor - 1)]; }
+
+_FREQ_TABLE(ifc);
+_FREQ_TABLE(bfc);
+_FREQ_TABLE(pfc);
+
+#ifdef CONFIG_CPU_SUBTYPE_ST40STB1
+
+/*
+ * The ST40 divisors are totally different so we set the cpu data
+ * clocks using a different algorithm
+ *
+ * I've just plugged this from the 2.4 code
+ *	- Alex Bennee <kernel-hacker@bennee.com>
+ */
+#define CCN_PVR_CHIP_SHIFT 24
+#define CCN_PVR_CHIP_MASK  0xff
+#define CCN_PVR_CHIP_ST40STB1 0x4
+
+
+struct frqcr_data {
+	unsigned short frqcr;
+
+	struct {
+		unsigned char multiplier;
+		unsigned char divisor;
+	} factor[3];
+};
+
+static struct frqcr_data st40_frqcr_table[] = {
+	{ 0x000, {{1,1}, {1,1}, {1,2}}},
+	{ 0x002, {{1,1}, {1,1}, {1,4}}},
+	{ 0x004, {{1,1}, {1,1}, {1,8}}},
+	{ 0x008, {{1,1}, {1,2}, {1,2}}},
+	{ 0x00A, {{1,1}, {1,2}, {1,4}}},
+	{ 0x00C, {{1,1}, {1,2}, {1,8}}},
+	{ 0x011, {{1,1}, {2,3}, {1,6}}},
+	{ 0x013, {{1,1}, {2,3}, {1,3}}},
+	{ 0x01A, {{1,1}, {1,2}, {1,4}}},
+	{ 0x01C, {{1,1}, {1,2}, {1,8}}},
+	{ 0x023, {{1,1}, {2,3}, {1,3}}},
+	{ 0x02C, {{1,1}, {1,2}, {1,8}}},
+	{ 0x048, {{1,2}, {1,2}, {1,4}}},
+	{ 0x04A, {{1,2}, {1,2}, {1,6}}},
+	{ 0x04C, {{1,2}, {1,2}, {1,8}}},
+	{ 0x05A, {{1,2}, {1,3}, {1,6}}},
+	{ 0x05C, {{1,2}, {1,3}, {1,6}}},
+	{ 0x063, {{1,2}, {1,4}, {1,4}}},
+	{ 0x06C, {{1,2}, {1,4}, {1,8}}},
+	{ 0x091, {{1,3}, {1,3}, {1,6}}},
+	{ 0x093, {{1,3}, {1,3}, {1,6}}},
+	{ 0x0A3, {{1,3}, {1,6}, {1,6}}},
+	{ 0x0DA, {{1,4}, {1,4}, {1,8}}},
+	{ 0x0DC, {{1,4}, {1,4}, {1,8}}},
+	{ 0x0EC, {{1,4}, {1,8}, {1,8}}},
+	{ 0x123, {{1,4}, {1,4}, {1,8}}},
+	{ 0x16C, {{1,4}, {1,8}, {1,8}}},
+};
+
+struct memclk_data {
+	unsigned char multiplier;
+	unsigned char divisor;
+};
+
+static struct memclk_data st40_memclk_table[8] = {
+	{1,1},	// 000
+	{1,2},	// 001
+	{1,3},	// 010
+	{2,3},	// 011
+	{1,4},	// 100
+	{1,6},	// 101
+	{1,8},	// 110
+	{1,8}	// 111
+};
+
+static void st40_specific_time_init(unsigned int module_clock, unsigned short frqcr)
+{
+	unsigned int cpu_clock, master_clock, bus_clock, memory_clock;
+	struct frqcr_data *d;
+	int a;
+	unsigned long memclkcr;
+	struct memclk_data *e;
+
+	for (a = 0; a < ARRAY_SIZE(st40_frqcr_table); a++) {
+		d = &st40_frqcr_table[a];
+
+		if (d->frqcr == (frqcr & 0x1ff))
+			break;
+	}
+
+	if (a == ARRAY_SIZE(st40_frqcr_table)) {
+		d = st40_frqcr_table;
+
+		printk("ERROR: Unrecognised FRQCR value (0x%x), "
+		       "using default multipliers\n", frqcr);
+	}
+
+	memclkcr = ctrl_inl(CLOCKGEN_MEMCLKCR);
+	e = &st40_memclk_table[memclkcr & MEMCLKCR_RATIO_MASK];
+
+	printk(KERN_INFO "Clock multipliers: CPU: %d/%d Bus: %d/%d "
+	       "Mem: %d/%d Periph: %d/%d\n",
+	       d->factor[0].multiplier, d->factor[0].divisor,
+	       d->factor[1].multiplier, d->factor[1].divisor,
+	       e->multiplier,           e->divisor,
+	       d->factor[2].multiplier, d->factor[2].divisor);
+
+	master_clock = module_clock * d->factor[2].divisor
+				    / d->factor[2].multiplier;
+	bus_clock    = master_clock * d->factor[1].multiplier
+				    / d->factor[1].divisor;
+	memory_clock = master_clock * e->multiplier
+				    / e->divisor;
+	cpu_clock    = master_clock * d->factor[0].multiplier
+				    / d->factor[0].divisor;
+
+	current_cpu_data.cpu_clock    = cpu_clock;
+	current_cpu_data.master_clock = master_clock;
+	current_cpu_data.bus_clock    = bus_clock;
+	current_cpu_data.memory_clock = memory_clock;
+	current_cpu_data.module_clock = module_clock;
+}
+#endif
+
+void __init time_init(void)
+{
+	unsigned int timer_freq = 0;
+	unsigned int ifc, pfc, bfc;
+	unsigned long interval;
+#ifdef CONFIG_CPU_SUBTYPE_ST40STB1
+	unsigned long pvr;
+	unsigned short frqcr;
+#endif
+
+	if (board_time_init)
+		board_time_init();
+
+	/*
+	 * If we don't have an RTC (such as with the SH7300), don't attempt to
+	 * probe the timer frequency. Rely on an either hardcoded peripheral
+	 * clock value, or on the sh_pclk command line option. Note that we
+	 * still need to have CONFIG_SH_PCLK_FREQ set in order for things like
+	 * CLOCK_TICK_RATE to be sane.
+	 */
+	current_cpu_data.module_clock = sh_pclk_freq;
+
+#ifdef CONFIG_SH_PCLK_CALC
+	/* XXX: Switch this over to a more generic test. */
+	{
+		unsigned int freq;
+
+		/*
+		 * If we've specified a peripheral clock frequency, and we have
+		 * an RTC, compare it against the autodetected value. Complain
+		 * if there's a mismatch.
+		 */
+		timer_freq = get_timer_frequency();
+		freq = timer_freq * 4;
+
+		if (sh_pclk_freq && (sh_pclk_freq/100*99 > freq || sh_pclk_freq/100*101 < freq)) {
+			printk(KERN_NOTICE "Calculated peripheral clock value "
+			       "%d differs from sh_pclk value %d, fixing..\n",
+			       freq, sh_pclk_freq);
+			current_cpu_data.module_clock = freq;
+		}
+	}
+#endif
+
+#ifdef CONFIG_CPU_SUBTYPE_ST40STB1
+	/* XXX: Update ST40 code to use board_time_init() */
+	pvr = ctrl_inl(CCN_PVR);
+	frqcr = ctrl_inw(FRQCR);
+	printk("time.c ST40 Probe: PVR %08lx, FRQCR %04hx\n", pvr, frqcr);
+
+	if (((pvr >> CCN_PVR_CHIP_SHIFT) & CCN_PVR_CHIP_MASK) == CCN_PVR_CHIP_ST40STB1)
+		st40_specific_time_init(current_cpu_data.module_clock, frqcr);
+	else
+#endif
+		get_current_frequency_divisors(&ifc, &bfc, &pfc);
+
+	if (rtc_get_time) {
+		rtc_get_time(&xtime);
+	} else {
+		xtime.tv_sec = mktime(2000, 1, 1, 0, 0, 0);
+		xtime.tv_nsec = 0;
+	}
+
+        set_normalized_timespec(&wall_to_monotonic,
+                                -xtime.tv_sec, -xtime.tv_nsec);
+
+	if (board_timer_setup) {
+		board_timer_setup(&irq0);
+	} else {
+		setup_irq(TIMER_IRQ, &irq0);
+	}
+
+	/*
+	 * for ST40 chips the current_cpu_data should already be set
+	 * so not having valid pfc/bfc/ifc shouldn't be a problem
+	 */
+	if (!current_cpu_data.master_clock)
+		current_cpu_data.master_clock = current_cpu_data.module_clock * pfc;
+	if (!current_cpu_data.bus_clock)
+		current_cpu_data.bus_clock = current_cpu_data.master_clock / bfc;
+	if (!current_cpu_data.cpu_clock)
+		current_cpu_data.cpu_clock = current_cpu_data.master_clock / ifc;
+
+	printk("CPU clock: %d.%02dMHz\n",
+	       (current_cpu_data.cpu_clock / 1000000),
+	       (current_cpu_data.cpu_clock % 1000000)/10000);
+	printk("Bus clock: %d.%02dMHz\n",
+	       (current_cpu_data.bus_clock / 1000000),
+	       (current_cpu_data.bus_clock % 1000000)/10000);
+#ifdef CONFIG_CPU_SUBTYPE_ST40STB1
+	printk("Memory clock: %d.%02dMHz\n",
+	       (current_cpu_data.memory_clock / 1000000),
+	       (current_cpu_data.memory_clock % 1000000)/10000);
+#endif
+	printk("Module clock: %d.%02dMHz\n",
+	       (current_cpu_data.module_clock / 1000000),
+	       (current_cpu_data.module_clock % 1000000)/10000);
+
+	interval = (current_cpu_data.module_clock/4 + HZ/2) / HZ;
+
+	printk("Interval = %ld\n", interval);
+
+	/* Start TMU0 */
+	ctrl_outb(0, TMU_TSTR);
+#if !defined(CONFIG_CPU_SUBTYPE_SH7300)
+	ctrl_outb(TMU_TOCR_INIT, TMU_TOCR);
+#endif
+	ctrl_outw(TMU0_TCR_INIT, TMU0_TCR);
+	ctrl_outl(interval, TMU0_TCOR);
+	ctrl_outl(interval, TMU0_TCNT);
+	ctrl_outb(TMU_TSTR_INIT, TMU_TSTR);
+
+#if defined(CONFIG_SH_KGDB)
+	/*
+	 * Set up kgdb as requested. We do it here because the serial
+	 * init uses the timer vars we just set up for figuring baud.
+	 */
+	kgdb_init();
+#endif
+}
