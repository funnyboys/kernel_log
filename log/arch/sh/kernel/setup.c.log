commit 40b19e316294e8fd466c0328be607a042e7ec95b
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Wed Dec 18 16:45:02 2019 -0500

    arch/sh/setup: Drop dummy_con initialization
    
    con_init in tty/vt.c will now set conswitchp to dummy_con if it's unset.
    Drop it from arch setup code.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20191218214506.49252-21-nivedita@alum.mit.edu
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index d232cfa01877..67f5a3b44c2e 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -341,10 +341,6 @@ void __init setup_arch(char **cmdline_p)
 
 	paging_init();
 
-#ifdef CONFIG_DUMMY_CONSOLE
-	conswitchp = &dummy_con;
-#endif
-
 	/* Perform the machine specific initialisation */
 	if (likely(sh_mv.mv_setup))
 		sh_mv.mv_setup(cmdline_p);

commit 9a3d7fd275be4559277667228902824165153c80
Merge: 0dd09bc02c1b 0e4a459f56c3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 27 11:06:20 2019 -0800

    Merge tag 'driver-core-5.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here is the "big" set of driver core patches for 5.5-rc1
    
      There's a few minor cleanups and fixes in here, but the majority of
      the patches in here fall into two buckets:
    
       - debugfs api cleanups and fixes
    
       - driver core device link support for boot dependancy issues
    
      The debugfs api cleanups are working to slowly refactor the debugfs
      apis so that it is even harder to use incorrectly. That work has been
      happening for the past few kernel releases and will continue over
      time, it's a long-term project/goal
    
      The driver core device link support missed 5.4 by just a bit, so it's
      been sitting and baking for many months now. It's from Saravana Kannan
      to help resolve the problems that DT-based systems have at boot time
      with dependancy graphs and kernel modules. Turns out that no one has
      actually tried to build a generic arm64 kernel with loads of modules
      and have it "just work" for a variety of platforms (like a distro
      kernel). The big problem turned out to be a lack of dependency
      information between different areas of DT entries, and the work here
      resolves that problem and now allows devices to boot properly, and
      quicker than a monolith kernel.
    
      All of these patches have been in linux-next for a long time with no
      reported issues"
    
    * tag 'driver-core-5.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (68 commits)
      tracing: Remove unnecessary DEBUG_FS dependency
      of: property: Add device link support for interrupt-parent, dmas and -gpio(s)
      debugfs: Fix !DEBUG_FS debugfs_create_automount
      of: property: Add device link support for "iommu-map"
      of: property: Fix the semantics of of_is_ancestor_of()
      i2c: of: Populate fwnode in of_i2c_get_board_info()
      drivers: base: Fix Kconfig indentation
      firmware_loader: Fix labels with comma for builtin firmware
      driver core: Allow device link operations inside sync_state()
      driver core: platform: Declare ret variable only once
      cpu-topology: declare parse_acpi_topology in <linux/arch_topology.h>
      crypto: hisilicon: no need to check return value of debugfs_create functions
      driver core: platform: use the correct callback type for bus_find_device
      firmware_class: make firmware caching configurable
      driver core: Clarify documentation for fwnode_operations.add_links()
      mailbox: tegra: Fix superfluous IRQ error message
      net: caif: Fix debugfs on 64-bit platforms
      mac80211: Use debugfs_create_xul() helper
      media: c8sectpfe: no need to check return value of debugfs_create functions
      of: property: Add device link support for iommus, mboxes and io-channels
      ...

commit 6d80f20c5328ad24dde0fddb980f60734a17b911
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Fri Oct 18 11:18:22 2019 +0800

    sh: Use pr_warn instead of pr_warning
    
    As said in commit f2c2cbcc35d4 ("powerpc: Use pr_warn instead of
    pr_warning"), removing pr_warning so all logging messages use a
    consistent <prefix>_warn style. Let's do it.
    
    Link: http://lkml.kernel.org/r/20191018031850.48498-5-wangkefeng.wang@huawei.com
    To: linux-kernel@vger.kernel.org
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Rich Felker <dalias@libc.org>
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 2c0e0f37a318..6ef341f6cfee 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -354,7 +354,7 @@ void __init setup_arch(char **cmdline_p)
 /* processor boot mode configuration */
 int generic_mode_pins(void)
 {
-	pr_warning("generic_mode_pins(): missing mode pin configuration\n");
+	pr_warn("generic_mode_pins(): missing mode pin configuration\n");
 	return 0;
 }
 

commit 201e91091b1d47047f55580b5474e1239f4d17aa
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Oct 3 11:29:13 2019 +0200

    sh: add the sh_ prefix to early platform symbols
    
    Old early platform device support is now sh-specific. Before moving on
    to implementing new early platform framework based on real platform
    devices, prefix all early platform symbols with 'sh_'.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Cc: Rich Felker <dalias@libc.org>
    Link: https://lore.kernel.org/r/20191003092913.10731-3-brgl@bgdev.pl
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index e535507851e1..914174a125a4 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -329,7 +329,7 @@ void __init setup_arch(char **cmdline_p)
 	sh_mv_setup();
 
 	/* Let earlyprintk output early console messages */
-	early_platform_driver_probe("earlyprintk", 1, 1);
+	sh_early_platform_driver_probe("earlyprintk", 1, 1);
 
 #ifdef CONFIG_OF_FLATTREE
 #ifdef CONFIG_USE_BUILTIN_DTB

commit 507fd01d5333338753a1cc26322dfc9f856c109f
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Oct 3 11:29:12 2019 +0200

    drivers: move the early platform device support to arch/sh
    
    SuperH is the only user of the current implementation of early platform
    device support. We want to introduce a more robust approach to early
    probing. As the first step - move all the current early platform code
    to arch/sh.
    
    In order not to export internal drivers/base functions to arch code for
    this temporary solution - copy the two needed routines for driver
    matching from drivers/base/platform.c to arch/sh/drivers/platform_early.c.
    
    Also: call early_platform_cleanup() from subsys_initcall() so that it's
    called after all early devices are probed.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Cc: Rich Felker <dalias@libc.org>
    Link: https://lore.kernel.org/r/20191003092913.10731-2-brgl@bgdev.pl
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 2c0e0f37a318..e535507851e1 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -44,6 +44,7 @@
 #include <asm/mmu_context.h>
 #include <asm/mmzone.h>
 #include <asm/sparsemem.h>
+#include <asm/platform_early.h>
 
 /*
  * Initialize loops_per_jiffy as 10000000 (1000MIPS).

commit e262e32d6bde0f77fb0c95d977482fc872c51996
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:07:23 2018 +0000

    vfs: Suppress MS_* flag defs within the kernel unless explicitly enabled
    
    Only the mount namespace code that implements mount(2) should be using the
    MS_* flags.  Suppress them inside the kernel unless uapi/linux/mount.h is
    included.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Reviewed-by: David Howells <dhowells@redhat.com>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index c286cf5da6e7..2c0e0f37a318 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -32,6 +32,7 @@
 #include <linux/of.h>
 #include <linux/of_fdt.h>
 #include <linux/uaccess.h>
+#include <uapi/linux/mount.h>
 #include <asm/io.h>
 #include <asm/page.h>
 #include <asm/elf.h>

commit ac21fc2dcb405cf250ad3f1228f64f64930d9211
Author: Rob Herring <robh@kernel.org>
Date:   Fri May 11 08:45:59 2018 -0500

    sh: switch to NO_BOOTMEM
    
    Commit 0fa1c579349f ("of/fdt: use memblock_virt_alloc for early alloc")
    inadvertently switched the DT unflattening allocations from memblock to
    bootmem which doesn't work because the unflattening happens before
    bootmem is initialized. Swapping the order of bootmem init and
    unflattening could also fix this, but removing bootmem is desired. So
    enable NO_BOOTMEM on SH like other architectures have done.
    
    Fixes: 0fa1c579349f ("of/fdt: use memblock_virt_alloc for early alloc")
    Reported-by: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Rich Felker <dalias@libc.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index d34e998b809f..c286cf5da6e7 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -11,7 +11,6 @@
 #include <linux/ioport.h>
 #include <linux/init.h>
 #include <linux/initrd.h>
-#include <linux/bootmem.h>
 #include <linux/console.h>
 #include <linux/root_dev.h>
 #include <linux/utsname.h>

commit eb6b6930a70faefe04479a71088cc10366782d9a
Author: Rich Felker <dalias@libc.org>
Date:   Mon Jul 31 01:27:50 2017 -0400

    sh: fix memory corruption of unflattened device tree
    
    unflatten_device_tree() makes use of memblock allocation, and
    therefore must be called before paging_init() migrates the memblock
    allocation data to the bootmem framework. Otherwise the record of the
    allocation for the expanded device tree will be lost, and will
    eventually be clobbered when allocated for another use.
    
    Signed-off-by: Rich Felker <dalias@libc.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index b95c411d0333..d34e998b809f 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -330,6 +330,14 @@ void __init setup_arch(char **cmdline_p)
 	/* Let earlyprintk output early console messages */
 	early_platform_driver_probe("earlyprintk", 1, 1);
 
+#ifdef CONFIG_OF_FLATTREE
+#ifdef CONFIG_USE_BUILTIN_DTB
+	unflatten_and_copy_device_tree();
+#else
+	unflatten_device_tree();
+#endif
+#endif
+
 	paging_init();
 
 #ifdef CONFIG_DUMMY_CONSOLE

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 3a44c753b642..b95c411d0333 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * arch/sh/kernel/setup.c
  *

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index e7b49d81053e..3a44c753b642 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -31,7 +31,7 @@
 #include <linux/memblock.h>
 #include <linux/of.h>
 #include <linux/of_fdt.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <asm/io.h>
 #include <asm/page.h>
 #include <asm/elf.h>

commit 03767daa1387f87619404bfe108ebb6aa5826e00
Author: Rich Felker <dalias@libc.org>
Date:   Wed Jun 1 22:21:45 2016 +0000

    sh: fix build regression with CONFIG_OF && !CONFIG_OF_FLATTREE
    
    Such a configuration could only be selected by manually selecting
    CONFIG_OF; SH_DEVICE_TREE selects both. The affected code is using the
    flat DTB at boot time and thus rightfully should depend on
    OF_FLATTREE, not just OF.
    
    Signed-off-by: Rich Felker <dalias@libc.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 5b9eb70311e3..e7b49d81053e 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -242,7 +242,7 @@ void __init __weak plat_early_device_setup(void)
 {
 }
 
-#ifdef CONFIG_OF
+#ifdef CONFIG_OF_FLATTREE
 void __ref sh_fdt_init(phys_addr_t dt_phys)
 {
 	static int done = 0;

commit 190fe191cfbead9fe089453dd092869c9469c6d4
Author: Rich Felker <dalias@libc.org>
Date:   Sat Mar 26 01:24:30 2016 +0000

    sh: add support for linking a builtin device tree blob in the kernel
    
    Signed-off-by: Rich Felker <dalias@libc.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 5d34605b58b5..5b9eb70311e3 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -251,7 +251,11 @@ void __ref sh_fdt_init(phys_addr_t dt_phys)
 	/* Avoid calling an __init function on secondary cpus. */
 	if (done) return;
 
+#ifdef CONFIG_USE_BUILTIN_DTB
+	dt_virt = __dtb_start;
+#else
 	dt_virt = phys_to_virt(dt_phys);
+#endif
 
 	if (!dt_virt || !early_init_dt_scan(dt_virt)) {
 		pr_crit("Error: invalid device tree blob"

commit b31a3bc3dbd2f42b61674d37de7f46022e1f6846
Merge: d5e2d00898bd b15d53d00955
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 19 16:09:43 2016 -0700

    Merge tag 'tag-sh-for-4.6' of git://git.libc.org/linux-sh
    
    Pull arch/sh updates from Rich Felker:
     "This includes minor cleanups, a fix for a crash that likely affects
      all sh models with MMU, and introduction of a framework for boards
      described by device tree, which sets the stage for future J2 support"
    
    * tag 'tag-sh-for-4.6' of git://git.libc.org/linux-sh:
      sched/preempt, sh: kmap_coherent relies on disabled preemption
      sh: add SMP method selection to device tree pseudo-board
      sh: add device tree support and generic board using device tree
      sh: remove arch-specific localtimer and use generic one
      sh: make MMU-specific SMP code conditional on CONFIG_MMU
      sh: provide unified syscall trap compatible with all SH models
      sh: New gcc support
      sh: Disable trace for kernel uncompressing.
      sh: Use generic clkdev.h header

commit 7480e0aabd5f9e6c3e3b72ed206e89284e90f11f
Author: Rich Felker <dalias@libc.org>
Date:   Sat Jan 23 00:45:41 2016 +0000

    sh: add device tree support and generic board using device tree
    
    Add a new pseudo-board, within the existing SH boards/machine-vectors
    framework, which does not represent any actual hardware but instead
    requires all hardware to be described by the device tree blob provided
    by the boot loader. Changes made are thus non-invasive and do not risk
    breaking support for legacy boards.
    
    New hardware, including the open-hardware J2 and associated SoC
    devices, will use device free from the outset. Legacy SH boards can
    transition to device tree once all their hardware has device tree
    bindings, driver support for device tree, and a dts file for the
    board.
    
    It is intented that, once all boards are supported in the new
    framework, the existing machine-vectors framework should be removed
    and the new device tree setup code integrated directly.
    
    Signed-off-by: Rich Felker <dalias@libc.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index de19cfa768f2..efb60ce720a7 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -29,6 +29,8 @@
 #include <linux/delay.h>
 #include <linux/platform_device.h>
 #include <linux/memblock.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/page.h>
@@ -172,6 +174,7 @@ void __init check_for_initrd(void)
 #endif
 }
 
+#ifndef CONFIG_GENERIC_CALIBRATE_DELAY
 void calibrate_delay(void)
 {
 	struct clk *clk = clk_get(NULL, "cpu_clk");
@@ -187,6 +190,7 @@ void calibrate_delay(void)
 			 (loops_per_jiffy/(5000/HZ)) % 100,
 			 loops_per_jiffy);
 }
+#endif
 
 void __init __add_active_range(unsigned int nid, unsigned long start_pfn,
 						unsigned long end_pfn)
@@ -238,6 +242,29 @@ void __init __weak plat_early_device_setup(void)
 {
 }
 
+#ifdef CONFIG_OF
+void __ref sh_fdt_init(phys_addr_t dt_phys)
+{
+	static int done = 0;
+	void *dt_virt;
+
+	/* Avoid calling an __init function on secondary cpus. */
+	if (done) return;
+
+	dt_virt = phys_to_virt(dt_phys);
+
+	if (!dt_virt || !early_init_dt_scan(dt_virt)) {
+		pr_crit("Error: invalid device tree blob"
+			" at physical address %p\n", (void *)dt_phys);
+
+		while (true)
+			cpu_relax();
+	}
+
+	done = 1;
+}
+#endif
+
 void __init setup_arch(char **cmdline_p)
 {
 	enable_mmu();

commit 35d98e93fe6a7ab612f6b389ce42c1dc135d6eef
Author: Toshi Kani <toshi.kani@hpe.com>
Date:   Tue Jan 26 21:57:22 2016 +0100

    arch: Set IORESOURCE_SYSTEM_RAM flag for System RAM
    
    Set IORESOURCE_SYSTEM_RAM in flags of resource ranges with
    "System RAM", "Kernel code", "Kernel data", and "Kernel bss".
    
    Note that:
    
     - IORESOURCE_SYSRAM (i.e. modifier bit) is set in flags when
       IORESOURCE_MEM is already set. IORESOURCE_SYSTEM_RAM is defined
       as (IORESOURCE_MEM|IORESOURCE_SYSRAM).
    
     - Some archs do not set 'flags' for children nodes, such as
       "Kernel code".  This patch does not change 'flags' in this
       case.
    
    Signed-off-by: Toshi Kani <toshi.kani@hpe.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Toshi Kani <toshi.kani@hp.com>
    Cc: linux-arch@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-mips@linux-mips.org
    Cc: linux-mm <linux-mm@kvack.org>
    Cc: linux-parisc@vger.kernel.org
    Cc: linux-s390@vger.kernel.org
    Cc: linux-sh@vger.kernel.org
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: sparclinux@vger.kernel.org
    Link: http://lkml.kernel.org/r/1453841853-11383-7-git-send-email-bp@alien8.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index de19cfa768f2..3f1c18b28e8a 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -78,17 +78,17 @@ static char __initdata command_line[COMMAND_LINE_SIZE] = { 0, };
 
 static struct resource code_resource = {
 	.name = "Kernel code",
-	.flags = IORESOURCE_BUSY | IORESOURCE_MEM,
+	.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,
 };
 
 static struct resource data_resource = {
 	.name = "Kernel data",
-	.flags = IORESOURCE_BUSY | IORESOURCE_MEM,
+	.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,
 };
 
 static struct resource bss_resource = {
 	.name	= "Kernel bss",
-	.flags	= IORESOURCE_BUSY | IORESOURCE_MEM,
+	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,
 };
 
 unsigned long memory_start;
@@ -202,7 +202,7 @@ void __init __add_active_range(unsigned int nid, unsigned long start_pfn,
 	res->name = "System RAM";
 	res->start = start;
 	res->end = end - 1;
-	res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+	res->flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;
 
 	if (request_resource(&iomem_resource, res)) {
 		pr_err("unable to request memory_resource 0x%lx 0x%lx\n",

commit e7e8de5918dd6a07cbddae559600d7765ad6a56e
Author: Tang Chen <tangchen@cn.fujitsu.com>
Date:   Tue Jan 21 15:49:26 2014 -0800

    memblock: make memblock_set_node() support different memblock_type
    
    [sfr@canb.auug.org.au: fix powerpc build]
    Signed-off-by: Tang Chen <tangchen@cn.fujitsu.com>
    Reviewed-by: Zhang Yanfei <zhangyanfei@cn.fujitsu.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: "Rafael J . Wysocki" <rjw@sisk.pl>
    Cc: Chen Tang <imtangchen@gmail.com>
    Cc: Gong Chen <gong.chen@linux.intel.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Jiang Liu <jiang.liu@huawei.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Lai Jiangshan <laijs@cn.fujitsu.com>
    Cc: Larry Woodman <lwoodman@redhat.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Liu Jiang <jiang.liu@huawei.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Michal Nazarewicz <mina86@mina86.com>
    Cc: Minchan Kim <minchan@kernel.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Thomas Renninger <trenn@suse.de>
    Cc: Toshi Kani <toshi.kani@hp.com>
    Cc: Vasilis Liaskovitis <vasilis.liaskovitis@profitbricks.com>
    Cc: Wanpeng Li <liwanp@linux.vnet.ibm.com>
    Cc: Wen Congyang <wency@cn.fujitsu.com>
    Cc: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 1cf90e947dbf..de19cfa768f2 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -230,8 +230,8 @@ void __init __add_active_range(unsigned int nid, unsigned long start_pfn,
 	pmb_bolt_mapping((unsigned long)__va(start), start, end - start,
 			 PAGE_KERNEL);
 
-	memblock_set_node(PFN_PHYS(start_pfn),
-			  PFN_PHYS(end_pfn - start_pfn), nid);
+	memblock_set_node(PFN_PHYS(start_pfn), PFN_PHYS(end_pfn - start_pfn),
+			  &memblock.memory, nid);
 }
 
 void __init __weak plat_early_device_setup(void)

commit 4603f53a1dc3c76dfba841d123db9fa6204934f5
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Jun 18 17:10:12 2013 -0400

    sh: delete __cpuinit usage from all sh files
    
    The __cpuinit type of throwaway sections might have made sense
    some time ago when RAM was more constrained, but now the savings
    do not offset the cost and complications.  For example, the fix in
    commit 5e427ec2d0 ("x86: Fix bit corruption at CPU resume time")
    is a good example of the nasty type of bugs that can be created
    with improper use of the various __init prefixes.
    
    After a discussion on LKML[1] it was decided that cpuinit should go
    the way of devinit and be phased out.  Once all the users are gone,
    we can then finally remove the macros themselves from linux/init.h.
    
    Note that some harmless section mismatch warnings may result, since
    notify_cpu_starting() and cpu_up() are arch independent (kernel/cpu.c)
    are flagged as __cpuinit  -- so if we remove the __cpuinit from
    arch specific callers, we will also get section mismatch warnings.
    As an intermediate step, we intend to turn the linux/init.h cpuinit
    content into no-ops as early as possible, since that will get rid
    of these warnings.  In any case, they are temporary and harmless.
    
    This removes all the arch/sh uses of the __cpuinit macros from
    all C files.  Currently sh does not have any __CPUINIT used in
    assembly files.
    
    [1] https://lkml.org/lkml/2013/5/20/589
    
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: linux-sh@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index ebe7a7d97215..1cf90e947dbf 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -172,7 +172,7 @@ void __init check_for_initrd(void)
 #endif
 }
 
-void __cpuinit calibrate_delay(void)
+void calibrate_delay(void)
 {
 	struct clk *clk = clk_get(NULL, "cpu_clk");
 

commit 363737d66427c18edb321a06933ac999d9ce5d7f
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Thu May 31 22:39:21 2012 +0200

    mtd/uclinux: Use generic __bss_stop instead of _ebss
    
    The standard (see BSS_SECTION() in <asm-generic/vmlinux.lds.h> and
    <asm-generic/sections.h>) symbol for the end of BSS is __bss_stop.
    This allows to remove all local declarations that have been added to
    several architectures just to please CONFIG_MTD_UCLINUX.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Acked-by: Michal Simek <monstr@monstr.eu>
    Acked-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 7b57bf1dc855..ebe7a7d97215 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -273,7 +273,7 @@ void __init setup_arch(char **cmdline_p)
 	data_resource.start = virt_to_phys(_etext);
 	data_resource.end = virt_to_phys(_edata)-1;
 	bss_resource.start = virt_to_phys(__bss_start);
-	bss_resource.end = virt_to_phys(_ebss)-1;
+	bss_resource.end = virt_to_phys(__bss_stop)-1;
 
 #ifdef CONFIG_CMDLINE_OVERWRITE
 	strlcpy(command_line, CONFIG_CMDLINE, sizeof(command_line));

commit 534cfbee295222e188c391db5187ca9a6ab0c035
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Dec 8 10:22:08 2011 -0800

    SuperH: Use HAVE_MEMBLOCK_NODE_MAP
    
    sh doesn't access early_node_map[] directly and enabling
    HAVE_MEMBLOCK_NODE_MAP is trivial - replacing add_active_range() calls
    with memblock_set_node() and selecting HAVE_MEMBLOCK_NODE_MAP is
    enough.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: linux-sh@vger.kernel.org

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 1a0e946679a4..7b57bf1dc855 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -230,7 +230,8 @@ void __init __add_active_range(unsigned int nid, unsigned long start_pfn,
 	pmb_bolt_mapping((unsigned long)__va(start), start, end - start,
 			 PAGE_KERNEL);
 
-	add_active_range(nid, start_pfn, end_pfn);
+	memblock_set_node(PFN_PHYS(start_pfn),
+			  PFN_PHYS(end_pfn - start_pfn), nid);
 }
 
 void __init __weak plat_early_device_setup(void)

commit 41309b7a22805f1650c600723d729af453d52719
Author: Simon Horman <horms@verge.net.au>
Date:   Fri Sep 2 03:47:12 2011 +0000

    sh: kexec: Register crashk_res
    
    Register crashk_res so that it can be used by kexec-tools
    via /proc/iomem.
    
    The crash kernel resource needs to be requested the same as the
    other kernel resources due to the fact that it's handled during
    the common path for adding new memory ranges, so it's added in to
    __add_active_range() with the others. This ensures that the crash
    kernel is properly reserved regardless of which memory range it's
    placed in.
    
    Signed-off-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 58bff45d1156..1a0e946679a4 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -211,13 +211,16 @@ void __init __add_active_range(unsigned int nid, unsigned long start_pfn,
 	}
 
 	/*
-	 *  We don't know which RAM region contains kernel data,
-	 *  so we try it repeatedly and let the resource manager
-	 *  test it.
+	 * We don't know which RAM region contains kernel data or
+	 * the reserved crashkernel region, so try it repeatedly
+	 * and let the resource manager test it.
 	 */
 	request_resource(res, &code_resource);
 	request_resource(res, &data_resource);
 	request_resource(res, &bss_resource);
+#ifdef CONFIG_KEXEC
+	request_resource(res, &crashk_res);
+#endif
 
 	/*
 	 * Also make sure that there is a PMB mapping that covers this

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 4f267160c515..58bff45d1156 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -150,7 +150,7 @@ void __init check_for_initrd(void)
 	}
 
 	/*
-	 * If we got this far inspite of the boot loader's best efforts
+	 * If we got this far in spite of the boot loader's best efforts
 	 * to the contrary, assume we actually have a valid initrd and
 	 * fix up the root dev.
 	 */

commit a9b27bcc6acf2491609f51aa592ec67311d4518d
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Nov 1 12:44:25 2010 -0400

    sh: Break out cpuinfo_op procfs bits.
    
    Presently this is all inlined in setup.c, which is not really the place
    for it. Follow the x86 example and split it out into its own file.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index d6b018c7ebdc..4f267160c515 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -12,7 +12,6 @@
 #include <linux/initrd.h>
 #include <linux/bootmem.h>
 #include <linux/console.h>
-#include <linux/seq_file.h>
 #include <linux/root_dev.h>
 #include <linux/utsname.h>
 #include <linux/nodemask.h>
@@ -319,146 +318,3 @@ int test_mode_pin(int pin)
 {
 	return sh_mv.mv_mode_pins() & pin;
 }
-
-static const char *cpu_name[] = {
-	[CPU_SH7201]	= "SH7201",
-	[CPU_SH7203]	= "SH7203",	[CPU_SH7263]	= "SH7263",
-	[CPU_SH7206]	= "SH7206",	[CPU_SH7619]	= "SH7619",
-	[CPU_SH7705]	= "SH7705",	[CPU_SH7706]	= "SH7706",
-	[CPU_SH7707]	= "SH7707",	[CPU_SH7708]	= "SH7708",
-	[CPU_SH7709]	= "SH7709",	[CPU_SH7710]	= "SH7710",
-	[CPU_SH7712]	= "SH7712",	[CPU_SH7720]	= "SH7720",
-	[CPU_SH7721]	= "SH7721",	[CPU_SH7729]	= "SH7729",
-	[CPU_SH7750]	= "SH7750",	[CPU_SH7750S]	= "SH7750S",
-	[CPU_SH7750R]	= "SH7750R",	[CPU_SH7751]	= "SH7751",
-	[CPU_SH7751R]	= "SH7751R",	[CPU_SH7760]	= "SH7760",
-	[CPU_SH4_202]	= "SH4-202",	[CPU_SH4_501]	= "SH4-501",
-	[CPU_SH7763]	= "SH7763",	[CPU_SH7770]	= "SH7770",
-	[CPU_SH7780]	= "SH7780",	[CPU_SH7781]	= "SH7781",
-	[CPU_SH7343]	= "SH7343",	[CPU_SH7785]	= "SH7785",
-	[CPU_SH7786]	= "SH7786",	[CPU_SH7757]	= "SH7757",
-	[CPU_SH7722]	= "SH7722",	[CPU_SHX3]	= "SH-X3",
-	[CPU_SH5_101]	= "SH5-101",	[CPU_SH5_103]	= "SH5-103",
-	[CPU_MXG]	= "MX-G",	[CPU_SH7723]	= "SH7723",
-	[CPU_SH7366]	= "SH7366",	[CPU_SH7724]	= "SH7724",
-	[CPU_SH_NONE]	= "Unknown"
-};
-
-const char *get_cpu_subtype(struct sh_cpuinfo *c)
-{
-	return cpu_name[c->type];
-}
-EXPORT_SYMBOL(get_cpu_subtype);
-
-#ifdef CONFIG_PROC_FS
-/* Symbolic CPU flags, keep in sync with asm/cpu-features.h */
-static const char *cpu_flags[] = {
-	"none", "fpu", "p2flush", "mmuassoc", "dsp", "perfctr",
-	"ptea", "llsc", "l2", "op32", "pteaex", NULL
-};
-
-static void show_cpuflags(struct seq_file *m, struct sh_cpuinfo *c)
-{
-	unsigned long i;
-
-	seq_printf(m, "cpu flags\t:");
-
-	if (!c->flags) {
-		seq_printf(m, " %s\n", cpu_flags[0]);
-		return;
-	}
-
-	for (i = 0; cpu_flags[i]; i++)
-		if ((c->flags & (1 << i)))
-			seq_printf(m, " %s", cpu_flags[i+1]);
-
-	seq_printf(m, "\n");
-}
-
-static void show_cacheinfo(struct seq_file *m, const char *type,
-			   struct cache_info info)
-{
-	unsigned int cache_size;
-
-	cache_size = info.ways * info.sets * info.linesz;
-
-	seq_printf(m, "%s size\t: %2dKiB (%d-way)\n",
-		   type, cache_size >> 10, info.ways);
-}
-
-/*
- *	Get CPU information for use by the procfs.
- */
-static int show_cpuinfo(struct seq_file *m, void *v)
-{
-	struct sh_cpuinfo *c = v;
-	unsigned int cpu = c - cpu_data;
-
-	if (!cpu_online(cpu))
-		return 0;
-
-	if (cpu == 0)
-		seq_printf(m, "machine\t\t: %s\n", get_system_type());
-	else
-		seq_printf(m, "\n");
-
-	seq_printf(m, "processor\t: %d\n", cpu);
-	seq_printf(m, "cpu family\t: %s\n", init_utsname()->machine);
-	seq_printf(m, "cpu type\t: %s\n", get_cpu_subtype(c));
-	if (c->cut_major == -1)
-		seq_printf(m, "cut\t\t: unknown\n");
-	else if (c->cut_minor == -1)
-		seq_printf(m, "cut\t\t: %d.x\n", c->cut_major);
-	else
-		seq_printf(m, "cut\t\t: %d.%d\n", c->cut_major, c->cut_minor);
-
-	show_cpuflags(m, c);
-
-	seq_printf(m, "cache type\t: ");
-
-	/*
-	 * Check for what type of cache we have, we support both the
-	 * unified cache on the SH-2 and SH-3, as well as the harvard
-	 * style cache on the SH-4.
-	 */
-	if (c->icache.flags & SH_CACHE_COMBINED) {
-		seq_printf(m, "unified\n");
-		show_cacheinfo(m, "cache", c->icache);
-	} else {
-		seq_printf(m, "split (harvard)\n");
-		show_cacheinfo(m, "icache", c->icache);
-		show_cacheinfo(m, "dcache", c->dcache);
-	}
-
-	/* Optional secondary cache */
-	if (c->flags & CPU_HAS_L2_CACHE)
-		show_cacheinfo(m, "scache", c->scache);
-
-	seq_printf(m, "address sizes\t: %u bits physical\n", c->phys_bits);
-
-	seq_printf(m, "bogomips\t: %lu.%02lu\n",
-		     c->loops_per_jiffy/(500000/HZ),
-		     (c->loops_per_jiffy/(5000/HZ)) % 100);
-
-	return 0;
-}
-
-static void *c_start(struct seq_file *m, loff_t *pos)
-{
-	return *pos < NR_CPUS ? cpu_data + *pos : NULL;
-}
-static void *c_next(struct seq_file *m, void *v, loff_t *pos)
-{
-	++*pos;
-	return c_start(m, pos);
-}
-static void c_stop(struct seq_file *m, void *v)
-{
-}
-const struct seq_operations cpuinfo_op = {
-	.start	= c_start,
-	.next	= c_next,
-	.stop	= c_stop,
-	.show	= show_cpuinfo,
-};
-#endif /* CONFIG_PROC_FS */

commit 9cc1cf380e15f7314f8defb849b8e926d5755f8b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Oct 27 14:24:34 2010 +0900

    sh: Fix the sparsemem disabled build.
    
    The introduction of MAX_PHYSMEM_BITS in to the initial cpuinfo struct
    causes a build error when sparsemem is disabled and asm/sparsemem.h is
    not brought in by other means. Include it explicitly.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 82c0a0c1df0d..d6b018c7ebdc 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -41,6 +41,7 @@
 #include <asm/smp.h>
 #include <asm/mmu_context.h>
 #include <asm/mmzone.h>
+#include <asm/sparsemem.h>
 
 /*
  * Initialize loops_per_jiffy as 10000000 (1000MIPS).

commit 2f98492c5375e906e48c78d88351f45bb11b6a8a
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Oct 26 14:44:58 2010 +0900

    sh: Expose physical addressing mode through cpuinfo.
    
    CPUs can be in either the legacy 29-bit or 32-bit physical addressing
    modes. This follows the x86 approach of tracking the phys bits in cpuinfo
    and exposing it to userspace through procfs.
    
    This change was requested to permit kexec-tools to detect the physical
    addressing mode in order to determine the appropriate address mangling.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 4e278467f76c..82c0a0c1df0d 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -52,6 +52,7 @@ struct sh_cpuinfo cpu_data[NR_CPUS] __read_mostly = {
 		.type			= CPU_SH_NONE,
 		.family			= CPU_FAMILY_UNKNOWN,
 		.loops_per_jiffy	= 10000000,
+		.phys_bits		= MAX_PHYSMEM_BITS,
 	},
 };
 EXPORT_SYMBOL(cpu_data);
@@ -432,6 +433,8 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 	if (c->flags & CPU_HAS_L2_CACHE)
 		show_cacheinfo(m, "scache", c->scache);
 
+	seq_printf(m, "address sizes\t: %u bits physical\n", c->phys_bits);
+
 	seq_printf(m, "bogomips\t: %lu.%02lu\n",
 		     c->loops_per_jiffy/(500000/HZ),
 		     (c->loops_per_jiffy/(5000/HZ)) % 100);

commit 901c28c257eb8903a7d66c900df163e2c13ca995
Author: Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
Date:   Tue Oct 5 08:16:08 2010 +0000

    sh: Fix address calculation of Initrd
    
    Signed-off-by: Nobuhiro Iwamatsu <nobuhiro.iwamatsu.yj@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index f24d0ea8be2d..4e278467f76c 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -135,8 +135,9 @@ void __init check_for_initrd(void)
 		goto disable;
 	}
 
-	if (unlikely(start < PAGE_OFFSET)) {
-		pr_err("initrd start < PAGE_OFFSET\n");
+	if (unlikely(start < __MEMORY_START)) {
+		pr_err("initrd start (%08lx) < __MEMORY_START(%x)\n",
+			start, __MEMORY_START);
 		goto disable;
 	}
 
@@ -157,7 +158,7 @@ void __init check_for_initrd(void)
 	/*
 	 * Address sanitization
 	 */
-	initrd_start = (unsigned long)__va(__pa(start));
+	initrd_start = (unsigned long)__va(start);
 	initrd_end = initrd_start + INITRD_SIZE;
 
 	memblock_reserve(__pa(initrd_start), INITRD_SIZE);

commit 3f224f4e057ce67713f3e7a8890f2fbe12d047a5
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Sep 24 04:04:26 2010 +0900

    sh: provide generic arch_debugfs_dir.
    
    While sh previously had its own debugfs root, there now exists a
    common arch_debugfs_dir prototype, so we switch everything over to
    that.  Presumably once more architectures start making use of this
    we'll be able to just kill off the stub kdebugfs wrapper.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index e769401a78ba..f24d0ea8be2d 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -24,7 +24,6 @@
 #include <linux/module.h>
 #include <linux/smp.h>
 #include <linux/err.h>
-#include <linux/debugfs.h>
 #include <linux/crash_dump.h>
 #include <linux/mmzone.h>
 #include <linux/clk.h>
@@ -458,17 +457,3 @@ const struct seq_operations cpuinfo_op = {
 	.show	= show_cpuinfo,
 };
 #endif /* CONFIG_PROC_FS */
-
-struct dentry *sh_debugfs_root;
-
-static int __init sh_debugfs_init(void)
-{
-	sh_debugfs_root = debugfs_create_dir("sh", NULL);
-	if (!sh_debugfs_root)
-		return -ENOMEM;
-	if (IS_ERR(sh_debugfs_root))
-		return PTR_ERR(sh_debugfs_root);
-
-	return 0;
-}
-arch_initcall(sh_debugfs_init);

commit 95f72d1ed41a66f1c1c29c24d479de81a0bea36f
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Jul 12 14:36:09 2010 +1000

    lmb: rename to memblock
    
    via following scripts
    
          FILES=$(find * -type f | grep -vE 'oprofile|[^K]config')
    
          sed -i \
            -e 's/lmb/memblock/g' \
            -e 's/LMB/MEMBLOCK/g' \
            $FILES
    
          for N in $(find . -name lmb.[ch]); do
            M=$(echo $N | sed 's/lmb/memblock/g')
            mv $N $M
          done
    
    and remove some wrong change like lmbench and dlmb etc.
    
    also move memblock.c from lib/ to mm/
    
    Suggested-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 272734681d29..e769401a78ba 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -30,7 +30,7 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/platform_device.h>
-#include <linux/lmb.h>
+#include <linux/memblock.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/page.h>
@@ -141,10 +141,10 @@ void __init check_for_initrd(void)
 		goto disable;
 	}
 
-	if (unlikely(end > lmb_end_of_DRAM())) {
+	if (unlikely(end > memblock_end_of_DRAM())) {
 		pr_err("initrd extends beyond end of memory "
 		       "(0x%08lx > 0x%08lx)\ndisabling initrd\n",
-		       end, (unsigned long)lmb_end_of_DRAM());
+		       end, (unsigned long)memblock_end_of_DRAM());
 		goto disable;
 	}
 
@@ -161,7 +161,7 @@ void __init check_for_initrd(void)
 	initrd_start = (unsigned long)__va(__pa(start));
 	initrd_end = initrd_start + INITRD_SIZE;
 
-	lmb_reserve(__pa(initrd_start), INITRD_SIZE);
+	memblock_reserve(__pa(initrd_start), INITRD_SIZE);
 
 	return;
 

commit ef4ed97d6bd91aa41907181e80a7feaf2721719a
Merge: c5eb5b372e7e 21823259a70b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu May 13 17:48:05 2010 +0900

    Merge branch 'sh/lmb'
    
    Conflicts:
            arch/sh/kernel/setup.c

commit 21823259a70b7a2a21eea1d48c25a6f38896dd11
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 11 13:52:50 2010 +0900

    sh: Ensure active regions have a backing PMB entry.
    
    In the NUMA or memory hot-add case where system memory has been
    partitioned up, we immediately run in to a situation where the existing
    PMB entry doesn't cover the new range (primarily as a result of the entry
    size being shrunk to match the node size early in the initialization). In
    order to fix this up it's necessary to preload a PMB mapping for the new
    range prior to activation in order to circumvent reset by MMU.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 61404ed01449..57bd93838f15 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -191,13 +191,18 @@ void __init __add_active_range(unsigned int nid, unsigned long start_pfn,
 						unsigned long end_pfn)
 {
 	struct resource *res = &mem_resources[nid];
+	unsigned long start, end;
 
 	WARN_ON(res->name); /* max one active range per node for now */
 
+	start = start_pfn << PAGE_SHIFT;
+	end = end_pfn << PAGE_SHIFT;
+
 	res->name = "System RAM";
-	res->start = start_pfn << PAGE_SHIFT;
-	res->end = (end_pfn << PAGE_SHIFT) - 1;
+	res->start = start;
+	res->end = end - 1;
 	res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+
 	if (request_resource(&iomem_resource, res)) {
 		pr_err("unable to request memory_resource 0x%lx 0x%lx\n",
 		       start_pfn, end_pfn);
@@ -213,6 +218,14 @@ void __init __add_active_range(unsigned int nid, unsigned long start_pfn,
 	request_resource(res, &data_resource);
 	request_resource(res, &bss_resource);
 
+	/*
+	 * Also make sure that there is a PMB mapping that covers this
+	 * range before we attempt to activate it, to avoid reset by MMU.
+	 * We can hit this path with NUMA or memory hot-add.
+	 */
+	pmb_bolt_mapping((unsigned long)__va(start), start, end - start,
+			 PAGE_KERNEL);
+
 	add_active_range(nid, start_pfn, end_pfn);
 }
 

commit 4bc277ac9cae60e11fe2e557e4ea4acb56d3dc9a
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 11 13:32:19 2010 +0900

    sh: bootmem refactoring.
    
    This reworks much of the bootmem setup and initialization code allowing
    us to get rid of duplicate work between the NUMA and non-NUMA cases. The
    end result is that we end up with a much more flexible interface for
    supporting more complex topologies (fake NUMA, highmem, etc, etc.) which
    is entirely LMB backed. This is an incremental step for more NUMA work as
    well as gradually enabling migration off of bootmem entirely.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index f6a2db12ad78..61404ed01449 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -114,31 +114,7 @@ static int __init early_parse_mem(char *p)
 }
 early_param("mem", early_parse_mem);
 
-/*
- * Register fully available low RAM pages with the bootmem allocator.
- */
-static void __init register_bootmem_low_pages(void)
-{
-	unsigned long curr_pfn, last_pfn, pages;
-
-	/*
-	 * We are rounding up the start address of usable memory:
-	 */
-	curr_pfn = PFN_UP(__MEMORY_START);
-
-	/*
-	 * ... and at the end of the usable range downwards:
-	 */
-	last_pfn = PFN_DOWN(__pa(memory_end));
-
-	if (last_pfn > max_low_pfn)
-		last_pfn = max_low_pfn;
-
-	pages = last_pfn - curr_pfn;
-	free_bootmem(PFN_PHYS(curr_pfn), PFN_PHYS(pages));
-}
-
-static void __init check_for_initrd(void)
+void __init check_for_initrd(void)
 {
 #ifdef CONFIG_BLK_DEV_INITRD
 	unsigned long start, end;
@@ -240,85 +216,6 @@ void __init __add_active_range(unsigned int nid, unsigned long start_pfn,
 	add_active_range(nid, start_pfn, end_pfn);
 }
 
-void __init do_init_bootmem(void)
-{
-	unsigned long bootmap_size;
-	unsigned long bootmap_pages, bootmem_paddr;
-	u64 total_pages = lmb_phys_mem_size() >> PAGE_SHIFT;
-	int i;
-
-	bootmap_pages = bootmem_bootmap_pages(total_pages);
-
-	bootmem_paddr = lmb_alloc(bootmap_pages << PAGE_SHIFT, PAGE_SIZE);
-
-	/*
-	 * Find a proper area for the bootmem bitmap. After this
-	 * bootstrap step all allocations (until the page allocator
-	 * is intact) must be done via bootmem_alloc().
-	 */
-	bootmap_size = init_bootmem_node(NODE_DATA(0),
-					 bootmem_paddr >> PAGE_SHIFT,
-					 min_low_pfn, max_low_pfn);
-
-	/* Add active regions with valid PFNs. */
-	for (i = 0; i < lmb.memory.cnt; i++) {
-		unsigned long start_pfn, end_pfn;
-		start_pfn = lmb.memory.region[i].base >> PAGE_SHIFT;
-		end_pfn = start_pfn + lmb_size_pages(&lmb.memory, i);
-		__add_active_range(0, start_pfn, end_pfn);
-	}
-
-	/*
-	 * Add all physical memory to the bootmem map and mark each
-	 * area as present.
-	 */
-	register_bootmem_low_pages();
-
-	/* Reserve the sections we're already using. */
-	for (i = 0; i < lmb.reserved.cnt; i++)
-		reserve_bootmem(lmb.reserved.region[i].base,
-				lmb_size_bytes(&lmb.reserved, i),
-				BOOTMEM_DEFAULT);
-
-	node_set_online(0);
-
-	sparse_memory_present_with_active_regions(0);
-}
-
-static void __init early_reserve_mem(void)
-{
-	unsigned long start_pfn;
-
-	/*
-	 * Partially used pages are not usable - thus
-	 * we are rounding upwards:
-	 */
-	start_pfn = PFN_UP(__pa(_end));
-
-	/*
-	 * Reserve the kernel text and
-	 * Reserve the bootmem bitmap. We do this in two steps (first step
-	 * was init_bootmem()), because this catches the (definitely buggy)
-	 * case of us accidentally initializing the bootmem allocator with
-	 * an invalid RAM area.
-	 */
-	lmb_reserve(__MEMORY_START + CONFIG_ZERO_PAGE_OFFSET,
-		    (PFN_PHYS(start_pfn) + PAGE_SIZE - 1) -
-		    (__MEMORY_START + CONFIG_ZERO_PAGE_OFFSET));
-
-	/*
-	 * Reserve physical pages below CONFIG_ZERO_PAGE_OFFSET.
-	 */
-	if (CONFIG_ZERO_PAGE_OFFSET != 0)
-		lmb_reserve(__MEMORY_START, CONFIG_ZERO_PAGE_OFFSET);
-
-	/*
-	 * Handle additional early reservations
-	 */
-	check_for_initrd();
-	reserve_crashkernel();
-}
-
 /*
  * Note: elfcorehdr_addr is not just limited to vmcore. It is also used by
  * is_kdump_kernel() to determine if we are booting after a panic. Hence
@@ -342,10 +239,6 @@ void __init __weak plat_early_device_setup(void)
 {
 }
 
-void __init __weak plat_mem_setup(void)
-{
-}
-
 void __init setup_arch(char **cmdline_p)
 {
 	enable_mmu();
@@ -401,44 +294,16 @@ void __init setup_arch(char **cmdline_p)
 
 	plat_early_device_setup();
 
-	/* Let earlyprintk output early console messages */
-	early_platform_driver_probe("earlyprintk", 1, 1);
-
-	lmb_init();
-
 	sh_mv_setup();
-	sh_mv.mv_mem_init();
-
-	early_reserve_mem();
 
-	lmb_enforce_memory_limit(memory_limit);
-	lmb_analyze();
-
-	lmb_dump_all();
-
-	/*
-	 * Determine low and high memory ranges:
-	 */
-	max_low_pfn = max_pfn = lmb_end_of_DRAM() >> PAGE_SHIFT;
-	min_low_pfn = __MEMORY_START >> PAGE_SHIFT;
-
-	nodes_clear(node_online_map);
-
-	memory_start = (unsigned long)__va(__MEMORY_START);
-	memory_end = memory_start + (memory_limit ?: lmb_phys_mem_size());
+	/* Let earlyprintk output early console messages */
+	early_platform_driver_probe("earlyprintk", 1, 1);
 
-	uncached_init();
-	pmb_init();
-	do_init_bootmem();
-	plat_mem_setup();
-	sparse_init();
+	paging_init();
 
 #ifdef CONFIG_DUMMY_CONSOLE
 	conswitchp = &dummy_con;
 #endif
-	paging_init();
-
-	ioremap_fixed_init();
 
 	/* Perform the machine specific initialisation */
 	if (likely(sh_mv.mv_setup))

commit 5e2ff328c0668794ff408a4632f5b8a62827571f
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon May 10 20:17:25 2010 +0900

    sh: rework memory limits to work with LMB.
    
    This reworks the memory limit handling to tie in through the available
    LMB infrastructure. This requires a bit of reordering as we need to have
    all of the LMB reservations taken care of prior to establishing the
    limits.
    
    While we're at it, the crash kernel reservation semantics are reworked
    so that we allocate from the bottom up and reduce the risk of having
    to disable the memory limit due to a clash with the crash kernel
    reservation.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 2c9ab2842765..f6a2db12ad78 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -95,6 +95,7 @@ unsigned long memory_start;
 EXPORT_SYMBOL(memory_start);
 unsigned long memory_end = 0;
 EXPORT_SYMBOL(memory_end);
+unsigned long memory_limit = 0;
 
 static struct resource mem_resources[MAX_NUMNODES];
 
@@ -102,21 +103,12 @@ int l1i_cache_shape, l1d_cache_shape, l2_cache_shape;
 
 static int __init early_parse_mem(char *p)
 {
-	unsigned long size;
+	if (!p)
+		return 1;
 
-	memory_start = (unsigned long)__va(__MEMORY_START);
-	size = memparse(p, &p);
-
-	if (size > __MEMORY_SIZE) {
-		printk(KERN_ERR
-			"Using mem= to increase the size of kernel memory "
-			"is not allowed.\n"
-			"  Recompile the kernel with the correct value for "
-			"CONFIG_MEMORY_SIZE.\n");
-		return 0;
-	}
+	memory_limit = PAGE_ALIGN(memparse(p, &p));
 
-	memory_end = memory_start + size;
+	pr_notice("Memory limited to %ldMB\n", memory_limit >> 20);
 
 	return 0;
 }
@@ -252,7 +244,7 @@ void __init do_init_bootmem(void)
 {
 	unsigned long bootmap_size;
 	unsigned long bootmap_pages, bootmem_paddr;
-	u64 total_pages = (lmb_end_of_DRAM() - __MEMORY_START) >> PAGE_SHIFT;
+	u64 total_pages = lmb_phys_mem_size() >> PAGE_SHIFT;
 	int i;
 
 	bootmap_pages = bootmem_bootmap_pages(total_pages);
@@ -276,12 +268,6 @@ void __init do_init_bootmem(void)
 		__add_active_range(0, start_pfn, end_pfn);
 	}
 
-	/*
-	 * Handle additional early reservations
-	 */
-	check_for_initrd();
-	reserve_crashkernel();
-
 	/*
 	 * Add all physical memory to the bootmem map and mark each
 	 * area as present.
@@ -299,7 +285,7 @@ void __init do_init_bootmem(void)
 	sparse_memory_present_with_active_regions(0);
 }
 
-static void __init setup_memory(void)
+static void __init early_reserve_mem(void)
 {
 	unsigned long start_pfn;
 
@@ -326,11 +312,11 @@ static void __init setup_memory(void)
 	if (CONFIG_ZERO_PAGE_OFFSET != 0)
 		lmb_reserve(__MEMORY_START, CONFIG_ZERO_PAGE_OFFSET);
 
-	lmb_analyze();
-	lmb_dump_all();
-
-	do_init_bootmem();
-	plat_mem_setup();
+	/*
+	 * Handle additional early reservations
+	 */
+	check_for_initrd();
+	reserve_crashkernel();
 }
 
 /*
@@ -397,10 +383,6 @@ void __init setup_arch(char **cmdline_p)
 	bss_resource.start = virt_to_phys(__bss_start);
 	bss_resource.end = virt_to_phys(_ebss)-1;
 
-	memory_start = (unsigned long)__va(__MEMORY_START);
-	if (!memory_end)
-		memory_end = memory_start + __MEMORY_SIZE;
-
 #ifdef CONFIG_CMDLINE_OVERWRITE
 	strlcpy(command_line, CONFIG_CMDLINE, sizeof(command_line));
 #else
@@ -417,8 +399,6 @@ void __init setup_arch(char **cmdline_p)
 
 	parse_early_param();
 
-	uncached_init();
-
 	plat_early_device_setup();
 
 	/* Let earlyprintk output early console messages */
@@ -429,21 +409,28 @@ void __init setup_arch(char **cmdline_p)
 	sh_mv_setup();
 	sh_mv.mv_mem_init();
 
-	/*
-	 * Find the highest page frame number we have available
-	 */
-	max_pfn = PFN_DOWN(__pa(memory_end));
+	early_reserve_mem();
+
+	lmb_enforce_memory_limit(memory_limit);
+	lmb_analyze();
+
+	lmb_dump_all();
 
 	/*
 	 * Determine low and high memory ranges:
 	 */
-	max_low_pfn = max_pfn;
+	max_low_pfn = max_pfn = lmb_end_of_DRAM() >> PAGE_SHIFT;
 	min_low_pfn = __MEMORY_START >> PAGE_SHIFT;
 
 	nodes_clear(node_online_map);
 
+	memory_start = (unsigned long)__va(__MEMORY_START);
+	memory_end = memory_start + (memory_limit ?: lmb_phys_mem_size());
+
+	uncached_init();
 	pmb_init();
-	setup_memory();
+	do_init_bootmem();
+	plat_mem_setup();
 	sparse_init();
 
 #ifdef CONFIG_DUMMY_CONSOLE

commit 19d8f84f86af867abee174be8bf1e4941a59143d
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon May 10 15:39:05 2010 +0900

    sh: enable LMB region setup via machvec.
    
    This plugs in a memory init callback in the machvec to permit boards to
    wire up various bits of memory directly in to LMB. A generic machvec
    implementation is provided that simply wraps around the normal
    Kconfig-derived memory start/size.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index e3f0da7b865d..2c9ab2842765 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -4,7 +4,7 @@
  * This file handles the architecture-dependent parts of initialization
  *
  *  Copyright (C) 1999  Niibe Yutaka
- *  Copyright (C) 2002 - 2007 Paul Mundt
+ *  Copyright (C) 2002 - 2010 Paul Mundt
  */
 #include <linux/screen_info.h>
 #include <linux/ioport.h>
@@ -41,6 +41,7 @@
 #include <asm/clock.h>
 #include <asm/smp.h>
 #include <asm/mmu_context.h>
+#include <asm/mmzone.h>
 
 /*
  * Initialize loops_per_jiffy as 10000000 (1000MIPS).
@@ -247,7 +248,7 @@ void __init __add_active_range(unsigned int nid, unsigned long start_pfn,
 	add_active_range(nid, start_pfn, end_pfn);
 }
 
-void __init setup_bootmem_allocator(unsigned long free_pfn)
+void __init do_init_bootmem(void)
 {
 	unsigned long bootmap_size;
 	unsigned long bootmap_pages, bootmem_paddr;
@@ -298,12 +299,9 @@ void __init setup_bootmem_allocator(unsigned long free_pfn)
 	sparse_memory_present_with_active_regions(0);
 }
 
-#ifndef CONFIG_NEED_MULTIPLE_NODES
 static void __init setup_memory(void)
 {
 	unsigned long start_pfn;
-	u64 base = min_low_pfn << PAGE_SHIFT;
-	u64 size = (max_low_pfn << PAGE_SHIFT) - base;
 
 	/*
 	 * Partially used pages are not usable - thus
@@ -311,8 +309,6 @@ static void __init setup_memory(void)
 	 */
 	start_pfn = PFN_UP(__pa(_end));
 
-	lmb_add(base, size);
-
 	/*
 	 * Reserve the kernel text and
 	 * Reserve the bootmem bitmap. We do this in two steps (first step
@@ -333,11 +329,9 @@ static void __init setup_memory(void)
 	lmb_analyze();
 	lmb_dump_all();
 
-	setup_bootmem_allocator(start_pfn);
+	do_init_bootmem();
+	plat_mem_setup();
 }
-#else
-extern void __init setup_memory(void);
-#endif
 
 /*
  * Note: elfcorehdr_addr is not just limited to vmcore. It is also used by
@@ -358,7 +352,11 @@ static int __init parse_elfcorehdr(char *arg)
 early_param("elfcorehdr", parse_elfcorehdr);
 #endif
 
-void __init __attribute__ ((weak)) plat_early_device_setup(void)
+void __init __weak plat_early_device_setup(void)
+{
+}
+
+void __init __weak plat_mem_setup(void)
 {
 }
 
@@ -426,7 +424,10 @@ void __init setup_arch(char **cmdline_p)
 	/* Let earlyprintk output early console messages */
 	early_platform_driver_probe("earlyprintk", 1, 1);
 
+	lmb_init();
+
 	sh_mv_setup();
+	sh_mv.mv_mem_init();
 
 	/*
 	 * Find the highest page frame number we have available
@@ -442,7 +443,6 @@ void __init setup_arch(char **cmdline_p)
 	nodes_clear(node_online_map);
 
 	pmb_init();
-	lmb_init();
 	setup_memory();
 	sparse_init();
 

commit 7aed3b34fb0a98e89d0e999f5833ceebdb3876b9
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri May 7 17:58:55 2010 +0900

    sh: shuffle the elfcorehdr handling over to the crash dump code.
    
    The elfcorehdr parsing was just tossed in setup.c, but nothing outside of
    the crash dump code/vmcore bits require it, so we just move it out of the
    way, as per ppc.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 9c7f7811af70..4f1585f41f2b 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -380,25 +380,6 @@ static void __init setup_memory(void)
 extern void __init setup_memory(void);
 #endif
 
-/*
- * Note: elfcorehdr_addr is not just limited to vmcore. It is also used by
- * is_kdump_kernel() to determine if we are booting after a panic. Hence
- * ifdef it under CONFIG_CRASH_DUMP and not CONFIG_PROC_VMCORE.
- */
-#ifdef CONFIG_CRASH_DUMP
-/* elfcorehdr= specifies the location of elf core header
- * stored by the crashed kernel.
- */
-static int __init parse_elfcorehdr(char *arg)
-{
-	if (!arg)
-		return -EINVAL;
-	elfcorehdr_addr = memparse(arg, &arg);
-	return 0;
-}
-early_param("elfcorehdr", parse_elfcorehdr);
-#endif
-
 void __init __attribute__ ((weak)) plat_early_device_setup(void)
 {
 }

commit 080e71e13d99d850875c0335c364766162eae7c6
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri May 7 15:10:42 2010 +0900

    sh: bump up extra LMB reservations in bootmem init.
    
    This bumps up the extra LMB reservations in ordering so that they're
    accounted for prior to iterating over the region list. This ensures that
    reservations are visible both within the LMB and bootmem context.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 08001729f5ee..e3f0da7b865d 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -275,6 +275,12 @@ void __init setup_bootmem_allocator(unsigned long free_pfn)
 		__add_active_range(0, start_pfn, end_pfn);
 	}
 
+	/*
+	 * Handle additional early reservations
+	 */
+	check_for_initrd();
+	reserve_crashkernel();
+
 	/*
 	 * Add all physical memory to the bootmem map and mark each
 	 * area as present.
@@ -290,10 +296,6 @@ void __init setup_bootmem_allocator(unsigned long free_pfn)
 	node_set_online(0);
 
 	sparse_memory_present_with_active_regions(0);
-
-	check_for_initrd();
-
-	reserve_crashkernel();
 }
 
 #ifndef CONFIG_NEED_MULTIPLE_NODES

commit 36fa06d6b5ef1874d012c04b23d5b8982b1f8dea
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri May 7 15:10:07 2010 +0900

    sh: convert initrd reservation to LMB.
    
    This switches over from bootmem -> LMB for the initrd area reservation.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index d67a8a386907..08001729f5ee 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -192,7 +192,7 @@ static void __init check_for_initrd(void)
 	initrd_start = (unsigned long)__va(__pa(start));
 	initrd_end = initrd_start + INITRD_SIZE;
 
-	reserve_bootmem(__pa(initrd_start), INITRD_SIZE, BOOTMEM_DEFAULT);
+	lmb_reserve(__pa(initrd_start), INITRD_SIZE);
 
 	return;
 

commit a5ec39507129a086d8838228ac1ca0a2eab38f91
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri May 7 14:54:55 2010 +0900

    sh: convert kexec crash kernel management to LMB.
    
    This migrates the crash kernel handling off of bootmem and over to LMB.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 9c7f7811af70..d67a8a386907 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -145,49 +145,6 @@ static void __init register_bootmem_low_pages(void)
 	free_bootmem(PFN_PHYS(curr_pfn), PFN_PHYS(pages));
 }
 
-#ifdef CONFIG_KEXEC
-static void __init reserve_crashkernel(void)
-{
-	unsigned long long free_mem;
-	unsigned long long crash_size, crash_base;
-	void *vp;
-	int ret;
-
-	free_mem = ((unsigned long long)max_low_pfn - min_low_pfn) << PAGE_SHIFT;
-
-	ret = parse_crashkernel(boot_command_line, free_mem,
-			&crash_size, &crash_base);
-	if (ret == 0 && crash_size) {
-		if (crash_base <= 0) {
-			vp = alloc_bootmem_nopanic(crash_size);
-			if (!vp) {
-				printk(KERN_INFO "crashkernel allocation "
-				       "failed\n");
-				return;
-			}
-			crash_base = __pa(vp);
-		} else if (reserve_bootmem(crash_base, crash_size,
-					BOOTMEM_EXCLUSIVE) < 0) {
-			printk(KERN_INFO "crashkernel reservation failed - "
-					"memory is in use\n");
-			return;
-		}
-
-		printk(KERN_INFO "Reserving %ldMB of memory at %ldMB "
-				"for crashkernel (System RAM: %ldMB)\n",
-				(unsigned long)(crash_size >> 20),
-				(unsigned long)(crash_base >> 20),
-				(unsigned long)(free_mem >> 20));
-		crashk_res.start = crash_base;
-		crashk_res.end   = crash_base + crash_size - 1;
-		insert_resource(&iomem_resource, &crashk_res);
-	}
-}
-#else
-static inline void __init reserve_crashkernel(void)
-{}
-#endif
-
 static void __init check_for_initrd(void)
 {
 #ifdef CONFIG_BLK_DEV_INITRD

commit 9b7a37853a8cd69829eb1d9715a6c09aae01eeec
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu May 6 15:09:45 2010 +0900

    sh: Make initrd detection more robust.
    
    Various boot loaders go to various extents to thwart the initrd detection
    logic (mostly on account of not being able to be bothered with adhering
    to the established boot ABI), so we make the detection logic a bit more
    robust. This makes it possible to work around the SDK7786's firmware's
    attempts to thwart compressed image booting. Victory is mine.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 14735d5ede52..9c7f7811af70 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -188,6 +188,63 @@ static inline void __init reserve_crashkernel(void)
 {}
 #endif
 
+static void __init check_for_initrd(void)
+{
+#ifdef CONFIG_BLK_DEV_INITRD
+	unsigned long start, end;
+
+	/*
+	 * Check for the rare cases where boot loaders adhere to the boot
+	 * ABI.
+	 */
+	if (!LOADER_TYPE || !INITRD_START || !INITRD_SIZE)
+		goto disable;
+
+	start = INITRD_START + __MEMORY_START;
+	end = start + INITRD_SIZE;
+
+	if (unlikely(end <= start))
+		goto disable;
+	if (unlikely(start & ~PAGE_MASK)) {
+		pr_err("initrd must be page aligned\n");
+		goto disable;
+	}
+
+	if (unlikely(start < PAGE_OFFSET)) {
+		pr_err("initrd start < PAGE_OFFSET\n");
+		goto disable;
+	}
+
+	if (unlikely(end > lmb_end_of_DRAM())) {
+		pr_err("initrd extends beyond end of memory "
+		       "(0x%08lx > 0x%08lx)\ndisabling initrd\n",
+		       end, (unsigned long)lmb_end_of_DRAM());
+		goto disable;
+	}
+
+	/*
+	 * If we got this far inspite of the boot loader's best efforts
+	 * to the contrary, assume we actually have a valid initrd and
+	 * fix up the root dev.
+	 */
+	ROOT_DEV = Root_RAM0;
+
+	/*
+	 * Address sanitization
+	 */
+	initrd_start = (unsigned long)__va(__pa(start));
+	initrd_end = initrd_start + INITRD_SIZE;
+
+	reserve_bootmem(__pa(initrd_start), INITRD_SIZE, BOOTMEM_DEFAULT);
+
+	return;
+
+disable:
+	pr_info("initrd disabled\n");
+	initrd_start = initrd_end = 0;
+#endif
+}
+
 void __cpuinit calibrate_delay(void)
 {
 	struct clk *clk = clk_get(NULL, "cpu_clk");
@@ -277,26 +334,7 @@ void __init setup_bootmem_allocator(unsigned long free_pfn)
 
 	sparse_memory_present_with_active_regions(0);
 
-#ifdef CONFIG_BLK_DEV_INITRD
-	ROOT_DEV = Root_RAM0;
-
-	if (LOADER_TYPE && INITRD_START) {
-		unsigned long initrd_start_phys = INITRD_START + __MEMORY_START;
-
-		if (initrd_start_phys + INITRD_SIZE <= PFN_PHYS(max_low_pfn)) {
-			reserve_bootmem(initrd_start_phys, INITRD_SIZE,
-					BOOTMEM_DEFAULT);
-			initrd_start = (unsigned long)__va(initrd_start_phys);
-			initrd_end = initrd_start + INITRD_SIZE;
-		} else {
-			printk("initrd extends beyond end of memory "
-			       "(0x%08lx > 0x%08lx)\ndisabling initrd\n",
-			       initrd_start_phys + INITRD_SIZE,
-			       (unsigned long)PFN_PHYS(max_low_pfn));
-			initrd_start = 0;
-		}
-	}
-#endif
+	check_for_initrd();
 
 	reserve_crashkernel();
 }

commit c9f4a3f53b5d61f86eae3512abdf948878ca3498
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Apr 26 18:35:44 2010 +0900

    sh: arch/sh/kernel/setup.c needs asm/smp.h.
    
    With the platform ops migration, the definitions still need to be
    included in the CONFIG_SMP=n case, so make the asm/smp.h include
    explicit.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 29155384d5a8..14735d5ede52 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -39,6 +39,7 @@
 #include <asm/irq.h>
 #include <asm/setup.h>
 #include <asm/clock.h>
+#include <asm/smp.h>
 #include <asm/mmu_context.h>
 
 /*

commit 3366e3585fbf0d40ce6f2382b544851cf4df1654
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Mar 30 12:38:01 2010 +0900

    sh: Move platform smp ops in to their own structure.
    
    This cribs the MIPS plat_smp_ops approach for wrapping up the platform
    ops. This will allow for mixing and matching different ops on the same
    platform in the future.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 8870d6ba64bf..29155384d5a8 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -459,9 +459,7 @@ void __init setup_arch(char **cmdline_p)
 	if (likely(sh_mv.mv_setup))
 		sh_mv.mv_setup(cmdline_p);
 
-#ifdef CONFIG_SMP
 	plat_smp_setup();
-#endif
 }
 
 /* processor boot mode configuration */

commit 09e1172317d1038918c5a139ba31155610f802b5
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Mar 3 13:16:31 2010 +0900

    sh: establish PMB mappings for NUMA nodes.
    
    In the case of NUMA emulation when in range PPNs are being used for
    secondary nodes, we need to make sure that the PMB has a mapping for it
    before setting up the pgdat. This prevents the MMU from resetting.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 3459e70eed72..8870d6ba64bf 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -443,7 +443,7 @@ void __init setup_arch(char **cmdline_p)
 
 	nodes_clear(node_online_map);
 
-	/* Setup bootmem with available RAM */
+	pmb_init();
 	lmb_init();
 	setup_memory();
 	sparse_init();
@@ -452,7 +452,6 @@ void __init setup_arch(char **cmdline_p)
 	conswitchp = &dummy_con;
 #endif
 	paging_init();
-	pmb_init();
 
 	ioremap_fixed_init();
 

commit d01447b3197c2c470a14666be2c640407bbbfec7
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Feb 18 18:13:51 2010 +0900

    sh: Merge legacy and dynamic PMB modes.
    
    This implements a bit of rework for the PMB code, which permits us to
    kill off the legacy PMB mode completely. Rather than trusting the boot
    loader to do the right thing, we do a quick verification of the PMB
    contents to determine whether to have the kernel setup the initial
    mappings or whether it needs to mangle them later on instead.
    
    If we're booting from legacy mappings, the kernel will now take control
    of them and make them match the kernel's initial mapping configuration.
    This is accomplished by breaking the initialization phase out in to
    multiple steps: synchronization, merging, and resizing. With the recent
    rework, the synchronization code establishes page links for compound
    mappings already, so we build on top of this for promoting mappings and
    reclaiming unused slots.
    
    At the same time, the changes introduced for the uncached helpers also
    permit us to dynamically resize the uncached mapping without any
    particular headaches. The smallest page size is more than sufficient for
    mapping all of kernel text, and as we're careful not to jump to any far
    off locations in the setup code the mapping can safely be resized
    regardless of whether we are executing from it or not.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index e187750dd319..3459e70eed72 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -421,6 +421,8 @@ void __init setup_arch(char **cmdline_p)
 
 	parse_early_param();
 
+	uncached_init();
+
 	plat_early_device_setup();
 
 	/* Let earlyprintk output early console messages */

commit 4d35b93a66e9b87df20784fcf130d2e8760be53f
Author: Matt Fleming <matt@console-pimps.org>
Date:   Thu Nov 5 07:54:17 2009 +0000

    sh: Add fixed ioremap support
    
    Some devices need to be ioremap'd and accessed very early in the boot
    process. It is not possible to use the standard ioremap() function in
    this case because that requires kmalloc()'ing some virtual address space
    and kmalloc() may not be available so early in boot.
    
    This patch provides fixmap mappings that allow physical address ranges
    to be remapped into the kernel address space during the early boot
    stages.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index f79ebe32a24a..e187750dd319 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -449,14 +449,15 @@ void __init setup_arch(char **cmdline_p)
 #ifdef CONFIG_DUMMY_CONSOLE
 	conswitchp = &dummy_con;
 #endif
+	paging_init();
+	pmb_init();
+
+	ioremap_fixed_init();
 
 	/* Perform the machine specific initialisation */
 	if (likely(sh_mv.mv_setup))
 		sh_mv.mv_setup(cmdline_p);
 
-	paging_init();
-	pmb_init();
-
 #ifdef CONFIG_SMP
 	plat_smp_setup();
 #endif

commit a0ab36689a36e583b6e736f1c99ac8c9aebdad59
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Jan 13 18:31:48 2010 +0900

    sh: fixed PMB mode refactoring.
    
    This introduces some much overdue chainsawing of the fixed PMB support.
    fixed PMB was introduced initially to work around the fact that dynamic
    PMB mode was relatively broken, though they were never intended to
    converge. The main areas where there are differences are whether the
    system is booted in 29-bit mode or 32-bit mode, and whether legacy
    mappings are to be preserved. Any system booting in true 32-bit mode will
    not care about legacy mappings, so these are roughly decoupled.
    
    Regardless of the entry point, PMB and 32BIT are directly related as far
    as the kernel is concerned, so we also switch back to having one select
    the other.
    
    With legacy mappings iterated through and applied in the initialization
    path it's now possible to finally merge the two implementations and
    permit dynamic remapping overtop of remaining entries regardless of
    whether boot mappings are crafted by hand or inherited from the boot
    loader.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 8b0e69792cf4..f79ebe32a24a 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -455,10 +455,7 @@ void __init setup_arch(char **cmdline_p)
 		sh_mv.mv_setup(cmdline_p);
 
 	paging_init();
-
-#ifdef CONFIG_PMB_ENABLE
 	pmb_init();
-#endif
 
 #ifdef CONFIG_SMP
 	plat_smp_setup();

commit 7b6fd3bf82c4901f6ba0101ba71a5c507c24f9cf
Author: Magnus Damm <damm@opensource.se>
Date:   Mon Dec 14 10:24:42 2009 +0000

    sh-sci: Extend sh-sci driver with early console V2
    
    This is V2 of early serial console support for the sh-sci
    driver. The early serial console is using early platform
    devices and "earlyprintk". To use this feature the early
    platform devices must be broken out to one device per port
    and the desired port should be selected on the kernel command
    line like: "earlyprintk=sh-sci.N[,baudrate][,keep]"
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 5a947a2567e4..8b0e69792cf4 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -423,6 +423,9 @@ void __init setup_arch(char **cmdline_p)
 
 	plat_early_device_setup();
 
+	/* Let earlyprintk output early console messages */
+	early_platform_driver_probe("earlyprintk", 1, 1);
+
 	sh_mv_setup();
 
 	/*

commit b195e46677bed5f044bc2eede65fd41c886ef5b2
Merge: d780613acc0e 457b646189e4
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Oct 14 15:53:08 2009 +0900

    Merge branch 'sh/stable-updates'

commit 2908df9e2ce85e4de19ba81ac619acdf93a8bfaa
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Oct 14 14:13:41 2009 +0900

    sh: Tidy up SMP cpuinfo.
    
    Trivial change for cleaning up the cpuinfo pretty printing on SMP, adds a
    newline between CPUs.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index f9d44f8e0df6..99b4fb553bf1 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -549,6 +549,8 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 
 	if (cpu == 0)
 		seq_printf(m, "machine\t\t: %s\n", get_system_type());
+	else
+		seq_printf(m, "\n");
 
 	seq_printf(m, "processor\t: %d\n", cpu);
 	seq_printf(m, "cpu family\t: %s\n", init_utsname()->machine);

commit 20b5014b3e5fe7b874a3f6a1dc03b0c21cb222cd
Author: Matt Fleming <matt@console-pimps.org>
Date:   Tue Oct 6 21:22:33 2009 +0000

    sh: Fold fixed-PMB support into dynamic PMB support
    
    The initialisation process differs for CONFIG_PMB and for
    CONFIG_PMB_FIXED. For CONFIG_PMB_FIXED we need to register the PMB
    entries that were allocated by the bootloader.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 8fdd03a67680..df65fe2d43b8 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -453,7 +453,7 @@ void __init setup_arch(char **cmdline_p)
 
 	paging_init();
 
-#ifdef CONFIG_PMB
+#ifdef CONFIG_PMB_ENABLE
 	pmb_init();
 #endif
 

commit 8386aebb9e15a94137693ea4f4df84207f71cc75
Author: Matt Fleming <matt@console-pimps.org>
Date:   Tue Oct 6 21:22:28 2009 +0000

    sh: Make most PMB functions static
    
    There's no need to export the internal PMB functions for allocating,
    freeing and modifying PMB entries, etc. This way we can restrict the
    interface for PMB.
    
    Also remove the static from pmb_init() so that we have more freedom in
    setting up the initial PMB entries and turning on MMU 32bit mode.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index f9d44f8e0df6..8fdd03a67680 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -453,6 +453,10 @@ void __init setup_arch(char **cmdline_p)
 
 	paging_init();
 
+#ifdef CONFIG_PMB
+	pmb_init();
+#endif
+
 #ifdef CONFIG_SMP
 	plat_smp_setup();
 #endif

commit ac6a0cf6716bb46813d0161024c66c2af66e53d1
Merge: e76a0136a3cf ce3f7cb96e67
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Sep 1 13:54:14 2009 +0900

    Merge branch 'master' into sh/smp
    
    Conflicts:
            arch/sh/mm/cache-sh4.c

commit d724a9c9d572e092d1ce820463f082697487b874
Author: Pawel Moll <pawel.moll@st.com>
Date:   Mon Aug 24 16:25:38 2009 +0900

    sh: Allow for kernel command line concatenation.
    
    So far kernel command line arguments could be passed in by a bootloader
    or defined as CONFIG_CMDLINE, which completely overwriting the first one.
    
    This change allows a developer to declare selected kernel parameters in
    a kernel configuration (eg. project-specific defconfig), retaining
    possibility of passing others by a bootloader.
    
    The obvious examples of the first type are MTD partition or
    bigphysarea-like region definitions, while "debug" option or network
    configuration should be given by a bootloader or a JTAG boot script.
    
    Signed-off-by: Pawel Moll <pawel.moll@st.com>
    Signed-off-by: Stuart Menefy <stuart.menefy@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 212e6bddaeb8..d13bbafb4e1b 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -404,10 +404,14 @@ void __init setup_arch(char **cmdline_p)
 	if (!memory_end)
 		memory_end = memory_start + __MEMORY_SIZE;
 
-#ifdef CONFIG_CMDLINE_BOOL
+#ifdef CONFIG_CMDLINE_OVERWRITE
 	strlcpy(command_line, CONFIG_CMDLINE, sizeof(command_line));
 #else
 	strlcpy(command_line, COMMAND_LINE, sizeof(command_line));
+#ifdef CONFIG_CMDLINE_EXTEND
+	strlcat(command_line, " ", sizeof(command_line));
+	strlcat(command_line, CONFIG_CMDLINE, sizeof(command_line));
+#endif
 #endif
 
 	/* Save unparsed command line copy for /proc/cmdline */

commit c01f0f1a4a96eb3acc5850e18cc43f24366966d0
Author: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
Date:   Fri Aug 21 16:30:28 2009 +0900

    sh: Add initial support for SH7757 CPU subtype
    
    Signed-off-by: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index ceb409bf7741..212e6bddaeb8 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -481,7 +481,7 @@ static const char *cpu_name[] = {
 	[CPU_SH7763]	= "SH7763",	[CPU_SH7770]	= "SH7770",
 	[CPU_SH7780]	= "SH7780",	[CPU_SH7781]	= "SH7781",
 	[CPU_SH7343]	= "SH7343",	[CPU_SH7785]	= "SH7785",
-	[CPU_SH7786]	= "SH7786",
+	[CPU_SH7786]	= "SH7786",	[CPU_SH7757]	= "SH7757",
 	[CPU_SH7722]	= "SH7722",	[CPU_SHX3]	= "SH-X3",
 	[CPU_SH5_101]	= "SH5-101",	[CPU_SH5_103]	= "SH5-103",
 	[CPU_MXG]	= "MX-G",	[CPU_SH7723]	= "SH7723",

commit e82da214d2fe3dc2610df966100c4f36bc0fad91
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sat Aug 15 10:48:13 2009 +0900

    sh: Track the CPU family in sh_cpuinfo.
    
    This adds a family member to struct sh_cpuinfo, which allows us to fall
    back more on the probe routines to work out what sort of subtype we are
    running on. This will be used by the CPU cache initialization code in
    order to first do family-level initialization, followed by subtype-level
    optimizations.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index ceb409bf7741..dc403e42bcab 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -49,6 +49,7 @@
 struct sh_cpuinfo cpu_data[NR_CPUS] __read_mostly = {
 	[0] = {
 		.type			= CPU_SH_NONE,
+		.family			= CPU_FAMILY_UNKNOWN,
 		.loops_per_jiffy	= 10000000,
 	},
 };

commit c601a51af10f714292f42eab45fa8c9154dc1414
Author: Matt Fleming <matt@console-pimps.org>
Date:   Fri Jul 3 16:16:54 2009 +0900

    sh: Use bootmem ontop of lmb
    
    Rework the bootmem allocator to use the lmb framework.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index dd38338553ef..ceb409bf7741 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -30,6 +30,7 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/platform_device.h>
+#include <linux/lmb.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/page.h>
@@ -233,39 +234,45 @@ void __init __add_active_range(unsigned int nid, unsigned long start_pfn,
 void __init setup_bootmem_allocator(unsigned long free_pfn)
 {
 	unsigned long bootmap_size;
+	unsigned long bootmap_pages, bootmem_paddr;
+	u64 total_pages = (lmb_end_of_DRAM() - __MEMORY_START) >> PAGE_SHIFT;
+	int i;
+
+	bootmap_pages = bootmem_bootmap_pages(total_pages);
+
+	bootmem_paddr = lmb_alloc(bootmap_pages << PAGE_SHIFT, PAGE_SIZE);
 
 	/*
 	 * Find a proper area for the bootmem bitmap. After this
 	 * bootstrap step all allocations (until the page allocator
 	 * is intact) must be done via bootmem_alloc().
 	 */
-	bootmap_size = init_bootmem_node(NODE_DATA(0), free_pfn,
+	bootmap_size = init_bootmem_node(NODE_DATA(0),
+					 bootmem_paddr >> PAGE_SHIFT,
 					 min_low_pfn, max_low_pfn);
 
-	__add_active_range(0, min_low_pfn, max_low_pfn);
-	register_bootmem_low_pages();
-
-	node_set_online(0);
+	/* Add active regions with valid PFNs. */
+	for (i = 0; i < lmb.memory.cnt; i++) {
+		unsigned long start_pfn, end_pfn;
+		start_pfn = lmb.memory.region[i].base >> PAGE_SHIFT;
+		end_pfn = start_pfn + lmb_size_pages(&lmb.memory, i);
+		__add_active_range(0, start_pfn, end_pfn);
+	}
 
 	/*
-	 * Reserve the kernel text and
-	 * Reserve the bootmem bitmap. We do this in two steps (first step
-	 * was init_bootmem()), because this catches the (definitely buggy)
-	 * case of us accidentally initializing the bootmem allocator with
-	 * an invalid RAM area.
+	 * Add all physical memory to the bootmem map and mark each
+	 * area as present.
 	 */
-	reserve_bootmem(__MEMORY_START + CONFIG_ZERO_PAGE_OFFSET,
-			(PFN_PHYS(free_pfn) + bootmap_size + PAGE_SIZE - 1) -
-			(__MEMORY_START + CONFIG_ZERO_PAGE_OFFSET),
-			BOOTMEM_DEFAULT);
+	register_bootmem_low_pages();
 
-	/*
-	 * Reserve physical pages below CONFIG_ZERO_PAGE_OFFSET.
-	 */
-	if (CONFIG_ZERO_PAGE_OFFSET != 0)
-		reserve_bootmem(__MEMORY_START, CONFIG_ZERO_PAGE_OFFSET,
+	/* Reserve the sections we're already using. */
+	for (i = 0; i < lmb.reserved.cnt; i++)
+		reserve_bootmem(lmb.reserved.region[i].base,
+				lmb_size_bytes(&lmb.reserved, i),
 				BOOTMEM_DEFAULT);
 
+	node_set_online(0);
+
 	sparse_memory_present_with_active_regions(0);
 
 #ifdef CONFIG_BLK_DEV_INITRD
@@ -296,12 +303,37 @@ void __init setup_bootmem_allocator(unsigned long free_pfn)
 static void __init setup_memory(void)
 {
 	unsigned long start_pfn;
+	u64 base = min_low_pfn << PAGE_SHIFT;
+	u64 size = (max_low_pfn << PAGE_SHIFT) - base;
 
 	/*
 	 * Partially used pages are not usable - thus
 	 * we are rounding upwards:
 	 */
 	start_pfn = PFN_UP(__pa(_end));
+
+	lmb_add(base, size);
+
+	/*
+	 * Reserve the kernel text and
+	 * Reserve the bootmem bitmap. We do this in two steps (first step
+	 * was init_bootmem()), because this catches the (definitely buggy)
+	 * case of us accidentally initializing the bootmem allocator with
+	 * an invalid RAM area.
+	 */
+	lmb_reserve(__MEMORY_START + CONFIG_ZERO_PAGE_OFFSET,
+		    (PFN_PHYS(start_pfn) + PAGE_SIZE - 1) -
+		    (__MEMORY_START + CONFIG_ZERO_PAGE_OFFSET));
+
+	/*
+	 * Reserve physical pages below CONFIG_ZERO_PAGE_OFFSET.
+	 */
+	if (CONFIG_ZERO_PAGE_OFFSET != 0)
+		lmb_reserve(__MEMORY_START, CONFIG_ZERO_PAGE_OFFSET);
+
+	lmb_analyze();
+	lmb_dump_all();
+
 	setup_bootmem_allocator(start_pfn);
 }
 #else
@@ -402,6 +434,7 @@ void __init setup_arch(char **cmdline_p)
 	nodes_clear(node_online_map);
 
 	/* Setup bootmem with available RAM */
+	lmb_init();
 	setup_memory();
 	sparse_init();
 

commit 0d4fdbb64f472ef31195714993f1263f77cf85ca
Author: Magnus Damm <damm@igel.co.jp>
Date:   Tue Jun 2 09:22:02 2009 +0000

    sh: rework mode pin code
    
    This patch reworks the mode pin code to keep the pin
    definitions in one place. The mode pins values are now
    the value of the bit instead of bit number.
    
    With this patch in place the sh7785 header file contains
    mode pin comments. The sh7785 clock code and the sh7785lcr
    board code are updated to reflect the new shared mode pins.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 050131eec773..dd38338553ef 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -429,7 +429,7 @@ int generic_mode_pins(void)
 
 int test_mode_pin(int pin)
 {
-	return sh_mv.mv_mode_pins() & (1 << pin);
+	return sh_mv.mv_mode_pins() & pin;
 }
 
 static const char *cpu_name[] = {

commit eb9b9b56eed280e65a9e194aaeb50a5a75111859
Author: Magnus Damm <damm@igel.co.jp>
Date:   Thu May 28 11:51:51 2009 +0000

    sh: boot word / mode pin support V2
    
    Add mode pin support for the SuperH architecture V2.
    
    With this patch applied the board code can add their
    own function to export the cpu mode pin configuration.
    In most cases this will be a constant bitmap, but
    boards that allow reading this from a register can
    instead read out the pin state from hardware.
    
    The code warns if a pin is tested but no board specific
    mode pin function has been provided.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 00086b234278..050131eec773 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -420,6 +420,18 @@ void __init setup_arch(char **cmdline_p)
 #endif
 }
 
+/* processor boot mode configuration */
+int generic_mode_pins(void)
+{
+	pr_warning("generic_mode_pins(): missing mode pin configuration\n");
+	return 0;
+}
+
+int test_mode_pin(int pin)
+{
+	return sh_mv.mv_mode_pins() & (1 << pin);
+}
+
 static const char *cpu_name[] = {
 	[CPU_SH7201]	= "SH7201",
 	[CPU_SH7203]	= "SH7203",	[CPU_SH7263]	= "SH7263",

commit 7b551f9daa9bd9533ba4ce31622ed4be1dd97d3e
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri May 8 22:14:01 2009 +0900

    sh: Kill off the GENERIC_CALIBRATE_DELAY ifndef.
    
    Now that everyone is using the clock framework directly and we
    unconditionally provide our own calibrate_delay() function, having it
    wrapped in an ifndef is no longer useful. So, kill it off.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 38515a795920..00086b234278 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -156,7 +156,7 @@ static void __init reserve_crashkernel(void)
 			&crash_size, &crash_base);
 	if (ret == 0 && crash_size) {
 		if (crash_base <= 0) {
-			vp = alloc_bootmem_nopanic(crash_size); 
+			vp = alloc_bootmem_nopanic(crash_size);
 			if (!vp) {
 				printk(KERN_INFO "crashkernel allocation "
 				       "failed\n");
@@ -185,7 +185,6 @@ static inline void __init reserve_crashkernel(void)
 {}
 #endif
 
-#ifndef CONFIG_GENERIC_CALIBRATE_DELAY
 void __cpuinit calibrate_delay(void)
 {
 	struct clk *clk = clk_get(NULL, "cpu_clk");
@@ -201,7 +200,6 @@ void __cpuinit calibrate_delay(void)
 			 (loops_per_jiffy/(5000/HZ)) % 100,
 			 loops_per_jiffy);
 }
-#endif
 
 void __init __add_active_range(unsigned int nid, unsigned long start_pfn,
 						unsigned long end_pfn)

commit 22fd67c5c94a188ded2bb7c78369fd751d1bb187
Merge: b8c193f88ebd 28fde6863e6e bc9f3d4291f8
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Sun Apr 19 13:08:33 2009 +0900

    Merge branches 'sh/earlytimer' and 'sh/shmobile-r2r-staging'

commit 87a00dc059e3af46303f1f56b0e8df41af988c7b
Author: Magnus Damm <damm@igel.co.jp>
Date:   Wed Apr 15 10:50:21 2009 +0000

    sh: Add plat_early_device_setup()
    
    Add a plat_early_device_setup() function to allow
    processor-specific code to register Early Platform Data.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 04a6004fccc4..22b976d42014 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -29,6 +29,7 @@
 #include <linux/mmzone.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
+#include <linux/platform_device.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/page.h>
@@ -328,6 +329,10 @@ static int __init parse_elfcorehdr(char *arg)
 early_param("elfcorehdr", parse_elfcorehdr);
 #endif
 
+void __init __attribute__ ((weak)) plat_early_device_setup(void)
+{
+}
+
 void __init setup_arch(char **cmdline_p)
 {
 	enable_mmu();
@@ -381,6 +386,8 @@ void __init setup_arch(char **cmdline_p)
 
 	parse_early_param();
 
+	plat_early_device_setup();
+
 	sh_mv_setup();
 
 	/*

commit 0207a2efb43d81e29e23662b5d035945688a103f
Author: Kuninori Morimoto <morimoto.kuninori@renesas.com>
Date:   Thu Apr 16 14:40:56 2009 +0900

    sh: Add support for SH7724 (SH-Mobile R2R) CPU subtype.
    
    This implements initial support for the SH-Mobile R2R CPU.
    Based on Rev 0.11 of the initial SH7724 hardware manual.
    
    Signed-off-by: Kuninori Morimoto <morimoto.kuninori@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 04a6004fccc4..0e6ed804546e 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -435,7 +435,8 @@ static const char *cpu_name[] = {
 	[CPU_SH7722]	= "SH7722",	[CPU_SHX3]	= "SH-X3",
 	[CPU_SH5_101]	= "SH5-101",	[CPU_SH5_103]	= "SH5-103",
 	[CPU_MXG]	= "MX-G",	[CPU_SH7723]	= "SH7723",
-	[CPU_SH7366]	= "SH7366",	[CPU_SH_NONE]	= "Unknown"
+	[CPU_SH7366]	= "SH7366",	[CPU_SH7724]	= "SH7724",
+	[CPU_SH_NONE]	= "Unknown"
 };
 
 const char *get_cpu_subtype(struct sh_cpuinfo *c)

commit 0bd4781d40ffc3bff939a2540041144b99c373b8
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Mar 31 08:25:54 2009 +0900

    sh: Fix up -Wformat-security whining.
    
    Triggers -Werror on gcc-4.3:
    
    arch/sh/kernel/setup.c: In function 'early_parse_mem':
    arch/sh/kernel/setup.c:111: error: format not a string literal and no format arguments
    ...
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 24c60251f680..04a6004fccc4 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -103,12 +103,11 @@ static int __init early_parse_mem(char *p)
 	size = memparse(p, &p);
 
 	if (size > __MEMORY_SIZE) {
-		static char msg[] __initdata = KERN_ERR
+		printk(KERN_ERR
 			"Using mem= to increase the size of kernel memory "
 			"is not allowed.\n"
 			"  Recompile the kernel with the correct value for "
-			"CONFIG_MEMORY_SIZE.\n";
-		printk(msg);
+			"CONFIG_MEMORY_SIZE.\n");
 		return 0;
 	}
 

commit 8263a67e169fdf0d06d172acbf6c03ae172a69d4
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Mar 17 17:49:49 2009 +0900

    sh: Support for extended ASIDs on PTEAEX-capable SH-X3 cores.
    
    This adds support for extended ASIDs (up to 16-bits) on newer SH-X3 cores
    that implement the PTAEX register and respective functionality. Presently
    only the 65nm SH7786 (90nm only supports legacy 8-bit ASIDs).
    
    The main change is in how the PTE is written out when loading the entry
    in to the TLB, as well as in how the TLB entry is selectively flushed.
    
    While SH-X2 extended mode splits out the memory-mapped U and I-TLB data
    arrays for extra bits, extended ASID mode splits out the address arrays.
    While we don't use the memory-mapped data array access, the address
    array accesses are necessary for selective TLB flushes, so these are
    implemented newly and replace the generic SH-4 implementation.
    
    With this, TLB flushes in switch_mm() are almost non-existent on newer
    parts.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 61ab2a7f8647..24c60251f680 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -449,7 +449,7 @@ EXPORT_SYMBOL(get_cpu_subtype);
 /* Symbolic CPU flags, keep in sync with asm/cpu-features.h */
 static const char *cpu_flags[] = {
 	"none", "fpu", "p2flush", "mmuassoc", "dsp", "perfctr",
-	"ptea", "llsc", "l2", "op32", NULL
+	"ptea", "llsc", "l2", "op32", "pteaex", NULL
 };
 
 static void show_cpuflags(struct seq_file *m, struct sh_cpuinfo *c)

commit 55ba99eb211a06709237cb322ecd8c8b6faf6159
Author: Kuninori Morimoto <morimoto.kuninori@renesas.com>
Date:   Tue Mar 3 15:40:25 2009 +0900

    sh: Add support for SH7786 CPU subtype.
    
    This adds preliminary support for the SH7786 CPU subtype.
    
    While this is a dual-core CPU, only UP is supported for now. L2 cache
    support is likewise not yet implemented.
    
    More information on this particular CPU subtype is available at:
    
            http://www.renesas.com/fmwk.jsp?cnt=sh7786_root.jsp&fp=/products/mpumcu/superh_family/sh7780_series/sh7786_group/
    
    Signed-off-by: Kuninori Morimoto <morimoto.kuninori@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 370d2cfa34eb..61ab2a7f8647 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -432,6 +432,7 @@ static const char *cpu_name[] = {
 	[CPU_SH7763]	= "SH7763",	[CPU_SH7770]	= "SH7770",
 	[CPU_SH7780]	= "SH7780",	[CPU_SH7781]	= "SH7781",
 	[CPU_SH7343]	= "SH7343",	[CPU_SH7785]	= "SH7785",
+	[CPU_SH7786]	= "SH7786",
 	[CPU_SH7722]	= "SH7722",	[CPU_SHX3]	= "SH-X3",
 	[CPU_SH5_101]	= "SH5-101",	[CPU_SH5_103]	= "SH5-103",
 	[CPU_MXG]	= "MX-G",	[CPU_SH7723]	= "SH7723",

commit 48865163109690ed988e2d98d6f258ec743c94c7
Author: Christopher SMITH <chris.smith@st.com>
Date:   Mon Oct 6 12:46:18 2008 +0100

    sh: Only reserve memory under CONFIG_ZERO_PAGE_OFFSET when it != 0.
    
    Signed-off-by: Chris Smith <chris.smith@st.com>
    Signed-off-by: Stuart Menefy <stuart.menefy@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 534247508572..370d2cfa34eb 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -262,11 +262,11 @@ void __init setup_bootmem_allocator(unsigned long free_pfn)
 			BOOTMEM_DEFAULT);
 
 	/*
-	 * reserve physical page 0 - it's a special BIOS page on many boxes,
-	 * enabling clean reboots, SMP operation, laptop functions.
+	 * Reserve physical pages below CONFIG_ZERO_PAGE_OFFSET.
 	 */
-	reserve_bootmem(__MEMORY_START, CONFIG_ZERO_PAGE_OFFSET,
-			BOOTMEM_DEFAULT);
+	if (CONFIG_ZERO_PAGE_OFFSET != 0)
+		reserve_bootmem(__MEMORY_START, CONFIG_ZERO_PAGE_OFFSET,
+				BOOTMEM_DEFAULT);
 
 	sparse_memory_present_with_active_regions(0);
 

commit 2825999e8a9bd7ab7e25a7e7475c7cdd10371a13
Author: Peter Griffin <pgriffin@mpc-data.co.uk>
Date:   Fri Nov 28 22:48:20 2008 +0900

    sh: Add support for SH7201 CPU subtype.
    
    This patch adds support for the SH-2A FPU based SH7201 processor subtype.
    
    Signed-off-by: Peter Griffin <pgriffin@mpc-data.co.uk>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index e7152cc6930e..534247508572 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -417,6 +417,7 @@ void __init setup_arch(char **cmdline_p)
 }
 
 static const char *cpu_name[] = {
+	[CPU_SH7201]	= "SH7201",
 	[CPU_SH7203]	= "SH7203",	[CPU_SH7263]	= "SH7263",
 	[CPU_SH7206]	= "SH7206",	[CPU_SH7619]	= "SH7619",
 	[CPU_SH7705]	= "SH7705",	[CPU_SH7706]	= "SH7706",

commit 4aeaa223433355a281559033f1e7600bfd73238e
Author: Magnus Damm <damm@igel.co.jp>
Date:   Thu Oct 9 18:42:55 2008 +0900

    sh: add dynamic crash base address support
    
    Add support for dynamic crash kernel base address.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 5767f0a84cd7..e7152cc6930e 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -147,6 +147,7 @@ static void __init reserve_crashkernel(void)
 {
 	unsigned long long free_mem;
 	unsigned long long crash_size, crash_base;
+	void *vp;
 	int ret;
 
 	free_mem = ((unsigned long long)max_low_pfn - min_low_pfn) << PAGE_SHIFT;
@@ -155,12 +156,14 @@ static void __init reserve_crashkernel(void)
 			&crash_size, &crash_base);
 	if (ret == 0 && crash_size) {
 		if (crash_base <= 0) {
-			printk(KERN_INFO "crashkernel reservation failed - "
-					"you have to specify a base address\n");
-			return;
-		}
-
-		if (reserve_bootmem(crash_base, crash_size,
+			vp = alloc_bootmem_nopanic(crash_size); 
+			if (!vp) {
+				printk(KERN_INFO "crashkernel allocation "
+				       "failed\n");
+				return;
+			}
+			crash_base = __pa(vp);
+		} else if (reserve_bootmem(crash_base, crash_size,
 					BOOTMEM_EXCLUSIVE) < 0) {
 			printk(KERN_INFO "crashkernel reservation failed - "
 					"memory is in use\n");

commit 9a19eb2a6607f2f6329efb3c4637fe23afae2cd7
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Oct 20 11:37:58 2008 +0900

    sh: Fix up some merge damage.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 836e80d5cb9f..5767f0a84cd7 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -282,7 +282,7 @@ void __init setup_bootmem_allocator(unsigned long free_pfn)
 			printk("initrd extends beyond end of memory "
 			       "(0x%08lx > 0x%08lx)\ndisabling initrd\n",
 			       initrd_start_phys + INITRD_SIZE,
-			       PFN_PHYS(max_low_pfn));
+			       (unsigned long)PFN_PHYS(max_low_pfn));
 			initrd_start = 0;
 		}
 	}

commit 9986b311efdc9727a5a48f03c3dac3d536fbaa74
Author: Zhaolei <zhaolei@cn.fujitsu.com>
Date:   Fri Oct 17 19:25:03 2008 +0800

    Fix debugfs_create_dir's error checking method for arch/sh/kernel/
    
    debugfs_create_dir() returns NULL if an error occurs, returns -ENODEV
    when debugfs is not enabled in the kernel.
    
    Signed-off-by: Zhao Lei <zhaolei@cn.fujitsu.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 267b344099c0..836e80d5cb9f 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -554,6 +554,8 @@ struct dentry *sh_debugfs_root;
 static int __init sh_debugfs_init(void)
 {
 	sh_debugfs_root = debugfs_create_dir("sh", NULL);
+	if (!sh_debugfs_root)
+		return -ENOMEM;
 	if (IS_ERR(sh_debugfs_root))
 		return PTR_ERR(sh_debugfs_root);
 

commit cf204fa797cf968de8043491cd469ad0321d0940
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Sep 8 20:47:42 2008 +0900

    sh: Derive calibrate_delay lpj from clk fwk.
    
    All CPUs must have a sensible cpu_clk definition these days, which we can
    safely use for deriving the preset loops_per_jiffy. The only odd one out
    is SH-5, which hasn't been hammered in to the framework yet.
    
    Based on the ST patch.
    
    Signed-off-by: Francesco Virlinzi <francesco.virlinzi@st.com>
    Signed-off-by: Carl Shaw <carl.shaw@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index fc098c8af052..267b344099c0 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -27,6 +27,8 @@
 #include <linux/debugfs.h>
 #include <linux/crash_dump.h>
 #include <linux/mmzone.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/page.h>
@@ -180,6 +182,24 @@ static inline void __init reserve_crashkernel(void)
 {}
 #endif
 
+#ifndef CONFIG_GENERIC_CALIBRATE_DELAY
+void __cpuinit calibrate_delay(void)
+{
+	struct clk *clk = clk_get(NULL, "cpu_clk");
+
+	if (IS_ERR(clk))
+		panic("Need a sane CPU clock definition!");
+
+	loops_per_jiffy = (clk_get_rate(clk) >> 1) / HZ;
+
+	printk(KERN_INFO "Calibrating delay loop (skipped)... "
+			 "%lu.%02lu BogoMIPS PRESET (lpj=%lu)\n",
+			 loops_per_jiffy/(500000/HZ),
+			 (loops_per_jiffy/(5000/HZ)) % 100,
+			 loops_per_jiffy);
+}
+#endif
+
 void __init __add_active_range(unsigned int nid, unsigned long start_pfn,
 						unsigned long end_pfn)
 {

commit f040ddaf4cfd28f25ea9d6a42d3c734d5c3f6798
Author: Stuart Menefy <stuart.menefy@st.com>
Date:   Fri Sep 5 16:29:40 2008 +0900

    sh: Fix an unusual memory initialisation error.
    
    This fixes a problems with the set up of Linux memory:
    
     - When reserving memory at boot time, the code previously reserved
       the bottom page of memory, and then from one page up to the end of
       the bootmap. This had the desired effect, but was strictly speaking
       wrong, as the one page was actually whatever CONFIG_ZERO_PAGE_OFFSET
       had been set to.
    
    Signed-off-by: Stuart Menefy <stuart.menefy@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index fc7171a9c804..fc098c8af052 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -233,15 +233,17 @@ void __init setup_bootmem_allocator(unsigned long free_pfn)
 	 * case of us accidentally initializing the bootmem allocator with
 	 * an invalid RAM area.
 	 */
-	reserve_bootmem(__MEMORY_START+PAGE_SIZE,
-		(PFN_PHYS(free_pfn)+bootmap_size+PAGE_SIZE-1)-__MEMORY_START,
-		BOOTMEM_DEFAULT);
+	reserve_bootmem(__MEMORY_START + CONFIG_ZERO_PAGE_OFFSET,
+			(PFN_PHYS(free_pfn) + bootmap_size + PAGE_SIZE - 1) -
+			(__MEMORY_START + CONFIG_ZERO_PAGE_OFFSET),
+			BOOTMEM_DEFAULT);
 
 	/*
 	 * reserve physical page 0 - it's a special BIOS page on many boxes,
 	 * enabling clean reboots, SMP operation, laptop functions.
 	 */
-	reserve_bootmem(__MEMORY_START, PAGE_SIZE, BOOTMEM_DEFAULT);
+	reserve_bootmem(__MEMORY_START, CONFIG_ZERO_PAGE_OFFSET,
+			BOOTMEM_DEFAULT);
 
 	sparse_memory_present_with_active_regions(0);
 

commit 28d6e52cf7e881834d2dab370afa20b6223f726c
Author: Stuart Menefy <stuart.menefy@st.com>
Date:   Fri Sep 5 16:14:17 2008 +0900

    sh: Fix up broken 32-bit initrd support.
    
    Signed-off-by: Stuart Menefy <stuart.menefy@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 6d0899e890d0..fc7171a9c804 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -249,17 +249,18 @@ void __init setup_bootmem_allocator(unsigned long free_pfn)
 	ROOT_DEV = Root_RAM0;
 
 	if (LOADER_TYPE && INITRD_START) {
-		if (INITRD_START + INITRD_SIZE <= (max_low_pfn << PAGE_SHIFT)) {
-			reserve_bootmem(INITRD_START + __MEMORY_START,
-					INITRD_SIZE, BOOTMEM_DEFAULT);
-			initrd_start = INITRD_START + PAGE_OFFSET +
-					__MEMORY_START;
+		unsigned long initrd_start_phys = INITRD_START + __MEMORY_START;
+
+		if (initrd_start_phys + INITRD_SIZE <= PFN_PHYS(max_low_pfn)) {
+			reserve_bootmem(initrd_start_phys, INITRD_SIZE,
+					BOOTMEM_DEFAULT);
+			initrd_start = (unsigned long)__va(initrd_start_phys);
 			initrd_end = initrd_start + INITRD_SIZE;
 		} else {
 			printk("initrd extends beyond end of memory "
-			    "(0x%08lx > 0x%08lx)\ndisabling initrd\n",
-				    INITRD_START + INITRD_SIZE,
-				    max_low_pfn << PAGE_SHIFT);
+			       "(0x%08lx > 0x%08lx)\ndisabling initrd\n",
+			       initrd_start_phys + INITRD_SIZE,
+			       PFN_PHYS(max_low_pfn));
 			initrd_start = 0;
 		}
 	}

commit fa43972fab24a3c050e880a7831f9378c6cebc0b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Sep 4 18:53:58 2008 +0900

    sh: fixup many sparse errors.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index de832056bf1b..6d0899e890d0 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -26,6 +26,7 @@
 #include <linux/err.h>
 #include <linux/debugfs.h>
 #include <linux/crash_dump.h>
+#include <linux/mmzone.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/page.h>

commit 34894c7843e00972d88b3592027703d4e05a06a7
Author: Magnus Damm <damm@igel.co.jp>
Date:   Wed Aug 27 18:15:43 2008 +0900

    sh: crash kernel resource fix
    
    The reserved crash kernel memory range is currently missing from
    /proc/iomem. crashk_res is mistakenly setup after __add_active_range().
    Reorder things to make sure the resource shows up in /proc/iomem.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index a35207655e7b..de832056bf1b 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -171,6 +171,7 @@ static void __init reserve_crashkernel(void)
 				(unsigned long)(free_mem >> 20));
 		crashk_res.start = crash_base;
 		crashk_res.end   = crash_base + crash_size - 1;
+		insert_resource(&iomem_resource, &crashk_res);
 	}
 }
 #else
@@ -204,11 +205,6 @@ void __init __add_active_range(unsigned int nid, unsigned long start_pfn,
 	request_resource(res, &data_resource);
 	request_resource(res, &bss_resource);
 
-#ifdef CONFIG_KEXEC
-	if (crashk_res.start != crashk_res.end)
-		request_resource(res, &crashk_res);
-#endif
-
 	add_active_range(nid, start_pfn, end_pfn);
 }
 

commit daf423db3b6afd90ecdd776dbc32c0b57cc78edb
Author: Simon Horman <horms@verge.net.au>
Date:   Wed Jul 30 10:29:39 2008 +1000

    kdump: sh: parse elfcorehdr command line argument
    
    A quick cut and paste from other architectures to allow SH
    to parse the elfcorehdr command line argument which is required
    for both is_kdump_kernel() and vmcore to function.
    (the former is as yet unused on SH).
    
    Tested compilation only
    
    Signed-off-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 6339d0c95715..a35207655e7b 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -25,6 +25,7 @@
 #include <linux/smp.h>
 #include <linux/err.h>
 #include <linux/debugfs.h>
+#include <linux/crash_dump.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/page.h>
@@ -286,6 +287,25 @@ static void __init setup_memory(void)
 extern void __init setup_memory(void);
 #endif
 
+/*
+ * Note: elfcorehdr_addr is not just limited to vmcore. It is also used by
+ * is_kdump_kernel() to determine if we are booting after a panic. Hence
+ * ifdef it under CONFIG_CRASH_DUMP and not CONFIG_PROC_VMCORE.
+ */
+#ifdef CONFIG_CRASH_DUMP
+/* elfcorehdr= specifies the location of elf core header
+ * stored by the crashed kernel.
+ */
+static int __init parse_elfcorehdr(char *arg)
+{
+	if (!arg)
+		return -EINVAL;
+	elfcorehdr_addr = memparse(arg, &arg);
+	return 0;
+}
+early_param("elfcorehdr", parse_elfcorehdr);
+#endif
+
 void __init setup_arch(char **cmdline_p)
 {
 	enable_mmu();

commit 3611ee7acc113e5e482b7d20d5133935226f3129
Author: Stuart Menefy <stuart.menefy@st.com>
Date:   Wed Jul 2 15:15:09 2008 +0900

    sh: Stub in silicon cut in CPU info.
    
    Signed-off-by: Stuart Menefy <stuart.menefy@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 9324cb91fd35..6339d0c95715 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -453,6 +453,12 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 	seq_printf(m, "processor\t: %d\n", cpu);
 	seq_printf(m, "cpu family\t: %s\n", init_utsname()->machine);
 	seq_printf(m, "cpu type\t: %s\n", get_cpu_subtype(c));
+	if (c->cut_major == -1)
+		seq_printf(m, "cut\t\t: unknown\n");
+	else if (c->cut_minor == -1)
+		seq_printf(m, "cut\t\t: %d.x\n", c->cut_major);
+	else
+		seq_printf(m, "cut\t\t: %d.%d\n", c->cut_major, c->cut_minor);
 
 	show_cpuflags(m, c);
 

commit b19a33cabafbac56ba581e2a77ea6476db9118ab
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Jun 18 01:30:24 2008 +0300

    sh: export get_cpu_subtype
    
    This patch fixes the following build error:
    
    <--  snip  -->
    
    ...
      MODPOST 1837 modules
    ERROR: "get_cpu_subtype" [arch/sh/oprofile/oprofile.ko] undefined!
    ...
    make[2]: *** [__modpost] Error 1
    
    <--  snip  -->
    
    Reported-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index bca2bbc575db..9324cb91fd35 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -398,6 +398,7 @@ const char *get_cpu_subtype(struct sh_cpuinfo *c)
 {
 	return cpu_name[c->type];
 }
+EXPORT_SYMBOL(get_cpu_subtype);
 
 #ifdef CONFIG_PROC_FS
 /* Symbolic CPU flags, keep in sync with asm/cpu-features.h */

commit 0105346cc763a6e34e80feb6adb36ed9781150d4
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 13 17:40:17 2008 +0900

    sh: display boot params by default on entry.
    
    Some kernel and boot loader configurations tweak the .empty_zero_page
    settings, while others do not. Print the values out on entry as a
    debugging aid.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 516bde9c50fa..bca2bbc575db 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -292,6 +292,17 @@ void __init setup_arch(char **cmdline_p)
 
 	ROOT_DEV = old_decode_dev(ORIG_ROOT_DEV);
 
+	printk(KERN_NOTICE "Boot params:\n"
+			   "... MOUNT_ROOT_RDONLY - %08lx\n"
+			   "... RAMDISK_FLAGS     - %08lx\n"
+			   "... ORIG_ROOT_DEV     - %08lx\n"
+			   "... LOADER_TYPE       - %08lx\n"
+			   "... INITRD_START      - %08lx\n"
+			   "... INITRD_SIZE       - %08lx\n",
+			   MOUNT_ROOT_RDONLY, RAMDISK_FLAGS,
+			   ORIG_ROOT_DEV, LOADER_TYPE,
+			   INITRD_START, INITRD_SIZE);
+
 #ifdef CONFIG_BLK_DEV_RAM
 	rd_image_start = RAMDISK_FLAGS & RAMDISK_IMAGE_START_MASK;
 	rd_prompt = ((RAMDISK_FLAGS & RAMDISK_PROMPT_FLAG) != 0);

commit 0146ba78b9339c27ed12545f9bdc208604354bb3
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Wed Apr 23 20:56:44 2008 +0900

    sh: add memory resources to /proc/iomem
    
    Add physical memory resources such as System RAM, Kernel code/data/bss
    and reserved crash dump area to /proc/iomem. Same strategy as on x86.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index c9fb912a78e2..516bde9c50fa 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -87,6 +87,8 @@ EXPORT_SYMBOL(memory_start);
 unsigned long memory_end = 0;
 EXPORT_SYMBOL(memory_end);
 
+static struct resource mem_resources[MAX_NUMNODES];
+
 int l1i_cache_shape, l1d_cache_shape, l2_cache_shape;
 
 static int __init early_parse_mem(char *p)
@@ -175,6 +177,40 @@ static inline void __init reserve_crashkernel(void)
 {}
 #endif
 
+void __init __add_active_range(unsigned int nid, unsigned long start_pfn,
+						unsigned long end_pfn)
+{
+	struct resource *res = &mem_resources[nid];
+
+	WARN_ON(res->name); /* max one active range per node for now */
+
+	res->name = "System RAM";
+	res->start = start_pfn << PAGE_SHIFT;
+	res->end = (end_pfn << PAGE_SHIFT) - 1;
+	res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+	if (request_resource(&iomem_resource, res)) {
+		pr_err("unable to request memory_resource 0x%lx 0x%lx\n",
+		       start_pfn, end_pfn);
+		return;
+	}
+
+	/*
+	 *  We don't know which RAM region contains kernel data,
+	 *  so we try it repeatedly and let the resource manager
+	 *  test it.
+	 */
+	request_resource(res, &code_resource);
+	request_resource(res, &data_resource);
+	request_resource(res, &bss_resource);
+
+#ifdef CONFIG_KEXEC
+	if (crashk_res.start != crashk_res.end)
+		request_resource(res, &crashk_res);
+#endif
+
+	add_active_range(nid, start_pfn, end_pfn);
+}
+
 void __init setup_bootmem_allocator(unsigned long free_pfn)
 {
 	unsigned long bootmap_size;
@@ -187,7 +223,7 @@ void __init setup_bootmem_allocator(unsigned long free_pfn)
 	bootmap_size = init_bootmem_node(NODE_DATA(0), free_pfn,
 					 min_low_pfn, max_low_pfn);
 
-	add_active_range(0, min_low_pfn, max_low_pfn);
+	__add_active_range(0, min_low_pfn, max_low_pfn);
 	register_bootmem_low_pages();
 
 	node_set_online(0);

commit 3d83984e99d80672b1d2e3c7dfdd393631883428
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Wed Apr 23 20:50:27 2008 +0900

    sh: add kernel bss resource
    
    Do like everyone else and have a struct resource for kernel bss.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index fc5b22edc0c2..c9fb912a78e2 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -77,6 +77,11 @@ static struct resource data_resource = {
 	.flags = IORESOURCE_BUSY | IORESOURCE_MEM,
 };
 
+static struct resource bss_resource = {
+	.name	= "Kernel bss",
+	.flags	= IORESOURCE_BUSY | IORESOURCE_MEM,
+};
+
 unsigned long memory_start;
 EXPORT_SYMBOL(memory_start);
 unsigned long memory_end = 0;
@@ -268,6 +273,8 @@ void __init setup_arch(char **cmdline_p)
 	code_resource.end = virt_to_phys(_etext)-1;
 	data_resource.start = virt_to_phys(_etext);
 	data_resource.end = virt_to_phys(_edata)-1;
+	bss_resource.start = virt_to_phys(__bss_start);
+	bss_resource.end = virt_to_phys(_ebss)-1;
 
 	memory_start = (unsigned long)__va(__MEMORY_START);
 	if (!memory_end)

commit 971ac16d56301c7150771409607846f9facc2f13
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Apr 25 16:01:38 2008 +0900

    sh64: Some symbol exports to make the allmodconfig happier.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 284f66f1ebbe..fc5b22edc0c2 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -53,6 +53,7 @@ EXPORT_SYMBOL(cpu_data);
  * sh_mv= on the command line, prior to .machvec.init teardown.
  */
 struct sh_machine_vector sh_mv = { .mv_name = "generic", };
+EXPORT_SYMBOL(sh_mv);
 
 #ifdef CONFIG_VT
 struct screen_info screen_info;

commit 178dd0cd28168287a0be6444a7eef8918b6c544e
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Apr 9 17:56:18 2008 +0900

    sh: Add support for SH7723 CPU subtype.
    
    This adds basic support for the SH7723 MobileR2 CPU.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 0ee776888c65..284f66f1ebbe 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -335,7 +335,7 @@ static const char *cpu_name[] = {
 	[CPU_SH7343]	= "SH7343",	[CPU_SH7785]	= "SH7785",
 	[CPU_SH7722]	= "SH7722",	[CPU_SHX3]	= "SH-X3",
 	[CPU_SH5_101]	= "SH5-101",	[CPU_SH5_103]	= "SH5-103",
-	[CPU_MXG]	= "MX-G",
+	[CPU_MXG]	= "MX-G",	[CPU_SH7723]	= "SH7723",
 	[CPU_SH7366]	= "SH7366",	[CPU_SH_NONE]	= "Unknown"
 };
 

commit 2ad699080bbe3a88d17a1ff11e5575b76850174f
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Mar 13 12:52:44 2008 +0900

    sh: Initial support for the MX-G CPU.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 23bc707c2b03..0ee776888c65 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -335,6 +335,7 @@ static const char *cpu_name[] = {
 	[CPU_SH7343]	= "SH7343",	[CPU_SH7785]	= "SH7785",
 	[CPU_SH7722]	= "SH7722",	[CPU_SHX3]	= "SH-X3",
 	[CPU_SH5_101]	= "SH5-101",	[CPU_SH5_103]	= "SH5-103",
+	[CPU_MXG]	= "MX-G",
 	[CPU_SH7366]	= "SH7366",	[CPU_SH_NONE]	= "Unknown"
 };
 

commit b9e393c2babb8b6956de52fc580b7c23f3629232
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Mar 7 17:19:58 2008 +0900

    sh: Create an sh debugfs root.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index ff4f54a47c07..23bc707c2b03 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -23,6 +23,8 @@
 #include <linux/kexec.h>
 #include <linux/module.h>
 #include <linux/smp.h>
+#include <linux/err.h>
+#include <linux/debugfs.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/page.h>
@@ -443,3 +445,15 @@ const struct seq_operations cpuinfo_op = {
 	.show	= show_cpuinfo,
 };
 #endif /* CONFIG_PROC_FS */
+
+struct dentry *sh_debugfs_root;
+
+static int __init sh_debugfs_init(void)
+{
+	sh_debugfs_root = debugfs_create_dir("sh", NULL);
+	if (IS_ERR(sh_debugfs_root))
+		return PTR_ERR(sh_debugfs_root);
+
+	return 0;
+}
+arch_initcall(sh_debugfs_init);

commit 9109a30e5a548b39463b5a777943cf103da507af
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Fri Feb 8 17:31:24 2008 +0900

    sh: add support for sh7366 processor
    
    This patch adds sh7366 cpu supports. Just the most basic things like interrupt
    controller, clocks and serial port are included at this point.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 18a5baf2cbad..ff4f54a47c07 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -333,7 +333,7 @@ static const char *cpu_name[] = {
 	[CPU_SH7343]	= "SH7343",	[CPU_SH7785]	= "SH7785",
 	[CPU_SH7722]	= "SH7722",	[CPU_SHX3]	= "SH-X3",
 	[CPU_SH5_101]	= "SH5-101",	[CPU_SH5_103]	= "SH5-103",
-	[CPU_SH_NONE]	= "Unknown"
+	[CPU_SH7366]	= "SH7366",	[CPU_SH_NONE]	= "Unknown"
 };
 
 const char *get_cpu_subtype(struct sh_cpuinfo *c)

commit 18a01a3beb9f25a70a51e12e3c1c3d273da10eca
Author: Bernhard Walle <bwalle@suse.de>
Date:   Thu Feb 7 00:15:19 2008 -0800

    Use BOOTMEM_EXCLUSIVE for kdump
    
    Use the BOOTMEM_EXCLUSIVE, introduced in the previous patch, to avoid
    conflicts while reserving the memory for the kdump capture kernel
    (crashkernel=).
    
    Signed-off-by: Bernhard Walle <bwalle@suse.de>
    Cc: <linux-arch@vger.kernel.org>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index af10db90a554..18a5baf2cbad 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -140,19 +140,26 @@ static void __init reserve_crashkernel(void)
 	ret = parse_crashkernel(boot_command_line, free_mem,
 			&crash_size, &crash_base);
 	if (ret == 0 && crash_size) {
-		if (crash_base > 0) {
-			printk(KERN_INFO "Reserving %ldMB of memory at %ldMB "
-					"for crashkernel (System RAM: %ldMB)\n",
-					(unsigned long)(crash_size >> 20),
-					(unsigned long)(crash_base >> 20),
-					(unsigned long)(free_mem >> 20));
-			crashk_res.start = crash_base;
-			crashk_res.end   = crash_base + crash_size - 1;
-			reserve_bootmem(crash_base, crash_size,
-					BOOTMEM_DEFAULT);
-		} else
+		if (crash_base <= 0) {
 			printk(KERN_INFO "crashkernel reservation failed - "
 					"you have to specify a base address\n");
+			return;
+		}
+
+		if (reserve_bootmem(crash_base, crash_size,
+					BOOTMEM_EXCLUSIVE) < 0) {
+			printk(KERN_INFO "crashkernel reservation failed - "
+					"memory is in use\n");
+			return;
+		}
+
+		printk(KERN_INFO "Reserving %ldMB of memory at %ldMB "
+				"for crashkernel (System RAM: %ldMB)\n",
+				(unsigned long)(crash_size >> 20),
+				(unsigned long)(crash_base >> 20),
+				(unsigned long)(free_mem >> 20));
+		crashk_res.start = crash_base;
+		crashk_res.end   = crash_base + crash_size - 1;
 	}
 }
 #else

commit 72a7fe3967dbf86cb34e24fbf1d957fe24d2f246
Author: Bernhard Walle <bwalle@suse.de>
Date:   Thu Feb 7 00:15:17 2008 -0800

    Introduce flags for reserve_bootmem()
    
    This patchset adds a flags variable to reserve_bootmem() and uses the
    BOOTMEM_EXCLUSIVE flag in crashkernel reservation code to detect collisions
    between crashkernel area and already used memory.
    
    This patch:
    
    Change the reserve_bootmem() function to accept a new flag BOOTMEM_EXCLUSIVE.
    If that flag is set, the function returns with -EBUSY if the memory already
    has been reserved in the past.  This is to avoid conflicts.
    
    Because that code runs before SMP initialisation, there's no race condition
    inside reserve_bootmem_core().
    
    [akpm@linux-foundation.org: coding-style fixes]
    [akpm@linux-foundation.org: fix powerpc build]
    Signed-off-by: Bernhard Walle <bwalle@suse.de>
    Cc: <linux-arch@vger.kernel.org>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 855cdf9d85b1..af10db90a554 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -148,7 +148,8 @@ static void __init reserve_crashkernel(void)
 					(unsigned long)(free_mem >> 20));
 			crashk_res.start = crash_base;
 			crashk_res.end   = crash_base + crash_size - 1;
-			reserve_bootmem(crash_base, crash_size);
+			reserve_bootmem(crash_base, crash_size,
+					BOOTMEM_DEFAULT);
 		} else
 			printk(KERN_INFO "crashkernel reservation failed - "
 					"you have to specify a base address\n");
@@ -184,13 +185,14 @@ void __init setup_bootmem_allocator(unsigned long free_pfn)
 	 * an invalid RAM area.
 	 */
 	reserve_bootmem(__MEMORY_START+PAGE_SIZE,
-		(PFN_PHYS(free_pfn)+bootmap_size+PAGE_SIZE-1)-__MEMORY_START);
+		(PFN_PHYS(free_pfn)+bootmap_size+PAGE_SIZE-1)-__MEMORY_START,
+		BOOTMEM_DEFAULT);
 
 	/*
 	 * reserve physical page 0 - it's a special BIOS page on many boxes,
 	 * enabling clean reboots, SMP operation, laptop functions.
 	 */
-	reserve_bootmem(__MEMORY_START, PAGE_SIZE);
+	reserve_bootmem(__MEMORY_START, PAGE_SIZE, BOOTMEM_DEFAULT);
 
 	sparse_memory_present_with_active_regions(0);
 
@@ -200,7 +202,7 @@ void __init setup_bootmem_allocator(unsigned long free_pfn)
 	if (LOADER_TYPE && INITRD_START) {
 		if (INITRD_START + INITRD_SIZE <= (max_low_pfn << PAGE_SHIFT)) {
 			reserve_bootmem(INITRD_START + __MEMORY_START,
-					INITRD_SIZE);
+					INITRD_SIZE, BOOTMEM_DEFAULT);
 			initrd_start = INITRD_START + PAGE_OFFSET +
 					__MEMORY_START;
 			initrd_end = initrd_start + INITRD_SIZE;

commit 773c7bd69434a356af4363a61889ef975b256e32
Author: Jan Engelhardt <jengelh@computergmbh.de>
Date:   Wed Jan 23 12:47:48 2008 +0900

    sh: constify function pointer tables
    
    Signed-off-by: Jan Engelhardt <jengelh@computergmbh.de>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 9cf1d2e998bf..855cdf9d85b1 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -427,7 +427,7 @@ static void *c_next(struct seq_file *m, void *v, loff_t *pos)
 static void c_stop(struct seq_file *m, void *v)
 {
 }
-struct seq_operations cpuinfo_op = {
+const struct seq_operations cpuinfo_op = {
 	.start	= c_start,
 	.next	= c_next,
 	.stop	= c_stop,

commit 7d740a066fb9c6681c2898c7977209725c9e552f
Author: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
Date:   Mon Jan 7 14:40:07 2008 +0900

    sh: Add support for SH7763 CPU subtype.
    
    Signed-off-by: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 48cd576754b5..9cf1d2e998bf 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -319,10 +319,10 @@ static const char *cpu_name[] = {
 	[CPU_SH7750R]	= "SH7750R",	[CPU_SH7751]	= "SH7751",
 	[CPU_SH7751R]	= "SH7751R",	[CPU_SH7760]	= "SH7760",
 	[CPU_SH4_202]	= "SH4-202",	[CPU_SH4_501]	= "SH4-501",
-	[CPU_SH7770]	= "SH7770",	[CPU_SH7780]	= "SH7780",
-	[CPU_SH7781]	= "SH7781",	[CPU_SH7343]	= "SH7343",
-	[CPU_SH7785]	= "SH7785",	[CPU_SH7722]	= "SH7722",
-	[CPU_SHX3]	= "SH-X3",
+	[CPU_SH7763]	= "SH7763",	[CPU_SH7770]	= "SH7770",
+	[CPU_SH7780]	= "SH7780",	[CPU_SH7781]	= "SH7781",
+	[CPU_SH7343]	= "SH7343",	[CPU_SH7785]	= "SH7785",
+	[CPU_SH7722]	= "SH7722",	[CPU_SHX3]	= "SH-X3",
 	[CPU_SH5_101]	= "SH5-101",	[CPU_SH5_103]	= "SH5-103",
 	[CPU_SH_NONE]	= "Unknown"
 };

commit 31a49c4bf8f964b7a9897baa889916d71b51d9c1
Author: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
Date:   Wed Dec 26 11:45:06 2007 +0900

    sh: Add support for SH7721 CPU subtype.
    
    Signed-off-by: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 9c105c827e86..48cd576754b5 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -314,10 +314,10 @@ static const char *cpu_name[] = {
 	[CPU_SH7707]	= "SH7707",	[CPU_SH7708]	= "SH7708",
 	[CPU_SH7709]	= "SH7709",	[CPU_SH7710]	= "SH7710",
 	[CPU_SH7712]	= "SH7712",	[CPU_SH7720]	= "SH7720",
-	[CPU_SH7729]	= "SH7729",	[CPU_SH7750]	= "SH7750",
-	[CPU_SH7750S]	= "SH7750S",	[CPU_SH7750R]	= "SH7750R",
-	[CPU_SH7751]	= "SH7751",	[CPU_SH7751R]	= "SH7751R",
-	[CPU_SH7760]	= "SH7760",
+	[CPU_SH7721]	= "SH7721",	[CPU_SH7729]	= "SH7729",
+	[CPU_SH7750]	= "SH7750",	[CPU_SH7750S]	= "SH7750S",
+	[CPU_SH7750R]	= "SH7750R",	[CPU_SH7751]	= "SH7751",
+	[CPU_SH7751R]	= "SH7751R",	[CPU_SH7760]	= "SH7760",
 	[CPU_SH4_202]	= "SH4-202",	[CPU_SH4_501]	= "SH4-501",
 	[CPU_SH7770]	= "SH7770",	[CPU_SH7780]	= "SH7780",
 	[CPU_SH7781]	= "SH7781",	[CPU_SH7343]	= "SH7343",

commit cd01204b82933754a7276838656420477f64d4b8
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Dec 10 15:50:28 2007 +0900

    sh: Encode L1/L2 cache shape in auxvt.
    
    This adds in the L1I/L1D/L2 cache shape support to their respective
    entries in the ELF auxvt, based on the Alpha implementation. We use
    this on the userspace libc side for calculating a tightly packed
    SHMLBA amongst other things.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index f48ce8e5d0a8..9c105c827e86 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -26,6 +26,7 @@
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/page.h>
+#include <asm/elf.h>
 #include <asm/sections.h>
 #include <asm/irq.h>
 #include <asm/setup.h>
@@ -78,6 +79,8 @@ EXPORT_SYMBOL(memory_start);
 unsigned long memory_end = 0;
 EXPORT_SYMBOL(memory_end);
 
+int l1i_cache_shape, l1d_cache_shape, l2_cache_shape;
+
 static int __init early_parse_mem(char *p)
 {
 	unsigned long size;

commit d02b08f6e8b184ffef349e395210a5e82ff4f4bc
Author: Stuart Menefy <stuart.menefy@st.com>
Date:   Fri Nov 30 17:52:53 2007 +0900

    sh: Clean up places that make 29-bit physical assumptions.
    
    Signed-off-by: Stuart Menefy <stuart.menefy@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 7eb7fdcce0f8..f48ce8e5d0a8 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -82,7 +82,7 @@ static int __init early_parse_mem(char *p)
 {
 	unsigned long size;
 
-	memory_start = (unsigned long)PAGE_OFFSET+__MEMORY_START;
+	memory_start = (unsigned long)__va(__MEMORY_START);
 	size = memparse(p, &p);
 
 	if (size > __MEMORY_SIZE) {
@@ -254,7 +254,7 @@ void __init setup_arch(char **cmdline_p)
 	data_resource.start = virt_to_phys(_etext);
 	data_resource.end = virt_to_phys(_edata)-1;
 
-	memory_start = (unsigned long)PAGE_OFFSET+__MEMORY_START;
+	memory_start = (unsigned long)__va(__MEMORY_START);
 	if (!memory_end)
 		memory_end = memory_start + __MEMORY_SIZE;
 

commit 80a68a43d90e2221599b507b6b26c3cba1957687
Author: Stuart Menefy <stuart.menefy@st.com>
Date:   Mon Nov 26 21:16:09 2007 +0900

    sh: Add a printk() to warn legacy mem= growers.
    
    mem= can't be used to grow the size of kernel memory, so provide a
    warning to that effect.
    
    Signed-off-by: Stuart Menefy <stuart.menefy@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 6891cc93548e..7eb7fdcce0f8 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -84,6 +84,17 @@ static int __init early_parse_mem(char *p)
 
 	memory_start = (unsigned long)PAGE_OFFSET+__MEMORY_START;
 	size = memparse(p, &p);
+
+	if (size > __MEMORY_SIZE) {
+		static char msg[] __initdata = KERN_ERR
+			"Using mem= to increase the size of kernel memory "
+			"is not allowed.\n"
+			"  Recompile the kernel with the correct value for "
+			"CONFIG_MEMORY_SIZE.\n";
+		printk(msg);
+		return 0;
+	}
+
 	memory_end = memory_start + size;
 
 	return 0;

commit a8f67f4b4d4b74cd14d3540ade8657ebee543340
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Nov 26 19:54:02 2007 +0900

    sh: Add SH7263 CPU support.
    
    This adds support for the SH7263 (SH-2A) CPU.
    
    This particular CPU is a superset of SH7203, adding some additional
    peripheral blocks and hooking up additional (reserved on SH7203)
    vectors in the INTC block.
    
    No visibly nasty surprises, yet..
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index c5a453fb19ca..6891cc93548e 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -294,7 +294,7 @@ void __init setup_arch(char **cmdline_p)
 }
 
 static const char *cpu_name[] = {
-	[CPU_SH7203]	= "SH7203",
+	[CPU_SH7203]	= "SH7203",	[CPU_SH7263]	= "SH7263",
 	[CPU_SH7206]	= "SH7206",	[CPU_SH7619]	= "SH7619",
 	[CPU_SH7705]	= "SH7705",	[CPU_SH7706]	= "SH7706",
 	[CPU_SH7707]	= "SH7707",	[CPU_SH7708]	= "SH7708",

commit 6d01f51086cf6c475470cdae67d2f45e5fb57833
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Nov 26 18:17:21 2007 +0900

    sh: Add SH7203 CPU support.
    
    This adds support for the SH7203 (SH-2A) CPU.
    
    Signed-off-by: Kieran Bingham <kbingham@mpc-data.co.uk>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 1ec40091a4e8..c5a453fb19ca 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -294,6 +294,7 @@ void __init setup_arch(char **cmdline_p)
 }
 
 static const char *cpu_name[] = {
+	[CPU_SH7203]	= "SH7203",
 	[CPU_SH7206]	= "SH7206",	[CPU_SH7619]	= "SH7619",
 	[CPU_SH7705]	= "SH7705",	[CPU_SH7706]	= "SH7706",
 	[CPU_SH7707]	= "SH7707",	[CPU_SH7708]	= "SH7708",

commit c2672f62e734292bca4ce4ab5e89c7e04ecb70dc
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Nov 20 18:29:00 2007 +0900

    sh: Add the SH-5 cpu type symbolic names.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 4156aac8c27d..1ec40091a4e8 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -307,7 +307,9 @@ static const char *cpu_name[] = {
 	[CPU_SH7770]	= "SH7770",	[CPU_SH7780]	= "SH7780",
 	[CPU_SH7781]	= "SH7781",	[CPU_SH7343]	= "SH7343",
 	[CPU_SH7785]	= "SH7785",	[CPU_SH7722]	= "SH7722",
-	[CPU_SHX3]	= "SH-X3",	[CPU_SH_NONE]	= "Unknown"
+	[CPU_SHX3]	= "SH-X3",
+	[CPU_SH5_101]	= "SH5-101",	[CPU_SH5_103]	= "SH5-103",
+	[CPU_SH_NONE]	= "Unknown"
 };
 
 const char *get_cpu_subtype(struct sh_cpuinfo *c)

commit f96691872439ab2071171d4531c4a95b5d493ae5
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Nov 7 11:05:32 2007 +0900

    sh: Kill off the remaining ST40 cruft.
    
    The ST40 stuff in-tree hasn't built for some time, and hasn't been
    updated for over 3 years. ST maintains their own out-of-tree changes
    and rebases occasionally, and that's ultimately where all of the ST40
    users go anyways.
    
    In order for the ST40 code to be brought up to date most of the stuff
    removed in this changeset would have to be rewritten anyways, so there's
    very little benefit in keeping the remnants around either.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 0b8c45d53a47..4156aac8c27d 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -303,7 +303,6 @@ static const char *cpu_name[] = {
 	[CPU_SH7750S]	= "SH7750S",	[CPU_SH7750R]	= "SH7750R",
 	[CPU_SH7751]	= "SH7751",	[CPU_SH7751R]	= "SH7751R",
 	[CPU_SH7760]	= "SH7760",
-	[CPU_ST40RA]	= "ST40RA",	[CPU_ST40GX1]	= "ST40GX1",
 	[CPU_SH4_202]	= "SH4-202",	[CPU_SH4_501]	= "SH4-501",
 	[CPU_SH7770]	= "SH7770",	[CPU_SH7780]	= "SH7780",
 	[CPU_SH7781]	= "SH7781",	[CPU_SH7343]	= "SH7343",

commit 69d1ef4caf77da7164d3e392bf0a8057b42cf26e
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Oct 30 17:32:08 2007 +0900

    sh: Move zero page param defs somewhere sensible.
    
    Follows s390 and others.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index c439a7ecd059..0b8c45d53a47 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -57,28 +57,21 @@ struct screen_info screen_info;
 
 extern int root_mountflags;
 
-/*
- * This is set up by the setup-routine at boot-time
- */
-#define PARAM	((unsigned char *)empty_zero_page)
-
-#define MOUNT_ROOT_RDONLY (*(unsigned long *) (PARAM+0x000))
-#define RAMDISK_FLAGS (*(unsigned long *) (PARAM+0x004))
-#define ORIG_ROOT_DEV (*(unsigned long *) (PARAM+0x008))
-#define LOADER_TYPE (*(unsigned long *) (PARAM+0x00c))
-#define INITRD_START (*(unsigned long *) (PARAM+0x010))
-#define INITRD_SIZE (*(unsigned long *) (PARAM+0x014))
-/* ... */
-#define COMMAND_LINE ((char *) (PARAM+0x100))
-
 #define RAMDISK_IMAGE_START_MASK	0x07FF
 #define RAMDISK_PROMPT_FLAG		0x8000
 #define RAMDISK_LOAD_FLAG		0x4000
 
 static char __initdata command_line[COMMAND_LINE_SIZE] = { 0, };
 
-static struct resource code_resource = { .name = "Kernel code", };
-static struct resource data_resource = { .name = "Kernel data", };
+static struct resource code_resource = {
+	.name = "Kernel code",
+	.flags = IORESOURCE_BUSY | IORESOURCE_MEM,
+};
+
+static struct resource data_resource = {
+	.name = "Kernel data",
+	.flags = IORESOURCE_BUSY | IORESOURCE_MEM,
+};
 
 unsigned long memory_start;
 EXPORT_SYMBOL(memory_start);

commit 3f9654f02ede996e5be73866da716b325a6fb66b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Oct 30 17:25:29 2007 +0900

    sh: Kill off legacy embedded ramdisk section.
    
    When the SH kernel used to support embedding a ramdisk in the
    pre-initramfs days it was placed in a special section and made to
    look like a regular initrd. Since that was removed ages ago, kill
    off the remaining cruft that was missed.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index a031c6773906..c439a7ecd059 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -32,12 +32,6 @@
 #include <asm/clock.h>
 #include <asm/mmu_context.h>
 
-extern void * __rd_start, * __rd_end;
-
-/*
- * Machine setup..
- */
-
 /*
  * Initialize loops_per_jiffy as 10000000 (1000MIPS).
  * This value will be used at the very early stage of serial setup.
@@ -194,14 +188,7 @@ void __init setup_bootmem_allocator(unsigned long free_pfn)
 	sparse_memory_present_with_active_regions(0);
 
 #ifdef CONFIG_BLK_DEV_INITRD
-	ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
-	if (&__rd_start != &__rd_end) {
-		LOADER_TYPE = 1;
-		INITRD_START = PHYSADDR((unsigned long)&__rd_start) -
-					__MEMORY_START;
-		INITRD_SIZE = (unsigned long)&__rd_end -
-			      (unsigned long)&__rd_start;
-	}
+	ROOT_DEV = Root_RAM0;
 
 	if (LOADER_TYPE && INITRD_START) {
 		if (INITRD_START + INITRD_SIZE <= (max_low_pfn << PAGE_SHIFT)) {

commit 7e5186eaae8eebc0101d539791dbff92256455ee
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Oct 30 17:18:08 2007 +0900

    sh: Fix up early mem cmdline parsing.
    
    memory_end was being clobbered by whatever the kernel config had
    specified, rather than obeying the setup option. Fix this up so
    that memory_end is only initialized if nothing has been set on
    the command line.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index b749403f6b38..a031c6773906 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -88,8 +88,7 @@ static struct resource data_resource = { .name = "Kernel data", };
 
 unsigned long memory_start;
 EXPORT_SYMBOL(memory_start);
-
-unsigned long memory_end;
+unsigned long memory_end = 0;
 EXPORT_SYMBOL(memory_end);
 
 static int __init early_parse_mem(char *p)
@@ -265,7 +264,8 @@ void __init setup_arch(char **cmdline_p)
 	data_resource.end = virt_to_phys(_edata)-1;
 
 	memory_start = (unsigned long)PAGE_OFFSET+__MEMORY_START;
-	memory_end = memory_start + __MEMORY_SIZE;
+	if (!memory_end)
+		memory_end = memory_start + __MEMORY_SIZE;
 
 #ifdef CONFIG_CMDLINE_BOOL
 	strlcpy(command_line, CONFIG_CMDLINE, sizeof(command_line));

commit 7d7712a385d5b0a6f921dbd9b66ad3aaed387b5e
Author: Bernhard Walle <bwalle@suse.de>
Date:   Thu Oct 18 23:41:02 2007 -0700

    Use extended crashkernel command line on sh
    
    This patch removes the crashkernel parsing from arch/sh/kernel/machine_kexec.c
    and calls the generic function, introduced in the generic patch, in
    setup_bootmem_allocator().
    
    This is necessary because the amount of System RAM must be known in this
    function now because of the new syntax.
    
    Signed-off-by: Bernhard Walle <bwalle@suse.de>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index b3027a6775b9..b749403f6b38 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -128,6 +128,37 @@ static void __init register_bootmem_low_pages(void)
 	free_bootmem(PFN_PHYS(curr_pfn), PFN_PHYS(pages));
 }
 
+#ifdef CONFIG_KEXEC
+static void __init reserve_crashkernel(void)
+{
+	unsigned long long free_mem;
+	unsigned long long crash_size, crash_base;
+	int ret;
+
+	free_mem = ((unsigned long long)max_low_pfn - min_low_pfn) << PAGE_SHIFT;
+
+	ret = parse_crashkernel(boot_command_line, free_mem,
+			&crash_size, &crash_base);
+	if (ret == 0 && crash_size) {
+		if (crash_base > 0) {
+			printk(KERN_INFO "Reserving %ldMB of memory at %ldMB "
+					"for crashkernel (System RAM: %ldMB)\n",
+					(unsigned long)(crash_size >> 20),
+					(unsigned long)(crash_base >> 20),
+					(unsigned long)(free_mem >> 20));
+			crashk_res.start = crash_base;
+			crashk_res.end   = crash_base + crash_size - 1;
+			reserve_bootmem(crash_base, crash_size);
+		} else
+			printk(KERN_INFO "crashkernel reservation failed - "
+					"you have to specify a base address\n");
+	}
+}
+#else
+static inline void __init reserve_crashkernel(void)
+{}
+#endif
+
 void __init setup_bootmem_allocator(unsigned long free_pfn)
 {
 	unsigned long bootmap_size;
@@ -189,11 +220,8 @@ void __init setup_bootmem_allocator(unsigned long free_pfn)
 		}
 	}
 #endif
-#ifdef CONFIG_KEXEC
-	if (crashk_res.start != crashk_res.end)
-		reserve_bootmem(crashk_res.start,
-			crashk_res.end - crashk_res.start + 1);
-#endif
+
+	reserve_crashkernel();
 }
 
 #ifndef CONFIG_NEED_MULTIPLE_NODES

commit 0016a126accb32f1663eaeba966eb76c98f8929b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Sep 21 18:39:49 2007 +0900

    sh: Plug plat_smp_setup() in to generic setup path.
    
    Now that the SMP stubs are in place, call in to the setup code
    to be defined by the platform.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index cd69b57488dd..b3027a6775b9 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -22,6 +22,7 @@
 #include <linux/mm.h>
 #include <linux/kexec.h>
 #include <linux/module.h>
+#include <linux/smp.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/page.h>
@@ -278,6 +279,10 @@ void __init setup_arch(char **cmdline_p)
 		sh_mv.mv_setup(cmdline_p);
 
 	paging_init();
+
+#ifdef CONFIG_SMP
+	plat_smp_setup();
+#endif
 }
 
 static const char *cpu_name[] = {

commit 2d4a73d5b91528322631830784f4eb7897fb5e41
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Sep 21 18:01:40 2007 +0900

    sh: Kill off special boot_cpu_data.
    
    This consolidates the cpu_data definitions and gets rid of the special
    boot_cpu_data. It's made a wrapper to the boot CPU, in order to keep
    the existing in-tree users happy.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index e0e655cba89c..cd69b57488dd 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -42,7 +42,13 @@ extern void * __rd_start, * __rd_end;
  * This value will be used at the very early stage of serial setup.
  * The bigger value means no problem.
  */
-struct sh_cpuinfo boot_cpu_data = { CPU_SH_NONE, 10000000, };
+struct sh_cpuinfo cpu_data[NR_CPUS] __read_mostly = {
+	[0] = {
+		.type			= CPU_SH_NONE,
+		.loops_per_jiffy	= 10000000,
+	},
+};
+EXPORT_SYMBOL(cpu_data);
 
 /*
  * The machine vector. First entry in .machvec.init, or clobbered by

commit 3ea6bc3de4f15fcae84fb31eeea4d420685a3da2
Author: Markus Brunner <super.firetwister@gmail.com>
Date:   Mon Aug 20 08:59:33 2007 +0900

    sh: Add SH7720 CPU support.
    
    This adds support for the SH7720 (SH3-DSP) CPU.
    
    Signed-off by: Markus Brunner <super.firetwister@gmail.com>
    Signed-off by: Mark Jonas <toertel@gmail.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 2cf7dec0d690..e0e655cba89c 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -279,7 +279,7 @@ static const char *cpu_name[] = {
 	[CPU_SH7705]	= "SH7705",	[CPU_SH7706]	= "SH7706",
 	[CPU_SH7707]	= "SH7707",	[CPU_SH7708]	= "SH7708",
 	[CPU_SH7709]	= "SH7709",	[CPU_SH7710]	= "SH7710",
-	[CPU_SH7712]	= "SH7712",
+	[CPU_SH7712]	= "SH7712",	[CPU_SH7720]	= "SH7720",
 	[CPU_SH7729]	= "SH7729",	[CPU_SH7750]	= "SH7750",
 	[CPU_SH7750S]	= "SH7750S",	[CPU_SH7750R]	= "SH7750R",
 	[CPU_SH7751]	= "SH7751",	[CPU_SH7751R]	= "SH7751R",

commit d89ddd1c847637d91625c8cb6b0d064e1717057c
Author: Magnus Damm <damm@igel.co.jp>
Date:   Wed Jul 25 11:42:56 2007 +0900

    sh: remove support for sh7300 and solution engine 7300
    
    This patch removes old dead code:
    - kill off sh7300 cpu support
    - get rid of broken solution engine 7300 board support
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index af766b6cd3c1..2cf7dec0d690 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -276,7 +276,6 @@ void __init setup_arch(char **cmdline_p)
 
 static const char *cpu_name[] = {
 	[CPU_SH7206]	= "SH7206",	[CPU_SH7619]	= "SH7619",
-	[CPU_SH7300]	= "SH7300",
 	[CPU_SH7705]	= "SH7705",	[CPU_SH7706]	= "SH7706",
 	[CPU_SH7707]	= "SH7707",	[CPU_SH7708]	= "SH7708",
 	[CPU_SH7709]	= "SH7709",	[CPU_SH7710]	= "SH7710",

commit 870e8a24380cf1854dc1bb5fa5abebb44d82674b
Author: Magnus Damm <damm@igel.co.jp>
Date:   Wed Jul 25 10:49:21 2007 +0900

    sh: remove support for sh73180 and solution engine 73180
    
    This patch removes old dead code:
    - kill off sh73180 cpu support
    - get rid of broken solution engine 73180 board support
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index c14a3e95d0b1..af766b6cd3c1 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -284,7 +284,7 @@ static const char *cpu_name[] = {
 	[CPU_SH7729]	= "SH7729",	[CPU_SH7750]	= "SH7750",
 	[CPU_SH7750S]	= "SH7750S",	[CPU_SH7750R]	= "SH7750R",
 	[CPU_SH7751]	= "SH7751",	[CPU_SH7751R]	= "SH7751R",
-	[CPU_SH7760]	= "SH7760",	[CPU_SH73180]	= "SH73180",
+	[CPU_SH7760]	= "SH7760",
 	[CPU_ST40RA]	= "ST40RA",	[CPU_ST40GX1]	= "ST40GX1",
 	[CPU_SH4_202]	= "SH4-202",	[CPU_SH4_501]	= "SH4-501",
 	[CPU_SH7770]	= "SH7770",	[CPU_SH7780]	= "SH7780",

commit 98d877c487a75af78f74780703aa6b174780788d
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Jul 20 16:59:49 2007 +0900

    sh: Many symbol exports for nommu allmodconfig.
    
    allmodconfig generates a lot of interesting code, a lot of the
    generated symbols we've never exported before, so this fixes
    those up. Verified with both GCC3 and GCC4 toolchains.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index de8e6e2f2c87..c14a3e95d0b1 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -21,6 +21,7 @@
 #include <linux/fs.h>
 #include <linux/mm.h>
 #include <linux/kexec.h>
+#include <linux/module.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/page.h>
@@ -78,7 +79,11 @@ static char __initdata command_line[COMMAND_LINE_SIZE] = { 0, };
 static struct resource code_resource = { .name = "Kernel code", };
 static struct resource data_resource = { .name = "Kernel data", };
 
-unsigned long memory_start, memory_end;
+unsigned long memory_start;
+EXPORT_SYMBOL(memory_start);
+
+unsigned long memory_end;
+EXPORT_SYMBOL(memory_end);
 
 static int __init early_parse_mem(char *p)
 {

commit 2b1bd1ac5d4bffe3fd542bfe1784a583bd7df4fa
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Jun 20 18:27:10 2007 +0900

    sh: Preliminary support for the SH-X3 CPU.
    
    This adds basic support for UP SH-X3.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 765f83c1bca4..de8e6e2f2c87 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -285,7 +285,7 @@ static const char *cpu_name[] = {
 	[CPU_SH7770]	= "SH7770",	[CPU_SH7780]	= "SH7780",
 	[CPU_SH7781]	= "SH7781",	[CPU_SH7343]	= "SH7343",
 	[CPU_SH7785]	= "SH7785",	[CPU_SH7722]	= "SH7722",
-	[CPU_SH_NONE]	= "Unknown"
+	[CPU_SHX3]	= "SH-X3",	[CPU_SH_NONE]	= "Unknown"
 };
 
 const char *get_cpu_subtype(struct sh_cpuinfo *c)

commit b9601c5e59dd25693345558a301e833741bf5874
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Jun 8 11:55:28 2007 +0900

    sh: Kill off dead SH7604 support.
    
    This was added during 2.5.x, but was never moved along. This
    can easily be resurrected if someone has one they wish to work
    with, but it's not worth keeping around in its current form.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index c2c6bfdf4dfe..765f83c1bca4 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -271,7 +271,7 @@ void __init setup_arch(char **cmdline_p)
 
 static const char *cpu_name[] = {
 	[CPU_SH7206]	= "SH7206",	[CPU_SH7619]	= "SH7619",
-	[CPU_SH7604]	= "SH7604",	[CPU_SH7300]	= "SH7300",
+	[CPU_SH7300]	= "SH7300",
 	[CPU_SH7705]	= "SH7705",	[CPU_SH7706]	= "SH7706",
 	[CPU_SH7707]	= "SH7707",	[CPU_SH7708]	= "SH7708",
 	[CPU_SH7709]	= "SH7709",	[CPU_SH7710]	= "SH7710",

commit 2826fa61c13716816c7ae658b8f1c5a4a505d8ac
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Jun 1 17:04:36 2007 +0900

    sh: Mark sparsemem regions present earlier.
    
    We have to call in to sparse_memory_present_with_active_regions()
    earlier in order for sparsemem to be happy. This was being called
    too late, and was causing troubles with the platforms that needed
    to enable sparsemem.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 3241a6274b81..c2c6bfdf4dfe 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -116,7 +116,7 @@ static void __init register_bootmem_low_pages(void)
 	free_bootmem(PFN_PHYS(curr_pfn), PFN_PHYS(pages));
 }
 
-void __init setup_bootmem_allocator(unsigned long start_pfn)
+void __init setup_bootmem_allocator(unsigned long free_pfn)
 {
 	unsigned long bootmap_size;
 
@@ -125,7 +125,7 @@ void __init setup_bootmem_allocator(unsigned long start_pfn)
 	 * bootstrap step all allocations (until the page allocator
 	 * is intact) must be done via bootmem_alloc().
 	 */
-	bootmap_size = init_bootmem_node(NODE_DATA(0), start_pfn,
+	bootmap_size = init_bootmem_node(NODE_DATA(0), free_pfn,
 					 min_low_pfn, max_low_pfn);
 
 	add_active_range(0, min_low_pfn, max_low_pfn);
@@ -141,7 +141,7 @@ void __init setup_bootmem_allocator(unsigned long start_pfn)
 	 * an invalid RAM area.
 	 */
 	reserve_bootmem(__MEMORY_START+PAGE_SIZE,
-		(PFN_PHYS(start_pfn)+bootmap_size+PAGE_SIZE-1)-__MEMORY_START);
+		(PFN_PHYS(free_pfn)+bootmap_size+PAGE_SIZE-1)-__MEMORY_START);
 
 	/*
 	 * reserve physical page 0 - it's a special BIOS page on many boxes,
@@ -149,6 +149,8 @@ void __init setup_bootmem_allocator(unsigned long start_pfn)
 	 */
 	reserve_bootmem(__MEMORY_START, PAGE_SIZE);
 
+	sparse_memory_present_with_active_regions(0);
+
 #ifdef CONFIG_BLK_DEV_INITRD
 	ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
 	if (&__rd_start != &__rd_end) {
@@ -193,7 +195,6 @@ static void __init setup_memory(void)
 	 */
 	start_pfn = PFN_UP(__pa(_end));
 	setup_bootmem_allocator(start_pfn);
-	sparse_memory_present_with_active_regions(0);
 }
 #else
 extern void __init setup_memory(void);

commit dfbb9042801eaeb4df9015bb86224291a39a0f52
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed May 23 17:48:36 2007 +0900

    sh: sparsemem support.
    
    This implements basic sparsemem support for SH. Presently this only
    uses static sparsemem, and we still permit explicit selection of
    flatmem. Those boards that want sparsemem can select it as usual.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 6f1ea9b33374..3241a6274b81 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -128,6 +128,7 @@ void __init setup_bootmem_allocator(unsigned long start_pfn)
 	bootmap_size = init_bootmem_node(NODE_DATA(0), start_pfn,
 					 min_low_pfn, max_low_pfn);
 
+	add_active_range(0, min_low_pfn, max_low_pfn);
 	register_bootmem_low_pages();
 
 	node_set_online(0);
@@ -192,6 +193,7 @@ static void __init setup_memory(void)
 	 */
 	start_pfn = PFN_UP(__pa(_end));
 	setup_bootmem_allocator(start_pfn);
+	sparse_memory_present_with_active_regions(0);
 }
 #else
 extern void __init setup_memory(void);
@@ -250,8 +252,9 @@ void __init setup_arch(char **cmdline_p)
 	min_low_pfn = __MEMORY_START >> PAGE_SHIFT;
 
 	nodes_clear(node_online_map);
+
+	/* Setup bootmem with available RAM */
 	setup_memory();
-	paging_init();
 	sparse_init();
 
 #ifdef CONFIG_DUMMY_CONSOLE
@@ -261,8 +264,9 @@ void __init setup_arch(char **cmdline_p)
 	/* Perform the machine specific initialisation */
 	if (likely(sh_mv.mv_setup))
 		sh_mv.mv_setup(cmdline_p);
-}
 
+	paging_init();
+}
 
 static const char *cpu_name[] = {
 	[CPU_SH7206]	= "SH7206",	[CPU_SH7619]	= "SH7619",

commit fd8f20e8e2f8f1d9201086bff444c8d35f0a6a45
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 15 15:38:30 2007 +0900

    sh: Rip out special unknown machvec.
    
    This kills off the BareCPU board as a "special" machvec, rather,
    we leave this as a default for when no other vector is available,
    or when we want to use it in combination with other vectors for
    testing with generic ops. As sh_mv is copied out anyways (or
    overloaded when an alternate vector is explicitly selected), this
    doesn't consume any additional memory.
    
    The generic machvec can be forcibly selected with sh_mv=generic,
    or by not having any other boards enabled.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 55ed653c7a67..6f1ea9b33374 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -47,7 +47,7 @@ struct sh_cpuinfo boot_cpu_data = { CPU_SH_NONE, 10000000, };
  * The machine vector. First entry in .machvec.init, or clobbered by
  * sh_mv= on the command line, prior to .machvec.init teardown.
  */
-struct sh_machine_vector sh_mv = { .mv_name = "Unknown", };
+struct sh_machine_vector sh_mv = { .mv_name = "generic", };
 
 #ifdef CONFIG_VT
 struct screen_info screen_info;

commit 82f81f4784479df17a80caff4a7156da0a2f7dea
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 15 15:19:34 2007 +0900

    sh: Kill off machvec aliases.
    
    We now throw all of the machvecs in to .machvec.init and either
    select one on the command line, or copy out the first (and
    usually only) one to sh_mv. The rest are freed as usual.
    
    This gets rid of all of the silly sh_mv aliasing and makes the
    selection explicit rather than link-order dependent.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 65c093145dac..55ed653c7a67 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -42,6 +42,13 @@ extern void * __rd_start, * __rd_end;
  * The bigger value means no problem.
  */
 struct sh_cpuinfo boot_cpu_data = { CPU_SH_NONE, 10000000, };
+
+/*
+ * The machine vector. First entry in .machvec.init, or clobbered by
+ * sh_mv= on the command line, prior to .machvec.init teardown.
+ */
+struct sh_machine_vector sh_mv = { .mv_name = "Unknown", };
+
 #ifdef CONFIG_VT
 struct screen_info screen_info;
 #endif

commit ba36197cf4ff68f631bb1b3d4cc442d567279fe3
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon May 14 17:48:00 2007 +0900

    sh: Fixup cmdline handling from machvec changes.
    
    The command line wasn't being saved off properly after the machvec
    changes went in, fix it up.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 0ad715833990..65c093145dac 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -194,10 +194,6 @@ void __init setup_arch(char **cmdline_p)
 {
 	enable_mmu();
 
-#ifdef CONFIG_CMDLINE_BOOL
-	strcpy(COMMAND_LINE, CONFIG_CMDLINE);
-#endif
-
 	ROOT_DEV = old_decode_dev(ORIG_ROOT_DEV);
 
 #ifdef CONFIG_BLK_DEV_RAM
@@ -221,9 +217,14 @@ void __init setup_arch(char **cmdline_p)
 	memory_start = (unsigned long)PAGE_OFFSET+__MEMORY_START;
 	memory_end = memory_start + __MEMORY_SIZE;
 
-	/* Save unparsed command line copy for /proc/cmdline */
-	strlcpy(boot_command_line, COMMAND_LINE, COMMAND_LINE_SIZE);
+#ifdef CONFIG_CMDLINE_BOOL
+	strlcpy(command_line, CONFIG_CMDLINE, sizeof(command_line));
+#else
+	strlcpy(command_line, COMMAND_LINE, sizeof(command_line));
+#endif
 
+	/* Save unparsed command line copy for /proc/cmdline */
+	memcpy(boot_command_line, command_line, COMMAND_LINE_SIZE);
 	*cmdline_p = command_line;
 
 	parse_early_param();

commit 9655ad03af2d232c3b26e7562ab4f8c29b107e49
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon May 14 15:59:09 2007 +0900

    sh: Fixup machvec support.
    
    This fixes up much of the machvec handling, allowing for it to be
    overloaded on boot. Making practical use of this still requires
    some Kconfig munging, however.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 61152b438325..0ad715833990 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -46,16 +46,8 @@ struct sh_cpuinfo boot_cpu_data = { CPU_SH_NONE, 10000000, };
 struct screen_info screen_info;
 #endif
 
-#if defined(CONFIG_SH_UNKNOWN)
-struct sh_machine_vector sh_mv;
-#endif
-
 extern int root_mountflags;
 
-#define MV_NAME_SIZE 32
-
-static struct sh_machine_vector* __init get_mv_byname(const char* name);
-
 /*
  * This is set up by the setup-routine at boot-time
  */
@@ -81,131 +73,17 @@ static struct resource data_resource = { .name = "Kernel data", };
 
 unsigned long memory_start, memory_end;
 
-static inline void parse_cmdline (char ** cmdline_p, char mv_name[MV_NAME_SIZE],
-				  struct sh_machine_vector** mvp,
-				  unsigned long *mv_io_base)
+static int __init early_parse_mem(char *p)
 {
-	char c = ' ', *to = command_line, *from = COMMAND_LINE;
-	int len = 0;
-
-	/* Save unparsed command line copy for /proc/cmdline */
-	memcpy(boot_command_line, COMMAND_LINE, COMMAND_LINE_SIZE);
-	boot_command_line[COMMAND_LINE_SIZE-1] = '\0';
+	unsigned long size;
 
 	memory_start = (unsigned long)PAGE_OFFSET+__MEMORY_START;
-	memory_end = memory_start + __MEMORY_SIZE;
-
-	for (;;) {
-		/*
-		 * "mem=XXX[kKmM]" defines a size of memory.
-		 */
-		if (c == ' ' && !memcmp(from, "mem=", 4)) {
-			if (to != command_line)
-				to--;
-			{
-				unsigned long mem_size;
-
-				mem_size = memparse(from+4, &from);
-				memory_end = memory_start + mem_size;
-			}
-		}
-
-		if (c == ' ' && !memcmp(from, "sh_mv=", 6)) {
-			char* mv_end;
-			char* mv_comma;
-			int mv_len;
-			if (to != command_line)
-				to--;
-			from += 6;
-			mv_end = strchr(from, ' ');
-			if (mv_end == NULL)
-				mv_end = from + strlen(from);
-
-			mv_comma = strchr(from, ',');
-			if ((mv_comma != NULL) && (mv_comma < mv_end)) {
-				int ints[3];
-				get_options(mv_comma+1, ARRAY_SIZE(ints), ints);
-				*mv_io_base = ints[1];
-				mv_len = mv_comma - from;
-			} else {
-				mv_len = mv_end - from;
-			}
-			if (mv_len > (MV_NAME_SIZE-1))
-				mv_len = MV_NAME_SIZE-1;
-			memcpy(mv_name, from, mv_len);
-			mv_name[mv_len] = '\0';
-			from = mv_end;
-
-			*mvp = get_mv_byname(mv_name);
-		}
-
-		c = *(from++);
-		if (!c)
-			break;
-		if (COMMAND_LINE_SIZE <= ++len)
-			break;
-		*(to++) = c;
-	}
-	*to = '\0';
-	*cmdline_p = command_line;
-}
-
-static int __init sh_mv_setup(char **cmdline_p)
-{
-#ifdef CONFIG_SH_UNKNOWN
-	extern struct sh_machine_vector mv_unknown;
-#endif
-	struct sh_machine_vector *mv = NULL;
-	char mv_name[MV_NAME_SIZE] = "";
-	unsigned long mv_io_base = 0;
-
-	parse_cmdline(cmdline_p, mv_name, &mv, &mv_io_base);
-
-#ifdef CONFIG_SH_UNKNOWN
-	if (mv == NULL) {
-		mv = &mv_unknown;
-		if (*mv_name != '\0') {
-			printk("Warning: Unsupported machine %s, using unknown\n",
-			       mv_name);
-		}
-	}
-	sh_mv = *mv;
-#endif
-
-	/*
-	 * Manually walk the vec, fill in anything that the board hasn't yet
-	 * by hand, wrapping to the generic implementation.
-	 */
-#define mv_set(elem) do { \
-	if (!sh_mv.mv_##elem) \
-		sh_mv.mv_##elem = generic_##elem; \
-} while (0)
-
-	mv_set(inb);	mv_set(inw);	mv_set(inl);
-	mv_set(outb);	mv_set(outw);	mv_set(outl);
-
-	mv_set(inb_p);	mv_set(inw_p);	mv_set(inl_p);
-	mv_set(outb_p);	mv_set(outw_p);	mv_set(outl_p);
-
-	mv_set(insb);	mv_set(insw);	mv_set(insl);
-	mv_set(outsb);	mv_set(outsw);	mv_set(outsl);
-
-	mv_set(readb);	mv_set(readw);	mv_set(readl);
-	mv_set(writeb);	mv_set(writew);	mv_set(writel);
-
-	mv_set(ioport_map);
-	mv_set(ioport_unmap);
-	mv_set(irq_demux);
-
-#ifdef CONFIG_SH_UNKNOWN
-	__set_io_port_base(mv_io_base);
-#endif
-
-	if (!sh_mv.mv_nr_irqs)
-		sh_mv.mv_nr_irqs = NR_IRQS;
+	size = memparse(p, &p);
+	memory_end = memory_start + size;
 
 	return 0;
 }
+early_param("mem", early_parse_mem);
 
 /*
  * Register fully available low RAM pages with the bootmem allocator.
@@ -340,9 +218,17 @@ void __init setup_arch(char **cmdline_p)
 	data_resource.start = virt_to_phys(_etext);
 	data_resource.end = virt_to_phys(_edata)-1;
 
+	memory_start = (unsigned long)PAGE_OFFSET+__MEMORY_START;
+	memory_end = memory_start + __MEMORY_SIZE;
+
+	/* Save unparsed command line copy for /proc/cmdline */
+	strlcpy(boot_command_line, COMMAND_LINE, COMMAND_LINE_SIZE);
+
+	*cmdline_p = command_line;
+
 	parse_early_param();
 
-	sh_mv_setup(cmdline_p);
+	sh_mv_setup();
 
 	/*
 	 * Find the highest page frame number we have available
@@ -369,26 +255,6 @@ void __init setup_arch(char **cmdline_p)
 		sh_mv.mv_setup(cmdline_p);
 }
 
-struct sh_machine_vector* __init get_mv_byname(const char* name)
-{
-	extern long __machvec_start, __machvec_end;
-	struct sh_machine_vector *all_vecs =
-		(struct sh_machine_vector *)&__machvec_start;
-
-	int i, n = ((unsigned long)&__machvec_end
-		    - (unsigned long)&__machvec_start)/
-		sizeof(struct sh_machine_vector);
-
-	for (i = 0; i < n; ++i) {
-		struct sh_machine_vector *mv = &all_vecs[i];
-		if (mv == NULL)
-			continue;
-		if (strcasecmp(name, get_system_type()) == 0) {
-			return mv;
-		}
-	}
-	return NULL;
-}
 
 static const char *cpu_name[] = {
 	[CPU_SH7206]	= "SH7206",	[CPU_SH7619]	= "SH7619",

commit 7a302a9674593259866de4a9d5ae8edc03dc1934
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon May 14 12:50:43 2007 +0900

    sh: Split out CPU topology initialization.
    
    Split out the CPU topology initialization to a separate file,
    and switch it to a percpu type, rather than an NR_CPUS array.
    
    At the same time, switch to only registering present CPUs,
    rather than using the possible CPU map.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index c27729135935..61152b438325 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -23,6 +23,7 @@
 #include <linux/kexec.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
+#include <asm/page.h>
 #include <asm/sections.h>
 #include <asm/irq.h>
 #include <asm/setup.h>
@@ -389,20 +390,6 @@ struct sh_machine_vector* __init get_mv_byname(const char* name)
 	return NULL;
 }
 
-static struct cpu cpu[NR_CPUS];
-
-static int __init topology_init(void)
-{
-	int cpu_id;
-
-	for_each_possible_cpu(cpu_id)
-		register_cpu(&cpu[cpu_id], cpu_id);
-
-	return 0;
-}
-
-subsys_initcall(topology_init);
-
 static const char *cpu_name[] = {
 	[CPU_SH7206]	= "SH7206",	[CPU_SH7619]	= "SH7619",
 	[CPU_SH7604]	= "SH7604",	[CPU_SH7300]	= "SH7300",

commit 074f98df0547b7d15f78db9a17e985da0c22af28
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue May 8 15:45:33 2007 +0900

    sh: Add 32-bit opcode feature CPU flag.
    
    Add a CPU flag for the CPUs that support 32-bit opcodes, which
    gets passed down to userspace.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 477d2a854fc4..c27729135935 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -431,7 +431,7 @@ const char *get_cpu_subtype(struct sh_cpuinfo *c)
 /* Symbolic CPU flags, keep in sync with asm/cpu-features.h */
 static const char *cpu_flags[] = {
 	"none", "fpu", "p2flush", "mmuassoc", "dsp", "perfctr",
-	"ptea", "llsc", "l2", NULL
+	"ptea", "llsc", "l2", "op32", NULL
 };
 
 static void show_cpuflags(struct seq_file *m, struct sh_cpuinfo *c)

commit 4d5ade5b29c618e97a8988efb6967cb4dd0e2183
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Apr 27 11:25:57 2007 +0900

    sh: kdump support.
    
    This adds support for kexec based crash dumps.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index cab91a7665da..477d2a854fc4 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -20,6 +20,7 @@
 #include <linux/pfn.h>
 #include <linux/fs.h>
 #include <linux/mm.h>
+#include <linux/kexec.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/sections.h>
@@ -287,6 +288,11 @@ void __init setup_bootmem_allocator(unsigned long start_pfn)
 		}
 	}
 #endif
+#ifdef CONFIG_KEXEC
+	if (crashk_res.start != crashk_res.end)
+		reserve_bootmem(crashk_res.start,
+			crashk_res.end - crashk_res.start + 1);
+#endif
 }
 
 #ifndef CONFIG_NEED_MULTIPLE_NODES

commit db62e5bd297d1f325811c5495ad23de36db0fdd4
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Apr 26 12:17:20 2007 +0900

    sh: Move clock reporting to its own proc entry.
    
    Previously this was done in cpuinfo, but with the number of clocks
    growing, it makes more sense to place this in a different proc entry.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 60cc2161438f..cab91a7665da 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -501,7 +501,7 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 		     c->loops_per_jiffy/(500000/HZ),
 		     (c->loops_per_jiffy/(5000/HZ)) % 100);
 
-	return show_clocks(m);
+	return 0;
 }
 
 static void *c_start(struct seq_file *m, loff_t *pos)

commit 01066625e9ae39742c92e21163f7f2a818e02762
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Mar 28 16:38:13 2007 +0900

    sh: bootmem tidying for discontig/sparsemem preparation.
    
    This reworks some of the node 0 bootmem initialization in
    preparation for discontigmem and sparsemem support.
    
    ARCH_POPULATES_NODE_MAP is switched to as a result of this.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 4d6d89115194..60cc2161438f 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -4,7 +4,7 @@
  * This file handles the architecture-dependent parts of initialization
  *
  *  Copyright (C) 1999  Niibe Yutaka
- *  Copyright (C) 2002 - 2006 Paul Mundt
+ *  Copyright (C) 2002 - 2007 Paul Mundt
  */
 #include <linux/screen_info.h>
 #include <linux/ioport.h>
@@ -15,15 +15,18 @@
 #include <linux/seq_file.h>
 #include <linux/root_dev.h>
 #include <linux/utsname.h>
+#include <linux/nodemask.h>
 #include <linux/cpu.h>
 #include <linux/pfn.h>
 #include <linux/fs.h>
+#include <linux/mm.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/sections.h>
 #include <asm/irq.h>
 #include <asm/setup.h>
 #include <asm/clock.h>
+#include <asm/mmu_context.h>
 
 extern void * __rd_start, * __rd_end;
 
@@ -202,53 +205,33 @@ static int __init sh_mv_setup(char **cmdline_p)
 	return 0;
 }
 
-void __init setup_arch(char **cmdline_p)
+/*
+ * Register fully available low RAM pages with the bootmem allocator.
+ */
+static void __init register_bootmem_low_pages(void)
 {
-	unsigned long bootmap_size;
-	unsigned long start_pfn, max_pfn, max_low_pfn;
-
-#ifdef CONFIG_CMDLINE_BOOL
-        strcpy(COMMAND_LINE, CONFIG_CMDLINE);
-#endif
-
-	ROOT_DEV = old_decode_dev(ORIG_ROOT_DEV);
-
-#ifdef CONFIG_BLK_DEV_RAM
-	rd_image_start = RAMDISK_FLAGS & RAMDISK_IMAGE_START_MASK;
-	rd_prompt = ((RAMDISK_FLAGS & RAMDISK_PROMPT_FLAG) != 0);
-	rd_doload = ((RAMDISK_FLAGS & RAMDISK_LOAD_FLAG) != 0);
-#endif
-
-	if (!MOUNT_ROOT_RDONLY)
-		root_mountflags &= ~MS_RDONLY;
-	init_mm.start_code = (unsigned long) _text;
-	init_mm.end_code = (unsigned long) _etext;
-	init_mm.end_data = (unsigned long) _edata;
-	init_mm.brk = (unsigned long) _end;
-
-	code_resource.start = (unsigned long)virt_to_phys(_text);
-	code_resource.end = (unsigned long)virt_to_phys(_etext)-1;
-	data_resource.start = (unsigned long)virt_to_phys(_etext);
-	data_resource.end = (unsigned long)virt_to_phys(_edata)-1;
-
-	sh_mv_setup(cmdline_p);
-
+	unsigned long curr_pfn, last_pfn, pages;
 
 	/*
-	 * Find the highest page frame number we have available
+	 * We are rounding up the start address of usable memory:
 	 */
-	max_pfn = PFN_DOWN(__pa(memory_end));
+	curr_pfn = PFN_UP(__MEMORY_START);
 
 	/*
-	 * Determine low and high memory ranges:
+	 * ... and at the end of the usable range downwards:
 	 */
-	max_low_pfn = max_pfn;
+	last_pfn = PFN_DOWN(__pa(memory_end));
 
-	/*
-	 * Partially used pages are not usable - thus
-	 * we are rounding upwards:
-	 */
-	start_pfn = PFN_UP(__pa(_end));
+	if (last_pfn > max_low_pfn)
+		last_pfn = max_low_pfn;
+
+	pages = last_pfn - curr_pfn;
+	free_bootmem(PFN_PHYS(curr_pfn), PFN_PHYS(pages));
+}
+
+void __init setup_bootmem_allocator(unsigned long start_pfn)
+{
+	unsigned long bootmap_size;
 
 	/*
 	 * Find a proper area for the bootmem bitmap. After this
@@ -256,31 +239,11 @@ void __init setup_arch(char **cmdline_p)
 	 * is intact) must be done via bootmem_alloc().
 	 */
 	bootmap_size = init_bootmem_node(NODE_DATA(0), start_pfn,
-					 __MEMORY_START>>PAGE_SHIFT,
-					 max_low_pfn);
-	/*
-	 * Register fully available low RAM pages with the bootmem allocator.
-	 */
-	{
-		unsigned long curr_pfn, last_pfn, pages;
-
-		/*
-		 * We are rounding up the start address of usable memory:
-		 */
-		curr_pfn = PFN_UP(__MEMORY_START);
-		/*
-		 * ... and at the end of the usable range downwards:
-		 */
-		last_pfn = PFN_DOWN(__pa(memory_end));
+					 min_low_pfn, max_low_pfn);
 
-		if (last_pfn > max_low_pfn)
-			last_pfn = max_low_pfn;
-
-		pages = last_pfn - curr_pfn;
-		free_bootmem_node(NODE_DATA(0), PFN_PHYS(curr_pfn),
-				  PFN_PHYS(pages));
-	}
+	register_bootmem_low_pages();
 
+	node_set_online(0);
 
 	/*
 	 * Reserve the kernel text and
@@ -289,14 +252,14 @@ void __init setup_arch(char **cmdline_p)
 	 * case of us accidentally initializing the bootmem allocator with
 	 * an invalid RAM area.
 	 */
-	reserve_bootmem_node(NODE_DATA(0), __MEMORY_START+PAGE_SIZE,
+	reserve_bootmem(__MEMORY_START+PAGE_SIZE,
 		(PFN_PHYS(start_pfn)+bootmap_size+PAGE_SIZE-1)-__MEMORY_START);
 
 	/*
 	 * reserve physical page 0 - it's a special BIOS page on many boxes,
 	 * enabling clean reboots, SMP operation, laptop functions.
 	 */
-	reserve_bootmem_node(NODE_DATA(0), __MEMORY_START, PAGE_SIZE);
+	reserve_bootmem(__MEMORY_START, PAGE_SIZE);
 
 #ifdef CONFIG_BLK_DEV_INITRD
 	ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
@@ -310,8 +273,8 @@ void __init setup_arch(char **cmdline_p)
 
 	if (LOADER_TYPE && INITRD_START) {
 		if (INITRD_START + INITRD_SIZE <= (max_low_pfn << PAGE_SHIFT)) {
-			reserve_bootmem_node(NODE_DATA(0), INITRD_START +
-						__MEMORY_START, INITRD_SIZE);
+			reserve_bootmem(INITRD_START + __MEMORY_START,
+					INITRD_SIZE);
 			initrd_start = INITRD_START + PAGE_OFFSET +
 					__MEMORY_START;
 			initrd_end = initrd_start + INITRD_SIZE;
@@ -324,6 +287,71 @@ void __init setup_arch(char **cmdline_p)
 		}
 	}
 #endif
+}
+
+#ifndef CONFIG_NEED_MULTIPLE_NODES
+static void __init setup_memory(void)
+{
+	unsigned long start_pfn;
+
+	/*
+	 * Partially used pages are not usable - thus
+	 * we are rounding upwards:
+	 */
+	start_pfn = PFN_UP(__pa(_end));
+	setup_bootmem_allocator(start_pfn);
+}
+#else
+extern void __init setup_memory(void);
+#endif
+
+void __init setup_arch(char **cmdline_p)
+{
+	enable_mmu();
+
+#ifdef CONFIG_CMDLINE_BOOL
+	strcpy(COMMAND_LINE, CONFIG_CMDLINE);
+#endif
+
+	ROOT_DEV = old_decode_dev(ORIG_ROOT_DEV);
+
+#ifdef CONFIG_BLK_DEV_RAM
+	rd_image_start = RAMDISK_FLAGS & RAMDISK_IMAGE_START_MASK;
+	rd_prompt = ((RAMDISK_FLAGS & RAMDISK_PROMPT_FLAG) != 0);
+	rd_doload = ((RAMDISK_FLAGS & RAMDISK_LOAD_FLAG) != 0);
+#endif
+
+	if (!MOUNT_ROOT_RDONLY)
+		root_mountflags &= ~MS_RDONLY;
+	init_mm.start_code = (unsigned long) _text;
+	init_mm.end_code = (unsigned long) _etext;
+	init_mm.end_data = (unsigned long) _edata;
+	init_mm.brk = (unsigned long) _end;
+
+	code_resource.start = virt_to_phys(_text);
+	code_resource.end = virt_to_phys(_etext)-1;
+	data_resource.start = virt_to_phys(_etext);
+	data_resource.end = virt_to_phys(_edata)-1;
+
+	parse_early_param();
+
+	sh_mv_setup(cmdline_p);
+
+	/*
+	 * Find the highest page frame number we have available
+	 */
+	max_pfn = PFN_DOWN(__pa(memory_end));
+
+	/*
+	 * Determine low and high memory ranges:
+	 */
+	max_low_pfn = max_pfn;
+	min_low_pfn = __MEMORY_START >> PAGE_SHIFT;
+
+	nodes_clear(node_online_map);
+	setup_memory();
+	paging_init();
+	sparse_init();
 
 #ifdef CONFIG_DUMMY_CONSOLE
 	conswitchp = &dummy_con;
@@ -332,8 +360,6 @@ void __init setup_arch(char **cmdline_p)
 	/* Perform the machine specific initialisation */
 	if (likely(sh_mv.mv_setup))
 		sh_mv.mv_setup(cmdline_p);
-
-	paging_init();
 }
 
 struct sh_machine_vector* __init get_mv_byname(const char* name)

commit 9465a54fa4a9da628091c372baa84120f8304587
Author: Nobuhiro Iwamatsu <iwamatsu@nigauri.org>
Date:   Tue Mar 27 18:13:51 2007 +0900

    sh: MS7712SE01 board support.
    
    Support the SH7712 (SH3-DSP) Solution Engine reference board.
    
    Signed-off-by: Nobuhiro Iwamatsu <iwamatsu@nigauri.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index f96490419768..4d6d89115194 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -377,6 +377,7 @@ static const char *cpu_name[] = {
 	[CPU_SH7705]	= "SH7705",	[CPU_SH7706]	= "SH7706",
 	[CPU_SH7707]	= "SH7707",	[CPU_SH7708]	= "SH7708",
 	[CPU_SH7709]	= "SH7709",	[CPU_SH7710]	= "SH7710",
+	[CPU_SH7712]	= "SH7712",
 	[CPU_SH7729]	= "SH7729",	[CPU_SH7750]	= "SH7750",
 	[CPU_SH7750S]	= "SH7750S",	[CPU_SH7750R]	= "SH7750R",
 	[CPU_SH7751]	= "SH7751",	[CPU_SH7751R]	= "SH7751R",

commit fa5da2f7bdcf885efe65a37df13907c7d72296f6
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Mar 8 17:27:37 2007 +0900

    sh: Bring kgdb back from the dead.
    
    This code has suffered quite a bit of bitrot, do some basic
    tidying to get it to a reasonably functional state again.
    This gets the basic support and the console working again.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 98802ab28211..f96490419768 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -25,11 +25,8 @@
 #include <asm/setup.h>
 #include <asm/clock.h>
 
-#ifdef CONFIG_SH_KGDB
-#include <asm/kgdb.h>
-static int kgdb_parse_options(char *options);
-#endif
 extern void * __rd_start, * __rd_end;
+
 /*
  * Machine setup..
  */
@@ -499,92 +496,3 @@ struct seq_operations cpuinfo_op = {
 	.show	= show_cpuinfo,
 };
 #endif /* CONFIG_PROC_FS */
-
-#ifdef CONFIG_SH_KGDB
-/*
- * Parse command-line kgdb options.  By default KGDB is enabled,
- * entered on error (or other action) using default serial info.
- * The command-line option can include a serial port specification
- * and an action to override default or configured behavior.
- */
-struct kgdb_sermap kgdb_sci_sermap =
-{ "ttySC", 5, kgdb_sci_setup, NULL };
-
-struct kgdb_sermap *kgdb_serlist = &kgdb_sci_sermap;
-struct kgdb_sermap *kgdb_porttype = &kgdb_sci_sermap;
-
-void kgdb_register_sermap(struct kgdb_sermap *map)
-{
-	struct kgdb_sermap *last;
-
-	for (last = kgdb_serlist; last->next; last = last->next)
-		;
-	last->next = map;
-	if (!map->namelen) {
-		map->namelen = strlen(map->name);
-	}
-}
-
-static int __init kgdb_parse_options(char *options)
-{
-	char c;
-	int baud;
-
-	/* Check for port spec (or use default) */
-
-	/* Determine port type and instance */
-	if (!memcmp(options, "tty", 3)) {
-		struct kgdb_sermap *map = kgdb_serlist;
-
-		while (map && memcmp(options, map->name, map->namelen))
-			map = map->next;
-
-		if (!map) {
-			KGDB_PRINTK("unknown port spec in %s\n", options);
-			return -1;
-		}
-
-		kgdb_porttype = map;
-		kgdb_serial_setup = map->setup_fn;
-		kgdb_portnum = options[map->namelen] - '0';
-		options += map->namelen + 1;
-
-		options = (*options == ',') ? options+1 : options;
-
-		/* Read optional parameters (baud/parity/bits) */
-		baud = simple_strtoul(options, &options, 10);
-		if (baud != 0) {
-			kgdb_baud = baud;
-
-			c = toupper(*options);
-			if (c == 'E' || c == 'O' || c == 'N') {
-				kgdb_parity = c;
-				options++;
-			}
-
-			c = *options;
-			if (c == '7' || c == '8') {
-				kgdb_bits = c;
-				options++;
-			}
-			options = (*options == ',') ? options+1 : options;
-		}
-	}
-
-	/* Check for action specification */
-	if (!memcmp(options, "halt", 4)) {
-		kgdb_halt = 1;
-		options += 4;
-	} else if (!memcmp(options, "disabled", 8)) {
-		kgdb_enabled = 0;
-		options += 8;
-	}
-
-	if (*options) {
-                KGDB_PRINTK("ignored unknown options: %s\n", options);
-		return 0;
-	}
-	return 1;
-}
-__setup("kgdb=", kgdb_parse_options);
-#endif /* CONFIG_SH_KGDB */

commit 11c1965687b0a472add948d4240dfe65a2fcb298
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Dec 25 10:19:56 2006 +0900

    sh: Fixup cpu_data references for the non-boot CPUs.
    
    There are a lot of bogus cpu_data-> references that only end up working
    for the boot CPU, convert these to current_cpu_data to fixup SMP.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index d6b817aa568f..98802ab28211 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -1,14 +1,11 @@
 /*
- *  linux/arch/sh/kernel/setup.c
+ * arch/sh/kernel/setup.c
  *
- *  Copyright (C) 1999  Niibe Yutaka
- *  Copyright (C) 2002, 2003  Paul Mundt
- */
-
-/*
  * This file handles the architecture-dependent parts of initialization
+ *
+ *  Copyright (C) 1999  Niibe Yutaka
+ *  Copyright (C) 2002 - 2006 Paul Mundt
  */
-
 #include <linux/screen_info.h>
 #include <linux/ioport.h>
 #include <linux/init.h>
@@ -395,9 +392,9 @@ static const char *cpu_name[] = {
 	[CPU_SH_NONE]	= "Unknown"
 };
 
-const char *get_cpu_subtype(void)
+const char *get_cpu_subtype(struct sh_cpuinfo *c)
 {
-	return cpu_name[boot_cpu_data.type];
+	return cpu_name[c->type];
 }
 
 #ifdef CONFIG_PROC_FS
@@ -407,19 +404,19 @@ static const char *cpu_flags[] = {
 	"ptea", "llsc", "l2", NULL
 };
 
-static void show_cpuflags(struct seq_file *m)
+static void show_cpuflags(struct seq_file *m, struct sh_cpuinfo *c)
 {
 	unsigned long i;
 
 	seq_printf(m, "cpu flags\t:");
 
-	if (!cpu_data->flags) {
+	if (!c->flags) {
 		seq_printf(m, " %s\n", cpu_flags[0]);
 		return;
 	}
 
 	for (i = 0; cpu_flags[i]; i++)
-		if ((cpu_data->flags & (1 << i)))
+		if ((c->flags & (1 << i)))
 			seq_printf(m, " %s", cpu_flags[i+1]);
 
 	seq_printf(m, "\n");
@@ -441,16 +438,20 @@ static void show_cacheinfo(struct seq_file *m, const char *type,
  */
 static int show_cpuinfo(struct seq_file *m, void *v)
 {
-	unsigned int cpu = smp_processor_id();
+	struct sh_cpuinfo *c = v;
+	unsigned int cpu = c - cpu_data;
+
+	if (!cpu_online(cpu))
+		return 0;
 
-	if (!cpu && cpu_online(cpu))
+	if (cpu == 0)
 		seq_printf(m, "machine\t\t: %s\n", get_system_type());
 
 	seq_printf(m, "processor\t: %d\n", cpu);
 	seq_printf(m, "cpu family\t: %s\n", init_utsname()->machine);
-	seq_printf(m, "cpu type\t: %s\n", get_cpu_subtype());
+	seq_printf(m, "cpu type\t: %s\n", get_cpu_subtype(c));
 
-	show_cpuflags(m);
+	show_cpuflags(m, c);
 
 	seq_printf(m, "cache type\t: ");
 
@@ -459,22 +460,22 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 	 * unified cache on the SH-2 and SH-3, as well as the harvard
 	 * style cache on the SH-4.
 	 */
-	if (boot_cpu_data.icache.flags & SH_CACHE_COMBINED) {
+	if (c->icache.flags & SH_CACHE_COMBINED) {
 		seq_printf(m, "unified\n");
-		show_cacheinfo(m, "cache", boot_cpu_data.icache);
+		show_cacheinfo(m, "cache", c->icache);
 	} else {
 		seq_printf(m, "split (harvard)\n");
-		show_cacheinfo(m, "icache", boot_cpu_data.icache);
-		show_cacheinfo(m, "dcache", boot_cpu_data.dcache);
+		show_cacheinfo(m, "icache", c->icache);
+		show_cacheinfo(m, "dcache", c->dcache);
 	}
 
 	/* Optional secondary cache */
-	if (boot_cpu_data.flags & CPU_HAS_L2_CACHE)
-		show_cacheinfo(m, "scache", boot_cpu_data.scache);
+	if (c->flags & CPU_HAS_L2_CACHE)
+		show_cacheinfo(m, "scache", c->scache);
 
 	seq_printf(m, "bogomips\t: %lu.%02lu\n",
-		     boot_cpu_data.loops_per_jiffy/(500000/HZ),
-		     (boot_cpu_data.loops_per_jiffy/(5000/HZ)) % 100);
+		     c->loops_per_jiffy/(500000/HZ),
+		     (c->loops_per_jiffy/(5000/HZ)) % 100);
 
 	return show_clocks(m);
 }

commit 53c82622c2db808c015953336faecefc0ebf29bc
Author: Alon Bar-Lev <alon.barlev@gmail.com>
Date:   Mon Feb 12 00:54:19 2007 -0800

    [PATCH] Dynamic kernel command-line: sh
    
    1. Rename saved_command_line into boot_command_line.
    2. Set command_line as __initdata.
    
    Signed-off-by: Alon Bar-Lev <alon.barlev@gmail.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 225f9ea5cdd7..d6b817aa568f 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -75,7 +75,7 @@ static struct sh_machine_vector* __init get_mv_byname(const char* name);
 #define RAMDISK_PROMPT_FLAG		0x8000
 #define RAMDISK_LOAD_FLAG		0x4000
 
-static char command_line[COMMAND_LINE_SIZE] = { 0, };
+static char __initdata command_line[COMMAND_LINE_SIZE] = { 0, };
 
 static struct resource code_resource = { .name = "Kernel code", };
 static struct resource data_resource = { .name = "Kernel data", };
@@ -90,8 +90,8 @@ static inline void parse_cmdline (char ** cmdline_p, char mv_name[MV_NAME_SIZE],
 	int len = 0;
 
 	/* Save unparsed command line copy for /proc/cmdline */
-	memcpy(saved_command_line, COMMAND_LINE, COMMAND_LINE_SIZE);
-	saved_command_line[COMMAND_LINE_SIZE-1] = '\0';
+	memcpy(boot_command_line, COMMAND_LINE, COMMAND_LINE_SIZE);
+	boot_command_line[COMMAND_LINE_SIZE-1] = '\0';
 
 	memory_start = (unsigned long)PAGE_OFFSET+__MEMORY_START;
 	memory_end = memory_start + __MEMORY_SIZE;

commit b641fe016a29fe2c0c7b0d717a5918e3f067a44f
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Dec 12 09:00:47 2006 +0900

    sh: Use early_param() for earlyprintk parsing.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index fe545bbb1e1f..225f9ea5cdd7 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -84,8 +84,7 @@ unsigned long memory_start, memory_end;
 
 static inline void parse_cmdline (char ** cmdline_p, char mv_name[MV_NAME_SIZE],
 				  struct sh_machine_vector** mvp,
-				  unsigned long *mv_io_base,
-				  int *mv_mmio_enable)
+				  unsigned long *mv_io_base)
 {
 	char c = ' ', *to = command_line, *from = COMMAND_LINE;
 	int len = 0;
@@ -112,23 +111,6 @@ static inline void parse_cmdline (char ** cmdline_p, char mv_name[MV_NAME_SIZE],
 			}
 		}
 
-#ifdef CONFIG_EARLY_PRINTK
-		if (c == ' ' && !memcmp(from, "earlyprintk=", 12)) {
-			char *ep_end;
-
-			if (to != command_line)
-				to--;
-
-			from += 12;
-			ep_end = strchr(from, ' ');
-
-			setup_early_printk(from);
-			printk("early console enabled\n");
-
-			from = ep_end;
-		}
-#endif
-
 		if (c == ' ' && !memcmp(from, "sh_mv=", 6)) {
 			char* mv_end;
 			char* mv_comma;
@@ -145,7 +127,6 @@ static inline void parse_cmdline (char ** cmdline_p, char mv_name[MV_NAME_SIZE],
 				int ints[3];
 				get_options(mv_comma+1, ARRAY_SIZE(ints), ints);
 				*mv_io_base = ints[1];
-				*mv_mmio_enable = ints[2];
 				mv_len = mv_comma - from;
 			} else {
 				mv_len = mv_end - from;
@@ -158,6 +139,7 @@ static inline void parse_cmdline (char ** cmdline_p, char mv_name[MV_NAME_SIZE],
 
 			*mvp = get_mv_byname(mv_name);
 		}
+
 		c = *(from++);
 		if (!c)
 			break;
@@ -177,9 +159,8 @@ static int __init sh_mv_setup(char **cmdline_p)
 	struct sh_machine_vector *mv = NULL;
 	char mv_name[MV_NAME_SIZE] = "";
 	unsigned long mv_io_base = 0;
-	int mv_mmio_enable = 0;
 
-	parse_cmdline(cmdline_p, mv_name, &mv, &mv_io_base, &mv_mmio_enable);
+	parse_cmdline(cmdline_p, mv_name, &mv, &mv_io_base);
 
 #ifdef CONFIG_SH_UNKNOWN
 	if (mv == NULL) {
@@ -258,6 +239,7 @@ void __init setup_arch(char **cmdline_p)
 
 	sh_mv_setup(cmdline_p);
 
+
 	/*
 	 * Find the highest page frame number we have available
 	 */
@@ -305,6 +287,7 @@ void __init setup_arch(char **cmdline_p)
 				  PFN_PHYS(pages));
 	}
 
+
 	/*
 	 * Reserve the kernel text and
 	 * Reserve the bootmem bitmap. We do this in two steps (first step

commit 41504c39726a7099e5a42508dd57fe561c8b4129
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Dec 11 20:28:03 2006 +0900

    sh: SH-MobileR SH7722 CPU support.
    
    This adds CPU support for the SH7722.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index f8dd6b7bfab0..fe545bbb1e1f 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -325,14 +325,18 @@ void __init setup_arch(char **cmdline_p)
 	ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
 	if (&__rd_start != &__rd_end) {
 		LOADER_TYPE = 1;
-		INITRD_START = PHYSADDR((unsigned long)&__rd_start) - __MEMORY_START;
-		INITRD_SIZE = (unsigned long)&__rd_end - (unsigned long)&__rd_start;
+		INITRD_START = PHYSADDR((unsigned long)&__rd_start) -
+					__MEMORY_START;
+		INITRD_SIZE = (unsigned long)&__rd_end -
+			      (unsigned long)&__rd_start;
 	}
 
 	if (LOADER_TYPE && INITRD_START) {
 		if (INITRD_START + INITRD_SIZE <= (max_low_pfn << PAGE_SHIFT)) {
-			reserve_bootmem_node(NODE_DATA(0), INITRD_START+__MEMORY_START, INITRD_SIZE);
-			initrd_start = INITRD_START + PAGE_OFFSET + __MEMORY_START;
+			reserve_bootmem_node(NODE_DATA(0), INITRD_START +
+						__MEMORY_START, INITRD_SIZE);
+			initrd_start = INITRD_START + PAGE_OFFSET +
+					__MEMORY_START;
 			initrd_end = initrd_start + INITRD_SIZE;
 		} else {
 			printk("initrd extends beyond end of memory "
@@ -404,7 +408,7 @@ static const char *cpu_name[] = {
 	[CPU_SH4_202]	= "SH4-202",	[CPU_SH4_501]	= "SH4-501",
 	[CPU_SH7770]	= "SH7770",	[CPU_SH7780]	= "SH7780",
 	[CPU_SH7781]	= "SH7781",	[CPU_SH7343]	= "SH7343",
-	[CPU_SH7785]	= "SH7785",
+	[CPU_SH7785]	= "SH7785",	[CPU_SH7722]	= "SH7722",
 	[CPU_SH_NONE]	= "Unknown"
 };
 

commit 19e5d9c0d2194b4b47189cbec2921cbf72b0bd1c
Author: Henry Nestler <henry.ne@arcor.de>
Date:   Wed Dec 6 20:37:45 2006 -0800

    [PATCH] initrd: remove unused false condition for initrd_start
    
    After LOADER_TYPE && INITRD_START are true, the short if-condition
    for INITRD_START can never be false.
    
    Remove unused code from the else condition.
    
    Signed-off-by: Henry Nestler <henry.ne@arcor.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 696ca75752d9..f8dd6b7bfab0 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -332,8 +332,7 @@ void __init setup_arch(char **cmdline_p)
 	if (LOADER_TYPE && INITRD_START) {
 		if (INITRD_START + INITRD_SIZE <= (max_low_pfn << PAGE_SHIFT)) {
 			reserve_bootmem_node(NODE_DATA(0), INITRD_START+__MEMORY_START, INITRD_SIZE);
-			initrd_start =
-				INITRD_START ? INITRD_START + PAGE_OFFSET + __MEMORY_START : 0;
+			initrd_start = INITRD_START + PAGE_OFFSET + __MEMORY_START;
 			initrd_end = initrd_start + INITRD_SIZE;
 		} else {
 			printk("initrd extends beyond end of memory "

commit b552c7e8bceae8a04ae79ecee6fa369c1ba4f8e4
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Nov 20 14:14:29 2006 +0900

    sh: Hook SH7785 in to the build system.
    
    Simple 7785 placeholders to start hooking up other bits of code.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index c24f6390007b..696ca75752d9 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -392,6 +392,7 @@ static int __init topology_init(void)
 subsys_initcall(topology_init);
 
 static const char *cpu_name[] = {
+	[CPU_SH7206]	= "SH7206",	[CPU_SH7619]	= "SH7619",
 	[CPU_SH7604]	= "SH7604",	[CPU_SH7300]	= "SH7300",
 	[CPU_SH7705]	= "SH7705",	[CPU_SH7706]	= "SH7706",
 	[CPU_SH7707]	= "SH7707",	[CPU_SH7708]	= "SH7708",
@@ -404,7 +405,7 @@ static const char *cpu_name[] = {
 	[CPU_SH4_202]	= "SH4-202",	[CPU_SH4_501]	= "SH4-501",
 	[CPU_SH7770]	= "SH7770",	[CPU_SH7780]	= "SH7780",
 	[CPU_SH7781]	= "SH7781",	[CPU_SH7343]	= "SH7343",
-	[CPU_SH7206]	= "SH7206",	[CPU_SH7619]	= "SH7619",
+	[CPU_SH7785]	= "SH7785",
 	[CPU_SH_NONE]	= "Unknown"
 };
 

commit 9d4436a6fbc8c5eccdfcb8f5884e0a7b4a57f6d2
Author: Yoshinori Sato <ysato@users.sourceforge.jp>
Date:   Sun Nov 5 15:40:13 2006 +0900

    sh: Add support for SH7206 and SH7619 CPU subtypes.
    
    This implements initial support for the SH7206 (SH-2A) and SH7619
    (SH-2) MMU-less CPUs.
    
    Signed-off-by: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 36d86f9ac38a..c24f6390007b 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -404,6 +404,7 @@ static const char *cpu_name[] = {
 	[CPU_SH4_202]	= "SH4-202",	[CPU_SH4_501]	= "SH4-501",
 	[CPU_SH7770]	= "SH7770",	[CPU_SH7780]	= "SH7780",
 	[CPU_SH7781]	= "SH7781",	[CPU_SH7343]	= "SH7343",
+	[CPU_SH7206]	= "SH7206",	[CPU_SH7619]	= "SH7619",
 	[CPU_SH_NONE]	= "Unknown"
 };
 

commit 711fa8096863e4b50bb97f9ebc44606dc2182ac3
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Oct 3 13:14:04 2006 +0900

    sh: build fixes for defconfigs.
    
    Get all of the defconfigs building again.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 77491cf9b259..36d86f9ac38a 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -1,5 +1,4 @@
-/* $Id: setup.c,v 1.30 2003/10/13 07:21:19 lethal Exp $
- *
+/*
  *  linux/arch/sh/kernel/setup.c
  *
  *  Copyright (C) 1999  Niibe Yutaka
@@ -21,6 +20,7 @@
 #include <linux/utsname.h>
 #include <linux/cpu.h>
 #include <linux/pfn.h>
+#include <linux/fs.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/sections.h>

commit 96b644bdec977b97a45133e5b4466ba47a7a5e65
Author: Serge E. Hallyn <serue@us.ibm.com>
Date:   Mon Oct 2 02:18:13 2006 -0700

    [PATCH] namespaces: utsname: use init_utsname when appropriate
    
    In some places, particularly drivers and __init code, the init utsns is the
    appropriate one to use.  This patch replaces those with a the init_utsname
    helper.
    
    Changes: Removed several uses of init_utsname().  Hope I picked all the
            right ones in net/ipv4/ipconfig.c.  These are now changed to
            utsname() (the per-process namespace utsname) in the previous
            patch (2/7)
    
    [akpm@osdl.org: CIFS fix]
    Signed-off-by: Serge E. Hallyn <serue@us.ibm.com>
    Cc: Kirill Korotaev <dev@openvz.org>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Herbert Poetzl <herbert@13thfloor.at>
    Cc: Andrey Savochkin <saw@sw.ru>
    Cc: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 5f587332234a..77491cf9b259 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -459,7 +459,7 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 		seq_printf(m, "machine\t\t: %s\n", get_system_type());
 
 	seq_printf(m, "processor\t: %d\n", cpu);
-	seq_printf(m, "cpu family\t: %s\n", system_utsname.machine);
+	seq_printf(m, "cpu family\t: %s\n", init_utsname()->machine);
 	seq_printf(m, "cpu type\t: %s\n", get_cpu_subtype());
 
 	show_cpuflags(m);

commit 72c35543f8cf1316773ffbd9619575bb84ac44fb
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 18:27:43 2006 +0900

    sh: Support for L2 cache on newer SH-4A CPUs.
    
    This implements preliminary support for the L2 caches found
    on newer SH-4A CPUs.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 6810de3f8ed2..5f587332234a 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -416,7 +416,7 @@ const char *get_cpu_subtype(void)
 /* Symbolic CPU flags, keep in sync with asm/cpu-features.h */
 static const char *cpu_flags[] = {
 	"none", "fpu", "p2flush", "mmuassoc", "dsp", "perfctr",
-	"ptea", "llsc", NULL
+	"ptea", "llsc", "l2", NULL
 };
 
 static void show_cpuflags(struct seq_file *m)
@@ -480,6 +480,10 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 		show_cacheinfo(m, "dcache", boot_cpu_data.dcache);
 	}
 
+	/* Optional secondary cache */
+	if (boot_cpu_data.flags & CPU_HAS_L2_CACHE)
+		show_cacheinfo(m, "scache", boot_cpu_data.scache);
+
 	seq_printf(m, "bogomips\t: %lu.%02lu\n",
 		     boot_cpu_data.loops_per_jiffy/(500000/HZ),
 		     (boot_cpu_data.loops_per_jiffy/(5000/HZ)) % 100);

commit 2220d164933a8776d1336c814e3c2e5573256d34
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 18:24:28 2006 +0900

    sh: Report movli.l/movco.l capabilities.
    
    Add llsc to cpu_flags[] and comment cpu-features.h.
    
    Signed-off-by: Jamie Lenehan <nynaeve@twibble.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index de8df969d6af..6810de3f8ed2 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -413,8 +413,10 @@ const char *get_cpu_subtype(void)
 }
 
 #ifdef CONFIG_PROC_FS
+/* Symbolic CPU flags, keep in sync with asm/cpu-features.h */
 static const char *cpu_flags[] = {
-	"none", "fpu", "p2flush", "mmuassoc", "dsp", "perfctr", "ptea", NULL
+	"none", "fpu", "p2flush", "mmuassoc", "dsp", "perfctr",
+	"ptea", "llsc", NULL
 };
 
 static void show_cpuflags(struct seq_file *m)

commit 2c7834a6f15fe6c50ed4766f1bb6f9183b9e2740
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 18:17:31 2006 +0900

    sh: machvec rework.
    
    Some more machvec overhauling and setup code cleanup. Kill off
    get_system_type() and platform_setup(), we can do these both
    through the machvec. While we're add it, kill off more useless
    mach.c's and drop some legacy cruft from setup.c.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 86ef17fe48b5..de8df969d6af 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -43,27 +43,14 @@ extern void * __rd_start, * __rd_end;
  * The bigger value means no problem.
  */
 struct sh_cpuinfo boot_cpu_data = { CPU_SH_NONE, 10000000, };
+#ifdef CONFIG_VT
 struct screen_info screen_info;
+#endif
 
 #if defined(CONFIG_SH_UNKNOWN)
 struct sh_machine_vector sh_mv;
 #endif
 
-/* We need this to satisfy some external references. */
-struct screen_info screen_info = {
-        0, 25,                  /* orig-x, orig-y */
-        0,                      /* unused */
-        0,                      /* orig-video-page */
-        0,                      /* orig-video-mode */
-        80,                     /* orig-video-cols */
-        0,0,0,                  /* ega_ax, ega_bx, ega_cx */
-        25,                     /* orig-video-lines */
-        0,                      /* orig-video-isVGA */
-        16                      /* orig-video-points */
-};
-
-extern void platform_setup(void);
-extern char *get_system_type(void);
 extern int root_mountflags;
 
 #define MV_NAME_SIZE 32
@@ -90,29 +77,8 @@ static struct sh_machine_vector* __init get_mv_byname(const char* name);
 
 static char command_line[COMMAND_LINE_SIZE] = { 0, };
 
-struct resource standard_io_resources[] = {
-	{ "dma1", 0x00, 0x1f },
-	{ "pic1", 0x20, 0x3f },
-	{ "timer", 0x40, 0x5f },
-	{ "keyboard", 0x60, 0x6f },
-	{ "dma page reg", 0x80, 0x8f },
-	{ "pic2", 0xa0, 0xbf },
-	{ "dma2", 0xc0, 0xdf },
-	{ "fpu", 0xf0, 0xff }
-};
-
-#define STANDARD_IO_RESOURCES (sizeof(standard_io_resources)/sizeof(struct resource))
-
-/* System RAM - interrupted by the 640kB-1M hole */
-#define code_resource (ram_resources[3])
-#define data_resource (ram_resources[4])
-static struct resource ram_resources[] = {
-	{ "System RAM", 0x000000, 0x09ffff, IORESOURCE_BUSY },
-	{ "System RAM", 0x100000, 0x100000, IORESOURCE_BUSY },
-	{ "Video RAM area", 0x0a0000, 0x0bffff },
-	{ "Kernel code", 0x100000, 0 },
-	{ "Kernel data", 0, 0 }
-};
+static struct resource code_resource = { .name = "Kernel code", };
+static struct resource data_resource = { .name = "Kernel data", };
 
 unsigned long memory_start, memory_end;
 
@@ -255,6 +221,9 @@ static int __init sh_mv_setup(char **cmdline_p)
 	__set_io_port_base(mv_io_base);
 #endif
 
+	if (!sh_mv.mv_nr_irqs)
+		sh_mv.mv_nr_irqs = NR_IRQS;
+
 	return 0;
 }
 
@@ -263,7 +232,6 @@ void __init setup_arch(char **cmdline_p)
 	unsigned long bootmap_size;
 	unsigned long start_pfn, max_pfn, max_low_pfn;
 
-
 #ifdef CONFIG_CMDLINE_BOOL
         strcpy(COMMAND_LINE, CONFIG_CMDLINE);
 #endif
@@ -382,14 +350,14 @@ void __init setup_arch(char **cmdline_p)
 #endif
 
 	/* Perform the machine specific initialisation */
-	platform_setup();
+	if (likely(sh_mv.mv_setup))
+		sh_mv.mv_setup(cmdline_p);
 
 	paging_init();
 }
 
 struct sh_machine_vector* __init get_mv_byname(const char* name)
 {
-	extern int strcasecmp(const char *, const char *);
 	extern long __machvec_start, __machvec_end;
 	struct sh_machine_vector *all_vecs =
 		(struct sh_machine_vector *)&__machvec_start;
@@ -467,7 +435,8 @@ static void show_cpuflags(struct seq_file *m)
 	seq_printf(m, "\n");
 }
 
-static void show_cacheinfo(struct seq_file *m, const char *type, struct cache_info info)
+static void show_cacheinfo(struct seq_file *m, const char *type,
+			   struct cache_info info)
 {
 	unsigned int cache_size;
 
@@ -624,4 +593,3 @@ static int __init kgdb_parse_options(char *options)
 }
 __setup("kgdb=", kgdb_parse_options);
 #endif /* CONFIG_SH_KGDB */
-

commit e5723e0eeb2dc16629e86d66785024ead9169000
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 17:38:11 2006 +0900

    sh: Add support for SH7706/SH7710/SH7343 CPUs.
    
    This adds support for the aforementioned CPU subtypes, and cleans
    up some build issues encountered as a result.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 4afdec071700..86ef17fe48b5 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -424,25 +424,18 @@ static int __init topology_init(void)
 subsys_initcall(topology_init);
 
 static const char *cpu_name[] = {
-	[CPU_SH7604]	= "SH7604",
-	[CPU_SH7705]	= "SH7705",
-	[CPU_SH7708]	= "SH7708",
-	[CPU_SH7729]	= "SH7729",
-	[CPU_SH7300]	= "SH7300",
-	[CPU_SH7750]	= "SH7750",
-	[CPU_SH7750S]	= "SH7750S",
-	[CPU_SH7750R]	= "SH7750R",
-	[CPU_SH7751]	= "SH7751",
-	[CPU_SH7751R]	= "SH7751R",
-	[CPU_SH7760]	= "SH7760",
-	[CPU_SH73180]	= "SH73180",
-	[CPU_ST40RA]	= "ST40RA",
-	[CPU_ST40GX1]	= "ST40GX1",
-	[CPU_SH4_202]	= "SH4-202",
-	[CPU_SH4_501]	= "SH4-501",
-	[CPU_SH7770]	= "SH7770",
-	[CPU_SH7780]	= "SH7780",
-	[CPU_SH7781]	= "SH7781",
+	[CPU_SH7604]	= "SH7604",	[CPU_SH7300]	= "SH7300",
+	[CPU_SH7705]	= "SH7705",	[CPU_SH7706]	= "SH7706",
+	[CPU_SH7707]	= "SH7707",	[CPU_SH7708]	= "SH7708",
+	[CPU_SH7709]	= "SH7709",	[CPU_SH7710]	= "SH7710",
+	[CPU_SH7729]	= "SH7729",	[CPU_SH7750]	= "SH7750",
+	[CPU_SH7750S]	= "SH7750S",	[CPU_SH7750R]	= "SH7750R",
+	[CPU_SH7751]	= "SH7751",	[CPU_SH7751R]	= "SH7751R",
+	[CPU_SH7760]	= "SH7760",	[CPU_SH73180]	= "SH73180",
+	[CPU_ST40RA]	= "ST40RA",	[CPU_ST40GX1]	= "ST40GX1",
+	[CPU_SH4_202]	= "SH4-202",	[CPU_SH4_501]	= "SH4-501",
+	[CPU_SH7770]	= "SH7770",	[CPU_SH7780]	= "SH7780",
+	[CPU_SH7781]	= "SH7781",	[CPU_SH7343]	= "SH7343",
 	[CPU_SH_NONE]	= "Unknown"
 };
 

commit 0f08f338083cc1d68788ccbccc44bd0502fc57ae
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 17:03:56 2006 +0900

    sh: More cosmetic cleanups and trivial fixes.
    
    Nothing exciting here, just trivial fixes..
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index cff8d36f91b0..4afdec071700 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -507,7 +507,7 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 	 * unified cache on the SH-2 and SH-3, as well as the harvard
 	 * style cache on the SH-4.
 	 */
-	if (test_bit(SH_CACHE_COMBINED, &(boot_cpu_data.icache.flags))) {
+	if (boot_cpu_data.icache.flags & SH_CACHE_COMBINED) {
 		seq_printf(m, "unified\n");
 		show_cacheinfo(m, "cache", boot_cpu_data.icache);
 	} else {

commit a80fd21e52cc09ff1e4d36de5781173a5b87b2dc
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Sep 27 14:26:53 2006 +0900

    sh: earlyprintk= support and cleanups.
    
    Allow multiple early printk consoles via earlyprintk=.
    
    With this change earlyprintk is no longer enabled by default,
    it must be specified on the kernel command line. Optionally
    with ,keep to prevent unreg by tty_io.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index e75189cb1db7..cff8d36f91b0 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -145,6 +145,24 @@ static inline void parse_cmdline (char ** cmdline_p, char mv_name[MV_NAME_SIZE],
 				memory_end = memory_start + mem_size;
 			}
 		}
+
+#ifdef CONFIG_EARLY_PRINTK
+		if (c == ' ' && !memcmp(from, "earlyprintk=", 12)) {
+			char *ep_end;
+
+			if (to != command_line)
+				to--;
+
+			from += 12;
+			ep_end = strchr(from, ' ');
+
+			setup_early_printk(from);
+			printk("early console enabled\n");
+
+			from = ep_end;
+		}
+#endif
+
 		if (c == ' ' && !memcmp(from, "sh_mv=", 6)) {
 			char* mv_end;
 			char* mv_comma;
@@ -245,11 +263,7 @@ void __init setup_arch(char **cmdline_p)
 	unsigned long bootmap_size;
 	unsigned long start_pfn, max_pfn, max_low_pfn;
 
-#ifdef CONFIG_EARLY_PRINTK
-	extern void enable_early_printk(void);
 
-	enable_early_printk();
-#endif
 #ifdef CONFIG_CMDLINE_BOOL
         strcpy(COMMAND_LINE, CONFIG_CMDLINE);
 #endif

commit 894673ee6122a3ce1958e1fe096901ba5356a96b
Author: Jon Smirl <jonsmir@gmail.com>
Date:   Mon Jul 10 04:44:13 2006 -0700

    [PATCH] tty: Remove include of screen_info.h from tty.h
    
    screen_info.h doesn't have anything to do with the tty layer and shouldn't be
    included by tty.h.  This patches removes the include and modifies all users to
    directly include screen_info.h.  struct screen_info is mainly used to
    communicate with the console drivers in drivers/video/console.  Note that this
    patch touches every arch and I have no way of testing it.  If there is a
    mistake the worst thing that will happen is a compile error.
    
    [akpm@osdl.org: fix arm build]
    [akpm@osdl.org: fix alpha build]
    Signed-off-by: Jon Smirl <jonsmir@gmail.com>
    Signed-off-by: Antonino Daplas <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 9af22116c9a2..e75189cb1db7 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -10,7 +10,7 @@
  * This file handles the architecture-dependent parts of initialization
  */
 
-#include <linux/tty.h>
+#include <linux/screen_info.h>
 #include <linux/ioport.h>
 #include <linux/init.h>
 #include <linux/initrd.h>

commit 76b67ed9dce69a6a329cdd66f94af1787f417b62
Author: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Date:   Tue Jun 27 02:53:41 2006 -0700

    [PATCH] node hotplug: register cpu: remove node struct
    
    With Goto-san's patch, we can add new pgdat/node at runtime.  I'm now
    considering node-hot-add with cpu + memory on ACPI.
    
    I found acpi container, which describes node, could evaluate cpu before
    memory. This means cpu-hot-add occurs before memory hot add.
    
    In most part, cpu-hot-add doesn't depend on node hot add.  But register_cpu(),
    which creates symbolic link from node to cpu, requires that node should be
    onlined before register_cpu().  When a node is onlined, its pgdat should be
    there.
    
    This patch-set holds off creating symbolic link from node to cpu
    until node is onlined.
    
    This removes node arguments from register_cpu().
    
    Now, register_cpu() requires 'struct node' as its argument.  But the array of
    struct node is now unified in driver/base/node.c now (By Goto's node hotplug
    patch).  We can get struct node in generic way.  So, this argument is not
    necessary now.
    
    This patch also guarantees add cpu under node only when node is onlined.  It
    is necessary for node-hot-add vs.  cpu-hot-add patch following this.
    
    Moreover, register_cpu calculates cpu->node_id by cpu_to_node() without regard
    to its 'struct node *root' argument.  This patch removes it.
    
    Also modify callers of register_cpu()/unregister_cpu, whose args are changed
    by register-cpu-remove-node-struct patch.
    
    [Brice.Goglin@ens-lyon.org: fix it]
    Signed-off-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Yasunori Goto <y-goto@jp.fujitsu.com>
    Cc: Ashok Raj <ashok.raj@intel.com>
    Cc: Dave Hansen <haveblue@us.ibm.com>
    Signed-off-by: Brice Goglin <Brice.Goglin@ens-lyon.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index bb229ef030f3..9af22116c9a2 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -402,7 +402,7 @@ static int __init topology_init(void)
 	int cpu_id;
 
 	for_each_possible_cpu(cpu_id)
-		register_cpu(&cpu[cpu_id], cpu_id, NULL);
+		register_cpu(&cpu[cpu_id], cpu_id);
 
 	return 0;
 }

commit bc83db4f006fcf9e9502a002b4bd448fc4511d04
Author: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Date:   Fri Mar 31 02:30:02 2006 -0800

    [PATCH] for_each_possible_cpu: sh
    
    for_each_cpu() actually iterates across all possible CPUs.  We've had mistakes
    in the past where people were using for_each_cpu() where they should have been
    iterating across only online or present CPUs.  This is inefficient and
    possibly buggy.
    
    We're renaming for_each_cpu() to for_each_possible_cpu() to avoid this in the
    future.
    
    This patch replaces for_each_cpu with for_each_possible_cpu.
    
    Signed-off-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Kazumoto Kojima <kkojima@rr.iij4u.or.jp>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 7ee4ca203616..bb229ef030f3 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -401,7 +401,7 @@ static int __init topology_init(void)
 {
 	int cpu_id;
 
-	for_each_cpu(cpu_id)
+	for_each_possible_cpu(cpu_id)
 		register_cpu(&cpu[cpu_id], cpu_id, NULL);
 
 	return 0;

commit 22a9835c350782a5c3257343713932af3ac92ee0
Author: Dave Hansen <haveblue@us.ibm.com>
Date:   Mon Mar 27 01:16:04 2006 -0800

    [PATCH] unify PFN_* macros
    
    Just about every architecture defines some macros to do operations on pfns.
     They're all virtually identical.  This patch consolidates all of them.
    
    One minor glitch is that at least i386 uses them in a very skeletal header
    file.  To keep away from #include dependency hell, I stuck the new
    definitions in a new, isolated header.
    
    Of all of the implementations, sh64 is the only one that varied by a bit.
    It used some masks to ensure that any sign-extension got ripped away before
    the arithmetic is done.  This has been posted to that sh64 maintainers and
    the development list.
    
    Compiles on x86, x86_64, ia64 and ppc64.
    
    Signed-off-by: Dave Hansen <haveblue@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index c0e79843f580..7ee4ca203616 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -20,6 +20,7 @@
 #include <linux/root_dev.h>
 #include <linux/utsname.h>
 #include <linux/cpu.h>
+#include <linux/pfn.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/sections.h>
@@ -275,10 +276,6 @@ void __init setup_arch(char **cmdline_p)
 
 	sh_mv_setup(cmdline_p);
 
-#define PFN_UP(x)	(((x) + PAGE_SIZE-1) >> PAGE_SHIFT)
-#define PFN_DOWN(x)	((x) >> PAGE_SHIFT)
-#define PFN_PHYS(x)	((x) << PAGE_SHIFT)
-
 	/*
 	 * Find the highest page frame number we have available
 	 */

commit 394e3902c55e667945f6f1c2bdbc59842cce70f7
Author: Andrew Morton <akpm@osdl.org>
Date:   Thu Mar 23 03:01:05 2006 -0800

    [PATCH] more for_each_cpu() conversions
    
    When we stop allocating percpu memory for not-possible CPUs we must not touch
    the percpu data for not-possible CPUs at all.  The correct way of doing this
    is to test cpu_possible() or to use for_each_cpu().
    
    This patch is a kernel-wide sweep of all instances of NR_CPUS.  I found very
    few instances of this bug, if any.  But the patch converts lots of open-coded
    test to use the preferred helper macros.
    
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: David Howells <dhowells@redhat.com>
    Acked-by: Kyle McMartin <kyle@parisc-linux.org>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: William Lee Irwin III <wli@holomorphy.com>
    Cc: Andi Kleen <ak@muc.de>
    Cc: Christian Zankel <chris@zankel.net>
    Cc: Philippe Elie <phil.el@wanadoo.fr>
    Cc: Nathan Scott <nathans@sgi.com>
    Cc: Jens Axboe <axboe@suse.de>
    Cc: Eric Dumazet <dada1@cosmosbay.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index a067a34e0b64..c0e79843f580 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -404,9 +404,8 @@ static int __init topology_init(void)
 {
 	int cpu_id;
 
-	for (cpu_id = 0; cpu_id < NR_CPUS; cpu_id++)
-		if (cpu_possible(cpu_id))
-			register_cpu(&cpu[cpu_id], cpu_id, NULL);
+	for_each_cpu(cpu_id)
+		register_cpu(&cpu[cpu_id], cpu_id, NULL);
 
 	return 0;
 }

commit 50373c1b7ee9cdd9b8ccaa1b58d13ad43f879908
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Feb 1 03:06:03 2006 -0800

    [PATCH] sh: unknown mach-type updates
    
    Trivial cleanup of the unknown machine type for some of the recent machvec
    changes.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 0f1fbe72cce4..a067a34e0b64 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -186,7 +186,7 @@ static inline void parse_cmdline (char ** cmdline_p, char mv_name[MV_NAME_SIZE],
 
 static int __init sh_mv_setup(char **cmdline_p)
 {
-#if defined(CONFIG_SH_UNKNOWN)
+#ifdef CONFIG_SH_UNKNOWN
 	extern struct sh_machine_vector mv_unknown;
 #endif
 	struct sh_machine_vector *mv = NULL;
@@ -196,7 +196,7 @@ static int __init sh_mv_setup(char **cmdline_p)
 
 	parse_cmdline(cmdline_p, mv_name, &mv, &mv_io_base, &mv_mmio_enable);
 
-#ifdef CONFIG_SH_GENERIC
+#ifdef CONFIG_SH_UNKNOWN
 	if (mv == NULL) {
 		mv = &mv_unknown;
 		if (*mv_name != '\0') {
@@ -206,9 +206,6 @@ static int __init sh_mv_setup(char **cmdline_p)
 	}
 	sh_mv = *mv;
 #endif
-#ifdef CONFIG_SH_UNKNOWN
-	sh_mv = mv_unknown;
-#endif
 
 	/*
 	 * Manually walk the vec, fill in anything that the board hasn't yet
@@ -231,10 +228,8 @@ static int __init sh_mv_setup(char **cmdline_p)
 	mv_set(readb);	mv_set(readw);	mv_set(readl);
 	mv_set(writeb);	mv_set(writew);	mv_set(writel);
 
-	mv_set(ioremap);
-	mv_set(iounmap);
-
-	mv_set(isa_port2addr);
+	mv_set(ioport_map);
+	mv_set(ioport_unmap);
 	mv_set(irq_demux);
 
 #ifdef CONFIG_SH_UNKNOWN

commit de02797aa744c96a90f47be7bc081ce2f74b17fd
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Feb 1 03:06:02 2006 -0800

    [PATCH] sh: Cleanup struct sh_cpuinfo for clock framework changes
    
    Now that the clock framework changes have been integrated, the manual clock
    accounting that was done in sh_cpuinfo can be dropped.
    
    Also correct a bug with running past the end of the CPU flags when there's a
    mismatch between the added flags and printed ones.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 036050b377cd..0f1fbe72cce4 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -22,10 +22,10 @@
 #include <linux/cpu.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
-#include <asm/io_generic.h>
 #include <asm/sections.h>
 #include <asm/irq.h>
 #include <asm/setup.h>
+#include <asm/clock.h>
 
 #ifdef CONFIG_SH_KGDB
 #include <asm/kgdb.h>
@@ -41,7 +41,7 @@ extern void * __rd_start, * __rd_end;
  * This value will be used at the very early stage of serial setup.
  * The bigger value means no problem.
  */
-struct sh_cpuinfo boot_cpu_data = { CPU_SH_NONE, 0, 10000000, };
+struct sh_cpuinfo boot_cpu_data = { CPU_SH_NONE, 10000000, };
 struct screen_info screen_info;
 
 #if defined(CONFIG_SH_UNKNOWN)
@@ -273,10 +273,10 @@ void __init setup_arch(char **cmdline_p)
 	init_mm.end_data = (unsigned long) _edata;
 	init_mm.brk = (unsigned long) _end;
 
-	code_resource.start = virt_to_bus(_text);
-	code_resource.end = virt_to_bus(_etext)-1;
-	data_resource.start = virt_to_bus(_etext);
-	data_resource.end = virt_to_bus(_edata)-1;
+	code_resource.start = (unsigned long)virt_to_phys(_text);
+	code_resource.end = (unsigned long)virt_to_phys(_etext)-1;
+	data_resource.start = (unsigned long)virt_to_phys(_etext);
+	data_resource.end = (unsigned long)virt_to_phys(_edata)-1;
 
 	sh_mv_setup(cmdline_p);
 
@@ -435,6 +435,9 @@ static const char *cpu_name[] = {
 	[CPU_ST40GX1]	= "ST40GX1",
 	[CPU_SH4_202]	= "SH4-202",
 	[CPU_SH4_501]	= "SH4-501",
+	[CPU_SH7770]	= "SH7770",
+	[CPU_SH7780]	= "SH7780",
+	[CPU_SH7781]	= "SH7781",
 	[CPU_SH_NONE]	= "Unknown"
 };
 
@@ -445,7 +448,7 @@ const char *get_cpu_subtype(void)
 
 #ifdef CONFIG_PROC_FS
 static const char *cpu_flags[] = {
-	"none", "fpu", "p2flush", "mmuassoc", "dsp", "perfctr",
+	"none", "fpu", "p2flush", "mmuassoc", "dsp", "perfctr", "ptea", NULL
 };
 
 static void show_cpuflags(struct seq_file *m)
@@ -459,7 +462,7 @@ static void show_cpuflags(struct seq_file *m)
 		return;
 	}
 
-	for (i = 0; i < cpu_data->flags; i++)
+	for (i = 0; cpu_flags[i]; i++)
 		if ((cpu_data->flags & (1 << i)))
 			seq_printf(m, " %s", cpu_flags[i+1]);
 
@@ -472,7 +475,8 @@ static void show_cacheinfo(struct seq_file *m, const char *type, struct cache_in
 
 	cache_size = info.ways * info.sets * info.linesz;
 
-	seq_printf(m, "%s size\t: %dKiB\n", type, cache_size >> 10);
+	seq_printf(m, "%s size\t: %2dKiB (%d-way)\n",
+		   type, cache_size >> 10, info.ways);
 }
 
 /*
@@ -511,21 +515,9 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 		     boot_cpu_data.loops_per_jiffy/(500000/HZ),
 		     (boot_cpu_data.loops_per_jiffy/(5000/HZ)) % 100);
 
-#define PRINT_CLOCK(name, value) \
-	seq_printf(m, name " clock\t: %d.%02dMHz\n", \
-		     ((value) / 1000000), ((value) % 1000000)/10000)
-	
-	PRINT_CLOCK("cpu", boot_cpu_data.cpu_clock);
-	PRINT_CLOCK("bus", boot_cpu_data.bus_clock);
-#ifdef CONFIG_CPU_SUBTYPE_ST40STB1
-	PRINT_CLOCK("memory", boot_cpu_data.memory_clock);
-#endif
-	PRINT_CLOCK("module", boot_cpu_data.module_clock);
-
-	return 0;
+	return show_clocks(m);
 }
 
-
 static void *c_start(struct seq_file *m, loff_t *pos)
 {
 	return *pos < NR_CPUS ? cpu_data + *pos : NULL;
@@ -596,7 +588,7 @@ static int __init kgdb_parse_options(char *options)
 		options += map->namelen + 1;
 
 		options = (*options == ',') ? options+1 : options;
-		
+
 		/* Read optional parameters (baud/parity/bits) */
 		baud = simple_strtoul(options, &options, 10);
 		if (baud != 0) {

commit 65463b73b14ed43368dc5961a6c3dcb0d98cfe1f
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Nov 7 00:58:24 2005 -0800

    [PATCH] sh: Drop hp690 discontig support
    
    There was only one board using this (hp690 specifically), and it just so
    happens that it's only physically discontiguous at the "normal" P1 offset.  If
    we bump up the P1 offset, it's possible to hit a shadowed region of memory
    where we suddenly become magically contiguous.
    
    As people have been using this shadowed region workaround for quite some time
    (and without any adverse effects), it's time to drop the left over discontig
    bits that no longer have any practical use (it was always very much
    hp690-centric to begin with).
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index 25b9d9ebe858..036050b377cd 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -83,9 +83,9 @@ static struct sh_machine_vector* __init get_mv_byname(const char* name);
 /* ... */
 #define COMMAND_LINE ((char *) (PARAM+0x100))
 
-#define RAMDISK_IMAGE_START_MASK  	0x07FF
+#define RAMDISK_IMAGE_START_MASK	0x07FF
 #define RAMDISK_PROMPT_FLAG		0x8000
-#define RAMDISK_LOAD_FLAG		0x4000	
+#define RAMDISK_LOAD_FLAG		0x4000
 
 static char command_line[COMMAND_LINE_SIZE] = { 0, };
 
@@ -284,18 +284,6 @@ void __init setup_arch(char **cmdline_p)
 #define PFN_DOWN(x)	((x) >> PAGE_SHIFT)
 #define PFN_PHYS(x)	((x) << PAGE_SHIFT)
 
-#ifdef CONFIG_DISCONTIGMEM
-	NODE_DATA(0)->bdata = &discontig_node_bdata[0];
-	NODE_DATA(1)->bdata = &discontig_node_bdata[1];
-
-	bootmap_size = init_bootmem_node(NODE_DATA(1), 
-					 PFN_UP(__MEMORY_START_2ND),
-					 PFN_UP(__MEMORY_START_2ND),
-					 PFN_DOWN(__MEMORY_START_2ND+__MEMORY_SIZE_2ND));
-	free_bootmem_node(NODE_DATA(1), __MEMORY_START_2ND, __MEMORY_SIZE_2ND);
-	reserve_bootmem_node(NODE_DATA(1), __MEMORY_START_2ND, bootmap_size);
-#endif
-
 	/*
 	 * Find the highest page frame number we have available
 	 */
@@ -306,10 +294,10 @@ void __init setup_arch(char **cmdline_p)
 	 */
 	max_low_pfn = max_pfn;
 
- 	/*
+	/*
 	 * Partially used pages are not usable - thus
 	 * we are rounding upwards:
- 	 */
+	 */
 	start_pfn = PFN_UP(__pa(_end));
 
 	/*
@@ -360,12 +348,12 @@ void __init setup_arch(char **cmdline_p)
 	reserve_bootmem_node(NODE_DATA(0), __MEMORY_START, PAGE_SIZE);
 
 #ifdef CONFIG_BLK_DEV_INITRD
- 	ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
- 	if (&__rd_start != &__rd_end) {
+	ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
+	if (&__rd_start != &__rd_end) {
 		LOADER_TYPE = 1;
 		INITRD_START = PHYSADDR((unsigned long)&__rd_start) - __MEMORY_START;
 		INITRD_SIZE = (unsigned long)&__rd_end - (unsigned long)&__rd_start;
- 	}
+	}
 
 	if (LOADER_TYPE && INITRD_START) {
 		if (INITRD_START + INITRD_SIZE <= (max_low_pfn << PAGE_SHIFT)) {

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
new file mode 100644
index 000000000000..25b9d9ebe858
--- /dev/null
+++ b/arch/sh/kernel/setup.c
@@ -0,0 +1,649 @@
+/* $Id: setup.c,v 1.30 2003/10/13 07:21:19 lethal Exp $
+ *
+ *  linux/arch/sh/kernel/setup.c
+ *
+ *  Copyright (C) 1999  Niibe Yutaka
+ *  Copyright (C) 2002, 2003  Paul Mundt
+ */
+
+/*
+ * This file handles the architecture-dependent parts of initialization
+ */
+
+#include <linux/tty.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/initrd.h>
+#include <linux/bootmem.h>
+#include <linux/console.h>
+#include <linux/seq_file.h>
+#include <linux/root_dev.h>
+#include <linux/utsname.h>
+#include <linux/cpu.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/io_generic.h>
+#include <asm/sections.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+
+#ifdef CONFIG_SH_KGDB
+#include <asm/kgdb.h>
+static int kgdb_parse_options(char *options);
+#endif
+extern void * __rd_start, * __rd_end;
+/*
+ * Machine setup..
+ */
+
+/*
+ * Initialize loops_per_jiffy as 10000000 (1000MIPS).
+ * This value will be used at the very early stage of serial setup.
+ * The bigger value means no problem.
+ */
+struct sh_cpuinfo boot_cpu_data = { CPU_SH_NONE, 0, 10000000, };
+struct screen_info screen_info;
+
+#if defined(CONFIG_SH_UNKNOWN)
+struct sh_machine_vector sh_mv;
+#endif
+
+/* We need this to satisfy some external references. */
+struct screen_info screen_info = {
+        0, 25,                  /* orig-x, orig-y */
+        0,                      /* unused */
+        0,                      /* orig-video-page */
+        0,                      /* orig-video-mode */
+        80,                     /* orig-video-cols */
+        0,0,0,                  /* ega_ax, ega_bx, ega_cx */
+        25,                     /* orig-video-lines */
+        0,                      /* orig-video-isVGA */
+        16                      /* orig-video-points */
+};
+
+extern void platform_setup(void);
+extern char *get_system_type(void);
+extern int root_mountflags;
+
+#define MV_NAME_SIZE 32
+
+static struct sh_machine_vector* __init get_mv_byname(const char* name);
+
+/*
+ * This is set up by the setup-routine at boot-time
+ */
+#define PARAM	((unsigned char *)empty_zero_page)
+
+#define MOUNT_ROOT_RDONLY (*(unsigned long *) (PARAM+0x000))
+#define RAMDISK_FLAGS (*(unsigned long *) (PARAM+0x004))
+#define ORIG_ROOT_DEV (*(unsigned long *) (PARAM+0x008))
+#define LOADER_TYPE (*(unsigned long *) (PARAM+0x00c))
+#define INITRD_START (*(unsigned long *) (PARAM+0x010))
+#define INITRD_SIZE (*(unsigned long *) (PARAM+0x014))
+/* ... */
+#define COMMAND_LINE ((char *) (PARAM+0x100))
+
+#define RAMDISK_IMAGE_START_MASK  	0x07FF
+#define RAMDISK_PROMPT_FLAG		0x8000
+#define RAMDISK_LOAD_FLAG		0x4000	
+
+static char command_line[COMMAND_LINE_SIZE] = { 0, };
+
+struct resource standard_io_resources[] = {
+	{ "dma1", 0x00, 0x1f },
+	{ "pic1", 0x20, 0x3f },
+	{ "timer", 0x40, 0x5f },
+	{ "keyboard", 0x60, 0x6f },
+	{ "dma page reg", 0x80, 0x8f },
+	{ "pic2", 0xa0, 0xbf },
+	{ "dma2", 0xc0, 0xdf },
+	{ "fpu", 0xf0, 0xff }
+};
+
+#define STANDARD_IO_RESOURCES (sizeof(standard_io_resources)/sizeof(struct resource))
+
+/* System RAM - interrupted by the 640kB-1M hole */
+#define code_resource (ram_resources[3])
+#define data_resource (ram_resources[4])
+static struct resource ram_resources[] = {
+	{ "System RAM", 0x000000, 0x09ffff, IORESOURCE_BUSY },
+	{ "System RAM", 0x100000, 0x100000, IORESOURCE_BUSY },
+	{ "Video RAM area", 0x0a0000, 0x0bffff },
+	{ "Kernel code", 0x100000, 0 },
+	{ "Kernel data", 0, 0 }
+};
+
+unsigned long memory_start, memory_end;
+
+static inline void parse_cmdline (char ** cmdline_p, char mv_name[MV_NAME_SIZE],
+				  struct sh_machine_vector** mvp,
+				  unsigned long *mv_io_base,
+				  int *mv_mmio_enable)
+{
+	char c = ' ', *to = command_line, *from = COMMAND_LINE;
+	int len = 0;
+
+	/* Save unparsed command line copy for /proc/cmdline */
+	memcpy(saved_command_line, COMMAND_LINE, COMMAND_LINE_SIZE);
+	saved_command_line[COMMAND_LINE_SIZE-1] = '\0';
+
+	memory_start = (unsigned long)PAGE_OFFSET+__MEMORY_START;
+	memory_end = memory_start + __MEMORY_SIZE;
+
+	for (;;) {
+		/*
+		 * "mem=XXX[kKmM]" defines a size of memory.
+		 */
+		if (c == ' ' && !memcmp(from, "mem=", 4)) {
+			if (to != command_line)
+				to--;
+			{
+				unsigned long mem_size;
+
+				mem_size = memparse(from+4, &from);
+				memory_end = memory_start + mem_size;
+			}
+		}
+		if (c == ' ' && !memcmp(from, "sh_mv=", 6)) {
+			char* mv_end;
+			char* mv_comma;
+			int mv_len;
+			if (to != command_line)
+				to--;
+			from += 6;
+			mv_end = strchr(from, ' ');
+			if (mv_end == NULL)
+				mv_end = from + strlen(from);
+
+			mv_comma = strchr(from, ',');
+			if ((mv_comma != NULL) && (mv_comma < mv_end)) {
+				int ints[3];
+				get_options(mv_comma+1, ARRAY_SIZE(ints), ints);
+				*mv_io_base = ints[1];
+				*mv_mmio_enable = ints[2];
+				mv_len = mv_comma - from;
+			} else {
+				mv_len = mv_end - from;
+			}
+			if (mv_len > (MV_NAME_SIZE-1))
+				mv_len = MV_NAME_SIZE-1;
+			memcpy(mv_name, from, mv_len);
+			mv_name[mv_len] = '\0';
+			from = mv_end;
+
+			*mvp = get_mv_byname(mv_name);
+		}
+		c = *(from++);
+		if (!c)
+			break;
+		if (COMMAND_LINE_SIZE <= ++len)
+			break;
+		*(to++) = c;
+	}
+	*to = '\0';
+	*cmdline_p = command_line;
+}
+
+static int __init sh_mv_setup(char **cmdline_p)
+{
+#if defined(CONFIG_SH_UNKNOWN)
+	extern struct sh_machine_vector mv_unknown;
+#endif
+	struct sh_machine_vector *mv = NULL;
+	char mv_name[MV_NAME_SIZE] = "";
+	unsigned long mv_io_base = 0;
+	int mv_mmio_enable = 0;
+
+	parse_cmdline(cmdline_p, mv_name, &mv, &mv_io_base, &mv_mmio_enable);
+
+#ifdef CONFIG_SH_GENERIC
+	if (mv == NULL) {
+		mv = &mv_unknown;
+		if (*mv_name != '\0') {
+			printk("Warning: Unsupported machine %s, using unknown\n",
+			       mv_name);
+		}
+	}
+	sh_mv = *mv;
+#endif
+#ifdef CONFIG_SH_UNKNOWN
+	sh_mv = mv_unknown;
+#endif
+
+	/*
+	 * Manually walk the vec, fill in anything that the board hasn't yet
+	 * by hand, wrapping to the generic implementation.
+	 */
+#define mv_set(elem) do { \
+	if (!sh_mv.mv_##elem) \
+		sh_mv.mv_##elem = generic_##elem; \
+} while (0)
+
+	mv_set(inb);	mv_set(inw);	mv_set(inl);
+	mv_set(outb);	mv_set(outw);	mv_set(outl);
+
+	mv_set(inb_p);	mv_set(inw_p);	mv_set(inl_p);
+	mv_set(outb_p);	mv_set(outw_p);	mv_set(outl_p);
+
+	mv_set(insb);	mv_set(insw);	mv_set(insl);
+	mv_set(outsb);	mv_set(outsw);	mv_set(outsl);
+
+	mv_set(readb);	mv_set(readw);	mv_set(readl);
+	mv_set(writeb);	mv_set(writew);	mv_set(writel);
+
+	mv_set(ioremap);
+	mv_set(iounmap);
+
+	mv_set(isa_port2addr);
+	mv_set(irq_demux);
+
+#ifdef CONFIG_SH_UNKNOWN
+	__set_io_port_base(mv_io_base);
+#endif
+
+	return 0;
+}
+
+void __init setup_arch(char **cmdline_p)
+{
+	unsigned long bootmap_size;
+	unsigned long start_pfn, max_pfn, max_low_pfn;
+
+#ifdef CONFIG_EARLY_PRINTK
+	extern void enable_early_printk(void);
+
+	enable_early_printk();
+#endif
+#ifdef CONFIG_CMDLINE_BOOL
+        strcpy(COMMAND_LINE, CONFIG_CMDLINE);
+#endif
+
+	ROOT_DEV = old_decode_dev(ORIG_ROOT_DEV);
+
+#ifdef CONFIG_BLK_DEV_RAM
+	rd_image_start = RAMDISK_FLAGS & RAMDISK_IMAGE_START_MASK;
+	rd_prompt = ((RAMDISK_FLAGS & RAMDISK_PROMPT_FLAG) != 0);
+	rd_doload = ((RAMDISK_FLAGS & RAMDISK_LOAD_FLAG) != 0);
+#endif
+
+	if (!MOUNT_ROOT_RDONLY)
+		root_mountflags &= ~MS_RDONLY;
+	init_mm.start_code = (unsigned long) _text;
+	init_mm.end_code = (unsigned long) _etext;
+	init_mm.end_data = (unsigned long) _edata;
+	init_mm.brk = (unsigned long) _end;
+
+	code_resource.start = virt_to_bus(_text);
+	code_resource.end = virt_to_bus(_etext)-1;
+	data_resource.start = virt_to_bus(_etext);
+	data_resource.end = virt_to_bus(_edata)-1;
+
+	sh_mv_setup(cmdline_p);
+
+#define PFN_UP(x)	(((x) + PAGE_SIZE-1) >> PAGE_SHIFT)
+#define PFN_DOWN(x)	((x) >> PAGE_SHIFT)
+#define PFN_PHYS(x)	((x) << PAGE_SHIFT)
+
+#ifdef CONFIG_DISCONTIGMEM
+	NODE_DATA(0)->bdata = &discontig_node_bdata[0];
+	NODE_DATA(1)->bdata = &discontig_node_bdata[1];
+
+	bootmap_size = init_bootmem_node(NODE_DATA(1), 
+					 PFN_UP(__MEMORY_START_2ND),
+					 PFN_UP(__MEMORY_START_2ND),
+					 PFN_DOWN(__MEMORY_START_2ND+__MEMORY_SIZE_2ND));
+	free_bootmem_node(NODE_DATA(1), __MEMORY_START_2ND, __MEMORY_SIZE_2ND);
+	reserve_bootmem_node(NODE_DATA(1), __MEMORY_START_2ND, bootmap_size);
+#endif
+
+	/*
+	 * Find the highest page frame number we have available
+	 */
+	max_pfn = PFN_DOWN(__pa(memory_end));
+
+	/*
+	 * Determine low and high memory ranges:
+	 */
+	max_low_pfn = max_pfn;
+
+ 	/*
+	 * Partially used pages are not usable - thus
+	 * we are rounding upwards:
+ 	 */
+	start_pfn = PFN_UP(__pa(_end));
+
+	/*
+	 * Find a proper area for the bootmem bitmap. After this
+	 * bootstrap step all allocations (until the page allocator
+	 * is intact) must be done via bootmem_alloc().
+	 */
+	bootmap_size = init_bootmem_node(NODE_DATA(0), start_pfn,
+					 __MEMORY_START>>PAGE_SHIFT,
+					 max_low_pfn);
+	/*
+	 * Register fully available low RAM pages with the bootmem allocator.
+	 */
+	{
+		unsigned long curr_pfn, last_pfn, pages;
+
+		/*
+		 * We are rounding up the start address of usable memory:
+		 */
+		curr_pfn = PFN_UP(__MEMORY_START);
+		/*
+		 * ... and at the end of the usable range downwards:
+		 */
+		last_pfn = PFN_DOWN(__pa(memory_end));
+
+		if (last_pfn > max_low_pfn)
+			last_pfn = max_low_pfn;
+
+		pages = last_pfn - curr_pfn;
+		free_bootmem_node(NODE_DATA(0), PFN_PHYS(curr_pfn),
+				  PFN_PHYS(pages));
+	}
+
+	/*
+	 * Reserve the kernel text and
+	 * Reserve the bootmem bitmap. We do this in two steps (first step
+	 * was init_bootmem()), because this catches the (definitely buggy)
+	 * case of us accidentally initializing the bootmem allocator with
+	 * an invalid RAM area.
+	 */
+	reserve_bootmem_node(NODE_DATA(0), __MEMORY_START+PAGE_SIZE,
+		(PFN_PHYS(start_pfn)+bootmap_size+PAGE_SIZE-1)-__MEMORY_START);
+
+	/*
+	 * reserve physical page 0 - it's a special BIOS page on many boxes,
+	 * enabling clean reboots, SMP operation, laptop functions.
+	 */
+	reserve_bootmem_node(NODE_DATA(0), __MEMORY_START, PAGE_SIZE);
+
+#ifdef CONFIG_BLK_DEV_INITRD
+ 	ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
+ 	if (&__rd_start != &__rd_end) {
+		LOADER_TYPE = 1;
+		INITRD_START = PHYSADDR((unsigned long)&__rd_start) - __MEMORY_START;
+		INITRD_SIZE = (unsigned long)&__rd_end - (unsigned long)&__rd_start;
+ 	}
+
+	if (LOADER_TYPE && INITRD_START) {
+		if (INITRD_START + INITRD_SIZE <= (max_low_pfn << PAGE_SHIFT)) {
+			reserve_bootmem_node(NODE_DATA(0), INITRD_START+__MEMORY_START, INITRD_SIZE);
+			initrd_start =
+				INITRD_START ? INITRD_START + PAGE_OFFSET + __MEMORY_START : 0;
+			initrd_end = initrd_start + INITRD_SIZE;
+		} else {
+			printk("initrd extends beyond end of memory "
+			    "(0x%08lx > 0x%08lx)\ndisabling initrd\n",
+				    INITRD_START + INITRD_SIZE,
+				    max_low_pfn << PAGE_SHIFT);
+			initrd_start = 0;
+		}
+	}
+#endif
+
+#ifdef CONFIG_DUMMY_CONSOLE
+	conswitchp = &dummy_con;
+#endif
+
+	/* Perform the machine specific initialisation */
+	platform_setup();
+
+	paging_init();
+}
+
+struct sh_machine_vector* __init get_mv_byname(const char* name)
+{
+	extern int strcasecmp(const char *, const char *);
+	extern long __machvec_start, __machvec_end;
+	struct sh_machine_vector *all_vecs =
+		(struct sh_machine_vector *)&__machvec_start;
+
+	int i, n = ((unsigned long)&__machvec_end
+		    - (unsigned long)&__machvec_start)/
+		sizeof(struct sh_machine_vector);
+
+	for (i = 0; i < n; ++i) {
+		struct sh_machine_vector *mv = &all_vecs[i];
+		if (mv == NULL)
+			continue;
+		if (strcasecmp(name, get_system_type()) == 0) {
+			return mv;
+		}
+	}
+	return NULL;
+}
+
+static struct cpu cpu[NR_CPUS];
+
+static int __init topology_init(void)
+{
+	int cpu_id;
+
+	for (cpu_id = 0; cpu_id < NR_CPUS; cpu_id++)
+		if (cpu_possible(cpu_id))
+			register_cpu(&cpu[cpu_id], cpu_id, NULL);
+
+	return 0;
+}
+
+subsys_initcall(topology_init);
+
+static const char *cpu_name[] = {
+	[CPU_SH7604]	= "SH7604",
+	[CPU_SH7705]	= "SH7705",
+	[CPU_SH7708]	= "SH7708",
+	[CPU_SH7729]	= "SH7729",
+	[CPU_SH7300]	= "SH7300",
+	[CPU_SH7750]	= "SH7750",
+	[CPU_SH7750S]	= "SH7750S",
+	[CPU_SH7750R]	= "SH7750R",
+	[CPU_SH7751]	= "SH7751",
+	[CPU_SH7751R]	= "SH7751R",
+	[CPU_SH7760]	= "SH7760",
+	[CPU_SH73180]	= "SH73180",
+	[CPU_ST40RA]	= "ST40RA",
+	[CPU_ST40GX1]	= "ST40GX1",
+	[CPU_SH4_202]	= "SH4-202",
+	[CPU_SH4_501]	= "SH4-501",
+	[CPU_SH_NONE]	= "Unknown"
+};
+
+const char *get_cpu_subtype(void)
+{
+	return cpu_name[boot_cpu_data.type];
+}
+
+#ifdef CONFIG_PROC_FS
+static const char *cpu_flags[] = {
+	"none", "fpu", "p2flush", "mmuassoc", "dsp", "perfctr",
+};
+
+static void show_cpuflags(struct seq_file *m)
+{
+	unsigned long i;
+
+	seq_printf(m, "cpu flags\t:");
+
+	if (!cpu_data->flags) {
+		seq_printf(m, " %s\n", cpu_flags[0]);
+		return;
+	}
+
+	for (i = 0; i < cpu_data->flags; i++)
+		if ((cpu_data->flags & (1 << i)))
+			seq_printf(m, " %s", cpu_flags[i+1]);
+
+	seq_printf(m, "\n");
+}
+
+static void show_cacheinfo(struct seq_file *m, const char *type, struct cache_info info)
+{
+	unsigned int cache_size;
+
+	cache_size = info.ways * info.sets * info.linesz;
+
+	seq_printf(m, "%s size\t: %dKiB\n", type, cache_size >> 10);
+}
+
+/*
+ *	Get CPU information for use by the procfs.
+ */
+static int show_cpuinfo(struct seq_file *m, void *v)
+{
+	unsigned int cpu = smp_processor_id();
+
+	if (!cpu && cpu_online(cpu))
+		seq_printf(m, "machine\t\t: %s\n", get_system_type());
+
+	seq_printf(m, "processor\t: %d\n", cpu);
+	seq_printf(m, "cpu family\t: %s\n", system_utsname.machine);
+	seq_printf(m, "cpu type\t: %s\n", get_cpu_subtype());
+
+	show_cpuflags(m);
+
+	seq_printf(m, "cache type\t: ");
+
+	/*
+	 * Check for what type of cache we have, we support both the
+	 * unified cache on the SH-2 and SH-3, as well as the harvard
+	 * style cache on the SH-4.
+	 */
+	if (test_bit(SH_CACHE_COMBINED, &(boot_cpu_data.icache.flags))) {
+		seq_printf(m, "unified\n");
+		show_cacheinfo(m, "cache", boot_cpu_data.icache);
+	} else {
+		seq_printf(m, "split (harvard)\n");
+		show_cacheinfo(m, "icache", boot_cpu_data.icache);
+		show_cacheinfo(m, "dcache", boot_cpu_data.dcache);
+	}
+
+	seq_printf(m, "bogomips\t: %lu.%02lu\n",
+		     boot_cpu_data.loops_per_jiffy/(500000/HZ),
+		     (boot_cpu_data.loops_per_jiffy/(5000/HZ)) % 100);
+
+#define PRINT_CLOCK(name, value) \
+	seq_printf(m, name " clock\t: %d.%02dMHz\n", \
+		     ((value) / 1000000), ((value) % 1000000)/10000)
+	
+	PRINT_CLOCK("cpu", boot_cpu_data.cpu_clock);
+	PRINT_CLOCK("bus", boot_cpu_data.bus_clock);
+#ifdef CONFIG_CPU_SUBTYPE_ST40STB1
+	PRINT_CLOCK("memory", boot_cpu_data.memory_clock);
+#endif
+	PRINT_CLOCK("module", boot_cpu_data.module_clock);
+
+	return 0;
+}
+
+
+static void *c_start(struct seq_file *m, loff_t *pos)
+{
+	return *pos < NR_CPUS ? cpu_data + *pos : NULL;
+}
+static void *c_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	++*pos;
+	return c_start(m, pos);
+}
+static void c_stop(struct seq_file *m, void *v)
+{
+}
+struct seq_operations cpuinfo_op = {
+	.start	= c_start,
+	.next	= c_next,
+	.stop	= c_stop,
+	.show	= show_cpuinfo,
+};
+#endif /* CONFIG_PROC_FS */
+
+#ifdef CONFIG_SH_KGDB
+/*
+ * Parse command-line kgdb options.  By default KGDB is enabled,
+ * entered on error (or other action) using default serial info.
+ * The command-line option can include a serial port specification
+ * and an action to override default or configured behavior.
+ */
+struct kgdb_sermap kgdb_sci_sermap =
+{ "ttySC", 5, kgdb_sci_setup, NULL };
+
+struct kgdb_sermap *kgdb_serlist = &kgdb_sci_sermap;
+struct kgdb_sermap *kgdb_porttype = &kgdb_sci_sermap;
+
+void kgdb_register_sermap(struct kgdb_sermap *map)
+{
+	struct kgdb_sermap *last;
+
+	for (last = kgdb_serlist; last->next; last = last->next)
+		;
+	last->next = map;
+	if (!map->namelen) {
+		map->namelen = strlen(map->name);
+	}
+}
+
+static int __init kgdb_parse_options(char *options)
+{
+	char c;
+	int baud;
+
+	/* Check for port spec (or use default) */
+
+	/* Determine port type and instance */
+	if (!memcmp(options, "tty", 3)) {
+		struct kgdb_sermap *map = kgdb_serlist;
+
+		while (map && memcmp(options, map->name, map->namelen))
+			map = map->next;
+
+		if (!map) {
+			KGDB_PRINTK("unknown port spec in %s\n", options);
+			return -1;
+		}
+
+		kgdb_porttype = map;
+		kgdb_serial_setup = map->setup_fn;
+		kgdb_portnum = options[map->namelen] - '0';
+		options += map->namelen + 1;
+
+		options = (*options == ',') ? options+1 : options;
+		
+		/* Read optional parameters (baud/parity/bits) */
+		baud = simple_strtoul(options, &options, 10);
+		if (baud != 0) {
+			kgdb_baud = baud;
+
+			c = toupper(*options);
+			if (c == 'E' || c == 'O' || c == 'N') {
+				kgdb_parity = c;
+				options++;
+			}
+
+			c = *options;
+			if (c == '7' || c == '8') {
+				kgdb_bits = c;
+				options++;
+			}
+			options = (*options == ',') ? options+1 : options;
+		}
+	}
+
+	/* Check for action specification */
+	if (!memcmp(options, "halt", 4)) {
+		kgdb_halt = 1;
+		options += 4;
+	} else if (!memcmp(options, "disabled", 8)) {
+		kgdb_enabled = 0;
+		options += 8;
+	}
+
+	if (*options) {
+                KGDB_PRINTK("ignored unknown options: %s\n", options);
+		return 0;
+	}
+	return 1;
+}
+__setup("kgdb=", kgdb_parse_options);
+#endif /* CONFIG_SH_KGDB */
+
