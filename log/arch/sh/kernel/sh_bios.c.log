commit 5933f6d220403b55772d2caf48a9a39d777fd630
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 28 00:32:24 2018 -0800

    sh: kernel: convert to SPDX identifiers
    
    Update license to use SPDX-License-Identifier instead of verbose license
    text.
    
    Link: http://lkml.kernel.org/r/8736rccswn.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/sh_bios.c b/arch/sh/kernel/sh_bios.c
index fe584e516964..250dbdf3fa74 100644
--- a/arch/sh/kernel/sh_bios.c
+++ b/arch/sh/kernel/sh_bios.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *  C interface for trapping into the standard LinuxSH BIOS.
  *
@@ -5,10 +6,6 @@
  *  Copyright (C) 1999, 2000  Niibe Yutaka
  *  Copyright (C) 2002  M. R. Brown
  *  Copyright (C) 2004 - 2010  Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 #include <linux/module.h>
 #include <linux/console.h>

commit d0380e6c3c0f6edb986d8798a23acfaf33d5df23
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Apr 29 16:17:18 2013 -0700

    early_printk: consolidate random copies of identical code
    
    The early console implementations are the same all over the place.  Move
    the print function to kernel/printk and get rid of the copies.
    
    [akpm@linux-foundation.org: arch/mips/kernel/early_printk.c needs kernel.h for va_list]
    [paul.gortmaker@windriver.com: sh4: make the bios early console support depend on EARLY_PRINTK]
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Richard Weinberger <richard@nod.at>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Tested-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/kernel/sh_bios.c b/arch/sh/kernel/sh_bios.c
index 47475cca068a..fe584e516964 100644
--- a/arch/sh/kernel/sh_bios.c
+++ b/arch/sh/kernel/sh_bios.c
@@ -104,6 +104,7 @@ void sh_bios_vbr_reload(void)
 		);
 }
 
+#ifdef CONFIG_EARLY_PRINTK
 /*
  *	Print a string through the BIOS
  */
@@ -144,8 +145,6 @@ static struct console bios_console = {
 	.index		= -1,
 };
 
-static struct console *early_console;
-
 static int __init setup_early_printk(char *buf)
 {
 	int keep_early = 0;
@@ -170,3 +169,4 @@ static int __init setup_early_printk(char *buf)
 	return 0;
 }
 early_param("earlyprintk", setup_early_printk);
+#endif

commit 94cd049522136c2f3bbe063d2e98b2b8d4286fd3
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jan 12 18:42:52 2010 +0900

    sh: sh_bios detection.
    
    This adds some VBR sanity checks in the sh_bios code to ensure that the
    BIOS VBR is in range before blindly trapping in to it. This permits
    boards with varying boot loader configurations to always leave support
    for sh-bios enabled and it will just be disabled at run-time if not
    found.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/sh_bios.c b/arch/sh/kernel/sh_bios.c
index 29cd2526e5c4..47475cca068a 100644
--- a/arch/sh/kernel/sh_bios.c
+++ b/arch/sh/kernel/sh_bios.c
@@ -23,6 +23,8 @@
 #define BIOS_CALL_SHUTDOWN		11
 #define BIOS_CALL_GDB_DETACH		0xff
 
+void *gdb_vbr_vector = NULL;
+
 static inline long sh_bios_call(long func, long arg0, long arg1, long arg2,
 				    long arg3)
 {
@@ -32,6 +34,9 @@ static inline long sh_bios_call(long func, long arg0, long arg1, long arg2,
 	register long r6 __asm__("r6") = arg2;
 	register long r7 __asm__("r7") = arg3;
 
+	if (!gdb_vbr_vector)
+		return -ENOSYS;
+
 	__asm__ __volatile__("trapa	#0x3f":"=z"(r0)
 			     :"0"(r0), "r"(r4), "r"(r5), "r"(r6), "r"(r7)
 			     :"memory");
@@ -60,8 +65,6 @@ void sh_bios_shutdown(unsigned int how)
 	sh_bios_call(BIOS_CALL_SHUTDOWN, how, 0, 0, 0);
 }
 
-void *gdb_vbr_vector = NULL;
-
 /*
  * Read the old value of the VBR register to initialise the vector
  * through which debug and BIOS traps are delegated by the Linux trap
@@ -76,8 +79,12 @@ void sh_bios_vbr_init(void)
 
 	__asm__ __volatile__ ("stc vbr, %0" : "=r" (vbr));
 
-	gdb_vbr_vector = (void *)(vbr + 0x100);
-	printk(KERN_NOTICE "Setting GDB trap vector to %p\n", gdb_vbr_vector);
+	if (vbr) {
+		gdb_vbr_vector = (void *)(vbr + 0x100);
+		printk(KERN_NOTICE "Setting GDB trap vector to %p\n",
+		       gdb_vbr_vector);
+	} else
+		printk(KERN_NOTICE "SH-BIOS not detected\n");
 }
 
 /**

commit 776258df925acd0563f471ee4b3f19bbffb3c04f
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jan 12 15:31:20 2010 +0900

    sh: Consolidate the sh_bios earlyprintk code.
    
    Now that the sh-sci earlyprintk is taken care of by the sh-sci driver
    directly, there's no longer any reason for having a split-out
    early_printk framework. sh_bios is the only other thing that uses it, so
    we just migrate the leftovers in to there. As it's possible to have
    multiple early_param()'s for the same string, there's not much point in
    having this split out anymore anyways, particularly since the sh_bios
    dependencies are still special-cased within sh-sci itself.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/sh_bios.c b/arch/sh/kernel/sh_bios.c
index 2a9c6d50d2c0..29cd2526e5c4 100644
--- a/arch/sh/kernel/sh_bios.c
+++ b/arch/sh/kernel/sh_bios.c
@@ -1,17 +1,26 @@
 /*
- *  linux/arch/sh/kernel/sh_bios.c
  *  C interface for trapping into the standard LinuxSH BIOS.
  *
  *  Copyright (C) 2000 Greg Banks, Mitch Davis
+ *  Copyright (C) 1999, 2000  Niibe Yutaka
+ *  Copyright (C) 2002  M. R. Brown
+ *  Copyright (C) 2004 - 2010  Paul Mundt
  *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
  */
 #include <linux/module.h>
+#include <linux/console.h>
+#include <linux/tty.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/delay.h>
 #include <asm/sh_bios.h>
 
 #define BIOS_CALL_CONSOLE_WRITE		0
 #define BIOS_CALL_ETH_NODE_ADDR		10
 #define BIOS_CALL_SHUTDOWN		11
-#define BIOS_CALL_CHAR_OUT		0x1f	/* TODO: hack */
 #define BIOS_CALL_GDB_DETACH		0xff
 
 static inline long sh_bios_call(long func, long arg0, long arg1, long arg2,
@@ -87,3 +96,70 @@ void sh_bios_vbr_reload(void)
 			: "memory"
 		);
 }
+
+/*
+ *	Print a string through the BIOS
+ */
+static void sh_console_write(struct console *co, const char *s,
+				 unsigned count)
+{
+	sh_bios_console_write(s, count);
+}
+
+/*
+ *	Setup initial baud/bits/parity. We do two things here:
+ *	- construct a cflag setting for the first rs_open()
+ *	- initialize the serial port
+ *	Return non-zero if we didn't find a serial port.
+ */
+static int __init sh_console_setup(struct console *co, char *options)
+{
+	int	cflag = CREAD | HUPCL | CLOCAL;
+
+	/*
+	 *	Now construct a cflag setting.
+	 *	TODO: this is a totally bogus cflag, as we have
+	 *	no idea what serial settings the BIOS is using, or
+	 *	even if its using the serial port at all.
+	 */
+	cflag |= B115200 | CS8 | /*no parity*/0;
+
+	co->cflag = cflag;
+
+	return 0;
+}
+
+static struct console bios_console = {
+	.name		= "bios",
+	.write		= sh_console_write,
+	.setup		= sh_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+};
+
+static struct console *early_console;
+
+static int __init setup_early_printk(char *buf)
+{
+	int keep_early = 0;
+
+	if (!buf)
+		return 0;
+
+	if (strstr(buf, "keep"))
+		keep_early = 1;
+
+	if (!strncmp(buf, "bios", 4))
+		early_console = &bios_console;
+
+	if (likely(early_console)) {
+		if (keep_early)
+			early_console->flags &= ~CON_BOOT;
+		else
+			early_console->flags |= CON_BOOT;
+		register_console(early_console);
+	}
+
+	return 0;
+}
+early_param("earlyprintk", setup_early_printk);

commit b9303a79567d4a45b015dff7e71dd24923332d8d
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jan 12 15:26:11 2010 +0900

    sh: Kill off more unused sh_bios callbacks.
    
    sh_bios_char_out() is not used by anything in-tree these days, so just
    get rid of it.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/sh_bios.c b/arch/sh/kernel/sh_bios.c
index 2a5f2e0d505d..2a9c6d50d2c0 100644
--- a/arch/sh/kernel/sh_bios.c
+++ b/arch/sh/kernel/sh_bios.c
@@ -34,11 +34,6 @@ void sh_bios_console_write(const char *buf, unsigned int len)
 	sh_bios_call(BIOS_CALL_CONSOLE_WRITE, (long)buf, (long)len, 0, 0);
 }
 
-void sh_bios_char_out(char ch)
-{
-	sh_bios_call(BIOS_CALL_CHAR_OUT, ch, 0, 0, 0);
-}
-
 void sh_bios_gdb_detach(void)
 {
 	sh_bios_call(BIOS_CALL_GDB_DETACH, 0, 0, 0, 0);

commit 191d0d24b632eb69767705acded5cbf7449ad457
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jan 12 14:50:43 2010 +0900

    sh: Tidy up the sh bios VBR handling.
    
    This moves the VBR handling out of the main trap handling code and in to
    the sh-bios helper code. A couple of accessors are added in order to
    permit other kernel code to get at the VBR value for state save/restore
    paths.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/sh_bios.c b/arch/sh/kernel/sh_bios.c
index c852f7805728..2a5f2e0d505d 100644
--- a/arch/sh/kernel/sh_bios.c
+++ b/arch/sh/kernel/sh_bios.c
@@ -55,3 +55,40 @@ void sh_bios_shutdown(unsigned int how)
 {
 	sh_bios_call(BIOS_CALL_SHUTDOWN, how, 0, 0, 0);
 }
+
+void *gdb_vbr_vector = NULL;
+
+/*
+ * Read the old value of the VBR register to initialise the vector
+ * through which debug and BIOS traps are delegated by the Linux trap
+ * handler.
+ */
+void sh_bios_vbr_init(void)
+{
+	unsigned long vbr;
+
+	if (unlikely(gdb_vbr_vector))
+		return;
+
+	__asm__ __volatile__ ("stc vbr, %0" : "=r" (vbr));
+
+	gdb_vbr_vector = (void *)(vbr + 0x100);
+	printk(KERN_NOTICE "Setting GDB trap vector to %p\n", gdb_vbr_vector);
+}
+
+/**
+ * sh_bios_vbr_reload - Re-load the system VBR from the BIOS vector.
+ *
+ * This can be used by save/restore code to reinitialize the system VBR
+ * from the fixed BIOS VBR. A no-op if no BIOS VBR is known.
+ */
+void sh_bios_vbr_reload(void)
+{
+	if (gdb_vbr_vector)
+		__asm__ __volatile__ (
+			"ldc %0, vbr"
+			:
+			: "r" (((unsigned long) gdb_vbr_vector) - 0x100)
+			: "memory"
+		);
+}

commit ca0c14e447a399eb90a1c9a4357560c2a29ef499
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Dec 17 11:47:59 2008 +0900

    sh: Kill off sh_bios_in_gdb_mode().
    
    With the reworked kgdb support, we always detach and reinitialize the
    stub. This was mostly a feature for handoffs between sh-ipl+g and the
    kgdb stub, but virtually no sh-ipl+g versions ever had this working
    right in the first place.
    
    Given that the sh-ipl+g stubs in general use today don't even support
    the GDB stub, and we have already killed off the special casing in the
    sh-sci serial driver, kill off this now unused symbol too.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/sh_bios.c b/arch/sh/kernel/sh_bios.c
index ae64e6df2957..c852f7805728 100644
--- a/arch/sh/kernel/sh_bios.c
+++ b/arch/sh/kernel/sh_bios.c
@@ -9,11 +9,9 @@
 #include <asm/sh_bios.h>
 
 #define BIOS_CALL_CONSOLE_WRITE		0
-#define BIOS_CALL_READ_BLOCK		1
 #define BIOS_CALL_ETH_NODE_ADDR		10
 #define BIOS_CALL_SHUTDOWN		11
 #define BIOS_CALL_CHAR_OUT		0x1f	/* TODO: hack */
-#define BIOS_CALL_GDB_GET_MODE_PTR	0xfe
 #define BIOS_CALL_GDB_DETACH		0xff
 
 static inline long sh_bios_call(long func, long arg0, long arg1, long arg2,
@@ -41,21 +39,6 @@ void sh_bios_char_out(char ch)
 	sh_bios_call(BIOS_CALL_CHAR_OUT, ch, 0, 0, 0);
 }
 
-int sh_bios_in_gdb_mode(void)
-{
-	static char queried = 0;
-	static char *gdb_mode_p = 0;
-
-	if (!queried) {
-		/* Query the gdb stub for address of its gdb mode variable */
-		long r = sh_bios_call(BIOS_CALL_GDB_GET_MODE_PTR, 0, 0, 0, 0);
-		if (r != ~0)	/* BIOS returns -1 for unknown function */
-			gdb_mode_p = (char *)r;
-		queried = 1;
-	}
-	return (gdb_mode_p != 0 ? *gdb_mode_p : 0);
-}
-
 void sh_bios_gdb_detach(void)
 {
 	sh_bios_call(BIOS_CALL_GDB_DETACH, 0, 0, 0, 0);

commit a9df1ed92fc46cb7c9a9c6b74dbd8bbdc41f69ce
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Dec 17 11:39:33 2008 +0900

    sh: export sh_bios_get_node_addr() symbol for stnic module.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/sh_bios.c b/arch/sh/kernel/sh_bios.c
index 7c8c58ec5dec..ae64e6df2957 100644
--- a/arch/sh/kernel/sh_bios.c
+++ b/arch/sh/kernel/sh_bios.c
@@ -60,13 +60,13 @@ void sh_bios_gdb_detach(void)
 {
 	sh_bios_call(BIOS_CALL_GDB_DETACH, 0, 0, 0, 0);
 }
-
-EXPORT_SYMBOL(sh_bios_gdb_detach);
+EXPORT_SYMBOL_GPL(sh_bios_gdb_detach);
 
 void sh_bios_get_node_addr(unsigned char *node_addr)
 {
 	sh_bios_call(BIOS_CALL_ETH_NODE_ADDR, 0, (long)node_addr, 0, 0);
 }
+EXPORT_SYMBOL_GPL(sh_bios_get_node_addr);
 
 void sh_bios_shutdown(unsigned int how)
 {

commit 8e32018b0428038b492dad5b19e80bf7d6dc002d
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Dec 17 11:37:51 2008 +0900

    sh: Run sh_bios through a long overdue Lindent.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/sh_bios.c b/arch/sh/kernel/sh_bios.c
index d1bcac4fa269..7c8c58ec5dec 100644
--- a/arch/sh/kernel/sh_bios.c
+++ b/arch/sh/kernel/sh_bios.c
@@ -8,69 +8,67 @@
 #include <linux/module.h>
 #include <asm/sh_bios.h>
 
-#define BIOS_CALL_CONSOLE_WRITE     	0
-#define BIOS_CALL_READ_BLOCK     	1
+#define BIOS_CALL_CONSOLE_WRITE		0
+#define BIOS_CALL_READ_BLOCK		1
 #define BIOS_CALL_ETH_NODE_ADDR		10
 #define BIOS_CALL_SHUTDOWN		11
-#define BIOS_CALL_CHAR_OUT     	    	0x1f  	/* TODO: hack */
-#define BIOS_CALL_GDB_GET_MODE_PTR     	0xfe
-#define BIOS_CALL_GDB_DETACH     	0xff
+#define BIOS_CALL_CHAR_OUT		0x1f	/* TODO: hack */
+#define BIOS_CALL_GDB_GET_MODE_PTR	0xfe
+#define BIOS_CALL_GDB_DETACH		0xff
 
-static __inline__ long sh_bios_call(long func, long arg0, long arg1, long arg2, long arg3)
+static inline long sh_bios_call(long func, long arg0, long arg1, long arg2,
+				    long arg3)
 {
-    register long r0 __asm__("r0") = func;
-    register long r4 __asm__("r4") = arg0;
-    register long r5 __asm__("r5") = arg1;
-    register long r6 __asm__("r6") = arg2;
-    register long r7 __asm__("r7") = arg3;
-    __asm__ __volatile__("trapa	#0x3f"
-	 : "=z" (r0)
-	 : "0" (r0), "r" (r4), "r" (r5), "r" (r6), "r" (r7)
-	 : "memory");
-    return r0;
-}
+	register long r0 __asm__("r0") = func;
+	register long r4 __asm__("r4") = arg0;
+	register long r5 __asm__("r5") = arg1;
+	register long r6 __asm__("r6") = arg2;
+	register long r7 __asm__("r7") = arg3;
 
+	__asm__ __volatile__("trapa	#0x3f":"=z"(r0)
+			     :"0"(r0), "r"(r4), "r"(r5), "r"(r6), "r"(r7)
+			     :"memory");
+	return r0;
+}
 
 void sh_bios_console_write(const char *buf, unsigned int len)
 {
-    sh_bios_call(BIOS_CALL_CONSOLE_WRITE, (long)buf, (long)len, 0, 0);
+	sh_bios_call(BIOS_CALL_CONSOLE_WRITE, (long)buf, (long)len, 0, 0);
 }
 
-
 void sh_bios_char_out(char ch)
 {
-    sh_bios_call(BIOS_CALL_CHAR_OUT, ch, 0, 0, 0);
+	sh_bios_call(BIOS_CALL_CHAR_OUT, ch, 0, 0, 0);
 }
 
-
 int sh_bios_in_gdb_mode(void)
 {
-    static char queried = 0;
-    static char *gdb_mode_p = 0;
+	static char queried = 0;
+	static char *gdb_mode_p = 0;
 
-    if (!queried)
-    {
-    	/* Query the gdb stub for address of its gdb mode variable */
-    	long r = sh_bios_call(BIOS_CALL_GDB_GET_MODE_PTR, 0, 0, 0, 0);
-	if (r != ~0)	/* BIOS returns -1 for unknown function */
-	    gdb_mode_p = (char *)r;
-	queried = 1;
-    }
-    return (gdb_mode_p != 0 ? *gdb_mode_p : 0);
+	if (!queried) {
+		/* Query the gdb stub for address of its gdb mode variable */
+		long r = sh_bios_call(BIOS_CALL_GDB_GET_MODE_PTR, 0, 0, 0, 0);
+		if (r != ~0)	/* BIOS returns -1 for unknown function */
+			gdb_mode_p = (char *)r;
+		queried = 1;
+	}
+	return (gdb_mode_p != 0 ? *gdb_mode_p : 0);
 }
 
 void sh_bios_gdb_detach(void)
 {
-    sh_bios_call(BIOS_CALL_GDB_DETACH, 0, 0, 0, 0);
+	sh_bios_call(BIOS_CALL_GDB_DETACH, 0, 0, 0, 0);
 }
+
 EXPORT_SYMBOL(sh_bios_gdb_detach);
 
-void sh_bios_get_node_addr (unsigned char *node_addr)
+void sh_bios_get_node_addr(unsigned char *node_addr)
 {
-    sh_bios_call(BIOS_CALL_ETH_NODE_ADDR, 0, (long)node_addr, 0, 0);
+	sh_bios_call(BIOS_CALL_ETH_NODE_ADDR, 0, (long)node_addr, 0, 0);
 }
 
 void sh_bios_shutdown(unsigned int how)
 {
-    sh_bios_call(BIOS_CALL_SHUTDOWN, how, 0, 0, 0);
+	sh_bios_call(BIOS_CALL_SHUTDOWN, how, 0, 0, 0);
 }

commit 98d877c487a75af78f74780703aa6b174780788d
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Jul 20 16:59:49 2007 +0900

    sh: Many symbol exports for nommu allmodconfig.
    
    allmodconfig generates a lot of interesting code, a lot of the
    generated symbols we've never exported before, so this fixes
    those up. Verified with both GCC3 and GCC4 toolchains.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/kernel/sh_bios.c b/arch/sh/kernel/sh_bios.c
index 5b53e10bb9cd..d1bcac4fa269 100644
--- a/arch/sh/kernel/sh_bios.c
+++ b/arch/sh/kernel/sh_bios.c
@@ -5,7 +5,7 @@
  *  Copyright (C) 2000 Greg Banks, Mitch Davis
  *
  */
-
+#include <linux/module.h>
 #include <asm/sh_bios.h>
 
 #define BIOS_CALL_CONSOLE_WRITE     	0
@@ -63,6 +63,7 @@ void sh_bios_gdb_detach(void)
 {
     sh_bios_call(BIOS_CALL_GDB_DETACH, 0, 0, 0, 0);
 }
+EXPORT_SYMBOL(sh_bios_gdb_detach);
 
 void sh_bios_get_node_addr (unsigned char *node_addr)
 {

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/sh/kernel/sh_bios.c b/arch/sh/kernel/sh_bios.c
new file mode 100644
index 000000000000..5b53e10bb9cd
--- /dev/null
+++ b/arch/sh/kernel/sh_bios.c
@@ -0,0 +1,75 @@
+/*
+ *  linux/arch/sh/kernel/sh_bios.c
+ *  C interface for trapping into the standard LinuxSH BIOS.
+ *
+ *  Copyright (C) 2000 Greg Banks, Mitch Davis
+ *
+ */
+
+#include <asm/sh_bios.h>
+
+#define BIOS_CALL_CONSOLE_WRITE     	0
+#define BIOS_CALL_READ_BLOCK     	1
+#define BIOS_CALL_ETH_NODE_ADDR		10
+#define BIOS_CALL_SHUTDOWN		11
+#define BIOS_CALL_CHAR_OUT     	    	0x1f  	/* TODO: hack */
+#define BIOS_CALL_GDB_GET_MODE_PTR     	0xfe
+#define BIOS_CALL_GDB_DETACH     	0xff
+
+static __inline__ long sh_bios_call(long func, long arg0, long arg1, long arg2, long arg3)
+{
+    register long r0 __asm__("r0") = func;
+    register long r4 __asm__("r4") = arg0;
+    register long r5 __asm__("r5") = arg1;
+    register long r6 __asm__("r6") = arg2;
+    register long r7 __asm__("r7") = arg3;
+    __asm__ __volatile__("trapa	#0x3f"
+	 : "=z" (r0)
+	 : "0" (r0), "r" (r4), "r" (r5), "r" (r6), "r" (r7)
+	 : "memory");
+    return r0;
+}
+
+
+void sh_bios_console_write(const char *buf, unsigned int len)
+{
+    sh_bios_call(BIOS_CALL_CONSOLE_WRITE, (long)buf, (long)len, 0, 0);
+}
+
+
+void sh_bios_char_out(char ch)
+{
+    sh_bios_call(BIOS_CALL_CHAR_OUT, ch, 0, 0, 0);
+}
+
+
+int sh_bios_in_gdb_mode(void)
+{
+    static char queried = 0;
+    static char *gdb_mode_p = 0;
+
+    if (!queried)
+    {
+    	/* Query the gdb stub for address of its gdb mode variable */
+    	long r = sh_bios_call(BIOS_CALL_GDB_GET_MODE_PTR, 0, 0, 0, 0);
+	if (r != ~0)	/* BIOS returns -1 for unknown function */
+	    gdb_mode_p = (char *)r;
+	queried = 1;
+    }
+    return (gdb_mode_p != 0 ? *gdb_mode_p : 0);
+}
+
+void sh_bios_gdb_detach(void)
+{
+    sh_bios_call(BIOS_CALL_GDB_DETACH, 0, 0, 0, 0);
+}
+
+void sh_bios_get_node_addr (unsigned char *node_addr)
+{
+    sh_bios_call(BIOS_CALL_ETH_NODE_ADDR, 0, (long)node_addr, 0, 0);
+}
+
+void sh_bios_shutdown(unsigned int how)
+{
+    sh_bios_call(BIOS_CALL_SHUTDOWN, how, 0, 0, 0);
+}
