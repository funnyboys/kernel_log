commit 2e1661d2673667d886cd40ad9f414cb6db48d8da
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu May 23 11:04:24 2019 -0500

    signal: Remove the task parameter from force_sig_fault
    
    As synchronous exceptions really only make sense against the current
    task (otherwise how are you synchronous) remove the task parameter
    from from force_sig_fault to make it explicit that is what is going
    on.
    
    The two known exceptions that deliver a synchronous exception to a
    stopped ptraced task have already been changed to
    force_sig_fault_to_task.
    
    The callers have been changed with the following emacs regular expression
    (with obvious variations on the architectures that take more arguments)
    to avoid typos:
    
    force_sig_fault[(]\([^,]+\)[,]\([^,]+\)[,]\([^,]+\)[,]\W+current[)]
    ->
    force_sig_fault(\1,\2,\3)
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/arch/sh/math-emu/math.c b/arch/sh/math-emu/math.c
index fe261b0983cc..e8be0eca0444 100644
--- a/arch/sh/math-emu/math.c
+++ b/arch/sh/math-emu/math.c
@@ -560,7 +560,7 @@ static int ieee_fpe_handler(struct pt_regs *regs)
 			task_thread_info(tsk)->status |= TS_USEDFPU;
 		} else {
 			force_sig_fault(SIGFPE, FPE_FLTINV,
-					(void __user *)regs->pc, current);
+					(void __user *)regs->pc);
 		}
 
 		regs->pc = nextpc;

commit 351b6825b3a9f70bab080fba67aec104ff9a41d6
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Feb 7 09:25:08 2019 -0600

    signal: Explicitly call force_sig_fault on current
    
    Update the calls of force_sig_fault that pass in a variable that is
    set to current earlier to explicitly use current.
    
    This is to make the next change that removes the task parameter
    from force_sig_fault easier to verify.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/arch/sh/math-emu/math.c b/arch/sh/math-emu/math.c
index a0fa8fc88739..fe261b0983cc 100644
--- a/arch/sh/math-emu/math.c
+++ b/arch/sh/math-emu/math.c
@@ -560,7 +560,7 @@ static int ieee_fpe_handler(struct pt_regs *regs)
 			task_thread_info(tsk)->status |= TS_USEDFPU;
 		} else {
 			force_sig_fault(SIGFPE, FPE_FLTINV,
-					(void __user *)regs->pc, tsk);
+					(void __user *)regs->pc, current);
 		}
 
 		regs->pc = nextpc;

commit c65626c0cd4d3e2f43a5f62fcde4fcd594959938
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sun Apr 15 19:56:33 2018 -0500

    signal/sh: Use force_sig_fault where appropriate
    
    Filling in struct siginfo before calling force_sig_info a tedious and
    error prone process, where once in a great while the wrong fields
    are filled out, and siginfo has been inconsistently cleared.
    
    Simplify this process by using the helper force_sig_fault.  Which
    takes as a parameters all of the information it needs, ensures
    all of the fiddly bits of filling in struct siginfo are done properly
    and then calls force_sig_info.
    
    In short about a 5 line reduction in code for every time force_sig_info
    is called, which makes the calling function clearer.
    
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Rich Felker <dalias@libc.org>
    Cc: linux-sh@vger.kernel.org
    Acked-by: Rich Felker <dalias@libc.org>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/arch/sh/math-emu/math.c b/arch/sh/math-emu/math.c
index d6d2213df078..a0fa8fc88739 100644
--- a/arch/sh/math-emu/math.c
+++ b/arch/sh/math-emu/math.c
@@ -507,7 +507,6 @@ static int ieee_fpe_handler(struct pt_regs *regs)
 	unsigned short insn = *(unsigned short *)regs->pc;
 	unsigned short finsn;
 	unsigned long nextpc;
-	siginfo_t info;
 	int nib[4] = {
 		(insn >> 12) & 0xf,
 		(insn >> 8) & 0xf,
@@ -560,12 +559,8 @@ static int ieee_fpe_handler(struct pt_regs *regs)
 				~(FPSCR_CAUSE_MASK | FPSCR_FLAG_MASK);
 			task_thread_info(tsk)->status |= TS_USEDFPU;
 		} else {
-			clear_siginfo(&info);
-			info.si_signo = SIGFPE;
-			info.si_errno = 0;
-			info.si_code = FPE_FLTINV;
-			info.si_addr = (void __user *)regs->pc;
-			force_sig_info(SIGFPE, &info, tsk);
+			force_sig_fault(SIGFPE, FPE_FLTINV,
+					(void __user *)regs->pc, tsk);
 		}
 
 		regs->pc = nextpc;

commit 3eb0f5193b497083391aa05d35210d5645211eef
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Apr 17 15:26:37 2018 -0500

    signal: Ensure every siginfo we send has all bits initialized
    
    Call clear_siginfo to ensure every stack allocated siginfo is properly
    initialized before being passed to the signal sending functions.
    
    Note: It is not safe to depend on C initializers to initialize struct
    siginfo on the stack because C is allowed to skip holes when
    initializing a structure.
    
    The initialization of struct siginfo in tracehook_report_syscall_exit
    was moved from the helper user_single_step_siginfo into
    tracehook_report_syscall_exit itself, to make it clear that the local
    variable siginfo gets fully initialized.
    
    In a few cases the scope of struct siginfo has been reduced to make it
    clear that siginfo siginfo is not used on other paths in the function
    in which it is declared.
    
    Instances of using memset to initialize siginfo have been replaced
    with calls clear_siginfo for clarity.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/arch/sh/math-emu/math.c b/arch/sh/math-emu/math.c
index c86f4360c6ce..d6d2213df078 100644
--- a/arch/sh/math-emu/math.c
+++ b/arch/sh/math-emu/math.c
@@ -560,6 +560,7 @@ static int ieee_fpe_handler(struct pt_regs *regs)
 				~(FPSCR_CAUSE_MASK | FPSCR_FLAG_MASK);
 			task_thread_info(tsk)->status |= TS_USEDFPU;
 		} else {
+			clear_siginfo(&info);
 			info.si_signo = SIGFPE;
 			info.si_errno = 0;
 			info.si_code = FPE_FLTINV;

commit 3f07c0144132e4f59d88055ac8ff3e691a5fa2b8
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 8 18:51:30 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <linux/sched/signal.h>
    
    We are going to split <linux/sched/signal.h> out of <linux/sched.h>, which
    will have to be picked up from other headers and a couple of .c files.
    
    Create a trivial placeholder <linux/sched/signal.h> file that just
    maps to <linux/sched.h> to make this patch obviously correct and
    bisectable.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/sh/math-emu/math.c b/arch/sh/math-emu/math.c
index 5078cb809750..c86f4360c6ce 100644
--- a/arch/sh/math-emu/math.c
+++ b/arch/sh/math-emu/math.c
@@ -10,7 +10,7 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/types.h>
-#include <linux/sched.h>
+#include <linux/sched/signal.h>
 #include <linux/signal.h>
 #include <linux/perf_event.h>
 

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/math-emu/math.c b/arch/sh/math-emu/math.c
index 04aa55fa8c75..5078cb809750 100644
--- a/arch/sh/math-emu/math.c
+++ b/arch/sh/math-emu/math.c
@@ -14,7 +14,7 @@
 #include <linux/signal.h>
 #include <linux/perf_event.h>
 
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <asm/processor.h>
 #include <asm/io.h>
 

commit 7caf62de25554da3af00c92c11afa95dcc3592c4
Author: Bobby Bingham <koorogi@koorogi.info>
Date:   Thu Apr 3 14:46:40 2014 -0700

    sh: remove unused do_fpu_error
    
    This does not appear to have been used since commit 74d99a5e2622 ("sh:
    SH-2A FPU support") in 2007.
    
    Signed-off-by: Bobby Bingham <koorogi@koorogi.info>
    Cc: Paul Mundt <paul.mundt@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/math-emu/math.c b/arch/sh/math-emu/math.c
index b876780c1e1c..04aa55fa8c75 100644
--- a/arch/sh/math-emu/math.c
+++ b/arch/sh/math-emu/math.c
@@ -574,24 +574,6 @@ static int ieee_fpe_handler(struct pt_regs *regs)
 	return 0;
 }
 
-asmlinkage void do_fpu_error(unsigned long r4, unsigned long r5,
-			     unsigned long r6, unsigned long r7,
-			     struct pt_regs regs)
-{
-	struct task_struct *tsk = current;
-	siginfo_t info;
-
-	if (ieee_fpe_handler (&regs))
-		return;
-
-	regs.pc += 2;
-	info.si_signo = SIGFPE;
-	info.si_errno = 0;
-	info.si_code = FPE_FLTINV;
-	info.si_addr = (void __user *)regs.pc;
-	force_sig_info(SIGFPE, &info, tsk);
-}
-
 /**
  * fpu_init - Initialize FPU registers
  * @fpu: Pointer to software emulated FPU registers.

commit e839ca528718e68cad32a307dc9aabf01ef3eb05
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Disintegrate asm/system.h for SH
    
    Disintegrate asm/system.h for SH.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-sh@vger.kernel.org

diff --git a/arch/sh/math-emu/math.c b/arch/sh/math-emu/math.c
index 977195210653..b876780c1e1c 100644
--- a/arch/sh/math-emu/math.c
+++ b/arch/sh/math-emu/math.c
@@ -14,7 +14,6 @@
 #include <linux/signal.h>
 #include <linux/perf_event.h>
 
-#include <asm/system.h>
 #include <asm/uaccess.h>
 #include <asm/processor.h>
 #include <asm/io.h>

commit a8b0ca17b80e92faab46ee7179ba9e99ccb61233
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Mon Jun 27 14:41:57 2011 +0200

    perf: Remove the nmi parameter from the swevent and overflow interface
    
    The nmi parameter indicated if we could do wakeups from the current
    context, if not, we would set some state and self-IPI and let the
    resulting interrupt do the wakeup.
    
    For the various event classes:
    
      - hardware: nmi=0; PMI is in fact an NMI or we run irq_work_run from
        the PMI-tail (ARM etc.)
      - tracepoint: nmi=0; since tracepoint could be from NMI context.
      - software: nmi=[0,1]; some, like the schedule thing cannot
        perform wakeups, and hence need 0.
    
    As one can see, there is very little nmi=1 usage, and the down-side of
    not using it is that on some platforms some software events can have a
    jiffy delay in wakeup (when arch_irq_work_raise isn't implemented).
    
    The up-side however is that we can remove the nmi parameter and save a
    bunch of conditionals in fast paths.
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Michael Cree <mcree@orcon.net.nz>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Deng-Cheng Zhu <dengcheng.zhu@gmail.com>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Eric B Munson <emunson@mgebm.net>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Don Zickus <dzickus@redhat.com>
    Link: http://lkml.kernel.org/n/tip-agjev8eu666tvknpb3iaj0fg@git.kernel.org
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/sh/math-emu/math.c b/arch/sh/math-emu/math.c
index f76a5090d5d1..977195210653 100644
--- a/arch/sh/math-emu/math.c
+++ b/arch/sh/math-emu/math.c
@@ -620,7 +620,7 @@ int do_fpu_inst(unsigned short inst, struct pt_regs *regs)
 	struct task_struct *tsk = current;
 	struct sh_fpu_soft_struct *fpu = &(tsk->thread.xstate->softfpu);
 
-	perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);
+	perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);
 
 	if (!(task_thread_info(tsk)->status & TS_USEDFPU)) {
 		/* initialize once. */

commit ace2dc7d12693545b67f15ab8cdb3d255c937713
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Oct 13 06:55:26 2010 +0900

    sh: wire up perf alignment and emulation faults.
    
    This plugs in the alignment and emulation fault reporting for perf sw
    events.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/math-emu/math.c b/arch/sh/math-emu/math.c
index 1fcdb1220975..f76a5090d5d1 100644
--- a/arch/sh/math-emu/math.c
+++ b/arch/sh/math-emu/math.c
@@ -12,6 +12,7 @@
 #include <linux/types.h>
 #include <linux/sched.h>
 #include <linux/signal.h>
+#include <linux/perf_event.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -619,6 +620,8 @@ int do_fpu_inst(unsigned short inst, struct pt_regs *regs)
 	struct task_struct *tsk = current;
 	struct sh_fpu_soft_struct *fpu = &(tsk->thread.xstate->softfpu);
 
+	perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);
+
 	if (!(task_thread_info(tsk)->status & TS_USEDFPU)) {
 		/* initialize once. */
 		fpu_init(fpu);

commit 0ea820cf9bf58f735ed40ec67947159c4f170012
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Jan 13 12:51:40 2010 +0900

    sh: Move over to dynamically allocated FPU context.
    
    This follows the x86 xstate changes and implements a task_xstate slab
    cache that is dynamically sized to match one of hard FP/soft FP/FPU-less.
    
    This also tidies up and consolidates some of the SH-2A/SH-4 FPU
    fragmentation. Now fpu state restorers are commonly defined, with the
    init_fpu()/fpu_init() mess reworked to follow the x86 convention.
    The fpu_init() register initialization has been replaced by xstate setup
    followed by writing out to hardware via the standard restore path.
    
    As init_fpu() now performs a slab allocation a secondary lighterweight
    restorer is also introduced for the context switch.
    
    In the future the DSP state will be rolled in here, too.
    
    More work remains for math emulation and the SH-5 FPU, which presently
    uses its own special (UP-only) interfaces.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/math-emu/math.c b/arch/sh/math-emu/math.c
index d6c15cae0912..1fcdb1220975 100644
--- a/arch/sh/math-emu/math.c
+++ b/arch/sh/math-emu/math.c
@@ -471,10 +471,10 @@ static int fpu_emulate(u16 code, struct sh_fpu_soft_struct *fregs, struct pt_reg
  *	denormal_to_double - Given denormalized float number,
  *	                     store double float
  *
- *	@fpu: Pointer to sh_fpu_hard structure
+ *	@fpu: Pointer to sh_fpu_soft structure
  *	@n: Index to FP register
  */
-static void denormal_to_double(struct sh_fpu_hard_struct *fpu, int n)
+static void denormal_to_double(struct sh_fpu_soft_struct *fpu, int n)
 {
 	unsigned long du, dl;
 	unsigned long x = fpu->fpul;
@@ -552,11 +552,11 @@ static int ieee_fpe_handler(struct pt_regs *regs)
 	if ((finsn & 0xf1ff) == 0xf0ad) { /* fcnvsd */
 		struct task_struct *tsk = current;
 
-		if ((tsk->thread.fpu.hard.fpscr & (1 << 17))) {
+		if ((tsk->thread.xstate->softfpu.fpscr & (1 << 17))) {
 			/* FPU error */
-			denormal_to_double (&tsk->thread.fpu.hard,
+			denormal_to_double (&tsk->thread.xstate->softfpu,
 					    (finsn >> 8) & 0xf);
-			tsk->thread.fpu.hard.fpscr &=
+			tsk->thread.xstate->softfpu.fpscr &=
 				~(FPSCR_CAUSE_MASK | FPSCR_FLAG_MASK);
 			task_thread_info(tsk)->status |= TS_USEDFPU;
 		} else {
@@ -617,7 +617,7 @@ static void fpu_init(struct sh_fpu_soft_struct *fpu)
 int do_fpu_inst(unsigned short inst, struct pt_regs *regs)
 {
 	struct task_struct *tsk = current;
-	struct sh_fpu_soft_struct *fpu = &(tsk->thread.fpu.soft);
+	struct sh_fpu_soft_struct *fpu = &(tsk->thread.xstate->softfpu);
 
 	if (!(task_thread_info(tsk)->status & TS_USEDFPU)) {
 		/* initialize once. */

commit d3ea9fa0a563620fe9f416f94bb8927c64390917
Author: Stuart Menefy <stuart.menefy@st.com>
Date:   Fri Sep 25 18:25:10 2009 +0100

    sh: Minor optimisations to FPU handling
    
    A number of small optimisations to FPU handling, in particular:
    
     - move the task USEDFPU flag from the thread_info flags field (which
       is accessed asynchronously to the thread) to a new status field,
       which is only accessed by the thread itself. This allows locking to
       be removed in most cases, or can be reduced to a preempt_lock().
       This mimics the i386 behaviour.
    
     - move the modification of regs->sr and thread_info->status flags out
       of save_fpu() to __unlazy_fpu(). This gives the compiler a better
       chance to optimise things, as well as making save_fpu() symmetrical
       with restore_fpu() and init_fpu().
    
     - implement prepare_to_copy(), so that when creating a thread, we can
       unlazy the FPU prior to copying the thread data structures.
    
    Also make sure that the FPU is disabled while in the kernel, in
    particular while booting, and for newly created kernel threads,
    
    In a very artificial benchmark, the execution time for 2500000
    context switches was reduced from 50 to 45 seconds.
    
    Signed-off-by: Stuart Menefy <stuart.menefy@st.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/math-emu/math.c b/arch/sh/math-emu/math.c
index ac2d7abd2567..d6c15cae0912 100644
--- a/arch/sh/math-emu/math.c
+++ b/arch/sh/math-emu/math.c
@@ -558,7 +558,7 @@ static int ieee_fpe_handler(struct pt_regs *regs)
 					    (finsn >> 8) & 0xf);
 			tsk->thread.fpu.hard.fpscr &=
 				~(FPSCR_CAUSE_MASK | FPSCR_FLAG_MASK);
-			set_tsk_thread_flag(tsk, TIF_USEDFPU);
+			task_thread_info(tsk)->status |= TS_USEDFPU;
 		} else {
 			info.si_signo = SIGFPE;
 			info.si_errno = 0;
@@ -619,10 +619,10 @@ int do_fpu_inst(unsigned short inst, struct pt_regs *regs)
 	struct task_struct *tsk = current;
 	struct sh_fpu_soft_struct *fpu = &(tsk->thread.fpu.soft);
 
-	if (!test_tsk_thread_flag(tsk, TIF_USEDFPU)) {
+	if (!(task_thread_info(tsk)->status & TS_USEDFPU)) {
 		/* initialize once. */
 		fpu_init(fpu);
-		set_tsk_thread_flag(tsk, TIF_USEDFPU);
+		task_thread_info(tsk)->status |= TS_USEDFPU;
 	}
 
 	return fpu_emulate(inst, fpu, regs);

commit d3efbdd6c5e8c823b732df26a355ec931ccab374
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Jun 11 15:57:42 2007 +0900

    sh: Fix up the math-emu build.
    
    math-emu wasn't converted for the trap_no/errno_code changes,
    get it building again.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/math-emu/math.c b/arch/sh/math-emu/math.c
index a38e1eed9e77..ac2d7abd2567 100644
--- a/arch/sh/math-emu/math.c
+++ b/arch/sh/math-emu/math.c
@@ -507,6 +507,7 @@ static int ieee_fpe_handler(struct pt_regs *regs)
 	unsigned short insn = *(unsigned short *)regs->pc;
 	unsigned short finsn;
 	unsigned long nextpc;
+	siginfo_t info;
 	int nib[4] = {
 		(insn >> 12) & 0xf,
 		(insn >> 8) & 0xf,
@@ -559,9 +560,11 @@ static int ieee_fpe_handler(struct pt_regs *regs)
 				~(FPSCR_CAUSE_MASK | FPSCR_FLAG_MASK);
 			set_tsk_thread_flag(tsk, TIF_USEDFPU);
 		} else {
-			tsk->thread.trap_no = 11;
-			tsk->thread.error_code = 0;
-			force_sig(SIGFPE, tsk);
+			info.si_signo = SIGFPE;
+			info.si_errno = 0;
+			info.si_code = FPE_FLTINV;
+			info.si_addr = (void __user *)regs->pc;
+			force_sig_info(SIGFPE, &info, tsk);
 		}
 
 		regs->pc = nextpc;
@@ -576,14 +579,17 @@ asmlinkage void do_fpu_error(unsigned long r4, unsigned long r5,
 			     struct pt_regs regs)
 {
 	struct task_struct *tsk = current;
+	siginfo_t info;
 
 	if (ieee_fpe_handler (&regs))
 		return;
 
 	regs.pc += 2;
-	tsk->thread.trap_no = 11;
-	tsk->thread.error_code = 0;
-	force_sig(SIGFPE, tsk);
+	info.si_signo = SIGFPE;
+	info.si_errno = 0;
+	info.si_code = FPE_FLTINV;
+	info.si_addr = (void __user *)regs.pc;
+	force_sig_info(SIGFPE, &info, tsk);
 }
 
 /**

commit e868d61272caa648214046a096e5a6bfc068dc8c
Author: Simon Arlott <simon@fire.lp0.eu>
Date:   Mon May 14 08:15:10 2007 +0900

    spelling fixes: arch/sh/
    
    Spelling fixes in arch/sh/.
    
    Signed-off-by: Simon Arlott <simon@fire.lp0.eu>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/math-emu/math.c b/arch/sh/math-emu/math.c
index 1efbac15ff4e..a38e1eed9e77 100644
--- a/arch/sh/math-emu/math.c
+++ b/arch/sh/math-emu/math.c
@@ -148,7 +148,7 @@ fmac(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
 	return 0;
 }
 
-// to process fmov's extention (odd n for DR access XD).
+// to process fmov's extension (odd n for DR access XD).
 #define FMOV_EXT(x) if(x&1) x+=16-1
 
 static int

commit 2914d4da172f53f71d0563d3c3bae14e496cbc86
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Oct 3 13:19:02 2006 +0900

    sh: Kill off remaining config.h references.
    
    A few of these managed to sneak back in, get rid of them once
    and for all.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/math-emu/math.c b/arch/sh/math-emu/math.c
index 26b6046814fd..1efbac15ff4e 100644
--- a/arch/sh/math-emu/math.c
+++ b/arch/sh/math-emu/math.c
@@ -7,7 +7,6 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  */
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/types.h>

commit 4b565680d16300acab0ff167e24f0ea289a6bd5d
Author: Takashi YOSHII <takasi-y@ops.dti.ne.jp>
Date:   Wed Sep 27 17:15:32 2006 +0900

    sh: math-emu support
    
    This implements initial math-emu support, aimed primarily at SH-3.
    
    Signed-off-by: Takashi YOSHII <takasi-y@ops.dti.ne.jp>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/math-emu/math.c b/arch/sh/math-emu/math.c
new file mode 100644
index 000000000000..26b6046814fd
--- /dev/null
+++ b/arch/sh/math-emu/math.c
@@ -0,0 +1,624 @@
+/*
+ * arch/sh/math-emu/math.c
+ *
+ * Copyright (C) 2006 Takashi YOSHII <takasi-y@ops.dti.ne.jp>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/signal.h>
+
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <asm/processor.h>
+#include <asm/io.h>
+
+#include "sfp-util.h"
+#include <math-emu/soft-fp.h>
+#include <math-emu/single.h>
+#include <math-emu/double.h>
+
+#define	FPUL		(fregs->fpul)
+#define FPSCR		(fregs->fpscr)
+#define FPSCR_RM	(FPSCR&3)
+#define FPSCR_DN	((FPSCR>>18)&1)
+#define FPSCR_PR	((FPSCR>>19)&1)
+#define FPSCR_SZ	((FPSCR>>20)&1)
+#define FPSCR_FR	((FPSCR>>21)&1)
+#define FPSCR_MASK	0x003fffffUL
+
+#define BANK(n)	(n^(FPSCR_FR?16:0))
+#define FR	((unsigned long*)(fregs->fp_regs))
+#define FR0	(FR[BANK(0)])
+#define FRn	(FR[BANK(n)])
+#define FRm	(FR[BANK(m)])
+#define DR	((unsigned long long*)(fregs->fp_regs))
+#define DRn	(DR[BANK(n)/2])
+#define DRm	(DR[BANK(m)/2])
+
+#define XREG(n)	(n^16)
+#define XFn	(FR[BANK(XREG(n))])
+#define XFm	(FR[BANK(XREG(m))])
+#define XDn	(DR[BANK(XREG(n))/2])
+#define XDm	(DR[BANK(XREG(m))/2])
+
+#define R0	(regs->regs[0])
+#define Rn	(regs->regs[n])
+#define Rm	(regs->regs[m])
+
+#define WRITE(d,a)	({if(put_user(d, (typeof (d)*)a)) return -EFAULT;})
+#define READ(d,a)	({if(get_user(d, (typeof (d)*)a)) return -EFAULT;})
+
+#define PACK_S(r,f)	FP_PACK_SP(&r,f)
+#define UNPACK_S(f,r)	FP_UNPACK_SP(f,&r)
+#define PACK_D(r,f) \
+	{u32 t[2]; FP_PACK_DP(t,f); ((u32*)&r)[0]=t[1]; ((u32*)&r)[1]=t[0];}
+#define UNPACK_D(f,r) \
+	{u32 t[2]; t[0]=((u32*)&r)[1]; t[1]=((u32*)&r)[0]; FP_UNPACK_DP(f,t);}
+
+// 2 args instructions.
+#define BOTH_PRmn(op,x) \
+	FP_DECL_EX; if(FPSCR_PR) op(D,x,DRm,DRn); else op(S,x,FRm,FRn);
+
+#define CMP_X(SZ,R,M,N) do{ \
+	FP_DECL_##SZ(Fm); FP_DECL_##SZ(Fn); \
+	UNPACK_##SZ(Fm, M); UNPACK_##SZ(Fn, N); \
+	FP_CMP_##SZ(R, Fn, Fm, 2); }while(0)
+#define EQ_X(SZ,R,M,N) do{ \
+	FP_DECL_##SZ(Fm); FP_DECL_##SZ(Fn); \
+	UNPACK_##SZ(Fm, M); UNPACK_##SZ(Fn, N); \
+	FP_CMP_EQ_##SZ(R, Fn, Fm); }while(0)
+#define CMP(OP) ({ int r; BOTH_PRmn(OP##_X,r); r; })
+
+static int
+fcmp_gt(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
+{
+	if (CMP(CMP) > 0)
+		regs->sr |= 1;
+	else
+		regs->sr &= ~1;
+
+	return 0;
+}
+
+static int
+fcmp_eq(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
+{
+	if (CMP(CMP /*EQ*/) == 0)
+		regs->sr |= 1;
+	else
+		regs->sr &= ~1;
+	return 0;
+}
+
+#define ARITH_X(SZ,OP,M,N) do{ \
+	FP_DECL_##SZ(Fm); FP_DECL_##SZ(Fn); FP_DECL_##SZ(Fr); \
+	UNPACK_##SZ(Fm, M); UNPACK_##SZ(Fn, N); \
+	FP_##OP##_##SZ(Fr, Fn, Fm); \
+	PACK_##SZ(N, Fr); }while(0)
+
+static int
+fadd(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
+{
+	BOTH_PRmn(ARITH_X, ADD);
+	return 0;
+}
+
+static int
+fsub(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
+{
+	BOTH_PRmn(ARITH_X, SUB);
+	return 0;
+}
+
+static int
+fmul(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
+{
+	BOTH_PRmn(ARITH_X, MUL);
+	return 0;
+}
+
+static int
+fdiv(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
+{
+	BOTH_PRmn(ARITH_X, DIV);
+	return 0;
+}
+
+static int
+fmac(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
+{
+	FP_DECL_EX;
+	FP_DECL_S(Fr);
+	FP_DECL_S(Ft);
+	FP_DECL_S(F0);
+	FP_DECL_S(Fm);
+	FP_DECL_S(Fn);
+	UNPACK_S(F0, FR0);
+	UNPACK_S(Fm, FRm);
+	UNPACK_S(Fn, FRn);
+	FP_MUL_S(Ft, Fm, F0);
+	FP_ADD_S(Fr, Fn, Ft);
+	PACK_S(FRn, Fr);
+	return 0;
+}
+
+// to process fmov's extention (odd n for DR access XD).
+#define FMOV_EXT(x) if(x&1) x+=16-1
+
+static int
+fmov_idx_reg(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
+	     int n)
+{
+	if (FPSCR_SZ) {
+		FMOV_EXT(n);
+		READ(FRn, Rm + R0 + 4);
+		n++;
+		READ(FRn, Rm + R0);
+	} else {
+		READ(FRn, Rm + R0);
+	}
+
+	return 0;
+}
+
+static int
+fmov_mem_reg(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
+	     int n)
+{
+	if (FPSCR_SZ) {
+		FMOV_EXT(n);
+		READ(FRn, Rm + 4);
+		n++;
+		READ(FRn, Rm);
+	} else {
+		READ(FRn, Rm);
+	}
+
+	return 0;
+}
+
+static int
+fmov_inc_reg(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
+	     int n)
+{
+	if (FPSCR_SZ) {
+		FMOV_EXT(n);
+		READ(FRn, Rm + 4);
+		n++;
+		READ(FRn, Rm);
+		Rm += 8;
+	} else {
+		READ(FRn, Rm);
+		Rm += 4;
+	}
+
+	return 0;
+}
+
+static int
+fmov_reg_idx(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
+	     int n)
+{
+	if (FPSCR_SZ) {
+		FMOV_EXT(m);
+		WRITE(FRm, Rn + R0 + 4);
+		m++;
+		WRITE(FRm, Rn + R0);
+	} else {
+		WRITE(FRm, Rn + R0);
+	}
+
+	return 0;
+}
+
+static int
+fmov_reg_mem(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
+	     int n)
+{
+	if (FPSCR_SZ) {
+		FMOV_EXT(m);
+		WRITE(FRm, Rn + 4);
+		m++;
+		WRITE(FRm, Rn);
+	} else {
+		WRITE(FRm, Rn);
+	}
+
+	return 0;
+}
+
+static int
+fmov_reg_dec(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
+	     int n)
+{
+	if (FPSCR_SZ) {
+		FMOV_EXT(m);
+		Rn -= 8;
+		WRITE(FRm, Rn + 4);
+		m++;
+		WRITE(FRm, Rn);
+	} else {
+		Rn -= 4;
+		WRITE(FRm, Rn);
+	}
+
+	return 0;
+}
+
+static int
+fmov_reg_reg(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
+	     int n)
+{
+	if (FPSCR_SZ) {
+		FMOV_EXT(m);
+		FMOV_EXT(n);
+		DRn = DRm;
+	} else {
+		FRn = FRm;
+	}
+
+	return 0;
+}
+
+static int
+fnop_mn(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
+{
+	return -EINVAL;
+}
+
+// 1 arg instructions.
+#define NOTYETn(i) static int i(struct sh_fpu_soft_struct *fregs, int n) \
+	{ printk( #i " not yet done.\n"); return 0; }
+
+NOTYETn(ftrv)
+NOTYETn(fsqrt)
+NOTYETn(fipr)
+NOTYETn(fsca)
+NOTYETn(fsrra)
+
+#define EMU_FLOAT_X(SZ,N) do { \
+	FP_DECL_##SZ(Fn); \
+	FP_FROM_INT_##SZ(Fn, FPUL, 32, int); \
+	PACK_##SZ(N, Fn); }while(0)
+static int ffloat(struct sh_fpu_soft_struct *fregs, int n)
+{
+	FP_DECL_EX;
+
+	if (FPSCR_PR)
+		EMU_FLOAT_X(D, DRn);
+	else
+		EMU_FLOAT_X(S, FRn);
+
+	return 0;
+}
+
+#define EMU_FTRC_X(SZ,N) do { \
+	FP_DECL_##SZ(Fn); \
+	UNPACK_##SZ(Fn, N); \
+	FP_TO_INT_##SZ(FPUL, Fn, 32, 1); }while(0)
+static int ftrc(struct sh_fpu_soft_struct *fregs, int n)
+{
+	FP_DECL_EX;
+
+	if (FPSCR_PR)
+		EMU_FTRC_X(D, DRn);
+	else
+		EMU_FTRC_X(S, FRn);
+
+	return 0;
+}
+
+static int fcnvsd(struct sh_fpu_soft_struct *fregs, int n)
+{
+	FP_DECL_EX;
+	FP_DECL_S(Fn);
+	FP_DECL_D(Fr);
+	UNPACK_S(Fn, FPUL);
+	FP_CONV(D, S, 2, 1, Fr, Fn);
+	PACK_D(DRn, Fr);
+	return 0;
+}
+
+static int fcnvds(struct sh_fpu_soft_struct *fregs, int n)
+{
+	FP_DECL_EX;
+	FP_DECL_D(Fn);
+	FP_DECL_S(Fr);
+	UNPACK_D(Fn, DRn);
+	FP_CONV(S, D, 1, 2, Fr, Fn);
+	PACK_S(FPUL, Fr);
+	return 0;
+}
+
+static int fxchg(struct sh_fpu_soft_struct *fregs, int flag)
+{
+	FPSCR ^= flag;
+	return 0;
+}
+
+static int fsts(struct sh_fpu_soft_struct *fregs, int n)
+{
+	FRn = FPUL;
+	return 0;
+}
+
+static int flds(struct sh_fpu_soft_struct *fregs, int n)
+{
+	FPUL = FRn;
+	return 0;
+}
+
+static int fneg(struct sh_fpu_soft_struct *fregs, int n)
+{
+	FRn ^= (1 << (_FP_W_TYPE_SIZE - 1));
+	return 0;
+}
+
+static int fabs(struct sh_fpu_soft_struct *fregs, int n)
+{
+	FRn &= ~(1 << (_FP_W_TYPE_SIZE - 1));
+	return 0;
+}
+
+static int fld0(struct sh_fpu_soft_struct *fregs, int n)
+{
+	FRn = 0;
+	return 0;
+}
+
+static int fld1(struct sh_fpu_soft_struct *fregs, int n)
+{
+	FRn = (_FP_EXPBIAS_S << (_FP_FRACBITS_S - 1));
+	return 0;
+}
+
+static int fnop_n(struct sh_fpu_soft_struct *fregs, int n)
+{
+	return -EINVAL;
+}
+
+/// Instruction decoders.
+
+static int id_fxfd(struct sh_fpu_soft_struct *, int);
+static int id_fnxd(struct sh_fpu_soft_struct *, struct pt_regs *, int, int);
+
+static int (*fnxd[])(struct sh_fpu_soft_struct *, int) = {
+	fsts, flds, ffloat, ftrc, fneg, fabs, fsqrt, fsrra,
+	fld0, fld1, fcnvsd, fcnvds, fnop_n, fnop_n, fipr, id_fxfd
+};
+
+static int (*fnmx[])(struct sh_fpu_soft_struct *, struct pt_regs *, int, int) = {
+	fadd, fsub, fmul, fdiv, fcmp_eq, fcmp_gt, fmov_idx_reg, fmov_reg_idx,
+	fmov_mem_reg, fmov_inc_reg, fmov_reg_mem, fmov_reg_dec,
+	fmov_reg_reg, id_fnxd, fmac, fnop_mn};
+
+static int id_fxfd(struct sh_fpu_soft_struct *fregs, int x)
+{
+	const int flag[] = { FPSCR_SZ, FPSCR_PR, FPSCR_FR, 0 };
+	switch (x & 3) {
+	case 3:
+		fxchg(fregs, flag[x >> 2]);
+		break;
+	case 1:
+		ftrv(fregs, x - 1);
+		break;
+	default:
+		fsca(fregs, x);
+	}
+	return 0;
+}
+
+static int
+id_fnxd(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int x, int n)
+{
+	return (fnxd[x])(fregs, n);
+}
+
+static int
+id_fnmx(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, u16 code)
+{
+	int n = (code >> 8) & 0xf, m = (code >> 4) & 0xf, x = code & 0xf;
+	return (fnmx[x])(fregs, regs, m, n);
+}
+
+static int
+id_sys(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, u16 code)
+{
+	int n = ((code >> 8) & 0xf);
+	unsigned long *reg = (code & 0x0010) ? &FPUL : &FPSCR;
+
+	switch (code & 0xf0ff) {
+	case 0x005a:
+	case 0x006a:
+		Rn = *reg;
+		break;
+	case 0x405a:
+	case 0x406a:
+		*reg = Rn;
+		break;
+	case 0x4052:
+	case 0x4062:
+		Rn -= 4;
+		WRITE(*reg, Rn);
+		break;
+	case 0x4056:
+	case 0x4066:
+		READ(*reg, Rn);
+		Rn += 4;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int fpu_emulate(u16 code, struct sh_fpu_soft_struct *fregs, struct pt_regs *regs)
+{
+	if ((code & 0xf000) == 0xf000)
+		return id_fnmx(fregs, regs, code);
+	else
+		return id_sys(fregs, regs, code);
+}
+
+/**
+ *	denormal_to_double - Given denormalized float number,
+ *	                     store double float
+ *
+ *	@fpu: Pointer to sh_fpu_hard structure
+ *	@n: Index to FP register
+ */
+static void denormal_to_double(struct sh_fpu_hard_struct *fpu, int n)
+{
+	unsigned long du, dl;
+	unsigned long x = fpu->fpul;
+	int exp = 1023 - 126;
+
+	if (x != 0 && (x & 0x7f800000) == 0) {
+		du = (x & 0x80000000);
+		while ((x & 0x00800000) == 0) {
+			x <<= 1;
+			exp--;
+		}
+		x &= 0x007fffff;
+		du |= (exp << 20) | (x >> 3);
+		dl = x << 29;
+
+		fpu->fp_regs[n] = du;
+		fpu->fp_regs[n+1] = dl;
+	}
+}
+
+/**
+ *	ieee_fpe_handler - Handle denormalized number exception
+ *
+ *	@regs: Pointer to register structure
+ *
+ *	Returns 1 when it's handled (should not cause exception).
+ */
+static int ieee_fpe_handler(struct pt_regs *regs)
+{
+	unsigned short insn = *(unsigned short *)regs->pc;
+	unsigned short finsn;
+	unsigned long nextpc;
+	int nib[4] = {
+		(insn >> 12) & 0xf,
+		(insn >> 8) & 0xf,
+		(insn >> 4) & 0xf,
+		insn & 0xf};
+
+	if (nib[0] == 0xb ||
+	    (nib[0] == 0x4 && nib[2] == 0x0 && nib[3] == 0xb)) /* bsr & jsr */
+		regs->pr = regs->pc + 4;
+
+	if (nib[0] == 0xa || nib[0] == 0xb) { /* bra & bsr */
+		nextpc = regs->pc + 4 + ((short) ((insn & 0xfff) << 4) >> 3);
+		finsn = *(unsigned short *) (regs->pc + 2);
+	} else if (nib[0] == 0x8 && nib[1] == 0xd) { /* bt/s */
+		if (regs->sr & 1)
+			nextpc = regs->pc + 4 + ((char) (insn & 0xff) << 1);
+		else
+			nextpc = regs->pc + 4;
+		finsn = *(unsigned short *) (regs->pc + 2);
+	} else if (nib[0] == 0x8 && nib[1] == 0xf) { /* bf/s */
+		if (regs->sr & 1)
+			nextpc = regs->pc + 4;
+		else
+			nextpc = regs->pc + 4 + ((char) (insn & 0xff) << 1);
+		finsn = *(unsigned short *) (regs->pc + 2);
+	} else if (nib[0] == 0x4 && nib[3] == 0xb &&
+		 (nib[2] == 0x0 || nib[2] == 0x2)) { /* jmp & jsr */
+		nextpc = regs->regs[nib[1]];
+		finsn = *(unsigned short *) (regs->pc + 2);
+	} else if (nib[0] == 0x0 && nib[3] == 0x3 &&
+		 (nib[2] == 0x0 || nib[2] == 0x2)) { /* braf & bsrf */
+		nextpc = regs->pc + 4 + regs->regs[nib[1]];
+		finsn = *(unsigned short *) (regs->pc + 2);
+	} else if (insn == 0x000b) { /* rts */
+		nextpc = regs->pr;
+		finsn = *(unsigned short *) (regs->pc + 2);
+	} else {
+		nextpc = regs->pc + 2;
+		finsn = insn;
+	}
+
+	if ((finsn & 0xf1ff) == 0xf0ad) { /* fcnvsd */
+		struct task_struct *tsk = current;
+
+		if ((tsk->thread.fpu.hard.fpscr & (1 << 17))) {
+			/* FPU error */
+			denormal_to_double (&tsk->thread.fpu.hard,
+					    (finsn >> 8) & 0xf);
+			tsk->thread.fpu.hard.fpscr &=
+				~(FPSCR_CAUSE_MASK | FPSCR_FLAG_MASK);
+			set_tsk_thread_flag(tsk, TIF_USEDFPU);
+		} else {
+			tsk->thread.trap_no = 11;
+			tsk->thread.error_code = 0;
+			force_sig(SIGFPE, tsk);
+		}
+
+		regs->pc = nextpc;
+		return 1;
+	}
+
+	return 0;
+}
+
+asmlinkage void do_fpu_error(unsigned long r4, unsigned long r5,
+			     unsigned long r6, unsigned long r7,
+			     struct pt_regs regs)
+{
+	struct task_struct *tsk = current;
+
+	if (ieee_fpe_handler (&regs))
+		return;
+
+	regs.pc += 2;
+	tsk->thread.trap_no = 11;
+	tsk->thread.error_code = 0;
+	force_sig(SIGFPE, tsk);
+}
+
+/**
+ * fpu_init - Initialize FPU registers
+ * @fpu: Pointer to software emulated FPU registers.
+ */
+static void fpu_init(struct sh_fpu_soft_struct *fpu)
+{
+	int i;
+
+	fpu->fpscr = FPSCR_INIT;
+	fpu->fpul = 0;
+
+	for (i = 0; i < 16; i++) {
+		fpu->fp_regs[i] = 0;
+		fpu->xfp_regs[i]= 0;
+	}
+}
+
+/**
+ * do_fpu_inst - Handle reserved instructions for FPU emulation
+ * @inst: instruction code.
+ * @regs: registers on stack.
+ */
+int do_fpu_inst(unsigned short inst, struct pt_regs *regs)
+{
+	struct task_struct *tsk = current;
+	struct sh_fpu_soft_struct *fpu = &(tsk->thread.fpu.soft);
+
+	if (!test_tsk_thread_flag(tsk, TIF_USEDFPU)) {
+		/* initialize once. */
+		fpu_init(fpu);
+		set_tsk_thread_flag(tsk, TIF_USEDFPU);
+	}
+
+	return fpu_emulate(inst, fpu, regs);
+}
