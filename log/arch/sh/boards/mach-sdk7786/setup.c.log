commit 87dfb311b707cd4c4b666c9af0fa15acbe6eee99
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue May 14 15:46:51 2019 -0700

    treewide: replace #include <asm/sizes.h> with #include <linux/sizes.h>
    
    Since commit dccd2304cc90 ("ARM: 7430/1: sizes.h: move from asm-generic
    to <linux/sizes.h>"), <asm/sizes.h> and <asm-generic/sizes.h> are just
    wrappers of <linux/sizes.h>.
    
    This commit replaces all <asm/sizes.h> and <asm-generic/sizes.h> to
    prepare for the removal.
    
    Link: http://lkml.kernel.org/r/1553267665-27228-1-git-send-email-yamada.masahiro@socionext.com
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/boards/mach-sdk7786/setup.c b/arch/sh/boards/mach-sdk7786/setup.c
index 65721c3a482c..d183026dbeb1 100644
--- a/arch/sh/boards/mach-sdk7786/setup.c
+++ b/arch/sh/boards/mach-sdk7786/setup.c
@@ -19,7 +19,7 @@
 #include <mach/irq.h>
 #include <asm/machvec.h>
 #include <asm/heartbeat.h>
-#include <asm/sizes.h>
+#include <linux/sizes.h>
 #include <asm/clock.h>
 #include <asm/reboot.h>
 #include <asm/smp-ops.h>

commit aaf9128abcb8314eb9756db3e32d667c5161156f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 28 00:31:46 2018 -0800

    sh: boards: convert to SPDX identifiers
    
    Update license to use SPDX-License-Identifier instead of verbose license
    text.
    
    Link: http://lkml.kernel.org/r/87in08ct0n.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/boards/mach-sdk7786/setup.c b/arch/sh/boards/mach-sdk7786/setup.c
index c29268bfd34a..65721c3a482c 100644
--- a/arch/sh/boards/mach-sdk7786/setup.c
+++ b/arch/sh/boards/mach-sdk7786/setup.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Renesas Technology Europe SDK7786 Support.
  *
  * Copyright (C) 2010  Matt Fleming
  * Copyright (C) 2010  Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 #include <linux/init.h>
 #include <linux/platform_device.h>

commit 2fcfe22ae791e1e4e0cc9d0fbad617405552ffc0
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Wed Jun 27 00:50:08 2012 +0200

    sh: add fixed voltage regulators to sdk7786
    
    On sdk7786 provide a dummy regulator for the smsc911x driver.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-sdk7786/setup.c b/arch/sh/boards/mach-sdk7786/setup.c
index 27a2314f50ac..c29268bfd34a 100644
--- a/arch/sh/boards/mach-sdk7786/setup.c
+++ b/arch/sh/boards/mach-sdk7786/setup.c
@@ -11,6 +11,8 @@
 #include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
+#include <linux/regulator/fixed.h>
+#include <linux/regulator/machine.h>
 #include <linux/smsc911x.h>
 #include <linux/i2c.h>
 #include <linux/irq.h>
@@ -38,6 +40,12 @@ static struct platform_device heartbeat_device = {
 	.resource	= &heartbeat_resource,
 };
 
+/* Dummy supplies, where voltage doesn't matter */
+static struct regulator_consumer_supply dummy_supplies[] = {
+	REGULATOR_SUPPLY("vddvario", "smsc911x"),
+	REGULATOR_SUPPLY("vdd33a", "smsc911x"),
+};
+
 static struct resource smsc911x_resources[] = {
 	[0] = {
 		.name		= "smsc911x-memory",
@@ -236,6 +244,8 @@ static void __init sdk7786_setup(char **cmdline_p)
 {
 	pr_info("Renesas Technology Europe SDK7786 support:\n");
 
+	regulator_register_fixed(0, dummy_supplies, ARRAY_SIZE(dummy_supplies));
+
 	sdk7786_fpga_init();
 	sdk7786_nmi_init();
 

commit c953efdbb1b4f6804a476329a2df8bdab3a76019
Author: Magnus Damm <damm@opensource.se>
Date:   Wed Feb 29 22:18:11 2012 +0900

    sh: board sh_clk_ops rename
    
    Convert remaining sh board code to use sh_clk_ops.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/arch/sh/boards/mach-sdk7786/setup.c b/arch/sh/boards/mach-sdk7786/setup.c
index 486d1ac3694c..27a2314f50ac 100644
--- a/arch/sh/boards/mach-sdk7786/setup.c
+++ b/arch/sh/boards/mach-sdk7786/setup.c
@@ -167,7 +167,7 @@ static void sdk7786_pcie_clk_disable(struct clk *clk)
 	fpga_write_reg(fpga_read_reg(PCIECR) & ~PCIECR_CLKEN, PCIECR);
 }
 
-static struct clk_ops sdk7786_pcie_clk_ops = {
+static struct sh_clk_ops sdk7786_pcie_clk_ops = {
 	.enable		= sdk7786_pcie_clk_enable,
 	.disable	= sdk7786_pcie_clk_disable,
 };

commit 7912825d8b755e6a5b9839eab910f451b0271aba
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Jun 24 17:36:23 2011 +0900

    sh: Tidy up pre-clkdev clk_get() error handling.
    
    clk_get() used to return NULL or an errno value depending on whether a
    clkdev lookup failed or a clock wasn't found in the primary clock list.
    As these disjoint paths were unified and everything now is handled via
    clkdev lookups, the NULL case never makes it out of clk_get(). Update
    accordingly and always look to the errno value.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-sdk7786/setup.c b/arch/sh/boards/mach-sdk7786/setup.c
index 1521aa75ee3a..486d1ac3694c 100644
--- a/arch/sh/boards/mach-sdk7786/setup.c
+++ b/arch/sh/boards/mach-sdk7786/setup.c
@@ -194,7 +194,7 @@ static int sdk7786_clk_init(void)
 		return -EINVAL;
 
 	clk = clk_get(NULL, "extal");
-	if (!clk || IS_ERR(clk))
+	if (IS_ERR(clk))
 		return PTR_ERR(clk);
 	ret = clk_set_rate(clk, 33333333);
 	clk_put(clk);

commit 95d210ce6b23ec8916f97ec0cc7eb4d5fa80e0b3
Author: Nobuhiro Iwamatsu <iwamatsu@nigauri.org>
Date:   Fri Jan 7 03:02:15 2011 +0000

    sh: Use device_initcall() instead of __initcall()
    
    Signed-off-by: Nobuhiro Iwamatsu <iwamatsu@nigauri.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-sdk7786/setup.c b/arch/sh/boards/mach-sdk7786/setup.c
index 5b302d690ee5..1521aa75ee3a 100644
--- a/arch/sh/boards/mach-sdk7786/setup.c
+++ b/arch/sh/boards/mach-sdk7786/setup.c
@@ -135,7 +135,7 @@ static int __init sdk7786_devices_setup(void)
 
 	return sdk7786_i2c_setup();
 }
-__initcall(sdk7786_devices_setup);
+device_initcall(sdk7786_devices_setup);
 
 static int sdk7786_mode_pins(void)
 {

commit 3bd75e5e0c5b58636aeadd34890114bcb988777e
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Jan 7 11:07:30 2011 +0900

    sh: mach-sdk7786: Fix up fallout from clkdev consolidation.
    
      CC      arch/sh/boards/mach-sdk7786/setup.o
    arch/sh/boards/mach-sdk7786/setup.c:179: error: variable 'sdk7786_pcie_cl' has initializer but incomplete type
    arch/sh/boards/mach-sdk7786/setup.c:180: error: unknown field 'con_id' specified in initializer
    arch/sh/boards/mach-sdk7786/setup.c:180: warning: excess elements in struct initializer
    arch/sh/boards/mach-sdk7786/setup.c:180: warning: (near initialization for 'sdk7786_pcie_cl')
    arch/sh/boards/mach-sdk7786/setup.c:181: error: unknown field 'clk' specified in initializer
    arch/sh/boards/mach-sdk7786/setup.c:181: warning: excess elements in struct initializer
    arch/sh/boards/mach-sdk7786/setup.c:181: warning: (near initialization for 'sdk7786_pcie_cl')
    arch/sh/boards/mach-sdk7786/setup.c: In function 'sdk7786_clk_init':
    arch/sh/boards/mach-sdk7786/setup.c:211: error: implicit declaration of function 'clkdev_add'
    
    which is a fanciful way of saying that the struct definition moved from
    asm/clkdev.h to linux/clkdev.h.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-sdk7786/setup.c b/arch/sh/boards/mach-sdk7786/setup.c
index 75e4ddbbec3e..5b302d690ee5 100644
--- a/arch/sh/boards/mach-sdk7786/setup.c
+++ b/arch/sh/boards/mach-sdk7786/setup.c
@@ -15,13 +15,13 @@
 #include <linux/i2c.h>
 #include <linux/irq.h>
 #include <linux/clk.h>
+#include <linux/clkdev.h>
 #include <mach/fpga.h>
 #include <mach/irq.h>
 #include <asm/machvec.h>
 #include <asm/heartbeat.h>
 #include <asm/sizes.h>
 #include <asm/clock.h>
-#include <asm/clkdev.h>
 #include <asm/reboot.h>
 #include <asm/smp-ops.h>
 

commit 76496f8f2e104b8bb08db09c063a6817d18829a6
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Dec 17 18:58:04 2010 +0900

    sh: mach-sdk7786: Handle baseboard NMI source selection.
    
    The on-board NMI switch is routed through and mangled by the FPGA prior
    to its delivery to the NMI pin, so add some glue for the various
    configuration options. The default is to unmask it and enable all input
    sources.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-sdk7786/setup.c b/arch/sh/boards/mach-sdk7786/setup.c
index 7e0c4e3878e0..75e4ddbbec3e 100644
--- a/arch/sh/boards/mach-sdk7786/setup.c
+++ b/arch/sh/boards/mach-sdk7786/setup.c
@@ -237,6 +237,7 @@ static void __init sdk7786_setup(char **cmdline_p)
 	pr_info("Renesas Technology Europe SDK7786 support:\n");
 
 	sdk7786_fpga_init();
+	sdk7786_nmi_init();
 
 	pr_info("\tPCB revision:\t%d\n", fpga_read_reg(PCBRR) & 0xf);
 

commit b6b77b2d5ffd2f8ee74fcc27661f7f4962c34705
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Oct 14 08:44:55 2010 +0900

    sh: pci: Support secondary FPGA-driven PCIe clocks on SDK7786.
    
    The SDK7786 FPGA has secondary control over the PCIe clocks, specifically
    relating to the slots and oscillator. This ties the FPGA clocks in to the
    clock framework and balances the refcounting similar to how the primary
    on-chip clocks are managed. While the on-chip clocks are per-port, the
    FPGA clock enable/disable is global for the entire block.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-sdk7786/setup.c b/arch/sh/boards/mach-sdk7786/setup.c
index 2ec1ea5cf8ef..7e0c4e3878e0 100644
--- a/arch/sh/boards/mach-sdk7786/setup.c
+++ b/arch/sh/boards/mach-sdk7786/setup.c
@@ -20,6 +20,8 @@
 #include <asm/machvec.h>
 #include <asm/heartbeat.h>
 #include <asm/sizes.h>
+#include <asm/clock.h>
+#include <asm/clkdev.h>
 #include <asm/reboot.h>
 #include <asm/smp-ops.h>
 
@@ -140,6 +142,45 @@ static int sdk7786_mode_pins(void)
 	return fpga_read_reg(MODSWR);
 }
 
+/*
+ * FPGA-driven PCIe clocks
+ *
+ * Historically these include the oscillator, clock B (slots 2/3/4) and
+ * clock A (slot 1 and the CPU clock). Newer revs of the PCB shove
+ * everything under a single PCIe clocks enable bit that happens to map
+ * to the same bit position as the oscillator bit for earlier FPGA
+ * versions.
+ *
+ * Given that the legacy clocks have the side-effect of shutting the CPU
+ * off through the FPGA along with the PCI slots, we simply leave them in
+ * their initial state and don't bother registering them with the clock
+ * framework.
+ */
+static int sdk7786_pcie_clk_enable(struct clk *clk)
+{
+	fpga_write_reg(fpga_read_reg(PCIECR) | PCIECR_CLKEN, PCIECR);
+	return 0;
+}
+
+static void sdk7786_pcie_clk_disable(struct clk *clk)
+{
+	fpga_write_reg(fpga_read_reg(PCIECR) & ~PCIECR_CLKEN, PCIECR);
+}
+
+static struct clk_ops sdk7786_pcie_clk_ops = {
+	.enable		= sdk7786_pcie_clk_enable,
+	.disable	= sdk7786_pcie_clk_disable,
+};
+
+static struct clk sdk7786_pcie_clk = {
+	.ops		= &sdk7786_pcie_clk_ops,
+};
+
+static struct clk_lookup sdk7786_pcie_cl = {
+	.con_id		= "pcie_plat_clk",
+	.clk		= &sdk7786_pcie_clk,
+};
+
 static int sdk7786_clk_init(void)
 {
 	struct clk *clk;
@@ -158,7 +199,18 @@ static int sdk7786_clk_init(void)
 	ret = clk_set_rate(clk, 33333333);
 	clk_put(clk);
 
-	return ret;
+	/*
+	 * Setup the FPGA clocks.
+	 */
+	ret = clk_register(&sdk7786_pcie_clk);
+	if (unlikely(ret)) {
+		pr_err("FPGA clock registration failed\n");
+		return ret;
+	}
+
+	clkdev_add(&sdk7786_pcie_cl);
+
+	return 0;
 }
 
 static void sdk7786_restart(char *cmd)

commit 3366e3585fbf0d40ce6f2382b544851cf4df1654
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Mar 30 12:38:01 2010 +0900

    sh: Move platform smp ops in to their own structure.
    
    This cribs the MIPS plat_smp_ops approach for wrapping up the platform
    ops. This will allow for mixing and matching different ops on the same
    platform in the future.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-sdk7786/setup.c b/arch/sh/boards/mach-sdk7786/setup.c
index 0c057a93fe29..2ec1ea5cf8ef 100644
--- a/arch/sh/boards/mach-sdk7786/setup.c
+++ b/arch/sh/boards/mach-sdk7786/setup.c
@@ -21,6 +21,7 @@
 #include <asm/heartbeat.h>
 #include <asm/sizes.h>
 #include <asm/reboot.h>
+#include <asm/smp-ops.h>
 
 static struct resource heartbeat_resource = {
 	.start		= 0x07fff8b0,
@@ -189,6 +190,8 @@ static void __init sdk7786_setup(char **cmdline_p)
 
 	machine_ops.restart = sdk7786_restart;
 	pm_power_off = sdk7786_power_off;
+
+	register_smp_ops(&shx3_smp_ops);
 }
 
 /*

commit d9c944463d8f3f7cafaaba8f3e44df62ce817484
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Mon Apr 19 16:27:47 2010 +0900

    sh: mach-sdk7786: pm_power_off support.
    
    This wires up power-off support for the SDK7786 board.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-sdk7786/setup.c b/arch/sh/boards/mach-sdk7786/setup.c
index f094ea2ee783..0c057a93fe29 100644
--- a/arch/sh/boards/mach-sdk7786/setup.c
+++ b/arch/sh/boards/mach-sdk7786/setup.c
@@ -165,6 +165,19 @@ static void sdk7786_restart(char *cmd)
 	fpga_write_reg(0xa5a5, SRSTR);
 }
 
+static void sdk7786_power_off(void)
+{
+	fpga_write_reg(fpga_read_reg(PWRCR) | PWRCR_PDWNREQ, PWRCR);
+
+	/*
+	 * It can take up to 20us for the R8C to do its job, back off and
+	 * wait a bit until we've been shut off. Even though newer FPGA
+	 * versions don't set the ACK bit, the latency issue remains.
+	 */
+	while ((fpga_read_reg(PWRCR) & PWRCR_PDWNACK) == 0)
+		cpu_sleep();
+}
+
 /* Initialize the board */
 static void __init sdk7786_setup(char **cmdline_p)
 {
@@ -175,6 +188,7 @@ static void __init sdk7786_setup(char **cmdline_p)
 	pr_info("\tPCB revision:\t%d\n", fpga_read_reg(PCBRR) & 0xf);
 
 	machine_ops.restart = sdk7786_restart;
+	pm_power_off = sdk7786_power_off;
 }
 
 /*

commit b51989b8afe9409ee68c67ce2a5de4390693bd2b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Jan 20 16:53:11 2010 +0900

    sh: mach-sdk7786: reset controller reboot support.
    
    This wires up the machine_ops reboot call to use the system reset
    controller.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-sdk7786/setup.c b/arch/sh/boards/mach-sdk7786/setup.c
index 3c3c9a38cfda..f094ea2ee783 100644
--- a/arch/sh/boards/mach-sdk7786/setup.c
+++ b/arch/sh/boards/mach-sdk7786/setup.c
@@ -20,6 +20,7 @@
 #include <asm/machvec.h>
 #include <asm/heartbeat.h>
 #include <asm/sizes.h>
+#include <asm/reboot.h>
 
 static struct resource heartbeat_resource = {
 	.start		= 0x07fff8b0,
@@ -159,6 +160,11 @@ static int sdk7786_clk_init(void)
 	return ret;
 }
 
+static void sdk7786_restart(char *cmd)
+{
+	fpga_write_reg(0xa5a5, SRSTR);
+}
+
 /* Initialize the board */
 static void __init sdk7786_setup(char **cmdline_p)
 {
@@ -167,6 +173,8 @@ static void __init sdk7786_setup(char **cmdline_p)
 	sdk7786_fpga_init();
 
 	pr_info("\tPCB revision:\t%d\n", fpga_read_reg(PCBRR) & 0xf);
+
+	machine_ops.restart = sdk7786_restart;
 }
 
 /*

commit 5f240718b475dcddee86b138b624f24c681dbb29
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Jan 20 15:23:54 2010 +0900

    sh: mach-sdk7786: Split out FPGA IRQ controller setup.
    
    This moves out the FPGA IRQ controller setup code to its own file, in
    preparation for switching off of IRL mode and having it provide its own
    irq_chip.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-sdk7786/setup.c b/arch/sh/boards/mach-sdk7786/setup.c
index 8dbbdea9c983..3c3c9a38cfda 100644
--- a/arch/sh/boards/mach-sdk7786/setup.c
+++ b/arch/sh/boards/mach-sdk7786/setup.c
@@ -15,10 +15,11 @@
 #include <linux/i2c.h>
 #include <linux/irq.h>
 #include <linux/clk.h>
+#include <mach/fpga.h>
+#include <mach/irq.h>
 #include <asm/machvec.h>
 #include <asm/heartbeat.h>
 #include <asm/sizes.h>
-#include <mach/fpga.h>
 
 static struct resource heartbeat_resource = {
 	.start		= 0x07fff8b0,
@@ -132,41 +133,6 @@ static int __init sdk7786_devices_setup(void)
 }
 __initcall(sdk7786_devices_setup);
 
-enum {
-	ATA_IRQ_BIT		= 1,
-	SPI_BUSY_BIT		= 2,
-	LIRQ5_BIT		= 3,
-	LIRQ6_BIT		= 4,
-	LIRQ7_BIT		= 5,
-	LIRQ8_BIT		= 6,
-	KEY_IRQ_BIT		= 7,
-	PEN_IRQ_BIT		= 8,
-	ETH_IRQ_BIT		= 9,
-	RTC_ALARM_BIT		= 10,
-	CRYSTAL_FAIL_BIT	= 12,
-	ETH_PME_BIT		= 14,
-};
-
-static void __init init_sdk7786_IRQ(void)
-{
-	unsigned int tmp;
-
-	/* Enable priority encoding for all IRLs */
-	fpga_write_reg(fpga_read_reg(INTMSR) | 0x0303, INTMSR);
-
-	/* Clear FPGA interrupt status registers */
-	fpga_write_reg(0x0000, INTASR);
-	fpga_write_reg(0x0000, INTBSR);
-
-	/* Unmask FPGA interrupts */
-	tmp = fpga_read_reg(INTAMR);
-	tmp &= ~(1 << ETH_IRQ_BIT);
-	fpga_write_reg(tmp, INTAMR);
-
-	plat_irq_setup_pins(IRQ_MODE_IRL7654_MASK);
-	plat_irq_setup_pins(IRQ_MODE_IRL3210_MASK);
-}
-
 static int sdk7786_mode_pins(void)
 {
 	return fpga_read_reg(MODSWR);
@@ -211,5 +177,5 @@ static struct sh_machine_vector mv_sdk7786 __initmv = {
 	.mv_setup		= sdk7786_setup,
 	.mv_mode_pins		= sdk7786_mode_pins,
 	.mv_clk_init		= sdk7786_clk_init,
-	.mv_init_irq		= init_sdk7786_IRQ,
+	.mv_init_irq		= sdk7786_init_irq,
 };

commit efd590d57a5edddabaaf4cfaf532c0f674193b81
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Jan 20 15:08:36 2010 +0900

    sh: mach-sdk7786: FPGA updates.
    
    This does a bit of refactoring of the FPGA management code. The primary
    FPGA initialization is moved out to its own file in preparation for
    implementing some of the more complex capabilities, a complete set of
    register definitions is provided, and all of the existing users in the
    board code are moved over to use the new interface instead of setting up
    overlapping mappings. This also corrects the FPGA size, which previously
    was chomped off at the SDIF control register.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-sdk7786/setup.c b/arch/sh/boards/mach-sdk7786/setup.c
index 0e4b1c39742c..8dbbdea9c983 100644
--- a/arch/sh/boards/mach-sdk7786/setup.c
+++ b/arch/sh/boards/mach-sdk7786/setup.c
@@ -18,6 +18,7 @@
 #include <asm/machvec.h>
 #include <asm/heartbeat.h>
 #include <asm/sizes.h>
+#include <mach/fpga.h>
 
 static struct resource heartbeat_resource = {
 	.start		= 0x07fff8b0,
@@ -103,27 +104,17 @@ static struct platform_device *sh7786_devices[] __initdata = {
 	&smbus_pcie_device,
 };
 
-#define SBCR_REGS_BASE	0x07fff990
-
-#define SCBR_I2CMEN	(1 << 0)	/* FPGA I2C master enable */
-#define SCBR_I2CCEN	(1 << 1)	/* CPU I2C master enable */
-
 static int sdk7786_i2c_setup(void)
 {
-	void __iomem *sbcr;
 	unsigned int tmp;
 
-	sbcr = ioremap_nocache(SBCR_REGS_BASE, SZ_16);
-
 	/*
 	 * Hand over I2C control to the FPGA.
 	 */
-	tmp = ioread16(sbcr);
+	tmp = fpga_read_reg(SBCR);
 	tmp &= ~SCBR_I2CCEN;
 	tmp |= SCBR_I2CMEN;
-	iowrite16(tmp, sbcr);
-
-	iounmap(sbcr);
+	fpga_write_reg(tmp, SBCR);
 
 	return i2c_register_board_info(0, sdk7786_i2c_devices,
 				       ARRAY_SIZE(sdk7786_i2c_devices));
@@ -141,43 +132,6 @@ static int __init sdk7786_devices_setup(void)
 }
 __initcall(sdk7786_devices_setup);
 
-#define FPGA_REGS_BASE	0x07fff800
-#define FPGA_REGS_SIZE	1152
-
-#define INTASR		0x010
-#define INTAMR		0x020
-#define INTBSR		0x090
-#define INTBMR		0x0a0
-#define INTMSR		0x130
-
-#define IASELR1		0x210
-#define IASELR2		0x220
-#define IASELR3		0x230
-#define IASELR4		0x240
-#define IASELR5		0x250
-#define IASELR6		0x260
-#define IASELR7		0x270
-#define IASELR8		0x280
-#define IASELR9		0x290
-#define IASELR10	0x2a0
-#define IASELR11	0x2b0
-#define IASELR12	0x2c0
-#define IASELR13	0x2d0
-#define IASELR14	0x2e0
-#define IASELR15	0x2f0
-
-static void __iomem *fpga_regs;
-
-static u16 fpga_read_reg(unsigned int reg)
-{
-	return __raw_readw(fpga_regs + reg);
-}
-
-static void fpga_write_reg(u16 val, unsigned int reg)
-{
-	__raw_writew(val, fpga_regs + reg);
-}
-
 enum {
 	ATA_IRQ_BIT		= 1,
 	SPI_BUSY_BIT		= 2,
@@ -197,12 +151,6 @@ static void __init init_sdk7786_IRQ(void)
 {
 	unsigned int tmp;
 
-	fpga_regs = ioremap_nocache(FPGA_REGS_BASE, FPGA_REGS_SIZE);
-	if (!fpga_regs) {
-		printk(KERN_ERR "Couldn't map FPGA registers\n");
-		return;
-	}
-
 	/* Enable priority encoding for all IRLs */
 	fpga_write_reg(fpga_read_reg(INTMSR) | 0x0303, INTMSR);
 
@@ -219,21 +167,9 @@ static void __init init_sdk7786_IRQ(void)
 	plat_irq_setup_pins(IRQ_MODE_IRL3210_MASK);
 }
 
-#define MODSWR_REGS	0x07fff830
-
 static int sdk7786_mode_pins(void)
 {
-	void __iomem *modswr;
-	int pin_states;
-
-	modswr = ioremap_nocache(MODSWR_REGS, SZ_16);
-	if (!modswr)
-		return -ENXIO;
-
-	pin_states = ioread16(modswr);
-	iounmap(modswr);
-
-	return pin_states;
+	return fpga_read_reg(MODSWR);
 }
 
 static int sdk7786_clk_init(void)
@@ -260,7 +196,11 @@ static int sdk7786_clk_init(void)
 /* Initialize the board */
 static void __init sdk7786_setup(char **cmdline_p)
 {
-	printk(KERN_INFO "Renesas Technology Corp. SDK7786 support.\n");
+	pr_info("Renesas Technology Europe SDK7786 support:\n");
+
+	sdk7786_fpga_init();
+
+	pr_info("\tPCB revision:\t%d\n", fpga_read_reg(PCBRR) & 0xf);
 }
 
 /*

commit c8098218271d19e7123d8b9137b9a4b87e5ffec0
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jan 19 19:38:36 2010 +0900

    sh: mach-sdk7786: Detect/configure/propagate EXTAL.
    
    This uses the mode pins exposed through the FPGA to work out whether
    we're driven from EXTAL or not and does the appropriate setup and
    propagation through the clock framework.
    
    This will also -EINVAL out for anyone adding in their own oscillators,
    forcing proper configuration with the clock framework instead of
    proceeding on with bogus clock values.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-sdk7786/setup.c b/arch/sh/boards/mach-sdk7786/setup.c
index c38c6cc293b5..0e4b1c39742c 100644
--- a/arch/sh/boards/mach-sdk7786/setup.c
+++ b/arch/sh/boards/mach-sdk7786/setup.c
@@ -14,6 +14,7 @@
 #include <linux/smsc911x.h>
 #include <linux/i2c.h>
 #include <linux/irq.h>
+#include <linux/clk.h>
 #include <asm/machvec.h>
 #include <asm/heartbeat.h>
 #include <asm/sizes.h>
@@ -235,6 +236,27 @@ static int sdk7786_mode_pins(void)
 	return pin_states;
 }
 
+static int sdk7786_clk_init(void)
+{
+	struct clk *clk;
+	int ret;
+
+	/*
+	 * Only handle the EXTAL case, anyone interfacing a crystal
+	 * resonator will need to provide their own input clock.
+	 */
+	if (test_mode_pin(MODE_PIN9))
+		return -EINVAL;
+
+	clk = clk_get(NULL, "extal");
+	if (!clk || IS_ERR(clk))
+		return PTR_ERR(clk);
+	ret = clk_set_rate(clk, 33333333);
+	clk_put(clk);
+
+	return ret;
+}
+
 /* Initialize the board */
 static void __init sdk7786_setup(char **cmdline_p)
 {
@@ -248,5 +270,6 @@ static struct sh_machine_vector mv_sdk7786 __initmv = {
 	.mv_name		= "SDK7786",
 	.mv_setup		= sdk7786_setup,
 	.mv_mode_pins		= sdk7786_mode_pins,
+	.mv_clk_init		= sdk7786_clk_init,
 	.mv_init_irq		= init_sdk7786_IRQ,
 };

commit 6f832e8aab8c4c6d28629e970e4a85e74a8d0be6
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Jan 15 16:31:04 2010 +0900

    sh: mach-sdk7786: mode pins support.
    
    This wires up the mode pins support on the SDK7786. The pins are
    standard SH7786 pins, and all are fixed in software. Needed for the
    clock framework, PCIe, and so forth.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-sdk7786/setup.c b/arch/sh/boards/mach-sdk7786/setup.c
index f2d4b75bf31c..c38c6cc293b5 100644
--- a/arch/sh/boards/mach-sdk7786/setup.c
+++ b/arch/sh/boards/mach-sdk7786/setup.c
@@ -218,6 +218,23 @@ static void __init init_sdk7786_IRQ(void)
 	plat_irq_setup_pins(IRQ_MODE_IRL3210_MASK);
 }
 
+#define MODSWR_REGS	0x07fff830
+
+static int sdk7786_mode_pins(void)
+{
+	void __iomem *modswr;
+	int pin_states;
+
+	modswr = ioremap_nocache(MODSWR_REGS, SZ_16);
+	if (!modswr)
+		return -ENXIO;
+
+	pin_states = ioread16(modswr);
+	iounmap(modswr);
+
+	return pin_states;
+}
+
 /* Initialize the board */
 static void __init sdk7786_setup(char **cmdline_p)
 {
@@ -230,5 +247,6 @@ static void __init sdk7786_setup(char **cmdline_p)
 static struct sh_machine_vector mv_sdk7786 __initmv = {
 	.mv_name		= "SDK7786",
 	.mv_setup		= sdk7786_setup,
+	.mv_mode_pins		= sdk7786_mode_pins,
 	.mv_init_irq		= init_sdk7786_IRQ,
 };

commit 2267c7875b3a3a41b7a8cc9659d75ec934c98ffd
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Jan 15 12:11:30 2010 +0900

    sh: mach-sdk7786: heartbeat support.
    
    Hand off the user LEDs to the heartbeat driver.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-sdk7786/setup.c b/arch/sh/boards/mach-sdk7786/setup.c
index b460dcc785c1..f2d4b75bf31c 100644
--- a/arch/sh/boards/mach-sdk7786/setup.c
+++ b/arch/sh/boards/mach-sdk7786/setup.c
@@ -15,8 +15,22 @@
 #include <linux/i2c.h>
 #include <linux/irq.h>
 #include <asm/machvec.h>
+#include <asm/heartbeat.h>
 #include <asm/sizes.h>
 
+static struct resource heartbeat_resource = {
+	.start		= 0x07fff8b0,
+	.end		= 0x07fff8b0 + sizeof(u16) - 1,
+	.flags		= IORESOURCE_MEM | IORESOURCE_MEM_16BIT,
+};
+
+static struct platform_device heartbeat_device = {
+	.name		= "heartbeat",
+	.id		= -1,
+	.num_resources	= 1,
+	.resource	= &heartbeat_resource,
+};
+
 static struct resource smsc911x_resources[] = {
 	[0] = {
 		.name		= "smsc911x-memory",
@@ -82,6 +96,7 @@ static struct i2c_board_info __initdata sdk7786_i2c_devices[] = {
 };
 
 static struct platform_device *sh7786_devices[] __initdata = {
+	&heartbeat_device,
 	&smsc911x_device,
 	&smbus_fpga_device,
 	&smbus_pcie_device,

commit 02bf6cc72cc2a6258411ddf1649f33a65fc9a06e
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Jan 14 20:58:58 2010 +0900

    sh: Preliminary SDK7786 board support.
    
    This stubs in some preliminary board support for the RTE SDK7786.
    
    This is quite stunted at the moment, and primarily builds on top of the
    system FPGA. FPGA IRQs are handled via CPU IRL masking for simplicity,
    with initial peripheral support restricted to the debug ethernet.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-sdk7786/setup.c b/arch/sh/boards/mach-sdk7786/setup.c
new file mode 100644
index 000000000000..b460dcc785c1
--- /dev/null
+++ b/arch/sh/boards/mach-sdk7786/setup.c
@@ -0,0 +1,219 @@
+/*
+ * Renesas Technology Europe SDK7786 Support.
+ *
+ * Copyright (C) 2010  Matt Fleming
+ * Copyright (C) 2010  Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/smsc911x.h>
+#include <linux/i2c.h>
+#include <linux/irq.h>
+#include <asm/machvec.h>
+#include <asm/sizes.h>
+
+static struct resource smsc911x_resources[] = {
+	[0] = {
+		.name		= "smsc911x-memory",
+		.start		= 0x07ffff00,
+		.end		= 0x07ffff00 + SZ_256 - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.name		= "smsc911x-irq",
+		.start		= evt2irq(0x2c0),
+		.end		= evt2irq(0x2c0),
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct smsc911x_platform_config smsc911x_config = {
+	.irq_polarity	= SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
+	.irq_type	= SMSC911X_IRQ_TYPE_OPEN_DRAIN,
+	.flags		= SMSC911X_USE_32BIT,
+	.phy_interface	= PHY_INTERFACE_MODE_MII,
+};
+
+static struct platform_device smsc911x_device = {
+	.name		= "smsc911x",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(smsc911x_resources),
+	.resource	= smsc911x_resources,
+	.dev = {
+		.platform_data = &smsc911x_config,
+	},
+};
+
+static struct resource smbus_fpga_resource = {
+	.start		= 0x07fff9e0,
+	.end		= 0x07fff9e0 + SZ_32 - 1,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device smbus_fpga_device = {
+	.name		= "i2c-sdk7786",
+	.id		= 0,
+	.num_resources	= 1,
+	.resource	= &smbus_fpga_resource,
+};
+
+static struct resource smbus_pcie_resource = {
+	.start		= 0x07fffc30,
+	.end		= 0x07fffc30 + SZ_32 - 1,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device smbus_pcie_device = {
+	.name		= "i2c-sdk7786",
+	.id		= 1,
+	.num_resources	= 1,
+	.resource	= &smbus_pcie_resource,
+};
+
+static struct i2c_board_info __initdata sdk7786_i2c_devices[] = {
+	{
+		I2C_BOARD_INFO("max6900", 0x68),
+	},
+};
+
+static struct platform_device *sh7786_devices[] __initdata = {
+	&smsc911x_device,
+	&smbus_fpga_device,
+	&smbus_pcie_device,
+};
+
+#define SBCR_REGS_BASE	0x07fff990
+
+#define SCBR_I2CMEN	(1 << 0)	/* FPGA I2C master enable */
+#define SCBR_I2CCEN	(1 << 1)	/* CPU I2C master enable */
+
+static int sdk7786_i2c_setup(void)
+{
+	void __iomem *sbcr;
+	unsigned int tmp;
+
+	sbcr = ioremap_nocache(SBCR_REGS_BASE, SZ_16);
+
+	/*
+	 * Hand over I2C control to the FPGA.
+	 */
+	tmp = ioread16(sbcr);
+	tmp &= ~SCBR_I2CCEN;
+	tmp |= SCBR_I2CMEN;
+	iowrite16(tmp, sbcr);
+
+	iounmap(sbcr);
+
+	return i2c_register_board_info(0, sdk7786_i2c_devices,
+				       ARRAY_SIZE(sdk7786_i2c_devices));
+}
+
+static int __init sdk7786_devices_setup(void)
+{
+	int ret;
+
+	ret = platform_add_devices(sh7786_devices, ARRAY_SIZE(sh7786_devices));
+	if (unlikely(ret != 0))
+		return ret;
+
+	return sdk7786_i2c_setup();
+}
+__initcall(sdk7786_devices_setup);
+
+#define FPGA_REGS_BASE	0x07fff800
+#define FPGA_REGS_SIZE	1152
+
+#define INTASR		0x010
+#define INTAMR		0x020
+#define INTBSR		0x090
+#define INTBMR		0x0a0
+#define INTMSR		0x130
+
+#define IASELR1		0x210
+#define IASELR2		0x220
+#define IASELR3		0x230
+#define IASELR4		0x240
+#define IASELR5		0x250
+#define IASELR6		0x260
+#define IASELR7		0x270
+#define IASELR8		0x280
+#define IASELR9		0x290
+#define IASELR10	0x2a0
+#define IASELR11	0x2b0
+#define IASELR12	0x2c0
+#define IASELR13	0x2d0
+#define IASELR14	0x2e0
+#define IASELR15	0x2f0
+
+static void __iomem *fpga_regs;
+
+static u16 fpga_read_reg(unsigned int reg)
+{
+	return __raw_readw(fpga_regs + reg);
+}
+
+static void fpga_write_reg(u16 val, unsigned int reg)
+{
+	__raw_writew(val, fpga_regs + reg);
+}
+
+enum {
+	ATA_IRQ_BIT		= 1,
+	SPI_BUSY_BIT		= 2,
+	LIRQ5_BIT		= 3,
+	LIRQ6_BIT		= 4,
+	LIRQ7_BIT		= 5,
+	LIRQ8_BIT		= 6,
+	KEY_IRQ_BIT		= 7,
+	PEN_IRQ_BIT		= 8,
+	ETH_IRQ_BIT		= 9,
+	RTC_ALARM_BIT		= 10,
+	CRYSTAL_FAIL_BIT	= 12,
+	ETH_PME_BIT		= 14,
+};
+
+static void __init init_sdk7786_IRQ(void)
+{
+	unsigned int tmp;
+
+	fpga_regs = ioremap_nocache(FPGA_REGS_BASE, FPGA_REGS_SIZE);
+	if (!fpga_regs) {
+		printk(KERN_ERR "Couldn't map FPGA registers\n");
+		return;
+	}
+
+	/* Enable priority encoding for all IRLs */
+	fpga_write_reg(fpga_read_reg(INTMSR) | 0x0303, INTMSR);
+
+	/* Clear FPGA interrupt status registers */
+	fpga_write_reg(0x0000, INTASR);
+	fpga_write_reg(0x0000, INTBSR);
+
+	/* Unmask FPGA interrupts */
+	tmp = fpga_read_reg(INTAMR);
+	tmp &= ~(1 << ETH_IRQ_BIT);
+	fpga_write_reg(tmp, INTAMR);
+
+	plat_irq_setup_pins(IRQ_MODE_IRL7654_MASK);
+	plat_irq_setup_pins(IRQ_MODE_IRL3210_MASK);
+}
+
+/* Initialize the board */
+static void __init sdk7786_setup(char **cmdline_p)
+{
+	printk(KERN_INFO "Renesas Technology Corp. SDK7786 support.\n");
+}
+
+/*
+ * The Machine Vector
+ */
+static struct sh_machine_vector mv_sdk7786 __initmv = {
+	.mv_name		= "SDK7786",
+	.mv_setup		= sdk7786_setup,
+	.mv_init_irq		= init_sdk7786_IRQ,
+};
