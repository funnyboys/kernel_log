commit e602b26ce4758e0eb97252363d32bd294afea530
Author: Sabyasachi Gupta <sabyasachi.linux@gmail.com>
Date:   Mon May 13 17:15:46 2019 -0700

    arch/sh/boards/mach-dreamcast/irq.c: Remove duplicate header
    
    Remove linux/irq.h which is included more than once.
    
    Link: http://lkml.kernel.org/r/5c8682ef.1c69fb81.5a1ea.2e7f@mx.google.com
    Signed-off-by: Sabyasachi Gupta <sabyasachi.linux@gmail.com>
    Acked-by: Souptick Joarder <jrdr.linux@gmail.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Mukesh Ojha <mojha@codeaurora.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/boards/mach-dreamcast/irq.c b/arch/sh/boards/mach-dreamcast/irq.c
index a929f764ae04..cc06e4cdb4cd 100644
--- a/arch/sh/boards/mach-dreamcast/irq.c
+++ b/arch/sh/boards/mach-dreamcast/irq.c
@@ -10,7 +10,6 @@
  */
 #include <linux/irq.h>
 #include <linux/io.h>
-#include <linux/irq.h>
 #include <linux/export.h>
 #include <linux/err.h>
 #include <mach/sysasic.h>

commit aaf9128abcb8314eb9756db3e32d667c5161156f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 28 00:31:46 2018 -0800

    sh: boards: convert to SPDX identifiers
    
    Update license to use SPDX-License-Identifier instead of verbose license
    text.
    
    Link: http://lkml.kernel.org/r/87in08ct0n.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/boards/mach-dreamcast/irq.c b/arch/sh/boards/mach-dreamcast/irq.c
index 2789647abebe..a929f764ae04 100644
--- a/arch/sh/boards/mach-dreamcast/irq.c
+++ b/arch/sh/boards/mach-dreamcast/irq.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * arch/sh/boards/dreamcast/irq.c
  *
@@ -6,7 +7,6 @@
  * Copyright (c) 2001, 2002 M. R. Brown <mrbrown@0xd6.org>
  *
  * This file is part of the LinuxDC project (www.linuxdc.org)
- * Released under the terms of the GNU GPL v2.0
  */
 #include <linux/irq.h>
 #include <linux/io.h>

commit 3b1267b90f6b7c080024101696c0454f455761f4
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri May 18 23:36:44 2012 +0900

    sh: dreamcast: Migrate off of deprecated dynamic IRQ API.
    
    Switches from create_irq_nr() to irq_alloc_descs().
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-dreamcast/irq.c b/arch/sh/boards/mach-dreamcast/irq.c
index f63d323f411f..2789647abebe 100644
--- a/arch/sh/boards/mach-dreamcast/irq.c
+++ b/arch/sh/boards/mach-dreamcast/irq.c
@@ -8,10 +8,11 @@
  * This file is part of the LinuxDC project (www.linuxdc.org)
  * Released under the terms of the GNU GPL v2.0
  */
-
 #include <linux/irq.h>
 #include <linux/io.h>
-#include <asm/irq.h>
+#include <linux/irq.h>
+#include <linux/export.h>
+#include <linux/err.h>
 #include <mach/sysasic.h>
 
 /*
@@ -141,26 +142,15 @@ int systemasic_irq_demux(int irq)
 
 void systemasic_irq_init(void)
 {
-	int i, nid = cpu_to_node(boot_cpu_data);
-
-	/* Assign all virtual IRQs to the System ASIC int. handler */
-	for (i = HW_EVENT_IRQ_BASE; i < HW_EVENT_IRQ_MAX; i++) {
-		unsigned int irq;
-
-		irq = create_irq_nr(i, nid);
-		if (unlikely(irq == 0)) {
-			pr_err("%s: failed hooking irq %d for systemasic\n",
-			       __func__, i);
-			return;
-		}
+	int irq_base, i;
 
-		if (unlikely(irq != i)) {
-			pr_err("%s: got irq %d but wanted %d, bailing.\n",
-			       __func__, irq, i);
-			destroy_irq(irq);
-			return;
-		}
+	irq_base = irq_alloc_descs(HW_EVENT_IRQ_BASE, HW_EVENT_IRQ_BASE,
+				   HW_EVENT_IRQ_MAX - HW_EVENT_IRQ_BASE, -1);
+	if (IS_ERR_VALUE(irq_base)) {
+		pr_err("%s: failed hooking irqs\n", __func__);
+		return;
+	}
 
+	for (i = HW_EVENT_IRQ_BASE; i < HW_EVENT_IRQ_MAX; i++)
 		irq_set_chip_and_handler(i, &systemasic_int, handle_level_irq);
-	}
 }

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/arch/sh/boards/mach-dreamcast/irq.c b/arch/sh/boards/mach-dreamcast/irq.c
index 78cf2ab89d7a..f63d323f411f 100644
--- a/arch/sh/boards/mach-dreamcast/irq.c
+++ b/arch/sh/boards/mach-dreamcast/irq.c
@@ -51,7 +51,7 @@
  */
 #define LEVEL(event) (((event) - HW_EVENT_IRQ_BASE) / 32)
 
-/* Return the hardware event's bit positon within the EMR/ESR */
+/* Return the hardware event's bit position within the EMR/ESR */
 #define EVENT_BIT(event) (((event) - HW_EVENT_IRQ_BASE) & 31)
 
 /*

commit fcb8918fd242f39496090dbbd6789ab24098295b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 16:31:17 2011 +0100

    sh: Convert to new function names
    
    Scripted with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/sh/boards/mach-dreamcast/irq.c b/arch/sh/boards/mach-dreamcast/irq.c
index 72e7ac9549da..78cf2ab89d7a 100644
--- a/arch/sh/boards/mach-dreamcast/irq.c
+++ b/arch/sh/boards/mach-dreamcast/irq.c
@@ -161,7 +161,6 @@ void systemasic_irq_init(void)
 			return;
 		}
 
-		set_irq_chip_and_handler(i, &systemasic_int,
-					 handle_level_irq);
+		irq_set_chip_and_handler(i, &systemasic_int, handle_level_irq);
 	}
 }

commit 0d338071f2fff7551f9afe22016d9b34b45900b5
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Wed Oct 27 14:36:28 2010 +0900

    sh: mach-dreamcast: irq_data conversion.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-dreamcast/irq.c b/arch/sh/boards/mach-dreamcast/irq.c
index d932667410ab..72e7ac9549da 100644
--- a/arch/sh/boards/mach-dreamcast/irq.c
+++ b/arch/sh/boards/mach-dreamcast/irq.c
@@ -60,8 +60,9 @@
  */
 
 /* Disable the hardware event by masking its bit in its EMR */
-static inline void disable_systemasic_irq(unsigned int irq)
+static inline void disable_systemasic_irq(struct irq_data *data)
 {
+	unsigned int irq = data->irq;
 	__u32 emr = EMR_BASE + (LEVEL(irq) << 4) + (LEVEL(irq) << 2);
 	__u32 mask;
 
@@ -71,8 +72,9 @@ static inline void disable_systemasic_irq(unsigned int irq)
 }
 
 /* Enable the hardware event by setting its bit in its EMR */
-static inline void enable_systemasic_irq(unsigned int irq)
+static inline void enable_systemasic_irq(struct irq_data *data)
 {
+	unsigned int irq = data->irq;
 	__u32 emr = EMR_BASE + (LEVEL(irq) << 4) + (LEVEL(irq) << 2);
 	__u32 mask;
 
@@ -82,18 +84,19 @@ static inline void enable_systemasic_irq(unsigned int irq)
 }
 
 /* Acknowledge a hardware event by writing its bit back to its ESR */
-static void mask_ack_systemasic_irq(unsigned int irq)
+static void mask_ack_systemasic_irq(struct irq_data *data)
 {
+	unsigned int irq = data->irq;
 	__u32 esr = ESR_BASE + (LEVEL(irq) << 2);
-	disable_systemasic_irq(irq);
+	disable_systemasic_irq(data);
 	outl((1 << EVENT_BIT(irq)), esr);
 }
 
 struct irq_chip systemasic_int = {
 	.name		= "System ASIC",
-	.mask		= disable_systemasic_irq,
-	.mask_ack	= mask_ack_systemasic_irq,
-	.unmask		= enable_systemasic_irq,
+	.irq_mask	= disable_systemasic_irq,
+	.irq_mask_ack	= mask_ack_systemasic_irq,
+	.irq_unmask	= enable_systemasic_irq,
 };
 
 /*

commit deb9b22b8968fa0166d89c8ad1346e816cf1aec4
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Feb 2 18:01:55 2010 +0900

    sh: mach-dreamcast: Convert to sparseirq.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-dreamcast/irq.c b/arch/sh/boards/mach-dreamcast/irq.c
index f55fc8e795e9..d932667410ab 100644
--- a/arch/sh/boards/mach-dreamcast/irq.c
+++ b/arch/sh/boards/mach-dreamcast/irq.c
@@ -135,3 +135,30 @@ int systemasic_irq_demux(int irq)
 	/* Not reached */
 	return irq;
 }
+
+void systemasic_irq_init(void)
+{
+	int i, nid = cpu_to_node(boot_cpu_data);
+
+	/* Assign all virtual IRQs to the System ASIC int. handler */
+	for (i = HW_EVENT_IRQ_BASE; i < HW_EVENT_IRQ_MAX; i++) {
+		unsigned int irq;
+
+		irq = create_irq_nr(i, nid);
+		if (unlikely(irq == 0)) {
+			pr_err("%s: failed hooking irq %d for systemasic\n",
+			       __func__, i);
+			return;
+		}
+
+		if (unlikely(irq != i)) {
+			pr_err("%s: got irq %d but wanted %d, bailing.\n",
+			       __func__, irq, i);
+			destroy_irq(irq);
+			return;
+		}
+
+		set_irq_chip_and_handler(i, &systemasic_int,
+					 handle_level_irq);
+	}
+}

commit e85a47744bbdfbcc65c94b2af67499f861c6fa42
Author: Matt Fleming <mjf@gentoo.org>
Date:   Sun Dec 14 12:02:26 2008 +0000

    sh: Convert Dreamcast support from hw_interrupt_type to irq_chip
    
    Switch the dreamcast IRQ code over to the irq_chip way of doing things,
    so that we can set GENERIC_HARDIRQS_NO__DO_IRQ for all SuperH boards.
    
    Also, whilst I'm here change some things to make checkpatch.pl happy:
            - Indent with tabs, not with spaces
            - Include <linux/io.h>, not <asm/io.h>
            - Fix the multi-line comment style
            - Fix some typos in the comments
    
    Tested-by: Adrian McMenamin <adrian@newgolddream.dyndns.info>
    Signed-off-by: Matt Fleming <mjf@gentoo.org>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-dreamcast/irq.c b/arch/sh/boards/mach-dreamcast/irq.c
index 67bdc33dd411..f55fc8e795e9 100644
--- a/arch/sh/boards/mach-dreamcast/irq.c
+++ b/arch/sh/boards/mach-dreamcast/irq.c
@@ -10,106 +10,90 @@
  */
 
 #include <linux/irq.h>
-#include <asm/io.h>
+#include <linux/io.h>
 #include <asm/irq.h>
 #include <mach/sysasic.h>
 
-/* Dreamcast System ASIC Hardware Events -
-
-   The Dreamcast's System ASIC (a.k.a. Holly) is responsible for receiving
-   hardware events from system peripherals and triggering an SH7750 IRQ.
-   Hardware events can trigger IRQs 13, 11, or 9 depending on which bits are
-   set in the Event Mask Registers (EMRs).  When a hardware event is
-   triggered, it's corresponding bit in the Event Status Registers (ESRs)
-   is set, and that bit should be rewritten to the ESR to acknowledge that
-   event.
-
-   There are three 32-bit ESRs located at 0xa05f8900 - 0xa05f6908.  Event
-   types can be found in include/asm-sh/dreamcast/sysasic.h. There are three
-   groups of EMRs that parallel the ESRs.  Each EMR group corresponds to an
-   IRQ, so 0xa05f6910 - 0xa05f6918 triggers IRQ 13, 0xa05f6920 - 0xa05f6928
-   triggers IRQ 11, and 0xa05f6930 - 0xa05f6938 triggers IRQ 9.
-
-   In the kernel, these events are mapped to virtual IRQs so that drivers can
-   respond to them as they would a normal interrupt.  In order to keep this
-   mapping simple, the events are mapped as:
-
-   6900/6910 - Events  0-31, IRQ 13
-   6904/6924 - Events 32-63, IRQ 11
-   6908/6938 - Events 64-95, IRQ  9
-
-*/
+/*
+ * Dreamcast System ASIC Hardware Events -
+ *
+ * The Dreamcast's System ASIC (a.k.a. Holly) is responsible for receiving
+ * hardware events from system peripherals and triggering an SH7750 IRQ.
+ * Hardware events can trigger IRQs 13, 11, or 9 depending on which bits are
+ * set in the Event Mask Registers (EMRs).  When a hardware event is
+ * triggered, its corresponding bit in the Event Status Registers (ESRs)
+ * is set, and that bit should be rewritten to the ESR to acknowledge that
+ * event.
+ *
+ * There are three 32-bit ESRs located at 0xa05f6900 - 0xa05f6908.  Event
+ * types can be found in arch/sh/include/mach-dreamcast/mach/sysasic.h.
+ * There are three groups of EMRs that parallel the ESRs.  Each EMR group
+ * corresponds to an IRQ, so 0xa05f6910 - 0xa05f6918 triggers IRQ 13,
+ * 0xa05f6920 - 0xa05f6928 triggers IRQ 11, and 0xa05f6930 - 0xa05f6938
+ * triggers IRQ 9.
+ *
+ * In the kernel, these events are mapped to virtual IRQs so that drivers can
+ * respond to them as they would a normal interrupt.  In order to keep this
+ * mapping simple, the events are mapped as:
+ *
+ * 6900/6910 - Events  0-31, IRQ 13
+ * 6904/6924 - Events 32-63, IRQ 11
+ * 6908/6938 - Events 64-95, IRQ  9
+ *
+ */
 
 #define ESR_BASE 0x005f6900    /* Base event status register */
 #define EMR_BASE 0x005f6910    /* Base event mask register */
 
-/* Helps us determine the EMR group that this event belongs to: 0 = 0x6910,
-   1 = 0x6920, 2 = 0x6930; also determine the event offset */
+/*
+ * Helps us determine the EMR group that this event belongs to: 0 = 0x6910,
+ * 1 = 0x6920, 2 = 0x6930; also determine the event offset.
+ */
 #define LEVEL(event) (((event) - HW_EVENT_IRQ_BASE) / 32)
 
 /* Return the hardware event's bit positon within the EMR/ESR */
 #define EVENT_BIT(event) (((event) - HW_EVENT_IRQ_BASE) & 31)
 
-/* For each of these *_irq routines, the IRQ passed in is the virtual IRQ
-   (logically mapped to the corresponding bit for the hardware event). */
+/*
+ * For each of these *_irq routines, the IRQ passed in is the virtual IRQ
+ * (logically mapped to the corresponding bit for the hardware event).
+ */
 
 /* Disable the hardware event by masking its bit in its EMR */
 static inline void disable_systemasic_irq(unsigned int irq)
 {
-        __u32 emr = EMR_BASE + (LEVEL(irq) << 4) + (LEVEL(irq) << 2);
-        __u32 mask;
+	__u32 emr = EMR_BASE + (LEVEL(irq) << 4) + (LEVEL(irq) << 2);
+	__u32 mask;
 
-        mask = inl(emr);
-        mask &= ~(1 << EVENT_BIT(irq));
-        outl(mask, emr);
+	mask = inl(emr);
+	mask &= ~(1 << EVENT_BIT(irq));
+	outl(mask, emr);
 }
 
 /* Enable the hardware event by setting its bit in its EMR */
 static inline void enable_systemasic_irq(unsigned int irq)
 {
-        __u32 emr = EMR_BASE + (LEVEL(irq) << 4) + (LEVEL(irq) << 2);
-        __u32 mask;
+	__u32 emr = EMR_BASE + (LEVEL(irq) << 4) + (LEVEL(irq) << 2);
+	__u32 mask;
 
-        mask = inl(emr);
-        mask |= (1 << EVENT_BIT(irq));
-        outl(mask, emr);
+	mask = inl(emr);
+	mask |= (1 << EVENT_BIT(irq));
+	outl(mask, emr);
 }
 
 /* Acknowledge a hardware event by writing its bit back to its ESR */
-static void ack_systemasic_irq(unsigned int irq)
-{
-        __u32 esr = ESR_BASE + (LEVEL(irq) << 2);
-        disable_systemasic_irq(irq);
-        outl((1 << EVENT_BIT(irq)), esr);
-}
-
-/* After a IRQ has been ack'd and responded to, it needs to be renabled */
-static void end_systemasic_irq(unsigned int irq)
-{
-        if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
-                enable_systemasic_irq(irq);
-}
-
-static unsigned int startup_systemasic_irq(unsigned int irq)
-{
-        enable_systemasic_irq(irq);
-
-        return 0;
-}
-
-static void shutdown_systemasic_irq(unsigned int irq)
+static void mask_ack_systemasic_irq(unsigned int irq)
 {
-        disable_systemasic_irq(irq);
+	__u32 esr = ESR_BASE + (LEVEL(irq) << 2);
+	disable_systemasic_irq(irq);
+	outl((1 << EVENT_BIT(irq)), esr);
 }
 
-struct hw_interrupt_type systemasic_int = {
-        .typename       = "System ASIC",
-        .startup        = startup_systemasic_irq,
-        .shutdown       = shutdown_systemasic_irq,
-        .enable         = enable_systemasic_irq,
-        .disable        = disable_systemasic_irq,
-        .ack            = ack_systemasic_irq,
-        .end            = end_systemasic_irq,
+struct irq_chip systemasic_int = {
+	.name		= "System ASIC",
+	.mask		= disable_systemasic_irq,
+	.mask_ack	= mask_ack_systemasic_irq,
+	.unmask		= enable_systemasic_irq,
 };
 
 /*
@@ -117,37 +101,37 @@ struct hw_interrupt_type systemasic_int = {
  */
 int systemasic_irq_demux(int irq)
 {
-        __u32 emr, esr, status, level;
-        __u32 j, bit;
-
-        switch (irq) {
-                case 13:
-                        level = 0;
-                        break;
-                case 11:
-                        level = 1;
-                        break;
-                case  9:
-                        level = 2;
-                        break;
-                default:
-                        return irq;
-        }
-        emr = EMR_BASE + (level << 4) + (level << 2);
-        esr = ESR_BASE + (level << 2);
-
-        /* Mask the ESR to filter any spurious, unwanted interrupts */
-        status = inl(esr);
-        status &= inl(emr);
-
-        /* Now scan and find the first set bit as the event to map */
-        for (bit = 1, j = 0; j < 32; bit <<= 1, j++) {
-                if (status & bit) {
-                        irq = HW_EVENT_IRQ_BASE + j + (level << 5);
-                        return irq;
-                }
-        }
-
-        /* Not reached */
-        return irq;
+	__u32 emr, esr, status, level;
+	__u32 j, bit;
+
+	switch (irq) {
+	case 13:
+		level = 0;
+		break;
+	case 11:
+		level = 1;
+		break;
+	case  9:
+		level = 2;
+		break;
+	default:
+		return irq;
+	}
+	emr = EMR_BASE + (level << 4) + (level << 2);
+	esr = ESR_BASE + (level << 2);
+
+	/* Mask the ESR to filter any spurious, unwanted interrupts */
+	status = inl(esr);
+	status &= inl(emr);
+
+	/* Now scan and find the first set bit as the event to map */
+	for (bit = 1, j = 0; j < 32; bit <<= 1, j++) {
+		if (status & bit) {
+			irq = HW_EVENT_IRQ_BASE + j + (level << 5);
+			return irq;
+		}
+	}
+
+	/* Not reached */
+	return irq;
 }

commit da2014a2b080e7f3024a4eb6917d47069ad9620b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jul 29 21:01:19 2008 +0900

    sh: Shuffle the board directories in to mach groups.
    
    This flattens out the board directories in to individual mach groups,
    we will use this for getting rid of unneeded directories, simplifying
    the build system, and becoming more coherent with the refactored
    arch/sh/include topology.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-dreamcast/irq.c b/arch/sh/boards/mach-dreamcast/irq.c
new file mode 100644
index 000000000000..67bdc33dd411
--- /dev/null
+++ b/arch/sh/boards/mach-dreamcast/irq.c
@@ -0,0 +1,153 @@
+/*
+ * arch/sh/boards/dreamcast/irq.c
+ *
+ * Holly IRQ support for the Sega Dreamcast.
+ *
+ * Copyright (c) 2001, 2002 M. R. Brown <mrbrown@0xd6.org>
+ *
+ * This file is part of the LinuxDC project (www.linuxdc.org)
+ * Released under the terms of the GNU GPL v2.0
+ */
+
+#include <linux/irq.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <mach/sysasic.h>
+
+/* Dreamcast System ASIC Hardware Events -
+
+   The Dreamcast's System ASIC (a.k.a. Holly) is responsible for receiving
+   hardware events from system peripherals and triggering an SH7750 IRQ.
+   Hardware events can trigger IRQs 13, 11, or 9 depending on which bits are
+   set in the Event Mask Registers (EMRs).  When a hardware event is
+   triggered, it's corresponding bit in the Event Status Registers (ESRs)
+   is set, and that bit should be rewritten to the ESR to acknowledge that
+   event.
+
+   There are three 32-bit ESRs located at 0xa05f8900 - 0xa05f6908.  Event
+   types can be found in include/asm-sh/dreamcast/sysasic.h. There are three
+   groups of EMRs that parallel the ESRs.  Each EMR group corresponds to an
+   IRQ, so 0xa05f6910 - 0xa05f6918 triggers IRQ 13, 0xa05f6920 - 0xa05f6928
+   triggers IRQ 11, and 0xa05f6930 - 0xa05f6938 triggers IRQ 9.
+
+   In the kernel, these events are mapped to virtual IRQs so that drivers can
+   respond to them as they would a normal interrupt.  In order to keep this
+   mapping simple, the events are mapped as:
+
+   6900/6910 - Events  0-31, IRQ 13
+   6904/6924 - Events 32-63, IRQ 11
+   6908/6938 - Events 64-95, IRQ  9
+
+*/
+
+#define ESR_BASE 0x005f6900    /* Base event status register */
+#define EMR_BASE 0x005f6910    /* Base event mask register */
+
+/* Helps us determine the EMR group that this event belongs to: 0 = 0x6910,
+   1 = 0x6920, 2 = 0x6930; also determine the event offset */
+#define LEVEL(event) (((event) - HW_EVENT_IRQ_BASE) / 32)
+
+/* Return the hardware event's bit positon within the EMR/ESR */
+#define EVENT_BIT(event) (((event) - HW_EVENT_IRQ_BASE) & 31)
+
+/* For each of these *_irq routines, the IRQ passed in is the virtual IRQ
+   (logically mapped to the corresponding bit for the hardware event). */
+
+/* Disable the hardware event by masking its bit in its EMR */
+static inline void disable_systemasic_irq(unsigned int irq)
+{
+        __u32 emr = EMR_BASE + (LEVEL(irq) << 4) + (LEVEL(irq) << 2);
+        __u32 mask;
+
+        mask = inl(emr);
+        mask &= ~(1 << EVENT_BIT(irq));
+        outl(mask, emr);
+}
+
+/* Enable the hardware event by setting its bit in its EMR */
+static inline void enable_systemasic_irq(unsigned int irq)
+{
+        __u32 emr = EMR_BASE + (LEVEL(irq) << 4) + (LEVEL(irq) << 2);
+        __u32 mask;
+
+        mask = inl(emr);
+        mask |= (1 << EVENT_BIT(irq));
+        outl(mask, emr);
+}
+
+/* Acknowledge a hardware event by writing its bit back to its ESR */
+static void ack_systemasic_irq(unsigned int irq)
+{
+        __u32 esr = ESR_BASE + (LEVEL(irq) << 2);
+        disable_systemasic_irq(irq);
+        outl((1 << EVENT_BIT(irq)), esr);
+}
+
+/* After a IRQ has been ack'd and responded to, it needs to be renabled */
+static void end_systemasic_irq(unsigned int irq)
+{
+        if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+                enable_systemasic_irq(irq);
+}
+
+static unsigned int startup_systemasic_irq(unsigned int irq)
+{
+        enable_systemasic_irq(irq);
+
+        return 0;
+}
+
+static void shutdown_systemasic_irq(unsigned int irq)
+{
+        disable_systemasic_irq(irq);
+}
+
+struct hw_interrupt_type systemasic_int = {
+        .typename       = "System ASIC",
+        .startup        = startup_systemasic_irq,
+        .shutdown       = shutdown_systemasic_irq,
+        .enable         = enable_systemasic_irq,
+        .disable        = disable_systemasic_irq,
+        .ack            = ack_systemasic_irq,
+        .end            = end_systemasic_irq,
+};
+
+/*
+ * Map the hardware event indicated by the processor IRQ to a virtual IRQ.
+ */
+int systemasic_irq_demux(int irq)
+{
+        __u32 emr, esr, status, level;
+        __u32 j, bit;
+
+        switch (irq) {
+                case 13:
+                        level = 0;
+                        break;
+                case 11:
+                        level = 1;
+                        break;
+                case  9:
+                        level = 2;
+                        break;
+                default:
+                        return irq;
+        }
+        emr = EMR_BASE + (level << 4) + (level << 2);
+        esr = ESR_BASE + (level << 2);
+
+        /* Mask the ESR to filter any spurious, unwanted interrupts */
+        status = inl(esr);
+        status &= inl(emr);
+
+        /* Now scan and find the first set bit as the event to map */
+        for (bit = 1, j = 0; j < 32; bit <<= 1, j++) {
+                if (status & bit) {
+                        irq = HW_EVENT_IRQ_BASE + j + (level << 5);
+                        return irq;
+                }
+        }
+
+        /* Not reached */
+        return irq;
+}
