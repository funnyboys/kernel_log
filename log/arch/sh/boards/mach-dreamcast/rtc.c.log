commit f346b0becb1bc62e45495f9cdbae3eef35d0b635
Merge: 00d59fde8532 0f4991e8fd48
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 28 16:55:46 2018 -0800

    Merge branch 'akpm' (patches from Andrew)
    
    Merge misc updates from Andrew Morton:
    
     - large KASAN update to use arm's "software tag-based mode"
    
     - a few misc things
    
     - sh updates
    
     - ocfs2 updates
    
     - just about all of MM
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (167 commits)
      kernel/fork.c: mark 'stack_vm_area' with __maybe_unused
      memcg, oom: notify on oom killer invocation from the charge path
      mm, swap: fix swapoff with KSM pages
      include/linux/gfp.h: fix typo
      mm/hmm: fix memremap.h, move dev_page_fault_t callback to hmm
      hugetlbfs: Use i_mmap_rwsem to fix page fault/truncate race
      hugetlbfs: use i_mmap_rwsem for more pmd sharing synchronization
      memory_hotplug: add missing newlines to debugging output
      mm: remove __hugepage_set_anon_rmap()
      include/linux/vmstat.h: remove unused page state adjustment macro
      mm/page_alloc.c: allow error injection
      mm: migrate: drop unused argument of migrate_page_move_mapping()
      blkdev: avoid migration stalls for blkdev pages
      mm: migrate: provide buffer_migrate_page_norefs()
      mm: migrate: move migrate_page_lock_buffers()
      mm: migrate: lock buffers before migrate_page_move_mapping()
      mm: migration: factor out code to compute expected number of page references
      mm, page_alloc: enable pcpu_drain with zone capability
      kmemleak: add config to select auto scan
      mm/page_alloc.c: don't call kasan_free_pages() at deferred mem init
      ...

commit aaf9128abcb8314eb9756db3e32d667c5161156f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Fri Dec 28 00:31:46 2018 -0800

    sh: boards: convert to SPDX identifiers
    
    Update license to use SPDX-License-Identifier instead of verbose license
    text.
    
    Link: http://lkml.kernel.org/r/87in08ct0n.wl-kuninori.morimoto.gx@renesas.com
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/sh/boards/mach-dreamcast/rtc.c b/arch/sh/boards/mach-dreamcast/rtc.c
index 061d65714fcc..e468dcce1927 100644
--- a/arch/sh/boards/mach-dreamcast/rtc.c
+++ b/arch/sh/boards/mach-dreamcast/rtc.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * arch/sh/boards/dreamcast/rtc.c
  *
@@ -5,9 +6,6 @@
  *
  * Copyright (c) 2001, 2002 M. R. Brown <mrbrown@0xd6.org>
  * Copyright (c) 2002 Paul Mundt <lethal@chaoticdreams.org>
- *
- * Released under the terms of the GNU GPL v2.0.
- *
  */
 
 #include <linux/time.h>

commit b0495e4b67b230cdb8a7ba244cd260e529c53b84
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jan 24 15:04:31 2018 +0100

    sh: dreamcast: rtc: push down rtc class ops into driver
    
    The SH RTC support has an extra level of indirection to provide
    either the old read_persistent_clock/update_persistent_clock
    interface or the rtc-generic device for hctosys/systohc.
    
    Both do the same thing for dreamcast, so we can do away with the
    abstraction and simply let the RTC core code to take care of it.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/sh/boards/mach-dreamcast/rtc.c b/arch/sh/boards/mach-dreamcast/rtc.c
index 061d65714fcc..0eb12c45fa59 100644
--- a/arch/sh/boards/mach-dreamcast/rtc.c
+++ b/arch/sh/boards/mach-dreamcast/rtc.c
@@ -11,8 +11,9 @@
  */
 
 #include <linux/time.h>
-#include <asm/rtc.h>
-#include <asm/io.h>
+#include <linux/rtc.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
 
 /* The AICA RTC has an Epoch of 1/1/1950, so we must subtract 20 years (in
    seconds) to get the standard Unix Epoch when getting the time, and add
@@ -26,13 +27,15 @@
 
 /**
  * aica_rtc_gettimeofday - Get the time from the AICA RTC
- * @ts: pointer to resulting timespec
+ * @dev: the RTC device (ignored)
+ * @tm: pointer to resulting RTC time structure
  *
  * Grabs the current RTC seconds counter and adjusts it to the Unix Epoch.
  */
-static void aica_rtc_gettimeofday(struct timespec *ts)
+static int aica_rtc_gettimeofday(struct device *dev, struct rtc_time *tm)
 {
 	unsigned long val1, val2;
+	time64_t t;
 
 	do {
 		val1 = ((__raw_readl(AICA_RTC_SECS_H) & 0xffff) << 16) |
@@ -42,22 +45,26 @@ static void aica_rtc_gettimeofday(struct timespec *ts)
 			(__raw_readl(AICA_RTC_SECS_L) & 0xffff);
 	} while (val1 != val2);
 
-	ts->tv_sec = val1 - TWENTY_YEARS;
+	/* normalize to 1970..2106 time range */
+	t = (u32)(val1 - TWENTY_YEARS);
 
-	/* Can't get nanoseconds with just a seconds counter. */
-	ts->tv_nsec = 0;
+	rtc_time64_to_tm(t, tm);
+
+	return 0;
 }
 
 /**
  * aica_rtc_settimeofday - Set the AICA RTC to the current time
- * @secs: contains the time_t to set
+ * @dev: the RTC device (ignored)
+ * @tm: pointer to new RTC time structure
  *
  * Adjusts the given @tv to the AICA Epoch and sets the RTC seconds counter.
  */
-static int aica_rtc_settimeofday(const time_t secs)
+static int aica_rtc_settimeofday(struct device *dev, struct rtc_time *tm)
 {
 	unsigned long val1, val2;
-	unsigned long adj = secs + TWENTY_YEARS;
+	time64_t secs = rtc_tm_to_time64(tm);
+	u32 adj = secs + TWENTY_YEARS;
 
 	do {
 		__raw_writel((adj & 0xffff0000) >> 16, AICA_RTC_SECS_H);
@@ -73,9 +80,19 @@ static int aica_rtc_settimeofday(const time_t secs)
 	return 0;
 }
 
-void aica_time_init(void)
+static const struct rtc_class_ops rtc_generic_ops = {
+	.read_time = aica_rtc_gettimeofday,
+	.set_time = aica_rtc_settimeofday,
+};
+
+static int __init aica_time_init(void)
 {
-	rtc_sh_get_time = aica_rtc_gettimeofday;
-	rtc_sh_set_time = aica_rtc_settimeofday;
-}
+	struct platform_device *pdev;
+
+	pdev = platform_device_register_data(NULL, "rtc-generic", -1,
+					     &rtc_generic_ops,
+					     sizeof(rtc_generic_ops));
 
+	return PTR_ERR_OR_ZERO(pdev);
+}
+arch_initcall(aica_time_init);

commit 9d56dd3b083a3bec56e9da35ce07baca81030b03
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jan 26 12:58:40 2010 +0900

    sh: Mass ctrl_in/outX to __raw_read/writeX conversion.
    
    The old ctrl in/out routines are non-portable and unsuitable for
    cross-platform use. While drivers/sh has already been sanitized, there
    is still quite a lot of code that is not. This converts the arch/sh/ bits
    over, which permits us to flag the routines as deprecated whilst still
    building with -Werror for the architecture code, and to ensure that
    future users are not added.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-dreamcast/rtc.c b/arch/sh/boards/mach-dreamcast/rtc.c
index a7433685798d..061d65714fcc 100644
--- a/arch/sh/boards/mach-dreamcast/rtc.c
+++ b/arch/sh/boards/mach-dreamcast/rtc.c
@@ -35,11 +35,11 @@ static void aica_rtc_gettimeofday(struct timespec *ts)
 	unsigned long val1, val2;
 
 	do {
-		val1 = ((ctrl_inl(AICA_RTC_SECS_H) & 0xffff) << 16) |
-			(ctrl_inl(AICA_RTC_SECS_L) & 0xffff);
+		val1 = ((__raw_readl(AICA_RTC_SECS_H) & 0xffff) << 16) |
+			(__raw_readl(AICA_RTC_SECS_L) & 0xffff);
 
-		val2 = ((ctrl_inl(AICA_RTC_SECS_H) & 0xffff) << 16) |
-			(ctrl_inl(AICA_RTC_SECS_L) & 0xffff);
+		val2 = ((__raw_readl(AICA_RTC_SECS_H) & 0xffff) << 16) |
+			(__raw_readl(AICA_RTC_SECS_L) & 0xffff);
 	} while (val1 != val2);
 
 	ts->tv_sec = val1 - TWENTY_YEARS;
@@ -60,14 +60,14 @@ static int aica_rtc_settimeofday(const time_t secs)
 	unsigned long adj = secs + TWENTY_YEARS;
 
 	do {
-		ctrl_outl((adj & 0xffff0000) >> 16, AICA_RTC_SECS_H);
-		ctrl_outl((adj & 0xffff), AICA_RTC_SECS_L);
+		__raw_writel((adj & 0xffff0000) >> 16, AICA_RTC_SECS_H);
+		__raw_writel((adj & 0xffff), AICA_RTC_SECS_L);
 
-		val1 = ((ctrl_inl(AICA_RTC_SECS_H) & 0xffff) << 16) |
-			(ctrl_inl(AICA_RTC_SECS_L) & 0xffff);
+		val1 = ((__raw_readl(AICA_RTC_SECS_H) & 0xffff) << 16) |
+			(__raw_readl(AICA_RTC_SECS_L) & 0xffff);
 
-		val2 = ((ctrl_inl(AICA_RTC_SECS_H) & 0xffff) << 16) |
-			(ctrl_inl(AICA_RTC_SECS_L) & 0xffff);
+		val2 = ((__raw_readl(AICA_RTC_SECS_H) & 0xffff) << 16) |
+			(__raw_readl(AICA_RTC_SECS_L) & 0xffff);
 	} while (val1 != val2);
 
 	return 0;

commit da2014a2b080e7f3024a4eb6917d47069ad9620b
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Jul 29 21:01:19 2008 +0900

    sh: Shuffle the board directories in to mach groups.
    
    This flattens out the board directories in to individual mach groups,
    we will use this for getting rid of unneeded directories, simplifying
    the build system, and becoming more coherent with the refactored
    arch/sh/include topology.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/sh/boards/mach-dreamcast/rtc.c b/arch/sh/boards/mach-dreamcast/rtc.c
new file mode 100644
index 000000000000..a7433685798d
--- /dev/null
+++ b/arch/sh/boards/mach-dreamcast/rtc.c
@@ -0,0 +1,81 @@
+/*
+ * arch/sh/boards/dreamcast/rtc.c
+ *
+ * Dreamcast AICA RTC routines.
+ *
+ * Copyright (c) 2001, 2002 M. R. Brown <mrbrown@0xd6.org>
+ * Copyright (c) 2002 Paul Mundt <lethal@chaoticdreams.org>
+ *
+ * Released under the terms of the GNU GPL v2.0.
+ *
+ */
+
+#include <linux/time.h>
+#include <asm/rtc.h>
+#include <asm/io.h>
+
+/* The AICA RTC has an Epoch of 1/1/1950, so we must subtract 20 years (in
+   seconds) to get the standard Unix Epoch when getting the time, and add
+   20 years when setting the time. */
+#define TWENTY_YEARS ((20 * 365LU + 5) * 86400)
+
+/* The AICA RTC is represented by a 32-bit seconds counter stored in 2 16-bit
+   registers.*/
+#define AICA_RTC_SECS_H		0xa0710000
+#define AICA_RTC_SECS_L		0xa0710004
+
+/**
+ * aica_rtc_gettimeofday - Get the time from the AICA RTC
+ * @ts: pointer to resulting timespec
+ *
+ * Grabs the current RTC seconds counter and adjusts it to the Unix Epoch.
+ */
+static void aica_rtc_gettimeofday(struct timespec *ts)
+{
+	unsigned long val1, val2;
+
+	do {
+		val1 = ((ctrl_inl(AICA_RTC_SECS_H) & 0xffff) << 16) |
+			(ctrl_inl(AICA_RTC_SECS_L) & 0xffff);
+
+		val2 = ((ctrl_inl(AICA_RTC_SECS_H) & 0xffff) << 16) |
+			(ctrl_inl(AICA_RTC_SECS_L) & 0xffff);
+	} while (val1 != val2);
+
+	ts->tv_sec = val1 - TWENTY_YEARS;
+
+	/* Can't get nanoseconds with just a seconds counter. */
+	ts->tv_nsec = 0;
+}
+
+/**
+ * aica_rtc_settimeofday - Set the AICA RTC to the current time
+ * @secs: contains the time_t to set
+ *
+ * Adjusts the given @tv to the AICA Epoch and sets the RTC seconds counter.
+ */
+static int aica_rtc_settimeofday(const time_t secs)
+{
+	unsigned long val1, val2;
+	unsigned long adj = secs + TWENTY_YEARS;
+
+	do {
+		ctrl_outl((adj & 0xffff0000) >> 16, AICA_RTC_SECS_H);
+		ctrl_outl((adj & 0xffff), AICA_RTC_SECS_L);
+
+		val1 = ((ctrl_inl(AICA_RTC_SECS_H) & 0xffff) << 16) |
+			(ctrl_inl(AICA_RTC_SECS_L) & 0xffff);
+
+		val2 = ((ctrl_inl(AICA_RTC_SECS_H) & 0xffff) << 16) |
+			(ctrl_inl(AICA_RTC_SECS_L) & 0xffff);
+	} while (val1 != val2);
+
+	return 0;
+}
+
+void aica_time_init(void)
+{
+	rtc_sh_get_time = aica_rtc_gettimeofday;
+	rtc_sh_set_time = aica_rtc_settimeofday;
+}
+
