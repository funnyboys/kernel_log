commit 50acfb2b76e19f73270fef9a32726c7e18d08ec3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:18:00 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 286
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 this program is distributed
      in the hope that it will be useful but without any warranty without
      even the implied warranty of merchantability or fitness for a
      particular purpose see the gnu general public license for more
      details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 97 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141901.025053186@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/riscv/include/asm/spinlock.h b/arch/riscv/include/asm/spinlock.h
index 8eb26d1ede81..f4f7fa1b7ca8 100644
--- a/arch/riscv/include/asm/spinlock.h
+++ b/arch/riscv/include/asm/spinlock.h
@@ -1,15 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (C) 2015 Regents of the University of California
  * Copyright (C) 2017 SiFive
- *
- *   This program is free software; you can redistribute it and/or
- *   modify it under the terms of the GNU General Public License
- *   as published by the Free Software Foundation, version 2.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
  */
 
 #ifndef _ASM_RISCV_SPINLOCK_H

commit 0123f4d76ca63b7b895f40089be0ce4809e392d8
Author: Andrea Parri <parri.andrea@gmail.com>
Date:   Fri Mar 9 13:13:20 2018 +0100

    riscv/spinlock: Strengthen implementations with fences
    
    Current implementations map locking operations using .rl and .aq
    annotations.  However, this mapping is unsound w.r.t. the kernel
    memory consistency model (LKMM) [1]:
    
    Referring to the "unlock-lock-read-ordering" test reported below,
    Daniel wrote:
    
      "I think an RCpc interpretation of .aq and .rl would in fact
       allow the two normal loads in P1 to be reordered [...]
    
       The intuition would be that the amoswap.w.aq can forward from
       the amoswap.w.rl while that's still in the store buffer, and
       then the lw x3,0(x4) can also perform while the amoswap.w.rl
       is still in the store buffer, all before the l1 x1,0(x2)
       executes.  That's not forbidden unless the amoswaps are RCsc,
       unless I'm missing something.
    
       Likewise even if the unlock()/lock() is between two stores.
       A control dependency might originate from the load part of
       the amoswap.w.aq, but there still would have to be something
       to ensure that this load part in fact performs after the store
       part of the amoswap.w.rl performs globally, and that's not
       automatic under RCpc."
    
    Simulation of the RISC-V memory consistency model confirmed this
    expectation.
    
    In order to "synchronize" LKMM and RISC-V's implementation, this
    commit strengthens the implementations of the locking operations
    by replacing .rl and .aq with the use of ("lightweigth") fences,
    resp., "fence rw,  w" and "fence r , rw".
    
    C unlock-lock-read-ordering
    
    {}
    /* s initially owned by P1 */
    
    P0(int *x, int *y)
    {
            WRITE_ONCE(*x, 1);
            smp_wmb();
            WRITE_ONCE(*y, 1);
    }
    
    P1(int *x, int *y, spinlock_t *s)
    {
            int r0;
            int r1;
    
            r0 = READ_ONCE(*y);
            spin_unlock(s);
            spin_lock(s);
            r1 = READ_ONCE(*x);
    }
    
    exists (1:r0=1 /\ 1:r1=0)
    
    [1] https://marc.info/?l=linux-kernel&m=151930201102853&w=2
        https://groups.google.com/a/groups.riscv.org/forum/#!topic/isa-dev/hKywNHBkAXM
        https://marc.info/?l=linux-kernel&m=151633436614259&w=2
    
    Signed-off-by: Andrea Parri <parri.andrea@gmail.com>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Albert Ou <albert@sifive.com>
    Cc: Daniel Lustig <dlustig@nvidia.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Boqun Feng <boqun.feng@gmail.com>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Jade Alglave <j.alglave@ucl.ac.uk>
    Cc: Luc Maranget <luc.maranget@inria.fr>
    Cc: "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>
    Cc: Akira Yokosawa <akiyks@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: linux-riscv@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/include/asm/spinlock.h b/arch/riscv/include/asm/spinlock.h
index 2fd27e8ef1fd..8eb26d1ede81 100644
--- a/arch/riscv/include/asm/spinlock.h
+++ b/arch/riscv/include/asm/spinlock.h
@@ -17,6 +17,7 @@
 
 #include <linux/kernel.h>
 #include <asm/current.h>
+#include <asm/fence.h>
 
 /*
  * Simple spin lock operations.  These provide no fairness guarantees.
@@ -28,10 +29,7 @@
 
 static inline void arch_spin_unlock(arch_spinlock_t *lock)
 {
-	__asm__ __volatile__ (
-		"amoswap.w.rl x0, x0, %0"
-		: "=A" (lock->lock)
-		:: "memory");
+	smp_store_release(&lock->lock, 0);
 }
 
 static inline int arch_spin_trylock(arch_spinlock_t *lock)
@@ -39,7 +37,8 @@ static inline int arch_spin_trylock(arch_spinlock_t *lock)
 	int tmp = 1, busy;
 
 	__asm__ __volatile__ (
-		"amoswap.w.aq %0, %2, %1"
+		"	amoswap.w %0, %2, %1\n"
+		RISCV_ACQUIRE_BARRIER
 		: "=r" (busy), "+A" (lock->lock)
 		: "r" (tmp)
 		: "memory");
@@ -68,8 +67,9 @@ static inline void arch_read_lock(arch_rwlock_t *lock)
 		"1:	lr.w	%1, %0\n"
 		"	bltz	%1, 1b\n"
 		"	addi	%1, %1, 1\n"
-		"	sc.w.aq	%1, %1, %0\n"
+		"	sc.w	%1, %1, %0\n"
 		"	bnez	%1, 1b\n"
+		RISCV_ACQUIRE_BARRIER
 		: "+A" (lock->lock), "=&r" (tmp)
 		:: "memory");
 }
@@ -82,8 +82,9 @@ static inline void arch_write_lock(arch_rwlock_t *lock)
 		"1:	lr.w	%1, %0\n"
 		"	bnez	%1, 1b\n"
 		"	li	%1, -1\n"
-		"	sc.w.aq	%1, %1, %0\n"
+		"	sc.w	%1, %1, %0\n"
 		"	bnez	%1, 1b\n"
+		RISCV_ACQUIRE_BARRIER
 		: "+A" (lock->lock), "=&r" (tmp)
 		:: "memory");
 }
@@ -96,8 +97,9 @@ static inline int arch_read_trylock(arch_rwlock_t *lock)
 		"1:	lr.w	%1, %0\n"
 		"	bltz	%1, 1f\n"
 		"	addi	%1, %1, 1\n"
-		"	sc.w.aq	%1, %1, %0\n"
+		"	sc.w	%1, %1, %0\n"
 		"	bnez	%1, 1b\n"
+		RISCV_ACQUIRE_BARRIER
 		"1:\n"
 		: "+A" (lock->lock), "=&r" (busy)
 		:: "memory");
@@ -113,8 +115,9 @@ static inline int arch_write_trylock(arch_rwlock_t *lock)
 		"1:	lr.w	%1, %0\n"
 		"	bnez	%1, 1f\n"
 		"	li	%1, -1\n"
-		"	sc.w.aq	%1, %1, %0\n"
+		"	sc.w	%1, %1, %0\n"
 		"	bnez	%1, 1b\n"
+		RISCV_ACQUIRE_BARRIER
 		"1:\n"
 		: "+A" (lock->lock), "=&r" (busy)
 		:: "memory");
@@ -125,7 +128,8 @@ static inline int arch_write_trylock(arch_rwlock_t *lock)
 static inline void arch_read_unlock(arch_rwlock_t *lock)
 {
 	__asm__ __volatile__(
-		"amoadd.w.rl x0, %1, %0"
+		RISCV_RELEASE_BARRIER
+		"	amoadd.w x0, %1, %0\n"
 		: "+A" (lock->lock)
 		: "r" (-1)
 		: "memory");
@@ -133,10 +137,7 @@ static inline void arch_read_unlock(arch_rwlock_t *lock)
 
 static inline void arch_write_unlock(arch_rwlock_t *lock)
 {
-	__asm__ __volatile__ (
-		"amoswap.w.rl x0, x0, %0"
-		: "=A" (lock->lock)
-		:: "memory");
+	smp_store_release(&lock->lock, 0);
 }
 
 #endif /* _ASM_RISCV_SPINLOCK_H */

commit bf730552734372e45b10fe056726de1950fdfdde
Author: Palmer Dabbelt <palmer@sifive.com>
Date:   Tue Nov 28 14:06:31 2017 -0800

    RISC-V: remove spin_unlock_wait()
    
    This was removed from the other architectures in commit
    952111d7db02 ("arch: Remove spin_unlock_wait() arch-specific
    definitions").  That landed between when we got upstream and when our
    patches were reviewed, so this is a followup patch.
    
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/include/asm/spinlock.h b/arch/riscv/include/asm/spinlock.h
index a6a005c4f2fb..2fd27e8ef1fd 100644
--- a/arch/riscv/include/asm/spinlock.h
+++ b/arch/riscv/include/asm/spinlock.h
@@ -58,15 +58,6 @@ static inline void arch_spin_lock(arch_spinlock_t *lock)
 	}
 }
 
-static inline void arch_spin_unlock_wait(arch_spinlock_t *lock)
-{
-	smp_rmb();
-	do {
-		cpu_relax();
-	} while (arch_spin_is_locked(lock));
-	smp_acquire__after_ctrl_dep();
-}
-
 /***********************************************************/
 
 static inline void arch_read_lock(arch_rwlock_t *lock)

commit 21db403660d1433b8a02b26d5d4084921b857c40
Author: Palmer Dabbelt <palmer@sifive.com>
Date:   Tue Nov 28 14:05:04 2017 -0800

    RISC-V: Add READ_ONCE in arch_spin_is_locked()
    
    This was just incorrect in the original version.
    
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/include/asm/spinlock.h b/arch/riscv/include/asm/spinlock.h
index 04c71d938afd..a6a005c4f2fb 100644
--- a/arch/riscv/include/asm/spinlock.h
+++ b/arch/riscv/include/asm/spinlock.h
@@ -24,7 +24,7 @@
 
 /* FIXME: Replace this with a ticket lock, like MIPS. */
 
-#define arch_spin_is_locked(x)	((x)->lock != 0)
+#define arch_spin_is_locked(x)	(READ_ONCE((x)->lock) != 0)
 
 static inline void arch_spin_unlock(arch_spinlock_t *lock)
 {

commit b293fca43be544483b6488d33ad4b3ed55881064
Merge: 0ef76878cfcf fbe934d69eb7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 15 10:49:15 2017 -0800

    Merge tag 'riscv-for-linus-4.15-arch-v9-premerge' of git://git.kernel.org/pub/scm/linux/kernel/git/palmer/linux
    
    Pull RISC-V architecture support from Palmer Dabbelt:
     "This contains the core RISC-V Linux port, which has been through nine
      rounds of review on various mailing lists. The port is not complete:
      there's some cleanup patches moving through the review process, a
      whole bunch of drivers that need some work, and a lot of feature
      additions that will be needed.
    
      The patches contained in this tag have been through nine rounds of
      review on the various mailing lists. I have some outstanding cleanup
      patches, but since there's been so much review on these patches I
      thought it would be best to submit them as-is and then submit explicit
      cleanup patches so everyone can review them. This first patch set is
      big enough that it's a bit of a pain to constantly rewrite, and it's
      caused a few headaches with various contributors.
    
      The port is definately a work in progress. While what's there builds
      and boots with 4.14, it's a bit hard to actually see anything happen
      because there are no device drivers yet. I maintain a staging branch
      that contains all the device drivers and cleanup that actually works,
      but those patches won't all be ready for a while. I'd like to get what
      we currently have into your tree so everyone can start working from a
      single base -- of particular importance is allowing the glibc
      upstreaming process to proceed so we can sort out any possibly
      lingering user-visible ABI problems we might have.
    
      Copied below is the ChangeLog that contains the history of this patch
      set:
    
       (v9) As per suggestions on our v8 patch set, I've split the core
            architecture code out from our drivers and would like to submit
            this patch set to be included into linux-next, with the goal
            being to be merged in during the next merge window. This patch
            set is based on 4.14-rc2, but if it's better to have it based on
            something else then I can change it around.
    
            This patch set contains just the core arch code for RISC-V, so
            while it builds an nominally boots, you can't print or take an
            interrupt so it's not that useful. If you're looking to actually
            boot a system it would probably be better to use the full patch
            set listed below.
    
            We've collected a handful of tags from reviewers, and the
            remainder of the patch set only got minimal feedback last time.
            Here's what changed:
    
             - We now use the device tree to initialize the timer driver so
               it's less tighly coupled with the arch port.
    
             - I cleaned up the defconfigs -- there's actually now just one,
               and it's empty. For now I think we're OK with what the kernel
               sets as defaults, but I anticipate we'll begin to expand this
               as people start to use the port more.
    
             - The VDSO symbols version is sane.
    
             - We WFI while spinning in the boot loop.
    
             - A handful of comments have been added.
    
            While there are still a handful of FIXMEs in this patch set,
            we've started to get enough interest from various users and
            contributors that maintaining an out of tree patch set is
            starting to become a big burden. Hopefully the patches are good
            enough to merge now, which will at least get everyone working in
            a more reasonable manner as we clean up the remaining issues.
    
       (v8) I know it may not be the ideal time to submit a patch set right
            now, as it's the middle of the merge window, but things have
            calmed down quite a bit in the last month so I thought it would
            be good to get everyone on the same page. There's been a handful
            of changes since the last patch set, but most of them are fairly
            minor:
    
             - We changed PAGE_OFFSET to allowing mapping more physical
               memory on 64-bit systems. This is user configurable, as it
               triggers a different code model that generates slightly less
               efficient code.
    
             - The device tree binding documentation is back, I'd managed to
               lose it at some point.
    
             - We now pass the atomic64 test suite
    
             - The SBI timer driver has been refactored.
    
       (v7) It's been a while since my last patch set, but the changes han
            been fairly minimal:
    
             - The PCI cleanup patches have been dropped, we'll do them as a
               separate patch set later.
    
             - We've the Kconfig entries from CONFIG_ISA_* to
               CONFIG_RISCV_ISA_*, to make grep easier.
    
             - There have been a handful of memory model related tweaks in
               I/O land, particularly relating the PCI and the upcoming
               platform specification. There are significant comments in the
               relevant files. This is still a WIP, but I think we're close
               to getting as good as we're going to get until we end up with
               some more specifications.
    
       (v6) As it's been only a day since the v5 patch set, the changes are
            pretty minimal:
    
             - The patch set is now based on linux-next/master, which I
               believe is a better base now that we're getting closer to
               upstream.
    
             - EARLY_PRINTK is no longer an option. Since the SBI console is
               reasonable, there's no penalty to enabling it (and thus no
               benefit to disabling it).
    
             - The mmap syscalls were refactored a bit.
    
       (v5) Things have really started to calm down, so this is fairly
            similar to the v4 patch set. The most interesting changes
            include:
    
             - We've moved back to a single patch set.
    
             - SMP support has been fixed, I was accidentally running on a
               non-SMP configuration. There were various mistakes all over
               the tree as a result of this.
    
             - The cmpxchg syscalls have been removed, as they were deemed a
               bad idea. As a result, RISC-V Linux systems mandate the A
               extension. The corresponding Kconfig entry to enable builds
               on non-A systems has been removed.
    
             - A few more atomic fixes: mostly fence changes, but those
               resulted in a handful of additional macros that were no
               longer necessary.
    
             - riscv_early_sie has been removed.
    
       (v4) There have only been a few changes since the v3 patch set:
    
             - The cmpxchg64 syscall is no longer enabled on 32-bit systems.
               It's not possible to provide this on SMP systems, and it's
               not necessary as glibc knows not to call it.
    
             - We provide a ELF_HWCAP so users can determine the ISA of the
               machine the kernel is running on.
    
             - The multi-line comments are in a better form.
    
             - There were a handful of headers that could be replaced with
               the asm-generic versions, and a few unnecessary definitions.
    
             - We no longer use printk, but instead use pr_*.
    
             - A few Kconfig and defconfig entries have been cleaned up.
    
       (v3) A highlight of the changes since the v2 patch set includes:
    
             - We've split out all our drivers into separate patch sets,
               which I've already sent out to the relevant maintainers. I
               haven't included those patches in this patch set, but some of
               them are necessary to build our port.
    
             - The patch set is now split up differently: rather than being
               split per directory it is split per topic. Hopefully this
               will make it easier to review the port on the mailing list.
               The split is a bit rough, so you probably still want to look
               at the patch set as a whole.
    
             - atomic.h has been completely rewritten and is hopefully now
               correct. I've attempted to sanitize the various other memory
               model related code as well, and I think it should all be sane
               now aside from a handful of FIXMEs commented in the code.
    
             - We've changed the cmpexchg syscall to always exist and to not
               be multiplexed. There is also a VDSO entry for compare and
               exchange, which allows kernels with the A extension to
               execute user code without the A extension reasonably fast.
    
             - Our user-visible register state now contains enough space for
               the Q extension for 128-bit floating point, as well as a few
               words to allow extensibility to future ISA extensions like
               the eventual V extension for vectors.
    
             - A handful of driver cleanups, but these have been split into
               separate patch sets now so I won't duplicate them here.
    
       (v2) A highlight of the changes since the v1 patch set includes:
    
             - We've split out our drivers into the right places, which
               means now there's a lot more patches. I'll be submitting
               these patches to various subsystem maintainers and including
               them in any future RISC-V patch sets until they've been
               merged.
    
             - The SBI console driver has been completely rewritten to use
               the HVC helpers and is now significantly smaller.
    
             - We've begun to use weaker barriers as opposed to just the big
               "fence". There's still some work to do here, specifically:
                - We need fences in the relaxed MMIO functions.
                - The non-relaxed MMIO functions are missing R/W bits on their fences.
                - Many AMOs need the aq and rl bits set.
    
             - We now have thread_info in task_struct. As a result, sscratch
               now contains TP instead of SP. This was necessary because
               thread_info is no longer on the stack.
    
             - A few shared routines have been added that we use instead of
               creating another arch copy"
    
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    
    * tag 'riscv-for-linus-4.15-arch-v9-premerge' of git://git.kernel.org/pub/scm/linux/kernel/git/palmer/linux:
      RISC-V: Build Infrastructure
      RISC-V: User-facing API
      RISC-V: Paging and MMU
      RISC-V: Device, timer, IRQs, and the SBI
      RISC-V: Task implementation
      RISC-V: ELF and module implementation
      RISC-V: Generic library routines and assembly
      RISC-V: Atomic and Locking Code
      RISC-V: Init and Halt Code
      dt-bindings: RISC-V CPU Bindings
      lib: Add shared copies of some GCC library routines
      MAINTAINERS: Add RISC-V

commit fab957c11efe2f405e08b9f0d080524bc2631428
Author: Palmer Dabbelt <palmer@dabbelt.com>
Date:   Mon Jul 10 18:02:19 2017 -0700

    RISC-V: Atomic and Locking Code
    
    This contains all the code that directly interfaces with the RISC-V
    memory model.  While this code corforms to the current RISC-V ISA
    specifications (user 2.2 and priv 1.10), the memory model is somewhat
    underspecified in those documents.  There is a working group that hopes
    to produce a formal memory model by the end of the year, but my
    understanding is that the basic definitions we're relying on here won't
    change significantly.
    
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Palmer Dabbelt <palmer@dabbelt.com>

diff --git a/arch/riscv/include/asm/spinlock.h b/arch/riscv/include/asm/spinlock.h
new file mode 100644
index 000000000000..b3b394ffaf7e
--- /dev/null
+++ b/arch/riscv/include/asm/spinlock.h
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2015 Regents of the University of California
+ * Copyright (C) 2017 SiFive
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation, version 2.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ */
+
+#ifndef _ASM_RISCV_SPINLOCK_H
+#define _ASM_RISCV_SPINLOCK_H
+
+#include <linux/kernel.h>
+#include <asm/current.h>
+
+/*
+ * Simple spin lock operations.  These provide no fairness guarantees.
+ */
+
+/* FIXME: Replace this with a ticket lock, like MIPS. */
+
+#define arch_spin_lock_flags(lock, flags) arch_spin_lock(lock)
+#define arch_spin_is_locked(x)	((x)->lock != 0)
+
+static inline void arch_spin_unlock(arch_spinlock_t *lock)
+{
+	__asm__ __volatile__ (
+		"amoswap.w.rl x0, x0, %0"
+		: "=A" (lock->lock)
+		:: "memory");
+}
+
+static inline int arch_spin_trylock(arch_spinlock_t *lock)
+{
+	int tmp = 1, busy;
+
+	__asm__ __volatile__ (
+		"amoswap.w.aq %0, %2, %1"
+		: "=r" (busy), "+A" (lock->lock)
+		: "r" (tmp)
+		: "memory");
+
+	return !busy;
+}
+
+static inline void arch_spin_lock(arch_spinlock_t *lock)
+{
+	while (1) {
+		if (arch_spin_is_locked(lock))
+			continue;
+
+		if (arch_spin_trylock(lock))
+			break;
+	}
+}
+
+static inline void arch_spin_unlock_wait(arch_spinlock_t *lock)
+{
+	smp_rmb();
+	do {
+		cpu_relax();
+	} while (arch_spin_is_locked(lock));
+	smp_acquire__after_ctrl_dep();
+}
+
+/***********************************************************/
+
+static inline int arch_read_can_lock(arch_rwlock_t *lock)
+{
+	return lock->lock >= 0;
+}
+
+static inline int arch_write_can_lock(arch_rwlock_t *lock)
+{
+	return lock->lock == 0;
+}
+
+static inline void arch_read_lock(arch_rwlock_t *lock)
+{
+	int tmp;
+
+	__asm__ __volatile__(
+		"1:	lr.w	%1, %0\n"
+		"	bltz	%1, 1b\n"
+		"	addi	%1, %1, 1\n"
+		"	sc.w.aq	%1, %1, %0\n"
+		"	bnez	%1, 1b\n"
+		: "+A" (lock->lock), "=&r" (tmp)
+		:: "memory");
+}
+
+static inline void arch_write_lock(arch_rwlock_t *lock)
+{
+	int tmp;
+
+	__asm__ __volatile__(
+		"1:	lr.w	%1, %0\n"
+		"	bnez	%1, 1b\n"
+		"	li	%1, -1\n"
+		"	sc.w.aq	%1, %1, %0\n"
+		"	bnez	%1, 1b\n"
+		: "+A" (lock->lock), "=&r" (tmp)
+		:: "memory");
+}
+
+static inline int arch_read_trylock(arch_rwlock_t *lock)
+{
+	int busy;
+
+	__asm__ __volatile__(
+		"1:	lr.w	%1, %0\n"
+		"	bltz	%1, 1f\n"
+		"	addi	%1, %1, 1\n"
+		"	sc.w.aq	%1, %1, %0\n"
+		"	bnez	%1, 1b\n"
+		"1:\n"
+		: "+A" (lock->lock), "=&r" (busy)
+		:: "memory");
+
+	return !busy;
+}
+
+static inline int arch_write_trylock(arch_rwlock_t *lock)
+{
+	int busy;
+
+	__asm__ __volatile__(
+		"1:	lr.w	%1, %0\n"
+		"	bnez	%1, 1f\n"
+		"	li	%1, -1\n"
+		"	sc.w.aq	%1, %1, %0\n"
+		"	bnez	%1, 1b\n"
+		"1:\n"
+		: "+A" (lock->lock), "=&r" (busy)
+		:: "memory");
+
+	return !busy;
+}
+
+static inline void arch_read_unlock(arch_rwlock_t *lock)
+{
+	__asm__ __volatile__(
+		"amoadd.w.rl x0, %1, %0"
+		: "+A" (lock->lock)
+		: "r" (-1)
+		: "memory");
+}
+
+static inline void arch_write_unlock(arch_rwlock_t *lock)
+{
+	__asm__ __volatile__ (
+		"amoswap.w.rl x0, x0, %0"
+		: "=A" (lock->lock)
+		:: "memory");
+}
+
+#define arch_read_lock_flags(lock, flags) arch_read_lock(lock)
+#define arch_write_lock_flags(lock, flags) arch_write_lock(lock)
+
+#endif /* _ASM_RISCV_SPINLOCK_H */
