commit 5cf998ba8c7bbbfec3e0d6534c9a3f860ab9920e
Author: Anup Patel <anup.patel@wdc.com>
Date:   Mon Jun 1 14:45:38 2020 +0530

    RISC-V: self-contained IPI handling routine
    
    Currently, the IPI handling routine riscv_software_interrupt() does
    not take any argument and also does not perform irq_enter()/irq_exit().
    
    This patch makes IPI handling routine more self-contained by:
    1. Passing "pt_regs *" argument
    2. Explicitly doing irq_enter()/irq_exit()
    3. Explicitly save/restore "pt_regs *" using set_irq_regs()
    
    With above changes, IPI handling routine does not depend on caller
    function to perform irq_enter()/irq_exit() and save/restore of
    "pt_regs *" hence its more self-contained. This also enables us
    to call IPI handling routine from IRQCHIP drivers.
    
    Signed-off-by: Anup Patel <anup.patel@wdc.com>
    Reviewed-by: Atish Patra <atish.patra@wdc.com>
    Reviewed-by: Palmer Dabbelt <palmerdabbelt@google.com>
    Acked-by: Palmer Dabbelt <palmerdabbelt@google.com>
    Signed-off-by: Palmer Dabbelt <palmerdabbelt@google.com>

diff --git a/arch/riscv/include/asm/smp.h b/arch/riscv/include/asm/smp.h
index f4c7cfda6b7f..40bb1c15a731 100644
--- a/arch/riscv/include/asm/smp.h
+++ b/arch/riscv/include/asm/smp.h
@@ -28,6 +28,9 @@ void show_ipi_stats(struct seq_file *p, int prec);
 /* SMP initialization hook for setup_arch */
 void __init setup_smp(void);
 
+/* Called from C code, this handles an IPI. */
+void handle_IPI(struct pt_regs *regs);
+
 /* Hook for the generic smp_call_function_many() routine. */
 void arch_send_call_function_ipi_mask(struct cpumask *mask);
 

commit f1e58583b9c7ceae7f11646e9edf2561d67f29c9
Author: Atish Patra <atish.patra@wdc.com>
Date:   Tue Mar 17 18:11:44 2020 -0700

    RISC-V: Support cpu hotplug
    
    This patch enable support for cpu hotplug in RISC-V. It uses SBI HSM
    extension to online/offline any hart. As a result, the harts are
    returned to firmware once they are offline. If the harts are brought
    online afterwards, they re-enter Linux kernel as if a secondary hart
    booted for the first time. All booting requirements are honored during
    this process.
    
    Tested both on QEMU and HighFive Unleashed board with. Test result follows.
    
    ---------------------------------------------------
    Offline cpu 2
    ---------------------------------------------------
    $ echo 0 > /sys/devices/system/cpu/cpu2/online
    [   32.828684] CPU2: off
    $ cat /proc/cpuinfo
    processor       : 0
    hart            : 0
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 1
    hart            : 1
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 3
    hart            : 3
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 4
    hart            : 4
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 5
    hart            : 5
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 6
    hart            : 6
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 7
    hart            : 7
    isa             : rv64imafdcsu
    mmu             : sv48
    
    ---------------------------------------------------
    online cpu 2
    ---------------------------------------------------
    $ echo 1 > /sys/devices/system/cpu/cpu2/online
    $ cat /proc/cpuinfo
    processor       : 0
    hart            : 0
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 1
    hart            : 1
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 2
    hart            : 2
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 3
    hart            : 3
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 4
    hart            : 4
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 5
    hart            : 5
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 6
    hart            : 6
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 7
    hart            : 7
    isa             : rv64imafdcsu
    mmu             : sv48
    
    Signed-off-by: Atish Patra <atish.patra@wdc.com>
    Reviewed-by: Anup Patel <anup@brainfault.org>

diff --git a/arch/riscv/include/asm/smp.h b/arch/riscv/include/asm/smp.h
index 023f74fb8b3b..f4c7cfda6b7f 100644
--- a/arch/riscv/include/asm/smp.h
+++ b/arch/riscv/include/asm/smp.h
@@ -43,6 +43,13 @@ void riscv_cpuid_to_hartid_mask(const struct cpumask *in, struct cpumask *out);
  */
 #define raw_smp_processor_id() (current_thread_info()->cpu)
 
+#if defined CONFIG_HOTPLUG_CPU
+int __cpu_disable(void);
+void __cpu_die(unsigned int cpu);
+void cpu_stop(void);
+#else
+#endif /* CONFIG_HOTPLUG_CPU */
+
 #else
 
 static inline void show_ipi_stats(struct seq_file *p, int prec)
@@ -69,4 +76,14 @@ static inline void riscv_cpuid_to_hartid_mask(const struct cpumask *in,
 }
 
 #endif /* CONFIG_SMP */
+
+#if defined(CONFIG_HOTPLUG_CPU) && (CONFIG_SMP)
+bool cpu_has_hotplug(unsigned int cpu);
+#else
+static inline bool cpu_has_hotplug(unsigned int cpu)
+{
+	return false;
+}
+#endif
+
 #endif /* _ASM_RISCV_SMP_H */

commit 1ef46c231df4b856559ec0234bfcbb41a1180b97
Author: Atish Patra <atish.patra@wdc.com>
Date:   Tue Mar 17 18:11:38 2020 -0700

    RISC-V: Implement new SBI v0.2 extensions
    
    Few v0.1 SBI calls are being replaced by new SBI calls that follows v0.2
    calling convention.
    
    Implement the replacement extensions and few additional new SBI function calls
    that makes way for a better SBI interface in future.
    
    Signed-off-by: Atish Patra <atish.patra@wdc.com>
    Reviewed-by: Anup Patel <anup@brainfault.org>
    Signed-off-by: Palmer Dabbelt <palmerdabbelt@google.com>

diff --git a/arch/riscv/include/asm/smp.h b/arch/riscv/include/asm/smp.h
index a83451d73a4e..023f74fb8b3b 100644
--- a/arch/riscv/include/asm/smp.h
+++ b/arch/riscv/include/asm/smp.h
@@ -61,5 +61,12 @@ static inline unsigned long cpuid_to_hartid_map(int cpu)
 	return boot_cpu_hartid;
 }
 
+static inline void riscv_cpuid_to_hartid_mask(const struct cpumask *in,
+					      struct cpumask *out)
+{
+	cpumask_clear(out);
+	cpumask_set_cpu(boot_cpu_hartid, out);
+}
+
 #endif /* CONFIG_SMP */
 #endif /* _ASM_RISCV_SMP_H */

commit f5bf645d10f2c6cc85294021af70f2b7bcc42d8e
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Aug 21 23:58:35 2019 +0900

    riscv: cleanup riscv_cpuid_to_hartid_mask
    
    Move the initial clearing of the mask from the callers to
    riscv_cpuid_to_hartid_mask, and remove the unused !CONFIG_SMP stub.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Atish Patra <atish.patra@wdc.com>
    Signed-off-by: Paul Walmsley <paul.walmsley@sifive.com>

diff --git a/arch/riscv/include/asm/smp.h b/arch/riscv/include/asm/smp.h
index c6ed4d691def..a83451d73a4e 100644
--- a/arch/riscv/include/asm/smp.h
+++ b/arch/riscv/include/asm/smp.h
@@ -61,11 +61,5 @@ static inline unsigned long cpuid_to_hartid_map(int cpu)
 	return boot_cpu_hartid;
 }
 
-static inline void riscv_cpuid_to_hartid_mask(const struct cpumask *in,
-					      struct cpumask *out)
-{
-	cpumask_set_cpu(cpuid_to_hartid_map(0), out);
-}
-
 #endif /* CONFIG_SMP */
 #endif /* _ASM_RISCV_SMP_H */

commit 50acfb2b76e19f73270fef9a32726c7e18d08ec3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:18:00 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 286
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 this program is distributed
      in the hope that it will be useful but without any warranty without
      even the implied warranty of merchantability or fitness for a
      particular purpose see the gnu general public license for more
      details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 97 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141901.025053186@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/riscv/include/asm/smp.h b/arch/riscv/include/asm/smp.h
index 636a934f013a..c6ed4d691def 100644
--- a/arch/riscv/include/asm/smp.h
+++ b/arch/riscv/include/asm/smp.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (C) 2012 Regents of the University of California
- *
- *   This program is free software; you can redistribute it and/or
- *   modify it under the terms of the GNU General Public License
- *   as published by the Free Software Foundation, version 2.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
  */
 
 #ifndef _ASM_RISCV_SMP_H

commit 78d1daa36489d44ecb97b400e75639e79422de67
Author: Atish Patra <atish.patra@wdc.com>
Date:   Fri Feb 22 11:41:36 2019 -0800

    RISC-V: Move cpuid to hartid mapping to SMP.
    
    Currently, logical CPU id to physical hartid mapping is defined for both
    smp and non-smp configurations. This is not required as we need this
    only for smp configuration.  The mapping function can define directly
    boot_cpu_hartid for non-smp use case.
    
    The reverse mapping function i.e. hartid to cpuid can be called for any
    valid but not booted harts. So it should return default cpu 0 only if it
    is a boot hartid.
    
    Signed-off-by: Atish Patra <atish.patra@wdc.com>
    Reviewed-by: Anup Patel <anup@brainfault.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/include/asm/smp.h b/arch/riscv/include/asm/smp.h
index 41aa73b476f4..636a934f013a 100644
--- a/arch/riscv/include/asm/smp.h
+++ b/arch/riscv/include/asm/smp.h
@@ -19,16 +19,17 @@
 #include <linux/thread_info.h>
 
 #define INVALID_HARTID ULONG_MAX
+
+struct seq_file;
+extern unsigned long boot_cpu_hartid;
+
+#ifdef CONFIG_SMP
 /*
  * Mapping between linux logical cpu index and hartid.
  */
 extern unsigned long __cpuid_to_hartid_map[NR_CPUS];
 #define cpuid_to_hartid_map(cpu)    __cpuid_to_hartid_map[cpu]
 
-struct seq_file;
-
-#ifdef CONFIG_SMP
-
 /* print IPI stats */
 void show_ipi_stats(struct seq_file *p, int prec);
 
@@ -58,7 +59,14 @@ static inline void show_ipi_stats(struct seq_file *p, int prec)
 
 static inline int riscv_hartid_to_cpuid(int hartid)
 {
-	return 0;
+	if (hartid == boot_cpu_hartid)
+		return 0;
+
+	return -1;
+}
+static inline unsigned long cpuid_to_hartid_map(int cpu)
+{
+	return boot_cpu_hartid;
 }
 
 static inline void riscv_cpuid_to_hartid_mask(const struct cpumask *in,

commit 8b20d2db0a6d2761e0fc156eb74f7a55b92b3147
Author: Anup Patel <anup@brainfault.org>
Date:   Tue Oct 2 12:15:07 2018 -0700

    RISC-V: Show IPI stats
    
    This patch provides arch_show_interrupts() implementation to
    show IPI stats via /proc/interrupts.
    
    Now the contents of /proc/interrupts" will look like below:
               CPU0       CPU1       CPU2       CPU3
      8:         17          7          6         14  SiFive PLIC   8  virtio0
     10:         10         10          9         11  SiFive PLIC  10  ttyS0
    IPI0:       170        673        251         79  Rescheduling interrupts
    IPI1:         1         12         27          1  Function call interrupts
    
    Signed-off-by: Anup Patel <anup@brainfault.org>
    [Atish - Fixed checkpatch errors]
    Signed-off-by: Atish Patra <atish.patra@wdc.com>
    Reviewed-by: Palmer Dabbelt <palmer@sifive.com>
    
    Changes since v2:
     - Remove use of IPI_CALL_WAKEUP because it's being removed
    
    Changes since v1:
     - Add stub inline show_ipi_stats() function for !CONFIG_SMP
     - Make ipi_names[] dynamically sized at compile time
     - Minor beautification of ipi_names[] using tabs
    
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/include/asm/smp.h b/arch/riscv/include/asm/smp.h
index 47fd61dfc897..41aa73b476f4 100644
--- a/arch/riscv/include/asm/smp.h
+++ b/arch/riscv/include/asm/smp.h
@@ -25,8 +25,13 @@
 extern unsigned long __cpuid_to_hartid_map[NR_CPUS];
 #define cpuid_to_hartid_map(cpu)    __cpuid_to_hartid_map[cpu]
 
+struct seq_file;
+
 #ifdef CONFIG_SMP
 
+/* print IPI stats */
+void show_ipi_stats(struct seq_file *p, int prec);
+
 /* SMP initialization hook for setup_arch */
 void __init setup_smp(void);
 
@@ -47,6 +52,10 @@ void riscv_cpuid_to_hartid_mask(const struct cpumask *in, struct cpumask *out);
 
 #else
 
+static inline void show_ipi_stats(struct seq_file *p, int prec)
+{
+}
+
 static inline int riscv_hartid_to_cpuid(int hartid)
 {
 	return 0;

commit 6825c7a80f1863b975a00042abe140ea24813af2
Author: Atish Patra <atish.patra@wdc.com>
Date:   Tue Oct 2 12:15:04 2018 -0700

    RISC-V: Add logical CPU indexing for RISC-V
    
    Currently, both Linux CPU id and hart id are same.
    This is not recommended as it will lead to discontinuous CPU
    indexing in Linux. Moreover, kdump kernel will run from CPU0
    which would be absent if we follow existing scheme.
    
    Implement a logical mapping between Linux CPU id and hart
    id to decouple these two. Always mark the boot processor as
    CPU0 and all other CPUs get the logical CPU id based on their
    booting order.
    
    Signed-off-by: Atish Patra <atish.patra@wdc.com>
    Reviewed-by: Anup Patel <anup@brainfault.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/include/asm/smp.h b/arch/riscv/include/asm/smp.h
index 85d7619eb927..47fd61dfc897 100644
--- a/arch/riscv/include/asm/smp.h
+++ b/arch/riscv/include/asm/smp.h
@@ -18,6 +18,13 @@
 #include <linux/irqreturn.h>
 #include <linux/thread_info.h>
 
+#define INVALID_HARTID ULONG_MAX
+/*
+ * Mapping between linux logical cpu index and hartid.
+ */
+extern unsigned long __cpuid_to_hartid_map[NR_CPUS];
+#define cpuid_to_hartid_map(cpu)    __cpuid_to_hartid_map[cpu]
+
 #ifdef CONFIG_SMP
 
 /* SMP initialization hook for setup_arch */
@@ -29,12 +36,27 @@ void arch_send_call_function_ipi_mask(struct cpumask *mask);
 /* Hook for the generic smp_call_function_single() routine. */
 void arch_send_call_function_single_ipi(int cpu);
 
+int riscv_hartid_to_cpuid(int hartid);
+void riscv_cpuid_to_hartid_mask(const struct cpumask *in, struct cpumask *out);
+
 /*
  * Obtains the hart ID of the currently executing task.  This relies on
  * THREAD_INFO_IN_TASK, but we define that unconditionally.
  */
 #define raw_smp_processor_id() (current_thread_info()->cpu)
 
-#endif /* CONFIG_SMP */
+#else
+
+static inline int riscv_hartid_to_cpuid(int hartid)
+{
+	return 0;
+}
 
+static inline void riscv_cpuid_to_hartid_mask(const struct cpumask *in,
+					      struct cpumask *out)
+{
+	cpumask_set_cpu(cpuid_to_hartid_map(0), out);
+}
+
+#endif /* CONFIG_SMP */
 #endif /* _ASM_RISCV_SMP_H */

commit 9639a44394b9859a5576cb36630105733a552bd6
Author: Palmer Dabbelt <palmer@sifive.com>
Date:   Tue Oct 2 12:14:59 2018 -0700

    RISC-V: Provide a cleaner raw_smp_processor_id()
    
    I'm not sure how I managed to miss this the first time, but this is much
    better.
    
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>
    [Atish: code comment formatting and other fixes]
    Signed-off-by: Atish Patra <atish.patra@wdc.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/include/asm/smp.h b/arch/riscv/include/asm/smp.h
index 36016845461d..85d7619eb927 100644
--- a/arch/riscv/include/asm/smp.h
+++ b/arch/riscv/include/asm/smp.h
@@ -14,13 +14,9 @@
 #ifndef _ASM_RISCV_SMP_H
 #define _ASM_RISCV_SMP_H
 
-/* This both needs asm-offsets.h and is used when generating it. */
-#ifndef GENERATING_ASM_OFFSETS
-#include <asm/asm-offsets.h>
-#endif
-
 #include <linux/cpumask.h>
 #include <linux/irqreturn.h>
+#include <linux/thread_info.h>
 
 #ifdef CONFIG_SMP
 
@@ -34,12 +30,10 @@ void arch_send_call_function_ipi_mask(struct cpumask *mask);
 void arch_send_call_function_single_ipi(int cpu);
 
 /*
- * This is particularly ugly: it appears we can't actually get the definition
- * of task_struct here, but we need access to the CPU this task is running on.
- * Instead of using C we're using asm-offsets.h to get the current processor
- * ID.
+ * Obtains the hart ID of the currently executing task.  This relies on
+ * THREAD_INFO_IN_TASK, but we define that unconditionally.
  */
-#define raw_smp_processor_id() (*((int*)((char*)get_current() + TASK_TI_CPU)))
+#define raw_smp_processor_id() (current_thread_info()->cpu)
 
 #endif /* CONFIG_SMP */
 

commit 62b0194368147def8c5a77ce604a125d620fc582
Author: Palmer Dabbelt <palmer@dabbelt.com>
Date:   Sat Aug 4 10:23:19 2018 +0200

    clocksource: new RISC-V SBI timer driver
    
    The RISC-V ISA defines a per-hart real-time clock and timer, which is
    present on all systems.  The clock is accessed via the 'rdtime'
    pseudo-instruction (which reads a CSR), and the timer is set via an SBI
    call.
    
    Contains various improvements from Atish Patra <atish.patra@wdc.com>.
    
    Signed-off-by: Dmitriy Cherkasov <dmitriy@oss-tech.org>
    Signed-off-by: Palmer Dabbelt <palmer@dabbelt.com>
    [hch: remove dead code, add SPDX tags, used riscv_of_processor_hart(),
     minor cleanups, merged  hotplug cpu support and other improvements
     from Atish]
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Atish Patra <atish.patra@wdc.com>
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/include/asm/smp.h b/arch/riscv/include/asm/smp.h
index c9395fff246f..36016845461d 100644
--- a/arch/riscv/include/asm/smp.h
+++ b/arch/riscv/include/asm/smp.h
@@ -24,9 +24,6 @@
 
 #ifdef CONFIG_SMP
 
-/* SMP initialization hook for setup_arch */
-void __init init_clockevent(void);
-
 /* SMP initialization hook for setup_arch */
 void __init setup_smp(void);
 

commit b9d5535746e306a456691177228a08f04b923a7b
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Aug 4 10:23:13 2018 +0200

    RISC-V: simplify software interrupt / IPI code
    
    Rename handle_ipi to riscv_software_interrupt, drop the unused return
    value and move the prototype to irq.h together with riscv_timer_interupt.
    This allows simplifying the upcoming interrupt handling support.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/include/asm/smp.h b/arch/riscv/include/asm/smp.h
index 85e4220839b0..c9395fff246f 100644
--- a/arch/riscv/include/asm/smp.h
+++ b/arch/riscv/include/asm/smp.h
@@ -44,9 +44,6 @@ void arch_send_call_function_single_ipi(int cpu);
  */
 #define raw_smp_processor_id() (*((int*)((char*)get_current() + TASK_TI_CPU)))
 
-/* Interprocessor interrupt handler */
-irqreturn_t handle_ipi(void);
-
 #endif /* CONFIG_SMP */
 
 #endif /* _ASM_RISCV_SMP_H */

commit 76d2a0493a17d4c8ecc781366850c3c4f8e1a446
Author: Palmer Dabbelt <palmer@dabbelt.com>
Date:   Mon Jul 10 18:00:26 2017 -0700

    RISC-V: Init and Halt Code
    
    This contains the various __init C functions, the initial assembly
    kernel entry point, and the code to reset the system.  When a file was
    init-related this patch contains the entire file.
    
    Signed-off-by: Palmer Dabbelt <palmer@dabbelt.com>

diff --git a/arch/riscv/include/asm/smp.h b/arch/riscv/include/asm/smp.h
new file mode 100644
index 000000000000..85e4220839b0
--- /dev/null
+++ b/arch/riscv/include/asm/smp.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2012 Regents of the University of California
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation, version 2.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ */
+
+#ifndef _ASM_RISCV_SMP_H
+#define _ASM_RISCV_SMP_H
+
+/* This both needs asm-offsets.h and is used when generating it. */
+#ifndef GENERATING_ASM_OFFSETS
+#include <asm/asm-offsets.h>
+#endif
+
+#include <linux/cpumask.h>
+#include <linux/irqreturn.h>
+
+#ifdef CONFIG_SMP
+
+/* SMP initialization hook for setup_arch */
+void __init init_clockevent(void);
+
+/* SMP initialization hook for setup_arch */
+void __init setup_smp(void);
+
+/* Hook for the generic smp_call_function_many() routine. */
+void arch_send_call_function_ipi_mask(struct cpumask *mask);
+
+/* Hook for the generic smp_call_function_single() routine. */
+void arch_send_call_function_single_ipi(int cpu);
+
+/*
+ * This is particularly ugly: it appears we can't actually get the definition
+ * of task_struct here, but we need access to the CPU this task is running on.
+ * Instead of using C we're using asm-offsets.h to get the current processor
+ * ID.
+ */
+#define raw_smp_processor_id() (*((int*)((char*)get_current() + TASK_TI_CPU)))
+
+/* Interprocessor interrupt handler */
+irqreturn_t handle_ipi(void);
+
+#endif /* CONFIG_SMP */
+
+#endif /* _ASM_RISCV_SMP_H */
