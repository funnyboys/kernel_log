commit f1e58583b9c7ceae7f11646e9edf2561d67f29c9
Author: Atish Patra <atish.patra@wdc.com>
Date:   Tue Mar 17 18:11:44 2020 -0700

    RISC-V: Support cpu hotplug
    
    This patch enable support for cpu hotplug in RISC-V. It uses SBI HSM
    extension to online/offline any hart. As a result, the harts are
    returned to firmware once they are offline. If the harts are brought
    online afterwards, they re-enter Linux kernel as if a secondary hart
    booted for the first time. All booting requirements are honored during
    this process.
    
    Tested both on QEMU and HighFive Unleashed board with. Test result follows.
    
    ---------------------------------------------------
    Offline cpu 2
    ---------------------------------------------------
    $ echo 0 > /sys/devices/system/cpu/cpu2/online
    [   32.828684] CPU2: off
    $ cat /proc/cpuinfo
    processor       : 0
    hart            : 0
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 1
    hart            : 1
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 3
    hart            : 3
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 4
    hart            : 4
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 5
    hart            : 5
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 6
    hart            : 6
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 7
    hart            : 7
    isa             : rv64imafdcsu
    mmu             : sv48
    
    ---------------------------------------------------
    online cpu 2
    ---------------------------------------------------
    $ echo 1 > /sys/devices/system/cpu/cpu2/online
    $ cat /proc/cpuinfo
    processor       : 0
    hart            : 0
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 1
    hart            : 1
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 2
    hart            : 2
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 3
    hart            : 3
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 4
    hart            : 4
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 5
    hart            : 5
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 6
    hart            : 6
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 7
    hart            : 7
    isa             : rv64imafdcsu
    mmu             : sv48
    
    Signed-off-by: Atish Patra <atish.patra@wdc.com>
    Reviewed-by: Anup Patel <anup@brainfault.org>

diff --git a/arch/riscv/include/asm/cpu_ops.h b/arch/riscv/include/asm/cpu_ops.h
index 5ce81a28e1d9..a8ec3c5c1bd2 100644
--- a/arch/riscv/include/asm/cpu_ops.h
+++ b/arch/riscv/include/asm/cpu_ops.h
@@ -18,12 +18,24 @@
  *			is a mechanism for doing so, tests whether it is
  *			possible to boot the given HART.
  * @cpu_start:		Boots a cpu into the kernel.
+ * @cpu_disable:	Prepares a cpu to die. May fail for some
+ *			mechanism-specific reason, which will cause the hot
+ *			unplug to be aborted. Called from the cpu to be killed.
+ * @cpu_stop:		Makes a cpu leave the kernel. Must not fail. Called from
+ *			the cpu being stopped.
+ * @cpu_is_stopped:	Ensures a cpu has left the kernel. Called from another
+ *			cpu.
  */
 struct cpu_operations {
 	const char	*name;
 	int		(*cpu_prepare)(unsigned int cpu);
 	int		(*cpu_start)(unsigned int cpu,
 				     struct task_struct *tidle);
+#ifdef CONFIG_HOTPLUG_CPU
+	int		(*cpu_disable)(unsigned int cpu);
+	void		(*cpu_stop)(void);
+	int		(*cpu_is_stopped)(unsigned int cpu);
+#endif
 };
 
 extern const struct cpu_operations *cpu_ops[NR_CPUS];

commit 2875fe0561569f82d0e63658ccf0d11ce7da8922
Author: Atish Patra <atish.patra@wdc.com>
Date:   Tue Mar 17 18:11:40 2020 -0700

    RISC-V: Add cpu_ops and modify default booting method
    
    Currently, all non-booting harts start booting after the booting hart
    updates the per-hart stack pointer. This is done in a way that, it's
    difficult to implement any other booting method without breaking the
    backward compatibility.
    
    Define a cpu_ops method that allows to introduce other booting methods
    in future. Modify the current booting method to be compatible with
    cpu_ops.
    
    Signed-off-by: Atish Patra <atish.patra@wdc.com>
    Reviewed-by: Anup Patel <anup@brainfault.org>
    Signed-off-by: Palmer Dabbelt <palmerdabbelt@google.com>

diff --git a/arch/riscv/include/asm/cpu_ops.h b/arch/riscv/include/asm/cpu_ops.h
new file mode 100644
index 000000000000..5ce81a28e1d9
--- /dev/null
+++ b/arch/riscv/include/asm/cpu_ops.h
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2020 Western Digital Corporation or its affiliates.
+ * Based on arch/arm64/include/asm/cpu_ops.h
+ */
+#ifndef __ASM_CPU_OPS_H
+#define __ASM_CPU_OPS_H
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/threads.h>
+
+/**
+ * struct cpu_operations - Callback operations for hotplugging CPUs.
+ *
+ * @name:		Name of the boot protocol.
+ * @cpu_prepare:	Early one-time preparation step for a cpu. If there
+ *			is a mechanism for doing so, tests whether it is
+ *			possible to boot the given HART.
+ * @cpu_start:		Boots a cpu into the kernel.
+ */
+struct cpu_operations {
+	const char	*name;
+	int		(*cpu_prepare)(unsigned int cpu);
+	int		(*cpu_start)(unsigned int cpu,
+				     struct task_struct *tidle);
+};
+
+extern const struct cpu_operations *cpu_ops[NR_CPUS];
+void __init cpu_set_ops(int cpu);
+void cpu_update_secondary_bootdata(unsigned int cpuid,
+				   struct task_struct *tidle);
+
+#endif /* ifndef __ASM_CPU_OPS_H */
