commit 3384b043ea1564560ff19591cb9554867c7c6f77
Author: Greentime Hu <greentime.hu@sifive.com>
Date:   Tue Mar 3 17:34:18 2020 +0800

    riscv: fix the IPI missing issue in nommu mode
    
    This patch fixes the IPI(inner processor interrupt) missing issue. It
    failed because it used hartid_mask to iterate for_each_cpu(), however the
    cpu_mask and hartid_mask may not be always the same. It will never send the
    IPI to hartid 4 because it will be skipped in for_each_cpu loop in my case.
    
    We can reproduce this case in Qemu sifive_u machine by this command.
    qemu-system-riscv64 -nographic -smp 5 -m 1G -M sifive_u -kernel \
    arch/riscv/boot/loader
    
    It will hang in csd_lock_wait(csd) because the csd_unlock(csd) is not
    called. It is not called because hartid 4 doesn't receive the IPI to
    release this lock. The caller hart doesn't send the IPI to hartid 4 is
    because of hartid 4 is skipped in for_each_cpu(). It will be skipped is
    because "(cpu) < nr_cpu_ids" is not true. The hartid is 4 and nr_cpu_ids
    is 4. Therefore it should use cpumask in for_each_cpu() instead of
    hartid_mask.
    
            /* Send a message to all CPUs in the map */
            arch_send_call_function_ipi_mask(cfd->cpumask_ipi);
    
            if (wait) {
                    for_each_cpu(cpu, cfd->cpumask) {
                            call_single_data_t *csd;
                            csd = per_cpu_ptr(cfd->csd, cpu);
                            csd_lock_wait(csd);
                    }
            }
    
            for ((cpu) = -1;                                \
                    (cpu) = cpumask_next((cpu), (mask)),    \
                    (cpu) < nr_cpu_ids;)
    
    It could boot to login console after this patch applied.
    
    Fixes: b2d36b5668f6 ("riscv: provide native clint access for M-mode")
    Signed-off-by: Greentime Hu <greentime.hu@sifive.com>
    Reviewed-by: Palmer Dabbelt <palmerdabbelt@google.com>
    Signed-off-by: Palmer Dabbelt <palmerdabbelt@google.com>

diff --git a/arch/riscv/include/asm/clint.h b/arch/riscv/include/asm/clint.h
index 6eaa2eedd694..a279b17a6aad 100644
--- a/arch/riscv/include/asm/clint.h
+++ b/arch/riscv/include/asm/clint.h
@@ -15,12 +15,12 @@ static inline void clint_send_ipi_single(unsigned long hartid)
 	writel(1, clint_ipi_base + hartid);
 }
 
-static inline void clint_send_ipi_mask(const struct cpumask *hartid_mask)
+static inline void clint_send_ipi_mask(const struct cpumask *mask)
 {
-	int hartid;
+	int cpu;
 
-	for_each_cpu(hartid, hartid_mask)
-		clint_send_ipi_single(hartid);
+	for_each_cpu(cpu, mask)
+		clint_send_ipi_single(cpuid_to_hartid_map(cpu));
 }
 
 static inline void clint_clear_ipi(unsigned long hartid)

commit fcdc65375186a5cd69cc2eedfb498b86f4f5a21e
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 28 13:10:38 2019 +0100

    riscv: provide native clint access for M-mode
    
    RISC-V has the concept of a cpu level interrupt controller.  The
    interface for it is split between a standardized part that is exposed
    as bits in the mstatus/sstatus register and the mie/mip/sie/sip
    CRS.  But the bit to actually trigger IPIs is not standardized and
    just mentioned as implementable using MMIO.
    
    Add support for IPIs using MMIO using the SiFive clint layout (which
    is also shared by Ariane, Kendryte and the Qemu virt platform).
    Additionally the MMIO block also supports the time value and timer
    compare registers, so they are also set up using the same OF node.
    Support for other layouts should also be relatively easy to add in the
    future.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Anup Patel <anup@brainfault.org>
    [paul.walmsley@sifive.com: update include guard format; fix checkpatch
     issues; minor commit message cleanup]
    Signed-off-by: Paul Walmsley <paul.walmsley@sifive.com>

diff --git a/arch/riscv/include/asm/clint.h b/arch/riscv/include/asm/clint.h
new file mode 100644
index 000000000000..6eaa2eedd694
--- /dev/null
+++ b/arch/riscv/include/asm/clint.h
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _ASM_RISCV_CLINT_H
+#define _ASM_RISCV_CLINT_H 1
+
+#include <linux/io.h>
+#include <linux/smp.h>
+
+#ifdef CONFIG_RISCV_M_MODE
+extern u32 __iomem *clint_ipi_base;
+
+void clint_init_boot_cpu(void);
+
+static inline void clint_send_ipi_single(unsigned long hartid)
+{
+	writel(1, clint_ipi_base + hartid);
+}
+
+static inline void clint_send_ipi_mask(const struct cpumask *hartid_mask)
+{
+	int hartid;
+
+	for_each_cpu(hartid, hartid_mask)
+		clint_send_ipi_single(hartid);
+}
+
+static inline void clint_clear_ipi(unsigned long hartid)
+{
+	writel(0, clint_ipi_base + hartid);
+}
+#else /* CONFIG_RISCV_M_MODE */
+#define clint_init_boot_cpu()	do { } while (0)
+
+/* stubs to for code is only reachable under IS_ENABLED(CONFIG_RISCV_M_MODE): */
+void clint_send_ipi_single(unsigned long hartid);
+void clint_send_ipi_mask(const struct cpumask *hartid_mask);
+void clint_clear_ipi(unsigned long hartid);
+#endif /* CONFIG_RISCV_M_MODE */
+
+#endif /* _ASM_RISCV_CLINT_H */
