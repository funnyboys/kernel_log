commit f1e58583b9c7ceae7f11646e9edf2561d67f29c9
Author: Atish Patra <atish.patra@wdc.com>
Date:   Tue Mar 17 18:11:44 2020 -0700

    RISC-V: Support cpu hotplug
    
    This patch enable support for cpu hotplug in RISC-V. It uses SBI HSM
    extension to online/offline any hart. As a result, the harts are
    returned to firmware once they are offline. If the harts are brought
    online afterwards, they re-enter Linux kernel as if a secondary hart
    booted for the first time. All booting requirements are honored during
    this process.
    
    Tested both on QEMU and HighFive Unleashed board with. Test result follows.
    
    ---------------------------------------------------
    Offline cpu 2
    ---------------------------------------------------
    $ echo 0 > /sys/devices/system/cpu/cpu2/online
    [   32.828684] CPU2: off
    $ cat /proc/cpuinfo
    processor       : 0
    hart            : 0
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 1
    hart            : 1
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 3
    hart            : 3
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 4
    hart            : 4
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 5
    hart            : 5
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 6
    hart            : 6
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 7
    hart            : 7
    isa             : rv64imafdcsu
    mmu             : sv48
    
    ---------------------------------------------------
    online cpu 2
    ---------------------------------------------------
    $ echo 1 > /sys/devices/system/cpu/cpu2/online
    $ cat /proc/cpuinfo
    processor       : 0
    hart            : 0
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 1
    hart            : 1
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 2
    hart            : 2
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 3
    hart            : 3
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 4
    hart            : 4
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 5
    hart            : 5
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 6
    hart            : 6
    isa             : rv64imafdcsu
    mmu             : sv48
    
    processor       : 7
    hart            : 7
    isa             : rv64imafdcsu
    mmu             : sv48
    
    Signed-off-by: Atish Patra <atish.patra@wdc.com>
    Reviewed-by: Anup Patel <anup@brainfault.org>

diff --git a/arch/riscv/kernel/cpu_ops_sbi.c b/arch/riscv/kernel/cpu_ops_sbi.c
index 66f3cded91f5..685fae72b7f5 100644
--- a/arch/riscv/kernel/cpu_ops_sbi.c
+++ b/arch/riscv/kernel/cpu_ops_sbi.c
@@ -74,8 +74,42 @@ static int sbi_cpu_prepare(unsigned int cpuid)
 	return 0;
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+static int sbi_cpu_disable(unsigned int cpuid)
+{
+	if (!cpu_ops_sbi.cpu_stop)
+		return -EOPNOTSUPP;
+	return 0;
+}
+
+static void sbi_cpu_stop(void)
+{
+	int ret;
+
+	ret = sbi_hsm_hart_stop();
+	pr_crit("Unable to stop the cpu %u (%d)\n", smp_processor_id(), ret);
+}
+
+static int sbi_cpu_is_stopped(unsigned int cpuid)
+{
+	int rc;
+	int hartid = cpuid_to_hartid_map(cpuid);
+
+	rc = sbi_hsm_hart_get_status(hartid);
+
+	if (rc == SBI_HSM_HART_STATUS_STOPPED)
+		return 0;
+	return rc;
+}
+#endif
+
 const struct cpu_operations cpu_ops_sbi = {
 	.name		= "sbi",
 	.cpu_prepare	= sbi_cpu_prepare,
 	.cpu_start	= sbi_cpu_start,
+#ifdef CONFIG_HOTPLUG_CPU
+	.cpu_disable	= sbi_cpu_disable,
+	.cpu_stop	= sbi_cpu_stop,
+	.cpu_is_stopped	= sbi_cpu_is_stopped,
+#endif
 };

commit cfafe260137418d0265d0df3bb18dc494af2b43e
Author: Atish Patra <atish.patra@wdc.com>
Date:   Tue Mar 17 18:11:43 2020 -0700

    RISC-V: Add supported for ordered booting method using HSM
    
    Currently, all harts have to jump Linux in RISC-V. This complicates the
    multi-stage boot process as every transient stage also has to ensure all
    harts enter to that stage and jump to Linux afterwards. It also obstructs
    a clean Kexec implementation.
    
    SBI HSM extension provides alternate solutions where only a single hart
    need to boot and enter Linux. The booting hart can bring up secondary
    harts one by one afterwards.
    
    Add SBI HSM based cpu_ops that implements an ordered booting method in
    RISC-V. This change is also backward compatible with older firmware not
    implementing HSM extension. If a latest kernel is used with older
    firmware, it will continue to use the default spinning booting method.
    
    Signed-off-by: Atish Patra <atish.patra@wdc.com>
    Reviewed-by: Anup Patel <anup@brainfault.org>
    Signed-off-by: Palmer Dabbelt <palmerdabbelt@google.com>

diff --git a/arch/riscv/kernel/cpu_ops_sbi.c b/arch/riscv/kernel/cpu_ops_sbi.c
new file mode 100644
index 000000000000..66f3cded91f5
--- /dev/null
+++ b/arch/riscv/kernel/cpu_ops_sbi.c
@@ -0,0 +1,81 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * HSM extension and cpu_ops implementation.
+ *
+ * Copyright (c) 2020 Western Digital Corporation or its affiliates.
+ */
+
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <asm/cpu_ops.h>
+#include <asm/sbi.h>
+#include <asm/smp.h>
+
+extern char secondary_start_sbi[];
+const struct cpu_operations cpu_ops_sbi;
+
+static int sbi_hsm_hart_start(unsigned long hartid, unsigned long saddr,
+			      unsigned long priv)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_HSM, SBI_EXT_HSM_HART_START,
+			hartid, saddr, priv, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+	else
+		return 0;
+}
+
+#ifdef CONFIG_HOTPLUG_CPU
+static int sbi_hsm_hart_stop(void)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_HSM, SBI_EXT_HSM_HART_STOP, 0, 0, 0, 0, 0, 0);
+
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+	else
+		return 0;
+}
+
+static int sbi_hsm_hart_get_status(unsigned long hartid)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_HSM, SBI_EXT_HSM_HART_STATUS,
+			hartid, 0, 0, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+	else
+		return ret.value;
+}
+#endif
+
+static int sbi_cpu_start(unsigned int cpuid, struct task_struct *tidle)
+{
+	int rc;
+	unsigned long boot_addr = __pa_symbol(secondary_start_sbi);
+	int hartid = cpuid_to_hartid_map(cpuid);
+
+	cpu_update_secondary_bootdata(cpuid, tidle);
+	rc = sbi_hsm_hart_start(hartid, boot_addr, 0);
+
+	return rc;
+}
+
+static int sbi_cpu_prepare(unsigned int cpuid)
+{
+	if (!cpu_ops_sbi.cpu_start) {
+		pr_err("cpu start method not defined for CPU [%d]\n", cpuid);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+const struct cpu_operations cpu_ops_sbi = {
+	.name		= "sbi",
+	.cpu_prepare	= sbi_cpu_prepare,
+	.cpu_start	= sbi_cpu_start,
+};
