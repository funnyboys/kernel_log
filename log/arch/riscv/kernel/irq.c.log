commit 24dc17005ca1d5034d5575f8f94bfd9ad719a22f
Author: Anup Patel <anup.patel@wdc.com>
Date:   Mon Jun 1 14:45:42 2020 +0530

    RISC-V: Remove do_IRQ() function
    
    The only thing do_IRQ() does is call handle_arch_irq function
    pointer. We can very well call handle_arch_irq function pointer
    directly from assembly and remove do_IRQ() function hence this
    patch.
    
    Signed-off-by: Anup Patel <anup.patel@wdc.com>
    Reviewed-by: Atish Patra <atish.patra@wdc.com>
    Signed-off-by: Palmer Dabbelt <palmerdabbelt@google.com>

diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c
index eb8777642ce6..7207fa08d78f 100644
--- a/arch/riscv/kernel/irq.c
+++ b/arch/riscv/kernel/irq.c
@@ -16,12 +16,6 @@ int arch_show_interrupts(struct seq_file *p, int prec)
 	return 0;
 }
 
-asmlinkage __visible void __irq_entry do_IRQ(struct pt_regs *regs)
-{
-	if (handle_arch_irq)
-		handle_arch_irq(regs);
-}
-
 void __init init_IRQ(void)
 {
 	irqchip_init();

commit 6b7ce8927b5a4d739670d4dc0de301f2abfd9a5c
Author: Anup Patel <anup.patel@wdc.com>
Date:   Mon Jun 1 14:45:40 2020 +0530

    irqchip: RISC-V per-HART local interrupt controller driver
    
    The RISC-V per-HART local interrupt controller manages software
    interrupts, timer interrupts, external interrupts (which are routed
    via the platform level interrupt controller) and other per-HART
    local interrupts.
    
    We add a driver for the RISC-V local interrupt controller, which
    eventually replaces the RISC-V architecture code, allowing for a
    better split between arch code and drivers.
    
    The driver is compliant with RISC-V Hart-Level Interrupt Controller
    DT bindings located at:
    Documentation/devicetree/bindings/interrupt-controller/riscv,cpu-intc.txt
    
    Co-developed-by: Palmer Dabbelt <palmer@dabbelt.com>
    Signed-off-by: Anup Patel <anup.patel@wdc.com>
    [Palmer: Cleaned up warnings]
    Signed-off-by: Palmer Dabbelt <palmer@dabbelt.com>

diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c
index bb0bfcd537e7..eb8777642ce6 100644
--- a/arch/riscv/kernel/irq.c
+++ b/arch/riscv/kernel/irq.c
@@ -7,7 +7,6 @@
 
 #include <linux/interrupt.h>
 #include <linux/irqchip.h>
-#include <linux/irqdomain.h>
 #include <linux/seq_file.h>
 #include <asm/smp.h>
 
@@ -19,39 +18,13 @@ int arch_show_interrupts(struct seq_file *p, int prec)
 
 asmlinkage __visible void __irq_entry do_IRQ(struct pt_regs *regs)
 {
-	struct pt_regs *old_regs;
-
-	switch (regs->cause & ~CAUSE_IRQ_FLAG) {
-	case RV_IRQ_TIMER:
-		old_regs = set_irq_regs(regs);
-		irq_enter();
-		riscv_timer_interrupt();
-		irq_exit();
-		set_irq_regs(old_regs);
-		break;
-#ifdef CONFIG_SMP
-	case RV_IRQ_SOFT:
-		/*
-		 * We only use software interrupts to pass IPIs, so if a non-SMP
-		 * system gets one, then we don't know what to do.
-		 */
-		handle_IPI(regs);
-		break;
-#endif
-	case RV_IRQ_EXT:
-		old_regs = set_irq_regs(regs);
-		irq_enter();
+	if (handle_arch_irq)
 		handle_arch_irq(regs);
-		irq_exit();
-		set_irq_regs(old_regs);
-		break;
-	default:
-		pr_alert("unexpected interrupt cause 0x%lx", regs->cause);
-		BUG();
-	}
 }
 
 void __init init_IRQ(void)
 {
 	irqchip_init();
+	if (!handle_arch_irq)
+		panic("No interrupt controller found.");
 }

commit 5cf998ba8c7bbbfec3e0d6534c9a3f860ab9920e
Author: Anup Patel <anup.patel@wdc.com>
Date:   Mon Jun 1 14:45:38 2020 +0530

    RISC-V: self-contained IPI handling routine
    
    Currently, the IPI handling routine riscv_software_interrupt() does
    not take any argument and also does not perform irq_enter()/irq_exit().
    
    This patch makes IPI handling routine more self-contained by:
    1. Passing "pt_regs *" argument
    2. Explicitly doing irq_enter()/irq_exit()
    3. Explicitly save/restore "pt_regs *" using set_irq_regs()
    
    With above changes, IPI handling routine does not depend on caller
    function to perform irq_enter()/irq_exit() and save/restore of
    "pt_regs *" hence its more self-contained. This also enables us
    to call IPI handling routine from IRQCHIP drivers.
    
    Signed-off-by: Anup Patel <anup.patel@wdc.com>
    Reviewed-by: Atish Patra <atish.patra@wdc.com>
    Reviewed-by: Palmer Dabbelt <palmerdabbelt@google.com>
    Acked-by: Palmer Dabbelt <palmerdabbelt@google.com>
    Signed-off-by: Palmer Dabbelt <palmerdabbelt@google.com>

diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c
index 345c4f2eba13..bb0bfcd537e7 100644
--- a/arch/riscv/kernel/irq.c
+++ b/arch/riscv/kernel/irq.c
@@ -19,12 +19,15 @@ int arch_show_interrupts(struct seq_file *p, int prec)
 
 asmlinkage __visible void __irq_entry do_IRQ(struct pt_regs *regs)
 {
-	struct pt_regs *old_regs = set_irq_regs(regs);
+	struct pt_regs *old_regs;
 
-	irq_enter();
 	switch (regs->cause & ~CAUSE_IRQ_FLAG) {
 	case RV_IRQ_TIMER:
+		old_regs = set_irq_regs(regs);
+		irq_enter();
 		riscv_timer_interrupt();
+		irq_exit();
+		set_irq_regs(old_regs);
 		break;
 #ifdef CONFIG_SMP
 	case RV_IRQ_SOFT:
@@ -32,19 +35,20 @@ asmlinkage __visible void __irq_entry do_IRQ(struct pt_regs *regs)
 		 * We only use software interrupts to pass IPIs, so if a non-SMP
 		 * system gets one, then we don't know what to do.
 		 */
-		riscv_software_interrupt();
+		handle_IPI(regs);
 		break;
 #endif
 	case RV_IRQ_EXT:
+		old_regs = set_irq_regs(regs);
+		irq_enter();
 		handle_arch_irq(regs);
+		irq_exit();
+		set_irq_regs(old_regs);
 		break;
 	default:
 		pr_alert("unexpected interrupt cause 0x%lx", regs->cause);
 		BUG();
 	}
-	irq_exit();
-
-	set_irq_regs(old_regs);
 }
 
 void __init init_IRQ(void)

commit 2f3035da4019780250658d1ffe486bc324e04805
Author: Paul Walmsley <paul.walmsley@sifive.com>
Date:   Fri Dec 20 03:09:49 2019 -0800

    riscv: prefix IRQ_ macro names with an RV_ namespace
    
    "IRQ_TIMER", used in the arch/riscv CSR header file, is a sufficiently
    generic macro name that it's used by several source files across the
    Linux code base.  Some of these other files ultimately include the
    arch/riscv CSR include file, causing collisions.  Fix by prefixing the
    RISC-V csr.h IRQ_ macro names with an RV_ prefix.
    
    Fixes: a4c3733d32a72 ("riscv: abstract out CSR names for supervisor vs machine mode")
    Reported-by: Olof Johansson <olof@lixom.net>
    Acked-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Paul Walmsley <paul.walmsley@sifive.com>

diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c
index 3f07a91d5afb..345c4f2eba13 100644
--- a/arch/riscv/kernel/irq.c
+++ b/arch/riscv/kernel/irq.c
@@ -23,11 +23,11 @@ asmlinkage __visible void __irq_entry do_IRQ(struct pt_regs *regs)
 
 	irq_enter();
 	switch (regs->cause & ~CAUSE_IRQ_FLAG) {
-	case IRQ_TIMER:
+	case RV_IRQ_TIMER:
 		riscv_timer_interrupt();
 		break;
 #ifdef CONFIG_SMP
-	case IRQ_SOFT:
+	case RV_IRQ_SOFT:
 		/*
 		 * We only use software interrupts to pass IPIs, so if a non-SMP
 		 * system gets one, then we don't know what to do.
@@ -35,7 +35,7 @@ asmlinkage __visible void __irq_entry do_IRQ(struct pt_regs *regs)
 		riscv_software_interrupt();
 		break;
 #endif
-	case IRQ_EXT:
+	case RV_IRQ_EXT:
 		handle_arch_irq(regs);
 		break;
 	default:

commit a4c3733d32a72f11dee86d0731d7565aa6ebe22d
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 28 13:10:32 2019 +0100

    riscv: abstract out CSR names for supervisor vs machine mode
    
    Many of the privileged CSRs exist in a supervisor and machine version
    that are used very similarly.  Provide versions of the CSR names and
    fields that map to either the S-mode or M-mode variant depending on
    a new CONFIG_RISCV_M_MODE kconfig symbol.
    
    Contains contributions from Damien Le Moal <Damien.LeMoal@wdc.com>
    and Paul Walmsley <paul.walmsley@sifive.com>.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de> # for drivers/clocksource, drivers/irqchip
    [paul.walmsley@sifive.com: updated to apply]
    Signed-off-by: Paul Walmsley <paul.walmsley@sifive.com>

diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c
index fffac6ddb0e0..3f07a91d5afb 100644
--- a/arch/riscv/kernel/irq.c
+++ b/arch/riscv/kernel/irq.c
@@ -11,13 +11,6 @@
 #include <linux/seq_file.h>
 #include <asm/smp.h>
 
-/*
- * Possible interrupt causes:
- */
-#define INTERRUPT_CAUSE_SOFTWARE	IRQ_S_SOFT
-#define INTERRUPT_CAUSE_TIMER		IRQ_S_TIMER
-#define INTERRUPT_CAUSE_EXTERNAL	IRQ_S_EXT
-
 int arch_show_interrupts(struct seq_file *p, int prec)
 {
 	show_ipi_stats(p, prec);
@@ -29,12 +22,12 @@ asmlinkage __visible void __irq_entry do_IRQ(struct pt_regs *regs)
 	struct pt_regs *old_regs = set_irq_regs(regs);
 
 	irq_enter();
-	switch (regs->scause & ~SCAUSE_IRQ_FLAG) {
-	case INTERRUPT_CAUSE_TIMER:
+	switch (regs->cause & ~CAUSE_IRQ_FLAG) {
+	case IRQ_TIMER:
 		riscv_timer_interrupt();
 		break;
 #ifdef CONFIG_SMP
-	case INTERRUPT_CAUSE_SOFTWARE:
+	case IRQ_SOFT:
 		/*
 		 * We only use software interrupts to pass IPIs, so if a non-SMP
 		 * system gets one, then we don't know what to do.
@@ -42,11 +35,11 @@ asmlinkage __visible void __irq_entry do_IRQ(struct pt_regs *regs)
 		riscv_software_interrupt();
 		break;
 #endif
-	case INTERRUPT_CAUSE_EXTERNAL:
+	case IRQ_EXT:
 		handle_arch_irq(regs);
 		break;
 	default:
-		pr_alert("unexpected interrupt cause 0x%lx", regs->scause);
+		pr_alert("unexpected interrupt cause 0x%lx", regs->cause);
 		BUG();
 	}
 	irq_exit();

commit f307307992bf63e609fe5395953048e81c9ebc54
Author: Paul Walmsley <paul.walmsley@sifive.com>
Date:   Thu Oct 17 22:20:05 2019 -0700

    riscv: for C functions called only from assembly, mark with __visible
    
    Rather than adding prototypes for C functions called only by assembly
    code, mark them as __visible.  This avoids adding prototypes that will
    never be used by the callers.  Resolves the following sparse warnings:
    
    arch/riscv/kernel/irq.c:27:29: warning: symbol 'do_IRQ' was not declared. Should it be static?
    arch/riscv/kernel/ptrace.c:151:6: warning: symbol 'do_syscall_trace_enter' was not declared. Should it be static?
    arch/riscv/kernel/ptrace.c:165:6: warning: symbol 'do_syscall_trace_exit' was not declared. Should it be static?
    arch/riscv/kernel/signal.c:295:17: warning: symbol 'do_notify_resume' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:92:1: warning: symbol 'do_trap_unknown' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:94:1: warning: symbol 'do_trap_insn_misaligned' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:96:1: warning: symbol 'do_trap_insn_fault' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:98:1: warning: symbol 'do_trap_insn_illegal' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:100:1: warning: symbol 'do_trap_load_misaligned' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:102:1: warning: symbol 'do_trap_load_fault' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:104:1: warning: symbol 'do_trap_store_misaligned' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:106:1: warning: symbol 'do_trap_store_fault' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:108:1: warning: symbol 'do_trap_ecall_u' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:110:1: warning: symbol 'do_trap_ecall_s' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:112:1: warning: symbol 'do_trap_ecall_m' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:124:17: warning: symbol 'do_trap_break' was not declared. Should it be static?
    arch/riscv/kernel/smpboot.c:136:24: warning: symbol 'smp_callin' was not declared. Should it be static?
    
    Based on a suggestion from Luc Van Oostenryck.
    
    This version includes changes based on feedback from Christoph Hellwig
    <hch@lst.de>.
    
    Signed-off-by: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de> # for do_syscall_trace_*

diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c
index 6d8659388c49..fffac6ddb0e0 100644
--- a/arch/riscv/kernel/irq.c
+++ b/arch/riscv/kernel/irq.c
@@ -24,7 +24,7 @@ int arch_show_interrupts(struct seq_file *p, int prec)
 	return 0;
 }
 
-asmlinkage void __irq_entry do_IRQ(struct pt_regs *regs)
+asmlinkage __visible void __irq_entry do_IRQ(struct pt_regs *regs)
 {
 	struct pt_regs *old_regs = set_irq_regs(regs);
 

commit 6dcaf00487ca10d87e53fc8decb2e30f113c955d
Author: Anup Patel <Anup.Patel@wdc.com>
Date:   Thu Apr 25 08:38:37 2019 +0000

    RISC-V: Add interrupt related SCAUSE defines in asm/csr.h
    
    This patch adds SCAUSE interrupt flag and SCAUSE interrupt related
    defines to asm/csr.h. We also use these defines in kernel/irq.c and
    express SIE/SIP flags in-terms of SCAUSE interrupt causes.
    
    Signed-off-by: Anup Patel <anup.patel@wdc.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c
index c738132eecf8..6d8659388c49 100644
--- a/arch/riscv/kernel/irq.c
+++ b/arch/riscv/kernel/irq.c
@@ -14,17 +14,9 @@
 /*
  * Possible interrupt causes:
  */
-#define INTERRUPT_CAUSE_SOFTWARE    1
-#define INTERRUPT_CAUSE_TIMER       5
-#define INTERRUPT_CAUSE_EXTERNAL    9
-
-/*
- * The high order bit of the trap cause register is always set for
- * interrupts, which allows us to differentiate them from exceptions
- * quickly.  The INTERRUPT_CAUSE_* macros don't contain that bit, so we
- * need to mask it off.
- */
-#define INTERRUPT_CAUSE_FLAG	(1UL << (__riscv_xlen - 1))
+#define INTERRUPT_CAUSE_SOFTWARE	IRQ_S_SOFT
+#define INTERRUPT_CAUSE_TIMER		IRQ_S_TIMER
+#define INTERRUPT_CAUSE_EXTERNAL	IRQ_S_EXT
 
 int arch_show_interrupts(struct seq_file *p, int prec)
 {
@@ -37,7 +29,7 @@ asmlinkage void __irq_entry do_IRQ(struct pt_regs *regs)
 	struct pt_regs *old_regs = set_irq_regs(regs);
 
 	irq_enter();
-	switch (regs->scause & ~INTERRUPT_CAUSE_FLAG) {
+	switch (regs->scause & ~SCAUSE_IRQ_FLAG) {
 	case INTERRUPT_CAUSE_TIMER:
 		riscv_timer_interrupt();
 		break;

commit bed1378706637c0dd09c055480767dfcf6abe7db
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Apr 15 11:14:41 2019 +0200

    riscv: print the unexpected interrupt cause
    
    This has been helpful when debugging my pending nommu port.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Nick Kossifidis <mick@ics.forth.gr>
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c
index 48e6b7db83a1..c738132eecf8 100644
--- a/arch/riscv/kernel/irq.c
+++ b/arch/riscv/kernel/irq.c
@@ -54,7 +54,8 @@ asmlinkage void __irq_entry do_IRQ(struct pt_regs *regs)
 		handle_arch_irq(regs);
 		break;
 	default:
-		panic("unexpected interrupt cause");
+		pr_alert("unexpected interrupt cause 0x%lx", regs->scause);
+		BUG();
 	}
 	irq_exit();
 

commit 8b20d2db0a6d2761e0fc156eb74f7a55b92b3147
Author: Anup Patel <anup@brainfault.org>
Date:   Tue Oct 2 12:15:07 2018 -0700

    RISC-V: Show IPI stats
    
    This patch provides arch_show_interrupts() implementation to
    show IPI stats via /proc/interrupts.
    
    Now the contents of /proc/interrupts" will look like below:
               CPU0       CPU1       CPU2       CPU3
      8:         17          7          6         14  SiFive PLIC   8  virtio0
     10:         10         10          9         11  SiFive PLIC  10  ttyS0
    IPI0:       170        673        251         79  Rescheduling interrupts
    IPI1:         1         12         27          1  Function call interrupts
    
    Signed-off-by: Anup Patel <anup@brainfault.org>
    [Atish - Fixed checkpatch errors]
    Signed-off-by: Atish Patra <atish.patra@wdc.com>
    Reviewed-by: Palmer Dabbelt <palmer@sifive.com>
    
    Changes since v2:
     - Remove use of IPI_CALL_WAKEUP because it's being removed
    
    Changes since v1:
     - Add stub inline show_ipi_stats() function for !CONFIG_SMP
     - Make ipi_names[] dynamically sized at compile time
     - Minor beautification of ipi_names[] using tabs
    
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c
index ca4593317e45..48e6b7db83a1 100644
--- a/arch/riscv/kernel/irq.c
+++ b/arch/riscv/kernel/irq.c
@@ -8,6 +8,8 @@
 #include <linux/interrupt.h>
 #include <linux/irqchip.h>
 #include <linux/irqdomain.h>
+#include <linux/seq_file.h>
+#include <asm/smp.h>
 
 /*
  * Possible interrupt causes:
@@ -24,6 +26,12 @@
  */
 #define INTERRUPT_CAUSE_FLAG	(1UL << (__riscv_xlen - 1))
 
+int arch_show_interrupts(struct seq_file *p, int prec)
+{
+	show_ipi_stats(p, prec);
+	return 0;
+}
+
 asmlinkage void __irq_entry do_IRQ(struct pt_regs *regs)
 {
 	struct pt_regs *old_regs = set_irq_regs(regs);

commit 1ed4237ab616a05225e11d07bf42d5474deec905
Author: Anup Patel <anup@brainfault.org>
Date:   Tue Oct 2 12:14:54 2018 -0700

    RISC-V: No need to pass scause as arg to do_IRQ()
    
    The scause is already part of pt_regs so no need to pass
    scause as separate arg to do_IRQ().
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Anup Patel <anup@brainfault.org>
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c
index 0cfac48a1272..ca4593317e45 100644
--- a/arch/riscv/kernel/irq.c
+++ b/arch/riscv/kernel/irq.c
@@ -24,12 +24,12 @@
  */
 #define INTERRUPT_CAUSE_FLAG	(1UL << (__riscv_xlen - 1))
 
-asmlinkage void __irq_entry do_IRQ(struct pt_regs *regs, unsigned long cause)
+asmlinkage void __irq_entry do_IRQ(struct pt_regs *regs)
 {
 	struct pt_regs *old_regs = set_irq_regs(regs);
 
 	irq_enter();
-	switch (cause & ~INTERRUPT_CAUSE_FLAG) {
+	switch (regs->scause & ~INTERRUPT_CAUSE_FLAG) {
 	case INTERRUPT_CAUSE_TIMER:
 		riscv_timer_interrupt();
 		break;

commit 62b0194368147def8c5a77ce604a125d620fc582
Author: Palmer Dabbelt <palmer@dabbelt.com>
Date:   Sat Aug 4 10:23:19 2018 +0200

    clocksource: new RISC-V SBI timer driver
    
    The RISC-V ISA defines a per-hart real-time clock and timer, which is
    present on all systems.  The clock is accessed via the 'rdtime'
    pseudo-instruction (which reads a CSR), and the timer is set via an SBI
    call.
    
    Contains various improvements from Atish Patra <atish.patra@wdc.com>.
    
    Signed-off-by: Dmitriy Cherkasov <dmitriy@oss-tech.org>
    Signed-off-by: Palmer Dabbelt <palmer@dabbelt.com>
    [hch: remove dead code, add SPDX tags, used riscv_of_processor_hart(),
     minor cleanups, merged  hotplug cpu support and other improvements
     from Atish]
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Atish Patra <atish.patra@wdc.com>
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c
index ab5f3e22c7cc..0cfac48a1272 100644
--- a/arch/riscv/kernel/irq.c
+++ b/arch/riscv/kernel/irq.c
@@ -30,6 +30,9 @@ asmlinkage void __irq_entry do_IRQ(struct pt_regs *regs, unsigned long cause)
 
 	irq_enter();
 	switch (cause & ~INTERRUPT_CAUSE_FLAG) {
+	case INTERRUPT_CAUSE_TIMER:
+		riscv_timer_interrupt();
+		break;
 #ifdef CONFIG_SMP
 	case INTERRUPT_CAUSE_SOFTWARE:
 		/*

commit 6ea0f26a7913b2a72f9cbe84e77ad2cbeaaa9dde
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Aug 4 10:23:16 2018 +0200

    RISC-V: implement low-level interrupt handling
    
    Add support for a routine that dispatches exceptions with the interrupt
    flags set to either the IPI or irqdomain code (and the clock source in the
    future).
    
    Loosely based on the irq-riscv-int.c irqchip driver from the RISC-V tree.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c
index 7bcdaed15703..ab5f3e22c7cc 100644
--- a/arch/riscv/kernel/irq.c
+++ b/arch/riscv/kernel/irq.c
@@ -1,21 +1,55 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2012 Regents of the University of California
  * Copyright (C) 2017 SiFive
- *
- *   This program is free software; you can redistribute it and/or
- *   modify it under the terms of the GNU General Public License
- *   as published by the Free Software Foundation, version 2.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
+ * Copyright (C) 2018 Christoph Hellwig
  */
 
 #include <linux/interrupt.h>
 #include <linux/irqchip.h>
 #include <linux/irqdomain.h>
 
+/*
+ * Possible interrupt causes:
+ */
+#define INTERRUPT_CAUSE_SOFTWARE    1
+#define INTERRUPT_CAUSE_TIMER       5
+#define INTERRUPT_CAUSE_EXTERNAL    9
+
+/*
+ * The high order bit of the trap cause register is always set for
+ * interrupts, which allows us to differentiate them from exceptions
+ * quickly.  The INTERRUPT_CAUSE_* macros don't contain that bit, so we
+ * need to mask it off.
+ */
+#define INTERRUPT_CAUSE_FLAG	(1UL << (__riscv_xlen - 1))
+
+asmlinkage void __irq_entry do_IRQ(struct pt_regs *regs, unsigned long cause)
+{
+	struct pt_regs *old_regs = set_irq_regs(regs);
+
+	irq_enter();
+	switch (cause & ~INTERRUPT_CAUSE_FLAG) {
+#ifdef CONFIG_SMP
+	case INTERRUPT_CAUSE_SOFTWARE:
+		/*
+		 * We only use software interrupts to pass IPIs, so if a non-SMP
+		 * system gets one, then we don't know what to do.
+		 */
+		riscv_software_interrupt();
+		break;
+#endif
+	case INTERRUPT_CAUSE_EXTERNAL:
+		handle_arch_irq(regs);
+		break;
+	default:
+		panic("unexpected interrupt cause");
+	}
+	irq_exit();
+
+	set_irq_regs(old_regs);
+}
+
 void __init init_IRQ(void)
 {
 	irqchip_init();

commit 8606544890d7dc4f7a740963f70dc1e1d54f8e30
Author: Palmer Dabbelt <palmer@sifive.com>
Date:   Fri Jun 22 15:46:28 2018 -0700

    RISC-V: Don't include irq-riscv-intc.h
    
    This file has never existed in the upstream kernel, but it's guarded by
    an #ifdef that's also never existed in the upstream kernel.  As a part
    of our interrupt controller refactoring this header is no longer
    necessary, but this reference managed to sneak in anyway.
    
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c
index b74cbfbce2d0..7bcdaed15703 100644
--- a/arch/riscv/kernel/irq.c
+++ b/arch/riscv/kernel/irq.c
@@ -16,10 +16,6 @@
 #include <linux/irqchip.h>
 #include <linux/irqdomain.h>
 
-#ifdef CONFIG_RISCV_INTC
-#include <linux/irqchip/irq-riscv-intc.h>
-#endif
-
 void __init init_IRQ(void)
 {
 	irqchip_init();

commit cc6c98485f8e61fb3d6c51821fc75384e5a3a9c3
Author: Palmer Dabbelt <palmer@sifive.com>
Date:   Wed Mar 7 15:57:28 2018 -0800

    RISC-V: Move to the new GENERIC_IRQ_MULTI_HANDLER handler
    
    The existing mechanism for handling IRQs on RISC-V is pretty ugly: the irq
    entry code selects the handler via Kconfig dependencies.
    
    Use the new generic IRQ handling infastructure, which allows boot time
    registration of the low level entry handler.
    
    This does add an additional load to the interrupt latency, but there's a
    lot of tuning left to be done there on RISC-V so it's OK for now.
    
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Stafford Horne <shorne@gmail.com>
    Cc: jonas@southpole.se
    Cc: catalin.marinas@arm.com
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux@armlinux.org.uk
    Cc: stefan.kristiansson@saunalahti.fi
    Cc: openrisc@lists.librecores.org
    Cc: linux-riscv@lists.infradead.org
    Cc: linux-arm-kernel@lists.infradead.org
    Link: https://lkml.kernel.org/r/20180307235731.22627-3-palmer@sifive.com

diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c
index 328718e8026e..b74cbfbce2d0 100644
--- a/arch/riscv/kernel/irq.c
+++ b/arch/riscv/kernel/irq.c
@@ -24,16 +24,3 @@ void __init init_IRQ(void)
 {
 	irqchip_init();
 }
-
-asmlinkage void __irq_entry do_IRQ(unsigned int cause, struct pt_regs *regs)
-{
-#ifdef CONFIG_RISCV_INTC
-	/*
-	 * FIXME: We don't want a direct call to riscv_intc_irq here.  The plan
-	 * is to put an IRQ domain here and let the interrupt controller
-	 * register with that, but I poked around the arm64 code a bit and
-	 * there might be a better way to do it (ie, something fully generic).
-	 */
-	riscv_intc_irq(cause, regs);
-#endif
-}

commit 76d2a0493a17d4c8ecc781366850c3c4f8e1a446
Author: Palmer Dabbelt <palmer@dabbelt.com>
Date:   Mon Jul 10 18:00:26 2017 -0700

    RISC-V: Init and Halt Code
    
    This contains the various __init C functions, the initial assembly
    kernel entry point, and the code to reset the system.  When a file was
    init-related this patch contains the entire file.
    
    Signed-off-by: Palmer Dabbelt <palmer@dabbelt.com>

diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c
new file mode 100644
index 000000000000..328718e8026e
--- /dev/null
+++ b/arch/riscv/kernel/irq.c
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2012 Regents of the University of California
+ * Copyright (C) 2017 SiFive
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation, version 2.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+
+#ifdef CONFIG_RISCV_INTC
+#include <linux/irqchip/irq-riscv-intc.h>
+#endif
+
+void __init init_IRQ(void)
+{
+	irqchip_init();
+}
+
+asmlinkage void __irq_entry do_IRQ(unsigned int cause, struct pt_regs *regs)
+{
+#ifdef CONFIG_RISCV_INTC
+	/*
+	 * FIXME: We don't want a direct call to riscv_intc_irq here.  The plan
+	 * is to put an IRQ domain here and let the interrupt controller
+	 * register with that, but I poked around the arm64 code a bit and
+	 * there might be a better way to do it (ie, something fully generic).
+	 */
+	riscv_intc_irq(cause, regs);
+#endif
+}
