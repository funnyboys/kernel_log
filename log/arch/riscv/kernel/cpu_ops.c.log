commit d6d5161280b3d57163f5310f0a0007cdeb729984
Author: Zong Li <zong.li@sifive.com>
Date:   Mon May 4 11:54:48 2020 +0800

    riscv: force __cpu_up_ variables to put in data section
    
    Put __cpu_up_stack_pointer and __cpu_up_task_pointer in data section.
    Currently, these two variables are put in bss section, there is a
    potential risk that secondary harts get the uninitialized value before
    main hart finishing the bss clearing. In this case, all secondary
    harts would pass the waiting loop and enable the MMU before main hart
    set up the page table.
    
    This issue happens on random booting of multiple harts, which means
    it will manifest for BBL and OpenSBI v0.6 (or older version). In OpenSBI
    v0.7 (or higher version), we have HSM extension so all the secondary harts
    are brought-up by Linux kernel in an orderly fashion. This means we don't
    need this change for OpenSBI v0.7 (or higher version).
    
    Signed-off-by: Zong Li <zong.li@sifive.com>
    Reviewed-by: Greentime Hu <greentime.hu@sifive.com>
    Reviewed-by: Anup Patel <anup@brainfault.org>
    Reviewed-by: Atish Patra <atish.patra@wdc.com>
    Signed-off-by: Palmer Dabbelt <palmerdabbelt@google.com>

diff --git a/arch/riscv/kernel/cpu_ops.c b/arch/riscv/kernel/cpu_ops.c
index c4c33bf02369..0ec22354018c 100644
--- a/arch/riscv/kernel/cpu_ops.c
+++ b/arch/riscv/kernel/cpu_ops.c
@@ -15,8 +15,8 @@
 
 const struct cpu_operations *cpu_ops[NR_CPUS] __ro_after_init;
 
-void *__cpu_up_stack_pointer[NR_CPUS];
-void *__cpu_up_task_pointer[NR_CPUS];
+void *__cpu_up_stack_pointer[NR_CPUS] __section(.data);
+void *__cpu_up_task_pointer[NR_CPUS] __section(.data);
 
 extern const struct cpu_operations cpu_ops_sbi;
 extern const struct cpu_operations cpu_ops_spinwait;

commit cfafe260137418d0265d0df3bb18dc494af2b43e
Author: Atish Patra <atish.patra@wdc.com>
Date:   Tue Mar 17 18:11:43 2020 -0700

    RISC-V: Add supported for ordered booting method using HSM
    
    Currently, all harts have to jump Linux in RISC-V. This complicates the
    multi-stage boot process as every transient stage also has to ensure all
    harts enter to that stage and jump to Linux afterwards. It also obstructs
    a clean Kexec implementation.
    
    SBI HSM extension provides alternate solutions where only a single hart
    need to boot and enter Linux. The booting hart can bring up secondary
    harts one by one afterwards.
    
    Add SBI HSM based cpu_ops that implements an ordered booting method in
    RISC-V. This change is also backward compatible with older firmware not
    implementing HSM extension. If a latest kernel is used with older
    firmware, it will continue to use the default spinning booting method.
    
    Signed-off-by: Atish Patra <atish.patra@wdc.com>
    Reviewed-by: Anup Patel <anup@brainfault.org>
    Signed-off-by: Palmer Dabbelt <palmerdabbelt@google.com>

diff --git a/arch/riscv/kernel/cpu_ops.c b/arch/riscv/kernel/cpu_ops.c
index 62705908eee5..c4c33bf02369 100644
--- a/arch/riscv/kernel/cpu_ops.c
+++ b/arch/riscv/kernel/cpu_ops.c
@@ -18,6 +18,7 @@ const struct cpu_operations *cpu_ops[NR_CPUS] __ro_after_init;
 void *__cpu_up_stack_pointer[NR_CPUS];
 void *__cpu_up_task_pointer[NR_CPUS];
 
+extern const struct cpu_operations cpu_ops_sbi;
 extern const struct cpu_operations cpu_ops_spinwait;
 
 void cpu_update_secondary_bootdata(unsigned int cpuid,
@@ -34,5 +35,12 @@ void cpu_update_secondary_bootdata(unsigned int cpuid,
 
 void __init cpu_set_ops(int cpuid)
 {
-	cpu_ops[cpuid] = &cpu_ops_spinwait;
+#if IS_ENABLED(CONFIG_RISCV_SBI)
+	if (sbi_probe_extension(SBI_EXT_HSM) > 0) {
+		if (!cpuid)
+			pr_info("SBI v0.2 HSM extension detected\n");
+		cpu_ops[cpuid] = &cpu_ops_sbi;
+	} else
+#endif
+		cpu_ops[cpuid] = &cpu_ops_spinwait;
 }

commit 2875fe0561569f82d0e63658ccf0d11ce7da8922
Author: Atish Patra <atish.patra@wdc.com>
Date:   Tue Mar 17 18:11:40 2020 -0700

    RISC-V: Add cpu_ops and modify default booting method
    
    Currently, all non-booting harts start booting after the booting hart
    updates the per-hart stack pointer. This is done in a way that, it's
    difficult to implement any other booting method without breaking the
    backward compatibility.
    
    Define a cpu_ops method that allows to introduce other booting methods
    in future. Modify the current booting method to be compatible with
    cpu_ops.
    
    Signed-off-by: Atish Patra <atish.patra@wdc.com>
    Reviewed-by: Anup Patel <anup@brainfault.org>
    Signed-off-by: Palmer Dabbelt <palmerdabbelt@google.com>

diff --git a/arch/riscv/kernel/cpu_ops.c b/arch/riscv/kernel/cpu_ops.c
new file mode 100644
index 000000000000..62705908eee5
--- /dev/null
+++ b/arch/riscv/kernel/cpu_ops.c
@@ -0,0 +1,38 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2020 Western Digital Corporation or its affiliates.
+ */
+
+#include <linux/errno.h>
+#include <linux/mm.h>
+#include <linux/of.h>
+#include <linux/string.h>
+#include <linux/sched.h>
+#include <linux/sched/task_stack.h>
+#include <asm/cpu_ops.h>
+#include <asm/sbi.h>
+#include <asm/smp.h>
+
+const struct cpu_operations *cpu_ops[NR_CPUS] __ro_after_init;
+
+void *__cpu_up_stack_pointer[NR_CPUS];
+void *__cpu_up_task_pointer[NR_CPUS];
+
+extern const struct cpu_operations cpu_ops_spinwait;
+
+void cpu_update_secondary_bootdata(unsigned int cpuid,
+				   struct task_struct *tidle)
+{
+	int hartid = cpuid_to_hartid_map(cpuid);
+
+	/* Make sure tidle is updated */
+	smp_mb();
+	WRITE_ONCE(__cpu_up_stack_pointer[hartid],
+		   task_stack_page(tidle) + THREAD_SIZE);
+	WRITE_ONCE(__cpu_up_task_pointer[hartid], tidle);
+}
+
+void __init cpu_set_ops(int cpuid)
+{
+	cpu_ops[cpuid] = &cpu_ops_spinwait;
+}
