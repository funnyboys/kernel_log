commit af33d2433b03d63ed31fcfda842f46676a5e1afc
Author: Tycho Andersen <tycho@tycho.ws>
Date:   Sat Feb 8 08:18:17 2020 -0700

    riscv: fix seccomp reject syscall code path
    
    If secure_computing() rejected a system call, we were previously setting
    the system call number to -1, to indicate to later code that the syscall
    failed. However, if something (e.g. a user notification) was sleeping, and
    received a signal, we may set a0 to -ERESTARTSYS and re-try the system call
    again.
    
    In this case, seccomp "denies" the syscall (because of the signal), and we
    would set a7 to -1, thus losing the value of the system call we want to
    restart.
    
    Instead, let's return -1 from do_syscall_trace_enter() to indicate that the
    syscall was rejected, so we don't clobber the value in case of -ERESTARTSYS
    or whatever.
    
    This commit fixes the user_notification_signal seccomp selftest on riscv to
    no longer hang. That test expects the system call to be re-issued after the
    signal, and it wasn't due to the above bug. Now that it is, everything
    works normally.
    
    Note that in the ptrace (tracer) case, the tracer can set the register
    values to whatever they want, so we still need to keep the code that
    handles out-of-bounds syscalls. However, we can drop the comment.
    
    We can also drop syscall_set_nr(), since it is no longer used anywhere, and
    the code that re-loads the value in a7 because of it.
    
    Reported in: https://lore.kernel.org/bpf/CAEn-LTp=ss0Dfv6J00=rCAy+N78U2AmhqJNjfqjr2FDpPYjxEQ@mail.gmail.com/
    
    Reported-by: David Abdurachmanov <david.abdurachmanov@gmail.com>
    Signed-off-by: Tycho Andersen <tycho@tycho.ws>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Palmer Dabbelt <palmerdabbelt@google.com>

diff --git a/arch/riscv/kernel/ptrace.c b/arch/riscv/kernel/ptrace.c
index 407464201b91..444dc7b0fd78 100644
--- a/arch/riscv/kernel/ptrace.c
+++ b/arch/riscv/kernel/ptrace.c
@@ -148,21 +148,19 @@ long arch_ptrace(struct task_struct *child, long request,
  * Allows PTRACE_SYSCALL to work.  These are called from entry.S in
  * {handle,ret_from}_syscall.
  */
-__visible void do_syscall_trace_enter(struct pt_regs *regs)
+__visible int do_syscall_trace_enter(struct pt_regs *regs)
 {
 	if (test_thread_flag(TIF_SYSCALL_TRACE))
 		if (tracehook_report_syscall_entry(regs))
-			syscall_set_nr(current, regs, -1);
+			return -1;
 
 	/*
 	 * Do the secure computing after ptrace; failures should be fast.
 	 * If this fails we might have return value in a0 from seccomp
 	 * (via SECCOMP_RET_ERRNO/TRACE).
 	 */
-	if (secure_computing() == -1) {
-		syscall_set_nr(current, regs, -1);
-		return;
-	}
+	if (secure_computing() == -1)
+		return -1;
 
 #ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS
 	if (test_thread_flag(TIF_SYSCALL_TRACEPOINT))
@@ -170,6 +168,7 @@ __visible void do_syscall_trace_enter(struct pt_regs *regs)
 #endif
 
 	audit_syscall_entry(regs->a7, regs->a0, regs->a1, regs->a2, regs->a3);
+	return 0;
 }
 
 __visible void do_syscall_trace_exit(struct pt_regs *regs)

commit b94ae8ad9fe79da61231999f347f79645b909bda
Merge: 3b805ca177a2 23b2c96fad21
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Nov 30 17:23:16 2019 -0800

    Merge tag 'seccomp-v5.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux
    
    Pull seccomp updates from Kees Cook:
     "Mostly this is implementing the new flag SECCOMP_USER_NOTIF_FLAG_CONTINUE,
      but there are cleanups as well.
    
       - implement SECCOMP_USER_NOTIF_FLAG_CONTINUE (Christian Brauner)
    
       - fixes to selftests (Christian Brauner)
    
       - remove secure_computing() argument (Christian Brauner)"
    
    * tag 'seccomp-v5.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux:
      seccomp: rework define for SECCOMP_USER_NOTIF_FLAG_CONTINUE
      seccomp: fix SECCOMP_USER_NOTIF_FLAG_CONTINUE test
      seccomp: simplify secure_computing()
      seccomp: test SECCOMP_USER_NOTIF_FLAG_CONTINUE
      seccomp: add SECCOMP_USER_NOTIF_FLAG_CONTINUE
      seccomp: avoid overflow in implicit constant conversion

commit 5340627e3fe08030988bdda46dd86cd5d5fb7517
Author: David Abdurachmanov <david.abdurachmanov@sifive.com>
Date:   Fri Oct 4 17:12:22 2019 -0700

    riscv: add support for SECCOMP and SECCOMP_FILTER
    
    This patch was extensively tested on Fedora/RISCV (applied by default on
    top of 5.2-rc7 kernel for <2 months). The patch was also tested with 5.3-rc
    on QEMU and SiFive Unleashed board.
    
    libseccomp (userspace) was rebased:
    https://github.com/seccomp/libseccomp/pull/134
    
    Fully passes libseccomp regression testing (simulation and live).
    
    There is one failing kernel selftest: global.user_notification_signal
    
    v1 -> v2:
      - return immediately if secure_computing(NULL) returns -1
      - fixed whitespace issues
      - add missing seccomp.h
      - remove patch #2 (solved now)
      - add riscv to seccomp kernel selftest
    
    Signed-off-by: David Abdurachmanov <david.abdurachmanov@sifive.com>
    Cc: keescook@chromium.org
    Cc: me@carlosedp.com
    Tested-by: Carlos de Paula <me@carlosedp.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Link: https://lore.kernel.org/linux-riscv/CAEn-LTp=ss0Dfv6J00=rCAy+N78U2AmhqJNjfqjr2FDpPYjxEQ@mail.gmail.com/
    Link: https://lore.kernel.org/linux-riscv/CAJr-aD=UnCN9E_mdVJ2H5nt=6juRSWikZnA5HxDLQxXLbsRz-w@mail.gmail.com/
    [paul.walmsley@sifive.com: cleaned up Cc: lines; fixed spelling and
     checkpatch issues; updated to apply]
    Signed-off-by: Paul Walmsley <paul.walmsley@sifive.com>

diff --git a/arch/riscv/kernel/ptrace.c b/arch/riscv/kernel/ptrace.c
index 1252113ef8b2..0f84628b9385 100644
--- a/arch/riscv/kernel/ptrace.c
+++ b/arch/riscv/kernel/ptrace.c
@@ -154,6 +154,16 @@ __visible void do_syscall_trace_enter(struct pt_regs *regs)
 		if (tracehook_report_syscall_entry(regs))
 			syscall_set_nr(current, regs, -1);
 
+	/*
+	 * Do the secure computing after ptrace; failures should be fast.
+	 * If this fails we might have return value in a0 from seccomp
+	 * (via SECCOMP_RET_ERRNO/TRACE).
+	 */
+	if (secure_computing(NULL) == -1) {
+		syscall_set_nr(current, regs, -1);
+		return;
+	}
+
 #ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS
 	if (test_thread_flag(TIF_SYSCALL_TRACEPOINT))
 		trace_sys_enter(regs, syscall_get_nr(current, regs));

commit f307307992bf63e609fe5395953048e81c9ebc54
Author: Paul Walmsley <paul.walmsley@sifive.com>
Date:   Thu Oct 17 22:20:05 2019 -0700

    riscv: for C functions called only from assembly, mark with __visible
    
    Rather than adding prototypes for C functions called only by assembly
    code, mark them as __visible.  This avoids adding prototypes that will
    never be used by the callers.  Resolves the following sparse warnings:
    
    arch/riscv/kernel/irq.c:27:29: warning: symbol 'do_IRQ' was not declared. Should it be static?
    arch/riscv/kernel/ptrace.c:151:6: warning: symbol 'do_syscall_trace_enter' was not declared. Should it be static?
    arch/riscv/kernel/ptrace.c:165:6: warning: symbol 'do_syscall_trace_exit' was not declared. Should it be static?
    arch/riscv/kernel/signal.c:295:17: warning: symbol 'do_notify_resume' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:92:1: warning: symbol 'do_trap_unknown' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:94:1: warning: symbol 'do_trap_insn_misaligned' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:96:1: warning: symbol 'do_trap_insn_fault' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:98:1: warning: symbol 'do_trap_insn_illegal' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:100:1: warning: symbol 'do_trap_load_misaligned' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:102:1: warning: symbol 'do_trap_load_fault' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:104:1: warning: symbol 'do_trap_store_misaligned' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:106:1: warning: symbol 'do_trap_store_fault' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:108:1: warning: symbol 'do_trap_ecall_u' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:110:1: warning: symbol 'do_trap_ecall_s' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:112:1: warning: symbol 'do_trap_ecall_m' was not declared. Should it be static?
    arch/riscv/kernel/traps.c:124:17: warning: symbol 'do_trap_break' was not declared. Should it be static?
    arch/riscv/kernel/smpboot.c:136:24: warning: symbol 'smp_callin' was not declared. Should it be static?
    
    Based on a suggestion from Luc Van Oostenryck.
    
    This version includes changes based on feedback from Christoph Hellwig
    <hch@lst.de>.
    
    Signed-off-by: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de> # for do_syscall_trace_*

diff --git a/arch/riscv/kernel/ptrace.c b/arch/riscv/kernel/ptrace.c
index 368751438366..1252113ef8b2 100644
--- a/arch/riscv/kernel/ptrace.c
+++ b/arch/riscv/kernel/ptrace.c
@@ -148,7 +148,7 @@ long arch_ptrace(struct task_struct *child, long request,
  * Allows PTRACE_SYSCALL to work.  These are called from entry.S in
  * {handle,ret_from}_syscall.
  */
-void do_syscall_trace_enter(struct pt_regs *regs)
+__visible void do_syscall_trace_enter(struct pt_regs *regs)
 {
 	if (test_thread_flag(TIF_SYSCALL_TRACE))
 		if (tracehook_report_syscall_entry(regs))
@@ -162,7 +162,7 @@ void do_syscall_trace_enter(struct pt_regs *regs)
 	audit_syscall_entry(regs->a7, regs->a0, regs->a1, regs->a2, regs->a3);
 }
 
-void do_syscall_trace_exit(struct pt_regs *regs)
+__visible void do_syscall_trace_exit(struct pt_regs *regs)
 {
 	audit_syscall_exit(regs);
 

commit 50acfb2b76e19f73270fef9a32726c7e18d08ec3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:18:00 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 286
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 this program is distributed
      in the hope that it will be useful but without any warranty without
      even the implied warranty of merchantability or fitness for a
      particular purpose see the gnu general public license for more
      details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 97 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141901.025053186@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/riscv/kernel/ptrace.c b/arch/riscv/kernel/ptrace.c
index 2ae5e0284f56..368751438366 100644
--- a/arch/riscv/kernel/ptrace.c
+++ b/arch/riscv/kernel/ptrace.c
@@ -1,17 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright 2010 Tilera Corporation. All Rights Reserved.
  * Copyright 2015 Regents of the University of California
  * Copyright 2017 SiFive
  *
- *   This program is free software; you can redistribute it and/or
- *   modify it under the terms of the GNU General Public License
- *   as published by the Free Software Foundation, version 2.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
  * Copied from arch/tile/kernel/ptrace.c
  */
 

commit 775800b0f1d7303d4fd8ce0e0d9eca4ff2f338f2
Author: David Abdurachmanov <david.abdurachmanov@gmail.com>
Date:   Thu Dec 6 16:26:34 2018 +0100

    riscv: fix trace_sys_exit hook
    
    Fix compilation error.
    
    Signed-off-by: David Abdurachmanov <david.abdurachmanov@gmail.com>
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/kernel/ptrace.c b/arch/riscv/kernel/ptrace.c
index a34c98b49dcb..2ae5e0284f56 100644
--- a/arch/riscv/kernel/ptrace.c
+++ b/arch/riscv/kernel/ptrace.c
@@ -179,6 +179,6 @@ void do_syscall_trace_exit(struct pt_regs *regs)
 
 #ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS
 	if (test_thread_flag(TIF_SYSCALL_TRACEPOINT))
-		trace_sys_exit(regs, regs->regs[0]);
+		trace_sys_exit(regs, regs_return_value(regs));
 #endif
 }

commit 008e901b70282183b52ee80d838d2994b2610231
Author: David Abdurachmanov <david.abdurachmanov@gmail.com>
Date:   Mon Dec 10 21:43:55 2018 +0100

    riscv: define CREATE_TRACE_POINTS in ptrace.c
    
    Define CREATE_TRACE_POINTS in order to create functions and structures
    for the trace events. This is needed if HAVE_SYSCALL_TRACEPOINTS and
    CONFIG_FTRACE_SYSCALLS are enabled, otherwise we get linking errors:
    
    [..]
      MODPOST vmlinux.o
    kernel/trace/trace_syscalls.o: In function `.L0 ':
    trace_syscalls.c:(.text+0x1152): undefined reference to `__tracepoint_sys_enter'
    trace_syscalls.c:(.text+0x126c): undefined reference to `__tracepoint_sys_enter'
    trace_syscalls.c:(.text+0x1328): undefined reference to `__tracepoint_sys_enter'
    trace_syscalls.c:(.text+0x14aa): undefined reference to `__tracepoint_sys_enter'
    trace_syscalls.c:(.text+0x1684): undefined reference to `__tracepoint_sys_exit'
    trace_syscalls.c:(.text+0x17a0): undefined reference to `__tracepoint_sys_exit'
    trace_syscalls.c:(.text+0x185c): undefined reference to `__tracepoint_sys_exit'
    trace_syscalls.c:(.text+0x19de): undefined reference to `__tracepoint_sys_exit'
    arch/riscv/kernel/ptrace.o: In function `.L0 ':
    ptrace.c:(.text+0x4dc): undefined reference to `__tracepoint_sys_enter'
    ptrace.c:(.text+0x632): undefined reference to `__tracepoint_sys_exit'
    make: *** [Makefile:1036: vmlinux] Error 1
    
    Signed-off-by: David Abdurachmanov <david.abdurachmanov@gmail.com>
    Fixes: b78002b395b4 ("riscv: add HAVE_SYSCALL_TRACEPOINTS to Kconfig")
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/kernel/ptrace.c b/arch/riscv/kernel/ptrace.c
index c1b51539c3e2..a34c98b49dcb 100644
--- a/arch/riscv/kernel/ptrace.c
+++ b/arch/riscv/kernel/ptrace.c
@@ -25,6 +25,8 @@
 #include <linux/sched.h>
 #include <linux/sched/task_stack.h>
 #include <linux/tracehook.h>
+
+#define CREATE_TRACE_POINTS
 #include <trace/events/syscalls.h>
 
 enum riscv_regset {

commit 0aea89430a4c79c65c541c947497007d33fbe002
Author: David Abdurachmanov <david.abdurachmanov@gmail.com>
Date:   Mon Oct 29 11:48:54 2018 +0100

    riscv: audit: add audit hook in do_syscall_trace_enter/exit()
    
    This patch adds auditing functions on entry to and exit from every system
    call invocation.
    
    Signed-off-by: David Abdurachmanov <david.abdurachmanov@gmail.com>
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/kernel/ptrace.c b/arch/riscv/kernel/ptrace.c
index 60f1e02eed36..c1b51539c3e2 100644
--- a/arch/riscv/kernel/ptrace.c
+++ b/arch/riscv/kernel/ptrace.c
@@ -18,6 +18,7 @@
 #include <asm/ptrace.h>
 #include <asm/syscall.h>
 #include <asm/thread_info.h>
+#include <linux/audit.h>
 #include <linux/ptrace.h>
 #include <linux/elf.h>
 #include <linux/regset.h>
@@ -163,10 +164,14 @@ void do_syscall_trace_enter(struct pt_regs *regs)
 	if (test_thread_flag(TIF_SYSCALL_TRACEPOINT))
 		trace_sys_enter(regs, syscall_get_nr(current, regs));
 #endif
+
+	audit_syscall_entry(regs->a7, regs->a0, regs->a1, regs->a2, regs->a3);
 }
 
 void do_syscall_trace_exit(struct pt_regs *regs)
 {
+	audit_syscall_exit(regs);
+
 	if (test_thread_flag(TIF_SYSCALL_TRACE))
 		tracehook_report_syscall_exit(regs, 0);
 

commit b8c8a9590e4fde82f8c3ee06a521763e6f21e9c8
Author: Jim Wilson <jimw@sifive.com>
Date:   Wed Oct 17 17:59:05 2018 -0700

    RISC-V: Add FP register ptrace support for gdb.
    
    Add a variable and a macro to describe FP registers, assuming only D is
    supported.  FP code is conditional on CONFIG_FPU.  The FP regs and FCSR
    are copied separately to avoid copying struct padding.  Tested by hand and
    with the gdb testsuite.
    
    Signed-off-by: Jim Wilson <jimw@sifive.com>
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/kernel/ptrace.c b/arch/riscv/kernel/ptrace.c
index 9f82a7e34c64..60f1e02eed36 100644
--- a/arch/riscv/kernel/ptrace.c
+++ b/arch/riscv/kernel/ptrace.c
@@ -28,6 +28,9 @@
 
 enum riscv_regset {
 	REGSET_X,
+#ifdef CONFIG_FPU
+	REGSET_F,
+#endif
 };
 
 static int riscv_gpr_get(struct task_struct *target,
@@ -54,6 +57,45 @@ static int riscv_gpr_set(struct task_struct *target,
 	return ret;
 }
 
+#ifdef CONFIG_FPU
+static int riscv_fpr_get(struct task_struct *target,
+			 const struct user_regset *regset,
+			 unsigned int pos, unsigned int count,
+			 void *kbuf, void __user *ubuf)
+{
+	int ret;
+	struct __riscv_d_ext_state *fstate = &target->thread.fstate;
+
+	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, fstate, 0,
+				  offsetof(struct __riscv_d_ext_state, fcsr));
+	if (!ret) {
+		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, fstate, 0,
+					  offsetof(struct __riscv_d_ext_state, fcsr) +
+					  sizeof(fstate->fcsr));
+	}
+
+	return ret;
+}
+
+static int riscv_fpr_set(struct task_struct *target,
+			 const struct user_regset *regset,
+			 unsigned int pos, unsigned int count,
+			 const void *kbuf, const void __user *ubuf)
+{
+	int ret;
+	struct __riscv_d_ext_state *fstate = &target->thread.fstate;
+
+	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, fstate, 0,
+				 offsetof(struct __riscv_d_ext_state, fcsr));
+	if (!ret) {
+		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, fstate, 0,
+					 offsetof(struct __riscv_d_ext_state, fcsr) +
+					 sizeof(fstate->fcsr));
+	}
+
+	return ret;
+}
+#endif
 
 static const struct user_regset riscv_user_regset[] = {
 	[REGSET_X] = {
@@ -64,6 +106,16 @@ static const struct user_regset riscv_user_regset[] = {
 		.get = &riscv_gpr_get,
 		.set = &riscv_gpr_set,
 	},
+#ifdef CONFIG_FPU
+	[REGSET_F] = {
+		.core_note_type = NT_PRFPREG,
+		.n = ELF_NFPREG,
+		.size = sizeof(elf_fpreg_t),
+		.align = sizeof(elf_fpreg_t),
+		.get = &riscv_fpr_get,
+		.set = &riscv_fpr_set,
+	},
+#endif
 };
 
 static const struct user_regset_view riscv_user_native_view = {

commit 1db9b80980d26fe95c942e0bb8bde2ca715029ad
Author: Jim Wilson <jimw@sifive.com>
Date:   Mon Jun 11 14:48:22 2018 -0700

    RISC-V: Fix PTRACE_SETREGSET bug.
    
    In riscv_gpr_set, pass regs instead of &regs to user_regset_copyin to fix
    gdb segfault.
    
    Signed-off-by: Jim Wilson <jimw@sifive.com>
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/kernel/ptrace.c b/arch/riscv/kernel/ptrace.c
index ba3e80712797..9f82a7e34c64 100644
--- a/arch/riscv/kernel/ptrace.c
+++ b/arch/riscv/kernel/ptrace.c
@@ -50,7 +50,7 @@ static int riscv_gpr_set(struct task_struct *target,
 	struct pt_regs *regs;
 
 	regs = task_pt_regs(target);
-	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &regs, 0, -1);
+	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, regs, 0, -1);
 	return ret;
 }
 

commit e2c0cdfba7f69925afc92b20cd9835d81e11a4f1
Author: Palmer Dabbelt <palmer@dabbelt.com>
Date:   Mon Jul 10 18:07:09 2017 -0700

    RISC-V: User-facing API
    
    This patch contains code that is in some way visible to the user:
    including via system calls, the VDSO, module loading and signal
    handling.  It also contains some generic code that is ABI visible.
    
    Signed-off-by: Palmer Dabbelt <palmer@dabbelt.com>

diff --git a/arch/riscv/kernel/ptrace.c b/arch/riscv/kernel/ptrace.c
new file mode 100644
index 000000000000..ba3e80712797
--- /dev/null
+++ b/arch/riscv/kernel/ptrace.c
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2010 Tilera Corporation. All Rights Reserved.
+ * Copyright 2015 Regents of the University of California
+ * Copyright 2017 SiFive
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation, version 2.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ * Copied from arch/tile/kernel/ptrace.c
+ */
+
+#include <asm/ptrace.h>
+#include <asm/syscall.h>
+#include <asm/thread_info.h>
+#include <linux/ptrace.h>
+#include <linux/elf.h>
+#include <linux/regset.h>
+#include <linux/sched.h>
+#include <linux/sched/task_stack.h>
+#include <linux/tracehook.h>
+#include <trace/events/syscalls.h>
+
+enum riscv_regset {
+	REGSET_X,
+};
+
+static int riscv_gpr_get(struct task_struct *target,
+			 const struct user_regset *regset,
+			 unsigned int pos, unsigned int count,
+			 void *kbuf, void __user *ubuf)
+{
+	struct pt_regs *regs;
+
+	regs = task_pt_regs(target);
+	return user_regset_copyout(&pos, &count, &kbuf, &ubuf, regs, 0, -1);
+}
+
+static int riscv_gpr_set(struct task_struct *target,
+			 const struct user_regset *regset,
+			 unsigned int pos, unsigned int count,
+			 const void *kbuf, const void __user *ubuf)
+{
+	int ret;
+	struct pt_regs *regs;
+
+	regs = task_pt_regs(target);
+	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &regs, 0, -1);
+	return ret;
+}
+
+
+static const struct user_regset riscv_user_regset[] = {
+	[REGSET_X] = {
+		.core_note_type = NT_PRSTATUS,
+		.n = ELF_NGREG,
+		.size = sizeof(elf_greg_t),
+		.align = sizeof(elf_greg_t),
+		.get = &riscv_gpr_get,
+		.set = &riscv_gpr_set,
+	},
+};
+
+static const struct user_regset_view riscv_user_native_view = {
+	.name = "riscv",
+	.e_machine = EM_RISCV,
+	.regsets = riscv_user_regset,
+	.n = ARRAY_SIZE(riscv_user_regset),
+};
+
+const struct user_regset_view *task_user_regset_view(struct task_struct *task)
+{
+	return &riscv_user_native_view;
+}
+
+void ptrace_disable(struct task_struct *child)
+{
+	clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
+}
+
+long arch_ptrace(struct task_struct *child, long request,
+		 unsigned long addr, unsigned long data)
+{
+	long ret = -EIO;
+
+	switch (request) {
+	default:
+		ret = ptrace_request(child, request, addr, data);
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * Allows PTRACE_SYSCALL to work.  These are called from entry.S in
+ * {handle,ret_from}_syscall.
+ */
+void do_syscall_trace_enter(struct pt_regs *regs)
+{
+	if (test_thread_flag(TIF_SYSCALL_TRACE))
+		if (tracehook_report_syscall_entry(regs))
+			syscall_set_nr(current, regs, -1);
+
+#ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS
+	if (test_thread_flag(TIF_SYSCALL_TRACEPOINT))
+		trace_sys_enter(regs, syscall_get_nr(current, regs));
+#endif
+}
+
+void do_syscall_trace_exit(struct pt_regs *regs)
+{
+	if (test_thread_flag(TIF_SYSCALL_TRACE))
+		tracehook_report_syscall_exit(regs, 0);
+
+#ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS
+	if (test_thread_flag(TIF_SYSCALL_TRACEPOINT))
+		trace_sys_exit(regs, regs->regs[0]);
+#endif
+}
