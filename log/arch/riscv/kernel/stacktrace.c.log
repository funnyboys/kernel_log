commit 9cb8f069deeed708bf19486d5893e297dc467ae0
Author: Dmitry Safonov <dima@arista.com>
Date:   Mon Jun 8 21:32:29 2020 -0700

    kernel: rename show_stack_loglvl() => show_stack()
    
    Now the last users of show_stack() got converted to use an explicit log
    level, show_stack_loglvl() can drop it's redundant suffix and become once
    again well known show_stack().
    
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Link: http://lkml.kernel.org/r/20200418201944.482088-51-dima@arista.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/riscv/kernel/stacktrace.c b/arch/riscv/kernel/stacktrace.c
index aaa64bf007f8..595342910c3f 100644
--- a/arch/riscv/kernel/stacktrace.c
+++ b/arch/riscv/kernel/stacktrace.c
@@ -105,18 +105,12 @@ static bool print_trace_address(unsigned long pc, void *arg)
 	return false;
 }
 
-void show_stack_loglvl(struct task_struct *task, unsigned long *sp,
-		       const char *loglvl)
+void show_stack(struct task_struct *task, unsigned long *sp, const char *loglvl)
 {
 	pr_cont("Call Trace:\n");
 	walk_stackframe(task, NULL, print_trace_address, (void *)loglvl);
 }
 
-void show_stack(struct task_struct *task, unsigned long *sp)
-{
-	show_stack_loglvl(task, sp, KERN_DEFAULT);
-}
-
 static bool save_wchan(unsigned long pc, void *arg)
 {
 	if (!in_sched_functions(pc)) {

commit 0b3d43657489711bf927998fde82b5cc575d9400
Author: Dmitry Safonov <dima@arista.com>
Date:   Mon Jun 8 21:31:17 2020 -0700

    riscv: add show_stack_loglvl()
    
    Currently, the log-level of show_stack() depends on a platform
    realization.  It creates situations where the headers are printed with
    lower log level or higher than the stacktrace (depending on a platform or
    user).
    
    Furthermore, it forces the logic decision from user to an architecture
    side.  In result, some users as sysrq/kdb/etc are doing tricks with
    temporary rising console_loglevel while printing their messages.  And in
    result it not only may print unwanted messages from other CPUs, but also
    omit printing at all in the unlucky case where the printk() was deferred.
    
    Introducing log-level parameter and KERN_UNSUPPRESSED [1] seems an easier
    approach than introducing more printk buffers.  Also, it will consolidate
    printings with headers.
    
    Introduce show_stack_loglvl(), that eventually will substitute
    show_stack().
    
    [1]: https://lore.kernel.org/lkml/20190528002412.1625-1-dima@arista.com/T/#u
    
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Albert Ou <aou@eecs.berkeley.edu>
    Cc: Palmer Dabbelt <palmer@dabbelt.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Link: http://lkml.kernel.org/r/20200418201944.482088-28-dima@arista.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/riscv/kernel/stacktrace.c b/arch/riscv/kernel/stacktrace.c
index 9f1ac258482f..aaa64bf007f8 100644
--- a/arch/riscv/kernel/stacktrace.c
+++ b/arch/riscv/kernel/stacktrace.c
@@ -99,16 +99,23 @@ void notrace walk_stackframe(struct task_struct *task,
 
 static bool print_trace_address(unsigned long pc, void *arg)
 {
-	print_ip_sym(KERN_DEFAULT, pc);
+	const char *loglvl = arg;
+
+	print_ip_sym(loglvl, pc);
 	return false;
 }
 
-void show_stack(struct task_struct *task, unsigned long *sp)
+void show_stack_loglvl(struct task_struct *task, unsigned long *sp,
+		       const char *loglvl)
 {
 	pr_cont("Call Trace:\n");
-	walk_stackframe(task, NULL, print_trace_address, NULL);
+	walk_stackframe(task, NULL, print_trace_address, (void *)loglvl);
 }
 
+void show_stack(struct task_struct *task, unsigned long *sp)
+{
+	show_stack_loglvl(task, sp, KERN_DEFAULT);
+}
 
 static bool save_wchan(unsigned long pc, void *arg)
 {

commit 2062a4e8ae9f486847652927aaf88e21ab8d195d
Author: Dmitry Safonov <dima@arista.com>
Date:   Mon Jun 8 21:29:56 2020 -0700

    kallsyms/printk: add loglvl to print_ip_sym()
    
    Patch series "Add log level to show_stack()", v3.
    
    Add log level argument to show_stack().
    
    Done in three stages:
    1. Introducing show_stack_loglvl() for every architecture
    2. Migrating old users with an explicit log level
    3. Renaming show_stack_loglvl() into show_stack()
    
    Justification:
    
    - It's a design mistake to move a business-logic decision into platform
      realization detail.
    
    - I have currently two patches sets that would benefit from this work:
      Removing console_loglevel jumps in sysrq driver [1] Hung task warning
      before panic [2] - suggested by Tetsuo (but he probably didn't realise
      what it would involve).
    
    - While doing (1), (2) the backtraces were adjusted to headers and other
      messages for each situation - so there won't be a situation when the
      backtrace is printed, but the headers are missing because they have
      lesser log level (or the reverse).
    
    - As the result in (2) plays with console_loglevel for kdb are removed.
    
    The least important for upstream, but maybe still worth to note that every
    company I've worked in so far had an off-list patch to print backtrace
    with the needed log level (but only for the architecture they cared
    about).  If you have other ideas how you will benefit from show_stack()
    with a log level - please, reply to this cover letter.
    
    See also discussion on v1:
    https://lore.kernel.org/linux-riscv/20191106083538.z5nlpuf64cigxigh@pathway.suse.cz/
    
    This patch (of 50):
    
    print_ip_sym() needs to have a log level parameter to comply with other
    parts being printed.  Otherwise, half of the expected backtrace would be
    printed and other may be missing with some logging level.
    
    The following callee(s) are using now the adjusted log level:
    - microblaze/unwind: the same level as headers & userspace unwind.
      Note that pr_debug()'s there are for debugging the unwinder itself.
    - nds32/traps: symbol addresses are printed with the same log level
      as backtrace headers.
    - lockdep: ip for locking issues is printed with the same log level
      as other part of the warning.
    - sched: ip where preemption was disabled is printed as error like
      the rest part of the message.
    - ftrace: bug reports are now consistent in the log level being used.
    
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Cc: Albert Ou <aou@eecs.berkeley.edu>
    Cc: Ben Segall <bsegall@google.com>
    Cc: Dietmar Eggemann <dietmar.eggemann@arm.com>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Juri Lelli <juri.lelli@redhat.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@dabbelt.com>
    Cc: Paul Burton <paulburton@kernel.org>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vincent Guittot <vincent.guittot@linaro.org>
    Cc: Will Deacon <will@kernel.org>
    Cc: Dmitry Safonov <0x7f454c46@gmail.com>
    Cc: Dmitry Safonov <dima@arista.com>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Aurelien Jacquiot <jacquiot.aurelien@gmail.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Stefan Kristiansson <stefan.kristiansson@saunalahti.fi>
    Cc: Helge Deller <deller@gmx.de>
    Cc: "James E.J. Bottomley" <James.Bottomley@HansenPartnership.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Christian Borntraeger <borntraeger@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Vasily Gorbik <gor@linux.ibm.com>
    Cc: Rich Felker <dalias@libc.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Anton Ivanov <anton.ivanov@cambridgegreys.com>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
    Cc: Daniel Thompson <daniel.thompson@linaro.org>
    Cc: Douglas Anderson <dianders@chromium.org>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Link: http://lkml.kernel.org/r/20200418201944.482088-2-dima@arista.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/riscv/kernel/stacktrace.c b/arch/riscv/kernel/stacktrace.c
index 837b9b38f825..9f1ac258482f 100644
--- a/arch/riscv/kernel/stacktrace.c
+++ b/arch/riscv/kernel/stacktrace.c
@@ -99,7 +99,7 @@ void notrace walk_stackframe(struct task_struct *task,
 
 static bool print_trace_address(unsigned long pc, void *arg)
 {
-	print_ip_sym(pc);
+	print_ip_sym(KERN_DEFAULT, pc);
 	return false;
 }
 

commit 0502bee37cdef755d63eee60236562e5605e2480
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Mon May 11 10:19:53 2020 +0800

    riscv: stacktrace: Fix undefined reference to `walk_stackframe'
    
    Drop static declaration to fix following build error if FRAME_POINTER disabled,
      riscv64-linux-ld: arch/riscv/kernel/perf_callchain.o: in function `.L0':
      perf_callchain.c:(.text+0x2b8): undefined reference to `walk_stackframe'
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Signed-off-by: Palmer Dabbelt <palmerdabbelt@google.com>

diff --git a/arch/riscv/kernel/stacktrace.c b/arch/riscv/kernel/stacktrace.c
index 6c854875ac74..837b9b38f825 100644
--- a/arch/riscv/kernel/stacktrace.c
+++ b/arch/riscv/kernel/stacktrace.c
@@ -65,7 +65,7 @@ void notrace walk_stackframe(struct task_struct *task, struct pt_regs *regs,
 
 #else /* !CONFIG_FRAME_POINTER */
 
-static void notrace walk_stackframe(struct task_struct *task,
+void notrace walk_stackframe(struct task_struct *task,
 	struct pt_regs *regs, bool (*fn)(unsigned long, void *), void *arg)
 {
 	unsigned long sp, pc;

commit af2bdf828f7963fd139ea8c5e23fd2c4e0dfca97
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Mon Apr 13 09:12:34 2020 -0700

    RISC-V: stacktrace: Declare sp_in_global outside ifdef
    
    riscv:allnoconfig and riscv:tinyconfig fail to compile.
    
    arch/riscv/kernel/stacktrace.c: In function 'walk_stackframe':
    arch/riscv/kernel/stacktrace.c:78:8: error: 'sp_in_global' undeclared
    
    sp_in_global is declared inside CONFIG_FRAME_POINTER but used outside
    of it.
    
    Fixes: 52e7c52d2ded ("RISC-V: Stop relying on GCC's register allocator's hueristics")
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Reviewed-by: Palmer Dabbelt <palmerdabbelt@google.com>
    Signed-off-by: Palmer Dabbelt <palmerdabbelt@google.com>

diff --git a/arch/riscv/kernel/stacktrace.c b/arch/riscv/kernel/stacktrace.c
index 02087fe539c6..6c854875ac74 100644
--- a/arch/riscv/kernel/stacktrace.c
+++ b/arch/riscv/kernel/stacktrace.c
@@ -12,6 +12,8 @@
 #include <linux/stacktrace.h>
 #include <linux/ftrace.h>
 
+register unsigned long sp_in_global __asm__("sp");
+
 #ifdef CONFIG_FRAME_POINTER
 
 struct stackframe {
@@ -19,8 +21,6 @@ struct stackframe {
 	unsigned long ra;
 };
 
-register unsigned long sp_in_global __asm__("sp");
-
 void notrace walk_stackframe(struct task_struct *task, struct pt_regs *regs,
 			     bool (*fn)(unsigned long, void *), void *arg)
 {

commit 52e7c52d2ded5908e6a4f8a7248e5fa6e0d6809a
Author: Palmer Dabbelt <palmerdabbelt@google.com>
Date:   Thu Feb 27 11:07:28 2020 -0800

    RISC-V: Stop relying on GCC's register allocator's hueristics
    
    GCC allows users to hint to the register allocation that a variable should be
    placed in a register by using a syntax along the lines of
    
        function(...) {
            register long in_REG __asm__("REG");
        }
    
    We've abused this a bit throughout the RISC-V port to access fixed registers
    directly as C variables.  In practice it's never going to blow up because GCC
    isn't going to allocate these registers, but it's not a well defined syntax so
    we really shouldn't be relying upon this.  Luckily there is a very similar but
    well defined syntax that allows us to still access these registers directly as
    C variables, which is to simply declare the register variables globally.  For
    fixed variables this doesn't change the ABI.
    
    LLVM disallows this ambiguous syntax, so this isn't just strictly a formatting
    change.
    
    Signed-off-by: Palmer Dabbelt <palmerdabbelt@google.com>

diff --git a/arch/riscv/kernel/stacktrace.c b/arch/riscv/kernel/stacktrace.c
index 0940681d2f68..02087fe539c6 100644
--- a/arch/riscv/kernel/stacktrace.c
+++ b/arch/riscv/kernel/stacktrace.c
@@ -19,6 +19,8 @@ struct stackframe {
 	unsigned long ra;
 };
 
+register unsigned long sp_in_global __asm__("sp");
+
 void notrace walk_stackframe(struct task_struct *task, struct pt_regs *regs,
 			     bool (*fn)(unsigned long, void *), void *arg)
 {
@@ -29,7 +31,7 @@ void notrace walk_stackframe(struct task_struct *task, struct pt_regs *regs,
 		sp = user_stack_pointer(regs);
 		pc = instruction_pointer(regs);
 	} else if (task == NULL || task == current) {
-		const register unsigned long current_sp __asm__ ("sp");
+		const register unsigned long current_sp = sp_in_global;
 		fp = (unsigned long)__builtin_frame_address(0);
 		sp = current_sp;
 		pc = (unsigned long)walk_stackframe;
@@ -73,8 +75,7 @@ static void notrace walk_stackframe(struct task_struct *task,
 		sp = user_stack_pointer(regs);
 		pc = instruction_pointer(regs);
 	} else if (task == NULL || task == current) {
-		const register unsigned long current_sp __asm__ ("sp");
-		sp = current_sp;
+		sp = sp_in_global;
 		pc = (unsigned long)walk_stackframe;
 	} else {
 		/* task blocked in __switch_to */

commit dbeb90b0c1eb86a9b963b929d3c937afb7dadfa3
Author: Mao Han <han_mao@c-sky.com>
Date:   Thu Aug 29 14:57:00 2019 +0800

    riscv: Add perf callchain support
    
    This patch add support for perf callchain sampling on riscv platforms.
    The return address of leaf function is retrieved from pt_regs as
    it is not saved in the outmost frame.
    
    Signed-off-by: Mao Han <han_mao@c-sky.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: linux-riscv <linux-riscv@lists.infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Guo Ren <guoren@kernel.org>
    Tested-by: Greentime Hu <greentime.hu@sifive.com>
    [paul.walmsley@sifive.com: fixed some 'checkpatch.pl --strict' issues;
     fixed patch description spelling]
    Signed-off-by: Paul Walmsley <paul.walmsley@sifive.com>

diff --git a/arch/riscv/kernel/stacktrace.c b/arch/riscv/kernel/stacktrace.c
index f15642715d1a..0940681d2f68 100644
--- a/arch/riscv/kernel/stacktrace.c
+++ b/arch/riscv/kernel/stacktrace.c
@@ -19,8 +19,8 @@ struct stackframe {
 	unsigned long ra;
 };
 
-static void notrace walk_stackframe(struct task_struct *task,
-	struct pt_regs *regs, bool (*fn)(unsigned long, void *), void *arg)
+void notrace walk_stackframe(struct task_struct *task, struct pt_regs *regs,
+			     bool (*fn)(unsigned long, void *), void *arg)
 {
 	unsigned long fp, sp, pc;
 

commit 1802d0beecafe581ad584634ba92f8a471d8a63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:21 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 174
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 655 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.575739538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/riscv/kernel/stacktrace.c b/arch/riscv/kernel/stacktrace.c
index e80a5e8da119..f15642715d1a 100644
--- a/arch/riscv/kernel/stacktrace.c
+++ b/arch/riscv/kernel/stacktrace.c
@@ -1,15 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2008 ARM Limited
  * Copyright (C) 2014 Regents of the University of California
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #include <linux/export.h>

commit b0bb1269b9788a35af68587505d8df90498df75f
Merge: 72cf0b07418a 8fef9900d43f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun May 19 09:56:36 2019 -0700

    Merge tag 'riscv-for-linus-5.2-mw2' of git://git.kernel.org/pub/scm/linux/kernel/git/palmer/riscv-linux
    
    Pull RISC-V updates from Palmer Dabbelt:
     "This contains an assortment of RISC-V related patches that I'd like to
      target for the 5.2 merge window. Most of the patches are cleanups, but
      there are a handful of user-visible changes:
    
       - The nosmp and nr_cpus command-line arguments are now supported,
         which work like normal.
    
       - The SBI console no longer installs itself as a preferred console,
         we rely on standard mechanisms (/chosen, command-line, hueristics)
         instead.
    
       - sfence_remove_sfence_vma{,_asid} now pass their arguments along to
         the SBI call.
    
       - Modules now support BUG().
    
       - A missing sfence.vma during boot has been added. This bug only
         manifests during boot.
    
       - The arch/riscv support for SiFive's L2 cache controller has been
         merged, which should un-block the EDAC framework work.
    
      I've only tested this on QEMU again, as I didn't have time to get
      things running on the Unleashed. The latest master from this morning
      merges in cleanly and passes the tests as well"
    
    * tag 'riscv-for-linus-5.2-mw2' of git://git.kernel.org/pub/scm/linux/kernel/git/palmer/riscv-linux: (31 commits)
      riscv: fix locking violation in page fault handler
      RISC-V: sifive_l2_cache: Add L2 cache controller driver for SiFive SoCs
      RISC-V: Add DT documentation for SiFive L2 Cache Controller
      RISC-V: Avoid using invalid intermediate translations
      riscv: Support BUG() in kernel module
      riscv: Add the support for c.ebreak check in is_valid_bugaddr()
      riscv: support trap-based WARN()
      riscv: fix sbi_remote_sfence_vma{,_asid}.
      riscv: move switch_mm to its own file
      riscv: move flush_icache_{all,mm} to cacheflush.c
      tty: Don't force RISCV SBI console as preferred console
      RISC-V: Access CSRs using CSR numbers
      RISC-V: Add interrupt related SCAUSE defines in asm/csr.h
      RISC-V: Use tabs to align macro values in asm/csr.h
      RISC-V: Fix minor checkpatch issues.
      RISC-V: Support nr_cpus command line option.
      RISC-V: Implement nosmp commandline option.
      RISC-V: Add RISC-V specific arch_match_cpu_phys_id
      riscv: vdso: drop unnecessary cc-ldoption
      riscv: call pm_power_off from machine_halt / machine_power_off
      ...

commit 6ab77af4b0ee09b58ace90aeb9b1b84f4605b859
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Apr 15 11:14:40 2019 +0200

    riscv: remove duplicate macros from ptrace.h
    
    No need to have two names for the same thing.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/kernel/stacktrace.c b/arch/riscv/kernel/stacktrace.c
index 855036c440c1..a4386a0c8f67 100644
--- a/arch/riscv/kernel/stacktrace.c
+++ b/arch/riscv/kernel/stacktrace.c
@@ -33,9 +33,9 @@ static void notrace walk_stackframe(struct task_struct *task,
 	unsigned long fp, sp, pc;
 
 	if (regs) {
-		fp = GET_FP(regs);
-		sp = GET_USP(regs);
-		pc = GET_IP(regs);
+		fp = frame_pointer(regs);
+		sp = user_stack_pointer(regs);
+		pc = instruction_pointer(regs);
 	} else if (task == NULL || task == current) {
 		const register unsigned long current_sp __asm__ ("sp");
 		fp = (unsigned long)__builtin_frame_address(0);
@@ -78,8 +78,8 @@ static void notrace walk_stackframe(struct task_struct *task,
 	unsigned long *ksp;
 
 	if (regs) {
-		sp = GET_USP(regs);
-		pc = GET_IP(regs);
+		sp = user_stack_pointer(regs);
+		pc = instruction_pointer(regs);
 	} else if (task == NULL || task == current) {
 		const register unsigned long current_sp __asm__ ("sp");
 		sp = current_sp;

commit 877425424d6c853b804e6b6a6045a5b4ea97c510
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Apr 15 11:14:39 2019 +0200

    riscv: remove unreachable !HAVE_FUNCTION_GRAPH_RET_ADDR_PTR code
    
    HAVE_FUNCTION_GRAPH_RET_ADDR_PTR is always defined for RISC-V.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/kernel/stacktrace.c b/arch/riscv/kernel/stacktrace.c
index a4b1d94371a0..855036c440c1 100644
--- a/arch/riscv/kernel/stacktrace.c
+++ b/arch/riscv/kernel/stacktrace.c
@@ -64,12 +64,8 @@ static void notrace walk_stackframe(struct task_struct *task,
 		frame = (struct stackframe *)fp - 1;
 		sp = fp;
 		fp = frame->fp;
-#ifdef HAVE_FUNCTION_GRAPH_RET_ADDR_PTR
 		pc = ftrace_graph_ret_addr(current, NULL, frame->ra,
 					   (unsigned long *)(fp - 8));
-#else
-		pc = frame->ra - 0x4;
-#endif
 	}
 }
 

commit fa9833992d5ff3c0d6e81d708bec363bce2fb54c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Apr 10 12:28:00 2019 +0200

    riscv/stacktrace: Remove the pointless ULONG_MAX marker
    
    Terminating the last trace entry with ULONG_MAX is a completely pointless
    exercise and none of the consumers can rely on it because it's
    inconsistently implemented across architectures. In fact quite some of the
    callers remove the entry and adjust stack_trace.nr_entries afterwards.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: linux-riscv@lists.infradead.org
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Albert Ou <aou@eecs.berkeley.edu>
    Link: https://lkml.kernel.org/r/20190410103644.131061192@linutronix.de

diff --git a/arch/riscv/kernel/stacktrace.c b/arch/riscv/kernel/stacktrace.c
index a4b1d94371a0..4d403274c2e8 100644
--- a/arch/riscv/kernel/stacktrace.c
+++ b/arch/riscv/kernel/stacktrace.c
@@ -169,8 +169,6 @@ static bool save_trace(unsigned long pc, void *arg)
 void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 {
 	walk_stackframe(tsk, NULL, save_trace, trace);
-	if (trace->nr_entries < trace->max_entries)
-		trace->entries[trace->nr_entries++] = ULONG_MAX;
 }
 EXPORT_SYMBOL_GPL(save_stack_trace_tsk);
 

commit b785ec129bd9498ecd6e221e45820b00c6ed4adf
Author: Alan Kao <alankao@andestech.com>
Date:   Tue Feb 13 13:13:21 2018 +0800

    riscv/ftrace: Add HAVE_FUNCTION_GRAPH_RET_ADDR_PTR support
    
    In walk_stackframe, the pc now receives the address from calling
    ftrace_graph_ret_addr instead of manual calculation.
    
    Note that the original calculation,
            pc = frame->ra - 4
    is buggy when the instruction at the return address happened to be a
    compressed inst. But since it is not a critical part of ftrace, it is
    ignored for now to ease the review process.
    
    Cc: Greentime Hu <greentime@andestech.com>
    Signed-off-by: Alan Kao <alankao@andestech.com>
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>

diff --git a/arch/riscv/kernel/stacktrace.c b/arch/riscv/kernel/stacktrace.c
index 559aae781154..a4b1d94371a0 100644
--- a/arch/riscv/kernel/stacktrace.c
+++ b/arch/riscv/kernel/stacktrace.c
@@ -18,6 +18,7 @@
 #include <linux/sched/debug.h>
 #include <linux/sched/task_stack.h>
 #include <linux/stacktrace.h>
+#include <linux/ftrace.h>
 
 #ifdef CONFIG_FRAME_POINTER
 
@@ -63,7 +64,12 @@ static void notrace walk_stackframe(struct task_struct *task,
 		frame = (struct stackframe *)fp - 1;
 		sp = fp;
 		fp = frame->fp;
+#ifdef HAVE_FUNCTION_GRAPH_RET_ADDR_PTR
+		pc = ftrace_graph_ret_addr(current, NULL, frame->ra,
+					   (unsigned long *)(fp - 8));
+#else
 		pc = frame->ra - 0x4;
+#endif
 	}
 }
 

commit 5d8544e2d0075a5f3c9a2cf27152354d54360da1
Author: Palmer Dabbelt <palmer@dabbelt.com>
Date:   Mon Jul 10 18:03:19 2017 -0700

    RISC-V: Generic library routines and assembly
    
    This patch contains code that is more specific to the RISC-V ISA than it
    is to Linux.  It contains string and math operations, C wrappers for
    various assembly instructions, stack walking code, and uaccess.
    
    Signed-off-by: Palmer Dabbelt <palmer@dabbelt.com>

diff --git a/arch/riscv/kernel/stacktrace.c b/arch/riscv/kernel/stacktrace.c
new file mode 100644
index 000000000000..559aae781154
--- /dev/null
+++ b/arch/riscv/kernel/stacktrace.c
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2008 ARM Limited
+ * Copyright (C) 2014 Regents of the University of California
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/export.h>
+#include <linux/kallsyms.h>
+#include <linux/sched.h>
+#include <linux/sched/debug.h>
+#include <linux/sched/task_stack.h>
+#include <linux/stacktrace.h>
+
+#ifdef CONFIG_FRAME_POINTER
+
+struct stackframe {
+	unsigned long fp;
+	unsigned long ra;
+};
+
+static void notrace walk_stackframe(struct task_struct *task,
+	struct pt_regs *regs, bool (*fn)(unsigned long, void *), void *arg)
+{
+	unsigned long fp, sp, pc;
+
+	if (regs) {
+		fp = GET_FP(regs);
+		sp = GET_USP(regs);
+		pc = GET_IP(regs);
+	} else if (task == NULL || task == current) {
+		const register unsigned long current_sp __asm__ ("sp");
+		fp = (unsigned long)__builtin_frame_address(0);
+		sp = current_sp;
+		pc = (unsigned long)walk_stackframe;
+	} else {
+		/* task blocked in __switch_to */
+		fp = task->thread.s[0];
+		sp = task->thread.sp;
+		pc = task->thread.ra;
+	}
+
+	for (;;) {
+		unsigned long low, high;
+		struct stackframe *frame;
+
+		if (unlikely(!__kernel_text_address(pc) || fn(pc, arg)))
+			break;
+
+		/* Validate frame pointer */
+		low = sp + sizeof(struct stackframe);
+		high = ALIGN(sp, THREAD_SIZE);
+		if (unlikely(fp < low || fp > high || fp & 0x7))
+			break;
+		/* Unwind stack frame */
+		frame = (struct stackframe *)fp - 1;
+		sp = fp;
+		fp = frame->fp;
+		pc = frame->ra - 0x4;
+	}
+}
+
+#else /* !CONFIG_FRAME_POINTER */
+
+static void notrace walk_stackframe(struct task_struct *task,
+	struct pt_regs *regs, bool (*fn)(unsigned long, void *), void *arg)
+{
+	unsigned long sp, pc;
+	unsigned long *ksp;
+
+	if (regs) {
+		sp = GET_USP(regs);
+		pc = GET_IP(regs);
+	} else if (task == NULL || task == current) {
+		const register unsigned long current_sp __asm__ ("sp");
+		sp = current_sp;
+		pc = (unsigned long)walk_stackframe;
+	} else {
+		/* task blocked in __switch_to */
+		sp = task->thread.sp;
+		pc = task->thread.ra;
+	}
+
+	if (unlikely(sp & 0x7))
+		return;
+
+	ksp = (unsigned long *)sp;
+	while (!kstack_end(ksp)) {
+		if (__kernel_text_address(pc) && unlikely(fn(pc, arg)))
+			break;
+		pc = (*ksp++) - 0x4;
+	}
+}
+
+#endif /* CONFIG_FRAME_POINTER */
+
+
+static bool print_trace_address(unsigned long pc, void *arg)
+{
+	print_ip_sym(pc);
+	return false;
+}
+
+void show_stack(struct task_struct *task, unsigned long *sp)
+{
+	pr_cont("Call Trace:\n");
+	walk_stackframe(task, NULL, print_trace_address, NULL);
+}
+
+
+static bool save_wchan(unsigned long pc, void *arg)
+{
+	if (!in_sched_functions(pc)) {
+		unsigned long *p = arg;
+		*p = pc;
+		return true;
+	}
+	return false;
+}
+
+unsigned long get_wchan(struct task_struct *task)
+{
+	unsigned long pc = 0;
+
+	if (likely(task && task != current && task->state != TASK_RUNNING))
+		walk_stackframe(task, NULL, save_wchan, &pc);
+	return pc;
+}
+
+
+#ifdef CONFIG_STACKTRACE
+
+static bool __save_trace(unsigned long pc, void *arg, bool nosched)
+{
+	struct stack_trace *trace = arg;
+
+	if (unlikely(nosched && in_sched_functions(pc)))
+		return false;
+	if (unlikely(trace->skip > 0)) {
+		trace->skip--;
+		return false;
+	}
+
+	trace->entries[trace->nr_entries++] = pc;
+	return (trace->nr_entries >= trace->max_entries);
+}
+
+static bool save_trace(unsigned long pc, void *arg)
+{
+	return __save_trace(pc, arg, false);
+}
+
+/*
+ * Save stack-backtrace addresses into a stack_trace buffer.
+ */
+void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
+{
+	walk_stackframe(tsk, NULL, save_trace, trace);
+	if (trace->nr_entries < trace->max_entries)
+		trace->entries[trace->nr_entries++] = ULONG_MAX;
+}
+EXPORT_SYMBOL_GPL(save_stack_trace_tsk);
+
+void save_stack_trace(struct stack_trace *trace)
+{
+	save_stack_trace_tsk(NULL, trace);
+}
+EXPORT_SYMBOL_GPL(save_stack_trace);
+
+#endif /* CONFIG_STACKTRACE */
