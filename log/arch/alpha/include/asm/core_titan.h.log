commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/alpha/include/asm/core_titan.h b/arch/alpha/include/asm/core_titan.h
index 8cf79d1219e1..dcc02682c1e1 100644
--- a/arch/alpha/include/asm/core_titan.h
+++ b/arch/alpha/include/asm/core_titan.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __ALPHA_TITAN__H__
 #define __ALPHA_TITAN__H__
 

commit 5286944d75cbe21dd21b0d57335cc6206622b62a
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Thu Mar 18 22:35:28 2010 -0400

    alpha: fix compile errors in dma-mapping-common.h
    
    The commit c186caca3dbe7f44da624cb4f9d78e1b1dfb13b8 leads to the
    following errors with CONFIG_ALPHA_{TSUNAMI, TITAN, RAWHIDE, MARVEL}:
    /home/fujita/git/linux-2.6/include/asm-generic/dma-mapping-common.h: In
    function `dma_map_sg_attrs':
    /home/fujita/git/linux-2.6/include/asm-generic/dma-mapping-common.h:49:
    error: implicit declaration of function `for_each_sg'
    /home/fujita/git/linux-2.6/include/asm-generic/dma-mapping-common.h:50:
    error: syntax error before "kmemcheck_mark_initialized"
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Reported-by: Michael Cree <mcree@orcon.net.nz>
    Signed-off-by: Matt Turner <mattst88@gmail.com>

diff --git a/arch/alpha/include/asm/core_titan.h b/arch/alpha/include/asm/core_titan.h
index a17f6f33b68e..8cf79d1219e1 100644
--- a/arch/alpha/include/asm/core_titan.h
+++ b/arch/alpha/include/asm/core_titan.h
@@ -2,7 +2,6 @@
 #define __ALPHA_TITAN__H__
 
 #include <linux/types.h>
-#include <linux/pci.h>
 #include <asm/compiler.h>
 
 /*

commit 024b246ed24492d6c2ee14c34d742b137fce1b94
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Aug 15 09:19:40 2008 -0700

    alpha: move include/asm-alpha to arch/alpha/include/asm
    
    Sam Ravnborg did the build-test that the direct header file move works,
    I'm just committing it.
    
    This is a pure move:
    
            mkdir arch/alpha/include
            git mv include/asm-alpha arch/alpha/include/asm
    
    with no other changes.
    
    Requested-and-tested-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/alpha/include/asm/core_titan.h b/arch/alpha/include/asm/core_titan.h
new file mode 100644
index 000000000000..a17f6f33b68e
--- /dev/null
+++ b/arch/alpha/include/asm/core_titan.h
@@ -0,0 +1,410 @@
+#ifndef __ALPHA_TITAN__H__
+#define __ALPHA_TITAN__H__
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <asm/compiler.h>
+
+/*
+ * TITAN is the internal names for a core logic chipset which provides
+ * memory controller and PCI/AGP access for 21264 based systems.
+ *
+ * This file is based on:
+ *
+ * Titan Chipset Engineering Specification
+ * Revision 0.12
+ * 13 July 1999
+ *
+ */
+
+/* XXX: Do we need to conditionalize on this?  */
+#ifdef USE_48_BIT_KSEG
+#define TI_BIAS 0x80000000000UL
+#else
+#define TI_BIAS 0x10000000000UL
+#endif
+
+/*
+ * CChip, DChip, and PChip registers
+ */
+
+typedef struct {
+	volatile unsigned long csr __attribute__((aligned(64)));
+} titan_64;
+
+typedef struct {
+	titan_64	csc;
+	titan_64	mtr;
+	titan_64	misc;
+	titan_64	mpd;
+	titan_64	aar0;
+	titan_64	aar1;
+	titan_64	aar2;
+	titan_64	aar3;
+	titan_64	dim0;
+	titan_64	dim1;
+	titan_64	dir0;
+	titan_64	dir1;
+	titan_64	drir;
+	titan_64	prben;
+	titan_64	iic0;
+	titan_64	iic1;
+	titan_64	mpr0;
+	titan_64	mpr1;
+	titan_64	mpr2;
+	titan_64	mpr3;
+	titan_64	rsvd[2];
+	titan_64	ttr;
+	titan_64	tdr;
+	titan_64	dim2;
+	titan_64	dim3;
+	titan_64	dir2;
+	titan_64	dir3;
+	titan_64	iic2;
+	titan_64	iic3;
+	titan_64	pwr;
+	titan_64	reserved[17];
+	titan_64	cmonctla;
+	titan_64	cmonctlb;
+	titan_64	cmoncnt01;
+	titan_64	cmoncnt23;
+	titan_64	cpen;
+} titan_cchip;
+
+typedef struct {
+	titan_64	dsc;
+	titan_64	str;
+	titan_64	drev;
+	titan_64	dsc2;
+} titan_dchip;
+
+typedef struct {
+	titan_64	wsba[4];
+	titan_64	wsm[4];
+	titan_64	tba[4];
+	titan_64	pctl;
+	titan_64	plat;
+	titan_64	reserved0[2];
+	union {
+		struct {
+			titan_64	serror;
+			titan_64	serren;
+			titan_64	serrset;
+			titan_64	reserved0;
+			titan_64	gperror;
+			titan_64	gperren;
+			titan_64	gperrset;
+			titan_64	reserved1;
+			titan_64	gtlbiv;
+			titan_64	gtlbia;
+			titan_64	reserved2[2];
+			titan_64	sctl;
+			titan_64	reserved3[3];
+		} g;
+		struct {
+			titan_64	agperror;
+			titan_64	agperren;
+			titan_64	agperrset;
+			titan_64	agplastwr;
+			titan_64	aperror;
+			titan_64	aperren;
+			titan_64	aperrset;
+			titan_64	reserved0;
+			titan_64	atlbiv;
+			titan_64	atlbia;
+			titan_64	reserved1[6];
+		} a;
+	} port_specific;
+	titan_64	sprst;
+	titan_64	reserved1[31];
+} titan_pachip_port;
+
+typedef struct {
+	titan_pachip_port	g_port;
+	titan_pachip_port	a_port;
+} titan_pachip;
+
+#define TITAN_cchip	((titan_cchip  *)(IDENT_ADDR+TI_BIAS+0x1A0000000UL))
+#define TITAN_dchip    	((titan_dchip  *)(IDENT_ADDR+TI_BIAS+0x1B0000800UL))
+#define TITAN_pachip0 	((titan_pachip *)(IDENT_ADDR+TI_BIAS+0x180000000UL))
+#define TITAN_pachip1 	((titan_pachip *)(IDENT_ADDR+TI_BIAS+0x380000000UL))
+extern unsigned TITAN_agp;
+extern int TITAN_bootcpu;
+
+/*
+ * TITAN PA-chip Window Space Base Address register.
+ * (WSBA[0-2])
+ */
+#define wsba_m_ena 0x1                
+#define wsba_m_sg 0x2
+#define wsba_m_addr 0xFFF00000  
+#define wmask_k_sz1gb 0x3FF00000                   
+union TPAchipWSBA {
+	struct  {
+		unsigned wsba_v_ena : 1;
+		unsigned wsba_v_sg : 1;
+		unsigned wsba_v_rsvd1 : 18;
+		unsigned wsba_v_addr : 12;
+		unsigned wsba_v_rsvd2 : 32;
+        } wsba_r_bits;
+	int wsba_q_whole [2];
+};
+
+/*
+ * TITAN PA-chip Control Register
+ * This definition covers both the G-Port GPCTL and the A-PORT APCTL.
+ * Bits <51:0> are the same in both cases. APCTL<63:52> are only 
+ * applicable to AGP.
+ */
+#define pctl_m_fbtb 			0x00000001
+#define pctl_m_thdis 			0x00000002
+#define pctl_m_chaindis 		0x00000004
+#define pctl_m_tgtlat 			0x00000018
+#define pctl_m_hole  	  		0x00000020
+#define pctl_m_mwin 	  		0x00000040
+#define pctl_m_arbena 	  		0x00000080
+#define pctl_m_prigrp 	  		0x0000FF00
+#define pctl_m_ppri 	  		0x00010000
+#define pctl_m_pcispd66  		0x00020000
+#define pctl_m_cngstlt	  		0x003C0000
+#define pctl_m_ptpdesten 		0x3FC00000
+#define pctl_m_dpcen			0x40000000
+#define pctl_m_apcen		0x0000000080000000UL
+#define pctl_m_dcrtv		0x0000000300000000UL
+#define pctl_m_en_stepping	0x0000000400000000UL
+#define apctl_m_rsvd1		0x000FFFF800000000UL
+#define apctl_m_agp_rate	0x0030000000000000UL
+#define apctl_m_agp_sba_en	0x0040000000000000UL
+#define apctl_m_agp_en		0x0080000000000000UL
+#define apctl_m_rsvd2		0x0100000000000000UL
+#define apctl_m_agp_present	0x0200000000000000UL
+#define apctl_agp_hp_rd		0x1C00000000000000UL
+#define apctl_agp_lp_rd		0xE000000000000000UL
+#define gpctl_m_rsvd		0xFFFFFFF800000000UL
+union TPAchipPCTL {
+	struct {
+		unsigned pctl_v_fbtb : 1;		/* A/G [0]     */
+		unsigned pctl_v_thdis : 1;		/* A/G [1]     */
+		unsigned pctl_v_chaindis : 1;		/* A/G [2]     */
+		unsigned pctl_v_tgtlat : 2;		/* A/G [4:3]   */
+		unsigned pctl_v_hole : 1;		/* A/G [5]     */
+		unsigned pctl_v_mwin : 1;		/* A/G [6]     */
+		unsigned pctl_v_arbena : 1;		/* A/G [7]     */
+		unsigned pctl_v_prigrp : 8;		/* A/G [15:8]  */
+		unsigned pctl_v_ppri : 1;		/* A/G [16]    */
+		unsigned pctl_v_pcispd66 : 1;		/* A/G [17]    */
+		unsigned pctl_v_cngstlt : 4;		/* A/G [21:18] */
+		unsigned pctl_v_ptpdesten : 8;		/* A/G [29:22] */
+		unsigned pctl_v_dpcen : 1;		/* A/G [30]    */
+		unsigned pctl_v_apcen : 1;		/* A/G [31]    */
+		unsigned pctl_v_dcrtv : 2;		/* A/G [33:32] */
+		unsigned pctl_v_en_stepping :1;		/* A/G [34]    */
+		unsigned apctl_v_rsvd1 : 17;		/* A   [51:35] */
+		unsigned apctl_v_agp_rate : 2;		/* A   [53:52] */
+		unsigned apctl_v_agp_sba_en : 1;	/* A   [54]    */
+		unsigned apctl_v_agp_en : 1;		/* A   [55]    */
+		unsigned apctl_v_rsvd2 : 1;		/* A   [56]    */
+		unsigned apctl_v_agp_present : 1;	/* A   [57]    */
+		unsigned apctl_v_agp_hp_rd : 3;		/* A   [60:58] */
+		unsigned apctl_v_agp_lp_rd : 3;		/* A   [63:61] */
+	} pctl_r_bits;
+	unsigned int pctl_l_whole [2];
+	unsigned long pctl_q_whole;
+};
+
+/*
+ * SERROR / SERREN / SERRSET
+ */
+union TPAchipSERR {
+	struct {
+		unsigned serr_v_lost_uecc : 1;		/* [0]		*/
+		unsigned serr_v_uecc : 1;		/* [1]  	*/
+		unsigned serr_v_cre : 1;		/* [2]		*/
+		unsigned serr_v_nxio : 1;		/* [3]		*/
+		unsigned serr_v_lost_cre : 1;		/* [4]		*/
+		unsigned serr_v_rsvd0 : 10;		/* [14:5]	*/
+		unsigned serr_v_addr : 32;		/* [46:15]	*/
+		unsigned serr_v_rsvd1 : 5;		/* [51:47]	*/
+		unsigned serr_v_source : 2;		/* [53:52]	*/
+		unsigned serr_v_cmd : 2;		/* [55:54]	*/
+		unsigned serr_v_syn : 8;		/* [63:56]	*/
+	} serr_r_bits;
+	unsigned int serr_l_whole[2];
+	unsigned long serr_q_whole;
+};
+
+/*
+ * GPERROR / APERROR / GPERREN / APERREN / GPERRSET / APERRSET
+ */
+union TPAchipPERR {
+	struct {
+		unsigned long perr_v_lost : 1;	     	/* [0]		*/
+		unsigned long perr_v_serr : 1;		/* [1]		*/
+		unsigned long perr_v_perr : 1;		/* [2]		*/
+		unsigned long perr_v_dcrto : 1;		/* [3]		*/
+		unsigned long perr_v_sge : 1;		/* [4]		*/
+		unsigned long perr_v_ape : 1;		/* [5]		*/
+		unsigned long perr_v_ta : 1;		/* [6]		*/
+		unsigned long perr_v_dpe : 1;		/* [7]		*/
+		unsigned long perr_v_nds : 1;		/* [8]		*/
+		unsigned long perr_v_iptpr : 1;		/* [9]		*/
+		unsigned long perr_v_iptpw : 1;		/* [10] 	*/
+		unsigned long perr_v_rsvd0 : 3;		/* [13:11]	*/
+		unsigned long perr_v_addr : 33;		/* [46:14]	*/
+		unsigned long perr_v_dac : 1;		/* [47]		*/
+		unsigned long perr_v_mwin : 1;		/* [48]		*/
+		unsigned long perr_v_rsvd1 : 3;		/* [51:49]	*/
+		unsigned long perr_v_cmd : 4;		/* [55:52]	*/
+		unsigned long perr_v_rsvd2 : 8;		/* [63:56]	*/
+	} perr_r_bits;
+	unsigned int perr_l_whole[2];
+	unsigned long perr_q_whole;
+};
+
+/*
+ * AGPERROR / AGPERREN / AGPERRSET
+ */
+union TPAchipAGPERR {
+	struct {
+		unsigned agperr_v_lost : 1;		/* [0]		*/
+		unsigned agperr_v_lpqfull : 1;		/* [1]		*/
+		unsigned apgerr_v_hpqfull : 1;		/* [2]		*/
+		unsigned agperr_v_rescmd : 1;		/* [3]		*/
+		unsigned agperr_v_ipte : 1;		/* [4]		*/
+		unsigned agperr_v_ptp :	1;      	/* [5]		*/
+		unsigned agperr_v_nowindow : 1;		/* [6]		*/
+		unsigned agperr_v_rsvd0 : 8;		/* [14:7]	*/
+		unsigned agperr_v_addr : 32;		/* [46:15]	*/
+		unsigned agperr_v_rsvd1 : 1;		/* [47]		*/
+		unsigned agperr_v_dac : 1;		/* [48]		*/
+		unsigned agperr_v_mwin : 1;		/* [49]		*/
+		unsigned agperr_v_cmd : 3;		/* [52:50]	*/
+		unsigned agperr_v_length : 6;		/* [58:53]	*/
+		unsigned agperr_v_fence : 1;		/* [59]		*/
+		unsigned agperr_v_rsvd2 : 4;		/* [63:60]	*/
+	} agperr_r_bits;
+	unsigned int agperr_l_whole[2];
+	unsigned long agperr_q_whole;
+};
+/*
+ * Memory spaces:
+ * Hose numbers are assigned as follows:
+ *		0 - pachip 0 / G Port
+ *		1 - pachip 1 / G Port
+ * 		2 - pachip 0 / A Port
+ *      	3 - pachip 1 / A Port
+ */
+#define TITAN_HOSE_SHIFT       (33) 
+#define TITAN_HOSE(h)		(((unsigned long)(h)) << TITAN_HOSE_SHIFT)
+#define TITAN_BASE		(IDENT_ADDR + TI_BIAS)
+#define TITAN_MEM(h)	     	(TITAN_BASE+TITAN_HOSE(h)+0x000000000UL)
+#define _TITAN_IACK_SC(h)    	(TITAN_BASE+TITAN_HOSE(h)+0x1F8000000UL)
+#define TITAN_IO(h)	     	(TITAN_BASE+TITAN_HOSE(h)+0x1FC000000UL)
+#define TITAN_CONF(h)	     	(TITAN_BASE+TITAN_HOSE(h)+0x1FE000000UL)
+
+#define TITAN_HOSE_MASK		TITAN_HOSE(3)
+#define TITAN_IACK_SC	     	_TITAN_IACK_SC(0) /* hack! */
+
+/* 
+ * The canonical non-remaped I/O and MEM addresses have these values
+ * subtracted out.  This is arranged so that folks manipulating ISA
+ * devices can use their familiar numbers and have them map to bus 0.
+ */
+
+#define TITAN_IO_BIAS		TITAN_IO(0)
+#define TITAN_MEM_BIAS		TITAN_MEM(0)
+
+/* The IO address space is larger than 0xffff */
+#define TITAN_IO_SPACE		(TITAN_CONF(0) - TITAN_IO(0))
+
+/* TIG Space */
+#define TITAN_TIG_SPACE		(TITAN_BASE + 0x100000000UL)
+
+/* Offset between ram physical addresses and pci64 DAC bus addresses.  */
+/* ??? Just a guess.  Ought to confirm it hasn't been moved.  */
+#define TITAN_DAC_OFFSET	(1UL << 40)
+
+/*
+ * Data structure for handling TITAN machine checks:
+ */
+#define SCB_Q_SYSERR	0x620
+#define SCB_Q_PROCERR	0x630
+#define SCB_Q_SYSMCHK	0x660
+#define SCB_Q_PROCMCHK	0x670
+#define SCB_Q_SYSEVENT	0x680	/* environmental / system management */
+struct el_TITAN_sysdata_mcheck {
+	u64 summary;	/* 0x00 */
+	u64 c_dirx;	/* 0x08 */
+	u64 c_misc;	/* 0x10 */
+	u64 p0_serror;	/* 0x18 */
+	u64 p0_gperror; /* 0x20 */
+	u64 p0_aperror; /* 0x28 */
+	u64 p0_agperror;/* 0x30 */
+	u64 p1_serror;	/* 0x38 */
+	u64 p1_gperror; /* 0x40 */
+	u64 p1_aperror; /* 0x48 */
+	u64 p1_agperror;/* 0x50 */
+};
+
+/*
+ * System area for a privateer 680 environmental/system management mcheck 
+ */
+struct el_PRIVATEER_envdata_mcheck {
+	u64 summary;	/* 0x00 */
+	u64 c_dirx;	/* 0x08 */
+	u64 smir;	/* 0x10 */
+	u64 cpuir;	/* 0x18 */
+	u64 psir;	/* 0x20 */
+	u64 fault;	/* 0x28 */
+	u64 sys_doors;	/* 0x30 */
+	u64 temp_warn;	/* 0x38 */
+	u64 fan_ctrl;	/* 0x40 */
+	u64 code;	/* 0x48 */
+	u64 reserved;	/* 0x50 */
+};
+
+#ifdef __KERNEL__
+
+#ifndef __EXTERN_INLINE
+#define __EXTERN_INLINE extern inline
+#define __IO_EXTERN_INLINE
+#endif
+
+/*
+ * I/O functions:
+ *
+ * TITAN, a 21??? PCI/memory support chipset for the EV6 (21264)
+ * can only use linear accesses to get at PCI/AGP memory and I/O spaces.
+ */
+
+/*
+ * Memory functions.  all accesses are done through linear space.
+ */
+extern void __iomem *titan_ioportmap(unsigned long addr);
+extern void __iomem *titan_ioremap(unsigned long addr, unsigned long size);
+extern void titan_iounmap(volatile void __iomem *addr);
+
+__EXTERN_INLINE int titan_is_ioaddr(unsigned long addr)
+{
+	return addr >= TITAN_BASE;
+}
+
+extern int titan_is_mmio(const volatile void __iomem *addr);
+
+#undef __IO_PREFIX
+#define __IO_PREFIX		titan
+#define titan_trivial_rw_bw	1
+#define titan_trivial_rw_lq	1
+#define titan_trivial_io_bw	1
+#define titan_trivial_io_lq	1
+#define titan_trivial_iounmap	0
+#include <asm/io_trivial.h>
+
+#ifdef __IO_EXTERN_INLINE
+#undef __EXTERN_INLINE
+#undef __IO_EXTERN_INLINE
+#endif
+
+#endif /* __KERNEL__ */
+
+#endif /* __ALPHA_TITAN__H__ */
