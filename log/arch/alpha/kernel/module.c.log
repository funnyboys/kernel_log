commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/alpha/kernel/module.c b/arch/alpha/kernel/module.c
index 47632fa8c24e..ac110ae8f978 100644
--- a/arch/alpha/kernel/module.c
+++ b/arch/alpha/kernel/module.c
@@ -1,19 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*  Kernel module help for Alpha.
     Copyright (C) 2002 Richard Henderson.
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 #include <linux/moduleloader.h>
 #include <linux/elf.h>

commit 4f61e0781b701f5eb4f0e186d361c4104659001e
Author: Michael Cree <mcree@orcon.net.nz>
Date:   Sat Jun 24 13:37:02 2017 +1200

    alpha: support R_ALPHA_REFLONG relocations for module loading
    
    Since commit 71810db27c1c853b33 (modversions: treat symbol CRCs
    as 32 bit quantities) R_ALPHA_REFLONG relocations can be required
    to load modules. This implements it.
    
    Tested-by: Bob Tracy <rct@gherkin.frus.com>
    Reviewed-by: Richard Henderson <rth@twiddle.net>
    Signed-off-by: Michael Cree <mcree@orcon.net.nz>
    Signed-off-by: Matt Turner <mattst88@gmail.com>

diff --git a/arch/alpha/kernel/module.c b/arch/alpha/kernel/module.c
index 936bc8f89a67..47632fa8c24e 100644
--- a/arch/alpha/kernel/module.c
+++ b/arch/alpha/kernel/module.c
@@ -181,6 +181,9 @@ apply_relocate_add(Elf64_Shdr *sechdrs, const char *strtab,
 		switch (r_type) {
 		case R_ALPHA_NONE:
 			break;
+		case R_ALPHA_REFLONG:
+			*(u32 *)location = value;
+			break;
 		case R_ALPHA_REFQUAD:
 			/* BUG() can produce misaligned relocations. */
 			((u32 *)location)[0] = value;

commit 7523e4dc5057e157212b4741abd6256e03404cf1
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Nov 26 09:44:08 2015 +1030

    module: use a structure to encapsulate layout.
    
    Makes it easier to handle init vs core cleanly, though the change is
    fairly invasive across random architectures.
    
    It simplifies the rbtree code immediately, however, while keeping the
    core data together in the same cachline (now iff the rbtree code is
    enabled).
    
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Reviewed-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/arch/alpha/kernel/module.c b/arch/alpha/kernel/module.c
index 2fd00b7077e4..936bc8f89a67 100644
--- a/arch/alpha/kernel/module.c
+++ b/arch/alpha/kernel/module.c
@@ -160,7 +160,7 @@ apply_relocate_add(Elf64_Shdr *sechdrs, const char *strtab,
 
 	/* The small sections were sorted to the end of the segment.
 	   The following should definitely cover them.  */
-	gp = (u64)me->module_core + me->core_size - 0x8000;
+	gp = (u64)me->core_layout.base + me->core_layout.size - 0x8000;
 	got = sechdrs[me->arch.gotsecindex].sh_addr;
 
 	for (i = 0; i < n; i++) {

commit 66574cc05438dd0907029075d7e6ec5ac0036fbc
Author: Jonas Bonn <jonas@southpole.se>
Date:   Thu Jun 30 21:22:12 2011 +0200

    modules: make arch's use default loader hooks
    
    This patch removes all the module loader hook implementations in the
    architecture specific code where the functionality is the same as that
    now provided by the recently added default hooks.
    
    Signed-off-by: Jonas Bonn <jonas@southpole.se>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Tested-by: Michal Simek <monstr@monstr.eu>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/arch/alpha/kernel/module.c b/arch/alpha/kernel/module.c
index ebc3c894b5a2..2fd00b7077e4 100644
--- a/arch/alpha/kernel/module.c
+++ b/arch/alpha/kernel/module.c
@@ -29,20 +29,6 @@
 #define DEBUGP(fmt...)
 #endif
 
-void *
-module_alloc(unsigned long size)
-{
-	if (size == 0)
-		return NULL;
-	return vmalloc(size);
-}
-
-void
-module_free(struct module *mod, void *module_region)
-{
-	vfree(module_region);
-}
-
 /* Allocate the GOT at the end of the core sections.  */
 
 struct got_entry {
@@ -155,14 +141,6 @@ module_frob_arch_sections(Elf64_Ehdr *hdr, Elf64_Shdr *sechdrs,
 	return 0;
 }
 
-int
-apply_relocate(Elf64_Shdr *sechdrs, const char *strtab, unsigned int symindex,
-	       unsigned int relsec, struct module *me)
-{
-	printk(KERN_ERR "module %s: REL relocation unsupported\n", me->name);
-	return -ENOEXEC;
-}
-
 int
 apply_relocate_add(Elf64_Shdr *sechdrs, const char *strtab,
 		   unsigned int symindex, unsigned int relsec,
@@ -302,15 +280,3 @@ apply_relocate_add(Elf64_Shdr *sechdrs, const char *strtab,
 
 	return 0;
 }
-
-int
-module_finalize(const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs,
-		struct module *me)
-{
-	return 0;
-}
-
-void
-module_arch_cleanup(struct module *mod)
-{
-}

commit b901d40c970e6db319fe1f8d84db2b9684b6c9bf
Author: Jim Meyering <jim@meyering.net>
Date:   Mon Apr 28 02:13:44 2008 -0700

    alpha: handle kcalloc failure
    
    arch/alpha/kernel/module.c (module_frob_arch_sections): Handle kcalloc failure.
    
    Signed-off-by: Jim Meyering <meyering@redhat.com>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/alpha/kernel/module.c b/arch/alpha/kernel/module.c
index 026ba9af6d6a..ebc3c894b5a2 100644
--- a/arch/alpha/kernel/module.c
+++ b/arch/alpha/kernel/module.c
@@ -120,6 +120,12 @@ module_frob_arch_sections(Elf64_Ehdr *hdr, Elf64_Shdr *sechdrs,
 
 	nsyms = symtab->sh_size / sizeof(Elf64_Sym);
 	chains = kcalloc(nsyms, sizeof(struct got_entry), GFP_KERNEL);
+	if (!chains) {
+		printk(KERN_ERR
+		       "module %s: no memory for symbol chain buffer\n",
+		       me->name);
+		return -ENOMEM;
+	}
 
 	got->sh_size = 0;
 	got->sh_addralign = 8;

commit dd00cc486ab1c17049a535413d1751ef3482141c
Author: Yoann Padioleau <padator@wanadoo.fr>
Date:   Thu Jul 19 01:49:03 2007 -0700

    some kmalloc/memset ->kzalloc (tree wide)
    
    Transform some calls to kmalloc/memset to a single kzalloc (or kcalloc).
    
    Here is a short excerpt of the semantic patch performing
    this transformation:
    
    @@
    type T2;
    expression x;
    identifier f,fld;
    expression E;
    expression E1,E2;
    expression e1,e2,e3,y;
    statement S;
    @@
    
     x =
    - kmalloc
    + kzalloc
      (E1,E2)
      ...  when != \(x->fld=E;\|y=f(...,x,...);\|f(...,x,...);\|x=E;\|while(...) S\|for(e1;e2;e3) S\)
    - memset((T2)x,0,E1);
    
    @@
    expression E1,E2,E3;
    @@
    
    - kzalloc(E1 * E2,E3)
    + kcalloc(E1,E2,E3)
    
    [akpm@linux-foundation.org: get kcalloc args the right way around]
    Signed-off-by: Yoann Padioleau <padator@wanadoo.fr>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Acked-by: Russell King <rmk@arm.linux.org.uk>
    Cc: Bryan Wu <bryan.wu@analog.com>
    Acked-by: Jiri Slaby <jirislaby@gmail.com>
    Cc: Dave Airlie <airlied@linux.ie>
    Acked-by: Roland Dreier <rolandd@cisco.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Acked-by: Dmitry Torokhov <dtor@mail.ru>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Mauro Carvalho Chehab <mchehab@infradead.org>
    Acked-by: Pierre Ossman <drzeus-list@drzeus.cx>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Acked-by: Greg KH <greg@kroah.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/alpha/kernel/module.c b/arch/alpha/kernel/module.c
index bd03dc94c72b..026ba9af6d6a 100644
--- a/arch/alpha/kernel/module.c
+++ b/arch/alpha/kernel/module.c
@@ -119,8 +119,7 @@ module_frob_arch_sections(Elf64_Ehdr *hdr, Elf64_Shdr *sechdrs,
 	}
 
 	nsyms = symtab->sh_size / sizeof(Elf64_Sym);
-	chains = kmalloc(nsyms * sizeof(struct got_entry), GFP_KERNEL);
-	memset(chains, 0, nsyms * sizeof(struct got_entry));
+	chains = kcalloc(nsyms, sizeof(struct got_entry), GFP_KERNEL);
 
 	got->sh_size = 0;
 	got->sh_addralign = 8;

commit 1b75b05b73cdefd1d10074e9dad60812f9731a5e
Author: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
Date:   Mon Apr 16 22:53:17 2007 -0700

    alpha: fixes for specific machine types
    
    Files:
    
    arch/alpha/kernel/core_mcpcia.c
    arch/alpha/kernel/sys_rawhide.c
    include/asm-alpha/core_mcpcia.h
    
            Determine correct hose configuration; RAWHIDE family can have
            2 or 4 hoses, so make sure non-existent hoses are ignored.
    
    arch/alpha/kernel/err_titan.c
    
            Supply a needed #include <asm/irq_regs.h>
    
    arch/alpha/kernel/module.c
    
            Add some useful output to the relocation overflow messages.
    
    arch/alpha/kernel/sys_noritake.c
    
            Supply necessary noritake_end_irq() to correct interrupt handling.
            This fixes a problem first noted by hangs during boot probing with
            a DE500-BA TULIP NIC present.
    
    arch/alpha/kernel/sys_sio.c
    
            Correct saving of original PIRQ register (PCI IRQ routing);
            change default PIRQ setting to leave PCI IRQs 9 and 14 free to
            be used for sound (Multia) and IDE (any), respectively.
    
    include/asm-alpha/io.h
    
            Supply the "isa_virt_to_bus" routine.
    
    Signed-off-by: Jay Estabrook <jay.estabrook@hp.com>
    Signed-off-by: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Richard Henderson <rth@twiddle.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/alpha/kernel/module.c b/arch/alpha/kernel/module.c
index aac6d4b22f7a..bd03dc94c72b 100644
--- a/arch/alpha/kernel/module.c
+++ b/arch/alpha/kernel/module.c
@@ -285,12 +285,12 @@ apply_relocate_add(Elf64_Shdr *sechdrs, const char *strtab,
 		reloc_overflow:
 			if (ELF64_ST_TYPE (sym->st_info) == STT_SECTION)
 			  printk(KERN_ERR
-			         "module %s: Relocation overflow vs section %d\n",
-			         me->name, sym->st_shndx);
+			         "module %s: Relocation (type %lu) overflow vs section %d\n",
+			         me->name, r_type, sym->st_shndx);
 			else
 			  printk(KERN_ERR
-			         "module %s: Relocation overflow vs %s\n",
-			         me->name, strtab + sym->st_name);
+			         "module %s: Relocation (type %lu) overflow vs %s\n",
+			         me->name, r_type, strtab + sym->st_name);
 			return -ENOEXEC;
 		}
 	}

commit 69ac59647e66c1b53fb98fe8b6d0f2099cffad60
Author: Chaskiel Grundman <cg2v@andrew.cmu.edu>
Date:   Fri Sep 9 13:01:54 2005 -0700

    [PATCH] alpha: process_reloc_for_got confuses r_offset and r_addend
    
    arch/alpha/kernel/module.c:process_reloc_for_got(), which figures out how big
    the .got section for a module should be, appears to be confusing r_offset (the
    file offset that the relocation needs to be applied to) with r_addend (the
    offset of the relocation's actual target address from the address of the
    relocation's symbol).  Because of this, one .got entry is allocated for each
    relocation instead of one each unique symbol/addend.
    
    In the module I am working with, this causes the .got section to be almost 10
    times larger than it needs to be (75544 bytes instead of 7608 bytes).  As the
    .got is accessed with global-pointer-relative instructions, it needs to be
    within the 64k gp "zone", and a 75544 byte .got clearly does not fit.  The
    result of this is that relocation overflows are detected during module load
    and the load is aborted.
    
    Change struct got_entry/process_reloc_for_got to fix this.
    
    Acked-by: Richard Henderson <rth@twiddle.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/alpha/kernel/module.c b/arch/alpha/kernel/module.c
index fc271e316a38..aac6d4b22f7a 100644
--- a/arch/alpha/kernel/module.c
+++ b/arch/alpha/kernel/module.c
@@ -47,7 +47,7 @@ module_free(struct module *mod, void *module_region)
 
 struct got_entry {
 	struct got_entry *next;
-	Elf64_Addr r_offset;
+	Elf64_Sxword r_addend;
 	int got_offset;
 };
 
@@ -57,14 +57,14 @@ process_reloc_for_got(Elf64_Rela *rela,
 {
 	unsigned long r_sym = ELF64_R_SYM (rela->r_info);
 	unsigned long r_type = ELF64_R_TYPE (rela->r_info);
-	Elf64_Addr r_offset = rela->r_offset;
+	Elf64_Sxword r_addend = rela->r_addend;
 	struct got_entry *g;
 
 	if (r_type != R_ALPHA_LITERAL)
 		return;
 
 	for (g = chains + r_sym; g ; g = g->next)
-		if (g->r_offset == r_offset) {
+		if (g->r_addend == r_addend) {
 			if (g->got_offset == 0) {
 				g->got_offset = *poffset;
 				*poffset += 8;
@@ -74,7 +74,7 @@ process_reloc_for_got(Elf64_Rela *rela,
 
 	g = kmalloc (sizeof (*g), GFP_KERNEL);
 	g->next = chains[r_sym].next;
-	g->r_offset = r_offset;
+	g->r_addend = r_addend;
 	g->got_offset = *poffset;
 	*poffset += 8;
 	chains[r_sym].next = g;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/alpha/kernel/module.c b/arch/alpha/kernel/module.c
new file mode 100644
index 000000000000..fc271e316a38
--- /dev/null
+++ b/arch/alpha/kernel/module.c
@@ -0,0 +1,311 @@
+/*  Kernel module help for Alpha.
+    Copyright (C) 2002 Richard Henderson.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+#include <linux/moduleloader.h>
+#include <linux/elf.h>
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
+#if 0
+#define DEBUGP printk
+#else
+#define DEBUGP(fmt...)
+#endif
+
+void *
+module_alloc(unsigned long size)
+{
+	if (size == 0)
+		return NULL;
+	return vmalloc(size);
+}
+
+void
+module_free(struct module *mod, void *module_region)
+{
+	vfree(module_region);
+}
+
+/* Allocate the GOT at the end of the core sections.  */
+
+struct got_entry {
+	struct got_entry *next;
+	Elf64_Addr r_offset;
+	int got_offset;
+};
+
+static inline void
+process_reloc_for_got(Elf64_Rela *rela,
+		      struct got_entry *chains, Elf64_Xword *poffset)
+{
+	unsigned long r_sym = ELF64_R_SYM (rela->r_info);
+	unsigned long r_type = ELF64_R_TYPE (rela->r_info);
+	Elf64_Addr r_offset = rela->r_offset;
+	struct got_entry *g;
+
+	if (r_type != R_ALPHA_LITERAL)
+		return;
+
+	for (g = chains + r_sym; g ; g = g->next)
+		if (g->r_offset == r_offset) {
+			if (g->got_offset == 0) {
+				g->got_offset = *poffset;
+				*poffset += 8;
+			}
+			goto found_entry;
+		}
+
+	g = kmalloc (sizeof (*g), GFP_KERNEL);
+	g->next = chains[r_sym].next;
+	g->r_offset = r_offset;
+	g->got_offset = *poffset;
+	*poffset += 8;
+	chains[r_sym].next = g;
+
+ found_entry:
+	/* Trick: most of the ELF64_R_TYPE field is unused.  There are
+	   42 valid relocation types, and a 32-bit field.  Co-opt the
+	   bits above 256 to store the got offset for this reloc.  */
+	rela->r_info |= g->got_offset << 8;
+}
+
+int
+module_frob_arch_sections(Elf64_Ehdr *hdr, Elf64_Shdr *sechdrs,
+			  char *secstrings, struct module *me)
+{
+	struct got_entry *chains;
+	Elf64_Rela *rela;
+	Elf64_Shdr *esechdrs, *symtab, *s, *got;
+	unsigned long nsyms, nrela, i;
+
+	esechdrs = sechdrs + hdr->e_shnum;
+	symtab = got = NULL;
+
+	/* Find out how large the symbol table is.  Allocate one got_entry
+	   head per symbol.  Normally this will be enough, but not always.
+	   We'll chain different offsets for the symbol down each head.  */
+	for (s = sechdrs; s < esechdrs; ++s)
+		if (s->sh_type == SHT_SYMTAB)
+			symtab = s;
+		else if (!strcmp(".got", secstrings + s->sh_name)) {
+			got = s;
+			me->arch.gotsecindex = s - sechdrs;
+		}
+
+	if (!symtab) {
+		printk(KERN_ERR "module %s: no symbol table\n", me->name);
+		return -ENOEXEC;
+	}
+	if (!got) {
+		printk(KERN_ERR "module %s: no got section\n", me->name);
+		return -ENOEXEC;
+	}
+
+	nsyms = symtab->sh_size / sizeof(Elf64_Sym);
+	chains = kmalloc(nsyms * sizeof(struct got_entry), GFP_KERNEL);
+	memset(chains, 0, nsyms * sizeof(struct got_entry));
+
+	got->sh_size = 0;
+	got->sh_addralign = 8;
+	got->sh_type = SHT_NOBITS;
+
+	/* Examine all LITERAL relocations to find out what GOT entries
+	   are required.  This sizes the GOT section as well.  */
+	for (s = sechdrs; s < esechdrs; ++s)
+		if (s->sh_type == SHT_RELA) {
+			nrela = s->sh_size / sizeof(Elf64_Rela);
+			rela = (void *)hdr + s->sh_offset;
+			for (i = 0; i < nrela; ++i)
+				process_reloc_for_got(rela+i, chains,
+						      &got->sh_size);
+		}
+
+	/* Free the memory we allocated.  */
+	for (i = 0; i < nsyms; ++i) {
+		struct got_entry *g, *n;
+		for (g = chains[i].next; g ; g = n) {
+			n = g->next;
+			kfree(g);
+		}
+	}
+	kfree(chains);
+
+	return 0;
+}
+
+int
+apply_relocate(Elf64_Shdr *sechdrs, const char *strtab, unsigned int symindex,
+	       unsigned int relsec, struct module *me)
+{
+	printk(KERN_ERR "module %s: REL relocation unsupported\n", me->name);
+	return -ENOEXEC;
+}
+
+int
+apply_relocate_add(Elf64_Shdr *sechdrs, const char *strtab,
+		   unsigned int symindex, unsigned int relsec,
+		   struct module *me)
+{
+	Elf64_Rela *rela = (void *)sechdrs[relsec].sh_addr;
+	unsigned long i, n = sechdrs[relsec].sh_size / sizeof(*rela);
+	Elf64_Sym *symtab, *sym;
+	void *base, *location;
+	unsigned long got, gp;
+
+	DEBUGP("Applying relocate section %u to %u\n", relsec,
+	       sechdrs[relsec].sh_info);
+
+	base = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr;
+	symtab = (Elf64_Sym *)sechdrs[symindex].sh_addr;
+
+	/* The small sections were sorted to the end of the segment.
+	   The following should definitely cover them.  */
+	gp = (u64)me->module_core + me->core_size - 0x8000;
+	got = sechdrs[me->arch.gotsecindex].sh_addr;
+
+	for (i = 0; i < n; i++) {
+		unsigned long r_sym = ELF64_R_SYM (rela[i].r_info);
+		unsigned long r_type = ELF64_R_TYPE (rela[i].r_info);
+		unsigned long r_got_offset = r_type >> 8;
+		unsigned long value, hi, lo;
+		r_type &= 0xff;
+
+		/* This is where to make the change.  */
+		location = base + rela[i].r_offset;
+
+		/* This is the symbol it is referring to.  Note that all
+		   unresolved symbols have been resolved.  */
+		sym = symtab + r_sym;
+		value = sym->st_value + rela[i].r_addend;
+
+		switch (r_type) {
+		case R_ALPHA_NONE:
+			break;
+		case R_ALPHA_REFQUAD:
+			/* BUG() can produce misaligned relocations. */
+			((u32 *)location)[0] = value;
+			((u32 *)location)[1] = value >> 32;
+			break;
+		case R_ALPHA_GPREL32:
+			value -= gp;
+			if ((int)value != value)
+				goto reloc_overflow;
+			*(u32 *)location = value;
+			break;
+		case R_ALPHA_LITERAL:
+			hi = got + r_got_offset;
+			lo = hi - gp;
+			if ((short)lo != lo)
+				goto reloc_overflow;
+			*(u16 *)location = lo;
+			*(u64 *)hi = value;
+			break;
+		case R_ALPHA_LITUSE:
+			break;
+		case R_ALPHA_GPDISP:
+			value = gp - (u64)location;
+			lo = (short)value;
+			hi = (int)(value - lo);
+			if (hi + lo != value)
+				goto reloc_overflow;
+			*(u16 *)location = hi >> 16;
+			*(u16 *)(location + rela[i].r_addend) = lo;
+			break;
+		case R_ALPHA_BRSGP:
+			/* BRSGP is only allowed to bind to local symbols.
+			   If the section is undef, this means that the
+			   value was resolved from somewhere else.  */
+			if (sym->st_shndx == SHN_UNDEF)
+				goto reloc_overflow;
+			if ((sym->st_other & STO_ALPHA_STD_GPLOAD) ==
+			    STO_ALPHA_STD_GPLOAD)
+				/* Omit the prologue. */
+				value += 8;
+			/* FALLTHRU */
+		case R_ALPHA_BRADDR:
+			value -= (u64)location + 4;
+			if (value & 3)
+				goto reloc_overflow;
+			value = (long)value >> 2;
+			if (value + (1<<21) >= 1<<22)
+				goto reloc_overflow;
+			value &= 0x1fffff;
+			value |= *(u32 *)location & ~0x1fffff;
+			*(u32 *)location = value;
+			break;
+		case R_ALPHA_HINT:
+			break;
+		case R_ALPHA_SREL32:
+			value -= (u64)location;
+			if ((int)value != value)
+				goto reloc_overflow;
+			*(u32 *)location = value;
+			break;
+		case R_ALPHA_SREL64:
+			value -= (u64)location;
+			*(u64 *)location = value;
+			break;
+		case R_ALPHA_GPRELHIGH:
+			value = (long)(value - gp + 0x8000) >> 16;
+			if ((short) value != value)
+				goto reloc_overflow;
+			*(u16 *)location = value;
+			break;
+		case R_ALPHA_GPRELLOW:
+			value -= gp;
+			*(u16 *)location = value;
+			break;
+		case R_ALPHA_GPREL16:
+			value -= gp;
+			if ((short) value != value)
+				goto reloc_overflow;
+			*(u16 *)location = value;
+			break;
+		default:
+			printk(KERN_ERR "module %s: Unknown relocation: %lu\n",
+			       me->name, r_type);
+			return -ENOEXEC;
+		reloc_overflow:
+			if (ELF64_ST_TYPE (sym->st_info) == STT_SECTION)
+			  printk(KERN_ERR
+			         "module %s: Relocation overflow vs section %d\n",
+			         me->name, sym->st_shndx);
+			else
+			  printk(KERN_ERR
+			         "module %s: Relocation overflow vs %s\n",
+			         me->name, strtab + sym->st_name);
+			return -ENOEXEC;
+		}
+	}
+
+	return 0;
+}
+
+int
+module_finalize(const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs,
+		struct module *me)
+{
+	return 0;
+}
+
+void
+module_arch_cleanup(struct module *mod)
+{
+}
