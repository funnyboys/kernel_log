commit 0bc25674a4a2ec32140e2f3f0b863cf87e566ad4
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Jan 21 16:22:40 2014 -0500

    alpha: delete non-required instances of <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Acked-by: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: linux-alpha@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Matt Turner <mattst88@gmail.com>

diff --git a/arch/alpha/oprofile/op_model_ev6.c b/arch/alpha/oprofile/op_model_ev6.c
index 1c84cc257fc7..02edf5971614 100644
--- a/arch/alpha/oprofile/op_model_ev6.c
+++ b/arch/alpha/oprofile/op_model_ev6.c
@@ -8,7 +8,6 @@
  */
 
 #include <linux/oprofile.h>
-#include <linux/init.h>
 #include <linux/smp.h>
 #include <asm/ptrace.h>
 

commit ec2212088c42ff7d1362629ec26dda4f3e8bdad3
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:11:12 2012 +0100

    Disintegrate asm/system.h for Alpha
    
    Disintegrate asm/system.h for Alpha.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-alpha@vger.kernel.org

diff --git a/arch/alpha/oprofile/op_model_ev6.c b/arch/alpha/oprofile/op_model_ev6.c
index 0869f85f5748..1c84cc257fc7 100644
--- a/arch/alpha/oprofile/op_model_ev6.c
+++ b/arch/alpha/oprofile/op_model_ev6.c
@@ -11,7 +11,6 @@
 #include <linux/init.h>
 #include <linux/smp.h>
 #include <asm/ptrace.h>
-#include <asm/system.h>
 
 #include "op_impl.h"
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/alpha/oprofile/op_model_ev6.c b/arch/alpha/oprofile/op_model_ev6.c
new file mode 100644
index 000000000000..0869f85f5748
--- /dev/null
+++ b/arch/alpha/oprofile/op_model_ev6.c
@@ -0,0 +1,103 @@
+/**
+ * @file arch/alpha/oprofile/op_model_ev6.c
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author Richard Henderson <rth@twiddle.net>
+ */
+
+#include <linux/oprofile.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <asm/ptrace.h>
+#include <asm/system.h>
+
+#include "op_impl.h"
+
+
+/* Compute all of the registers in preparation for enabling profiling.  */
+
+static void
+ev6_reg_setup(struct op_register_config *reg,
+	      struct op_counter_config *ctr,
+	      struct op_system_config *sys)
+{
+	unsigned long ctl, reset, need_reset, i;
+
+	/* Select desired events.  We've mapped the event numbers
+	   such that they fit directly into the event selection fields.  */
+	ctl = 0;
+	if (ctr[0].enabled && ctr[0].event)
+		ctl |= (ctr[0].event & 1) << 4;
+	if (ctr[1].enabled)
+		ctl |= (ctr[1].event - 2) & 15;
+	reg->mux_select = ctl;
+
+	/* Select logging options.  */
+	/* ??? Need to come up with some mechanism to trace only
+	   selected processes.  EV6 does not have a mechanism to
+	   select kernel or user mode only.  For now, enable always.  */
+	reg->proc_mode = 0;
+
+	/* EV6 cannot change the width of the counters as with the
+	   other implementations.  But fortunately, we can write to
+	   the counters and set the value such that it will overflow
+	   at the right time.  */
+	reset = need_reset = 0;
+	for (i = 0; i < 2; ++i) {
+		unsigned long count = ctr[i].count;
+		if (!ctr[i].enabled)
+			continue;
+
+		if (count > 0x100000)
+			count = 0x100000;
+		ctr[i].count = count;
+		reset |= (0x100000 - count) << (i ? 6 : 28);
+		if (count != 0x100000)
+			need_reset |= 1 << i;
+	}
+	reg->reset_values = reset;
+	reg->need_reset = need_reset;
+}
+
+/* Program all of the registers in preparation for enabling profiling.  */
+
+static void
+ev6_cpu_setup (void *x)
+{
+	struct op_register_config *reg = x;
+
+	wrperfmon(2, reg->mux_select);
+	wrperfmon(3, reg->proc_mode);
+	wrperfmon(6, reg->reset_values | 3);
+}
+
+/* CTR is a counter for which the user has requested an interrupt count
+   in between one of the widths selectable in hardware.  Reset the count
+   for CTR to the value stored in REG->RESET_VALUES.  */
+
+static void
+ev6_reset_ctr(struct op_register_config *reg, unsigned long ctr)
+{
+	wrperfmon(6, reg->reset_values | (1 << ctr));
+}
+
+static void
+ev6_handle_interrupt(unsigned long which, struct pt_regs *regs,
+		     struct op_counter_config *ctr)
+{
+	/* Record the sample.  */
+	oprofile_add_sample(regs, which);
+}
+
+
+struct op_axp_model op_model_ev6 = {
+	.reg_setup		= ev6_reg_setup,
+	.cpu_setup		= ev6_cpu_setup,
+	.reset_ctr		= ev6_reset_ctr,
+	.handle_interrupt	= ev6_handle_interrupt,
+	.cpu_type		= "alpha/ev6",
+	.num_counters		= 2,
+	.can_set_proc_mode	= 0,
+};
