commit cc0282975b3f887005c380adcf0af95915f0c1bb
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Thu Dec 6 20:07:40 2018 +0000

    kgdb/treewide: constify struct kgdb_arch arch_kgdb_ops
    
    checkpatch.pl reports the following:
    
      WARNING: struct kgdb_arch should normally be const
      #28: FILE: arch/mips/kernel/kgdb.c:397:
      +struct kgdb_arch arch_kgdb_ops = {
    
    This report makes sense, as all other ops struct, this
    one should also be const. This patch does the change.
    
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: x86@kernel.org
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Acked-by: Paul Burton <paul.burton@mips.com>
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Acked-by: Borislav Petkov <bp@suse.de>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>

diff --git a/arch/h8300/kernel/kgdb.c b/arch/h8300/kernel/kgdb.c
index 1a1d30cb0609..602e478afbd5 100644
--- a/arch/h8300/kernel/kgdb.c
+++ b/arch/h8300/kernel/kgdb.c
@@ -129,7 +129,7 @@ void kgdb_arch_exit(void)
 	/* Nothing to do */
 }
 
-struct kgdb_arch arch_kgdb_ops = {
+const struct kgdb_arch arch_kgdb_ops = {
 	/* Breakpoint instruction: trapa #2 */
 	.gdb_bpt_instr = { 0x57, 0x20 },
 };

commit ce156febeed1d2731fe6e325a842cb4640931d22
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Thu Jul 19 19:36:06 2018 -0700

    arch/h8300: eliminate kgbd.c warning
    
    Drop the "const" qualifier from arch_kgdb_ops to eliminate the gcc
    warning (gcc version is 8.1.0).
    
    arch/h8300/kernel/kgdb.c:132:24: error: conflicting type qualifiers for 'arch_kgdb_ops'
     const struct kgdb_arch arch_kgdb_ops = {
    In file included from ../arch/h8300/kernel/kgdb.c:12:
    ../include/linux/kgdb.h:284:26: note: previous declaration of 'arch_kgdb_ops' was here
     extern struct kgdb_arch  arch_kgdb_ops;
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: uclinux-h8-devel@lists.sourceforge.jp
    Signed-off-by: Yoshinori Sato <ysato@users.sourceforge.jp>

diff --git a/arch/h8300/kernel/kgdb.c b/arch/h8300/kernel/kgdb.c
index 602e478afbd5..1a1d30cb0609 100644
--- a/arch/h8300/kernel/kgdb.c
+++ b/arch/h8300/kernel/kgdb.c
@@ -129,7 +129,7 @@ void kgdb_arch_exit(void)
 	/* Nothing to do */
 }
 
-const struct kgdb_arch arch_kgdb_ops = {
+struct kgdb_arch arch_kgdb_ops = {
 	/* Breakpoint instruction: trapa #2 */
 	.gdb_bpt_instr = { 0x57, 0x20 },
 };

commit 96ff2d7081cfc50e5493e9a5ac7c58bfa2ea41d3
Author: Yoshinori Sato <ysato@users.sourceforge.jp>
Date:   Wed Jan 20 23:27:30 2016 +0900

    h8300: Add KGDB support.
    
    Signed-off-by: Yoshinori Sato <ysato@users.sourceforge.jp>

diff --git a/arch/h8300/kernel/kgdb.c b/arch/h8300/kernel/kgdb.c
new file mode 100644
index 000000000000..602e478afbd5
--- /dev/null
+++ b/arch/h8300/kernel/kgdb.c
@@ -0,0 +1,135 @@
+/*
+ * H8/300 KGDB support
+ *
+ * Copyright (C) 2015 Yoshinori Sato <ysato@users.sourceforge.jp>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/ptrace.h>
+#include <linux/kgdb.h>
+#include <linux/kdebug.h>
+#include <linux/io.h>
+
+struct dbg_reg_def_t dbg_reg_def[DBG_MAX_REG_NUM] = {
+	{ "er0", GDB_SIZEOF_REG, offsetof(struct pt_regs, er0) },
+	{ "er1", GDB_SIZEOF_REG, offsetof(struct pt_regs, er1) },
+	{ "er2", GDB_SIZEOF_REG, offsetof(struct pt_regs, er2) },
+	{ "er3", GDB_SIZEOF_REG, offsetof(struct pt_regs, er3) },
+	{ "er4", GDB_SIZEOF_REG, offsetof(struct pt_regs, er4) },
+	{ "er5", GDB_SIZEOF_REG, offsetof(struct pt_regs, er5) },
+	{ "er6", GDB_SIZEOF_REG, offsetof(struct pt_regs, er6) },
+	{ "sp", GDB_SIZEOF_REG, offsetof(struct pt_regs, sp) },
+	{ "ccr", GDB_SIZEOF_REG, offsetof(struct pt_regs, ccr) },
+	{ "pc", GDB_SIZEOF_REG, offsetof(struct pt_regs, pc) },
+	{ "cycles", GDB_SIZEOF_REG, -1 },
+#if defined(CONFIG_CPU_H8S)
+	{ "exr", GDB_SIZEOF_REG, offsetof(struct pt_regs, exr) },
+#endif
+	{ "tick", GDB_SIZEOF_REG, -1 },
+	{ "inst", GDB_SIZEOF_REG, -1 },
+};
+
+char *dbg_get_reg(int regno, void *mem, struct pt_regs *regs)
+{
+	if (regno >= DBG_MAX_REG_NUM || regno < 0)
+		return NULL;
+
+	switch (regno) {
+	case GDB_CCR:
+#if defined(CONFIG_CPU_H8S)
+	case GDB_EXR:
+#endif
+		*(u32 *)mem = *(u16 *)((void *)regs +
+				       dbg_reg_def[regno].offset);
+		break;
+	default:
+		if (dbg_reg_def[regno].offset >= 0)
+			memcpy(mem, (void *)regs + dbg_reg_def[regno].offset,
+			       dbg_reg_def[regno].size);
+		else
+			memset(mem, 0, dbg_reg_def[regno].size);
+		break;
+	}
+	return dbg_reg_def[regno].name;
+}
+
+int dbg_set_reg(int regno, void *mem, struct pt_regs *regs)
+{
+	if (regno >= DBG_MAX_REG_NUM || regno < 0)
+		return -EINVAL;
+
+	switch (regno) {
+	case GDB_CCR:
+#if defined(CONFIG_CPU_H8S)
+	case GDB_EXR:
+#endif
+		*(u16 *)((void *)regs +
+			 dbg_reg_def[regno].offset) = *(u32 *)mem;
+		break;
+	default:
+		memcpy((void *)regs + dbg_reg_def[regno].offset, mem,
+		       dbg_reg_def[regno].size);
+	}
+	return 0;
+}
+
+asmlinkage void h8300_kgdb_trap(struct pt_regs *regs)
+{
+	regs->pc &= 0x00ffffff;
+	if (kgdb_handle_exception(10, SIGTRAP, 0, regs))
+		return;
+	if (*(u16 *)(regs->pc) == *(u16 *)&arch_kgdb_ops.gdb_bpt_instr)
+		regs->pc += BREAK_INSTR_SIZE;
+	regs->pc |= regs->ccr << 24;
+}
+
+void sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p)
+{
+	memset((char *)gdb_regs, 0, NUMREGBYTES);
+	gdb_regs[GDB_SP] = p->thread.ksp;
+	gdb_regs[GDB_PC] = KSTK_EIP(p);
+}
+
+void kgdb_arch_set_pc(struct pt_regs *regs, unsigned long pc)
+{
+	regs->pc = pc;
+}
+
+int kgdb_arch_handle_exception(int vector, int signo, int err_code,
+				char *remcom_in_buffer, char *remcom_out_buffer,
+				struct pt_regs *regs)
+{
+	char *ptr;
+	unsigned long addr;
+
+	switch (remcom_in_buffer[0]) {
+	case 's':
+	case 'c':
+		/* handle the optional parameters */
+		ptr = &remcom_in_buffer[1];
+		if (kgdb_hex2long(&ptr, &addr))
+			regs->pc = addr;
+
+		return 0;
+	}
+
+	return -1; /* this means that we do not want to exit from the handler */
+}
+
+int kgdb_arch_init(void)
+{
+	return 0;
+}
+
+void kgdb_arch_exit(void)
+{
+	/* Nothing to do */
+}
+
+const struct kgdb_arch arch_kgdb_ops = {
+	/* Breakpoint instruction: trapa #2 */
+	.gdb_bpt_instr = { 0x57, 0x20 },
+};
