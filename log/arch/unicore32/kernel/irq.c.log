commit 2229a3618abdaac40c9e32754509357ed78c90f5
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Jun 26 11:34:18 2019 +0200

    unicore: Drop pointless include
    
    I can't see why this file includes <linux/gpio.h>, it is not
    using any of the interfaces. Lots of things are named "gpio"
    in the file but it is an irqchip driver and has nothing to
    do with the GPIO interfaces.
    
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/20190626093418.6263-1-linus.walleij@linaro.org

diff --git a/arch/unicore32/kernel/irq.c b/arch/unicore32/kernel/irq.c
index d1129828c41e..c014ae3c3e48 100644
--- a/arch/unicore32/kernel/irq.c
+++ b/arch/unicore32/kernel/irq.c
@@ -21,7 +21,6 @@
 #include <linux/kallsyms.h>
 #include <linux/proc_fs.h>
 #include <linux/syscore_ops.h>
-#include <linux/gpio.h>
 
 #include <mach/hardware.h>
 

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/unicore32/kernel/irq.c b/arch/unicore32/kernel/irq.c
index eb1fd0030359..d1129828c41e 100644
--- a/arch/unicore32/kernel/irq.c
+++ b/arch/unicore32/kernel/irq.c
@@ -1,13 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * linux/arch/unicore32/kernel/irq.c
  *
  * Code specific to PKUnity SoC and UniCore ISA
  *
  * Copyright (C) 2001-2010 GUAN Xue-tao
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 #include <linux/kernel_stat.h>
 #include <linux/module.h>

commit bd0b9ac405e1794d72533c3d487aa65b6b955a0c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 14 10:42:37 2015 +0200

    genirq: Remove irq argument from irq flow handlers
    
    Most interrupt flow handlers do not use the irq argument. Those few
    which use it can retrieve the irq number from the irq descriptor.
    
    Remove the argument.
    
    Search and replace was done with coccinelle and some extra helper
    scripts around it. Thanks to Julia for her help!
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>

diff --git a/arch/unicore32/kernel/irq.c b/arch/unicore32/kernel/irq.c
index c53729d92e8d..eb1fd0030359 100644
--- a/arch/unicore32/kernel/irq.c
+++ b/arch/unicore32/kernel/irq.c
@@ -112,7 +112,7 @@ static struct irq_chip puv3_low_gpio_chip = {
  * irq_controller_lock held, and IRQs disabled.  Decode the IRQ
  * and call the handler.
  */
-static void puv3_gpio_handler(unsigned int __irq, struct irq_desc *desc)
+static void puv3_gpio_handler(struct irq_desc *desc)
 {
 	unsigned int mask, irq;
 

commit f70229e2a342714c7431547676da2518a0a22b55
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 31 22:09:38 2015 +0200

    unicore32/irq: Prepare puv3_gpio_handler for irq argument removal
    
    The irq argument of most interrupt flow handlers is unused or merily
    used instead of a local variable. The handlers which need the irq
    argument can retrieve the irq number from the irq descriptor.
    
    Search and update was done with coccinelle and the invaluable help of
    Julia Lawall.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>

diff --git a/arch/unicore32/kernel/irq.c b/arch/unicore32/kernel/irq.c
index 0be5ccd7ccd2..c53729d92e8d 100644
--- a/arch/unicore32/kernel/irq.c
+++ b/arch/unicore32/kernel/irq.c
@@ -112,10 +112,9 @@ static struct irq_chip puv3_low_gpio_chip = {
  * irq_controller_lock held, and IRQs disabled.  Decode the IRQ
  * and call the handler.
  */
-static void
-puv3_gpio_handler(unsigned int irq, struct irq_desc *desc)
+static void puv3_gpio_handler(unsigned int __irq, struct irq_desc *desc)
 {
-	unsigned int mask;
+	unsigned int mask, irq;
 
 	mask = readl(GPIO_GEDR);
 	do {

commit 8978bfd2288adaa24d39fa15f57eb9e24ffeca12
Author: Guan Xuetao <gxt@mprc.pku.edu.cn>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Disintegrate asm/system.h for Unicore32 [based on ver #3, changed by gxt]
    
    Disintegrate asm/system.h for Unicore32. (Compilation successful)
    The implementation details are not changed, but only splitted.
    BTW, some codestyles are adjusted.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Guan Xuetao <gxt@mprc.pku.edu.cn>

diff --git a/arch/unicore32/kernel/irq.c b/arch/unicore32/kernel/irq.c
index d4efa7d679ff..0be5ccd7ccd2 100644
--- a/arch/unicore32/kernel/irq.c
+++ b/arch/unicore32/kernel/irq.c
@@ -26,7 +26,6 @@
 #include <linux/syscore_ops.h>
 #include <linux/gpio.h>
 
-#include <asm/system.h>
 #include <mach/hardware.h>
 
 #include "setup.h"

commit f98bf4aa39ecce96020631cba910be094c87ac3c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Apr 26 19:14:47 2011 +0200

    PM / UNICORE32: Use struct syscore_ops instead of sysdevs for PM
    
    Make some UNICORE32 architecture's code use struct syscore_ops
    objects for power management instead of sysdev classes and sysdevs.
    
    This simplifies the code and reduces the kernel's memory footprint.
    It also is necessary for removing sysdevs from the kernel entirely in
    the future.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Guan Xuetao <gxt@mprc.pku.edu.cn>

diff --git a/arch/unicore32/kernel/irq.c b/arch/unicore32/kernel/irq.c
index 2aa30a364bbe..d4efa7d679ff 100644
--- a/arch/unicore32/kernel/irq.c
+++ b/arch/unicore32/kernel/irq.c
@@ -23,7 +23,7 @@
 #include <linux/list.h>
 #include <linux/kallsyms.h>
 #include <linux/proc_fs.h>
-#include <linux/sysdev.h>
+#include <linux/syscore_ops.h>
 #include <linux/gpio.h>
 
 #include <asm/system.h>
@@ -237,7 +237,7 @@ static struct puv3_irq_state {
 	unsigned int	iccr;
 } puv3_irq_state;
 
-static int puv3_irq_suspend(struct sys_device *dev, pm_message_t state)
+static int puv3_irq_suspend(void)
 {
 	struct puv3_irq_state *st = &puv3_irq_state;
 
@@ -265,7 +265,7 @@ static int puv3_irq_suspend(struct sys_device *dev, pm_message_t state)
 	return 0;
 }
 
-static int puv3_irq_resume(struct sys_device *dev)
+static void puv3_irq_resume(void)
 {
 	struct puv3_irq_state *st = &puv3_irq_state;
 
@@ -278,27 +278,20 @@ static int puv3_irq_resume(struct sys_device *dev)
 
 		writel(st->icmr, INTC_ICMR);
 	}
-	return 0;
 }
 
-static struct sysdev_class puv3_irq_sysclass = {
-	.name		= "pkunity-irq",
+static struct syscore_ops puv3_irq_syscore_ops = {
 	.suspend	= puv3_irq_suspend,
 	.resume		= puv3_irq_resume,
 };
 
-static struct sys_device puv3_irq_device = {
-	.id		= 0,
-	.cls		= &puv3_irq_sysclass,
-};
-
-static int __init puv3_irq_init_devicefs(void)
+static int __init puv3_irq_init_syscore(void)
 {
-	sysdev_class_register(&puv3_irq_sysclass);
-	return sysdev_register(&puv3_irq_device);
+	register_syscore_ops(&puv3_irq_syscore_ops);
+	return 0;
 }
 
-device_initcall(puv3_irq_init_devicefs);
+device_initcall(puv3_irq_init_syscore);
 
 void __init init_IRQ(void)
 {

commit 37daf3223e61685854798f755e4af9f073aaa26c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 18:26:42 2011 +0100

    unicore32: Use generic show_interrupts()
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/unicore32/kernel/irq.c b/arch/unicore32/kernel/irq.c
index a6ee47f162ee..2aa30a364bbe 100644
--- a/arch/unicore32/kernel/irq.c
+++ b/arch/unicore32/kernel/irq.c
@@ -355,48 +355,6 @@ void __init init_IRQ(void)
 #endif
 }
 
-int show_interrupts(struct seq_file *p, void *v)
-{
-	int i = *(loff_t *) v, cpu;
-	struct irq_desc *desc;
-	struct irqaction *action;
-	unsigned long flags;
-
-	if (i == 0) {
-		char cpuname[12];
-
-		seq_printf(p, "    ");
-		for_each_present_cpu(cpu) {
-			sprintf(cpuname, "CPU%d", cpu);
-			seq_printf(p, " %10s", cpuname);
-		}
-		seq_putc(p, '\n');
-	}
-
-	if (i < nr_irqs) {
-		desc = irq_to_desc(i);
-		raw_spin_lock_irqsave(&desc->lock, flags);
-		action = desc->action;
-		if (!action)
-			goto unlock;
-
-		seq_printf(p, "%3d: ", i);
-		for_each_present_cpu(cpu)
-			seq_printf(p, "%10u ", kstat_irqs_cpu(i, cpu));
-		seq_printf(p, " %10s", desc->irq_data.chip->name ? : "-");
-		seq_printf(p, "  %s", action->name);
-		for (action = action->next; action; action = action->next)
-			seq_printf(p, ", %s", action->name);
-
-		seq_putc(p, '\n');
-unlock:
-		raw_spin_unlock_irqrestore(&desc->lock, flags);
-	} else if (i == nr_irqs) {
-		seq_printf(p, "Error in interrupt!\n");
-	}
-	return 0;
-}
-
 /*
  * do_IRQ handles all hardware IRQ's.  Decoded IRQs should not
  * come via this function.  Instead, they should provide their

commit e1f5ce819c60a1020b43532333b0db291f2ce5c1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 18:26:16 2011 +0100

    unicore32: Convert to new irq function names
    
    Scripted with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/unicore32/kernel/irq.c b/arch/unicore32/kernel/irq.c
index b23624cf3062..a6ee47f162ee 100644
--- a/arch/unicore32/kernel/irq.c
+++ b/arch/unicore32/kernel/irq.c
@@ -321,24 +321,24 @@ void __init init_IRQ(void)
 	writel(1, INTC_ICCR);
 
 	for (irq = 0; irq < IRQ_GPIOHIGH; irq++) {
-		set_irq_chip(irq, &puv3_low_gpio_chip);
-		set_irq_handler(irq, handle_edge_irq);
+		irq_set_chip(irq, &puv3_low_gpio_chip);
+		irq_set_handler(irq, handle_edge_irq);
 		irq_modify_status(irq,
 			IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN,
 			0);
 	}
 
 	for (irq = IRQ_GPIOHIGH + 1; irq < IRQ_GPIO0; irq++) {
-		set_irq_chip(irq, &puv3_normal_chip);
-		set_irq_handler(irq, handle_level_irq);
+		irq_set_chip(irq, &puv3_normal_chip);
+		irq_set_handler(irq, handle_level_irq);
 		irq_modify_status(irq,
 			IRQ_NOREQUEST | IRQ_NOAUTOEN,
 			IRQ_NOPROBE);
 	}
 
 	for (irq = IRQ_GPIO0; irq <= IRQ_GPIO27; irq++) {
-		set_irq_chip(irq, &puv3_high_gpio_chip);
-		set_irq_handler(irq, handle_edge_irq);
+		irq_set_chip(irq, &puv3_high_gpio_chip);
+		irq_set_handler(irq, handle_edge_irq);
 		irq_modify_status(irq,
 			IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN,
 			0);
@@ -347,8 +347,8 @@ void __init init_IRQ(void)
 	/*
 	 * Install handler for GPIO 0-27 edge detect interrupts
 	 */
-	set_irq_chip(IRQ_GPIOHIGH, &puv3_normal_chip);
-	set_irq_chained_handler(IRQ_GPIOHIGH, puv3_gpio_handler);
+	irq_set_chip(IRQ_GPIOHIGH, &puv3_normal_chip);
+	irq_set_chained_handler(IRQ_GPIOHIGH, puv3_gpio_handler);
 
 #ifdef CONFIG_PUV3_GPIO
 	puv3_init_gpio();

commit 1cf46c42d7688a2e09de87fc9201b0e9a0961866
Author: GuanXuetao <gxt@mprc.pku.edu.cn>
Date:   Fri Mar 4 18:07:48 2011 +0800

    unicore32: modify io_p2v and io_v2p macros, and adjust PKUNITY_mmio_BASEs
    
    1. remove __REG macro
    2. add (void __iomem *) to io_p2v macro
    3. add (phys_addr_t) to io_v2p macro
    4. add PKUNITY_AHB_BASE and PKUNITY_APB_BASE definitions
    5. modify all PKUNITY_mmio_BASEs from physical addr to virtual addr
    6. adjust prefix macro for all usage of PKUNITY_mmio_BASEs
      -- by advice with Arnd Bergmann
    
    Signed-off-by: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/unicore32/kernel/irq.c b/arch/unicore32/kernel/irq.c
index e1dbfcb61873..b23624cf3062 100644
--- a/arch/unicore32/kernel/irq.c
+++ b/arch/unicore32/kernel/irq.c
@@ -226,8 +226,8 @@ static struct irq_chip puv3_normal_chip = {
 
 static struct resource irq_resource = {
 	.name	= "irqs",
-	.start	= PKUNITY_INTC_BASE,
-	.end	= PKUNITY_INTC_BASE + 0xFFFFF,
+	.start	= io_v2p(PKUNITY_INTC_BASE),
+	.end	= io_v2p(PKUNITY_INTC_BASE) + 0xFFFFF,
 };
 
 static struct puv3_irq_state {

commit e5abf78b57199a417eb01ff922a5ea6ff9e10b61
Author: GuanXuetao <gxt@mprc.pku.edu.cn>
Date:   Sat Feb 26 21:21:18 2011 +0800

    unicore32 io: redefine __REG(x) and re-use readl/writel funcs
    
      -- by advice of Arnd Bergmann
    
    Signed-off-by: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/unicore32/kernel/irq.c b/arch/unicore32/kernel/irq.c
index 38e30897dea3..e1dbfcb61873 100644
--- a/arch/unicore32/kernel/irq.c
+++ b/arch/unicore32/kernel/irq.c
@@ -66,8 +66,8 @@ static int puv3_gpio_type(struct irq_data *d, unsigned int type)
 	else
 		GPIO_IRQ_falling_edge &= ~mask;
 
-	GPIO_GRER = GPIO_IRQ_rising_edge & GPIO_IRQ_mask;
-	GPIO_GFER = GPIO_IRQ_falling_edge & GPIO_IRQ_mask;
+	writel(GPIO_IRQ_rising_edge & GPIO_IRQ_mask, GPIO_GRER);
+	writel(GPIO_IRQ_falling_edge & GPIO_IRQ_mask, GPIO_GFER);
 
 	return 0;
 }
@@ -77,25 +77,25 @@ static int puv3_gpio_type(struct irq_data *d, unsigned int type)
  */
 static void puv3_low_gpio_ack(struct irq_data *d)
 {
-	GPIO_GEDR = (1 << d->irq);
+	writel((1 << d->irq), GPIO_GEDR);
 }
 
 static void puv3_low_gpio_mask(struct irq_data *d)
 {
-	INTC_ICMR &= ~(1 << d->irq);
+	writel(readl(INTC_ICMR) & ~(1 << d->irq), INTC_ICMR);
 }
 
 static void puv3_low_gpio_unmask(struct irq_data *d)
 {
-	INTC_ICMR |= 1 << d->irq;
+	writel(readl(INTC_ICMR) | (1 << d->irq), INTC_ICMR);
 }
 
 static int puv3_low_gpio_wake(struct irq_data *d, unsigned int on)
 {
 	if (on)
-		PM_PWER |= 1 << d->irq;
+		writel(readl(PM_PWER) | (1 << d->irq), PM_PWER);
 	else
-		PM_PWER &= ~(1 << d->irq);
+		writel(readl(PM_PWER) & ~(1 << d->irq), PM_PWER);
 	return 0;
 }
 
@@ -118,13 +118,13 @@ puv3_gpio_handler(unsigned int irq, struct irq_desc *desc)
 {
 	unsigned int mask;
 
-	mask = GPIO_GEDR;
+	mask = readl(GPIO_GEDR);
 	do {
 		/*
 		 * clear down all currently active IRQ sources.
 		 * We will be processing them all.
 		 */
-		GPIO_GEDR = mask;
+		writel(mask, GPIO_GEDR);
 
 		irq = IRQ_GPIO0;
 		do {
@@ -133,7 +133,7 @@ puv3_gpio_handler(unsigned int irq, struct irq_desc *desc)
 			mask >>= 1;
 			irq++;
 		} while (mask);
-		mask = GPIO_GEDR;
+		mask = readl(GPIO_GEDR);
 	} while (mask);
 }
 
@@ -146,7 +146,7 @@ static void puv3_high_gpio_ack(struct irq_data *d)
 {
 	unsigned int mask = GPIO_MASK(d->irq);
 
-	GPIO_GEDR = mask;
+	writel(mask, GPIO_GEDR);
 }
 
 static void puv3_high_gpio_mask(struct irq_data *d)
@@ -155,8 +155,8 @@ static void puv3_high_gpio_mask(struct irq_data *d)
 
 	GPIO_IRQ_mask &= ~mask;
 
-	GPIO_GRER &= ~mask;
-	GPIO_GFER &= ~mask;
+	writel(readl(GPIO_GRER) & ~mask, GPIO_GRER);
+	writel(readl(GPIO_GFER) & ~mask, GPIO_GFER);
 }
 
 static void puv3_high_gpio_unmask(struct irq_data *d)
@@ -165,16 +165,16 @@ static void puv3_high_gpio_unmask(struct irq_data *d)
 
 	GPIO_IRQ_mask |= mask;
 
-	GPIO_GRER = GPIO_IRQ_rising_edge & GPIO_IRQ_mask;
-	GPIO_GFER = GPIO_IRQ_falling_edge & GPIO_IRQ_mask;
+	writel(GPIO_IRQ_rising_edge & GPIO_IRQ_mask, GPIO_GRER);
+	writel(GPIO_IRQ_falling_edge & GPIO_IRQ_mask, GPIO_GFER);
 }
 
 static int puv3_high_gpio_wake(struct irq_data *d, unsigned int on)
 {
 	if (on)
-		PM_PWER |= PM_PWER_GPIOHIGH;
+		writel(readl(PM_PWER) | PM_PWER_GPIOHIGH, PM_PWER);
 	else
-		PM_PWER &= ~PM_PWER_GPIOHIGH;
+		writel(readl(PM_PWER) & ~PM_PWER_GPIOHIGH, PM_PWER);
 	return 0;
 }
 
@@ -193,12 +193,12 @@ static struct irq_chip puv3_high_gpio_chip = {
  */
 static void puv3_mask_irq(struct irq_data *d)
 {
-	INTC_ICMR &= ~(1 << d->irq);
+	writel(readl(INTC_ICMR) & ~(1 << d->irq), INTC_ICMR);
 }
 
 static void puv3_unmask_irq(struct irq_data *d)
 {
-	INTC_ICMR |= (1 << d->irq);
+	writel(readl(INTC_ICMR) | (1 << d->irq), INTC_ICMR);
 }
 
 /*
@@ -208,9 +208,9 @@ static int puv3_set_wake(struct irq_data *d, unsigned int on)
 {
 	if (d->irq == IRQ_RTCAlarm) {
 		if (on)
-			PM_PWER |= PM_PWER_RTC;
+			writel(readl(PM_PWER) | PM_PWER_RTC, PM_PWER);
 		else
-			PM_PWER &= ~PM_PWER_RTC;
+			writel(readl(PM_PWER) & ~PM_PWER_RTC, PM_PWER);
 		return 0;
 	}
 	return -EINVAL;
@@ -242,25 +242,25 @@ static int puv3_irq_suspend(struct sys_device *dev, pm_message_t state)
 	struct puv3_irq_state *st = &puv3_irq_state;
 
 	st->saved = 1;
-	st->icmr = INTC_ICMR;
-	st->iclr = INTC_ICLR;
-	st->iccr = INTC_ICCR;
+	st->icmr = readl(INTC_ICMR);
+	st->iclr = readl(INTC_ICLR);
+	st->iccr = readl(INTC_ICCR);
 
 	/*
 	 * Disable all GPIO-based interrupts.
 	 */
-	INTC_ICMR &= ~(0x1ff);
+	writel(readl(INTC_ICMR) & ~(0x1ff), INTC_ICMR);
 
 	/*
 	 * Set the appropriate edges for wakeup.
 	 */
-	GPIO_GRER = PM_PWER & GPIO_IRQ_rising_edge;
-	GPIO_GFER = PM_PWER & GPIO_IRQ_falling_edge;
+	writel(readl(PM_PWER) & GPIO_IRQ_rising_edge, GPIO_GRER);
+	writel(readl(PM_PWER) & GPIO_IRQ_falling_edge, GPIO_GFER);
 
 	/*
 	 * Clear any pending GPIO interrupts.
 	 */
-	GPIO_GEDR = GPIO_GEDR;
+	writel(readl(GPIO_GEDR), GPIO_GEDR);
 
 	return 0;
 }
@@ -270,13 +270,13 @@ static int puv3_irq_resume(struct sys_device *dev)
 	struct puv3_irq_state *st = &puv3_irq_state;
 
 	if (st->saved) {
-		INTC_ICCR = st->iccr;
-		INTC_ICLR = st->iclr;
+		writel(st->iccr, INTC_ICCR);
+		writel(st->iclr, INTC_ICLR);
 
-		GPIO_GRER = GPIO_IRQ_rising_edge & GPIO_IRQ_mask;
-		GPIO_GFER = GPIO_IRQ_falling_edge & GPIO_IRQ_mask;
+		writel(GPIO_IRQ_rising_edge & GPIO_IRQ_mask, GPIO_GRER);
+		writel(GPIO_IRQ_falling_edge & GPIO_IRQ_mask, GPIO_GFER);
 
-		INTC_ICMR = st->icmr;
+		writel(st->icmr, INTC_ICMR);
 	}
 	return 0;
 }
@@ -307,18 +307,18 @@ void __init init_IRQ(void)
 	request_resource(&iomem_resource, &irq_resource);
 
 	/* disable all IRQs */
-	INTC_ICMR = 0;
+	writel(0, INTC_ICMR);
 
 	/* all IRQs are IRQ, not REAL */
-	INTC_ICLR = 0;
+	writel(0, INTC_ICLR);
 
 	/* clear all GPIO edge detects */
-	GPIO_GPIR = FMASK(8, 0) & ~FIELD(1, 1, GPI_SOFF_REQ);
-	GPIO_GFER = 0;
-	GPIO_GRER = 0;
-	GPIO_GEDR = 0x0FFFFFFF;
+	writel(FMASK(8, 0) & ~FIELD(1, 1, GPI_SOFF_REQ), GPIO_GPIR);
+	writel(0, GPIO_GFER);
+	writel(0, GPIO_GRER);
+	writel(0x0FFFFFFF, GPIO_GEDR);
 
-	INTC_ICCR = 1;
+	writel(1, INTC_ICCR);
 
 	for (irq = 0; irq < IRQ_GPIOHIGH; irq++) {
 		set_irq_chip(irq, &puv3_low_gpio_chip);

commit 36a8b8c399480b5388ddd198ead78c9dd0e50df0
Author: GuanXuetao <gxt@mprc.pku.edu.cn>
Date:   Thu Feb 17 19:15:36 2011 +0800

    unicore32: modify function names and parameters for irq_chips
    
      -- by advice with Thomas Gleixner
    
    Signed-off-by: Guan Xuetao <gxt@mprc.pku.edu.cn>

diff --git a/arch/unicore32/kernel/irq.c b/arch/unicore32/kernel/irq.c
index 7c211f597833..38e30897dea3 100644
--- a/arch/unicore32/kernel/irq.c
+++ b/arch/unicore32/kernel/irq.c
@@ -42,14 +42,14 @@ static int GPIO_IRQ_mask = 0;
 
 #define GPIO_MASK(irq)		(1 << (irq - IRQ_GPIO0))
 
-static int puv3_gpio_type(unsigned int irq, unsigned int type)
+static int puv3_gpio_type(struct irq_data *d, unsigned int type)
 {
 	unsigned int mask;
 
-	if (irq < IRQ_GPIOHIGH)
-		mask = 1 << irq;
+	if (d->irq < IRQ_GPIOHIGH)
+		mask = 1 << d->irq;
 	else
-		mask = GPIO_MASK(irq);
+		mask = GPIO_MASK(d->irq);
 
 	if (type == IRQ_TYPE_PROBE) {
 		if ((GPIO_IRQ_rising_edge | GPIO_IRQ_falling_edge) & mask)
@@ -75,37 +75,37 @@ static int puv3_gpio_type(unsigned int irq, unsigned int type)
 /*
  * GPIO IRQs must be acknowledged.  This is for IRQs from 0 to 7.
  */
-static void puv3_low_gpio_ack(unsigned int irq)
+static void puv3_low_gpio_ack(struct irq_data *d)
 {
-	GPIO_GEDR = (1 << irq);
+	GPIO_GEDR = (1 << d->irq);
 }
 
-static void puv3_low_gpio_mask(unsigned int irq)
+static void puv3_low_gpio_mask(struct irq_data *d)
 {
-	INTC_ICMR &= ~(1 << irq);
+	INTC_ICMR &= ~(1 << d->irq);
 }
 
-static void puv3_low_gpio_unmask(unsigned int irq)
+static void puv3_low_gpio_unmask(struct irq_data *d)
 {
-	INTC_ICMR |= 1 << irq;
+	INTC_ICMR |= 1 << d->irq;
 }
 
-static int puv3_low_gpio_wake(unsigned int irq, unsigned int on)
+static int puv3_low_gpio_wake(struct irq_data *d, unsigned int on)
 {
 	if (on)
-		PM_PWER |= 1 << irq;
+		PM_PWER |= 1 << d->irq;
 	else
-		PM_PWER &= ~(1 << irq);
+		PM_PWER &= ~(1 << d->irq);
 	return 0;
 }
 
 static struct irq_chip puv3_low_gpio_chip = {
 	.name		= "GPIO-low",
-	.ack		= puv3_low_gpio_ack,
-	.mask		= puv3_low_gpio_mask,
-	.unmask		= puv3_low_gpio_unmask,
-	.set_type	= puv3_gpio_type,
-	.set_wake	= puv3_low_gpio_wake,
+	.irq_ack	= puv3_low_gpio_ack,
+	.irq_mask	= puv3_low_gpio_mask,
+	.irq_unmask	= puv3_low_gpio_unmask,
+	.irq_set_type	= puv3_gpio_type,
+	.irq_set_wake	= puv3_low_gpio_wake,
 };
 
 /*
@@ -142,16 +142,16 @@ puv3_gpio_handler(unsigned int irq, struct irq_desc *desc)
  * In addition, the IRQs are all collected up into one bit in the
  * interrupt controller registers.
  */
-static void puv3_high_gpio_ack(unsigned int irq)
+static void puv3_high_gpio_ack(struct irq_data *d)
 {
-	unsigned int mask = GPIO_MASK(irq);
+	unsigned int mask = GPIO_MASK(d->irq);
 
 	GPIO_GEDR = mask;
 }
 
-static void puv3_high_gpio_mask(unsigned int irq)
+static void puv3_high_gpio_mask(struct irq_data *d)
 {
-	unsigned int mask = GPIO_MASK(irq);
+	unsigned int mask = GPIO_MASK(d->irq);
 
 	GPIO_IRQ_mask &= ~mask;
 
@@ -159,9 +159,9 @@ static void puv3_high_gpio_mask(unsigned int irq)
 	GPIO_GFER &= ~mask;
 }
 
-static void puv3_high_gpio_unmask(unsigned int irq)
+static void puv3_high_gpio_unmask(struct irq_data *d)
 {
-	unsigned int mask = GPIO_MASK(irq);
+	unsigned int mask = GPIO_MASK(d->irq);
 
 	GPIO_IRQ_mask |= mask;
 
@@ -169,7 +169,7 @@ static void puv3_high_gpio_unmask(unsigned int irq)
 	GPIO_GFER = GPIO_IRQ_falling_edge & GPIO_IRQ_mask;
 }
 
-static int puv3_high_gpio_wake(unsigned int irq, unsigned int on)
+static int puv3_high_gpio_wake(struct irq_data *d, unsigned int on)
 {
 	if (on)
 		PM_PWER |= PM_PWER_GPIOHIGH;
@@ -180,33 +180,33 @@ static int puv3_high_gpio_wake(unsigned int irq, unsigned int on)
 
 static struct irq_chip puv3_high_gpio_chip = {
 	.name		= "GPIO-high",
-	.ack		= puv3_high_gpio_ack,
-	.mask		= puv3_high_gpio_mask,
-	.unmask		= puv3_high_gpio_unmask,
-	.set_type	= puv3_gpio_type,
-	.set_wake	= puv3_high_gpio_wake,
+	.irq_ack	= puv3_high_gpio_ack,
+	.irq_mask	= puv3_high_gpio_mask,
+	.irq_unmask	= puv3_high_gpio_unmask,
+	.irq_set_type	= puv3_gpio_type,
+	.irq_set_wake	= puv3_high_gpio_wake,
 };
 
 /*
  * We don't need to ACK IRQs on the PKUnity unless they're GPIOs
  * this is for internal IRQs i.e. from 8 to 31.
  */
-static void puv3_mask_irq(unsigned int irq)
+static void puv3_mask_irq(struct irq_data *d)
 {
-	INTC_ICMR &= ~(1 << irq);
+	INTC_ICMR &= ~(1 << d->irq);
 }
 
-static void puv3_unmask_irq(unsigned int irq)
+static void puv3_unmask_irq(struct irq_data *d)
 {
-	INTC_ICMR |= (1 << irq);
+	INTC_ICMR |= (1 << d->irq);
 }
 
 /*
  * Apart form GPIOs, only the RTC alarm can be a wakeup event.
  */
-static int puv3_set_wake(unsigned int irq, unsigned int on)
+static int puv3_set_wake(struct irq_data *d, unsigned int on)
 {
-	if (irq == IRQ_RTCAlarm) {
+	if (d->irq == IRQ_RTCAlarm) {
 		if (on)
 			PM_PWER |= PM_PWER_RTC;
 		else
@@ -218,10 +218,10 @@ static int puv3_set_wake(unsigned int irq, unsigned int on)
 
 static struct irq_chip puv3_normal_chip = {
 	.name		= "PKUnity-v3",
-	.ack		= puv3_mask_irq,
-	.mask		= puv3_mask_irq,
-	.unmask		= puv3_unmask_irq,
-	.set_wake	= puv3_set_wake,
+	.irq_ack	= puv3_mask_irq,
+	.irq_mask	= puv3_mask_irq,
+	.irq_unmask	= puv3_unmask_irq,
+	.irq_set_wake	= puv3_set_wake,
 };
 
 static struct resource irq_resource = {
@@ -383,7 +383,7 @@ int show_interrupts(struct seq_file *p, void *v)
 		seq_printf(p, "%3d: ", i);
 		for_each_present_cpu(cpu)
 			seq_printf(p, "%10u ", kstat_irqs_cpu(i, cpu));
-		seq_printf(p, " %10s", desc->chip->name ? : "-");
+		seq_printf(p, " %10s", desc->irq_data.chip->name ? : "-");
 		seq_printf(p, "  %s", action->name);
 		for (action = action->next; action; action = action->next)
 			seq_printf(p, ", %s", action->name);

commit 752bcb4d02ccfd5e7a8d810424154169b4cca8ae
Author: GuanXuetao <gxt@mprc.pku.edu.cn>
Date:   Sat Jan 15 18:19:35 2011 +0800

    unicore32 core architecture: interrupts ang gpio handling
    
    This patch implements interrupts and gpio handling.
    UniCore32 has 9 gpio interrupt sources.
    And gpio device operations are also here.
    
    Signed-off-by: Guan Xuetao <gxt@mprc.pku.edu.cn>

diff --git a/arch/unicore32/kernel/irq.c b/arch/unicore32/kernel/irq.c
new file mode 100644
index 000000000000..7c211f597833
--- /dev/null
+++ b/arch/unicore32/kernel/irq.c
@@ -0,0 +1,426 @@
+/*
+ * linux/arch/unicore32/kernel/irq.c
+ *
+ * Code specific to PKUnity SoC and UniCore ISA
+ *
+ * Copyright (C) 2001-2010 GUAN Xue-tao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/random.h>
+#include <linux/smp.h>
+#include <linux/init.h>
+#include <linux/seq_file.h>
+#include <linux/errno.h>
+#include <linux/list.h>
+#include <linux/kallsyms.h>
+#include <linux/proc_fs.h>
+#include <linux/sysdev.h>
+#include <linux/gpio.h>
+
+#include <asm/system.h>
+#include <mach/hardware.h>
+
+#include "setup.h"
+
+/*
+ * PKUnity GPIO edge detection for IRQs:
+ * IRQs are generated on Falling-Edge, Rising-Edge, or both.
+ * Use this instead of directly setting GRER/GFER.
+ */
+static int GPIO_IRQ_rising_edge;
+static int GPIO_IRQ_falling_edge;
+static int GPIO_IRQ_mask = 0;
+
+#define GPIO_MASK(irq)		(1 << (irq - IRQ_GPIO0))
+
+static int puv3_gpio_type(unsigned int irq, unsigned int type)
+{
+	unsigned int mask;
+
+	if (irq < IRQ_GPIOHIGH)
+		mask = 1 << irq;
+	else
+		mask = GPIO_MASK(irq);
+
+	if (type == IRQ_TYPE_PROBE) {
+		if ((GPIO_IRQ_rising_edge | GPIO_IRQ_falling_edge) & mask)
+			return 0;
+		type = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;
+	}
+
+	if (type & IRQ_TYPE_EDGE_RISING)
+		GPIO_IRQ_rising_edge |= mask;
+	else
+		GPIO_IRQ_rising_edge &= ~mask;
+	if (type & IRQ_TYPE_EDGE_FALLING)
+		GPIO_IRQ_falling_edge |= mask;
+	else
+		GPIO_IRQ_falling_edge &= ~mask;
+
+	GPIO_GRER = GPIO_IRQ_rising_edge & GPIO_IRQ_mask;
+	GPIO_GFER = GPIO_IRQ_falling_edge & GPIO_IRQ_mask;
+
+	return 0;
+}
+
+/*
+ * GPIO IRQs must be acknowledged.  This is for IRQs from 0 to 7.
+ */
+static void puv3_low_gpio_ack(unsigned int irq)
+{
+	GPIO_GEDR = (1 << irq);
+}
+
+static void puv3_low_gpio_mask(unsigned int irq)
+{
+	INTC_ICMR &= ~(1 << irq);
+}
+
+static void puv3_low_gpio_unmask(unsigned int irq)
+{
+	INTC_ICMR |= 1 << irq;
+}
+
+static int puv3_low_gpio_wake(unsigned int irq, unsigned int on)
+{
+	if (on)
+		PM_PWER |= 1 << irq;
+	else
+		PM_PWER &= ~(1 << irq);
+	return 0;
+}
+
+static struct irq_chip puv3_low_gpio_chip = {
+	.name		= "GPIO-low",
+	.ack		= puv3_low_gpio_ack,
+	.mask		= puv3_low_gpio_mask,
+	.unmask		= puv3_low_gpio_unmask,
+	.set_type	= puv3_gpio_type,
+	.set_wake	= puv3_low_gpio_wake,
+};
+
+/*
+ * IRQ8 (GPIO0 through 27) handler.  We enter here with the
+ * irq_controller_lock held, and IRQs disabled.  Decode the IRQ
+ * and call the handler.
+ */
+static void
+puv3_gpio_handler(unsigned int irq, struct irq_desc *desc)
+{
+	unsigned int mask;
+
+	mask = GPIO_GEDR;
+	do {
+		/*
+		 * clear down all currently active IRQ sources.
+		 * We will be processing them all.
+		 */
+		GPIO_GEDR = mask;
+
+		irq = IRQ_GPIO0;
+		do {
+			if (mask & 1)
+				generic_handle_irq(irq);
+			mask >>= 1;
+			irq++;
+		} while (mask);
+		mask = GPIO_GEDR;
+	} while (mask);
+}
+
+/*
+ * GPIO0-27 edge IRQs need to be handled specially.
+ * In addition, the IRQs are all collected up into one bit in the
+ * interrupt controller registers.
+ */
+static void puv3_high_gpio_ack(unsigned int irq)
+{
+	unsigned int mask = GPIO_MASK(irq);
+
+	GPIO_GEDR = mask;
+}
+
+static void puv3_high_gpio_mask(unsigned int irq)
+{
+	unsigned int mask = GPIO_MASK(irq);
+
+	GPIO_IRQ_mask &= ~mask;
+
+	GPIO_GRER &= ~mask;
+	GPIO_GFER &= ~mask;
+}
+
+static void puv3_high_gpio_unmask(unsigned int irq)
+{
+	unsigned int mask = GPIO_MASK(irq);
+
+	GPIO_IRQ_mask |= mask;
+
+	GPIO_GRER = GPIO_IRQ_rising_edge & GPIO_IRQ_mask;
+	GPIO_GFER = GPIO_IRQ_falling_edge & GPIO_IRQ_mask;
+}
+
+static int puv3_high_gpio_wake(unsigned int irq, unsigned int on)
+{
+	if (on)
+		PM_PWER |= PM_PWER_GPIOHIGH;
+	else
+		PM_PWER &= ~PM_PWER_GPIOHIGH;
+	return 0;
+}
+
+static struct irq_chip puv3_high_gpio_chip = {
+	.name		= "GPIO-high",
+	.ack		= puv3_high_gpio_ack,
+	.mask		= puv3_high_gpio_mask,
+	.unmask		= puv3_high_gpio_unmask,
+	.set_type	= puv3_gpio_type,
+	.set_wake	= puv3_high_gpio_wake,
+};
+
+/*
+ * We don't need to ACK IRQs on the PKUnity unless they're GPIOs
+ * this is for internal IRQs i.e. from 8 to 31.
+ */
+static void puv3_mask_irq(unsigned int irq)
+{
+	INTC_ICMR &= ~(1 << irq);
+}
+
+static void puv3_unmask_irq(unsigned int irq)
+{
+	INTC_ICMR |= (1 << irq);
+}
+
+/*
+ * Apart form GPIOs, only the RTC alarm can be a wakeup event.
+ */
+static int puv3_set_wake(unsigned int irq, unsigned int on)
+{
+	if (irq == IRQ_RTCAlarm) {
+		if (on)
+			PM_PWER |= PM_PWER_RTC;
+		else
+			PM_PWER &= ~PM_PWER_RTC;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static struct irq_chip puv3_normal_chip = {
+	.name		= "PKUnity-v3",
+	.ack		= puv3_mask_irq,
+	.mask		= puv3_mask_irq,
+	.unmask		= puv3_unmask_irq,
+	.set_wake	= puv3_set_wake,
+};
+
+static struct resource irq_resource = {
+	.name	= "irqs",
+	.start	= PKUNITY_INTC_BASE,
+	.end	= PKUNITY_INTC_BASE + 0xFFFFF,
+};
+
+static struct puv3_irq_state {
+	unsigned int	saved;
+	unsigned int	icmr;
+	unsigned int	iclr;
+	unsigned int	iccr;
+} puv3_irq_state;
+
+static int puv3_irq_suspend(struct sys_device *dev, pm_message_t state)
+{
+	struct puv3_irq_state *st = &puv3_irq_state;
+
+	st->saved = 1;
+	st->icmr = INTC_ICMR;
+	st->iclr = INTC_ICLR;
+	st->iccr = INTC_ICCR;
+
+	/*
+	 * Disable all GPIO-based interrupts.
+	 */
+	INTC_ICMR &= ~(0x1ff);
+
+	/*
+	 * Set the appropriate edges for wakeup.
+	 */
+	GPIO_GRER = PM_PWER & GPIO_IRQ_rising_edge;
+	GPIO_GFER = PM_PWER & GPIO_IRQ_falling_edge;
+
+	/*
+	 * Clear any pending GPIO interrupts.
+	 */
+	GPIO_GEDR = GPIO_GEDR;
+
+	return 0;
+}
+
+static int puv3_irq_resume(struct sys_device *dev)
+{
+	struct puv3_irq_state *st = &puv3_irq_state;
+
+	if (st->saved) {
+		INTC_ICCR = st->iccr;
+		INTC_ICLR = st->iclr;
+
+		GPIO_GRER = GPIO_IRQ_rising_edge & GPIO_IRQ_mask;
+		GPIO_GFER = GPIO_IRQ_falling_edge & GPIO_IRQ_mask;
+
+		INTC_ICMR = st->icmr;
+	}
+	return 0;
+}
+
+static struct sysdev_class puv3_irq_sysclass = {
+	.name		= "pkunity-irq",
+	.suspend	= puv3_irq_suspend,
+	.resume		= puv3_irq_resume,
+};
+
+static struct sys_device puv3_irq_device = {
+	.id		= 0,
+	.cls		= &puv3_irq_sysclass,
+};
+
+static int __init puv3_irq_init_devicefs(void)
+{
+	sysdev_class_register(&puv3_irq_sysclass);
+	return sysdev_register(&puv3_irq_device);
+}
+
+device_initcall(puv3_irq_init_devicefs);
+
+void __init init_IRQ(void)
+{
+	unsigned int irq;
+
+	request_resource(&iomem_resource, &irq_resource);
+
+	/* disable all IRQs */
+	INTC_ICMR = 0;
+
+	/* all IRQs are IRQ, not REAL */
+	INTC_ICLR = 0;
+
+	/* clear all GPIO edge detects */
+	GPIO_GPIR = FMASK(8, 0) & ~FIELD(1, 1, GPI_SOFF_REQ);
+	GPIO_GFER = 0;
+	GPIO_GRER = 0;
+	GPIO_GEDR = 0x0FFFFFFF;
+
+	INTC_ICCR = 1;
+
+	for (irq = 0; irq < IRQ_GPIOHIGH; irq++) {
+		set_irq_chip(irq, &puv3_low_gpio_chip);
+		set_irq_handler(irq, handle_edge_irq);
+		irq_modify_status(irq,
+			IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN,
+			0);
+	}
+
+	for (irq = IRQ_GPIOHIGH + 1; irq < IRQ_GPIO0; irq++) {
+		set_irq_chip(irq, &puv3_normal_chip);
+		set_irq_handler(irq, handle_level_irq);
+		irq_modify_status(irq,
+			IRQ_NOREQUEST | IRQ_NOAUTOEN,
+			IRQ_NOPROBE);
+	}
+
+	for (irq = IRQ_GPIO0; irq <= IRQ_GPIO27; irq++) {
+		set_irq_chip(irq, &puv3_high_gpio_chip);
+		set_irq_handler(irq, handle_edge_irq);
+		irq_modify_status(irq,
+			IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN,
+			0);
+	}
+
+	/*
+	 * Install handler for GPIO 0-27 edge detect interrupts
+	 */
+	set_irq_chip(IRQ_GPIOHIGH, &puv3_normal_chip);
+	set_irq_chained_handler(IRQ_GPIOHIGH, puv3_gpio_handler);
+
+#ifdef CONFIG_PUV3_GPIO
+	puv3_init_gpio();
+#endif
+}
+
+int show_interrupts(struct seq_file *p, void *v)
+{
+	int i = *(loff_t *) v, cpu;
+	struct irq_desc *desc;
+	struct irqaction *action;
+	unsigned long flags;
+
+	if (i == 0) {
+		char cpuname[12];
+
+		seq_printf(p, "    ");
+		for_each_present_cpu(cpu) {
+			sprintf(cpuname, "CPU%d", cpu);
+			seq_printf(p, " %10s", cpuname);
+		}
+		seq_putc(p, '\n');
+	}
+
+	if (i < nr_irqs) {
+		desc = irq_to_desc(i);
+		raw_spin_lock_irqsave(&desc->lock, flags);
+		action = desc->action;
+		if (!action)
+			goto unlock;
+
+		seq_printf(p, "%3d: ", i);
+		for_each_present_cpu(cpu)
+			seq_printf(p, "%10u ", kstat_irqs_cpu(i, cpu));
+		seq_printf(p, " %10s", desc->chip->name ? : "-");
+		seq_printf(p, "  %s", action->name);
+		for (action = action->next; action; action = action->next)
+			seq_printf(p, ", %s", action->name);
+
+		seq_putc(p, '\n');
+unlock:
+		raw_spin_unlock_irqrestore(&desc->lock, flags);
+	} else if (i == nr_irqs) {
+		seq_printf(p, "Error in interrupt!\n");
+	}
+	return 0;
+}
+
+/*
+ * do_IRQ handles all hardware IRQ's.  Decoded IRQs should not
+ * come via this function.  Instead, they should provide their
+ * own 'handler'
+ */
+asmlinkage void asm_do_IRQ(unsigned int irq, struct pt_regs *regs)
+{
+	struct pt_regs *old_regs = set_irq_regs(regs);
+
+	irq_enter();
+
+	/*
+	 * Some hardware gives randomly wrong interrupts.  Rather
+	 * than crashing, do something sensible.
+	 */
+	if (unlikely(irq >= nr_irqs)) {
+		if (printk_ratelimit())
+			printk(KERN_WARNING "Bad IRQ%u\n", irq);
+		ack_bad_irq(irq);
+	} else {
+		generic_handle_irq(irq);
+	}
+
+	irq_exit();
+	set_irq_regs(old_regs);
+}
+
