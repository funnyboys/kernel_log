commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/openrisc/kernel/irq.c b/arch/openrisc/kernel/irq.c
index 5f9445effaf8..c38fa863afa8 100644
--- a/arch/openrisc/kernel/irq.c
+++ b/arch/openrisc/kernel/irq.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * OpenRISC irq.c
  *
@@ -7,11 +8,6 @@
  *
  * Modifications for the OpenRISC architecture:
  * Copyright (C) 2010-2011 Jonas Bonn <jonas@southpole.se>
- *
- *      This program is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU General Public License
- *      as published by the Free Software Foundation; either version
- *      2 of the License, or (at your option) any later version.
  */
 
 #include <linux/interrupt.h>

commit c5ca4560de0f04a3c872bdd17ae3378762c66bd2
Author: Palmer Dabbelt <palmer@sifive.com>
Date:   Fri Jun 22 10:01:25 2018 -0700

    openrisc: Use the new GENERIC_IRQ_MULTI_HANDLER
    
    It appears that openrisc copied arm64's GENERIC_IRQ_MULTI_HANDLER code
    (which came from arm).  Cnvert it to use the generic version.
    
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Stafford Horne <shorne@gmail.com>
    Cc: linux@armlinux.org.uk
    Cc: catalin.marinas@arm.com
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: jonas@southpole.se
    Cc: stefan.kristiansson@saunalahti.fi
    Cc: jason@lakedaemon.net
    Cc: marc.zyngier@arm.com
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: nicolas.pitre@linaro.org
    Cc: vladimir.murzin@arm.com
    Cc: keescook@chromium.org
    Cc: jinb.park7@gmail.com
    Cc: yamada.masahiro@socionext.com
    Cc: alexandre.belloni@bootlin.com
    Cc: pombredanne@nexb.com
    Cc: Greg KH <gregkh@linuxfoundation.org>
    Cc: kstewart@linuxfoundation.org
    Cc: jhogan@kernel.org
    Cc: mark.rutland@arm.com
    Cc: ard.biesheuvel@linaro.org
    Cc: james.morse@arm.com
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: openrisc@lists.librecores.org
    Link: https://lkml.kernel.org/r/20180622170126.6308-5-palmer@sifive.com

diff --git a/arch/openrisc/kernel/irq.c b/arch/openrisc/kernel/irq.c
index 35e478a93116..5f9445effaf8 100644
--- a/arch/openrisc/kernel/irq.c
+++ b/arch/openrisc/kernel/irq.c
@@ -41,13 +41,6 @@ void __init init_IRQ(void)
 	irqchip_init();
 }
 
-static void (*handle_arch_irq)(struct pt_regs *);
-
-void __init set_handle_irq(void (*handle_irq)(struct pt_regs *))
-{
-	handle_arch_irq = handle_irq;
-}
-
 void __irq_entry do_IRQ(struct pt_regs *regs)
 {
 	handle_arch_irq(regs);

commit 087fe000f086c933f831044cbd0e69b4e140f38c
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Aug 26 11:03:41 2014 +0100

    openrisc: Get rid of handle_IRQ
    
    The openrisc irqchip driver has been converted to handle_domain_irq,
    making it possible to remove the handle_IRQ stub entierely.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Stefan Kristiansson <stefan.kristiansson@saunalahti.fi>
    Link: https://lkml.kernel.org/r/1409047421-27649-27-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/openrisc/kernel/irq.c b/arch/openrisc/kernel/irq.c
index e9aaf280b7d9..35e478a93116 100644
--- a/arch/openrisc/kernel/irq.c
+++ b/arch/openrisc/kernel/irq.c
@@ -48,11 +48,6 @@ void __init set_handle_irq(void (*handle_irq)(struct pt_regs *))
 	handle_arch_irq = handle_irq;
 }
 
-void handle_IRQ(unsigned int irq, struct pt_regs *regs)
-{
-	__handle_domain_irq(NULL, irq, false, regs);
-}
-
 void __irq_entry do_IRQ(struct pt_regs *regs)
 {
 	handle_arch_irq(regs);

commit d1f6f28f68507e3ae67203de3e7ab7e5b9bf0082
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Aug 26 11:03:19 2014 +0100

    openrisc: Convert handle_IRQ to use __handle_domain_irq
    
    In order to limit code duplication, convert the architecture specific
    handle_IRQ to use the generic __handle_domain_irq function.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Stefan Kristiansson <stefan.kristiansson@saunalahti.fi>
    Link: https://lkml.kernel.org/r/1409047421-27649-5-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/openrisc/kernel/irq.c b/arch/openrisc/kernel/irq.c
index 967eb1430203..e9aaf280b7d9 100644
--- a/arch/openrisc/kernel/irq.c
+++ b/arch/openrisc/kernel/irq.c
@@ -50,14 +50,7 @@ void __init set_handle_irq(void (*handle_irq)(struct pt_regs *))
 
 void handle_IRQ(unsigned int irq, struct pt_regs *regs)
 {
-	struct pt_regs *old_regs = set_irq_regs(regs);
-
-	irq_enter();
-
-	generic_handle_irq(irq);
-
-	irq_exit();
-	set_irq_regs(old_regs);
+	__handle_domain_irq(NULL, irq, false, regs);
 }
 
 void __irq_entry do_IRQ(struct pt_regs *regs)

commit 4db8e6d20ccb158de2e06d30a1a421f4d053e429
Author: Stefan Kristiansson <stefan.kristiansson@saunalahti.fi>
Date:   Mon May 26 23:31:42 2014 +0300

    irqchip: or1k-pic: Migrate from arch/openrisc/
    
    In addition to consolidating the or1k-pic with other interrupt
    controllers, this makes OpenRISC less tied to its on-cpu
    interrupt controller.
    
    All or1k-pic specific parts are moved out of irq.c and into
    drivers/irqchip/irq-or1k-pic.c
    
    In that transition, the functionality have been divided into
    three chip variants.
    One that handles level triggered interrupts, one that handles edge
    triggered interrupts and one that handles the interrupt
    controller that is present in the or1200 OpenRISC cpu
    implementation.
    
    Signed-off-by: Stefan Kristiansson <stefan.kristiansson@saunalahti.fi>
    Link: https://lkml.kernel.org/r/1401136302-27654-1-git-send-email-stefan.kristiansson@saunalahti.fi
    Acked-by: Jonas Bonn <jonas@southpole.se>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/openrisc/kernel/irq.c b/arch/openrisc/kernel/irq.c
index 8ec77bc9f1e7..967eb1430203 100644
--- a/arch/openrisc/kernel/irq.c
+++ b/arch/openrisc/kernel/irq.c
@@ -16,11 +16,10 @@
 
 #include <linux/interrupt.h>
 #include <linux/init.h>
-#include <linux/of.h>
 #include <linux/ftrace.h>
 #include <linux/irq.h>
+#include <linux/irqchip.h>
 #include <linux/export.h>
-#include <linux/irqdomain.h>
 #include <linux/irqflags.h>
 
 /* read interrupt enabled status */
@@ -37,150 +36,31 @@ void arch_local_irq_restore(unsigned long flags)
 }
 EXPORT_SYMBOL(arch_local_irq_restore);
 
-
-/* OR1K PIC implementation */
-
-/* We're a couple of cycles faster than the generic implementations with
- * these 'fast' versions.
- */
-
-static void or1k_pic_mask(struct irq_data *data)
-{
-	mtspr(SPR_PICMR, mfspr(SPR_PICMR) & ~(1UL << data->hwirq));
-}
-
-static void or1k_pic_unmask(struct irq_data *data)
-{
-	mtspr(SPR_PICMR, mfspr(SPR_PICMR) | (1UL << data->hwirq));
-}
-
-static void or1k_pic_ack(struct irq_data *data)
-{
-	/* EDGE-triggered interrupts need to be ack'ed in order to clear
-	 * the latch.
-	 * LEVEL-triggered interrupts do not need to be ack'ed; however,
-	 * ack'ing the interrupt has no ill-effect and is quicker than
-	 * trying to figure out what type it is...
-	 */
-
-	/* The OpenRISC 1000 spec says to write a 1 to the bit to ack the
-	 * interrupt, but the OR1200 does this backwards and requires a 0
-	 * to be written...
-	 */
-
-#ifdef CONFIG_OR1K_1200
-	/* There are two oddities with the OR1200 PIC implementation:
-	 * i)  LEVEL-triggered interrupts are latched and need to be cleared
-	 * ii) the interrupt latch is cleared by writing a 0 to the bit,
-	 *     as opposed to a 1 as mandated by the spec
-	 */
-
-	mtspr(SPR_PICSR, mfspr(SPR_PICSR) & ~(1UL << data->hwirq));
-#else
-	WARN(1, "Interrupt handling possibly broken\n");
-	mtspr(SPR_PICSR, (1UL << data->hwirq));
-#endif
-}
-
-static void or1k_pic_mask_ack(struct irq_data *data)
-{
-	/* Comments for pic_ack apply here, too */
-
-#ifdef CONFIG_OR1K_1200
-	mtspr(SPR_PICMR, mfspr(SPR_PICMR) & ~(1UL << data->hwirq));
-	mtspr(SPR_PICSR, mfspr(SPR_PICSR) & ~(1UL << data->hwirq));
-#else
-	WARN(1, "Interrupt handling possibly broken\n");
-	mtspr(SPR_PICMR, (1UL << data->hwirq));
-	mtspr(SPR_PICSR, (1UL << data->hwirq));
-#endif
-}
-
-#if 0
-static int or1k_pic_set_type(struct irq_data *data, unsigned int flow_type)
-{
-	/* There's nothing to do in the PIC configuration when changing
-	 * flow type.  Level and edge-triggered interrupts are both
-	 * supported, but it's PIC-implementation specific which type
-	 * is handled. */
-
-	return irq_setup_alt_chip(data, flow_type);
-}
-#endif
-
-static struct irq_chip or1k_dev = {
-	.name = "or1k-PIC",
-	.irq_unmask = or1k_pic_unmask,
-	.irq_mask = or1k_pic_mask,
-	.irq_ack = or1k_pic_ack,
-	.irq_mask_ack = or1k_pic_mask_ack,
-};
-
-static struct irq_domain *root_domain;
-
-static inline int pic_get_irq(int first)
-{
-	int hwirq;
-
-	hwirq = ffs(mfspr(SPR_PICSR) >> first);
-	if (!hwirq)
-		return NO_IRQ;
-	else
-		hwirq = hwirq + first -1;
-
-	return irq_find_mapping(root_domain, hwirq);
-}
-
-
-static int or1k_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hw)
+void __init init_IRQ(void)
 {
-	irq_set_chip_and_handler_name(irq, &or1k_dev,
-				      handle_level_irq, "level");
-	irq_set_status_flags(irq, IRQ_LEVEL | IRQ_NOPROBE);
-
-	return 0;
+	irqchip_init();
 }
 
-static const struct irq_domain_ops or1k_irq_domain_ops = {
-	.xlate = irq_domain_xlate_onecell,
-	.map = or1k_map,
-};
-
-/*
- * This sets up the IRQ domain for the PIC built in to the OpenRISC
- * 1000 CPU.  This is the "root" domain as these are the interrupts
- * that directly trigger an exception in the CPU.
- */
-static void __init or1k_irq_init(void)
-{
-	struct device_node *intc = NULL;
-
-	/* The interrupt controller device node is mandatory */
-	intc = of_find_compatible_node(NULL, NULL, "opencores,or1k-pic");
-	BUG_ON(!intc);
-
-	/* Disable all interrupts until explicitly requested */
-	mtspr(SPR_PICMR, (0UL));
-
-	root_domain = irq_domain_add_linear(intc, 32,
-					    &or1k_irq_domain_ops, NULL);
-}
+static void (*handle_arch_irq)(struct pt_regs *);
 
-void __init init_IRQ(void)
+void __init set_handle_irq(void (*handle_irq)(struct pt_regs *))
 {
-	or1k_irq_init();
+	handle_arch_irq = handle_irq;
 }
 
-void __irq_entry do_IRQ(struct pt_regs *regs)
+void handle_IRQ(unsigned int irq, struct pt_regs *regs)
 {
-	int irq = -1;
 	struct pt_regs *old_regs = set_irq_regs(regs);
 
 	irq_enter();
 
-	while ((irq = pic_get_irq(irq + 1)) != NO_IRQ)
-		generic_handle_irq(irq);
+	generic_handle_irq(irq);
 
 	irq_exit();
 	set_irq_regs(old_regs);
 }
+
+void __irq_entry do_IRQ(struct pt_regs *regs)
+{
+	handle_arch_irq(regs);
+}

commit d23b5799b608112bb799c9b0e1e11ee1da692d76
Author: Gong Tao <gontao0607@gmail.com>
Date:   Fri Sep 21 08:49:58 2012 +0200

    openrisc: mask interrupts in irq_mask_ack function
    
    or1k_pic_mask_ack was failing to actually mask the IRQ.
    
    Signed-off-by: Gong Tao <gongtao0607@gmail.com>
    Signed-off-by: Jonas Bonn <jonas@southpole.se>

diff --git a/arch/openrisc/kernel/irq.c b/arch/openrisc/kernel/irq.c
index 61327985f967..8ec77bc9f1e7 100644
--- a/arch/openrisc/kernel/irq.c
+++ b/arch/openrisc/kernel/irq.c
@@ -87,9 +87,11 @@ static void or1k_pic_mask_ack(struct irq_data *data)
 	/* Comments for pic_ack apply here, too */
 
 #ifdef CONFIG_OR1K_1200
+	mtspr(SPR_PICMR, mfspr(SPR_PICMR) & ~(1UL << data->hwirq));
 	mtspr(SPR_PICSR, mfspr(SPR_PICSR) & ~(1UL << data->hwirq));
 #else
 	WARN(1, "Interrupt handling possibly broken\n");
+	mtspr(SPR_PICMR, (1UL << data->hwirq));
 	mtspr(SPR_PICSR, (1UL << data->hwirq));
 #endif
 }

commit 8eea8a6a9a2af067bd3006f7fefab66a4fb66451
Author: Jonas Bonn <jonas@southpole.se>
Date:   Fri Sep 21 09:19:48 2012 +0200

    openrisc: fix typos in comments and warnings
    
    Signed-off-by: Jonas Bonn <jonas@southpole.se>

diff --git a/arch/openrisc/kernel/irq.c b/arch/openrisc/kernel/irq.c
index 094c394eee5b..61327985f967 100644
--- a/arch/openrisc/kernel/irq.c
+++ b/arch/openrisc/kernel/irq.c
@@ -58,7 +58,7 @@ static void or1k_pic_ack(struct irq_data *data)
 {
 	/* EDGE-triggered interrupts need to be ack'ed in order to clear
 	 * the latch.
-	 * LEVER-triggered interrupts do not need to be ack'ed; however,
+	 * LEVEL-triggered interrupts do not need to be ack'ed; however,
 	 * ack'ing the interrupt has no ill-effect and is quicker than
 	 * trying to figure out what type it is...
 	 */
@@ -77,7 +77,7 @@ static void or1k_pic_ack(struct irq_data *data)
 
 	mtspr(SPR_PICSR, mfspr(SPR_PICSR) & ~(1UL << data->hwirq));
 #else
-	WARN(1, "Interrupt handling possibily broken\n");
+	WARN(1, "Interrupt handling possibly broken\n");
 	mtspr(SPR_PICSR, (1UL << data->hwirq));
 #endif
 }
@@ -89,7 +89,7 @@ static void or1k_pic_mask_ack(struct irq_data *data)
 #ifdef CONFIG_OR1K_1200
 	mtspr(SPR_PICSR, mfspr(SPR_PICSR) & ~(1UL << data->hwirq));
 #else
-	WARN(1, "Interrupt handling possibily broken\n");
+	WARN(1, "Interrupt handling possibly broken\n");
 	mtspr(SPR_PICSR, (1UL << data->hwirq));
 #endif
 }

commit f248ef1cd39dc9900cca5bf0a51b1e80081ecc67
Author: Jonas Bonn <jonas@southpole.se>
Date:   Fri Sep 21 09:17:32 2012 +0200

    openrisc: PIC should act on domain-local irqs
    
    Now that IRQ domains are in use, we should be acting on domain-local
    IRQ numbers (hwirq) instead of 'global' ones.
    
    Signed-off-by: Jonas Bonn <jonas@southpole.se>

diff --git a/arch/openrisc/kernel/irq.c b/arch/openrisc/kernel/irq.c
index e935b9d8eee1..094c394eee5b 100644
--- a/arch/openrisc/kernel/irq.c
+++ b/arch/openrisc/kernel/irq.c
@@ -46,12 +46,12 @@ EXPORT_SYMBOL(arch_local_irq_restore);
 
 static void or1k_pic_mask(struct irq_data *data)
 {
-	mtspr(SPR_PICMR, mfspr(SPR_PICMR) & ~(1UL << data->irq));
+	mtspr(SPR_PICMR, mfspr(SPR_PICMR) & ~(1UL << data->hwirq));
 }
 
 static void or1k_pic_unmask(struct irq_data *data)
 {
-	mtspr(SPR_PICMR, mfspr(SPR_PICMR) | (1UL << data->irq));
+	mtspr(SPR_PICMR, mfspr(SPR_PICMR) | (1UL << data->hwirq));
 }
 
 static void or1k_pic_ack(struct irq_data *data)
@@ -75,10 +75,10 @@ static void or1k_pic_ack(struct irq_data *data)
 	 *     as opposed to a 1 as mandated by the spec
 	 */
 
-	mtspr(SPR_PICSR, mfspr(SPR_PICSR) & ~(1UL << data->irq));
+	mtspr(SPR_PICSR, mfspr(SPR_PICSR) & ~(1UL << data->hwirq));
 #else
 	WARN(1, "Interrupt handling possibily broken\n");
-	mtspr(SPR_PICSR, (1UL << irq));
+	mtspr(SPR_PICSR, (1UL << data->hwirq));
 #endif
 }
 
@@ -87,10 +87,10 @@ static void or1k_pic_mask_ack(struct irq_data *data)
 	/* Comments for pic_ack apply here, too */
 
 #ifdef CONFIG_OR1K_1200
-	mtspr(SPR_PICSR, mfspr(SPR_PICSR) & ~(1UL << data->irq));
+	mtspr(SPR_PICSR, mfspr(SPR_PICSR) & ~(1UL << data->hwirq));
 #else
 	WARN(1, "Interrupt handling possibily broken\n");
-	mtspr(SPR_PICSR, (1UL << irq));
+	mtspr(SPR_PICSR, (1UL << data->hwirq));
 #endif
 }
 

commit ad188f955a79f5501b0cd5bde2b0621b3c78044a
Author: Jonas Bonn <jonas@southpole.se>
Date:   Fri Apr 6 13:04:12 2012 +0200

    openrisc: remove unnecessary includes
    
    Signed-off-by: Jonas Bonn <jonas@southpole.se>

diff --git a/arch/openrisc/kernel/irq.c b/arch/openrisc/kernel/irq.c
index 15c5ea3e98d4..e935b9d8eee1 100644
--- a/arch/openrisc/kernel/irq.c
+++ b/arch/openrisc/kernel/irq.c
@@ -14,15 +14,11 @@
  *      2 of the License, or (at your option) any later version.
  */
 
-#include <linux/ptrace.h>
-#include <linux/errno.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>
 #include <linux/of.h>
 #include <linux/ftrace.h>
 #include <linux/irq.h>
-#include <linux/seq_file.h>
-#include <linux/kernel_stat.h>
 #include <linux/export.h>
 #include <linux/irqdomain.h>
 #include <linux/irqflags.h>

commit b4c4c6ee93501a46d58d5511fc8bb9aeb4508c6d
Author: Jonas Bonn <jonas@southpole.se>
Date:   Fri Apr 6 12:52:54 2012 +0200

    openrisc: implement irqdomains
    
    This moves OpenRISC to using the irqdomain infrastructure.  This doesn't
    fundamentally change anything other than that it will be easier to have
    multiple interrupt controllers in the future.
    
    Signed-off-by: Jonas Bonn <jonas@southpole.se>

diff --git a/arch/openrisc/kernel/irq.c b/arch/openrisc/kernel/irq.c
index 4bfead220956..15c5ea3e98d4 100644
--- a/arch/openrisc/kernel/irq.c
+++ b/arch/openrisc/kernel/irq.c
@@ -24,7 +24,7 @@
 #include <linux/seq_file.h>
 #include <linux/kernel_stat.h>
 #include <linux/export.h>
-
+#include <linux/irqdomain.h>
 #include <linux/irqflags.h>
 
 /* read interrupt enabled status */
@@ -98,6 +98,7 @@ static void or1k_pic_mask_ack(struct irq_data *data)
 #endif
 }
 
+#if 0
 static int or1k_pic_set_type(struct irq_data *data, unsigned int flow_type)
 {
 	/* There's nothing to do in the PIC configuration when changing
@@ -107,43 +108,64 @@ static int or1k_pic_set_type(struct irq_data *data, unsigned int flow_type)
 
 	return irq_setup_alt_chip(data, flow_type);
 }
+#endif
+
+static struct irq_chip or1k_dev = {
+	.name = "or1k-PIC",
+	.irq_unmask = or1k_pic_unmask,
+	.irq_mask = or1k_pic_mask,
+	.irq_ack = or1k_pic_ack,
+	.irq_mask_ack = or1k_pic_mask_ack,
+};
+
+static struct irq_domain *root_domain;
 
 static inline int pic_get_irq(int first)
 {
-	int irq;
+	int hwirq;
 
-	irq = ffs(mfspr(SPR_PICSR) >> first);
+	hwirq = ffs(mfspr(SPR_PICSR) >> first);
+	if (!hwirq)
+		return NO_IRQ;
+	else
+		hwirq = hwirq + first -1;
 
-	return irq ? irq + first - 1 : NO_IRQ;
+	return irq_find_mapping(root_domain, hwirq);
 }
 
-static void __init or1k_irq_init(void)
+
+static int or1k_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hw)
 {
-	struct irq_chip_generic *gc;
-	struct irq_chip_type *ct;
+	irq_set_chip_and_handler_name(irq, &or1k_dev,
+				      handle_level_irq, "level");
+	irq_set_status_flags(irq, IRQ_LEVEL | IRQ_NOPROBE);
 
-	/* Disable all interrupts until explicitly requested */
-	mtspr(SPR_PICMR, (0UL));
+	return 0;
+}
 
-	gc = irq_alloc_generic_chip("or1k-PIC", 1, 0, 0, handle_level_irq);
-	ct = gc->chip_types;
+static const struct irq_domain_ops or1k_irq_domain_ops = {
+	.xlate = irq_domain_xlate_onecell,
+	.map = or1k_map,
+};
 
-	ct->chip.irq_unmask = or1k_pic_unmask;
-	ct->chip.irq_mask = or1k_pic_mask;
-	ct->chip.irq_ack = or1k_pic_ack;
-	ct->chip.irq_mask_ack = or1k_pic_mask_ack;
-	ct->chip.irq_set_type = or1k_pic_set_type;
+/*
+ * This sets up the IRQ domain for the PIC built in to the OpenRISC
+ * 1000 CPU.  This is the "root" domain as these are the interrupts
+ * that directly trigger an exception in the CPU.
+ */
+static void __init or1k_irq_init(void)
+{
+	struct device_node *intc = NULL;
 
-	/* The OR1K PIC can handle both level and edge trigged
-	 * interrupts in roughly the same manner
-	 */
-#if 0
-	/* FIXME: chip.type??? */
-	ct->chip.type = IRQ_TYPE_EDGE_BOTH | IRQ_TYPE_LEVEL_MASK;
-#endif
+	/* The interrupt controller device node is mandatory */
+	intc = of_find_compatible_node(NULL, NULL, "opencores,or1k-pic");
+	BUG_ON(!intc);
 
-	irq_setup_generic_chip(gc, IRQ_MSK(NR_IRQS), 0,
-			       IRQ_NOREQUEST, IRQ_LEVEL | IRQ_NOPROBE);
+	/* Disable all interrupts until explicitly requested */
+	mtspr(SPR_PICMR, (0UL));
+
+	root_domain = irq_domain_add_linear(intc, 32,
+					    &or1k_irq_domain_ops, NULL);
 }
 
 void __init init_IRQ(void)
@@ -164,10 +186,3 @@ void __irq_entry do_IRQ(struct pt_regs *regs)
 	irq_exit();
 	set_irq_regs(old_regs);
 }
-
-unsigned int irq_create_of_mapping(struct device_node *controller,
-				   const u32 *intspec, unsigned int intsize)
-{
-	return intspec[0];
-}
-EXPORT_SYMBOL_GPL(irq_create_of_mapping);

commit abdf8b5e07884a183938969253770164d60b87cb
Author: Jonas Bonn <jonas@southpole.se>
Date:   Wed Feb 15 15:00:32 2012 +0100

    openrisc: include export.h for EXPORT_SYMBOL
    
    Use of EXPORT_SYMBOL requires inclusion of export.h
    
    Signed-off-by: Jonas Bonn <jonas@southpole.se>

diff --git a/arch/openrisc/kernel/irq.c b/arch/openrisc/kernel/irq.c
index 59b302338331..4bfead220956 100644
--- a/arch/openrisc/kernel/irq.c
+++ b/arch/openrisc/kernel/irq.c
@@ -23,6 +23,7 @@
 #include <linux/irq.h>
 #include <linux/seq_file.h>
 #include <linux/kernel_stat.h>
+#include <linux/export.h>
 
 #include <linux/irqflags.h>
 

commit 816ebaa8b6ea8f97515a40e25076f297d0304611
Author: Jonas Bonn <jonas@southpole.se>
Date:   Sat Jun 4 22:18:56 2011 +0300

    OpenRISC: IRQ
    
    This patch adds support for the OpenRISC PIC.
    
    Signed-off-by: Jonas Bonn <jonas@southpole.se>
    Cc: tglx@linutronix.de
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/openrisc/kernel/irq.c b/arch/openrisc/kernel/irq.c
new file mode 100644
index 000000000000..59b302338331
--- /dev/null
+++ b/arch/openrisc/kernel/irq.c
@@ -0,0 +1,172 @@
+/*
+ * OpenRISC irq.c
+ *
+ * Linux architectural port borrowing liberally from similar works of
+ * others.  All original copyrights apply as per the original source
+ * declaration.
+ *
+ * Modifications for the OpenRISC architecture:
+ * Copyright (C) 2010-2011 Jonas Bonn <jonas@southpole.se>
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/ptrace.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/of.h>
+#include <linux/ftrace.h>
+#include <linux/irq.h>
+#include <linux/seq_file.h>
+#include <linux/kernel_stat.h>
+
+#include <linux/irqflags.h>
+
+/* read interrupt enabled status */
+unsigned long arch_local_save_flags(void)
+{
+	return mfspr(SPR_SR) & (SPR_SR_IEE|SPR_SR_TEE);
+}
+EXPORT_SYMBOL(arch_local_save_flags);
+
+/* set interrupt enabled status */
+void arch_local_irq_restore(unsigned long flags)
+{
+	mtspr(SPR_SR, ((mfspr(SPR_SR) & ~(SPR_SR_IEE|SPR_SR_TEE)) | flags));
+}
+EXPORT_SYMBOL(arch_local_irq_restore);
+
+
+/* OR1K PIC implementation */
+
+/* We're a couple of cycles faster than the generic implementations with
+ * these 'fast' versions.
+ */
+
+static void or1k_pic_mask(struct irq_data *data)
+{
+	mtspr(SPR_PICMR, mfspr(SPR_PICMR) & ~(1UL << data->irq));
+}
+
+static void or1k_pic_unmask(struct irq_data *data)
+{
+	mtspr(SPR_PICMR, mfspr(SPR_PICMR) | (1UL << data->irq));
+}
+
+static void or1k_pic_ack(struct irq_data *data)
+{
+	/* EDGE-triggered interrupts need to be ack'ed in order to clear
+	 * the latch.
+	 * LEVER-triggered interrupts do not need to be ack'ed; however,
+	 * ack'ing the interrupt has no ill-effect and is quicker than
+	 * trying to figure out what type it is...
+	 */
+
+	/* The OpenRISC 1000 spec says to write a 1 to the bit to ack the
+	 * interrupt, but the OR1200 does this backwards and requires a 0
+	 * to be written...
+	 */
+
+#ifdef CONFIG_OR1K_1200
+	/* There are two oddities with the OR1200 PIC implementation:
+	 * i)  LEVEL-triggered interrupts are latched and need to be cleared
+	 * ii) the interrupt latch is cleared by writing a 0 to the bit,
+	 *     as opposed to a 1 as mandated by the spec
+	 */
+
+	mtspr(SPR_PICSR, mfspr(SPR_PICSR) & ~(1UL << data->irq));
+#else
+	WARN(1, "Interrupt handling possibily broken\n");
+	mtspr(SPR_PICSR, (1UL << irq));
+#endif
+}
+
+static void or1k_pic_mask_ack(struct irq_data *data)
+{
+	/* Comments for pic_ack apply here, too */
+
+#ifdef CONFIG_OR1K_1200
+	mtspr(SPR_PICSR, mfspr(SPR_PICSR) & ~(1UL << data->irq));
+#else
+	WARN(1, "Interrupt handling possibily broken\n");
+	mtspr(SPR_PICSR, (1UL << irq));
+#endif
+}
+
+static int or1k_pic_set_type(struct irq_data *data, unsigned int flow_type)
+{
+	/* There's nothing to do in the PIC configuration when changing
+	 * flow type.  Level and edge-triggered interrupts are both
+	 * supported, but it's PIC-implementation specific which type
+	 * is handled. */
+
+	return irq_setup_alt_chip(data, flow_type);
+}
+
+static inline int pic_get_irq(int first)
+{
+	int irq;
+
+	irq = ffs(mfspr(SPR_PICSR) >> first);
+
+	return irq ? irq + first - 1 : NO_IRQ;
+}
+
+static void __init or1k_irq_init(void)
+{
+	struct irq_chip_generic *gc;
+	struct irq_chip_type *ct;
+
+	/* Disable all interrupts until explicitly requested */
+	mtspr(SPR_PICMR, (0UL));
+
+	gc = irq_alloc_generic_chip("or1k-PIC", 1, 0, 0, handle_level_irq);
+	ct = gc->chip_types;
+
+	ct->chip.irq_unmask = or1k_pic_unmask;
+	ct->chip.irq_mask = or1k_pic_mask;
+	ct->chip.irq_ack = or1k_pic_ack;
+	ct->chip.irq_mask_ack = or1k_pic_mask_ack;
+	ct->chip.irq_set_type = or1k_pic_set_type;
+
+	/* The OR1K PIC can handle both level and edge trigged
+	 * interrupts in roughly the same manner
+	 */
+#if 0
+	/* FIXME: chip.type??? */
+	ct->chip.type = IRQ_TYPE_EDGE_BOTH | IRQ_TYPE_LEVEL_MASK;
+#endif
+
+	irq_setup_generic_chip(gc, IRQ_MSK(NR_IRQS), 0,
+			       IRQ_NOREQUEST, IRQ_LEVEL | IRQ_NOPROBE);
+}
+
+void __init init_IRQ(void)
+{
+	or1k_irq_init();
+}
+
+void __irq_entry do_IRQ(struct pt_regs *regs)
+{
+	int irq = -1;
+	struct pt_regs *old_regs = set_irq_regs(regs);
+
+	irq_enter();
+
+	while ((irq = pic_get_irq(irq + 1)) != NO_IRQ)
+		generic_handle_irq(irq);
+
+	irq_exit();
+	set_irq_regs(old_regs);
+}
+
+unsigned int irq_create_of_mapping(struct device_node *controller,
+				   const u32 *intspec, unsigned int intsize)
+{
+	return intspec[0];
+}
+EXPORT_SYMBOL_GPL(irq_create_of_mapping);
