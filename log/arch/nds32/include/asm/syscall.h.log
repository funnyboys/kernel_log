commit 33644b95eb342201511fc951d8fcd10362bd435b
Author: Dmitry V. Levin <ldv@altlinux.org>
Date:   Tue Jul 16 16:29:24 2019 -0700

    nds32: fix asm/syscall.h
    
    PTRACE_GET_SYSCALL_INFO is a generic ptrace API that lets ptracer obtain
    details of the syscall the tracee is blocked in.
    
    There are two reasons for a special syscall-related ptrace request.
    
    Firstly, with the current ptrace API there are cases when ptracer cannot
    retrieve necessary information about syscalls.  Some examples include:
    
     * The notorious int-0x80-from-64-bit-task issue. See [1] for details.
       In short, if a 64-bit task performs a syscall through int 0x80, its
       tracer has no reliable means to find out that the syscall was, in
       fact, a compat syscall, and misidentifies it.
    
     * Syscall-enter-stop and syscall-exit-stop look the same for the
       tracer. Common practice is to keep track of the sequence of
       ptrace-stops in order not to mix the two syscall-stops up. But it is
       not as simple as it looks; for example, strace had a (just recently
       fixed) long-standing bug where attaching strace to a tracee that is
       performing the execve system call led to the tracer identifying the
       following syscall-exit-stop as syscall-enter-stop, which messed up
       all the state tracking.
    
     * Since the introduction of commit 84d77d3f06e7 ("ptrace: Don't allow
       accessing an undumpable mm"), both PTRACE_PEEKDATA and
       process_vm_readv become unavailable when the process dumpable flag is
       cleared. On such architectures as ia64 this results in all syscall
       arguments being unavailable for the tracer.
    
    Secondly, ptracers also have to support a lot of arch-specific code for
    obtaining information about the tracee.  For some architectures, this
    requires a ptrace(PTRACE_PEEKUSER, ...) invocation for every syscall
    argument and return value.
    
    PTRACE_GET_SYSCALL_INFO returns the following structure:
    
    struct ptrace_syscall_info {
            __u8 op;        /* PTRACE_SYSCALL_INFO_* */
            __u32 arch __attribute__((__aligned__(sizeof(__u32))));
            __u64 instruction_pointer;
            __u64 stack_pointer;
            union {
                    struct {
                            __u64 nr;
                            __u64 args[6];
                    } entry;
                    struct {
                            __s64 rval;
                            __u8 is_error;
                    } exit;
                    struct {
                            __u64 nr;
                            __u64 args[6];
                            __u32 ret_data;
                    } seccomp;
            };
    };
    
    The structure was chosen according to [2], except for the following
    changes:
    
     * seccomp substructure was added as a superset of entry substructure
    
     * the type of nr field was changed from int to __u64 because syscall
       numbers are, as a practical matter, 64 bits
    
     * stack_pointer field was added along with instruction_pointer field
       since it is readily available and can save the tracer from extra
       PTRACE_GETREGS/PTRACE_GETREGSET calls
    
     * arch is always initialized to aid with tracing system calls such as
       execve()
    
     * instruction_pointer and stack_pointer are always initialized so they
       could be easily obtained for non-syscall stops
    
     * a boolean is_error field was added along with rval field, this way
       the tracer can more reliably distinguish a return value from an error
       value
    
    strace has been ported to PTRACE_GET_SYSCALL_INFO.  Starting with
    release 4.26, strace uses PTRACE_GET_SYSCALL_INFO API as the preferred
    mechanism of obtaining syscall information.
    
    [1] https://lore.kernel.org/lkml/CA+55aFzcSVmdDj9Lh_gdbz1OzHyEm6ZrGPBDAJnywm2LF_eVyg@mail.gmail.com/
    [2] https://lore.kernel.org/lkml/CAObL_7GM0n80N7J_DFw_eQyfLyzq+sf4y2AvsCCV88Tb3AwEHA@mail.gmail.com/
    
    This patch (of 7):
    
    All syscall_get_*() and syscall_set_*() functions must be defined as
    static inline as on all other architectures, otherwise asm/syscall.h
    cannot be included in more than one compilation unit.
    
    This bug has to be fixed in order to extend the generic
    ptrace API with PTRACE_GET_SYSCALL_INFO request.
    
    Link: http://lkml.kernel.org/r/20190510152749.GA28558@altlinux.org
    Fixes: 1932fbe36e02 ("nds32: System calls handling")
    Signed-off-by: Dmitry V. Levin <ldv@altlinux.org>
    Reported-by: kbuild test robot <lkp@intel.com>
    Acked-by: Greentime Hu <greentime@andestech.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Elvira Khabirova <lineprinter@altlinux.org>
    Cc: Eugene Syromyatnikov <esyr@redhat.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Helge Deller <deller@gmx.de>        [parisc]
    Cc: James E.J. Bottomley <jejb@parisc-linux.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Shuah Khan <shuah@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/nds32/include/asm/syscall.h b/arch/nds32/include/asm/syscall.h
index 899b2fb4b52f..7b5180d78e20 100644
--- a/arch/nds32/include/asm/syscall.h
+++ b/arch/nds32/include/asm/syscall.h
@@ -26,7 +26,8 @@ struct pt_regs;
  *
  * It's only valid to call this when @task is known to be blocked.
  */
-int syscall_get_nr(struct task_struct *task, struct pt_regs *regs)
+static inline int
+syscall_get_nr(struct task_struct *task, struct pt_regs *regs)
 {
 	return regs->syscallno;
 }
@@ -47,7 +48,8 @@ int syscall_get_nr(struct task_struct *task, struct pt_regs *regs)
  * system call instruction.  This may not be the same as what the
  * register state looked like at system call entry tracing.
  */
-void syscall_rollback(struct task_struct *task, struct pt_regs *regs)
+static inline void
+syscall_rollback(struct task_struct *task, struct pt_regs *regs)
 {
 	regs->uregs[0] = regs->orig_r0;
 }
@@ -62,7 +64,8 @@ void syscall_rollback(struct task_struct *task, struct pt_regs *regs)
  * It's only valid to call this when @task is stopped for tracing on exit
  * from a system call, due to %TIF_SYSCALL_TRACE or %TIF_SYSCALL_AUDIT.
  */
-long syscall_get_error(struct task_struct *task, struct pt_regs *regs)
+static inline long
+syscall_get_error(struct task_struct *task, struct pt_regs *regs)
 {
 	unsigned long error = regs->uregs[0];
 	return IS_ERR_VALUE(error) ? error : 0;
@@ -79,7 +82,8 @@ long syscall_get_error(struct task_struct *task, struct pt_regs *regs)
  * It's only valid to call this when @task is stopped for tracing on exit
  * from a system call, due to %TIF_SYSCALL_TRACE or %TIF_SYSCALL_AUDIT.
  */
-long syscall_get_return_value(struct task_struct *task, struct pt_regs *regs)
+static inline long
+syscall_get_return_value(struct task_struct *task, struct pt_regs *regs)
 {
 	return regs->uregs[0];
 }
@@ -99,8 +103,9 @@ long syscall_get_return_value(struct task_struct *task, struct pt_regs *regs)
  * It's only valid to call this when @task is stopped for tracing on exit
  * from a system call, due to %TIF_SYSCALL_TRACE or %TIF_SYSCALL_AUDIT.
  */
-void syscall_set_return_value(struct task_struct *task, struct pt_regs *regs,
-			      int error, long val)
+static inline void
+syscall_set_return_value(struct task_struct *task, struct pt_regs *regs,
+			 int error, long val)
 {
 	regs->uregs[0] = (long)error ? error : val;
 }
@@ -118,8 +123,9 @@ void syscall_set_return_value(struct task_struct *task, struct pt_regs *regs,
  * entry to a system call, due to %TIF_SYSCALL_TRACE or %TIF_SYSCALL_AUDIT.
  */
 #define SYSCALL_MAX_ARGS 6
-void syscall_get_arguments(struct task_struct *task, struct pt_regs *regs,
-			   unsigned long *args)
+static inline void
+syscall_get_arguments(struct task_struct *task, struct pt_regs *regs,
+		      unsigned long *args)
 {
 	args[0] = regs->orig_r0;
 	args++;
@@ -138,8 +144,9 @@ void syscall_get_arguments(struct task_struct *task, struct pt_regs *regs,
  * It's only valid to call this when @task is stopped for tracing on
  * entry to a system call, due to %TIF_SYSCALL_TRACE or %TIF_SYSCALL_AUDIT.
  */
-void syscall_set_arguments(struct task_struct *task, struct pt_regs *regs,
-			   const unsigned long *args)
+static inline void
+syscall_set_arguments(struct task_struct *task, struct pt_regs *regs,
+		      const unsigned long *args)
 {
 	regs->orig_r0 = args[0];
 	args++;

commit 4489da7183099f569a7d3dd819c975073c04bc72
Merge: 80111bfb672d af9abd65983c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 17 10:17:29 2019 -0700

    Merge tag 'nds32-for-linus-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/greentime/linux
    
    Pull nds32 updates from Greentime Hu:
    
     - Clean up codes and Makefile
    
     - Fix a vDSO bug
    
     - Remove useless functions/header files
    
     - Update git repo path in MAINTAINERS
    
    * tag 'nds32-for-linus-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/greentime/linux:
      nds32: Fix vDSO clock_getres()
      MAINTAINERS: update nds32 git repo path
      nds32: don't export low-level cache flushing routines
      arch: nds32: Kconfig: pedantic formatting
      nds32: fix semicolon code style issue
      nds32: vdso: drop unnecessary cc-ldoption
      nds32: remove unused generic-y += cmpxchg-local.h
      nds32: Use the correct style for SPDX License Identifier
      nds32: remove __virt_to_bus and __bus_to_virt
      nds32: vdso: fix and clean-up Makefile
      nds32: add vmlinux.lds and vdso.so to .gitignore
      nds32: ex-exit: Remove unneeded need_resched() loop
      nds32/io: Remove useless definition of mmiowb()
      nds32: Removed unused thread flag TIF_USEDFPU

commit 02aff8db6438ce29371fd9cd54c57213f4bb4536
Merge: f72dae20891d 70c4cf17e445
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 19:06:04 2019 -0700

    Merge tag 'audit-pr-20190507' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/audit
    
    Pull audit updates from Paul Moore:
     "We've got a reasonably broad set of audit patches for the v5.2 merge
      window, the highlights are below:
    
       - The biggest change, and the source of all the arch/* changes, is
         the patchset from Dmitry to help enable some of the work he is
         doing around PTRACE_GET_SYSCALL_INFO.
    
         To be honest, including this in the audit tree is a bit of a
         stretch, but it does help move audit a little further along towards
         proper syscall auditing for all arches, and everyone else seemed to
         agree that audit was a "good" spot for this to land (or maybe they
         just didn't want to merge it? dunno.).
    
       - We can now audit time/NTP adjustments.
    
       - We continue the work to connect associated audit records into a
         single event"
    
    * tag 'audit-pr-20190507' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/audit: (21 commits)
      audit: fix a memory leak bug
      ntp: Audit NTP parameters adjustment
      timekeeping: Audit clock adjustments
      audit: purge unnecessary list_empty calls
      audit: link integrity evm_write_xattrs record to syscall event
      syscall_get_arch: add "struct task_struct *" argument
      unicore32: define syscall_get_arch()
      Move EM_UNICORE to uapi/linux/elf-em.h
      nios2: define syscall_get_arch()
      nds32: define syscall_get_arch()
      Move EM_NDS32 to uapi/linux/elf-em.h
      m68k: define syscall_get_arch()
      hexagon: define syscall_get_arch()
      Move EM_HEXAGON to uapi/linux/elf-em.h
      h8300: define syscall_get_arch()
      c6x: define syscall_get_arch()
      arc: define syscall_get_arch()
      Move EM_ARCOMPACT and EM_ARCV2 to uapi/linux/elf-em.h
      audit: Make audit_log_cap and audit_copy_inode static
      audit: connect LOGIN record to its syscall record
      ...

commit 7f9ea6b799ef0f3adc7e860937dec633545b5f6f
Author: Nishad Kamdar <nishadkamdar@gmail.com>
Date:   Tue Apr 16 20:54:35 2019 +0530

    nds32: Use the correct style for SPDX License Identifier
    
    This patch corrects the SPDX License Identifier style
    in the nds32 Hardware Architecture related files.
    
    Suggested-by: Joe Perches <joe@perches.com>
    Signed-off-by: Nishad Kamdar <nishadkamdar@gmail.com>
    Acked-by: Greentime Hu <greentime@andestech.com>
    Signed-off-by: Greentime Hu <greentime@andestech.com>

diff --git a/arch/nds32/include/asm/syscall.h b/arch/nds32/include/asm/syscall.h
index 671ebd357496..f4085c7775ab 100644
--- a/arch/nds32/include/asm/syscall.h
+++ b/arch/nds32/include/asm/syscall.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+/* SPDX-License-Identifier: GPL-2.0 */
 // Copyright (C) 2008-2009 Red Hat, Inc.  All rights reserved.
 // Copyright (C) 2005-2017 Andes Technology Corporation
 

commit 32d92586629a8b3637a3c9361709818e25f327ad
Author: Steven Rostedt (VMware) <rostedt@goodmis.org>
Date:   Wed Mar 27 20:07:31 2019 -0400

    syscalls: Remove start and number from syscall_set_arguments() args
    
    After removing the start and count arguments of syscall_get_arguments() it
    seems reasonable to remove them from syscall_set_arguments(). Note, as of
    today, there are no users of syscall_set_arguments(). But we are told that
    there will be soon. But for now, at least make it consistent with
    syscall_get_arguments().
    
    Link: http://lkml.kernel.org/r/20190327222014.GA32540@altlinux.org
    
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Dave Martin <dave.martin@arm.com>
    Cc: "Dmitry V. Levin" <ldv@altlinux.org>
    Cc: x86@kernel.org
    Cc: linux-snps-arc@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-c6x-dev@linux-c6x.org
    Cc: uclinux-h8-devel@lists.sourceforge.jp
    Cc: linux-hexagon@vger.kernel.org
    Cc: linux-ia64@vger.kernel.org
    Cc: linux-mips@vger.kernel.org
    Cc: nios2-dev@lists.rocketboards.org
    Cc: openrisc@lists.librecores.org
    Cc: linux-parisc@vger.kernel.org
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: linux-riscv@lists.infradead.org
    Cc: linux-s390@vger.kernel.org
    Cc: linux-sh@vger.kernel.org
    Cc: sparclinux@vger.kernel.org
    Cc: linux-um@lists.infradead.org
    Cc: linux-xtensa@linux-xtensa.org
    Cc: linux-arch@vger.kernel.org
    Acked-by: Max Filippov <jcmvbkbc@gmail.com> # For xtensa changes
    Acked-by: Will Deacon <will.deacon@arm.com> # For the arm64 bits
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de> # for x86
    Reviewed-by: Dmitry V. Levin <ldv@altlinux.org>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/arch/nds32/include/asm/syscall.h b/arch/nds32/include/asm/syscall.h
index 89a6ec8731d8..671ebd357496 100644
--- a/arch/nds32/include/asm/syscall.h
+++ b/arch/nds32/include/asm/syscall.h
@@ -129,39 +129,20 @@ void syscall_get_arguments(struct task_struct *task, struct pt_regs *regs,
  * syscall_set_arguments - change system call parameter value
  * @task:	task of interest, must be in system call entry tracing
  * @regs:	task_pt_regs() of @task
- * @i:		argument index [0,5]
- * @n:		number of arguments; n+i must be [1,6].
  * @args:	array of argument values to store
  *
- * Changes @n arguments to the system call starting with the @i'th argument.
- * Argument @i gets value @args[0], and so on.
- * An arch inline version is probably optimal when @i and @n are constants.
+ * Changes 6 arguments to the system call. The first argument gets value
+ * @args[0], and so on.
  *
  * It's only valid to call this when @task is stopped for tracing on
  * entry to a system call, due to %TIF_SYSCALL_TRACE or %TIF_SYSCALL_AUDIT.
- * It's invalid to call this with @i + @n > 6; we only support system calls
- * taking up to 6 arguments.
  */
 void syscall_set_arguments(struct task_struct *task, struct pt_regs *regs,
-			   unsigned int i, unsigned int n,
 			   const unsigned long *args)
 {
-	if (n == 0)
-		return;
-
-	if (i + n > SYSCALL_MAX_ARGS) {
-		pr_warn("%s called with max args %d, handling only %d\n",
-			__func__, i + n, SYSCALL_MAX_ARGS);
-		n = SYSCALL_MAX_ARGS - i;
-	}
-
-	if (i == 0) {
-		regs->orig_r0 = args[0];
-		args++;
-		i++;
-		n--;
-	}
+	regs->orig_r0 = args[0];
+	args++;
 
-	memcpy(&regs->uregs[0] + i, args, n * sizeof(args[0]));
+	memcpy(&regs->uregs[0] + 1, args, 5 * sizeof(args[0]));
 }
 #endif /* _ASM_NDS32_SYSCALL_H */

commit b35f549df1d7520d37ba1e6d4a8d4df6bd52d136
Author: Steven Rostedt (Red Hat) <rostedt@goodmis.org>
Date:   Mon Nov 7 16:26:37 2016 -0500

    syscalls: Remove start and number from syscall_get_arguments() args
    
    At Linux Plumbers, Andy Lutomirski approached me and pointed out that the
    function call syscall_get_arguments() implemented in x86 was horribly
    written and not optimized for the standard case of passing in 0 and 6 for
    the starting index and the number of system calls to get. When looking at
    all the users of this function, I discovered that all instances pass in only
    0 and 6 for these arguments. Instead of having this function handle
    different cases that are never used, simply rewrite it to return the first 6
    arguments of a system call.
    
    This should help out the performance of tracing system calls by ptrace,
    ftrace and perf.
    
    Link: http://lkml.kernel.org/r/20161107213233.754809394@goodmis.org
    
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Dave Martin <dave.martin@arm.com>
    Cc: "Dmitry V. Levin" <ldv@altlinux.org>
    Cc: x86@kernel.org
    Cc: linux-snps-arc@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-c6x-dev@linux-c6x.org
    Cc: uclinux-h8-devel@lists.sourceforge.jp
    Cc: linux-hexagon@vger.kernel.org
    Cc: linux-ia64@vger.kernel.org
    Cc: linux-mips@vger.kernel.org
    Cc: nios2-dev@lists.rocketboards.org
    Cc: openrisc@lists.librecores.org
    Cc: linux-parisc@vger.kernel.org
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: linux-riscv@lists.infradead.org
    Cc: linux-s390@vger.kernel.org
    Cc: linux-sh@vger.kernel.org
    Cc: sparclinux@vger.kernel.org
    Cc: linux-um@lists.infradead.org
    Cc: linux-xtensa@linux-xtensa.org
    Cc: linux-arch@vger.kernel.org
    Acked-by: Paul Burton <paul.burton@mips.com> # MIPS parts
    Acked-by: Max Filippov <jcmvbkbc@gmail.com> # For xtensa changes
    Acked-by: Will Deacon <will.deacon@arm.com> # For the arm64 bits
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de> # for x86
    Reviewed-by: Dmitry V. Levin <ldv@altlinux.org>
    Reported-by: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>

diff --git a/arch/nds32/include/asm/syscall.h b/arch/nds32/include/asm/syscall.h
index f7e5e86765fe..89a6ec8731d8 100644
--- a/arch/nds32/include/asm/syscall.h
+++ b/arch/nds32/include/asm/syscall.h
@@ -108,42 +108,21 @@ void syscall_set_return_value(struct task_struct *task, struct pt_regs *regs,
  * syscall_get_arguments - extract system call parameter values
  * @task:	task of interest, must be blocked
  * @regs:	task_pt_regs() of @task
- * @i:		argument index [0,5]
- * @n:		number of arguments; n+i must be [1,6].
  * @args:	array filled with argument values
  *
- * Fetches @n arguments to the system call starting with the @i'th argument
- * (from 0 through 5).  Argument @i is stored in @args[0], and so on.
- * An arch inline version is probably optimal when @i and @n are constants.
+ * Fetches 6 arguments to the system call (from 0 through 5). The first
+ * argument is stored in @args[0], and so on.
  *
  * It's only valid to call this when @task is stopped for tracing on
  * entry to a system call, due to %TIF_SYSCALL_TRACE or %TIF_SYSCALL_AUDIT.
- * It's invalid to call this with @i + @n > 6; we only support system calls
- * taking up to 6 arguments.
  */
 #define SYSCALL_MAX_ARGS 6
 void syscall_get_arguments(struct task_struct *task, struct pt_regs *regs,
-			   unsigned int i, unsigned int n, unsigned long *args)
+			   unsigned long *args)
 {
-	if (n == 0)
-		return;
-	if (i + n > SYSCALL_MAX_ARGS) {
-		unsigned long *args_bad = args + SYSCALL_MAX_ARGS - i;
-		unsigned int n_bad = n + i - SYSCALL_MAX_ARGS;
-		pr_warning("%s called with max args %d, handling only %d\n",
-			   __func__, i + n, SYSCALL_MAX_ARGS);
-		memset(args_bad, 0, n_bad * sizeof(args[0]));
-		memset(args_bad, 0, n_bad * sizeof(args[0]));
-	}
-
-	if (i == 0) {
-		args[0] = regs->orig_r0;
-		args++;
-		i++;
-		n--;
-	}
-
-	memcpy(args, &regs->uregs[0] + i, n * sizeof(args[0]));
+	args[0] = regs->orig_r0;
+	args++;
+	memcpy(args, &regs->uregs[0] + 1, 5 * sizeof(args[0]));
 }
 
 /**

commit 16add411645cff83360086e102daa67b25f1e39a
Author: Dmitry V. Levin <ldv@altlinux.org>
Date:   Mon Mar 18 02:30:18 2019 +0300

    syscall_get_arch: add "struct task_struct *" argument
    
    This argument is required to extend the generic ptrace API with
    PTRACE_GET_SYSCALL_INFO request: syscall_get_arch() is going
    to be called from ptrace_request() along with syscall_get_nr(),
    syscall_get_arguments(), syscall_get_error(), and
    syscall_get_return_value() functions with a tracee as their argument.
    
    The primary intent is that the triple (audit_arch, syscall_nr, arg1..arg6)
    should describe what system call is being called and what its arguments
    are.
    
    Reverts: 5e937a9ae913 ("syscall_get_arch: remove useless function arguments")
    Reverts: 1002d94d3076 ("syscall.h: fix doc text for syscall_get_arch()")
    Reviewed-by: Andy Lutomirski <luto@kernel.org> # for x86
    Reviewed-by: Palmer Dabbelt <palmer@sifive.com>
    Acked-by: Paul Moore <paul@paul-moore.com>
    Acked-by: Paul Burton <paul.burton@mips.com> # MIPS parts
    Acked-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
    Acked-by: Kees Cook <keescook@chromium.org> # seccomp parts
    Acked-by: Mark Salter <msalter@redhat.com> # for the c6x bit
    Cc: Elvira Khabirova <lineprinter@altlinux.org>
    Cc: Eugene Syromyatnikov <esyr@redhat.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: x86@kernel.org
    Cc: linux-alpha@vger.kernel.org
    Cc: linux-snps-arc@lists.infradead.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-c6x-dev@linux-c6x.org
    Cc: uclinux-h8-devel@lists.sourceforge.jp
    Cc: linux-hexagon@vger.kernel.org
    Cc: linux-ia64@vger.kernel.org
    Cc: linux-m68k@lists.linux-m68k.org
    Cc: linux-mips@vger.kernel.org
    Cc: nios2-dev@lists.rocketboards.org
    Cc: openrisc@lists.librecores.org
    Cc: linux-parisc@vger.kernel.org
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: linux-riscv@lists.infradead.org
    Cc: linux-s390@vger.kernel.org
    Cc: linux-sh@vger.kernel.org
    Cc: sparclinux@vger.kernel.org
    Cc: linux-um@lists.infradead.org
    Cc: linux-xtensa@linux-xtensa.org
    Cc: linux-arch@vger.kernel.org
    Cc: linux-audit@redhat.com
    Signed-off-by: Dmitry V. Levin <ldv@altlinux.org>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/arch/nds32/include/asm/syscall.h b/arch/nds32/include/asm/syscall.h
index cc56a3962f8b..7501e376a6b1 100644
--- a/arch/nds32/include/asm/syscall.h
+++ b/arch/nds32/include/asm/syscall.h
@@ -188,7 +188,7 @@ void syscall_set_arguments(struct task_struct *task, struct pt_regs *regs,
 }
 
 static inline int
-syscall_get_arch(void)
+syscall_get_arch(struct task_struct *task)
 {
 	return IS_ENABLED(CONFIG_CPU_BIG_ENDIAN)
 		? AUDIT_ARCH_NDS32BE : AUDIT_ARCH_NDS32;

commit fa562447e154334523daa44c0b60625d71a345f5
Author: Dmitry V. Levin <ldv@altlinux.org>
Date:   Mon Mar 18 02:29:57 2019 +0300

    nds32: define syscall_get_arch()
    
    syscall_get_arch() is required to be implemented on all architectures
    in addition to already implemented syscall_get_nr(),
    syscall_get_arguments(), syscall_get_error(), and
    syscall_get_return_value() functions in order to extend the generic
    ptrace API with PTRACE_GET_SYSCALL_INFO request.
    
    Acked-by: Paul Moore <paul@paul-moore.com>
    Acked-by: Vincent Chen <vincentc@andestech.com>
    Acked-by: Greentime Hu <greentime@andestech.com>
    Cc: Elvira Khabirova <lineprinter@altlinux.org>
    Cc: Eugene Syromyatnikov <esyr@redhat.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: linux-audit@redhat.com
    Signed-off-by: Dmitry V. Levin <ldv@altlinux.org>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/arch/nds32/include/asm/syscall.h b/arch/nds32/include/asm/syscall.h
index f7e5e86765fe..cc56a3962f8b 100644
--- a/arch/nds32/include/asm/syscall.h
+++ b/arch/nds32/include/asm/syscall.h
@@ -5,6 +5,7 @@
 #ifndef _ASM_NDS32_SYSCALL_H
 #define _ASM_NDS32_SYSCALL_H	1
 
+#include <uapi/linux/audit.h>
 #include <linux/err.h>
 struct task_struct;
 struct pt_regs;
@@ -185,4 +186,12 @@ void syscall_set_arguments(struct task_struct *task, struct pt_regs *regs,
 
 	memcpy(&regs->uregs[0] + i, args, n * sizeof(args[0]));
 }
+
+static inline int
+syscall_get_arch(void)
+{
+	return IS_ENABLED(CONFIG_CPU_BIG_ENDIAN)
+		? AUDIT_ARCH_NDS32BE : AUDIT_ARCH_NDS32;
+}
+
 #endif /* _ASM_NDS32_SYSCALL_H */

commit 1932fbe36e02f54223ac4c6779b92269ca8b9b60
Author: Greentime Hu <greentime@andestech.com>
Date:   Wed Oct 25 10:37:49 2017 +0800

    nds32: System calls handling
    
    This patch adds support for system calls.
    
    Signed-off-by: Vincent Chen <vincentc@andestech.com>
    Signed-off-by: Greentime Hu <greentime@andestech.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/nds32/include/asm/syscall.h b/arch/nds32/include/asm/syscall.h
new file mode 100644
index 000000000000..f7e5e86765fe
--- /dev/null
+++ b/arch/nds32/include/asm/syscall.h
@@ -0,0 +1,188 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2008-2009 Red Hat, Inc.  All rights reserved.
+// Copyright (C) 2005-2017 Andes Technology Corporation
+
+#ifndef _ASM_NDS32_SYSCALL_H
+#define _ASM_NDS32_SYSCALL_H	1
+
+#include <linux/err.h>
+struct task_struct;
+struct pt_regs;
+
+/**
+ * syscall_get_nr - find what system call a task is executing
+ * @task:	task of interest, must be blocked
+ * @regs:	task_pt_regs() of @task
+ *
+ * If @task is executing a system call or is at system call
+ * tracing about to attempt one, returns the system call number.
+ * If @task is not executing a system call, i.e. it's blocked
+ * inside the kernel for a fault or signal, returns -1.
+ *
+ * Note this returns int even on 64-bit machines.  Only 32 bits of
+ * system call number can be meaningful.  If the actual arch value
+ * is 64 bits, this truncates to 32 bits so 0xffffffff means -1.
+ *
+ * It's only valid to call this when @task is known to be blocked.
+ */
+int syscall_get_nr(struct task_struct *task, struct pt_regs *regs)
+{
+	return regs->syscallno;
+}
+
+/**
+ * syscall_rollback - roll back registers after an aborted system call
+ * @task:	task of interest, must be in system call exit tracing
+ * @regs:	task_pt_regs() of @task
+ *
+ * It's only valid to call this when @task is stopped for system
+ * call exit tracing (due to TIF_SYSCALL_TRACE or TIF_SYSCALL_AUDIT),
+ * after tracehook_report_syscall_entry() returned nonzero to prevent
+ * the system call from taking place.
+ *
+ * This rolls back the register state in @regs so it's as if the
+ * system call instruction was a no-op.  The registers containing
+ * the system call number and arguments are as they were before the
+ * system call instruction.  This may not be the same as what the
+ * register state looked like at system call entry tracing.
+ */
+void syscall_rollback(struct task_struct *task, struct pt_regs *regs)
+{
+	regs->uregs[0] = regs->orig_r0;
+}
+
+/**
+ * syscall_get_error - check result of traced system call
+ * @task:	task of interest, must be blocked
+ * @regs:	task_pt_regs() of @task
+ *
+ * Returns 0 if the system call succeeded, or -ERRORCODE if it failed.
+ *
+ * It's only valid to call this when @task is stopped for tracing on exit
+ * from a system call, due to %TIF_SYSCALL_TRACE or %TIF_SYSCALL_AUDIT.
+ */
+long syscall_get_error(struct task_struct *task, struct pt_regs *regs)
+{
+	unsigned long error = regs->uregs[0];
+	return IS_ERR_VALUE(error) ? error : 0;
+}
+
+/**
+ * syscall_get_return_value - get the return value of a traced system call
+ * @task:	task of interest, must be blocked
+ * @regs:	task_pt_regs() of @task
+ *
+ * Returns the return value of the successful system call.
+ * This value is meaningless if syscall_get_error() returned nonzero.
+ *
+ * It's only valid to call this when @task is stopped for tracing on exit
+ * from a system call, due to %TIF_SYSCALL_TRACE or %TIF_SYSCALL_AUDIT.
+ */
+long syscall_get_return_value(struct task_struct *task, struct pt_regs *regs)
+{
+	return regs->uregs[0];
+}
+
+/**
+ * syscall_set_return_value - change the return value of a traced system call
+ * @task:	task of interest, must be blocked
+ * @regs:	task_pt_regs() of @task
+ * @error:	negative error code, or zero to indicate success
+ * @val:	user return value if @error is zero
+ *
+ * This changes the results of the system call that user mode will see.
+ * If @error is zero, the user sees a successful system call with a
+ * return value of @val.  If @error is nonzero, it's a negated errno
+ * code; the user sees a failed system call with this errno code.
+ *
+ * It's only valid to call this when @task is stopped for tracing on exit
+ * from a system call, due to %TIF_SYSCALL_TRACE or %TIF_SYSCALL_AUDIT.
+ */
+void syscall_set_return_value(struct task_struct *task, struct pt_regs *regs,
+			      int error, long val)
+{
+	regs->uregs[0] = (long)error ? error : val;
+}
+
+/**
+ * syscall_get_arguments - extract system call parameter values
+ * @task:	task of interest, must be blocked
+ * @regs:	task_pt_regs() of @task
+ * @i:		argument index [0,5]
+ * @n:		number of arguments; n+i must be [1,6].
+ * @args:	array filled with argument values
+ *
+ * Fetches @n arguments to the system call starting with the @i'th argument
+ * (from 0 through 5).  Argument @i is stored in @args[0], and so on.
+ * An arch inline version is probably optimal when @i and @n are constants.
+ *
+ * It's only valid to call this when @task is stopped for tracing on
+ * entry to a system call, due to %TIF_SYSCALL_TRACE or %TIF_SYSCALL_AUDIT.
+ * It's invalid to call this with @i + @n > 6; we only support system calls
+ * taking up to 6 arguments.
+ */
+#define SYSCALL_MAX_ARGS 6
+void syscall_get_arguments(struct task_struct *task, struct pt_regs *regs,
+			   unsigned int i, unsigned int n, unsigned long *args)
+{
+	if (n == 0)
+		return;
+	if (i + n > SYSCALL_MAX_ARGS) {
+		unsigned long *args_bad = args + SYSCALL_MAX_ARGS - i;
+		unsigned int n_bad = n + i - SYSCALL_MAX_ARGS;
+		pr_warning("%s called with max args %d, handling only %d\n",
+			   __func__, i + n, SYSCALL_MAX_ARGS);
+		memset(args_bad, 0, n_bad * sizeof(args[0]));
+		memset(args_bad, 0, n_bad * sizeof(args[0]));
+	}
+
+	if (i == 0) {
+		args[0] = regs->orig_r0;
+		args++;
+		i++;
+		n--;
+	}
+
+	memcpy(args, &regs->uregs[0] + i, n * sizeof(args[0]));
+}
+
+/**
+ * syscall_set_arguments - change system call parameter value
+ * @task:	task of interest, must be in system call entry tracing
+ * @regs:	task_pt_regs() of @task
+ * @i:		argument index [0,5]
+ * @n:		number of arguments; n+i must be [1,6].
+ * @args:	array of argument values to store
+ *
+ * Changes @n arguments to the system call starting with the @i'th argument.
+ * Argument @i gets value @args[0], and so on.
+ * An arch inline version is probably optimal when @i and @n are constants.
+ *
+ * It's only valid to call this when @task is stopped for tracing on
+ * entry to a system call, due to %TIF_SYSCALL_TRACE or %TIF_SYSCALL_AUDIT.
+ * It's invalid to call this with @i + @n > 6; we only support system calls
+ * taking up to 6 arguments.
+ */
+void syscall_set_arguments(struct task_struct *task, struct pt_regs *regs,
+			   unsigned int i, unsigned int n,
+			   const unsigned long *args)
+{
+	if (n == 0)
+		return;
+
+	if (i + n > SYSCALL_MAX_ARGS) {
+		pr_warn("%s called with max args %d, handling only %d\n",
+			__func__, i + n, SYSCALL_MAX_ARGS);
+		n = SYSCALL_MAX_ARGS - i;
+	}
+
+	if (i == 0) {
+		regs->orig_r0 = args[0];
+		args++;
+		i++;
+		n--;
+	}
+
+	memcpy(&regs->uregs[0] + i, args, n * sizeof(args[0]));
+}
+#endif /* _ASM_NDS32_SYSCALL_H */
