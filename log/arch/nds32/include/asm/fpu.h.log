commit ed32949e0acb73e7bc054bb02e0453d4d561ceda
Author: Vincent Chen <vincentc@andestech.com>
Date:   Mon May 20 09:21:12 2019 +0800

    nds32: Avoid IEX status being incorrectly modified
    
    In order for kernel to capture each denormalized output, the UDF
    trapping enable bit is always raised in $fpcsr. Because underflow case will
    issue not an underflow exception but also an inexact exception, it causes
    that the IEX, IEX cumulative exception, flag in $fpcsr to be raised in each
    denormalized output handling. To make the emulation transparent to the
    user, the emulator needs to clear the IEX flag in $fpcsr if the result is a
    denormalized number. However, if the IEX flag has been raised before this
    floating point emulation, this cleanup may be incorrect. To avoid the IEX
    flags in $fpcsr be raised in each denormalized output handling, the IEX
    trap shall be always enabled.
    
    Signed-off-by: Vincent Chen <vincentc@andestech.com>
    Acked-by: Greentime Hu <greentime@andestech.com>
    Signed-off-by: Greentime Hu <greentime@andestech.com>

diff --git a/arch/nds32/include/asm/fpu.h b/arch/nds32/include/asm/fpu.h
index 019f1bcfc5ee..8294ed4aaa2c 100644
--- a/arch/nds32/include/asm/fpu.h
+++ b/arch/nds32/include/asm/fpu.h
@@ -36,7 +36,7 @@ extern int do_fpuemu(struct pt_regs *regs, struct fpu_struct *fpu);
  * enabled by default and kerenl will re-execute it by fpu emulator
  * when getting underflow exception.
  */
-#define FPCSR_INIT  FPCSR_mskUDFE
+#define FPCSR_INIT  (FPCSR_mskUDFE | FPCSR_mskIEXE)
 #else
 #define FPCSR_INIT  0x0UL
 #endif

commit 44e92e0364adfd7b6759084e02a550d06336d896
Author: Vincent Chen <vincentc@andestech.com>
Date:   Thu Nov 22 11:14:36 2018 +0800

    nds32: support denormalized result through FP emulator
    
    Currently, the nds32 FPU dose not support the arithmetic of denormalized
    number. When the nds32 FPU finds the result of the instruction is a
    denormlized number, the nds32 FPU considers it to be an underflow condition
    and rounds the result to an appropriate number. It may causes some loss
    of precision. This commit proposes a solution to re-execute the
    instruction by the FPU emulator to enhance the precision. To transfer
    calculations from user space to kernel space, this feature will enable
    the underflow exception trap by default. Enabling this feature may cause
    some side effects:
      1. Performance loss due to extra FPU exception
      2. Need another scheme to control real underflow trap
           A new parameter, UDF_trap, which is belong to FPU context is used
         to control underflow trap.
    
    User can configure this feature via CONFIG_SUPPORT_DENORMAL_ARITHMETIC
    
    Signed-off-by: Vincent Chen <vincentc@andestech.com>
    Acked-by: Greentime Hu <greentime@andestech.com>
    Signed-off-by: Greentime Hu <greentime@andestech.com>

diff --git a/arch/nds32/include/asm/fpu.h b/arch/nds32/include/asm/fpu.h
index 9b1107b58e23..019f1bcfc5ee 100644
--- a/arch/nds32/include/asm/fpu.h
+++ b/arch/nds32/include/asm/fpu.h
@@ -28,7 +28,18 @@ extern int do_fpuemu(struct pt_regs *regs, struct fpu_struct *fpu);
 #define sNAN64    0xFFFFFFFFFFFFFFFFULL
 #define sNAN32    0xFFFFFFFFUL
 
+#if IS_ENABLED(CONFIG_SUPPORT_DENORMAL_ARITHMETIC)
+/*
+ * Denormalized number is unsupported by nds32 FPU. Hence the operation
+ * is treated as underflow cases when the final result is a denormalized
+ * number. To enhance precision, underflow exception trap should be
+ * enabled by default and kerenl will re-execute it by fpu emulator
+ * when getting underflow exception.
+ */
+#define FPCSR_INIT  FPCSR_mskUDFE
+#else
 #define FPCSR_INIT  0x0UL
+#endif
 
 extern const struct fpu_struct init_fpuregs;
 

commit 1ac832509f2ea1b566f0c06f98f308f58b03d098
Author: Vincent Chen <vincentc@andestech.com>
Date:   Thu Nov 22 11:14:35 2018 +0800

    nds32: Support FP emulation
    
    The Andes FPU coprocessor does not support denormalized number handling.
    According to the specification, FPU generates a denorm input exception
    that requires the kernel to deal with this instrution operation when it
    encounters denormalized operands. Hence an nds32 FPU ISA emulator in the
    kernel is required to meet requirement.
    
    Signed-off-by: Vincent Chen <vincentc@andestech.com>
    Signed-off-by: Nickhu <nickhu@andestech.com>
    Acked-by: Greentime Hu <greentime@andestech.com>
    Signed-off-by: Greentime Hu <greentime@andestech.com>

diff --git a/arch/nds32/include/asm/fpu.h b/arch/nds32/include/asm/fpu.h
index f7a7f6b2ea8f..9b1107b58e23 100644
--- a/arch/nds32/include/asm/fpu.h
+++ b/arch/nds32/include/asm/fpu.h
@@ -15,6 +15,7 @@ extern bool has_fpu;
 extern void save_fpu(struct task_struct *__tsk);
 extern void load_fpu(const struct fpu_struct *fpregs);
 extern bool do_fpu_exception(unsigned int subtype, struct pt_regs *regs);
+extern int do_fpuemu(struct pt_regs *regs, struct fpu_struct *fpu);
 
 #define test_tsk_fpu(regs)	(regs->fucop_ctl & FUCOP_CTL_mskCP0EN)
 

commit e46bf83c1864a20f9dd17d597ec9be18ed05add8
Author: Vincent Chen <vincentc@andestech.com>
Date:   Thu Nov 22 11:14:34 2018 +0800

    nds32: nds32 FPU port
    
    This patch set contains basic components for supporting the nds32 FPU,
    such as exception handlers and context switch for FPU registers. By
    default, the lazy FPU scheme is supported and the user can configure it via
    CONFIG_LZAY_FPU.
    
    Signed-off-by: Vincent Chen <vincentc@andestech.com>
    Acked-by: Greentime Hu <greentime@andestech.com>
    Signed-off-by: Greentime Hu <greentime@andestech.com>

diff --git a/arch/nds32/include/asm/fpu.h b/arch/nds32/include/asm/fpu.h
new file mode 100644
index 000000000000..f7a7f6b2ea8f
--- /dev/null
+++ b/arch/nds32/include/asm/fpu.h
@@ -0,0 +1,114 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2005-2018 Andes Technology Corporation */
+
+#ifndef __ASM_NDS32_FPU_H
+#define __ASM_NDS32_FPU_H
+
+#if IS_ENABLED(CONFIG_FPU)
+#ifndef __ASSEMBLY__
+#include <linux/sched/task_stack.h>
+#include <linux/preempt.h>
+#include <asm/ptrace.h>
+
+extern bool has_fpu;
+
+extern void save_fpu(struct task_struct *__tsk);
+extern void load_fpu(const struct fpu_struct *fpregs);
+extern bool do_fpu_exception(unsigned int subtype, struct pt_regs *regs);
+
+#define test_tsk_fpu(regs)	(regs->fucop_ctl & FUCOP_CTL_mskCP0EN)
+
+/*
+ * Initially load the FPU with signalling NANS.  This bit pattern
+ * has the property that no matter whether considered as single or as
+ * double precision, it still represents a signalling NAN.
+ */
+
+#define sNAN64    0xFFFFFFFFFFFFFFFFULL
+#define sNAN32    0xFFFFFFFFUL
+
+#define FPCSR_INIT  0x0UL
+
+extern const struct fpu_struct init_fpuregs;
+
+static inline void disable_ptreg_fpu(struct pt_regs *regs)
+{
+	regs->fucop_ctl &= ~FUCOP_CTL_mskCP0EN;
+}
+
+static inline void enable_ptreg_fpu(struct pt_regs *regs)
+{
+	regs->fucop_ctl |= FUCOP_CTL_mskCP0EN;
+}
+
+static inline void enable_fpu(void)
+{
+	unsigned long fucop_ctl;
+
+	fucop_ctl = __nds32__mfsr(NDS32_SR_FUCOP_CTL) | FUCOP_CTL_mskCP0EN;
+	__nds32__mtsr(fucop_ctl, NDS32_SR_FUCOP_CTL);
+	__nds32__isb();
+}
+
+static inline void disable_fpu(void)
+{
+	unsigned long fucop_ctl;
+
+	fucop_ctl = __nds32__mfsr(NDS32_SR_FUCOP_CTL) & ~FUCOP_CTL_mskCP0EN;
+	__nds32__mtsr(fucop_ctl, NDS32_SR_FUCOP_CTL);
+	__nds32__isb();
+}
+
+static inline void lose_fpu(void)
+{
+	preempt_disable();
+#if IS_ENABLED(CONFIG_LAZY_FPU)
+	if (last_task_used_math == current) {
+		last_task_used_math = NULL;
+#else
+	if (test_tsk_fpu(task_pt_regs(current))) {
+#endif
+		save_fpu(current);
+	}
+	disable_ptreg_fpu(task_pt_regs(current));
+	preempt_enable();
+}
+
+static inline void own_fpu(void)
+{
+	preempt_disable();
+#if IS_ENABLED(CONFIG_LAZY_FPU)
+	if (last_task_used_math != current) {
+		if (last_task_used_math != NULL)
+			save_fpu(last_task_used_math);
+		load_fpu(&current->thread.fpu);
+		last_task_used_math = current;
+	}
+#else
+	if (!test_tsk_fpu(task_pt_regs(current))) {
+		load_fpu(&current->thread.fpu);
+	}
+#endif
+	enable_ptreg_fpu(task_pt_regs(current));
+	preempt_enable();
+}
+
+#if !IS_ENABLED(CONFIG_LAZY_FPU)
+static inline void unlazy_fpu(struct task_struct *tsk)
+{
+	preempt_disable();
+	if (test_tsk_fpu(task_pt_regs(tsk)))
+		save_fpu(tsk);
+	preempt_enable();
+}
+#endif /* !CONFIG_LAZY_FPU */
+static inline void clear_fpu(struct pt_regs *regs)
+{
+	preempt_disable();
+	if (test_tsk_fpu(regs))
+		disable_ptreg_fpu(regs);
+	preempt_enable();
+}
+#endif /* CONFIG_FPU */
+#endif /* __ASSEMBLY__ */
+#endif /* __ASM_NDS32_FPU_H */
