commit 95f93ed7fe92c16f5346e477491d91e4fa8e92b8
Author: Zong Li <zong@andestech.com>
Date:   Mon Aug 20 09:51:29 2018 +0800

    nds32: Add macro definition for offset of lp register on stack
    
    Use macro to replace the magic number.
    
    Signed-off-by: Zong Li <zong@andestech.com>
    Acked-by: Greentime Hu <greentime@andestech.com>
    Signed-off-by: Greentime Hu <greentime@andestech.com>

diff --git a/arch/nds32/kernel/stacktrace.c b/arch/nds32/kernel/stacktrace.c
index 36bc87003e83..d974c0c1c65f 100644
--- a/arch/nds32/kernel/stacktrace.c
+++ b/arch/nds32/kernel/stacktrace.c
@@ -31,7 +31,7 @@ void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 	       && (fpn >= (unsigned long *)TASK_SIZE)) {
 		unsigned long lpp, fpp;
 
-		lpp = fpn[-1];
+		lpp = fpn[LP_OFFSET];
 		fpp = fpn[FP_OFFSET];
 		if (!__kernel_text_address(lpp))
 			break;

commit 1e377ae9b04aef4dc531fa4c5f81b65d440ebcba
Author: Zong Li <zong@andestech.com>
Date:   Wed Aug 15 11:05:40 2018 +0800

    nds32/stack: Get real return address by using ftrace_graph_ret_addr
    
    Function graph tracer has modified the return address to
    'return_to_handler' on stack, and provide the 'ftrace_graph_ret_addr' to
    get the real return address.
    
    Signed-off-by: Zong Li <zong@andestech.com>
    Acked-by: Greentime Hu <greentime@andestech.com>
    Signed-off-by: Greentime Hu <greentime@andestech.com>

diff --git a/arch/nds32/kernel/stacktrace.c b/arch/nds32/kernel/stacktrace.c
index 8b231e910ea6..36bc87003e83 100644
--- a/arch/nds32/kernel/stacktrace.c
+++ b/arch/nds32/kernel/stacktrace.c
@@ -4,6 +4,7 @@
 #include <linux/sched/debug.h>
 #include <linux/sched/task_stack.h>
 #include <linux/stacktrace.h>
+#include <linux/ftrace.h>
 
 void save_stack_trace(struct stack_trace *trace)
 {
@@ -16,6 +17,7 @@ void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 	unsigned long *fpn;
 	int skip = trace->skip;
 	int savesched;
+	int graph_idx = 0;
 
 	if (tsk == current) {
 		__asm__ __volatile__("\tori\t%0, $fp, #0\n":"=r"(fpn));
@@ -33,6 +35,8 @@ void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 		fpp = fpn[FP_OFFSET];
 		if (!__kernel_text_address(lpp))
 			break;
+		else
+			lpp = ftrace_graph_ret_addr(tsk, &graph_idx, lpp, NULL);
 
 		if (savesched || !in_sched_functions(lpp)) {
 			if (skip) {

commit e3f4624388731eb475ef7494b43440b3ad9269e1
Author: Greentime Hu <greentime@andestech.com>
Date:   Thu Apr 19 15:45:45 2018 +0800

    nds32: Fix the symbols undefined issue by exporting them.
    
    It broke the 'allmodconfig' build.
      LD      vmlinux
      SYSMAP  System.map
      Building modules, stage 2.
      MODPOST 5028 modules
    ERROR: "flush_dcache_page" [net/sunrpc/xprtrdma/rpcrdma.ko] undefined!
    ERROR: "empty_zero_page" [net/ceph/libceph.ko] undefined!
    ERROR: "save_stack_trace" [kernel/backtracetest.ko] undefined!
    ERROR: "clear_page" [fs/ocfs2/dlm/ocfs2_dlm.ko] undefined!
    ERROR: "copy_page" [fs/nilfs2/nilfs2.ko] undefined!
    ...
    
    Signed-off-by: Greentime Hu <greentime@andestech.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/nds32/kernel/stacktrace.c b/arch/nds32/kernel/stacktrace.c
index bc70113c0e84..8b231e910ea6 100644
--- a/arch/nds32/kernel/stacktrace.c
+++ b/arch/nds32/kernel/stacktrace.c
@@ -9,6 +9,7 @@ void save_stack_trace(struct stack_trace *trace)
 {
 	save_stack_trace_tsk(current, trace);
 }
+EXPORT_SYMBOL_GPL(save_stack_trace);
 
 void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 {
@@ -45,3 +46,4 @@ void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 		fpn = (unsigned long *)fpp;
 	}
 }
+EXPORT_SYMBOL_GPL(save_stack_trace_tsk);

commit 2923f5ea7738cb9f5372bb9d7ac9886cf4193003
Author: Greentime Hu <greentime@andestech.com>
Date:   Tue Oct 24 14:42:02 2017 +0800

    nds32: Exception handling
    
    This patch includes the exception/interrupt entries, pt_reg structure and
    related accessors.
    
    /* Unaligned accessing handling*/
    Andes processors cannot load/store information which is not naturally
    aligned on the bus, i.e., loading a 4 byte data whose start address must
    be divisible by 4. If unaligned data accessing is happened, data
    unaligned exception will be triggered and user will get SIGSEGV or
    kernel oops according to the unaligned address. In order to make user be
    able to load/store data from an unaligned address, software load/store
    emulation is implemented in arch/nds32/mm/alignment.c to address data
    unaligned exception.
    
    Unaligned accessing handling is disabled by default because it is not a
    normal case. User can enable this feature by following steps.
    
    A. Compile time:
        1. Enable kernel config CONFIG_ALIGNMENT_TRAP
    B. Run time:
        1. Enter /proc/sys/nds32/unaligned_acess folder
        2. Write 1 to file enable_mode to enable unaligned accessing
           handling. User can disable it by writing 0 to this file.
        3. Write 1 to file debug to show which unaligned address is under
           processing. User can disable it by writing 0 to this file.
    
    However, unaligned accessing handler cannot work if this unaligned
    address is not accessible such as protection violation. On this
    condition, the default behaviors for addressing data unaligned exception
    still happen
    
    Signed-off-by: Vincent Chen <vincentc@andestech.com>
    Signed-off-by: Greentime Hu <greentime@andestech.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/nds32/kernel/stacktrace.c b/arch/nds32/kernel/stacktrace.c
new file mode 100644
index 000000000000..bc70113c0e84
--- /dev/null
+++ b/arch/nds32/kernel/stacktrace.c
@@ -0,0 +1,47 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2005-2017 Andes Technology Corporation
+
+#include <linux/sched/debug.h>
+#include <linux/sched/task_stack.h>
+#include <linux/stacktrace.h>
+
+void save_stack_trace(struct stack_trace *trace)
+{
+	save_stack_trace_tsk(current, trace);
+}
+
+void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
+{
+	unsigned long *fpn;
+	int skip = trace->skip;
+	int savesched;
+
+	if (tsk == current) {
+		__asm__ __volatile__("\tori\t%0, $fp, #0\n":"=r"(fpn));
+		savesched = 1;
+	} else {
+		fpn = (unsigned long *)thread_saved_fp(tsk);
+		savesched = 0;
+	}
+
+	while (!kstack_end(fpn) && !((unsigned long)fpn & 0x3)
+	       && (fpn >= (unsigned long *)TASK_SIZE)) {
+		unsigned long lpp, fpp;
+
+		lpp = fpn[-1];
+		fpp = fpn[FP_OFFSET];
+		if (!__kernel_text_address(lpp))
+			break;
+
+		if (savesched || !in_sched_functions(lpp)) {
+			if (skip) {
+				skip--;
+			} else {
+				trace->entries[trace->nr_entries++] = lpp;
+				if (trace->nr_entries >= trace->max_entries)
+					break;
+			}
+		}
+		fpn = (unsigned long *)fpp;
+	}
+}
