commit 1ccea77e2a2687cae171b7987eb44730ec8c6d5f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:43 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 13
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not see http www gnu org licenses
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details [based]
      [from] [clk] [highbank] [c] you should have received a copy of the
      gnu general public license along with this program if not see http
      www gnu org licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 355 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154041.837383322@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/nios2/kernel/kgdb.c b/arch/nios2/kernel/kgdb.c
index 37b25f844a2d..d0963fcb11b7 100644
--- a/arch/nios2/kernel/kgdb.c
+++ b/arch/nios2/kernel/kgdb.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Nios2 KGDB support
  *
@@ -6,20 +7,6 @@
  *
  * Based on the code posted by Kazuyasu on the Altera Forum at:
  * http://www.alteraforum.com/forum/showpost.php?p=77003&postcount=20
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
  */
 #include <linux/ptrace.h>
 #include <linux/kgdb.h>

commit cc0282975b3f887005c380adcf0af95915f0c1bb
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Thu Dec 6 20:07:40 2018 +0000

    kgdb/treewide: constify struct kgdb_arch arch_kgdb_ops
    
    checkpatch.pl reports the following:
    
      WARNING: struct kgdb_arch should normally be const
      #28: FILE: arch/mips/kernel/kgdb.c:397:
      +struct kgdb_arch arch_kgdb_ops = {
    
    This report makes sense, as all other ops struct, this
    one should also be const. This patch does the change.
    
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: x86@kernel.org
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Acked-by: Paul Burton <paul.burton@mips.com>
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Acked-by: Borislav Petkov <bp@suse.de>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>

diff --git a/arch/nios2/kernel/kgdb.c b/arch/nios2/kernel/kgdb.c
index 117859122d1c..37b25f844a2d 100644
--- a/arch/nios2/kernel/kgdb.c
+++ b/arch/nios2/kernel/kgdb.c
@@ -165,7 +165,7 @@ void kgdb_arch_exit(void)
 	/* Nothing to do */
 }
 
-struct kgdb_arch arch_kgdb_ops = {
+const struct kgdb_arch arch_kgdb_ops = {
 	/* Breakpoint instruction: trap 30 */
 	.gdb_bpt_instr = { 0xba, 0x6f, 0x3b, 0x00 },
 };

commit d16d2be111a61baf3a4696f07bfc7a8e36697cec
Author: Ley Foon Tan <lftan@altera.com>
Date:   Mon Feb 16 19:26:43 2015 +0800

    nios2: add kgdb support
    
    Signed-off-by: Ley Foon Tan <lftan@altera.com>

diff --git a/arch/nios2/kernel/kgdb.c b/arch/nios2/kernel/kgdb.c
new file mode 100644
index 000000000000..117859122d1c
--- /dev/null
+++ b/arch/nios2/kernel/kgdb.c
@@ -0,0 +1,171 @@
+/*
+ * Nios2 KGDB support
+ *
+ * Copyright (C) 2015 Altera Corporation
+ * Copyright (C) 2011 Tobias Klauser <tklauser@distanz.ch>
+ *
+ * Based on the code posted by Kazuyasu on the Altera Forum at:
+ * http://www.alteraforum.com/forum/showpost.php?p=77003&postcount=20
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <linux/ptrace.h>
+#include <linux/kgdb.h>
+#include <linux/kdebug.h>
+#include <linux/io.h>
+
+static int wait_for_remote_debugger;
+
+struct dbg_reg_def_t dbg_reg_def[DBG_MAX_REG_NUM] =
+{
+	{ "zero", GDB_SIZEOF_REG, -1 },
+	{ "at", GDB_SIZEOF_REG, offsetof(struct pt_regs, r1) },
+	{ "r2", GDB_SIZEOF_REG, offsetof(struct pt_regs, r2) },
+	{ "r3", GDB_SIZEOF_REG, offsetof(struct pt_regs, r3) },
+	{ "r4", GDB_SIZEOF_REG, offsetof(struct pt_regs, r4) },
+	{ "r5", GDB_SIZEOF_REG, offsetof(struct pt_regs, r5) },
+	{ "r6", GDB_SIZEOF_REG, offsetof(struct pt_regs, r6) },
+	{ "r7", GDB_SIZEOF_REG, offsetof(struct pt_regs, r7) },
+	{ "r8", GDB_SIZEOF_REG, offsetof(struct pt_regs, r8) },
+	{ "r9", GDB_SIZEOF_REG, offsetof(struct pt_regs, r9) },
+	{ "r10", GDB_SIZEOF_REG, offsetof(struct pt_regs, r10) },
+	{ "r11", GDB_SIZEOF_REG, offsetof(struct pt_regs, r11) },
+	{ "r12", GDB_SIZEOF_REG, offsetof(struct pt_regs, r12) },
+	{ "r13", GDB_SIZEOF_REG, offsetof(struct pt_regs, r13) },
+	{ "r14", GDB_SIZEOF_REG, offsetof(struct pt_regs, r14) },
+	{ "r15", GDB_SIZEOF_REG, offsetof(struct pt_regs, r15) },
+	{ "r16", GDB_SIZEOF_REG, -1 },
+	{ "r17", GDB_SIZEOF_REG, -1 },
+	{ "r18", GDB_SIZEOF_REG, -1 },
+	{ "r19", GDB_SIZEOF_REG, -1 },
+	{ "r20", GDB_SIZEOF_REG, -1 },
+	{ "r21", GDB_SIZEOF_REG, -1 },
+	{ "r22", GDB_SIZEOF_REG, -1 },
+	{ "r23", GDB_SIZEOF_REG, -1 },
+	{ "et", GDB_SIZEOF_REG, -1 },
+	{ "bt", GDB_SIZEOF_REG, -1 },
+	{ "gp", GDB_SIZEOF_REG, offsetof(struct pt_regs, gp) },
+	{ "sp", GDB_SIZEOF_REG, offsetof(struct pt_regs, sp) },
+	{ "fp", GDB_SIZEOF_REG, offsetof(struct pt_regs, fp) },
+	{ "ea", GDB_SIZEOF_REG, -1 },
+	{ "ba", GDB_SIZEOF_REG, -1 },
+	{ "ra", GDB_SIZEOF_REG, offsetof(struct pt_regs, ra) },
+	{ "pc", GDB_SIZEOF_REG, offsetof(struct pt_regs, ea) },
+	{ "status", GDB_SIZEOF_REG, -1 },
+	{ "estatus", GDB_SIZEOF_REG, offsetof(struct pt_regs, estatus) },
+	{ "bstatus", GDB_SIZEOF_REG, -1 },
+	{ "ienable", GDB_SIZEOF_REG, -1 },
+	{ "ipending", GDB_SIZEOF_REG, -1},
+	{ "cpuid", GDB_SIZEOF_REG, -1 },
+	{ "ctl6", GDB_SIZEOF_REG, -1 },
+	{ "exception", GDB_SIZEOF_REG, -1 },
+	{ "pteaddr", GDB_SIZEOF_REG, -1 },
+	{ "tlbacc", GDB_SIZEOF_REG, -1 },
+	{ "tlbmisc", GDB_SIZEOF_REG, -1 },
+	{ "eccinj", GDB_SIZEOF_REG, -1 },
+	{ "badaddr", GDB_SIZEOF_REG, -1 },
+	{ "config", GDB_SIZEOF_REG, -1 },
+	{ "mpubase", GDB_SIZEOF_REG, -1 },
+	{ "mpuacc", GDB_SIZEOF_REG, -1 },
+};
+
+char *dbg_get_reg(int regno, void *mem, struct pt_regs *regs)
+{
+	if (regno >= DBG_MAX_REG_NUM || regno < 0)
+		return NULL;
+
+	if (dbg_reg_def[regno].offset != -1)
+		memcpy(mem, (void *)regs + dbg_reg_def[regno].offset,
+		       dbg_reg_def[regno].size);
+	else
+		memset(mem, 0, dbg_reg_def[regno].size);
+
+	return dbg_reg_def[regno].name;
+}
+
+int dbg_set_reg(int regno, void *mem, struct pt_regs *regs)
+{
+	if (regno >= DBG_MAX_REG_NUM || regno < 0)
+		return -EINVAL;
+
+	if (dbg_reg_def[regno].offset != -1)
+		memcpy((void *)regs + dbg_reg_def[regno].offset, mem,
+		       dbg_reg_def[regno].size);
+
+	return 0;
+}
+
+void sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p)
+{
+	memset((char *)gdb_regs, 0, NUMREGBYTES);
+	gdb_regs[GDB_SP] = p->thread.kregs->sp;
+	gdb_regs[GDB_PC] = p->thread.kregs->ea;
+}
+
+void kgdb_arch_set_pc(struct pt_regs *regs, unsigned long pc)
+{
+	regs->ea = pc;
+}
+
+int kgdb_arch_handle_exception(int vector, int signo, int err_code,
+				char *remcom_in_buffer, char *remcom_out_buffer,
+				struct pt_regs *regs)
+{
+	char *ptr;
+	unsigned long addr;
+
+	switch (remcom_in_buffer[0]) {
+	case 's':
+	case 'c':
+		/* handle the optional parameters */
+		ptr = &remcom_in_buffer[1];
+		if (kgdb_hex2long(&ptr, &addr))
+			regs->ea = addr;
+
+		return 0;
+	}
+
+	return -1; /* this means that we do not want to exit from the handler */
+}
+
+asmlinkage void kgdb_breakpoint_c(struct pt_regs *regs)
+{
+	/*
+	 * The breakpoint entry code has moved the PC on by 4 bytes, so we must
+	 * move it back.  This could be done on the host but we do it here
+	 */
+	if (!wait_for_remote_debugger)
+		regs->ea -= 4;
+	else	/* pass the first trap 30 code */
+		wait_for_remote_debugger = 0;
+
+	kgdb_handle_exception(30, SIGTRAP, 0, regs);
+}
+
+int kgdb_arch_init(void)
+{
+	wait_for_remote_debugger = 1;
+	return 0;
+}
+
+void kgdb_arch_exit(void)
+{
+	/* Nothing to do */
+}
+
+struct kgdb_arch arch_kgdb_ops = {
+	/* Breakpoint instruction: trap 30 */
+	.gdb_bpt_instr = { 0xba, 0x6f, 0x3b, 0x00 },
+};
