commit a8950e49bd241dc9ad90c24e92e23e95dbe9f018
Author: Romain Perier <romain.perier@free-electrons.com>
Date:   Tue Apr 19 18:17:32 2016 +0800

    nios2: memset: use the right constraint modifier for the %4 output operand
    
    Depending on the size of the area to be memset'ed, the nios2 memset implementation
    either uses a naive loop (for buffers smaller or equal than 8 bytes) or a more optimized
    implementation (for buffers larger than 8 bytes). This implementation does 4-byte stores
    rather than 1-byte stores to speed up memset.
    
    However, we discovered that on our nios2 platform, memset() was not properly setting the
    buffer to the expected value. A memset of 0xff would not set the entire buffer to 0xff, but to:
    
    0xff 0x00 0xff 0x00 0xff 0x00 0xff 0x00 ...
    
    Which is obviously incorrect. Our investigation has revealed that the problem lies in the
    incorrect constraints used in the inline assembly.
    
    The following piece of assembly, from the nios2 memset implementation, is supposed to
    create a 4-byte value that repeats 4 times the 1-byte pattern passed as memset argument:
    
    /* fill8 %3, %5 (c & 0xff) */
    "       slli    %4, %5, 8\n"
    "       or      %4, %4, %5\n"
    "       slli    %3, %4, 16\n"
    "       or      %3, %3, %4\n"
    
    However, depending on the compiler and optimization level, this code might be compiled as:
    
    34:     280a923a        slli    r5,r5,8
    38:     294ab03a        or      r5,r5,r5
    3c:     2808943a        slli    r4,r5,16
    40:     2148b03a        or      r4,r4,r5
    
    This is wrong because r5 gets used both for %5 and %4, which leads to the final pattern
    stored in r4 to be 0xff00ff00 rather than the expected 0xffffffff.
    
    %4 is defined with the "=r" constraint, i.e as an output operand. However, as explained in
    http://www.ethernut.de/en/documents/arm-inline-asm.html, this does not prevent gcc from
    using the same register for an output operand (%4) and input operand (%5). By using the
    constraint modifier '&', we indicate that the register should be used for output only. With this
    change, we get the following assembly output:
    
    34:     2810923a        slli    r8,r5,8
    38:     4150b03a        or      r8,r8,r5
    3c:     400e943a        slli    r7,r8,16
    40:     3a0eb03a        or      r7,r7,r8
    
    Which correctly produces the 0xffffffff pattern when 0xff is passed as the memset() pattern.
    
    It is worth mentioning the observed consequence of this bug: we were hitting the kernel
    BUG() in mm/bootmem.c:__free() that verifies when marking a page as free that it was
    previously marked as occupied (i.e that the bit was set to 1). The entire bootmem bitmap is
    set to 0xff bit via a memset() during the bootmem initialization. The bootmem_free() call right
    after the initialization was finding some bits to be set to 0, which didn't make sense since the
    bitmap has just been memset'ed to 0xff. Except that due to the bug explained above, the
    bitmap was in fact initialized to 0xff00ff00.
    
    Thanks to Marek Vasut for his help and feedback.
    
    Signed-off-by: Romain Perier <romain.perier@free-electrons.com>
    Acked-by: Marek Vasut <marex@denx.de>
    Acked-by: Ley Foon Tan <lftan@altera.com>

diff --git a/arch/nios2/lib/memset.c b/arch/nios2/lib/memset.c
index c2cfcb121e34..2fcefe720283 100644
--- a/arch/nios2/lib/memset.c
+++ b/arch/nios2/lib/memset.c
@@ -68,7 +68,7 @@ void *memset(void *s, int c, size_t count)
 		  "=r" (charcnt),	/* %1  Output */
 		  "=r" (dwordcnt),	/* %2  Output */
 		  "=r" (fill8reg),	/* %3  Output */
-		  "=r" (wrkrega)	/* %4  Output */
+		  "=&r" (wrkrega)	/* %4  Output only */
 		: "r" (c),		/* %5  Input */
 		  "0" (s),		/* %0  Input/Output */
 		  "1" (count)		/* %1  Input/Output */

commit bb3fc5ddef93836a36a39308cf7eca82ef0a1c4c
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Fri Nov 6 14:19:11 2015 +0800

    nios2: Remove unnecessary #ifdef guards
    
    __HAVE_ARCH_MEMMOVE and __HAVE_ARCH_MEMSET are unconditionally defined
    for nios2, so there is no need to protect the function definitions of
    memmove() and memset().
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Acked-by: Ley Foon Tan <lftan@altera.com>

diff --git a/arch/nios2/lib/memset.c b/arch/nios2/lib/memset.c
index 65e97802f5cc..c2cfcb121e34 100644
--- a/arch/nios2/lib/memset.c
+++ b/arch/nios2/lib/memset.c
@@ -10,7 +10,6 @@
 #include <linux/types.h>
 #include <linux/string.h>
 
-#ifdef __HAVE_ARCH_MEMSET
 void *memset(void *s, int c, size_t count)
 {
 	int destptr, charcnt, dwordcnt, fill8reg, wrkrega;
@@ -78,4 +77,3 @@ void *memset(void *s, int c, size_t count)
 
 	return s;
 }
-#endif /* __HAVE_ARCH_MEMSET */

commit eea9507a69d637d52705de8703b168bf6bfe5643
Author: Ley Foon Tan <lftan@altera.com>
Date:   Thu Nov 6 15:20:00 2014 +0800

    nios2: Library functions
    
    Add optimised library functions for nios2.
    
    Signed-off-by: Ley Foon Tan <lftan@altera.com>

diff --git a/arch/nios2/lib/memset.c b/arch/nios2/lib/memset.c
new file mode 100644
index 000000000000..65e97802f5cc
--- /dev/null
+++ b/arch/nios2/lib/memset.c
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2011 Tobias Klauser <tklauser@distanz.ch>
+ * Copyright (C) 2004 Microtronix Datacom Ltd
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/types.h>
+#include <linux/string.h>
+
+#ifdef __HAVE_ARCH_MEMSET
+void *memset(void *s, int c, size_t count)
+{
+	int destptr, charcnt, dwordcnt, fill8reg, wrkrega;
+
+	if (!count)
+		return s;
+
+	c &= 0xFF;
+
+	if (count <= 8) {
+		char *xs = (char *) s;
+
+		while (count--)
+			*xs++ = c;
+		return s;
+	}
+
+	__asm__ __volatile__ (
+		/* fill8 %3, %5 (c & 0xff) */
+		"	slli	%4, %5, 8\n"
+		"	or	%4, %4, %5\n"
+		"	slli    %3, %4, 16\n"
+		"	or	%3, %3, %4\n"
+		/* Word-align %0 (s) if necessary */
+		"	andi	%4, %0, 0x01\n"
+		"	beq	%4, zero, 1f\n"
+		"	addi	%1, %1, -1\n"
+		"	stb	%3, 0(%0)\n"
+		"	addi	%0, %0, 1\n"
+		"1:	mov	%2, %1\n"
+		/* Dword-align %0 (s) if necessary */
+		"	andi	%4, %0, 0x02\n"
+		"	beq	%4, zero, 2f\n"
+		"	addi	%1, %1, -2\n"
+		"	sth	%3, 0(%0)\n"
+		"	addi	%0, %0, 2\n"
+		"	mov	%2, %1\n"
+		/* %1 and %2 are how many more bytes to set */
+		"2:	srli	%2, %2, 2\n"
+		/* %2 is how many dwords to set */
+		"3:	stw	%3, 0(%0)\n"
+		"	addi	%0, %0, 4\n"
+		"	addi    %2, %2, -1\n"
+		"	bne	%2, zero, 3b\n"
+		/* store residual word and/or byte if necessary */
+		"	andi	%4, %1, 0x02\n"
+		"	beq	%4, zero, 4f\n"
+		"	sth	%3, 0(%0)\n"
+		"	addi	%0, %0, 2\n"
+		/* store residual byte if necessary */
+		"4:	andi	%4, %1, 0x01\n"
+		"	beq	%4, zero, 5f\n"
+		"	stb	%3, 0(%0)\n"
+		"5:\n"
+		: "=r" (destptr),	/* %0  Output */
+		  "=r" (charcnt),	/* %1  Output */
+		  "=r" (dwordcnt),	/* %2  Output */
+		  "=r" (fill8reg),	/* %3  Output */
+		  "=r" (wrkrega)	/* %4  Output */
+		: "r" (c),		/* %5  Input */
+		  "0" (s),		/* %0  Input/Output */
+		  "1" (count)		/* %1  Input/Output */
+		: "memory"		/* clobbered */
+	);
+
+	return s;
+}
+#endif /* __HAVE_ARCH_MEMSET */
