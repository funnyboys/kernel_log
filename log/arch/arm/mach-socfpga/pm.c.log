commit 9952f6918daa4ab5fc81307a9f90e31a4df3b200
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 10:10:04 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 201
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms and conditions of the gnu general public license
      version 2 as published by the free software foundation this program
      is distributed in the hope it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 228 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528171438.107155473@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-socfpga/pm.c b/arch/arm/mach-socfpga/pm.c
index d4866788702c..6ed887cf8dc9 100644
--- a/arch/arm/mach-socfpga/pm.c
+++ b/arch/arm/mach-socfpga/pm.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  arch/arm/mach-socfpga/pm.c
  *
@@ -6,18 +7,6 @@
  * with code from pm-imx6.c
  * Copyright 2011-2014 Freescale Semiconductor, Inc.
  * Copyright 2011 Linaro Ltd.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <linux/bitops.h>

commit de067e46eddeda9d8e58996a99e0b2cfc4f0623d
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Mar 2 15:04:47 2018 +0100

    ARM: socfpga: PM: Drop useless check for PM_SUSPEND_STANDBY
    
    As SoCFPGA uses the standard suspend_valid_only_mem() for its
    platform_suspend_ops.valid() callback, its platform_suspend_ops.enter()
    callback will never be called with state equal to PM_SUSPEND_STANDBY.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Dinh Nguyen <dinguyen@kernel.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-socfpga/pm.c b/arch/arm/mach-socfpga/pm.c
index c378ab0c2431..d4866788702c 100644
--- a/arch/arm/mach-socfpga/pm.c
+++ b/arch/arm/mach-socfpga/pm.c
@@ -116,7 +116,6 @@ static int socfpga_pm_suspend(unsigned long arg)
 static int socfpga_pm_enter(suspend_state_t state)
 {
 	switch (state) {
-	case PM_SUSPEND_STANDBY:
 	case PM_SUSPEND_MEM:
 		outer_disable();
 		cpu_suspend(0, socfpga_pm_suspend);

commit 73858173593c31cb94bce63fe1c24eb803bb04e6
Author: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
Date:   Fri Sep 4 15:47:43 2015 -0700

    genalloc: add name arg to gen_pool_get() and devm_gen_pool_create()
    
    This change modifies gen_pool_get() and devm_gen_pool_create() client
    interfaces adding one more argument "name" of a gen_pool object.
    
    Due to implementation gen_pool_get() is capable to retrieve only one
    gen_pool associated with a device even if multiple gen_pools are created,
    fortunately right at the moment it is sufficient for the clients, hence
    provide NULL as a valid argument on both producer devm_gen_pool_create()
    and consumer gen_pool_get() sides.
    
    Because only one created gen_pool per device is addressable, explicitly
    add a restriction to devm_gen_pool_create() to create only one gen_pool
    per device, this implies two possible error codes returned by the
    function, account it on client side (only misc/sram).  This completes
    client side changes related to genalloc updates.
    
    [akpm@linux-foundation.org: gen_pool_get() cleanup]
    Signed-off-by: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Cc: Jean-Christophe Plagniol-Villard <plagnioj@jcrosoft.com>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-socfpga/pm.c b/arch/arm/mach-socfpga/pm.c
index 6a4199f2bffb..c378ab0c2431 100644
--- a/arch/arm/mach-socfpga/pm.c
+++ b/arch/arm/mach-socfpga/pm.c
@@ -56,7 +56,7 @@ static int socfpga_setup_ocram_self_refresh(void)
 		goto put_node;
 	}
 
-	ocram_pool = gen_pool_get(&pdev->dev);
+	ocram_pool = gen_pool_get(&pdev->dev, NULL);
 	if (!ocram_pool) {
 		pr_warn("%s: ocram pool unavailable!\n", __func__);
 		ret = -ENODEV;

commit 0030edf296db8a7afb13573eb12977b7d399cd40
Author: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
Date:   Tue Jun 30 15:00:03 2015 -0700

    genalloc: rename dev_get_gen_pool() to gen_pool_get()
    
    To be consistent with other genalloc interface namings, rename
    dev_get_gen_pool() to gen_pool_get().  The original omitted "dev_" prefix
    is removed, since it points to argument type of the function, and so it
    does not bring any useful information.
    
    [akpm@linux-foundation.org: update arch/arm/mach-socfpga/pm.c]
    Signed-off-by: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: Vinod Koul <vinod.koul@intel.com>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Alan Tull <atull@opensource.altera.com>
    Cc: Dinh Nguyen <dinguyen@opensource.altera.com>
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-socfpga/pm.c b/arch/arm/mach-socfpga/pm.c
index 1ed89fc2b7a8..6a4199f2bffb 100644
--- a/arch/arm/mach-socfpga/pm.c
+++ b/arch/arm/mach-socfpga/pm.c
@@ -56,7 +56,7 @@ static int socfpga_setup_ocram_self_refresh(void)
 		goto put_node;
 	}
 
-	ocram_pool = dev_get_gen_pool(&pdev->dev);
+	ocram_pool = gen_pool_get(&pdev->dev);
 	if (!ocram_pool) {
 		pr_warn("%s: ocram pool unavailable!\n", __func__);
 		ret = -ENODEV;

commit 44fd8c7d4005f660f48679439f0a54225ba234a4
Author: Alan Tull <atull@opensource.altera.com>
Date:   Fri Jun 5 08:24:52 2015 -0500

    ARM: socfpga: support suspend to ram
    
    Add code that requests that the sdr controller go into
    self-refresh mode.  This code is run from ocram.
    
    Suspend-to-RAM and EDAC support are mutually exclusive on
    SOCFPGA.  If the EDAC is enabled, it will prevent the
    platform from going into suspend.
    
    Example of how to request to suspend to ram:
     $ echo enabled > \
    /sys/devices/soc/ffc02000.serial0/tty/ttyS0/power/wakeup
    
     $ echo -n mem > /sys/power/state
    
    Signed-off-by: Alan Tull <atull@opensource.altera.com>
    Signed-off-by: Dinh Nguyen <dinguyen@opensource.altera.com>
    Signed-off-by: Kevin Hilman <khilman@linaro.org>

diff --git a/arch/arm/mach-socfpga/pm.c b/arch/arm/mach-socfpga/pm.c
new file mode 100644
index 000000000000..1ed89fc2b7a8
--- /dev/null
+++ b/arch/arm/mach-socfpga/pm.c
@@ -0,0 +1,149 @@
+/*
+ *  arch/arm/mach-socfpga/pm.c
+ *
+ * Copyright (C) 2014-2015 Altera Corporation. All rights reserved.
+ *
+ * with code from pm-imx6.c
+ * Copyright 2011-2014 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/bitops.h>
+#include <linux/genalloc.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/of_platform.h>
+#include <linux/suspend.h>
+#include <asm/suspend.h>
+#include <asm/fncpy.h>
+#include "core.h"
+
+/* Pointer to function copied to ocram */
+static u32 (*socfpga_sdram_self_refresh_in_ocram)(u32 sdr_base);
+
+static int socfpga_setup_ocram_self_refresh(void)
+{
+	struct platform_device *pdev;
+	phys_addr_t ocram_pbase;
+	struct device_node *np;
+	struct gen_pool *ocram_pool;
+	unsigned long ocram_base;
+	void __iomem *suspend_ocram_base;
+	int ret = 0;
+
+	np = of_find_compatible_node(NULL, NULL, "mmio-sram");
+	if (!np) {
+		pr_err("%s: Unable to find mmio-sram in dtb\n", __func__);
+		return -ENODEV;
+	}
+
+	pdev = of_find_device_by_node(np);
+	if (!pdev) {
+		pr_warn("%s: failed to find ocram device!\n", __func__);
+		ret = -ENODEV;
+		goto put_node;
+	}
+
+	ocram_pool = dev_get_gen_pool(&pdev->dev);
+	if (!ocram_pool) {
+		pr_warn("%s: ocram pool unavailable!\n", __func__);
+		ret = -ENODEV;
+		goto put_node;
+	}
+
+	ocram_base = gen_pool_alloc(ocram_pool, socfpga_sdram_self_refresh_sz);
+	if (!ocram_base) {
+		pr_warn("%s: unable to alloc ocram!\n", __func__);
+		ret = -ENOMEM;
+		goto put_node;
+	}
+
+	ocram_pbase = gen_pool_virt_to_phys(ocram_pool, ocram_base);
+
+	suspend_ocram_base = __arm_ioremap_exec(ocram_pbase,
+						socfpga_sdram_self_refresh_sz,
+						false);
+	if (!suspend_ocram_base) {
+		pr_warn("%s: __arm_ioremap_exec failed!\n", __func__);
+		ret = -ENOMEM;
+		goto put_node;
+	}
+
+	/* Copy the code that puts DDR in self refresh to ocram */
+	socfpga_sdram_self_refresh_in_ocram =
+		(void *)fncpy(suspend_ocram_base,
+			      &socfpga_sdram_self_refresh,
+			      socfpga_sdram_self_refresh_sz);
+
+	WARN(!socfpga_sdram_self_refresh_in_ocram,
+	     "could not copy function to ocram");
+	if (!socfpga_sdram_self_refresh_in_ocram)
+		ret = -EFAULT;
+
+put_node:
+	of_node_put(np);
+
+	return ret;
+}
+
+static int socfpga_pm_suspend(unsigned long arg)
+{
+	u32 ret;
+
+	if (!sdr_ctl_base_addr)
+		return -EFAULT;
+
+	ret = socfpga_sdram_self_refresh_in_ocram((u32)sdr_ctl_base_addr);
+
+	pr_debug("%s self-refresh loops request=%d exit=%d\n", __func__,
+		 ret & 0xffff, (ret >> 16) & 0xffff);
+
+	return 0;
+}
+
+static int socfpga_pm_enter(suspend_state_t state)
+{
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+	case PM_SUSPEND_MEM:
+		outer_disable();
+		cpu_suspend(0, socfpga_pm_suspend);
+		outer_resume();
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static const struct platform_suspend_ops socfpga_pm_ops = {
+	.valid	= suspend_valid_only_mem,
+	.enter	= socfpga_pm_enter,
+};
+
+static int __init socfpga_pm_init(void)
+{
+	int ret;
+
+	ret = socfpga_setup_ocram_self_refresh();
+	if (ret)
+		return ret;
+
+	suspend_set_ops(&socfpga_pm_ops);
+	pr_info("SoCFPGA initialized for DDR self-refresh during suspend.\n");
+
+	return 0;
+}
+arch_initcall(socfpga_pm_init);
