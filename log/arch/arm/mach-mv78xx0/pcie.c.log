commit 97ad2bdcbe8598a69ee1f372ed6c0fbdb2869218
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Jun 28 15:13:55 2017 -0500

    ARM/PCI: Convert PCI scan API to pci_scan_root_bus_bridge()
    
    The introduction of pci_scan_root_bus_bridge() provides a PCI core API to
    scan a PCI root bus backed by an already initialized struct pci_host_bridge
    object, which simplifies the bus scan interface and makes the PCI scan root
    bus interface easier to generalize as members are added to the struct
    pci_host_bridge.
    
    Convert ARM bios32 code to pci_scan_root_bus_bridge() to improve the PCI
    root bus scanning interface.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    [bhelgaas: fold in warning fix from Arnd Bergmann <arnd@arndb.de>:
    http://lkml.kernel.org/r/20170621215323.3921382-1-arnd@arndb.de]
    [bhelgaas: set bridge->ops for mv78xx0]
    [bhelgaas: fold in fixes from Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>:
    http://lkml.kernel.org/r/20170701135457.GB8977@red-moon]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Andrew Lunn <andrew@lunn.ch>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index 81ff4327a962..636d84b40466 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -194,16 +194,22 @@ static void rc_pci_fixup(struct pci_dev *dev)
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL, PCI_ANY_ID, rc_pci_fixup);
 
-static struct pci_bus __init *
-mv78xx0_pcie_scan_bus(int nr, struct pci_sys_data *sys)
+static int __init mv78xx0_pcie_scan_bus(int nr, struct pci_host_bridge *bridge)
 {
+	struct pci_sys_data *sys = pci_host_bridge_priv(bridge);
+
 	if (nr >= num_pcie_ports) {
 		BUG();
-		return NULL;
+		return -EINVAL;
 	}
 
-	return pci_scan_root_bus(NULL, sys->busnr, &pcie_ops, sys,
-				 &sys->resources);
+	list_splice_init(&sys->resources, &bridge->windows);
+	bridge->dev.parent = NULL;
+	bridge->sysdata = sys;
+	bridge->busnr = sys->busnr;
+	bridge->ops = &pcie_ops;
+
+	return pci_scan_root_bus_bridge(bridge);
 }
 
 static int __init mv78xx0_pcie_map_irq(const struct pci_dev *dev, u8 slot,

commit 5de267b299829b99990305ad0440753bb8aa3de2
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jan 11 14:41:40 2017 +0100

    ARM: mv78xx0: fix possible PCI buffer overflow
    
    gcc-7.0 reports a potential array overflow:
    
    arch/arm/mach-mv78xx0/pcie.c: In function 'mv78xx0_pcie_preinit':
    arch/arm/mach-mv78xx0/pcie.c:81:4: error: output may be truncated before the last format character [-Werror=format-truncation=]
    
    I haven't checked if this can actually happen, but making the
    array one 32-bit word longer addresses the warning and makes
    it completely safe.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index 13a7d72ee0c4..81ff4327a962 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -29,7 +29,7 @@ struct pcie_port {
 	u8			root_bus_nr;
 	void __iomem		*base;
 	spinlock_t		conf_lock;
-	char			mem_space_name[16];
+	char			mem_space_name[20];
 	struct resource		res;
 };
 

commit 4c811b99b4de975f6c624efb269ed719e75a3035
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Dec 2 22:27:06 2015 +0100

    ARM: mv78xx0: clean up mach/*.h headers
    
    This is a simple move of all header files that are no longer
    included by anything else from the include/mach directory
    to the platform directory itself as preparation for
    multiplatform support.
    
    The mach/uncompress.h headers are left in place for now,
    and are mildly modified to be independent of the other
    headers. They will be removed entirely when ARCH_MULTIPLATFORM
    gets enabled and they become obsolete.
    
    Rather than updating the path names inside of the comments
    of each header, I delete those comments to avoid having to
    update them again, should they get moved or copied another
    time.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index 097ea4cb1136..13a7d72ee0c4 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -15,7 +15,7 @@
 #include <asm/irq.h>
 #include <asm/mach/pci.h>
 #include <plat/pcie.h>
-#include <mach/mv78xx0.h>
+#include "mv78xx0.h"
 #include "common.h"
 
 #define MV78XX0_MBUS_PCIE_MEM_TARGET(port, lane) ((port) ? 8 : 4)

commit 9e808eb6a7689b61399f772a2576d779161769ec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Mar 12 15:07:04 2015 -0500

    PCI: Cleanup control flow
    
    Return errors immediately so the straightline path is the normal,
    no-error path.  No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index 445e553f4a28..097ea4cb1136 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -197,17 +197,13 @@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL, PCI_ANY_ID, rc_pci_fixup);
 static struct pci_bus __init *
 mv78xx0_pcie_scan_bus(int nr, struct pci_sys_data *sys)
 {
-	struct pci_bus *bus;
-
-	if (nr < num_pcie_ports) {
-		bus = pci_scan_root_bus(NULL, sys->busnr, &pcie_ops, sys,
-					&sys->resources);
-	} else {
-		bus = NULL;
+	if (nr >= num_pcie_ports) {
 		BUG();
+		return NULL;
 	}
 
-	return bus;
+	return pci_scan_root_bus(NULL, sys->busnr, &pcie_ops, sys,
+				 &sys->resources);
 }
 
 static int __init mv78xx0_pcie_map_irq(const struct pci_dev *dev, u8 slot,

commit c5d0ecc98ca94eb55eacda034a304d5d028d514a
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Fri Jul 26 10:17:41 2013 -0300

    ARM: mv78xx0: Move to ID based window creation
    
    With the introduction of the ID based MBus API, it's better
    to switch to use it instead of the current name based scheme.
    
    This will allow to deprecate the name based API, once every
    user is removed.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Tested-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index dc26a654c496..445e553f4a28 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -18,6 +18,11 @@
 #include <mach/mv78xx0.h>
 #include "common.h"
 
+#define MV78XX0_MBUS_PCIE_MEM_TARGET(port, lane) ((port) ? 8 : 4)
+#define MV78XX0_MBUS_PCIE_MEM_ATTR(port, lane)   (0xf8 & ~(0x10 << (lane)))
+#define MV78XX0_MBUS_PCIE_IO_TARGET(port, lane)  ((port) ? 8 : 4)
+#define MV78XX0_MBUS_PCIE_IO_ATTR(port, lane)    (0xf0 & ~(0x10 << (lane)))
+
 struct pcie_port {
 	u8			maj;
 	u8			min;
@@ -71,7 +76,6 @@ static void __init mv78xx0_pcie_preinit(void)
 	start = MV78XX0_PCIE_MEM_PHYS_BASE;
 	for (i = 0; i < num_pcie_ports; i++) {
 		struct pcie_port *pp = pcie_port + i;
-		char winname[MVEBU_MBUS_MAX_WINNAME_SZ];
 
 		snprintf(pp->mem_space_name, sizeof(pp->mem_space_name),
 			"PCIe %d.%d MEM", pp->maj, pp->min);
@@ -85,17 +89,12 @@ static void __init mv78xx0_pcie_preinit(void)
 		if (request_resource(&iomem_resource, &pp->res))
 			panic("can't allocate PCIe MEM sub-space");
 
-		snprintf(winname, sizeof(winname), "pcie%d.%d",
-			 pp->maj, pp->min);
-
-		mvebu_mbus_add_window_remap_flags(winname,
-						  pp->res.start,
-						  resource_size(&pp->res),
-						  MVEBU_MBUS_NO_REMAP,
-						  MVEBU_MBUS_PCI_MEM);
-		mvebu_mbus_add_window_remap_flags(winname,
-						  i * SZ_64K, SZ_64K,
-						  0, MVEBU_MBUS_PCI_IO);
+		mvebu_mbus_add_window_by_id(MV78XX0_MBUS_PCIE_MEM_TARGET(pp->maj, pp->min),
+					    MV78XX0_MBUS_PCIE_MEM_ATTR(pp->maj, pp->min),
+					    pp->res.start, resource_size(&pp->res));
+		mvebu_mbus_add_window_remap_by_id(MV78XX0_MBUS_PCIE_IO_TARGET(pp->maj, pp->min),
+						  MV78XX0_MBUS_PCIE_IO_ATTR(pp->maj, pp->min),
+						  i * SZ_64K, SZ_64K, 0);
 	}
 }
 

commit 95b80e0a9ab3c1c8b41af5f2863801708f8f7288
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Thu Mar 21 17:59:19 2013 +0100

    arm: mach-mv78xx0: convert to use the mvebu-mbus driver
    
    This commit convers the mach-mv78xx0 sub-architecture to use the
    mvebu-mbus driver. We simply have to call mvebu_mbus_init() in the
    ->init_early() function, and modify the PCIe code so that it uses the
    new functions provided by mvebu-mbus to create the needed PCIe
    windows.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index ee8c0b51df2c..dc26a654c496 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -10,11 +10,11 @@
 
 #include <linux/kernel.h>
 #include <linux/pci.h>
+#include <linux/mbus.h>
 #include <video/vga.h>
 #include <asm/irq.h>
 #include <asm/mach/pci.h>
 #include <plat/pcie.h>
-#include <plat/addr-map.h>
 #include <mach/mv78xx0.h>
 #include "common.h"
 
@@ -54,7 +54,6 @@ static void __init mv78xx0_pcie_preinit(void)
 	int i;
 	u32 size_each;
 	u32 start;
-	int win = 0;
 
 	pcie_io_space.name = "PCIe I/O Space";
 	pcie_io_space.start = MV78XX0_PCIE_IO_PHYS_BASE(0);
@@ -72,6 +71,7 @@ static void __init mv78xx0_pcie_preinit(void)
 	start = MV78XX0_PCIE_MEM_PHYS_BASE;
 	for (i = 0; i < num_pcie_ports; i++) {
 		struct pcie_port *pp = pcie_port + i;
+		char winname[MVEBU_MBUS_MAX_WINNAME_SZ];
 
 		snprintf(pp->mem_space_name, sizeof(pp->mem_space_name),
 			"PCIe %d.%d MEM", pp->maj, pp->min);
@@ -85,12 +85,17 @@ static void __init mv78xx0_pcie_preinit(void)
 		if (request_resource(&iomem_resource, &pp->res))
 			panic("can't allocate PCIe MEM sub-space");
 
-		mv78xx0_setup_pcie_mem_win(win + i + 8, pp->res.start,
-					   resource_size(&pp->res),
-					   pp->maj, pp->min);
-
-		mv78xx0_setup_pcie_io_win(win + i, i * SZ_64K, SZ_64K,
-					  pp->maj, pp->min);
+		snprintf(winname, sizeof(winname), "pcie%d.%d",
+			 pp->maj, pp->min);
+
+		mvebu_mbus_add_window_remap_flags(winname,
+						  pp->res.start,
+						  resource_size(&pp->res),
+						  MVEBU_MBUS_NO_REMAP,
+						  MVEBU_MBUS_PCI_MEM);
+		mvebu_mbus_add_window_remap_flags(winname,
+						  i * SZ_64K, SZ_64K,
+						  0, MVEBU_MBUS_PCI_IO);
 	}
 }
 

commit 351a102dbf489d0e9c9b0883f76e2a94d895503d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 14:02:24 2012 -0800

    ARM: drivers: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index a9a154a646dd..ee8c0b51df2c 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -173,7 +173,7 @@ static struct pci_ops pcie_ops = {
 	.write = pcie_wr_conf,
 };
 
-static void __devinit rc_pci_fixup(struct pci_dev *dev)
+static void rc_pci_fixup(struct pci_dev *dev)
 {
 	/*
 	 * Prevent enumeration of root complex.

commit 0d601f613b8557cf6489f06251ae5dc383b811d0
Merge: d7ffa2234c18 5b40baee4a39
Author: Olof Johansson <olof@lixom.net>
Date:   Sat Sep 22 14:09:21 2012 -0700

    Merge branch 'kirkwood/addr_decode' of git://git.infradead.org/users/jcooper/linux into late/kirkwood
    
    * 'kirkwood/addr_decode' of git://git.infradead.org/users/jcooper/linux:
      arm: mvebu: add address decoding controller to the DT
      arm: mvebu: add basic address decoding support to Armada 370/XP
      arm: plat-orion: make bridge_virt_base non-const to support DT use case
      arm: plat-orion: introduce PLAT_ORION_LEGACY hidden config option
      arm: plat-orion: use void __iomem pointers for addr-map functions
      arm: plat-orion: use void __iomem pointers for time functions
      arm: plat-orion: use void __iomem pointers for MPP functions
      arm: plat-orion: use void __iomem pointers for UART registration functions
      arm: mach-mvebu: use IOMEM() for base address definitions
      arm: mach-orion5x: use IOMEM() for base address definitions
      arm: mach-mv78xx0: use IOMEM() for base address definitions
      arm: mach-kirkwood: use IOMEM() for base address definitions
      arm: mach-dove: use IOMEM() for base address definitions
      arm: mach-orion5x: use plus instead of or for address definitions
      arm: mach-mv78xx0: use plus instead of or for address definitions
      arm: mach-kirkwood: use plus instead of or for address definitions
      arm: mach-dove: use plus instead of or for address definitions
    
    This branch had quite a few conflicts, in particular with the PCI static
    map rework from Rob Herring, and a few other context conflicts due to
    changes in Kconfig, etc.
    
    I fixed up conflicts in:
            arch/arm/Kconfig
            arch/arm/mach-dove/common.c
            arch/arm/mach-dove/include/mach/dove.h
            arch/arm/mach-kirkwood/common.c
            arch/arm/mach-kirkwood/include/mach/kirkwood.h
            arch/arm/mach-mv78xx0/common.c
            arch/arm/mach-mv78xx0/include/mach/mv78xx0.h
            arch/arm/mach-orion5x/common.c
            arch/arm/mach-orion5x/include/mach/orion5x.h
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 383b99610e6084878930d4e4682dfc5e9141b038
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Tue Sep 11 14:27:20 2012 +0200

    arm: mach-mv78xx0: use IOMEM() for base address definitions
    
    We now define all virtual base address constants using IOMEM() so that
    those are naturally typed as void __iomem pointers, and we do the
    necessary adjustements in the mach-mv78xx0 code.
    
    Note that we introduce a few temporary additional "unsigned long"
    casts when calling into plat-orion functions. Those are removed by
    followup patches converting plat-orion functions to void __iomem
    pointers as well.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index 2e56e86b6d68..e2940fbbcd68 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -36,8 +36,8 @@ static struct resource pcie_mem_space;
 
 void __init mv78xx0_pcie_id(u32 *dev, u32 *rev)
 {
-	*dev = orion_pcie_dev_id((void __iomem *)PCIE00_VIRT_BASE);
-	*rev = orion_pcie_rev((void __iomem *)PCIE00_VIRT_BASE);
+	*dev = orion_pcie_dev_id(PCIE00_VIRT_BASE);
+	*rev = orion_pcie_rev(PCIE00_VIRT_BASE);
 }
 
 static void __init mv78xx0_pcie_preinit(void)
@@ -267,11 +267,11 @@ static struct hw_pci mv78xx0_pci __initdata = {
 	.map_irq	= mv78xx0_pcie_map_irq,
 };
 
-static void __init add_pcie_port(int maj, int min, unsigned long base)
+static void __init add_pcie_port(int maj, int min, void __iomem *base)
 {
 	printk(KERN_INFO "MV78xx0 PCIe port %d.%d: ", maj, min);
 
-	if (orion_pcie_link_up((void __iomem *)base)) {
+	if (orion_pcie_link_up(base)) {
 		struct pcie_port *pp = &pcie_port[num_pcie_ports++];
 
 		printk("link up\n");
@@ -279,7 +279,7 @@ static void __init add_pcie_port(int maj, int min, unsigned long base)
 		pp->maj = maj;
 		pp->min = min;
 		pp->root_bus_nr = -1;
-		pp->base = (void __iomem *)base;
+		pp->base = base;
 		spin_lock_init(&pp->conf_lock);
 		memset(pp->res, 0, sizeof(pp->res));
 	} else {
@@ -293,7 +293,7 @@ void __init mv78xx0_pcie_init(int init_port0, int init_port1)
 
 	if (init_port0) {
 		add_pcie_port(0, 0, PCIE00_VIRT_BASE);
-		if (!orion_pcie_x4_mode((void __iomem *)PCIE00_VIRT_BASE)) {
+		if (!orion_pcie_x4_mode(PCIE00_VIRT_BASE)) {
 			add_pcie_port(0, 1, PCIE01_VIRT_BASE);
 			add_pcie_port(0, 2, PCIE02_VIRT_BASE);
 			add_pcie_port(0, 3, PCIE03_VIRT_BASE);

commit 0b9b18e0166d8925ed222335efbc3cfd66aa882f
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Mon Jul 9 23:26:58 2012 -0500

    ARM: mv78xx0: use fixed pci i/o mapping
    
    Move mv78xx0 PCI to fixed i/o mapping and remove io.h. This changes the PCI
    bus addresses from the cpu address to 0 based. It appears that there is
    translation h/w for this, but its untested.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index 2e56e86b6d68..26a059b4f472 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -15,6 +15,7 @@
 #include <asm/mach/pci.h>
 #include <plat/pcie.h>
 #include <plat/addr-map.h>
+#include <mach/mv78xx0.h>
 #include "common.h"
 
 struct pcie_port {
@@ -23,16 +24,13 @@ struct pcie_port {
 	u8			root_bus_nr;
 	void __iomem		*base;
 	spinlock_t		conf_lock;
-	char			io_space_name[16];
 	char			mem_space_name[16];
-	struct resource		res[2];
+	struct resource		res;
 };
 
 static struct pcie_port pcie_port[8];
 static int num_pcie_ports;
 static struct resource pcie_io_space;
-static struct resource pcie_mem_space;
-
 
 void __init mv78xx0_pcie_id(u32 *dev, u32 *rev)
 {
@@ -40,102 +38,59 @@ void __init mv78xx0_pcie_id(u32 *dev, u32 *rev)
 	*rev = orion_pcie_rev((void __iomem *)PCIE00_VIRT_BASE);
 }
 
+u32 pcie_port_size[8] = {
+	0,
+	0x30000000,
+	0x10000000,
+	0x10000000,
+	0x08000000,
+	0x08000000,
+	0x08000000,
+	0x04000000,
+};
+
 static void __init mv78xx0_pcie_preinit(void)
 {
 	int i;
 	u32 size_each;
 	u32 start;
-	int win;
+	int win = 0;
 
 	pcie_io_space.name = "PCIe I/O Space";
 	pcie_io_space.start = MV78XX0_PCIE_IO_PHYS_BASE(0);
 	pcie_io_space.end =
 		MV78XX0_PCIE_IO_PHYS_BASE(0) + MV78XX0_PCIE_IO_SIZE * 8 - 1;
-	pcie_io_space.flags = IORESOURCE_IO;
+	pcie_io_space.flags = IORESOURCE_MEM;
 	if (request_resource(&iomem_resource, &pcie_io_space))
 		panic("can't allocate PCIe I/O space");
 
-	pcie_mem_space.name = "PCIe MEM Space";
-	pcie_mem_space.start = MV78XX0_PCIE_MEM_PHYS_BASE;
-	pcie_mem_space.end =
-		MV78XX0_PCIE_MEM_PHYS_BASE + MV78XX0_PCIE_MEM_SIZE - 1;
-	pcie_mem_space.flags = IORESOURCE_MEM;
-	if (request_resource(&iomem_resource, &pcie_mem_space))
-		panic("can't allocate PCIe MEM space");
+	if (num_pcie_ports > 7)
+		panic("invalid number of PCIe ports");
+
+	size_each = pcie_port_size[num_pcie_ports];
 
+	start = MV78XX0_PCIE_MEM_PHYS_BASE;
 	for (i = 0; i < num_pcie_ports; i++) {
 		struct pcie_port *pp = pcie_port + i;
 
-		snprintf(pp->io_space_name, sizeof(pp->io_space_name),
-			"PCIe %d.%d I/O", pp->maj, pp->min);
-		pp->io_space_name[sizeof(pp->io_space_name) - 1] = 0;
-		pp->res[0].name = pp->io_space_name;
-		pp->res[0].start = MV78XX0_PCIE_IO_PHYS_BASE(i);
-		pp->res[0].end = pp->res[0].start + MV78XX0_PCIE_IO_SIZE - 1;
-		pp->res[0].flags = IORESOURCE_IO;
-
 		snprintf(pp->mem_space_name, sizeof(pp->mem_space_name),
 			"PCIe %d.%d MEM", pp->maj, pp->min);
 		pp->mem_space_name[sizeof(pp->mem_space_name) - 1] = 0;
-		pp->res[1].name = pp->mem_space_name;
-		pp->res[1].flags = IORESOURCE_MEM;
-	}
-
-	switch (num_pcie_ports) {
-	case 0:
-		size_each = 0;
-		break;
-
-	case 1:
-		size_each = 0x30000000;
-		break;
-
-	case 2 ... 3:
-		size_each = 0x10000000;
-		break;
-
-	case 4 ... 6:
-		size_each = 0x08000000;
-		break;
-
-	case 7:
-		size_each = 0x04000000;
-		break;
-
-	default:
-		panic("invalid number of PCIe ports");
-	}
-
-	start = MV78XX0_PCIE_MEM_PHYS_BASE;
-	for (i = 0; i < num_pcie_ports; i++) {
-		struct pcie_port *pp = pcie_port + i;
-
-		pp->res[1].start = start;
-		pp->res[1].end = start + size_each - 1;
+		pp->res.name = pp->mem_space_name;
+		pp->res.flags = IORESOURCE_MEM;
+		pp->res.start = start;
+		pp->res.end = start + size_each - 1;
 		start += size_each;
-	}
-
-	for (i = 0; i < num_pcie_ports; i++) {
-		struct pcie_port *pp = pcie_port + i;
 
-		if (request_resource(&pcie_io_space, &pp->res[0]))
-			panic("can't allocate PCIe I/O sub-space");
-
-		if (request_resource(&pcie_mem_space, &pp->res[1]))
+		if (request_resource(&iomem_resource, &pp->res))
 			panic("can't allocate PCIe MEM sub-space");
-	}
 
-	win = 0;
-	for (i = 0; i < num_pcie_ports; i++) {
-		struct pcie_port *pp = pcie_port + i;
+		mv78xx0_setup_pcie_mem_win(win + i + 8, pp->res.start,
+					   resource_size(&pp->res),
+					   pp->maj, pp->min);
 
-		mv78xx0_setup_pcie_io_win(win++, pp->res[0].start,
-					  resource_size(&pp->res[0]),
+		mv78xx0_setup_pcie_io_win(win + i, i * SZ_64K, SZ_64K,
 					  pp->maj, pp->min);
-
-		mv78xx0_setup_pcie_mem_win(win++, pp->res[1].start,
-					   resource_size(&pp->res[1]),
-					   pp->maj, pp->min);
 	}
 }
 
@@ -156,8 +111,9 @@ static int __init mv78xx0_pcie_setup(int nr, struct pci_sys_data *sys)
 	orion_pcie_set_local_bus_nr(pp->base, sys->busnr);
 	orion_pcie_setup(pp->base);
 
-	pci_add_resource_offset(&sys->resources, &pp->res[0], sys->io_offset);
-	pci_add_resource_offset(&sys->resources, &pp->res[1], sys->mem_offset);
+	pci_ioremap_io(nr * SZ_64K, MV78XX0_PCIE_IO_PHYS_BASE(nr));
+
+	pci_add_resource_offset(&sys->resources, &pp->res, sys->mem_offset);
 
 	return 1;
 }
@@ -281,7 +237,7 @@ static void __init add_pcie_port(int maj, int min, unsigned long base)
 		pp->root_bus_nr = -1;
 		pp->base = (void __iomem *)base;
 		spin_lock_init(&pp->conf_lock);
-		memset(pp->res, 0, sizeof(pp->res));
+		memset(&pp->res, 0, sizeof(pp->res));
 	} else {
 		printk("link down, ignoring\n");
 	}

commit 43ba990bb7bf741f4b2f405b35dc02823d68a682
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Mar 10 13:31:34 2012 +0000

    ARM: PCI: dove/kirkwood/mv78xx0: use sys->private_data
    
    Use sys->private_data to store the PCIe port data structure.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index 53f2fb5607f9..2e56e86b6d68 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -147,6 +147,7 @@ static int __init mv78xx0_pcie_setup(int nr, struct pci_sys_data *sys)
 		return 0;
 
 	pp = &pcie_port[nr];
+	sys->private_data = pp;
 	pp->root_bus_nr = sys->busnr;
 
 	/*
@@ -161,19 +162,6 @@ static int __init mv78xx0_pcie_setup(int nr, struct pci_sys_data *sys)
 	return 1;
 }
 
-static struct pcie_port *bus_to_port(int bus)
-{
-	int i;
-
-	for (i = num_pcie_ports - 1; i >= 0; i--) {
-		int rbus = pcie_port[i].root_bus_nr;
-		if (rbus != -1 && rbus <= bus)
-			break;
-	}
-
-	return i >= 0 ? pcie_port + i : NULL;
-}
-
 static int pcie_valid_config(struct pcie_port *pp, int bus, int dev)
 {
 	/*
@@ -189,7 +177,8 @@ static int pcie_valid_config(struct pcie_port *pp, int bus, int dev)
 static int pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,
 			int size, u32 *val)
 {
-	struct pcie_port *pp = bus_to_port(bus->number);
+	struct pci_sys_data *sys = bus->sysdata;
+	struct pcie_port *pp = sys->private_data;
 	unsigned long flags;
 	int ret;
 
@@ -208,7 +197,8 @@ static int pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,
 static int pcie_wr_conf(struct pci_bus *bus, u32 devfn,
 			int where, int size, u32 val)
 {
-	struct pcie_port *pp = bus_to_port(bus->number);
+	struct pci_sys_data *sys = bus->sysdata;
+	struct pcie_port *pp = sys->private_data;
 	unsigned long flags;
 	int ret;
 
@@ -263,7 +253,8 @@ mv78xx0_pcie_scan_bus(int nr, struct pci_sys_data *sys)
 static int __init mv78xx0_pcie_map_irq(const struct pci_dev *dev, u8 slot,
 	u8 pin)
 {
-	struct pcie_port *pp = bus_to_port(dev->bus->number);
+	struct pci_sys_data *sys = dev->bus->sysdata;
+	struct pcie_port *pp = sys->private_data;
 
 	return IRQ_MV78XX0_PCIE_00 + (pp->maj << 2) + pp->min;
 }

commit daeb4c0c3bf2df72d0cd6e4330bad9e2e520552b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Mar 10 11:39:33 2012 +0000

    ARM: PCI: get rid of pci_std_swizzle()
    
    Most PCI implementations use the standard PCI swizzle function, which
    handles the well defined behaviour of PCI-to-PCI bridges which can be
    found on cards (eg, four port ethernet cards.)
    
    Rather than having almost every platform specify the standard swizzle
    function, make this the default when no swizzle function is supplied.
    Therefore, a swizzle function only needs to be provided when there is
    something exceptional which needs to be handled.
    
    This gets rid of the swizzle initializer from 47 files, and leaves us
    with just two platforms specifying a swizzle function: ARM Integrator
    and Chalice CATS.
    
    Acked-by: Krzysztof Hałasa <khc@pm.waw.pl>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index df3e38055a24..53f2fb5607f9 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -271,7 +271,6 @@ static int __init mv78xx0_pcie_map_irq(const struct pci_dev *dev, u8 slot,
 static struct hw_pci mv78xx0_pci __initdata = {
 	.nr_controllers	= 8,
 	.preinit	= mv78xx0_pcie_preinit,
-	.swizzle	= pci_std_swizzle,
 	.setup		= mv78xx0_pcie_setup,
 	.scan		= mv78xx0_pcie_scan_bus,
 	.map_irq	= mv78xx0_pcie_map_irq,

commit 9f786d033d025ab7d2c4d1b959aa81d935eb9e19
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 23 20:19:01 2012 -0700

    arm/PCI: get rid of device resource fixups
    
    Tell the PCI core about host bridge address translation so it can take
    care of bus-to-resource conversion for us.
    
    CC: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index 8459f6d7d8ca..df3e38055a24 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -155,8 +155,8 @@ static int __init mv78xx0_pcie_setup(int nr, struct pci_sys_data *sys)
 	orion_pcie_set_local_bus_nr(pp->base, sys->busnr);
 	orion_pcie_setup(pp->base);
 
-	pci_add_resource(&sys->resources, &pp->res[0]);
-	pci_add_resource(&sys->resources, &pp->res[1]);
+	pci_add_resource_offset(&sys->resources, &pp->res[0], sys->io_offset);
+	pci_add_resource_offset(&sys->resources, &pp->res[1], sys->mem_offset);
 
 	return 1;
 }

commit 7b67e751479d50b7f84d1a3cc5216eed5e534b66
Merge: 9f13a1fd452f 76ccc297018d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 11 18:50:26 2012 -0800

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci: (80 commits)
      x86/PCI: Expand the x86_msi_ops to have a restore MSIs.
      PCI: Increase resource array mask bit size in pcim_iomap_regions()
      PCI: DEVICE_COUNT_RESOURCE should be equal to PCI_NUM_RESOURCES
      PCI: pci_ids: add device ids for STA2X11 device (aka ConneXT)
      PNP: work around Dell 1536/1546 BIOS MMCONFIG bug that breaks USB
      x86/PCI: amd: factor out MMCONFIG discovery
      PCI: Enable ATS at the device state restore
      PCI: msi: fix imbalanced refcount of msi irq sysfs objects
      PCI: kconfig: English typo in pci/pcie/Kconfig
      PCI/PM/Runtime: make PCI traces quieter
      PCI: remove pci_create_bus()
      xtensa/PCI: convert to pci_scan_root_bus() for correct root bus resources
      x86/PCI: convert to pci_create_root_bus() and pci_scan_root_bus()
      x86/PCI: use pci_scan_bus() instead of pci_scan_bus_parented()
      x86/PCI: read Broadcom CNB20LE host bridge info before PCI scan
      sparc32, leon/PCI: convert to pci_scan_root_bus() for correct root bus resources
      sparc/PCI: convert to pci_create_root_bus()
      sh/PCI: convert to pci_scan_root_bus() for correct root bus resources
      powerpc/PCI: convert to pci_create_root_bus()
      powerpc/PCI: split PHB part out of pcibios_map_io_space()
      ...
    
    Fix up conflicts in drivers/pci/msi.c and include/linux/pci_regs.h due
    to the same patches being applied in other branches.

commit 37d15909ff6bf6e97e1d4447efa7f1a19e7a508e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 28 16:26:16 2011 -0600

    arm/PCI: convert to pci_scan_root_bus() for correct root bus resources
    
    Convert from pci_scan_bus() to pci_scan_root_bus() and remove root bus
    resource fixups.  This fixes the problem of "early" and "header" quirks
    seeing incorrect root bus resources.
    
    CC: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index c51af1cac300..c701135f139e 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -155,9 +155,8 @@ static int __init mv78xx0_pcie_setup(int nr, struct pci_sys_data *sys)
 	orion_pcie_set_local_bus_nr(pp->base, sys->busnr);
 	orion_pcie_setup(pp->base, &mv78xx0_mbus_dram_info);
 
-	sys->resource[0] = &pp->res[0];
-	sys->resource[1] = &pp->res[1];
-	sys->resource[2] = NULL;
+	pci_add_resource(&sys->resources, &pp->res[0]);
+	pci_add_resource(&sys->resources, &pp->res[1]);
 
 	return 1;
 }
@@ -251,7 +250,8 @@ mv78xx0_pcie_scan_bus(int nr, struct pci_sys_data *sys)
 	struct pci_bus *bus;
 
 	if (nr < num_pcie_ports) {
-		bus = pci_scan_bus(sys->busnr, &pcie_ops, sys);
+		bus = pci_scan_root_bus(NULL, sys->busnr, &pcie_ops, sys,
+					&sys->resources);
 	} else {
 		bus = NULL;
 		BUG();

commit 63a9332b232bdab0df6ef18a9f39e8d58a82bda4
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Dec 7 21:48:07 2011 +0100

    ARM: Orion: Get address map from plat-orion instead of via platform_data
    
    Use an getter function in plat-orion/addr-map.c to get the address map
    structure, rather than pass it to drivers in the platform_data
    structures. When the drivers are built for none orion platforms, a
    dummy function is provided instead which returns NULL.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Tested-by: Michael Walle <michael@walle.cc>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index 9208667c478a..12fcb108b0e1 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -10,7 +10,6 @@
 
 #include <linux/kernel.h>
 #include <linux/pci.h>
-#include <linux/mbus.h>
 #include <video/vga.h>
 #include <asm/irq.h>
 #include <asm/mach/pci.h>
@@ -154,7 +153,7 @@ static int __init mv78xx0_pcie_setup(int nr, struct pci_sys_data *sys)
 	 * Generic PCIe unit setup.
 	 */
 	orion_pcie_set_local_bus_nr(pp->base, sys->busnr);
-	orion_pcie_setup(pp->base, &orion_mbus_dram_info);
+	orion_pcie_setup(pp->base);
 
 	sys->resource[0] = &pp->res[0];
 	sys->resource[1] = &pp->res[1];

commit 45173d5ed4c9a397db31623bf6469efbd3a239cd
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Dec 7 21:48:06 2011 +0100

    ARM: Orion: mbus_dram_info consolidation
    
    Move the *_mbus_dram_info structure into the orion platform and call it
    orion_mbus_dram_info everywhere.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Tested-by: Michael Walle <michael@walle.cc>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index c51af1cac300..9208667c478a 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -15,6 +15,7 @@
 #include <asm/irq.h>
 #include <asm/mach/pci.h>
 #include <plat/pcie.h>
+#include <plat/addr-map.h>
 #include "common.h"
 
 struct pcie_port {
@@ -153,7 +154,7 @@ static int __init mv78xx0_pcie_setup(int nr, struct pci_sys_data *sys)
 	 * Generic PCIe unit setup.
 	 */
 	orion_pcie_set_local_bus_nr(pp->base, sys->busnr);
-	orion_pcie_setup(pp->base, &mv78xx0_mbus_dram_info);
+	orion_pcie_setup(pp->base, &orion_mbus_dram_info);
 
 	sys->resource[0] = &pp->res[0];
 	sys->resource[1] = &pp->res[1];

commit f85f19de90a9997583bb26e6f1f9297a4e152c18
Merge: b993fdbc7fe2 7b87c9df5602
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 29 23:35:05 2011 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6:
      PCI: remove printks about disabled bridge windows
      PCI: fold pci_calc_resource_flags() into decode_bar()
      PCI: treat mem BAR type "11" (reserved) as 32-bit, not 64-bit, BAR
      PCI: correct pcie_set_readrq write size
      PCI: pciehp: change wait time for valid configuration access
      x86/PCI: Preserve existing pci=bfsort whitelist for Dell systems
      PCI: ARI is a PCIe v2 feature
      x86/PCI: quirks: Use pci_dev->revision
      PCI: Make the struct pci_dev * argument of pci_fixup_irqs const.
      PCI hotplug: cpqphp: use pci_dev->vendor
      PCI hotplug: cpqphp: use pci_dev->subsystem_{vendor|device}
      x86/PCI: config space accessor functions should not ignore the segment argument
      PCI: Assign values to 'pci_obff_signal_type' enumeration constants
      x86/PCI: reduce severity of host bridge window conflict warnings
      PCI: enumerate the PCI device only removed out PCI hieratchy of OS when re-scanning PCI
      PCI: PCIe AER: add aer_recover_queue
      x86/PCI: select direct access mode for mmconfig option
      PCI hotplug: Rename is_ejectable which also exists in dock.c

commit 3960ef326a1838971466193ffa008ff37c1d978d
Merge: 62c9072bee22 c8f85523e70f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 26 17:12:10 2011 -0700

    Merge branch 'next/cross-platform' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/linux-arm-soc
    
    * 'next/cross-platform' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/linux-arm-soc:
      ARM: Consolidate the clkdev header files
      ARM: set vga memory base at run-time
      ARM: convert PCI defines to variables
      ARM: pci: make pcibios_assign_all_busses use pci_has_flag
      ARM: remove unnecessary mach/hardware.h includes
      pci: move microblaze and powerpc pci flag functions into asm-generic
      powerpc: rename ppc_pci_*_flags to pci_*_flags
    
    Fix up conflicts in arch/microblaze/include/asm/pci-bridge.h

commit d5341942d784134f2997b3ff82cd63cf71d1f932
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Jun 10 15:30:21 2011 +0100

    PCI: Make the struct pci_dev * argument of pci_fixup_irqs const.
    
    Aside of the usual motivation for constification,  this function has a
    history of being abused a hook for interrupt and other fixups so I turned
    this function const ages ago in the MIPS code but it should be done
    treewide.
    
    Due to function pointer passing in varous places a few other functions
    had to be constified as well.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    To: Anton Vorontsov <avorontsov@mvista.com>
    To: Chris Metcalf <cmetcalf@tilera.com>
    To: Colin Cross <ccross@android.com>
    Acked-by: "David S. Miller" <davem@davemloft.net>
    To: Eric Miao <eric.y.miao@gmail.com>
    To: Erik Gilling <konkers@android.com>
    Acked-by: Guan Xuetao <gxt@mprc.pku.edu.cn>
    To: "H. Peter Anvin" <hpa@zytor.com>
    To: Imre Kaloz <kaloz@openwrt.org>
    To: Ingo Molnar <mingo@redhat.com>
    To: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    To: Jesse Barnes <jbarnes@virtuousgeek.org>
    To: Krzysztof Halasa <khc@pm.waw.pl>
    To: Lennert Buytenhek <kernel@wantstofly.org>
    To: Matt Turner <mattst88@gmail.com>
    To: Nicolas Pitre <nico@fluxnic.net>
    To: Olof Johansson <olof@lixom.net>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    To: Richard Henderson <rth@twiddle.net>
    To: Russell King <linux@arm.linux.org.uk>
    To: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: linux-alpha@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Cc: linux-pci@vger.kernel.org
    Cc: linux-sh@vger.kernel.org
    Cc: linux-tegra@vger.kernel.org
    Cc: sparclinux@vger.kernel.org
    Cc: x86@kernel.org
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index a560439dcc3c..8854d8c7680b 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -259,7 +259,8 @@ mv78xx0_pcie_scan_bus(int nr, struct pci_sys_data *sys)
 	return bus;
 }
 
-static int __init mv78xx0_pcie_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+static int __init mv78xx0_pcie_map_irq(const struct pci_dev *dev, u8 slot,
+	u8 pin)
 {
 	struct pcie_port *pp = bus_to_port(dev->bus->number);
 

commit cc22b4c18540e5e8bf55c7d124044f9317527d3c
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Tue Jun 28 21:22:40 2011 -0500

    ARM: set vga memory base at run-time
    
    Convert the incorrectly named PCIMEM_BASE to a variable called vga_base.
    This removes the dependency on mach/hardware.h.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index a560439dcc3c..445a332325d5 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -11,6 +11,7 @@
 #include <linux/kernel.h>
 #include <linux/pci.h>
 #include <linux/mbus.h>
+#include <video/vga.h>
 #include <asm/irq.h>
 #include <asm/mach/pci.h>
 #include <plat/pcie.h>
@@ -297,6 +298,8 @@ static void __init add_pcie_port(int maj, int min, unsigned long base)
 
 void __init mv78xx0_pcie_init(int init_port0, int init_port1)
 {
+	vga_base = MV78XX0_PCIE_MEM_PHYS_BASE;
+
 	if (init_port0) {
 		add_pcie_port(0, 0, PCIE00_VIRT_BASE);
 		if (!orion_pcie_x4_mode((void __iomem *)PCIE00_VIRT_BASE)) {

commit 28f65c11f2ffb3957259dece647a24f8ad2e241b
Author: Joe Perches <joe@perches.com>
Date:   Thu Jun 9 09:13:32 2011 -0700

    treewide: Convert uses of struct resource to resource_size(ptr)
    
    Several fixes as well where the +1 was missing.
    
    Done via coccinelle scripts like:
    
    @@
    struct resource *ptr;
    @@
    
    - ptr->end - ptr->start + 1
    + resource_size(ptr)
    
    and some grep and typing.
    
    Mostly uncompiled, no cross-compilers.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index a560439dcc3c..f27c7d2fa9f7 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -129,12 +129,12 @@ static void __init mv78xx0_pcie_preinit(void)
 		struct pcie_port *pp = pcie_port + i;
 
 		mv78xx0_setup_pcie_io_win(win++, pp->res[0].start,
-			pp->res[0].end - pp->res[0].start + 1,
-			pp->maj, pp->min);
+					  resource_size(&pp->res[0]),
+					  pp->maj, pp->min);
 
 		mv78xx0_setup_pcie_mem_win(win++, pp->res[1].start,
-			pp->res[1].end - pp->res[1].start + 1,
-			pp->maj, pp->min);
+					   resource_size(&pp->res[1]),
+					   pp->maj, pp->min);
 	}
 }
 

commit cfdeb6376e439c58c2d37de492d2a8c763621022
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Fri Feb 20 02:31:35 2009 +0100

    [ARM] mv78xx0: distinguish between different chip steppings
    
    During boot, identify which chip stepping we're running on (determined
    by looking at the first PCIe unit's device ID and revision registers),
    and print a message with the details about what we found.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index aad3a7a2f830..a560439dcc3c 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -33,6 +33,12 @@ static struct resource pcie_io_space;
 static struct resource pcie_mem_space;
 
 
+void __init mv78xx0_pcie_id(u32 *dev, u32 *rev)
+{
+	*dev = orion_pcie_dev_id((void __iomem *)PCIE00_VIRT_BASE);
+	*rev = orion_pcie_rev((void __iomem *)PCIE00_VIRT_BASE);
+}
+
 static void __init mv78xx0_pcie_preinit(void)
 {
 	int i;

commit ba0cda6dc8c7d1de46c2f0663cdaaa2df714a8dc
Author: Nicolas Pitre <nico@cam.org>
Date:   Wed Jan 7 04:58:23 2009 +0100

    [ARM] 5361/1: mv78xx0: fix compilation error
    
    Commit ba84be2338d3 broke the build.
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index 430ea84d587d..aad3a7a2f830 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -11,6 +11,7 @@
 #include <linux/kernel.h>
 #include <linux/pci.h>
 #include <linux/mbus.h>
+#include <asm/irq.h>
 #include <asm/mach/pci.h>
 #include <plat/pcie.h>
 #include "common.h"

commit 6f088f1d215be5250582b974f83f0e3aa6ad3a28
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Sat Aug 9 13:44:58 2008 +0200

    [ARM] Move include/asm-arm/plat-orion to arch/arm/plat-orion/include/plat
    
    This patch performs the equivalent include directory shuffle for
    plat-orion, and fixes up all users.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
index b78e1443159f..430ea84d587d 100644
--- a/arch/arm/mach-mv78xx0/pcie.c
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -12,7 +12,7 @@
 #include <linux/pci.h>
 #include <linux/mbus.h>
 #include <asm/mach/pci.h>
-#include <asm/plat-orion/pcie.h>
+#include <plat/pcie.h>
 #include "common.h"
 
 struct pcie_port {

commit 794d15b25df5dda10efba600d6dd6cd74a7aa9cb
Author: Stanislav Samsonov <samsonov@marvell.com>
Date:   Sun Jun 22 22:45:10 2008 +0200

    [ARM] add Marvell 78xx0 ARM SoC support
    
    The Marvell Discovery Duo (MV78xx0) is a family of ARM SoCs featuring
    (depending on the model) one or two Feroceon CPU cores with 512K of L2
    cache and VFP coprocessors running at (depending on the model) between
    800 MHz and 1.2 GHz, and features a DDR2 controller, two PCIe
    interfaces that can each run either in x4 or quad x1 mode, three USB
    2.0 interfaces, two 3Gb/s SATA II interfaces, a SPI interface, two
    TWSI interfaces, a crypto accelerator, IDMA/XOR engines, a SPI
    interface, four UARTs, and depending on the model, two or four gigabit
    ethernet interfaces.
    
    This patch adds basic support for the platform, and allows booting
    on the MV78x00 development board, with functional UARTs, SATA, PCIe,
    GigE and USB ports.
    
    Signed-off-by: Stanislav Samsonov <samsonov@marvell.com>
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>

diff --git a/arch/arm/mach-mv78xx0/pcie.c b/arch/arm/mach-mv78xx0/pcie.c
new file mode 100644
index 000000000000..b78e1443159f
--- /dev/null
+++ b/arch/arm/mach-mv78xx0/pcie.c
@@ -0,0 +1,312 @@
+/*
+ * arch/arm/mach-mv78xx0/pcie.c
+ *
+ * PCIe functions for Marvell MV78xx0 SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/mbus.h>
+#include <asm/mach/pci.h>
+#include <asm/plat-orion/pcie.h>
+#include "common.h"
+
+struct pcie_port {
+	u8			maj;
+	u8			min;
+	u8			root_bus_nr;
+	void __iomem		*base;
+	spinlock_t		conf_lock;
+	char			io_space_name[16];
+	char			mem_space_name[16];
+	struct resource		res[2];
+};
+
+static struct pcie_port pcie_port[8];
+static int num_pcie_ports;
+static struct resource pcie_io_space;
+static struct resource pcie_mem_space;
+
+
+static void __init mv78xx0_pcie_preinit(void)
+{
+	int i;
+	u32 size_each;
+	u32 start;
+	int win;
+
+	pcie_io_space.name = "PCIe I/O Space";
+	pcie_io_space.start = MV78XX0_PCIE_IO_PHYS_BASE(0);
+	pcie_io_space.end =
+		MV78XX0_PCIE_IO_PHYS_BASE(0) + MV78XX0_PCIE_IO_SIZE * 8 - 1;
+	pcie_io_space.flags = IORESOURCE_IO;
+	if (request_resource(&iomem_resource, &pcie_io_space))
+		panic("can't allocate PCIe I/O space");
+
+	pcie_mem_space.name = "PCIe MEM Space";
+	pcie_mem_space.start = MV78XX0_PCIE_MEM_PHYS_BASE;
+	pcie_mem_space.end =
+		MV78XX0_PCIE_MEM_PHYS_BASE + MV78XX0_PCIE_MEM_SIZE - 1;
+	pcie_mem_space.flags = IORESOURCE_MEM;
+	if (request_resource(&iomem_resource, &pcie_mem_space))
+		panic("can't allocate PCIe MEM space");
+
+	for (i = 0; i < num_pcie_ports; i++) {
+		struct pcie_port *pp = pcie_port + i;
+
+		snprintf(pp->io_space_name, sizeof(pp->io_space_name),
+			"PCIe %d.%d I/O", pp->maj, pp->min);
+		pp->io_space_name[sizeof(pp->io_space_name) - 1] = 0;
+		pp->res[0].name = pp->io_space_name;
+		pp->res[0].start = MV78XX0_PCIE_IO_PHYS_BASE(i);
+		pp->res[0].end = pp->res[0].start + MV78XX0_PCIE_IO_SIZE - 1;
+		pp->res[0].flags = IORESOURCE_IO;
+
+		snprintf(pp->mem_space_name, sizeof(pp->mem_space_name),
+			"PCIe %d.%d MEM", pp->maj, pp->min);
+		pp->mem_space_name[sizeof(pp->mem_space_name) - 1] = 0;
+		pp->res[1].name = pp->mem_space_name;
+		pp->res[1].flags = IORESOURCE_MEM;
+	}
+
+	switch (num_pcie_ports) {
+	case 0:
+		size_each = 0;
+		break;
+
+	case 1:
+		size_each = 0x30000000;
+		break;
+
+	case 2 ... 3:
+		size_each = 0x10000000;
+		break;
+
+	case 4 ... 6:
+		size_each = 0x08000000;
+		break;
+
+	case 7:
+		size_each = 0x04000000;
+		break;
+
+	default:
+		panic("invalid number of PCIe ports");
+	}
+
+	start = MV78XX0_PCIE_MEM_PHYS_BASE;
+	for (i = 0; i < num_pcie_ports; i++) {
+		struct pcie_port *pp = pcie_port + i;
+
+		pp->res[1].start = start;
+		pp->res[1].end = start + size_each - 1;
+		start += size_each;
+	}
+
+	for (i = 0; i < num_pcie_ports; i++) {
+		struct pcie_port *pp = pcie_port + i;
+
+		if (request_resource(&pcie_io_space, &pp->res[0]))
+			panic("can't allocate PCIe I/O sub-space");
+
+		if (request_resource(&pcie_mem_space, &pp->res[1]))
+			panic("can't allocate PCIe MEM sub-space");
+	}
+
+	win = 0;
+	for (i = 0; i < num_pcie_ports; i++) {
+		struct pcie_port *pp = pcie_port + i;
+
+		mv78xx0_setup_pcie_io_win(win++, pp->res[0].start,
+			pp->res[0].end - pp->res[0].start + 1,
+			pp->maj, pp->min);
+
+		mv78xx0_setup_pcie_mem_win(win++, pp->res[1].start,
+			pp->res[1].end - pp->res[1].start + 1,
+			pp->maj, pp->min);
+	}
+}
+
+static int __init mv78xx0_pcie_setup(int nr, struct pci_sys_data *sys)
+{
+	struct pcie_port *pp;
+
+	if (nr >= num_pcie_ports)
+		return 0;
+
+	pp = &pcie_port[nr];
+	pp->root_bus_nr = sys->busnr;
+
+	/*
+	 * Generic PCIe unit setup.
+	 */
+	orion_pcie_set_local_bus_nr(pp->base, sys->busnr);
+	orion_pcie_setup(pp->base, &mv78xx0_mbus_dram_info);
+
+	sys->resource[0] = &pp->res[0];
+	sys->resource[1] = &pp->res[1];
+	sys->resource[2] = NULL;
+
+	return 1;
+}
+
+static struct pcie_port *bus_to_port(int bus)
+{
+	int i;
+
+	for (i = num_pcie_ports - 1; i >= 0; i--) {
+		int rbus = pcie_port[i].root_bus_nr;
+		if (rbus != -1 && rbus <= bus)
+			break;
+	}
+
+	return i >= 0 ? pcie_port + i : NULL;
+}
+
+static int pcie_valid_config(struct pcie_port *pp, int bus, int dev)
+{
+	/*
+	 * Don't go out when trying to access nonexisting devices
+	 * on the local bus.
+	 */
+	if (bus == pp->root_bus_nr && dev > 1)
+		return 0;
+
+	return 1;
+}
+
+static int pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,
+			int size, u32 *val)
+{
+	struct pcie_port *pp = bus_to_port(bus->number);
+	unsigned long flags;
+	int ret;
+
+	if (pcie_valid_config(pp, bus->number, PCI_SLOT(devfn)) == 0) {
+		*val = 0xffffffff;
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
+	spin_lock_irqsave(&pp->conf_lock, flags);
+	ret = orion_pcie_rd_conf(pp->base, bus, devfn, where, size, val);
+	spin_unlock_irqrestore(&pp->conf_lock, flags);
+
+	return ret;
+}
+
+static int pcie_wr_conf(struct pci_bus *bus, u32 devfn,
+			int where, int size, u32 val)
+{
+	struct pcie_port *pp = bus_to_port(bus->number);
+	unsigned long flags;
+	int ret;
+
+	if (pcie_valid_config(pp, bus->number, PCI_SLOT(devfn)) == 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	spin_lock_irqsave(&pp->conf_lock, flags);
+	ret = orion_pcie_wr_conf(pp->base, bus, devfn, where, size, val);
+	spin_unlock_irqrestore(&pp->conf_lock, flags);
+
+	return ret;
+}
+
+static struct pci_ops pcie_ops = {
+	.read = pcie_rd_conf,
+	.write = pcie_wr_conf,
+};
+
+static void __devinit rc_pci_fixup(struct pci_dev *dev)
+{
+	/*
+	 * Prevent enumeration of root complex.
+	 */
+	if (dev->bus->parent == NULL && dev->devfn == 0) {
+		int i;
+
+		for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
+			dev->resource[i].start = 0;
+			dev->resource[i].end   = 0;
+			dev->resource[i].flags = 0;
+		}
+	}
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL, PCI_ANY_ID, rc_pci_fixup);
+
+static struct pci_bus __init *
+mv78xx0_pcie_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	struct pci_bus *bus;
+
+	if (nr < num_pcie_ports) {
+		bus = pci_scan_bus(sys->busnr, &pcie_ops, sys);
+	} else {
+		bus = NULL;
+		BUG();
+	}
+
+	return bus;
+}
+
+static int __init mv78xx0_pcie_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	struct pcie_port *pp = bus_to_port(dev->bus->number);
+
+	return IRQ_MV78XX0_PCIE_00 + (pp->maj << 2) + pp->min;
+}
+
+static struct hw_pci mv78xx0_pci __initdata = {
+	.nr_controllers	= 8,
+	.preinit	= mv78xx0_pcie_preinit,
+	.swizzle	= pci_std_swizzle,
+	.setup		= mv78xx0_pcie_setup,
+	.scan		= mv78xx0_pcie_scan_bus,
+	.map_irq	= mv78xx0_pcie_map_irq,
+};
+
+static void __init add_pcie_port(int maj, int min, unsigned long base)
+{
+	printk(KERN_INFO "MV78xx0 PCIe port %d.%d: ", maj, min);
+
+	if (orion_pcie_link_up((void __iomem *)base)) {
+		struct pcie_port *pp = &pcie_port[num_pcie_ports++];
+
+		printk("link up\n");
+
+		pp->maj = maj;
+		pp->min = min;
+		pp->root_bus_nr = -1;
+		pp->base = (void __iomem *)base;
+		spin_lock_init(&pp->conf_lock);
+		memset(pp->res, 0, sizeof(pp->res));
+	} else {
+		printk("link down, ignoring\n");
+	}
+}
+
+void __init mv78xx0_pcie_init(int init_port0, int init_port1)
+{
+	if (init_port0) {
+		add_pcie_port(0, 0, PCIE00_VIRT_BASE);
+		if (!orion_pcie_x4_mode((void __iomem *)PCIE00_VIRT_BASE)) {
+			add_pcie_port(0, 1, PCIE01_VIRT_BASE);
+			add_pcie_port(0, 2, PCIE02_VIRT_BASE);
+			add_pcie_port(0, 3, PCIE03_VIRT_BASE);
+		}
+	}
+
+	if (init_port1) {
+		add_pcie_port(1, 0, PCIE10_VIRT_BASE);
+		if (!orion_pcie_x4_mode((void __iomem *)PCIE10_VIRT_BASE)) {
+			add_pcie_port(1, 1, PCIE11_VIRT_BASE);
+			add_pcie_port(1, 2, PCIE12_VIRT_BASE);
+			add_pcie_port(1, 3, PCIE13_VIRT_BASE);
+		}
+	}
+
+	pci_common_init(&mv78xx0_pci);
+}
