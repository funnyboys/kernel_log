commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index 844e8ac593e2..014cf6dcaf8b 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -1,13 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * arch/arm/mach-ixp4xx/include/mach/io.h
  *
  * Author: Deepak Saxena <dsaxena@plexity.net>
  *
  * Copyright (C) 2002-2005  MontaVista Software, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #ifndef __ASM_ARM_ARCH_IO_H

commit c4caa8db4c90a6d0e2258e34a203961e07903c05
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jun 10 10:51:04 2016 +0200

    ARM: ixp4xx: fix ioport_unmap definition
    
    An empty macro definition can cause unexpected behavior, in
    case of the ixp4xx ioport_unmap, we get two warnings:
    
    drivers/net/wireless/marvell/libertas/if_cs.c: In function 'if_cs_release':
    drivers/net/wireless/marvell/libertas/if_cs.c:826:3: error: suggest braces around empty body in an 'if' statement [-Werror=empty-body]
       ioport_unmap(card->iobase);
    drivers/vfio/pci/vfio_pci_rdwr.c: In function 'vfio_pci_vga_rw':
    drivers/vfio/pci/vfio_pci_rdwr.c:230:15: error: the omitted middle operand in ?: will always be 'true', suggest explicit middle operand [-Werror=parentheses]
       is_ioport ? ioport_unmap(iomem) : iounmap(iomem);
    
    This uses an inline function to define the macro in a safer way.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Krzysztof Halasa <khalasa@piap.pl>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index d04d3ec97ac0..844e8ac593e2 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -534,8 +534,15 @@ static inline void iowrite32_rep(void __iomem *addr, const void *vaddr,
 #endif
 }
 
-#define	ioport_map(port, nr)		((void __iomem*)(port + PIO_OFFSET))
-#define	ioport_unmap(addr)
+#define ioport_map(port, nr) ioport_map(port, nr)
+static inline void __iomem *ioport_map(unsigned long port, unsigned int nr)
+{
+	return ((void __iomem*)((port) + PIO_OFFSET));
+}
+#define	ioport_unmap(addr) ioport_unmap(addr)
+static inline void ioport_unmap(void __iomem *addr)
+{
+}
 #endif /* CONFIG_PCI */
 
 #endif /* __ASM_ARM_ARCH_IO_H */

commit 1f3b4d8fcc28d68bc4b01bec0b886f31c4ea3efb
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jan 15 13:32:43 2016 +0100

    ARM: ixp4xx: use normal prototype for {read,write}s{b,w,l}
    
    ixp4xx defines the arguments to its __indirect_writesb() and other
    functions as pointers to fixed-size data. This is not necessarily
    wrong, and it works most of the time, but it causes warnings in
    at least one driver:
    
    drivers/net/ethernet/smsc/smc91x.c: In function 'smc_rcv':
    drivers/net/ethernet/smsc/smc91x.c:495:21: error: passing argument 2 of '__indirect_readsw' from incompatible pointer type [-Werror=incompatible-pointer-types]
       SMC_PULL_DATA(lp, data, packet_len - 4);
    
    All other definitions of the same functions pass void pointers,
    so doing the same here avoids the warnings.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Krzysztof Halasa <khalasa@piap.pl>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index 7a0c13bf4269..d04d3ec97ac0 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -95,8 +95,10 @@ static inline void __indirect_writeb(u8 value, volatile void __iomem *p)
 }
 
 static inline void __indirect_writesb(volatile void __iomem *bus_addr,
-				      const u8 *vaddr, int count)
+				      const void *p, int count)
 {
+	const u8 *vaddr = p;
+
 	while (count--)
 		writeb(*vaddr++, bus_addr);
 }
@@ -118,8 +120,10 @@ static inline void __indirect_writew(u16 value, volatile void __iomem *p)
 }
 
 static inline void __indirect_writesw(volatile void __iomem *bus_addr,
-				      const u16 *vaddr, int count)
+				      const void *p, int count)
 {
+	const u16 *vaddr = p;
+
 	while (count--)
 		writew(*vaddr++, bus_addr);
 }
@@ -137,8 +141,9 @@ static inline void __indirect_writel(u32 value, volatile void __iomem *p)
 }
 
 static inline void __indirect_writesl(volatile void __iomem *bus_addr,
-				      const u32 *vaddr, int count)
+				      const void *p, int count)
 {
+	const u32 *vaddr = p;
 	while (count--)
 		writel(*vaddr++, bus_addr);
 }
@@ -160,8 +165,10 @@ static inline u8 __indirect_readb(const volatile void __iomem *p)
 }
 
 static inline void __indirect_readsb(const volatile void __iomem *bus_addr,
-				     u8 *vaddr, u32 count)
+				     void *p, u32 count)
 {
+	u8 *vaddr = p;
+
 	while (count--)
 		*vaddr++ = readb(bus_addr);
 }
@@ -183,8 +190,10 @@ static inline u16 __indirect_readw(const volatile void __iomem *p)
 }
 
 static inline void __indirect_readsw(const volatile void __iomem *bus_addr,
-				     u16 *vaddr, u32 count)
+				     void *p, u32 count)
 {
+	u16 *vaddr = p;
+
 	while (count--)
 		*vaddr++ = readw(bus_addr);
 }
@@ -204,8 +213,10 @@ static inline u32 __indirect_readl(const volatile void __iomem *p)
 }
 
 static inline void __indirect_readsl(const volatile void __iomem *bus_addr,
-				     u32 *vaddr, u32 count)
+				     void *p, u32 count)
 {
+	u32 *vaddr = p;
+
 	while (count--)
 		*vaddr++ = readl(bus_addr);
 }

commit d66e5139aee7d8379fc135b00b9ac7c66f9d4c74
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Nov 20 23:20:28 2015 +0100

    ARM: ixp4xx: fix read{b,w,l} return types
    
    On ixp4xx, the readl() function returns an 'unsigned long' output
    when indirect I/O is used. This is unlike any other platform, and
    it causes lots of harmless compiler warnings, such as:
    
    drivers/ata/libahci.c: In function 'ahci_show_host_version':
    drivers/ata/libahci.c:254:22: warning: format '%x' expects argument of type 'unsigned int', but argument 3 has type 'long unsigned int' [-Wformat=]
    drivers/block/mtip32xx/mtip32xx.c: In function 'mtip_hw_read_registers':
    drivers/block/mtip32xx/mtip32xx.c:2602:31: warning: format '%X' expects argument of type 'unsigned int', but argument 3 has type 'long unsigned int' [-Wformat=]
    drivers/block/cciss.c: In function 'print_cfg_table':
    drivers/block/cciss.c:3845:25: warning: format '%d' expects argument of type 'int', but argument 4 has type 'long unsigned int' [-Wformat=]
    
    This changes all six of the ixp4xx specific I/O read functions
    to return the same types that we have in the normal asm/io.h,
    to avoid the warnings.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Krzysztof Halasa <khalasa@piap.pl>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index b02439019963..7a0c13bf4269 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -143,7 +143,7 @@ static inline void __indirect_writesl(volatile void __iomem *bus_addr,
 		writel(*vaddr++, bus_addr);
 }
 
-static inline unsigned char __indirect_readb(const volatile void __iomem *p)
+static inline u8 __indirect_readb(const volatile void __iomem *p)
 {
 	u32 addr = (u32)p;
 	u32 n, byte_enables, data;
@@ -166,7 +166,7 @@ static inline void __indirect_readsb(const volatile void __iomem *bus_addr,
 		*vaddr++ = readb(bus_addr);
 }
 
-static inline unsigned short __indirect_readw(const volatile void __iomem *p)
+static inline u16 __indirect_readw(const volatile void __iomem *p)
 {
 	u32 addr = (u32)p;
 	u32 n, byte_enables, data;
@@ -189,7 +189,7 @@ static inline void __indirect_readsw(const volatile void __iomem *bus_addr,
 		*vaddr++ = readw(bus_addr);
 }
 
-static inline unsigned long __indirect_readl(const volatile void __iomem *p)
+static inline u32 __indirect_readl(const volatile void __iomem *p)
 {
 	u32 addr = (__force u32)p;
 	u32 data;
@@ -350,7 +350,7 @@ static inline void insl(u32 io_addr, void *p, u32 count)
 					((unsigned long)p <= (PIO_MASK + PIO_OFFSET)))
 
 #define	ioread8(p)			ioread8(p)
-static inline unsigned int ioread8(const void __iomem *addr)
+static inline u8 ioread8(const void __iomem *addr)
 {
 	unsigned long port = (unsigned long __force)addr;
 	if (__is_io_address(port))
@@ -378,7 +378,7 @@ static inline void ioread8_rep(const void __iomem *addr, void *vaddr, u32 count)
 }
 
 #define	ioread16(p)			ioread16(p)
-static inline unsigned int ioread16(const void __iomem *addr)
+static inline u16 ioread16(const void __iomem *addr)
 {
 	unsigned long port = (unsigned long __force)addr;
 	if (__is_io_address(port))
@@ -407,7 +407,7 @@ static inline void ioread16_rep(const void __iomem *addr, void *vaddr,
 }
 
 #define	ioread32(p)			ioread32(p)
-static inline unsigned int ioread32(const void __iomem *addr)
+static inline u32 ioread32(const void __iomem *addr)
 {
 	unsigned long port = (unsigned long __force)addr;
 	if (__is_io_address(port))

commit 1aeb3c5c48bebf0bb608c861612c76bdcd0205e6
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jan 26 13:19:23 2015 +0100

    ARM: ixp4xx: fix {in,out}s{bwl} data types
    
    Most platforms use void pointer arguments in these functions, but
    ixp4xx does not, which triggers lots of warnings in device drivers like:
    
    net/ethernet/8390/ne2k-pci.c: In function 'ne2k_pci_get_8390_hdr':
    net/ethernet/8390/ne2k-pci.c:503:3: warning: passing argument 2 of 'insw' from incompatible pointer type
       insw(NE_BASE + NE_DATAPORT, hdr, sizeof(struct e8390_pkt_hdr)>>1);
       ^
    In file included from include/asm/io.h:214:0,
                     from /git/arm-soc/include/linux/io.h:22,
                     from /git/arm-soc/include/linux/pci.h:31,
                     from net/ethernet/8390/ne2k-pci.c:48:
    mach-ixp4xx/include/mach/io.h:316:91: note: expected 'u16 *' but argument is of type 'struct e8390_pkt_hdr *'
     static inline void insw(u32 io_addr, u16 *vaddr, u32 count)
    
    Fixing the drivers seems hopeless, so this changes the ixp4xx code
    to do the same as the others to avoid the warnings.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Krzysztof Halasa <khalasa@piap.pl>
    Cc: Imre Kaloz <kaloz@openwrt.org>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index 6a722860e34d..b02439019963 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -245,8 +245,10 @@ static inline void outb(u8 value, u32 addr)
 }
 
 #define outsb outsb
-static inline void outsb(u32 io_addr, const u8 *vaddr, u32 count)
+static inline void outsb(u32 io_addr, const void *p, u32 count)
 {
+	const u8 *vaddr = p;
+
 	while (count--)
 		outb(*vaddr++, io_addr);
 }
@@ -262,8 +264,9 @@ static inline void outw(u16 value, u32 addr)
 }
 
 #define outsw outsw
-static inline void outsw(u32 io_addr, const u16 *vaddr, u32 count)
+static inline void outsw(u32 io_addr, const void *p, u32 count)
 {
+	const u16 *vaddr = p;
 	while (count--)
 		outw(cpu_to_le16(*vaddr++), io_addr);
 }
@@ -275,8 +278,9 @@ static inline void outl(u32 value, u32 addr)
 }
 
 #define outsl outsl
-static inline void outsl(u32 io_addr, const u32 *vaddr, u32 count)
+static inline void outsl(u32 io_addr, const void *p, u32 count)
 {
+	const u32 *vaddr = p;
 	while (count--)
 		outl(cpu_to_le32(*vaddr++), io_addr);
 }
@@ -294,8 +298,9 @@ static inline u8 inb(u32 addr)
 }
 
 #define insb insb
-static inline void insb(u32 io_addr, u8 *vaddr, u32 count)
+static inline void insb(u32 io_addr, void *p, u32 count)
 {
+	u8 *vaddr = p;
 	while (count--)
 		*vaddr++ = inb(io_addr);
 }
@@ -313,8 +318,9 @@ static inline u16 inw(u32 addr)
 }
 
 #define insw insw
-static inline void insw(u32 io_addr, u16 *vaddr, u32 count)
+static inline void insw(u32 io_addr, void *p, u32 count)
 {
+	u16 *vaddr = p;
 	while (count--)
 		*vaddr++ = le16_to_cpu(inw(io_addr));
 }
@@ -330,8 +336,9 @@ static inline u32 inl(u32 addr)
 }
 
 #define insl insl
-static inline void insl(u32 io_addr, u32 *vaddr, u32 count)
+static inline void insl(u32 io_addr, void *p, u32 count)
 {
+	u32 *vaddr = p;
 	while (count--)
 		*vaddr++ = le32_to_cpu(inl(io_addr));
 }

commit 2e0fa0c95393f51ed356b351d66a37a82f867dc6
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Oct 1 14:15:34 2014 +0200

    ARM: ixp4xx: Properly override I/O accessors
    
    In order to override accessors properly they must be #define'd so that
    subsequent generic headers (the one for ARM and finally the architecture
    independent one) can properly detect it.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index 0f737fcebcc1..6a722860e34d 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -234,6 +234,7 @@ static inline void __indirect_readsl(const volatile void __iomem *bus_addr,
  * I/O functions.
  */
 
+#define outb outb
 static inline void outb(u8 value, u32 addr)
 {
 	u32 n, byte_enables, data;
@@ -243,12 +244,14 @@ static inline void outb(u8 value, u32 addr)
 	ixp4xx_pci_write(addr, byte_enables | NP_CMD_IOWRITE, data);
 }
 
+#define outsb outsb
 static inline void outsb(u32 io_addr, const u8 *vaddr, u32 count)
 {
 	while (count--)
 		outb(*vaddr++, io_addr);
 }
 
+#define outw outw
 static inline void outw(u16 value, u32 addr)
 {
 	u32 n, byte_enables, data;
@@ -258,23 +261,27 @@ static inline void outw(u16 value, u32 addr)
 	ixp4xx_pci_write(addr, byte_enables | NP_CMD_IOWRITE, data);
 }
 
+#define outsw outsw
 static inline void outsw(u32 io_addr, const u16 *vaddr, u32 count)
 {
 	while (count--)
 		outw(cpu_to_le16(*vaddr++), io_addr);
 }
 
+#define outl outl
 static inline void outl(u32 value, u32 addr)
 {
 	ixp4xx_pci_write(addr, NP_CMD_IOWRITE, value);
 }
 
+#define outsl outsl
 static inline void outsl(u32 io_addr, const u32 *vaddr, u32 count)
 {
 	while (count--)
 		outl(cpu_to_le32(*vaddr++), io_addr);
 }
 
+#define inb inb
 static inline u8 inb(u32 addr)
 {
 	u32 n, byte_enables, data;
@@ -286,12 +293,14 @@ static inline u8 inb(u32 addr)
 	return data >> (8*n);
 }
 
+#define insb insb
 static inline void insb(u32 io_addr, u8 *vaddr, u32 count)
 {
 	while (count--)
 		*vaddr++ = inb(io_addr);
 }
 
+#define inw inw
 static inline u16 inw(u32 addr)
 {
 	u32 n, byte_enables, data;
@@ -303,12 +312,14 @@ static inline u16 inw(u32 addr)
 	return data>>(8*n);
 }
 
+#define insw insw
 static inline void insw(u32 io_addr, u16 *vaddr, u32 count)
 {
 	while (count--)
 		*vaddr++ = le16_to_cpu(inw(io_addr));
 }
 
+#define inl inl
 static inline u32 inl(u32 addr)
 {
 	u32 data;
@@ -318,6 +329,7 @@ static inline u32 inl(u32 addr)
 	return data;
 }
 
+#define insl insl
 static inline void insl(u32 io_addr, u32 *vaddr, u32 count)
 {
 	while (count--)

commit e43b21cbbd816aebbb275093f22a974f7b0cb345
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Nov 10 15:10:32 2014 +0100

    ARM: ixp4xx: Fix build with IXP4XX_INDIRECT_PCI
    
    Provide *_relaxed() accessors and make sure to pass the volatile void
    __iomem * to accessors rather than the value cast to a u32. This allows
    ixp4xx to build with IXP4XX_INDIRECT_PCI enabled.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index 559c69a47731..0f737fcebcc1 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -58,6 +58,10 @@ static inline int is_pci_memory(u32 addr)
 #define writew(v, p)			__indirect_writew(v, p)
 #define writel(v, p)			__indirect_writel(v, p)
 
+#define writeb_relaxed(v, p)		__indirect_writeb(v, p)
+#define writew_relaxed(v, p)		__indirect_writew(v, p)
+#define writel_relaxed(v, p)		__indirect_writel(v, p)
+
 #define writesb(p, v, l)		__indirect_writesb(p, v, l)
 #define writesw(p, v, l)		__indirect_writesw(p, v, l)
 #define writesl(p, v, l)		__indirect_writesl(p, v, l)
@@ -66,6 +70,10 @@ static inline int is_pci_memory(u32 addr)
 #define readw(p)			__indirect_readw(p)
 #define readl(p)			__indirect_readl(p)
 
+#define readb_relaxed(p)		__indirect_readb(p)
+#define readw_relaxed(p)		__indirect_readw(p)
+#define readl_relaxed(p)		__indirect_readl(p)
+
 #define readsb(p, v, l)			__indirect_readsb(p, v, l)
 #define readsw(p, v, l)			__indirect_readsw(p, v, l)
 #define readsl(p, v, l)			__indirect_readsl(p, v, l)
@@ -76,7 +84,7 @@ static inline void __indirect_writeb(u8 value, volatile void __iomem *p)
 	u32 n, byte_enables, data;
 
 	if (!is_pci_memory(addr)) {
-		__raw_writeb(value, addr);
+		__raw_writeb(value, p);
 		return;
 	}
 
@@ -99,7 +107,7 @@ static inline void __indirect_writew(u16 value, volatile void __iomem *p)
 	u32 n, byte_enables, data;
 
 	if (!is_pci_memory(addr)) {
-		__raw_writew(value, addr);
+		__raw_writew(value, p);
 		return;
 	}
 
@@ -141,7 +149,7 @@ static inline unsigned char __indirect_readb(const volatile void __iomem *p)
 	u32 n, byte_enables, data;
 
 	if (!is_pci_memory(addr))
-		return __raw_readb(addr);
+		return __raw_readb(p);
 
 	n = addr % 4;
 	byte_enables = (0xf & ~BIT(n)) << IXP4XX_PCI_NP_CBE_BESL;
@@ -164,7 +172,7 @@ static inline unsigned short __indirect_readw(const volatile void __iomem *p)
 	u32 n, byte_enables, data;
 
 	if (!is_pci_memory(addr))
-		return __raw_readw(addr);
+		return __raw_readw(p);
 
 	n = addr % 4;
 	byte_enables = (0xf & ~(BIT(n) | BIT(n+1))) << IXP4XX_PCI_NP_CBE_BESL;

commit 926aabde6318db321eb982ded8f5f63cd52fee74
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Mar 16 20:23:18 2014 +0100

    ARM: ixp4xx: avoid use of PCIBIOS_MIN_MEM in io.h
    
    When using CONFIG_IXP4XX_INDIRECT_PCI, we run into a recursive
    header file dependency between mach/io.h and asm/pci.h, resulting
    in a build failure:
    
    mach-ixp4xx/include/mach/io.h: In function 'is_pci_memory':
    mach-ixp4xx/include/mach/io.h:53:18: error: 'PCIBIOS_MIN_MEM' undeclared (first use in this function)
      return (addr >= PCIBIOS_MIN_MEM) && (addr <= 0x4FFFFFFF);
                      ^
    mach-ixp4xx/include/mach/io.h:53:18: note: each undeclared identifier is reported only once for each function it appears in
    
    We can work around this by referencing the pcibios_min_mem variable
    directly through an extern declaration, rather than using the macro.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Cc: Krzysztof Halasa <khc@pm.waw.pl>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index 5cf30d1b78d2..559c69a47731 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -48,9 +48,10 @@ extern int ixp4xx_pci_write(u32 addr, u32 cmd, u32 data);
  * fallback to the default.
  */
 
+extern unsigned long pcibios_min_mem;
 static inline int is_pci_memory(u32 addr)
 {
-	return (addr >= PCIBIOS_MIN_MEM) && (addr <= 0x4FFFFFFF);
+	return (addr >= pcibios_min_mem) && (addr <= 0x4FFFFFFF);
 }
 
 #define writeb(v, p)			__indirect_writeb(v, p)

commit 5621caac1d9514b568f986b55ce5494b1d119d40
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Fri Feb 10 20:04:56 2012 -0600

    ARM: kill off __mem_pci
    
    __mem_pci is only used to enable readl/writel and friends. Just condition
    this on readl being defined and remove all the __mem_pci defines.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Lennert Buytenhek <kernel@wantstofly.org>
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Cc: Krzysztof Halasa <khc@pm.waw.pl>
    Cc: Nicolas Pitre <nico@fluxnic.net>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Colin Cross <ccross@android.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index 6a520768e5ed..5cf30d1b78d2 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -39,11 +39,7 @@ extern int ixp4xx_pci_write(u32 addr, u32 cmd, u32 data);
  *    but in some cases the performance hit is acceptable. In addition, you
  *    cannot mmap() PCI devices in this case.
  */
-#ifndef	CONFIG_IXP4XX_INDIRECT_PCI
-
-#define __mem_pci(a)		(a)
-
-#else
+#ifdef	CONFIG_IXP4XX_INDIRECT_PCI
 
 /*
  * In the case of using indirect PCI, we simply return the actual PCI

commit f449588c65e23637aef59cae2ea7b6b2b1b767ec
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Tue Mar 6 15:01:53 2012 -0600

    ARM: ixp4xx: use runtime ioremap hook
    
    Convert ixp4xx platforms to use run-time ioremap hook instead of the
    compile time hook.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Cc: Krzysztof Halasa <khc@pm.waw.pl>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index ffb9d6afb89f..6a520768e5ed 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -57,24 +57,6 @@ static inline int is_pci_memory(u32 addr)
 	return (addr >= PCIBIOS_MIN_MEM) && (addr <= 0x4FFFFFFF);
 }
 
-static inline void __iomem * __indirect_ioremap(unsigned long addr, size_t size,
-						unsigned int mtype)
-{
-	if (!is_pci_memory(addr))
-		return __arm_ioremap(addr, size, mtype);
-
-	return (void __iomem *)addr;
-}
-
-static inline void __indirect_iounmap(void __iomem *addr)
-{
-	if (!is_pci_memory((__force u32)addr))
-		__iounmap(addr);
-}
-
-#define __arch_ioremap			__indirect_ioremap
-#define __arch_iounmap			__indirect_iounmap
-
 #define writeb(v, p)			__indirect_writeb(v, p)
 #define writew(v, p)			__indirect_writew(v, p)
 #define writel(v, p)			__indirect_writel(v, p)

commit deb9a75e623083b51f71eeee9a2846b97bf57438
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jul 7 09:02:06 2011 +0100

    ARM: io: remove IO_SPACE_LIMIT from platforms with ISA/PCI and 64K window
    
    Remove IO_SPACE_LIMIT definitions from platforms which have a well
    defined ISA or PCI, and has a 64K window.
    
    EBSA110 - well defined set of ISA devices.
    Footbridge, Integrator, IXP4xx, VT8500 - PCI platforms.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index 57b5410c31f4..ffb9d6afb89f 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -17,8 +17,6 @@
 
 #include <mach/hardware.h>
 
-#define IO_SPACE_LIMIT 0x0000ffff
-
 extern int (*ixp4xx_pci_read)(u32 addr, u32 cmd, u32* data);
 extern int ixp4xx_pci_write(u32 addr, u32 cmd, u32 data);
 

commit a0b7bd0829194c03921915a68ee4a331ee394223
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Dec 8 13:49:04 2010 +0000

    ARM: io: make iounmap() a simple macro
    
    Defining iounmap() with arguments prevents it from being used as a
    function pointer, causing platforms to work around this.  Instead,
    define it to be a simple macro.
    
    Do the same for __arch_io(re|un)map too.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index de274a1f19d7..57b5410c31f4 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -74,8 +74,8 @@ static inline void __indirect_iounmap(void __iomem *addr)
 		__iounmap(addr);
 }
 
-#define __arch_ioremap(a, s, f)		__indirect_ioremap(a, s, f)
-#define __arch_iounmap(a)		__indirect_iounmap(a)
+#define __arch_ioremap			__indirect_ioremap
+#define __arch_iounmap			__indirect_iounmap
 
 #define writeb(v, p)			__indirect_writeb(v, p)
 #define writew(v, p)			__indirect_writew(v, p)

commit 59c290176e0bf14085959124b8a9b55f6e831861
Author: Krzysztof Hałasa <khc@pm.waw.pl>
Date:   Sun Jan 10 13:55:11 2010 +0100

    IXP4xx: Fix sparse warnings in I/O primitives.
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index 6ea7e2fb2701..de274a1f19d7 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -353,7 +353,7 @@ static inline unsigned int ioread8(const void __iomem *addr)
 		return (unsigned int)inb(port & PIO_MASK);
 	else
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
-		return (unsigned int)__raw_readb(port);
+		return (unsigned int)__raw_readb(addr);
 #else
 		return (unsigned int)__indirect_readb(addr);
 #endif
@@ -381,7 +381,7 @@ static inline unsigned int ioread16(const void __iomem *addr)
 		return	(unsigned int)inw(port & PIO_MASK);
 	else
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
-		return le16_to_cpu(__raw_readw((u32)port));
+		return le16_to_cpu((__force __le16)__raw_readw(addr));
 #else
 		return (unsigned int)__indirect_readw(addr);
 #endif
@@ -440,7 +440,7 @@ static inline void iowrite8(u8 value, void __iomem *addr)
 		outb(value, port & PIO_MASK);
 	else
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
-		__raw_writeb(value, port);
+		__raw_writeb(value, addr);
 #else
 		__indirect_writeb(value, addr);
 #endif

commit ed5b9fa0d1c5ad1e01ff56b9acd3ff52bc783f66
Author: Krzysztof Hałasa <khc@pm.waw.pl>
Date:   Sun Nov 15 18:02:10 2009 +0100

    IXP4xx: Extend PCI MMIO indirect address space to 1 GB.
    
    IXP4xx CPUs can indirectly access the whole 4 GB PCI MMIO address space (using
    the non-prefetch registers). Previously the available space depended on the CPU
    variant, since one of the IXP43x platforms needed more than the usual 128 MB.
    1 GB should be enough for everyone, and if not, we can trivially increase it.
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index 0e601fe50162..6ea7e2fb2701 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -26,22 +26,20 @@ extern int ixp4xx_pci_write(u32 addr, u32 cmd, u32 data);
 /*
  * IXP4xx provides two methods of accessing PCI memory space:
  *
- * 1) A direct mapped window from 0x48000000 to 0x4bffffff (64MB).
+ * 1) A direct mapped window from 0x48000000 to 0x4BFFFFFF (64MB).
  *    To access PCI via this space, we simply ioremap() the BAR
  *    into the kernel and we can use the standard read[bwl]/write[bwl]
  *    macros. This is the preffered method due to speed but it
- *    limits the system to just 64MB of PCI memory. This can be 
- *    problamatic if using video cards and other memory-heavy
- *    targets.
- *
- * 2) If > 64MB of memory space is required, the IXP4xx can be configured
- *    to use indirect registers to access PCI (as we do below for I/O
- *    transactions). This allows for up to 128MB (0x48000000 to 0x4fffffff)
- *    of memory on the bus. The disadvantage of this is that every 
- *    PCI access requires three local register accesses plus a spinlock,
- *    but in some cases the performance hit is acceptable. In addition,
- *    you cannot mmap() PCI devices in this case.
+ *    limits the system to just 64MB of PCI memory. This can be
+ *    problematic if using video cards and other memory-heavy targets.
  *
+ * 2) If > 64MB of memory space is required, the IXP4xx can use indirect
+ *    registers to access the whole 4 GB of PCI memory space (as we do below
+ *    for I/O transactions). This allows currently for up to 1 GB (0x10000000
+ *    to 0x4FFFFFFF) of memory on the bus. The disadvantage of this is that
+ *    every PCI access requires three local register accesses plus a spinlock,
+ *    but in some cases the performance hit is acceptable. In addition, you
+ *    cannot mmap() PCI devices in this case.
  */
 #ifndef	CONFIG_IXP4XX_INDIRECT_PCI
 

commit cba362221b12b102dff1f21b291fdc7b93e24a18
Author: Krzysztof Hałasa <khc@pm.waw.pl>
Date:   Sun Nov 15 01:25:06 2009 +0100

    IXP4xx: Fix compilation failure with CONFIG_IXP4XX_INDIRECT_PCI.
    
    Instead of including the heavy linux/mm.h for VMALLOC_START, test the addresses
    against PCI MIN and MAX addresses. Indirect PCI uses 1:1 mapping for MMIO space
    making this change possible.
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index c06d4a2911a6..0e601fe50162 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -55,10 +55,16 @@ extern int ixp4xx_pci_write(u32 addr, u32 cmd, u32 data);
  * access registers. If something outside of PCI is ioremap'd, we
  * fallback to the default.
  */
+
+static inline int is_pci_memory(u32 addr)
+{
+	return (addr >= PCIBIOS_MIN_MEM) && (addr <= 0x4FFFFFFF);
+}
+
 static inline void __iomem * __indirect_ioremap(unsigned long addr, size_t size,
 						unsigned int mtype)
 {
-	if((addr < PCIBIOS_MIN_MEM) || (addr > 0x4fffffff))
+	if (!is_pci_memory(addr))
 		return __arm_ioremap(addr, size, mtype);
 
 	return (void __iomem *)addr;
@@ -66,7 +72,7 @@ static inline void __iomem * __indirect_ioremap(unsigned long addr, size_t size,
 
 static inline void __indirect_iounmap(void __iomem *addr)
 {
-	if ((__force u32)addr >= VMALLOC_START)
+	if (!is_pci_memory((__force u32)addr))
 		__iounmap(addr);
 }
 
@@ -94,7 +100,7 @@ static inline void __indirect_writeb(u8 value, volatile void __iomem *p)
 	u32 addr = (u32)p;
 	u32 n, byte_enables, data;
 
-	if (addr >= VMALLOC_START) {
+	if (!is_pci_memory(addr)) {
 		__raw_writeb(value, addr);
 		return;
 	}
@@ -117,7 +123,7 @@ static inline void __indirect_writew(u16 value, volatile void __iomem *p)
 	u32 addr = (u32)p;
 	u32 n, byte_enables, data;
 
-	if (addr >= VMALLOC_START) {
+	if (!is_pci_memory(addr)) {
 		__raw_writew(value, addr);
 		return;
 	}
@@ -138,7 +144,8 @@ static inline void __indirect_writesw(volatile void __iomem *bus_addr,
 static inline void __indirect_writel(u32 value, volatile void __iomem *p)
 {
 	u32 addr = (__force u32)p;
-	if (addr >= VMALLOC_START) {
+
+	if (!is_pci_memory(addr)) {
 		__raw_writel(value, p);
 		return;
 	}
@@ -158,7 +165,7 @@ static inline unsigned char __indirect_readb(const volatile void __iomem *p)
 	u32 addr = (u32)p;
 	u32 n, byte_enables, data;
 
-	if (addr >= VMALLOC_START)
+	if (!is_pci_memory(addr))
 		return __raw_readb(addr);
 
 	n = addr % 4;
@@ -181,7 +188,7 @@ static inline unsigned short __indirect_readw(const volatile void __iomem *p)
 	u32 addr = (u32)p;
 	u32 n, byte_enables, data;
 
-	if (addr >= VMALLOC_START)
+	if (!is_pci_memory(addr))
 		return __raw_readw(addr);
 
 	n = addr % 4;
@@ -204,7 +211,7 @@ static inline unsigned long __indirect_readl(const volatile void __iomem *p)
 	u32 addr = (__force u32)p;
 	u32 data;
 
-	if (addr >= VMALLOC_START)
+	if (!is_pci_memory(addr))
 		return __raw_readl(p);
 
 	if (ixp4xx_pci_read(addr, NP_CMD_MEMREAD, &data))

commit 58e570d1182a9dc3bc52d8dc508c6bd5b2d279c7
Author: Krzysztof Hałasa <khc@pm.waw.pl>
Date:   Sat Nov 14 22:55:42 2009 +0100

    IXP4xx: Drop "__ixp4xx_" prefix from in/out/ioread/iowrite functions for clarity.
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index 061a1f144a01..c06d4a2911a6 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -243,25 +243,8 @@ static inline void __indirect_readsl(const volatile void __iomem *bus_addr,
  * transaction.  This means that we need to override the default
  * I/O functions.
  */
-#define	outb(p, v)			__ixp4xx_outb(p, v)
-#define	outw(p, v)			__ixp4xx_outw(p, v)
-#define	outl(p, v)			__ixp4xx_outl(p, v)
-	
-#define	outsb(p, v, l)			__ixp4xx_outsb(p, v, l)
-#define	outsw(p, v, l)			__ixp4xx_outsw(p, v, l)
-#define	outsl(p, v, l)			__ixp4xx_outsl(p, v, l)
 
-#define	inb(p)				__ixp4xx_inb(p)
-#define	inw(p)				__ixp4xx_inw(p)
-#define	inl(p)				__ixp4xx_inl(p)
-
-#define	insb(p, v, l)			__ixp4xx_insb(p, v, l)
-#define	insw(p, v, l)			__ixp4xx_insw(p, v, l)
-#define	insl(p, v, l)			__ixp4xx_insl(p, v, l)
-
-
-static inline void 
-__ixp4xx_outb(u8 value, u32 addr)
+static inline void outb(u8 value, u32 addr)
 {
 	u32 n, byte_enables, data;
 	n = addr % 4;
@@ -270,15 +253,13 @@ __ixp4xx_outb(u8 value, u32 addr)
 	ixp4xx_pci_write(addr, byte_enables | NP_CMD_IOWRITE, data);
 }
 
-static inline void 
-__ixp4xx_outsb(u32 io_addr, const u8 *vaddr, u32 count)
+static inline void outsb(u32 io_addr, const u8 *vaddr, u32 count)
 {
 	while (count--)
 		outb(*vaddr++, io_addr);
 }
 
-static inline void 
-__ixp4xx_outw(u16 value, u32 addr)
+static inline void outw(u16 value, u32 addr)
 {
 	u32 n, byte_enables, data;
 	n = addr % 4;
@@ -287,28 +268,24 @@ __ixp4xx_outw(u16 value, u32 addr)
 	ixp4xx_pci_write(addr, byte_enables | NP_CMD_IOWRITE, data);
 }
 
-static inline void 
-__ixp4xx_outsw(u32 io_addr, const u16 *vaddr, u32 count)
+static inline void outsw(u32 io_addr, const u16 *vaddr, u32 count)
 {
 	while (count--)
 		outw(cpu_to_le16(*vaddr++), io_addr);
 }
 
-static inline void 
-__ixp4xx_outl(u32 value, u32 addr)
+static inline void outl(u32 value, u32 addr)
 {
 	ixp4xx_pci_write(addr, NP_CMD_IOWRITE, value);
 }
 
-static inline void 
-__ixp4xx_outsl(u32 io_addr, const u32 *vaddr, u32 count)
+static inline void outsl(u32 io_addr, const u32 *vaddr, u32 count)
 {
 	while (count--)
 		outl(cpu_to_le32(*vaddr++), io_addr);
 }
 
-static inline u8 
-__ixp4xx_inb(u32 addr)
+static inline u8 inb(u32 addr)
 {
 	u32 n, byte_enables, data;
 	n = addr % 4;
@@ -319,15 +296,13 @@ __ixp4xx_inb(u32 addr)
 	return data >> (8*n);
 }
 
-static inline void 
-__ixp4xx_insb(u32 io_addr, u8 *vaddr, u32 count)
+static inline void insb(u32 io_addr, u8 *vaddr, u32 count)
 {
 	while (count--)
 		*vaddr++ = inb(io_addr);
 }
 
-static inline u16 
-__ixp4xx_inw(u32 addr)
+static inline u16 inw(u32 addr)
 {
 	u32 n, byte_enables, data;
 	n = addr % 4;
@@ -338,15 +313,13 @@ __ixp4xx_inw(u32 addr)
 	return data>>(8*n);
 }
 
-static inline void 
-__ixp4xx_insw(u32 io_addr, u16 *vaddr, u32 count)
+static inline void insw(u32 io_addr, u16 *vaddr, u32 count)
 {
 	while (count--)
 		*vaddr++ = le16_to_cpu(inw(io_addr));
 }
 
-static inline u32 
-__ixp4xx_inl(u32 addr)
+static inline u32 inl(u32 addr)
 {
 	u32 data;
 	if (ixp4xx_pci_read(addr, NP_CMD_IOREAD, &data))
@@ -355,8 +328,7 @@ __ixp4xx_inl(u32 addr)
 	return data;
 }
 
-static inline void 
-__ixp4xx_insl(u32 io_addr, u32 *vaddr, u32 count)
+static inline void insl(u32 io_addr, u32 *vaddr, u32 count)
 {
 	while (count--)
 		*vaddr++ = le32_to_cpu(inl(io_addr));
@@ -368,12 +340,12 @@ __ixp4xx_insl(u32 io_addr, u32 *vaddr, u32 count)
 #define	__is_io_address(p)	(((unsigned long)p >= PIO_OFFSET) && \
 					((unsigned long)p <= (PIO_MASK + PIO_OFFSET)))
 
-static inline unsigned int
-__ixp4xx_ioread8(const void __iomem *addr)
+#define	ioread8(p)			ioread8(p)
+static inline unsigned int ioread8(const void __iomem *addr)
 {
 	unsigned long port = (unsigned long __force)addr;
 	if (__is_io_address(port))
-		return (unsigned int)__ixp4xx_inb(port & PIO_MASK);
+		return (unsigned int)inb(port & PIO_MASK);
 	else
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
 		return (unsigned int)__raw_readb(port);
@@ -382,12 +354,12 @@ __ixp4xx_ioread8(const void __iomem *addr)
 #endif
 }
 
-static inline void
-__ixp4xx_ioread8_rep(const void __iomem *addr, void *vaddr, u32 count)
+#define	ioread8_rep(p, v, c)		ioread8_rep(p, v, c)
+static inline void ioread8_rep(const void __iomem *addr, void *vaddr, u32 count)
 {
 	unsigned long port = (unsigned long __force)addr;
 	if (__is_io_address(port))
-		__ixp4xx_insb(port & PIO_MASK, vaddr, count);
+		insb(port & PIO_MASK, vaddr, count);
 	else
 #ifndef	CONFIG_IXP4XX_INDIRECT_PCI
 		__raw_readsb(addr, vaddr, count);
@@ -396,12 +368,12 @@ __ixp4xx_ioread8_rep(const void __iomem *addr, void *vaddr, u32 count)
 #endif
 }
 
-static inline unsigned int
-__ixp4xx_ioread16(const void __iomem *addr)
+#define	ioread16(p)			ioread16(p)
+static inline unsigned int ioread16(const void __iomem *addr)
 {
 	unsigned long port = (unsigned long __force)addr;
 	if (__is_io_address(port))
-		return	(unsigned int)__ixp4xx_inw(port & PIO_MASK);
+		return	(unsigned int)inw(port & PIO_MASK);
 	else
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
 		return le16_to_cpu(__raw_readw((u32)port));
@@ -410,12 +382,13 @@ __ixp4xx_ioread16(const void __iomem *addr)
 #endif
 }
 
-static inline void
-__ixp4xx_ioread16_rep(const void __iomem *addr, void *vaddr, u32 count)
+#define	ioread16_rep(p, v, c)		ioread16_rep(p, v, c)
+static inline void ioread16_rep(const void __iomem *addr, void *vaddr,
+				u32 count)
 {
 	unsigned long port = (unsigned long __force)addr;
 	if (__is_io_address(port))
-		__ixp4xx_insw(port & PIO_MASK, vaddr, count);
+		insw(port & PIO_MASK, vaddr, count);
 	else
 #ifndef	CONFIG_IXP4XX_INDIRECT_PCI
 		__raw_readsw(addr, vaddr, count);
@@ -424,12 +397,12 @@ __ixp4xx_ioread16_rep(const void __iomem *addr, void *vaddr, u32 count)
 #endif
 }
 
-static inline unsigned int
-__ixp4xx_ioread32(const void __iomem *addr)
+#define	ioread32(p)			ioread32(p)
+static inline unsigned int ioread32(const void __iomem *addr)
 {
 	unsigned long port = (unsigned long __force)addr;
 	if (__is_io_address(port))
-		return	(unsigned int)__ixp4xx_inl(port & PIO_MASK);
+		return	(unsigned int)inl(port & PIO_MASK);
 	else {
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
 		return le32_to_cpu((__force __le32)__raw_readl(addr));
@@ -439,12 +412,13 @@ __ixp4xx_ioread32(const void __iomem *addr)
 	}
 }
 
-static inline void
-__ixp4xx_ioread32_rep(const void __iomem *addr, void *vaddr, u32 count)
+#define	ioread32_rep(p, v, c)		ioread32_rep(p, v, c)
+static inline void ioread32_rep(const void __iomem *addr, void *vaddr,
+				u32 count)
 {
 	unsigned long port = (unsigned long __force)addr;
 	if (__is_io_address(port))
-		__ixp4xx_insl(port & PIO_MASK, vaddr, count);
+		insl(port & PIO_MASK, vaddr, count);
 	else
 #ifndef	CONFIG_IXP4XX_INDIRECT_PCI
 		__raw_readsl(addr, vaddr, count);
@@ -453,12 +427,12 @@ __ixp4xx_ioread32_rep(const void __iomem *addr, void *vaddr, u32 count)
 #endif
 }
 
-static inline void
-__ixp4xx_iowrite8(u8 value, void __iomem *addr)
+#define	iowrite8(v, p)			iowrite8(v, p)
+static inline void iowrite8(u8 value, void __iomem *addr)
 {
 	unsigned long port = (unsigned long __force)addr;
 	if (__is_io_address(port))
-		__ixp4xx_outb(value, port & PIO_MASK);
+		outb(value, port & PIO_MASK);
 	else
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
 		__raw_writeb(value, port);
@@ -467,12 +441,13 @@ __ixp4xx_iowrite8(u8 value, void __iomem *addr)
 #endif
 }
 
-static inline void
-__ixp4xx_iowrite8_rep(void __iomem *addr, const void *vaddr, u32 count)
+#define	iowrite8_rep(p, v, c)		iowrite8_rep(p, v, c)
+static inline void iowrite8_rep(void __iomem *addr, const void *vaddr,
+				u32 count)
 {
 	unsigned long port = (unsigned long __force)addr;
 	if (__is_io_address(port))
-		__ixp4xx_outsb(port & PIO_MASK, vaddr, count);
+		outsb(port & PIO_MASK, vaddr, count);
 	else
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
 		__raw_writesb(addr, vaddr, count);
@@ -481,12 +456,12 @@ __ixp4xx_iowrite8_rep(void __iomem *addr, const void *vaddr, u32 count)
 #endif
 }
 
-static inline void
-__ixp4xx_iowrite16(u16 value, void __iomem *addr)
+#define	iowrite16(v, p)			iowrite16(v, p)
+static inline void iowrite16(u16 value, void __iomem *addr)
 {
 	unsigned long port = (unsigned long __force)addr;
 	if (__is_io_address(port))
-		__ixp4xx_outw(value, port & PIO_MASK);
+		outw(value, port & PIO_MASK);
 	else
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
 		__raw_writew(cpu_to_le16(value), addr);
@@ -495,12 +470,13 @@ __ixp4xx_iowrite16(u16 value, void __iomem *addr)
 #endif
 }
 
-static inline void
-__ixp4xx_iowrite16_rep(void __iomem *addr, const void *vaddr, u32 count)
+#define	iowrite16_rep(p, v, c)		iowrite16_rep(p, v, c)
+static inline void iowrite16_rep(void __iomem *addr, const void *vaddr,
+				 u32 count)
 {
 	unsigned long port = (unsigned long __force)addr;
 	if (__is_io_address(port))
-		__ixp4xx_outsw(port & PIO_MASK, vaddr, count);
+		outsw(port & PIO_MASK, vaddr, count);
 	else
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
 		__raw_writesw(addr, vaddr, count);
@@ -509,12 +485,12 @@ __ixp4xx_iowrite16_rep(void __iomem *addr, const void *vaddr, u32 count)
 #endif
 }
 
-static inline void
-__ixp4xx_iowrite32(u32 value, void __iomem *addr)
+#define	iowrite32(v, p)			iowrite32(v, p)
+static inline void iowrite32(u32 value, void __iomem *addr)
 {
 	unsigned long port = (unsigned long __force)addr;
 	if (__is_io_address(port))
-		__ixp4xx_outl(value, port & PIO_MASK);
+		outl(value, port & PIO_MASK);
 	else
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
 		__raw_writel((u32 __force)cpu_to_le32(value), addr);
@@ -523,12 +499,13 @@ __ixp4xx_iowrite32(u32 value, void __iomem *addr)
 #endif
 }
 
-static inline void
-__ixp4xx_iowrite32_rep(void __iomem *addr, const void *vaddr, u32 count)
+#define	iowrite32_rep(p, v, c)		iowrite32_rep(p, v, c)
+static inline void iowrite32_rep(void __iomem *addr, const void *vaddr,
+				 u32 count)
 {
 	unsigned long port = (unsigned long __force)addr;
 	if (__is_io_address(port))
-		__ixp4xx_outsl(port & PIO_MASK, vaddr, count);
+		outsl(port & PIO_MASK, vaddr, count);
 	else
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
 		__raw_writesl(addr, vaddr, count);
@@ -537,25 +514,8 @@ __ixp4xx_iowrite32_rep(void __iomem *addr, const void *vaddr, u32 count)
 #endif
 }
 
-#define	ioread8(p)			__ixp4xx_ioread8(p)
-#define	ioread16(p)			__ixp4xx_ioread16(p)
-#define	ioread32(p)			__ixp4xx_ioread32(p)
-
-#define	ioread8_rep(p, v, c)		__ixp4xx_ioread8_rep(p, v, c)
-#define	ioread16_rep(p, v, c)		__ixp4xx_ioread16_rep(p, v, c)
-#define	ioread32_rep(p, v, c)		__ixp4xx_ioread32_rep(p, v, c)
-
-#define	iowrite8(v,p)			__ixp4xx_iowrite8(v,p)
-#define	iowrite16(v,p)			__ixp4xx_iowrite16(v,p)
-#define	iowrite32(v,p)			__ixp4xx_iowrite32(v,p)
-
-#define	iowrite8_rep(p, v, c)		__ixp4xx_iowrite8_rep(p, v, c)
-#define	iowrite16_rep(p, v, c)		__ixp4xx_iowrite16_rep(p, v, c)
-#define	iowrite32_rep(p, v, c)		__ixp4xx_iowrite32_rep(p, v, c)
-
 #define	ioport_map(port, nr)		((void __iomem*)(port + PIO_OFFSET))
 #define	ioport_unmap(addr)
-#endif	// !CONFIG_PCI
-
-#endif	//  __ASM_ARM_ARCH_IO_H
+#endif /* CONFIG_PCI */
 
+#endif /* __ASM_ARM_ARCH_IO_H */

commit 28f85cd3f65808cde50bb0e395043f38c3efa1cb
Author: Krzysztof Hałasa <khc@pm.waw.pl>
Date:   Sat Nov 14 19:44:44 2009 +0100

    IXP4xx: Rename indirect MMIO primitives from __ixp4xx_* to __indirect_*.
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index eb9c7489a999..061a1f144a01 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -55,8 +55,8 @@ extern int ixp4xx_pci_write(u32 addr, u32 cmd, u32 data);
  * access registers. If something outside of PCI is ioremap'd, we
  * fallback to the default.
  */
-static inline void __iomem *
-__ixp4xx_ioremap(unsigned long addr, size_t size, unsigned int mtype)
+static inline void __iomem * __indirect_ioremap(unsigned long addr, size_t size,
+						unsigned int mtype)
 {
 	if((addr < PCIBIOS_MIN_MEM) || (addr > 0x4fffffff))
 		return __arm_ioremap(addr, size, mtype);
@@ -64,34 +64,32 @@ __ixp4xx_ioremap(unsigned long addr, size_t size, unsigned int mtype)
 	return (void __iomem *)addr;
 }
 
-static inline void
-__ixp4xx_iounmap(void __iomem *addr)
+static inline void __indirect_iounmap(void __iomem *addr)
 {
 	if ((__force u32)addr >= VMALLOC_START)
 		__iounmap(addr);
 }
 
-#define __arch_ioremap(a, s, f)		__ixp4xx_ioremap(a, s, f)
-#define	__arch_iounmap(a)		__ixp4xx_iounmap(a)
+#define __arch_ioremap(a, s, f)		__indirect_ioremap(a, s, f)
+#define __arch_iounmap(a)		__indirect_iounmap(a)
 
-#define	writeb(v, p)			__ixp4xx_writeb(v, p)
-#define	writew(v, p)			__ixp4xx_writew(v, p)
-#define	writel(v, p)			__ixp4xx_writel(v, p)
+#define writeb(v, p)			__indirect_writeb(v, p)
+#define writew(v, p)			__indirect_writew(v, p)
+#define writel(v, p)			__indirect_writel(v, p)
 
-#define	writesb(p, v, l)		__ixp4xx_writesb(p, v, l)
-#define	writesw(p, v, l)		__ixp4xx_writesw(p, v, l)
-#define	writesl(p, v, l)		__ixp4xx_writesl(p, v, l)
-	
-#define	readb(p)			__ixp4xx_readb(p)
-#define	readw(p)			__ixp4xx_readw(p)
-#define	readl(p)			__ixp4xx_readl(p)
-	
-#define	readsb(p, v, l)			__ixp4xx_readsb(p, v, l)
-#define	readsw(p, v, l)			__ixp4xx_readsw(p, v, l)
-#define	readsl(p, v, l)			__ixp4xx_readsl(p, v, l)
+#define writesb(p, v, l)		__indirect_writesb(p, v, l)
+#define writesw(p, v, l)		__indirect_writesw(p, v, l)
+#define writesl(p, v, l)		__indirect_writesl(p, v, l)
 
-static inline void 
-__ixp4xx_writeb(u8 value, volatile void __iomem *p)
+#define readb(p)			__indirect_readb(p)
+#define readw(p)			__indirect_readw(p)
+#define readl(p)			__indirect_readl(p)
+
+#define readsb(p, v, l)			__indirect_readsb(p, v, l)
+#define readsw(p, v, l)			__indirect_readsw(p, v, l)
+#define readsl(p, v, l)			__indirect_readsl(p, v, l)
+
+static inline void __indirect_writeb(u8 value, volatile void __iomem *p)
 {
 	u32 addr = (u32)p;
 	u32 n, byte_enables, data;
@@ -107,15 +105,14 @@ __ixp4xx_writeb(u8 value, volatile void __iomem *p)
 	ixp4xx_pci_write(addr, byte_enables | NP_CMD_MEMWRITE, data);
 }
 
-static inline void
-__ixp4xx_writesb(volatile void __iomem *bus_addr, const u8 *vaddr, int count)
+static inline void __indirect_writesb(volatile void __iomem *bus_addr,
+				      const u8 *vaddr, int count)
 {
 	while (count--)
 		writeb(*vaddr++, bus_addr);
 }
 
-static inline void 
-__ixp4xx_writew(u16 value, volatile void __iomem *p)
+static inline void __indirect_writew(u16 value, volatile void __iomem *p)
 {
 	u32 addr = (u32)p;
 	u32 n, byte_enables, data;
@@ -131,15 +128,14 @@ __ixp4xx_writew(u16 value, volatile void __iomem *p)
 	ixp4xx_pci_write(addr, byte_enables | NP_CMD_MEMWRITE, data);
 }
 
-static inline void
-__ixp4xx_writesw(volatile void __iomem *bus_addr, const u16 *vaddr, int count)
+static inline void __indirect_writesw(volatile void __iomem *bus_addr,
+				      const u16 *vaddr, int count)
 {
 	while (count--)
 		writew(*vaddr++, bus_addr);
 }
 
-static inline void 
-__ixp4xx_writel(u32 value, volatile void __iomem *p)
+static inline void __indirect_writel(u32 value, volatile void __iomem *p)
 {
 	u32 addr = (__force u32)p;
 	if (addr >= VMALLOC_START) {
@@ -150,15 +146,14 @@ __ixp4xx_writel(u32 value, volatile void __iomem *p)
 	ixp4xx_pci_write(addr, NP_CMD_MEMWRITE, value);
 }
 
-static inline void
-__ixp4xx_writesl(volatile void __iomem *bus_addr, const u32 *vaddr, int count)
+static inline void __indirect_writesl(volatile void __iomem *bus_addr,
+				      const u32 *vaddr, int count)
 {
 	while (count--)
 		writel(*vaddr++, bus_addr);
 }
 
-static inline unsigned char 
-__ixp4xx_readb(const volatile void __iomem *p)
+static inline unsigned char __indirect_readb(const volatile void __iomem *p)
 {
 	u32 addr = (u32)p;
 	u32 n, byte_enables, data;
@@ -174,15 +169,14 @@ __ixp4xx_readb(const volatile void __iomem *p)
 	return data >> (8*n);
 }
 
-static inline void
-__ixp4xx_readsb(const volatile void __iomem *bus_addr, u8 *vaddr, u32 count)
+static inline void __indirect_readsb(const volatile void __iomem *bus_addr,
+				     u8 *vaddr, u32 count)
 {
 	while (count--)
 		*vaddr++ = readb(bus_addr);
 }
 
-static inline unsigned short 
-__ixp4xx_readw(const volatile void __iomem *p)
+static inline unsigned short __indirect_readw(const volatile void __iomem *p)
 {
 	u32 addr = (u32)p;
 	u32 n, byte_enables, data;
@@ -198,15 +192,14 @@ __ixp4xx_readw(const volatile void __iomem *p)
 	return data>>(8*n);
 }
 
-static inline void 
-__ixp4xx_readsw(const volatile void __iomem *bus_addr, u16 *vaddr, u32 count)
+static inline void __indirect_readsw(const volatile void __iomem *bus_addr,
+				     u16 *vaddr, u32 count)
 {
 	while (count--)
 		*vaddr++ = readw(bus_addr);
 }
 
-static inline unsigned long 
-__ixp4xx_readl(const volatile void __iomem *p)
+static inline unsigned long __indirect_readl(const volatile void __iomem *p)
 {
 	u32 addr = (__force u32)p;
 	u32 data;
@@ -220,8 +213,8 @@ __ixp4xx_readl(const volatile void __iomem *p)
 	return data;
 }
 
-static inline void 
-__ixp4xx_readsl(const volatile void __iomem *bus_addr, u32 *vaddr, u32 count)
+static inline void __indirect_readsl(const volatile void __iomem *bus_addr,
+				     u32 *vaddr, u32 count)
 {
 	while (count--)
 		*vaddr++ = readl(bus_addr);
@@ -235,7 +228,7 @@ __ixp4xx_readsl(const volatile void __iomem *bus_addr, u32 *vaddr, u32 count)
 #define memcpy_fromio(a,c,l)		_memcpy_fromio((a),(c),(l))
 #define memcpy_toio(c,a,l)		_memcpy_toio((c),(a),(l))
 
-#endif
+#endif /* CONFIG_IXP4XX_INDIRECT_PCI */
 
 #ifndef CONFIG_PCI
 
@@ -385,7 +378,7 @@ __ixp4xx_ioread8(const void __iomem *addr)
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
 		return (unsigned int)__raw_readb(port);
 #else
-		return (unsigned int)__ixp4xx_readb(addr);
+		return (unsigned int)__indirect_readb(addr);
 #endif
 }
 
@@ -399,7 +392,7 @@ __ixp4xx_ioread8_rep(const void __iomem *addr, void *vaddr, u32 count)
 #ifndef	CONFIG_IXP4XX_INDIRECT_PCI
 		__raw_readsb(addr, vaddr, count);
 #else
-		__ixp4xx_readsb(addr, vaddr, count);
+		__indirect_readsb(addr, vaddr, count);
 #endif
 }
 
@@ -413,7 +406,7 @@ __ixp4xx_ioread16(const void __iomem *addr)
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
 		return le16_to_cpu(__raw_readw((u32)port));
 #else
-		return (unsigned int)__ixp4xx_readw(addr);
+		return (unsigned int)__indirect_readw(addr);
 #endif
 }
 
@@ -427,7 +420,7 @@ __ixp4xx_ioread16_rep(const void __iomem *addr, void *vaddr, u32 count)
 #ifndef	CONFIG_IXP4XX_INDIRECT_PCI
 		__raw_readsw(addr, vaddr, count);
 #else
-		__ixp4xx_readsw(addr, vaddr, count);
+		__indirect_readsw(addr, vaddr, count);
 #endif
 }
 
@@ -441,7 +434,7 @@ __ixp4xx_ioread32(const void __iomem *addr)
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
 		return le32_to_cpu((__force __le32)__raw_readl(addr));
 #else
-		return (unsigned int)__ixp4xx_readl(addr);
+		return (unsigned int)__indirect_readl(addr);
 #endif
 	}
 }
@@ -456,7 +449,7 @@ __ixp4xx_ioread32_rep(const void __iomem *addr, void *vaddr, u32 count)
 #ifndef	CONFIG_IXP4XX_INDIRECT_PCI
 		__raw_readsl(addr, vaddr, count);
 #else
-		__ixp4xx_readsl(addr, vaddr, count);
+		__indirect_readsl(addr, vaddr, count);
 #endif
 }
 
@@ -470,7 +463,7 @@ __ixp4xx_iowrite8(u8 value, void __iomem *addr)
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
 		__raw_writeb(value, port);
 #else
-		__ixp4xx_writeb(value, addr);
+		__indirect_writeb(value, addr);
 #endif
 }
 
@@ -484,7 +477,7 @@ __ixp4xx_iowrite8_rep(void __iomem *addr, const void *vaddr, u32 count)
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
 		__raw_writesb(addr, vaddr, count);
 #else
-		__ixp4xx_writesb(addr, vaddr, count);
+		__indirect_writesb(addr, vaddr, count);
 #endif
 }
 
@@ -498,7 +491,7 @@ __ixp4xx_iowrite16(u16 value, void __iomem *addr)
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
 		__raw_writew(cpu_to_le16(value), addr);
 #else
-		__ixp4xx_writew(value, addr);
+		__indirect_writew(value, addr);
 #endif
 }
 
@@ -512,7 +505,7 @@ __ixp4xx_iowrite16_rep(void __iomem *addr, const void *vaddr, u32 count)
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
 		__raw_writesw(addr, vaddr, count);
 #else
-		__ixp4xx_writesw(addr, vaddr, count);
+		__indirect_writesw(addr, vaddr, count);
 #endif
 }
 
@@ -526,7 +519,7 @@ __ixp4xx_iowrite32(u32 value, void __iomem *addr)
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
 		__raw_writel((u32 __force)cpu_to_le32(value), addr);
 #else
-		__ixp4xx_writel(value, addr);
+		__indirect_writel(value, addr);
 #endif
 }
 
@@ -540,7 +533,7 @@ __ixp4xx_iowrite32_rep(void __iomem *addr, const void *vaddr, u32 count)
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
 		__raw_writesl(addr, vaddr, count);
 #else
-		__ixp4xx_writesl(addr, vaddr, count);
+		__indirect_writesl(addr, vaddr, count);
 #endif
 }
 

commit 9f2c94928a0d713d223b53909734877fe4f340ab
Author: Krzysztof Hałasa <khc@pm.waw.pl>
Date:   Wed Nov 11 00:21:48 2009 +0100

    ARM: fix insl() and outsl() endianness on IXP4xx architecture.
    
    The repetitive in/out functions must preserve order, not value.
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index 8a947d42a6f1..eb9c7489a999 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -311,7 +311,7 @@ static inline void
 __ixp4xx_outsl(u32 io_addr, const u32 *vaddr, u32 count)
 {
 	while (count--)
-		outl(*vaddr++, io_addr);
+		outl(cpu_to_le32(*vaddr++), io_addr);
 }
 
 static inline u8 
@@ -366,7 +366,7 @@ static inline void
 __ixp4xx_insl(u32 io_addr, u32 *vaddr, u32 count)
 {
 	while (count--)
-		*vaddr++ = inl(io_addr);
+		*vaddr++ = le32_to_cpu(inl(io_addr));
 }
 
 #define PIO_OFFSET      0x10000UL
@@ -374,12 +374,13 @@ __ixp4xx_insl(u32 io_addr, u32 *vaddr, u32 count)
 
 #define	__is_io_address(p)	(((unsigned long)p >= PIO_OFFSET) && \
 					((unsigned long)p <= (PIO_MASK + PIO_OFFSET)))
+
 static inline unsigned int
 __ixp4xx_ioread8(const void __iomem *addr)
 {
 	unsigned long port = (unsigned long __force)addr;
 	if (__is_io_address(port))
-		return	(unsigned int)__ixp4xx_inb(port & PIO_MASK);
+		return (unsigned int)__ixp4xx_inb(port & PIO_MASK);
 	else
 #ifndef CONFIG_IXP4XX_INDIRECT_PCI
 		return (unsigned int)__raw_readb(port);

commit dee2b904a1f93c275a015b67cd693038d74b18e8
Author: Mikael Pettersson <mikpe@it.uu.se>
Date:   Sun Aug 9 21:21:57 2009 +0200

    IXP4xx: Fix IO_SPACE_LIMIT for 2.6.31-rc core PCI changes
    
    2.6.31-rc kernels don't boot on my ixp4xx box (ds101), because the libata
    driver doesn't find the PCI IDE controller any more. 2.6.30 was fine.
    I traced this to a PCI update (1f82de10d6b1d845155363c895c552e61b36b51a)
    in 2.6.30-git19. Diffing the kernel boot logs from 2.6.30-git18 and
    2.6.30-git19 illustrates the breakage:
    
    > --- dmesg-2.6.30-git18        2009-08-04 01:45:22.000000000 +0200
    > +++ dmesg-2.6.30-git19        2009-08-04 01:45:46.000000000 +0200
    > @@ -26,6 +26,13 @@
    >  pci 0000:00:02.2: PME# supported from D0 D1 D2 D3hot
    >  pci 0000:00:02.2: PME# disabled
    >  PCI: bus0: Fast back to back transfers disabled
    > +pci 0000:00:01.0: BAR 0: can't allocate I/O resource [0x10000-0xffff]
    > +pci 0000:00:01.0: BAR 1: can't allocate I/O resource [0x10000-0xffff]
    > +pci 0000:00:01.0: BAR 2: can't allocate I/O resource [0x10000-0xffff]
    > +pci 0000:00:01.0: BAR 3: can't allocate I/O resource [0x10000-0xffff]
    > +pci 0000:00:01.0: BAR 4: can't allocate I/O resource [0x10000-0xffff]
    > +pci 0000:00:02.0: BAR 4: can't allocate I/O resource [0x10000-0xffff]
    > +pci 0000:00:02.1: BAR 4: can't allocate I/O resource [0x10000-0xffff]
    >  bio: create slab <bio-0> at 0
    >  SCSI subsystem initialized
    >  NET: Registered protocol family 2
    > @@ -44,11 +51,7 @@
    >  console [ttyS0] enabled
    >  serial8250.0: ttyS1 at MMIO 0xc8001000 (irq = 13) is a XScale
    >  Driver 'sd' needs updating - please use bus_type methods
    > -PCI: enabling device 0000:00:01.0 (0140 -> 0141)
    > -scsi0 : pata_artop
    > -scsi1 : pata_artop
    > -ata1: PATA max UDMA/100 cmd 0x1050 ctl 0x1060 bmdma 0x1040 irq 28
    > -ata2: PATA max UDMA/100 cmd 0x1058 ctl 0x1064 bmdma 0x1048 irq 28
    > +pata_artop 0000:00:01.0: no available native port
    >  Using configured DiskOnChip probe address 0x50000000
    >  DiskOnChip found at 0x50000000
    >  NAND device: Manufacturer ID: 0x98, Chip ID: 0x73 (Toshiba NAND 16MiB 3,3V 8-bit)
    
    The specific change in 1f82de10d6b1d845155363c895c552e61b36b51a responsible
    for this failure turned out to be the following:
    
    > --- a/drivers/pci/probe.c
    > +++ b/drivers/pci/probe.c
    > @@ -193,7 +193,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
    >               res->flags |= pci_calc_resource_flags(l) | IORESOURCE_SIZEALIGN;
    >               if (type == pci_bar_io) {
    >                       l &= PCI_BASE_ADDRESS_IO_MASK;
    > -                     mask = PCI_BASE_ADDRESS_IO_MASK & 0xffff;
    > +                     mask = PCI_BASE_ADDRESS_IO_MASK & IO_SPACE_LIMIT;
    >               } else {
    >                       l &= PCI_BASE_ADDRESS_MEM_MASK;
    >                       mask = (u32)PCI_BASE_ADDRESS_MEM_MASK;
    
    Every arch except arm's ixp4xx defines IO_SPACE_LIMIT as an all-bits-one
    bitmask, typically -1UL but sometimes only a 16-bit 0x0000ffff. But ixp4xx
    defines it as 0xffff0000, which is now causing the PCI failures.
    
    Russell King noted that ixp4xx has 64KB PCI IO space, so IO_SPACE_LIMIT
    should be 0x0000ffff. This patch makes that change, which fixes the PCI
    failures on my ixp4xx box.
    
    Signed-off-by: Mikael Pettersson <mikpe@it.uu.se>
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index ce63048d45eb..8a947d42a6f1 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -17,7 +17,7 @@
 
 #include <mach/hardware.h>
 
-#define IO_SPACE_LIMIT 0xffff0000
+#define IO_SPACE_LIMIT 0x0000ffff
 
 extern int (*ixp4xx_pci_read)(u32 addr, u32 cmd, u32* data);
 extern int ixp4xx_pci_write(u32 addr, u32 cmd, u32 data);

commit 0560cf5aa51216b06874333a2fa26ca034d97bdb
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Nov 30 11:45:54 2008 +0000

    [ARM] Add a common typesafe __io implementation
    
    As Al did for Versatile in 2ad4f86b60b649fd7428265c08d73a3bd360c81b,
    add a typesafe __io implementation for platforms to use.  Convert
    platforms to use this new simple typesafe implementation.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index b7f780f574fa..ce63048d45eb 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -239,7 +239,7 @@ __ixp4xx_readsl(const volatile void __iomem *bus_addr, u32 *vaddr, u32 count)
 
 #ifndef CONFIG_PCI
 
-#define	__io(v)		v
+#define	__io(v)		__typesafe_io(v)
 
 #else
 

commit 4b78a9ffabbb03af4032ff704689912298e19070
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Nov 28 21:12:40 2008 +0000

    [ARM] ixp4xx: clean up includes
    
    mach/io.h doesn't need linux/mm.h.
    mach/dma.h doesn't need linux/device.h, asm/page.h or mach/hardware.h
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
index 319948e31bec..b7f780f574fa 100644
--- a/arch/arm/mach-ixp4xx/include/mach/io.h
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -49,8 +49,6 @@ extern int ixp4xx_pci_write(u32 addr, u32 cmd, u32 data);
 
 #else
 
-#include <linux/mm.h>
-
 /*
  * In the case of using indirect PCI, we simply return the actual PCI
  * address and our read/write implementation use that to drive the 

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/include/mach/io.h b/arch/arm/mach-ixp4xx/include/mach/io.h
new file mode 100644
index 000000000000..319948e31bec
--- /dev/null
+++ b/arch/arm/mach-ixp4xx/include/mach/io.h
@@ -0,0 +1,569 @@
+/*
+ * arch/arm/mach-ixp4xx/include/mach/io.h
+ *
+ * Author: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright (C) 2002-2005  MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#include <linux/bitops.h>
+
+#include <mach/hardware.h>
+
+#define IO_SPACE_LIMIT 0xffff0000
+
+extern int (*ixp4xx_pci_read)(u32 addr, u32 cmd, u32* data);
+extern int ixp4xx_pci_write(u32 addr, u32 cmd, u32 data);
+
+
+/*
+ * IXP4xx provides two methods of accessing PCI memory space:
+ *
+ * 1) A direct mapped window from 0x48000000 to 0x4bffffff (64MB).
+ *    To access PCI via this space, we simply ioremap() the BAR
+ *    into the kernel and we can use the standard read[bwl]/write[bwl]
+ *    macros. This is the preffered method due to speed but it
+ *    limits the system to just 64MB of PCI memory. This can be 
+ *    problamatic if using video cards and other memory-heavy
+ *    targets.
+ *
+ * 2) If > 64MB of memory space is required, the IXP4xx can be configured
+ *    to use indirect registers to access PCI (as we do below for I/O
+ *    transactions). This allows for up to 128MB (0x48000000 to 0x4fffffff)
+ *    of memory on the bus. The disadvantage of this is that every 
+ *    PCI access requires three local register accesses plus a spinlock,
+ *    but in some cases the performance hit is acceptable. In addition,
+ *    you cannot mmap() PCI devices in this case.
+ *
+ */
+#ifndef	CONFIG_IXP4XX_INDIRECT_PCI
+
+#define __mem_pci(a)		(a)
+
+#else
+
+#include <linux/mm.h>
+
+/*
+ * In the case of using indirect PCI, we simply return the actual PCI
+ * address and our read/write implementation use that to drive the 
+ * access registers. If something outside of PCI is ioremap'd, we
+ * fallback to the default.
+ */
+static inline void __iomem *
+__ixp4xx_ioremap(unsigned long addr, size_t size, unsigned int mtype)
+{
+	if((addr < PCIBIOS_MIN_MEM) || (addr > 0x4fffffff))
+		return __arm_ioremap(addr, size, mtype);
+
+	return (void __iomem *)addr;
+}
+
+static inline void
+__ixp4xx_iounmap(void __iomem *addr)
+{
+	if ((__force u32)addr >= VMALLOC_START)
+		__iounmap(addr);
+}
+
+#define __arch_ioremap(a, s, f)		__ixp4xx_ioremap(a, s, f)
+#define	__arch_iounmap(a)		__ixp4xx_iounmap(a)
+
+#define	writeb(v, p)			__ixp4xx_writeb(v, p)
+#define	writew(v, p)			__ixp4xx_writew(v, p)
+#define	writel(v, p)			__ixp4xx_writel(v, p)
+
+#define	writesb(p, v, l)		__ixp4xx_writesb(p, v, l)
+#define	writesw(p, v, l)		__ixp4xx_writesw(p, v, l)
+#define	writesl(p, v, l)		__ixp4xx_writesl(p, v, l)
+	
+#define	readb(p)			__ixp4xx_readb(p)
+#define	readw(p)			__ixp4xx_readw(p)
+#define	readl(p)			__ixp4xx_readl(p)
+	
+#define	readsb(p, v, l)			__ixp4xx_readsb(p, v, l)
+#define	readsw(p, v, l)			__ixp4xx_readsw(p, v, l)
+#define	readsl(p, v, l)			__ixp4xx_readsl(p, v, l)
+
+static inline void 
+__ixp4xx_writeb(u8 value, volatile void __iomem *p)
+{
+	u32 addr = (u32)p;
+	u32 n, byte_enables, data;
+
+	if (addr >= VMALLOC_START) {
+		__raw_writeb(value, addr);
+		return;
+	}
+
+	n = addr % 4;
+	byte_enables = (0xf & ~BIT(n)) << IXP4XX_PCI_NP_CBE_BESL;
+	data = value << (8*n);
+	ixp4xx_pci_write(addr, byte_enables | NP_CMD_MEMWRITE, data);
+}
+
+static inline void
+__ixp4xx_writesb(volatile void __iomem *bus_addr, const u8 *vaddr, int count)
+{
+	while (count--)
+		writeb(*vaddr++, bus_addr);
+}
+
+static inline void 
+__ixp4xx_writew(u16 value, volatile void __iomem *p)
+{
+	u32 addr = (u32)p;
+	u32 n, byte_enables, data;
+
+	if (addr >= VMALLOC_START) {
+		__raw_writew(value, addr);
+		return;
+	}
+
+	n = addr % 4;
+	byte_enables = (0xf & ~(BIT(n) | BIT(n+1))) << IXP4XX_PCI_NP_CBE_BESL;
+	data = value << (8*n);
+	ixp4xx_pci_write(addr, byte_enables | NP_CMD_MEMWRITE, data);
+}
+
+static inline void
+__ixp4xx_writesw(volatile void __iomem *bus_addr, const u16 *vaddr, int count)
+{
+	while (count--)
+		writew(*vaddr++, bus_addr);
+}
+
+static inline void 
+__ixp4xx_writel(u32 value, volatile void __iomem *p)
+{
+	u32 addr = (__force u32)p;
+	if (addr >= VMALLOC_START) {
+		__raw_writel(value, p);
+		return;
+	}
+
+	ixp4xx_pci_write(addr, NP_CMD_MEMWRITE, value);
+}
+
+static inline void
+__ixp4xx_writesl(volatile void __iomem *bus_addr, const u32 *vaddr, int count)
+{
+	while (count--)
+		writel(*vaddr++, bus_addr);
+}
+
+static inline unsigned char 
+__ixp4xx_readb(const volatile void __iomem *p)
+{
+	u32 addr = (u32)p;
+	u32 n, byte_enables, data;
+
+	if (addr >= VMALLOC_START)
+		return __raw_readb(addr);
+
+	n = addr % 4;
+	byte_enables = (0xf & ~BIT(n)) << IXP4XX_PCI_NP_CBE_BESL;
+	if (ixp4xx_pci_read(addr, byte_enables | NP_CMD_MEMREAD, &data))
+		return 0xff;
+
+	return data >> (8*n);
+}
+
+static inline void
+__ixp4xx_readsb(const volatile void __iomem *bus_addr, u8 *vaddr, u32 count)
+{
+	while (count--)
+		*vaddr++ = readb(bus_addr);
+}
+
+static inline unsigned short 
+__ixp4xx_readw(const volatile void __iomem *p)
+{
+	u32 addr = (u32)p;
+	u32 n, byte_enables, data;
+
+	if (addr >= VMALLOC_START)
+		return __raw_readw(addr);
+
+	n = addr % 4;
+	byte_enables = (0xf & ~(BIT(n) | BIT(n+1))) << IXP4XX_PCI_NP_CBE_BESL;
+	if (ixp4xx_pci_read(addr, byte_enables | NP_CMD_MEMREAD, &data))
+		return 0xffff;
+
+	return data>>(8*n);
+}
+
+static inline void 
+__ixp4xx_readsw(const volatile void __iomem *bus_addr, u16 *vaddr, u32 count)
+{
+	while (count--)
+		*vaddr++ = readw(bus_addr);
+}
+
+static inline unsigned long 
+__ixp4xx_readl(const volatile void __iomem *p)
+{
+	u32 addr = (__force u32)p;
+	u32 data;
+
+	if (addr >= VMALLOC_START)
+		return __raw_readl(p);
+
+	if (ixp4xx_pci_read(addr, NP_CMD_MEMREAD, &data))
+		return 0xffffffff;
+
+	return data;
+}
+
+static inline void 
+__ixp4xx_readsl(const volatile void __iomem *bus_addr, u32 *vaddr, u32 count)
+{
+	while (count--)
+		*vaddr++ = readl(bus_addr);
+}
+
+
+/*
+ * We can use the built-in functions b/c they end up calling writeb/readb
+ */
+#define memset_io(c,v,l)		_memset_io((c),(v),(l))
+#define memcpy_fromio(a,c,l)		_memcpy_fromio((a),(c),(l))
+#define memcpy_toio(c,a,l)		_memcpy_toio((c),(a),(l))
+
+#endif
+
+#ifndef CONFIG_PCI
+
+#define	__io(v)		v
+
+#else
+
+/*
+ * IXP4xx does not have a transparent cpu -> PCI I/O translation
+ * window.  Instead, it has a set of registers that must be tweaked
+ * with the proper byte lanes, command types, and address for the
+ * transaction.  This means that we need to override the default
+ * I/O functions.
+ */
+#define	outb(p, v)			__ixp4xx_outb(p, v)
+#define	outw(p, v)			__ixp4xx_outw(p, v)
+#define	outl(p, v)			__ixp4xx_outl(p, v)
+	
+#define	outsb(p, v, l)			__ixp4xx_outsb(p, v, l)
+#define	outsw(p, v, l)			__ixp4xx_outsw(p, v, l)
+#define	outsl(p, v, l)			__ixp4xx_outsl(p, v, l)
+
+#define	inb(p)				__ixp4xx_inb(p)
+#define	inw(p)				__ixp4xx_inw(p)
+#define	inl(p)				__ixp4xx_inl(p)
+
+#define	insb(p, v, l)			__ixp4xx_insb(p, v, l)
+#define	insw(p, v, l)			__ixp4xx_insw(p, v, l)
+#define	insl(p, v, l)			__ixp4xx_insl(p, v, l)
+
+
+static inline void 
+__ixp4xx_outb(u8 value, u32 addr)
+{
+	u32 n, byte_enables, data;
+	n = addr % 4;
+	byte_enables = (0xf & ~BIT(n)) << IXP4XX_PCI_NP_CBE_BESL;
+	data = value << (8*n);
+	ixp4xx_pci_write(addr, byte_enables | NP_CMD_IOWRITE, data);
+}
+
+static inline void 
+__ixp4xx_outsb(u32 io_addr, const u8 *vaddr, u32 count)
+{
+	while (count--)
+		outb(*vaddr++, io_addr);
+}
+
+static inline void 
+__ixp4xx_outw(u16 value, u32 addr)
+{
+	u32 n, byte_enables, data;
+	n = addr % 4;
+	byte_enables = (0xf & ~(BIT(n) | BIT(n+1))) << IXP4XX_PCI_NP_CBE_BESL;
+	data = value << (8*n);
+	ixp4xx_pci_write(addr, byte_enables | NP_CMD_IOWRITE, data);
+}
+
+static inline void 
+__ixp4xx_outsw(u32 io_addr, const u16 *vaddr, u32 count)
+{
+	while (count--)
+		outw(cpu_to_le16(*vaddr++), io_addr);
+}
+
+static inline void 
+__ixp4xx_outl(u32 value, u32 addr)
+{
+	ixp4xx_pci_write(addr, NP_CMD_IOWRITE, value);
+}
+
+static inline void 
+__ixp4xx_outsl(u32 io_addr, const u32 *vaddr, u32 count)
+{
+	while (count--)
+		outl(*vaddr++, io_addr);
+}
+
+static inline u8 
+__ixp4xx_inb(u32 addr)
+{
+	u32 n, byte_enables, data;
+	n = addr % 4;
+	byte_enables = (0xf & ~BIT(n)) << IXP4XX_PCI_NP_CBE_BESL;
+	if (ixp4xx_pci_read(addr, byte_enables | NP_CMD_IOREAD, &data))
+		return 0xff;
+
+	return data >> (8*n);
+}
+
+static inline void 
+__ixp4xx_insb(u32 io_addr, u8 *vaddr, u32 count)
+{
+	while (count--)
+		*vaddr++ = inb(io_addr);
+}
+
+static inline u16 
+__ixp4xx_inw(u32 addr)
+{
+	u32 n, byte_enables, data;
+	n = addr % 4;
+	byte_enables = (0xf & ~(BIT(n) | BIT(n+1))) << IXP4XX_PCI_NP_CBE_BESL;
+	if (ixp4xx_pci_read(addr, byte_enables | NP_CMD_IOREAD, &data))
+		return 0xffff;
+
+	return data>>(8*n);
+}
+
+static inline void 
+__ixp4xx_insw(u32 io_addr, u16 *vaddr, u32 count)
+{
+	while (count--)
+		*vaddr++ = le16_to_cpu(inw(io_addr));
+}
+
+static inline u32 
+__ixp4xx_inl(u32 addr)
+{
+	u32 data;
+	if (ixp4xx_pci_read(addr, NP_CMD_IOREAD, &data))
+		return 0xffffffff;
+
+	return data;
+}
+
+static inline void 
+__ixp4xx_insl(u32 io_addr, u32 *vaddr, u32 count)
+{
+	while (count--)
+		*vaddr++ = inl(io_addr);
+}
+
+#define PIO_OFFSET      0x10000UL
+#define PIO_MASK        0x0ffffUL
+
+#define	__is_io_address(p)	(((unsigned long)p >= PIO_OFFSET) && \
+					((unsigned long)p <= (PIO_MASK + PIO_OFFSET)))
+static inline unsigned int
+__ixp4xx_ioread8(const void __iomem *addr)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		return	(unsigned int)__ixp4xx_inb(port & PIO_MASK);
+	else
+#ifndef CONFIG_IXP4XX_INDIRECT_PCI
+		return (unsigned int)__raw_readb(port);
+#else
+		return (unsigned int)__ixp4xx_readb(addr);
+#endif
+}
+
+static inline void
+__ixp4xx_ioread8_rep(const void __iomem *addr, void *vaddr, u32 count)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		__ixp4xx_insb(port & PIO_MASK, vaddr, count);
+	else
+#ifndef	CONFIG_IXP4XX_INDIRECT_PCI
+		__raw_readsb(addr, vaddr, count);
+#else
+		__ixp4xx_readsb(addr, vaddr, count);
+#endif
+}
+
+static inline unsigned int
+__ixp4xx_ioread16(const void __iomem *addr)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		return	(unsigned int)__ixp4xx_inw(port & PIO_MASK);
+	else
+#ifndef CONFIG_IXP4XX_INDIRECT_PCI
+		return le16_to_cpu(__raw_readw((u32)port));
+#else
+		return (unsigned int)__ixp4xx_readw(addr);
+#endif
+}
+
+static inline void
+__ixp4xx_ioread16_rep(const void __iomem *addr, void *vaddr, u32 count)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		__ixp4xx_insw(port & PIO_MASK, vaddr, count);
+	else
+#ifndef	CONFIG_IXP4XX_INDIRECT_PCI
+		__raw_readsw(addr, vaddr, count);
+#else
+		__ixp4xx_readsw(addr, vaddr, count);
+#endif
+}
+
+static inline unsigned int
+__ixp4xx_ioread32(const void __iomem *addr)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		return	(unsigned int)__ixp4xx_inl(port & PIO_MASK);
+	else {
+#ifndef CONFIG_IXP4XX_INDIRECT_PCI
+		return le32_to_cpu((__force __le32)__raw_readl(addr));
+#else
+		return (unsigned int)__ixp4xx_readl(addr);
+#endif
+	}
+}
+
+static inline void
+__ixp4xx_ioread32_rep(const void __iomem *addr, void *vaddr, u32 count)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		__ixp4xx_insl(port & PIO_MASK, vaddr, count);
+	else
+#ifndef	CONFIG_IXP4XX_INDIRECT_PCI
+		__raw_readsl(addr, vaddr, count);
+#else
+		__ixp4xx_readsl(addr, vaddr, count);
+#endif
+}
+
+static inline void
+__ixp4xx_iowrite8(u8 value, void __iomem *addr)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		__ixp4xx_outb(value, port & PIO_MASK);
+	else
+#ifndef CONFIG_IXP4XX_INDIRECT_PCI
+		__raw_writeb(value, port);
+#else
+		__ixp4xx_writeb(value, addr);
+#endif
+}
+
+static inline void
+__ixp4xx_iowrite8_rep(void __iomem *addr, const void *vaddr, u32 count)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		__ixp4xx_outsb(port & PIO_MASK, vaddr, count);
+	else
+#ifndef CONFIG_IXP4XX_INDIRECT_PCI
+		__raw_writesb(addr, vaddr, count);
+#else
+		__ixp4xx_writesb(addr, vaddr, count);
+#endif
+}
+
+static inline void
+__ixp4xx_iowrite16(u16 value, void __iomem *addr)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		__ixp4xx_outw(value, port & PIO_MASK);
+	else
+#ifndef CONFIG_IXP4XX_INDIRECT_PCI
+		__raw_writew(cpu_to_le16(value), addr);
+#else
+		__ixp4xx_writew(value, addr);
+#endif
+}
+
+static inline void
+__ixp4xx_iowrite16_rep(void __iomem *addr, const void *vaddr, u32 count)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		__ixp4xx_outsw(port & PIO_MASK, vaddr, count);
+	else
+#ifndef CONFIG_IXP4XX_INDIRECT_PCI
+		__raw_writesw(addr, vaddr, count);
+#else
+		__ixp4xx_writesw(addr, vaddr, count);
+#endif
+}
+
+static inline void
+__ixp4xx_iowrite32(u32 value, void __iomem *addr)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		__ixp4xx_outl(value, port & PIO_MASK);
+	else
+#ifndef CONFIG_IXP4XX_INDIRECT_PCI
+		__raw_writel((u32 __force)cpu_to_le32(value), addr);
+#else
+		__ixp4xx_writel(value, addr);
+#endif
+}
+
+static inline void
+__ixp4xx_iowrite32_rep(void __iomem *addr, const void *vaddr, u32 count)
+{
+	unsigned long port = (unsigned long __force)addr;
+	if (__is_io_address(port))
+		__ixp4xx_outsl(port & PIO_MASK, vaddr, count);
+	else
+#ifndef CONFIG_IXP4XX_INDIRECT_PCI
+		__raw_writesl(addr, vaddr, count);
+#else
+		__ixp4xx_writesl(addr, vaddr, count);
+#endif
+}
+
+#define	ioread8(p)			__ixp4xx_ioread8(p)
+#define	ioread16(p)			__ixp4xx_ioread16(p)
+#define	ioread32(p)			__ixp4xx_ioread32(p)
+
+#define	ioread8_rep(p, v, c)		__ixp4xx_ioread8_rep(p, v, c)
+#define	ioread16_rep(p, v, c)		__ixp4xx_ioread16_rep(p, v, c)
+#define	ioread32_rep(p, v, c)		__ixp4xx_ioread32_rep(p, v, c)
+
+#define	iowrite8(v,p)			__ixp4xx_iowrite8(v,p)
+#define	iowrite16(v,p)			__ixp4xx_iowrite16(v,p)
+#define	iowrite32(v,p)			__ixp4xx_iowrite32(v,p)
+
+#define	iowrite8_rep(p, v, c)		__ixp4xx_iowrite8_rep(p, v, c)
+#define	iowrite16_rep(p, v, c)		__ixp4xx_iowrite16_rep(p, v, c)
+#define	iowrite32_rep(p, v, c)		__ixp4xx_iowrite32_rep(p, v, c)
+
+#define	ioport_map(port, nr)		((void __iomem*)(port + PIO_OFFSET))
+#define	ioport_unmap(addr)
+#endif	// !CONFIG_PCI
+
+#endif	//  __ASM_ARM_ARCH_IO_H
+
