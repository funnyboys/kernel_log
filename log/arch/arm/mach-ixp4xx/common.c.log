commit e31cf2f4ca422ac9b14ecc4a1295b8977a20f812
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:33 2020 -0700

    mm: don't include asm/pgtable.h if linux/mm.h is already included
    
    Patch series "mm: consolidate definitions of page table accessors", v2.
    
    The low level page table accessors (pXY_index(), pXY_offset()) are
    duplicated across all architectures and sometimes more than once.  For
    instance, we have 31 definition of pgd_offset() for 25 supported
    architectures.
    
    Most of these definitions are actually identical and typically it boils
    down to, e.g.
    
    static inline unsigned long pmd_index(unsigned long address)
    {
            return (address >> PMD_SHIFT) & (PTRS_PER_PMD - 1);
    }
    
    static inline pmd_t *pmd_offset(pud_t *pud, unsigned long address)
    {
            return (pmd_t *)pud_page_vaddr(*pud) + pmd_index(address);
    }
    
    These definitions can be shared among 90% of the arches provided
    XYZ_SHIFT, PTRS_PER_XYZ and xyz_page_vaddr() are defined.
    
    For architectures that really need a custom version there is always
    possibility to override the generic version with the usual ifdefs magic.
    
    These patches introduce include/linux/pgtable.h that replaces
    include/asm-generic/pgtable.h and add the definitions of the page table
    accessors to the new header.
    
    This patch (of 12):
    
    The linux/mm.h header includes <asm/pgtable.h> to allow inlining of the
    functions involving page table manipulations, e.g.  pte_alloc() and
    pmd_alloc().  So, there is no point to explicitly include <asm/pgtable.h>
    in the files that include <linux/mm.h>.
    
    The include statements in such cases are remove with a simple loop:
    
            for f in $(git grep -l "include <linux/mm.h>") ; do
                    sed -i -e '/include <asm\/pgtable.h>/ d' $f
            done
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Mike Rapoport <rppt@kernel.org>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-1-rppt@kernel.org
    Link: http://lkml.kernel.org/r/20200514170327.31389-2-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 381f452de28d..184262d660ba 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -33,7 +33,6 @@
 #include <mach/hardware.h>
 #include <mach/io.h>
 #include <linux/uaccess.h>
-#include <asm/pgtable.h>
 #include <asm/page.h>
 #include <asm/exception.h>
 #include <asm/irq.h>

commit 8e7b65a6eb7a8876b389afb34176a41eb3d70238
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Mon May 6 08:31:09 2019 +0200

    ARM: ixp4xx: Remove duplicated include from common.c
    
    Remove duplicated include.
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index cc5f15679d29..381f452de28d 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -27,7 +27,6 @@
 #include <linux/cpu.h>
 #include <linux/pci.h>
 #include <linux/sched_clock.h>
-#include <linux/bitops.h>
 #include <linux/irqchip/irq-ixp4xx.h>
 #include <linux/platform_data/timer-ixp4xx.h>
 #include <mach/udc.h>

commit ecc133c6da60377c54a117841d630612d9f49964
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sun Feb 10 20:20:10 2019 +0100

    soc: ixp4xx: qmgr: Pass resources
    
    Instead of using hardcoded base address implicitly
    obtained through <linux/io.h>, pass the physical base
    for the QMGR block as a memory resource and remap
    it in the driver.
    
    Also pass the two IRQs as resources and obtain them
    in the driver.
    
    Use devm_* accessors and simplify the error path in the
    process. Drop memory region request as this is done by
    the devm_ioremap* functions.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 07c3cb312a92..cc5f15679d29 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -66,11 +66,6 @@ static struct map_desc ixp4xx_io_desc[] __initdata = {
 		.pfn		= __phys_to_pfn(IXP4XX_PCI_CFG_BASE_PHYS),
 		.length		= IXP4XX_PCI_CFG_REGION_SIZE,
 		.type		= MT_DEVICE
-	}, {	/* Queue Manager */
-		.virtual	= (unsigned long)IXP4XX_QMGR_BASE_VIRT,
-		.pfn		= __phys_to_pfn(IXP4XX_QMGR_BASE_PHYS),
-		.length		= IXP4XX_QMGR_REGION_SIZE,
-		.type		= MT_DEVICE
 	},
 };
 
@@ -176,9 +171,29 @@ static struct platform_device ixp4xx_npe_device = {
 	.resource       = ixp4xx_npe_resources,
 };
 
+static struct resource ixp4xx_qmgr_resources[] = {
+	{
+		.start = IXP4XX_QMGR_BASE_PHYS,
+		.end = IXP4XX_QMGR_BASE_PHYS + 0x3fff,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = IRQ_IXP4XX_QM1,
+		.end = IRQ_IXP4XX_QM1,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = IRQ_IXP4XX_QM2,
+		.end = IRQ_IXP4XX_QM2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
 static struct platform_device ixp4xx_qmgr_device = {
 	.name           = "ixp4xx-qmgr",
 	.id             = -1,
+	.num_resources  = ARRAY_SIZE(ixp4xx_qmgr_resources),
+	.resource       = ixp4xx_qmgr_resources,
 };
 
 static struct platform_device *ixp4xx_devices[] __initdata = {

commit 0b458d7b10f83eb34b84957e6cf47cee2a97bc49
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sun Feb 10 19:35:08 2019 +0100

    soc: ixp4xx: npe: Pass addresses as resources
    
    Instead of using hardcoded base addresses implicitly
    obtained through <linux/io.h>, pass the physical base
    for the three NPE blocks as memory resources and remap
    these in the driver.
    
    Drop the memory request region business, this will
    anyways be done by devm_* remapping functions.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index cdcd6d6b6d3d..07c3cb312a92 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -150,9 +150,30 @@ static struct platform_device ixp4xx_udc_device = {
 	},
 };
 
+static struct resource ixp4xx_npe_resources[] = {
+	{
+		.start = IXP4XX_NPEA_BASE_PHYS,
+		.end = IXP4XX_NPEA_BASE_PHYS + 0xfff,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = IXP4XX_NPEB_BASE_PHYS,
+		.end = IXP4XX_NPEB_BASE_PHYS + 0xfff,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = IXP4XX_NPEC_BASE_PHYS,
+		.end = IXP4XX_NPEC_BASE_PHYS + 0xfff,
+		.flags = IORESOURCE_MEM,
+	},
+
+};
+
 static struct platform_device ixp4xx_npe_device = {
 	.name           = "ixp4xx-npe",
 	.id             = -1,
+	.num_resources  = ARRAY_SIZE(ixp4xx_npe_resources),
+	.resource       = ixp4xx_npe_resources,
 };
 
 static struct platform_device ixp4xx_qmgr_device = {

commit 81bca32fcc75ededc51274d11f593a22a027236c
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sun Feb 10 17:14:10 2019 +0100

    ARM: ixp4xx: Turn the QMGR into a platform device
    
    Instead of registering everything related to the QMGR
    unconditionally in the module_init() call (which will
    never work with multiplatform) create a platform device
    and probe the QMGR like any other device.
    
    Put the device second in the list of devices added for
    the platform so it is there when the dependent network
    and crypto drivers probe later on.
    
    This probe() path will not be taken unconditionally on
    device tree boots, so remove the DT guard.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index e7789d06c39b..cdcd6d6b6d3d 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -155,8 +155,14 @@ static struct platform_device ixp4xx_npe_device = {
 	.id             = -1,
 };
 
+static struct platform_device ixp4xx_qmgr_device = {
+	.name           = "ixp4xx-qmgr",
+	.id             = -1,
+};
+
 static struct platform_device *ixp4xx_devices[] __initdata = {
 	&ixp4xx_npe_device,
+	&ixp4xx_qmgr_device,
 	&ixp4xx_gpio_device,
 	&ixp4xx_udc_device,
 };

commit bc4d7eafb7ad590f546b58c40cd7856990fbb303
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sun Feb 10 17:05:29 2019 +0100

    ARM: ixp4xx: Turn the NPE into a platform device
    
    Instead of registering everything related to the NPE
    unconditionally in the module_init() call (which will
    never work with multiplatform) create a platform device
    and probe the NPE like any other device.
    
    Put the device first in the list of devices added for
    the platform so it is there when the dependent network
    and crypto drivers probe later on.
    
    This probe() path will not be taken unconditionally on
    device tree boots, so remove the DT guard.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index fc4c9b21ca96..e7789d06c39b 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -150,7 +150,13 @@ static struct platform_device ixp4xx_udc_device = {
 	},
 };
 
+static struct platform_device ixp4xx_npe_device = {
+	.name           = "ixp4xx-npe",
+	.id             = -1,
+};
+
 static struct platform_device *ixp4xx_devices[] __initdata = {
+	&ixp4xx_npe_device,
 	&ixp4xx_gpio_device,
 	&ixp4xx_udc_device,
 };

commit 65af666713ffd275d6db3f086f80e070594c4732
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sat Jan 26 00:51:51 2019 +0100

    ARM: ixp4xx: Switch to use new timer driver
    
    This augments the IXP4xx to select and use the new
    timer driver in drivers/clocksource and removes the old
    code in the machine.
    
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 71683dfc48f9..fc4c9b21ca96 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -22,9 +22,6 @@
 #include <linux/serial_core.h>
 #include <linux/interrupt.h>
 #include <linux/bitops.h>
-#include <linux/time.h>
-#include <linux/clocksource.h>
-#include <linux/clockchips.h>
 #include <linux/io.h>
 #include <linux/export.h>
 #include <linux/cpu.h>
@@ -32,6 +29,7 @@
 #include <linux/sched_clock.h>
 #include <linux/bitops.h>
 #include <linux/irqchip/irq-ixp4xx.h>
+#include <linux/platform_data/timer-ixp4xx.h>
 #include <mach/udc.h>
 #include <mach/hardware.h>
 #include <mach/io.h>
@@ -49,19 +47,6 @@
 
 #define IXP4XX_TIMER_FREQ 66666000
 
-/*
- * The timer register doesn't allow to specify the two least significant bits of
- * the timeout value and assumes them being zero. So make sure IXP4XX_LATCH is
- * the best value with the two least significant bits unset.
- */
-#define IXP4XX_LATCH DIV_ROUND_CLOSEST(IXP4XX_TIMER_FREQ, \
-				       (IXP4XX_OST_RELOAD_MASK + 1) * HZ) * \
-			(IXP4XX_OST_RELOAD_MASK + 1)
-
-static void __init ixp4xx_clocksource_init(void);
-static void __init ixp4xx_clockevent_init(void);
-static struct clock_event_device clockevent_ixp4xx;
-
 /*************************************************************************
  * IXP4xx chipset I/O mapping
  *************************************************************************/
@@ -106,37 +91,11 @@ void __init ixp4xx_init_irq(void)
 			(cpu_is_ixp46x() || cpu_is_ixp43x()));
 }
 
-/*************************************************************************
- * IXP4xx timer tick
- * We use OS timer1 on the CPU for the timer tick and the timestamp 
- * counter as a source of real clock ticks to account for missed jiffies.
- *************************************************************************/
-
-static irqreturn_t ixp4xx_timer_interrupt(int irq, void *dev_id)
-{
-	struct clock_event_device *evt = dev_id;
-
-	/* Clear Pending Interrupt by writing '1' to it */
-	*IXP4XX_OSST = IXP4XX_OSST_TIMER_1_PEND;
-
-	evt->event_handler(evt);
-
-	return IRQ_HANDLED;
-}
-
 void __init ixp4xx_timer_init(void)
 {
-	/* Reset/disable counter */
-	*IXP4XX_OSRT1 = 0;
-
-	/* Clear Pending Interrupt by writing '1' to it */
-	*IXP4XX_OSST = IXP4XX_OSST_TIMER_1_PEND;
-
-	/* Reset time-stamp counter */
-	*IXP4XX_OSTS = 0;
-
-	ixp4xx_clocksource_init();
-	ixp4xx_clockevent_init();
+	return ixp4xx_timer_setup(IXP4XX_TIMER_BASE_PHYS,
+				  IRQ_IXP4XX_TIMER1,
+				  IXP4XX_TIMER_FREQ);
 }
 
 static struct pxa2xx_udc_mach_info ixp4xx_udc_info;
@@ -251,112 +210,8 @@ void __init ixp4xx_sys_init(void)
 			ixp4xx_exp_bus_size >> 20);
 }
 
-/*
- * sched_clock()
- */
-static u64 notrace ixp4xx_read_sched_clock(void)
-{
-	return *IXP4XX_OSTS;
-}
-
-/*
- * clocksource
- */
-
-static u64 ixp4xx_clocksource_read(struct clocksource *c)
-{
-	return *IXP4XX_OSTS;
-}
-
 unsigned long ixp4xx_timer_freq = IXP4XX_TIMER_FREQ;
 EXPORT_SYMBOL(ixp4xx_timer_freq);
-static void __init ixp4xx_clocksource_init(void)
-{
-	sched_clock_register(ixp4xx_read_sched_clock, 32, ixp4xx_timer_freq);
-
-	clocksource_mmio_init(NULL, "OSTS", ixp4xx_timer_freq, 200, 32,
-			ixp4xx_clocksource_read);
-}
-
-/*
- * clockevents
- */
-static int ixp4xx_set_next_event(unsigned long evt,
-				 struct clock_event_device *unused)
-{
-	unsigned long opts = *IXP4XX_OSRT1 & IXP4XX_OST_RELOAD_MASK;
-
-	*IXP4XX_OSRT1 = (evt & ~IXP4XX_OST_RELOAD_MASK) | opts;
-
-	return 0;
-}
-
-static int ixp4xx_shutdown(struct clock_event_device *evt)
-{
-	unsigned long opts = *IXP4XX_OSRT1 & IXP4XX_OST_RELOAD_MASK;
-	unsigned long osrt = *IXP4XX_OSRT1 & ~IXP4XX_OST_RELOAD_MASK;
-
-	opts &= ~IXP4XX_OST_ENABLE;
-	*IXP4XX_OSRT1 = osrt | opts;
-	return 0;
-}
-
-static int ixp4xx_set_oneshot(struct clock_event_device *evt)
-{
-	unsigned long opts = IXP4XX_OST_ENABLE | IXP4XX_OST_ONE_SHOT;
-	unsigned long osrt = 0;
-
-	/* period set by 'set next_event' */
-	*IXP4XX_OSRT1 = osrt | opts;
-	return 0;
-}
-
-static int ixp4xx_set_periodic(struct clock_event_device *evt)
-{
-	unsigned long opts = IXP4XX_OST_ENABLE;
-	unsigned long osrt = IXP4XX_LATCH & ~IXP4XX_OST_RELOAD_MASK;
-
-	*IXP4XX_OSRT1 = osrt | opts;
-	return 0;
-}
-
-static int ixp4xx_resume(struct clock_event_device *evt)
-{
-	unsigned long opts = *IXP4XX_OSRT1 & IXP4XX_OST_RELOAD_MASK;
-	unsigned long osrt = *IXP4XX_OSRT1 & ~IXP4XX_OST_RELOAD_MASK;
-
-	opts |= IXP4XX_OST_ENABLE;
-	*IXP4XX_OSRT1 = osrt | opts;
-	return 0;
-}
-
-static struct clock_event_device clockevent_ixp4xx = {
-	.name			= "ixp4xx timer1",
-	.features		= CLOCK_EVT_FEAT_PERIODIC |
-				  CLOCK_EVT_FEAT_ONESHOT,
-	.rating			= 200,
-	.set_state_shutdown	= ixp4xx_shutdown,
-	.set_state_periodic	= ixp4xx_set_periodic,
-	.set_state_oneshot	= ixp4xx_set_oneshot,
-	.tick_resume		= ixp4xx_resume,
-	.set_next_event		= ixp4xx_set_next_event,
-};
-
-static void __init ixp4xx_clockevent_init(void)
-{
-	int ret;
-
-	clockevent_ixp4xx.cpumask = cpumask_of(0);
-	clockevent_ixp4xx.irq = IRQ_IXP4XX_TIMER1;
-	ret = request_irq(IRQ_IXP4XX_TIMER1, ixp4xx_timer_interrupt,
-			  IRQF_TIMER, "IXP4XX-TIMER1", &clockevent_ixp4xx);
-	if (ret) {
-		pr_crit("no timer IRQ\n");
-		return;
-	}
-	clockevents_config_and_register(&clockevent_ixp4xx, IXP4XX_TIMER_FREQ,
-					0xf, 0xfffffffe);
-}
 
 void ixp4xx_restart(enum reboot_mode mode, const char *cmd)
 {

commit 55ec465e733e60d2d524bd42ff19b66ed21f01df
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Jan 25 22:58:39 2019 +0100

    ARM: ixp4xx: Switch to use new IRQ+GPIO drivers
    
    This deletes the old irq+gpiochip combo from the IXP4xx
    machine and switches it over to use the new drivers merged
    in respective subsystem.
    
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index aa8fd248c125..71683dfc48f9 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -27,11 +27,11 @@
 #include <linux/clockchips.h>
 #include <linux/io.h>
 #include <linux/export.h>
-#include <linux/gpio/driver.h>
 #include <linux/cpu.h>
 #include <linux/pci.h>
 #include <linux/sched_clock.h>
 #include <linux/bitops.h>
+#include <linux/irqchip/irq-ixp4xx.h>
 #include <mach/udc.h>
 #include <mach/hardware.h>
 #include <mach/io.h>
@@ -58,7 +58,6 @@
 				       (IXP4XX_OST_RELOAD_MASK + 1) * HZ) * \
 			(IXP4XX_OST_RELOAD_MASK + 1)
 
-static struct irq_domain *ixp4xx_irqdomain;
 static void __init ixp4xx_clocksource_init(void);
 static void __init ixp4xx_clockevent_init(void);
 static struct clock_event_device clockevent_ixp4xx;
@@ -95,266 +94,18 @@ void __init ixp4xx_map_io(void)
   	iotable_init(ixp4xx_io_desc, ARRAY_SIZE(ixp4xx_io_desc));
 }
 
-/*
- * GPIO-functions
- */
-/*
- * The following converted to the real HW bits the gpio_line_config
- */
-/* GPIO pin types */
-#define IXP4XX_GPIO_OUT 		0x1
-#define IXP4XX_GPIO_IN  		0x2
-
-/* GPIO signal types */
-#define IXP4XX_GPIO_LOW			0
-#define IXP4XX_GPIO_HIGH		1
-
-/* GPIO Clocks */
-#define IXP4XX_GPIO_CLK_0		14
-#define IXP4XX_GPIO_CLK_1		15
-
-static void gpio_line_config(u8 line, u32 direction)
-{
-	if (direction == IXP4XX_GPIO_IN)
-		*IXP4XX_GPIO_GPOER |= (1 << line);
-	else
-		*IXP4XX_GPIO_GPOER &= ~(1 << line);
-}
-
-static void gpio_line_get(u8 line, int *value)
-{
-	*value = (*IXP4XX_GPIO_GPINR >> line) & 0x1;
-}
-
-static void gpio_line_set(u8 line, int value)
-{
-	if (value == IXP4XX_GPIO_HIGH)
-	    *IXP4XX_GPIO_GPOUTR |= (1 << line);
-	else if (value == IXP4XX_GPIO_LOW)
-	    *IXP4XX_GPIO_GPOUTR &= ~(1 << line);
-}
-
-/*************************************************************************
- * IXP4xx chipset IRQ handling
- *
- * TODO: GPIO IRQs should be marked invalid until the user of the IRQ
- *       (be it PCI or something else) configures that GPIO line
- *       as an IRQ.
- **************************************************************************/
-enum ixp4xx_irq_type {
-	IXP4XX_IRQ_LEVEL, IXP4XX_IRQ_EDGE
-};
-
-/* Each bit represents an IRQ: 1: edge-triggered, 0: level triggered */
-static unsigned long long ixp4xx_irq_edge = 0;
-
-/*
- * IRQ -> GPIO mapping table
- */
-static signed char irq2gpio[32] = {
-	-1, -1, -1, -1, -1, -1,  0,  1,
-	-1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1,  2,  3,  4,  5,  6,
-	 7,  8,  9, 10, 11, 12, -1, -1,
-};
-
-static int ixp4xx_gpio_to_irq(struct gpio_chip *chip, unsigned gpio)
-{
-	int irq;
-
-	for (irq = 0; irq < 32; irq++) {
-		if (irq2gpio[irq] == gpio)
-			return irq;
-	}
-	return -EINVAL;
-}
-
-static int ixp4xx_set_irq_type(struct irq_data *d, unsigned int type)
-{
-	int line = irq2gpio[d->hwirq];
-	u32 int_style;
-	enum ixp4xx_irq_type irq_type;
-	volatile u32 *int_reg;
-
-	/*
-	 * Only for GPIO IRQs
-	 * all other IRQs are simply active low
-	 */
-	if (line < 0)
-		return 0;
-
-	switch (type){
-	case IRQ_TYPE_EDGE_BOTH:
-		int_style = IXP4XX_GPIO_STYLE_TRANSITIONAL;
-		irq_type = IXP4XX_IRQ_EDGE;
-		break;
-	case IRQ_TYPE_EDGE_RISING:
-		int_style = IXP4XX_GPIO_STYLE_RISING_EDGE;
-		irq_type = IXP4XX_IRQ_EDGE;
-		break;
-	case IRQ_TYPE_EDGE_FALLING:
-		int_style = IXP4XX_GPIO_STYLE_FALLING_EDGE;
-		irq_type = IXP4XX_IRQ_EDGE;
-		break;
-	case IRQ_TYPE_LEVEL_HIGH:
-		int_style = IXP4XX_GPIO_STYLE_ACTIVE_HIGH;
-		irq_type = IXP4XX_IRQ_LEVEL;
-		break;
-	case IRQ_TYPE_LEVEL_LOW:
-		int_style = IXP4XX_GPIO_STYLE_ACTIVE_LOW;
-		irq_type = IXP4XX_IRQ_LEVEL;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	if (irq_type == IXP4XX_IRQ_EDGE)
-		ixp4xx_irq_edge |= (1 << d->hwirq);
-	else
-		ixp4xx_irq_edge &= ~(1 << d->hwirq);
-
-	if (line >= 8) {	/* pins 8-15 */
-		line -= 8;
-		int_reg = IXP4XX_GPIO_GPIT2R;
-	} else {		/* pins 0-7 */
-		int_reg = IXP4XX_GPIO_GPIT1R;
-	}
-
-	/* Clear the style for the appropriate pin */
-	*int_reg &= ~(IXP4XX_GPIO_STYLE_CLEAR <<
-	    		(line * IXP4XX_GPIO_STYLE_SIZE));
-
-	*IXP4XX_GPIO_GPISR = (1 << line);
-
-	/* Set the new style */
-	*int_reg |= (int_style << (line * IXP4XX_GPIO_STYLE_SIZE));
-
-	/* Configure the line as an input */
-	gpio_line_config(irq2gpio[d->hwirq], IXP4XX_GPIO_IN);
-
-	return 0;
-}
-
-static void ixp4xx_irq_mask(struct irq_data *d)
-{
-	if ((cpu_is_ixp46x() || cpu_is_ixp43x()) && d->hwirq >= 32)
-		*IXP4XX_ICMR2 &= ~(1 << (d->hwirq - 32));
-	else
-		*IXP4XX_ICMR &= ~(1 << d->hwirq);
-}
-
-static void ixp4xx_irq_ack(struct irq_data *d)
-{
-	int line = (d->hwirq < 32) ? irq2gpio[d->hwirq] : -1;
-
-	if (line >= 0)
-		*IXP4XX_GPIO_GPISR = (1 << line);
-}
-
-/*
- * Level triggered interrupts on GPIO lines can only be cleared when the
- * interrupt condition disappears.
- */
-static void ixp4xx_irq_unmask(struct irq_data *d)
-{
-	if (!(ixp4xx_irq_edge & (1 << d->hwirq)))
-		ixp4xx_irq_ack(d);
-
-	if ((cpu_is_ixp46x() || cpu_is_ixp43x()) && d->hwirq >= 32)
-		*IXP4XX_ICMR2 |= (1 << (d->hwirq - 32));
-	else
-		*IXP4XX_ICMR |= (1 << d->hwirq);
-}
-
-static struct irq_chip ixp4xx_irq_chip = {
-	.name		= "IXP4xx",
-	.irq_ack	= ixp4xx_irq_ack,
-	.irq_mask	= ixp4xx_irq_mask,
-	.irq_unmask	= ixp4xx_irq_unmask,
-	.irq_set_type	= ixp4xx_set_irq_type,
-};
-
-asmlinkage void __exception_irq_entry ixp4xx_handle_irq(struct pt_regs *regs)
-{
-	unsigned long status;
-	int i;
-
-	status = *IXP4XX_ICIP;
-
-	for_each_set_bit(i, &status, 32)
-		handle_domain_irq(ixp4xx_irqdomain, i, regs);
-
-	/*
-	 * IXP465/IXP435 has an upper IRQ status register
-	 */
-	if ((cpu_is_ixp46x() || cpu_is_ixp43x())) {
-		status = *IXP4XX_ICIP2;
-		for_each_set_bit(i, &status, 32)
-			handle_domain_irq(ixp4xx_irqdomain, i + 32, regs);
-	}
-}
-
-static int ixp4xx_irqdomain_map(struct irq_domain *d, unsigned int irq,
-				irq_hw_number_t hwirq)
-{
-	irq_set_chip_data(irq, &ixp4xx_irq_chip);
-	irq_set_chip_and_handler(irq, &ixp4xx_irq_chip, handle_level_irq);
-	irq_set_probe(irq);
-
-	return 0;
-}
-
-static void ixp4xx_irqdomain_unmap(struct irq_domain *d, unsigned int irq)
-{
-	irq_set_chip_and_handler(irq, NULL, NULL);
-	irq_set_chip_data(irq, NULL);
-}
-
-static const struct irq_domain_ops ixp4xx_irqdomain_ops = {
-	.map = ixp4xx_irqdomain_map,
-	.unmap = ixp4xx_irqdomain_unmap,
-};
-
 void __init ixp4xx_init_irq(void)
 {
-	int nr_irqs;
-
 	/*
 	 * ixp4xx does not implement the XScale PWRMODE register
 	 * so it must not call cpu_do_idle().
 	 */
 	cpu_idle_poll_ctrl(true);
 
-	/* Route all sources to IRQ instead of FIQ */
-	*IXP4XX_ICLR = 0x0;
-
-	/* Disable all interrupt */
-	*IXP4XX_ICMR = 0x0; 
-
-	if (cpu_is_ixp46x() || cpu_is_ixp43x()) {
-		/* Route upper 32 sources to IRQ instead of FIQ */
-		*IXP4XX_ICLR2 = 0x00;
-
-		/* Disable upper 32 interrupts */
-		*IXP4XX_ICMR2 = 0x00;
-
-		nr_irqs = 64;
-	} else {
-		nr_irqs = 32;
-	}
-
-	ixp4xx_irqdomain = irq_domain_add_simple(NULL, nr_irqs, IRQ_IXP4XX_BASE,
-						 &ixp4xx_irqdomain_ops,
-						 NULL);
-	if (!ixp4xx_irqdomain) {
-		pr_crit("can not add primary irqdomain\n");
-		return;
-	}
-
-	set_handle_irq(ixp4xx_handle_irq);
+	ixp4xx_irq_init(IXP4XX_INTC_BASE_PHYS,
+			(cpu_is_ixp46x() || cpu_is_ixp43x()));
 }
 
-
 /*************************************************************************
  * IXP4xx timer tick
  * We use OS timer1 on the CPU for the timer tick and the timestamp 
@@ -408,6 +159,24 @@ static struct resource ixp4xx_udc_resources[] = {
 	},
 };
 
+static struct resource ixp4xx_gpio_resource[] = {
+	{
+		.start = IXP4XX_GPIO_BASE_PHYS,
+		.end = IXP4XX_GPIO_BASE_PHYS + 0xfff,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device ixp4xx_gpio_device = {
+	.name           = "ixp4xx-gpio",
+	.id             = -1,
+	.dev = {
+		.coherent_dma_mask      = DMA_BIT_MASK(32),
+	},
+	.resource = ixp4xx_gpio_resource,
+	.num_resources  = ARRAY_SIZE(ixp4xx_gpio_resource),
+};
+
 /*
  * USB device controller. The IXP4xx uses the same controller as PXA25X,
  * so we just use the same device.
@@ -423,6 +192,7 @@ static struct platform_device ixp4xx_udc_device = {
 };
 
 static struct platform_device *ixp4xx_devices[] __initdata = {
+	&ixp4xx_gpio_device,
 	&ixp4xx_udc_device,
 };
 
@@ -457,56 +227,12 @@ static struct platform_device *ixp46x_devices[] __initdata = {
 unsigned long ixp4xx_exp_bus_size;
 EXPORT_SYMBOL(ixp4xx_exp_bus_size);
 
-static int ixp4xx_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)
-{
-	gpio_line_config(gpio, IXP4XX_GPIO_IN);
-
-	return 0;
-}
-
-static int ixp4xx_gpio_direction_output(struct gpio_chip *chip, unsigned gpio,
-					int level)
-{
-	gpio_line_set(gpio, level);
-	gpio_line_config(gpio, IXP4XX_GPIO_OUT);
-
-	return 0;
-}
-
-static int ixp4xx_gpio_get_value(struct gpio_chip *chip, unsigned gpio)
-{
-	int value;
-
-	gpio_line_get(gpio, &value);
-
-	return value;
-}
-
-static void ixp4xx_gpio_set_value(struct gpio_chip *chip, unsigned gpio,
-				  int value)
-{
-	gpio_line_set(gpio, value);
-}
-
-static struct gpio_chip ixp4xx_gpio_chip = {
-	.label			= "IXP4XX_GPIO_CHIP",
-	.direction_input	= ixp4xx_gpio_direction_input,
-	.direction_output	= ixp4xx_gpio_direction_output,
-	.get			= ixp4xx_gpio_get_value,
-	.set			= ixp4xx_gpio_set_value,
-	.to_irq			= ixp4xx_gpio_to_irq,
-	.base			= 0,
-	.ngpio			= 16,
-};
-
 void __init ixp4xx_sys_init(void)
 {
 	ixp4xx_exp_bus_size = SZ_16M;
 
 	platform_add_devices(ixp4xx_devices, ARRAY_SIZE(ixp4xx_devices));
 
-	gpiochip_add_data(&ixp4xx_gpio_chip, NULL);
-
 	if (cpu_is_ixp46x()) {
 		int region;
 

commit dc8ef8cd3a05632bf15ce8714d6b84ece2836fe9
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sat Dec 29 15:47:52 2018 +0100

    ARM: ixp4xx: Convert to SPARSE_IRQ
    
    This localizes the <mach/irqs.h> header to the mach-ixp4xx
    directory, removes NR_IRQS and switches IXP4xx over to using
    SPARSE_IRQ.
    
    This is a prerequisite for DT support.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 58a1b851425e..aa8fd248c125 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -45,6 +45,8 @@
 #include <asm/mach/irq.h>
 #include <asm/mach/time.h>
 
+#include "irqs.h"
+
 #define IXP4XX_TIMER_FREQ 66666000
 
 /*

commit 98ac0cc270b717c49a49787fe7c42041123290bb
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sat Dec 29 14:30:27 2018 +0100

    ARM: ixp4xx: Convert to MULTI_IRQ_HANDLER
    
    This rewrites the IXP4xx to use MULTI_IRQ_HANDLER and
    create an irqdomain for the irqchip in the platform. We
    convert the timer to request the interrupt like any other
    driver in the process.
    
    We bump all IRQs to 16+offset to avoid using IRQ 0 and
    set NR_IRQS to 512 (the default for most systems).
    This conveniently fits with the first 16 IRQs being
    pre-allocated when using SPARSE_IRQ.
    
    This is a prerequisite for SPARSE_IRQ and DT boot.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 846e033c56fa..58a1b851425e 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -31,12 +31,14 @@
 #include <linux/cpu.h>
 #include <linux/pci.h>
 #include <linux/sched_clock.h>
+#include <linux/bitops.h>
 #include <mach/udc.h>
 #include <mach/hardware.h>
 #include <mach/io.h>
 #include <linux/uaccess.h>
 #include <asm/pgtable.h>
 #include <asm/page.h>
+#include <asm/exception.h>
 #include <asm/irq.h>
 #include <asm/system_misc.h>
 #include <asm/mach/map.h>
@@ -54,6 +56,7 @@
 				       (IXP4XX_OST_RELOAD_MASK + 1) * HZ) * \
 			(IXP4XX_OST_RELOAD_MASK + 1)
 
+static struct irq_domain *ixp4xx_irqdomain;
 static void __init ixp4xx_clocksource_init(void);
 static void __init ixp4xx_clockevent_init(void);
 static struct clock_event_device clockevent_ixp4xx;
@@ -166,16 +169,17 @@ static int ixp4xx_gpio_to_irq(struct gpio_chip *chip, unsigned gpio)
 
 static int ixp4xx_set_irq_type(struct irq_data *d, unsigned int type)
 {
-	int line = irq2gpio[d->irq];
+	int line = irq2gpio[d->hwirq];
 	u32 int_style;
 	enum ixp4xx_irq_type irq_type;
 	volatile u32 *int_reg;
 
 	/*
 	 * Only for GPIO IRQs
+	 * all other IRQs are simply active low
 	 */
 	if (line < 0)
-		return -EINVAL;
+		return 0;
 
 	switch (type){
 	case IRQ_TYPE_EDGE_BOTH:
@@ -203,9 +207,9 @@ static int ixp4xx_set_irq_type(struct irq_data *d, unsigned int type)
 	}
 
 	if (irq_type == IXP4XX_IRQ_EDGE)
-		ixp4xx_irq_edge |= (1 << d->irq);
+		ixp4xx_irq_edge |= (1 << d->hwirq);
 	else
-		ixp4xx_irq_edge &= ~(1 << d->irq);
+		ixp4xx_irq_edge &= ~(1 << d->hwirq);
 
 	if (line >= 8) {	/* pins 8-15 */
 		line -= 8;
@@ -224,22 +228,22 @@ static int ixp4xx_set_irq_type(struct irq_data *d, unsigned int type)
 	*int_reg |= (int_style << (line * IXP4XX_GPIO_STYLE_SIZE));
 
 	/* Configure the line as an input */
-	gpio_line_config(irq2gpio[d->irq], IXP4XX_GPIO_IN);
+	gpio_line_config(irq2gpio[d->hwirq], IXP4XX_GPIO_IN);
 
 	return 0;
 }
 
 static void ixp4xx_irq_mask(struct irq_data *d)
 {
-	if ((cpu_is_ixp46x() || cpu_is_ixp43x()) && d->irq >= 32)
-		*IXP4XX_ICMR2 &= ~(1 << (d->irq - 32));
+	if ((cpu_is_ixp46x() || cpu_is_ixp43x()) && d->hwirq >= 32)
+		*IXP4XX_ICMR2 &= ~(1 << (d->hwirq - 32));
 	else
-		*IXP4XX_ICMR &= ~(1 << d->irq);
+		*IXP4XX_ICMR &= ~(1 << d->hwirq);
 }
 
 static void ixp4xx_irq_ack(struct irq_data *d)
 {
-	int line = (d->irq < 32) ? irq2gpio[d->irq] : -1;
+	int line = (d->hwirq < 32) ? irq2gpio[d->hwirq] : -1;
 
 	if (line >= 0)
 		*IXP4XX_GPIO_GPISR = (1 << line);
@@ -251,13 +255,13 @@ static void ixp4xx_irq_ack(struct irq_data *d)
  */
 static void ixp4xx_irq_unmask(struct irq_data *d)
 {
-	if (!(ixp4xx_irq_edge & (1 << d->irq)))
+	if (!(ixp4xx_irq_edge & (1 << d->hwirq)))
 		ixp4xx_irq_ack(d);
 
-	if ((cpu_is_ixp46x() || cpu_is_ixp43x()) && d->irq >= 32)
-		*IXP4XX_ICMR2 |= (1 << (d->irq - 32));
+	if ((cpu_is_ixp46x() || cpu_is_ixp43x()) && d->hwirq >= 32)
+		*IXP4XX_ICMR2 |= (1 << (d->hwirq - 32));
 	else
-		*IXP4XX_ICMR |= (1 << d->irq);
+		*IXP4XX_ICMR |= (1 << d->hwirq);
 }
 
 static struct irq_chip ixp4xx_irq_chip = {
@@ -268,9 +272,50 @@ static struct irq_chip ixp4xx_irq_chip = {
 	.irq_set_type	= ixp4xx_set_irq_type,
 };
 
+asmlinkage void __exception_irq_entry ixp4xx_handle_irq(struct pt_regs *regs)
+{
+	unsigned long status;
+	int i;
+
+	status = *IXP4XX_ICIP;
+
+	for_each_set_bit(i, &status, 32)
+		handle_domain_irq(ixp4xx_irqdomain, i, regs);
+
+	/*
+	 * IXP465/IXP435 has an upper IRQ status register
+	 */
+	if ((cpu_is_ixp46x() || cpu_is_ixp43x())) {
+		status = *IXP4XX_ICIP2;
+		for_each_set_bit(i, &status, 32)
+			handle_domain_irq(ixp4xx_irqdomain, i + 32, regs);
+	}
+}
+
+static int ixp4xx_irqdomain_map(struct irq_domain *d, unsigned int irq,
+				irq_hw_number_t hwirq)
+{
+	irq_set_chip_data(irq, &ixp4xx_irq_chip);
+	irq_set_chip_and_handler(irq, &ixp4xx_irq_chip, handle_level_irq);
+	irq_set_probe(irq);
+
+	return 0;
+}
+
+static void ixp4xx_irqdomain_unmap(struct irq_domain *d, unsigned int irq)
+{
+	irq_set_chip_and_handler(irq, NULL, NULL);
+	irq_set_chip_data(irq, NULL);
+}
+
+static const struct irq_domain_ops ixp4xx_irqdomain_ops = {
+	.map = ixp4xx_irqdomain_map,
+	.unmap = ixp4xx_irqdomain_unmap,
+};
+
 void __init ixp4xx_init_irq(void)
 {
-	int i = 0;
+	int nr_irqs;
 
 	/*
 	 * ixp4xx does not implement the XScale PWRMODE register
@@ -290,14 +335,21 @@ void __init ixp4xx_init_irq(void)
 
 		/* Disable upper 32 interrupts */
 		*IXP4XX_ICMR2 = 0x00;
+
+		nr_irqs = 64;
+	} else {
+		nr_irqs = 32;
 	}
 
-        /* Default to all level triggered */
-	for(i = 0; i < NR_IRQS; i++) {
-		irq_set_chip_and_handler(i, &ixp4xx_irq_chip,
-					 handle_level_irq);
-		irq_clear_status_flags(i, IRQ_NOREQUEST);
+	ixp4xx_irqdomain = irq_domain_add_simple(NULL, nr_irqs, IRQ_IXP4XX_BASE,
+						 &ixp4xx_irqdomain_ops,
+						 NULL);
+	if (!ixp4xx_irqdomain) {
+		pr_crit("can not add primary irqdomain\n");
+		return;
 	}
+
+	set_handle_irq(ixp4xx_handle_irq);
 }
 
 
@@ -319,13 +371,6 @@ static irqreturn_t ixp4xx_timer_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static struct irqaction ixp4xx_timer_irq = {
-	.name		= "timer1",
-	.flags		= IRQF_TIMER | IRQF_IRQPOLL,
-	.handler	= ixp4xx_timer_interrupt,
-	.dev_id		= &clockevent_ixp4xx,
-};
-
 void __init ixp4xx_timer_init(void)
 {
 	/* Reset/disable counter */
@@ -337,9 +382,6 @@ void __init ixp4xx_timer_init(void)
 	/* Reset time-stamp counter */
 	*IXP4XX_OSTS = 0;
 
-	/* Connect the interrupt handler and enable the interrupt */
-	setup_irq(IRQ_IXP4XX_TIMER1, &ixp4xx_timer_irq);
-
 	ixp4xx_clocksource_init();
 	ixp4xx_clockevent_init();
 }
@@ -574,7 +616,16 @@ static struct clock_event_device clockevent_ixp4xx = {
 
 static void __init ixp4xx_clockevent_init(void)
 {
+	int ret;
+
 	clockevent_ixp4xx.cpumask = cpumask_of(0);
+	clockevent_ixp4xx.irq = IRQ_IXP4XX_TIMER1;
+	ret = request_irq(IRQ_IXP4XX_TIMER1, ixp4xx_timer_interrupt,
+			  IRQF_TIMER, "IXP4XX-TIMER1", &clockevent_ixp4xx);
+	if (ret) {
+		pr_crit("no timer IRQ\n");
+		return;
+	}
 	clockevents_config_and_register(&clockevent_ixp4xx, IXP4XX_TIMER_FREQ,
 					0xf, 0xfffffffe);
 }

commit a5a1d1c2914b5316924c7893eb683a5420ebd3be
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Dec 21 20:32:01 2016 +0100

    clocksource: Use a plain u64 instead of cycle_t
    
    There is no point in having an extra type for extra confusion. u64 is
    unambiguous.
    
    Conversion was done with the following coccinelle script:
    
    @rem@
    @@
    -typedef u64 cycle_t;
    
    @fix@
    typedef cycle_t;
    @@
    -cycle_t
    +u64
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: John Stultz <john.stultz@linaro.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 0f08f611c1a6..846e033c56fa 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -493,7 +493,7 @@ static u64 notrace ixp4xx_read_sched_clock(void)
  * clocksource
  */
 
-static cycle_t ixp4xx_clocksource_read(struct clocksource *c)
+static u64 ixp4xx_clocksource_read(struct clocksource *c)
 {
 	return *IXP4XX_OSTS;
 }

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 26874f608ca9..0f08f611c1a6 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -34,7 +34,7 @@
 #include <mach/udc.h>
 #include <mach/hardware.h>
 #include <mach/io.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <asm/pgtable.h>
 #include <asm/page.h>
 #include <asm/irq.h>

commit 010b16d4549c653f901e97de3c69e22b1e10bada
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Dec 8 11:08:52 2015 +0100

    ARM: ixp4xx: switch to gpiochip_add_data()
    
    We're planning to remove the gpiochip_add() function to swith
    to gpiochip_add_data() with NULL for data argument.
    
    Cc: arm@kernel.org
    Acked-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 1cb6f2f02880..26874f608ca9 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -27,7 +27,7 @@
 #include <linux/clockchips.h>
 #include <linux/io.h>
 #include <linux/export.h>
-#include <linux/gpio.h>
+#include <linux/gpio/driver.h>
 #include <linux/cpu.h>
 #include <linux/pci.h>
 #include <linux/sched_clock.h>
@@ -461,7 +461,7 @@ void __init ixp4xx_sys_init(void)
 
 	platform_add_devices(ixp4xx_devices, ARRAY_SIZE(ixp4xx_devices));
 
-	gpiochip_add(&ixp4xx_gpio_chip);
+	gpiochip_add_data(&ixp4xx_gpio_chip, NULL);
 
 	if (cpu_is_ixp46x()) {
 		int region;

commit e8d36d5dbb6a6ec4f5222f8775d664ec29d5527d
Author: Rob Herring <robh@kernel.org>
Date:   Mon Jul 27 15:55:13 2015 -0500

    ARM: kill off set_irq_flags usage
    
    set_irq_flags is ARM specific with custom flags which have genirq
    equivalents. Convert drivers to use the genirq interfaces directly, so we
    can kill off set_irq_flags. The translation of flags is as follows:
    
    IRQF_VALID -> !IRQ_NOREQUEST
    IRQF_PROBE -> !IRQ_NOPROBE
    IRQF_NOAUTOEN -> IRQ_NOAUTOEN
    
    For IRQs managed by an irqdomain, the irqdomain core code handles clearing
    and setting IRQ_NOREQUEST already, so there is no need to do this in
    .map() functions and we can simply remove the set_irq_flags calls. Some
    users also modify IRQ_NOPROBE and this has been maintained although it
    is not clear that is really needed. There appears to be a great deal of
    blind copy and paste of this code.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Sekhar Nori <nsekhar@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Gregory Clement <gregory.clement@free-electrons.com>
    Acked-by: Hans Ulli Kroll <ulli.kroll@googlemail.com>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Acked-by: Krzysztof Halasa <khalasa@piap.pl>
    Cc: Greg Ungerer <gerg@uclinux.org>
    Cc: Roland Stigge <stigge@antcom.de>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Daniel Mack <daniel@zonque.org>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: Robert Jarzmik <robert.jarzmik@free.fr>
    Cc: Simtec Linux Team <linux@simtec.co.uk>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Acked-by: Wan ZongShun <mcuos.com@gmail.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-omap@vger.kernel.org
    Cc: linux-samsung-soc@vger.kernel.org
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 70773b948e7e..1cb6f2f02880 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -296,7 +296,7 @@ void __init ixp4xx_init_irq(void)
 	for(i = 0; i < NR_IRQS; i++) {
 		irq_set_chip_and_handler(i, &ixp4xx_irq_chip,
 					 handle_level_irq);
-		set_irq_flags(i, IRQF_VALID);
+		irq_clear_status_flags(i, IRQ_NOREQUEST);
 	}
 }
 

commit cea50eeef15c8498181c4a1ff804a7cdef29aebb
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/ixp4xx/timer: Migrate to new 'set-state' interface
    
    Migrate ixp4xx driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    NOTE: ixp4xx_set_{oneshot|periodic} don't perform read operation on
    'IXP4XX_OSRT1' register anymore.
    
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Acked-by: Krzysztof Hałasa <khalasa@piap.pl>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 8537d4c41e34..70773b948e7e 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -521,43 +521,55 @@ static int ixp4xx_set_next_event(unsigned long evt,
 	return 0;
 }
 
-static void ixp4xx_set_mode(enum clock_event_mode mode,
-			    struct clock_event_device *evt)
+static int ixp4xx_shutdown(struct clock_event_device *evt)
 {
 	unsigned long opts = *IXP4XX_OSRT1 & IXP4XX_OST_RELOAD_MASK;
 	unsigned long osrt = *IXP4XX_OSRT1 & ~IXP4XX_OST_RELOAD_MASK;
 
-	switch (mode) {
-	case CLOCK_EVT_MODE_PERIODIC:
-		osrt = IXP4XX_LATCH & ~IXP4XX_OST_RELOAD_MASK;
- 		opts = IXP4XX_OST_ENABLE;
-		break;
-	case CLOCK_EVT_MODE_ONESHOT:
-		/* period set by 'set next_event' */
-		osrt = 0;
-		opts = IXP4XX_OST_ENABLE | IXP4XX_OST_ONE_SHOT;
-		break;
-	case CLOCK_EVT_MODE_SHUTDOWN:
-		opts &= ~IXP4XX_OST_ENABLE;
-		break;
-	case CLOCK_EVT_MODE_RESUME:
-		opts |= IXP4XX_OST_ENABLE;
-		break;
-	case CLOCK_EVT_MODE_UNUSED:
-	default:
-		osrt = opts = 0;
-		break;
-	}
+	opts &= ~IXP4XX_OST_ENABLE;
+	*IXP4XX_OSRT1 = osrt | opts;
+	return 0;
+}
 
+static int ixp4xx_set_oneshot(struct clock_event_device *evt)
+{
+	unsigned long opts = IXP4XX_OST_ENABLE | IXP4XX_OST_ONE_SHOT;
+	unsigned long osrt = 0;
+
+	/* period set by 'set next_event' */
 	*IXP4XX_OSRT1 = osrt | opts;
+	return 0;
+}
+
+static int ixp4xx_set_periodic(struct clock_event_device *evt)
+{
+	unsigned long opts = IXP4XX_OST_ENABLE;
+	unsigned long osrt = IXP4XX_LATCH & ~IXP4XX_OST_RELOAD_MASK;
+
+	*IXP4XX_OSRT1 = osrt | opts;
+	return 0;
+}
+
+static int ixp4xx_resume(struct clock_event_device *evt)
+{
+	unsigned long opts = *IXP4XX_OSRT1 & IXP4XX_OST_RELOAD_MASK;
+	unsigned long osrt = *IXP4XX_OSRT1 & ~IXP4XX_OST_RELOAD_MASK;
+
+	opts |= IXP4XX_OST_ENABLE;
+	*IXP4XX_OSRT1 = osrt | opts;
+	return 0;
 }
 
 static struct clock_event_device clockevent_ixp4xx = {
-	.name		= "ixp4xx timer1",
-	.features       = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
-	.rating         = 200,
-	.set_mode	= ixp4xx_set_mode,
-	.set_next_event	= ixp4xx_set_next_event,
+	.name			= "ixp4xx timer1",
+	.features		= CLOCK_EVT_FEAT_PERIODIC |
+				  CLOCK_EVT_FEAT_ONESHOT,
+	.rating			= 200,
+	.set_state_shutdown	= ixp4xx_shutdown,
+	.set_state_periodic	= ixp4xx_set_periodic,
+	.set_state_oneshot	= ixp4xx_set_oneshot,
+	.tick_resume		= ixp4xx_resume,
+	.set_next_event		= ixp4xx_set_next_event,
 };
 
 static void __init ixp4xx_clockevent_init(void)

commit e43b21cbbd816aebbb275093f22a974f7b0cb345
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Nov 10 15:10:32 2014 +0100

    ARM: ixp4xx: Fix build with IXP4XX_INDIRECT_PCI
    
    Provide *_relaxed() accessors and make sure to pass the volatile void
    __iomem * to accessors rather than the value cast to a u32. This allows
    ixp4xx to build with IXP4XX_INDIRECT_PCI enabled.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index fc4b7b24265e..8537d4c41e34 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -652,7 +652,7 @@ static void __iomem *ixp4xx_ioremap_caller(phys_addr_t addr, size_t size,
 	return (void __iomem *)addr;
 }
 
-static void ixp4xx_iounmap(void __iomem *addr)
+static void ixp4xx_iounmap(volatile void __iomem *addr)
 {
 	if (!is_pci_memory((__force u32)addr))
 		__iounmap(addr);

commit dfc25e4503aef6b82a1de4a0fbe19aafa8648fbe
Merge: 9f800363bb0e 8f881c67368f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 5 13:51:19 2014 -0700

    Merge tag 'cleanup-3.15' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC cleanups from Arnd Bergmann:
     "These cleanup patches are mainly move stuff around and should all be
      harmless.  They are mainly split out so that other branches can be
      based on top to avoid conflicts.
    
      Notable changes are:
    
       - We finally remove all mach/timex.h, after CLOCK_TICK_RATE is no
         longer used (Uwe Kleine-König)
       - The Qualcomm MSM platform is split out into legacy mach-msm and
         new-style mach-qcom, to allow easier maintainance of the new
         hardware support without regressions (Kumar Gala)
       - A rework of some of the Kconfig logic to simplify multiplatform
         support (Rob Herring)
       - Samsung Exynos gets closer to supporting multiplatform (Sachin
         Kamat and others)
       - mach-bcm3528 gets merged into mach-bcm (Stephen Warren)
       - at91 gains some common clock framework support (Alexandre Belloni,
         Jean-Jacques Hiblot and other French people)"
    
    * tag 'cleanup-3.15' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (89 commits)
      ARM: hisi: select HAVE_ARM_SCU only for SMP
      ARM: efm32: allow uncompress debug output
      ARM: prima2: build reset code standalone
      ARM: at91: add PWM clock
      ARM: at91: move sam9261 SoC to common clk
      ARM: at91: prepare common clk transition for sam9261 SoC
      ARM: at91: updated the at91_dt_defconfig with support for the ADS7846
      ARM: at91: dt: sam9261: Device Tree support for the at91sam9261ek
      ARM: at91: dt: defconfig: Added the sam9261 to the list of DT-enabled SOCs
      ARM: at91: dt: Add at91sam9261 dt SoC support
      ARM: at91: switch sam9rl to common clock framework
      ARM: at91/dt: define main clk frequency of at91sam9rlek
      ARM: at91/dt: define at91sam9rl clocks
      ARM: at91: prepare common clk transition for sam9rl SoCs
      ARM: at91: prepare sam9 dt boards transition to common clk
      ARM: at91: dt: sam9rl: Device Tree for the at91sam9rlek
      ARM: at91/defconfig: Add the sam9rl to the list of DT-enabled SOCs
      ARM: at91: Add at91sam9rl DT SoC support
      ARM: at91: prepare at91sam9rl DT transition
      ARM: at91/defconfig: refresh at91sam9260_9g20_defconfig
      ...

commit 9f800363bb0ea459e15bef0928a72c88d374e489
Merge: 2d1eb87ae1e6 cb46a256a782
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 5 13:44:27 2014 -0700

    Merge tag 'fixes-non-critical-3.15' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC non-critical bug fixes from Arnd Bergmann:
     "Lots of isolated bug fixes that were not found to be important enough
      to be submitted before the merge window or backported into stable
      kernels.
    
      The vast majority of these came out of Arnd's randconfig testing and
      just prevents running into build-time bugs in configurations that we
      do not care about in practice"
    
    * tag 'fixes-non-critical-3.15' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (75 commits)
      ARM: at91: fix a typo
      ARM: moxart: fix CPU selection
      ARM: tegra: fix board DT pinmux setup
      ARM: nspire: Fix compiler warning
      IXP4xx: Fix DMA masks.
      Revert "ARM: ixp4xx: Make dma_set_coherent_mask common, correct implementation"
      IXP4xx: Fix Goramo Multilink GPIO conversion.
      Revert "ARM: ixp4xx: fix gpio rework"
      ARM: tegra: make debug_ll code build for ARMv6
      ARM: sunxi: fix build for THUMB2_KERNEL
      ARM: exynos: add missing include of linux/module.h
      ARM: exynos: fix l2x0 saved regs handling
      ARM: samsung: select CRC32 for SAMSUNG_PM_CHECK
      ARM: samsung: select ATAGS where necessary
      ARM: samsung: fix SAMSUNG_PM_DEBUG Kconfig logic
      ARM: samsung: allow serial driver to be disabled
      ARM: s5pv210: enable IDE support in MACH_TORBRECK
      ARM: s5p64x0: fix building with only one soc type
      ARM: s3c64xx: select power domains only when used
      ARM: s3c64xx: MACH_SMDK6400 needs HSMMC1
      ...

commit 00e1b3a3d196ae876370633b32007bf98584e748
Author: Krzysztof Halasa <khc@pm.waw.pl>
Date:   Sun Mar 23 01:36:48 2014 +0100

    IXP4xx: Fix DMA masks.
    
    Now, devices will have 32-bit default DMA masks (0xFFFFFFFF) as per DMA API.
    
    Fixes:
    $ ifconfig eth0 up
    net eth0: coherent DMA mask is unset
    
    $ ifconfig hdlc0 up
    net hdlc0: coherent DMA mask is unset
    
    Also fixes a cosmetic off-by-one bug which caused DMA transfers ending exactly
    on the 64 MiB boundary to go through dmabounce unnecessarily.
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>
    Tested-by: Simon Kagstrom <simon.kagstrom@netinsight.net>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 6d68aed6548a..12c71a4a42a0 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -30,8 +30,8 @@
 #include <linux/export.h>
 #include <linux/gpio.h>
 #include <linux/cpu.h>
+#include <linux/pci.h>
 #include <linux/sched_clock.h>
-
 #include <mach/udc.h>
 #include <mach/hardware.h>
 #include <mach/io.h>
@@ -40,7 +40,6 @@
 #include <asm/page.h>
 #include <asm/irq.h>
 #include <asm/system_misc.h>
-
 #include <asm/mach/map.h>
 #include <asm/mach/irq.h>
 #include <asm/mach/time.h>
@@ -578,6 +577,54 @@ void ixp4xx_restart(enum reboot_mode mode, const char *cmd)
 	}
 }
 
+#ifdef CONFIG_PCI
+static int ixp4xx_needs_bounce(struct device *dev, dma_addr_t dma_addr, size_t size)
+{
+	return (dma_addr + size) > SZ_64M;
+}
+
+static int ixp4xx_platform_notify_remove(struct device *dev)
+{
+	if (dev_is_pci(dev))
+		dmabounce_unregister_dev(dev);
+
+	return 0;
+}
+#endif
+
+/*
+ * Setup DMA mask to 64MB on PCI devices and 4 GB on all other things.
+ */
+static int ixp4xx_platform_notify(struct device *dev)
+{
+	dev->dma_mask = &dev->coherent_dma_mask;
+
+#ifdef CONFIG_PCI
+	if (dev_is_pci(dev)) {
+		dev->coherent_dma_mask = DMA_BIT_MASK(28); /* 64 MB */
+		dmabounce_register_dev(dev, 2048, 4096, ixp4xx_needs_bounce);
+		return 0;
+	}
+#endif
+
+	dev->coherent_dma_mask = DMA_BIT_MASK(32);
+	return 0;
+}
+
+int dma_set_coherent_mask(struct device *dev, u64 mask)
+{
+	if (dev_is_pci(dev))
+		mask &= DMA_BIT_MASK(28); /* 64 MB */
+
+	if ((mask & DMA_BIT_MASK(28)) == DMA_BIT_MASK(28)) {
+		dev->coherent_dma_mask = mask;
+		return 0;
+	}
+
+	return -EIO;		/* device wanted sub-64MB mask */
+}
+EXPORT_SYMBOL(dma_set_coherent_mask);
+
 #ifdef CONFIG_IXP4XX_INDIRECT_PCI
 /*
  * In the case of using indirect PCI, we simply return the actual PCI
@@ -600,12 +647,16 @@ static void ixp4xx_iounmap(void __iomem *addr)
 	if (!is_pci_memory((__force u32)addr))
 		__iounmap(addr);
 }
+#endif
 
 void __init ixp4xx_init_early(void)
 {
+	platform_notify = ixp4xx_platform_notify;
+#ifdef CONFIG_PCI
+	platform_notify_remove = ixp4xx_platform_notify_remove;
+#endif
+#ifdef CONFIG_IXP4XX_INDIRECT_PCI
 	arch_ioremap_caller = ixp4xx_ioremap_caller;
 	arch_iounmap = ixp4xx_iounmap;
-}
-#else
-void __init ixp4xx_init_early(void) {}
 #endif
+}

commit 53ad835ce7050dc3a3b3343fb07636db86783e26
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Mar 26 23:07:17 2014 +0100

    Revert "ARM: ixp4xx: Make dma_set_coherent_mask common, correct implementation"
    
    This reverts commit bfdad565ae0a61ac943974b8ae61ec0ed55ceb04.
    
    The patch turned out to be incorrect, and will be replaced
    with a correct patch.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index df82a2b4a546..6d68aed6548a 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -31,7 +31,6 @@
 #include <linux/gpio.h>
 #include <linux/cpu.h>
 #include <linux/sched_clock.h>
-#include <linux/pci.h>
 
 #include <mach/udc.h>
 #include <mach/hardware.h>
@@ -579,17 +578,6 @@ void ixp4xx_restart(enum reboot_mode mode, const char *cmd)
 	}
 }
 
-int dma_set_coherent_mask(struct device *dev, u64 mask)
-{
-	if (dev_is_pci(dev) && mask >= SZ_64M)
-		return -EIO;
-
-	dev->coherent_dma_mask = mask;
-
-	return 0;
-}
-EXPORT_SYMBOL(dma_set_coherent_mask);
-
 #ifdef CONFIG_IXP4XX_INDIRECT_PCI
 /*
  * In the case of using indirect PCI, we simply return the actual PCI

commit 9c9c6c55a887dfe4e68d48d0829e412ed4f14ca9
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Mar 26 23:03:09 2014 +0100

    Revert "ARM: ixp4xx: fix gpio rework"
    
    This reverts commit 48ba81f6fdb7580a5c474da1b14a338e1358e6ab.
    
    A better fix was sent by Krzysztof Halasa.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index eef39c7ad0cf..df82a2b4a546 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -100,7 +100,7 @@ void __init ixp4xx_map_io(void)
 #define IXP4XX_GPIO_CLK_0		14
 #define IXP4XX_GPIO_CLK_1		15
 
-void gpio_line_config(u8 line, u32 direction)
+static void gpio_line_config(u8 line, u32 direction)
 {
 	if (direction == IXP4XX_GPIO_IN)
 		*IXP4XX_GPIO_GPOER |= (1 << line);
@@ -108,12 +108,12 @@ void gpio_line_config(u8 line, u32 direction)
 		*IXP4XX_GPIO_GPOER &= ~(1 << line);
 }
 
-void gpio_line_get(u8 line, int *value)
+static void gpio_line_get(u8 line, int *value)
 {
 	*value = (*IXP4XX_GPIO_GPINR >> line) & 0x1;
 }
 
-void gpio_line_set(u8 line, int value)
+static void gpio_line_set(u8 line, int value)
 {
 	if (value == IXP4XX_GPIO_HIGH)
 	    *IXP4XX_GPIO_GPOUTR |= (1 << line);

commit 600a1dfae24746ccd8b1617742ef7b98099f83b8
Merge: b44ce3b0f9c3 9f3ba4567e8d
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Mar 21 18:32:54 2014 +0100

    Merge branch 'randconfig-fixes' into next/fixes-non-critical
    
    This is the first batch of a much longer series of bug fixes
    found during randconfig testing. This part are all the simple
    patches that are applicable for the arm-soc tree, while most
    other fixes will likely go through other maintainers.
    
    * randconfig-fixes: (50 commits)
      ARM: tegra: make debug_ll code build for ARMv6
      ARM: sunxi: fix build for THUMB2_KERNEL
      ARM: exynos: add missing include of linux/module.h
      ARM: exynos: fix l2x0 saved regs handling
      ARM: samsung: select CRC32 for SAMSUNG_PM_CHECK
      ARM: samsung: select ATAGS where necessary
      ARM: samsung: fix SAMSUNG_PM_DEBUG Kconfig logic
      ARM: samsung: allow serial driver to be disabled
      ARM: s5pv210: enable IDE support in MACH_TORBRECK
      ARM: s5p64x0: fix building with only one soc type
      ARM: s3c64xx: select power domains only when used
      ARM: s3c64xx: MACH_SMDK6400 needs HSMMC1
      ARM: s3c24xx: osiris dvs needs tps65010
      ARM: s3c24xx: fix gta02 build error
      ARM: s3c24xx: MINI2440 needs I2C for EEPROM_AT24
      ARM: integrator: only select pl01x if TTY is enabled
      ARM: realview: fix sparsemem build
      ARM: footbridge: make screen_info setup conditional
      ARM: footbridge: fix build with PCI disabled
      ARM: footbridge: don't build floppy code for addin mode
      ...
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 48ba81f6fdb7580a5c474da1b14a338e1358e6ab
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Feb 3 17:40:14 2014 +0100

    ARM: ixp4xx: fix gpio rework
    
    Commit 098e30f6558f8 "ARM: ixp4xx: stop broadcasting the custom GPIO API"
    changed the internal gpio code of ixp4xx to be accessible only from
    common.c, but unfortunately that broke the Goramo MultiLink code, which
    uses this API.
    
    This tries to restore the previous state without exposing the
    API globally again. A better solution might be needed.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Krzysztof Halasa <khc@pm.waw.pl>
    Cc: Imre Kaloz <kaloz@openwrt.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 6d68aed6548a..c751f2f35668 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -99,7 +99,7 @@ void __init ixp4xx_map_io(void)
 #define IXP4XX_GPIO_CLK_0		14
 #define IXP4XX_GPIO_CLK_1		15
 
-static void gpio_line_config(u8 line, u32 direction)
+void gpio_line_config(u8 line, u32 direction)
 {
 	if (direction == IXP4XX_GPIO_IN)
 		*IXP4XX_GPIO_GPOER |= (1 << line);
@@ -107,12 +107,12 @@ static void gpio_line_config(u8 line, u32 direction)
 		*IXP4XX_GPIO_GPOER &= ~(1 << line);
 }
 
-static void gpio_line_get(u8 line, int *value)
+void gpio_line_get(u8 line, int *value)
 {
 	*value = (*IXP4XX_GPIO_GPINR >> line) & 0x1;
 }
 
-static void gpio_line_set(u8 line, int value)
+void gpio_line_set(u8 line, int value)
 {
 	if (value == IXP4XX_GPIO_HIGH)
 	    *IXP4XX_GPIO_GPOUTR |= (1 << line);

commit bfdad565ae0a61ac943974b8ae61ec0ed55ceb04
Author: Simon Kågström <simon.kagstrom@netinsight.net>
Date:   Mon Mar 17 14:42:35 2014 +0100

    ARM: ixp4xx: Make dma_set_coherent_mask common, correct implementation
    
    Non-PCI devices can use the entire 32-bit range, PCI dittos are
    limited to the first 64MiB.
    
    Also actually setup coherent_dma_mask.
    
    The patch has been verified on a board with 128MiB memory, one
    ipx4xx_eth device and a e100 PCI device.
    
    Signed-off-by: Simon Kagstrom <simon.kagstrom@netinsight.net>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 6d68aed6548a..df82a2b4a546 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -31,6 +31,7 @@
 #include <linux/gpio.h>
 #include <linux/cpu.h>
 #include <linux/sched_clock.h>
+#include <linux/pci.h>
 
 #include <mach/udc.h>
 #include <mach/hardware.h>
@@ -578,6 +579,17 @@ void ixp4xx_restart(enum reboot_mode mode, const char *cmd)
 	}
 }
 
+int dma_set_coherent_mask(struct device *dev, u64 mask)
+{
+	if (dev_is_pci(dev) && mask >= SZ_64M)
+		return -EIO;
+
+	dev->coherent_dma_mask = mask;
+
+	return 0;
+}
+EXPORT_SYMBOL(dma_set_coherent_mask);
+
 #ifdef CONFIG_IXP4XX_INDIRECT_PCI
 /*
  * In the case of using indirect PCI, we simply return the actual PCI

commit 1ee6564d72ce718bf4e50d5684aa98d9d895f859
Author: Michael Opdenacker <michael@free-electrons.com>
Date:   Tue Mar 4 21:59:03 2014 +0100

    ARM: 7998/1: IXP4xx: remove deprecated IRQF_DISABLED
    
    This patch removes the use of the IRQF_DISABLED flag
    from code in arch/arm/mach-ixp4xx
    
    It's a NOOP since 2.6.35 and it will be removed one day.
    
    Signed-off-by: Michael Opdenacker <michael.opdenacker@free-electrons.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 6d68aed6548a..a465f27bc263 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -312,7 +312,7 @@ static irqreturn_t ixp4xx_timer_interrupt(int irq, void *dev_id)
 
 static struct irqaction ixp4xx_timer_irq = {
 	.name		= "timer1",
-	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.flags		= IRQF_TIMER | IRQF_IRQPOLL,
 	.handler	= ixp4xx_timer_interrupt,
 	.dev_id		= &clockevent_ixp4xx,
 };

commit 11d73c56b96b4297bd96273e9a22b7c72d13f1fa
Merge: 6d0abeca3242 fb3174e4ad24
Author: Olof Johansson <olof@lixom.net>
Date:   Tue Feb 18 22:19:33 2014 -0800

    Merge tag 'dropmachtimexh-v2' of git://git.pengutronix.de/git/ukl/linux into next/cleanup
    
    This cleanup series gets rid of <mach/timex.h> for platforms not using
    ARCH_MULTIPLATFORM. (For multi-platform code it's already unused since
    387798b (ARM: initial multiplatform support).)
    
    To make this work some code out of arch/arm needed to be adapted. The
    respective changes got acks by their maintainers to be taken via armsoc
    (with Andrew Morton substituting for Alessandro Zummo as rtc maintainer).
    
    Compared to the previous pull request there was another patch added that
    fixes a (non-critical) regression on ixp4xx. Olof Johansson asked to not
    squash this fix into the original commit to save him from the need to
    reverify the series.
    
    * tag 'dropmachtimexh-v2' of git://git.pengutronix.de/git/ukl/linux:
      ARM: ixp4xx: fix timer latch calculation
      ARM: drop <mach/timex.h> for !ARCH_MULTIPLATFORM, too
      ARM: rpc: stop using <mach/timex.h>
      ARM: ixp4xx: stop using <mach/timex.h>
      input: ixp4xx-beeper: don't use symbols from <mach/timex.h>
      ARM: at91: don't use <mach/timex.h>
      ARM: ep93xx: stop using mach/timex.h
      ARM: mmp: stop using mach/timex.h
      ARM: netx: stop using mach/timex.h
      ARM: sa1100: stop using mach/timex.h
      clocksource: sirf/marco+prima2: drop usage of CLOCK_TICK_RATE
      rtc: pxa: drop unused #define TIMER_FREQ
      rtc: at91sam9: include <mach/hardware.h> explicitly
      ARM/serial: at91: switch atmel serial to use gpiolib
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit fb3174e4ad2427c6ad90c67093d6ca97f13e8672
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Feb 3 11:31:19 2014 +0100

    ARM: ixp4xx: fix timer latch calculation
    
    In commit f0402f9b4711 ("ARM: ixp4xx: stop using <mach/timex.h>")
    I didn't intend to implement a functional change, but as Olof noticed I
    failed---at least a bit. Before this commit the following was used to
    determine the latch value used:
    
            #define IXP4XX_TIMER_FREQ 66666000
            #define CLOCK_TICK_RATE \
                    (((IXP4XX_TIMER_FREQ / HZ & ~IXP4XX_OST_RELOAD_MASK) + 1) * HZ)
            #define LATCH ((CLOCK_TICK_RATE + HZ/2) / HZ)
    
    The complicated calculation was done "b/c the timer register ignores the
    bottom 2 bits of the LATCH value." With HZ=100 CLOCK_TICK_RATE used to
    calculate to 66666100 and so LATCH to 666661. In ixp4xx_set_mode the
    term
    
            LATCH & ~IXP4XX_OST_RELOAD_MASK
    
    was used to write to the relevant register (with IXP4XX_OST_RELOAD_MASK
    being 3) and so effectively 666660 was used.
    
    In commit f0402f9b4711 I translated that to:
    
            #define IXP4XX_TIMER_FREQ 66666000
            #define IXP4XX_LATCH DIV_ROUND_CLOSEST(IXP4XX_TIMER_FREQ, HZ)
    
    which results in the same register writes, but still doesn't bear in
    mind that the two least significant bits cannot be specified (which is
    relevant only when HZ or IXP4XX_TIMER_FREQ are changed).
    
    Instead of reverting back to the old approach use a more obvious and
    also more correct way to calculate LATCH. (Regarding the more
    correct claim: With IXP4XX_TIMER_FREQ == 66665999, the old code resulted
    in LATCH = 666657 corresponding to a cycle time of 0.009999940149400597
    seconds (error: -6.0e-8 s) while the new approach results in LATCH =
    666660 and so a cycle time of 0.010000000150001503 seconds
    (error: 1.5e-10 s).)
    
    Fixes: f0402f9b4711 ("ARM: ixp4xx: stop using <mach/timex.h>")
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 20b62aa30086..37e6cdac1642 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -45,7 +45,15 @@
 #include <asm/mach/time.h>
 
 #define IXP4XX_TIMER_FREQ 66666000
-#define IXP4XX_LATCH DIV_ROUND_CLOSEST(IXP4XX_TIMER_FREQ, HZ)
+
+/*
+ * The timer register doesn't allow to specify the two least significant bits of
+ * the timeout value and assumes them being zero. So make sure IXP4XX_LATCH is
+ * the best value with the two least significant bits unset.
+ */
+#define IXP4XX_LATCH DIV_ROUND_CLOSEST(IXP4XX_TIMER_FREQ, \
+				       (IXP4XX_OST_RELOAD_MASK + 1) * HZ) * \
+			(IXP4XX_OST_RELOAD_MASK + 1)
 
 static void __init ixp4xx_clocksource_init(void);
 static void __init ixp4xx_clockevent_init(void);

commit dfd10e7ae60c6c1b24b5d601744b4fd1ecab2f31
Merge: f2c73464d7b3 6373bb71875b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 23 18:40:49 2014 -0800

    Merge tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform changes from Olof Johansson:
     "New core SoC-specific changes.
    
      New platforms:
       * Introduction of a vendor, Hisilicon, and one of their SoCs with
         some random numerical product name.
       * Introduction of EFM32, embedded platform from Silicon Labs (ARMv7m,
         i.e. !MMU).
       * Marvell Berlin series of SoCs, which include the one in Chromecast.
       * MOXA platform support, ARM9-based platform used mostly in
         industrial products
       * Support for Freescale's i.MX50 SoC.
    
      Other work:
       * Renesas work for new platforms and drivers, and conversion over to
         more multiplatform-friendly device registration schemes.
       * SMP support for Allwinner sunxi platforms.
       * ... plus a bunch of other stuff across various platforms"
    
    * tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (201 commits)
      ARM: tegra: fix tegra_powergate_sequence_power_up() inline
      ARM: msm_defconfig: Update for multi-platform
      ARM: msm: Move MSM's DT based hardware to multi-platform support
      ARM: msm: Only build timer.c if required
      ARM: msm: Only build clock.c on proc_comm based platforms
      ARM: ux500: Enable system suspend with WFI support
      ARM: ux500: turn on PRINTK_TIME in u8500_defconfig
      ARM: shmobile: r8a7790: Fix I2C controller names
      ARM: msm: Simplify ARCH_MSM_DT config
      ARM: msm: Add support for MSM8974 SoC
      ARM: sunxi: select ARM_PSCI
      MAINTAINERS: Update Allwinner sunXi maintainer files
      ARM: sunxi: Select RESET_CONTROLLER
      ARM: imx: improve the comment of CCM lpm SW workaround
      ARM: imx: improve status check of clock gate
      ARM: imx: add necessary interface for pfd
      ARM: imx_v6_v7_defconfig: Select CONFIG_REGULATOR_PFUZE100
      ARM: imx_v6_v7_defconfig: Select MX35 and MX50 device tree support
      ARM: imx: Add cpu frequency scaling support
      ARM i.MX35: Add devicetree support.
      ...

commit 97e81acd31de184af22b78c4977a66f40ca1efa3
Author: Krzysztof Hałasa <khalasa@piap.pl>
Date:   Thu Jan 2 09:34:10 2014 +0100

    IXP4xx: remove '1 &&' from a condition check in ixp4xx_restart()
    
    Signed-off-by: Krzysztof Hałasa <khalasa@piap.pl>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 9edaf4734fa8..a7906ebedb19 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -560,7 +560,7 @@ static void __init ixp4xx_clockevent_init(void)
 
 void ixp4xx_restart(enum reboot_mode mode, const char *cmd)
 {
-	if ( 1 && mode == REBOOT_SOFT) {
+	if (mode == REBOOT_SOFT) {
 		/* Jump into ROM at address 0 */
 		soft_restart(0);
 	} else {

commit f0402f9b47112faea10541b799b61066ae322c36
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Tue Nov 26 19:25:59 2013 +0100

    ARM: ixp4xx: stop using <mach/timex.h>
    
    The only user of symbols defined in ixp4xx's <mach/timex.h> is common.c.
    Fix that one up by moving the used #define into common.c directly and
    add a local substitute for the global define LATCH which uses
    CLOCK_TICK_RATE. This makes ixp4xx not to be a bar to dropping support
    for <mach/timex.h>.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 9edaf4734fa8..20b62aa30086 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -23,7 +23,6 @@
 #include <linux/interrupt.h>
 #include <linux/bitops.h>
 #include <linux/time.h>
-#include <linux/timex.h>
 #include <linux/clocksource.h>
 #include <linux/clockchips.h>
 #include <linux/io.h>
@@ -45,6 +44,9 @@
 #include <asm/mach/irq.h>
 #include <asm/mach/time.h>
 
+#define IXP4XX_TIMER_FREQ 66666000
+#define IXP4XX_LATCH DIV_ROUND_CLOSEST(IXP4XX_TIMER_FREQ, HZ)
+
 static void __init ixp4xx_clocksource_init(void);
 static void __init ixp4xx_clockevent_init(void);
 static struct clock_event_device clockevent_ixp4xx;
@@ -520,7 +522,7 @@ static void ixp4xx_set_mode(enum clock_event_mode mode,
 
 	switch (mode) {
 	case CLOCK_EVT_MODE_PERIODIC:
-		osrt = LATCH & ~IXP4XX_OST_RELOAD_MASK;
+		osrt = IXP4XX_LATCH & ~IXP4XX_OST_RELOAD_MASK;
  		opts = IXP4XX_OST_ENABLE;
 		break;
 	case CLOCK_EVT_MODE_ONESHOT:

commit b8969ef5cfa7859dbe6ac74debfd2d884d9fe14c
Merge: b19e11fbb2d4 d25f1d5a3069
Author: Kevin Hilman <khilman@linaro.org>
Date:   Fri Dec 6 08:05:37 2013 -0800

    Merge branch 'soc/sched_clock' into next/soc
    
    From Stephen Boyd:
    * soc/sched_clock:
      ARM: versatile: Switch to sched_clock_register()
      ARM: orion: Switch to sched_clock_register()
      ARM: OMAP: Switch to sched_clock_register()
      ARM: iop: Switch to sched_clock_register()
      ARM: u300: Switch to sched_clock_register()
      ARM: sa1100: Switch to sched_clock_register()
      ARM: pxa: Switch to sched_clock_register()
      ARM: OMAP2+: Switch to sched_clock_register()
      ARM: OMAP1: Switch to sched_clock_register()
      ARM: msm: Switch to sched_clock_register()
      ARM: mmp: Switch to sched_clock_register()
      ARM: IXP4xx: Switch to sched_clock_register()
      ARM: integrator: Switch to sched_clock_register()
      ARM: imx: Switch to sched_clock_register()
      ARM: davinci: Switch to sched_clock_register()
      ARM: clps711x: Switch to sched_clock_register()
      ARM: timer-sp: Switch to sched_clock_register()
    
    Signed-off-by: Kevin Hilman <khilman@linaro.org>

commit bf3eb44f9805061209d34c8b24cd455c50d1fd62
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Nov 15 15:26:14 2013 -0800

    ARM: IXP4xx: Switch to sched_clock_register()
    
    The 32 bit sched_clock interface now supports 64 bits. Upgrade to
    the 64 bit function to allow us to remove the 32 bit registration
    interface.
    
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Krzysztof Halasa <khc@pm.waw.pl>
    Signed-off-by: Kevin Hilman <khilman@linaro.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 5327decde5a0..124631e66797 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -448,7 +448,7 @@ void __init ixp4xx_sys_init(void)
 /*
  * sched_clock()
  */
-static u32 notrace ixp4xx_read_sched_clock(void)
+static u64 notrace ixp4xx_read_sched_clock(void)
 {
 	return *IXP4XX_OSTS;
 }
@@ -466,7 +466,7 @@ unsigned long ixp4xx_timer_freq = IXP4XX_TIMER_FREQ;
 EXPORT_SYMBOL(ixp4xx_timer_freq);
 static void __init ixp4xx_clocksource_init(void)
 {
-	setup_sched_clock(ixp4xx_read_sched_clock, 32, ixp4xx_timer_freq);
+	sched_clock_register(ixp4xx_read_sched_clock, 32, ixp4xx_timer_freq);
 
 	clocksource_mmio_init(NULL, "OSTS", ixp4xx_timer_freq, 200, 32,
 			ixp4xx_clocksource_read);

commit 098e30f6558f8950ed851e874d08bab91c9d4be7
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Sep 10 14:10:13 2013 +0200

    ARM: ixp4xx: stop broadcasting the custom GPIO API
    
    Now that these custom GPIO accessors are only used from the
    gpio chip in this machine, move the code out of the include
    file and right next to the gpiochip implementation.
    
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Cc: Alexandre Courbot <acourbot@nvidia.com>
    Acked-by: Krzysztof Halasa <khc@pm.waw.pl>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 8708ac8f3614..9edaf4734fa8 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -81,6 +81,44 @@ void __init ixp4xx_map_io(void)
   	iotable_init(ixp4xx_io_desc, ARRAY_SIZE(ixp4xx_io_desc));
 }
 
+/*
+ * GPIO-functions
+ */
+/*
+ * The following converted to the real HW bits the gpio_line_config
+ */
+/* GPIO pin types */
+#define IXP4XX_GPIO_OUT 		0x1
+#define IXP4XX_GPIO_IN  		0x2
+
+/* GPIO signal types */
+#define IXP4XX_GPIO_LOW			0
+#define IXP4XX_GPIO_HIGH		1
+
+/* GPIO Clocks */
+#define IXP4XX_GPIO_CLK_0		14
+#define IXP4XX_GPIO_CLK_1		15
+
+static void gpio_line_config(u8 line, u32 direction)
+{
+	if (direction == IXP4XX_GPIO_IN)
+		*IXP4XX_GPIO_GPOER |= (1 << line);
+	else
+		*IXP4XX_GPIO_GPOER &= ~(1 << line);
+}
+
+static void gpio_line_get(u8 line, int *value)
+{
+	*value = (*IXP4XX_GPIO_GPINR >> line) & 0x1;
+}
+
+static void gpio_line_set(u8 line, int value)
+{
+	if (value == IXP4XX_GPIO_HIGH)
+	    *IXP4XX_GPIO_GPOUTR |= (1 << line);
+	else if (value == IXP4XX_GPIO_LOW)
+	    *IXP4XX_GPIO_GPOUTR &= ~(1 << line);
+}
 
 /*************************************************************************
  * IXP4xx chipset IRQ handling

commit 81ded3c11eeb167c38406247914533872a82db8c
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Sep 10 13:39:03 2013 +0200

    ARM: ixp4: delete irq_to_gpio
    
    This dangerous function is not used in the kernel, so let's
    just delete it.
    
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Cc: Alexandre Courbot <acourbot@nvidia.com>
    Acked-by: Krzysztof Halasa <khc@pm.waw.pl>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 5327decde5a0..8708ac8f3614 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -117,17 +117,6 @@ static int ixp4xx_gpio_to_irq(struct gpio_chip *chip, unsigned gpio)
 	return -EINVAL;
 }
 
-int irq_to_gpio(unsigned int irq)
-{
-	int gpio = (irq < 32) ? irq2gpio[irq] : -EINVAL;
-
-	if (gpio == -1)
-		return -EINVAL;
-
-	return gpio;
-}
-EXPORT_SYMBOL(irq_to_gpio);
-
 static int ixp4xx_set_irq_type(struct irq_data *d, unsigned int type)
 {
 	int line = irq2gpio[d->irq];

commit 7b6d864b48d95e6ea1df7df64475b9cb9616dcf9
Author: Robin Holt <holt@sgi.com>
Date:   Mon Jul 8 16:01:40 2013 -0700

    reboot: arm: change reboot_mode to use enum reboot_mode
    
    Preparing to move the parsing of reboot= to generic kernel code forces
    the change in reboot_mode handling to use the enum.
    
    [akpm@linux-foundation.org: fix arch/arm/mach-socfpga/socfpga.c]
    Signed-off-by: Robin Holt <holt@sgi.com>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Russ Anderson <rja@sgi.com>
    Cc: Robin Holt <holt@sgi.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 1f6c1fb353ad..5327decde5a0 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -531,9 +531,9 @@ static void __init ixp4xx_clockevent_init(void)
 					0xf, 0xfffffffe);
 }
 
-void ixp4xx_restart(char mode, const char *cmd)
+void ixp4xx_restart(enum reboot_mode mode, const char *cmd)
 {
-	if ( 1 && mode == 's') {
+	if ( 1 && mode == REBOOT_SOFT) {
 		/* Jump into ROM at address 0 */
 		soft_restart(0);
 	} else {

commit 21884a83b2192a00885d7244a1dda32debd2fbc7
Merge: 8b70a90cabaf 73b0cd674ccc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 6 14:09:38 2013 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer core updates from Thomas Gleixner:
     "The timer changes contain:
    
       - posix timer code consolidation and fixes for odd corner cases
    
       - sched_clock implementation moved from ARM to core code to avoid
         duplication by other architectures
    
       - alarm timer updates
    
       - clocksource and clockevents unregistration facilities
    
       - clocksource/events support for new hardware
    
       - precise nanoseconds RTC readout (Xen feature)
    
       - generic support for Xen suspend/resume oddities
    
       - the usual lot of fixes and cleanups all over the place
    
      The parts which touch other areas (ARM/XEN) have been coordinated with
      the relevant maintainers.  Though this results in an handful of
      trivial to solve merge conflicts, which we preferred over nasty cross
      tree merge dependencies.
    
      The patches which have been committed in the last few days are bug
      fixes plus the posix timer lot.  The latter was in akpms queue and
      next for quite some time; they just got forgotten and Frederic
      collected them last minute."
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (59 commits)
      hrtimer: Remove unused variable
      hrtimers: Move SMP function call to thread context
      clocksource: Reselect clocksource when watchdog validated high-res capability
      posix-cpu-timers: don't account cpu timer after stopped thread runtime accounting
      posix_timers: fix racy timer delta caching on task exit
      posix-timers: correctly get dying task time sample in posix_cpu_timer_schedule()
      selftests: add basic posix timers selftests
      posix_cpu_timers: consolidate expired timers check
      posix_cpu_timers: consolidate timer list cleanups
      posix_cpu_timer: consolidate expiry time type
      tick: Sanitize broadcast control logic
      tick: Prevent uncontrolled switch to oneshot mode
      tick: Make oneshot broadcast robust vs. CPU offlining
      x86: xen: Sync the CMOS RTC as well as the Xen wallclock
      x86: xen: Sync the wallclock when the system time is set
      timekeeping: Indicate that clock was set in the pvclock gtod notifier
      timekeeping: Pass flags instead of multiple bools to timekeeping_update()
      xen: Remove clock_was_set() call in the resume path
      hrtimers: Support resuming with two or more CPUs online (but stopped)
      timer: Fix jiffies wrap behavior of round_jiffies_common()
      ...

commit 38ff87f77af0b5a93fc8581cff1d6e5692ab8970
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Sat Jun 1 23:39:40 2013 -0700

    sched_clock: Make ARM's sched_clock generic for all architectures
    
    Nothing about the sched_clock implementation in the ARM port is
    specific to the architecture. Generalize the code so that other
    architectures can use it by selecting GENERIC_SCHED_CLOCK.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    [jstultz: Merge minor collisions with other patches in my tree]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 6600cff6bd92..58307cff1f18 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -30,6 +30,7 @@
 #include <linux/export.h>
 #include <linux/gpio.h>
 #include <linux/cpu.h>
+#include <linux/sched_clock.h>
 
 #include <mach/udc.h>
 #include <mach/hardware.h>
@@ -38,7 +39,6 @@
 #include <asm/pgtable.h>
 #include <asm/page.h>
 #include <asm/irq.h>
-#include <asm/sched_clock.h>
 #include <asm/system_misc.h>
 
 #include <asm/mach/map.h>

commit 9b97173e785a54c5df0aa23d1e1f680f61e36e43
Author: Laura Abbott <lauraa@codeaurora.org>
Date:   Thu May 16 19:40:22 2013 +0100

    ARM: 7728/1: mm: Use phys_addr_t properly for ioremap functions
    
    Several of the ioremap functions use unsigned long in places
    resulting in truncation if physical addresses greater than
    4G are passed in. Change the types of the functions and the
    callers accordingly.
    
    Cc: Krzysztof Halasa <khc@pm.waw.pl>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Laura Abbott <lauraa@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 6600cff6bd92..d7223b3b81f3 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -559,7 +559,7 @@ void ixp4xx_restart(char mode, const char *cmd)
  * fallback to the default.
  */
 
-static void __iomem *ixp4xx_ioremap_caller(unsigned long addr, size_t size,
+static void __iomem *ixp4xx_ioremap_caller(phys_addr_t addr, size_t size,
 					   unsigned int mtype, void *caller)
 {
 	if (!is_pci_memory(addr))

commit f7b861b7a6d9d1838cbbb5f4053e61578b86d134
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 21 22:49:38 2013 +0100

    arm: Use generic idle loop
    
    Use the generic idle loop and replace enable/disable_hlt with the
    respective core functions.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Paul McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Reviewed-by: Cc: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Tested-by: Kevin Hilman <khilman@linaro.org> # OMAP
    Link: http://lkml.kernel.org/r/20130321215233.826238797@linutronix.de

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 1dbeb7c99d58..6600cff6bd92 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -29,6 +29,7 @@
 #include <linux/io.h>
 #include <linux/export.h>
 #include <linux/gpio.h>
+#include <linux/cpu.h>
 
 #include <mach/udc.h>
 #include <mach/hardware.h>
@@ -239,7 +240,7 @@ void __init ixp4xx_init_irq(void)
 	 * ixp4xx does not implement the XScale PWRMODE register
 	 * so it must not call cpu_do_idle().
 	 */
-	disable_hlt();
+	cpu_idle_poll_ctrl(true);
 
 	/* Route all sources to IRQ instead of FIQ */
 	*IXP4XX_ICLR = 0x0;

commit 8d84981e395850aab31c3f2ca7e2738e03f671d7
Merge: 00c82d644056 77cc982f6a3b
Author: Olof Johansson <olof@lixom.net>
Date:   Mon Jan 14 10:20:02 2013 -0800

    Merge branch 'clocksource/cleanup' into next/cleanup
    
    Clockevent cleanup series from Shawn Guo.
    
    Resolved move/change conflict in mach-pxa/time.c due to the sys_timer
    cleanup.
    
    * clocksource/cleanup:
      clocksource: use clockevents_config_and_register() where possible
      ARM: use clockevents_config_and_register() where possible
      clockevents: export clockevents_config_and_register for module use
      + sync to Linux 3.8-rc3
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    
    Conflicts:
            arch/arm/mach-pxa/time.c

commit 838a2ae80a6ab52139fb1bf0a93ea8c5eff94488
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Sat Jan 12 11:50:05 2013 +0000

    ARM: use clockevents_config_and_register() where possible
    
    The clockevent core is able to figure out the best mult and shift,
    calculate min_delta_ns and max_delta_ns, with the necessary info passed
    into clockevents_config_and_register().  Use this combined configure
    and register function where possible to make the codes less error prone
    and gain some positive diff stat.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Reviewed-by: Anton Vorontsov <cbouatmailru@gmail.com>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Tested-by: Roland Stigge <stigge@antcom.de>
    Acked-by: Eric Miao <eric.y.miao@gmail.com>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: David Brown <davidb@codeaurora.org>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Barry Song <baohua.song@csr.com>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Tony Prisk <linux@prisktech.co.nz>
    Cc: Lennert Buytenhek <buytenh@wantstofly.org>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 8c0c0e2d0727..65ff98cc865c 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -523,22 +523,15 @@ static struct clock_event_device clockevent_ixp4xx = {
 	.name		= "ixp4xx timer1",
 	.features       = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
 	.rating         = 200,
-	.shift		= 24,
 	.set_mode	= ixp4xx_set_mode,
 	.set_next_event	= ixp4xx_set_next_event,
 };
 
 static void __init ixp4xx_clockevent_init(void)
 {
-	clockevent_ixp4xx.mult = div_sc(IXP4XX_TIMER_FREQ, NSEC_PER_SEC,
-					clockevent_ixp4xx.shift);
-	clockevent_ixp4xx.max_delta_ns =
-		clockevent_delta2ns(0xfffffffe, &clockevent_ixp4xx);
-	clockevent_ixp4xx.min_delta_ns =
-		clockevent_delta2ns(0xf, &clockevent_ixp4xx);
 	clockevent_ixp4xx.cpumask = cpumask_of(0);
-
-	clockevents_register_device(&clockevent_ixp4xx);
+	clockevents_config_and_register(&clockevent_ixp4xx, IXP4XX_TIMER_FREQ,
+					0xf, 0xfffffffe);
 }
 
 void ixp4xx_restart(char mode, const char *cmd)

commit 6bb27d7349db51b50c40534710fe164ca0d58902
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Nov 8 12:40:59 2012 -0700

    ARM: delete struct sys_timer
    
    Now that the only field in struct sys_timer is .init, delete the struct,
    and replace the machine descriptor .timer field with the initialization
    function itself.
    
    This will enable moving timer drivers into drivers/clocksource without
    having to place a public prototype of each struct sys_timer object into
    include/linux; the intent is to create a single of_clocksource_init()
    function that determines which timer driver to initialize by scanning
    the device dtree, much like the proposed irqchip_init() at:
    http://www.spinics.net/lists/arm-kernel/msg203686.html
    
    Includes mach-omap2 fixes from Igor Grinberg.
    
    Tested-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 8c0c0e2d0727..f6ac695ceb60 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -307,10 +307,6 @@ void __init ixp4xx_timer_init(void)
 	ixp4xx_clockevent_init();
 }
 
-struct sys_timer ixp4xx_timer = {
-	.init		= ixp4xx_timer_init,
-};
-
 static struct pxa2xx_udc_mach_info ixp4xx_udc_info;
 
 void __init ixp4xx_set_udc_info(struct pxa2xx_udc_mach_info *info)

commit b7b23db72f9a79e6ed0bcfb75d73b29f8e03fe62
Author: Krzysztof Hałasa <khc@pm.waw.pl>
Date:   Sun Sep 2 00:50:39 2012 +0200

    IXP4xx: map CPU config registers within VMALLOC region.
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index acc0584377fc..8c0c0e2d0727 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -73,14 +73,6 @@ static struct map_desc ixp4xx_io_desc[] __initdata = {
 		.length		= IXP4XX_QMGR_REGION_SIZE,
 		.type		= MT_DEVICE
 	},
-#ifdef CONFIG_DEBUG_LL
-	{	/* Debug UART mapping */
-		.virtual	= (unsigned long)IXP4XX_DEBUG_UART_BASE_VIRT,
-		.pfn		= __phys_to_pfn(IXP4XX_DEBUG_UART_BASE_PHYS),
-		.length		= IXP4XX_DEBUG_UART_REGION_SIZE,
-		.type		= MT_DEVICE
-	}
-#endif
 };
 
 void __init ixp4xx_map_io(void)

commit f0cdb153292635203b3a0921c901dacf85d4ef1b
Author: Krzysztof Hałasa <khc@pm.waw.pl>
Date:   Fri Mar 26 16:38:52 2010 +0100

    IXP4xx: Always ioremap() Queue Manager MMIO region at boot.
    
    It doesn't make much sense to map QMgr dynamically - we almost always need it
    and the static mapping will be needed for little-endian data-coherent operation
    (to make QMgr region value-coherent).
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index fdf91a160884..acc0584377fc 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -67,6 +67,11 @@ static struct map_desc ixp4xx_io_desc[] __initdata = {
 		.pfn		= __phys_to_pfn(IXP4XX_PCI_CFG_BASE_PHYS),
 		.length		= IXP4XX_PCI_CFG_REGION_SIZE,
 		.type		= MT_DEVICE
+	}, {	/* Queue Manager */
+		.virtual	= (unsigned long)IXP4XX_QMGR_BASE_VIRT,
+		.pfn		= __phys_to_pfn(IXP4XX_QMGR_BASE_PHYS),
+		.length		= IXP4XX_QMGR_REGION_SIZE,
+		.type		= MT_DEVICE
 	},
 #ifdef CONFIG_DEBUG_LL
 	{	/* Debug UART mapping */

commit 13ec32f47cb42cecc9cd262c307ef9377c601007
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Sep 14 20:19:40 2012 +0000

    ARM: ixp4xx: use __iomem pointers for MMIO
    
    ARM is moving to stricter checks on readl/write functions,
    so we need to use the correct types everywhere.
    
    At the moment, this patch conflicts with other patches in linux-next,
    need to sort this out.
    
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Cc: Krzysztof Halasa <khc@pm.waw.pl>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index a9f80943d01f..fdf91a160884 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -53,24 +53,24 @@ static struct clock_event_device clockevent_ixp4xx;
  *************************************************************************/
 static struct map_desc ixp4xx_io_desc[] __initdata = {
 	{	/* UART, Interrupt ctrl, GPIO, timers, NPEs, MACs, USB .... */
-		.virtual	= IXP4XX_PERIPHERAL_BASE_VIRT,
+		.virtual	= (unsigned long)IXP4XX_PERIPHERAL_BASE_VIRT,
 		.pfn		= __phys_to_pfn(IXP4XX_PERIPHERAL_BASE_PHYS),
 		.length		= IXP4XX_PERIPHERAL_REGION_SIZE,
 		.type		= MT_DEVICE
 	}, {	/* Expansion Bus Config Registers */
-		.virtual	= IXP4XX_EXP_CFG_BASE_VIRT,
+		.virtual	= (unsigned long)IXP4XX_EXP_CFG_BASE_VIRT,
 		.pfn		= __phys_to_pfn(IXP4XX_EXP_CFG_BASE_PHYS),
 		.length		= IXP4XX_EXP_CFG_REGION_SIZE,
 		.type		= MT_DEVICE
 	}, {	/* PCI Registers */
-		.virtual	= IXP4XX_PCI_CFG_BASE_VIRT,
+		.virtual	= (unsigned long)IXP4XX_PCI_CFG_BASE_VIRT,
 		.pfn		= __phys_to_pfn(IXP4XX_PCI_CFG_BASE_PHYS),
 		.length		= IXP4XX_PCI_CFG_REGION_SIZE,
 		.type		= MT_DEVICE
 	},
 #ifdef CONFIG_DEBUG_LL
 	{	/* Debug UART mapping */
-		.virtual	= IXP4XX_DEBUG_UART_BASE_VIRT,
+		.virtual	= (unsigned long)IXP4XX_DEBUG_UART_BASE_VIRT,
 		.pfn		= __phys_to_pfn(IXP4XX_DEBUG_UART_BASE_PHYS),
 		.length		= IXP4XX_DEBUG_UART_REGION_SIZE,
 		.type		= MT_DEVICE

commit 9dde0ae3769875ec1370cb316e50c54b57d52c1a
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Wed May 23 18:19:51 2012 +0200

    ixp4xx: fix compilation by adding gpiolib support
    
    Once again, ixp4xx no longer even compiles. This patch fixes the issue
    by converting over to gpiolib. This patch was first made by Imre and
    posted by Marc, and I added in Russell's suggestion to empty the gpio
    header file.
    
    This fix should also go for 3.1, 3.2, 3.3, and 3.4.
    
    Signed-off-by: Richard Cochran <richardcochran@gmail.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index ebbd7fc90eb4..a9f80943d01f 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -28,6 +28,7 @@
 #include <linux/clockchips.h>
 #include <linux/io.h>
 #include <linux/export.h>
+#include <linux/gpio.h>
 
 #include <mach/udc.h>
 #include <mach/hardware.h>
@@ -107,7 +108,7 @@ static signed char irq2gpio[32] = {
 	 7,  8,  9, 10, 11, 12, -1, -1,
 };
 
-int gpio_to_irq(int gpio)
+static int ixp4xx_gpio_to_irq(struct gpio_chip *chip, unsigned gpio)
 {
 	int irq;
 
@@ -117,7 +118,6 @@ int gpio_to_irq(int gpio)
 	}
 	return -EINVAL;
 }
-EXPORT_SYMBOL(gpio_to_irq);
 
 int irq_to_gpio(unsigned int irq)
 {
@@ -383,12 +383,56 @@ static struct platform_device *ixp46x_devices[] __initdata = {
 unsigned long ixp4xx_exp_bus_size;
 EXPORT_SYMBOL(ixp4xx_exp_bus_size);
 
+static int ixp4xx_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)
+{
+	gpio_line_config(gpio, IXP4XX_GPIO_IN);
+
+	return 0;
+}
+
+static int ixp4xx_gpio_direction_output(struct gpio_chip *chip, unsigned gpio,
+					int level)
+{
+	gpio_line_set(gpio, level);
+	gpio_line_config(gpio, IXP4XX_GPIO_OUT);
+
+	return 0;
+}
+
+static int ixp4xx_gpio_get_value(struct gpio_chip *chip, unsigned gpio)
+{
+	int value;
+
+	gpio_line_get(gpio, &value);
+
+	return value;
+}
+
+static void ixp4xx_gpio_set_value(struct gpio_chip *chip, unsigned gpio,
+				  int value)
+{
+	gpio_line_set(gpio, value);
+}
+
+static struct gpio_chip ixp4xx_gpio_chip = {
+	.label			= "IXP4XX_GPIO_CHIP",
+	.direction_input	= ixp4xx_gpio_direction_input,
+	.direction_output	= ixp4xx_gpio_direction_output,
+	.get			= ixp4xx_gpio_get_value,
+	.set			= ixp4xx_gpio_set_value,
+	.to_irq			= ixp4xx_gpio_to_irq,
+	.base			= 0,
+	.ngpio			= 16,
+};
+
 void __init ixp4xx_sys_init(void)
 {
 	ixp4xx_exp_bus_size = SZ_16M;
 
 	platform_add_devices(ixp4xx_devices, ARRAY_SIZE(ixp4xx_devices));
 
+	gpiochip_add(&ixp4xx_gpio_chip);
+
 	if (cpu_is_ixp46x()) {
 		int region;
 

commit c39e8ede284f469971589f2e04af78216e1a771d
Merge: a335750b9a03 d3c7de52096a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 30 17:00:34 2012 -0700

    Merge tag 'fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull a few more ARM platform fixes from Olof Johansson:
     "Apologies for back-to-back fixes pull requests, but one of the patches
      below are the kind we'll see posted over and over if we don't send it
      in.  I hadn't done the full sanity-check of defconfig builds by the
      time I sent up the other fixes yesterday or I would have included it
      then.
    
      Two patches, one dealing with the system.h fallout, the other is a
      missing linux/bug.h in a place where ARRAY_SIZE() is used."
    
    * tag 'fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      ARM: clps711x: fix missing include file
      ARM: fix builds due to missing <asm/system_misc.h> includes

commit 86dfe446c2c10ab2ab437a1b0a3f29e63cb350cb
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Mar 29 23:22:44 2012 -0700

    ARM: fix builds due to missing <asm/system_misc.h> includes
    
    This does a sweeping change fixing up all the missing system_misc.h and
    system_info.h includes from the system.h split-up change. These were the
    ones I came across when building all defconfigs in arch/arm/configs, there
    might be more but they lack adequate build coverage to be easily caught.
    
    I'm expecting to get a lot of these piecemeal by each maintainer, so we
    might just as well do one sweeping change to get them all at once.
    
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Cc: Krzysztof Halasa <khc@pm.waw.pl>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index a6329a0a8ec4..fa7c9c0e5672 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -36,6 +36,7 @@
 #include <asm/page.h>
 #include <asm/irq.h>
 #include <asm/sched_clock.h>
+#include <asm/system_misc.h>
 
 #include <asm/mach/map.h>
 #include <asm/mach/irq.h>

commit f449588c65e23637aef59cae2ea7b6b2b1b767ec
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Tue Mar 6 15:01:53 2012 -0600

    ARM: ixp4xx: use runtime ioremap hook
    
    Convert ixp4xx platforms to use run-time ioremap hook instead of the
    compile time hook.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Cc: Krzysztof Halasa <khc@pm.waw.pl>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index a6329a0a8ec4..c60e7b86192c 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -31,6 +31,7 @@
 
 #include <mach/udc.h>
 #include <mach/hardware.h>
+#include <mach/io.h>
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
 #include <asm/page.h>
@@ -517,3 +518,35 @@ void ixp4xx_restart(char mode, const char *cmd)
 		*IXP4XX_OSWE = IXP4XX_WDT_RESET_ENABLE | IXP4XX_WDT_COUNT_ENABLE;
 	}
 }
+
+#ifdef CONFIG_IXP4XX_INDIRECT_PCI
+/*
+ * In the case of using indirect PCI, we simply return the actual PCI
+ * address and our read/write implementation use that to drive the
+ * access registers. If something outside of PCI is ioremap'd, we
+ * fallback to the default.
+ */
+
+static void __iomem *ixp4xx_ioremap_caller(unsigned long addr, size_t size,
+					   unsigned int mtype, void *caller)
+{
+	if (!is_pci_memory(addr))
+		return __arm_ioremap_caller(addr, size, mtype, caller);
+
+	return (void __iomem *)addr;
+}
+
+static void ixp4xx_iounmap(void __iomem *addr)
+{
+	if (!is_pci_memory((__force u32)addr))
+		__iounmap(addr);
+}
+
+void __init ixp4xx_init_early(void)
+{
+	arch_ioremap_caller = ixp4xx_ioremap_caller;
+	arch_iounmap = ixp4xx_iounmap;
+}
+#else
+void __init ixp4xx_init_early(void) {}
+#endif

commit 12d2b4e5f0c65eaa1d61e4e1bbfb2df41bc6cd9d
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Wed Aug 3 07:25:39 2011 -0400

    ARM: mach-ixp4xx: properly disable CPU idle call
    
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 3841ab4146ba..a6329a0a8ec4 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -236,6 +236,12 @@ void __init ixp4xx_init_irq(void)
 {
 	int i = 0;
 
+	/*
+	 * ixp4xx does not implement the XScale PWRMODE register
+	 * so it must not call cpu_do_idle().
+	 */
+	disable_hlt();
+
 	/* Route all sources to IRQ instead of FIQ */
 	*IXP4XX_ICLR = 0x0;
 

commit 7b9dd47136c07ffd883aff6926c7b281e4c1eea4
Merge: 2e0e94343691 0575fb754dbf
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jan 5 13:25:15 2012 +0000

    Merge branch 'restart' into for-linus
    
    Conflicts:
            arch/arm/mach-exynos/cpu.c
    
    The changes to arch/arm/mach-exynos/cpu.c were moved to
    mach-exynos/common.c.

commit d1b860fbb2b0d25a5ccd8165ea4db2914b0820f5
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Nov 5 12:10:55 2011 +0000

    ARM: restart: ixp4xx: use new restart hook
    
    Hook these platforms restart code into the new restart hook rather
    than using arch_reset().
    
    Acked-by: Krzysztof Hałasa <khc@pm.waw.pl>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index b86a0055ab96..04aa12103bce 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -501,3 +501,23 @@ static void __init ixp4xx_clockevent_init(void)
 
 	clockevents_register_device(&clockevent_ixp4xx);
 }
+
+void ixp4xx_restart(char mode, const char *cmd)
+{
+	if ( 1 && mode == 's') {
+		/* Jump into ROM at address 0 */
+		soft_restart(0);
+	} else {
+		/* Use on-chip reset capability */
+
+		/* set the "key" register to enable access to
+		 * "timer" and "enable" registers
+		 */
+		*IXP4XX_OSWK = IXP4XX_WDT_KEY;
+
+		/* write 0 to the timer register for an immediate reset */
+		*IXP4XX_OSWT = 0;
+
+		*IXP4XX_OSWE = IXP4XX_WDT_RESET_ENABLE | IXP4XX_WDT_COUNT_ENABLE;
+	}
+}

commit 2f0778afac79bd8d226225556858a636931eeabc
Author: Marc Zyngier <Marc.Zyngier@arm.com>
Date:   Thu Dec 15 12:19:23 2011 +0100

    ARM: 7205/2: sched_clock: allow sched_clock to be selected at runtime
    
    sched_clock() is yet another blocker on the road to the single
    image. This patch implements an idea by Russell King:
    
    http://www.spinics.net/lists/linux-omap/msg49561.html
    
    Instead of asking the platform to implement both sched_clock()
    itself and the rollover callback, simply register a read()
    function, and let the ARM code care about sched_clock() itself,
    the conversion to ns and the rollover. sched_clock() uses
    this read() function as an indirection to the platform code.
    If the platform doesn't provide a read(), the code falls back
    to the jiffy counter (just like the default sched_clock).
    
    This allow some simplifications and possibly some footprint gain
    when multiple platforms are compiled in. Among the drawbacks,
    the removal of the *_fixed_sched_clock optimization which could
    negatively impact some platforms (sa1100, tegra, versatile
    and omap).
    
    Tested on 11MPCore, OMAP4 and Tegra.
    
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Colin Cross <ccross@android.com>
    Cc: Erik Gilling <konkers@android.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Alessandro Rubini <rubini@unipv.it>
    Cc: STEricsson <STEricsson_nomadik_linux@list.st.com>
    Cc: Lennert Buytenhek <kernel@wantstofly.org>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Tested-by: Jamie Iles <jamie@jamieiles.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Krzysztof Halasa <khc@pm.waw.pl>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index b86a0055ab96..c1b12f945fc9 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -17,7 +17,6 @@
 #include <linux/mm.h>
 #include <linux/init.h>
 #include <linux/serial.h>
-#include <linux/sched.h>
 #include <linux/tty.h>
 #include <linux/platform_device.h>
 #include <linux/serial_core.h>
@@ -403,18 +402,9 @@ void __init ixp4xx_sys_init(void)
 /*
  * sched_clock()
  */
-static DEFINE_CLOCK_DATA(cd);
-
-unsigned long long notrace sched_clock(void)
+static u32 notrace ixp4xx_read_sched_clock(void)
 {
-	u32 cyc = *IXP4XX_OSTS;
-	return cyc_to_sched_clock(&cd, cyc, (u32)~0);
-}
-
-static void notrace ixp4xx_update_sched_clock(void)
-{
-	u32 cyc = *IXP4XX_OSTS;
-	update_sched_clock(&cd, cyc, (u32)~0);
+	return *IXP4XX_OSTS;
 }
 
 /*
@@ -430,7 +420,7 @@ unsigned long ixp4xx_timer_freq = IXP4XX_TIMER_FREQ;
 EXPORT_SYMBOL(ixp4xx_timer_freq);
 static void __init ixp4xx_clocksource_init(void)
 {
-	init_sched_clock(&cd, ixp4xx_update_sched_clock, 32, ixp4xx_timer_freq);
+	setup_sched_clock(ixp4xx_read_sched_clock, 32, ixp4xx_timer_freq);
 
 	clocksource_mmio_init(NULL, "OSTS", ixp4xx_timer_freq, 200, 32,
 			ixp4xx_clocksource_read);

commit dc28094b905a872f8884f1f1c48ca86b3b78583a
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 31 16:17:29 2011 -0400

    arm: Add export.h to ARM specific files as required.
    
    These files all make use of one of the EXPORT_SYMBOL variants
    or the THIS_MODULE macro.  So they will need <linux/export.h>
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 07772575d7ab..b86a0055ab96 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -28,6 +28,7 @@
 #include <linux/clocksource.h>
 #include <linux/clockchips.h>
 #include <linux/io.h>
+#include <linux/export.h>
 
 #include <mach/udc.h>
 #include <mach/hardware.h>

commit 900b170af40b4fef54e89f3d48d055f7d8031ae6
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Fri Jul 15 21:33:12 2011 +0200

    ARM: fix regression in IXP4xx clocksource
    
    Commit 234b6ceddb4fc2a4bc5b9a7670f070f6e69e0868
    
       clocksource: convert ARM 32-bit up counting clocksources
    
    broke the build for ixp4xx and made big endian operation impossible.
    This commit restores the original behaviour.
    
    Signed-off-by: Richard Cochran <richard.cochran@omicron.at>
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>
    [ Thomas says that we might want to have generic BE accessor functions
      to the MMIO clock source, but that hasn't happened yet, so in the
      meantime this seems to be the short-term fix for the particular
      problem - Linus ]
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 74ed81a3cb1a..07772575d7ab 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -419,14 +419,20 @@ static void notrace ixp4xx_update_sched_clock(void)
 /*
  * clocksource
  */
+
+static cycle_t ixp4xx_clocksource_read(struct clocksource *c)
+{
+	return *IXP4XX_OSTS;
+}
+
 unsigned long ixp4xx_timer_freq = IXP4XX_TIMER_FREQ;
 EXPORT_SYMBOL(ixp4xx_timer_freq);
 static void __init ixp4xx_clocksource_init(void)
 {
 	init_sched_clock(&cd, ixp4xx_update_sched_clock, 32, ixp4xx_timer_freq);
 
-	clocksource_mmio_init(&IXP4XX_OSTS, "OSTS", ixp4xx_timer_freq, 200, 32,
-			clocksource_mmio_readl_up);
+	clocksource_mmio_init(NULL, "OSTS", ixp4xx_timer_freq, 200, 32,
+			ixp4xx_clocksource_read);
 }
 
 /*

commit 234b6ceddb4fc2a4bc5b9a7670f070f6e69e0868
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun May 8 14:09:47 2011 +0100

    clocksource: convert ARM 32-bit up counting clocksources
    
    Convert ixp4xx, lpc32xx, mxc, netx, pxa, sa1100, tcc8k, tegra and u300
    to use the generic mmio clocksource recently introduced.
    
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Cc: Krzysztof Halasa <khc@pm.waw.pl>
    Acked-by: Eric Miao <eric.y.miao@gmail.com>
    Acked-by: "Hans J. Koch" <hjk@hansjkoch.de>
    Acked-by: Colin Cross <ccross@android.com>
    Cc: Erik Gilling <konkers@android.com>
    Cc: Olof Johansson <olof@lixom.net>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index ed19bc314318..74ed81a3cb1a 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -419,26 +419,14 @@ static void notrace ixp4xx_update_sched_clock(void)
 /*
  * clocksource
  */
-static cycle_t ixp4xx_get_cycles(struct clocksource *cs)
-{
-	return *IXP4XX_OSTS;
-}
-
-static struct clocksource clocksource_ixp4xx = {
-	.name 		= "OSTS",
-	.rating		= 200,
-	.read		= ixp4xx_get_cycles,
-	.mask		= CLOCKSOURCE_MASK(32),
-	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
-};
-
 unsigned long ixp4xx_timer_freq = IXP4XX_TIMER_FREQ;
 EXPORT_SYMBOL(ixp4xx_timer_freq);
 static void __init ixp4xx_clocksource_init(void)
 {
 	init_sched_clock(&cd, ixp4xx_update_sched_clock, 32, ixp4xx_timer_freq);
 
-	clocksource_register_hz(&clocksource_ixp4xx, ixp4xx_timer_freq);
+	clocksource_mmio_init(&IXP4XX_OSTS, "OSTS", ixp4xx_timer_freq, 200, 32,
+			clocksource_mmio_readl_up);
 }
 
 /*

commit f38c02f3b338651e145aac2889ba976baf6b28b3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 13:35:09 2011 +0100

    arm: Fold irq_set_chip/irq_set_handler
    
    Use irq_set_chip_and_handler() instead. Converted with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index eca559071185..ed19bc314318 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -252,8 +252,8 @@ void __init ixp4xx_init_irq(void)
 
         /* Default to all level triggered */
 	for(i = 0; i < NR_IRQS; i++) {
-		irq_set_chip(i, &ixp4xx_irq_chip);
-		irq_set_handler(i, handle_level_irq);
+		irq_set_chip_and_handler(i, &ixp4xx_irq_chip,
+					 handle_level_irq);
 		set_irq_flags(i, IRQF_VALID);
 	}
 }

commit 6845664a6a7d443f03883db59d10749d38d98b8e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 13:25:22 2011 +0100

    arm: Cleanup the irq namespace
    
    Convert to the new function names. Automated with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 9fd894271d5d..eca559071185 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -252,8 +252,8 @@ void __init ixp4xx_init_irq(void)
 
         /* Default to all level triggered */
 	for(i = 0; i < NR_IRQS; i++) {
-		set_irq_chip(i, &ixp4xx_irq_chip);
-		set_irq_handler(i, handle_level_irq);
+		irq_set_chip(i, &ixp4xx_irq_chip);
+		irq_set_handler(i, handle_level_irq);
 		set_irq_flags(i, IRQF_VALID);
 	}
 }

commit e66a022a80d73b1a5d2e02c9db2c42e8b9853b40
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Sat Dec 11 20:17:54 2010 +0000

    arm/ixp4xx: Rename FREQ macro to avoid collisions
    
    FREQ is a ridiculously short name for a platform-specific macro in a
    generic header, and it now conflicts with an enumeration in the
    gspca/ov519 driver.
    
    Also delete conditional reference to ixp4xx_get_board_tick_rate()
    which is not defined anywhere.
    
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 4dc68d6bb6be..9fd894271d5d 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -432,7 +432,7 @@ static struct clocksource clocksource_ixp4xx = {
 	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
-unsigned long ixp4xx_timer_freq = FREQ;
+unsigned long ixp4xx_timer_freq = IXP4XX_TIMER_FREQ;
 EXPORT_SYMBOL(ixp4xx_timer_freq);
 static void __init ixp4xx_clocksource_init(void)
 {
@@ -496,7 +496,7 @@ static struct clock_event_device clockevent_ixp4xx = {
 
 static void __init ixp4xx_clockevent_init(void)
 {
-	clockevent_ixp4xx.mult = div_sc(FREQ, NSEC_PER_SEC,
+	clockevent_ixp4xx.mult = div_sc(IXP4XX_TIMER_FREQ, NSEC_PER_SEC,
 					clockevent_ixp4xx.shift);
 	clockevent_ixp4xx.max_delta_ns =
 		clockevent_delta2ns(0xfffffffe, &clockevent_ixp4xx);

commit ee04087add7fa429fd1e4256705479cd1386adec
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Mon Nov 29 10:33:49 2010 +0100

    ARM: ixp4xx: irq_data conversion.
    
    Signed-off-by: Lennert Buytenhek <buytenh@secretlab.ca>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 4dbfcbb9163c..4dc68d6bb6be 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -128,9 +128,9 @@ int irq_to_gpio(unsigned int irq)
 }
 EXPORT_SYMBOL(irq_to_gpio);
 
-static int ixp4xx_set_irq_type(unsigned int irq, unsigned int type)
+static int ixp4xx_set_irq_type(struct irq_data *d, unsigned int type)
 {
-	int line = irq2gpio[irq];
+	int line = irq2gpio[d->irq];
 	u32 int_style;
 	enum ixp4xx_irq_type irq_type;
 	volatile u32 *int_reg;
@@ -167,9 +167,9 @@ static int ixp4xx_set_irq_type(unsigned int irq, unsigned int type)
 	}
 
 	if (irq_type == IXP4XX_IRQ_EDGE)
-		ixp4xx_irq_edge |= (1 << irq);
+		ixp4xx_irq_edge |= (1 << d->irq);
 	else
-		ixp4xx_irq_edge &= ~(1 << irq);
+		ixp4xx_irq_edge &= ~(1 << d->irq);
 
 	if (line >= 8) {	/* pins 8-15 */
 		line -= 8;
@@ -188,22 +188,22 @@ static int ixp4xx_set_irq_type(unsigned int irq, unsigned int type)
 	*int_reg |= (int_style << (line * IXP4XX_GPIO_STYLE_SIZE));
 
 	/* Configure the line as an input */
-	gpio_line_config(irq2gpio[irq], IXP4XX_GPIO_IN);
+	gpio_line_config(irq2gpio[d->irq], IXP4XX_GPIO_IN);
 
 	return 0;
 }
 
-static void ixp4xx_irq_mask(unsigned int irq)
+static void ixp4xx_irq_mask(struct irq_data *d)
 {
-	if ((cpu_is_ixp46x() || cpu_is_ixp43x()) && irq >= 32)
-		*IXP4XX_ICMR2 &= ~(1 << (irq - 32));
+	if ((cpu_is_ixp46x() || cpu_is_ixp43x()) && d->irq >= 32)
+		*IXP4XX_ICMR2 &= ~(1 << (d->irq - 32));
 	else
-		*IXP4XX_ICMR &= ~(1 << irq);
+		*IXP4XX_ICMR &= ~(1 << d->irq);
 }
 
-static void ixp4xx_irq_ack(unsigned int irq)
+static void ixp4xx_irq_ack(struct irq_data *d)
 {
-	int line = (irq < 32) ? irq2gpio[irq] : -1;
+	int line = (d->irq < 32) ? irq2gpio[d->irq] : -1;
 
 	if (line >= 0)
 		*IXP4XX_GPIO_GPISR = (1 << line);
@@ -213,23 +213,23 @@ static void ixp4xx_irq_ack(unsigned int irq)
  * Level triggered interrupts on GPIO lines can only be cleared when the
  * interrupt condition disappears.
  */
-static void ixp4xx_irq_unmask(unsigned int irq)
+static void ixp4xx_irq_unmask(struct irq_data *d)
 {
-	if (!(ixp4xx_irq_edge & (1 << irq)))
-		ixp4xx_irq_ack(irq);
+	if (!(ixp4xx_irq_edge & (1 << d->irq)))
+		ixp4xx_irq_ack(d);
 
-	if ((cpu_is_ixp46x() || cpu_is_ixp43x()) && irq >= 32)
-		*IXP4XX_ICMR2 |= (1 << (irq - 32));
+	if ((cpu_is_ixp46x() || cpu_is_ixp43x()) && d->irq >= 32)
+		*IXP4XX_ICMR2 |= (1 << (d->irq - 32));
 	else
-		*IXP4XX_ICMR |= (1 << irq);
+		*IXP4XX_ICMR |= (1 << d->irq);
 }
 
 static struct irq_chip ixp4xx_irq_chip = {
 	.name		= "IXP4xx",
-	.ack		= ixp4xx_irq_ack,
-	.mask		= ixp4xx_irq_mask,
-	.unmask		= ixp4xx_irq_unmask,
-	.set_type	= ixp4xx_set_irq_type,
+	.irq_ack	= ixp4xx_irq_ack,
+	.irq_mask	= ixp4xx_irq_mask,
+	.irq_unmask	= ixp4xx_irq_unmask,
+	.irq_set_type	= ixp4xx_set_irq_type,
 };
 
 void __init ixp4xx_init_irq(void)

commit 5b0d495c067d843c52fc1f9edbca29d5e9368b10
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Dec 15 21:23:13 2010 +0000

    ARM: ixp4xx: convert sched_clock() to use new infrastructure
    
    Convert ixp4xx to use the new sched_clock() infrastructure for
    extending 32bit counters to full 64-bit nanoseconds.
    
    Tested-by: Mikael Pettersson <mikpe@it.uu.se>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index e0b91d8ef644..4dbfcbb9163c 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -35,6 +35,7 @@
 #include <asm/pgtable.h>
 #include <asm/page.h>
 #include <asm/irq.h>
+#include <asm/sched_clock.h>
 
 #include <asm/mach/map.h>
 #include <asm/mach/irq.h>
@@ -398,6 +399,23 @@ void __init ixp4xx_sys_init(void)
 			ixp4xx_exp_bus_size >> 20);
 }
 
+/*
+ * sched_clock()
+ */
+static DEFINE_CLOCK_DATA(cd);
+
+unsigned long long notrace sched_clock(void)
+{
+	u32 cyc = *IXP4XX_OSTS;
+	return cyc_to_sched_clock(&cd, cyc, (u32)~0);
+}
+
+static void notrace ixp4xx_update_sched_clock(void)
+{
+	u32 cyc = *IXP4XX_OSTS;
+	update_sched_clock(&cd, cyc, (u32)~0);
+}
+
 /*
  * clocksource
  */
@@ -418,18 +436,9 @@ unsigned long ixp4xx_timer_freq = FREQ;
 EXPORT_SYMBOL(ixp4xx_timer_freq);
 static void __init ixp4xx_clocksource_init(void)
 {
-	clocksource_register_hz(&clocksource_ixp4xx, ixp4xx_timer_freq);
-}
-
-/*
- * sched_clock()
- */
-unsigned long long notrace sched_clock(void)
-{
-	cycle_t cyc = ixp4xx_get_cycles(NULL);
-	struct clocksource *cs = &clocksource_ixp4xx;
+	init_sched_clock(&cd, ixp4xx_update_sched_clock, 32, ixp4xx_timer_freq);
 
-	return clocksource_cyc2ns(cyc, cs->mult, cs->shift);
+	clocksource_register_hz(&clocksource_ixp4xx, ixp4xx_timer_freq);
 }
 
 /*

commit 5e06b6492e53ab2a4e467763a9ee9f70b032c301
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Dec 15 19:19:25 2010 +0000

    ARM: ensure all sched_clock() implementations are notrace marked
    
    ftrace requires sched_clock() to be notrace.  Ensure that all
    implementations are so marked.  Also make sure that they include
    linux/sched.h
    
    Also ensure OMAP clocksource read functions are marked notrace as
    they're used for sched_clock() too.
    
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Will Deacon <will.deacon@arm.com>
    Tested-by: Mikael Pettersson <mikpe@it.uu.se>
    Tested-by: Eric Miao <eric.y.miao@gmail.com>
    Tested-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 82fc003aae8b..e0b91d8ef644 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -424,7 +424,7 @@ static void __init ixp4xx_clocksource_init(void)
 /*
  * sched_clock()
  */
-unsigned long long sched_clock(void)
+unsigned long long notrace sched_clock(void)
 {
 	cycle_t cyc = ixp4xx_get_cycles(NULL);
 	struct clocksource *cs = &clocksource_ixp4xx;

commit b7c7c50adcf0d9c901542c5db8d795fe226bb454
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Dec 13 13:17:40 2010 +0000

    ARM: ixp4xx: update clock source registration
    
    In d7e81c2 (clocksource: Add clocksource_register_hz/khz interface) new
    interfaces were added which simplify (and optimize) the selection of the
    divisor shift/mult constants.  Switch over to using this new interface.
    
    Tested-by: Mikael Pettersson <mikpe@it.uu.se>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 0bce09799d18..82fc003aae8b 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -411,7 +411,6 @@ static struct clocksource clocksource_ixp4xx = {
 	.rating		= 200,
 	.read		= ixp4xx_get_cycles,
 	.mask		= CLOCKSOURCE_MASK(32),
-	.shift 		= 20,
 	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
@@ -419,10 +418,7 @@ unsigned long ixp4xx_timer_freq = FREQ;
 EXPORT_SYMBOL(ixp4xx_timer_freq);
 static void __init ixp4xx_clocksource_init(void)
 {
-	clocksource_ixp4xx.mult =
-		clocksource_hz2mult(ixp4xx_timer_freq,
-				    clocksource_ixp4xx.shift);
-	clocksource_register(&clocksource_ixp4xx);
+	clocksource_register_hz(&clocksource_ixp4xx, ixp4xx_timer_freq);
 }
 
 /*

commit 6262c92f51ffb074800d5a340ee16bc06758e037
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Mar 25 17:06:19 2010 +0000

    ARM: Remove useless linux/bootmem.h includes
    
    These files include linux/bootmem.h without using anything from this
    file; remove the unnecessary include.
    
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 71728d36d501..0bce09799d18 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -21,7 +21,6 @@
 #include <linux/tty.h>
 #include <linux/platform_device.h>
 #include <linux/serial_core.h>
-#include <linux/bootmem.h>
 #include <linux/interrupt.h>
 #include <linux/bitops.h>
 #include <linux/time.h>

commit e00d9d4b1796dae3adf6e39c9a766e760dd1c796
Author: Mikael Pettersson <mikpe@it.uu.se>
Date:   Sat Jan 9 13:03:59 2010 +0100

    ARM: 5869/1: ixp4xx: implement sched_clock()
    
    Add a better sched_clock() to the ixp4xx platform,
    implemented via its clocksource support.
    
    This is based on the sched_clock() I implemented for
    the IOP platform. Tested on a ds101 ixp420 machine.
    
    Signed-off-by: Mikael Pettersson <mikpe@it.uu.se>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 3bbf40f6d964..71728d36d501 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -426,6 +426,17 @@ static void __init ixp4xx_clocksource_init(void)
 	clocksource_register(&clocksource_ixp4xx);
 }
 
+/*
+ * sched_clock()
+ */
+unsigned long long sched_clock(void)
+{
+	cycle_t cyc = ixp4xx_get_cycles(NULL);
+	struct clocksource *cs = &clocksource_ixp4xx;
+
+	return clocksource_cyc2ns(cyc, cs->mult, cs->shift);
+}
+
 /*
  * clockevents
  */

commit efec194f576eebca8b0b3ac6e96fea05ae4567c9
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Tue Nov 3 23:05:32 2009 +0100

    IXP4xx: Ensure index is positive in irq_to_gpio() and npe_request().
    
    The indexes were signed, so negatives were possible.
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index cfd52fb341cb..3bbf40f6d964 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -117,7 +117,7 @@ int gpio_to_irq(int gpio)
 }
 EXPORT_SYMBOL(gpio_to_irq);
 
-int irq_to_gpio(int irq)
+int irq_to_gpio(unsigned int irq)
 {
 	int gpio = (irq < 32) ? irq2gpio[irq] : -EINVAL;
 

commit ceb69a899f0819bce825083bd487c6afacc0d1b4
Author: Mikael Pettersson <mikpe@it.uu.se>
Date:   Fri Sep 11 00:59:07 2009 +0200

    ixp4xx: timer and clocks cleanups
    
    This patch does a few simple cleanups of the ixp4xx timer
    and clocksource/clockevent code in mach-ixp4xx/common.c:
    
    - ixp4xx_clocksource_init() is static and always returns 0,
      which is ignored by its only caller: make it return void
    - ixp4xx_clockevent_init(): ditto
    - ixp4xx_get_cycles() is only referenced locally: make it static
    - use the ixp4xx_timer_irq.dev_id field to pass &clockevent_ixp4xx
      to ixp4xx_timer_interrupt() via its dev_id parameter, allowing
      the code in ixp4xx_timer_interrupt() to be smaller and faster
    
    Tested on an ixp420 machine (ds101).
    
    Signed-off-by: Mikael Pettersson <mikpe@it.uu.se>
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 5083f03e9b5e..cfd52fb341cb 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -41,8 +41,8 @@
 #include <asm/mach/irq.h>
 #include <asm/mach/time.h>
 
-static int __init ixp4xx_clocksource_init(void);
-static int __init ixp4xx_clockevent_init(void);
+static void __init ixp4xx_clocksource_init(void);
+static void __init ixp4xx_clockevent_init(void);
 static struct clock_event_device clockevent_ixp4xx;
 
 /*************************************************************************
@@ -267,7 +267,7 @@ void __init ixp4xx_init_irq(void)
 
 static irqreturn_t ixp4xx_timer_interrupt(int irq, void *dev_id)
 {
-	struct clock_event_device *evt = &clockevent_ixp4xx;
+	struct clock_event_device *evt = dev_id;
 
 	/* Clear Pending Interrupt by writing '1' to it */
 	*IXP4XX_OSST = IXP4XX_OSST_TIMER_1_PEND;
@@ -281,6 +281,7 @@ static struct irqaction ixp4xx_timer_irq = {
 	.name		= "timer1",
 	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
 	.handler	= ixp4xx_timer_interrupt,
+	.dev_id		= &clockevent_ixp4xx,
 };
 
 void __init ixp4xx_timer_init(void)
@@ -401,7 +402,7 @@ void __init ixp4xx_sys_init(void)
 /*
  * clocksource
  */
-cycle_t ixp4xx_get_cycles(struct clocksource *cs)
+static cycle_t ixp4xx_get_cycles(struct clocksource *cs)
 {
 	return *IXP4XX_OSTS;
 }
@@ -417,14 +418,12 @@ static struct clocksource clocksource_ixp4xx = {
 
 unsigned long ixp4xx_timer_freq = FREQ;
 EXPORT_SYMBOL(ixp4xx_timer_freq);
-static int __init ixp4xx_clocksource_init(void)
+static void __init ixp4xx_clocksource_init(void)
 {
 	clocksource_ixp4xx.mult =
 		clocksource_hz2mult(ixp4xx_timer_freq,
 				    clocksource_ixp4xx.shift);
 	clocksource_register(&clocksource_ixp4xx);
-
-	return 0;
 }
 
 /*
@@ -480,7 +479,7 @@ static struct clock_event_device clockevent_ixp4xx = {
 	.set_next_event	= ixp4xx_set_next_event,
 };
 
-static int __init ixp4xx_clockevent_init(void)
+static void __init ixp4xx_clockevent_init(void)
 {
 	clockevent_ixp4xx.mult = div_sc(FREQ, NSEC_PER_SEC,
 					clockevent_ixp4xx.shift);
@@ -491,5 +490,4 @@ static int __init ixp4xx_clockevent_init(void)
 	clockevent_ixp4xx.cpumask = cpumask_of(0);
 
 	clockevents_register_device(&clockevent_ixp4xx);
-	return 0;
 }

commit 5dbc46506a4f7b9f564bb7589a49ed32bc1caa15
Author: Krzysztof Halasa <khc@pm.waw.pl>
Date:   Sat Sep 5 03:59:49 2009 +0000

    IXP42x HSS support for setting internal clock rate
    
    HSS usually uses external clocks, so it's not a big deal. Internal clock
    is used for direct DTE-DTE connections and when the DCE doesn't provide
    it's own clock.
    
    This also depends on the oscillator frequency. Intel seems to have
    calculated the clock register settings for 33.33 MHz (66.66 MHz timer
    base). Their settings seem quite suboptimal both in terms of average
    frequency (60 ppm is unacceptable for G.703 applications, their primary
    intended usage(?)) and jitter.
    
    Many (most?) platforms use a 33.333 MHz oscillator, a 10 ppm difference
    from Intel's base.
    
    Instead of creating static tables, I've created a procedure to program
    the HSS clock register. The register consists of 3 parts (A, B, C).
    The average frequency (= bit rate) is:
    66.66x MHz / (A  + (B + 1) / (C + 1))
    The procedure aims at the closest average frequency, possibly at the
    cost of increased jitter. Nobody would be able to directly drive an
    unbufferred transmitter with a HSS anyway, and the frequency error is
    what it really counts.
    
    I've verified the above with an oscilloscope on IXP425. It seems IXP46x
    and possibly IXP43x use a bit different clock generation algorithm - it
    looks like the avg frequency is:
    (on IXP465) 66.66x MHz / (A  + B / (C + 1)).
    Also they use much greater precomputed A and B - on IXP425 it would
    simply result in more jitter, but I don't know how does it work on
    IXP46x (perhaps 3 least significant bits aren't used?).
    
    Anyway it looks that they were aiming for exactly +60 ppm or -60 ppm,
    while <1 ppm is typically possible (with a synchronized clock, of
    course).
    
    The attached patch makes it possible to set almost any bit rate
    (my IXP425 533 MHz quits at > 22 Mb/s if a single port is used, and the
    minimum is ca. 65 Kb/s).
    
    This is independent of MVIP (multi-E1/T1 on one HSS) mode.
    
    Signed-off-by: Krzysztof Hałasa <khc@pm.waw.pl>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 1e93dfee7543..5083f03e9b5e 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -416,6 +416,7 @@ static struct clocksource clocksource_ixp4xx = {
 };
 
 unsigned long ixp4xx_timer_freq = FREQ;
+EXPORT_SYMBOL(ixp4xx_timer_freq);
 static int __init ixp4xx_clocksource_init(void)
 {
 	clocksource_ixp4xx.mult =

commit 8e19608e8b5c001e4a66ce482edc474f05fb7355
Author: Magnus Damm <damm@igel.co.jp>
Date:   Tue Apr 21 12:24:00 2009 -0700

    clocksource: pass clocksource to read() callback
    
    Pass clocksource pointer to the read() callback for clocksources.  This
    allows us to share the callback between multiple instances.
    
    [hugh@veritas.com: fix powerpc build of clocksource pass clocksource mods]
    [akpm@linux-foundation.org: cleanup]
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Hugh Dickins <hugh@veritas.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index f4656d2ac8a8..1e93dfee7543 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -401,7 +401,7 @@ void __init ixp4xx_sys_init(void)
 /*
  * clocksource
  */
-cycle_t ixp4xx_get_cycles(void)
+cycle_t ixp4xx_get_cycles(struct clocksource *cs)
 {
 	return *IXP4XX_OSTS;
 }

commit 320ab2b0b1e08e3805a3e1084a2f0eb1938d5d67
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Sat Dec 13 21:20:26 2008 +1030

    cpumask: convert struct clock_event_device to cpumask pointers.
    
    Impact: change calling convention of existing clock_event APIs
    
    struct clock_event_timer's cpumask field gets changed to take pointer,
    as does the ->broadcast function.
    
    Another single-patch change.  For safety, we BUG_ON() in
    clockevents_register_device() if it's not set.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 7766f469456b..f4656d2ac8a8 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -487,7 +487,7 @@ static int __init ixp4xx_clockevent_init(void)
 		clockevent_delta2ns(0xfffffffe, &clockevent_ixp4xx);
 	clockevent_ixp4xx.min_delta_ns =
 		clockevent_delta2ns(0xf, &clockevent_ixp4xx);
-	clockevent_ixp4xx.cpumask = cpumask_of_cpu(0);
+	clockevent_ixp4xx.cpumask = cpumask_of(0);
 
 	clockevents_register_device(&clockevent_ixp4xx);
 	return 0;

commit fced80c735941fa518ac67c0b61bbe153fb8c050
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Sep 6 12:10:45 2008 +0100

    [ARM] Convert asm/io.h to linux/io.h
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 58bd2842a6f1..7766f469456b 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -28,11 +28,11 @@
 #include <linux/timex.h>
 #include <linux/clocksource.h>
 #include <linux/clockchips.h>
+#include <linux/io.h>
 
 #include <mach/udc.h>
 #include <mach/hardware.h>
 #include <asm/uaccess.h>
-#include <asm/io.h>
 #include <asm/pgtable.h>
 #include <asm/page.h>
 #include <asm/irq.h>

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 00cede2b7a42..58bd2842a6f1 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -29,8 +29,8 @@
 #include <linux/clocksource.h>
 #include <linux/clockchips.h>
 
-#include <asm/arch/udc.h>
-#include <asm/arch/hardware.h>
+#include <mach/udc.h>
+#include <mach/hardware.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/pgtable.h>

commit be509729356b7433f73df2b9a966674a437fbbc1
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Aug 4 10:41:28 2008 +0100

    [ARM] Remove asm/hardware.h, use asm/arch/hardware.h instead
    
    Remove includes of asm/hardware.h in addition to asm/arch/hardware.h.
    Then, since asm/hardware.h only exists to include asm/arch/hardware.h,
    update everything to directly include asm/arch/hardware.h and remove
    asm/hardware.h.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 3947c506b4f3..00cede2b7a42 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -30,7 +30,7 @@
 #include <linux/clockchips.h>
 
 #include <asm/arch/udc.h>
-#include <asm/hardware.h>
+#include <asm/arch/hardware.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/pgtable.h>

commit 6cab48602996cdbcb277375a8107d53e21e8c9b9
Author: Dmitry Baryshkov <dbaryshkov@gmail.com>
Date:   Sun Jul 27 04:23:31 2008 +0100

    [ARM] 5179/1: Replace obsolete IRQT_* and __IRQT_* values with IRQ_TYPE_*
    
    IRQT_* and __IRQT_* were obsoleted long ago by patch [3692/1].
    Remove them completely. Sed script for the reference:
    
    s/__IRQT_RISEDGE/IRQ_TYPE_EDGE_RISING/g
    s/__IRQT_FALEDGE/IRQ_TYPE_EDGE_FALLING/g
    s/__IRQT_LOWLVL/IRQ_TYPE_LEVEL_LOW/g
    s/__IRQT_HIGHLVL/IRQ_TYPE_LEVEL_HIGH/g
    s/IRQT_RISING/IRQ_TYPE_EDGE_RISING/g
    s/IRQT_FALLING/IRQ_TYPE_EDGE_FALLING/g
    s/IRQT_BOTHEDGE/IRQ_TYPE_EDGE_BOTH/g
    s/IRQT_LOW/IRQ_TYPE_LEVEL_LOW/g
    s/IRQT_HIGH/IRQ_TYPE_LEVEL_HIGH/g
    s/IRQT_PROBE/IRQ_TYPE_PROBE/g
    s/IRQT_NOEDGE/IRQ_TYPE_NONE/g
    
    Signed-off-by: Dmitry Baryshkov <dbaryshkov@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 3781b3db9f49..3947c506b4f3 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -142,23 +142,23 @@ static int ixp4xx_set_irq_type(unsigned int irq, unsigned int type)
 		return -EINVAL;
 
 	switch (type){
-	case IRQT_BOTHEDGE:
+	case IRQ_TYPE_EDGE_BOTH:
 		int_style = IXP4XX_GPIO_STYLE_TRANSITIONAL;
 		irq_type = IXP4XX_IRQ_EDGE;
 		break;
-	case IRQT_RISING:
+	case IRQ_TYPE_EDGE_RISING:
 		int_style = IXP4XX_GPIO_STYLE_RISING_EDGE;
 		irq_type = IXP4XX_IRQ_EDGE;
 		break;
-	case IRQT_FALLING:
+	case IRQ_TYPE_EDGE_FALLING:
 		int_style = IXP4XX_GPIO_STYLE_FALLING_EDGE;
 		irq_type = IXP4XX_IRQ_EDGE;
 		break;
-	case IRQT_HIGH:
+	case IRQ_TYPE_LEVEL_HIGH:
 		int_style = IXP4XX_GPIO_STYLE_ACTIVE_HIGH;
 		irq_type = IXP4XX_IRQ_LEVEL;
 		break;
-	case IRQT_LOW:
+	case IRQ_TYPE_LEVEL_LOW:
 		int_style = IXP4XX_GPIO_STYLE_ACTIVE_LOW;
 		irq_type = IXP4XX_IRQ_LEVEL;
 		break;

commit 7a8576204333d133d58cbcc59dacf49a5546e3e4
Author: Philipp Zabel <philipp.zabel@gmail.com>
Date:   Sun Jun 22 23:36:39 2008 +0100

    [ARM] 5120/1: pxa: correct platform driver names for PXA25x and PXA27x UDC drivers
    
    The pxa2xx_udc.c driver is renamed to pxa25x_udc.c (the platform
    driver name changes from pxa2xx-udc to pxa25x-udc) and the
    platform driver name of pxa27x_udc.c is fixed to pxa27x-udc.
    pxa_device_udc in devices.c is split into pxa25x and pxa27x flavors
    and the pxa27x_device_udc is enabled in pxa27x.c.
    
    Signed-off-by: Philipp Zabel <philipp.zabel@gmail.com>
    Acked-by: Nicolas Pitre <nico@cam.org>
    Acked-by: Eric Miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    
    Including from Ian Molton:
    
    Fixes for mistakes left over from the PXA2{5,7}X UDC split.
    
    Signed-off-by: Ian Molton <spyro@f2s.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index f6d66dce6852..3781b3db9f49 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -326,11 +326,11 @@ static struct resource ixp4xx_udc_resources[] = {
 };
 
 /*
- * USB device controller. The IXP4xx uses the same controller as PXA2XX,
+ * USB device controller. The IXP4xx uses the same controller as PXA25X,
  * so we just use the same device.
  */
 static struct platform_device ixp4xx_udc_device = {
-	.name           = "pxa2xx-udc",
+	.name           = "pxa25x-udc",
 	.id             = -1,
 	.num_resources  = 2,
 	.resource       = ixp4xx_udc_resources,

commit 553876c802249b21267b78a9b3857d1341a3df87
Author: Kevin Hilman <khilman@mvista.com>
Date:   Wed Dec 12 00:32:58 2007 +0100

    [ARM] 4694/1: IXP4xx: Update clockevent support for shutdown and resume
    
    Add proper support for CLOCK_EVT_MODE_RESUME and in the process fix
    CLOCK_EVT_MODE_SHUTDOWN so that only the enable bits are toggled for both.
    
    Signed-off-by: Kevin Hilman <khilman@mvista.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index c1271c449246..f6d66dce6852 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -442,7 +442,8 @@ static int ixp4xx_set_next_event(unsigned long evt,
 static void ixp4xx_set_mode(enum clock_event_mode mode,
 			    struct clock_event_device *evt)
 {
-	unsigned long opts, osrt = *IXP4XX_OSRT1 & ~IXP4XX_OST_RELOAD_MASK;
+	unsigned long opts = *IXP4XX_OSRT1 & IXP4XX_OST_RELOAD_MASK;
+	unsigned long osrt = *IXP4XX_OSRT1 & ~IXP4XX_OST_RELOAD_MASK;
 
 	switch (mode) {
 	case CLOCK_EVT_MODE_PERIODIC:
@@ -455,12 +456,15 @@ static void ixp4xx_set_mode(enum clock_event_mode mode,
 		opts = IXP4XX_OST_ENABLE | IXP4XX_OST_ONE_SHOT;
 		break;
 	case CLOCK_EVT_MODE_SHUTDOWN:
+		opts &= ~IXP4XX_OST_ENABLE;
+		break;
+	case CLOCK_EVT_MODE_RESUME:
+		opts |= IXP4XX_OST_ENABLE;
+		break;
 	case CLOCK_EVT_MODE_UNUSED:
 	default:
 		osrt = opts = 0;
 		break;
-	case CLOCK_EVT_MODE_RESUME:
-		break;
 	}
 
 	*IXP4XX_OSRT1 = osrt | opts;

commit 7578634990fb47cc30083fbd812689aa6deacfc0
Merge: d7f5e3df3574 5957a4eb284d
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Sun Jul 22 11:22:59 2007 -0700

    Merge branch 'devel' of master.kernel.org:/home/rmk/linux-2.6-arm
    
    * 'devel' of master.kernel.org:/home/rmk/linux-2.6-arm: (60 commits)
      [ARM] 4524/1: S3C: Move register out of include/asm-arm/arch-s3c2410
      [ARM] 4523/1: S3C: Remove FIFO_MAX from uncompression headers
      [ARM] 4522/1: S3C: split include/asm-arm/arch/memory.h
      [ARM] 4521/2: S3C: Reorganise VA mapping headers
      [ARM] 4520/1: S3C: Remove old VA values from static map
      [ARM] 4519/1: S3C: split S3C2400 values out of S3C24XX map.h
      [ARM] 4518/1: S3C: Rename watchdog configuration options
      [ARM] 4517/1: S3C: Fix debug macros for ARM926 output
      [ARM] 4516/1: S3C: Fix uncompressor serial output for ARM926
      [ARM] 4515/1: S3C: Move uncompress code to plat-s3c
      [ARM] 4514/1: S3C: Rename DEBUG_S3C2410_PORT and DEBUG_S3C_UART
      [ARM] 4513/1: S3C: Rename CONFIG_S3C2410_LOWLEVEL_UART_PORT
      [ARM] 4512/1: S3C: rename the debug macros for per-cpu updates
      [ARM] 4511/1: S3C: updated LLSERIAL Kconfig defines for CPU support
      [ARM] 4510/1: S3C: split debug-macro support into plat-s3c
      [ARM] 4509/1: S3C: Create initial arch/arm/plat-s3c
      [ARM] 4508/1: S3C: Move items to include/asm-arm/plat-s3c
      [ARM] 4461/1: MXC platform and i.MX31ADS core support
      [ARM] 4507/1: pxa2xx clock_event_device
      [ARM] 4497/1: Only allow safe cache configurations on ARMv6 and later
      ...

commit 18de5bc4c1f1f1fa5e14f354a7603bd6e9d4e3b6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 21 04:37:34 2007 -0700

    clockevents: fix resume logic
    
    We need to make sure, that the clockevent devices are resumed, before
    the tick is resumed. The current resume logic does not guarantee this.
    
    Add CLOCK_EVT_MODE_RESUME and call the set mode functions of the clock
    event devices before resuming the tick / oneshot functionality.
    
    Fixup the existing users.
    
    Thanks to Nigel Cunningham for tracking down a long standing thinko,
    which affected the jinxed VAIO.
    
    [akpm@linux-foundation.org: xen build fix]
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 8112f726ffa0..23e7fba6d3e1 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -459,6 +459,8 @@ static void ixp4xx_set_mode(enum clock_event_mode mode,
 	default:
 		osrt = opts = 0;
 		break;
+	case CLOCK_EVT_MODE_RESUME:
+		break;
 	}
 
 	*IXP4XX_OSRT1 = osrt | opts;

commit 5c9b9123b35e28dd7cb3012f3f8d4ea13a30631c
Author: Tim Harvey <tim_harvey@yahoo.com>
Date:   Sat Jul 14 11:15:05 2007 +0200

    [ARM] ixp4xx: fix IRQ GPIO direction configuration for GPIOs >= 8
    
    I believe that the following patch is necessary to properly configure
    GPIO line configuration for IRQ's which are mapped to a GPIO line >= 8
    (without this patch the wrong GPIO is configured as an input.)
    
    Signed-off-by: Tim Harvey <tim_harvey@yahoo.com>
    Signed-off-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 8112f726ffa0..4c54a86eda3a 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -188,7 +188,7 @@ static int ixp4xx_set_irq_type(unsigned int irq, unsigned int type)
 	*int_reg |= (int_style << (line * IXP4XX_GPIO_STYLE_SIZE));
 
 	/* Configure the line as an input */
-	gpio_line_config(line, IXP4XX_GPIO_IN);
+	gpio_line_config(irq2gpio[irq], IXP4XX_GPIO_IN);
 
 	return 0;
 }

commit 435c5da00b9610f9664c5d6f38dfdafce419ef4a
Author: Michael-Luke Jones <mlj28@cam.ac.uk>
Date:   Wed May 23 22:38:45 2007 +0100

    [ARM] 4405/1: NSLU2, DSM-G600 frequency fixup code
    
    This patch is required as the frequency fixup in nslu2_init does not
    run sufficiently early in the boot sequence to take effect. In addition
    the dsmg600 setup code behaviour has been improved such that a
    'fixup' routine is avoided.
    
    Signed-off-by: Michael-Luke Jones <mlj28@cam.ac.uk>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 64685da1462d..8112f726ffa0 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -283,7 +283,7 @@ static struct irqaction ixp4xx_timer_irq = {
 	.handler	= ixp4xx_timer_interrupt,
 };
 
-static void __init ixp4xx_timer_init(void)
+void __init ixp4xx_timer_init(void)
 {
 	/* Reset/disable counter */
 	*IXP4XX_OSRT1 = 0;

commit b30fabadae2b3c1a65e3662be98f105d5718db70
Author: Bernhard Walle <bwalle@suse.de>
Date:   Tue May 8 00:35:39 2007 -0700

    Add IRQF_IRQPOLL flag on arm
    
    Add IRQF_IRQPOLL for each timer interrupt.
    
    Signed-off-by: Bernhard Walle <bwalle@suse.de>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index f5cae1e46b7e..64685da1462d 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -279,7 +279,7 @@ static irqreturn_t ixp4xx_timer_interrupt(int irq, void *dev_id)
 
 static struct irqaction ixp4xx_timer_irq = {
 	.name		= "timer1",
-	.flags		= IRQF_DISABLED | IRQF_TIMER,
+	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
 	.handler	= ixp4xx_timer_interrupt,
 };
 

commit 5cd47155155a32e5b944ac9fc3f3dc578e429aa0
Merge: 6f95416ebe81 28bd3a0dcce1
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun May 6 20:58:29 2007 +0100

    Merge branch 'ixp4xx' into devel
    
    Conflicts:
    
            include/asm-arm/arch-ixp4xx/io.h

commit e32f1502be3fa459723b1e4105e014f0828f7513
Author: Kevin Hilman <khilman@mvista.com>
Date:   Thu Mar 8 20:23:59 2007 +0100

    [ARM] 4259/1: clockevent support for ixp4xx platform
    
    Update ixp4xx timer support to use new clockevent infrastructure.
    
    Signed-off-by: Kevin Hilman <khilman@mvista.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 45068c3d8dcc..09edea9779e6 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -27,6 +27,7 @@
 #include <linux/time.h>
 #include <linux/timex.h>
 #include <linux/clocksource.h>
+#include <linux/clockchips.h>
 
 #include <asm/arch/udc.h>
 #include <asm/hardware.h>
@@ -41,6 +42,8 @@
 #include <asm/mach/time.h>
 
 static int __init ixp4xx_clocksource_init(void);
+static int __init ixp4xx_clockevent_init(void);
+static struct clock_event_device clockevent_ixp4xx;
 
 /*************************************************************************
  * IXP4xx chipset I/O mapping
@@ -239,52 +242,40 @@ void __init ixp4xx_init_irq(void)
  * counter as a source of real clock ticks to account for missed jiffies.
  *************************************************************************/
 
-static unsigned volatile last_jiffy_time;
-
-#define CLOCK_TICKS_PER_USEC	((CLOCK_TICK_RATE + USEC_PER_SEC/2) / USEC_PER_SEC)
-
 static irqreturn_t ixp4xx_timer_interrupt(int irq, void *dev_id)
 {
-	write_seqlock(&xtime_lock);
+	struct clock_event_device *evt = &clockevent_ixp4xx;
 
 	/* Clear Pending Interrupt by writing '1' to it */
 	*IXP4XX_OSST = IXP4XX_OSST_TIMER_1_PEND;
 
-	/*
-	 * Catch up with the real idea of time
-	 */
-	while ((signed long)(*IXP4XX_OSTS - last_jiffy_time) >= LATCH) {
-		timer_tick();
-		last_jiffy_time += LATCH;
-	}
-
-	write_sequnlock(&xtime_lock);
+	evt->event_handler(evt);
 
 	return IRQ_HANDLED;
 }
 
 static struct irqaction ixp4xx_timer_irq = {
-	.name		= "IXP4xx Timer Tick",
+	.name		= "timer1",
 	.flags		= IRQF_DISABLED | IRQF_TIMER,
 	.handler	= ixp4xx_timer_interrupt,
 };
 
 static void __init ixp4xx_timer_init(void)
 {
+	/* Reset/disable counter */
+	*IXP4XX_OSRT1 = 0;
+
 	/* Clear Pending Interrupt by writing '1' to it */
 	*IXP4XX_OSST = IXP4XX_OSST_TIMER_1_PEND;
 
-	/* Setup the Timer counter value */
-	*IXP4XX_OSRT1 = (LATCH & ~IXP4XX_OST_RELOAD_MASK) | IXP4XX_OST_ENABLE;
-
 	/* Reset time-stamp counter */
 	*IXP4XX_OSTS = 0;
-	last_jiffy_time = 0;
 
 	/* Connect the interrupt handler and enable the interrupt */
 	setup_irq(IRQ_IXP4XX_TIMER1, &ixp4xx_timer_irq);
 
 	ixp4xx_clocksource_init();
+	ixp4xx_clockevent_init();
 }
 
 struct sys_timer ixp4xx_timer = {
@@ -384,6 +375,9 @@ void __init ixp4xx_sys_init(void)
 			ixp4xx_exp_bus_size >> 20);
 }
 
+/*
+ * clocksource
+ */
 cycle_t ixp4xx_get_cycles(void)
 {
 	return *IXP4XX_OSTS;
@@ -408,3 +402,64 @@ static int __init ixp4xx_clocksource_init(void)
 
 	return 0;
 }
+
+/*
+ * clockevents
+ */
+static int ixp4xx_set_next_event(unsigned long evt,
+				 struct clock_event_device *unused)
+{
+	unsigned long opts = *IXP4XX_OSRT1 & IXP4XX_OST_RELOAD_MASK;
+
+	*IXP4XX_OSRT1 = (evt & ~IXP4XX_OST_RELOAD_MASK) | opts;
+
+	return 0;
+}
+
+static void ixp4xx_set_mode(enum clock_event_mode mode,
+			    struct clock_event_device *evt)
+{
+	unsigned long opts, osrt = *IXP4XX_OSRT1 & ~IXP4XX_OST_RELOAD_MASK;
+
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		osrt = LATCH & ~IXP4XX_OST_RELOAD_MASK;
+ 		opts = IXP4XX_OST_ENABLE;
+		break;
+	case CLOCK_EVT_MODE_ONESHOT:
+		/* period set by 'set next_event' */
+		osrt = 0;
+		opts = IXP4XX_OST_ENABLE | IXP4XX_OST_ONE_SHOT;
+		break;
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	case CLOCK_EVT_MODE_UNUSED:
+	default:
+		osrt = opts = 0;
+		break;
+	}
+
+	*IXP4XX_OSRT1 = osrt | opts;
+}
+
+static struct clock_event_device clockevent_ixp4xx = {
+	.name		= "ixp4xx timer1",
+	.features       = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+	.rating         = 200,
+	.shift		= 24,
+	.set_mode	= ixp4xx_set_mode,
+	.set_next_event	= ixp4xx_set_next_event,
+};
+
+static int __init ixp4xx_clockevent_init(void)
+{
+	clockevent_ixp4xx.mult = div_sc(FREQ, NSEC_PER_SEC,
+					clockevent_ixp4xx.shift);
+	clockevent_ixp4xx.max_delta_ns =
+		clockevent_delta2ns(0xfffffffe, &clockevent_ixp4xx);
+	clockevent_ixp4xx.min_delta_ns =
+		clockevent_delta2ns(0xf, &clockevent_ixp4xx);
+	clockevent_ixp4xx.cpumask = cpumask_of_cpu(0);
+
+	clockevents_register_device(&clockevent_ixp4xx);
+	return 0;
+}

commit 45fba0846f5a5a48ed3c394aa4f8ca93699e7655
Author: Ruslan V. Sushko <rsushko@ru.mvista.com>
Date:   Fri Apr 6 15:00:31 2007 +0100

    [ARM] 4311/1: ixp4xx: add KIXRP435 platform
    
    Add Intel KIXRP435 Reference Platform based on IXP43x processor.
    Fixed after review : access to cp15 removed in identification functions,
    used access to global processor_id instead
    
    Signed-off-by: Vladimir Barinov <vbarinov@ru.mvista.com>
    Signed-off-by: Ruslan  Sushko <rsushko@ru.mvista.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 39f2eeb219b4..030dd75d053a 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -192,7 +192,7 @@ static int ixp4xx_set_irq_type(unsigned int irq, unsigned int type)
 
 static void ixp4xx_irq_mask(unsigned int irq)
 {
-	if (cpu_is_ixp46x() && irq >= 32)
+	if ((cpu_is_ixp46x() || cpu_is_ixp43x()) && irq >= 32)
 		*IXP4XX_ICMR2 &= ~(1 << (irq - 32));
 	else
 		*IXP4XX_ICMR &= ~(1 << irq);
@@ -215,7 +215,7 @@ static void ixp4xx_irq_unmask(unsigned int irq)
 	if (!(ixp4xx_irq_edge & (1 << irq)))
 		ixp4xx_irq_ack(irq);
 
-	if (cpu_is_ixp46x() && irq >= 32)
+	if ((cpu_is_ixp46x() || cpu_is_ixp43x()) && irq >= 32)
 		*IXP4XX_ICMR2 |= (1 << (irq - 32));
 	else
 		*IXP4XX_ICMR |= (1 << irq);
@@ -239,7 +239,7 @@ void __init ixp4xx_init_irq(void)
 	/* Disable all interrupt */
 	*IXP4XX_ICMR = 0x0; 
 
-	if (cpu_is_ixp46x()) {
+	if (cpu_is_ixp46x() || cpu_is_ixp43x()) {
 		/* Route upper 32 sources to IRQ instead of FIQ */
 		*IXP4XX_ICLR2 = 0x00;
 

commit 25735d10ba477d5128b1e5ccef42062bea429075
Author: Milan Svoboda <msvoboda@ra.rockwell.com>
Date:   Wed Mar 21 14:04:08 2007 +0100

    [ARM] 4275/1: generic gpio layer for ixp4xx
    
    This patch brings generic gpio layer support to ixp4xx. It creates
    functions needed for gpio->irq and irq->gpio translation.
    
    It expects and initial value to be passed to
    gpio_direction_output() which has been introduced by
    commit 28735a7253a6c24364765e80a5428b4a151fccc2 in Linus git tree.
    
    Generic gpio layer is going to be used by pxa2xx_udc driver.
    
    Signed-off-by: Milan Svoboda <msvoboda@ra.rockwell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 45068c3d8dcc..39f2eeb219b4 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -102,6 +102,29 @@ static signed char irq2gpio[32] = {
 	 7,  8,  9, 10, 11, 12, -1, -1,
 };
 
+int gpio_to_irq(int gpio)
+{
+	int irq;
+
+	for (irq = 0; irq < 32; irq++) {
+		if (irq2gpio[irq] == gpio)
+			return irq;
+	}
+	return -EINVAL;
+}
+EXPORT_SYMBOL(gpio_to_irq);
+
+int irq_to_gpio(int irq)
+{
+	int gpio = (irq < 32) ? irq2gpio[irq] : -EINVAL;
+
+	if (gpio == -1)
+		return -EINVAL;
+
+	return gpio;
+}
+EXPORT_SYMBOL(irq_to_gpio);
+
 static int ixp4xx_set_irq_type(unsigned int irq, unsigned int type)
 {
 	int line = irq2gpio[irq];

commit c66699a749eb0d84c6ebc3aac659e9f71d1aba14
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 16 01:27:37 2007 -0800

    [PATCH] clocksource: fixup is_continous changes on ARM
    
    Fixup the is_contionous replacement by a flag field.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 2ec9a9e9a04d..45068c3d8dcc 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -395,7 +395,7 @@ static struct clocksource clocksource_ixp4xx = {
 	.read		= ixp4xx_get_cycles,
 	.mask		= CLOCKSOURCE_MASK(32),
 	.shift 		= 20,
-	.is_continuous 	= 1,
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
 unsigned long ixp4xx_timer_freq = FREQ;

commit f9a8ca1cabf09316d79cab7f04e1390261ff9035
Author: Kevin Hilman <khilman@mvista.com>
Date:   Wed Dec 6 00:45:07 2006 +0100

    [ARM] 3985/1: ixp4xx clocksource cleanup
    
    Rather than using a device_initcall() for the clocksource initialization, just call the init from the sys_timer init function.
    
    Signed-off-by: Kevin Hilman <khilman@mvista.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 1cf3bde1a5d2..2ec9a9e9a04d 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -40,6 +40,8 @@
 #include <asm/mach/irq.h>
 #include <asm/mach/time.h>
 
+static int __init ixp4xx_clocksource_init(void);
+
 /*************************************************************************
  * IXP4xx chipset I/O mapping
  *************************************************************************/
@@ -281,6 +283,8 @@ static void __init ixp4xx_timer_init(void)
 
 	/* Connect the interrupt handler and enable the interrupt */
 	setup_irq(IRQ_IXP4XX_TIMER1, &ixp4xx_timer_irq);
+
+	ixp4xx_clocksource_init();
 }
 
 struct sys_timer ixp4xx_timer = {
@@ -404,5 +408,3 @@ static int __init ixp4xx_clocksource_init(void)
 
 	return 0;
 }
-
-device_initcall(ixp4xx_clocksource_init);

commit e520a36de2f7985df5ef2e84a9f6d2608ecc6f25
Author: Milan Svoboda <msvoboda@ra.rockwell.com>
Date:   Fri Dec 1 11:36:41 2006 +0100

    [ARM] 3958/1: add platform device (pxa2xx-udc)to ixp4xx
    
    Create include/asm-arm/arch-ixp4xx/udc.h and
    add platfrom device ixp4xx_udc_device into
    arch/arm/mach-ixp4xx/common.c.
    
    This allows us to use pxa2xx-udc on
    the ixp4xx platfrom. Both pxa2xx and
    ixp4xx use the same device controller.
    
    Signed-off-by:Milan Svoboda <msvoboda@ra.rockwell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 074c96520246..1cf3bde1a5d2 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -28,6 +28,7 @@
 #include <linux/timex.h>
 #include <linux/clocksource.h>
 
+#include <asm/arch/udc.h>
 #include <asm/hardware.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -286,6 +287,44 @@ struct sys_timer ixp4xx_timer = {
 	.init		= ixp4xx_timer_init,
 };
 
+static struct pxa2xx_udc_mach_info ixp4xx_udc_info;
+
+void __init ixp4xx_set_udc_info(struct pxa2xx_udc_mach_info *info)
+{
+	memcpy(&ixp4xx_udc_info, info, sizeof *info);
+}
+
+static struct resource ixp4xx_udc_resources[] = {
+	[0] = {
+		.start  = 0xc800b000,
+		.end    = 0xc800bfff,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = IRQ_IXP4XX_USB,
+		.end    = IRQ_IXP4XX_USB,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+/*
+ * USB device controller. The IXP4xx uses the same controller as PXA2XX,
+ * so we just use the same device.
+ */
+static struct platform_device ixp4xx_udc_device = {
+	.name           = "pxa2xx-udc",
+	.id             = -1,
+	.num_resources  = 2,
+	.resource       = ixp4xx_udc_resources,
+	.dev            = {
+		.platform_data = &ixp4xx_udc_info,
+	},
+};
+
+static struct platform_device *ixp4xx_devices[] __initdata = {
+	&ixp4xx_udc_device,
+};
+
 static struct resource ixp46x_i2c_resources[] = {
 	[0] = {
 		.start 	= 0xc8011000,
@@ -321,6 +360,8 @@ void __init ixp4xx_sys_init(void)
 {
 	ixp4xx_exp_bus_size = SZ_16M;
 
+	platform_add_devices(ixp4xx_devices, ARRAY_SIZE(ixp4xx_devices));
+
 	if (cpu_is_ixp46x()) {
 		int region;
 

commit 10dd5ce28d78e2440e8fa1135d17e33399d75340
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Nov 23 11:41:32 2006 +0000

    [ARM] Remove compatibility layer for ARM irqs
    
    set_irq_chipdata -> set_irq_chip_data
    get_irq_chipdata -> get_irq_chip_data
    do_level_IRQ -> handle_level_irq
    do_edge_IRQ -> handle_edge_irq
    do_simple_IRQ -> handle_simple_irq
    irqdesc -> irq_desc
    irqchip -> irq_chip
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index fbe288a8da65..074c96520246 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -195,7 +195,7 @@ static void ixp4xx_irq_unmask(unsigned int irq)
 		*IXP4XX_ICMR |= (1 << irq);
 }
 
-static struct irqchip ixp4xx_irq_chip = {
+static struct irq_chip ixp4xx_irq_chip = {
 	.name		= "IXP4xx",
 	.ack		= ixp4xx_irq_ack,
 	.mask		= ixp4xx_irq_mask,
@@ -224,7 +224,7 @@ void __init ixp4xx_init_irq(void)
         /* Default to all level triggered */
 	for(i = 0; i < NR_IRQS; i++) {
 		set_irq_chip(i, &ixp4xx_irq_chip);
-		set_irq_handler(i, do_level_IRQ);
+		set_irq_handler(i, handle_level_irq);
 		set_irq_flags(i, IRQF_VALID);
 	}
 }

commit 984d115bbf2d731ed2264031fe49c1378d730db0
Author: Kevin Hilman <khilman@com.rmk.(none)>
Date:   Fri Nov 3 01:47:20 2006 +0100

    [ARM] 3918/1: ixp4xx irq-chip rework
    
    This is a rework of the ixp4xx irq_chip implementation.  The use of
    two irq_chip structures and potentially switching between them is a
    violation of the intended use of the IRQ framework.  The current
    implementation does not work with current in-kernel spinlock debugging
    or lockdep due to lock recursion problems caused by calling
    set_irq_chip/handler from within the chip's set_irq_type().
    
    This patch goes back to using one irq_chip structure and handling the
    differences between edge/level, normal/GPIO interrupts inside the
    ack/mask/unmask routines themselves.
    
    Signed-off-by: Kevin Hilman <khilman@mvista.com>
    Signed-off-by: Deepak Saxena <dsaxena@mvista.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index c7513f6eb50c..fbe288a8da65 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -86,7 +86,8 @@ enum ixp4xx_irq_type {
 	IXP4XX_IRQ_LEVEL, IXP4XX_IRQ_EDGE
 };
 
-static void ixp4xx_config_irq(unsigned irq, enum ixp4xx_irq_type type);
+/* Each bit represents an IRQ: 1: edge-triggered, 0: level triggered */
+static unsigned long long ixp4xx_irq_edge = 0;
 
 /*
  * IRQ -> GPIO mapping table
@@ -135,7 +136,11 @@ static int ixp4xx_set_irq_type(unsigned int irq, unsigned int type)
 	default:
 		return -EINVAL;
 	}
-	ixp4xx_config_irq(irq, irq_type);
+
+	if (irq_type == IXP4XX_IRQ_EDGE)
+		ixp4xx_irq_edge |= (1 << irq);
+	else
+		ixp4xx_irq_edge &= ~(1 << irq);
 
 	if (line >= 8) {	/* pins 8-15 */
 		line -= 8;
@@ -167,14 +172,6 @@ static void ixp4xx_irq_mask(unsigned int irq)
 		*IXP4XX_ICMR &= ~(1 << irq);
 }
 
-static void ixp4xx_irq_unmask(unsigned int irq)
-{
-	if (cpu_is_ixp46x() && irq >= 32)
-		*IXP4XX_ICMR2 |= (1 << (irq - 32));
-	else
-		*IXP4XX_ICMR |= (1 << irq);
-}
-
 static void ixp4xx_irq_ack(unsigned int irq)
 {
 	int line = (irq < 32) ? irq2gpio[irq] : -1;
@@ -187,41 +184,25 @@ static void ixp4xx_irq_ack(unsigned int irq)
  * Level triggered interrupts on GPIO lines can only be cleared when the
  * interrupt condition disappears.
  */
-static void ixp4xx_irq_level_unmask(unsigned int irq)
+static void ixp4xx_irq_unmask(unsigned int irq)
 {
-	ixp4xx_irq_ack(irq);
-	ixp4xx_irq_unmask(irq);
-}
+	if (!(ixp4xx_irq_edge & (1 << irq)))
+		ixp4xx_irq_ack(irq);
 
-static struct irqchip ixp4xx_irq_level_chip = {
-	.ack		= ixp4xx_irq_mask,
-	.mask		= ixp4xx_irq_mask,
-	.unmask		= ixp4xx_irq_level_unmask,
-	.set_type	= ixp4xx_set_irq_type,
-};
+	if (cpu_is_ixp46x() && irq >= 32)
+		*IXP4XX_ICMR2 |= (1 << (irq - 32));
+	else
+		*IXP4XX_ICMR |= (1 << irq);
+}
 
-static struct irqchip ixp4xx_irq_edge_chip = {
+static struct irqchip ixp4xx_irq_chip = {
+	.name		= "IXP4xx",
 	.ack		= ixp4xx_irq_ack,
 	.mask		= ixp4xx_irq_mask,
 	.unmask		= ixp4xx_irq_unmask,
 	.set_type	= ixp4xx_set_irq_type,
 };
 
-static void ixp4xx_config_irq(unsigned irq, enum ixp4xx_irq_type type)
-{
-	switch (type) {
-	case IXP4XX_IRQ_LEVEL:
-		set_irq_chip(irq, &ixp4xx_irq_level_chip);
-		set_irq_handler(irq, do_level_IRQ);
-		break;
-	case IXP4XX_IRQ_EDGE:
-		set_irq_chip(irq, &ixp4xx_irq_edge_chip);
-		set_irq_handler(irq, do_edge_IRQ);
-		break;
-	}
-	set_irq_flags(irq, IRQF_VALID);
-}
-
 void __init ixp4xx_init_irq(void)
 {
 	int i = 0;
@@ -241,8 +222,11 @@ void __init ixp4xx_init_irq(void)
 	}
 
         /* Default to all level triggered */
-	for(i = 0; i < NR_IRQS; i++)
-		ixp4xx_config_irq(i, IXP4XX_IRQ_LEVEL);
+	for(i = 0; i < NR_IRQS; i++) {
+		set_irq_chip(i, &ixp4xx_irq_chip);
+		set_irq_handler(i, do_level_IRQ);
+		set_irq_flags(i, IRQF_VALID);
+	}
 }
 
 

commit 0cd61b68c340a4f901a06e8bb5e0dea4353161c0
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Fri Oct 6 10:53:39 2006 -0700

    Initial blind fixup for arm for irq changes
    
    Untested, but this should fix up the bulk of the totally mechanical
    issues, and should make the actual detail fixing easier.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 35dd8b3824b0..c7513f6eb50c 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -256,7 +256,7 @@ static unsigned volatile last_jiffy_time;
 
 #define CLOCK_TICKS_PER_USEC	((CLOCK_TICK_RATE + USEC_PER_SEC/2) / USEC_PER_SEC)
 
-static irqreturn_t ixp4xx_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t ixp4xx_timer_interrupt(int irq, void *dev_id)
 {
 	write_seqlock(&xtime_lock);
 
@@ -267,7 +267,7 @@ static irqreturn_t ixp4xx_timer_interrupt(int irq, void *dev_id, struct pt_regs
 	 * Catch up with the real idea of time
 	 */
 	while ((signed long)(*IXP4XX_OSTS - last_jiffy_time) >= LATCH) {
-		timer_tick(regs);
+		timer_tick();
 		last_jiffy_time += LATCH;
 	}
 

commit 84904d0ead0a8c419abd45c7b2ac8d76d50a0d48
Author: Kevin Hilman <khilman@mvista.com>
Date:   Fri Sep 22 00:58:57 2006 +0100

    [ARM] 3856/1: Add clocksource for Intel IXP4xx platforms
    
    Enables the ixp4xx platforms to use Generic time-of-day.
    
    Signed-off-by: Kevin Hilman <khilman@mvista.com>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Signed-off-by: Deepak Saxena <dsaxena@plexity.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 7c25dbd5a181..35dd8b3824b0 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -26,6 +26,7 @@
 #include <linux/bitops.h>
 #include <linux/time.h>
 #include <linux/timex.h>
+#include <linux/clocksource.h>
 
 #include <asm/hardware.h>
 #include <asm/uaccess.h>
@@ -255,16 +256,6 @@ static unsigned volatile last_jiffy_time;
 
 #define CLOCK_TICKS_PER_USEC	((CLOCK_TICK_RATE + USEC_PER_SEC/2) / USEC_PER_SEC)
 
-/* IRQs are disabled before entering here from do_gettimeofday() */
-static unsigned long ixp4xx_gettimeoffset(void)
-{
-	u32 elapsed;
-
-	elapsed = *IXP4XX_OSTS - last_jiffy_time;
-
-	return elapsed / CLOCK_TICKS_PER_USEC;
-}
-
 static irqreturn_t ixp4xx_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	write_seqlock(&xtime_lock);
@@ -309,7 +300,6 @@ static void __init ixp4xx_timer_init(void)
 
 struct sys_timer ixp4xx_timer = {
 	.init		= ixp4xx_timer_init,
-	.offset		= ixp4xx_gettimeoffset,
 };
 
 static struct resource ixp46x_i2c_resources[] = {
@@ -365,3 +355,29 @@ void __init ixp4xx_sys_init(void)
 			ixp4xx_exp_bus_size >> 20);
 }
 
+cycle_t ixp4xx_get_cycles(void)
+{
+	return *IXP4XX_OSTS;
+}
+
+static struct clocksource clocksource_ixp4xx = {
+	.name 		= "OSTS",
+	.rating		= 200,
+	.read		= ixp4xx_get_cycles,
+	.mask		= CLOCKSOURCE_MASK(32),
+	.shift 		= 20,
+	.is_continuous 	= 1,
+};
+
+unsigned long ixp4xx_timer_freq = FREQ;
+static int __init ixp4xx_clocksource_init(void)
+{
+	clocksource_ixp4xx.mult =
+		clocksource_hz2mult(ixp4xx_timer_freq,
+				    clocksource_ixp4xx.shift);
+	clocksource_register(&clocksource_ixp4xx);
+
+	return 0;
+}
+
+device_initcall(ixp4xx_clocksource_init);

commit 52e405eaa9806968e88b35d65e57acad954a5ab5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 3 02:20:05 2006 +0200

    [PATCH] ARM: fixup irqflags breakage after ARM genirq merge
    
    The irgflags consolidation did conflict with the ARM to generic IRQ
    conversion and was not applied for ARM. Fix it up.
    
    Use the new IRQF_ constants and remove the SA_INTERRUPT define
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 13c7c629d037..7c25dbd5a181 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -287,7 +287,7 @@ static irqreturn_t ixp4xx_timer_interrupt(int irq, void *dev_id, struct pt_regs
 
 static struct irqaction ixp4xx_timer_irq = {
 	.name		= "IXP4xx Timer Tick",
-	.flags		= SA_INTERRUPT | SA_TIMER,
+	.flags		= IRQF_DISABLED | IRQF_TIMER,
 	.handler	= ixp4xx_timer_interrupt,
 };
 

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index bf25a76e9bdf..13c7c629d037 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -13,7 +13,6 @@
  * warranty of any kind, whether express or implied.
  */
 
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/init.h>

commit f869afab8f36c5f8561557f74b4b9846719092da
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Thu Jun 22 10:30:53 2006 +0100

    [ARM] 3616/1: fix timer handler wrap logic for a number of platforms
    
    Patch from Lennert Buytenhek
    
    A couple of platforms aren't using the right comparison type in their
    timer interrupt handlers (as we're comparing two wrapping timestamps,
    we need a bmi/bpl-type comparison, not an unsigned comparison) -- this
    patch fixes them up.
    
    Signed-off-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 00b761ff0f9c..bf25a76e9bdf 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -276,7 +276,7 @@ static irqreturn_t ixp4xx_timer_interrupt(int irq, void *dev_id, struct pt_regs
 	/*
 	 * Catch up with the real idea of time
 	 */
-	while ((*IXP4XX_OSTS - last_jiffy_time) > LATCH) {
+	while ((signed long)(*IXP4XX_OSTS - last_jiffy_time) >= LATCH) {
 		timer_tick(regs);
 		last_jiffy_time += LATCH;
 	}

commit 6cc1b6588686190325a960b5a598f4f952dbe23b
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Thu Apr 20 21:24:38 2006 +0100

    [ARM] 3480/1: ixp4xx: fix irq2gpio array type
    
    Patch from Lennert Buytenhek
    
    The irq2gpio array was recently converted from an array of ints to an
    array of chars (by patch 3368/1.)  However, this array contains elements
    that are -1, and on ARM, the char type is unsigned by default, so this
    patch broke the GPIO check in ixp4xx_set_irq_type.
    
    Change the 'char' to be a 'signed char' to fix this.
    
    Signed-off-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Signed-off-by: Deepak Saxena <dsaxena@plexity.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index a0888e160e3b..00b761ff0f9c 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -91,7 +91,7 @@ static void ixp4xx_config_irq(unsigned irq, enum ixp4xx_irq_type type);
 /*
  * IRQ -> GPIO mapping table
  */
-static char irq2gpio[32] = {
+static signed char irq2gpio[32] = {
 	-1, -1, -1, -1, -1, -1,  0,  1,
 	-1, -1, -1, -1, -1, -1, -1, -1,
 	-1, -1, -1,  2,  3,  4,  5,  6,

commit 73deb7dc05b4cf968e506e7b18345bc65bcbc0f3
Author: Alessandro Zummo <a.zummo@towertech.it>
Date:   Mon Mar 20 17:10:12 2006 +0000

    [ARM] 3368/1: ixp4xx: set gpio direction in ixp4xx_config_irq
    
    Patch from Alessandro Zummo
    
    ixp4xx_config_irq did not configure the gpio line
    as an input.
    
    As an added bonus, the irq2gpio array has been converted
    from int to char.
    
    Signed-off-by: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index fbadf3021b9e..a0888e160e3b 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -91,7 +91,7 @@ static void ixp4xx_config_irq(unsigned irq, enum ixp4xx_irq_type type);
 /*
  * IRQ -> GPIO mapping table
  */
-static int irq2gpio[32] = {
+static char irq2gpio[32] = {
 	-1, -1, -1, -1, -1, -1,  0,  1,
 	-1, -1, -1, -1, -1, -1, -1, -1,
 	-1, -1, -1,  2,  3,  4,  5,  6,
@@ -153,6 +153,9 @@ static int ixp4xx_set_irq_type(unsigned int irq, unsigned int type)
 	/* Set the new style */
 	*int_reg |= (int_style << (line * IXP4XX_GPIO_STYLE_SIZE));
 
+	/* Configure the line as an input */
+	gpio_line_config(line, IXP4XX_GPIO_IN);
+
 	return 0;
 }
 

commit 06e4479bd092eca4125e5507e7c22619a491dab3
Author: Mrten Wikstrm <marten.wikstrom@passito.se>
Date:   Wed Feb 22 22:27:23 2006 +0000

    [ARM] 3347/1: Bugfix for ixp4xx_set_irq_type()
    
    Patch from Mrten Wikstrm
    
    This patch fixes a bug in ixp4xx_set_irq_type() which leads to
    GPIO being incorrectly set to both edge triggered for raising
    as well as falling edge interrupt types. See the previous
    discussion on patch 3312/1.
    
    Signed-off-by: Mrten Wikstrm <marten.wikstrom@passito.se>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 4bdc9d4526cd..fbadf3021b9e 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -111,24 +111,30 @@ static int ixp4xx_set_irq_type(unsigned int irq, unsigned int type)
 	if (line < 0)
 		return -EINVAL;
 
-	if (type & IRQT_BOTHEDGE) {
+	switch (type){
+	case IRQT_BOTHEDGE:
 		int_style = IXP4XX_GPIO_STYLE_TRANSITIONAL;
 		irq_type = IXP4XX_IRQ_EDGE;
-	} else  if (type & IRQT_RISING) {
+		break;
+	case IRQT_RISING:
 		int_style = IXP4XX_GPIO_STYLE_RISING_EDGE;
 		irq_type = IXP4XX_IRQ_EDGE;
-	} else if (type & IRQT_FALLING) {
+		break;
+	case IRQT_FALLING:
 		int_style = IXP4XX_GPIO_STYLE_FALLING_EDGE;
 		irq_type = IXP4XX_IRQ_EDGE;
-	} else if (type & IRQT_HIGH) {
+		break;
+	case IRQT_HIGH:
 		int_style = IXP4XX_GPIO_STYLE_ACTIVE_HIGH;
 		irq_type = IXP4XX_IRQ_LEVEL;
-	} else if (type & IRQT_LOW) {
+		break;
+	case IRQT_LOW:
 		int_style = IXP4XX_GPIO_STYLE_ACTIVE_LOW;
 		irq_type = IXP4XX_IRQ_LEVEL;
-	} else
+		break;
+	default:
 		return -EINVAL;
-
+	}
 	ixp4xx_config_irq(irq, irq_type);
 
 	if (line >= 8) {	/* pins 8-15 */

commit 1e74c891252941ac195bb47978f079c592271a3f
Author: David Vrabel <dvrabel@arcom.com>
Date:   Wed Jan 18 22:46:43 2006 +0000

    [ARM] 3281/1: ixp4xx: export ixp4xx_exp_bus_size for modules
    
    Patch from David Vrabel
    
    Export ixp4xx_exp_bus_size so modules can use the IXP4XX_EXP_BUS_BASE(n) macro.
    
    Also, fix a printk format warning.
    
    Signed-off-by: David Vrabel <dvrabel@arcom.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 6b393691d0e8..4bdc9d4526cd 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -333,6 +333,7 @@ static struct platform_device *ixp46x_devices[] __initdata = {
 };
 
 unsigned long ixp4xx_exp_bus_size;
+EXPORT_SYMBOL(ixp4xx_exp_bus_size);
 
 void __init ixp4xx_sys_init(void)
 {
@@ -352,7 +353,7 @@ void __init ixp4xx_sys_init(void)
 		}
 	}
 
-	printk("IXP4xx: Using %uMiB expansion bus window size\n",
+	printk("IXP4xx: Using %luMiB expansion bus window size\n",
 			ixp4xx_exp_bus_size >> 20);
 }
 

commit 54e269ead6e672325866037b0617a72edd1396b9
Author: Deepak Saxena <dsaxena@plexity.net>
Date:   Thu Jan 5 20:59:29 2006 +0000

    [ARM] 3226/1: IXP4xx runtime expansion bus window size configuration
    
    Patch from Deepak Saxena
    
    The expansion bus on the IXP46x NPU can be configured for either 32MiB or
    16MiB windows and changing the configuration causes the base address for
    each chip select for each region to change. Because of this, we cannot
    hardcode the physical base as we currently do. This patch checks the
    expansion bus configuration registers at runtime to determine the
    appropriate window size. Note that this requires that the bootloader
    already configured the device sizes appropriately, but I feel that is
    valid assumption to make as the bootloader must configure and access
    the flash window, the output display (LCD, LEDs, etc) window, and
    other expansion bus devices.
    
    Signed-off-by: Deepak Saxena <dsaxena@plexity.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 9f33cb21e7f3..6b393691d0e8 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -332,11 +332,27 @@ static struct platform_device *ixp46x_devices[] __initdata = {
 	&ixp46x_i2c_controller
 };
 
+unsigned long ixp4xx_exp_bus_size;
+
 void __init ixp4xx_sys_init(void)
 {
+	ixp4xx_exp_bus_size = SZ_16M;
+
 	if (cpu_is_ixp46x()) {
+		int region;
+
 		platform_add_devices(ixp46x_devices,
 				ARRAY_SIZE(ixp46x_devices));
+
+		for (region = 0; region < 7; region++) {
+			if((*(IXP4XX_EXP_REG(0x4 * region)) & 0x200)) {
+				ixp4xx_exp_bus_size = SZ_32M;
+				break;
+			}
+		}
 	}
+
+	printk("IXP4xx: Using %uMiB expansion bus window size\n",
+			ixp4xx_exp_bus_size >> 20);
 }
 

commit f7e8bbb8207c17afbd716e7e5fc785b78fa08571
Author: Deepak Saxena <dsaxena@plexity.net>
Date:   Wed Jan 4 17:17:10 2006 +0000

    [ARM] 3192/1: Remove gpio_isr_line_clear() API from IXP4xx
    
    Patch from Deepak Saxena
    
    Other than interrupt masking purposes, this API is only used when
    configuring interrupt lines and this patch moves that functionality
    directly into the ixp4xx_set_irq_type() implementation as board level
    PCI code should not need to worry about those details.
    
    Signed-off-by: Deepak Saxena <dsaxena@plexity.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index f3c687cf0071..9f33cb21e7f3 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -142,6 +142,8 @@ static int ixp4xx_set_irq_type(unsigned int irq, unsigned int type)
 	*int_reg &= ~(IXP4XX_GPIO_STYLE_CLEAR <<
 	    		(line * IXP4XX_GPIO_STYLE_SIZE));
 
+	*IXP4XX_GPIO_GPISR = (1 << line);
+
 	/* Set the new style */
 	*int_reg |= (int_style << (line * IXP4XX_GPIO_STYLE_SIZE));
 
@@ -169,7 +171,7 @@ static void ixp4xx_irq_ack(unsigned int irq)
 	int line = (irq < 32) ? irq2gpio[irq] : -1;
 
 	if (line >= 0)
-		gpio_line_isr_clear(line);
+		*IXP4XX_GPIO_GPISR = (1 << line);
 }
 
 /*

commit d052d1beff706920e82c5d55006b08e256b5df09
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Oct 29 19:07:23 2005 +0100

    Create platform_device.h to contain all the platform device details.
    Convert everyone who uses platform_bus_type to include
    linux/platform_device.h.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 6c396447c4e0..f3c687cf0071 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -20,6 +20,7 @@
 #include <linux/serial.h>
 #include <linux/sched.h>
 #include <linux/tty.h>
+#include <linux/platform_device.h>
 #include <linux/serial_core.h>
 #include <linux/bootmem.h>
 #include <linux/interrupt.h>

commit 87fe04bd2a39f263211cc232da9f4f094eaffea0
Author: Deepak Saxena <dsaxena@plexity.net>
Date:   Fri Oct 28 15:18:59 2005 +0100

    [ARM] 2985/1: Replace map_desc.physical with map_desc.pfn: IXP4xx
    
    Patch from Deepak Saxena
    
    IXP4xx map_desc.pfn conversion
    
    Signed-off-by: Deepak Saxena <dsaxena@plexity.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 36b6045213ee..6c396447c4e0 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -44,24 +44,24 @@
 static struct map_desc ixp4xx_io_desc[] __initdata = {
 	{	/* UART, Interrupt ctrl, GPIO, timers, NPEs, MACs, USB .... */
 		.virtual	= IXP4XX_PERIPHERAL_BASE_VIRT,
-		.physical	= IXP4XX_PERIPHERAL_BASE_PHYS,
+		.pfn		= __phys_to_pfn(IXP4XX_PERIPHERAL_BASE_PHYS),
 		.length		= IXP4XX_PERIPHERAL_REGION_SIZE,
 		.type		= MT_DEVICE
 	}, {	/* Expansion Bus Config Registers */
 		.virtual	= IXP4XX_EXP_CFG_BASE_VIRT,
-		.physical	= IXP4XX_EXP_CFG_BASE_PHYS,
+		.pfn		= __phys_to_pfn(IXP4XX_EXP_CFG_BASE_PHYS),
 		.length		= IXP4XX_EXP_CFG_REGION_SIZE,
 		.type		= MT_DEVICE
 	}, {	/* PCI Registers */
 		.virtual	= IXP4XX_PCI_CFG_BASE_VIRT,
-		.physical	= IXP4XX_PCI_CFG_BASE_PHYS,
+		.pfn		= __phys_to_pfn(IXP4XX_PCI_CFG_BASE_PHYS),
 		.length		= IXP4XX_PCI_CFG_REGION_SIZE,
 		.type		= MT_DEVICE
 	},
 #ifdef CONFIG_DEBUG_LL
 	{	/* Debug UART mapping */
 		.virtual	= IXP4XX_DEBUG_UART_BASE_VIRT,
-		.physical	= IXP4XX_DEBUG_UART_BASE_PHYS,
+		.pfn		= __phys_to_pfn(IXP4XX_DEBUG_UART_BASE_PHYS),
 		.length		= IXP4XX_DEBUG_UART_REGION_SIZE,
 		.type		= MT_DEVICE
 	}

commit 6132f9e146150473f803323dc8064a5506e33952
Author: David Vrabel <dvrabel@arcom.com>
Date:   Mon Sep 26 19:52:56 2005 +0100

    [ARM] 2935/1: ixp4xx: fix warnings in ixp4xx_set_irq_type
    
    Patch from David Vrabel
    
    Signed-off-by: David Vrabel <dvrabel@arcom.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 52ad11328e96..36b6045213ee 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -125,7 +125,8 @@ static int ixp4xx_set_irq_type(unsigned int irq, unsigned int type)
 	} else if (type & IRQT_LOW) {
 		int_style = IXP4XX_GPIO_STYLE_ACTIVE_LOW;
 		irq_type = IXP4XX_IRQ_LEVEL;
-	}
+	} else
+		return -EINVAL;
 
 	ixp4xx_config_irq(irq, irq_type);
 
@@ -142,6 +143,8 @@ static int ixp4xx_set_irq_type(unsigned int irq, unsigned int type)
 
 	/* Set the new style */
 	*int_reg |= (int_style << (line * IXP4XX_GPIO_STYLE_SIZE));
+
+	return 0;
 }
 
 static void ixp4xx_irq_mask(unsigned int irq)

commit 2be863c959ea22ac9eb83e30f6cd92a8ae78bfdc
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Sep 6 23:13:17 2005 +0100

    [ARM] Fix missed initialisers/missing comma
    
    Fix the broken initialisers missed by the recent IRQ patch.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 0422e906cc9a..52ad11328e96 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -179,17 +179,17 @@ static void ixp4xx_irq_level_unmask(unsigned int irq)
 }
 
 static struct irqchip ixp4xx_irq_level_chip = {
-	.ack	= ixp4xx_irq_mask,
-	.mask	= ixp4xx_irq_mask,
-	.unmask	= ixp4xx_irq_level_unmask,
-	.type	= ixp4xx_set_irq_type
+	.ack		= ixp4xx_irq_mask,
+	.mask		= ixp4xx_irq_mask,
+	.unmask		= ixp4xx_irq_level_unmask,
+	.set_type	= ixp4xx_set_irq_type,
 };
 
 static struct irqchip ixp4xx_irq_edge_chip = {
-	.ack	= ixp4xx_irq_ack,
-	.mask	= ixp4xx_irq_mask,
-	.unmask	= ixp4xx_irq_unmask,
-	.type	= ixp4xx_set_irq_type
+	.ack		= ixp4xx_irq_ack,
+	.mask		= ixp4xx_irq_mask,
+	.unmask		= ixp4xx_irq_unmask,
+	.set_type	= ixp4xx_set_irq_type,
 };
 
 static void ixp4xx_config_irq(unsigned irq, enum ixp4xx_irq_type type)

commit bdf82b59c5dcf04bbdbd1938eefca14dd9cb44d3
Author: Deepak Saxena <dsaxena@plexity.net>
Date:   Mon Aug 29 22:46:30 2005 +0100

    [ARM] 2836/1: Cleanup IXP4xx GPIO code
    
    Patch from Deepak Saxena
    
    This patch implements the set_irq_type() hooks for configuring GPIO
    IRQ type and updates all the platforms to use it instead of the
    gpio_line_config() function which is now used to configure input
    vs. output on the pins.
    
    Signed-off-by: Deepak Saxena <dsaxena@plexity.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 04490a9f8f6e..0422e906cc9a 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -38,90 +38,6 @@
 #include <asm/mach/irq.h>
 #include <asm/mach/time.h>
 
-enum ixp4xx_irq_type {
-	IXP4XX_IRQ_LEVEL, IXP4XX_IRQ_EDGE
-};
-static void ixp4xx_config_irq(unsigned irq, enum ixp4xx_irq_type type);
-
-/*************************************************************************
- * GPIO acces functions
- *************************************************************************/
-
-/*
- * Configure GPIO line for input, interrupt, or output operation
- *
- * TODO: Enable/disable the irq_desc based on interrupt or output mode.
- * TODO: Should these be named ixp4xx_gpio_?
- */
-void gpio_line_config(u8 line, u32 style)
-{
-	static const int gpio2irq[] = {
-		6, 7, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29
-	};
-	u32 enable;
-	volatile u32 *int_reg;
-	u32 int_style;
-	enum ixp4xx_irq_type irq_type;
-
-	enable = *IXP4XX_GPIO_GPOER;
-
-	if (style & IXP4XX_GPIO_OUT) {
-		enable &= ~((1) << line);
-	} else if (style & IXP4XX_GPIO_IN) {
-		enable |= ((1) << line);
-
-		switch (style & IXP4XX_GPIO_INTSTYLE_MASK)
-		{
-		case (IXP4XX_GPIO_ACTIVE_HIGH):
-			int_style = IXP4XX_GPIO_STYLE_ACTIVE_HIGH;
-			irq_type = IXP4XX_IRQ_LEVEL;
-			break;
-		case (IXP4XX_GPIO_ACTIVE_LOW):
-			int_style = IXP4XX_GPIO_STYLE_ACTIVE_LOW;
-			irq_type = IXP4XX_IRQ_LEVEL;
-			break;
-		case (IXP4XX_GPIO_RISING_EDGE):
-			int_style = IXP4XX_GPIO_STYLE_RISING_EDGE;
-			irq_type = IXP4XX_IRQ_EDGE;
-			break;
-		case (IXP4XX_GPIO_FALLING_EDGE):
-			int_style = IXP4XX_GPIO_STYLE_FALLING_EDGE;
-			irq_type = IXP4XX_IRQ_EDGE;
-			break;
-		case (IXP4XX_GPIO_TRANSITIONAL):
-			int_style = IXP4XX_GPIO_STYLE_TRANSITIONAL;
-			irq_type = IXP4XX_IRQ_EDGE;
-			break;
-		default:
-			int_style = IXP4XX_GPIO_STYLE_ACTIVE_HIGH;
-			irq_type = IXP4XX_IRQ_LEVEL;
-			break;
-		}
-
-		if (style & IXP4XX_GPIO_INTSTYLE_MASK)
-			ixp4xx_config_irq(gpio2irq[line], irq_type);
-
-		if (line >= 8) {	/* pins 8-15 */ 
-			line -= 8;
-			int_reg = IXP4XX_GPIO_GPIT2R;
-		}
-		else {			/* pins 0-7 */
-			int_reg = IXP4XX_GPIO_GPIT1R;
-		}
-
-		/* Clear the style for the appropriate pin */
-		*int_reg &= ~(IXP4XX_GPIO_STYLE_CLEAR << 
-		    		(line * IXP4XX_GPIO_STYLE_SIZE));
-
-		/* Set the new style */
-		*int_reg |= (int_style << (line * IXP4XX_GPIO_STYLE_SIZE));
-	}
-
-	*IXP4XX_GPIO_GPOER = enable;
-}
-
-EXPORT_SYMBOL(gpio_line_config);
-
 /*************************************************************************
  * IXP4xx chipset I/O mapping
  *************************************************************************/
@@ -165,6 +81,69 @@ void __init ixp4xx_map_io(void)
  *       (be it PCI or something else) configures that GPIO line
  *       as an IRQ.
  **************************************************************************/
+enum ixp4xx_irq_type {
+	IXP4XX_IRQ_LEVEL, IXP4XX_IRQ_EDGE
+};
+
+static void ixp4xx_config_irq(unsigned irq, enum ixp4xx_irq_type type);
+
+/*
+ * IRQ -> GPIO mapping table
+ */
+static int irq2gpio[32] = {
+	-1, -1, -1, -1, -1, -1,  0,  1,
+	-1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1,  2,  3,  4,  5,  6,
+	 7,  8,  9, 10, 11, 12, -1, -1,
+};
+
+static int ixp4xx_set_irq_type(unsigned int irq, unsigned int type)
+{
+	int line = irq2gpio[irq];
+	u32 int_style;
+	enum ixp4xx_irq_type irq_type;
+	volatile u32 *int_reg;
+
+	/*
+	 * Only for GPIO IRQs
+	 */
+	if (line < 0)
+		return -EINVAL;
+
+	if (type & IRQT_BOTHEDGE) {
+		int_style = IXP4XX_GPIO_STYLE_TRANSITIONAL;
+		irq_type = IXP4XX_IRQ_EDGE;
+	} else  if (type & IRQT_RISING) {
+		int_style = IXP4XX_GPIO_STYLE_RISING_EDGE;
+		irq_type = IXP4XX_IRQ_EDGE;
+	} else if (type & IRQT_FALLING) {
+		int_style = IXP4XX_GPIO_STYLE_FALLING_EDGE;
+		irq_type = IXP4XX_IRQ_EDGE;
+	} else if (type & IRQT_HIGH) {
+		int_style = IXP4XX_GPIO_STYLE_ACTIVE_HIGH;
+		irq_type = IXP4XX_IRQ_LEVEL;
+	} else if (type & IRQT_LOW) {
+		int_style = IXP4XX_GPIO_STYLE_ACTIVE_LOW;
+		irq_type = IXP4XX_IRQ_LEVEL;
+	}
+
+	ixp4xx_config_irq(irq, irq_type);
+
+	if (line >= 8) {	/* pins 8-15 */
+		line -= 8;
+		int_reg = IXP4XX_GPIO_GPIT2R;
+	} else {		/* pins 0-7 */
+		int_reg = IXP4XX_GPIO_GPIT1R;
+	}
+
+	/* Clear the style for the appropriate pin */
+	*int_reg &= ~(IXP4XX_GPIO_STYLE_CLEAR <<
+	    		(line * IXP4XX_GPIO_STYLE_SIZE));
+
+	/* Set the new style */
+	*int_reg |= (int_style << (line * IXP4XX_GPIO_STYLE_SIZE));
+}
+
 static void ixp4xx_irq_mask(unsigned int irq)
 {
 	if (cpu_is_ixp46x() && irq >= 32)
@@ -183,12 +162,6 @@ static void ixp4xx_irq_unmask(unsigned int irq)
 
 static void ixp4xx_irq_ack(unsigned int irq)
 {
-	static int irq2gpio[32] = {
-		-1, -1, -1, -1, -1, -1,  0,  1,
-		-1, -1, -1, -1, -1, -1, -1, -1,
-		-1, -1, -1,  2,  3,  4,  5,  6,
-		 7,  8,  9, 10, 11, 12, -1, -1,
-	};
 	int line = (irq < 32) ? irq2gpio[irq] : -1;
 
 	if (line >= 0)
@@ -209,12 +182,14 @@ static struct irqchip ixp4xx_irq_level_chip = {
 	.ack	= ixp4xx_irq_mask,
 	.mask	= ixp4xx_irq_mask,
 	.unmask	= ixp4xx_irq_level_unmask,
+	.type	= ixp4xx_set_irq_type
 };
 
 static struct irqchip ixp4xx_irq_edge_chip = {
 	.ack	= ixp4xx_irq_ack,
 	.mask	= ixp4xx_irq_mask,
 	.unmask	= ixp4xx_irq_unmask,
+	.type	= ixp4xx_set_irq_type
 };
 
 static void ixp4xx_config_irq(unsigned irq, enum ixp4xx_irq_type type)

commit 09b8b5f843afc21daf710cc610e5ca890ee94696
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Jun 26 17:06:36 2005 +0100

    [PATCH] ARM: Add SA_TIMER flag to timer interrupts
    
    VST needs to know which timer handler is for the timer interrupt.
    Mark all timer interrupts with the SA_TIMER flag.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index f39e8408488f..04490a9f8f6e 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -298,8 +298,8 @@ static irqreturn_t ixp4xx_timer_interrupt(int irq, void *dev_id, struct pt_regs
 
 static struct irqaction ixp4xx_timer_irq = {
 	.name		= "IXP4xx Timer Tick",
-	.flags		= SA_INTERRUPT,
-	.handler	= ixp4xx_timer_interrupt
+	.flags		= SA_INTERRUPT | SA_TIMER,
+	.handler	= ixp4xx_timer_interrupt,
 };
 
 static void __init ixp4xx_timer_init(void)

commit 5932ae3f5d610fd8d047ef4693bab9f084e5c56d
Author: Deepak Saxena <dsaxena@plexity.net>
Date:   Fri Jun 24 20:54:35 2005 +0100

    [PATCH] ARM: 2745/1: Fix IXP4xx debug macros
    
    Patch from Deepak Saxena
    
    Current IXP4xx debug macros do not work in the small window between
    the MMU being enabled and the call to map_io() b/c the standard
    peripheral mapping is not properly setup for use with the low-level
    debug code. This patch creates a new section-aligned mapping for the
    UART specifically for use with the debug macros.
    
    Signed-off-by: Deepak Saxena
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
index 267ba02d77dc..f39e8408488f 100644
--- a/arch/arm/mach-ixp4xx/common.c
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -141,7 +141,15 @@ static struct map_desc ixp4xx_io_desc[] __initdata = {
 		.physical	= IXP4XX_PCI_CFG_BASE_PHYS,
 		.length		= IXP4XX_PCI_CFG_REGION_SIZE,
 		.type		= MT_DEVICE
+	},
+#ifdef CONFIG_DEBUG_LL
+	{	/* Debug UART mapping */
+		.virtual	= IXP4XX_DEBUG_UART_BASE_VIRT,
+		.physical	= IXP4XX_DEBUG_UART_BASE_PHYS,
+		.length		= IXP4XX_DEBUG_UART_REGION_SIZE,
+		.type		= MT_DEVICE
 	}
+#endif
 };
 
 void __init ixp4xx_map_io(void)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/arm/mach-ixp4xx/common.c b/arch/arm/mach-ixp4xx/common.c
new file mode 100644
index 000000000000..267ba02d77dc
--- /dev/null
+++ b/arch/arm/mach-ixp4xx/common.c
@@ -0,0 +1,353 @@
+/*
+ * arch/arm/mach-ixp4xx/common.c
+ *
+ * Generic code shared across all IXP4XX platforms
+ *
+ * Maintainer: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright 2002 (c) Intel Corporation
+ * Copyright 2003-2004 (c) MontaVista, Software, Inc. 
+ * 
+ * This file is licensed under  the terms of the GNU General Public 
+ * License version 2. This program is licensed "as is" without any 
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/serial.h>
+#include <linux/sched.h>
+#include <linux/tty.h>
+#include <linux/serial_core.h>
+#include <linux/bootmem.h>
+#include <linux/interrupt.h>
+#include <linux/bitops.h>
+#include <linux/time.h>
+#include <linux/timex.h>
+
+#include <asm/hardware.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/irq.h>
+
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/time.h>
+
+enum ixp4xx_irq_type {
+	IXP4XX_IRQ_LEVEL, IXP4XX_IRQ_EDGE
+};
+static void ixp4xx_config_irq(unsigned irq, enum ixp4xx_irq_type type);
+
+/*************************************************************************
+ * GPIO acces functions
+ *************************************************************************/
+
+/*
+ * Configure GPIO line for input, interrupt, or output operation
+ *
+ * TODO: Enable/disable the irq_desc based on interrupt or output mode.
+ * TODO: Should these be named ixp4xx_gpio_?
+ */
+void gpio_line_config(u8 line, u32 style)
+{
+	static const int gpio2irq[] = {
+		6, 7, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29
+	};
+	u32 enable;
+	volatile u32 *int_reg;
+	u32 int_style;
+	enum ixp4xx_irq_type irq_type;
+
+	enable = *IXP4XX_GPIO_GPOER;
+
+	if (style & IXP4XX_GPIO_OUT) {
+		enable &= ~((1) << line);
+	} else if (style & IXP4XX_GPIO_IN) {
+		enable |= ((1) << line);
+
+		switch (style & IXP4XX_GPIO_INTSTYLE_MASK)
+		{
+		case (IXP4XX_GPIO_ACTIVE_HIGH):
+			int_style = IXP4XX_GPIO_STYLE_ACTIVE_HIGH;
+			irq_type = IXP4XX_IRQ_LEVEL;
+			break;
+		case (IXP4XX_GPIO_ACTIVE_LOW):
+			int_style = IXP4XX_GPIO_STYLE_ACTIVE_LOW;
+			irq_type = IXP4XX_IRQ_LEVEL;
+			break;
+		case (IXP4XX_GPIO_RISING_EDGE):
+			int_style = IXP4XX_GPIO_STYLE_RISING_EDGE;
+			irq_type = IXP4XX_IRQ_EDGE;
+			break;
+		case (IXP4XX_GPIO_FALLING_EDGE):
+			int_style = IXP4XX_GPIO_STYLE_FALLING_EDGE;
+			irq_type = IXP4XX_IRQ_EDGE;
+			break;
+		case (IXP4XX_GPIO_TRANSITIONAL):
+			int_style = IXP4XX_GPIO_STYLE_TRANSITIONAL;
+			irq_type = IXP4XX_IRQ_EDGE;
+			break;
+		default:
+			int_style = IXP4XX_GPIO_STYLE_ACTIVE_HIGH;
+			irq_type = IXP4XX_IRQ_LEVEL;
+			break;
+		}
+
+		if (style & IXP4XX_GPIO_INTSTYLE_MASK)
+			ixp4xx_config_irq(gpio2irq[line], irq_type);
+
+		if (line >= 8) {	/* pins 8-15 */ 
+			line -= 8;
+			int_reg = IXP4XX_GPIO_GPIT2R;
+		}
+		else {			/* pins 0-7 */
+			int_reg = IXP4XX_GPIO_GPIT1R;
+		}
+
+		/* Clear the style for the appropriate pin */
+		*int_reg &= ~(IXP4XX_GPIO_STYLE_CLEAR << 
+		    		(line * IXP4XX_GPIO_STYLE_SIZE));
+
+		/* Set the new style */
+		*int_reg |= (int_style << (line * IXP4XX_GPIO_STYLE_SIZE));
+	}
+
+	*IXP4XX_GPIO_GPOER = enable;
+}
+
+EXPORT_SYMBOL(gpio_line_config);
+
+/*************************************************************************
+ * IXP4xx chipset I/O mapping
+ *************************************************************************/
+static struct map_desc ixp4xx_io_desc[] __initdata = {
+	{	/* UART, Interrupt ctrl, GPIO, timers, NPEs, MACs, USB .... */
+		.virtual	= IXP4XX_PERIPHERAL_BASE_VIRT,
+		.physical	= IXP4XX_PERIPHERAL_BASE_PHYS,
+		.length		= IXP4XX_PERIPHERAL_REGION_SIZE,
+		.type		= MT_DEVICE
+	}, {	/* Expansion Bus Config Registers */
+		.virtual	= IXP4XX_EXP_CFG_BASE_VIRT,
+		.physical	= IXP4XX_EXP_CFG_BASE_PHYS,
+		.length		= IXP4XX_EXP_CFG_REGION_SIZE,
+		.type		= MT_DEVICE
+	}, {	/* PCI Registers */
+		.virtual	= IXP4XX_PCI_CFG_BASE_VIRT,
+		.physical	= IXP4XX_PCI_CFG_BASE_PHYS,
+		.length		= IXP4XX_PCI_CFG_REGION_SIZE,
+		.type		= MT_DEVICE
+	}
+};
+
+void __init ixp4xx_map_io(void)
+{
+  	iotable_init(ixp4xx_io_desc, ARRAY_SIZE(ixp4xx_io_desc));
+}
+
+
+/*************************************************************************
+ * IXP4xx chipset IRQ handling
+ *
+ * TODO: GPIO IRQs should be marked invalid until the user of the IRQ
+ *       (be it PCI or something else) configures that GPIO line
+ *       as an IRQ.
+ **************************************************************************/
+static void ixp4xx_irq_mask(unsigned int irq)
+{
+	if (cpu_is_ixp46x() && irq >= 32)
+		*IXP4XX_ICMR2 &= ~(1 << (irq - 32));
+	else
+		*IXP4XX_ICMR &= ~(1 << irq);
+}
+
+static void ixp4xx_irq_unmask(unsigned int irq)
+{
+	if (cpu_is_ixp46x() && irq >= 32)
+		*IXP4XX_ICMR2 |= (1 << (irq - 32));
+	else
+		*IXP4XX_ICMR |= (1 << irq);
+}
+
+static void ixp4xx_irq_ack(unsigned int irq)
+{
+	static int irq2gpio[32] = {
+		-1, -1, -1, -1, -1, -1,  0,  1,
+		-1, -1, -1, -1, -1, -1, -1, -1,
+		-1, -1, -1,  2,  3,  4,  5,  6,
+		 7,  8,  9, 10, 11, 12, -1, -1,
+	};
+	int line = (irq < 32) ? irq2gpio[irq] : -1;
+
+	if (line >= 0)
+		gpio_line_isr_clear(line);
+}
+
+/*
+ * Level triggered interrupts on GPIO lines can only be cleared when the
+ * interrupt condition disappears.
+ */
+static void ixp4xx_irq_level_unmask(unsigned int irq)
+{
+	ixp4xx_irq_ack(irq);
+	ixp4xx_irq_unmask(irq);
+}
+
+static struct irqchip ixp4xx_irq_level_chip = {
+	.ack	= ixp4xx_irq_mask,
+	.mask	= ixp4xx_irq_mask,
+	.unmask	= ixp4xx_irq_level_unmask,
+};
+
+static struct irqchip ixp4xx_irq_edge_chip = {
+	.ack	= ixp4xx_irq_ack,
+	.mask	= ixp4xx_irq_mask,
+	.unmask	= ixp4xx_irq_unmask,
+};
+
+static void ixp4xx_config_irq(unsigned irq, enum ixp4xx_irq_type type)
+{
+	switch (type) {
+	case IXP4XX_IRQ_LEVEL:
+		set_irq_chip(irq, &ixp4xx_irq_level_chip);
+		set_irq_handler(irq, do_level_IRQ);
+		break;
+	case IXP4XX_IRQ_EDGE:
+		set_irq_chip(irq, &ixp4xx_irq_edge_chip);
+		set_irq_handler(irq, do_edge_IRQ);
+		break;
+	}
+	set_irq_flags(irq, IRQF_VALID);
+}
+
+void __init ixp4xx_init_irq(void)
+{
+	int i = 0;
+
+	/* Route all sources to IRQ instead of FIQ */
+	*IXP4XX_ICLR = 0x0;
+
+	/* Disable all interrupt */
+	*IXP4XX_ICMR = 0x0; 
+
+	if (cpu_is_ixp46x()) {
+		/* Route upper 32 sources to IRQ instead of FIQ */
+		*IXP4XX_ICLR2 = 0x00;
+
+		/* Disable upper 32 interrupts */
+		*IXP4XX_ICMR2 = 0x00;
+	}
+
+        /* Default to all level triggered */
+	for(i = 0; i < NR_IRQS; i++)
+		ixp4xx_config_irq(i, IXP4XX_IRQ_LEVEL);
+}
+
+
+/*************************************************************************
+ * IXP4xx timer tick
+ * We use OS timer1 on the CPU for the timer tick and the timestamp 
+ * counter as a source of real clock ticks to account for missed jiffies.
+ *************************************************************************/
+
+static unsigned volatile last_jiffy_time;
+
+#define CLOCK_TICKS_PER_USEC	((CLOCK_TICK_RATE + USEC_PER_SEC/2) / USEC_PER_SEC)
+
+/* IRQs are disabled before entering here from do_gettimeofday() */
+static unsigned long ixp4xx_gettimeoffset(void)
+{
+	u32 elapsed;
+
+	elapsed = *IXP4XX_OSTS - last_jiffy_time;
+
+	return elapsed / CLOCK_TICKS_PER_USEC;
+}
+
+static irqreturn_t ixp4xx_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	write_seqlock(&xtime_lock);
+
+	/* Clear Pending Interrupt by writing '1' to it */
+	*IXP4XX_OSST = IXP4XX_OSST_TIMER_1_PEND;
+
+	/*
+	 * Catch up with the real idea of time
+	 */
+	while ((*IXP4XX_OSTS - last_jiffy_time) > LATCH) {
+		timer_tick(regs);
+		last_jiffy_time += LATCH;
+	}
+
+	write_sequnlock(&xtime_lock);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction ixp4xx_timer_irq = {
+	.name		= "IXP4xx Timer Tick",
+	.flags		= SA_INTERRUPT,
+	.handler	= ixp4xx_timer_interrupt
+};
+
+static void __init ixp4xx_timer_init(void)
+{
+	/* Clear Pending Interrupt by writing '1' to it */
+	*IXP4XX_OSST = IXP4XX_OSST_TIMER_1_PEND;
+
+	/* Setup the Timer counter value */
+	*IXP4XX_OSRT1 = (LATCH & ~IXP4XX_OST_RELOAD_MASK) | IXP4XX_OST_ENABLE;
+
+	/* Reset time-stamp counter */
+	*IXP4XX_OSTS = 0;
+	last_jiffy_time = 0;
+
+	/* Connect the interrupt handler and enable the interrupt */
+	setup_irq(IRQ_IXP4XX_TIMER1, &ixp4xx_timer_irq);
+}
+
+struct sys_timer ixp4xx_timer = {
+	.init		= ixp4xx_timer_init,
+	.offset		= ixp4xx_gettimeoffset,
+};
+
+static struct resource ixp46x_i2c_resources[] = {
+	[0] = {
+		.start 	= 0xc8011000,
+		.end	= 0xc801101c,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start 	= IRQ_IXP4XX_I2C,
+		.end	= IRQ_IXP4XX_I2C,
+		.flags	= IORESOURCE_IRQ
+	}
+};
+
+/*
+ * I2C controller. The IXP46x uses the same block as the IOP3xx, so
+ * we just use the same device name.
+ */
+static struct platform_device ixp46x_i2c_controller = {
+	.name		= "IOP3xx-I2C",
+	.id		= 0,
+	.num_resources	= 2,
+	.resource	= ixp46x_i2c_resources
+};
+
+static struct platform_device *ixp46x_devices[] __initdata = {
+	&ixp46x_i2c_controller
+};
+
+void __init ixp4xx_sys_init(void)
+{
+	if (cpu_is_ixp46x()) {
+		platform_add_devices(ixp46x_devices,
+				ARRAY_SIZE(ixp46x_devices));
+	}
+}
+
