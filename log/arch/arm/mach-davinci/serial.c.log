commit 74ba9207e1adf1966c57450340534ae9742d00af
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 09:19:02 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 61
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      675 mass ave cambridge ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 441 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520071858.739733335@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-davinci/serial.c b/arch/arm/mach-davinci/serial.c
index 951b620bfa73..127b62ce7b1e 100644
--- a/arch/arm/mach-davinci/serial.c
+++ b/arch/arm/mach-davinci/serial.c
@@ -1,22 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * TI DaVinci serial driver
  *
  * Copyright (C) 2006 Texas Instruments.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
  */
 
 #include <linux/kernel.h>

commit 6e4b4dd539a2cf9e278112cce7475bb85f772aa2
Author: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
Date:   Tue Dec 2 23:08:40 2014 +0100

    ARM: davinci: serial.c: remove unused serial_read_reg()
    
    Remove function serial_read_reg() that is not used anywhere.
    
    This was partially found by using a static code analysis program called cppcheck.
    
    Signed-off-by: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/serial.c b/arch/arm/mach-davinci/serial.c
index 5e93a734c858..951b620bfa73 100644
--- a/arch/arm/mach-davinci/serial.c
+++ b/arch/arm/mach-davinci/serial.c
@@ -31,16 +31,6 @@
 #include <mach/serial.h>
 #include <mach/cputype.h>
 
-static inline unsigned int serial_read_reg(struct plat_serial8250_port *up,
-					   int offset)
-{
-	offset <<= up->regshift;
-
-	WARN_ONCE(!up->membase, "unmapped read: uart[%d]\n", offset);
-
-	return (unsigned int)__raw_readl(up->membase + offset);
-}
-
 static inline void serial_write_reg(struct plat_serial8250_port *p, int offset,
 				    int value)
 {

commit 323761bb7518d27c62c1514156cb3243930b55c1
Author: Manjunathappa, Prakash <prakash.pm@ti.com>
Date:   Wed Jun 19 14:45:42 2013 +0530

    ARM: davinci: serial: remove davinci_serial_setup_clk()
    
    Get rid of davinci_serial_setup_clk() since its not called
    from multiple places now. Instead initialize clock in
    davinci_serial_init() itself. This also helps get rid of
    "serial_dev" member of struct davinci_soc_info.
    
    Signed-off-by: Manjunathappa, Prakash <prakash.pm@ti.com>
    Suggested-by: Sekhar Nori <nsekhar@ti.com>
    [nsekhar@ti.com: split removal of davinci_serial_setup_clk()
                     into a separate patch.]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/serial.c b/arch/arm/mach-davinci/serial.c
index 45bd41a924db..5e93a734c858 100644
--- a/arch/arm/mach-davinci/serial.c
+++ b/arch/arm/mach-davinci/serial.c
@@ -70,33 +70,12 @@ static void __init davinci_serial_reset(struct plat_serial8250_port *p)
 				 UART_DM646X_SCR_TX_WATERMARK);
 }
 
-/* Enable UART clock and obtain its rate */
-int __init davinci_serial_setup_clk(unsigned instance, unsigned int *rate)
-{
-	struct clk *clk;
-	struct davinci_soc_info *soc_info = &davinci_soc_info;
-	struct device *dev = &soc_info->serial_dev[instance].dev;
-
-	clk = clk_get(dev, NULL);
-	if (IS_ERR(clk)) {
-		pr_err("%s:%d: failed to get UART%d clock\n",
-					__func__, __LINE__, instance);
-		return PTR_ERR(clk);
-	}
-
-	clk_prepare_enable(clk);
-
-	if (rate)
-		*rate = clk_get_rate(clk);
-
-	return 0;
-}
-
 int __init davinci_serial_init(struct platform_device *serial_dev)
 {
 	int i, ret = 0;
 	struct device *dev;
 	struct plat_serial8250_port *p;
+	struct clk *clk;
 
 	/*
 	 * Make sure the serial ports are muxed on at this point.
@@ -110,9 +89,16 @@ int __init davinci_serial_init(struct platform_device *serial_dev)
 		if (ret)
 			continue;
 
-		ret = davinci_serial_setup_clk(i, &p->uartclk);
-		if (ret)
+		clk = clk_get(dev, NULL);
+		if (IS_ERR(clk)) {
+			pr_err("%s:%d: failed to get UART%d clock\n",
+			       __func__, __LINE__, i);
 			continue;
+		}
+
+		clk_prepare_enable(clk);
+
+		p->uartclk = clk_get_rate(clk);
 
 		if (!p->membase && p->mapbase) {
 			p->membase = ioremap(p->mapbase, SZ_4K);

commit fcf7157ba3b50e57653544421250ebbe81a33d81
Author: Manjunathappa, Prakash <prakash.pm@ti.com>
Date:   Wed Jun 19 14:45:42 2013 +0530

    ARM: davinci: serial: get rid of davinci_uart_config
    
    "struct davinci_uart_config" was introduced to specify
    UART ports brought out or enabled on the board. But
    none of the boards use it for that purpose and we are
    not going to add anymore board files, so remove the
    structure.
    
    Signed-off-by: Manjunathappa, Prakash <prakash.pm@ti.com>
    Suggested-by: Sekhar Nori <nsekhar@ti.com>
    [nsekhar@ti.com: split patch to remove davinci_serial_setup_clk()
                     changes.]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/serial.c b/arch/arm/mach-davinci/serial.c
index 2bc74c2a8d45..45bd41a924db 100644
--- a/arch/arm/mach-davinci/serial.c
+++ b/arch/arm/mach-davinci/serial.c
@@ -92,10 +92,9 @@ int __init davinci_serial_setup_clk(unsigned instance, unsigned int *rate)
 	return 0;
 }
 
-int __init davinci_serial_init(struct davinci_uart_config *info)
+int __init davinci_serial_init(struct platform_device *serial_dev)
 {
 	int i, ret = 0;
-	struct davinci_soc_info *soc_info = &davinci_soc_info;
 	struct device *dev;
 	struct plat_serial8250_port *p;
 
@@ -103,13 +102,11 @@ int __init davinci_serial_init(struct davinci_uart_config *info)
 	 * Make sure the serial ports are muxed on at this point.
 	 * You have to mux them off in device drivers later on if not needed.
 	 */
-	for (i = 0; soc_info->serial_dev[i].dev.platform_data != NULL; i++) {
-		dev = &soc_info->serial_dev[i].dev;
+	for (i = 0; serial_dev[i].dev.platform_data != NULL; i++) {
+		dev = &serial_dev[i].dev;
 		p = dev->platform_data;
-		if (!(info->enabled_uarts & (1 << i)))
-			continue;
 
-		ret = platform_device_register(&soc_info->serial_dev[i]);
+		ret = platform_device_register(&serial_dev[i]);
 		if (ret)
 			continue;
 

commit 19955c3d7453757271d05859958ca1804a5d2d67
Author: Manjunathappa, Prakash <prakash.pm@ti.com>
Date:   Wed Jun 19 14:45:38 2013 +0530

    ARM: davinci: uart: move to devid based clk_get
    
    For modules having single clock, clk_get should be done with dev_id.
    But current davinci implementation handles multiple instances
    of the UART devices with single platform_device_register. Hence clk_get
    is based on con_id rather than dev_id, this is not correct. Do
    platform_device_register for each instance and clk_get on dev_id.
    
    Signed-off-by: Manjunathappa, Prakash <prakash.pm@ti.com>
    [nsekhar@ti.com: actually stop using con_id in clk_get(), squash the
                     patch adding OF aux data into this one]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/serial.c b/arch/arm/mach-davinci/serial.c
index f2625814c3c9..2bc74c2a8d45 100644
--- a/arch/arm/mach-davinci/serial.c
+++ b/arch/arm/mach-davinci/serial.c
@@ -73,13 +73,11 @@ static void __init davinci_serial_reset(struct plat_serial8250_port *p)
 /* Enable UART clock and obtain its rate */
 int __init davinci_serial_setup_clk(unsigned instance, unsigned int *rate)
 {
-	char name[16];
 	struct clk *clk;
 	struct davinci_soc_info *soc_info = &davinci_soc_info;
-	struct device *dev = &soc_info->serial_dev->dev;
+	struct device *dev = &soc_info->serial_dev[instance].dev;
 
-	sprintf(name, "uart%d", instance);
-	clk = clk_get(dev, name);
+	clk = clk_get(dev, NULL);
 	if (IS_ERR(clk)) {
 		pr_err("%s:%d: failed to get UART%d clock\n",
 					__func__, __LINE__, instance);
@@ -96,19 +94,25 @@ int __init davinci_serial_setup_clk(unsigned instance, unsigned int *rate)
 
 int __init davinci_serial_init(struct davinci_uart_config *info)
 {
-	int i, ret;
+	int i, ret = 0;
 	struct davinci_soc_info *soc_info = &davinci_soc_info;
-	struct device *dev = &soc_info->serial_dev->dev;
-	struct plat_serial8250_port *p = dev->platform_data;
+	struct device *dev;
+	struct plat_serial8250_port *p;
 
 	/*
 	 * Make sure the serial ports are muxed on at this point.
 	 * You have to mux them off in device drivers later on if not needed.
 	 */
-	for (i = 0; p->flags; i++, p++) {
+	for (i = 0; soc_info->serial_dev[i].dev.platform_data != NULL; i++) {
+		dev = &soc_info->serial_dev[i].dev;
+		p = dev->platform_data;
 		if (!(info->enabled_uarts & (1 << i)))
 			continue;
 
+		ret = platform_device_register(&soc_info->serial_dev[i]);
+		if (ret)
+			continue;
+
 		ret = davinci_serial_setup_clk(i, &p->uartclk);
 		if (ret)
 			continue;
@@ -125,6 +129,5 @@ int __init davinci_serial_init(struct davinci_uart_config *info)
 		if (p->membase && p->type != PORT_AR7)
 			davinci_serial_reset(p);
 	}
-
-	return platform_device_register(soc_info->serial_dev);
+	return ret;
 }

commit 76d57ce6ef6060f611c14675249b7300a3c96368
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Wed Aug 29 22:48:52 2012 +0530

    ARM: davinci: serial: provide API to initialze UART clocks
    
    Provide an API to initialize a UART clock. Refactor existing
    davinci_serial_init() to separate out the part which enables
    the clock.
    
    This will later be used to help DA850 DT boot support.
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/serial.c b/arch/arm/mach-davinci/serial.c
index 24ddb0d32a0f..f2625814c3c9 100644
--- a/arch/arm/mach-davinci/serial.c
+++ b/arch/arm/mach-davinci/serial.c
@@ -70,11 +70,33 @@ static void __init davinci_serial_reset(struct plat_serial8250_port *p)
 				 UART_DM646X_SCR_TX_WATERMARK);
 }
 
-int __init davinci_serial_init(struct davinci_uart_config *info)
+/* Enable UART clock and obtain its rate */
+int __init davinci_serial_setup_clk(unsigned instance, unsigned int *rate)
 {
-	int i;
 	char name[16];
-	struct clk *uart_clk;
+	struct clk *clk;
+	struct davinci_soc_info *soc_info = &davinci_soc_info;
+	struct device *dev = &soc_info->serial_dev->dev;
+
+	sprintf(name, "uart%d", instance);
+	clk = clk_get(dev, name);
+	if (IS_ERR(clk)) {
+		pr_err("%s:%d: failed to get UART%d clock\n",
+					__func__, __LINE__, instance);
+		return PTR_ERR(clk);
+	}
+
+	clk_prepare_enable(clk);
+
+	if (rate)
+		*rate = clk_get_rate(clk);
+
+	return 0;
+}
+
+int __init davinci_serial_init(struct davinci_uart_config *info)
+{
+	int i, ret;
 	struct davinci_soc_info *soc_info = &davinci_soc_info;
 	struct device *dev = &soc_info->serial_dev->dev;
 	struct plat_serial8250_port *p = dev->platform_data;
@@ -87,16 +109,9 @@ int __init davinci_serial_init(struct davinci_uart_config *info)
 		if (!(info->enabled_uarts & (1 << i)))
 			continue;
 
-		sprintf(name, "uart%d", i);
-		uart_clk = clk_get(dev, name);
-		if (IS_ERR(uart_clk)) {
-			printk(KERN_ERR "%s:%d: failed to get UART%d clock\n",
-					__func__, __LINE__, i);
+		ret = davinci_serial_setup_clk(i, &p->uartclk);
+		if (ret)
 			continue;
-		}
-
-		clk_prepare_enable(uart_clk);
-		p->uartclk = clk_get_rate(uart_clk);
 
 		if (!p->membase && p->mapbase) {
 			p->membase = ioremap(p->mapbase, SZ_4K);

commit b6f1ffed9d8a830ab94fd3fc6182e2fc8c77cba0
Author: m-karicheri2@ti.com <m-karicheri2@ti.com>
Date:   Thu Aug 2 16:53:48 2012 +0000

    ARM: davinci: convert platform code to use clk_prepare/clk_unprepare
    
    As a first step towards migrating davinci platforms to use common clock
    framework, replace all instances of clk_enable() with clk_prepare_enable()
    and clk_disable() with clk_disable_unprepare(). Until the platform is
    switched to use the CONFIG_HAVE_CLK_PREPARE Kconfig variable, this just
    adds a might_sleep() call and would work without any issues.
    
    This will make it easy later to switch to common clk based implementation
    of clk driver from DaVinci specific driver.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Reviewed-by: Mike Turquette <mturquette@linaro.org>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/serial.c b/arch/arm/mach-davinci/serial.c
index 1875740fe27c..24ddb0d32a0f 100644
--- a/arch/arm/mach-davinci/serial.c
+++ b/arch/arm/mach-davinci/serial.c
@@ -95,7 +95,7 @@ int __init davinci_serial_init(struct davinci_uart_config *info)
 			continue;
 		}
 
-		clk_enable(uart_clk);
+		clk_prepare_enable(uart_clk);
 		p->uartclk = clk_get_rate(uart_clk);
 
 		if (!p->membase && p->mapbase) {

commit e2800007f3b9aab51c1fe866034db576d3a9fd83
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Sun May 2 14:28:14 2010 -0400

    Davinci: serial - conditional reset via pwremu
    
    With this patch, AR7 type uart ports are not reset via pwremu registers.  This
    allows davinci_serial_init() reuse on tnetv107x soc.
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/serial.c b/arch/arm/mach-davinci/serial.c
index 81af42ca29d2..1875740fe27c 100644
--- a/arch/arm/mach-davinci/serial.c
+++ b/arch/arm/mach-davinci/serial.c
@@ -107,7 +107,7 @@ int __init davinci_serial_init(struct davinci_uart_config *info)
 				pr_err("uart regs ioremap failed\n");
 		}
 
-		if (p->membase)
+		if (p->membase && p->type != PORT_AR7)
 			davinci_serial_reset(p);
 	}
 

commit 9ee1acefa86083c6acf4112983b88a0057eb7785
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Sun May 2 14:28:13 2010 -0400

    Davinci: serial - use ioremap()
    
    This patch implements davinci serial cleanups towards having this code
    reusable on tnetv107x.
    
    The change reuses the platform data membase field to hold the remapped space.
    By disabling the UPF_IOREMAP flag in the platform data, we prevent
    the 8250 driver from repeating the ioremap.
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/serial.c b/arch/arm/mach-davinci/serial.c
index 709e1a90ec2a..81af42ca29d2 100644
--- a/arch/arm/mach-davinci/serial.c
+++ b/arch/arm/mach-davinci/serial.c
@@ -35,14 +35,20 @@ static inline unsigned int serial_read_reg(struct plat_serial8250_port *up,
 					   int offset)
 {
 	offset <<= up->regshift;
-	return (unsigned int)__raw_readl(IO_ADDRESS(up->mapbase) + offset);
+
+	WARN_ONCE(!up->membase, "unmapped read: uart[%d]\n", offset);
+
+	return (unsigned int)__raw_readl(up->membase + offset);
 }
 
 static inline void serial_write_reg(struct plat_serial8250_port *p, int offset,
 				    int value)
 {
 	offset <<= p->regshift;
-	__raw_writel(value, IO_ADDRESS(p->mapbase) + offset);
+
+	WARN_ONCE(!p->membase, "unmapped write: uart[%d]\n", offset);
+
+	__raw_writel(value, p->membase + offset);
 }
 
 static void __init davinci_serial_reset(struct plat_serial8250_port *p)
@@ -83,14 +89,26 @@ int __init davinci_serial_init(struct davinci_uart_config *info)
 
 		sprintf(name, "uart%d", i);
 		uart_clk = clk_get(dev, name);
-		if (IS_ERR(uart_clk))
+		if (IS_ERR(uart_clk)) {
 			printk(KERN_ERR "%s:%d: failed to get UART%d clock\n",
 					__func__, __LINE__, i);
-		else {
-			clk_enable(uart_clk);
-			p->uartclk = clk_get_rate(uart_clk);
-			davinci_serial_reset(p);
+			continue;
 		}
+
+		clk_enable(uart_clk);
+		p->uartclk = clk_get_rate(uart_clk);
+
+		if (!p->membase && p->mapbase) {
+			p->membase = ioremap(p->mapbase, SZ_4K);
+
+			if (p->membase)
+				p->flags &= ~UPF_IOREMAP;
+			else
+				pr_err("uart regs ioremap failed\n");
+		}
+
+		if (p->membase)
+			davinci_serial_reset(p);
 	}
 
 	return platform_device_register(soc_info->serial_dev);

commit da0122ca8b7804b9cd8fa7eff466bafba27f09a3
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Sun May 2 14:28:12 2010 -0400

    Davinci: serial - remove unnecessary define
    
    The uart pdata array is already terminated by a zero flag field.
    
    This patch reuses this terminator and eliminates DAVINCI_MAX_NR_UARTS
    definition.  This way, future platforms can have different number of uarts
    initialized via davinci_serial_init().
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/serial.c b/arch/arm/mach-davinci/serial.c
index 7ce5ba086575..709e1a90ec2a 100644
--- a/arch/arm/mach-davinci/serial.c
+++ b/arch/arm/mach-davinci/serial.c
@@ -77,7 +77,7 @@ int __init davinci_serial_init(struct davinci_uart_config *info)
 	 * Make sure the serial ports are muxed on at this point.
 	 * You have to mux them off in device drivers later on if not needed.
 	 */
-	for (i = 0; i < DAVINCI_MAX_NR_UARTS; i++, p++) {
+	for (i = 0; p->flags; i++, p++) {
 		if (!(info->enabled_uarts & (1 << i)))
 			continue;
 

commit 42d399e4189346b495fec8a9a267e8b7f744ee48
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Fri Oct 2 22:05:29 2009 +0400

    DaVinci: remove unneeded #include's
    
    There have accumulated quite a lot of them after the code reorganizations...
    
    In several cases I had to replace #include <linux/dma-mapping.h> which wasn't
    needed directly but happened to #include <linux/err.h> which was needed.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/serial.c b/arch/arm/mach-davinci/serial.c
index c530c7333d0a..7ce5ba086575 100644
--- a/arch/arm/mach-davinci/serial.c
+++ b/arch/arm/mach-davinci/serial.c
@@ -28,14 +28,8 @@
 #include <linux/clk.h>
 #include <linux/io.h>
 
-#include <asm/irq.h>
-#include <mach/hardware.h>
 #include <mach/serial.h>
-#include <mach/irqs.h>
 #include <mach/cputype.h>
-#include <mach/common.h>
-
-#include "clock.h"
 
 static inline unsigned int serial_read_reg(struct plat_serial8250_port *up,
 					   int offset)

commit 65e866a9741126c678e6dcd5d4fa8c9eca18e945
Author: Mark A. Greer <mgreer@mvista.com>
Date:   Wed Mar 18 12:36:08 2009 -0500

    davinci: Move serial platform_device into SoC-specific files
    
    Currently, there is one set of platform_device and platform_data
    structures for all DaVinci SoCs.  The differences in the data
    between the various SoCs is handled by davinci_serial_init()
    by checking the SoC type.  However, as new SoCs appear, this
    routine will become more & more cluttered.
    
    To clean up the routine and make it easier to add support for new
    SoCs, move the platform_device and platform_data structures into the
    SoC-specific code and use the SoC infrastructure to provide access
    to the data.
    
    In the process, fix a bug where the wrong irq is used for uart2
    of the dm646x.
    
    Signed-off-by: Mark A. Greer <mgreer@mvista.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/serial.c b/arch/arm/mach-davinci/serial.c
index 695075796522..c530c7333d0a 100644
--- a/arch/arm/mach-davinci/serial.c
+++ b/arch/arm/mach-davinci/serial.c
@@ -33,6 +33,8 @@
 #include <mach/serial.h>
 #include <mach/irqs.h>
 #include <mach/cputype.h>
+#include <mach/common.h>
+
 #include "clock.h"
 
 static inline unsigned int serial_read_reg(struct plat_serial8250_port *up,
@@ -49,44 +51,6 @@ static inline void serial_write_reg(struct plat_serial8250_port *p, int offset,
 	__raw_writel(value, IO_ADDRESS(p->mapbase) + offset);
 }
 
-static struct plat_serial8250_port serial_platform_data[] = {
-	{
-		.mapbase	= DAVINCI_UART0_BASE,
-		.irq		= IRQ_UARTINT0,
-		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
-				  UPF_IOREMAP,
-		.iotype		= UPIO_MEM,
-		.regshift	= 2,
-	},
-	{
-		.mapbase	= DAVINCI_UART1_BASE,
-		.irq		= IRQ_UARTINT1,
-		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
-				  UPF_IOREMAP,
-		.iotype		= UPIO_MEM,
-		.regshift	= 2,
-	},
-	{
-		.mapbase	= DAVINCI_UART2_BASE,
-		.irq		= IRQ_UARTINT2,
-		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
-				  UPF_IOREMAP,
-		.iotype		= UPIO_MEM,
-		.regshift	= 2,
-	},
-	{
-		.flags		= 0
-	},
-};
-
-static struct platform_device serial_device = {
-	.name			= "serial8250",
-	.id			= PLAT8250_DEV_PLATFORM,
-	.dev			= {
-		.platform_data	= serial_platform_data,
-	},
-};
-
 static void __init davinci_serial_reset(struct plat_serial8250_port *p)
 {
 	unsigned int pwremu = 0;
@@ -106,35 +70,22 @@ static void __init davinci_serial_reset(struct plat_serial8250_port *p)
 				 UART_DM646X_SCR_TX_WATERMARK);
 }
 
-void __init davinci_serial_init(struct davinci_uart_config *info)
+int __init davinci_serial_init(struct davinci_uart_config *info)
 {
 	int i;
 	char name[16];
 	struct clk *uart_clk;
-	struct device *dev = &serial_device.dev;
+	struct davinci_soc_info *soc_info = &davinci_soc_info;
+	struct device *dev = &soc_info->serial_dev->dev;
+	struct plat_serial8250_port *p = dev->platform_data;
 
 	/*
 	 * Make sure the serial ports are muxed on at this point.
-	 * You have to mux them off in device drivers later on
-	 * if not needed.
+	 * You have to mux them off in device drivers later on if not needed.
 	 */
-	for (i = 0; i < DAVINCI_MAX_NR_UARTS; i++) {
-		struct plat_serial8250_port *p = serial_platform_data + i;
-
-		if (!(info->enabled_uarts & (1 << i))) {
-			p->flags = 0;
+	for (i = 0; i < DAVINCI_MAX_NR_UARTS; i++, p++) {
+		if (!(info->enabled_uarts & (1 << i)))
 			continue;
-		}
-
-		if (cpu_is_davinci_dm646x())
-			p->iotype = UPIO_MEM32;
-
-		if (cpu_is_davinci_dm355()) {
-			if (i == 2) {
-				p->mapbase = (unsigned long)DM355_UART2_BASE;
-				p->irq = IRQ_DM355_UARTINT2;
-			}
-		}
 
 		sprintf(name, "uart%d", i);
 		uart_clk = clk_get(dev, name);
@@ -147,11 +98,6 @@ void __init davinci_serial_init(struct davinci_uart_config *info)
 			davinci_serial_reset(p);
 		}
 	}
-}
 
-static int __init davinci_init(void)
-{
-	return platform_device_register(&serial_device);
+	return platform_device_register(soc_info->serial_dev);
 }
-
-arch_initcall(davinci_init);

commit 617b925f94e0126841164ffd40dd3a8879502b57
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Tue Apr 14 08:04:26 2009 -0500

    davinci: serial: generalize for more SoCs
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/serial.c b/arch/arm/mach-davinci/serial.c
index 3010f9971255..695075796522 100644
--- a/arch/arm/mach-davinci/serial.c
+++ b/arch/arm/mach-davinci/serial.c
@@ -32,32 +32,47 @@
 #include <mach/hardware.h>
 #include <mach/serial.h>
 #include <mach/irqs.h>
+#include <mach/cputype.h>
+#include "clock.h"
 
-#define UART_DAVINCI_PWREMU 0x0c
-
-static inline unsigned int davinci_serial_in(struct plat_serial8250_port *up,
-					  int offset)
+static inline unsigned int serial_read_reg(struct plat_serial8250_port *up,
+					   int offset)
 {
 	offset <<= up->regshift;
-	return (unsigned int)__raw_readb(up->membase + offset);
+	return (unsigned int)__raw_readl(IO_ADDRESS(up->mapbase) + offset);
 }
 
-static inline void davinci_serial_outp(struct plat_serial8250_port *p,
-				       int offset, int value)
+static inline void serial_write_reg(struct plat_serial8250_port *p, int offset,
+				    int value)
 {
 	offset <<= p->regshift;
-	__raw_writeb(value, p->membase + offset);
+	__raw_writel(value, IO_ADDRESS(p->mapbase) + offset);
 }
 
 static struct plat_serial8250_port serial_platform_data[] = {
 	{
-		.membase	= (char *)IO_ADDRESS(DAVINCI_UART0_BASE),
-		.mapbase	= (unsigned long)DAVINCI_UART0_BASE,
+		.mapbase	= DAVINCI_UART0_BASE,
 		.irq		= IRQ_UARTINT0,
-		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
+				  UPF_IOREMAP,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+	},
+	{
+		.mapbase	= DAVINCI_UART1_BASE,
+		.irq		= IRQ_UARTINT1,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
+				  UPF_IOREMAP,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+	},
+	{
+		.mapbase	= DAVINCI_UART2_BASE,
+		.irq		= IRQ_UARTINT2,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
+				  UPF_IOREMAP,
 		.iotype		= UPIO_MEM,
 		.regshift	= 2,
-		.uartclk	= 27000000,
 	},
 	{
 		.flags		= 0
@@ -74,22 +89,68 @@ static struct platform_device serial_device = {
 
 static void __init davinci_serial_reset(struct plat_serial8250_port *p)
 {
-	/* reset both transmitter and receiver: bits 14,13 = UTRST, URRST */
 	unsigned int pwremu = 0;
 
-	davinci_serial_outp(p, UART_IER, 0);  /* disable all interrupts */
+	serial_write_reg(p, UART_IER, 0);  /* disable all interrupts */
 
-	davinci_serial_outp(p, UART_DAVINCI_PWREMU, pwremu);
+	/* reset both transmitter and receiver: bits 14,13 = UTRST, URRST */
+	serial_write_reg(p, UART_DAVINCI_PWREMU, pwremu);
 	mdelay(10);
 
 	pwremu |= (0x3 << 13);
 	pwremu |= 0x1;
-	davinci_serial_outp(p, UART_DAVINCI_PWREMU, pwremu);
+	serial_write_reg(p, UART_DAVINCI_PWREMU, pwremu);
+
+	if (cpu_is_davinci_dm646x())
+		serial_write_reg(p, UART_DM646X_SCR,
+				 UART_DM646X_SCR_TX_WATERMARK);
+}
+
+void __init davinci_serial_init(struct davinci_uart_config *info)
+{
+	int i;
+	char name[16];
+	struct clk *uart_clk;
+	struct device *dev = &serial_device.dev;
+
+	/*
+	 * Make sure the serial ports are muxed on at this point.
+	 * You have to mux them off in device drivers later on
+	 * if not needed.
+	 */
+	for (i = 0; i < DAVINCI_MAX_NR_UARTS; i++) {
+		struct plat_serial8250_port *p = serial_platform_data + i;
+
+		if (!(info->enabled_uarts & (1 << i))) {
+			p->flags = 0;
+			continue;
+		}
+
+		if (cpu_is_davinci_dm646x())
+			p->iotype = UPIO_MEM32;
+
+		if (cpu_is_davinci_dm355()) {
+			if (i == 2) {
+				p->mapbase = (unsigned long)DM355_UART2_BASE;
+				p->irq = IRQ_DM355_UARTINT2;
+			}
+		}
+
+		sprintf(name, "uart%d", i);
+		uart_clk = clk_get(dev, name);
+		if (IS_ERR(uart_clk))
+			printk(KERN_ERR "%s:%d: failed to get UART%d clock\n",
+					__func__, __LINE__, i);
+		else {
+			clk_enable(uart_clk);
+			p->uartclk = clk_get_rate(uart_clk);
+			davinci_serial_reset(p);
+		}
+	}
 }
 
 static int __init davinci_init(void)
 {
-	davinci_serial_reset(&serial_platform_data[0]);
 	return platform_device_register(&serial_device);
 }
 

commit fced80c735941fa518ac67c0b61bbe153fb8c050
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Sep 6 12:10:45 2008 +0100

    [ARM] Convert asm/io.h to linux/io.h
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-davinci/serial.c b/arch/arm/mach-davinci/serial.c
index caf101e2cc62..3010f9971255 100644
--- a/arch/arm/mach-davinci/serial.c
+++ b/arch/arm/mach-davinci/serial.c
@@ -26,8 +26,8 @@
 #include <linux/platform_device.h>
 #include <linux/delay.h>
 #include <linux/clk.h>
+#include <linux/io.h>
 
-#include <asm/io.h>
 #include <asm/irq.h>
 #include <mach/hardware.h>
 #include <mach/serial.h>

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-davinci/serial.c b/arch/arm/mach-davinci/serial.c
index c2b812f3391c..caf101e2cc62 100644
--- a/arch/arm/mach-davinci/serial.c
+++ b/arch/arm/mach-davinci/serial.c
@@ -29,9 +29,9 @@
 
 #include <asm/io.h>
 #include <asm/irq.h>
-#include <asm/arch/hardware.h>
-#include <asm/arch/serial.h>
-#include <asm/arch/irqs.h>
+#include <mach/hardware.h>
+#include <mach/serial.h>
+#include <mach/irqs.h>
 
 #define UART_DAVINCI_PWREMU 0x0c
 

commit be509729356b7433f73df2b9a966674a437fbbc1
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Aug 4 10:41:28 2008 +0100

    [ARM] Remove asm/hardware.h, use asm/arch/hardware.h instead
    
    Remove includes of asm/hardware.h in addition to asm/arch/hardware.h.
    Then, since asm/hardware.h only exists to include asm/arch/hardware.h,
    update everything to directly include asm/arch/hardware.h and remove
    asm/hardware.h.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-davinci/serial.c b/arch/arm/mach-davinci/serial.c
index 8368c93c788d..c2b812f3391c 100644
--- a/arch/arm/mach-davinci/serial.c
+++ b/arch/arm/mach-davinci/serial.c
@@ -29,7 +29,7 @@
 
 #include <asm/io.h>
 #include <asm/irq.h>
-#include <asm/hardware.h>
+#include <asm/arch/hardware.h>
 #include <asm/arch/serial.h>
 #include <asm/arch/irqs.h>
 

commit 7c6337e225364870e9bf02a3ae277d9fdea483f8
Author: Kevin Hilman <khilman@mvista.com>
Date:   Mon Apr 30 19:37:19 2007 +0100

    [ARM] 4303/3: base kernel support for TI DaVinci
    
    Add base kernel support for the TI DaVinci platform.
    
    This patch only includes interrupts, timers, CPU identification,
    serial support and basic power and sleep controller init.  More
    drivers to come.
    
    Signed-off-by: Kevin Hilman <khilman@mvista.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-davinci/serial.c b/arch/arm/mach-davinci/serial.c
new file mode 100644
index 000000000000..8368c93c788d
--- /dev/null
+++ b/arch/arm/mach-davinci/serial.c
@@ -0,0 +1,96 @@
+/*
+ * TI DaVinci serial driver
+ *
+ * Copyright (C) 2006 Texas Instruments.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/serial_8250.h>
+#include <linux/serial_reg.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/arch/serial.h>
+#include <asm/arch/irqs.h>
+
+#define UART_DAVINCI_PWREMU 0x0c
+
+static inline unsigned int davinci_serial_in(struct plat_serial8250_port *up,
+					  int offset)
+{
+	offset <<= up->regshift;
+	return (unsigned int)__raw_readb(up->membase + offset);
+}
+
+static inline void davinci_serial_outp(struct plat_serial8250_port *p,
+				       int offset, int value)
+{
+	offset <<= p->regshift;
+	__raw_writeb(value, p->membase + offset);
+}
+
+static struct plat_serial8250_port serial_platform_data[] = {
+	{
+		.membase	= (char *)IO_ADDRESS(DAVINCI_UART0_BASE),
+		.mapbase	= (unsigned long)DAVINCI_UART0_BASE,
+		.irq		= IRQ_UARTINT0,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= 27000000,
+	},
+	{
+		.flags		= 0
+	},
+};
+
+static struct platform_device serial_device = {
+	.name			= "serial8250",
+	.id			= PLAT8250_DEV_PLATFORM,
+	.dev			= {
+		.platform_data	= serial_platform_data,
+	},
+};
+
+static void __init davinci_serial_reset(struct plat_serial8250_port *p)
+{
+	/* reset both transmitter and receiver: bits 14,13 = UTRST, URRST */
+	unsigned int pwremu = 0;
+
+	davinci_serial_outp(p, UART_IER, 0);  /* disable all interrupts */
+
+	davinci_serial_outp(p, UART_DAVINCI_PWREMU, pwremu);
+	mdelay(10);
+
+	pwremu |= (0x3 << 13);
+	pwremu |= 0x1;
+	davinci_serial_outp(p, UART_DAVINCI_PWREMU, pwremu);
+}
+
+static int __init davinci_init(void)
+{
+	davinci_serial_reset(&serial_platform_data[0]);
+	return platform_device_register(&serial_device);
+}
+
+arch_initcall(davinci_init);
