commit 76c7473f753dabee2e6ad03f72181b45083a0c7c
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Mon Jul 22 15:17:41 2019 +0200

    ARM: davinci: da850: switch to using the clocksource driver
    
    We now have a proper clocksource driver for davinci. Switch the da850
    platform to using it.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Reviewed-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index dcf3536c46bc..73b7cc53f966 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -35,7 +35,8 @@
 #include <mach/cputype.h>
 #include <mach/da8xx.h>
 #include <mach/pm.h>
-#include <mach/time.h>
+
+#include <clocksource/timer-davinci.h>
 
 #include "irqs.h"
 #include "mux.h"
@@ -333,38 +334,16 @@ static struct davinci_id da850_ids[] = {
 	},
 };
 
-static struct davinci_timer_instance da850_timer_instance[4] = {
-	{
-		.base		= DA8XX_TIMER64P0_BASE,
-		.bottom_irq	= DAVINCI_INTC_IRQ(IRQ_DA8XX_TINT12_0),
-		.top_irq	= DAVINCI_INTC_IRQ(IRQ_DA8XX_TINT34_0),
-	},
-	{
-		.base		= DA8XX_TIMER64P1_BASE,
-		.bottom_irq	= DAVINCI_INTC_IRQ(IRQ_DA8XX_TINT12_1),
-		.top_irq	= DAVINCI_INTC_IRQ(IRQ_DA8XX_TINT34_1),
-	},
-	{
-		.base		= DA850_TIMER64P2_BASE,
-		.bottom_irq	= DAVINCI_INTC_IRQ(IRQ_DA850_TINT12_2),
-		.top_irq	= DAVINCI_INTC_IRQ(IRQ_DA850_TINT34_2),
-	},
-	{
-		.base		= DA850_TIMER64P3_BASE,
-		.bottom_irq	= DAVINCI_INTC_IRQ(IRQ_DA850_TINT12_3),
-		.top_irq	= DAVINCI_INTC_IRQ(IRQ_DA850_TINT34_3),
-	},
-};
-
 /*
- * T0_BOT: Timer 0, bottom		: Used for clock_event
- * T0_TOP: Timer 0, top			: Used for clocksource
- * T1_BOT, T1_TOP: Timer 1, bottom & top: Used for watchdog timer
+ * Bottom half of timer 0 is used for clock_event, top half for
+ * clocksource.
  */
-static struct davinci_timer_info da850_timer_info = {
-	.timers		= da850_timer_instance,
-	.clockevent_id	= T0_BOT,
-	.clocksource_id	= T0_TOP,
+static const struct davinci_timer_cfg da850_timer_cfg = {
+	.reg = DEFINE_RES_IO(DA8XX_TIMER64P0_BASE, SZ_4K),
+	.irq = {
+		DEFINE_RES_IRQ(DAVINCI_INTC_IRQ(IRQ_DA8XX_TINT12_0)),
+		DEFINE_RES_IRQ(DAVINCI_INTC_IRQ(IRQ_DA8XX_TINT34_0)),
+	},
 };
 
 #ifdef CONFIG_CPU_FREQ
@@ -635,7 +614,6 @@ static const struct davinci_soc_info davinci_soc_info_da850 = {
 	.pinmux_base		= DA8XX_SYSCFG0_BASE + 0x120,
 	.pinmux_pins		= da850_pins,
 	.pinmux_pins_num	= ARRAY_SIZE(da850_pins),
-	.timer_info		= &da850_timer_info,
 	.emac_pdata		= &da8xx_emac_pdata,
 	.sram_dma		= DA8XX_SHARED_RAM_BASE,
 	.sram_len		= SZ_128K,
@@ -672,6 +650,7 @@ void __init da850_init_time(void)
 	void __iomem *pll0;
 	struct regmap *cfgchip;
 	struct clk *clk;
+	int rv;
 
 	clk_register_fixed_rate(NULL, "ref_clk", NULL, 0, DA850_REF_FREQ);
 
@@ -686,7 +665,8 @@ void __init da850_init_time(void)
 		return;
 	}
 
-	davinci_timer_init(clk);
+	rv = davinci_timer_register(clk, &da850_timer_cfg);
+	WARN(rv, "Unable to register the timer: %d\n", rv);
 }
 
 static struct resource da850_pll1_resources[] = {

commit d470df3bc5e1a9cd38995b55c918d9ecdda141e1
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Mon Jul 22 15:17:40 2019 +0200

    ARM: davinci: WARN_ON() if clk_get() fails
    
    Currently the timer code checks if the clock pointer passed to it is
    good (!IS_ERR(clk)). The new clocksource driver expects the clock to
    be functional and doesn't perform any checks so emit a warning if
    clk_get() fails. Apply this to all davinci platforms.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Reviewed-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 77bc64d6e39b..dcf3536c46bc 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -681,6 +681,10 @@ void __init da850_init_time(void)
 	da850_pll0_init(NULL, pll0, cfgchip);
 
 	clk = clk_get(NULL, "timer0");
+	if (WARN_ON(IS_ERR(clk))) {
+		pr_err("Unable to get the timer clock\n");
+		return;
+	}
 
 	davinci_timer_init(clk);
 }

commit 62e59c4e69b3cdbad67e3c2d49e4df4cfe1679e3
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Apr 18 15:20:22 2019 -0700

    clk: Remove io.h from clk-provider.h
    
    Now that we've gotten rid of clk_readl() we can remove io.h from the
    clk-provider header and push out the io.h include to any code that isn't
    already including the io.h header but using things like readl/writel,
    etc.
    
    Found with this grep:
    
      git grep -l clk-provider.h | grep '.c$' | xargs git grep -L 'linux/io.h' | \
            xargs git grep -l \
            -e '\<__iowrite32_copy\>' --or \
            -e '\<__ioread32_copy\>' --or \
            -e '\<__iowrite64_copy\>' --or \
            -e '\<ioremap_page_range\>' --or \
            -e '\<ioremap_huge_init\>' --or \
            -e '\<arch_ioremap_pud_supported\>' --or \
            -e '\<arch_ioremap_pmd_supported\>' --or \
            -e '\<devm_ioport_map\>' --or \
            -e '\<devm_ioport_unmap\>' --or \
            -e '\<IOMEM_ERR_PTR\>' --or \
            -e '\<devm_ioremap\>' --or \
            -e '\<devm_ioremap_nocache\>' --or \
            -e '\<devm_ioremap_wc\>' --or \
            -e '\<devm_iounmap\>' --or \
            -e '\<devm_ioremap_release\>' --or \
            -e '\<devm_memremap\>' --or \
            -e '\<devm_memunmap\>' --or \
            -e '\<__devm_memremap_pages\>' --or \
            -e '\<pci_remap_cfgspace\>' --or \
            -e '\<arch_has_dev_port\>' --or \
            -e '\<arch_phys_wc_add\>' --or \
            -e '\<arch_phys_wc_del\>' --or \
            -e '\<memremap\>' --or \
            -e '\<memunmap\>' --or \
            -e '\<arch_io_reserve_memtype_wc\>' --or \
            -e '\<arch_io_free_memtype_wc\>' --or \
            -e '\<__io_aw\>' --or \
            -e '\<__io_pbw\>' --or \
            -e '\<__io_paw\>' --or \
            -e '\<__io_pbr\>' --or \
            -e '\<__io_par\>' --or \
            -e '\<__raw_readb\>' --or \
            -e '\<__raw_readw\>' --or \
            -e '\<__raw_readl\>' --or \
            -e '\<__raw_readq\>' --or \
            -e '\<__raw_writeb\>' --or \
            -e '\<__raw_writew\>' --or \
            -e '\<__raw_writel\>' --or \
            -e '\<__raw_writeq\>' --or \
            -e '\<readb\>' --or \
            -e '\<readw\>' --or \
            -e '\<readl\>' --or \
            -e '\<readq\>' --or \
            -e '\<writeb\>' --or \
            -e '\<writew\>' --or \
            -e '\<writel\>' --or \
            -e '\<writeq\>' --or \
            -e '\<readb_relaxed\>' --or \
            -e '\<readw_relaxed\>' --or \
            -e '\<readl_relaxed\>' --or \
            -e '\<readq_relaxed\>' --or \
            -e '\<writeb_relaxed\>' --or \
            -e '\<writew_relaxed\>' --or \
            -e '\<writel_relaxed\>' --or \
            -e '\<writeq_relaxed\>' --or \
            -e '\<readsb\>' --or \
            -e '\<readsw\>' --or \
            -e '\<readsl\>' --or \
            -e '\<readsq\>' --or \
            -e '\<writesb\>' --or \
            -e '\<writesw\>' --or \
            -e '\<writesl\>' --or \
            -e '\<writesq\>' --or \
            -e '\<inb\>' --or \
            -e '\<inw\>' --or \
            -e '\<inl\>' --or \
            -e '\<outb\>' --or \
            -e '\<outw\>' --or \
            -e '\<outl\>' --or \
            -e '\<inb_p\>' --or \
            -e '\<inw_p\>' --or \
            -e '\<inl_p\>' --or \
            -e '\<outb_p\>' --or \
            -e '\<outw_p\>' --or \
            -e '\<outl_p\>' --or \
            -e '\<insb\>' --or \
            -e '\<insw\>' --or \
            -e '\<insl\>' --or \
            -e '\<outsb\>' --or \
            -e '\<outsw\>' --or \
            -e '\<outsl\>' --or \
            -e '\<insb_p\>' --or \
            -e '\<insw_p\>' --or \
            -e '\<insl_p\>' --or \
            -e '\<outsb_p\>' --or \
            -e '\<outsw_p\>' --or \
            -e '\<outsl_p\>' --or \
            -e '\<ioread8\>' --or \
            -e '\<ioread16\>' --or \
            -e '\<ioread32\>' --or \
            -e '\<ioread64\>' --or \
            -e '\<iowrite8\>' --or \
            -e '\<iowrite16\>' --or \
            -e '\<iowrite32\>' --or \
            -e '\<iowrite64\>' --or \
            -e '\<ioread16be\>' --or \
            -e '\<ioread32be\>' --or \
            -e '\<ioread64be\>' --or \
            -e '\<iowrite16be\>' --or \
            -e '\<iowrite32be\>' --or \
            -e '\<iowrite64be\>' --or \
            -e '\<ioread8_rep\>' --or \
            -e '\<ioread16_rep\>' --or \
            -e '\<ioread32_rep\>' --or \
            -e '\<ioread64_rep\>' --or \
            -e '\<iowrite8_rep\>' --or \
            -e '\<iowrite16_rep\>' --or \
            -e '\<iowrite32_rep\>' --or \
            -e '\<iowrite64_rep\>' --or \
            -e '\<__io_virt\>' --or \
            -e '\<pci_iounmap\>' --or \
            -e '\<virt_to_phys\>' --or \
            -e '\<phys_to_virt\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<__ioremap\>' --or \
            -e '\<iounmap\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<ioremap_nocache\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wt\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<xlate_dev_kmem_ptr\>' --or \
            -e '\<xlate_dev_mem_ptr\>' --or \
            -e '\<unxlate_dev_mem_ptr\>' --or \
            -e '\<virt_to_bus\>' --or \
            -e '\<bus_to_virt\>' --or \
            -e '\<memset_io\>' --or \
            -e '\<memcpy_fromio\>' --or \
            -e '\<memcpy_toio\>'
    
    I also reordered a couple includes when they weren't alphabetical and
    removed clk.h from kona, replacing it with clk-provider.h because
    that driver doesn't use clk consumer APIs.
    
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Mark Brown <broonie@kernel.org>
    Cc: Chris Zankel <chris@zankel.net>
    Acked-by: Max Filippov <jcmvbkbc@gmail.com>
    Acked-by: John Crispin <john@phrozen.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 67ab71ba3ad3..77bc64d6e39b 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -18,6 +18,7 @@
 #include <linux/cpufreq.h>
 #include <linux/gpio.h>
 #include <linux/init.h>
+#include <linux/io.h>
 #include <linux/irqchip/irq-davinci-cp-intc.h>
 #include <linux/mfd/da8xx-cfgchip.h>
 #include <linux/platform_data/clk-da8xx-cfgchip.h>

commit ef8006846a3a97d9d8bf49e63dba948d0d2dbbf0
Merge: 8dcd175bc3d5 1271d6d576b7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 6 12:59:46 2019 -0800

    Merge tag 'pm-5.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management updates from Rafael Wysocki:
     "These are PM-runtime framework changes to use ktime instead of jiffies
      for accounting, new PM core flag to mark devices that don't need any
      form of power management, cpuidle updates including driver API
      documentation and a new governor, cpufreq updates including a new
      driver for Armada 8K, thermal cleanups and more, some energy-aware
      scheduling (EAS) enabling changes, new chips support in the intel_idle
      and RAPL drivers and assorted cleanups in some other places.
    
      Specifics:
    
       - Update the PM-runtime framework to use ktime instead of jiffies for
         accounting (Thara Gopinath, Vincent Guittot)
    
       - Optimize the autosuspend code in the PM-runtime framework somewhat
         (Ladislav Michl)
    
       - Add a PM core flag to mark devices that don't need any form of
         power management (Sudeep Holla)
    
       - Introduce driver API documentation for cpuidle and add a new
         cpuidle governor for tickless systems (Rafael Wysocki)
    
       - Add Jacobsville support to the intel_idle driver (Zhang Rui)
    
       - Clean up a cpuidle core header file and the cpuidle-dt and ACPI
         processor-idle drivers (Yangtao Li, Joseph Lo, Yazen Ghannam)
    
       - Add new cpufreq driver for Armada 8K (Gregory Clement)
    
       - Fix and clean up cpufreq core (Rafael Wysocki, Viresh Kumar, Amit
         Kucheria)
    
       - Add support for light-weight tear-down and bring-up of CPUs to the
         cpufreq core and use it in the cpufreq-dt driver (Viresh Kumar)
    
       - Fix cpu_cooling Kconfig dependencies, add support for CPU cooling
         auto-registration to the cpufreq core and use it in multiple
         cpufreq drivers (Amit Kucheria)
    
       - Fix some minor issues and do some cleanups in the davinci,
         e_powersaver, ap806, s5pv210, qcom and kryo cpufreq drivers
         (Bartosz Golaszewski, Gustavo Silva, Julia Lawall, Paweł Chmiel,
         Taniya Das, Viresh Kumar)
    
       - Add a Hisilicon CPPC quirk to the cppc_cpufreq driver (Xiongfeng
         Wang)
    
       - Clean up the intel_pstate and acpi-cpufreq drivers (Erwan Velu,
         Rafael Wysocki)
    
       - Clean up multiple cpufreq drivers (Yangtao Li)
    
       - Update cpufreq-related MAINTAINERS entries (Baruch Siach, Lukas
         Bulwahn)
    
       - Add support for exposing the Energy Model via debugfs and make
         multiple cpufreq drivers register an Energy Model to support
         energy-aware scheduling (Quentin Perret, Dietmar Eggemann, Matthias
         Kaehlcke)
    
       - Add Ice Lake mobile and Jacobsville support to the Intel RAPL
         power-capping driver (Gayatri Kammela, Zhang Rui)
    
       - Add a power estimation helper to the operating performance points
         (OPP) framework and clean up a core function in it (Quentin Perret,
         Viresh Kumar)
    
       - Make minor improvements in the generic power domains (genpd), OPP
         and system suspend frameworks and in the PM core (Aditya Pakki,
         Douglas Anderson, Greg Kroah-Hartman, Rafael Wysocki, Yangtao Li)"
    
    * tag 'pm-5.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (80 commits)
      cpufreq: kryo: Release OPP tables on module removal
      cpufreq: ap806: add missing of_node_put after of_device_is_available
      cpufreq: acpi-cpufreq: Report if CPU doesn't support boost technologies
      cpufreq: Pass updated policy to driver ->setpolicy() callback
      cpufreq: Fix two debug messages in cpufreq_set_policy()
      cpufreq: Reorder and simplify cpufreq_update_policy()
      cpufreq: Add kerneldoc comments for two core functions
      PM / core: Add support to skip power management in device/driver model
      cpufreq: intel_pstate: Rework iowait boosting to be less aggressive
      cpufreq: intel_pstate: Eliminate intel_pstate_get_base_pstate()
      cpufreq: intel_pstate: Avoid redundant initialization of local vars
      powercap/intel_rapl: add Ice Lake mobile
      ACPI / processor: Set P_LVL{2,3} idle state descriptions
      cpufreq / cppc: Work around for Hisilicon CPPC cpufreq
      ACPI / CPPC: Add a helper to get desired performance
      cpufreq: davinci: move configuration to include/linux/platform_data
      cpufreq: speedstep: convert BUG() to BUG_ON()
      cpufreq: powernv: fix missing check of return value in init_powernv_pstates()
      cpufreq: longhaul: remove unneeded semicolon
      cpufreq: pcc-cpufreq: remove unneeded semicolon
      ..

commit 49b654fd43b29e8decaa38035eed9ca8f221e48a
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Feb 14 15:52:31 2019 +0100

    ARM: davinci: remove intc related fields from davinci_soc_info
    
    The fields related to the two davinci interrupt controllers are no
    longer used. Remove them.
    
    Reviewed-by: David Lechner <david@lechnology.com>
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 62a00fa94696..8a50956a9181 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -299,111 +299,6 @@ const short da850_vpif_display_pins[] __initconst = {
 	-1
 };
 
-/* FIQ are pri 0-1; otherwise 2-7, with 7 lowest priority */
-static u8 da850_default_priorities[DA850_N_CP_INTC_IRQ] = {
-	[IRQ_DA8XX_COMMTX]		= 7,
-	[IRQ_DA8XX_COMMRX]		= 7,
-	[IRQ_DA8XX_NINT]		= 7,
-	[IRQ_DA8XX_EVTOUT0]		= 7,
-	[IRQ_DA8XX_EVTOUT1]		= 7,
-	[IRQ_DA8XX_EVTOUT2]		= 7,
-	[IRQ_DA8XX_EVTOUT3]		= 7,
-	[IRQ_DA8XX_EVTOUT4]		= 7,
-	[IRQ_DA8XX_EVTOUT5]		= 7,
-	[IRQ_DA8XX_EVTOUT6]		= 7,
-	[IRQ_DA8XX_EVTOUT7]		= 7,
-	[IRQ_DA8XX_CCINT0]		= 7,
-	[IRQ_DA8XX_CCERRINT]		= 7,
-	[IRQ_DA8XX_TCERRINT0]		= 7,
-	[IRQ_DA8XX_AEMIFINT]		= 7,
-	[IRQ_DA8XX_I2CINT0]		= 7,
-	[IRQ_DA8XX_MMCSDINT0]		= 7,
-	[IRQ_DA8XX_MMCSDINT1]		= 7,
-	[IRQ_DA8XX_ALLINT0]		= 7,
-	[IRQ_DA8XX_RTC]			= 7,
-	[IRQ_DA8XX_SPINT0]		= 7,
-	[IRQ_DA8XX_TINT12_0]		= 7,
-	[IRQ_DA8XX_TINT34_0]		= 7,
-	[IRQ_DA8XX_TINT12_1]		= 7,
-	[IRQ_DA8XX_TINT34_1]		= 7,
-	[IRQ_DA8XX_UARTINT0]		= 7,
-	[IRQ_DA8XX_KEYMGRINT]		= 7,
-	[IRQ_DA850_MPUADDRERR0]		= 7,
-	[IRQ_DA8XX_CHIPINT0]		= 7,
-	[IRQ_DA8XX_CHIPINT1]		= 7,
-	[IRQ_DA8XX_CHIPINT2]		= 7,
-	[IRQ_DA8XX_CHIPINT3]		= 7,
-	[IRQ_DA8XX_TCERRINT1]		= 7,
-	[IRQ_DA8XX_C0_RX_THRESH_PULSE]	= 7,
-	[IRQ_DA8XX_C0_RX_PULSE]		= 7,
-	[IRQ_DA8XX_C0_TX_PULSE]		= 7,
-	[IRQ_DA8XX_C0_MISC_PULSE]	= 7,
-	[IRQ_DA8XX_C1_RX_THRESH_PULSE]	= 7,
-	[IRQ_DA8XX_C1_RX_PULSE]		= 7,
-	[IRQ_DA8XX_C1_TX_PULSE]		= 7,
-	[IRQ_DA8XX_C1_MISC_PULSE]	= 7,
-	[IRQ_DA8XX_MEMERR]		= 7,
-	[IRQ_DA8XX_GPIO0]		= 7,
-	[IRQ_DA8XX_GPIO1]		= 7,
-	[IRQ_DA8XX_GPIO2]		= 7,
-	[IRQ_DA8XX_GPIO3]		= 7,
-	[IRQ_DA8XX_GPIO4]		= 7,
-	[IRQ_DA8XX_GPIO5]		= 7,
-	[IRQ_DA8XX_GPIO6]		= 7,
-	[IRQ_DA8XX_GPIO7]		= 7,
-	[IRQ_DA8XX_GPIO8]		= 7,
-	[IRQ_DA8XX_I2CINT1]		= 7,
-	[IRQ_DA8XX_LCDINT]		= 7,
-	[IRQ_DA8XX_UARTINT1]		= 7,
-	[IRQ_DA8XX_MCASPINT]		= 7,
-	[IRQ_DA8XX_ALLINT1]		= 7,
-	[IRQ_DA8XX_SPINT1]		= 7,
-	[IRQ_DA8XX_UHPI_INT1]		= 7,
-	[IRQ_DA8XX_USB_INT]		= 7,
-	[IRQ_DA8XX_IRQN]		= 7,
-	[IRQ_DA8XX_RWAKEUP]		= 7,
-	[IRQ_DA8XX_UARTINT2]		= 7,
-	[IRQ_DA8XX_DFTSSINT]		= 7,
-	[IRQ_DA8XX_EHRPWM0]		= 7,
-	[IRQ_DA8XX_EHRPWM0TZ]		= 7,
-	[IRQ_DA8XX_EHRPWM1]		= 7,
-	[IRQ_DA8XX_EHRPWM1TZ]		= 7,
-	[IRQ_DA850_SATAINT]		= 7,
-	[IRQ_DA850_TINTALL_2]		= 7,
-	[IRQ_DA8XX_ECAP0]		= 7,
-	[IRQ_DA8XX_ECAP1]		= 7,
-	[IRQ_DA8XX_ECAP2]		= 7,
-	[IRQ_DA850_MMCSDINT0_1]		= 7,
-	[IRQ_DA850_MMCSDINT1_1]		= 7,
-	[IRQ_DA850_T12CMPINT0_2]	= 7,
-	[IRQ_DA850_T12CMPINT1_2]	= 7,
-	[IRQ_DA850_T12CMPINT2_2]	= 7,
-	[IRQ_DA850_T12CMPINT3_2]	= 7,
-	[IRQ_DA850_T12CMPINT4_2]	= 7,
-	[IRQ_DA850_T12CMPINT5_2]	= 7,
-	[IRQ_DA850_T12CMPINT6_2]	= 7,
-	[IRQ_DA850_T12CMPINT7_2]	= 7,
-	[IRQ_DA850_T12CMPINT0_3]	= 7,
-	[IRQ_DA850_T12CMPINT1_3]	= 7,
-	[IRQ_DA850_T12CMPINT2_3]	= 7,
-	[IRQ_DA850_T12CMPINT3_3]	= 7,
-	[IRQ_DA850_T12CMPINT4_3]	= 7,
-	[IRQ_DA850_T12CMPINT5_3]	= 7,
-	[IRQ_DA850_T12CMPINT6_3]	= 7,
-	[IRQ_DA850_T12CMPINT7_3]	= 7,
-	[IRQ_DA850_RPIINT]		= 7,
-	[IRQ_DA850_VPIFINT]		= 7,
-	[IRQ_DA850_CCINT1]		= 7,
-	[IRQ_DA850_CCERRINT1]		= 7,
-	[IRQ_DA850_TCERRINT2]		= 7,
-	[IRQ_DA850_TINTALL_3]		= 7,
-	[IRQ_DA850_MCBSP0RINT]		= 7,
-	[IRQ_DA850_MCBSP0XINT]		= 7,
-	[IRQ_DA850_MCBSP1RINT]		= 7,
-	[IRQ_DA850_MCBSP1XINT]		= 7,
-	[IRQ_DA8XX_ARMCLKSTOPREQ]	= 7,
-};
-
 static struct map_desc da850_io_desc[] = {
 	{
 		.virtual	= IO_VIRT,
@@ -739,9 +634,6 @@ static const struct davinci_soc_info davinci_soc_info_da850 = {
 	.pinmux_base		= DA8XX_SYSCFG0_BASE + 0x120,
 	.pinmux_pins		= da850_pins,
 	.pinmux_pins_num	= ARRAY_SIZE(da850_pins),
-	.intc_base		= DA8XX_CP_INTC_BASE,
-	.intc_irq_prios		= da850_default_priorities,
-	.intc_irq_num		= DA850_N_CP_INTC_IRQ,
 	.timer_info		= &da850_timer_info,
 	.emac_pdata		= &da8xx_emac_pdata,
 	.sram_dma		= DA8XX_SHARED_RAM_BASE,

commit 6567954b8e8e7cbb74b1340038dcac7ecc9e2e1b
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Feb 14 15:52:23 2019 +0100

    ARM: davinci: cp-intc: use the new-style config structure
    
    Modify the cp-intc driver to take all its configuration from the new
    config structure. Stop referencing davinci_soc_info in any way.
    Move the declaration for davinci_cp_intc_init() to
    irq-davinci-cp-intc.h and make it take the new config structure as
    parameter. Convert all users to the new version.
    
    Also: since the two da8xx SoCs default all irq priorities to 7, just
    drop the priority configuration at all and hardcode the channels to 7.
    
    It will simplify the driver code and make our lives easier when it
    comes to device-tree support.
    
    Reviewed-by: David Lechner <david@lechnology.com>
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index fe274ab63fc8..62a00fa94696 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -771,7 +771,7 @@ static const struct davinci_cp_intc_config da850_cp_intc_config = {
 
 void __init da850_init_irq(void)
 {
-	davinci_cp_intc_init();
+	davinci_cp_intc_init(&da850_cp_intc_config);
 }
 
 void __init da850_init_time(void)

commit b35b55e72c12b29fc04c14ba71cb5d2e5580fead
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Feb 14 15:52:21 2019 +0100

    ARM: davinci: cp-intc: use a common prefix for all symbols
    
    In preparation for moving the driver to drivers/irqchip do some
    cleanup: use a common prefix for all symbols.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Reviewed-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 9a3ce68c0de4..fe274ab63fc8 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -771,7 +771,7 @@ static const struct davinci_cp_intc_config da850_cp_intc_config = {
 
 void __init da850_init_irq(void)
 {
-	cp_intc_init();
+	davinci_cp_intc_init();
 }
 
 void __init da850_init_time(void)

commit 47b7c6195c43e0bf3f761e01682ea849961399e6
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Feb 14 15:52:20 2019 +0100

    ARM: davinci: cp-intc: add the new config structures for da8xx SoCs
    
    Add the new-style config structures for da8xx SoCs. They will be used
    once we make the cp-intc driver stop using davinci_soc_info.
    
    Reviewed-by: David Lechner <david@lechnology.com>
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 6df6994c0f26..9a3ce68c0de4 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -18,6 +18,7 @@
 #include <linux/cpufreq.h>
 #include <linux/gpio.h>
 #include <linux/init.h>
+#include <linux/irqchip/irq-davinci-cp-intc.h>
 #include <linux/mfd/da8xx-cfgchip.h>
 #include <linux/platform_data/clk-da8xx-cfgchip.h>
 #include <linux/platform_data/clk-davinci-pll.h>
@@ -759,6 +760,15 @@ void __init da850_init(void)
 	WARN(!da8xx_syscfg1_base, "Unable to map syscfg1 module");
 }
 
+static const struct davinci_cp_intc_config da850_cp_intc_config = {
+	.reg = {
+		.start		= DA8XX_CP_INTC_BASE,
+		.end		= DA8XX_CP_INTC_BASE + SZ_8K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	.num_irqs		= DA850_N_CP_INTC_IRQ,
+};
+
 void __init da850_init_irq(void)
 {
 	cp_intc_init();

commit f451ca3e4b18bb27b069ec3c8ee3582e975d4ebe
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Feb 14 15:52:18 2019 +0100

    ARM: davinci: cp-intc: add a wrapper around cp_intc_init()
    
    We're going to extend the cp_intc_init() function with a config
    structure so we can drop the intc-related fields from davinci_soc_info.
    
    Once we do it, we won't be able to use this routine directly as the
    init_irq callback. Wrap the calls in additional helpers that don't
    take parameters and can be assigned to init_irq.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Reviewed-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 486d53481636..6df6994c0f26 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -759,6 +759,11 @@ void __init da850_init(void)
 	WARN(!da8xx_syscfg1_base, "Unable to map syscfg1 module");
 }
 
+void __init da850_init_irq(void)
+{
+	cp_intc_init();
+}
+
 void __init da850_init_time(void)
 {
 	void __iomem *pll0;

commit 544ca0b0d8248d8b48c4815e1ad88dd2796ae6ce
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Feb 14 15:52:03 2019 +0100

    ARM: davinci: make irqs.h a local header
    
    The existence of irqs.h in mach-davinci/include/mach only makes sense
    without SPARSE_IRQ as it's then expected to define NR_IRQS and is
    included from asm/irq.h. As we now support SPARSE_IRQ, this header can
    be moved to mach-davinci and used as the source of HW interrupt numbers.
    
    While updating the includes in various files - also rearrange the
    headers by directory (linux/asm/mach).
    
    Reviewed-by: David Lechner <david@lechnology.com>
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index d22b19833326..486d53481636 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -32,10 +32,10 @@
 #include <mach/cpufreq.h>
 #include <mach/cputype.h>
 #include <mach/da8xx.h>
-#include <mach/irqs.h>
 #include <mach/pm.h>
 #include <mach/time.h>
 
+#include "irqs.h"
 #include "mux.h"
 
 #define DA850_PLL1_BASE		0x01e1a000

commit a98ca73ee34825c09e666a97245dedf71ca84fbd
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Feb 14 15:52:01 2019 +0100

    ARM: davinci: wrap HW interrupt numbers with a macro
    
    Once we select SPARSE_IRQ, the interrupt numbers defined in mach/irqs.h
    will only signify the hardware interrupt offsets, not the interrupt
    numbers seen by linux. Introduce a wrapper macro that translates the
    hwirq number to virtual numbers. For now it's just a dummy. Use that
    macro when specifying the interrupts in resources for platform devices.
    
    Reviewed-by: David Lechner <david@lechnology.com>
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index e823b89e2b7a..d22b19833326 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -439,23 +439,23 @@ static struct davinci_id da850_ids[] = {
 static struct davinci_timer_instance da850_timer_instance[4] = {
 	{
 		.base		= DA8XX_TIMER64P0_BASE,
-		.bottom_irq	= IRQ_DA8XX_TINT12_0,
-		.top_irq	= IRQ_DA8XX_TINT34_0,
+		.bottom_irq	= DAVINCI_INTC_IRQ(IRQ_DA8XX_TINT12_0),
+		.top_irq	= DAVINCI_INTC_IRQ(IRQ_DA8XX_TINT34_0),
 	},
 	{
 		.base		= DA8XX_TIMER64P1_BASE,
-		.bottom_irq	= IRQ_DA8XX_TINT12_1,
-		.top_irq	= IRQ_DA8XX_TINT34_1,
+		.bottom_irq	= DAVINCI_INTC_IRQ(IRQ_DA8XX_TINT12_1),
+		.top_irq	= DAVINCI_INTC_IRQ(IRQ_DA8XX_TINT34_1),
 	},
 	{
 		.base		= DA850_TIMER64P2_BASE,
-		.bottom_irq	= IRQ_DA850_TINT12_2,
-		.top_irq	= IRQ_DA850_TINT34_2,
+		.bottom_irq	= DAVINCI_INTC_IRQ(IRQ_DA850_TINT12_2),
+		.top_irq	= DAVINCI_INTC_IRQ(IRQ_DA850_TINT34_2),
 	},
 	{
 		.base		= DA850_TIMER64P3_BASE,
-		.bottom_irq	= IRQ_DA850_TINT12_3,
-		.top_irq	= IRQ_DA850_TINT34_3,
+		.bottom_irq	= DAVINCI_INTC_IRQ(IRQ_DA850_TINT12_3),
+		.top_irq	= DAVINCI_INTC_IRQ(IRQ_DA850_TINT34_3),
 	},
 };
 
@@ -658,8 +658,8 @@ static struct platform_device da850_vpif_dev = {
 
 static struct resource da850_vpif_display_resource[] = {
 	{
-		.start = IRQ_DA850_VPIFINT,
-		.end   = IRQ_DA850_VPIFINT,
+		.start = DAVINCI_INTC_IRQ(IRQ_DA850_VPIFINT),
+		.end   = DAVINCI_INTC_IRQ(IRQ_DA850_VPIFINT),
 		.flags = IORESOURCE_IRQ,
 	},
 };
@@ -677,13 +677,13 @@ static struct platform_device da850_vpif_display_dev = {
 
 static struct resource da850_vpif_capture_resource[] = {
 	{
-		.start = IRQ_DA850_VPIFINT,
-		.end   = IRQ_DA850_VPIFINT,
+		.start = DAVINCI_INTC_IRQ(IRQ_DA850_VPIFINT),
+		.end   = DAVINCI_INTC_IRQ(IRQ_DA850_VPIFINT),
 		.flags = IORESOURCE_IRQ,
 	},
 	{
-		.start = IRQ_DA850_VPIFINT,
-		.end   = IRQ_DA850_VPIFINT,
+		.start = DAVINCI_INTC_IRQ(IRQ_DA850_VPIFINT),
+		.end   = DAVINCI_INTC_IRQ(IRQ_DA850_VPIFINT),
 		.flags = IORESOURCE_IRQ,
 	},
 };

commit e3a8c7631d45c621a78f0cb186ac7a09d9642858
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Feb 14 15:51:59 2019 +0100

    ARM: davinci: remove davinci_intc_type
    
    We now use the generic ARM irq handler on davinci. There are no more
    users that check davinci_intc_type. Remove the variable and all its
    references.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Reviewed-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index e7b78df2bfef..e823b89e2b7a 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -739,7 +739,6 @@ static const struct davinci_soc_info davinci_soc_info_da850 = {
 	.pinmux_pins		= da850_pins,
 	.pinmux_pins_num	= ARRAY_SIZE(da850_pins),
 	.intc_base		= DA8XX_CP_INTC_BASE,
-	.intc_type		= DAVINCI_INTC_TYPE_CP_INTC,
 	.intc_irq_prios		= da850_default_priorities,
 	.intc_irq_num		= DA850_N_CP_INTC_IRQ,
 	.timer_info		= &da850_timer_info,

commit 40b46b3b2f098e3740f65024099a7c55ff4b9866
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Feb 14 18:05:05 2019 +0100

    cpufreq: davinci: move configuration to include/linux/platform_data
    
    The header containing the configuration structure for davinci cpufreq
    driver lives in mach-davinci/include/mach/. This is fine for now but
    if we want to make davinci part of the multi_v5 build, no code external
    to mach-davinci should include machine-specific headers.
    
    Move the configuration structure to include/linux/platform_data.
    
    While we're at it: convert the GPL-2.0 boilerplate to a proper SPDX
    license identifier.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index e7b78df2bfef..a02ff431ba47 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -21,6 +21,7 @@
 #include <linux/mfd/da8xx-cfgchip.h>
 #include <linux/platform_data/clk-da8xx-cfgchip.h>
 #include <linux/platform_data/clk-davinci-pll.h>
+#include <linux/platform_data/davinci-cpufreq.h>
 #include <linux/platform_data/gpio-davinci.h>
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
@@ -29,7 +30,6 @@
 #include <asm/mach/map.h>
 
 #include <mach/common.h>
-#include <mach/cpufreq.h>
 #include <mach/cputype.h>
 #include <mach/da8xx.h>
 #include <mach/irqs.h>

commit 45ed94b9e2d2e310fa7fb884b26080dfd4f0e31d
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Wed Nov 21 10:35:18 2018 +0100

    ARM: davinci: da850: set the GPIO base to 0
    
    Commit 587f7a694f01 ("gpio: davinci: Use dev name for label and
    automatic base selection") broke the network support in legacy boot
    mode for da850-evm since we can no longer request the MDIO clock GPIO.
    
    We now have the option to specify the GPIO base manually for davinci,
    so add the relevant fields to platform data.
    
    Fixes: 587f7a694f01 ("gpio: davinci: Use dev name for label and automatic base selection")
    Cc: stable@vger.kernel.org
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 4528bbf0c861..e7b78df2bfef 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -719,7 +719,9 @@ int __init da850_register_vpif_capture(struct vpif_capture_config
 }
 
 static struct davinci_gpio_platform_data da850_gpio_platform_data = {
-	.ngpio = 144,
+	.no_auto_base	= true,
+	.base		= 0,
+	.ngpio		= 144,
 };
 
 int __init da850_register_gpio(void)

commit 9cc247b82d3c2d30f0a075020d0cdeba6aaafdd8
Author: David Lechner <david@lechnology.com>
Date:   Fri May 18 11:48:19 2018 -0500

    ARM: davinci: da850: Remove legacy clock init
    
    This removes the unused legacy clock init code from
    arch/arm/mach-davinci/da850.c.
    
    Signed-off-by: David Lechner <david@lechnology.com>
    Reviewed-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 9e00beb943c9..4528bbf0c861 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -38,559 +38,12 @@
 
 #include "mux.h"
 
-#ifndef CONFIG_COMMON_CLK
-#include "clock.h"
-#include "psc.h"
-#endif
-
 #define DA850_PLL1_BASE		0x01e1a000
 #define DA850_TIMER64P2_BASE	0x01f0c000
 #define DA850_TIMER64P3_BASE	0x01f0d000
 
 #define DA850_REF_FREQ		24000000
 
-#ifndef CONFIG_COMMON_CLK
-static int da850_set_armrate(struct clk *clk, unsigned long rate);
-static int da850_round_armrate(struct clk *clk, unsigned long rate);
-static int da850_set_pll0rate(struct clk *clk, unsigned long armrate);
-
-static struct pll_data pll0_data = {
-	.num		= 1,
-	.phys_base	= DA8XX_PLL0_BASE,
-	.flags		= PLL_HAS_PREDIV | PLL_HAS_POSTDIV,
-};
-
-static struct clk ref_clk = {
-	.name		= "ref_clk",
-	.rate		= DA850_REF_FREQ,
-	.set_rate	= davinci_simple_set_rate,
-};
-
-static struct clk pll0_clk = {
-	.name		= "pll0",
-	.parent		= &ref_clk,
-	.pll_data	= &pll0_data,
-	.flags		= CLK_PLL,
-	.set_rate	= da850_set_pll0rate,
-};
-
-static struct clk pll0_aux_clk = {
-	.name		= "pll0_aux_clk",
-	.parent		= &pll0_clk,
-	.flags		= CLK_PLL | PRE_PLL,
-};
-
-static struct clk pll0_sysclk1 = {
-	.name		= "pll0_sysclk1",
-	.parent		= &pll0_clk,
-	.flags		= CLK_PLL,
-	.div_reg	= PLLDIV1,
-};
-
-static struct clk pll0_sysclk2 = {
-	.name		= "pll0_sysclk2",
-	.parent		= &pll0_clk,
-	.flags		= CLK_PLL,
-	.div_reg	= PLLDIV2,
-};
-
-static struct clk pll0_sysclk3 = {
-	.name		= "pll0_sysclk3",
-	.parent		= &pll0_clk,
-	.flags		= CLK_PLL,
-	.div_reg	= PLLDIV3,
-	.set_rate	= davinci_set_sysclk_rate,
-	.maxrate	= 100000000,
-};
-
-static struct clk pll0_sysclk4 = {
-	.name		= "pll0_sysclk4",
-	.parent		= &pll0_clk,
-	.flags		= CLK_PLL,
-	.div_reg	= PLLDIV4,
-};
-
-static struct clk pll0_sysclk5 = {
-	.name		= "pll0_sysclk5",
-	.parent		= &pll0_clk,
-	.flags		= CLK_PLL,
-	.div_reg	= PLLDIV5,
-};
-
-static struct clk pll0_sysclk6 = {
-	.name		= "pll0_sysclk6",
-	.parent		= &pll0_clk,
-	.flags		= CLK_PLL,
-	.div_reg	= PLLDIV6,
-};
-
-static struct clk pll0_sysclk7 = {
-	.name		= "pll0_sysclk7",
-	.parent		= &pll0_clk,
-	.flags		= CLK_PLL,
-	.div_reg	= PLLDIV7,
-};
-
-static struct pll_data pll1_data = {
-	.num		= 2,
-	.phys_base	= DA850_PLL1_BASE,
-	.flags		= PLL_HAS_POSTDIV,
-};
-
-static struct clk pll1_clk = {
-	.name		= "pll1",
-	.parent		= &ref_clk,
-	.pll_data	= &pll1_data,
-	.flags		= CLK_PLL,
-};
-
-static struct clk pll1_aux_clk = {
-	.name		= "pll1_aux_clk",
-	.parent		= &pll1_clk,
-	.flags		= CLK_PLL | PRE_PLL,
-};
-
-static struct clk pll1_sysclk2 = {
-	.name		= "pll1_sysclk2",
-	.parent		= &pll1_clk,
-	.flags		= CLK_PLL,
-	.div_reg	= PLLDIV2,
-};
-
-static struct clk pll1_sysclk3 = {
-	.name		= "pll1_sysclk3",
-	.parent		= &pll1_clk,
-	.flags		= CLK_PLL,
-	.div_reg	= PLLDIV3,
-};
-
-static int da850_async3_set_parent(struct clk *clk, struct clk *parent)
-{
-	u32 val;
-
-	val = readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));
-
-	if (parent == &pll0_sysclk2) {
-		val &= ~CFGCHIP3_ASYNC3_CLKSRC;
-	} else if (parent == &pll1_sysclk2) {
-		val |= CFGCHIP3_ASYNC3_CLKSRC;
-	} else {
-		pr_err("Bad parent on async3 clock mux\n");
-		return -EINVAL;
-	}
-
-	writel(val, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));
-
-	return 0;
-}
-
-static struct clk async3_clk = {
-	.name		= "async3",
-	.parent		= &pll1_sysclk2,
-	.set_parent	= da850_async3_set_parent,
-};
-
-static struct clk i2c0_clk = {
-	.name		= "i2c0",
-	.parent		= &pll0_aux_clk,
-};
-
-static struct clk timerp64_0_clk = {
-	.name		= "timer0",
-	.parent		= &pll0_aux_clk,
-};
-
-static struct clk timerp64_1_clk = {
-	.name		= "timer1",
-	.parent		= &pll0_aux_clk,
-};
-
-static struct clk arm_rom_clk = {
-	.name		= "arm_rom",
-	.parent		= &pll0_sysclk2,
-	.lpsc		= DA8XX_LPSC0_ARM_RAM_ROM,
-	.flags		= ALWAYS_ENABLED,
-};
-
-static struct clk tpcc0_clk = {
-	.name		= "tpcc0",
-	.parent		= &pll0_sysclk2,
-	.lpsc		= DA8XX_LPSC0_TPCC,
-	.flags		= ALWAYS_ENABLED | CLK_PSC,
-};
-
-static struct clk tptc0_clk = {
-	.name		= "tptc0",
-	.parent		= &pll0_sysclk2,
-	.lpsc		= DA8XX_LPSC0_TPTC0,
-	.flags		= ALWAYS_ENABLED,
-};
-
-static struct clk tptc1_clk = {
-	.name		= "tptc1",
-	.parent		= &pll0_sysclk2,
-	.lpsc		= DA8XX_LPSC0_TPTC1,
-	.flags		= ALWAYS_ENABLED,
-};
-
-static struct clk tpcc1_clk = {
-	.name		= "tpcc1",
-	.parent		= &pll0_sysclk2,
-	.lpsc		= DA850_LPSC1_TPCC1,
-	.gpsc		= 1,
-	.flags		= CLK_PSC | ALWAYS_ENABLED,
-};
-
-static struct clk tptc2_clk = {
-	.name		= "tptc2",
-	.parent		= &pll0_sysclk2,
-	.lpsc		= DA850_LPSC1_TPTC2,
-	.gpsc		= 1,
-	.flags		= ALWAYS_ENABLED,
-};
-
-static struct clk pruss_clk = {
-	.name		= "pruss",
-	.parent		= &pll0_sysclk2,
-	.lpsc		= DA8XX_LPSC0_PRUSS,
-};
-
-static struct clk uart0_clk = {
-	.name		= "uart0",
-	.parent		= &pll0_sysclk2,
-	.lpsc		= DA8XX_LPSC0_UART0,
-};
-
-static struct clk uart1_clk = {
-	.name		= "uart1",
-	.parent		= &async3_clk,
-	.lpsc		= DA8XX_LPSC1_UART1,
-	.gpsc		= 1,
-};
-
-static struct clk uart2_clk = {
-	.name		= "uart2",
-	.parent		= &async3_clk,
-	.lpsc		= DA8XX_LPSC1_UART2,
-	.gpsc		= 1,
-};
-
-static struct clk aintc_clk = {
-	.name		= "aintc",
-	.parent		= &pll0_sysclk4,
-	.lpsc		= DA8XX_LPSC0_AINTC,
-	.flags		= ALWAYS_ENABLED,
-};
-
-static struct clk gpio_clk = {
-	.name		= "gpio",
-	.parent		= &pll0_sysclk4,
-	.lpsc		= DA8XX_LPSC1_GPIO,
-	.gpsc		= 1,
-};
-
-static struct clk i2c1_clk = {
-	.name		= "i2c1",
-	.parent		= &pll0_sysclk4,
-	.lpsc		= DA8XX_LPSC1_I2C,
-	.gpsc		= 1,
-};
-
-static struct clk emif3_clk = {
-	.name		= "emif3",
-	.parent		= &pll0_sysclk5,
-	.lpsc		= DA8XX_LPSC1_EMIF3C,
-	.gpsc		= 1,
-	.flags		= ALWAYS_ENABLED,
-};
-
-static struct clk arm_clk = {
-	.name		= "arm",
-	.parent		= &pll0_sysclk6,
-	.lpsc		= DA8XX_LPSC0_ARM,
-	.flags		= ALWAYS_ENABLED,
-	.set_rate	= da850_set_armrate,
-	.round_rate	= da850_round_armrate,
-};
-
-static struct clk rmii_clk = {
-	.name		= "rmii",
-	.parent		= &pll0_sysclk7,
-};
-
-static struct clk emac_clk = {
-	.name		= "emac",
-	.parent		= &pll0_sysclk4,
-	.lpsc		= DA8XX_LPSC1_CPGMAC,
-	.gpsc		= 1,
-};
-
-/*
- * In order to avoid adding the emac_clk to the clock lookup table twice (and
- * screwing up the linked list in the process) create a separate clock for
- * mdio inheriting the rate from emac_clk.
- */
-static struct clk mdio_clk = {
-	.name		= "mdio",
-	.parent		= &emac_clk,
-};
-
-static struct clk mcasp_clk = {
-	.name		= "mcasp",
-	.parent		= &async3_clk,
-	.lpsc		= DA8XX_LPSC1_McASP0,
-	.gpsc		= 1,
-};
-
-static struct clk mcbsp0_clk = {
-	.name		= "mcbsp0",
-	.parent		= &async3_clk,
-	.lpsc		= DA850_LPSC1_McBSP0,
-	.gpsc		= 1,
-};
-
-static struct clk mcbsp1_clk = {
-	.name		= "mcbsp1",
-	.parent		= &async3_clk,
-	.lpsc		= DA850_LPSC1_McBSP1,
-	.gpsc		= 1,
-};
-
-static struct clk lcdc_clk = {
-	.name		= "lcdc",
-	.parent		= &pll0_sysclk2,
-	.lpsc		= DA8XX_LPSC1_LCDC,
-	.gpsc		= 1,
-};
-
-static struct clk mmcsd0_clk = {
-	.name		= "mmcsd0",
-	.parent		= &pll0_sysclk2,
-	.lpsc		= DA8XX_LPSC0_MMC_SD,
-};
-
-static struct clk mmcsd1_clk = {
-	.name		= "mmcsd1",
-	.parent		= &pll0_sysclk2,
-	.lpsc		= DA850_LPSC1_MMC_SD1,
-	.gpsc		= 1,
-};
-
-static struct clk aemif_clk = {
-	.name		= "aemif",
-	.parent		= &pll0_sysclk3,
-	.lpsc		= DA8XX_LPSC0_EMIF25,
-	.flags		= ALWAYS_ENABLED,
-};
-
-/*
- * In order to avoid adding the aemif_clk to the clock lookup table twice (and
- * screwing up the linked list in the process) create a separate clock for
- * nand inheriting the rate from aemif_clk.
- */
-static struct clk aemif_nand_clk = {
-	.name		= "nand",
-	.parent		= &aemif_clk,
-};
-
-static struct clk usb11_clk = {
-	.name		= "usb11",
-	.parent		= &pll0_sysclk4,
-	.lpsc		= DA8XX_LPSC1_USB11,
-	.gpsc		= 1,
-};
-
-static struct clk usb20_clk = {
-	.name		= "usb20",
-	.parent		= &pll0_sysclk2,
-	.lpsc		= DA8XX_LPSC1_USB20,
-	.gpsc		= 1,
-};
-
-static struct clk cppi41_clk = {
-	.name		= "cppi41",
-	.parent		= &usb20_clk,
-};
-
-static struct clk spi0_clk = {
-	.name		= "spi0",
-	.parent		= &pll0_sysclk2,
-	.lpsc		= DA8XX_LPSC0_SPI0,
-};
-
-static struct clk spi1_clk = {
-	.name		= "spi1",
-	.parent		= &async3_clk,
-	.lpsc		= DA8XX_LPSC1_SPI1,
-	.gpsc		= 1,
-};
-
-static struct clk vpif_clk = {
-	.name		= "vpif",
-	.parent		= &pll0_sysclk2,
-	.lpsc		= DA850_LPSC1_VPIF,
-	.gpsc		= 1,
-};
-
-static struct clk sata_clk = {
-	.name		= "sata",
-	.parent		= &pll0_sysclk2,
-	.lpsc		= DA850_LPSC1_SATA,
-	.gpsc		= 1,
-	.flags		= PSC_FORCE,
-};
-
-static struct clk dsp_clk = {
-	.name		= "dsp",
-	.parent		= &pll0_sysclk1,
-	.domain		= DAVINCI_GPSC_DSPDOMAIN,
-	.lpsc		= DA8XX_LPSC0_GEM,
-	.flags		= PSC_LRST | PSC_FORCE,
-};
-
-static struct clk ehrpwm_clk = {
-	.name		= "ehrpwm",
-	.parent		= &async3_clk,
-	.lpsc		= DA8XX_LPSC1_PWM,
-	.gpsc		= 1,
-};
-
-static struct clk ehrpwm0_clk = {
-	.name		= "ehrpwm0",
-	.parent		= &ehrpwm_clk,
-};
-
-static struct clk ehrpwm1_clk = {
-	.name		= "ehrpwm1",
-	.parent		= &ehrpwm_clk,
-};
-
-#define DA8XX_EHRPWM_TBCLKSYNC	BIT(12)
-
-static void ehrpwm_tblck_enable(struct clk *clk)
-{
-	u32 val;
-
-	val = readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP1_REG));
-	val |= DA8XX_EHRPWM_TBCLKSYNC;
-	writel(val, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP1_REG));
-}
-
-static void ehrpwm_tblck_disable(struct clk *clk)
-{
-	u32 val;
-
-	val = readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP1_REG));
-	val &= ~DA8XX_EHRPWM_TBCLKSYNC;
-	writel(val, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP1_REG));
-}
-
-static struct clk ehrpwm_tbclk = {
-	.name		= "ehrpwm_tbclk",
-	.parent		= &ehrpwm_clk,
-	.clk_enable	= ehrpwm_tblck_enable,
-	.clk_disable	= ehrpwm_tblck_disable,
-};
-
-static struct clk ehrpwm0_tbclk = {
-	.name		= "ehrpwm0_tbclk",
-	.parent		= &ehrpwm_tbclk,
-};
-
-static struct clk ehrpwm1_tbclk = {
-	.name		= "ehrpwm1_tbclk",
-	.parent		= &ehrpwm_tbclk,
-};
-
-static struct clk ecap_clk = {
-	.name		= "ecap",
-	.parent		= &async3_clk,
-	.lpsc		= DA8XX_LPSC1_ECAP,
-	.gpsc		= 1,
-};
-
-static struct clk ecap0_clk = {
-	.name		= "ecap0_clk",
-	.parent		= &ecap_clk,
-};
-
-static struct clk ecap1_clk = {
-	.name		= "ecap1_clk",
-	.parent		= &ecap_clk,
-};
-
-static struct clk ecap2_clk = {
-	.name		= "ecap2_clk",
-	.parent		= &ecap_clk,
-};
-
-static struct clk_lookup da850_clks[] = {
-	CLK(NULL,		"ref",		&ref_clk),
-	CLK(NULL,		"pll0",		&pll0_clk),
-	CLK(NULL,		"pll0_aux",	&pll0_aux_clk),
-	CLK(NULL,		"pll0_sysclk1",	&pll0_sysclk1),
-	CLK(NULL,		"pll0_sysclk2",	&pll0_sysclk2),
-	CLK(NULL,		"pll0_sysclk3",	&pll0_sysclk3),
-	CLK(NULL,		"pll0_sysclk4",	&pll0_sysclk4),
-	CLK(NULL,		"pll0_sysclk5",	&pll0_sysclk5),
-	CLK(NULL,		"pll0_sysclk6",	&pll0_sysclk6),
-	CLK(NULL,		"pll0_sysclk7",	&pll0_sysclk7),
-	CLK(NULL,		"pll1",		&pll1_clk),
-	CLK(NULL,		"pll1_aux",	&pll1_aux_clk),
-	CLK(NULL,		"pll1_sysclk2",	&pll1_sysclk2),
-	CLK(NULL,		"pll1_sysclk3",	&pll1_sysclk3),
-	CLK(NULL,		"async3",	&async3_clk),
-	CLK("i2c_davinci.1",	NULL,		&i2c0_clk),
-	CLK(NULL,		"timer0",	&timerp64_0_clk),
-	CLK("davinci-wdt",	NULL,		&timerp64_1_clk),
-	CLK(NULL,		"arm_rom",	&arm_rom_clk),
-	CLK(NULL,		"tpcc0",	&tpcc0_clk),
-	CLK(NULL,		"tptc0",	&tptc0_clk),
-	CLK(NULL,		"tptc1",	&tptc1_clk),
-	CLK(NULL,		"tpcc1",	&tpcc1_clk),
-	CLK(NULL,		"tptc2",	&tptc2_clk),
-	CLK("pruss_uio",	"pruss",	&pruss_clk),
-	CLK("serial8250.0",	NULL,		&uart0_clk),
-	CLK("serial8250.1",	NULL,		&uart1_clk),
-	CLK("serial8250.2",	NULL,		&uart2_clk),
-	CLK(NULL,		"aintc",	&aintc_clk),
-	CLK(NULL,		"gpio",		&gpio_clk),
-	CLK("i2c_davinci.2",	NULL,		&i2c1_clk),
-	CLK(NULL,		"emif3",	&emif3_clk),
-	CLK(NULL,		"arm",		&arm_clk),
-	CLK(NULL,		"rmii",		&rmii_clk),
-	CLK("davinci_emac.1",	NULL,		&emac_clk),
-	CLK("davinci_mdio.0",	"fck",		&mdio_clk),
-	CLK("davinci-mcasp.0",	NULL,		&mcasp_clk),
-	CLK("davinci-mcbsp.0",	NULL,		&mcbsp0_clk),
-	CLK("davinci-mcbsp.1",	NULL,		&mcbsp1_clk),
-	CLK("da8xx_lcdc.0",	"fck",		&lcdc_clk),
-	CLK("da830-mmc.0",	NULL,		&mmcsd0_clk),
-	CLK("da830-mmc.1",	NULL,		&mmcsd1_clk),
-	CLK("ti-aemif",		NULL,		&aemif_clk),
-	CLK("davinci-nand.0",	"aemif",	&aemif_nand_clk),
-	CLK("ohci-da8xx",	NULL,		&usb11_clk),
-	CLK("musb-da8xx",	NULL,		&usb20_clk),
-	CLK("cppi41-dmaengine",	NULL,		&cppi41_clk),
-	CLK("spi_davinci.0",	NULL,		&spi0_clk),
-	CLK("spi_davinci.1",	NULL,		&spi1_clk),
-	CLK("vpif",		NULL,		&vpif_clk),
-	CLK("ahci_da850",	"fck",		&sata_clk),
-	CLK("davinci-rproc.0",	NULL,		&dsp_clk),
-	CLK(NULL,		NULL,		&ehrpwm_clk),
-	CLK("ehrpwm.0",		"fck",		&ehrpwm0_clk),
-	CLK("ehrpwm.1",		"fck",		&ehrpwm1_clk),
-	CLK(NULL,		NULL,		&ehrpwm_tbclk),
-	CLK("ehrpwm.0",		"tbclk",	&ehrpwm0_tbclk),
-	CLK("ehrpwm.1",		"tbclk",	&ehrpwm1_tbclk),
-	CLK(NULL,		NULL,		&ecap_clk),
-	CLK("ecap.0",		"fck",		&ecap0_clk),
-	CLK("ecap.1",		"fck",		&ecap1_clk),
-	CLK("ecap.2",		"fck",		&ecap2_clk),
-	CLK(NULL,		NULL,		NULL),
-};
-#endif
-
 /*
  * Device specific mux setup
  *
@@ -965,8 +418,6 @@ static struct map_desc da850_io_desc[] = {
 	},
 };
 
-static u32 da850_psc_bases[] = { DA8XX_PSC0_BASE, DA8XX_PSC1_BASE };
-
 /* Contents of JTAG ID register used to identify exact cpu type */
 static struct davinci_id da850_ids[] = {
 	{
@@ -1176,93 +627,11 @@ int da850_register_cpufreq(char *async_clk)
 
 	return platform_device_register(&da850_cpufreq_device);
 }
-
-#ifndef CONFIG_COMMON_CLK
-static int da850_round_armrate(struct clk *clk, unsigned long rate)
-{
-	int ret = 0, diff;
-	unsigned int best = (unsigned int) -1;
-	struct cpufreq_frequency_table *table = cpufreq_info.freq_table;
-	struct cpufreq_frequency_table *pos;
-
-	rate /= 1000; /* convert to kHz */
-
-	cpufreq_for_each_entry(pos, table) {
-		diff = pos->frequency - rate;
-		if (diff < 0)
-			diff = -diff;
-
-		if (diff < best) {
-			best = diff;
-			ret = pos->frequency;
-		}
-	}
-
-	return ret * 1000;
-}
-
-static int da850_set_armrate(struct clk *clk, unsigned long index)
-{
-	struct clk *pllclk = &pll0_clk;
-
-	return clk_set_rate(pllclk, index);
-}
-
-static int da850_set_pll0rate(struct clk *clk, unsigned long rate)
-{
-	struct pll_data *pll = clk->pll_data;
-	struct cpufreq_frequency_table *freq;
-	unsigned int prediv, mult, postdiv;
-	struct da850_opp *opp = NULL;
-	int ret;
-
-	rate /= 1000;
-
-	for (freq = da850_freq_table;
-	     freq->frequency != CPUFREQ_TABLE_END; freq++) {
-		/* rate is in Hz, freq->frequency is in KHz */
-		if (freq->frequency == rate) {
-			opp = (struct da850_opp *)freq->driver_data;
-			break;
-		}
-	}
-
-	if (!opp)
-		return -EINVAL;
-
-	prediv = opp->prediv;
-	mult = opp->mult;
-	postdiv = opp->postdiv;
-
-	ret = davinci_set_pllrate(pll, prediv, mult, postdiv);
-	if (WARN_ON(ret))
-		return ret;
-
-	return 0;
-}
-#endif /* CONFIG_COMMON_CLK */
 #else
 int __init da850_register_cpufreq(char *async_clk)
 {
 	return 0;
 }
-
-#ifndef CONFIG_COMMON_CLK
-static int da850_set_armrate(struct clk *clk, unsigned long rate)
-{
-	return -EINVAL;
-}
-
-static int da850_set_pll0rate(struct clk *clk, unsigned long armrate)
-{
-	return -EINVAL;
-}
-
-static int da850_round_armrate(struct clk *clk, unsigned long rate)
-{
-	return clk->rate;
-}
-#endif /* CONFIG_COMMON_CLK */
 #endif
 
 /* VPIF resource, platform data */
@@ -1364,8 +733,6 @@ static const struct davinci_soc_info davinci_soc_info_da850 = {
 	.jtag_id_reg		= DA8XX_SYSCFG0_BASE + DA8XX_JTAG_ID_REG,
 	.ids			= da850_ids,
 	.ids_num		= ARRAY_SIZE(da850_ids),
-	.psc_bases		= da850_psc_bases,
-	.psc_bases_num		= ARRAY_SIZE(da850_psc_bases),
 	.pinmux_base		= DA8XX_SYSCFG0_BASE + 0x120,
 	.pinmux_pins		= da850_pins,
 	.pinmux_pins_num	= ARRAY_SIZE(da850_pins),
@@ -1381,8 +748,6 @@ static const struct davinci_soc_info davinci_soc_info_da850 = {
 
 void __init da850_init(void)
 {
-	unsigned int v;
-
 	davinci_common_init(&davinci_soc_info_da850);
 
 	da8xx_syscfg0_base = ioremap(DA8XX_SYSCFG0_BASE, SZ_4K);
@@ -1390,23 +755,11 @@ void __init da850_init(void)
 		return;
 
 	da8xx_syscfg1_base = ioremap(DA8XX_SYSCFG1_BASE, SZ_4K);
-	if (WARN(!da8xx_syscfg1_base, "Unable to map syscfg1 module"))
-		return;
-
-	/* Unlock writing to PLL0 registers */
-	v = __raw_readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP0_REG));
-	v &= ~CFGCHIP0_PLL_MASTER_LOCK;
-	__raw_writel(v, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP0_REG));
-
-	/* Unlock writing to PLL1 registers */
-	v = __raw_readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));
-	v &= ~CFGCHIP3_PLL1_MASTER_LOCK;
-	__raw_writel(v, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));
+	WARN(!da8xx_syscfg1_base, "Unable to map syscfg1 module");
 }
 
 void __init da850_init_time(void)
 {
-#ifdef CONFIG_COMMON_CLK
 	void __iomem *pll0;
 	struct regmap *cfgchip;
 	struct clk *clk;
@@ -1421,10 +774,6 @@ void __init da850_init_time(void)
 	clk = clk_get(NULL, "timer0");
 
 	davinci_timer_init(clk);
-#else
-	davinci_clk_init(da850_clks);
-	davinci_timer_init(&timerp64_0_clk);
-#endif
 }
 
 static struct resource da850_pll1_resources[] = {

commit 482db8893ee4fa777e2256dd66ba207e719777dc
Author: David Lechner <david@lechnology.com>
Date:   Fri May 18 11:48:08 2018 -0500

    ARM: davinci: da850: add new clock init using common clock framework
    
    This adds the new board-specific clock init in mach-davinci/da850.c
    using the new common clock framework drivers.
    
    The #ifdefs are needed to prevent compile errors until the entire
    ARCH_DAVINCI is converted.
    
    Also clean up the #includes since we are adding some here.
    
    Some CFGCHIP macros were removed because we are now including
    linux/mfd/da8xx-cfgchip.h which defines the same values.
    
    Reviewed-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 1dbf01c4124b..9e00beb943c9 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -11,39 +11,45 @@
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
  */
+
+#include <linux/clk-provider.h>
+#include <linux/clk/davinci.h>
 #include <linux/clkdev.h>
+#include <linux/cpufreq.h>
 #include <linux/gpio.h>
 #include <linux/init.h>
-#include <linux/clk.h>
+#include <linux/mfd/da8xx-cfgchip.h>
+#include <linux/platform_data/clk-da8xx-cfgchip.h>
+#include <linux/platform_data/clk-davinci-pll.h>
+#include <linux/platform_data/gpio-davinci.h>
 #include <linux/platform_device.h>
-#include <linux/cpufreq.h>
+#include <linux/regmap.h>
 #include <linux/regulator/consumer.h>
-#include <linux/platform_data/gpio-davinci.h>
 
 #include <asm/mach/map.h>
 
-#include "psc.h"
-#include <mach/irqs.h>
-#include <mach/cputype.h>
 #include <mach/common.h>
-#include <mach/time.h>
-#include <mach/da8xx.h>
 #include <mach/cpufreq.h>
+#include <mach/cputype.h>
+#include <mach/da8xx.h>
+#include <mach/irqs.h>
 #include <mach/pm.h>
+#include <mach/time.h>
 
-#include "clock.h"
 #include "mux.h"
 
+#ifndef CONFIG_COMMON_CLK
+#include "clock.h"
+#include "psc.h"
+#endif
+
 #define DA850_PLL1_BASE		0x01e1a000
 #define DA850_TIMER64P2_BASE	0x01f0c000
 #define DA850_TIMER64P3_BASE	0x01f0d000
 
 #define DA850_REF_FREQ		24000000
 
-#define CFGCHIP3_ASYNC3_CLKSRC	BIT(4)
-#define CFGCHIP3_PLL1_MASTER_LOCK	BIT(5)
-#define CFGCHIP0_PLL_MASTER_LOCK	BIT(4)
-
+#ifndef CONFIG_COMMON_CLK
 static int da850_set_armrate(struct clk *clk, unsigned long rate);
 static int da850_round_armrate(struct clk *clk, unsigned long rate);
 static int da850_set_pll0rate(struct clk *clk, unsigned long armrate);
@@ -583,6 +589,7 @@ static struct clk_lookup da850_clks[] = {
 	CLK("ecap.2",		"fck",		&ecap2_clk),
 	CLK(NULL,		NULL,		NULL),
 };
+#endif
 
 /*
  * Device specific mux setup
@@ -1170,6 +1177,7 @@ int da850_register_cpufreq(char *async_clk)
 	return platform_device_register(&da850_cpufreq_device);
 }
 
+#ifndef CONFIG_COMMON_CLK
 static int da850_round_armrate(struct clk *clk, unsigned long rate)
 {
 	int ret = 0, diff;
@@ -1232,12 +1240,14 @@ static int da850_set_pll0rate(struct clk *clk, unsigned long rate)
 
 	return 0;
 }
+#endif /* CONFIG_COMMON_CLK */
 #else
 int __init da850_register_cpufreq(char *async_clk)
 {
 	return 0;
 }
 
+#ifndef CONFIG_COMMON_CLK
 static int da850_set_armrate(struct clk *clk, unsigned long rate)
 {
 	return -EINVAL;
@@ -1252,6 +1262,7 @@ static int da850_round_armrate(struct clk *clk, unsigned long rate)
 {
 	return clk->rate;
 }
+#endif /* CONFIG_COMMON_CLK */
 #endif
 
 /* VPIF resource, platform data */
@@ -1395,6 +1406,124 @@ void __init da850_init(void)
 
 void __init da850_init_time(void)
 {
+#ifdef CONFIG_COMMON_CLK
+	void __iomem *pll0;
+	struct regmap *cfgchip;
+	struct clk *clk;
+
+	clk_register_fixed_rate(NULL, "ref_clk", NULL, 0, DA850_REF_FREQ);
+
+	pll0 = ioremap(DA8XX_PLL0_BASE, SZ_4K);
+	cfgchip = da8xx_get_cfgchip();
+
+	da850_pll0_init(NULL, pll0, cfgchip);
+
+	clk = clk_get(NULL, "timer0");
+
+	davinci_timer_init(clk);
+#else
 	davinci_clk_init(da850_clks);
 	davinci_timer_init(&timerp64_0_clk);
+#endif
+}
+
+static struct resource da850_pll1_resources[] = {
+	{
+		.start	= DA850_PLL1_BASE,
+		.end	= DA850_PLL1_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct davinci_pll_platform_data da850_pll1_pdata;
+
+static struct platform_device da850_pll1_device = {
+	.name		= "da850-pll1",
+	.id		= -1,
+	.resource	= da850_pll1_resources,
+	.num_resources	= ARRAY_SIZE(da850_pll1_resources),
+	.dev		= {
+		.platform_data	= &da850_pll1_pdata,
+	},
+};
+
+static struct resource da850_psc0_resources[] = {
+	{
+		.start	= DA8XX_PSC0_BASE,
+		.end	= DA8XX_PSC0_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device da850_psc0_device = {
+	.name		= "da850-psc0",
+	.id		= -1,
+	.resource	= da850_psc0_resources,
+	.num_resources	= ARRAY_SIZE(da850_psc0_resources),
+};
+
+static struct resource da850_psc1_resources[] = {
+	{
+		.start	= DA8XX_PSC1_BASE,
+		.end	= DA8XX_PSC1_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device da850_psc1_device = {
+	.name		= "da850-psc1",
+	.id		= -1,
+	.resource	= da850_psc1_resources,
+	.num_resources	= ARRAY_SIZE(da850_psc1_resources),
+};
+
+static struct da8xx_cfgchip_clk_platform_data da850_async1_pdata;
+
+static struct platform_device da850_async1_clksrc_device = {
+	.name		= "da850-async1-clksrc",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &da850_async1_pdata,
+	},
+};
+
+static struct da8xx_cfgchip_clk_platform_data da850_async3_pdata;
+
+static struct platform_device da850_async3_clksrc_device = {
+	.name		= "da850-async3-clksrc",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &da850_async3_pdata,
+	},
+};
+
+static struct da8xx_cfgchip_clk_platform_data da850_tbclksync_pdata;
+
+static struct platform_device da850_tbclksync_device = {
+	.name		= "da830-tbclksync",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &da850_tbclksync_pdata,
+	},
+};
+
+void __init da850_register_clocks(void)
+{
+	/* PLL0 is registered in da850_init_time() */
+
+	da850_pll1_pdata.cfgchip = da8xx_get_cfgchip();
+	platform_device_register(&da850_pll1_device);
+
+	da850_async1_pdata.cfgchip = da8xx_get_cfgchip();
+	platform_device_register(&da850_async1_clksrc_device);
+
+	da850_async3_pdata.cfgchip = da8xx_get_cfgchip();
+	platform_device_register(&da850_async3_clksrc_device);
+
+	platform_device_register(&da850_psc0_device);
+
+	platform_device_register(&da850_psc1_device);
+
+	da850_tbclksync_pdata.cfgchip = da8xx_get_cfgchip();
+	platform_device_register(&da850_tbclksync_device);
 }

commit a7da5277cdc6690823ad226335feefc11391cf67
Author: David Lechner <david@lechnology.com>
Date:   Fri May 18 11:48:06 2018 -0500

    ARM: davinci: pass clock as parameter to davinci_timer_init()
    
    This changes davinci_timer_init() so that we pass the clock as a
    parameter instead of using clk_get(). This is done in preparation
    for converting to the common clock framework.
    
    It removes the requirement that we have to have a clock with con_id
    of "timer0", which will be good for DT bindings since clock-names =
    "timer0" doesn't really make sense.
    
    Also, drop use of extern in header file since we are touching the
    definition.
    
    Reviewed-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 34117e614e08..1dbf01c4124b 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1396,5 +1396,5 @@ void __init da850_init(void)
 void __init da850_init_time(void)
 {
 	davinci_clk_init(da850_clks);
-	davinci_timer_init();
+	davinci_timer_init(&timerp64_0_clk);
 }

commit 96c081735d5197d9d4fa0b6ce84cffa3bb197474
Author: David Lechner <david@lechnology.com>
Date:   Fri Jan 19 21:20:22 2018 -0600

    ARM: davinci: move davinci_clk_init() to init_time
    
    This moves the call of davinci_clk_init() from map_io to init_time for all
    boards.
    
    This is the proper place to init clocks. This is also done in preparation
    for moving to the common clock framework.
    
    dm646x is a special case because we need to handle different ref_clk rates
    depending on which board is being used. The clock init in this case is
    modified to set the rate before registering the clocks instead of using
    davinci_set_refclk_rate() to recalculate the entire clock tree after all
    of the clocks are registered.
    
    Also, the cpu_clks field is removed from struct davinci_soc_info since it
    is no longer needed.
    
    Signed-off-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index aa37cbdf7d4d..34117e614e08 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1353,7 +1353,6 @@ static const struct davinci_soc_info davinci_soc_info_da850 = {
 	.jtag_id_reg		= DA8XX_SYSCFG0_BASE + DA8XX_JTAG_ID_REG,
 	.ids			= da850_ids,
 	.ids_num		= ARRAY_SIZE(da850_ids),
-	.cpu_clks		= da850_clks,
 	.psc_bases		= da850_psc_bases,
 	.psc_bases_num		= ARRAY_SIZE(da850_psc_bases),
 	.pinmux_base		= DA8XX_SYSCFG0_BASE + 0x120,
@@ -1392,6 +1391,10 @@ void __init da850_init(void)
 	v = __raw_readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));
 	v &= ~CFGCHIP3_PLL1_MASTER_LOCK;
 	__raw_writel(v, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));
+}
 
-	davinci_clk_init(davinci_soc_info_da850.cpu_clks);
+void __init da850_init_time(void)
+{
+	davinci_clk_init(da850_clks);
+	davinci_timer_init();
 }

commit adbc128fa8b4e9ecfdd11d5dd0a7d9845c6ea510
Merge: 537433b6241e 0ca14cdea789
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 1 16:17:40 2018 -0800

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform updates from Arnd Bergmann:
     "These are mostly minor bugfixes, cleanup and many defconfig updates to
      support added drivers. In particular OMAP and PXA keep cleaning up the
      legacy code base, as usual.
    
      Nvidia adds some more SoC support code for Tegra 186.
    
      For the first time on years, we are actually adding a non-DT platform
      for the EP93xx based Liebherr controller BK3.1. It's a minor variation
      of the EP93xx reference design and in active use, while EP93xx
      apparently doesn't have enough new development to have any device tree
      support"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (73 commits)
      ARM: omap: hwmod: fix section mismatch warnings
      ARM: pxa/tosa-bt: add MODULE_LICENSE tag
      arm64: defconfig: enable CONFIG_ACPI_APEI_EINJ
      arm64: defconfig: enable EDAC GHES option
      arm64: defconfig: enable CONFIG_ACPI_APEI_MEMORY_FAILURE
      ARM: imx_v6_v7_defconfig: enable CONFIG_CPU_FREQ_STAT
      Wind down ARM/TANGO port
      ARM: davinci: constify gpio_led
      ARM: davinci: drop unneeded newline
      soc: Add SoC driver for Gemini
      ARM: SAMSUNG: Add SPDX license identifiers
      ARM: S5PV210: Add SPDX license identifiers
      ARM: S3C64XX: Add SPDX license identifiers
      ARM: S3C24XX: Add SPDX license identifiers
      ARM: EXYNOS: Add SPDX license identifiers
      ARM: imx: remove unused imx3 pm definitions
      ARM: imx: don't abort MMDC probe if power saving status doesn't match
      ARM: imx_v6_v7_defconfig: enable RTC_DRV_MXC_V2
      ARM: imx_v6_v7_defconfig: Add missing config for DART-MX6 SoM
      ARM: davinci: Use PTR_ERR_OR_ZERO()
      ...

commit 102402a73bbeb8b2e0785a3653f37ce480a18614
Author: David Lechner <david@lechnology.com>
Date:   Sat Jan 6 21:19:52 2018 -0600

    ARM: da8xx: remove con_id from USB clocks
    
    There is only one clock each for "musb-da8xx" and "ohci-da8xx", so we
    do not the the con_id. Removing them  will also prevent needing an
    unnecessary device tree property when device tree bindings are added
    for clocks.
    
    Signed-off-by: David Lechner <david@lechnology.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 07d6f0eb8c82..d37b5463cd8f 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -563,8 +563,8 @@ static struct clk_lookup da850_clks[] = {
 	CLK("da830-mmc.1",	NULL,		&mmcsd1_clk),
 	CLK("ti-aemif",		NULL,		&aemif_clk),
 	CLK("davinci-nand.0",	"aemif",	&aemif_nand_clk),
-	CLK("ohci-da8xx",	"usb11",	&usb11_clk),
-	CLK("musb-da8xx",	"usb20",	&usb20_clk),
+	CLK("ohci-da8xx",	NULL,		&usb11_clk),
+	CLK("musb-da8xx",	NULL,		&usb20_clk),
 	CLK("cppi41-dmaengine",	NULL,		&cppi41_clk),
 	CLK("spi_davinci.0",	NULL,		&spi0_clk),
 	CLK("spi_davinci.1",	NULL,		&spi1_clk),

commit ab41910dfd5ab8e90b6a93d8c17f39ce2dbb069d
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Mon Oct 16 12:08:24 2017 +0200

    ARM: davinci: make davinci_soc_info structures const
    
    Make davinci_soc_info structures const as they are either passed to the
    function davinci_common_init having the argument as const or their field
    cpu_clks of type struct clk_lookup * is passed to the function
    davinci_clk_init.
    
    So, the fields are never modified and the structures can be const.
    
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    [nsekhar@ti.com: minor commit message adjustment]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 07d6f0eb8c82..04a58a3f38ad 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1347,7 +1347,7 @@ int __init da850_register_gpio(void)
 	return da8xx_register_gpio(&da850_gpio_platform_data);
 }
 
-static struct davinci_soc_info davinci_soc_info_da850 = {
+static const struct davinci_soc_info davinci_soc_info_da850 = {
 	.io_desc		= da850_io_desc,
 	.io_desc_num		= ARRAY_SIZE(da850_io_desc),
 	.jtag_id_reg		= DA8XX_SYSCFG0_BASE + DA8XX_JTAG_ID_REG,

commit 398dbc776a8f7dfdee7c38ad003e66abd31b3b0a
Author: Alexandre Bailon <abailon@baylibre.com>
Date:   Wed Apr 5 19:17:50 2017 +0200

    ARM: davinci: Add clock for CPPI 4.1 DMA engine
    
    The CPPI 4.1 DMA in USB subsystem shares its clock with the
    USB OTG, and most of the time, the clock will be enabled by
    USB.  But during the init of the DMA, USB is not enabled
    (waiting for DMA), and then we must enable the DMA clock
    before doing anything.
    
    Add clock for the CPPI 4.1 DMA engine.
    
    Signed-off-by: Alexandre Bailon <abailon@baylibre.com>
    [nsekhar@ti.com: minor commit message tweaks]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index ccad2f99dfc9..07d6f0eb8c82 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -401,6 +401,11 @@ static struct clk usb20_clk = {
 	.gpsc		= 1,
 };
 
+static struct clk cppi41_clk = {
+	.name		= "cppi41",
+	.parent		= &usb20_clk,
+};
+
 static struct clk spi0_clk = {
 	.name		= "spi0",
 	.parent		= &pll0_sysclk2,
@@ -560,6 +565,7 @@ static struct clk_lookup da850_clks[] = {
 	CLK("davinci-nand.0",	"aemif",	&aemif_nand_clk),
 	CLK("ohci-da8xx",	"usb11",	&usb11_clk),
 	CLK("musb-da8xx",	"usb20",	&usb20_clk),
+	CLK("cppi41-dmaengine",	NULL,		&cppi41_clk),
 	CLK("spi_davinci.0",	NULL,		&spi0_clk),
 	CLK("spi_davinci.1",	NULL,		&spi1_clk),
 	CLK("vpif",		NULL,		&vpif_clk),

commit 6ae52c65e01991426e87bb0fb8a2ac9e032db7b1
Merge: af8999f67242 af1d09eefa72
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 23 15:33:54 2017 -0800

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform updates from Arnd Bergmann:
     "In the SoC branch we normally collect classic arch/arm/mach-*
      contents, i.e. C code changes for SoC platforms. This release cycle
      the diffstat is quite nice, in that we're removing 3x the amount of
      code that's being added.
    
      The main reason for this is that there's a removal of camera drivers
      for Freescale i.MX chips (driver was removed so the device
      registration isn't needed any more). There's also removal of display
      initialization code for OMAP that is no longer needed.
    
      The rest are mostly minor tweaks and cleanups; constification on
      Samsung platforms, cleanup of ux500 platform data, purge of other
      unused platform data/device seutp on i.MX and other good stuff.
    
      New SoC support this cycle is for two Allwinner platforms, H2+ and
      V3s"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (55 commits)
      ARM: ux500: remove deleted file from Makefile
      ARM: ep93xx: Disable TS-72xx watchdog before uncompressing
      ARM: ux500: cut some platform data
      MAINTAINERS: Update for the current location of the bcm2835 tree.
      ARM: davinci: remove BUG_ON() from da850_register_sata()
      ARM: davinci: da850: model the SATA refclk
      ARM: davinci: da850: add con_id for the SATA clock
      ARM: davinci: da8xx-dt: add OF_DEV_AUXDATA entry for SATA
      arm: mvebu: support for SMP on 98DX3336 SoC
      dt-bindings: video: exynos7-decon: Remove obsolete samsung,power-domain property
      soc: dove: constify reset_control_ops structures
      ARM: mv78xx0: fix possible PCI buffer overflow
      MAINTAINERS: transfer maintainership for the EZX platform
      ARM: shmobile: rcar-gen2: Add more register documentation
      ARM: tegra: paz00: Fix __initdata placement
      ARM: OMAP: clock: Remove unused mpurate cmdline option
      ARM: davinci: add skeleton for pdata-quirks
      arm: sunxi: add support for V3s SoC
      ARM: OMAP2+: omap_hwmod: Add support for earlycon
      arm: hisi: drop extern hip01_cpu_die
      ...

commit af8999f672421776417977101c3e1f334414c065
Merge: 60e8d3e11645 92f3e6ebf6e4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 23 15:28:04 2017 -0800

    Merge tag 'armsoc-fixes-nc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC non-urgent fixes from Arnd Bergmann:
     "We sometimes collect non-critical fixes that come in during the later
      part of the merge window in a branch for the next release instead, and
      this is that contents for v4.11.
    
      Most of these are OMAP fixes, dealing with OMAP36/37 detection, quirks
      and setup. There's also some fixes for Davinci and a Kconfig fix for
      SCPI to only enable on ARM{,64}"
    
    * tag 'armsoc-fixes-nc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      firmware: arm_scpi: Add hardware dependencies
      ARM: OMAP3: Fix SoC detection of OMAP36/37 Family
      ARM: OMAP5: Add HWMOD_SWSUP_SIDLE_ACT flag for UART
      ARM: dts: Fix compatible for ti81xx uarts for 8250
      ARM: dts: Fix am335x and dm814x scm syscon to probe children
      ARM: OMAP2+: Fix init for multiple quirks for the same SoC
      ARM: dts: Fix omap3 off mode pull defines
      bus: da850-mstpri: fix my e-mail address
      ARM: davinci: da850: fix da850_set_pll0rate()
      ARM: davinci: da850: coding style fix

commit af1d09eefa72089300ddde13bbaf9af1a82c6be1
Merge: c6057e101a2d a3035886852c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Feb 16 17:15:39 2017 +0100

    Merge tag 'davinci-for-v4.11/soc-2' of git://git.kernel.org/pub/scm/linux/kernel/git/nsekhar/linux-davinci into next/soc
    
    Pull "SoC updates needed for SATA support on DA850" from Sekhar Nori:
    
    This includes a merge of non-critical-fixes
    branch already queued for v4.11 because
    SATA clock addition conflicts with the fix-up
    done earlier.
    
    * tag 'davinci-for-v4.11/soc-2' of git://git.kernel.org/pub/scm/linux/kernel/git/nsekhar/linux-davinci:
      ARM: davinci: remove BUG_ON() from da850_register_sata()
      ARM: davinci: da850: model the SATA refclk
      ARM: davinci: da850: add con_id for the SATA clock
      ARM: davinci: da8xx-dt: add OF_DEV_AUXDATA entry for SATA
      ARM: davinci: add skeleton for pdata-quirks
      bus: da850-mstpri: fix my e-mail address
      ARM: davinci: da850: fix da850_set_pll0rate()
      ARM: davinci: da850: coding style fix

commit 8ba0f6caa41c0786b964dcf75ab74bb05c726ec3
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Mon Jan 30 11:02:02 2017 +0100

    ARM: davinci: da850: add con_id for the SATA clock
    
    The ahci-da850 SATA driver is now capable of retrieving clocks by
    con_id. Add the connection id for the sysclk2-derived SATA clock.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 07d36fc1e33c..8ab3c099e9aa 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -543,7 +543,7 @@ static struct clk_lookup da850_clks[] = {
 	CLK("spi_davinci.0",	NULL,		&spi0_clk),
 	CLK("spi_davinci.1",	NULL,		&spi1_clk),
 	CLK("vpif",		NULL,		&vpif_clk),
-	CLK("ahci_da850",	NULL,		&sata_clk),
+	CLK("ahci_da850",	"fck",		&sata_clk),
 	CLK("davinci-rproc.0",	NULL,		&dsp_clk),
 	CLK(NULL,		NULL,		&ehrpwm_clk),
 	CLK("ehrpwm.0",		"fck",		&ehrpwm0_clk),

commit d8e22fb4ccace71731193d3cf85d08e238b6e4f9
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Fri Jan 13 11:00:26 2017 +0100

    ARM: da850: add the nand dev_id to the clock lookup table
    
    The aemif driver can now access struct of_dev_auxdata (using platform
    data).
    
    Add the device id to the clock lookup table for the nand clock and
    create a separate lookup table for aemif subnodes.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 1d873d15b545..9780829f8a05 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -557,15 +557,7 @@ static struct clk_lookup da850_clks[] = {
 	CLK("da830-mmc.0",	NULL,		&mmcsd0_clk),
 	CLK("da830-mmc.1",	NULL,		&mmcsd1_clk),
 	CLK("ti-aemif",		NULL,		&aemif_clk),
-	/*
-	 * The only user of this clock is davinci_nand and it get's it through
-	 * con_id. The nand node itself is created from within the aemif
-	 * driver to guarantee that it's probed after the aemif timing
-	 * parameters are configured. of_dev_auxdata is not accessible from
-	 * the aemif driver and can't be passed to of_platform_populate(). For
-	 * that reason we're leaving the dev_id here as NULL.
-	 */
-	CLK(NULL,		"aemif",	&aemif_nand_clk),
+	CLK("davinci-nand.0",	"aemif",	&aemif_nand_clk),
 	CLK("ohci-da8xx",	"usb11",	&usb11_clk),
 	CLK("musb-da8xx",	"usb20",	&usb20_clk),
 	CLK("spi_davinci.0",	NULL,		&spi0_clk),

commit b40881738f098e1be5c32e89c2691b688fc00875
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Wed Dec 7 16:22:18 2016 +0100

    ARM: davinci: da850: fix da850_set_pll0rate()
    
    This function is confusing - its second argument is an index to the
    freq table, not the requested clock rate in Hz, but it's used as the
    set_rate callback for the pll0 clock. It leads to an oops when the
    caller doesn't know the internals and passes the rate in Hz as
    argument instead of the cpufreq index since this argument isn't bounds
    checked either.
    
    Fix it by iterating over the array of supported frequencies and
    selecting a one that matches or returning -EINVAL for unsupported
    rates.
    
    Also: update the davinci cpufreq driver. It's the only user of this
    clock and currently it passes the cpufreq table index to
    clk_set_rate(), which is confusing. Make it pass the requested clock
    rate in Hz.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    [nsekhar@ti.com: commit headline update]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 063560d75b22..07d36fc1e33c 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1174,14 +1174,28 @@ static int da850_set_armrate(struct clk *clk, unsigned long index)
 	return clk_set_rate(pllclk, index);
 }
 
-static int da850_set_pll0rate(struct clk *clk, unsigned long index)
+static int da850_set_pll0rate(struct clk *clk, unsigned long rate)
 {
-	unsigned int prediv, mult, postdiv;
-	struct da850_opp *opp;
 	struct pll_data *pll = clk->pll_data;
+	struct cpufreq_frequency_table *freq;
+	unsigned int prediv, mult, postdiv;
+	struct da850_opp *opp = NULL;
 	int ret;
 
-	opp = (struct da850_opp *) cpufreq_info.freq_table[index].driver_data;
+	rate /= 1000;
+
+	for (freq = da850_freq_table;
+	     freq->frequency != CPUFREQ_TABLE_END; freq++) {
+		/* rate is in Hz, freq->frequency is in KHz */
+		if (freq->frequency == rate) {
+			opp = (struct da850_opp *)freq->driver_data;
+			break;
+		}
+	}
+
+	if (!opp)
+		return -EINVAL;
+
 	prediv = opp->prediv;
 	mult = opp->mult;
 	postdiv = opp->postdiv;

commit 0a5011673af0fe995a3e448d3479a027a4082ddf
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Wed Dec 7 16:22:17 2016 +0100

    ARM: davinci: da850: coding style fix
    
    Fix alignment of the clock lookup table entries.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    [nsekhar@ti.com: commit headline update]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index e770c97ea45c..063560d75b22 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -543,7 +543,7 @@ static struct clk_lookup da850_clks[] = {
 	CLK("spi_davinci.0",	NULL,		&spi0_clk),
 	CLK("spi_davinci.1",	NULL,		&spi1_clk),
 	CLK("vpif",		NULL,		&vpif_clk),
-	CLK("ahci_da850",		NULL,		&sata_clk),
+	CLK("ahci_da850",	NULL,		&sata_clk),
 	CLK("davinci-rproc.0",	NULL,		&dsp_clk),
 	CLK(NULL,		NULL,		&ehrpwm_clk),
 	CLK("ehrpwm.0",		"fck",		&ehrpwm0_clk),

commit ef37427ac5677331145ab27a17e6f5f1b43f0c11
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Wed Dec 7 16:22:16 2016 +0100

    ARM: davinci: da850: don't add emac clock to lookup table twice
    
    Similarly to the aemif clock - this screws up the linked list of clock
    children. Create a separate clock for mdio inheriting the rate from
    emac_clk.
    
    Cc: <stable@vger.kernel.org> # 3.12.x-
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    [nsekhar@ti.com: add a comment over mdio_clk to explaing its existence +
                     commit headline updates]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index e9d019cc8f46..1d873d15b545 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -319,6 +319,16 @@ static struct clk emac_clk = {
 	.gpsc		= 1,
 };
 
+/*
+ * In order to avoid adding the emac_clk to the clock lookup table twice (and
+ * screwing up the linked list in the process) create a separate clock for
+ * mdio inheriting the rate from emac_clk.
+ */
+static struct clk mdio_clk = {
+	.name		= "mdio",
+	.parent		= &emac_clk,
+};
+
 static struct clk mcasp_clk = {
 	.name		= "mcasp",
 	.parent		= &async3_clk,
@@ -539,7 +549,7 @@ static struct clk_lookup da850_clks[] = {
 	CLK(NULL,		"arm",		&arm_clk),
 	CLK(NULL,		"rmii",		&rmii_clk),
 	CLK("davinci_emac.1",	NULL,		&emac_clk),
-	CLK("davinci_mdio.0",	"fck",		&emac_clk),
+	CLK("davinci_mdio.0",	"fck",		&mdio_clk),
 	CLK("davinci-mcasp.0",	NULL,		&mcasp_clk),
 	CLK("davinci-mcbsp.0",	NULL,		&mcbsp0_clk),
 	CLK("davinci-mcbsp.1",	NULL,		&mcbsp1_clk),

commit 5d45b011c14a791ef23555a59ff7a3e6d213530f
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Wed Dec 7 16:22:15 2016 +0100

    ARM: davinci: da850: fix infinite loop in clk_set_rate()
    
    The aemif clock is added twice to the lookup table in da850.c. This
    breaks the children list of pll0_sysclk3 as we're using the same list
    links in struct clk. When calling clk_set_rate(), we get stuck in
    propagate_rate().
    
    Create a separate clock for nand, inheriting the rate of the aemif
    clock and retrieve it in the davinci_nand module.
    
    Cc: <stable@vger.kernel.org> # 4.9.x
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index e770c97ea45c..e9d019cc8f46 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -367,6 +367,16 @@ static struct clk aemif_clk = {
 	.flags		= ALWAYS_ENABLED,
 };
 
+/*
+ * In order to avoid adding the aemif_clk to the clock lookup table twice (and
+ * screwing up the linked list in the process) create a separate clock for
+ * nand inheriting the rate from aemif_clk.
+ */
+static struct clk aemif_nand_clk = {
+	.name		= "nand",
+	.parent		= &aemif_clk,
+};
+
 static struct clk usb11_clk = {
 	.name		= "usb11",
 	.parent		= &pll0_sysclk4,
@@ -537,7 +547,15 @@ static struct clk_lookup da850_clks[] = {
 	CLK("da830-mmc.0",	NULL,		&mmcsd0_clk),
 	CLK("da830-mmc.1",	NULL,		&mmcsd1_clk),
 	CLK("ti-aemif",		NULL,		&aemif_clk),
-	CLK(NULL,		"aemif",	&aemif_clk),
+	/*
+	 * The only user of this clock is davinci_nand and it get's it through
+	 * con_id. The nand node itself is created from within the aemif
+	 * driver to guarantee that it's probed after the aemif timing
+	 * parameters are configured. of_dev_auxdata is not accessible from
+	 * the aemif driver and can't be passed to of_platform_populate(). For
+	 * that reason we're leaving the dev_id here as NULL.
+	 */
+	CLK(NULL,		"aemif",	&aemif_nand_clk),
 	CLK("ohci-da8xx",	"usb11",	&usb11_clk),
 	CLK("musb-da8xx",	"usb20",	&usb20_clk),
 	CLK("spi_davinci.0",	NULL,		&spi0_clk),

commit e79ab194d15e1baa25540cb9efaf2a459cf4bc32
Merge: 3ec5e8d82b1a 44c29b83de17
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 15 15:39:02 2016 -0800

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform updates from Arnd Bergmann:
     "These are updates for platform specific code on 32-bit ARM machines,
      essentially anything that can not (yet) be expressed using DT files.
    
      Noteworthy changes include:
    
       - Added support for the TI DRA71x family of SoCs in mach-omap2, this
         is an new variant of the the DRA72x/DRA74x automotive infotainment
         chips we already supported for a while.
    
       - Added support for the ST STM32F746 SoC, the first Cortex-M7 based
         microcontroller we support, related to the smaller STM32F4 family.
    
       - Renesas adds support for r8a7743 and r8a7745 in mach-shmobile, see
         http://elinux.org/RZ-G
    
       - SMP is now supported on the OX820 platform
    
       - A lot of code in mach-omap2 gets removed as a follow-up to removing
         support for board files in the previous release
    
       - Davinci has some new work to improve USB support
    
       - For i.MX, the performance monitor now supports profiling the memory
         controller using 'perf'"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (95 commits)
      ARM: davinci: da830-evm: use gpio descriptor for mmc pins
      ARM: davinci: da850-evm: use gpio descriptor for mmc pins
      ARM: davinci: hawk: use gpio descriptor for mmc pins
      ARM: ARTPEC-6: add select MFD_SYSCON to MACH_ARTPEC6
      ARM: davinci: da8xx: Fix ohci device name
      ARM: oxnas: Add OX820 config and makefile entry
      ARM: oxnas: Add OX820 SMP support
      ARM: davinci: PM: fix build when da850 not compiled in
      ARM: orion5x: remove legacy support of ls-chl
      ARM: integrator: drop EBI access use syscon
      ARM: BCM5301X: Add back handler ignoring external imprecise aborts
      ARM: davinci: PM: support da8xx DT platforms
      ARM: davinci: PM: cleanup: remove references to pdata
      ARM: davinci: PM: rework init, remove platform device
      ARM: Kconfig: Introduce MACH_STM32F746 flag
      ARM: mach-stm32: Add a new SOC - STM32F746
      ARM: shmobile: document SK-RZG1E board
      ARM: shmobile: r8a7745: basic SoC support
      ARM: imx: mach-imx6ul: add imx6ull support
      ARM: zynq: Reserve correct amount of non-DMA RAM
      ...

commit 196249beabe34066fc4655af8bacbb5ab8b77224
Merge: c0db16b8151e b5e1438cf98a
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Nov 30 14:48:30 2016 +0100

    Merge tag 'davinci-for-v4.10/soc-3' of git://git.kernel.org/pub/scm/linux/kernel/git/nsekhar/linux-davinci into next/soc
    
    Pull "DaVinci SoC updates for v4.10 (part 3)" from Sekhar Nori:
    
    mach-davinci SoC support updates to adjust
    USB ohci device name to that used by drivers
    and update of various board files to use gpio
    descriptor API used by MMC subsystem for card
    detect and write-protect detection.
    
    * tag 'davinci-for-v4.10/soc-3' of git://git.kernel.org/pub/scm/linux/kernel/git/nsekhar/linux-davinci:
      ARM: davinci: da830-evm: use gpio descriptor for mmc pins
      ARM: davinci: da850-evm: use gpio descriptor for mmc pins
      ARM: davinci: hawk: use gpio descriptor for mmc pins
      ARM: davinci: da8xx: Fix ohci device name

commit e264ae280ce178c2da6ddf77c9a7928c6d3b6caa
Merge: e70a13e7d771 f7715b299954
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Nov 30 14:45:31 2016 +0100

    Merge tag 'davinci-for-v4.10/cleanup-2' of git://git.kernel.org/pub/scm/linux/kernel/git/nsekhar/linux-davinci into next/soc
    
    Pull DaVinci cleanup for v4.10 from Sekhar Nori:
    
    mach-davinci cleanup to make it easy to add PM support
    for DT-boot.
    
    * tag 'davinci-for-v4.10/cleanup-2' of git://git.kernel.org/pub/scm/linux/kernel/git/nsekhar/linux-davinci:
      ARM: davinci: PM: fix build when da850 not compiled in
      ARM: davinci: PM: cleanup: remove references to pdata
      ARM: davinci: PM: rework init, remove platform device

commit 8439a1d77d07514fadc616a2691b5d130ce0b678
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Thu Nov 3 17:03:06 2016 +0100

    ARM: davinci: da8xx: Fix ohci device name
    
    While the clk lookup table is making reference to "ohci"
    other subsystems (such as phy) are trying to match "ohci.0"
    
    Since there is a single ohci instance, instead of changing
    the clk name, change the dev id to -1, and add the "-da8xx"
    postfix to match the driver name that will also be changed
    in a subsequent patch.
    
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 196e262b7147..396155604e80 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -503,7 +503,7 @@ static struct clk_lookup da850_clks[] = {
 	CLK("da830-mmc.1",	NULL,		&mmcsd1_clk),
 	CLK("ti-aemif",		NULL,		&aemif_clk),
 	CLK(NULL,		"aemif",	&aemif_clk),
-	CLK("ohci",		"usb11",	&usb11_clk),
+	CLK("ohci-da8xx",	"usb11",	&usb11_clk),
 	CLK("musb-da8xx",	"usb20",	&usb20_clk),
 	CLK("spi_davinci.0",	NULL,		&spi0_clk),
 	CLK("spi_davinci.1",	NULL,		&spi1_clk),

commit aa9aa1ec2df6ffb270cf98b848570ed58e11a1f9
Author: Kevin Hilman <khilman@baylibre.com>
Date:   Tue Nov 15 11:54:19 2016 -0800

    ARM: davinci: PM: rework init, remove platform device
    
    Remove fake platform device used for PM init.  Move pdata values which
    are common across all current platforms into pm.c.
    
    Also, since PM is only used on da8xx, remove davinci_pm_init() from
    common init code, and only use in da850/omapl138 board files that are
    currently creating the fake platform_device.
    
    Suggested-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@baylibre.com>
    [nsekhar@ti.com: subject line adjustment]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index ed3d0e9f72ac..28771923199f 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1172,44 +1172,6 @@ static int da850_round_armrate(struct clk *clk, unsigned long rate)
 }
 #endif
 
-int __init da850_register_pm(struct platform_device *pdev)
-{
-	int ret;
-	struct davinci_pm_config *pdata = pdev->dev.platform_data;
-
-	ret = davinci_cfg_reg(DA850_RTC_ALARM);
-	if (ret)
-		return ret;
-
-	pdata->ddr2_ctlr_base = da8xx_get_mem_ctlr();
-	pdata->deepsleep_reg = DA8XX_SYSCFG1_VIRT(DA8XX_DEEPSLEEP_REG);
-	pdata->ddrpsc_num = DA8XX_LPSC1_EMIF3C;
-
-	pdata->cpupll_reg_base = ioremap(DA8XX_PLL0_BASE, SZ_4K);
-	if (!pdata->cpupll_reg_base)
-		return -ENOMEM;
-
-	pdata->ddrpll_reg_base = ioremap(DA850_PLL1_BASE, SZ_4K);
-	if (!pdata->ddrpll_reg_base) {
-		ret = -ENOMEM;
-		goto no_ddrpll_mem;
-	}
-
-	pdata->ddrpsc_reg_base = ioremap(DA8XX_PSC1_BASE, SZ_4K);
-	if (!pdata->ddrpsc_reg_base) {
-		ret = -ENOMEM;
-		goto no_ddrpsc_mem;
-	}
-
-	return platform_device_register(pdev);
-
-no_ddrpsc_mem:
-	iounmap(pdata->ddrpll_reg_base);
-no_ddrpll_mem:
-	iounmap(pdata->cpupll_reg_base);
-	return ret;
-}
-
 /* VPIF resource, platform data */
 static u64 da850_vpif_dma_mask = DMA_BIT_MASK(32);
 

commit 36173c2d023bad4dbad6ed0e6e886fde10ec8f2f
Author: David Lechner <david@lechnology.com>
Date:   Mon Oct 31 15:04:24 2016 -0500

    ARM: davinci: da850: Fix pwm name matching
    
    This fixes pwm name matching for DA850 familiy devices. When using device
    tree, the da850_auxdata_lookup[] table caused pwm devices to have the exact
    same name, which caused errors when trying to register the devices.
    
    We cannot have multiple entries for the same clock in in da850_clks[], so
    we have added child clocks to the EHRPWM and ECAP LPSC clocks so that each
    PWM device will have its own clock for proper name matching.
    
    Signed-off-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index ed3d0e9f72ac..6d8c8fa75ff1 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -424,6 +424,16 @@ static struct clk ehrpwm_clk = {
 	.gpsc		= 1,
 };
 
+static struct clk ehrpwm0_clk = {
+	.name		= "ehrpwm0",
+	.parent		= &ehrpwm_clk,
+};
+
+static struct clk ehrpwm1_clk = {
+	.name		= "ehrpwm1",
+	.parent		= &ehrpwm_clk,
+};
+
 #define DA8XX_EHRPWM_TBCLKSYNC	BIT(12)
 
 static void ehrpwm_tblck_enable(struct clk *clk)
@@ -451,6 +461,16 @@ static struct clk ehrpwm_tbclk = {
 	.clk_disable	= ehrpwm_tblck_disable,
 };
 
+static struct clk ehrpwm0_tbclk = {
+	.name		= "ehrpwm0_tbclk",
+	.parent		= &ehrpwm_tbclk,
+};
+
+static struct clk ehrpwm1_tbclk = {
+	.name		= "ehrpwm1_tbclk",
+	.parent		= &ehrpwm_tbclk,
+};
+
 static struct clk ecap_clk = {
 	.name		= "ecap",
 	.parent		= &async3_clk,
@@ -458,6 +478,21 @@ static struct clk ecap_clk = {
 	.gpsc		= 1,
 };
 
+static struct clk ecap0_clk = {
+	.name		= "ecap0_clk",
+	.parent		= &ecap_clk,
+};
+
+static struct clk ecap1_clk = {
+	.name		= "ecap1_clk",
+	.parent		= &ecap_clk,
+};
+
+static struct clk ecap2_clk = {
+	.name		= "ecap2_clk",
+	.parent		= &ecap_clk,
+};
+
 static struct clk_lookup da850_clks[] = {
 	CLK(NULL,		"ref",		&ref_clk),
 	CLK(NULL,		"pll0",		&pll0_clk),
@@ -510,9 +545,16 @@ static struct clk_lookup da850_clks[] = {
 	CLK("vpif",		NULL,		&vpif_clk),
 	CLK("ahci_da850",		NULL,		&sata_clk),
 	CLK("davinci-rproc.0",	NULL,		&dsp_clk),
-	CLK("ehrpwm",		"fck",		&ehrpwm_clk),
-	CLK("ehrpwm",		"tbclk",	&ehrpwm_tbclk),
-	CLK("ecap",		"fck",		&ecap_clk),
+	CLK(NULL,		NULL,		&ehrpwm_clk),
+	CLK("ehrpwm.0",		"fck",		&ehrpwm0_clk),
+	CLK("ehrpwm.1",		"fck",		&ehrpwm1_clk),
+	CLK(NULL,		NULL,		&ehrpwm_tbclk),
+	CLK("ehrpwm.0",		"tbclk",	&ehrpwm0_tbclk),
+	CLK("ehrpwm.1",		"tbclk",	&ehrpwm1_tbclk),
+	CLK(NULL,		NULL,		&ecap_clk),
+	CLK("ecap.0",		"fck",		&ecap0_clk),
+	CLK("ecap.1",		"fck",		&ecap1_clk),
+	CLK("ecap.2",		"fck",		&ecap2_clk),
 	CLK(NULL,		NULL,		NULL),
 };
 

commit b08157a1b650773ab446ae173c908f8c9abdb9a4
Author: David Lechner <david@lechnology.com>
Date:   Wed Oct 26 19:18:16 2016 -0500

    ARM: davinci: da8xx: Add USB device names to clock lookup tables
    
    This adds device names for the SoC USB devices to the clock lookup tables
    in da830.c and da850.c.
    
    Also add the USB device names to the da850_auxdata_lookup[] table.
    
    Signed-off-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index ed3d0e9f72ac..196e262b7147 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -503,8 +503,8 @@ static struct clk_lookup da850_clks[] = {
 	CLK("da830-mmc.1",	NULL,		&mmcsd1_clk),
 	CLK("ti-aemif",		NULL,		&aemif_clk),
 	CLK(NULL,		"aemif",	&aemif_clk),
-	CLK(NULL,		"usb11",	&usb11_clk),
-	CLK(NULL,		"usb20",	&usb20_clk),
+	CLK("ohci",		"usb11",	&usb11_clk),
+	CLK("musb-da8xx",	"usb20",	&usb20_clk),
 	CLK("spi_davinci.0",	NULL,		&spi0_clk),
 	CLK("spi_davinci.1",	NULL,		&spi1_clk),
 	CLK("vpif",		NULL,		&vpif_clk),

commit 8f899b4ed6918ee4f7b87654f772bdaa0d580124
Author: Karl Beldan <kbeldan@baylibre.com>
Date:   Fri Aug 19 16:47:36 2016 +0000

    ARM: davinci: da850: Add ti-aemif lookup for clock matching
    
    The davinci boards don't have their clocks in DT yet and getting a clock
    will fail, unless registering them as clk_lookups. This registers the
    aemif clock for the ti-aemif memory driver.
    
    The current aemif lookup entry resolving to the same clock:
        'CLK(NULL,               "aemif",        &aemif_clk)'
    is currently used by davinci_nand and remains for non-DT and backward
    compatibility.
    
    Currently the davinci boards only configure the AEMIF in case of non-DT
    boot, via some code in mach-davinci.
    This change will allow DT-based davinci platforms to do the same, via
    the ti-aemif memory driver code.
    
    Signed-off-by: Karl Beldan <kbeldan@baylibre.com>
    [nsekhar@ti.com: reworded commit message]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 0d046accb35b..ed3d0e9f72ac 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -501,6 +501,7 @@ static struct clk_lookup da850_clks[] = {
 	CLK("da8xx_lcdc.0",	"fck",		&lcdc_clk),
 	CLK("da830-mmc.0",	NULL,		&mmcsd0_clk),
 	CLK("da830-mmc.1",	NULL,		&mmcsd1_clk),
+	CLK("ti-aemif",		NULL,		&aemif_clk),
 	CLK(NULL,		"aemif",	&aemif_clk),
 	CLK(NULL,		"usb11",	&usb11_clk),
 	CLK(NULL,		"usb20",	&usb20_clk),

commit ca5c098f75ec21d47f9e824d12aa11c45f2a1fe5
Author: Petr Kulhavy <petr@barix.com>
Date:   Mon May 9 16:00:10 2016 +0200

    ARM: davinci: da850: add clocks for mcbsp0 and 1
    
    Add clock definitions "davinci-mcbsp.0" and "davinci-mcbsp.1" in order
    to make McBSP driver work on the DA850 platform.
    
    The McBSP 0 and 1 interfaces were not defined for the DA850 platform.
    Neither were the related clocks. In order to make the use of McBSP via
    devicetree the clocks need to be defined.
    
    Signed-off-by: Petr Kulhavy <petr@barix.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 239886299968..0d046accb35b 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -326,6 +326,20 @@ static struct clk mcasp_clk = {
 	.gpsc		= 1,
 };
 
+static struct clk mcbsp0_clk = {
+	.name		= "mcbsp0",
+	.parent		= &async3_clk,
+	.lpsc		= DA850_LPSC1_McBSP0,
+	.gpsc		= 1,
+};
+
+static struct clk mcbsp1_clk = {
+	.name		= "mcbsp1",
+	.parent		= &async3_clk,
+	.lpsc		= DA850_LPSC1_McBSP1,
+	.gpsc		= 1,
+};
+
 static struct clk lcdc_clk = {
 	.name		= "lcdc",
 	.parent		= &pll0_sysclk2,
@@ -482,6 +496,8 @@ static struct clk_lookup da850_clks[] = {
 	CLK("davinci_emac.1",	NULL,		&emac_clk),
 	CLK("davinci_mdio.0",	"fck",		&emac_clk),
 	CLK("davinci-mcasp.0",	NULL,		&mcasp_clk),
+	CLK("davinci-mcbsp.0",	NULL,		&mcbsp0_clk),
+	CLK("davinci-mcbsp.1",	NULL,		&mcbsp1_clk),
 	CLK("da8xx_lcdc.0",	"fck",		&lcdc_clk),
 	CLK("da830-mmc.0",	NULL,		&mmcsd0_clk),
 	CLK("da830-mmc.1",	NULL,		&mmcsd1_clk),

commit 3f2a09d57bb12ca55f92209b3ef0c0684cdb20b0
Author: David Lechner <david@lechnology.com>
Date:   Thu Apr 14 14:13:36 2016 -0500

    ARM: davinci: da850: use clk->set_parent for async3
    
    The da850 family of processors has an async3 clock domain that can be
    muxed to either pll0_sysclk2 or pll1_sysclk2. Now that the davinci clocks
    have a set_parent callback, we can use this to control the async3 mux
    instead of a stand-alone function.
    
    This adds a new async3_clk and sets the appropriate child clocks. The
    default is use to pll1_sysclk2 since it is not affected by processor
    frequency scaling.
    
    Signed-off-by: David Lechner <david@lechnology.com>
    [nsekhar@ti.com: drop unnecessary comment]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 1f85bbca2e55..239886299968 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -34,9 +34,6 @@
 #include "clock.h"
 #include "mux.h"
 
-/* SoC specific clock flags */
-#define DA850_CLK_ASYNC3	BIT(16)
-
 #define DA850_PLL1_BASE		0x01e1a000
 #define DA850_TIMER64P2_BASE	0x01f0c000
 #define DA850_TIMER64P3_BASE	0x01f0d000
@@ -161,6 +158,32 @@ static struct clk pll1_sysclk3 = {
 	.div_reg	= PLLDIV3,
 };
 
+static int da850_async3_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 val;
+
+	val = readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));
+
+	if (parent == &pll0_sysclk2) {
+		val &= ~CFGCHIP3_ASYNC3_CLKSRC;
+	} else if (parent == &pll1_sysclk2) {
+		val |= CFGCHIP3_ASYNC3_CLKSRC;
+	} else {
+		pr_err("Bad parent on async3 clock mux\n");
+		return -EINVAL;
+	}
+
+	writel(val, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));
+
+	return 0;
+}
+
+static struct clk async3_clk = {
+	.name		= "async3",
+	.parent		= &pll1_sysclk2,
+	.set_parent	= da850_async3_set_parent,
+};
+
 static struct clk i2c0_clk = {
 	.name		= "i2c0",
 	.parent		= &pll0_aux_clk,
@@ -234,18 +257,16 @@ static struct clk uart0_clk = {
 
 static struct clk uart1_clk = {
 	.name		= "uart1",
-	.parent		= &pll0_sysclk2,
+	.parent		= &async3_clk,
 	.lpsc		= DA8XX_LPSC1_UART1,
 	.gpsc		= 1,
-	.flags		= DA850_CLK_ASYNC3,
 };
 
 static struct clk uart2_clk = {
 	.name		= "uart2",
-	.parent		= &pll0_sysclk2,
+	.parent		= &async3_clk,
 	.lpsc		= DA8XX_LPSC1_UART2,
 	.gpsc		= 1,
-	.flags		= DA850_CLK_ASYNC3,
 };
 
 static struct clk aintc_clk = {
@@ -300,10 +321,9 @@ static struct clk emac_clk = {
 
 static struct clk mcasp_clk = {
 	.name		= "mcasp",
-	.parent		= &pll0_sysclk2,
+	.parent		= &async3_clk,
 	.lpsc		= DA8XX_LPSC1_McASP0,
 	.gpsc		= 1,
-	.flags		= DA850_CLK_ASYNC3,
 };
 
 static struct clk lcdc_clk = {
@@ -355,10 +375,9 @@ static struct clk spi0_clk = {
 
 static struct clk spi1_clk = {
 	.name		= "spi1",
-	.parent		= &pll0_sysclk2,
+	.parent		= &async3_clk,
 	.lpsc		= DA8XX_LPSC1_SPI1,
 	.gpsc		= 1,
-	.flags		= DA850_CLK_ASYNC3,
 };
 
 static struct clk vpif_clk = {
@@ -386,10 +405,9 @@ static struct clk dsp_clk = {
 
 static struct clk ehrpwm_clk = {
 	.name		= "ehrpwm",
-	.parent		= &pll0_sysclk2,
+	.parent		= &async3_clk,
 	.lpsc		= DA8XX_LPSC1_PWM,
 	.gpsc		= 1,
-	.flags		= DA850_CLK_ASYNC3,
 };
 
 #define DA8XX_EHRPWM_TBCLKSYNC	BIT(12)
@@ -421,10 +439,9 @@ static struct clk ehrpwm_tbclk = {
 
 static struct clk ecap_clk = {
 	.name		= "ecap",
-	.parent		= &pll0_sysclk2,
+	.parent		= &async3_clk,
 	.lpsc		= DA8XX_LPSC1_ECAP,
 	.gpsc		= 1,
-	.flags		= DA850_CLK_ASYNC3,
 };
 
 static struct clk_lookup da850_clks[] = {
@@ -442,6 +459,7 @@ static struct clk_lookup da850_clks[] = {
 	CLK(NULL,		"pll1_aux",	&pll1_aux_clk),
 	CLK(NULL,		"pll1_sysclk2",	&pll1_sysclk2),
 	CLK(NULL,		"pll1_sysclk3",	&pll1_sysclk3),
+	CLK(NULL,		"async3",	&async3_clk),
 	CLK("i2c_davinci.1",	NULL,		&i2c0_clk),
 	CLK(NULL,		"timer0",	&timerp64_0_clk),
 	CLK("davinci-wdt",	NULL,		&timerp64_1_clk),
@@ -909,30 +927,6 @@ static struct davinci_timer_info da850_timer_info = {
 	.clocksource_id	= T0_TOP,
 };
 
-static void da850_set_async3_src(int pllnum)
-{
-	struct clk *clk, *newparent = pllnum ? &pll1_sysclk2 : &pll0_sysclk2;
-	struct clk_lookup *c;
-	unsigned int v;
-	int ret;
-
-	for (c = da850_clks; c->clk; c++) {
-		clk = c->clk;
-		if (clk->flags & DA850_CLK_ASYNC3) {
-			ret = clk_set_parent(clk, newparent);
-			WARN(ret, "DA850: unable to re-parent clock %s",
-								clk->name);
-		}
-       }
-
-	v = __raw_readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));
-	if (pllnum)
-		v |= CFGCHIP3_ASYNC3_CLKSRC;
-	else
-		v &= ~CFGCHIP3_ASYNC3_CLKSRC;
-	__raw_writel(v, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));
-}
-
 #ifdef CONFIG_CPU_FREQ
 /*
  * Notes:
@@ -1328,15 +1322,6 @@ void __init da850_init(void)
 	if (WARN(!da8xx_syscfg1_base, "Unable to map syscfg1 module"))
 		return;
 
-	/*
-	 * Move the clock source of Async3 domain to PLL1 SYSCLK2.
-	 * This helps keeping the peripherals on this domain insulated
-	 * from CPU frequency changes caused by DVFS. The firmware sets
-	 * both PLL0 and PLL1 to the same frequency so, there should not
-	 * be any noticeable change even in non-DVFS use cases.
-	 */
-	da850_set_async3_src(1);
-
 	/* Unlock writing to PLL0 registers */
 	v = __raw_readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP0_REG));
 	v &= ~CFGCHIP0_PLL_MASTER_LOCK;

commit 6fc9ebbdeb75197df780c52f5ebcc3eeffb9cd91
Author: David Lechner <david@lechnology.com>
Date:   Thu Apr 14 14:13:35 2016 -0500

    ARM: davinci: Move clock init after ioremap.
    
    Some clocks (such as the USB PHY clocks in DA8xx) will need to use iomem.
    The davinci_common_init() function must be called before the ioremap, so
    the clock init is now split out as separate function.
    
    Signed-off-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 97d8779a9a65..1f85bbca2e55 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1346,4 +1346,6 @@ void __init da850_init(void)
 	v = __raw_readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));
 	v &= ~CFGCHIP3_PLL1_MASTER_LOCK;
 	__raw_writel(v, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));
+
+	davinci_clk_init(davinci_soc_info_da850.cpu_clks);
 }

commit 3acf731ccad039d91721b6cd9fc85569e9f958ca
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jan 30 10:45:33 2015 +0100

    ARM: davinci: make headers more local
    
    Some header files are never included outside of a mach-davinci
    directory and do not need to be made visible in include/mach,
    so let's just move them all down one level.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 676997895e13..97d8779a9a65 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -22,7 +22,7 @@
 
 #include <asm/mach/map.h>
 
-#include <mach/psc.h>
+#include "psc.h"
 #include <mach/irqs.h>
 #include <mach/cputype.h>
 #include <mach/common.h>

commit 19c233b79d1af7b5af1ec68c1172848648184449
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Mon Jul 27 18:27:52 2015 -0400

    ARM: appropriate __init annotation for const data
    
    Init data marked const should be annotated with __initconst for
    correctness and not __initdata.  In some cases the array gathering
    references to that data has to be marked const as well. This fixes
    LTO builds that otherwise fail with section mismatch errors.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 3b8740c083c4..676997895e13 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -715,7 +715,7 @@ const short da850_lcdcntl_pins[] __initconst = {
 	-1
 };
 
-const short da850_vpif_capture_pins[] __initdata = {
+const short da850_vpif_capture_pins[] __initconst = {
 	DA850_VPIF_DIN0, DA850_VPIF_DIN1, DA850_VPIF_DIN2, DA850_VPIF_DIN3,
 	DA850_VPIF_DIN4, DA850_VPIF_DIN5, DA850_VPIF_DIN6, DA850_VPIF_DIN7,
 	DA850_VPIF_DIN8, DA850_VPIF_DIN9, DA850_VPIF_DIN10, DA850_VPIF_DIN11,
@@ -725,7 +725,7 @@ const short da850_vpif_capture_pins[] __initdata = {
 	-1
 };
 
-const short da850_vpif_display_pins[] __initdata = {
+const short da850_vpif_display_pins[] __initconst = {
 	DA850_VPIF_DOUT0, DA850_VPIF_DOUT1, DA850_VPIF_DOUT2, DA850_VPIF_DOUT3,
 	DA850_VPIF_DOUT4, DA850_VPIF_DOUT5, DA850_VPIF_DOUT6, DA850_VPIF_DOUT7,
 	DA850_VPIF_DOUT8, DA850_VPIF_DOUT9, DA850_VPIF_DOUT10,

commit 2d34e507293102f29ee94d9a9c5b890696d42452
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Mar 9 11:03:00 2015 +0000

    clkdev: get rid of redundant clk_add_alias() prototype in linux/clk.h
    
    clk_add_alias() is provided by clkdev, and is not part of the clk API.
    Howver, it is prototyped in two locations: linux/clkdev.h and
    linux/clk.h.  This is a mess.  Get rid of the redundant and unnecessary
    version in linux/clk.h.
    
    Acked-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 45ce065e7170..3b8740c083c4 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -11,6 +11,7 @@
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
  */
+#include <linux/clkdev.h>
 #include <linux/gpio.h>
 #include <linux/init.h>
 #include <linux/clk.h>

commit 499f8ad5ab8a3bd79e31d80469e509a5bcd86aa3
Author: Stratos Karafotis <stratosk@semaphore.gr>
Date:   Fri Apr 25 23:15:55 2014 +0300

    ARM: davinci: da850: Use cpufreq_for_each_entry macro for iteration
    
    The cpufreq core now supports the cpufreq_for_each_entry macro helper
    for iteration over the cpufreq_frequency_table, so use it.
    
    It should have no functional changes.
    
    Signed-off-by: Stratos Karafotis <stratosk@semaphore.gr>
    Acked-and-tested-by: Lad, Prabhakar <prabhakar.csengg@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 85399c98f84a..45ce065e7170 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1092,20 +1092,21 @@ int da850_register_cpufreq(char *async_clk)
 
 static int da850_round_armrate(struct clk *clk, unsigned long rate)
 {
-	int i, ret = 0, diff;
+	int ret = 0, diff;
 	unsigned int best = (unsigned int) -1;
 	struct cpufreq_frequency_table *table = cpufreq_info.freq_table;
+	struct cpufreq_frequency_table *pos;
 
 	rate /= 1000; /* convert to kHz */
 
-	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
-		diff = table[i].frequency - rate;
+	cpufreq_for_each_entry(pos, table) {
+		diff = pos->frequency - rate;
 		if (diff < 0)
 			diff = -diff;
 
 		if (diff < best) {
 			best = diff;
-			ret = table[i].frequency;
+			ret = pos->frequency;
 		}
 	}
 

commit 080c492df02bd1171963d70daf7305a72443873d
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Tue Mar 25 19:51:41 2014 +0100

    ARM: davinci: da850: update SATA AHCI support
    
    Update SATA AHCI support to make use of the new ahci_da850 host
    driver (instead of the generic ahci_platform one) and remove
    deprecated ahci_platform_data code.
    
    Cc: Sekhar Nori <nsekhar@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 2ab00434b2eb..85399c98f84a 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -472,7 +472,7 @@ static struct clk_lookup da850_clks[] = {
 	CLK("spi_davinci.0",	NULL,		&spi0_clk),
 	CLK("spi_davinci.1",	NULL,		&spi1_clk),
 	CLK("vpif",		NULL,		&vpif_clk),
-	CLK("ahci",		NULL,		&sata_clk),
+	CLK("ahci_da850",		NULL,		&sata_clk),
 	CLK("davinci-rproc.0",	NULL,		&dsp_clk),
 	CLK("ehrpwm",		"fck",		&ehrpwm_clk),
 	CLK("ehrpwm",		"tbclk",	&ehrpwm_tbclk),

commit cd2f43a1f7400a74a084094502f70df2e169c6e8
Merge: 64576e439709 843748123d95
Author: Kevin Hilman <khilman@linaro.org>
Date:   Thu Jan 16 13:59:44 2014 -0800

    Merge tag 'davinci-for-v3.14/watchdog' of git://git.kernel.org/pub/scm/linux/kernel/git/nsekhar/linux-davinci into next/drivers
    
    From Sekhar Nori:
    This patch updates the davinci watchdog
    platform device name from generic "watchdog"
    to something more specific.
    
    * tag 'davinci-for-v3.14/watchdog' of git://git.kernel.org/pub/scm/linux/kernel/git/nsekhar/linux-davinci:
      watchdog: davinci: rename platform driver to davinci-wdt
    
    Signed-off-by: Kevin Hilman <khilman@linaro.org>

commit 843748123d95ae77a489b41f2f193e8502fc7ea8
Author: Ivan Khoronzhuk <ivan.khoronzhuk@ti.com>
Date:   Wed Nov 27 15:31:53 2013 +0200

    watchdog: davinci: rename platform driver to davinci-wdt
    
    As we switch to use the watchdog core which permits more than one
    active watchdog in the system, rename platform driver to
    "davinci-wdt" to be identifiable.
    
    Acked-by: Wim Van Sebroeck <wim@iguana.be>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Ivan Khoronzhuk <ivan.khoronzhuk@ti.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 352984e1528a..ccb2f5893223 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -443,7 +443,7 @@ static struct clk_lookup da850_clks[] = {
 	CLK(NULL,		"pll1_sysclk3",	&pll1_sysclk3),
 	CLK("i2c_davinci.1",	NULL,		&i2c0_clk),
 	CLK(NULL,		"timer0",	&timerp64_0_clk),
-	CLK("watchdog",		NULL,		&timerp64_1_clk),
+	CLK("davinci-wdt",	NULL,		&timerp64_1_clk),
 	CLK(NULL,		"arm_rom",	&arm_rom_clk),
 	CLK(NULL,		"tpcc0",	&tpcc0_clk),
 	CLK(NULL,		"tptc0",	&tptc0_clk),

commit d3422a18dbc4a8aa1d430828b39e48d6c91f1791
Author: Lad, Prabhakar <prabhakar.csengg@gmail.com>
Date:   Thu Nov 21 23:45:28 2013 +0530

    gpio: davinci: remove unused variable intc_irq_num
    
    As the davinci-gpio driver is migrated to use irqdomain
    there is no need to pass the irq base for the gpio driver.
    This patch removes this variable from davinci_gpio_platform_data
    and also the refrences from the machine file.
    
    Signed-off-by: Lad, Prabhakar <prabhakar.csengg@gmail.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 352984e1528a..437931746689 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1283,7 +1283,6 @@ int __init da850_register_vpif_capture(struct vpif_capture_config
 
 static struct davinci_gpio_platform_data da850_gpio_platform_data = {
 	.ngpio = 144,
-	.intc_irq_num = DA850_N_CP_INTC_IRQ,
 };
 
 int __init da850_register_gpio(void)

commit f606d38de74a2f2d43d4a57317aaa8f05809fdef
Author: KV Sujith <sujithkv@ti.com>
Date:   Sun Aug 18 10:48:59 2013 +0530

    ARM: davinci: da8xx: support gpio platform device
    
    DaVinci GPIO driver now uses platform device model.
    Convert DA8XX SoC code to use the new model.
    
    Add da8xx_register_gpio() to create platform device for da8xx
    platforms.
    
    Signed-off-by: KV Sujith <sujithkv@ti.com>
    Signed-off-by: Philip Avinash <avinashphilip@ti.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    [nsekhar@ti.com: simplify commit message]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Lad, Prabhakar <prabhakar.csengg@gmail.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index f56e5fbfa2fd..352984e1528a 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -17,6 +17,7 @@
 #include <linux/platform_device.h>
 #include <linux/cpufreq.h>
 #include <linux/regulator/consumer.h>
+#include <linux/platform_data/gpio-davinci.h>
 
 #include <asm/mach/map.h>
 
@@ -28,7 +29,6 @@
 #include <mach/da8xx.h>
 #include <mach/cpufreq.h>
 #include <mach/pm.h>
-#include <mach/gpio-davinci.h>
 
 #include "clock.h"
 #include "mux.h"
@@ -1281,6 +1281,16 @@ int __init da850_register_vpif_capture(struct vpif_capture_config
 	return platform_device_register(&da850_vpif_capture_dev);
 }
 
+static struct davinci_gpio_platform_data da850_gpio_platform_data = {
+	.ngpio = 144,
+	.intc_irq_num = DA850_N_CP_INTC_IRQ,
+};
+
+int __init da850_register_gpio(void)
+{
+	return da8xx_register_gpio(&da850_gpio_platform_data);
+}
+
 static struct davinci_soc_info davinci_soc_info_da850 = {
 	.io_desc		= da850_io_desc,
 	.io_desc_num		= ARRAY_SIZE(da850_io_desc),
@@ -1298,10 +1308,6 @@ static struct davinci_soc_info davinci_soc_info_da850 = {
 	.intc_irq_prios		= da850_default_priorities,
 	.intc_irq_num		= DA850_N_CP_INTC_IRQ,
 	.timer_info		= &da850_timer_info,
-	.gpio_type		= GPIO_TYPE_DAVINCI,
-	.gpio_base		= DA8XX_GPIO_BASE,
-	.gpio_num		= 144,
-	.gpio_irq		= IRQ_DA8XX_GPIO0,
 	.emac_pdata		= &da8xx_emac_pdata,
 	.sram_dma		= DA8XX_SHARED_RAM_BASE,
 	.sram_len		= SZ_128K,

commit 46c1833467c5e555f31cd6f14b342a7383f26885
Author: Lad, Prabhakar <prabhakar.csengg@gmail.com>
Date:   Thu Aug 15 11:31:33 2013 +0530

    ARM: davinci: fix clock lookup for mdio device
    
    This patch removes the clock alias for mdio device and adds a entry
    in clock lookup table, this entry can now be used by both DT and
    non-DT case.
    
    Signed-off-by: Lad, Prabhakar <prabhakar.csengg@gmail.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 5ef37f9d5984..f56e5fbfa2fd 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -461,6 +461,7 @@ static struct clk_lookup da850_clks[] = {
 	CLK(NULL,		"arm",		&arm_clk),
 	CLK(NULL,		"rmii",		&rmii_clk),
 	CLK("davinci_emac.1",	NULL,		&emac_clk),
+	CLK("davinci_mdio.0",	"fck",		&emac_clk),
 	CLK("davinci-mcasp.0",	NULL,		&mcasp_clk),
 	CLK("da8xx_lcdc.0",	"fck",		&lcdc_clk),
 	CLK("da830-mmc.0",	NULL,		&mmcsd0_clk),

commit 323761bb7518d27c62c1514156cb3243930b55c1
Author: Manjunathappa, Prakash <prakash.pm@ti.com>
Date:   Wed Jun 19 14:45:42 2013 +0530

    ARM: davinci: serial: remove davinci_serial_setup_clk()
    
    Get rid of davinci_serial_setup_clk() since its not called
    from multiple places now. Instead initialize clock in
    davinci_serial_init() itself. This also helps get rid of
    "serial_dev" member of struct davinci_soc_info.
    
    Signed-off-by: Manjunathappa, Prakash <prakash.pm@ti.com>
    Suggested-by: Sekhar Nori <nsekhar@ti.com>
    [nsekhar@ti.com: split removal of davinci_serial_setup_clk()
                     into a separate patch.]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index d4274ab5e742..5ef37f9d5984 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1301,7 +1301,6 @@ static struct davinci_soc_info davinci_soc_info_da850 = {
 	.gpio_base		= DA8XX_GPIO_BASE,
 	.gpio_num		= 144,
 	.gpio_irq		= IRQ_DA8XX_GPIO0,
-	.serial_dev		= da8xx_serial_device,
 	.emac_pdata		= &da8xx_emac_pdata,
 	.sram_dma		= DA8XX_SHARED_RAM_BASE,
 	.sram_len		= SZ_128K,

commit 19955c3d7453757271d05859958ca1804a5d2d67
Author: Manjunathappa, Prakash <prakash.pm@ti.com>
Date:   Wed Jun 19 14:45:38 2013 +0530

    ARM: davinci: uart: move to devid based clk_get
    
    For modules having single clock, clk_get should be done with dev_id.
    But current davinci implementation handles multiple instances
    of the UART devices with single platform_device_register. Hence clk_get
    is based on con_id rather than dev_id, this is not correct. Do
    platform_device_register for each instance and clk_get on dev_id.
    
    Signed-off-by: Manjunathappa, Prakash <prakash.pm@ti.com>
    [nsekhar@ti.com: actually stop using con_id in clk_get(), squash the
                     patch adding OF aux data into this one]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index a0d4f6038b60..d4274ab5e742 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -451,9 +451,9 @@ static struct clk_lookup da850_clks[] = {
 	CLK(NULL,		"tpcc1",	&tpcc1_clk),
 	CLK(NULL,		"tptc2",	&tptc2_clk),
 	CLK("pruss_uio",	"pruss",	&pruss_clk),
-	CLK(NULL,		"uart0",	&uart0_clk),
-	CLK(NULL,		"uart1",	&uart1_clk),
-	CLK(NULL,		"uart2",	&uart2_clk),
+	CLK("serial8250.0",	NULL,		&uart0_clk),
+	CLK("serial8250.1",	NULL,		&uart1_clk),
+	CLK("serial8250.2",	NULL,		&uart2_clk),
 	CLK(NULL,		"aintc",	&aintc_clk),
 	CLK(NULL,		"gpio",		&gpio_clk),
 	CLK("i2c_davinci.2",	NULL,		&i2c1_clk),
@@ -1301,7 +1301,7 @@ static struct davinci_soc_info davinci_soc_info_da850 = {
 	.gpio_base		= DA8XX_GPIO_BASE,
 	.gpio_num		= 144,
 	.gpio_irq		= IRQ_DA8XX_GPIO0,
-	.serial_dev		= &da8xx_serial_device,
+	.serial_dev		= da8xx_serial_device,
 	.emac_pdata		= &da8xx_emac_pdata,
 	.sram_dma		= DA8XX_SHARED_RAM_BASE,
 	.sram_len		= SZ_128K,

commit 5070158804b5339c71809f5e673cea1cfacd804d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat Mar 30 16:25:15 2013 +0530

    cpufreq: rename index as driver_data in cpufreq_frequency_table
    
    The "index" field of struct cpufreq_frequency_table was never an
    index and isn't used at all by the cpufreq core.  It only is useful
    for cpufreq drivers for their internal purposes.
    
    Many people nowadays blindly set it in ascending order with the
    assumption that the core will use it, which is a mistake.
    
    Rename it to "driver_data" as that's what its purpose is. All of its
    users are updated accordingly.
    
    [rjw: Changelog]
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 4d6933848abf..a0d4f6038b60 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1004,7 +1004,7 @@ static const struct da850_opp da850_opp_96 = {
 
 #define OPP(freq) 		\
 	{				\
-		.index = (unsigned int) &da850_opp_##freq,	\
+		.driver_data = (unsigned int) &da850_opp_##freq,	\
 		.frequency = freq * 1000, \
 	}
 
@@ -1016,7 +1016,7 @@ static struct cpufreq_frequency_table da850_freq_table[] = {
 	OPP(200),
 	OPP(96),
 	{
-		.index		= 0,
+		.driver_data		= 0,
 		.frequency	= CPUFREQ_TABLE_END,
 	},
 };
@@ -1044,7 +1044,7 @@ static int da850_set_voltage(unsigned int index)
 	if (!cvdd)
 		return -ENODEV;
 
-	opp = (struct da850_opp *) cpufreq_info.freq_table[index].index;
+	opp = (struct da850_opp *) cpufreq_info.freq_table[index].driver_data;
 
 	return regulator_set_voltage(cvdd, opp->cvdd_min, opp->cvdd_max);
 }
@@ -1125,7 +1125,7 @@ static int da850_set_pll0rate(struct clk *clk, unsigned long index)
 	struct pll_data *pll = clk->pll_data;
 	int ret;
 
-	opp = (struct da850_opp *) cpufreq_info.freq_table[index].index;
+	opp = (struct da850_opp *) cpufreq_info.freq_table[index].driver_data;
 	prediv = opp->prediv;
 	mult = opp->mult;
 	postdiv = opp->postdiv;

commit d7ca4c755a82eda8f0fc4f72c52130056b28c7d2
Author: Manjunathappa, Prakash <prakash.pm@ti.com>
Date:   Thu Mar 28 18:41:59 2013 +0530

    ARM: davinci: mmc: derive version information from device name
    
    Remove specifying mmc controller IP version information via platform
    data, instead specify device name so that driver derives it from
    platform_device_id table. Also change the clock node name to match
    the changed dev_id.
    Tested on da850-evm to make sure driver loads without clk_get failures.
    
    Signed-off-by: Manjunathappa, Prakash <prakash.pm@ti.com>
    Reviewed-by: Sekhar Nori <nsekhar@ti.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 2a2f60c54ec6..4d6933848abf 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -463,8 +463,8 @@ static struct clk_lookup da850_clks[] = {
 	CLK("davinci_emac.1",	NULL,		&emac_clk),
 	CLK("davinci-mcasp.0",	NULL,		&mcasp_clk),
 	CLK("da8xx_lcdc.0",	"fck",		&lcdc_clk),
-	CLK("davinci_mmc.0",	NULL,		&mmcsd0_clk),
-	CLK("davinci_mmc.1",	NULL,		&mmcsd1_clk),
+	CLK("da830-mmc.0",	NULL,		&mmcsd0_clk),
+	CLK("da830-mmc.1",	NULL,		&mmcsd1_clk),
 	CLK(NULL,		"aemif",	&aemif_clk),
 	CLK(NULL,		"usb11",	&usb11_clk),
 	CLK(NULL,		"usb20",	&usb20_clk),

commit bb170e6118e76903bf03fc14ab60a34c26aac747
Author: Philip Avinash <avinashphilip@ti.com>
Date:   Mon Mar 25 13:19:48 2013 +0530

    ARM: davinci: da850: add ECAP & EHRPWM clock nodes
    
    Add ECAP and EHRPWM module clock nodes. Also add a clock
    node for TBCLK for EHRWPM.
    
    Signed-off-by: Philip Avinash <avinashphilip@ti.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 0c4a26ddebba..2a2f60c54ec6 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -383,6 +383,49 @@ static struct clk dsp_clk = {
 	.flags		= PSC_LRST | PSC_FORCE,
 };
 
+static struct clk ehrpwm_clk = {
+	.name		= "ehrpwm",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC1_PWM,
+	.gpsc		= 1,
+	.flags		= DA850_CLK_ASYNC3,
+};
+
+#define DA8XX_EHRPWM_TBCLKSYNC	BIT(12)
+
+static void ehrpwm_tblck_enable(struct clk *clk)
+{
+	u32 val;
+
+	val = readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP1_REG));
+	val |= DA8XX_EHRPWM_TBCLKSYNC;
+	writel(val, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP1_REG));
+}
+
+static void ehrpwm_tblck_disable(struct clk *clk)
+{
+	u32 val;
+
+	val = readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP1_REG));
+	val &= ~DA8XX_EHRPWM_TBCLKSYNC;
+	writel(val, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP1_REG));
+}
+
+static struct clk ehrpwm_tbclk = {
+	.name		= "ehrpwm_tbclk",
+	.parent		= &ehrpwm_clk,
+	.clk_enable	= ehrpwm_tblck_enable,
+	.clk_disable	= ehrpwm_tblck_disable,
+};
+
+static struct clk ecap_clk = {
+	.name		= "ecap",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC1_ECAP,
+	.gpsc		= 1,
+	.flags		= DA850_CLK_ASYNC3,
+};
+
 static struct clk_lookup da850_clks[] = {
 	CLK(NULL,		"ref",		&ref_clk),
 	CLK(NULL,		"pll0",		&pll0_clk),
@@ -430,6 +473,9 @@ static struct clk_lookup da850_clks[] = {
 	CLK("vpif",		NULL,		&vpif_clk),
 	CLK("ahci",		NULL,		&sata_clk),
 	CLK("davinci-rproc.0",	NULL,		&dsp_clk),
+	CLK("ehrpwm",		"fck",		&ehrpwm_clk),
+	CLK("ehrpwm",		"tbclk",	&ehrpwm_tbclk),
+	CLK("ecap",		"fck",		&ecap_clk),
 	CLK(NULL,		NULL,		NULL),
 };
 

commit 09810a853b9a7920ba8c250d18815ef236effc47
Author: Robert Tivy <rtivy@ti.com>
Date:   Thu Jan 10 16:23:22 2013 -0800

    ARM: davinci: da850: add dsp clock definition
    
    Added dsp clock definition, keyed to "davinci-rproc.0".
    DSP clocks is derived from pll0 sysclk1. Add a clock tree
    node for that too.
    
    Signed-off-by: Robert Tivy <rtivy@ti.com>
    [nsekhar@ti.com: merge addition of pll0 sysclk1 and dsp clock
    into one commit. Add PSC_FORCE to dsp clock node to handle the
    case where DSP does not go into IDLE and its clock needs to
    be disabled.]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 6b9154e9f908..0c4a26ddebba 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -76,6 +76,13 @@ static struct clk pll0_aux_clk = {
 	.flags		= CLK_PLL | PRE_PLL,
 };
 
+static struct clk pll0_sysclk1 = {
+	.name		= "pll0_sysclk1",
+	.parent		= &pll0_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV1,
+};
+
 static struct clk pll0_sysclk2 = {
 	.name		= "pll0_sysclk2",
 	.parent		= &pll0_clk,
@@ -368,10 +375,19 @@ static struct clk sata_clk = {
 	.flags		= PSC_FORCE,
 };
 
+static struct clk dsp_clk = {
+	.name		= "dsp",
+	.parent		= &pll0_sysclk1,
+	.domain		= DAVINCI_GPSC_DSPDOMAIN,
+	.lpsc		= DA8XX_LPSC0_GEM,
+	.flags		= PSC_LRST | PSC_FORCE,
+};
+
 static struct clk_lookup da850_clks[] = {
 	CLK(NULL,		"ref",		&ref_clk),
 	CLK(NULL,		"pll0",		&pll0_clk),
 	CLK(NULL,		"pll0_aux",	&pll0_aux_clk),
+	CLK(NULL,		"pll0_sysclk1",	&pll0_sysclk1),
 	CLK(NULL,		"pll0_sysclk2",	&pll0_sysclk2),
 	CLK(NULL,		"pll0_sysclk3",	&pll0_sysclk3),
 	CLK(NULL,		"pll0_sysclk4",	&pll0_sysclk4),
@@ -413,6 +429,7 @@ static struct clk_lookup da850_clks[] = {
 	CLK("spi_davinci.1",	NULL,		&spi1_clk),
 	CLK("vpif",		NULL,		&vpif_clk),
 	CLK("ahci",		NULL,		&sata_clk),
+	CLK("davinci-rproc.0",	NULL,		&dsp_clk),
 	CLK(NULL,		NULL,		NULL),
 };
 

commit 2b8318881ddbcb67c5e8d2178b42284749442222
Merge: e81d372ff9f6 e7f5c9a16ea2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 15 13:03:48 2012 -0800

    Merge tag 'fbdev-for-3.8' of git://gitorious.org/linux-omap-dss2/linux
    
    Pull fbdev changes from Tomi Valkeinen:
     "OMAPDSS changes, including:
       - use dynanic debug prints
       - OMAP platform dependency removals
       - Creation of compat-layer, helping us to improve omapdrm
       - Misc cleanups, aiming to make omadss more in line with the upcoming
         common display framework
    
      Exynos DP changes for the 3.8 merge window:
       - Device Tree support for Samsung Exynos DP
       - SW Link training is cleaned up.
       - HPD interrupt is supported.
    
      Samsung Framebuffer changes for the 3.8 merge window:
       - The bit definitions of header file are updated.
       - Some minor typos are fixed.
       - Some minor bugs of s3c_fb_check_var() are fixed.
    
      FB related changes for SH Mobile, Freescale DIU
    
      Add support for the Solomon SSD1307 OLED Controller"
    
    * tag 'fbdev-for-3.8' of git://gitorious.org/linux-omap-dss2/linux: (191 commits)
      OMAPDSS: fix TV-out issue with DSI PLL
      Revert "OMAPFB: simplify locking"
      OMAPFB: remove silly loop in fb2display()
      OMAPFB: fix error handling in omapfb_find_best_mode()
      OMAPFB: use devm_kzalloc to allocate omapfb2_device
      OMAPDSS: DISPC: remove dispc fck uses
      OMAPDSS: DISPC: get dss clock rate from dss driver
      drivers/video/console/softcursor.c: remove redundant NULL check before kfree()
      drivers/video: add support for the Solomon SSD1307 OLED Controller
      OMAPDSS: use omapdss_compat_init() in other drivers
      OMAPDSS: export dispc functions
      OMAPDSS: export dss_feat functions
      OMAPDSS: export dss_mgr_ops functions
      OMAPDSS: separate compat files in the Makefile
      OMAPDSS: move display sysfs init to compat layer
      OMAPDSS: DPI: use dispc's check_timings
      OMAPDSS: DISPC: add dispc_ovl_check()
      OMAPDSS: move irq handling to dispc-compat
      OMAPDSS: move omap_dispc_wait_for_irq_interruptible_timeout to dispc-compat.c
      OMAPDSS: move blocking mgr enable/disable to compat layer
      ...
    
    Conflicts:
            arch/arm/mach-davinci/devices-da8xx.c
            arch/arm/plat-omap/common.c
            drivers/media/platform/omap/omap_vout.c

commit 81cec3c7566b8498f93d4f47225241875ab4968c
Author: Manjunathappa <prakash.pm@ti.com>
Date:   Tue Nov 20 18:11:01 2012 +0530

    video: da8xx-fb: clk_get on connection id fck
    
    do clk_get on connection id "fck" to support OMAP based
    platforms having multiple clocks for module. Without this
    driver change clk_get fails on am335x.
    
    This patch is based on the discussion in community
    http://marc.info/?l=linux-kernel&m=135166018907827&w=2
    
    Signed-off-by: Manjunathappa <prakash.pm@ti.com>
    Cc: Vaibhav Hiremath <hvaibhav@ti.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index b90c172d5541..fda70484815a 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -396,7 +396,7 @@ static struct clk_lookup da850_clks[] = {
 	CLK(NULL,		"rmii",		&rmii_clk),
 	CLK("davinci_emac.1",	NULL,		&emac_clk),
 	CLK("davinci-mcasp.0",	NULL,		&mcasp_clk),
-	CLK("da8xx_lcdc.0",	NULL,		&lcdc_clk),
+	CLK("da8xx_lcdc.0",	"fck",		&lcdc_clk),
 	CLK("davinci_mmc.0",	NULL,		&mmcsd0_clk),
 	CLK("davinci_mmc.1",	NULL,		&mmcsd1_clk),
 	CLK(NULL,		"aemif",	&aemif_clk),

commit 8e0d72d2c7a6955692ba0a21bbf5ca86e8061777
Author: Matt Porter <mporter@ti.com>
Date:   Mon Oct 8 09:53:08 2012 -0400

    ARM: davinci: da8xx: add DA850 PRUSS support
    
    Adds PRUSS clock support and registration helper for the
    uio_pruss device.
    
    Signed-off-by: Matt Porter <mporter@ti.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 41d2cabbcf33..68c5fe01857c 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -212,6 +212,12 @@ static struct clk tptc2_clk = {
 	.flags		= ALWAYS_ENABLED,
 };
 
+static struct clk pruss_clk = {
+	.name		= "pruss",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC0_PRUSS,
+};
+
 static struct clk uart0_clk = {
 	.name		= "uart0",
 	.parent		= &pll0_sysclk2,
@@ -385,6 +391,7 @@ static struct clk_lookup da850_clks[] = {
 	CLK(NULL,		"tptc1",	&tptc1_clk),
 	CLK(NULL,		"tpcc1",	&tpcc1_clk),
 	CLK(NULL,		"tptc2",	&tptc2_clk),
+	CLK("pruss_uio",	"pruss",	&pruss_clk),
 	CLK(NULL,		"uart0",	&uart0_clk),
 	CLK(NULL,		"uart1",	&uart1_clk),
 	CLK(NULL,		"uart2",	&uart2_clk),

commit c94472d4ad11c5b7d8cd527d136c198269d390fc
Author: Subhasish Ghosh <subhasish@mistralsolutions.com>
Date:   Fri Oct 5 13:04:42 2012 -0400

    ARM: davinci: da850: changed SRAM allocator to shared ram.
    
    This patch modifies the sram allocator to allocate memory
    from the DA8XX shared RAM.
    
    Regression tested suspend/resume on AM180x EVM.
    
    Signed-off-by: Subhasish Ghosh <subhasish@mistralsolutions.com>
    [rebased onto consolidated SRAM patches]
    Signed-off-by: Ben Gardiner <bengardiner@nanometrics.ca>
    [rebased to mainline as consolidated SRAM patches were dropped]
    Signed-off-by: Matt Porter <mporter@ti.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index ffc84f5e1aa2..41d2cabbcf33 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1233,8 +1233,8 @@ static struct davinci_soc_info davinci_soc_info_da850 = {
 	.gpio_irq		= IRQ_DA8XX_GPIO0,
 	.serial_dev		= &da8xx_serial_device,
 	.emac_pdata		= &da8xx_emac_pdata,
-	.sram_dma		= DA8XX_ARM_RAM_BASE,
-	.sram_len		= SZ_8K,
+	.sram_dma		= DA8XX_SHARED_RAM_BASE,
+	.sram_len		= SZ_128K,
 };
 
 void __init da850_init(void)

commit 626863a3f32f0baaf55a1d18b8d4fbb937700dda
Author: Ben Gardiner <bengardiner@nanometrics.ca>
Date:   Fri Oct 5 13:04:41 2012 -0400

    ARM: davinci: sram: switch from iotable to ioremapped regions
    
    The current davinci init sets up SRAM in iotables. There has been
    an observed failure to boot a da850 with 128K specified in the
    iotable.
    
    Make the davinci sram allocator do an ioremap of the region
    specified by the entries in davinci_soc_info before registering
    with gen_pool_add_virt(). Remove all iotable SRAM mappings and
    SRAM_VIRT.
    
    Regression tested suspend/resume on AM180x EVM.
    
    Signed-off-by: Ben Gardiner <bengardiner@nanometrics.ca>
    Signed-off-by: Matt Porter <mporter@ti.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index b90c172d5541..ffc84f5e1aa2 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -781,12 +781,6 @@ static struct map_desc da850_io_desc[] = {
 		.length		= DA8XX_CP_INTC_SIZE,
 		.type		= MT_DEVICE
 	},
-	{
-		.virtual	= SRAM_VIRT,
-		.pfn		= __phys_to_pfn(DA8XX_ARM_RAM_BASE),
-		.length		= SZ_8K,
-		.type		= MT_DEVICE
-	},
 };
 
 static u32 da850_psc_bases[] = { DA8XX_PSC0_BASE, DA8XX_PSC1_BASE };

commit bf3b202b41999f88f091632f13842b7234bd58b7
Merge: 782cd9ee985b 1fdead8ad31d
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Oct 11 15:07:19 2012 -0300

    Merge branch 'staging/for_v3.7' into v4l_for_linus
    
    Applied on the top of changeset 782cd9e, as some of those patches
    depend on some fixes that went via -arm tree.
    
    * staging/for_v3.7: (109 commits)
      [media] m5mols: Add missing #include <linux/sizes.h>
      [media] stk1160: Add support for S-Video input
      Revert "[media] omap3isp: Replace cpu_is_omap3630() with ISP revision check"
      [media]  dvb: LNA implementation changes
      [media] v4l2-ioctl: fix W=1 warnings
      [media] v4l2-ioctl: add blocks check for VIDIOC_SUBDEV_G/S_EDID
      [media] omap3isp: Fix compilation error in ispreg.h
      [media] rc-msi-digivox-ii: Add full scan keycodes
      [media] cx25821: testing the wrong variable
      [media] tda18271-common: hold the I2C adapter during write transfers
      [media] ds3000: add module parameter to force firmware upload
      [media] drivers/media: Remove unnecessary semicolon
      [media] winbond: remove space from driver name
      [media] iguanair: cannot send data from the stack
      [media] omap3isp: Replace cpu_is_omap3630() with ISP revision check
      [media] dvb-usb: print small buffers via %*ph
      [media] uvc: Add return code check at vb2_queue_init()
      [media] em28xx: Replace memcpy with struct assignment
      [media] bt8xx: Add video4linux control V4L2_CID_COLOR_KILLER
      [media] mem2mem_testdev: Use devm_kzalloc() in probe
      ...

commit 0b33162ec5ce4316effd95374768b59dc6f63326
Merge: a4ee7770c4a0 45ef6ac6f5d4
Author: Olof Johansson <olof@lixom.net>
Date:   Sun Oct 7 07:22:32 2012 -0700

    Merge branch 'late/fixes' into fixes
    
    This is a series from Arnd that fixes a number of compiler warnings
    when building defconfigs on ARM.
    
    * late/fixes:
      ARM: footbridge: nw_gpio_lock is raw_spin_lock
      ARM: mv78xx0: correct addr_map_cfg __initdata annotation
      ARM: footbridge: remove RTC_IRQ definition
      ARM: soc: dependency warnings for errata
      ARM: ks8695: __arch_virt_to_dma type handling
      ARM: rpc: check device_register return code in ecard_probe
      ARM: davinci: don't mark da850_register_cpufreq as __init
      ARM: iop13xx: fix iq81340sc_atux_map_irq prototype
      ARM: iop13xx: mark iop13xx_scan_bus as __devinit
      ARM: mv78xx0: mark mv78xx0_timer_init as __init_refok
      ARM: s3c24xx: fix multiple section mismatch warnings
      ARM: at91: unused variable in at91_pm_verify_clocks
      ARM: at91: skip at91_io_desc definition for NOMMU
      ARM: pxa: work around duplicate definition of GPIO24_SSP1_SFRM
      ARM: pxa: remove sharpsl_fatal_check function
      ARM: pxa: define palmte2_pxa_keys conditionally
      ARM: pxa: Wunused-result warning in viper board file
      ARM: shark: fix shark_pci_init return code
    
    Fixed trivial conflicts in arch/arm/mach-at91/setup.c.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 5063557ac0e83a52182fd0d49e83cc770e52ccd1
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Apr 30 14:00:15 2012 +0000

    ARM: davinci: don't mark da850_register_cpufreq as __init
    
    The mityomapl138_cpufreq_init and read_factory_config function in
    board-mityomapl138.c are not __init functions and might be called
    at a later stage, so da850_register_cpufreq must not be __init either.
    
    Without this patch, building da8xx_omapl_defconfig results in:
    
    WARNING: arch/arm/mach-davinci/built-in.o(.text+0x2eb4): Section mismatch in reference from the function read_factory_config() to the function .init.text:da850_register_cpufreq()
    The function read_factory_config() references
    the function __init da850_register_cpufreq().
    This is often because read_factory_config lacks a __init
    annotation or the annotation of da850_register_cpufreq is wrong.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index b44dc844e15e..8329e5b81cf5 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -939,7 +939,7 @@ static struct platform_device da850_cpufreq_device = {
 
 unsigned int da850_max_speed = 300000;
 
-int __init da850_register_cpufreq(char *async_clk)
+int da850_register_cpufreq(char *async_clk)
 {
 	int i;
 

commit 154d54a8ce9953197a662ffd24f4bb6aaeb236f4
Author: Manjunath Hadli <manjunath.hadli@ti.com>
Date:   Mon Jan 23 06:17:24 2012 -0300

    [media] ARM: davinci: da850: Add SoC related definitions for VPIF
    
    Add clock, pin mux definitions and registration function for
    VPIF capture and display driver on DA850/OMAP-L138 SoC.
    
    Signed-off-by: Manjunath Hadli <manjunath.hadli@ti.com>
    Signed-off-by: Lad, Prabhakar <prabhakar.lad@ti.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index b44dc844e15e..20d16fff6efd 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -347,6 +347,13 @@ static struct clk spi1_clk = {
 	.flags		= DA850_CLK_ASYNC3,
 };
 
+static struct clk vpif_clk = {
+	.name		= "vpif",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA850_LPSC1_VPIF,
+	.gpsc		= 1,
+};
+
 static struct clk sata_clk = {
 	.name		= "sata",
 	.parent		= &pll0_sysclk2,
@@ -397,6 +404,7 @@ static struct clk_lookup da850_clks[] = {
 	CLK(NULL,		"usb20",	&usb20_clk),
 	CLK("spi_davinci.0",	NULL,		&spi0_clk),
 	CLK("spi_davinci.1",	NULL,		&spi1_clk),
+	CLK("vpif",		NULL,		&vpif_clk),
 	CLK("ahci",		NULL,		&sata_clk),
 	CLK(NULL,		NULL,		NULL),
 };
@@ -573,6 +581,46 @@ static const struct mux_config da850_pins[] = {
 	MUX_CFG(DA850, GPIO6_10,	13,	20,	15,	8,	false)
 	MUX_CFG(DA850, GPIO6_13,	13,	8,	15,	8,	false)
 	MUX_CFG(DA850, RTC_ALARM,	0,	28,	15,	2,	false)
+	/* VPIF Capture */
+	MUX_CFG(DA850, VPIF_DIN0,	15,	4,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DIN1,	15,	0,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DIN2,	14,	28,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DIN3,	14,	24,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DIN4,	14,	20,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DIN5,	14,	16,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DIN6,	14,	12,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DIN7,	14,	8,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DIN8,	16,	4,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DIN9,	16,	0,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DIN10,	15,	28,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DIN11,	15,	24,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DIN12,	15,	20,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DIN13,	15,	16,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DIN14,	15,	12,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DIN15,	15,	8,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_CLKIN0,	14,	0,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_CLKIN1,	14,	4,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_CLKIN2,	19,	8,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_CLKIN3,	19,	16,	15,	1,	false)
+	/* VPIF Display */
+	MUX_CFG(DA850, VPIF_DOUT0,	17,	4,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DOUT1,	17,	0,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DOUT2,	16,	28,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DOUT3,	16,	24,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DOUT4,	16,	20,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DOUT5,	16,	16,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DOUT6,	16,	12,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DOUT7,	16,	8,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DOUT8,	18,	4,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DOUT9,	18,	0,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DOUT10,	17,	28,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DOUT11,	17,	24,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DOUT12,	17,	20,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DOUT13,	17,	16,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DOUT14,	17,	12,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_DOUT15,	17,	8,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_CLKO2,	19,	12,	15,	1,	false)
+	MUX_CFG(DA850, VPIF_CLKO3,	19,	20,	15,	1,	false)
 #endif
 };
 
@@ -595,6 +643,26 @@ const short da850_lcdcntl_pins[] __initdata = {
 	-1
 };
 
+const short da850_vpif_capture_pins[] __initdata = {
+	DA850_VPIF_DIN0, DA850_VPIF_DIN1, DA850_VPIF_DIN2, DA850_VPIF_DIN3,
+	DA850_VPIF_DIN4, DA850_VPIF_DIN5, DA850_VPIF_DIN6, DA850_VPIF_DIN7,
+	DA850_VPIF_DIN8, DA850_VPIF_DIN9, DA850_VPIF_DIN10, DA850_VPIF_DIN11,
+	DA850_VPIF_DIN12, DA850_VPIF_DIN13, DA850_VPIF_DIN14, DA850_VPIF_DIN15,
+	DA850_VPIF_CLKIN0, DA850_VPIF_CLKIN1, DA850_VPIF_CLKIN2,
+	DA850_VPIF_CLKIN3,
+	-1
+};
+
+const short da850_vpif_display_pins[] __initdata = {
+	DA850_VPIF_DOUT0, DA850_VPIF_DOUT1, DA850_VPIF_DOUT2, DA850_VPIF_DOUT3,
+	DA850_VPIF_DOUT4, DA850_VPIF_DOUT5, DA850_VPIF_DOUT6, DA850_VPIF_DOUT7,
+	DA850_VPIF_DOUT8, DA850_VPIF_DOUT9, DA850_VPIF_DOUT10,
+	DA850_VPIF_DOUT11, DA850_VPIF_DOUT12, DA850_VPIF_DOUT13,
+	DA850_VPIF_DOUT14, DA850_VPIF_DOUT15, DA850_VPIF_CLKO2,
+	DA850_VPIF_CLKO3,
+	-1
+};
+
 /* FIQ are pri 0-1; otherwise 2-7, with 7 lowest priority */
 static u8 da850_default_priorities[DA850_N_CP_INTC_IRQ] = {
 	[IRQ_DA8XX_COMMTX]		= 7,
@@ -1064,6 +1132,90 @@ int __init da850_register_pm(struct platform_device *pdev)
 	return ret;
 }
 
+/* VPIF resource, platform data */
+static u64 da850_vpif_dma_mask = DMA_BIT_MASK(32);
+
+static struct resource da850_vpif_resource[] = {
+	{
+		.start = DA8XX_VPIF_BASE,
+		.end   = DA8XX_VPIF_BASE + 0xfff,
+		.flags = IORESOURCE_MEM,
+	}
+};
+
+static struct platform_device da850_vpif_dev = {
+	.name		= "vpif",
+	.id		= -1,
+	.dev		= {
+		.dma_mask		= &da850_vpif_dma_mask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+	.resource	= da850_vpif_resource,
+	.num_resources	= ARRAY_SIZE(da850_vpif_resource),
+};
+
+static struct resource da850_vpif_display_resource[] = {
+	{
+		.start = IRQ_DA850_VPIFINT,
+		.end   = IRQ_DA850_VPIFINT,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device da850_vpif_display_dev = {
+	.name		= "vpif_display",
+	.id		= -1,
+	.dev		= {
+		.dma_mask		= &da850_vpif_dma_mask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+	.resource       = da850_vpif_display_resource,
+	.num_resources  = ARRAY_SIZE(da850_vpif_display_resource),
+};
+
+static struct resource da850_vpif_capture_resource[] = {
+	{
+		.start = IRQ_DA850_VPIFINT,
+		.end   = IRQ_DA850_VPIFINT,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = IRQ_DA850_VPIFINT,
+		.end   = IRQ_DA850_VPIFINT,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device da850_vpif_capture_dev = {
+	.name		= "vpif_capture",
+	.id		= -1,
+	.dev		= {
+		.dma_mask		= &da850_vpif_dma_mask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+	.resource       = da850_vpif_capture_resource,
+	.num_resources  = ARRAY_SIZE(da850_vpif_capture_resource),
+};
+
+int __init da850_register_vpif(void)
+{
+	return platform_device_register(&da850_vpif_dev);
+}
+
+int __init da850_register_vpif_display(struct vpif_display_config
+						*display_config)
+{
+	da850_vpif_display_dev.dev.platform_data = display_config;
+	return platform_device_register(&da850_vpif_display_dev);
+}
+
+int __init da850_register_vpif_capture(struct vpif_capture_config
+							*capture_config)
+{
+	da850_vpif_capture_dev.dev.platform_data = capture_config;
+	return platform_device_register(&da850_vpif_capture_dev);
+}
+
 static struct davinci_soc_info davinci_soc_info_da850 = {
 	.io_desc		= da850_io_desc,
 	.io_desc_num		= ARRAY_SIZE(da850_io_desc),

commit bcad6dc3634a861c8c5e1f7261c02646a9010014
Author: Andi Kleen <ak@linux.intel.com>
Date:   Thu Oct 4 17:11:28 2012 -0700

    sections: fix section conflicts in arch/arm/
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index b44dc844e15e..6676dee7104e 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -576,17 +576,17 @@ static const struct mux_config da850_pins[] = {
 #endif
 };
 
-const short da850_i2c0_pins[] __initdata = {
+const short da850_i2c0_pins[] __initconst = {
 	DA850_I2C0_SDA, DA850_I2C0_SCL,
 	-1
 };
 
-const short da850_i2c1_pins[] __initdata = {
+const short da850_i2c1_pins[] __initconst = {
 	DA850_I2C1_SCL, DA850_I2C1_SDA,
 	-1
 };
 
-const short da850_lcdcntl_pins[] __initdata = {
+const short da850_lcdcntl_pins[] __initconst = {
 	DA850_LCD_D_0, DA850_LCD_D_1, DA850_LCD_D_2, DA850_LCD_D_3,
 	DA850_LCD_D_4, DA850_LCD_D_5, DA850_LCD_D_6, DA850_LCD_D_7,
 	DA850_LCD_D_8, DA850_LCD_D_9, DA850_LCD_D_10, DA850_LCD_D_11,

commit 30c766bdeccf945615097ca185326c1d7199f023
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Mar 7 23:03:56 2012 +0100

    ARM: davinci: DA850: move da850_register_pm to .init.text
    
    All callers (board-mityomapl138.c and board-da850-evm.c) use it in
    __init functions only.
    
    This fixes:
    
            WARNING: vmlinux.o(.text+0xd664): Section mismatch in reference from the function da850_register_pm() to the function .init.text:da8xx_get_mem_ctlr()
            The function da850_register_pm() references
            the function __init da8xx_get_mem_ctlr().
            This is often because da850_register_pm lacks a __init
            annotation or the annotation of da8xx_get_mem_ctlr is wrong.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 992c4c410185..b44dc844e15e 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1026,7 +1026,7 @@ static int da850_round_armrate(struct clk *clk, unsigned long rate)
 }
 #endif
 
-int da850_register_pm(struct platform_device *pdev)
+int __init da850_register_pm(struct platform_device *pdev)
 {
 	int ret;
 	struct davinci_pm_config *pdata = pdev->dev.platform_data;

commit 7c655099b25c889c1268dba894fbc5d515097752
Author: Bas van den Berg <b.van.den.berg.nl@gmail.com>
Date:   Mon Jan 16 07:46:02 2012 +0100

    ARM: davinci: DA850: remove non-existing pll1_sysclk4-7 clocks
    
    DA850: sysclk4-7 only exist for pll0. for pll1 sysclk1-3 exist.
    
    Remove the non-existing clocks.
    
    Signed-off-by: Bas van den Berg <b.van.den.berg.nl@gmail.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 0ed7fdb64efb..992c4c410185 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -153,34 +153,6 @@ static struct clk pll1_sysclk3 = {
 	.div_reg	= PLLDIV3,
 };
 
-static struct clk pll1_sysclk4 = {
-	.name		= "pll1_sysclk4",
-	.parent		= &pll1_clk,
-	.flags		= CLK_PLL,
-	.div_reg	= PLLDIV4,
-};
-
-static struct clk pll1_sysclk5 = {
-	.name		= "pll1_sysclk5",
-	.parent		= &pll1_clk,
-	.flags		= CLK_PLL,
-	.div_reg	= PLLDIV5,
-};
-
-static struct clk pll1_sysclk6 = {
-	.name		= "pll0_sysclk6",
-	.parent		= &pll0_clk,
-	.flags		= CLK_PLL,
-	.div_reg	= PLLDIV6,
-};
-
-static struct clk pll1_sysclk7 = {
-	.name		= "pll1_sysclk7",
-	.parent		= &pll1_clk,
-	.flags		= CLK_PLL,
-	.div_reg	= PLLDIV7,
-};
-
 static struct clk i2c0_clk = {
 	.name		= "i2c0",
 	.parent		= &pll0_aux_clk,
@@ -397,10 +369,6 @@ static struct clk_lookup da850_clks[] = {
 	CLK(NULL,		"pll1_aux",	&pll1_aux_clk),
 	CLK(NULL,		"pll1_sysclk2",	&pll1_sysclk2),
 	CLK(NULL,		"pll1_sysclk3",	&pll1_sysclk3),
-	CLK(NULL,		"pll1_sysclk4",	&pll1_sysclk4),
-	CLK(NULL,		"pll1_sysclk5",	&pll1_sysclk5),
-	CLK(NULL,		"pll1_sysclk6",	&pll1_sysclk6),
-	CLK(NULL,		"pll1_sysclk7",	&pll1_sysclk7),
 	CLK("i2c_davinci.1",	NULL,		&i2c0_clk),
 	CLK(NULL,		"timer0",	&timerp64_0_clk),
 	CLK("watchdog",		NULL,		&timerp64_1_clk),

commit c6121ddd1f75278ab77504af2914d07831558672
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Mon Dec 5 11:29:46 2011 +0100

    ARM: 7190/1: restart: davinci: use new restart hook
    
    Rather than using DaVinci specific davinci_soc_info based
    restart hook, use the restart hook available in the machine
    descriptor instead.
    
    Tested on DM365 and AM18x EVMs.
    
    v2:
    Changed to use restart hook in machine descriptor
    per Russell's comment.
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index b047f8702278..0ed7fdb64efb 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1121,7 +1121,6 @@ static struct davinci_soc_info davinci_soc_info_da850 = {
 	.emac_pdata		= &da8xx_emac_pdata,
 	.sram_dma		= DA8XX_ARM_RAM_BASE,
 	.sram_len		= SZ_8K,
-	.reset_device		= &da8xx_wdt_device,
 };
 
 void __init da850_init(void)

commit efa62e1355f0495f37f1296754b8880947c8da72
Merge: 107532920226 f55be1bf52aa
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Oct 31 23:46:42 2011 +0100

    Merge branch 'depends/rmk/gpio' into next/devel
    
    Conflicts:
            arch/arm/mach-mxs/include/mach/gpio.h
            arch/arm/plat-mxc/include/mach/gpio.h
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 6836989c35b285b566b932fdbb8402edf8fcc887
Author: Ido Yariv <ido@wizery.com>
Date:   Sun Jul 10 16:14:38 2011 +0300

    ARM: davinci: DA850: Add GPIO pinmux configuration for wl1271
    
    The wl1271 daughter board makes use of a few GPIOs:
    GPIO6_9 is used for powering down/up the WLAN functionality.
    GPIO6_10 is used as an input IRQ line from the WLAN chip.
    
    Add the required pinmux configuration for these GPIOs.
    
    Signed-off-by: Ido Yariv <ido@wizery.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 87cdce64fba7..0cf0d8845422 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -600,6 +600,8 @@ static const struct mux_config da850_pins[] = {
 	MUX_CFG(DA850, GPIO3_13,	7,	8,	15,	8,	false)
 	MUX_CFG(DA850, GPIO4_0,		10,	28,	15,	8,	false)
 	MUX_CFG(DA850, GPIO4_1,		10,	24,	15,	8,	false)
+	MUX_CFG(DA850, GPIO6_9,		13,	24,	15,	8,	false)
+	MUX_CFG(DA850, GPIO6_10,	13,	20,	15,	8,	false)
 	MUX_CFG(DA850, GPIO6_13,	13,	8,	15,	8,	false)
 	MUX_CFG(DA850, RTC_ALARM,	0,	28,	15,	2,	false)
 #endif

commit 5c4d11b477f66080c9305c91e5d387c796be411c
Author: Ido Yariv <ido@wizery.com>
Date:   Sun Jul 10 16:14:37 2011 +0300

    ARM: davinci: DA850: Add MMC/SD1 pinmux configuration
    
    AM18x has two MMC slots. Add the required pinmux configuration for the
    second slot.
    
    Signed-off-by: Ido Yariv <ido@wizery.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 935dbed5c541..87cdce64fba7 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -535,6 +535,13 @@ static const struct mux_config da850_pins[] = {
 	MUX_CFG(DA850, MMCSD0_DAT_3,	10,	20,	15,	2,	false)
 	MUX_CFG(DA850, MMCSD0_CLK,	10,	0,	15,	2,	false)
 	MUX_CFG(DA850, MMCSD0_CMD,	10,	4,	15,	2,	false)
+	/* MMC/SD1 function */
+	MUX_CFG(DA850, MMCSD1_DAT_0,	18,	8,	15,	2,	false)
+	MUX_CFG(DA850, MMCSD1_DAT_1,	19,	16,	15,	2,	false)
+	MUX_CFG(DA850, MMCSD1_DAT_2,	19,	12,	15,	2,	false)
+	MUX_CFG(DA850, MMCSD1_DAT_3,	19,	8,	15,	2,	false)
+	MUX_CFG(DA850, MMCSD1_CLK,	18,	12,	15,	2,	false)
+	MUX_CFG(DA850, MMCSD1_CMD,	18,	16,	15,	2,	false)
 	/* EMIF2.5/EMIFA function */
 	MUX_CFG(DA850, EMA_D_7,		9,	0,	15,	1,	false)
 	MUX_CFG(DA850, EMA_D_6,		9,	4,	15,	1,	false)

commit 5f3fcf9649dbb010ccac41259d04147775ec8fc2
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Aug 22 08:40:38 2011 +0100

    ARM: 7040/1: mach-davinci: break out GPIO driver specifics
    
    The <mach/gpio.h> file is included from upper directories
    and deal with generic GPIO and gpiolib stuff. Break out the
    platform and driver specific defines and functions into its own
    header file.
    
    Cc: Sekhar Nori <nsekhar@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 71a4aa263fb0..4aae01576aab 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -28,6 +28,7 @@
 #include <mach/da8xx.h>
 #include <mach/cpufreq.h>
 #include <mach/pm.h>
+#include <mach/gpio-davinci.h>
 
 #include "clock.h"
 #include "mux.h"

commit 2f8163baada3dbd0ce891c35bc59ae46e773487a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jul 26 10:53:52 2011 +0100

    ARM: gpio: convert includes of mach/gpio.h and asm/gpio.h to linux/gpio.h
    
    Convert arch/arm includes of mach/gpio.h and asm/gpio.h to linux/gpio.h
    before we start consolidating the individual platform implementations
    of the gpio header files.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 935dbed5c541..71a4aa263fb0 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -11,6 +11,7 @@
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
  */
+#include <linux/gpio.h>
 #include <linux/init.h>
 #include <linux/clk.h>
 #include <linux/platform_device.h>
@@ -27,7 +28,6 @@
 #include <mach/da8xx.h>
 #include <mach/cpufreq.h>
 #include <mach/pm.h>
-#include <mach/gpio.h>
 
 #include "clock.h"
 #include "mux.h"

commit cbb2c9617ae80c99a7b290dbe5cf48ebf9a36ad9
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Wed Jul 6 06:01:23 2011 +0000

    davinci: da850: add support for SATA interface
    
    Add support for SATA controller on the
    DA850/OMAP-L138/AM18x devices.
    
    The patch adds the necessary clocks, platform
    resources and a routine to initialize the SATA
    controller.
    
    The PHY configuration in this patch is
    courtesy the work done by Zegeye Alemu,
    Swaminathan and Mansoor Ahamed from TI.
    
    While testing this patch, enable port multiplier
    support iff you are actually using one. The
    reasons of this behaviour are discussed
    here: http://patchwork.ozlabs.org/patch/78163/
    
    ChangeLog:
    v3:
    Removed fields which were being initialized
    to zero in PHY configuration. Moved SATA base
    address definition to the top of the file to
    make it inline with what is done for the rest
    of the modules.
    v2:
    Addressed comments from Sergei. Removed unnecessary
    braces and removed unnecessary else after goto.
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 4e22b8da3493..935dbed5c541 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -374,6 +374,14 @@ static struct clk spi1_clk = {
 	.flags		= DA850_CLK_ASYNC3,
 };
 
+static struct clk sata_clk = {
+	.name		= "sata",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA850_LPSC1_SATA,
+	.gpsc		= 1,
+	.flags		= PSC_FORCE,
+};
+
 static struct clk_lookup da850_clks[] = {
 	CLK(NULL,		"ref",		&ref_clk),
 	CLK(NULL,		"pll0",		&pll0_clk),
@@ -420,6 +428,7 @@ static struct clk_lookup da850_clks[] = {
 	CLK(NULL,		"usb20",	&usb20_clk),
 	CLK("spi_davinci.0",	NULL,		&spi0_clk),
 	CLK("spi_davinci.1",	NULL,		&spi1_clk),
+	CLK("ahci",		NULL,		&sata_clk),
 	CLK(NULL,		NULL,		NULL),
 };
 

commit 8d54297b90831b6e87e62ad910f833b8666094c8
Author: Christian Riesch <christian.riesch@omicron.at>
Date:   Tue Jun 28 15:10:51 2011 +0000

    davinci: da850: add a .set_rate method to ref_clk
    
    This patch allows setting the input clock frequency of the SoC from
    the board specific code using the davinci_set_refclk_rate function.
    
    Suggested-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Christian Riesch <christian.riesch@omicron.at>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 133aac405853..4e22b8da3493 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -58,6 +58,7 @@ static struct pll_data pll0_data = {
 static struct clk ref_clk = {
 	.name		= "ref_clk",
 	.rate		= DA850_REF_FREQ,
+	.set_rate	= davinci_simple_set_rate,
 };
 
 static struct clk pll0_clk = {

commit e0c199d0989e2f9fa2683e817624779f55abfa7f
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Wed Apr 6 17:26:06 2011 +0000

    DA8xx: kill duplicate #define DA8XX_PLL1_BASE
    
    Commit 044ca01521d077a35b46a445b02b93f413109a4b (davinci: da850/omap-l138: add
    support for SoC suspend) introduced DA8XX_PLL1_BASE despite PLL1 exists only on
    DA850/OMAP-L138 and da850.c even already #define'd DA850_PLL1_BASE. Kill the
    duplicate macro, renaming an existing reference to it...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index b95b9196deed..133aac405853 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1055,7 +1055,7 @@ int da850_register_pm(struct platform_device *pdev)
 	if (!pdata->cpupll_reg_base)
 		return -ENOMEM;
 
-	pdata->ddrpll_reg_base = ioremap(DA8XX_PLL1_BASE, SZ_4K);
+	pdata->ddrpll_reg_base = ioremap(DA850_PLL1_BASE, SZ_4K);
 	if (!pdata->ddrpll_reg_base) {
 		ret = -ENOMEM;
 		goto no_ddrpll_mem;

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 68fe4c289d77..b95b9196deed 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1123,7 +1123,7 @@ void __init da850_init(void)
 	 * This helps keeping the peripherals on this domain insulated
 	 * from CPU frequency changes caused by DVFS. The firmware sets
 	 * both PLL0 and PLL1 to the same frequency so, there should not
-	 * be any noticible change even in non-DVFS use cases.
+	 * be any noticeable change even in non-DVFS use cases.
 	 */
 	da850_set_async3_src(1);
 

commit 12d35cf374a2ca116481d2bc2dcf6f89854646dd
Author: Michael Williamson <michael.williamson@criticallink.com>
Date:   Tue Feb 22 13:37:00 2011 +0000

    davinci: da850: add spi device clock definitions
    
    Add spi clock information for da850.
    
    Signed-off-by: Michael Williamson <michael.williamson@criticallink.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 3443d9725265..68fe4c289d77 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -359,6 +359,20 @@ static struct clk usb20_clk = {
 	.gpsc		= 1,
 };
 
+static struct clk spi0_clk = {
+	.name		= "spi0",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC0_SPI0,
+};
+
+static struct clk spi1_clk = {
+	.name		= "spi1",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC1_SPI1,
+	.gpsc		= 1,
+	.flags		= DA850_CLK_ASYNC3,
+};
+
 static struct clk_lookup da850_clks[] = {
 	CLK(NULL,		"ref",		&ref_clk),
 	CLK(NULL,		"pll0",		&pll0_clk),
@@ -403,6 +417,8 @@ static struct clk_lookup da850_clks[] = {
 	CLK(NULL,		"aemif",	&aemif_clk),
 	CLK(NULL,		"usb11",	&usb11_clk),
 	CLK(NULL,		"usb20",	&usb20_clk),
+	CLK("spi_davinci.0",	NULL,		&spi0_clk),
+	CLK("spi_davinci.1",	NULL,		&spi1_clk),
 	CLK(NULL,		NULL,		NULL),
 };
 

commit a42f18c96da2220eaad603a7586d43cdd12d9f9f
Author: Michael Williamson <michael.williamson@criticallink.com>
Date:   Tue Jan 18 12:21:46 2011 -0500

    davinci: da850: remove unused uart pinmux arrays.
    
    The da850 uart pinmux arrays are not used.  Remove them.
    
    Signed-off-by: Michael Williamson <michael.williamson@criticallink.com>
    Tested-by: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 9fd497afd4a5..3443d9725265 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -572,21 +572,6 @@ static const struct mux_config da850_pins[] = {
 #endif
 };
 
-const short da850_uart0_pins[] __initdata = {
-	DA850_NUART0_CTS, DA850_NUART0_RTS, DA850_UART0_RXD, DA850_UART0_TXD,
-	-1
-};
-
-const short da850_uart1_pins[] __initdata = {
-	DA850_UART1_RXD, DA850_UART1_TXD,
-	-1
-};
-
-const short da850_uart2_pins[] __initdata = {
-	DA850_UART2_RXD, DA850_UART2_TXD,
-	-1
-};
-
 const short da850_i2c0_pins[] __initdata = {
 	DA850_I2C0_SDA, DA850_I2C0_SCL,
 	-1

commit 5a0d80ea806f89c078dd4b244479080cfe73d2ae
Author: Michael Williamson <michael.williamson@criticallink.com>
Date:   Tue Jan 18 12:21:45 2011 -0500

    davinci: da850: move da850_evm specific mmcsd pinmux array to board file.
    
    The da850_mmcsd0_pins pinmux array contains pins that are specific to the
    da850 evm board (the write protect and card detect GPIO pins).  Move
    the array to the board file.
    
    Signed-off-by: Michael Williamson <michael.williamson@criticallink.com>
    Tested-by: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 9cb769c2890b..9fd497afd4a5 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -606,13 +606,6 @@ const short da850_lcdcntl_pins[] __initdata = {
 	-1
 };
 
-const short da850_mmcsd0_pins[] __initdata = {
-	DA850_MMCSD0_DAT_0, DA850_MMCSD0_DAT_1, DA850_MMCSD0_DAT_2,
-	DA850_MMCSD0_DAT_3, DA850_MMCSD0_CLK, DA850_MMCSD0_CMD,
-	DA850_GPIO4_0, DA850_GPIO4_1,
-	-1
-};
-
 /* FIQ are pri 0-1; otherwise 2-7, with 7 lowest priority */
 static u8 da850_default_priorities[DA850_N_CP_INTC_IRQ] = {
 	[IRQ_DA8XX_COMMTX]		= 7,

commit c840fc745f6ec8a3b7062d72de193ab9c397d725
Author: Michael Williamson <michael.williamson@criticallink.com>
Date:   Tue Jan 18 12:21:44 2011 -0500

    davinci: da850: move da850_evm specific mcasp pins to board file.
    
    The da850_mcasp_pins pinmux array is specific to the da850_evm, and is
    not generic.  Move the array to the board file, make it static initdata,
    and rename it accordingly.
    
    Signed-off-by: Michael Williamson <michael.williamson@criticallink.com>
    Tested-by: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 1cf3d7fc4700..9cb769c2890b 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -597,13 +597,6 @@ const short da850_i2c1_pins[] __initdata = {
 	-1
 };
 
-const short da850_mcasp_pins[] __initdata = {
-	DA850_AHCLKX, DA850_ACLKX, DA850_AFSX,
-	DA850_AHCLKR, DA850_ACLKR, DA850_AFSR, DA850_AMUTE,
-	DA850_AXR_11, DA850_AXR_12,
-	-1
-};
-
 const short da850_lcdcntl_pins[] __initdata = {
 	DA850_LCD_D_0, DA850_LCD_D_1, DA850_LCD_D_2, DA850_LCD_D_3,
 	DA850_LCD_D_4, DA850_LCD_D_5, DA850_LCD_D_6, DA850_LCD_D_7,

commit 0b642b6a86771f4f82abe6608fc61e050ea03f33
Author: Michael Williamson <michael.williamson@criticallink.com>
Date:   Tue Jan 18 12:21:43 2011 -0500

    davinci: da850: remove unused emif pinmux array
    
    The da850_emif25_pins pinmux array is not used.  Remove it.
    
    Signed-off-by: Michael Williamson <michael.williamson@criticallink.com>
    Tested-by: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 7031a6ec4cd6..1cf3d7fc4700 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -620,22 +620,6 @@ const short da850_mmcsd0_pins[] __initdata = {
 	-1
 };
 
-const short da850_emif25_pins[] __initdata = {
-	DA850_EMA_BA_1, DA850_EMA_CLK, DA850_EMA_WAIT_1, DA850_NEMA_CS_2,
-	DA850_NEMA_CS_3, DA850_NEMA_CS_4, DA850_NEMA_WE, DA850_NEMA_OE,
-	DA850_EMA_D_0, DA850_EMA_D_1, DA850_EMA_D_2, DA850_EMA_D_3,
-	DA850_EMA_D_4, DA850_EMA_D_5, DA850_EMA_D_6, DA850_EMA_D_7,
-	DA850_EMA_D_8, DA850_EMA_D_9, DA850_EMA_D_10, DA850_EMA_D_11,
-	DA850_EMA_D_12, DA850_EMA_D_13, DA850_EMA_D_14, DA850_EMA_D_15,
-	DA850_EMA_A_0, DA850_EMA_A_1, DA850_EMA_A_2, DA850_EMA_A_3,
-	DA850_EMA_A_4, DA850_EMA_A_5, DA850_EMA_A_6, DA850_EMA_A_7,
-	DA850_EMA_A_8, DA850_EMA_A_9, DA850_EMA_A_10, DA850_EMA_A_11,
-	DA850_EMA_A_12, DA850_EMA_A_13, DA850_EMA_A_14, DA850_EMA_A_15,
-	DA850_EMA_A_16, DA850_EMA_A_17, DA850_EMA_A_18, DA850_EMA_A_19,
-	DA850_EMA_A_20, DA850_EMA_A_21, DA850_EMA_A_22, DA850_EMA_A_23,
-	-1
-};
-
 /* FIQ are pri 0-1; otherwise 2-7, with 7 lowest priority */
 static u8 da850_default_priorities[DA850_N_CP_INTC_IRQ] = {
 	[IRQ_DA8XX_COMMTX]		= 7,

commit 8ae7545aae15b55afe24ecebb234484883646410
Author: Michael Williamson <michael.williamson@criticallink.com>
Date:   Tue Jan 18 12:21:42 2011 -0500

    davinci: da850: remove unused pinmux array
    
    The da850_cpgmac_pins pinmux array is not used.  Remove it.
    
    Signed-off-by: Michael Williamson <michael.williamson@criticallink.com>
    Tested-by: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 703e81f8b24c..7031a6ec4cd6 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -597,17 +597,6 @@ const short da850_i2c1_pins[] __initdata = {
 	-1
 };
 
-const short da850_cpgmac_pins[] __initdata = {
-	DA850_MII_TXEN, DA850_MII_TXCLK, DA850_MII_COL, DA850_MII_TXD_3,
-	DA850_MII_TXD_2, DA850_MII_TXD_1, DA850_MII_TXD_0, DA850_MII_RXER,
-	DA850_MII_CRS, DA850_MII_RXCLK, DA850_MII_RXDV, DA850_MII_RXD_3,
-	DA850_MII_RXD_2, DA850_MII_RXD_1, DA850_MII_RXD_0, DA850_MDIO_CLK,
-	DA850_MDIO_D, DA850_RMII_TXD_0, DA850_RMII_TXD_1, DA850_RMII_TXEN,
-	DA850_RMII_CRS_DV, DA850_RMII_RXD_0, DA850_RMII_RXD_1, DA850_RMII_RXER,
-	DA850_RMII_MHZ_50_CLK,
-	-1
-};
-
 const short da850_mcasp_pins[] __initdata = {
 	DA850_AHCLKX, DA850_ACLKX, DA850_AFSX,
 	DA850_AHCLKR, DA850_ACLKR, DA850_AFSR, DA850_AMUTE,

commit cbb691fb89ae01fde4ccce3b7351a0fa9fe1a47b
Author: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
Date:   Mon Jan 3 08:03:27 2011 -0500

    davinci: Add additional JTAG code for AM-1808 and OMAP-L138 Rev 2.0 SoCs
    
    From: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
    
    The JTAG variant code for Rev-2.0 silicon of the OMAP-L138 has changed.
    In addition, the variant code for the AM-1808 SoC appears to match
    the Rev-2.0 code for the OMAP-L138.  Add an additional entry to support
    these chips.
    
    This patch is originally from a patch on the arago project, here:
    http://arago-project.org/git/projects/?p=linux-omapl1.git;a=commit;h=6157618435e313a444cdf059702bd34036a6e2b7
    
    Further information related to the need for this patch can be located at
    http://e2e.ti.com/support/embedded/f/354/p/67290/248486.aspx
    http://linux.davincidsp.com/pipermail/davinci-linux-open-source/2010-November/021224.html
    
    This patch was tested using an AM-1808 SoC on a MityARM-1808 SoM card.  It
    was also tested using a Rev 1.0 silicon OMAP-L138 on a MityDSP-L138F card.
    
    Signed-off-by: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
    Signed-off-by: Michael Williamson <michael.williamson@criticallink.com>
    Tested-by: Michael Williamson <michael.williamson@criticallink.com>
    Reported-by: Nicolas Luna <luna.id@gmail.com>
    Reviewed-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index c7417a4caeaf..703e81f8b24c 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -784,6 +784,13 @@ static struct davinci_id da850_ids[] = {
 		.cpu_id		= DAVINCI_CPU_ID_DA850,
 		.name		= "da850/omap-l138",
 	},
+	{
+		.variant	= 0x1,
+		.part_no	= 0xb7d1,
+		.manufacturer	= 0x017,	/* 0x02f >> 1 */
+		.cpu_id		= DAVINCI_CPU_ID_DA850,
+		.name		= "da850/omap-l138/am18x",
+	},
 };
 
 static struct davinci_timer_instance da850_timer_instance[4] = {

commit 5efe330ac19ff63c257db1ab120234cca01a8079
Author: Victor Rodriguez <vm.rod25@gmail.com>
Date:   Mon Dec 27 16:43:12 2010 -0600

    davinci: USB clocks for Omapl138-Hawkboard
    
    This patch adds USB1.1 and USB2.0 clocks for the Hawkboard-L138 system
    
    Signed-off-by: Victor Rodriguez <vm.rod25@gmail.com>
    Tested-by: Rene Gonzalez <renegs.2378@gmail.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index f55a60f34266..c7417a4caeaf 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -345,6 +345,20 @@ static struct clk aemif_clk = {
 	.flags		= ALWAYS_ENABLED,
 };
 
+static struct clk usb11_clk = {
+	.name		= "usb11",
+	.parent		= &pll0_sysclk4,
+	.lpsc		= DA8XX_LPSC1_USB11,
+	.gpsc		= 1,
+};
+
+static struct clk usb20_clk = {
+	.name		= "usb20",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC1_USB20,
+	.gpsc		= 1,
+};
+
 static struct clk_lookup da850_clks[] = {
 	CLK(NULL,		"ref",		&ref_clk),
 	CLK(NULL,		"pll0",		&pll0_clk),
@@ -387,6 +401,8 @@ static struct clk_lookup da850_clks[] = {
 	CLK("davinci_mmc.0",	NULL,		&mmcsd0_clk),
 	CLK("davinci_mmc.1",	NULL,		&mmcsd1_clk),
 	CLK(NULL,		"aemif",	&aemif_clk),
+	CLK(NULL,		"usb11",	&usb11_clk),
+	CLK(NULL,		"usb20",	&usb20_clk),
 	CLK(NULL,		NULL,		NULL),
 };
 

commit fe358d6a049dcd7cd52b0eb6ae5c8bddf223d41b
Author: Victor Rodriguez <vm.rod25@gmail.com>
Date:   Mon Dec 27 16:43:10 2010 -0600

    davinci: MMC/SD and USB-OHCI configuration for Omapl138-Hawkboard
    
    This patch defines Pin Mux configuration to enable MMC/SD
    and USB-OHCI on the Hawkboard-L138 system
    
    Signed-off-by: Victor Rodriguez <vm.rod25@gmail.com>
    Tested-by: Rene Gonzalez <renegs.2378@gmail.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 78b5ae29ae40..f55a60f34266 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -543,11 +543,15 @@ static const struct mux_config da850_pins[] = {
 	MUX_CFG(DA850, EMA_WAIT_1,	6,	24,	15,	1,	false)
 	MUX_CFG(DA850, NEMA_CS_2,	7,	0,	15,	1,	false)
 	/* GPIO function */
+	MUX_CFG(DA850, GPIO2_4,		6,	12,	15,	8,	false)
 	MUX_CFG(DA850, GPIO2_6,		6,	4,	15,	8,	false)
 	MUX_CFG(DA850, GPIO2_8,		5,	28,	15,	8,	false)
 	MUX_CFG(DA850, GPIO2_15,	5,	0,	15,	8,	false)
+	MUX_CFG(DA850, GPIO3_12,	7,	12,	15,	8,	false)
+	MUX_CFG(DA850, GPIO3_13,	7,	8,	15,	8,	false)
 	MUX_CFG(DA850, GPIO4_0,		10,	28,	15,	8,	false)
 	MUX_CFG(DA850, GPIO4_1,		10,	24,	15,	8,	false)
+	MUX_CFG(DA850, GPIO6_13,	13,	8,	15,	8,	false)
 	MUX_CFG(DA850, RTC_ALARM,	0,	28,	15,	2,	false)
 #endif
 };

commit 39e145500458bd68d1d33adfa256886900b1597b
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Mon Dec 20 21:31:33 2010 +0530

    davinci: am18x/da850/omap-l138: add support for higher speed grades
    
    AM18x/DA850/OMAP-L138 SoCs have variants that can operate
    at a maximum of 456 MHz at 1.3V operating point. Also the
    1.2V operating point has a variant that can support a maximum
    of 375 MHz.
    
    This patch adds three new OPPs (456 MHz, 408 MHz and 372 MHz)
    to the list of DA850 OPPs.
    
    Not all silicon is qualified to run at higher speeds and
    unfortunately the maximum speed the chip can support can only
    be determined from the label on the package (not software
    readable).
    
    Because of this, we depend on the maximum speed grade information
    to be provided to us in some board specific way. The board informs
    the maximum speed grade information by setting the da850_max_speed
    variable.
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 63916b902760..78b5ae29ae40 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -830,8 +830,7 @@ static void da850_set_async3_src(int pllnum)
  * According to the TRM, minimum PLLM results in maximum power savings.
  * The OPP definitions below should keep the PLLM as low as possible.
  *
- * The output of the PLLM must be between 400 to 600 MHz.
- * This rules out prediv of anything but divide-by-one for 24Mhz OSC input.
+ * The output of the PLLM must be between 300 to 600 MHz.
  */
 struct da850_opp {
 	unsigned int	freq;	/* in KHz */
@@ -842,6 +841,33 @@ struct da850_opp {
 	unsigned int	cvdd_max; /* in uV */
 };
 
+static const struct da850_opp da850_opp_456 = {
+	.freq		= 456000,
+	.prediv		= 1,
+	.mult		= 19,
+	.postdiv	= 1,
+	.cvdd_min	= 1300000,
+	.cvdd_max	= 1350000,
+};
+
+static const struct da850_opp da850_opp_408 = {
+	.freq		= 408000,
+	.prediv		= 1,
+	.mult		= 17,
+	.postdiv	= 1,
+	.cvdd_min	= 1300000,
+	.cvdd_max	= 1350000,
+};
+
+static const struct da850_opp da850_opp_372 = {
+	.freq		= 372000,
+	.prediv		= 2,
+	.mult		= 31,
+	.postdiv	= 1,
+	.cvdd_min	= 1200000,
+	.cvdd_max	= 1320000,
+};
+
 static const struct da850_opp da850_opp_300 = {
 	.freq		= 300000,
 	.prediv		= 1,
@@ -876,6 +902,9 @@ static const struct da850_opp da850_opp_96 = {
 	}
 
 static struct cpufreq_frequency_table da850_freq_table[] = {
+	OPP(456),
+	OPP(408),
+	OPP(372),
 	OPP(300),
 	OPP(200),
 	OPP(96),
@@ -885,6 +914,19 @@ static struct cpufreq_frequency_table da850_freq_table[] = {
 	},
 };
 
+#ifdef CONFIG_REGULATOR
+static int da850_set_voltage(unsigned int index);
+static int da850_regulator_init(void);
+#endif
+
+static struct davinci_cpufreq_config cpufreq_info = {
+	.freq_table = da850_freq_table,
+#ifdef CONFIG_REGULATOR
+	.init = da850_regulator_init,
+	.set_voltage = da850_set_voltage,
+#endif
+};
+
 #ifdef CONFIG_REGULATOR
 static struct regulator *cvdd;
 
@@ -895,7 +937,7 @@ static int da850_set_voltage(unsigned int index)
 	if (!cvdd)
 		return -ENODEV;
 
-	opp = (struct da850_opp *) da850_freq_table[index].index;
+	opp = (struct da850_opp *) cpufreq_info.freq_table[index].index;
 
 	return regulator_set_voltage(cvdd, opp->cvdd_min, opp->cvdd_max);
 }
@@ -912,14 +954,6 @@ static int da850_regulator_init(void)
 }
 #endif
 
-static struct davinci_cpufreq_config cpufreq_info = {
-	.freq_table = &da850_freq_table[0],
-#ifdef CONFIG_REGULATOR
-	.init = da850_regulator_init,
-	.set_voltage = da850_set_voltage,
-#endif
-};
-
 static struct platform_device da850_cpufreq_device = {
 	.name			= "cpufreq-davinci",
 	.dev = {
@@ -928,12 +962,22 @@ static struct platform_device da850_cpufreq_device = {
 	.id = -1,
 };
 
+unsigned int da850_max_speed = 300000;
+
 int __init da850_register_cpufreq(char *async_clk)
 {
+	int i;
+
 	/* cpufreq driver can help keep an "async" clock constant */
 	if (async_clk)
 		clk_add_alias("async", da850_cpufreq_device.name,
 							async_clk, NULL);
+	for (i = 0; i < ARRAY_SIZE(da850_freq_table); i++) {
+		if (da850_freq_table[i].frequency <= da850_max_speed) {
+			cpufreq_info.freq_table = &da850_freq_table[i];
+			break;
+		}
+	}
 
 	return platform_device_register(&da850_cpufreq_device);
 }
@@ -942,17 +986,18 @@ static int da850_round_armrate(struct clk *clk, unsigned long rate)
 {
 	int i, ret = 0, diff;
 	unsigned int best = (unsigned int) -1;
+	struct cpufreq_frequency_table *table = cpufreq_info.freq_table;
 
 	rate /= 1000; /* convert to kHz */
 
-	for (i = 0; da850_freq_table[i].frequency != CPUFREQ_TABLE_END; i++) {
-		diff = da850_freq_table[i].frequency - rate;
+	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
+		diff = table[i].frequency - rate;
 		if (diff < 0)
 			diff = -diff;
 
 		if (diff < best) {
 			best = diff;
-			ret = da850_freq_table[i].frequency;
+			ret = table[i].frequency;
 		}
 	}
 
@@ -973,7 +1018,7 @@ static int da850_set_pll0rate(struct clk *clk, unsigned long index)
 	struct pll_data *pll = clk->pll_data;
 	int ret;
 
-	opp = (struct da850_opp *) da850_freq_table[index].index;
+	opp = (struct da850_opp *) cpufreq_info.freq_table[index].index;
 	prediv = opp->prediv;
 	mult = opp->mult;
 	postdiv = opp->postdiv;

commit 051a6687336d3310abc85991db7a8917ecc603fc
Author: Juha Kuikka <juha.kuikka@elektrobit.com>
Date:   Thu Aug 26 12:40:46 2010 -0700

    DA850: Split MMCSD clock into two to support both MMCSD peripherals
    
    Split mmcsd_clk into mmcsd0_clk and mmcsd1_clk and add davinci_mmc.1
    in preparation for adding support for MMCSD1 peripheral in DA850.
    
    Signed-off-by: Juha Kuikka <juha.kuikka@elektrobit.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index c2a3ce55b6c5..63916b902760 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -325,12 +325,19 @@ static struct clk lcdc_clk = {
 	.gpsc		= 1,
 };
 
-static struct clk mmcsd_clk = {
-	.name		= "mmcsd",
+static struct clk mmcsd0_clk = {
+	.name		= "mmcsd0",
 	.parent		= &pll0_sysclk2,
 	.lpsc		= DA8XX_LPSC0_MMC_SD,
 };
 
+static struct clk mmcsd1_clk = {
+	.name		= "mmcsd1",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA850_LPSC1_MMC_SD1,
+	.gpsc		= 1,
+};
+
 static struct clk aemif_clk = {
 	.name		= "aemif",
 	.parent		= &pll0_sysclk3,
@@ -377,7 +384,8 @@ static struct clk_lookup da850_clks[] = {
 	CLK("davinci_emac.1",	NULL,		&emac_clk),
 	CLK("davinci-mcasp.0",	NULL,		&mcasp_clk),
 	CLK("da8xx_lcdc.0",	NULL,		&lcdc_clk),
-	CLK("davinci_mmc.0",	NULL,		&mmcsd_clk),
+	CLK("davinci_mmc.0",	NULL,		&mmcsd0_clk),
+	CLK("davinci_mmc.1",	NULL,		&mmcsd1_clk),
 	CLK(NULL,		"aemif",	&aemif_clk),
 	CLK(NULL,		NULL,		NULL),
 };

commit 85b8307fd03badbff0da5a75776c62cb45ee6551
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Sun Aug 1 21:17:00 2010 +0400

    DA850: move MII/RMII pin lists to the board file
    
    The CPGMAC pin list in da850.c was incorrectly split into two MII/RMII mode
    specific pin lists, while what pin group is used is a function of how the board
    is wired.  Copy the pin lists to board-da850-evm.c, renaming them accordingly,
    and merge the two lists in da850.c into one, da850_cpgmac_pins[], representing
    the CPGMAC module as a whole...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Tested-by: Ben Gardiner <bengardiner@nanometrics.ca>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index efb904ebce9c..c2a3ce55b6c5 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -574,15 +574,9 @@ const short da850_cpgmac_pins[] __initdata = {
 	DA850_MII_TXD_2, DA850_MII_TXD_1, DA850_MII_TXD_0, DA850_MII_RXER,
 	DA850_MII_CRS, DA850_MII_RXCLK, DA850_MII_RXDV, DA850_MII_RXD_3,
 	DA850_MII_RXD_2, DA850_MII_RXD_1, DA850_MII_RXD_0, DA850_MDIO_CLK,
-	DA850_MDIO_D,
-	-1
-};
-
-const short da850_rmii_pins[] __initdata = {
-	DA850_RMII_TXD_0, DA850_RMII_TXD_1, DA850_RMII_TXEN,
-	DA850_RMII_CRS_DV, DA850_RMII_RXD_0, DA850_RMII_RXD_1,
-	DA850_RMII_RXER, DA850_RMII_MHZ_50_CLK, DA850_MDIO_CLK,
-	DA850_MDIO_D,
+	DA850_MDIO_D, DA850_RMII_TXD_0, DA850_RMII_TXD_1, DA850_RMII_TXEN,
+	DA850_RMII_CRS_DV, DA850_RMII_RXD_0, DA850_RMII_RXD_1, DA850_RMII_RXER,
+	DA850_RMII_MHZ_50_CLK,
 	-1
 };
 

commit f48ecc2f73763e9d94d5847692ed25ab0f4fb73c
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Sun Aug 1 21:15:16 2010 +0400

    DA850: move NAND/NOR pin lists to the board file
    
    The NAND/NOR flash pin lists (da850_nand_pins/da850_nor_pins) are purely board
    specific and as such shouldn't be in da850.c -- copy them to board-da850-evm.c,
    renaming to da850_evm_nand_pins/da850_evm_nor_pins respectively, and merge the
    two lists in da850.c into one, representing the EMIF 2.5 module as a whole,
    just like we have it in da830.c...
    
    While at it, remove the '__init' modifier from da850_evm_setup_nor_nand() as
    this function is called from non '__init' code...
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Tested-by: Ben Gardiner <bengardiner@nanometrics.ca>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 5af7cfb1447e..efb904ebce9c 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -609,27 +609,19 @@ const short da850_mmcsd0_pins[] __initdata = {
 	-1
 };
 
-const short da850_nand_pins[] __initdata = {
-	DA850_EMA_D_7, DA850_EMA_D_6, DA850_EMA_D_5, DA850_EMA_D_4,
-	DA850_EMA_D_3, DA850_EMA_D_2, DA850_EMA_D_1, DA850_EMA_D_0,
-	DA850_EMA_A_1, DA850_EMA_A_2, DA850_NEMA_CS_3, DA850_NEMA_CS_4,
-	DA850_NEMA_WE, DA850_NEMA_OE,
-	-1
-};
-
-const short da850_nor_pins[] __initdata = {
+const short da850_emif25_pins[] __initdata = {
 	DA850_EMA_BA_1, DA850_EMA_CLK, DA850_EMA_WAIT_1, DA850_NEMA_CS_2,
-	DA850_NEMA_WE, DA850_NEMA_OE, DA850_EMA_D_0, DA850_EMA_D_1,
-	DA850_EMA_D_2, DA850_EMA_D_3, DA850_EMA_D_4, DA850_EMA_D_5,
-	DA850_EMA_D_6, DA850_EMA_D_7, DA850_EMA_D_8, DA850_EMA_D_9,
-	DA850_EMA_D_10, DA850_EMA_D_11, DA850_EMA_D_12, DA850_EMA_D_13,
-	DA850_EMA_D_14, DA850_EMA_D_15, DA850_EMA_A_0, DA850_EMA_A_1,
-	DA850_EMA_A_2, DA850_EMA_A_3, DA850_EMA_A_4, DA850_EMA_A_5,
-	DA850_EMA_A_6, DA850_EMA_A_7, DA850_EMA_A_8, DA850_EMA_A_9,
-	DA850_EMA_A_10, DA850_EMA_A_11, DA850_EMA_A_12, DA850_EMA_A_13,
-	DA850_EMA_A_14, DA850_EMA_A_15, DA850_EMA_A_16, DA850_EMA_A_17,
-	DA850_EMA_A_18, DA850_EMA_A_19, DA850_EMA_A_20, DA850_EMA_A_21,
-	DA850_EMA_A_22, DA850_EMA_A_23,
+	DA850_NEMA_CS_3, DA850_NEMA_CS_4, DA850_NEMA_WE, DA850_NEMA_OE,
+	DA850_EMA_D_0, DA850_EMA_D_1, DA850_EMA_D_2, DA850_EMA_D_3,
+	DA850_EMA_D_4, DA850_EMA_D_5, DA850_EMA_D_6, DA850_EMA_D_7,
+	DA850_EMA_D_8, DA850_EMA_D_9, DA850_EMA_D_10, DA850_EMA_D_11,
+	DA850_EMA_D_12, DA850_EMA_D_13, DA850_EMA_D_14, DA850_EMA_D_15,
+	DA850_EMA_A_0, DA850_EMA_A_1, DA850_EMA_A_2, DA850_EMA_A_3,
+	DA850_EMA_A_4, DA850_EMA_A_5, DA850_EMA_A_6, DA850_EMA_A_7,
+	DA850_EMA_A_8, DA850_EMA_A_9, DA850_EMA_A_10, DA850_EMA_A_11,
+	DA850_EMA_A_12, DA850_EMA_A_13, DA850_EMA_A_14, DA850_EMA_A_15,
+	DA850_EMA_A_16, DA850_EMA_A_17, DA850_EMA_A_18, DA850_EMA_A_19,
+	DA850_EMA_A_20, DA850_EMA_A_21, DA850_EMA_A_22, DA850_EMA_A_23,
 	-1
 };
 

commit b987c4b2c9c9db2393f4c089e63d1734301214e5
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Tue Jul 20 16:46:51 2010 +0530

    davinci: am18x/da850/omap-l138: keep async clock constant with cpufreq
    
    Keep PLL0 SYSCLK3 at a constant rate of 100MHz. This enables the AEMIF
    timing to remain valid even as the PLL0 output is changed by cpufreq
    driver to save power.
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 6932d804556b..5af7cfb1447e 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -86,6 +86,8 @@ static struct clk pll0_sysclk3 = {
 	.parent		= &pll0_clk,
 	.flags		= CLK_PLL,
 	.div_reg	= PLLDIV3,
+	.set_rate	= davinci_set_sysclk_rate,
+	.maxrate	= 100000000,
 };
 
 static struct clk pll0_sysclk4 = {
@@ -929,10 +931,16 @@ static struct platform_device da850_cpufreq_device = {
 	.dev = {
 		.platform_data	= &cpufreq_info,
 	},
+	.id = -1,
 };
 
-int __init da850_register_cpufreq(void)
+int __init da850_register_cpufreq(char *async_clk)
 {
+	/* cpufreq driver can help keep an "async" clock constant */
+	if (async_clk)
+		clk_add_alias("async", da850_cpufreq_device.name,
+							async_clk, NULL);
+
 	return platform_device_register(&da850_cpufreq_device);
 }
 

commit 6ef62f8204402e32259451857c1a4a04f155b56e
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Wed Jul 7 14:02:49 2010 +0530

    davinci: am18x/da850/omap-l138: use 'NOM' voltage defined in datasheet as min voltage
    
    For each DA850 OPP, the normal ('NOM') voltage defined in the tecnical
    reference manual (TRM) is actually the minimum voltage the frequency
    is supported at.
    
    The minimum ('MIN') voltage defined in TRM is meant to take care of
    voltage fluctuations and the device should not be run at this voltage
    for extended periods of time.
    
    Fix the OPP definitions to define the cvdd_min as the normal voltage
    defined in the datasheet.
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 868227e66cea..6932d804556b 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -851,7 +851,7 @@ static const struct da850_opp da850_opp_300 = {
 	.prediv		= 1,
 	.mult		= 25,
 	.postdiv	= 2,
-	.cvdd_min	= 1140000,
+	.cvdd_min	= 1200000,
 	.cvdd_max	= 1320000,
 };
 
@@ -860,7 +860,7 @@ static const struct da850_opp da850_opp_200 = {
 	.prediv		= 1,
 	.mult		= 25,
 	.postdiv	= 3,
-	.cvdd_min	= 1050000,
+	.cvdd_min	= 1100000,
 	.cvdd_max	= 1160000,
 };
 
@@ -869,7 +869,7 @@ static const struct da850_opp da850_opp_96 = {
 	.prediv		= 1,
 	.mult		= 20,
 	.postdiv	= 5,
-	.cvdd_min	= 950000,
+	.cvdd_min	= 1000000,
 	.cvdd_max	= 1050000,
 };
 

commit fca97b3337edb6b12707d167460b224dd8ef6052
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Tue Jul 20 16:46:48 2010 +0530

    davinci: cpufreq: bailout on regulator errors
    
    Current cpufreq code does not consider errors that can occur while
    changing voltage. Code to increase CPU  frequency goes ahead even in
    the case the regulator has failed to increase the voltage. This leads
    to hard error since lower voltages cannot support increased frequency.
    
    Prevent this by not increasing frequency in case increasing voltage
    is not successful.
    
    Also, do not lower the voltage if changing the cpu frequency has failed
    for some reason.
    
    Note that we do not return error on failure to decrease voltage as
    that is not a hard error.
    
    Build fix for non-cpufreq kernels by Caglar Akyuz.
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Cc: Caglar Akyuz <caglar@bilkon-kontrol.com.tr>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 68ed58a48252..868227e66cea 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -983,7 +983,7 @@ static int da850_set_pll0rate(struct clk *clk, unsigned long index)
 	return 0;
 }
 #else
-int __init da850_register_cpufreq(void)
+int __init da850_register_cpufreq(char *async_clk)
 {
 	return 0;
 }

commit f027512db7410ed149422262b07d2c78f0a36282
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Mon Jun 28 17:16:37 2010 +0530

    davinci: da8xx: sparse cleanup: remove duplicate entries in irq priorities
    
    This patch helps get rid of the following sparse warnings
    of the type:
    
      CHECK   arch/arm/mach-davinci/da830.c
    arch/arm/mach-davinci/da830.c:1026:3: warning: Initializer entry defined twice
    arch/arm/mach-davinci/da830.c:1027:3:   also defined here
    
    coming from the irq priorities array init.
    
    Apart from one instance of genuinie repetition, most are are instances
    of multiple #defines of the same interrupt number. I have not
    removed the multiple definitions from the irq.h file in the hope
    that someone might decide to use them as shared interrupts at some
    point of time. The priority initialization however needs to be done
    only once and hence has been corrected.
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 6b8331bf8cf3..68ed58a48252 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -643,7 +643,6 @@ static u8 da850_default_priorities[DA850_N_CP_INTC_IRQ] = {
 	[IRQ_DA8XX_EVTOUT4]		= 7,
 	[IRQ_DA8XX_EVTOUT5]		= 7,
 	[IRQ_DA8XX_EVTOUT6]		= 7,
-	[IRQ_DA8XX_EVTOUT6]		= 7,
 	[IRQ_DA8XX_EVTOUT7]		= 7,
 	[IRQ_DA8XX_CCINT0]		= 7,
 	[IRQ_DA8XX_CCERRINT]		= 7,
@@ -661,27 +660,7 @@ static u8 da850_default_priorities[DA850_N_CP_INTC_IRQ] = {
 	[IRQ_DA8XX_TINT34_1]		= 7,
 	[IRQ_DA8XX_UARTINT0]		= 7,
 	[IRQ_DA8XX_KEYMGRINT]		= 7,
-	[IRQ_DA8XX_SECINT]		= 7,
-	[IRQ_DA8XX_SECKEYERR]		= 7,
 	[IRQ_DA850_MPUADDRERR0]		= 7,
-	[IRQ_DA850_MPUPROTERR0]		= 7,
-	[IRQ_DA850_IOPUADDRERR0]	= 7,
-	[IRQ_DA850_IOPUPROTERR0]	= 7,
-	[IRQ_DA850_IOPUADDRERR1]	= 7,
-	[IRQ_DA850_IOPUPROTERR1]	= 7,
-	[IRQ_DA850_IOPUADDRERR2]	= 7,
-	[IRQ_DA850_IOPUPROTERR2]	= 7,
-	[IRQ_DA850_BOOTCFG_ADDR_ERR]	= 7,
-	[IRQ_DA850_BOOTCFG_PROT_ERR]	= 7,
-	[IRQ_DA850_MPUADDRERR1]		= 7,
-	[IRQ_DA850_MPUPROTERR1]		= 7,
-	[IRQ_DA850_IOPUADDRERR3]	= 7,
-	[IRQ_DA850_IOPUPROTERR3]	= 7,
-	[IRQ_DA850_IOPUADDRERR4]	= 7,
-	[IRQ_DA850_IOPUPROTERR4]	= 7,
-	[IRQ_DA850_IOPUADDRERR5]	= 7,
-	[IRQ_DA850_IOPUPROTERR5]	= 7,
-	[IRQ_DA850_MIOPU_BOOTCFG_ERR]	= 7,
 	[IRQ_DA8XX_CHIPINT0]		= 7,
 	[IRQ_DA8XX_CHIPINT1]		= 7,
 	[IRQ_DA8XX_CHIPINT2]		= 7,
@@ -722,8 +701,6 @@ static u8 da850_default_priorities[DA850_N_CP_INTC_IRQ] = {
 	[IRQ_DA8XX_EHRPWM1]		= 7,
 	[IRQ_DA8XX_EHRPWM1TZ]		= 7,
 	[IRQ_DA850_SATAINT]		= 7,
-	[IRQ_DA850_TINT12_2]		= 7,
-	[IRQ_DA850_TINT34_2]		= 7,
 	[IRQ_DA850_TINTALL_2]		= 7,
 	[IRQ_DA8XX_ECAP0]		= 7,
 	[IRQ_DA8XX_ECAP1]		= 7,
@@ -751,8 +728,6 @@ static u8 da850_default_priorities[DA850_N_CP_INTC_IRQ] = {
 	[IRQ_DA850_CCINT1]		= 7,
 	[IRQ_DA850_CCERRINT1]		= 7,
 	[IRQ_DA850_TCERRINT2]		= 7,
-	[IRQ_DA850_TINT12_3]		= 7,
-	[IRQ_DA850_TINT34_3]		= 7,
 	[IRQ_DA850_TINTALL_3]		= 7,
 	[IRQ_DA850_MCBSP0RINT]		= 7,
 	[IRQ_DA850_MCBSP0XINT]		= 7,

commit bcd6a1c695c8b404bfde22b276186ac52a20291b
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Fri May 7 17:06:39 2010 -0400

    Davinci: iotable based ioremap() interception
    
    This patch allows for a more flexible ioremap() interception based on iotable
    contents.
    
    With this patch, the ioremap() interception code can properly translate
    addresses only after davinci_soc_info has been initialized.  Consequently,
    in soc-specific init functions, davinci_common_init() has to happen before any
    ioremap() attempts. The da8xx init sequence has been suitably modified to meet
    this restriction.
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 74d4e49d4064..6b8331bf8cf3 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1099,6 +1099,8 @@ void __init da850_init(void)
 {
 	unsigned int v;
 
+	davinci_common_init(&davinci_soc_info_da850);
+
 	da8xx_syscfg0_base = ioremap(DA8XX_SYSCFG0_BASE, SZ_4K);
 	if (WARN(!da8xx_syscfg0_base, "Unable to map syscfg0 module"))
 		return;
@@ -1107,8 +1109,6 @@ void __init da850_init(void)
 	if (WARN(!da8xx_syscfg1_base, "Unable to map syscfg1 module"))
 		return;
 
-	davinci_common_init(&davinci_soc_info_da850);
-
 	/*
 	 * Move the clock source of Async3 domain to PLL1 SYSCLK2.
 	 * This helps keeping the peripherals on this domain insulated

commit 779b0d53ca41873d59225eb776c5d4493a0abd0f
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Fri May 7 17:06:38 2010 -0400

    Davinci: pinmux - use ioremap()
    
    This patch modifies the pinmux implementation so as to ioremap() the pinmux
    register area on first use.
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 6f5ea2aa1c4a..74d4e49d4064 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1076,6 +1076,7 @@ static struct davinci_soc_info davinci_soc_info_da850 = {
 	.cpu_clks		= da850_clks,
 	.psc_bases		= da850_psc_bases,
 	.psc_bases_num		= ARRAY_SIZE(da850_psc_bases),
+	.pinmux_base		= DA8XX_SYSCFG0_BASE + 0x120,
 	.pinmux_pins		= da850_pins,
 	.pinmux_pins_num	= ARRAY_SIZE(da850_pins),
 	.intc_base		= DA8XX_CP_INTC_BASE,
@@ -1106,8 +1107,6 @@ void __init da850_init(void)
 	if (WARN(!da8xx_syscfg1_base, "Unable to map syscfg1 module"))
 		return;
 
-	davinci_soc_info_da850.pinmux_base = DA8XX_SYSCFG0_VIRT(0x120);
-
 	davinci_common_init(&davinci_soc_info_da850);
 
 	/*

commit bd808947040ba53b2b0e52dde598a9414fb27bba
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Fri May 7 17:06:37 2010 -0400

    Davinci: aintc/cpintc - use ioremap()
    
    This patch implements the following:
    
     - interrupt initialization uses ioremap() instead of passing a virtual address
       via davinci_soc_info.
    
     - machine definitions directly point to cp_intc_init() or davinci_irq_init()
    
     - davinci_intc_type and davinci_intc_base now get initialized in controller
       specific init functions instead of davinci_common_init()
    
     - minor fix in davinci_irq_init() to use intc_irq_num instead of
       DAVINCI_N_AINTC_IRQ
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 2a430bbbd393..6f5ea2aa1c4a 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1078,7 +1078,7 @@ static struct davinci_soc_info davinci_soc_info_da850 = {
 	.psc_bases_num		= ARRAY_SIZE(da850_psc_bases),
 	.pinmux_pins		= da850_pins,
 	.pinmux_pins_num	= ARRAY_SIZE(da850_pins),
-	.intc_base		= (void __iomem *)DA8XX_CP_INTC_VIRT,
+	.intc_base		= DA8XX_CP_INTC_BASE,
 	.intc_type		= DAVINCI_INTC_TYPE_CP_INTC,
 	.intc_irq_prios		= da850_default_priorities,
 	.intc_irq_num		= DA850_N_CP_INTC_IRQ,

commit e4c822c7e98cdda78b10a696b030fc20b22dcab4
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Fri May 7 17:06:36 2010 -0400

    Davinci: psc - use ioremap()
    
    This patch modifies the psc and clock control code to use ioremap()ed
    registers.
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index ebfa5ca29a81..2a430bbbd393 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -782,10 +782,7 @@ static struct map_desc da850_io_desc[] = {
 	},
 };
 
-static void __iomem *da850_psc_bases[] = {
-	IO_ADDRESS(DA8XX_PSC0_BASE),
-	IO_ADDRESS(DA8XX_PSC1_BASE),
-};
+static u32 da850_psc_bases[] = { DA8XX_PSC0_BASE, DA8XX_PSC1_BASE };
 
 /* Contents of JTAG ID register used to identify exact cpu type */
 static struct davinci_id da850_ids[] = {

commit 1bcd38ad2de4c1cd30387c588dfb28d637d4111d
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Fri May 7 17:06:35 2010 -0400

    Davinci: timer - use ioremap()
    
    This patch eliminates IO_ADDRESS() usage for Davinci timer definitions.  The
    timer code has correspondingly been modified to ioremap() MMRs instead.
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index fcf701628590..ebfa5ca29a81 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -800,22 +800,22 @@ static struct davinci_id da850_ids[] = {
 
 static struct davinci_timer_instance da850_timer_instance[4] = {
 	{
-		.base		= IO_ADDRESS(DA8XX_TIMER64P0_BASE),
+		.base		= DA8XX_TIMER64P0_BASE,
 		.bottom_irq	= IRQ_DA8XX_TINT12_0,
 		.top_irq	= IRQ_DA8XX_TINT34_0,
 	},
 	{
-		.base		= IO_ADDRESS(DA8XX_TIMER64P1_BASE),
+		.base		= DA8XX_TIMER64P1_BASE,
 		.bottom_irq	= IRQ_DA8XX_TINT12_1,
 		.top_irq	= IRQ_DA8XX_TINT34_1,
 	},
 	{
-		.base		= IO_ADDRESS(DA850_TIMER64P2_BASE),
+		.base		= DA850_TIMER64P2_BASE,
 		.bottom_irq	= IRQ_DA850_TINT12_2,
 		.top_irq	= IRQ_DA850_TINT34_2,
 	},
 	{
-		.base		= IO_ADDRESS(DA850_TIMER64P3_BASE),
+		.base		= DA850_TIMER64P3_BASE,
 		.bottom_irq	= IRQ_DA850_TINT12_3,
 		.top_irq	= IRQ_DA850_TINT34_3,
 	},

commit 3347db8392486a1b52aab980cc445cf505c36d45
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Fri May 7 17:06:34 2010 -0400

    Davinci: jtag_id - use ioremap()
    
    This patch replaces the jtag id base info in davinci_soc_info with a physical
    address which is then ioremap()ed within common code.
    
    This patch (in combination with a similar change for PSC) will allow us to
    eliminate the SYSCFG nastiness in DA8xx code.
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index cb7f66300525..fcf701628590 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1073,6 +1073,7 @@ int da850_register_pm(struct platform_device *pdev)
 static struct davinci_soc_info davinci_soc_info_da850 = {
 	.io_desc		= da850_io_desc,
 	.io_desc_num		= ARRAY_SIZE(da850_io_desc),
+	.jtag_id_reg		= DA8XX_SYSCFG0_BASE + DA8XX_JTAG_ID_REG,
 	.ids			= da850_ids,
 	.ids_num		= ARRAY_SIZE(da850_ids),
 	.cpu_clks		= da850_clks,
@@ -1108,8 +1109,6 @@ void __init da850_init(void)
 	if (WARN(!da8xx_syscfg1_base, "Unable to map syscfg1 module"))
 		return;
 
-	davinci_soc_info_da850.jtag_id_base =
-					DA8XX_SYSCFG0_VIRT(DA8XX_JTAG_ID_REG);
 	davinci_soc_info_da850.pinmux_base = DA8XX_SYSCFG0_VIRT(0x120);
 
 	davinci_common_init(&davinci_soc_info_da850);

commit b8d44293952e4b32b8595d924a377351f3cd1565
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Fri May 7 17:06:32 2010 -0400

    Davinci: gpio - use ioremap()
    
    This patch modifies the gpio_base definition in davinci_soc_info to be a
    physical address, which is then ioremap()ed by the gpio initialization
    function.
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 2b6dd59d72f2..cb7f66300525 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1086,7 +1086,7 @@ static struct davinci_soc_info davinci_soc_info_da850 = {
 	.intc_irq_num		= DA850_N_CP_INTC_IRQ,
 	.timer_info		= &da850_timer_info,
 	.gpio_type		= GPIO_TYPE_DAVINCI,
-	.gpio_base		= IO_ADDRESS(DA8XX_GPIO_BASE),
+	.gpio_base		= DA8XX_GPIO_BASE,
 	.gpio_num		= 144,
 	.gpio_irq		= IRQ_DA8XX_GPIO0,
 	.serial_dev		= &da8xx_serial_device,

commit c78a5bc2e77e8fc5be29cda5b28c9b9afd0f4b6d
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Sat May 1 18:38:28 2010 -0400

    Davinci: watchdog reset separation across socs
    
    The earlier watchdog reset mechanism had a couple of limitations.  First, it
    embedded a reference to "davinci_wdt_device" inside common code.  This
    forced all derived platforms (da8xx and tnetv107x) to define such a device.
    This also would have caused problems in including multiple socs in a single
    build due to symbol redefinition.
    
    With this patch, davinci_watchdog_reset() now takes the platform device as an
    argument.  The davinci_soc_info struct has been extended to include a reset
    function and a watchdog platform_device.  arch_reset() then uses these
    elements to reset the system in a SoC specific fashion.
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Tested-by: Sandeep Paulraj <s-paulraj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 8aefcffa5ae2..2b6dd59d72f2 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -1093,6 +1093,7 @@ static struct davinci_soc_info davinci_soc_info_da850 = {
 	.emac_pdata		= &da8xx_emac_pdata,
 	.sram_dma		= DA8XX_ARM_RAM_BASE,
 	.sram_len		= SZ_8K,
+	.reset_device		= &da8xx_wdt_device,
 };
 
 void __init da850_init(void)

commit 686b634a07451fc4fe3b712fe211bfa861a53241
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Sat May 1 18:37:54 2010 -0400

    Davinci: gpio - controller type support
    
    This patch allows for gpio controllers that deviate from those found on
    traditional davinci socs.  davinci_soc_info has an added field to indicate the
    soc-specific gpio controller type.  The gpio initialization code then bails
    out if necessary.
    
    More elements (tnetv107x) to be added later into enum davinci_gpio_type.
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Tested-by: Sandeep Paulraj <s-paulraj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index d0fd7566712a..8aefcffa5ae2 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -27,6 +27,7 @@
 #include <mach/da8xx.h>
 #include <mach/cpufreq.h>
 #include <mach/pm.h>
+#include <mach/gpio.h>
 
 #include "clock.h"
 #include "mux.h"
@@ -1084,6 +1085,7 @@ static struct davinci_soc_info davinci_soc_info_da850 = {
 	.intc_irq_prios		= da850_default_priorities,
 	.intc_irq_num		= DA850_N_CP_INTC_IRQ,
 	.timer_info		= &da850_timer_info,
+	.gpio_type		= GPIO_TYPE_DAVINCI,
 	.gpio_base		= IO_ADDRESS(DA8XX_GPIO_BASE),
 	.gpio_num		= 144,
 	.gpio_irq		= IRQ_DA8XX_GPIO0,

commit 08aca087f263e8089420b2723fe0c1a0cbe5de0c
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Mon Jan 11 08:22:23 2010 -0800

    davinci: clkdev cleanup: remove clk_lookup wrapper, use clkdev_add_table()
    
    Remove unneeded 'struct davinci_clk' wrapper around 'struct clk_lookup'
    and use clkdev_add_table() to add the list of clocks in one go.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index b9a7b3bc36b2..d0fd7566712a 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -335,7 +335,7 @@ static struct clk aemif_clk = {
 	.flags		= ALWAYS_ENABLED,
 };
 
-static struct davinci_clk da850_clks[] = {
+static struct clk_lookup da850_clks[] = {
 	CLK(NULL,		"ref",		&ref_clk),
 	CLK(NULL,		"pll0",		&pll0_clk),
 	CLK(NULL,		"pll0_aux",	&pll0_aux_clk),
@@ -834,12 +834,12 @@ static struct davinci_timer_info da850_timer_info = {
 static void da850_set_async3_src(int pllnum)
 {
 	struct clk *clk, *newparent = pllnum ? &pll1_sysclk2 : &pll0_sysclk2;
-	struct davinci_clk *c;
+	struct clk_lookup *c;
 	unsigned int v;
 	int ret;
 
-	for (c = da850_clks; c->lk.clk; c++) {
-		clk = c->lk.clk;
+	for (c = da850_clks; c->clk; c++) {
+		clk = c->clk;
 		if (clk->flags & DA850_CLK_ASYNC3) {
 			ret = clk_set_parent(clk, newparent);
 			WARN(ret, "DA850: unable to re-parent clock %s",

commit 044ca01521d077a35b46a445b02b93f413109a4b
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Thu Dec 17 18:29:32 2009 +0530

    davinci: da850/omap-l138: add support for SoC suspend
    
    This patch adds support for registering for suspend-to-RAM
    functionality on da850/omap-l138 SoCs.
    
    da850 supports wakeup based on external event and RTC
    alarm.
    
    Currently only RTC alarm based wakeup is supported.
    Support for wakeup based on external event will be
    added as later improvements.
    
    For scheduling an alarm event on RTC some useful code
    is present in Documentation/rtc.txt
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 1ac8f6318c1b..b9a7b3bc36b2 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -26,6 +26,7 @@
 #include <mach/time.h>
 #include <mach/da8xx.h>
 #include <mach/cpufreq.h>
+#include <mach/pm.h>
 
 #include "clock.h"
 #include "mux.h"
@@ -536,6 +537,7 @@ static const struct mux_config da850_pins[] = {
 	MUX_CFG(DA850, GPIO2_15,	5,	0,	15,	8,	false)
 	MUX_CFG(DA850, GPIO4_0,		10,	28,	15,	8,	false)
 	MUX_CFG(DA850, GPIO4_1,		10,	24,	15,	8,	false)
+	MUX_CFG(DA850, RTC_ALARM,	0,	28,	15,	2,	false)
 #endif
 };
 
@@ -1029,6 +1031,43 @@ static int da850_round_armrate(struct clk *clk, unsigned long rate)
 }
 #endif
 
+int da850_register_pm(struct platform_device *pdev)
+{
+	int ret;
+	struct davinci_pm_config *pdata = pdev->dev.platform_data;
+
+	ret = davinci_cfg_reg(DA850_RTC_ALARM);
+	if (ret)
+		return ret;
+
+	pdata->ddr2_ctlr_base = da8xx_get_mem_ctlr();
+	pdata->deepsleep_reg = DA8XX_SYSCFG1_VIRT(DA8XX_DEEPSLEEP_REG);
+	pdata->ddrpsc_num = DA8XX_LPSC1_EMIF3C;
+
+	pdata->cpupll_reg_base = ioremap(DA8XX_PLL0_BASE, SZ_4K);
+	if (!pdata->cpupll_reg_base)
+		return -ENOMEM;
+
+	pdata->ddrpll_reg_base = ioremap(DA8XX_PLL1_BASE, SZ_4K);
+	if (!pdata->ddrpll_reg_base) {
+		ret = -ENOMEM;
+		goto no_ddrpll_mem;
+	}
+
+	pdata->ddrpsc_reg_base = ioremap(DA8XX_PSC1_BASE, SZ_4K);
+	if (!pdata->ddrpsc_reg_base) {
+		ret = -ENOMEM;
+		goto no_ddrpsc_mem;
+	}
+
+	return platform_device_register(pdev);
+
+no_ddrpsc_mem:
+	iounmap(pdata->ddrpll_reg_base);
+no_ddrpll_mem:
+	iounmap(pdata->cpupll_reg_base);
+	return ret;
+}
 
 static struct davinci_soc_info davinci_soc_info_da850 = {
 	.io_desc		= da850_io_desc,

commit 60cd02e1f4a1574c26c9ae8d29d63bd3d179c0c2
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Mon Nov 16 17:21:39 2009 +0530

    davinci: da850/omap-l138: create static map for SRAM
    
    Create static map for internal SRAM and populate SRAM base
    and size in soc_info structure to allow SRAM allocation
    functions from arch/arm/mach-davinci/sram.c to work.
    
    On DA850 SRAM is used for suspend-to-RAM implementation
    in places where DDR2 cannot be accessed as its clocks are
    stopped.
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index fcfde2a72f8f..1ac8f6318c1b 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -771,6 +771,12 @@ static struct map_desc da850_io_desc[] = {
 		.length		= DA8XX_CP_INTC_SIZE,
 		.type		= MT_DEVICE
 	},
+	{
+		.virtual	= SRAM_VIRT,
+		.pfn		= __phys_to_pfn(DA8XX_ARM_RAM_BASE),
+		.length		= SZ_8K,
+		.type		= MT_DEVICE
+	},
 };
 
 static void __iomem *da850_psc_bases[] = {
@@ -1044,6 +1050,8 @@ static struct davinci_soc_info davinci_soc_info_da850 = {
 	.gpio_irq		= IRQ_DA8XX_GPIO0,
 	.serial_dev		= &da8xx_serial_device,
 	.emac_pdata		= &da8xx_emac_pdata,
+	.sram_dma		= DA8XX_ARM_RAM_BASE,
+	.sram_len		= SZ_8K,
 };
 
 void __init da850_init(void)

commit 7aad472bb5602242113718fc170e61b127460cbe
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Mon Nov 16 17:21:38 2009 +0530

    davinci: da850/omap-l138: unlock PLL registers during init
    
    On omap-l1 devices the PLL registers can be locked from
    writes. Currently the cpufreq rate setting code unlocks
    PLL0 before the write actually happens. With suspend
    support getting added PLL1 registers need be be unlocked
    as well.
    
    To facilitate this, unlock both PLLs during the init time
    itself.
    
    This also obviates the need to unlock PLL registers for
    each CPUFreq transtition.
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 4f84ab4bb221..fcfde2a72f8f 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -40,6 +40,7 @@
 #define DA850_REF_FREQ		24000000
 
 #define CFGCHIP3_ASYNC3_CLKSRC	BIT(4)
+#define CFGCHIP3_PLL1_MASTER_LOCK	BIT(5)
 #define CFGCHIP0_PLL_MASTER_LOCK	BIT(4)
 
 static int da850_set_armrate(struct clk *clk, unsigned long rate);
@@ -987,7 +988,6 @@ static int da850_set_pll0rate(struct clk *clk, unsigned long index)
 	unsigned int prediv, mult, postdiv;
 	struct da850_opp *opp;
 	struct pll_data *pll = clk->pll_data;
-	unsigned int v;
 	int ret;
 
 	opp = (struct da850_opp *) da850_freq_table[index].index;
@@ -995,11 +995,6 @@ static int da850_set_pll0rate(struct clk *clk, unsigned long index)
 	mult = opp->mult;
 	postdiv = opp->postdiv;
 
-	/* Unlock writing to PLL registers */
-	v = __raw_readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP0_REG));
-	v &= ~CFGCHIP0_PLL_MASTER_LOCK;
-	__raw_writel(v, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP0_REG));
-
 	ret = davinci_set_pllrate(pll, prediv, mult, postdiv);
 	if (WARN_ON(ret))
 		return ret;
@@ -1053,6 +1048,8 @@ static struct davinci_soc_info davinci_soc_info_da850 = {
 
 void __init da850_init(void)
 {
+	unsigned int v;
+
 	da8xx_syscfg0_base = ioremap(DA8XX_SYSCFG0_BASE, SZ_4K);
 	if (WARN(!da8xx_syscfg0_base, "Unable to map syscfg0 module"))
 		return;
@@ -1075,4 +1072,14 @@ void __init da850_init(void)
 	 * be any noticible change even in non-DVFS use cases.
 	 */
 	da850_set_async3_src(1);
+
+	/* Unlock writing to PLL0 registers */
+	v = __raw_readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP0_REG));
+	v &= ~CFGCHIP0_PLL_MASTER_LOCK;
+	__raw_writel(v, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP0_REG));
+
+	/* Unlock writing to PLL1 registers */
+	v = __raw_readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));
+	v &= ~CFGCHIP3_PLL1_MASTER_LOCK;
+	__raw_writel(v, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));
 }

commit d2de05827cce9438dfc61d5a4cf13b6ca82ebdee
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Mon Nov 16 17:21:32 2009 +0530

    davinci: da8xx/omapl1: add support for the second sysconfig module
    
    OMAP-L138 adds a second SYSCFG region having useful functionality
    like deep sleep, pull up/down control and SATA clock stop.
    
    This patch makes provision for accessing registers from second
    SYSCFG region in da8xx code.
    
    Note that OMAP-L137 has a single SYSCFG region.
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 717806c6cef9..4f84ab4bb221 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -838,12 +838,12 @@ static void da850_set_async3_src(int pllnum)
 		}
        }
 
-	v = __raw_readl(DA8XX_SYSCFG_VIRT(DA8XX_CFGCHIP3_REG));
+	v = __raw_readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));
 	if (pllnum)
 		v |= CFGCHIP3_ASYNC3_CLKSRC;
 	else
 		v &= ~CFGCHIP3_ASYNC3_CLKSRC;
-	__raw_writel(v, DA8XX_SYSCFG_VIRT(DA8XX_CFGCHIP3_REG));
+	__raw_writel(v, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));
 }
 
 #ifdef CONFIG_CPU_FREQ
@@ -996,9 +996,9 @@ static int da850_set_pll0rate(struct clk *clk, unsigned long index)
 	postdiv = opp->postdiv;
 
 	/* Unlock writing to PLL registers */
-	v = __raw_readl(DA8XX_SYSCFG_VIRT(DA8XX_CFGCHIP0_REG));
+	v = __raw_readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP0_REG));
 	v &= ~CFGCHIP0_PLL_MASTER_LOCK;
-	__raw_writel(v, DA8XX_SYSCFG_VIRT(DA8XX_CFGCHIP0_REG));
+	__raw_writel(v, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP0_REG));
 
 	ret = davinci_set_pllrate(pll, prediv, mult, postdiv);
 	if (WARN_ON(ret))
@@ -1053,13 +1053,17 @@ static struct davinci_soc_info davinci_soc_info_da850 = {
 
 void __init da850_init(void)
 {
-	da8xx_syscfg_base = ioremap(DA8XX_SYSCFG_BASE, SZ_4K);
-	if (WARN(!da8xx_syscfg_base, "Unable to map syscfg module"))
+	da8xx_syscfg0_base = ioremap(DA8XX_SYSCFG0_BASE, SZ_4K);
+	if (WARN(!da8xx_syscfg0_base, "Unable to map syscfg0 module"))
+		return;
+
+	da8xx_syscfg1_base = ioremap(DA8XX_SYSCFG1_BASE, SZ_4K);
+	if (WARN(!da8xx_syscfg1_base, "Unable to map syscfg1 module"))
 		return;
 
 	davinci_soc_info_da850.jtag_id_base =
-					DA8XX_SYSCFG_VIRT(DA8XX_JTAG_ID_REG);
-	davinci_soc_info_da850.pinmux_base = DA8XX_SYSCFG_VIRT(0x120);
+					DA8XX_SYSCFG0_VIRT(DA8XX_JTAG_ID_REG);
+	davinci_soc_info_da850.pinmux_base = DA8XX_SYSCFG0_VIRT(0x120);
 
 	davinci_common_init(&davinci_soc_info_da850);
 

commit 13d5e27a4482e43bea9073706033c84cd873b5ca
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Thu Oct 22 15:12:16 2009 +0530

    davinci: DA850/OMAP-L138: avoid using separate initcall for initializing regulator
    
    Using a device_initcall() for initializing the voltage regulator
    on DA850 is not such a good idea because it gets called for all
    platforms - even those who do not have a regulator implemented.
    This leads to a big fat warning message during boot-up when
    regulator cannot be found.
    
    Instead, tie initialization of voltage regulator to cpufreq init.
    Define a platform specific init call which in case of DA850 gets
    used for initializing the regulator. On other future platforms it
    can be used for other purposes.
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 0f27c93545bf..717806c6cef9 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -907,8 +907,39 @@ static struct cpufreq_frequency_table da850_freq_table[] = {
 	},
 };
 
+#ifdef CONFIG_REGULATOR
+static struct regulator *cvdd;
+
+static int da850_set_voltage(unsigned int index)
+{
+	struct da850_opp *opp;
+
+	if (!cvdd)
+		return -ENODEV;
+
+	opp = (struct da850_opp *) da850_freq_table[index].index;
+
+	return regulator_set_voltage(cvdd, opp->cvdd_min, opp->cvdd_max);
+}
+
+static int da850_regulator_init(void)
+{
+	cvdd = regulator_get(NULL, "cvdd");
+	if (WARN(IS_ERR(cvdd), "Unable to obtain voltage regulator for CVDD;"
+					" voltage scaling unsupported\n")) {
+		return PTR_ERR(cvdd);
+	}
+
+	return 0;
+}
+#endif
+
 static struct davinci_cpufreq_config cpufreq_info = {
 	.freq_table = &da850_freq_table[0],
+#ifdef CONFIG_REGULATOR
+	.init = da850_regulator_init,
+	.set_voltage = da850_set_voltage,
+#endif
 };
 
 static struct platform_device da850_cpufreq_device = {
@@ -997,39 +1028,6 @@ static int da850_round_armrate(struct clk *clk, unsigned long rate)
 }
 #endif
 
-#ifdef CONFIG_REGULATOR
-static struct regulator *cvdd;
-
-static int da850_set_voltage(unsigned int index)
-{
-	struct da850_opp *opp;
-
-	if (!cvdd)
-		return -ENODEV;
-
-	opp = (struct da850_opp *) da850_freq_table[index].index;
-
-	return regulator_set_voltage(cvdd, opp->cvdd_min, opp->cvdd_max);
-}
-
-static int __init da850_regulator_init(void)
-{
-	int ret = 0;
-
-	cvdd = regulator_get(NULL, "cvdd");
-	if (WARN(IS_ERR(cvdd), "Unable to obtain voltage regulator for CVDD;"
-					" voltage scaling unsupported\n")) {
-		ret = PTR_ERR(cvdd);
-		goto out;
-	}
-
-	cpufreq_info.set_voltage = da850_set_voltage;
-
-out:
-	return ret;
-}
-device_initcall(da850_regulator_init);
-#endif
 
 static struct davinci_soc_info davinci_soc_info_da850 = {
 	.io_desc		= da850_io_desc,

commit 51157ed8c5983c2c2be527d46faa42387f3e3e3c
Author: Chaithrika U S <chaithrika@ti.com>
Date:   Tue Oct 13 17:32:43 2009 +0530

    davinci: DA850/OMAP-L138: Set ASYNC3 domain flag for McASP
    
    In the McASP clock definition add a flag to indicate that the peripheral clock
    belongs to ASYNC3 clock domain.
    
    Signed-off-by: Chaithrika U S <chaithrika@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index bd79288e22ac..0f27c93545bf 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -310,6 +310,7 @@ static struct clk mcasp_clk = {
 	.parent		= &pll0_sysclk2,
 	.lpsc		= DA8XX_LPSC1_McASP0,
 	.gpsc		= 1,
+	.flags		= DA850_CLK_ASYNC3,
 };
 
 static struct clk lcdc_clk = {

commit 42d399e4189346b495fec8a9a267e8b7f744ee48
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Fri Oct 2 22:05:29 2009 +0400

    DaVinci: remove unneeded #include's
    
    There have accumulated quite a lot of them after the code reorganizations...
    
    In several cases I had to replace #include <linux/dma-mapping.h> which wasn't
    needed directly but happened to #include <linux/err.h> which was needed.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index b804d5792346..bd79288e22ac 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -11,7 +11,6 @@
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
  */
-#include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/clk.h>
 #include <linux/platform_device.h>
@@ -20,9 +19,7 @@
 
 #include <asm/mach/map.h>
 
-#include <mach/clock.h>
 #include <mach/psc.h>
-#include <mach/mux.h>
 #include <mach/irqs.h>
 #include <mach/cputype.h>
 #include <mach/common.h>

commit 2206771c4359e236308122ad3fed7f5d91586fd7
Author: Chaithrika U S <chaithrika@ti.com>
Date:   Wed Sep 30 17:00:53 2009 -0400

    davinci: RMII support for DA850/OMAP-L138 EVM
    
    DA850/OMAP-L138 EVM has a RMII Ethernet PHY on the UI daughter card. The PHY
    is enabled by proper programming of the IO Expander (TCA6416) ports. Also for
    RMII PHY to work, the MDIO clock of MII PHY has to be disabled since both the
    PHYs have the same address. This is done via the GPIO2[6] pin. This patch adds
    support for RMII PHY.
    
    This patch also adds a menuconfig option to select one or no peripheral
    connected to expander. Currently, sub-options in this menu are RMII and no
    peripheral.This menuconfig option is similar to the one present for UI card on
    DA830/OMAP-L137 EVM.
    
    Signed-off-by: Chaithrika U S <chaithrika@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 1d6d8b42a624..b804d5792346 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -422,6 +422,14 @@ static const struct mux_config da850_pins[] = {
 	MUX_CFG(DA850, MII_RXD_0,	3,	28,	15,	8,	false)
 	MUX_CFG(DA850, MDIO_CLK,	4,	0,	15,	8,	false)
 	MUX_CFG(DA850, MDIO_D,		4,	4,	15,	8,	false)
+	MUX_CFG(DA850, RMII_TXD_0,	14,	12,	15,	8,	false)
+	MUX_CFG(DA850, RMII_TXD_1,	14,	8,	15,	8,	false)
+	MUX_CFG(DA850, RMII_TXEN,	14,	16,	15,	8,	false)
+	MUX_CFG(DA850, RMII_CRS_DV,	15,	4,	15,	8,	false)
+	MUX_CFG(DA850, RMII_RXD_0,	14,	24,	15,	8,	false)
+	MUX_CFG(DA850, RMII_RXD_1,	14,	20,	15,	8,	false)
+	MUX_CFG(DA850, RMII_RXER,	14,	28,	15,	8,	false)
+	MUX_CFG(DA850, RMII_MHZ_50_CLK,	15,	0,	15,	0,	false)
 	/* McASP function */
 	MUX_CFG(DA850,	ACLKR,		0,	0,	15,	1,	false)
 	MUX_CFG(DA850,	ACLKX,		0,	4,	15,	1,	false)
@@ -524,6 +532,7 @@ static const struct mux_config da850_pins[] = {
 	MUX_CFG(DA850, EMA_WAIT_1,	6,	24,	15,	1,	false)
 	MUX_CFG(DA850, NEMA_CS_2,	7,	0,	15,	1,	false)
 	/* GPIO function */
+	MUX_CFG(DA850, GPIO2_6,		6,	4,	15,	8,	false)
 	MUX_CFG(DA850, GPIO2_8,		5,	28,	15,	8,	false)
 	MUX_CFG(DA850, GPIO2_15,	5,	0,	15,	8,	false)
 	MUX_CFG(DA850, GPIO4_0,		10,	28,	15,	8,	false)
@@ -565,6 +574,14 @@ const short da850_cpgmac_pins[] __initdata = {
 	-1
 };
 
+const short da850_rmii_pins[] __initdata = {
+	DA850_RMII_TXD_0, DA850_RMII_TXD_1, DA850_RMII_TXEN,
+	DA850_RMII_CRS_DV, DA850_RMII_RXD_0, DA850_RMII_RXD_1,
+	DA850_RMII_RXER, DA850_RMII_MHZ_50_CLK, DA850_MDIO_CLK,
+	DA850_MDIO_D,
+	-1
+};
+
 const short da850_mcasp_pins[] __initdata = {
 	DA850_AHCLKX, DA850_ACLKX, DA850_AFSX,
 	DA850_AHCLKR, DA850_ACLKR, DA850_AFSR, DA850_AMUTE,

commit 789a785ee4351a0b425d1b3702d40aeb71745ff3
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Wed Sep 30 19:48:03 2009 +0400

    davinci: DA8xx: rename 'psc_ctlr' field into 'gpsc'
    
    Replace badly chosen 'psc_ctlr' name of the 'struct clk' field (PSC already
    means "Power and Sleep Controller", so the '_ctlr' postfix makes the name
    tautological) with technically correct 'gpsc' (Global PSC -- which contains
    all the module registers).
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 0e1027ea8a40..1d6d8b42a624 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -224,16 +224,16 @@ static struct clk tpcc1_clk = {
 	.name		= "tpcc1",
 	.parent		= &pll0_sysclk2,
 	.lpsc		= DA850_LPSC1_TPCC1,
+	.gpsc		= 1,
 	.flags		= CLK_PSC | ALWAYS_ENABLED,
-	.psc_ctlr	= 1,
 };
 
 static struct clk tptc2_clk = {
 	.name		= "tptc2",
 	.parent		= &pll0_sysclk2,
 	.lpsc		= DA850_LPSC1_TPTC2,
+	.gpsc		= 1,
 	.flags		= ALWAYS_ENABLED,
-	.psc_ctlr	= 1,
 };
 
 static struct clk uart0_clk = {
@@ -246,16 +246,16 @@ static struct clk uart1_clk = {
 	.name		= "uart1",
 	.parent		= &pll0_sysclk2,
 	.lpsc		= DA8XX_LPSC1_UART1,
+	.gpsc		= 1,
 	.flags		= DA850_CLK_ASYNC3,
-	.psc_ctlr	= 1,
 };
 
 static struct clk uart2_clk = {
 	.name		= "uart2",
 	.parent		= &pll0_sysclk2,
 	.lpsc		= DA8XX_LPSC1_UART2,
+	.gpsc		= 1,
 	.flags		= DA850_CLK_ASYNC3,
-	.psc_ctlr	= 1,
 };
 
 static struct clk aintc_clk = {
@@ -269,22 +269,22 @@ static struct clk gpio_clk = {
 	.name		= "gpio",
 	.parent		= &pll0_sysclk4,
 	.lpsc		= DA8XX_LPSC1_GPIO,
-	.psc_ctlr	= 1,
+	.gpsc		= 1,
 };
 
 static struct clk i2c1_clk = {
 	.name		= "i2c1",
 	.parent		= &pll0_sysclk4,
 	.lpsc		= DA8XX_LPSC1_I2C,
-	.psc_ctlr	= 1,
+	.gpsc		= 1,
 };
 
 static struct clk emif3_clk = {
 	.name		= "emif3",
 	.parent		= &pll0_sysclk5,
 	.lpsc		= DA8XX_LPSC1_EMIF3C,
+	.gpsc		= 1,
 	.flags		= ALWAYS_ENABLED,
-	.psc_ctlr	= 1,
 };
 
 static struct clk arm_clk = {
@@ -305,21 +305,21 @@ static struct clk emac_clk = {
 	.name		= "emac",
 	.parent		= &pll0_sysclk4,
 	.lpsc		= DA8XX_LPSC1_CPGMAC,
-	.psc_ctlr	= 1,
+	.gpsc		= 1,
 };
 
 static struct clk mcasp_clk = {
 	.name		= "mcasp",
 	.parent		= &pll0_sysclk2,
 	.lpsc		= DA8XX_LPSC1_McASP0,
-	.psc_ctlr	= 1,
+	.gpsc		= 1,
 };
 
 static struct clk lcdc_clk = {
 	.name		= "lcdc",
 	.parent		= &pll0_sysclk2,
 	.lpsc		= DA8XX_LPSC1_LCDC,
-	.psc_ctlr	= 1,
+	.gpsc		= 1,
 };
 
 static struct clk mmcsd_clk = {

commit 35f9acd8bd13ba3d90998b5f31cae3e271309127
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Tue Sep 22 21:14:02 2009 +0530

    davinci: DA850/OMAP-L138: add voltage regulation support
    
    This patch adds support for regulating the CVDD voltage for the
    DA850/OMAP-L138 platform.
    
    The CVDD min and max values for each OPP have been obtained from
    section 5.2 "Recommended Operating Conditions" of SPRS586
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 49dcc71168c7..0e1027ea8a40 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -16,6 +16,7 @@
 #include <linux/clk.h>
 #include <linux/platform_device.h>
 #include <linux/cpufreq.h>
+#include <linux/regulator/consumer.h>
 
 #include <asm/mach/map.h>
 
@@ -844,6 +845,8 @@ struct da850_opp {
 	unsigned int	prediv;
 	unsigned int	mult;
 	unsigned int	postdiv;
+	unsigned int	cvdd_min; /* in uV */
+	unsigned int	cvdd_max; /* in uV */
 };
 
 static const struct da850_opp da850_opp_300 = {
@@ -851,6 +854,8 @@ static const struct da850_opp da850_opp_300 = {
 	.prediv		= 1,
 	.mult		= 25,
 	.postdiv	= 2,
+	.cvdd_min	= 1140000,
+	.cvdd_max	= 1320000,
 };
 
 static const struct da850_opp da850_opp_200 = {
@@ -858,6 +863,8 @@ static const struct da850_opp da850_opp_200 = {
 	.prediv		= 1,
 	.mult		= 25,
 	.postdiv	= 3,
+	.cvdd_min	= 1050000,
+	.cvdd_max	= 1160000,
 };
 
 static const struct da850_opp da850_opp_96 = {
@@ -865,6 +872,8 @@ static const struct da850_opp da850_opp_96 = {
 	.prediv		= 1,
 	.mult		= 20,
 	.postdiv	= 5,
+	.cvdd_min	= 950000,
+	.cvdd_max	= 1050000,
 };
 
 #define OPP(freq) 		\
@@ -973,6 +982,40 @@ static int da850_round_armrate(struct clk *clk, unsigned long rate)
 }
 #endif
 
+#ifdef CONFIG_REGULATOR
+static struct regulator *cvdd;
+
+static int da850_set_voltage(unsigned int index)
+{
+	struct da850_opp *opp;
+
+	if (!cvdd)
+		return -ENODEV;
+
+	opp = (struct da850_opp *) da850_freq_table[index].index;
+
+	return regulator_set_voltage(cvdd, opp->cvdd_min, opp->cvdd_max);
+}
+
+static int __init da850_regulator_init(void)
+{
+	int ret = 0;
+
+	cvdd = regulator_get(NULL, "cvdd");
+	if (WARN(IS_ERR(cvdd), "Unable to obtain voltage regulator for CVDD;"
+					" voltage scaling unsupported\n")) {
+		ret = PTR_ERR(cvdd);
+		goto out;
+	}
+
+	cpufreq_info.set_voltage = da850_set_voltage;
+
+out:
+	return ret;
+}
+device_initcall(da850_regulator_init);
+#endif
+
 static struct davinci_soc_info davinci_soc_info_da850 = {
 	.io_desc		= da850_io_desc,
 	.io_desc_num		= ARRAY_SIZE(da850_io_desc),

commit 683b1e1f0e6f7b2690c0ce76751ba8f26f0235c6
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Tue Sep 22 21:14:01 2009 +0530

    davinci: DA850/OMAP-L138: add frequency scaling support
    
    Adds basic frequency scaling support for DA850/OMAP-L138.
    
    Currently, frequency scaling only on PLL0 is supported. No scaling of PLL1
    as yet.
    
    Peripherals like MMC/SD which have a clock input synchronous with
    ARM clock will not work well since the clock will change behind their backs.
    Support for notification to such devices to adjust themselves to the
    new frequency will be added in later patches. Current defconfigs keep
    CPUFreq disabled so it will not affect normal operation.
    
    The OPP defintions assume clock input of 24MHz to the SoC. This is inline
    with hardcoding of input frequency in the <soc>.c files. At some point
    this will need to move into board dependent code as new boards appear with
    a different reference clock.
    
    Tested on OMAP-L138 EVM with ondemand governer and a shell script to
    vary processor load.
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index a62863c57459..49dcc71168c7 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -15,6 +15,7 @@
 #include <linux/init.h>
 #include <linux/clk.h>
 #include <linux/platform_device.h>
+#include <linux/cpufreq.h>
 
 #include <asm/mach/map.h>
 
@@ -26,6 +27,7 @@
 #include <mach/common.h>
 #include <mach/time.h>
 #include <mach/da8xx.h>
+#include <mach/cpufreq.h>
 
 #include "clock.h"
 #include "mux.h"
@@ -40,6 +42,11 @@
 #define DA850_REF_FREQ		24000000
 
 #define CFGCHIP3_ASYNC3_CLKSRC	BIT(4)
+#define CFGCHIP0_PLL_MASTER_LOCK	BIT(4)
+
+static int da850_set_armrate(struct clk *clk, unsigned long rate);
+static int da850_round_armrate(struct clk *clk, unsigned long rate);
+static int da850_set_pll0rate(struct clk *clk, unsigned long armrate);
 
 static struct pll_data pll0_data = {
 	.num		= 1,
@@ -57,6 +64,7 @@ static struct clk pll0_clk = {
 	.parent		= &ref_clk,
 	.pll_data	= &pll0_data,
 	.flags		= CLK_PLL,
+	.set_rate	= da850_set_pll0rate,
 };
 
 static struct clk pll0_aux_clk = {
@@ -283,6 +291,8 @@ static struct clk arm_clk = {
 	.parent		= &pll0_sysclk6,
 	.lpsc		= DA8XX_LPSC0_ARM,
 	.flags		= ALWAYS_ENABLED,
+	.set_rate	= da850_set_armrate,
+	.round_rate	= da850_round_armrate,
 };
 
 static struct clk rmii_clk = {
@@ -820,6 +830,149 @@ static void da850_set_async3_src(int pllnum)
 	__raw_writel(v, DA8XX_SYSCFG_VIRT(DA8XX_CFGCHIP3_REG));
 }
 
+#ifdef CONFIG_CPU_FREQ
+/*
+ * Notes:
+ * According to the TRM, minimum PLLM results in maximum power savings.
+ * The OPP definitions below should keep the PLLM as low as possible.
+ *
+ * The output of the PLLM must be between 400 to 600 MHz.
+ * This rules out prediv of anything but divide-by-one for 24Mhz OSC input.
+ */
+struct da850_opp {
+	unsigned int	freq;	/* in KHz */
+	unsigned int	prediv;
+	unsigned int	mult;
+	unsigned int	postdiv;
+};
+
+static const struct da850_opp da850_opp_300 = {
+	.freq		= 300000,
+	.prediv		= 1,
+	.mult		= 25,
+	.postdiv	= 2,
+};
+
+static const struct da850_opp da850_opp_200 = {
+	.freq		= 200000,
+	.prediv		= 1,
+	.mult		= 25,
+	.postdiv	= 3,
+};
+
+static const struct da850_opp da850_opp_96 = {
+	.freq		= 96000,
+	.prediv		= 1,
+	.mult		= 20,
+	.postdiv	= 5,
+};
+
+#define OPP(freq) 		\
+	{				\
+		.index = (unsigned int) &da850_opp_##freq,	\
+		.frequency = freq * 1000, \
+	}
+
+static struct cpufreq_frequency_table da850_freq_table[] = {
+	OPP(300),
+	OPP(200),
+	OPP(96),
+	{
+		.index		= 0,
+		.frequency	= CPUFREQ_TABLE_END,
+	},
+};
+
+static struct davinci_cpufreq_config cpufreq_info = {
+	.freq_table = &da850_freq_table[0],
+};
+
+static struct platform_device da850_cpufreq_device = {
+	.name			= "cpufreq-davinci",
+	.dev = {
+		.platform_data	= &cpufreq_info,
+	},
+};
+
+int __init da850_register_cpufreq(void)
+{
+	return platform_device_register(&da850_cpufreq_device);
+}
+
+static int da850_round_armrate(struct clk *clk, unsigned long rate)
+{
+	int i, ret = 0, diff;
+	unsigned int best = (unsigned int) -1;
+
+	rate /= 1000; /* convert to kHz */
+
+	for (i = 0; da850_freq_table[i].frequency != CPUFREQ_TABLE_END; i++) {
+		diff = da850_freq_table[i].frequency - rate;
+		if (diff < 0)
+			diff = -diff;
+
+		if (diff < best) {
+			best = diff;
+			ret = da850_freq_table[i].frequency;
+		}
+	}
+
+	return ret * 1000;
+}
+
+static int da850_set_armrate(struct clk *clk, unsigned long index)
+{
+	struct clk *pllclk = &pll0_clk;
+
+	return clk_set_rate(pllclk, index);
+}
+
+static int da850_set_pll0rate(struct clk *clk, unsigned long index)
+{
+	unsigned int prediv, mult, postdiv;
+	struct da850_opp *opp;
+	struct pll_data *pll = clk->pll_data;
+	unsigned int v;
+	int ret;
+
+	opp = (struct da850_opp *) da850_freq_table[index].index;
+	prediv = opp->prediv;
+	mult = opp->mult;
+	postdiv = opp->postdiv;
+
+	/* Unlock writing to PLL registers */
+	v = __raw_readl(DA8XX_SYSCFG_VIRT(DA8XX_CFGCHIP0_REG));
+	v &= ~CFGCHIP0_PLL_MASTER_LOCK;
+	__raw_writel(v, DA8XX_SYSCFG_VIRT(DA8XX_CFGCHIP0_REG));
+
+	ret = davinci_set_pllrate(pll, prediv, mult, postdiv);
+	if (WARN_ON(ret))
+		return ret;
+
+	return 0;
+}
+#else
+int __init da850_register_cpufreq(void)
+{
+	return 0;
+}
+
+static int da850_set_armrate(struct clk *clk, unsigned long rate)
+{
+	return -EINVAL;
+}
+
+static int da850_set_pll0rate(struct clk *clk, unsigned long armrate)
+{
+	return -EINVAL;
+}
+
+static int da850_round_armrate(struct clk *clk, unsigned long rate)
+{
+	return clk->rate;
+}
+#endif
+
 static struct davinci_soc_info davinci_soc_info_da850 = {
 	.io_desc		= da850_io_desc,
 	.io_desc_num		= ARRAY_SIZE(da850_io_desc),

commit 7761ef67930dac37f90aaf0ffcd6b1f473c07dfc
Author: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
Date:   Tue Sep 15 17:46:14 2009 -0400

    davinci: Correct the GPIO number for LCD panel power
    
    On the latest DA850/OMAP-L138 EVM (Beta) the GPIO pin
    number of LCD panel power has changed. This patch takes
    care of this change. Software will support only Beta
    versions of DA850/OMAP-L138 EVM.
    
    In the process, add the missing entry for data pin 0
    and remove the GPIO specific pins from da850_lcdcntl_pins
    structure. EVM specific muxing for LCD is being done in the
    board file now.
    
    Signed-off-by: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 575e9ccbb25f..a62863c57459 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -513,8 +513,8 @@ static const struct mux_config da850_pins[] = {
 	MUX_CFG(DA850, EMA_WAIT_1,	6,	24,	15,	1,	false)
 	MUX_CFG(DA850, NEMA_CS_2,	7,	0,	15,	1,	false)
 	/* GPIO function */
+	MUX_CFG(DA850, GPIO2_8,		5,	28,	15,	8,	false)
 	MUX_CFG(DA850, GPIO2_15,	5,	0,	15,	8,	false)
-	MUX_CFG(DA850, GPIO8_10,	18,	28,	15,	8,	false)
 	MUX_CFG(DA850, GPIO4_0,		10,	28,	15,	8,	false)
 	MUX_CFG(DA850, GPIO4_1,		10,	24,	15,	8,	false)
 #endif
@@ -562,12 +562,11 @@ const short da850_mcasp_pins[] __initdata = {
 };
 
 const short da850_lcdcntl_pins[] __initdata = {
-	DA850_LCD_D_1, DA850_LCD_D_2, DA850_LCD_D_3, DA850_LCD_D_4,
-	DA850_LCD_D_5, DA850_LCD_D_6, DA850_LCD_D_7, DA850_LCD_D_8,
-	DA850_LCD_D_9, DA850_LCD_D_10, DA850_LCD_D_11, DA850_LCD_D_12,
-	DA850_LCD_D_13, DA850_LCD_D_14, DA850_LCD_D_15, DA850_LCD_PCLK,
-	DA850_LCD_HSYNC, DA850_LCD_VSYNC, DA850_NLCD_AC_ENB_CS, DA850_GPIO2_15,
-	DA850_GPIO8_10,
+	DA850_LCD_D_0, DA850_LCD_D_1, DA850_LCD_D_2, DA850_LCD_D_3,
+	DA850_LCD_D_4, DA850_LCD_D_5, DA850_LCD_D_6, DA850_LCD_D_7,
+	DA850_LCD_D_8, DA850_LCD_D_9, DA850_LCD_D_10, DA850_LCD_D_11,
+	DA850_LCD_D_12, DA850_LCD_D_13, DA850_LCD_D_14, DA850_LCD_D_15,
+	DA850_LCD_PCLK, DA850_LCD_HSYNC, DA850_LCD_VSYNC, DA850_NLCD_AC_ENB_CS,
 	-1
 };
 

commit 5d36a3321bd77418cc55e05680efc35deeaba3f4
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Mon Aug 31 15:48:05 2009 +0530

    davinci: DA850/OMAP-L138: allow async3 source to be changed
    
    The patch allows Async3 clock source to be selected between PLL1 SYSCLK2
    and PLL0 SYSCLK2.
    
    Having Async3 source from PLL1 SYSCLK2 allows peripherals on that
    domain to remain unaffected by frequency scaling on PLL0.
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index f5c3a6a71315..575e9ccbb25f 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -30,12 +30,17 @@
 #include "clock.h"
 #include "mux.h"
 
+/* SoC specific clock flags */
+#define DA850_CLK_ASYNC3	BIT(16)
+
 #define DA850_PLL1_BASE		0x01e1a000
 #define DA850_TIMER64P2_BASE	0x01f0c000
 #define DA850_TIMER64P3_BASE	0x01f0d000
 
 #define DA850_REF_FREQ		24000000
 
+#define CFGCHIP3_ASYNC3_CLKSRC	BIT(4)
+
 static struct pll_data pll0_data = {
 	.num		= 1,
 	.phys_base	= DA8XX_PLL0_BASE,
@@ -232,6 +237,7 @@ static struct clk uart1_clk = {
 	.name		= "uart1",
 	.parent		= &pll0_sysclk2,
 	.lpsc		= DA8XX_LPSC1_UART1,
+	.flags		= DA850_CLK_ASYNC3,
 	.psc_ctlr	= 1,
 };
 
@@ -239,6 +245,7 @@ static struct clk uart2_clk = {
 	.name		= "uart2",
 	.parent		= &pll0_sysclk2,
 	.lpsc		= DA8XX_LPSC1_UART2,
+	.flags		= DA850_CLK_ASYNC3,
 	.psc_ctlr	= 1,
 };
 
@@ -790,6 +797,30 @@ static struct davinci_timer_info da850_timer_info = {
 	.clocksource_id	= T0_TOP,
 };
 
+static void da850_set_async3_src(int pllnum)
+{
+	struct clk *clk, *newparent = pllnum ? &pll1_sysclk2 : &pll0_sysclk2;
+	struct davinci_clk *c;
+	unsigned int v;
+	int ret;
+
+	for (c = da850_clks; c->lk.clk; c++) {
+		clk = c->lk.clk;
+		if (clk->flags & DA850_CLK_ASYNC3) {
+			ret = clk_set_parent(clk, newparent);
+			WARN(ret, "DA850: unable to re-parent clock %s",
+								clk->name);
+		}
+       }
+
+	v = __raw_readl(DA8XX_SYSCFG_VIRT(DA8XX_CFGCHIP3_REG));
+	if (pllnum)
+		v |= CFGCHIP3_ASYNC3_CLKSRC;
+	else
+		v &= ~CFGCHIP3_ASYNC3_CLKSRC;
+	__raw_writel(v, DA8XX_SYSCFG_VIRT(DA8XX_CFGCHIP3_REG));
+}
+
 static struct davinci_soc_info davinci_soc_info_da850 = {
 	.io_desc		= da850_io_desc,
 	.io_desc_num		= ARRAY_SIZE(da850_io_desc),
@@ -823,4 +854,13 @@ void __init da850_init(void)
 	davinci_soc_info_da850.pinmux_base = DA8XX_SYSCFG_VIRT(0x120);
 
 	davinci_common_init(&davinci_soc_info_da850);
+
+	/*
+	 * Move the clock source of Async3 domain to PLL1 SYSCLK2.
+	 * This helps keeping the peripherals on this domain insulated
+	 * from CPU frequency changes caused by DVFS. The firmware sets
+	 * both PLL0 and PLL1 to the same frequency so, there should not
+	 * be any noticible change even in non-DVFS use cases.
+	 */
+	da850_set_async3_src(1);
 }

commit cd87444802ddceaa2259bc5ac48c1d2e42a99a3f
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Mon Aug 31 15:48:00 2009 +0530

    davinci: DA8XX/OMAP-L1XX: JTAG ID register should offset from SYSCFG base
    
    This makes it clear that JTAG ID register is part of the
    SYSCFG module
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 54d1836f1224..f5c3a6a71315 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -793,7 +793,6 @@ static struct davinci_timer_info da850_timer_info = {
 static struct davinci_soc_info davinci_soc_info_da850 = {
 	.io_desc		= da850_io_desc,
 	.io_desc_num		= ARRAY_SIZE(da850_io_desc),
-	.jtag_id_base		= IO_ADDRESS(DA8XX_JTAG_ID_REG),
 	.ids			= da850_ids,
 	.ids_num		= ARRAY_SIZE(da850_ids),
 	.cpu_clks		= da850_clks,
@@ -819,6 +818,8 @@ void __init da850_init(void)
 	if (WARN(!da8xx_syscfg_base, "Unable to map syscfg module"))
 		return;
 
+	davinci_soc_info_da850.jtag_id_base =
+					DA8XX_SYSCFG_VIRT(DA8XX_JTAG_ID_REG);
 	davinci_soc_info_da850.pinmux_base = DA8XX_SYSCFG_VIRT(0x120);
 
 	davinci_common_init(&davinci_soc_info_da850);

commit 6a28adef21e551602023afc5bba330f8013556d8
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Mon Aug 31 15:47:59 2009 +0530

    davinci: DA8XX/OMAP-L1XX: Avoid use of IO_ADDRESS for SYSCFG module
    
    Avoid use of IO_ADDRESS() for SYSCFG module by doing an ioremap() instead.
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 18c33b6cbfdd..54d1836f1224 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -799,7 +799,6 @@ static struct davinci_soc_info davinci_soc_info_da850 = {
 	.cpu_clks		= da850_clks,
 	.psc_bases		= da850_psc_bases,
 	.psc_bases_num		= ARRAY_SIZE(da850_psc_bases),
-	.pinmux_base		= IO_ADDRESS(DA8XX_SYSCFG_BASE + 0x120),
 	.pinmux_pins		= da850_pins,
 	.pinmux_pins_num	= ARRAY_SIZE(da850_pins),
 	.intc_base		= (void __iomem *)DA8XX_CP_INTC_VIRT,
@@ -816,5 +815,11 @@ static struct davinci_soc_info davinci_soc_info_da850 = {
 
 void __init da850_init(void)
 {
+	da8xx_syscfg_base = ioremap(DA8XX_SYSCFG_BASE, SZ_4K);
+	if (WARN(!da8xx_syscfg_base, "Unable to map syscfg module"))
+		return;
+
+	davinci_soc_info_da850.pinmux_base = DA8XX_SYSCFG_VIRT(0x120);
+
 	davinci_common_init(&davinci_soc_info_da850);
 }

commit 3c60a66de662dca6e47951a78b73de1bf081e785
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Mon Aug 31 15:47:58 2009 +0530

    davinci: DA8XX/OMAP-L1XX: It's SYSCFG not BOOT_CFG
    
    Rename the DA8XX_BOOT_CFG_BASE macro to get it in line
    with the public documentation for these parts.
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 192d719a47df..18c33b6cbfdd 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -799,7 +799,7 @@ static struct davinci_soc_info davinci_soc_info_da850 = {
 	.cpu_clks		= da850_clks,
 	.psc_bases		= da850_psc_bases,
 	.psc_bases_num		= ARRAY_SIZE(da850_psc_bases),
-	.pinmux_base		= IO_ADDRESS(DA8XX_BOOT_CFG_BASE + 0x120),
+	.pinmux_base		= IO_ADDRESS(DA8XX_SYSCFG_BASE + 0x120),
 	.pinmux_pins		= da850_pins,
 	.pinmux_pins_num	= ARRAY_SIZE(da850_pins),
 	.intc_base		= (void __iomem *)DA8XX_CP_INTC_VIRT,

commit 7c5ec6095a7d29c89ee050281faa068a374a5ac6
Author: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
Date:   Thu Aug 13 17:36:25 2009 -0400

    davinci: Add NOR flash support for da850/omap-l138
    
    This patch adds platform data for the 8MB NOR flash
    found on da850/omap-l138 EVM. Both NOR and NAND can
    co-exist on da850/omap-l138 as they are using different
    chip selects.
    
    Signed-off-by: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index db4209413450..192d719a47df 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -471,6 +471,40 @@ static const struct mux_config da850_pins[] = {
 	MUX_CFG(DA850, NEMA_CS_4,	7,	8,	15,	1,	false)
 	MUX_CFG(DA850, NEMA_WE,		7,	16,	15,	1,	false)
 	MUX_CFG(DA850, NEMA_OE,		7,	20,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_0,		12,	28,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_3,		12,	16,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_4,		12,	12,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_5,		12,	8,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_6,		12,	4,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_7,		12,	0,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_8,		11,	28,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_9,		11,	24,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_10,	11,	20,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_11,	11,	16,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_12,	11,	12,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_13,	11,	8,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_14,	11,	4,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_15,	11,	0,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_16,	10,	28,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_17,	10,	24,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_18,	10,	20,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_19,	10,	16,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_20,	10,	12,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_21,	10,	8,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_22,	10,	4,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_23,	10,	0,	15,	1,	false)
+	MUX_CFG(DA850, EMA_D_8,		8,	28,	15,	1,	false)
+	MUX_CFG(DA850, EMA_D_9,		8,	24,	15,	1,	false)
+	MUX_CFG(DA850, EMA_D_10,	8,	20,	15,	1,	false)
+	MUX_CFG(DA850, EMA_D_11,	8,	16,	15,	1,	false)
+	MUX_CFG(DA850, EMA_D_12,	8,	12,	15,	1,	false)
+	MUX_CFG(DA850, EMA_D_13,	8,	8,	15,	1,	false)
+	MUX_CFG(DA850, EMA_D_14,	8,	4,	15,	1,	false)
+	MUX_CFG(DA850, EMA_D_15,	8,	0,	15,	1,	false)
+	MUX_CFG(DA850, EMA_BA_1,	5,	24,	15,	1,	false)
+	MUX_CFG(DA850, EMA_CLK,		6,	0,	15,	1,	false)
+	MUX_CFG(DA850, EMA_WAIT_1,	6,	24,	15,	1,	false)
+	MUX_CFG(DA850, NEMA_CS_2,	7,	0,	15,	1,	false)
 	/* GPIO function */
 	MUX_CFG(DA850, GPIO2_15,	5,	0,	15,	8,	false)
 	MUX_CFG(DA850, GPIO8_10,	18,	28,	15,	8,	false)
@@ -545,6 +579,22 @@ const short da850_nand_pins[] __initdata = {
 	-1
 };
 
+const short da850_nor_pins[] __initdata = {
+	DA850_EMA_BA_1, DA850_EMA_CLK, DA850_EMA_WAIT_1, DA850_NEMA_CS_2,
+	DA850_NEMA_WE, DA850_NEMA_OE, DA850_EMA_D_0, DA850_EMA_D_1,
+	DA850_EMA_D_2, DA850_EMA_D_3, DA850_EMA_D_4, DA850_EMA_D_5,
+	DA850_EMA_D_6, DA850_EMA_D_7, DA850_EMA_D_8, DA850_EMA_D_9,
+	DA850_EMA_D_10, DA850_EMA_D_11, DA850_EMA_D_12, DA850_EMA_D_13,
+	DA850_EMA_D_14, DA850_EMA_D_15, DA850_EMA_A_0, DA850_EMA_A_1,
+	DA850_EMA_A_2, DA850_EMA_A_3, DA850_EMA_A_4, DA850_EMA_A_5,
+	DA850_EMA_A_6, DA850_EMA_A_7, DA850_EMA_A_8, DA850_EMA_A_9,
+	DA850_EMA_A_10, DA850_EMA_A_11, DA850_EMA_A_12, DA850_EMA_A_13,
+	DA850_EMA_A_14, DA850_EMA_A_15, DA850_EMA_A_16, DA850_EMA_A_17,
+	DA850_EMA_A_18, DA850_EMA_A_19, DA850_EMA_A_20, DA850_EMA_A_21,
+	DA850_EMA_A_22, DA850_EMA_A_23,
+	-1
+};
+
 /* FIQ are pri 0-1; otherwise 2-7, with 7 lowest priority */
 static u8 da850_default_priorities[DA850_N_CP_INTC_IRQ] = {
 	[IRQ_DA8XX_COMMTX]		= 7,

commit 38beb929f2c33a37bf3af6103c064a9edfbe242b
Author: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
Date:   Thu Aug 13 16:21:11 2009 -0400

    davinci: Add NAND flash support for DA850/OMAP-L138
    
    This patch adds platform data for the 512MB NAND Flash
    found on DA850/OMAP-L138 EVM. Currently it supports
    only 1-bit ECC.
    
    Signed-off-by: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 9debd57deb71..db4209413450 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -310,6 +310,13 @@ static struct clk mmcsd_clk = {
 	.lpsc		= DA8XX_LPSC0_MMC_SD,
 };
 
+static struct clk aemif_clk = {
+	.name		= "aemif",
+	.parent		= &pll0_sysclk3,
+	.lpsc		= DA8XX_LPSC0_EMIF25,
+	.flags		= ALWAYS_ENABLED,
+};
+
 static struct davinci_clk da850_clks[] = {
 	CLK(NULL,		"ref",		&ref_clk),
 	CLK(NULL,		"pll0",		&pll0_clk),
@@ -350,6 +357,7 @@ static struct davinci_clk da850_clks[] = {
 	CLK("davinci-mcasp.0",	NULL,		&mcasp_clk),
 	CLK("da8xx_lcdc.0",	NULL,		&lcdc_clk),
 	CLK("davinci_mmc.0",	NULL,		&mmcsd_clk),
+	CLK(NULL,		"aemif",	&aemif_clk),
 	CLK(NULL,		NULL,		NULL),
 };
 
@@ -448,6 +456,21 @@ static const struct mux_config da850_pins[] = {
 	MUX_CFG(DA850, MMCSD0_DAT_3,	10,	20,	15,	2,	false)
 	MUX_CFG(DA850, MMCSD0_CLK,	10,	0,	15,	2,	false)
 	MUX_CFG(DA850, MMCSD0_CMD,	10,	4,	15,	2,	false)
+	/* EMIF2.5/EMIFA function */
+	MUX_CFG(DA850, EMA_D_7,		9,	0,	15,	1,	false)
+	MUX_CFG(DA850, EMA_D_6,		9,	4,	15,	1,	false)
+	MUX_CFG(DA850, EMA_D_5,		9,	8,	15,	1,	false)
+	MUX_CFG(DA850, EMA_D_4,		9,	12,	15,	1,	false)
+	MUX_CFG(DA850, EMA_D_3,		9,	16,	15,	1,	false)
+	MUX_CFG(DA850, EMA_D_2,		9,	20,	15,	1,	false)
+	MUX_CFG(DA850, EMA_D_1,		9,	24,	15,	1,	false)
+	MUX_CFG(DA850, EMA_D_0,		9,	28,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_1,		12,	24,	15,	1,	false)
+	MUX_CFG(DA850, EMA_A_2,		12,	20,	15,	1,	false)
+	MUX_CFG(DA850, NEMA_CS_3,	7,	4,	15,	1,	false)
+	MUX_CFG(DA850, NEMA_CS_4,	7,	8,	15,	1,	false)
+	MUX_CFG(DA850, NEMA_WE,		7,	16,	15,	1,	false)
+	MUX_CFG(DA850, NEMA_OE,		7,	20,	15,	1,	false)
 	/* GPIO function */
 	MUX_CFG(DA850, GPIO2_15,	5,	0,	15,	8,	false)
 	MUX_CFG(DA850, GPIO8_10,	18,	28,	15,	8,	false)
@@ -514,6 +537,14 @@ const short da850_mmcsd0_pins[] __initdata = {
 	-1
 };
 
+const short da850_nand_pins[] __initdata = {
+	DA850_EMA_D_7, DA850_EMA_D_6, DA850_EMA_D_5, DA850_EMA_D_4,
+	DA850_EMA_D_3, DA850_EMA_D_2, DA850_EMA_D_1, DA850_EMA_D_0,
+	DA850_EMA_A_1, DA850_EMA_A_2, DA850_NEMA_CS_3, DA850_NEMA_CS_4,
+	DA850_NEMA_WE, DA850_NEMA_OE,
+	-1
+};
+
 /* FIQ are pri 0-1; otherwise 2-7, with 7 lowest priority */
 static u8 da850_default_priorities[DA850_N_CP_INTC_IRQ] = {
 	[IRQ_DA8XX_COMMTX]		= 7,

commit 700691f27ed9b0891cece9032e4de8c0b482c625
Author: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
Date:   Thu Aug 13 15:16:23 2009 -0400

    davinci: Add MMC/SD support for da850/omap-l138
    
    There are two instances of MMC/SD on da850/omap-l138.
    Connector for the first instance is available on the
    EVM. This patch adds support for this instance.
    
    This patch also adds support for card detect and write
    protect switches on da850/omap-l138 EVM.
    
    Signed-off-by: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index e6e605bf1516..9debd57deb71 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -304,6 +304,12 @@ static struct clk lcdc_clk = {
 	.psc_ctlr	= 1,
 };
 
+static struct clk mmcsd_clk = {
+	.name		= "mmcsd",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC0_MMC_SD,
+};
+
 static struct davinci_clk da850_clks[] = {
 	CLK(NULL,		"ref",		&ref_clk),
 	CLK(NULL,		"pll0",		&pll0_clk),
@@ -343,6 +349,7 @@ static struct davinci_clk da850_clks[] = {
 	CLK("davinci_emac.1",	NULL,		&emac_clk),
 	CLK("davinci-mcasp.0",	NULL,		&mcasp_clk),
 	CLK("da8xx_lcdc.0",	NULL,		&lcdc_clk),
+	CLK("davinci_mmc.0",	NULL,		&mmcsd_clk),
 	CLK(NULL,		NULL,		NULL),
 };
 
@@ -434,9 +441,18 @@ static const struct mux_config da850_pins[] = {
 	MUX_CFG(DA850, LCD_HSYNC,	19,	0,	15,	2,	false)
 	MUX_CFG(DA850, LCD_VSYNC,	19,	4,	15,	2,	false)
 	MUX_CFG(DA850, NLCD_AC_ENB_CS,	19,	24,	15,	2,	false)
+	/* MMC/SD0 function */
+	MUX_CFG(DA850, MMCSD0_DAT_0,	10,	8,	15,	2,	false)
+	MUX_CFG(DA850, MMCSD0_DAT_1,	10,	12,	15,	2,	false)
+	MUX_CFG(DA850, MMCSD0_DAT_2,	10,	16,	15,	2,	false)
+	MUX_CFG(DA850, MMCSD0_DAT_3,	10,	20,	15,	2,	false)
+	MUX_CFG(DA850, MMCSD0_CLK,	10,	0,	15,	2,	false)
+	MUX_CFG(DA850, MMCSD0_CMD,	10,	4,	15,	2,	false)
 	/* GPIO function */
 	MUX_CFG(DA850, GPIO2_15,	5,	0,	15,	8,	false)
 	MUX_CFG(DA850, GPIO8_10,	18,	28,	15,	8,	false)
+	MUX_CFG(DA850, GPIO4_0,		10,	28,	15,	8,	false)
+	MUX_CFG(DA850, GPIO4_1,		10,	24,	15,	8,	false)
 #endif
 };
 
@@ -491,6 +507,13 @@ const short da850_lcdcntl_pins[] __initdata = {
 	-1
 };
 
+const short da850_mmcsd0_pins[] __initdata = {
+	DA850_MMCSD0_DAT_0, DA850_MMCSD0_DAT_1, DA850_MMCSD0_DAT_2,
+	DA850_MMCSD0_DAT_3, DA850_MMCSD0_CLK, DA850_MMCSD0_CMD,
+	DA850_GPIO4_0, DA850_GPIO4_1,
+	-1
+};
+
 /* FIQ are pri 0-1; otherwise 2-7, with 7 lowest priority */
 static u8 da850_default_priorities[DA850_N_CP_INTC_IRQ] = {
 	[IRQ_DA8XX_COMMTX]		= 7,

commit 5cbdf276bd9d9cd3cb9616f8253390096c1a237f
Author: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
Date:   Thu Aug 13 14:33:14 2009 -0400

    davinci: Add platform support for da850/omap-l138 GLCD
    
    This patch adds platform support for the graphic display
    (Sharp LK043T1DG01) found on DA850/OMAP-L138 based EVM.
    
    Signed-off-by: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index e440c09c5576..e6e605bf1516 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -297,6 +297,13 @@ static struct clk mcasp_clk = {
 	.psc_ctlr	= 1,
 };
 
+static struct clk lcdc_clk = {
+	.name		= "lcdc",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC1_LCDC,
+	.psc_ctlr	= 1,
+};
+
 static struct davinci_clk da850_clks[] = {
 	CLK(NULL,		"ref",		&ref_clk),
 	CLK(NULL,		"pll0",		&pll0_clk),
@@ -335,6 +342,7 @@ static struct davinci_clk da850_clks[] = {
 	CLK(NULL,		"rmii",		&rmii_clk),
 	CLK("davinci_emac.1",	NULL,		&emac_clk),
 	CLK("davinci-mcasp.0",	NULL,		&mcasp_clk),
+	CLK("da8xx_lcdc.0",	NULL,		&lcdc_clk),
 	CLK(NULL,		NULL,		NULL),
 };
 
@@ -405,6 +413,30 @@ static const struct mux_config da850_pins[] = {
 	MUX_CFG(DA850,	AXR_2,		2,	20,	15,	1,	false)
 	MUX_CFG(DA850,	AXR_1,		2,	24,	15,	1,	false)
 	MUX_CFG(DA850,	AXR_0,		2,	28,	15,	1,	false)
+	/* LCD function */
+	MUX_CFG(DA850, LCD_D_7,		16,	8,	15,	2,	false)
+	MUX_CFG(DA850, LCD_D_6,		16,	12,	15,	2,	false)
+	MUX_CFG(DA850, LCD_D_5,		16,	16,	15,	2,	false)
+	MUX_CFG(DA850, LCD_D_4,		16,	20,	15,	2,	false)
+	MUX_CFG(DA850, LCD_D_3,		16,	24,	15,	2,	false)
+	MUX_CFG(DA850, LCD_D_2,		16,	28,	15,	2,	false)
+	MUX_CFG(DA850, LCD_D_1,		17,	0,	15,	2,	false)
+	MUX_CFG(DA850, LCD_D_0,		17,	4,	15,	2,	false)
+	MUX_CFG(DA850, LCD_D_15,	17,	8,	15,	2,	false)
+	MUX_CFG(DA850, LCD_D_14,	17,	12,	15,	2,	false)
+	MUX_CFG(DA850, LCD_D_13,	17,	16,	15,	2,	false)
+	MUX_CFG(DA850, LCD_D_12,	17,	20,	15,	2,	false)
+	MUX_CFG(DA850, LCD_D_11,	17,	24,	15,	2,	false)
+	MUX_CFG(DA850, LCD_D_10,	17,	28,	15,	2,	false)
+	MUX_CFG(DA850, LCD_D_9,		18,	0,	15,	2,	false)
+	MUX_CFG(DA850, LCD_D_8,		18,	4,	15,	2,	false)
+	MUX_CFG(DA850, LCD_PCLK,	18,	24,	15,	2,	false)
+	MUX_CFG(DA850, LCD_HSYNC,	19,	0,	15,	2,	false)
+	MUX_CFG(DA850, LCD_VSYNC,	19,	4,	15,	2,	false)
+	MUX_CFG(DA850, NLCD_AC_ENB_CS,	19,	24,	15,	2,	false)
+	/* GPIO function */
+	MUX_CFG(DA850, GPIO2_15,	5,	0,	15,	8,	false)
+	MUX_CFG(DA850, GPIO8_10,	18,	28,	15,	8,	false)
 #endif
 };
 
@@ -449,6 +481,16 @@ const short da850_mcasp_pins[] __initdata = {
 	-1
 };
 
+const short da850_lcdcntl_pins[] __initdata = {
+	DA850_LCD_D_1, DA850_LCD_D_2, DA850_LCD_D_3, DA850_LCD_D_4,
+	DA850_LCD_D_5, DA850_LCD_D_6, DA850_LCD_D_7, DA850_LCD_D_8,
+	DA850_LCD_D_9, DA850_LCD_D_10, DA850_LCD_D_11, DA850_LCD_D_12,
+	DA850_LCD_D_13, DA850_LCD_D_14, DA850_LCD_D_15, DA850_LCD_PCLK,
+	DA850_LCD_HSYNC, DA850_LCD_VSYNC, DA850_NLCD_AC_ENB_CS, DA850_GPIO2_15,
+	DA850_GPIO8_10,
+	-1
+};
+
 /* FIQ are pri 0-1; otherwise 2-7, with 7 lowest priority */
 static u8 da850_default_priorities[DA850_N_CP_INTC_IRQ] = {
 	[IRQ_DA8XX_COMMTX]		= 7,

commit 491214e1f8129844289869bb6c231dc4542b11e3
Author: Chaithrika U S <chaithrika@ti.com>
Date:   Tue Aug 11 17:03:25 2009 -0400

    davinci: Audio support for DA850/OMAP-L138 EVM
    
    Define resources for McASP used on DA850/OMAP-L138 EVM, add platform
    device defintion and Pin Mux configurations.
    
    Signed-off-by: Chaithrika U S <chaithrika@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index c5efc515df4f..e440c09c5576 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -290,6 +290,13 @@ static struct clk emac_clk = {
 	.psc_ctlr	= 1,
 };
 
+static struct clk mcasp_clk = {
+	.name		= "mcasp",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC1_McASP0,
+	.psc_ctlr	= 1,
+};
+
 static struct davinci_clk da850_clks[] = {
 	CLK(NULL,		"ref",		&ref_clk),
 	CLK(NULL,		"pll0",		&pll0_clk),
@@ -327,6 +334,7 @@ static struct davinci_clk da850_clks[] = {
 	CLK(NULL,		"arm",		&arm_clk),
 	CLK(NULL,		"rmii",		&rmii_clk),
 	CLK("davinci_emac.1",	NULL,		&emac_clk),
+	CLK("davinci-mcasp.0",	NULL,		&mcasp_clk),
 	CLK(NULL,		NULL,		NULL),
 };
 
@@ -373,6 +381,30 @@ static const struct mux_config da850_pins[] = {
 	MUX_CFG(DA850, MII_RXD_0,	3,	28,	15,	8,	false)
 	MUX_CFG(DA850, MDIO_CLK,	4,	0,	15,	8,	false)
 	MUX_CFG(DA850, MDIO_D,		4,	4,	15,	8,	false)
+	/* McASP function */
+	MUX_CFG(DA850,	ACLKR,		0,	0,	15,	1,	false)
+	MUX_CFG(DA850,	ACLKX,		0,	4,	15,	1,	false)
+	MUX_CFG(DA850,	AFSR,		0,	8,	15,	1,	false)
+	MUX_CFG(DA850,	AFSX,		0,	12,	15,	1,	false)
+	MUX_CFG(DA850,	AHCLKR,		0,	16,	15,	1,	false)
+	MUX_CFG(DA850,	AHCLKX,		0,	20,	15,	1,	false)
+	MUX_CFG(DA850,	AMUTE,		0,	24,	15,	1,	false)
+	MUX_CFG(DA850,	AXR_15,		1,	0,	15,	1,	false)
+	MUX_CFG(DA850,	AXR_14,		1,	4,	15,	1,	false)
+	MUX_CFG(DA850,	AXR_13,		1,	8,	15,	1,	false)
+	MUX_CFG(DA850,	AXR_12,		1,	12,	15,	1,	false)
+	MUX_CFG(DA850,	AXR_11,		1,	16,	15,	1,	false)
+	MUX_CFG(DA850,	AXR_10,		1,	20,	15,	1,	false)
+	MUX_CFG(DA850,	AXR_9,		1,	24,	15,	1,	false)
+	MUX_CFG(DA850,	AXR_8,		1,	28,	15,	1,	false)
+	MUX_CFG(DA850,	AXR_7,		2,	0,	15,	1,	false)
+	MUX_CFG(DA850,	AXR_6,		2,	4,	15,	1,	false)
+	MUX_CFG(DA850,	AXR_5,		2,	8,	15,	1,	false)
+	MUX_CFG(DA850,	AXR_4,		2,	12,	15,	1,	false)
+	MUX_CFG(DA850,	AXR_3,		2,	16,	15,	1,	false)
+	MUX_CFG(DA850,	AXR_2,		2,	20,	15,	1,	false)
+	MUX_CFG(DA850,	AXR_1,		2,	24,	15,	1,	false)
+	MUX_CFG(DA850,	AXR_0,		2,	28,	15,	1,	false)
 #endif
 };
 
@@ -410,6 +442,13 @@ const short da850_cpgmac_pins[] __initdata = {
 	-1
 };
 
+const short da850_mcasp_pins[] __initdata = {
+	DA850_AHCLKX, DA850_ACLKX, DA850_AFSX,
+	DA850_AHCLKR, DA850_ACLKR, DA850_AFSR, DA850_AMUTE,
+	DA850_AXR_11, DA850_AXR_12,
+	-1
+};
+
 /* FIQ are pri 0-1; otherwise 2-7, with 7 lowest priority */
 static u8 da850_default_priorities[DA850_N_CP_INTC_IRQ] = {
 	[IRQ_DA8XX_COMMTX]		= 7,

commit 5a8d5441f4aac3ef0478d5de723422304c611926
Author: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
Date:   Tue Aug 11 16:14:21 2009 -0400

    davinci: Correct the number of GPIO pins for da850/omap-l138
    
    DA850/OMAP-L138 has 144 pins configurable as GPIO, but
    currently this has been configured as 128. This patch
    corrects it.
    
    Also, this patch adds the base address for GPIO pins
    greater than 128.
    
    Signed-off-by: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 22205a3727a7..c5efc515df4f 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -623,7 +623,7 @@ static struct davinci_soc_info davinci_soc_info_da850 = {
 	.intc_irq_num		= DA850_N_CP_INTC_IRQ,
 	.timer_info		= &da850_timer_info,
 	.gpio_base		= IO_ADDRESS(DA8XX_GPIO_BASE),
-	.gpio_num		= 128,
+	.gpio_num		= 144,
 	.gpio_irq		= IRQ_DA8XX_GPIO0,
 	.serial_dev		= &da8xx_serial_device,
 	.emac_pdata		= &da8xx_emac_pdata,

commit 53ca5c916971f72262ef37287e17f0a7d980362c
Author: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
Date:   Tue Aug 11 11:10:50 2009 -0400

    davinci: Configure MDIO pins for EMAC
    
    Earlier patch which adds EMAC support for da850/omap-l138
    was not configuring the MDIO pins.
    
    Ethernet was working fine with the earlier patch, because
    the MDIO pins were configured from the boot loader. This
    patch removes that dependency.
    
    Also, this patch populates a member in the emac clk structure
    to say that EMAC LPSC sits on controller 1.
    
    Signed-off-by: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 4a43ae2bec09..22205a3727a7 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -287,6 +287,7 @@ static struct clk emac_clk = {
 	.name		= "emac",
 	.parent		= &pll0_sysclk4,
 	.lpsc		= DA8XX_LPSC1_CPGMAC,
+	.psc_ctlr	= 1,
 };
 
 static struct davinci_clk da850_clks[] = {
@@ -370,6 +371,8 @@ static const struct mux_config da850_pins[] = {
 	MUX_CFG(DA850, MII_RXD_2,	3,	20,	15,	8,	false)
 	MUX_CFG(DA850, MII_RXD_1,	3,	24,	15,	8,	false)
 	MUX_CFG(DA850, MII_RXD_0,	3,	28,	15,	8,	false)
+	MUX_CFG(DA850, MDIO_CLK,	4,	0,	15,	8,	false)
+	MUX_CFG(DA850, MDIO_D,		4,	4,	15,	8,	false)
 #endif
 };
 
@@ -402,7 +405,8 @@ const short da850_cpgmac_pins[] __initdata = {
 	DA850_MII_TXEN, DA850_MII_TXCLK, DA850_MII_COL, DA850_MII_TXD_3,
 	DA850_MII_TXD_2, DA850_MII_TXD_1, DA850_MII_TXD_0, DA850_MII_RXER,
 	DA850_MII_CRS, DA850_MII_RXCLK, DA850_MII_RXDV, DA850_MII_RXD_3,
-	DA850_MII_RXD_2, DA850_MII_RXD_1, DA850_MII_RXD_0,
+	DA850_MII_RXD_2, DA850_MII_RXD_1, DA850_MII_RXD_0, DA850_MDIO_CLK,
+	DA850_MDIO_D,
 	-1
 };
 

commit 5a4b131508236c0a59b8680f486c49e31881fe4e
Author: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
Date:   Fri Jul 17 04:47:10 2009 -0400

    davinci: Add EMAC support for da850/omap-l138
    
    Ethernet Media Access Controller (EMAC) on da850/omap-l138
    supports 10/100 Mbps operation. It also supports Media
    Independent Interface (MII) and Reduced Media Independent
    Interface (RMII) to physical layer (PHY).
    
    Phy which supports MII is present on the DA850/OMAP-L138
    base board and Phy supporting RMII is present on the
    UI card. This patch adds support only for the MII Phy.
    Support for RMII Phy will be added later.
    
    Signed-off-by: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index 332cf7fadb1f..4a43ae2bec09 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -283,6 +283,12 @@ static struct clk rmii_clk = {
 	.parent		= &pll0_sysclk7,
 };
 
+static struct clk emac_clk = {
+	.name		= "emac",
+	.parent		= &pll0_sysclk4,
+	.lpsc		= DA8XX_LPSC1_CPGMAC,
+};
+
 static struct davinci_clk da850_clks[] = {
 	CLK(NULL,		"ref",		&ref_clk),
 	CLK(NULL,		"pll0",		&pll0_clk),
@@ -319,6 +325,7 @@ static struct davinci_clk da850_clks[] = {
 	CLK(NULL,		"emif3",	&emif3_clk),
 	CLK(NULL,		"arm",		&arm_clk),
 	CLK(NULL,		"rmii",		&rmii_clk),
+	CLK("davinci_emac.1",	NULL,		&emac_clk),
 	CLK(NULL,		NULL,		NULL),
 };
 
@@ -347,6 +354,22 @@ static const struct mux_config da850_pins[] = {
 	/* I2C0 function */
 	MUX_CFG(DA850, I2C0_SDA,	4,	12,	15,	2,	false)
 	MUX_CFG(DA850, I2C0_SCL,	4,	8,	15,	2,	false)
+	/* EMAC function */
+	MUX_CFG(DA850, MII_TXEN,	2,	4,	15,	8,	false)
+	MUX_CFG(DA850, MII_TXCLK,	2,	8,	15,	8,	false)
+	MUX_CFG(DA850, MII_COL,		2,	12,	15,	8,	false)
+	MUX_CFG(DA850, MII_TXD_3,	2,	16,	15,	8,	false)
+	MUX_CFG(DA850, MII_TXD_2,	2,	20,	15,	8,	false)
+	MUX_CFG(DA850, MII_TXD_1,	2,	24,	15,	8,	false)
+	MUX_CFG(DA850, MII_TXD_0,	2,	28,	15,	8,	false)
+	MUX_CFG(DA850, MII_RXCLK,	3,	0,	15,	8,	false)
+	MUX_CFG(DA850, MII_RXDV,	3,	4,	15,	8,	false)
+	MUX_CFG(DA850, MII_RXER,	3,	8,	15,	8,	false)
+	MUX_CFG(DA850, MII_CRS,		3,	12,	15,	8,	false)
+	MUX_CFG(DA850, MII_RXD_3,	3,	16,	15,	8,	false)
+	MUX_CFG(DA850, MII_RXD_2,	3,	20,	15,	8,	false)
+	MUX_CFG(DA850, MII_RXD_1,	3,	24,	15,	8,	false)
+	MUX_CFG(DA850, MII_RXD_0,	3,	28,	15,	8,	false)
 #endif
 };
 
@@ -375,6 +398,14 @@ const short da850_i2c1_pins[] __initdata = {
 	-1
 };
 
+const short da850_cpgmac_pins[] __initdata = {
+	DA850_MII_TXEN, DA850_MII_TXCLK, DA850_MII_COL, DA850_MII_TXD_3,
+	DA850_MII_TXD_2, DA850_MII_TXD_1, DA850_MII_TXD_0, DA850_MII_RXER,
+	DA850_MII_CRS, DA850_MII_RXCLK, DA850_MII_RXDV, DA850_MII_RXD_3,
+	DA850_MII_RXD_2, DA850_MII_RXD_1, DA850_MII_RXD_0,
+	-1
+};
+
 /* FIQ are pri 0-1; otherwise 2-7, with 7 lowest priority */
 static u8 da850_default_priorities[DA850_N_CP_INTC_IRQ] = {
 	[IRQ_DA8XX_COMMTX]		= 7,

commit e1a8d7e2ea7c971f750b1adf0e98c3c8ed002623
Author: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
Date:   Thu Jul 16 06:41:54 2009 -0400

    davinci: Add base DA850/OMAP-L138 SoC support
    
    The DA850/OMAP-L138 is a new SoC from TI in the same family as
    DA830/OMAP-L137.
    
    Major changes include better support for power management,
    support for SATA devices and McBSP (same IP as DM644x).
    
    DA850/OMAP-L138 documents are available at
    http://focus.ti.com/docs/prod/folders/print/omap-l138.html.
    
    Signed-off-by: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
new file mode 100644
index 000000000000..332cf7fadb1f
--- /dev/null
+++ b/arch/arm/mach-davinci/da850.c
@@ -0,0 +1,600 @@
+/*
+ * TI DA850/OMAP-L138 chip specific setup
+ *
+ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * Derived from: arch/arm/mach-davinci/da830.c
+ * Original Copyrights follow:
+ *
+ * 2009 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach/map.h>
+
+#include <mach/clock.h>
+#include <mach/psc.h>
+#include <mach/mux.h>
+#include <mach/irqs.h>
+#include <mach/cputype.h>
+#include <mach/common.h>
+#include <mach/time.h>
+#include <mach/da8xx.h>
+
+#include "clock.h"
+#include "mux.h"
+
+#define DA850_PLL1_BASE		0x01e1a000
+#define DA850_TIMER64P2_BASE	0x01f0c000
+#define DA850_TIMER64P3_BASE	0x01f0d000
+
+#define DA850_REF_FREQ		24000000
+
+static struct pll_data pll0_data = {
+	.num		= 1,
+	.phys_base	= DA8XX_PLL0_BASE,
+	.flags		= PLL_HAS_PREDIV | PLL_HAS_POSTDIV,
+};
+
+static struct clk ref_clk = {
+	.name		= "ref_clk",
+	.rate		= DA850_REF_FREQ,
+};
+
+static struct clk pll0_clk = {
+	.name		= "pll0",
+	.parent		= &ref_clk,
+	.pll_data	= &pll0_data,
+	.flags		= CLK_PLL,
+};
+
+static struct clk pll0_aux_clk = {
+	.name		= "pll0_aux_clk",
+	.parent		= &pll0_clk,
+	.flags		= CLK_PLL | PRE_PLL,
+};
+
+static struct clk pll0_sysclk2 = {
+	.name		= "pll0_sysclk2",
+	.parent		= &pll0_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV2,
+};
+
+static struct clk pll0_sysclk3 = {
+	.name		= "pll0_sysclk3",
+	.parent		= &pll0_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV3,
+};
+
+static struct clk pll0_sysclk4 = {
+	.name		= "pll0_sysclk4",
+	.parent		= &pll0_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV4,
+};
+
+static struct clk pll0_sysclk5 = {
+	.name		= "pll0_sysclk5",
+	.parent		= &pll0_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV5,
+};
+
+static struct clk pll0_sysclk6 = {
+	.name		= "pll0_sysclk6",
+	.parent		= &pll0_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV6,
+};
+
+static struct clk pll0_sysclk7 = {
+	.name		= "pll0_sysclk7",
+	.parent		= &pll0_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV7,
+};
+
+static struct pll_data pll1_data = {
+	.num		= 2,
+	.phys_base	= DA850_PLL1_BASE,
+	.flags		= PLL_HAS_POSTDIV,
+};
+
+static struct clk pll1_clk = {
+	.name		= "pll1",
+	.parent		= &ref_clk,
+	.pll_data	= &pll1_data,
+	.flags		= CLK_PLL,
+};
+
+static struct clk pll1_aux_clk = {
+	.name		= "pll1_aux_clk",
+	.parent		= &pll1_clk,
+	.flags		= CLK_PLL | PRE_PLL,
+};
+
+static struct clk pll1_sysclk2 = {
+	.name		= "pll1_sysclk2",
+	.parent		= &pll1_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV2,
+};
+
+static struct clk pll1_sysclk3 = {
+	.name		= "pll1_sysclk3",
+	.parent		= &pll1_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV3,
+};
+
+static struct clk pll1_sysclk4 = {
+	.name		= "pll1_sysclk4",
+	.parent		= &pll1_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV4,
+};
+
+static struct clk pll1_sysclk5 = {
+	.name		= "pll1_sysclk5",
+	.parent		= &pll1_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV5,
+};
+
+static struct clk pll1_sysclk6 = {
+	.name		= "pll0_sysclk6",
+	.parent		= &pll0_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV6,
+};
+
+static struct clk pll1_sysclk7 = {
+	.name		= "pll1_sysclk7",
+	.parent		= &pll1_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV7,
+};
+
+static struct clk i2c0_clk = {
+	.name		= "i2c0",
+	.parent		= &pll0_aux_clk,
+};
+
+static struct clk timerp64_0_clk = {
+	.name		= "timer0",
+	.parent		= &pll0_aux_clk,
+};
+
+static struct clk timerp64_1_clk = {
+	.name		= "timer1",
+	.parent		= &pll0_aux_clk,
+};
+
+static struct clk arm_rom_clk = {
+	.name		= "arm_rom",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC0_ARM_RAM_ROM,
+	.flags		= ALWAYS_ENABLED,
+};
+
+static struct clk tpcc0_clk = {
+	.name		= "tpcc0",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC0_TPCC,
+	.flags		= ALWAYS_ENABLED | CLK_PSC,
+};
+
+static struct clk tptc0_clk = {
+	.name		= "tptc0",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC0_TPTC0,
+	.flags		= ALWAYS_ENABLED,
+};
+
+static struct clk tptc1_clk = {
+	.name		= "tptc1",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC0_TPTC1,
+	.flags		= ALWAYS_ENABLED,
+};
+
+static struct clk tpcc1_clk = {
+	.name		= "tpcc1",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA850_LPSC1_TPCC1,
+	.flags		= CLK_PSC | ALWAYS_ENABLED,
+	.psc_ctlr	= 1,
+};
+
+static struct clk tptc2_clk = {
+	.name		= "tptc2",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA850_LPSC1_TPTC2,
+	.flags		= ALWAYS_ENABLED,
+	.psc_ctlr	= 1,
+};
+
+static struct clk uart0_clk = {
+	.name		= "uart0",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC0_UART0,
+};
+
+static struct clk uart1_clk = {
+	.name		= "uart1",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC1_UART1,
+	.psc_ctlr	= 1,
+};
+
+static struct clk uart2_clk = {
+	.name		= "uart2",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC1_UART2,
+	.psc_ctlr	= 1,
+};
+
+static struct clk aintc_clk = {
+	.name		= "aintc",
+	.parent		= &pll0_sysclk4,
+	.lpsc		= DA8XX_LPSC0_AINTC,
+	.flags		= ALWAYS_ENABLED,
+};
+
+static struct clk gpio_clk = {
+	.name		= "gpio",
+	.parent		= &pll0_sysclk4,
+	.lpsc		= DA8XX_LPSC1_GPIO,
+	.psc_ctlr	= 1,
+};
+
+static struct clk i2c1_clk = {
+	.name		= "i2c1",
+	.parent		= &pll0_sysclk4,
+	.lpsc		= DA8XX_LPSC1_I2C,
+	.psc_ctlr	= 1,
+};
+
+static struct clk emif3_clk = {
+	.name		= "emif3",
+	.parent		= &pll0_sysclk5,
+	.lpsc		= DA8XX_LPSC1_EMIF3C,
+	.flags		= ALWAYS_ENABLED,
+	.psc_ctlr	= 1,
+};
+
+static struct clk arm_clk = {
+	.name		= "arm",
+	.parent		= &pll0_sysclk6,
+	.lpsc		= DA8XX_LPSC0_ARM,
+	.flags		= ALWAYS_ENABLED,
+};
+
+static struct clk rmii_clk = {
+	.name		= "rmii",
+	.parent		= &pll0_sysclk7,
+};
+
+static struct davinci_clk da850_clks[] = {
+	CLK(NULL,		"ref",		&ref_clk),
+	CLK(NULL,		"pll0",		&pll0_clk),
+	CLK(NULL,		"pll0_aux",	&pll0_aux_clk),
+	CLK(NULL,		"pll0_sysclk2",	&pll0_sysclk2),
+	CLK(NULL,		"pll0_sysclk3",	&pll0_sysclk3),
+	CLK(NULL,		"pll0_sysclk4",	&pll0_sysclk4),
+	CLK(NULL,		"pll0_sysclk5",	&pll0_sysclk5),
+	CLK(NULL,		"pll0_sysclk6",	&pll0_sysclk6),
+	CLK(NULL,		"pll0_sysclk7",	&pll0_sysclk7),
+	CLK(NULL,		"pll1",		&pll1_clk),
+	CLK(NULL,		"pll1_aux",	&pll1_aux_clk),
+	CLK(NULL,		"pll1_sysclk2",	&pll1_sysclk2),
+	CLK(NULL,		"pll1_sysclk3",	&pll1_sysclk3),
+	CLK(NULL,		"pll1_sysclk4",	&pll1_sysclk4),
+	CLK(NULL,		"pll1_sysclk5",	&pll1_sysclk5),
+	CLK(NULL,		"pll1_sysclk6",	&pll1_sysclk6),
+	CLK(NULL,		"pll1_sysclk7",	&pll1_sysclk7),
+	CLK("i2c_davinci.1",	NULL,		&i2c0_clk),
+	CLK(NULL,		"timer0",	&timerp64_0_clk),
+	CLK("watchdog",		NULL,		&timerp64_1_clk),
+	CLK(NULL,		"arm_rom",	&arm_rom_clk),
+	CLK(NULL,		"tpcc0",	&tpcc0_clk),
+	CLK(NULL,		"tptc0",	&tptc0_clk),
+	CLK(NULL,		"tptc1",	&tptc1_clk),
+	CLK(NULL,		"tpcc1",	&tpcc1_clk),
+	CLK(NULL,		"tptc2",	&tptc2_clk),
+	CLK(NULL,		"uart0",	&uart0_clk),
+	CLK(NULL,		"uart1",	&uart1_clk),
+	CLK(NULL,		"uart2",	&uart2_clk),
+	CLK(NULL,		"aintc",	&aintc_clk),
+	CLK(NULL,		"gpio",		&gpio_clk),
+	CLK("i2c_davinci.2",	NULL,		&i2c1_clk),
+	CLK(NULL,		"emif3",	&emif3_clk),
+	CLK(NULL,		"arm",		&arm_clk),
+	CLK(NULL,		"rmii",		&rmii_clk),
+	CLK(NULL,		NULL,		NULL),
+};
+
+/*
+ * Device specific mux setup
+ *
+ *		soc	description	mux	mode	mode	mux	dbg
+ *					reg	offset	mask	mode
+ */
+static const struct mux_config da850_pins[] = {
+#ifdef CONFIG_DAVINCI_MUX
+	/* UART0 function */
+	MUX_CFG(DA850, NUART0_CTS,	3,	24,	15,	2,	false)
+	MUX_CFG(DA850, NUART0_RTS,	3,	28,	15,	2,	false)
+	MUX_CFG(DA850, UART0_RXD,	3,	16,	15,	2,	false)
+	MUX_CFG(DA850, UART0_TXD,	3,	20,	15,	2,	false)
+	/* UART1 function */
+	MUX_CFG(DA850, UART1_RXD,	4,	24,	15,	2,	false)
+	MUX_CFG(DA850, UART1_TXD,	4,	28,	15,	2,	false)
+	/* UART2 function */
+	MUX_CFG(DA850, UART2_RXD,	4,	16,	15,	2,	false)
+	MUX_CFG(DA850, UART2_TXD,	4,	20,	15,	2,	false)
+	/* I2C1 function */
+	MUX_CFG(DA850, I2C1_SCL,	4,	16,	15,	4,	false)
+	MUX_CFG(DA850, I2C1_SDA,	4,	20,	15,	4,	false)
+	/* I2C0 function */
+	MUX_CFG(DA850, I2C0_SDA,	4,	12,	15,	2,	false)
+	MUX_CFG(DA850, I2C0_SCL,	4,	8,	15,	2,	false)
+#endif
+};
+
+const short da850_uart0_pins[] __initdata = {
+	DA850_NUART0_CTS, DA850_NUART0_RTS, DA850_UART0_RXD, DA850_UART0_TXD,
+	-1
+};
+
+const short da850_uart1_pins[] __initdata = {
+	DA850_UART1_RXD, DA850_UART1_TXD,
+	-1
+};
+
+const short da850_uart2_pins[] __initdata = {
+	DA850_UART2_RXD, DA850_UART2_TXD,
+	-1
+};
+
+const short da850_i2c0_pins[] __initdata = {
+	DA850_I2C0_SDA, DA850_I2C0_SCL,
+	-1
+};
+
+const short da850_i2c1_pins[] __initdata = {
+	DA850_I2C1_SCL, DA850_I2C1_SDA,
+	-1
+};
+
+/* FIQ are pri 0-1; otherwise 2-7, with 7 lowest priority */
+static u8 da850_default_priorities[DA850_N_CP_INTC_IRQ] = {
+	[IRQ_DA8XX_COMMTX]		= 7,
+	[IRQ_DA8XX_COMMRX]		= 7,
+	[IRQ_DA8XX_NINT]		= 7,
+	[IRQ_DA8XX_EVTOUT0]		= 7,
+	[IRQ_DA8XX_EVTOUT1]		= 7,
+	[IRQ_DA8XX_EVTOUT2]		= 7,
+	[IRQ_DA8XX_EVTOUT3]		= 7,
+	[IRQ_DA8XX_EVTOUT4]		= 7,
+	[IRQ_DA8XX_EVTOUT5]		= 7,
+	[IRQ_DA8XX_EVTOUT6]		= 7,
+	[IRQ_DA8XX_EVTOUT6]		= 7,
+	[IRQ_DA8XX_EVTOUT7]		= 7,
+	[IRQ_DA8XX_CCINT0]		= 7,
+	[IRQ_DA8XX_CCERRINT]		= 7,
+	[IRQ_DA8XX_TCERRINT0]		= 7,
+	[IRQ_DA8XX_AEMIFINT]		= 7,
+	[IRQ_DA8XX_I2CINT0]		= 7,
+	[IRQ_DA8XX_MMCSDINT0]		= 7,
+	[IRQ_DA8XX_MMCSDINT1]		= 7,
+	[IRQ_DA8XX_ALLINT0]		= 7,
+	[IRQ_DA8XX_RTC]			= 7,
+	[IRQ_DA8XX_SPINT0]		= 7,
+	[IRQ_DA8XX_TINT12_0]		= 7,
+	[IRQ_DA8XX_TINT34_0]		= 7,
+	[IRQ_DA8XX_TINT12_1]		= 7,
+	[IRQ_DA8XX_TINT34_1]		= 7,
+	[IRQ_DA8XX_UARTINT0]		= 7,
+	[IRQ_DA8XX_KEYMGRINT]		= 7,
+	[IRQ_DA8XX_SECINT]		= 7,
+	[IRQ_DA8XX_SECKEYERR]		= 7,
+	[IRQ_DA850_MPUADDRERR0]		= 7,
+	[IRQ_DA850_MPUPROTERR0]		= 7,
+	[IRQ_DA850_IOPUADDRERR0]	= 7,
+	[IRQ_DA850_IOPUPROTERR0]	= 7,
+	[IRQ_DA850_IOPUADDRERR1]	= 7,
+	[IRQ_DA850_IOPUPROTERR1]	= 7,
+	[IRQ_DA850_IOPUADDRERR2]	= 7,
+	[IRQ_DA850_IOPUPROTERR2]	= 7,
+	[IRQ_DA850_BOOTCFG_ADDR_ERR]	= 7,
+	[IRQ_DA850_BOOTCFG_PROT_ERR]	= 7,
+	[IRQ_DA850_MPUADDRERR1]		= 7,
+	[IRQ_DA850_MPUPROTERR1]		= 7,
+	[IRQ_DA850_IOPUADDRERR3]	= 7,
+	[IRQ_DA850_IOPUPROTERR3]	= 7,
+	[IRQ_DA850_IOPUADDRERR4]	= 7,
+	[IRQ_DA850_IOPUPROTERR4]	= 7,
+	[IRQ_DA850_IOPUADDRERR5]	= 7,
+	[IRQ_DA850_IOPUPROTERR5]	= 7,
+	[IRQ_DA850_MIOPU_BOOTCFG_ERR]	= 7,
+	[IRQ_DA8XX_CHIPINT0]		= 7,
+	[IRQ_DA8XX_CHIPINT1]		= 7,
+	[IRQ_DA8XX_CHIPINT2]		= 7,
+	[IRQ_DA8XX_CHIPINT3]		= 7,
+	[IRQ_DA8XX_TCERRINT1]		= 7,
+	[IRQ_DA8XX_C0_RX_THRESH_PULSE]	= 7,
+	[IRQ_DA8XX_C0_RX_PULSE]		= 7,
+	[IRQ_DA8XX_C0_TX_PULSE]		= 7,
+	[IRQ_DA8XX_C0_MISC_PULSE]	= 7,
+	[IRQ_DA8XX_C1_RX_THRESH_PULSE]	= 7,
+	[IRQ_DA8XX_C1_RX_PULSE]		= 7,
+	[IRQ_DA8XX_C1_TX_PULSE]		= 7,
+	[IRQ_DA8XX_C1_MISC_PULSE]	= 7,
+	[IRQ_DA8XX_MEMERR]		= 7,
+	[IRQ_DA8XX_GPIO0]		= 7,
+	[IRQ_DA8XX_GPIO1]		= 7,
+	[IRQ_DA8XX_GPIO2]		= 7,
+	[IRQ_DA8XX_GPIO3]		= 7,
+	[IRQ_DA8XX_GPIO4]		= 7,
+	[IRQ_DA8XX_GPIO5]		= 7,
+	[IRQ_DA8XX_GPIO6]		= 7,
+	[IRQ_DA8XX_GPIO7]		= 7,
+	[IRQ_DA8XX_GPIO8]		= 7,
+	[IRQ_DA8XX_I2CINT1]		= 7,
+	[IRQ_DA8XX_LCDINT]		= 7,
+	[IRQ_DA8XX_UARTINT1]		= 7,
+	[IRQ_DA8XX_MCASPINT]		= 7,
+	[IRQ_DA8XX_ALLINT1]		= 7,
+	[IRQ_DA8XX_SPINT1]		= 7,
+	[IRQ_DA8XX_UHPI_INT1]		= 7,
+	[IRQ_DA8XX_USB_INT]		= 7,
+	[IRQ_DA8XX_IRQN]		= 7,
+	[IRQ_DA8XX_RWAKEUP]		= 7,
+	[IRQ_DA8XX_UARTINT2]		= 7,
+	[IRQ_DA8XX_DFTSSINT]		= 7,
+	[IRQ_DA8XX_EHRPWM0]		= 7,
+	[IRQ_DA8XX_EHRPWM0TZ]		= 7,
+	[IRQ_DA8XX_EHRPWM1]		= 7,
+	[IRQ_DA8XX_EHRPWM1TZ]		= 7,
+	[IRQ_DA850_SATAINT]		= 7,
+	[IRQ_DA850_TINT12_2]		= 7,
+	[IRQ_DA850_TINT34_2]		= 7,
+	[IRQ_DA850_TINTALL_2]		= 7,
+	[IRQ_DA8XX_ECAP0]		= 7,
+	[IRQ_DA8XX_ECAP1]		= 7,
+	[IRQ_DA8XX_ECAP2]		= 7,
+	[IRQ_DA850_MMCSDINT0_1]		= 7,
+	[IRQ_DA850_MMCSDINT1_1]		= 7,
+	[IRQ_DA850_T12CMPINT0_2]	= 7,
+	[IRQ_DA850_T12CMPINT1_2]	= 7,
+	[IRQ_DA850_T12CMPINT2_2]	= 7,
+	[IRQ_DA850_T12CMPINT3_2]	= 7,
+	[IRQ_DA850_T12CMPINT4_2]	= 7,
+	[IRQ_DA850_T12CMPINT5_2]	= 7,
+	[IRQ_DA850_T12CMPINT6_2]	= 7,
+	[IRQ_DA850_T12CMPINT7_2]	= 7,
+	[IRQ_DA850_T12CMPINT0_3]	= 7,
+	[IRQ_DA850_T12CMPINT1_3]	= 7,
+	[IRQ_DA850_T12CMPINT2_3]	= 7,
+	[IRQ_DA850_T12CMPINT3_3]	= 7,
+	[IRQ_DA850_T12CMPINT4_3]	= 7,
+	[IRQ_DA850_T12CMPINT5_3]	= 7,
+	[IRQ_DA850_T12CMPINT6_3]	= 7,
+	[IRQ_DA850_T12CMPINT7_3]	= 7,
+	[IRQ_DA850_RPIINT]		= 7,
+	[IRQ_DA850_VPIFINT]		= 7,
+	[IRQ_DA850_CCINT1]		= 7,
+	[IRQ_DA850_CCERRINT1]		= 7,
+	[IRQ_DA850_TCERRINT2]		= 7,
+	[IRQ_DA850_TINT12_3]		= 7,
+	[IRQ_DA850_TINT34_3]		= 7,
+	[IRQ_DA850_TINTALL_3]		= 7,
+	[IRQ_DA850_MCBSP0RINT]		= 7,
+	[IRQ_DA850_MCBSP0XINT]		= 7,
+	[IRQ_DA850_MCBSP1RINT]		= 7,
+	[IRQ_DA850_MCBSP1XINT]		= 7,
+	[IRQ_DA8XX_ARMCLKSTOPREQ]	= 7,
+};
+
+static struct map_desc da850_io_desc[] = {
+	{
+		.virtual	= IO_VIRT,
+		.pfn		= __phys_to_pfn(IO_PHYS),
+		.length		= IO_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= DA8XX_CP_INTC_VIRT,
+		.pfn		= __phys_to_pfn(DA8XX_CP_INTC_BASE),
+		.length		= DA8XX_CP_INTC_SIZE,
+		.type		= MT_DEVICE
+	},
+};
+
+static void __iomem *da850_psc_bases[] = {
+	IO_ADDRESS(DA8XX_PSC0_BASE),
+	IO_ADDRESS(DA8XX_PSC1_BASE),
+};
+
+/* Contents of JTAG ID register used to identify exact cpu type */
+static struct davinci_id da850_ids[] = {
+	{
+		.variant	= 0x0,
+		.part_no	= 0xb7d1,
+		.manufacturer	= 0x017,	/* 0x02f >> 1 */
+		.cpu_id		= DAVINCI_CPU_ID_DA850,
+		.name		= "da850/omap-l138",
+	},
+};
+
+static struct davinci_timer_instance da850_timer_instance[4] = {
+	{
+		.base		= IO_ADDRESS(DA8XX_TIMER64P0_BASE),
+		.bottom_irq	= IRQ_DA8XX_TINT12_0,
+		.top_irq	= IRQ_DA8XX_TINT34_0,
+	},
+	{
+		.base		= IO_ADDRESS(DA8XX_TIMER64P1_BASE),
+		.bottom_irq	= IRQ_DA8XX_TINT12_1,
+		.top_irq	= IRQ_DA8XX_TINT34_1,
+	},
+	{
+		.base		= IO_ADDRESS(DA850_TIMER64P2_BASE),
+		.bottom_irq	= IRQ_DA850_TINT12_2,
+		.top_irq	= IRQ_DA850_TINT34_2,
+	},
+	{
+		.base		= IO_ADDRESS(DA850_TIMER64P3_BASE),
+		.bottom_irq	= IRQ_DA850_TINT12_3,
+		.top_irq	= IRQ_DA850_TINT34_3,
+	},
+};
+
+/*
+ * T0_BOT: Timer 0, bottom		: Used for clock_event
+ * T0_TOP: Timer 0, top			: Used for clocksource
+ * T1_BOT, T1_TOP: Timer 1, bottom & top: Used for watchdog timer
+ */
+static struct davinci_timer_info da850_timer_info = {
+	.timers		= da850_timer_instance,
+	.clockevent_id	= T0_BOT,
+	.clocksource_id	= T0_TOP,
+};
+
+static struct davinci_soc_info davinci_soc_info_da850 = {
+	.io_desc		= da850_io_desc,
+	.io_desc_num		= ARRAY_SIZE(da850_io_desc),
+	.jtag_id_base		= IO_ADDRESS(DA8XX_JTAG_ID_REG),
+	.ids			= da850_ids,
+	.ids_num		= ARRAY_SIZE(da850_ids),
+	.cpu_clks		= da850_clks,
+	.psc_bases		= da850_psc_bases,
+	.psc_bases_num		= ARRAY_SIZE(da850_psc_bases),
+	.pinmux_base		= IO_ADDRESS(DA8XX_BOOT_CFG_BASE + 0x120),
+	.pinmux_pins		= da850_pins,
+	.pinmux_pins_num	= ARRAY_SIZE(da850_pins),
+	.intc_base		= (void __iomem *)DA8XX_CP_INTC_VIRT,
+	.intc_type		= DAVINCI_INTC_TYPE_CP_INTC,
+	.intc_irq_prios		= da850_default_priorities,
+	.intc_irq_num		= DA850_N_CP_INTC_IRQ,
+	.timer_info		= &da850_timer_info,
+	.gpio_base		= IO_ADDRESS(DA8XX_GPIO_BASE),
+	.gpio_num		= 128,
+	.gpio_irq		= IRQ_DA8XX_GPIO0,
+	.serial_dev		= &da8xx_serial_device,
+	.emac_pdata		= &da8xx_emac_pdata,
+};
+
+void __init da850_init(void)
+{
+	davinci_common_init(&davinci_soc_info_da850);
+}
