commit c0512c2ca380cdfb109e44f65ecdf45c8693d533
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Mon Jul 22 15:17:44 2019 +0200

    ARM: davinci: dm355: switch to using the clocksource driver
    
    We now have a proper clocksource driver for davinci. Switch the dm355
    platform to using it.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Reviewed-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index a38a3648345b..5de72d2fa8f0 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -30,7 +30,8 @@
 #include <mach/cputype.h>
 #include <mach/mux.h>
 #include <mach/serial.h>
-#include <mach/time.h>
+
+#include <clocksource/timer-davinci.h>
 
 #include "asp.h"
 #include "davinci.h"
@@ -620,15 +621,15 @@ static struct davinci_id dm355_ids[] = {
 };
 
 /*
- * T0_BOT: Timer 0, bottom:  clockevent source for hrtimers
- * T0_TOP: Timer 0, top   :  clocksource for generic timekeeping
- * T1_BOT: Timer 1, bottom:  (used by DSP in TI DSPLink code)
- * T1_TOP: Timer 1, top   :  <unused>
+ * Bottom half of timer0 is used for clockevent, top half is used for
+ * clocksource.
  */
-static struct davinci_timer_info dm355_timer_info = {
-	.timers		= davinci_timer_instance,
-	.clockevent_id	= T0_BOT,
-	.clocksource_id	= T0_TOP,
+static const struct davinci_timer_cfg dm355_timer_cfg = {
+	.reg = DEFINE_RES_IO(DAVINCI_TIMER0_BASE, SZ_4K),
+	.irq = {
+		DEFINE_RES_IRQ(DAVINCI_INTC_IRQ(IRQ_TINT0_TINT12)),
+		DEFINE_RES_IRQ(DAVINCI_INTC_IRQ(IRQ_TINT0_TINT34)),
+	},
 };
 
 static struct plat_serial8250_port dm355_serial0_platform_data[] = {
@@ -706,7 +707,6 @@ static const struct davinci_soc_info davinci_soc_info_dm355 = {
 	.pinmux_base		= DAVINCI_SYSTEM_MODULE_BASE,
 	.pinmux_pins		= dm355_pins,
 	.pinmux_pins_num	= ARRAY_SIZE(dm355_pins),
-	.timer_info		= &dm355_timer_info,
 	.sram_dma		= 0x00010000,
 	.sram_len		= SZ_32K,
 };
@@ -733,6 +733,7 @@ void __init dm355_init_time(void)
 {
 	void __iomem *pll1, *psc;
 	struct clk *clk;
+	int rv;
 
 	clk_register_fixed_rate(NULL, "ref_clk", NULL, 0, DM355_REF_FREQ);
 
@@ -748,7 +749,8 @@ void __init dm355_init_time(void)
 		return;
 	}
 
-	davinci_timer_init(clk);
+	rv = davinci_timer_register(clk, &dm355_timer_cfg);
+	WARN(rv, "Unable to register the timer: %d\n", rv);
 }
 
 static struct resource dm355_pll2_resources[] = {

commit d470df3bc5e1a9cd38995b55c918d9ecdda141e1
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Mon Jul 22 15:17:40 2019 +0200

    ARM: davinci: WARN_ON() if clk_get() fails
    
    Currently the timer code checks if the clock pointer passed to it is
    good (!IS_ERR(clk)). The new clocksource driver expects the clock to
    be functional and doesn't perform any checks so emit a warning if
    clk_get() fails. Apply this to all davinci platforms.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Reviewed-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index c6073326be2e..a38a3648345b 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -743,6 +743,10 @@ void __init dm355_init_time(void)
 	dm355_psc_init(NULL, psc);
 
 	clk = clk_get(NULL, "timer0");
+	if (WARN_ON(IS_ERR(clk))) {
+		pr_err("Unable to get the timer clock\n");
+		return;
+	}
 
 	davinci_timer_init(clk);
 }

commit 62e59c4e69b3cdbad67e3c2d49e4df4cfe1679e3
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Thu Apr 18 15:20:22 2019 -0700

    clk: Remove io.h from clk-provider.h
    
    Now that we've gotten rid of clk_readl() we can remove io.h from the
    clk-provider header and push out the io.h include to any code that isn't
    already including the io.h header but using things like readl/writel,
    etc.
    
    Found with this grep:
    
      git grep -l clk-provider.h | grep '.c$' | xargs git grep -L 'linux/io.h' | \
            xargs git grep -l \
            -e '\<__iowrite32_copy\>' --or \
            -e '\<__ioread32_copy\>' --or \
            -e '\<__iowrite64_copy\>' --or \
            -e '\<ioremap_page_range\>' --or \
            -e '\<ioremap_huge_init\>' --or \
            -e '\<arch_ioremap_pud_supported\>' --or \
            -e '\<arch_ioremap_pmd_supported\>' --or \
            -e '\<devm_ioport_map\>' --or \
            -e '\<devm_ioport_unmap\>' --or \
            -e '\<IOMEM_ERR_PTR\>' --or \
            -e '\<devm_ioremap\>' --or \
            -e '\<devm_ioremap_nocache\>' --or \
            -e '\<devm_ioremap_wc\>' --or \
            -e '\<devm_iounmap\>' --or \
            -e '\<devm_ioremap_release\>' --or \
            -e '\<devm_memremap\>' --or \
            -e '\<devm_memunmap\>' --or \
            -e '\<__devm_memremap_pages\>' --or \
            -e '\<pci_remap_cfgspace\>' --or \
            -e '\<arch_has_dev_port\>' --or \
            -e '\<arch_phys_wc_add\>' --or \
            -e '\<arch_phys_wc_del\>' --or \
            -e '\<memremap\>' --or \
            -e '\<memunmap\>' --or \
            -e '\<arch_io_reserve_memtype_wc\>' --or \
            -e '\<arch_io_free_memtype_wc\>' --or \
            -e '\<__io_aw\>' --or \
            -e '\<__io_pbw\>' --or \
            -e '\<__io_paw\>' --or \
            -e '\<__io_pbr\>' --or \
            -e '\<__io_par\>' --or \
            -e '\<__raw_readb\>' --or \
            -e '\<__raw_readw\>' --or \
            -e '\<__raw_readl\>' --or \
            -e '\<__raw_readq\>' --or \
            -e '\<__raw_writeb\>' --or \
            -e '\<__raw_writew\>' --or \
            -e '\<__raw_writel\>' --or \
            -e '\<__raw_writeq\>' --or \
            -e '\<readb\>' --or \
            -e '\<readw\>' --or \
            -e '\<readl\>' --or \
            -e '\<readq\>' --or \
            -e '\<writeb\>' --or \
            -e '\<writew\>' --or \
            -e '\<writel\>' --or \
            -e '\<writeq\>' --or \
            -e '\<readb_relaxed\>' --or \
            -e '\<readw_relaxed\>' --or \
            -e '\<readl_relaxed\>' --or \
            -e '\<readq_relaxed\>' --or \
            -e '\<writeb_relaxed\>' --or \
            -e '\<writew_relaxed\>' --or \
            -e '\<writel_relaxed\>' --or \
            -e '\<writeq_relaxed\>' --or \
            -e '\<readsb\>' --or \
            -e '\<readsw\>' --or \
            -e '\<readsl\>' --or \
            -e '\<readsq\>' --or \
            -e '\<writesb\>' --or \
            -e '\<writesw\>' --or \
            -e '\<writesl\>' --or \
            -e '\<writesq\>' --or \
            -e '\<inb\>' --or \
            -e '\<inw\>' --or \
            -e '\<inl\>' --or \
            -e '\<outb\>' --or \
            -e '\<outw\>' --or \
            -e '\<outl\>' --or \
            -e '\<inb_p\>' --or \
            -e '\<inw_p\>' --or \
            -e '\<inl_p\>' --or \
            -e '\<outb_p\>' --or \
            -e '\<outw_p\>' --or \
            -e '\<outl_p\>' --or \
            -e '\<insb\>' --or \
            -e '\<insw\>' --or \
            -e '\<insl\>' --or \
            -e '\<outsb\>' --or \
            -e '\<outsw\>' --or \
            -e '\<outsl\>' --or \
            -e '\<insb_p\>' --or \
            -e '\<insw_p\>' --or \
            -e '\<insl_p\>' --or \
            -e '\<outsb_p\>' --or \
            -e '\<outsw_p\>' --or \
            -e '\<outsl_p\>' --or \
            -e '\<ioread8\>' --or \
            -e '\<ioread16\>' --or \
            -e '\<ioread32\>' --or \
            -e '\<ioread64\>' --or \
            -e '\<iowrite8\>' --or \
            -e '\<iowrite16\>' --or \
            -e '\<iowrite32\>' --or \
            -e '\<iowrite64\>' --or \
            -e '\<ioread16be\>' --or \
            -e '\<ioread32be\>' --or \
            -e '\<ioread64be\>' --or \
            -e '\<iowrite16be\>' --or \
            -e '\<iowrite32be\>' --or \
            -e '\<iowrite64be\>' --or \
            -e '\<ioread8_rep\>' --or \
            -e '\<ioread16_rep\>' --or \
            -e '\<ioread32_rep\>' --or \
            -e '\<ioread64_rep\>' --or \
            -e '\<iowrite8_rep\>' --or \
            -e '\<iowrite16_rep\>' --or \
            -e '\<iowrite32_rep\>' --or \
            -e '\<iowrite64_rep\>' --or \
            -e '\<__io_virt\>' --or \
            -e '\<pci_iounmap\>' --or \
            -e '\<virt_to_phys\>' --or \
            -e '\<phys_to_virt\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<__ioremap\>' --or \
            -e '\<iounmap\>' --or \
            -e '\<ioremap\>' --or \
            -e '\<ioremap_nocache\>' --or \
            -e '\<ioremap_uc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wc\>' --or \
            -e '\<ioremap_wt\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<ioport_map\>' --or \
            -e '\<ioport_unmap\>' --or \
            -e '\<xlate_dev_kmem_ptr\>' --or \
            -e '\<xlate_dev_mem_ptr\>' --or \
            -e '\<unxlate_dev_mem_ptr\>' --or \
            -e '\<virt_to_bus\>' --or \
            -e '\<bus_to_virt\>' --or \
            -e '\<memset_io\>' --or \
            -e '\<memcpy_fromio\>' --or \
            -e '\<memcpy_toio\>'
    
    I also reordered a couple includes when they weren't alphabetical and
    removed clk.h from kona, replacing it with clk-provider.h because
    that driver doesn't use clk consumer APIs.
    
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Chen-Yu Tsai <wens@csie.org>
    Acked-by: Maxime Ripard <maxime.ripard@bootlin.com>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Cc: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Mark Brown <broonie@kernel.org>
    Cc: Chris Zankel <chris@zankel.net>
    Acked-by: Max Filippov <jcmvbkbc@gmail.com>
    Acked-by: John Crispin <john@phrozen.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 4a482445b9a2..c6073326be2e 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -15,6 +15,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/dmaengine.h>
 #include <linux/init.h>
+#include <linux/io.h>
 #include <linux/irqchip/irq-davinci-aintc.h>
 #include <linux/platform_data/edma.h>
 #include <linux/platform_data/gpio-davinci.h>

commit 49b654fd43b29e8decaa38035eed9ca8f221e48a
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Feb 14 15:52:31 2019 +0100

    ARM: davinci: remove intc related fields from davinci_soc_info
    
    The fields related to the two davinci interrupt controllers are no
    longer used. Remove them.
    
    Reviewed-by: David Lechner <david@lechnology.com>
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index c7cd765114af..4a482445b9a2 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -705,9 +705,6 @@ static const struct davinci_soc_info davinci_soc_info_dm355 = {
 	.pinmux_base		= DAVINCI_SYSTEM_MODULE_BASE,
 	.pinmux_pins		= dm355_pins,
 	.pinmux_pins_num	= ARRAY_SIZE(dm355_pins),
-	.intc_base		= DAVINCI_ARM_INTC_BASE,
-	.intc_irq_prios		= dm355_default_priorities,
-	.intc_irq_num		= DAVINCI_N_AINTC_IRQ,
 	.timer_info		= &dm355_timer_info,
 	.sram_dma		= 0x00010000,
 	.sram_len		= SZ_32K,

commit 06a2871614295eb3c504821adc4dee15748890ac
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Feb 14 15:52:11 2019 +0100

    ARM: davinci: aintc: use the new config structure
    
    Modify the aintc driver to take all its configuration from the new
    config structure. Stop referencing davinci_soc_info in any way.
    Move the declaration for davinci_aintc_init() to irq-davinci-aintc.h
    and make it take the new config structure as parameter. Convert all
    users to the new version.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Reviewed-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index ff79c1a17fae..c7cd765114af 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -805,7 +805,7 @@ static const struct davinci_aintc_config dm355_aintc_config = {
 
 void __init dm355_init_irq(void)
 {
-	davinci_aintc_init();
+	davinci_aintc_init(&dm355_aintc_config);
 }
 
 static int __init dm355_init_devices(void)

commit fd0f4275864d32a5150426bc73247901f5cc9b1b
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Feb 14 15:52:10 2019 +0100

    ARM: davinci: aintc: use the new irqchip config structure in dm* SoCs
    
    Add the new-style config structures for dm* SoCs. They will be used
    once we make the aintc driver stop using davinci_soc_info.
    
    Reviewed-by: David Lechner <david@lechnology.com>
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index e2b680e9944b..ff79c1a17fae 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -15,6 +15,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/dmaengine.h>
 #include <linux/init.h>
+#include <linux/irqchip/irq-davinci-aintc.h>
 #include <linux/platform_data/edma.h>
 #include <linux/platform_data/gpio-davinci.h>
 #include <linux/platform_data/spi-davinci.h>
@@ -792,6 +793,16 @@ int __init dm355_init_video(struct vpfe_config *vpfe_cfg,
 	return 0;
 }
 
+static const struct davinci_aintc_config dm355_aintc_config = {
+	.reg = {
+		.start		= DAVINCI_ARM_INTC_BASE,
+		.end		= DAVINCI_ARM_INTC_BASE + SZ_4K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	.num_irqs		= 64,
+	.prios			= dm355_default_priorities,
+};
+
 void __init dm355_init_irq(void)
 {
 	davinci_aintc_init();

commit 2b6a2e74f2bff4ae226c35113c8b9d802c50f2a6
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Feb 14 15:52:06 2019 +0100

    ARM: davinci: aintc: use a common prefix for symbols in the driver
    
    In preparation for moving the driver to drivers/irqchip do some
    cleanup: use a common prefix for all symbols.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Reviewed-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 6c65699cb074..e2b680e9944b 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -794,7 +794,7 @@ int __init dm355_init_video(struct vpfe_config *vpfe_cfg,
 
 void __init dm355_init_irq(void)
 {
-	davinci_irq_init();
+	davinci_aintc_init();
 }
 
 static int __init dm355_init_devices(void)

commit de4f82a245ce2ef5ef5623a57105ddfd77ad2ea5
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Feb 14 15:52:05 2019 +0100

    ARM: davinci: aintc: wrap davinci_irq_init() with a helper
    
    We're going to extend the davinci_irq_init() function with a config
    structure so we can drop the intc-related fields from davinci_soc_info.
    
    Once we do it, we won't be able to use this routine directly as the
    init_irq callback. Wrap the calls in additional helpers that don't
    take parameters and can be assigned to init_irq.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Reviewed-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index b27ea4fc1d51..6c65699cb074 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -792,6 +792,11 @@ int __init dm355_init_video(struct vpfe_config *vpfe_cfg,
 	return 0;
 }
 
+void __init dm355_init_irq(void)
+{
+	davinci_irq_init();
+}
+
 static int __init dm355_init_devices(void)
 {
 	struct platform_device *edma_pdev;

commit 544ca0b0d8248d8b48c4815e1ad88dd2796ae6ce
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Feb 14 15:52:03 2019 +0100

    ARM: davinci: make irqs.h a local header
    
    The existence of irqs.h in mach-davinci/include/mach only makes sense
    without SPARSE_IRQ as it's then expected to define NR_IRQS and is
    included from asm/irq.h. As we now support SPARSE_IRQ, this header can
    be moved to mach-davinci and used as the source of HW interrupt numbers.
    
    While updating the includes in various files - also rearrange the
    headers by directory (linux/asm/mach).
    
    Reviewed-by: David Lechner <david@lechnology.com>
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index cb725244fa13..b27ea4fc1d51 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -26,13 +26,13 @@
 
 #include <mach/common.h>
 #include <mach/cputype.h>
-#include <mach/irqs.h>
 #include <mach/mux.h>
 #include <mach/serial.h>
 #include <mach/time.h>
 
 #include "asp.h"
 #include "davinci.h"
+#include "irqs.h"
 #include "mux.h"
 
 #define DM355_UART2_BASE	(IO_PHYS + 0x206000)

commit a98ca73ee34825c09e666a97245dedf71ca84fbd
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Feb 14 15:52:01 2019 +0100

    ARM: davinci: wrap HW interrupt numbers with a macro
    
    Once we select SPARSE_IRQ, the interrupt numbers defined in mach/irqs.h
    will only signify the hardware interrupt offsets, not the interrupt
    numbers seen by linux. Introduce a wrapper macro that translates the
    hwirq number to virtual numbers. For now it's just a dummy. Use that
    macro when specifying the interrupts in resources for platform devices.
    
    Reviewed-by: David Lechner <david@lechnology.com>
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 03ce5df28d87..cb725244fa13 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -53,7 +53,7 @@ static struct resource dm355_spi0_resources[] = {
 		.flags = IORESOURCE_MEM,
 	},
 	{
-		.start = IRQ_DM355_SPINT0_0,
+		.start = DAVINCI_INTC_IRQ(IRQ_DM355_SPINT0_0),
 		.flags = IORESOURCE_IRQ,
 	},
 };
@@ -273,12 +273,12 @@ static struct resource edma_resources[] = {
 	},
 	{
 		.name	= "edma3_ccint",
-		.start	= IRQ_CCINT0,
+		.start	= DAVINCI_INTC_IRQ(IRQ_CCINT0),
 		.flags	= IORESOURCE_IRQ,
 	},
 	{
 		.name	= "edma3_ccerrint",
-		.start	= IRQ_CCERRINT,
+		.start	= DAVINCI_INTC_IRQ(IRQ_CCERRINT),
 		.flags	= IORESOURCE_IRQ,
 	},
 	/* not using (or muxing) TC*_ERR */
@@ -358,13 +358,13 @@ static struct platform_device dm355_vpss_device = {
 
 static struct resource vpfe_resources[] = {
 	{
-		.start          = IRQ_VDINT0,
-		.end            = IRQ_VDINT0,
+		.start          = DAVINCI_INTC_IRQ(IRQ_VDINT0),
+		.end            = DAVINCI_INTC_IRQ(IRQ_VDINT0),
 		.flags          = IORESOURCE_IRQ,
 	},
 	{
-		.start          = IRQ_VDINT1,
-		.end            = IRQ_VDINT1,
+		.start          = DAVINCI_INTC_IRQ(IRQ_VDINT1),
+		.end            = DAVINCI_INTC_IRQ(IRQ_VDINT1),
 		.flags          = IORESOURCE_IRQ,
 	},
 };
@@ -422,8 +422,8 @@ static struct platform_device dm355_osd_dev = {
 
 static struct resource dm355_venc_resources[] = {
 	{
-		.start	= IRQ_VENCINT,
-		.end	= IRQ_VENCINT,
+		.start	= DAVINCI_INTC_IRQ(IRQ_VENCINT),
+		.end	= DAVINCI_INTC_IRQ(IRQ_VENCINT),
 		.flags	= IORESOURCE_IRQ,
 	},
 	/* venc registers io space */
@@ -442,8 +442,8 @@ static struct resource dm355_venc_resources[] = {
 
 static struct resource dm355_v4l2_disp_resources[] = {
 	{
-		.start	= IRQ_VENCINT,
-		.end	= IRQ_VENCINT,
+		.start	= DAVINCI_INTC_IRQ(IRQ_VENCINT),
+		.end	= DAVINCI_INTC_IRQ(IRQ_VENCINT),
 		.flags	= IORESOURCE_IRQ,
 	},
 	/* venc registers io space */
@@ -547,38 +547,38 @@ static struct resource dm355_gpio_resources[] = {
 		.flags	= IORESOURCE_MEM,
 	},
 	{	/* interrupt */
-		.start	= IRQ_DM355_GPIOBNK0,
-		.end	= IRQ_DM355_GPIOBNK0,
+		.start	= DAVINCI_INTC_IRQ(IRQ_DM355_GPIOBNK0),
+		.end	= DAVINCI_INTC_IRQ(IRQ_DM355_GPIOBNK0),
 		.flags	= IORESOURCE_IRQ,
 	},
 	{
-		.start	= IRQ_DM355_GPIOBNK1,
-		.end	= IRQ_DM355_GPIOBNK1,
+		.start	= DAVINCI_INTC_IRQ(IRQ_DM355_GPIOBNK1),
+		.end	= DAVINCI_INTC_IRQ(IRQ_DM355_GPIOBNK1),
 		.flags	= IORESOURCE_IRQ,
 	},
 	{
-		.start	= IRQ_DM355_GPIOBNK2,
-		.end	= IRQ_DM355_GPIOBNK2,
+		.start	= DAVINCI_INTC_IRQ(IRQ_DM355_GPIOBNK2),
+		.end	= DAVINCI_INTC_IRQ(IRQ_DM355_GPIOBNK2),
 		.flags	= IORESOURCE_IRQ,
 	},
 	{
-		.start	= IRQ_DM355_GPIOBNK3,
-		.end	= IRQ_DM355_GPIOBNK3,
+		.start	= DAVINCI_INTC_IRQ(IRQ_DM355_GPIOBNK3),
+		.end	= DAVINCI_INTC_IRQ(IRQ_DM355_GPIOBNK3),
 		.flags	= IORESOURCE_IRQ,
 	},
 	{
-		.start	= IRQ_DM355_GPIOBNK4,
-		.end	= IRQ_DM355_GPIOBNK4,
+		.start	= DAVINCI_INTC_IRQ(IRQ_DM355_GPIOBNK4),
+		.end	= DAVINCI_INTC_IRQ(IRQ_DM355_GPIOBNK4),
 		.flags	= IORESOURCE_IRQ,
 	},
 	{
-		.start	= IRQ_DM355_GPIOBNK5,
-		.end	= IRQ_DM355_GPIOBNK5,
+		.start	= DAVINCI_INTC_IRQ(IRQ_DM355_GPIOBNK5),
+		.end	= DAVINCI_INTC_IRQ(IRQ_DM355_GPIOBNK5),
 		.flags	= IORESOURCE_IRQ,
 	},
 	{
-		.start	= IRQ_DM355_GPIOBNK6,
-		.end	= IRQ_DM355_GPIOBNK6,
+		.start	= DAVINCI_INTC_IRQ(IRQ_DM355_GPIOBNK6),
+		.end	= DAVINCI_INTC_IRQ(IRQ_DM355_GPIOBNK6),
 		.flags	= IORESOURCE_IRQ,
 	},
 };
@@ -632,7 +632,7 @@ static struct davinci_timer_info dm355_timer_info = {
 static struct plat_serial8250_port dm355_serial0_platform_data[] = {
 	{
 		.mapbase	= DAVINCI_UART0_BASE,
-		.irq		= IRQ_UARTINT0,
+		.irq		= DAVINCI_INTC_IRQ(IRQ_UARTINT0),
 		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
 				  UPF_IOREMAP,
 		.iotype		= UPIO_MEM,
@@ -645,7 +645,7 @@ static struct plat_serial8250_port dm355_serial0_platform_data[] = {
 static struct plat_serial8250_port dm355_serial1_platform_data[] = {
 	{
 		.mapbase	= DAVINCI_UART1_BASE,
-		.irq		= IRQ_UARTINT1,
+		.irq		= DAVINCI_INTC_IRQ(IRQ_UARTINT1),
 		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
 				  UPF_IOREMAP,
 		.iotype		= UPIO_MEM,
@@ -658,7 +658,7 @@ static struct plat_serial8250_port dm355_serial1_platform_data[] = {
 static struct plat_serial8250_port dm355_serial2_platform_data[] = {
 	{
 		.mapbase	= DM355_UART2_BASE,
-		.irq		= IRQ_DM355_UARTINT2,
+		.irq		= DAVINCI_INTC_IRQ(IRQ_DM355_UARTINT2),
 		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
 				  UPF_IOREMAP,
 		.iotype		= UPIO_MEM,

commit e3a8c7631d45c621a78f0cb186ac7a09d9642858
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Feb 14 15:51:59 2019 +0100

    ARM: davinci: remove davinci_intc_type
    
    We now use the generic ARM irq handler on davinci. There are no more
    users that check davinci_intc_type. Remove the variable and all its
    references.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Reviewed-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 4c6e0bef4509..03ce5df28d87 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -705,7 +705,6 @@ static const struct davinci_soc_info davinci_soc_info_dm355 = {
 	.pinmux_pins		= dm355_pins,
 	.pinmux_pins_num	= ARRAY_SIZE(dm355_pins),
 	.intc_base		= DAVINCI_ARM_INTC_BASE,
-	.intc_type		= DAVINCI_INTC_TYPE_AINTC,
 	.intc_irq_prios		= dm355_default_priorities,
 	.intc_irq_num		= DAVINCI_N_AINTC_IRQ,
 	.timer_info		= &dm355_timer_info,

commit a6ca633e13f888cbb0a92309a1e090818cffcc86
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Wed Nov 21 10:35:21 2018 +0100

    ARM: davinci: dm355: set the GPIO base to 0
    
    Commit 587f7a694f01 ("gpio: davinci: Use dev name for label and
    automatic base selection") broke the GPIO support on DaVinci boards
    in legacy mode by allowing gpiolib to set the GPIO base automatically.
    
    DaVinci board files use the legacy GPIO API with hard-coded GPIO line
    numbers. Use the new fields in struct davinci_gpio_platform_data to
    manually set the GPIO base to 0.
    
    Fixes: 587f7a694f01 ("gpio: davinci: Use dev name for label and automatic base selection")
    Cc: stable@vger.kernel.org
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 2b0f5d97ab7c..4c6e0bef4509 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -584,6 +584,8 @@ static struct resource dm355_gpio_resources[] = {
 };
 
 static struct davinci_gpio_platform_data dm355_gpio_platform_data = {
+	.no_auto_base	= true,
+	.base		= 0,
 	.ngpio		= 104,
 };
 

commit 27db7baab640ea28d7994eda943fef170e347081
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Wed Nov 21 10:35:15 2018 +0100

    ARM: davinci: dm355: define gpio interrupts as separate resources
    
    Since commit eb3744a2dd01 ("gpio: davinci: Do not assume continuous
    IRQ numbering") the davinci GPIO driver fails to probe if we boot
    in legacy mode from any of the board files. Since the driver now
    expects every interrupt to be defined as a separate resource, split
    the definition of IRQ resources instead of having a single continuous
    interrupt range.
    
    Fixes: eb3744a2dd01 ("gpio: davinci: Do not assume continuous IRQ numbering")
    Cc: stable@vger.kernel.org
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 9f7d38d12c88..2b0f5d97ab7c 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -548,6 +548,36 @@ static struct resource dm355_gpio_resources[] = {
 	},
 	{	/* interrupt */
 		.start	= IRQ_DM355_GPIOBNK0,
+		.end	= IRQ_DM355_GPIOBNK0,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		.start	= IRQ_DM355_GPIOBNK1,
+		.end	= IRQ_DM355_GPIOBNK1,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		.start	= IRQ_DM355_GPIOBNK2,
+		.end	= IRQ_DM355_GPIOBNK2,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		.start	= IRQ_DM355_GPIOBNK3,
+		.end	= IRQ_DM355_GPIOBNK3,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		.start	= IRQ_DM355_GPIOBNK4,
+		.end	= IRQ_DM355_GPIOBNK4,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		.start	= IRQ_DM355_GPIOBNK5,
+		.end	= IRQ_DM355_GPIOBNK5,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		.start	= IRQ_DM355_GPIOBNK6,
 		.end	= IRQ_DM355_GPIOBNK6,
 		.flags	= IORESOURCE_IRQ,
 	},

commit feee4eda2de296aeaecbba8fa1128e1e2006ff0a
Author: David Lechner <david@lechnology.com>
Date:   Fri May 18 11:48:20 2018 -0500

    ARM: davinci: dm355: Remove legacy clock init
    
    This removes the unused legacy clock init code from
    arch/arm/mach-davinci/dm355.c.
    
    Signed-off-by: David Lechner <david@lechnology.com>
    Reviewed-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 14014b942e8a..9f7d38d12c88 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -35,11 +35,6 @@
 #include "davinci.h"
 #include "mux.h"
 
-#ifndef CONFIG_COMMON_CLK
-#include "clock.h"
-#include "psc.h"
-#endif
-
 #define DM355_UART2_BASE	(IO_PHYS + 0x206000)
 #define DM355_OSD_BASE		(IO_PHYS + 0x70200)
 #define DM355_VENC_BASE		(IO_PHYS + 0x70400)
@@ -49,349 +44,6 @@
  */
 #define DM355_REF_FREQ		24000000	/* 24 or 36 MHz */
 
-#ifndef CONFIG_COMMON_CLK
-static struct pll_data pll1_data = {
-	.num       = 1,
-	.phys_base = DAVINCI_PLL1_BASE,
-	.flags     = PLL_HAS_PREDIV | PLL_HAS_POSTDIV,
-};
-
-static struct pll_data pll2_data = {
-	.num       = 2,
-	.phys_base = DAVINCI_PLL2_BASE,
-	.flags     = PLL_HAS_PREDIV,
-};
-
-static struct clk ref_clk = {
-	.name = "ref_clk",
-	/* FIXME -- crystal rate is board-specific */
-	.rate = DM355_REF_FREQ,
-};
-
-static struct clk pll1_clk = {
-	.name = "pll1",
-	.parent = &ref_clk,
-	.flags = CLK_PLL,
-	.pll_data = &pll1_data,
-};
-
-static struct clk pll1_aux_clk = {
-	.name = "pll1_aux_clk",
-	.parent = &pll1_clk,
-	.flags = CLK_PLL | PRE_PLL,
-};
-
-static struct clk pll1_sysclk1 = {
-	.name = "pll1_sysclk1",
-	.parent = &pll1_clk,
-	.flags = CLK_PLL,
-	.div_reg = PLLDIV1,
-};
-
-static struct clk pll1_sysclk2 = {
-	.name = "pll1_sysclk2",
-	.parent = &pll1_clk,
-	.flags = CLK_PLL,
-	.div_reg = PLLDIV2,
-};
-
-static struct clk pll1_sysclk3 = {
-	.name = "pll1_sysclk3",
-	.parent = &pll1_clk,
-	.flags = CLK_PLL,
-	.div_reg = PLLDIV3,
-};
-
-static struct clk pll1_sysclk4 = {
-	.name = "pll1_sysclk4",
-	.parent = &pll1_clk,
-	.flags = CLK_PLL,
-	.div_reg = PLLDIV4,
-};
-
-static struct clk pll1_sysclkbp = {
-	.name = "pll1_sysclkbp",
-	.parent = &pll1_clk,
-	.flags = CLK_PLL | PRE_PLL,
-	.div_reg = BPDIV
-};
-
-static struct clk vpss_dac_clk = {
-	.name = "vpss_dac",
-	.parent = &pll1_sysclk3,
-	.lpsc = DM355_LPSC_VPSS_DAC,
-};
-
-static struct clk vpss_master_clk = {
-	.name = "vpss_master",
-	.parent = &pll1_sysclk4,
-	.lpsc = DAVINCI_LPSC_VPSSMSTR,
-	.flags = CLK_PSC,
-};
-
-static struct clk vpss_slave_clk = {
-	.name = "vpss_slave",
-	.parent = &pll1_sysclk4,
-	.lpsc = DAVINCI_LPSC_VPSSSLV,
-};
-
-static struct clk clkout1_clk = {
-	.name = "clkout1",
-	.parent = &pll1_aux_clk,
-	/* NOTE:  clkout1 can be externally gated by muxing GPIO-18 */
-};
-
-static struct clk clkout2_clk = {
-	.name = "clkout2",
-	.parent = &pll1_sysclkbp,
-};
-
-static struct clk pll2_clk = {
-	.name = "pll2",
-	.parent = &ref_clk,
-	.flags = CLK_PLL,
-	.pll_data = &pll2_data,
-};
-
-static struct clk pll2_sysclk1 = {
-	.name = "pll2_sysclk1",
-	.parent = &pll2_clk,
-	.flags = CLK_PLL,
-	.div_reg = PLLDIV1,
-};
-
-static struct clk pll2_sysclkbp = {
-	.name = "pll2_sysclkbp",
-	.parent = &pll2_clk,
-	.flags = CLK_PLL | PRE_PLL,
-	.div_reg = BPDIV
-};
-
-static struct clk clkout3_clk = {
-	.name = "clkout3",
-	.parent = &pll2_sysclkbp,
-	/* NOTE:  clkout3 can be externally gated by muxing GPIO-16 */
-};
-
-static struct clk arm_clk = {
-	.name = "arm_clk",
-	.parent = &pll1_sysclk1,
-	.lpsc = DAVINCI_LPSC_ARM,
-	.flags = ALWAYS_ENABLED,
-};
-
-/*
- * NOT LISTED below, and not touched by Linux
- *   - in SyncReset state by default
- *	.lpsc = DAVINCI_LPSC_TPCC,
- *	.lpsc = DAVINCI_LPSC_TPTC0,
- *	.lpsc = DAVINCI_LPSC_TPTC1,
- *	.lpsc = DAVINCI_LPSC_DDR_EMIF, .parent = &sysclk2_clk,
- *	.lpsc = DAVINCI_LPSC_MEMSTICK,
- *   - in Enabled state by default
- *	.lpsc = DAVINCI_LPSC_SYSTEM_SUBSYS,
- *	.lpsc = DAVINCI_LPSC_SCR2,	// "bus"
- *	.lpsc = DAVINCI_LPSC_SCR3,	// "bus"
- *	.lpsc = DAVINCI_LPSC_SCR4,	// "bus"
- *	.lpsc = DAVINCI_LPSC_CROSSBAR,	// "emulation"
- *	.lpsc = DAVINCI_LPSC_CFG27,	// "test"
- *	.lpsc = DAVINCI_LPSC_CFG3,	// "test"
- *	.lpsc = DAVINCI_LPSC_CFG5,	// "test"
- */
-
-static struct clk mjcp_clk = {
-	.name = "mjcp",
-	.parent = &pll1_sysclk1,
-	.lpsc = DAVINCI_LPSC_IMCOP,
-};
-
-static struct clk uart0_clk = {
-	.name = "uart0",
-	.parent = &pll1_aux_clk,
-	.lpsc = DAVINCI_LPSC_UART0,
-};
-
-static struct clk uart1_clk = {
-	.name = "uart1",
-	.parent = &pll1_aux_clk,
-	.lpsc = DAVINCI_LPSC_UART1,
-};
-
-static struct clk uart2_clk = {
-	.name = "uart2",
-	.parent = &pll1_sysclk2,
-	.lpsc = DAVINCI_LPSC_UART2,
-};
-
-static struct clk i2c_clk = {
-	.name = "i2c",
-	.parent = &pll1_aux_clk,
-	.lpsc = DAVINCI_LPSC_I2C,
-};
-
-static struct clk asp0_clk = {
-	.name = "asp0",
-	.parent = &pll1_sysclk2,
-	.lpsc = DAVINCI_LPSC_McBSP,
-};
-
-static struct clk asp1_clk = {
-	.name = "asp1",
-	.parent = &pll1_sysclk2,
-	.lpsc = DM355_LPSC_McBSP1,
-};
-
-static struct clk mmcsd0_clk = {
-	.name = "mmcsd0",
-	.parent = &pll1_sysclk2,
-	.lpsc = DAVINCI_LPSC_MMC_SD,
-};
-
-static struct clk mmcsd1_clk = {
-	.name = "mmcsd1",
-	.parent = &pll1_sysclk2,
-	.lpsc = DM355_LPSC_MMC_SD1,
-};
-
-static struct clk spi0_clk = {
-	.name = "spi0",
-	.parent = &pll1_sysclk2,
-	.lpsc = DAVINCI_LPSC_SPI,
-};
-
-static struct clk spi1_clk = {
-	.name = "spi1",
-	.parent = &pll1_sysclk2,
-	.lpsc = DM355_LPSC_SPI1,
-};
-
-static struct clk spi2_clk = {
-	.name = "spi2",
-	.parent = &pll1_sysclk2,
-	.lpsc = DM355_LPSC_SPI2,
-};
-
-static struct clk gpio_clk = {
-	.name = "gpio",
-	.parent = &pll1_sysclk2,
-	.lpsc = DAVINCI_LPSC_GPIO,
-};
-
-static struct clk aemif_clk = {
-	.name = "aemif",
-	.parent = &pll1_sysclk2,
-	.lpsc = DAVINCI_LPSC_AEMIF,
-};
-
-static struct clk pwm0_clk = {
-	.name = "pwm0",
-	.parent = &pll1_aux_clk,
-	.lpsc = DAVINCI_LPSC_PWM0,
-};
-
-static struct clk pwm1_clk = {
-	.name = "pwm1",
-	.parent = &pll1_aux_clk,
-	.lpsc = DAVINCI_LPSC_PWM1,
-};
-
-static struct clk pwm2_clk = {
-	.name = "pwm2",
-	.parent = &pll1_aux_clk,
-	.lpsc = DAVINCI_LPSC_PWM2,
-};
-
-static struct clk pwm3_clk = {
-	.name = "pwm3",
-	.parent = &pll1_aux_clk,
-	.lpsc = DM355_LPSC_PWM3,
-};
-
-static struct clk timer0_clk = {
-	.name = "timer0",
-	.parent = &pll1_aux_clk,
-	.lpsc = DAVINCI_LPSC_TIMER0,
-};
-
-static struct clk timer1_clk = {
-	.name = "timer1",
-	.parent = &pll1_aux_clk,
-	.lpsc = DAVINCI_LPSC_TIMER1,
-};
-
-static struct clk timer2_clk = {
-	.name = "timer2",
-	.parent = &pll1_aux_clk,
-	.lpsc = DAVINCI_LPSC_TIMER2,
-	.usecount = 1,              /* REVISIT: why can't this be disabled? */
-};
-
-static struct clk timer3_clk = {
-	.name = "timer3",
-	.parent = &pll1_aux_clk,
-	.lpsc = DM355_LPSC_TIMER3,
-};
-
-static struct clk rto_clk = {
-	.name = "rto",
-	.parent = &pll1_aux_clk,
-	.lpsc = DM355_LPSC_RTO,
-};
-
-static struct clk usb_clk = {
-	.name = "usb",
-	.parent = &pll1_sysclk2,
-	.lpsc = DAVINCI_LPSC_USB,
-};
-
-static struct clk_lookup dm355_clks[] = {
-	CLK(NULL, "ref", &ref_clk),
-	CLK(NULL, "pll1", &pll1_clk),
-	CLK(NULL, "pll1_sysclk1", &pll1_sysclk1),
-	CLK(NULL, "pll1_sysclk2", &pll1_sysclk2),
-	CLK(NULL, "pll1_sysclk3", &pll1_sysclk3),
-	CLK(NULL, "pll1_sysclk4", &pll1_sysclk4),
-	CLK(NULL, "pll1_aux", &pll1_aux_clk),
-	CLK(NULL, "pll1_sysclkbp", &pll1_sysclkbp),
-	CLK(NULL, "vpss_dac", &vpss_dac_clk),
-	CLK("vpss", "master", &vpss_master_clk),
-	CLK("vpss", "slave", &vpss_slave_clk),
-	CLK(NULL, "clkout1", &clkout1_clk),
-	CLK(NULL, "clkout2", &clkout2_clk),
-	CLK(NULL, "pll2", &pll2_clk),
-	CLK(NULL, "pll2_sysclk1", &pll2_sysclk1),
-	CLK(NULL, "pll2_sysclkbp", &pll2_sysclkbp),
-	CLK(NULL, "clkout3", &clkout3_clk),
-	CLK(NULL, "arm", &arm_clk),
-	CLK(NULL, "mjcp", &mjcp_clk),
-	CLK("serial8250.0", NULL, &uart0_clk),
-	CLK("serial8250.1", NULL, &uart1_clk),
-	CLK("serial8250.2", NULL, &uart2_clk),
-	CLK("i2c_davinci.1", NULL, &i2c_clk),
-	CLK("davinci-mcbsp.0", NULL, &asp0_clk),
-	CLK("davinci-mcbsp.1", NULL, &asp1_clk),
-	CLK("dm6441-mmc.0", NULL, &mmcsd0_clk),
-	CLK("dm6441-mmc.1", NULL, &mmcsd1_clk),
-	CLK("spi_davinci.0", NULL, &spi0_clk),
-	CLK("spi_davinci.1", NULL, &spi1_clk),
-	CLK("spi_davinci.2", NULL, &spi2_clk),
-	CLK(NULL, "gpio", &gpio_clk),
-	CLK(NULL, "aemif", &aemif_clk),
-	CLK(NULL, "pwm0", &pwm0_clk),
-	CLK(NULL, "pwm1", &pwm1_clk),
-	CLK(NULL, "pwm2", &pwm2_clk),
-	CLK(NULL, "pwm3", &pwm3_clk),
-	CLK(NULL, "timer0", &timer0_clk),
-	CLK(NULL, "timer1", &timer1_clk),
-	CLK("davinci-wdt", NULL, &timer2_clk),
-	CLK(NULL, "timer3", &timer3_clk),
-	CLK(NULL, "rto", &rto_clk),
-	CLK(NULL, "usb", &usb_clk),
-	CLK(NULL, NULL, NULL),
-};
-#endif
-/*----------------------------------------------------------------------*/
-
 static u64 dm355_spi0_dma_mask = DMA_BIT_MASK(32);
 
 static struct resource dm355_spi0_resources[] = {
@@ -933,8 +585,6 @@ static struct davinci_id dm355_ids[] = {
 	},
 };
 
-static u32 dm355_psc_bases[] = { DAVINCI_PWR_SLEEP_CNTRL_BASE };
-
 /*
  * T0_BOT: Timer 0, bottom:  clockevent source for hrtimers
  * T0_TOP: Timer 0, top   :  clocksource for generic timekeeping
@@ -1019,8 +669,6 @@ static const struct davinci_soc_info davinci_soc_info_dm355 = {
 	.jtag_id_reg		= 0x01c40028,
 	.ids			= dm355_ids,
 	.ids_num		= ARRAY_SIZE(dm355_ids),
-	.psc_bases		= dm355_psc_bases,
-	.psc_bases_num		= ARRAY_SIZE(dm355_psc_bases),
 	.pinmux_base		= DAVINCI_SYSTEM_MODULE_BASE,
 	.pinmux_pins		= dm355_pins,
 	.pinmux_pins_num	= ARRAY_SIZE(dm355_pins),
@@ -1053,7 +701,6 @@ void __init dm355_init(void)
 
 void __init dm355_init_time(void)
 {
-#ifdef CONFIG_COMMON_CLK
 	void __iomem *pll1, *psc;
 	struct clk *clk;
 
@@ -1068,10 +715,6 @@ void __init dm355_init_time(void)
 	clk = clk_get(NULL, "timer0");
 
 	davinci_timer_init(clk);
-#else
-	davinci_clk_init(dm355_clks);
-	davinci_timer_init(&timer0_clk);
-#endif
 }
 
 static struct resource dm355_pll2_resources[] = {

commit 5b19f66d63b44ca38953b157e81595fb1e985762
Author: David Lechner <david@lechnology.com>
Date:   Fri May 18 11:48:09 2018 -0500

    ARM: davinci: dm355: add new clock init using common clock framework
    
    This adds the new board-specific clock init in mach-davinci/dm355.c
    using the new common clock framework drivers.
    
    The #ifdefs are needed to prevent compile errors until the entire
    ARCH_DAVINCI is converted.
    
    Also clean up the #includes since we are adding some here.
    
    Signed-off-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 0da7516018ca..14014b942e8a 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -8,31 +8,37 @@
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
  */
-#include <linux/init.h>
-#include <linux/clk.h>
-#include <linux/serial_8250.h>
-#include <linux/platform_device.h>
+
+#include <linux/clk-provider.h>
+#include <linux/clk/davinci.h>
+#include <linux/clkdev.h>
 #include <linux/dma-mapping.h>
 #include <linux/dmaengine.h>
-#include <linux/spi/spi.h>
+#include <linux/init.h>
 #include <linux/platform_data/edma.h>
 #include <linux/platform_data/gpio-davinci.h>
 #include <linux/platform_data/spi-davinci.h>
+#include <linux/platform_device.h>
+#include <linux/serial_8250.h>
+#include <linux/spi/spi.h>
 
 #include <asm/mach/map.h>
 
+#include <mach/common.h>
 #include <mach/cputype.h>
-#include "psc.h"
-#include <mach/mux.h>
 #include <mach/irqs.h>
-#include <mach/time.h>
+#include <mach/mux.h>
 #include <mach/serial.h>
-#include <mach/common.h>
+#include <mach/time.h>
 
+#include "asp.h"
 #include "davinci.h"
-#include "clock.h"
 #include "mux.h"
-#include "asp.h"
+
+#ifndef CONFIG_COMMON_CLK
+#include "clock.h"
+#include "psc.h"
+#endif
 
 #define DM355_UART2_BASE	(IO_PHYS + 0x206000)
 #define DM355_OSD_BASE		(IO_PHYS + 0x70200)
@@ -43,6 +49,7 @@
  */
 #define DM355_REF_FREQ		24000000	/* 24 or 36 MHz */
 
+#ifndef CONFIG_COMMON_CLK
 static struct pll_data pll1_data = {
 	.num       = 1,
 	.phys_base = DAVINCI_PLL1_BASE,
@@ -382,7 +389,7 @@ static struct clk_lookup dm355_clks[] = {
 	CLK(NULL, "usb", &usb_clk),
 	CLK(NULL, NULL, NULL),
 };
-
+#endif
 /*----------------------------------------------------------------------*/
 
 static u64 dm355_spi0_dma_mask = DMA_BIT_MASK(32);
@@ -1046,8 +1053,46 @@ void __init dm355_init(void)
 
 void __init dm355_init_time(void)
 {
+#ifdef CONFIG_COMMON_CLK
+	void __iomem *pll1, *psc;
+	struct clk *clk;
+
+	clk_register_fixed_rate(NULL, "ref_clk", NULL, 0, DM355_REF_FREQ);
+
+	pll1 = ioremap(DAVINCI_PLL1_BASE, SZ_1K);
+	dm355_pll1_init(NULL, pll1, NULL);
+
+	psc = ioremap(DAVINCI_PWR_SLEEP_CNTRL_BASE, SZ_4K);
+	dm355_psc_init(NULL, psc);
+
+	clk = clk_get(NULL, "timer0");
+
+	davinci_timer_init(clk);
+#else
 	davinci_clk_init(dm355_clks);
 	davinci_timer_init(&timer0_clk);
+#endif
+}
+
+static struct resource dm355_pll2_resources[] = {
+	{
+		.start	= DAVINCI_PLL2_BASE,
+		.end	= DAVINCI_PLL2_BASE + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device dm355_pll2_device = {
+	.name		= "dm355-pll2",
+	.id		= -1,
+	.resource	= dm355_pll2_resources,
+	.num_resources	= ARRAY_SIZE(dm355_pll2_resources),
+};
+
+void __init dm355_register_clocks(void)
+{
+	/* PLL1 and PSC are registered in dm355_init_time() */
+	platform_device_register(&dm355_pll2_device);
 }
 
 int __init dm355_init_video(struct vpfe_config *vpfe_cfg,

commit a7da5277cdc6690823ad226335feefc11391cf67
Author: David Lechner <david@lechnology.com>
Date:   Fri May 18 11:48:06 2018 -0500

    ARM: davinci: pass clock as parameter to davinci_timer_init()
    
    This changes davinci_timer_init() so that we pass the clock as a
    parameter instead of using clk_get(). This is done in preparation
    for converting to the common clock framework.
    
    It removes the requirement that we have to have a clock with con_id
    of "timer0", which will be good for DT bindings since clock-names =
    "timer0" doesn't really make sense.
    
    Also, drop use of extern in header file since we are touching the
    definition.
    
    Reviewed-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index f29480495c18..0da7516018ca 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -1047,7 +1047,7 @@ void __init dm355_init(void)
 void __init dm355_init_time(void)
 {
 	davinci_clk_init(dm355_clks);
-	davinci_timer_init();
+	davinci_timer_init(&timer0_clk);
 }
 
 int __init dm355_init_video(struct vpfe_config *vpfe_cfg,

commit 96c081735d5197d9d4fa0b6ce84cffa3bb197474
Author: David Lechner <david@lechnology.com>
Date:   Fri Jan 19 21:20:22 2018 -0600

    ARM: davinci: move davinci_clk_init() to init_time
    
    This moves the call of davinci_clk_init() from map_io to init_time for all
    boards.
    
    This is the proper place to init clocks. This is also done in preparation
    for moving to the common clock framework.
    
    dm646x is a special case because we need to handle different ref_clk rates
    depending on which board is being used. The clock init in this case is
    modified to set the rate before registering the clocks instead of using
    davinci_set_refclk_rate() to recalculate the entire clock tree after all
    of the clocks are registered.
    
    Also, the cpu_clks field is removed from struct davinci_soc_info since it
    is no longer needed.
    
    Signed-off-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 938747f20c22..f29480495c18 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -1012,7 +1012,6 @@ static const struct davinci_soc_info davinci_soc_info_dm355 = {
 	.jtag_id_reg		= 0x01c40028,
 	.ids			= dm355_ids,
 	.ids_num		= ARRAY_SIZE(dm355_ids),
-	.cpu_clks		= dm355_clks,
 	.psc_bases		= dm355_psc_bases,
 	.psc_bases_num		= ARRAY_SIZE(dm355_psc_bases),
 	.pinmux_base		= DAVINCI_SYSTEM_MODULE_BASE,
@@ -1043,7 +1042,12 @@ void __init dm355_init(void)
 {
 	davinci_common_init(&davinci_soc_info_dm355);
 	davinci_map_sysmod();
-	davinci_clk_init(davinci_soc_info_dm355.cpu_clks);
+}
+
+void __init dm355_init_time(void)
+{
+	davinci_clk_init(dm355_clks);
+	davinci_timer_init();
 }
 
 int __init dm355_init_video(struct vpfe_config *vpfe_cfg,

commit ab41910dfd5ab8e90b6a93d8c17f39ce2dbb069d
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Mon Oct 16 12:08:24 2017 +0200

    ARM: davinci: make davinci_soc_info structures const
    
    Make davinci_soc_info structures const as they are either passed to the
    function davinci_common_init having the argument as const or their field
    cpu_clks of type struct clk_lookup * is passed to the function
    davinci_clk_init.
    
    So, the fields are never modified and the structures can be const.
    
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    [nsekhar@ti.com: minor commit message adjustment]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index bd50367f654e..938747f20c22 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -1006,7 +1006,7 @@ struct platform_device dm355_serial_device[] = {
 	}
 };
 
-static struct davinci_soc_info davinci_soc_info_dm355 = {
+static const struct davinci_soc_info davinci_soc_info_dm355 = {
 	.io_desc		= dm355_io_desc,
 	.io_desc_num		= ARRAY_SIZE(dm355_io_desc),
 	.jtag_id_reg		= 0x01c40028,

commit 0dc68bc0840e6772a29e0066abf8914e75856d57
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Wed Sep 28 13:35:29 2016 +0300

    ARM: davinci: dm355: Remove DMA resources for SPI
    
    The driver is converted to not use the DMA resource.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index d33322ddedab..bd50367f654e 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -397,14 +397,6 @@ static struct resource dm355_spi0_resources[] = {
 		.start = IRQ_DM355_SPINT0_0,
 		.flags = IORESOURCE_IRQ,
 	},
-	{
-		.start = 17,
-		.flags = IORESOURCE_DMA,
-	},
-	{
-		.start = 16,
-		.flags = IORESOURCE_DMA,
-	},
 };
 
 static struct davinci_spi_platform_data dm355_spi0_pdata = {

commit 6bce5efd442488434a317a25c5482fcd5a66bb0f
Author: Petr Kulhavy <petr@barix.com>
Date:   Mon May 9 15:59:48 2016 +0200

    ARM: davinci: remove unused davinci-i2s pdata
    
    The davinci-i2s driver ("davinci-mcbsp") does not use platform
    data any longer. Remove the dummy pdata provided by the board
    drivers dm355, dm365, dm644x and neuros-osd2.
    
    Signed-off-by: Petr Kulhavy <petr@barix.com>
    Reviewed-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 5a19cca7ed6a..d33322ddedab 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -1035,7 +1035,7 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.sram_len		= SZ_32K,
 };
 
-void __init dm355_init_asp1(u32 evt_enable, struct snd_platform_data *pdata)
+void __init dm355_init_asp1(u32 evt_enable)
 {
 	/* we don't use ASP1 IRQs, or we'd need to mux them ... */
 	if (evt_enable & ASP1_TX_EVT_EN)
@@ -1044,7 +1044,6 @@ void __init dm355_init_asp1(u32 evt_enable, struct snd_platform_data *pdata)
 	if (evt_enable & ASP1_RX_EVT_EN)
 		davinci_cfg_reg(DM355_EVT9_ASP1_RX);
 
-	dm355_asp1_device.dev.platform_data = pdata;
 	platform_device_register(&dm355_asp1_device);
 }
 

commit 6fc9ebbdeb75197df780c52f5ebcc3eeffb9cd91
Author: David Lechner <david@lechnology.com>
Date:   Thu Apr 14 14:13:35 2016 -0500

    ARM: davinci: Move clock init after ioremap.
    
    Some clocks (such as the USB PHY clocks in DA8xx) will need to use iomem.
    The davinci_common_init() function must be called before the ioremap, so
    the clock init is now split out as separate function.
    
    Signed-off-by: David Lechner <david@lechnology.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index a0ecf499c2f2..5a19cca7ed6a 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -1052,6 +1052,7 @@ void __init dm355_init(void)
 {
 	davinci_common_init(&davinci_soc_info_dm355);
 	davinci_map_sysmod();
+	davinci_clk_init(davinci_soc_info_dm355.cpu_clks);
 }
 
 int __init dm355_init_video(struct vpfe_config *vpfe_cfg,

commit f7a3be503f166a08259a983daa7df12b9e149c46
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Tue Feb 2 14:43:14 2016 +0200

    ARM: davinci: dm355: Add dma_slave_map to edma
    
    Provide the dma_slave_map to edma which will allow us to move the drivers
    to the new, simpler dmaengine API and we can remove the DMA resources also
    for the devices.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    [nsekhar@ti.com: typo fixes in code]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index c7c1458df23c..a0ecf499c2f2 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -13,6 +13,7 @@
 #include <linux/serial_8250.h>
 #include <linux/platform_device.h>
 #include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
 #include <linux/spi/spi.h>
 #include <linux/platform_data/edma.h>
 #include <linux/platform_data/gpio-davinci.h>
@@ -576,9 +577,28 @@ static s8 queue_priority_mapping[][2] = {
 	{-1, -1},
 };
 
+static const struct dma_slave_map dm355_edma_map[] = {
+	{ "davinci-mcbsp.0", "tx", EDMA_FILTER_PARAM(0, 2) },
+	{ "davinci-mcbsp.0", "rx", EDMA_FILTER_PARAM(0, 3) },
+	{ "davinci-mcbsp.1", "tx", EDMA_FILTER_PARAM(0, 8) },
+	{ "davinci-mcbsp.1", "rx", EDMA_FILTER_PARAM(0, 9) },
+	{ "spi_davinci.2", "tx", EDMA_FILTER_PARAM(0, 10) },
+	{ "spi_davinci.2", "rx", EDMA_FILTER_PARAM(0, 11) },
+	{ "spi_davinci.1", "tx", EDMA_FILTER_PARAM(0, 14) },
+	{ "spi_davinci.1", "rx", EDMA_FILTER_PARAM(0, 15) },
+	{ "spi_davinci.0", "tx", EDMA_FILTER_PARAM(0, 16) },
+	{ "spi_davinci.0", "rx", EDMA_FILTER_PARAM(0, 17) },
+	{ "dm6441-mmc.0", "rx", EDMA_FILTER_PARAM(0, 26) },
+	{ "dm6441-mmc.0", "tx", EDMA_FILTER_PARAM(0, 27) },
+	{ "dm6441-mmc.1", "rx", EDMA_FILTER_PARAM(0, 30) },
+	{ "dm6441-mmc.1", "tx", EDMA_FILTER_PARAM(0, 31) },
+};
+
 static struct edma_soc_info dm355_edma_pdata = {
 	.queue_priority_mapping	= queue_priority_mapping,
 	.default_queue		= EVENTQ_1,
+	.slave_map		= dm355_edma_map,
+	.slavecnt		= ARRAY_SIZE(dm355_edma_map),
 };
 
 static struct resource edma_resources[] = {

commit 3acf731ccad039d91721b6cd9fc85569e9f958ca
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jan 30 10:45:33 2015 +0100

    ARM: davinci: make headers more local
    
    Some header files are never included outside of a mach-davinci
    directory and do not need to be made visible in include/mach,
    so let's just move them all down one level.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 609950b8c191..c7c1458df23c 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -21,7 +21,7 @@
 #include <asm/mach/map.h>
 
 #include <mach/cputype.h>
-#include <mach/psc.h>
+#include "psc.h"
 #include <mach/mux.h>
 #include <mach/irqs.h>
 #include <mach/time.h>

commit cef5b0da4019358cb03c9b0a964d4d63cd7deaf6
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Wed Oct 14 14:42:52 2015 +0300

    ARM: davinci: Add dma_mask to eDMA devices
    
    The upcoming change to merge the arch/arm/common/edma.c into
    drivers/dma/edma.c will need this change when booting daVinci devices in
    no DT mode.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 5f10c6695e31..609950b8c191 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -616,6 +616,7 @@ static struct resource edma_resources[] = {
 static const struct platform_device_info dm355_edma_device __initconst = {
 	.name		= "edma",
 	.id		= 0,
+	.dma_mask	= DMA_BIT_MASK(32),
 	.res		= edma_resources,
 	.num_res	= ARRAY_SIZE(edma_resources),
 	.data		= &dm355_edma_pdata,

commit 7ab388e85faa97a35d520720269e7c8e00ad54a0
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Wed Oct 14 14:42:51 2015 +0300

    ARM: davinci: Use platform_device_register_full() to create pdev for eDMA
    
    Convert the eDMA platform device creation to use
    struct platform_device_info XXXXXX __initconst and
    platform_device_register_full()
    This will allow us to cleanly specify the dma_mask for the devices in an
    upcoming patch.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index a50bb9c66952..5f10c6695e31 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -613,12 +613,13 @@ static struct resource edma_resources[] = {
 	/* not using (or muxing) TC*_ERR */
 };
 
-static struct platform_device dm355_edma_device = {
-	.name			= "edma",
-	.id			= 0,
-	.dev.platform_data	= &dm355_edma_pdata,
-	.num_resources		= ARRAY_SIZE(edma_resources),
-	.resource		= edma_resources,
+static const struct platform_device_info dm355_edma_device __initconst = {
+	.name		= "edma",
+	.id		= 0,
+	.res		= edma_resources,
+	.num_res	= ARRAY_SIZE(edma_resources),
+	.data		= &dm355_edma_pdata,
+	.size_data	= sizeof(dm355_edma_pdata),
 };
 
 static struct resource dm355_asp1_resources[] = {
@@ -1057,13 +1058,18 @@ int __init dm355_init_video(struct vpfe_config *vpfe_cfg,
 
 static int __init dm355_init_devices(void)
 {
+	struct platform_device *edma_pdev;
 	int ret = 0;
 
 	if (!cpu_is_davinci_dm355())
 		return 0;
 
 	davinci_cfg_reg(DM355_INT_EDMA_CC);
-	platform_device_register(&dm355_edma_device);
+	edma_pdev = platform_device_register_full(&dm355_edma_device);
+	if (IS_ERR(edma_pdev)) {
+		pr_warn("%s: Failed to register eDMA\n", __func__);
+		return PTR_ERR(edma_pdev);
+	}
 
 	ret = davinci_init_wdt();
 	if (ret)

commit d4cb7f404247173e2c760a01bf06fd1016a8b0d4
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Wed Oct 14 14:42:46 2015 +0300

    ARM: davinci/common: Convert edma driver to handle one eDMA instance per driver
    
    Currently we have one device created to handle all (maximum 2) eDMAs in the
    system.
    With this change all eDMA instance will have it's own device/driver.
    This change is needed for further cleanups in the eDMA driver stack since
    the one device/driver to handle all eDMAs in the system was not flexible
    enough and prevents the upcoming work.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 567dc56fe8cd..a50bb9c66952 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -569,49 +569,44 @@ static u8 dm355_default_priorities[DAVINCI_N_AINTC_IRQ] = {
 
 /*----------------------------------------------------------------------*/
 
-static s8
-queue_priority_mapping[][2] = {
+static s8 queue_priority_mapping[][2] = {
 	/* {event queue no, Priority} */
 	{0, 3},
 	{1, 7},
 	{-1, -1},
 };
 
-static struct edma_soc_info edma_cc0_info = {
+static struct edma_soc_info dm355_edma_pdata = {
 	.queue_priority_mapping	= queue_priority_mapping,
 	.default_queue		= EVENTQ_1,
 };
 
-static struct edma_soc_info *dm355_edma_info[EDMA_MAX_CC] = {
-       &edma_cc0_info,
-};
-
 static struct resource edma_resources[] = {
 	{
-		.name	= "edma_cc0",
+		.name	= "edma3_cc",
 		.start	= 0x01c00000,
 		.end	= 0x01c00000 + SZ_64K - 1,
 		.flags	= IORESOURCE_MEM,
 	},
 	{
-		.name	= "edma_tc0",
+		.name	= "edma3_tc0",
 		.start	= 0x01c10000,
 		.end	= 0x01c10000 + SZ_1K - 1,
 		.flags	= IORESOURCE_MEM,
 	},
 	{
-		.name	= "edma_tc1",
+		.name	= "edma3_tc1",
 		.start	= 0x01c10400,
 		.end	= 0x01c10400 + SZ_1K - 1,
 		.flags	= IORESOURCE_MEM,
 	},
 	{
-		.name	= "edma0",
+		.name	= "edma3_ccint",
 		.start	= IRQ_CCINT0,
 		.flags	= IORESOURCE_IRQ,
 	},
 	{
-		.name	= "edma0_err",
+		.name	= "edma3_ccerrint",
 		.start	= IRQ_CCERRINT,
 		.flags	= IORESOURCE_IRQ,
 	},
@@ -621,7 +616,7 @@ static struct resource edma_resources[] = {
 static struct platform_device dm355_edma_device = {
 	.name			= "edma",
 	.id			= 0,
-	.dev.platform_data	= dm355_edma_info,
+	.dev.platform_data	= &dm355_edma_pdata,
 	.num_resources		= ARRAY_SIZE(edma_resources),
 	.resource		= edma_resources,
 };

commit 1b0838b5a794456ca36ce02b405bd7bcc85bfba0
Author: Franklin S Cooper Jr <fcooper@ti.com>
Date:   Wed Aug 12 08:26:19 2015 -0500

    ARM: davinci: Set proper SPI prescale limit value
    
    SPI Davinci driver has been updated to allow SOCs to specify their minimum
    prescale value. Update the various SOCs board files that use this driver with
    their proper prescaler limit.
    
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Franklin S Cooper Jr <fcooper@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 9cbeda798584..567dc56fe8cd 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -411,6 +411,7 @@ static struct davinci_spi_platform_data dm355_spi0_pdata = {
 	.num_chipselect = 2,
 	.cshold_bug	= true,
 	.dma_event_q	= EVENTQ_1,
+	.prescaler_limit = 1,
 };
 static struct platform_device dm355_spi0_device = {
 	.name = "spi_davinci",

commit 27ffaeb0ab160852c87e2dfa505594020e9a3a06
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Mon Nov 10 14:28:31 2014 -0300

    [media] platform: Make use of media_bus_format enum
    
    In order to have subsytem agnostic media bus format definitions we've
    moved media bus definition to include/uapi/linux/media-bus-format.h and
    prefixed values with MEDIA_BUS_FMT instead of V4L2_MBUS_FMT.
    
    Reference new definitions in all platform drivers.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Acked-by: Lad, Prabhakar <prabhakar.csengg@gmail.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 2f3ed3a58d57..9cbeda798584 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -785,14 +785,13 @@ static struct resource dm355_v4l2_disp_resources[] = {
 	},
 };
 
-static int dm355_vpbe_setup_pinmux(enum v4l2_mbus_pixelcode if_type,
-			    int field)
+static int dm355_vpbe_setup_pinmux(u32 if_type, int field)
 {
 	switch (if_type) {
-	case V4L2_MBUS_FMT_SGRBG8_1X8:
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
 		davinci_cfg_reg(DM355_VOUT_FIELD_G70);
 		break;
-	case V4L2_MBUS_FMT_YUYV10_1X20:
+	case MEDIA_BUS_FMT_YUYV10_1X20:
 		if (field)
 			davinci_cfg_reg(DM355_VOUT_FIELD);
 		else

commit d5fc0e8dd9b3ddc26374d5334455c38ad84b7fab
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Fri May 16 15:17:19 2014 +0300

    ARM: davinci: Remove redundant/unused parameters for edma
    
    The following parameters are no longer needed by the edma driver since the
    information can be obtained from the IP's CCCFG register:
    n_channel, n_region, n_slot and n_tc.
    Remove the initialization of n_cc as well since in this context it has no
    meaning. We have separate edma_soc_info struct/eDMA3_CC instance so this
    member does not make any sense (and the driver no longer uses it).
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index e27f7ff54570..2f3ed3a58d57 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -577,11 +577,6 @@ queue_priority_mapping[][2] = {
 };
 
 static struct edma_soc_info edma_cc0_info = {
-	.n_channel		= 64,
-	.n_region		= 4,
-	.n_slot			= 128,
-	.n_tc			= 2,
-	.n_cc			= 1,
 	.queue_priority_mapping	= queue_priority_mapping,
 	.default_queue		= EVENTQ_1,
 };

commit 82ba61228467db9e8fe7d253cba0a5974e562974
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Fri May 16 15:17:11 2014 +0300

    ARM: davinci: Remove eDMA3 queue_tc_mapping data from edma_soc_info
    
    It is ignored by the edma driver since we are just setting back the default
    mapping of TC -> Queue.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 07381d8cea62..e27f7ff54570 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -568,14 +568,6 @@ static u8 dm355_default_priorities[DAVINCI_N_AINTC_IRQ] = {
 
 /*----------------------------------------------------------------------*/
 
-static s8
-queue_tc_mapping[][2] = {
-	/* {event queue no, TC no} */
-	{0, 0},
-	{1, 1},
-	{-1, -1},
-};
-
 static s8
 queue_priority_mapping[][2] = {
 	/* {event queue no, Priority} */
@@ -590,7 +582,6 @@ static struct edma_soc_info edma_cc0_info = {
 	.n_slot			= 128,
 	.n_tc			= 2,
 	.n_cc			= 1,
-	.queue_tc_mapping	= queue_tc_mapping,
 	.queue_priority_mapping	= queue_priority_mapping,
 	.default_queue		= EVENTQ_1,
 };

commit 1233090cf6d8a75c8dca3b37e65a6e12f79502af
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Wed Feb 26 10:29:43 2014 +0530

    ARM: davinci: da8xx: fix multiple watchdog device registration
    
    Fix multiple watchdog device registration on da8xx devices
    due to davinci_init_devices blindly registering watchdog
    device.
    
    Fix this by getting rid of the initcall and instead registering
    watchdog for each soc.
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 4668c0e19767..07381d8cea62 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -1076,12 +1076,18 @@ int __init dm355_init_video(struct vpfe_config *vpfe_cfg,
 
 static int __init dm355_init_devices(void)
 {
+	int ret = 0;
+
 	if (!cpu_is_davinci_dm355())
 		return 0;
 
 	davinci_cfg_reg(DM355_INT_EDMA_CC);
 	platform_device_register(&dm355_edma_device);
 
-	return 0;
+	ret = davinci_init_wdt();
+	if (ret)
+		pr_warn("%s: watchdog init failed: %d\n", __func__, ret);
+
+	return ret;
 }
 postcore_initcall(dm355_init_devices);

commit cd2f43a1f7400a74a084094502f70df2e169c6e8
Merge: 64576e439709 843748123d95
Author: Kevin Hilman <khilman@linaro.org>
Date:   Thu Jan 16 13:59:44 2014 -0800

    Merge tag 'davinci-for-v3.14/watchdog' of git://git.kernel.org/pub/scm/linux/kernel/git/nsekhar/linux-davinci into next/drivers
    
    From Sekhar Nori:
    This patch updates the davinci watchdog
    platform device name from generic "watchdog"
    to something more specific.
    
    * tag 'davinci-for-v3.14/watchdog' of git://git.kernel.org/pub/scm/linux/kernel/git/nsekhar/linux-davinci:
      watchdog: davinci: rename platform driver to davinci-wdt
    
    Signed-off-by: Kevin Hilman <khilman@linaro.org>

commit 843748123d95ae77a489b41f2f193e8502fc7ea8
Author: Ivan Khoronzhuk <ivan.khoronzhuk@ti.com>
Date:   Wed Nov 27 15:31:53 2013 +0200

    watchdog: davinci: rename platform driver to davinci-wdt
    
    As we switch to use the watchdog core which permits more than one
    active watchdog in the system, rename platform driver to
    "davinci-wdt" to be identifiable.
    
    Acked-by: Wim Van Sebroeck <wim@iguana.be>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Ivan Khoronzhuk <ivan.khoronzhuk@ti.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index ef9ff1fb6f52..4bb813276a95 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -375,7 +375,7 @@ static struct clk_lookup dm355_clks[] = {
 	CLK(NULL, "pwm3", &pwm3_clk),
 	CLK(NULL, "timer0", &timer0_clk),
 	CLK(NULL, "timer1", &timer1_clk),
-	CLK("watchdog", NULL, &timer2_clk),
+	CLK("davinci-wdt", NULL, &timer2_clk),
 	CLK(NULL, "timer3", &timer3_clk),
 	CLK(NULL, "rto", &rto_clk),
 	CLK(NULL, "usb", &usb_clk),

commit d3422a18dbc4a8aa1d430828b39e48d6c91f1791
Author: Lad, Prabhakar <prabhakar.csengg@gmail.com>
Date:   Thu Nov 21 23:45:28 2013 +0530

    gpio: davinci: remove unused variable intc_irq_num
    
    As the davinci-gpio driver is migrated to use irqdomain
    there is no need to pass the irq base for the gpio driver.
    This patch removes this variable from davinci_gpio_platform_data
    and also the refrences from the machine file.
    
    Signed-off-by: Lad, Prabhakar <prabhakar.csengg@gmail.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 6117fc644188..4d2c72fb40c4 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -901,7 +901,6 @@ static struct resource dm355_gpio_resources[] = {
 
 static struct davinci_gpio_platform_data dm355_gpio_platform_data = {
 	.ngpio		= 104,
-	.intc_irq_num	= DAVINCI_N_AINTC_IRQ,
 };
 
 int __init dm355_gpio_register(void)

commit 8ae19ec3356901bafa64816d9ea9378896f8979c
Merge: fa22f66b82de ee880dbd1688
Author: Olof Johansson <olof@lixom.net>
Date:   Wed Dec 4 14:28:26 2013 -0800

    Merge tag 'davinci-fixes-for-v3.13-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/nsekhar/linux-davinci into fixes
    
    From Sekhar Nori:
    This pull request includes a patch
    to align platform code to driver's
    usage of platform_get_resource_byname()
    
    This is needed to start successfully probing
    audio again. The regression was introduced
    in v3.13 merge window.
    
    * tag 'davinci-fixes-for-v3.13-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/nsekhar/linux-davinci:
      ARM: davinci: Fix McASP mem resource names
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit ee880dbd1688c99084052c7890246c1e16c89820
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Wed Nov 13 16:48:17 2013 +0200

    ARM: davinci: Fix McASP mem resource names
    
    The ASoC McASP driver looks for the mem resources by name
    "mpu" and "dat" regions.
    Change/add the needed name for the mem resources so the driver can pick the
    correct resource.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index ef9ff1fb6f52..d4baf4f6cf42 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -641,6 +641,7 @@ static struct platform_device dm355_edma_device = {
 
 static struct resource dm355_asp1_resources[] = {
 	{
+		.name	= "mpu",
 		.start	= DAVINCI_ASP1_BASE,
 		.end	= DAVINCI_ASP1_BASE + SZ_8K - 1,
 		.flags	= IORESOURCE_MEM,

commit e462f1f5174893f3f5efd03a31ca014b02120f9a
Author: Lad, Prabhakar <prabhakar.csengg@gmail.com>
Date:   Fri Nov 8 12:15:56 2013 +0530

    ARM: davinci: fix number of resources passed to davinci_gpio_register()
    
    The davinci_gpio_register() function expects the number of
    resources as the second parameter, but sizeof() resources
    was passed to it due to which it was causing unexpected
    behaviour. This patch fixes the same by passing the
    ARRAY_SIZE() of resources.
    
    Reported-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Lad, Prabhakar <prabhakar.csengg@gmail.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index ef9ff1fb6f52..536ce52d51cf 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -906,7 +906,7 @@ static struct davinci_gpio_platform_data dm355_gpio_platform_data = {
 int __init dm355_gpio_register(void)
 {
 	return davinci_gpio_register(dm355_gpio_resources,
-				     sizeof(dm355_gpio_resources),
+				     ARRAY_SIZE(dm355_gpio_resources),
 				     &dm355_gpio_platform_data);
 }
 /*----------------------------------------------------------------------*/

commit 9cc1515cbd2155df8530ba8438b0b5bfdff50117
Author: Philip Avinash <avinashphilip@ti.com>
Date:   Sun Aug 18 10:49:00 2013 +0530

    ARM: davinci: support gpio platform device
    
    DaVinci GPIO driver now uses platform device model.
    Add a GPIO platform register API to convert the
    traditional DaVinci  SoCs to use the new model.
    
    While at it, also group related include files together
    wherever that was not the case.
    
    Signed-off-by: Philip Avinash <avinashphilip@ti.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Lad, Prabhakar <prabhakar.csengg@gmail.com>
    [nsekhar@ti.com: move function declaration to local header,
                     simplify commit message, merge SoC specific
                     portions from other patches into this patch]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 3eaa5f6b2160..ef9ff1fb6f52 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -13,8 +13,10 @@
 #include <linux/serial_8250.h>
 #include <linux/platform_device.h>
 #include <linux/dma-mapping.h>
-
 #include <linux/spi/spi.h>
+#include <linux/platform_data/edma.h>
+#include <linux/platform_data/gpio-davinci.h>
+#include <linux/platform_data/spi-davinci.h>
 
 #include <asm/mach/map.h>
 
@@ -25,9 +27,6 @@
 #include <mach/time.h>
 #include <mach/serial.h>
 #include <mach/common.h>
-#include <linux/platform_data/spi-davinci.h>
-#include <mach/gpio-davinci.h>
-#include <linux/platform_data/edma.h>
 
 #include "davinci.h"
 #include "clock.h"
@@ -886,6 +885,30 @@ static struct platform_device dm355_vpbe_dev = {
 	},
 };
 
+static struct resource dm355_gpio_resources[] = {
+	{	/* registers */
+		.start	= DAVINCI_GPIO_BASE,
+		.end	= DAVINCI_GPIO_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{	/* interrupt */
+		.start	= IRQ_DM355_GPIOBNK0,
+		.end	= IRQ_DM355_GPIOBNK6,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct davinci_gpio_platform_data dm355_gpio_platform_data = {
+	.ngpio		= 104,
+	.intc_irq_num	= DAVINCI_N_AINTC_IRQ,
+};
+
+int __init dm355_gpio_register(void)
+{
+	return davinci_gpio_register(dm355_gpio_resources,
+				     sizeof(dm355_gpio_resources),
+				     &dm355_gpio_platform_data);
+}
 /*----------------------------------------------------------------------*/
 
 static struct map_desc dm355_io_desc[] = {
@@ -1005,10 +1028,6 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.intc_irq_prios		= dm355_default_priorities,
 	.intc_irq_num		= DAVINCI_N_AINTC_IRQ,
 	.timer_info		= &dm355_timer_info,
-	.gpio_type		= GPIO_TYPE_DAVINCI,
-	.gpio_base		= DAVINCI_GPIO_BASE,
-	.gpio_num		= 104,
-	.gpio_irq		= IRQ_DM355_GPIOBNK0,
 	.sram_dma		= 0x00010000,
 	.sram_len		= SZ_32K,
 };

commit cee7e8bbd634486277796341a6acdaa30ad6429b
Merge: 1ee64e48fac2 46c1833467c5
Author: Kevin Hilman <khilman@linaro.org>
Date:   Thu Aug 22 11:44:44 2013 -0700

    Merge tag 'davinci-for-v3.12/soc' of git://git.kernel.org/pub/scm/linux/kernel/git/nsekhar/linux-davinci into next/soc
    
    From Sekhar Nori:
    
    DaVinci SoC updates for v3.12
    -----------------------------
    
    This set of SoC updates contains changes to the
    way UART clock is handled to enabled DT-boot to
    obtain UART clock frequency instead of relying
    on DT-binding being supplied. Similarly handling
    of MDIO clock is fixed to make it easier to support
    MDIO in DT-boot. Finally there is patch to remove
    now unnecessary setting of wake-up capable flag for
    RTC.
    
    * tag 'davinci-for-v3.12/soc' of git://git.kernel.org/pub/scm/linux/kernel/git/nsekhar/linux-davinci:
      ARM: davinci: fix clock lookup for mdio device
      ARM: davinci: da8xx: remove hard coding of rtc device wakeup
      ARM: davinci: serial: remove davinci_serial_setup_clk()
      ARM: davinci: serial: get rid of davinci_uart_config
      ARM: davinci: da8xx: remove da8xx_uart_clk_enable
      ARM: davinci: uart: move to devid based clk_get
    
    Signed-off-by: Kevin Hilman <khilman@linaro.org>

commit 323761bb7518d27c62c1514156cb3243930b55c1
Author: Manjunathappa, Prakash <prakash.pm@ti.com>
Date:   Wed Jun 19 14:45:42 2013 +0530

    ARM: davinci: serial: remove davinci_serial_setup_clk()
    
    Get rid of davinci_serial_setup_clk() since its not called
    from multiple places now. Instead initialize clock in
    davinci_serial_init() itself. This also helps get rid of
    "serial_dev" member of struct davinci_soc_info.
    
    Signed-off-by: Manjunathappa, Prakash <prakash.pm@ti.com>
    Suggested-by: Sekhar Nori <nsekhar@ti.com>
    [nsekhar@ti.com: split removal of davinci_serial_setup_clk()
                     into a separate patch.]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 85367350e3d9..0f3cb486f561 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -1009,7 +1009,6 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.gpio_base		= DAVINCI_GPIO_BASE,
 	.gpio_num		= 104,
 	.gpio_irq		= IRQ_DM355_GPIOBNK0,
-	.serial_dev		= dm355_serial_device,
 	.sram_dma		= 0x00010000,
 	.sram_len		= SZ_32K,
 };

commit fcf7157ba3b50e57653544421250ebbe81a33d81
Author: Manjunathappa, Prakash <prakash.pm@ti.com>
Date:   Wed Jun 19 14:45:42 2013 +0530

    ARM: davinci: serial: get rid of davinci_uart_config
    
    "struct davinci_uart_config" was introduced to specify
    UART ports brought out or enabled on the board. But
    none of the boards use it for that purpose and we are
    not going to add anymore board files, so remove the
    structure.
    
    Signed-off-by: Manjunathappa, Prakash <prakash.pm@ti.com>
    Suggested-by: Sekhar Nori <nsekhar@ti.com>
    [nsekhar@ti.com: split patch to remove davinci_serial_setup_clk()
                     changes.]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 29fdbae16995..85367350e3d9 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -962,7 +962,7 @@ static struct plat_serial8250_port dm355_serial2_platform_data[] = {
 	}
 };
 
-static struct platform_device dm355_serial_device[] = {
+struct platform_device dm355_serial_device[] = {
 	{
 		.name			= "serial8250",
 		.id			= PLAT8250_DEV_PLATFORM,

commit 19955c3d7453757271d05859958ca1804a5d2d67
Author: Manjunathappa, Prakash <prakash.pm@ti.com>
Date:   Wed Jun 19 14:45:38 2013 +0530

    ARM: davinci: uart: move to devid based clk_get
    
    For modules having single clock, clk_get should be done with dev_id.
    But current davinci implementation handles multiple instances
    of the UART devices with single platform_device_register. Hence clk_get
    is based on con_id rather than dev_id, this is not correct. Do
    platform_device_register for each instance and clk_get on dev_id.
    
    Signed-off-by: Manjunathappa, Prakash <prakash.pm@ti.com>
    [nsekhar@ti.com: actually stop using con_id in clk_get(), squash the
                     patch adding OF aux data into this one]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 42ef53f62c6c..29fdbae16995 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -357,9 +357,9 @@ static struct clk_lookup dm355_clks[] = {
 	CLK(NULL, "clkout3", &clkout3_clk),
 	CLK(NULL, "arm", &arm_clk),
 	CLK(NULL, "mjcp", &mjcp_clk),
-	CLK(NULL, "uart0", &uart0_clk),
-	CLK(NULL, "uart1", &uart1_clk),
-	CLK(NULL, "uart2", &uart2_clk),
+	CLK("serial8250.0", NULL, &uart0_clk),
+	CLK("serial8250.1", NULL, &uart1_clk),
+	CLK("serial8250.2", NULL, &uart2_clk),
 	CLK("i2c_davinci.1", NULL, &i2c_clk),
 	CLK("davinci-mcbsp.0", NULL, &asp0_clk),
 	CLK("davinci-mcbsp.1", NULL, &asp1_clk),
@@ -922,7 +922,7 @@ static struct davinci_timer_info dm355_timer_info = {
 	.clocksource_id	= T0_TOP,
 };
 
-static struct plat_serial8250_port dm355_serial_platform_data[] = {
+static struct plat_serial8250_port dm355_serial0_platform_data[] = {
 	{
 		.mapbase	= DAVINCI_UART0_BASE,
 		.irq		= IRQ_UARTINT0,
@@ -931,6 +931,11 @@ static struct plat_serial8250_port dm355_serial_platform_data[] = {
 		.iotype		= UPIO_MEM,
 		.regshift	= 2,
 	},
+	{
+		.flags	= 0,
+	}
+};
+static struct plat_serial8250_port dm355_serial1_platform_data[] = {
 	{
 		.mapbase	= DAVINCI_UART1_BASE,
 		.irq		= IRQ_UARTINT1,
@@ -939,6 +944,11 @@ static struct plat_serial8250_port dm355_serial_platform_data[] = {
 		.iotype		= UPIO_MEM,
 		.regshift	= 2,
 	},
+	{
+		.flags	= 0,
+	}
+};
+static struct plat_serial8250_port dm355_serial2_platform_data[] = {
 	{
 		.mapbase	= DM355_UART2_BASE,
 		.irq		= IRQ_DM355_UARTINT2,
@@ -948,16 +958,34 @@ static struct plat_serial8250_port dm355_serial_platform_data[] = {
 		.regshift	= 2,
 	},
 	{
-		.flags		= 0
-	},
+		.flags	= 0,
+	}
 };
 
-static struct platform_device dm355_serial_device = {
-	.name			= "serial8250",
-	.id			= PLAT8250_DEV_PLATFORM,
-	.dev			= {
-		.platform_data	= dm355_serial_platform_data,
+static struct platform_device dm355_serial_device[] = {
+	{
+		.name			= "serial8250",
+		.id			= PLAT8250_DEV_PLATFORM,
+		.dev			= {
+			.platform_data	= dm355_serial0_platform_data,
+		}
+	},
+	{
+		.name			= "serial8250",
+		.id			= PLAT8250_DEV_PLATFORM1,
+		.dev			= {
+			.platform_data	= dm355_serial1_platform_data,
+		}
 	},
+	{
+		.name			= "serial8250",
+		.id			= PLAT8250_DEV_PLATFORM2,
+		.dev			= {
+			.platform_data	= dm355_serial2_platform_data,
+		}
+	},
+	{
+	}
 };
 
 static struct davinci_soc_info davinci_soc_info_dm355 = {
@@ -981,7 +1009,7 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.gpio_base		= DAVINCI_GPIO_BASE,
 	.gpio_num		= 104,
 	.gpio_irq		= IRQ_DM355_GPIOBNK0,
-	.serial_dev		= &dm355_serial_device,
+	.serial_dev		= dm355_serial_device,
 	.sram_dma		= 0x00010000,
 	.sram_len		= SZ_32K,
 };

commit 9c559708b6cda71d8fdabc3f98cb7e98edbd4f0b
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Fri Jul 12 15:19:03 2013 +0530

    ARM: davinci: make file local variables static
    
    Make file local variables static in mach-davinci.
    This fixes sparse warnings of the form:
    
    arch/arm/mach-davinci/dm355.c:863:27: warning: symbol 'dm355_venc_pdata' was not declared. Should it be static?
    
    Cc: Prabhakar Lad <prabhakar.csengg@gmail.com>
    Acked-by: Prabhakar Lad <prabhakar.csengg@gmail.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 42ef53f62c6c..86100d179694 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -860,7 +860,7 @@ static struct platform_device dm355_vpbe_display = {
 	},
 };
 
-struct venc_platform_data dm355_venc_pdata = {
+static struct venc_platform_data dm355_venc_pdata = {
 	.setup_pinmux	= dm355_vpbe_setup_pinmux,
 	.setup_clock	= dm355_venc_setup_clock,
 };

commit 6cba4355066bda19f14d4da66b8abbca0ffdfd59
Author: Matt Porter <mporter@ti.com>
Date:   Thu Jun 20 16:06:38 2013 -0500

    ARM: edma: Add DT and runtime PM support to the private EDMA API
    
    Adds support for parsing the TI EDMA DT data into the required EDMA
    private API platform data. Enables runtime PM support to initialize
    the EDMA hwmod. Enables build on OMAP.
    
    Changes by Joel:
    * Setup default one-to-one mapping for queue_priority and queue_tc
    mapping as discussed in [1].
    * Split out xbar stuff to separate patch. [1]
    * Dropped unused DT helper to convert to array
    * Fixed dangling pointer issue with Sekhar's changes
    
    [1] https://patchwork.kernel.org/patch/2226761/
    
    Signed-off-by: Matt Porter <mporter@ti.com>
    [nsekhar@ti.com: fix checkpatch errors, build breakages. Introduce
    edma_setup_info_from_dt() as part of that effort]
    Signed-off-by: Joel A Fernandes <joelagnel@ti.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 526cf7d06d0e..42ef53f62c6c 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -569,7 +569,7 @@ static u8 dm355_default_priorities[DAVINCI_N_AINTC_IRQ] = {
 
 /*----------------------------------------------------------------------*/
 
-static const s8
+static s8
 queue_tc_mapping[][2] = {
 	/* {event queue no, TC no} */
 	{0, 0},
@@ -577,7 +577,7 @@ queue_tc_mapping[][2] = {
 	{-1, -1},
 };
 
-static const s8
+static s8
 queue_priority_mapping[][2] = {
 	/* {event queue no, Priority} */
 	{0, 3},

commit 3ad7a42d5a9c3736cd6d2c6f7e6038d0ca8b316c
Author: Matt Porter <mporter@ti.com>
Date:   Wed Mar 6 11:15:31 2013 -0500

    ARM: davinci: move private EDMA API to arm/common
    
    Move mach-davinci/dma.c to common/edma.c so it can be used
    by OMAP (specifically AM33xx) as well.
    
    Signed-off-by: Matt Porter <mporter@ti.com>
    Acked-by: Chris Ball <cjb@laptop.org> # davinci_mmc.c
    Acked-by: Mark Brown <broonie@linaro.org>
    Acked-by: Olof Johansson <olof@lixom.net>
    [nsekhar@ti.com: dropped davinci sffsdr changes]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index a11034a358f1..526cf7d06d0e 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -19,7 +19,6 @@
 #include <asm/mach/map.h>
 
 #include <mach/cputype.h>
-#include <mach/edma.h>
 #include <mach/psc.h>
 #include <mach/mux.h>
 #include <mach/irqs.h>
@@ -28,6 +27,7 @@
 #include <mach/common.h>
 #include <linux/platform_data/spi-davinci.h>
 #include <mach/gpio-davinci.h>
+#include <linux/platform_data/edma.h>
 
 #include "davinci.h"
 #include "clock.h"

commit 97b1007a2924aaa9126398623f6755a8c3c6a616
Merge: dfab34aa61a0 e0d20b69d3fa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 2 09:31:45 2013 -0700

    Merge tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform updates from Olof Johansson:
     "This branch contains part 1 of the platform updates for 3.10.  Among
      the highlights:
    
       - Support for the new Atmel Cortex-A5 based platforms (SAMA5D3)
       - New support for CSR SiRFatlas6 SoCs
       - A handful of updates for NVidia T114 (a.k.a. Tegra 4)
       - A bunch of updates for the shmobile platforms
       - A handful of updates for davinci
       - A few updates for Qualcomm MSM
       - Plus a handful of other patches, defconfig updates, etc."
    
    * tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (135 commits)
      ARM: tegra: pm: fix build error w/o PM_SLEEP
      ARM: davinci: ensure global variables are declared
      ARM: davinci: sram.c: fix incorrect type in assignment
      ARM: davinci: da8xx dt: make file local symbols static
      ARM: davinci: da8xx: add remoteproc support
      ARM: socfpga: Upgrade clk driver for socfpga to make use of dts clock entries
      ARM: socfpga: Add clock entries into device tree
      ARM: socfpga: Enable soft reset
      ARM: EXYNOS: replace cpumask by the corresponding macro
      ARM: EXYNOS: handle properly the return values
      ARM: EXYNOS: factor out the idle states
      ARM: OMAP4: Enable fix for Cortex-A9 erratas
      ARM: OMAP2+: Export SoC information to userspace
      ARM: OMAP2+: SoC name and revision unification
      ARM: OMAP2+: Move common part of late init into common function
      ARM: tegra: pm: remove duplicated include from pm.c
      ARM: davinci: da850: override mmc DT node device name
      ARM: davinci: da850: add mmc DT entries
      mmc: davinci_mmc: add DT support
      ARM: SAMSUNG: check processor type before cache restoration in resume
      ...

commit 62a2d6cd56a4db3ab59322ad6c95f762a842d7ab
Author: Lad, Prabhakar <prabhakar.csengg@gmail.com>
Date:   Tue Apr 9 10:35:05 2013 -0300

    [media] ARM: davinci: dm355: add support for v4l2 video display
    
    Create platform devices for various video modules like venc,osd,
    vpbe and v4l2 driver for dm355.
    
    Signed-off-by: Lad, Prabhakar <prabhakar.csengg@gmail.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 8e98bb06b1c1..bf9a9d4ad9f5 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -35,6 +35,8 @@
 #include "asp.h"
 
 #define DM355_UART2_BASE	(IO_PHYS + 0x206000)
+#define DM355_OSD_BASE		(IO_PHYS + 0x70200)
+#define DM355_VENC_BASE		(IO_PHYS + 0x70400)
 
 /*
  * Device specific clocks
@@ -744,11 +746,146 @@ static struct platform_device vpfe_capture_dev = {
 	},
 };
 
-void dm355_set_vpfe_config(struct vpfe_config *cfg)
+static struct resource dm355_osd_resources[] = {
+	{
+		.start	= DM355_OSD_BASE,
+		.end	= DM355_OSD_BASE + 0x17f,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device dm355_osd_dev = {
+	.name		= DM355_VPBE_OSD_SUBDEV_NAME,
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(dm355_osd_resources),
+	.resource	= dm355_osd_resources,
+	.dev		= {
+		.dma_mask		= &vpfe_capture_dma_mask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+};
+
+static struct resource dm355_venc_resources[] = {
+	{
+		.start	= IRQ_VENCINT,
+		.end	= IRQ_VENCINT,
+		.flags	= IORESOURCE_IRQ,
+	},
+	/* venc registers io space */
+	{
+		.start	= DM355_VENC_BASE,
+		.end	= DM355_VENC_BASE + 0x17f,
+		.flags	= IORESOURCE_MEM,
+	},
+	/* VDAC config register io space */
+	{
+		.start	= DAVINCI_SYSTEM_MODULE_BASE + SYSMOD_VDAC_CONFIG,
+		.end	= DAVINCI_SYSTEM_MODULE_BASE + SYSMOD_VDAC_CONFIG + 3,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct resource dm355_v4l2_disp_resources[] = {
+	{
+		.start	= IRQ_VENCINT,
+		.end	= IRQ_VENCINT,
+		.flags	= IORESOURCE_IRQ,
+	},
+	/* venc registers io space */
+	{
+		.start	= DM355_VENC_BASE,
+		.end	= DM355_VENC_BASE + 0x17f,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static int dm355_vpbe_setup_pinmux(enum v4l2_mbus_pixelcode if_type,
+			    int field)
+{
+	switch (if_type) {
+	case V4L2_MBUS_FMT_SGRBG8_1X8:
+		davinci_cfg_reg(DM355_VOUT_FIELD_G70);
+		break;
+	case V4L2_MBUS_FMT_YUYV10_1X20:
+		if (field)
+			davinci_cfg_reg(DM355_VOUT_FIELD);
+		else
+			davinci_cfg_reg(DM355_VOUT_FIELD_G70);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	davinci_cfg_reg(DM355_VOUT_COUTL_EN);
+	davinci_cfg_reg(DM355_VOUT_COUTH_EN);
+
+	return 0;
+}
+
+static int dm355_venc_setup_clock(enum vpbe_enc_timings_type type,
+				   unsigned int pclock)
 {
-	vpfe_capture_dev.dev.platform_data = cfg;
+	void __iomem *vpss_clk_ctrl_reg;
+
+	vpss_clk_ctrl_reg = DAVINCI_SYSMOD_VIRT(SYSMOD_VPSS_CLKCTL);
+
+	switch (type) {
+	case VPBE_ENC_STD:
+		writel(VPSS_DACCLKEN_ENABLE | VPSS_VENCCLKEN_ENABLE,
+		       vpss_clk_ctrl_reg);
+		break;
+	case VPBE_ENC_DV_TIMINGS:
+		if (pclock > 27000000)
+			/*
+			 * For HD, use external clock source since we cannot
+			 * support HD mode with internal clocks.
+			 */
+			writel(VPSS_MUXSEL_EXTCLK_ENABLE, vpss_clk_ctrl_reg);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
 }
 
+static struct platform_device dm355_vpbe_display = {
+	.name		= "vpbe-v4l2",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(dm355_v4l2_disp_resources),
+	.resource	= dm355_v4l2_disp_resources,
+	.dev		= {
+		.dma_mask		= &vpfe_capture_dma_mask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+};
+
+struct venc_platform_data dm355_venc_pdata = {
+	.setup_pinmux	= dm355_vpbe_setup_pinmux,
+	.setup_clock	= dm355_venc_setup_clock,
+};
+
+static struct platform_device dm355_venc_dev = {
+	.name		= DM355_VPBE_VENC_SUBDEV_NAME,
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(dm355_venc_resources),
+	.resource	= dm355_venc_resources,
+	.dev		= {
+		.dma_mask		= &vpfe_capture_dma_mask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+		.platform_data		= (void *)&dm355_venc_pdata,
+	},
+};
+
+static struct platform_device dm355_vpbe_dev = {
+	.name		= "vpbe_controller",
+	.id		= -1,
+	.dev		= {
+		.dma_mask		= &vpfe_capture_dma_mask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+};
+
 /*----------------------------------------------------------------------*/
 
 static struct map_desc dm355_io_desc[] = {
@@ -868,6 +1005,29 @@ void __init dm355_init(void)
 	davinci_map_sysmod();
 }
 
+int __init dm355_init_video(struct vpfe_config *vpfe_cfg,
+				struct vpbe_config *vpbe_cfg)
+{
+	if (vpfe_cfg || vpbe_cfg)
+		platform_device_register(&dm355_vpss_device);
+
+	if (vpfe_cfg) {
+		vpfe_capture_dev.dev.platform_data = vpfe_cfg;
+		platform_device_register(&dm355_ccdc_dev);
+		platform_device_register(&vpfe_capture_dev);
+	}
+
+	if (vpbe_cfg) {
+		dm355_vpbe_dev.dev.platform_data = vpbe_cfg;
+		platform_device_register(&dm355_osd_dev);
+		platform_device_register(&dm355_venc_dev);
+		platform_device_register(&dm355_vpbe_dev);
+		platform_device_register(&dm355_vpbe_display);
+	}
+
+	return 0;
+}
+
 static int __init dm355_init_devices(void)
 {
 	if (!cpu_is_davinci_dm355())
@@ -875,9 +1035,6 @@ static int __init dm355_init_devices(void)
 
 	davinci_cfg_reg(DM355_INT_EDMA_CC);
 	platform_device_register(&dm355_edma_device);
-	platform_device_register(&dm355_vpss_device);
-	platform_device_register(&dm355_ccdc_dev);
-	platform_device_register(&vpfe_capture_dev);
 
 	return 0;
 }

commit 9a3e89b10f5e48c0d8cca7896c02bf4d76d0ae46
Author: Lad, Prabhakar <prabhakar.csengg@gmail.com>
Date:   Fri Mar 22 04:53:12 2013 -0300

    [media] media: davinci: vpss: enable vpss clocks
    
    By default the VPSS clocks were enabled in capture driver
    for davinci family which creates duplicates for dm355/dm365/dm644x.
    This patch adds support to enable the VPSS clocks in VPSS driver,
    which avoids duplication of code and also adding clock aliases.
    This patch uses PM runtime API to enable/disable clock, instead
    of DaVinci clock framework. con_ids for master and slave clocks of
    vpss is added in pm_domain.
    This patch cleanups the VPSS clock enabling in the capture driver,
    and also removes the clock alias in machine file. Along side adds
    a vpss slave clock for DM365 as mentioned by Sekhar
    (https://patchwork.kernel.org/patch/1221261/).
    The Suspend/Resume in dm644x_ccdc.c which enabled/disabled the VPSS clock
    is now implemented as part of the VPSS driver.
    
    Signed-off-by: Lad, Prabhakar <prabhakar.csengg@gmail.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index b49c3b77d55e..8e98bb06b1c1 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -345,8 +345,8 @@ static struct clk_lookup dm355_clks[] = {
 	CLK(NULL, "pll1_aux", &pll1_aux_clk),
 	CLK(NULL, "pll1_sysclkbp", &pll1_sysclkbp),
 	CLK(NULL, "vpss_dac", &vpss_dac_clk),
-	CLK(NULL, "vpss_master", &vpss_master_clk),
-	CLK(NULL, "vpss_slave", &vpss_slave_clk),
+	CLK("vpss", "master", &vpss_master_clk),
+	CLK("vpss", "slave", &vpss_slave_clk),
 	CLK(NULL, "clkout1", &clkout1_clk),
 	CLK(NULL, "clkout2", &clkout2_clk),
 	CLK(NULL, "pll2", &pll2_clk),
@@ -873,9 +873,6 @@ static int __init dm355_init_devices(void)
 	if (!cpu_is_davinci_dm355())
 		return 0;
 
-	/* Add ccdc clock aliases */
-	clk_add_alias("master", dm355_ccdc_dev.name, "vpss_master", NULL);
-	clk_add_alias("slave", dm355_ccdc_dev.name, "vpss_master", NULL);
 	davinci_cfg_reg(DM355_INT_EDMA_CC);
 	platform_device_register(&dm355_edma_device);
 	platform_device_register(&dm355_vpss_device);

commit d7ca4c755a82eda8f0fc4f72c52130056b28c7d2
Author: Manjunathappa, Prakash <prakash.pm@ti.com>
Date:   Thu Mar 28 18:41:59 2013 +0530

    ARM: davinci: mmc: derive version information from device name
    
    Remove specifying mmc controller IP version information via platform
    data, instead specify device name so that driver derives it from
    platform_device_id table. Also change the clock node name to match
    the changed dev_id.
    Tested on da850-evm to make sure driver loads without clk_get failures.
    
    Signed-off-by: Manjunathappa, Prakash <prakash.pm@ti.com>
    Reviewed-by: Sekhar Nori <nsekhar@ti.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index b49c3b77d55e..87e6104f45e6 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -361,8 +361,8 @@ static struct clk_lookup dm355_clks[] = {
 	CLK("i2c_davinci.1", NULL, &i2c_clk),
 	CLK("davinci-mcbsp.0", NULL, &asp0_clk),
 	CLK("davinci-mcbsp.1", NULL, &asp1_clk),
-	CLK("davinci_mmc.0", NULL, &mmcsd0_clk),
-	CLK("davinci_mmc.1", NULL, &mmcsd1_clk),
+	CLK("dm6441-mmc.0", NULL, &mmcsd0_clk),
+	CLK("dm6441-mmc.1", NULL, &mmcsd1_clk),
 	CLK("spi_davinci.0", NULL, &spi0_clk),
 	CLK("spi_davinci.1", NULL, &spi1_clk),
 	CLK("spi_davinci.2", NULL, &spi2_clk),

commit 626863a3f32f0baaf55a1d18b8d4fbb937700dda
Author: Ben Gardiner <bengardiner@nanometrics.ca>
Date:   Fri Oct 5 13:04:41 2012 -0400

    ARM: davinci: sram: switch from iotable to ioremapped regions
    
    The current davinci init sets up SRAM in iotables. There has been
    an observed failure to boot a da850 with 128K specified in the
    iotable.
    
    Make the davinci sram allocator do an ioremap of the region
    specified by the entries in davinci_soc_info before registering
    with gen_pool_add_virt(). Remove all iotable SRAM mappings and
    SRAM_VIRT.
    
    Regression tested suspend/resume on AM180x EVM.
    
    Signed-off-by: Ben Gardiner <bengardiner@nanometrics.ca>
    Signed-off-by: Matt Porter <mporter@ti.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index a255434908db..b49c3b77d55e 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -758,12 +758,6 @@ static struct map_desc dm355_io_desc[] = {
 		.length		= IO_SIZE,
 		.type		= MT_DEVICE
 	},
-	{
-		.virtual	= SRAM_VIRT,
-		.pfn		= __phys_to_pfn(0x00010000),
-		.length		= SZ_32K,
-		.type		= MT_MEMORY_NONCACHED,
-	},
 };
 
 /* Contents of JTAG ID register used to identify exact cpu type */

commit f5a246eab9a268f51ba8189ea5b098a1bfff200e
Merge: d5bbd43d5f45 7ff34ad80b70
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 9 07:07:14 2012 +0900

    Merge tag 'sound-3.7' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "This contains pretty many small commits covering fairly large range of
      files in sound/ directory.  Partly because of additional API support
      and partly because of constantly developed ASoC and ARM stuff.
    
      Some highlights:
    
       - Introduced the helper function and documentation for exposing the
         channel map via control API, as discussed in Plumbers; most of PCI
         drivers are covered, will follow more drivers later
    
       - Most of drivers have been replaced with the new PM callbacks (if
         the bus is supported)
    
       - HD-audio controller got the support of runtime PM and the support
         of D3 clock-stop.  Also changing the power_save option in sysfs
         kicks off immediately to enable / disable the power-save mode.
    
       - Another significant code change in HD-audio is the rewrite of
         firmware loading code.  Other than that, most of changes in
         HD-audio are continued cleanups and standardization for the generic
         auto parser and bug fixes (HBR, device-specific fixups), in
         addition to the support of channel-map API.
    
       - Addition of ASoC bindings for the compressed API, used by the
         mid-x86 drivers.
    
       - Lots of cleanups and API refreshes for ASoC codec drivers and
         DaVinci.
    
       - Conversion of OMAP to dmaengine.
    
       - New machine driver for Wolfson Microelectronics Bells.
    
       - New CODEC driver for Wolfson Microelectronics WM0010.
    
       - Enhancements to the ux500 and wm2000 drivers
    
       - A new driver for DA9055 and the support for regulator bypass mode."
    
    Fix up various arm soc header file reorg conflicts.
    
    * tag 'sound-3.7' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (339 commits)
      ALSA: hda - Add new codec ALC283 ALC290 support
      ALSA: hda - avoid unneccesary indices on "Headphone Jack" controls
      ALSA: hda - fix indices on boost volume on Conexant
      ALSA: aloop - add locking to timer access
      ALSA: hda - Fix hang caused by race during suspend.
      sound: Remove unnecessary semicolon
      ALSA: hda/realtek - Fix detection of ALC271X codec
      ALSA: hda - Add inverted internal mic quirk for Lenovo IdeaPad U310
      ALSA: hda - make Realtek/Sigmatel/Conexant use the generic unsol event
      ALSA: hda - make a generic unsol event handler
      ASoC: codecs: Add DA9055 codec driver
      ASoC: eukrea-tlv320: Convert it to platform driver
      ALSA: ASoC: add DT bindings for CS4271
      ASoC: wm_hubs: Ensure volume updates are handled during class W startup
      ASoC: wm5110: Adding missing volume update bits
      ASoC: wm5110: Add OUT3R support
      ASoC: wm5110: Add AEC loopback support
      ASoC: wm5110: Rename EPOUT to HPOUT3
      ASoC: arizona: Add more clock rates
      ASoC: arizona: Add more DSP options for mixer input muxes
      ...

commit ec2a0833e5157fab6cac5f57a49b2f31eb418a39
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Aug 24 15:11:34 2012 +0200

    ARM: davinci: move platform_data definitions
    
    Platform data for device drivers should be defined in
    include/linux/platform_data/*.h, not in the architecture
    and platform specific directories.
    
    This moves such data out of the davinci include directories
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Cc: Sekhar Nori <nsekhar@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: "Ben Dooks" <ben-linux@fluff.org>
    Cc: "Wolfram Sang" <w.sang@pengutronix.de>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Chris Ball <cjb@laptop.org>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Liam Girdwood <lrg@ti.com>
    Cc: davinci-linux-open-source@linux.davincidsp.com

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 678cd99b7336..adbde33eca01 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -27,7 +27,7 @@
 #include <mach/serial.h>
 #include <mach/common.h>
 #include <mach/asp.h>
-#include <mach/spi.h>
+#include <linux/platform_data/spi-davinci.h>
 #include <mach/gpio-davinci.h>
 
 #include "davinci.h"

commit 896f66b7de293644e65cf62600e4933af954dcf2
Author: Hebbar, Gururaja <gururaja.hebbar@ti.com>
Date:   Mon Aug 27 18:56:41 2012 +0530

    ASoC/ARM: Davinci: McASP: split asp header into platform and audio specific
    
    Davinci McASP header & driver are shared by few OMAP platforms (like
    TI81xx, AM335x). Splitting asp header into Davinci platform specific
    header and Audio specific header helps to share them across platforms.
    
    Audio specific defines is moved to to common
    <linux/platform_data/davinci_asp.h> so that the header can be
    accessed by all related platforms.
    
    While here, correct the header usage (remove multiple header
    re-definitions and unused headers) and remove platform names from
    structures comments and enum. Also some some coding style errors.
    
    Signed-off-by: Hebbar, Gururaja <gururaja.hebbar@ti.com>
    Acked-by: Vaibhav Bedia <vaibhav.bedia@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 678cd99b7336..e47a3f0e8ac4 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -26,13 +26,13 @@
 #include <mach/time.h>
 #include <mach/serial.h>
 #include <mach/common.h>
-#include <mach/asp.h>
 #include <mach/spi.h>
 #include <mach/gpio-davinci.h>
 
 #include "davinci.h"
 #include "clock.h"
 #include "mux.h"
+#include "asp.h"
 
 #define DM355_UART2_BASE	(IO_PHYS + 0x206000)
 

commit d65566e50b35165c5d89cd6ea5049662ae6da43b
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Fri Mar 30 22:13:53 2012 +0200

    ARM: davinci: mark spi_board_info arguments as const
    
    spi_board_info is not modified in any of the spi registeration
    functions and passed along as-is to the generic SPI layer.
    
    Mark spi_board_info arguments as const to signal this.
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    [nsekhar@ti.com: extended for dm365 and dm355]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index fd3d09aa6cde..678cd99b7336 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -424,7 +424,7 @@ static struct platform_device dm355_spi0_device = {
 };
 
 void __init dm355_init_spi0(unsigned chipselect_mask,
-		struct spi_board_info *info, unsigned len)
+		const struct spi_board_info *info, unsigned len)
 {
 	/* for now, assume we need MISO */
 	davinci_cfg_reg(DM355_SPI0_SDI);

commit 5cfb19ac604a68c030b245561f575c2d1bac1d49
Author: Manjunath Hadli <manjunath.hadli@ti.com>
Date:   Wed Dec 21 19:13:36 2011 +0530

    ARM: davinci: streamline sysmod access
    
    There are instances of IO_ADDRESS() being used for system module
    (sysmod) register access. Eliminate this in favor of a ioremap()
    based access. ioremap() the entire sysmod address space once during
    boot-up and provide a helper macro to access specific register
    offsets within the address space.
    
    With this, also eliminate ioremap() of specific sysmodule registers
    related to VPIF happening in DM646x EVM code.
    
    While at it, also eliminate some duplicate sysmod register offset macros
    defined in code and place offset definitions at one place in davinci.h
    
    Signed-off-by: Manjunath Hadli <manjunath.hadli@ti.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    [nsekhar@ti.com: removed the addition of ifndef __ASSEMBLER__
    in davinci.h, eliminate IO_ADDRESS() usage left out in dm646x.c,
    cleanup VPIF sysmodule register access as part of this patch and
    keep all sysmod offsets in davinci.h Also, convert the WARN_ON()
    on failure to setup sysmod base to BUG_ON()]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 0b0d41c1bd8f..fd3d09aa6cde 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -871,6 +871,7 @@ void __init dm355_init_asp1(u32 evt_enable, struct snd_platform_data *pdata)
 void __init dm355_init(void)
 {
 	davinci_common_init(&davinci_soc_info_dm355);
+	davinci_map_sysmod();
 }
 
 static int __init dm355_init_devices(void)

commit 39c6d2d1d743b8c925abae7043acc35e6cdc0051
Author: Manjunath Hadli <manjunath.hadli@ti.com>
Date:   Wed Dec 21 19:13:35 2011 +0530

    ARM: davinci: create new common platform header for davinci
    
    Remove individual platform header files for dm365, dm355, dm644x
    and dm646x and consolidate it into a single and common
    header file davinci.h placed in arch/arm/mach-davinci.
    
    This reduces the pollution in the include/mach and is consistent
    with Russell's suggestions as part of his "pet peaves" mail.
    (See #4 in: http://lists.infradead.org/pipermail/linux-arm-kernel/2011-November/071516.html)
    
    While at it, fix the forward declaration of spi_board_info,
    and include the right header file instead.
    
    The further patches in the series take  advantage of this consolidation
    for easy implementation of IO_ADDRESS elimination.
    
    Signed-off-by: Manjunath Hadli <manjunath.hadli@ti.com>
    [nsekhar@ti.com: make davinci.h the first local include file,
    fix forward declaration of spi_board_info and add back Deep Root
    Systems, LLC copyright]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 19667cfc5de0..0b0d41c1bd8f 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -18,7 +18,6 @@
 
 #include <asm/mach/map.h>
 
-#include <mach/dm355.h>
 #include <mach/cputype.h>
 #include <mach/edma.h>
 #include <mach/psc.h>
@@ -31,6 +30,7 @@
 #include <mach/spi.h>
 #include <mach/gpio-davinci.h>
 
+#include "davinci.h"
 #include "clock.h"
 #include "mux.h"
 

commit c6121ddd1f75278ab77504af2914d07831558672
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Mon Dec 5 11:29:46 2011 +0100

    ARM: 7190/1: restart: davinci: use new restart hook
    
    Rather than using DaVinci specific davinci_soc_info based
    restart hook, use the restart hook available in the machine
    descriptor instead.
    
    Tested on DM365 and AM18x EVMs.
    
    v2:
    Changed to use restart hook in machine descriptor
    per Russell's comment.
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index fe520d4167a2..19667cfc5de0 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -853,7 +853,6 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.serial_dev		= &dm355_serial_device,
 	.sram_dma		= 0x00010000,
 	.sram_len		= SZ_32K,
-	.reset_device		= &davinci_wdt_device,
 };
 
 void __init dm355_init_asp1(u32 evt_enable, struct snd_platform_data *pdata)

commit 3e965b176341b78620f7404fd8b7f9a0d061f8a2
Merge: 034ee299122c 5839fec9d8db
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Oct 31 23:25:41 2011 +0100

    Merge branch 'next/fixes' into next/cleanup
    
    Conflicts:
            arch/arm/mach-mxs/include/mach/gpio.h
            arch/arm/plat-mxc/include/mach/gpio.h
            drivers/video/omap/lcd_apollon.c
            drivers/video/omap/lcd_ldp.c
            drivers/video/omap/lcd_overo.c

commit f23fe857bbea393b4b94fe2218c98d934bd3d4cf
Author: Ido Yariv <ido@wizery.com>
Date:   Sun Jul 10 16:14:35 2011 +0300

    ARM: davinci: Explicitly set channel controllers' default queues
    
    Davinci platforms may define a default queue for each channel
    controller. If one is not defined, the default queue is set to EVENTQ_1.
    However, there's no way to distinguish between an unset default queue to
    one that is set to EVENTQ_0, as EVENTQ_0 = 0.
    
    Explicitly specify the default queue for all channel controllers on all
    Davinci platforms to EVENTQ_1, and don't overwrite it in the EDMA probe
    function.
    
    One exception is the DA850 board, for which EVENTQ_1 is not a valid
    option for its second channel controller. Use EVENTQ_0 instead for that
    channel controller.
    
    Signed-off-by: Ido Yariv <ido@wizery.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index a3a94e9c9378..68fb18162459 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -591,6 +591,7 @@ static struct edma_soc_info edma_cc0_info = {
 	.n_cc			= 1,
 	.queue_tc_mapping	= queue_tc_mapping,
 	.queue_priority_mapping	= queue_priority_mapping,
+	.default_queue		= EVENTQ_1,
 };
 
 static struct edma_soc_info *dm355_edma_info[EDMA_MAX_CC] = {

commit 5f3fcf9649dbb010ccac41259d04147775ec8fc2
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Aug 22 08:40:38 2011 +0100

    ARM: 7040/1: mach-davinci: break out GPIO driver specifics
    
    The <mach/gpio.h> file is included from upper directories
    and deal with generic GPIO and gpiolib stuff. Break out the
    platform and driver specific defines and functions into its own
    header file.
    
    Cc: Sekhar Nori <nsekhar@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index a3a94e9c9378..c143f43addcc 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -13,7 +13,6 @@
 #include <linux/serial_8250.h>
 #include <linux/platform_device.h>
 #include <linux/dma-mapping.h>
-#include <linux/gpio.h>
 
 #include <linux/spi/spi.h>
 
@@ -30,6 +29,7 @@
 #include <mach/common.h>
 #include <mach/asp.h>
 #include <mach/spi.h>
+#include <mach/gpio-davinci.h>
 
 #include "clock.h"
 #include "mux.h"

commit e9c549998dc24209847007e1f209f3b6c88d21ba
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Tue Apr 26 23:28:26 2011 -0700

    Revert wrong fixes for common misspellings
    
    These changes were incorrectly fixed by codespell. They were now
    manually corrected.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index f68012239641..a3a94e9c9378 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -314,7 +314,7 @@ static struct clk timer2_clk = {
 	.name = "timer2",
 	.parent = &pll1_aux_clk,
 	.lpsc = DAVINCI_LPSC_TIMER2,
-	.usecount = 1,              /* REVISIT: why can't' this be disabled? */
+	.usecount = 1,              /* REVISIT: why can't this be disabled? */
 };
 
 static struct clk timer3_clk = {

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 76364d1345df..f68012239641 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -314,7 +314,7 @@ static struct clk timer2_clk = {
 	.name = "timer2",
 	.parent = &pll1_aux_clk,
 	.lpsc = DAVINCI_LPSC_TIMER2,
-	.usecount = 1,              /* REVISIT: why cant' this be disabled? */
+	.usecount = 1,              /* REVISIT: why can't' this be disabled? */
 };
 
 static struct clk timer3_clk = {

commit 2e3e2a5e4fef586ae9b1cfef42823c0aef1797f4
Author: Michael Williamson <michael.williamson@criticallink.com>
Date:   Tue Feb 8 07:59:55 2011 -0500

    davinci: spi: move event queue parameter to platform data
    
    For DMA operation, the davinci spi driver needs an event queue number.
    Currently, this number is passed as a IORESOURCE_DMA.  This is not
    correct, as the event queue is not a DMA channel.  Pass the event queue
    via the platform data structure instead.
    
    On dm355 and dm365, move the eventq assignment for spi0 out of resources
    array and into platform data.
    
    Signed-off-by: Michael Williamson <michael.williamson@criticallink.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index a5f8a80c1f28..76364d1345df 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -403,16 +403,13 @@ static struct resource dm355_spi0_resources[] = {
 		.start = 16,
 		.flags = IORESOURCE_DMA,
 	},
-	{
-		.start = EVENTQ_1,
-		.flags = IORESOURCE_DMA,
-	},
 };
 
 static struct davinci_spi_platform_data dm355_spi0_pdata = {
 	.version 	= SPI_VERSION_1,
 	.num_chipselect = 2,
 	.cshold_bug	= true,
+	.dma_event_q	= EVENTQ_1,
 };
 static struct platform_device dm355_spi0_device = {
 	.name = "spi_davinci",

commit 496a2e360a34e1f41c336d23947f800216cb9bdf
Merge: 5aa68b85951a 23ce17adb7fc
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed Dec 29 00:47:29 2010 -0700

    Merge branch 'for-grant' of git://arago-project.org/git/projects/linux-davinci into spi/next
    
    * 'for-grant' of git://arago-project.org/git/projects/linux-davinci into spi/next
       spi: davinci: fix checkpatch errors
       spi: davinci: whitespace cleanup
       spi: davinci: remove unused variable 'pdata'
       spi: davinci: set chip-select mode in SPIDEF only once
       spi: davinci: enable both activation and deactivation of chip-selects
       spi: davinci: remove unnecessary data transmit on CS disable
       spi: davinci: enable GPIO lines to be used as chip selects
       spi: davinci: simplify prescalar calculation
       spi: davinci: remove 'wait_enable' platform data member
       spi: davinci: make chip-slect specific parameters really chip-select specific
       spi: davinci: consolidate setup of SPIFMTn in one function
       spi: davinci: setup chip-select timers values only if timer enabled
       spi: davinci: add support for wait enable timeouts
       spi: davinci: remove unused members of davinci_spi_slave
       spi: davinci: eliminate the single member structure davinci_spi_slave
       spi: davinci: eliminate unnecessary update of davinci_spi->count
       spi: davinci: simplify calculation of edma acount value
       spi: davinci: check for NULL buffer pointer before using it
       spi: davinci: remove unnecessary disable of SPI
       spi: davinci: remove unnecessary 'count' variable in driver private data
       spi: davinci: remove unnecessary completion variable initialization
       spi: davinci: remove non-useful interrupt mode support
       spi: davinci: simplify poll mode transfers
       spi: davinci: add support for interrupt mode
       spi: davinci: configure the invariable bits in spipc0 only once
       spi: davinci: remove unnecessary function davinci_spi_bufs_prep()
       spi: davinci: remove unnecessary call to davinci_spi_setup_transfer()
       spi: davinci: do not store DMA channel information per chip select
       spi: davinci: always start transmit DMA
       spi: davinci: do not use temporary buffer if no transmit data provided
       spi: davinci: always start receive DMA
       spi: davinci: use edma_write_slot() to setup EDMA PaRAM slot
       spi: davinci: fix DMA event generation stoppage
       spi: davinci: fix EDMA CC errors at end of transfers
       spi: davinci: handle DMA completion errors correctly
       spi: davinci: remove usage of additional completion variables for DMA
       spi: davinci: let DMA operation be specified on per-device basis
       spi: davinci: remove non-useful "clk_internal" platform data
       spi: davinci: enable and power-up SPI only when required
       spi: davinci: setup the driver owner
       spi: davinci: add additional comments
       spi: davinci: add EF Johnson Technologies copyright
       spi: davinci: removed unused #defines
       spi: davinci: remove unnecessary typecast
       spi: davinci: do not treat Tx interrupt being set as error
       spi: davinci: do not allocate DMA channels during SPI device setup
       spi: davinci: remove unnecessary private data member 'region_size'
       spi: davinci: shorten variable names
       spi: davinci: kconfig: add manufacturer name to prompt string

commit 3409e408ab0d7171ae81d198110a1f293852959f
Author: Brian Niebuhr <bniebuhr@efjohnson.com>
Date:   Wed Oct 6 18:13:31 2010 +0530

    spi: davinci: remove non-useful "clk_internal" platform data
    
    The "clk_internal" platform data member which contols the
    CLKMOD bit in Global Control Register 1 is not useful
    since CLKMOD needs be set to 1 *always* to ensure master
    mode operation.
    
    Remove this platform data.
    
    Signed-off-by: Brian Niebuhr <bniebuhr@efjohnson.com>
    Tested-By: Michael Williamson <michael.williamson@criticallink.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 27ee870b2d27..c0c501a4c139 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -412,7 +412,6 @@ static struct resource dm355_spi0_resources[] = {
 static struct davinci_spi_platform_data dm355_spi0_pdata = {
 	.version 	= SPI_VERSION_1,
 	.num_chipselect = 2,
-	.clk_internal	= 1,
 	.cshold_bug	= true,
 };
 static struct platform_device dm355_spi0_device = {

commit c29e3c60e75d1cc1262ac8af379738b6fd851f33
Author: Brian Niebuhr <bniebuhr@efjohnson.com>
Date:   Tue Sep 28 13:59:26 2010 +0530

    spi: davinci: always start transmit DMA
    
    Due to the full duplex nature of the SPI bus, the SPI master
    on DaVinci needs transmit to be active even if the tranfer is
    only meant to collect receive data.
    
    The current code achieves this by using a temporary zeroed buffer
    to provide DMA data in case the transfer does not have a transmit
    buffer provided.
    
    However, the transmit DMA is started only if transmit buffer is
    provided rendering the temporary buffer unused. Instead the code
    relies on a write to SPIDAT1 register to trigger transmit operation.
    This however only sends two bytes of data.
    
    Fix this by starting transmit DMA always.
    
    This changes exposes a bug on DM355 where the CSHOLD bit in
    SPIDAT1 needs to be written to in between transfers. Handle
    that by introducing a "cshold_bug" platform data which is
    set to true for DM355.
    
    Signed-off-by: Brian Niebuhr <bniebuhr@efjohnson.com>
    Tested-By: Michael Williamson <michael.williamson@criticallink.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index e311f29ffb57..27ee870b2d27 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -413,6 +413,7 @@ static struct davinci_spi_platform_data dm355_spi0_pdata = {
 	.version 	= SPI_VERSION_1,
 	.num_chipselect = 2,
 	.clk_internal	= 1,
+	.cshold_bug	= true,
 };
 static struct platform_device dm355_spi0_device = {
 	.name = "spi_davinci",

commit cf90fe73504764cbcc2552c7ea69b1866059db30
Author: Brian Niebuhr <bniebuhr@efjohnson.com>
Date:   Fri Aug 20 17:02:49 2010 +0530

    spi: davinci: remove non-useful interrupt mode support
    
    The interrupt mode support as it stands is another version
    of poll mode. Even when interrupt mode is selected, the code
    tight loops on interrupt status register, rendering it totally
    useless. A completion variable is initialized, but never used.
    
    Remove this fake interrupt mode since users can anyway use
    poll mode with no functional difference. A usefully implemented
    interrupt mode support can be added later.
    
    Signed-off-by: Brian Niebuhr <bniebuhr@efjohnson.com>
    Tested-By: Michael Williamson <michael.williamson@criticallink.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index a6d9b72190ff..e311f29ffb57 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -413,7 +413,6 @@ static struct davinci_spi_platform_data dm355_spi0_pdata = {
 	.version 	= SPI_VERSION_1,
 	.num_chipselect = 2,
 	.clk_internal	= 1,
-	.poll_mode	= 1,	/* 0 -> interrupt mode 1-> polling mode */
 };
 static struct platform_device dm355_spi0_device = {
 	.name = "spi_davinci",

commit 53a31b07c5aea4001bbb36ddd5ef2addffc7ccbd
Author: Brian Niebuhr <bniebuhr@efjohnson.com>
Date:   Mon Aug 16 15:05:51 2010 +0530

    spi: davinci: make chip-slect specific parameters really chip-select specific
    
    Some chip-select specific paramterers like wdelay, parity, usage of
    chip-select timers (and the actual timer values) are included in
    platform data forcing the same behaviour across all chip-selects.
    
    Create a new davinci_spi_config data structure which can be passed
    along using controller_data member of spi_device data structure
    on a per-device basis.
    
    Signed-off-by: Brian Niebuhr <bniebuhr@efjohnson.com>
    Tested-By: Michael Williamson <michael.williamson@criticallink.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 6a76dfa60ef7..a6d9b72190ff 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -413,10 +413,7 @@ static struct davinci_spi_platform_data dm355_spi0_pdata = {
 	.version 	= SPI_VERSION_1,
 	.num_chipselect = 2,
 	.clk_internal	= 1,
-	.intr_level	= 0,
 	.poll_mode	= 1,	/* 0 -> interrupt mode 1-> polling mode */
-	.c2tdelay	= 0,
-	.t2cdelay	= 0,
 };
 static struct platform_device dm355_spi0_device = {
 	.name = "spi_davinci",

commit 7978b8c385a86f0b5b9304e81a1dfb5dcaf21528
Author: Brian Niebuhr <bniebuhr@efjohnson.com>
Date:   Fri Aug 13 10:11:03 2010 +0530

    spi: davinci: enable both activation and deactivation of chip-selects
    
    Let davinci_spi_chipselect() perform both activation and
    deactivation of chip selects. This lets spi_bitbang fully
    control chip select activation, as intended by the SPI API.
    
    With this change, the chip select activation code need not
    be duplicated in davinci_spi_bufs_{pio|dma}().
    
    Also, keeping chip select active control is removed as a
    platform data and simply controlled using information from
    spi_bitbang on whether chip slect should be activated or
    de-activated.
    
    Signed-off-by: Brian Niebuhr <bniebuhr@efjohnson.com>
    Tested-By: Michael Williamson <michael.williamson@criticallink.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 9be261beae7d..6a76dfa60ef7 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -413,7 +413,6 @@ static struct davinci_spi_platform_data dm355_spi0_pdata = {
 	.version 	= SPI_VERSION_1,
 	.num_chipselect = 2,
 	.clk_internal	= 1,
-	.cs_hold	= 1,
 	.intr_level	= 0,
 	.poll_mode	= 1,	/* 0 -> interrupt mode 1-> polling mode */
 	.c2tdelay	= 0,

commit bedad0ca3fb2ba52c347b54a97b78d32e406dd96
Author: Chris Paulson-Ellis <chris@edesix.com>
Date:   Tue Nov 16 12:27:09 2010 +0000

    ASoC: davinci: fixes for multi-component
    
    Multi-component commit f0fba2ad broke a few things which this patch should
    fix. Tested on the DM355 EVM. I've been as careful as I can, but it would be
    good if those with access to other Davinci boards could test.
    
    --
    
    The multi-component commit put the initialisation of
    snd_soc_dai.[capture|playback]_dma_data into snd_soc_dai_ops.hw_params of the
    McBSP, McASP & VCIF drivers (davinci-i2s.c, davinci-mcasp.c & davinci-vcif.c).
    The initialisation had to be moved from the probe function in these drivers
    because davinci_*_dai changed from snd_soc_dai to snd_soc_dai_driver.
    
    Unfortunately, the DMA params pointer is needed by davinci_pcm_open (in
    davinci-pcm.c) before hw_params is called. I have moved the initialisation to
    a new snd_soc_dai_ops.startup function in each of these drivers. This fix
    indicates that all platforms that use davinci-pcm must have been broken and
    need to test with this fix.
    
    --
    
    The multi-component commit also changed the McBSP driver name from
    "davinci-asp" to "davinci-i2s" in davinci-i2s.c without updating the board
    level references to the driver name. This change is understandable, as there
    is a similarly named "davinci-mcasp" driver in davinci-mcasp.c.
    
    There is probably no 'correct' name for this driver. The DM6446 datasheet
    calls it the "ASP" and describes it as a "specialised McBSP". The DM355
    datasheet calls it the "ASP" and describes it as a "specialised ASP". The
    DM365 datasheet calls it the "McBSP". Rather than fix this problem by
    reverting to "davinci-asp", I've elected to avoid future confusion with the
    "davinci-mcasp" driver by changing it to "davinci-mcbsp", which is also
    consistent with the names of the functions in the driver. There are other
    fixes required, so it was never going to be as simple as a revert anyway.
    
    --
    
    The DM365 only has one McBSP port (of the McBSP platforms, only the DM355 has
    2 ports), so I've changed the the id of the platform_device from 0 to -1.
    
    --
    
    In davinci-evm.c, the DM6446 EVM can no longer share a snd_soc_dai_link
    structure with the DM355 EVM as they use different cpu DAI names (the DM355
    has 2 ports and the EVM uses the second port, but the DM6446 only has 1 port).
    This also means that the 2 boards need different snd_soc_card structures.
    
    --
    
    The codec_name entries in davinci-evm.c didn't match the i2c ids in the board
    files. I have only checked and fixed the details of the names used for the
    McBSP based platforms. Someone with a McASP based platform (eg DA8xx) should
    check the others.
    
    Signed-off-by: Chris Paulson-Ellis <chris@edesix.com>
    Acked-by: Liam Girdwood <lrg@slimlogic.co.uk>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 9be261beae7d..2652af124acd 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -359,8 +359,8 @@ static struct clk_lookup dm355_clks[] = {
 	CLK(NULL, "uart1", &uart1_clk),
 	CLK(NULL, "uart2", &uart2_clk),
 	CLK("i2c_davinci.1", NULL, &i2c_clk),
-	CLK("davinci-asp.0", NULL, &asp0_clk),
-	CLK("davinci-asp.1", NULL, &asp1_clk),
+	CLK("davinci-mcbsp.0", NULL, &asp0_clk),
+	CLK("davinci-mcbsp.1", NULL, &asp1_clk),
 	CLK("davinci_mmc.0", NULL, &mmcsd0_clk),
 	CLK("davinci_mmc.1", NULL, &mmcsd1_clk),
 	CLK("spi_davinci.0", NULL, &spi0_clk),
@@ -664,7 +664,7 @@ static struct resource dm355_asp1_resources[] = {
 };
 
 static struct platform_device dm355_asp1_device = {
-	.name		= "davinci-asp",
+	.name		= "davinci-mcbsp",
 	.id		= 1,
 	.num_resources	= ARRAY_SIZE(dm355_asp1_resources),
 	.resource	= dm355_asp1_resources,

commit 2de5c00ac06c8983ab33ad51a8341584f1cf42c3
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Fri Sep 24 07:21:05 2010 +0100

    ARM: 6409/1: davinci: map sram using MT_MEMORY_NONCACHED instead of MT_DEVICE
    
    On Davinci SRAM is mapped as MT_DEVICE becasue of the section
    mapping pre-requisite instead of intended MT_MEMORY_NONCACHED
    
    Since the section mapping limitation gets fixed with first
    patch in this series, the MT_MEMORY_NONCACHED can be used now.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 3d996b659ff4..9be261beae7d 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -769,8 +769,7 @@ static struct map_desc dm355_io_desc[] = {
 		.virtual	= SRAM_VIRT,
 		.pfn		= __phys_to_pfn(0x00010000),
 		.length		= SZ_32K,
-		/* MT_MEMORY_NONCACHED requires supersection alignment */
-		.type		= MT_DEVICE,
+		.type		= MT_MEMORY_NONCACHED,
 	},
 };
 

commit bc3ac9f31642fb4697b313c2eb575c5286f35c2a
Author: Sekhar Nori <nsekhar@ti.com>
Date:   Tue Jun 29 11:35:12 2010 +0530

    davinci: edma: provide ability to detect insufficient CC info data
    
    This patch modifies the EDMA driver to expect the channel
    controller (CC) infomation passed on by the platform as a fixed
    size (EDMA_MAX_CC) array of pointers to structures.
    
    Doing so helps catch errors of the sort where the resource
    structure has information for more channel controllers than
    the number channel controller info structures defined.
    
    Such insufficient platform data would lead to illegal memory
    accesses.
    
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 383478116ef5..3d996b659ff4 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -591,16 +591,18 @@ queue_priority_mapping[][2] = {
 	{-1, -1},
 };
 
-static struct edma_soc_info dm355_edma_info[] = {
-	{
-		.n_channel		= 64,
-		.n_region		= 4,
-		.n_slot			= 128,
-		.n_tc			= 2,
-		.n_cc			= 1,
-		.queue_tc_mapping	= queue_tc_mapping,
-		.queue_priority_mapping	= queue_priority_mapping,
-	},
+static struct edma_soc_info edma_cc0_info = {
+	.n_channel		= 64,
+	.n_region		= 4,
+	.n_slot			= 128,
+	.n_tc			= 2,
+	.n_cc			= 1,
+	.queue_tc_mapping	= queue_tc_mapping,
+	.queue_priority_mapping	= queue_priority_mapping,
+};
+
+static struct edma_soc_info *dm355_edma_info[EDMA_MAX_CC] = {
+       &edma_cc0_info,
 };
 
 static struct resource edma_resources[] = {

commit 779b0d53ca41873d59225eb776c5d4493a0abd0f
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Fri May 7 17:06:38 2010 -0400

    Davinci: pinmux - use ioremap()
    
    This patch modifies the pinmux implementation so as to ioremap() the pinmux
    register area on first use.
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 5ab39f6360f9..383478116ef5 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -844,7 +844,7 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.cpu_clks		= dm355_clks,
 	.psc_bases		= dm355_psc_bases,
 	.psc_bases_num		= ARRAY_SIZE(dm355_psc_bases),
-	.pinmux_base		= IO_ADDRESS(DAVINCI_SYSTEM_MODULE_BASE),
+	.pinmux_base		= DAVINCI_SYSTEM_MODULE_BASE,
 	.pinmux_pins		= dm355_pins,
 	.pinmux_pins_num	= ARRAY_SIZE(dm355_pins),
 	.intc_base		= DAVINCI_ARM_INTC_BASE,

commit bd808947040ba53b2b0e52dde598a9414fb27bba
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Fri May 7 17:06:37 2010 -0400

    Davinci: aintc/cpintc - use ioremap()
    
    This patch implements the following:
    
     - interrupt initialization uses ioremap() instead of passing a virtual address
       via davinci_soc_info.
    
     - machine definitions directly point to cp_intc_init() or davinci_irq_init()
    
     - davinci_intc_type and davinci_intc_base now get initialized in controller
       specific init functions instead of davinci_common_init()
    
     - minor fix in davinci_irq_init() to use intc_irq_num instead of
       DAVINCI_N_AINTC_IRQ
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 70a18275c5da..5ab39f6360f9 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -847,7 +847,7 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.pinmux_base		= IO_ADDRESS(DAVINCI_SYSTEM_MODULE_BASE),
 	.pinmux_pins		= dm355_pins,
 	.pinmux_pins_num	= ARRAY_SIZE(dm355_pins),
-	.intc_base		= IO_ADDRESS(DAVINCI_ARM_INTC_BASE),
+	.intc_base		= DAVINCI_ARM_INTC_BASE,
 	.intc_type		= DAVINCI_INTC_TYPE_AINTC,
 	.intc_irq_prios		= dm355_default_priorities,
 	.intc_irq_num		= DAVINCI_N_AINTC_IRQ,

commit e4c822c7e98cdda78b10a696b030fc20b22dcab4
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Fri May 7 17:06:36 2010 -0400

    Davinci: psc - use ioremap()
    
    This patch modifies the psc and clock control code to use ioremap()ed
    registers.
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 228b6d1460e5..70a18275c5da 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -783,9 +783,7 @@ static struct davinci_id dm355_ids[] = {
 	},
 };
 
-static void __iomem *dm355_psc_bases[] = {
-	IO_ADDRESS(DAVINCI_PWR_SLEEP_CNTRL_BASE),
-};
+static u32 dm355_psc_bases[] = { DAVINCI_PWR_SLEEP_CNTRL_BASE };
 
 /*
  * T0_BOT: Timer 0, bottom:  clockevent source for hrtimers

commit 3347db8392486a1b52aab980cc445cf505c36d45
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Fri May 7 17:06:34 2010 -0400

    Davinci: jtag_id - use ioremap()
    
    This patch replaces the jtag id base info in davinci_soc_info with a physical
    address which is then ioremap()ed within common code.
    
    This patch (in combination with a similar change for PSC) will allow us to
    eliminate the SYSCFG nastiness in DA8xx code.
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 277041dcd9a1..228b6d1460e5 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -840,7 +840,7 @@ static struct platform_device dm355_serial_device = {
 static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.io_desc		= dm355_io_desc,
 	.io_desc_num		= ARRAY_SIZE(dm355_io_desc),
-	.jtag_id_base		= IO_ADDRESS(0x01c40028),
+	.jtag_id_reg		= 0x01c40028,
 	.ids			= dm355_ids,
 	.ids_num		= ARRAY_SIZE(dm355_ids),
 	.cpu_clks		= dm355_clks,

commit b8d44293952e4b32b8595d924a377351f3cd1565
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Fri May 7 17:06:32 2010 -0400

    Davinci: gpio - use ioremap()
    
    This patch modifies the gpio_base definition in davinci_soc_info to be a
    physical address, which is then ioremap()ed by the gpio initialization
    function.
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 0c62a68a90a3..277041dcd9a1 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -855,7 +855,7 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.intc_irq_num		= DAVINCI_N_AINTC_IRQ,
 	.timer_info		= &dm355_timer_info,
 	.gpio_type		= GPIO_TYPE_DAVINCI,
-	.gpio_base		= IO_ADDRESS(DAVINCI_GPIO_BASE),
+	.gpio_base		= DAVINCI_GPIO_BASE,
 	.gpio_num		= 104,
 	.gpio_irq		= IRQ_DM355_GPIOBNK0,
 	.serial_dev		= &dm355_serial_device,

commit c78a5bc2e77e8fc5be29cda5b28c9b9afd0f4b6d
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Sat May 1 18:38:28 2010 -0400

    Davinci: watchdog reset separation across socs
    
    The earlier watchdog reset mechanism had a couple of limitations.  First, it
    embedded a reference to "davinci_wdt_device" inside common code.  This
    forced all derived platforms (da8xx and tnetv107x) to define such a device.
    This also would have caused problems in including multiple socs in a single
    build due to symbol redefinition.
    
    With this patch, davinci_watchdog_reset() now takes the platform device as an
    argument.  The davinci_soc_info struct has been extended to include a reset
    function and a watchdog platform_device.  arch_reset() then uses these
    elements to reset the system in a SoC specific fashion.
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Tested-by: Sandeep Paulraj <s-paulraj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index f91e9a1ab921..0c62a68a90a3 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -861,6 +861,7 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.serial_dev		= &dm355_serial_device,
 	.sram_dma		= 0x00010000,
 	.sram_len		= SZ_32K,
+	.reset_device		= &davinci_wdt_device,
 };
 
 void __init dm355_init_asp1(u32 evt_enable, struct snd_platform_data *pdata)

commit 5b3a05ca911688c53680f2b020a1512b9da29c89
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Sat May 1 18:38:27 2010 -0400

    Davinci: eliminate pinmux offset verbosity
    
    Pinmux registers are sequential, and do not need to be enumerated out as they
    currently are.  This reduces code volume and keeps things simple.
    
    If some future SoC comes up with a discontiguous register map, PINMUX() can
    then be expanded with local token pasting.
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index f9a54ff2d249..f91e9a1ab921 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -450,11 +450,6 @@ void __init dm355_init_spi0(unsigned chipselect_mask,
 
 /*----------------------------------------------------------------------*/
 
-#define PINMUX0		0x00
-#define PINMUX1		0x04
-#define PINMUX2		0x08
-#define PINMUX3		0x0c
-#define PINMUX4		0x10
 #define INTMUX		0x18
 #define EVTMUX		0x1c
 

commit 686b634a07451fc4fe3b712fe211bfa861a53241
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Sat May 1 18:37:54 2010 -0400

    Davinci: gpio - controller type support
    
    This patch allows for gpio controllers that deviate from those found on
    traditional davinci socs.  davinci_soc_info has an added field to indicate the
    soc-specific gpio controller type.  The gpio initialization code then bails
    out if necessary.
    
    More elements (tnetv107x) to be added later into enum davinci_gpio_type.
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Tested-by: Sandeep Paulraj <s-paulraj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 5efce70ccdd0..f9a54ff2d249 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -859,6 +859,7 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.intc_irq_prios		= dm355_default_priorities,
 	.intc_irq_num		= DAVINCI_N_AINTC_IRQ,
 	.timer_info		= &dm355_timer_info,
+	.gpio_type		= GPIO_TYPE_DAVINCI,
 	.gpio_base		= IO_ADDRESS(DAVINCI_GPIO_BASE),
 	.gpio_num		= 104,
 	.gpio_irq		= IRQ_DM355_GPIOBNK0,

commit 28552c2eae472a0a52d1cdb02eb32766c7f690e1
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Thu Feb 25 15:36:38 2010 -0800

    davinci: misc cleanups from sparse
    
    - Convert data/functions to static
    - include headers for missing declarations
    - pointer cleanups:  struct foo *__iomem f --> struct foo __iomem *f;
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 3dc0a88712eb..5efce70ccdd0 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -798,7 +798,7 @@ static void __iomem *dm355_psc_bases[] = {
  * T1_BOT: Timer 1, bottom:  (used by DSP in TI DSPLink code)
  * T1_TOP: Timer 1, top   :  <unused>
  */
-struct davinci_timer_info dm355_timer_info = {
+static struct davinci_timer_info dm355_timer_info = {
 	.timers		= davinci_timer_instance,
 	.clockevent_id	= T0_BOT,
 	.clocksource_id	= T0_TOP,

commit 13dda80e48439b446d0bc9bab34b91484bc8f533
Merge: 379e3a820da1 5f19daa16ffc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 1 13:05:40 2010 -0800

    Merge branch 'davinci-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/khilman/linux-davinci
    
    * 'davinci-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/khilman/linux-davinci: (40 commits)
      DaVinci DM365: Adding support for SPI EEPROM
      DaVinci DM365: Adding DM365 SPI support
      DaVinci DM355: Modifications to DM355 SPI support
      DaVinci: SPI: Adding header file for SPI support.
      davinci: dm646x: CDCE clocks: davinci_clk converted to clk_lookup
      davinci: clkdev cleanup: remove clk_lookup wrapper, use clkdev_add_table()
      DaVinci: DM365: Voice codec support for the DM365 SoC
      davinci: clock: let clk->set_rate function sleep
      Add SDA and SCL pin numbers to i2c platform data
      davinci: da8xx/omap-l1xx: Add EDMA platform data for da850/omap-l138
      davinci: build list of unused EDMA events dynamically
      davinci: Fix edma_alloc_channel api for EDMA_CHANNEL_ANY case
      davinci: Keep count of channel controllers on a platform
      davinci: Correct return value of edma_alloc_channel api
      davinci: add CDCE949 support on DM6467 EVM
      davinci: add support for CDCE949 clock synthesizer
      davinci: da850/omap-l138 EVM: register for suspend support
      davinci: da850/omap-l138: add support for SoC suspend
      davinci: add power management support
      DaVinci: DM365: Changing default queue for DM365.
      ...

commit 15e865859a9e65a3f39e95bcb7ee72d0645b9a0e
Author: Sandeep Paulraj <s-paulraj@ti.com>
Date:   Mon Feb 1 09:51:15 2010 -0500

    DaVinci DM355: Modifications to DM355 SPI support
    
    This patch does the following
    
    1) Minor change to the SPI clocks making it
    similar to DM365.
    2) Changing the interrupt used by SPI0
    3) Adding EDMA resources that can be used by SPI0
    4) Adding platform specific data.
    
    Signed-off-by: Sandeep Paulraj <s-paulraj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 2cdd8740aad9..36e7213779e8 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -29,6 +29,7 @@
 #include <mach/serial.h>
 #include <mach/common.h>
 #include <mach/asp.h>
+#include <mach/spi.h>
 
 #include "clock.h"
 #include "mux.h"
@@ -363,9 +364,9 @@ static struct clk_lookup dm355_clks[] = {
 	CLK("davinci-asp.1", NULL, &asp1_clk),
 	CLK("davinci_mmc.0", NULL, &mmcsd0_clk),
 	CLK("davinci_mmc.1", NULL, &mmcsd1_clk),
-	CLK(NULL, "spi0", &spi0_clk),
-	CLK(NULL, "spi1", &spi1_clk),
-	CLK(NULL, "spi2", &spi2_clk),
+	CLK("spi_davinci.0", NULL, &spi0_clk),
+	CLK("spi_davinci.1", NULL, &spi1_clk),
+	CLK("spi_davinci.2", NULL, &spi2_clk),
 	CLK(NULL, "gpio", &gpio_clk),
 	CLK(NULL, "aemif", &aemif_clk),
 	CLK(NULL, "pwm0", &pwm0_clk),
@@ -392,24 +393,40 @@ static struct resource dm355_spi0_resources[] = {
 		.flags = IORESOURCE_MEM,
 	},
 	{
-		.start = IRQ_DM355_SPINT0_1,
+		.start = IRQ_DM355_SPINT0_0,
 		.flags = IORESOURCE_IRQ,
 	},
-	/* Not yet used, so not included:
-	 * IORESOURCE_IRQ:
-	 *  - IRQ_DM355_SPINT0_0
-	 * IORESOURCE_DMA:
-	 *  - DAVINCI_DMA_SPI_SPIX
-	 *  - DAVINCI_DMA_SPI_SPIR
-	 */
+	{
+		.start = 17,
+		.flags = IORESOURCE_DMA,
+	},
+	{
+		.start = 16,
+		.flags = IORESOURCE_DMA,
+	},
+	{
+		.start = EVENTQ_1,
+		.flags = IORESOURCE_DMA,
+	},
 };
 
+static struct davinci_spi_platform_data dm355_spi0_pdata = {
+	.version 	= SPI_VERSION_1,
+	.num_chipselect = 2,
+	.clk_internal	= 1,
+	.cs_hold	= 1,
+	.intr_level	= 0,
+	.poll_mode	= 1,	/* 0 -> interrupt mode 1-> polling mode */
+	.c2tdelay	= 0,
+	.t2cdelay	= 0,
+};
 static struct platform_device dm355_spi0_device = {
 	.name = "spi_davinci",
 	.id = 0,
 	.dev = {
 		.dma_mask = &dm355_spi0_dma_mask,
 		.coherent_dma_mask = DMA_BIT_MASK(32),
+		.platform_data = &dm355_spi0_pdata,
 	},
 	.num_resources = ARRAY_SIZE(dm355_spi0_resources),
 	.resource = dm355_spi0_resources,

commit 77c8b5fb0ee6e367332167eaa26470d843596270
Author: Muralidharan Karicheri <m-karicheri2@ti.com>
Date:   Wed Jan 13 20:27:08 2010 -0300

    V4L/DVB: vpfe-capture: converting ccdc drivers to platform-drivers
    
    This adds platform code for ccdc driver on DM355 and DM6446.
    
    1) new ccdc platform devices added
    2) added clock aliases master and slave for CCDC clocks
    3) added dm355_ccdc_setup_pinmux() pin-mux setup hook in dm355 ccdc driver platform data
    
    Reviewed-by: Vaibhav Hiremath <hvaibhav@ti.com>
    Reviewed-by: Kevin Hilman <khilman@deeprootsystems.com>
    Reviewed-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Muralidharan Karicheri <m-karicheri2@ti.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index dedf4d4f3a27..d84e85414d20 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -125,7 +125,6 @@ static struct clk vpss_slave_clk = {
 	.lpsc = DAVINCI_LPSC_VPSSSLV,
 };
 
-
 static struct clk clkout1_clk = {
 	.name = "clkout1",
 	.parent = &pll1_aux_clk,
@@ -665,6 +664,17 @@ static struct platform_device dm355_asp1_device = {
 	.resource	= dm355_asp1_resources,
 };
 
+static void dm355_ccdc_setup_pinmux(void)
+{
+	davinci_cfg_reg(DM355_VIN_PCLK);
+	davinci_cfg_reg(DM355_VIN_CAM_WEN);
+	davinci_cfg_reg(DM355_VIN_CAM_VD);
+	davinci_cfg_reg(DM355_VIN_CAM_HD);
+	davinci_cfg_reg(DM355_VIN_YIN_EN);
+	davinci_cfg_reg(DM355_VIN_CINL_EN);
+	davinci_cfg_reg(DM355_VIN_CINH_EN);
+}
+
 static struct resource dm355_vpss_resources[] = {
 	{
 		/* VPSS BL Base address */
@@ -701,6 +711,10 @@ static struct resource vpfe_resources[] = {
 		.end            = IRQ_VDINT1,
 		.flags          = IORESOURCE_IRQ,
 	},
+};
+
+static u64 vpfe_capture_dma_mask = DMA_BIT_MASK(32);
+static struct resource dm355_ccdc_resource[] = {
 	/* CCDC Base address */
 	{
 		.flags          = IORESOURCE_MEM,
@@ -708,8 +722,18 @@ static struct resource vpfe_resources[] = {
 		.end            = 0x01c70600 + 0x1ff,
 	},
 };
+static struct platform_device dm355_ccdc_dev = {
+	.name           = "dm355_ccdc",
+	.id             = -1,
+	.num_resources  = ARRAY_SIZE(dm355_ccdc_resource),
+	.resource       = dm355_ccdc_resource,
+	.dev = {
+		.dma_mask               = &vpfe_capture_dma_mask,
+		.coherent_dma_mask      = DMA_BIT_MASK(32),
+		.platform_data		= dm355_ccdc_setup_pinmux,
+	},
+};
 
-static u64 vpfe_capture_dma_mask = DMA_BIT_MASK(32);
 static struct platform_device vpfe_capture_dev = {
 	.name		= CAPTURE_DRV_NAME,
 	.id		= -1,
@@ -857,20 +881,13 @@ static int __init dm355_init_devices(void)
 	if (!cpu_is_davinci_dm355())
 		return 0;
 
+	/* Add ccdc clock aliases */
+	clk_add_alias("master", dm355_ccdc_dev.name, "vpss_master", NULL);
+	clk_add_alias("slave", dm355_ccdc_dev.name, "vpss_master", NULL);
 	davinci_cfg_reg(DM355_INT_EDMA_CC);
 	platform_device_register(&dm355_edma_device);
 	platform_device_register(&dm355_vpss_device);
-	/*
-	 * setup Mux configuration for vpfe input and register
-	 * vpfe capture platform device
-	 */
-	davinci_cfg_reg(DM355_VIN_PCLK);
-	davinci_cfg_reg(DM355_VIN_CAM_WEN);
-	davinci_cfg_reg(DM355_VIN_CAM_VD);
-	davinci_cfg_reg(DM355_VIN_CAM_HD);
-	davinci_cfg_reg(DM355_VIN_YIN_EN);
-	davinci_cfg_reg(DM355_VIN_CINL_EN);
-	davinci_cfg_reg(DM355_VIN_CINH_EN);
+	platform_device_register(&dm355_ccdc_dev);
 	platform_device_register(&vpfe_capture_dev);
 
 	return 0;

commit 08aca087f263e8089420b2723fe0c1a0cbe5de0c
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Mon Jan 11 08:22:23 2010 -0800

    davinci: clkdev cleanup: remove clk_lookup wrapper, use clkdev_add_table()
    
    Remove unneeded 'struct davinci_clk' wrapper around 'struct clk_lookup'
    and use clkdev_add_table() to add the list of clocks in one go.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index b1185f82ffb3..2cdd8740aad9 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -335,7 +335,7 @@ static struct clk usb_clk = {
 	.lpsc = DAVINCI_LPSC_USB,
 };
 
-static struct davinci_clk dm355_clks[] = {
+static struct clk_lookup dm355_clks[] = {
 	CLK(NULL, "ref", &ref_clk),
 	CLK(NULL, "pll1", &pll1_clk),
 	CLK(NULL, "pll1_sysclk1", &pll1_sysclk1),

commit f900d552f95a009e4c4910aff7acbd45f952aa2e
Author: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
Date:   Wed Jan 6 17:29:49 2010 +0530

    davinci: build list of unused EDMA events dynamically
    
    Currently, the edma_noevent list is passed from platform data.
    But on some architectures, there will be many EDMA channels
    which will not be used at all. This patch scans all the
    platform devices and then builds a list of events which are
    not being used. The unused event list will be used to allocate
    EDMA channels in case of EDMA_CHANNEL_ANY usage instead of the
    edma_noevent being used earlier for this purpose.
    
    This patch is based on David Brownells's suggestion at
    http://article.gmane.org/gmane.linux.davinci/15176.
    
    Signed-off-by: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index dedf4d4f3a27..b1185f82ffb3 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -564,13 +564,6 @@ static u8 dm355_default_priorities[DAVINCI_N_AINTC_IRQ] = {
 
 /*----------------------------------------------------------------------*/
 
-static const s8 dma_chan_dm355_no_event[] = {
-	12, 13, 24, 56, 57,
-	58, 59, 60, 61, 62,
-	63,
-	-1
-};
-
 static const s8
 queue_tc_mapping[][2] = {
 	/* {event queue no, TC no} */
@@ -594,7 +587,6 @@ static struct edma_soc_info dm355_edma_info[] = {
 		.n_slot			= 128,
 		.n_tc			= 2,
 		.n_cc			= 1,
-		.noevent		= dma_chan_dm355_no_event,
 		.queue_tc_mapping	= queue_tc_mapping,
 		.queue_priority_mapping	= queue_priority_mapping,
 	},

commit 42d399e4189346b495fec8a9a267e8b7f744ee48
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Fri Oct 2 22:05:29 2009 +0400

    DaVinci: remove unneeded #include's
    
    There have accumulated quite a lot of them after the code reorganizations...
    
    In several cases I had to replace #include <linux/dma-mapping.h> which wasn't
    needed directly but happened to #include <linux/err.h> which was needed.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 059670018aff..dedf4d4f3a27 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -8,7 +8,6 @@
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
  */
-#include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/clk.h>
 #include <linux/serial_8250.h>
@@ -21,7 +20,6 @@
 #include <asm/mach/map.h>
 
 #include <mach/dm355.h>
-#include <mach/clock.h>
 #include <mach/cputype.h>
 #include <mach/edma.h>
 #include <mach/psc.h>

commit 51e68e27d310034332b67a6762914af9589b3db5
Author: Muralidharan Karicheri <m-karicheri2@ti.com>
Date:   Wed Sep 16 12:02:50 2009 -0400

    davinci: DM355 - platform changes for vpfe capture
    
    DM355 platform and board setup
    
    This has platform and board setup changes to support vpfe capture
    driver for DM355 EVMs.
    
    Tested video capture on DM355 using tvp514x
    
    Reviewed-by: Hans Verkuil <hverkuil@xs4all.nl>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@skynet.be>
    Reviewed-by: David Brownell <david-b@pacbell.net>
    Signed-off-by: Muralidharan Karicheri <m-karicheri2@ti.com>
    Signed-off-by: Denys Dmytriyenko <denis@denix.org>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 4f42169c029c..059670018aff 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -488,6 +488,14 @@ MUX_CFG(DM355,	VOUT_FIELD_G70,	1,   18,    3,	  0,	 false)
 MUX_CFG(DM355,	VOUT_HVSYNC,	1,   16,    1,	  0,	 false)
 MUX_CFG(DM355,	VOUT_COUTL_EN,	1,   0,     0xff, 0x55,  false)
 MUX_CFG(DM355,	VOUT_COUTH_EN,	1,   8,     0xff, 0x55,  false)
+
+MUX_CFG(DM355,	VIN_PCLK,	0,   14,    1,    1,	 false)
+MUX_CFG(DM355,	VIN_CAM_WEN,	0,   13,    1,    1,	 false)
+MUX_CFG(DM355,	VIN_CAM_VD,	0,   12,    1,    1,	 false)
+MUX_CFG(DM355,	VIN_CAM_HD,	0,   11,    1,    1,	 false)
+MUX_CFG(DM355,	VIN_YIN_EN,	0,   10,    1,    1,	 false)
+MUX_CFG(DM355,	VIN_CINL_EN,	0,   0,   0xff, 0x55,	 false)
+MUX_CFG(DM355,	VIN_CINH_EN,	0,   8,     3,    3,	 false)
 #endif
 };
 
@@ -659,6 +667,67 @@ static struct platform_device dm355_asp1_device = {
 	.resource	= dm355_asp1_resources,
 };
 
+static struct resource dm355_vpss_resources[] = {
+	{
+		/* VPSS BL Base address */
+		.name		= "vpss",
+		.start          = 0x01c70800,
+		.end            = 0x01c70800 + 0xff,
+		.flags          = IORESOURCE_MEM,
+	},
+	{
+		/* VPSS CLK Base address */
+		.name		= "vpss",
+		.start          = 0x01c70000,
+		.end            = 0x01c70000 + 0xf,
+		.flags          = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device dm355_vpss_device = {
+	.name			= "vpss",
+	.id			= -1,
+	.dev.platform_data	= "dm355_vpss",
+	.num_resources		= ARRAY_SIZE(dm355_vpss_resources),
+	.resource		= dm355_vpss_resources,
+};
+
+static struct resource vpfe_resources[] = {
+	{
+		.start          = IRQ_VDINT0,
+		.end            = IRQ_VDINT0,
+		.flags          = IORESOURCE_IRQ,
+	},
+	{
+		.start          = IRQ_VDINT1,
+		.end            = IRQ_VDINT1,
+		.flags          = IORESOURCE_IRQ,
+	},
+	/* CCDC Base address */
+	{
+		.flags          = IORESOURCE_MEM,
+		.start          = 0x01c70600,
+		.end            = 0x01c70600 + 0x1ff,
+	},
+};
+
+static u64 vpfe_capture_dma_mask = DMA_BIT_MASK(32);
+static struct platform_device vpfe_capture_dev = {
+	.name		= CAPTURE_DRV_NAME,
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(vpfe_resources),
+	.resource	= vpfe_resources,
+	.dev = {
+		.dma_mask		= &vpfe_capture_dma_mask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+};
+
+void dm355_set_vpfe_config(struct vpfe_config *cfg)
+{
+	vpfe_capture_dev.dev.platform_data = cfg;
+}
+
 /*----------------------------------------------------------------------*/
 
 static struct map_desc dm355_io_desc[] = {
@@ -792,6 +861,20 @@ static int __init dm355_init_devices(void)
 
 	davinci_cfg_reg(DM355_INT_EDMA_CC);
 	platform_device_register(&dm355_edma_device);
+	platform_device_register(&dm355_vpss_device);
+	/*
+	 * setup Mux configuration for vpfe input and register
+	 * vpfe capture platform device
+	 */
+	davinci_cfg_reg(DM355_VIN_PCLK);
+	davinci_cfg_reg(DM355_VIN_CAM_WEN);
+	davinci_cfg_reg(DM355_VIN_CAM_VD);
+	davinci_cfg_reg(DM355_VIN_CAM_HD);
+	davinci_cfg_reg(DM355_VIN_YIN_EN);
+	davinci_cfg_reg(DM355_VIN_CINL_EN);
+	davinci_cfg_reg(DM355_VIN_CINH_EN);
+	platform_device_register(&vpfe_capture_dev);
+
 	return 0;
 }
 postcore_initcall(dm355_init_devices);

commit 1aebb50e06b8c184dcf1dde4314cb782f42f9e21
Author: Sandeep Paulraj <s-paulraj@ti.com>
Date:   Fri Aug 21 12:38:11 2009 -0400

    DaVinci: DM355: Adding PINMUX entries for DM355 Display
    
    This patch adds PINMUX entries for DM355 Display.
    These will be used by the DM355 display driver.
    
    Signed-off-by: Sandeep Paulraj <s-paulraj@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 3abeb3eb9b24..4f42169c029c 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -482,6 +482,12 @@ INT_CFG(DM355,  INT_EDMA_TC1_ERR,     4,    1,    1,     false)
 EVT_CFG(DM355,  EVT8_ASP1_TX,	      0,    1,    0,     false)
 EVT_CFG(DM355,  EVT9_ASP1_RX,	      1,    1,    0,     false)
 EVT_CFG(DM355,  EVT26_MMC0_RX,	      2,    1,    0,     false)
+
+MUX_CFG(DM355,	VOUT_FIELD,	1,   18,    3,	  1,	 false)
+MUX_CFG(DM355,	VOUT_FIELD_G70,	1,   18,    3,	  0,	 false)
+MUX_CFG(DM355,	VOUT_HVSYNC,	1,   16,    1,	  0,	 false)
+MUX_CFG(DM355,	VOUT_COUTL_EN,	1,   0,     0xff, 0x55,  false)
+MUX_CFG(DM355,	VOUT_COUTH_EN,	1,   8,     0xff, 0x55,  false)
 #endif
 };
 

commit 61aa07328d8e70d95a1e2325288df52a1e92a694
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Wed Jul 15 08:47:48 2009 -0700

    davinci: audio clocks: use struct device instead of clock names
    
    There is no need to pass clock name strings in platform_data.
    Instead, setup clkdev nodes to have correct ASoC device names.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index b4d709a8612a..3abeb3eb9b24 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -361,8 +361,8 @@ static struct davinci_clk dm355_clks[] = {
 	CLK(NULL, "uart1", &uart1_clk),
 	CLK(NULL, "uart2", &uart2_clk),
 	CLK("i2c_davinci.1", NULL, &i2c_clk),
-	CLK(NULL, "asp0", &asp0_clk),
-	CLK(NULL, "asp1", &asp1_clk),
+	CLK("davinci-asp.0", NULL, &asp0_clk),
+	CLK("davinci-asp.1", NULL, &asp1_clk),
 	CLK("davinci_mmc.0", NULL, &mmcsd0_clk),
 	CLK("davinci_mmc.1", NULL, &mmcsd1_clk),
 	CLK(NULL, "spi0", &spi0_clk),
@@ -648,7 +648,7 @@ static struct resource dm355_asp1_resources[] = {
 
 static struct platform_device dm355_asp1_device = {
 	.name		= "davinci-asp",
-	.id		= -1,
+	.id		= 1,
 	.num_resources	= ARRAY_SIZE(dm355_asp1_resources),
 	.resource	= dm355_asp1_resources,
 };

commit 25acf553aeed86f93f2cf39227b59fc6eb3e8c78
Author: Chaithrika U S <chaithrika@ti.com>
Date:   Fri Jun 5 06:28:08 2009 -0400

    davinci: ASoC: Add the platform devices for ASP
    
    1) Registers the platform devices for ASP on dm355, dm644x and dm646x
       so that the machine driver can probe to get ASP related platform
       data.
    2) Move towards definition of the asp clocks using physical name(for
       dm355 and dm644x)
    3) Add platform data to board specific files.
    
    Signed-off-by: Naresh Medisetty <naresh@ti.com>
    Signed-off-by: Chaithrika U S <chaithrika@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 48f33e420517..b4d709a8612a 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -30,6 +30,7 @@
 #include <mach/time.h>
 #include <mach/serial.h>
 #include <mach/common.h>
+#include <mach/asp.h>
 
 #include "clock.h"
 #include "mux.h"
@@ -360,8 +361,8 @@ static struct davinci_clk dm355_clks[] = {
 	CLK(NULL, "uart1", &uart1_clk),
 	CLK(NULL, "uart2", &uart2_clk),
 	CLK("i2c_davinci.1", NULL, &i2c_clk),
-	CLK("soc-audio.0", NULL, &asp0_clk),
-	CLK("soc-audio.1", NULL, &asp1_clk),
+	CLK(NULL, "asp0", &asp0_clk),
+	CLK(NULL, "asp1", &asp1_clk),
 	CLK("davinci_mmc.0", NULL, &mmcsd0_clk),
 	CLK("davinci_mmc.1", NULL, &mmcsd1_clk),
 	CLK(NULL, "spi0", &spi0_clk),
@@ -627,6 +628,31 @@ static struct platform_device dm355_edma_device = {
 	.resource		= edma_resources,
 };
 
+static struct resource dm355_asp1_resources[] = {
+	{
+		.start	= DAVINCI_ASP1_BASE,
+		.end	= DAVINCI_ASP1_BASE + SZ_8K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= DAVINCI_DMA_ASP1_TX,
+		.end	= DAVINCI_DMA_ASP1_TX,
+		.flags	= IORESOURCE_DMA,
+	},
+	{
+		.start	= DAVINCI_DMA_ASP1_RX,
+		.end	= DAVINCI_DMA_ASP1_RX,
+		.flags	= IORESOURCE_DMA,
+	},
+};
+
+static struct platform_device dm355_asp1_device = {
+	.name		= "davinci-asp",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(dm355_asp1_resources),
+	.resource	= dm355_asp1_resources,
+};
+
 /*----------------------------------------------------------------------*/
 
 static struct map_desc dm355_io_desc[] = {
@@ -735,6 +761,19 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.sram_len		= SZ_32K,
 };
 
+void __init dm355_init_asp1(u32 evt_enable, struct snd_platform_data *pdata)
+{
+	/* we don't use ASP1 IRQs, or we'd need to mux them ... */
+	if (evt_enable & ASP1_TX_EVT_EN)
+		davinci_cfg_reg(DM355_EVT8_ASP1_TX);
+
+	if (evt_enable & ASP1_RX_EVT_EN)
+		davinci_cfg_reg(DM355_EVT9_ASP1_RX);
+
+	dm355_asp1_device.dev.platform_data = pdata;
+	platform_device_register(&dm355_asp1_device);
+}
+
 void __init dm355_init(void)
 {
 	davinci_common_init(&davinci_soc_info_dm355);

commit 5fcd294df26e6160f32ea551ef074630b4df728d
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Wed Jun 3 12:24:50 2009 -0700

    davinci: remove watchdog from soc_info
    
    watchdog info is not needed in soc_info, platform_device can
    be used directly in core code.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 373f0c4003a5..48f33e420517 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -727,7 +727,6 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.intc_irq_prios		= dm355_default_priorities,
 	.intc_irq_num		= DAVINCI_N_AINTC_IRQ,
 	.timer_info		= &dm355_timer_info,
-	.wdt_base		= IO_ADDRESS(DAVINCI_WDOG_BASE),
 	.gpio_base		= IO_ADDRESS(DAVINCI_GPIO_BASE),
 	.gpio_num		= 104,
 	.gpio_irq		= IRQ_DM355_GPIOBNK0,

commit 60902a2cb12c3c1682ee7a04ad7448ec16dc0c29
Author: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
Date:   Thu May 21 07:41:35 2009 -0400

    davinci: EDMA: multiple CCs, channel mapping and API changes
    
    - restructure to support multiple channel controllers by using
      additional struct resources for each CC
    
    - interface changes visible to EDMA clients
    
      Introduce macros to build IDs from controller and channel number,
      and to extract them. Modify the edma_alloc_slot function to take an
      extra argument for the controller.
    
      Also update ASoC drivers to use API.  ASoC changes
      Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    
    - Move queue related mappings to dm<soc>.c
    
      EDMA in DM355 and DM644x has two transfer controllers while DM646x
      has four transfer controllers. Moving the queue to tc mapping and
      queue priority mapping to dm<soc>.c will be helpful to probe these
      mappings from platform device so that the machine_is_* testing will
      be avoided.
    
    - add channel mapping logic
    
      Channel mapping logic is introduced in dm646x EDMA. This implies
      that there is no fixed association for a channel number to a
      parameter entry number. In other words, using the DMA channel
      mapping registers (DCHMAPn), a PaRAM entry can be mapped to any
      channel. While in the case of dm644x and dm355 there is a fixed
      mapping between the EDMA channel and Param entry number.
    
    Signed-off-by: Naresh Medisetty <naresh@ti.com>
    Signed-off-by: Sudhakar Rajashekhara <sudhakar.raj@ti.com>
    Reviewed-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index baaaf328de2e..373f0c4003a5 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -558,17 +558,38 @@ static const s8 dma_chan_dm355_no_event[] = {
 	-1
 };
 
-static struct edma_soc_info dm355_edma_info = {
-	.n_channel	= 64,
-	.n_region	= 4,
-	.n_slot		= 128,
-	.n_tc		= 2,
-	.noevent	= dma_chan_dm355_no_event,
+static const s8
+queue_tc_mapping[][2] = {
+	/* {event queue no, TC no} */
+	{0, 0},
+	{1, 1},
+	{-1, -1},
+};
+
+static const s8
+queue_priority_mapping[][2] = {
+	/* {event queue no, Priority} */
+	{0, 3},
+	{1, 7},
+	{-1, -1},
+};
+
+static struct edma_soc_info dm355_edma_info[] = {
+	{
+		.n_channel		= 64,
+		.n_region		= 4,
+		.n_slot			= 128,
+		.n_tc			= 2,
+		.n_cc			= 1,
+		.noevent		= dma_chan_dm355_no_event,
+		.queue_tc_mapping	= queue_tc_mapping,
+		.queue_priority_mapping	= queue_priority_mapping,
+	},
 };
 
 static struct resource edma_resources[] = {
 	{
-		.name	= "edma_cc",
+		.name	= "edma_cc0",
 		.start	= 0x01c00000,
 		.end	= 0x01c00000 + SZ_64K - 1,
 		.flags	= IORESOURCE_MEM,
@@ -586,10 +607,12 @@ static struct resource edma_resources[] = {
 		.flags	= IORESOURCE_MEM,
 	},
 	{
+		.name	= "edma0",
 		.start	= IRQ_CCINT0,
 		.flags	= IORESOURCE_IRQ,
 	},
 	{
+		.name	= "edma0_err",
 		.start	= IRQ_CCERRINT,
 		.flags	= IORESOURCE_IRQ,
 	},
@@ -598,8 +621,8 @@ static struct resource edma_resources[] = {
 
 static struct platform_device dm355_edma_device = {
 	.name			= "edma",
-	.id			= -1,
-	.dev.platform_data	= &dm355_edma_info,
+	.id			= 0,
+	.dev.platform_data	= dm355_edma_info,
 	.num_resources		= ARRAY_SIZE(edma_resources),
 	.resource		= edma_resources,
 };

commit 0d04eb47054f685b23033ed6ceadfb20db77c5b3
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Thu Apr 30 17:35:48 2009 -0700

    davinci: soc-specific SRAM setup
    
    Package on-chip SRAM.  It's always accessible from the ARM, so
    set up a standardized virtual address mapping into a 128 KiB
    area that's reserved for platform use.
    
    In some cases (dm6467) the physical addresses used for EDMA are
    not the same as the ones used by the ARM ... so record that info
    separately in the SOC data, for chips (unlike the OMAP-L137)
    where SRAM may be used with EDMA.
    
    Other blocks of SRAM, such as the ETB buffer or DSP L1/L2 RAM,
    may be unused/available on some system.  They are ignored here.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 893d5ba21d5f..baaaf328de2e 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -613,6 +613,13 @@ static struct map_desc dm355_io_desc[] = {
 		.length		= IO_SIZE,
 		.type		= MT_DEVICE
 	},
+	{
+		.virtual	= SRAM_VIRT,
+		.pfn		= __phys_to_pfn(0x00010000),
+		.length		= SZ_32K,
+		/* MT_MEMORY_NONCACHED requires supersection alignment */
+		.type		= MT_DEVICE,
+	},
 };
 
 /* Contents of JTAG ID register used to identify exact cpu type */
@@ -702,6 +709,8 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.gpio_num		= 104,
 	.gpio_irq		= IRQ_DM355_GPIOBNK0,
 	.serial_dev		= &dm355_serial_device,
+	.sram_dma		= 0x00010000,
+	.sram_len		= SZ_32K,
 };
 
 void __init dm355_init(void)

commit 96ed299fdb572fd694d361dc49285dddc0c87da4
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Thu Apr 30 11:20:24 2009 -0700

    davinci: cleanup: move dm355 UART2 define to dm355.c
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 78fc598b0bca..893d5ba21d5f 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -34,6 +34,8 @@
 #include "clock.h"
 #include "mux.h"
 
+#define DM355_UART2_BASE	(IO_PHYS + 0x206000)
+
 /*
  * Device specific clocks
  */

commit 5570078c0ec5ecc5df0bbd7d06f43549b7127ae7
Author: Mark A. Greer <mgreer@mvista.com>
Date:   Wed Apr 15 12:42:06 2009 -0700

    davinci: Move PINMUX defines to SoC files
    
    Different SoC have different numbers of pinmux registers and other
    resources that overlap with each other.  To clean up the code and
    eliminate defines that overlap with each other, move the PINMUX
    defines to the SoC specific files.
    
    Signed-off-by: Mark A. Greer <mgreer@mvista.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 4c3257ef5ddc..78fc598b0bca 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -433,6 +433,14 @@ void __init dm355_init_spi0(unsigned chipselect_mask,
 
 /*----------------------------------------------------------------------*/
 
+#define PINMUX0		0x00
+#define PINMUX1		0x04
+#define PINMUX2		0x08
+#define PINMUX3		0x0c
+#define PINMUX4		0x10
+#define INTMUX		0x18
+#define EVTMUX		0x1c
+
 /*
  * Device specific mux setup
  *

commit 65e866a9741126c678e6dcd5d4fa8c9eca18e945
Author: Mark A. Greer <mgreer@mvista.com>
Date:   Wed Mar 18 12:36:08 2009 -0500

    davinci: Move serial platform_device into SoC-specific files
    
    Currently, there is one set of platform_device and platform_data
    structures for all DaVinci SoCs.  The differences in the data
    between the various SoCs is handled by davinci_serial_init()
    by checking the SoC type.  However, as new SoCs appear, this
    routine will become more & more cluttered.
    
    To clean up the routine and make it easier to add support for new
    SoCs, move the platform_device and platform_data structures into the
    SoC-specific code and use the SoC infrastructure to provide access
    to the data.
    
    In the process, fix a bug where the wrong irq is used for uart2
    of the dm646x.
    
    Signed-off-by: Mark A. Greer <mgreer@mvista.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 757def752010..4c3257ef5ddc 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -11,6 +11,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/clk.h>
+#include <linux/serial_8250.h>
 #include <linux/platform_device.h>
 #include <linux/dma-mapping.h>
 #include <linux/gpio.h>
@@ -27,6 +28,7 @@
 #include <mach/mux.h>
 #include <mach/irqs.h>
 #include <mach/time.h>
+#include <mach/serial.h>
 #include <mach/common.h>
 
 #include "clock.h"
@@ -630,6 +632,44 @@ struct davinci_timer_info dm355_timer_info = {
 	.clocksource_id	= T0_TOP,
 };
 
+static struct plat_serial8250_port dm355_serial_platform_data[] = {
+	{
+		.mapbase	= DAVINCI_UART0_BASE,
+		.irq		= IRQ_UARTINT0,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
+				  UPF_IOREMAP,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+	},
+	{
+		.mapbase	= DAVINCI_UART1_BASE,
+		.irq		= IRQ_UARTINT1,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
+				  UPF_IOREMAP,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+	},
+	{
+		.mapbase	= DM355_UART2_BASE,
+		.irq		= IRQ_DM355_UARTINT2,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
+				  UPF_IOREMAP,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+	},
+	{
+		.flags		= 0
+	},
+};
+
+static struct platform_device dm355_serial_device = {
+	.name			= "serial8250",
+	.id			= PLAT8250_DEV_PLATFORM,
+	.dev			= {
+		.platform_data	= dm355_serial_platform_data,
+	},
+};
+
 static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.io_desc		= dm355_io_desc,
 	.io_desc_num		= ARRAY_SIZE(dm355_io_desc),
@@ -651,6 +691,7 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.gpio_base		= IO_ADDRESS(DAVINCI_GPIO_BASE),
 	.gpio_num		= 104,
 	.gpio_irq		= IRQ_DM355_GPIOBNK0,
+	.serial_dev		= &dm355_serial_device,
 };
 
 void __init dm355_init(void)

commit a994955cc091a8a51b7d7412174d9cf6de04d26b
Author: Mark A. Greer <mgreer@mvista.com>
Date:   Wed Apr 15 12:40:35 2009 -0700

    davinci: Make GPIO code more generic
    
    The current gpio code needs to know the number of
    gpio irqs there are and what the bank irq number is.
    To determine those values, it checks the SoC type.
    
    It also assumes that the base address and the number
    of irqs the interrupt controller uses is fixed.
    
    To clean up the SoC checks and make it support
    different base addresses and interrupt controllers,
    have the SoC-specific code set those values in
    the soc_info structure and have the gpio code
    reference them there.
    
    Signed-off-by: Mark A. Greer <mgreer@mvista.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 1b7c16cd2672..757def752010 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -13,6 +13,7 @@
 #include <linux/clk.h>
 #include <linux/platform_device.h>
 #include <linux/dma-mapping.h>
+#include <linux/gpio.h>
 
 #include <linux/spi/spi.h>
 
@@ -647,6 +648,9 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.intc_irq_num		= DAVINCI_N_AINTC_IRQ,
 	.timer_info		= &dm355_timer_info,
 	.wdt_base		= IO_ADDRESS(DAVINCI_WDOG_BASE),
+	.gpio_base		= IO_ADDRESS(DAVINCI_GPIO_BASE),
+	.gpio_num		= 104,
+	.gpio_irq		= IRQ_DM355_GPIOBNK0,
 };
 
 void __init dm355_init(void)

commit 951d6f6d703110790256abfce03ced117d2dcc6b
Author: Mark A. Greer <mgreer@mvista.com>
Date:   Wed Apr 15 12:40:21 2009 -0700

    davinci: Add watchdog base address flexibility
    
    The watchdog code currently hardcodes the base address
    of the timer its using.  To support new SoCs, make it
    support timers at any address.  Use the soc_info structure
    to do this.
    
    Signed-off-by: Mark A. Greer <mgreer@mvista.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 293a419a4a8e..1b7c16cd2672 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -646,6 +646,7 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.intc_irq_prios		= dm355_default_priorities,
 	.intc_irq_num		= DAVINCI_N_AINTC_IRQ,
 	.timer_info		= &dm355_timer_info,
+	.wdt_base		= IO_ADDRESS(DAVINCI_WDOG_BASE),
 };
 
 void __init dm355_init(void)

commit f64691b3ab795268072e76ddb89290b6277cdf33
Author: Mark A. Greer <mgreer@mvista.com>
Date:   Wed Apr 15 12:40:11 2009 -0700

    davinci: Add base address and timer flexibility
    
    The davinci timer code currently hardcodes the timer register
    base addresses, the timer irq numbers, and the timers to use
    for clock events and clocksource.  This won't work for some
    a new SoC so put those values into the soc_info structure
    and set them up in the SoC-specific files.
    
    Signed-off-by: Mark A. Greer <mgreer@mvista.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index e8c01ffe818a..293a419a4a8e 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -25,6 +25,7 @@
 #include <mach/psc.h>
 #include <mach/mux.h>
 #include <mach/irqs.h>
+#include <mach/time.h>
 #include <mach/common.h>
 
 #include "clock.h"
@@ -616,6 +617,18 @@ static void __iomem *dm355_psc_bases[] = {
 	IO_ADDRESS(DAVINCI_PWR_SLEEP_CNTRL_BASE),
 };
 
+/*
+ * T0_BOT: Timer 0, bottom:  clockevent source for hrtimers
+ * T0_TOP: Timer 0, top   :  clocksource for generic timekeeping
+ * T1_BOT: Timer 1, bottom:  (used by DSP in TI DSPLink code)
+ * T1_TOP: Timer 1, top   :  <unused>
+ */
+struct davinci_timer_info dm355_timer_info = {
+	.timers		= davinci_timer_instance,
+	.clockevent_id	= T0_BOT,
+	.clocksource_id	= T0_TOP,
+};
+
 static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.io_desc		= dm355_io_desc,
 	.io_desc_num		= ARRAY_SIZE(dm355_io_desc),
@@ -632,6 +645,7 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.intc_type		= DAVINCI_INTC_TYPE_AINTC,
 	.intc_irq_prios		= dm355_default_priorities,
 	.intc_irq_num		= DAVINCI_N_AINTC_IRQ,
+	.timer_info		= &dm355_timer_info,
 };
 
 void __init dm355_init(void)

commit 673dd36f0d0cf8893d6b46d524ad80e81076b885
Author: Mark A. Greer <mgreer@mvista.com>
Date:   Wed Apr 15 12:40:00 2009 -0700

    davinci: Move interrupt ctlr info to SoC infrastructure
    
    Use the SoC infrastructure to hold the interrupt controller
    information (i.e., base address, default priorities,
    interrupt controller type, and the number of IRQs).
    
    The interrupt controller base, although initially put
    in the soc_info structure's intc_base field, is eventually
    put in the global 'davinci_intc_base' so the low-level
    interrupt code can access it without a dereference.
    
    These changes enable the SoC default irq priorities to be
    put in the SoC-specific files, and the interrupt controller
    to be at any base address.
    
    Signed-off-by: Mark A. Greer <mgreer@mvista.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index f735ed9d2d10..e8c01ffe818a 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -470,6 +470,71 @@ EVT_CFG(DM355,  EVT26_MMC0_RX,	      2,    1,    0,     false)
 #endif
 };
 
+static u8 dm355_default_priorities[DAVINCI_N_AINTC_IRQ] = {
+	[IRQ_DM355_CCDC_VDINT0]		= 2,
+	[IRQ_DM355_CCDC_VDINT1]		= 6,
+	[IRQ_DM355_CCDC_VDINT2]		= 6,
+	[IRQ_DM355_IPIPE_HST]		= 6,
+	[IRQ_DM355_H3AINT]		= 6,
+	[IRQ_DM355_IPIPE_SDR]		= 6,
+	[IRQ_DM355_IPIPEIFINT]		= 6,
+	[IRQ_DM355_OSDINT]		= 7,
+	[IRQ_DM355_VENCINT]		= 6,
+	[IRQ_ASQINT]			= 6,
+	[IRQ_IMXINT]			= 6,
+	[IRQ_USBINT]			= 4,
+	[IRQ_DM355_RTOINT]		= 4,
+	[IRQ_DM355_UARTINT2]		= 7,
+	[IRQ_DM355_TINT6]		= 7,
+	[IRQ_CCINT0]			= 5,	/* dma */
+	[IRQ_CCERRINT]			= 5,	/* dma */
+	[IRQ_TCERRINT0]			= 5,	/* dma */
+	[IRQ_TCERRINT]			= 5,	/* dma */
+	[IRQ_DM355_SPINT2_1]		= 7,
+	[IRQ_DM355_TINT7]		= 4,
+	[IRQ_DM355_SDIOINT0]		= 7,
+	[IRQ_MBXINT]			= 7,
+	[IRQ_MBRINT]			= 7,
+	[IRQ_MMCINT]			= 7,
+	[IRQ_DM355_MMCINT1]		= 7,
+	[IRQ_DM355_PWMINT3]		= 7,
+	[IRQ_DDRINT]			= 7,
+	[IRQ_AEMIFINT]			= 7,
+	[IRQ_DM355_SDIOINT1]		= 4,
+	[IRQ_TINT0_TINT12]		= 2,	/* clockevent */
+	[IRQ_TINT0_TINT34]		= 2,	/* clocksource */
+	[IRQ_TINT1_TINT12]		= 7,	/* DSP timer */
+	[IRQ_TINT1_TINT34]		= 7,	/* system tick */
+	[IRQ_PWMINT0]			= 7,
+	[IRQ_PWMINT1]			= 7,
+	[IRQ_PWMINT2]			= 7,
+	[IRQ_I2C]			= 3,
+	[IRQ_UARTINT0]			= 3,
+	[IRQ_UARTINT1]			= 3,
+	[IRQ_DM355_SPINT0_0]		= 3,
+	[IRQ_DM355_SPINT0_1]		= 3,
+	[IRQ_DM355_GPIO0]		= 3,
+	[IRQ_DM355_GPIO1]		= 7,
+	[IRQ_DM355_GPIO2]		= 4,
+	[IRQ_DM355_GPIO3]		= 4,
+	[IRQ_DM355_GPIO4]		= 7,
+	[IRQ_DM355_GPIO5]		= 7,
+	[IRQ_DM355_GPIO6]		= 7,
+	[IRQ_DM355_GPIO7]		= 7,
+	[IRQ_DM355_GPIO8]		= 7,
+	[IRQ_DM355_GPIO9]		= 7,
+	[IRQ_DM355_GPIOBNK0]		= 7,
+	[IRQ_DM355_GPIOBNK1]		= 7,
+	[IRQ_DM355_GPIOBNK2]		= 7,
+	[IRQ_DM355_GPIOBNK3]		= 7,
+	[IRQ_DM355_GPIOBNK4]		= 7,
+	[IRQ_DM355_GPIOBNK5]		= 7,
+	[IRQ_DM355_GPIOBNK6]		= 7,
+	[IRQ_COMMTX]			= 7,
+	[IRQ_COMMRX]			= 7,
+	[IRQ_EMUINT]			= 7,
+};
+
 /*----------------------------------------------------------------------*/
 
 static const s8 dma_chan_dm355_no_event[] = {
@@ -563,6 +628,10 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.pinmux_base		= IO_ADDRESS(DAVINCI_SYSTEM_MODULE_BASE),
 	.pinmux_pins		= dm355_pins,
 	.pinmux_pins_num	= ARRAY_SIZE(dm355_pins),
+	.intc_base		= IO_ADDRESS(DAVINCI_ARM_INTC_BASE),
+	.intc_type		= DAVINCI_INTC_TYPE_AINTC,
+	.intc_irq_prios		= dm355_default_priorities,
+	.intc_irq_num		= DAVINCI_N_AINTC_IRQ,
 };
 
 void __init dm355_init(void)

commit 0e585952ac6a06b3c77d6b8eadb9c359766a700d
Author: Mark A. Greer <mgreer@mvista.com>
Date:   Wed Apr 15 12:39:48 2009 -0700

    davinci: Move pinmux setup info to SoC infrastructure
    
    The pinmux register base and setup can be different for different
    SoCs so move the pinmux reg base, pinmux table (and its size) to
    the SoC infrastructure.
    
    Signed-off-by: Mark A. Greer <mgreer@mvista.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 37f20a7214be..f735ed9d2d10 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -436,6 +436,7 @@ void __init dm355_init_spi0(unsigned chipselect_mask,
  *				reg  offset mask  mode
  */
 static const struct mux_config dm355_pins[] = {
+#ifdef CONFIG_DAVINCI_MUX
 MUX_CFG(DM355,	MMCSD0,		4,   2,     1,	  0,	 false)
 
 MUX_CFG(DM355,	SD1_CLK,	3,   6,     1,	  1,	 false)
@@ -466,6 +467,7 @@ INT_CFG(DM355,  INT_EDMA_TC1_ERR,     4,    1,    1,     false)
 EVT_CFG(DM355,  EVT8_ASP1_TX,	      0,    1,    0,     false)
 EVT_CFG(DM355,  EVT9_ASP1_RX,	      1,    1,    0,     false)
 EVT_CFG(DM355,  EVT26_MMC0_RX,	      2,    1,    0,     false)
+#endif
 };
 
 /*----------------------------------------------------------------------*/
@@ -558,12 +560,14 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.cpu_clks		= dm355_clks,
 	.psc_bases		= dm355_psc_bases,
 	.psc_bases_num		= ARRAY_SIZE(dm355_psc_bases),
+	.pinmux_base		= IO_ADDRESS(DAVINCI_SYSTEM_MODULE_BASE),
+	.pinmux_pins		= dm355_pins,
+	.pinmux_pins_num	= ARRAY_SIZE(dm355_pins),
 };
 
 void __init dm355_init(void)
 {
 	davinci_common_init(&davinci_soc_info_dm355);
-	davinci_mux_register(dm355_pins, ARRAY_SIZE(dm355_pins));;
 }
 
 static int __init dm355_init_devices(void)

commit d81d188cafecbc9e01df51527ac4c84a5b19e033
Author: Mark A. Greer <mgreer@mvista.com>
Date:   Wed Apr 15 12:39:33 2009 -0700

    davinci: Add support for multiple PSCs
    
    The current code to support the DaVinci Power and Sleep Controller (PSC)
    assumes that there is only one controller.  This assumption is no longer
    valid so expand the support to allow greater than one PSC.
    
    To accomplish this, put the base addresses for the PSCs in the SoC
    infrastructure so it can be referenced by the PSC code.  This also
    requires adding an extra parameter to davinci_psc_config() to specify
    the PSC that is to be enabled/disabled.
    
    Signed-off-by: Mark A. Greer <mgreer@mvista.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index e93840a814ed..37f20a7214be 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -545,6 +545,10 @@ static struct davinci_id dm355_ids[] = {
 	},
 };
 
+static void __iomem *dm355_psc_bases[] = {
+	IO_ADDRESS(DAVINCI_PWR_SLEEP_CNTRL_BASE),
+};
+
 static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.io_desc		= dm355_io_desc,
 	.io_desc_num		= ARRAY_SIZE(dm355_io_desc),
@@ -552,6 +556,8 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.ids			= dm355_ids,
 	.ids_num		= ARRAY_SIZE(dm355_ids),
 	.cpu_clks		= dm355_clks,
+	.psc_bases		= dm355_psc_bases,
+	.psc_bases_num		= ARRAY_SIZE(dm355_psc_bases),
 };
 
 void __init dm355_init(void)

commit 66e0c3991c5a1735dd8add77ab8aff5005f57681
Author: Mark A. Greer <mgreer@mvista.com>
Date:   Wed Apr 15 12:39:23 2009 -0700

    davinci: Add clock init call to common init routine
    
    All of the davinci SoCs need to call davinci_clk_init() so
    put the call in the common init routine.
    
    Signed-off-by: Mark A. Greer <mgreer@mvista.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 0f724c060084..e93840a814ed 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -551,12 +551,12 @@ static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.jtag_id_base		= IO_ADDRESS(0x01c40028),
 	.ids			= dm355_ids,
 	.ids_num		= ARRAY_SIZE(dm355_ids),
+	.cpu_clks		= dm355_clks,
 };
 
 void __init dm355_init(void)
 {
 	davinci_common_init(&davinci_soc_info_dm355);
-	davinci_clk_init(dm355_clks);
 	davinci_mux_register(dm355_pins, ARRAY_SIZE(dm355_pins));;
 }
 

commit b9ab12797e74d93a3656ea0bf5591f8b3e094fd5
Author: Mark A. Greer <mgreer@mvista.com>
Date:   Wed Apr 15 12:39:09 2009 -0700

    davinci: Support JTAG ID register at any address
    
    The Davinci cpu_is_davinci_*() macros use the SoC part number
    and variant retrieved from the JTAG ID register to determine the
    type of cpu that the kernel is running on.  Currently, the code to
    read the JTAG ID register assumes that the register is always at
    the same base address.  This isn't true on some newer SoCs.
    
    To solve this, have the SoC-specific code set the JTAG ID register
    base address in soc_info structure and add a 'cpu_id' member to it.
    'cpu_id' will be used by the cpu_is_davinci_*() macros to match
    the cpu id.  Also move the info used to identify the cpu type into
    the SoC-specific code to keep all SoC-specific code together.
    
    The common code will read the JTAG ID register, search through
    an array of davinci_id structures to identify the cpu type.
    Once identified, it will set the 'cpu_id' member of the soc_info
    structure to the proper value and the cpu_is_davinci_*() macros
    will now work.
    
    Signed-off-by: Mark A. Greer <mgreer@mvista.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index 6d1abfdcfb72..0f724c060084 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -534,9 +534,23 @@ static struct map_desc dm355_io_desc[] = {
 	},
 };
 
+/* Contents of JTAG ID register used to identify exact cpu type */
+static struct davinci_id dm355_ids[] = {
+	{
+		.variant	= 0x0,
+		.part_no	= 0xb73b,
+		.manufacturer	= 0x00f,
+		.cpu_id		= DAVINCI_CPU_ID_DM355,
+		.name		= "dm355",
+	},
+};
+
 static struct davinci_soc_info davinci_soc_info_dm355 = {
 	.io_desc		= dm355_io_desc,
 	.io_desc_num		= ARRAY_SIZE(dm355_io_desc),
+	.jtag_id_base		= IO_ADDRESS(0x01c40028),
+	.ids			= dm355_ids,
+	.ids_num		= ARRAY_SIZE(dm355_ids),
 };
 
 void __init dm355_init(void)

commit 79c3c0b729647a6246c120408f36e6804dab244e
Author: Mark A. Greer <mgreer@mvista.com>
Date:   Wed Apr 15 12:38:58 2009 -0700

    davinci: Encapsulate SoC-specific data in a structure
    
    Create a structure to encapsulate SoC-specific information.
    This will assist in generalizing code so it can be used by
    different SoCs that have similar hardware but with minor
    differences such as having a different base address.
    
    The idea is that the code for each SoC fills out a structure
    with the correct information.  The board-specific code then
    calls the SoC init routine which in turn will call a common
    init routine that makes a copy of the structure, maps in I/O
    regions, etc.
    
    After initialization, code can get a pointer to the structure
    by calling davinci_get_soc_info().  Eventually, the common
    init routine will make a copy of all of the data pointed to
    by the structure so the original data can be made __init_data.
    That way the data for SoC's that aren't being used won't consume
    memory for the entire life of the kernel.
    
    The structure will be extended in subsequent patches but
    initially, it holds the map_desc structure for any I/O
    regions the SoC/board wants statically mapped.
    
    Signed-off-by: Mark A. Greer <mgreer@mvista.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index c02115f1eb9b..6d1abfdcfb72 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -16,6 +16,8 @@
 
 #include <linux/spi/spi.h>
 
+#include <asm/mach/map.h>
+
 #include <mach/dm355.h>
 #include <mach/clock.h>
 #include <mach/cputype.h>
@@ -23,6 +25,7 @@
 #include <mach/psc.h>
 #include <mach/mux.h>
 #include <mach/irqs.h>
+#include <mach/common.h>
 
 #include "clock.h"
 #include "mux.h"
@@ -522,8 +525,23 @@ static struct platform_device dm355_edma_device = {
 
 /*----------------------------------------------------------------------*/
 
+static struct map_desc dm355_io_desc[] = {
+	{
+		.virtual	= IO_VIRT,
+		.pfn		= __phys_to_pfn(IO_PHYS),
+		.length		= IO_SIZE,
+		.type		= MT_DEVICE
+	},
+};
+
+static struct davinci_soc_info davinci_soc_info_dm355 = {
+	.io_desc		= dm355_io_desc,
+	.io_desc_num		= ARRAY_SIZE(dm355_io_desc),
+};
+
 void __init dm355_init(void)
 {
+	davinci_common_init(&davinci_soc_info_dm355);
 	davinci_clk_init(dm355_clks);
 	davinci_mux_register(dm355_pins, ARRAY_SIZE(dm355_pins));;
 }

commit 95a3477fe57e0669dcb531516f2930fe1cf27e6b
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Wed Apr 29 12:10:55 2009 -0700

    davinci: DM355: add base SoC and board support
    
    In addition, add board support for the DM355 Evaluation Module (EVM)
    and the DM355 Leopard board.
    
    Original DM355 EVM support done by Sandeep Paulraj, with significant
    updates and improvements by David Brownell.  DM355 Leopord support
    done by Koen Kooi.
    
    Signed-off-by: Sandeep Paulraj <s-paulraj@ti.com>
    Signed-off-by: Koen Kooi <koen@beagleboard.org>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
new file mode 100644
index 000000000000..c02115f1eb9b
--- /dev/null
+++ b/arch/arm/mach-davinci/dm355.c
@@ -0,0 +1,540 @@
+/*
+ * TI DaVinci DM355 chip specific setup
+ *
+ * Author: Kevin Hilman, Deep Root Systems, LLC
+ *
+ * 2007 (c) Deep Root Systems, LLC. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+
+#include <linux/spi/spi.h>
+
+#include <mach/dm355.h>
+#include <mach/clock.h>
+#include <mach/cputype.h>
+#include <mach/edma.h>
+#include <mach/psc.h>
+#include <mach/mux.h>
+#include <mach/irqs.h>
+
+#include "clock.h"
+#include "mux.h"
+
+/*
+ * Device specific clocks
+ */
+#define DM355_REF_FREQ		24000000	/* 24 or 36 MHz */
+
+static struct pll_data pll1_data = {
+	.num       = 1,
+	.phys_base = DAVINCI_PLL1_BASE,
+	.flags     = PLL_HAS_PREDIV | PLL_HAS_POSTDIV,
+};
+
+static struct pll_data pll2_data = {
+	.num       = 2,
+	.phys_base = DAVINCI_PLL2_BASE,
+	.flags     = PLL_HAS_PREDIV,
+};
+
+static struct clk ref_clk = {
+	.name = "ref_clk",
+	/* FIXME -- crystal rate is board-specific */
+	.rate = DM355_REF_FREQ,
+};
+
+static struct clk pll1_clk = {
+	.name = "pll1",
+	.parent = &ref_clk,
+	.flags = CLK_PLL,
+	.pll_data = &pll1_data,
+};
+
+static struct clk pll1_aux_clk = {
+	.name = "pll1_aux_clk",
+	.parent = &pll1_clk,
+	.flags = CLK_PLL | PRE_PLL,
+};
+
+static struct clk pll1_sysclk1 = {
+	.name = "pll1_sysclk1",
+	.parent = &pll1_clk,
+	.flags = CLK_PLL,
+	.div_reg = PLLDIV1,
+};
+
+static struct clk pll1_sysclk2 = {
+	.name = "pll1_sysclk2",
+	.parent = &pll1_clk,
+	.flags = CLK_PLL,
+	.div_reg = PLLDIV2,
+};
+
+static struct clk pll1_sysclk3 = {
+	.name = "pll1_sysclk3",
+	.parent = &pll1_clk,
+	.flags = CLK_PLL,
+	.div_reg = PLLDIV3,
+};
+
+static struct clk pll1_sysclk4 = {
+	.name = "pll1_sysclk4",
+	.parent = &pll1_clk,
+	.flags = CLK_PLL,
+	.div_reg = PLLDIV4,
+};
+
+static struct clk pll1_sysclkbp = {
+	.name = "pll1_sysclkbp",
+	.parent = &pll1_clk,
+	.flags = CLK_PLL | PRE_PLL,
+	.div_reg = BPDIV
+};
+
+static struct clk vpss_dac_clk = {
+	.name = "vpss_dac",
+	.parent = &pll1_sysclk3,
+	.lpsc = DM355_LPSC_VPSS_DAC,
+};
+
+static struct clk vpss_master_clk = {
+	.name = "vpss_master",
+	.parent = &pll1_sysclk4,
+	.lpsc = DAVINCI_LPSC_VPSSMSTR,
+	.flags = CLK_PSC,
+};
+
+static struct clk vpss_slave_clk = {
+	.name = "vpss_slave",
+	.parent = &pll1_sysclk4,
+	.lpsc = DAVINCI_LPSC_VPSSSLV,
+};
+
+
+static struct clk clkout1_clk = {
+	.name = "clkout1",
+	.parent = &pll1_aux_clk,
+	/* NOTE:  clkout1 can be externally gated by muxing GPIO-18 */
+};
+
+static struct clk clkout2_clk = {
+	.name = "clkout2",
+	.parent = &pll1_sysclkbp,
+};
+
+static struct clk pll2_clk = {
+	.name = "pll2",
+	.parent = &ref_clk,
+	.flags = CLK_PLL,
+	.pll_data = &pll2_data,
+};
+
+static struct clk pll2_sysclk1 = {
+	.name = "pll2_sysclk1",
+	.parent = &pll2_clk,
+	.flags = CLK_PLL,
+	.div_reg = PLLDIV1,
+};
+
+static struct clk pll2_sysclkbp = {
+	.name = "pll2_sysclkbp",
+	.parent = &pll2_clk,
+	.flags = CLK_PLL | PRE_PLL,
+	.div_reg = BPDIV
+};
+
+static struct clk clkout3_clk = {
+	.name = "clkout3",
+	.parent = &pll2_sysclkbp,
+	/* NOTE:  clkout3 can be externally gated by muxing GPIO-16 */
+};
+
+static struct clk arm_clk = {
+	.name = "arm_clk",
+	.parent = &pll1_sysclk1,
+	.lpsc = DAVINCI_LPSC_ARM,
+	.flags = ALWAYS_ENABLED,
+};
+
+/*
+ * NOT LISTED below, and not touched by Linux
+ *   - in SyncReset state by default
+ *	.lpsc = DAVINCI_LPSC_TPCC,
+ *	.lpsc = DAVINCI_LPSC_TPTC0,
+ *	.lpsc = DAVINCI_LPSC_TPTC1,
+ *	.lpsc = DAVINCI_LPSC_DDR_EMIF, .parent = &sysclk2_clk,
+ *	.lpsc = DAVINCI_LPSC_MEMSTICK,
+ *   - in Enabled state by default
+ *	.lpsc = DAVINCI_LPSC_SYSTEM_SUBSYS,
+ *	.lpsc = DAVINCI_LPSC_SCR2,	// "bus"
+ *	.lpsc = DAVINCI_LPSC_SCR3,	// "bus"
+ *	.lpsc = DAVINCI_LPSC_SCR4,	// "bus"
+ *	.lpsc = DAVINCI_LPSC_CROSSBAR,	// "emulation"
+ *	.lpsc = DAVINCI_LPSC_CFG27,	// "test"
+ *	.lpsc = DAVINCI_LPSC_CFG3,	// "test"
+ *	.lpsc = DAVINCI_LPSC_CFG5,	// "test"
+ */
+
+static struct clk mjcp_clk = {
+	.name = "mjcp",
+	.parent = &pll1_sysclk1,
+	.lpsc = DAVINCI_LPSC_IMCOP,
+};
+
+static struct clk uart0_clk = {
+	.name = "uart0",
+	.parent = &pll1_aux_clk,
+	.lpsc = DAVINCI_LPSC_UART0,
+};
+
+static struct clk uart1_clk = {
+	.name = "uart1",
+	.parent = &pll1_aux_clk,
+	.lpsc = DAVINCI_LPSC_UART1,
+};
+
+static struct clk uart2_clk = {
+	.name = "uart2",
+	.parent = &pll1_sysclk2,
+	.lpsc = DAVINCI_LPSC_UART2,
+};
+
+static struct clk i2c_clk = {
+	.name = "i2c",
+	.parent = &pll1_aux_clk,
+	.lpsc = DAVINCI_LPSC_I2C,
+};
+
+static struct clk asp0_clk = {
+	.name = "asp0",
+	.parent = &pll1_sysclk2,
+	.lpsc = DAVINCI_LPSC_McBSP,
+};
+
+static struct clk asp1_clk = {
+	.name = "asp1",
+	.parent = &pll1_sysclk2,
+	.lpsc = DM355_LPSC_McBSP1,
+};
+
+static struct clk mmcsd0_clk = {
+	.name = "mmcsd0",
+	.parent = &pll1_sysclk2,
+	.lpsc = DAVINCI_LPSC_MMC_SD,
+};
+
+static struct clk mmcsd1_clk = {
+	.name = "mmcsd1",
+	.parent = &pll1_sysclk2,
+	.lpsc = DM355_LPSC_MMC_SD1,
+};
+
+static struct clk spi0_clk = {
+	.name = "spi0",
+	.parent = &pll1_sysclk2,
+	.lpsc = DAVINCI_LPSC_SPI,
+};
+
+static struct clk spi1_clk = {
+	.name = "spi1",
+	.parent = &pll1_sysclk2,
+	.lpsc = DM355_LPSC_SPI1,
+};
+
+static struct clk spi2_clk = {
+	.name = "spi2",
+	.parent = &pll1_sysclk2,
+	.lpsc = DM355_LPSC_SPI2,
+};
+
+static struct clk gpio_clk = {
+	.name = "gpio",
+	.parent = &pll1_sysclk2,
+	.lpsc = DAVINCI_LPSC_GPIO,
+};
+
+static struct clk aemif_clk = {
+	.name = "aemif",
+	.parent = &pll1_sysclk2,
+	.lpsc = DAVINCI_LPSC_AEMIF,
+};
+
+static struct clk pwm0_clk = {
+	.name = "pwm0",
+	.parent = &pll1_aux_clk,
+	.lpsc = DAVINCI_LPSC_PWM0,
+};
+
+static struct clk pwm1_clk = {
+	.name = "pwm1",
+	.parent = &pll1_aux_clk,
+	.lpsc = DAVINCI_LPSC_PWM1,
+};
+
+static struct clk pwm2_clk = {
+	.name = "pwm2",
+	.parent = &pll1_aux_clk,
+	.lpsc = DAVINCI_LPSC_PWM2,
+};
+
+static struct clk pwm3_clk = {
+	.name = "pwm3",
+	.parent = &pll1_aux_clk,
+	.lpsc = DM355_LPSC_PWM3,
+};
+
+static struct clk timer0_clk = {
+	.name = "timer0",
+	.parent = &pll1_aux_clk,
+	.lpsc = DAVINCI_LPSC_TIMER0,
+};
+
+static struct clk timer1_clk = {
+	.name = "timer1",
+	.parent = &pll1_aux_clk,
+	.lpsc = DAVINCI_LPSC_TIMER1,
+};
+
+static struct clk timer2_clk = {
+	.name = "timer2",
+	.parent = &pll1_aux_clk,
+	.lpsc = DAVINCI_LPSC_TIMER2,
+	.usecount = 1,              /* REVISIT: why cant' this be disabled? */
+};
+
+static struct clk timer3_clk = {
+	.name = "timer3",
+	.parent = &pll1_aux_clk,
+	.lpsc = DM355_LPSC_TIMER3,
+};
+
+static struct clk rto_clk = {
+	.name = "rto",
+	.parent = &pll1_aux_clk,
+	.lpsc = DM355_LPSC_RTO,
+};
+
+static struct clk usb_clk = {
+	.name = "usb",
+	.parent = &pll1_sysclk2,
+	.lpsc = DAVINCI_LPSC_USB,
+};
+
+static struct davinci_clk dm355_clks[] = {
+	CLK(NULL, "ref", &ref_clk),
+	CLK(NULL, "pll1", &pll1_clk),
+	CLK(NULL, "pll1_sysclk1", &pll1_sysclk1),
+	CLK(NULL, "pll1_sysclk2", &pll1_sysclk2),
+	CLK(NULL, "pll1_sysclk3", &pll1_sysclk3),
+	CLK(NULL, "pll1_sysclk4", &pll1_sysclk4),
+	CLK(NULL, "pll1_aux", &pll1_aux_clk),
+	CLK(NULL, "pll1_sysclkbp", &pll1_sysclkbp),
+	CLK(NULL, "vpss_dac", &vpss_dac_clk),
+	CLK(NULL, "vpss_master", &vpss_master_clk),
+	CLK(NULL, "vpss_slave", &vpss_slave_clk),
+	CLK(NULL, "clkout1", &clkout1_clk),
+	CLK(NULL, "clkout2", &clkout2_clk),
+	CLK(NULL, "pll2", &pll2_clk),
+	CLK(NULL, "pll2_sysclk1", &pll2_sysclk1),
+	CLK(NULL, "pll2_sysclkbp", &pll2_sysclkbp),
+	CLK(NULL, "clkout3", &clkout3_clk),
+	CLK(NULL, "arm", &arm_clk),
+	CLK(NULL, "mjcp", &mjcp_clk),
+	CLK(NULL, "uart0", &uart0_clk),
+	CLK(NULL, "uart1", &uart1_clk),
+	CLK(NULL, "uart2", &uart2_clk),
+	CLK("i2c_davinci.1", NULL, &i2c_clk),
+	CLK("soc-audio.0", NULL, &asp0_clk),
+	CLK("soc-audio.1", NULL, &asp1_clk),
+	CLK("davinci_mmc.0", NULL, &mmcsd0_clk),
+	CLK("davinci_mmc.1", NULL, &mmcsd1_clk),
+	CLK(NULL, "spi0", &spi0_clk),
+	CLK(NULL, "spi1", &spi1_clk),
+	CLK(NULL, "spi2", &spi2_clk),
+	CLK(NULL, "gpio", &gpio_clk),
+	CLK(NULL, "aemif", &aemif_clk),
+	CLK(NULL, "pwm0", &pwm0_clk),
+	CLK(NULL, "pwm1", &pwm1_clk),
+	CLK(NULL, "pwm2", &pwm2_clk),
+	CLK(NULL, "pwm3", &pwm3_clk),
+	CLK(NULL, "timer0", &timer0_clk),
+	CLK(NULL, "timer1", &timer1_clk),
+	CLK("watchdog", NULL, &timer2_clk),
+	CLK(NULL, "timer3", &timer3_clk),
+	CLK(NULL, "rto", &rto_clk),
+	CLK(NULL, "usb", &usb_clk),
+	CLK(NULL, NULL, NULL),
+};
+
+/*----------------------------------------------------------------------*/
+
+static u64 dm355_spi0_dma_mask = DMA_BIT_MASK(32);
+
+static struct resource dm355_spi0_resources[] = {
+	{
+		.start = 0x01c66000,
+		.end   = 0x01c667ff,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = IRQ_DM355_SPINT0_1,
+		.flags = IORESOURCE_IRQ,
+	},
+	/* Not yet used, so not included:
+	 * IORESOURCE_IRQ:
+	 *  - IRQ_DM355_SPINT0_0
+	 * IORESOURCE_DMA:
+	 *  - DAVINCI_DMA_SPI_SPIX
+	 *  - DAVINCI_DMA_SPI_SPIR
+	 */
+};
+
+static struct platform_device dm355_spi0_device = {
+	.name = "spi_davinci",
+	.id = 0,
+	.dev = {
+		.dma_mask = &dm355_spi0_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.num_resources = ARRAY_SIZE(dm355_spi0_resources),
+	.resource = dm355_spi0_resources,
+};
+
+void __init dm355_init_spi0(unsigned chipselect_mask,
+		struct spi_board_info *info, unsigned len)
+{
+	/* for now, assume we need MISO */
+	davinci_cfg_reg(DM355_SPI0_SDI);
+
+	/* not all slaves will be wired up */
+	if (chipselect_mask & BIT(0))
+		davinci_cfg_reg(DM355_SPI0_SDENA0);
+	if (chipselect_mask & BIT(1))
+		davinci_cfg_reg(DM355_SPI0_SDENA1);
+
+	spi_register_board_info(info, len);
+
+	platform_device_register(&dm355_spi0_device);
+}
+
+/*----------------------------------------------------------------------*/
+
+/*
+ * Device specific mux setup
+ *
+ *	soc	description	mux  mode   mode  mux	 dbg
+ *				reg  offset mask  mode
+ */
+static const struct mux_config dm355_pins[] = {
+MUX_CFG(DM355,	MMCSD0,		4,   2,     1,	  0,	 false)
+
+MUX_CFG(DM355,	SD1_CLK,	3,   6,     1,	  1,	 false)
+MUX_CFG(DM355,	SD1_CMD,	3,   7,     1,	  1,	 false)
+MUX_CFG(DM355,	SD1_DATA3,	3,   8,     3,	  1,	 false)
+MUX_CFG(DM355,	SD1_DATA2,	3,   10,    3,	  1,	 false)
+MUX_CFG(DM355,	SD1_DATA1,	3,   12,    3,	  1,	 false)
+MUX_CFG(DM355,	SD1_DATA0,	3,   14,    3,	  1,	 false)
+
+MUX_CFG(DM355,	I2C_SDA,	3,   19,    1,	  1,	 false)
+MUX_CFG(DM355,	I2C_SCL,	3,   20,    1,	  1,	 false)
+
+MUX_CFG(DM355,	MCBSP0_BDX,	3,   0,     1,	  1,	 false)
+MUX_CFG(DM355,	MCBSP0_X,	3,   1,     1,	  1,	 false)
+MUX_CFG(DM355,	MCBSP0_BFSX,	3,   2,     1,	  1,	 false)
+MUX_CFG(DM355,	MCBSP0_BDR,	3,   3,     1,	  1,	 false)
+MUX_CFG(DM355,	MCBSP0_R,	3,   4,     1,	  1,	 false)
+MUX_CFG(DM355,	MCBSP0_BFSR,	3,   5,     1,	  1,	 false)
+
+MUX_CFG(DM355,	SPI0_SDI,	4,   1,     1,    0,	 false)
+MUX_CFG(DM355,	SPI0_SDENA0,	4,   0,     1,    0,	 false)
+MUX_CFG(DM355,	SPI0_SDENA1,	3,   28,    1,    1,	 false)
+
+INT_CFG(DM355,  INT_EDMA_CC,	      2,    1,    1,     false)
+INT_CFG(DM355,  INT_EDMA_TC0_ERR,     3,    1,    1,     false)
+INT_CFG(DM355,  INT_EDMA_TC1_ERR,     4,    1,    1,     false)
+
+EVT_CFG(DM355,  EVT8_ASP1_TX,	      0,    1,    0,     false)
+EVT_CFG(DM355,  EVT9_ASP1_RX,	      1,    1,    0,     false)
+EVT_CFG(DM355,  EVT26_MMC0_RX,	      2,    1,    0,     false)
+};
+
+/*----------------------------------------------------------------------*/
+
+static const s8 dma_chan_dm355_no_event[] = {
+	12, 13, 24, 56, 57,
+	58, 59, 60, 61, 62,
+	63,
+	-1
+};
+
+static struct edma_soc_info dm355_edma_info = {
+	.n_channel	= 64,
+	.n_region	= 4,
+	.n_slot		= 128,
+	.n_tc		= 2,
+	.noevent	= dma_chan_dm355_no_event,
+};
+
+static struct resource edma_resources[] = {
+	{
+		.name	= "edma_cc",
+		.start	= 0x01c00000,
+		.end	= 0x01c00000 + SZ_64K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "edma_tc0",
+		.start	= 0x01c10000,
+		.end	= 0x01c10000 + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "edma_tc1",
+		.start	= 0x01c10400,
+		.end	= 0x01c10400 + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= IRQ_CCINT0,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		.start	= IRQ_CCERRINT,
+		.flags	= IORESOURCE_IRQ,
+	},
+	/* not using (or muxing) TC*_ERR */
+};
+
+static struct platform_device dm355_edma_device = {
+	.name			= "edma",
+	.id			= -1,
+	.dev.platform_data	= &dm355_edma_info,
+	.num_resources		= ARRAY_SIZE(edma_resources),
+	.resource		= edma_resources,
+};
+
+/*----------------------------------------------------------------------*/
+
+void __init dm355_init(void)
+{
+	davinci_clk_init(dm355_clks);
+	davinci_mux_register(dm355_pins, ARRAY_SIZE(dm355_pins));;
+}
+
+static int __init dm355_init_devices(void)
+{
+	if (!cpu_is_davinci_dm355())
+		return 0;
+
+	davinci_cfg_reg(DM355_INT_EDMA_CC);
+	platform_device_register(&dm355_edma_device);
+	return 0;
+}
+postcore_initcall(dm355_init_devices);
