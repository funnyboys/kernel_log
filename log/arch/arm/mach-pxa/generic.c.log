commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index cb73a9723d0e..ab7cdffd7ea8 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  linux/arch/arm/mach-pxa/generic.c
  *
@@ -7,10 +8,6 @@
  *
  * Code common to all PXA machines.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  * Since this file should be linked before any other machine specific file,
  * the __initcall() here will be executed first.  This serves as default
  * initialization stuff for PXA machines which can be overridden later if

commit d3570e3c5002d514582cad09d6892a4c78c3781b
Author: Robert Jarzmik <robert.jarzmik@free.fr>
Date:   Mon Sep 19 21:12:15 2016 +0200

    ARM: sa11x0/pxa: get rid of get_clock_tick_rate
    
    The last user of this function is gone, so remove it. The clock API
    should now be used to get clock rates.
    
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 2a9297991d74..cb73a9723d0e 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -43,21 +43,6 @@ void clear_reset_status(unsigned int mask)
 	}
 }
 
-unsigned long get_clock_tick_rate(void)
-{
-	unsigned long clock_tick_rate;
-
-	if (cpu_is_pxa25x())
-		clock_tick_rate = 3686400;
-	else if (machine_is_mainstone())
-		clock_tick_rate = 3249600;
-	else
-		clock_tick_rate = 3250000;
-
-	return clock_tick_rate;
-}
-EXPORT_SYMBOL(get_clock_tick_rate);
-
 /*
  * For non device-tree builds, keep legacy timer init
  */

commit f4e14edf25661f32c9e7323d8a482b8632a6f47f
Author: Robert Jarzmik <robert.jarzmik@free.fr>
Date:   Mon Sep 19 21:12:13 2016 +0200

    ARM: sa11x0/pxa: acquire timer rate from the clock rate
    
    As both pxa and sa1100 provide a clock to the timer, the rate can be
    inferred from the clock rather than hard encoded in a functional call.
    
    This patch changes the pxa timer to have a mandatory clock which is used
    as the timer rate.
    
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index ec510ecf8370..2a9297991d74 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -69,8 +69,7 @@ void __init pxa_timer_init(void)
 		pxa27x_clocks_init();
 	if (cpu_is_pxa3xx())
 		pxa3xx_clocks_init();
-	pxa_timer_nodt_init(IRQ_OST0, io_p2v(0x40a00000),
-			    get_clock_tick_rate());
+	pxa_timer_nodt_init(IRQ_OST0, io_p2v(0x40a00000));
 }
 
 /*

commit a1c0a6adbc705a9a760416796ce9cb3349fd476f
Author: Robert Jarzmik <robert.jarzmik@free.fr>
Date:   Sat Feb 7 22:54:03 2015 +0100

    ARM: pxa: Transition pxa25x, pxa27x, pxa3xx to clk framework
    
    Transition the PXA25x, PXA27x and PXA3xx CPUs to the clock framework.
    This transition still enables legacy platforms to run without device
    tree as before, ie relying on platform data encoded in board specific
    files.
    
    This is the last step of clock framework transition for pxa
    platforms. It was tested on lubbock (pxa25x), mioa701 (pxa27x) and
    zylonite (pxa3xx).
    
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index d988c5314089..ec510ecf8370 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -67,6 +67,8 @@ void __init pxa_timer_init(void)
 		pxa25x_clocks_init();
 	if (cpu_is_pxa27x())
 		pxa27x_clocks_init();
+	if (cpu_is_pxa3xx())
+		pxa3xx_clocks_init();
 	pxa_timer_nodt_init(IRQ_OST0, io_p2v(0x40a00000),
 			    get_clock_tick_rate());
 }

commit 5e1d01285140a8cd90676ba15c06c8ec700fd618
Author: Robert Jarzmik <robert.jarzmik@free.fr>
Date:   Sat Dec 27 14:55:25 2014 +0100

    ARM: pxa: change clocks init sequence
    
    Since pxa clocks were ported to the clock framework, an ordering issue
    appears between clocks and clocksource initialization. As a consequence,
    the pxa timer clock cannot be acquired in pxa_timer, and is disabled by
    clock framework because it is "unused".
    
    The ordering issue is that in the kernel boot sequence :
      start_kernel()
        ...
        time_init()
          -> pxa_timer()
            -> here the clocksource is initialized
        ...
        rest_init()
          kernel_init()
            initcalls
              -> here the clocks are initialized
    
    In the current sequence, the clocks are initialized way after pxa_timer,
    which cannot acquire the OSTIMER0 clock.
    
    To solve this issue, the clocks initialization is moved to pxa_timer(),
    so that clocks are initialized before clocksource for non device-tree.
    For device-tree, the standard arm time_init() will take care of the
    ordering.
    
    Reviewed-by: Michael Turquette <mturquette@linaro.org>
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 04b013fbc98f..d988c5314089 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -63,6 +63,10 @@ EXPORT_SYMBOL(get_clock_tick_rate);
  */
 void __init pxa_timer_init(void)
 {
+	if (cpu_is_pxa25x())
+		pxa25x_clocks_init();
+	if (cpu_is_pxa27x())
+		pxa27x_clocks_init();
 	pxa_timer_nodt_init(IRQ_OST0, io_p2v(0x40a00000),
 			    get_clock_tick_rate());
 }

commit 3d3c6a5f3de2c76b2d6bf96be56dd6fcc2bb2a30
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Jul 26 20:49:39 2014 +0200

    ARM: pxa: fix section mismatch warning for pxa_timer_nodt_init
    
    commit a38b1f60b5245a3 ("ARM: pxa: Add non device-tree timer link to
    clocksource") introduced a harmless section mismatch warning for
    all pxa platforms, by introducing a new pxa_timer_init() function
    that is not marked __init but that calls pxa_timer_nodt_init(),
    which is.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Robert Jarzmik <robert.jarzmik@free.fr>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 630fa916bbc6..04b013fbc98f 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -61,7 +61,7 @@ EXPORT_SYMBOL(get_clock_tick_rate);
 /*
  * For non device-tree builds, keep legacy timer init
  */
-void pxa_timer_init(void)
+void __init pxa_timer_init(void)
 {
 	pxa_timer_nodt_init(IRQ_OST0, io_p2v(0x40a00000),
 			    get_clock_tick_rate());

commit 44c916d58b9ef1f2c4aec2def57fa8289c716a60
Merge: 889fa782bf8e c4846a7823bf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Aug 8 11:00:26 2014 -0700

    Merge tag 'cleanup-for-3.17' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC cleanups from Olof Johansson:
     "This merge window brings a good size of cleanups on various platforms.
      Among the bigger ones:
    
       - Removal of Samsung s5pc100 and s5p64xx platforms.  Both of these
         have lacked active support for quite a while, and after asking
         around nobody showed interest in keeping them around.  If needed,
         they could be resurrected in the future but it's more likely that
         we would prefer reintroduction of them as DT and
         multiplatform-enabled platforms instead.
    
       - OMAP4 controller code register define diet.  They defined a lot of
         registers that were never actually used, etc.
    
       - Move of some of the Tegra platform code (PMC, APBIO, fuse,
         powergate) to drivers/soc so it can be shared with 64-bit code.
         This also converts them over to traditional driver models where
         possible.
    
       - Removal of legacy gpio-samsung driver, since the last users have
         been removed (moved to pinctrl)
    
      Plus a bunch of smaller changes for various platforms that sort of
      dissapear in the diffstat for the above.  clps711x cleanups, shmobile
      header file refactoring/moves for multiplatform friendliness, some
      misc cleanups, etc"
    
    * tag 'cleanup-for-3.17' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (117 commits)
      drivers: CCI: Correct use of ! and &
      video: clcd-versatile: Depend on ARM
      video: fix up versatile CLCD helper move
      MAINTAINERS: Add sdhci-st file to ARCH/STI architecture
      ARM: EXYNOS: Fix build breakge with PM_SLEEP=n
      MAINTAINERS: Remove Kirkwood
      ARM: tegra: Convert PMC to a driver
      soc/tegra: fuse: Set up in early initcall
      ARM: tegra: Always lock the CPU reset vector
      ARM: tegra: Setup CPU hotplug in a pure initcall
      soc/tegra: Implement runtime check for Tegra SoCs
      soc/tegra: fuse: fix dummy functions
      soc/tegra: fuse: move APB DMA into Tegra20 fuse driver
      soc/tegra: Add efuse and apbmisc bindings
      soc/tegra: Add efuse driver for Tegra
      ARM: tegra: move fuse exports to soc/tegra/fuse.h
      ARM: tegra: export apb dma readl/writel
      ARM: tegra: Use a function to get the chip ID
      ARM: tegra: Sort includes alphabetically
      ARM: tegra: Move includes to include/soc/tegra
      ...

commit a38b1f60b5245a3f610baac2019c0ecd8abd8752
Author: Robert Jarzmik <robert.jarzmik@free.fr>
Date:   Mon Jul 14 18:52:04 2014 +0200

    ARM: pxa: Add non device-tree timer link to clocksource
    
    As clocksource pxa_timer was moved to clocksource framework, the
    pxa_timer initialization needs to be a bit amended, to pass the
    necessary informations to clocksource, ie :
     - the timer interrupt (mach specific)
     - the timer registers base (ditto)
     - the timer clockrate
    
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 42254175fcf4..6f38e1af45af 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -25,11 +25,13 @@
 #include <asm/mach/map.h>
 #include <asm/mach-types.h>
 
+#include <mach/irqs.h>
 #include <mach/reset.h>
 #include <mach/smemc.h>
 #include <mach/pxa3xx-regs.h>
 
 #include "generic.h"
+#include <clocksource/pxa.h>
 
 void clear_reset_status(unsigned int mask)
 {
@@ -56,6 +58,15 @@ unsigned long get_clock_tick_rate(void)
 }
 EXPORT_SYMBOL(get_clock_tick_rate);
 
+/*
+ * For non device-tree builds, keep legacy timer init
+ */
+void pxa_timer_init(void)
+{
+	pxa_timer_nodt_init(IRQ_OST0, io_p2v(0x40a00000),
+			    get_clock_tick_rate());
+}
+
 /*
  * Get the clock frequency as reflected by CCCR and the turbo flag.
  * We assume these values have been applied via a fcs.

commit b10f1c836c4e8c2372d14953a17aa5b9744eb55c
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Jul 11 13:00:37 2014 +0200

    ARM: pxa: Move UNCACHED_PHYS_0 mapping from generic.c to pxa2[57]x.c
    
    The UNCACHED_PHYS_0 mapping is only needed on PXA25x and PXA27x
    platforms. Move it to pxa25x.c and pxa27x.c to avoid wasting vmalloc
    space on PXA3xx.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 68a75fe16020..b31e101cad9b 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -83,11 +83,6 @@ static struct map_desc common_io_desc[] __initdata = {
 		.pfn		= __phys_to_pfn(PERIPH_PHYS),
 		.length		= PERIPH_SIZE,
 		.type		= MT_DEVICE
-	}, {	/* UNCACHED_PHYS_0 */
-		.virtual	= UNCACHED_PHYS_0,
-		.pfn		= __phys_to_pfn(0x00000000),
-		.length		= UNCACHED_PHYS_0_SIZE,
-		.type		= MT_DEVICE
 	}
 };
 

commit 0e32986c0f51d585b4980a0f01c269627f51b78b
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Jul 11 13:00:36 2014 +0200

    ARM: pxa: Don't hardcode addresses and size in map_desc tables
    
    The virtual address, physical address and size of all regions for which
    we create static mappings are defined in PXA headers. Replaced the
    hardcoded values with macros.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 94f49c23ca02..68a75fe16020 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -79,14 +79,14 @@ EXPORT_SYMBOL(get_clk_frequency_khz);
  */
 static struct map_desc common_io_desc[] __initdata = {
   	{	/* Devs */
-		.virtual	=  0xf2000000,
-		.pfn		= __phys_to_pfn(0x40000000),
-		.length		= 0x02000000,
+		.virtual	= (unsigned long)PERIPH_VIRT,
+		.pfn		= __phys_to_pfn(PERIPH_PHYS),
+		.length		= PERIPH_SIZE,
 		.type		= MT_DEVICE
 	}, {	/* UNCACHED_PHYS_0 */
-		.virtual	= 0xff000000,
+		.virtual	= UNCACHED_PHYS_0,
 		.pfn		= __phys_to_pfn(0x00000000),
-		.length		= 0x00100000,
+		.length		= UNCACHED_PHYS_0_SIZE,
 		.type		= MT_DEVICE
 	}
 };

commit 2111667b467748ba8a3d8950e79e6921221f41eb
Author: Andrew Ruder <andrew.ruder@elecsyscorp.com>
Date:   Thu Jun 5 14:10:57 2014 -0500

    ARM: pxa: call debug_ll_io_init for earlyprintk
    
    This is already done automatically for many other ARM platforms by the
    ARM core code, but since pxa is using the .map_io callback, it needs to
    call it explicitely for earlyprintk support.
    
    Signed-off-by: Andrew Ruder <andrew.ruder@elecsyscorp.com>
    Acked-by: Haojian Zhuang <haojian.zhuang@linaro.org>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 42254175fcf4..94f49c23ca02 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -93,5 +93,6 @@ static struct map_desc common_io_desc[] __initdata = {
 
 void __init pxa_map_io(void)
 {
+	debug_ll_io_init();
 	iotable_init(ARRAY_AND_SIZE(common_io_desc));
 }

commit 9f97da78bf018206fb623cd351d454af2f105fe0
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:01 2012 +0100

    Disintegrate asm/system.h for ARM
    
    Disintegrate asm/system.h for ARM.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Russell King <linux@arm.linux.org.uk>
    cc: linux-arm-kernel@lists.infradead.org

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 5432ecb15def..42254175fcf4 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -22,7 +22,6 @@
 #include <linux/init.h>
 
 #include <mach/hardware.h>
-#include <asm/system.h>
 #include <asm/mach/map.h>
 #include <asm/mach-types.h>
 

commit 2f8163baada3dbd0ce891c35bc59ae46e773487a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jul 26 10:53:52 2011 +0100

    ARM: gpio: convert includes of mach/gpio.h and asm/gpio.h to linux/gpio.h
    
    Convert arch/arm includes of mach/gpio.h and asm/gpio.h to linux/gpio.h
    before we start consolidating the individual platform implementations
    of the gpio header files.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index f5d91efc2965..5432ecb15def 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -16,6 +16,7 @@
  * initialization stuff for PXA machines which can be overridden later if
  * need be.
  */
+#include <linux/gpio.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -26,7 +27,6 @@
 #include <asm/mach-types.h>
 
 #include <mach/reset.h>
-#include <mach/gpio.h>
 #include <mach/smemc.h>
 #include <mach/pxa3xx-regs.h>
 

commit 671289c2872cfc050954ac1dd3131429fca30aad
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jan 15 00:14:25 2011 +0000

    ARM: Fix build regression on SA11x0, PXA, and H720x targets
    
    Build errors similar this appeared in todays kautobuild for the above
    targets:
    
    In file included from arch/arm/include/asm/pgtable.h:461,
                     from arch/arm/mach-pxa/generic.c:26:
    include/asm-generic/pgtable.h: In function 'ptep_test_and_clear_young':
    include/asm-generic/pgtable.h:29: error: dereferencing pointer to incomplete type
    
    None of the .c files including asm/pgtable.h with this error is using
    this header, so simply remove the include.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index d6e15f71fc09..f5d91efc2965 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -22,7 +22,6 @@
 
 #include <mach/hardware.h>
 #include <asm/system.h>
-#include <asm/pgtable.h>
 #include <asm/mach/map.h>
 #include <asm/mach-types.h>
 

commit a4553358d94b4a1f3e6f24aacfd076022ac14855
Author: Haojian Zhuang <haojian.zhuang@marvell.com>
Date:   Wed Nov 24 11:54:19 2010 +0800

    ARM: pxa: support pxa95x
    
    The core of PXA955 is PJ4. Add new PJ4 support. And add new macro
    CONFIG_PXA95x.
    
    Signed-off-by: Haojian Zhuang <haojian.zhuang@marvell.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index d2bb071b0afc..d6e15f71fc09 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -29,6 +29,7 @@
 #include <mach/reset.h>
 #include <mach/gpio.h>
 #include <mach/smemc.h>
+#include <mach/pxa3xx-regs.h>
 
 #include "generic.h"
 
@@ -36,9 +37,10 @@ void clear_reset_status(unsigned int mask)
 {
 	if (cpu_is_pxa2xx())
 		pxa2xx_clear_reset_status(mask);
-
-	if (cpu_is_pxa3xx())
-		pxa3xx_clear_reset_status(mask);
+	else {
+		/* RESET_STATUS_* has a 1:1 mapping with ARSR */
+		ARSR = mask;
+	}
 }
 
 unsigned long get_clock_tick_rate(void)

commit 2a125dd56b3a853701063fe8a678ad7603e385fd
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Mon Nov 22 22:48:49 2010 +0800

    ARM: pxa: remove get_memclk_frequency_10khz()
    
    Introduce 'struct clk' for memory and remove
    get_memclk_frequency_10khz().
    
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index d4ce8f9233d7..d2bb071b0afc 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -71,19 +71,6 @@ unsigned int get_clk_frequency_khz(int info)
 }
 EXPORT_SYMBOL(get_clk_frequency_khz);
 
-/*
- * Return the current memory clock frequency in units of 10kHz
- */
-unsigned int get_memclk_frequency_10khz(void)
-{
-	if (cpu_is_pxa25x())
-		return pxa25x_get_memclk_frequency_10khz();
-	else if (cpu_is_pxa27x())
-		return pxa27x_get_memclk_frequency_10khz();
-	return 0;
-}
-EXPORT_SYMBOL(get_memclk_frequency_10khz);
-
 /*
  * Intel PXA2xx internal register mapping.
  *

commit ad68bb9f7a3cd47396635a5e3895215af57579da
Author: Marek Vasut <marek.vasut@gmail.com>
Date:   Wed Nov 3 16:29:35 2010 +0100

    ARM: pxa: Access SMEMC via virtual addresses
    
    This is important because on PXA3xx, the physical mapping of SMEMC registers
    differs from the one on PXA2xx. In order to get PCMCIA working on both PXA2xx
    and PXA320, the PCMCIA driver was adjusted accordingly as well.
    
    Also, various places in the kernel had to be patched to use
    __raw_read/__raw_write.
    
    Signed-off-by: Marek Vasut <marek.vasut@gmail.com>
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 6a5f37935378..d4ce8f9233d7 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -28,6 +28,7 @@
 
 #include <mach/reset.h>
 #include <mach/gpio.h>
+#include <mach/smemc.h>
 
 #include "generic.h"
 

commit 851982c1b6ca18cedf6d01e4529a0c1ddb30771e
Author: Marek Vasut <marek.vasut@gmail.com>
Date:   Mon Oct 11 02:20:19 2010 +0200

    ARM: pxa: Introduce pxa{25x,27x,3xx}_map_io()
    
    This patch introduces pxa2xx_map_io() and pxa3xx_map_io() to distinguish
    between PXA25x/PXA27x and PXA3xx memory mapping.
    
    Also, fixup for platforms broken after introducing pxa{25x,27x}_map_io()
    and pxa3xx_map_io() is included.
    
    Signed-off-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 69a89fe4ce8d..6a5f37935378 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -86,27 +86,15 @@ EXPORT_SYMBOL(get_memclk_frequency_10khz);
 /*
  * Intel PXA2xx internal register mapping.
  *
- * Note 1: not all PXA2xx variants implement all those addresses.
- *
- * Note 2: virtual 0xfffe0000-0xffffffff is reserved for the vector table
- *         and cache flush area.
+ * Note: virtual 0xfffe0000-0xffffffff is reserved for the vector table
+ *       and cache flush area.
  */
-static struct map_desc standard_io_desc[] __initdata = {
+static struct map_desc common_io_desc[] __initdata = {
   	{	/* Devs */
 		.virtual	=  0xf2000000,
 		.pfn		= __phys_to_pfn(0x40000000),
 		.length		= 0x02000000,
 		.type		= MT_DEVICE
-	}, {	/* Mem Ctl */
-		.virtual	=  0xf6000000,
-		.pfn		= __phys_to_pfn(0x48000000),
-		.length		= 0x00200000,
-		.type		= MT_DEVICE
-	}, {	/* IMem ctl */
-		.virtual	=  0xfe000000,
-		.pfn		= __phys_to_pfn(0x58000000),
-		.length		= 0x00100000,
-		.type		= MT_DEVICE
 	}, {	/* UNCACHED_PHYS_0 */
 		.virtual	= 0xff000000,
 		.pfn		= __phys_to_pfn(0x00000000),
@@ -117,6 +105,5 @@ static struct map_desc standard_io_desc[] __initdata = {
 
 void __init pxa_map_io(void)
 {
-	iotable_init(standard_io_desc, ARRAY_SIZE(standard_io_desc));
-	get_clk_frequency_khz(1);
+	iotable_init(ARRAY_AND_SIZE(common_io_desc));
 }

commit ead67b6e6679b14befb0cef59db60e2853e19cd8
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Wed Oct 13 10:38:56 2010 +0800

    ARM: pxa: remove un-used mapping of camera registers
    
    The camera registers start and range are encoded into the platform
    device, and are actually handled by ioremap()'ed, thus the mapping
    in pxa_map_io() is not necessary.
    
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 6451e9c3a93f..69a89fe4ce8d 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -102,11 +102,6 @@ static struct map_desc standard_io_desc[] __initdata = {
 		.pfn		= __phys_to_pfn(0x48000000),
 		.length		= 0x00200000,
 		.type		= MT_DEVICE
-	}, {	/* Camera */
-		.virtual	=  0xfa000000,
-		.pfn		= __phys_to_pfn(0x50000000),
-		.length		= 0x00100000,
-		.type		= MT_DEVICE
 	}, {	/* IMem ctl */
 		.virtual	=  0xfe000000,
 		.pfn		= __phys_to_pfn(0x58000000),

commit 799929d7048b3ec0086ed525ed7ccf6f2b8ecda6
Author: Haojian Zhuang <haojian.zhuang@gmail.com>
Date:   Sun Sep 19 20:10:13 2010 -0400

    ARM: pxa: reduce the scope of get_memclk_frequency_10khz()
    
    Up to now, only pxa2xx pcmcia driver is using the API. No other device driver
    is using this API in PXA3xx or any other PXA silicons.
    
    Restrict the scope only on pxa2xx and remove the implementation of pxa3xx. So
    we can avoid oo much checking on cpuid after more pxa chips supported.
    
    Signed-off-by: Haojian Zhuang <haojian.zhuang@marvell.com>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 6655dea11c2f..6451e9c3a93f 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -79,8 +79,7 @@ unsigned int get_memclk_frequency_10khz(void)
 		return pxa25x_get_memclk_frequency_10khz();
 	else if (cpu_is_pxa27x())
 		return pxa27x_get_memclk_frequency_10khz();
-	else
-		return pxa3xx_get_memclk_frequency_10khz();
+	return 0;
 }
 EXPORT_SYMBOL(get_memclk_frequency_10khz);
 

commit ecf89b8a9189462480086f72791eb41f8aa09bfd
Author: Haojian Zhuang <haojian.zhuang@gmail.com>
Date:   Sun Sep 19 20:09:10 2010 -0400

    ARM: pxa: reduce the scope of get_clk_frequency_khz()
    
    get_clk_frequency_khz() is used in private cpufreq driver. In order to meet
    the change of different pxa silicons, checking cpuid is introduced in
    get_clk_frequency_khz(). While more pxa silicons are supported, the workload
    of checking cpuid is higher.
    
    So restrict the scope of get_clk_frequency_khz() on pxa2xx. Different pxa
    silcions use different private cpufreq driver to avoid too much checking
    on cpuid.
    
    Signed-off-by: Haojian Zhuang <haojian.zhuang@marvell.com>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index baabb3ce088e..6655dea11c2f 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -66,8 +66,7 @@ unsigned int get_clk_frequency_khz(int info)
 		return pxa25x_get_clk_frequency_khz(info);
 	else if (cpu_is_pxa27x())
 		return pxa27x_get_clk_frequency_khz(info);
-	else
-		return pxa3xx_get_clk_frequency_khz(info);
+	return 0;
 }
 EXPORT_SYMBOL(get_clk_frequency_khz);
 

commit b1d9bf1d9836dcee235f49bb4eb5ba4450a3a678
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Tue Apr 27 15:09:33 2010 +0800

    [ARM] pxa: remove pxa_gpio_mode() and files
    
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 3126a35aa002..baabb3ce088e 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -28,7 +28,6 @@
 
 #include <mach/reset.h>
 #include <mach/gpio.h>
-#include <mach/pxa2xx-gpio.h>
 
 #include "generic.h"
 
@@ -128,33 +127,3 @@ void __init pxa_map_io(void)
 	iotable_init(standard_io_desc, ARRAY_SIZE(standard_io_desc));
 	get_clk_frequency_khz(1);
 }
-
-/*
- * Configure pins for GPIO or other functions
- */
-int pxa_gpio_mode(int gpio_mode)
-{
-	unsigned long flags;
-	int gpio = gpio_mode & GPIO_MD_MASK_NR;
-	int fn = (gpio_mode & GPIO_MD_MASK_FN) >> 8;
-	int gafr;
-
-	if (gpio > pxa_last_gpio)
-		return -EINVAL;
-
-	local_irq_save(flags);
-	if (gpio_mode & GPIO_DFLT_LOW)
-		GPCR(gpio) = GPIO_bit(gpio);
-	else if (gpio_mode & GPIO_DFLT_HIGH)
-		GPSR(gpio) = GPIO_bit(gpio);
-	if (gpio_mode & GPIO_MD_MASK_DIR)
-		GPDR(gpio) |= GPIO_bit(gpio);
-	else
-		GPDR(gpio) &= ~GPIO_bit(gpio);
-	gafr = GAFR(gpio) & ~(0x3 << (((gpio) & 0xf)*2));
-	GAFR(gpio) = gafr |  (fn  << (((gpio) & 0xf)*2));
-	local_irq_restore(flags);
-
-	return 0;
-}
-EXPORT_SYMBOL(pxa_gpio_mode);

commit da065a0b3611751feefeb0f0e277cd5830056dad
Author: Eric Miao <eric.miao@marvell.com>
Date:   Tue Jan 6 18:29:01 2009 +0800

    [ARM] pxa: move GPIO register definitions into <mach/gpio.h>
    
    This makes gpio.c fully independent of pxa-regs.h (except for the
    virtual address of the registers).
    
    Signed-off-by: Mike Rapoport <mike@compulab.co.il>
    Signed-off-by: Eric Miao <eric.miao@marvell.com>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index dc870dd93697..3126a35aa002 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -26,8 +26,8 @@
 #include <asm/mach/map.h>
 #include <asm/mach-types.h>
 
-#include <mach/pxa-regs.h>
 #include <mach/reset.h>
+#include <mach/gpio.h>
 #include <mach/pxa2xx-gpio.h>
 
 #include "generic.h"

commit 0d9f768fce67a53b9c2296789129d4dfb3f4996b
Author: Eric Miao <eric.miao@marvell.com>
Date:   Tue Jan 6 18:06:25 2009 +0800

    [ARM] pxa: move pxa_gpio_mode() outside of generic gpio.c
    
    Looks like we have to live with pxa_gpio_mode() for a while, giving
    its presence is actually making gpio.c not generic enough, let's
    move it temporarily outside before it can be fully purged.
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 0ccc91c92c44..dc870dd93697 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -28,6 +28,7 @@
 
 #include <mach/pxa-regs.h>
 #include <mach/reset.h>
+#include <mach/pxa2xx-gpio.h>
 
 #include "generic.h"
 
@@ -127,3 +128,33 @@ void __init pxa_map_io(void)
 	iotable_init(standard_io_desc, ARRAY_SIZE(standard_io_desc));
 	get_clk_frequency_khz(1);
 }
+
+/*
+ * Configure pins for GPIO or other functions
+ */
+int pxa_gpio_mode(int gpio_mode)
+{
+	unsigned long flags;
+	int gpio = gpio_mode & GPIO_MD_MASK_NR;
+	int fn = (gpio_mode & GPIO_MD_MASK_FN) >> 8;
+	int gafr;
+
+	if (gpio > pxa_last_gpio)
+		return -EINVAL;
+
+	local_irq_save(flags);
+	if (gpio_mode & GPIO_DFLT_LOW)
+		GPCR(gpio) = GPIO_bit(gpio);
+	else if (gpio_mode & GPIO_DFLT_HIGH)
+		GPSR(gpio) = GPIO_bit(gpio);
+	if (gpio_mode & GPIO_MD_MASK_DIR)
+		GPDR(gpio) |= GPIO_bit(gpio);
+	else
+		GPDR(gpio) &= ~GPIO_bit(gpio);
+	gafr = GAFR(gpio) & ~(0x3 << (((gpio) & 0xf)*2));
+	GAFR(gpio) = gafr |  (fn  << (((gpio) & 0xf)*2));
+	local_irq_restore(flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(pxa_gpio_mode);

commit 6769717d5d51596618f6b143008d8ace11ec8a69
Author: Eric Miao <eric.miao@marvell.com>
Date:   Thu Dec 18 11:10:32 2008 +0800

    [ARM] rtc-sa1100: don't assume CLOCK_TICK_RATE to be a constant
    
    As Nicolas and Russell pointed out, CLOCK_TICK_RATE is no more
    a constant on PXA when multiple processors and platforms are
    selected, change TIMER_FREQ in rtc-sa1100.c into a variable.
    
    Since the code to decide the clock tick rate is re-used from
    timer.c, introduce a common get_clock_tick_rate() for this.
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Acked-by: Nicolas Pitre <nico@marvell.com>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 85ed0b33331f..0ccc91c92c44 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -24,6 +24,7 @@
 #include <asm/system.h>
 #include <asm/pgtable.h>
 #include <asm/mach/map.h>
+#include <asm/mach-types.h>
 
 #include <mach/pxa-regs.h>
 #include <mach/reset.h>
@@ -39,6 +40,21 @@ void clear_reset_status(unsigned int mask)
 		pxa3xx_clear_reset_status(mask);
 }
 
+unsigned long get_clock_tick_rate(void)
+{
+	unsigned long clock_tick_rate;
+
+	if (cpu_is_pxa25x())
+		clock_tick_rate = 3686400;
+	else if (machine_is_mainstone())
+		clock_tick_rate = 3249600;
+	else
+		clock_tick_rate = 3250000;
+
+	return clock_tick_rate;
+}
+EXPORT_SYMBOL(get_clock_tick_rate);
+
 /*
  * Get the clock frequency as reflected by CCCR and the turbo flag.
  * We assume these values have been applied via a fcs.

commit 0c392ed9a78cbe0f54955ea4716ade8bc22eb00d
Author: Eric Miao <eric.miao@marvell.com>
Date:   Sat Oct 4 12:57:21 2008 +0800

    [ARM] ohci-pxa27x: use ioremap() and offset for register access
    
    This avoid the pre-mapping of OHCI controller register space, and the
    mapping is made only when necessary (OHCI is probed).
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index cbbf30097920..85ed0b33331f 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -88,11 +88,6 @@ static struct map_desc standard_io_desc[] __initdata = {
 		.pfn		= __phys_to_pfn(0x48000000),
 		.length		= 0x00200000,
 		.type		= MT_DEVICE
-	}, {	/* USB host */
-		.virtual	=  0xf8000000,
-		.pfn		= __phys_to_pfn(0x4c000000),
-		.length		= 0x00100000,
-		.type		= MT_DEVICE
 	}, {	/* Camera */
 		.virtual	=  0xfa000000,
 		.pfn		= __phys_to_pfn(0x50000000),

commit 0ffcbfd54ea81ca24c0749f55ca4fcf3e2bdc23e
Author: Eric Miao <eric.miao@marvell.com>
Date:   Thu Sep 11 10:27:30 2008 +0800

    [ARM] pxa: make cpu_is_pxa2* macros more consistent
    
    1. add a CPUID table in the comment
    
    2. make cpu_is_pxa25x() true for PXA210/250/255/26x
    
    3. PXA210 is treated as PXA25x, all related code modified to
       reflect this
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index ceaed0076366..cbbf30097920 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -46,7 +46,7 @@ void clear_reset_status(unsigned int mask)
  */
 unsigned int get_clk_frequency_khz(int info)
 {
-	if (cpu_is_pxa21x() || cpu_is_pxa25x())
+	if (cpu_is_pxa25x())
 		return pxa25x_get_clk_frequency_khz(info);
 	else if (cpu_is_pxa27x())
 		return pxa27x_get_clk_frequency_khz(info);
@@ -60,7 +60,7 @@ EXPORT_SYMBOL(get_clk_frequency_khz);
  */
 unsigned int get_memclk_frequency_10khz(void)
 {
-	if (cpu_is_pxa21x() || cpu_is_pxa25x())
+	if (cpu_is_pxa25x())
 		return pxa25x_get_memclk_frequency_10khz();
 	else if (cpu_is_pxa27x())
 		return pxa27x_get_memclk_frequency_10khz();

commit afd2fc02ab7bae6062671c5ca80dd34c34a63fb7
Merge: 1f4de5a0e3b4 214c6a7ed13e
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Aug 7 11:05:25 2008 +0100

    Merge branch 'for-rmk' of git://git.kernel.org/pub/scm/linux/kernel/git/ycmiao/pxa-linux-2.6
    
    Conflicts:
    
            arch/arm/mach-pxa/generic.c
            arch/arm/mach-pxa/pxa25x.c
            arch/arm/mach-pxa/pxa27x.c
            arch/arm/mach-pxa/pxa2xx.c
            arch/arm/mach-pxa/pxa3xx.c
            arch/arm/mach-pxa/reset.c
            arch/arm/mach-pxa/spitz.c
            arch/arm/mach-pxa/tosa.c
            drivers/watchdog/sa1100_wdt.c

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 2106028636f4..2834b7fff78c 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -20,12 +20,12 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 
-#include <asm/arch/hardware.h>
+#include <mach/hardware.h>
 #include <asm/system.h>
 #include <asm/pgtable.h>
 #include <asm/mach/map.h>
 
-#include <asm/arch/pxa-regs.h>
+#include <mach/pxa-regs.h>
 
 #include "generic.h"
 

commit be509729356b7433f73df2b9a966674a437fbbc1
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Aug 4 10:41:28 2008 +0100

    [ARM] Remove asm/hardware.h, use asm/arch/hardware.h instead
    
    Remove includes of asm/hardware.h in addition to asm/arch/hardware.h.
    Then, since asm/hardware.h only exists to include asm/arch/hardware.h,
    update everything to directly include asm/arch/hardware.h and remove
    asm/hardware.h.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index ca053226fba0..2106028636f4 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -20,7 +20,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 
-#include <asm/hardware.h>
+#include <asm/arch/hardware.h>
 #include <asm/system.h>
 #include <asm/pgtable.h>
 #include <asm/mach/map.h>

commit 04fef228fb00dd79475a2313f4ba73b4fbfe2faa
Author: Eric Miao <eric.miao@marvell.com>
Date:   Tue Jul 29 14:26:00 2008 +0800

    [ARM] pxa: introduce reset_status and clear_reset_status for driver's usage
    
    Due to the problem of reset status bits being handled by different
    registers between pxa2xx and pxa3xx, introduce a global reset_status
    variable, initialized by SoC-specific code and later being used by
    other drivers.
    
    And also introduce clear_reset_status(), which is used to clear the
    corresponding status bits. Pass RESET_STATUS_ALL to clear all bits.
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index ca053226fba0..36638926c5ce 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -26,9 +26,19 @@
 #include <asm/mach/map.h>
 
 #include <asm/arch/pxa-regs.h>
+#include <asm/arch/reset.h>
 
 #include "generic.h"
 
+void clear_reset_status(unsigned int mask)
+{
+	if (cpu_is_pxa2xx())
+		pxa2xx_clear_reset_status(mask);
+
+	if (cpu_is_pxa3xx())
+		pxa3xx_clear_reset_status(mask);
+}
+
 /*
  * Get the clock frequency as reflected by CCCR and the turbo flag.
  * We assume these values have been applied via a fcs.

commit 66a7f72d9892013e9ea663260f407758989ff510
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Jun 2 16:10:20 2008 +0100

    [ARM] pxa: remove pxa_set_cken()
    
    pxa_set_cken() is now unused, remove it.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index c2f102339f57..ca053226fba0 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -26,7 +26,6 @@
 #include <asm/mach/map.h>
 
 #include <asm/arch/pxa-regs.h>
-#include <asm/arch/pxa2xx-regs.h> /* for __pxa_set_cken */
 
 #include "generic.h"
 
@@ -60,23 +59,6 @@ unsigned int get_memclk_frequency_10khz(void)
 }
 EXPORT_SYMBOL(get_memclk_frequency_10khz);
 
-/*
- * Routine to safely enable or disable a clock in the CKEN
- */
-void __pxa_set_cken(int clock, int enable)
-{
-	unsigned long flags;
-	local_irq_save(flags);
-
-	if (enable)
-		CKEN |= (1 << clock);
-	else
-		CKEN &= ~(1 << clock);
-
-	local_irq_restore(flags);
-}
-EXPORT_SYMBOL(__pxa_set_cken);
-
 /*
  * Intel PXA2xx internal register mapping.
  *

commit 0b0a9df6038752674e54e333cd247c877d29aab8
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun May 18 14:59:36 2008 +0100

    [ARM] pxa: separate out power manager and clock registers
    
    The power manager and core clock registers aren't present in PXA3
    CPUs.  Move them out of pxa-regs.h into pxa2xx-regs.h, and include
    pxa2xx-regs.h where necessary.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 44617938f3f1..c2f102339f57 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -26,6 +26,7 @@
 #include <asm/mach/map.h>
 
 #include <asm/arch/pxa-regs.h>
+#include <asm/arch/pxa2xx-regs.h> /* for __pxa_set_cken */
 
 #include "generic.h"
 

commit ce4fb7b892a6d6c6a0f87366b26fd834d2923dd7
Author: eric miao <eric.miao@marvell.com>
Date:   Wed Apr 30 00:52:21 2008 -0700

    pxafb: convert fb driver to use ioremap() and __raw_{readl, writel}
    
    This is part of the effort moving peripheral registers outside of pxa-regs.h,
    and using ioremap() make it possible the same IP can be re-used on different
    processors with different registers space
    
    As a result, the fixed mapping in pxa_map_io() is removed.
    
    The regs-lcd.h can actually moved to where closer to pxafb.c but some of its
    bit definitions are directly used by various platform code, though this is not
    a good style.
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 331f29b2d0cd..44617938f3f1 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -90,11 +90,6 @@ static struct map_desc standard_io_desc[] __initdata = {
 		.pfn		= __phys_to_pfn(0x40000000),
 		.length		= 0x02000000,
 		.type		= MT_DEVICE
-	}, {	/* LCD */
-		.virtual	=  0xf4000000,
-		.pfn		= __phys_to_pfn(0x44000000),
-		.length		= 0x00100000,
-		.type		= MT_DEVICE
 	}, {	/* Mem Ctl */
 		.virtual	=  0xf6000000,
 		.pfn		= __phys_to_pfn(0x48000000),

commit 663707c1a99b23a79f9e21117b7c1bdbfe80a899
Author: eric miao <eric.miao@marvell.com>
Date:   Tue Mar 4 16:13:58 2008 +0800

    [ARM] pxa: move GPIO sysdev outside of generic.c into gpio.c
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 80721c610d41..331f29b2d0cd 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -19,14 +19,8 @@
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/ioport.h>
-#include <linux/pm.h>
-#include <linux/string.h>
-#include <linux/sysdev.h>
 
 #include <asm/hardware.h>
-#include <asm/irq.h>
 #include <asm/system.h>
 #include <asm/pgtable.h>
 #include <asm/mach/map.h>
@@ -134,59 +128,3 @@ void __init pxa_map_io(void)
 	iotable_init(standard_io_desc, ARRAY_SIZE(standard_io_desc));
 	get_clk_frequency_khz(1);
 }
-
-#ifdef CONFIG_PM
-
-static unsigned long saved_gplr[4];
-static unsigned long saved_gpdr[4];
-static unsigned long saved_grer[4];
-static unsigned long saved_gfer[4];
-
-static int pxa_gpio_suspend(struct sys_device *dev, pm_message_t state)
-{
-	int i, gpio;
-
-	for (gpio = 0, i = 0; gpio < pxa_last_gpio; gpio += 32, i++) {
-		saved_gplr[i] = GPLR(gpio);
-		saved_gpdr[i] = GPDR(gpio);
-		saved_grer[i] = GRER(gpio);
-		saved_gfer[i] = GFER(gpio);
-
-		/* Clear GPIO transition detect bits */
-		GEDR(gpio) = GEDR(gpio);
-	}
-	return 0;
-}
-
-static int pxa_gpio_resume(struct sys_device *dev)
-{
-	int i, gpio;
-
-	for (gpio = 0, i = 0; gpio < pxa_last_gpio; gpio += 32, i++) {
-		/* restore level with set/clear */
-		GPSR(gpio) = saved_gplr[i];
-		GPCR(gpio) = ~saved_gplr[i];
-
-		GRER(gpio) = saved_grer[i];
-		GFER(gpio) = saved_gfer[i];
-		GPDR(gpio) = saved_gpdr[i];
-	}
-	return 0;
-}
-#else
-#define pxa_gpio_suspend	NULL
-#define pxa_gpio_resume		NULL
-#endif
-
-struct sysdev_class pxa_gpio_sysclass = {
-	.name		= "gpio",
-	.suspend	= pxa_gpio_suspend,
-	.resume		= pxa_gpio_resume,
-};
-
-static int __init pxa_gpio_init(void)
-{
-	return sysdev_class_register(&pxa_gpio_sysclass);
-}
-
-core_initcall(pxa_gpio_init);

commit 1c44f5f16fee880b294f8068354bfb9dddf1349b
Author: Philipp Zabel <philipp.zabel@gmail.com>
Date:   Mon Feb 4 22:28:22 2008 -0800

    gpiolib support for the PXA architecture
    
    This adds gpiolib support for the PXA architecture:
      - move all GPIO API functions from generic.c into gpio.c
      - convert the gpio_get/set_value macros into inline functions
    
    This makes it easier to hook up GPIOs provided by external chips like
    ASICs and CPLDs.
    
    Signed-off-by: Philipp Zabel <philipp.zabel@gmail.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Jean Delvare <khali@linux-fr.org>
    Cc: Eric Miao <eric.miao@marvell.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Haavard Skinnemoen <hskinnemoen@atmel.com>
    Cc: Ben Gardner <bgardner@wabtec.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    [ Minor ARM fixup from David Brownell folded into this ]
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 76970598f550..80721c610d41 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -32,7 +32,6 @@
 #include <asm/mach/map.h>
 
 #include <asm/arch/pxa-regs.h>
-#include <asm/arch/gpio.h>
 
 #include "generic.h"
 
@@ -66,97 +65,6 @@ unsigned int get_memclk_frequency_10khz(void)
 }
 EXPORT_SYMBOL(get_memclk_frequency_10khz);
 
-/*
- * Handy function to set GPIO alternate functions
- */
-int pxa_last_gpio;
-
-int pxa_gpio_mode(int gpio_mode)
-{
-	unsigned long flags;
-	int gpio = gpio_mode & GPIO_MD_MASK_NR;
-	int fn = (gpio_mode & GPIO_MD_MASK_FN) >> 8;
-	int gafr;
-
-	if (gpio > pxa_last_gpio)
-		return -EINVAL;
-
-	local_irq_save(flags);
-	if (gpio_mode & GPIO_DFLT_LOW)
-		GPCR(gpio) = GPIO_bit(gpio);
-	else if (gpio_mode & GPIO_DFLT_HIGH)
-		GPSR(gpio) = GPIO_bit(gpio);
-	if (gpio_mode & GPIO_MD_MASK_DIR)
-		GPDR(gpio) |= GPIO_bit(gpio);
-	else
-		GPDR(gpio) &= ~GPIO_bit(gpio);
-	gafr = GAFR(gpio) & ~(0x3 << (((gpio) & 0xf)*2));
-	GAFR(gpio) = gafr |  (fn  << (((gpio) & 0xf)*2));
-	local_irq_restore(flags);
-
-	return 0;
-}
-
-EXPORT_SYMBOL(pxa_gpio_mode);
-
-int gpio_direction_input(unsigned gpio)
-{
-	unsigned long flags;
-	u32 mask;
-
-	if (gpio > pxa_last_gpio)
-		return -EINVAL;
-
-	mask = GPIO_bit(gpio);
-	local_irq_save(flags);
-	GPDR(gpio) &= ~mask;
-	local_irq_restore(flags);
-
-	return 0;
-}
-EXPORT_SYMBOL(gpio_direction_input);
-
-int gpio_direction_output(unsigned gpio, int value)
-{
-	unsigned long flags;
-	u32 mask;
-
-	if (gpio > pxa_last_gpio)
-		return -EINVAL;
-
-	mask = GPIO_bit(gpio);
-	local_irq_save(flags);
-	if (value)
-		GPSR(gpio) = mask;
-	else
-		GPCR(gpio) = mask;
-	GPDR(gpio) |= mask;
-	local_irq_restore(flags);
-
-	return 0;
-}
-EXPORT_SYMBOL(gpio_direction_output);
-
-/*
- * Return GPIO level
- */
-int pxa_gpio_get_value(unsigned gpio)
-{
-	return __gpio_get_value(gpio);
-}
-
-EXPORT_SYMBOL(pxa_gpio_get_value);
-
-/*
- * Set output GPIO level
- */
-void pxa_gpio_set_value(unsigned gpio, int value)
-{
-	__gpio_set_value(gpio, value);
-}
-
-EXPORT_SYMBOL(pxa_gpio_set_value);
-
 /*
  * Routine to safely enable or disable a clock in the CKEN
  */
@@ -172,7 +80,6 @@ void __pxa_set_cken(int clock, int enable)
 
 	local_irq_restore(flags);
 }
-
 EXPORT_SYMBOL(__pxa_set_cken);
 
 /*

commit 16dfdbf038706c12c56f327d14c6b901edc376a3
Author: eric miao <eric.miao@marvell.com>
Date:   Mon Jan 28 23:00:02 2008 +0000

    [ARM] pxa: introduce sysdev for GPIO register saving/restoring
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 698aeec52961..76970598f550 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -23,6 +23,7 @@
 #include <linux/ioport.h>
 #include <linux/pm.h>
 #include <linux/string.h>
+#include <linux/sysdev.h>
 
 #include <asm/hardware.h>
 #include <asm/irq.h>
@@ -226,3 +227,59 @@ void __init pxa_map_io(void)
 	iotable_init(standard_io_desc, ARRAY_SIZE(standard_io_desc));
 	get_clk_frequency_khz(1);
 }
+
+#ifdef CONFIG_PM
+
+static unsigned long saved_gplr[4];
+static unsigned long saved_gpdr[4];
+static unsigned long saved_grer[4];
+static unsigned long saved_gfer[4];
+
+static int pxa_gpio_suspend(struct sys_device *dev, pm_message_t state)
+{
+	int i, gpio;
+
+	for (gpio = 0, i = 0; gpio < pxa_last_gpio; gpio += 32, i++) {
+		saved_gplr[i] = GPLR(gpio);
+		saved_gpdr[i] = GPDR(gpio);
+		saved_grer[i] = GRER(gpio);
+		saved_gfer[i] = GFER(gpio);
+
+		/* Clear GPIO transition detect bits */
+		GEDR(gpio) = GEDR(gpio);
+	}
+	return 0;
+}
+
+static int pxa_gpio_resume(struct sys_device *dev)
+{
+	int i, gpio;
+
+	for (gpio = 0, i = 0; gpio < pxa_last_gpio; gpio += 32, i++) {
+		/* restore level with set/clear */
+		GPSR(gpio) = saved_gplr[i];
+		GPCR(gpio) = ~saved_gplr[i];
+
+		GRER(gpio) = saved_grer[i];
+		GFER(gpio) = saved_gfer[i];
+		GPDR(gpio) = saved_gpdr[i];
+	}
+	return 0;
+}
+#else
+#define pxa_gpio_suspend	NULL
+#define pxa_gpio_resume		NULL
+#endif
+
+struct sysdev_class pxa_gpio_sysclass = {
+	.name		= "gpio",
+	.suspend	= pxa_gpio_suspend,
+	.resume		= pxa_gpio_resume,
+};
+
+static int __init pxa_gpio_init(void)
+{
+	return sysdev_class_register(&pxa_gpio_sysclass);
+}
+
+core_initcall(pxa_gpio_init);

commit 7664c400cc994542a27d1bacde54673880e7e179
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Jan 4 22:41:09 2008 +0000

    [ARM] pxa: increase size of memory mapping
    
    The mapping for physical address 0x48000000 is not sufficient
    to allow access to the dynamic memory controller configuration
    registers on PXA3.  These registers need to be accessed to
    reconfigure the SDRAM when waking from a low power mode.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index e4dbdbc2fb15..698aeec52961 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -196,7 +196,7 @@ static struct map_desc standard_io_desc[] __initdata = {
 	}, {	/* Mem Ctl */
 		.virtual	=  0xf6000000,
 		.pfn		= __phys_to_pfn(0x48000000),
-		.length		= 0x00100000,
+		.length		= 0x00200000,
 		.type		= MT_DEVICE
 	}, {	/* USB host */
 		.virtual	=  0xf8000000,

commit 8f58de7c3932f659fff3b4e5fc14ca8ccf8ec873
Author: eric miao <eric.miao@marvell.com>
Date:   Wed Dec 19 17:14:02 2007 +0800

    [ARM] pxa: create arch/arm/mach-pxa/device.c for all on-chip devices
    
    Considering that generic.c is getting more and more bloated by device
    information, moving that part out side will be much cleaner.
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index a8d88704c8d4..e4dbdbc2fb15 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -20,11 +20,9 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/delay.h>
-#include <linux/platform_device.h>
 #include <linux/ioport.h>
 #include <linux/pm.h>
 #include <linux/string.h>
-#include <linux/dma-mapping.h>
 
 #include <asm/hardware.h>
 #include <asm/irq.h>
@@ -34,13 +32,7 @@
 
 #include <asm/arch/pxa-regs.h>
 #include <asm/arch/gpio.h>
-#include <asm/arch/udc.h>
-#include <asm/arch/pxafb.h>
-#include <asm/arch/mmc.h>
-#include <asm/arch/irda.h>
-#include <asm/arch/i2c.h>
 
-#include "devices.h"
 #include "generic.h"
 
 /*
@@ -234,543 +226,3 @@ void __init pxa_map_io(void)
 	iotable_init(standard_io_desc, ARRAY_SIZE(standard_io_desc));
 	get_clk_frequency_khz(1);
 }
-
-
-void __init pxa_register_device(struct platform_device *dev, void *data)
-{
-	int ret;
-
-	dev->dev.platform_data = data;
-
-	ret = platform_device_register(dev);
-	if (ret)
-		dev_err(&dev->dev, "unable to register device: %d\n", ret);
-}
-
-
-static struct resource pxamci_resources[] = {
-	[0] = {
-		.start	= 0x41100000,
-		.end	= 0x41100fff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_MMC,
-		.end	= IRQ_MMC,
-		.flags	= IORESOURCE_IRQ,
-	},
-	[2] = {
-		.start	= 21,
-		.end	= 21,
-		.flags	= IORESOURCE_DMA,
-	},
-	[3] = {
-		.start	= 22,
-		.end	= 22,
-		.flags	= IORESOURCE_DMA,
-	},
-};
-
-static u64 pxamci_dmamask = 0xffffffffUL;
-
-struct platform_device pxa_device_mci = {
-	.name		= "pxa2xx-mci",
-	.id		= -1,
-	.dev		= {
-		.dma_mask = &pxamci_dmamask,
-		.coherent_dma_mask = 0xffffffff,
-	},
-	.num_resources	= ARRAY_SIZE(pxamci_resources),
-	.resource	= pxamci_resources,
-};
-
-void __init pxa_set_mci_info(struct pxamci_platform_data *info)
-{
-	pxa_register_device(&pxa_device_mci, info);
-}
-
-
-static struct pxa2xx_udc_mach_info pxa_udc_info;
-
-void __init pxa_set_udc_info(struct pxa2xx_udc_mach_info *info)
-{
-	memcpy(&pxa_udc_info, info, sizeof *info);
-}
-
-static struct resource pxa2xx_udc_resources[] = {
-	[0] = {
-		.start	= 0x40600000,
-		.end	= 0x4060ffff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_USB,
-		.end	= IRQ_USB,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static u64 udc_dma_mask = ~(u32)0;
-
-struct platform_device pxa_device_udc = {
-	.name		= "pxa2xx-udc",
-	.id		= -1,
-	.resource	= pxa2xx_udc_resources,
-	.num_resources	= ARRAY_SIZE(pxa2xx_udc_resources),
-	.dev		=  {
-		.platform_data	= &pxa_udc_info,
-		.dma_mask	= &udc_dma_mask,
-	}
-};
-
-static struct resource pxafb_resources[] = {
-	[0] = {
-		.start	= 0x44000000,
-		.end	= 0x4400ffff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_LCD,
-		.end	= IRQ_LCD,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static u64 fb_dma_mask = ~(u64)0;
-
-struct platform_device pxa_device_fb = {
-	.name		= "pxa2xx-fb",
-	.id		= -1,
-	.dev		= {
-		.dma_mask	= &fb_dma_mask,
-		.coherent_dma_mask = 0xffffffff,
-	},
-	.num_resources	= ARRAY_SIZE(pxafb_resources),
-	.resource	= pxafb_resources,
-};
-
-void __init set_pxa_fb_info(struct pxafb_mach_info *info)
-{
-	pxa_register_device(&pxa_device_fb, info);
-}
-
-void __init set_pxa_fb_parent(struct device *parent_dev)
-{
-	pxa_device_fb.dev.parent = parent_dev;
-}
-
-static struct resource pxa_resource_ffuart[] = {
-	{
-		.start	= __PREG(FFUART),
-		.end	= __PREG(FFUART) + 35,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start	= IRQ_FFUART,
-		.end	= IRQ_FFUART,
-		.flags	= IORESOURCE_IRQ,
-	}
-};
-
-struct platform_device pxa_device_ffuart= {
-	.name		= "pxa2xx-uart",
-	.id		= 0,
-	.resource	= pxa_resource_ffuart,
-	.num_resources	= ARRAY_SIZE(pxa_resource_ffuart),
-};
-
-static struct resource pxa_resource_btuart[] = {
-	{
-		.start	= __PREG(BTUART),
-		.end	= __PREG(BTUART) + 35,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start	= IRQ_BTUART,
-		.end	= IRQ_BTUART,
-		.flags	= IORESOURCE_IRQ,
-	}
-};
-
-struct platform_device pxa_device_btuart = {
-	.name		= "pxa2xx-uart",
-	.id		= 1,
-	.resource	= pxa_resource_btuart,
-	.num_resources	= ARRAY_SIZE(pxa_resource_btuart),
-};
-
-static struct resource pxa_resource_stuart[] = {
-	{
-		.start	= __PREG(STUART),
-		.end	= __PREG(STUART) + 35,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start	= IRQ_STUART,
-		.end	= IRQ_STUART,
-		.flags	= IORESOURCE_IRQ,
-	}
-};
-
-struct platform_device pxa_device_stuart = {
-	.name		= "pxa2xx-uart",
-	.id		= 2,
-	.resource	= pxa_resource_stuart,
-	.num_resources	= ARRAY_SIZE(pxa_resource_stuart),
-};
-
-static struct resource pxa_resource_hwuart[] = {
-	{
-		.start	= __PREG(HWUART),
-		.end	= __PREG(HWUART) + 47,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start	= IRQ_HWUART,
-		.end	= IRQ_HWUART,
-		.flags	= IORESOURCE_IRQ,
-	}
-};
-
-struct platform_device pxa_device_hwuart = {
-	.name		= "pxa2xx-uart",
-	.id		= 3,
-	.resource	= pxa_resource_hwuart,
-	.num_resources	= ARRAY_SIZE(pxa_resource_hwuart),
-};
-
-static struct resource pxai2c_resources[] = {
-	{
-		.start	= 0x40301680,
-		.end	= 0x403016a3,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start	= IRQ_I2C,
-		.end	= IRQ_I2C,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-struct platform_device pxa_device_i2c = {
-	.name		= "pxa2xx-i2c",
-	.id		= 0,
-	.resource	= pxai2c_resources,
-	.num_resources	= ARRAY_SIZE(pxai2c_resources),
-};
-
-void __init pxa_set_i2c_info(struct i2c_pxa_platform_data *info)
-{
-	pxa_register_device(&pxa_device_i2c, info);
-}
-
-static struct resource pxai2s_resources[] = {
-	{
-		.start	= 0x40400000,
-		.end	= 0x40400083,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start	= IRQ_I2S,
-		.end	= IRQ_I2S,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-struct platform_device pxa_device_i2s = {
-	.name		= "pxa2xx-i2s",
-	.id		= -1,
-	.resource	= pxai2s_resources,
-	.num_resources	= ARRAY_SIZE(pxai2s_resources),
-};
-
-static u64 pxaficp_dmamask = ~(u32)0;
-
-struct platform_device pxa_device_ficp = {
-	.name		= "pxa2xx-ir",
-	.id		= -1,
-	.dev		= {
-		.dma_mask = &pxaficp_dmamask,
-		.coherent_dma_mask = 0xffffffff,
-	},
-};
-
-void __init pxa_set_ficp_info(struct pxaficp_platform_data *info)
-{
-	pxa_register_device(&pxa_device_ficp, info);
-}
-
-struct platform_device pxa_device_rtc = {
-	.name		= "sa1100-rtc",
-	.id		= -1,
-};
-
-#ifdef CONFIG_PXA25x
-
-static u64 pxa25x_ssp_dma_mask = DMA_BIT_MASK(32);
-
-static struct resource pxa25x_resource_ssp[] = {
-	[0] = {
-		.start	= 0x41000000,
-		.end	= 0x4100001f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_SSP,
-		.end	= IRQ_SSP,
-		.flags	= IORESOURCE_IRQ,
-	},
-	[2] = {
-		/* DRCMR for RX */
-		.start	= 13,
-		.end	= 13,
-		.flags	= IORESOURCE_DMA,
-	},
-	[3] = {
-		/* DRCMR for TX */
-		.start	= 14,
-		.end	= 14,
-		.flags	= IORESOURCE_DMA,
-	},
-};
-
-struct platform_device pxa25x_device_ssp = {
-	.name		= "pxa25x-ssp",
-	.id		= 0,
-	.dev		= {
-		.dma_mask = &pxa25x_ssp_dma_mask,
-		.coherent_dma_mask = DMA_BIT_MASK(32),
-	},
-	.resource	= pxa25x_resource_ssp,
-	.num_resources	= ARRAY_SIZE(pxa25x_resource_ssp),
-};
-
-static u64 pxa25x_nssp_dma_mask = DMA_BIT_MASK(32);
-
-static struct resource pxa25x_resource_nssp[] = {
-	[0] = {
-		.start	= 0x41400000,
-		.end	= 0x4140002f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_NSSP,
-		.end	= IRQ_NSSP,
-		.flags	= IORESOURCE_IRQ,
-	},
-	[2] = {
-		/* DRCMR for RX */
-		.start	= 15,
-		.end	= 15,
-		.flags	= IORESOURCE_DMA,
-	},
-	[3] = {
-		/* DRCMR for TX */
-		.start	= 16,
-		.end	= 16,
-		.flags	= IORESOURCE_DMA,
-	},
-};
-
-struct platform_device pxa25x_device_nssp = {
-	.name		= "pxa25x-nssp",
-	.id		= 1,
-	.dev		= {
-		.dma_mask = &pxa25x_nssp_dma_mask,
-		.coherent_dma_mask = DMA_BIT_MASK(32),
-	},
-	.resource	= pxa25x_resource_nssp,
-	.num_resources	= ARRAY_SIZE(pxa25x_resource_nssp),
-};
-
-static u64 pxa25x_assp_dma_mask = DMA_BIT_MASK(32);
-
-static struct resource pxa25x_resource_assp[] = {
-	[0] = {
-		.start	= 0x41500000,
-		.end	= 0x4150002f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_ASSP,
-		.end	= IRQ_ASSP,
-		.flags	= IORESOURCE_IRQ,
-	},
-	[2] = {
-		/* DRCMR for RX */
-		.start	= 23,
-		.end	= 23,
-		.flags	= IORESOURCE_DMA,
-	},
-	[3] = {
-		/* DRCMR for TX */
-		.start	= 24,
-		.end	= 24,
-		.flags	= IORESOURCE_DMA,
-	},
-};
-
-struct platform_device pxa25x_device_assp = {
-	/* ASSP is basically equivalent to NSSP */
-	.name		= "pxa25x-nssp",
-	.id		= 2,
-	.dev		= {
-		.dma_mask = &pxa25x_assp_dma_mask,
-		.coherent_dma_mask = DMA_BIT_MASK(32),
-	},
-	.resource	= pxa25x_resource_assp,
-	.num_resources	= ARRAY_SIZE(pxa25x_resource_assp),
-};
-#endif /* CONFIG_PXA25x */
-
-#if defined(CONFIG_PXA27x) || defined(CONFIG_PXA3xx)
-
-static u64 pxa27x_ssp1_dma_mask = DMA_BIT_MASK(32);
-
-static struct resource pxa27x_resource_ssp1[] = {
-	[0] = {
-		.start	= 0x41000000,
-		.end	= 0x4100003f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_SSP,
-		.end	= IRQ_SSP,
-		.flags	= IORESOURCE_IRQ,
-	},
-	[2] = {
-		/* DRCMR for RX */
-		.start	= 13,
-		.end	= 13,
-		.flags	= IORESOURCE_DMA,
-	},
-	[3] = {
-		/* DRCMR for TX */
-		.start	= 14,
-		.end	= 14,
-		.flags	= IORESOURCE_DMA,
-	},
-};
-
-struct platform_device pxa27x_device_ssp1 = {
-	.name		= "pxa27x-ssp",
-	.id		= 0,
-	.dev		= {
-		.dma_mask = &pxa27x_ssp1_dma_mask,
-		.coherent_dma_mask = DMA_BIT_MASK(32),
-	},
-	.resource	= pxa27x_resource_ssp1,
-	.num_resources	= ARRAY_SIZE(pxa27x_resource_ssp1),
-};
-
-static u64 pxa27x_ssp2_dma_mask = DMA_BIT_MASK(32);
-
-static struct resource pxa27x_resource_ssp2[] = {
-	[0] = {
-		.start	= 0x41700000,
-		.end	= 0x4170003f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_SSP2,
-		.end	= IRQ_SSP2,
-		.flags	= IORESOURCE_IRQ,
-	},
-	[2] = {
-		/* DRCMR for RX */
-		.start	= 15,
-		.end	= 15,
-		.flags	= IORESOURCE_DMA,
-	},
-	[3] = {
-		/* DRCMR for TX */
-		.start	= 16,
-		.end	= 16,
-		.flags	= IORESOURCE_DMA,
-	},
-};
-
-struct platform_device pxa27x_device_ssp2 = {
-	.name		= "pxa27x-ssp",
-	.id		= 1,
-	.dev		= {
-		.dma_mask = &pxa27x_ssp2_dma_mask,
-		.coherent_dma_mask = DMA_BIT_MASK(32),
-	},
-	.resource	= pxa27x_resource_ssp2,
-	.num_resources	= ARRAY_SIZE(pxa27x_resource_ssp2),
-};
-
-static u64 pxa27x_ssp3_dma_mask = DMA_BIT_MASK(32);
-
-static struct resource pxa27x_resource_ssp3[] = {
-	[0] = {
-		.start	= 0x41900000,
-		.end	= 0x4190003f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_SSP3,
-		.end	= IRQ_SSP3,
-		.flags	= IORESOURCE_IRQ,
-	},
-	[2] = {
-		/* DRCMR for RX */
-		.start	= 66,
-		.end	= 66,
-		.flags	= IORESOURCE_DMA,
-	},
-	[3] = {
-		/* DRCMR for TX */
-		.start	= 67,
-		.end	= 67,
-		.flags	= IORESOURCE_DMA,
-	},
-};
-
-struct platform_device pxa27x_device_ssp3 = {
-	.name		= "pxa27x-ssp",
-	.id		= 2,
-	.dev		= {
-		.dma_mask = &pxa27x_ssp3_dma_mask,
-		.coherent_dma_mask = DMA_BIT_MASK(32),
-	},
-	.resource	= pxa27x_resource_ssp3,
-	.num_resources	= ARRAY_SIZE(pxa27x_resource_ssp3),
-};
-#endif /* CONFIG_PXA27x || CONFIG_PXA3xx */
-
-#ifdef CONFIG_PXA3xx
-static u64 pxa3xx_ssp4_dma_mask = DMA_BIT_MASK(32);
-
-static struct resource pxa3xx_resource_ssp4[] = {
-	[0] = {
-		.start	= 0x41a00000,
-		.end	= 0x41a0003f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_SSP4,
-		.end	= IRQ_SSP4,
-		.flags	= IORESOURCE_IRQ,
-	},
-	[2] = {
-		/* DRCMR for RX */
-		.start	= 2,
-		.end	= 2,
-		.flags	= IORESOURCE_DMA,
-	},
-	[3] = {
-		/* DRCMR for TX */
-		.start	= 3,
-		.end	= 3,
-		.flags	= IORESOURCE_DMA,
-	},
-};
-
-struct platform_device pxa3xx_device_ssp4 = {
-	/* PXA3xx SSP is basically equivalent to PXA27x */
-	.name		= "pxa27x-ssp",
-	.id		= 3,
-	.dev		= {
-		.dma_mask = &pxa3xx_ssp4_dma_mask,
-		.coherent_dma_mask = DMA_BIT_MASK(32),
-	},
-	.resource	= pxa3xx_resource_ssp4,
-	.num_resources	= ARRAY_SIZE(pxa3xx_resource_ssp4),
-};
-#endif /* CONFIG_PXA3xx */

commit 9a788c6b78802b4a378be3f0d4c2da30da811620
Author: Bridge Wu <bridge.wu@marvell.com>
Date:   Fri Dec 14 10:40:25 2007 +0100

    [ARM] 4711/1: pxa: mmc: move DMA specific code to platform layer
    
    This patch is to move pxamci DMA specific code to corresponding
    platform layer because using DRCMRRXMMC/DRCMRTXMMC in pxamci.c makes
    the driver code dedicated to platform which is not extensible.
    
    It is applicable to all pxa platforms.
    
    Signed-off-by: Bridge Wu <bridge.wu@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 8bb70e70131e..a8d88704c8d4 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -259,6 +259,16 @@ static struct resource pxamci_resources[] = {
 		.end	= IRQ_MMC,
 		.flags	= IORESOURCE_IRQ,
 	},
+	[2] = {
+		.start	= 21,
+		.end	= 21,
+		.flags	= IORESOURCE_DMA,
+	},
+	[3] = {
+		.start	= 22,
+		.end	= 22,
+		.flags	= IORESOURCE_DMA,
+	},
 };
 
 static u64 pxamci_dmamask = 0xffffffffUL;

commit d2b82dded8c45daeaad332459222034a3fabd227
Author: eric miao <eric.miao@marvell.com>
Date:   Mon Dec 10 17:51:29 2007 +0800

    [ARM] pxa: define SSP platform devices for pxa2xx/pxa3xx
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 3d863c919e8b..8bb70e70131e 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -24,6 +24,7 @@
 #include <linux/ioport.h>
 #include <linux/pm.h>
 #include <linux/string.h>
+#include <linux/dma-mapping.h>
 
 #include <asm/hardware.h>
 #include <asm/irq.h>
@@ -487,3 +488,279 @@ struct platform_device pxa_device_rtc = {
 	.name		= "sa1100-rtc",
 	.id		= -1,
 };
+
+#ifdef CONFIG_PXA25x
+
+static u64 pxa25x_ssp_dma_mask = DMA_BIT_MASK(32);
+
+static struct resource pxa25x_resource_ssp[] = {
+	[0] = {
+		.start	= 0x41000000,
+		.end	= 0x4100001f,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_SSP,
+		.end	= IRQ_SSP,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		/* DRCMR for RX */
+		.start	= 13,
+		.end	= 13,
+		.flags	= IORESOURCE_DMA,
+	},
+	[3] = {
+		/* DRCMR for TX */
+		.start	= 14,
+		.end	= 14,
+		.flags	= IORESOURCE_DMA,
+	},
+};
+
+struct platform_device pxa25x_device_ssp = {
+	.name		= "pxa25x-ssp",
+	.id		= 0,
+	.dev		= {
+		.dma_mask = &pxa25x_ssp_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.resource	= pxa25x_resource_ssp,
+	.num_resources	= ARRAY_SIZE(pxa25x_resource_ssp),
+};
+
+static u64 pxa25x_nssp_dma_mask = DMA_BIT_MASK(32);
+
+static struct resource pxa25x_resource_nssp[] = {
+	[0] = {
+		.start	= 0x41400000,
+		.end	= 0x4140002f,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_NSSP,
+		.end	= IRQ_NSSP,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		/* DRCMR for RX */
+		.start	= 15,
+		.end	= 15,
+		.flags	= IORESOURCE_DMA,
+	},
+	[3] = {
+		/* DRCMR for TX */
+		.start	= 16,
+		.end	= 16,
+		.flags	= IORESOURCE_DMA,
+	},
+};
+
+struct platform_device pxa25x_device_nssp = {
+	.name		= "pxa25x-nssp",
+	.id		= 1,
+	.dev		= {
+		.dma_mask = &pxa25x_nssp_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.resource	= pxa25x_resource_nssp,
+	.num_resources	= ARRAY_SIZE(pxa25x_resource_nssp),
+};
+
+static u64 pxa25x_assp_dma_mask = DMA_BIT_MASK(32);
+
+static struct resource pxa25x_resource_assp[] = {
+	[0] = {
+		.start	= 0x41500000,
+		.end	= 0x4150002f,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_ASSP,
+		.end	= IRQ_ASSP,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		/* DRCMR for RX */
+		.start	= 23,
+		.end	= 23,
+		.flags	= IORESOURCE_DMA,
+	},
+	[3] = {
+		/* DRCMR for TX */
+		.start	= 24,
+		.end	= 24,
+		.flags	= IORESOURCE_DMA,
+	},
+};
+
+struct platform_device pxa25x_device_assp = {
+	/* ASSP is basically equivalent to NSSP */
+	.name		= "pxa25x-nssp",
+	.id		= 2,
+	.dev		= {
+		.dma_mask = &pxa25x_assp_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.resource	= pxa25x_resource_assp,
+	.num_resources	= ARRAY_SIZE(pxa25x_resource_assp),
+};
+#endif /* CONFIG_PXA25x */
+
+#if defined(CONFIG_PXA27x) || defined(CONFIG_PXA3xx)
+
+static u64 pxa27x_ssp1_dma_mask = DMA_BIT_MASK(32);
+
+static struct resource pxa27x_resource_ssp1[] = {
+	[0] = {
+		.start	= 0x41000000,
+		.end	= 0x4100003f,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_SSP,
+		.end	= IRQ_SSP,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		/* DRCMR for RX */
+		.start	= 13,
+		.end	= 13,
+		.flags	= IORESOURCE_DMA,
+	},
+	[3] = {
+		/* DRCMR for TX */
+		.start	= 14,
+		.end	= 14,
+		.flags	= IORESOURCE_DMA,
+	},
+};
+
+struct platform_device pxa27x_device_ssp1 = {
+	.name		= "pxa27x-ssp",
+	.id		= 0,
+	.dev		= {
+		.dma_mask = &pxa27x_ssp1_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.resource	= pxa27x_resource_ssp1,
+	.num_resources	= ARRAY_SIZE(pxa27x_resource_ssp1),
+};
+
+static u64 pxa27x_ssp2_dma_mask = DMA_BIT_MASK(32);
+
+static struct resource pxa27x_resource_ssp2[] = {
+	[0] = {
+		.start	= 0x41700000,
+		.end	= 0x4170003f,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_SSP2,
+		.end	= IRQ_SSP2,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		/* DRCMR for RX */
+		.start	= 15,
+		.end	= 15,
+		.flags	= IORESOURCE_DMA,
+	},
+	[3] = {
+		/* DRCMR for TX */
+		.start	= 16,
+		.end	= 16,
+		.flags	= IORESOURCE_DMA,
+	},
+};
+
+struct platform_device pxa27x_device_ssp2 = {
+	.name		= "pxa27x-ssp",
+	.id		= 1,
+	.dev		= {
+		.dma_mask = &pxa27x_ssp2_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.resource	= pxa27x_resource_ssp2,
+	.num_resources	= ARRAY_SIZE(pxa27x_resource_ssp2),
+};
+
+static u64 pxa27x_ssp3_dma_mask = DMA_BIT_MASK(32);
+
+static struct resource pxa27x_resource_ssp3[] = {
+	[0] = {
+		.start	= 0x41900000,
+		.end	= 0x4190003f,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_SSP3,
+		.end	= IRQ_SSP3,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		/* DRCMR for RX */
+		.start	= 66,
+		.end	= 66,
+		.flags	= IORESOURCE_DMA,
+	},
+	[3] = {
+		/* DRCMR for TX */
+		.start	= 67,
+		.end	= 67,
+		.flags	= IORESOURCE_DMA,
+	},
+};
+
+struct platform_device pxa27x_device_ssp3 = {
+	.name		= "pxa27x-ssp",
+	.id		= 2,
+	.dev		= {
+		.dma_mask = &pxa27x_ssp3_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.resource	= pxa27x_resource_ssp3,
+	.num_resources	= ARRAY_SIZE(pxa27x_resource_ssp3),
+};
+#endif /* CONFIG_PXA27x || CONFIG_PXA3xx */
+
+#ifdef CONFIG_PXA3xx
+static u64 pxa3xx_ssp4_dma_mask = DMA_BIT_MASK(32);
+
+static struct resource pxa3xx_resource_ssp4[] = {
+	[0] = {
+		.start	= 0x41a00000,
+		.end	= 0x41a0003f,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_SSP4,
+		.end	= IRQ_SSP4,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		/* DRCMR for RX */
+		.start	= 2,
+		.end	= 2,
+		.flags	= IORESOURCE_DMA,
+	},
+	[3] = {
+		/* DRCMR for TX */
+		.start	= 3,
+		.end	= 3,
+		.flags	= IORESOURCE_DMA,
+	},
+};
+
+struct platform_device pxa3xx_device_ssp4 = {
+	/* PXA3xx SSP is basically equivalent to PXA27x */
+	.name		= "pxa27x-ssp",
+	.id		= 3,
+	.dev		= {
+		.dma_mask = &pxa3xx_ssp4_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.resource	= pxa3xx_resource_ssp4,
+	.num_resources	= ARRAY_SIZE(pxa3xx_resource_ssp4),
+};
+#endif /* CONFIG_PXA3xx */

commit 03f5b2cee6cabd0400b9f89956c373a0b5d3802a
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Nov 8 11:17:19 2007 +0000

    [ARM] pxa: avoid always registering MMC, I2C, IrDA and framebuffer devices
    
    Only register the MMC, framebuffer, I2C and FICP devices when the
    platform supplies the necessary platform data structures for the
    devices.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 1c34946ee16e..3d863c919e8b 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -235,6 +235,18 @@ void __init pxa_map_io(void)
 }
 
 
+void __init pxa_register_device(struct platform_device *dev, void *data)
+{
+	int ret;
+
+	dev->dev.platform_data = data;
+
+	ret = platform_device_register(dev);
+	if (ret)
+		dev_err(&dev->dev, "unable to register device: %d\n", ret);
+}
+
+
 static struct resource pxamci_resources[] = {
 	[0] = {
 		.start	= 0x41100000,
@@ -263,7 +275,7 @@ struct platform_device pxa_device_mci = {
 
 void __init pxa_set_mci_info(struct pxamci_platform_data *info)
 {
-	pxa_device_mci.dev.platform_data = info;
+	pxa_register_device(&pxa_device_mci, info);
 }
 
 
@@ -328,7 +340,7 @@ struct platform_device pxa_device_fb = {
 
 void __init set_pxa_fb_info(struct pxafb_mach_info *info)
 {
-	pxa_device_fb.dev.platform_data = info;
+	pxa_register_device(&pxa_device_fb, info);
 }
 
 void __init set_pxa_fb_parent(struct device *parent_dev)
@@ -433,7 +445,7 @@ struct platform_device pxa_device_i2c = {
 
 void __init pxa_set_i2c_info(struct i2c_pxa_platform_data *info)
 {
-	pxa_device_i2c.dev.platform_data = info;
+	pxa_register_device(&pxa_device_i2c, info);
 }
 
 static struct resource pxai2s_resources[] = {
@@ -468,7 +480,7 @@ struct platform_device pxa_device_ficp = {
 
 void __init pxa_set_ficp_info(struct pxaficp_platform_data *info)
 {
-	pxa_device_ficp.dev.platform_data = info;
+	pxa_register_device(&pxa_device_ficp, info);
 }
 
 struct platform_device pxa_device_rtc = {

commit 3e0cc7ee045fb53e8215fed7442455c0cee0ee93
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Oct 2 14:28:01 2007 +0100

    [ARM] pxa: Avoid pxa_gpio_mode() in gpio_direction_{in,out}put()
    
    pxa_gpio_mode() is a universal call that fiddles with the GAFR
    (gpio alternate function register.)  GAFR does not exist on PXA3
    CPUs, but instead the alternate functions are controlled via the
    MFP support code.
    
    Platforms are expected to configure the MFP according to their
    needs in their platform support code rather than drivers.  We
    extend this idea to the GAFR, and make the gpio_direction_*()
    functions purely operate on the GPIO level.
    
    This means platform support code is entirely responsible for
    configuring the GPIOs alternate functions on all PXA CPU types.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 2263a84844a1..1c34946ee16e 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -105,6 +105,44 @@ int pxa_gpio_mode(int gpio_mode)
 
 EXPORT_SYMBOL(pxa_gpio_mode);
 
+int gpio_direction_input(unsigned gpio)
+{
+	unsigned long flags;
+	u32 mask;
+
+	if (gpio > pxa_last_gpio)
+		return -EINVAL;
+
+	mask = GPIO_bit(gpio);
+	local_irq_save(flags);
+	GPDR(gpio) &= ~mask;
+	local_irq_restore(flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_direction_input);
+
+int gpio_direction_output(unsigned gpio, int value)
+{
+	unsigned long flags;
+	u32 mask;
+
+	if (gpio > pxa_last_gpio)
+		return -EINVAL;
+
+	mask = GPIO_bit(gpio);
+	local_irq_save(flags);
+	if (value)
+		GPSR(gpio) = mask;
+	else
+		GPCR(gpio) = mask;
+	GPDR(gpio) |= mask;
+	local_irq_restore(flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_direction_output);
+
 /*
  * Return GPIO level
  */

commit 2c8086a5d073e8e72122a5b84febde236a39845b
Author: eric miao <eric.y.miao@gmail.com>
Date:   Tue Sep 11 19:13:17 2007 -0700

    [ARM] pxa: PXA3xx base support
    
    Signed-off-by: eric miao <eric.y.miao@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index eed95eaf58cd..2263a84844a1 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -51,8 +51,10 @@ unsigned int get_clk_frequency_khz(int info)
 {
 	if (cpu_is_pxa21x() || cpu_is_pxa25x())
 		return pxa25x_get_clk_frequency_khz(info);
-	else
+	else if (cpu_is_pxa27x())
 		return pxa27x_get_clk_frequency_khz(info);
+	else
+		return pxa3xx_get_clk_frequency_khz(info);
 }
 EXPORT_SYMBOL(get_clk_frequency_khz);
 
@@ -63,8 +65,10 @@ unsigned int get_memclk_frequency_10khz(void)
 {
 	if (cpu_is_pxa21x() || cpu_is_pxa25x())
 		return pxa25x_get_memclk_frequency_10khz();
-	else
+	else if (cpu_is_pxa27x())
 		return pxa27x_get_memclk_frequency_10khz();
+	else
+		return pxa3xx_get_memclk_frequency_10khz();
 }
 EXPORT_SYMBOL(get_memclk_frequency_10khz);
 

commit 30f0b40844e5add7ad879e2f5939ff498f72f3e6
Author: eric miao <eric.y.miao@gmail.com>
Date:   Wed Aug 29 10:18:47 2007 +0100

    [ARM] 4559/1: pxa: make PXA_LAST_GPIO a run-time variable
    
    This definition produces processor specific code in generic function
    pxa_gpio_mode(), thus creating inconsistencies for support of pxa25x
    and pxa27x in a single zImage.
    
    As David Brownell suggests, make it a run-time variable and initialize
    at run-time according to the number of GPIOs on the processor. For now
    the initialization happens in pxa_init_irq_gpio(),  since there is
    already a parameter for that, besides, this is and MUST be earlier
    than any subsequent calls to pxa_gpio_mode().
    
    Signed-off-by: eric miao <eric.y.miao@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 1c5413fc6e74..eed95eaf58cd 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -71,6 +71,7 @@ EXPORT_SYMBOL(get_memclk_frequency_10khz);
 /*
  * Handy function to set GPIO alternate functions
  */
+int pxa_last_gpio;
 
 int pxa_gpio_mode(int gpio_mode)
 {
@@ -79,7 +80,7 @@ int pxa_gpio_mode(int gpio_mode)
 	int fn = (gpio_mode & GPIO_MD_MASK_FN) >> 8;
 	int gafr;
 
-	if (gpio > PXA_LAST_GPIO)
+	if (gpio > pxa_last_gpio)
 		return -EINVAL;
 
 	local_irq_save(flags);

commit a7073b8b47651ce2ed27564ed8395eff81120c58
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Sep 19 09:33:55 2007 +0100

    [ARM] pxa: mark pxa_set_cken deprecated
    
    Allow the generic clock support code to fiddle with the CKEN register
    and mark pxa_set_cken() deprecated.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 2f0cc1c4995a..1c5413fc6e74 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -123,7 +123,7 @@ EXPORT_SYMBOL(pxa_gpio_set_value);
 /*
  * Routine to safely enable or disable a clock in the CKEN
  */
-void pxa_set_cken(int clock, int enable)
+void __pxa_set_cken(int clock, int enable)
 {
 	unsigned long flags;
 	local_irq_save(flags);
@@ -136,7 +136,7 @@ void pxa_set_cken(int clock, int enable)
 	local_irq_restore(flags);
 }
 
-EXPORT_SYMBOL(pxa_set_cken);
+EXPORT_SYMBOL(__pxa_set_cken);
 
 /*
  * Intel PXA2xx internal register mapping.

commit a88a447d44648f1dfba4c40b3f4b6f75597150ed
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Aug 20 10:34:37 2007 +0100

    [ARM] pxa: remove get_lcdclk_frequency_10khz()
    
    get_lcdclk_frequency_10khz() is now redundant, remove it.  Hide
    pxa27x_get_lcdclk_frequency_10khz() from public view.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index ac2b1fc5bda9..2f0cc1c4995a 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -68,18 +68,6 @@ unsigned int get_memclk_frequency_10khz(void)
 }
 EXPORT_SYMBOL(get_memclk_frequency_10khz);
 
-/*
- * Return the current LCD clock frequency in units of 10kHz
- */
-unsigned int get_lcdclk_frequency_10khz(void)
-{
-	if (cpu_is_pxa21x() || cpu_is_pxa25x())
-		return pxa25x_get_memclk_frequency_10khz();
-	else
-		return pxa27x_get_lcdclk_frequency_10khz();
-}
-EXPORT_SYMBOL(get_lcdclk_frequency_10khz);
-
 /*
  * Handy function to set GPIO alternate functions
  */

commit 15a4033354c68eb75e417ab60771f36212610820
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Aug 20 10:07:44 2007 +0100

    [ARM] pxa: fix naming of memory/lcd/core clock functions
    
    Rename pxa25x and pxa27x memory/lcd/core clock functions, and
    select the correct version at run time.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 98df63898d1d..ac2b1fc5bda9 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -42,6 +42,44 @@
 #include "devices.h"
 #include "generic.h"
 
+/*
+ * Get the clock frequency as reflected by CCCR and the turbo flag.
+ * We assume these values have been applied via a fcs.
+ * If info is not 0 we also display the current settings.
+ */
+unsigned int get_clk_frequency_khz(int info)
+{
+	if (cpu_is_pxa21x() || cpu_is_pxa25x())
+		return pxa25x_get_clk_frequency_khz(info);
+	else
+		return pxa27x_get_clk_frequency_khz(info);
+}
+EXPORT_SYMBOL(get_clk_frequency_khz);
+
+/*
+ * Return the current memory clock frequency in units of 10kHz
+ */
+unsigned int get_memclk_frequency_10khz(void)
+{
+	if (cpu_is_pxa21x() || cpu_is_pxa25x())
+		return pxa25x_get_memclk_frequency_10khz();
+	else
+		return pxa27x_get_memclk_frequency_10khz();
+}
+EXPORT_SYMBOL(get_memclk_frequency_10khz);
+
+/*
+ * Return the current LCD clock frequency in units of 10kHz
+ */
+unsigned int get_lcdclk_frequency_10khz(void)
+{
+	if (cpu_is_pxa21x() || cpu_is_pxa25x())
+		return pxa25x_get_memclk_frequency_10khz();
+	else
+		return pxa27x_get_lcdclk_frequency_10khz();
+}
+EXPORT_SYMBOL(get_lcdclk_frequency_10khz);
+
 /*
  * Handy function to set GPIO alternate functions
  */

commit e259a3aecbfb61981175ddc7fc02dd180da7d73e
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Aug 20 09:47:41 2007 +0100

    [ARM] pxa: convert PXA serial drivers to use platform resources
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 9d6a2c00d762..98df63898d1d 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -267,21 +267,80 @@ void __init set_pxa_fb_parent(struct device *parent_dev)
 	pxa_device_fb.dev.parent = parent_dev;
 }
 
+static struct resource pxa_resource_ffuart[] = {
+	{
+		.start	= __PREG(FFUART),
+		.end	= __PREG(FFUART) + 35,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_FFUART,
+		.end	= IRQ_FFUART,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
 struct platform_device pxa_device_ffuart= {
 	.name		= "pxa2xx-uart",
 	.id		= 0,
+	.resource	= pxa_resource_ffuart,
+	.num_resources	= ARRAY_SIZE(pxa_resource_ffuart),
+};
+
+static struct resource pxa_resource_btuart[] = {
+	{
+		.start	= __PREG(BTUART),
+		.end	= __PREG(BTUART) + 35,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_BTUART,
+		.end	= IRQ_BTUART,
+		.flags	= IORESOURCE_IRQ,
+	}
 };
+
 struct platform_device pxa_device_btuart = {
 	.name		= "pxa2xx-uart",
 	.id		= 1,
+	.resource	= pxa_resource_btuart,
+	.num_resources	= ARRAY_SIZE(pxa_resource_btuart),
 };
+
+static struct resource pxa_resource_stuart[] = {
+	{
+		.start	= __PREG(STUART),
+		.end	= __PREG(STUART) + 35,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_STUART,
+		.end	= IRQ_STUART,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
 struct platform_device pxa_device_stuart = {
 	.name		= "pxa2xx-uart",
 	.id		= 2,
+	.resource	= pxa_resource_stuart,
+	.num_resources	= ARRAY_SIZE(pxa_resource_stuart),
 };
+
+static struct resource pxa_resource_hwuart[] = {
+	{
+		.start	= __PREG(HWUART),
+		.end	= __PREG(HWUART) + 47,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_HWUART,
+		.end	= IRQ_HWUART,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
 struct platform_device pxa_device_hwuart = {
 	.name		= "pxa2xx-uart",
 	.id		= 3,
+	.resource	= pxa_resource_hwuart,
+	.num_resources	= ARRAY_SIZE(pxa_resource_hwuart),
 };
 
 static struct resource pxai2c_resources[] = {

commit 6c3a158316598bfb165b8c83b168fa413d5ae2d8
Author: Nicolas Pitre <nico@cam.org>
Date:   Fri Aug 17 16:55:22 2007 +0100

    [ARM] 4550/1: sched_clock on PXA should cope with run time clock rate selection
    
    The previous implementation was relying on compile time optimizations
    based on a constant clock rate.  However, support for different PXA
    flavors in the same kernel binary requires that the clock be selected at
    run time, so here it is.
    
    Let's move this code to a more appropriate location while at it.
    
    Signed-off-by: Nicolas Pitre <npitre@mvista.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 5510f6fdce55..9d6a2c00d762 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -25,10 +25,6 @@
 #include <linux/pm.h>
 #include <linux/string.h>
 
-#include <linux/sched.h>
-#include <asm/cnt32_to_63.h>
-#include <asm/div64.h>
-
 #include <asm/hardware.h>
 #include <asm/irq.h>
 #include <asm/system.h>
@@ -46,64 +42,6 @@
 #include "devices.h"
 #include "generic.h"
 
-/*
- * This is the PXA2xx sched_clock implementation. This has a resolution
- * of at least 308ns and a maximum value that depends on the value of
- * CLOCK_TICK_RATE.
- *
- * The return value is guaranteed to be monotonic in that range as
- * long as there is always less than 582 seconds between successive
- * calls to this function.
- */
-unsigned long long sched_clock(void)
-{
-	unsigned long long v = cnt32_to_63(OSCR);
-	/* Note: top bit ov v needs cleared unless multiplier is even. */
-
-#if	CLOCK_TICK_RATE == 3686400
-	/* 1E9 / 3686400 => 78125 / 288, max value = 32025597s (370 days). */
-	/* The <<1 is used to get rid of tick.hi top bit */
-	v *= 78125<<1;
-	do_div(v, 288<<1);
-#elif	CLOCK_TICK_RATE == 3250000
-	/* 1E9 / 3250000 => 4000 / 13, max value = 709490156s (8211 days) */
-	v *= 4000;
-	do_div(v, 13);
-#elif	CLOCK_TICK_RATE == 3249600
-	/* 1E9 / 3249600 => 625000 / 2031, max value = 4541295s (52 days) */
-	v *= 625000;
-	do_div(v, 2031);
-#else
-#warning "consider fixing sched_clock for your value of CLOCK_TICK_RATE"
-	/*
-	 * 96-bit math to perform tick * NSEC_PER_SEC / CLOCK_TICK_RATE for
-	 * any value of CLOCK_TICK_RATE. Max value is in the 80 thousand
-	 * years range and truncation to unsigned long long limits it to
-	 * sched_clock's max range of ~584 years.  This is nice but with
-	 * higher computation cost.
-	 */
-	{
-		union {
-			unsigned long long val;
-			struct { unsigned long lo, hi; };
-		} x;
-		unsigned long long y;
-
-		x.val = v;
-		x.hi &= 0x7fffffff;
-		y = (unsigned long long)x.lo * NSEC_PER_SEC;
-		x.lo = y;
-		y = (y >> 32) + (unsigned long long)x.hi * NSEC_PER_SEC;
-		x.hi = do_div(y, CLOCK_TICK_RATE);
-		do_div(x.val, CLOCK_TICK_RATE);
-		x.hi += y;
-		v = x.val;
-	}
-#endif
-
-	return v;
-}
-
 /*
  * Handy function to set GPIO alternate functions
  */

commit e09d02e123fb6944af23a0697369ebcfc15acf73
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Tue Jul 17 10:45:58 2007 +0100

    [ARM] 4480/1: pxa: change the pxa device naming scheme
    
    1. for common devices across all the pxa variants, the names
       are changed to be:
         "pxa_device_xxx"
    
    2. for pxa25x or pxa27x specific devices, the names are
       changed to be:
         "pxa25x_device_xxx", or
         "pxa27x_device_xxx"
    
    Signed-off-by: eric miao <eric.y.miao@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 296539b6359c..5510f6fdce55 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -243,7 +243,7 @@ static struct resource pxamci_resources[] = {
 
 static u64 pxamci_dmamask = 0xffffffffUL;
 
-struct platform_device pxamci_device = {
+struct platform_device pxa_device_mci = {
 	.name		= "pxa2xx-mci",
 	.id		= -1,
 	.dev		= {
@@ -256,7 +256,7 @@ struct platform_device pxamci_device = {
 
 void __init pxa_set_mci_info(struct pxamci_platform_data *info)
 {
-	pxamci_device.dev.platform_data = info;
+	pxa_device_mci.dev.platform_data = info;
 }
 
 
@@ -282,7 +282,7 @@ static struct resource pxa2xx_udc_resources[] = {
 
 static u64 udc_dma_mask = ~(u32)0;
 
-struct platform_device pxaudc_device = {
+struct platform_device pxa_device_udc = {
 	.name		= "pxa2xx-udc",
 	.id		= -1,
 	.resource	= pxa2xx_udc_resources,
@@ -308,7 +308,7 @@ static struct resource pxafb_resources[] = {
 
 static u64 fb_dma_mask = ~(u64)0;
 
-struct platform_device pxafb_device = {
+struct platform_device pxa_device_fb = {
 	.name		= "pxa2xx-fb",
 	.id		= -1,
 	.dev		= {
@@ -321,27 +321,27 @@ struct platform_device pxafb_device = {
 
 void __init set_pxa_fb_info(struct pxafb_mach_info *info)
 {
-	pxafb_device.dev.platform_data = info;
+	pxa_device_fb.dev.platform_data = info;
 }
 
 void __init set_pxa_fb_parent(struct device *parent_dev)
 {
-	pxafb_device.dev.parent = parent_dev;
+	pxa_device_fb.dev.parent = parent_dev;
 }
 
-struct platform_device ffuart_device = {
+struct platform_device pxa_device_ffuart= {
 	.name		= "pxa2xx-uart",
 	.id		= 0,
 };
-struct platform_device btuart_device = {
+struct platform_device pxa_device_btuart = {
 	.name		= "pxa2xx-uart",
 	.id		= 1,
 };
-struct platform_device stuart_device = {
+struct platform_device pxa_device_stuart = {
 	.name		= "pxa2xx-uart",
 	.id		= 2,
 };
-struct platform_device hwuart_device = {
+struct platform_device pxa_device_hwuart = {
 	.name		= "pxa2xx-uart",
 	.id		= 3,
 };
@@ -358,7 +358,7 @@ static struct resource pxai2c_resources[] = {
 	},
 };
 
-struct platform_device pxai2c_device = {
+struct platform_device pxa_device_i2c = {
 	.name		= "pxa2xx-i2c",
 	.id		= 0,
 	.resource	= pxai2c_resources,
@@ -367,7 +367,7 @@ struct platform_device pxai2c_device = {
 
 void __init pxa_set_i2c_info(struct i2c_pxa_platform_data *info)
 {
-	pxai2c_device.dev.platform_data = info;
+	pxa_device_i2c.dev.platform_data = info;
 }
 
 static struct resource pxai2s_resources[] = {
@@ -382,7 +382,7 @@ static struct resource pxai2s_resources[] = {
 	},
 };
 
-struct platform_device pxai2s_device = {
+struct platform_device pxa_device_i2s = {
 	.name		= "pxa2xx-i2s",
 	.id		= -1,
 	.resource	= pxai2s_resources,
@@ -391,7 +391,7 @@ struct platform_device pxai2s_device = {
 
 static u64 pxaficp_dmamask = ~(u32)0;
 
-struct platform_device pxaficp_device = {
+struct platform_device pxa_device_ficp = {
 	.name		= "pxa2xx-ir",
 	.id		= -1,
 	.dev		= {
@@ -402,10 +402,10 @@ struct platform_device pxaficp_device = {
 
 void __init pxa_set_ficp_info(struct pxaficp_platform_data *info)
 {
-	pxaficp_device.dev.platform_data = info;
+	pxa_device_ficp.dev.platform_data = info;
 }
 
-struct platform_device pxartc_device = {
+struct platform_device pxa_device_rtc = {
 	.name		= "sa1100-rtc",
 	.id		= -1,
 };

commit 46c41e62a1feb4ab2e941f33f06bbf8feab2d2cf
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue May 15 15:39:36 2007 +0100

    [ARM] pxa: move platform devices to separate header file
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index a496e498ef57..296539b6359c 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -43,6 +43,7 @@
 #include <asm/arch/irda.h>
 #include <asm/arch/i2c.h>
 
+#include "devices.h"
 #include "generic.h"
 
 /*

commit 34f3231f435dfb8e6c83271c63461fdd2901dc97
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue May 15 10:39:49 2007 +0100

    [ARM] pxa: move device registration into CPU-specific file
    
    This allows individual CPU support to determine which platform
    devices should be registered.  Also fix a copy-n-paste bug in
    the I2C power platform device entry.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 147b7c40d9f9..a496e498ef57 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -242,7 +242,7 @@ static struct resource pxamci_resources[] = {
 
 static u64 pxamci_dmamask = 0xffffffffUL;
 
-static struct platform_device pxamci_device = {
+struct platform_device pxamci_device = {
 	.name		= "pxa2xx-mci",
 	.id		= -1,
 	.dev		= {
@@ -281,7 +281,7 @@ static struct resource pxa2xx_udc_resources[] = {
 
 static u64 udc_dma_mask = ~(u32)0;
 
-static struct platform_device udc_device = {
+struct platform_device pxaudc_device = {
 	.name		= "pxa2xx-udc",
 	.id		= -1,
 	.resource	= pxa2xx_udc_resources,
@@ -307,7 +307,7 @@ static struct resource pxafb_resources[] = {
 
 static u64 fb_dma_mask = ~(u64)0;
 
-static struct platform_device pxafb_device = {
+struct platform_device pxafb_device = {
 	.name		= "pxa2xx-fb",
 	.id		= -1,
 	.dev		= {
@@ -328,24 +328,24 @@ void __init set_pxa_fb_parent(struct device *parent_dev)
 	pxafb_device.dev.parent = parent_dev;
 }
 
-static struct platform_device ffuart_device = {
+struct platform_device ffuart_device = {
 	.name		= "pxa2xx-uart",
 	.id		= 0,
 };
-static struct platform_device btuart_device = {
+struct platform_device btuart_device = {
 	.name		= "pxa2xx-uart",
 	.id		= 1,
 };
-static struct platform_device stuart_device = {
+struct platform_device stuart_device = {
 	.name		= "pxa2xx-uart",
 	.id		= 2,
 };
-static struct platform_device hwuart_device = {
+struct platform_device hwuart_device = {
 	.name		= "pxa2xx-uart",
 	.id		= 3,
 };
 
-static struct resource i2c_resources[] = {
+static struct resource pxai2c_resources[] = {
 	{
 		.start	= 0x40301680,
 		.end	= 0x403016a3,
@@ -357,40 +357,19 @@ static struct resource i2c_resources[] = {
 	},
 };
 
-static struct platform_device i2c_device = {
+struct platform_device pxai2c_device = {
 	.name		= "pxa2xx-i2c",
 	.id		= 0,
-	.resource	= i2c_resources,
-	.num_resources	= ARRAY_SIZE(i2c_resources),
+	.resource	= pxai2c_resources,
+	.num_resources	= ARRAY_SIZE(pxai2c_resources),
 };
 
-#ifdef CONFIG_PXA27x
-static struct resource i2c_power_resources[] = {
-	{
-		.start	= 0x40f00180,
-		.end	= 0x40f001a3,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start	= IRQ_PWRI2C,
-		.end	= IRQ_PWRI2C,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device i2c_power_device = {
-	.name		= "pxa2xx-i2c",
-	.id		= 1,
-	.resource	= i2c_power_resources,
-	.num_resources	= ARRAY_SIZE(i2c_resources),
-};
-#endif
-
 void __init pxa_set_i2c_info(struct i2c_pxa_platform_data *info)
 {
-	i2c_device.dev.platform_data = info;
+	pxai2c_device.dev.platform_data = info;
 }
 
-static struct resource i2s_resources[] = {
+static struct resource pxai2s_resources[] = {
 	{
 		.start	= 0x40400000,
 		.end	= 0x40400083,
@@ -402,16 +381,16 @@ static struct resource i2s_resources[] = {
 	},
 };
 
-static struct platform_device i2s_device = {
+struct platform_device pxai2s_device = {
 	.name		= "pxa2xx-i2s",
 	.id		= -1,
-	.resource	= i2s_resources,
-	.num_resources	= ARRAY_SIZE(i2s_resources),
+	.resource	= pxai2s_resources,
+	.num_resources	= ARRAY_SIZE(pxai2s_resources),
 };
 
 static u64 pxaficp_dmamask = ~(u32)0;
 
-static struct platform_device pxaficp_device = {
+struct platform_device pxaficp_device = {
 	.name		= "pxa2xx-ir",
 	.id		= -1,
 	.dev		= {
@@ -425,40 +404,7 @@ void __init pxa_set_ficp_info(struct pxaficp_platform_data *info)
 	pxaficp_device.dev.platform_data = info;
 }
 
-static struct platform_device pxartc_device = {
+struct platform_device pxartc_device = {
 	.name		= "sa1100-rtc",
 	.id		= -1,
 };
-
-static struct platform_device *devices[] __initdata = {
-	&pxamci_device,
-	&udc_device,
-	&pxafb_device,
-	&ffuart_device,
-	&btuart_device,
-	&stuart_device,
-	&pxaficp_device,
-	&i2c_device,
-#ifdef CONFIG_PXA27x
-	&i2c_power_device,
-#endif
-	&i2s_device,
-	&pxartc_device,
-};
-
-static int __init pxa_init(void)
-{
-	int ret;
-
-	ret = platform_add_devices(devices, ARRAY_SIZE(devices));
-	if (ret)
-		return ret;
-
-	/* Only add HWUART for PXA255/26x; PXA210/250/27x do not have it. */
-	if (cpu_is_pxa25x())
-		ret = platform_device_register(&hwuart_device);
-
-	return ret;
-}
-
-subsys_initcall(pxa_init);

commit b23170c01f6e4ea043df7cd9486c2488e01f3d60
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue May 15 10:26:49 2007 +0100

    [ARM] pxa: introduce cpu_is_pxaXXX macros
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 64b08b744f9f..147b7c40d9f9 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -448,16 +448,14 @@ static struct platform_device *devices[] __initdata = {
 
 static int __init pxa_init(void)
 {
-	int cpuid, ret;
+	int ret;
 
 	ret = platform_add_devices(devices, ARRAY_SIZE(devices));
 	if (ret)
 		return ret;
 
 	/* Only add HWUART for PXA255/26x; PXA210/250/27x do not have it. */
-	cpuid = read_cpuid(CPUID_ID);
-	if (((cpuid >> 4) & 0xfff) == 0x2d0 ||
-	    ((cpuid >> 4) & 0xfff) == 0x290)
+	if (cpu_is_pxa25x())
 		ret = platform_device_register(&hwuart_device);
 
 	return ret;

commit 7053acbd78336abf5d4bc3d8a875a03624cfb83f
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Thu Apr 5 04:07:20 2007 +0100

    [ARM] 4304/1: removes the unnecessary bit number from CKENnn_XXXX
    
    This patch removes the unnecessary bit number from CKENnn_XXXX
    definitions for PXA, so that
    
            CKEN0_PWM0 --> CKEN_PWM0
            CKEN1_PWM1 --> CKEN_PWM1
            ...
            CKEN24_CAMERA --> CKEN_CAMERA
    
    The reasons for the change of these defitions are:
    
    1. they do not scale - they are currently valid for pxa2xx, but
    definitely not valid for pxa3xx, e.g., pxa3xx has bit 3 for camera
    instead of bit 24
    
    2. they are unnecessary - the peripheral name within the definition
    has already announced its usage, we don't need those bit numbers
    to know which peripheral we are going to enable/disable clock for
    
    3. they are inconvenient - think about this: a driver programmer
    for pxa has to remember which bit in the CKEN register to turn
    on/off
    
    Another change in the patch is to make the definitions equal to its
    clock bit index, so that
    
       #define CKEN_CAMERA  (24)
    
    instead of
    
       #define CKEN_CAMERA  (1 << 24)
    
    this change, however, will add a run-time bit shift operation in
    pxa_set_cken(), but the benefit of this change is that it scales
    when bit index exceeds 32, e.g., pxa3xx has two registers CKENA
    and CKENB, totally 64 bit for this, suppose CAMERA clock enabling
    bit is CKENB:10, one can simply define CKEN_CAMERA to be (32 + 10)
    and so that pxa_set_cken() need minimum change to adapt to that.
    
    Signed-off-by: eric miao <eric.y.miao@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index b8cb79f899d5..64b08b744f9f 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -164,9 +164,9 @@ void pxa_set_cken(int clock, int enable)
 	local_irq_save(flags);
 
 	if (enable)
-		CKEN |= clock;
+		CKEN |= (1 << clock);
 	else
-		CKEN &= ~clock;
+		CKEN &= ~(1 << clock);
 
 	local_irq_restore(flags);
 }

commit 3deac046e2883686a732960050ab74fca0db11fa
Author: Philipp Zabel <philipp.zabel@gmail.com>
Date:   Tue Feb 20 13:58:15 2007 -0800

    [PATCH] GPIO API: PXA wrapper cleanup
    
    Based on the discussion last december (http://lkml.org/lkml/2006/12/20/242),
    this patch:
    
      - moves the PXA_LAST_GPIO check into pxa_gpio_mode
      - fixes comment and includes in gpio.h
      - replaces the gpio_set/get_value macros with inline
        functions and adds a non-inline version to avoid
        code explosion when gpio is not a constant.
    
    Signed-off-by: Philipp Zabel <philipp.zabel@gmail.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Nicolas Pitre <nico@cam.org>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 390524c4710f..b8cb79f899d5 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -36,6 +36,7 @@
 #include <asm/mach/map.h>
 
 #include <asm/arch/pxa-regs.h>
+#include <asm/arch/gpio.h>
 #include <asm/arch/udc.h>
 #include <asm/arch/pxafb.h>
 #include <asm/arch/mmc.h>
@@ -106,13 +107,16 @@ unsigned long long sched_clock(void)
  * Handy function to set GPIO alternate functions
  */
 
-void pxa_gpio_mode(int gpio_mode)
+int pxa_gpio_mode(int gpio_mode)
 {
 	unsigned long flags;
 	int gpio = gpio_mode & GPIO_MD_MASK_NR;
 	int fn = (gpio_mode & GPIO_MD_MASK_FN) >> 8;
 	int gafr;
 
+	if (gpio > PXA_LAST_GPIO)
+		return -EINVAL;
+
 	local_irq_save(flags);
 	if (gpio_mode & GPIO_DFLT_LOW)
 		GPCR(gpio) = GPIO_bit(gpio);
@@ -125,10 +129,32 @@ void pxa_gpio_mode(int gpio_mode)
 	gafr = GAFR(gpio) & ~(0x3 << (((gpio) & 0xf)*2));
 	GAFR(gpio) = gafr |  (fn  << (((gpio) & 0xf)*2));
 	local_irq_restore(flags);
+
+	return 0;
 }
 
 EXPORT_SYMBOL(pxa_gpio_mode);
 
+/*
+ * Return GPIO level
+ */
+int pxa_gpio_get_value(unsigned gpio)
+{
+	return __gpio_get_value(gpio);
+}
+
+EXPORT_SYMBOL(pxa_gpio_get_value);
+
+/*
+ * Set output GPIO level
+ */
+void pxa_gpio_set_value(unsigned gpio, int value)
+{
+	__gpio_set_value(gpio, value);
+}
+
+EXPORT_SYMBOL(pxa_gpio_set_value);
+
 /*
  * Routine to safely enable or disable a clock in the CKEN
  */

commit a7b4e5506d1608112a208bc5391377d2c0b6dd80
Author: Guennadi Liakhovetski <gl@dsa-ac.de>
Date:   Thu Feb 8 09:43:26 2007 +0100

    [ARM] 4144/1: Fix for patch #4099/1 with CONFIG_I2C_PXA_SLAVE set
    
    Switch the i2c-pxa driver to actually using the platform device information and let it handle the power i2c bus on pxa27x too. Original version of this patch didn't compile with CONFIG_I2C_PXA_SLAVE set.
    
    Signed-off-by: G. Liakhovetski <gl@dsa-ac.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 9de1278d234f..390524c4710f 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -338,6 +338,27 @@ static struct platform_device i2c_device = {
 	.num_resources	= ARRAY_SIZE(i2c_resources),
 };
 
+#ifdef CONFIG_PXA27x
+static struct resource i2c_power_resources[] = {
+	{
+		.start	= 0x40f00180,
+		.end	= 0x40f001a3,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_PWRI2C,
+		.end	= IRQ_PWRI2C,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device i2c_power_device = {
+	.name		= "pxa2xx-i2c",
+	.id		= 1,
+	.resource	= i2c_power_resources,
+	.num_resources	= ARRAY_SIZE(i2c_resources),
+};
+#endif
+
 void __init pxa_set_i2c_info(struct i2c_pxa_platform_data *info)
 {
 	i2c_device.dev.platform_data = info;
@@ -392,6 +413,9 @@ static struct platform_device *devices[] __initdata = {
 	&stuart_device,
 	&pxaficp_device,
 	&i2c_device,
+#ifdef CONFIG_PXA27x
+	&i2c_power_device,
+#endif
 	&i2s_device,
 	&pxartc_device,
 };

commit 0c48d314b16f485e89e0f13fa37c9bd98b6a064d
Author: Nicolas Pitre <nico@cam.org>
Date:   Fri Dec 22 18:52:56 2006 +0100

    [ARM] 4066/1: correct a comment about PXA's sched_clock range
    
    Signed-off-by: Nicolas Pitre <nico@cam.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 6ae605857ca9..9de1278d234f 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -76,7 +76,9 @@ unsigned long long sched_clock(void)
 	/*
 	 * 96-bit math to perform tick * NSEC_PER_SEC / CLOCK_TICK_RATE for
 	 * any value of CLOCK_TICK_RATE. Max value is in the 80 thousand
-	 * years range which is nice, but with higher computation cost.
+	 * years range and truncation to unsigned long long limits it to
+	 * sched_clock's max range of ~584 years.  This is nice but with
+	 * higher computation cost.
 	 */
 	{
 		union {

commit 2dc20a51dc1e2da6eae1182cfe4c4835fca26017
Author: Nicolas Pitre <nico@cam.org>
Date:   Mon Dec 4 20:42:09 2006 +0100

    [ARM] 3981/1: sched_clock for PXA2xx
    
    Here's a 63-bit implementation of shed_clock() for PXA2xx.  The actual
    period depends on the value of CLOCK_TICK_RATE and whether or not
    reduced scaling factors were provided for it.
    
    Signed-off-by: Nicolas Pitre <nico@cam.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 45fb2c3bcf82..6ae605857ca9 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -25,6 +25,10 @@
 #include <linux/pm.h>
 #include <linux/string.h>
 
+#include <linux/sched.h>
+#include <asm/cnt32_to_63.h>
+#include <asm/div64.h>
+
 #include <asm/hardware.h>
 #include <asm/irq.h>
 #include <asm/system.h>
@@ -40,6 +44,62 @@
 
 #include "generic.h"
 
+/*
+ * This is the PXA2xx sched_clock implementation. This has a resolution
+ * of at least 308ns and a maximum value that depends on the value of
+ * CLOCK_TICK_RATE.
+ *
+ * The return value is guaranteed to be monotonic in that range as
+ * long as there is always less than 582 seconds between successive
+ * calls to this function.
+ */
+unsigned long long sched_clock(void)
+{
+	unsigned long long v = cnt32_to_63(OSCR);
+	/* Note: top bit ov v needs cleared unless multiplier is even. */
+
+#if	CLOCK_TICK_RATE == 3686400
+	/* 1E9 / 3686400 => 78125 / 288, max value = 32025597s (370 days). */
+	/* The <<1 is used to get rid of tick.hi top bit */
+	v *= 78125<<1;
+	do_div(v, 288<<1);
+#elif	CLOCK_TICK_RATE == 3250000
+	/* 1E9 / 3250000 => 4000 / 13, max value = 709490156s (8211 days) */
+	v *= 4000;
+	do_div(v, 13);
+#elif	CLOCK_TICK_RATE == 3249600
+	/* 1E9 / 3249600 => 625000 / 2031, max value = 4541295s (52 days) */
+	v *= 625000;
+	do_div(v, 2031);
+#else
+#warning "consider fixing sched_clock for your value of CLOCK_TICK_RATE"
+	/*
+	 * 96-bit math to perform tick * NSEC_PER_SEC / CLOCK_TICK_RATE for
+	 * any value of CLOCK_TICK_RATE. Max value is in the 80 thousand
+	 * years range which is nice, but with higher computation cost.
+	 */
+	{
+		union {
+			unsigned long long val;
+			struct { unsigned long lo, hi; };
+		} x;
+		unsigned long long y;
+
+		x.val = v;
+		x.hi &= 0x7fffffff;
+		y = (unsigned long long)x.lo * NSEC_PER_SEC;
+		x.lo = y;
+		y = (y >> 32) + (unsigned long long)x.hi * NSEC_PER_SEC;
+		x.hi = do_div(y, CLOCK_TICK_RATE);
+		do_div(x.val, CLOCK_TICK_RATE);
+		x.hi += y;
+		v = x.val;
+	}
+#endif
+
+	return v;
+}
+
 /*
  * Handy function to set GPIO alternate functions
  */

commit d14b272bc63f35a8f20b4b1df16c080b8d24f8f1
Author: Richard Purdie <rpurdie@net.rmk.(none)>
Date:   Wed Sep 20 22:54:21 2006 +0100

    [ARM] 3848/1: pxafb: Add option of fixing video modes and spitz QVGA mode support
    
    Add the ability to have pxafb use only certain fixed video modes
    (selected on a per platform basis). This is useful on production
    hardware such as the Zaurus cxx00 models where the valid modes are
    known in advance and any other modes could result in hardware damage.
    
    Following this, add support for the cxx00 QVGA mode. Mode information
    is passed to the lcd_power call to allowing the panel drivers to
    configure the display hardware accordingly (corgi_lcd already contains
    the functionality for the cxx00 panel).
    
    This mirrors the setup already used by w100fb.
    
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 5efa84749f37..45fb2c3bcf82 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -204,13 +204,6 @@ static struct platform_device udc_device = {
 	}
 };
 
-static struct pxafb_mach_info pxa_fb_info;
-
-void __init set_pxa_fb_info(struct pxafb_mach_info *hard_pxa_fb_info)
-{
-	memcpy(&pxa_fb_info,hard_pxa_fb_info,sizeof(struct pxafb_mach_info));
-}
-
 static struct resource pxafb_resources[] = {
 	[0] = {
 		.start	= 0x44000000,
@@ -230,7 +223,6 @@ static struct platform_device pxafb_device = {
 	.name		= "pxa2xx-fb",
 	.id		= -1,
 	.dev		= {
- 		.platform_data	= &pxa_fb_info,
 		.dma_mask	= &fb_dma_mask,
 		.coherent_dma_mask = 0xffffffff,
 	},
@@ -238,6 +230,11 @@ static struct platform_device pxafb_device = {
 	.resource	= pxafb_resources,
 };
 
+void __init set_pxa_fb_info(struct pxafb_mach_info *info)
+{
+	pxafb_device.dev.platform_data = info;
+}
+
 void __init set_pxa_fb_parent(struct device *parent_dev)
 {
 	pxafb_device.dev.parent = parent_dev;

commit e842f1c8ff8a88f290e26d1139e89aad02c4e0c3
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Mon Mar 27 01:16:46 2006 -0800

    [PATCH] RTC subsystem: SA1100/PXA2XX driver
    
    Add an RTC subsystem driver for the ARM SA1100/PXA2XX processor RTC.
    
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 9b48a90aefce..5efa84749f37 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -319,6 +319,11 @@ void __init pxa_set_ficp_info(struct pxaficp_platform_data *info)
 	pxaficp_device.dev.platform_data = info;
 }
 
+static struct platform_device pxartc_device = {
+	.name		= "sa1100-rtc",
+	.id		= -1,
+};
+
 static struct platform_device *devices[] __initdata = {
 	&pxamci_device,
 	&udc_device,
@@ -329,6 +334,7 @@ static struct platform_device *devices[] __initdata = {
 	&pxaficp_device,
 	&i2c_device,
 	&i2s_device,
+	&pxartc_device,
 };
 
 static int __init pxa_init(void)

commit 4fd5f8267dd37aaebadfabe71d9c808821eea05a
Merge: eb16292ba8a6 8576762ff5d1
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Mon Oct 31 07:32:56 2005 -0800

    Merge master.kernel.org:/home/rmk/linux-2.6-drvmodel
    
    Manual #include fixups for clashes - there may be some unnecessary

commit 4e57b6817880946a3a78d5d8cad1ace363f7e449
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Oct 30 15:03:48 2005 -0800

    [PATCH] fix missing includes
    
    I recently picked up my older work to remove unnecessary #includes of
    sched.h, starting from a patch by Dave Jones to not include sched.h
    from module.h. This reduces the number of indirect includes of sched.h
    by ~300. Another ~400 pointless direct includes can be removed after
    this disentangling (patch to follow later).
    However, quite a few indirect includes need to be fixed up for this.
    
    In order to feed the patches through -mm with as little disturbance as
    possible, I've split out the fixes I accumulated up to now (complete for
    i386 and x86_64, more archs to follow later) and post them before the real
    patch.  This way this large part of the patch is kept simple with only
    adding #includes, and all hunks are independent of each other.  So if any
    hunk rejects or gets in the way of other patches, just drop it.  My scripts
    will pick it up again in the next round.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 3248bc9b9495..9c0289333301 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -23,6 +23,7 @@
 #include <linux/device.h>
 #include <linux/ioport.h>
 #include <linux/pm.h>
+#include <linux/string.h>
 
 #include <asm/hardware.h>
 #include <asm/irq.h>

commit d052d1beff706920e82c5d55006b08e256b5df09
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Oct 29 19:07:23 2005 +0100

    Create platform_device.h to contain all the platform device details.
    Convert everyone who uses platform_bus_type to include
    linux/platform_device.h.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 3248bc9b9495..afd5063b0ebe 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -20,7 +20,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/delay.h>
-#include <linux/device.h>
+#include <linux/platform_device.h>
 #include <linux/ioport.h>
 #include <linux/pm.h>
 

commit 6f475c0133eb91c7df3b056843dc33d2824368a2
Author: Nicolas Pitre <nico@cam.org>
Date:   Fri Oct 28 16:39:33 2005 +0100

    [ARM] 2897/2: PXA2xx IRDA support
    
    Patch from Nicolas Pitre
    
    This is the PXA2xx common IRDA driver, plus platform support
    for Lubbock and Mainstone.
    
    Signed-off-by: Nicolas Pitre <nico@cam.org>
    Acked-by: Jean Tourrilhes <jt@hpl.hp.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 218eb9671fa3..3248bc9b9495 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -34,6 +34,7 @@
 #include <asm/arch/udc.h>
 #include <asm/arch/pxafb.h>
 #include <asm/arch/mmc.h>
+#include <asm/arch/irda.h>
 #include <asm/arch/i2c.h>
 
 #include "generic.h"
@@ -301,6 +302,22 @@ static struct platform_device i2s_device = {
 	.num_resources	= ARRAY_SIZE(i2s_resources),
 };
 
+static u64 pxaficp_dmamask = ~(u32)0;
+
+static struct platform_device pxaficp_device = {
+	.name		= "pxa2xx-ir",
+	.id		= -1,
+	.dev		= {
+		.dma_mask = &pxaficp_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+};
+
+void __init pxa_set_ficp_info(struct pxaficp_platform_data *info)
+{
+	pxaficp_device.dev.platform_data = info;
+}
+
 static struct platform_device *devices[] __initdata = {
 	&pxamci_device,
 	&udc_device,
@@ -308,6 +325,7 @@ static struct platform_device *devices[] __initdata = {
 	&ffuart_device,
 	&btuart_device,
 	&stuart_device,
+	&pxaficp_device,
 	&i2c_device,
 	&i2s_device,
 };

commit d9e29649875df82828167dd45c802d942db863ba
Author: Matt Reimer <mreimer@vpop.net>
Date:   Fri Oct 28 16:25:02 2005 +0100

    [ARM] 3029/1: Add HWUART support for PXA 255/26x
    
    Patch from Matt Reimer
    
    Adds support for HWUART on PXA 255 / 26x. This patch originally came from
    http://svn.rungie.com/svn/gumstix-buildroot/trunk/sources/kernel-patches/000-gumstix-hwuart.patch
    and has been tweaked by me.
    
    Signed-off-by: Matt Reimer <mreimer@vpop.net>
    Signed-off-by: Nicolas Pitre <nico@cam.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 719b91e93fa2..218eb9671fa3 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -253,6 +253,10 @@ static struct platform_device stuart_device = {
 	.name		= "pxa2xx-uart",
 	.id		= 2,
 };
+static struct platform_device hwuart_device = {
+	.name		= "pxa2xx-uart",
+	.id		= 3,
+};
 
 static struct resource i2c_resources[] = {
 	{
@@ -310,7 +314,19 @@ static struct platform_device *devices[] __initdata = {
 
 static int __init pxa_init(void)
 {
-	return platform_add_devices(devices, ARRAY_SIZE(devices));
+	int cpuid, ret;
+
+	ret = platform_add_devices(devices, ARRAY_SIZE(devices));
+	if (ret)
+		return ret;
+
+	/* Only add HWUART for PXA255/26x; PXA210/250/27x do not have it. */
+	cpuid = read_cpuid(CPUID_ID);
+	if (((cpuid >> 4) & 0xfff) == 0x2d0 ||
+	    ((cpuid >> 4) & 0xfff) == 0x290)
+		ret = platform_device_register(&hwuart_device);
+
+	return ret;
 }
 
 subsys_initcall(pxa_init);

commit b57235215933d5fde4013e2448223b934b4ac2b7
Author: Ian Campbell <icampbell@arcom.com>
Date:   Fri Oct 28 15:31:48 2005 +0100

    [ARM] 3048/1: register i2s resources not i2c resources for the pxa i2s platform device
    
    Patch from Ian Campbell
    
    As noted by Uli Luckas in the comments of 3025 there is a typo in the i2s platform device. The i2s platform device refers to the i2c resources.
    
    Signed-off-by: Ian Campbell <icampbell@arcom.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 2e9e1702c4b3..719b91e93fa2 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -293,7 +293,7 @@ static struct resource i2s_resources[] = {
 static struct platform_device i2s_device = {
 	.name		= "pxa2xx-i2s",
 	.id		= -1,
-	.resource	= i2c_resources,
+	.resource	= i2s_resources,
 	.num_resources	= ARRAY_SIZE(i2s_resources),
 };
 

commit 6f9182eb32a4e6c46813928bee50df71e3fd1c74
Author: Deepak Saxena <dsaxena@plexity.net>
Date:   Fri Oct 28 15:19:01 2005 +0100

    [ARM] 2988/1: Replace map_desc.physical with map_desc.pfn: PXA
    
    Patch from Deepak Saxena
    
    PXA map_desc.pfn conversion
    
    Signed-off-by: Deepak Saxena <dsaxena@plexity.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index 1d7677669a76..2e9e1702c4b3 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -92,14 +92,42 @@ EXPORT_SYMBOL(pxa_set_cken);
  *         and cache flush area.
  */
 static struct map_desc standard_io_desc[] __initdata = {
- /* virtual     physical    length      type */
-  { 0xf2000000, 0x40000000, 0x02000000, MT_DEVICE }, /* Devs */
-  { 0xf4000000, 0x44000000, 0x00100000, MT_DEVICE }, /* LCD */
-  { 0xf6000000, 0x48000000, 0x00100000, MT_DEVICE }, /* Mem Ctl */
-  { 0xf8000000, 0x4c000000, 0x00100000, MT_DEVICE }, /* USB host */
-  { 0xfa000000, 0x50000000, 0x00100000, MT_DEVICE }, /* Camera */
-  { 0xfe000000, 0x58000000, 0x00100000, MT_DEVICE }, /* IMem ctl */
-  { 0xff000000, 0x00000000, 0x00100000, MT_DEVICE }  /* UNCACHED_PHYS_0 */
+  	{	/* Devs */
+		.virtual	=  0xf2000000,
+		.pfn		= __phys_to_pfn(0x40000000),
+		.length		= 0x02000000,
+		.type		= MT_DEVICE
+	}, {	/* LCD */
+		.virtual	=  0xf4000000,
+		.pfn		= __phys_to_pfn(0x44000000),
+		.length		= 0x00100000,
+		.type		= MT_DEVICE
+	}, {	/* Mem Ctl */
+		.virtual	=  0xf6000000,
+		.pfn		= __phys_to_pfn(0x48000000),
+		.length		= 0x00100000,
+		.type		= MT_DEVICE
+	}, {	/* USB host */
+		.virtual	=  0xf8000000,
+		.pfn		= __phys_to_pfn(0x4c000000),
+		.length		= 0x00100000,
+		.type		= MT_DEVICE
+	}, {	/* Camera */
+		.virtual	=  0xfa000000,
+		.pfn		= __phys_to_pfn(0x50000000),
+		.length		= 0x00100000,
+		.type		= MT_DEVICE
+	}, {	/* IMem ctl */
+		.virtual	=  0xfe000000,
+		.pfn		= __phys_to_pfn(0x58000000),
+		.length		= 0x00100000,
+		.type		= MT_DEVICE
+	}, {	/* UNCACHED_PHYS_0 */
+		.virtual	= 0xff000000,
+		.pfn		= __phys_to_pfn(0x00000000),
+		.length		= 0x00100000,
+		.type		= MT_DEVICE
+	}
 };
 
 void __init pxa_map_io(void)

commit b2640b420a806c91f6b8799314ca96bb88a246d2
Author: Matt Reimer <mreimer@vpop.net>
Date:   Thu Oct 20 23:21:18 2005 +0100

    [ARM] 3025/1: Add I2S platform device for PXA
    
    Patch from Matt Reimer
    
    Adds an I2S platform_device for PXA. I2S is used to interface
    with sound chips on systems like iPAQ h1910/h2200/hx4700 and
    Asus 716.
    
    Signed-off-by: mreimer@vpop.net
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index d327c127eddb..1d7677669a76 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -250,6 +250,25 @@ void __init pxa_set_i2c_info(struct i2c_pxa_platform_data *info)
 	i2c_device.dev.platform_data = info;
 }
 
+static struct resource i2s_resources[] = {
+	{
+		.start	= 0x40400000,
+		.end	= 0x40400083,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_I2S,
+		.end	= IRQ_I2S,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device i2s_device = {
+	.name		= "pxa2xx-i2s",
+	.id		= -1,
+	.resource	= i2c_resources,
+	.num_resources	= ARRAY_SIZE(i2s_resources),
+};
+
 static struct platform_device *devices[] __initdata = {
 	&pxamci_device,
 	&udc_device,
@@ -258,6 +277,7 @@ static struct platform_device *devices[] __initdata = {
 	&btuart_device,
 	&stuart_device,
 	&i2c_device,
+	&i2s_device,
 };
 
 static int __init pxa_init(void)

commit cb38c569e5ecf9e922e66963b6da2751b4f13d81
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Fri Oct 14 16:07:25 2005 +0100

    [ARM] 3011/1: pxafb: Add ability to set device parent + fix spitz compile error
    
    Patch from Richard Purdie
    
    Add a function to allow machines to set the parent of the pxa
    framebuffer device. This means the power up/down sequence can be
    controlled where required by the machine.
    
    Update spitz to use the new function, fixing a compile error.
    
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index d0660a8c4b70..d327c127eddb 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -208,6 +208,11 @@ static struct platform_device pxafb_device = {
 	.resource	= pxafb_resources,
 };
 
+void __init set_pxa_fb_parent(struct device *parent_dev)
+{
+	pxafb_device.dev.parent = parent_dev;
+}
+
 static struct platform_device ffuart_device = {
 	.name		= "pxa2xx-uart",
 	.id		= 0,

commit eb9181a2f85d46cdbbd3cb18b4541f8ab2df0933
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Sep 29 09:49:25 2005 +0100

    [ARM] Fix warning in arch/arm/mach-pxa/generic.c
    
    Fix
     arch/arm/mach-pxa/generic.c:242: warning: 'struct i2c_pxa_platform_data' declared inside parameter list
    caused by missing asm/arch/i2c.h include.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index a45aaa115a76..d0660a8c4b70 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -34,6 +34,7 @@
 #include <asm/arch/udc.h>
 #include <asm/arch/pxafb.h>
 #include <asm/arch/mmc.h>
+#include <asm/arch/i2c.h>
 
 #include "generic.h"
 

commit bb9bffcbef6166cf03385fbcde97c27bc1a5e689
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Apr 30 13:26:06 2005 +0100

    [PATCH] ARM: PXA I2C: add platform device
    
    Add the PXA I2C platform device.
    
    Signed-off-by: Russell King <rmk@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
index b1575b8dc1cd..a45aaa115a76 100644
--- a/arch/arm/mach-pxa/generic.c
+++ b/arch/arm/mach-pxa/generic.c
@@ -220,6 +220,30 @@ static struct platform_device stuart_device = {
 	.id		= 2,
 };
 
+static struct resource i2c_resources[] = {
+	{
+		.start	= 0x40301680,
+		.end	= 0x403016a3,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_I2C,
+		.end	= IRQ_I2C,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device i2c_device = {
+	.name		= "pxa2xx-i2c",
+	.id		= 0,
+	.resource	= i2c_resources,
+	.num_resources	= ARRAY_SIZE(i2c_resources),
+};
+
+void __init pxa_set_i2c_info(struct i2c_pxa_platform_data *info)
+{
+	i2c_device.dev.platform_data = info;
+}
+
 static struct platform_device *devices[] __initdata = {
 	&pxamci_device,
 	&udc_device,
@@ -227,6 +251,7 @@ static struct platform_device *devices[] __initdata = {
 	&ffuart_device,
 	&btuart_device,
 	&stuart_device,
+	&i2c_device,
 };
 
 static int __init pxa_init(void)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/arm/mach-pxa/generic.c b/arch/arm/mach-pxa/generic.c
new file mode 100644
index 000000000000..b1575b8dc1cd
--- /dev/null
+++ b/arch/arm/mach-pxa/generic.c
@@ -0,0 +1,237 @@
+/*
+ *  linux/arch/arm/mach-pxa/generic.c
+ *
+ *  Author:	Nicolas Pitre
+ *  Created:	Jun 15, 2001
+ *  Copyright:	MontaVista Software Inc.
+ *
+ * Code common to all PXA machines.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Since this file should be linked before any other machine specific file,
+ * the __initcall() here will be executed first.  This serves as default
+ * initialization stuff for PXA machines which can be overridden later if
+ * need be.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/ioport.h>
+#include <linux/pm.h>
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/pgtable.h>
+#include <asm/mach/map.h>
+
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/udc.h>
+#include <asm/arch/pxafb.h>
+#include <asm/arch/mmc.h>
+
+#include "generic.h"
+
+/*
+ * Handy function to set GPIO alternate functions
+ */
+
+void pxa_gpio_mode(int gpio_mode)
+{
+	unsigned long flags;
+	int gpio = gpio_mode & GPIO_MD_MASK_NR;
+	int fn = (gpio_mode & GPIO_MD_MASK_FN) >> 8;
+	int gafr;
+
+	local_irq_save(flags);
+	if (gpio_mode & GPIO_DFLT_LOW)
+		GPCR(gpio) = GPIO_bit(gpio);
+	else if (gpio_mode & GPIO_DFLT_HIGH)
+		GPSR(gpio) = GPIO_bit(gpio);
+	if (gpio_mode & GPIO_MD_MASK_DIR)
+		GPDR(gpio) |= GPIO_bit(gpio);
+	else
+		GPDR(gpio) &= ~GPIO_bit(gpio);
+	gafr = GAFR(gpio) & ~(0x3 << (((gpio) & 0xf)*2));
+	GAFR(gpio) = gafr |  (fn  << (((gpio) & 0xf)*2));
+	local_irq_restore(flags);
+}
+
+EXPORT_SYMBOL(pxa_gpio_mode);
+
+/*
+ * Routine to safely enable or disable a clock in the CKEN
+ */
+void pxa_set_cken(int clock, int enable)
+{
+	unsigned long flags;
+	local_irq_save(flags);
+
+	if (enable)
+		CKEN |= clock;
+	else
+		CKEN &= ~clock;
+
+	local_irq_restore(flags);
+}
+
+EXPORT_SYMBOL(pxa_set_cken);
+
+/*
+ * Intel PXA2xx internal register mapping.
+ *
+ * Note 1: not all PXA2xx variants implement all those addresses.
+ *
+ * Note 2: virtual 0xfffe0000-0xffffffff is reserved for the vector table
+ *         and cache flush area.
+ */
+static struct map_desc standard_io_desc[] __initdata = {
+ /* virtual     physical    length      type */
+  { 0xf2000000, 0x40000000, 0x02000000, MT_DEVICE }, /* Devs */
+  { 0xf4000000, 0x44000000, 0x00100000, MT_DEVICE }, /* LCD */
+  { 0xf6000000, 0x48000000, 0x00100000, MT_DEVICE }, /* Mem Ctl */
+  { 0xf8000000, 0x4c000000, 0x00100000, MT_DEVICE }, /* USB host */
+  { 0xfa000000, 0x50000000, 0x00100000, MT_DEVICE }, /* Camera */
+  { 0xfe000000, 0x58000000, 0x00100000, MT_DEVICE }, /* IMem ctl */
+  { 0xff000000, 0x00000000, 0x00100000, MT_DEVICE }  /* UNCACHED_PHYS_0 */
+};
+
+void __init pxa_map_io(void)
+{
+	iotable_init(standard_io_desc, ARRAY_SIZE(standard_io_desc));
+	get_clk_frequency_khz(1);
+}
+
+
+static struct resource pxamci_resources[] = {
+	[0] = {
+		.start	= 0x41100000,
+		.end	= 0x41100fff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_MMC,
+		.end	= IRQ_MMC,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static u64 pxamci_dmamask = 0xffffffffUL;
+
+static struct platform_device pxamci_device = {
+	.name		= "pxa2xx-mci",
+	.id		= -1,
+	.dev		= {
+		.dma_mask = &pxamci_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(pxamci_resources),
+	.resource	= pxamci_resources,
+};
+
+void __init pxa_set_mci_info(struct pxamci_platform_data *info)
+{
+	pxamci_device.dev.platform_data = info;
+}
+
+
+static struct pxa2xx_udc_mach_info pxa_udc_info;
+
+void __init pxa_set_udc_info(struct pxa2xx_udc_mach_info *info)
+{
+	memcpy(&pxa_udc_info, info, sizeof *info);
+}
+
+static struct resource pxa2xx_udc_resources[] = {
+	[0] = {
+		.start	= 0x40600000,
+		.end	= 0x4060ffff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_USB,
+		.end	= IRQ_USB,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static u64 udc_dma_mask = ~(u32)0;
+
+static struct platform_device udc_device = {
+	.name		= "pxa2xx-udc",
+	.id		= -1,
+	.resource	= pxa2xx_udc_resources,
+	.num_resources	= ARRAY_SIZE(pxa2xx_udc_resources),
+	.dev		=  {
+		.platform_data	= &pxa_udc_info,
+		.dma_mask	= &udc_dma_mask,
+	}
+};
+
+static struct pxafb_mach_info pxa_fb_info;
+
+void __init set_pxa_fb_info(struct pxafb_mach_info *hard_pxa_fb_info)
+{
+	memcpy(&pxa_fb_info,hard_pxa_fb_info,sizeof(struct pxafb_mach_info));
+}
+
+static struct resource pxafb_resources[] = {
+	[0] = {
+		.start	= 0x44000000,
+		.end	= 0x4400ffff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_LCD,
+		.end	= IRQ_LCD,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static u64 fb_dma_mask = ~(u64)0;
+
+static struct platform_device pxafb_device = {
+	.name		= "pxa2xx-fb",
+	.id		= -1,
+	.dev		= {
+ 		.platform_data	= &pxa_fb_info,
+		.dma_mask	= &fb_dma_mask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(pxafb_resources),
+	.resource	= pxafb_resources,
+};
+
+static struct platform_device ffuart_device = {
+	.name		= "pxa2xx-uart",
+	.id		= 0,
+};
+static struct platform_device btuart_device = {
+	.name		= "pxa2xx-uart",
+	.id		= 1,
+};
+static struct platform_device stuart_device = {
+	.name		= "pxa2xx-uart",
+	.id		= 2,
+};
+
+static struct platform_device *devices[] __initdata = {
+	&pxamci_device,
+	&udc_device,
+	&pxafb_device,
+	&ffuart_device,
+	&btuart_device,
+	&stuart_device,
+};
+
+static int __init pxa_init(void)
+{
+	return platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+subsys_initcall(pxa_init);
