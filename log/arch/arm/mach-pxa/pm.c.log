commit c276557de3087ef67ad1aec4222f9f8b1d005f80
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Jun 3 21:34:48 2017 +0200

    ARM: pxa: Delete an error message for a failed memory allocation in pxa_pm_init()
    
    Omit an extra message for a memory allocation failure in this function.
    
    This issue was detected by using the Coccinelle software.
    
    Link: http://events.linuxfoundation.org/sites/events/files/slides/LCJ16-Refactor_Strings-WSang_0.pdf
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index e7450fb49d24..f2237f471750 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -107,10 +107,8 @@ static int __init pxa_pm_init(void)
 	sleep_save = kmalloc_array(pxa_cpu_pm_fns->save_count,
 				   sizeof(*sleep_save),
 				   GFP_KERNEL);
-	if (!sleep_save) {
-		printk(KERN_ERR "failed to alloc memory for pm save\n");
+	if (!sleep_save)
 		return -ENOMEM;
-	}
 
 	suspend_set_ops(&pxa_pm_ops);
 	return 0;

commit 8571110575c985b12d443288c397dba6dc7a44f5
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Aug 25 18:01:37 2016 +0200

    ARM: pxa: Use kmalloc_array() in pxa_pm_init()
    
    * A multiplication for the size determination of a memory allocation
      indicated that an array data structure should be processed.
      Thus use the corresponding function "kmalloc_array".
    
      This issue was detected by using the Coccinelle software.
    
    * Replace the specification of a data type by a pointer dereference
      to make the corresponding size determination a bit safer according to
      the Linux coding style convention.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 388463b99090..e7450fb49d24 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -104,8 +104,9 @@ static int __init pxa_pm_init(void)
 		return -EINVAL;
 	}
 
-	sleep_save = kmalloc(pxa_cpu_pm_fns->save_count * sizeof(unsigned long),
-			     GFP_KERNEL);
+	sleep_save = kmalloc_array(pxa_cpu_pm_fns->save_count,
+				   sizeof(*sleep_save),
+				   GFP_KERNEL);
 	if (!sleep_save) {
 		printk(KERN_ERR "failed to alloc memory for pm save\n");
 		return -ENOMEM;

commit 4c25c5d2985c1db482cfe59ed9b3a07829a60ba9
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jan 30 10:45:33 2015 +0100

    ARM: pxa: make more mach/*.h files local
    
    Lots of header files are never included outside of a mach-pxa
    directory and do not need to be made visible in include/mach,
    so let's just move them all down one level.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 37178a8559b1..388463b99090 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -16,7 +16,7 @@
 #include <linux/errno.h>
 #include <linux/slab.h>
 
-#include <mach/pm.h>
+#include "pm.h"
 
 struct pxa_cpu_pm_fns *pxa_cpu_pm_fns;
 static unsigned long *sleep_save;

commit 14cd8fd574bce1cfbe510ccb1f73c7c1024d770f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jun 21 16:32:58 2011 +0100

    ARM: pm: move cpu_init() call into core code
    
    As we have core code dealing with CPU suspend/resume, we can
    re-initialize the CPUs exception banked registers via that code rather
    than having platforms deal with that level of detail.  So, move the
    call to cpu_init() out of platform code into core code.
    
    Tested-by: Kevin Hilman <khilman@ti.com>
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 51e1583265b2..37178a8559b1 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -42,7 +42,6 @@ int pxa_pm_enter(suspend_state_t state)
 
 	/* *** go zzz *** */
 	pxa_cpu_pm_fns->enter(state);
-	cpu_init();
 
 	if (state != PM_SUSPEND_STANDBY && pxa_cpu_pm_fns->restore) {
 		/* after sleeping, validate the checksum */

commit 2472f3c8d8fc18b25b2cf1574c036e238187c0ff
Merge: d081377dfda4 31bb68a314e9 5dab26af1bac 4e8d76373c9f b6338bdc8305 f512626f5baf bf0c11183fc3 941aefac4c24 f45b1149911c 981a95d37126 6e266b204b85 21f47fbc5b18
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Mar 16 23:35:17 2011 +0000

    Merge branches 'at91', 'ep93xx', 'errata', 'footbridge', 'fncpy', 'gemini', 'irqdata', 'pm', 'sh', 'smp', 'spear', 'ux500' and 'via' into devel

commit 4f5ad99bb5331c571371f94ff4423cbb366c460b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Feb 6 17:41:26 2011 +0000

    ARM: pm: convert PXA to generic suspend/resume support
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 978e1b289544..f377f0df298d 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -67,11 +67,6 @@ int pxa_pm_enter(suspend_state_t state)
 
 EXPORT_SYMBOL_GPL(pxa_pm_enter);
 
-unsigned long sleep_phys_sp(void *sp)
-{
-	return virt_to_phys(sp);
-}
-
 static int pxa_pm_valid(suspend_state_t state)
 {
 	if (pxa_cpu_pm_fns)

commit 3d9cb0eafd024d6fc1b1583ff9b17e5f60951fd9
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Wed Jan 26 05:04:00 2011 +0800

    ARM: pxa: only save/restore registers when pm functions are defined
    
    Reported-and-tested-by: Sven Neumann <s.neumann@raumfeld.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 978e1b289544..1807c9abdde0 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -33,7 +33,7 @@ int pxa_pm_enter(suspend_state_t state)
 #endif
 
 	/* skip registers saving for standby */
-	if (state != PM_SUSPEND_STANDBY) {
+	if (state != PM_SUSPEND_STANDBY && pxa_cpu_pm_fns->save) {
 		pxa_cpu_pm_fns->save(sleep_save);
 		/* before sleeping, calculate and save a checksum */
 		for (i = 0; i < pxa_cpu_pm_fns->save_count - 1; i++)
@@ -44,7 +44,7 @@ int pxa_pm_enter(suspend_state_t state)
 	pxa_cpu_pm_fns->enter(state);
 	cpu_init();
 
-	if (state != PM_SUSPEND_STANDBY) {
+	if (state != PM_SUSPEND_STANDBY && pxa_cpu_pm_fns->restore) {
 		/* after sleeping, validate the checksum */
 		for (i = 0; i < pxa_cpu_pm_fns->save_count - 1; i++)
 			checksum += sleep_save[i];

commit 2f55ac072f5344519348c0c94b3d2f4cca46847b
Author: Lionel Debroux <lionel_debroux@yahoo.fr>
Date:   Tue Nov 16 14:14:02 2010 +0100

    suspend: constify platform_suspend_ops
    
    While at it, fix two checkpatch errors.
    Several non-const struct instances constified by this patch were added after
    the introduction of platform_suspend_ops in checkpatch.pl's list of "should
    be const" structs (79404849e90a41ea2109bd0e2f7c7164b0c4ce73).
    
    Patch against mainline.
    Inspired by hunks of the grsecurity patch, updated for newer kernels.
    
    Signed-off-by: Lionel Debroux <lionel_debroux@yahoo.fr>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 166c15f62916..978e1b289544 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -96,7 +96,7 @@ void pxa_pm_finish(void)
 		pxa_cpu_pm_fns->finish();
 }
 
-static struct platform_suspend_ops pxa_pm_ops = {
+static const struct platform_suspend_ops pxa_pm_ops = {
 	.valid		= pxa_pm_valid,
 	.enter		= pxa_pm_enter,
 	.prepare	= pxa_pm_prepare,

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 7693355ee637..166c15f62916 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -14,6 +14,7 @@
 #include <linux/module.h>
 #include <linux/suspend.h>
 #include <linux/errno.h>
+#include <linux/slab.h>
 
 #include <mach/pm.h>
 

commit 51cdd9289d2e0d83eb32ed6d7a42596b02bf924e
Author: Pavel Machek <pavel@ucw.cz>
Date:   Thu Jun 11 23:25:09 2009 +0800

    [ARM] pxa/sharpsl_pm: zaurus needs generic pxa suspend/resume routines
    
    For suspend/resume to work, spitz needs pxa_pm_suspend/resume to be
    called. Otherwise PSPR is not set properly, and system will die during
    resume.
    
    Signed-off-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 884b174c8ead..7693355ee637 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -79,7 +79,7 @@ static int pxa_pm_valid(suspend_state_t state)
 	return -EINVAL;
 }
 
-static int pxa_pm_prepare(void)
+int pxa_pm_prepare(void)
 {
 	int ret = 0;
 
@@ -89,7 +89,7 @@ static int pxa_pm_prepare(void)
 	return ret;
 }
 
-static void pxa_pm_finish(void)
+void pxa_pm_finish(void)
 {
 	if (pxa_cpu_pm_fns && pxa_cpu_pm_fns->finish)
 		pxa_cpu_pm_fns->finish();

commit 5438614509d80bc0b1981b749e9cb688f1769dfb
Author: Eric Miao <eric.miao@marvell.com>
Date:   Mon Jan 19 18:43:12 2009 +0800

    [ARM] pxa: make lubbock specific debugging stuffs back into lubbock.c
    
    This isn't perfect but at least solves the problem of pm.c's dependency
    on register definitions in <mach/lubbock.h>, which doesn't make much
    sense.
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 164eb0bb6321..884b174c8ead 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -14,15 +14,8 @@
 #include <linux/module.h>
 #include <linux/suspend.h>
 #include <linux/errno.h>
-#include <linux/time.h>
 
-#include <mach/hardware.h>
-#include <asm/memory.h>
-#include <asm/system.h>
 #include <mach/pm.h>
-#include <mach/pxa-regs.h>
-#include <mach/lubbock.h>
-#include <asm/mach/time.h>
 
 struct pxa_cpu_pm_fns *pxa_cpu_pm_fns;
 static unsigned long *sleep_save;
@@ -57,9 +50,9 @@ int pxa_pm_enter(suspend_state_t state)
 
 		/* if invalid, display message and wait for a hardware reset */
 		if (checksum != sleep_save_checksum) {
-#ifdef CONFIG_ARCH_LUBBOCK
-			LUB_HEXLED = 0xbadbadc5;
-#endif
+
+			lubbock_set_hexled(0xbadbadc5);
+
 			while (1)
 				pxa_cpu_pm_fns->enter(state);
 		}

commit 4104980a3c21801f701e53961375b3d736ee9a73
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Aug 27 12:55:04 2008 +0100

    [ARM] pxa: Allow platforms to override PSPR setting
    
    Currently, we set PSPR just before entering sleep mode.  However,
    some platforms have different requirements for setting PSPR in
    order to properly wake up.
    
    Set PSPR earlier in the suspend cycle so that platforms can
    change the setting by using a sysdev driver instead.
    
    Acked-by: Eric Miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 1b539e675579..164eb0bb6321 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -86,9 +86,27 @@ static int pxa_pm_valid(suspend_state_t state)
 	return -EINVAL;
 }
 
+static int pxa_pm_prepare(void)
+{
+	int ret = 0;
+
+	if (pxa_cpu_pm_fns && pxa_cpu_pm_fns->prepare)
+		ret = pxa_cpu_pm_fns->prepare();
+
+	return ret;
+}
+
+static void pxa_pm_finish(void)
+{
+	if (pxa_cpu_pm_fns && pxa_cpu_pm_fns->finish)
+		pxa_cpu_pm_fns->finish();
+}
+
 static struct platform_suspend_ops pxa_pm_ops = {
 	.valid		= pxa_pm_valid,
 	.enter		= pxa_pm_enter,
+	.prepare	= pxa_pm_prepare,
+	.finish		= pxa_pm_finish,
 };
 
 static int __init pxa_pm_init(void)

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 9445bf11e7ae..1b539e675579 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -16,12 +16,12 @@
 #include <linux/errno.h>
 #include <linux/time.h>
 
-#include <asm/arch/hardware.h>
+#include <mach/hardware.h>
 #include <asm/memory.h>
 #include <asm/system.h>
-#include <asm/arch/pm.h>
-#include <asm/arch/pxa-regs.h>
-#include <asm/arch/lubbock.h>
+#include <mach/pm.h>
+#include <mach/pxa-regs.h>
+#include <mach/lubbock.h>
 #include <asm/mach/time.h>
 
 struct pxa_cpu_pm_fns *pxa_cpu_pm_fns;

commit be509729356b7433f73df2b9a966674a437fbbc1
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Aug 4 10:41:28 2008 +0100

    [ARM] Remove asm/hardware.h, use asm/arch/hardware.h instead
    
    Remove includes of asm/hardware.h in addition to asm/arch/hardware.h.
    Then, since asm/hardware.h only exists to include asm/arch/hardware.h,
    update everything to directly include asm/arch/hardware.h and remove
    asm/hardware.h.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 7d4debbdcca3..9445bf11e7ae 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -16,7 +16,7 @@
 #include <linux/errno.h>
 #include <linux/time.h>
 
-#include <asm/hardware.h>
+#include <asm/arch/hardware.h>
 #include <asm/memory.h>
 #include <asm/system.h>
 #include <asm/arch/pm.h>

commit dc38e2ad53ca27968919dea6d7fa60575782d5a6
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu May 8 16:50:39 2008 +0100

    [ARM] pxa: Fix RCSR handling
    
    Related to d3930614e68bdf83a120d904c039a64e9f75dba1.
    
    RCSR is only present on PXA2xx CPUs, not on PXA3xx CPUs.  Therefore,
    we should not be unconditionally writing to RCSR from generic code.
    
    Since we now clear the RCSR status from the SoC specific PXA PM code
    and before reset in the arch_reset() function, the duplication in
    the corgi, poodle, spitz and tosa code can be removed.
    
    Acked-by: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 329df2152dcd..7d4debbdcca3 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -46,9 +46,6 @@ int pxa_pm_enter(suspend_state_t state)
 			sleep_save_checksum += sleep_save[i];
 	}
 
-	/* Clear reset status */
-	RCSR = RCSR_HWR | RCSR_WDR | RCSR_SMR | RCSR_GPR;
-
 	/* *** go zzz *** */
 	pxa_cpu_pm_fns->enter(state);
 	cpu_init();

commit 649de51b883746d76c5fa1614dd067054c9d702a
Author: Robert Jarzmik <rjarzmik@free.fr>
Date:   Fri May 2 21:17:06 2008 +0100

    [ARM] 5027/1: Fixed random memory corruption on pxa suspend cycle.
    
    Each time a pxa type cpu went in suspend, a portion of
    kmalloc memory was corrupted.
    The issue was an incorrect length allocation introduced by
    the commit 711be5ccfe9a02ba560aa918a008c31ea4760163 for
    the save registers array (=> overflow).
    
    Signed-off-by: Robert Jarzmik <rjarzmik@free.fr>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index ec1bbf333a3a..329df2152dcd 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -42,7 +42,7 @@ int pxa_pm_enter(suspend_state_t state)
 	if (state != PM_SUSPEND_STANDBY) {
 		pxa_cpu_pm_fns->save(sleep_save);
 		/* before sleeping, calculate and save a checksum */
-		for (i = 0; i < pxa_cpu_pm_fns->save_size - 1; i++)
+		for (i = 0; i < pxa_cpu_pm_fns->save_count - 1; i++)
 			sleep_save_checksum += sleep_save[i];
 	}
 
@@ -55,7 +55,7 @@ int pxa_pm_enter(suspend_state_t state)
 
 	if (state != PM_SUSPEND_STANDBY) {
 		/* after sleeping, validate the checksum */
-		for (i = 0; i < pxa_cpu_pm_fns->save_size - 1; i++)
+		for (i = 0; i < pxa_cpu_pm_fns->save_count - 1; i++)
 			checksum += sleep_save[i];
 
 		/* if invalid, display message and wait for a hardware reset */
@@ -101,7 +101,8 @@ static int __init pxa_pm_init(void)
 		return -EINVAL;
 	}
 
-	sleep_save = kmalloc(pxa_cpu_pm_fns->save_size, GFP_KERNEL);
+	sleep_save = kmalloc(pxa_cpu_pm_fns->save_count * sizeof(unsigned long),
+			     GFP_KERNEL);
 	if (!sleep_save) {
 		printk(KERN_ERR "failed to alloc memory for pm save\n");
 		return -ENOMEM;

commit d3930614e68bdf83a120d904c039a64e9f75dba1
Author: Dmitry Baryshkov <dbaryshkov@gmail.com>
Date:   Mon Apr 21 11:54:13 2008 +0100

    [ARM] 5014/1: Cleanup reset state before entering suspend or resetting.
    
    The kernel should clean stale bits from reset status, so that
    they won't confuse the bootloader.
    
    Signed-off-by: Dmitry Baryshkov <dbaryshkov@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 039194cbe477..ec1bbf333a3a 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -46,8 +46,8 @@ int pxa_pm_enter(suspend_state_t state)
 			sleep_save_checksum += sleep_save[i];
 	}
 
-	/* Clear sleep reset status */
-	RCSR = RCSR_SMR;
+	/* Clear reset status */
+	RCSR = RCSR_HWR | RCSR_WDR | RCSR_SMR | RCSR_GPR;
 
 	/* *** go zzz *** */
 	pxa_cpu_pm_fns->enter(state);

commit 512f03fdae58b96568bac1beee4d3d3b34d4ead4
Author: eric miao <eric.miao@marvell.com>
Date:   Mon Jan 14 15:50:54 2008 +0800

    [ARM] pxa: skip registers saving/restoring if entering standby mode
    
    registers are retained during standby mode, thus it's not necessary
    to save/restore and checksum
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index a941c71c7d06..039194cbe477 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -38,34 +38,37 @@ int pxa_pm_enter(suspend_state_t state)
 		iwmmxt_task_disable(NULL);
 #endif
 
-	pxa_cpu_pm_fns->save(sleep_save);
+	/* skip registers saving for standby */
+	if (state != PM_SUSPEND_STANDBY) {
+		pxa_cpu_pm_fns->save(sleep_save);
+		/* before sleeping, calculate and save a checksum */
+		for (i = 0; i < pxa_cpu_pm_fns->save_size - 1; i++)
+			sleep_save_checksum += sleep_save[i];
+	}
 
 	/* Clear sleep reset status */
 	RCSR = RCSR_SMR;
 
-	/* before sleeping, calculate and save a checksum */
-	for (i = 0; i < pxa_cpu_pm_fns->save_size - 1; i++)
-		sleep_save_checksum += sleep_save[i];
-
 	/* *** go zzz *** */
 	pxa_cpu_pm_fns->enter(state);
 	cpu_init();
 
-	/* after sleeping, validate the checksum */
-	for (i = 0; i < pxa_cpu_pm_fns->save_size - 1; i++)
-		checksum += sleep_save[i];
+	if (state != PM_SUSPEND_STANDBY) {
+		/* after sleeping, validate the checksum */
+		for (i = 0; i < pxa_cpu_pm_fns->save_size - 1; i++)
+			checksum += sleep_save[i];
 
-	/* if invalid, display message and wait for a hardware reset */
-	if (checksum != sleep_save_checksum) {
+		/* if invalid, display message and wait for a hardware reset */
+		if (checksum != sleep_save_checksum) {
 #ifdef CONFIG_ARCH_LUBBOCK
-		LUB_HEXLED = 0xbadbadc5;
+			LUB_HEXLED = 0xbadbadc5;
 #endif
-		while (1)
-			pxa_cpu_pm_fns->enter(state);
+			while (1)
+				pxa_cpu_pm_fns->enter(state);
+		}
+		pxa_cpu_pm_fns->restore(sleep_save);
 	}
 
-	pxa_cpu_pm_fns->restore(sleep_save);
-
 	pr_debug("*** made it back from resume\n");
 
 	return 0;

commit 26398a70ea35f153feb799fa850c71685667712b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 18 03:04:40 2007 -0700

    PM: Rename struct pm_ops and related things
    
    The name of 'struct pm_ops' suggests that it is related to the power
    management in general, but in fact it is only related to suspend.   Moreover,
    its name should indicate what this structure is used for, so it seems
    reasonable to change it to 'struct platform_suspend_ops'.   In that case, the
    name of the global variable of this type used by the PM core and the names of
    related functions should be changed accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index b59a81a8e7d3..a941c71c7d06 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -86,7 +86,7 @@ static int pxa_pm_valid(suspend_state_t state)
 	return -EINVAL;
 }
 
-static struct pm_ops pxa_pm_ops = {
+static struct platform_suspend_ops pxa_pm_ops = {
 	.valid		= pxa_pm_valid,
 	.enter		= pxa_pm_enter,
 };
@@ -104,7 +104,7 @@ static int __init pxa_pm_init(void)
 		return -ENOMEM;
 	}
 
-	pm_set_ops(&pxa_pm_ops);
+	suspend_set_ops(&pxa_pm_ops);
 	return 0;
 }
 

commit 711be5ccfe9a02ba560aa918a008c31ea4760163
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Wed Jul 18 11:38:45 2007 +0100

    [ARM] 4488/1: pxa: move pxa25x/pxa27x specific code out of pm.c
    
    1. introduce a structure pxa_cpu_pm_fns for pxa25x/pxa27x specific
       operations as follows:
    
            struct pxa_cpu_pm_fns {
                    int     save_size;
                    void    (*save)(unsigned long *);
                    void    (*restore)(unsigned long *);
                    int     (*valid)(suspend_state_t state);
                    void    (*enter)(suspend_state_t state);
            }
    
    2. processor specific registers saving and restoring are performed
       by calling the corresponding (*save) and (*restore)
    
    3. pxa_cpu_pm_fns->save_size should be initialized to the required
       size for processor specific registers saving, the allocated
       memory address will be passed to (*save) and (*restore)
    
       memory allocation happens early in pxa_pm_init(), and save_size
       should be assigned prior to this (which is usually true, since
       pxa_pm_init() happens in device_initcall()
    
    4. there're some redundancies for those SLEEP_SAVE_XXX and related
       macros, will be fixed later, one way possible is for the system
       devices to handle the specific registers saving and restoring
    
    Signed-off-by: eric miao <eric.y.miao@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index e66dbc26add1..b59a81a8e7d3 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -24,61 +24,13 @@
 #include <asm/arch/lubbock.h>
 #include <asm/mach/time.h>
 
-
-/*
- * Debug macros
- */
-#undef DEBUG
-
-#define SAVE(x)		sleep_save[SLEEP_SAVE_##x] = x
-#define RESTORE(x)	x = sleep_save[SLEEP_SAVE_##x]
-
-#define RESTORE_GPLEVEL(n) do { \
-	GPSR##n = sleep_save[SLEEP_SAVE_GPLR##n]; \
-	GPCR##n = ~sleep_save[SLEEP_SAVE_GPLR##n]; \
-} while (0)
-
-/*
- * List of global PXA peripheral registers to preserve.
- * More ones like CP and general purpose register values are preserved
- * with the stack pointer in sleep.S.
- */
-enum {	SLEEP_SAVE_START = 0,
-
-	SLEEP_SAVE_GPLR0, SLEEP_SAVE_GPLR1, SLEEP_SAVE_GPLR2, SLEEP_SAVE_GPLR3,
-	SLEEP_SAVE_GPDR0, SLEEP_SAVE_GPDR1, SLEEP_SAVE_GPDR2, SLEEP_SAVE_GPDR3,
-	SLEEP_SAVE_GRER0, SLEEP_SAVE_GRER1, SLEEP_SAVE_GRER2, SLEEP_SAVE_GRER3,
-	SLEEP_SAVE_GFER0, SLEEP_SAVE_GFER1, SLEEP_SAVE_GFER2, SLEEP_SAVE_GFER3,
-	SLEEP_SAVE_PGSR0, SLEEP_SAVE_PGSR1, SLEEP_SAVE_PGSR2, SLEEP_SAVE_PGSR3,
-
-	SLEEP_SAVE_GAFR0_L, SLEEP_SAVE_GAFR0_U,
-	SLEEP_SAVE_GAFR1_L, SLEEP_SAVE_GAFR1_U,
-	SLEEP_SAVE_GAFR2_L, SLEEP_SAVE_GAFR2_U,
-	SLEEP_SAVE_GAFR3_L, SLEEP_SAVE_GAFR3_U,
-
-	SLEEP_SAVE_PSTR,
-
-	SLEEP_SAVE_ICMR,
-	SLEEP_SAVE_CKEN,
-
-#ifdef CONFIG_PXA27x
- 	SLEEP_SAVE_MDREFR,
- 	SLEEP_SAVE_PWER, SLEEP_SAVE_PCFR, SLEEP_SAVE_PRER,
- 	SLEEP_SAVE_PFER, SLEEP_SAVE_PKWR,
-#endif
-
-	SLEEP_SAVE_CKSUM,
-
-	SLEEP_SAVE_SIZE
-};
-
+struct pxa_cpu_pm_fns *pxa_cpu_pm_fns;
+static unsigned long *sleep_save;
 
 int pxa_pm_enter(suspend_state_t state)
 {
-	unsigned long sleep_save[SLEEP_SAVE_SIZE];
-	unsigned long checksum = 0;
+	unsigned long sleep_save_checksum = 0, checksum = 0;
 	int i;
-	extern void pxa_cpu_pm_enter(suspend_state_t state);
 
 #ifdef CONFIG_IWMMXT
 	/* force any iWMMXt context to ram **/
@@ -86,100 +38,35 @@ int pxa_pm_enter(suspend_state_t state)
 		iwmmxt_task_disable(NULL);
 #endif
 
-	SAVE(GPLR0); SAVE(GPLR1); SAVE(GPLR2);
-	SAVE(GPDR0); SAVE(GPDR1); SAVE(GPDR2);
-	SAVE(GRER0); SAVE(GRER1); SAVE(GRER2);
-	SAVE(GFER0); SAVE(GFER1); SAVE(GFER2);
-	SAVE(PGSR0); SAVE(PGSR1); SAVE(PGSR2);
-
-	SAVE(GAFR0_L); SAVE(GAFR0_U);
-	SAVE(GAFR1_L); SAVE(GAFR1_U);
-	SAVE(GAFR2_L); SAVE(GAFR2_U);
-
-#ifdef CONFIG_PXA27x
-	SAVE(MDREFR);
-	SAVE(GPLR3); SAVE(GPDR3); SAVE(GRER3); SAVE(GFER3); SAVE(PGSR3);
-	SAVE(GAFR3_L); SAVE(GAFR3_U);
-	SAVE(PWER); SAVE(PCFR); SAVE(PRER);
-	SAVE(PFER); SAVE(PKWR);
-#endif
-
-	SAVE(ICMR);
-	ICMR = 0;
-
-	SAVE(CKEN);
-	SAVE(PSTR);
-
-	/* Note: wake up source are set up in each machine specific files */
-
-	/* clear GPIO transition detect  bits */
-	GEDR0 = GEDR0; GEDR1 = GEDR1; GEDR2 = GEDR2;
-#ifdef CONFIG_PXA27x
-	GEDR3 = GEDR3;
-#endif
+	pxa_cpu_pm_fns->save(sleep_save);
 
 	/* Clear sleep reset status */
 	RCSR = RCSR_SMR;
 
 	/* before sleeping, calculate and save a checksum */
-	for (i = 0; i < SLEEP_SAVE_SIZE - 1; i++)
-		checksum += sleep_save[i];
-	sleep_save[SLEEP_SAVE_CKSUM] = checksum;
+	for (i = 0; i < pxa_cpu_pm_fns->save_size - 1; i++)
+		sleep_save_checksum += sleep_save[i];
 
 	/* *** go zzz *** */
-	pxa_cpu_pm_enter(state);
-
+	pxa_cpu_pm_fns->enter(state);
 	cpu_init();
 
 	/* after sleeping, validate the checksum */
-	checksum = 0;
-	for (i = 0; i < SLEEP_SAVE_SIZE - 1; i++)
+	for (i = 0; i < pxa_cpu_pm_fns->save_size - 1; i++)
 		checksum += sleep_save[i];
 
 	/* if invalid, display message and wait for a hardware reset */
-	if (checksum != sleep_save[SLEEP_SAVE_CKSUM]) {
+	if (checksum != sleep_save_checksum) {
 #ifdef CONFIG_ARCH_LUBBOCK
 		LUB_HEXLED = 0xbadbadc5;
 #endif
 		while (1)
-			pxa_cpu_pm_enter(state);
+			pxa_cpu_pm_fns->enter(state);
 	}
 
-	/* ensure not to come back here if it wasn't intended */
-	PSPR = 0;
-
-	/* restore registers */
-	RESTORE_GPLEVEL(0); RESTORE_GPLEVEL(1); RESTORE_GPLEVEL(2);
-	RESTORE(GPDR0); RESTORE(GPDR1); RESTORE(GPDR2);
-	RESTORE(GAFR0_L); RESTORE(GAFR0_U);
-	RESTORE(GAFR1_L); RESTORE(GAFR1_U);
-	RESTORE(GAFR2_L); RESTORE(GAFR2_U);
-	RESTORE(GRER0); RESTORE(GRER1); RESTORE(GRER2);
-	RESTORE(GFER0); RESTORE(GFER1); RESTORE(GFER2);
-	RESTORE(PGSR0); RESTORE(PGSR1); RESTORE(PGSR2);
-
-#ifdef CONFIG_PXA27x
-	RESTORE(MDREFR);
-	RESTORE_GPLEVEL(3); RESTORE(GPDR3);
-	RESTORE(GAFR3_L); RESTORE(GAFR3_U);
-	RESTORE(GRER3); RESTORE(GFER3); RESTORE(PGSR3);
-	RESTORE(PWER); RESTORE(PCFR); RESTORE(PRER);
-	RESTORE(PFER); RESTORE(PKWR);
-#endif
-
-	PSSR = PSSR_RDH | PSSR_PH;
-
-	RESTORE(CKEN);
-
-	ICLR = 0;
-	ICCR = 1;
-	RESTORE(ICMR);
+	pxa_cpu_pm_fns->restore(sleep_save);
 
-	RESTORE(PSTR);
-
-#ifdef DEBUG
-	printk(KERN_DEBUG "*** made it back from resume\n");
-#endif
+	pr_debug("*** made it back from resume\n");
 
 	return 0;
 }
@@ -190,3 +77,35 @@ unsigned long sleep_phys_sp(void *sp)
 {
 	return virt_to_phys(sp);
 }
+
+static int pxa_pm_valid(suspend_state_t state)
+{
+	if (pxa_cpu_pm_fns)
+		return pxa_cpu_pm_fns->valid(state);
+
+	return -EINVAL;
+}
+
+static struct pm_ops pxa_pm_ops = {
+	.valid		= pxa_pm_valid,
+	.enter		= pxa_pm_enter,
+};
+
+static int __init pxa_pm_init(void)
+{
+	if (!pxa_cpu_pm_fns) {
+		printk(KERN_ERR "no valid pxa_cpu_pm_fns defined\n");
+		return -EINVAL;
+	}
+
+	sleep_save = kmalloc(pxa_cpu_pm_fns->save_size, GFP_KERNEL);
+	if (!sleep_save) {
+		printk(KERN_ERR "failed to alloc memory for pm save\n");
+		return -ENOMEM;
+	}
+
+	pm_set_ops(&pxa_pm_ops);
+	return 0;
+}
+
+device_initcall(pxa_pm_init);

commit 2aca0a865722fce435034cee5a33e1726fe10a9f
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Jun 27 09:56:05 2007 +0100

    [ARM] pxa: stop doing our own rtc management over suspend
    
    Remove the RTC management over a suspend/resume cycle.  Firstly,
    we may not be using the internal RTC for time keeping; some
    platforms have an external RTC for this inspite of the PXA having
    an internal RTC.  Secondly, the RTC library code handles updating
    system time on resume.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index d439ffa1b071..e66dbc26add1 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -77,7 +77,6 @@ int pxa_pm_enter(suspend_state_t state)
 {
 	unsigned long sleep_save[SLEEP_SAVE_SIZE];
 	unsigned long checksum = 0;
-	struct timespec delta, rtc;
 	int i;
 	extern void pxa_cpu_pm_enter(suspend_state_t state);
 
@@ -87,11 +86,6 @@ int pxa_pm_enter(suspend_state_t state)
 		iwmmxt_task_disable(NULL);
 #endif
 
-	/* preserve current time */
-	rtc.tv_sec = RCNR;
-	rtc.tv_nsec = 0;
-	save_time_delta(&delta, &rtc);
-
 	SAVE(GPLR0); SAVE(GPLR1); SAVE(GPLR2);
 	SAVE(GPDR0); SAVE(GPDR1); SAVE(GPDR2);
 	SAVE(GRER0); SAVE(GRER1); SAVE(GRER2);
@@ -183,10 +177,6 @@ int pxa_pm_enter(suspend_state_t state)
 
 	RESTORE(PSTR);
 
-	/* restore current time */
-	rtc.tv_sec = RCNR;
-	restore_time_delta(&delta, &rtc);
-
 #ifdef DEBUG
 	printk(KERN_DEBUG "*** made it back from resume\n");
 #endif

commit e176bb05fec4c00450302a75e81f8da3dc9e309e
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue May 15 11:16:10 2007 +0100

    [ARM] pxa: move pm_ops structure into CPU specific files
    
    Move the pm_ops structure into the PXA25x and PXA27x support
    files.  Remove the old pxa_pm_prepare() function, and rename
    the both pxa_cpu_pm_prepare() functions as pxa_pm_prepare().
    We'll fix that later.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 6d86203aef7b..d439ffa1b071 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -200,29 +200,3 @@ unsigned long sleep_phys_sp(void *sp)
 {
 	return virt_to_phys(sp);
 }
-
-/*
- * Called after processes are frozen, but before we shut down devices.
- */
-int pxa_pm_prepare(suspend_state_t state)
-{
-	extern int pxa_cpu_pm_prepare(suspend_state_t state);
-
-	return pxa_cpu_pm_prepare(state);
-}
-
-EXPORT_SYMBOL_GPL(pxa_pm_prepare);
-
-static struct pm_ops pxa_pm_ops = {
-	.prepare	= pxa_pm_prepare,
-	.enter		= pxa_pm_enter,
-	.valid		= pm_valid_only_mem,
-};
-
-static int __init pxa_pm_init(void)
-{
-	pm_set_ops(&pxa_pm_ops);
-	return 0;
-}
-
-device_initcall(pxa_pm_init);

commit f62c3f2c35874713ebbb6b6a4b9d9c6caaed4f14
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue May 15 11:03:24 2007 +0100

    [ARM] pxa: remove useless pxa_pm_finish() function
    
    pxa_pm_finish() does nothing but return zero.  The core code
    does nothing with this return value, and will not try to call
    the finish method in the pm_ops structure if it is NULL.
    
    Therefore, we can remove this useless function.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 6bf15ae73848..6d86203aef7b 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -213,20 +213,9 @@ int pxa_pm_prepare(suspend_state_t state)
 
 EXPORT_SYMBOL_GPL(pxa_pm_prepare);
 
-/*
- * Called after devices are re-setup, but before processes are thawed.
- */
-int pxa_pm_finish(suspend_state_t state)
-{
-	return 0;
-}
-
-EXPORT_SYMBOL_GPL(pxa_pm_finish);
-
 static struct pm_ops pxa_pm_ops = {
 	.prepare	= pxa_pm_prepare,
 	.enter		= pxa_pm_enter,
-	.finish		= pxa_pm_finish,
 	.valid		= pm_valid_only_mem,
 };
 

commit e8c9c502690efd24b7055bf608e7a3c34216848b
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Apr 30 15:09:54 2007 -0700

    power management: implement pm_ops.valid for everybody
    
    Almost all users of pm_ops only support mem sleep, don't check in .valid and
    don't reject any others in .prepare so users can be confused if they check
    /sys/power/state, especially when new states are added (these would then
    result in s-t-r although they're supposed to be something different).
    
    This patch implements a generic pm_valid_only_mem function that is then
    exported for users and puts it to use in almost all existing pm_ops.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Cc: David Brownell <david-b@pacbell.net>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: linux-pm@lists.linux-foundation.org
    Cc: Len Brown <lenb@kernel.org>
    Acked-by: Russell King <rmk@arm.linux.org.uk>
    Cc: Greg KH <greg@kroah.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 0a99ef43b36f..6bf15ae73848 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -227,6 +227,7 @@ static struct pm_ops pxa_pm_ops = {
 	.prepare	= pxa_pm_prepare,
 	.enter		= pxa_pm_enter,
 	.finish		= pxa_pm_finish,
+	.valid		= pm_valid_only_mem,
 };
 
 static int __init pxa_pm_init(void)

commit fe0c935a6cbf25d72a27c7a345df8a2151de0b74
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Apr 30 15:09:51 2007 -0700

    rework pm_ops pm_disk_mode, kill misuse
    
    This patch series cleans up some misconceptions about pm_ops.  Some users of
    the pm_ops structure attempt to use it to stop the user from entering suspend
    to disk, this, however, is not possible since the user can always use
    "shutdown" in /sys/power/disk and then the pm_ops are never invoked.  Also,
    platforms that don't support suspend to disk simply should not allow
    configuring SOFTWARE_SUSPEND (read the help text on it, it only selects
    suspend to disk and nothing else, all the other stuff depends on PM).
    
    The pm_ops structure is actually intended to provide a way to enter
    platform-defined sleep states (currently supported states are "standby" and
    "mem" (suspend to ram)) and additionally (if SOFTWARE_SUSPEND is configured)
    allows a platform to support a platform specific way to enter low-power mode
    once everything has been saved to disk.  This is currently only used by ACPI
    (S4).
    
    This patch:
    
    The pm_ops.pm_disk_mode is used in totally bogus ways since nobody really
    seems to understand what it actually does.
    
    This patch clarifies the pm_disk_mode description.
    
    It also removes all the arm and sh users that think they can veto suspend to
    disk via pm_ops; not so since the user can always do echo shutdown >
    /sys/power/disk, they need to find a better way involving Kconfig or such.
    
    ACPI is the only user left with a non-zero pm_disk_mode.
    
    The patch also sets the default mode to shutdown again, but when a new pm_ops
    is registered its pm_disk_mode is selected as default, that way the default
    stays for ACPI where it is apparently required.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Cc: David Brownell <david-b@pacbell.net>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: <linux-pm@lists.linux-foundation.org>
    Cc: Len Brown <lenb@kernel.org>
    Acked-by: Russell King <rmk@arm.linux.org.uk>
    Cc: Greg KH <greg@kroah.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index b4d8276d6050..0a99ef43b36f 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -223,11 +223,7 @@ int pxa_pm_finish(suspend_state_t state)
 
 EXPORT_SYMBOL_GPL(pxa_pm_finish);
 
-/*
- * Set to PM_DISK_FIRMWARE so we can quickly veto suspend-to-disk.
- */
 static struct pm_ops pxa_pm_ops = {
-	.pm_disk_mode	= PM_DISK_FIRMWARE,
 	.prepare	= pxa_pm_prepare,
 	.enter		= pxa_pm_enter,
 	.finish		= pxa_pm_finish,

commit afe4b25e7d9260d85fccb2d13c9933a987bdfc8a
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Sun Dec 3 18:51:14 2006 +0100

    [ARM] 3881/4: xscale: clean up cp0/cp1 handling
    
    XScale cores either have a DSP coprocessor (which contains a single
    40 bit accumulator register), or an iWMMXt coprocessor (which contains
    eight 64 bit registers.)
    
    Because of the small amount of state in the DSP coprocessor, access to
    the DSP coprocessor (CP0) is always enabled, and DSP context switching
    is done unconditionally on every task switch.  Access to the iWMMXt
    coprocessor (CP0/CP1) is enabled only when an iWMMXt instruction is
    first issued, and iWMMXt context switching is done lazily.
    
    CONFIG_IWMMXT is supposed to mean 'the cpu we will be running on will
    have iWMMXt support', but boards are supposed to select this config
    symbol by hand, and at least one pxa27x board doesn't get this right,
    so on that board, proc-xscale.S will incorrectly assume that we have a
    DSP coprocessor, enable CP0 on boot, and we will then only save the
    first iWMMXt register (wR0) on context switches, which is Bad.
    
    This patch redefines CONFIG_IWMMXT as 'the cpu we will be running on
    might have iWMMXt support, and we will enable iWMMXt context switching
    if it does.'  This means that with this patch, running a CONFIG_IWMMXT=n
    kernel on an iWMMXt-capable CPU will no longer potentially corrupt iWMMXt
    state over context switches, and running a CONFIG_IWMMXT=y kernel on a
    non-iWMMXt capable CPU will still do DSP context save/restore.
    
    These changes should make iWMMXt work on PXA3xx, and as a side effect,
    enable proper acc0 save/restore on non-iWMMXt capable xsc3 cores such
    as IOP13xx and IXP23xx (which will not have CONFIG_CPU_XSCALE defined),
    as well as setting and using HWCAP_IWMMXT properly.
    
    Signed-off-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Acked-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 2112c414f0e2..b4d8276d6050 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -83,7 +83,8 @@ int pxa_pm_enter(suspend_state_t state)
 
 #ifdef CONFIG_IWMMXT
 	/* force any iWMMXt context to ram **/
-	iwmmxt_task_disable(NULL);
+	if (elf_hwcap & HWCAP_IWMMXT)
+		iwmmxt_task_disable(NULL);
 #endif
 
 	/* preserve current time */

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 852ea72d8c80..2112c414f0e2 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -10,7 +10,6 @@
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License.
  */
-#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/suspend.h>

commit 1ee9530a71686436dbeb5f31dd5b925c39cf71d7
Author: Lothar Wassmann <LW@KARO-electronics.de>
Date:   Mon Dec 12 16:44:05 2005 +0000

    [ARM] 3201/1: PXA27x: Prevent hangup during resume due to inadvertedly enabling MBREQ (replaces: 3198/1)
    
    Patch from Lothar Wassmann
    
    The patch makes sure, that the ouptut functions of pins are restored
    before restoring the Alternat Function settings, preventing pins from
    being intermediately configured for undefined or unwanted alternate
    functions.
    
    Here is the original comment:
    I've got a PXA270 system that uses GPIO80 as nCS4. This system did
    hang on resume. Digging into the problem I found that the processor
    stalled immediately when restoring the GAFR2_U register which restored
    the alternate function for GPIO80. Since the GPDR registers were
    restored after the GAFR registers, the offending GPIO was configured
    as input at this point.
    Thus the alternate function that was in effect after restoring the
    GAFR was in fact the input function "MBREQ" instead of the output
    function "nCS4". The "PXA27x Processor Family Developer's Manual"
    (Footnote in Table 6-1 on page 6-3) states that:
    "The MBREQ alternate function must not be enabled until the PSSR[RDH]
    bit field is cleared. For more details, see Table 3-15, "PSSR Bit
    Definitions" on page 3-71."
    
    There is another note in the Developer's Manual (chapter 24.4.2
    "GPIO operation as Alternate Function" on page 24-4)
    stating that:
    "Configuring a GPIO for an alternate function that is not defined for
    it causes unpredictable results."
    
    Since some GPIOs have no input function defined, and to prevent
    inadvertedly programming the MBREQ function on some pin, the GAFR
    registers should be restored after the GPDR registers have been
    restored.
    
    Additional provisions have to be made when the MBREQ function is
    actually required. The corresponding GAFR bits should not be restored
    with the regular GAFR restore, but must be set only after the PSSR
    bits have been cleared.
    
    Signed-off-by: Lothar Wassmann <LW@KARO-electronics.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index f74b9af112dc..852ea72d8c80 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -155,19 +155,20 @@ int pxa_pm_enter(suspend_state_t state)
 	PSPR = 0;
 
 	/* restore registers */
+	RESTORE_GPLEVEL(0); RESTORE_GPLEVEL(1); RESTORE_GPLEVEL(2);
+	RESTORE(GPDR0); RESTORE(GPDR1); RESTORE(GPDR2);
 	RESTORE(GAFR0_L); RESTORE(GAFR0_U);
 	RESTORE(GAFR1_L); RESTORE(GAFR1_U);
 	RESTORE(GAFR2_L); RESTORE(GAFR2_U);
-	RESTORE_GPLEVEL(0); RESTORE_GPLEVEL(1); RESTORE_GPLEVEL(2);
-	RESTORE(GPDR0); RESTORE(GPDR1); RESTORE(GPDR2);
 	RESTORE(GRER0); RESTORE(GRER1); RESTORE(GRER2);
 	RESTORE(GFER0); RESTORE(GFER1); RESTORE(GFER2);
 	RESTORE(PGSR0); RESTORE(PGSR1); RESTORE(PGSR2);
 
 #ifdef CONFIG_PXA27x
 	RESTORE(MDREFR);
-	RESTORE(GAFR3_L); RESTORE(GAFR3_U); RESTORE_GPLEVEL(3);
-	RESTORE(GPDR3); RESTORE(GRER3); RESTORE(GFER3); RESTORE(PGSR3);
+	RESTORE_GPLEVEL(3); RESTORE(GPDR3);
+	RESTORE(GAFR3_L); RESTORE(GAFR3_U);
+	RESTORE(GRER3); RESTORE(GFER3); RESTORE(PGSR3);
 	RESTORE(PWER); RESTORE(PCFR); RESTORE(PRER);
 	RESTORE(PFER); RESTORE(PKWR);
 #endif

commit 756c7b748926b0baec6d2a921c3711679282c8fd
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Sun Nov 6 15:03:23 2005 +0000

    [ARM] 3113/1: PXA: Allow machines to override (and also reuse) pxa pm functions
    
    Patch from Richard Purdie
    
    Update the PXA pm.c file to allow machines (such as the Sharp
    Zaurus) to override the standard pm functions but reuse/wrap them
    where needed.
    
    The init call is made slightly earlier to give machine code an init
    level to override them in removing any race.
    
    Signed-off-by: Richard Purdie
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index ac4dd4336160..f74b9af112dc 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -12,6 +12,7 @@
  */
 #include <linux/config.h>
 #include <linux/init.h>
+#include <linux/module.h>
 #include <linux/suspend.h>
 #include <linux/errno.h>
 #include <linux/time.h>
@@ -19,6 +20,7 @@
 #include <asm/hardware.h>
 #include <asm/memory.h>
 #include <asm/system.h>
+#include <asm/arch/pm.h>
 #include <asm/arch/pxa-regs.h>
 #include <asm/arch/lubbock.h>
 #include <asm/mach/time.h>
@@ -72,7 +74,7 @@ enum {	SLEEP_SAVE_START = 0,
 };
 
 
-static int pxa_pm_enter(suspend_state_t state)
+int pxa_pm_enter(suspend_state_t state)
 {
 	unsigned long sleep_save[SLEEP_SAVE_SIZE];
 	unsigned long checksum = 0;
@@ -191,6 +193,8 @@ static int pxa_pm_enter(suspend_state_t state)
 	return 0;
 }
 
+EXPORT_SYMBOL_GPL(pxa_pm_enter);
+
 unsigned long sleep_phys_sp(void *sp)
 {
 	return virt_to_phys(sp);
@@ -199,21 +203,25 @@ unsigned long sleep_phys_sp(void *sp)
 /*
  * Called after processes are frozen, but before we shut down devices.
  */
-static int pxa_pm_prepare(suspend_state_t state)
+int pxa_pm_prepare(suspend_state_t state)
 {
 	extern int pxa_cpu_pm_prepare(suspend_state_t state);
 
 	return pxa_cpu_pm_prepare(state);
 }
 
+EXPORT_SYMBOL_GPL(pxa_pm_prepare);
+
 /*
  * Called after devices are re-setup, but before processes are thawed.
  */
-static int pxa_pm_finish(suspend_state_t state)
+int pxa_pm_finish(suspend_state_t state)
 {
 	return 0;
 }
 
+EXPORT_SYMBOL_GPL(pxa_pm_finish);
+
 /*
  * Set to PM_DISK_FIRMWARE so we can quickly veto suspend-to-disk.
  */
@@ -230,4 +238,4 @@ static int __init pxa_pm_init(void)
 	return 0;
 }
 
-late_initcall(pxa_pm_init);
+device_initcall(pxa_pm_init);

commit 36c5ed23b9f535d1c79986efb45f9c1f115e0997
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Jun 19 18:39:33 2005 +0100

    [PATCH] ARM SMP: Fix PXA/SA11x0 suspend resume crash
    
    We need to re-initialise the stack pointers for undefined, IRQ
    and abort mode handlers whenever we resume.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 9799fe80df23..ac4dd4336160 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -133,6 +133,8 @@ static int pxa_pm_enter(suspend_state_t state)
 	/* *** go zzz *** */
 	pxa_cpu_pm_enter(state);
 
+	cpu_init();
+
 	/* after sleeping, validate the checksum */
 	checksum = 0;
 	for (i = 0; i < SLEEP_SAVE_SIZE - 1; i++)

commit 8775420d2fbcfff866995471ea5f6130d14d121c
Author: Todd Poynor <tpoynor@com.rmk.(none)>
Date:   Fri Jun 3 20:52:27 2005 +0100

    [PATCH] ARM: 2691/1: PXA27x sleep fixes take 2
    
    Patch from Todd Poynor
    
    PXA27x sleep fixes:
    * set additional sleep/wakeup registers for Mainstone boards.
    * move CKEN=0 to pxa25x-specific code; that value is harmful on pxa27x.
    * save/restore additional registers, including some found necessary for
    C5 processors and/or newer blob versions.
    * enable future support of additional sleep modes for PXA27x (eg,
    standby, deep sleep).
    * split off cpu-specific sleep processing between pxa27x and pxa25x into
    separate files (partly in preparation for additional sleep modes).
    Includes fixes from David Burrage.
    
    Signed-off-by: Todd Poynor
    Signed-off-by: Nicolas Pitre
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
index 82a4bf34c251..9799fe80df23 100644
--- a/arch/arm/mach-pxa/pm.c
+++ b/arch/arm/mach-pxa/pm.c
@@ -29,9 +29,6 @@
  */
 #undef DEBUG
 
-extern void pxa_cpu_suspend(void);
-extern void pxa_cpu_resume(void);
-
 #define SAVE(x)		sleep_save[SLEEP_SAVE_##x] = x
 #define RESTORE(x)	x = sleep_save[SLEEP_SAVE_##x]
 
@@ -63,6 +60,12 @@ enum {	SLEEP_SAVE_START = 0,
 	SLEEP_SAVE_ICMR,
 	SLEEP_SAVE_CKEN,
 
+#ifdef CONFIG_PXA27x
+ 	SLEEP_SAVE_MDREFR,
+ 	SLEEP_SAVE_PWER, SLEEP_SAVE_PCFR, SLEEP_SAVE_PRER,
+ 	SLEEP_SAVE_PFER, SLEEP_SAVE_PKWR,
+#endif
+
 	SLEEP_SAVE_CKSUM,
 
 	SLEEP_SAVE_SIZE
@@ -75,9 +78,7 @@ static int pxa_pm_enter(suspend_state_t state)
 	unsigned long checksum = 0;
 	struct timespec delta, rtc;
 	int i;
-
-	if (state != PM_SUSPEND_MEM)
-		return -EINVAL;
+	extern void pxa_cpu_pm_enter(suspend_state_t state);
 
 #ifdef CONFIG_IWMMXT
 	/* force any iWMMXt context to ram **/
@@ -100,16 +101,17 @@ static int pxa_pm_enter(suspend_state_t state)
 	SAVE(GAFR2_L); SAVE(GAFR2_U);
 
 #ifdef CONFIG_PXA27x
+	SAVE(MDREFR);
 	SAVE(GPLR3); SAVE(GPDR3); SAVE(GRER3); SAVE(GFER3); SAVE(PGSR3);
 	SAVE(GAFR3_L); SAVE(GAFR3_U);
+	SAVE(PWER); SAVE(PCFR); SAVE(PRER);
+	SAVE(PFER); SAVE(PKWR);
 #endif
 
 	SAVE(ICMR);
 	ICMR = 0;
 
 	SAVE(CKEN);
-	CKEN = 0;
-
 	SAVE(PSTR);
 
 	/* Note: wake up source are set up in each machine specific files */
@@ -123,16 +125,13 @@ static int pxa_pm_enter(suspend_state_t state)
 	/* Clear sleep reset status */
 	RCSR = RCSR_SMR;
 
-	/* set resume return address */
-	PSPR = virt_to_phys(pxa_cpu_resume);
-
 	/* before sleeping, calculate and save a checksum */
 	for (i = 0; i < SLEEP_SAVE_SIZE - 1; i++)
 		checksum += sleep_save[i];
 	sleep_save[SLEEP_SAVE_CKSUM] = checksum;
 
 	/* *** go zzz *** */
-	pxa_cpu_suspend();
+	pxa_cpu_pm_enter(state);
 
 	/* after sleeping, validate the checksum */
 	checksum = 0;
@@ -145,7 +144,7 @@ static int pxa_pm_enter(suspend_state_t state)
 		LUB_HEXLED = 0xbadbadc5;
 #endif
 		while (1)
-			pxa_cpu_suspend();
+			pxa_cpu_pm_enter(state);
 	}
 
 	/* ensure not to come back here if it wasn't intended */
@@ -162,8 +161,11 @@ static int pxa_pm_enter(suspend_state_t state)
 	RESTORE(PGSR0); RESTORE(PGSR1); RESTORE(PGSR2);
 
 #ifdef CONFIG_PXA27x
+	RESTORE(MDREFR);
 	RESTORE(GAFR3_L); RESTORE(GAFR3_U); RESTORE_GPLEVEL(3);
 	RESTORE(GPDR3); RESTORE(GRER3); RESTORE(GFER3); RESTORE(PGSR3);
+	RESTORE(PWER); RESTORE(PCFR); RESTORE(PRER);
+	RESTORE(PFER); RESTORE(PKWR);
 #endif
 
 	PSSR = PSSR_RDH | PSSR_PH;
@@ -197,7 +199,9 @@ unsigned long sleep_phys_sp(void *sp)
  */
 static int pxa_pm_prepare(suspend_state_t state)
 {
-	return 0;
+	extern int pxa_cpu_pm_prepare(suspend_state_t state);
+
+	return pxa_cpu_pm_prepare(state);
 }
 
 /*

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/arm/mach-pxa/pm.c b/arch/arm/mach-pxa/pm.c
new file mode 100644
index 000000000000..82a4bf34c251
--- /dev/null
+++ b/arch/arm/mach-pxa/pm.c
@@ -0,0 +1,227 @@
+/*
+ * PXA250/210 Power Management Routines
+ *
+ * Original code for the SA11x0:
+ * Copyright (c) 2001 Cliff Brake <cbrake@accelent.com>
+ *
+ * Modified for the PXA250 by Nicolas Pitre:
+ * Copyright (c) 2002 Monta Vista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/suspend.h>
+#include <linux/errno.h>
+#include <linux/time.h>
+
+#include <asm/hardware.h>
+#include <asm/memory.h>
+#include <asm/system.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/lubbock.h>
+#include <asm/mach/time.h>
+
+
+/*
+ * Debug macros
+ */
+#undef DEBUG
+
+extern void pxa_cpu_suspend(void);
+extern void pxa_cpu_resume(void);
+
+#define SAVE(x)		sleep_save[SLEEP_SAVE_##x] = x
+#define RESTORE(x)	x = sleep_save[SLEEP_SAVE_##x]
+
+#define RESTORE_GPLEVEL(n) do { \
+	GPSR##n = sleep_save[SLEEP_SAVE_GPLR##n]; \
+	GPCR##n = ~sleep_save[SLEEP_SAVE_GPLR##n]; \
+} while (0)
+
+/*
+ * List of global PXA peripheral registers to preserve.
+ * More ones like CP and general purpose register values are preserved
+ * with the stack pointer in sleep.S.
+ */
+enum {	SLEEP_SAVE_START = 0,
+
+	SLEEP_SAVE_GPLR0, SLEEP_SAVE_GPLR1, SLEEP_SAVE_GPLR2, SLEEP_SAVE_GPLR3,
+	SLEEP_SAVE_GPDR0, SLEEP_SAVE_GPDR1, SLEEP_SAVE_GPDR2, SLEEP_SAVE_GPDR3,
+	SLEEP_SAVE_GRER0, SLEEP_SAVE_GRER1, SLEEP_SAVE_GRER2, SLEEP_SAVE_GRER3,
+	SLEEP_SAVE_GFER0, SLEEP_SAVE_GFER1, SLEEP_SAVE_GFER2, SLEEP_SAVE_GFER3,
+	SLEEP_SAVE_PGSR0, SLEEP_SAVE_PGSR1, SLEEP_SAVE_PGSR2, SLEEP_SAVE_PGSR3,
+
+	SLEEP_SAVE_GAFR0_L, SLEEP_SAVE_GAFR0_U,
+	SLEEP_SAVE_GAFR1_L, SLEEP_SAVE_GAFR1_U,
+	SLEEP_SAVE_GAFR2_L, SLEEP_SAVE_GAFR2_U,
+	SLEEP_SAVE_GAFR3_L, SLEEP_SAVE_GAFR3_U,
+
+	SLEEP_SAVE_PSTR,
+
+	SLEEP_SAVE_ICMR,
+	SLEEP_SAVE_CKEN,
+
+	SLEEP_SAVE_CKSUM,
+
+	SLEEP_SAVE_SIZE
+};
+
+
+static int pxa_pm_enter(suspend_state_t state)
+{
+	unsigned long sleep_save[SLEEP_SAVE_SIZE];
+	unsigned long checksum = 0;
+	struct timespec delta, rtc;
+	int i;
+
+	if (state != PM_SUSPEND_MEM)
+		return -EINVAL;
+
+#ifdef CONFIG_IWMMXT
+	/* force any iWMMXt context to ram **/
+	iwmmxt_task_disable(NULL);
+#endif
+
+	/* preserve current time */
+	rtc.tv_sec = RCNR;
+	rtc.tv_nsec = 0;
+	save_time_delta(&delta, &rtc);
+
+	SAVE(GPLR0); SAVE(GPLR1); SAVE(GPLR2);
+	SAVE(GPDR0); SAVE(GPDR1); SAVE(GPDR2);
+	SAVE(GRER0); SAVE(GRER1); SAVE(GRER2);
+	SAVE(GFER0); SAVE(GFER1); SAVE(GFER2);
+	SAVE(PGSR0); SAVE(PGSR1); SAVE(PGSR2);
+
+	SAVE(GAFR0_L); SAVE(GAFR0_U);
+	SAVE(GAFR1_L); SAVE(GAFR1_U);
+	SAVE(GAFR2_L); SAVE(GAFR2_U);
+
+#ifdef CONFIG_PXA27x
+	SAVE(GPLR3); SAVE(GPDR3); SAVE(GRER3); SAVE(GFER3); SAVE(PGSR3);
+	SAVE(GAFR3_L); SAVE(GAFR3_U);
+#endif
+
+	SAVE(ICMR);
+	ICMR = 0;
+
+	SAVE(CKEN);
+	CKEN = 0;
+
+	SAVE(PSTR);
+
+	/* Note: wake up source are set up in each machine specific files */
+
+	/* clear GPIO transition detect  bits */
+	GEDR0 = GEDR0; GEDR1 = GEDR1; GEDR2 = GEDR2;
+#ifdef CONFIG_PXA27x
+	GEDR3 = GEDR3;
+#endif
+
+	/* Clear sleep reset status */
+	RCSR = RCSR_SMR;
+
+	/* set resume return address */
+	PSPR = virt_to_phys(pxa_cpu_resume);
+
+	/* before sleeping, calculate and save a checksum */
+	for (i = 0; i < SLEEP_SAVE_SIZE - 1; i++)
+		checksum += sleep_save[i];
+	sleep_save[SLEEP_SAVE_CKSUM] = checksum;
+
+	/* *** go zzz *** */
+	pxa_cpu_suspend();
+
+	/* after sleeping, validate the checksum */
+	checksum = 0;
+	for (i = 0; i < SLEEP_SAVE_SIZE - 1; i++)
+		checksum += sleep_save[i];
+
+	/* if invalid, display message and wait for a hardware reset */
+	if (checksum != sleep_save[SLEEP_SAVE_CKSUM]) {
+#ifdef CONFIG_ARCH_LUBBOCK
+		LUB_HEXLED = 0xbadbadc5;
+#endif
+		while (1)
+			pxa_cpu_suspend();
+	}
+
+	/* ensure not to come back here if it wasn't intended */
+	PSPR = 0;
+
+	/* restore registers */
+	RESTORE(GAFR0_L); RESTORE(GAFR0_U);
+	RESTORE(GAFR1_L); RESTORE(GAFR1_U);
+	RESTORE(GAFR2_L); RESTORE(GAFR2_U);
+	RESTORE_GPLEVEL(0); RESTORE_GPLEVEL(1); RESTORE_GPLEVEL(2);
+	RESTORE(GPDR0); RESTORE(GPDR1); RESTORE(GPDR2);
+	RESTORE(GRER0); RESTORE(GRER1); RESTORE(GRER2);
+	RESTORE(GFER0); RESTORE(GFER1); RESTORE(GFER2);
+	RESTORE(PGSR0); RESTORE(PGSR1); RESTORE(PGSR2);
+
+#ifdef CONFIG_PXA27x
+	RESTORE(GAFR3_L); RESTORE(GAFR3_U); RESTORE_GPLEVEL(3);
+	RESTORE(GPDR3); RESTORE(GRER3); RESTORE(GFER3); RESTORE(PGSR3);
+#endif
+
+	PSSR = PSSR_RDH | PSSR_PH;
+
+	RESTORE(CKEN);
+
+	ICLR = 0;
+	ICCR = 1;
+	RESTORE(ICMR);
+
+	RESTORE(PSTR);
+
+	/* restore current time */
+	rtc.tv_sec = RCNR;
+	restore_time_delta(&delta, &rtc);
+
+#ifdef DEBUG
+	printk(KERN_DEBUG "*** made it back from resume\n");
+#endif
+
+	return 0;
+}
+
+unsigned long sleep_phys_sp(void *sp)
+{
+	return virt_to_phys(sp);
+}
+
+/*
+ * Called after processes are frozen, but before we shut down devices.
+ */
+static int pxa_pm_prepare(suspend_state_t state)
+{
+	return 0;
+}
+
+/*
+ * Called after devices are re-setup, but before processes are thawed.
+ */
+static int pxa_pm_finish(suspend_state_t state)
+{
+	return 0;
+}
+
+/*
+ * Set to PM_DISK_FIRMWARE so we can quickly veto suspend-to-disk.
+ */
+static struct pm_ops pxa_pm_ops = {
+	.pm_disk_mode	= PM_DISK_FIRMWARE,
+	.prepare	= pxa_pm_prepare,
+	.enter		= pxa_pm_enter,
+	.finish		= pxa_pm_finish,
+};
+
+static int __init pxa_pm_init(void)
+{
+	pm_set_ops(&pxa_pm_ops);
+	return 0;
+}
+
+late_initcall(pxa_pm_init);
