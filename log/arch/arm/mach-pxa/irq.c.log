commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 4e8c2116808e..74efc3ab595f 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  linux/arch/arm/mach-pxa/irq.c
  *
@@ -6,10 +7,6 @@
  *  Author:	Nicolas Pitre
  *  Created:	Jun 15, 2001
  *  Copyright:	MontaVista Software Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
  */
 #include <linux/bitops.h>
 #include <linux/init.h>

commit 0c1049dcb4ceec640d8bd797335bcbebdcab44d2
Author: Daniel Mack <daniel@zonque.org>
Date:   Fri Jul 6 22:15:00 2018 +0200

    ARM: pxa: irq: fix handling of ICMR registers in suspend/resume
    
    PXA3xx platforms have 56 interrupts that are stored in two ICMR
    registers. The code in pxa_irq_suspend() and pxa_irq_resume() however
    does a simple division by 32 which only leads to one register being
    saved at suspend and restored at resume time. The NAND interrupt
    setting, for instance, is lost.
    
    Fix this by using DIV_ROUND_UP() instead.
    
    Signed-off-by: Daniel Mack <daniel@zonque.org>
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 9c10248fadcc..4e8c2116808e 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -185,7 +185,7 @@ static int pxa_irq_suspend(void)
 {
 	int i;
 
-	for (i = 0; i < pxa_internal_irq_nr / 32; i++) {
+	for (i = 0; i < DIV_ROUND_UP(pxa_internal_irq_nr, 32); i++) {
 		void __iomem *base = irq_base(i);
 
 		saved_icmr[i] = __raw_readl(base + ICMR);
@@ -204,7 +204,7 @@ static void pxa_irq_resume(void)
 {
 	int i;
 
-	for (i = 0; i < pxa_internal_irq_nr / 32; i++) {
+	for (i = 0; i < DIV_ROUND_UP(pxa_internal_irq_nr, 32); i++) {
 		void __iomem *base = irq_base(i);
 
 		__raw_writel(saved_icmr[i], base + ICMR);

commit e8d36d5dbb6a6ec4f5222f8775d664ec29d5527d
Author: Rob Herring <robh@kernel.org>
Date:   Mon Jul 27 15:55:13 2015 -0500

    ARM: kill off set_irq_flags usage
    
    set_irq_flags is ARM specific with custom flags which have genirq
    equivalents. Convert drivers to use the genirq interfaces directly, so we
    can kill off set_irq_flags. The translation of flags is as follows:
    
    IRQF_VALID -> !IRQ_NOREQUEST
    IRQF_PROBE -> !IRQ_NOPROBE
    IRQF_NOAUTOEN -> IRQ_NOAUTOEN
    
    For IRQs managed by an irqdomain, the irqdomain core code handles clearing
    and setting IRQ_NOREQUEST already, so there is no need to do this in
    .map() functions and we can simply remove the set_irq_flags calls. Some
    users also modify IRQ_NOPROBE and this has been maintained although it
    is not clear that is really needed. There appears to be a great deal of
    blind copy and paste of this code.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Sekhar Nori <nsekhar@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Gregory Clement <gregory.clement@free-electrons.com>
    Acked-by: Hans Ulli Kroll <ulli.kroll@googlemail.com>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Acked-by: Krzysztof Halasa <khalasa@piap.pl>
    Cc: Greg Ungerer <gerg@uclinux.org>
    Cc: Roland Stigge <stigge@antcom.de>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Daniel Mack <daniel@zonque.org>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: Robert Jarzmik <robert.jarzmik@free.fr>
    Cc: Simtec Linux Team <linux@simtec.co.uk>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Acked-by: Wan ZongShun <mcuos.com@gmail.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-omap@vger.kernel.org
    Cc: linux-samsung-soc@vger.kernel.org
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 98608c5575cb..9c10248fadcc 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -133,7 +133,6 @@ static int pxa_irq_map(struct irq_domain *h, unsigned int virq,
 	irq_set_chip_and_handler(virq, &pxa_internal_irq_chip,
 				 handle_level_irq);
 	irq_set_chip_data(virq, base);
-	set_irq_flags(virq, IRQF_VALID);
 
 	return 0;
 }

commit 64227114c676d9b1fefa4d5070534f3d82d23711
Author: Krzysztof Kozlowski <k.kozlowski.k@gmail.com>
Date:   Mon Apr 27 21:50:46 2015 +0900

    ARM: pxa: Constify irq_domain_ops
    
    The irq_domain_ops are not modified by the driver and the irqdomain core
    code accepts pointer to a const data.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski.k@gmail.com>
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 89a7c06570d3..98608c5575cb 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -138,7 +138,7 @@ static int pxa_irq_map(struct irq_domain *h, unsigned int virq,
 	return 0;
 }
 
-static struct irq_domain_ops pxa_irq_ops = {
+static const struct irq_domain_ops pxa_irq_ops = {
 	.map    = pxa_irq_map,
 	.xlate  = irq_domain_xlate_onecell,
 };

commit d6cf30ca716b347587b35923eda400ad2d9e8832
Author: Robert Jarzmik <robert.jarzmik@free.fr>
Date:   Sat Feb 14 22:41:56 2015 +0100

    ARM: pxa: fix pxa interrupts handling in DT
    
    The commit "ARM: pxa: arbitrarily set first interrupt number" changed
    the first pxa interrupt to 16.
    
    As a consequence, device-tree builds got broken, because :
     - pxa_mask_irq() and pxa_unmask_irq() are using IRQ_BIT()
     - IRQ_BIT(x) calculates the interrupts as : x - PXA_IRQ(0)
    
    Before the commit, the first interrupt shift, PXA_IRQ(0) was 0,
    therefore IRQ_BIT(x) was x. After the change, it is necessary that the
    same shift of 16 is applied between the virtual interrupt number and the
    hardware irq number.
    
    This situation comes from the common irq_chip shared between legacy
    platform builds and device-tree builds.
    
    Fix the broken interrupts in DT case by adding this shift in the DT case
    too.
    
    As a consequence of the IRQ_BIT() is removed alltogether from interrupts
    handling, even in the platform data types of platforms :
     - a legacy irq domain is used
     - the irq_chip handles hardware interrupts
     - the virtual to hardware interrupt conversion is fully handled by irq
       domain mechanics
    
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 0eecd83c624e..89a7c06570d3 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -11,6 +11,7 @@
  *  it under the terms of the GNU General Public License version 2 as
  *  published by the Free Software Foundation.
  */
+#include <linux/bitops.h>
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/interrupt.h>
@@ -40,7 +41,6 @@
 #define ICHP_VAL_IRQ		(1 << 31)
 #define ICHP_IRQ(i)		(((i) >> 16) & 0x7fff)
 #define IPR_VALID		(1 << 31)
-#define IRQ_BIT(n)		(((n) - PXA_IRQ(0)) & 0x1f)
 
 #define MAX_INTERNAL_IRQS	128
 
@@ -51,6 +51,7 @@
 static void __iomem *pxa_irq_base;
 static int pxa_internal_irq_nr;
 static bool cpu_has_ipr;
+static struct irq_domain *pxa_irq_domain;
 
 static inline void __iomem *irq_base(int i)
 {
@@ -66,18 +67,20 @@ static inline void __iomem *irq_base(int i)
 void pxa_mask_irq(struct irq_data *d)
 {
 	void __iomem *base = irq_data_get_irq_chip_data(d);
+	irq_hw_number_t irq = irqd_to_hwirq(d);
 	uint32_t icmr = __raw_readl(base + ICMR);
 
-	icmr &= ~(1 << IRQ_BIT(d->irq));
+	icmr &= ~BIT(irq & 0x1f);
 	__raw_writel(icmr, base + ICMR);
 }
 
 void pxa_unmask_irq(struct irq_data *d)
 {
 	void __iomem *base = irq_data_get_irq_chip_data(d);
+	irq_hw_number_t irq = irqd_to_hwirq(d);
 	uint32_t icmr = __raw_readl(base + ICMR);
 
-	icmr |= 1 << IRQ_BIT(d->irq);
+	icmr |= BIT(irq & 0x1f);
 	__raw_writel(icmr, base + ICMR);
 }
 
@@ -118,40 +121,63 @@ asmlinkage void __exception_irq_entry ichp_handle_irq(struct pt_regs *regs)
 	} while (1);
 }
 
-void __init pxa_init_irq(int irq_nr, int (*fn)(struct irq_data *, unsigned int))
+static int pxa_irq_map(struct irq_domain *h, unsigned int virq,
+		       irq_hw_number_t hw)
 {
-	int irq, i, n;
+	void __iomem *base = irq_base(hw / 32);
 
-	BUG_ON(irq_nr > MAX_INTERNAL_IRQS);
+	/* initialize interrupt priority */
+	if (cpu_has_ipr)
+		__raw_writel(hw | IPR_VALID, pxa_irq_base + IPR(hw));
+
+	irq_set_chip_and_handler(virq, &pxa_internal_irq_chip,
+				 handle_level_irq);
+	irq_set_chip_data(virq, base);
+	set_irq_flags(virq, IRQF_VALID);
+
+	return 0;
+}
+
+static struct irq_domain_ops pxa_irq_ops = {
+	.map    = pxa_irq_map,
+	.xlate  = irq_domain_xlate_onecell,
+};
+
+static __init void
+pxa_init_irq_common(struct device_node *node, int irq_nr,
+		    int (*fn)(struct irq_data *, unsigned int))
+{
+	int n;
 
 	pxa_internal_irq_nr = irq_nr;
-	cpu_has_ipr = !cpu_is_pxa25x();
-	pxa_irq_base = io_p2v(0x40d00000);
+	pxa_irq_domain = irq_domain_add_legacy(node, irq_nr,
+					       PXA_IRQ(0), 0,
+					       &pxa_irq_ops, NULL);
+	if (!pxa_irq_domain)
+		panic("Unable to add PXA IRQ domain\n");
+	irq_set_default_host(pxa_irq_domain);
 
 	for (n = 0; n < irq_nr; n += 32) {
 		void __iomem *base = irq_base(n >> 5);
 
 		__raw_writel(0, base + ICMR);	/* disable all IRQs */
 		__raw_writel(0, base + ICLR);	/* all IRQs are IRQ, not FIQ */
-		for (i = n; (i < (n + 32)) && (i < irq_nr); i++) {
-			/* initialize interrupt priority */
-			if (cpu_has_ipr)
-				__raw_writel(i | IPR_VALID, pxa_irq_base + IPR(i));
-
-			irq = PXA_IRQ(i);
-			irq_set_chip_and_handler(irq, &pxa_internal_irq_chip,
-						 handle_level_irq);
-			irq_set_chip_data(irq, base);
-			set_irq_flags(irq, IRQF_VALID);
-		}
 	}
-
 	/* only unmasked interrupts kick us out of idle */
 	__raw_writel(1, irq_base(0) + ICCR);
 
 	pxa_internal_irq_chip.irq_set_wake = fn;
 }
 
+void __init pxa_init_irq(int irq_nr, int (*fn)(struct irq_data *, unsigned int))
+{
+	BUG_ON(irq_nr > MAX_INTERNAL_IRQS);
+
+	pxa_irq_base = io_p2v(0x40d00000);
+	cpu_has_ipr = !cpu_is_pxa25x();
+	pxa_init_irq_common(NULL, irq_nr, fn);
+}
+
 #ifdef CONFIG_PM
 static unsigned long saved_icmr[MAX_INTERNAL_IRQS/32];
 static unsigned long saved_ipr[MAX_INTERNAL_IRQS];
@@ -203,30 +229,6 @@ struct syscore_ops pxa_irq_syscore_ops = {
 };
 
 #ifdef CONFIG_OF
-static struct irq_domain *pxa_irq_domain;
-
-static int pxa_irq_map(struct irq_domain *h, unsigned int virq,
-		       irq_hw_number_t hw)
-{
-	void __iomem *base = irq_base(hw / 32);
-
-	/* initialize interrupt priority */
-	if (cpu_has_ipr)
-		__raw_writel(hw | IPR_VALID, pxa_irq_base + IPR(hw));
-
-	irq_set_chip_and_handler(hw, &pxa_internal_irq_chip,
-				 handle_level_irq);
-	irq_set_chip_data(hw, base);
-	set_irq_flags(hw, IRQF_VALID);
-
-	return 0;
-}
-
-static struct irq_domain_ops pxa_irq_ops = {
-	.map    = pxa_irq_map,
-	.xlate  = irq_domain_xlate_onecell,
-};
-
 static const struct of_device_id intc_ids[] __initconst = {
 	{ .compatible = "marvell,pxa-intc", },
 	{}
@@ -236,7 +238,7 @@ void __init pxa_dt_irq_init(int (*fn)(struct irq_data *, unsigned int))
 {
 	struct device_node *node;
 	struct resource res;
-	int n, ret;
+	int ret;
 
 	node = of_find_matching_node(NULL, intc_ids);
 	if (!node) {
@@ -267,23 +269,6 @@ void __init pxa_dt_irq_init(int (*fn)(struct irq_data *, unsigned int))
 		return;
 	}
 
-	pxa_irq_domain = irq_domain_add_legacy(node, pxa_internal_irq_nr, 0, 0,
-					       &pxa_irq_ops, NULL);
-	if (!pxa_irq_domain)
-		panic("Unable to add PXA IRQ domain\n");
-
-	irq_set_default_host(pxa_irq_domain);
-
-	for (n = 0; n < pxa_internal_irq_nr; n += 32) {
-		void __iomem *base = irq_base(n >> 5);
-
-		__raw_writel(0, base + ICMR);	/* disable all IRQs */
-		__raw_writel(0, base + ICLR);	/* all IRQs are IRQ, not FIQ */
-	}
-
-	/* only unmasked interrupts kick us out of idle */
-	__raw_writel(1, irq_base(0) + ICCR);
-
-	pxa_internal_irq_chip.irq_set_wake = fn;
+	pxa_init_irq_common(node, pxa_internal_irq_nr, fn);
 }
 #endif /* CONFIG_OF */

commit 2473de06b070bdd6c711bac138572ec806d5c53d
Author: Thierry Reding <thierry.reding@gmail.com>
Date:   Wed Dec 4 11:22:45 2013 +0100

    ARM: pxa: Remove unused variables
    
    The conf and of_id variables are assigned but never used, so they may as
    well just be removed.
    
    Signed-off-by: Thierry Reding <thierry.reding@gmail.com>
    Acked-by: Daniel Mack <zonque@gmail.com>
    Signed-off-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index b6cc1816463e..0eecd83c624e 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -235,8 +235,6 @@ static const struct of_device_id intc_ids[] __initconst = {
 void __init pxa_dt_irq_init(int (*fn)(struct irq_data *, unsigned int))
 {
 	struct device_node *node;
-	const struct of_device_id *of_id;
-	struct pxa_intc_conf *conf;
 	struct resource res;
 	int n, ret;
 
@@ -245,8 +243,6 @@ void __init pxa_dt_irq_init(int (*fn)(struct irq_data *, unsigned int))
 		pr_err("Failed to find interrupt controller in arch-pxa\n");
 		return;
 	}
-	of_id = of_match_node(intc_ids, node);
-	conf = of_id->data;
 
 	ret = of_property_read_u32(node, "marvell,intc-nr-irqs",
 				   &pxa_internal_irq_nr);

commit 089d03629b04ebe8163905a2398742b426e35085
Author: Daniel Mack <zonque@gmail.com>
Date:   Sun Jul 22 19:50:22 2012 +0200

    ARM: pxa: add devicetree code for irq handling
    
    Properly register on-chip interrupt using the irqdomain logic. The
    number of interrupts is taken from the devicetree node. That includes
    the following changes:
    
    - cpu_has_ipr() was converted from an inline function to a static bool
    variable, so it can be set using the "marvell,intc-priority" property
    inside the device node of the tree.
    
    - IRQ_BASE was converted from a macro to a runtime variable so that it
    can be initialized dynamically from the DT init code.
    
    - irq_base() now uses pxa_irq_base and just adds an offset.
    
    Hence, there are now no compile-time fixed values used in case of DT
    initialization.
    
    Signed-off-by: Daniel Mack <zonque@gmail.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Haojian Zhuang <haojian.zhuang@gmail.com>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 5dae15ea6718..b6cc1816463e 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -17,6 +17,8 @@
 #include <linux/syscore_ops.h>
 #include <linux/io.h>
 #include <linux/irq.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
 
 #include <asm/exception.h>
 
@@ -25,8 +27,6 @@
 
 #include "generic.h"
 
-#define IRQ_BASE		io_p2v(0x40d00000)
-
 #define ICIP			(0x000)
 #define ICMR			(0x004)
 #define ICLR			(0x008)
@@ -48,22 +48,19 @@
  * This is for peripheral IRQs internal to the PXA chip.
  */
 
+static void __iomem *pxa_irq_base;
 static int pxa_internal_irq_nr;
-
-static inline int cpu_has_ipr(void)
-{
-	return !cpu_is_pxa25x();
-}
+static bool cpu_has_ipr;
 
 static inline void __iomem *irq_base(int i)
 {
-	static unsigned long phys_base[] = {
-		0x40d00000,
-		0x40d0009c,
-		0x40d00130,
+	static unsigned long phys_base_offset[] = {
+		0x0,
+		0x9c,
+		0x130,
 	};
 
-	return io_p2v(phys_base[i]);
+	return pxa_irq_base + phys_base_offset[i];
 }
 
 void pxa_mask_irq(struct irq_data *d)
@@ -96,8 +93,8 @@ asmlinkage void __exception_irq_entry icip_handle_irq(struct pt_regs *regs)
 	uint32_t icip, icmr, mask;
 
 	do {
-		icip = __raw_readl(IRQ_BASE + ICIP);
-		icmr = __raw_readl(IRQ_BASE + ICMR);
+		icip = __raw_readl(pxa_irq_base + ICIP);
+		icmr = __raw_readl(pxa_irq_base + ICMR);
 		mask = icip & icmr;
 
 		if (mask == 0)
@@ -128,6 +125,8 @@ void __init pxa_init_irq(int irq_nr, int (*fn)(struct irq_data *, unsigned int))
 	BUG_ON(irq_nr > MAX_INTERNAL_IRQS);
 
 	pxa_internal_irq_nr = irq_nr;
+	cpu_has_ipr = !cpu_is_pxa25x();
+	pxa_irq_base = io_p2v(0x40d00000);
 
 	for (n = 0; n < irq_nr; n += 32) {
 		void __iomem *base = irq_base(n >> 5);
@@ -136,8 +135,8 @@ void __init pxa_init_irq(int irq_nr, int (*fn)(struct irq_data *, unsigned int))
 		__raw_writel(0, base + ICLR);	/* all IRQs are IRQ, not FIQ */
 		for (i = n; (i < (n + 32)) && (i < irq_nr); i++) {
 			/* initialize interrupt priority */
-			if (cpu_has_ipr())
-				__raw_writel(i | IPR_VALID, IRQ_BASE + IPR(i));
+			if (cpu_has_ipr)
+				__raw_writel(i | IPR_VALID, pxa_irq_base + IPR(i));
 
 			irq = PXA_IRQ(i);
 			irq_set_chip_and_handler(irq, &pxa_internal_irq_chip,
@@ -168,9 +167,9 @@ static int pxa_irq_suspend(void)
 		__raw_writel(0, base + ICMR);
 	}
 
-	if (cpu_has_ipr()) {
+	if (cpu_has_ipr) {
 		for (i = 0; i < pxa_internal_irq_nr; i++)
-			saved_ipr[i] = __raw_readl(IRQ_BASE + IPR(i));
+			saved_ipr[i] = __raw_readl(pxa_irq_base + IPR(i));
 	}
 
 	return 0;
@@ -187,11 +186,11 @@ static void pxa_irq_resume(void)
 		__raw_writel(0, base + ICLR);
 	}
 
-	if (cpu_has_ipr())
+	if (cpu_has_ipr)
 		for (i = 0; i < pxa_internal_irq_nr; i++)
-			__raw_writel(saved_ipr[i], IRQ_BASE + IPR(i));
+			__raw_writel(saved_ipr[i], pxa_irq_base + IPR(i));
 
-	__raw_writel(1, IRQ_BASE + ICCR);
+	__raw_writel(1, pxa_irq_base + ICCR);
 }
 #else
 #define pxa_irq_suspend		NULL
@@ -202,3 +201,93 @@ struct syscore_ops pxa_irq_syscore_ops = {
 	.suspend	= pxa_irq_suspend,
 	.resume		= pxa_irq_resume,
 };
+
+#ifdef CONFIG_OF
+static struct irq_domain *pxa_irq_domain;
+
+static int pxa_irq_map(struct irq_domain *h, unsigned int virq,
+		       irq_hw_number_t hw)
+{
+	void __iomem *base = irq_base(hw / 32);
+
+	/* initialize interrupt priority */
+	if (cpu_has_ipr)
+		__raw_writel(hw | IPR_VALID, pxa_irq_base + IPR(hw));
+
+	irq_set_chip_and_handler(hw, &pxa_internal_irq_chip,
+				 handle_level_irq);
+	irq_set_chip_data(hw, base);
+	set_irq_flags(hw, IRQF_VALID);
+
+	return 0;
+}
+
+static struct irq_domain_ops pxa_irq_ops = {
+	.map    = pxa_irq_map,
+	.xlate  = irq_domain_xlate_onecell,
+};
+
+static const struct of_device_id intc_ids[] __initconst = {
+	{ .compatible = "marvell,pxa-intc", },
+	{}
+};
+
+void __init pxa_dt_irq_init(int (*fn)(struct irq_data *, unsigned int))
+{
+	struct device_node *node;
+	const struct of_device_id *of_id;
+	struct pxa_intc_conf *conf;
+	struct resource res;
+	int n, ret;
+
+	node = of_find_matching_node(NULL, intc_ids);
+	if (!node) {
+		pr_err("Failed to find interrupt controller in arch-pxa\n");
+		return;
+	}
+	of_id = of_match_node(intc_ids, node);
+	conf = of_id->data;
+
+	ret = of_property_read_u32(node, "marvell,intc-nr-irqs",
+				   &pxa_internal_irq_nr);
+	if (ret) {
+		pr_err("Not found marvell,intc-nr-irqs property\n");
+		return;
+	}
+
+	ret = of_address_to_resource(node, 0, &res);
+	if (ret < 0) {
+		pr_err("No registers defined for node\n");
+		return;
+	}
+	pxa_irq_base = io_p2v(res.start);
+
+	if (of_find_property(node, "marvell,intc-priority", NULL))
+		cpu_has_ipr = 1;
+
+	ret = irq_alloc_descs(-1, 0, pxa_internal_irq_nr, 0);
+	if (ret < 0) {
+		pr_err("Failed to allocate IRQ numbers\n");
+		return;
+	}
+
+	pxa_irq_domain = irq_domain_add_legacy(node, pxa_internal_irq_nr, 0, 0,
+					       &pxa_irq_ops, NULL);
+	if (!pxa_irq_domain)
+		panic("Unable to add PXA IRQ domain\n");
+
+	irq_set_default_host(pxa_irq_domain);
+
+	for (n = 0; n < pxa_internal_irq_nr; n += 32) {
+		void __iomem *base = irq_base(n >> 5);
+
+		__raw_writel(0, base + ICMR);	/* disable all IRQs */
+		__raw_writel(0, base + ICLR);	/* all IRQs are IRQ, not FIQ */
+	}
+
+	/* only unmasked interrupts kick us out of idle */
+	__raw_writel(1, irq_base(0) + ICCR);
+
+	pxa_internal_irq_chip.irq_set_wake = fn;
+}
+#endif /* CONFIG_OF */

commit 157d2644cb0c1e71a18baaffca56d2b1d0ebf10f
Author: Haojian Zhuang <haojian.zhuang@marvell.com>
Date:   Mon Oct 17 20:37:52 2011 +0800

    ARM: pxa: change gpio to platform device
    
    Remove most gpio macros and change gpio driver to platform driver.
    
    Signed-off-by: Haojian Zhuang <haojian.zhuang@marvell.com>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 36c538f48fa6..5dae15ea6718 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -22,7 +22,6 @@
 
 #include <mach/hardware.h>
 #include <mach/irqs.h>
-#include <mach/gpio-pxa.h>
 
 #include "generic.h"
 
@@ -122,7 +121,7 @@ asmlinkage void __exception_irq_entry ichp_handle_irq(struct pt_regs *regs)
 	} while (1);
 }
 
-void __init pxa_init_irq(int irq_nr, set_wake_t fn)
+void __init pxa_init_irq(int irq_nr, int (*fn)(struct irq_data *, unsigned int))
 {
 	int irq, i, n;
 

commit 87c49e20579c933d531a376596875b8fd5dcb04f
Author: Haojian Zhuang <haojian.zhuang@marvell.com>
Date:   Mon Oct 10 14:38:46 2011 +0800

    ARM: pxa: use chained interrupt for GPIO0 and GPIO1
    
    GPIO0 and GPIO1 are linked to unique interrupt line in PXA series,
    others are linked to another interrupt line. All GPIO are linked to one
    interrupt line in MMP series.
    
    Since gpio driver is shared between PXA series and MMP series, define
    GPIO0 and GPIO1 as chained interrupt chip. So we can move out gpio code
    from irq.c to gpio-pxa.c.
    
    Signed-off-by: Haojian Zhuang <haojian.zhuang@marvell.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 532c5d3a97d2..36c538f48fa6 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -92,44 +92,6 @@ static struct irq_chip pxa_internal_irq_chip = {
 	.irq_unmask	= pxa_unmask_irq,
 };
 
-/*
- * GPIO IRQs for GPIO 0 and 1
- */
-static int pxa_set_low_gpio_type(struct irq_data *d, unsigned int type)
-{
-	int gpio = d->irq - IRQ_GPIO0;
-
-	if (__gpio_is_occupied(gpio)) {
-		pr_err("%s failed: GPIO is configured\n", __func__);
-		return -EINVAL;
-	}
-
-	if (type & IRQ_TYPE_EDGE_RISING)
-		GRER0 |= GPIO_bit(gpio);
-	else
-		GRER0 &= ~GPIO_bit(gpio);
-
-	if (type & IRQ_TYPE_EDGE_FALLING)
-		GFER0 |= GPIO_bit(gpio);
-	else
-		GFER0 &= ~GPIO_bit(gpio);
-
-	return 0;
-}
-
-static void pxa_ack_low_gpio(struct irq_data *d)
-{
-	GEDR0 = (1 << (d->irq - IRQ_GPIO0));
-}
-
-static struct irq_chip pxa_low_gpio_chip = {
-	.name		= "GPIO-l",
-	.irq_ack	= pxa_ack_low_gpio,
-	.irq_mask	= pxa_mask_irq,
-	.irq_unmask	= pxa_unmask_irq,
-	.irq_set_type	= pxa_set_low_gpio_type,
-};
-
 asmlinkage void __exception_irq_entry icip_handle_irq(struct pt_regs *regs)
 {
 	uint32_t icip, icmr, mask;
@@ -160,25 +122,6 @@ asmlinkage void __exception_irq_entry ichp_handle_irq(struct pt_regs *regs)
 	} while (1);
 }
 
-static void __init pxa_init_low_gpio_irq(set_wake_t fn)
-{
-	int irq;
-
-	/* clear edge detection on GPIO 0 and 1 */
-	GFER0 &= ~0x3;
-	GRER0 &= ~0x3;
-	GEDR0 = 0x3;
-
-	for (irq = IRQ_GPIO0; irq <= IRQ_GPIO1; irq++) {
-		irq_set_chip_and_handler(irq, &pxa_low_gpio_chip,
-					 handle_edge_irq);
-		irq_set_chip_data(irq, irq_base(0));
-		set_irq_flags(irq, IRQF_VALID);
-	}
-
-	pxa_low_gpio_chip.irq_set_wake = fn;
-}
-
 void __init pxa_init_irq(int irq_nr, set_wake_t fn)
 {
 	int irq, i, n;
@@ -209,7 +152,6 @@ void __init pxa_init_irq(int irq_nr, set_wake_t fn)
 	__raw_writel(1, irq_base(0) + ICCR);
 
 	pxa_internal_irq_chip.irq_set_wake = fn;
-	pxa_init_low_gpio_irq(fn);
 }
 
 #ifdef CONFIG_PM

commit 68e24ba70465b82ad24e0774ceab5360180d4627
Merge: b4beb4bf9934 5725aeae5ff2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 1 19:55:06 2011 -0700

    Merge branch 'next/fixes' of git://git.linaro.org/people/arnd/arm-soc
    
    * 'next/fixes' of git://git.linaro.org/people/arnd/arm-soc: (28 commits)
      ARM: pxa/cm-x300: properly set bt_reset pin
      ARM: mmp: rename SHEEVAD to GPLUGD
      ARM: imx: Fix typo 'MACH_MX31_3DS_MXC_NAND_USE_BBT'
      ARM: i.MX28: shift frac value in _CLK_SET_RATE
      plat-mxc: iomux-v3.h: implicitly enable pull-up/down when that's desired
      ARM: mx5: fix clock usage for suspend
      ARM: pxa: use correct __iomem annotations
      ARM: pxa: sharpsl pm needs SPI
      ARM: pxa: centro and treo680 need palm27x
      ARM: pxa: make pxafb_smart_*() empty when not enabled
      ARM: pxa: select POWER_SUPPLY on raumfeld
      ARM: pxa: pxa95x is incompatible with earlier pxa
      ARM: pxa: CPU_FREQ_TABLE is needed for CPU_FREQ
      ARM: pxa: pxa95x/saarb depends on pxa3xx code
      ARM: pxa: allow selecting just one of TREO680/CENTRO
      ARM: pxa: export symbols from pxa3xx-ulpi
      ARM: pxa: make zylonite_pxa*_init declaration match code
      ARM: pxa/z2: fix building error of pxa27x_cpu_suspend() no longer available
      ARM: at91: add defconfig for at91sam9g45 family
      ARM: at91: remove dependency for Atmel PWM driver selector in Kconfig
      ...

commit 43872fa788060eef91ae437957e0a5e39f1c56fd
Merge: 91fed558d0f3 f55be1bf52aa
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Oct 31 22:44:18 2011 +0100

    Merge branch 'depends/rmk/gpio' into next/fixes
    
    This sorts out merge conflicts with the arm/gpio branch that
    already got merged into mainline Linux.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit ca90666287401b475d9e0becf85bd02f069f1de8
Merge: 60325f0c6ee7 374e759db148
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 27 08:39:10 2011 +0200

    Merge branch 'gpio' of http://ftp.arm.linux.org.uk/pub/linux/arm/kernel/git-cur/linux-2.6-arm
    
    * 'gpio' of http://ftp.arm.linux.org.uk/pub/linux/arm/kernel/git-cur/linux-2.6-arm: (43 commits)
      ARM: 7135/1: ep93xx: bring back missing <mach/gpio.h>
      ARM: 7104/1: plat-pxa: break out GPIO driver specifics
      ARM: 7103/1: plat-pxa: move PXA GPIO driver to GPIO subsystem
      ARM: 7042/3: mach-ep93xx: break out GPIO driver specifics
      ARM: 7101/1: arm/tegra: Replace <mach/gpio.h> with <mach/gpio-tegra.h>
      ARM: 7094/1: arm/tegra: Move EN_VDD_1V05_GPIO to board-harmony.h
      ARM: 7083/1: rewrite U300 GPIO to use gpiolib
      ARM: 7074/1: gpio: davinci: eliminate unused variable warnings
      ARM: 7063/1: Orion: gpio: add missing include of linux/types.h
      ARM: 7055/1: arm/tegra: mach/gpio.h: include linux/types.h to fix build
      ARM: 7054/1: arm/tegra: Delete custom gpio_to_irq, and irq_to_gpio
      ARM: 7053/1: gpio/tegra: Implement gpio_chip.to_irq
      ARM: 7052/1: gpio/tegra: Remove use of irq_to_gpio
      ARM: 7057/1: mach-pnx4008: rename GPIO header
      ARM: 7056/1: plat-nomadik: kill off <plat/gpio.h>
      ARM: 7050/1: mach-sa1100: delete irq_to_gpio() function
      ARM: 7049/1: mach-sa1100: move SA1100 GPIO driver to GPIO subsystem
      ARM: 7045/1: mach-lpc32xx: break out GPIO driver specifics
      ARM: 7044/1: mach-lpc32xx: move LPC32XX GPIO driver to GPIO subsystem
      ARM: 7043/1: mach-ixp2000: rename GPIO header
      ...
    
    Fix up trivial conflicts in arch/arm/mach-u300/Kconfig manually

commit 5a567d78c437e3be1c512734cdfe64b4ae6b82d7
Author: Jamie Iles <jamie@jamieiles.com>
Date:   Sat Oct 8 11:20:42 2011 +0100

    ARM: 7115/4: move __exception and friends to asm/exception.h
    
    The definition of __exception_irq_entry for
    CONFIG_FUNCTION_GRAPH_TRACER=y needs linux/ftrace.h, but this creates a
    circular dependency with it's current home in asm/system.h. Create
    asm/exception.h and update all current users.
    
    v4:     - rebase to rmk/for-next
    v3:     - remove redundant includes of linux/ftrace.h
    v2:     - document the usage restricitions of __exception*
    
    Cc: Zoltan Devai <zdevai@gmail.com>
    Signed-off-by: Jamie Iles <jamie@jamieiles.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index b09e848eb6c6..ca6075717824 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -19,6 +19,8 @@
 #include <linux/io.h>
 #include <linux/irq.h>
 
+#include <asm/exception.h>
+
 #include <mach/hardware.h>
 #include <mach/irqs.h>
 #include <mach/gpio.h>

commit 97b09da4ee36ec4bd0f6e16b84b4bb6fa05db110
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Oct 1 22:03:45 2011 +0200

    ARM: pxa: use correct __iomem annotations
    
    This tries to clear up the confusion between integers and iomem pointers
    in the marvell pxa platform. MMIO addresses are supposed to be __iomem*
    values, in order to let the Linux type checking work correctly. This
    patch moves the cast to __iomem as far back as possible, to the place
    where the MMIO virtual address windows are defined.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index b09e848eb6c6..fead5c779a23 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -25,7 +25,7 @@
 
 #include "generic.h"
 
-#define IRQ_BASE		(void __iomem *)io_p2v(0x40d00000)
+#define IRQ_BASE		io_p2v(0x40d00000)
 
 #define ICIP			(0x000)
 #define ICMR			(0x004)
@@ -63,7 +63,7 @@ static inline void __iomem *irq_base(int i)
 		0x40d00130,
 	};
 
-	return (void __iomem *)io_p2v(phys_base[i]);
+	return io_p2v(phys_base[i]);
 }
 
 void pxa_mask_irq(struct irq_data *d)

commit f55be1bf52aad524dc1bf556ae26c90262c87825
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Sep 28 09:11:30 2011 +0100

    ARM: 7104/1: plat-pxa: break out GPIO driver specifics
    
    The <mach/gpio.h> file is included from upper directories
    and deal with generic GPIO and gpiolib stuff. Break out the
    platform and driver specific defines and functions into its own
    header file.
    
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index dafb4bf6349e..d493a230addf 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -11,7 +11,6 @@
  *  it under the terms of the GNU General Public License version 2 as
  *  published by the Free Software Foundation.
  */
-#include <linux/gpio.h>
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/interrupt.h>
@@ -21,6 +20,7 @@
 
 #include <mach/hardware.h>
 #include <mach/irqs.h>
+#include <mach/gpio-pxa.h>
 
 #include "generic.h"
 

commit 2f8163baada3dbd0ce891c35bc59ae46e773487a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jul 26 10:53:52 2011 +0100

    ARM: gpio: convert includes of mach/gpio.h and asm/gpio.h to linux/gpio.h
    
    Convert arch/arm includes of mach/gpio.h and asm/gpio.h to linux/gpio.h
    before we start consolidating the individual platform implementations
    of the gpio header files.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index b09e848eb6c6..dafb4bf6349e 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -11,7 +11,7 @@
  *  it under the terms of the GNU General Public License version 2 as
  *  published by the Free Software Foundation.
  */
-
+#include <linux/gpio.h>
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/interrupt.h>
@@ -21,7 +21,6 @@
 
 #include <mach/hardware.h>
 #include <mach/irqs.h>
-#include <mach/gpio.h>
 
 #include "generic.h"
 

commit a551e4f787220459c6e78668a15cbe01f1ac7637
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Wed Apr 27 22:48:05 2011 +0800

    ARM: pxa: introduce {icip,ichp}_handle_irq() to prepare MULTI_IRQ_HANDLER
    
    Thanks Dmitry for providing a fix to the original code.
    
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index c89c0e40fe32..b09e848eb6c6 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -37,6 +37,8 @@
 #define IPR(i)			(((i) < 32) ? (0x01c + ((i) << 2)) :		\
 				((i) < 64) ? (0x0b0 + (((i) - 32) << 2)) :	\
 				      (0x144 + (((i) - 64) << 2)))
+#define ICHP_VAL_IRQ		(1 << 31)
+#define ICHP_IRQ(i)		(((i) >> 16) & 0x7fff)
 #define IPR_VALID		(1 << 31)
 #define IRQ_BIT(n)		(((n) - PXA_IRQ(0)) & 0x1f)
 
@@ -127,6 +129,36 @@ static struct irq_chip pxa_low_gpio_chip = {
 	.irq_set_type	= pxa_set_low_gpio_type,
 };
 
+asmlinkage void __exception_irq_entry icip_handle_irq(struct pt_regs *regs)
+{
+	uint32_t icip, icmr, mask;
+
+	do {
+		icip = __raw_readl(IRQ_BASE + ICIP);
+		icmr = __raw_readl(IRQ_BASE + ICMR);
+		mask = icip & icmr;
+
+		if (mask == 0)
+			break;
+
+		handle_IRQ(PXA_IRQ(fls(mask) - 1), regs);
+	} while (1);
+}
+
+asmlinkage void __exception_irq_entry ichp_handle_irq(struct pt_regs *regs)
+{
+	uint32_t ichp;
+
+	do {
+		__asm__ __volatile__("mrc p6, 0, %0, c5, c0, 0\n": "=r"(ichp));
+
+		if ((ichp & ICHP_VAL_IRQ) == 0)
+			break;
+
+		handle_IRQ(PXA_IRQ(ICHP_IRQ(ichp)), regs);
+	} while (1);
+}
+
 static void __init pxa_init_low_gpio_irq(set_wake_t fn)
 {
 	int irq;

commit 5d284e353eb11ab2e8b1c5671ba06489b0bd1e0c
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Wed Apr 27 22:48:04 2011 +0800

    ARM: pxa: avoid accessing interrupt registers directly
    
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 32ed551bf9c5..c89c0e40fe32 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -64,7 +64,7 @@ static inline void __iomem *irq_base(int i)
 	return (void __iomem *)io_p2v(phys_base[i]);
 }
 
-static void pxa_mask_irq(struct irq_data *d)
+void pxa_mask_irq(struct irq_data *d)
 {
 	void __iomem *base = irq_data_get_irq_chip_data(d);
 	uint32_t icmr = __raw_readl(base + ICMR);
@@ -73,7 +73,7 @@ static void pxa_mask_irq(struct irq_data *d)
 	__raw_writel(icmr, base + ICMR);
 }
 
-static void pxa_unmask_irq(struct irq_data *d)
+void pxa_unmask_irq(struct irq_data *d)
 {
 	void __iomem *base = irq_data_get_irq_chip_data(d);
 	uint32_t icmr = __raw_readl(base + ICMR);

commit 2eaa03b5bebd1e80014f780d7bf27c3e66daefd6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Apr 22 22:03:11 2011 +0200

    ARM / PXA: Use struct syscore_ops for "core" power management
    
    Replace sysdev classes and struct sys_device objects used for "core"
    power management by the PXA platform code with struct syscore_ops
    objects that are simpler.
    
    This reduces the code size and the kernel memory footprint.  It also
    is necessary for removing sysdevs entirely from the kernel in the
    future.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 6251e3f5c62c..32ed551bf9c5 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -15,7 +15,7 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/interrupt.h>
-#include <linux/sysdev.h>
+#include <linux/syscore_ops.h>
 #include <linux/io.h>
 #include <linux/irq.h>
 
@@ -183,7 +183,7 @@ void __init pxa_init_irq(int irq_nr, set_wake_t fn)
 static unsigned long saved_icmr[MAX_INTERNAL_IRQS/32];
 static unsigned long saved_ipr[MAX_INTERNAL_IRQS];
 
-static int pxa_irq_suspend(struct sys_device *dev, pm_message_t state)
+static int pxa_irq_suspend(void)
 {
 	int i;
 
@@ -202,7 +202,7 @@ static int pxa_irq_suspend(struct sys_device *dev, pm_message_t state)
 	return 0;
 }
 
-static int pxa_irq_resume(struct sys_device *dev)
+static void pxa_irq_resume(void)
 {
 	int i;
 
@@ -218,22 +218,13 @@ static int pxa_irq_resume(struct sys_device *dev)
 			__raw_writel(saved_ipr[i], IRQ_BASE + IPR(i));
 
 	__raw_writel(1, IRQ_BASE + ICCR);
-	return 0;
 }
 #else
 #define pxa_irq_suspend		NULL
 #define pxa_irq_resume		NULL
 #endif
 
-struct sysdev_class pxa_irq_sysclass = {
-	.name		= "irq",
+struct syscore_ops pxa_irq_syscore_ops = {
 	.suspend	= pxa_irq_suspend,
 	.resume		= pxa_irq_resume,
 };
-
-static int __init pxa_irq_init(void)
-{
-	return sysdev_class_register(&pxa_irq_sysclass);
-}
-
-core_initcall(pxa_irq_init);

commit f38c02f3b338651e145aac2889ba976baf6b28b3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 13:35:09 2011 +0100

    arm: Fold irq_set_chip/irq_set_handler
    
    Use irq_set_chip_and_handler() instead. Converted with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 70344cc75743..6251e3f5c62c 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -137,8 +137,8 @@ static void __init pxa_init_low_gpio_irq(set_wake_t fn)
 	GEDR0 = 0x3;
 
 	for (irq = IRQ_GPIO0; irq <= IRQ_GPIO1; irq++) {
-		irq_set_chip(irq, &pxa_low_gpio_chip);
-		irq_set_handler(irq, handle_edge_irq);
+		irq_set_chip_and_handler(irq, &pxa_low_gpio_chip,
+					 handle_edge_irq);
 		irq_set_chip_data(irq, irq_base(0));
 		set_irq_flags(irq, IRQF_VALID);
 	}
@@ -165,8 +165,8 @@ void __init pxa_init_irq(int irq_nr, set_wake_t fn)
 				__raw_writel(i | IPR_VALID, IRQ_BASE + IPR(i));
 
 			irq = PXA_IRQ(i);
-			irq_set_chip(irq, &pxa_internal_irq_chip);
-			irq_set_handler(irq, handle_level_irq);
+			irq_set_chip_and_handler(irq, &pxa_internal_irq_chip,
+						 handle_level_irq);
 			irq_set_chip_data(irq, base);
 			set_irq_flags(irq, IRQF_VALID);
 		}

commit 9323f26186403433293e87e717a7785f74f75d80
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 13:29:39 2011 +0100

    arm: Reorder irq_set_ function calls
    
    Reorder
    irq_set_chip()
    irq_set_chip_data()
    irq_set_handler()
    
    to
    
    irq_set_chip()
    irq_set_handler()
    irq_set_chip_data()
    
    so the next patch can combine irq_set_chip() and irq_set_handler() to
    irq_set_chip_and_handler().
    
    Automated conversion with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index cc7bfc3428c8..70344cc75743 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -138,8 +138,8 @@ static void __init pxa_init_low_gpio_irq(set_wake_t fn)
 
 	for (irq = IRQ_GPIO0; irq <= IRQ_GPIO1; irq++) {
 		irq_set_chip(irq, &pxa_low_gpio_chip);
-		irq_set_chip_data(irq, irq_base(0));
 		irq_set_handler(irq, handle_edge_irq);
+		irq_set_chip_data(irq, irq_base(0));
 		set_irq_flags(irq, IRQF_VALID);
 	}
 
@@ -166,8 +166,8 @@ void __init pxa_init_irq(int irq_nr, set_wake_t fn)
 
 			irq = PXA_IRQ(i);
 			irq_set_chip(irq, &pxa_internal_irq_chip);
-			irq_set_chip_data(irq, base);
 			irq_set_handler(irq, handle_level_irq);
+			irq_set_chip_data(irq, base);
 			set_irq_flags(irq, IRQF_VALID);
 		}
 	}

commit 6845664a6a7d443f03883db59d10749d38d98b8e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 13:25:22 2011 +0100

    arm: Cleanup the irq namespace
    
    Convert to the new function names. Automated with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 2693e3c3776f..cc7bfc3428c8 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -137,9 +137,9 @@ static void __init pxa_init_low_gpio_irq(set_wake_t fn)
 	GEDR0 = 0x3;
 
 	for (irq = IRQ_GPIO0; irq <= IRQ_GPIO1; irq++) {
-		set_irq_chip(irq, &pxa_low_gpio_chip);
-		set_irq_chip_data(irq, irq_base(0));
-		set_irq_handler(irq, handle_edge_irq);
+		irq_set_chip(irq, &pxa_low_gpio_chip);
+		irq_set_chip_data(irq, irq_base(0));
+		irq_set_handler(irq, handle_edge_irq);
 		set_irq_flags(irq, IRQF_VALID);
 	}
 
@@ -165,9 +165,9 @@ void __init pxa_init_irq(int irq_nr, set_wake_t fn)
 				__raw_writel(i | IPR_VALID, IRQ_BASE + IPR(i));
 
 			irq = PXA_IRQ(i);
-			set_irq_chip(irq, &pxa_internal_irq_chip);
-			set_irq_chip_data(irq, base);
-			set_irq_handler(irq, handle_level_irq);
+			irq_set_chip(irq, &pxa_internal_irq_chip);
+			irq_set_chip_data(irq, base);
+			irq_set_handler(irq, handle_level_irq);
 			set_irq_flags(irq, IRQF_VALID);
 		}
 	}

commit a1015a159530391fc498482656bab6c99dcd3c70
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Wed Jan 12 16:42:24 2011 -0600

    ARM: pxa: fix recursive calls in pxa_low_gpio_chip
    
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>
    Tested-by: Marek Vasut <marek.vasut@gmail.com>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index b71677bce548..2693e3c3776f 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -53,6 +53,17 @@ static inline int cpu_has_ipr(void)
 	return !cpu_is_pxa25x();
 }
 
+static inline void __iomem *irq_base(int i)
+{
+	static unsigned long phys_base[] = {
+		0x40d00000,
+		0x40d0009c,
+		0x40d00130,
+	};
+
+	return (void __iomem *)io_p2v(phys_base[i]);
+}
+
 static void pxa_mask_irq(struct irq_data *d)
 {
 	void __iomem *base = irq_data_get_irq_chip_data(d);
@@ -108,25 +119,11 @@ static void pxa_ack_low_gpio(struct irq_data *d)
 	GEDR0 = (1 << (d->irq - IRQ_GPIO0));
 }
 
-static void pxa_mask_low_gpio(struct irq_data *d)
-{
-	struct irq_desc *desc = irq_to_desc(d->irq);
-
-	desc->irq_data.chip->irq_mask(d);
-}
-
-static void pxa_unmask_low_gpio(struct irq_data *d)
-{
-	struct irq_desc *desc = irq_to_desc(d->irq);
-
-	desc->irq_data.chip->irq_unmask(d);
-}
-
 static struct irq_chip pxa_low_gpio_chip = {
 	.name		= "GPIO-l",
 	.irq_ack	= pxa_ack_low_gpio,
-	.irq_mask	= pxa_mask_low_gpio,
-	.irq_unmask	= pxa_unmask_low_gpio,
+	.irq_mask	= pxa_mask_irq,
+	.irq_unmask	= pxa_unmask_irq,
 	.irq_set_type	= pxa_set_low_gpio_type,
 };
 
@@ -141,6 +138,7 @@ static void __init pxa_init_low_gpio_irq(set_wake_t fn)
 
 	for (irq = IRQ_GPIO0; irq <= IRQ_GPIO1; irq++) {
 		set_irq_chip(irq, &pxa_low_gpio_chip);
+		set_irq_chip_data(irq, irq_base(0));
 		set_irq_handler(irq, handle_edge_irq);
 		set_irq_flags(irq, IRQF_VALID);
 	}
@@ -148,17 +146,6 @@ static void __init pxa_init_low_gpio_irq(set_wake_t fn)
 	pxa_low_gpio_chip.irq_set_wake = fn;
 }
 
-static inline void __iomem *irq_base(int i)
-{
-	static unsigned long phys_base[] = {
-		0x40d00000,
-		0x40d0009c,
-		0x40d00130,
-	};
-
-	return (void __iomem *)io_p2v(phys_base[i]);
-}
-
 void __init pxa_init_irq(int irq_nr, set_wake_t fn)
 {
 	int irq, i, n;

commit 1b624fb64c2de44c00576cc9695680983f05c1ce
Author: Marek Vasut <marek.vasut@gmail.com>
Date:   Mon Jan 10 23:53:12 2011 +0100

    ARM: pxa: fix suspend/resume array index miscalculation
    
    Signed-off-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 8f947002c0bf..b71677bce548 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -156,7 +156,7 @@ static inline void __iomem *irq_base(int i)
 		0x40d00130,
 	};
 
-	return (void __iomem *)io_p2v(phys_base[i >> 5]);
+	return (void __iomem *)io_p2v(phys_base[i]);
 }
 
 void __init pxa_init_irq(int irq_nr, set_wake_t fn)
@@ -168,7 +168,7 @@ void __init pxa_init_irq(int irq_nr, set_wake_t fn)
 	pxa_internal_irq_nr = irq_nr;
 
 	for (n = 0; n < irq_nr; n += 32) {
-		void __iomem *base = irq_base(n);
+		void __iomem *base = irq_base(n >> 5);
 
 		__raw_writel(0, base + ICMR);	/* disable all IRQs */
 		__raw_writel(0, base + ICLR);	/* all IRQs are IRQ, not FIQ */
@@ -200,7 +200,7 @@ static int pxa_irq_suspend(struct sys_device *dev, pm_message_t state)
 {
 	int i;
 
-	for (i = 0; i < pxa_internal_irq_nr; i += 32) {
+	for (i = 0; i < pxa_internal_irq_nr / 32; i++) {
 		void __iomem *base = irq_base(i);
 
 		saved_icmr[i] = __raw_readl(base + ICMR);
@@ -219,7 +219,7 @@ static int pxa_irq_resume(struct sys_device *dev)
 {
 	int i;
 
-	for (i = 0; i < pxa_internal_irq_nr; i += 32) {
+	for (i = 0; i < pxa_internal_irq_nr / 32; i++) {
 		void __iomem *base = irq_base(i);
 
 		__raw_writel(saved_icmr[i], base + ICMR);

commit 57879b8c40d4c254f1feba3adbeb69614fe5e4c9
Author: Marek Vasut <marek.vasut@gmail.com>
Date:   Mon Jan 10 00:29:04 2011 +0100

    ARM: pxa: use cpu_has_ipr() consistently in irq.c
    
    Signed-off-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 3f7f5bf05f3a..8f947002c0bf 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -226,7 +226,7 @@ static int pxa_irq_resume(struct sys_device *dev)
 		__raw_writel(0, base + ICLR);
 	}
 
-	if (!cpu_is_pxa25x())
+	if (cpu_has_ipr())
 		for (i = 0; i < pxa_internal_irq_nr; i++)
 			__raw_writel(saved_ipr[i], IRQ_BASE + IPR(i));
 

commit a3f4c927d379cfaa597bc8ff75dc9d28f8d9200e
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Mon Nov 29 11:18:26 2010 +0100

    ARM: PXA SoCs: irq_data conversion.
    
    Signed-off-by: Lennert Buytenhek <buytenh@secretlab.ca>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 54e91c9e71c8..3f7f5bf05f3a 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -53,37 +53,37 @@ static inline int cpu_has_ipr(void)
 	return !cpu_is_pxa25x();
 }
 
-static void pxa_mask_irq(unsigned int irq)
+static void pxa_mask_irq(struct irq_data *d)
 {
-	void __iomem *base = get_irq_chip_data(irq);
+	void __iomem *base = irq_data_get_irq_chip_data(d);
 	uint32_t icmr = __raw_readl(base + ICMR);
 
-	icmr &= ~(1 << IRQ_BIT(irq));
+	icmr &= ~(1 << IRQ_BIT(d->irq));
 	__raw_writel(icmr, base + ICMR);
 }
 
-static void pxa_unmask_irq(unsigned int irq)
+static void pxa_unmask_irq(struct irq_data *d)
 {
-	void __iomem *base = get_irq_chip_data(irq);
+	void __iomem *base = irq_data_get_irq_chip_data(d);
 	uint32_t icmr = __raw_readl(base + ICMR);
 
-	icmr |= 1 << IRQ_BIT(irq);
+	icmr |= 1 << IRQ_BIT(d->irq);
 	__raw_writel(icmr, base + ICMR);
 }
 
 static struct irq_chip pxa_internal_irq_chip = {
 	.name		= "SC",
-	.ack		= pxa_mask_irq,
-	.mask		= pxa_mask_irq,
-	.unmask		= pxa_unmask_irq,
+	.irq_ack	= pxa_mask_irq,
+	.irq_mask	= pxa_mask_irq,
+	.irq_unmask	= pxa_unmask_irq,
 };
 
 /*
  * GPIO IRQs for GPIO 0 and 1
  */
-static int pxa_set_low_gpio_type(unsigned int irq, unsigned int type)
+static int pxa_set_low_gpio_type(struct irq_data *d, unsigned int type)
 {
-	int gpio = irq - IRQ_GPIO0;
+	int gpio = d->irq - IRQ_GPIO0;
 
 	if (__gpio_is_occupied(gpio)) {
 		pr_err("%s failed: GPIO is configured\n", __func__);
@@ -103,31 +103,31 @@ static int pxa_set_low_gpio_type(unsigned int irq, unsigned int type)
 	return 0;
 }
 
-static void pxa_ack_low_gpio(unsigned int irq)
+static void pxa_ack_low_gpio(struct irq_data *d)
 {
-	GEDR0 = (1 << (irq - IRQ_GPIO0));
+	GEDR0 = (1 << (d->irq - IRQ_GPIO0));
 }
 
-static void pxa_mask_low_gpio(unsigned int irq)
+static void pxa_mask_low_gpio(struct irq_data *d)
 {
-	struct irq_desc *desc = irq_to_desc(irq);
+	struct irq_desc *desc = irq_to_desc(d->irq);
 
-	desc->chip->mask(irq);
+	desc->irq_data.chip->irq_mask(d);
 }
 
-static void pxa_unmask_low_gpio(unsigned int irq)
+static void pxa_unmask_low_gpio(struct irq_data *d)
 {
-	struct irq_desc *desc = irq_to_desc(irq);
+	struct irq_desc *desc = irq_to_desc(d->irq);
 
-	desc->chip->unmask(irq);
+	desc->irq_data.chip->irq_unmask(d);
 }
 
 static struct irq_chip pxa_low_gpio_chip = {
 	.name		= "GPIO-l",
-	.ack		= pxa_ack_low_gpio,
-	.mask		= pxa_mask_low_gpio,
-	.unmask		= pxa_unmask_low_gpio,
-	.set_type	= pxa_set_low_gpio_type,
+	.irq_ack	= pxa_ack_low_gpio,
+	.irq_mask	= pxa_mask_low_gpio,
+	.irq_unmask	= pxa_unmask_low_gpio,
+	.irq_set_type	= pxa_set_low_gpio_type,
 };
 
 static void __init pxa_init_low_gpio_irq(set_wake_t fn)
@@ -145,7 +145,7 @@ static void __init pxa_init_low_gpio_irq(set_wake_t fn)
 		set_irq_flags(irq, IRQF_VALID);
 	}
 
-	pxa_low_gpio_chip.set_wake = fn;
+	pxa_low_gpio_chip.irq_set_wake = fn;
 }
 
 static inline void __iomem *irq_base(int i)
@@ -188,7 +188,7 @@ void __init pxa_init_irq(int irq_nr, set_wake_t fn)
 	/* only unmasked interrupts kick us out of idle */
 	__raw_writel(1, irq_base(0) + ICCR);
 
-	pxa_internal_irq_chip.set_wake = fn;
+	pxa_internal_irq_chip.irq_set_wake = fn;
 	pxa_init_low_gpio_irq(fn);
 }
 

commit a79a9ad94acdbd0106491f5a444167636562460f
Author: Haojian Zhuang <haojian.zhuang@marvell.com>
Date:   Wed Nov 24 11:54:22 2010 +0800

    ARM: pxa: sanitize IRQ registers access based on offset
    
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Haojian Zhuang <haojian.zhuang@marvell.com>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index b5cafe2b4888..54e91c9e71c8 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -16,20 +16,31 @@
 #include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/sysdev.h>
+#include <linux/io.h>
+#include <linux/irq.h>
 
 #include <mach/hardware.h>
-#include <asm/irq.h>
-#include <asm/mach/irq.h>
+#include <mach/irqs.h>
 #include <mach/gpio.h>
-#include <mach/regs-intc.h>
 
 #include "generic.h"
 
-#define MAX_INTERNAL_IRQS	128
+#define IRQ_BASE		(void __iomem *)io_p2v(0x40d00000)
+
+#define ICIP			(0x000)
+#define ICMR			(0x004)
+#define ICLR			(0x008)
+#define ICFR			(0x00c)
+#define ICPR			(0x010)
+#define ICCR			(0x014)
+#define ICHP			(0x018)
+#define IPR(i)			(((i) < 32) ? (0x01c + ((i) << 2)) :		\
+				((i) < 64) ? (0x0b0 + (((i) - 32) << 2)) :	\
+				      (0x144 + (((i) - 64) << 2)))
+#define IPR_VALID		(1 << 31)
+#define IRQ_BIT(n)		(((n) - PXA_IRQ(0)) & 0x1f)
 
-#define IRQ_BIT(n)	(((n) - PXA_IRQ(0)) & 0x1f)
-#define _ICMR(n)	(*((((n) - PXA_IRQ(0)) & ~0x1f) ? &ICMR2 : &ICMR))
-#define _ICLR(n)	(*((((n) - PXA_IRQ(0)) & ~0x1f) ? &ICLR2 : &ICLR))
+#define MAX_INTERNAL_IRQS	128
 
 /*
  * This is for peripheral IRQs internal to the PXA chip.
@@ -44,12 +55,20 @@ static inline int cpu_has_ipr(void)
 
 static void pxa_mask_irq(unsigned int irq)
 {
-	_ICMR(irq) &= ~(1 << IRQ_BIT(irq));
+	void __iomem *base = get_irq_chip_data(irq);
+	uint32_t icmr = __raw_readl(base + ICMR);
+
+	icmr &= ~(1 << IRQ_BIT(irq));
+	__raw_writel(icmr, base + ICMR);
 }
 
 static void pxa_unmask_irq(unsigned int irq)
 {
-	_ICMR(irq) |= 1 << IRQ_BIT(irq);
+	void __iomem *base = get_irq_chip_data(irq);
+	uint32_t icmr = __raw_readl(base + ICMR);
+
+	icmr |= 1 << IRQ_BIT(irq);
+	__raw_writel(icmr, base + ICMR);
 }
 
 static struct irq_chip pxa_internal_irq_chip = {
@@ -91,12 +110,16 @@ static void pxa_ack_low_gpio(unsigned int irq)
 
 static void pxa_mask_low_gpio(unsigned int irq)
 {
-	ICMR &= ~(1 << (irq - PXA_IRQ(0)));
+	struct irq_desc *desc = irq_to_desc(irq);
+
+	desc->chip->mask(irq);
 }
 
 static void pxa_unmask_low_gpio(unsigned int irq)
 {
-	ICMR |= 1 << (irq - PXA_IRQ(0));
+	struct irq_desc *desc = irq_to_desc(irq);
+
+	desc->chip->unmask(irq);
 }
 
 static struct irq_chip pxa_low_gpio_chip = {
@@ -125,33 +148,45 @@ static void __init pxa_init_low_gpio_irq(set_wake_t fn)
 	pxa_low_gpio_chip.set_wake = fn;
 }
 
+static inline void __iomem *irq_base(int i)
+{
+	static unsigned long phys_base[] = {
+		0x40d00000,
+		0x40d0009c,
+		0x40d00130,
+	};
+
+	return (void __iomem *)io_p2v(phys_base[i >> 5]);
+}
+
 void __init pxa_init_irq(int irq_nr, set_wake_t fn)
 {
-	int irq, i;
+	int irq, i, n;
 
 	BUG_ON(irq_nr > MAX_INTERNAL_IRQS);
 
 	pxa_internal_irq_nr = irq_nr;
 
-	for (irq = PXA_IRQ(0); irq < PXA_IRQ(irq_nr); irq += 32) {
-		_ICMR(irq) = 0;	/* disable all IRQs */
-		_ICLR(irq) = 0;	/* all IRQs are IRQ, not FIQ */
-	}
-
-	/* initialize interrupt priority */
-	if (cpu_has_ipr()) {
-		for (i = 0; i < irq_nr; i++)
-			IPR(i) = i | (1 << 31);
+	for (n = 0; n < irq_nr; n += 32) {
+		void __iomem *base = irq_base(n);
+
+		__raw_writel(0, base + ICMR);	/* disable all IRQs */
+		__raw_writel(0, base + ICLR);	/* all IRQs are IRQ, not FIQ */
+		for (i = n; (i < (n + 32)) && (i < irq_nr); i++) {
+			/* initialize interrupt priority */
+			if (cpu_has_ipr())
+				__raw_writel(i | IPR_VALID, IRQ_BASE + IPR(i));
+
+			irq = PXA_IRQ(i);
+			set_irq_chip(irq, &pxa_internal_irq_chip);
+			set_irq_chip_data(irq, base);
+			set_irq_handler(irq, handle_level_irq);
+			set_irq_flags(irq, IRQF_VALID);
+		}
 	}
 
 	/* only unmasked interrupts kick us out of idle */
-	ICCR = 1;
-
-	for (irq = PXA_IRQ(0); irq < PXA_IRQ(irq_nr); irq++) {
-		set_irq_chip(irq, &pxa_internal_irq_chip);
-		set_irq_handler(irq, handle_level_irq);
-		set_irq_flags(irq, IRQF_VALID);
-	}
+	__raw_writel(1, irq_base(0) + ICCR);
 
 	pxa_internal_irq_chip.set_wake = fn;
 	pxa_init_low_gpio_irq(fn);
@@ -163,16 +198,18 @@ static unsigned long saved_ipr[MAX_INTERNAL_IRQS];
 
 static int pxa_irq_suspend(struct sys_device *dev, pm_message_t state)
 {
-	int i, irq = PXA_IRQ(0);
+	int i;
+
+	for (i = 0; i < pxa_internal_irq_nr; i += 32) {
+		void __iomem *base = irq_base(i);
 
-	for (i = 0; irq < PXA_IRQ(pxa_internal_irq_nr); i++, irq += 32) {
-		saved_icmr[i] = _ICMR(irq);
-		_ICMR(irq) = 0;
+		saved_icmr[i] = __raw_readl(base + ICMR);
+		__raw_writel(0, base + ICMR);
 	}
 
 	if (cpu_has_ipr()) {
 		for (i = 0; i < pxa_internal_irq_nr; i++)
-			saved_ipr[i] = IPR(i);
+			saved_ipr[i] = __raw_readl(IRQ_BASE + IPR(i));
 	}
 
 	return 0;
@@ -180,19 +217,20 @@ static int pxa_irq_suspend(struct sys_device *dev, pm_message_t state)
 
 static int pxa_irq_resume(struct sys_device *dev)
 {
-	int i, irq = PXA_IRQ(0);
+	int i;
 
-	if (cpu_has_ipr()) {
-		for (i = 0; i < pxa_internal_irq_nr; i++)
-			IPR(i) = saved_ipr[i];
-	}
+	for (i = 0; i < pxa_internal_irq_nr; i += 32) {
+		void __iomem *base = irq_base(i);
 
-	for (i = 0; irq < PXA_IRQ(pxa_internal_irq_nr); i++, irq += 32) {
-		_ICMR(irq) = saved_icmr[i];
-		_ICLR(irq) = 0;
+		__raw_writel(saved_icmr[i], base + ICMR);
+		__raw_writel(0, base + ICLR);
 	}
 
-	ICCR = 1;
+	if (!cpu_is_pxa25x())
+		for (i = 0; i < pxa_internal_irq_nr; i++)
+			__raw_writel(saved_ipr[i], IRQ_BASE + IPR(i));
+
+	__raw_writel(1, IRQ_BASE + ICCR);
 	return 0;
 }
 #else

commit bb71bdd31b48efa2b9834f1a47eb5f657e3c217c
Author: Haojian Zhuang <haojian.zhuang@marvell.com>
Date:   Wed Nov 17 19:03:36 2010 +0800

    ARM: pxa: redefine irqs.h
    
    Define all IRQs in irqs.h. If some IRQs are sharing one IRQ number, define
    them together. If some IRQs are sharing same name with different IRQ number,
    define different IRQ.
    
    Signed-off-by: Haojian Zhuang <haojian.zhuang@marvell.com>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 1beb40f692fc..b5cafe2b4888 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -37,6 +37,11 @@
 
 static int pxa_internal_irq_nr;
 
+static inline int cpu_has_ipr(void)
+{
+	return !cpu_is_pxa25x();
+}
+
 static void pxa_mask_irq(unsigned int irq)
 {
 	_ICMR(irq) &= ~(1 << IRQ_BIT(irq));
@@ -134,7 +139,7 @@ void __init pxa_init_irq(int irq_nr, set_wake_t fn)
 	}
 
 	/* initialize interrupt priority */
-	if (cpu_is_pxa27x() || cpu_is_pxa3xx()) {
+	if (cpu_has_ipr()) {
 		for (i = 0; i < irq_nr; i++)
 			IPR(i) = i | (1 << 31);
 	}
@@ -165,7 +170,7 @@ static int pxa_irq_suspend(struct sys_device *dev, pm_message_t state)
 		_ICMR(irq) = 0;
 	}
 
-	if (cpu_is_pxa27x() || cpu_is_pxa3xx()) {
+	if (cpu_has_ipr()) {
 		for (i = 0; i < pxa_internal_irq_nr; i++)
 			saved_ipr[i] = IPR(i);
 	}
@@ -177,7 +182,7 @@ static int pxa_irq_resume(struct sys_device *dev)
 {
 	int i, irq = PXA_IRQ(0);
 
-	if (cpu_is_pxa27x() || cpu_is_pxa3xx()) {
+	if (cpu_has_ipr()) {
 		for (i = 0; i < pxa_internal_irq_nr; i++)
 			IPR(i) = saved_ipr[i];
 	}

commit c70f5a60994058895384f593989a9fbe6fe6adee
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Mon Jan 11 20:39:37 2010 +0800

    [ARM] pxa: fix irq suspend/resume for pxa25x
    
    PXA25x does not have IPR registers, saving and restoring should happen
    only for pxa27x and pxa3xx.
    
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 6112af431fa4..1beb40f692fc 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -164,8 +164,11 @@ static int pxa_irq_suspend(struct sys_device *dev, pm_message_t state)
 		saved_icmr[i] = _ICMR(irq);
 		_ICMR(irq) = 0;
 	}
-	for (i = 0; i < pxa_internal_irq_nr; i++)
-		saved_ipr[i] = IPR(i);
+
+	if (cpu_is_pxa27x() || cpu_is_pxa3xx()) {
+		for (i = 0; i < pxa_internal_irq_nr; i++)
+			saved_ipr[i] = IPR(i);
+	}
 
 	return 0;
 }
@@ -174,12 +177,15 @@ static int pxa_irq_resume(struct sys_device *dev)
 {
 	int i, irq = PXA_IRQ(0);
 
+	if (cpu_is_pxa27x() || cpu_is_pxa3xx()) {
+		for (i = 0; i < pxa_internal_irq_nr; i++)
+			IPR(i) = saved_ipr[i];
+	}
+
 	for (i = 0; irq < PXA_IRQ(pxa_internal_irq_nr); i++, irq += 32) {
 		_ICMR(irq) = saved_icmr[i];
 		_ICLR(irq) = 0;
 	}
-	for (i = 0; i < pxa_internal_irq_nr; i++)
-		IPR(i) = saved_ipr[i];
 
 	ICCR = 1;
 	return 0;

commit c482ae4dcf23fd241321595d71bbe8aee33eabf5
Author: Haojian Zhuang <haojian.zhuang@marvell.com>
Date:   Mon Nov 2 14:02:21 2009 -0500

    [ARM] pxa: fix resume failure by saving/restoring IPRx registers
    
    Since interrupt handler is changed to use interrupt priority, we also need
    to save and restore these interrupt controller registers in suspend/resume
    routine.
    
    Signed-off-by: Haojian Zhuang <haojian.zhuang@marvell.com>
    Tested-by: Daniel Mack <daniel@caiaq.de>
    Tested-by: Pavel Machek <pavel@ucw.cz>
    Tested-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index d694ce289668..6112af431fa4 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -25,6 +25,8 @@
 
 #include "generic.h"
 
+#define MAX_INTERNAL_IRQS	128
+
 #define IRQ_BIT(n)	(((n) - PXA_IRQ(0)) & 0x1f)
 #define _ICMR(n)	(*((((n) - PXA_IRQ(0)) & ~0x1f) ? &ICMR2 : &ICMR))
 #define _ICLR(n)	(*((((n) - PXA_IRQ(0)) & ~0x1f) ? &ICLR2 : &ICLR))
@@ -122,6 +124,8 @@ void __init pxa_init_irq(int irq_nr, set_wake_t fn)
 {
 	int irq, i;
 
+	BUG_ON(irq_nr > MAX_INTERNAL_IRQS);
+
 	pxa_internal_irq_nr = irq_nr;
 
 	for (irq = PXA_IRQ(0); irq < PXA_IRQ(irq_nr); irq += 32) {
@@ -149,7 +153,8 @@ void __init pxa_init_irq(int irq_nr, set_wake_t fn)
 }
 
 #ifdef CONFIG_PM
-static unsigned long saved_icmr[2];
+static unsigned long saved_icmr[MAX_INTERNAL_IRQS/32];
+static unsigned long saved_ipr[MAX_INTERNAL_IRQS];
 
 static int pxa_irq_suspend(struct sys_device *dev, pm_message_t state)
 {
@@ -159,6 +164,8 @@ static int pxa_irq_suspend(struct sys_device *dev, pm_message_t state)
 		saved_icmr[i] = _ICMR(irq);
 		_ICMR(irq) = 0;
 	}
+	for (i = 0; i < pxa_internal_irq_nr; i++)
+		saved_ipr[i] = IPR(i);
 
 	return 0;
 }
@@ -171,6 +178,8 @@ static int pxa_irq_resume(struct sys_device *dev)
 		_ICMR(irq) = saved_icmr[i];
 		_ICLR(irq) = 0;
 	}
+	for (i = 0; i < pxa_internal_irq_nr; i++)
+		IPR(i) = saved_ipr[i];
 
 	ICCR = 1;
 	return 0;

commit d2c37068429b29d6549cf3486fc84b836689e122
Author: Haojian Zhuang <haojian.zhuang@marvell.com>
Date:   Wed Aug 19 19:49:31 2009 +0800

    [ARM] pxa: initialize default interrupt priority and use ICHP for IRQ handling
    
    Signed-off-by: Haojian Zhuang <haojian.zhuang@marvell.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index f6e0300e4f64..d694ce289668 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -120,7 +120,7 @@ static void __init pxa_init_low_gpio_irq(set_wake_t fn)
 
 void __init pxa_init_irq(int irq_nr, set_wake_t fn)
 {
-	int irq;
+	int irq, i;
 
 	pxa_internal_irq_nr = irq_nr;
 
@@ -129,6 +129,12 @@ void __init pxa_init_irq(int irq_nr, set_wake_t fn)
 		_ICLR(irq) = 0;	/* all IRQs are IRQ, not FIQ */
 	}
 
+	/* initialize interrupt priority */
+	if (cpu_is_pxa27x() || cpu_is_pxa3xx()) {
+		for (i = 0; i < irq_nr; i++)
+			IPR(i) = i | (1 << 31);
+	}
+
 	/* only unmasked interrupts kick us out of idle */
 	ICCR = 1;
 

commit 5bf3df3f00f507119a26ba0780aa8799e741615c
Author: Eric Miao <eric.miao@marvell.com>
Date:   Tue Jan 20 11:04:16 2009 +0800

    [ARM] pxa: separate definitions from pxa-regs.h and remove it finally
    
    The remaining registers are separated into:
    
       - <mach/regs-ost.h>
       - <mach/regs-rtc.h>
       - <mach/regs-intc.h>
    
    and then we can remove pxa-regs.h completely. Instead of #include this
    file, let's:
    
    1. include the specific <mach/regs-*.h> with care (if that's absolutely
       necessary)
    
    2. define the registers in the driver, make cleanly defined API to expose
       the register access to external with sufficient reason
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index d3d40a31f9da..f6e0300e4f64 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -20,8 +20,8 @@
 #include <mach/hardware.h>
 #include <asm/irq.h>
 #include <asm/mach/irq.h>
-#include <mach/pxa-regs.h>
 #include <mach/gpio.h>
+#include <mach/regs-intc.h>
 
 #include "generic.h"
 

commit a58fbcd8ad17ddaa0c7aadbbbd20de4ebc807fa4
Author: Eric Miao <eric.miao@marvell.com>
Date:   Tue Jan 6 17:37:37 2009 +0800

    [ARM] pxa: move IRQ handling of GPIO 0 and 1 outside of gpio.c
    
    This is part of the work making gpio.c generic enough, the changes
    include:
    
    1. move IRQ handling of GPIO 0 and 1 outside (and back into irq.c)
    
    2. pxa_init_gpio() accepts a range for muxed GPIO IRQs, and an IRQ
       number for the muxed GPIOs
    
    3. __gpio_is_occupied() and __gpio_is_inverted() are made inline,
       and are moved into <mach/gpio.h> instead of generic gpio.c
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index fa69c3a6a38e..d3d40a31f9da 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -21,6 +21,7 @@
 #include <asm/irq.h>
 #include <asm/mach/irq.h>
 #include <mach/pxa-regs.h>
+#include <mach/gpio.h>
 
 #include "generic.h"
 
@@ -51,6 +52,72 @@ static struct irq_chip pxa_internal_irq_chip = {
 	.unmask		= pxa_unmask_irq,
 };
 
+/*
+ * GPIO IRQs for GPIO 0 and 1
+ */
+static int pxa_set_low_gpio_type(unsigned int irq, unsigned int type)
+{
+	int gpio = irq - IRQ_GPIO0;
+
+	if (__gpio_is_occupied(gpio)) {
+		pr_err("%s failed: GPIO is configured\n", __func__);
+		return -EINVAL;
+	}
+
+	if (type & IRQ_TYPE_EDGE_RISING)
+		GRER0 |= GPIO_bit(gpio);
+	else
+		GRER0 &= ~GPIO_bit(gpio);
+
+	if (type & IRQ_TYPE_EDGE_FALLING)
+		GFER0 |= GPIO_bit(gpio);
+	else
+		GFER0 &= ~GPIO_bit(gpio);
+
+	return 0;
+}
+
+static void pxa_ack_low_gpio(unsigned int irq)
+{
+	GEDR0 = (1 << (irq - IRQ_GPIO0));
+}
+
+static void pxa_mask_low_gpio(unsigned int irq)
+{
+	ICMR &= ~(1 << (irq - PXA_IRQ(0)));
+}
+
+static void pxa_unmask_low_gpio(unsigned int irq)
+{
+	ICMR |= 1 << (irq - PXA_IRQ(0));
+}
+
+static struct irq_chip pxa_low_gpio_chip = {
+	.name		= "GPIO-l",
+	.ack		= pxa_ack_low_gpio,
+	.mask		= pxa_mask_low_gpio,
+	.unmask		= pxa_unmask_low_gpio,
+	.set_type	= pxa_set_low_gpio_type,
+};
+
+static void __init pxa_init_low_gpio_irq(set_wake_t fn)
+{
+	int irq;
+
+	/* clear edge detection on GPIO 0 and 1 */
+	GFER0 &= ~0x3;
+	GRER0 &= ~0x3;
+	GEDR0 = 0x3;
+
+	for (irq = IRQ_GPIO0; irq <= IRQ_GPIO1; irq++) {
+		set_irq_chip(irq, &pxa_low_gpio_chip);
+		set_irq_handler(irq, handle_edge_irq);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+
+	pxa_low_gpio_chip.set_wake = fn;
+}
+
 void __init pxa_init_irq(int irq_nr, set_wake_t fn)
 {
 	int irq;
@@ -72,6 +139,7 @@ void __init pxa_init_irq(int irq_nr, set_wake_t fn)
 	}
 
 	pxa_internal_irq_chip.set_wake = fn;
+	pxa_init_low_gpio_irq(fn);
 }
 
 #ifdef CONFIG_PM

commit 57a7a62eb65b35f51814382b0841ff99be242880
Author: Marc Zyngier <maz@misterjones.org>
Date:   Mon Sep 1 13:03:32 2008 +0100

    [ARM] 5233/1: Allow PXA to have ISA IRQs numbered 0-15
    
    Allow PXA IRQs to be numbered starting at 16, leaving 0 to 15 for the
    ISA IRQs, if needed.
    
    This patch depends on RMK's PXA_HAVE_BOARD_IRQS patch.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@altran.com>
    Acked-by: Russel King <linux@arm.linux.org.uk>
    Acked-by: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 5e95c5372fec..fa69c3a6a38e 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -57,7 +57,7 @@ void __init pxa_init_irq(int irq_nr, set_wake_t fn)
 
 	pxa_internal_irq_nr = irq_nr;
 
-	for (irq = 0; irq < irq_nr; irq += 32) {
+	for (irq = PXA_IRQ(0); irq < PXA_IRQ(irq_nr); irq += 32) {
 		_ICMR(irq) = 0;	/* disable all IRQs */
 		_ICLR(irq) = 0;	/* all IRQs are IRQ, not FIQ */
 	}

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 26a9d8b7d5f1..5e95c5372fec 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -17,10 +17,10 @@
 #include <linux/interrupt.h>
 #include <linux/sysdev.h>
 
-#include <asm/arch/hardware.h>
+#include <mach/hardware.h>
 #include <asm/irq.h>
 #include <asm/mach/irq.h>
-#include <asm/arch/pxa-regs.h>
+#include <mach/pxa-regs.h>
 
 #include "generic.h"
 

commit be509729356b7433f73df2b9a966674a437fbbc1
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Aug 4 10:41:28 2008 +0100

    [ARM] Remove asm/hardware.h, use asm/arch/hardware.h instead
    
    Remove includes of asm/hardware.h in addition to asm/arch/hardware.h.
    Then, since asm/hardware.h only exists to include asm/arch/hardware.h,
    update everything to directly include asm/arch/hardware.h and remove
    asm/hardware.h.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index fbff557bb225..26a9d8b7d5f1 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -17,7 +17,7 @@
 #include <linux/interrupt.h>
 #include <linux/sysdev.h>
 
-#include <asm/hardware.h>
+#include <asm/arch/hardware.h>
 #include <asm/irq.h>
 #include <asm/mach/irq.h>
 #include <asm/arch/pxa-regs.h>

commit f1b23586c1f50d4c5684e56395140ec1cd8b688d
Author: Philipp Zabel <philipp.zabel@gmail.com>
Date:   Mon Jun 30 18:08:11 2008 +0100

    [ARM] 5135/1: pxa: drop superfluous asm/arch/pxa2xx-gpio.h includes
    
    Both i2c-pxa.c and irq.c still include pxa2xx-gpio.h although is is not
    needed anymore.
    
    Signed-off-by: Philipp Zabel <philipp.zabel@gmail.com>
    Acked-by: Eric Miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index a9a0c3fab159..fbff557bb225 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -21,7 +21,6 @@
 #include <asm/irq.h>
 #include <asm/mach/irq.h>
 #include <asm/arch/pxa-regs.h>
-#include <asm/arch/pxa2xx-gpio.h>
 
 #include "generic.h"
 

commit a683b14df8f4320d0ef6cac93a6d9806173bf339
Author: eric miao <eric.miao@marvell.com>
Date:   Mon Mar 3 09:44:25 2008 +0800

    [ARM] pxa: separate GPIOs and their mode definitions to pxa2xx-gpio.h
    
    two reasons:
    1. GPIO namings and their mode definitions are conceptually not part
       of the PXA register definitions
    
    2. this is actually a temporary move in the transition of PXA2xx to
       use MFP-alike APIs (as what PXA3xx is now doing), so that legacy
       code will still work and new code can be added in step by step
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index fbff557bb225..a9a0c3fab159 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -21,6 +21,7 @@
 #include <asm/irq.h>
 #include <asm/mach/irq.h>
 #include <asm/arch/pxa-regs.h>
+#include <asm/arch/pxa2xx-gpio.h>
 
 #include "generic.h"
 

commit b9e25aced33eeb7279ccbaef198f28370cfb4e93
Author: eric miao <eric.miao@marvell.com>
Date:   Tue Mar 4 14:19:58 2008 +0800

    [ARM] pxa: merge assignment of set_wake into pxa_init_{irq,gpio}()
    
    To further clean up the GPIO and IRQ structure:
    
    1. pxa_init_irq_gpio() and pxa_init_gpio() combines into a single
       function pxa_init_gpio()
    
    2. assignment of set_wake merged into pxa_init_{irq,gpio}() as
       an argument
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index cccc3ed3c679..fbff557bb225 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -51,7 +51,7 @@ static struct irq_chip pxa_internal_irq_chip = {
 	.unmask		= pxa_unmask_irq,
 };
 
-void __init pxa_init_irq(int irq_nr)
+void __init pxa_init_irq(int irq_nr, set_wake_t fn)
 {
 	int irq;
 
@@ -70,12 +70,8 @@ void __init pxa_init_irq(int irq_nr)
 		set_irq_handler(irq, handle_level_irq);
 		set_irq_flags(irq, IRQF_VALID);
 	}
-}
 
-void __init pxa_init_irq_set_wake(int (*set_wake)(unsigned int, unsigned int))
-{
-	pxa_internal_irq_chip.set_wake = set_wake;
-	pxa_init_gpio_set_wake(set_wake);
+	pxa_internal_irq_chip.set_wake = fn;
 }
 
 #ifdef CONFIG_PM

commit f6fb7af4768bc1ddc2349f6eaefedd746c8e4913
Author: eric miao <eric.miao@marvell.com>
Date:   Tue Mar 4 13:53:05 2008 +0800

    [ARM] pxa: integrate low IRQ chip (ICIP) and high IRQ chip (ICIP2) into one
    
    This makes the code better organized and simplified a bit.  The change
    will lose a bit of performance when performing IRQ ack/mask/unmask,but
    that's not too much after checking the result binary.
    
    This patch also removes the ugly #ifdef CONFIG_PXA27x .. #endif by
    carefully not to access those pxa{27x,3xx} specific registers, this
    is done by keeping an internal IRQ number variable.  The pxa-regs.h
    is also modified so registers for IRQ > PXA_IRQ(31) are made public
    even if CONFIG_PXA{27x,3xx} isn't defined (for pxa25x's sake)
    
    The incorrect assumption in the original code that internal irq starts
    from 0 is also corrected by comparing with PXA_IRQ(0).
    
    "struct sys_device" for the IRQ are reduced into one single device on
    pxa{27x,3xx}.
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index da3a44a4249a..cccc3ed3c679 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -24,92 +24,57 @@
 
 #include "generic.h"
 
+#define IRQ_BIT(n)	(((n) - PXA_IRQ(0)) & 0x1f)
+#define _ICMR(n)	(*((((n) - PXA_IRQ(0)) & ~0x1f) ? &ICMR2 : &ICMR))
+#define _ICLR(n)	(*((((n) - PXA_IRQ(0)) & ~0x1f) ? &ICLR2 : &ICLR))
 
 /*
  * This is for peripheral IRQs internal to the PXA chip.
  */
 
-static void pxa_mask_low_irq(unsigned int irq)
+static int pxa_internal_irq_nr;
+
+static void pxa_mask_irq(unsigned int irq)
 {
-	ICMR &= ~(1 << irq);
+	_ICMR(irq) &= ~(1 << IRQ_BIT(irq));
 }
 
-static void pxa_unmask_low_irq(unsigned int irq)
+static void pxa_unmask_irq(unsigned int irq)
 {
-	ICMR |= (1 << irq);
+	_ICMR(irq) |= 1 << IRQ_BIT(irq);
 }
 
-static struct irq_chip pxa_internal_chip_low = {
+static struct irq_chip pxa_internal_irq_chip = {
 	.name		= "SC",
-	.ack		= pxa_mask_low_irq,
-	.mask		= pxa_mask_low_irq,
-	.unmask		= pxa_unmask_low_irq,
+	.ack		= pxa_mask_irq,
+	.mask		= pxa_mask_irq,
+	.unmask		= pxa_unmask_irq,
 };
 
-void __init pxa_init_irq_low(void)
+void __init pxa_init_irq(int irq_nr)
 {
 	int irq;
 
-	/* disable all IRQs */
-	ICMR = 0;
+	pxa_internal_irq_nr = irq_nr;
 
-	/* all IRQs are IRQ, not FIQ */
-	ICLR = 0;
+	for (irq = 0; irq < irq_nr; irq += 32) {
+		_ICMR(irq) = 0;	/* disable all IRQs */
+		_ICLR(irq) = 0;	/* all IRQs are IRQ, not FIQ */
+	}
 
 	/* only unmasked interrupts kick us out of idle */
 	ICCR = 1;
 
-	for (irq = PXA_IRQ(0); irq <= PXA_IRQ(31); irq++) {
-		set_irq_chip(irq, &pxa_internal_chip_low);
-		set_irq_handler(irq, handle_level_irq);
-		set_irq_flags(irq, IRQF_VALID);
-	}
-}
-
-#if defined(CONFIG_PXA27x) || defined(CONFIG_PXA3xx)
-
-/*
- * This is for the second set of internal IRQs as found on the PXA27x.
- */
-
-static void pxa_mask_high_irq(unsigned int irq)
-{
-	ICMR2 &= ~(1 << (irq - 32));
-}
-
-static void pxa_unmask_high_irq(unsigned int irq)
-{
-	ICMR2 |= (1 << (irq - 32));
-}
-
-static struct irq_chip pxa_internal_chip_high = {
-	.name		= "SC-hi",
-	.ack		= pxa_mask_high_irq,
-	.mask		= pxa_mask_high_irq,
-	.unmask		= pxa_unmask_high_irq,
-};
-
-void __init pxa_init_irq_high(void)
-{
-	int irq;
-
-	ICMR2 = 0;
-	ICLR2 = 0;
-
-	for (irq = PXA_IRQ(32); irq < PXA_IRQ(64); irq++) {
-		set_irq_chip(irq, &pxa_internal_chip_high);
+	for (irq = PXA_IRQ(0); irq < PXA_IRQ(irq_nr); irq++) {
+		set_irq_chip(irq, &pxa_internal_irq_chip);
 		set_irq_handler(irq, handle_level_irq);
 		set_irq_flags(irq, IRQF_VALID);
 	}
 }
-#endif
 
 void __init pxa_init_irq_set_wake(int (*set_wake)(unsigned int, unsigned int))
 {
-	pxa_internal_chip_low.set_wake = set_wake;
-#ifdef CONFIG_PXA27x
-	pxa_internal_chip_high.set_wake = set_wake;
-#endif
+	pxa_internal_irq_chip.set_wake = set_wake;
 	pxa_init_gpio_set_wake(set_wake);
 }
 
@@ -118,19 +83,11 @@ static unsigned long saved_icmr[2];
 
 static int pxa_irq_suspend(struct sys_device *dev, pm_message_t state)
 {
-	switch (dev->id) {
-	case 0:
-		saved_icmr[0] = ICMR;
-		ICMR = 0;
-		break;
-#if defined(CONFIG_PXA27x) || defined(CONFIG_PXA3xx)
-	case 1:
-		saved_icmr[1] = ICMR2;
-		ICMR2 = 0;
-		break;
-#endif
-	default:
-		return -EINVAL;
+	int i, irq = PXA_IRQ(0);
+
+	for (i = 0; irq < PXA_IRQ(pxa_internal_irq_nr); i++, irq += 32) {
+		saved_icmr[i] = _ICMR(irq);
+		_ICMR(irq) = 0;
 	}
 
 	return 0;
@@ -138,22 +95,14 @@ static int pxa_irq_suspend(struct sys_device *dev, pm_message_t state)
 
 static int pxa_irq_resume(struct sys_device *dev)
 {
-	switch (dev->id) {
-	case 0:
-		ICMR = saved_icmr[0];
-		ICLR = 0;
-		ICCR = 1;
-		break;
-#if defined(CONFIG_PXA27x) || defined(CONFIG_PXA3xx)
-	case 1:
-		ICMR2 = saved_icmr[1];
-		ICLR2 = 0;
-		break;
-#endif
-	default:
-		return -EINVAL;
+	int i, irq = PXA_IRQ(0);
+
+	for (i = 0; irq < PXA_IRQ(pxa_internal_irq_nr); i++, irq += 32) {
+		_ICMR(irq) = saved_icmr[i];
+		_ICLR(irq) = 0;
 	}
 
+	ICCR = 1;
 	return 0;
 }
 #else

commit e3630db1fa7677b350fd5a1ac5498cc48448ae28
Author: eric miao <eric.miao@marvell.com>
Date:   Tue Mar 4 11:42:26 2008 +0800

    [ARM] pxa: move GPIO IRQ specific code out of irq.c into gpio.c
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 4fd4560dd3ad..da3a44a4249a 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -1,7 +1,7 @@
 /*
  *  linux/arch/arm/mach-pxa/irq.c
  *
- *  Generic PXA IRQ handling, GPIO IRQ demultiplexing, etc.
+ *  Generic PXA IRQ handling
  *
  *  Author:	Nicolas Pitre
  *  Created:	Jun 15, 2001
@@ -104,188 +104,6 @@ void __init pxa_init_irq_high(void)
 }
 #endif
 
-/*
- * PXA GPIO edge detection for IRQs:
- * IRQs are generated on Falling-Edge, Rising-Edge, or both.
- * Use this instead of directly setting GRER/GFER.
- */
-
-static long GPIO_IRQ_rising_edge[4];
-static long GPIO_IRQ_falling_edge[4];
-static long GPIO_IRQ_mask[4];
-
-static int pxa_gpio_irq_type(unsigned int irq, unsigned int type)
-{
-	int gpio, idx;
-
-	gpio = IRQ_TO_GPIO(irq);
-	idx = gpio >> 5;
-
-	if (type == IRQ_TYPE_PROBE) {
-		/* Don't mess with enabled GPIOs using preconfigured edges or
-		 * GPIOs set to alternate function or to output during probe
-		 */
-		if ((GPIO_IRQ_rising_edge[idx] |
-		     GPIO_IRQ_falling_edge[idx] |
-		     GPDR(gpio)) & GPIO_bit(gpio))
-			return 0;
-		if (GAFR(gpio) & (0x3 << (((gpio) & 0xf)*2)))
-			return 0;
-		type = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;
-	}
-
-	pxa_gpio_mode(gpio | GPIO_IN);
-
-	if (type & IRQ_TYPE_EDGE_RISING)
-		__set_bit(gpio, GPIO_IRQ_rising_edge);
-	else
-		__clear_bit(gpio, GPIO_IRQ_rising_edge);
-
-	if (type & IRQ_TYPE_EDGE_FALLING)
-		__set_bit(gpio, GPIO_IRQ_falling_edge);
-	else
-		__clear_bit(gpio, GPIO_IRQ_falling_edge);
-
-	GRER(gpio) = GPIO_IRQ_rising_edge[idx] & GPIO_IRQ_mask[idx];
-	GFER(gpio) = GPIO_IRQ_falling_edge[idx] & GPIO_IRQ_mask[idx];
-
-	pr_debug("%s: IRQ%d (GPIO%d) - edge%s%s\n", __func__, irq, gpio,
-		((type & IRQ_TYPE_EDGE_RISING)  ? " rising"  : ""),
-		((type & IRQ_TYPE_EDGE_FALLING) ? " falling" : ""));
-	return 0;
-}
-
-/*
- * GPIO IRQs must be acknowledged.  This is for GPIO 0 and 1.
- */
-
-static void pxa_ack_low_gpio(unsigned int irq)
-{
-	GEDR0 = (1 << (irq - IRQ_GPIO0));
-}
-
-static void pxa_mask_low_gpio(unsigned int irq)
-{
-	ICMR &= ~(1 << (irq - PXA_IRQ(0)));
-}
-
-static void pxa_unmask_low_gpio(unsigned int irq)
-{
-	ICMR |= 1 << (irq - PXA_IRQ(0));
-}
-
-static struct irq_chip pxa_low_gpio_chip = {
-	.name		= "GPIO-l",
-	.ack		= pxa_ack_low_gpio,
-	.mask		= pxa_mask_low_gpio,
-	.unmask		= pxa_unmask_low_gpio,
-	.set_type	= pxa_gpio_irq_type,
-};
-
-/*
- * Demux handler for GPIO>=2 edge detect interrupts
- */
-
-#define GEDR_BITS	(sizeof(gedr) * BITS_PER_BYTE)
-
-static void pxa_gpio_demux_handler(unsigned int irq, struct irq_desc *desc)
-{
-	int loop, bit, n;
-	unsigned long gedr[4];
-
-	do {
-		gedr[0] = GEDR0 & GPIO_IRQ_mask[0] & ~3;
-		gedr[1] = GEDR1 & GPIO_IRQ_mask[1];
-		gedr[2] = GEDR2 & GPIO_IRQ_mask[2];
-		gedr[3] = GEDR3 & GPIO_IRQ_mask[3];
-
-		GEDR0 = gedr[0]; GEDR1 = gedr[1];
-		GEDR2 = gedr[2]; GEDR3 = gedr[3];
-
-		loop = 0;
-		bit = find_first_bit(gedr, GEDR_BITS);
-		while (bit < GEDR_BITS) {
-			loop = 1;
-
-			n = PXA_GPIO_IRQ_BASE + bit;
-			desc_handle_irq(n, irq_desc + n);
-
-			bit = find_next_bit(gedr, GEDR_BITS, bit + 1);
-		}
-	} while (loop);
-}
-
-static void pxa_ack_muxed_gpio(unsigned int irq)
-{
-	int gpio = irq - IRQ_GPIO(2) + 2;
-	GEDR(gpio) = GPIO_bit(gpio);
-}
-
-static void pxa_mask_muxed_gpio(unsigned int irq)
-{
-	int gpio = irq - IRQ_GPIO(2) + 2;
-	__clear_bit(gpio, GPIO_IRQ_mask);
-	GRER(gpio) &= ~GPIO_bit(gpio);
-	GFER(gpio) &= ~GPIO_bit(gpio);
-}
-
-static void pxa_unmask_muxed_gpio(unsigned int irq)
-{
-	int gpio = irq - IRQ_GPIO(2) + 2;
-	int idx = gpio >> 5;
-	__set_bit(gpio, GPIO_IRQ_mask);
-	GRER(gpio) = GPIO_IRQ_rising_edge[idx] & GPIO_IRQ_mask[idx];
-	GFER(gpio) = GPIO_IRQ_falling_edge[idx] & GPIO_IRQ_mask[idx];
-}
-
-static struct irq_chip pxa_muxed_gpio_chip = {
-	.name		= "GPIO",
-	.ack		= pxa_ack_muxed_gpio,
-	.mask		= pxa_mask_muxed_gpio,
-	.unmask		= pxa_unmask_muxed_gpio,
-	.set_type	= pxa_gpio_irq_type,
-};
-
-void __init pxa_init_irq_gpio(int gpio_nr)
-{
-	int irq, i;
-
-	pxa_last_gpio = gpio_nr - 1;
-
-	/* clear all GPIO edge detects */
-	for (i = 0; i < gpio_nr; i += 32) {
-		GFER(i) = 0;
-		GRER(i) = 0;
-		GEDR(i) = GEDR(i);
-	}
-
-	/* GPIO 0 and 1 must have their mask bit always set */
-	GPIO_IRQ_mask[0] = 3;
-
-	for (irq = IRQ_GPIO0; irq <= IRQ_GPIO1; irq++) {
-		set_irq_chip(irq, &pxa_low_gpio_chip);
-		set_irq_handler(irq, handle_edge_irq);
-		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
-	}
-
-	for (irq = IRQ_GPIO(2); irq < IRQ_GPIO(gpio_nr); irq++) {
-		set_irq_chip(irq, &pxa_muxed_gpio_chip);
-		set_irq_handler(irq, handle_edge_irq);
-		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
-	}
-
-	/* Install handler for GPIO>=2 edge detect interrupts */
-	set_irq_chained_handler(IRQ_GPIO_2_x, pxa_gpio_demux_handler);
-
-	pxa_init_gpio(gpio_nr);
-}
-
-void __init pxa_init_gpio_set_wake(int (*set_wake)(unsigned int, unsigned int))
-{
-	pxa_low_gpio_chip.set_wake = set_wake;
-	pxa_muxed_gpio_chip.set_wake = set_wake;
-}
-
 void __init pxa_init_irq_set_wake(int (*set_wake)(unsigned int, unsigned int))
 {
 	pxa_internal_chip_low.set_wake = set_wake;

commit dfa1067996390dfd4b1ce449676500fab4980ce2
Author: eric miao <eric.miao@marvell.com>
Date:   Tue Mar 4 11:18:48 2008 +0800

    [ARM] pxa: cleanup the coding style of pxa_gpio_set_type()
    
    by
    
    1. wrapping long lines and making comments tidy
    
    2. using IRQ_TYPE_* instead of migration macros __IRQT_*
    
    3. introduce a pr_debug() for the commented printk(KERN_DEBUG ...)
       stuff
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index ce150bf00bdd..4fd4560dd3ad 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -121,39 +121,37 @@ static int pxa_gpio_irq_type(unsigned int irq, unsigned int type)
 	gpio = IRQ_TO_GPIO(irq);
 	idx = gpio >> 5;
 
-	if (type == IRQT_PROBE) {
-	    /* Don't mess with enabled GPIOs using preconfigured edges or
-	       GPIOs set to alternate function or to output during probe */
-		if ((GPIO_IRQ_rising_edge[idx] | GPIO_IRQ_falling_edge[idx] | GPDR(gpio)) &
-		    GPIO_bit(gpio))
+	if (type == IRQ_TYPE_PROBE) {
+		/* Don't mess with enabled GPIOs using preconfigured edges or
+		 * GPIOs set to alternate function or to output during probe
+		 */
+		if ((GPIO_IRQ_rising_edge[idx] |
+		     GPIO_IRQ_falling_edge[idx] |
+		     GPDR(gpio)) & GPIO_bit(gpio))
 			return 0;
 		if (GAFR(gpio) & (0x3 << (((gpio) & 0xf)*2)))
 			return 0;
-		type = __IRQT_RISEDGE | __IRQT_FALEDGE;
+		type = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;
 	}
 
-	/* printk(KERN_DEBUG "IRQ%d (GPIO%d): ", irq, gpio); */
-
 	pxa_gpio_mode(gpio | GPIO_IN);
 
-	if (type & __IRQT_RISEDGE) {
-		/* printk("rising "); */
-		__set_bit (gpio, GPIO_IRQ_rising_edge);
-	} else {
-		__clear_bit (gpio, GPIO_IRQ_rising_edge);
-	}
+	if (type & IRQ_TYPE_EDGE_RISING)
+		__set_bit(gpio, GPIO_IRQ_rising_edge);
+	else
+		__clear_bit(gpio, GPIO_IRQ_rising_edge);
 
-	if (type & __IRQT_FALEDGE) {
-		/* printk("falling "); */
-		__set_bit (gpio, GPIO_IRQ_falling_edge);
-	} else {
-		__clear_bit (gpio, GPIO_IRQ_falling_edge);
-	}
-
-	/* printk("edges\n"); */
+	if (type & IRQ_TYPE_EDGE_FALLING)
+		__set_bit(gpio, GPIO_IRQ_falling_edge);
+	else
+		__clear_bit(gpio, GPIO_IRQ_falling_edge);
 
 	GRER(gpio) = GPIO_IRQ_rising_edge[idx] & GPIO_IRQ_mask[idx];
 	GFER(gpio) = GPIO_IRQ_falling_edge[idx] & GPIO_IRQ_mask[idx];
+
+	pr_debug("%s: IRQ%d (GPIO%d) - edge%s%s\n", __func__, irq, gpio,
+		((type & IRQ_TYPE_EDGE_RISING)  ? " rising"  : ""),
+		((type & IRQ_TYPE_EDGE_FALLING) ? " falling" : ""));
 	return 0;
 }
 

commit a7bf4dbabac2a1ccd56527a56c82af720e7a00d1
Author: eric miao <eric.miao@marvell.com>
Date:   Tue Mar 4 11:12:14 2008 +0800

    [ARM] pxa: make GPIO IRQ code less dependent on the internal IRQs
    
    by:
    
    1. introduce dedicated pxa_{mask,unmask}_low_gpio()
    
    2. remove set_irq_chip(IRQ_GPIO_2_x, ...) which has already been
       initialized in pxa_init_irq()
    
    3. introduce dedicated pxa_init_gpio_set_wake()
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 381fde66aeeb..ce150bf00bdd 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -166,11 +166,21 @@ static void pxa_ack_low_gpio(unsigned int irq)
 	GEDR0 = (1 << (irq - IRQ_GPIO0));
 }
 
+static void pxa_mask_low_gpio(unsigned int irq)
+{
+	ICMR &= ~(1 << (irq - PXA_IRQ(0)));
+}
+
+static void pxa_unmask_low_gpio(unsigned int irq)
+{
+	ICMR |= 1 << (irq - PXA_IRQ(0));
+}
+
 static struct irq_chip pxa_low_gpio_chip = {
 	.name		= "GPIO-l",
 	.ack		= pxa_ack_low_gpio,
-	.mask		= pxa_mask_low_irq,
-	.unmask		= pxa_unmask_low_irq,
+	.mask		= pxa_mask_low_gpio,
+	.unmask		= pxa_unmask_low_gpio,
 	.set_type	= pxa_gpio_irq_type,
 };
 
@@ -267,20 +277,24 @@ void __init pxa_init_irq_gpio(int gpio_nr)
 	}
 
 	/* Install handler for GPIO>=2 edge detect interrupts */
-	set_irq_chip(IRQ_GPIO_2_x, &pxa_internal_chip_low);
 	set_irq_chained_handler(IRQ_GPIO_2_x, pxa_gpio_demux_handler);
 
 	pxa_init_gpio(gpio_nr);
 }
 
+void __init pxa_init_gpio_set_wake(int (*set_wake)(unsigned int, unsigned int))
+{
+	pxa_low_gpio_chip.set_wake = set_wake;
+	pxa_muxed_gpio_chip.set_wake = set_wake;
+}
+
 void __init pxa_init_irq_set_wake(int (*set_wake)(unsigned int, unsigned int))
 {
 	pxa_internal_chip_low.set_wake = set_wake;
 #ifdef CONFIG_PXA27x
 	pxa_internal_chip_high.set_wake = set_wake;
 #endif
-	pxa_low_gpio_chip.set_wake = set_wake;
-	pxa_muxed_gpio_chip.set_wake = set_wake;
+	pxa_init_gpio_set_wake(set_wake);
 }
 
 #ifdef CONFIG_PM

commit 7a26d3a33fd9adcbfd4fa2ca2d7e8a8272817935
Author: eric miao <eric.miao@marvell.com>
Date:   Tue Mar 4 10:57:18 2008 +0800

    [ARM] pxa: generalize the muxed gpio IRQ handling code with loop and ffs()
    
    1. As David Brownell suggests, using ffs() is going to make the loop
       a bit faster (by avoiding unnecessary shift and iteration)
    
    2. Russell suggested find_{first,next}_bit() being used with the
       gedr[] array
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 36c6a68beca2..381fde66aeeb 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -178,73 +178,31 @@ static struct irq_chip pxa_low_gpio_chip = {
  * Demux handler for GPIO>=2 edge detect interrupts
  */
 
+#define GEDR_BITS	(sizeof(gedr) * BITS_PER_BYTE)
+
 static void pxa_gpio_demux_handler(unsigned int irq, struct irq_desc *desc)
 {
-	unsigned int mask;
-	int loop;
+	int loop, bit, n;
+	unsigned long gedr[4];
 
 	do {
-		loop = 0;
+		gedr[0] = GEDR0 & GPIO_IRQ_mask[0] & ~3;
+		gedr[1] = GEDR1 & GPIO_IRQ_mask[1];
+		gedr[2] = GEDR2 & GPIO_IRQ_mask[2];
+		gedr[3] = GEDR3 & GPIO_IRQ_mask[3];
 
-		mask = GEDR0 & GPIO_IRQ_mask[0] & ~3;
-		if (mask) {
-			GEDR0 = mask;
-			irq = IRQ_GPIO(2);
-			desc = irq_desc + irq;
-			mask >>= 2;
-			do {
-				if (mask & 1)
-					desc_handle_irq(irq, desc);
-				irq++;
-				desc++;
-				mask >>= 1;
-			} while (mask);
-			loop = 1;
-		}
+		GEDR0 = gedr[0]; GEDR1 = gedr[1];
+		GEDR2 = gedr[2]; GEDR3 = gedr[3];
 
-		mask = GEDR1 & GPIO_IRQ_mask[1];
-		if (mask) {
-			GEDR1 = mask;
-			irq = IRQ_GPIO(32);
-			desc = irq_desc + irq;
-			do {
-				if (mask & 1)
-					desc_handle_irq(irq, desc);
-				irq++;
-				desc++;
-				mask >>= 1;
-			} while (mask);
+		loop = 0;
+		bit = find_first_bit(gedr, GEDR_BITS);
+		while (bit < GEDR_BITS) {
 			loop = 1;
-		}
 
-		mask = GEDR2 & GPIO_IRQ_mask[2];
-		if (mask) {
-			GEDR2 = mask;
-			irq = IRQ_GPIO(64);
-			desc = irq_desc + irq;
-			do {
-				if (mask & 1)
-					desc_handle_irq(irq, desc);
-				irq++;
-				desc++;
-				mask >>= 1;
-			} while (mask);
-			loop = 1;
-		}
+			n = PXA_GPIO_IRQ_BASE + bit;
+			desc_handle_irq(n, irq_desc + n);
 
-		mask = GEDR3 & GPIO_IRQ_mask[3];
-		if (mask) {
-			GEDR3 = mask;
-			irq = IRQ_GPIO(96);
-			desc = irq_desc + irq;
-			do {
-				if (mask & 1)
-					desc_handle_irq(irq, desc);
-				irq++;
-				desc++;
-				mask >>= 1;
-			} while (mask);
-			loop = 1;
+			bit = find_next_bit(gedr, GEDR_BITS, bit + 1);
 		}
 	} while (loop);
 }

commit 1c44f5f16fee880b294f8068354bfb9dddf1349b
Author: Philipp Zabel <philipp.zabel@gmail.com>
Date:   Mon Feb 4 22:28:22 2008 -0800

    gpiolib support for the PXA architecture
    
    This adds gpiolib support for the PXA architecture:
      - move all GPIO API functions from generic.c into gpio.c
      - convert the gpio_get/set_value macros into inline functions
    
    This makes it easier to hook up GPIOs provided by external chips like
    ASICs and CPLDs.
    
    Signed-off-by: Philipp Zabel <philipp.zabel@gmail.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Jean Delvare <khali@linux-fr.org>
    Cc: Eric Miao <eric.miao@marvell.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Haavard Skinnemoen <hskinnemoen@atmel.com>
    Cc: Ben Gardner <bgardner@wabtec.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    [ Minor ARM fixup from David Brownell folded into this ]
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 5a1d5eef10a4..36c6a68beca2 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -311,6 +311,8 @@ void __init pxa_init_irq_gpio(int gpio_nr)
 	/* Install handler for GPIO>=2 edge detect interrupts */
 	set_irq_chip(IRQ_GPIO_2_x, &pxa_internal_chip_low);
 	set_irq_chained_handler(IRQ_GPIO_2_x, pxa_gpio_demux_handler);
+
+	pxa_init_gpio(gpio_nr);
 }
 
 void __init pxa_init_irq_set_wake(int (*set_wake)(unsigned int, unsigned int))

commit c016550490687c6bdbcdf06c7b4d874b6c7c6e4e
Author: eric miao <eric.miao@marvell.com>
Date:   Mon Jan 28 23:00:02 2008 +0000

    [ARM] pxa: introduce sysdev for IRQ register saving/restoring
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 07acb45b16ea..5a1d5eef10a4 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -15,6 +15,7 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/interrupt.h>
+#include <linux/sysdev.h>
 
 #include <asm/hardware.h>
 #include <asm/irq.h>
@@ -321,3 +322,64 @@ void __init pxa_init_irq_set_wake(int (*set_wake)(unsigned int, unsigned int))
 	pxa_low_gpio_chip.set_wake = set_wake;
 	pxa_muxed_gpio_chip.set_wake = set_wake;
 }
+
+#ifdef CONFIG_PM
+static unsigned long saved_icmr[2];
+
+static int pxa_irq_suspend(struct sys_device *dev, pm_message_t state)
+{
+	switch (dev->id) {
+	case 0:
+		saved_icmr[0] = ICMR;
+		ICMR = 0;
+		break;
+#if defined(CONFIG_PXA27x) || defined(CONFIG_PXA3xx)
+	case 1:
+		saved_icmr[1] = ICMR2;
+		ICMR2 = 0;
+		break;
+#endif
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int pxa_irq_resume(struct sys_device *dev)
+{
+	switch (dev->id) {
+	case 0:
+		ICMR = saved_icmr[0];
+		ICLR = 0;
+		ICCR = 1;
+		break;
+#if defined(CONFIG_PXA27x) || defined(CONFIG_PXA3xx)
+	case 1:
+		ICMR2 = saved_icmr[1];
+		ICLR2 = 0;
+		break;
+#endif
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#else
+#define pxa_irq_suspend		NULL
+#define pxa_irq_resume		NULL
+#endif
+
+struct sysdev_class pxa_irq_sysclass = {
+	.name		= "irq",
+	.suspend	= pxa_irq_suspend,
+	.resume		= pxa_irq_resume,
+};
+
+static int __init pxa_irq_init(void)
+{
+	return sysdev_class_register(&pxa_irq_sysclass);
+}
+
+core_initcall(pxa_irq_init);

commit 2c8086a5d073e8e72122a5b84febde236a39845b
Author: eric miao <eric.y.miao@gmail.com>
Date:   Tue Sep 11 19:13:17 2007 -0700

    [ARM] pxa: PXA3xx base support
    
    Signed-off-by: eric miao <eric.y.miao@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 294cc6758d55..07acb45b16ea 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -65,7 +65,7 @@ void __init pxa_init_irq_low(void)
 	}
 }
 
-#ifdef CONFIG_PXA27x
+#if defined(CONFIG_PXA27x) || defined(CONFIG_PXA3xx)
 
 /*
  * This is for the second set of internal IRQs as found on the PXA27x.

commit c95530c7798b760901c5d6212e528b03e323b8ac
Author: eric miao <eric.y.miao@gmail.com>
Date:   Wed Aug 29 10:22:17 2007 +0100

    [ARM] 4560/1: pxa: move processor specific set_wake logic out of irq.c
    
    a function pxa_init_irq_set_wake() was introduced, so that
    processor specific code could install their own version
    
    code setting PFER and PRER registers within pxa_gpio_irq_type
    are removed, and the edge configuration is postponed to the
    (*set_wake) and copies the GRER and GFER register, which will
    always be set up correctly by pxa_gpio_irq_type()
    
    Signed-off-by: eric miao <eric.y.miao@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 3d95442d4168..294cc6758d55 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -38,33 +38,11 @@ static void pxa_unmask_low_irq(unsigned int irq)
 	ICMR |= (1 << irq);
 }
 
-static int pxa_set_wake(unsigned int irq, unsigned int on)
-{
-	u32	mask;
-
-	switch (irq) {
-	case IRQ_RTCAlrm:
-		mask = PWER_RTC;
-		break;
-#ifdef CONFIG_PXA27x
-	/* REVISIT can handle USBH1, USBH2, USB, MSL, USIM, ... */
-#endif
-	default:
-		return -EINVAL;
-	}
-	if (on)
-		PWER |= mask;
-	else
-		PWER &= ~mask;
-	return 0;
-}
-
 static struct irq_chip pxa_internal_chip_low = {
 	.name		= "SC",
 	.ack		= pxa_mask_low_irq,
 	.mask		= pxa_mask_low_irq,
 	.unmask		= pxa_unmask_low_irq,
-	.set_wake	= pxa_set_wake,
 };
 
 void __init pxa_init_irq_low(void)
@@ -125,26 +103,6 @@ void __init pxa_init_irq_high(void)
 }
 #endif
 
-/* Note that if an input/irq line ever gets changed to an output during
- * suspend, the relevant PWER, PRER, and PFER bits should be cleared.
- */
-#ifdef CONFIG_PXA27x
-
-/* PXA27x:  Various gpios can issue wakeup events.  This logic only
- * handles the simple cases, not the WEMUX2 and WEMUX3 options
- */
-#define PXA27x_GPIO_NOWAKE_MASK \
-	((1 << 8) | (1 << 7) | (1 << 6) | (1 << 5) | (1 << 2))
-#define	WAKEMASK(gpio) \
-	(((gpio) <= 15) \
-		? ((1 << (gpio)) & ~PXA27x_GPIO_NOWAKE_MASK) \
-		: ((gpio == 35) ? (1 << 24) : 0))
-#else
-
-/* pxa 210, 250, 255, 26x:  gpios 0..15 can issue wakeups */
-#define	WAKEMASK(gpio) (((gpio) <= 15) ? (1 << (gpio)) : 0)
-#endif
-
 /*
  * PXA GPIO edge detection for IRQs:
  * IRQs are generated on Falling-Edge, Rising-Edge, or both.
@@ -158,11 +116,9 @@ static long GPIO_IRQ_mask[4];
 static int pxa_gpio_irq_type(unsigned int irq, unsigned int type)
 {
 	int gpio, idx;
-	u32 mask;
 
 	gpio = IRQ_TO_GPIO(irq);
 	idx = gpio >> 5;
-	mask = WAKEMASK(gpio);
 
 	if (type == IRQT_PROBE) {
 	    /* Don't mess with enabled GPIOs using preconfigured edges or
@@ -182,19 +138,15 @@ static int pxa_gpio_irq_type(unsigned int irq, unsigned int type)
 	if (type & __IRQT_RISEDGE) {
 		/* printk("rising "); */
 		__set_bit (gpio, GPIO_IRQ_rising_edge);
-		PRER |= mask;
 	} else {
 		__clear_bit (gpio, GPIO_IRQ_rising_edge);
-		PRER &= ~mask;
 	}
 
 	if (type & __IRQT_FALEDGE) {
 		/* printk("falling "); */
 		__set_bit (gpio, GPIO_IRQ_falling_edge);
-		PFER |= mask;
 	} else {
 		__clear_bit (gpio, GPIO_IRQ_falling_edge);
-		PFER &= ~mask;
 	}
 
 	/* printk("edges\n"); */
@@ -213,29 +165,12 @@ static void pxa_ack_low_gpio(unsigned int irq)
 	GEDR0 = (1 << (irq - IRQ_GPIO0));
 }
 
-static int pxa_set_gpio_wake(unsigned int irq, unsigned int on)
-{
-	int	gpio = IRQ_TO_GPIO(irq);
-	u32	mask = WAKEMASK(gpio);
-
-	if (!mask)
-		return -EINVAL;
-
-	if (on)
-		PWER |= mask;
-	else
-		PWER &= ~mask;
-	return 0;
-}
-
-
 static struct irq_chip pxa_low_gpio_chip = {
 	.name		= "GPIO-l",
 	.ack		= pxa_ack_low_gpio,
 	.mask		= pxa_mask_low_irq,
 	.unmask		= pxa_unmask_low_irq,
 	.set_type	= pxa_gpio_irq_type,
-	.set_wake	= pxa_set_gpio_wake,
 };
 
 /*
@@ -342,7 +277,6 @@ static struct irq_chip pxa_muxed_gpio_chip = {
 	.mask		= pxa_mask_muxed_gpio,
 	.unmask		= pxa_unmask_muxed_gpio,
 	.set_type	= pxa_gpio_irq_type,
-	.set_wake	= pxa_set_gpio_wake,
 };
 
 void __init pxa_init_irq_gpio(int gpio_nr)
@@ -377,3 +311,13 @@ void __init pxa_init_irq_gpio(int gpio_nr)
 	set_irq_chip(IRQ_GPIO_2_x, &pxa_internal_chip_low);
 	set_irq_chained_handler(IRQ_GPIO_2_x, pxa_gpio_demux_handler);
 }
+
+void __init pxa_init_irq_set_wake(int (*set_wake)(unsigned int, unsigned int))
+{
+	pxa_internal_chip_low.set_wake = set_wake;
+#ifdef CONFIG_PXA27x
+	pxa_internal_chip_high.set_wake = set_wake;
+#endif
+	pxa_low_gpio_chip.set_wake = set_wake;
+	pxa_muxed_gpio_chip.set_wake = set_wake;
+}

commit 30f0b40844e5add7ad879e2f5939ff498f72f3e6
Author: eric miao <eric.y.miao@gmail.com>
Date:   Wed Aug 29 10:18:47 2007 +0100

    [ARM] 4559/1: pxa: make PXA_LAST_GPIO a run-time variable
    
    This definition produces processor specific code in generic function
    pxa_gpio_mode(), thus creating inconsistencies for support of pxa25x
    and pxa27x in a single zImage.
    
    As David Brownell suggests, make it a run-time variable and initialize
    at run-time according to the number of GPIOs on the processor. For now
    the initialization happens in pxa_init_irq_gpio(),  since there is
    already a parameter for that, besides, this is and MUST be earlier
    than any subsequent calls to pxa_gpio_mode().
    
    Signed-off-by: eric miao <eric.y.miao@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index ae2ae08032d7..3d95442d4168 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -349,6 +349,8 @@ void __init pxa_init_irq_gpio(int gpio_nr)
 {
 	int irq, i;
 
+	pxa_last_gpio = gpio_nr - 1;
+
 	/* clear all GPIO edge detects */
 	for (i = 0; i < gpio_nr; i += 32) {
 		GFER(i) = 0;

commit fd51bcc5dc4073b18308f25846aa3b421fa3c42e
Author: Samuel <sameo@openedhand.com>
Date:   Tue Aug 28 19:56:34 2007 +0100

    [ARM] 4557/1: Fix PXA irq gpio initialization
    
    As pointed out by Jrgen, we are overflowing the number of GPIOs
    in pxa_init_irq_gpio(). I'm seeing the same problem on my HTC
    Universal PXA270 based PDA.
    According to Eric, the function argument is the number of GPIOs,
    so we should keep the semantics and reduce the number of
    iteration by 1.
    
    Signed-off-by: Samuel Ortiz <sameo@openedhand.com>
    Acked-by: Jrgen Schindele <linux@schindele.name>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 4b867b0789d5..ae2ae08032d7 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -365,7 +365,7 @@ void __init pxa_init_irq_gpio(int gpio_nr)
 		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
 	}
 
-	for (irq = IRQ_GPIO(2); irq <= IRQ_GPIO(gpio_nr); irq++) {
+	for (irq = IRQ_GPIO(2); irq < IRQ_GPIO(gpio_nr); irq++) {
 		set_irq_chip(irq, &pxa_muxed_gpio_chip);
 		set_irq_handler(irq, handle_edge_irq);
 		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);

commit cd49104d99b56383a3b1fdce2f31018197093c31
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Fri Jun 22 04:14:09 2007 +0100

    [ARM] 4450/1: pxa: add pxa25x_init_irq() and pxa27x_init_irq()
    
    /* should be ok this time, I aligned this patch to your arm:pxa2.mbox */
    
    1. move pxa25x specific IRQ initialization code to pxa25x_init_irq()
    and pxa27x code to pxa27x_init_irq(), remove pxa_init_irq()
    
    2. replace all pxa_init_irq() with their PXA25x or PXA27x specific
    functions
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 09d2fe19c85f..4b867b0789d5 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -375,12 +375,3 @@ void __init pxa_init_irq_gpio(int gpio_nr)
 	set_irq_chip(IRQ_GPIO_2_x, &pxa_internal_chip_low);
 	set_irq_chained_handler(IRQ_GPIO_2_x, pxa_gpio_demux_handler);
 }
-
-void __init pxa_init_irq(void)
-{
-	pxa_init_irq_low();
-#ifdef CONFIG_PXA27x
-	pxa_init_irq_high();
-#endif
-	pxa_init_irq_gpio(PXA_LAST_GPIO + 1);
-}

commit 4a3dcd35c82a2a25b2832502290e1a3f1571e9ef
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Wed Jun 6 06:45:18 2007 +0100

    [ARM] 4438/1: PXA: remove #ifdef .. #endif from pxa_gpio_demux_handler()
    
    1. use GPIO_IRQ_mask[] to select those bits of interest, actually
       only those "unmasked" GPIO IRQs with their corresponding bits
       in GPIO_IRQ_mask[] set to "1" should be checked
    
    2. remove #ifdef PXA_LAST_GPIO > 96 .. #endif, GPIO_IRQ_mask[]
       is used to mask out the irrelevant bits, so that even though
       the GEDR3 on PXA25x is reserved, it will be masked, and the
       following code will never run. Another point is that GPIO85-
       GPIO95 bits within GEDR2 will also be masked out on PXA25x
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 256f8d2b3d9b..09d2fe19c85f 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -250,7 +250,7 @@ static void pxa_gpio_demux_handler(unsigned int irq, struct irq_desc *desc)
 	do {
 		loop = 0;
 
-		mask = GEDR0 & ~3;
+		mask = GEDR0 & GPIO_IRQ_mask[0] & ~3;
 		if (mask) {
 			GEDR0 = mask;
 			irq = IRQ_GPIO(2);
@@ -266,7 +266,7 @@ static void pxa_gpio_demux_handler(unsigned int irq, struct irq_desc *desc)
 			loop = 1;
 		}
 
-		mask = GEDR1;
+		mask = GEDR1 & GPIO_IRQ_mask[1];
 		if (mask) {
 			GEDR1 = mask;
 			irq = IRQ_GPIO(32);
@@ -281,7 +281,7 @@ static void pxa_gpio_demux_handler(unsigned int irq, struct irq_desc *desc)
 			loop = 1;
 		}
 
-		mask = GEDR2;
+		mask = GEDR2 & GPIO_IRQ_mask[2];
 		if (mask) {
 			GEDR2 = mask;
 			irq = IRQ_GPIO(64);
@@ -296,8 +296,7 @@ static void pxa_gpio_demux_handler(unsigned int irq, struct irq_desc *desc)
 			loop = 1;
 		}
 
-#if PXA_LAST_GPIO >= 96
-		mask = GEDR3;
+		mask = GEDR3 & GPIO_IRQ_mask[3];
 		if (mask) {
 			GEDR3 = mask;
 			irq = IRQ_GPIO(96);
@@ -311,7 +310,6 @@ static void pxa_gpio_demux_handler(unsigned int irq, struct irq_desc *desc)
 			} while (mask);
 			loop = 1;
 		}
-#endif
 	} while (loop);
 }
 

commit 348f2e3b2956e30f07d2507d7234c3f12a8a612d
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Wed Jun 6 06:37:15 2007 +0100

    [ARM] 4437/1: PXA: move the GPIO IRQ initialization code to pxa_init_irq_gpio()
    
    move the GPIO IRQ initialization code to pxa_init_irq_gpio()
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 42b2da2f213e..256f8d2b3d9b 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -347,43 +347,27 @@ static struct irq_chip pxa_muxed_gpio_chip = {
 	.set_wake	= pxa_set_gpio_wake,
 };
 
-void __init pxa_init_irq(void)
+void __init pxa_init_irq_gpio(int gpio_nr)
 {
-	int irq;
+	int irq, i;
 
 	/* clear all GPIO edge detects */
-	GFER0 = 0;
-	GFER1 = 0;
-	GFER2 = 0;
-	GRER0 = 0;
-	GRER1 = 0;
-	GRER2 = 0;
-	GEDR0 = GEDR0;
-	GEDR1 = GEDR1;
-	GEDR2 = GEDR2;
-
-#ifdef CONFIG_PXA27x
-	/* And similarly for the extra regs on the PXA27x */
-	GFER3 = 0;
-	GRER3 = 0;
-	GEDR3 = GEDR3;
-#endif
+	for (i = 0; i < gpio_nr; i += 32) {
+		GFER(i) = 0;
+		GRER(i) = 0;
+		GEDR(i) = GEDR(i);
+	}
 
 	/* GPIO 0 and 1 must have their mask bit always set */
 	GPIO_IRQ_mask[0] = 3;
 
-	pxa_init_irq_low();
-#ifdef CONFIG_PXA27x
-	pxa_init_irq_high();
-#endif
-
 	for (irq = IRQ_GPIO0; irq <= IRQ_GPIO1; irq++) {
 		set_irq_chip(irq, &pxa_low_gpio_chip);
 		set_irq_handler(irq, handle_edge_irq);
 		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
 	}
 
-	for (irq = IRQ_GPIO(2); irq <= IRQ_GPIO(PXA_LAST_GPIO); irq++) {
+	for (irq = IRQ_GPIO(2); irq <= IRQ_GPIO(gpio_nr); irq++) {
 		set_irq_chip(irq, &pxa_muxed_gpio_chip);
 		set_irq_handler(irq, handle_edge_irq);
 		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
@@ -393,3 +377,12 @@ void __init pxa_init_irq(void)
 	set_irq_chip(IRQ_GPIO_2_x, &pxa_internal_chip_low);
 	set_irq_chained_handler(IRQ_GPIO_2_x, pxa_gpio_demux_handler);
 }
+
+void __init pxa_init_irq(void)
+{
+	pxa_init_irq_low();
+#ifdef CONFIG_PXA27x
+	pxa_init_irq_high();
+#endif
+	pxa_init_irq_gpio(PXA_LAST_GPIO + 1);
+}

commit 53665a50fdac6fe11e0dde4e2b95700ed5184dc4
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Wed Jun 6 06:36:04 2007 +0100

    [ARM] 4436/1: PXA: move low IRQ initialization code to pxa_init_irq_low()
    
    1. move low IRQ initialization code to pxa_init_irq_low()
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 844d3de3ef44..42b2da2f213e 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -67,6 +67,26 @@ static struct irq_chip pxa_internal_chip_low = {
 	.set_wake	= pxa_set_wake,
 };
 
+void __init pxa_init_irq_low(void)
+{
+	int irq;
+
+	/* disable all IRQs */
+	ICMR = 0;
+
+	/* all IRQs are IRQ, not FIQ */
+	ICLR = 0;
+
+	/* only unmasked interrupts kick us out of idle */
+	ICCR = 1;
+
+	for (irq = PXA_IRQ(0); irq <= PXA_IRQ(31); irq++) {
+		set_irq_chip(irq, &pxa_internal_chip_low);
+		set_irq_handler(irq, handle_level_irq);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+}
+
 #ifdef CONFIG_PXA27x
 
 /*
@@ -331,12 +351,6 @@ void __init pxa_init_irq(void)
 {
 	int irq;
 
-	/* disable all IRQs */
-	ICMR = 0;
-
-	/* all IRQs are IRQ, not FIQ */
-	ICLR = 0;
-
 	/* clear all GPIO edge detects */
 	GFER0 = 0;
 	GFER1 = 0;
@@ -355,18 +369,10 @@ void __init pxa_init_irq(void)
 	GEDR3 = GEDR3;
 #endif
 
-	/* only unmasked interrupts kick us out of idle */
-	ICCR = 1;
-
 	/* GPIO 0 and 1 must have their mask bit always set */
 	GPIO_IRQ_mask[0] = 3;
 
-	for (irq = PXA_IRQ(0); irq <= PXA_IRQ(31); irq++) {
-		set_irq_chip(irq, &pxa_internal_chip_low);
-		set_irq_handler(irq, handle_level_irq);
-		set_irq_flags(irq, IRQF_VALID);
-	}
-
+	pxa_init_irq_low();
 #ifdef CONFIG_PXA27x
 	pxa_init_irq_high();
 #endif

commit c08b7b3ef6bf489ddabadc03e050f3db2ea44b5d
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Wed Jun 6 06:32:38 2007 +0100

    [ARM] 4435/1: PXA: remove PXA_INTERNAL_IRQS
    
    1. define PXA_GPIO_IRQ_BASE to be right after the internal IRQs,
       and define PXA_GPIO_IRQ_NUM to be 128 for all PXA2xx variants
    
    2. make the code specific to the high IRQ numbers (32..64) to be
       PXA27x specific
    
    3. add a function pxa_init_irq_high() to initialize the internal
       high IRQ chip, the invoke of this function could be moved to
       PXA27x specific initialization code
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 45ce711f0472..844d3de3ef44 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -67,7 +67,7 @@ static struct irq_chip pxa_internal_chip_low = {
 	.set_wake	= pxa_set_wake,
 };
 
-#if PXA_INTERNAL_IRQS > 32
+#ifdef CONFIG_PXA27x
 
 /*
  * This is for the second set of internal IRQs as found on the PXA27x.
@@ -90,6 +90,19 @@ static struct irq_chip pxa_internal_chip_high = {
 	.unmask		= pxa_unmask_high_irq,
 };
 
+void __init pxa_init_irq_high(void)
+{
+	int irq;
+
+	ICMR2 = 0;
+	ICLR2 = 0;
+
+	for (irq = PXA_IRQ(32); irq < PXA_IRQ(64); irq++) {
+		set_irq_chip(irq, &pxa_internal_chip_high);
+		set_irq_handler(irq, handle_level_irq);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+}
 #endif
 
 /* Note that if an input/irq line ever gets changed to an output during
@@ -314,7 +327,6 @@ static struct irq_chip pxa_muxed_gpio_chip = {
 	.set_wake	= pxa_set_gpio_wake,
 };
 
-
 void __init pxa_init_irq(void)
 {
 	int irq;
@@ -338,8 +350,6 @@ void __init pxa_init_irq(void)
 
 #ifdef CONFIG_PXA27x
 	/* And similarly for the extra regs on the PXA27x */
-	ICMR2 = 0;
-	ICLR2 = 0;
 	GFER3 = 0;
 	GRER3 = 0;
 	GEDR3 = GEDR3;
@@ -357,12 +367,8 @@ void __init pxa_init_irq(void)
 		set_irq_flags(irq, IRQF_VALID);
 	}
 
-#if PXA_INTERNAL_IRQS > 32
-	for (irq = PXA_IRQ(32); irq < PXA_IRQ(PXA_INTERNAL_IRQS); irq++) {
-		set_irq_chip(irq, &pxa_internal_chip_high);
-		set_irq_handler(irq, handle_level_irq);
-		set_irq_flags(irq, IRQF_VALID);
-	}
+#ifdef CONFIG_PXA27x
+	pxa_init_irq_high();
 #endif
 
 	for (irq = IRQ_GPIO0; irq <= IRQ_GPIO1; irq++) {

commit 486c955118dbbb0f13dc4d40cc5dac2b23f82676
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Wed Jun 6 06:22:20 2007 +0100

    [ARM] 4434/1: PXA: remove PXA_IRQ_SKIP
    
    1. PXA_IRQ_SKIP is defined to be 7 on PXA25x so that the first IRQ
       starts from zero. This makes IRQ numbering inconsistent between
       PXA25x and PXA27x. Remove this macro so that the same IRQ_XXXXX
       definition has the same value on both PXA25x and PXA27x.
    
    2. make IRQ_SSP3..IRQ_PWRI2C valid only if PXA27x is defined, this
       avoids unintentional use of these macros on PXA25x
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 4619d5fe606c..45ce711f0472 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -30,12 +30,12 @@
 
 static void pxa_mask_low_irq(unsigned int irq)
 {
-	ICMR &= ~(1 << (irq + PXA_IRQ_SKIP));
+	ICMR &= ~(1 << irq);
 }
 
 static void pxa_unmask_low_irq(unsigned int irq)
 {
-	ICMR |= (1 << (irq + PXA_IRQ_SKIP));
+	ICMR |= (1 << irq);
 }
 
 static int pxa_set_wake(unsigned int irq, unsigned int on)
@@ -75,12 +75,12 @@ static struct irq_chip pxa_internal_chip_low = {
 
 static void pxa_mask_high_irq(unsigned int irq)
 {
-	ICMR2 &= ~(1 << (irq - 32 + PXA_IRQ_SKIP));
+	ICMR2 &= ~(1 << (irq - 32));
 }
 
 static void pxa_unmask_high_irq(unsigned int irq)
 {
-	ICMR2 |= (1 << (irq - 32 + PXA_IRQ_SKIP));
+	ICMR2 |= (1 << (irq - 32));
 }
 
 static struct irq_chip pxa_internal_chip_high = {
@@ -351,7 +351,7 @@ void __init pxa_init_irq(void)
 	/* GPIO 0 and 1 must have their mask bit always set */
 	GPIO_IRQ_mask[0] = 3;
 
-	for (irq = PXA_IRQ(PXA_IRQ_SKIP); irq <= PXA_IRQ(31); irq++) {
+	for (irq = PXA_IRQ(0); irq <= PXA_IRQ(31); irq++) {
 		set_irq_chip(irq, &pxa_internal_chip_low);
 		set_irq_handler(irq, handle_level_irq);
 		set_irq_flags(irq, IRQF_VALID);

commit 4fe4a2bf9a687fc87ea796c234da8c59df763aab
Author: Philipp Zabel <philipp.zabel@gmail.com>
Date:   Mon Feb 26 01:44:57 2007 +0100

    [ARM] 4236/2: basic {enable,disable}_irq_wake() support for PXA
    
    pxa_set_gpio_wake handles GPIOs > 1, so IRQ_TO_GPIO has to be used
    instead of just substracting IRQ_GPIO0 from the irq number.

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 9f7499b6d435..4619d5fe606c 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -38,11 +38,33 @@ static void pxa_unmask_low_irq(unsigned int irq)
 	ICMR |= (1 << (irq + PXA_IRQ_SKIP));
 }
 
+static int pxa_set_wake(unsigned int irq, unsigned int on)
+{
+	u32	mask;
+
+	switch (irq) {
+	case IRQ_RTCAlrm:
+		mask = PWER_RTC;
+		break;
+#ifdef CONFIG_PXA27x
+	/* REVISIT can handle USBH1, USBH2, USB, MSL, USIM, ... */
+#endif
+	default:
+		return -EINVAL;
+	}
+	if (on)
+		PWER |= mask;
+	else
+		PWER &= ~mask;
+	return 0;
+}
+
 static struct irq_chip pxa_internal_chip_low = {
 	.name		= "SC",
 	.ack		= pxa_mask_low_irq,
 	.mask		= pxa_mask_low_irq,
 	.unmask		= pxa_unmask_low_irq,
+	.set_wake	= pxa_set_wake,
 };
 
 #if PXA_INTERNAL_IRQS > 32
@@ -70,6 +92,26 @@ static struct irq_chip pxa_internal_chip_high = {
 
 #endif
 
+/* Note that if an input/irq line ever gets changed to an output during
+ * suspend, the relevant PWER, PRER, and PFER bits should be cleared.
+ */
+#ifdef CONFIG_PXA27x
+
+/* PXA27x:  Various gpios can issue wakeup events.  This logic only
+ * handles the simple cases, not the WEMUX2 and WEMUX3 options
+ */
+#define PXA27x_GPIO_NOWAKE_MASK \
+	((1 << 8) | (1 << 7) | (1 << 6) | (1 << 5) | (1 << 2))
+#define	WAKEMASK(gpio) \
+	(((gpio) <= 15) \
+		? ((1 << (gpio)) & ~PXA27x_GPIO_NOWAKE_MASK) \
+		: ((gpio == 35) ? (1 << 24) : 0))
+#else
+
+/* pxa 210, 250, 255, 26x:  gpios 0..15 can issue wakeups */
+#define	WAKEMASK(gpio) (((gpio) <= 15) ? (1 << (gpio)) : 0)
+#endif
+
 /*
  * PXA GPIO edge detection for IRQs:
  * IRQs are generated on Falling-Edge, Rising-Edge, or both.
@@ -83,9 +125,11 @@ static long GPIO_IRQ_mask[4];
 static int pxa_gpio_irq_type(unsigned int irq, unsigned int type)
 {
 	int gpio, idx;
+	u32 mask;
 
 	gpio = IRQ_TO_GPIO(irq);
 	idx = gpio >> 5;
+	mask = WAKEMASK(gpio);
 
 	if (type == IRQT_PROBE) {
 	    /* Don't mess with enabled GPIOs using preconfigured edges or
@@ -105,14 +149,20 @@ static int pxa_gpio_irq_type(unsigned int irq, unsigned int type)
 	if (type & __IRQT_RISEDGE) {
 		/* printk("rising "); */
 		__set_bit (gpio, GPIO_IRQ_rising_edge);
-	} else
+		PRER |= mask;
+	} else {
 		__clear_bit (gpio, GPIO_IRQ_rising_edge);
+		PRER &= ~mask;
+	}
 
 	if (type & __IRQT_FALEDGE) {
 		/* printk("falling "); */
 		__set_bit (gpio, GPIO_IRQ_falling_edge);
-	} else
+		PFER |= mask;
+	} else {
 		__clear_bit (gpio, GPIO_IRQ_falling_edge);
+		PFER &= ~mask;
+	}
 
 	/* printk("edges\n"); */
 
@@ -130,12 +180,29 @@ static void pxa_ack_low_gpio(unsigned int irq)
 	GEDR0 = (1 << (irq - IRQ_GPIO0));
 }
 
+static int pxa_set_gpio_wake(unsigned int irq, unsigned int on)
+{
+	int	gpio = IRQ_TO_GPIO(irq);
+	u32	mask = WAKEMASK(gpio);
+
+	if (!mask)
+		return -EINVAL;
+
+	if (on)
+		PWER |= mask;
+	else
+		PWER &= ~mask;
+	return 0;
+}
+
+
 static struct irq_chip pxa_low_gpio_chip = {
 	.name		= "GPIO-l",
 	.ack		= pxa_ack_low_gpio,
 	.mask		= pxa_mask_low_irq,
 	.unmask		= pxa_unmask_low_irq,
 	.set_type	= pxa_gpio_irq_type,
+	.set_wake	= pxa_set_gpio_wake,
 };
 
 /*
@@ -244,6 +311,7 @@ static struct irq_chip pxa_muxed_gpio_chip = {
 	.mask		= pxa_mask_muxed_gpio,
 	.unmask		= pxa_unmask_muxed_gpio,
 	.set_type	= pxa_gpio_irq_type,
+	.set_wake	= pxa_set_gpio_wake,
 };
 
 

commit 0f0a00beb80624a446ba7c0152cd171008eeab2e
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Mar 3 19:45:25 2007 +0000

    [ARM] Remove needless linux/ptrace.h includes
    
    Lots of places in arch/arm were needlessly including linux/ptrace.h,
    resumably because we used to pass a struct pt_regs to interrupt
    handlers.  Now that we don't, all these ptrace.h includes are
    redundant.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index f815678a9d63..9f7499b6d435 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -15,7 +15,6 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/interrupt.h>
-#include <linux/ptrace.h>
 
 #include <asm/hardware.h>
 #include <asm/irq.h>

commit 10dd5ce28d78e2440e8fa1135d17e33399d75340
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Nov 23 11:41:32 2006 +0000

    [ARM] Remove compatibility layer for ARM irqs
    
    set_irq_chipdata -> set_irq_chip_data
    get_irq_chipdata -> get_irq_chip_data
    do_level_IRQ -> handle_level_irq
    do_edge_IRQ -> handle_edge_irq
    do_simple_IRQ -> handle_simple_irq
    irqdesc -> irq_desc
    irqchip -> irq_chip
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index ab1a16025d51..f815678a9d63 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -143,7 +143,7 @@ static struct irq_chip pxa_low_gpio_chip = {
  * Demux handler for GPIO>=2 edge detect interrupts
  */
 
-static void pxa_gpio_demux_handler(unsigned int irq, struct irqdesc *desc)
+static void pxa_gpio_demux_handler(unsigned int irq, struct irq_desc *desc)
 {
 	unsigned int mask;
 	int loop;
@@ -286,27 +286,27 @@ void __init pxa_init_irq(void)
 
 	for (irq = PXA_IRQ(PXA_IRQ_SKIP); irq <= PXA_IRQ(31); irq++) {
 		set_irq_chip(irq, &pxa_internal_chip_low);
-		set_irq_handler(irq, do_level_IRQ);
+		set_irq_handler(irq, handle_level_irq);
 		set_irq_flags(irq, IRQF_VALID);
 	}
 
 #if PXA_INTERNAL_IRQS > 32
 	for (irq = PXA_IRQ(32); irq < PXA_IRQ(PXA_INTERNAL_IRQS); irq++) {
 		set_irq_chip(irq, &pxa_internal_chip_high);
-		set_irq_handler(irq, do_level_IRQ);
+		set_irq_handler(irq, handle_level_irq);
 		set_irq_flags(irq, IRQF_VALID);
 	}
 #endif
 
 	for (irq = IRQ_GPIO0; irq <= IRQ_GPIO1; irq++) {
 		set_irq_chip(irq, &pxa_low_gpio_chip);
-		set_irq_handler(irq, do_edge_IRQ);
+		set_irq_handler(irq, handle_edge_irq);
 		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
 	}
 
 	for (irq = IRQ_GPIO(2); irq <= IRQ_GPIO(PXA_LAST_GPIO); irq++) {
 		set_irq_chip(irq, &pxa_muxed_gpio_chip);
-		set_irq_handler(irq, do_edge_IRQ);
+		set_irq_handler(irq, handle_edge_irq);
 		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
 	}
 

commit 0cd61b68c340a4f901a06e8bb5e0dea4353161c0
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Fri Oct 6 10:53:39 2006 -0700

    Initial blind fixup for arm for irq changes
    
    Untested, but this should fix up the bulk of the totally mechanical
    issues, and should make the actual detail fixing easier.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 12141e2a50cc..ab1a16025d51 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -143,8 +143,7 @@ static struct irq_chip pxa_low_gpio_chip = {
  * Demux handler for GPIO>=2 edge detect interrupts
  */
 
-static void pxa_gpio_demux_handler(unsigned int irq, struct irqdesc *desc,
-				   struct pt_regs *regs)
+static void pxa_gpio_demux_handler(unsigned int irq, struct irqdesc *desc)
 {
 	unsigned int mask;
 	int loop;
@@ -160,7 +159,7 @@ static void pxa_gpio_demux_handler(unsigned int irq, struct irqdesc *desc,
 			mask >>= 2;
 			do {
 				if (mask & 1)
-					desc_handle_irq(irq, desc, regs);
+					desc_handle_irq(irq, desc);
 				irq++;
 				desc++;
 				mask >>= 1;
@@ -175,7 +174,7 @@ static void pxa_gpio_demux_handler(unsigned int irq, struct irqdesc *desc,
 			desc = irq_desc + irq;
 			do {
 				if (mask & 1)
-					desc_handle_irq(irq, desc, regs);
+					desc_handle_irq(irq, desc);
 				irq++;
 				desc++;
 				mask >>= 1;
@@ -190,7 +189,7 @@ static void pxa_gpio_demux_handler(unsigned int irq, struct irqdesc *desc,
 			desc = irq_desc + irq;
 			do {
 				if (mask & 1)
-					desc_handle_irq(irq, desc, regs);
+					desc_handle_irq(irq, desc);
 				irq++;
 				desc++;
 				mask >>= 1;
@@ -206,7 +205,7 @@ static void pxa_gpio_demux_handler(unsigned int irq, struct irqdesc *desc,
 			desc = irq_desc + irq;
 			do {
 				if (mask & 1)
-					desc_handle_irq(irq, desc, regs);
+					desc_handle_irq(irq, desc);
 				irq++;
 				desc++;
 				mask >>= 1;

commit 38c677cb9a683c9d477f845484b74b0a1b23e1fb
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Aug 1 22:26:25 2006 +0100

    [ARM] 3739/1: genirq updates:  irq_chip, add and use irq_chip.name
    
    Patch from David Brownell
    
    ARM genirq cleanups/updates:
    
        - Start switching platforms to newer APIs
            * use "irq_chip" name, not "irqchip"
            * providing irq_chip.name
    
        - Show irq_chip.name in /proc/interrupts, like on x86.
    
    This update a bit more than half of the ARM code.  The irq_chip.name
    values were chosen to match docs (if I have them) or be otherwise
    obvious ("FPGA", "CPLD", or matching the code).
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index d9635ff4b10c..12141e2a50cc 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -39,7 +39,8 @@ static void pxa_unmask_low_irq(unsigned int irq)
 	ICMR |= (1 << (irq + PXA_IRQ_SKIP));
 }
 
-static struct irqchip pxa_internal_chip_low = {
+static struct irq_chip pxa_internal_chip_low = {
+	.name		= "SC",
 	.ack		= pxa_mask_low_irq,
 	.mask		= pxa_mask_low_irq,
 	.unmask		= pxa_unmask_low_irq,
@@ -61,7 +62,8 @@ static void pxa_unmask_high_irq(unsigned int irq)
 	ICMR2 |= (1 << (irq - 32 + PXA_IRQ_SKIP));
 }
 
-static struct irqchip pxa_internal_chip_high = {
+static struct irq_chip pxa_internal_chip_high = {
+	.name		= "SC-hi",
 	.ack		= pxa_mask_high_irq,
 	.mask		= pxa_mask_high_irq,
 	.unmask		= pxa_unmask_high_irq,
@@ -129,7 +131,8 @@ static void pxa_ack_low_gpio(unsigned int irq)
 	GEDR0 = (1 << (irq - IRQ_GPIO0));
 }
 
-static struct irqchip pxa_low_gpio_chip = {
+static struct irq_chip pxa_low_gpio_chip = {
+	.name		= "GPIO-l",
 	.ack		= pxa_ack_low_gpio,
 	.mask		= pxa_mask_low_irq,
 	.unmask		= pxa_unmask_low_irq,
@@ -237,7 +240,8 @@ static void pxa_unmask_muxed_gpio(unsigned int irq)
 	GFER(gpio) = GPIO_IRQ_falling_edge[idx] & GPIO_IRQ_mask[idx];
 }
 
-static struct irqchip pxa_muxed_gpio_chip = {
+static struct irq_chip pxa_muxed_gpio_chip = {
+	.name		= "GPIO",
 	.ack		= pxa_ack_muxed_gpio,
 	.mask		= pxa_mask_muxed_gpio,
 	.unmask		= pxa_unmask_muxed_gpio,

commit e033108bf7e585755350b554048229d1fd10a02e
Author: Guennadi Liakhovetski <gl@dsa-ac.de>
Date:   Wed Jun 28 16:42:02 2006 +0100

    [ARM] 3672/1: PXA: don't probe output GPIOs for interrupt
    
    Patch from Guennadi Liakhovetski
    
    Currently probe_irq_on() on PXA will silently reconfigure all output GPIOs, that are not configured as alternate functions, for input. Avoid that. Upon CPU reset all GPIOs are configured as inputs, so, if a GPIO is configured as output, it has been done so intentionally.
    
    Signed-off-by: G. Liakhovetski <gl@dsa-ac.de>
    Signed-off-by: Nicolas Pitre <nico@cam.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 539b596005fc..d9635ff4b10c 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -88,8 +88,8 @@ static int pxa_gpio_irq_type(unsigned int irq, unsigned int type)
 
 	if (type == IRQT_PROBE) {
 	    /* Don't mess with enabled GPIOs using preconfigured edges or
-	       GPIOs set to alternate function during probe */
-		if ((GPIO_IRQ_rising_edge[idx] | GPIO_IRQ_falling_edge[idx]) &
+	       GPIOs set to alternate function or to output during probe */
+		if ((GPIO_IRQ_rising_edge[idx] | GPIO_IRQ_falling_edge[idx] | GPDR(gpio)) &
 		    GPIO_bit(gpio))
 			return 0;
 		if (GAFR(gpio) & (0x3 << (((gpio) & 0xf)*2)))

commit 664399e1fbdceb18da9c9c5534dedd62327c63e8
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Sep 4 19:45:00 2005 +0100

    [ARM] Wrap calls to descriptor handlers
    
    This is part of Thomas Gleixner's generic IRQ patch, which converts
    ARM to use the generic IRQ subsystem.  Here, we wrap calls to
    desc->handler() in an inline function, desc_handle_irq().  This
    reduces the size of Thomas' patch since the changes become more
    localised.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index 6cf35f674464..539b596005fc 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -157,7 +157,7 @@ static void pxa_gpio_demux_handler(unsigned int irq, struct irqdesc *desc,
 			mask >>= 2;
 			do {
 				if (mask & 1)
-					desc->handle(irq, desc, regs);
+					desc_handle_irq(irq, desc, regs);
 				irq++;
 				desc++;
 				mask >>= 1;
@@ -172,7 +172,7 @@ static void pxa_gpio_demux_handler(unsigned int irq, struct irqdesc *desc,
 			desc = irq_desc + irq;
 			do {
 				if (mask & 1)
-					desc->handle(irq, desc, regs);
+					desc_handle_irq(irq, desc, regs);
 				irq++;
 				desc++;
 				mask >>= 1;
@@ -187,7 +187,7 @@ static void pxa_gpio_demux_handler(unsigned int irq, struct irqdesc *desc,
 			desc = irq_desc + irq;
 			do {
 				if (mask & 1)
-					desc->handle(irq, desc, regs);
+					desc_handle_irq(irq, desc, regs);
 				irq++;
 				desc++;
 				mask >>= 1;
@@ -203,7 +203,7 @@ static void pxa_gpio_demux_handler(unsigned int irq, struct irqdesc *desc,
 			desc = irq_desc + irq;
 			do {
 				if (mask & 1)
-					desc->handle(irq, desc, regs);
+					desc_handle_irq(irq, desc, regs);
 				irq++;
 				desc++;
 				mask >>= 1;

commit 7801907b8c4a49f8ec033d13a938751114a97a55
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Sep 4 19:43:13 2005 +0100

    [ARM] Change irq_chip wake/type methods to set_wake/set_type
    
    This is part of Thomas Gleixner's generic IRQ patch, which converts
    ARM to use the generic IRQ subsystem.  Here, we rename two of the
    irq_chip methods - wake becomes set_wake, and type becomes set_type.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
index f3cac43124a5..6cf35f674464 100644
--- a/arch/arm/mach-pxa/irq.c
+++ b/arch/arm/mach-pxa/irq.c
@@ -133,7 +133,7 @@ static struct irqchip pxa_low_gpio_chip = {
 	.ack		= pxa_ack_low_gpio,
 	.mask		= pxa_mask_low_irq,
 	.unmask		= pxa_unmask_low_irq,
-	.type		= pxa_gpio_irq_type,
+	.set_type	= pxa_gpio_irq_type,
 };
 
 /*
@@ -241,7 +241,7 @@ static struct irqchip pxa_muxed_gpio_chip = {
 	.ack		= pxa_ack_muxed_gpio,
 	.mask		= pxa_mask_muxed_gpio,
 	.unmask		= pxa_unmask_muxed_gpio,
-	.type		= pxa_gpio_irq_type,
+	.set_type	= pxa_gpio_irq_type,
 };
 
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/arm/mach-pxa/irq.c b/arch/arm/mach-pxa/irq.c
new file mode 100644
index 000000000000..f3cac43124a5
--- /dev/null
+++ b/arch/arm/mach-pxa/irq.c
@@ -0,0 +1,313 @@
+/*
+ *  linux/arch/arm/mach-pxa/irq.c
+ *
+ *  Generic PXA IRQ handling, GPIO IRQ demultiplexing, etc.
+ *
+ *  Author:	Nicolas Pitre
+ *  Created:	Jun 15, 2001
+ *  Copyright:	MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/pxa-regs.h>
+
+#include "generic.h"
+
+
+/*
+ * This is for peripheral IRQs internal to the PXA chip.
+ */
+
+static void pxa_mask_low_irq(unsigned int irq)
+{
+	ICMR &= ~(1 << (irq + PXA_IRQ_SKIP));
+}
+
+static void pxa_unmask_low_irq(unsigned int irq)
+{
+	ICMR |= (1 << (irq + PXA_IRQ_SKIP));
+}
+
+static struct irqchip pxa_internal_chip_low = {
+	.ack		= pxa_mask_low_irq,
+	.mask		= pxa_mask_low_irq,
+	.unmask		= pxa_unmask_low_irq,
+};
+
+#if PXA_INTERNAL_IRQS > 32
+
+/*
+ * This is for the second set of internal IRQs as found on the PXA27x.
+ */
+
+static void pxa_mask_high_irq(unsigned int irq)
+{
+	ICMR2 &= ~(1 << (irq - 32 + PXA_IRQ_SKIP));
+}
+
+static void pxa_unmask_high_irq(unsigned int irq)
+{
+	ICMR2 |= (1 << (irq - 32 + PXA_IRQ_SKIP));
+}
+
+static struct irqchip pxa_internal_chip_high = {
+	.ack		= pxa_mask_high_irq,
+	.mask		= pxa_mask_high_irq,
+	.unmask		= pxa_unmask_high_irq,
+};
+
+#endif
+
+/*
+ * PXA GPIO edge detection for IRQs:
+ * IRQs are generated on Falling-Edge, Rising-Edge, or both.
+ * Use this instead of directly setting GRER/GFER.
+ */
+
+static long GPIO_IRQ_rising_edge[4];
+static long GPIO_IRQ_falling_edge[4];
+static long GPIO_IRQ_mask[4];
+
+static int pxa_gpio_irq_type(unsigned int irq, unsigned int type)
+{
+	int gpio, idx;
+
+	gpio = IRQ_TO_GPIO(irq);
+	idx = gpio >> 5;
+
+	if (type == IRQT_PROBE) {
+	    /* Don't mess with enabled GPIOs using preconfigured edges or
+	       GPIOs set to alternate function during probe */
+		if ((GPIO_IRQ_rising_edge[idx] | GPIO_IRQ_falling_edge[idx]) &
+		    GPIO_bit(gpio))
+			return 0;
+		if (GAFR(gpio) & (0x3 << (((gpio) & 0xf)*2)))
+			return 0;
+		type = __IRQT_RISEDGE | __IRQT_FALEDGE;
+	}
+
+	/* printk(KERN_DEBUG "IRQ%d (GPIO%d): ", irq, gpio); */
+
+	pxa_gpio_mode(gpio | GPIO_IN);
+
+	if (type & __IRQT_RISEDGE) {
+		/* printk("rising "); */
+		__set_bit (gpio, GPIO_IRQ_rising_edge);
+	} else
+		__clear_bit (gpio, GPIO_IRQ_rising_edge);
+
+	if (type & __IRQT_FALEDGE) {
+		/* printk("falling "); */
+		__set_bit (gpio, GPIO_IRQ_falling_edge);
+	} else
+		__clear_bit (gpio, GPIO_IRQ_falling_edge);
+
+	/* printk("edges\n"); */
+
+	GRER(gpio) = GPIO_IRQ_rising_edge[idx] & GPIO_IRQ_mask[idx];
+	GFER(gpio) = GPIO_IRQ_falling_edge[idx] & GPIO_IRQ_mask[idx];
+	return 0;
+}
+
+/*
+ * GPIO IRQs must be acknowledged.  This is for GPIO 0 and 1.
+ */
+
+static void pxa_ack_low_gpio(unsigned int irq)
+{
+	GEDR0 = (1 << (irq - IRQ_GPIO0));
+}
+
+static struct irqchip pxa_low_gpio_chip = {
+	.ack		= pxa_ack_low_gpio,
+	.mask		= pxa_mask_low_irq,
+	.unmask		= pxa_unmask_low_irq,
+	.type		= pxa_gpio_irq_type,
+};
+
+/*
+ * Demux handler for GPIO>=2 edge detect interrupts
+ */
+
+static void pxa_gpio_demux_handler(unsigned int irq, struct irqdesc *desc,
+				   struct pt_regs *regs)
+{
+	unsigned int mask;
+	int loop;
+
+	do {
+		loop = 0;
+
+		mask = GEDR0 & ~3;
+		if (mask) {
+			GEDR0 = mask;
+			irq = IRQ_GPIO(2);
+			desc = irq_desc + irq;
+			mask >>= 2;
+			do {
+				if (mask & 1)
+					desc->handle(irq, desc, regs);
+				irq++;
+				desc++;
+				mask >>= 1;
+			} while (mask);
+			loop = 1;
+		}
+
+		mask = GEDR1;
+		if (mask) {
+			GEDR1 = mask;
+			irq = IRQ_GPIO(32);
+			desc = irq_desc + irq;
+			do {
+				if (mask & 1)
+					desc->handle(irq, desc, regs);
+				irq++;
+				desc++;
+				mask >>= 1;
+			} while (mask);
+			loop = 1;
+		}
+
+		mask = GEDR2;
+		if (mask) {
+			GEDR2 = mask;
+			irq = IRQ_GPIO(64);
+			desc = irq_desc + irq;
+			do {
+				if (mask & 1)
+					desc->handle(irq, desc, regs);
+				irq++;
+				desc++;
+				mask >>= 1;
+			} while (mask);
+			loop = 1;
+		}
+
+#if PXA_LAST_GPIO >= 96
+		mask = GEDR3;
+		if (mask) {
+			GEDR3 = mask;
+			irq = IRQ_GPIO(96);
+			desc = irq_desc + irq;
+			do {
+				if (mask & 1)
+					desc->handle(irq, desc, regs);
+				irq++;
+				desc++;
+				mask >>= 1;
+			} while (mask);
+			loop = 1;
+		}
+#endif
+	} while (loop);
+}
+
+static void pxa_ack_muxed_gpio(unsigned int irq)
+{
+	int gpio = irq - IRQ_GPIO(2) + 2;
+	GEDR(gpio) = GPIO_bit(gpio);
+}
+
+static void pxa_mask_muxed_gpio(unsigned int irq)
+{
+	int gpio = irq - IRQ_GPIO(2) + 2;
+	__clear_bit(gpio, GPIO_IRQ_mask);
+	GRER(gpio) &= ~GPIO_bit(gpio);
+	GFER(gpio) &= ~GPIO_bit(gpio);
+}
+
+static void pxa_unmask_muxed_gpio(unsigned int irq)
+{
+	int gpio = irq - IRQ_GPIO(2) + 2;
+	int idx = gpio >> 5;
+	__set_bit(gpio, GPIO_IRQ_mask);
+	GRER(gpio) = GPIO_IRQ_rising_edge[idx] & GPIO_IRQ_mask[idx];
+	GFER(gpio) = GPIO_IRQ_falling_edge[idx] & GPIO_IRQ_mask[idx];
+}
+
+static struct irqchip pxa_muxed_gpio_chip = {
+	.ack		= pxa_ack_muxed_gpio,
+	.mask		= pxa_mask_muxed_gpio,
+	.unmask		= pxa_unmask_muxed_gpio,
+	.type		= pxa_gpio_irq_type,
+};
+
+
+void __init pxa_init_irq(void)
+{
+	int irq;
+
+	/* disable all IRQs */
+	ICMR = 0;
+
+	/* all IRQs are IRQ, not FIQ */
+	ICLR = 0;
+
+	/* clear all GPIO edge detects */
+	GFER0 = 0;
+	GFER1 = 0;
+	GFER2 = 0;
+	GRER0 = 0;
+	GRER1 = 0;
+	GRER2 = 0;
+	GEDR0 = GEDR0;
+	GEDR1 = GEDR1;
+	GEDR2 = GEDR2;
+
+#ifdef CONFIG_PXA27x
+	/* And similarly for the extra regs on the PXA27x */
+	ICMR2 = 0;
+	ICLR2 = 0;
+	GFER3 = 0;
+	GRER3 = 0;
+	GEDR3 = GEDR3;
+#endif
+
+	/* only unmasked interrupts kick us out of idle */
+	ICCR = 1;
+
+	/* GPIO 0 and 1 must have their mask bit always set */
+	GPIO_IRQ_mask[0] = 3;
+
+	for (irq = PXA_IRQ(PXA_IRQ_SKIP); irq <= PXA_IRQ(31); irq++) {
+		set_irq_chip(irq, &pxa_internal_chip_low);
+		set_irq_handler(irq, do_level_IRQ);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+
+#if PXA_INTERNAL_IRQS > 32
+	for (irq = PXA_IRQ(32); irq < PXA_IRQ(PXA_INTERNAL_IRQS); irq++) {
+		set_irq_chip(irq, &pxa_internal_chip_high);
+		set_irq_handler(irq, do_level_IRQ);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+#endif
+
+	for (irq = IRQ_GPIO0; irq <= IRQ_GPIO1; irq++) {
+		set_irq_chip(irq, &pxa_low_gpio_chip);
+		set_irq_handler(irq, do_edge_IRQ);
+		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	}
+
+	for (irq = IRQ_GPIO(2); irq <= IRQ_GPIO(PXA_LAST_GPIO); irq++) {
+		set_irq_chip(irq, &pxa_muxed_gpio_chip);
+		set_irq_handler(irq, do_edge_IRQ);
+		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	}
+
+	/* Install handler for GPIO>=2 edge detect interrupts */
+	set_irq_chip(IRQ_GPIO_2_x, &pxa_internal_chip_low);
+	set_irq_chained_handler(IRQ_GPIO_2_x, pxa_gpio_demux_handler);
+}
