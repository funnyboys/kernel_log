commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index 3732aec76750..6a5451b186c2 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  linux/arch/arm/mach-pxa/mfp-pxa2xx.c
  *
@@ -7,10 +8,6 @@
  *  functions, this is by concept samilar to the MFP configuration
  *  on PXA3xx,  what's more important, the low power pin state and
  *  wakeup detection are also supported by the same framework.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
  */
 #include <linux/gpio.h>
 #include <linux/gpio-pxa.h>

commit 4c25c5d2985c1db482cfe59ed9b3a07829a60ba9
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jan 30 10:45:33 2015 +0100

    ARM: pxa: make more mach/*.h files local
    
    Lots of header files are never included outside of a mach-pxa
    directory and do not need to be made visible in include/mach,
    so let's just move them all down one level.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index 666b78972c40..3732aec76750 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -21,7 +21,7 @@
 #include <linux/syscore_ops.h>
 
 #include <mach/pxa2xx-regs.h>
-#include <mach/mfp-pxa2xx.h>
+#include "mfp-pxa2xx.h"
 
 #include "generic.h"
 

commit 7b472ac75689af196d868b3f2322edb44b8096d3
Author: Joe Perches <joe@perches.com>
Date:   Sat Sep 13 11:31:18 2014 -0700

    arm: mach-pxa: Convert pr_warning to pr_warn
    
    Use the more common pr_warn.
    
    Other miscellanea:
    
    o Coalesce formats
    o Realign arguments
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index ef0426a159d4..666b78972c40 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -93,8 +93,8 @@ static int __mfp_config_gpio(unsigned gpio, unsigned long c)
 		break;
 	default:
 		/* warning and fall through, treat as MFP_LPM_DEFAULT */
-		pr_warning("%s: GPIO%d: unsupported low power mode\n",
-				__func__, gpio);
+		pr_warn("%s: GPIO%d: unsupported low power mode\n",
+			__func__, gpio);
 		break;
 	}
 
@@ -107,14 +107,12 @@ static int __mfp_config_gpio(unsigned gpio, unsigned long c)
 	 * configurations of those pins not able to wakeup
 	 */
 	if ((c & MFP_LPM_CAN_WAKEUP) && !gpio_desc[gpio].can_wakeup) {
-		pr_warning("%s: GPIO%d unable to wakeup\n",
-				__func__, gpio);
+		pr_warn("%s: GPIO%d unable to wakeup\n", __func__, gpio);
 		return -EINVAL;
 	}
 
 	if ((c & MFP_LPM_CAN_WAKEUP) && is_out) {
-		pr_warning("%s: output GPIO%d unable to wakeup\n",
-				__func__, gpio);
+		pr_warn("%s: output GPIO%d unable to wakeup\n", __func__, gpio);
 		return -EINVAL;
 	}
 
@@ -126,7 +124,7 @@ static inline int __mfp_validate(int mfp)
 	int gpio = mfp_to_gpio(mfp);
 
 	if ((mfp > MFP_PIN_GPIO127) || !gpio_desc[gpio].valid) {
-		pr_warning("%s: GPIO%d is invalid pin\n", __func__, gpio);
+		pr_warn("%s: GPIO%d is invalid pin\n", __func__, gpio);
 		return -1;
 	}
 

commit ef7c7c693b4b05a293678fd40ed1511bc94d6f61
Author: Igor Grinberg <grinberg@compulab.co.il>
Date:   Thu Apr 12 15:43:29 2012 +0300

    ARM: PXA2xx: MFP: fix potential direction bug
    
    Pins configured as input and have MFP_LPM_DRIVE_* flag set, can have a
    wrong output value for some period of time (spike) during the suspend
    sequence.
    This can happen because the direction of the pins (GPDR) is set by
    software and the output level is set by hardware (PGSR) at a later
    stage.
    
    Fix the above potential bug by setting the output levels first.
    Also save the actual levels of the pins before the suspend and restore
    them after the resume, but before the direction settings take place, so
    the same bug as described above will not happen in the resume sequence.
    
    Reported-by: Paul Parsons <lost.distance@yahoo.com>
    Signed-off-by: Igor Grinberg <grinberg@compulab.co.il>
    Tested-by: Paul Parsons <lost.distance@yahoo.com>
    Signed-off-by: Haojian Zhuang <haojian.zhuang@gmail.com>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index d2373d79b657..ef0426a159d4 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -33,6 +33,8 @@
 #define BANK_OFF(n)	(((n) < 3) ? (n) << 2 : 0x100 + (((n) - 3) << 2))
 #define GPLR(x)		__REG2(0x40E00000, BANK_OFF((x) >> 5))
 #define GPDR(x)		__REG2(0x40E00000, BANK_OFF((x) >> 5) + 0x0c)
+#define GPSR(x)		__REG2(0x40E00000, BANK_OFF((x) >> 5) + 0x18)
+#define GPCR(x)		__REG2(0x40E00000, BANK_OFF((x) >> 5) + 0x24)
 
 #define PWER_WE35	(1 << 24)
 
@@ -348,6 +350,7 @@ static inline void pxa27x_mfp_init(void) {}
 #ifdef CONFIG_PM
 static unsigned long saved_gafr[2][4];
 static unsigned long saved_gpdr[4];
+static unsigned long saved_gplr[4];
 static unsigned long saved_pgsr[4];
 
 static int pxa2xx_mfp_suspend(void)
@@ -369,7 +372,11 @@ static int pxa2xx_mfp_suspend(void)
 		saved_gafr[0][i] = GAFR_L(i);
 		saved_gafr[1][i] = GAFR_U(i);
 		saved_gpdr[i] = GPDR(i * 32);
+		saved_gplr[i] = GPLR(i * 32);
 		saved_pgsr[i] = PGSR(i);
+
+		GPSR(i * 32) = PGSR(i);
+		GPCR(i * 32) = ~PGSR(i);
 	}
 
 	/* set GPDR bits taking into account MFP_LPM_KEEP_OUTPUT */
@@ -392,6 +399,8 @@ static void pxa2xx_mfp_resume(void)
 	for (i = 0; i <= gpio_to_bank(pxa_last_gpio); i++) {
 		GAFR_L(i) = saved_gafr[0][i];
 		GAFR_U(i) = saved_gafr[1][i];
+		GPSR(i * 32) = saved_gplr[i];
+		GPCR(i * 32) = ~saved_gplr[i];
 		GPDR(i * 32) = saved_gpdr[i];
 		PGSR(i) = saved_pgsr[i];
 	}

commit a13b878780ea98d8415203c4502a8fc5bc614656
Author: Igor Grinberg <grinberg@compulab.co.il>
Date:   Thu Apr 12 15:43:28 2012 +0300

    ARM: PXA2xx: MFP: fix bug with MFP_LPM_KEEP_OUTPUT
    
    Pins that have MFP_LPM_KEEP_OUTPUT set and are configured for output
    must retain the output state in low power mode.
    Currently, the pin direction configuration is overrided with values
    in gpdr_lpm[] array and do not obey the MFP_LPM_KEEP_OUTPUT setting.
    
    Fix the above bug and add some documentation to clarify the
    MFP_LPM_KEEP_OUTPUT setting purpose.
    
    Reported-by: Paul Parsons <lost.distance@yahoo.com>
    Signed-off-by: Igor Grinberg <grinberg@compulab.co.il>
    Tested-by: Paul Parsons <lost.distance@yahoo.com>
    Signed-off-by: Haojian Zhuang <haojian.zhuang@gmail.com>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index b0a842887780..d2373d79b657 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -366,14 +366,22 @@ static int pxa2xx_mfp_suspend(void)
 	}
 
 	for (i = 0; i <= gpio_to_bank(pxa_last_gpio); i++) {
-
 		saved_gafr[0][i] = GAFR_L(i);
 		saved_gafr[1][i] = GAFR_U(i);
 		saved_gpdr[i] = GPDR(i * 32);
 		saved_pgsr[i] = PGSR(i);
+	}
 
-		GPDR(i * 32) = gpdr_lpm[i];
+	/* set GPDR bits taking into account MFP_LPM_KEEP_OUTPUT */
+	for (i = 0; i < pxa_last_gpio; i++) {
+		if ((gpdr_lpm[gpio_to_bank(i)] & GPIO_bit(i)) ||
+		    ((gpio_desc[i].config & MFP_LPM_KEEP_OUTPUT) &&
+		     (saved_gpdr[gpio_to_bank(i)] & GPIO_bit(i))))
+			GPDR(i) |= GPIO_bit(i);
+		else
+			GPDR(i) &= ~GPIO_bit(i);
 	}
+
 	return 0;
 }
 

commit 820d41cf0cd0e94a5661e093821e2e5c6b36a9d8
Merge: 6268b325c306 88b48684fe2d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 29 18:02:10 2012 -0700

    Merge tag 'cleanup2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull "ARM: cleanups of io includes" from Olof Johansson:
     "Rob Herring has done a sweeping change cleaning up all of the
      mach/io.h includes, moving some of the oft-repeated macros to a common
      location and removing a bunch of boiler plate.  This is another step
      closer to a common zImage for multiple platforms."
    
    Fix up various fairly trivial conflicts (<mach/io.h> removal vs changes
    around it, tegra localtimer.o is *still* gone, yadda-yadda).
    
    * tag 'cleanup2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (29 commits)
      ARM: tegra: Include assembler.h in sleep.S to fix build break
      ARM: pxa: use common IOMEM definition
      ARM: dma-mapping: convert ARCH_HAS_DMA_SET_COHERENT_MASK to kconfig symbol
      ARM: __io abuse cleanup
      ARM: create a common IOMEM definition
      ARM: iop13xx: fix missing declaration of iop13xx_init_early
      ARM: fix ioremap/iounmap for !CONFIG_MMU
      ARM: kill off __mem_pci
      ARM: remove bunch of now unused mach/io.h files
      ARM: make mach/io.h include optional
      ARM: clps711x: remove unneeded include of mach/io.h
      ARM: dove: add explicit include of dove.h to addr-map.c
      ARM: at91: add explicit include of hardware.h to uncompressor
      ARM: ep93xx: clean-up mach/io.h
      ARM: tegra: clean-up mach/io.h
      ARM: orion5x: clean-up mach/io.h
      ARM: davinci: remove unneeded mach/io.h include
      [media] davinci: remove includes of mach/io.h
      ARM: OMAP: Remove remaining includes for mach/io.h
      ARM: msm: clean-up mach/io.h
      ...

commit 23019a733bb83c8499f192fb428b7e6e81c95a34
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Tue Mar 20 14:33:19 2012 -0500

    ARM: pxa: use common IOMEM definition
    
    pxa was missed in the moving of IOMEM to a common definition, so lots of
    IOMEM redefined warnings were introduced. So remove pxa IOMEM definition
    and fix all the fallout.
    
    Reported-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Haojian Zhuang <haojian.zhuang@marvell.com>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: rtc-linux@googlegroups.com
    Cc: alsa-devel@alsa-project.org

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index f14775536b83..b029562da41e 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -17,6 +17,7 @@
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
+#include <linux/io.h>
 #include <linux/syscore_ops.h>
 
 #include <mach/pxa2xx-regs.h>

commit af829310e8a914ad17ed61a7b18b14b4f457bca1
Author: Haojian Zhuang <haojian.zhuang@gmail.com>
Date:   Tue Mar 6 14:57:16 2012 +0800

    ARM: pxa: fix invalid mfp pin issue
    
    Failure is reported on hx4700 with kernel v3.3-rc1.
    
    __mfp_validate: GPIO20 is invalid pin
    __mfp_validate: GPIO21 is invalid pin
    __mfp_validate: GPIO15 is invalid pin
    __mfp_validate: GPIO78 is invalid pin
    __mfp_validate: GPIO79 is invalid pin
    __mfp_validate: GPIO80 is invalid pin
    __mfp_validate: GPIO33 is invalid pin
    __mfp_validate: GPIO48 is invalid pin
    __mfp_validate: GPIO49 is invalid pin
    __mfp_validate: GPIO50 is invalid pin
    
    Since pxa_last_gpio is used in mfp-pxa2xx driver. But it's only
    updated in pxa-gpio driver that run after mfp-pxa2xx driver.
    
    So update the pxa_last_gpio first in mfp-pxa2xx driver.
    
    Reported-by: Paul Parsons <lost.distance@yahoo.com>
    Signed-off-by: Haojian Zhuang <haojian.zhuang@gmail.com>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index f14775536b83..29b62afc6f7c 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -226,6 +226,12 @@ static void __init pxa25x_mfp_init(void)
 {
 	int i;
 
+	/* running before pxa_gpio_probe() */
+#ifdef CONFIG_CPU_PXA26x
+	pxa_last_gpio = 89;
+#else
+	pxa_last_gpio = 84;
+#endif
 	for (i = 0; i <= pxa_last_gpio; i++)
 		gpio_desc[i].valid = 1;
 
@@ -295,6 +301,7 @@ static void __init pxa27x_mfp_init(void)
 {
 	int i, gpio;
 
+	pxa_last_gpio = 120;	/* running before pxa_gpio_probe() */
 	for (i = 0; i <= pxa_last_gpio; i++) {
 		/* skip GPIO2, 5, 6, 7, 8, they are not
 		 * valid pins allow configuration

commit 157d2644cb0c1e71a18baaffca56d2b1d0ebf10f
Author: Haojian Zhuang <haojian.zhuang@marvell.com>
Date:   Mon Oct 17 20:37:52 2011 +0800

    ARM: pxa: change gpio to platform device
    
    Remove most gpio macros and change gpio driver to platform driver.
    
    Signed-off-by: Haojian Zhuang <haojian.zhuang@marvell.com>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index 43a5f6861ca3..f14775536b83 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -13,6 +13,7 @@
  *  published by the Free Software Foundation.
  */
 #include <linux/gpio.h>
+#include <linux/gpio-pxa.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -20,7 +21,6 @@
 
 #include <mach/pxa2xx-regs.h>
 #include <mach/mfp-pxa2xx.h>
-#include <mach/gpio-pxa.h>
 
 #include "generic.h"
 
@@ -29,6 +29,10 @@
 #define GAFR_L(x)	__GAFR(0, x)
 #define GAFR_U(x)	__GAFR(1, x)
 
+#define BANK_OFF(n)	(((n) < 3) ? (n) << 2 : 0x100 + (((n) - 3) << 2))
+#define GPLR(x)		__REG2(0x40E00000, BANK_OFF((x) >> 5))
+#define GPDR(x)		__REG2(0x40E00000, BANK_OFF((x) >> 5) + 0x0c)
+
 #define PWER_WE35	(1 << 24)
 
 struct gpio_desc {

commit f55be1bf52aad524dc1bf556ae26c90262c87825
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Sep 28 09:11:30 2011 +0100

    ARM: 7104/1: plat-pxa: break out GPIO driver specifics
    
    The <mach/gpio.h> file is included from upper directories
    and deal with generic GPIO and gpiolib stuff. Break out the
    platform and driver specific defines and functions into its own
    header file.
    
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index b129527832cb..43a5f6861ca3 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -20,6 +20,7 @@
 
 #include <mach/pxa2xx-regs.h>
 #include <mach/mfp-pxa2xx.h>
+#include <mach/gpio-pxa.h>
 
 #include "generic.h"
 

commit 2f8163baada3dbd0ce891c35bc59ae46e773487a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jul 26 10:53:52 2011 +0100

    ARM: gpio: convert includes of mach/gpio.h and asm/gpio.h to linux/gpio.h
    
    Convert arch/arm includes of mach/gpio.h and asm/gpio.h to linux/gpio.h
    before we start consolidating the individual platform implementations
    of the gpio header files.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index b27544bcafcb..b129527832cb 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -12,13 +12,12 @@
  *  it under the terms of the GNU General Public License version 2 as
  *  published by the Free Software Foundation.
  */
-
+#include <linux/gpio.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/syscore_ops.h>
 
-#include <mach/gpio.h>
 #include <mach/pxa2xx-regs.h>
 #include <mach/mfp-pxa2xx.h>
 

commit beb0c9b056b1c23d2029b46a425362e9ccbeba01
Author: Paul Parsons <lost.distance@yahoo.com>
Date:   Sun May 8 01:54:33 2011 +0000

    ARM: pxa: fix PGSR register address calculation
    
    The file mfp-pxa2xx.c defines a macro, PGSR(), which translates a gpio
    bank number to a PGSR register address. The function pxa2xx_mfp_suspend()
    erroneously passed in a gpio number instead of a gpio bank number.
    
    Signed-off-by: Paul Parsons <lost.distance@yahoo.com>
    Cc: stable@kernel.org
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index 87ae3129f4f7..b27544bcafcb 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -347,9 +347,9 @@ static int pxa2xx_mfp_suspend(void)
 		if ((gpio_desc[i].config & MFP_LPM_KEEP_OUTPUT) &&
 		    (GPDR(i) & GPIO_bit(i))) {
 			if (GPLR(i) & GPIO_bit(i))
-				PGSR(i) |= GPIO_bit(i);
+				PGSR(gpio_to_bank(i)) |= GPIO_bit(i);
 			else
-				PGSR(i) &= ~GPIO_bit(i);
+				PGSR(gpio_to_bank(i)) &= ~GPIO_bit(i);
 		}
 	}
 

commit 2eaa03b5bebd1e80014f780d7bf27c3e66daefd6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Apr 22 22:03:11 2011 +0200

    ARM / PXA: Use struct syscore_ops for "core" power management
    
    Replace sysdev classes and struct sys_device objects used for "core"
    power management by the PXA platform code with struct syscore_ops
    objects that are simpler.
    
    This reduces the code size and the kernel memory footprint.  It also
    is necessary for removing sysdevs entirely from the kernel in the
    future.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index 1d1419b73457..87ae3129f4f7 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -16,7 +16,7 @@
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
-#include <linux/sysdev.h>
+#include <linux/syscore_ops.h>
 
 #include <mach/gpio.h>
 #include <mach/pxa2xx-regs.h>
@@ -338,7 +338,7 @@ static unsigned long saved_gafr[2][4];
 static unsigned long saved_gpdr[4];
 static unsigned long saved_pgsr[4];
 
-static int pxa2xx_mfp_suspend(struct sys_device *d, pm_message_t state)
+static int pxa2xx_mfp_suspend(void)
 {
 	int i;
 
@@ -365,7 +365,7 @@ static int pxa2xx_mfp_suspend(struct sys_device *d, pm_message_t state)
 	return 0;
 }
 
-static int pxa2xx_mfp_resume(struct sys_device *d)
+static void pxa2xx_mfp_resume(void)
 {
 	int i;
 
@@ -376,15 +376,13 @@ static int pxa2xx_mfp_resume(struct sys_device *d)
 		PGSR(i) = saved_pgsr[i];
 	}
 	PSSR = PSSR_RDH | PSSR_PH;
-	return 0;
 }
 #else
 #define pxa2xx_mfp_suspend	NULL
 #define pxa2xx_mfp_resume	NULL
 #endif
 
-struct sysdev_class pxa2xx_mfp_sysclass = {
-	.name		= "mfp",
+struct syscore_ops pxa2xx_mfp_syscore_ops = {
 	.suspend	= pxa2xx_mfp_suspend,
 	.resume		= pxa2xx_mfp_resume,
 };
@@ -409,6 +407,6 @@ static int __init pxa2xx_mfp_init(void)
 	for (i = 0; i <= gpio_to_bank(pxa_last_gpio); i++)
 		gpdr_lpm[i] = GPDR(i * 32);
 
-	return sysdev_class_register(&pxa2xx_mfp_sysclass);
+	return 0;
 }
 postcore_initcall(pxa2xx_mfp_init);

commit 1fe8c2bcad52d16e4d31d3680b9bb536c56df3d8
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Tue Apr 27 11:14:24 2010 +0800

    [ARM] pxa: allow MFP_LPM_INPUT to be explicitly specified
    
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index e5b79210a90b..1d1419b73457 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -81,6 +81,7 @@ static int __mfp_config_gpio(unsigned gpio, unsigned long c)
 		PGSR(bank) &= ~mask;
 		is_out = 1;
 		break;
+	case MFP_LPM_INPUT:
 	case MFP_LPM_DEFAULT:
 		break;
 	default:

commit c09f431c338cf032c68ea68915f4dd85d92fd526
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Tue Apr 20 14:52:50 2010 +0800

    [ARM] pxa: allow keypad GPIOs to wakeup when configured as generic
    
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index c98b5a8c3b0f..e5b79210a90b 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -178,8 +178,17 @@ int gpio_set_wake(unsigned int gpio, unsigned int on)
 	if (!d->valid)
 		return -EINVAL;
 
-	if (d->keypad_gpio)
-		return -EINVAL;
+	/* Allow keypad GPIOs to wakeup system when
+	 * configured as generic GPIOs.
+	 */
+	if (d->keypad_gpio && (MFP_AF(d->config) == 0) &&
+	    (d->config & MFP_LPM_CAN_WAKEUP)) {
+		if (on)
+			PKWR |= d->mask;
+		else
+			PKWR &= ~d->mask;
+		return 0;
+	}
 
 	mux_taken = (PWER & d->mux_mask) & (~d->mask);
 	if (on && mux_taken)
@@ -239,21 +248,25 @@ static int pxa27x_pkwr_gpio[] = {
 int keypad_set_wake(unsigned int on)
 {
 	unsigned int i, gpio, mask = 0;
-
-	if (!on) {
-		PKWR = 0;
-		return 0;
-	}
+	struct gpio_desc *d;
 
 	for (i = 0; i < ARRAY_SIZE(pxa27x_pkwr_gpio); i++) {
 
 		gpio = pxa27x_pkwr_gpio[i];
+		d = &gpio_desc[gpio];
 
-		if (gpio_desc[gpio].config & MFP_LPM_CAN_WAKEUP)
+		/* skip if configured as generic GPIO */
+		if (MFP_AF(d->config) == 0)
+			continue;
+
+		if (d->config & MFP_LPM_CAN_WAKEUP)
 			mask |= gpio_desc[gpio].mask;
 	}
 
-	PKWR = mask;
+	if (on)
+		PKWR |= mask;
+	else
+		PKWR &= ~mask;
 	return 0;
 }
 

commit 1106143d7ab43ba07678c88c85417df219354ae8
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Mon Jan 11 21:25:15 2010 +0800

    [ARM] pxa: add MFP_LPM_KEEP_OUTPUT flag to pin config
    
    Some pins are expected to keep their last level during suspend, and
    introduce MFP_LPM_KEEP_OUTPUT for this.
    
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index cf6b720c055f..c98b5a8c3b0f 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -328,6 +328,17 @@ static int pxa2xx_mfp_suspend(struct sys_device *d, pm_message_t state)
 {
 	int i;
 
+	/* set corresponding PGSR bit of those marked MFP_LPM_KEEP_OUTPUT */
+	for (i = 0; i < pxa_last_gpio; i++) {
+		if ((gpio_desc[i].config & MFP_LPM_KEEP_OUTPUT) &&
+		    (GPDR(i) & GPIO_bit(i))) {
+			if (GPLR(i) & GPIO_bit(i))
+				PGSR(i) |= GPIO_bit(i);
+			else
+				PGSR(i) &= ~GPIO_bit(i);
+		}
+	}
+
 	for (i = 0; i <= gpio_to_bank(pxa_last_gpio); i++) {
 
 		saved_gafr[0][i] = GAFR_L(i);

commit 866bd435819df8d97767c407f8828a7a2ff971e6
Author: Timothy Clacy <tcl@phaseone.com>
Date:   Thu May 7 19:40:33 2009 +0200

    [ARM] pxa: enable GPIO receivers after configuring pins
    
    'mach-pxa' platforms currently rely on a bootloader to setup GPIO pins
    and clear RDH (to enable inputs).
    
    A kernel loaded by a 'minimal' bootloader, that doesn't touch any pins,
    will not function correctly; inputs will remain disabled, even after the
    pins are configured. The following change fixes the issue and has been
    verified on Gumstix Verdex XL6P and a custom PXA270 platform.
    
    Signed-off-by: Timothy Clacy <tcl@phaseone.com>
    Signed-off-by: Eric Miao <eric.miao@marvell.com>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index 6ae50604170d..cf6b720c055f 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -377,6 +377,9 @@ static int __init pxa2xx_mfp_init(void)
 	if (cpu_is_pxa27x())
 		pxa27x_mfp_init();
 
+	/* clear RDH bit to enable GPIO receivers after reset/sleep exit */
+	PSSR = PSSR_RDH;
+
 	/* initialize gafr_run[], pgsr_lpm[] from existing values */
 	for (i = 0; i <= gpio_to_bank(pxa_last_gpio); i++)
 		gpdr_lpm[i] = GPDR(i * 32);

commit 818bc814447a35350ae90a329133e474bf1a2bd7
Author: Daniel Ribeiro <drwyrm@gmail.com>
Date:   Sat May 2 15:05:59 2009 -0300

    [ARM] pxa: save/restore PGSR on suspend/resume.
    
    Signed-off-by: Daniel Ribeiro <drwyrm@gmail.com>
    Signed-off-by: Eric Miao <eric.miao@marvell.com>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index 7ffb91d64c39..6ae50604170d 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -322,6 +322,7 @@ static inline void pxa27x_mfp_init(void) {}
 #ifdef CONFIG_PM
 static unsigned long saved_gafr[2][4];
 static unsigned long saved_gpdr[4];
+static unsigned long saved_pgsr[4];
 
 static int pxa2xx_mfp_suspend(struct sys_device *d, pm_message_t state)
 {
@@ -332,6 +333,7 @@ static int pxa2xx_mfp_suspend(struct sys_device *d, pm_message_t state)
 		saved_gafr[0][i] = GAFR_L(i);
 		saved_gafr[1][i] = GAFR_U(i);
 		saved_gpdr[i] = GPDR(i * 32);
+		saved_pgsr[i] = PGSR(i);
 
 		GPDR(i * 32) = gpdr_lpm[i];
 	}
@@ -346,6 +348,7 @@ static int pxa2xx_mfp_resume(struct sys_device *d)
 		GAFR_L(i) = saved_gafr[0][i];
 		GAFR_U(i) = saved_gafr[1][i];
 		GPDR(i * 32) = saved_gpdr[i];
+		PGSR(i) = saved_pgsr[i];
 	}
 	PSSR = PSSR_RDH | PSSR_PH;
 	return 0;

commit 0807da5938b2d64fef7f1109fb4014de6392cbf7
Author: Eric Miao <eric.miao@marvell.com>
Date:   Wed Jan 7 18:01:51 2009 +0800

    [ARM] pxa: access GPIO registers by chip so to make it further generic
    
    Let's handle GPIOs by banks, each bank covers up to 32 GPIOs with one set
    of registers, and each set of registers start from different offsets.
    
               GPLR    GPDR    GPSR    GPCR    GRER    GFER    GEDR
     BANK 0 - 0x0000  0x000C  0x0018  0x0024  0x0030  0x003C  0x0048
     BANK 1 - 0x0004  0x0010  0x001C  0x0028  0x0034  0x0040  0x004C
     BANK 2 - 0x0008  0x0014  0x0020  0x002C  0x0038  0x0044  0x0050
    
     BANK 3 - 0x0100  0x010C  0x0118  0x0124  0x0130  0x013C  0x0148
     BANK 4 - 0x0104  0x0110  0x011C  0x0128  0x0134  0x0140  0x014C
     BANK 5 - 0x0108  0x0114  0x0120  0x012C  0x0138  0x0144  0x0150
    
     NOTE:
       BANK 3 is only available on PXA27x and later processors.
       BANK 4 and 5 are only available on PXA935
    
    1. introduce GPIO_BANK(n) for the offset base of each bank
    
    2. 'struct pxa_gpio_chip' is expanded to include IRQ edge and mask
       setings, and saved register values as well, and is dynamically
       allocated due to possible bank number ranging from 3 to 6
    
    3. all accesses to GPIO registers are made through 'regbase' within
       'pxa_gpio_chip', and register offset
    
    4. introduce several inline functions to simplify the code a bit
    
    5. change IRQ demux handler to base on gpio chips
    
    Signed-off-by: Mike Rapoport <mike@compulab.co.il>
    Signed-off-by: Eric Miao <eric.miao@marvell.com>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index 9d23b731d39b..7ffb91d64c39 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -24,8 +24,6 @@
 
 #include "generic.h"
 
-#define gpio_to_bank(gpio)	((gpio) >> 5)
-
 #define PGSR(x)		__REG2(0x40F00020, (x) << 2)
 #define __GAFR(u, x)	__REG2((u) ? 0x40E00058 : 0x40E00054, (x) << 3)
 #define GAFR_L(x)	__GAFR(0, x)

commit da065a0b3611751feefeb0f0e277cd5830056dad
Author: Eric Miao <eric.miao@marvell.com>
Date:   Tue Jan 6 18:29:01 2009 +0800

    [ARM] pxa: move GPIO register definitions into <mach/gpio.h>
    
    This makes gpio.c fully independent of pxa-regs.h (except for the
    virtual address of the registers).
    
    Signed-off-by: Mike Rapoport <mike@compulab.co.il>
    Signed-off-by: Eric Miao <eric.miao@marvell.com>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index 33626de8cbf6..9d23b731d39b 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -18,8 +18,7 @@
 #include <linux/init.h>
 #include <linux/sysdev.h>
 
-#include <mach/hardware.h>
-#include <mach/pxa-regs.h>
+#include <mach/gpio.h>
 #include <mach/pxa2xx-regs.h>
 #include <mach/mfp-pxa2xx.h>
 

commit 067455aa53a55404ded85227e87436478c2acc63
Author: Eric Miao <eric.miao@marvell.com>
Date:   Wed Nov 26 18:12:04 2008 +0800

    [ARM] pxa: add support for additional GPIOs on PXA26x
    
    Original patch from Marek Vasut, the problems with PXA26x are:
    
    1. there are additional 4 GPIOs 86,87,88,89 have their direction bits
       inverted in GPDR2, as well as their alternate function bits being
       '1' for their GPIO functionality in GAFRx
    
    2. there is no easy way to decide if the processor is a pxa26x or a
       pxa250/pxa255 at run-time, so the assumption here is the pxa26x
       will be treated as one of the pxa25x variants, and board code
       should have a better knowledge of the processor it is featured
    
    Introduce pxa26x_init_irq() for the second purpose, and treat the
    additional GPIOs > 85 on PXA25x specially.
    
    Kconfig option CONFIG_CPU_PXA26x is introduced to optimize the code
    a bit when PXA26x support isn't needed. Board config options have
    to select this to enable the support for PXA26x.
    
    __gpio_is_inverted() will be optimized way when CONFIG_CPU_PXA26x
    isn't selected.
    
    Signed-off-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Eric Miao <eric.miao@marvell.com>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index 1f2298759077..33626de8cbf6 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -38,6 +38,7 @@ struct gpio_desc {
 	unsigned	valid		: 1;
 	unsigned	can_wakeup	: 1;
 	unsigned	keypad_gpio	: 1;
+	unsigned	dir_inverted	: 1;
 	unsigned int	mask; /* bit mask in PWER or PKWR */
 	unsigned int	mux_mask; /* bit mask of muxed gpio bits, 0 if no mux */
 	unsigned long	config;
@@ -54,7 +55,7 @@ static int __mfp_config_gpio(unsigned gpio, unsigned long c)
 	int uorl = !!(gpio & 0x10); /* GAFRx_U or GAFRx_L ? */
 	int shft = (gpio & 0xf) << 1;
 	int fn = MFP_AF(c);
-	int dir = c & MFP_DIR_OUT;
+	int is_out = (c & MFP_DIR_OUT) ? 1 : 0;
 
 	if (fn > 3)
 		return -EINVAL;
@@ -68,7 +69,7 @@ static int __mfp_config_gpio(unsigned gpio, unsigned long c)
 	else
 		GAFR_U(bank) = gafr;
 
-	if (dir == MFP_DIR_OUT)
+	if (is_out ^ gpio_desc[gpio].dir_inverted)
 		GPDR(gpio) |= mask;
 	else
 		GPDR(gpio) &= ~mask;
@@ -77,11 +78,11 @@ static int __mfp_config_gpio(unsigned gpio, unsigned long c)
 	switch (c & MFP_LPM_STATE_MASK) {
 	case MFP_LPM_DRIVE_HIGH:
 		PGSR(bank) |= mask;
-		dir = MFP_DIR_OUT;
+		is_out = 1;
 		break;
 	case MFP_LPM_DRIVE_LOW:
 		PGSR(bank) &= ~mask;
-		dir = MFP_DIR_OUT;
+		is_out = 1;
 		break;
 	case MFP_LPM_DEFAULT:
 		break;
@@ -92,7 +93,7 @@ static int __mfp_config_gpio(unsigned gpio, unsigned long c)
 		break;
 	}
 
-	if (dir == MFP_DIR_OUT)
+	if (is_out ^ gpio_desc[gpio].dir_inverted)
 		gpdr_lpm[bank] |= mask;
 	else
 		gpdr_lpm[bank] &= ~mask;
@@ -106,7 +107,7 @@ static int __mfp_config_gpio(unsigned gpio, unsigned long c)
 		return -EINVAL;
 	}
 
-	if ((c & MFP_LPM_CAN_WAKEUP) && (dir == MFP_DIR_OUT)) {
+	if ((c & MFP_LPM_CAN_WAKEUP) && is_out) {
 		pr_warning("%s: output GPIO%d unable to wakeup\n",
 				__func__, gpio);
 		return -EINVAL;
@@ -221,6 +222,12 @@ static void __init pxa25x_mfp_init(void)
 		gpio_desc[i].can_wakeup = 1;
 		gpio_desc[i].mask = GPIO_bit(i);
 	}
+
+	/* PXA26x has additional 4 GPIOs (86/87/88/89) which has the
+	 * direction bit inverted in GPDR2. See PXA26x DM 4.1.1.
+	 */
+	for (i = 86; i <= pxa_last_gpio; i++)
+		gpio_desc[i].dir_inverted = 1;
 }
 #else
 static inline void pxa25x_mfp_init(void) {}

commit ddd244dd814ee3e5ef1e4872705cbec0dfced541
Author: Eric Miao <eric.miao@marvell.com>
Date:   Wed Nov 26 17:06:42 2008 +0800

    [ARM] pxa: use 'pxa_last_gpio' instead of 'gpio_nr' in mfp-pxa2xx.c
    
    The 'gpio_nr' can really be inferred by 'pxa_last_gpio', and since we
    already have that variable, remove the unnecessary 'gpio_nr' now.
    
    Also, fix the incorrect GPIO number passed in pxa27x_init_irq().
    
    Note: pxa_last_gpio should be initialized earlier, and this is true
    since it's been assigned in machine_desc->init_irq().
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index 28d10679e225..1f2298759077 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -44,7 +44,6 @@ struct gpio_desc {
 };
 
 static struct gpio_desc gpio_desc[MFP_PIN_GPIO127 + 1];
-static int gpio_nr;
 
 static unsigned long gpdr_lpm[4];
 
@@ -215,15 +214,13 @@ static void __init pxa25x_mfp_init(void)
 {
 	int i;
 
-	for (i = 0; i <= 84; i++)
+	for (i = 0; i <= pxa_last_gpio; i++)
 		gpio_desc[i].valid = 1;
 
 	for (i = 0; i <= 15; i++) {
 		gpio_desc[i].can_wakeup = 1;
 		gpio_desc[i].mask = GPIO_bit(i);
 	}
-
-	gpio_nr = 85;
 }
 #else
 static inline void pxa25x_mfp_init(void) {}
@@ -276,7 +273,7 @@ static void __init pxa27x_mfp_init(void)
 {
 	int i, gpio;
 
-	for (i = 0; i <= 120; i++) {
+	for (i = 0; i <= pxa_last_gpio; i++) {
 		/* skip GPIO2, 5, 6, 7, 8, they are not
 		 * valid pins allow configuration
 		 */
@@ -313,7 +310,6 @@ static void __init pxa27x_mfp_init(void)
 	INIT_GPIO_DESC_MUXED(WEMUX2, 53);
 	INIT_GPIO_DESC_MUXED(WEMUX2, 40);
 	INIT_GPIO_DESC_MUXED(WEMUX2, 36);
-	gpio_nr = 121;
 }
 #else
 static inline void pxa27x_mfp_init(void) {}
@@ -327,7 +323,7 @@ static int pxa2xx_mfp_suspend(struct sys_device *d, pm_message_t state)
 {
 	int i;
 
-	for (i = 0; i <= gpio_to_bank(gpio_nr); i++) {
+	for (i = 0; i <= gpio_to_bank(pxa_last_gpio); i++) {
 
 		saved_gafr[0][i] = GAFR_L(i);
 		saved_gafr[1][i] = GAFR_U(i);
@@ -342,7 +338,7 @@ static int pxa2xx_mfp_resume(struct sys_device *d)
 {
 	int i;
 
-	for (i = 0; i <= gpio_to_bank(gpio_nr); i++) {
+	for (i = 0; i <= gpio_to_bank(pxa_last_gpio); i++) {
 		GAFR_L(i) = saved_gafr[0][i];
 		GAFR_U(i) = saved_gafr[1][i];
 		GPDR(i * 32) = saved_gpdr[i];
@@ -375,7 +371,7 @@ static int __init pxa2xx_mfp_init(void)
 		pxa27x_mfp_init();
 
 	/* initialize gafr_run[], pgsr_lpm[] from existing values */
-	for (i = 0; i <= gpio_to_bank(gpio_nr); i++)
+	for (i = 0; i <= gpio_to_bank(pxa_last_gpio); i++)
 		gpdr_lpm[i] = GPDR(i * 32);
 
 	return sysdev_class_register(&pxa2xx_mfp_sysclass);

commit 9968711468570c5dc5f96c415e73cb3282e857fc
Author: Robert Jarzmik <robert.jarzmik@free.fr>
Date:   Thu Nov 13 23:30:00 2008 +0100

    [ARM] pxa: add muxed gpio wakeup sources on pxa2xx architectures
    
    PXA SoC have several GPIOs muxed on only one wakeup source.
    Add support for these wakeup sources which were missing
    in mfp core support.
    
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: Eric Miao <eric.miao@marvell.com>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index 2061c00c8ead..28d10679e225 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -39,6 +39,7 @@ struct gpio_desc {
 	unsigned	can_wakeup	: 1;
 	unsigned	keypad_gpio	: 1;
 	unsigned int	mask; /* bit mask in PWER or PKWR */
+	unsigned int	mux_mask; /* bit mask of muxed gpio bits, 0 if no mux */
 	unsigned long	config;
 };
 
@@ -169,7 +170,7 @@ void pxa2xx_mfp_set_lpm(int mfp, unsigned long lpm)
 int gpio_set_wake(unsigned int gpio, unsigned int on)
 {
 	struct gpio_desc *d;
-	unsigned long c;
+	unsigned long c, mux_taken;
 
 	if (gpio > mfp_to_gpio(MFP_PIN_GPIO127))
 		return -EINVAL;
@@ -183,9 +184,13 @@ int gpio_set_wake(unsigned int gpio, unsigned int on)
 	if (d->keypad_gpio)
 		return -EINVAL;
 
+	mux_taken = (PWER & d->mux_mask) & (~d->mask);
+	if (on && mux_taken)
+		return -EBUSY;
+
 	if (d->can_wakeup && (c & MFP_LPM_CAN_WAKEUP)) {
 		if (on) {
-			PWER |= d->mask;
+			PWER = (PWER & ~d->mux_mask) | d->mask;
 
 			if (c & MFP_LPM_EDGE_RISE)
 				PRER |= d->mask;
@@ -251,6 +256,22 @@ int keypad_set_wake(unsigned int on)
 	return 0;
 }
 
+#define PWER_WEMUX2_GPIO38	(1 << 16)
+#define PWER_WEMUX2_GPIO53	(2 << 16)
+#define PWER_WEMUX2_GPIO40	(3 << 16)
+#define PWER_WEMUX2_GPIO36	(4 << 16)
+#define PWER_WEMUX2_MASK	(7 << 16)
+#define PWER_WEMUX3_GPIO31	(1 << 19)
+#define PWER_WEMUX3_GPIO113	(2 << 19)
+#define PWER_WEMUX3_MASK	(3 << 19)
+
+#define INIT_GPIO_DESC_MUXED(mux, gpio)				\
+do {								\
+	gpio_desc[(gpio)].can_wakeup = 1;			\
+	gpio_desc[(gpio)].mask = PWER_ ## mux ## _GPIO ##gpio;	\
+	gpio_desc[(gpio)].mux_mask = PWER_ ## mux ## _MASK;	\
+} while (0)
+
 static void __init pxa27x_mfp_init(void)
 {
 	int i, gpio;
@@ -286,6 +307,12 @@ static void __init pxa27x_mfp_init(void)
 	gpio_desc[35].can_wakeup = 1;
 	gpio_desc[35].mask = PWER_WE35;
 
+	INIT_GPIO_DESC_MUXED(WEMUX3, 31);
+	INIT_GPIO_DESC_MUXED(WEMUX3, 113);
+	INIT_GPIO_DESC_MUXED(WEMUX2, 38);
+	INIT_GPIO_DESC_MUXED(WEMUX2, 53);
+	INIT_GPIO_DESC_MUXED(WEMUX2, 40);
+	INIT_GPIO_DESC_MUXED(WEMUX2, 36);
 	gpio_nr = 121;
 }
 #else

commit e7f3c60037fcad0edc0b79b8d285418246bcef40
Author: Eric Miao <eric.miao@marvell.com>
Date:   Sat Sep 27 18:07:48 2008 +0800

    [ARM] pxa: fix incorrect initialization of mfp sysdev when not pxa2xx
    
    The initialization of mfp sysdev in pxa2xx_mfp_init() shall really be
    avoided when !cpu_is_pxa2xx().
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index 3ee1f39062e9..2061c00c8ead 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -338,6 +338,9 @@ static int __init pxa2xx_mfp_init(void)
 {
 	int i;
 
+	if (!cpu_is_pxa2xx())
+		return 0;
+
 	if (cpu_is_pxa25x())
 		pxa25x_mfp_init();
 

commit 5a3d96519040f9736b9f8089e2a1e33a81a6eafe
Author: Eric Miao <eric.miao@marvell.com>
Date:   Wed Sep 3 18:06:34 2008 +0800

    [ARM] pxa: better MFP low power state support for pxa25x/pxa27x
    
    When configured as a specific low power state: MFP_LPM_DRIVE_LOW,
    MFP_LPM_DRIVE_HIGH, the corresponding GPDR register bit during
    low power mode shall be re-configured as output (if they are not
    configured so), thus the PGSRx bits can output.
    
    Create an additional low power values GPDR registers, and properly
    save/restore the GAFR + GPDR registers when doing suspend/resume.
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index 925575f10acf..3ee1f39062e9 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -25,7 +25,12 @@
 
 #include "generic.h"
 
-#define PGSR(x)		__REG2(0x40F00020, ((x) & 0x60) >> 3)
+#define gpio_to_bank(gpio)	((gpio) >> 5)
+
+#define PGSR(x)		__REG2(0x40F00020, (x) << 2)
+#define __GAFR(u, x)	__REG2((u) ? 0x40E00058 : 0x40E00054, (x) << 3)
+#define GAFR_L(x)	__GAFR(0, x)
+#define GAFR_U(x)	__GAFR(1, x)
 
 #define PWER_WE35	(1 << 24)
 
@@ -38,49 +43,59 @@ struct gpio_desc {
 };
 
 static struct gpio_desc gpio_desc[MFP_PIN_GPIO127 + 1];
+static int gpio_nr;
 
-static int __mfp_config_lpm(unsigned gpio, unsigned long lpm)
-{
-	unsigned mask = GPIO_bit(gpio);
-
-	/* low power state */
-	switch (lpm) {
-	case MFP_LPM_DRIVE_HIGH:
-		PGSR(gpio) |= mask;
-		break;
-	case MFP_LPM_DRIVE_LOW:
-		PGSR(gpio) &= ~mask;
-		break;
-	case MFP_LPM_INPUT:
-		break;
-	default:
-		pr_warning("%s: invalid low power state for GPIO%d\n",
-				__func__, gpio);
-		return -EINVAL;
-	}
-	return 0;
-}
+static unsigned long gpdr_lpm[4];
 
 static int __mfp_config_gpio(unsigned gpio, unsigned long c)
 {
 	unsigned long gafr, mask = GPIO_bit(gpio);
-	int fn;
+	int bank = gpio_to_bank(gpio);
+	int uorl = !!(gpio & 0x10); /* GAFRx_U or GAFRx_L ? */
+	int shft = (gpio & 0xf) << 1;
+	int fn = MFP_AF(c);
+	int dir = c & MFP_DIR_OUT;
 
-	fn = MFP_AF(c);
 	if (fn > 3)
 		return -EINVAL;
 
-	/* alternate function and direction */
-	gafr = GAFR(gpio) & ~(0x3 << ((gpio & 0xf) * 2));
-	GAFR(gpio) = gafr |  (fn  << ((gpio & 0xf) * 2));
+	/* alternate function and direction at run-time */
+	gafr = (uorl == 0) ? GAFR_L(bank) : GAFR_U(bank);
+	gafr = (gafr & ~(0x3 << shft)) | (fn << shft);
 
-	if (c & MFP_DIR_OUT)
+	if (uorl == 0)
+		GAFR_L(bank) = gafr;
+	else
+		GAFR_U(bank) = gafr;
+
+	if (dir == MFP_DIR_OUT)
 		GPDR(gpio) |= mask;
 	else
 		GPDR(gpio) &= ~mask;
 
-	if (__mfp_config_lpm(gpio, c & MFP_LPM_STATE_MASK))
-		return -EINVAL;
+	/* alternate function and direction at low power mode */
+	switch (c & MFP_LPM_STATE_MASK) {
+	case MFP_LPM_DRIVE_HIGH:
+		PGSR(bank) |= mask;
+		dir = MFP_DIR_OUT;
+		break;
+	case MFP_LPM_DRIVE_LOW:
+		PGSR(bank) &= ~mask;
+		dir = MFP_DIR_OUT;
+		break;
+	case MFP_LPM_DEFAULT:
+		break;
+	default:
+		/* warning and fall through, treat as MFP_LPM_DEFAULT */
+		pr_warning("%s: GPIO%d: unsupported low power mode\n",
+				__func__, gpio);
+		break;
+	}
+
+	if (dir == MFP_DIR_OUT)
+		gpdr_lpm[bank] |= mask;
+	else
+		gpdr_lpm[bank] &= ~mask;
 
 	/* give early warning if MFP_LPM_CAN_WAKEUP is set on the
 	 * configurations of those pins not able to wakeup
@@ -91,7 +106,7 @@ static int __mfp_config_gpio(unsigned gpio, unsigned long c)
 		return -EINVAL;
 	}
 
-	if ((c & MFP_LPM_CAN_WAKEUP) && (c & MFP_DIR_OUT)) {
+	if ((c & MFP_LPM_CAN_WAKEUP) && (dir == MFP_DIR_OUT)) {
 		pr_warning("%s: output GPIO%d unable to wakeup\n",
 				__func__, gpio);
 		return -EINVAL;
@@ -135,7 +150,7 @@ void pxa2xx_mfp_config(unsigned long *mfp_cfgs, int num)
 
 void pxa2xx_mfp_set_lpm(int mfp, unsigned long lpm)
 {
-	unsigned long flags;
+	unsigned long flags, c;
 	int gpio;
 
 	gpio = __mfp_validate(mfp);
@@ -143,7 +158,11 @@ void pxa2xx_mfp_set_lpm(int mfp, unsigned long lpm)
 		return;
 
 	local_irq_save(flags);
-	__mfp_config_lpm(gpio, lpm);
+
+	c = gpio_desc[gpio].config;
+	c = (c & ~MFP_LPM_STATE_MASK) | lpm;
+	__mfp_config_gpio(gpio, c);
+
 	local_irq_restore(flags);
 }
 
@@ -187,23 +206,22 @@ int gpio_set_wake(unsigned int gpio, unsigned int on)
 }
 
 #ifdef CONFIG_PXA25x
-static int __init pxa25x_mfp_init(void)
+static void __init pxa25x_mfp_init(void)
 {
 	int i;
 
-	if (cpu_is_pxa25x()) {
-		for (i = 0; i <= 84; i++)
-			gpio_desc[i].valid = 1;
+	for (i = 0; i <= 84; i++)
+		gpio_desc[i].valid = 1;
 
-		for (i = 0; i <= 15; i++) {
-			gpio_desc[i].can_wakeup = 1;
-			gpio_desc[i].mask = GPIO_bit(i);
-		}
+	for (i = 0; i <= 15; i++) {
+		gpio_desc[i].can_wakeup = 1;
+		gpio_desc[i].mask = GPIO_bit(i);
 	}
 
-	return 0;
+	gpio_nr = 85;
 }
-postcore_initcall(pxa25x_mfp_init);
+#else
+static inline void pxa25x_mfp_init(void) {}
 #endif /* CONFIG_PXA25x */
 
 #ifdef CONFIG_PXA27x
@@ -233,45 +251,103 @@ int keypad_set_wake(unsigned int on)
 	return 0;
 }
 
-static int __init pxa27x_mfp_init(void)
+static void __init pxa27x_mfp_init(void)
 {
 	int i, gpio;
 
-	if (cpu_is_pxa27x()) {
-		for (i = 0; i <= 120; i++) {
-			/* skip GPIO2, 5, 6, 7, 8, they are not
-			 * valid pins allow configuration
-			 */
-			if (i == 2 || i == 5 || i == 6 ||
-			    i == 7 || i == 8)
-				continue;
+	for (i = 0; i <= 120; i++) {
+		/* skip GPIO2, 5, 6, 7, 8, they are not
+		 * valid pins allow configuration
+		 */
+		if (i == 2 || i == 5 || i == 6 || i == 7 || i == 8)
+			continue;
 
-			gpio_desc[i].valid = 1;
-		}
+		gpio_desc[i].valid = 1;
+	}
 
-		/* Keypad GPIOs */
-		for (i = 0; i < ARRAY_SIZE(pxa27x_pkwr_gpio); i++) {
-			gpio = pxa27x_pkwr_gpio[i];
-			gpio_desc[gpio].can_wakeup = 1;
-			gpio_desc[gpio].keypad_gpio = 1;
-			gpio_desc[gpio].mask = 1 << i;
-		}
+	/* Keypad GPIOs */
+	for (i = 0; i < ARRAY_SIZE(pxa27x_pkwr_gpio); i++) {
+		gpio = pxa27x_pkwr_gpio[i];
+		gpio_desc[gpio].can_wakeup = 1;
+		gpio_desc[gpio].keypad_gpio = 1;
+		gpio_desc[gpio].mask = 1 << i;
+	}
 
-		/* Overwrite GPIO13 as a PWER wakeup source */
-		for (i = 0; i <= 15; i++) {
-			/* skip GPIO2, 5, 6, 7, 8 */
-			if (GPIO_bit(i) & 0x1e4)
-				continue;
+	/* Overwrite GPIO13 as a PWER wakeup source */
+	for (i = 0; i <= 15; i++) {
+		/* skip GPIO2, 5, 6, 7, 8 */
+		if (GPIO_bit(i) & 0x1e4)
+			continue;
 
-			gpio_desc[i].can_wakeup = 1;
-			gpio_desc[i].mask = GPIO_bit(i);
-		}
+		gpio_desc[i].can_wakeup = 1;
+		gpio_desc[i].mask = GPIO_bit(i);
+	}
+
+	gpio_desc[35].can_wakeup = 1;
+	gpio_desc[35].mask = PWER_WE35;
+
+	gpio_nr = 121;
+}
+#else
+static inline void pxa27x_mfp_init(void) {}
+#endif /* CONFIG_PXA27x */
+
+#ifdef CONFIG_PM
+static unsigned long saved_gafr[2][4];
+static unsigned long saved_gpdr[4];
+
+static int pxa2xx_mfp_suspend(struct sys_device *d, pm_message_t state)
+{
+	int i;
+
+	for (i = 0; i <= gpio_to_bank(gpio_nr); i++) {
 
-		gpio_desc[35].can_wakeup = 1;
-		gpio_desc[35].mask = PWER_WE35;
+		saved_gafr[0][i] = GAFR_L(i);
+		saved_gafr[1][i] = GAFR_U(i);
+		saved_gpdr[i] = GPDR(i * 32);
+
+		GPDR(i * 32) = gpdr_lpm[i];
 	}
+	return 0;
+}
 
+static int pxa2xx_mfp_resume(struct sys_device *d)
+{
+	int i;
+
+	for (i = 0; i <= gpio_to_bank(gpio_nr); i++) {
+		GAFR_L(i) = saved_gafr[0][i];
+		GAFR_U(i) = saved_gafr[1][i];
+		GPDR(i * 32) = saved_gpdr[i];
+	}
+	PSSR = PSSR_RDH | PSSR_PH;
 	return 0;
 }
-postcore_initcall(pxa27x_mfp_init);
-#endif /* CONFIG_PXA27x */
+#else
+#define pxa2xx_mfp_suspend	NULL
+#define pxa2xx_mfp_resume	NULL
+#endif
+
+struct sysdev_class pxa2xx_mfp_sysclass = {
+	.name		= "mfp",
+	.suspend	= pxa2xx_mfp_suspend,
+	.resume		= pxa2xx_mfp_resume,
+};
+
+static int __init pxa2xx_mfp_init(void)
+{
+	int i;
+
+	if (cpu_is_pxa25x())
+		pxa25x_mfp_init();
+
+	if (cpu_is_pxa27x())
+		pxa27x_mfp_init();
+
+	/* initialize gafr_run[], pgsr_lpm[] from existing values */
+	for (i = 0; i <= gpio_to_bank(gpio_nr); i++)
+		gpdr_lpm[i] = GPDR(i * 32);
+
+	return sysdev_class_register(&pxa2xx_mfp_sysclass);
+}
+postcore_initcall(pxa2xx_mfp_init);

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index fd4545eab803..925575f10acf 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -18,10 +18,10 @@
 #include <linux/init.h>
 #include <linux/sysdev.h>
 
-#include <asm/arch/hardware.h>
-#include <asm/arch/pxa-regs.h>
-#include <asm/arch/pxa2xx-regs.h>
-#include <asm/arch/mfp-pxa2xx.h>
+#include <mach/hardware.h>
+#include <mach/pxa-regs.h>
+#include <mach/pxa2xx-regs.h>
+#include <mach/mfp-pxa2xx.h>
 
 #include "generic.h"
 

commit 566b450c33ea43f339d54d445f4ea1ab2e021909
Author: Eric Miao <eric.miao@marvell.com>
Date:   Mon Jun 16 09:47:47 2008 +0800

    [ARM] pxa: add pxa2xx_mfp_set_lpm() to facilitate low power state change
    
    Some boards want to change low power state of pins on-the-fly, this
    function helps to facilitate that operation instead of switching
    back-n-forth between two configurations with pxa2xx_mfp_config().
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Tested-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index ed91c043471b..fd4545eab803 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -39,6 +39,28 @@ struct gpio_desc {
 
 static struct gpio_desc gpio_desc[MFP_PIN_GPIO127 + 1];
 
+static int __mfp_config_lpm(unsigned gpio, unsigned long lpm)
+{
+	unsigned mask = GPIO_bit(gpio);
+
+	/* low power state */
+	switch (lpm) {
+	case MFP_LPM_DRIVE_HIGH:
+		PGSR(gpio) |= mask;
+		break;
+	case MFP_LPM_DRIVE_LOW:
+		PGSR(gpio) &= ~mask;
+		break;
+	case MFP_LPM_INPUT:
+		break;
+	default:
+		pr_warning("%s: invalid low power state for GPIO%d\n",
+				__func__, gpio);
+		return -EINVAL;
+	}
+	return 0;
+}
+
 static int __mfp_config_gpio(unsigned gpio, unsigned long c)
 {
 	unsigned long gafr, mask = GPIO_bit(gpio);
@@ -57,21 +79,8 @@ static int __mfp_config_gpio(unsigned gpio, unsigned long c)
 	else
 		GPDR(gpio) &= ~mask;
 
-	/* low power state */
-	switch (c & MFP_LPM_STATE_MASK) {
-	case MFP_LPM_DRIVE_HIGH:
-		PGSR(gpio) |= mask;
-		break;
-	case MFP_LPM_DRIVE_LOW:
-		PGSR(gpio) &= ~mask;
-		break;
-	case MFP_LPM_INPUT:
-		break;
-	default:
-		pr_warning("%s: invalid low power state for GPIO%d\n",
-				__func__, gpio);
+	if (__mfp_config_lpm(gpio, c & MFP_LPM_STATE_MASK))
 		return -EINVAL;
-	}
 
 	/* give early warning if MFP_LPM_CAN_WAKEUP is set on the
 	 * configurations of those pins not able to wakeup
@@ -124,6 +133,20 @@ void pxa2xx_mfp_config(unsigned long *mfp_cfgs, int num)
 	}
 }
 
+void pxa2xx_mfp_set_lpm(int mfp, unsigned long lpm)
+{
+	unsigned long flags;
+	int gpio;
+
+	gpio = __mfp_validate(mfp);
+	if (gpio < 0)
+		return;
+
+	local_irq_save(flags);
+	__mfp_config_lpm(gpio, lpm);
+	local_irq_restore(flags);
+}
+
 int gpio_set_wake(unsigned int gpio, unsigned int on)
 {
 	struct gpio_desc *d;

commit 0fedb0cad6ebc00af01013b5bbe52dd596853c63
Author: Eric Miao <eric.miao@marvell.com>
Date:   Mon Jun 16 09:38:27 2008 +0800

    [ARM] pxa: introduce dedicated __mfp_validate() to check PXA2xx MFP
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Tested-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index d1cdb4ecb0b8..ed91c043471b 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -91,6 +91,18 @@ static int __mfp_config_gpio(unsigned gpio, unsigned long c)
 	return 0;
 }
 
+static inline int __mfp_validate(int mfp)
+{
+	int gpio = mfp_to_gpio(mfp);
+
+	if ((mfp > MFP_PIN_GPIO127) || !gpio_desc[gpio].valid) {
+		pr_warning("%s: GPIO%d is invalid pin\n", __func__, gpio);
+		return -1;
+	}
+
+	return gpio;
+}
+
 void pxa2xx_mfp_config(unsigned long *mfp_cfgs, int num)
 {
 	unsigned long flags;
@@ -99,13 +111,9 @@ void pxa2xx_mfp_config(unsigned long *mfp_cfgs, int num)
 
 	for (i = 0, c = mfp_cfgs; i < num; i++, c++) {
 
-		gpio = mfp_to_gpio(MFP_PIN(*c));
-
-		if (!gpio_desc[gpio].valid) {
-			pr_warning("%s: GPIO%d is invalid pin\n",
-				__func__, gpio);
+		gpio = __mfp_validate(MFP_PIN(*c));
+		if (gpio < 0)
 			continue;
-		}
 
 		local_irq_save(flags);
 

commit 0b0a9df6038752674e54e333cd247c877d29aab8
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun May 18 14:59:36 2008 +0100

    [ARM] pxa: separate out power manager and clock registers
    
    The power manager and core clock registers aren't present in PXA3
    CPUs.  Move them out of pxa-regs.h into pxa2xx-regs.h, and include
    pxa2xx-regs.h where necessary.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index 22097a1707cc..d1cdb4ecb0b8 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -20,6 +20,7 @@
 
 #include <asm/arch/hardware.h>
 #include <asm/arch/pxa-regs.h>
+#include <asm/arch/pxa2xx-regs.h>
 #include <asm/arch/mfp-pxa2xx.h>
 
 #include "generic.h"

commit c0a596d6a138ea281bed4ff3018c07c45dd245a2
Author: eric miao <eric.miao@marvell.com>
Date:   Tue Mar 11 09:46:28 2008 +0800

    [ARM] pxa: allow dynamic enable/disable of GPIO wakeup for pxa{25x,27x}
    
    Changes include:
    
    1. rename MFP_LPM_WAKEUP_ENABLE into MFP_LPM_CAN_WAKEUP to indicate
       the board capability of this pin to wakeup the system
    
    2. add gpio_set_wake() and keypad_set_wake() to allow dynamically
       enable/disable wakeup from GPIOs and keypad GPIO
    
       * these functions are currently kept in mfp-pxa2xx.c due to their
         dependency to the MFP configuration
    
    3. pxa2xx_mfp_config() only gives early warning if MFP_LPM_CAN_WAKEUP
       is set on incorrect pins
    
    So that the GPIO's wakeup capability is now decided by the following:
    
       a) processor's capability: (only those GPIOs which have dedicated
          bits within PWER/PRER/PFER can wakeup the system), this is
          initialized by pxa{25x,27x}_init_mfp()
    
       b) board design decides:
          - whether the pin is designed to wakeup the system (some of
            the GPIOs are configured as other functions, which is not
            intended to be a wakeup source), by OR'ing the pin config
            with MFP_LPM_CAN_WAKEUP
    
          - which edge the pin is designed to wakeup the system, this
            may depends on external peripherals/connections, which is
            totally board specific; this is indicated by MFP_LPM_EDGE_*
    
       c) the corresponding device's (most likely the gpio_keys.c) wakeup
          attribute:
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
index f85f681c0393..22097a1707cc 100644
--- a/arch/arm/mach-pxa/mfp-pxa2xx.c
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -28,15 +28,17 @@
 
 #define PWER_WE35	(1 << 24)
 
-static struct {
+struct gpio_desc {
 	unsigned	valid		: 1;
 	unsigned	can_wakeup	: 1;
 	unsigned	keypad_gpio	: 1;
 	unsigned int	mask; /* bit mask in PWER or PKWR */
 	unsigned long	config;
-} gpio_desc[MFP_PIN_GPIO127 + 1];
+};
+
+static struct gpio_desc gpio_desc[MFP_PIN_GPIO127 + 1];
 
-static inline int __mfp_config_gpio(unsigned gpio, unsigned long c)
+static int __mfp_config_gpio(unsigned gpio, unsigned long c)
 {
 	unsigned long gafr, mask = GPIO_bit(gpio);
 	int fn;
@@ -70,26 +72,19 @@ static inline int __mfp_config_gpio(unsigned gpio, unsigned long c)
 		return -EINVAL;
 	}
 
-	/* wakeup enabling */
-	if ((c & MFP_LPM_WAKEUP_ENABLE) == 0)
-		return 0;
-
-	if (!gpio_desc[gpio].can_wakeup || c & MFP_DIR_OUT) {
+	/* give early warning if MFP_LPM_CAN_WAKEUP is set on the
+	 * configurations of those pins not able to wakeup
+	 */
+	if ((c & MFP_LPM_CAN_WAKEUP) && !gpio_desc[gpio].can_wakeup) {
 		pr_warning("%s: GPIO%d unable to wakeup\n",
 				__func__, gpio);
 		return -EINVAL;
 	}
 
-	if (gpio_desc[gpio].keypad_gpio)
-		PKWR |= gpio_desc[gpio].mask;
-	else {
-		PWER |= gpio_desc[gpio].mask;
-
-		if (c & MFP_LPM_EDGE_RISE)
-			PRER |= gpio_desc[gpio].mask;
-
-		if (c & MFP_LPM_EDGE_FALL)
-			PFER |= gpio_desc[gpio].mask;
+	if ((c & MFP_LPM_CAN_WAKEUP) && (c & MFP_DIR_OUT)) {
+		pr_warning("%s: output GPIO%d unable to wakeup\n",
+				__func__, gpio);
+		return -EINVAL;
 	}
 
 	return 0;
@@ -120,6 +115,45 @@ void pxa2xx_mfp_config(unsigned long *mfp_cfgs, int num)
 	}
 }
 
+int gpio_set_wake(unsigned int gpio, unsigned int on)
+{
+	struct gpio_desc *d;
+	unsigned long c;
+
+	if (gpio > mfp_to_gpio(MFP_PIN_GPIO127))
+		return -EINVAL;
+
+	d = &gpio_desc[gpio];
+	c = d->config;
+
+	if (!d->valid)
+		return -EINVAL;
+
+	if (d->keypad_gpio)
+		return -EINVAL;
+
+	if (d->can_wakeup && (c & MFP_LPM_CAN_WAKEUP)) {
+		if (on) {
+			PWER |= d->mask;
+
+			if (c & MFP_LPM_EDGE_RISE)
+				PRER |= d->mask;
+			else
+				PRER &= ~d->mask;
+
+			if (c & MFP_LPM_EDGE_FALL)
+				PFER |= d->mask;
+			else
+				PFER &= ~d->mask;
+		} else {
+			PWER &= ~d->mask;
+			PRER &= ~d->mask;
+			PFER &= ~d->mask;
+		}
+	}
+	return 0;
+}
+
 #ifdef CONFIG_PXA25x
 static int __init pxa25x_mfp_init(void)
 {
@@ -141,11 +175,32 @@ postcore_initcall(pxa25x_mfp_init);
 #endif /* CONFIG_PXA25x */
 
 #ifdef CONFIG_PXA27x
-static int pxa27x_pkwr_gpio[] __initdata = {
+static int pxa27x_pkwr_gpio[] = {
 	13, 16, 17, 34, 36, 37, 38, 39, 90, 91, 93, 94,
 	95, 96, 97, 98, 99, 100, 101, 102
 };
 
+int keypad_set_wake(unsigned int on)
+{
+	unsigned int i, gpio, mask = 0;
+
+	if (!on) {
+		PKWR = 0;
+		return 0;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(pxa27x_pkwr_gpio); i++) {
+
+		gpio = pxa27x_pkwr_gpio[i];
+
+		if (gpio_desc[gpio].config & MFP_LPM_CAN_WAKEUP)
+			mask |= gpio_desc[gpio].mask;
+	}
+
+	PKWR = mask;
+	return 0;
+}
+
 static int __init pxa27x_mfp_init(void)
 {
 	int i, gpio;

commit 7facc2f9374159795af2a3f8b3e682b4ee230643
Author: eric miao <eric.miao@marvell.com>
Date:   Wed Mar 5 17:16:29 2008 +0800

    [ARM] pxa: add MFP-alike pin configuration support for pxa{25x, 27x}
    
    Pin configuration on pxa{25x,27x} has now separated from generic GPIO
    into dedicated mfp-pxa2xx.c by this patch. The name "mfp" is borrowed
    from pxa3xx and is used here to alert the difference between the two
    concepts: pin configuration and generic GPIOs.  A GPIO can be called
    a "GPIO" _only_ when the corresponding pin is configured so.
    
    A pin configuration on pxa{25x,27x} is composed of:
    
        - alternate function selection (or pin mux as commonly called)
        - low power state or sleep state
        - wakeup enabling from low power mode
    
    The following MFP_xxx bit definitions in mfp.h are re-used:
    
        - MFP_PIN(x)
        - MFP_AFx
        - MFP_LPM_DRIVE_{LOW, HIGH}
        - MFP_LPM_EDGE_*
    
    Selecting alternate function on pxa{25x, 27x} involves configuration
    of GPIO direction register GPDRx, so a new bit and MFP_DIR_{IN, OUT}
    are introduced. And pin configurations are defined by the following
    two macros:
    
        - MFP_CFG_IN  : for input alternate functions
        - MFP_CFG_OUT : for output alternate functions
    
    Every configuration should provide a low power state if it configured
    as output using MFP_CFG_OUT().  As a general guideline, the low power
    state should be decided to minimize the overall power dissipation. As
    an example, it is better to drive the pin as high level in low power
    mode if the GPIO is configured as an active low chip select.
    
    Pins configured as GPIO are defined by MFP_CFG_IN(). This is to avoid
    side effects when it is firstly configured as output.  The actual
    direction of the GPIO is configured by gpio_direction_{input, output}
    
    Wakeup enabling on pxa{25x, 27x} is actually GPIO based wakeup, thus
    the device based enable_irq_wake() mechanism is not applicable here.
    
    E.g.  invoking enable_irq_wake() with a GPIO IRQ as in the following
    code to enable OTG wakeup is by no means portable and intuitive, and
    it is valid _only_ when GPIO35 is configured as USB_P2_1:
    
        enable_irq_wake( gpio_to_irq(35) );
    
    To make things worse, not every GPIO is able to wakeup the system.
    Only a small number of them can, on either rising or falling edge,
    or when level is high (for keypad GPIOs).
    
    Thus, another new bit is introduced to indicate that the GPIO will
    wakeup the system:
    
        - MFP_LPM_WAKEUP_ENABLE
    
    The following macros can be used in platform code, and be OR'ed to
    the GPIO configuration to enable its wakeup:
    
        - WAKEUP_ON_EDGE_{RISE, FALL, BOTH}
        - WAKEUP_ON_LEVEL_HIGH
    
    The WAKEUP_ON_LEVEL_HIGH is used for keypad GPIOs _only_, there is
    no edge settings for those GPIOs.
    
    These WAKEUP_ON_* flags OR'ed on wrong GPIOs will be ignored in case
    that platform code author is careless enough.
    
    The tradeoff here is that the wakeup source is fully determined by
    the platform configuration, instead of enable_irq_wake().
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-pxa/mfp-pxa2xx.c b/arch/arm/mach-pxa/mfp-pxa2xx.c
new file mode 100644
index 000000000000..f85f681c0393
--- /dev/null
+++ b/arch/arm/mach-pxa/mfp-pxa2xx.c
@@ -0,0 +1,190 @@
+/*
+ *  linux/arch/arm/mach-pxa/mfp-pxa2xx.c
+ *
+ *  PXA2xx pin mux configuration support
+ *
+ *  The GPIOs on PXA2xx can be configured as one of many alternate
+ *  functions, this is by concept samilar to the MFP configuration
+ *  on PXA3xx,  what's more important, the low power pin state and
+ *  wakeup detection are also supported by the same framework.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sysdev.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/mfp-pxa2xx.h>
+
+#include "generic.h"
+
+#define PGSR(x)		__REG2(0x40F00020, ((x) & 0x60) >> 3)
+
+#define PWER_WE35	(1 << 24)
+
+static struct {
+	unsigned	valid		: 1;
+	unsigned	can_wakeup	: 1;
+	unsigned	keypad_gpio	: 1;
+	unsigned int	mask; /* bit mask in PWER or PKWR */
+	unsigned long	config;
+} gpio_desc[MFP_PIN_GPIO127 + 1];
+
+static inline int __mfp_config_gpio(unsigned gpio, unsigned long c)
+{
+	unsigned long gafr, mask = GPIO_bit(gpio);
+	int fn;
+
+	fn = MFP_AF(c);
+	if (fn > 3)
+		return -EINVAL;
+
+	/* alternate function and direction */
+	gafr = GAFR(gpio) & ~(0x3 << ((gpio & 0xf) * 2));
+	GAFR(gpio) = gafr |  (fn  << ((gpio & 0xf) * 2));
+
+	if (c & MFP_DIR_OUT)
+		GPDR(gpio) |= mask;
+	else
+		GPDR(gpio) &= ~mask;
+
+	/* low power state */
+	switch (c & MFP_LPM_STATE_MASK) {
+	case MFP_LPM_DRIVE_HIGH:
+		PGSR(gpio) |= mask;
+		break;
+	case MFP_LPM_DRIVE_LOW:
+		PGSR(gpio) &= ~mask;
+		break;
+	case MFP_LPM_INPUT:
+		break;
+	default:
+		pr_warning("%s: invalid low power state for GPIO%d\n",
+				__func__, gpio);
+		return -EINVAL;
+	}
+
+	/* wakeup enabling */
+	if ((c & MFP_LPM_WAKEUP_ENABLE) == 0)
+		return 0;
+
+	if (!gpio_desc[gpio].can_wakeup || c & MFP_DIR_OUT) {
+		pr_warning("%s: GPIO%d unable to wakeup\n",
+				__func__, gpio);
+		return -EINVAL;
+	}
+
+	if (gpio_desc[gpio].keypad_gpio)
+		PKWR |= gpio_desc[gpio].mask;
+	else {
+		PWER |= gpio_desc[gpio].mask;
+
+		if (c & MFP_LPM_EDGE_RISE)
+			PRER |= gpio_desc[gpio].mask;
+
+		if (c & MFP_LPM_EDGE_FALL)
+			PFER |= gpio_desc[gpio].mask;
+	}
+
+	return 0;
+}
+
+void pxa2xx_mfp_config(unsigned long *mfp_cfgs, int num)
+{
+	unsigned long flags;
+	unsigned long *c;
+	int i, gpio;
+
+	for (i = 0, c = mfp_cfgs; i < num; i++, c++) {
+
+		gpio = mfp_to_gpio(MFP_PIN(*c));
+
+		if (!gpio_desc[gpio].valid) {
+			pr_warning("%s: GPIO%d is invalid pin\n",
+				__func__, gpio);
+			continue;
+		}
+
+		local_irq_save(flags);
+
+		gpio_desc[gpio].config = *c;
+		__mfp_config_gpio(gpio, *c);
+
+		local_irq_restore(flags);
+	}
+}
+
+#ifdef CONFIG_PXA25x
+static int __init pxa25x_mfp_init(void)
+{
+	int i;
+
+	if (cpu_is_pxa25x()) {
+		for (i = 0; i <= 84; i++)
+			gpio_desc[i].valid = 1;
+
+		for (i = 0; i <= 15; i++) {
+			gpio_desc[i].can_wakeup = 1;
+			gpio_desc[i].mask = GPIO_bit(i);
+		}
+	}
+
+	return 0;
+}
+postcore_initcall(pxa25x_mfp_init);
+#endif /* CONFIG_PXA25x */
+
+#ifdef CONFIG_PXA27x
+static int pxa27x_pkwr_gpio[] __initdata = {
+	13, 16, 17, 34, 36, 37, 38, 39, 90, 91, 93, 94,
+	95, 96, 97, 98, 99, 100, 101, 102
+};
+
+static int __init pxa27x_mfp_init(void)
+{
+	int i, gpio;
+
+	if (cpu_is_pxa27x()) {
+		for (i = 0; i <= 120; i++) {
+			/* skip GPIO2, 5, 6, 7, 8, they are not
+			 * valid pins allow configuration
+			 */
+			if (i == 2 || i == 5 || i == 6 ||
+			    i == 7 || i == 8)
+				continue;
+
+			gpio_desc[i].valid = 1;
+		}
+
+		/* Keypad GPIOs */
+		for (i = 0; i < ARRAY_SIZE(pxa27x_pkwr_gpio); i++) {
+			gpio = pxa27x_pkwr_gpio[i];
+			gpio_desc[gpio].can_wakeup = 1;
+			gpio_desc[gpio].keypad_gpio = 1;
+			gpio_desc[gpio].mask = 1 << i;
+		}
+
+		/* Overwrite GPIO13 as a PWER wakeup source */
+		for (i = 0; i <= 15; i++) {
+			/* skip GPIO2, 5, 6, 7, 8 */
+			if (GPIO_bit(i) & 0x1e4)
+				continue;
+
+			gpio_desc[i].can_wakeup = 1;
+			gpio_desc[i].mask = GPIO_bit(i);
+		}
+
+		gpio_desc[35].can_wakeup = 1;
+		gpio_desc[35].mask = PWER_WE35;
+	}
+
+	return 0;
+}
+postcore_initcall(pxa27x_mfp_init);
+#endif /* CONFIG_PXA27x */
