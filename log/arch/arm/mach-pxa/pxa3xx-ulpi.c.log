commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-pxa/pxa3xx-ulpi.c b/arch/arm/mach-pxa/pxa3xx-ulpi.c
index b3e2016f24b1..4bd7da1f8657 100644
--- a/arch/arm/mach-pxa/pxa3xx-ulpi.c
+++ b/arch/arm/mach-pxa/pxa3xx-ulpi.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * linux/arch/arm/mach-pxa/pxa3xx-ulpi.c
  *
@@ -7,10 +8,6 @@
  *
  * 2010-13-07: Igor Grinberg <grinberg@compulab.co.il>
  *             initial version: pxa310 USB Host mode support
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/module.h>

commit 7a5d9a913f91775805acae18bd6bd96e36f78a48
Author: Igor Grinberg <grinberg@compulab.co.il>
Date:   Tue Dec 26 15:32:53 2017 +0200

    ARM: pxa: ulpi: fix ulpi timeout and slowpath warn
    
    Both cm-x300 and pxa3xx-ulpi use the plain clk_{en,dis}able() API.
    With the new clocking framework this results in warnings of type:
    ------------[ cut here ]------------
    WARNING: CPU: 0 PID: 1 at drivers/clk/clk.c:714 clk_core_enable+0x90/0x9c
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper Not tainted 4.15.0-rc5-cm-x300+ #15
    Hardware name: CM-X300 module
    [<c001007c>] (unwind_backtrace) from [<c000df94>] (show_stack+0x10/0x14)
    [<c000df94>] (show_stack) from [<c00199a8>] (__warn+0xd8/0x100)
    [<c00199a8>] (__warn) from [<c0019a0c>] (warn_slowpath_null+0x3c/0x48)
    [<c0019a0c>] (warn_slowpath_null) from [<c024e8c0>] (clk_core_enable+0x90/0x9c)
    [<c024e8c0>] (clk_core_enable) from [<c024ea54>] (clk_core_enable_lock+0x18/0x2c)
    [<c024ea54>] (clk_core_enable_lock) from [<c0016994>] (cm_x300_u2d_init+0x4c/0xe8)
    [<c0016994>] (cm_x300_u2d_init) from [<c00163e0>] (pxa3xx_u2d_probe+0xe0/0x244)
    [<c00163e0>] (pxa3xx_u2d_probe) from [<c0283de0>] (platform_drv_probe+0x38/0x88)
    ...
    ------------[ cut here ]------------
    and alike...
    
    And finally, it results in:
    ------------[ cut here ]------------
    pxa310_ulpi_poll: ULPI access timed out!
    OTG transceiver init failed
    ------------[ cut here ]------------
    
    It might be that disabling the warning in kernel config would also do
    the job, but IMO a better solution would be to switch to
    clk_prepare_enable() and clk_disable_unprepare() APIs.
    
    Signed-off-by: Igor Grinberg <grinberg@compulab.co.il>
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>

diff --git a/arch/arm/mach-pxa/pxa3xx-ulpi.c b/arch/arm/mach-pxa/pxa3xx-ulpi.c
index c00450764352..b3e2016f24b1 100644
--- a/arch/arm/mach-pxa/pxa3xx-ulpi.c
+++ b/arch/arm/mach-pxa/pxa3xx-ulpi.c
@@ -256,7 +256,7 @@ int pxa3xx_u2d_start_hc(struct usb_bus *host)
 	if (!u2d)
 		return 0;
 
-	clk_enable(u2d->clk);
+	clk_prepare_enable(u2d->clk);
 
 	if (cpu_is_pxa310()) {
 		pxa310_u2d_setup_otg_hc();
@@ -276,7 +276,7 @@ void pxa3xx_u2d_stop_hc(struct usb_bus *host)
 	if (cpu_is_pxa310())
 		pxa310_stop_otg_hc();
 
-	clk_disable(u2d->clk);
+	clk_disable_unprepare(u2d->clk);
 }
 EXPORT_SYMBOL_GPL(pxa3xx_u2d_stop_hc);
 

commit 6d07f1911e545e77bd57b30590742ad9517ab323
Author: Igor Grinberg <grinberg@compulab.co.il>
Date:   Tue Dec 26 14:33:51 2017 +0200

    ARM: pxa: fix static checker warning in pxa3xx-ulpi
    
    Static checker reports the following warning:
    
    arch/arm/mach-pxa/pxa3xx-ulpi.c:336 pxa3xx_u2d_probe()
    warn: did you mean to pass the address of 'u2d'
    
    Fix it by passing the correct pointer.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Igor Grinberg <grinberg@compulab.co.il>
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>

diff --git a/arch/arm/mach-pxa/pxa3xx-ulpi.c b/arch/arm/mach-pxa/pxa3xx-ulpi.c
index 60cb59a7ebd1..c00450764352 100644
--- a/arch/arm/mach-pxa/pxa3xx-ulpi.c
+++ b/arch/arm/mach-pxa/pxa3xx-ulpi.c
@@ -331,7 +331,7 @@ static int pxa3xx_u2d_probe(struct platform_device *pdev)
 			goto err_free_plat;
 	}
 
-	platform_set_drvdata(pdev, &u2d);
+	platform_set_drvdata(pdev, u2d);
 
 	return 0;
 

commit ce3de60ff92ba5e4d65f1c1ce07460795e3a6157
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Jun 3 21:46:26 2017 +0200

    ARM: pxa: Delete an error message for a failed memory allocation in pxa3xx_u2d_probe()
    
    Omit an extra message for a memory allocation failure in this function.
    
    This issue was detected by using the Coccinelle software.
    
    Link: http://events.linuxfoundation.org/sites/events/files/slides/LCJ16-Refactor_Strings-WSang_0.pdf
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>

diff --git a/arch/arm/mach-pxa/pxa3xx-ulpi.c b/arch/arm/mach-pxa/pxa3xx-ulpi.c
index 13f9909ac8bf..60cb59a7ebd1 100644
--- a/arch/arm/mach-pxa/pxa3xx-ulpi.c
+++ b/arch/arm/mach-pxa/pxa3xx-ulpi.c
@@ -287,10 +287,8 @@ static int pxa3xx_u2d_probe(struct platform_device *pdev)
 	int err;
 
 	u2d = kzalloc(sizeof(*u2d), GFP_KERNEL);
-	if (!u2d) {
-		dev_err(&pdev->dev, "failed to allocate memory\n");
+	if (!u2d)
 		return -ENOMEM;
-	}
 
 	u2d->clk = clk_get(&pdev->dev, NULL);
 	if (IS_ERR(u2d->clk)) {

commit 361f7cc7f33607489bea815f9148e8e9a13ea673
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Jun 3 21:43:11 2017 +0200

    ARM: pxa: Improve a size determination in pxa3xx_u2d_probe()
    
    Replace the specification of a data structure by a pointer dereference
    as the parameter for the operator "sizeof" to make the corresponding size
    determination a bit safer according to the Linux coding style convention.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>

diff --git a/arch/arm/mach-pxa/pxa3xx-ulpi.c b/arch/arm/mach-pxa/pxa3xx-ulpi.c
index eba595fac8ca..13f9909ac8bf 100644
--- a/arch/arm/mach-pxa/pxa3xx-ulpi.c
+++ b/arch/arm/mach-pxa/pxa3xx-ulpi.c
@@ -286,7 +286,7 @@ static int pxa3xx_u2d_probe(struct platform_device *pdev)
 	struct resource *r;
 	int err;
 
-	u2d = kzalloc(sizeof(struct pxa3xx_u2d_ulpi), GFP_KERNEL);
+	u2d = kzalloc(sizeof(*u2d), GFP_KERNEL);
 	if (!u2d) {
 		dev_err(&pdev->dev, "failed to allocate memory\n");
 		return -ENOMEM;

commit 4c25c5d2985c1db482cfe59ed9b3a07829a60ba9
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jan 30 10:45:33 2015 +0100

    ARM: pxa: make more mach/*.h files local
    
    Lots of header files are never included outside of a mach-pxa
    directory and do not need to be made visible in include/mach,
    so let's just move them all down one level.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-pxa/pxa3xx-ulpi.c b/arch/arm/mach-pxa/pxa3xx-ulpi.c
index 1c85275cb768..eba595fac8ca 100644
--- a/arch/arm/mach-pxa/pxa3xx-ulpi.c
+++ b/arch/arm/mach-pxa/pxa3xx-ulpi.c
@@ -26,7 +26,7 @@
 #include <linux/usb/otg.h>
 
 #include <mach/hardware.h>
-#include <mach/regs-u2d.h>
+#include "regs-u2d.h"
 #include <linux/platform_data/usb-pxa3xx-ulpi.h>
 
 struct pxa3xx_u2d_ulpi {

commit e6b5be2be4e30037eb551e0ed09dd97bd00d85d3
Merge: 37da7bbbe84f f1c488a78d9f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 16:10:09 2014 -0800

    Merge tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core update from Greg KH:
     "Here's the set of driver core patches for 3.19-rc1.
    
      They are dominated by the removal of the .owner field in platform
      drivers.  They touch a lot of files, but they are "simple" changes,
      just removing a line in a structure.
    
      Other than that, a few minor driver core and debugfs changes.  There
      are some ath9k patches coming in through this tree that have been
      acked by the wireless maintainers as they relied on the debugfs
      changes.
    
      Everything has been in linux-next for a while"
    
    * tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (324 commits)
      Revert "ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries"
      fs: debugfs: add forward declaration for struct device type
      firmware class: Deletion of an unnecessary check before the function call "vunmap"
      firmware loader: fix hung task warning dump
      devcoredump: provide a one-way disable function
      device: Add dev_<level>_once variants
      ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries
      ath: use seq_file api for ath9k debugfs files
      debugfs: add helper function to create device related seq_file
      drivers/base: cacheinfo: remove noisy error boot message
      Revert "core: platform: add warning if driver has no owner"
      drivers: base: support cpu cache information interface to userspace via sysfs
      drivers: base: add cpu_device_create to support per-cpu devices
      topology: replace custom attribute macros with standard DEVICE_ATTR*
      cpumask: factor out show_cpumap into separate helper function
      driver core: Fix unbalanced device reference in drivers_probe
      driver core: fix race with userland in device_add()
      sysfs/kernfs: make read requests on pre-alloc files use the buffer.
      sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
      fs: sysfs: return EGBIG on write if offset is larger than file size
      ...

commit 7b472ac75689af196d868b3f2322edb44b8096d3
Author: Joe Perches <joe@perches.com>
Date:   Sat Sep 13 11:31:18 2014 -0700

    arm: mach-pxa: Convert pr_warning to pr_warn
    
    Use the more common pr_warn.
    
    Other miscellanea:
    
    o Coalesce formats
    o Realign arguments
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Robert Jarzmik <robert.jarzmik@free.fr>

diff --git a/arch/arm/mach-pxa/pxa3xx-ulpi.c b/arch/arm/mach-pxa/pxa3xx-ulpi.c
index e329ccefd364..614003e8b081 100644
--- a/arch/arm/mach-pxa/pxa3xx-ulpi.c
+++ b/arch/arm/mach-pxa/pxa3xx-ulpi.c
@@ -74,7 +74,7 @@ static int pxa310_ulpi_poll(void)
 		cpu_relax();
 	}
 
-	pr_warning("%s: ULPI access timed out!\n", __func__);
+	pr_warn("%s: ULPI access timed out!\n", __func__);
 
 	return -ETIMEDOUT;
 }
@@ -84,7 +84,7 @@ static int pxa310_ulpi_read(struct usb_phy *otg, u32 reg)
 	int err;
 
 	if (pxa310_ulpi_get_phymode() != SYNCH) {
-		pr_warning("%s: PHY is not in SYNCH mode!\n", __func__);
+		pr_warn("%s: PHY is not in SYNCH mode!\n", __func__);
 		return -EBUSY;
 	}
 
@@ -101,7 +101,7 @@ static int pxa310_ulpi_read(struct usb_phy *otg, u32 reg)
 static int pxa310_ulpi_write(struct usb_phy *otg, u32 val, u32 reg)
 {
 	if (pxa310_ulpi_get_phymode() != SYNCH) {
-		pr_warning("%s: PHY is not in SYNCH mode!\n", __func__);
+		pr_warn("%s: PHY is not in SYNCH mode!\n", __func__);
 		return -EBUSY;
 	}
 

commit a961f40ee16c5c1cae338e0734d054a98f24d7b7
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:05 2014 +0200

    ARM: mach-pxa: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/arch/arm/mach-pxa/pxa3xx-ulpi.c b/arch/arm/mach-pxa/pxa3xx-ulpi.c
index e329ccefd364..4ced61afc7f5 100644
--- a/arch/arm/mach-pxa/pxa3xx-ulpi.c
+++ b/arch/arm/mach-pxa/pxa3xx-ulpi.c
@@ -379,7 +379,6 @@ static int pxa3xx_u2d_remove(struct platform_device *pdev)
 static struct platform_driver pxa3xx_u2d_ulpi_driver = {
         .driver		= {
                 .name   = "pxa3xx-u2d",
-		.owner	= THIS_MODULE,
         },
         .probe          = pxa3xx_u2d_probe,
         .remove         = pxa3xx_u2d_remove,

commit 6ed68a6d83e4497dc33581ccc82b4fa3e7e8226d
Author: Srinivas Kandagatla <srinivas.kandagatla@st.com>
Date:   Fri Oct 12 08:11:20 2012 +0100

    ARM: pxa: use module_platform_driver macro
    
    This patch removes some code duplication by using
    module_platform_driver.
    
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@st.com>
    Acked-by: Igor Grinberg <grinberg@compulab.co.il>
    Signed-off-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-pxa/pxa3xx-ulpi.c b/arch/arm/mach-pxa/pxa3xx-ulpi.c
index 7dbe3ccf1993..e329ccefd364 100644
--- a/arch/arm/mach-pxa/pxa3xx-ulpi.c
+++ b/arch/arm/mach-pxa/pxa3xx-ulpi.c
@@ -384,18 +384,7 @@ static struct platform_driver pxa3xx_u2d_ulpi_driver = {
         .probe          = pxa3xx_u2d_probe,
         .remove         = pxa3xx_u2d_remove,
 };
-
-static int pxa3xx_u2d_ulpi_init(void)
-{
-	return platform_driver_register(&pxa3xx_u2d_ulpi_driver);
-}
-module_init(pxa3xx_u2d_ulpi_init);
-
-static void __exit pxa3xx_u2d_ulpi_exit(void)
-{
-	platform_driver_unregister(&pxa3xx_u2d_ulpi_driver);
-}
-module_exit(pxa3xx_u2d_ulpi_exit);
+module_platform_driver(pxa3xx_u2d_ulpi_driver);
 
 MODULE_DESCRIPTION("PXA3xx U2D ULPI driver");
 MODULE_AUTHOR("Igor Grinberg");

commit 293b2da1b61136813fc2764f43304c66ff8040e9
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Aug 24 15:16:48 2012 +0200

    ARM: pxa: move platform_data definitions
    
    Platform data for device drivers should be defined in
    include/linux/platform_data/*.h, not in the architecture
    and platform specific directories.
    
    This moves such data out of the pxa include directories
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Acked-by: Igor Grinberg <grinberg@compulab.co.il>
    Acked-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: Marek Vasut <marex@denx.de>
    Acked-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Acked-by: Paul Parsons <lost.distance@yahoo.com>
    Acked-by: Vinod Koul <vinod.koul@linux.intel.com>
    Acked-By: Stefan Schmidt <stefan@openezx.org>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: Daniel Ribeiro <drwyrm@gmail.com>
    Cc: Harald Welte <laforge@openezx.org>
    Cc: Philipp Zabel <philipp.zabel@gmail.com>
    Cc: Tomas Cech <sleep_walker@suse.cz>
    Cc: Sergey Lapin <slapin@ossfans.org>
    Cc: Jonathan Cameron <jic23@cam.ac.uk>
    Cc: Dan Williams <djbw@fb.com>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Chris Ball <cjb@laptop.org>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Samuel Ortiz <samuel@sortiz.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Florian Tobias Schandinat <FlorianSchandinat@gmx.de>
    Cc: Liam Girdwood <lrg@ti.com>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Cc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Cc: openezx-devel@lists.openezx.org

diff --git a/arch/arm/mach-pxa/pxa3xx-ulpi.c b/arch/arm/mach-pxa/pxa3xx-ulpi.c
index 5ead6d480c6d..7dbe3ccf1993 100644
--- a/arch/arm/mach-pxa/pxa3xx-ulpi.c
+++ b/arch/arm/mach-pxa/pxa3xx-ulpi.c
@@ -27,7 +27,7 @@
 
 #include <mach/hardware.h>
 #include <mach/regs-u2d.h>
-#include <mach/pxa3xx-u2d.h>
+#include <linux/platform_data/usb-pxa3xx-ulpi.h>
 
 struct pxa3xx_u2d_ulpi {
 	struct clk		*clk;

commit 6e13c6505cdff9766d5268ffb8c972c1a2f996e6
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon Feb 13 13:24:20 2012 +0200

    usb: otg: Convert all users to pass struct usb_otg for OTG functions
    
    This changes the otg functions so that they receive struct
    otg instead of struct usb_phy as parameter and
    converts all users of these functions to pass the otg member
    of their usb_phy.
    
    Includes fixes to IMX code from Sascha Hauer.
    
    [ balbi@ti.com : fixed a compile warning on ehci-mv.c ]
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Igor Grinberg <grinberg@compulab.co.il>
    Acked-by: Pavankumar Kondeti <pkondeti@codeaurora.org>
    Acked-by: Li Yang <leoli@freescale.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Reviewed-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/arch/arm/mach-pxa/pxa3xx-ulpi.c b/arch/arm/mach-pxa/pxa3xx-ulpi.c
index a13f33565623..5ead6d480c6d 100644
--- a/arch/arm/mach-pxa/pxa3xx-ulpi.c
+++ b/arch/arm/mach-pxa/pxa3xx-ulpi.c
@@ -145,13 +145,13 @@ static int pxa310_start_otg_host_transcvr(struct usb_bus *host)
 		return err;
 	}
 
-	err = otg_set_vbus(u2d->otg, 1);
+	err = otg_set_vbus(u2d->otg->otg, 1);
 	if (err) {
 		pr_err("OTG transceiver VBUS set failed");
 		return err;
 	}
 
-	err = otg_set_host(u2d->otg, host);
+	err = otg_set_host(u2d->otg->otg, host);
 	if (err)
 		pr_err("OTG transceiver Host mode set failed");
 
@@ -189,8 +189,8 @@ static void pxa310_stop_otg_hc(void)
 {
 	pxa310_otg_transceiver_rtsm();
 
-	otg_set_host(u2d->otg, NULL);
-	otg_set_vbus(u2d->otg, 0);
+	otg_set_host(u2d->otg->otg, NULL);
+	otg_set_vbus(u2d->otg->otg, 0);
 	usb_phy_shutdown(u2d->otg);
 }
 

commit 298b083cf9dd2efd9bb7020107ab0077135051e0
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon Feb 13 13:24:13 2012 +0200

    usb: otg: ulpi: Start using struct usb_otg
    
    Use struct usb_otg members with OTG specific functions instead
    of usb_phy members.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Igor Grinberg <grinberg@compulab.co.il>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Reviewed-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/arch/arm/mach-pxa/pxa3xx-ulpi.c b/arch/arm/mach-pxa/pxa3xx-ulpi.c
index 960d0ac50418..a13f33565623 100644
--- a/arch/arm/mach-pxa/pxa3xx-ulpi.c
+++ b/arch/arm/mach-pxa/pxa3xx-ulpi.c
@@ -111,7 +111,7 @@ static int pxa310_ulpi_write(struct usb_phy *otg, u32 val, u32 reg)
 	return pxa310_ulpi_poll();
 }
 
-struct otg_io_access_ops pxa310_ulpi_access_ops = {
+struct usb_phy_io_ops pxa310_ulpi_access_ops = {
 	.read	= pxa310_ulpi_read,
 	.write	= pxa310_ulpi_write,
 };
@@ -139,7 +139,7 @@ static int pxa310_start_otg_host_transcvr(struct usb_bus *host)
 
 	pxa310_otg_transceiver_rtsm();
 
-	err = otg_init(u2d->otg);
+	err = usb_phy_init(u2d->otg);
 	if (err) {
 		pr_err("OTG transceiver init failed");
 		return err;
@@ -191,7 +191,7 @@ static void pxa310_stop_otg_hc(void)
 
 	otg_set_host(u2d->otg, NULL);
 	otg_set_vbus(u2d->otg, 0);
-	otg_shutdown(u2d->otg);
+	usb_phy_shutdown(u2d->otg);
 }
 
 static void pxa310_u2d_setup_otg_hc(void)

commit 8675381109b0eb1c948a423c2b35e3f4509cb25e
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Mon Feb 13 13:24:02 2012 +0200

    usb: otg: Rename otg_transceiver to usb_phy
    
    This is the first step in separating USB transceivers from
    USB OTG utilities.
    
    Includes fixes to IMX code from Sascha Hauer.
    
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Pavankumar Kondeti <pkondeti@codeaurora.org>
    Acked-by: Li Yang <leoli@freescale.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Igor Grinberg <grinberg@compulab.co.il>
    Reviewed-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/arch/arm/mach-pxa/pxa3xx-ulpi.c b/arch/arm/mach-pxa/pxa3xx-ulpi.c
index e28dfb88827f..960d0ac50418 100644
--- a/arch/arm/mach-pxa/pxa3xx-ulpi.c
+++ b/arch/arm/mach-pxa/pxa3xx-ulpi.c
@@ -33,7 +33,7 @@ struct pxa3xx_u2d_ulpi {
 	struct clk		*clk;
 	void __iomem		*mmio_base;
 
-	struct otg_transceiver	*otg;
+	struct usb_phy		*otg;
 	unsigned int		ulpi_mode;
 };
 
@@ -79,7 +79,7 @@ static int pxa310_ulpi_poll(void)
 	return -ETIMEDOUT;
 }
 
-static int pxa310_ulpi_read(struct otg_transceiver *otg, u32 reg)
+static int pxa310_ulpi_read(struct usb_phy *otg, u32 reg)
 {
 	int err;
 
@@ -98,7 +98,7 @@ static int pxa310_ulpi_read(struct otg_transceiver *otg, u32 reg)
 	return u2d_readl(U2DOTGUCR) & U2DOTGUCR_RDATA;
 }
 
-static int pxa310_ulpi_write(struct otg_transceiver *otg, u32 val, u32 reg)
+static int pxa310_ulpi_write(struct usb_phy *otg, u32 val, u32 reg)
 {
 	if (pxa310_ulpi_get_phymode() != SYNCH) {
 		pr_warning("%s: PHY is not in SYNCH mode!\n", __func__);

commit 145580388b43b4ad549d0621f42bed4e3960537e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Oct 1 22:03:41 2011 +0200

    ARM: pxa: export symbols from pxa3xx-ulpi
    
    The pxa3xx_u2d_start_hc/pxa3xx_u2d_stop_hc symbols are used by the
    ohci-pxa27x driver, which can be a module.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Igor Grinberg <grinberg@compulab.co.il>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/pxa3xx-ulpi.c b/arch/arm/mach-pxa/pxa3xx-ulpi.c
index ce7168b233e2..e28dfb88827f 100644
--- a/arch/arm/mach-pxa/pxa3xx-ulpi.c
+++ b/arch/arm/mach-pxa/pxa3xx-ulpi.c
@@ -265,6 +265,7 @@ int pxa3xx_u2d_start_hc(struct usb_bus *host)
 
 	return err;
 }
+EXPORT_SYMBOL_GPL(pxa3xx_u2d_start_hc);
 
 void pxa3xx_u2d_stop_hc(struct usb_bus *host)
 {
@@ -277,6 +278,7 @@ void pxa3xx_u2d_stop_hc(struct usb_bus *host)
 
 	clk_disable(u2d->clk);
 }
+EXPORT_SYMBOL_GPL(pxa3xx_u2d_stop_hc);
 
 static int pxa3xx_u2d_probe(struct platform_device *pdev)
 {

commit a754aea25e804d0635d1871558bee5024605ff92
Author: Marek Vasut <marek.vasut@gmail.com>
Date:   Fri Sep 3 22:35:46 2010 +0200

    ARM: pxa: fix pxa3xx-u2d crash when ULPI not used
    
    In case the pxa3xx-u2d driver isn't used, probing of ohci-pxa27x will cause an
    ugly kernel crash (NULL pointer dereference in pxa3xx_u2d_start_hc(), because
    struct u2d is NULL and clk_enable() call will crash the kernel, trying to access
    it).
    
    Signed-off-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/pxa3xx-ulpi.c b/arch/arm/mach-pxa/pxa3xx-ulpi.c
index e57439e01171..ce7168b233e2 100644
--- a/arch/arm/mach-pxa/pxa3xx-ulpi.c
+++ b/arch/arm/mach-pxa/pxa3xx-ulpi.c
@@ -252,6 +252,10 @@ int pxa3xx_u2d_start_hc(struct usb_bus *host)
 {
 	int err = 0;
 
+	/* In case the PXA3xx ULPI isn't used, do nothing. */
+	if (!u2d)
+		return 0;
+
 	clk_enable(u2d->clk);
 
 	if (cpu_is_pxa310()) {
@@ -264,6 +268,10 @@ int pxa3xx_u2d_start_hc(struct usb_bus *host)
 
 void pxa3xx_u2d_stop_hc(struct usb_bus *host)
 {
+	/* In case the PXA3xx ULPI isn't used, do nothing. */
+	if (!u2d)
+		return;
+
 	if (cpu_is_pxa310())
 		pxa310_stop_otg_hc();
 

commit 69f22be7b10684ade3808de22db87c536ed135f3
Author: Igor Grinberg <grinberg@compulab.co.il>
Date:   Tue Jul 27 15:06:58 2010 +0300

    ARM: pxa: add U2D controller and ULPI driver for pxa3xx
    
    USB2.0 Device Controller (U2DC) which is found in Marvell PXA3xx.
    U2DC supports both High and Full speed modes.
    PXA320 and PXA300 U2DC supports only UTMI interface.
    PXA310 U2DC supports only ULPI interface and has the OTG capability.
    
    U2D Controller ULPI driver introduced in this patch supports only the
    PXA310 USB Host via the ULPI.
    
    Signed-off-by: Igor Grinberg <grinberg@compulab.co.il>
    Signed-off-by: Mike Rapoport <mike@compulab.co.il>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-pxa/pxa3xx-ulpi.c b/arch/arm/mach-pxa/pxa3xx-ulpi.c
new file mode 100644
index 000000000000..e57439e01171
--- /dev/null
+++ b/arch/arm/mach-pxa/pxa3xx-ulpi.c
@@ -0,0 +1,392 @@
+/*
+ * linux/arch/arm/mach-pxa/pxa3xx-ulpi.c
+ *
+ * code specific to pxa3xx aka Monahans
+ *
+ * Copyright (C) 2010 CompuLab Ltd.
+ *
+ * 2010-13-07: Igor Grinberg <grinberg@compulab.co.il>
+ *             initial version: pxa310 USB Host mode support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/usb.h>
+#include <linux/usb/otg.h>
+
+#include <mach/hardware.h>
+#include <mach/regs-u2d.h>
+#include <mach/pxa3xx-u2d.h>
+
+struct pxa3xx_u2d_ulpi {
+	struct clk		*clk;
+	void __iomem		*mmio_base;
+
+	struct otg_transceiver	*otg;
+	unsigned int		ulpi_mode;
+};
+
+static struct pxa3xx_u2d_ulpi *u2d;
+
+static inline u32 u2d_readl(u32 reg)
+{
+	return __raw_readl(u2d->mmio_base + reg);
+}
+
+static inline void u2d_writel(u32 reg, u32 val)
+{
+	__raw_writel(val, u2d->mmio_base + reg);
+}
+
+#if defined(CONFIG_PXA310_ULPI)
+enum u2d_ulpi_phy_mode {
+	SYNCH		= 0,
+	CARKIT		= (1 << 0),
+	SER_3PIN	= (1 << 1),
+	SER_6PIN	= (1 << 2),
+	LOWPOWER	= (1 << 3),
+};
+
+static inline enum u2d_ulpi_phy_mode pxa310_ulpi_get_phymode(void)
+{
+	return (u2d_readl(U2DOTGUSR) >> 28) & 0xF;
+}
+
+static int pxa310_ulpi_poll(void)
+{
+	int timeout = 50000;
+
+	while (timeout--) {
+		if (!(u2d_readl(U2DOTGUCR) & U2DOTGUCR_RUN))
+			return 0;
+
+		cpu_relax();
+	}
+
+	pr_warning("%s: ULPI access timed out!\n", __func__);
+
+	return -ETIMEDOUT;
+}
+
+static int pxa310_ulpi_read(struct otg_transceiver *otg, u32 reg)
+{
+	int err;
+
+	if (pxa310_ulpi_get_phymode() != SYNCH) {
+		pr_warning("%s: PHY is not in SYNCH mode!\n", __func__);
+		return -EBUSY;
+	}
+
+	u2d_writel(U2DOTGUCR, U2DOTGUCR_RUN | U2DOTGUCR_RNW | (reg << 16));
+	msleep(5);
+
+	err = pxa310_ulpi_poll();
+	if (err)
+		return err;
+
+	return u2d_readl(U2DOTGUCR) & U2DOTGUCR_RDATA;
+}
+
+static int pxa310_ulpi_write(struct otg_transceiver *otg, u32 val, u32 reg)
+{
+	if (pxa310_ulpi_get_phymode() != SYNCH) {
+		pr_warning("%s: PHY is not in SYNCH mode!\n", __func__);
+		return -EBUSY;
+	}
+
+	u2d_writel(U2DOTGUCR, U2DOTGUCR_RUN | (reg << 16) | (val << 8));
+	msleep(5);
+
+	return pxa310_ulpi_poll();
+}
+
+struct otg_io_access_ops pxa310_ulpi_access_ops = {
+	.read	= pxa310_ulpi_read,
+	.write	= pxa310_ulpi_write,
+};
+
+static void pxa310_otg_transceiver_rtsm(void)
+{
+	u32 u2dotgcr;
+
+	/* put PHY to sync mode */
+	u2dotgcr = u2d_readl(U2DOTGCR);
+	u2dotgcr |=  U2DOTGCR_RTSM | U2DOTGCR_UTMID;
+	u2d_writel(U2DOTGCR, u2dotgcr);
+	msleep(10);
+
+	/* setup OTG sync mode */
+	u2dotgcr = u2d_readl(U2DOTGCR);
+	u2dotgcr |= U2DOTGCR_ULAF;
+	u2dotgcr &= ~(U2DOTGCR_SMAF | U2DOTGCR_CKAF);
+	u2d_writel(U2DOTGCR, u2dotgcr);
+}
+
+static int pxa310_start_otg_host_transcvr(struct usb_bus *host)
+{
+	int err;
+
+	pxa310_otg_transceiver_rtsm();
+
+	err = otg_init(u2d->otg);
+	if (err) {
+		pr_err("OTG transceiver init failed");
+		return err;
+	}
+
+	err = otg_set_vbus(u2d->otg, 1);
+	if (err) {
+		pr_err("OTG transceiver VBUS set failed");
+		return err;
+	}
+
+	err = otg_set_host(u2d->otg, host);
+	if (err)
+		pr_err("OTG transceiver Host mode set failed");
+
+	return err;
+}
+
+static int pxa310_start_otg_hc(struct usb_bus *host)
+{
+	u32 u2dotgcr;
+	int err;
+
+	/* disable USB device controller */
+	u2d_writel(U2DCR, u2d_readl(U2DCR) & ~U2DCR_UDE);
+	u2d_writel(U2DOTGCR, u2d_readl(U2DOTGCR) | U2DOTGCR_UTMID);
+	u2d_writel(U2DOTGICR, u2d_readl(U2DOTGICR) & ~0x37F7F);
+
+	err = pxa310_start_otg_host_transcvr(host);
+	if (err)
+		return err;
+
+	/* set xceiver mode */
+	if (u2d->ulpi_mode & ULPI_IC_6PIN_SERIAL)
+		u2d_writel(U2DP3CR, u2d_readl(U2DP3CR) & ~U2DP3CR_P2SS);
+	else if (u2d->ulpi_mode & ULPI_IC_3PIN_SERIAL)
+		u2d_writel(U2DP3CR, u2d_readl(U2DP3CR) | U2DP3CR_P2SS);
+
+	/* start OTG host controller */
+	u2dotgcr = u2d_readl(U2DOTGCR) | U2DOTGCR_SMAF;
+	u2d_writel(U2DOTGCR, u2dotgcr & ~(U2DOTGCR_ULAF | U2DOTGCR_CKAF));
+
+	return 0;
+}
+
+static void pxa310_stop_otg_hc(void)
+{
+	pxa310_otg_transceiver_rtsm();
+
+	otg_set_host(u2d->otg, NULL);
+	otg_set_vbus(u2d->otg, 0);
+	otg_shutdown(u2d->otg);
+}
+
+static void pxa310_u2d_setup_otg_hc(void)
+{
+	u32 u2dotgcr;
+
+	u2dotgcr = u2d_readl(U2DOTGCR);
+	u2dotgcr |= U2DOTGCR_ULAF | U2DOTGCR_UTMID;
+	u2dotgcr &= ~(U2DOTGCR_SMAF | U2DOTGCR_CKAF);
+	u2d_writel(U2DOTGCR, u2dotgcr);
+	msleep(5);
+	u2d_writel(U2DOTGCR, u2dotgcr | U2DOTGCR_ULE);
+	msleep(5);
+	u2d_writel(U2DOTGICR, u2d_readl(U2DOTGICR) & ~0x37F7F);
+}
+
+static int pxa310_otg_init(struct pxa3xx_u2d_platform_data *pdata)
+{
+	unsigned int ulpi_mode = ULPI_OTG_DRVVBUS;
+
+	if (pdata) {
+		if (pdata->ulpi_mode & ULPI_SER_6PIN)
+			ulpi_mode |= ULPI_IC_6PIN_SERIAL;
+		else if (pdata->ulpi_mode & ULPI_SER_3PIN)
+			ulpi_mode |= ULPI_IC_3PIN_SERIAL;
+	}
+
+	u2d->ulpi_mode = ulpi_mode;
+
+	u2d->otg = otg_ulpi_create(&pxa310_ulpi_access_ops, ulpi_mode);
+	if (!u2d->otg)
+		return -ENOMEM;
+
+	u2d->otg->io_priv = u2d->mmio_base;
+
+	return 0;
+}
+
+static void pxa310_otg_exit(void)
+{
+	kfree(u2d->otg);
+}
+#else
+static inline void pxa310_u2d_setup_otg_hc(void) {}
+static inline int pxa310_start_otg_hc(struct usb_bus *host)
+{
+	return 0;
+}
+static inline void pxa310_stop_otg_hc(void) {}
+static inline int pxa310_otg_init(struct pxa3xx_u2d_platform_data *pdata)
+{
+	return 0;
+}
+static inline void pxa310_otg_exit(void) {}
+#endif /* CONFIG_PXA310_ULPI */
+
+int pxa3xx_u2d_start_hc(struct usb_bus *host)
+{
+	int err = 0;
+
+	clk_enable(u2d->clk);
+
+	if (cpu_is_pxa310()) {
+		pxa310_u2d_setup_otg_hc();
+		err = pxa310_start_otg_hc(host);
+	}
+
+	return err;
+}
+
+void pxa3xx_u2d_stop_hc(struct usb_bus *host)
+{
+	if (cpu_is_pxa310())
+		pxa310_stop_otg_hc();
+
+	clk_disable(u2d->clk);
+}
+
+static int pxa3xx_u2d_probe(struct platform_device *pdev)
+{
+	struct pxa3xx_u2d_platform_data *pdata = pdev->dev.platform_data;
+	struct resource *r;
+	int err;
+
+	u2d = kzalloc(sizeof(struct pxa3xx_u2d_ulpi), GFP_KERNEL);
+	if (!u2d) {
+		dev_err(&pdev->dev, "failed to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	u2d->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(u2d->clk)) {
+		dev_err(&pdev->dev, "failed to get u2d clock\n");
+		err = PTR_ERR(u2d->clk);
+		goto err_free_mem;
+	}
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!r) {
+		dev_err(&pdev->dev, "no IO memory resource defined\n");
+		err = -ENODEV;
+		goto err_put_clk;
+	}
+
+        r = request_mem_region(r->start, resource_size(r), pdev->name);
+        if (!r) {
+                dev_err(&pdev->dev, "failed to request memory resource\n");
+                err = -EBUSY;
+                goto err_put_clk;
+        }
+
+	u2d->mmio_base = ioremap(r->start, resource_size(r));
+	if (!u2d->mmio_base) {
+		dev_err(&pdev->dev, "ioremap() failed\n");
+		err = -ENODEV;
+		goto err_free_res;
+	}
+
+	if (pdata->init) {
+		err = pdata->init(&pdev->dev);
+		if (err)
+			goto err_free_io;
+	}
+
+	/* Only PXA310 U2D has OTG functionality */
+	if (cpu_is_pxa310()) {
+		err = pxa310_otg_init(pdata);
+		if (err)
+			goto err_free_plat;
+	}
+
+	platform_set_drvdata(pdev, &u2d);
+
+	return 0;
+
+err_free_plat:
+	if (pdata->exit)
+		pdata->exit(&pdev->dev);
+err_free_io:
+	iounmap(u2d->mmio_base);
+err_free_res:
+	release_mem_region(r->start, resource_size(r));
+err_put_clk:
+	clk_put(u2d->clk);
+err_free_mem:
+	kfree(u2d);
+	return err;
+}
+
+static int pxa3xx_u2d_remove(struct platform_device *pdev)
+{
+	struct pxa3xx_u2d_platform_data *pdata = pdev->dev.platform_data;
+	struct resource *r;
+
+	if (cpu_is_pxa310()) {
+		pxa310_stop_otg_hc();
+		pxa310_otg_exit();
+	}
+
+	if (pdata->exit)
+		pdata->exit(&pdev->dev);
+
+	platform_set_drvdata(pdev, NULL);
+	iounmap(u2d->mmio_base);
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(r->start, resource_size(r));
+
+	clk_put(u2d->clk);
+
+	kfree(u2d);
+
+	return 0;
+}
+
+static struct platform_driver pxa3xx_u2d_ulpi_driver = {
+        .driver		= {
+                .name   = "pxa3xx-u2d",
+		.owner	= THIS_MODULE,
+        },
+        .probe          = pxa3xx_u2d_probe,
+        .remove         = pxa3xx_u2d_remove,
+};
+
+static int pxa3xx_u2d_ulpi_init(void)
+{
+	return platform_driver_register(&pxa3xx_u2d_ulpi_driver);
+}
+module_init(pxa3xx_u2d_ulpi_init);
+
+static void __exit pxa3xx_u2d_ulpi_exit(void)
+{
+	platform_driver_unregister(&pxa3xx_u2d_ulpi_driver);
+}
+module_exit(pxa3xx_u2d_ulpi_exit);
+
+MODULE_DESCRIPTION("PXA3xx U2D ULPI driver");
+MODULE_AUTHOR("Igor Grinberg");
+MODULE_LICENSE("GPL v2");
