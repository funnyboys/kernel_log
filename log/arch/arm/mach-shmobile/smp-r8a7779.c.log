commit 8fc0d470bc77fa07632b471cec8207baf9704e32
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jul 6 17:15:19 2018 +0200

    ARM: shmobile: r8a7779: hide unused r8a7779_platform_cpu_kill
    
    After the cleanup in r8a7779_smp_prepare_cpus(), the only remaining caller of
    r8a7779_platform_cpu_kill() is in an ifdef, which leads to a build warning
    without CONFIG_HOTPLUG_CPU:
    
    arch/arm/mach-shmobile/smp-r8a7779.c:26:12: error: 'r8a7779_platform_cpu_kill' defined but not used [-Werror=unused-function]
    
    This moves the function inside of that #ifdef to avoid the warning.
    
    Fixes: 62f55ce683e3 ("ARM: shmobile: r8a7779: Stop powering down secondary CPUs during early boot")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index b7fe1f489b08..0ed73b650c14 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -23,17 +23,6 @@
 #define AVECR IOMEM(0xfe700040)
 #define R8A7779_SCU_BASE 0xf0000000
 
-static int r8a7779_platform_cpu_kill(unsigned int cpu)
-{
-	int ret = -EIO;
-
-	cpu = cpu_logical_map(cpu);
-	if (cpu)
-		ret = rcar_sysc_power_down_cpu(cpu);
-
-	return ret ? ret : 1;
-}
-
 static int r8a7779_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	int ret = -EIO;
@@ -55,6 +44,17 @@ static void __init r8a7779_smp_prepare_cpus(unsigned int max_cpus)
 }
 
 #ifdef CONFIG_HOTPLUG_CPU
+static int r8a7779_platform_cpu_kill(unsigned int cpu)
+{
+	int ret = -EIO;
+
+	cpu = cpu_logical_map(cpu);
+	if (cpu)
+		ret = rcar_sysc_power_down_cpu(cpu);
+
+	return ret ? ret : 1;
+}
+
 static int r8a7779_cpu_kill(unsigned int cpu)
 {
 	if (shmobile_smp_scu_cpu_kill(cpu))

commit c44e182e537492baaa37303fc0ee299222fce921
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Thu Jun 14 10:56:06 2018 +0900

    ARM: shmobile: convert to SPDX identifier
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Acked-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 0d3ec5c2b8fc..b7fe1f489b08 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -1,17 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * SMP support for R-Mobile / SH-Mobile - r8a7779 portion
  *
  * Copyright (C) 2011  Renesas Solutions Corp.
  * Copyright (C) 2011  Magnus Damm
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 #include <linux/kernel.h>
 #include <linux/init.h>

commit 16acd53b1547d3dbe3eabef5e3356674eb957ae4
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed May 30 17:25:15 2018 +0200

    ARM: shmobile: r8a7779: Remove explicit SYSC config and init
    
    If the R-Car H1 system controller is described in DT, the rcar-sysc
    driver configures SYSCIER and SYSCIMR based on the SoC-specific power
    area definitions in r8a7779-sysc.  The platform code still passed this
    information to the rcar-sysc driver, for compatibility with old DTBs
    predating commit b2df3aa487395a1b ("ARM: dts: r8a7779: Add SYSC PM
    Domains") in v4.7.  The time has come to drop backwards compatibility,
    and delegate everything to the DT enabled rcar-sysc driver.
    
    After stopping powering down secondary CPUs during early boot, there is
    no longer a need to force an early initialization of the rcar-sysc
    driver.  It will be initialized in time for secondary CPU bringup by its
    early_initcall().
    
    Hence all explicit SYSC configuration and initialization can be removed
    from the R-Car H1 platform code.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 3036f9100461..0d3ec5c2b8fc 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -60,8 +60,6 @@ static void __init r8a7779_smp_prepare_cpus(unsigned int max_cpus)
 
 	/* setup r8a7779 specific SCU bits */
 	shmobile_smp_scu_prepare_cpus(R8A7779_SCU_BASE, max_cpus);
-
-	r8a7779_pm_init();
 }
 
 #ifdef CONFIG_HOTPLUG_CPU

commit 9d65c891587ea9d0936551e432f34485c16bb71c
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed May 30 17:25:14 2018 +0200

    ARM: shmobile: r8a7779: Use rcar_sysc_power_{down,up}_cpu()
    
    The r8a7779 SMP code calls rcar_sysc_power_{down,up}() to control power
    to the SYSC power areas containing CPUs. This requires passing full CPU
    power area parameter blocks.
    
    Migrate the code to call the new rcar_sysc_power_{down,up}_cpu()
    helpers, which just take a CPU index, and use the SYSC power area
    definitions from the r8a7779-sysc driver.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index ff1e6fc0b861..3036f9100461 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -31,59 +31,24 @@
 #define AVECR IOMEM(0xfe700040)
 #define R8A7779_SCU_BASE 0xf0000000
 
-static const struct rcar_sysc_ch r8a7779_ch_cpu1 = {
-	.chan_offs = 0x40, /* PWRSR0 .. PWRER0 */
-	.chan_bit = 1, /* ARM1 */
-	.isr_bit = 1, /* ARM1 */
-};
-
-static const struct rcar_sysc_ch r8a7779_ch_cpu2 = {
-	.chan_offs = 0x40, /* PWRSR0 .. PWRER0 */
-	.chan_bit = 2, /* ARM2 */
-	.isr_bit = 2, /* ARM2 */
-};
-
-static const struct rcar_sysc_ch r8a7779_ch_cpu3 = {
-	.chan_offs = 0x40, /* PWRSR0 .. PWRER0 */
-	.chan_bit = 3, /* ARM3 */
-	.isr_bit = 3, /* ARM3 */
-};
-
-static const struct rcar_sysc_ch * const r8a7779_ch_cpu[4] = {
-	[1] = &r8a7779_ch_cpu1,
-	[2] = &r8a7779_ch_cpu2,
-	[3] = &r8a7779_ch_cpu3,
-};
-
 static int r8a7779_platform_cpu_kill(unsigned int cpu)
 {
-	const struct rcar_sysc_ch *ch = NULL;
 	int ret = -EIO;
 
 	cpu = cpu_logical_map(cpu);
-
-	if (cpu < ARRAY_SIZE(r8a7779_ch_cpu))
-		ch = r8a7779_ch_cpu[cpu];
-
-	if (ch)
-		ret = rcar_sysc_power_down(ch);
+	if (cpu)
+		ret = rcar_sysc_power_down_cpu(cpu);
 
 	return ret ? ret : 1;
 }
 
 static int r8a7779_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
-	const struct rcar_sysc_ch *ch = NULL;
-	unsigned int lcpu = cpu_logical_map(cpu);
-	int ret;
-
-	if (lcpu < ARRAY_SIZE(r8a7779_ch_cpu))
-		ch = r8a7779_ch_cpu[lcpu];
+	int ret = -EIO;
 
-	if (ch)
-		ret = rcar_sysc_power_up(ch);
-	else
-		ret = -EIO;
+	cpu = cpu_logical_map(cpu);
+	if (cpu)
+		ret = rcar_sysc_power_up_cpu(cpu);
 
 	return ret;
 }

commit 62f55ce683e3675aa83cc3e912f070aef1baeff8
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed May 30 17:25:12 2018 +0200

    ARM: shmobile: r8a7779: Stop powering down secondary CPUs during early boot
    
    At .smp_prepare_cpus() time, CPUs 1-3 are still powered down:
      - The bootloader doesn't enable CPUs 1-3,
      - Non-boot CPUs are disabled by kexec before starting the new kernel.
    
    Hence there is no need to try to power them down again, as it will fail
    silently with -EIO anyway.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index c6951ee24588..ff1e6fc0b861 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -97,11 +97,6 @@ static void __init r8a7779_smp_prepare_cpus(unsigned int max_cpus)
 	shmobile_smp_scu_prepare_cpus(R8A7779_SCU_BASE, max_cpus);
 
 	r8a7779_pm_init();
-
-	/* power off secondary CPUs */
-	r8a7779_platform_cpu_kill(1);
-	r8a7779_platform_cpu_kill(2);
-	r8a7779_platform_cpu_kill(3);
 }
 
 #ifdef CONFIG_HOTPLUG_CPU

commit be32bcbbd18213803ff24e480340d4d2cca1df4f
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Apr 20 14:02:36 2016 +0200

    soc: renesas: Move pm-rcar to drivers/soc/renesas/rcar-sysc
    
    Move the pm-rcar driver from arch/arm/mach-shmobile/ to
    drivers/soc/renesas/, and its header file to include/linux/soc/renesas/,
    so it can be shared between arm32 (R-Car H1 and Gen2) and arm64 (R-Car
    Gen3). Rename it to rcar-sysc as it's really a driver for the R-Car
    System Controller (SYSC).
    
    Kill the intermediate PM_RCAR config symbol, as it's not user
    configurable anymore, and to prepare for SoC-specific make rules.
    
    Add the missing #include <linux/types.h> to rcar-sysc.h, which was
    exposed by different include order.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index f5c31fbc10b2..c6951ee24588 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -19,13 +19,13 @@
 #include <linux/spinlock.h>
 #include <linux/io.h>
 #include <linux/delay.h>
+#include <linux/soc/renesas/rcar-sysc.h>
 
 #include <asm/cacheflush.h>
 #include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
 
 #include "common.h"
-#include "pm-rcar.h"
 #include "r8a7779.h"
 
 #define AVECR IOMEM(0xfe700040)

commit 8701d8083d1e4b9210b9cf4f420bcf7b4b36bd6d
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Jan 28 16:13:32 2016 +0100

    ARM: shmobile: Consolidate SCU mapping code
    
    Currently the SCU registers are mapped in SoC-specific code, using
    different methods, all involving the static mapping set up from
    machine_desc.map_io():
      - On emev2, a static (non-identity) mapping is used, with ioremap().
        As the static mapping uses the MT_DEVICE type, ioremap() reuses it,
        and the returned virtual address is suitable for passing to
        shmobile_smp_hook(),
      - On sh73a0 and r8a7779, a static identity mapping is used, with the
        legacy IOMEM() macro.
        As the static mapping uses the MT_DEVICE_NONSHARED type, replacing
        IOMEM() by ioremap() would create a new mapping, whose virtual
        address cannot be passed to shmobile_smp_hook().
    
    Move the mapping of the SCU registers from SoC-specific code to common
    code, always using ioremap(). To work in the absence of a static
    mapping, this requires passing the physical SCU base address to
    shmobile_smp_hook().
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 0b024a9dbd43..f5c31fbc10b2 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -94,8 +94,7 @@ static void __init r8a7779_smp_prepare_cpus(unsigned int max_cpus)
 	__raw_writel(__pa(shmobile_boot_vector), AVECR);
 
 	/* setup r8a7779 specific SCU bits */
-	shmobile_scu_base = IOMEM(R8A7779_SCU_BASE);
-	shmobile_smp_scu_prepare_cpus(max_cpus);
+	shmobile_smp_scu_prepare_cpus(R8A7779_SCU_BASE, max_cpus);
 
 	r8a7779_pm_init();
 

commit b1568d80123a7e7ab528f587ef6896b2d5413b61
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Jan 28 16:13:31 2016 +0100

    ARM: shmobile: r8a7779: Remove remainings of removed SCU boot setup code
    
    Commit 0ca2894b5a900709 ("ARM: shmobile: Use shared SCU SMP boot code on
    r8a7779") obsoleted the r8a7779-specific SCU boot code, but forgot to
    remove the setup of shmobile_boot_fn and shmobile_boot_arg, which is
    overwritten by shmobile_smp_scu_prepare_cpus().
    
    Note that shmobile_scu_base wasn't initialized at that point yet anyway.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index b854fe2095ad..0b024a9dbd43 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -92,8 +92,6 @@ static void __init r8a7779_smp_prepare_cpus(unsigned int max_cpus)
 {
 	/* Map the reset vector (in headsmp-scu.S, headsmp.S) */
 	__raw_writel(__pa(shmobile_boot_vector), AVECR);
-	shmobile_boot_fn = virt_to_phys(shmobile_boot_scu);
-	shmobile_boot_arg = (unsigned long)shmobile_scu_base;
 
 	/* setup r8a7779 specific SCU bits */
 	shmobile_scu_base = IOMEM(R8A7779_SCU_BASE);

commit 75305275a721d33ae9abfaeed2817cec8b2fee9a
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 15 10:39:53 2015 +0900

    ARM: use const and __initconst for smp_operations
    
    These smp_operations structures are not over-written, so add "const"
    qualifier and replace __initdata with __initconst.
    
    Also, add "static" where it is possible.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Moritz Fischer <moritz.fischer@ettus.com>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org> # qcom part
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: Wei Xu <xuwei5@hisilicon.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Acked-by: Matthias Brugger <matthias.bgg@gmail.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 353562b8a5ee..b854fe2095ad 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -117,7 +117,7 @@ static int r8a7779_cpu_kill(unsigned int cpu)
 }
 #endif /* CONFIG_HOTPLUG_CPU */
 
-struct smp_operations r8a7779_smp_ops  __initdata = {
+const struct smp_operations r8a7779_smp_ops  __initconst = {
 	.smp_prepare_cpus	= r8a7779_smp_prepare_cpus,
 	.smp_boot_secondary	= r8a7779_boot_secondary,
 #ifdef CONFIG_HOTPLUG_CPU

commit ff20775d189cf8f36684c88f6f95e00d21bc783c
Merge: 39aa437e18ca c99cd90d98a9
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Aug 6 10:09:08 2015 +0200

    Merge tag 'renesas-marzen-board-removal-for-v4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas into next/cleanup
    
    Renesas ARM Based SoC Marzen Board Removal for v4.3
    
    * Remove legacy r8a7779 SoC code
    * Remove legacy marzen board code
    
    * tag 'renesas-marzen-board-removal-for-v4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas:
      ARM: shmobile: r8a7779: Remove legacy SoC code
      ARM: shmobile: marzen: Remove legacy board code
      ARM: shmobile: r8a7779: Cleanup header file
      ARM: shmobile: marzen-reference: Remove C board code
      ARM: shmobile: r8a7779: Generic SMP ops
      ARM: shmobile: r8a7779: Generic CCF and timer support
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit c99cd90d98a98aa101b169e44d249e5cd71f46f2
Author: Magnus Damm <damm+renesas@opensource.se>
Date:   Thu Jul 16 16:54:03 2015 +0900

    ARM: shmobile: r8a7779: Remove legacy SoC code
    
    Now when the Marzen legacy board code is gone this patch
    removes the unused r8a7779 legacy SoC code.
    
    Signed-off-by: Magnus Damm <damm+renesas@opensource.se>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 01f792fcb220..6756ada34bc0 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -23,7 +23,6 @@
 #include <asm/cacheflush.h>
 #include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
-#include <asm/smp_twd.h>
 
 #include "common.h"
 #include "pm-rcar.h"
@@ -56,14 +55,6 @@ static struct rcar_sysc_ch *r8a7779_ch_cpu[4] = {
 	[3] = &r8a7779_ch_cpu3,
 };
 
-#if defined(CONFIG_HAVE_ARM_TWD) && !defined(CONFIG_ARCH_MULTIPLATFORM)
-static DEFINE_TWD_LOCAL_TIMER(twd_local_timer, R8A7779_SCU_BASE + 0x600, 29);
-void __init r8a7779_register_twd(void)
-{
-	twd_local_timer_register(&twd_local_timer);
-}
-#endif
-
 static int r8a7779_platform_cpu_kill(unsigned int cpu)
 {
 	struct rcar_sysc_ch *ch = NULL;

commit 5afcd90f65ac990ca08b101a0e0fd9eac4e0dcde
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Jun 4 20:22:34 2015 +0200

    ARM: shmobile: r8a7779: Make struct rcar_sysc_ch const
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 01f792fcb220..9122216df060 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -32,25 +32,25 @@
 #define AVECR IOMEM(0xfe700040)
 #define R8A7779_SCU_BASE 0xf0000000
 
-static struct rcar_sysc_ch r8a7779_ch_cpu1 = {
+static const struct rcar_sysc_ch r8a7779_ch_cpu1 = {
 	.chan_offs = 0x40, /* PWRSR0 .. PWRER0 */
 	.chan_bit = 1, /* ARM1 */
 	.isr_bit = 1, /* ARM1 */
 };
 
-static struct rcar_sysc_ch r8a7779_ch_cpu2 = {
+static const struct rcar_sysc_ch r8a7779_ch_cpu2 = {
 	.chan_offs = 0x40, /* PWRSR0 .. PWRER0 */
 	.chan_bit = 2, /* ARM2 */
 	.isr_bit = 2, /* ARM2 */
 };
 
-static struct rcar_sysc_ch r8a7779_ch_cpu3 = {
+static const struct rcar_sysc_ch r8a7779_ch_cpu3 = {
 	.chan_offs = 0x40, /* PWRSR0 .. PWRER0 */
 	.chan_bit = 3, /* ARM3 */
 	.isr_bit = 3, /* ARM3 */
 };
 
-static struct rcar_sysc_ch *r8a7779_ch_cpu[4] = {
+static const struct rcar_sysc_ch * const r8a7779_ch_cpu[4] = {
 	[1] = &r8a7779_ch_cpu1,
 	[2] = &r8a7779_ch_cpu2,
 	[3] = &r8a7779_ch_cpu3,
@@ -66,7 +66,7 @@ void __init r8a7779_register_twd(void)
 
 static int r8a7779_platform_cpu_kill(unsigned int cpu)
 {
-	struct rcar_sysc_ch *ch = NULL;
+	const struct rcar_sysc_ch *ch = NULL;
 	int ret = -EIO;
 
 	cpu = cpu_logical_map(cpu);
@@ -82,7 +82,7 @@ static int r8a7779_platform_cpu_kill(unsigned int cpu)
 
 static int r8a7779_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
-	struct rcar_sysc_ch *ch = NULL;
+	const struct rcar_sysc_ch *ch = NULL;
 	unsigned int lcpu = cpu_logical_map(cpu);
 	int ret;
 

commit fd9454ab51fa92f43ae5b7a71c42f2ee8417c2a2
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Feb 13 16:41:01 2015 -0800

    ARM: shmobile: r8a7779: Remove redundant cpu_disable implementation
    
    By default only the non-boot CPUs can be hotplugged if the
    smp_operations structure doesn't have the cpu_disable function
    pointer set. r8a7779_cpu_disable() implements the same logic,
    only non-boot CPUs can be hotplugged, so it's redundant to
    override the default behavior.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Magnus Damm <damm+renesas@opensource.se>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 9fc280e24ef4..01f792fcb220 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -124,19 +124,12 @@ static int r8a7779_cpu_kill(unsigned int cpu)
 
 	return 0;
 }
-
-static int r8a7779_cpu_disable(unsigned int cpu)
-{
-	/* only CPU1->3 have power domains, do not allow hotplug of CPU0 */
-	return cpu == 0 ? -EPERM : 0;
-}
 #endif /* CONFIG_HOTPLUG_CPU */
 
 struct smp_operations r8a7779_smp_ops  __initdata = {
 	.smp_prepare_cpus	= r8a7779_smp_prepare_cpus,
 	.smp_boot_secondary	= r8a7779_boot_secondary,
 #ifdef CONFIG_HOTPLUG_CPU
-	.cpu_disable		= r8a7779_cpu_disable,
 	.cpu_die		= shmobile_smp_scu_cpu_die,
 	.cpu_kill		= r8a7779_cpu_kill,
 #endif

commit 1dc13eee3a5c60131657482aa88c997e5fa8b50c
Author: Magnus Damm <damm+renesas@opensource.se>
Date:   Tue Dec 16 18:39:31 2014 +0900

    ARM: shmobile: r8a7779: No TWD setup in C for Multiplatform
    
    Skip the TWD setup in C for r8a7779 Multiplatform.
    We should use DTS for the TWD device anyway.
    
    Signed-off-by: Magnus Damm <damm+renesas@opensource.se>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 3f761f839043..9fc280e24ef4 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -56,7 +56,7 @@ static struct rcar_sysc_ch *r8a7779_ch_cpu[4] = {
 	[3] = &r8a7779_ch_cpu3,
 };
 
-#ifdef CONFIG_HAVE_ARM_TWD
+#if defined(CONFIG_HAVE_ARM_TWD) && !defined(CONFIG_ARCH_MULTIPLATFORM)
 static DEFINE_TWD_LOCAL_TIMER(twd_local_timer, R8A7779_SCU_BASE + 0x600, 29);
 void __init r8a7779_register_twd(void)
 {

commit 335204dfb83b3105cf4a666d1ad024917831cbdc
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Sun Oct 26 16:20:27 2014 +0200

    ARM: shmobile: Remove FSF address from copyright headers
    
    The information is already included in the COPYING file in the kernel
    sources root directory, we don't want to modify all source files when
    the FSF will move to a new address, and I'm tired of seeing the related
    checkpatch.pl warnings.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 3100e355c3fd..3f761f839043 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -12,10 +12,6 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 #include <linux/kernel.h>
 #include <linux/init.h>

commit 1b55353c9214788b0d0797a5fd4585af1557a12c
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jun 20 18:53:05 2014 +0200

    ARM: shmobile: Move r8a7779.h
    
    Change location of r8a7779.h so it can be included as "r8a7779.h"
    instead of the old style <mach/r8a7779.h>
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index c230fc0c3fef..3100e355c3fd 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -23,13 +23,15 @@
 #include <linux/spinlock.h>
 #include <linux/io.h>
 #include <linux/delay.h>
-#include <mach/r8a7779.h>
+
 #include <asm/cacheflush.h>
 #include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
 #include <asm/smp_twd.h>
+
 #include "common.h"
 #include "pm-rcar.h"
+#include "r8a7779.h"
 
 #define AVECR IOMEM(0xfe700040)
 #define R8A7779_SCU_BASE 0xf0000000

commit 585c09df3738d4f72cee36eb0b975351fd9a339a
Author: Magnus Damm <damm+renesas@opensource.se>
Date:   Tue Jun 17 16:47:53 2014 +0900

    ARM: shmobile: Move pm-rcar.h, cleanup r8a7779 case
    
    Change location of pm-rcar.h so it can be used as #include "pm-rcar.h"
    instead of the old style #include <mach/pm-rcar.h>. Also clean up
    the r8a7779 case to move some unused header file cruft into a C
    file.
    
    Signed-off-by: Magnus Damm <damm+renesas@opensource.se>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index e063cd29c30f..c230fc0c3fef 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -23,13 +23,13 @@
 #include <linux/spinlock.h>
 #include <linux/io.h>
 #include <linux/delay.h>
-#include <mach/pm-rcar.h>
 #include <mach/r8a7779.h>
 #include <asm/cacheflush.h>
 #include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
 #include <asm/smp_twd.h>
 #include "common.h"
+#include "pm-rcar.h"
 
 #define AVECR IOMEM(0xfe700040)
 #define R8A7779_SCU_BASE 0xf0000000

commit fd44aa5e570d1d8c7d361dcbf94c2b8cd25cfe92
Author: Magnus Damm <damm+renesas@opensource.se>
Date:   Tue Jun 17 16:47:37 2014 +0900

    ARM: shmobile: Move common.h
    
    Change location for common.h so it can be used as #include "common.h"
    instead of the old style #include <mach/common.h>.
    
    Signed-off-by: Magnus Damm <damm+renesas@opensource.se>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index e7a3201473d0..e063cd29c30f 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -23,13 +23,13 @@
 #include <linux/spinlock.h>
 #include <linux/io.h>
 #include <linux/delay.h>
-#include <mach/common.h>
 #include <mach/pm-rcar.h>
 #include <mach/r8a7779.h>
 #include <asm/cacheflush.h>
 #include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
 #include <asm/smp_twd.h>
+#include "common.h"
 
 #define AVECR IOMEM(0xfe700040)
 #define R8A7779_SCU_BASE 0xf0000000

commit a6557eb795edcf7832b5278a11842c4ca302f4af
Author: Magnus Damm <damm@opensource.se>
Date:   Wed Jan 15 16:43:08 2014 +0900

    ARM: shmobile: Break out R-Car SYSC PM code
    
    Break out the R-Car SYSC power management code from
    the r8a7779 SoC code. With this new shared R-Car SYSC
    code base it is possible to hook in Generation 2 SoCs
    as well.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 627c1f0d9478..e7a3201473d0 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -24,6 +24,7 @@
 #include <linux/io.h>
 #include <linux/delay.h>
 #include <mach/common.h>
+#include <mach/pm-rcar.h>
 #include <mach/r8a7779.h>
 #include <asm/cacheflush.h>
 #include <asm/smp_plat.h>
@@ -33,25 +34,25 @@
 #define AVECR IOMEM(0xfe700040)
 #define R8A7779_SCU_BASE 0xf0000000
 
-static struct r8a7779_pm_ch r8a7779_ch_cpu1 = {
+static struct rcar_sysc_ch r8a7779_ch_cpu1 = {
 	.chan_offs = 0x40, /* PWRSR0 .. PWRER0 */
 	.chan_bit = 1, /* ARM1 */
 	.isr_bit = 1, /* ARM1 */
 };
 
-static struct r8a7779_pm_ch r8a7779_ch_cpu2 = {
+static struct rcar_sysc_ch r8a7779_ch_cpu2 = {
 	.chan_offs = 0x40, /* PWRSR0 .. PWRER0 */
 	.chan_bit = 2, /* ARM2 */
 	.isr_bit = 2, /* ARM2 */
 };
 
-static struct r8a7779_pm_ch r8a7779_ch_cpu3 = {
+static struct rcar_sysc_ch r8a7779_ch_cpu3 = {
 	.chan_offs = 0x40, /* PWRSR0 .. PWRER0 */
 	.chan_bit = 3, /* ARM3 */
 	.isr_bit = 3, /* ARM3 */
 };
 
-static struct r8a7779_pm_ch *r8a7779_ch_cpu[4] = {
+static struct rcar_sysc_ch *r8a7779_ch_cpu[4] = {
 	[1] = &r8a7779_ch_cpu1,
 	[2] = &r8a7779_ch_cpu2,
 	[3] = &r8a7779_ch_cpu3,
@@ -67,7 +68,7 @@ void __init r8a7779_register_twd(void)
 
 static int r8a7779_platform_cpu_kill(unsigned int cpu)
 {
-	struct r8a7779_pm_ch *ch = NULL;
+	struct rcar_sysc_ch *ch = NULL;
 	int ret = -EIO;
 
 	cpu = cpu_logical_map(cpu);
@@ -76,14 +77,14 @@ static int r8a7779_platform_cpu_kill(unsigned int cpu)
 		ch = r8a7779_ch_cpu[cpu];
 
 	if (ch)
-		ret = r8a7779_sysc_power_down(ch);
+		ret = rcar_sysc_power_down(ch);
 
 	return ret ? ret : 1;
 }
 
 static int r8a7779_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
-	struct r8a7779_pm_ch *ch = NULL;
+	struct rcar_sysc_ch *ch = NULL;
 	unsigned int lcpu = cpu_logical_map(cpu);
 	int ret;
 
@@ -91,7 +92,7 @@ static int r8a7779_boot_secondary(unsigned int cpu, struct task_struct *idle)
 		ch = r8a7779_ch_cpu[lcpu];
 
 	if (ch)
-		ret = r8a7779_sysc_power_up(ch);
+		ret = rcar_sysc_power_up(ch);
 	else
 		ret = -EIO;
 

commit deb4928ea39c5eeef1c9f4562b5cee71f06a31ad
Author: Magnus Damm <damm@opensource.se>
Date:   Sat Sep 14 22:46:52 2013 +0900

    ARM: shmobile: Let r8a7779 rely on SCU CPU notifier
    
    Now when CPU notifiers are used for SCU boot vector
    setup shmobile_smp_scu_boot_secondary() is no longer
    needed.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 0f05e9fb722f..627c1f0d9478 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -87,10 +87,6 @@ static int r8a7779_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	unsigned int lcpu = cpu_logical_map(cpu);
 	int ret;
 
-	ret = shmobile_smp_scu_boot_secondary(cpu, idle);
-	if (ret)
-		return ret;
-
 	if (lcpu < ARRAY_SIZE(r8a7779_ch_cpu))
 		ch = r8a7779_ch_cpu[lcpu];
 

commit 25475030ec0e2c4c05f3ecb2c068f6e42944fd04
Merge: e707bb338b5c 1d33a354bbb6
Author: Olof Johansson <olof@lixom.net>
Date:   Wed Aug 28 10:04:38 2013 -0700

    Merge tag 'renesas-smp-for-v3.12' of git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas into next/renesas
    
    From Simon Horman:
    Renesas ARM based SoC SMP updates for v3.12
    
    * Per-CPU SMP boot and sleep code on SoCs that use SCU
    * Shared SCU CPU Hotplug code on r8a7779 and sh73a0 SoCs
    * Shared SCU CPU boot code on emev2, r8a7779 and sh73a0 SoCs
    
    * tag 'renesas-smp-for-v3.12' of git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas:
      ARM: shmobile: Per-CPU SMP boot / sleep code for SCU SoCs
      ARM: shmobile: Introduce per-CPU SMP boot / sleep code
      ARM: shmobile: Use shared SCU CPU Hotplug code on r8a7779
      ARM: shmobile: Use shared SCU CPU Hotplug code on sh73a0
      ARM: shmobile: Add shared SCU CPU Hotplug code
      ARM: shmobile: Use shared SCU SMP boot code on emev2
      ARM: shmobile: Use shared SCU SMP boot code on r8a7779
      ARM: shmobile: Use shared SCU SMP boot code on sh73a0
      ARM: shmobile: Introduce shared SCU SMP boot code
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit e707bb338b5c6f5859578ae6eb426a21b78b0f42
Merge: f0a108b7227c 282b583f752f
Author: Olof Johansson <olof@lixom.net>
Date:   Wed Aug 28 10:00:24 2013 -0700

    Merge tag 'renesas-cleanup3-for-v3.12' of git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas into next/renesas
    
    From Simon Horman:
    Third round of Renesas ARM based SoC cleanups for v3.12
    
    * Remove global GPIO_NR definition from sh73a0 SoC
    * Remove unnecessary nfsroot settings from bootargs of
      kzm9d and armadillo800eva
    * Rename irq initialisation functions of r8a7779 SoC
      to make them consistent with other SoCs
    * Simplify irq initialisation of r8a7740 SoC
    * Add missing __initdata annotations to bockw board, and
      r8a7790 and r8a7779 SoCs
    * Refactor time initialisation and remove shmobile_init_time.
      - This affects the following boards: kzm9g, marzen, ape6evm,
        armadillo800eva and bockw
      - This affects the following SoCs: r8a7790, r8a7779, r7a7740, r7a73a4
    * Cleanup device registration code of r8a7778 SoC
    
    * tag 'renesas-cleanup3-for-v3.12' of git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas: (45 commits)
      ARM: shmobile: sh73a0: Remove global GPIO_NR definition
      ARM: shmobile: kzm9d: remove nfsroot settings from bootargs
      ARM: shmobile: armadillo800eva: remove nfsroot settings from bootargs
      ARM: shmobile: r8a7779: move r8a7779_init_irq_xxx() to setup
      ARM: shmobile: r8a7740: move r8a7740_init_irq_of() to setup
      ARM: shmobile: bockw: add missing __initdata
      ARM: shmobile: r8a7790: add missing __initdata
      ARM: shmobile: r8a7779: add missing __initdata
      ARM: shmobile: Remove unused shmobile_init_time()
      ARM: shmobile: Use clocksource_of_init() on r8a7790
      ARM: shmobile: Use default ->init_time() on KZM9G DT ref
      ARM: shmobile: Use default ->init_time() on Marzen DT ref
      ARM: shmobile: Use default ->init_time() on APE6EVM DT ref
      ARM: shmobile: Use default ->init_time() on APE6EVM
      ARM: shmobile: Use default ->init_time() on Armadillo DT ref
      ARM: shmobile: Use default ->init_time() on Bockw DT ref
      ARM: shmobile: Use default ->init_time() on Bockw
      ARM: shmobile: Use default ->init_time() on r8a7779
      ARM: shmobile: Use default ->init_time() on r8a7778
      ARM: shmobile: Use default ->init_time() on r8a7740
      ...
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit e9e7c4fbf468e205387b21463dddacfe44da2d9a
Author: Magnus Damm <damm@opensource.se>
Date:   Wed Jul 31 16:08:09 2013 +0900

    ARM: shmobile: Use shared SCU CPU Hotplug code on r8a7779
    
    Update the r8a7779 specific CPU Hotplug code to make use of
    the recently introduced shared SCU functions. The r8a7779
    power domain hardware requires special power down handling
    at ->kill() time.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 1963d0d42afb..c159964ea56e 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -122,47 +122,14 @@ static void __init r8a7779_smp_prepare_cpus(unsigned int max_cpus)
 }
 
 #ifdef CONFIG_HOTPLUG_CPU
-static int r8a7779_scu_psr_core_disabled(int cpu)
-{
-	unsigned long mask = 3 << (cpu * 8);
-
-	if ((__raw_readl(shmobile_scu_base + 8) & mask) == mask)
-		return 1;
-
-	return 0;
-}
-
 static int r8a7779_cpu_kill(unsigned int cpu)
 {
-	int k;
-
-	/* this function is running on another CPU than the offline target,
-	 * here we need wait for shutdown code in platform_cpu_die() to
-	 * finish before asking SoC-specific code to power off the CPU core.
-	 */
-	for (k = 0; k < 1000; k++) {
-		if (r8a7779_scu_psr_core_disabled(cpu))
-			return r8a7779_platform_cpu_kill(cpu);
-
-		mdelay(1);
-	}
+	if (shmobile_smp_scu_cpu_kill(cpu))
+		return r8a7779_platform_cpu_kill(cpu);
 
 	return 0;
 }
 
-static void r8a7779_cpu_die(unsigned int cpu)
-{
-	dsb();
-	flush_cache_all();
-
-	/* disable cache coherency */
-	scu_power_mode(shmobile_scu_base, SCU_PM_POWEROFF);
-
-	/* Endless loop until power off from r8a7779_cpu_kill() */
-	while (1)
-		cpu_do_idle();
-}
-
 static int r8a7779_cpu_disable(unsigned int cpu)
 {
 	/* only CPU1->3 have power domains, do not allow hotplug of CPU0 */
@@ -174,8 +141,8 @@ struct smp_operations r8a7779_smp_ops  __initdata = {
 	.smp_prepare_cpus	= r8a7779_smp_prepare_cpus,
 	.smp_boot_secondary	= r8a7779_boot_secondary,
 #ifdef CONFIG_HOTPLUG_CPU
-	.cpu_kill		= r8a7779_cpu_kill,
-	.cpu_die		= r8a7779_cpu_die,
 	.cpu_disable		= r8a7779_cpu_disable,
+	.cpu_die		= shmobile_smp_scu_cpu_die,
+	.cpu_kill		= r8a7779_cpu_kill,
 #endif
 };

commit 0ca2894b5a9007091ad1a4d82b9f3132d4dd9410
Author: Magnus Damm <damm@opensource.se>
Date:   Wed Jul 31 16:07:31 2013 +0900

    ARM: shmobile: Use shared SCU SMP boot code on r8a7779
    
    Use shared SCU code on r8a7779 for SMP boot.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index bb3adae7de0f..1963d0d42afb 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -84,33 +84,34 @@ static int r8a7779_platform_cpu_kill(unsigned int cpu)
 static int __cpuinit r8a7779_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	struct r8a7779_pm_ch *ch = NULL;
-	int ret = -EIO;
+	unsigned int lcpu = cpu_logical_map(cpu);
+	int ret;
 
-	cpu = cpu_logical_map(cpu);
+	ret = shmobile_smp_scu_boot_secondary(cpu, idle);
+	if (ret)
+		return ret;
 
-	if (cpu < ARRAY_SIZE(r8a7779_ch_cpu))
-		ch = r8a7779_ch_cpu[cpu];
+	if (lcpu < ARRAY_SIZE(r8a7779_ch_cpu))
+		ch = r8a7779_ch_cpu[lcpu];
 
 	if (ch)
 		ret = r8a7779_sysc_power_up(ch);
+	else
+		ret = -EIO;
 
 	return ret;
 }
 
 static void __init r8a7779_smp_prepare_cpus(unsigned int max_cpus)
 {
-
-	/* setup r8a7779 specific SCU base */
-	shmobile_scu_base = IOMEM(R8A7779_SCU_BASE);
-	scu_enable(shmobile_scu_base);
-
 	/* Map the reset vector (in headsmp-scu.S, headsmp.S) */
 	__raw_writel(__pa(shmobile_boot_vector), AVECR);
 	shmobile_boot_fn = virt_to_phys(shmobile_boot_scu);
 	shmobile_boot_arg = (unsigned long)shmobile_scu_base;
 
-	/* enable cache coherency on booting CPU */
-	scu_power_mode(shmobile_scu_base, SCU_PM_NORMAL);
+	/* setup r8a7779 specific SCU bits */
+	shmobile_scu_base = IOMEM(R8A7779_SCU_BASE);
+	shmobile_smp_scu_prepare_cpus(max_cpus);
 
 	r8a7779_pm_init();
 

commit afad20105a58c06407ad9ad85c1cd9ca79d99e00
Author: Simon Horman <horms+renesas@verge.net.au>
Date:   Wed Jul 24 17:11:46 2013 +0900

    ARM: shmobile: r8a7779: Rely on DT for SMP CPU info
    
    Remove r8a7779 specific ->smp_init_cpus() callback and
    instead of relying on shmobile_smp_init_cpus() simply
    use DT for CPU core information.
    
    Based on work for the sh73a0 by Magnus Damm.
    
    Acked-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 526cfaae81c1..bb3adae7de0f 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -99,6 +99,9 @@ static int __cpuinit r8a7779_boot_secondary(unsigned int cpu, struct task_struct
 
 static void __init r8a7779_smp_prepare_cpus(unsigned int max_cpus)
 {
+
+	/* setup r8a7779 specific SCU base */
+	shmobile_scu_base = IOMEM(R8A7779_SCU_BASE);
 	scu_enable(shmobile_scu_base);
 
 	/* Map the reset vector (in headsmp-scu.S, headsmp.S) */
@@ -117,14 +120,6 @@ static void __init r8a7779_smp_prepare_cpus(unsigned int max_cpus)
 	r8a7779_platform_cpu_kill(3);
 }
 
-static void __init r8a7779_smp_init_cpus(void)
-{
-	/* setup r8a7779 specific SCU base */
-	shmobile_scu_base = IOMEM(R8A7779_SCU_BASE);
-
-	shmobile_smp_init_cpus(scu_get_core_count(shmobile_scu_base));
-}
-
 #ifdef CONFIG_HOTPLUG_CPU
 static int r8a7779_scu_psr_core_disabled(int cpu)
 {
@@ -175,7 +170,6 @@ static int r8a7779_cpu_disable(unsigned int cpu)
 #endif /* CONFIG_HOTPLUG_CPU */
 
 struct smp_operations r8a7779_smp_ops  __initdata = {
-	.smp_init_cpus		= r8a7779_smp_init_cpus,
 	.smp_prepare_cpus	= r8a7779_smp_prepare_cpus,
 	.smp_boot_secondary	= r8a7779_boot_secondary,
 #ifdef CONFIG_HOTPLUG_CPU

commit 8bd26e3a7e49af2697449bbcb7187a39dc85d672
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jun 17 15:43:14 2013 -0400

    arm: delete __cpuinit/__CPUINIT usage from all ARM users
    
    The __cpuinit type of throwaway sections might have made sense
    some time ago when RAM was more constrained, but now the savings
    do not offset the cost and complications.  For example, the fix in
    commit 5e427ec2d0 ("x86: Fix bit corruption at CPU resume time")
    is a good example of the nasty type of bugs that can be created
    with improper use of the various __init prefixes.
    
    After a discussion on LKML[1] it was decided that cpuinit should go
    the way of devinit and be phased out.  Once all the users are gone,
    we can then finally remove the macros themselves from linux/init.h.
    
    Note that some harmless section mismatch warnings may result, since
    notify_cpu_starting() and cpu_up() are arch independent (kernel/cpu.c)
    and are flagged as __cpuinit  -- so if we remove the __cpuinit from
    the arch specific callers, we will also get section mismatch warnings.
    As an intermediate step, we intend to turn the linux/init.h cpuinit
    related content into no-ops as early as possible, since that will get
    rid of these warnings.  In any case, they are temporary and harmless.
    
    This removes all the ARM uses of the __cpuinit macros from C code,
    and all __CPUINIT from assembly code.  It also had two ".previous"
    section statements that were paired off against __CPUINIT
    (aka .section ".cpuinit.text") that also get removed here.
    
    [1] https://lkml.org/lkml/2013/5/20/589
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 526cfaae81c1..9bdf810f2a87 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -81,7 +81,7 @@ static int r8a7779_platform_cpu_kill(unsigned int cpu)
 	return ret ? ret : 1;
 }
 
-static int __cpuinit r8a7779_boot_secondary(unsigned int cpu, struct task_struct *idle)
+static int r8a7779_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	struct r8a7779_pm_ch *ch = NULL;
 	int ret = -EIO;

commit af642310aaa491df6dabcca96bdf0d1b8465a834
Author: Magnus Damm <damm@opensource.se>
Date:   Mon Jun 10 18:19:56 2013 +0900

    ARM: shmobile: r8a7779 SMP with SCU boot fn and args
    
    Let r8a7779 make use of shmobile_boot_fn and shmobile_boot_arg
    together with shmobile_boot_scu and the SCU base address.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index a853bf182ed5..526cfaae81c1 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -101,8 +101,10 @@ static void __init r8a7779_smp_prepare_cpus(unsigned int max_cpus)
 {
 	scu_enable(shmobile_scu_base);
 
-	/* Map the reset vector (in headsmp-scu.S) */
-	__raw_writel(__pa(shmobile_secondary_vector_scu), AVECR);
+	/* Map the reset vector (in headsmp-scu.S, headsmp.S) */
+	__raw_writel(__pa(shmobile_boot_vector), AVECR);
+	shmobile_boot_fn = virt_to_phys(shmobile_boot_scu);
+	shmobile_boot_arg = (unsigned long)shmobile_scu_base;
 
 	/* enable cache coherency on booting CPU */
 	scu_power_mode(shmobile_scu_base, SCU_PM_NORMAL);

commit e0d20b69d3fa74a21ec363989612bddd58b930b8
Merge: 128673b3646b bc895b5987dd
Author: Olof Johansson <olof@lixom.net>
Date:   Sun Apr 28 15:06:56 2013 -0700

    Merge branch 'gic/cleanup' into next/soc
    
    Merge in the gic cleanup since it has a handful of annoying internal conflicts
    with soc development branches. All of them are delete/delete conflicts.
    
    * gic/cleanup:
      irqchip: vic: add include of linux/irq.h
      irqchip: gic: Perform the gic_secondary_init() call via CPU notifier
      irqchip: gic: Call handle_bad_irq() directly
      arm: Move chained_irq_(enter|exit) to a generic file
      arm: Move the set_handle_irq and handle_arch_irq declarations to asm/irq.h
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    
    Conflicts:
            arch/arm/mach-shmobile/smp-emev2.c
            arch/arm/mach-shmobile/smp-r8a7779.c
            arch/arm/mach-shmobile/smp-sh73a0.c
            arch/arm/mach-socfpga/platsmp.c

commit c0114709ed85a5693eb74acdfa03d94f7f12e5b8
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Mon Jan 14 18:05:37 2013 +0000

    irqchip: gic: Perform the gic_secondary_init() call via CPU notifier
    
    All the calls to gic_secondary_init() pass 0 as the first argument.
    Since this function is called on each CPU when starting, it can be done
    in a platform-independent way via a CPU notifier registered by the GIC
    code.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Tested-by: Simon Horman <horms+renesas@verge.net.au>
    Acked-by: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Tested-by: Dinh Nguyen <dinguyen@altera.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Tested-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: David Brown <davidb@codeaurora.org>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Shiraz Hashim <shiraz.hashim@st.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Barry Song <baohua.song@csr.com>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 3a4acf23edcf..994906560edd 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -23,7 +23,6 @@
 #include <linux/spinlock.h>
 #include <linux/io.h>
 #include <linux/delay.h>
-#include <linux/irqchip/arm-gic.h>
 #include <mach/common.h>
 #include <mach/r8a7779.h>
 #include <asm/smp_plat.h>
@@ -132,11 +131,6 @@ static int __maybe_unused r8a7779_cpu_kill(unsigned int cpu)
 }
 
 
-static void __cpuinit r8a7779_secondary_init(unsigned int cpu)
-{
-	gic_secondary_init(0);
-}
-
 static int __cpuinit r8a7779_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	struct r8a7779_pm_ch *ch = NULL;
@@ -186,7 +180,6 @@ static void __init r8a7779_smp_init_cpus(void)
 struct smp_operations r8a7779_smp_ops  __initdata = {
 	.smp_init_cpus		= r8a7779_smp_init_cpus,
 	.smp_prepare_cpus	= r8a7779_smp_prepare_cpus,
-	.smp_secondary_init	= r8a7779_secondary_init,
 	.smp_boot_secondary	= r8a7779_boot_secondary,
 #ifdef CONFIG_HOTPLUG_CPU
 	.cpu_kill		= r8a7779_cpu_kill,

commit fd0865c3f7054d9068007fd280681cb4ea7929a1
Author: Magnus Damm <damm@opensource.se>
Date:   Mon Feb 18 22:47:54 2013 +0900

    ARM: shmobile: Rearrange r8a7779 cpu hotplug code
    
    Update the r8a7779 SMP code and CPU Hotplug in particular
    to follow the same style as sh73a0. This means dropping
    __maybe_unused for #ifdef CONFIG_HOTPLUG_CPU.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index bdd38091dc9e..ea4535a5c4e2 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -66,16 +66,6 @@ void __init r8a7779_register_twd(void)
 }
 #endif
 
-static int r8a7779_scu_psr_core_disabled(int cpu)
-{
-	unsigned long mask = 3 << (cpu * 8);
-
-	if ((__raw_readl(shmobile_scu_base + 8) & mask) == mask)
-		return 1;
-
-	return 0;
-}
-
 static int r8a7779_platform_cpu_kill(unsigned int cpu)
 {
 	struct r8a7779_pm_ch *ch = NULL;
@@ -92,43 +82,6 @@ static int r8a7779_platform_cpu_kill(unsigned int cpu)
 	return ret ? ret : 1;
 }
 
-static int __maybe_unused r8a7779_cpu_kill(unsigned int cpu)
-{
-	int k;
-
-	/* this function is running on another CPU than the offline target,
-	 * here we need wait for shutdown code in platform_cpu_die() to
-	 * finish before asking SoC-specific code to power off the CPU core.
-	 */
-	for (k = 0; k < 1000; k++) {
-		if (r8a7779_scu_psr_core_disabled(cpu))
-			return r8a7779_platform_cpu_kill(cpu);
-
-		mdelay(1);
-	}
-
-	return 0;
-}
-
-static void __maybe_unused r8a7779_cpu_die(unsigned int cpu)
-{
-	dsb();
-	flush_cache_all();
-
-	/* disable cache coherency */
-	scu_power_mode(shmobile_scu_base, SCU_PM_POWEROFF);
-
-	/* Endless loop until power off from r8a7779_cpu_kill() */
-	while (1)
-		cpu_do_idle();
-}
-
-static int __maybe_unused r8a7779_cpu_disable(unsigned int cpu)
-{
-	/* only CPU1->3 have power domains, do not allow hotplug of CPU0 */
-	return cpu == 0 ? -EPERM : 0;
-}
-
 static void __cpuinit r8a7779_secondary_init(unsigned int cpu)
 {
 	gic_secondary_init(0);
@@ -176,6 +129,55 @@ static void __init r8a7779_smp_init_cpus(void)
 	shmobile_smp_init_cpus(scu_get_core_count(shmobile_scu_base));
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+static int r8a7779_scu_psr_core_disabled(int cpu)
+{
+	unsigned long mask = 3 << (cpu * 8);
+
+	if ((__raw_readl(shmobile_scu_base + 8) & mask) == mask)
+		return 1;
+
+	return 0;
+}
+
+static int r8a7779_cpu_kill(unsigned int cpu)
+{
+	int k;
+
+	/* this function is running on another CPU than the offline target,
+	 * here we need wait for shutdown code in platform_cpu_die() to
+	 * finish before asking SoC-specific code to power off the CPU core.
+	 */
+	for (k = 0; k < 1000; k++) {
+		if (r8a7779_scu_psr_core_disabled(cpu))
+			return r8a7779_platform_cpu_kill(cpu);
+
+		mdelay(1);
+	}
+
+	return 0;
+}
+
+static void r8a7779_cpu_die(unsigned int cpu)
+{
+	dsb();
+	flush_cache_all();
+
+	/* disable cache coherency */
+	scu_power_mode(shmobile_scu_base, SCU_PM_POWEROFF);
+
+	/* Endless loop until power off from r8a7779_cpu_kill() */
+	while (1)
+		cpu_do_idle();
+}
+
+static int r8a7779_cpu_disable(unsigned int cpu)
+{
+	/* only CPU1->3 have power domains, do not allow hotplug of CPU0 */
+	return cpu == 0 ? -EPERM : 0;
+}
+#endif /* CONFIG_HOTPLUG_CPU */
+
 struct smp_operations r8a7779_smp_ops  __initdata = {
 	.smp_init_cpus		= r8a7779_smp_init_cpus,
 	.smp_prepare_cpus	= r8a7779_smp_prepare_cpus,

commit 8bbcd729d219ca7cdc06ad3b0dea161c4c41b807
Author: Magnus Damm <damm@opensource.se>
Date:   Mon Feb 18 22:47:35 2013 +0900

    ARM: shmobile: Update r8a7779 to use scu_power_mode()
    
    Update the SMP code for R8A7779 to make use of the
    shared SCU function scu_power_mode() together with
    the early setup code in shmobile_secondary_vector_scu.
    
    With this patch in place the secondary CPUs modify the
    SCU setting during early boot instead of letting other
    CPUs deal with the coherency setting before boot. In
    other words, we used to setup coherency before boot
    in r8a7779_boot_secondary() but that bit is now instead
    handled by the code in shmobile_secondary_vector_scu.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 63c8db966fb2..bdd38091dc9e 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -58,9 +58,6 @@ static struct r8a7779_pm_ch *r8a7779_ch_cpu[4] = {
 	[3] = &r8a7779_ch_cpu3,
 };
 
-static DEFINE_SPINLOCK(scu_lock);
-static unsigned long tmp;
-
 #ifdef CONFIG_HAVE_ARM_TWD
 static DEFINE_TWD_LOCAL_TIMER(twd_local_timer, R8A7779_SCU_BASE + 0x600, 29);
 void __init r8a7779_register_twd(void)
@@ -79,20 +76,6 @@ static int r8a7779_scu_psr_core_disabled(int cpu)
 	return 0;
 }
 
-static void modify_scu_cpu_psr(unsigned long set, unsigned long clr)
-{
-	void __iomem *scu_base = shmobile_scu_base;
-
-	spin_lock(&scu_lock);
-	tmp = __raw_readl(scu_base + 8);
-	tmp &= ~clr;
-	tmp |= set;
-	spin_unlock(&scu_lock);
-
-	/* disable cache coherency after releasing the lock */
-	__raw_writel(tmp, scu_base + 8);
-}
-
 static int r8a7779_platform_cpu_kill(unsigned int cpu)
 {
 	struct r8a7779_pm_ch *ch = NULL;
@@ -133,7 +116,7 @@ static void __maybe_unused r8a7779_cpu_die(unsigned int cpu)
 	flush_cache_all();
 
 	/* disable cache coherency */
-	modify_scu_cpu_psr(3 << (cpu * 8), 0);
+	scu_power_mode(shmobile_scu_base, SCU_PM_POWEROFF);
 
 	/* Endless loop until power off from r8a7779_cpu_kill() */
 	while (1)
@@ -158,9 +141,6 @@ static int __cpuinit r8a7779_boot_secondary(unsigned int cpu, struct task_struct
 
 	cpu = cpu_logical_map(cpu);
 
-	/* enable cache coherency */
-	modify_scu_cpu_psr(0, 3 << (cpu * 8));
-
 	if (cpu < ARRAY_SIZE(r8a7779_ch_cpu))
 		ch = r8a7779_ch_cpu[cpu];
 
@@ -172,15 +152,13 @@ static int __cpuinit r8a7779_boot_secondary(unsigned int cpu, struct task_struct
 
 static void __init r8a7779_smp_prepare_cpus(unsigned int max_cpus)
 {
-	int cpu = cpu_logical_map(0);
-
 	scu_enable(shmobile_scu_base);
 
-	/* Map the reset vector (in headsmp.S) */
-	__raw_writel(__pa(shmobile_secondary_vector), AVECR);
+	/* Map the reset vector (in headsmp-scu.S) */
+	__raw_writel(__pa(shmobile_secondary_vector_scu), AVECR);
 
-	/* enable cache coherency on CPU0 */
-	modify_scu_cpu_psr(0, 3 << (cpu * 8));
+	/* enable cache coherency on booting CPU */
+	scu_power_mode(shmobile_scu_base, SCU_PM_NORMAL);
 
 	r8a7779_pm_init();
 

commit bbf2627c77355ee07cb589904efaf814cfc223d1
Author: Magnus Damm <damm@opensource.se>
Date:   Mon Feb 18 22:47:25 2013 +0900

    ARM: shmobile: Update r8a7779 to check SCU for hotplug
    
    Update the r8a7779 CPU Hotplug code to use SCU PSR
    to wait for the target CPU core. Previously the
    shared code in hotplug.c was used to let cpu_kill()
    wait for cpu_die(). With this change in place the
    r8a7779 SMP code does not depend on hotplug.c anymore.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index e69ce259a2d7..63c8db966fb2 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -26,6 +26,7 @@
 #include <linux/irqchip/arm-gic.h>
 #include <mach/common.h>
 #include <mach/r8a7779.h>
+#include <asm/cacheflush.h>
 #include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
 #include <asm/smp_twd.h>
@@ -68,6 +69,16 @@ void __init r8a7779_register_twd(void)
 }
 #endif
 
+static int r8a7779_scu_psr_core_disabled(int cpu)
+{
+	unsigned long mask = 3 << (cpu * 8);
+
+	if ((__raw_readl(shmobile_scu_base + 8) & mask) == mask)
+		return 1;
+
+	return 0;
+}
+
 static void modify_scu_cpu_psr(unsigned long set, unsigned long clr)
 {
 	void __iomem *scu_base = shmobile_scu_base;
@@ -89,9 +100,6 @@ static int r8a7779_platform_cpu_kill(unsigned int cpu)
 
 	cpu = cpu_logical_map(cpu);
 
-	/* disable cache coherency */
-	modify_scu_cpu_psr(3 << (cpu * 8), 0);
-
 	if (cpu < ARRAY_SIZE(r8a7779_ch_cpu))
 		ch = r8a7779_ch_cpu[cpu];
 
@@ -110,7 +118,7 @@ static int __maybe_unused r8a7779_cpu_kill(unsigned int cpu)
 	 * finish before asking SoC-specific code to power off the CPU core.
 	 */
 	for (k = 0; k < 1000; k++) {
-		if (shmobile_cpu_is_dead(cpu))
+		if (r8a7779_scu_psr_core_disabled(cpu))
 			return r8a7779_platform_cpu_kill(cpu);
 
 		mdelay(1);
@@ -119,6 +127,24 @@ static int __maybe_unused r8a7779_cpu_kill(unsigned int cpu)
 	return 0;
 }
 
+static void __maybe_unused r8a7779_cpu_die(unsigned int cpu)
+{
+	dsb();
+	flush_cache_all();
+
+	/* disable cache coherency */
+	modify_scu_cpu_psr(3 << (cpu * 8), 0);
+
+	/* Endless loop until power off from r8a7779_cpu_kill() */
+	while (1)
+		cpu_do_idle();
+}
+
+static int __maybe_unused r8a7779_cpu_disable(unsigned int cpu)
+{
+	/* only CPU1->3 have power domains, do not allow hotplug of CPU0 */
+	return cpu == 0 ? -EPERM : 0;
+}
 
 static void __cpuinit r8a7779_secondary_init(unsigned int cpu)
 {
@@ -179,7 +205,7 @@ struct smp_operations r8a7779_smp_ops  __initdata = {
 	.smp_boot_secondary	= r8a7779_boot_secondary,
 #ifdef CONFIG_HOTPLUG_CPU
 	.cpu_kill		= r8a7779_cpu_kill,
-	.cpu_die		= shmobile_cpu_die,
-	.cpu_disable		= shmobile_cpu_disable,
+	.cpu_die		= r8a7779_cpu_die,
+	.cpu_disable		= r8a7779_cpu_disable,
 #endif
 };

commit abf88136f73da52162d7e70bd1d8d4294c08bf1e
Author: Magnus Damm <damm@opensource.se>
Date:   Mon Feb 18 22:47:16 2013 +0900

    ARM: shmobile: Use R8A7779_SCU_BASE with TWD
    
    Rework the IOMEM() usage for the SCU base address in the
    case of r8a7779. Adjusts the TWD to use R8A7779_SCU_BASE.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 7fd58a3a26d8..e69ce259a2d7 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -31,7 +31,7 @@
 #include <asm/smp_twd.h>
 
 #define AVECR IOMEM(0xfe700040)
-#define R8A7779_SCU_BASE IOMEM(0xf0000000)
+#define R8A7779_SCU_BASE 0xf0000000
 
 static struct r8a7779_pm_ch r8a7779_ch_cpu1 = {
 	.chan_offs = 0x40, /* PWRSR0 .. PWRER0 */
@@ -61,8 +61,7 @@ static DEFINE_SPINLOCK(scu_lock);
 static unsigned long tmp;
 
 #ifdef CONFIG_HAVE_ARM_TWD
-static DEFINE_TWD_LOCAL_TIMER(twd_local_timer, 0xf0000600, 29);
-
+static DEFINE_TWD_LOCAL_TIMER(twd_local_timer, R8A7779_SCU_BASE + 0x600, 29);
 void __init r8a7779_register_twd(void)
 {
 	twd_local_timer_register(&twd_local_timer);
@@ -168,7 +167,7 @@ static void __init r8a7779_smp_prepare_cpus(unsigned int max_cpus)
 static void __init r8a7779_smp_init_cpus(void)
 {
 	/* setup r8a7779 specific SCU base */
-	shmobile_scu_base = R8A7779_SCU_BASE;
+	shmobile_scu_base = IOMEM(R8A7779_SCU_BASE);
 
 	shmobile_smp_init_cpus(scu_get_core_count(shmobile_scu_base));
 }

commit 4c8228455d1008136d748e6973dd72578bab4697
Author: Magnus Damm <damm@opensource.se>
Date:   Wed Feb 13 22:47:17 2013 +0900

    ARM: shmobile: Common shmobile_scu_base in headsmp-scu.S
    
    Update the code in headsmp-scu.S to use a global
    shmobile_scu_base variable both for convenient SCU
    base address storage and for the early SCU setup
    code in shmobile_secondary_vector_scu.
    
    With this patch applied r8a7779, sh73a0 and EMEV2
    all make use of the global shmobile_scu_base
    variable. However only sh73a0 makes use of the SCU
    bring up code in shmobile_secondary_vector_scu.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index d92188d702ab..7fd58a3a26d8 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -33,8 +33,6 @@
 #define AVECR IOMEM(0xfe700040)
 #define R8A7779_SCU_BASE IOMEM(0xf0000000)
 
-static void __iomem *shmobile_scu_base;
-
 static struct r8a7779_pm_ch r8a7779_ch_cpu1 = {
 	.chan_offs = 0x40, /* PWRSR0 .. PWRER0 */
 	.chan_bit = 1, /* ARM1 */

commit 3b94afa38350ad5b592df5b6539a20a253e04b53
Author: Magnus Damm <damm@opensource.se>
Date:   Wed Feb 13 22:46:48 2013 +0900

    ARM: shmobile: Kill off r8a7779 scu_base_addr() function
    
    Replace scu_base_addr() with a static shmobile_scu_base
    variable and introduce R8A7779_SCU_BASE.
    
    Later in the series the shmobile_scu_base variable will be
    made into a global variable so this is preparation only.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index f46b51658c3a..d92188d702ab 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -31,6 +31,9 @@
 #include <asm/smp_twd.h>
 
 #define AVECR IOMEM(0xfe700040)
+#define R8A7779_SCU_BASE IOMEM(0xf0000000)
+
+static void __iomem *shmobile_scu_base;
 
 static struct r8a7779_pm_ch r8a7779_ch_cpu1 = {
 	.chan_offs = 0x40, /* PWRSR0 .. PWRER0 */
@@ -56,11 +59,6 @@ static struct r8a7779_pm_ch *r8a7779_ch_cpu[4] = {
 	[3] = &r8a7779_ch_cpu3,
 };
 
-static void __iomem *scu_base_addr(void)
-{
-	return (void __iomem *)0xf0000000;
-}
-
 static DEFINE_SPINLOCK(scu_lock);
 static unsigned long tmp;
 
@@ -75,7 +73,7 @@ void __init r8a7779_register_twd(void)
 
 static void modify_scu_cpu_psr(unsigned long set, unsigned long clr)
 {
-	void __iomem *scu_base = scu_base_addr();
+	void __iomem *scu_base = shmobile_scu_base;
 
 	spin_lock(&scu_lock);
 	tmp = __raw_readl(scu_base + 8);
@@ -153,7 +151,7 @@ static void __init r8a7779_smp_prepare_cpus(unsigned int max_cpus)
 {
 	int cpu = cpu_logical_map(0);
 
-	scu_enable(scu_base_addr());
+	scu_enable(shmobile_scu_base);
 
 	/* Map the reset vector (in headsmp.S) */
 	__raw_writel(__pa(shmobile_secondary_vector), AVECR);
@@ -171,9 +169,10 @@ static void __init r8a7779_smp_prepare_cpus(unsigned int max_cpus)
 
 static void __init r8a7779_smp_init_cpus(void)
 {
-	unsigned int ncores = scu_get_core_count(scu_base_addr());
+	/* setup r8a7779 specific SCU base */
+	shmobile_scu_base = R8A7779_SCU_BASE;
 
-	shmobile_smp_init_cpus(ncores);
+	shmobile_smp_init_cpus(scu_get_core_count(shmobile_scu_base));
 }
 
 struct smp_operations r8a7779_smp_ops  __initdata = {

commit 0ae56a951de0efbf36a51de5b2e91db10425c771
Author: Magnus Damm <damm@opensource.se>
Date:   Wed Feb 13 00:45:25 2013 +0900

    ARM: shmobile: Remove r8a7779_get_core_count()
    
    Reduce the number of lines of code in smp-r8a7779.c
    by getting rid of the r8a7779_get_core_count() function.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 3a4acf23edcf..f46b51658c3a 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -87,13 +87,6 @@ static void modify_scu_cpu_psr(unsigned long set, unsigned long clr)
 	__raw_writel(tmp, scu_base + 8);
 }
 
-static unsigned int __init r8a7779_get_core_count(void)
-{
-	void __iomem *scu_base = scu_base_addr();
-
-	return scu_get_core_count(scu_base);
-}
-
 static int r8a7779_platform_cpu_kill(unsigned int cpu)
 {
 	struct r8a7779_pm_ch *ch = NULL;
@@ -178,7 +171,7 @@ static void __init r8a7779_smp_prepare_cpus(unsigned int max_cpus)
 
 static void __init r8a7779_smp_init_cpus(void)
 {
-	unsigned int ncores = r8a7779_get_core_count();
+	unsigned int ncores = scu_get_core_count(scu_base_addr());
 
 	shmobile_smp_init_cpus(ncores);
 }

commit 520f7bd73354f003a9a59937b28e4903d985c420
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Thu Dec 27 13:10:24 2012 -0600

    irqchip: Move ARM gic.h to include/linux/irqchip/arm-gic.h
    
    Now that we have GIC moved to drivers/irqchip and all GIC DT init for
    platforms using irqchip_init, move gic.h and update the remaining
    includes.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Anton Vorontsov <avorontsov@mvista.com>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: David Brown <davidb@codeaurora.org>
    Cc: Daniel Walker <dwalker@fifo99.com>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Viresh Kumar <viresh.linux@gmail.com>
    Cc: Shiraz Hashim <shiraz.hashim@st.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 2ce6af9a6a37..3a4acf23edcf 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -23,12 +23,12 @@
 #include <linux/spinlock.h>
 #include <linux/io.h>
 #include <linux/delay.h>
+#include <linux/irqchip/arm-gic.h>
 #include <mach/common.h>
 #include <mach/r8a7779.h>
 #include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
 #include <asm/smp_twd.h>
-#include <asm/hardware/gic.h>
 
 #define AVECR IOMEM(0xfe700040)
 

commit 872b59832d920ba7398b7cf81b5d8fc9088f8259
Author: Simon Horman <horms@verge.net.au>
Date:   Tue Nov 13 11:42:54 2012 +0900

    Revert "ARM: shmobile: r8a7779: Replace modify_scu_cpu_psr with scu_power_mode"
    
    This reverts commit cdc7594e5c5f7509a86b205edeedc58d72dd3999.
    
    The code changes the flags of the wrong cpus - which breaks the whole
    bootup of secondary CPUs.
    
    Cc: Bastian Hecht <hechtb@gmail.com>
    Signed-off-by: Simon Horman <horms@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 9def0f22bf22..2ce6af9a6a37 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -61,6 +61,9 @@ static void __iomem *scu_base_addr(void)
 	return (void __iomem *)0xf0000000;
 }
 
+static DEFINE_SPINLOCK(scu_lock);
+static unsigned long tmp;
+
 #ifdef CONFIG_HAVE_ARM_TWD
 static DEFINE_TWD_LOCAL_TIMER(twd_local_timer, 0xf0000600, 29);
 
@@ -70,6 +73,20 @@ void __init r8a7779_register_twd(void)
 }
 #endif
 
+static void modify_scu_cpu_psr(unsigned long set, unsigned long clr)
+{
+	void __iomem *scu_base = scu_base_addr();
+
+	spin_lock(&scu_lock);
+	tmp = __raw_readl(scu_base + 8);
+	tmp &= ~clr;
+	tmp |= set;
+	spin_unlock(&scu_lock);
+
+	/* disable cache coherency after releasing the lock */
+	__raw_writel(tmp, scu_base + 8);
+}
+
 static unsigned int __init r8a7779_get_core_count(void)
 {
 	void __iomem *scu_base = scu_base_addr();
@@ -85,7 +102,7 @@ static int r8a7779_platform_cpu_kill(unsigned int cpu)
 	cpu = cpu_logical_map(cpu);
 
 	/* disable cache coherency */
-	scu_power_mode(scu_base_addr(), 3);
+	modify_scu_cpu_psr(3 << (cpu * 8), 0);
 
 	if (cpu < ARRAY_SIZE(r8a7779_ch_cpu))
 		ch = r8a7779_ch_cpu[cpu];
@@ -128,7 +145,7 @@ static int __cpuinit r8a7779_boot_secondary(unsigned int cpu, struct task_struct
 	cpu = cpu_logical_map(cpu);
 
 	/* enable cache coherency */
-	scu_power_mode(scu_base_addr(), 0);
+	modify_scu_cpu_psr(0, 3 << (cpu * 8));
 
 	if (cpu < ARRAY_SIZE(r8a7779_ch_cpu))
 		ch = r8a7779_ch_cpu[cpu];
@@ -141,13 +158,15 @@ static int __cpuinit r8a7779_boot_secondary(unsigned int cpu, struct task_struct
 
 static void __init r8a7779_smp_prepare_cpus(unsigned int max_cpus)
 {
+	int cpu = cpu_logical_map(0);
+
 	scu_enable(scu_base_addr());
 
 	/* Map the reset vector (in headsmp.S) */
 	__raw_writel(__pa(shmobile_secondary_vector), AVECR);
 
 	/* enable cache coherency on CPU0 */
-	scu_power_mode(scu_base_addr(), 0);
+	modify_scu_cpu_psr(0, 3 << (cpu * 8));
 
 	r8a7779_pm_init();
 

commit cdc7594e5c5f7509a86b205edeedc58d72dd3999
Author: Bastian Hecht <hechtb@googlemail.com>
Date:   Thu Oct 25 12:58:22 2012 +0200

    ARM: shmobile: r8a7779: Replace modify_scu_cpu_psr with scu_power_mode
    
    We can remove the extra code of modify_scu_cpu_psr() and use the cleaner
    generic ARM helper scu_power_mode(). As every CPU only deals with its
    own power register and scu_power_mode() operates with 8-bit accesses,
    we save the locking overhead too.
    
    Signed-off-by: Bastian Hecht <hechtb@gmail.com>
    Signed-off-by: Simon Horman <horms@verge.net.au>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 2ce6af9a6a37..9def0f22bf22 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -61,9 +61,6 @@ static void __iomem *scu_base_addr(void)
 	return (void __iomem *)0xf0000000;
 }
 
-static DEFINE_SPINLOCK(scu_lock);
-static unsigned long tmp;
-
 #ifdef CONFIG_HAVE_ARM_TWD
 static DEFINE_TWD_LOCAL_TIMER(twd_local_timer, 0xf0000600, 29);
 
@@ -73,20 +70,6 @@ void __init r8a7779_register_twd(void)
 }
 #endif
 
-static void modify_scu_cpu_psr(unsigned long set, unsigned long clr)
-{
-	void __iomem *scu_base = scu_base_addr();
-
-	spin_lock(&scu_lock);
-	tmp = __raw_readl(scu_base + 8);
-	tmp &= ~clr;
-	tmp |= set;
-	spin_unlock(&scu_lock);
-
-	/* disable cache coherency after releasing the lock */
-	__raw_writel(tmp, scu_base + 8);
-}
-
 static unsigned int __init r8a7779_get_core_count(void)
 {
 	void __iomem *scu_base = scu_base_addr();
@@ -102,7 +85,7 @@ static int r8a7779_platform_cpu_kill(unsigned int cpu)
 	cpu = cpu_logical_map(cpu);
 
 	/* disable cache coherency */
-	modify_scu_cpu_psr(3 << (cpu * 8), 0);
+	scu_power_mode(scu_base_addr(), 3);
 
 	if (cpu < ARRAY_SIZE(r8a7779_ch_cpu))
 		ch = r8a7779_ch_cpu[cpu];
@@ -145,7 +128,7 @@ static int __cpuinit r8a7779_boot_secondary(unsigned int cpu, struct task_struct
 	cpu = cpu_logical_map(cpu);
 
 	/* enable cache coherency */
-	modify_scu_cpu_psr(0, 3 << (cpu * 8));
+	scu_power_mode(scu_base_addr(), 0);
 
 	if (cpu < ARRAY_SIZE(r8a7779_ch_cpu))
 		ch = r8a7779_ch_cpu[cpu];
@@ -158,15 +141,13 @@ static int __cpuinit r8a7779_boot_secondary(unsigned int cpu, struct task_struct
 
 static void __init r8a7779_smp_prepare_cpus(unsigned int max_cpus)
 {
-	int cpu = cpu_logical_map(0);
-
 	scu_enable(scu_base_addr());
 
 	/* Map the reset vector (in headsmp.S) */
 	__raw_writel(__pa(shmobile_secondary_vector), AVECR);
 
 	/* enable cache coherency on CPU0 */
-	modify_scu_cpu_psr(0, 3 << (cpu * 8));
+	scu_power_mode(scu_base_addr(), 0);
 
 	r8a7779_pm_init();
 

commit a62580e58065dc00430b16ced6e7a00837b8323f
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Thu Sep 8 13:15:22 2011 +0100

    ARM: SoC: convert shmobile SMP to SMP operations
    
    Convert shmobile SMP platforms to use struct smp_operations to provide
    their SMP and CPU hotplug operations.
    
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 6d1d0238cbf7..2ce6af9a6a37 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -87,14 +87,14 @@ static void modify_scu_cpu_psr(unsigned long set, unsigned long clr)
 	__raw_writel(tmp, scu_base + 8);
 }
 
-unsigned int __init r8a7779_get_core_count(void)
+static unsigned int __init r8a7779_get_core_count(void)
 {
 	void __iomem *scu_base = scu_base_addr();
 
 	return scu_get_core_count(scu_base);
 }
 
-int r8a7779_platform_cpu_kill(unsigned int cpu)
+static int r8a7779_platform_cpu_kill(unsigned int cpu)
 {
 	struct r8a7779_pm_ch *ch = NULL;
 	int ret = -EIO;
@@ -113,12 +113,31 @@ int r8a7779_platform_cpu_kill(unsigned int cpu)
 	return ret ? ret : 1;
 }
 
-void __cpuinit r8a7779_secondary_init(unsigned int cpu)
+static int __maybe_unused r8a7779_cpu_kill(unsigned int cpu)
+{
+	int k;
+
+	/* this function is running on another CPU than the offline target,
+	 * here we need wait for shutdown code in platform_cpu_die() to
+	 * finish before asking SoC-specific code to power off the CPU core.
+	 */
+	for (k = 0; k < 1000; k++) {
+		if (shmobile_cpu_is_dead(cpu))
+			return r8a7779_platform_cpu_kill(cpu);
+
+		mdelay(1);
+	}
+
+	return 0;
+}
+
+
+static void __cpuinit r8a7779_secondary_init(unsigned int cpu)
 {
 	gic_secondary_init(0);
 }
 
-int __cpuinit r8a7779_boot_secondary(unsigned int cpu)
+static int __cpuinit r8a7779_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	struct r8a7779_pm_ch *ch = NULL;
 	int ret = -EIO;
@@ -137,7 +156,7 @@ int __cpuinit r8a7779_boot_secondary(unsigned int cpu)
 	return ret;
 }
 
-void __init r8a7779_smp_prepare_cpus(void)
+static void __init r8a7779_smp_prepare_cpus(unsigned int max_cpus)
 {
 	int cpu = cpu_logical_map(0);
 
@@ -156,3 +175,22 @@ void __init r8a7779_smp_prepare_cpus(void)
 	r8a7779_platform_cpu_kill(2);
 	r8a7779_platform_cpu_kill(3);
 }
+
+static void __init r8a7779_smp_init_cpus(void)
+{
+	unsigned int ncores = r8a7779_get_core_count();
+
+	shmobile_smp_init_cpus(ncores);
+}
+
+struct smp_operations r8a7779_smp_ops  __initdata = {
+	.smp_init_cpus		= r8a7779_smp_init_cpus,
+	.smp_prepare_cpus	= r8a7779_smp_prepare_cpus,
+	.smp_secondary_init	= r8a7779_secondary_init,
+	.smp_boot_secondary	= r8a7779_boot_secondary,
+#ifdef CONFIG_HOTPLUG_CPU
+	.cpu_kill		= r8a7779_cpu_kill,
+	.cpu_die		= shmobile_cpu_die,
+	.cpu_disable		= shmobile_cpu_disable,
+#endif
+};

commit b759bd114e27fbb940fb44fd16552e8f4acd831e
Author: Magnus Damm <damm@opensource.se>
Date:   Thu May 10 14:57:22 2012 +0900

    ARM / mach-shmobile: r8a7779 SMP TWD boot regression fix
    
    Fix SMP TWD boot regression on r8a7779 based platforms caused by:
    
    4200b16 ARM: shmobile: convert to twd_local_timer_register() interface
    
    After the merge of the above commit it has been impossible to boot
    r8a7779 based SoCs with SMP enabled and CONFIG_HAVE_ARM_TWD=y. The
    kernel crashes at smp_init_cpus() timing which is before the console
    has been initialized, so to the user this looks like a kernel lock up
    without any particular error message.
    
    This patch fixes the regression on r8a7779 by moving the TWD
    registration code from smp_init_cpus() to sys_timer->init() time.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index b62e19d4c9af..6d1d0238cbf7 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -64,8 +64,15 @@ static void __iomem *scu_base_addr(void)
 static DEFINE_SPINLOCK(scu_lock);
 static unsigned long tmp;
 
+#ifdef CONFIG_HAVE_ARM_TWD
 static DEFINE_TWD_LOCAL_TIMER(twd_local_timer, 0xf0000600, 29);
 
+void __init r8a7779_register_twd(void)
+{
+	twd_local_timer_register(&twd_local_timer);
+}
+#endif
+
 static void modify_scu_cpu_psr(unsigned long set, unsigned long clr)
 {
 	void __iomem *scu_base = scu_base_addr();
@@ -84,7 +91,6 @@ unsigned int __init r8a7779_get_core_count(void)
 {
 	void __iomem *scu_base = scu_base_addr();
 
-	shmobile_twd_init(&twd_local_timer);
 	return scu_get_core_count(scu_base);
 }
 

commit 820d41cf0cd0e94a5661e093821e2e5c6b36a9d8
Merge: 6268b325c306 88b48684fe2d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 29 18:02:10 2012 -0700

    Merge tag 'cleanup2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull "ARM: cleanups of io includes" from Olof Johansson:
     "Rob Herring has done a sweeping change cleaning up all of the
      mach/io.h includes, moving some of the oft-repeated macros to a common
      location and removing a bunch of boiler plate.  This is another step
      closer to a common zImage for multiple platforms."
    
    Fix up various fairly trivial conflicts (<mach/io.h> removal vs changes
    around it, tegra localtimer.o is *still* gone, yadda-yadda).
    
    * tag 'cleanup2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (29 commits)
      ARM: tegra: Include assembler.h in sleep.S to fix build break
      ARM: pxa: use common IOMEM definition
      ARM: dma-mapping: convert ARCH_HAS_DMA_SET_COHERENT_MASK to kconfig symbol
      ARM: __io abuse cleanup
      ARM: create a common IOMEM definition
      ARM: iop13xx: fix missing declaration of iop13xx_init_early
      ARM: fix ioremap/iounmap for !CONFIG_MMU
      ARM: kill off __mem_pci
      ARM: remove bunch of now unused mach/io.h files
      ARM: make mach/io.h include optional
      ARM: clps711x: remove unneeded include of mach/io.h
      ARM: dove: add explicit include of dove.h to addr-map.c
      ARM: at91: add explicit include of hardware.h to uncompressor
      ARM: ep93xx: clean-up mach/io.h
      ARM: tegra: clean-up mach/io.h
      ARM: orion5x: clean-up mach/io.h
      ARM: davinci: remove unneeded mach/io.h include
      [media] davinci: remove includes of mach/io.h
      ARM: OMAP: Remove remaining includes for mach/io.h
      ARM: msm: clean-up mach/io.h
      ...

commit a2a47ca36642e3995e982957bc42678cf11ca6ac
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Fri Mar 9 17:16:40 2012 -0600

    ARM: __io abuse cleanup
    
    Several platforms incorrectly use __io() for casting to 'void __iomem *'.
    This converts all of those uses to use the common IOMEM macro.
    
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Anton Vorontsov <cbouatmailru@gmail.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: linux-sh@vger.kernel.org
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 4fe2e9eaf501..6d5e57d350b7 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -30,7 +30,7 @@
 #include <asm/smp_twd.h>
 #include <asm/hardware/gic.h>
 
-#define AVECR 0xfe700040
+#define AVECR IOMEM(0xfe700040)
 
 static struct r8a7779_pm_ch r8a7779_ch_cpu1 = {
 	.chan_offs = 0x40, /* PWRSR0 .. PWRER0 */
@@ -140,7 +140,7 @@ void __init r8a7779_smp_prepare_cpus(void)
 	scu_enable(scu_base_addr());
 
 	/* Map the reset vector (in headsmp.S) */
-	__raw_writel(__pa(shmobile_secondary_vector), __io(AVECR));
+	__raw_writel(__pa(shmobile_secondary_vector), AVECR);
 
 	/* enable cache coherency on CPU0 */
 	modify_scu_cpu_psr(0, 3 << (cpu * 8));

commit 4200b16d58cd34ff8e1616d8ed77417f8fc44864
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jan 10 19:44:19 2012 +0000

    ARM: shmobile: convert to twd_local_timer_register() interface
    
    Add support for the new smp_twd runtime registration interface
    to the shmobile platforms, and remove the old compile-time support.
    
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index 4fe2e9eaf501..9bb7b8575a1f 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -64,6 +64,8 @@ static void __iomem *scu_base_addr(void)
 static DEFINE_SPINLOCK(scu_lock);
 static unsigned long tmp;
 
+static DEFINE_TWD_LOCAL_TIMER(twd_local_timer, 0xf0000600, 29);
+
 static void modify_scu_cpu_psr(unsigned long set, unsigned long clr)
 {
 	void __iomem *scu_base = scu_base_addr();
@@ -82,11 +84,7 @@ unsigned int __init r8a7779_get_core_count(void)
 {
 	void __iomem *scu_base = scu_base_addr();
 
-#ifdef CONFIG_HAVE_ARM_TWD
-	/* twd_base needs to be initialized before percpu_timer_setup() */
-	twd_base = (void __iomem *)0xf0000600;
-#endif
-
+	shmobile_twd_init(&twd_local_timer);
 	return scu_get_core_count(scu_base);
 }
 

commit eb50439b92b6298bf209a982f295ba9c0f7cb30b
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Jan 20 12:01:12 2012 +0100

    ARM: 7293/1: logical_cpu_map: decouple CPU mapping from SMP
    
    It turns out that the logical CPU mapping is useful even when !CONFIG_SMP
    for manipulation of devices like interrupt and power controllers when
    running a UP kernel on a CPU other than 0. This can happen when kexecing
    a UP image from an SMP kernel.
    
    In the future, multi-cluster systems running AMP configurations will
    require something similar for mapping cluster IDs, so it makes sense to
    decouple this logic in preparation for this support.
    
    Acked-by: Yang Bai <hamo.by@gmail.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Reported-by: Joerg Roedel <joerg.roedel@amd.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
index cc97ef892d1b..4fe2e9eaf501 100644
--- a/arch/arm/mach-shmobile/smp-r8a7779.c
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -25,6 +25,7 @@
 #include <linux/delay.h>
 #include <mach/common.h>
 #include <mach/r8a7779.h>
+#include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
 #include <asm/smp_twd.h>
 #include <asm/hardware/gic.h>

commit f40aaf6da14a4043d6361e0c7d74ada18e866059
Author: Magnus Damm <damm@opensource.se>
Date:   Tue Jan 10 17:44:39 2012 +0900

    ARM: mach-shmobile: r8a7779 SMP support V3
    
    This patch contains r8a7779 SMP support V3 - now including
    CPU hotplug offine and online support. The r8a7779 power
    domain code is tied together with SMP glue code which allows
    us to control the power domains via CPU hotplug.
    
    At this point the kernel boots with the 4 Cortex-A9 cores in
    SMP mode and all CPU cores except CPU0 can be hotplugged.
    
    The code in platsmp.c is quite far from pretty, but it is
    kept like that intentionally to avoid creating layers of
    code that will go away in the near future anyway. The code
    needs to be updated when some per-SoC handling code will be
    added to the ARM architecture, see the following patch for
    more information:
     "[RFC PATCH 0/3] Per SoC descriptor"
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/arch/arm/mach-shmobile/smp-r8a7779.c b/arch/arm/mach-shmobile/smp-r8a7779.c
new file mode 100644
index 000000000000..cc97ef892d1b
--- /dev/null
+++ b/arch/arm/mach-shmobile/smp-r8a7779.c
@@ -0,0 +1,153 @@
+/*
+ * SMP support for R-Mobile / SH-Mobile - r8a7779 portion
+ *
+ * Copyright (C) 2011  Renesas Solutions Corp.
+ * Copyright (C) 2011  Magnus Damm
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <mach/common.h>
+#include <mach/r8a7779.h>
+#include <asm/smp_scu.h>
+#include <asm/smp_twd.h>
+#include <asm/hardware/gic.h>
+
+#define AVECR 0xfe700040
+
+static struct r8a7779_pm_ch r8a7779_ch_cpu1 = {
+	.chan_offs = 0x40, /* PWRSR0 .. PWRER0 */
+	.chan_bit = 1, /* ARM1 */
+	.isr_bit = 1, /* ARM1 */
+};
+
+static struct r8a7779_pm_ch r8a7779_ch_cpu2 = {
+	.chan_offs = 0x40, /* PWRSR0 .. PWRER0 */
+	.chan_bit = 2, /* ARM2 */
+	.isr_bit = 2, /* ARM2 */
+};
+
+static struct r8a7779_pm_ch r8a7779_ch_cpu3 = {
+	.chan_offs = 0x40, /* PWRSR0 .. PWRER0 */
+	.chan_bit = 3, /* ARM3 */
+	.isr_bit = 3, /* ARM3 */
+};
+
+static struct r8a7779_pm_ch *r8a7779_ch_cpu[4] = {
+	[1] = &r8a7779_ch_cpu1,
+	[2] = &r8a7779_ch_cpu2,
+	[3] = &r8a7779_ch_cpu3,
+};
+
+static void __iomem *scu_base_addr(void)
+{
+	return (void __iomem *)0xf0000000;
+}
+
+static DEFINE_SPINLOCK(scu_lock);
+static unsigned long tmp;
+
+static void modify_scu_cpu_psr(unsigned long set, unsigned long clr)
+{
+	void __iomem *scu_base = scu_base_addr();
+
+	spin_lock(&scu_lock);
+	tmp = __raw_readl(scu_base + 8);
+	tmp &= ~clr;
+	tmp |= set;
+	spin_unlock(&scu_lock);
+
+	/* disable cache coherency after releasing the lock */
+	__raw_writel(tmp, scu_base + 8);
+}
+
+unsigned int __init r8a7779_get_core_count(void)
+{
+	void __iomem *scu_base = scu_base_addr();
+
+#ifdef CONFIG_HAVE_ARM_TWD
+	/* twd_base needs to be initialized before percpu_timer_setup() */
+	twd_base = (void __iomem *)0xf0000600;
+#endif
+
+	return scu_get_core_count(scu_base);
+}
+
+int r8a7779_platform_cpu_kill(unsigned int cpu)
+{
+	struct r8a7779_pm_ch *ch = NULL;
+	int ret = -EIO;
+
+	cpu = cpu_logical_map(cpu);
+
+	/* disable cache coherency */
+	modify_scu_cpu_psr(3 << (cpu * 8), 0);
+
+	if (cpu < ARRAY_SIZE(r8a7779_ch_cpu))
+		ch = r8a7779_ch_cpu[cpu];
+
+	if (ch)
+		ret = r8a7779_sysc_power_down(ch);
+
+	return ret ? ret : 1;
+}
+
+void __cpuinit r8a7779_secondary_init(unsigned int cpu)
+{
+	gic_secondary_init(0);
+}
+
+int __cpuinit r8a7779_boot_secondary(unsigned int cpu)
+{
+	struct r8a7779_pm_ch *ch = NULL;
+	int ret = -EIO;
+
+	cpu = cpu_logical_map(cpu);
+
+	/* enable cache coherency */
+	modify_scu_cpu_psr(0, 3 << (cpu * 8));
+
+	if (cpu < ARRAY_SIZE(r8a7779_ch_cpu))
+		ch = r8a7779_ch_cpu[cpu];
+
+	if (ch)
+		ret = r8a7779_sysc_power_up(ch);
+
+	return ret;
+}
+
+void __init r8a7779_smp_prepare_cpus(void)
+{
+	int cpu = cpu_logical_map(0);
+
+	scu_enable(scu_base_addr());
+
+	/* Map the reset vector (in headsmp.S) */
+	__raw_writel(__pa(shmobile_secondary_vector), __io(AVECR));
+
+	/* enable cache coherency on CPU0 */
+	modify_scu_cpu_psr(0, 3 << (cpu * 8));
+
+	r8a7779_pm_init();
+
+	/* power off secondary CPUs */
+	r8a7779_platform_cpu_kill(1);
+	r8a7779_platform_cpu_kill(2);
+	r8a7779_platform_cpu_kill(3);
+}
