commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index 6c4f766365a2..3ebcd96efbff 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  linux/arch/arm/mach-omap1/clock_data.c
  *
@@ -5,10 +6,6 @@
  *  Written by Tuukka Tikkanen <tuukka.tikkanen@elektrobit.com>
  *  Based on clocks.h by Tony Lindgren, Gordon McNutt and RidgeRun, Inc
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  * To do:
  * - Clocks that are only available on some chips should be marked with the
  *   chips that they are present on.

commit 13872ebb915b547b3c0a1fc04f549a1475bb7989
Author: Aaro Koskinen <aaro.koskinen@iki.fi>
Date:   Wed Mar 13 04:10:57 2013 -0600

    ARM: OMAP1: fix USB host on 1710
    
    There is a long-standing bug that OHCI USB host controller does
    not respond on 1710, because of wrong clock definitions. See e.g.
    http://marc.info/?l=linux-omap&m=119634441229321&w=2. All register reads
    return just zeroes:
    
    [    1.896606] ohci ohci: OMAP OHCI
    [    1.912597] ohci ohci: new USB bus registered, assigned bus number 1
    [    1.933776] ohci ohci: irq 38, io mem 0xfffba000
    [    2.012573] ohci ohci: init err (00000000 0000)
    [    2.030334] ohci ohci: can't start
    [    2.046661] ohci ohci: startup error -75
    [    2.063201] ohci ohci: USB bus 1 deregistered
    
    After some experiments, it seems that when changing the usb_dc_ck /
    SOFT_REQ enable bit from USB_REQ_EN_SHIFT to SOFT_USB_OTG_DPLL_REQ_SHIFT
    (like done also on 7XX), the USB appears to work:
    
    [    2.183959] ohci ohci: OMAP OHCI
    [    2.198242] ohci ohci: new USB bus registered, assigned bus number 1
    [    2.215820] ohci ohci: irq 38, io mem 0xfffba000
    [    2.324798] hub 1-0:1.0: USB hub found
    [    2.361267] hub 1-0:1.0: 3 ports detected
    
    The patch is tested on Nokia 770.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index cb7c6ae2e3fc..6c4f766365a2 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -538,15 +538,6 @@ static struct clk usb_hhc_ck16xx = {
 };
 
 static struct clk usb_dc_ck = {
-	.name		= "usb_dc_ck",
-	.ops		= &clkops_generic,
-	/* Direct from ULPD, no parent */
-	.rate		= 48000000,
-	.enable_reg	= OMAP1_IO_ADDRESS(SOFT_REQ_REG),
-	.enable_bit	= USB_REQ_EN_SHIFT,
-};
-
-static struct clk usb_dc_ck7xx = {
 	.name		= "usb_dc_ck",
 	.ops		= &clkops_generic,
 	/* Direct from ULPD, no parent */
@@ -727,8 +718,7 @@ static struct omap_clk omap_clks[] = {
 	CLK(NULL,	"usb_clko",	&usb_clko,	CK_16XX | CK_1510 | CK_310),
 	CLK(NULL,	"usb_hhc_ck",	&usb_hhc_ck1510, CK_1510 | CK_310),
 	CLK(NULL,	"usb_hhc_ck",	&usb_hhc_ck16xx, CK_16XX),
-	CLK(NULL,	"usb_dc_ck",	&usb_dc_ck,	CK_16XX),
-	CLK(NULL,	"usb_dc_ck",	&usb_dc_ck7xx,	CK_7XX),
+	CLK(NULL,	"usb_dc_ck",	&usb_dc_ck,	CK_16XX | CK_7XX),
 	CLK(NULL,	"mclk",		&mclk_1510,	CK_1510 | CK_310),
 	CLK(NULL,	"mclk",		&mclk_16xx,	CK_16XX),
 	CLK(NULL,	"bclk",		&bclk_1510,	CK_1510 | CK_310),

commit bf027ca13738b1548910351952c3fe9b63263a9a
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Oct 29 13:54:06 2012 -0700

    ARM: OMAP: Split sram.h to local headers and minimal shared header
    
    Most of the defines are specific to omap1 and omap2+,
    and should be in the local headers. Only minimal function
    prototypes need to be shared.
    
    As discussed on linux-arm-kernel, we want to avoid
    relative includes for the arch/arm/*omap* shared code:
    
    http://www.spinics.net/lists/linux-omap/msg80520.html
    
    So this patch re-adds a minimal plat/sram.h.
    
    The new plat/sram.h must not be included from drivers,
    that will break build for omap2+ CONFIG_MULTIPLATFORM.
    
    Note that this patch temporarily adds two more
    relative includes; Those will be removed in the
    following patch.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index 28aea55a412e..cb7c6ae2e3fc 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -27,10 +27,9 @@
 #include <mach/hardware.h>
 #include <mach/usb.h>   /* for OTG_BASE */
 
-#include "../plat-omap/sram.h"
-
 #include "iomap.h"
 #include "clock.h"
+#include "sram.h"
 
 /* Some ARM_IDLECT1 bit shifts - used in struct arm_idlect1_clk */
 #define IDL_CLKOUT_ARM_SHIFT			12

commit e4c060db2c13f10de09101afc564763f9fd0019a
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Oct 5 13:25:59 2012 -0700

    ARM: OMAP: Split plat/cpu.h into local soc.h for mach-omap1 and mach-omap2
    
    We want to remove plat/cpu.h. To do this, let's first split
    it to private soc.h to mach-omap1 and mach-omap2. We have to
    keep plat/cpu.h around until the remaining drivers are fixed,
    so let's include the local soc.h in plat/cpu.h and for drivers
    still including plat/cpu.h.
    
    Once the drivers are fixed not to include plat/cpu.h, we
    can remove the file.
    
    This is needed for the ARM common zImage support.
    
    [tony@atomide.com: updated to not print a warning]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index c78fb913ee64..28aea55a412e 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -22,7 +22,7 @@
 
 #include <asm/mach-types.h>  /* for machine_is_* */
 
-#include <plat/cpu.h>
+#include "soc.h"
 
 #include <mach/hardware.h>
 #include <mach/usb.h>   /* for OTG_BASE */

commit e10dd62ffcb2953f80a4ea6ac53cb489ebfe0a79
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Sep 27 10:33:35 2012 -0600

    ARM: OMAP: clock: split plat/clkdev_omap.h into OMAP1/2 files
    
    To facilitate the ARM single image work, split
    arch/arm/plat-omap/include/plat/clkdev_omap.h into the
    arch/arm/mach-omap1/clock.h and arch/arm/mach-omap2/clock.h files.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index 8f4ae755010d..c78fb913ee64 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -23,7 +23,6 @@
 #include <asm/mach-types.h>  /* for machine_is_* */
 
 #include <plat/cpu.h>
-#include <plat/clkdev_omap.h>
 
 #include <mach/hardware.h>
 #include <mach/usb.h>   /* for OTG_BASE */

commit a135eaae524acba1509a3b19c97fae556e4da7cd
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Sep 27 10:33:34 2012 -0600

    ARM: OMAP: remove plat/clock.h
    
    Remove arch/arm/plat-omap/include/plat/clock.h by merging it into
    arch/arm/mach-omap1/clock.h and arch/arm/mach-omap2/clock.h.
    The goal here is to facilitate ARM single image kernels by removing
    includes via the "plat/" symlink.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    [tony@atomide.com: fixed to remove duplicate clock.h includes]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index 28e58eb163f2..8f4ae755010d 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -22,7 +22,6 @@
 
 #include <asm/mach-types.h>  /* for machine_is_* */
 
-#include <plat/clock.h>
 #include <plat/cpu.h>
 #include <plat/clkdev_omap.h>
 

commit 1fe9be8248ae9a04a09fcec7fed486d31e7f0897
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Sep 27 10:33:33 2012 -0600

    ARM: OMAP: duplicate plat-omap/clock.c into mach-omap[12]/clock.c
    
    Duplicate arch/arm/plat-omap/clock.c into arch/arm/mach-omap1/clock.c
    and arch/arm/mach-omap2/clock.c.  This is to support people who are working
    on the ARM single image kernel and the OMAP common clock framework
    conversion.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index 4337586195af..28e58eb163f2 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -766,14 +766,6 @@ static struct omap_clk omap_clks[] = {
  * init
  */
 
-static struct clk_functions omap1_clk_functions = {
-	.clk_enable		= omap1_clk_enable,
-	.clk_disable		= omap1_clk_disable,
-	.clk_round_rate		= omap1_clk_round_rate,
-	.clk_set_rate		= omap1_clk_set_rate,
-	.clk_disable_unused	= omap1_clk_disable_unused,
-};
-
 static void __init omap1_show_rates(void)
 {
 	pr_notice("Clocking rate (xtal/DPLL1/MPU): %ld.%01ld/%ld.%01ld/%ld.%01ld MHz\n",
@@ -804,8 +796,6 @@ int __init omap1_clk_init(void)
 	if (!cpu_is_omap15xx())
 		omap_writew(0, SOFT_REQ_REG2);
 
-	clk_init(&omap1_clk_functions);
-
 	/* By default all idlect1 clocks are allowed to idle */
 	arm_idlect1_mask = ~0;
 

commit 622297fdec22310d57cc3222a8fc337993c7cd23
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 2 14:19:52 2012 -0700

    ARM: OMAP: Make plat/sram.h local to plat-omap
    
    We can move this from plat to be local to plat-omap
    for common ARM zImage support.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index 9b45f4b0ee22..4337586195af 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -25,11 +25,12 @@
 #include <plat/clock.h>
 #include <plat/cpu.h>
 #include <plat/clkdev_omap.h>
-#include <plat/sram.h>	/* for omap_sram_reprogram_clock() */
 
 #include <mach/hardware.h>
 #include <mach/usb.h>   /* for OTG_BASE */
 
+#include "../plat-omap/sram.h"
+
 #include "iomap.h"
 #include "clock.h"
 

commit 3c101c41fbe5daf88afbbd575542aa1d047812bb
Merge: f191f40c1819 7852ec0536ca
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Sep 12 20:42:36 2012 -0700

    Merge tag 'omap-cleanup-b-for-3.7' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into cleanup-makefile-sparse
    
    smatch and string-wrapping cleanups for the OMAP subarch code.
    
    These changes fix some of the more meaningful warnings that smatch
    returns for the OMAP subarch code, and unwraps strings that are
    wrapped at the 80-column boundary, to conform with the current
    practice.
    
    Basic build, boot, and PM logs are available here:
    
    http://www.pwsan.com/omap/testlogs/warnings_a_cleanup_3.7/20120912025927/

commit 7852ec0536ca39cefffc6301dc77f8ae55592926
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Jul 26 00:54:26 2012 -0600

    ARM: OMAP: unwrap strings
    
    Find and unwrap wrapped strings in the style:
    
            pr_debug("clockdomain: hardware cannot set/clear wake up of "
                     "%s when %s wakes up\n", clkdm1->name, clkdm2->name);
    
    Keeping these strings contiguous seems to be the current Linux kernel
    policy.
    
    The offending lines were found with the following command:
    
        pcregrep -rnM '"\s*$\s*"' arch/arm/*omap*
    
    While here, some messages have been clarified, some pr_warning(
    ... calls have been converted to pr_warn( ..., and some printk(KERN_*
    ... have been converted to pr_*.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index c007d80dfb62..243e8b2865f5 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -776,11 +776,10 @@ static struct clk_functions omap1_clk_functions = {
 
 static void __init omap1_show_rates(void)
 {
-	pr_notice("Clocking rate (xtal/DPLL1/MPU): "
-			"%ld.%01ld/%ld.%01ld/%ld.%01ld MHz\n",
-		ck_ref.rate / 1000000, (ck_ref.rate / 100000) % 10,
-		ck_dpll1.rate / 1000000, (ck_dpll1.rate / 100000) % 10,
-		arm_ck.rate / 1000000, (arm_ck.rate / 100000) % 10);
+	pr_notice("Clocking rate (xtal/DPLL1/MPU): %ld.%01ld/%ld.%01ld/%ld.%01ld MHz\n",
+		  ck_ref.rate / 1000000, (ck_ref.rate / 100000) % 10,
+		  ck_dpll1.rate / 1000000, (ck_dpll1.rate / 100000) % 10,
+		  arm_ck.rate / 1000000, (arm_ck.rate / 100000) % 10);
 }
 
 u32 cpu_mask;
@@ -848,8 +847,8 @@ int __init omap1_clk_init(void)
 	if (cpu_is_omap16xx() && crystal_type == 2)
 		ck_ref.rate = 19200000;
 
-	pr_info("Clocks: ARM_SYSST: 0x%04x DPLL_CTL: 0x%04x ARM_CKCTL: "
-		"0x%04x\n", omap_readw(ARM_SYSST), omap_readw(DPLL_CTL),
+	pr_info("Clocks: ARM_SYSST: 0x%04x DPLL_CTL: 0x%04x ARM_CKCTL: 0x%04x\n",
+		omap_readw(ARM_SYSST), omap_readw(DPLL_CTL),
 		omap_readw(ARM_CKCTL));
 
 	/* We want to be in syncronous scalable mode */

commit 8aa8a9037a814b3006fb87cc03d925a96a197956
Author: Igor Grinberg <grinberg@compulab.co.il>
Date:   Wed Aug 29 02:18:52 2012 +0300

    ARM: OMAP1: remove the crystal type tag parsing
    
    The omap1 crystal setting uses the OMAP custom tags.
    Those tags are not used in upstream kernel and therefore the crystal
    type is never set by the tag parsing code on upstream kernels.
    Remove the crystal tag parsing code.
    
    Signed-off-by: Igor Grinberg <grinberg@compulab.co.il>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index c007d80dfb62..6a32b9b0dc30 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -25,7 +25,6 @@
 #include <plat/clock.h>
 #include <plat/cpu.h>
 #include <plat/clkdev_omap.h>
-#include <plat/board.h>
 #include <plat/sram.h>	/* for omap_sram_reprogram_clock() */
 
 #include <mach/hardware.h>
@@ -788,7 +787,6 @@ u32 cpu_mask;
 int __init omap1_clk_init(void)
 {
 	struct omap_clk *c;
-	const struct omap_clock_config *info;
 	int crystal_type = 0; /* Default 12 MHz */
 	u32 reg;
 
@@ -837,12 +835,6 @@ int __init omap1_clk_init(void)
 	ck_dpll1_p = clk_get(NULL, "ck_dpll1");
 	ck_ref_p = clk_get(NULL, "ck_ref");
 
-	info = omap_get_config(OMAP_TAG_CLOCK, struct omap_clock_config);
-	if (info != NULL) {
-		if (!cpu_is_omap15xx())
-			crystal_type = info->system_clock_type;
-	}
-
 	if (cpu_is_omap7xx())
 		ck_ref.rate = 13000000;
 	if (cpu_is_omap16xx() && crystal_type == 2)

commit b924b2047045844644e04b3c6e8308b2114afe7e
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Jun 4 00:56:15 2012 -0700

    ARM: OMAP: Make FS USB omap1 only
    
    As the FS USB code is not being actively used for omap2+
    there's no point keeping it around for omap2+.
    
    Let's make the FS USB platform init code omap1 only so
    we can remove the last user of omap_read/write for omap2+,
    and simplify things for further USB, DMA, and device tree
    related work.
    
    While at it, also group the mach includes for the related
    drivers.
    
    Cc: linux-usb@vger.kernel.org
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index c6ce93f71d08..c007d80dfb62 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -25,10 +25,11 @@
 #include <plat/clock.h>
 #include <plat/cpu.h>
 #include <plat/clkdev_omap.h>
+#include <plat/board.h>
 #include <plat/sram.h>	/* for omap_sram_reprogram_clock() */
-#include <plat/usb.h>   /* for OTG_BASE */
 
 #include <mach/hardware.h>
+#include <mach/usb.h>   /* for OTG_BASE */
 
 #include "iomap.h"
 #include "clock.h"

commit 2c799cef4d145af2182594a41cb5e5b42f2535c5
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Feb 24 10:34:35 2012 -0800

    ARM: OMAP: Remove plat/io.h by splitting it into mach/io.h and mach/hardware.h
    
    This is needed to minimize io.h so the SoC specific io.h
    for ARMs can removed.
    
    Note that minimal driver changes for DSS and RNG are needed to
    include cpu.h for SoC detection macros.
    
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Matt Mackall <mpm@selenic.com>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index 10b74511a4e8..c6ce93f71d08 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -15,6 +15,7 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/io.h>
 #include <linux/clk.h>
 #include <linux/cpufreq.h>
 #include <linux/delay.h>
@@ -27,6 +28,8 @@
 #include <plat/sram.h>	/* for omap_sram_reprogram_clock() */
 #include <plat/usb.h>   /* for OTG_BASE */
 
+#include <mach/hardware.h>
+
 #include "iomap.h"
 #include "clock.h"
 

commit 2e3ee9f45b3c25faa012abc9a62ab7aa515cd617
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Feb 24 10:34:34 2012 -0800

    ARM: OMAP1: Move most of plat/io.h into local iomap.h
    
    There's no need to have these in plat/io.h.
    
    While at it, clean up the includes to group them
    like they typically are grouped.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index 94699a82a734..10b74511a4e8 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -18,7 +18,6 @@
 #include <linux/clk.h>
 #include <linux/cpufreq.h>
 #include <linux/delay.h>
-#include <linux/io.h>
 
 #include <asm/mach-types.h>  /* for machine_is_* */
 
@@ -28,6 +27,7 @@
 #include <plat/sram.h>	/* for omap_sram_reprogram_clock() */
 #include <plat/usb.h>   /* for OTG_BASE */
 
+#include "iomap.h"
 #include "clock.h"
 
 /* Some ARM_IDLECT1 bit shifts - used in struct arm_idlect1_clk */

commit c116abc43df9ce3ebe5fbf2fbd6ae2edd6a9bd87
Author: Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
Date:   Sun Dec 4 16:07:47 2011 +0100

    ARM: OMAP1: Always reprogram dpll1 rate at boot
    
    DPLL1 reprogramming to a different rate is actually blocked inside
    omap1_select_table_rate(). However, it is already forced at boot, for
    boards which boot at unusable clock rates, and this seems to work
    correctly.
    
    OTOH, we now have a fine, run time performed clock selection algorithm
    implemented, which prevents less powerfull SoCs from being overclocked
    unintentionally.
    
    Allow reprogramming of dpll1 by default, and use it for switching to the
    higest supported clock rate with all boards, including those already
    booting at a usable rate of 60 MHz or above.
    
    Created against linux-omap/master tip as of Thu Dec 1,
    commit f83c2a8cbb59981722d1ab610c79adfd034a2667. Requires the just
    submitted patch "ARM: OMAP1: Move dpll1 rates selection from config to
    runtime" to prevent from unintentional overclocking. Tested on Amstrad
    Delta.
    
    Signed-off-by: Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index 9d1a42a5afd8..94699a82a734 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -936,12 +936,6 @@ void __init omap1_clk_late_init(void)
 {
 	unsigned long rate = ck_dpll1.rate;
 
-	if (rate >= OMAP1_DPLL1_SANE_VALUE)
-		return;
-
-	/* System booting at unusable rate, force reprogramming of DPLL1 */
-	ck_dpll1_p->rate = 0;
-
 	/* Find the highest supported frequency and enable it */
 	if (omap1_select_table_rate(&virtual_ck_mpu, ~0)) {
 		pr_err("System frequencies not set, using default. Check your config.\n");

commit f9e5908fa04e15a681dc4695b53c2c0c1d9b9a03
Author: Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
Date:   Thu Dec 1 22:16:26 2011 +0100

    ARM: OMAP1: Update dpll1 default rate reprogramming method
    
    According to comments in omap1_select_table_rate(), reprogramming dpll1
    is tricky, and should always be done from SRAM.
    
    While being at it, move OMAP730 special case handling inside
    omap_sram_reprogram_clock().
    
    Created on top of version 2 of the series "ARM: OMAP1: Fix dpll1
    reprogramming related issues", which it depends on.
    Tested on Amstrad Delta.
    
    Signed-off-by: Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index ff2d5248df23..9d1a42a5afd8 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -25,6 +25,7 @@
 #include <plat/clock.h>
 #include <plat/cpu.h>
 #include <plat/clkdev_omap.h>
+#include <plat/sram.h>	/* for omap_sram_reprogram_clock() */
 #include <plat/usb.h>   /* for OTG_BASE */
 
 #include "clock.h"
@@ -944,8 +945,10 @@ void __init omap1_clk_late_init(void)
 	/* Find the highest supported frequency and enable it */
 	if (omap1_select_table_rate(&virtual_ck_mpu, ~0)) {
 		pr_err("System frequencies not set, using default. Check your config.\n");
-		omap_writew(0x2290, DPLL_CTL);
-		omap_writew(cpu_is_omap7xx() ? 0x2005 : 0x0005, ARM_CKCTL);
+		/*
+		 * Reprogramming the DPLL is tricky, it must be done from SRAM.
+		 */
+		omap_sram_reprogram_clock(0x2290, 0x0005);
 		ck_dpll1.rate = OMAP1_DPLL1_SANE_VALUE;
 	}
 	propagate_rate(&ck_dpll1);

commit 24ce2705c2dd50e51f325c6e57dec378adc8c135
Author: Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
Date:   Thu Dec 8 18:01:41 2011 -0800

    ARM: OMAP1: Move dpll1 rates selection from config to runtime
    
    For still better multi-OMAP1 support, expand omap1_rate_table with flags
    for different SoC types and match them while selecting clock rates. The
    idea is stolen from current omap24xx clock rate selection algorithm.
    
    Since clkdev platform flag definitions are reused here, those had to be
    expanded with one extra entry for OMAP1710 subtype, as this is the only
    SoC for which we allow selection of the highest, 216 MHz rate.
    
    Once done, remove no longer needed clock rate configure time options.
    
    Tested on Amstrad Delta.
    
    Signed-off-by: Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
    [tony@atomide.com: updated comments]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index 9ff90a744a21..ff2d5248df23 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -778,12 +778,14 @@ static void __init omap1_show_rates(void)
 		arm_ck.rate / 1000000, (arm_ck.rate / 100000) % 10);
 }
 
+u32 cpu_mask;
+
 int __init omap1_clk_init(void)
 {
 	struct omap_clk *c;
 	const struct omap_clock_config *info;
 	int crystal_type = 0; /* Default 12 MHz */
-	u32 reg, cpu_mask;
+	u32 reg;
 
 #ifdef CONFIG_DEBUG_LL
 	/*
@@ -808,6 +810,8 @@ int __init omap1_clk_init(void)
 		clk_preinit(c->lk.clk);
 
 	cpu_mask = 0;
+	if (cpu_is_omap1710())
+		cpu_mask |= CK_1710;
 	if (cpu_is_omap16xx())
 		cpu_mask |= CK_16XX;
 	if (cpu_is_omap1510())

commit 6560ee07dc946e94f7cc2cd8e3b5a5f5ee7340c1
Author: Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
Date:   Thu Dec 1 21:13:02 2011 +0100

    ARM: OMAP1: recalculate loops per jiffy after dpll1 reprogram
    
    Otherwise timing is inaccurate, resulting in devices which depend on it,
    like omap-keypad, broken.
    
    Tested on Amstrad Delta.
    
    Signed-off-by: Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
    [tony@atomide.com: removed comment referencing a development branch]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index 86b2dec11788..9ff90a744a21 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -16,6 +16,8 @@
 
 #include <linux/kernel.h>
 #include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <linux/delay.h>
 #include <linux/io.h>
 
 #include <asm/mach-types.h>  /* for machine_is_* */
@@ -927,7 +929,9 @@ int __init omap1_clk_init(void)
 
 void __init omap1_clk_late_init(void)
 {
-	if (ck_dpll1.rate >= OMAP1_DPLL1_SANE_VALUE)
+	unsigned long rate = ck_dpll1.rate;
+
+	if (rate >= OMAP1_DPLL1_SANE_VALUE)
 		return;
 
 	/* System booting at unusable rate, force reprogramming of DPLL1 */
@@ -942,4 +946,5 @@ void __init omap1_clk_late_init(void)
 	}
 	propagate_rate(&ck_dpll1);
 	omap1_show_rates();
+	loops_per_jiffy = cpufreq_scale(loops_per_jiffy, rate, ck_dpll1.rate);
 }

commit c2cb211116192690605eaa70d39deb04241003e2
Author: Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
Date:   Thu Dec 1 21:13:01 2011 +0100

    ARM: OMAP1: Fix ckctl value used for dpll1 defualt rate
    
    Use the exact value found in omap1_rate_table, otherwise I have been
    experiencing issues with correct timekeeping on my Amstrad Delta.
    
    Signed-off-by: Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
    [tony@atomide.com: removed comment referencing a development branch]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index 3f305610efa0..86b2dec11788 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -937,7 +937,7 @@ void __init omap1_clk_late_init(void)
 	if (omap1_select_table_rate(&virtual_ck_mpu, ~0)) {
 		pr_err("System frequencies not set, using default. Check your config.\n");
 		omap_writew(0x2290, DPLL_CTL);
-		omap_writew(cpu_is_omap7xx() ? 0x3005 : 0x1005, ARM_CKCTL);
+		omap_writew(cpu_is_omap7xx() ? 0x2005 : 0x0005, ARM_CKCTL);
 		ck_dpll1.rate = OMAP1_DPLL1_SANE_VALUE;
 	}
 	propagate_rate(&ck_dpll1);

commit 650f7a72b8cc235ffe4a0e3eff37954349026721
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Dec 1 17:47:06 2011 -0800

    ARM: OMAP1: Fix reprogramming of DPLL1 for systems that boot at rates below 60MHz
    
    Commit e9b7086b80c4d9e354f4edc9e280ae85a60df408 (ARM: OMAP: Fix
    reprogramming of dpll1 rate) fixed a regression for systems that
    did not rely on bootloader set rates.
    
    However, it also introduced a new problem where the rates selected
    in .config would not take affect as omap1_select_table_rate
    currently refuses to reprogram DPLL1 if it's already initialized.
    
    This was not a problem earlier, as the reprogramming was done
    earlier with ck_dpll1_p->rate uninitialized.
    
    Fix this by forcing the reprogramming on systems booting at rates
    below 60MHz. Note that the long term fix is to make the rates
    SoC specific later on.
    
    Thanks for Janusz Krzysztofik <jkrzyszt@tis.icnet.pl> for figuring
    this one out.
    
    Reported-by: Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
    Acked-by: Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index 1297bb58869c..3f305610efa0 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -930,6 +930,9 @@ void __init omap1_clk_late_init(void)
 	if (ck_dpll1.rate >= OMAP1_DPLL1_SANE_VALUE)
 		return;
 
+	/* System booting at unusable rate, force reprogramming of DPLL1 */
+	ck_dpll1_p->rate = 0;
+
 	/* Find the highest supported frequency and enable it */
 	if (omap1_select_table_rate(&virtual_ck_mpu, ~0)) {
 		pr_err("System frequencies not set, using default. Check your config.\n");

commit e9b7086b80c4d9e354f4edc9e280ae85a60df408
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Nov 11 10:15:11 2011 -0800

    ARM: OMAP: Fix reprogramming of dpll1 rate
    
    Commit a66cb3454f220f49f900646ebdc76cb943319eb7 (ARM: OMAP: Map SRAM
    later on with ioremap_exec()) moved the SRAM init to happen later
    to remove a dependency to early SoC detection for map_io.
    
    This broke booting on some boards not using Kconfig option for
    OMAP_CLOCKS_SET_BY_BOOTLOADER as the dpll1 reprogramming would
    cause the following error:
    
    kernel BUG at arch/arm/plat-omap/sram.c:226!
    Internal error: Oops - undefined instruction: 0 [#1] PREEMPT
    Modules linked in:
    
    CPU: 0    Not tainted  (3.2.0-rc1-e3 #9)
    PC is at omap_sram_reprogram_clock+0x28/0x30
    LR is at omap1_select_table_rate+0x88/0xb4
    pc : [<c001b0c4>]    lr : [<c0019f54>]    psr: 600000d3
    sp : c035bf10  ip : c035bf20  fp : c035bf1c
    r10: c035bfd4  r9 : 54029252  r8 : c03f8120
    r7 : c0362b50  r6 : 00b71b00  r5 : c03873cc  r4 : c0362b40
    r3 : 00000000  r2 : c0362b40  r1 : 0000010a  r0 : 00002cb0
    Flags: nZCv  IRQs off  FIQs off  Mode SVC_32  ISA ARM  Segment kernel
    Control: 0000317f  Table: 10004000  DAC: 00000017
    Process swapper (pid: 0, stack limit = 0xc035a270)
    Stack: (0xc035bf10 to 0xc035c000)
    bf00:                                     c035bf3c c035bf20 c0019f54 c001b0ac
    bf20: 00001000 00002cb3 00000004 c035ed4c c035bf74 c035bf40 c033ea24 c0019edc
    bf40: c02f526c 00000002 00000015 bc058c9b 93111a16 c035335c 02000000 c035ed4c
    bf60: c035ed4c c03f8120 c035bf84 c035bf78 c00194c4 c033e8ec c035bfc4 c035bf88
    bf80: c033bc24 c00194a0 c035bf90 c035bf98 00000000 00000000 00000000 00000000
    bfa0: 00000001 00000000 c0354678 c035ece4 10004000 103532f4 c035bff4 c035bfc8
    bfc0: c0338574 c033b598 00000000 00000000 00000000 c035467c 0000317d c035c03c
    bfe0: c0354678 c035ece4 00000000 c035bff8 10008040 c0338508 00000000 00000000
    Backtrace:
    [<c001b09c>] (omap_sram_reprogram_clock+0x0/0x30) from [<c0019f54>] (omap1_select_table_rate+0x88/0xb4)
    [<c0019ecc>] (omap1_select_table_rate+0x0/0xb4) from [<c033ea24>] (omap1_clk_init+0x148/0x334)
     r7:c035ed4c r6:00000004 r5:00002cb3 r4:00001000
    [<c033e8dc>] (omap1_clk_init+0x0/0x334) from [<c00194c4>] (omap1_init_early+0x34/0x48)
     r8:c03f8120 r7:c035ed4c r6:c035ed4c r5:02000000 r4:c035335c
    [<c0019490>] (omap1_init_early+0x0/0x48) from [<c033bc24>] (setup_arch+0x69c/0x79c)
    [<c033b588>] (setup_arch+0x0/0x79c) from [<c0338574>] (start_kernel+0x7c/0x2f4)
    [<c03384f8>] (start_kernel+0x0/0x2f4) from [<10008040>] (0x10008040)
     r7:c035ece4 r6:c0354678 r5:c035c03c r4:0000317d
    Code: 0a000002 e1a0e00f e12fff13 e89da800 (e7f001f2)
    
    Fix this by adding omap1_clk_late_init() that only reprograms dpll1
    if the bootloader rate is less than 60MHz. This also allows removing
    of the OMAP_CLOCKS_SET_BY_BOOTLOADER option.
    
    Reported-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Tested-by: Aaro Koskinen <aaro.koskinen@iki.fi>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index 92400b9eb69f..1297bb58869c 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -767,6 +767,15 @@ static struct clk_functions omap1_clk_functions = {
 	.clk_disable_unused	= omap1_clk_disable_unused,
 };
 
+static void __init omap1_show_rates(void)
+{
+	pr_notice("Clocking rate (xtal/DPLL1/MPU): "
+			"%ld.%01ld/%ld.%01ld/%ld.%01ld MHz\n",
+		ck_ref.rate / 1000000, (ck_ref.rate / 100000) % 10,
+		ck_dpll1.rate / 1000000, (ck_dpll1.rate / 100000) % 10,
+		arm_ck.rate / 1000000, (arm_ck.rate / 100000) % 10);
+}
+
 int __init omap1_clk_init(void)
 {
 	struct omap_clk *c;
@@ -835,9 +844,12 @@ int __init omap1_clk_init(void)
 	/* We want to be in syncronous scalable mode */
 	omap_writew(0x1000, ARM_SYSST);
 
-#ifdef CONFIG_OMAP_CLOCKS_SET_BY_BOOTLOADER
-	/* Use values set by bootloader. Determine PLL rate and recalculate
-	 * dependent clocks as if kernel had changed PLL or divisors.
+
+	/*
+	 * Initially use the values set by bootloader. Determine PLL rate and
+	 * recalculate dependent clocks as if kernel had changed PLL or
+	 * divisors. See also omap1_clk_late_init() that can reprogram dpll1
+	 * after the SRAM is initialized.
 	 */
 	{
 		unsigned pll_ctl_val = omap_readw(DPLL_CTL);
@@ -862,25 +874,10 @@ int __init omap1_clk_init(void)
 			}
 		}
 	}
-#else
-	/* Find the highest supported frequency and enable it */
-	if (omap1_select_table_rate(&virtual_ck_mpu, ~0)) {
-		printk(KERN_ERR "System frequencies not set. Check your config.\n");
-		/* Guess sane values (60MHz) */
-		omap_writew(0x2290, DPLL_CTL);
-		omap_writew(cpu_is_omap7xx() ? 0x3005 : 0x1005, ARM_CKCTL);
-		ck_dpll1.rate = 60000000;
-	}
-#endif
 	propagate_rate(&ck_dpll1);
 	/* Cache rates for clocks connected to ck_ref (not dpll1) */
 	propagate_rate(&ck_ref);
-	printk(KERN_INFO "Clocking rate (xtal/DPLL1/MPU): "
-		"%ld.%01ld/%ld.%01ld/%ld.%01ld MHz\n",
-	       ck_ref.rate / 1000000, (ck_ref.rate / 100000) % 10,
-	       ck_dpll1.rate / 1000000, (ck_dpll1.rate / 100000) % 10,
-	       arm_ck.rate / 1000000, (arm_ck.rate / 100000) % 10);
-
+	omap1_show_rates();
 	if (machine_is_omap_perseus2() || machine_is_omap_fsample()) {
 		/* Select slicer output as OMAP input clock */
 		omap_writew(omap_readw(OMAP7XX_PCC_UPLD_CTRL) & ~0x1,
@@ -925,3 +922,21 @@ int __init omap1_clk_init(void)
 
 	return 0;
 }
+
+#define OMAP1_DPLL1_SANE_VALUE	60000000
+
+void __init omap1_clk_late_init(void)
+{
+	if (ck_dpll1.rate >= OMAP1_DPLL1_SANE_VALUE)
+		return;
+
+	/* Find the highest supported frequency and enable it */
+	if (omap1_select_table_rate(&virtual_ck_mpu, ~0)) {
+		pr_err("System frequencies not set, using default. Check your config.\n");
+		omap_writew(0x2290, DPLL_CTL);
+		omap_writew(cpu_is_omap7xx() ? 0x3005 : 0x1005, ARM_CKCTL);
+		ck_dpll1.rate = OMAP1_DPLL1_SANE_VALUE;
+	}
+	propagate_rate(&ck_dpll1);
+	omap1_show_rates();
+}

commit 65ae65c9058eb41e9566ffd12699607c68b23e5f
Author: Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
Date:   Tue Dec 21 21:08:15 2010 -0700

    OMAP1: clock_data: use runtime cpu / machine checks
    
    Otherwise multi-omap1 configurations may set wrong clock speed.
    
    Created and tested against l-o master on Amstrad Delta.
    
    Signed-off-by: Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index 12fee24181b2..92400b9eb69f 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -823,12 +823,10 @@ int __init omap1_clk_init(void)
 			crystal_type = info->system_clock_type;
 	}
 
-#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
-	ck_ref.rate = 13000000;
-#elif defined(CONFIG_ARCH_OMAP16XX)
-	if (crystal_type == 2)
+	if (cpu_is_omap7xx())
+		ck_ref.rate = 13000000;
+	if (cpu_is_omap16xx() && crystal_type == 2)
 		ck_ref.rate = 19200000;
-#endif
 
 	pr_info("Clocks: ARM_SYSST: 0x%04x DPLL_CTL: 0x%04x ARM_CKCTL: "
 		"0x%04x\n", omap_readw(ARM_SYSST), omap_readw(DPLL_CTL),
@@ -883,10 +881,11 @@ int __init omap1_clk_init(void)
 	       ck_dpll1.rate / 1000000, (ck_dpll1.rate / 100000) % 10,
 	       arm_ck.rate / 1000000, (arm_ck.rate / 100000) % 10);
 
-#if defined(CONFIG_MACH_OMAP_PERSEUS2) || defined(CONFIG_MACH_OMAP_FSAMPLE)
-	/* Select slicer output as OMAP input clock */
-	omap_writew(omap_readw(OMAP7XX_PCC_UPLD_CTRL) & ~0x1, OMAP7XX_PCC_UPLD_CTRL);
-#endif
+	if (machine_is_omap_perseus2() || machine_is_omap_fsample()) {
+		/* Select slicer output as OMAP input clock */
+		omap_writew(omap_readw(OMAP7XX_PCC_UPLD_CTRL) & ~0x1,
+				OMAP7XX_PCC_UPLD_CTRL);
+	}
 
 	/* Amstrad Delta wants BCLK high when inactive */
 	if (machine_is_ams_delta())

commit f7bb0d9ab29e3159e22c3bfc843bd37c7d3c91a0
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Thu Dec 9 14:24:16 2010 +0000

    I2C: i2c-omap: Change device name: i2c_omap -> omap_i2c
    
    The convention for omap device naming is omap_XXX.
    
    Rename the device and driver name in order to stick
    to this naming convention.
    
    Change device name in clock nodes as well.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Cc: Ben Dooks <ben-i2c@fluff.org>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Acked-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index 423d21d8c190..12fee24181b2 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -736,9 +736,9 @@ static struct omap_clk omap_clks[] = {
 	CLK("mmci-omap.1", "ick",	&armper_ck.clk,	CK_16XX),
 	/* Virtual clocks */
 	CLK(NULL,	"mpu",		&virtual_ck_mpu, CK_16XX | CK_1510 | CK_310),
-	CLK("i2c_omap.1", "fck",	&i2c_fck,	CK_16XX | CK_1510 | CK_310 | CK_7XX),
-	CLK("i2c_omap.1", "ick",	&i2c_ick,	CK_16XX),
-	CLK("i2c_omap.1", "ick",	&dummy_ck,	CK_1510 | CK_310 | CK_7XX),
+	CLK("omap_i2c.1", "fck",	&i2c_fck,	CK_16XX | CK_1510 | CK_310 | CK_7XX),
+	CLK("omap_i2c.1", "ick",	&i2c_ick,	CK_16XX),
+	CLK("omap_i2c.1", "ick",	&dummy_ck,	CK_1510 | CK_310 | CK_7XX),
 	CLK("omap1_spi100k.1", "fck",	&dummy_ck,	CK_7XX),
 	CLK("omap1_spi100k.1", "ick",	&dummy_ck,	CK_7XX),
 	CLK("omap1_spi100k.2", "fck",	&dummy_ck,	CK_7XX),

commit 77640aabd7558e43b65bc1a0311be2dbb42c3ff8
Author: Varadarajan, Charulatha <charu@ti.com>
Date:   Tue Dec 7 16:26:57 2010 -0800

    OMAP: GPIO: Implement GPIO as a platform device
    
    Implement GPIO as a platform device.
    
    GPIO APIs are used in machine_init functions. Hence it is
    required to complete GPIO probe before board_init. Therefore
    GPIO device register and driver register are implemented as
    postcore_initcalls.
    
    omap_gpio_init() does nothing now and this function would be
    removed in the next patch as it's usage is spread across most
    of the board files.
    
    Inorder to convert GPIO as platform device, modifications are
    required in clockxxxx_data.c file for OMAP1 so that device names
    can be used to obtain clock instead of getting clocks by
    name/NULL ptr.
    
    Use runtime pm APIs (pm_runtime_put*/pm_runtime_get*) for enabling
    or disabling the clocks, modify sysconfig settings and remove usage
    of clock FW APIs.
    Note 1: Converting GPIO driver to use runtime PM APIs is not done as a
    separate patch because GPIO clock names are different for various OMAPs
    and are different for some of the banks in the same CPU. This would need
    usage of cpu_is checks and bank id checks while using clock FW APIs in
    the gpio driver. Hence while making GPIO a platform driver framework,
    PM runtime APIs are used directly.
    
    Note 2: While implementing GPIO as a platform device, pm runtime APIs
    are used as mentioned above and modification is not done in gpio's
    prepare for idle/ resume after idle functions. This would be done
    in the next patch series and GPIO driver would be made to use dev_pm_ops
    instead of sysdev_class in that series only.
    
    Due to the above, the GPIO driver implicitly relies on
    CM_AUTOIDLE = 1 on its iclk for power management to work, since the
    driver never disables its iclk.
    This would be taken care in the next patch series (see Note 3 below).
    
    Refer to
    http://www.mail-archive.com/linux-omap@vger.kernel.org/msg39112.html
    for more details.
    
    Note 3: only pm_runtime_get_sync is called in gpio's probe() and
    pm_runtime_put* is never called. This is to make the implementation
    similar to the existing GPIO code. Another patch series would be sent
    to correct this.
    
    In OMAP3 and OMAP4 gpio's debounce clocks are optional clocks. They
    are enabled/ disabled whenever required using clock framework APIs
    
    TODO:
    1. Cleanup the GPIO driver. Use function pointers and register
    offest pointers instead of using hardcoded values
    2. Remove all cpu_is_ checks and OMAP specific macros
    3. Remove usage of gpio_bank array so that only
       instance specific information is used in driver code
    4. Rename 'method'/ avoid it's usage
    5. Fix the non-wakeup gpios handling for OMAP2430, OMAP3 & OMAP4
    6. Modify gpio's prepare for idle/ resume after idle functions
       to use runtime pm implentation.
    
    Signed-off-by: Charulatha V <charu@ti.com>
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Reviewed-by: Basak, Partha <p-basak2@ti.com>
    Acked-by: Kevin Hilman <khilman@deeprootsystems.com>
    [tony@atomide.com: updated for bank specific revision and updated boards]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index af54114b8f08..423d21d8c190 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -143,7 +143,7 @@ static struct arm_idlect1_clk armper_ck = {
  * activation.  [ GPIO code for 1510 ]
  */
 static struct clk arm_gpio_ck = {
-	.name		= "arm_gpio_ck",
+	.name		= "ick",
 	.ops		= &clkops_generic,
 	.parent		= &ck_dpll1,
 	.flags		= ENABLE_ON_INIT,
@@ -684,7 +684,7 @@ static struct omap_clk omap_clks[] = {
 	CLK(NULL,	"ck_sossi",	&sossi_ck,	CK_16XX),
 	CLK(NULL,	"arm_ck",	&arm_ck,	CK_16XX | CK_1510 | CK_310),
 	CLK(NULL,	"armper_ck",	&armper_ck.clk,	CK_16XX | CK_1510 | CK_310),
-	CLK(NULL,	"arm_gpio_ck",	&arm_gpio_ck,	CK_1510 | CK_310),
+	CLK("omap_gpio.0", "ick",	&arm_gpio_ck,	CK_1510 | CK_310),
 	CLK(NULL,	"armxor_ck",	&armxor_ck.clk,	CK_16XX | CK_1510 | CK_310 | CK_7XX),
 	CLK(NULL,	"armtim_ck",	&armtim_ck.clk,	CK_16XX | CK_1510 | CK_310),
 	CLK("omap_wdt",	"fck",		&armwdt_ck.clk,	CK_16XX | CK_1510 | CK_310),

commit 331d919af416b9b92428947ef8c535a3e24c6b31
Merge: 047b51fb208c fb8ce14c7e16
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Aug 4 08:46:24 2010 +0300

    Merge branch 'for_2.6.36' of git://git.pwsan.com/linux-2.6 into omap-for-linus

commit 8b8fbd39e20b5db95f8f4b3bda4c9d3fcf8e3afc
Author: Cory Maccarrone <darkstar6262@gmail.com>
Date:   Mon Aug 2 14:21:39 2010 +0300

    omap1: omap7xx clocks, mux, serial fixes
    
    This change adds in the necessary clocks and mux pins for UART
    control on omap7xx devices.  I also made a change in the serial
    code to only try and initialize two UARTs in omap_serial_init, as
    these devices don't have three.
    
    Signed-off-by: Cory Maccarrone <darkstar6262@gmail.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index aa8558adbf1c..9240bc1026a3 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -478,6 +478,24 @@ static struct clk usb_dc_ck7xx = {
 	.enable_bit	= 8,
 };
 
+static struct clk uart1_7xx = {
+	.name		= "uart1_ck",
+	.ops		= &clkops_generic,
+	/* Direct from ULPD, no parent */
+	.rate		= 12000000,
+	.enable_reg	= OMAP1_IO_ADDRESS(SOFT_REQ_REG),
+	.enable_bit	= 9,
+};
+
+static struct clk uart2_7xx = {
+	.name		= "uart2_ck",
+	.ops		= &clkops_generic,
+	/* Direct from ULPD, no parent */
+	.rate		= 12000000,
+	.enable_reg	= OMAP1_IO_ADDRESS(SOFT_REQ_REG),
+	.enable_bit	= 11,
+};
+
 static struct clk mclk_1510 = {
 	.name		= "mclk",
 	.ops		= &clkops_generic,
@@ -620,7 +638,9 @@ static struct omap_clk omap_clks[] = {
 	/* ULPD clocks */
 	CLK(NULL,	"uart1_ck",	&uart1_1510,	CK_1510 | CK_310),
 	CLK(NULL,	"uart1_ck",	&uart1_16xx.clk, CK_16XX),
+	CLK(NULL,	"uart1_ck",	&uart1_7xx,	CK_7XX),
 	CLK(NULL,	"uart2_ck",	&uart2_ck,	CK_16XX | CK_1510 | CK_310),
+	CLK(NULL,	"uart2_ck",	&uart2_7xx,	CK_7XX),
 	CLK(NULL,	"uart3_ck",	&uart3_1510,	CK_1510 | CK_310),
 	CLK(NULL,	"uart3_ck",	&uart3_16xx.clk, CK_16XX),
 	CLK(NULL,	"usb_clko",	&usb_clko,	CK_16XX | CK_1510 | CK_310),

commit fb2fc9204f8ce060d239ab41f09cf6fc6de5ad4b
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Jul 26 16:34:28 2010 -0600

    OMAP1: clock: some cleanup
    
    Convert most of the magic numbers in mach-omap1/clock_data.c to use
    macros.  Clean up a few comments to conform with Documentation/CodingStyle.
    Mark the current clkops_uart as being OMAP16xx-only, and add some comments
    to indicate that it does not belong there, for future cleanup.
    
    This patch should not cause any functional changes.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index aa8558adbf1c..ca4bd862033c 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -8,6 +8,10 @@
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
+ *
+ * To do:
+ * - Clocks that are only available on some chips should be marked with the
+ *   chips that they are present on.
  */
 
 #include <linux/kernel.h>
@@ -23,9 +27,49 @@
 
 #include "clock.h"
 
-/*------------------------------------------------------------------------
+/* Some ARM_IDLECT1 bit shifts - used in struct arm_idlect1_clk */
+#define IDL_CLKOUT_ARM_SHIFT			12
+#define IDLTIM_ARM_SHIFT			9
+#define IDLAPI_ARM_SHIFT			8
+#define IDLIF_ARM_SHIFT				6
+#define IDLLB_ARM_SHIFT				4	/* undocumented? */
+#define OMAP1510_IDLLCD_ARM_SHIFT		3	/* undocumented? */
+#define IDLPER_ARM_SHIFT			2
+#define IDLXORP_ARM_SHIFT			1
+#define IDLWDT_ARM_SHIFT			0
+
+/* Some MOD_CONF_CTRL_0 bit shifts - used in struct clk.enable_bit */
+#define CONF_MOD_UART3_CLK_MODE_R		31
+#define CONF_MOD_UART2_CLK_MODE_R		30
+#define CONF_MOD_UART1_CLK_MODE_R		29
+#define CONF_MOD_MMC_SD_CLK_REQ_R		23
+#define CONF_MOD_MCBSP3_AUXON			20
+
+/* Some MOD_CONF_CTRL_1 bit shifts - used in struct clk.enable_bit */
+#define CONF_MOD_SOSSI_CLK_EN_R			16
+
+/* Some OTG_SYSCON_2-specific bit fields */
+#define OTG_SYSCON_2_UHOST_EN_SHIFT		8
+
+/* Some SOFT_REQ_REG bit fields - used in struct clk.enable_bit */
+#define SOFT_MMC2_DPLL_REQ_SHIFT	13
+#define SOFT_MMC_DPLL_REQ_SHIFT		12
+#define SOFT_UART3_DPLL_REQ_SHIFT	11
+#define SOFT_UART2_DPLL_REQ_SHIFT	10
+#define SOFT_UART1_DPLL_REQ_SHIFT	9
+#define SOFT_USB_OTG_DPLL_REQ_SHIFT	8
+#define SOFT_CAM_DPLL_REQ_SHIFT		7
+#define SOFT_COM_MCKO_REQ_SHIFT		6
+#define SOFT_PERIPH_REQ_SHIFT		5	/* sys_ck gate for UART2 ? */
+#define USB_REQ_EN_SHIFT		4
+#define SOFT_USB_REQ_SHIFT		3	/* sys_ck gate for USB host? */
+#define SOFT_SDW_REQ_SHIFT		2	/* sys_ck gate for Bluetooth? */
+#define SOFT_COM_REQ_SHIFT		1	/* sys_ck gate for com proc? */
+#define SOFT_DPLL_REQ_SHIFT		0
+
+/*
  * Omap1 clocks
- *-------------------------------------------------------------------------*/
+ */
 
 static struct clk ck_ref = {
 	.name		= "ck_ref",
@@ -54,7 +98,7 @@ static struct arm_idlect1_clk ck_dpll1out = {
 		.enable_bit	= EN_CKOUT_ARM,
 		.recalc		= &followparent_recalc,
 	},
-	.idlect_shift	= 12,
+	.idlect_shift	= IDL_CLKOUT_ARM_SHIFT,
 };
 
 static struct clk sossi_ck = {
@@ -63,7 +107,7 @@ static struct clk sossi_ck = {
 	.parent		= &ck_dpll1out.clk,
 	.flags		= CLOCK_NO_IDLE_PARENT | ENABLE_REG_32BIT,
 	.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_1),
-	.enable_bit	= 16,
+	.enable_bit	= CONF_MOD_SOSSI_CLK_EN_R,
 	.recalc		= &omap1_sossi_recalc,
 	.set_rate	= &omap1_set_sossi_rate,
 };
@@ -91,7 +135,7 @@ static struct arm_idlect1_clk armper_ck = {
 		.round_rate	= omap1_clk_round_rate_ckctl_arm,
 		.set_rate	= omap1_clk_set_rate_ckctl_arm,
 	},
-	.idlect_shift	= 2,
+	.idlect_shift	= IDLPER_ARM_SHIFT,
 };
 
 /*
@@ -118,7 +162,7 @@ static struct arm_idlect1_clk armxor_ck = {
 		.enable_bit	= EN_XORPCK,
 		.recalc		= &followparent_recalc,
 	},
-	.idlect_shift	= 1,
+	.idlect_shift	= IDLXORP_ARM_SHIFT,
 };
 
 static struct arm_idlect1_clk armtim_ck = {
@@ -131,7 +175,7 @@ static struct arm_idlect1_clk armtim_ck = {
 		.enable_bit	= EN_TIMCK,
 		.recalc		= &followparent_recalc,
 	},
-	.idlect_shift	= 9,
+	.idlect_shift	= IDLTIM_ARM_SHIFT,
 };
 
 static struct arm_idlect1_clk armwdt_ck = {
@@ -145,7 +189,7 @@ static struct arm_idlect1_clk armwdt_ck = {
 		.fixed_div	= 14,
 		.recalc		= &omap_fixed_divisor_recalc,
 	},
-	.idlect_shift	= 0,
+	.idlect_shift	= IDLWDT_ARM_SHIFT,
 };
 
 static struct clk arminth_ck16xx = {
@@ -212,7 +256,6 @@ static struct clk dsptim_ck = {
 	.recalc		= &followparent_recalc,
 };
 
-/* Tie ARM_IDLECT1:IDLIF_ARM to this logical clock structure */
 static struct arm_idlect1_clk tc_ck = {
 	.clk = {
 		.name		= "tc_ck",
@@ -224,7 +267,7 @@ static struct arm_idlect1_clk tc_ck = {
 		.round_rate	= omap1_clk_round_rate_ckctl_arm,
 		.set_rate	= omap1_clk_set_rate_ckctl_arm,
 	},
-	.idlect_shift	= 6,
+	.idlect_shift	= IDLIF_ARM_SHIFT,
 };
 
 static struct clk arminth_ck1510 = {
@@ -304,7 +347,7 @@ static struct arm_idlect1_clk api_ck = {
 		.enable_bit	= EN_APICK,
 		.recalc		= &followparent_recalc,
 	},
-	.idlect_shift	= 8,
+	.idlect_shift	= IDLAPI_ARM_SHIFT,
 };
 
 static struct arm_idlect1_clk lb_ck = {
@@ -317,7 +360,7 @@ static struct arm_idlect1_clk lb_ck = {
 		.enable_bit	= EN_LBCK,
 		.recalc		= &followparent_recalc,
 	},
-	.idlect_shift	= 4,
+	.idlect_shift	= IDLLB_ARM_SHIFT,
 };
 
 static struct clk rhea1_ck = {
@@ -359,9 +402,15 @@ static struct arm_idlect1_clk lcd_ck_1510 = {
 		.round_rate	= omap1_clk_round_rate_ckctl_arm,
 		.set_rate	= omap1_clk_set_rate_ckctl_arm,
 	},
-	.idlect_shift	= 3,
+	.idlect_shift	= OMAP1510_IDLLCD_ARM_SHIFT,
 };
 
+/*
+ * XXX The enable_bit here is misused - it simply switches between 12MHz
+ * and 48MHz.  Reimplement with clksel.
+ *
+ * XXX does this need SYSC register handling?
+ */
 static struct clk uart1_1510 = {
 	.name		= "uart1_ck",
 	.ops		= &clkops_null,
@@ -370,25 +419,37 @@ static struct clk uart1_1510 = {
 	.rate		= 12000000,
 	.flags		= ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
 	.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_0),
-	.enable_bit	= 29,	/* Chooses between 12MHz and 48MHz */
+	.enable_bit	= CONF_MOD_UART1_CLK_MODE_R,
 	.set_rate	= &omap1_set_uart_rate,
 	.recalc		= &omap1_uart_recalc,
 };
 
+/*
+ * XXX The enable_bit here is misused - it simply switches between 12MHz
+ * and 48MHz.  Reimplement with clksel.
+ *
+ * XXX SYSC register handling does not belong in the clock framework
+ */
 static struct uart_clk uart1_16xx = {
 	.clk	= {
 		.name		= "uart1_ck",
-		.ops		= &clkops_uart,
+		.ops		= &clkops_uart_16xx,
 		/* Direct from ULPD, no real parent */
 		.parent		= &armper_ck.clk,
 		.rate		= 48000000,
 		.flags		= ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
 		.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_0),
-		.enable_bit	= 29,
+		.enable_bit	= CONF_MOD_UART1_CLK_MODE_R,
 	},
 	.sysc_addr	= 0xfffb0054,
 };
 
+/*
+ * XXX The enable_bit here is misused - it simply switches between 12MHz
+ * and 48MHz.  Reimplement with clksel.
+ *
+ * XXX does this need SYSC register handling?
+ */
 static struct clk uart2_ck = {
 	.name		= "uart2_ck",
 	.ops		= &clkops_null,
@@ -397,11 +458,17 @@ static struct clk uart2_ck = {
 	.rate		= 12000000,
 	.flags		= ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
 	.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_0),
-	.enable_bit	= 30,	/* Chooses between 12MHz and 48MHz */
+	.enable_bit	= CONF_MOD_UART2_CLK_MODE_R,
 	.set_rate	= &omap1_set_uart_rate,
 	.recalc		= &omap1_uart_recalc,
 };
 
+/*
+ * XXX The enable_bit here is misused - it simply switches between 12MHz
+ * and 48MHz.  Reimplement with clksel.
+ *
+ * XXX does this need SYSC register handling?
+ */
 static struct clk uart3_1510 = {
 	.name		= "uart3_ck",
 	.ops		= &clkops_null,
@@ -410,21 +477,27 @@ static struct clk uart3_1510 = {
 	.rate		= 12000000,
 	.flags		= ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
 	.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_0),
-	.enable_bit	= 31,	/* Chooses between 12MHz and 48MHz */
+	.enable_bit	= CONF_MOD_UART3_CLK_MODE_R,
 	.set_rate	= &omap1_set_uart_rate,
 	.recalc		= &omap1_uart_recalc,
 };
 
+/*
+ * XXX The enable_bit here is misused - it simply switches between 12MHz
+ * and 48MHz.  Reimplement with clksel.
+ *
+ * XXX SYSC register handling does not belong in the clock framework
+ */
 static struct uart_clk uart3_16xx = {
 	.clk	= {
 		.name		= "uart3_ck",
-		.ops		= &clkops_uart,
+		.ops		= &clkops_uart_16xx,
 		/* Direct from ULPD, no real parent */
 		.parent		= &armper_ck.clk,
 		.rate		= 48000000,
 		.flags		= ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
 		.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_0),
-		.enable_bit	= 31,
+		.enable_bit	= CONF_MOD_UART3_CLK_MODE_R,
 	},
 	.sysc_addr	= 0xfffb9854,
 };
@@ -457,7 +530,7 @@ static struct clk usb_hhc_ck16xx = {
 	/* OTG_SYSCON_2.OTG_PADEN == 0 (not 1510-compatible) */
 	.flags		= ENABLE_REG_32BIT,
 	.enable_reg	= OMAP1_IO_ADDRESS(OTG_BASE + 0x08), /* OTG_SYSCON_2 */
-	.enable_bit	= 8 /* UHOST_EN */,
+	.enable_bit	= OTG_SYSCON_2_UHOST_EN_SHIFT
 };
 
 static struct clk usb_dc_ck = {
@@ -466,7 +539,7 @@ static struct clk usb_dc_ck = {
 	/* Direct from ULPD, no parent */
 	.rate		= 48000000,
 	.enable_reg	= OMAP1_IO_ADDRESS(SOFT_REQ_REG),
-	.enable_bit	= 4,
+	.enable_bit	= USB_REQ_EN_SHIFT,
 };
 
 static struct clk usb_dc_ck7xx = {
@@ -475,7 +548,7 @@ static struct clk usb_dc_ck7xx = {
 	/* Direct from ULPD, no parent */
 	.rate		= 48000000,
 	.enable_reg	= OMAP1_IO_ADDRESS(SOFT_REQ_REG),
-	.enable_bit	= 8,
+	.enable_bit	= SOFT_USB_OTG_DPLL_REQ_SHIFT,
 };
 
 static struct clk mclk_1510 = {
@@ -484,7 +557,7 @@ static struct clk mclk_1510 = {
 	/* Direct from ULPD, no parent. May be enabled by ext hardware. */
 	.rate		= 12000000,
 	.enable_reg	= OMAP1_IO_ADDRESS(SOFT_REQ_REG),
-	.enable_bit	= 6,
+	.enable_bit	= SOFT_COM_MCKO_REQ_SHIFT,
 };
 
 static struct clk mclk_16xx = {
@@ -524,9 +597,13 @@ static struct clk mmc1_ck = {
 	.rate		= 48000000,
 	.flags		= ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
 	.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_0),
-	.enable_bit	= 23,
+	.enable_bit	= CONF_MOD_MMC_SD_CLK_REQ_R,
 };
 
+/*
+ * XXX MOD_CONF_CTRL_0 bit 20 is defined in the 1510 TRM as
+ * CONF_MOD_MCBSP3_AUXON ??
+ */
 static struct clk mmc2_ck = {
 	.name		= "mmc2_ck",
 	.ops		= &clkops_generic,
@@ -546,7 +623,7 @@ static struct clk mmc3_ck = {
 	.rate		= 48000000,
 	.flags		= ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
 	.enable_reg	= OMAP1_IO_ADDRESS(SOFT_REQ_REG),
-	.enable_bit	= 12,
+	.enable_bit	= SOFT_MMC_DPLL_REQ_SHIFT,
 };
 
 static struct clk virtual_ck_mpu = {

commit 7c43d5472878db90d0244551370f6f0dc1b97747
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Mon Feb 22 22:09:40 2010 -0700

    OMAP4: clock: Add dummy clock nodes for interface clocks
    
    On OMAP4 platform the iclk control is completly under hardware control
    and no software control is available.
    
    This difference w.r.t previous OMAP's needs all the common driver
    accross OMAP's , cpu_is_xxxx() checks. To avoid poulluting the
    drivers dummy clock nodes are created (The autogeneration
    script has been updated accordingly).
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    [paul@pwsan.com: made OMAP1 dummy_ck common and edited patch to reuse that]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index 8b1d14d1e38e..aa8558adbf1c 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -27,12 +27,6 @@
  * Omap1 clocks
  *-------------------------------------------------------------------------*/
 
-/* XXX is this necessary? */
-static struct clk dummy_ck = {
-	.name	= "dummy",
-	.ops	= &clkops_dummy,
-};
-
 static struct clk ck_ref = {
 	.name		= "ck_ref",
 	.ops		= &clkops_null,

commit 51c19541624f5588bccb9d4fb3ae518c68c8082e
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Feb 22 22:09:26 2010 -0700

    OMAP clock: drop RATE_FIXED clock flag
    
    The RATE_FIXED clock flag is pointless.  In the OMAP1 clock code, it
    simply causes the omap1_clk_round_rate() function to return the
    current rate of the clock.  omap1_clk_round_rate(), however, should
    never be called for a fixed-rate clock, since none of these clocks
    have a .round_rate function pointer set in their struct clk records.
    Similarly, in the OMAP2+ clock code, the RATE_FIXED flag just causes
    the clock code to emit a warning if the OMAP clock maintainer was
    foolish enough to add a .round_rate function pointer to a fixed-rate
    clock.  "Doctor, it hurts when I pretend that a fixed-rate clock is
    rate-changeable."  "Then don't pretend that a fixed-rate clock is
    rate-changeable."  It has no functional value.  This patch drops the
    RATE_FIXED clock flag, removing it from all clocks that are so marked.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Richard Woodruff <r-woodruff2@ti.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index cea91cdf624d..8b1d14d1e38e 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -1,7 +1,7 @@
 /*
  *  linux/arch/arm/mach-omap1/clock_data.c
  *
- *  Copyright (C) 2004 - 2005, 2009 Nokia corporation
+ *  Copyright (C) 2004 - 2005, 2009-2010 Nokia Corporation
  *  Written by Tuukka Tikkanen <tuukka.tikkanen@elektrobit.com>
  *  Based on clocks.h by Tony Lindgren, Gordon McNutt and RidgeRun, Inc
  *
@@ -31,7 +31,6 @@
 static struct clk dummy_ck = {
 	.name	= "dummy",
 	.ops	= &clkops_dummy,
-	.flags	= RATE_FIXED,
 };
 
 static struct clk ck_ref = {
@@ -389,8 +388,7 @@ static struct uart_clk uart1_16xx = {
 		/* Direct from ULPD, no real parent */
 		.parent		= &armper_ck.clk,
 		.rate		= 48000000,
-		.flags		= RATE_FIXED | ENABLE_REG_32BIT |
-				  CLOCK_NO_IDLE_PARENT,
+		.flags		= ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
 		.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_0),
 		.enable_bit	= 29,
 	},
@@ -430,8 +428,7 @@ static struct uart_clk uart3_16xx = {
 		/* Direct from ULPD, no real parent */
 		.parent		= &armper_ck.clk,
 		.rate		= 48000000,
-		.flags		= RATE_FIXED | ENABLE_REG_32BIT |
-				  CLOCK_NO_IDLE_PARENT,
+		.flags		= ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
 		.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_0),
 		.enable_bit	= 31,
 	},
@@ -443,7 +440,7 @@ static struct clk usb_clko = {	/* 6 MHz output on W4_USB_CLKO */
 	.ops		= &clkops_generic,
 	/* Direct from ULPD, no parent */
 	.rate		= 6000000,
-	.flags		= RATE_FIXED | ENABLE_REG_32BIT,
+	.flags		= ENABLE_REG_32BIT,
 	.enable_reg	= OMAP1_IO_ADDRESS(ULPD_CLOCK_CTRL),
 	.enable_bit	= USB_MCLK_EN_BIT,
 };
@@ -453,7 +450,7 @@ static struct clk usb_hhc_ck1510 = {
 	.ops		= &clkops_generic,
 	/* Direct from ULPD, no parent */
 	.rate		= 48000000, /* Actually 2 clocks, 12MHz and 48MHz */
-	.flags		= RATE_FIXED | ENABLE_REG_32BIT,
+	.flags		= ENABLE_REG_32BIT,
 	.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_0),
 	.enable_bit	= USB_HOST_HHC_UHOST_EN,
 };
@@ -464,7 +461,7 @@ static struct clk usb_hhc_ck16xx = {
 	/* Direct from ULPD, no parent */
 	.rate		= 48000000,
 	/* OTG_SYSCON_2.OTG_PADEN == 0 (not 1510-compatible) */
-	.flags		= RATE_FIXED | ENABLE_REG_32BIT,
+	.flags		= ENABLE_REG_32BIT,
 	.enable_reg	= OMAP1_IO_ADDRESS(OTG_BASE + 0x08), /* OTG_SYSCON_2 */
 	.enable_bit	= 8 /* UHOST_EN */,
 };
@@ -474,7 +471,6 @@ static struct clk usb_dc_ck = {
 	.ops		= &clkops_generic,
 	/* Direct from ULPD, no parent */
 	.rate		= 48000000,
-	.flags		= RATE_FIXED,
 	.enable_reg	= OMAP1_IO_ADDRESS(SOFT_REQ_REG),
 	.enable_bit	= 4,
 };
@@ -484,7 +480,6 @@ static struct clk usb_dc_ck7xx = {
 	.ops		= &clkops_generic,
 	/* Direct from ULPD, no parent */
 	.rate		= 48000000,
-	.flags		= RATE_FIXED,
 	.enable_reg	= OMAP1_IO_ADDRESS(SOFT_REQ_REG),
 	.enable_bit	= 8,
 };
@@ -494,7 +489,6 @@ static struct clk mclk_1510 = {
 	.ops		= &clkops_generic,
 	/* Direct from ULPD, no parent. May be enabled by ext hardware. */
 	.rate		= 12000000,
-	.flags		= RATE_FIXED,
 	.enable_reg	= OMAP1_IO_ADDRESS(SOFT_REQ_REG),
 	.enable_bit	= 6,
 };
@@ -515,7 +509,6 @@ static struct clk bclk_1510 = {
 	.ops		= &clkops_generic,
 	/* Direct from ULPD, no parent. May be enabled by ext hardware. */
 	.rate		= 12000000,
-	.flags		= RATE_FIXED,
 };
 
 static struct clk bclk_16xx = {
@@ -535,7 +528,7 @@ static struct clk mmc1_ck = {
 	/* Functional clock is direct from ULPD, interface clock is ARMPER */
 	.parent		= &armper_ck.clk,
 	.rate		= 48000000,
-	.flags		= RATE_FIXED | ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
+	.flags		= ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
 	.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_0),
 	.enable_bit	= 23,
 };
@@ -546,7 +539,7 @@ static struct clk mmc2_ck = {
 	/* Functional clock is direct from ULPD, interface clock is ARMPER */
 	.parent		= &armper_ck.clk,
 	.rate		= 48000000,
-	.flags		= RATE_FIXED | ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
+	.flags		= ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
 	.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_0),
 	.enable_bit	= 20,
 };
@@ -557,7 +550,7 @@ static struct clk mmc3_ck = {
 	/* Functional clock is direct from ULPD, interface clock is ARMPER */
 	.parent		= &armper_ck.clk,
 	.rate		= 48000000,
-	.flags		= RATE_FIXED | ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
+	.flags		= ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
 	.enable_reg	= OMAP1_IO_ADDRESS(SOFT_REQ_REG),
 	.enable_bit	= 12,
 };

commit b92c170d019db7554db95380d2e1dfb3a368e350
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Feb 22 22:09:19 2010 -0700

    OMAP clock: drop .id field; ensure each clock has a unique name
    
    After the clkdev conversion, the struct clk.id field became
    superfluous, so, drop it.  Bring the clock names closer to the TRMs
    and ensure they are unique for debugfs.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index edefb3440d30..cea91cdf624d 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -530,7 +530,7 @@ static struct clk bclk_16xx = {
 };
 
 static struct clk mmc1_ck = {
-	.name		= "mmc_ck",
+	.name		= "mmc1_ck",
 	.ops		= &clkops_generic,
 	/* Functional clock is direct from ULPD, interface clock is ARMPER */
 	.parent		= &armper_ck.clk,
@@ -541,8 +541,7 @@ static struct clk mmc1_ck = {
 };
 
 static struct clk mmc2_ck = {
-	.name		= "mmc_ck",
-	.id		= 1,
+	.name		= "mmc2_ck",
 	.ops		= &clkops_generic,
 	/* Functional clock is direct from ULPD, interface clock is ARMPER */
 	.parent		= &armper_ck.clk,
@@ -553,8 +552,7 @@ static struct clk mmc2_ck = {
 };
 
 static struct clk mmc3_ck = {
-	.name		= "mmc_ck",
-	.id		= 2,
+	.name		= "mmc3_ck",
 	.ops		= &clkops_generic,
 	/* Functional clock is direct from ULPD, interface clock is ARMPER */
 	.parent		= &armper_ck.clk,
@@ -577,7 +575,6 @@ static struct clk virtual_ck_mpu = {
 remains active during MPU idle whenever this is enabled */
 static struct clk i2c_fck = {
 	.name		= "i2c_fck",
-	.id		= 1,
 	.ops		= &clkops_null,
 	.flags		= CLOCK_NO_IDLE_PARENT,
 	.parent		= &armxor_ck.clk,
@@ -586,7 +583,6 @@ static struct clk i2c_fck = {
 
 static struct clk i2c_ick = {
 	.name		= "i2c_ick",
-	.id		= 1,
 	.ops		= &clkops_null,
 	.flags		= CLOCK_NO_IDLE_PARENT,
 	.parent		= &armper_ck.clk,

commit 0dfc242ff05fcc4bbef1e1bf4eed6f7d01e0cb44
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Jan 26 20:12:57 2010 -0700

    OMAP1 clock: convert armwdt_ck to use the fixed divisor recalc function
    
    The armwdt_ck clock uses a fixed divisor, so it can use the OMAP clock
    fixed divisor recalculation code, rather than a custom function.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index 65e7b5b85d83..edefb3440d30 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -149,7 +149,8 @@ static struct arm_idlect1_clk armwdt_ck = {
 		.flags		= CLOCK_IDLE_CONTROL,
 		.enable_reg	= OMAP1_IO_ADDRESS(ARM_IDLECT2),
 		.enable_bit	= EN_WDTCK,
-		.recalc		= &omap1_watchdog_recalc,
+		.fixed_div	= 14,
+		.recalc		= &omap_fixed_divisor_recalc,
 	},
 	.idlect_shift	= 0,
 };

commit 27dba4bcf87494e2909f6b0035f0a9a038e80f83
Merge: 342aa2c1721e cdf1a915569e
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Jan 8 14:27:56 2010 -0800

    Merge branch 'for_2.6.33rc_c' of git://git.pwsan.com/linux-2.6 into omap-fixes-for-linus

commit 9b11769f998e138cbc89ba822316aa3e63912856
Author: Cory Maccarrone <darkstar6262@gmail.com>
Date:   Fri Jan 8 15:23:14 2010 -0700

    OMAP1 clock: remove __initdata from struct clk_functions to prevent crash
    
    Commit 52650505fbf3a6ab851c801f54e73e76c55ab8da added an __initdata
    decoration to the structure containing the clk_enable and clk_disable
    functions.  Once init data was freed, these pointers went to null, and
    the next enable or disable call caused the kernel to crash.  This
    change removes this decoration.
    
    Signed-off-by: Cory Maccarrone <darkstar6262@gmail.com>
    [paul@pwsan.com: patch manually split and commit message edited]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index 31fba077142c..8a85bbb6bb00 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -674,7 +674,7 @@ static struct omap_clk omap_clks[] = {
  * init
  */
 
-static struct clk_functions omap1_clk_functions __initdata = {
+static struct clk_functions omap1_clk_functions = {
 	.clk_enable		= omap1_clk_enable,
 	.clk_disable		= omap1_clk_disable,
 	.clk_round_rate		= omap1_clk_round_rate,

commit e8ae6b6e4dec43db4ae6fc67550fe63f16247667
Author: Cory Maccarrone <darkstar6262@gmail.com>
Date:   Fri Jan 8 15:23:10 2010 -0700

    OMAP1 clock: Add missing clocks for OMAP 7xx
    
    This change adds in some missing clocks that were needed as a result
    of 526505... (OMAP1 clock: convert mach-omap1/clock.h to
    mach-omap1/clock_data.c).  Prior to this, it was just assumed that
    these clocks existed for all devices, and it was used directly instead
    of calling it out with a clock_get call or similar.  So, not having
    the CK_7XX meant these clocks weren't being used anymore for omap 7xx
    devices, which broke things badly.
    
    Signed-off-by: Cory Maccarrone <darkstar6262@gmail.com>
    [paul@pwsan.com: commit message edited]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index ab995a9c606c..31fba077142c 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -599,7 +599,7 @@ static struct clk i2c_ick = {
 static struct omap_clk omap_clks[] = {
 	/* non-ULPD clocks */
 	CLK(NULL,	"ck_ref",	&ck_ref,	CK_16XX | CK_1510 | CK_310 | CK_7XX),
-	CLK(NULL,	"ck_dpll1",	&ck_dpll1,	CK_16XX | CK_1510 | CK_310),
+	CLK(NULL,	"ck_dpll1",	&ck_dpll1,	CK_16XX | CK_1510 | CK_310 | CK_7XX),
 	/* CK_GEN1 clocks */
 	CLK(NULL,	"ck_dpll1out",	&ck_dpll1out.clk, CK_16XX),
 	CLK(NULL,	"ck_sossi",	&sossi_ck,	CK_16XX),
@@ -627,7 +627,7 @@ static struct omap_clk omap_clks[] = {
 	CLK(NULL,	"tc2_ck",	&tc2_ck,	CK_16XX),
 	CLK(NULL,	"dma_ck",	&dma_ck,	CK_16XX | CK_1510 | CK_310),
 	CLK(NULL,	"dma_lcdfree_ck", &dma_lcdfree_ck, CK_16XX),
-	CLK(NULL,	"api_ck",	&api_ck.clk,	CK_16XX | CK_1510 | CK_310),
+	CLK(NULL,	"api_ck",	&api_ck.clk,	CK_16XX | CK_1510 | CK_310 | CK_7XX),
 	CLK(NULL,	"lb_ck",	&lb_ck.clk,	CK_1510 | CK_310),
 	CLK(NULL,	"rhea1_ck",	&rhea1_ck,	CK_16XX),
 	CLK(NULL,	"rhea2_ck",	&rhea2_ck,	CK_16XX),

commit c5c4dce45d7538ada6e9aac4cdb2909bc1cb28f6
Author: Cory Maccarrone <darkstar6262@gmail.com>
Date:   Fri Jan 8 10:29:05 2010 -0800

    omap1: Add 7xx clocks and pin muxes for SPI
    
    Commit 35c9049b27040d09461bc90928ad770be7ddf661 added
    drivers/spi/omap_spi_100k.c.
    
    This patch add the related clocks and pin muxing
    entries to make the driver work on omap7xx platforms.
    
    Signed-off-by: Cory Maccarrone <darkstar6262@gmail.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index ab995a9c606c..6887bf308aac 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -658,6 +658,10 @@ static struct omap_clk omap_clks[] = {
 	CLK("i2c_omap.1", "fck",	&i2c_fck,	CK_16XX | CK_1510 | CK_310 | CK_7XX),
 	CLK("i2c_omap.1", "ick",	&i2c_ick,	CK_16XX),
 	CLK("i2c_omap.1", "ick",	&dummy_ck,	CK_1510 | CK_310 | CK_7XX),
+	CLK("omap1_spi100k.1", "fck",	&dummy_ck,	CK_7XX),
+	CLK("omap1_spi100k.1", "ick",	&dummy_ck,	CK_7XX),
+	CLK("omap1_spi100k.2", "fck",	&dummy_ck,	CK_7XX),
+	CLK("omap1_spi100k.2", "ick",	&dummy_ck,	CK_7XX),
 	CLK("omap_uwire", "fck",	&armxor_ck.clk,	CK_16XX | CK_1510 | CK_310),
 	CLK("omap-mcbsp.1", "ick",	&dspper_ck,	CK_16XX),
 	CLK("omap-mcbsp.1", "ick",	&dummy_ck,	CK_1510 | CK_310),

commit bf92a40762fb10a394281941a46f529463c49ffc
Author: Cory Maccarrone <darkstar6262@gmail.com>
Date:   Fri Dec 11 16:16:34 2009 -0800

    omap1: I2C mux and clocks for omap7xx
    
    This change adds MUX pin configuration and clocks for I2C support
    to OMAP 730 and 850-based devices.
    
    Signed-off-by: Cory Maccarrone <darkstar6262@gmail.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
index cf5f017b392c..ab995a9c606c 100644
--- a/arch/arm/mach-omap1/clock_data.c
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -655,9 +655,9 @@ static struct omap_clk omap_clks[] = {
 	CLK("mmci-omap.1", "ick",	&armper_ck.clk,	CK_16XX),
 	/* Virtual clocks */
 	CLK(NULL,	"mpu",		&virtual_ck_mpu, CK_16XX | CK_1510 | CK_310),
-	CLK("i2c_omap.1", "fck",	&i2c_fck,	CK_16XX | CK_1510 | CK_310),
+	CLK("i2c_omap.1", "fck",	&i2c_fck,	CK_16XX | CK_1510 | CK_310 | CK_7XX),
 	CLK("i2c_omap.1", "ick",	&i2c_ick,	CK_16XX),
-	CLK("i2c_omap.1", "ick",	&dummy_ck,	CK_1510 | CK_310),
+	CLK("i2c_omap.1", "ick",	&dummy_ck,	CK_1510 | CK_310 | CK_7XX),
 	CLK("omap_uwire", "fck",	&armxor_ck.clk,	CK_16XX | CK_1510 | CK_310),
 	CLK("omap-mcbsp.1", "ick",	&dspper_ck,	CK_16XX),
 	CLK("omap-mcbsp.1", "ick",	&dummy_ck,	CK_1510 | CK_310),

commit 52650505fbf3a6ab851c801f54e73e76c55ab8da
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 8 16:29:38 2009 -0700

    OMAP1 clock: convert mach-omap1/clock.h to mach-omap1/clock_data.c
    
    The OMAP1 clock code currently #includes a large .h file full of static
    data structures.  Instead, define the data in a .c file.
    
    Russell King <linux@arm.linux.org.uk> proposed this new arrangement:
    
        http://marc.info/?l=linux-omap&m=125967425908895&w=2
    
    This patch also deals with most of the flagrant checkpatch violations.
    
    While here, separate the mpu_rate data structures out into their own
    files, opp.h and opp_data.c.  In the long run, these mpu_rate tables
    should be replaced with OPP code.
    
    Also includes a patch from Felipe Balbi <felipe.balbi@nokia.com> to
    mark omap1_clk_functions as __initdata to avoid a section warning:
    
        http://patchwork.kernel.org/patch/64366/
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Felipe Balbi <felipe.balbi@nokia.com>
    Cc: Nishanth Menon <nm@ti.com>

diff --git a/arch/arm/mach-omap1/clock_data.c b/arch/arm/mach-omap1/clock_data.c
new file mode 100644
index 000000000000..cf5f017b392c
--- /dev/null
+++ b/arch/arm/mach-omap1/clock_data.c
@@ -0,0 +1,843 @@
+/*
+ *  linux/arch/arm/mach-omap1/clock_data.c
+ *
+ *  Copyright (C) 2004 - 2005, 2009 Nokia corporation
+ *  Written by Tuukka Tikkanen <tuukka.tikkanen@elektrobit.com>
+ *  Based on clocks.h by Tony Lindgren, Gordon McNutt and RidgeRun, Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+#include <asm/mach-types.h>  /* for machine_is_* */
+
+#include <plat/clock.h>
+#include <plat/cpu.h>
+#include <plat/clkdev_omap.h>
+#include <plat/usb.h>   /* for OTG_BASE */
+
+#include "clock.h"
+
+/*------------------------------------------------------------------------
+ * Omap1 clocks
+ *-------------------------------------------------------------------------*/
+
+/* XXX is this necessary? */
+static struct clk dummy_ck = {
+	.name	= "dummy",
+	.ops	= &clkops_dummy,
+	.flags	= RATE_FIXED,
+};
+
+static struct clk ck_ref = {
+	.name		= "ck_ref",
+	.ops		= &clkops_null,
+	.rate		= 12000000,
+};
+
+static struct clk ck_dpll1 = {
+	.name		= "ck_dpll1",
+	.ops		= &clkops_null,
+	.parent		= &ck_ref,
+};
+
+/*
+ * FIXME: This clock seems to be necessary but no-one has asked for its
+ * activation.  [ FIX: SoSSI, SSR ]
+ */
+static struct arm_idlect1_clk ck_dpll1out = {
+	.clk = {
+		.name		= "ck_dpll1out",
+		.ops		= &clkops_generic,
+		.parent		= &ck_dpll1,
+		.flags		= CLOCK_IDLE_CONTROL | ENABLE_REG_32BIT |
+				  ENABLE_ON_INIT,
+		.enable_reg	= OMAP1_IO_ADDRESS(ARM_IDLECT2),
+		.enable_bit	= EN_CKOUT_ARM,
+		.recalc		= &followparent_recalc,
+	},
+	.idlect_shift	= 12,
+};
+
+static struct clk sossi_ck = {
+	.name		= "ck_sossi",
+	.ops		= &clkops_generic,
+	.parent		= &ck_dpll1out.clk,
+	.flags		= CLOCK_NO_IDLE_PARENT | ENABLE_REG_32BIT,
+	.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_1),
+	.enable_bit	= 16,
+	.recalc		= &omap1_sossi_recalc,
+	.set_rate	= &omap1_set_sossi_rate,
+};
+
+static struct clk arm_ck = {
+	.name		= "arm_ck",
+	.ops		= &clkops_null,
+	.parent		= &ck_dpll1,
+	.rate_offset	= CKCTL_ARMDIV_OFFSET,
+	.recalc		= &omap1_ckctl_recalc,
+	.round_rate	= omap1_clk_round_rate_ckctl_arm,
+	.set_rate	= omap1_clk_set_rate_ckctl_arm,
+};
+
+static struct arm_idlect1_clk armper_ck = {
+	.clk = {
+		.name		= "armper_ck",
+		.ops		= &clkops_generic,
+		.parent		= &ck_dpll1,
+		.flags		= CLOCK_IDLE_CONTROL,
+		.enable_reg	= OMAP1_IO_ADDRESS(ARM_IDLECT2),
+		.enable_bit	= EN_PERCK,
+		.rate_offset	= CKCTL_PERDIV_OFFSET,
+		.recalc		= &omap1_ckctl_recalc,
+		.round_rate	= omap1_clk_round_rate_ckctl_arm,
+		.set_rate	= omap1_clk_set_rate_ckctl_arm,
+	},
+	.idlect_shift	= 2,
+};
+
+/*
+ * FIXME: This clock seems to be necessary but no-one has asked for its
+ * activation.  [ GPIO code for 1510 ]
+ */
+static struct clk arm_gpio_ck = {
+	.name		= "arm_gpio_ck",
+	.ops		= &clkops_generic,
+	.parent		= &ck_dpll1,
+	.flags		= ENABLE_ON_INIT,
+	.enable_reg	= OMAP1_IO_ADDRESS(ARM_IDLECT2),
+	.enable_bit	= EN_GPIOCK,
+	.recalc		= &followparent_recalc,
+};
+
+static struct arm_idlect1_clk armxor_ck = {
+	.clk = {
+		.name		= "armxor_ck",
+		.ops		= &clkops_generic,
+		.parent		= &ck_ref,
+		.flags		= CLOCK_IDLE_CONTROL,
+		.enable_reg	= OMAP1_IO_ADDRESS(ARM_IDLECT2),
+		.enable_bit	= EN_XORPCK,
+		.recalc		= &followparent_recalc,
+	},
+	.idlect_shift	= 1,
+};
+
+static struct arm_idlect1_clk armtim_ck = {
+	.clk = {
+		.name		= "armtim_ck",
+		.ops		= &clkops_generic,
+		.parent		= &ck_ref,
+		.flags		= CLOCK_IDLE_CONTROL,
+		.enable_reg	= OMAP1_IO_ADDRESS(ARM_IDLECT2),
+		.enable_bit	= EN_TIMCK,
+		.recalc		= &followparent_recalc,
+	},
+	.idlect_shift	= 9,
+};
+
+static struct arm_idlect1_clk armwdt_ck = {
+	.clk = {
+		.name		= "armwdt_ck",
+		.ops		= &clkops_generic,
+		.parent		= &ck_ref,
+		.flags		= CLOCK_IDLE_CONTROL,
+		.enable_reg	= OMAP1_IO_ADDRESS(ARM_IDLECT2),
+		.enable_bit	= EN_WDTCK,
+		.recalc		= &omap1_watchdog_recalc,
+	},
+	.idlect_shift	= 0,
+};
+
+static struct clk arminth_ck16xx = {
+	.name		= "arminth_ck",
+	.ops		= &clkops_null,
+	.parent		= &arm_ck,
+	.recalc		= &followparent_recalc,
+	/* Note: On 16xx the frequency can be divided by 2 by programming
+	 * ARM_CKCTL:ARM_INTHCK_SEL(14) to 1
+	 *
+	 * 1510 version is in TC clocks.
+	 */
+};
+
+static struct clk dsp_ck = {
+	.name		= "dsp_ck",
+	.ops		= &clkops_generic,
+	.parent		= &ck_dpll1,
+	.enable_reg	= OMAP1_IO_ADDRESS(ARM_CKCTL),
+	.enable_bit	= EN_DSPCK,
+	.rate_offset	= CKCTL_DSPDIV_OFFSET,
+	.recalc		= &omap1_ckctl_recalc,
+	.round_rate	= omap1_clk_round_rate_ckctl_arm,
+	.set_rate	= omap1_clk_set_rate_ckctl_arm,
+};
+
+static struct clk dspmmu_ck = {
+	.name		= "dspmmu_ck",
+	.ops		= &clkops_null,
+	.parent		= &ck_dpll1,
+	.rate_offset	= CKCTL_DSPMMUDIV_OFFSET,
+	.recalc		= &omap1_ckctl_recalc,
+	.round_rate	= omap1_clk_round_rate_ckctl_arm,
+	.set_rate	= omap1_clk_set_rate_ckctl_arm,
+};
+
+static struct clk dspper_ck = {
+	.name		= "dspper_ck",
+	.ops		= &clkops_dspck,
+	.parent		= &ck_dpll1,
+	.enable_reg	= DSP_IDLECT2,
+	.enable_bit	= EN_PERCK,
+	.rate_offset	= CKCTL_PERDIV_OFFSET,
+	.recalc		= &omap1_ckctl_recalc_dsp_domain,
+	.round_rate	= omap1_clk_round_rate_ckctl_arm,
+	.set_rate	= &omap1_clk_set_rate_dsp_domain,
+};
+
+static struct clk dspxor_ck = {
+	.name		= "dspxor_ck",
+	.ops		= &clkops_dspck,
+	.parent		= &ck_ref,
+	.enable_reg	= DSP_IDLECT2,
+	.enable_bit	= EN_XORPCK,
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk dsptim_ck = {
+	.name		= "dsptim_ck",
+	.ops		= &clkops_dspck,
+	.parent		= &ck_ref,
+	.enable_reg	= DSP_IDLECT2,
+	.enable_bit	= EN_DSPTIMCK,
+	.recalc		= &followparent_recalc,
+};
+
+/* Tie ARM_IDLECT1:IDLIF_ARM to this logical clock structure */
+static struct arm_idlect1_clk tc_ck = {
+	.clk = {
+		.name		= "tc_ck",
+		.ops		= &clkops_null,
+		.parent		= &ck_dpll1,
+		.flags		= CLOCK_IDLE_CONTROL,
+		.rate_offset	= CKCTL_TCDIV_OFFSET,
+		.recalc		= &omap1_ckctl_recalc,
+		.round_rate	= omap1_clk_round_rate_ckctl_arm,
+		.set_rate	= omap1_clk_set_rate_ckctl_arm,
+	},
+	.idlect_shift	= 6,
+};
+
+static struct clk arminth_ck1510 = {
+	.name		= "arminth_ck",
+	.ops		= &clkops_null,
+	.parent		= &tc_ck.clk,
+	.recalc		= &followparent_recalc,
+	/* Note: On 1510 the frequency follows TC_CK
+	 *
+	 * 16xx version is in MPU clocks.
+	 */
+};
+
+static struct clk tipb_ck = {
+	/* No-idle controlled by "tc_ck" */
+	.name		= "tipb_ck",
+	.ops		= &clkops_null,
+	.parent		= &tc_ck.clk,
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk l3_ocpi_ck = {
+	/* No-idle controlled by "tc_ck" */
+	.name		= "l3_ocpi_ck",
+	.ops		= &clkops_generic,
+	.parent		= &tc_ck.clk,
+	.enable_reg	= OMAP1_IO_ADDRESS(ARM_IDLECT3),
+	.enable_bit	= EN_OCPI_CK,
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk tc1_ck = {
+	.name		= "tc1_ck",
+	.ops		= &clkops_generic,
+	.parent		= &tc_ck.clk,
+	.enable_reg	= OMAP1_IO_ADDRESS(ARM_IDLECT3),
+	.enable_bit	= EN_TC1_CK,
+	.recalc		= &followparent_recalc,
+};
+
+/*
+ * FIXME: This clock seems to be necessary but no-one has asked for its
+ * activation.  [ pm.c (SRAM), CCP, Camera ]
+ */
+static struct clk tc2_ck = {
+	.name		= "tc2_ck",
+	.ops		= &clkops_generic,
+	.parent		= &tc_ck.clk,
+	.flags		= ENABLE_ON_INIT,
+	.enable_reg	= OMAP1_IO_ADDRESS(ARM_IDLECT3),
+	.enable_bit	= EN_TC2_CK,
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk dma_ck = {
+	/* No-idle controlled by "tc_ck" */
+	.name		= "dma_ck",
+	.ops		= &clkops_null,
+	.parent		= &tc_ck.clk,
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk dma_lcdfree_ck = {
+	.name		= "dma_lcdfree_ck",
+	.ops		= &clkops_null,
+	.parent		= &tc_ck.clk,
+	.recalc		= &followparent_recalc,
+};
+
+static struct arm_idlect1_clk api_ck = {
+	.clk = {
+		.name		= "api_ck",
+		.ops		= &clkops_generic,
+		.parent		= &tc_ck.clk,
+		.flags		= CLOCK_IDLE_CONTROL,
+		.enable_reg	= OMAP1_IO_ADDRESS(ARM_IDLECT2),
+		.enable_bit	= EN_APICK,
+		.recalc		= &followparent_recalc,
+	},
+	.idlect_shift	= 8,
+};
+
+static struct arm_idlect1_clk lb_ck = {
+	.clk = {
+		.name		= "lb_ck",
+		.ops		= &clkops_generic,
+		.parent		= &tc_ck.clk,
+		.flags		= CLOCK_IDLE_CONTROL,
+		.enable_reg	= OMAP1_IO_ADDRESS(ARM_IDLECT2),
+		.enable_bit	= EN_LBCK,
+		.recalc		= &followparent_recalc,
+	},
+	.idlect_shift	= 4,
+};
+
+static struct clk rhea1_ck = {
+	.name		= "rhea1_ck",
+	.ops		= &clkops_null,
+	.parent		= &tc_ck.clk,
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk rhea2_ck = {
+	.name		= "rhea2_ck",
+	.ops		= &clkops_null,
+	.parent		= &tc_ck.clk,
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk lcd_ck_16xx = {
+	.name		= "lcd_ck",
+	.ops		= &clkops_generic,
+	.parent		= &ck_dpll1,
+	.enable_reg	= OMAP1_IO_ADDRESS(ARM_IDLECT2),
+	.enable_bit	= EN_LCDCK,
+	.rate_offset	= CKCTL_LCDDIV_OFFSET,
+	.recalc		= &omap1_ckctl_recalc,
+	.round_rate	= omap1_clk_round_rate_ckctl_arm,
+	.set_rate	= omap1_clk_set_rate_ckctl_arm,
+};
+
+static struct arm_idlect1_clk lcd_ck_1510 = {
+	.clk = {
+		.name		= "lcd_ck",
+		.ops		= &clkops_generic,
+		.parent		= &ck_dpll1,
+		.flags		= CLOCK_IDLE_CONTROL,
+		.enable_reg	= OMAP1_IO_ADDRESS(ARM_IDLECT2),
+		.enable_bit	= EN_LCDCK,
+		.rate_offset	= CKCTL_LCDDIV_OFFSET,
+		.recalc		= &omap1_ckctl_recalc,
+		.round_rate	= omap1_clk_round_rate_ckctl_arm,
+		.set_rate	= omap1_clk_set_rate_ckctl_arm,
+	},
+	.idlect_shift	= 3,
+};
+
+static struct clk uart1_1510 = {
+	.name		= "uart1_ck",
+	.ops		= &clkops_null,
+	/* Direct from ULPD, no real parent */
+	.parent		= &armper_ck.clk,
+	.rate		= 12000000,
+	.flags		= ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
+	.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_0),
+	.enable_bit	= 29,	/* Chooses between 12MHz and 48MHz */
+	.set_rate	= &omap1_set_uart_rate,
+	.recalc		= &omap1_uart_recalc,
+};
+
+static struct uart_clk uart1_16xx = {
+	.clk	= {
+		.name		= "uart1_ck",
+		.ops		= &clkops_uart,
+		/* Direct from ULPD, no real parent */
+		.parent		= &armper_ck.clk,
+		.rate		= 48000000,
+		.flags		= RATE_FIXED | ENABLE_REG_32BIT |
+				  CLOCK_NO_IDLE_PARENT,
+		.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_0),
+		.enable_bit	= 29,
+	},
+	.sysc_addr	= 0xfffb0054,
+};
+
+static struct clk uart2_ck = {
+	.name		= "uart2_ck",
+	.ops		= &clkops_null,
+	/* Direct from ULPD, no real parent */
+	.parent		= &armper_ck.clk,
+	.rate		= 12000000,
+	.flags		= ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
+	.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_0),
+	.enable_bit	= 30,	/* Chooses between 12MHz and 48MHz */
+	.set_rate	= &omap1_set_uart_rate,
+	.recalc		= &omap1_uart_recalc,
+};
+
+static struct clk uart3_1510 = {
+	.name		= "uart3_ck",
+	.ops		= &clkops_null,
+	/* Direct from ULPD, no real parent */
+	.parent		= &armper_ck.clk,
+	.rate		= 12000000,
+	.flags		= ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
+	.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_0),
+	.enable_bit	= 31,	/* Chooses between 12MHz and 48MHz */
+	.set_rate	= &omap1_set_uart_rate,
+	.recalc		= &omap1_uart_recalc,
+};
+
+static struct uart_clk uart3_16xx = {
+	.clk	= {
+		.name		= "uart3_ck",
+		.ops		= &clkops_uart,
+		/* Direct from ULPD, no real parent */
+		.parent		= &armper_ck.clk,
+		.rate		= 48000000,
+		.flags		= RATE_FIXED | ENABLE_REG_32BIT |
+				  CLOCK_NO_IDLE_PARENT,
+		.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_0),
+		.enable_bit	= 31,
+	},
+	.sysc_addr	= 0xfffb9854,
+};
+
+static struct clk usb_clko = {	/* 6 MHz output on W4_USB_CLKO */
+	.name		= "usb_clko",
+	.ops		= &clkops_generic,
+	/* Direct from ULPD, no parent */
+	.rate		= 6000000,
+	.flags		= RATE_FIXED | ENABLE_REG_32BIT,
+	.enable_reg	= OMAP1_IO_ADDRESS(ULPD_CLOCK_CTRL),
+	.enable_bit	= USB_MCLK_EN_BIT,
+};
+
+static struct clk usb_hhc_ck1510 = {
+	.name		= "usb_hhc_ck",
+	.ops		= &clkops_generic,
+	/* Direct from ULPD, no parent */
+	.rate		= 48000000, /* Actually 2 clocks, 12MHz and 48MHz */
+	.flags		= RATE_FIXED | ENABLE_REG_32BIT,
+	.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_0),
+	.enable_bit	= USB_HOST_HHC_UHOST_EN,
+};
+
+static struct clk usb_hhc_ck16xx = {
+	.name		= "usb_hhc_ck",
+	.ops		= &clkops_generic,
+	/* Direct from ULPD, no parent */
+	.rate		= 48000000,
+	/* OTG_SYSCON_2.OTG_PADEN == 0 (not 1510-compatible) */
+	.flags		= RATE_FIXED | ENABLE_REG_32BIT,
+	.enable_reg	= OMAP1_IO_ADDRESS(OTG_BASE + 0x08), /* OTG_SYSCON_2 */
+	.enable_bit	= 8 /* UHOST_EN */,
+};
+
+static struct clk usb_dc_ck = {
+	.name		= "usb_dc_ck",
+	.ops		= &clkops_generic,
+	/* Direct from ULPD, no parent */
+	.rate		= 48000000,
+	.flags		= RATE_FIXED,
+	.enable_reg	= OMAP1_IO_ADDRESS(SOFT_REQ_REG),
+	.enable_bit	= 4,
+};
+
+static struct clk usb_dc_ck7xx = {
+	.name		= "usb_dc_ck",
+	.ops		= &clkops_generic,
+	/* Direct from ULPD, no parent */
+	.rate		= 48000000,
+	.flags		= RATE_FIXED,
+	.enable_reg	= OMAP1_IO_ADDRESS(SOFT_REQ_REG),
+	.enable_bit	= 8,
+};
+
+static struct clk mclk_1510 = {
+	.name		= "mclk",
+	.ops		= &clkops_generic,
+	/* Direct from ULPD, no parent. May be enabled by ext hardware. */
+	.rate		= 12000000,
+	.flags		= RATE_FIXED,
+	.enable_reg	= OMAP1_IO_ADDRESS(SOFT_REQ_REG),
+	.enable_bit	= 6,
+};
+
+static struct clk mclk_16xx = {
+	.name		= "mclk",
+	.ops		= &clkops_generic,
+	/* Direct from ULPD, no parent. May be enabled by ext hardware. */
+	.enable_reg	= OMAP1_IO_ADDRESS(COM_CLK_DIV_CTRL_SEL),
+	.enable_bit	= COM_ULPD_PLL_CLK_REQ,
+	.set_rate	= &omap1_set_ext_clk_rate,
+	.round_rate	= &omap1_round_ext_clk_rate,
+	.init		= &omap1_init_ext_clk,
+};
+
+static struct clk bclk_1510 = {
+	.name		= "bclk",
+	.ops		= &clkops_generic,
+	/* Direct from ULPD, no parent. May be enabled by ext hardware. */
+	.rate		= 12000000,
+	.flags		= RATE_FIXED,
+};
+
+static struct clk bclk_16xx = {
+	.name		= "bclk",
+	.ops		= &clkops_generic,
+	/* Direct from ULPD, no parent. May be enabled by ext hardware. */
+	.enable_reg	= OMAP1_IO_ADDRESS(SWD_CLK_DIV_CTRL_SEL),
+	.enable_bit	= SWD_ULPD_PLL_CLK_REQ,
+	.set_rate	= &omap1_set_ext_clk_rate,
+	.round_rate	= &omap1_round_ext_clk_rate,
+	.init		= &omap1_init_ext_clk,
+};
+
+static struct clk mmc1_ck = {
+	.name		= "mmc_ck",
+	.ops		= &clkops_generic,
+	/* Functional clock is direct from ULPD, interface clock is ARMPER */
+	.parent		= &armper_ck.clk,
+	.rate		= 48000000,
+	.flags		= RATE_FIXED | ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
+	.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_0),
+	.enable_bit	= 23,
+};
+
+static struct clk mmc2_ck = {
+	.name		= "mmc_ck",
+	.id		= 1,
+	.ops		= &clkops_generic,
+	/* Functional clock is direct from ULPD, interface clock is ARMPER */
+	.parent		= &armper_ck.clk,
+	.rate		= 48000000,
+	.flags		= RATE_FIXED | ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
+	.enable_reg	= OMAP1_IO_ADDRESS(MOD_CONF_CTRL_0),
+	.enable_bit	= 20,
+};
+
+static struct clk mmc3_ck = {
+	.name		= "mmc_ck",
+	.id		= 2,
+	.ops		= &clkops_generic,
+	/* Functional clock is direct from ULPD, interface clock is ARMPER */
+	.parent		= &armper_ck.clk,
+	.rate		= 48000000,
+	.flags		= RATE_FIXED | ENABLE_REG_32BIT | CLOCK_NO_IDLE_PARENT,
+	.enable_reg	= OMAP1_IO_ADDRESS(SOFT_REQ_REG),
+	.enable_bit	= 12,
+};
+
+static struct clk virtual_ck_mpu = {
+	.name		= "mpu",
+	.ops		= &clkops_null,
+	.parent		= &arm_ck, /* Is smarter alias for */
+	.recalc		= &followparent_recalc,
+	.set_rate	= &omap1_select_table_rate,
+	.round_rate	= &omap1_round_to_table_rate,
+};
+
+/* virtual functional clock domain for I2C. Just for making sure that ARMXOR_CK
+remains active during MPU idle whenever this is enabled */
+static struct clk i2c_fck = {
+	.name		= "i2c_fck",
+	.id		= 1,
+	.ops		= &clkops_null,
+	.flags		= CLOCK_NO_IDLE_PARENT,
+	.parent		= &armxor_ck.clk,
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk i2c_ick = {
+	.name		= "i2c_ick",
+	.id		= 1,
+	.ops		= &clkops_null,
+	.flags		= CLOCK_NO_IDLE_PARENT,
+	.parent		= &armper_ck.clk,
+	.recalc		= &followparent_recalc,
+};
+
+/*
+ * clkdev integration
+ */
+
+static struct omap_clk omap_clks[] = {
+	/* non-ULPD clocks */
+	CLK(NULL,	"ck_ref",	&ck_ref,	CK_16XX | CK_1510 | CK_310 | CK_7XX),
+	CLK(NULL,	"ck_dpll1",	&ck_dpll1,	CK_16XX | CK_1510 | CK_310),
+	/* CK_GEN1 clocks */
+	CLK(NULL,	"ck_dpll1out",	&ck_dpll1out.clk, CK_16XX),
+	CLK(NULL,	"ck_sossi",	&sossi_ck,	CK_16XX),
+	CLK(NULL,	"arm_ck",	&arm_ck,	CK_16XX | CK_1510 | CK_310),
+	CLK(NULL,	"armper_ck",	&armper_ck.clk,	CK_16XX | CK_1510 | CK_310),
+	CLK(NULL,	"arm_gpio_ck",	&arm_gpio_ck,	CK_1510 | CK_310),
+	CLK(NULL,	"armxor_ck",	&armxor_ck.clk,	CK_16XX | CK_1510 | CK_310 | CK_7XX),
+	CLK(NULL,	"armtim_ck",	&armtim_ck.clk,	CK_16XX | CK_1510 | CK_310),
+	CLK("omap_wdt",	"fck",		&armwdt_ck.clk,	CK_16XX | CK_1510 | CK_310),
+	CLK("omap_wdt",	"ick",		&armper_ck.clk,	CK_16XX),
+	CLK("omap_wdt", "ick",		&dummy_ck,	CK_1510 | CK_310),
+	CLK(NULL,	"arminth_ck",	&arminth_ck1510, CK_1510 | CK_310),
+	CLK(NULL,	"arminth_ck",	&arminth_ck16xx, CK_16XX),
+	/* CK_GEN2 clocks */
+	CLK(NULL,	"dsp_ck",	&dsp_ck,	CK_16XX | CK_1510 | CK_310),
+	CLK(NULL,	"dspmmu_ck",	&dspmmu_ck,	CK_16XX | CK_1510 | CK_310),
+	CLK(NULL,	"dspper_ck",	&dspper_ck,	CK_16XX | CK_1510 | CK_310),
+	CLK(NULL,	"dspxor_ck",	&dspxor_ck,	CK_16XX | CK_1510 | CK_310),
+	CLK(NULL,	"dsptim_ck",	&dsptim_ck,	CK_16XX | CK_1510 | CK_310),
+	/* CK_GEN3 clocks */
+	CLK(NULL,	"tc_ck",	&tc_ck.clk,	CK_16XX | CK_1510 | CK_310 | CK_7XX),
+	CLK(NULL,	"tipb_ck",	&tipb_ck,	CK_1510 | CK_310),
+	CLK(NULL,	"l3_ocpi_ck",	&l3_ocpi_ck,	CK_16XX | CK_7XX),
+	CLK(NULL,	"tc1_ck",	&tc1_ck,	CK_16XX),
+	CLK(NULL,	"tc2_ck",	&tc2_ck,	CK_16XX),
+	CLK(NULL,	"dma_ck",	&dma_ck,	CK_16XX | CK_1510 | CK_310),
+	CLK(NULL,	"dma_lcdfree_ck", &dma_lcdfree_ck, CK_16XX),
+	CLK(NULL,	"api_ck",	&api_ck.clk,	CK_16XX | CK_1510 | CK_310),
+	CLK(NULL,	"lb_ck",	&lb_ck.clk,	CK_1510 | CK_310),
+	CLK(NULL,	"rhea1_ck",	&rhea1_ck,	CK_16XX),
+	CLK(NULL,	"rhea2_ck",	&rhea2_ck,	CK_16XX),
+	CLK(NULL,	"lcd_ck",	&lcd_ck_16xx,	CK_16XX | CK_7XX),
+	CLK(NULL,	"lcd_ck",	&lcd_ck_1510.clk, CK_1510 | CK_310),
+	/* ULPD clocks */
+	CLK(NULL,	"uart1_ck",	&uart1_1510,	CK_1510 | CK_310),
+	CLK(NULL,	"uart1_ck",	&uart1_16xx.clk, CK_16XX),
+	CLK(NULL,	"uart2_ck",	&uart2_ck,	CK_16XX | CK_1510 | CK_310),
+	CLK(NULL,	"uart3_ck",	&uart3_1510,	CK_1510 | CK_310),
+	CLK(NULL,	"uart3_ck",	&uart3_16xx.clk, CK_16XX),
+	CLK(NULL,	"usb_clko",	&usb_clko,	CK_16XX | CK_1510 | CK_310),
+	CLK(NULL,	"usb_hhc_ck",	&usb_hhc_ck1510, CK_1510 | CK_310),
+	CLK(NULL,	"usb_hhc_ck",	&usb_hhc_ck16xx, CK_16XX),
+	CLK(NULL,	"usb_dc_ck",	&usb_dc_ck,	CK_16XX),
+	CLK(NULL,	"usb_dc_ck",	&usb_dc_ck7xx,	CK_7XX),
+	CLK(NULL,	"mclk",		&mclk_1510,	CK_1510 | CK_310),
+	CLK(NULL,	"mclk",		&mclk_16xx,	CK_16XX),
+	CLK(NULL,	"bclk",		&bclk_1510,	CK_1510 | CK_310),
+	CLK(NULL,	"bclk",		&bclk_16xx,	CK_16XX),
+	CLK("mmci-omap.0", "fck",	&mmc1_ck,	CK_16XX | CK_1510 | CK_310),
+	CLK("mmci-omap.0", "fck",	&mmc3_ck,	CK_7XX),
+	CLK("mmci-omap.0", "ick",	&armper_ck.clk,	CK_16XX | CK_1510 | CK_310 | CK_7XX),
+	CLK("mmci-omap.1", "fck",	&mmc2_ck,	CK_16XX),
+	CLK("mmci-omap.1", "ick",	&armper_ck.clk,	CK_16XX),
+	/* Virtual clocks */
+	CLK(NULL,	"mpu",		&virtual_ck_mpu, CK_16XX | CK_1510 | CK_310),
+	CLK("i2c_omap.1", "fck",	&i2c_fck,	CK_16XX | CK_1510 | CK_310),
+	CLK("i2c_omap.1", "ick",	&i2c_ick,	CK_16XX),
+	CLK("i2c_omap.1", "ick",	&dummy_ck,	CK_1510 | CK_310),
+	CLK("omap_uwire", "fck",	&armxor_ck.clk,	CK_16XX | CK_1510 | CK_310),
+	CLK("omap-mcbsp.1", "ick",	&dspper_ck,	CK_16XX),
+	CLK("omap-mcbsp.1", "ick",	&dummy_ck,	CK_1510 | CK_310),
+	CLK("omap-mcbsp.2", "ick",	&armper_ck.clk,	CK_16XX),
+	CLK("omap-mcbsp.2", "ick",	&dummy_ck,	CK_1510 | CK_310),
+	CLK("omap-mcbsp.3", "ick",	&dspper_ck,	CK_16XX),
+	CLK("omap-mcbsp.3", "ick",	&dummy_ck,	CK_1510 | CK_310),
+	CLK("omap-mcbsp.1", "fck",	&dspxor_ck,	CK_16XX | CK_1510 | CK_310),
+	CLK("omap-mcbsp.2", "fck",	&armper_ck.clk,	CK_16XX | CK_1510 | CK_310),
+	CLK("omap-mcbsp.3", "fck",	&dspxor_ck,	CK_16XX | CK_1510 | CK_310),
+};
+
+/*
+ * init
+ */
+
+static struct clk_functions omap1_clk_functions __initdata = {
+	.clk_enable		= omap1_clk_enable,
+	.clk_disable		= omap1_clk_disable,
+	.clk_round_rate		= omap1_clk_round_rate,
+	.clk_set_rate		= omap1_clk_set_rate,
+	.clk_disable_unused	= omap1_clk_disable_unused,
+};
+
+int __init omap1_clk_init(void)
+{
+	struct omap_clk *c;
+	const struct omap_clock_config *info;
+	int crystal_type = 0; /* Default 12 MHz */
+	u32 reg, cpu_mask;
+
+#ifdef CONFIG_DEBUG_LL
+	/*
+	 * Resets some clocks that may be left on from bootloader,
+	 * but leaves serial clocks on.
+	 */
+	omap_writel(0x3 << 29, MOD_CONF_CTRL_0);
+#endif
+
+	/* USB_REQ_EN will be disabled later if necessary (usb_dc_ck) */
+	reg = omap_readw(SOFT_REQ_REG) & (1 << 4);
+	omap_writew(reg, SOFT_REQ_REG);
+	if (!cpu_is_omap15xx())
+		omap_writew(0, SOFT_REQ_REG2);
+
+	clk_init(&omap1_clk_functions);
+
+	/* By default all idlect1 clocks are allowed to idle */
+	arm_idlect1_mask = ~0;
+
+	for (c = omap_clks; c < omap_clks + ARRAY_SIZE(omap_clks); c++)
+		clk_preinit(c->lk.clk);
+
+	cpu_mask = 0;
+	if (cpu_is_omap16xx())
+		cpu_mask |= CK_16XX;
+	if (cpu_is_omap1510())
+		cpu_mask |= CK_1510;
+	if (cpu_is_omap7xx())
+		cpu_mask |= CK_7XX;
+	if (cpu_is_omap310())
+		cpu_mask |= CK_310;
+
+	for (c = omap_clks; c < omap_clks + ARRAY_SIZE(omap_clks); c++)
+		if (c->cpu & cpu_mask) {
+			clkdev_add(&c->lk);
+			clk_register(c->lk.clk);
+		}
+
+	/* Pointers to these clocks are needed by code in clock.c */
+	api_ck_p = clk_get(NULL, "api_ck");
+	ck_dpll1_p = clk_get(NULL, "ck_dpll1");
+	ck_ref_p = clk_get(NULL, "ck_ref");
+
+	info = omap_get_config(OMAP_TAG_CLOCK, struct omap_clock_config);
+	if (info != NULL) {
+		if (!cpu_is_omap15xx())
+			crystal_type = info->system_clock_type;
+	}
+
+#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
+	ck_ref.rate = 13000000;
+#elif defined(CONFIG_ARCH_OMAP16XX)
+	if (crystal_type == 2)
+		ck_ref.rate = 19200000;
+#endif
+
+	pr_info("Clocks: ARM_SYSST: 0x%04x DPLL_CTL: 0x%04x ARM_CKCTL: "
+		"0x%04x\n", omap_readw(ARM_SYSST), omap_readw(DPLL_CTL),
+		omap_readw(ARM_CKCTL));
+
+	/* We want to be in syncronous scalable mode */
+	omap_writew(0x1000, ARM_SYSST);
+
+#ifdef CONFIG_OMAP_CLOCKS_SET_BY_BOOTLOADER
+	/* Use values set by bootloader. Determine PLL rate and recalculate
+	 * dependent clocks as if kernel had changed PLL or divisors.
+	 */
+	{
+		unsigned pll_ctl_val = omap_readw(DPLL_CTL);
+
+		ck_dpll1.rate = ck_ref.rate; /* Base xtal rate */
+		if (pll_ctl_val & 0x10) {
+			/* PLL enabled, apply multiplier and divisor */
+			if (pll_ctl_val & 0xf80)
+				ck_dpll1.rate *= (pll_ctl_val & 0xf80) >> 7;
+			ck_dpll1.rate /= ((pll_ctl_val & 0x60) >> 5) + 1;
+		} else {
+			/* PLL disabled, apply bypass divisor */
+			switch (pll_ctl_val & 0xc) {
+			case 0:
+				break;
+			case 0x4:
+				ck_dpll1.rate /= 2;
+				break;
+			default:
+				ck_dpll1.rate /= 4;
+				break;
+			}
+		}
+	}
+#else
+	/* Find the highest supported frequency and enable it */
+	if (omap1_select_table_rate(&virtual_ck_mpu, ~0)) {
+		printk(KERN_ERR "System frequencies not set. Check your config.\n");
+		/* Guess sane values (60MHz) */
+		omap_writew(0x2290, DPLL_CTL);
+		omap_writew(cpu_is_omap7xx() ? 0x3005 : 0x1005, ARM_CKCTL);
+		ck_dpll1.rate = 60000000;
+	}
+#endif
+	propagate_rate(&ck_dpll1);
+	/* Cache rates for clocks connected to ck_ref (not dpll1) */
+	propagate_rate(&ck_ref);
+	printk(KERN_INFO "Clocking rate (xtal/DPLL1/MPU): "
+		"%ld.%01ld/%ld.%01ld/%ld.%01ld MHz\n",
+	       ck_ref.rate / 1000000, (ck_ref.rate / 100000) % 10,
+	       ck_dpll1.rate / 1000000, (ck_dpll1.rate / 100000) % 10,
+	       arm_ck.rate / 1000000, (arm_ck.rate / 100000) % 10);
+
+#if defined(CONFIG_MACH_OMAP_PERSEUS2) || defined(CONFIG_MACH_OMAP_FSAMPLE)
+	/* Select slicer output as OMAP input clock */
+	omap_writew(omap_readw(OMAP7XX_PCC_UPLD_CTRL) & ~0x1, OMAP7XX_PCC_UPLD_CTRL);
+#endif
+
+	/* Amstrad Delta wants BCLK high when inactive */
+	if (machine_is_ams_delta())
+		omap_writel(omap_readl(ULPD_CLOCK_CTRL) |
+				(1 << SDW_MCLK_INV_BIT),
+				ULPD_CLOCK_CTRL);
+
+	/* Turn off DSP and ARM_TIMXO. Make sure ARM_INTHCK is not divided */
+	/* (on 730, bit 13 must not be cleared) */
+	if (cpu_is_omap7xx())
+		omap_writew(omap_readw(ARM_CKCTL) & 0x2fff, ARM_CKCTL);
+	else
+		omap_writew(omap_readw(ARM_CKCTL) & 0x0fff, ARM_CKCTL);
+
+	/* Put DSP/MPUI into reset until needed */
+	omap_writew(0, ARM_RSTCT1);
+	omap_writew(1, ARM_RSTCT2);
+	omap_writew(0x400, ARM_IDLECT1);
+
+	/*
+	 * According to OMAP5910 Erratum SYS_DMA_1, bit DMACK_REQ (bit 8)
+	 * of the ARM_IDLECT2 register must be set to zero. The power-on
+	 * default value of this bit is one.
+	 */
+	omap_writew(0x0000, ARM_IDLECT2);	/* Turn LCD clock off also */
+
+	/*
+	 * Only enable those clocks we will need, let the drivers
+	 * enable other clocks as necessary
+	 */
+	clk_enable(&armper_ck.clk);
+	clk_enable(&armxor_ck.clk);
+	clk_enable(&armtim_ck.clk); /* This should be done by timer code */
+
+	if (cpu_is_omap15xx())
+		clk_enable(&arm_gpio_ck);
+
+	return 0;
+}
