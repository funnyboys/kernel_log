commit 0be298a939b748256035f66716fca409dd26d0dc
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Mon Jan 20 14:10:04 2020 +0200

    ARM: at91: pm: add pmc_version member to at91_pm_data
    
    This will be used to differentiate b/w different PLLs settings to be
    applied in the final/first steps of the suspend/resume process by doing
    PLL specific configurations.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Acked-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/1579522208-19523-5-git-send-email-claudiu.beznea@microchip.com

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index ae7b148febd9..074bde64064e 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -737,28 +737,34 @@ static void __init at91_pm_modes_init(void)
 struct pmc_info {
 	unsigned long uhp_udp_mask;
 	unsigned long mckr;
+	unsigned long version;
 };
 
 static const struct pmc_info pmc_infos[] __initconst = {
 	{
 		.uhp_udp_mask = AT91RM9200_PMC_UHP | AT91RM9200_PMC_UDP,
 		.mckr = 0x30,
+		.version = AT91_PMC_V1,
 	},
 
 	{
 		.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP,
 		.mckr = 0x30,
+		.version = AT91_PMC_V1,
 	},
 	{
 		.uhp_udp_mask = AT91SAM926x_PMC_UHP,
 		.mckr = 0x30,
+		.version = AT91_PMC_V1,
 	},
 	{	.uhp_udp_mask = 0,
 		.mckr = 0x30,
+		.version = AT91_PMC_V1,
 	},
 	{
 		.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP,
 		.mckr = 0x28,
+		.version = AT91_PMC_V2,
 	},
 };
 
@@ -797,6 +803,7 @@ static void __init at91_pm_init(void (*pm_idle)(void))
 	pmc = of_id->data;
 	soc_pm.data.uhp_udp_mask = pmc->uhp_udp_mask;
 	soc_pm.data.pmc_mckr_offset = pmc->mckr;
+	soc_pm.data.pmc_version = pmc->version;
 
 	if (pm_idle)
 		arm_pm_idle = pm_idle;

commit 6ec1587b5c172f53ff27e8c00e6ff9927d2650d4
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Mon Jan 20 14:10:01 2020 +0200

    ARM: at91: pm: use proper master clock register offset
    
    SAM9X60's PMC has different master clock register offset than the other
    SoCs' PMC. Due to this, specify master clock register offset based
    on PMC compatible and pass it to pm_suspend.S since it is also needed
    in there. When PM part for SAM9X60 was published the SAM9X60's PMC
    (commit f6deae46039c ("clk: at91: add sam9x60 pmc driver")) wasn't
    integrated.
    
    Fixes: 01c7031cfa73 ("ARM: at91: pm: initial PM support for SAM9X60")
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/1579522208-19523-2-git-send-email-claudiu.beznea@microchip.com

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 374b9d155558..ae7b148febd9 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -736,13 +736,30 @@ static void __init at91_pm_modes_init(void)
 
 struct pmc_info {
 	unsigned long uhp_udp_mask;
+	unsigned long mckr;
 };
 
 static const struct pmc_info pmc_infos[] __initconst = {
-	{ .uhp_udp_mask = AT91RM9200_PMC_UHP | AT91RM9200_PMC_UDP },
-	{ .uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP },
-	{ .uhp_udp_mask = AT91SAM926x_PMC_UHP },
-	{ .uhp_udp_mask = 0 },
+	{
+		.uhp_udp_mask = AT91RM9200_PMC_UHP | AT91RM9200_PMC_UDP,
+		.mckr = 0x30,
+	},
+
+	{
+		.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP,
+		.mckr = 0x30,
+	},
+	{
+		.uhp_udp_mask = AT91SAM926x_PMC_UHP,
+		.mckr = 0x30,
+	},
+	{	.uhp_udp_mask = 0,
+		.mckr = 0x30,
+	},
+	{
+		.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP,
+		.mckr = 0x28,
+	},
 };
 
 static const struct of_device_id atmel_pmc_ids[] __initconst = {
@@ -757,7 +774,7 @@ static const struct of_device_id atmel_pmc_ids[] __initconst = {
 	{ .compatible = "atmel,sama5d3-pmc", .data = &pmc_infos[1] },
 	{ .compatible = "atmel,sama5d4-pmc", .data = &pmc_infos[1] },
 	{ .compatible = "atmel,sama5d2-pmc", .data = &pmc_infos[1] },
-	{ .compatible = "microchip,sam9x60-pmc", .data = &pmc_infos[1] },
+	{ .compatible = "microchip,sam9x60-pmc", .data = &pmc_infos[4] },
 	{ /* sentinel */ },
 };
 
@@ -779,6 +796,7 @@ static void __init at91_pm_init(void (*pm_idle)(void))
 
 	pmc = of_id->data;
 	soc_pm.data.uhp_udp_mask = pmc->uhp_udp_mask;
+	soc_pm.data.pmc_mckr_offset = pmc->mckr;
 
 	if (pm_idle)
 		arm_pm_idle = pm_idle;

commit ec6e618c8c018c1361d77789a100a5f6f6317178
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Wed Dec 11 13:04:08 2019 +0200

    ARM: at91: pm: use of_device_id array to find the proper shdwc node
    
    Use of_device_id array to find the proper shdwc compatibile node.
    SAM9X60's shdwc changes were not integrated when
    commit eaedc0d379da ("ARM: at91: pm: add ULP1 support for SAM9X60")
    was integrated.
    
    Fixes: eaedc0d379da ("ARM: at91: pm: add ULP1 support for SAM9X60")
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Link: https://lore.kernel.org/r/1576062248-18514-3-git-send-email-claudiu.beznea@microchip.com
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 62c170fbd339..374b9d155558 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -691,6 +691,12 @@ static void __init at91_pm_use_default_mode(int pm_mode)
 		soc_pm.data.suspend_mode = AT91_PM_ULP0;
 }
 
+static const struct of_device_id atmel_shdwc_ids[] = {
+	{ .compatible = "atmel,sama5d2-shdwc" },
+	{ .compatible = "microchip,sam9x60-shdwc" },
+	{ /* sentinel. */ }
+};
+
 static void __init at91_pm_modes_init(void)
 {
 	struct device_node *np;
@@ -700,7 +706,7 @@ static void __init at91_pm_modes_init(void)
 	    !at91_is_pm_mode_active(AT91_PM_ULP1))
 		return;
 
-	np = of_find_compatible_node(NULL, NULL, "atmel,sama5d2-shdwc");
+	np = of_find_matching_node(NULL, atmel_shdwc_ids);
 	if (!np) {
 		pr_warn("%s: failed to find shdwc!\n", __func__);
 		goto ulp1_default;

commit 6b9dfd986a81a999a27b6ed9dbe91203089c62dd
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Wed Dec 11 13:04:07 2019 +0200

    ARM: at91: pm: use SAM9X60 PMC's compatible
    
    SAM9X60 PMC's has a different PMC. It was not integrated at the moment
    commit 01c7031cfa73 ("ARM: at91: pm: initial PM support for SAM9X60")
    was published.
    
    Fixes: 01c7031cfa73 ("ARM: at91: pm: initial PM support for SAM9X60")
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Link: https://lore.kernel.org/r/1576062248-18514-2-git-send-email-claudiu.beznea@microchip.com
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 56a6a49b19e2..62c170fbd339 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -751,6 +751,7 @@ static const struct of_device_id atmel_pmc_ids[] __initconst = {
 	{ .compatible = "atmel,sama5d3-pmc", .data = &pmc_infos[1] },
 	{ .compatible = "atmel,sama5d4-pmc", .data = &pmc_infos[1] },
 	{ .compatible = "atmel,sama5d2-pmc", .data = &pmc_infos[1] },
+	{ .compatible = "microchip,sam9x60-pmc", .data = &pmc_infos[1] },
 	{ /* sentinel */ },
 };
 

commit eb0df9b7fb022af73fb5002f3506a5b1a92df1ae
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Fri Nov 29 15:51:39 2019 +0200

    ARM: at91: pm: move SAM9X60's PM under its own SoC config flag
    
    Move SAM9X60's PM part under SoC config flag. This allows the building
    of SAM9X60 platform withouth depending on CONFIG_SOC_AT91SAM9 flag,
    allowing us to select only necessary config flags for SAM9X60.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Link: https://lore.kernel.org/r/1575035505-6310-4-git-send-email-claudiu.beznea@microchip.com
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index d5af6aedc02c..56a6a49b19e2 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -805,7 +805,7 @@ void __init at91rm9200_pm_init(void)
 
 void __init sam9x60_pm_init(void)
 {
-	if (!IS_ENABLED(CONFIG_SOC_AT91SAM9))
+	if (!IS_ENABLED(CONFIG_SOC_SAM9X60))
 		return;
 
 	at91_pm_modes_init();

commit abd6aa55d72e4e574935dee897d8bdcb0858c9ee
Merge: 0ffd86080bf5 95701b1c3c8f
Author: Olof Johansson <olof@lixom.net>
Date:   Tue Jun 25 05:50:31 2019 -0700

    Merge tag 'at91-5.3-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/at91/linux into arm/soc
    
    AT91 SoC for 5.3
    
     - fix a pm.c warning with W=1
    
    * tag 'at91-5.3-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/at91/linux:
      arm: add missing include platform-data/atmel.h
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 95701b1c3c8fe36368361394e3950094eece4723
Author: Philippe Mazenauer <philippe.mazenauer@outlook.de>
Date:   Wed May 22 09:36:57 2019 +0000

    arm: add missing include platform-data/atmel.h
    
    Include corresponding headerfile <linux/platform-data/atmel.h> for
    function at91_suspend_entering_slow_clock().
    
    ../arch/arm/mach-at91/pm.c:279:5: warning: no previous prototype for ‘at91_suspend_entering_slow_clock’ [-Wmissing-prototypes]
     int at91_suspend_entering_slow_clock(void)
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    Signed-off-by: Philippe Mazenauer <philippe.mazenauer@outlook.de>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 6c8147536f3d..1c88b47c236f 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -19,6 +19,7 @@
 #include <linux/suspend.h>
 
 #include <linux/clk/at91_pmc.h>
+#include <linux/platform_data/atmel.h>
 
 #include <asm/cacheflush.h>
 #include <asm/fncpy.h>

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 6c8147536f3d..da85e64143e9 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -1,13 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * arch/arm/mach-at91/pm.c
  * AT91 Power Management
  *
  * Copyright (C) 2005 David Brownell
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 
 #include <linux/genalloc.h>

commit faff3fcf01effe2be9a7efc165df5af2b5747b73
Merge: e40b0695d56d 2725d70aa513
Author: Olof Johansson <olof@lixom.net>
Date:   Thu May 16 11:05:11 2019 -0700

    Merge tag 'at91-5.2-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/at91/linux into arm/late
    
    AT91 SoC for 5.2
    
     - PM changes for SAM9X60
    
    * tag 'at91-5.2-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/at91/linux:
      ARM: at91: pm: do not disable/enable PLLA for ULP modes
      ARM: at91: pm: disable RC oscillator in ULP0
      ARM: at91: pm: add ULP1 support for SAM9X60
      ARM: at91: pm: add support for per SoC wakeup source configuration
      ARM: at91: pm: keep at91_pm_backup_init() only for SAMA5D2 SoCs
      ARM: at91: pm: initial PM support for SAM9X60
      dt-bindings: arm: atmel: add binding for SAM9X60 SoC
      ARM: at91: pm: introduce at91_soc_pm structure
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit ba5e60c9b75dec92d4c695b928f69300b17d7686
Author: Peng Hao <peng.hao2@zte.com.cn>
Date:   Tue Apr 2 22:12:38 2019 +0800

    arm/mach-at91/pm : fix possible object reference leak
    
    of_find_device_by_node() takes a reference to the struct device
    when it finds a match via get_device. When returning error we should
    call put_device.
    
    Reviewed-by: Mukesh Ojha <mojha@codeaurora.org>
    Signed-off-by: Peng Hao <peng.hao2@zte.com.cn>
    Signed-off-by: Ludovic Desroches <ludovic.desroches@microchip.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 51e808adb00c..2a757dcaa1a5 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -591,13 +591,13 @@ static int __init at91_pm_backup_init(void)
 
 	np = of_find_compatible_node(NULL, NULL, "atmel,sama5d2-securam");
 	if (!np)
-		goto securam_fail;
+		goto securam_fail_no_ref_dev;
 
 	pdev = of_find_device_by_node(np);
 	of_node_put(np);
 	if (!pdev) {
 		pr_warn("%s: failed to find securam device!\n", __func__);
-		goto securam_fail;
+		goto securam_fail_no_ref_dev;
 	}
 
 	sram_pool = gen_pool_get(&pdev->dev, NULL);
@@ -620,6 +620,8 @@ static int __init at91_pm_backup_init(void)
 	return 0;
 
 securam_fail:
+	put_device(&pdev->dev);
+securam_fail_no_ref_dev:
 	iounmap(pm_data.sfrbu);
 	pm_data.sfrbu = NULL;
 	return ret;

commit eaedc0d379da6d1157a4f274d186001d11615b2b
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Thu Feb 14 15:54:57 2019 +0000

    ARM: at91: pm: add ULP1 support for SAM9X60
    
    Add ULP1 support for SAM9X60. In pm_suspend.S enable RC oscillator in
    PMC if it is not enabled. At resume the state before suspend is
    restored.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Acked-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: Ludovic Desroches <ludovic.desroches@microchip.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 27264caa4ec6..5571658b3c46 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -100,6 +100,8 @@ static const struct wakeup_source_info ws_info[] = {
 	{ .pmc_fsmr_bit = AT91_PMC_RTCAL,	.shdwc_mr_bit = BIT(17) },
 	{ .pmc_fsmr_bit = AT91_PMC_USBAL },
 	{ .pmc_fsmr_bit = AT91_PMC_SDMMC_CD },
+	{ .pmc_fsmr_bit = AT91_PMC_RTTAL },
+	{ .pmc_fsmr_bit = AT91_PMC_RXLP_MCE },
 };
 
 static const struct of_device_id sama5d2_ws_ids[] = {
@@ -114,6 +116,17 @@ static const struct of_device_id sama5d2_ws_ids[] = {
 	{ /* sentinel */ }
 };
 
+static const struct of_device_id sam9x60_ws_ids[] = {
+	{ .compatible = "atmel,at91sam9x5-rtc",		.data = &ws_info[1] },
+	{ .compatible = "atmel,at91rm9200-ohci",	.data = &ws_info[2] },
+	{ .compatible = "usb-ohci",			.data = &ws_info[2] },
+	{ .compatible = "atmel,at91sam9g45-ehci",	.data = &ws_info[2] },
+	{ .compatible = "usb-ehci",			.data = &ws_info[2] },
+	{ .compatible = "atmel,at91sam9260-rtt",	.data = &ws_info[4] },
+	{ .compatible = "cdns,sam9x60-macb",		.data = &ws_info[5] },
+	{ /* sentinel */ }
+};
+
 static int at91_pm_config_ws(unsigned int pm_mode, bool set)
 {
 	const struct wakeup_source_info *wsi;
@@ -192,6 +205,13 @@ static int at91_sama5d2_config_pmc_ws(void __iomem *pmc, u32 mode, u32 polarity)
 	return 0;
 }
 
+static int at91_sam9x60_config_pmc_ws(void __iomem *pmc, u32 mode, u32 polarity)
+{
+	writel(mode, pmc + AT91_PMC_FSMR);
+
+	return 0;
+}
+
 /*
  * Called after processes are frozen, but before we shutdown devices.
  */
@@ -789,8 +809,12 @@ void __init sam9x60_pm_init(void)
 	if (!IS_ENABLED(CONFIG_SOC_AT91SAM9))
 		return;
 
+	at91_pm_modes_init();
 	at91_dt_ramc();
 	at91_pm_init(at91sam9x60_idle);
+
+	soc_pm.ws_ids = sam9x60_ws_ids;
+	soc_pm.config_pmc_ws = at91_sam9x60_config_pmc_ws;
 }
 
 void __init at91sam9_pm_init(void)

commit a958156dac936d336f6f56fd2de86e36bc868ff4
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Thu Feb 14 15:54:51 2019 +0000

    ARM: at91: pm: add support for per SoC wakeup source configuration
    
    Add support for per SoC wakeup source configuration. In this way
    we could have per SoC wakeup sources, shutdown controller and power
    management controller configurations for ULP1 power management mode.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: Ludovic Desroches <ludovic.desroches@microchip.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index c83f78000ab3..27264caa4ec6 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -40,6 +40,9 @@ extern void at91_pinctrl_gpio_resume(void);
 #endif
 
 struct at91_soc_pm {
+	int (*config_shdwc_ws)(void __iomem *shdwc, u32 *mode, u32 *polarity);
+	int (*config_pmc_ws)(void __iomem *pmc, u32 mode, u32 polarity);
+	const struct of_device_id *ws_ids;
 	struct at91_pm_data data;
 };
 
@@ -122,7 +125,7 @@ static int at91_pm_config_ws(unsigned int pm_mode, bool set)
 	if (pm_mode != AT91_PM_ULP1)
 		return 0;
 
-	if (!soc_pm.data.pmc || !soc_pm.data.shdwc)
+	if (!soc_pm.data.pmc || !soc_pm.data.shdwc || !soc_pm.ws_ids)
 		return -EPERM;
 
 	if (!set) {
@@ -130,16 +133,14 @@ static int at91_pm_config_ws(unsigned int pm_mode, bool set)
 		return 0;
 	}
 
-	/* SHDWC.WUIR */
-	val = readl(soc_pm.data.shdwc + 0x0c);
-	mode |= (val & 0x3ff);
-	polarity |= ((val >> 16) & 0x3ff);
+	if (soc_pm.config_shdwc_ws)
+		soc_pm.config_shdwc_ws(soc_pm.data.shdwc, &mode, &polarity);
 
 	/* SHDWC.MR */
 	val = readl(soc_pm.data.shdwc + 0x04);
 
 	/* Loop through defined wakeup sources. */
-	for_each_matching_node_and_match(np, sama5d2_ws_ids, &match) {
+	for_each_matching_node_and_match(np, soc_pm.ws_ids, &match) {
 		pdev = of_find_device_by_node(np);
 		if (!pdev)
 			continue;
@@ -161,8 +162,8 @@ static int at91_pm_config_ws(unsigned int pm_mode, bool set)
 	}
 
 	if (mode) {
-		writel(mode, soc_pm.data.pmc + AT91_PMC_FSMR);
-		writel(polarity, soc_pm.data.pmc + AT91_PMC_FSPR);
+		if (soc_pm.config_pmc_ws)
+			soc_pm.config_pmc_ws(soc_pm.data.pmc, mode, polarity);
 	} else {
 		pr_err("AT91: PM: no ULP1 wakeup sources found!");
 	}
@@ -170,6 +171,27 @@ static int at91_pm_config_ws(unsigned int pm_mode, bool set)
 	return mode ? 0 : -EPERM;
 }
 
+static int at91_sama5d2_config_shdwc_ws(void __iomem *shdwc, u32 *mode,
+					u32 *polarity)
+{
+	u32 val;
+
+	/* SHDWC.WUIR */
+	val = readl(shdwc + 0x0c);
+	*mode |= (val & 0x3ff);
+	*polarity |= ((val >> 16) & 0x3ff);
+
+	return 0;
+}
+
+static int at91_sama5d2_config_pmc_ws(void __iomem *pmc, u32 mode, u32 polarity)
+{
+	writel(mode, pmc + AT91_PMC_FSMR);
+	writel(polarity, pmc + AT91_PMC_FSPR);
+
+	return 0;
+}
+
 /*
  * Called after processes are frozen, but before we shutdown devices.
  */
@@ -796,6 +818,10 @@ void __init sama5d2_pm_init(void)
 
 	at91_pm_modes_init();
 	sama5_pm_init();
+
+	soc_pm.ws_ids = sama5d2_ws_ids;
+	soc_pm.config_shdwc_ws = at91_sama5d2_config_shdwc_ws;
+	soc_pm.config_pmc_ws = at91_sama5d2_config_pmc_ws;
 }
 
 static int __init at91_pm_modes_select(char *str)

commit 2fa86e5200a49b3f236a0835f3976c3148148206
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Thu Feb 14 15:54:47 2019 +0000

    ARM: at91: pm: keep at91_pm_backup_init() only for SAMA5D2 SoCs
    
    In at91_pm_backup_init() return if it is not about SAMA5D2 SoCs.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: Ludovic Desroches <ludovic.desroches@microchip.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index e42db02eafe4..c83f78000ab3 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -588,6 +588,9 @@ static int __init at91_pm_backup_init(void)
 	struct platform_device *pdev = NULL;
 	int ret = -ENODEV;
 
+	if (!IS_ENABLED(CONFIG_SOC_SAMA5D2))
+		return -EPERM;
+
 	if (!at91_is_pm_mode_active(AT91_PM_BACKUP))
 		return 0;
 

commit 01c7031cfa7308c2a6d46636bda2e51be6474cf4
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Thu Feb 14 15:54:41 2019 +0000

    ARM: at91: pm: initial PM support for SAM9X60
    
    Add initial PM support for SAM9X60. This include idle, WFI and ULP0.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: Ludovic Desroches <ludovic.desroches@microchip.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index ce2ff86968f6..e42db02eafe4 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -518,6 +518,11 @@ static void at91rm9200_idle(void)
 	writel(AT91_PMC_PCK, soc_pm.data.pmc + AT91_PMC_SCDR);
 }
 
+static void at91sam9x60_idle(void)
+{
+	cpu_do_idle();
+}
+
 static void at91sam9_idle(void)
 {
 	writel(AT91_PMC_PCK, soc_pm.data.pmc + AT91_PMC_SCDR);
@@ -754,6 +759,15 @@ void __init at91rm9200_pm_init(void)
 	at91_pm_init(at91rm9200_idle);
 }
 
+void __init sam9x60_pm_init(void)
+{
+	if (!IS_ENABLED(CONFIG_SOC_AT91SAM9))
+		return;
+
+	at91_dt_ramc();
+	at91_pm_init(at91sam9x60_idle);
+}
+
 void __init at91sam9_pm_init(void)
 {
 	if (!IS_ENABLED(CONFIG_SOC_AT91SAM9))

commit c3f5b8fde71f6ab15d4fd8921997d62ef98d803a
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Thu Feb 14 15:54:31 2019 +0000

    ARM: at91: pm: introduce at91_soc_pm structure
    
    To have per SoC PM information add a new structure which embed
    a member of type struct at91_pm_data. This will allow easy addition
    of new information without contaminate struct at91_pm_data that is
    passed to the last phase suspend function (at91_suspend_sram_fn).
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: Ludovic Desroches <ludovic.desroches@microchip.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 51e808adb00c..ce2ff86968f6 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -39,6 +39,17 @@ extern void at91_pinctrl_gpio_suspend(void);
 extern void at91_pinctrl_gpio_resume(void);
 #endif
 
+struct at91_soc_pm {
+	struct at91_pm_data data;
+};
+
+static struct at91_soc_pm soc_pm = {
+	.data = {
+		.standby_mode = AT91_PM_STANDBY,
+		.suspend_mode = AT91_PM_ULP0,
+	},
+};
+
 static const match_table_t pm_modes __initconst = {
 	{ AT91_PM_STANDBY, "standby" },
 	{ AT91_PM_ULP0, "ulp0" },
@@ -47,16 +58,11 @@ static const match_table_t pm_modes __initconst = {
 	{ -1, NULL },
 };
 
-static struct at91_pm_data pm_data = {
-	.standby_mode = AT91_PM_STANDBY,
-	.suspend_mode = AT91_PM_ULP0,
-};
-
 #define at91_ramc_read(id, field) \
-	__raw_readl(pm_data.ramc[id] + field)
+	__raw_readl(soc_pm.data.ramc[id] + field)
 
 #define at91_ramc_write(id, field, value) \
-	__raw_writel(value, pm_data.ramc[id] + field)
+	__raw_writel(value, soc_pm.data.ramc[id] + field)
 
 static int at91_pm_valid_state(suspend_state_t state)
 {
@@ -116,21 +122,21 @@ static int at91_pm_config_ws(unsigned int pm_mode, bool set)
 	if (pm_mode != AT91_PM_ULP1)
 		return 0;
 
-	if (!pm_data.pmc || !pm_data.shdwc)
+	if (!soc_pm.data.pmc || !soc_pm.data.shdwc)
 		return -EPERM;
 
 	if (!set) {
-		writel(mode, pm_data.pmc + AT91_PMC_FSMR);
+		writel(mode, soc_pm.data.pmc + AT91_PMC_FSMR);
 		return 0;
 	}
 
 	/* SHDWC.WUIR */
-	val = readl(pm_data.shdwc + 0x0c);
+	val = readl(soc_pm.data.shdwc + 0x0c);
 	mode |= (val & 0x3ff);
 	polarity |= ((val >> 16) & 0x3ff);
 
 	/* SHDWC.MR */
-	val = readl(pm_data.shdwc + 0x04);
+	val = readl(soc_pm.data.shdwc + 0x04);
 
 	/* Loop through defined wakeup sources. */
 	for_each_matching_node_and_match(np, sama5d2_ws_ids, &match) {
@@ -155,8 +161,8 @@ static int at91_pm_config_ws(unsigned int pm_mode, bool set)
 	}
 
 	if (mode) {
-		writel(mode, pm_data.pmc + AT91_PMC_FSMR);
-		writel(polarity, pm_data.pmc + AT91_PMC_FSPR);
+		writel(mode, soc_pm.data.pmc + AT91_PMC_FSMR);
+		writel(polarity, soc_pm.data.pmc + AT91_PMC_FSPR);
 	} else {
 		pr_err("AT91: PM: no ULP1 wakeup sources found!");
 	}
@@ -171,18 +177,18 @@ static int at91_pm_begin(suspend_state_t state)
 {
 	switch (state) {
 	case PM_SUSPEND_MEM:
-		pm_data.mode = pm_data.suspend_mode;
+		soc_pm.data.mode = soc_pm.data.suspend_mode;
 		break;
 
 	case PM_SUSPEND_STANDBY:
-		pm_data.mode = pm_data.standby_mode;
+		soc_pm.data.mode = soc_pm.data.standby_mode;
 		break;
 
 	default:
-		pm_data.mode = -1;
+		soc_pm.data.mode = -1;
 	}
 
-	return at91_pm_config_ws(pm_data.mode, true);
+	return at91_pm_config_ws(soc_pm.data.mode, true);
 }
 
 /*
@@ -194,10 +200,10 @@ static int at91_pm_verify_clocks(void)
 	unsigned long scsr;
 	int i;
 
-	scsr = readl(pm_data.pmc + AT91_PMC_SCSR);
+	scsr = readl(soc_pm.data.pmc + AT91_PMC_SCSR);
 
 	/* USB must not be using PLLB */
-	if ((scsr & pm_data.uhp_udp_mask) != 0) {
+	if ((scsr & soc_pm.data.uhp_udp_mask) != 0) {
 		pr_err("AT91: PM - Suspend-to-RAM with USB still active\n");
 		return 0;
 	}
@@ -208,7 +214,7 @@ static int at91_pm_verify_clocks(void)
 
 		if ((scsr & (AT91_PMC_PCK0 << i)) == 0)
 			continue;
-		css = readl(pm_data.pmc + AT91_PMC_PCKR(i)) & AT91_PMC_CSS;
+		css = readl(soc_pm.data.pmc + AT91_PMC_PCKR(i)) & AT91_PMC_CSS;
 		if (css != AT91_PMC_CSS_SLOW) {
 			pr_err("AT91: PM - Suspend-to-RAM with PCK%d src %d\n", i, css);
 			return 0;
@@ -230,7 +236,7 @@ static int at91_pm_verify_clocks(void)
  */
 int at91_suspend_entering_slow_clock(void)
 {
-	return (pm_data.mode >= AT91_PM_ULP0);
+	return (soc_pm.data.mode >= AT91_PM_ULP0);
 }
 EXPORT_SYMBOL(at91_suspend_entering_slow_clock);
 
@@ -243,14 +249,14 @@ static int at91_suspend_finish(unsigned long val)
 	flush_cache_all();
 	outer_disable();
 
-	at91_suspend_sram_fn(&pm_data);
+	at91_suspend_sram_fn(&soc_pm.data);
 
 	return 0;
 }
 
 static void at91_pm_suspend(suspend_state_t state)
 {
-	if (pm_data.mode == AT91_PM_BACKUP) {
+	if (soc_pm.data.mode == AT91_PM_BACKUP) {
 		pm_bu->suspended = 1;
 
 		cpu_suspend(0, at91_suspend_finish);
@@ -289,7 +295,7 @@ static int at91_pm_enter(suspend_state_t state)
 		/*
 		 * Ensure that clocks are in a valid state.
 		 */
-		if (pm_data.mode >= AT91_PM_ULP0 &&
+		if (soc_pm.data.mode >= AT91_PM_ULP0 &&
 		    !at91_pm_verify_clocks())
 			goto error;
 
@@ -318,7 +324,7 @@ static int at91_pm_enter(suspend_state_t state)
  */
 static void at91_pm_end(void)
 {
-	at91_pm_config_ws(pm_data.mode, false);
+	at91_pm_config_ws(soc_pm.data.mode, false);
 }
 
 
@@ -351,7 +357,7 @@ static void at91rm9200_standby(void)
 		"    str    %2, [%1, %3]\n\t"
 		"    mcr    p15, 0, %0, c7, c0, 4\n\t"
 		:
-		: "r" (0), "r" (pm_data.ramc[0]),
+		: "r" (0), "r" (soc_pm.data.ramc[0]),
 		  "r" (1), "r" (AT91_MC_SDRAMC_SRR));
 }
 
@@ -374,7 +380,7 @@ static void at91_ddr_standby(void)
 		at91_ramc_write(0, AT91_DDRSDRC_MDR, mdr);
 	}
 
-	if (pm_data.ramc[1]) {
+	if (soc_pm.data.ramc[1]) {
 		saved_lpr1 = at91_ramc_read(1, AT91_DDRSDRC_LPR);
 		lpr1 = saved_lpr1 & ~AT91_DDRSDRC_LPCB;
 		lpr1 |= AT91_DDRSDRC_LPCB_SELF_REFRESH;
@@ -392,14 +398,14 @@ static void at91_ddr_standby(void)
 
 	/* self-refresh mode now */
 	at91_ramc_write(0, AT91_DDRSDRC_LPR, lpr0);
-	if (pm_data.ramc[1])
+	if (soc_pm.data.ramc[1])
 		at91_ramc_write(1, AT91_DDRSDRC_LPR, lpr1);
 
 	cpu_do_idle();
 
 	at91_ramc_write(0, AT91_DDRSDRC_MDR, saved_mdr0);
 	at91_ramc_write(0, AT91_DDRSDRC_LPR, saved_lpr0);
-	if (pm_data.ramc[1]) {
+	if (soc_pm.data.ramc[1]) {
 		at91_ramc_write(0, AT91_DDRSDRC_MDR, saved_mdr1);
 		at91_ramc_write(1, AT91_DDRSDRC_LPR, saved_lpr1);
 	}
@@ -429,7 +435,7 @@ static void at91sam9_sdram_standby(void)
 	u32 lpr0, lpr1 = 0;
 	u32 saved_lpr0, saved_lpr1 = 0;
 
-	if (pm_data.ramc[1]) {
+	if (soc_pm.data.ramc[1]) {
 		saved_lpr1 = at91_ramc_read(1, AT91_SDRAMC_LPR);
 		lpr1 = saved_lpr1 & ~AT91_SDRAMC_LPCB;
 		lpr1 |= AT91_SDRAMC_LPCB_SELF_REFRESH;
@@ -441,13 +447,13 @@ static void at91sam9_sdram_standby(void)
 
 	/* self-refresh mode now */
 	at91_ramc_write(0, AT91_SDRAMC_LPR, lpr0);
-	if (pm_data.ramc[1])
+	if (soc_pm.data.ramc[1])
 		at91_ramc_write(1, AT91_SDRAMC_LPR, lpr1);
 
 	cpu_do_idle();
 
 	at91_ramc_write(0, AT91_SDRAMC_LPR, saved_lpr0);
-	if (pm_data.ramc[1])
+	if (soc_pm.data.ramc[1])
 		at91_ramc_write(1, AT91_SDRAMC_LPR, saved_lpr1);
 }
 
@@ -480,14 +486,14 @@ static __init void at91_dt_ramc(void)
 	const struct ramc_info *ramc;
 
 	for_each_matching_node_and_match(np, ramc_ids, &of_id) {
-		pm_data.ramc[idx] = of_iomap(np, 0);
-		if (!pm_data.ramc[idx])
+		soc_pm.data.ramc[idx] = of_iomap(np, 0);
+		if (!soc_pm.data.ramc[idx])
 			panic(pr_fmt("unable to map ramc[%d] cpu registers\n"), idx);
 
 		ramc = of_id->data;
 		if (!standby)
 			standby = ramc->idle;
-		pm_data.memctrl = ramc->memctrl;
+		soc_pm.data.memctrl = ramc->memctrl;
 
 		idx++;
 	}
@@ -509,12 +515,12 @@ static void at91rm9200_idle(void)
 	 * Disable the processor clock.  The processor will be automatically
 	 * re-enabled by an interrupt or by a reset.
 	 */
-	writel(AT91_PMC_PCK, pm_data.pmc + AT91_PMC_SCDR);
+	writel(AT91_PMC_PCK, soc_pm.data.pmc + AT91_PMC_SCDR);
 }
 
 static void at91sam9_idle(void)
 {
-	writel(AT91_PMC_PCK, pm_data.pmc + AT91_PMC_SCDR);
+	writel(AT91_PMC_PCK, soc_pm.data.pmc + AT91_PMC_SCDR);
 	cpu_do_idle();
 }
 
@@ -566,8 +572,8 @@ static void __init at91_pm_sram_init(void)
 
 static bool __init at91_is_pm_mode_active(int pm_mode)
 {
-	return (pm_data.standby_mode == pm_mode ||
-		pm_data.suspend_mode == pm_mode);
+	return (soc_pm.data.standby_mode == pm_mode ||
+		soc_pm.data.suspend_mode == pm_mode);
 }
 
 static int __init at91_pm_backup_init(void)
@@ -586,7 +592,7 @@ static int __init at91_pm_backup_init(void)
 		return ret;
 	}
 
-	pm_data.sfrbu = of_iomap(np, 0);
+	soc_pm.data.sfrbu = of_iomap(np, 0);
 	of_node_put(np);
 
 	np = of_find_compatible_node(NULL, NULL, "atmel,sama5d2-securam");
@@ -620,8 +626,8 @@ static int __init at91_pm_backup_init(void)
 	return 0;
 
 securam_fail:
-	iounmap(pm_data.sfrbu);
-	pm_data.sfrbu = NULL;
+	iounmap(soc_pm.data.sfrbu);
+	soc_pm.data.sfrbu = NULL;
 	return ret;
 }
 
@@ -630,10 +636,10 @@ static void __init at91_pm_use_default_mode(int pm_mode)
 	if (pm_mode != AT91_PM_ULP1 && pm_mode != AT91_PM_BACKUP)
 		return;
 
-	if (pm_data.standby_mode == pm_mode)
-		pm_data.standby_mode = AT91_PM_ULP0;
-	if (pm_data.suspend_mode == pm_mode)
-		pm_data.suspend_mode = AT91_PM_ULP0;
+	if (soc_pm.data.standby_mode == pm_mode)
+		soc_pm.data.standby_mode = AT91_PM_ULP0;
+	if (soc_pm.data.suspend_mode == pm_mode)
+		soc_pm.data.suspend_mode = AT91_PM_ULP0;
 }
 
 static void __init at91_pm_modes_init(void)
@@ -651,7 +657,7 @@ static void __init at91_pm_modes_init(void)
 		goto ulp1_default;
 	}
 
-	pm_data.shdwc = of_iomap(np, 0);
+	soc_pm.data.shdwc = of_iomap(np, 0);
 	of_node_put(np);
 
 	ret = at91_pm_backup_init();
@@ -665,8 +671,8 @@ static void __init at91_pm_modes_init(void)
 	return;
 
 unmap:
-	iounmap(pm_data.shdwc);
-	pm_data.shdwc = NULL;
+	iounmap(soc_pm.data.shdwc);
+	soc_pm.data.shdwc = NULL;
 ulp1_default:
 	at91_pm_use_default_mode(AT91_PM_ULP1);
 backup_default:
@@ -709,14 +715,14 @@ static void __init at91_pm_init(void (*pm_idle)(void))
 		platform_device_register(&at91_cpuidle_device);
 
 	pmc_np = of_find_matching_node_and_match(NULL, atmel_pmc_ids, &of_id);
-	pm_data.pmc = of_iomap(pmc_np, 0);
-	if (!pm_data.pmc) {
+	soc_pm.data.pmc = of_iomap(pmc_np, 0);
+	if (!soc_pm.data.pmc) {
 		pr_err("AT91: PM not supported, PMC not found\n");
 		return;
 	}
 
 	pmc = of_id->data;
-	pm_data.uhp_udp_mask = pmc->uhp_udp_mask;
+	soc_pm.data.uhp_udp_mask = pmc->uhp_udp_mask;
 
 	if (pm_idle)
 		arm_pm_idle = pm_idle;
@@ -726,8 +732,8 @@ static void __init at91_pm_init(void (*pm_idle)(void))
 	if (at91_suspend_sram_fn) {
 		suspend_set_ops(&at91_pm_ops);
 		pr_info("AT91: PM: standby: %s, suspend: %s\n",
-			pm_modes[pm_data.standby_mode].pattern,
-			pm_modes[pm_data.suspend_mode].pattern);
+			pm_modes[soc_pm.data.standby_mode].pattern,
+			pm_modes[soc_pm.data.suspend_mode].pattern);
 	} else {
 		pr_info("AT91: PM not supported, due to no SRAM allocated\n");
 	}
@@ -793,8 +799,8 @@ static int __init at91_pm_modes_select(char *str)
 	if (suspend < 0)
 		return 0;
 
-	pm_data.standby_mode = standby;
-	pm_data.suspend_mode = suspend;
+	soc_pm.data.standby_mode = standby;
+	soc_pm.data.suspend_mode = suspend;
 
 	return 0;
 }

commit 95590a6286c547b7287d01c55515fb96b904aa03
Author: zhong jiang <zhongjiang@huawei.com>
Date:   Thu Aug 16 18:26:22 2018 +0800

    ARM: at91: pm: call put_device instead of of_node_put in at91_pm_config_ws
    
    of_find_device_by_node takes a reference to the struct device when it
    finds a match via get_device. but it fails to put_device in
    at91_pm_config_ws, for_each_matching_node_and_match will get and put
    the node properly, there is no need to call the of_put_node. Therefore,
    just call put_device instead of of_node_put in at91_pm_config_ws.
    
    Fixes: d7484f5c6b3b ("ARM: at91: pm: configure wakeup sources for ULP1 mode")
    Suggested-by: Claudiu Beznea <Claudiu.Beznea@microchip.com>
    Signed-off-by: zhong jiang <zhongjiang@huawei.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index b6488d8b7142..51e808adb00c 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -143,15 +143,15 @@ static int at91_pm_config_ws(unsigned int pm_mode, bool set)
 
 			/* Check if enabled on SHDWC. */
 			if (wsi->shdwc_mr_bit && !(val & wsi->shdwc_mr_bit))
-				goto put_node;
+				goto put_device;
 
 			mode |= wsi->pmc_fsmr_bit;
 			if (wsi->set_polarity)
 				polarity |= wsi->pmc_fsmr_bit;
 		}
 
-put_node:
-		of_node_put(np);
+put_device:
+		put_device(&pdev->dev);
 	}
 
 	if (mode) {

commit 1e1f808f9d7ae8e39c81c51a1f713b2bc5a0074f
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Wed Aug 8 10:47:40 2018 +0300

    ARM: at91: pm: remove pm_bu initialization in at91_pm_backup_init()
    
    There is no need to initialize pm_bu since it is used only if backup
    mode is selected. In case backup mode initialization fails (which means
    pm_bu is invalid) the ULP0 mode will be selected.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 32fae4dbd63b..b6488d8b7142 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -580,8 +580,6 @@ static int __init at91_pm_backup_init(void)
 	if (!at91_is_pm_mode_active(AT91_PM_BACKUP))
 		return 0;
 
-	pm_bu = NULL;
-
 	np = of_find_compatible_node(NULL, NULL, "atmel,sama5d2-sfrbu");
 	if (!np) {
 		pr_warn("%s: failed to find sfrbu!\n", __func__);
@@ -590,7 +588,6 @@ static int __init at91_pm_backup_init(void)
 
 	pm_data.sfrbu = of_iomap(np, 0);
 	of_node_put(np);
-	pm_bu = NULL;
 
 	np = of_find_compatible_node(NULL, NULL, "atmel,sama5d2-securam");
 	if (!np)

commit 2f34a64aeac4d87e8ed8275d9f1230e18a50079c
Merge: ee090756962c afd3e3dad676
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Aug 23 14:02:22 2018 -0700

    Merge tag 'armsoc-dt' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM device-tree updates from Olof Johansson:
     "Business as usual -- the bulk of our changes are to devicetree files
      with new hardware support, new SoCs and platforms, and new board
      types.
    
      New SoCs/platforms:
       - Raspberry Pi Compute Module (CM1) and IO board
       - i.MX6SSL from NXP
       - Renesas RZ/N1D SoC (R9A06G032), Dual Cortex-A7 with Ethernet, CAN
         and PLC interfaces
       - TI AM654 SoC, Quad Cortex-A53, safety subsystem with Cortex-R5
         controllers, communication and PRU subsystem and lots of other
         interfaces (PCIe, USB3, etc).
    
      New boards and systems:
       - Several Atmel at91-based boards from Laird
       - Marvell Armada388-based Helios4 board from SolidRun
       - Samsung Aires-based phones (s5pv210)
       - Allwinner A64-based Pinebook laptop
    
      In addition to the above, there's the usual amount of new devices
      described on existing platforms, fixes and tweaks and new minor
      variants of boards/platforms"
    
    * tag 'armsoc-dt' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (478 commits)
      arm64: dts: sdm845: Add tsens nodes
      arm64: dts: msm8996: thermal: Initialise via DT and add second controller
      arm64: dts: sprd: Add one suspend timer
      arm64: dts: sprd: Add SC27XX ADC device
      arm64: dts: sprd: Add SC27XX eFuse device
      arm64: dts: sprd: Add SC27XX vibrator device
      arm64: dts: sprd: Add SC27XX breathing light controller device
      arm64: dts: meson-axg: add spdif-dit codec
      arm64: dts: meson-axg: add lineout codec
      arm64: dts: meson-axg: add linein codec
      arm64: dts: meson-axg: add tdm interfaces
      arm64: dts: meson-axg: add tdmout formatters
      arm64: dts: meson-axg: add tdmin formatters
      arm64: dts: meson-axg: add spdifout
      arm64: dts: rockchip: add led support for Firefly-RK3399
      arm64: dts: rockchip: remove deprecated Type-C PHY properties on rk3399
      arm64: dts: rockchip: add power button support for Firefly-RK3399
      ARM: dts: aspeed: Add coprocessor interrupt controller
      arm64: dts: meson-axg: add audio arb reset controller
      arm64: dts: meson-axg: add usb power regulator
      ...

commit d7484f5c6b3b0565d2395aece2862f183581e1c1
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Tue Jul 17 14:06:24 2018 +0300

    ARM: at91: pm: configure wakeup sources for ULP1 mode
    
    Since for ULP1 PM mode of SAMA5D2 the wakeup sources are limited and
    well known add a method to check if these wakeup sources are defined by
    user (either via DT or filesystem). In case there are no wakeup sources
    defined for ULP1 the PM suspend will fail, otherwise these will be
    configured in fast startup registers of PMC. Since wakeup sources of
    ULP1 need also to be configured in SHDWC registers the code was a bit
    changed to map the SHDWC also in case ULP1 is requested by user (this
    was done in the initialization phase). In case the ULP1 initialization
    fails the ULP0 mode is used (this mode was also used in case backup mode
    initialization failed).
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 099d8094018c..e8f3d0f97e61 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -80,6 +80,90 @@ static struct at91_pm_bu {
 	phys_addr_t resume;
 } *pm_bu;
 
+struct wakeup_source_info {
+	unsigned int pmc_fsmr_bit;
+	unsigned int shdwc_mr_bit;
+	bool set_polarity;
+};
+
+static const struct wakeup_source_info ws_info[] = {
+	{ .pmc_fsmr_bit = AT91_PMC_FSTT(10),	.set_polarity = true },
+	{ .pmc_fsmr_bit = AT91_PMC_RTCAL,	.shdwc_mr_bit = BIT(17) },
+	{ .pmc_fsmr_bit = AT91_PMC_USBAL },
+	{ .pmc_fsmr_bit = AT91_PMC_SDMMC_CD },
+};
+
+static const struct of_device_id sama5d2_ws_ids[] = {
+	{ .compatible = "atmel,sama5d2-gem",		.data = &ws_info[0] },
+	{ .compatible = "atmel,at91rm9200-rtc",		.data = &ws_info[1] },
+	{ .compatible = "atmel,sama5d3-udc",		.data = &ws_info[2] },
+	{ .compatible = "atmel,at91rm9200-ohci",	.data = &ws_info[2] },
+	{ .compatible = "usb-ohci",			.data = &ws_info[2] },
+	{ .compatible = "atmel,at91sam9g45-ehci",	.data = &ws_info[2] },
+	{ .compatible = "usb-ehci",			.data = &ws_info[2] },
+	{ .compatible = "atmel,sama5d2-sdhci",		.data = &ws_info[3] },
+	{ /* sentinel */ }
+};
+
+static int at91_pm_config_ws(unsigned int pm_mode, bool set)
+{
+	const struct wakeup_source_info *wsi;
+	const struct of_device_id *match;
+	struct platform_device *pdev;
+	struct device_node *np;
+	unsigned int mode = 0, polarity = 0, val = 0;
+
+	if (pm_mode != AT91_PM_ULP1)
+		return 0;
+
+	if (!pm_data.pmc || !pm_data.shdwc)
+		return -EPERM;
+
+	if (!set) {
+		writel(mode, pm_data.pmc + AT91_PMC_FSMR);
+		return 0;
+	}
+
+	/* SHDWC.WUIR */
+	val = readl(pm_data.shdwc + 0x0c);
+	mode |= (val & 0x3ff);
+	polarity |= ((val >> 16) & 0x3ff);
+
+	/* SHDWC.MR */
+	val = readl(pm_data.shdwc + 0x04);
+
+	/* Loop through defined wakeup sources. */
+	for_each_matching_node_and_match(np, sama5d2_ws_ids, &match) {
+		pdev = of_find_device_by_node(np);
+		if (!pdev)
+			continue;
+
+		if (device_may_wakeup(&pdev->dev)) {
+			wsi = match->data;
+
+			/* Check if enabled on SHDWC. */
+			if (wsi->shdwc_mr_bit && !(val & wsi->shdwc_mr_bit))
+				goto put_node;
+
+			mode |= wsi->pmc_fsmr_bit;
+			if (wsi->set_polarity)
+				polarity |= wsi->pmc_fsmr_bit;
+		}
+
+put_node:
+		of_node_put(np);
+	}
+
+	if (mode) {
+		writel(mode, pm_data.pmc + AT91_PMC_FSMR);
+		writel(polarity, pm_data.pmc + AT91_PMC_FSPR);
+	} else {
+		pr_err("AT91: PM: no ULP1 wakeup sources found!");
+	}
+
+	return mode ? 0 : -EPERM;
+}
+
 /*
  * Called after processes are frozen, but before we shutdown devices.
  */
@@ -98,7 +182,7 @@ static int at91_pm_begin(suspend_state_t state)
 		pm_data.mode = -1;
 	}
 
-	return 0;
+	return at91_pm_config_ws(pm_data.mode, true);
 }
 
 /*
@@ -234,6 +318,7 @@ static int at91_pm_enter(suspend_state_t state)
  */
 static void at91_pm_end(void)
 {
+	at91_pm_config_ws(pm_data.mode, false);
 }
 
 
@@ -479,31 +564,28 @@ static void __init at91_pm_sram_init(void)
 			&at91_pm_suspend_in_sram, at91_pm_suspend_in_sram_sz);
 }
 
-static void __init at91_pm_backup_init(void)
+static bool __init at91_is_pm_mode_active(int pm_mode)
+{
+	return (pm_data.standby_mode == pm_mode ||
+		pm_data.suspend_mode == pm_mode);
+}
+
+static int __init at91_pm_backup_init(void)
 {
 	struct gen_pool *sram_pool;
 	struct device_node *np;
 	struct platform_device *pdev = NULL;
+	int ret = -ENODEV;
 
-	if ((pm_data.standby_mode != AT91_PM_BACKUP) &&
-	    (pm_data.suspend_mode != AT91_PM_BACKUP))
-		return;
+	if (!at91_is_pm_mode_active(AT91_PM_BACKUP))
+		return 0;
 
 	pm_bu = NULL;
 
-	np = of_find_compatible_node(NULL, NULL, "atmel,sama5d2-shdwc");
-	if (!np) {
-		pr_warn("%s: failed to find shdwc!\n", __func__);
-		return;
-	}
-
-	pm_data.shdwc = of_iomap(np, 0);
-	of_node_put(np);
-
 	np = of_find_compatible_node(NULL, NULL, "atmel,sama5d2-sfrbu");
 	if (!np) {
 		pr_warn("%s: failed to find sfrbu!\n", __func__);
-		goto sfrbu_fail;
+		return ret;
 	}
 
 	pm_data.sfrbu = of_iomap(np, 0);
@@ -530,6 +612,7 @@ static void __init at91_pm_backup_init(void)
 	pm_bu = (void *)gen_pool_alloc(sram_pool, sizeof(struct at91_pm_bu));
 	if (!pm_bu) {
 		pr_warn("%s: unable to alloc securam!\n", __func__);
+		ret = -ENOMEM;
 		goto securam_fail;
 	}
 
@@ -537,21 +620,62 @@ static void __init at91_pm_backup_init(void)
 	pm_bu->canary = __pa_symbol(&canary);
 	pm_bu->resume = __pa_symbol(cpu_resume);
 
-	return;
+	return 0;
 
-sfrbu_fail:
-	iounmap(pm_data.shdwc);
-	pm_data.shdwc = NULL;
 securam_fail:
 	iounmap(pm_data.sfrbu);
 	pm_data.sfrbu = NULL;
+	return ret;
+}
 
-	if (pm_data.standby_mode == AT91_PM_BACKUP)
+static void __init at91_pm_use_default_mode(int pm_mode)
+{
+	if (pm_mode != AT91_PM_ULP1 && pm_mode != AT91_PM_BACKUP)
+		return;
+
+	if (pm_data.standby_mode == pm_mode)
 		pm_data.standby_mode = AT91_PM_ULP0;
-	if (pm_data.suspend_mode == AT91_PM_BACKUP)
+	if (pm_data.suspend_mode == pm_mode)
 		pm_data.suspend_mode = AT91_PM_ULP0;
 }
 
+static void __init at91_pm_modes_init(void)
+{
+	struct device_node *np;
+	int ret;
+
+	if (!at91_is_pm_mode_active(AT91_PM_BACKUP) &&
+	    !at91_is_pm_mode_active(AT91_PM_ULP1))
+		return;
+
+	np = of_find_compatible_node(NULL, NULL, "atmel,sama5d2-shdwc");
+	if (!np) {
+		pr_warn("%s: failed to find shdwc!\n", __func__);
+		goto ulp1_default;
+	}
+
+	pm_data.shdwc = of_iomap(np, 0);
+	of_node_put(np);
+
+	ret = at91_pm_backup_init();
+	if (ret) {
+		if (!at91_is_pm_mode_active(AT91_PM_ULP1))
+			goto unmap;
+		else
+			goto backup_default;
+	}
+
+	return;
+
+unmap:
+	iounmap(pm_data.shdwc);
+	pm_data.shdwc = NULL;
+ulp1_default:
+	at91_pm_use_default_mode(AT91_PM_ULP1);
+backup_default:
+	at91_pm_use_default_mode(AT91_PM_BACKUP);
+}
+
 struct pmc_info {
 	unsigned long uhp_udp_mask;
 };
@@ -645,7 +769,7 @@ void __init sama5d2_pm_init(void)
 	if (!IS_ENABLED(CONFIG_SOC_SAMA5D2))
 		return;
 
-	at91_pm_backup_init();
+	at91_pm_modes_init();
 	sama5_pm_init();
 }
 

commit 5b56c182edb1224bc1a97a1c74003eaa0eb59daf
Author: Wenyou Yang <wenyou.yang@atmel.com>
Date:   Tue Jul 17 11:26:55 2018 +0300

    ARM: at91: pm: Add ULP1 mode support
    
    In the ULP1 mode, in order to achieve the lowest power consumption
    with the system in retention mode and be able to resume on the wake
    up events, all the clocks are shut off, inclusive the embedded 12MHz
    RC oscillator, and the number of wake up sources is limited as well.
    When the wake up event is asserted, the embedded 12MHz RC oscillator
    restarts automatically.
    
    The ULP1 (Ultra Low-power mode 1) is introduced by SAMA5D2.
    
    The previous size of pm_suspend.o was 2148 bytes. With the addition of
    ULP1 mode the new size of pm_suspend.o raised at 2456 bytes.
    
    Signed-off-by: Wenyou Yang <wenyou.yang@atmel.com>
    Signed-off-by: Ludovic Desroches <ludovic.desroches@microchip.com>
    [claudiu.beznea@microchip.com: aligned with 4.18-rc1]
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index d43f00a715d7..099d8094018c 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -42,6 +42,7 @@ extern void at91_pinctrl_gpio_resume(void);
 static const match_table_t pm_modes __initconst = {
 	{ AT91_PM_STANDBY, "standby" },
 	{ AT91_PM_ULP0, "ulp0" },
+	{ AT91_PM_ULP1, "ulp1" },
 	{ AT91_PM_BACKUP, "backup" },
 	{ -1, NULL },
 };

commit 514e2a294aad435ce205c1c66d2abb89a292473c
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Tue Jul 17 11:26:54 2018 +0300

    ARM: at91: pm: Use ULP0 naming instead of slow clock
    
    Switch to use ULP0 naming instead of slow clock naming for power modes, to
    be as closed as possible to datasheet. This commit does the necessary
    renaming and macro addition to be as close as possible to the namings
    from [1].
    
    [1] https://lore.kernel.org/lkml/1470650705-31418-3-git-send-email-wenyou.yang@atmel.com
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 849014c01cf4..d43f00a715d7 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -40,15 +40,15 @@ extern void at91_pinctrl_gpio_resume(void);
 #endif
 
 static const match_table_t pm_modes __initconst = {
-	{ 0, "standby" },
-	{ AT91_PM_SLOW_CLOCK, "ulp0" },
+	{ AT91_PM_STANDBY, "standby" },
+	{ AT91_PM_ULP0, "ulp0" },
 	{ AT91_PM_BACKUP, "backup" },
 	{ -1, NULL },
 };
 
 static struct at91_pm_data pm_data = {
-	.standby_mode = 0,
-	.suspend_mode = AT91_PM_SLOW_CLOCK,
+	.standby_mode = AT91_PM_STANDBY,
+	.suspend_mode = AT91_PM_ULP0,
 };
 
 #define at91_ramc_read(id, field) \
@@ -145,7 +145,7 @@ static int at91_pm_verify_clocks(void)
  */
 int at91_suspend_entering_slow_clock(void)
 {
-	return (pm_data.mode >= AT91_PM_SLOW_CLOCK);
+	return (pm_data.mode >= AT91_PM_ULP0);
 }
 EXPORT_SYMBOL(at91_suspend_entering_slow_clock);
 
@@ -186,7 +186,7 @@ static void at91_pm_suspend(suspend_state_t state)
  * event sources; and reduces DRAM power.  But otherwise it's identical to
  * PM_SUSPEND_ON: cpu idle, and nothing fancy done with main or cpu clocks.
  *
- * AT91_PM_SLOW_CLOCK is like STANDBY plus slow clock mode, so drivers must
+ * AT91_PM_ULP0 is like STANDBY plus slow clock mode, so drivers must
  * suspend more deeply, the master clock switches to the clk32k and turns off
  * the main oscillator
  *
@@ -204,7 +204,7 @@ static int at91_pm_enter(suspend_state_t state)
 		/*
 		 * Ensure that clocks are in a valid state.
 		 */
-		if ((pm_data.mode >= AT91_PM_SLOW_CLOCK) &&
+		if (pm_data.mode >= AT91_PM_ULP0 &&
 		    !at91_pm_verify_clocks())
 			goto error;
 
@@ -546,9 +546,9 @@ static void __init at91_pm_backup_init(void)
 	pm_data.sfrbu = NULL;
 
 	if (pm_data.standby_mode == AT91_PM_BACKUP)
-		pm_data.standby_mode = AT91_PM_SLOW_CLOCK;
+		pm_data.standby_mode = AT91_PM_ULP0;
 	if (pm_data.suspend_mode == AT91_PM_BACKUP)
-		pm_data.suspend_mode = AT91_PM_SLOW_CLOCK;
+		pm_data.suspend_mode = AT91_PM_ULP0;
 }
 
 struct pmc_info {

commit 91f87180e18fff629b5b3b8de9e5dfaa409a09c6
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Thu Jun 7 10:41:06 2018 +0200

    ARM: at91: fix USB clock detection handling
    
    Add more compatibles to be able to correct the USB clock detection.
    
    at91sam9261 and at91sam9263 have the same PMC_SCSR layout as at91sam9260.
    at91sam9rl doesn't have any USB clock.
    
    Acked-by: Nicolas Ferre <nicolas.ferre@microchip.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 849014c01cf4..563f34d01ce4 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -559,15 +559,20 @@ static const struct pmc_info pmc_infos[] __initconst = {
 	{ .uhp_udp_mask = AT91RM9200_PMC_UHP | AT91RM9200_PMC_UDP },
 	{ .uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP },
 	{ .uhp_udp_mask = AT91SAM926x_PMC_UHP },
+	{ .uhp_udp_mask = 0 },
 };
 
 static const struct of_device_id atmel_pmc_ids[] __initconst = {
 	{ .compatible = "atmel,at91rm9200-pmc", .data = &pmc_infos[0] },
 	{ .compatible = "atmel,at91sam9260-pmc", .data = &pmc_infos[1] },
+	{ .compatible = "atmel,at91sam9261-pmc", .data = &pmc_infos[1] },
+	{ .compatible = "atmel,at91sam9263-pmc", .data = &pmc_infos[1] },
 	{ .compatible = "atmel,at91sam9g45-pmc", .data = &pmc_infos[2] },
 	{ .compatible = "atmel,at91sam9n12-pmc", .data = &pmc_infos[1] },
+	{ .compatible = "atmel,at91sam9rl-pmc", .data = &pmc_infos[3] },
 	{ .compatible = "atmel,at91sam9x5-pmc", .data = &pmc_infos[1] },
 	{ .compatible = "atmel,sama5d3-pmc", .data = &pmc_infos[1] },
+	{ .compatible = "atmel,sama5d4-pmc", .data = &pmc_infos[1] },
 	{ .compatible = "atmel,sama5d2-pmc", .data = &pmc_infos[1] },
 	{ /* sentinel */ },
 };

commit 093d79f62a89f47d9b5fd0746768146d9696535c
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Thu Aug 24 13:44:54 2017 +0200

    ARM: at91: Replace uses of virt_to_phys with __pa_symbol
    
    The PM code wrongly uses virt_to_phys() instead of __pa_symbol() and was
    not updated by commit 64fc2a947a98 ("ARM: 8641/1: treewide: Replace uses of
    virt_to_phys with __pa_symbol") because it was not yet in tree.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@microchip.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 5036f996e694..849014c01cf4 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -533,8 +533,8 @@ static void __init at91_pm_backup_init(void)
 	}
 
 	pm_bu->suspended = 0;
-	pm_bu->canary = virt_to_phys(&canary);
-	pm_bu->resume = virt_to_phys(cpu_resume);
+	pm_bu->canary = __pa_symbol(&canary);
+	pm_bu->resume = __pa_symbol(cpu_resume);
 
 	return;
 

commit dbeb0c8e84805b78f3979b53a4a12751403e4520
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Aug 23 16:46:15 2017 +0200

    ARM: at91: don't select CONFIG_ARM_CPU_SUSPEND for old platforms
    
    My previous patch fixed a link error for all at91 platforms when
    CONFIG_ARM_CPU_SUSPEND was not set, however this caused another
    problem on a configuration that enabled CONFIG_ARCH_AT91 but none
    of the individual SoCs, and that also enabled CPU_ARM720 as
    the only CPU:
    
    warning: (ARCH_AT91 && SOC_IMX23 && SOC_IMX28 && ARCH_PXA && MACH_MVEBU_V7 && SOC_IMX6 && ARCH_OMAP3 && ARCH_OMAP4 && SOC_OMAP5 && SOC_AM33XX && SOC_DRA7XX && ARCH_EXYNOS3 && ARCH_EXYNOS4 && EXYNOS5420_MCPM && EXYNOS_CPU_SUSPEND && ARCH_VEXPRESS_TC2_PM && ARM_BIG_LITTLE_CPUIDLE && ARM_HIGHBANK_CPUIDLE && QCOM_PM) selects ARM_CPU_SUSPEND which has unmet direct dependencies (ARCH_SUSPEND_POSSIBLE)
    arch/arm/kernel/sleep.o: In function `cpu_resume':
    (.text+0xf0): undefined reference to `cpu_arm720_suspend_size'
    arch/arm/kernel/suspend.o: In function `__cpu_suspend_save':
    suspend.c:(.text+0x134): undefined reference to `cpu_arm720_do_suspend'
    
    This improves the hack some more by only selecting ARM_CPU_SUSPEND
    for the part that requires it, and changing pm.c to drop the
    contents of unused init functions so we no longer refer to
    cpu_resume on at91 platforms that don't need it.
    
    Fixes: cc7a938f5f30 ("ARM: at91: select CONFIG_ARM_CPU_SUSPEND")
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 667fddac3856..5036f996e694 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -608,6 +608,9 @@ static void __init at91_pm_init(void (*pm_idle)(void))
 
 void __init at91rm9200_pm_init(void)
 {
+	if (!IS_ENABLED(CONFIG_SOC_AT91RM9200))
+		return;
+
 	at91_dt_ramc();
 
 	/*
@@ -620,18 +623,27 @@ void __init at91rm9200_pm_init(void)
 
 void __init at91sam9_pm_init(void)
 {
+	if (!IS_ENABLED(CONFIG_SOC_AT91SAM9))
+		return;
+
 	at91_dt_ramc();
 	at91_pm_init(at91sam9_idle);
 }
 
 void __init sama5_pm_init(void)
 {
+	if (!IS_ENABLED(CONFIG_SOC_SAMA5))
+		return;
+
 	at91_dt_ramc();
 	at91_pm_init(NULL);
 }
 
 void __init sama5d2_pm_init(void)
 {
+	if (!IS_ENABLED(CONFIG_SOC_SAMA5D2))
+		return;
+
 	at91_pm_backup_init();
 	sama5_pm_init();
 }

commit 5a55029f46d636ffed430d47c7fc1bfa0e64a3b6
Merge: 516835714ae2 8a3d809373c6
Author: Olof Johansson <olof@lixom.net>
Date:   Sun Jun 18 22:53:20 2017 -0700

    Merge tag 'at91-ab-4.13-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/abelloni/linux into next/soc
    
    SoC for 4.13:
    
     - New suspend/resume mode for sama5d2
     - Initial support for armv7m based SoCs
    
    * tag 'at91-ab-4.13-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/abelloni/linux:
      ARM: at91: remove atmel_nand_data
      ARM: at91: fix at91_suspend_entering_slow_clock link error
      ARM: at91: debug: add samv7x support
      ARM: at91: add armv7m SoC detection
      ARM: at91: handle CONFIG_PM for armv7m configurations
      ARM: at91: Add armv7m support
      ARM: at91: Document armv7m compatibles
      ARM: at91: Documentation: add armv7m families
      ARM: at91: pm: fallback to slowclock when backup mode fails
      ARM: at91: pm: allow selecting standby and suspend modes
      ARM: at91: pm: Add sama5d2 backup mode
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 0527873b29b077fc8e656acd63e1866b429fef55
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu May 11 13:50:16 2017 +0200

    ARM: remove duplicate 'const' annotations'
    
    gcc-7 warns about some declarations that are more 'const' than necessary:
    
    arch/arm/mach-at91/pm.c:338:34: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct of_device_id const ramc_ids[] __initconst = {
    arch/arm/mach-bcm/bcm_kona_smc.c:36:34: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct of_device_id const bcm_kona_smc_ids[] __initconst = {
    arch/arm/mach-spear/time.c:207:34: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct of_device_id const timer_of_match[] __initconst = {
    arch/arm/mach-omap2/prm_common.c:714:34: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct of_device_id const omap_prcm_dt_match_table[] __initconst = {
    arch/arm/mach-omap2/vc.c:562:35: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct i2c_init_data const omap4_i2c_timing_data[] __initconst = {
    
    The ones in arch/arm were apparently all introduced accidentally by one
    commit that correctly marked a lot of variables as __initconst.
    
    Fixes: 19c233b79d1a ("ARM: appropriate __init annotation for const data")
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Krzysztof Hałasa <khalasa@piap.pl>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 2cd27c830ab6..283e79ab587d 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -335,7 +335,7 @@ static const struct ramc_info ramc_infos[] __initconst = {
 	{ .idle = sama5d3_ddr_standby, .memctrl = AT91_MEMCTRL_DDRSDR},
 };
 
-static const struct of_device_id const ramc_ids[] __initconst = {
+static const struct of_device_id ramc_ids[] __initconst = {
 	{ .compatible = "atmel,at91rm9200-sdramc", .data = &ramc_infos[0] },
 	{ .compatible = "atmel,at91sam9260-sdramc", .data = &ramc_infos[1] },
 	{ .compatible = "atmel,at91sam9g45-ddramc", .data = &ramc_infos[2] },

commit 287322386d303891e9cdc81313137054da9d5467
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Wed Apr 26 16:34:24 2017 +0200

    ARM: at91: pm: fallback to slowclock when backup mode fails
    
    If the backup sram allocation fails, ensure we can suspend by falling back
    to the usual slow clock mode.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Wenyou Yang <wenyou.yang@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index ef9c1d29cc67..fc4026478579 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -544,6 +544,11 @@ static void __init at91_pm_backup_init(void)
 securam_fail:
 	iounmap(pm_data.sfrbu);
 	pm_data.sfrbu = NULL;
+
+	if (pm_data.standby_mode == AT91_PM_BACKUP)
+		pm_data.standby_mode = AT91_PM_SLOW_CLOCK;
+	if (pm_data.suspend_mode == AT91_PM_BACKUP)
+		pm_data.suspend_mode = AT91_PM_SLOW_CLOCK;
 }
 
 struct pmc_info {

commit 7693e18e8c2e2f3188f69bd572ff77dac481da6e
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Wed Apr 26 16:31:03 2017 +0200

    ARM: at91: pm: allow selecting standby and suspend modes
    
    While we can only select between "standby" and "mem" states for power
    management, the atmel platforms can actually support more modes.
    
    For both standby and mem, allow selecting which mode will be used using the
    atmel.pm_modes kernel parameter.
    By default, keep the current modes.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Wenyou Yang <wenyou.yang@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index d138d19fa9f0..ef9c1d29cc67 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -15,6 +15,7 @@
 #include <linux/of_address.h>
 #include <linux/of.h>
 #include <linux/of_platform.h>
+#include <linux/parser.h>
 #include <linux/suspend.h>
 
 #include <linux/clk/at91_pmc.h>
@@ -38,7 +39,17 @@ extern void at91_pinctrl_gpio_suspend(void);
 extern void at91_pinctrl_gpio_resume(void);
 #endif
 
-static struct at91_pm_data pm_data;
+static const match_table_t pm_modes __initconst = {
+	{ 0, "standby" },
+	{ AT91_PM_SLOW_CLOCK, "ulp0" },
+	{ AT91_PM_BACKUP, "backup" },
+	{ -1, NULL },
+};
+
+static struct at91_pm_data pm_data = {
+	.standby_mode = 0,
+	.suspend_mode = AT91_PM_SLOW_CLOCK,
+};
 
 #define at91_ramc_read(id, field) \
 	__raw_readl(pm_data.ramc[id] + field)
@@ -68,14 +79,24 @@ static struct at91_pm_bu {
 	phys_addr_t resume;
 } *pm_bu;
 
-static suspend_state_t target_state;
-
 /*
  * Called after processes are frozen, but before we shutdown devices.
  */
 static int at91_pm_begin(suspend_state_t state)
 {
-	target_state = state;
+	switch (state) {
+	case PM_SUSPEND_MEM:
+		pm_data.mode = pm_data.suspend_mode;
+		break;
+
+	case PM_SUSPEND_STANDBY:
+		pm_data.mode = pm_data.standby_mode;
+		break;
+
+	default:
+		pm_data.mode = -1;
+	}
+
 	return 0;
 }
 
@@ -124,7 +145,7 @@ static int at91_pm_verify_clocks(void)
  */
 int at91_suspend_entering_slow_clock(void)
 {
-	return (target_state == PM_SUSPEND_MEM);
+	return (pm_data.mode >= AT91_PM_SLOW_CLOCK);
 }
 EXPORT_SYMBOL(at91_suspend_entering_slow_clock);
 
@@ -144,14 +165,6 @@ static int at91_suspend_finish(unsigned long val)
 
 static void at91_pm_suspend(suspend_state_t state)
 {
-	if (pm_data.deepest_state == AT91_PM_BACKUP)
-		if (state == PM_SUSPEND_MEM)
-			pm_data.mode = AT91_PM_BACKUP;
-		else
-			pm_data.mode = AT91_PM_SLOW_CLOCK;
-	else
-		pm_data.mode = (state == PM_SUSPEND_MEM) ? AT91_PM_SLOW_CLOCK : 0;
-
 	if (pm_data.mode == AT91_PM_BACKUP) {
 		pm_bu->suspended = 1;
 
@@ -168,38 +181,37 @@ static void at91_pm_suspend(suspend_state_t state)
 	outer_resume();
 }
 
+/*
+ * STANDBY mode has *all* drivers suspended; ignores irqs not marked as 'wakeup'
+ * event sources; and reduces DRAM power.  But otherwise it's identical to
+ * PM_SUSPEND_ON: cpu idle, and nothing fancy done with main or cpu clocks.
+ *
+ * AT91_PM_SLOW_CLOCK is like STANDBY plus slow clock mode, so drivers must
+ * suspend more deeply, the master clock switches to the clk32k and turns off
+ * the main oscillator
+ *
+ * AT91_PM_BACKUP turns off the whole SoC after placing the DDR in self refresh
+ */
 static int at91_pm_enter(suspend_state_t state)
 {
 #ifdef CONFIG_PINCTRL_AT91
 	at91_pinctrl_gpio_suspend();
 #endif
+
 	switch (state) {
-	/*
-	 * Suspend-to-RAM is like STANDBY plus slow clock mode, so
-	 * drivers must suspend more deeply, the master clock switches
-	 * to the clk32k and turns off the main oscillator
-	 */
 	case PM_SUSPEND_MEM:
+	case PM_SUSPEND_STANDBY:
 		/*
 		 * Ensure that clocks are in a valid state.
 		 */
-		if (!at91_pm_verify_clocks())
+		if ((pm_data.mode >= AT91_PM_SLOW_CLOCK) &&
+		    !at91_pm_verify_clocks())
 			goto error;
 
 		at91_pm_suspend(state);
 
 		break;
 
-	/*
-	 * STANDBY mode has *all* drivers suspended; ignores irqs not
-	 * marked as 'wakeup' event sources; and reduces DRAM power.
-	 * But otherwise it's identical to PM_SUSPEND_ON: cpu idle, and
-	 * nothing fancy done with main or cpu clocks.
-	 */
-	case PM_SUSPEND_STANDBY:
-		at91_pm_suspend(state);
-		break;
-
 	case PM_SUSPEND_ON:
 		cpu_do_idle();
 		break;
@@ -210,8 +222,6 @@ static int at91_pm_enter(suspend_state_t state)
 	}
 
 error:
-	target_state = PM_SUSPEND_ON;
-
 #ifdef CONFIG_PINCTRL_AT91
 	at91_pinctrl_gpio_resume();
 #endif
@@ -223,7 +233,6 @@ static int at91_pm_enter(suspend_state_t state)
  */
 static void at91_pm_end(void)
 {
-	target_state = PM_SUSPEND_ON;
 }
 
 
@@ -475,6 +484,10 @@ static void __init at91_pm_backup_init(void)
 	struct device_node *np;
 	struct platform_device *pdev = NULL;
 
+	if ((pm_data.standby_mode != AT91_PM_BACKUP) &&
+	    (pm_data.suspend_mode != AT91_PM_BACKUP))
+		return;
+
 	pm_bu = NULL;
 
 	np = of_find_compatible_node(NULL, NULL, "atmel,sama5d2-shdwc");
@@ -578,10 +591,14 @@ static void __init at91_pm_init(void (*pm_idle)(void))
 
 	at91_pm_sram_init();
 
-	if (at91_suspend_sram_fn)
+	if (at91_suspend_sram_fn) {
 		suspend_set_ops(&at91_pm_ops);
-	else
+		pr_info("AT91: PM: standby: %s, suspend: %s\n",
+			pm_modes[pm_data.standby_mode].pattern,
+			pm_modes[pm_data.suspend_mode].pattern);
+	} else {
 		pr_info("AT91: PM not supported, due to no SRAM allocated\n");
+	}
 }
 
 void __init at91rm9200_pm_init(void)
@@ -613,3 +630,28 @@ void __init sama5d2_pm_init(void)
 	at91_pm_backup_init();
 	sama5_pm_init();
 }
+
+static int __init at91_pm_modes_select(char *str)
+{
+	char *s;
+	substring_t args[MAX_OPT_ARGS];
+	int standby, suspend;
+
+	if (!str)
+		return 0;
+
+	s = strsep(&str, ",");
+	standby = match_token(s, pm_modes, args);
+	if (standby < 0)
+		return 0;
+
+	suspend = match_token(str, pm_modes, args);
+	if (suspend < 0)
+		return 0;
+
+	pm_data.standby_mode = standby;
+	pm_data.suspend_mode = suspend;
+
+	return 0;
+}
+early_param("atmel.pm_modes", at91_pm_modes_select);

commit 24a0f5c539f944248cbb2e3502830dcb7fd2a96e
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Tue Sep 27 12:29:50 2016 +0200

    ARM: at91: pm: Add sama5d2 backup mode
    
    The sama5d2 has a mode were it is possible to cut power to the SoC while
    keeping the RAM in self refresh.
    Resuming from that mode needs support in the firmware/bootloader.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Wenyou Yang <wenyou.yang@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 2cd27c830ab6..d138d19fa9f0 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -22,6 +22,7 @@
 #include <asm/cacheflush.h>
 #include <asm/fncpy.h>
 #include <asm/system_misc.h>
+#include <asm/suspend.h>
 
 #include "generic.h"
 #include "pm.h"
@@ -58,6 +59,14 @@ static int at91_pm_valid_state(suspend_state_t state)
 	}
 }
 
+static int canary = 0xA5A5A5A5;
+
+static struct at91_pm_bu {
+	int suspended;
+	unsigned long reserved;
+	phys_addr_t canary;
+	phys_addr_t resume;
+} *pm_bu;
 
 static suspend_state_t target_state;
 
@@ -123,15 +132,39 @@ static void (*at91_suspend_sram_fn)(struct at91_pm_data *);
 extern void at91_pm_suspend_in_sram(struct at91_pm_data *pm_data);
 extern u32 at91_pm_suspend_in_sram_sz;
 
-static void at91_pm_suspend(suspend_state_t state)
+static int at91_suspend_finish(unsigned long val)
 {
-	pm_data.mode = (state == PM_SUSPEND_MEM) ? AT91_PM_SLOW_CLOCK : 0;
-
 	flush_cache_all();
 	outer_disable();
 
 	at91_suspend_sram_fn(&pm_data);
 
+	return 0;
+}
+
+static void at91_pm_suspend(suspend_state_t state)
+{
+	if (pm_data.deepest_state == AT91_PM_BACKUP)
+		if (state == PM_SUSPEND_MEM)
+			pm_data.mode = AT91_PM_BACKUP;
+		else
+			pm_data.mode = AT91_PM_SLOW_CLOCK;
+	else
+		pm_data.mode = (state == PM_SUSPEND_MEM) ? AT91_PM_SLOW_CLOCK : 0;
+
+	if (pm_data.mode == AT91_PM_BACKUP) {
+		pm_bu->suspended = 1;
+
+		cpu_suspend(0, at91_suspend_finish);
+
+		/* The SRAM is lost between suspend cycles */
+		at91_suspend_sram_fn = fncpy(at91_suspend_sram_fn,
+					     &at91_pm_suspend_in_sram,
+					     at91_pm_suspend_in_sram_sz);
+	} else {
+		at91_suspend_finish(0);
+	}
+
 	outer_resume();
 }
 
@@ -436,6 +469,70 @@ static void __init at91_pm_sram_init(void)
 			&at91_pm_suspend_in_sram, at91_pm_suspend_in_sram_sz);
 }
 
+static void __init at91_pm_backup_init(void)
+{
+	struct gen_pool *sram_pool;
+	struct device_node *np;
+	struct platform_device *pdev = NULL;
+
+	pm_bu = NULL;
+
+	np = of_find_compatible_node(NULL, NULL, "atmel,sama5d2-shdwc");
+	if (!np) {
+		pr_warn("%s: failed to find shdwc!\n", __func__);
+		return;
+	}
+
+	pm_data.shdwc = of_iomap(np, 0);
+	of_node_put(np);
+
+	np = of_find_compatible_node(NULL, NULL, "atmel,sama5d2-sfrbu");
+	if (!np) {
+		pr_warn("%s: failed to find sfrbu!\n", __func__);
+		goto sfrbu_fail;
+	}
+
+	pm_data.sfrbu = of_iomap(np, 0);
+	of_node_put(np);
+	pm_bu = NULL;
+
+	np = of_find_compatible_node(NULL, NULL, "atmel,sama5d2-securam");
+	if (!np)
+		goto securam_fail;
+
+	pdev = of_find_device_by_node(np);
+	of_node_put(np);
+	if (!pdev) {
+		pr_warn("%s: failed to find securam device!\n", __func__);
+		goto securam_fail;
+	}
+
+	sram_pool = gen_pool_get(&pdev->dev, NULL);
+	if (!sram_pool) {
+		pr_warn("%s: securam pool unavailable!\n", __func__);
+		goto securam_fail;
+	}
+
+	pm_bu = (void *)gen_pool_alloc(sram_pool, sizeof(struct at91_pm_bu));
+	if (!pm_bu) {
+		pr_warn("%s: unable to alloc securam!\n", __func__);
+		goto securam_fail;
+	}
+
+	pm_bu->suspended = 0;
+	pm_bu->canary = virt_to_phys(&canary);
+	pm_bu->resume = virt_to_phys(cpu_resume);
+
+	return;
+
+sfrbu_fail:
+	iounmap(pm_data.shdwc);
+	pm_data.shdwc = NULL;
+securam_fail:
+	iounmap(pm_data.sfrbu);
+	pm_data.sfrbu = NULL;
+}
+
 struct pmc_info {
 	unsigned long uhp_udp_mask;
 };
@@ -510,3 +607,9 @@ void __init sama5_pm_init(void)
 	at91_dt_ramc();
 	at91_pm_init(NULL);
 }
+
+void __init sama5d2_pm_init(void)
+{
+	at91_pm_backup_init();
+	sama5_pm_init();
+}

commit e56d75a9cf1273222ab48069175b2242a205a107
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Wed Feb 1 23:55:10 2017 +0100

    ARM: at91: pm: Remove at91_pm_set_standby
    
    Merge at91_pm_set_standby() in at91_dt_ramc as this is the only callsite.
    That moves it to the init section.
    
    Acked-by: Wenyou Yang <wenyou.yang@atmel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index dedfe9038336..2cd27c830ab6 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -205,12 +205,6 @@ static struct platform_device at91_cpuidle_device = {
 	.name = "cpuidle-at91",
 };
 
-static void at91_pm_set_standby(void (*at91_standby)(void))
-{
-	if (at91_standby)
-		at91_cpuidle_device.dev.platform_data = at91_standby;
-}
-
 /*
  * The AT91RM9200 goes into self-refresh mode with this command, and will
  * terminate self-refresh automatically on the next SDRAM access.
@@ -354,7 +348,7 @@ static __init void at91_dt_ramc(void)
 	struct device_node *np;
 	const struct of_device_id *of_id;
 	int idx = 0;
-	const void *standby = NULL;
+	void *standby = NULL;
 	const struct ramc_info *ramc;
 
 	for_each_matching_node_and_match(np, ramc_ids, &of_id) {
@@ -378,7 +372,7 @@ static __init void at91_dt_ramc(void)
 		return;
 	}
 
-	at91_pm_set_standby(standby);
+	at91_cpuidle_device.dev.platform_data = standby;
 }
 
 static void at91rm9200_idle(void)

commit 1346919285933b881e169ede93e67abd226676aa
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Wed Feb 1 23:43:03 2017 +0100

    ARM: at91: pm: Merge all at91sam9*_pm_init
    
    The PM initialization is now identical for all at91sam9. Merge the
    functions.
    
    Acked-by: Wenyou Yang <wenyou.yang@atmel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index a7c047f0d21f..dedfe9038336 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -505,19 +505,7 @@ void __init at91rm9200_pm_init(void)
 	at91_pm_init(at91rm9200_idle);
 }
 
-void __init at91sam9260_pm_init(void)
-{
-	at91_dt_ramc();
-	at91_pm_init(at91sam9_idle);
-}
-
-void __init at91sam9g45_pm_init(void)
-{
-	at91_dt_ramc();
-	at91_pm_init(at91sam9_idle);
-}
-
-void __init at91sam9x5_pm_init(void)
+void __init at91sam9_pm_init(void)
 {
 	at91_dt_ramc();
 	at91_pm_init(at91sam9_idle);

commit 13f16017d3e3febdceba86e8634cf4d06d5c500c
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Wed Feb 1 23:35:18 2017 +0100

    ARM: at91: pm: Tie the USB clock mask to the pmc
    
    The USB clocks mask (uhp_udp_mask) depends on the pmc. Tie it to the pmc id
    instead of the SoC.
    
    Acked-by: Wenyou Yang <wenyou.yang@atmel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index ddf62a006635..a7c047f0d21f 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -442,31 +442,46 @@ static void __init at91_pm_sram_init(void)
 			&at91_pm_suspend_in_sram, at91_pm_suspend_in_sram_sz);
 }
 
+struct pmc_info {
+	unsigned long uhp_udp_mask;
+};
+
+static const struct pmc_info pmc_infos[] __initconst = {
+	{ .uhp_udp_mask = AT91RM9200_PMC_UHP | AT91RM9200_PMC_UDP },
+	{ .uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP },
+	{ .uhp_udp_mask = AT91SAM926x_PMC_UHP },
+};
+
 static const struct of_device_id atmel_pmc_ids[] __initconst = {
-	{ .compatible = "atmel,at91rm9200-pmc"  },
-	{ .compatible = "atmel,at91sam9260-pmc" },
-	{ .compatible = "atmel,at91sam9g45-pmc" },
-	{ .compatible = "atmel,at91sam9n12-pmc" },
-	{ .compatible = "atmel,at91sam9x5-pmc" },
-	{ .compatible = "atmel,sama5d3-pmc" },
-	{ .compatible = "atmel,sama5d2-pmc" },
+	{ .compatible = "atmel,at91rm9200-pmc", .data = &pmc_infos[0] },
+	{ .compatible = "atmel,at91sam9260-pmc", .data = &pmc_infos[1] },
+	{ .compatible = "atmel,at91sam9g45-pmc", .data = &pmc_infos[2] },
+	{ .compatible = "atmel,at91sam9n12-pmc", .data = &pmc_infos[1] },
+	{ .compatible = "atmel,at91sam9x5-pmc", .data = &pmc_infos[1] },
+	{ .compatible = "atmel,sama5d3-pmc", .data = &pmc_infos[1] },
+	{ .compatible = "atmel,sama5d2-pmc", .data = &pmc_infos[1] },
 	{ /* sentinel */ },
 };
 
 static void __init at91_pm_init(void (*pm_idle)(void))
 {
 	struct device_node *pmc_np;
+	const struct of_device_id *of_id;
+	const struct pmc_info *pmc;
 
 	if (at91_cpuidle_device.dev.platform_data)
 		platform_device_register(&at91_cpuidle_device);
 
-	pmc_np = of_find_matching_node(NULL, atmel_pmc_ids);
+	pmc_np = of_find_matching_node_and_match(NULL, atmel_pmc_ids, &of_id);
 	pm_data.pmc = of_iomap(pmc_np, 0);
 	if (!pm_data.pmc) {
 		pr_err("AT91: PM not supported, PMC not found\n");
 		return;
 	}
 
+	pmc = of_id->data;
+	pm_data.uhp_udp_mask = pmc->uhp_udp_mask;
+
 	if (pm_idle)
 		arm_pm_idle = pm_idle;
 
@@ -487,35 +502,29 @@ void __init at91rm9200_pm_init(void)
 	 */
 	at91_ramc_write(0, AT91_MC_SDRAMC_LPR, 0);
 
-	pm_data.uhp_udp_mask = AT91RM9200_PMC_UHP | AT91RM9200_PMC_UDP;
-
 	at91_pm_init(at91rm9200_idle);
 }
 
 void __init at91sam9260_pm_init(void)
 {
 	at91_dt_ramc();
-	pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
 	at91_pm_init(at91sam9_idle);
 }
 
 void __init at91sam9g45_pm_init(void)
 {
 	at91_dt_ramc();
-	pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP;
 	at91_pm_init(at91sam9_idle);
 }
 
 void __init at91sam9x5_pm_init(void)
 {
 	at91_dt_ramc();
-	pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
 	at91_pm_init(at91sam9_idle);
 }
 
 void __init sama5_pm_init(void)
 {
 	at91_dt_ramc();
-	pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
 	at91_pm_init(NULL);
 }

commit aab02d611f814c8f129860d87719a90a4d88b386
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Wed Feb 1 22:41:50 2017 +0100

    ARM: at91: pm: Tie the memory controller type to the ramc id
    
    Instead of relying on the SoC type to select the memory controller type,
    use the device tree ids as they are parsed anyway.
    
    Acked-by: Wenyou Yang <wenyou.yang@atmel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 488549bc2bed..ddf62a006635 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -329,11 +329,23 @@ static void at91sam9_sdram_standby(void)
 		at91_ramc_write(1, AT91_SDRAMC_LPR, saved_lpr1);
 }
 
+struct ramc_info {
+	void (*idle)(void);
+	unsigned int memctrl;
+};
+
+static const struct ramc_info ramc_infos[] __initconst = {
+	{ .idle = at91rm9200_standby, .memctrl = AT91_MEMCTRL_MC},
+	{ .idle = at91sam9_sdram_standby, .memctrl = AT91_MEMCTRL_SDRAMC},
+	{ .idle = at91_ddr_standby, .memctrl = AT91_MEMCTRL_DDRSDR},
+	{ .idle = sama5d3_ddr_standby, .memctrl = AT91_MEMCTRL_DDRSDR},
+};
+
 static const struct of_device_id const ramc_ids[] __initconst = {
-	{ .compatible = "atmel,at91rm9200-sdramc", .data = at91rm9200_standby },
-	{ .compatible = "atmel,at91sam9260-sdramc", .data = at91sam9_sdram_standby },
-	{ .compatible = "atmel,at91sam9g45-ddramc", .data = at91_ddr_standby },
-	{ .compatible = "atmel,sama5d3-ddramc", .data = sama5d3_ddr_standby },
+	{ .compatible = "atmel,at91rm9200-sdramc", .data = &ramc_infos[0] },
+	{ .compatible = "atmel,at91sam9260-sdramc", .data = &ramc_infos[1] },
+	{ .compatible = "atmel,at91sam9g45-ddramc", .data = &ramc_infos[2] },
+	{ .compatible = "atmel,sama5d3-ddramc", .data = &ramc_infos[3] },
 	{ /*sentinel*/ }
 };
 
@@ -343,14 +355,17 @@ static __init void at91_dt_ramc(void)
 	const struct of_device_id *of_id;
 	int idx = 0;
 	const void *standby = NULL;
+	const struct ramc_info *ramc;
 
 	for_each_matching_node_and_match(np, ramc_ids, &of_id) {
 		pm_data.ramc[idx] = of_iomap(np, 0);
 		if (!pm_data.ramc[idx])
 			panic(pr_fmt("unable to map ramc[%d] cpu registers\n"), idx);
 
+		ramc = of_id->data;
 		if (!standby)
-			standby = of_id->data;
+			standby = ramc->idle;
+		pm_data.memctrl = ramc->memctrl;
 
 		idx++;
 	}
@@ -473,7 +488,6 @@ void __init at91rm9200_pm_init(void)
 	at91_ramc_write(0, AT91_MC_SDRAMC_LPR, 0);
 
 	pm_data.uhp_udp_mask = AT91RM9200_PMC_UHP | AT91RM9200_PMC_UDP;
-	pm_data.memctrl = AT91_MEMCTRL_MC;
 
 	at91_pm_init(at91rm9200_idle);
 }
@@ -481,7 +495,6 @@ void __init at91rm9200_pm_init(void)
 void __init at91sam9260_pm_init(void)
 {
 	at91_dt_ramc();
-	pm_data.memctrl = AT91_MEMCTRL_SDRAMC;
 	pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
 	at91_pm_init(at91sam9_idle);
 }
@@ -490,7 +503,6 @@ void __init at91sam9g45_pm_init(void)
 {
 	at91_dt_ramc();
 	pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP;
-	pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
 	at91_pm_init(at91sam9_idle);
 }
 
@@ -498,7 +510,6 @@ void __init at91sam9x5_pm_init(void)
 {
 	at91_dt_ramc();
 	pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
-	pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
 	at91_pm_init(at91sam9_idle);
 }
 
@@ -506,6 +517,5 @@ void __init sama5_pm_init(void)
 {
 	at91_dt_ramc();
 	pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
-	pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
 	at91_pm_init(NULL);
 }

commit 56387634b7604c141b8645d2377980164e18da0d
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Wed Feb 1 22:10:34 2017 +0100

    ARM: at91: pm: Workaround DDRSDRC self-refresh bug with LPDDR1 memories.
    
    As already explained for pm_suspend.S, the DDRSDR controller fails to put
    LPDDR1 memories in self-refresh. Force the controller to think it has DDR2
    memories during the self-refresh period, as the DDR2 self-refresh spec is
    equivalent to LPDDR1, and is correctly implemented in the controller.
    
    Acked-by: Wenyou Yang <wenyou.yang@atmel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 3d68d93c11c7..488549bc2bed 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -241,12 +241,27 @@ static void at91_ddr_standby(void)
 	/* Those two values allow us to delay self-refresh activation
 	 * to the maximum. */
 	u32 lpr0, lpr1 = 0;
+	u32 mdr, saved_mdr0, saved_mdr1 = 0;
 	u32 saved_lpr0, saved_lpr1 = 0;
 
+	/* LPDDR1 --> force DDR2 mode during self-refresh */
+	saved_mdr0 = at91_ramc_read(0, AT91_DDRSDRC_MDR);
+	if ((saved_mdr0 & AT91_DDRSDRC_MD) == AT91_DDRSDRC_MD_LOW_POWER_DDR) {
+		mdr = saved_mdr0 & ~AT91_DDRSDRC_MD;
+		mdr |= AT91_DDRSDRC_MD_DDR2;
+		at91_ramc_write(0, AT91_DDRSDRC_MDR, mdr);
+	}
+
 	if (pm_data.ramc[1]) {
 		saved_lpr1 = at91_ramc_read(1, AT91_DDRSDRC_LPR);
 		lpr1 = saved_lpr1 & ~AT91_DDRSDRC_LPCB;
 		lpr1 |= AT91_DDRSDRC_LPCB_SELF_REFRESH;
+		saved_mdr1 = at91_ramc_read(1, AT91_DDRSDRC_MDR);
+		if ((saved_mdr1 & AT91_DDRSDRC_MD) == AT91_DDRSDRC_MD_LOW_POWER_DDR) {
+			mdr = saved_mdr1 & ~AT91_DDRSDRC_MD;
+			mdr |= AT91_DDRSDRC_MD_DDR2;
+			at91_ramc_write(1, AT91_DDRSDRC_MDR, mdr);
+		}
 	}
 
 	saved_lpr0 = at91_ramc_read(0, AT91_DDRSDRC_LPR);
@@ -260,9 +275,12 @@ static void at91_ddr_standby(void)
 
 	cpu_do_idle();
 
+	at91_ramc_write(0, AT91_DDRSDRC_MDR, saved_mdr0);
 	at91_ramc_write(0, AT91_DDRSDRC_LPR, saved_lpr0);
-	if (pm_data.ramc[1])
+	if (pm_data.ramc[1]) {
+		at91_ramc_write(0, AT91_DDRSDRC_MDR, saved_mdr1);
 		at91_ramc_write(1, AT91_DDRSDRC_LPR, saved_lpr1);
+	}
 }
 
 static void sama5d3_ddr_standby(void)

commit 5a2d4f053f67d03d212c2d036166934f4958173d
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Wed Feb 1 21:32:43 2017 +0100

    ARM: at91: pm: Simplify at91rm9200_standby
    
    Since 2008, AT91_MC_SDRAMC_LPR is set to 0 at kernel initialization. There
    is no use saving, changing and restoring it.
    
    Acked-by: Wenyou Yang <wenyou.yang@atmel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index a35b1541b328..3d68d93c11c7 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -222,20 +222,15 @@ static void at91_pm_set_standby(void (*at91_standby)(void))
  */
 static void at91rm9200_standby(void)
 {
-	u32 lpr = at91_ramc_read(0, AT91_MC_SDRAMC_LPR);
-
 	asm volatile(
 		"b    1f\n\t"
 		".align    5\n\t"
 		"1:  mcr    p15, 0, %0, c7, c10, 4\n\t"
-		"    str    %0, [%1, %2]\n\t"
-		"    str    %3, [%1, %4]\n\t"
+		"    str    %2, [%1, %3]\n\t"
 		"    mcr    p15, 0, %0, c7, c0, 4\n\t"
-		"    str    %5, [%1, %2]"
 		:
-		: "r" (0), "r" (pm_data.ramc[0]), "r" (AT91_MC_SDRAMC_LPR),
-		  "r" (1), "r" (AT91_MC_SDRAMC_SRR),
-		  "r" (lpr));
+		: "r" (0), "r" (pm_data.ramc[0]),
+		  "r" (1), "r" (AT91_MC_SDRAMC_SRR));
 }
 
 /* We manage both DDRAM/SDRAM controllers, we need more than one value to

commit 65cc1a59d192be1df33633d3fe668a1e3e0edc36
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Tue Jan 31 18:12:57 2017 +0100

    ARM: at91: pm: Use struct at91_pm_data in pm_suspend.S
    
    The number of register we can safely pass to at91_pm_suspend_in_sram is
    limited. Instead, pass the address to the at91_pm_data structure.
    
    The offsets are automatically generated to avoid hardcoding them.
    
    Acked-by: Wenyou Yang <wenyou.yang@atmel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index c780dda3b604..a35b1541b328 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -37,18 +37,13 @@ extern void at91_pinctrl_gpio_suspend(void);
 extern void at91_pinctrl_gpio_resume(void);
 #endif
 
-static struct {
-	void __iomem *pmc;
-	void __iomem *ramc[2];
-	unsigned long uhp_udp_mask;
-	int memctrl;
-} at91_pm_data;
+static struct at91_pm_data pm_data;
 
 #define at91_ramc_read(id, field) \
-	__raw_readl(at91_pm_data.ramc[id] + field)
+	__raw_readl(pm_data.ramc[id] + field)
 
 #define at91_ramc_write(id, field, value) \
-	__raw_writel(value, at91_pm_data.ramc[id] + field)
+	__raw_writel(value, pm_data.ramc[id] + field)
 
 static int at91_pm_valid_state(suspend_state_t state)
 {
@@ -84,10 +79,10 @@ static int at91_pm_verify_clocks(void)
 	unsigned long scsr;
 	int i;
 
-	scsr = readl(at91_pm_data.pmc + AT91_PMC_SCSR);
+	scsr = readl(pm_data.pmc + AT91_PMC_SCSR);
 
 	/* USB must not be using PLLB */
-	if ((scsr & at91_pm_data.uhp_udp_mask) != 0) {
+	if ((scsr & pm_data.uhp_udp_mask) != 0) {
 		pr_err("AT91: PM - Suspend-to-RAM with USB still active\n");
 		return 0;
 	}
@@ -98,7 +93,7 @@ static int at91_pm_verify_clocks(void)
 
 		if ((scsr & (AT91_PMC_PCK0 << i)) == 0)
 			continue;
-		css = readl(at91_pm_data.pmc + AT91_PMC_PCKR(i)) & AT91_PMC_CSS;
+		css = readl(pm_data.pmc + AT91_PMC_PCKR(i)) & AT91_PMC_CSS;
 		if (css != AT91_PMC_CSS_SLOW) {
 			pr_err("AT91: PM - Suspend-to-RAM with PCK%d src %d\n", i, css);
 			return 0;
@@ -124,25 +119,18 @@ int at91_suspend_entering_slow_clock(void)
 }
 EXPORT_SYMBOL(at91_suspend_entering_slow_clock);
 
-static void (*at91_suspend_sram_fn)(void __iomem *pmc, void __iomem *ramc0,
-			  void __iomem *ramc1, int memctrl);
-
-extern void at91_pm_suspend_in_sram(void __iomem *pmc, void __iomem *ramc0,
-			    void __iomem *ramc1, int memctrl);
+static void (*at91_suspend_sram_fn)(struct at91_pm_data *);
+extern void at91_pm_suspend_in_sram(struct at91_pm_data *pm_data);
 extern u32 at91_pm_suspend_in_sram_sz;
 
 static void at91_pm_suspend(suspend_state_t state)
 {
-	unsigned int pm_data = at91_pm_data.memctrl;
-
-	pm_data |= (state == PM_SUSPEND_MEM) ?
-				AT91_PM_MODE(AT91_PM_SLOW_CLOCK) : 0;
+	pm_data.mode = (state == PM_SUSPEND_MEM) ? AT91_PM_SLOW_CLOCK : 0;
 
 	flush_cache_all();
 	outer_disable();
 
-	at91_suspend_sram_fn(at91_pm_data.pmc, at91_pm_data.ramc[0],
-			     at91_pm_data.ramc[1], pm_data);
+	at91_suspend_sram_fn(&pm_data);
 
 	outer_resume();
 }
@@ -245,7 +233,7 @@ static void at91rm9200_standby(void)
 		"    mcr    p15, 0, %0, c7, c0, 4\n\t"
 		"    str    %5, [%1, %2]"
 		:
-		: "r" (0), "r" (at91_pm_data.ramc[0]), "r" (AT91_MC_SDRAMC_LPR),
+		: "r" (0), "r" (pm_data.ramc[0]), "r" (AT91_MC_SDRAMC_LPR),
 		  "r" (1), "r" (AT91_MC_SDRAMC_SRR),
 		  "r" (lpr));
 }
@@ -260,7 +248,7 @@ static void at91_ddr_standby(void)
 	u32 lpr0, lpr1 = 0;
 	u32 saved_lpr0, saved_lpr1 = 0;
 
-	if (at91_pm_data.ramc[1]) {
+	if (pm_data.ramc[1]) {
 		saved_lpr1 = at91_ramc_read(1, AT91_DDRSDRC_LPR);
 		lpr1 = saved_lpr1 & ~AT91_DDRSDRC_LPCB;
 		lpr1 |= AT91_DDRSDRC_LPCB_SELF_REFRESH;
@@ -272,13 +260,13 @@ static void at91_ddr_standby(void)
 
 	/* self-refresh mode now */
 	at91_ramc_write(0, AT91_DDRSDRC_LPR, lpr0);
-	if (at91_pm_data.ramc[1])
+	if (pm_data.ramc[1])
 		at91_ramc_write(1, AT91_DDRSDRC_LPR, lpr1);
 
 	cpu_do_idle();
 
 	at91_ramc_write(0, AT91_DDRSDRC_LPR, saved_lpr0);
-	if (at91_pm_data.ramc[1])
+	if (pm_data.ramc[1])
 		at91_ramc_write(1, AT91_DDRSDRC_LPR, saved_lpr1);
 }
 
@@ -306,7 +294,7 @@ static void at91sam9_sdram_standby(void)
 	u32 lpr0, lpr1 = 0;
 	u32 saved_lpr0, saved_lpr1 = 0;
 
-	if (at91_pm_data.ramc[1]) {
+	if (pm_data.ramc[1]) {
 		saved_lpr1 = at91_ramc_read(1, AT91_SDRAMC_LPR);
 		lpr1 = saved_lpr1 & ~AT91_SDRAMC_LPCB;
 		lpr1 |= AT91_SDRAMC_LPCB_SELF_REFRESH;
@@ -318,13 +306,13 @@ static void at91sam9_sdram_standby(void)
 
 	/* self-refresh mode now */
 	at91_ramc_write(0, AT91_SDRAMC_LPR, lpr0);
-	if (at91_pm_data.ramc[1])
+	if (pm_data.ramc[1])
 		at91_ramc_write(1, AT91_SDRAMC_LPR, lpr1);
 
 	cpu_do_idle();
 
 	at91_ramc_write(0, AT91_SDRAMC_LPR, saved_lpr0);
-	if (at91_pm_data.ramc[1])
+	if (pm_data.ramc[1])
 		at91_ramc_write(1, AT91_SDRAMC_LPR, saved_lpr1);
 }
 
@@ -344,8 +332,8 @@ static __init void at91_dt_ramc(void)
 	const void *standby = NULL;
 
 	for_each_matching_node_and_match(np, ramc_ids, &of_id) {
-		at91_pm_data.ramc[idx] = of_iomap(np, 0);
-		if (!at91_pm_data.ramc[idx])
+		pm_data.ramc[idx] = of_iomap(np, 0);
+		if (!pm_data.ramc[idx])
 			panic(pr_fmt("unable to map ramc[%d] cpu registers\n"), idx);
 
 		if (!standby)
@@ -371,12 +359,12 @@ static void at91rm9200_idle(void)
 	 * Disable the processor clock.  The processor will be automatically
 	 * re-enabled by an interrupt or by a reset.
 	 */
-	writel(AT91_PMC_PCK, at91_pm_data.pmc + AT91_PMC_SCDR);
+	writel(AT91_PMC_PCK, pm_data.pmc + AT91_PMC_SCDR);
 }
 
 static void at91sam9_idle(void)
 {
-	writel(AT91_PMC_PCK, at91_pm_data.pmc + AT91_PMC_SCDR);
+	writel(AT91_PMC_PCK, pm_data.pmc + AT91_PMC_SCDR);
 	cpu_do_idle();
 }
 
@@ -445,8 +433,8 @@ static void __init at91_pm_init(void (*pm_idle)(void))
 		platform_device_register(&at91_cpuidle_device);
 
 	pmc_np = of_find_matching_node(NULL, atmel_pmc_ids);
-	at91_pm_data.pmc = of_iomap(pmc_np, 0);
-	if (!at91_pm_data.pmc) {
+	pm_data.pmc = of_iomap(pmc_np, 0);
+	if (!pm_data.pmc) {
 		pr_err("AT91: PM not supported, PMC not found\n");
 		return;
 	}
@@ -471,8 +459,8 @@ void __init at91rm9200_pm_init(void)
 	 */
 	at91_ramc_write(0, AT91_MC_SDRAMC_LPR, 0);
 
-	at91_pm_data.uhp_udp_mask = AT91RM9200_PMC_UHP | AT91RM9200_PMC_UDP;
-	at91_pm_data.memctrl = AT91_MEMCTRL_MC;
+	pm_data.uhp_udp_mask = AT91RM9200_PMC_UHP | AT91RM9200_PMC_UDP;
+	pm_data.memctrl = AT91_MEMCTRL_MC;
 
 	at91_pm_init(at91rm9200_idle);
 }
@@ -480,31 +468,31 @@ void __init at91rm9200_pm_init(void)
 void __init at91sam9260_pm_init(void)
 {
 	at91_dt_ramc();
-	at91_pm_data.memctrl = AT91_MEMCTRL_SDRAMC;
-	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
+	pm_data.memctrl = AT91_MEMCTRL_SDRAMC;
+	pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
 	at91_pm_init(at91sam9_idle);
 }
 
 void __init at91sam9g45_pm_init(void)
 {
 	at91_dt_ramc();
-	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP;
-	at91_pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
+	pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP;
+	pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
 	at91_pm_init(at91sam9_idle);
 }
 
 void __init at91sam9x5_pm_init(void)
 {
 	at91_dt_ramc();
-	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
-	at91_pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
+	pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
+	pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
 	at91_pm_init(at91sam9_idle);
 }
 
 void __init sama5_pm_init(void)
 {
 	at91_dt_ramc();
-	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
-	at91_pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
+	pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
+	pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
 	at91_pm_init(NULL);
 }

commit 9e07c3ce2c1054af503b0cb5860df0f8c8ee2619
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Tue Jan 31 14:15:48 2017 +0100

    ARM: at91: pm: Move global variables into at91_pm_data
    
    Instead of having separate global variables to hold IP addresses, move them
    to struct at91_pm_data.
    
    Acked-by: Wenyou Yang <wenyou.yang@atmel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 41789aa4df86..c780dda3b604 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -26,8 +26,6 @@
 #include "generic.h"
 #include "pm.h"
 
-static void __iomem *pmc;
-
 /*
  * FIXME: this is needed to communicate between the pinctrl driver and
  * the PM implementation in the machine. Possibly part of the PM
@@ -40,17 +38,17 @@ extern void at91_pinctrl_gpio_resume(void);
 #endif
 
 static struct {
+	void __iomem *pmc;
+	void __iomem *ramc[2];
 	unsigned long uhp_udp_mask;
 	int memctrl;
 } at91_pm_data;
 
-static void __iomem *at91_ramc_base[2];
 #define at91_ramc_read(id, field) \
-	__raw_readl(at91_ramc_base[id] + field)
+	__raw_readl(at91_pm_data.ramc[id] + field)
 
 #define at91_ramc_write(id, field, value) \
-	__raw_writel(value, at91_ramc_base[id] + field)
-
+	__raw_writel(value, at91_pm_data.ramc[id] + field)
 
 static int at91_pm_valid_state(suspend_state_t state)
 {
@@ -86,7 +84,7 @@ static int at91_pm_verify_clocks(void)
 	unsigned long scsr;
 	int i;
 
-	scsr = readl(pmc + AT91_PMC_SCSR);
+	scsr = readl(at91_pm_data.pmc + AT91_PMC_SCSR);
 
 	/* USB must not be using PLLB */
 	if ((scsr & at91_pm_data.uhp_udp_mask) != 0) {
@@ -100,7 +98,7 @@ static int at91_pm_verify_clocks(void)
 
 		if ((scsr & (AT91_PMC_PCK0 << i)) == 0)
 			continue;
-		css = readl(pmc + AT91_PMC_PCKR(i)) & AT91_PMC_CSS;
+		css = readl(at91_pm_data.pmc + AT91_PMC_PCKR(i)) & AT91_PMC_CSS;
 		if (css != AT91_PMC_CSS_SLOW) {
 			pr_err("AT91: PM - Suspend-to-RAM with PCK%d src %d\n", i, css);
 			return 0;
@@ -143,8 +141,8 @@ static void at91_pm_suspend(suspend_state_t state)
 	flush_cache_all();
 	outer_disable();
 
-	at91_suspend_sram_fn(pmc, at91_ramc_base[0],
-			     at91_ramc_base[1], pm_data);
+	at91_suspend_sram_fn(at91_pm_data.pmc, at91_pm_data.ramc[0],
+			     at91_pm_data.ramc[1], pm_data);
 
 	outer_resume();
 }
@@ -247,7 +245,7 @@ static void at91rm9200_standby(void)
 		"    mcr    p15, 0, %0, c7, c0, 4\n\t"
 		"    str    %5, [%1, %2]"
 		:
-		: "r" (0), "r" (at91_ramc_base[0]), "r" (AT91_MC_SDRAMC_LPR),
+		: "r" (0), "r" (at91_pm_data.ramc[0]), "r" (AT91_MC_SDRAMC_LPR),
 		  "r" (1), "r" (AT91_MC_SDRAMC_SRR),
 		  "r" (lpr));
 }
@@ -262,7 +260,7 @@ static void at91_ddr_standby(void)
 	u32 lpr0, lpr1 = 0;
 	u32 saved_lpr0, saved_lpr1 = 0;
 
-	if (at91_ramc_base[1]) {
+	if (at91_pm_data.ramc[1]) {
 		saved_lpr1 = at91_ramc_read(1, AT91_DDRSDRC_LPR);
 		lpr1 = saved_lpr1 & ~AT91_DDRSDRC_LPCB;
 		lpr1 |= AT91_DDRSDRC_LPCB_SELF_REFRESH;
@@ -274,13 +272,13 @@ static void at91_ddr_standby(void)
 
 	/* self-refresh mode now */
 	at91_ramc_write(0, AT91_DDRSDRC_LPR, lpr0);
-	if (at91_ramc_base[1])
+	if (at91_pm_data.ramc[1])
 		at91_ramc_write(1, AT91_DDRSDRC_LPR, lpr1);
 
 	cpu_do_idle();
 
 	at91_ramc_write(0, AT91_DDRSDRC_LPR, saved_lpr0);
-	if (at91_ramc_base[1])
+	if (at91_pm_data.ramc[1])
 		at91_ramc_write(1, AT91_DDRSDRC_LPR, saved_lpr1);
 }
 
@@ -308,7 +306,7 @@ static void at91sam9_sdram_standby(void)
 	u32 lpr0, lpr1 = 0;
 	u32 saved_lpr0, saved_lpr1 = 0;
 
-	if (at91_ramc_base[1]) {
+	if (at91_pm_data.ramc[1]) {
 		saved_lpr1 = at91_ramc_read(1, AT91_SDRAMC_LPR);
 		lpr1 = saved_lpr1 & ~AT91_SDRAMC_LPCB;
 		lpr1 |= AT91_SDRAMC_LPCB_SELF_REFRESH;
@@ -320,13 +318,13 @@ static void at91sam9_sdram_standby(void)
 
 	/* self-refresh mode now */
 	at91_ramc_write(0, AT91_SDRAMC_LPR, lpr0);
-	if (at91_ramc_base[1])
+	if (at91_pm_data.ramc[1])
 		at91_ramc_write(1, AT91_SDRAMC_LPR, lpr1);
 
 	cpu_do_idle();
 
 	at91_ramc_write(0, AT91_SDRAMC_LPR, saved_lpr0);
-	if (at91_ramc_base[1])
+	if (at91_pm_data.ramc[1])
 		at91_ramc_write(1, AT91_SDRAMC_LPR, saved_lpr1);
 }
 
@@ -346,8 +344,8 @@ static __init void at91_dt_ramc(void)
 	const void *standby = NULL;
 
 	for_each_matching_node_and_match(np, ramc_ids, &of_id) {
-		at91_ramc_base[idx] = of_iomap(np, 0);
-		if (!at91_ramc_base[idx])
+		at91_pm_data.ramc[idx] = of_iomap(np, 0);
+		if (!at91_pm_data.ramc[idx])
 			panic(pr_fmt("unable to map ramc[%d] cpu registers\n"), idx);
 
 		if (!standby)
@@ -373,12 +371,12 @@ static void at91rm9200_idle(void)
 	 * Disable the processor clock.  The processor will be automatically
 	 * re-enabled by an interrupt or by a reset.
 	 */
-	writel(AT91_PMC_PCK, pmc + AT91_PMC_SCDR);
+	writel(AT91_PMC_PCK, at91_pm_data.pmc + AT91_PMC_SCDR);
 }
 
 static void at91sam9_idle(void)
 {
-	writel(AT91_PMC_PCK, pmc + AT91_PMC_SCDR);
+	writel(AT91_PMC_PCK, at91_pm_data.pmc + AT91_PMC_SCDR);
 	cpu_do_idle();
 }
 
@@ -447,8 +445,8 @@ static void __init at91_pm_init(void (*pm_idle)(void))
 		platform_device_register(&at91_cpuidle_device);
 
 	pmc_np = of_find_matching_node(NULL, atmel_pmc_ids);
-	pmc = of_iomap(pmc_np, 0);
-	if (!pmc) {
+	at91_pm_data.pmc = of_iomap(pmc_np, 0);
+	if (!at91_pm_data.pmc) {
 		pr_err("AT91: PM not supported, PMC not found\n");
 		return;
 	}

commit 4d767bc3c3ae4894877061b58fce0acf63096576
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Tue Jan 31 14:08:47 2017 +0100

    ARM: at91: pm: Move at91_ramc_read/write to pm.c
    
    Those macros are only used in pm.c, move them there so we can remove the
    test on __ASSEMBLY__.
    
    Acked-by: Wenyou Yang <wenyou.yang@atmel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 9e2b5c1e503e..41789aa4df86 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -45,6 +45,12 @@ static struct {
 } at91_pm_data;
 
 static void __iomem *at91_ramc_base[2];
+#define at91_ramc_read(id, field) \
+	__raw_readl(at91_ramc_base[id] + field)
+
+#define at91_ramc_write(id, field, value) \
+	__raw_writel(value, at91_ramc_base[id] + field)
+
 
 static int at91_pm_valid_state(suspend_state_t state)
 {

commit 9824c447aafa6fbca1be6a2dae7e99e1f0c8c564
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Tue Jan 31 13:49:24 2017 +0100

    ARM: at91: pm: Cleanup headers
    
    Remove unnecessary header inclusions and reorder the remaining ones.
    
    Acked-by: Wenyou Yang <wenyou.yang@atmel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index a277981f414d..9e2b5c1e503e 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -10,28 +10,17 @@
  * (at your option) any later version.
  */
 
-#include <linux/gpio.h>
-#include <linux/suspend.h>
-#include <linux/sched.h>
-#include <linux/proc_fs.h>
 #include <linux/genalloc.h>
-#include <linux/interrupt.h>
-#include <linux/sysfs.h>
-#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/of_address.h>
 #include <linux/of.h>
 #include <linux/of_platform.h>
-#include <linux/of_address.h>
-#include <linux/platform_device.h>
-#include <linux/platform_data/atmel.h>
-#include <linux/io.h>
+#include <linux/suspend.h>
+
 #include <linux/clk/at91_pmc.h>
 
-#include <asm/irq.h>
-#include <linux/atomic.h>
-#include <asm/mach/time.h>
-#include <asm/mach/irq.h>
-#include <asm/fncpy.h>
 #include <asm/cacheflush.h>
+#include <asm/fncpy.h>
 #include <asm/system_misc.h>
 
 #include "generic.h"

commit 60b89f1928af80b546b5c3fd8714a62f6f4b8844
Author: Nicolas Ferre <nicolas.ferre@microchip.com>
Date:   Tue Mar 14 09:38:04 2017 +0100

    ARM: at91: pm: cpu_idle: switch DDR to power-down mode
    
    On some DDR controllers, compatible with the sama5d3 one,
    the sequence to enter/exit/re-enter the self-refresh mode adds
    more constrains than what is currently written in the at91_idle
    driver. An actual access to the DDR chip is needed between exit
    and re-enter of this mode which is somehow difficult to implement.
    This sequence can completely hang the SoC. It is particularly
    experienced on parts which embed a L2 cache if the code run
    between IDLE calls fits in it...
    
    Moreover, as the intention is to enter and exit pretty rapidly
    from IDLE, the power-down mode is a good candidate.
    
    So now we use power-down instead of self-refresh. As we can
    simplify the code for sama5d3 compatible DDR controllers,
    we instantiate a new sama5d3_ddr_standby() function.
    
    Signed-off-by: Nicolas Ferre <nicolas.ferre@microchip.com>
    Cc: <stable@vger.kernel.org> # v4.1+
    Fixes: 017b5522d5e3 ("ARM: at91: Add new binding for sama5d3-ddramc")
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 3d89b7905bd9..a277981f414d 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -289,6 +289,22 @@ static void at91_ddr_standby(void)
 		at91_ramc_write(1, AT91_DDRSDRC_LPR, saved_lpr1);
 }
 
+static void sama5d3_ddr_standby(void)
+{
+	u32 lpr0;
+	u32 saved_lpr0;
+
+	saved_lpr0 = at91_ramc_read(0, AT91_DDRSDRC_LPR);
+	lpr0 = saved_lpr0 & ~AT91_DDRSDRC_LPCB;
+	lpr0 |= AT91_DDRSDRC_LPCB_POWER_DOWN;
+
+	at91_ramc_write(0, AT91_DDRSDRC_LPR, lpr0);
+
+	cpu_do_idle();
+
+	at91_ramc_write(0, AT91_DDRSDRC_LPR, saved_lpr0);
+}
+
 /* We manage both DDRAM/SDRAM controllers, we need more than one value to
  * remember.
  */
@@ -323,7 +339,7 @@ static const struct of_device_id const ramc_ids[] __initconst = {
 	{ .compatible = "atmel,at91rm9200-sdramc", .data = at91rm9200_standby },
 	{ .compatible = "atmel,at91sam9260-sdramc", .data = at91sam9_sdram_standby },
 	{ .compatible = "atmel,at91sam9g45-ddramc", .data = at91_ddr_standby },
-	{ .compatible = "atmel,sama5d3-ddramc", .data = at91_ddr_standby },
+	{ .compatible = "atmel,sama5d3-ddramc", .data = sama5d3_ddr_standby },
 	{ /*sentinel*/ }
 };
 

commit 6cc7fbdf8d931eefa2d0aabf0d2840e94ba09ae5
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Tue Sep 27 12:37:15 2016 +0200

    ARM: at91: pm: remove useless extern definition
    
    at91_ramc_base is local to pm.c, remove its definition in pm.h
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index b4332b727e9c..3d89b7905bd9 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -55,7 +55,7 @@ static struct {
 	int memctrl;
 } at91_pm_data;
 
-void __iomem *at91_ramc_base[2];
+static void __iomem *at91_ramc_base[2];
 
 static int at91_pm_valid_state(suspend_state_t state)
 {

commit ab6778eee51b72f2dae79763bf918e3d43331c12
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Fri Jun 17 16:34:18 2016 +0100

    ARM: at91: fix warnings in pm.c
    
    Fix a pair of missing statics on un-exported functions and
    include <linux/platform_data/atmel.h> to provide the declaration
    of at91_suspend_entering_slow_clock() to fix the following
    sparse warnings:
    
    arch/arm/mach-at91/pm.c:127:5: warning: symbol 'at91_suspend_entering_slow_clock' was not declared. Should it be static?
    arch/arm/mach-at91/pm.c:358:6: warning: symbol 'at91rm9200_idle' was not declared. Should it be static?
    arch/arm/mach-at91/pm.c:367:6: warning: symbol 'at91sam9_idle' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index f06270198bf1..b4332b727e9c 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -22,6 +22,7 @@
 #include <linux/of_platform.h>
 #include <linux/of_address.h>
 #include <linux/platform_device.h>
+#include <linux/platform_data/atmel.h>
 #include <linux/io.h>
 #include <linux/clk/at91_pmc.h>
 
@@ -355,7 +356,7 @@ static __init void at91_dt_ramc(void)
 	at91_pm_set_standby(standby);
 }
 
-void at91rm9200_idle(void)
+static void at91rm9200_idle(void)
 {
 	/*
 	 * Disable the processor clock.  The processor will be automatically
@@ -364,7 +365,7 @@ void at91rm9200_idle(void)
 	writel(AT91_PMC_PCK, pmc + AT91_PMC_SCDR);
 }
 
-void at91sam9_idle(void)
+static void at91sam9_idle(void)
 {
 	writel(AT91_PMC_PCK, pmc + AT91_PMC_SCDR);
 	cpu_do_idle();

commit fbc7edca5a7dd417013ef4900763ef931f325b3d
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Wed Sep 30 01:58:40 2015 +0200

    ARM: at91: pm: move idle functions to pm.c
    
    Avoid using code from clk/at91 for PM.
    This also has the bonus effect of setting arm_pm_idle for sama5 platforms.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 8923efbfa7fa..f06270198bf1 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -31,6 +31,7 @@
 #include <asm/mach/irq.h>
 #include <asm/fncpy.h>
 #include <asm/cacheflush.h>
+#include <asm/system_misc.h>
 
 #include "generic.h"
 #include "pm.h"
@@ -354,6 +355,21 @@ static __init void at91_dt_ramc(void)
 	at91_pm_set_standby(standby);
 }
 
+void at91rm9200_idle(void)
+{
+	/*
+	 * Disable the processor clock.  The processor will be automatically
+	 * re-enabled by an interrupt or by a reset.
+	 */
+	writel(AT91_PMC_PCK, pmc + AT91_PMC_SCDR);
+}
+
+void at91sam9_idle(void)
+{
+	writel(AT91_PMC_PCK, pmc + AT91_PMC_SCDR);
+	cpu_do_idle();
+}
+
 static void __init at91_pm_sram_init(void)
 {
 	struct gen_pool *sram_pool;
@@ -411,7 +427,7 @@ static const struct of_device_id atmel_pmc_ids[] __initconst = {
 	{ /* sentinel */ },
 };
 
-static void __init at91_pm_init(void)
+static void __init at91_pm_init(void (*pm_idle)(void))
 {
 	struct device_node *pmc_np;
 
@@ -425,6 +441,9 @@ static void __init at91_pm_init(void)
 		return;
 	}
 
+	if (pm_idle)
+		arm_pm_idle = pm_idle;
+
 	at91_pm_sram_init();
 
 	if (at91_suspend_sram_fn)
@@ -445,7 +464,7 @@ void __init at91rm9200_pm_init(void)
 	at91_pm_data.uhp_udp_mask = AT91RM9200_PMC_UHP | AT91RM9200_PMC_UDP;
 	at91_pm_data.memctrl = AT91_MEMCTRL_MC;
 
-	at91_pm_init();
+	at91_pm_init(at91rm9200_idle);
 }
 
 void __init at91sam9260_pm_init(void)
@@ -453,7 +472,7 @@ void __init at91sam9260_pm_init(void)
 	at91_dt_ramc();
 	at91_pm_data.memctrl = AT91_MEMCTRL_SDRAMC;
 	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
-	at91_pm_init();
+	at91_pm_init(at91sam9_idle);
 }
 
 void __init at91sam9g45_pm_init(void)
@@ -461,7 +480,7 @@ void __init at91sam9g45_pm_init(void)
 	at91_dt_ramc();
 	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP;
 	at91_pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
-	at91_pm_init();
+	at91_pm_init(at91sam9_idle);
 }
 
 void __init at91sam9x5_pm_init(void)
@@ -469,5 +488,13 @@ void __init at91sam9x5_pm_init(void)
 	at91_dt_ramc();
 	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
 	at91_pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
-	at91_pm_init();
+	at91_pm_init(at91sam9_idle);
+}
+
+void __init sama5_pm_init(void)
+{
+	at91_dt_ramc();
+	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
+	at91_pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
+	at91_pm_init(NULL);
 }

commit 5737b73e193ba9d09286b621eecd9db3f3c6abd2
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Wed Sep 30 01:31:34 2015 +0200

    ARM: at91: pm: find and remap the pmc
    
    To avoid relying on at91_pmc_read(), find the pmc node and remap it
    locally.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index db32bf846cef..8923efbfa7fa 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -35,6 +35,8 @@
 #include "generic.h"
 #include "pm.h"
 
+static void __iomem *pmc;
+
 /*
  * FIXME: this is needed to communicate between the pinctrl driver and
  * the PM implementation in the machine. Possibly part of the PM
@@ -87,7 +89,7 @@ static int at91_pm_verify_clocks(void)
 	unsigned long scsr;
 	int i;
 
-	scsr = at91_pmc_read(AT91_PMC_SCSR);
+	scsr = readl(pmc + AT91_PMC_SCSR);
 
 	/* USB must not be using PLLB */
 	if ((scsr & at91_pm_data.uhp_udp_mask) != 0) {
@@ -101,8 +103,7 @@ static int at91_pm_verify_clocks(void)
 
 		if ((scsr & (AT91_PMC_PCK0 << i)) == 0)
 			continue;
-
-		css = at91_pmc_read(AT91_PMC_PCKR(i)) & AT91_PMC_CSS;
+		css = readl(pmc + AT91_PMC_PCKR(i)) & AT91_PMC_CSS;
 		if (css != AT91_PMC_CSS_SLOW) {
 			pr_err("AT91: PM - Suspend-to-RAM with PCK%d src %d\n", i, css);
 			return 0;
@@ -145,8 +146,8 @@ static void at91_pm_suspend(suspend_state_t state)
 	flush_cache_all();
 	outer_disable();
 
-	at91_suspend_sram_fn(at91_pmc_base, at91_ramc_base[0],
-				at91_ramc_base[1], pm_data);
+	at91_suspend_sram_fn(pmc, at91_ramc_base[0],
+			     at91_ramc_base[1], pm_data);
 
 	outer_resume();
 }
@@ -399,13 +400,33 @@ static void __init at91_pm_sram_init(void)
 			&at91_pm_suspend_in_sram, at91_pm_suspend_in_sram_sz);
 }
 
+static const struct of_device_id atmel_pmc_ids[] __initconst = {
+	{ .compatible = "atmel,at91rm9200-pmc"  },
+	{ .compatible = "atmel,at91sam9260-pmc" },
+	{ .compatible = "atmel,at91sam9g45-pmc" },
+	{ .compatible = "atmel,at91sam9n12-pmc" },
+	{ .compatible = "atmel,at91sam9x5-pmc" },
+	{ .compatible = "atmel,sama5d3-pmc" },
+	{ .compatible = "atmel,sama5d2-pmc" },
+	{ /* sentinel */ },
+};
+
 static void __init at91_pm_init(void)
 {
-	at91_pm_sram_init();
+	struct device_node *pmc_np;
 
 	if (at91_cpuidle_device.dev.platform_data)
 		platform_device_register(&at91_cpuidle_device);
 
+	pmc_np = of_find_matching_node(NULL, atmel_pmc_ids);
+	pmc = of_iomap(pmc_np, 0);
+	if (!pmc) {
+		pr_err("AT91: PM not supported, PMC not found\n");
+		return;
+	}
+
+	at91_pm_sram_init();
+
 	if (at91_suspend_sram_fn)
 		suspend_set_ops(&at91_pm_ops);
 	else

commit 997ff83b55c3f50cd5179b9d02d37429064b35eb
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Wed Sep 30 01:08:33 2015 +0200

    ARM: at91: pm: simply call at91_pm_init
    
    at91_pm_init() doesn't return a value, as is the case for its callers,
    simply call it instead of returning its non-existent return value.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 23726fb31741..db32bf846cef 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -432,7 +432,7 @@ void __init at91sam9260_pm_init(void)
 	at91_dt_ramc();
 	at91_pm_data.memctrl = AT91_MEMCTRL_SDRAMC;
 	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
-	return at91_pm_init();
+	at91_pm_init();
 }
 
 void __init at91sam9g45_pm_init(void)
@@ -440,7 +440,7 @@ void __init at91sam9g45_pm_init(void)
 	at91_dt_ramc();
 	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP;
 	at91_pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
-	return at91_pm_init();
+	at91_pm_init();
 }
 
 void __init at91sam9x5_pm_init(void)
@@ -448,5 +448,5 @@ void __init at91sam9x5_pm_init(void)
 	at91_dt_ramc();
 	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
 	at91_pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
-	return at91_pm_init();
+	at91_pm_init();
 }

commit 8423536fe453b3623f4ed7c2c3cca9b86af1ace5
Author: Ludovic Desroches <ludovic.desroches@atmel.com>
Date:   Tue Dec 1 11:44:40 2015 +0100

    ARM: at91: fix pinctrl driver selection
    
    Move the selection of the pinctrl driver to SoC family level since we
    have two pinctrl drivers. It is useless to select one which is not
    compatible with the SoC.
    
    [abelloni: fixed pm.c when only sama2d2 is selected]
    Signed-off-by: Ludovic Desroches <ludovic.desroches@atmel.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 80e277cfcc8b..23726fb31741 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -41,8 +41,10 @@
  * implementation should be moved down into the pinctrl driver and get
  * called as part of the generic suspend/resume path.
  */
+#ifdef CONFIG_PINCTRL_AT91
 extern void at91_pinctrl_gpio_suspend(void);
 extern void at91_pinctrl_gpio_resume(void);
+#endif
 
 static struct {
 	unsigned long uhp_udp_mask;
@@ -151,8 +153,9 @@ static void at91_pm_suspend(suspend_state_t state)
 
 static int at91_pm_enter(suspend_state_t state)
 {
+#ifdef CONFIG_PINCTRL_AT91
 	at91_pinctrl_gpio_suspend();
-
+#endif
 	switch (state) {
 	/*
 	 * Suspend-to-RAM is like STANDBY plus slow clock mode, so
@@ -192,7 +195,9 @@ static int at91_pm_enter(suspend_state_t state)
 error:
 	target_state = PM_SUSPEND_ON;
 
+#ifdef CONFIG_PINCTRL_AT91
 	at91_pinctrl_gpio_resume();
+#endif
 	return 0;
 }
 

commit 73858173593c31cb94bce63fe1c24eb803bb04e6
Author: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
Date:   Fri Sep 4 15:47:43 2015 -0700

    genalloc: add name arg to gen_pool_get() and devm_gen_pool_create()
    
    This change modifies gen_pool_get() and devm_gen_pool_create() client
    interfaces adding one more argument "name" of a gen_pool object.
    
    Due to implementation gen_pool_get() is capable to retrieve only one
    gen_pool associated with a device even if multiple gen_pools are created,
    fortunately right at the moment it is sufficient for the clients, hence
    provide NULL as a valid argument on both producer devm_gen_pool_create()
    and consumer gen_pool_get() sides.
    
    Because only one created gen_pool per device is addressable, explicitly
    add a restriction to devm_gen_pool_create() to create only one gen_pool
    per device, this implies two possible error codes returned by the
    function, account it on client side (only misc/sram).  This completes
    client side changes related to genalloc updates.
    
    [akpm@linux-foundation.org: gen_pool_get() cleanup]
    Signed-off-by: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Cc: Jean-Christophe Plagniol-Villard <plagnioj@jcrosoft.com>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 265ffeb2037e..80e277cfcc8b 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -369,7 +369,7 @@ static void __init at91_pm_sram_init(void)
 		return;
 	}
 
-	sram_pool = gen_pool_get(&pdev->dev);
+	sram_pool = gen_pool_get(&pdev->dev, NULL);
 	if (!sram_pool) {
 		pr_warn("%s: sram pool unavailable!\n", __func__);
 		return;

commit 19c233b79d1af7b5af1ec68c1172848648184449
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Mon Jul 27 18:27:52 2015 -0400

    ARM: appropriate __init annotation for const data
    
    Init data marked const should be annotated with __initconst for
    correctness and not __initdata.  In some cases the array gathering
    references to that data has to be marked const as well. This fixes
    LTO builds that otherwise fail with section mismatch errors.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index e24df77abd79..265ffeb2037e 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -311,7 +311,7 @@ static void at91sam9_sdram_standby(void)
 		at91_ramc_write(1, AT91_SDRAMC_LPR, saved_lpr1);
 }
 
-static const struct of_device_id ramc_ids[] __initconst = {
+static const struct of_device_id const ramc_ids[] __initconst = {
 	{ .compatible = "atmel,at91rm9200-sdramc", .data = at91rm9200_standby },
 	{ .compatible = "atmel,at91sam9260-sdramc", .data = at91sam9_sdram_standby },
 	{ .compatible = "atmel,at91sam9g45-ddramc", .data = at91_ddr_standby },

commit 0030edf296db8a7afb13573eb12977b7d399cd40
Author: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
Date:   Tue Jun 30 15:00:03 2015 -0700

    genalloc: rename dev_get_gen_pool() to gen_pool_get()
    
    To be consistent with other genalloc interface namings, rename
    dev_get_gen_pool() to gen_pool_get().  The original omitted "dev_" prefix
    is removed, since it points to argument type of the function, and so it
    does not bring any useful information.
    
    [akpm@linux-foundation.org: update arch/arm/mach-socfpga/pm.c]
    Signed-off-by: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: Vinod Koul <vinod.koul@intel.com>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Alan Tull <atull@opensource.altera.com>
    Cc: Dinh Nguyen <dinguyen@opensource.altera.com>
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 1e184767c3be..e24df77abd79 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -369,7 +369,7 @@ static void __init at91_pm_sram_init(void)
 		return;
 	}
 
-	sram_pool = dev_get_gen_pool(&pdev->dev);
+	sram_pool = gen_pool_get(&pdev->dev);
 	if (!sram_pool) {
 		pr_warn("%s: sram pool unavailable!\n", __func__);
 		return;

commit d7d45f25557e70c467ffd10d59f99e37463bb833
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Mon Mar 16 15:14:50 2015 +0100

    ARM: at91/pm: use the atmel-mc syscon defines
    
    Use the defines from atmel-mc.h instead of at91rm9200_sdramc.h
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 5062699cbb12..1e184767c3be 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -233,7 +233,7 @@ static void at91_pm_set_standby(void (*at91_standby)(void))
  */
 static void at91rm9200_standby(void)
 {
-	u32 lpr = at91_ramc_read(0, AT91RM9200_SDRAMC_LPR);
+	u32 lpr = at91_ramc_read(0, AT91_MC_SDRAMC_LPR);
 
 	asm volatile(
 		"b    1f\n\t"
@@ -244,8 +244,8 @@ static void at91rm9200_standby(void)
 		"    mcr    p15, 0, %0, c7, c0, 4\n\t"
 		"    str    %5, [%1, %2]"
 		:
-		: "r" (0), "r" (at91_ramc_base[0]), "r" (AT91RM9200_SDRAMC_LPR),
-		  "r" (1), "r" (AT91RM9200_SDRAMC_SRR),
+		: "r" (0), "r" (at91_ramc_base[0]), "r" (AT91_MC_SDRAMC_LPR),
+		  "r" (1), "r" (AT91_MC_SDRAMC_SRR),
 		  "r" (lpr));
 }
 
@@ -414,7 +414,7 @@ void __init at91rm9200_pm_init(void)
 	/*
 	 * AT91RM9200 SDRAM low-power mode cannot be used with self-refresh.
 	 */
-	at91_ramc_write(0, AT91RM9200_SDRAMC_LPR, 0);
+	at91_ramc_write(0, AT91_MC_SDRAMC_LPR, 0);
 
 	at91_pm_data.uhp_udp_mask = AT91RM9200_PMC_UHP | AT91RM9200_PMC_UDP;
 	at91_pm_data.memctrl = AT91_MEMCTRL_MC;

commit 89522f0f8bd5056dec21bb7de073cbd5886e435c
Merge: e8621d83c10e 2e57dc087c27
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Apr 14 01:50:21 2015 +0200

    Merge tag 'at91-cleanup4_bis' of git://git.kernel.org/pub/scm/linux/kernel/git/nferre/linux-at91 into next/multiplatform
    
    Pull "Fourth batch of cleanup for 4.1" from Nicolas Ferre:
    
    - 1 issues revealed by the kbuild test robot fixed
    - move of some functions and macros into relevant files to be able to
      streamline the at91 specific header afterwards
    
    * tag 'at91-cleanup4_bis' of git://git.kernel.org/pub/scm/linux/kernel/git/nferre/linux-at91:
      ARM: at91/pm: move AT91_MEMCTRL_* to pm.h
      ARM: at91/pm: move the standby functions to pm.c
      ARM: at91: fix pm_suspend.S compilation when ARMv6 is selected

commit a18d0699dd18ba5661c321ebd67e6056656b6765
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Mon Mar 16 23:44:37 2015 +0100

    ARM: at91/pm: move the standby functions to pm.c
    
    The standby functions are now only used in pm.c, move them there.
    
    Also, they are not inlined as a pointer to those functions is passed to the
    cpuidle driver.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index ac947cdd506c..0a71c69618f8 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -216,6 +216,95 @@ static void at91_pm_set_standby(void (*at91_standby)(void))
 		at91_cpuidle_device.dev.platform_data = at91_standby;
 }
 
+/*
+ * The AT91RM9200 goes into self-refresh mode with this command, and will
+ * terminate self-refresh automatically on the next SDRAM access.
+ *
+ * Self-refresh mode is exited as soon as a memory access is made, but we don't
+ * know for sure when that happens. However, we need to restore the low-power
+ * mode if it was enabled before going idle. Restoring low-power mode while
+ * still in self-refresh is "not recommended", but seems to work.
+ */
+static void at91rm9200_standby(void)
+{
+	u32 lpr = at91_ramc_read(0, AT91RM9200_SDRAMC_LPR);
+
+	asm volatile(
+		"b    1f\n\t"
+		".align    5\n\t"
+		"1:  mcr    p15, 0, %0, c7, c10, 4\n\t"
+		"    str    %0, [%1, %2]\n\t"
+		"    str    %3, [%1, %4]\n\t"
+		"    mcr    p15, 0, %0, c7, c0, 4\n\t"
+		"    str    %5, [%1, %2]"
+		:
+		: "r" (0), "r" (at91_ramc_base[0]), "r" (AT91RM9200_SDRAMC_LPR),
+		  "r" (1), "r" (AT91RM9200_SDRAMC_SRR),
+		  "r" (lpr));
+}
+
+/* We manage both DDRAM/SDRAM controllers, we need more than one value to
+ * remember.
+ */
+static void at91_ddr_standby(void)
+{
+	/* Those two values allow us to delay self-refresh activation
+	 * to the maximum. */
+	u32 lpr0, lpr1 = 0;
+	u32 saved_lpr0, saved_lpr1 = 0;
+
+	if (at91_ramc_base[1]) {
+		saved_lpr1 = at91_ramc_read(1, AT91_DDRSDRC_LPR);
+		lpr1 = saved_lpr1 & ~AT91_DDRSDRC_LPCB;
+		lpr1 |= AT91_DDRSDRC_LPCB_SELF_REFRESH;
+	}
+
+	saved_lpr0 = at91_ramc_read(0, AT91_DDRSDRC_LPR);
+	lpr0 = saved_lpr0 & ~AT91_DDRSDRC_LPCB;
+	lpr0 |= AT91_DDRSDRC_LPCB_SELF_REFRESH;
+
+	/* self-refresh mode now */
+	at91_ramc_write(0, AT91_DDRSDRC_LPR, lpr0);
+	if (at91_ramc_base[1])
+		at91_ramc_write(1, AT91_DDRSDRC_LPR, lpr1);
+
+	cpu_do_idle();
+
+	at91_ramc_write(0, AT91_DDRSDRC_LPR, saved_lpr0);
+	if (at91_ramc_base[1])
+		at91_ramc_write(1, AT91_DDRSDRC_LPR, saved_lpr1);
+}
+
+/* We manage both DDRAM/SDRAM controllers, we need more than one value to
+ * remember.
+ */
+static void at91sam9_sdram_standby(void)
+{
+	u32 lpr0, lpr1 = 0;
+	u32 saved_lpr0, saved_lpr1 = 0;
+
+	if (at91_ramc_base[1]) {
+		saved_lpr1 = at91_ramc_read(1, AT91_SDRAMC_LPR);
+		lpr1 = saved_lpr1 & ~AT91_SDRAMC_LPCB;
+		lpr1 |= AT91_SDRAMC_LPCB_SELF_REFRESH;
+	}
+
+	saved_lpr0 = at91_ramc_read(0, AT91_SDRAMC_LPR);
+	lpr0 = saved_lpr0 & ~AT91_SDRAMC_LPCB;
+	lpr0 |= AT91_SDRAMC_LPCB_SELF_REFRESH;
+
+	/* self-refresh mode now */
+	at91_ramc_write(0, AT91_SDRAMC_LPR, lpr0);
+	if (at91_ramc_base[1])
+		at91_ramc_write(1, AT91_SDRAMC_LPR, lpr1);
+
+	cpu_do_idle();
+
+	at91_ramc_write(0, AT91_SDRAMC_LPR, saved_lpr0);
+	if (at91_ramc_base[1])
+		at91_ramc_write(1, AT91_SDRAMC_LPR, saved_lpr1);
+}
+
 static const struct of_device_id ramc_ids[] __initconst = {
 	{ .compatible = "atmel,at91rm9200-sdramc", .data = at91rm9200_standby },
 	{ .compatible = "atmel,at91sam9260-sdramc", .data = at91sam9_sdram_standby },

commit 23b8408246aef28499a918b10425c1da4fef613a
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Fri Mar 13 22:57:23 2015 +0100

    ARM: at91: remove hardware.h
    
    hardware.h is now mostyl unused, move the remaining declarations to pm.c and
    remove it.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 2a12c01afc67..f93a735ba327 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -32,11 +32,18 @@
 #include <asm/fncpy.h>
 #include <asm/cacheflush.h>
 
-#include <mach/hardware.h>
-
 #include "generic.h"
 #include "pm.h"
 
+/*
+ * FIXME: this is needed to communicate between the pinctrl driver and
+ * the PM implementation in the machine. Possibly part of the PM
+ * implementation should be moved down into the pinctrl driver and get
+ * called as part of the generic suspend/resume path.
+ */
+extern void at91_pinctrl_gpio_suspend(void);
+extern void at91_pinctrl_gpio_resume(void);
+
 static struct {
 	unsigned long uhp_udp_mask;
 	int memctrl;

commit f56d8f7c29320abe6f923fa1b3cb7adcc3252a24
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Fri Mar 13 22:57:21 2015 +0100

    ARM: at91: remove useless mach/cpu.h
    
    mach/cpu.h is not used anymore, remove it.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index ac947cdd506c..2a12c01afc67 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -32,7 +32,6 @@
 #include <asm/fncpy.h>
 #include <asm/cacheflush.h>
 
-#include <mach/cpu.h>
 #include <mach/hardware.h>
 
 #include "generic.h"

commit 385acc0dac88d79447a03a1363072fc258429dec
Author: Wenyou Yang <wenyou.yang@atmel.com>
Date:   Mon Mar 9 11:54:26 2015 +0800

    ARM: at91/pm: flush data cache and clean, invalidate and disable the L2 cache
    
    Flush data cache, and clean, invalidate and disable the L2 cache before going to suspend.
    Restore the L2 cache configuration and re-enable the L2 cache after waking up.
    
    Signed-off-by: Wenyou Yang <wenyou.yang@atmel.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Tested-by: Sylvain Rochet <sylvain.rochet@finsecur.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 9fb868d2b9da..ac947cdd506c 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -30,6 +30,7 @@
 #include <asm/mach/time.h>
 #include <asm/mach/irq.h>
 #include <asm/fncpy.h>
+#include <asm/cacheflush.h>
 
 #include <mach/cpu.h>
 #include <mach/hardware.h>
@@ -133,8 +134,13 @@ static void at91_pm_suspend(suspend_state_t state)
 	pm_data |= (state == PM_SUSPEND_MEM) ?
 				AT91_PM_MODE(AT91_PM_SLOW_CLOCK) : 0;
 
+	flush_cache_all();
+	outer_disable();
+
 	at91_suspend_sram_fn(at91_pmc_base, at91_ramc_base[0],
 				at91_ramc_base[1], pm_data);
+
+	outer_resume();
 }
 
 static int at91_pm_enter(suspend_state_t state)

commit e32d995cf9db8dbf48d0ae25794b1b7b3872857d
Author: Wenyou Yang <wenyou.yang@atmel.com>
Date:   Mon Mar 9 11:51:49 2015 +0800

    ARM: at91/pm: remove unused void (*at91_pm_standby)(void)
    
    Because the standby mode use the same sram function as the suspend to memory
    mode, void (*at91_pm_standby)(void) doesn't need, remove it.
    
    Signed-off-by: Wenyou Yang <wenyou.yang@atmel.com>
    Tested-by: Sylvain Rochet <sylvain.rochet@finsecur.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index a008e9cb88ef..9fb868d2b9da 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -42,7 +42,6 @@ static struct {
 	int memctrl;
 } at91_pm_data;
 
-static void (*at91_pm_standby)(void);
 void __iomem *at91_ramc_base[2];
 
 static int at91_pm_valid_state(suspend_state_t state)
@@ -207,10 +206,8 @@ static struct platform_device at91_cpuidle_device = {
 
 static void at91_pm_set_standby(void (*at91_standby)(void))
 {
-	if (at91_standby) {
+	if (at91_standby)
 		at91_cpuidle_device.dev.platform_data = at91_standby;
-		at91_pm_standby = at91_standby;
-	}
 }
 
 static const struct of_device_id ramc_ids[] __initconst = {

commit 5726a8b9686348e8d203f1bbf9d5fc1bb5899518
Author: Wenyou Yang <wenyou.yang@atmel.com>
Date:   Mon Mar 9 11:51:09 2015 +0800

    ARM: at91/pm: rename function name: at91_slow_clock() --> at91_pm_suspend_sram_fn()
    
    As the file name is renamed, rename the function name at91_slow_clock()
    --> at91_pm_suspend_sram_fn(), rename the function handler's name at the
    same time.
    
    Signed-off-by: Wenyou Yang <wenyou.yang@atmel.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Tested-by: Sylvain Rochet <sylvain.rochet@finsecur.com>
    [nicolas.ferre@atmel.com: little update of the commit message]
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 3fc5e12043a2..a008e9cb88ef 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -120,13 +120,12 @@ int at91_suspend_entering_slow_clock(void)
 }
 EXPORT_SYMBOL(at91_suspend_entering_slow_clock);
 
-
-static void (*slow_clock)(void __iomem *pmc, void __iomem *ramc0,
+static void (*at91_suspend_sram_fn)(void __iomem *pmc, void __iomem *ramc0,
 			  void __iomem *ramc1, int memctrl);
 
-extern void at91_slow_clock(void __iomem *pmc, void __iomem *ramc0,
+extern void at91_pm_suspend_in_sram(void __iomem *pmc, void __iomem *ramc0,
 			    void __iomem *ramc1, int memctrl);
-extern u32 at91_slow_clock_sz;
+extern u32 at91_pm_suspend_in_sram_sz;
 
 static void at91_pm_suspend(suspend_state_t state)
 {
@@ -135,8 +134,8 @@ static void at91_pm_suspend(suspend_state_t state)
 	pm_data |= (state == PM_SUSPEND_MEM) ?
 				AT91_PM_MODE(AT91_PM_SLOW_CLOCK) : 0;
 
-	slow_clock(at91_pmc_base, at91_ramc_base[0],
-			at91_ramc_base[1], pm_data);
+	at91_suspend_sram_fn(at91_pmc_base, at91_ramc_base[0],
+				at91_ramc_base[1], pm_data);
 }
 
 static int at91_pm_enter(suspend_state_t state)
@@ -278,21 +277,23 @@ static void __init at91_pm_sram_init(void)
 		return;
 	}
 
-	sram_base = gen_pool_alloc(sram_pool, at91_slow_clock_sz);
+	sram_base = gen_pool_alloc(sram_pool, at91_pm_suspend_in_sram_sz);
 	if (!sram_base) {
-		pr_warn("%s: unable to alloc ocram!\n", __func__);
+		pr_warn("%s: unable to alloc sram!\n", __func__);
 		return;
 	}
 
 	sram_pbase = gen_pool_virt_to_phys(sram_pool, sram_base);
-	slow_clock = __arm_ioremap_exec(sram_pbase, at91_slow_clock_sz, false);
-	if (!slow_clock) {
+	at91_suspend_sram_fn = __arm_ioremap_exec(sram_pbase,
+					at91_pm_suspend_in_sram_sz, false);
+	if (!at91_suspend_sram_fn) {
 		pr_warn("SRAM: Could not map\n");
 		return;
 	}
 
-	/* Copy the slow_clock handler to SRAM */
-	slow_clock = fncpy(slow_clock, &at91_slow_clock, at91_slow_clock_sz);
+	/* Copy the pm suspend handler to SRAM */
+	at91_suspend_sram_fn = fncpy(at91_suspend_sram_fn,
+			&at91_pm_suspend_in_sram, at91_pm_suspend_in_sram_sz);
 }
 
 static void __init at91_pm_init(void)
@@ -302,7 +303,7 @@ static void __init at91_pm_init(void)
 	if (at91_cpuidle_device.dev.platform_data)
 		platform_device_register(&at91_cpuidle_device);
 
-	if (slow_clock)
+	if (at91_suspend_sram_fn)
 		suspend_set_ops(&at91_pm_ops);
 	else
 		pr_info("AT91: PM not supported, due to no SRAM allocated\n");

commit 23be4be5a666c6b4e6fe8ddbbb84fb4f2efee0a5
Author: Wenyou Yang <wenyou.yang@atmel.com>
Date:   Mon Mar 9 11:49:46 2015 +0800

    ARM: at91/pm: standby mode uses same sram function as suspend to memory mode
    
    To simply the PM code, the suspend to standby mode uses same sram function
    as the suspend to memory mode, running in the internal SRAM, instead of the
    respective code for each mode.
    
    For the suspend to standby mode, the master clock doesn't switch to the slow
    clock, and PLLA and the main oscillator doesn't turn off as well.
    
    Signed-off-by: Wenyou Yang <wenyou.yang@atmel.com>
    Tested-by: Sylvain Rochet <sylvain.rochet@finsecur.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 7cb3a33bdba3..3fc5e12043a2 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -128,62 +128,55 @@ extern void at91_slow_clock(void __iomem *pmc, void __iomem *ramc0,
 			    void __iomem *ramc1, int memctrl);
 extern u32 at91_slow_clock_sz;
 
+static void at91_pm_suspend(suspend_state_t state)
+{
+	unsigned int pm_data = at91_pm_data.memctrl;
+
+	pm_data |= (state == PM_SUSPEND_MEM) ?
+				AT91_PM_MODE(AT91_PM_SLOW_CLOCK) : 0;
+
+	slow_clock(at91_pmc_base, at91_ramc_base[0],
+			at91_ramc_base[1], pm_data);
+}
+
 static int at91_pm_enter(suspend_state_t state)
 {
 	at91_pinctrl_gpio_suspend();
 
 	switch (state) {
+	/*
+	 * Suspend-to-RAM is like STANDBY plus slow clock mode, so
+	 * drivers must suspend more deeply, the master clock switches
+	 * to the clk32k and turns off the main oscillator
+	 */
+	case PM_SUSPEND_MEM:
 		/*
-		 * Suspend-to-RAM is like STANDBY plus slow clock mode, so
-		 * drivers must suspend more deeply:  only the master clock
-		 * controller may be using the main oscillator.
+		 * Ensure that clocks are in a valid state.
 		 */
-		case PM_SUSPEND_MEM:
-			/*
-			 * Ensure that clocks are in a valid state.
-			 */
-			if (!at91_pm_verify_clocks())
-				goto error;
-
-			/*
-			 * Enter slow clock mode by switching over to clk32k and
-			 * turning off the main oscillator; reverse on wakeup.
-			 */
-			if (slow_clock) {
-				slow_clock(at91_pmc_base, at91_ramc_base[0],
-					   at91_ramc_base[1],
-					   at91_pm_data.memctrl);
-				break;
-			} else {
-				pr_info("AT91: PM - no slow clock mode enabled ...\n");
-				/* FALLTHROUGH leaving master clock alone */
-			}
+		if (!at91_pm_verify_clocks())
+			goto error;
 
-		/*
-		 * STANDBY mode has *all* drivers suspended; ignores irqs not
-		 * marked as 'wakeup' event sources; and reduces DRAM power.
-		 * But otherwise it's identical to PM_SUSPEND_ON:  cpu idle, and
-		 * nothing fancy done with main or cpu clocks.
-		 */
-		case PM_SUSPEND_STANDBY:
-			/*
-			 * NOTE: the Wait-for-Interrupt instruction needs to be
-			 * in icache so no SDRAM accesses are needed until the
-			 * wakeup IRQ occurs and self-refresh is terminated.
-			 * For ARM 926 based chips, this requirement is weaker
-			 * as at91sam9 can access a RAM in self-refresh mode.
-			 */
-			if (at91_pm_standby)
-				at91_pm_standby();
-			break;
+		at91_pm_suspend(state);
 
-		case PM_SUSPEND_ON:
-			cpu_do_idle();
-			break;
+		break;
 
-		default:
-			pr_debug("AT91: PM - bogus suspend state %d\n", state);
-			goto error;
+	/*
+	 * STANDBY mode has *all* drivers suspended; ignores irqs not
+	 * marked as 'wakeup' event sources; and reduces DRAM power.
+	 * But otherwise it's identical to PM_SUSPEND_ON: cpu idle, and
+	 * nothing fancy done with main or cpu clocks.
+	 */
+	case PM_SUSPEND_STANDBY:
+		at91_pm_suspend(state);
+		break;
+
+	case PM_SUSPEND_ON:
+		cpu_do_idle();
+		break;
+
+	default:
+		pr_debug("AT91: PM - bogus suspend state %d\n", state);
+		goto error;
 	}
 
 error:

commit d94e688cae5661b18164fb7366d1696a1921baba
Author: Wenyou Yang <wenyou.yang@atmel.com>
Date:   Mon Mar 9 11:49:01 2015 +0800

    ARM: at91/pm: move the copying the sram function to the sram initialization phase
    
    To decrease the suspend time, move copying the sram function to the sram
    initialization phase, instead of every time go to suspend.
    
    In the meanwhile, substitute fncpy() for memcpy().
    
    If there is no sram allocated for PM, the PM is not supported.
    
    Signed-off-by: Wenyou Yang <wenyou.yang@atmel.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Tested-by: Sylvain Rochet <sylvain.rochet@finsecur.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index ea4d888994af..7cb3a33bdba3 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -29,6 +29,7 @@
 #include <linux/atomic.h>
 #include <asm/mach/time.h>
 #include <asm/mach/irq.h>
+#include <asm/fncpy.h>
 
 #include <mach/cpu.h>
 #include <mach/hardware.h>
@@ -149,9 +150,6 @@ static int at91_pm_enter(suspend_state_t state)
 			 * turning off the main oscillator; reverse on wakeup.
 			 */
 			if (slow_clock) {
-				/* copy slow_clock handler to SRAM, and call it */
-				memcpy(slow_clock, at91_slow_clock, at91_slow_clock_sz);
-
 				slow_clock(at91_pmc_base, at91_ramc_base[0],
 					   at91_ramc_base[1],
 					   at91_pm_data.memctrl);
@@ -295,6 +293,13 @@ static void __init at91_pm_sram_init(void)
 
 	sram_pbase = gen_pool_virt_to_phys(sram_pool, sram_base);
 	slow_clock = __arm_ioremap_exec(sram_pbase, at91_slow_clock_sz, false);
+	if (!slow_clock) {
+		pr_warn("SRAM: Could not map\n");
+		return;
+	}
+
+	/* Copy the slow_clock handler to SRAM */
+	slow_clock = fncpy(slow_clock, &at91_slow_clock, at91_slow_clock_sz);
 }
 
 static void __init at91_pm_init(void)
@@ -304,7 +309,10 @@ static void __init at91_pm_init(void)
 	if (at91_cpuidle_device.dev.platform_data)
 		platform_device_register(&at91_cpuidle_device);
 
-	suspend_set_ops(&at91_pm_ops);
+	if (slow_clock)
+		suspend_set_ops(&at91_pm_ops);
+	else
+		pr_info("AT91: PM not supported, due to no SRAM allocated\n");
 }
 
 void __init at91rm9200_pm_init(void)

commit 09fc78a601e59de89f125c8e6739fd21a7e2fd01
Author: Wenyou Yang <wenyou.yang@atmel.com>
Date:   Mon Mar 9 11:45:35 2015 +0800

    ARM: at91/pm: remove CONFIG_AT91_SLOW_CLOCK config option
    
    The slow clock always exists, selecting CONFIG_AT91_SLOW_CLOCK config
    is unnecessary for the suspend to memory mode.
    For this mode the master clock should always switch to the slow clock.
    
    Signed-off-by: Wenyou Yang <wenyou.yang@atmel.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Tested-by: Sylvain Rochet <sylvain.rochet@finsecur.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index a4473dcd0f7c..ea4d888994af 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -123,11 +123,9 @@ EXPORT_SYMBOL(at91_suspend_entering_slow_clock);
 static void (*slow_clock)(void __iomem *pmc, void __iomem *ramc0,
 			  void __iomem *ramc1, int memctrl);
 
-#ifdef CONFIG_AT91_SLOW_CLOCK
 extern void at91_slow_clock(void __iomem *pmc, void __iomem *ramc0,
 			    void __iomem *ramc1, int memctrl);
 extern u32 at91_slow_clock_sz;
-#endif
 
 static int at91_pm_enter(suspend_state_t state)
 {
@@ -151,10 +149,9 @@ static int at91_pm_enter(suspend_state_t state)
 			 * turning off the main oscillator; reverse on wakeup.
 			 */
 			if (slow_clock) {
-#ifdef CONFIG_AT91_SLOW_CLOCK
 				/* copy slow_clock handler to SRAM, and call it */
 				memcpy(slow_clock, at91_slow_clock, at91_slow_clock_sz);
-#endif
+
 				slow_clock(at91_pmc_base, at91_ramc_base[0],
 					   at91_ramc_base[1],
 					   at91_pm_data.memctrl);
@@ -263,7 +260,6 @@ static __init void at91_dt_ramc(void)
 	at91_pm_set_standby(standby);
 }
 
-#ifdef CONFIG_AT91_SLOW_CLOCK
 static void __init at91_pm_sram_init(void)
 {
 	struct gen_pool *sram_pool;
@@ -300,16 +296,10 @@ static void __init at91_pm_sram_init(void)
 	sram_pbase = gen_pool_virt_to_phys(sram_pool, sram_base);
 	slow_clock = __arm_ioremap_exec(sram_pbase, at91_slow_clock_sz, false);
 }
-#endif
-
 
 static void __init at91_pm_init(void)
 {
-#ifdef CONFIG_AT91_SLOW_CLOCK
 	at91_pm_sram_init();
-#endif
-
-	pr_info("AT91: Power Management%s\n", (slow_clock ? " (with slow clock mode)" : ""));
 
 	if (at91_cpuidle_device.dev.platform_data)
 		platform_device_register(&at91_cpuidle_device);

commit 047794e13632f177e864eba6160cecfbf3875cbe
Author: Wenyou Yang <wenyou.yang@atmel.com>
Date:   Wed Mar 4 09:44:45 2015 +0800

    ARM: at91: pm: change at91_pm_set_standby() to static
    
    Since at91_pm_set_standby() will not be used out of the pm.c file,
    change its attribute from extern to static, remove its declaration as well.
    
    Signed-off-by: Wenyou Yang <wenyou.yang@atmel.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index aa4116e9452f..a4473dcd0f7c 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -218,7 +218,7 @@ static struct platform_device at91_cpuidle_device = {
 	.name = "cpuidle-at91",
 };
 
-void at91_pm_set_standby(void (*at91_standby)(void))
+static void at91_pm_set_standby(void (*at91_standby)(void))
 {
 	if (at91_standby) {
 		at91_cpuidle_device.dev.platform_data = at91_standby;

commit 4a031f7dbe497a66cd18b33fc6e5ce2e889d89c7
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Tue Mar 3 08:38:07 2015 +0100

    ARM: at91: pm: fix SRAM allocation
    
    On some platforms, there are multiple SRAM nodes defined in the device tree but
    some of them are disabled, leading to allocation failure. Try to find the first
    enabled SRAM node and allocate from it.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Tested-by: Wenyou Yang <wenyou.yang@atmel.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 5e34fb143309..aa4116e9452f 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -270,37 +270,35 @@ static void __init at91_pm_sram_init(void)
 	phys_addr_t sram_pbase;
 	unsigned long sram_base;
 	struct device_node *node;
-	struct platform_device *pdev;
+	struct platform_device *pdev = NULL;
 
-	node = of_find_compatible_node(NULL, NULL, "mmio-sram");
-	if (!node) {
-		pr_warn("%s: failed to find sram node!\n", __func__);
-		return;
+	for_each_compatible_node(node, NULL, "mmio-sram") {
+		pdev = of_find_device_by_node(node);
+		if (pdev) {
+			of_node_put(node);
+			break;
+		}
 	}
 
-	pdev = of_find_device_by_node(node);
 	if (!pdev) {
 		pr_warn("%s: failed to find sram device!\n", __func__);
-		goto put_node;
+		return;
 	}
 
 	sram_pool = dev_get_gen_pool(&pdev->dev);
 	if (!sram_pool) {
 		pr_warn("%s: sram pool unavailable!\n", __func__);
-		goto put_node;
+		return;
 	}
 
 	sram_base = gen_pool_alloc(sram_pool, at91_slow_clock_sz);
 	if (!sram_base) {
 		pr_warn("%s: unable to alloc ocram!\n", __func__);
-		goto put_node;
+		return;
 	}
 
 	sram_pbase = gen_pool_virt_to_phys(sram_pool, sram_base);
 	slow_clock = __arm_ioremap_exec(sram_pbase, at91_slow_clock_sz, false);
-
-put_node:
-	of_node_put(node);
 }
 #endif
 

commit 444d2d33d8564f95df851ddaca80f640ca36934d
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Feb 18 21:19:56 2015 +0100

    ARM: make of_device_ids const
    
    of_device_ids (i.e. compatible strings and the respective data) are not
    supposed to change at runtime. All functions working with of_device_ids
    provided by <linux/of.h> work with const of_device_ids. So mark the
    non-const structs in arch/arm as const, too.
    
    While at it also add some __initconst annotations.
    
    Acked-by: Jason Cooper <jason@lakedameon.net>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index af8d8afc2e12..5e34fb143309 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -226,7 +226,7 @@ void at91_pm_set_standby(void (*at91_standby)(void))
 	}
 }
 
-static struct of_device_id ramc_ids[] = {
+static const struct of_device_id ramc_ids[] __initconst = {
 	{ .compatible = "atmel,at91rm9200-sdramc", .data = at91rm9200_standby },
 	{ .compatible = "atmel,at91sam9260-sdramc", .data = at91sam9_sdram_standby },
 	{ .compatible = "atmel,at91sam9g45-ddramc", .data = at91_ddr_standby },
@@ -234,7 +234,7 @@ static struct of_device_id ramc_ids[] = {
 	{ /*sentinel*/ }
 };
 
-static void at91_dt_ramc(void)
+static __init void at91_dt_ramc(void)
 {
 	struct device_node *np;
 	const struct of_device_id *of_id;

commit ad3fc3e316891cbc4f33116a61c57c4a9b2a2518
Author: Nicolas Ferre <nicolas.ferre@atmel.com>
Date:   Tue Jan 27 18:41:33 2015 +0100

    ARM: at91/trivial: unify functions and machine names
    
    Remove the string "(Device Tree)" after the machine name because all AT91
    machines use the DT nowadays.
    Also change some function names to unify following the convention:
    - at91sam9xxx aren't named sam9, 9xxx but with the full name
    - sama5 are the ones that don't have the at91 prefix anymore.
    
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 25bb93db8208..af8d8afc2e12 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -319,7 +319,7 @@ static void __init at91_pm_init(void)
 	suspend_set_ops(&at91_pm_ops);
 }
 
-void __init at91_rm9200_pm_init(void)
+void __init at91rm9200_pm_init(void)
 {
 	at91_dt_ramc();
 
@@ -334,7 +334,7 @@ void __init at91_rm9200_pm_init(void)
 	at91_pm_init();
 }
 
-void __init at91_sam9260_pm_init(void)
+void __init at91sam9260_pm_init(void)
 {
 	at91_dt_ramc();
 	at91_pm_data.memctrl = AT91_MEMCTRL_SDRAMC;
@@ -342,7 +342,7 @@ void __init at91_sam9260_pm_init(void)
 	return at91_pm_init();
 }
 
-void __init at91_sam9g45_pm_init(void)
+void __init at91sam9g45_pm_init(void)
 {
 	at91_dt_ramc();
 	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP;
@@ -350,7 +350,7 @@ void __init at91_sam9g45_pm_init(void)
 	return at91_pm_init();
 }
 
-void __init at91_sam9x5_pm_init(void)
+void __init at91sam9x5_pm_init(void)
 {
 	at91_dt_ramc();
 	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;

commit 827de1f123ba0880033d1b5299e116470e19bafb
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Tue Jan 27 17:38:46 2015 +0100

    ARM: at91: remove at91_dt_initialize and machine init_early()
    
    Move the ramc initialization to pm.c as it is the only user left.
    This allows us to get rid of at91_dt_initialize() that was the only one called
    by the init_early() function pointer of struct machine_desc.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    [nicolas.ferre@atmel.com: adapt patch to newer series]
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 87c1fd8aa1b6..25bb93db8208 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -20,6 +20,7 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_platform.h>
+#include <linux/of_address.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
 #include <linux/clk/at91_pmc.h>
@@ -41,6 +42,7 @@ static struct {
 } at91_pm_data;
 
 static void (*at91_pm_standby)(void);
+void __iomem *at91_ramc_base[2];
 
 static int at91_pm_valid_state(suspend_state_t state)
 {
@@ -224,6 +226,43 @@ void at91_pm_set_standby(void (*at91_standby)(void))
 	}
 }
 
+static struct of_device_id ramc_ids[] = {
+	{ .compatible = "atmel,at91rm9200-sdramc", .data = at91rm9200_standby },
+	{ .compatible = "atmel,at91sam9260-sdramc", .data = at91sam9_sdram_standby },
+	{ .compatible = "atmel,at91sam9g45-ddramc", .data = at91_ddr_standby },
+	{ .compatible = "atmel,sama5d3-ddramc", .data = at91_ddr_standby },
+	{ /*sentinel*/ }
+};
+
+static void at91_dt_ramc(void)
+{
+	struct device_node *np;
+	const struct of_device_id *of_id;
+	int idx = 0;
+	const void *standby = NULL;
+
+	for_each_matching_node_and_match(np, ramc_ids, &of_id) {
+		at91_ramc_base[idx] = of_iomap(np, 0);
+		if (!at91_ramc_base[idx])
+			panic(pr_fmt("unable to map ramc[%d] cpu registers\n"), idx);
+
+		if (!standby)
+			standby = of_id->data;
+
+		idx++;
+	}
+
+	if (!idx)
+		panic(pr_fmt("unable to find compatible ram controller node in dtb\n"));
+
+	if (!standby) {
+		pr_warn("ramc no standby function available\n");
+		return;
+	}
+
+	at91_pm_set_standby(standby);
+}
+
 #ifdef CONFIG_AT91_SLOW_CLOCK
 static void __init at91_pm_sram_init(void)
 {
@@ -282,6 +321,8 @@ static void __init at91_pm_init(void)
 
 void __init at91_rm9200_pm_init(void)
 {
+	at91_dt_ramc();
+
 	/*
 	 * AT91RM9200 SDRAM low-power mode cannot be used with self-refresh.
 	 */
@@ -295,6 +336,7 @@ void __init at91_rm9200_pm_init(void)
 
 void __init at91_sam9260_pm_init(void)
 {
+	at91_dt_ramc();
 	at91_pm_data.memctrl = AT91_MEMCTRL_SDRAMC;
 	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
 	return at91_pm_init();
@@ -302,6 +344,7 @@ void __init at91_sam9260_pm_init(void)
 
 void __init at91_sam9g45_pm_init(void)
 {
+	at91_dt_ramc();
 	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP;
 	at91_pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
 	return at91_pm_init();
@@ -309,6 +352,7 @@ void __init at91_sam9g45_pm_init(void)
 
 void __init at91_sam9x5_pm_init(void)
 {
+	at91_dt_ramc();
 	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
 	at91_pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
 	return at91_pm_init();

commit bf02280e435cb620b255bb03738ac334cb7233dd
Author: Nicolas Ferre <nicolas.ferre@atmel.com>
Date:   Thu Jan 22 16:54:50 2015 +0100

    ARM: at91: fix PM initialization for newer SoCs
    
    Newer SoCs: at91sam9x5, at91sam9n12, sama5d3 and sama5d4 embed a DDR controller
    and have a different PMC status register layout than the at91sam9g45. Create
    another at91_sam9x5_pm_init() function to match this compatibility.
    
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 81f2f12d3cc1..87c1fd8aa1b6 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -306,3 +306,10 @@ void __init at91_sam9g45_pm_init(void)
 	at91_pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
 	return at91_pm_init();
 }
+
+void __init at91_sam9x5_pm_init(void)
+{
+	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
+	at91_pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
+	return at91_pm_init();
+}

commit 4db0ba22da9f4406c292a6a6110eeb2edd12f16a
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Thu Jan 15 15:59:27 2015 +0100

    ARM: at91: pm: prepare for multiplatform
    
    Split at91_pm_init() in three variants that are called by the respective SoCs
    .init_machine. This allows to remove the of_machine_is_compatible() calls and
    move at91_pm_init() out of arch_initcall() which is required for multiplatform.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 71cc845263dc..81f2f12d3cc1 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -266,7 +266,7 @@ static void __init at91_pm_sram_init(void)
 #endif
 
 
-static int __init at91_pm_init(void)
+static void __init at91_pm_init(void)
 {
 #ifdef CONFIG_AT91_SLOW_CLOCK
 	at91_pm_sram_init();
@@ -274,29 +274,35 @@ static int __init at91_pm_init(void)
 
 	pr_info("AT91: Power Management%s\n", (slow_clock ? " (with slow clock mode)" : ""));
 
-	at91_pm_data.memctrl = AT91_MEMCTRL_SDRAMC;
-	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
-
-	if (of_machine_is_compatible("atmel,at91rm9200")) {
-		/*
-		 * AT91RM9200 SDRAM low-power mode cannot be used with
-		 * self-refresh.
-		 */
-		at91_ramc_write(0, AT91RM9200_SDRAMC_LPR, 0);
-
-		at91_pm_data.uhp_udp_mask = AT91RM9200_PMC_UHP |
-					    AT91RM9200_PMC_UDP;
-		at91_pm_data.memctrl = AT91_MEMCTRL_MC;
-	} else if (of_machine_is_compatible("atmel,at91sam9g45")) {
-		at91_pm_data.uhp_udp_mask = AT91RM9200_PMC_UHP;
-		at91_pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
-	}
-
 	if (at91_cpuidle_device.dev.platform_data)
 		platform_device_register(&at91_cpuidle_device);
 
 	suspend_set_ops(&at91_pm_ops);
+}
 
-	return 0;
+void __init at91_rm9200_pm_init(void)
+{
+	/*
+	 * AT91RM9200 SDRAM low-power mode cannot be used with self-refresh.
+	 */
+	at91_ramc_write(0, AT91RM9200_SDRAMC_LPR, 0);
+
+	at91_pm_data.uhp_udp_mask = AT91RM9200_PMC_UHP | AT91RM9200_PMC_UDP;
+	at91_pm_data.memctrl = AT91_MEMCTRL_MC;
+
+	at91_pm_init();
+}
+
+void __init at91_sam9260_pm_init(void)
+{
+	at91_pm_data.memctrl = AT91_MEMCTRL_SDRAMC;
+	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
+	return at91_pm_init();
+}
+
+void __init at91_sam9g45_pm_init(void)
+{
+	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP;
+	at91_pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
+	return at91_pm_init();
 }
-arch_initcall(at91_pm_init);

commit a63ba4114690cad6e71cbcfd187b0ebf20321dfa
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Thu Jan 15 15:59:26 2015 +0100

    ARM: at91: pm: add UDP and UHP checks to newer SoCs
    
    Check UDP and UHP on sam9x5, sam9n12 and the sama5 series.
    Check UHP on the sam9g45.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 515791edcc60..71cc845263dc 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -275,6 +275,7 @@ static int __init at91_pm_init(void)
 	pr_info("AT91: Power Management%s\n", (slow_clock ? " (with slow clock mode)" : ""));
 
 	at91_pm_data.memctrl = AT91_MEMCTRL_SDRAMC;
+	at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP;
 
 	if (of_machine_is_compatible("atmel,at91rm9200")) {
 		/*
@@ -286,14 +287,8 @@ static int __init at91_pm_init(void)
 		at91_pm_data.uhp_udp_mask = AT91RM9200_PMC_UHP |
 					    AT91RM9200_PMC_UDP;
 		at91_pm_data.memctrl = AT91_MEMCTRL_MC;
-	} else if (of_machine_is_compatible("atmel,at91sam9260") ||
-		   of_machine_is_compatible("atmel,at91sam9g20") ||
-		   of_machine_is_compatible("atmel,at91sam9261") ||
-		   of_machine_is_compatible("atmel,at91sam9g10") ||
-		   of_machine_is_compatible("atmel,at91sam9263")) {
-		at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP |
-					    AT91SAM926x_PMC_UDP;
 	} else if (of_machine_is_compatible("atmel,at91sam9g45")) {
+		at91_pm_data.uhp_udp_mask = AT91RM9200_PMC_UHP;
 		at91_pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
 	}
 

commit d2e467905596760f1218e3382de24ab2c14d5baf
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Thu Jan 15 15:59:25 2015 +0100

    ARM: at91: pm: use the mmio-sram pool to access SRAM
    
    Now that the SRAM is part of a genpool, use it to allocate memory to use for the
    slowclock implementation.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 79aa793d1f00..515791edcc60 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -14,10 +14,12 @@
 #include <linux/suspend.h>
 #include <linux/sched.h>
 #include <linux/proc_fs.h>
+#include <linux/genalloc.h>
 #include <linux/interrupt.h>
 #include <linux/sysfs.h>
 #include <linux/module.h>
 #include <linux/of.h>
+#include <linux/of_platform.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
 #include <linux/clk/at91_pmc.h>
@@ -222,10 +224,52 @@ void at91_pm_set_standby(void (*at91_standby)(void))
 	}
 }
 
+#ifdef CONFIG_AT91_SLOW_CLOCK
+static void __init at91_pm_sram_init(void)
+{
+	struct gen_pool *sram_pool;
+	phys_addr_t sram_pbase;
+	unsigned long sram_base;
+	struct device_node *node;
+	struct platform_device *pdev;
+
+	node = of_find_compatible_node(NULL, NULL, "mmio-sram");
+	if (!node) {
+		pr_warn("%s: failed to find sram node!\n", __func__);
+		return;
+	}
+
+	pdev = of_find_device_by_node(node);
+	if (!pdev) {
+		pr_warn("%s: failed to find sram device!\n", __func__);
+		goto put_node;
+	}
+
+	sram_pool = dev_get_gen_pool(&pdev->dev);
+	if (!sram_pool) {
+		pr_warn("%s: sram pool unavailable!\n", __func__);
+		goto put_node;
+	}
+
+	sram_base = gen_pool_alloc(sram_pool, at91_slow_clock_sz);
+	if (!sram_base) {
+		pr_warn("%s: unable to alloc ocram!\n", __func__);
+		goto put_node;
+	}
+
+	sram_pbase = gen_pool_virt_to_phys(sram_pool, sram_base);
+	slow_clock = __arm_ioremap_exec(sram_pbase, at91_slow_clock_sz, false);
+
+put_node:
+	of_node_put(node);
+}
+#endif
+
+
 static int __init at91_pm_init(void)
 {
 #ifdef CONFIG_AT91_SLOW_CLOCK
-	slow_clock = (void *) (AT91_IO_VIRT_BASE - at91_slow_clock_sz);
+	at91_pm_sram_init();
 #endif
 
 	pr_info("AT91: Power Management%s\n", (slow_clock ? " (with slow clock mode)" : ""));

commit f5598d346e36169f3eb4008c895300a39b100a0b
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Thu Jan 15 15:59:24 2015 +0100

    ARM: at91: pm: rework cpu detection
    
    Store SoC differences in a struct to remove cpu_is_* usage.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 9b15169a1c62..79aa793d1f00 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -17,6 +17,7 @@
 #include <linux/interrupt.h>
 #include <linux/sysfs.h>
 #include <linux/module.h>
+#include <linux/of.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
 #include <linux/clk/at91_pmc.h>
@@ -32,6 +33,11 @@
 #include "generic.h"
 #include "pm.h"
 
+static struct {
+	unsigned long uhp_udp_mask;
+	int memctrl;
+} at91_pm_data;
+
 static void (*at91_pm_standby)(void);
 
 static int at91_pm_valid_state(suspend_state_t state)
@@ -71,17 +77,9 @@ static int at91_pm_verify_clocks(void)
 	scsr = at91_pmc_read(AT91_PMC_SCSR);
 
 	/* USB must not be using PLLB */
-	if (cpu_is_at91rm9200()) {
-		if ((scsr & (AT91RM9200_PMC_UHP | AT91RM9200_PMC_UDP)) != 0) {
-			pr_err("AT91: PM - Suspend-to-RAM with USB still active\n");
-			return 0;
-		}
-	} else if (cpu_is_at91sam9260() || cpu_is_at91sam9261() || cpu_is_at91sam9263()
-			|| cpu_is_at91sam9g20() || cpu_is_at91sam9g10()) {
-		if ((scsr & (AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP)) != 0) {
-			pr_err("AT91: PM - Suspend-to-RAM with USB still active\n");
-			return 0;
-		}
+	if ((scsr & at91_pm_data.uhp_udp_mask) != 0) {
+		pr_err("AT91: PM - Suspend-to-RAM with USB still active\n");
+		return 0;
 	}
 
 	/* PCK0..PCK3 must be disabled, or configured to use clk32k */
@@ -149,18 +147,13 @@ static int at91_pm_enter(suspend_state_t state)
 			 * turning off the main oscillator; reverse on wakeup.
 			 */
 			if (slow_clock) {
-				int memctrl = AT91_MEMCTRL_SDRAMC;
-
-				if (cpu_is_at91rm9200())
-					memctrl = AT91_MEMCTRL_MC;
-				else if (cpu_is_at91sam9g45())
-					memctrl = AT91_MEMCTRL_DDRSDR;
 #ifdef CONFIG_AT91_SLOW_CLOCK
 				/* copy slow_clock handler to SRAM, and call it */
 				memcpy(slow_clock, at91_slow_clock, at91_slow_clock_sz);
 #endif
 				slow_clock(at91_pmc_base, at91_ramc_base[0],
-					   at91_ramc_base[1], memctrl);
+					   at91_ramc_base[1],
+					   at91_pm_data.memctrl);
 				break;
 			} else {
 				pr_info("AT91: PM - no slow clock mode enabled ...\n");
@@ -237,10 +230,29 @@ static int __init at91_pm_init(void)
 
 	pr_info("AT91: Power Management%s\n", (slow_clock ? " (with slow clock mode)" : ""));
 
-	/* AT91RM9200 SDRAM low-power mode cannot be used with self-refresh. */
-	if (cpu_is_at91rm9200())
+	at91_pm_data.memctrl = AT91_MEMCTRL_SDRAMC;
+
+	if (of_machine_is_compatible("atmel,at91rm9200")) {
+		/*
+		 * AT91RM9200 SDRAM low-power mode cannot be used with
+		 * self-refresh.
+		 */
 		at91_ramc_write(0, AT91RM9200_SDRAMC_LPR, 0);
-	
+
+		at91_pm_data.uhp_udp_mask = AT91RM9200_PMC_UHP |
+					    AT91RM9200_PMC_UDP;
+		at91_pm_data.memctrl = AT91_MEMCTRL_MC;
+	} else if (of_machine_is_compatible("atmel,at91sam9260") ||
+		   of_machine_is_compatible("atmel,at91sam9g20") ||
+		   of_machine_is_compatible("atmel,at91sam9261") ||
+		   of_machine_is_compatible("atmel,at91sam9g10") ||
+		   of_machine_is_compatible("atmel,at91sam9263")) {
+		at91_pm_data.uhp_udp_mask = AT91SAM926x_PMC_UHP |
+					    AT91SAM926x_PMC_UDP;
+	} else if (of_machine_is_compatible("atmel,at91sam9g45")) {
+		at91_pm_data.memctrl = AT91_MEMCTRL_DDRSDR;
+	}
+
 	if (at91_cpuidle_device.dev.platform_data)
 		platform_device_register(&at91_cpuidle_device);
 

commit 85c4b31e6e462674a0392240e7e38ebe8bb22832
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Dec 2 12:08:27 2014 +0100

    ARM: at91: remove old AT91-specific drivers
    
    GPIO and LED drivers were replaced by generic ones for DT boards. These drivers
    were remaining: delete them now. Modifications are also done on the
    corresponding header files.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    [nicolas.ferre@atmel.com: split patch]
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index a42360f69127..9b15169a1c62 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -31,7 +31,6 @@
 
 #include "generic.h"
 #include "pm.h"
-#include "gpio.h"
 
 static void (*at91_pm_standby)(void);
 
@@ -130,10 +129,7 @@ extern u32 at91_slow_clock_sz;
 
 static int at91_pm_enter(suspend_state_t state)
 {
-	if (of_have_populated_dt())
-		at91_pinctrl_gpio_suspend();
-	else
-		at91_gpio_suspend();
+	at91_pinctrl_gpio_suspend();
 
 	switch (state) {
 		/*
@@ -201,10 +197,7 @@ static int at91_pm_enter(suspend_state_t state)
 error:
 	target_state = PM_SUSPEND_ON;
 
-	if (of_have_populated_dt())
-		at91_pinctrl_gpio_resume();
-	else
-		at91_gpio_resume();
+	at91_pinctrl_gpio_resume();
 	return 0;
 }
 

commit 1ccdde057b03a2446eeee7b7a63306c4d9c68d61
Author: Nicolas Ferre <nicolas.ferre@atmel.com>
Date:   Thu Nov 27 16:10:06 2014 +0100

    ARM: at91: remove legacy IRQ driver and related code
    
    Remove irc.c and associated header file. The related code was idendified by
    the CONFIG_OLD_IRQ_AT91 option that was removed previously. It has been spotted
    by following coccinelle semantic match:
    
    @rule1@
    expression E;
    statement S;
    @@
    (
    - if (IS_ENABLED(CONFIG_OLD_IRQ_AT91)) S
    |
    - if (IS_ENABLED(CONFIG_OLD_IRQ_AT91) && E) S
    )
    
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Acked-by: Boris BREZILLON <boris.brezillon@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 4073ab7f38f3..a42360f69127 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -29,7 +29,6 @@
 #include <mach/cpu.h>
 #include <mach/hardware.h>
 
-#include "at91_aic.h"
 #include "generic.h"
 #include "pm.h"
 #include "gpio.h"
@@ -136,19 +135,6 @@ static int at91_pm_enter(suspend_state_t state)
 	else
 		at91_gpio_suspend();
 
-	if (IS_ENABLED(CONFIG_OLD_IRQ_AT91) && at91_aic_base) {
-		at91_irq_suspend();
-
-		pr_debug("AT91: PM - wake mask %08x, pm state %d\n",
-				/* remember all the always-wake irqs */
-				(at91_pmc_read(AT91_PMC_PCSR)
-						| (1 << AT91_ID_FIQ)
-						| (1 << AT91_ID_SYS)
-						| (at91_get_extern_irq()))
-					& at91_aic_read(AT91_AIC_IMR),
-				state);
-	}
-
 	switch (state) {
 		/*
 		 * Suspend-to-RAM is like STANDBY plus slow clock mode, so
@@ -212,17 +198,9 @@ static int at91_pm_enter(suspend_state_t state)
 			goto error;
 	}
 
-	if (IS_ENABLED(CONFIG_OLD_IRQ_AT91) && at91_aic_base)
-		pr_debug("AT91: PM - wakeup %08x\n",
-			 at91_aic_read(AT91_AIC_IPR) &
-			 at91_aic_read(AT91_AIC_IMR));
-
 error:
 	target_state = PM_SUSPEND_ON;
 
-	if (IS_ENABLED(CONFIG_OLD_IRQ_AT91) && at91_aic_base)
-		at91_irq_resume();
-
 	if (of_have_populated_dt())
 		at91_pinctrl_gpio_resume();
 	else

commit 572e85e3aa58f11671759e9cfa6b9b5d79b131fd
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Thu Jul 3 14:46:05 2014 +0200

    ARM: at91/pm: Remove show_reset_status function
    
    Both the reset and poweroff drivers are now implementing what the
    show_reset_status function used to do. Hence, we can remove this rather hackish
    function that prevents us from doing further cleanup.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 5920373809c5..4073ab7f38f3 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -34,79 +34,8 @@
 #include "pm.h"
 #include "gpio.h"
 
-/*
- * Show the reason for the previous system reset.
- */
-
-#include "at91_rstc.h"
-#include "at91_shdwc.h"
-
 static void (*at91_pm_standby)(void);
 
-static void __init show_reset_status(void)
-{
-	static char reset[] __initdata = "reset";
-
-	static char general[] __initdata = "general";
-	static char wakeup[] __initdata = "wakeup";
-	static char watchdog[] __initdata = "watchdog";
-	static char software[] __initdata = "software";
-	static char user[] __initdata = "user";
-	static char unknown[] __initdata = "unknown";
-
-	static char signal[] __initdata = "signal";
-	static char rtc[] __initdata = "rtc";
-	static char rtt[] __initdata = "rtt";
-	static char restore[] __initdata = "power-restored";
-
-	char *reason, *r2 = reset;
-	u32 reset_type, wake_type;
-
-	if (!at91_shdwc_base || !at91_rstc_base)
-		return;
-
-	reset_type = at91_rstc_read(AT91_RSTC_SR) & AT91_RSTC_RSTTYP;
-	wake_type = at91_shdwc_read(AT91_SHDW_SR);
-
-	switch (reset_type) {
-	case AT91_RSTC_RSTTYP_GENERAL:
-		reason = general;
-		break;
-	case AT91_RSTC_RSTTYP_WAKEUP:
-		/* board-specific code enabled the wakeup sources */
-		reason = wakeup;
-
-		/* "wakeup signal" */
-		if (wake_type & AT91_SHDW_WAKEUP0)
-			r2 = signal;
-		else {
-			r2 = reason;
-			if (wake_type & AT91_SHDW_RTTWK)	/* rtt wakeup */
-				reason = rtt;
-			else if (wake_type & AT91_SHDW_RTCWK)	/* rtc wakeup */
-				reason = rtc;
-			else if (wake_type == 0)	/* power-restored wakeup */
-				reason = restore;
-			else				/* unknown wakeup */
-				reason = unknown;
-		}
-		break;
-	case AT91_RSTC_RSTTYP_WATCHDOG:
-		reason = watchdog;
-		break;
-	case AT91_RSTC_RSTTYP_SOFTWARE:
-		reason = software;
-		break;
-	case AT91_RSTC_RSTTYP_USER:
-		reason = user;
-		break;
-	default:
-		reason = unknown;
-		break;
-	}
-	pr_info("AT91: Starting after %s %s\n", reason, r2);
-}
-
 static int at91_pm_valid_state(suspend_state_t state)
 {
 	switch (state) {
@@ -346,7 +275,6 @@ static int __init at91_pm_init(void)
 
 	suspend_set_ops(&at91_pm_ops);
 
-	show_reset_status();
 	return 0;
 }
 arch_initcall(at91_pm_init);

commit 071926041e5b38f84f2aaac2122c57e398e535b5
Author: Boris BREZILLON <boris.brezillon@free-electrons.com>
Date:   Thu Jul 10 19:14:20 2014 +0200

    ARM: at91: enclose at91_aic_xx calls in IS_ENABLED(CONFIG_OLD_IRQ_AT91) blocks
    
    Enclose at91_aic_xx calls in IS_ENABLED(CONFIG_OLD_IRQ_AT91) blocks in
    order to prepare migration to the new AIC driver.
    
    In the new AIC driver the suspend/resume functions are called by the
    generic irq framework and are no longer needed in the PM specific code.
    
    Moreover, the new AIC driver no longer exposes the at91_aic_base variable
    which is used by the at91_aic_read functions.
    
    Signed-off-by: Boris BREZILLON <boris.brezillon@free-electrons.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index e95554532987..5920373809c5 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -206,16 +206,19 @@ static int at91_pm_enter(suspend_state_t state)
 		at91_pinctrl_gpio_suspend();
 	else
 		at91_gpio_suspend();
-	at91_irq_suspend();
 
-	pr_debug("AT91: PM - wake mask %08x, pm state %d\n",
-			/* remember all the always-wake irqs */
-			(at91_pmc_read(AT91_PMC_PCSR)
-					| (1 << AT91_ID_FIQ)
-					| (1 << AT91_ID_SYS)
-					| (at91_get_extern_irq()))
-				& at91_aic_read(AT91_AIC_IMR),
-			state);
+	if (IS_ENABLED(CONFIG_OLD_IRQ_AT91) && at91_aic_base) {
+		at91_irq_suspend();
+
+		pr_debug("AT91: PM - wake mask %08x, pm state %d\n",
+				/* remember all the always-wake irqs */
+				(at91_pmc_read(AT91_PMC_PCSR)
+						| (1 << AT91_ID_FIQ)
+						| (1 << AT91_ID_SYS)
+						| (at91_get_extern_irq()))
+					& at91_aic_read(AT91_AIC_IMR),
+				state);
+	}
 
 	switch (state) {
 		/*
@@ -280,12 +283,17 @@ static int at91_pm_enter(suspend_state_t state)
 			goto error;
 	}
 
-	pr_debug("AT91: PM - wakeup %08x\n",
-			at91_aic_read(AT91_AIC_IPR) & at91_aic_read(AT91_AIC_IMR));
+	if (IS_ENABLED(CONFIG_OLD_IRQ_AT91) && at91_aic_base)
+		pr_debug("AT91: PM - wakeup %08x\n",
+			 at91_aic_read(AT91_AIC_IPR) &
+			 at91_aic_read(AT91_AIC_IMR));
 
 error:
 	target_state = PM_SUSPEND_ON;
-	at91_irq_resume();
+
+	if (IS_ENABLED(CONFIG_OLD_IRQ_AT91) && at91_aic_base)
+		at91_irq_resume();
+
 	if (of_have_populated_dt())
 		at91_pinctrl_gpio_resume();
 	else

commit cf2e933ce6da2a8bacd52e49c4dd4c0974af1d09
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Mar 27 14:18:51 2014 +0100

    ARM: at91: localize GPIO header
    
    This moves the <mach/gpio.h> header in the AT91 platform down
    into the machine directory and removes the reliance on
    MACH_NEED_GPIO_H from the AT91.
    
    This does not move the platform to GENERIC_GPIO but localize
    the remaining work to be done for this to the mach-at91
    folder.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    [nicolas.ferre@atmel.com: adapt to newer kernel, add rsi-ews board]
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 8bda1cefdf96..e95554532987 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -32,6 +32,7 @@
 #include "at91_aic.h"
 #include "generic.h"
 #include "pm.h"
+#include "gpio.h"
 
 /*
  * Show the reason for the previous system reset.

commit 11d73c56b96b4297bd96273e9a22b7c72d13f1fa
Merge: 6d0abeca3242 fb3174e4ad24
Author: Olof Johansson <olof@lixom.net>
Date:   Tue Feb 18 22:19:33 2014 -0800

    Merge tag 'dropmachtimexh-v2' of git://git.pengutronix.de/git/ukl/linux into next/cleanup
    
    This cleanup series gets rid of <mach/timex.h> for platforms not using
    ARCH_MULTIPLATFORM. (For multi-platform code it's already unused since
    387798b (ARM: initial multiplatform support).)
    
    To make this work some code out of arch/arm needed to be adapted. The
    respective changes got acks by their maintainers to be taken via armsoc
    (with Andrew Morton substituting for Alessandro Zummo as rtc maintainer).
    
    Compared to the previous pull request there was another patch added that
    fixes a (non-critical) regression on ixp4xx. Olof Johansson asked to not
    squash this fix into the original commit to save him from the need to
    reverify the series.
    
    * tag 'dropmachtimexh-v2' of git://git.pengutronix.de/git/ukl/linux:
      ARM: ixp4xx: fix timer latch calculation
      ARM: drop <mach/timex.h> for !ARCH_MULTIPLATFORM, too
      ARM: rpc: stop using <mach/timex.h>
      ARM: ixp4xx: stop using <mach/timex.h>
      input: ixp4xx-beeper: don't use symbols from <mach/timex.h>
      ARM: at91: don't use <mach/timex.h>
      ARM: ep93xx: stop using mach/timex.h
      ARM: mmp: stop using mach/timex.h
      ARM: netx: stop using mach/timex.h
      ARM: sa1100: stop using mach/timex.h
      clocksource: sirf/marco+prima2: drop usage of CLOCK_TICK_RATE
      rtc: pxa: drop unused #define TIMER_FREQ
      rtc: at91sam9: include <mach/hardware.h> explicitly
      ARM/serial: at91: switch atmel serial to use gpiolib
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit ac11a1d46cf06a8b5b3535f0ce12b6c1cb48ddab
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu Nov 14 10:49:19 2013 +0100

    ARM: at91: don't use <mach/timex.h>
    
    The platform specific <mach/timex.h> will be removed in a later patch.
    So move its only still used symbol to a different header specific for
    the only machine still using it. Also add a few explicit includes of
    <mach/hardware.h> that are implicitly available through <mach/timex.h>.
    
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 9986542e8060..7afecb8a35b1 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -27,6 +27,7 @@
 
 #include <mach/at91_pmc.h>
 #include <mach/cpu.h>
+#include <mach/hardware.h>
 
 #include "at91_aic.h"
 #include "generic.h"

commit 83301480111c9ac3fbd03ec5b0c90c21c5aa39f7
Author: Nicolas Ferre <nicolas.ferre@atmel.com>
Date:   Thu Dec 12 17:00:45 2013 +0100

    ARM: at91: remove AT91_PROGRAMMABLE_CLOCKS configuration option
    
    This AT91 specific Kconfig option removed the code that dealt with
    programmable clocks. Each AT91 SoC embeds programmable clocks and
    there is little gain to remove this code in case that such a clock
    is not used.
    If this option is not selected, it causes certain drivers to fail
    to build. We simply remove this option instead of adding code just
    to build a workaround.
    
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Kevin Hilman <khilman@linaro.org>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index d43b79f56e94..590b52dea9f7 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -155,9 +155,6 @@ static int at91_pm_verify_clocks(void)
 		}
 	}
 
-	if (!IS_ENABLED(CONFIG_AT91_PROGRAMMABLE_CLOCKS))
-		return 1;
-
 	/* PCK0..PCK3 must be disabled, or configured to use clk32k */
 	for (i = 0; i < 4; i++) {
 		u32 css;

commit 2edb90ae421a0f65edcdef65ef9dd08e3228abbf
Author: Boris BREZILLON <b.brezillon@overkiz.com>
Date:   Fri Oct 11 09:37:45 2013 +0200

    ARM: at91: move at91_pmc.h to include/linux/clk/at91_pmc.h
    
    This patch moves at91_pmc.h header from machine specific directory
    (arch/arm/mach-at91/include/mach/at91_pmc.h) to clk include directory
    (include/linux/clk/at91_pmc.h).
    We need this to avoid reference to machine specific headers in clk
    drivers.
    
    Signed-off-by: Boris BREZILLON <b.brezillon@overkiz.com>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Acked-by: Mike Turquette <mturquette@linaro.org>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 9986542e8060..d43b79f56e94 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -19,13 +19,13 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
+#include <linux/clk/at91_pmc.h>
 
 #include <asm/irq.h>
 #include <linux/atomic.h>
 #include <asm/mach/time.h>
 #include <asm/mach/irq.h>
 
-#include <mach/at91_pmc.h>
 #include <mach/cpu.h>
 
 #include "at91_aic.h"

commit 5ad945ea58f6cab7490dc149974ccb6514cc569a
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Sun Sep 22 22:29:57 2013 +0200

    ARM: at91: cpuidle: Convert to platform driver
    
    Using the platform driver model is a good way to separate the cpuidle specific
    code from the low level pm code. It allows to remove the dependency between
    these two components.
    
    The platform_device is located in the pm code and a 'set' function has been
    added to set the standby function from the AT91_SOC_START initialization
    function. Each SoC with a cpuidle driver will set the standby function in the
    platform_data field at init time. Then pm code will register the cpuidle
    platform device.
    
    The cpuidle driver will register the platform_driver and use the device's
    platform_data as a standby callback in the idle path.
    
    The at91_pm_enter function contains a { if then else } based on cpu_is_xx
    similar to what was in cpuidle. This is considered dangerous when adding a new
    SoC. Like the cpuidle driver, a standby ops is defined and assigned when the
    SoC init function specifies what is its standby function and reused in the
    at91_pm_enter's 'case' block.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 15afb5d9271f..9986542e8060 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -39,6 +39,8 @@
 #include "at91_rstc.h"
 #include "at91_shdwc.h"
 
+static void (*at91_pm_standby)(void);
+
 static void __init show_reset_status(void)
 {
 	static char reset[] __initdata = "reset";
@@ -266,14 +268,8 @@ static int at91_pm_enter(suspend_state_t state)
 			 * For ARM 926 based chips, this requirement is weaker
 			 * as at91sam9 can access a RAM in self-refresh mode.
 			 */
-			if (cpu_is_at91rm9200())
-				at91rm9200_standby();
-			else if (cpu_is_at91sam9g45())
-				at91sam9g45_standby();
-			else if (cpu_is_at91sam9263())
-				at91sam9263_standby();
-			else
-				at91sam9_standby();
+			if (at91_pm_standby)
+				at91_pm_standby();
 			break;
 
 		case PM_SUSPEND_ON:
@@ -314,6 +310,18 @@ static const struct platform_suspend_ops at91_pm_ops = {
 	.end	= at91_pm_end,
 };
 
+static struct platform_device at91_cpuidle_device = {
+	.name = "cpuidle-at91",
+};
+
+void at91_pm_set_standby(void (*at91_standby)(void))
+{
+	if (at91_standby) {
+		at91_cpuidle_device.dev.platform_data = at91_standby;
+		at91_pm_standby = at91_standby;
+	}
+}
+
 static int __init at91_pm_init(void)
 {
 #ifdef CONFIG_AT91_SLOW_CLOCK
@@ -325,6 +333,9 @@ static int __init at91_pm_init(void)
 	/* AT91RM9200 SDRAM low-power mode cannot be used with self-refresh. */
 	if (cpu_is_at91rm9200())
 		at91_ramc_write(0, AT91RM9200_SDRAMC_LPR, 0);
+	
+	if (at91_cpuidle_device.dev.platform_data)
+		platform_device_register(&at91_cpuidle_device);
 
 	suspend_set_ops(&at91_pm_ops);
 

commit 546c830c90beb7d3e398007715fd1b631c6c060a
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Sat Jun 1 16:40:11 2013 +0200

    ARM: at91: fix at91_extern_irq usage for non-dt boards
    
    Since 4b68520dc0ec96153bc0d87bca5ffba508edfcf
    ARM: at91: add AIC5 support
    
    we allocate the at91_extern_irq.
    
    This patch makes it static and stores the non-dt extern irq in the soc
    structure. It is then possible to use a at91_get_extern_irq() function
    to get the value for outside of the irq driver. It is useful for passing
    its value to at91_aic_init().
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Ludovic Desroches <ludovic.desroches@atmel.com>
    [nicolas.ferre@atmel.com: rework commit message]
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 530db304ec5e..15afb5d9271f 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -212,7 +212,7 @@ static int at91_pm_enter(suspend_state_t state)
 			(at91_pmc_read(AT91_PMC_PCSR)
 					| (1 << AT91_ID_FIQ)
 					| (1 << AT91_ID_SYS)
-					| (at91_extern_irq))
+					| (at91_get_extern_irq()))
 				& at91_aic_read(AT91_AIC_IMR),
 			state);
 

commit 61b464aef0e306f141dbc0bb3f9c58049a987a7e
Merge: a71efd61db63 f5fa4098c3fc
Author: Olof Johansson <olof@lixom.net>
Date:   Fri Apr 19 11:50:32 2013 -0700

    Merge tag 'at91-soc' of git://github.com/at91linux/linux-at91 into late/cleanup
    
    From Nicolas Ferre:
    Little modification in SoC presentation in kernel log.
    Removing of a long-standing warning in sam9263 PM code.
    
    * tag 'at91-soc' of git://github.com/at91linux/linux-at91:
      ARM: at91: suspend both memory controllers on at91sam9263
      ARM: at91: change "Unknown" qualifier SoC subtype handling
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit f5fa4098c3fcc0e504fbc0682dccd331dbbcf197
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jan 25 22:44:17 2013 +0000

    ARM: at91: suspend both memory controllers on at91sam9263
    
    For the past three years, we have had a #warning in
    mach-at91 about the sdram_selfrefresh_enable or
    at91sam9_standby functions possibly not working on
    at91sam9263. In the meantime a function was added
    to do the right thing on at91sam9g45, which looks like
    it should also work on '9263.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    [nicolas.ferre@atmel.com: remove paragraph in commit message]
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index adb6db888a1f..b8017c1a864d 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -267,6 +267,8 @@ static int at91_pm_enter(suspend_state_t state)
 				at91rm9200_standby();
 			else if (cpu_is_at91sam9g45())
 				at91sam9g45_standby();
+			else if (cpu_is_at91sam9263())
+				at91sam9263_standby();
 			else
 				at91sam9_standby();
 			break;

commit 647f8d94a4e69d39e88a617846755655853c20f5
Author: Ludovic Desroches <ludovic.desroches@atmel.com>
Date:   Fri Mar 8 16:18:21 2013 +0100

    ARM: at91: add gpio suspend/resume support when using pinctrl
    
    gpio suspend/resume and wakeup sources where not managed when using pinctrl so
    it was impossible to wake up the system with a gpio.
    
    Signed-off-by: Ludovic Desroches <ludovic.desroches@atmel.com>
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index adb6db888a1f..73f1f250403a 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -201,7 +201,10 @@ extern u32 at91_slow_clock_sz;
 
 static int at91_pm_enter(suspend_state_t state)
 {
-	at91_gpio_suspend();
+	if (of_have_populated_dt())
+		at91_pinctrl_gpio_suspend();
+	else
+		at91_gpio_suspend();
 	at91_irq_suspend();
 
 	pr_debug("AT91: PM - wake mask %08x, pm state %d\n",
@@ -286,7 +289,10 @@ static int at91_pm_enter(suspend_state_t state)
 error:
 	target_state = PM_SUSPEND_ON;
 	at91_irq_resume();
-	at91_gpio_resume();
+	if (of_have_populated_dt())
+		at91_pinctrl_gpio_resume();
+	else
+		at91_gpio_resume();
 	return 0;
 }
 

commit f0995d089e46b3ee03acc13d2a3380d90c573381
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Tue Oct 30 08:11:24 2012 +0800

    arm: at91: move reset controller header to arm/arm/mach-at91
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 34557400bf4d..adb6db888a1f 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -36,7 +36,7 @@
  * Show the reason for the previous system reset.
  */
 
-#include <mach/at91_rstc.h>
+#include "at91_rstc.h"
 #include "at91_shdwc.h"
 
 static void __init show_reset_status(void)

commit 176bdd2c54ffddb4ea0ba1d1db170832f2085e61
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Tue Oct 30 08:07:11 2012 +0800

    arm: at91: move at91_shdwc.h to arch/arm/mach-at91
    
    This is only used by old boards style or via core code.
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index e8cb6b811df3..34557400bf4d 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -37,7 +37,7 @@
  */
 
 #include <mach/at91_rstc.h>
-#include <mach/at91_shdwc.h>
+#include "at91_shdwc.h"
 
 static void __init show_reset_status(void)
 {

commit a510b9bacd365dbf7d20a825f34116b9833dd146
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Tue Oct 30 06:41:28 2012 +0800

    arm: at91 move at91_aic.h to arch/arm/mach-at91
    
    as this is only used board old style board old mach code
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 5315f05896e9..e8cb6b811df3 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -25,10 +25,10 @@
 #include <asm/mach/time.h>
 #include <asm/mach/irq.h>
 
-#include <mach/at91_aic.h>
 #include <mach/at91_pmc.h>
 #include <mach/cpu.h>
 
+#include "at91_aic.h"
 #include "generic.h"
 #include "pm.h"
 

commit 9e0e4e11623e57c0f6635f5dc6972244ce511f77
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Apr 30 13:00:32 2012 +0000

    ARM: at91: unused variable in at91_pm_verify_clocks
    
    The code using the variable 'i' in this function is conditional which
    results in a harmless compiler warning. Using the IS_ENABLED macro
    instead of #ifdef makes the code look nicer and gets rid of the
    warning.
    
    Without this patch, building at91sam9263_defconfig results in:
    
    /home/arnd/linux-arm/arch/arm/mach-at91/pm.c: In function 'at91_pm_verify_clocks':
    /home/arnd/linux-arm/arch/arm/mach-at91/pm.c:137:6: warning: unused variable 'i' [-Wunused-variable]
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 2c2d86505a54..5315f05896e9 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -153,7 +153,9 @@ static int at91_pm_verify_clocks(void)
 		}
 	}
 
-#ifdef CONFIG_AT91_PROGRAMMABLE_CLOCKS
+	if (!IS_ENABLED(CONFIG_AT91_PROGRAMMABLE_CLOCKS))
+		return 1;
+
 	/* PCK0..PCK3 must be disabled, or configured to use clk32k */
 	for (i = 0; i < 4; i++) {
 		u32 css;
@@ -167,7 +169,6 @@ static int at91_pm_verify_clocks(void)
 			return 0;
 		}
 	}
-#endif
 
 	return 1;
 }

commit 8fe82a5550a8e97b3f59c74f994b88ed6b3544a3
Author: Ludovic Desroches <ludovic.desroches@atmel.com>
Date:   Thu Jun 21 14:47:27 2012 +0200

    ARM: at91: sparse irq support
    
    Enable sparse irq support for multisoc image. It involves to add the
    NR_IRQS_LEGACY offset to static SoC irq number definitions since NR_IRQS_LEGACY
    irq descs are allocated before AIC requests irq descs allocation.
    Move NR_AIC_IRQS macro to a more appropiate place with the purpose to
    remove mach/irqs.h later.
    
    Signed-off-by: Ludovic Desroches <ludovic.desroches@atmel.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 1bfaad628731..2c2d86505a54 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -25,6 +25,7 @@
 #include <asm/mach/time.h>
 #include <asm/mach/irq.h>
 
+#include <mach/at91_aic.h>
 #include <mach/at91_pmc.h>
 #include <mach/cpu.h>
 

commit efd09165aa554f84a42565d5ae6a1af58b06a97a
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Mon Feb 13 14:58:30 2012 +0800

    ARM: at91: pm select memory controler at runtime
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    [nicolas.ferre@atmel.com: add cpuidle modification]
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index f630250c6b87..1bfaad628731 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -261,7 +261,12 @@ static int at91_pm_enter(suspend_state_t state)
 			 * For ARM 926 based chips, this requirement is weaker
 			 * as at91sam9 can access a RAM in self-refresh mode.
 			 */
-			at91_standby();
+			if (cpu_is_at91rm9200())
+				at91rm9200_standby();
+			else if (cpu_is_at91sam9g45())
+				at91sam9g45_standby();
+			else
+				at91sam9_standby();
 			break;
 
 		case PM_SUSPEND_ON:
@@ -307,10 +312,9 @@ static int __init at91_pm_init(void)
 
 	pr_info("AT91: Power Management%s\n", (slow_clock ? " (with slow clock mode)" : ""));
 
-#ifdef CONFIG_ARCH_AT91RM9200
 	/* AT91RM9200 SDRAM low-power mode cannot be used with self-refresh. */
-	at91_ramc_write(0, AT91RM9200_SDRAMC_LPR, 0);
-#endif
+	if (cpu_is_at91rm9200())
+		at91_ramc_write(0, AT91RM9200_SDRAMC_LPR, 0);
 
 	suspend_set_ops(&at91_pm_ops);
 

commit a7776ec625c8ca90d050953946a5b72eaf41c21c
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Fri Mar 2 20:54:37 2012 +0800

    ARM: at91: add ram controller DT support
    
    We can now drop the call to ioremap_registers() as we have the binding for the
    SDRAM/DDR Controller.
    
    Drop ioremap_registers() for sam9x5 too.
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 6c9d5e69ac28..f630250c6b87 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -197,19 +197,6 @@ extern void at91_slow_clock(void __iomem *pmc, void __iomem *ramc0,
 extern u32 at91_slow_clock_sz;
 #endif
 
-void __iomem *at91_ramc_base[2];
-
-void __init at91_ioremap_ramc(int id, u32 addr, u32 size)
-{
-	if (id < 0 || id > 1) {
-		pr_emerg("Wrong RAM controller id (%d), cannot continue\n", id);
-		BUG();
-	}
-	at91_ramc_base[id] = ioremap(addr, size);
-	if (!at91_ramc_base[id])
-		panic("Impossible to ioremap ramc.%d 0x%x\n", id, addr);
-}
-
 static int at91_pm_enter(suspend_state_t state)
 {
 	at91_gpio_suspend();

commit b55149529d265718a989b67468c4f03de0d3af7a
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Fri Nov 25 09:59:46 2011 +0800

    ARM: at91/PMC: make register base soc independent
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Reviewed-by: Ryan Mallon <rmallon@gmail.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 2793591c73c0..6c9d5e69ac28 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -136,7 +136,7 @@ static int at91_pm_verify_clocks(void)
 	unsigned long scsr;
 	int i;
 
-	scsr = at91_sys_read(AT91_PMC_SCSR);
+	scsr = at91_pmc_read(AT91_PMC_SCSR);
 
 	/* USB must not be using PLLB */
 	if (cpu_is_at91rm9200()) {
@@ -160,7 +160,7 @@ static int at91_pm_verify_clocks(void)
 		if ((scsr & (AT91_PMC_PCK0 << i)) == 0)
 			continue;
 
-		css = at91_sys_read(AT91_PMC_PCKR(i)) & AT91_PMC_CSS;
+		css = at91_pmc_read(AT91_PMC_PCKR(i)) & AT91_PMC_CSS;
 		if (css != AT91_PMC_CSS_SLOW) {
 			pr_err("AT91: PM - Suspend-to-RAM with PCK%d src %d\n", i, css);
 			return 0;
@@ -197,7 +197,6 @@ extern void at91_slow_clock(void __iomem *pmc, void __iomem *ramc0,
 extern u32 at91_slow_clock_sz;
 #endif
 
-static void __iomem *at91_pmc_base = (void __iomem*)(AT91_VA_BASE_SYS + AT91_PMC);
 void __iomem *at91_ramc_base[2];
 
 void __init at91_ioremap_ramc(int id, u32 addr, u32 size)
@@ -218,7 +217,7 @@ static int at91_pm_enter(suspend_state_t state)
 
 	pr_debug("AT91: PM - wake mask %08x, pm state %d\n",
 			/* remember all the always-wake irqs */
-			(at91_sys_read(AT91_PMC_PCSR)
+			(at91_pmc_read(AT91_PMC_PCSR)
 					| (1 << AT91_ID_FIQ)
 					| (1 << AT91_ID_SYS)
 					| (at91_extern_irq))

commit fb7e197bec45f15299315ed14292f09086d90a0b
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Wed Feb 22 17:50:55 2012 +0100

    ARM: at91/pm_slowclock: add runtime detection of memory contoller
    
    This will allow to have all SoC in one kernel image.
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 46dbb7e1339c..2793591c73c0 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -188,10 +188,12 @@ int at91_suspend_entering_slow_clock(void)
 EXPORT_SYMBOL(at91_suspend_entering_slow_clock);
 
 
-static void (*slow_clock)(void __iomem *pmc, void __iomem *ramc0, void __iomem *ramc1);
+static void (*slow_clock)(void __iomem *pmc, void __iomem *ramc0,
+			  void __iomem *ramc1, int memctrl);
 
 #ifdef CONFIG_AT91_SLOW_CLOCK
-extern void at91_slow_clock(void __iomem *pmc, void __iomem *ramc0, void __iomem *ramc1);
+extern void at91_slow_clock(void __iomem *pmc, void __iomem *ramc0,
+			    void __iomem *ramc1, int memctrl);
 extern u32 at91_slow_clock_sz;
 #endif
 
@@ -241,11 +243,18 @@ static int at91_pm_enter(suspend_state_t state)
 			 * turning off the main oscillator; reverse on wakeup.
 			 */
 			if (slow_clock) {
+				int memctrl = AT91_MEMCTRL_SDRAMC;
+
+				if (cpu_is_at91rm9200())
+					memctrl = AT91_MEMCTRL_MC;
+				else if (cpu_is_at91sam9g45())
+					memctrl = AT91_MEMCTRL_DDRSDR;
 #ifdef CONFIG_AT91_SLOW_CLOCK
 				/* copy slow_clock handler to SRAM, and call it */
 				memcpy(slow_clock, at91_slow_clock, at91_slow_clock_sz);
 #endif
-				slow_clock(at91_pmc_base, at91_ramc_base[0], at91_ramc_base[1]);
+				slow_clock(at91_pmc_base, at91_ramc_base[0],
+					   at91_ramc_base[1], memctrl);
 				break;
 			} else {
 				pr_info("AT91: PM - no slow clock mode enabled ...\n");

commit f363c407b42c467d06675c852e55f26adb959915
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Mon Feb 13 12:58:53 2012 +0800

    ARM: at91: make sdram/ddr register base soc independent
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 8046a50a0c2a..46dbb7e1339c 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -196,19 +196,18 @@ extern u32 at91_slow_clock_sz;
 #endif
 
 static void __iomem *at91_pmc_base = (void __iomem*)(AT91_VA_BASE_SYS + AT91_PMC);
-#ifdef CONFIG_ARCH_AT91RM9200
-static void __iomem *at91_ramc0_base = (void __iomem*)AT91_VA_BASE_SYS;
-#elif defined(CONFIG_ARCH_AT91SAM9G45)
-static void __iomem *at91_ramc0_base = (void __iomem*)(AT91_VA_BASE_SYS + AT91_DDRSDRC0);
-#else
-static void __iomem *at91_ramc0_base = (void __iomem*)(AT91_VA_BASE_SYS + AT91_SDRAMC0);
-#endif
+void __iomem *at91_ramc_base[2];
 
-#if defined(CONFIG_ARCH_AT91SAM9G45)
-static void __iomem *at91_ramc1_base = (void __iomem*)(AT91_VA_BASE_SYS + AT91_DDRSDRC1);
-#else
-static void __iomem *at91_ramc1_base = NULL;
-#endif
+void __init at91_ioremap_ramc(int id, u32 addr, u32 size)
+{
+	if (id < 0 || id > 1) {
+		pr_emerg("Wrong RAM controller id (%d), cannot continue\n", id);
+		BUG();
+	}
+	at91_ramc_base[id] = ioremap(addr, size);
+	if (!at91_ramc_base[id])
+		panic("Impossible to ioremap ramc.%d 0x%x\n", id, addr);
+}
 
 static int at91_pm_enter(suspend_state_t state)
 {
@@ -246,7 +245,7 @@ static int at91_pm_enter(suspend_state_t state)
 				/* copy slow_clock handler to SRAM, and call it */
 				memcpy(slow_clock, at91_slow_clock, at91_slow_clock_sz);
 #endif
-				slow_clock(at91_pmc_base, at91_ramc0_base, at91_ramc1_base);
+				slow_clock(at91_pmc_base, at91_ramc_base[0], at91_ramc_base[1]);
 				break;
 			} else {
 				pr_info("AT91: PM - no slow clock mode enabled ...\n");
@@ -315,7 +314,7 @@ static int __init at91_pm_init(void)
 
 #ifdef CONFIG_ARCH_AT91RM9200
 	/* AT91RM9200 SDRAM low-power mode cannot be used with self-refresh. */
-	at91_sys_write(AT91RM9200_SDRAMC_LPR, 0);
+	at91_ramc_write(0, AT91RM9200_SDRAMC_LPR, 0);
 #endif
 
 	suspend_set_ops(&at91_pm_ops);

commit 1a269ade22bb65d0afc0d20e0a19602453fae04a
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Wed Nov 16 02:58:31 2011 +0800

    ARM: at91: move at91rm9200 sdramc defines to at91rm9200_sdramc.h
    
    This cleanup is done to allow to have multiple SoC in the same image.
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index aac00cecbf4f..8046a50a0c2a 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -315,7 +315,7 @@ static int __init at91_pm_init(void)
 
 #ifdef CONFIG_ARCH_AT91RM9200
 	/* AT91RM9200 SDRAM low-power mode cannot be used with self-refresh. */
-	at91_sys_write(AT91_SDRAMC_LPR, 0);
+	at91_sys_write(AT91RM9200_SDRAMC_LPR, 0);
 #endif
 
 	suspend_set_ops(&at91_pm_ops);

commit 8ff12ad3df62ee343d5f5ec29572b9d2c5c2cedd
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Wed Feb 22 17:50:54 2012 +0100

    ARM: at91/pm_slowclock: function slow_clock() accepts parameters
    
    Change slow_clock()/at91_slow_clock() prototype to accept the PMC
    base address and one or two RAM controller addresses by parameters.
    The r0, r1 and r2 registers are used differently and preserved during
    function call.
    Those values are defined in pm.c and slow_clock() function is called
    from there with its new parameters.
    
    This will allow to have a soc independent pm_slowclock.
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Ached-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index d554e6771b4e..aac00cecbf4f 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -188,13 +188,27 @@ int at91_suspend_entering_slow_clock(void)
 EXPORT_SYMBOL(at91_suspend_entering_slow_clock);
 
 
-static void (*slow_clock)(void);
+static void (*slow_clock)(void __iomem *pmc, void __iomem *ramc0, void __iomem *ramc1);
 
 #ifdef CONFIG_AT91_SLOW_CLOCK
-extern void at91_slow_clock(void);
+extern void at91_slow_clock(void __iomem *pmc, void __iomem *ramc0, void __iomem *ramc1);
 extern u32 at91_slow_clock_sz;
 #endif
 
+static void __iomem *at91_pmc_base = (void __iomem*)(AT91_VA_BASE_SYS + AT91_PMC);
+#ifdef CONFIG_ARCH_AT91RM9200
+static void __iomem *at91_ramc0_base = (void __iomem*)AT91_VA_BASE_SYS;
+#elif defined(CONFIG_ARCH_AT91SAM9G45)
+static void __iomem *at91_ramc0_base = (void __iomem*)(AT91_VA_BASE_SYS + AT91_DDRSDRC0);
+#else
+static void __iomem *at91_ramc0_base = (void __iomem*)(AT91_VA_BASE_SYS + AT91_SDRAMC0);
+#endif
+
+#if defined(CONFIG_ARCH_AT91SAM9G45)
+static void __iomem *at91_ramc1_base = (void __iomem*)(AT91_VA_BASE_SYS + AT91_DDRSDRC1);
+#else
+static void __iomem *at91_ramc1_base = NULL;
+#endif
 
 static int at91_pm_enter(suspend_state_t state)
 {
@@ -232,7 +246,7 @@ static int at91_pm_enter(suspend_state_t state)
 				/* copy slow_clock handler to SRAM, and call it */
 				memcpy(slow_clock, at91_slow_clock, at91_slow_clock_sz);
 #endif
-				slow_clock();
+				slow_clock(at91_pmc_base, at91_ramc0_base, at91_ramc1_base);
 				break;
 			} else {
 				pr_info("AT91: PM - no slow clock mode enabled ...\n");

commit 00482a4078f4ff0dd0638e7f2fd83e34cc402ff7
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Wed Jan 25 00:56:08 2012 +0100

    ARM: at91: implement the standby function for pm/cpuidle
    
    This patch groups the self-refresh on/cpu_do_idle/self-refresh off into
    a single 'standby' function.
    
    The standby routine for rm9200 has been turned into an asm routine to have
    a better control of the self refresh and to prevent a memory access when
    running this code.
    
    Draining the write buffer is done automatically when switching for the self
    refresh on sam9, so the instruction is added to the rm9200 only.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index d7e8d4cbc5ef..d554e6771b4e 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -198,7 +198,6 @@ extern u32 at91_slow_clock_sz;
 
 static int at91_pm_enter(suspend_state_t state)
 {
-	u32 saved_lpr;
 	at91_gpio_suspend();
 	at91_irq_suspend();
 
@@ -254,16 +253,7 @@ static int at91_pm_enter(suspend_state_t state)
 			 * For ARM 926 based chips, this requirement is weaker
 			 * as at91sam9 can access a RAM in self-refresh mode.
 			 */
-			asm volatile (	"mov r0, #0\n\t"
-					"b 1f\n\t"
-					".align 5\n\t"
-					"1: mcr p15, 0, r0, c7, c10, 4\n\t"
-					: /* no output */
-					: /* no input */
-					: "r0");
-			saved_lpr = sdram_selfrefresh_enable();
-			cpu_do_idle();
-			sdram_selfrefresh_disable(saved_lpr);
+			at91_standby();
 			break;
 
 		case PM_SUSPEND_ON:

commit b59160f6c017bfe33d3483ed9a6120701644af8a
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Wed Jan 25 00:56:07 2012 +0100

    ARM: at91: remove wait_for_interrupt definition
    
    All the "wait_for_interrupt" definition are aliases to cpu_do_idle.
    Only the rm9200 has an asm routine to switch to wfi. But the cpu_do_idle
    for this platform has exactly the same asm routine.
    
    arch/arm/mm/proc-arm920.S
    ..
    ENTRY(cpu_arm920_do_idle)
            mcr     p15, 0, r0, c7, c0, 4           @ Wait for interrupt
    ..
    
    Then it is safe to invoke cpu_do_idle for this platform. As all the
    wait_for_interrupts are definition for cpu_do_idle, let's remove it
    and replace its invokation by cpu_do_idle.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 87be5aa18753..d7e8d4cbc5ef 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -262,7 +262,7 @@ static int at91_pm_enter(suspend_state_t state)
 					: /* no input */
 					: "r0");
 			saved_lpr = sdram_selfrefresh_enable();
-			wait_for_interrupt_enable();
+			cpu_do_idle();
 			sdram_selfrefresh_disable(saved_lpr);
 			break;
 

commit 9918ceafd4a9e013572e03983f528017c29bb1cb
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Thu Jan 26 14:07:09 2012 +0100

    ARM: at91: code removal of CAP9 SoC
    
    Following removal announce and addition to feature-removal-schedule.txt,
    here is the actual source code deletion for Atmel CAP9 family.
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 1606379ac284..87be5aa18753 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -150,11 +150,6 @@ static int at91_pm_verify_clocks(void)
 			pr_err("AT91: PM - Suspend-to-RAM with USB still active\n");
 			return 0;
 		}
-	} else if (cpu_is_at91cap9()) {
-		if ((scsr & AT91CAP9_PMC_UHP) != 0) {
-			pr_err("AT91: PM - Suspend-to-RAM with USB still active\n");
-			return 0;
-		}
 	}
 
 #ifdef CONFIG_AT91_PROGRAMMABLE_CLOCKS

commit e9f68b5cc6160a473fc668054fd13f435fd4508b
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Fri Nov 18 01:25:52 2011 +0800

    ARM: at91: make rstc soc independent
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 62ad95556c36..1606379ac284 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -34,7 +34,6 @@
 /*
  * Show the reason for the previous system reset.
  */
-#if defined(AT91_RSTC)
 
 #include <mach/at91_rstc.h>
 #include <mach/at91_shdwc.h>
@@ -58,10 +57,10 @@ static void __init show_reset_status(void)
 	char *reason, *r2 = reset;
 	u32 reset_type, wake_type;
 
-	if (!at91_shdwc_base)
+	if (!at91_shdwc_base || !at91_rstc_base)
 		return;
 
-	reset_type = at91_sys_read(AT91_RSTC_SR) & AT91_RSTC_RSTTYP;
+	reset_type = at91_rstc_read(AT91_RSTC_SR) & AT91_RSTC_RSTTYP;
 	wake_type = at91_shdwc_read(AT91_SHDW_SR);
 
 	switch (reset_type) {
@@ -102,10 +101,6 @@ static void __init show_reset_status(void)
 	}
 	pr_info("AT91: Starting after %s %s\n", reason, r2);
 }
-#else
-static void __init show_reset_status(void) {}
-#endif
-
 
 static int at91_pm_valid_state(suspend_state_t state)
 {

commit be6d4321720cd56623c1d5be311bde65c2c91229
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Thu Nov 3 01:12:50 2011 +0800

    ARM: at91: make aic soc independent
    
    on all at91 have the Advanced Interrupt Controller starts at address
    0xfffff000
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 3a5b7b4279e7..62ad95556c36 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -218,7 +218,7 @@ static int at91_pm_enter(suspend_state_t state)
 					| (1 << AT91_ID_FIQ)
 					| (1 << AT91_ID_SYS)
 					| (at91_extern_irq))
-				& at91_sys_read(AT91_AIC_IMR),
+				& at91_aic_read(AT91_AIC_IMR),
 			state);
 
 	switch (state) {
@@ -286,7 +286,7 @@ static int at91_pm_enter(suspend_state_t state)
 	}
 
 	pr_debug("AT91: PM - wakeup %08x\n",
-			at91_sys_read(AT91_AIC_IPR) & at91_sys_read(AT91_AIC_IMR));
+			at91_aic_read(AT91_AIC_IPR) & at91_aic_read(AT91_AIC_IMR));
 
 error:
 	target_state = PM_SUSPEND_ON;

commit f22deee523e0ff49c3be01dd6f979d374230725a
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Tue Nov 1 01:23:20 2011 +0800

    ARM: at91: make shutdown controler soc independent
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 7046158109d7..3a5b7b4279e7 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -34,7 +34,7 @@
 /*
  * Show the reason for the previous system reset.
  */
-#if defined(AT91_SHDWC)
+#if defined(AT91_RSTC)
 
 #include <mach/at91_rstc.h>
 #include <mach/at91_shdwc.h>
@@ -58,8 +58,11 @@ static void __init show_reset_status(void)
 	char *reason, *r2 = reset;
 	u32 reset_type, wake_type;
 
+	if (!at91_shdwc_base)
+		return;
+
 	reset_type = at91_sys_read(AT91_RSTC_SR) & AT91_RSTC_RSTTYP;
-	wake_type = at91_sys_read(AT91_SHDW_SR);
+	wake_type = at91_shdwc_read(AT91_SHDW_SR);
 
 	switch (reset_type) {
 	case AT91_RSTC_RSTTYP_GENERAL:

commit 2f8163baada3dbd0ce891c35bc59ae46e773487a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jul 26 10:53:52 2011 +0100

    ARM: gpio: convert includes of mach/gpio.h and asm/gpio.h to linux/gpio.h
    
    Convert arch/arm includes of mach/gpio.h and asm/gpio.h to linux/gpio.h
    before we start consolidating the individual platform implementations
    of the gpio header files.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 4159eca78945..7046158109d7 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -10,6 +10,7 @@
  * (at your option) any later version.
  */
 
+#include <linux/gpio.h>
 #include <linux/suspend.h>
 #include <linux/sched.h>
 #include <linux/proc_fs.h>
@@ -25,7 +26,6 @@
 #include <asm/mach/irq.h>
 
 #include <mach/at91_pmc.h>
-#include <mach/gpio.h>
 #include <mach/cpu.h>
 
 #include "generic.h"

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index ea53f4d9b283..4159eca78945 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -20,7 +20,7 @@
 #include <linux/io.h>
 
 #include <asm/irq.h>
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 #include <asm/mach/time.h>
 #include <asm/mach/irq.h>
 

commit 2f55ac072f5344519348c0c94b3d2f4cca46847b
Author: Lionel Debroux <lionel_debroux@yahoo.fr>
Date:   Tue Nov 16 14:14:02 2010 +0100

    suspend: constify platform_suspend_ops
    
    While at it, fix two checkpatch errors.
    Several non-const struct instances constified by this patch were added after
    the introduction of platform_suspend_ops in checkpatch.pl's list of "should
    be const" structs (79404849e90a41ea2109bd0e2f7c7164b0c4ce73).
    
    Patch against mainline.
    Inspired by hunks of the grsecurity patch, updated for newer kernels.
    
    Signed-off-by: Lionel Debroux <lionel_debroux@yahoo.fr>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index dafbacc25eb1..ea53f4d9b283 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -301,7 +301,7 @@ static void at91_pm_end(void)
 }
 
 
-static struct platform_suspend_ops at91_pm_ops ={
+static const struct platform_suspend_ops at91_pm_ops = {
 	.valid	= at91_pm_valid_state,
 	.begin	= at91_pm_begin,
 	.enter	= at91_pm_enter,

commit a2a571b74a3881963d8d09deb272d13afe5b49e3
Author: Nicolas Ferre <nicolas.ferre@atmel.com>
Date:   Fri Oct 22 18:55:39 2010 +0200

    AT91: pm: make sure that r0 is 0 when dealing with cache operations
    
    When using CP15 cache operations (c7), we make sure that Rd (r0)
    is actually 0 as ARM 926 TRM is saying.
    
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 87a31baf1cb3..dafbacc25eb1 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -261,8 +261,13 @@ static int at91_pm_enter(suspend_state_t state)
 			 * For ARM 926 based chips, this requirement is weaker
 			 * as at91sam9 can access a RAM in self-refresh mode.
 			 */
-			asm("b 1f; .align 5; 1:");
-			asm("mcr p15, 0, r0, c7, c10, 4");	/* drain write buffer */
+			asm volatile (	"mov r0, #0\n\t"
+					"b 1f\n\t"
+					".align 5\n\t"
+					"1: mcr p15, 0, r0, c7, c10, 4\n\t"
+					: /* no output */
+					: /* no input */
+					: "r0");
 			saved_lpr = sdram_selfrefresh_enable();
 			wait_for_interrupt_enable();
 			sdram_selfrefresh_disable(saved_lpr);

commit 8aeeda822fbfe7da2d4ea391a9757e9532796598
Author: Nicolas Ferre <nicolas.ferre@atmel.com>
Date:   Fri Oct 22 17:53:39 2010 +0200

    AT91: pm: use plain cpu_do_idle() for "wait for interrupt"
    
    For power management at91_pm_enter() routine, use the cpu_do_idle() for a
    rock solid "wait for interrupt" implementation.
    For AT91SAM9 ARM 926 based chips, we can exceed the cache line length as
    we can access RAM even while in self-refresh mode.
    We keep plain access to CP15 for at91rm9200 as this feature is not
    available: instructions have to be in a single cache line.
    
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 615668986480..87a31baf1cb3 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -258,16 +258,18 @@ static int at91_pm_enter(suspend_state_t state)
 			 * NOTE: the Wait-for-Interrupt instruction needs to be
 			 * in icache so no SDRAM accesses are needed until the
 			 * wakeup IRQ occurs and self-refresh is terminated.
+			 * For ARM 926 based chips, this requirement is weaker
+			 * as at91sam9 can access a RAM in self-refresh mode.
 			 */
 			asm("b 1f; .align 5; 1:");
 			asm("mcr p15, 0, r0, c7, c10, 4");	/* drain write buffer */
 			saved_lpr = sdram_selfrefresh_enable();
-			asm("mcr p15, 0, r0, c7, c0, 4");	/* wait for interrupt */
+			wait_for_interrupt_enable();
 			sdram_selfrefresh_disable(saved_lpr);
 			break;
 
 		case PM_SUSPEND_ON:
-			asm("mcr p15, 0, r0, c7, c0, 4");	/* wait for interrupt */
+			cpu_do_idle();
 			break;
 
 		default:

commit 1ea60cf7062271f0d53d09268726aa1544bf4836
Author: Albin Tonnerre <albin.tonnerre@free-electrons.com>
Date:   Sun Nov 1 18:40:50 2009 +0100

    ARM: 5778/1: AT91: Add cpuidle support
    
    This patch adds the support for cpuidle on AT91 SoCs, taken from the
    cpuidle support in mach-kirkwood.
    cpuidle needs sdram_selfrefresh_enable and _disable, so move their
    definition to a separate header file instead of duplicating the code
    already used in pm.c.
    
    Tested-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Albin Tonnerre <albin.tonnerre@free-electrons.com>
    Acked-by: Andrew Victor <linux@maxim.org.za>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 4028724d490d..615668986480 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -29,62 +29,7 @@
 #include <mach/cpu.h>
 
 #include "generic.h"
-
-#ifdef CONFIG_ARCH_AT91RM9200
-#include <mach/at91rm9200_mc.h>
-
-/*
- * The AT91RM9200 goes into self-refresh mode with this command, and will
- * terminate self-refresh automatically on the next SDRAM access.
- */
-#define sdram_selfrefresh_enable()	at91_sys_write(AT91_SDRAMC_SRR, 1)
-#define sdram_selfrefresh_disable()	do {} while (0)
-
-#elif defined(CONFIG_ARCH_AT91CAP9)
-#include <mach/at91cap9_ddrsdr.h>
-
-static u32 saved_lpr;
-
-static inline void sdram_selfrefresh_enable(void)
-{
-	u32 lpr;
-
-	saved_lpr = at91_sys_read(AT91_DDRSDRC_LPR);
-
-	lpr = saved_lpr & ~AT91_DDRSDRC_LPCB;
-	at91_sys_write(AT91_DDRSDRC_LPR, lpr | AT91_DDRSDRC_LPCB_SELF_REFRESH);
-}
-
-#define sdram_selfrefresh_disable()	at91_sys_write(AT91_DDRSDRC_LPR, saved_lpr)
-
-#else
-#include <mach/at91sam9_sdramc.h>
-
-#ifdef CONFIG_ARCH_AT91SAM9263
-/*
- * FIXME either or both the SDRAM controllers (EB0, EB1) might be in use;
- * handle those cases both here and in the Suspend-To-RAM support.
- */
-#define	AT91_SDRAMC	AT91_SDRAMC0
-#warning Assuming EB1 SDRAM controller is *NOT* used
-#endif
-
-static u32 saved_lpr;
-
-static inline void sdram_selfrefresh_enable(void)
-{
-	u32 lpr;
-
-	saved_lpr = at91_sys_read(AT91_SDRAMC_LPR);
-
-	lpr = saved_lpr & ~AT91_SDRAMC_LPCB;
-	at91_sys_write(AT91_SDRAMC_LPR, lpr | AT91_SDRAMC_LPCB_SELF_REFRESH);
-}
-
-#define sdram_selfrefresh_disable()	at91_sys_write(AT91_SDRAMC_LPR, saved_lpr)
-
-#endif
-
+#include "pm.h"
 
 /*
  * Show the reason for the previous system reset.
@@ -260,6 +205,7 @@ extern u32 at91_slow_clock_sz;
 
 static int at91_pm_enter(suspend_state_t state)
 {
+	u32 saved_lpr;
 	at91_gpio_suspend();
 	at91_irq_suspend();
 
@@ -315,9 +261,9 @@ static int at91_pm_enter(suspend_state_t state)
 			 */
 			asm("b 1f; .align 5; 1:");
 			asm("mcr p15, 0, r0, c7, c10, 4");	/* drain write buffer */
-			sdram_selfrefresh_enable();
+			saved_lpr = sdram_selfrefresh_enable();
 			asm("mcr p15, 0, r0, c7, c0, 4");	/* wait for interrupt */
-			sdram_selfrefresh_disable();
+			sdram_selfrefresh_disable(saved_lpr);
 			break;
 
 		case PM_SUSPEND_ON:

commit b319ff80852e823c3a18778c839151784990f80b
Author: Nicolas Ferre <nicolas.ferre@atmel.com>
Date:   Fri Jun 26 15:37:01 2009 +0100

    [ARM] 5570/1: at91: Support for at91sam9g10: core chip & board support
    
    From: Hong Xu <hong.xu@atmel.com>
    
    Here are the modification to at91sam9261 files dedicated to the support of
    at91sam9g10. This direction has been adopted to minimize code duplication.
    
    All at91sam9261 drivers are enabled in _devices and board- files. Modificaton
    to peripherals that support at91sam9g10 will be added in future patches.
    
    Signed-off-by: Hong Xu <hong.xu@atmel.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Acked-by: Andrew Victor <linux@maxim.org.za>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index e26c4fe61fae..4028724d490d 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -201,7 +201,8 @@ static int at91_pm_verify_clocks(void)
 			pr_err("AT91: PM - Suspend-to-RAM with USB still active\n");
 			return 0;
 		}
-	} else if (cpu_is_at91sam9260() || cpu_is_at91sam9261() || cpu_is_at91sam9263() || cpu_is_at91sam9g20()) {
+	} else if (cpu_is_at91sam9260() || cpu_is_at91sam9261() || cpu_is_at91sam9263()
+			|| cpu_is_at91sam9g20() || cpu_is_at91sam9g10()) {
 		if ((scsr & (AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP)) != 0) {
 			pr_err("AT91: PM - Suspend-to-RAM with USB still active\n");
 			return 0;

commit 7f96b1caac43b34b325ee4acf61ce57d7214409c
Author: Ryan Mallon <ryan@bluewatersys.com>
Date:   Wed Apr 1 20:33:30 2009 +0100

    [ARM] 5441/1: Use pr_err on error paths in at91 pm
    
    Change pr_debug to pr_err on error paths in the AT91 power management
    code. All of the errors will result in the cpu not going into the
    suspend state. This patch makes it possible to identify problems with
    suspend when power management debugging is not enabled.
    
    Signed-off-by: Ryan Mallon <ryan@bluewatersys.com>
    Acked-by: Andrew Victor <linux@maxim.org.za>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 7ac812dc055a..e26c4fe61fae 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -198,17 +198,17 @@ static int at91_pm_verify_clocks(void)
 	/* USB must not be using PLLB */
 	if (cpu_is_at91rm9200()) {
 		if ((scsr & (AT91RM9200_PMC_UHP | AT91RM9200_PMC_UDP)) != 0) {
-			pr_debug("AT91: PM - Suspend-to-RAM with USB still active\n");
+			pr_err("AT91: PM - Suspend-to-RAM with USB still active\n");
 			return 0;
 		}
 	} else if (cpu_is_at91sam9260() || cpu_is_at91sam9261() || cpu_is_at91sam9263() || cpu_is_at91sam9g20()) {
 		if ((scsr & (AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP)) != 0) {
-			pr_debug("AT91: PM - Suspend-to-RAM with USB still active\n");
+			pr_err("AT91: PM - Suspend-to-RAM with USB still active\n");
 			return 0;
 		}
 	} else if (cpu_is_at91cap9()) {
 		if ((scsr & AT91CAP9_PMC_UHP) != 0) {
-			pr_debug("AT91: PM - Suspend-to-RAM with USB still active\n");
+			pr_err("AT91: PM - Suspend-to-RAM with USB still active\n");
 			return 0;
 		}
 	}
@@ -223,7 +223,7 @@ static int at91_pm_verify_clocks(void)
 
 		css = at91_sys_read(AT91_PMC_PCKR(i)) & AT91_PMC_CSS;
 		if (css != AT91_PMC_CSS_SLOW) {
-			pr_debug("AT91: PM - Suspend-to-RAM with PCK%d src %d\n", i, css);
+			pr_err("AT91: PM - Suspend-to-RAM with PCK%d src %d\n", i, css);
 			return 0;
 		}
 	}

commit d82ad6d6833ee8248e6c34e1b9fc3c4e61e3f035
Author: Andrei Birjukov <andrei.birjukov@artecdesign.ee>
Date:   Sun Feb 22 22:37:21 2009 +0000

    [ARM] at91: fix for Atmel AT91 powersaving
    
    We've discovered that our AT91SAM9260 board consumed too much power when
    returning from a slowclock low-power mode.  RAM self-refresh is enabled in
    a bootloader in our case, this is how we saw a difference.  Estimated ca.
    30mA more on 4V battery than the same state before powersaving.
    
    After a small research we found that there seems to be a bogus
    sdram_selfrefresh_disable() call at the end of at91_pm_enter() call, which
    overwrites the LPR register with uninitialized value.  Please find the
    suggested patch attached.
    
    This patch fixes correct restoring of LPR register of the Atmel AT91 SDRAM
    controller when returning from a power saving mode.
    
    Signed-off-by: Andrei Birjukov <andrei.birjukov@artecdesign.ee>
    Acked-by: Andrew Victor <linux@maxim.org.za>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 9bb4f043aa22..7ac812dc055a 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -332,7 +332,6 @@ static int at91_pm_enter(suspend_state_t state)
 			at91_sys_read(AT91_AIC_IPR) & at91_sys_read(AT91_AIC_IMR));
 
 error:
-	sdram_selfrefresh_disable();
 	target_state = PM_SUSPEND_ON;
 	at91_irq_resume();
 	at91_gpio_resume();

commit fced80c735941fa518ac67c0b61bbe153fb8c050
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Sep 6 12:10:45 2008 +0100

    [ARM] Convert asm/io.h to linux/io.h
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index ec2fe4ca1e27..9bb4f043aa22 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -17,8 +17,8 @@
 #include <linux/sysfs.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
+#include <linux/io.h>
 
-#include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/atomic.h>
 #include <asm/mach/time.h>

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index a5cfe866c9dd..ec2fe4ca1e27 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -24,14 +24,14 @@
 #include <asm/mach/time.h>
 #include <asm/mach/irq.h>
 
-#include <asm/arch/at91_pmc.h>
-#include <asm/arch/gpio.h>
-#include <asm/arch/cpu.h>
+#include <mach/at91_pmc.h>
+#include <mach/gpio.h>
+#include <mach/cpu.h>
 
 #include "generic.h"
 
 #ifdef CONFIG_ARCH_AT91RM9200
-#include <asm/arch/at91rm9200_mc.h>
+#include <mach/at91rm9200_mc.h>
 
 /*
  * The AT91RM9200 goes into self-refresh mode with this command, and will
@@ -41,7 +41,7 @@
 #define sdram_selfrefresh_disable()	do {} while (0)
 
 #elif defined(CONFIG_ARCH_AT91CAP9)
-#include <asm/arch/at91cap9_ddrsdr.h>
+#include <mach/at91cap9_ddrsdr.h>
 
 static u32 saved_lpr;
 
@@ -58,7 +58,7 @@ static inline void sdram_selfrefresh_enable(void)
 #define sdram_selfrefresh_disable()	at91_sys_write(AT91_DDRSDRC_LPR, saved_lpr)
 
 #else
-#include <asm/arch/at91sam9_sdramc.h>
+#include <mach/at91sam9_sdramc.h>
 
 #ifdef CONFIG_ARCH_AT91SAM9263
 /*
@@ -91,8 +91,8 @@ static inline void sdram_selfrefresh_enable(void)
  */
 #if defined(AT91_SHDWC)
 
-#include <asm/arch/at91_rstc.h>
-#include <asm/arch/at91_shdwc.h>
+#include <mach/at91_rstc.h>
+#include <mach/at91_shdwc.h>
 
 static void __init show_reset_status(void)
 {

commit 0f8469a54f7bd65f2c740a5480c56260dc8a7ae0
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Aug 3 15:06:16 2008 +0100

    [ARM] Eliminate useless includes of asm/mach-types.h
    
    There are 43 includes of asm/mach-types.h by files that don't
    reference anything from that file.  Remove these unnecessary
    includes.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 8ab4feb1ec5b..a5cfe866c9dd 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -23,7 +23,6 @@
 #include <asm/atomic.h>
 #include <asm/mach/time.h>
 #include <asm/mach/irq.h>
-#include <asm/mach-types.h>
 
 #include <asm/arch/at91_pmc.h>
 #include <asm/arch/gpio.h>

commit 613526677a74c2b3d1b1696ea7334b2cf35155b3
Author: sedji gaouaou <sedji.gaouaou@atmel.com>
Date:   Thu Jul 10 10:15:35 2008 +0100

    [ARM] 5130/4: Support for the at91sam9g20
    
    Support for the at91sam9g20 : Atmel 400Mhz ARM 926ej-s SOC.
    
    AT91sam9g20 is an evolution of the at91sam9260 with a faster clock
    speed.
    We created a new board for this device but based the chip support
    directly on 9260 files with little updates.
    Here is the chip page on Atmel wabsite:
    http://atmel.com/dyn/products/product_card.asp?part_id=4337
    
    Signed-off-by: Sedji Gaouaou <sedji.gaouaou@atmel.com>
    Signed-off-by: Justin Waters <justin.waters@timesys.com>
    Acked-by: Andrew Victor <linux@maxim.org.za>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index aa863c157708..8ab4feb1ec5b 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -202,7 +202,7 @@ static int at91_pm_verify_clocks(void)
 			pr_debug("AT91: PM - Suspend-to-RAM with USB still active\n");
 			return 0;
 		}
-	} else if (cpu_is_at91sam9260() || cpu_is_at91sam9261() || cpu_is_at91sam9263()) {
+	} else if (cpu_is_at91sam9260() || cpu_is_at91sam9261() || cpu_is_at91sam9263() || cpu_is_at91sam9g20()) {
 		if ((scsr & (AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP)) != 0) {
 			pr_debug("AT91: PM - Suspend-to-RAM with USB still active\n");
 			return 0;

commit 136eb955773dc99f82e6e754038eb1c530e03fdf
Author: David Brownell <david-b@pacbell.net>
Date:   Thu Apr 24 20:58:33 2008 +0100

    [ARM] 5021/1: at91: buildfix for sam9263 + PM
    
    Build fix for power management on at91sam9263:  it has two memory
    controllers instead of just one, so it might have two banks of
    DRAM to put into selfrefresh mode.  For now we continue to assume
    only the first bank is populated.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Andrew Victor <linux@maxim.org.za>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 39733b6992aa..aa863c157708 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -61,6 +61,15 @@ static inline void sdram_selfrefresh_enable(void)
 #else
 #include <asm/arch/at91sam9_sdramc.h>
 
+#ifdef CONFIG_ARCH_AT91SAM9263
+/*
+ * FIXME either or both the SDRAM controllers (EB0, EB1) might be in use;
+ * handle those cases both here and in the Suspend-To-RAM support.
+ */
+#define	AT91_SDRAMC	AT91_SDRAMC0
+#warning Assuming EB1 SDRAM controller is *NOT* used
+#endif
+
 static u32 saved_lpr;
 
 static inline void sdram_selfrefresh_enable(void)
@@ -75,11 +84,6 @@ static inline void sdram_selfrefresh_enable(void)
 
 #define sdram_selfrefresh_disable()	at91_sys_write(AT91_SDRAMC_LPR, saved_lpr)
 
-/*
- * FIXME: The AT91SAM9263 has a second EBI controller which may have
- *        additional SDRAM.  pm_slowclock.S will require a similar fix.
- */
-
 #endif
 
 

commit 565ac44593d17bdfc9f595614b56bb335a9b8d6f
Author: Andrew Victor <linux@maxim.org.za>
Date:   Wed Apr 2 21:52:19 2008 +0100

    [ARM] 4907/1: [AT91] SAM9/CAP9 reset reason
    
    The Reset controller on the SAM9/CAP9 processors will store the reason
    for the last system reset.
    On startup, display this information (wakeup signal, RTT alarm,
    watchdog reset, user reset, etc)
    
    Based on patch from David Brownell.
    
    Signed-off-by: Andrew Victor <linux@maxim.org.za>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 77d9669810ed..39733b6992aa 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -83,6 +83,79 @@ static inline void sdram_selfrefresh_enable(void)
 #endif
 
 
+/*
+ * Show the reason for the previous system reset.
+ */
+#if defined(AT91_SHDWC)
+
+#include <asm/arch/at91_rstc.h>
+#include <asm/arch/at91_shdwc.h>
+
+static void __init show_reset_status(void)
+{
+	static char reset[] __initdata = "reset";
+
+	static char general[] __initdata = "general";
+	static char wakeup[] __initdata = "wakeup";
+	static char watchdog[] __initdata = "watchdog";
+	static char software[] __initdata = "software";
+	static char user[] __initdata = "user";
+	static char unknown[] __initdata = "unknown";
+
+	static char signal[] __initdata = "signal";
+	static char rtc[] __initdata = "rtc";
+	static char rtt[] __initdata = "rtt";
+	static char restore[] __initdata = "power-restored";
+
+	char *reason, *r2 = reset;
+	u32 reset_type, wake_type;
+
+	reset_type = at91_sys_read(AT91_RSTC_SR) & AT91_RSTC_RSTTYP;
+	wake_type = at91_sys_read(AT91_SHDW_SR);
+
+	switch (reset_type) {
+	case AT91_RSTC_RSTTYP_GENERAL:
+		reason = general;
+		break;
+	case AT91_RSTC_RSTTYP_WAKEUP:
+		/* board-specific code enabled the wakeup sources */
+		reason = wakeup;
+
+		/* "wakeup signal" */
+		if (wake_type & AT91_SHDW_WAKEUP0)
+			r2 = signal;
+		else {
+			r2 = reason;
+			if (wake_type & AT91_SHDW_RTTWK)	/* rtt wakeup */
+				reason = rtt;
+			else if (wake_type & AT91_SHDW_RTCWK)	/* rtc wakeup */
+				reason = rtc;
+			else if (wake_type == 0)	/* power-restored wakeup */
+				reason = restore;
+			else				/* unknown wakeup */
+				reason = unknown;
+		}
+		break;
+	case AT91_RSTC_RSTTYP_WATCHDOG:
+		reason = watchdog;
+		break;
+	case AT91_RSTC_RSTTYP_SOFTWARE:
+		reason = software;
+		break;
+	case AT91_RSTC_RSTTYP_USER:
+		reason = user;
+		break;
+	default:
+		reason = unknown;
+		break;
+	}
+	pr_info("AT91: Starting after %s %s\n", reason, r2);
+}
+#else
+static void __init show_reset_status(void) {}
+#endif
+
+
 static int at91_pm_valid_state(suspend_state_t state)
 {
 	switch (state) {
@@ -294,6 +367,7 @@ static int __init at91_pm_init(void)
 
 	suspend_set_ops(&at91_pm_ops);
 
+	show_reset_status();
 	return 0;
 }
 arch_initcall(at91_pm_init);

commit f5d0f4574fe1584891b5167fb0ba42974af13e49
Author: Andrew Victor <linux@maxim.org.za>
Date:   Wed Apr 2 21:50:16 2008 +0100

    [ARM] 4906/1: [AT91] SAM9/CAP9 basic power-management
    
    Basic power-management (suspend-to-ram) support for Atmel SAM9 and
    CAP9 processors.
    
    Based on comments & patches from Anti Sullin and David Brownell.
    
    Signed-off-by: Andrew Victor <linux@maxim.org.za>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index a67defd50438..77d9669810ed 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -26,12 +26,62 @@
 #include <asm/mach-types.h>
 
 #include <asm/arch/at91_pmc.h>
-#include <asm/arch/at91rm9200_mc.h>
 #include <asm/arch/gpio.h>
 #include <asm/arch/cpu.h>
 
 #include "generic.h"
 
+#ifdef CONFIG_ARCH_AT91RM9200
+#include <asm/arch/at91rm9200_mc.h>
+
+/*
+ * The AT91RM9200 goes into self-refresh mode with this command, and will
+ * terminate self-refresh automatically on the next SDRAM access.
+ */
+#define sdram_selfrefresh_enable()	at91_sys_write(AT91_SDRAMC_SRR, 1)
+#define sdram_selfrefresh_disable()	do {} while (0)
+
+#elif defined(CONFIG_ARCH_AT91CAP9)
+#include <asm/arch/at91cap9_ddrsdr.h>
+
+static u32 saved_lpr;
+
+static inline void sdram_selfrefresh_enable(void)
+{
+	u32 lpr;
+
+	saved_lpr = at91_sys_read(AT91_DDRSDRC_LPR);
+
+	lpr = saved_lpr & ~AT91_DDRSDRC_LPCB;
+	at91_sys_write(AT91_DDRSDRC_LPR, lpr | AT91_DDRSDRC_LPCB_SELF_REFRESH);
+}
+
+#define sdram_selfrefresh_disable()	at91_sys_write(AT91_DDRSDRC_LPR, saved_lpr)
+
+#else
+#include <asm/arch/at91sam9_sdramc.h>
+
+static u32 saved_lpr;
+
+static inline void sdram_selfrefresh_enable(void)
+{
+	u32 lpr;
+
+	saved_lpr = at91_sys_read(AT91_SDRAMC_LPR);
+
+	lpr = saved_lpr & ~AT91_SDRAMC_LPCB;
+	at91_sys_write(AT91_SDRAMC_LPR, lpr | AT91_SDRAMC_LPCB_SELF_REFRESH);
+}
+
+#define sdram_selfrefresh_disable()	at91_sys_write(AT91_SDRAMC_LPR, saved_lpr)
+
+/*
+ * FIXME: The AT91SAM9263 has a second EBI controller which may have
+ *        additional SDRAM.  pm_slowclock.S will require a similar fix.
+ */
+
+#endif
+
 
 static int at91_pm_valid_state(suspend_state_t state)
 {
@@ -125,6 +175,11 @@ EXPORT_SYMBOL(at91_suspend_entering_slow_clock);
 
 static void (*slow_clock)(void);
 
+#ifdef CONFIG_AT91_SLOW_CLOCK
+extern void at91_slow_clock(void);
+extern u32 at91_slow_clock_sz;
+#endif
+
 
 static int at91_pm_enter(suspend_state_t state)
 {
@@ -158,11 +213,14 @@ static int at91_pm_enter(suspend_state_t state)
 			 * turning off the main oscillator; reverse on wakeup.
 			 */
 			if (slow_clock) {
+#ifdef CONFIG_AT91_SLOW_CLOCK
+				/* copy slow_clock handler to SRAM, and call it */
+				memcpy(slow_clock, at91_slow_clock, at91_slow_clock_sz);
+#endif
 				slow_clock();
 				break;
 			} else {
-				/* DEVELOPMENT ONLY */
-				pr_info("AT91: PM - no slow clock mode yet ...\n");
+				pr_info("AT91: PM - no slow clock mode enabled ...\n");
 				/* FALLTHROUGH leaving master clock alone */
 			}
 
@@ -175,13 +233,15 @@ static int at91_pm_enter(suspend_state_t state)
 		case PM_SUSPEND_STANDBY:
 			/*
 			 * NOTE: the Wait-for-Interrupt instruction needs to be
-			 * in icache so the SDRAM stays in self-refresh mode until
-			 * the wakeup IRQ occurs.
+			 * in icache so no SDRAM accesses are needed until the
+			 * wakeup IRQ occurs and self-refresh is terminated.
 			 */
 			asm("b 1f; .align 5; 1:");
 			asm("mcr p15, 0, r0, c7, c10, 4");	/* drain write buffer */
-			at91_sys_write(AT91_SDRAMC_SRR, 1);	/* self-refresh mode */
-			/* fall though to next state */
+			sdram_selfrefresh_enable();
+			asm("mcr p15, 0, r0, c7, c0, 4");	/* wait for interrupt */
+			sdram_selfrefresh_disable();
+			break;
 
 		case PM_SUSPEND_ON:
 			asm("mcr p15, 0, r0, c7, c0, 4");	/* wait for interrupt */
@@ -196,6 +256,7 @@ static int at91_pm_enter(suspend_state_t state)
 			at91_sys_read(AT91_AIC_IPR) & at91_sys_read(AT91_AIC_IMR));
 
 error:
+	sdram_selfrefresh_disable();
 	target_state = PM_SUSPEND_ON;
 	at91_irq_resume();
 	at91_gpio_resume();
@@ -220,18 +281,16 @@ static struct platform_suspend_ops at91_pm_ops ={
 
 static int __init at91_pm_init(void)
 {
-	printk("AT91: Power Management\n");
-
-#ifdef CONFIG_AT91_PM_SLOW_CLOCK
-	/* REVISIT allocations of SRAM should be dynamically managed.
-	 * FIQ handlers and other components will want SRAM/TCM too...
-	 */
-	slow_clock = (void *) (AT91_VA_BASE_SRAM + (3 * SZ_4K));
-	memcpy(slow_clock, at91rm9200_slow_clock, at91rm9200_slow_clock_sz);
+#ifdef CONFIG_AT91_SLOW_CLOCK
+	slow_clock = (void *) (AT91_IO_VIRT_BASE - at91_slow_clock_sz);
 #endif
 
-	/* Disable SDRAM low-power mode.  Cannot be used with self-refresh. */
+	pr_info("AT91: Power Management%s\n", (slow_clock ? " (with slow clock mode)" : ""));
+
+#ifdef CONFIG_ARCH_AT91RM9200
+	/* AT91RM9200 SDRAM low-power mode cannot be used with self-refresh. */
 	at91_sys_write(AT91_SDRAMC_LPR, 0);
+#endif
 
 	suspend_set_ops(&at91_pm_ops);
 

commit c697eecebc6cfc0b393afea3c4ff1a5041526ad1
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jan 8 00:04:17 2008 +0100

    Suspend: Introduce begin() and end() callbacks
    
    On ACPI systems the target state set by acpi_pm_set_target() is
    reset by acpi_pm_finish(), but that need not be called if the
    suspend fails.  All platforms that use the .set_target() global
    suspend callback are affected by analogous issues.
    
    For this reason, we need an additional global suspend callback that
    will reset the target state regardless of whether or not the suspend
    is successful.  Also, it is reasonable to rename the .set_target()
    callback, since it will be used for a different purpose on ACPI
    systems (due to ACPI 1.0x code ordering requirements).
    
    Introduce the global suspend callback .end() to be executed at the
    end of the suspend sequence and rename the .set_target() global
    suspend callback to .begin().
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 4b120cc36135..a67defd50438 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -52,7 +52,7 @@ static suspend_state_t target_state;
 /*
  * Called after processes are frozen, but before we shutdown devices.
  */
-static int at91_pm_set_target(suspend_state_t state)
+static int at91_pm_begin(suspend_state_t state)
 {
 	target_state = state;
 	return 0;
@@ -202,11 +202,20 @@ static int at91_pm_enter(suspend_state_t state)
 	return 0;
 }
 
+/*
+ * Called right prior to thawing processes.
+ */
+static void at91_pm_end(void)
+{
+	target_state = PM_SUSPEND_ON;
+}
+
 
 static struct platform_suspend_ops at91_pm_ops ={
-	.valid		= at91_pm_valid_state,
-	.set_target	= at91_pm_set_target,
-	.enter		= at91_pm_enter,
+	.valid	= at91_pm_valid_state,
+	.begin	= at91_pm_begin,
+	.enter	= at91_pm_enter,
+	.end	= at91_pm_end,
 };
 
 static int __init at91_pm_init(void)

commit 2b3b3516b6eeea1464e205b2dde9ebc9b7dd2ec8
Author: Andrew Victor <linux@maxim.org.za>
Date:   Thu Jan 24 15:10:39 2008 +0100

    [ARM] 4764/1: [AT91] AT91CAP9 core support
    
    Add support for Atmel's AT91CAP9 Customizable Microcontroller family.
      <http://www.atmel.com/products/AT91CAP/Default.asp>
    
    Signed-off-by: Stelian Pop <stelian@popies.net>
    Signed-off-by: Andrew Victor <linux@maxim.org.za>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 98cb61482917..4b120cc36135 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -80,6 +80,11 @@ static int at91_pm_verify_clocks(void)
 			pr_debug("AT91: PM - Suspend-to-RAM with USB still active\n");
 			return 0;
 		}
+	} else if (cpu_is_at91cap9()) {
+		if ((scsr & AT91CAP9_PMC_UHP) != 0) {
+			pr_debug("AT91: PM - Suspend-to-RAM with USB still active\n");
+			return 0;
+		}
 	}
 
 #ifdef CONFIG_AT91_PROGRAMMABLE_CLOCKS

commit 26398a70ea35f153feb799fa850c71685667712b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 18 03:04:40 2007 -0700

    PM: Rename struct pm_ops and related things
    
    The name of 'struct pm_ops' suggests that it is related to the power
    management in general, but in fact it is only related to suspend.   Moreover,
    its name should indicate what this structure is used for, so it seems
    reasonable to change it to 'struct platform_suspend_ops'.   In that case, the
    name of the global variable of this type used by the PM core and the names of
    related functions should be changed accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index c7c81c9f769c..98cb61482917 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -198,7 +198,7 @@ static int at91_pm_enter(suspend_state_t state)
 }
 
 
-static struct pm_ops at91_pm_ops ={
+static struct platform_suspend_ops at91_pm_ops ={
 	.valid		= at91_pm_valid_state,
 	.set_target	= at91_pm_set_target,
 	.enter		= at91_pm_enter,
@@ -219,7 +219,7 @@ static int __init at91_pm_init(void)
 	/* Disable SDRAM low-power mode.  Cannot be used with self-refresh. */
 	at91_sys_write(AT91_SDRAMC_LPR, 0);
 
-	pm_set_ops(&at91_pm_ops);
+	suspend_set_ops(&at91_pm_ops);
 
 	return 0;
 }

commit 95d9ffbe01fb21d524c86bf77871255066bc6e55
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 18 03:04:39 2007 -0700

    PM: Move definition of struct pm_ops to suspend.h
    
    Move the definition of 'struct pm_ops' and related functions from <linux/pm.h>
    to <linux/suspend.h> .
    
    There are, at least, the following reasons to do that:
    * 'struct pm_ops' is specifically related to suspend and not to the power
      management in general.
    * As long as 'struct pm_ops' is defined in <linux/pm.h>, any modification of it
      causes the entire kernel to be recompiled, which is unnecessary and annoying.
    * Some suspend-related features are already defined in <linux/suspend.h>, so it
      is logical to move the definition of 'struct pm_ops' into there.
    * 'struct hibernation_ops', being the hibernation-related counterpart of
      'struct pm_ops', is defined in <linux/suspend.h> .
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index ddf9184d561d..c7c81c9f769c 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -10,10 +10,9 @@
  * (at your option) any later version.
  */
 
-#include <linux/pm.h>
+#include <linux/suspend.h>
 #include <linux/sched.h>
 #include <linux/proc_fs.h>
-#include <linux/pm.h>
 #include <linux/interrupt.h>
 #include <linux/sysfs.h>
 #include <linux/module.h>

commit 2391dae3e36c19fe668c71eac2eb8344dbaaf46d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jul 1 12:07:33 2007 -0700

    PM: introduce set_target method in pm_ops
    
    Commit 52ade9b3b97fd3bea42842a056fe0786c28d0555 changed the suspend code
    ordering to execute pm_ops->prepare() after the device model per-device
    .suspend() calls in order to fix some ACPI-related issues.  Unfortunately, it
    broke the at91 platform which assumed that pm_ops->prepare() would be called
    before suspending devices.
    
    at91 used pm_ops->prepare() to get notified of the target system sleep state,
    so that it could use this information while suspending devices.  However, with
    the current suspend code ordering pm_ops->prepare() is called too late for
    this purpose.  Thus, at91 needs an additional method in 'struct pm_ops' that
    will be used for notifying the platform of the target system sleep state.
    Moreover, in the future such a method will also be needed by ACPI.
    
    This patch adds the .set_target() method to 'struct pm_ops' and makes the
    suspend code call it, if implemented, before executing the device model
    per-device .suspend() calls.  It also modifies the at91 code to use
    pm_ops->set_target() instead of pm_ops->prepare().
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index 47ff676aca5f..ddf9184d561d 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -53,7 +53,7 @@ static suspend_state_t target_state;
 /*
  * Called after processes are frozen, but before we shutdown devices.
  */
-static int at91_pm_prepare(suspend_state_t state)
+static int at91_pm_set_target(suspend_state_t state)
 {
 	target_state = state;
 	return 0;
@@ -201,7 +201,7 @@ static int at91_pm_enter(suspend_state_t state)
 
 static struct pm_ops at91_pm_ops ={
 	.valid		= at91_pm_valid_state,
-	.prepare	= at91_pm_prepare,
+	.set_target	= at91_pm_set_target,
 	.enter		= at91_pm_enter,
 };
 

commit b6b27ae5e85fb193c08448157943b187958b8ca2
Author: Andrew Victor <andrew@sanpeople.com>
Date:   Thu May 31 09:34:53 2007 +0100

    [ARM] 4419/1: AT91: SAM9 USB clocks check for suspending
    
    When suspending to slow-clock mode, at91_pm_verify_clocks() is called to
    ensure that all the clocks are disabled or in the correct state.
    
    This patch replaces the "#warning TODO" messages for the SAM9 processors
    with the correct code.
    
    Signed-off-by: Andrew Victor <andrew@sanpeople.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index ff8db29e989e..47ff676aca5f 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -76,12 +76,11 @@ static int at91_pm_verify_clocks(void)
 			pr_debug("AT91: PM - Suspend-to-RAM with USB still active\n");
 			return 0;
 		}
-	} else if (cpu_is_at91sam9260()) {
-#warning "Check SAM9260 USB clocks"
-	} else if (cpu_is_at91sam9261()) {
-#warning "Check SAM9261 USB clocks"
-	} else if (cpu_is_at91sam9263()) {
-#warning "Check SAM9263 USB clocks"
+	} else if (cpu_is_at91sam9260() || cpu_is_at91sam9261() || cpu_is_at91sam9263()) {
+		if ((scsr & (AT91SAM926x_PMC_UHP | AT91SAM926x_PMC_UDP)) != 0) {
+			pr_debug("AT91: PM - Suspend-to-RAM with USB still active\n");
+			return 0;
+		}
 	}
 
 #ifdef CONFIG_AT91_PROGRAMMABLE_CLOCKS

commit fe0c935a6cbf25d72a27c7a345df8a2151de0b74
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Apr 30 15:09:51 2007 -0700

    rework pm_ops pm_disk_mode, kill misuse
    
    This patch series cleans up some misconceptions about pm_ops.  Some users of
    the pm_ops structure attempt to use it to stop the user from entering suspend
    to disk, this, however, is not possible since the user can always use
    "shutdown" in /sys/power/disk and then the pm_ops are never invoked.  Also,
    platforms that don't support suspend to disk simply should not allow
    configuring SOFTWARE_SUSPEND (read the help text on it, it only selects
    suspend to disk and nothing else, all the other stuff depends on PM).
    
    The pm_ops structure is actually intended to provide a way to enter
    platform-defined sleep states (currently supported states are "standby" and
    "mem" (suspend to ram)) and additionally (if SOFTWARE_SUSPEND is configured)
    allows a platform to support a platform specific way to enter low-power mode
    once everything has been saved to disk.  This is currently only used by ACPI
    (S4).
    
    This patch:
    
    The pm_ops.pm_disk_mode is used in totally bogus ways since nobody really
    seems to understand what it actually does.
    
    This patch clarifies the pm_disk_mode description.
    
    It also removes all the arm and sh users that think they can veto suspend to
    disk via pm_ops; not so since the user can always do echo shutdown >
    /sys/power/disk, they need to find a better way involving Kconfig or such.
    
    ACPI is the only user left with a non-zero pm_disk_mode.
    
    The patch also sets the default mode to shutdown again, but when a new pm_ops
    is registered its pm_disk_mode is selected as default, that way the default
    stays for ACPI where it is apparently required.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Cc: David Brownell <david-b@pacbell.net>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: <linux-pm@lists.linux-foundation.org>
    Cc: Len Brown <lenb@kernel.org>
    Acked-by: Russell King <rmk@arm.linux.org.uk>
    Cc: Greg KH <greg@kroah.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index b49bfda53d7f..ff8db29e989e 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -201,7 +201,6 @@ static int at91_pm_enter(suspend_state_t state)
 
 
 static struct pm_ops at91_pm_ops ={
-	.pm_disk_mode	= 0,
 	.valid		= at91_pm_valid_state,
 	.prepare	= at91_pm_prepare,
 	.enter		= at91_pm_enter,

commit b2c6561605da4802886cafe96432b8e2968e9edc
Author: Andrew Victor <andrew@sanpeople.com>
Date:   Thu Feb 8 09:42:40 2007 +0100

    [ARM] 4145/2: AT91: Add support for AT91SAM9263 processor
    
    Add support for the Atmel AT91SAM9263 processor.  It is similar to the
    AT91SAM9260 but with more integrated peripherals, 5 GPIO banks, etc.
    
    Original patch from Nicolas Ferre.
    
    Signed-off-by: Andrew Victor <andrew@sanpeople.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
index e095b1fe8d8a..b49bfda53d7f 100644
--- a/arch/arm/mach-at91/pm.c
+++ b/arch/arm/mach-at91/pm.c
@@ -80,6 +80,8 @@ static int at91_pm_verify_clocks(void)
 #warning "Check SAM9260 USB clocks"
 	} else if (cpu_is_at91sam9261()) {
 #warning "Check SAM9261 USB clocks"
+	} else if (cpu_is_at91sam9263()) {
+#warning "Check SAM9263 USB clocks"
 	}
 
 #ifdef CONFIG_AT91_PROGRAMMABLE_CLOCKS

commit 9d0412680e6c7b685ee466842047bcfb924d6dc5
Author: Andrew Victor <andrew@sanpeople.com>
Date:   Mon Feb 5 11:42:07 2007 +0100

    [ARM] 4124/1: Rename mach-at91rm9200 and arch-at91rm9200 directories
    
    Now that Linux includes support for the Atmel AT91SAM9260 and
    AT91SAM9261 processors in addition to the original Atmel AT91RM9200
    (with support for more AT91 processors pending), the "mach-at91rm9200"
    and "arch-at91rm9200" directories should be renamed to indicate their
    more generic nature.
    
    The following git commands should be run BEFORE applying this patch:
      git-mv arch/arm/mach-at91rm9200 arch/arm/mach-at91
      git-mv include/asm-arm/arch-at91rm9200 include/asm-arm/arch-at91
    
    Signed-off-by: Andrew Victor <andrew@sanpeople.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c
new file mode 100644
index 000000000000..e095b1fe8d8a
--- /dev/null
+++ b/arch/arm/mach-at91/pm.c
@@ -0,0 +1,227 @@
+/*
+ * arch/arm/mach-at91/pm.c
+ * AT91 Power Management
+ *
+ * Copyright (C) 2005 David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/pm.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/pm.h>
+#include <linux/interrupt.h>
+#include <linux/sysfs.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/atomic.h>
+#include <asm/mach/time.h>
+#include <asm/mach/irq.h>
+#include <asm/mach-types.h>
+
+#include <asm/arch/at91_pmc.h>
+#include <asm/arch/at91rm9200_mc.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/cpu.h>
+
+#include "generic.h"
+
+
+static int at91_pm_valid_state(suspend_state_t state)
+{
+	switch (state) {
+		case PM_SUSPEND_ON:
+		case PM_SUSPEND_STANDBY:
+		case PM_SUSPEND_MEM:
+			return 1;
+
+		default:
+			return 0;
+	}
+}
+
+
+static suspend_state_t target_state;
+
+/*
+ * Called after processes are frozen, but before we shutdown devices.
+ */
+static int at91_pm_prepare(suspend_state_t state)
+{
+	target_state = state;
+	return 0;
+}
+
+/*
+ * Verify that all the clocks are correct before entering
+ * slow-clock mode.
+ */
+static int at91_pm_verify_clocks(void)
+{
+	unsigned long scsr;
+	int i;
+
+	scsr = at91_sys_read(AT91_PMC_SCSR);
+
+	/* USB must not be using PLLB */
+	if (cpu_is_at91rm9200()) {
+		if ((scsr & (AT91RM9200_PMC_UHP | AT91RM9200_PMC_UDP)) != 0) {
+			pr_debug("AT91: PM - Suspend-to-RAM with USB still active\n");
+			return 0;
+		}
+	} else if (cpu_is_at91sam9260()) {
+#warning "Check SAM9260 USB clocks"
+	} else if (cpu_is_at91sam9261()) {
+#warning "Check SAM9261 USB clocks"
+	}
+
+#ifdef CONFIG_AT91_PROGRAMMABLE_CLOCKS
+	/* PCK0..PCK3 must be disabled, or configured to use clk32k */
+	for (i = 0; i < 4; i++) {
+		u32 css;
+
+		if ((scsr & (AT91_PMC_PCK0 << i)) == 0)
+			continue;
+
+		css = at91_sys_read(AT91_PMC_PCKR(i)) & AT91_PMC_CSS;
+		if (css != AT91_PMC_CSS_SLOW) {
+			pr_debug("AT91: PM - Suspend-to-RAM with PCK%d src %d\n", i, css);
+			return 0;
+		}
+	}
+#endif
+
+	return 1;
+}
+
+/*
+ * Call this from platform driver suspend() to see how deeply to suspend.
+ * For example, some controllers (like OHCI) need one of the PLL clocks
+ * in order to act as a wakeup source, and those are not available when
+ * going into slow clock mode.
+ *
+ * REVISIT: generalize as clk_will_be_available(clk)?  Other platforms have
+ * the very same problem (but not using at91 main_clk), and it'd be better
+ * to add one generic API rather than lots of platform-specific ones.
+ */
+int at91_suspend_entering_slow_clock(void)
+{
+	return (target_state == PM_SUSPEND_MEM);
+}
+EXPORT_SYMBOL(at91_suspend_entering_slow_clock);
+
+
+static void (*slow_clock)(void);
+
+
+static int at91_pm_enter(suspend_state_t state)
+{
+	at91_gpio_suspend();
+	at91_irq_suspend();
+
+	pr_debug("AT91: PM - wake mask %08x, pm state %d\n",
+			/* remember all the always-wake irqs */
+			(at91_sys_read(AT91_PMC_PCSR)
+					| (1 << AT91_ID_FIQ)
+					| (1 << AT91_ID_SYS)
+					| (at91_extern_irq))
+				& at91_sys_read(AT91_AIC_IMR),
+			state);
+
+	switch (state) {
+		/*
+		 * Suspend-to-RAM is like STANDBY plus slow clock mode, so
+		 * drivers must suspend more deeply:  only the master clock
+		 * controller may be using the main oscillator.
+		 */
+		case PM_SUSPEND_MEM:
+			/*
+			 * Ensure that clocks are in a valid state.
+			 */
+			if (!at91_pm_verify_clocks())
+				goto error;
+
+			/*
+			 * Enter slow clock mode by switching over to clk32k and
+			 * turning off the main oscillator; reverse on wakeup.
+			 */
+			if (slow_clock) {
+				slow_clock();
+				break;
+			} else {
+				/* DEVELOPMENT ONLY */
+				pr_info("AT91: PM - no slow clock mode yet ...\n");
+				/* FALLTHROUGH leaving master clock alone */
+			}
+
+		/*
+		 * STANDBY mode has *all* drivers suspended; ignores irqs not
+		 * marked as 'wakeup' event sources; and reduces DRAM power.
+		 * But otherwise it's identical to PM_SUSPEND_ON:  cpu idle, and
+		 * nothing fancy done with main or cpu clocks.
+		 */
+		case PM_SUSPEND_STANDBY:
+			/*
+			 * NOTE: the Wait-for-Interrupt instruction needs to be
+			 * in icache so the SDRAM stays in self-refresh mode until
+			 * the wakeup IRQ occurs.
+			 */
+			asm("b 1f; .align 5; 1:");
+			asm("mcr p15, 0, r0, c7, c10, 4");	/* drain write buffer */
+			at91_sys_write(AT91_SDRAMC_SRR, 1);	/* self-refresh mode */
+			/* fall though to next state */
+
+		case PM_SUSPEND_ON:
+			asm("mcr p15, 0, r0, c7, c0, 4");	/* wait for interrupt */
+			break;
+
+		default:
+			pr_debug("AT91: PM - bogus suspend state %d\n", state);
+			goto error;
+	}
+
+	pr_debug("AT91: PM - wakeup %08x\n",
+			at91_sys_read(AT91_AIC_IPR) & at91_sys_read(AT91_AIC_IMR));
+
+error:
+	target_state = PM_SUSPEND_ON;
+	at91_irq_resume();
+	at91_gpio_resume();
+	return 0;
+}
+
+
+static struct pm_ops at91_pm_ops ={
+	.pm_disk_mode	= 0,
+	.valid		= at91_pm_valid_state,
+	.prepare	= at91_pm_prepare,
+	.enter		= at91_pm_enter,
+};
+
+static int __init at91_pm_init(void)
+{
+	printk("AT91: Power Management\n");
+
+#ifdef CONFIG_AT91_PM_SLOW_CLOCK
+	/* REVISIT allocations of SRAM should be dynamically managed.
+	 * FIQ handlers and other components will want SRAM/TCM too...
+	 */
+	slow_clock = (void *) (AT91_VA_BASE_SRAM + (3 * SZ_4K));
+	memcpy(slow_clock, at91rm9200_slow_clock, at91rm9200_slow_clock_sz);
+#endif
+
+	/* Disable SDRAM low-power mode.  Cannot be used with self-refresh. */
+	at91_sys_write(AT91_SDRAMC_LPR, 0);
+
+	pm_set_ops(&at91_pm_ops);
+
+	return 0;
+}
+arch_initcall(at91_pm_init);
