commit 0be298a939b748256035f66716fca409dd26d0dc
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Mon Jan 20 14:10:04 2020 +0200

    ARM: at91: pm: add pmc_version member to at91_pm_data
    
    This will be used to differentiate b/w different PLLs settings to be
    applied in the final/first steps of the suspend/resume process by doing
    PLL specific configurations.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Acked-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/1579522208-19523-5-git-send-email-claudiu.beznea@microchip.com

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 6f7f4236865a..218e8d1a30fb 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -34,6 +34,7 @@ struct at91_pm_data {
 	unsigned int standby_mode;
 	unsigned int suspend_mode;
 	unsigned int pmc_mckr_offset;
+	unsigned int pmc_version;
 };
 #endif
 

commit 6ec1587b5c172f53ff27e8c00e6ff9927d2650d4
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Mon Jan 20 14:10:01 2020 +0200

    ARM: at91: pm: use proper master clock register offset
    
    SAM9X60's PMC has different master clock register offset than the other
    SoCs' PMC. Due to this, specify master clock register offset based
    on PMC compatible and pass it to pm_suspend.S since it is also needed
    in there. When PM part for SAM9X60 was published the SAM9X60's PMC
    (commit f6deae46039c ("clk: at91: add sam9x60 pmc driver")) wasn't
    integrated.
    
    Fixes: 01c7031cfa73 ("ARM: at91: pm: initial PM support for SAM9X60")
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/1579522208-19523-2-git-send-email-claudiu.beznea@microchip.com

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 9fa4f483f2b5..6f7f4236865a 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -33,6 +33,7 @@ struct at91_pm_data {
 	void __iomem *sfrbu;
 	unsigned int standby_mode;
 	unsigned int suspend_mode;
+	unsigned int pmc_mckr_offset;
 };
 #endif
 

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 9bd4e6ca672a..9fa4f483f2b5 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -1,12 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * AT91 Power Management
  *
  * Copyright (C) 2005 David Brownell
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 #ifndef __ARCH_ARM_MACH_AT91_PM
 #define __ARCH_ARM_MACH_AT91_PM

commit 5b56c182edb1224bc1a97a1c74003eaa0eb59daf
Author: Wenyou Yang <wenyou.yang@atmel.com>
Date:   Tue Jul 17 11:26:55 2018 +0300

    ARM: at91: pm: Add ULP1 mode support
    
    In the ULP1 mode, in order to achieve the lowest power consumption
    with the system in retention mode and be able to resume on the wake
    up events, all the clocks are shut off, inclusive the embedded 12MHz
    RC oscillator, and the number of wake up sources is limited as well.
    When the wake up event is asserted, the embedded 12MHz RC oscillator
    restarts automatically.
    
    The ULP1 (Ultra Low-power mode 1) is introduced by SAMA5D2.
    
    The previous size of pm_suspend.o was 2148 bytes. With the addition of
    ULP1 mode the new size of pm_suspend.o raised at 2456 bytes.
    
    Signed-off-by: Wenyou Yang <wenyou.yang@atmel.com>
    Signed-off-by: Ludovic Desroches <ludovic.desroches@microchip.com>
    [claudiu.beznea@microchip.com: aligned with 4.18-rc1]
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index c44eaf17db86..9bd4e6ca672a 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -23,7 +23,8 @@
 
 #define	AT91_PM_STANDBY		0x00
 #define AT91_PM_ULP0		0x01
-#define	AT91_PM_BACKUP		0x02
+#define AT91_PM_ULP1		0x02
+#define	AT91_PM_BACKUP		0x03
 
 #ifndef __ASSEMBLY__
 struct at91_pm_data {

commit 514e2a294aad435ce205c1c66d2abb89a292473c
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Tue Jul 17 11:26:54 2018 +0300

    ARM: at91: pm: Use ULP0 naming instead of slow clock
    
    Switch to use ULP0 naming instead of slow clock naming for power modes, to
    be as closed as possible to datasheet. This commit does the necessary
    renaming and macro addition to be as close as possible to the namings
    from [1].
    
    [1] https://lore.kernel.org/lkml/1470650705-31418-3-git-send-email-wenyou.yang@atmel.com
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index f95d31496f08..c44eaf17db86 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -21,7 +21,8 @@
 #define AT91_MEMCTRL_SDRAMC	1
 #define AT91_MEMCTRL_DDRSDR	2
 
-#define	AT91_PM_SLOW_CLOCK	0x01
+#define	AT91_PM_STANDBY		0x00
+#define AT91_PM_ULP0		0x01
 #define	AT91_PM_BACKUP		0x02
 
 #ifndef __ASSEMBLY__

commit 7693e18e8c2e2f3188f69bd572ff77dac481da6e
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Wed Apr 26 16:31:03 2017 +0200

    ARM: at91: pm: allow selecting standby and suspend modes
    
    While we can only select between "standby" and "mem" states for power
    management, the atmel platforms can actually support more modes.
    
    For both standby and mem, allow selecting which mode will be used using the
    atmel.pm_modes kernel parameter.
    By default, keep the current modes.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Wenyou Yang <wenyou.yang@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index d9c6612ef62f..f95d31496f08 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -33,7 +33,8 @@ struct at91_pm_data {
 	unsigned int mode;
 	void __iomem *shdwc;
 	void __iomem *sfrbu;
-	unsigned int deepest_state;
+	unsigned int standby_mode;
+	unsigned int suspend_mode;
 };
 #endif
 

commit 24a0f5c539f944248cbb2e3502830dcb7fd2a96e
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Tue Sep 27 12:29:50 2016 +0200

    ARM: at91: pm: Add sama5d2 backup mode
    
    The sama5d2 has a mode were it is possible to cut power to the SoC while
    keeping the RAM in self refresh.
    Resuming from that mode needs support in the firmware/bootloader.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Wenyou Yang <wenyou.yang@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index fc0f7d048187..d9c6612ef62f 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -22,6 +22,7 @@
 #define AT91_MEMCTRL_DDRSDR	2
 
 #define	AT91_PM_SLOW_CLOCK	0x01
+#define	AT91_PM_BACKUP		0x02
 
 #ifndef __ASSEMBLY__
 struct at91_pm_data {
@@ -30,6 +31,9 @@ struct at91_pm_data {
 	unsigned long uhp_udp_mask;
 	unsigned int memctrl;
 	unsigned int mode;
+	void __iomem *shdwc;
+	void __iomem *sfrbu;
+	unsigned int deepest_state;
 };
 #endif
 

commit 65cc1a59d192be1df33633d3fe668a1e3e0edc36
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Tue Jan 31 18:12:57 2017 +0100

    ARM: at91: pm: Use struct at91_pm_data in pm_suspend.S
    
    The number of register we can safely pass to at91_pm_suspend_in_sram is
    limited. Instead, pass the address to the at91_pm_data structure.
    
    The offsets are automatically generated to avoid hardcoding them.
    
    Acked-by: Wenyou Yang <wenyou.yang@atmel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 8eed156ef19a..fc0f7d048187 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -21,12 +21,16 @@
 #define AT91_MEMCTRL_SDRAMC	1
 #define AT91_MEMCTRL_DDRSDR	2
 
-#define	AT91_PM_MEMTYPE_MASK	0x0f
-
-#define	AT91_PM_MODE_OFFSET	4
-#define	AT91_PM_MODE_MASK	0x01
-#define	AT91_PM_MODE(x)		(((x) & AT91_PM_MODE_MASK) << AT91_PM_MODE_OFFSET)
-
 #define	AT91_PM_SLOW_CLOCK	0x01
 
+#ifndef __ASSEMBLY__
+struct at91_pm_data {
+	void __iomem *pmc;
+	void __iomem *ramc[2];
+	unsigned long uhp_udp_mask;
+	unsigned int memctrl;
+	unsigned int mode;
+};
+#endif
+
 #endif

commit 4d767bc3c3ae4894877061b58fce0acf63096576
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Tue Jan 31 14:08:47 2017 +0100

    ARM: at91: pm: Move at91_ramc_read/write to pm.c
    
    Those macros are only used in pm.c, move them there so we can remove the
    test on __ASSEMBLY__.
    
    Acked-by: Wenyou Yang <wenyou.yang@atmel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index bf980c6ef294..8eed156ef19a 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -17,14 +17,6 @@
 #include <soc/at91/at91sam9_ddrsdr.h>
 #include <soc/at91/at91sam9_sdramc.h>
 
-#ifndef __ASSEMBLY__
-#define at91_ramc_read(id, field) \
-	__raw_readl(at91_ramc_base[id] + field)
-
-#define at91_ramc_write(id, field, value) \
-	__raw_writel(value, at91_ramc_base[id] + field)
-#endif
-
 #define AT91_MEMCTRL_MC		0
 #define AT91_MEMCTRL_SDRAMC	1
 #define AT91_MEMCTRL_DDRSDR	2

commit 6cc7fbdf8d931eefa2d0aabf0d2840e94ba09ae5
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Tue Sep 27 12:37:15 2016 +0200

    ARM: at91: pm: remove useless extern definition
    
    at91_ramc_base is local to pm.c, remove its definition in pm.h
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 3fcf8810f14e..bf980c6ef294 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -18,8 +18,6 @@
 #include <soc/at91/at91sam9_sdramc.h>
 
 #ifndef __ASSEMBLY__
-extern void __iomem *at91_ramc_base[];
-
 #define at91_ramc_read(id, field) \
 	__raw_readl(at91_ramc_base[id] + field)
 

commit 09099f1942e993b1c63408b5a385883876e3e35e
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Mon Mar 16 15:13:39 2015 +0100

    ARM: at91: remove mach/at91_ramc.h and mach/at91rm9200_mc.h
    
    mach/at91_ramc.h and mach/at91rm9200_mc.h aren't necessary anymore, remove them.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index ecd875a91d52..3fcf8810f14e 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -13,7 +13,19 @@
 
 #include <asm/proc-fns.h>
 
-#include <mach/at91_ramc.h>
+#include <linux/mfd/syscon/atmel-mc.h>
+#include <soc/at91/at91sam9_ddrsdr.h>
+#include <soc/at91/at91sam9_sdramc.h>
+
+#ifndef __ASSEMBLY__
+extern void __iomem *at91_ramc_base[];
+
+#define at91_ramc_read(id, field) \
+	__raw_readl(at91_ramc_base[id] + field)
+
+#define at91_ramc_write(id, field, value) \
+	__raw_writel(value, at91_ramc_base[id] + field)
+#endif
 
 #define AT91_MEMCTRL_MC		0
 #define AT91_MEMCTRL_SDRAMC	1

commit 2e57dc087c27b8b0bd4a9e5f2c6f28f3cd0b47ff
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Mon Mar 16 23:44:38 2015 +0100

    ARM: at91/pm: move AT91_MEMCTRL_* to pm.h
    
    the AT91_MEMCTRL_* defines are only used by the pm code, move them to pm.h
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 3223967d3460..ecd875a91d52 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -15,6 +15,10 @@
 
 #include <mach/at91_ramc.h>
 
+#define AT91_MEMCTRL_MC		0
+#define AT91_MEMCTRL_SDRAMC	1
+#define AT91_MEMCTRL_DDRSDR	2
+
 #define	AT91_PM_MEMTYPE_MASK	0x0f
 
 #define	AT91_PM_MODE_OFFSET	4

commit a18d0699dd18ba5661c321ebd67e6056656b6765
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Mon Mar 16 23:44:37 2015 +0100

    ARM: at91/pm: move the standby functions to pm.c
    
    The standby functions are now only used in pm.c, move them there.
    
    Also, they are not inlined as a pointer to those functions is passed to the
    cpuidle driver.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index dcacfa1ad3fa..3223967d3460 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -23,96 +23,4 @@
 
 #define	AT91_PM_SLOW_CLOCK	0x01
 
-/*
- * The AT91RM9200 goes into self-refresh mode with this command, and will
- * terminate self-refresh automatically on the next SDRAM access.
- *
- * Self-refresh mode is exited as soon as a memory access is made, but we don't
- * know for sure when that happens. However, we need to restore the low-power
- * mode if it was enabled before going idle. Restoring low-power mode while
- * still in self-refresh is "not recommended", but seems to work.
- */
-
-#ifndef __ASSEMBLY__
-static inline void at91rm9200_standby(void)
-{
-	u32 lpr = at91_ramc_read(0, AT91RM9200_SDRAMC_LPR);
-
-	asm volatile(
-		"b    1f\n\t"
-		".align    5\n\t"
-		"1:  mcr    p15, 0, %0, c7, c10, 4\n\t"
-		"    str    %0, [%1, %2]\n\t"
-		"    str    %3, [%1, %4]\n\t"
-		"    mcr    p15, 0, %0, c7, c0, 4\n\t"
-		"    str    %5, [%1, %2]"
-		:
-		: "r" (0), "r" (at91_ramc_base[0]), "r" (AT91RM9200_SDRAMC_LPR),
-		  "r" (1), "r" (AT91RM9200_SDRAMC_SRR),
-		  "r" (lpr));
-}
-
-/* We manage both DDRAM/SDRAM controllers, we need more than one value to
- * remember.
- */
-static inline void at91_ddr_standby(void)
-{
-	/* Those two values allow us to delay self-refresh activation
-	 * to the maximum. */
-	u32 lpr0, lpr1 = 0;
-	u32 saved_lpr0, saved_lpr1 = 0;
-
-	if (at91_ramc_base[1]) {
-		saved_lpr1 = at91_ramc_read(1, AT91_DDRSDRC_LPR);
-		lpr1 = saved_lpr1 & ~AT91_DDRSDRC_LPCB;
-		lpr1 |= AT91_DDRSDRC_LPCB_SELF_REFRESH;
-	}
-
-	saved_lpr0 = at91_ramc_read(0, AT91_DDRSDRC_LPR);
-	lpr0 = saved_lpr0 & ~AT91_DDRSDRC_LPCB;
-	lpr0 |= AT91_DDRSDRC_LPCB_SELF_REFRESH;
-
-	/* self-refresh mode now */
-	at91_ramc_write(0, AT91_DDRSDRC_LPR, lpr0);
-	if (at91_ramc_base[1])
-		at91_ramc_write(1, AT91_DDRSDRC_LPR, lpr1);
-
-	cpu_do_idle();
-
-	at91_ramc_write(0, AT91_DDRSDRC_LPR, saved_lpr0);
-	if (at91_ramc_base[1])
-		at91_ramc_write(1, AT91_DDRSDRC_LPR, saved_lpr1);
-}
-
-/* We manage both DDRAM/SDRAM controllers, we need more than one value to
- * remember.
- */
-static inline void at91sam9_sdram_standby(void)
-{
-	u32 lpr0, lpr1 = 0;
-	u32 saved_lpr0, saved_lpr1 = 0;
-
-	if (at91_ramc_base[1]) {
-		saved_lpr1 = at91_ramc_read(1, AT91_SDRAMC_LPR);
-		lpr1 = saved_lpr1 & ~AT91_SDRAMC_LPCB;
-		lpr1 |= AT91_SDRAMC_LPCB_SELF_REFRESH;
-	}
-
-	saved_lpr0 = at91_ramc_read(0, AT91_SDRAMC_LPR);
-	lpr0 = saved_lpr0 & ~AT91_SDRAMC_LPCB;
-	lpr0 |= AT91_SDRAMC_LPCB_SELF_REFRESH;
-
-	/* self-refresh mode now */
-	at91_ramc_write(0, AT91_SDRAMC_LPR, lpr0);
-	if (at91_ramc_base[1])
-		at91_ramc_write(1, AT91_SDRAMC_LPR, lpr1);
-
-	cpu_do_idle();
-
-	at91_ramc_write(0, AT91_SDRAMC_LPR, saved_lpr0);
-	if (at91_ramc_base[1])
-		at91_ramc_write(1, AT91_SDRAMC_LPR, saved_lpr1);
-}
-
-#endif
 #endif

commit 23be4be5a666c6b4e6fe8ddbbb84fb4f2efee0a5
Author: Wenyou Yang <wenyou.yang@atmel.com>
Date:   Mon Mar 9 11:49:46 2015 +0800

    ARM: at91/pm: standby mode uses same sram function as suspend to memory mode
    
    To simply the PM code, the suspend to standby mode uses same sram function
    as the suspend to memory mode, running in the internal SRAM, instead of the
    respective code for each mode.
    
    For the suspend to standby mode, the master clock doesn't switch to the slow
    clock, and PLLA and the main oscillator doesn't turn off as well.
    
    Signed-off-by: Wenyou Yang <wenyou.yang@atmel.com>
    Tested-by: Sylvain Rochet <sylvain.rochet@finsecur.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 86a9d0b91814..dcacfa1ad3fa 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -15,6 +15,14 @@
 
 #include <mach/at91_ramc.h>
 
+#define	AT91_PM_MEMTYPE_MASK	0x0f
+
+#define	AT91_PM_MODE_OFFSET	4
+#define	AT91_PM_MODE_MASK	0x01
+#define	AT91_PM_MODE(x)		(((x) & AT91_PM_MODE_MASK) << AT91_PM_MODE_OFFSET)
+
+#define	AT91_PM_SLOW_CLOCK	0x01
+
 /*
  * The AT91RM9200 goes into self-refresh mode with this command, and will
  * terminate self-refresh automatically on the next SDRAM access.
@@ -25,6 +33,7 @@
  * still in self-refresh is "not recommended", but seems to work.
  */
 
+#ifndef __ASSEMBLY__
 static inline void at91rm9200_standby(void)
 {
 	u32 lpr = at91_ramc_read(0, AT91RM9200_SDRAMC_LPR);
@@ -106,3 +115,4 @@ static inline void at91sam9_sdram_standby(void)
 }
 
 #endif
+#endif

commit 047794e13632f177e864eba6160cecfbf3875cbe
Author: Wenyou Yang <wenyou.yang@atmel.com>
Date:   Wed Mar 4 09:44:45 2015 +0800

    ARM: at91: pm: change at91_pm_set_standby() to static
    
    Since at91_pm_set_standby() will not be used out of the pm.c file,
    change its attribute from extern to static, remove its declaration as well.
    
    Signed-off-by: Wenyou Yang <wenyou.yang@atmel.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 86c0aa819d25..86a9d0b91814 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -15,12 +15,6 @@
 
 #include <mach/at91_ramc.h>
 
-#ifdef CONFIG_PM
-extern void at91_pm_set_standby(void (*at91_standby)(void));
-#else
-static inline void at91_pm_set_standby(void (*at91_standby)(void)) { }
-#endif
-
 /*
  * The AT91RM9200 goes into self-refresh mode with this command, and will
  * terminate self-refresh automatically on the next SDRAM access.

commit 84e871660bebfddb9a62ebd6f19d02536e782f0a
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Tue Mar 3 19:58:22 2015 +0100

    ARM: at91: pm: fix at91rm9200 standby
    
    at91rm9200 standby and suspend to ram has been broken since
    00482a4078f4. It is wrongly using AT91_BASE_SYS which is a physical address
    and actually doesn't correspond to any register on at91rm9200.
    
    Use the correct at91_ramc_base[0] instead.
    
    Fixes: 00482a4078f4 (ARM: at91: implement the standby function for pm/cpuidle)
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index d2c89963af2d..86c0aa819d25 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -44,7 +44,7 @@ static inline void at91rm9200_standby(void)
 		"    mcr    p15, 0, %0, c7, c0, 4\n\t"
 		"    str    %5, [%1, %2]"
 		:
-		: "r" (0), "r" (AT91_BASE_SYS), "r" (AT91RM9200_SDRAMC_LPR),
+		: "r" (0), "r" (at91_ramc_base[0]), "r" (AT91RM9200_SDRAMC_LPR),
 		  "r" (1), "r" (AT91RM9200_SDRAMC_SRR),
 		  "r" (lpr));
 }

commit f0a0a58e6f46c2dded813ee860b9cbd795b4e571
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Fri Nov 7 21:58:21 2014 +0100

    ARM: at91: move sdramc/ddrsdr header to include/soc/at91
    
    Move the (DDR) SDRAM controller headers to include/soc/at91 to remove the
    dependency on mach/ headers from the at91-reset driver.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index c5101dcb4fb0..d2c89963af2d 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -14,7 +14,6 @@
 #include <asm/proc-fns.h>
 
 #include <mach/at91_ramc.h>
-#include <mach/at91rm9200_sdramc.h>
 
 #ifdef CONFIG_PM
 extern void at91_pm_set_standby(void (*at91_standby)(void));

commit 7093bf2b7195541281cb711e31c027a8d826c6df
Author: Brent Taylor <motobud@gmail.com>
Date:   Sun Nov 24 12:02:35 2013 -0600

    ARM: at91: fixed unresolved symbol "at91_pm_set_standby" when built without CONFIG_PM
    
    If CONFIG_PM is not defined, then arch/arm/mach-at91/pm.c is not
    compiled in.  This patch creates an inline function that does nothing
    if CONFIG_PM is not defined.
    
    Signed-off-by: Brent Taylor <motobud@gmail.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 3ed190ce062b..c5101dcb4fb0 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -16,7 +16,11 @@
 #include <mach/at91_ramc.h>
 #include <mach/at91rm9200_sdramc.h>
 
+#ifdef CONFIG_PM
 extern void at91_pm_set_standby(void (*at91_standby)(void));
+#else
+static inline void at91_pm_set_standby(void (*at91_standby)(void)) { }
+#endif
 
 /*
  * The AT91RM9200 goes into self-refresh mode with this command, and will

commit 2d2c476f3c075bd2fdfce479245b2bf4d0879ec6
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Wed Oct 16 16:24:56 2013 +0200

    ARM: AT91: pm: Factorize standby function
    
    Detect presence of second bank. So we do not need to have on function per SoC
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 76dd1a749ebd..3ed190ce062b 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -49,16 +49,18 @@ static inline void at91rm9200_standby(void)
 /* We manage both DDRAM/SDRAM controllers, we need more than one value to
  * remember.
  */
-static inline void at91sam9g45_standby(void)
+static inline void at91_ddr_standby(void)
 {
 	/* Those two values allow us to delay self-refresh activation
 	 * to the maximum. */
-	u32 lpr0, lpr1;
-	u32 saved_lpr0, saved_lpr1;
+	u32 lpr0, lpr1 = 0;
+	u32 saved_lpr0, saved_lpr1 = 0;
 
-	saved_lpr1 = at91_ramc_read(1, AT91_DDRSDRC_LPR);
-	lpr1 = saved_lpr1 & ~AT91_DDRSDRC_LPCB;
-	lpr1 |= AT91_DDRSDRC_LPCB_SELF_REFRESH;
+	if (at91_ramc_base[1]) {
+		saved_lpr1 = at91_ramc_read(1, AT91_DDRSDRC_LPR);
+		lpr1 = saved_lpr1 & ~AT91_DDRSDRC_LPCB;
+		lpr1 |= AT91_DDRSDRC_LPCB_SELF_REFRESH;
+	}
 
 	saved_lpr0 = at91_ramc_read(0, AT91_DDRSDRC_LPR);
 	lpr0 = saved_lpr0 & ~AT91_DDRSDRC_LPCB;
@@ -66,25 +68,29 @@ static inline void at91sam9g45_standby(void)
 
 	/* self-refresh mode now */
 	at91_ramc_write(0, AT91_DDRSDRC_LPR, lpr0);
-	at91_ramc_write(1, AT91_DDRSDRC_LPR, lpr1);
+	if (at91_ramc_base[1])
+		at91_ramc_write(1, AT91_DDRSDRC_LPR, lpr1);
 
 	cpu_do_idle();
 
 	at91_ramc_write(0, AT91_DDRSDRC_LPR, saved_lpr0);
-	at91_ramc_write(1, AT91_DDRSDRC_LPR, saved_lpr1);
+	if (at91_ramc_base[1])
+		at91_ramc_write(1, AT91_DDRSDRC_LPR, saved_lpr1);
 }
 
 /* We manage both DDRAM/SDRAM controllers, we need more than one value to
  * remember.
  */
-static inline void at91sam9263_standby(void)
+static inline void at91sam9_sdram_standby(void)
 {
-	u32 lpr0, lpr1;
-	u32 saved_lpr0, saved_lpr1;
+	u32 lpr0, lpr1 = 0;
+	u32 saved_lpr0, saved_lpr1 = 0;
 
-	saved_lpr1 = at91_ramc_read(1, AT91_SDRAMC_LPR);
-	lpr1 = saved_lpr1 & ~AT91_SDRAMC_LPCB;
-	lpr1 |= AT91_SDRAMC_LPCB_SELF_REFRESH;
+	if (at91_ramc_base[1]) {
+		saved_lpr1 = at91_ramc_read(1, AT91_SDRAMC_LPR);
+		lpr1 = saved_lpr1 & ~AT91_SDRAMC_LPCB;
+		lpr1 |= AT91_SDRAMC_LPCB_SELF_REFRESH;
+	}
 
 	saved_lpr0 = at91_ramc_read(0, AT91_SDRAMC_LPR);
 	lpr0 = saved_lpr0 & ~AT91_SDRAMC_LPCB;
@@ -92,27 +98,14 @@ static inline void at91sam9263_standby(void)
 
 	/* self-refresh mode now */
 	at91_ramc_write(0, AT91_SDRAMC_LPR, lpr0);
-	at91_ramc_write(1, AT91_SDRAMC_LPR, lpr1);
+	if (at91_ramc_base[1])
+		at91_ramc_write(1, AT91_SDRAMC_LPR, lpr1);
 
 	cpu_do_idle();
 
 	at91_ramc_write(0, AT91_SDRAMC_LPR, saved_lpr0);
-	at91_ramc_write(1, AT91_SDRAMC_LPR, saved_lpr1);
-}
-
-static inline void at91sam9_standby(void)
-{
-	u32 saved_lpr, lpr;
-
-	saved_lpr = at91_ramc_read(0, AT91_SDRAMC_LPR);
-
-	lpr = saved_lpr & ~AT91_SDRAMC_LPCB;
-	at91_ramc_write(0, AT91_SDRAMC_LPR, lpr |
-			AT91_SDRAMC_LPCB_SELF_REFRESH);
-
-	cpu_do_idle();
-
-	at91_ramc_write(0, AT91_SDRAMC_LPR, saved_lpr);
+	if (at91_ramc_base[1])
+		at91_ramc_write(1, AT91_SDRAMC_LPR, saved_lpr1);
 }
 
 #endif

commit 5ad945ea58f6cab7490dc149974ccb6514cc569a
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Sun Sep 22 22:29:57 2013 +0200

    ARM: at91: cpuidle: Convert to platform driver
    
    Using the platform driver model is a good way to separate the cpuidle specific
    code from the low level pm code. It allows to remove the dependency between
    these two components.
    
    The platform_device is located in the pm code and a 'set' function has been
    added to set the standby function from the AT91_SOC_START initialization
    function. Each SoC with a cpuidle driver will set the standby function in the
    platform_data field at init time. Then pm code will register the cpuidle
    platform device.
    
    The cpuidle driver will register the platform_driver and use the device's
    platform_data as a standby callback in the idle path.
    
    The at91_pm_enter function contains a { if then else } based on cpu_is_xx
    similar to what was in cpuidle. This is considered dangerous when adding a new
    SoC. Like the cpuidle driver, a standby ops is defined and assigned when the
    SoC init function specifies what is its standby function and reused in the
    at91_pm_enter's 'case' block.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 2f5908f0b8c5..76dd1a749ebd 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -11,9 +11,13 @@
 #ifndef __ARCH_ARM_MACH_AT91_PM
 #define __ARCH_ARM_MACH_AT91_PM
 
+#include <asm/proc-fns.h>
+
 #include <mach/at91_ramc.h>
 #include <mach/at91rm9200_sdramc.h>
 
+extern void at91_pm_set_standby(void (*at91_standby)(void));
+
 /*
  * The AT91RM9200 goes into self-refresh mode with this command, and will
  * terminate self-refresh automatically on the next SDRAM access.

commit f5fa4098c3fcc0e504fbc0682dccd331dbbcf197
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jan 25 22:44:17 2013 +0000

    ARM: at91: suspend both memory controllers on at91sam9263
    
    For the past three years, we have had a #warning in
    mach-at91 about the sdram_selfrefresh_enable or
    at91sam9_standby functions possibly not working on
    at91sam9263. In the meantime a function was added
    to do the right thing on at91sam9g45, which looks like
    it should also work on '9263.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    [nicolas.ferre@atmel.com: remove paragraph in commit message]
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 38f467c6b710..2f5908f0b8c5 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -70,13 +70,31 @@ static inline void at91sam9g45_standby(void)
 	at91_ramc_write(1, AT91_DDRSDRC_LPR, saved_lpr1);
 }
 
-#ifdef CONFIG_SOC_AT91SAM9263
-/*
- * FIXME either or both the SDRAM controllers (EB0, EB1) might be in use;
- * handle those cases both here and in the Suspend-To-RAM support.
+/* We manage both DDRAM/SDRAM controllers, we need more than one value to
+ * remember.
  */
-#warning Assuming EB1 SDRAM controller is *NOT* used
-#endif
+static inline void at91sam9263_standby(void)
+{
+	u32 lpr0, lpr1;
+	u32 saved_lpr0, saved_lpr1;
+
+	saved_lpr1 = at91_ramc_read(1, AT91_SDRAMC_LPR);
+	lpr1 = saved_lpr1 & ~AT91_SDRAMC_LPCB;
+	lpr1 |= AT91_SDRAMC_LPCB_SELF_REFRESH;
+
+	saved_lpr0 = at91_ramc_read(0, AT91_SDRAMC_LPR);
+	lpr0 = saved_lpr0 & ~AT91_SDRAMC_LPCB;
+	lpr0 |= AT91_SDRAMC_LPCB_SELF_REFRESH;
+
+	/* self-refresh mode now */
+	at91_ramc_write(0, AT91_SDRAMC_LPR, lpr0);
+	at91_ramc_write(1, AT91_SDRAMC_LPR, lpr1);
+
+	cpu_do_idle();
+
+	at91_ramc_write(0, AT91_SDRAMC_LPR, saved_lpr0);
+	at91_ramc_write(1, AT91_SDRAMC_LPR, saved_lpr1);
+}
 
 static inline void at91sam9_standby(void)
 {

commit 1e3ce2b8545390a2aee8dbfcd49ca4161b636000
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Fri Apr 6 11:51:50 2012 +0800

    ARN: at91: introduce SOC_AT91xxx define to allow to compile SoC core support
    
    We can now compile all SoC core support together and DT boards.
    We still can not compile together the non DT board.
    So We keep the ARCH_AT91xxx for the non DT board and for backward defconfig
    compatibility. This will enable the plaform_device ressources.
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 1b4865e7571d..38f467c6b710 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -70,7 +70,7 @@ static inline void at91sam9g45_standby(void)
 	at91_ramc_write(1, AT91_DDRSDRC_LPR, saved_lpr1);
 }
 
-#ifdef CONFIG_ARCH_AT91SAM9263
+#ifdef CONFIG_SOC_AT91SAM9263
 /*
  * FIXME either or both the SDRAM controllers (EB0, EB1) might be in use;
  * handle those cases both here and in the Suspend-To-RAM support.

commit efd09165aa554f84a42565d5ae6a1af58b06a97a
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Mon Feb 13 14:58:30 2012 +0800

    ARM: at91: pm select memory controler at runtime
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    [nicolas.ferre@atmel.com: add cpuidle modification]
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 89f56f3a802e..1b4865e7571d 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -12,7 +12,6 @@
 #define __ARCH_ARM_MACH_AT91_PM
 
 #include <mach/at91_ramc.h>
-#ifdef CONFIG_ARCH_AT91RM9200
 #include <mach/at91rm9200_sdramc.h>
 
 /*
@@ -43,10 +42,6 @@ static inline void at91rm9200_standby(void)
 		  "r" (lpr));
 }
 
-#define at91_standby at91rm9200_standby
-
-#elif defined(CONFIG_ARCH_AT91SAM9G45)
-
 /* We manage both DDRAM/SDRAM controllers, we need more than one value to
  * remember.
  */
@@ -75,10 +70,6 @@ static inline void at91sam9g45_standby(void)
 	at91_ramc_write(1, AT91_DDRSDRC_LPR, saved_lpr1);
 }
 
-#define at91_standby at91sam9g45_standby
-
-#else
-
 #ifdef CONFIG_ARCH_AT91SAM9263
 /*
  * FIXME either or both the SDRAM controllers (EB0, EB1) might be in use;
@@ -102,8 +93,4 @@ static inline void at91sam9_standby(void)
 	at91_ramc_write(0, AT91_SDRAMC_LPR, saved_lpr);
 }
 
-#define at91_standby at91sam9_standby
-
-#endif
-
 #endif

commit f363c407b42c467d06675c852e55f26adb959915
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Mon Feb 13 12:58:53 2012 +0800

    ARM: at91: make sdram/ddr register base soc independent
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 41cdd2beb1ec..89f56f3a802e 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -11,8 +11,8 @@
 #ifndef __ARCH_ARM_MACH_AT91_PM
 #define __ARCH_ARM_MACH_AT91_PM
 
+#include <mach/at91_ramc.h>
 #ifdef CONFIG_ARCH_AT91RM9200
-#include <mach/at91rm9200_mc.h>
 #include <mach/at91rm9200_sdramc.h>
 
 /*
@@ -27,7 +27,7 @@
 
 static inline void at91rm9200_standby(void)
 {
-	u32 lpr = at91_sys_read(AT91RM9200_SDRAMC_LPR);
+	u32 lpr = at91_ramc_read(0, AT91RM9200_SDRAMC_LPR);
 
 	asm volatile(
 		"b    1f\n\t"
@@ -46,7 +46,6 @@ static inline void at91rm9200_standby(void)
 #define at91_standby at91rm9200_standby
 
 #elif defined(CONFIG_ARCH_AT91SAM9G45)
-#include <mach/at91sam9_ddrsdr.h>
 
 /* We manage both DDRAM/SDRAM controllers, we need more than one value to
  * remember.
@@ -79,7 +78,6 @@ static inline void at91sam9g45_standby(void)
 #define at91_standby at91sam9g45_standby
 
 #else
-#include <mach/at91sam9_sdramc.h>
 
 #ifdef CONFIG_ARCH_AT91SAM9263
 /*

commit 1a269ade22bb65d0afc0d20e0a19602453fae04a
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Wed Nov 16 02:58:31 2011 +0800

    ARM: at91: move at91rm9200 sdramc defines to at91rm9200_sdramc.h
    
    This cleanup is done to allow to have multiple SoC in the same image.
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index bba9ce1aaaec..41cdd2beb1ec 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -13,6 +13,7 @@
 
 #ifdef CONFIG_ARCH_AT91RM9200
 #include <mach/at91rm9200_mc.h>
+#include <mach/at91rm9200_sdramc.h>
 
 /*
  * The AT91RM9200 goes into self-refresh mode with this command, and will
@@ -26,7 +27,7 @@
 
 static inline void at91rm9200_standby(void)
 {
-	u32 lpr = at91_sys_read(AT91_SDRAMC_LPR);
+	u32 lpr = at91_sys_read(AT91RM9200_SDRAMC_LPR);
 
 	asm volatile(
 		"b    1f\n\t"
@@ -37,8 +38,8 @@ static inline void at91rm9200_standby(void)
 		"    mcr    p15, 0, %0, c7, c0, 4\n\t"
 		"    str    %5, [%1, %2]"
 		:
-		: "r" (0), "r" (AT91_BASE_SYS), "r" (AT91_SDRAMC_LPR),
-		  "r" (1), "r" (AT91_SDRAMC_SRR),
+		: "r" (0), "r" (AT91_BASE_SYS), "r" (AT91RM9200_SDRAMC_LPR),
+		  "r" (1), "r" (AT91RM9200_SDRAMC_SRR),
 		  "r" (lpr));
 }
 

commit 00482a4078f4ff0dd0638e7f2fd83e34cc402ff7
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Wed Jan 25 00:56:08 2012 +0100

    ARM: at91: implement the standby function for pm/cpuidle
    
    This patch groups the self-refresh on/cpu_do_idle/self-refresh off into
    a single 'standby' function.
    
    The standby routine for rm9200 has been turned into an asm routine to have
    a better control of the self refresh and to prevent a memory access when
    running this code.
    
    Draining the write buffer is done automatically when switching for the self
    refresh on sam9, so the instruction is added to the rm9200 only.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 38f9a13ee794..bba9ce1aaaec 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -24,17 +24,25 @@
  * still in self-refresh is "not recommended", but seems to work.
  */
 
-static inline u32 sdram_selfrefresh_enable(void)
+static inline void at91rm9200_standby(void)
 {
-	u32 saved_lpr = at91_sys_read(AT91_SDRAMC_LPR);
-
-	at91_sys_write(AT91_SDRAMC_LPR, 0);
-	at91_sys_write(AT91_SDRAMC_SRR, 1);
-	return saved_lpr;
+	u32 lpr = at91_sys_read(AT91_SDRAMC_LPR);
+
+	asm volatile(
+		"b    1f\n\t"
+		".align    5\n\t"
+		"1:  mcr    p15, 0, %0, c7, c10, 4\n\t"
+		"    str    %0, [%1, %2]\n\t"
+		"    str    %3, [%1, %4]\n\t"
+		"    mcr    p15, 0, %0, c7, c0, 4\n\t"
+		"    str    %5, [%1, %2]"
+		:
+		: "r" (0), "r" (AT91_BASE_SYS), "r" (AT91_SDRAMC_LPR),
+		  "r" (1), "r" (AT91_SDRAMC_SRR),
+		  "r" (lpr));
 }
 
-#define sdram_selfrefresh_disable(saved_lpr) \
-	at91_sys_write(AT91_SDRAMC_LPR, saved_lpr)
+#define at91_standby at91rm9200_standby
 
 #elif defined(CONFIG_ARCH_AT91SAM9G45)
 #include <mach/at91sam9_ddrsdr.h>
@@ -42,14 +50,12 @@ static inline u32 sdram_selfrefresh_enable(void)
 /* We manage both DDRAM/SDRAM controllers, we need more than one value to
  * remember.
  */
-static u32 saved_lpr1;
-
-static inline u32 sdram_selfrefresh_enable(void)
+static inline void at91sam9g45_standby(void)
 {
-	/* Those tow values allow us to delay self-refresh activation
+	/* Those two values allow us to delay self-refresh activation
 	 * to the maximum. */
 	u32 lpr0, lpr1;
-	u32 saved_lpr0;
+	u32 saved_lpr0, saved_lpr1;
 
 	saved_lpr1 = at91_ramc_read(1, AT91_DDRSDRC_LPR);
 	lpr1 = saved_lpr1 & ~AT91_DDRSDRC_LPCB;
@@ -63,14 +69,13 @@ static inline u32 sdram_selfrefresh_enable(void)
 	at91_ramc_write(0, AT91_DDRSDRC_LPR, lpr0);
 	at91_ramc_write(1, AT91_DDRSDRC_LPR, lpr1);
 
-	return saved_lpr0;
+	cpu_do_idle();
+
+	at91_ramc_write(0, AT91_DDRSDRC_LPR, saved_lpr0);
+	at91_ramc_write(1, AT91_DDRSDRC_LPR, saved_lpr1);
 }
 
-#define sdram_selfrefresh_disable(saved_lpr0)	\
-	do { \
-		at91_ramc_write(0, AT91_DDRSDRC_LPR, saved_lpr0); \
-		at91_ramc_write(1, AT91_DDRSDRC_LPR, saved_lpr1); \
-	} while (0)
+#define at91_standby at91sam9g45_standby
 
 #else
 #include <mach/at91sam9_sdramc.h>
@@ -83,7 +88,7 @@ static inline u32 sdram_selfrefresh_enable(void)
 #warning Assuming EB1 SDRAM controller is *NOT* used
 #endif
 
-static inline u32 sdram_selfrefresh_enable(void)
+static inline void at91sam9_standby(void)
 {
 	u32 saved_lpr, lpr;
 
@@ -92,11 +97,13 @@ static inline u32 sdram_selfrefresh_enable(void)
 	lpr = saved_lpr & ~AT91_SDRAMC_LPCB;
 	at91_ramc_write(0, AT91_SDRAMC_LPR, lpr |
 			AT91_SDRAMC_LPCB_SELF_REFRESH);
-	return saved_lpr;
+
+	cpu_do_idle();
+
+	at91_ramc_write(0, AT91_SDRAMC_LPR, saved_lpr);
 }
 
-#define sdram_selfrefresh_disable(saved_lpr) \
-	at91_ramc_write(0, AT91_SDRAMC_LPR, saved_lpr)
+#define at91_standby at91sam9_standby
 
 #endif
 

commit b59160f6c017bfe33d3483ed9a6120701644af8a
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Wed Jan 25 00:56:07 2012 +0100

    ARM: at91: remove wait_for_interrupt definition
    
    All the "wait_for_interrupt" definition are aliases to cpu_do_idle.
    Only the rm9200 has an asm routine to switch to wfi. But the cpu_do_idle
    for this platform has exactly the same asm routine.
    
    arch/arm/mm/proc-arm920.S
    ..
    ENTRY(cpu_arm920_do_idle)
            mcr     p15, 0, r0, c7, c0, 4           @ Wait for interrupt
    ..
    
    Then it is safe to invoke cpu_do_idle for this platform. As all the
    wait_for_interrupts are definition for cpu_do_idle, let's remove it
    and replace its invokation by cpu_do_idle.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 715813ed73e3..38f9a13ee794 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -36,10 +36,6 @@ static inline u32 sdram_selfrefresh_enable(void)
 #define sdram_selfrefresh_disable(saved_lpr) \
 	at91_sys_write(AT91_SDRAMC_LPR, saved_lpr)
 
-#define wait_for_interrupt_enable() \
-	asm volatile ("mcr p15, 0, %0, c7, c0, 4" \
-		      : : "r" (0))
-
 #elif defined(CONFIG_ARCH_AT91SAM9G45)
 #include <mach/at91sam9_ddrsdr.h>
 
@@ -76,8 +72,6 @@ static inline u32 sdram_selfrefresh_enable(void)
 		at91_ramc_write(1, AT91_DDRSDRC_LPR, saved_lpr1); \
 	} while (0)
 
-#define wait_for_interrupt_enable()		cpu_do_idle()
-
 #else
 #include <mach/at91sam9_sdramc.h>
 
@@ -104,9 +98,6 @@ static inline u32 sdram_selfrefresh_enable(void)
 #define sdram_selfrefresh_disable(saved_lpr) \
 	at91_ramc_write(0, AT91_SDRAMC_LPR, saved_lpr)
 
-#define wait_for_interrupt_enable() \
-	cpu_do_idle()
-
 #endif
 
 #endif

commit fa50ae9c100225964eafc7214c70a8c08e70e50e
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Wed Jan 25 00:56:06 2012 +0100

    ARM: at91: declare header name
    
    Add the header and define the macro to prevent multiple inclusion
    like the others headers.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index caac65f39838..715813ed73e3 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -1,3 +1,16 @@
+/*
+ * AT91 Power Management
+ *
+ * Copyright (C) 2005 David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#ifndef __ARCH_ARM_MACH_AT91_PM
+#define __ARCH_ARM_MACH_AT91_PM
+
 #ifdef CONFIG_ARCH_AT91RM9200
 #include <mach/at91rm9200_mc.h>
 
@@ -95,3 +108,5 @@ static inline u32 sdram_selfrefresh_enable(void)
 	cpu_do_idle()
 
 #endif
+
+#endif

commit c54b7bbbd25600007d452909e6fac39fd36bbc98
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Wed Jan 25 00:56:05 2012 +0100

    ARM: at91: coding style fixes
    
    This patch is mindless and does only fix the line length.
    The purpose is to facilitate the review of the next patches.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 218d816427c0..caac65f39838 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -20,9 +20,12 @@ static inline u32 sdram_selfrefresh_enable(void)
 	return saved_lpr;
 }
 
-#define sdram_selfrefresh_disable(saved_lpr)	at91_sys_write(AT91_SDRAMC_LPR, saved_lpr)
-#define wait_for_interrupt_enable()		asm volatile ("mcr p15, 0, %0, c7, c0, 4" \
-								: : "r" (0))
+#define sdram_selfrefresh_disable(saved_lpr) \
+	at91_sys_write(AT91_SDRAMC_LPR, saved_lpr)
+
+#define wait_for_interrupt_enable() \
+	asm volatile ("mcr p15, 0, %0, c7, c0, 4" \
+		      : : "r" (0))
 
 #elif defined(CONFIG_ARCH_AT91SAM9G45)
 #include <mach/at91sam9_ddrsdr.h>
@@ -59,6 +62,7 @@ static inline u32 sdram_selfrefresh_enable(void)
 		at91_ramc_write(0, AT91_DDRSDRC_LPR, saved_lpr0); \
 		at91_ramc_write(1, AT91_DDRSDRC_LPR, saved_lpr1); \
 	} while (0)
+
 #define wait_for_interrupt_enable()		cpu_do_idle()
 
 #else
@@ -79,11 +83,15 @@ static inline u32 sdram_selfrefresh_enable(void)
 	saved_lpr = at91_ramc_read(0, AT91_SDRAMC_LPR);
 
 	lpr = saved_lpr & ~AT91_SDRAMC_LPCB;
-	at91_ramc_write(0, AT91_SDRAMC_LPR, lpr | AT91_SDRAMC_LPCB_SELF_REFRESH);
+	at91_ramc_write(0, AT91_SDRAMC_LPR, lpr |
+			AT91_SDRAMC_LPCB_SELF_REFRESH);
 	return saved_lpr;
 }
 
-#define sdram_selfrefresh_disable(saved_lpr)	at91_ramc_write(0, AT91_SDRAMC_LPR, saved_lpr)
-#define wait_for_interrupt_enable()		cpu_do_idle()
+#define sdram_selfrefresh_disable(saved_lpr) \
+	at91_ramc_write(0, AT91_SDRAMC_LPR, saved_lpr)
+
+#define wait_for_interrupt_enable() \
+	cpu_do_idle()
 
 #endif

commit 9918ceafd4a9e013572e03983f528017c29bb1cb
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Thu Jan 26 14:07:09 2012 +0100

    ARM: at91: code removal of CAP9 SoC
    
    Following removal announce and addition to feature-removal-schedule.txt,
    here is the actual source code deletion for Atmel CAP9 family.
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 7eb40d24242f..218d816427c0 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -24,24 +24,6 @@ static inline u32 sdram_selfrefresh_enable(void)
 #define wait_for_interrupt_enable()		asm volatile ("mcr p15, 0, %0, c7, c0, 4" \
 								: : "r" (0))
 
-#elif defined(CONFIG_ARCH_AT91CAP9)
-#include <mach/at91sam9_ddrsdr.h>
-
-
-static inline u32 sdram_selfrefresh_enable(void)
-{
-	u32 saved_lpr, lpr;
-
-	saved_lpr = at91_ramc_read(0, AT91CAP9_DDRSDRC_LPR);
-
-	lpr = saved_lpr & ~AT91_DDRSDRC_LPCB;
-	at91_ramc_write(0, AT91CAP9_DDRSDRC_LPR, lpr | AT91_DDRSDRC_LPCB_SELF_REFRESH);
-	return saved_lpr;
-}
-
-#define sdram_selfrefresh_disable(saved_lpr)	at91_ramc_write(0, AT91CAP9_DDRSDRC_LPR, saved_lpr)
-#define wait_for_interrupt_enable()		cpu_do_idle()
-
 #elif defined(CONFIG_ARCH_AT91SAM9G45)
 #include <mach/at91sam9_ddrsdr.h>
 

commit 17d2cc25f04462fd5d835318f02fb5492576ab4b
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Fri Nov 18 00:36:21 2011 +0800

    ARM: at91: merge at91cap9_ddrsdr.h in at91sam9_ddrsdr.h
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index ce9a20699111..7eb40d24242f 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -25,21 +25,21 @@ static inline u32 sdram_selfrefresh_enable(void)
 								: : "r" (0))
 
 #elif defined(CONFIG_ARCH_AT91CAP9)
-#include <mach/at91cap9_ddrsdr.h>
+#include <mach/at91sam9_ddrsdr.h>
 
 
 static inline u32 sdram_selfrefresh_enable(void)
 {
 	u32 saved_lpr, lpr;
 
-	saved_lpr = at91_ramc_read(0, AT91_DDRSDRC_LPR);
+	saved_lpr = at91_ramc_read(0, AT91CAP9_DDRSDRC_LPR);
 
 	lpr = saved_lpr & ~AT91_DDRSDRC_LPCB;
-	at91_ramc_write(0, AT91_DDRSDRC_LPR, lpr | AT91_DDRSDRC_LPCB_SELF_REFRESH);
+	at91_ramc_write(0, AT91CAP9_DDRSDRC_LPR, lpr | AT91_DDRSDRC_LPCB_SELF_REFRESH);
 	return saved_lpr;
 }
 
-#define sdram_selfrefresh_disable(saved_lpr)	at91_ramc_write(0, AT91_DDRSDRC_LPR, saved_lpr)
+#define sdram_selfrefresh_disable(saved_lpr)	at91_ramc_write(0, AT91CAP9_DDRSDRC_LPR, saved_lpr)
 #define wait_for_interrupt_enable()		cpu_do_idle()
 
 #elif defined(CONFIG_ARCH_AT91SAM9G45)

commit a2a571b74a3881963d8d09deb272d13afe5b49e3
Author: Nicolas Ferre <nicolas.ferre@atmel.com>
Date:   Fri Oct 22 18:55:39 2010 +0200

    AT91: pm: make sure that r0 is 0 when dealing with cache operations
    
    When using CP15 cache operations (c7), we make sure that Rd (r0)
    is actually 0 as ARM 926 TRM is saying.
    
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 2c4424bfa6c4..ce9a20699111 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -21,7 +21,8 @@ static inline u32 sdram_selfrefresh_enable(void)
 }
 
 #define sdram_selfrefresh_disable(saved_lpr)	at91_sys_write(AT91_SDRAMC_LPR, saved_lpr)
-#define wait_for_interrupt_enable()		asm("mcr p15, 0, r0, c7, c0, 4")
+#define wait_for_interrupt_enable()		asm volatile ("mcr p15, 0, %0, c7, c0, 4" \
+								: : "r" (0))
 
 #elif defined(CONFIG_ARCH_AT91CAP9)
 #include <mach/at91cap9_ddrsdr.h>

commit 8aeeda822fbfe7da2d4ea391a9757e9532796598
Author: Nicolas Ferre <nicolas.ferre@atmel.com>
Date:   Fri Oct 22 17:53:39 2010 +0200

    AT91: pm: use plain cpu_do_idle() for "wait for interrupt"
    
    For power management at91_pm_enter() routine, use the cpu_do_idle() for a
    rock solid "wait for interrupt" implementation.
    For AT91SAM9 ARM 926 based chips, we can exceed the cache line length as
    we can access RAM even while in self-refresh mode.
    We keep plain access to CP15 for at91rm9200 as this feature is not
    available: instructions have to be in a single cache line.
    
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 8c87d0c1b8f8..2c4424bfa6c4 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -21,6 +21,7 @@ static inline u32 sdram_selfrefresh_enable(void)
 }
 
 #define sdram_selfrefresh_disable(saved_lpr)	at91_sys_write(AT91_SDRAMC_LPR, saved_lpr)
+#define wait_for_interrupt_enable()		asm("mcr p15, 0, r0, c7, c0, 4")
 
 #elif defined(CONFIG_ARCH_AT91CAP9)
 #include <mach/at91cap9_ddrsdr.h>
@@ -38,6 +39,7 @@ static inline u32 sdram_selfrefresh_enable(void)
 }
 
 #define sdram_selfrefresh_disable(saved_lpr)	at91_ramc_write(0, AT91_DDRSDRC_LPR, saved_lpr)
+#define wait_for_interrupt_enable()		cpu_do_idle()
 
 #elif defined(CONFIG_ARCH_AT91SAM9G45)
 #include <mach/at91sam9_ddrsdr.h>
@@ -74,6 +76,7 @@ static inline u32 sdram_selfrefresh_enable(void)
 		at91_ramc_write(0, AT91_DDRSDRC_LPR, saved_lpr0); \
 		at91_ramc_write(1, AT91_DDRSDRC_LPR, saved_lpr1); \
 	} while (0)
+#define wait_for_interrupt_enable()		cpu_do_idle()
 
 #else
 #include <mach/at91sam9_sdramc.h>
@@ -98,5 +101,6 @@ static inline u32 sdram_selfrefresh_enable(void)
 }
 
 #define sdram_selfrefresh_disable(saved_lpr)	at91_ramc_write(0, AT91_SDRAMC_LPR, saved_lpr)
+#define wait_for_interrupt_enable()		cpu_do_idle()
 
 #endif

commit 7dca3343fc5ae5af2fa9248057cd65077a5576e1
Author: Nicolas Ferre <nicolas.ferre@atmel.com>
Date:   Mon Jun 21 14:59:27 2010 +0100

    ARM: 6185/1: AT91: PM: dual ram controller support
    
    This rework allows to address tow memory controllers. AT91SAM9263 and
    AT91SAM9G45 family have tow SDRAM or DDR/SDRAM controllers. Power management
    should take care of this.
    This patch modify the way RAM IP header files are implemented to allow
    access to registers of both controllers ; it also adds some macros.
    
    We also modify the power management files to use those modified header files.
    Slow clock (assembly) and regular power management functions are synchronized
    for setting of RAM self-refresh procedure:
    (lpr & ~AT91_DDRSDRC_LPCB) | AT91_DDRSDRC_LPCB_SELF_REFRESH
    
    Note that AT91RM9200 is not impacted by this modification.
    
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Acked-by: Andrew Victor <linux@maxim.org.za>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
index 08322c44df1a..8c87d0c1b8f8 100644
--- a/arch/arm/mach-at91/pm.h
+++ b/arch/arm/mach-at91/pm.h
@@ -30,14 +30,50 @@ static inline u32 sdram_selfrefresh_enable(void)
 {
 	u32 saved_lpr, lpr;
 
-	saved_lpr = at91_sys_read(AT91_DDRSDRC_LPR);
+	saved_lpr = at91_ramc_read(0, AT91_DDRSDRC_LPR);
 
 	lpr = saved_lpr & ~AT91_DDRSDRC_LPCB;
-	at91_sys_write(AT91_DDRSDRC_LPR, lpr | AT91_DDRSDRC_LPCB_SELF_REFRESH);
+	at91_ramc_write(0, AT91_DDRSDRC_LPR, lpr | AT91_DDRSDRC_LPCB_SELF_REFRESH);
 	return saved_lpr;
 }
 
-#define sdram_selfrefresh_disable(saved_lpr)	at91_sys_write(AT91_DDRSDRC_LPR, saved_lpr)
+#define sdram_selfrefresh_disable(saved_lpr)	at91_ramc_write(0, AT91_DDRSDRC_LPR, saved_lpr)
+
+#elif defined(CONFIG_ARCH_AT91SAM9G45)
+#include <mach/at91sam9_ddrsdr.h>
+
+/* We manage both DDRAM/SDRAM controllers, we need more than one value to
+ * remember.
+ */
+static u32 saved_lpr1;
+
+static inline u32 sdram_selfrefresh_enable(void)
+{
+	/* Those tow values allow us to delay self-refresh activation
+	 * to the maximum. */
+	u32 lpr0, lpr1;
+	u32 saved_lpr0;
+
+	saved_lpr1 = at91_ramc_read(1, AT91_DDRSDRC_LPR);
+	lpr1 = saved_lpr1 & ~AT91_DDRSDRC_LPCB;
+	lpr1 |= AT91_DDRSDRC_LPCB_SELF_REFRESH;
+
+	saved_lpr0 = at91_ramc_read(0, AT91_DDRSDRC_LPR);
+	lpr0 = saved_lpr0 & ~AT91_DDRSDRC_LPCB;
+	lpr0 |= AT91_DDRSDRC_LPCB_SELF_REFRESH;
+
+	/* self-refresh mode now */
+	at91_ramc_write(0, AT91_DDRSDRC_LPR, lpr0);
+	at91_ramc_write(1, AT91_DDRSDRC_LPR, lpr1);
+
+	return saved_lpr0;
+}
+
+#define sdram_selfrefresh_disable(saved_lpr0)	\
+	do { \
+		at91_ramc_write(0, AT91_DDRSDRC_LPR, saved_lpr0); \
+		at91_ramc_write(1, AT91_DDRSDRC_LPR, saved_lpr1); \
+	} while (0)
 
 #else
 #include <mach/at91sam9_sdramc.h>
@@ -47,7 +83,6 @@ static inline u32 sdram_selfrefresh_enable(void)
  * FIXME either or both the SDRAM controllers (EB0, EB1) might be in use;
  * handle those cases both here and in the Suspend-To-RAM support.
  */
-#define	AT91_SDRAMC	AT91_SDRAMC0
 #warning Assuming EB1 SDRAM controller is *NOT* used
 #endif
 
@@ -55,13 +90,13 @@ static inline u32 sdram_selfrefresh_enable(void)
 {
 	u32 saved_lpr, lpr;
 
-	saved_lpr = at91_sys_read(AT91_SDRAMC_LPR);
+	saved_lpr = at91_ramc_read(0, AT91_SDRAMC_LPR);
 
 	lpr = saved_lpr & ~AT91_SDRAMC_LPCB;
-	at91_sys_write(AT91_SDRAMC_LPR, lpr | AT91_SDRAMC_LPCB_SELF_REFRESH);
+	at91_ramc_write(0, AT91_SDRAMC_LPR, lpr | AT91_SDRAMC_LPCB_SELF_REFRESH);
 	return saved_lpr;
 }
 
-#define sdram_selfrefresh_disable(saved_lpr)	at91_sys_write(AT91_SDRAMC_LPR, saved_lpr)
+#define sdram_selfrefresh_disable(saved_lpr)	at91_ramc_write(0, AT91_SDRAMC_LPR, saved_lpr)
 
 #endif

commit 1ea60cf7062271f0d53d09268726aa1544bf4836
Author: Albin Tonnerre <albin.tonnerre@free-electrons.com>
Date:   Sun Nov 1 18:40:50 2009 +0100

    ARM: 5778/1: AT91: Add cpuidle support
    
    This patch adds the support for cpuidle on AT91 SoCs, taken from the
    cpuidle support in mach-kirkwood.
    cpuidle needs sdram_selfrefresh_enable and _disable, so move their
    definition to a separate header file instead of duplicating the code
    already used in pm.c.
    
    Tested-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Albin Tonnerre <albin.tonnerre@free-electrons.com>
    Acked-by: Andrew Victor <linux@maxim.org.za>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h
new file mode 100644
index 000000000000..08322c44df1a
--- /dev/null
+++ b/arch/arm/mach-at91/pm.h
@@ -0,0 +1,67 @@
+#ifdef CONFIG_ARCH_AT91RM9200
+#include <mach/at91rm9200_mc.h>
+
+/*
+ * The AT91RM9200 goes into self-refresh mode with this command, and will
+ * terminate self-refresh automatically on the next SDRAM access.
+ *
+ * Self-refresh mode is exited as soon as a memory access is made, but we don't
+ * know for sure when that happens. However, we need to restore the low-power
+ * mode if it was enabled before going idle. Restoring low-power mode while
+ * still in self-refresh is "not recommended", but seems to work.
+ */
+
+static inline u32 sdram_selfrefresh_enable(void)
+{
+	u32 saved_lpr = at91_sys_read(AT91_SDRAMC_LPR);
+
+	at91_sys_write(AT91_SDRAMC_LPR, 0);
+	at91_sys_write(AT91_SDRAMC_SRR, 1);
+	return saved_lpr;
+}
+
+#define sdram_selfrefresh_disable(saved_lpr)	at91_sys_write(AT91_SDRAMC_LPR, saved_lpr)
+
+#elif defined(CONFIG_ARCH_AT91CAP9)
+#include <mach/at91cap9_ddrsdr.h>
+
+
+static inline u32 sdram_selfrefresh_enable(void)
+{
+	u32 saved_lpr, lpr;
+
+	saved_lpr = at91_sys_read(AT91_DDRSDRC_LPR);
+
+	lpr = saved_lpr & ~AT91_DDRSDRC_LPCB;
+	at91_sys_write(AT91_DDRSDRC_LPR, lpr | AT91_DDRSDRC_LPCB_SELF_REFRESH);
+	return saved_lpr;
+}
+
+#define sdram_selfrefresh_disable(saved_lpr)	at91_sys_write(AT91_DDRSDRC_LPR, saved_lpr)
+
+#else
+#include <mach/at91sam9_sdramc.h>
+
+#ifdef CONFIG_ARCH_AT91SAM9263
+/*
+ * FIXME either or both the SDRAM controllers (EB0, EB1) might be in use;
+ * handle those cases both here and in the Suspend-To-RAM support.
+ */
+#define	AT91_SDRAMC	AT91_SDRAMC0
+#warning Assuming EB1 SDRAM controller is *NOT* used
+#endif
+
+static inline u32 sdram_selfrefresh_enable(void)
+{
+	u32 saved_lpr, lpr;
+
+	saved_lpr = at91_sys_read(AT91_SDRAMC_LPR);
+
+	lpr = saved_lpr & ~AT91_SDRAMC_LPCB;
+	at91_sys_write(AT91_SDRAMC_LPR, lpr | AT91_SDRAMC_LPCB_SELF_REFRESH);
+	return saved_lpr;
+}
+
+#define sdram_selfrefresh_disable(saved_lpr)	at91_sys_write(AT91_SDRAMC_LPR, saved_lpr)
+
+#endif
