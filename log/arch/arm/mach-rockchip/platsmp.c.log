commit 0b973c65d2f2da049252bc8370e4cf037b99c7e9
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Jan 23 00:48:07 2020 +0000

    ARM: rockchip: fix spelling mistake "to" -> "too"
    
    There is a spelling mistake in a pr_err message. Fix it.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Link: https://lore.kernel.org/r/20200123004807.2833556-1-colin.king@canonical.com
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index 649e0a54784c..d60856898d97 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -180,7 +180,7 @@ static int __init rockchip_smp_prepare_sram(struct device_node *node)
 
 	rsize = resource_size(&res);
 	if (rsize < trampoline_sz) {
-		pr_err("%s: reserved block with size 0x%x is to small for trampoline size 0x%x\n",
+		pr_err("%s: reserved block with size 0x%x is too small for trampoline size 0x%x\n",
 		       __func__, rsize, trampoline_sz);
 		return -EINVAL;
 	}

commit 4ab3a3e7e8ba63739bd2b1f6a0372b9534449078
Merge: 449c1cd29777 c2af88f1a0cd
Author: Olof Johansson <olof@lixom.net>
Date:   Mon Jun 17 05:14:24 2019 -0700

    Merge tag 'v5.3-rockchip-soc32-1' of git://git.kernel.org/pub/scm/linux/kernel/git/mmind/linux-rockchip into arm/soc
    
    Another missing of_node_put
    
    * tag 'v5.3-rockchip-soc32-1' of git://git.kernel.org/pub/scm/linux/kernel/git/mmind/linux-rockchip:
      ARM: rockchip: fix missing of_node_put calls in smp code
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index 4675d9202000..909fffee0240 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -1,16 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2013 MundoReader S.L.
  * Author: Heiko Stuebner <heiko@sntech.de>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #include <linux/delay.h>

commit c2af88f1a0cdf4cbe94b51fd93e52a3f55606a13
Author: Wen Yang <wen.yang99@zte.com.cn>
Date:   Fri Apr 26 15:08:08 2019 +0800

    ARM: rockchip: fix missing of_node_put calls in smp code
    
    The call to of_get_next_child returns a node pointer with refcount
    incremented thus it must be explicitly decremented after the last
    usage.
    
    Detected by coccinelle with the following warnings:
    ./arch/arm/mach-rockchip/pm.c:269:2-8: ERROR: missing of_node_put; acquired a node pointer with refcount incremented on line 259, but without a corresponding object release within this function.
    ./arch/arm/mach-rockchip/pm.c:275:2-8: ERROR: missing of_node_put; acquired a node pointer with refcount incremented on line 259, but without a corresponding object release within this function
    ./arch/arm/mach-rockchip/platsmp.c:281:2-8: ERROR: missing of_node_put; acquired a node pointer with refcount incremented on line 272, but without a corresponding object release within this function.
    ./arch/arm/mach-rockchip/platsmp.c:285:2-8: ERROR: missing of_node_put; acquired a node pointer with refcount incremented on line 272, but without a corresponding object release within this function.
    ./arch/arm/mach-rockchip/platsmp.c:289:3-9: ERROR: missing of_node_put; acquired a node pointer with refcount incremented on line 272, but without a corresponding object release within this function.
    ./arch/arm/mach-rockchip/platsmp.c:303:3-9: ERROR: missing of_node_put; acquired a node pointer with refcount incremented on line 294, but without a corresponding object release within this function.
    
    Signed-off-by: Wen Yang <wen.yang99@zte.com.cn>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Suggested-by: Heiko Stuebner <heiko@sntech.de>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index 4675d9202000..afd15147fdd4 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -278,19 +278,25 @@ static void __init rockchip_smp_prepare_cpus(unsigned int max_cpus)
 	sram_base_addr = of_iomap(node, 0);
 	if (!sram_base_addr) {
 		pr_err("%s: could not map sram registers\n", __func__);
+		of_node_put(node);
 		return;
 	}
 
-	if (has_pmu && rockchip_smp_prepare_pmu())
+	if (has_pmu && rockchip_smp_prepare_pmu()) {
+		of_node_put(node);
 		return;
+	}
 
 	if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9) {
-		if (rockchip_smp_prepare_sram(node))
+		if (rockchip_smp_prepare_sram(node)) {
+			of_node_put(node);
 			return;
+		}
 
 		/* enable the SCU power domain */
 		pmu_set_power_domain(PMU_PWRDN_SCU, true);
 
+		of_node_put(node);
 		node = of_find_compatible_node(NULL, NULL, "arm,cortex-a9-scu");
 		if (!node) {
 			pr_err("%s: missing scu\n", __func__);
@@ -300,6 +306,7 @@ static void __init rockchip_smp_prepare_cpus(unsigned int max_cpus)
 		scu_base_addr = of_iomap(node, 0);
 		if (!scu_base_addr) {
 			pr_err("%s: could not map scu registers\n", __func__);
+			of_node_put(node);
 			return;
 		}
 
@@ -318,6 +325,7 @@ static void __init rockchip_smp_prepare_cpus(unsigned int max_cpus)
 		asm ("mrc p15, 1, %0, c9, c0, 2\n" : "=r" (l2ctlr));
 		ncores = ((l2ctlr >> 24) & 0x3) + 1;
 	}
+	of_node_put(node);
 
 	/* Make sure that all cores except the first are really off */
 	for (i = 1; i < ncores; i++)

commit fbd7af041586a15f5dc15b9ec051d25aa5ebe00a
Author: Wen Yang <wen.yang99@zte.com.cn>
Date:   Tue Mar 5 19:32:56 2019 +0800

    ARM: rockchip: add missing of_node_put in rockchip_smp_prepare_pmu
    
    The call to of_get_next_child returns a node pointer with refcount
    incremented thus it must be explicitly decremented after the last
    usage.
    
    Detected by coccinelle with the following warnings:
    ./arch/arm/mach-rockchip/platsmp.c:250:2-8: ERROR: missing of_node_put; acquired a node pointer with refcount incremented on line 241, but without a corresponding object release within this function.
    ./arch/arm/mach-rockchip/platsmp.c:260:2-8: ERROR: missing of_node_put; acquired a node pointer with refcount incremented on line 241, but without a corresponding object release within this function.
    ./arch/arm/mach-rockchip/platsmp.c:263:1-7: ERROR: missing of_node_put; acquired a node pointer with refcount incremented on line 241, but without a corresponding object release within this function.
    
    Signed-off-by: Wen Yang <wen.yang99@zte.com.cn>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index 51984a40b097..4675d9202000 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -245,6 +245,7 @@ static int __init rockchip_smp_prepare_pmu(void)
 	}
 
 	pmu_base = of_iomap(node, 0);
+	of_node_put(node);
 	if (!pmu_base) {
 		pr_err("%s: could not map pmu registers\n", __func__);
 		return -ENOMEM;

commit 03151b8989257bfcee6cfd5f06d9a4a06b781cf3
Author: Jeffy Chen <jeffy.chen@rock-chips.com>
Date:   Mon Mar 12 17:51:42 2018 +0800

    ARM: rockchip: Set name of pmu regmap_config in smp code
    
    We are now allowing to register debugfs without a valid device, and not
    having a valid name will end up using "dummy*" to create debugfs dir.
    
    Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index ecec340ca345..51984a40b097 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -208,6 +208,7 @@ static int __init rockchip_smp_prepare_sram(struct device_node *node)
 }
 
 static const struct regmap_config rockchip_pmu_regmap_config = {
+	.name = "rockchip-pmu",
 	.reg_bits = 32,
 	.val_bits = 32,
 	.reg_stride = 4,

commit 9ec83463d679a51560135ac8cf023567fbb6e4c0
Merge: a93fae750d46 2ad93fa37fdd
Author: Olof Johansson <olof@lixom.net>
Date:   Tue Sep 5 20:29:46 2017 -0700

    Merge branch 'next/cleanup' into next/soc
    
    * next/cleanup:
      soc: versatile: remove unnecessary static in realview_soc_probe()
      ARM: Convert to using %pOF instead of full_name
      ARM: hisi: Fix typo in comment
      ARM: OMAP4+: PRM: fix of_irq_get() result checks
      ARM: OMAP3+: PRM: fix of_irq_get() result check
      ARM: dts: dra72-evm-revc: workaround incorrect DP83867 RX_CTRL pin strap
      ARM: dts: dra71-evm: workaround incorrect DP83867 RX_CTRL pin strap
      ARM: OMAP2+: omap_device: drop broken RPM status update from suspend_noirq
      bus: omap-ocp2scp: Fix error handling in omap_ocp2scp_probe

commit a8e65e06ec66f8657795162c51ee73bec116a890
Author: Rob Herring <robh@kernel.org>
Date:   Fri Jul 21 14:28:32 2017 -0500

    ARM: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Acked-by: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Javier Martinez Canillas <javier@osg.samsung.com>
    Cc: Fabio Estevam <fabio.estevam@nxp.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: "Beno√Æt Cousson" <bcousson@baylibre.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index 3abafdbdd7f4..2b5b0e43d657 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -182,8 +182,8 @@ static int __init rockchip_smp_prepare_sram(struct device_node *node)
 
 	ret = of_address_to_resource(node, 0, &res);
 	if (ret < 0) {
-		pr_err("%s: could not get address for node %s\n",
-		       __func__, node->full_name);
+		pr_err("%s: could not get address for node %pOF\n",
+		       __func__, node);
 		return ret;
 	}
 

commit da45adf97f57a561fc290e7cdd3a3dcb184cc88e
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Wed Jul 19 17:25:05 2017 +0200

    ARM: rockchip: explicitly request exclusive reset control in smp code
    
    Commit a53e35db70d1 ("reset: Ensure drivers are explicit when requesting
    reset lines") started to transition the reset control request API calls
    to explicitly state whether the driver needs exclusive or shared reset
    control behavior. Convert all drivers requesting exclusive resets to the
    explicit API call so the temporary transition helpers can be removed.
    
    No functional changes.
    
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: linux-rockchip@lists.infradead.org
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index 3abafdbdd7f4..420ba6765223 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -67,7 +67,7 @@ static struct reset_control *rockchip_get_core_reset(int cpu)
 	else
 		np = of_get_cpu_node(cpu, NULL);
 
-	return of_reset_control_get(np, NULL);
+	return of_reset_control_get_exclusive(np, NULL);
 }
 
 static int pmu_set_power_domain(int pd, bool on)

commit 64fc2a947a9873700929ec0ef02b4654a04e0476
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sun Jan 15 03:59:29 2017 +0100

    ARM: 8641/1: treewide: Replace uses of virt_to_phys with __pa_symbol
    
    All low-level PM/SMP code using virt_to_phys() should actually use
    __pa_symbol() against kernel symbols. Update code where relevant to move
    away from virt_to_phys().
    
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Laura Abbott <labbott@redhat.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index 4d827a069d49..3abafdbdd7f4 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -156,7 +156,7 @@ static int rockchip_boot_secondary(unsigned int cpu, struct task_struct *idle)
 		 */
 		mdelay(1); /* ensure the cpus other than cpu0 to startup */
 
-		writel(virt_to_phys(secondary_startup), sram_base_addr + 8);
+		writel(__pa_symbol(secondary_startup), sram_base_addr + 8);
 		writel(0xDEADBEAF, sram_base_addr + 4);
 		dsb_sev();
 	}
@@ -195,7 +195,7 @@ static int __init rockchip_smp_prepare_sram(struct device_node *node)
 	}
 
 	/* set the boot function for the sram code */
-	rockchip_boot_fn = virt_to_phys(secondary_startup);
+	rockchip_boot_fn = __pa_symbol(secondary_startup);
 
 	/* copy the trampoline to sram, that runs during startup of the core */
 	memcpy(sram_base_addr, &rockchip_secondary_trampoline, trampoline_sz);

commit 26d5192953d88d6231d173281848a1c61f9e5d34
Author: Peter Griffin <peter.griffin@linaro.org>
Date:   Thu Mar 17 13:43:11 2016 +0000

    ARM: rockchip: Fix use of plain integer as NULL pointer
    
    This fixes the following sparse build warning:
    
         mach-rockchip/platsmp.c:68:43: Using plain integer as NULL pointer
    
    Signed-off-by: Peter Griffin <peter.griffin@linaro.org>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index d42a07e33482..4d827a069d49 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -65,7 +65,7 @@ static struct reset_control *rockchip_get_core_reset(int cpu)
 	if (dev)
 		np = dev->of_node;
 	else
-		np = of_get_cpu_node(cpu, 0);
+		np = of_get_cpu_node(cpu, NULL);
 
 	return of_reset_control_get(np, NULL);
 }

commit 8907dbaa363de87e5c6f48070e3d8b639477d5ba
Merge: 9cdac4a20a96 e32465429490
Author: Olof Johansson <olof@lixom.net>
Date:   Tue Dec 22 13:10:00 2015 -0800

    Merge branch 'treewide/cleanup' into next/soc
    
    Merge in cleanup to avoid internal conflicts with newly added code.
    
    * treewide/cleanup:
      ARM: use "depends on" for SoC configs instead of "if" after prompt
      ARM/clocksource: use automatic DT probing for ux500 PRCMU
      ARM: use const and __initconst for smp_operations
      ARM: hisi: do not export smp_operations structures
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 26dc88fbb937e61988d86af92ca57544cc2a2087
Author: Heiko Stuebner <heiko@sntech.de>
Date:   Fri Dec 4 18:04:44 2015 +0100

    ARM: rockchip: use const and __initconst for rk3036 smp_operations
    
    The newly added rk3036 smp operations missed the wholesale fixup from
    Masahiro Yamada. So fix that now.
    
    Reported-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index 5c138f9699f9..9a5b2e0502f3 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -351,7 +351,7 @@ static void rockchip_cpu_die(unsigned int cpu)
 }
 #endif
 
-static struct smp_operations rk3036_smp_ops __initdata = {
+static const struct smp_operations rk3036_smp_ops __initconst = {
 	.smp_prepare_cpus	= rk3036_smp_prepare_cpus,
 	.smp_boot_secondary	= rockchip_boot_secondary,
 #ifdef CONFIG_HOTPLUG_CPU

commit 75305275a721d33ae9abfaeed2817cec8b2fee9a
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 15 10:39:53 2015 +0900

    ARM: use const and __initconst for smp_operations
    
    These smp_operations structures are not over-written, so add "const"
    qualifier and replace __initdata with __initconst.
    
    Also, add "static" where it is possible.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Moritz Fischer <moritz.fischer@ettus.com>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org> # qcom part
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: Wei Xu <xuwei5@hisilicon.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Acked-by: Matthias Brugger <matthias.bgg@gmail.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index 3e7a4b761a95..938888fc55a1 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -340,7 +340,7 @@ static void rockchip_cpu_die(unsigned int cpu)
 }
 #endif
 
-static struct smp_operations rockchip_smp_ops __initdata = {
+static const struct smp_operations rockchip_smp_ops __initconst = {
 	.smp_prepare_cpus	= rockchip_smp_prepare_cpus,
 	.smp_boot_secondary	= rockchip_boot_secondary,
 #ifdef CONFIG_HOTPLUG_CPU

commit 9def7ccfe8d5b84d382cff83553dd6db72f61a23
Author: Heiko Stuebner <heiko@sntech.de>
Date:   Wed Nov 4 20:25:16 2015 +0800

    ARM: rockchip: add support smp for rk3036
    
    The dual-core Cortex A7 rk3036 is a bit special in that it does not allow
    to control the actual powerdomain of the cpu cores, while the rest of the
    smp-bringup like reset control and entry address handling stays the same.
    Its bigger sibling, the quad-core rk3128 again allows powerdomain control.
    
    So allow that case by introducing a separate smp-enable-method, that simply
    disables powerdomain handling in the common code.
    
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Tested-by: Xing Zheng <zhengxing@rock-chips.com>
    Acked-by: Rob Herring <robh@kernel.org>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index 3e7a4b761a95..5c138f9699f9 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -42,6 +42,7 @@ static int ncores;
 #define PMU_PWRDN_SCU		4
 
 static struct regmap *pmu;
+static int has_pmu = true;
 
 static int pmu_power_domain_is_on(int pd)
 {
@@ -89,20 +90,23 @@ static int pmu_set_power_domain(int pd, bool on)
 	if (!IS_ERR(rstc) && !on)
 		reset_control_assert(rstc);
 
-	ret = regmap_update_bits(pmu, PMU_PWRDN_CON, BIT(pd), val);
-	if (ret < 0) {
-		pr_err("%s: could not update power domain\n", __func__);
-		return ret;
-	}
-
-	ret = -1;
-	while (ret != on) {
-		ret = pmu_power_domain_is_on(pd);
+	if (has_pmu) {
+		ret = regmap_update_bits(pmu, PMU_PWRDN_CON, BIT(pd), val);
 		if (ret < 0) {
-			pr_err("%s: could not read power domain state\n",
+			pr_err("%s: could not update power domain\n",
 			       __func__);
 			return ret;
 		}
+
+		ret = -1;
+		while (ret != on) {
+			ret = pmu_power_domain_is_on(pd);
+			if (ret < 0) {
+				pr_err("%s: could not read power domain state\n",
+				       __func__);
+				return ret;
+			}
+		}
 	}
 
 	if (!IS_ERR(rstc)) {
@@ -122,7 +126,7 @@ static int rockchip_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	int ret;
 
-	if (!sram_base_addr || !pmu) {
+	if (!sram_base_addr || (has_pmu && !pmu)) {
 		pr_err("%s: sram or pmu missing for cpu boot\n", __func__);
 		return -ENXIO;
 	}
@@ -275,7 +279,7 @@ static void __init rockchip_smp_prepare_cpus(unsigned int max_cpus)
 		return;
 	}
 
-	if (rockchip_smp_prepare_pmu())
+	if (has_pmu && rockchip_smp_prepare_pmu())
 		return;
 
 	if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9) {
@@ -318,6 +322,13 @@ static void __init rockchip_smp_prepare_cpus(unsigned int max_cpus)
 		pmu_set_power_domain(0 + i, false);
 }
 
+static void __init rk3036_smp_prepare_cpus(unsigned int max_cpus)
+{
+	has_pmu = false;
+
+	rockchip_smp_prepare_cpus(max_cpus);
+}
+
 #ifdef CONFIG_HOTPLUG_CPU
 static int rockchip_cpu_kill(unsigned int cpu)
 {
@@ -340,6 +351,15 @@ static void rockchip_cpu_die(unsigned int cpu)
 }
 #endif
 
+static struct smp_operations rk3036_smp_ops __initdata = {
+	.smp_prepare_cpus	= rk3036_smp_prepare_cpus,
+	.smp_boot_secondary	= rockchip_boot_secondary,
+#ifdef CONFIG_HOTPLUG_CPU
+	.cpu_kill		= rockchip_cpu_kill,
+	.cpu_die		= rockchip_cpu_die,
+#endif
+};
+
 static struct smp_operations rockchip_smp_ops __initdata = {
 	.smp_prepare_cpus	= rockchip_smp_prepare_cpus,
 	.smp_boot_secondary	= rockchip_boot_secondary,
@@ -349,4 +369,5 @@ static struct smp_operations rockchip_smp_ops __initdata = {
 #endif
 };
 
+CPU_METHOD_OF_DECLARE(rk3036_smp, "rockchip,rk3036-smp", &rk3036_smp_ops);
 CPU_METHOD_OF_DECLARE(rk3066_smp, "rockchip,rk3066-smp", &rockchip_smp_ops);

commit cb8cc37f4d38d96552f2c52deb15e511cdacf906
Author: Caesar Wang <wxt@rock-chips.com>
Date:   Mon Jul 6 11:37:23 2015 +0800

    ARM: rockchip: fix broken build
    
    The following was seen in branch[0] build.
    
    arch/arm/mach-rockchip/platsmp.c:154:23: error:
        'rockchip_secondary_startup' undeclared (first use in this function)
    
    branch[0]:
    git://git.kernel.org/pub/scm/linux/kernel/git/mmind/linux-rockchip.git
    v4.3-armsoc/soc
    
    The broken build is caused by the commit fe4407c0dc58
    ("ARM: rockchip: fix the CPU soft reset").
    
    Signed-off-by: Caesar Wang <wxt@rock-chips.com>
    
    The breakage was a result of it being wrongly merged in my branch with
    the cache invalidation rework from Russell 02b4e2756e01c
    ("ARM: v7 setup function should invalidate L1 cache").
    
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index 7ebd1c1a98c6..3e7a4b761a95 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -152,8 +152,7 @@ static int rockchip_boot_secondary(unsigned int cpu, struct task_struct *idle)
 		 */
 		mdelay(1); /* ensure the cpus other than cpu0 to startup */
 
-		writel(virt_to_phys(rockchip_secondary_startup),
-		       sram_base_addr + 8);
+		writel(virt_to_phys(secondary_startup), sram_base_addr + 8);
 		writel(0xDEADBEAF, sram_base_addr + 4);
 		dsb_sev();
 	}

commit 7f0b61ad34f04b076a3d1e2b5cfc6e1fae853ec4
Author: Caesar Wang <wxt@rock-chips.com>
Date:   Tue Jun 9 17:49:59 2015 +0800

    ARM: rockchip: fix the SMP code style
    
    Use the below scripts to check:
    scripts/checkpatch.pl -f --subject arch/arm/mach-rockchip/platsmp.c
    
    Signed-off-by: Caesar Wang <wxt@rock-chips.com>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Kever Yang <kever.yang@rock-chips.com>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index 4187ac2b01b3..7ebd1c1a98c6 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -100,7 +100,7 @@ static int pmu_set_power_domain(int pd, bool on)
 		ret = pmu_power_domain_is_on(pd);
 		if (ret < 0) {
 			pr_err("%s: could not read power domain state\n",
-				 __func__);
+			       __func__);
 			return ret;
 		}
 	}
@@ -129,7 +129,7 @@ static int rockchip_boot_secondary(unsigned int cpu, struct task_struct *idle)
 
 	if (cpu >= ncores) {
 		pr_err("%s: cpu %d outside maximum number of cpus %d\n",
-							__func__, cpu, ncores);
+		       __func__, cpu, ncores);
 		return -ENXIO;
 	}
 
@@ -139,7 +139,8 @@ static int rockchip_boot_secondary(unsigned int cpu, struct task_struct *idle)
 		return ret;
 
 	if (read_cpuid_part() != ARM_CPU_PART_CORTEX_A9) {
-		/* We communicate with the bootrom to active the cpus other
+		/*
+		 * We communicate with the bootrom to active the cpus other
 		 * than cpu0, after a blob of initialize code, they will
 		 * stay at wfe state, once they are actived, they will check
 		 * the mailbox:
@@ -148,11 +149,11 @@ static int rockchip_boot_secondary(unsigned int cpu, struct task_struct *idle)
 		 * The cpu0 need to wait the other cpus other than cpu0 entering
 		 * the wfe state.The wait time is affected by many aspects.
 		 * (e.g: cpu frequency, bootrom frequency, sram frequency, ...)
-		 * */
+		 */
 		mdelay(1); /* ensure the cpus other than cpu0 to startup */
 
 		writel(virt_to_phys(rockchip_secondary_startup),
-			sram_base_addr + 8);
+		       sram_base_addr + 8);
 		writel(0xDEADBEAF, sram_base_addr + 4);
 		dsb_sev();
 	}
@@ -335,7 +336,7 @@ static int rockchip_cpu_kill(unsigned int cpu)
 static void rockchip_cpu_die(unsigned int cpu)
 {
 	v7_exit_coherency_flush(louis);
-	while(1)
+	while (1)
 		cpu_do_idle();
 }
 #endif
@@ -348,4 +349,5 @@ static struct smp_operations rockchip_smp_ops __initdata = {
 	.cpu_die		= rockchip_cpu_die,
 #endif
 };
+
 CPU_METHOD_OF_DECLARE(rk3066_smp, "rockchip,rk3066-smp", &rockchip_smp_ops);

commit e306bc16c53199e7440e1fee69dd91dc0a56edee
Author: Caesar Wang <wxt@rock-chips.com>
Date:   Tue Jun 9 17:49:58 2015 +0800

    ARM: rockchip: ensure CPU to enter WFI/WFE state
    
    The patch can ensure that v7_exit_coherency_flush() in rockchip_cpu_die()
    executed in time.
    The mdelay(1) has enough time to fix the problem of CPU offlining.
    That's a workaround way in rockchip hotplug code,
    At least, we haven't a better way to solve it. Who know,
    that maybe fixed by chip (hardware) in the future.
    
    Signed-off-by: Caesar Wang <wxt@rock-chips.com>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Kever Yang <kever.yang@rock-chips.com>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index d1a5fec68887..4187ac2b01b3 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -321,6 +321,13 @@ static void __init rockchip_smp_prepare_cpus(unsigned int max_cpus)
 #ifdef CONFIG_HOTPLUG_CPU
 static int rockchip_cpu_kill(unsigned int cpu)
 {
+	/*
+	 * We need a delay here to ensure that the dying CPU can finish
+	 * executing v7_coherency_exit() and reach the WFI/WFE state
+	 * prior to having the power domain disabled.
+	 */
+	mdelay(1);
+
 	pmu_set_power_domain(0 + cpu, false);
 	return 1;
 }

commit fe4407c0dc58215a7abfb7532740d79ddabe7a7a
Author: Caesar Wang <wxt@rock-chips.com>
Date:   Tue Jun 9 17:49:57 2015 +0800

    ARM: rockchip: fix the CPU soft reset
    
    We need different orderings when turning a core on and turning a core
    off.  In one case we need to assert reset before turning power off.
    In ther other case we need to turn power on and the deassert reset.
    
    In general, the correct flow is:
    
    CPU off:
        reset_control_assert
        regmap_update_bits(pmu, PMU_PWRDN_CON, BIT(pd), BIT(pd))
        wait_for_power_domain_to_turn_off
    CPU on:
        regmap_update_bits(pmu, PMU_PWRDN_CON, BIT(pd), 0)
        wait_for_power_domain_to_turn_on
        reset_control_deassert
    
    This is needed for stressing CPU up/down, as per:
        cd /sys/devices/system/cpu/
        for i in $(seq 10000); do
            echo "================= $i ============"
            for j in $(seq 100); do
                while [[ "$(cat cpu1/online)$(cat cpu2/online)$(cat cpu3/online)" != "000"" ]]
                    echo 0 > cpu1/online
                    echo 0 > cpu2/online
                    echo 0 > cpu3/online
                done
                while [[ "$(cat cpu1/online)$(cat cpu2/online)$(cat cpu3/online)" != "111" ]]; do
                    echo 1 > cpu1/online
                    echo 1 > cpu2/online
                    echo 1 > cpu3/online
                done
            done
        done
    
    The following is reproducable log:
        [34466.186812] PM: noirq suspend of devices complete after 0.669 msecs
        [34466.186824] Disabling non-boot CPUs ...
        [34466.187509] CPU1: shutdown
        [34466.188672] CPU2: shutdown
        [34473.736627] Kernel panic - not syncing:Watchdog detected hard LOCKUP on cpu 0
        .......
    or others similar log:
        .......
        [ 4072.454453] CPU1: shutdown
        [ 4072.504436] CPU2: shutdown
        [ 4072.554426] CPU3: shutdown
        [ 4072.577827] CPU1: Booted secondary processor
        [ 4072.582611] CPU2: Booted secondary processor
        <hang>
    
        Tested by cpu up/down scripts, the results told us need delay more time
    before write the sram. The wait time is affected by many aspects
    (e.g: cpu frequency, bootrom frequency, sram frequency, bus speed, ...).
    
        Although the cpus other than cpu0 will write the sram, the speedy is
    no the same as cpu0, if the cpu0 early wake up, perhaps the other cpus
    can't startup. As we know, the cpu0 can wake up when the cpu1/2/3 write
    the 'sram+4/8' and send the sev.
        Anyway.....
        At the moment, 1ms delay will be happy work for cpu up/down scripts test.
    
    Signed-off-by: Caesar Wang <wxt@rock-chips.com>
    Reviewed-by: Doug Anderson <dianders@chromium.org>
    Reviewed-by: Kever Yang <kever.yang@rock-chips.com>
    Fixes: 3ee851e212d0 ("ARM: rockchip: add basic smp support for rk3288")
    Cc: stable@vger.kernel.org
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index 8fcec1cc101e..d1a5fec68887 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -72,29 +72,22 @@ static struct reset_control *rockchip_get_core_reset(int cpu)
 static int pmu_set_power_domain(int pd, bool on)
 {
 	u32 val = (on) ? 0 : BIT(pd);
+	struct reset_control *rstc = rockchip_get_core_reset(pd);
 	int ret;
 
+	if (IS_ERR(rstc) && read_cpuid_part() != ARM_CPU_PART_CORTEX_A9) {
+		pr_err("%s: could not get reset control for core %d\n",
+		       __func__, pd);
+		return PTR_ERR(rstc);
+	}
+
 	/*
 	 * We need to soft reset the cpu when we turn off the cpu power domain,
 	 * or else the active processors might be stalled when the individual
 	 * processor is powered down.
 	 */
-	if (read_cpuid_part() != ARM_CPU_PART_CORTEX_A9) {
-		struct reset_control *rstc = rockchip_get_core_reset(pd);
-
-		if (IS_ERR(rstc)) {
-			pr_err("%s: could not get reset control for core %d\n",
-			       __func__, pd);
-			return PTR_ERR(rstc);
-		}
-
-		if (on)
-			reset_control_deassert(rstc);
-		else
-			reset_control_assert(rstc);
-
-		reset_control_put(rstc);
-	}
+	if (!IS_ERR(rstc) && !on)
+		reset_control_assert(rstc);
 
 	ret = regmap_update_bits(pmu, PMU_PWRDN_CON, BIT(pd), val);
 	if (ret < 0) {
@@ -112,6 +105,12 @@ static int pmu_set_power_domain(int pd, bool on)
 		}
 	}
 
+	if (!IS_ERR(rstc)) {
+		if (on)
+			reset_control_deassert(rstc);
+		reset_control_put(rstc);
+	}
+
 	return 0;
 }
 
@@ -146,9 +145,14 @@ static int rockchip_boot_secondary(unsigned int cpu, struct task_struct *idle)
 		 * the mailbox:
 		 * sram_base_addr + 4: 0xdeadbeaf
 		 * sram_base_addr + 8: start address for pc
+		 * The cpu0 need to wait the other cpus other than cpu0 entering
+		 * the wfe state.The wait time is affected by many aspects.
+		 * (e.g: cpu frequency, bootrom frequency, sram frequency, ...)
 		 * */
-		udelay(10);
-		writel(virt_to_phys(secondary_startup), sram_base_addr + 8);
+		mdelay(1); /* ensure the cpus other than cpu0 to startup */
+
+		writel(virt_to_phys(rockchip_secondary_startup),
+			sram_base_addr + 8);
 		writel(0xDEADBEAF, sram_base_addr + 4);
 		dsb_sev();
 	}

commit 47f92418c7916a71c985444100bfe68aed61e247
Merge: 4da3064d1775 22c1587adfed
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 2 09:54:14 2015 -0700

    Merge tag 'cpuinit-v4.1-rc8' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    Pull __cpuinit removal from Paul Gortmaker:
     "Remove __cpuinit macros and users.
    
      We removed the __cpuinit stuff in 3.11-rc1 with commit 22f0a2736774
      ("init.h: remove __cpuinit sections from the kernel") but we left some
      no-op stubs as a courtesy to unmerged code.
    
      Here we get rid of the stubs as well, since (as can be seen in these
      changes) they are enabling use cases to sneak back in, primarily from
      older BSP code that has been living out of tree for some time prior to
      getting mainlined.  So we get rid of these "new" users 1st and then
      get rid of the stubs.
    
      Obviously, getting rid of the stubs can't happen until all the users
      are gone, so I had to keep this together as a series, even though some
      of these commits since got picked up into maintainers trees as well.
    
      The nature of this change is such that it should have zero impact on
      the generated runtime.
    
      This is one of several independent cleanup branches aimed at enabling
      better organization in the init.h and module.h code.  They have been
      getting coverage in the linux-next tree for the last month, in
      addition to my local testing, which also covers approximately a half
      dozen or more architectures"
    
    * tag 'cpuinit-v4.1-rc8' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux:
      init: delete the __cpuinit related stubs
      kernel/cpu.c: remove new instance of __cpuinit that crept back in
      sched/core: remove __cpuinit section tag that crept back in.
      mips/mm/tlbex: remove new instance of __cpuinit that crept back in
      mips/c-r4k: remove legacy __cpuinit section that crept in
      mips/bcm77xx: remove legacy __cpuinit sections that crept in
      mips/ath25: remove legacy __cpuinit section that crept in
      arm/mach-hisi: remove legacy __CPUINIT section that crept in
      arm/mach-rockchip: remove legacy __cpuinit section that crept in
      arm/mach-mvebu: remove legacy __cpuinit sections that crept in
      arm/mach-keystone: remove legacy __cpuinit sections that crept in

commit 374d4dd3ef1a3ebac33a7df5f8f2e7b5fbd7ec05
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sat Jan 17 16:48:41 2015 -0500

    arm/mach-rockchip: remove legacy __cpuinit section that crept in
    
    We removed __cpuinit support (leaving no-op stubs) quite some time ago.
    However this one crept back in as of commit a7a2b3118b410fb3cd3a8363b1
    ("ARM: rockchip: add smp bringup code").
    
    Since we want to clobber the stubs soon, get this removed now.
    
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index 5b4ca3c3c879..fd2f0dc81015 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -119,8 +119,7 @@ static int pmu_set_power_domain(int pd, bool on)
  * Handling of CPU cores
  */
 
-static int __cpuinit rockchip_boot_secondary(unsigned int cpu,
-					     struct task_struct *idle)
+static int rockchip_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	int ret;
 

commit 02b4e2756e01c623cc4dbceae4b07be75252db5b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue May 19 17:06:44 2015 +0100

    ARM: v7 setup function should invalidate L1 cache
    
    All ARMv5 and older CPUs invalidate their caches in the early assembly
    setup function, prior to enabling the MMU.  This is because the L1
    cache should not contain any data relevant to the execution of the
    kernel at this point; all data should have been flushed out to memory.
    
    This requirement should also be true for ARMv6 and ARMv7 CPUs - indeed,
    these typically do not search their caches when caching is disabled (as
    it needs to be when the MMU is disabled) so this change should be safe.
    
    ARMv7 allows there to be CPUs which search their caches while caching is
    disabled, and it's permitted that the cache is uninitialised at boot;
    for these, the architecture reference manual requires that an
    implementation specific code sequence is used immediately after reset
    to ensure that the cache is placed into a sane state.  Such
    functionality is definitely outside the remit of the Linux kernel, and
    must be done by the SoC's firmware before _any_ CPU gets to the Linux
    kernel.
    
    Changing the data cache clean+invalidate to a mere invalidate allows us
    to get rid of a lot of platform specific hacks around this issue for
    their secondary CPU bringup paths - some of which were buggy.
    
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Tested-by: Florian Fainelli <f.fainelli@gmail.com>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Tested-by: Dinh Nguyen <dinguyen@opensource.altera.com>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Tested-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Acked-by: Shawn Guo <shawn.guo@linaro.org>
    Tested-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Tested-by: Michal Simek <michal.simek@xilinx.com>
    Tested-by: Wei Xu <xuwei5@hisilicon.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index 5b4ca3c3c879..2e6ab67e2284 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -149,8 +149,7 @@ static int __cpuinit rockchip_boot_secondary(unsigned int cpu,
 		 * sram_base_addr + 8: start address for pc
 		 * */
 		udelay(10);
-		writel(virt_to_phys(rockchip_secondary_startup),
-			sram_base_addr + 8);
+		writel(virt_to_phys(secondary_startup), sram_base_addr + 8);
 		writel(0xDEADBEAF, sram_base_addr + 4);
 		dsb_sev();
 	}
@@ -189,7 +188,7 @@ static int __init rockchip_smp_prepare_sram(struct device_node *node)
 	}
 
 	/* set the boot function for the sram code */
-	rockchip_boot_fn = virt_to_phys(rockchip_secondary_startup);
+	rockchip_boot_fn = virt_to_phys(secondary_startup);
 
 	/* copy the trampoline to sram, that runs during startup of the core */
 	memcpy(sram_base_addr, &rockchip_secondary_trampoline, trampoline_sz);

commit bd76d73836fa903d67eaabcb3a0201d2d0a73461
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Mon Mar 2 00:12:03 2015 +0100

    ARM: rockchip: Constify struct regmap_config and staticize local function
    
    The regmap_config struct may be const because it is not modified by the
    driver and regmap_init() accepts pointer to const.
    
    Make function rockchip_get_core_reset() static because it is not used
    outside of the platsmp.c file.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index f26fcdca2445..5b4ca3c3c879 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -55,7 +55,7 @@ static int pmu_power_domain_is_on(int pd)
 	return !(val & BIT(pd));
 }
 
-struct reset_control *rockchip_get_core_reset(int cpu)
+static struct reset_control *rockchip_get_core_reset(int cpu)
 {
 	struct device *dev = get_cpu_device(cpu);
 	struct device_node *np;
@@ -201,7 +201,7 @@ static int __init rockchip_smp_prepare_sram(struct device_node *node)
 	return 0;
 }
 
-static struct regmap_config rockchip_pmu_regmap_config = {
+static const struct regmap_config rockchip_pmu_regmap_config = {
 	.reg_bits = 32,
 	.val_bits = 32,
 	.reg_stride = 4,

commit 3ee851e212d0bb6be8c462059fba74ce2e3f6064
Author: Kever Yang <kever.yang@rock-chips.com>
Date:   Wed Oct 15 10:23:03 2014 -0700

    ARM: rockchip: add basic smp support for rk3288
    
    This patch add basic rk3288 smp support.
    
    Only cortex-A9 need invalid L1, A7/A12/A15/A17 should not invalid L1, since
    for A7/A12/A15, the invalidation would be taken as clean and invalidate.
    
    If you use the software manual invalidation instead of hardware invalidation
    (assert l1/l2rstdisable during reset) after reset, there is tiny change that
    some cachelines would be in dirty and valid state after reset(since the ram
    content would be random value after reset), then the unexpected clean might
    lead to system crash.
    
    It is a known issue for the A12/A17 MPCore multiprocessor that the active
    processors might be stalled when the individual processor is powered down,
    we can avoid this prolbem by softreset the processor before power it down.
    
    Signed-off-by: Kever Yang <kever.yang@rock-chips.com>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index 57b53b32e103..f26fcdca2445 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -22,6 +22,8 @@
 #include <linux/regmap.h>
 #include <linux/mfd/syscon.h>
 
+#include <linux/reset.h>
+#include <linux/cpu.h>
 #include <asm/cacheflush.h>
 #include <asm/cp15.h>
 #include <asm/smp_scu.h>
@@ -53,11 +55,47 @@ static int pmu_power_domain_is_on(int pd)
 	return !(val & BIT(pd));
 }
 
+struct reset_control *rockchip_get_core_reset(int cpu)
+{
+	struct device *dev = get_cpu_device(cpu);
+	struct device_node *np;
+
+	/* The cpu device is only available after the initial core bringup */
+	if (dev)
+		np = dev->of_node;
+	else
+		np = of_get_cpu_node(cpu, 0);
+
+	return of_reset_control_get(np, NULL);
+}
+
 static int pmu_set_power_domain(int pd, bool on)
 {
 	u32 val = (on) ? 0 : BIT(pd);
 	int ret;
 
+	/*
+	 * We need to soft reset the cpu when we turn off the cpu power domain,
+	 * or else the active processors might be stalled when the individual
+	 * processor is powered down.
+	 */
+	if (read_cpuid_part() != ARM_CPU_PART_CORTEX_A9) {
+		struct reset_control *rstc = rockchip_get_core_reset(pd);
+
+		if (IS_ERR(rstc)) {
+			pr_err("%s: could not get reset control for core %d\n",
+			       __func__, pd);
+			return PTR_ERR(rstc);
+		}
+
+		if (on)
+			reset_control_deassert(rstc);
+		else
+			reset_control_assert(rstc);
+
+		reset_control_put(rstc);
+	}
+
 	ret = regmap_update_bits(pmu, PMU_PWRDN_CON, BIT(pd), val);
 	if (ret < 0) {
 		pr_err("%s: could not update power domain\n", __func__);
@@ -84,6 +122,8 @@ static int pmu_set_power_domain(int pd, bool on)
 static int __cpuinit rockchip_boot_secondary(unsigned int cpu,
 					     struct task_struct *idle)
 {
+	int ret;
+
 	if (!sram_base_addr || !pmu) {
 		pr_err("%s: sram or pmu missing for cpu boot\n", __func__);
 		return -ENXIO;
@@ -96,7 +136,26 @@ static int __cpuinit rockchip_boot_secondary(unsigned int cpu,
 	}
 
 	/* start the core */
-	return pmu_set_power_domain(0 + cpu, true);
+	ret = pmu_set_power_domain(0 + cpu, true);
+	if (ret < 0)
+		return ret;
+
+	if (read_cpuid_part() != ARM_CPU_PART_CORTEX_A9) {
+		/* We communicate with the bootrom to active the cpus other
+		 * than cpu0, after a blob of initialize code, they will
+		 * stay at wfe state, once they are actived, they will check
+		 * the mailbox:
+		 * sram_base_addr + 4: 0xdeadbeaf
+		 * sram_base_addr + 8: start address for pc
+		 * */
+		udelay(10);
+		writel(virt_to_phys(rockchip_secondary_startup),
+			sram_base_addr + 8);
+		writel(0xDEADBEAF, sram_base_addr + 4);
+		dsb_sev();
+	}
+
+	return 0;
 }
 
 /**
@@ -129,8 +188,6 @@ static int __init rockchip_smp_prepare_sram(struct device_node *node)
 		return -EINVAL;
 	}
 
-	sram_base_addr = of_iomap(node, 0);
-
 	/* set the boot function for the sram code */
 	rockchip_boot_fn = virt_to_phys(rockchip_secondary_startup);
 
@@ -204,40 +261,55 @@ static void __init rockchip_smp_prepare_cpus(unsigned int max_cpus)
 	struct device_node *node;
 	unsigned int i;
 
-	node = of_find_compatible_node(NULL, NULL, "arm,cortex-a9-scu");
-	if (!node) {
-		pr_err("%s: missing scu\n", __func__);
-		return;
-	}
-
-	scu_base_addr = of_iomap(node, 0);
-	if (!scu_base_addr) {
-		pr_err("%s: could not map scu registers\n", __func__);
-		return;
-	}
-
 	node = of_find_compatible_node(NULL, NULL, "rockchip,rk3066-smp-sram");
 	if (!node) {
 		pr_err("%s: could not find sram dt node\n", __func__);
 		return;
 	}
 
-	if (rockchip_smp_prepare_sram(node))
+	sram_base_addr = of_iomap(node, 0);
+	if (!sram_base_addr) {
+		pr_err("%s: could not map sram registers\n", __func__);
 		return;
+	}
 
 	if (rockchip_smp_prepare_pmu())
 		return;
 
-	/* enable the SCU power domain */
-	pmu_set_power_domain(PMU_PWRDN_SCU, true);
+	if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9) {
+		if (rockchip_smp_prepare_sram(node))
+			return;
 
-	/*
-	 * While the number of cpus is gathered from dt, also get the number
-	 * of cores from the scu to verify this value when booting the cores.
-	 */
-	ncores = scu_get_core_count(scu_base_addr);
+		/* enable the SCU power domain */
+		pmu_set_power_domain(PMU_PWRDN_SCU, true);
+
+		node = of_find_compatible_node(NULL, NULL, "arm,cortex-a9-scu");
+		if (!node) {
+			pr_err("%s: missing scu\n", __func__);
+			return;
+		}
 
-	scu_enable(scu_base_addr);
+		scu_base_addr = of_iomap(node, 0);
+		if (!scu_base_addr) {
+			pr_err("%s: could not map scu registers\n", __func__);
+			return;
+		}
+
+		/*
+		 * While the number of cpus is gathered from dt, also get the
+		 * number of cores from the scu to verify this value when
+		 * booting the cores.
+		 */
+		ncores = scu_get_core_count(scu_base_addr);
+		pr_err("%s: ncores %d\n", __func__, ncores);
+
+		scu_enable(scu_base_addr);
+	} else {
+		unsigned int l2ctlr;
+
+		asm ("mrc p15, 1, %0, c9, c0, 2\n" : "=r" (l2ctlr));
+		ncores = ((l2ctlr >> 24) & 0x3) + 1;
+	}
 
 	/* Make sure that all cores except the first are really off */
 	for (i = 1; i < ncores; i++)

commit 6de2d21adaf05b7a456077625b6e311feabd3718
Author: Heiko Stuebner <heiko@sntech.de>
Date:   Wed Oct 15 10:23:01 2014 -0700

    ARM: rockchip: add option to access the pmu via a phandle in smp_operations
    
    Makes it possible to define a rockchip,pmu phandle in the cpus node directly
    referencing the pmu syscon instead of searching for specific compatible.
    
    The old way of finding the pmu stays of course available.
    
    Signed-off-by: Kever Yang <kever.yang@rock-chips.com>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index 4c36fbf99afb..57b53b32e103 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -155,6 +155,19 @@ static int __init rockchip_smp_prepare_pmu(void)
 	struct device_node *node;
 	void __iomem *pmu_base;
 
+	/*
+	 * This function is only called via smp_ops->smp_prepare_cpu().
+	 * That only happens if a "/cpus" device tree node exists
+	 * and has an "enable-method" property that selects the SMP
+	 * operations defined herein.
+	 */
+	node = of_find_node_by_path("/cpus");
+
+	pmu = syscon_regmap_lookup_by_phandle(node, "rockchip,pmu");
+	of_node_put(node);
+	if (!IS_ERR(pmu))
+		return 0;
+
 	pmu = syscon_regmap_lookup_by_compatible("rockchip,rk3066-pmu");
 	if (!IS_ERR(pmu))
 		return 0;

commit d003b58c8389d596e9fc6a131fc2901e3d039343
Author: Heiko Stuebner <heiko@sntech.de>
Date:   Wed Oct 15 10:23:00 2014 -0700

    ARM: rockchip: convert to regmap and use pmu syscon if available
    
    The pmu register space is - like the GRF - shared by quite some peripherals.
    On the rk3188 and rk3288 even parts of the pinctrl are living there.
    Therefore we normally shouldn't map it a second time when the syscon
    does this already.
    
    Therefore convert the cpu power-domain handling to access the pmu via a
    regmap and at first try to get it via the syscon interface.
    Getting this syscon will only fail if the pmu node does not have the
    "syscon" compatible and thus does not get shared with other drivers.
    
    In this case we map it like before and create the necessary regmap on
    top of it.
    
    Signed-off-by: Kever Yang <kever.yang@rock-chips.com>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index 189684f55927..4c36fbf99afb 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -19,6 +19,8 @@
 #include <linux/io.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
 
 #include <asm/cacheflush.h>
 #include <asm/cp15.h>
@@ -37,23 +39,42 @@ static int ncores;
 
 #define PMU_PWRDN_SCU		4
 
-static void __iomem *pmu_base_addr;
+static struct regmap *pmu;
 
-static inline bool pmu_power_domain_is_on(int pd)
+static int pmu_power_domain_is_on(int pd)
 {
-	return !(readl_relaxed(pmu_base_addr + PMU_PWRDN_ST) & BIT(pd));
+	u32 val;
+	int ret;
+
+	ret = regmap_read(pmu, PMU_PWRDN_ST, &val);
+	if (ret < 0)
+		return ret;
+
+	return !(val & BIT(pd));
 }
 
-static void pmu_set_power_domain(int pd, bool on)
+static int pmu_set_power_domain(int pd, bool on)
 {
-	u32 val = readl_relaxed(pmu_base_addr + PMU_PWRDN_CON);
-	if (on)
-		val &= ~BIT(pd);
-	else
-		val |=  BIT(pd);
-	writel(val, pmu_base_addr + PMU_PWRDN_CON);
-
-	while (pmu_power_domain_is_on(pd) != on) { }
+	u32 val = (on) ? 0 : BIT(pd);
+	int ret;
+
+	ret = regmap_update_bits(pmu, PMU_PWRDN_CON, BIT(pd), val);
+	if (ret < 0) {
+		pr_err("%s: could not update power domain\n", __func__);
+		return ret;
+	}
+
+	ret = -1;
+	while (ret != on) {
+		ret = pmu_power_domain_is_on(pd);
+		if (ret < 0) {
+			pr_err("%s: could not read power domain state\n",
+				 __func__);
+			return ret;
+		}
+	}
+
+	return 0;
 }
 
 /*
@@ -63,7 +84,7 @@ static void pmu_set_power_domain(int pd, bool on)
 static int __cpuinit rockchip_boot_secondary(unsigned int cpu,
 					     struct task_struct *idle)
 {
-	if (!sram_base_addr || !pmu_base_addr) {
+	if (!sram_base_addr || !pmu) {
 		pr_err("%s: sram or pmu missing for cpu boot\n", __func__);
 		return -ENXIO;
 	}
@@ -75,9 +96,7 @@ static int __cpuinit rockchip_boot_secondary(unsigned int cpu,
 	}
 
 	/* start the core */
-	pmu_set_power_domain(0 + cpu, true);
-
-	return 0;
+	return pmu_set_power_domain(0 + cpu, true);
 }
 
 /**
@@ -125,6 +144,48 @@ static int __init rockchip_smp_prepare_sram(struct device_node *node)
 	return 0;
 }
 
+static struct regmap_config rockchip_pmu_regmap_config = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = 4,
+};
+
+static int __init rockchip_smp_prepare_pmu(void)
+{
+	struct device_node *node;
+	void __iomem *pmu_base;
+
+	pmu = syscon_regmap_lookup_by_compatible("rockchip,rk3066-pmu");
+	if (!IS_ERR(pmu))
+		return 0;
+
+	/* fallback, create our own regmap for the pmu area */
+	pmu = NULL;
+	node = of_find_compatible_node(NULL, NULL, "rockchip,rk3066-pmu");
+	if (!node) {
+		pr_err("%s: could not find pmu dt node\n", __func__);
+		return -ENODEV;
+	}
+
+	pmu_base = of_iomap(node, 0);
+	if (!pmu_base) {
+		pr_err("%s: could not map pmu registers\n", __func__);
+		return -ENOMEM;
+	}
+
+	pmu = regmap_init_mmio(NULL, pmu_base, &rockchip_pmu_regmap_config);
+	if (IS_ERR(pmu)) {
+		int ret = PTR_ERR(pmu);
+
+		iounmap(pmu_base);
+		pmu = NULL;
+		pr_err("%s: regmap init failed\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
 static void __init rockchip_smp_prepare_cpus(unsigned int max_cpus)
 {
 	struct device_node *node;
@@ -151,17 +212,8 @@ static void __init rockchip_smp_prepare_cpus(unsigned int max_cpus)
 	if (rockchip_smp_prepare_sram(node))
 		return;
 
-	node = of_find_compatible_node(NULL, NULL, "rockchip,rk3066-pmu");
-	if (!node) {
-		pr_err("%s: could not find pmu dt node\n", __func__);
+	if (rockchip_smp_prepare_pmu())
 		return;
-	}
-
-	pmu_base_addr = of_iomap(node, 0);
-	if (!pmu_base_addr) {
-		pr_err("%s: could not map pmu registers\n", __func__);
-		return;
-	}
 
 	/* enable the SCU power domain */
 	pmu_set_power_domain(PMU_PWRDN_SCU, true);

commit f54b91fdfa7a1b5603d6d00f9972765662a4e6ef
Author: Romain Perier <romain.perier@gmail.com>
Date:   Sat Jul 19 13:03:26 2014 +0000

    ARM: rockchip: Add cpu hotplug support for RK3XXX SoCs
    
    Adds ability to shutdown all CPUs except the first one
    (since it might be special for a lot of platforms).
    It is now possible to use kexec which requires such a feature.
    
    Signed-off-by: Romain Perier <romain.perier@gmail.com>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index 910835d4ccf4..189684f55927 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -21,6 +21,7 @@
 #include <linux/of_address.h>
 
 #include <asm/cacheflush.h>
+#include <asm/cp15.h>
 #include <asm/smp_scu.h>
 #include <asm/smp_plat.h>
 #include <asm/mach/map.h>
@@ -178,8 +179,27 @@ static void __init rockchip_smp_prepare_cpus(unsigned int max_cpus)
 		pmu_set_power_domain(0 + i, false);
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+static int rockchip_cpu_kill(unsigned int cpu)
+{
+	pmu_set_power_domain(0 + cpu, false);
+	return 1;
+}
+
+static void rockchip_cpu_die(unsigned int cpu)
+{
+	v7_exit_coherency_flush(louis);
+	while(1)
+		cpu_do_idle();
+}
+#endif
+
 static struct smp_operations rockchip_smp_ops __initdata = {
 	.smp_prepare_cpus	= rockchip_smp_prepare_cpus,
 	.smp_boot_secondary	= rockchip_boot_secondary,
+#ifdef CONFIG_HOTPLUG_CPU
+	.cpu_kill		= rockchip_cpu_kill,
+	.cpu_die		= rockchip_cpu_die,
+#endif
 };
 CPU_METHOD_OF_DECLARE(rk3066_smp, "rockchip,rk3066-smp", &rockchip_smp_ops);

commit 26ab69cb4c1f77060bece483f2ec210163867782
Author: Heiko St√ºbner <heiko@sntech.de>
Date:   Thu Mar 27 01:06:32 2014 +0100

    ARM: rockchip: convert smp bringup to CPU_METHOD_OF_DECLARE
    
    With the newly introduced CPU_METHOD_OF_DECLARE is not necessary anymore
    to reference the relevant smp_ops in the board file, but instead it can
    simply be set by the enable-method property of the cpu nodes.
    
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index 072842f6491b..910835d4ccf4 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -178,7 +178,8 @@ static void __init rockchip_smp_prepare_cpus(unsigned int max_cpus)
 		pmu_set_power_domain(0 + i, false);
 }
 
-struct smp_operations rockchip_smp_ops __initdata = {
+static struct smp_operations rockchip_smp_ops __initdata = {
 	.smp_prepare_cpus	= rockchip_smp_prepare_cpus,
 	.smp_boot_secondary	= rockchip_boot_secondary,
 };
+CPU_METHOD_OF_DECLARE(rk3066_smp, "rockchip,rk3066-smp", &rockchip_smp_ops);

commit 5c4348c1f959234664e4667f428cf82b3b8a7c2c
Author: Heiko Stuebner <heiko@sntech.de>
Date:   Fri Apr 11 11:44:24 2014 +0200

    ARM: rockchip: fix copy'n'paste error in smp error messages
    
    The error emitted when mapping the pmu failed, wrongly mentions the sram.
    
    Reported-by: Kent Borg <kentborg@borg.org>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
index dbfa5a26cfff..072842f6491b 100644
--- a/arch/arm/mach-rockchip/platsmp.c
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -152,7 +152,7 @@ static void __init rockchip_smp_prepare_cpus(unsigned int max_cpus)
 
 	node = of_find_compatible_node(NULL, NULL, "rockchip,rk3066-pmu");
 	if (!node) {
-		pr_err("%s: could not find sram dt node\n", __func__);
+		pr_err("%s: could not find pmu dt node\n", __func__);
 		return;
 	}
 

commit a7a2b3118b410fb3cd3a8363b157c56f4211ee05
Author: Heiko Stuebner <heiko@sntech.de>
Date:   Mon Jun 17 22:29:23 2013 +0200

    ARM: rockchip: add smp bringup code
    
    This adds the necessary smp-operations and startup code to use
    additional cores on Rockchip SoCs.
    
    We currently hog the power management unit in the smp code, as it is
    necessary to control the power to the cpu core and nothing else is
    currently using it, so a generic implementation can be done later.
    
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Tested-by: Ulrich Prinz <ulrich.prinz@googlemail.com>

diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c
new file mode 100644
index 000000000000..dbfa5a26cfff
--- /dev/null
+++ b/arch/arm/mach-rockchip/platsmp.c
@@ -0,0 +1,184 @@
+/*
+ * Copyright (c) 2013 MundoReader S.L.
+ * Author: Heiko Stuebner <heiko@sntech.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+
+#include <asm/cacheflush.h>
+#include <asm/smp_scu.h>
+#include <asm/smp_plat.h>
+#include <asm/mach/map.h>
+
+#include "core.h"
+
+static void __iomem *scu_base_addr;
+static void __iomem *sram_base_addr;
+static int ncores;
+
+#define PMU_PWRDN_CON		0x08
+#define PMU_PWRDN_ST		0x0c
+
+#define PMU_PWRDN_SCU		4
+
+static void __iomem *pmu_base_addr;
+
+static inline bool pmu_power_domain_is_on(int pd)
+{
+	return !(readl_relaxed(pmu_base_addr + PMU_PWRDN_ST) & BIT(pd));
+}
+
+static void pmu_set_power_domain(int pd, bool on)
+{
+	u32 val = readl_relaxed(pmu_base_addr + PMU_PWRDN_CON);
+	if (on)
+		val &= ~BIT(pd);
+	else
+		val |=  BIT(pd);
+	writel(val, pmu_base_addr + PMU_PWRDN_CON);
+
+	while (pmu_power_domain_is_on(pd) != on) { }
+}
+
+/*
+ * Handling of CPU cores
+ */
+
+static int __cpuinit rockchip_boot_secondary(unsigned int cpu,
+					     struct task_struct *idle)
+{
+	if (!sram_base_addr || !pmu_base_addr) {
+		pr_err("%s: sram or pmu missing for cpu boot\n", __func__);
+		return -ENXIO;
+	}
+
+	if (cpu >= ncores) {
+		pr_err("%s: cpu %d outside maximum number of cpus %d\n",
+							__func__, cpu, ncores);
+		return -ENXIO;
+	}
+
+	/* start the core */
+	pmu_set_power_domain(0 + cpu, true);
+
+	return 0;
+}
+
+/**
+ * rockchip_smp_prepare_sram - populate necessary sram block
+ * Starting cores execute the code residing at the start of the on-chip sram
+ * after power-on. Therefore make sure, this sram region is reserved and
+ * big enough. After this check, copy the trampoline code that directs the
+ * core to the real startup code in ram into the sram-region.
+ * @node: mmio-sram device node
+ */
+static int __init rockchip_smp_prepare_sram(struct device_node *node)
+{
+	unsigned int trampoline_sz = &rockchip_secondary_trampoline_end -
+					    &rockchip_secondary_trampoline;
+	struct resource res;
+	unsigned int rsize;
+	int ret;
+
+	ret = of_address_to_resource(node, 0, &res);
+	if (ret < 0) {
+		pr_err("%s: could not get address for node %s\n",
+		       __func__, node->full_name);
+		return ret;
+	}
+
+	rsize = resource_size(&res);
+	if (rsize < trampoline_sz) {
+		pr_err("%s: reserved block with size 0x%x is to small for trampoline size 0x%x\n",
+		       __func__, rsize, trampoline_sz);
+		return -EINVAL;
+	}
+
+	sram_base_addr = of_iomap(node, 0);
+
+	/* set the boot function for the sram code */
+	rockchip_boot_fn = virt_to_phys(rockchip_secondary_startup);
+
+	/* copy the trampoline to sram, that runs during startup of the core */
+	memcpy(sram_base_addr, &rockchip_secondary_trampoline, trampoline_sz);
+	flush_cache_all();
+	outer_clean_range(0, trampoline_sz);
+
+	dsb_sev();
+
+	return 0;
+}
+
+static void __init rockchip_smp_prepare_cpus(unsigned int max_cpus)
+{
+	struct device_node *node;
+	unsigned int i;
+
+	node = of_find_compatible_node(NULL, NULL, "arm,cortex-a9-scu");
+	if (!node) {
+		pr_err("%s: missing scu\n", __func__);
+		return;
+	}
+
+	scu_base_addr = of_iomap(node, 0);
+	if (!scu_base_addr) {
+		pr_err("%s: could not map scu registers\n", __func__);
+		return;
+	}
+
+	node = of_find_compatible_node(NULL, NULL, "rockchip,rk3066-smp-sram");
+	if (!node) {
+		pr_err("%s: could not find sram dt node\n", __func__);
+		return;
+	}
+
+	if (rockchip_smp_prepare_sram(node))
+		return;
+
+	node = of_find_compatible_node(NULL, NULL, "rockchip,rk3066-pmu");
+	if (!node) {
+		pr_err("%s: could not find sram dt node\n", __func__);
+		return;
+	}
+
+	pmu_base_addr = of_iomap(node, 0);
+	if (!pmu_base_addr) {
+		pr_err("%s: could not map pmu registers\n", __func__);
+		return;
+	}
+
+	/* enable the SCU power domain */
+	pmu_set_power_domain(PMU_PWRDN_SCU, true);
+
+	/*
+	 * While the number of cpus is gathered from dt, also get the number
+	 * of cores from the scu to verify this value when booting the cores.
+	 */
+	ncores = scu_get_core_count(scu_base_addr);
+
+	scu_enable(scu_base_addr);
+
+	/* Make sure that all cores except the first are really off */
+	for (i = 1; i < ncores; i++)
+		pmu_set_power_domain(0 + i, false);
+}
+
+struct smp_operations rockchip_smp_ops __initdata = {
+	.smp_prepare_cpus	= rockchip_smp_prepare_cpus,
+	.smp_boot_secondary	= rockchip_boot_secondary,
+};
