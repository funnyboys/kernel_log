commit 4505153954fdb1465d2b178288a9bf646f2a2166
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:47 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 333
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 59 temple place suite 330 boston ma 02111
      1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 136 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.384967451@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/lib/delay.c b/arch/arm/lib/delay.c
index 2cef11884857..b7fe84f68bf1 100644
--- a/arch/arm/lib/delay.c
+++ b/arch/arm/lib/delay.c
@@ -1,21 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Delay loops based on the OpenRISC implementation.
  *
  * Copyright (C) 2012 ARM Limited
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
  * Author: Will Deacon <will.deacon@arm.com>
  */
 

commit 8478132a8784605fe07ede555f7277d989368d73
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Wed Nov 23 10:00:03 2016 +0000

    Revert "arm: move exports to definitions"
    
    This reverts commit 4dd1837d7589f468ed109556513f476e7a7f9121.
    
    Moving the exports for assembly code into the assembly files breaks
    KSYM trimming, but also breaks modversions.
    
    While fixing the KSYM trimming is trivial, fixing modversions brings
    us to a technically worse position that we had prior to the above
    change:
    
    - We end up with the prototype definitions divorsed from everything
      else, which means that adding or removing assembly level ksyms
      become more fragile:
      * if adding a new assembly ksyms export, a missed prototype in
        asm-prototypes.h results in a successful build if no module in
        the selected configuration makes use of the symbol.
      * when removing a ksyms export, asm-prototypes.h will get forgotten,
        with armksyms.c, you'll get a build error if you forget to touch
        the file.
    
    - We end up with the same amount of include files and prototypes,
      they're just in a header file instead of a .c file with their
      exports.
    
    As for lines of code, we don't get much of a size reduction:
     (original commit)
     47 files changed, 131 insertions(+), 208 deletions(-)
     (fix for ksyms trimming)
     7 files changed, 18 insertions(+), 5 deletions(-)
     (two fixes for modversions)
     1 file changed, 34 insertions(+)
     3 files changed, 7 insertions(+), 2 deletions(-)
    which results in a net total of only 25 lines deleted.
    
    As there does not seem to be much benefit from this change of approach,
    revert the change.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/lib/delay.c b/arch/arm/lib/delay.c
index 69aad80a3af4..2cef11884857 100644
--- a/arch/arm/lib/delay.c
+++ b/arch/arm/lib/delay.c
@@ -24,7 +24,6 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/export.h>
 #include <linux/timex.h>
 
 /*
@@ -35,7 +34,6 @@ struct arm_delay_ops arm_delay_ops __ro_after_init = {
 	.const_udelay	= __loop_const_udelay,
 	.udelay		= __loop_udelay,
 };
-EXPORT_SYMBOL(arm_delay_ops);
 
 static const struct delay_timer *delay_timer;
 static bool delay_calibrated;

commit 84d69848c97faab0c25aa2667b273404d2e2a64a
Merge: d4d24d2d0a7e 590abbdd2733
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 14 14:26:58 2016 -0700

    Merge branch 'kbuild' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild
    
    Pull kbuild updates from Michal Marek:
    
     - EXPORT_SYMBOL for asm source by Al Viro.
    
       This does bring a regression, because genksyms no longer generates
       checksums for these symbols (CONFIG_MODVERSIONS). Nick Piggin is
       working on a patch to fix this.
    
       Plus, we are talking about functions like strcpy(), which rarely
       change prototypes.
    
     - Fixes for PPC fallout of the above by Stephen Rothwell and Nick
       Piggin
    
     - fixdep speedup by Alexey Dobriyan.
    
     - preparatory work by Nick Piggin to allow architectures to build with
       -ffunction-sections, -fdata-sections and --gc-sections
    
     - CONFIG_THIN_ARCHIVES support by Stephen Rothwell
    
     - fix for filenames with colons in the initramfs source by me.
    
    * 'kbuild' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild: (22 commits)
      initramfs: Escape colons in depfile
      ppc: there is no clear_pages to export
      powerpc/64: whitelist unresolved modversions CRCs
      kbuild: -ffunction-sections fix for archs with conflicting sections
      kbuild: add arch specific post-link Makefile
      kbuild: allow archs to select link dead code/data elimination
      kbuild: allow architectures to use thin archives instead of ld -r
      kbuild: Regenerate genksyms lexer
      kbuild: genksyms fix for typeof handling
      fixdep: faster CONFIG_ search
      ia64: move exports to definitions
      sparc32: debride memcpy.S a bit
      [sparc] unify 32bit and 64bit string.h
      sparc: move exports to definitions
      ppc: move exports to definitions
      arm: move exports to definitions
      s390: move exports to definitions
      m68k: move exports to definitions
      alpha: move exports to actual definitions
      x86: move exports to actual definitions
      ...

commit 7619751f8c900fa5fdd76db06f4caf095c56de8e
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Aug 10 22:46:49 2016 +0100

    ARM: 8595/2: apply more __ro_after_init
    
    Guided by grsecurity's analogous __read_only markings in arch/arm,
    this applies several uses of __ro_after_init to structures that are
    only updated during __init.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/lib/delay.c b/arch/arm/lib/delay.c
index 8044591dca72..2cef11884857 100644
--- a/arch/arm/lib/delay.c
+++ b/arch/arm/lib/delay.c
@@ -29,7 +29,7 @@
 /*
  * Default to the loop-based delay implementation.
  */
-struct arm_delay_ops arm_delay_ops = {
+struct arm_delay_ops arm_delay_ops __ro_after_init = {
 	.delay		= __loop_delay,
 	.const_udelay	= __loop_const_udelay,
 	.udelay		= __loop_udelay,

commit 4dd1837d7589f468ed109556513f476e7a7f9121
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jan 13 13:46:22 2016 -0500

    arm: move exports to definitions
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/arm/lib/delay.c b/arch/arm/lib/delay.c
index 8044591dca72..e60ce1549759 100644
--- a/arch/arm/lib/delay.c
+++ b/arch/arm/lib/delay.c
@@ -24,6 +24,7 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/export.h>
 #include <linux/timex.h>
 
 /*
@@ -34,6 +35,7 @@ struct arm_delay_ops arm_delay_ops = {
 	.const_udelay	= __loop_const_udelay,
 	.udelay		= __loop_udelay,
 };
+EXPORT_SYMBOL(arm_delay_ops);
 
 static const struct delay_timer *delay_timer;
 static bool delay_calibrated;

commit 57ca654bef6c43bbbccfb2d231fd245d3f67dd46
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Apr 13 10:36:04 2015 +0100

    ARM: ensure delay timer has sufficient accuracy for delays
    
    We have recently had an example of someone wanting to use a 90kHz timer
    for the software delay loop.
    
    udelay() needs to have at least microsecond resolution to allow drivers
    access to a delay mechanism with a reasonable chance of delaying the
    period they requested within at least a 50% marging of error, especially
    for small delays.
    
    Discussion about the udelay() accuracy can be found at:
            https://lkml.org/lkml/2011/1/9/37
    
    Reject timers which are unable to supply this level of resolution.
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/lib/delay.c b/arch/arm/lib/delay.c
index 312d43eb686a..8044591dca72 100644
--- a/arch/arm/lib/delay.c
+++ b/arch/arm/lib/delay.c
@@ -83,6 +83,12 @@ void __init register_current_timer_delay(const struct delay_timer *timer)
 			       NSEC_PER_SEC, 3600);
 	res = cyc_to_ns(1ULL, new_mult, new_shift);
 
+	if (res > 1000) {
+		pr_err("Ignoring delay timer %ps, which has insufficient resolution of %lluns\n",
+			timer, res);
+		return;
+	}
+
 	if (!delay_calibrated && (!delay_res || (res < delay_res))) {
 		pr_info("Switching to timer-based delay loop, resolution %lluns\n", res);
 		delay_timer			= timer;

commit 5930c1a1f7f8439883d0a2173c6ce51d577e36ec
Author: Peter De Schrijver <pdeschrijver@nvidia.com>
Date:   Thu Jun 12 18:58:28 2014 +0300

    ARM: choose highest resolution delay timer
    
    In case there are several possible delay timers, choose the one with the
    highest resolution. This code relies on the fact secondary CPUs have not yet
    been brought online when register_current_timer_delay() is called. This is
    ensured by implementing calibration_delay_done(),
    
    Signed-off-by: Peter De Schrijver <pdeschrijver@nvidia.com>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/lib/delay.c b/arch/arm/lib/delay.c
index 5306de350133..312d43eb686a 100644
--- a/arch/arm/lib/delay.c
+++ b/arch/arm/lib/delay.c
@@ -19,6 +19,7 @@
  * Author: Will Deacon <will.deacon@arm.com>
  */
 
+#include <linux/clocksource.h>
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
@@ -36,6 +37,7 @@ struct arm_delay_ops arm_delay_ops = {
 
 static const struct delay_timer *delay_timer;
 static bool delay_calibrated;
+static u64 delay_res;
 
 int read_current_timer(unsigned long *timer_val)
 {
@@ -47,6 +49,11 @@ int read_current_timer(unsigned long *timer_val)
 }
 EXPORT_SYMBOL_GPL(read_current_timer);
 
+static inline u64 cyc_to_ns(u64 cyc, u32 mult, u32 shift)
+{
+	return (cyc * mult) >> shift;
+}
+
 static void __timer_delay(unsigned long cycles)
 {
 	cycles_t start = get_cycles();
@@ -69,18 +76,24 @@ static void __timer_udelay(unsigned long usecs)
 
 void __init register_current_timer_delay(const struct delay_timer *timer)
 {
-	if (!delay_calibrated) {
-		pr_info("Switching to timer-based delay loop\n");
+	u32 new_mult, new_shift;
+	u64 res;
+
+	clocks_calc_mult_shift(&new_mult, &new_shift, timer->freq,
+			       NSEC_PER_SEC, 3600);
+	res = cyc_to_ns(1ULL, new_mult, new_shift);
+
+	if (!delay_calibrated && (!delay_res || (res < delay_res))) {
+		pr_info("Switching to timer-based delay loop, resolution %lluns\n", res);
 		delay_timer			= timer;
 		lpj_fine			= timer->freq / HZ;
+		delay_res			= res;
 
 		/* cpufreq may scale loops_per_jiffy, so keep a private copy */
 		arm_delay_ops.ticks_per_jiffy	= lpj_fine;
 		arm_delay_ops.delay		= __timer_delay;
 		arm_delay_ops.const_udelay	= __timer_const_udelay;
 		arm_delay_ops.udelay		= __timer_udelay;
-
-		delay_calibrated		= true;
 	} else {
 		pr_info("Ignoring duplicate/late registration of read_current_timer delay\n");
 	}
@@ -91,3 +104,8 @@ unsigned long calibrate_delay_is_known(void)
 	delay_calibrated = true;
 	return lpj_fine;
 }
+
+void calibration_delay_done(void)
+{
+	delay_calibrated = true;
+}

commit 8bd26e3a7e49af2697449bbcb7187a39dc85d672
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jun 17 15:43:14 2013 -0400

    arm: delete __cpuinit/__CPUINIT usage from all ARM users
    
    The __cpuinit type of throwaway sections might have made sense
    some time ago when RAM was more constrained, but now the savings
    do not offset the cost and complications.  For example, the fix in
    commit 5e427ec2d0 ("x86: Fix bit corruption at CPU resume time")
    is a good example of the nasty type of bugs that can be created
    with improper use of the various __init prefixes.
    
    After a discussion on LKML[1] it was decided that cpuinit should go
    the way of devinit and be phased out.  Once all the users are gone,
    we can then finally remove the macros themselves from linux/init.h.
    
    Note that some harmless section mismatch warnings may result, since
    notify_cpu_starting() and cpu_up() are arch independent (kernel/cpu.c)
    and are flagged as __cpuinit  -- so if we remove the __cpuinit from
    the arch specific callers, we will also get section mismatch warnings.
    As an intermediate step, we intend to turn the linux/init.h cpuinit
    related content into no-ops as early as possible, since that will get
    rid of these warnings.  In any case, they are temporary and harmless.
    
    This removes all the ARM uses of the __cpuinit macros from C code,
    and all __CPUINIT from assembly code.  It also had two ".previous"
    section statements that were paired off against __CPUINIT
    (aka .section ".cpuinit.text") that also get removed here.
    
    [1] https://lkml.org/lkml/2013/5/20/589
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/arm/lib/delay.c b/arch/arm/lib/delay.c
index 64dbfa57204a..5306de350133 100644
--- a/arch/arm/lib/delay.c
+++ b/arch/arm/lib/delay.c
@@ -86,7 +86,7 @@ void __init register_current_timer_delay(const struct delay_timer *timer)
 	}
 }
 
-unsigned long __cpuinit calibrate_delay_is_known(void)
+unsigned long calibrate_delay_is_known(void)
 {
 	delay_calibrated = true;
 	return lpj_fine;

commit 6f3d90e55660ba42301b5e9c7eed332cc9f70fd7
Author: Will Deacon <will.deacon@arm.com>
Date:   Thu Mar 28 11:17:55 2013 +0100

    ARM: 7685/1: delay: use private ticks_per_jiffy field for timer-based delay ops
    
    Commit 70264367a243 ("ARM: 7653/2: do not scale loops_per_jiffy when
    using a constant delay clock") fixed a problem with our timer-based
    delay loop, where loops_per_jiffy is scaled by cpufreq yet used directly
    by the timer delay ops.
    
    This patch fixes the problem in a more elegant way by keeping a private
    ticks_per_jiffy field in the delay ops, independent of loops_per_jiffy
    and therefore not subject to scaling. The loop-based delay continues to
    use loops_per_jiffy directly, as it should.
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/lib/delay.c b/arch/arm/lib/delay.c
index 6b93f6a1a3c7..64dbfa57204a 100644
--- a/arch/arm/lib/delay.c
+++ b/arch/arm/lib/delay.c
@@ -58,7 +58,7 @@ static void __timer_delay(unsigned long cycles)
 static void __timer_const_udelay(unsigned long xloops)
 {
 	unsigned long long loops = xloops;
-	loops *= loops_per_jiffy;
+	loops *= arm_delay_ops.ticks_per_jiffy;
 	__timer_delay(loops >> UDELAY_SHIFT);
 }
 
@@ -73,11 +73,13 @@ void __init register_current_timer_delay(const struct delay_timer *timer)
 		pr_info("Switching to timer-based delay loop\n");
 		delay_timer			= timer;
 		lpj_fine			= timer->freq / HZ;
-		loops_per_jiffy			= lpj_fine;
+
+		/* cpufreq may scale loops_per_jiffy, so keep a private copy */
+		arm_delay_ops.ticks_per_jiffy	= lpj_fine;
 		arm_delay_ops.delay		= __timer_delay;
 		arm_delay_ops.const_udelay	= __timer_const_udelay;
 		arm_delay_ops.udelay		= __timer_udelay;
-		arm_delay_ops.const_clock	= true;
+
 		delay_calibrated		= true;
 	} else {
 		pr_info("Ignoring duplicate/late registration of read_current_timer delay\n");

commit 70264367a243a68b1d5636ffb570183449803cbe
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Mon Feb 18 16:36:13 2013 +0100

    ARM: 7653/2: do not scale loops_per_jiffy when using a constant delay clock
    
    When udelay() is implemented using an architected timer, it is wrong
    to scale loops_per_jiffy when changing the CPU clock frequency since
    the timer clock remains constant.
    
    The lpj should probably become an implementation detail relevant to
    the CPU loop based delay routine only and more confined to it. In the
    mean time this is the minimal fix needed to have expected delays with
    the timer based implementation when cpufreq is also in use.
    
    Reported-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Tested-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/lib/delay.c b/arch/arm/lib/delay.c
index 0dc53854a5d8..6b93f6a1a3c7 100644
--- a/arch/arm/lib/delay.c
+++ b/arch/arm/lib/delay.c
@@ -77,6 +77,7 @@ void __init register_current_timer_delay(const struct delay_timer *timer)
 		arm_delay_ops.delay		= __timer_delay;
 		arm_delay_ops.const_udelay	= __timer_const_udelay;
 		arm_delay_ops.udelay		= __timer_udelay;
+		arm_delay_ops.const_clock	= true;
 		delay_calibrated		= true;
 	} else {
 		pr_info("Ignoring duplicate/late registration of read_current_timer delay\n");

commit f3accb122f2c758494a6db3b9e9a8cd62aafcf83
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Oct 1 14:47:31 2012 +0000

    ARM: export default read_current_timer
    
    read_current_timer is used by get_cycles since "ARM: 7538/1: delay:
    add registration mechanism for delay timer sources", and get_cycles
    can be used by device drivers in loadable modules, so it has to
    be exported.
    
    Without this patch, building imote2_defconfig fails with
    
    ERROR: "read_current_timer" [crypto/tcrypt.ko] undefined!
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Jonathan Austin <jonathan.austin@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/lib/delay.c b/arch/arm/lib/delay.c
index 9d0a30032d7f..0dc53854a5d8 100644
--- a/arch/arm/lib/delay.c
+++ b/arch/arm/lib/delay.c
@@ -45,6 +45,7 @@ int read_current_timer(unsigned long *timer_val)
 	*timer_val = delay_timer->read_current_timer();
 	return 0;
 }
+EXPORT_SYMBOL_GPL(read_current_timer);
 
 static void __timer_delay(unsigned long cycles)
 {

commit 56942fec06efa0e17df0f4c3b438332c923b9014
Author: Jonathan Austin <Jonathan.Austin@arm.com>
Date:   Fri Sep 21 18:51:44 2012 +0100

    ARM: 7538/1: delay: add registration mechanism for delay timer sources
    
    The current timer-based delay loop relies on the architected timer to
    initiate the switch away from the polling-based implementation. This is
    unfortunate for platforms without the architected timers but with a
    suitable delay source (that is, constant frequency, always powered-up
    and ticking as long as the CPUs are online).
    
    This patch introduces a registration mechanism for the delay timer
    (which provides an unconditional read_current_timer implementation) and
    updates the architected timer code to use the new interface.
    
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Jonathan Austin <jonathan.austin@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/lib/delay.c b/arch/arm/lib/delay.c
index d6dacc69254e..9d0a30032d7f 100644
--- a/arch/arm/lib/delay.c
+++ b/arch/arm/lib/delay.c
@@ -34,7 +34,18 @@ struct arm_delay_ops arm_delay_ops = {
 	.udelay		= __loop_udelay,
 };
 
-#ifdef ARCH_HAS_READ_CURRENT_TIMER
+static const struct delay_timer *delay_timer;
+static bool delay_calibrated;
+
+int read_current_timer(unsigned long *timer_val)
+{
+	if (!delay_timer)
+		return -ENXIO;
+
+	*timer_val = delay_timer->read_current_timer();
+	return 0;
+}
+
 static void __timer_delay(unsigned long cycles)
 {
 	cycles_t start = get_cycles();
@@ -55,17 +66,24 @@ static void __timer_udelay(unsigned long usecs)
 	__timer_const_udelay(usecs * UDELAY_MULT);
 }
 
-void __init init_current_timer_delay(unsigned long freq)
+void __init register_current_timer_delay(const struct delay_timer *timer)
 {
-	pr_info("Switching to timer-based delay loop\n");
-	lpj_fine			= freq / HZ;
-	arm_delay_ops.delay		= __timer_delay;
-	arm_delay_ops.const_udelay	= __timer_const_udelay;
-	arm_delay_ops.udelay		= __timer_udelay;
+	if (!delay_calibrated) {
+		pr_info("Switching to timer-based delay loop\n");
+		delay_timer			= timer;
+		lpj_fine			= timer->freq / HZ;
+		loops_per_jiffy			= lpj_fine;
+		arm_delay_ops.delay		= __timer_delay;
+		arm_delay_ops.const_udelay	= __timer_const_udelay;
+		arm_delay_ops.udelay		= __timer_udelay;
+		delay_calibrated		= true;
+	} else {
+		pr_info("Ignoring duplicate/late registration of read_current_timer delay\n");
+	}
 }
 
 unsigned long __cpuinit calibrate_delay_is_known(void)
 {
+	delay_calibrated = true;
 	return lpj_fine;
 }
-#endif

commit d0a533b18235d36206b9b422efadb7cee444dfdb
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Jul 6 15:47:17 2012 +0100

    ARM: 7452/1: delay: allow timer-based delay implementation to be selected
    
    This patch allows a timer-based delay implementation to be selected by
    switching the delay routines over to use get_cycles, which is
    implemented in terms of read_current_timer. This further allows us to
    skip the loop calibration and have a consistent delay function in the
    face of core frequency scaling.
    
    To avoid the pain of dealing with memory-mapped counters, this
    implementation uses the co-processor interface to the architected timers
    when they are available. The previous loop-based implementation is
    kept around for CPUs without the architected timers and we retain both
    the maximum delay (2ms) and the corresponding conversion factors for
    determining the number of loops required for a given interval. Since the
    indirection of the timer routines will only work when called from C,
    the sa1100 sleep routines are modified to branch to the loop-based delay
    functions directly.
    
    Tested-by: Shinya Kuribayashi <shinya.kuribayashi.px@renesas.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/lib/delay.c b/arch/arm/lib/delay.c
new file mode 100644
index 000000000000..d6dacc69254e
--- /dev/null
+++ b/arch/arm/lib/delay.c
@@ -0,0 +1,71 @@
+/*
+ * Delay loops based on the OpenRISC implementation.
+ *
+ * Copyright (C) 2012 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Author: Will Deacon <will.deacon@arm.com>
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/timex.h>
+
+/*
+ * Default to the loop-based delay implementation.
+ */
+struct arm_delay_ops arm_delay_ops = {
+	.delay		= __loop_delay,
+	.const_udelay	= __loop_const_udelay,
+	.udelay		= __loop_udelay,
+};
+
+#ifdef ARCH_HAS_READ_CURRENT_TIMER
+static void __timer_delay(unsigned long cycles)
+{
+	cycles_t start = get_cycles();
+
+	while ((get_cycles() - start) < cycles)
+		cpu_relax();
+}
+
+static void __timer_const_udelay(unsigned long xloops)
+{
+	unsigned long long loops = xloops;
+	loops *= loops_per_jiffy;
+	__timer_delay(loops >> UDELAY_SHIFT);
+}
+
+static void __timer_udelay(unsigned long usecs)
+{
+	__timer_const_udelay(usecs * UDELAY_MULT);
+}
+
+void __init init_current_timer_delay(unsigned long freq)
+{
+	pr_info("Switching to timer-based delay loop\n");
+	lpj_fine			= freq / HZ;
+	arm_delay_ops.delay		= __timer_delay;
+	arm_delay_ops.const_udelay	= __timer_const_udelay;
+	arm_delay_ops.udelay		= __timer_udelay;
+}
+
+unsigned long __cpuinit calibrate_delay_is_known(void)
+{
+	return lpj_fine;
+}
+#endif
