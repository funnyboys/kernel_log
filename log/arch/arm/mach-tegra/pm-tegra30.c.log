commit 9952f6918daa4ab5fc81307a9f90e31a4df3b200
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 10:10:04 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 201
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms and conditions of the gnu general public license
      version 2 as published by the free software foundation this program
      is distributed in the hope it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 228 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528171438.107155473@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-tegra/pm-tegra30.c b/arch/arm/mach-tegra/pm-tegra30.c
index 46cc19de9916..e1b0329537fe 100644
--- a/arch/arm/mach-tegra/pm-tegra30.c
+++ b/arch/arm/mach-tegra/pm-tegra30.c
@@ -1,17 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2013, NVIDIA Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <linux/kernel.h>

commit a0524acc94c91c72c2968a76eddc6f3afe82f9f2
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Jul 11 09:44:49 2014 +0200

    ARM: tegra: Sort includes alphabetically
    
    If these aren't sorted alphabetically, then the logical choice is to
    append new ones, however that creates a lot of potential for conflicts
    because every change will then add new includes in the same location.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm-tegra30.c b/arch/arm/mach-tegra/pm-tegra30.c
index 8fa326d6ff1a..46cc19de9916 100644
--- a/arch/arm/mach-tegra/pm-tegra30.c
+++ b/arch/arm/mach-tegra/pm-tegra30.c
@@ -13,6 +13,7 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+
 #include <linux/kernel.h>
 
 #include "pm.h"

commit e7a932b1961c3936c7ae5b8d1628f39dc50a746d
Author: Joseph Lo <josephl@nvidia.com>
Date:   Mon Aug 12 17:40:04 2013 +0800

    ARM: tegra: add LP1 suspend support for Tegra30
    
    The LP1 suspend mode will power off the CPU, clock gated the PLLs and put
    SDRAM to self-refresh mode. Any interrupt can wake up device from LP1. The
    sequence when LP1 suspending:
    
    * tunning off L1 data cache and the MMU
    * storing some EMC registers, DPD (deep power down) status, clk source of
      mselect and SCLK burst policy
    * putting SDRAM into self-refresh
    * switching CPU to CLK_M (12MHz OSC)
    * tunning off PLLM, PLLP, PLLA, PLLC and PLLX
    * switching SCLK to CLK_S (32KHz OSC)
    * shutting off the CPU rail
    
    The sequence of LP1 resuming:
    
    * re-enabling PLLM, PLLP, PLLA, PLLC and PLLX
    * restoring the clk source of mselect and SCLK burst policy
    * setting up CCLK burst policy to PLLX
    * restoring DPD status and some EMC registers
    * resuming SDRAM to normal mode
    * jumping to the "tegra_resume" from PMC_SCRATCH41
    
    Due to the SDRAM will be put into self-refresh mode, the low level
    procedures of LP1 suspending and resuming should be copied to
    TEGRA_IRAM_CODE_AREA (TEGRA_IRAM_BASE + SZ_4K) when suspending. Before
    restoring the CPU context when resuming, the SDRAM needs to be switched
    back to normal mode. And the PLLs need to be re-enabled, SCLK burst policy
    be restored, CCLK burst policy be set in PLLX. Then jumping to
    "tegra_resume" that was expected to be stored in PMC_SCRATCH41 to restore
    CPU context and back to kernel.
    
    Based on the work by: Scott Williams <scwilliams@nvidia.com>
    
    Signed-off-by: Joseph Lo <josephl@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm-tegra30.c b/arch/arm/mach-tegra/pm-tegra30.c
new file mode 100644
index 000000000000..8fa326d6ff1a
--- /dev/null
+++ b/arch/arm/mach-tegra/pm-tegra30.c
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2013, NVIDIA Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/kernel.h>
+
+#include "pm.h"
+
+#ifdef CONFIG_PM_SLEEP
+extern u32 tegra30_iram_start, tegra30_iram_end;
+extern void tegra30_sleep_core_finish(unsigned long);
+
+void tegra30_lp1_iram_hook(void)
+{
+	tegra_lp1_iram.start_addr = &tegra30_iram_start;
+	tegra_lp1_iram.end_addr = &tegra30_iram_end;
+}
+
+void tegra30_sleep_core_init(void)
+{
+	tegra_sleep_core_finish = tegra30_sleep_core_finish;
+}
+#endif
