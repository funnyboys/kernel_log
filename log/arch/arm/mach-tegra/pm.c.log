commit 38743e414e7cc6d23f41276f298ad4781890a89f
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Wed Mar 25 01:43:34 2020 +0300

    ARM: tegra: Do not fully reinitialize L2 on resume
    
    ASUS TF300T device may not work properly if firmware is asked to fully
    re-initialize L2 cache after resume from LP2 suspend. The downstream
    kernel of TF300T uses different opcode to enable cache after resuming
    from LP2, this opcode also works fine on Nexus 7 and Ouya devices.
    Supposedly, this may be needed by an older firmware versions.
    
    Reported-by: Michał Mirosław <mirq-linux@rere.qmqm.pl>
    Tested-by: Michał Mirosław <mirq-linux@rere.qmqm.pl>
    Tested-by: Jasper Korten <jja2000@gmail.com>
    Tested-by: David Heidelberg <david@ixit.cz>
    Tested-by: Peter Geis <pgwipeout@gmail.com>
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index d1e1a61b12cf..6452ebf68d40 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -216,6 +216,8 @@ int tegra_pm_enter_lp2(void)
 	restore_cpu_complex();
 	cpu_cluster_pm_exit();
 
+	call_firmware_op(prepare_idle, TF_PM_MODE_NONE);
+
 	return err;
 }
 
@@ -391,6 +393,8 @@ static int tegra_suspend_enter(suspend_state_t state)
 
 	local_fiq_enable();
 
+	call_firmware_op(prepare_idle, TF_PM_MODE_NONE);
+
 	return 0;
 }
 

commit 7ed50dd5dd12c2e69a591b2dc4d242b0e6c32dd3
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Tue Feb 25 01:40:48 2020 +0300

    ARM: tegra: Make outer_disable() open-coded
    
    The outer_disable() of Tegra's suspend code is open-coded now since
    that helper produces spurious warning message about secondary CPUs being
    online when CPU enters into LP2 from cpuidle. The secondaries are actually
    halted by the cpuidle driver on entering into LP2 idle-state, but the
    online status is not touched by the cpuidle. This fixes a storm of
    warnings once LP2 idling state is enabled on Tegra30. The outer_disable()
    helper has sanity checks for interrupts and secondary CPUs being disabled
    and we are pretty confident about the interrupts state during of CPU
    idling / system suspend. The rail-off status check is added in this patch
    as equivalent for the "num_online_cpus() > 1".
    
    Acked-by: Peter De Schrijver <pdeschrijver@nvidia.com>
    Tested-by: Peter Geis <pgwipeout@gmail.com>
    Tested-by: Jasper Korten <jja2000@gmail.com>
    Tested-by: David Heidelberg <david@ixit.cz>
    Tested-by: Nicolas Chauvet <kwizart@gmail.com>
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 7d9ef26e52a7..d1e1a61b12cf 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -138,6 +138,10 @@ void tegra_pm_set_cpu_in_lp2(void)
 
 static int tegra_sleep_cpu(unsigned long v2p)
 {
+	if (tegra_cpu_car_ops->rail_off_ready &&
+	    WARN_ON(!tegra_cpu_rail_off_ready()))
+		return -EBUSY;
+
 	/*
 	 * L2 cache disabling using kernel API only allowed when all
 	 * secondary CPU's are offline. Cache have to be disabled with
@@ -146,9 +150,10 @@ static int tegra_sleep_cpu(unsigned long v2p)
 	 * if any of secondary CPU's is online and this is the LP2-idle
 	 * code-path only for Tegra20/30.
 	 */
-	if (trusted_foundations_registered())
-		outer_disable();
-
+#ifdef CONFIG_OUTER_CACHE
+	if (trusted_foundations_registered() && outer_cache.disable)
+		outer_cache.disable();
+#endif
 	/*
 	 * Note that besides of setting up CPU reset vector this firmware
 	 * call may also do the following, depending on the FW version:

commit 1f3e18ec95f61589404d1471dc01c9599352dd93
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Tue Feb 25 01:40:47 2020 +0300

    ARM: tegra: Rename some of the newly exposed PM functions
    
    Rename some of the recently exposed PM functions, prefixing them with
    "tegra_pm_" in order to make the naming of the PM functions consistent.
    
    Acked-by: Peter De Schrijver <pdeschrijver@nvidia.com>
    Tested-by: Peter Geis <pgwipeout@gmail.com>
    Tested-by: Jasper Korten <jja2000@gmail.com>
    Tested-by: David Heidelberg <david@ixit.cz>
    Tested-by: Nicolas Chauvet <kwizart@gmail.com>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index a094acaca307..7d9ef26e52a7 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -110,7 +110,7 @@ static void suspend_cpu_complex(void)
 	flowctrl_cpu_suspend_enter(cpu);
 }
 
-void tegra_clear_cpu_in_lp2(void)
+void tegra_pm_clear_cpu_in_lp2(void)
 {
 	int phy_cpu_id = cpu_logical_map(smp_processor_id());
 	u32 *cpu_in_lp2 = tegra_cpu_lp2_mask;
@@ -123,7 +123,7 @@ void tegra_clear_cpu_in_lp2(void)
 	spin_unlock(&tegra_lp2_lock);
 }
 
-void tegra_set_cpu_in_lp2(void)
+void tegra_pm_set_cpu_in_lp2(void)
 {
 	int phy_cpu_id = cpu_logical_map(smp_processor_id());
 	u32 *cpu_in_lp2 = tegra_cpu_lp2_mask;
@@ -189,7 +189,7 @@ static void tegra_pm_set(enum tegra_suspend_mode mode)
 	tegra_pmc_enter_suspend_mode(mode);
 }
 
-int tegra_idle_lp2_last(void)
+int tegra_pm_enter_lp2(void)
 {
 	int err;
 
@@ -356,7 +356,7 @@ static int tegra_suspend_enter(suspend_state_t state)
 		tegra_suspend_enter_lp1();
 		break;
 	case TEGRA_SUSPEND_LP2:
-		tegra_set_cpu_in_lp2();
+		tegra_pm_set_cpu_in_lp2();
 		break;
 	default:
 		break;
@@ -377,7 +377,7 @@ static int tegra_suspend_enter(suspend_state_t state)
 		tegra_suspend_exit_lp1();
 		break;
 	case TEGRA_SUSPEND_LP2:
-		tegra_clear_cpu_in_lp2();
+		tegra_pm_clear_cpu_in_lp2();
 		break;
 	default:
 		break;

commit 891e1286c138eafb26d1f36eee3f31b8cd2c2bd9
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Tue Feb 25 01:40:45 2020 +0300

    ARM: tegra: Propagate error from tegra_idle_lp2_last()
    
    Technically cpu_suspend() may fail and it's never good to lose information
    about failure. For example things like cpuidle core could correctly sample
    idling time in the case of failure.
    
    Acked-by: Peter De Schrijver <pdeschrijver@nvidia.com>
    Tested-by: Peter Geis <pgwipeout@gmail.com>
    Tested-by: Jasper Korten <jja2000@gmail.com>
    Tested-by: David Heidelberg <david@ixit.cz>
    Tested-by: Nicolas Chauvet <kwizart@gmail.com>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index a72f9a2d3cb7..a094acaca307 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -189,14 +189,16 @@ static void tegra_pm_set(enum tegra_suspend_mode mode)
 	tegra_pmc_enter_suspend_mode(mode);
 }
 
-void tegra_idle_lp2_last(void)
+int tegra_idle_lp2_last(void)
 {
+	int err;
+
 	tegra_pm_set(TEGRA_SUSPEND_LP2);
 
 	cpu_cluster_pm_enter();
 	suspend_cpu_complex();
 
-	cpu_suspend(PHYS_OFFSET - PAGE_OFFSET, &tegra_sleep_cpu);
+	err = cpu_suspend(PHYS_OFFSET - PAGE_OFFSET, &tegra_sleep_cpu);
 
 	/*
 	 * Resume L2 cache if it wasn't re-enabled early during resume,
@@ -208,6 +210,8 @@ void tegra_idle_lp2_last(void)
 
 	restore_cpu_complex();
 	cpu_cluster_pm_exit();
+
+	return err;
 }
 
 enum tegra_suspend_mode tegra_pm_validate_suspend_mode(

commit f5619492c80ba021e267de245bb78b485d1802c5
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Tue Feb 25 01:40:44 2020 +0300

    ARM: tegra: Change tegra_set_cpu_in_lp2() type to void
    
    The Tegra30 CPUIDLE driver has intention to check whether primary CPU was
    the last CPU that entered LP2 (CC6) idle-state, but that functionality
    never got utilized because driver never supported the CC6 state for the
    case where any secondary CPU is online. The new cpuidle driver will
    properly support CC6 on Tegra30, including the case where secondary CPUs
    are online, and that knowledge about what CPUs entered into CC6 won't be
    needed at all because new driver will use different approach by making use
    of the coupled idle-state and explicitly parking secondary CPUs before
    entering into CC6. Thus this patch is just a minor cleanup change.
    
    Acked-by: Peter De Schrijver <pdeschrijver@nvidia.com>
    Tested-by: Peter Geis <pgwipeout@gmail.com>
    Tested-by: Jasper Korten <jja2000@gmail.com>
    Tested-by: David Heidelberg <david@ixit.cz>
    Tested-by: Nicolas Chauvet <kwizart@gmail.com>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 1ff499068bb1..a72f9a2d3cb7 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -123,11 +123,9 @@ void tegra_clear_cpu_in_lp2(void)
 	spin_unlock(&tegra_lp2_lock);
 }
 
-bool tegra_set_cpu_in_lp2(void)
+void tegra_set_cpu_in_lp2(void)
 {
 	int phy_cpu_id = cpu_logical_map(smp_processor_id());
-	bool last_cpu = false;
-	cpumask_t *cpu_lp2_mask = tegra_cpu_lp2_mask;
 	u32 *cpu_in_lp2 = tegra_cpu_lp2_mask;
 
 	spin_lock(&tegra_lp2_lock);
@@ -135,11 +133,7 @@ bool tegra_set_cpu_in_lp2(void)
 	BUG_ON((*cpu_in_lp2 & BIT(phy_cpu_id)));
 	*cpu_in_lp2 |= BIT(phy_cpu_id);
 
-	if ((phy_cpu_id == 0) && cpumask_equal(cpu_lp2_mask, cpu_online_mask))
-		last_cpu = true;
-
 	spin_unlock(&tegra_lp2_lock);
-	return last_cpu;
 }
 
 static int tegra_sleep_cpu(unsigned long v2p)

commit d90bdb72bb42369ae1493f5bbb3fadb3c854aad8
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Tue Feb 25 01:40:43 2020 +0300

    ARM: tegra: Remove pen-locking from cpuidle-tegra20
    
    Pen-locking is meant to block CPU0 if CPU1 wakes up during of entering
    into LP2 because of some interrupt firing up, preventing unnecessary LP2
    enter that will be resumed immediately. Apparently this case doesn't
    happen often in practice, I checked how often it takes place and found
    that after ~20 hours of browsing web, managing email, watching videos and
    idling (15+ hours) there is only a dozen of early LP2 entering abortions
    and they all happened while device was idling. Thus let's remove the
    pen-locking and make LP2 entering uninterruptible, simplifying code quite
    a lot. This will also become very handy for the upcoming unified cpuidle
    driver, allowing to have a common LP2 code-path across of different
    hardware generations.
    
    Acked-by: Peter De Schrijver <pdeschrijver@nvidia.com>
    Tested-by: Peter Geis <pgwipeout@gmail.com>
    Tested-by: Jasper Korten <jja2000@gmail.com>
    Tested-by: David Heidelberg <david@ixit.cz>
    Tested-by: Nicolas Chauvet <kwizart@gmail.com>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index f5ff3dd1dd81..1ff499068bb1 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -137,18 +137,11 @@ bool tegra_set_cpu_in_lp2(void)
 
 	if ((phy_cpu_id == 0) && cpumask_equal(cpu_lp2_mask, cpu_online_mask))
 		last_cpu = true;
-	else if (tegra_get_chip_id() == TEGRA20 && phy_cpu_id == 1)
-		tegra20_cpu_set_resettable_soon();
 
 	spin_unlock(&tegra_lp2_lock);
 	return last_cpu;
 }
 
-int tegra_cpu_do_idle(void)
-{
-	return cpu_do_idle();
-}
-
 static int tegra_sleep_cpu(unsigned long v2p)
 {
 	/*

commit 859a6f6ee15ee8931da40fae31fdea73a5e72192
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Tue Feb 25 01:40:42 2020 +0300

    ARM: tegra: Add tegra_pm_park_secondary_cpu()
    
    This function resembles tegra_cpu_die() of the hotplug code, but
    this variant is more suitable to be used for CPU PM because it's made
    specifically to be used by cpu_suspend(). In short this function puts
    secondary CPU offline, it will be used by the new CPUIDLE driver.
    
    Acked-by: Peter De Schrijver <pdeschrijver@nvidia.com>
    Tested-by: Peter Geis <pgwipeout@gmail.com>
    Tested-by: Jasper Korten <jja2000@gmail.com>
    Tested-by: David Heidelberg <david@ixit.cz>
    Tested-by: Nicolas Chauvet <kwizart@gmail.com>
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 3cab81b82866..f5ff3dd1dd81 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -436,4 +436,18 @@ void __init tegra_init_suspend(void)
 
 	suspend_set_ops(&tegra_suspend_ops);
 }
+
+int tegra_pm_park_secondary_cpu(unsigned long cpu)
+{
+	if (cpu > 0) {
+		tegra_disable_clean_inv_dcache(TEGRA_FLUSH_CACHE_LOUIS);
+
+		if (tegra_get_chip_id() == TEGRA20)
+			tegra20_hotplug_shutdown();
+		else
+			tegra30_hotplug_shutdown();
+	}
+
+	return -EINVAL;
+}
 #endif

commit 9952f6918daa4ab5fc81307a9f90e31a4df3b200
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 10:10:04 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 201
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms and conditions of the gnu general public license
      version 2 as published by the free software foundation this program
      is distributed in the hope it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 228 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528171438.107155473@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 1b0ade06f204..3cab81b82866 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -1,19 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * CPU complex suspend & resume functions for Tegra SoCs
  *
  * Copyright (c) 2009-2012, NVIDIA Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <linux/clk/tegra.h>

commit 4cb5d9eca143f7fbf8cc457be19a91914f978a00
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Apr 10 10:47:28 2019 +0200

    firmware: Move Trusted Foundations support
    
    Move the Trusted Foundations support out of arch/arm/firmware and into
    drivers/firmware where most other firmware support implementations are
    located.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index abf5f88778f4..1b0ade06f204 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -27,6 +27,8 @@
 #include <linux/spinlock.h>
 #include <linux/suspend.h>
 
+#include <linux/firmware/trusted_foundations.h>
+
 #include <soc/tegra/flowctrl.h>
 #include <soc/tegra/fuse.h>
 #include <soc/tegra/pm.h>
@@ -39,7 +41,6 @@
 #include <asm/smp_plat.h>
 #include <asm/suspend.h>
 #include <asm/tlbflush.h>
-#include <asm/trusted_foundations.h>
 
 #include "iomap.h"
 #include "pm.h"

commit 78ee399f1632a00a92dcdb0ebba8cfe0081a3e5d
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Mon Mar 18 01:52:10 2019 +0300

    ARM: tegra: Add firmware calls required for suspend-resume on Tegra30
    
    In order to suspend-resume CPU with Trusted Foundations firmware being
    present on Tegra30, the LP1/LP2 boot vectors and CPU caches need to be
    set up using the firmware calls and then suspend code shall avoid
    re-disabling parts that were disabled by the firmware.
    
    Tested-by: Robert Yang <decatf@gmail.com>
    Tested-by: Michał Mirosław <mirq-linux@rere.qmqm.pl>
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 1ad5719779b0..abf5f88778f4 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -33,11 +33,13 @@
 #include <soc/tegra/pmc.h>
 
 #include <asm/cacheflush.h>
+#include <asm/firmware.h>
 #include <asm/idmap.h>
 #include <asm/proc-fns.h>
 #include <asm/smp_plat.h>
 #include <asm/suspend.h>
 #include <asm/tlbflush.h>
+#include <asm/trusted_foundations.h>
 
 #include "iomap.h"
 #include "pm.h"
@@ -159,6 +161,28 @@ int tegra_cpu_do_idle(void)
 
 static int tegra_sleep_cpu(unsigned long v2p)
 {
+	/*
+	 * L2 cache disabling using kernel API only allowed when all
+	 * secondary CPU's are offline. Cache have to be disabled with
+	 * MMU-on if cache maintenance is done via Trusted Foundations
+	 * firmware. Note that CPUIDLE won't ever enter powergate on Tegra30
+	 * if any of secondary CPU's is online and this is the LP2-idle
+	 * code-path only for Tegra20/30.
+	 */
+	if (trusted_foundations_registered())
+		outer_disable();
+
+	/*
+	 * Note that besides of setting up CPU reset vector this firmware
+	 * call may also do the following, depending on the FW version:
+	 *  1) Disable L2. But this doesn't matter since we already
+	 *     disabled the L2.
+	 *  2) Disable D-cache. This need to be taken into account in
+	 *     particular by the tegra_disable_clean_inv_dcache() which
+	 *     shall avoid the re-disable.
+	 */
+	call_firmware_op(prepare_idle, TF_PM_MODE_LP2);
+
 	setup_mm_for_reboot();
 	tegra_sleep_cpu_finish(v2p);
 
@@ -197,6 +221,14 @@ void tegra_idle_lp2_last(void)
 
 	cpu_suspend(PHYS_OFFSET - PAGE_OFFSET, &tegra_sleep_cpu);
 
+	/*
+	 * Resume L2 cache if it wasn't re-enabled early during resume,
+	 * which is the case for Tegra30 that has to re-enable the cache
+	 * via firmware call. In other cases cache is already enabled and
+	 * hence re-enabling is a no-op. This is always a no-op on Tegra114+.
+	 */
+	outer_resume();
+
 	restore_cpu_complex();
 	cpu_cluster_pm_exit();
 }
@@ -215,6 +247,15 @@ enum tegra_suspend_mode tegra_pm_validate_suspend_mode(
 
 static int tegra_sleep_core(unsigned long v2p)
 {
+	/*
+	 * Cache have to be disabled with MMU-on if cache maintenance is done
+	 * via Trusted Foundations firmware. This is a no-op on Tegra114+.
+	 */
+	if (trusted_foundations_registered())
+		outer_disable();
+
+	call_firmware_op(prepare_idle, TF_PM_MODE_LP1);
+
 	setup_mm_for_reboot();
 	tegra_sleep_core_finish(v2p);
 
@@ -342,6 +383,14 @@ static int tegra_suspend_enter(suspend_state_t state)
 
 	cpu_suspend(PHYS_OFFSET - PAGE_OFFSET, tegra_sleep_func);
 
+	/*
+	 * Resume L2 cache if it wasn't re-enabled early during resume,
+	 * which is the case for Tegra30 that has to re-enable the cache
+	 * via firmware call. In other cases cache is already enabled and
+	 * hence re-enabling is a no-op.
+	 */
+	outer_resume();
+
 	switch (mode) {
 	case TEGRA_SUSPEND_LP1:
 		tegra_suspend_exit_lp1();

commit 7e10cf743634a6b0f3cf63046c49294b38254fe9
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Tue Mar 28 13:42:54 2017 +0100

    soc/tegra: Move Tegra flowctrl driver
    
    The flowctrl driver is required for both ARM and ARM64 Tegra devices
    and in order to enable support for it for ARM64, move the Tegra flowctrl
    driver into drivers/soc/tegra.
    
    By moving the flowctrl driver, tegra_flowctrl_init() is now called by
    via an early initcall and to prevent this function from attempting to
    mapping IO space for a non-Tegra device, a test for 'soc_is_tegra()'
    is also added.
    
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index b0f48a3946fa..1ad5719779b0 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -27,6 +27,7 @@
 #include <linux/spinlock.h>
 #include <linux/suspend.h>
 
+#include <soc/tegra/flowctrl.h>
 #include <soc/tegra/fuse.h>
 #include <soc/tegra/pm.h>
 #include <soc/tegra/pmc.h>
@@ -38,7 +39,6 @@
 #include <asm/suspend.h>
 #include <asm/tlbflush.h>
 
-#include "flowctrl.h"
 #include "iomap.h"
 #include "pm.h"
 #include "reset.h"

commit 7232398abc6a7186e315425638c367d50c674718
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Jul 11 13:19:06 2014 +0200

    ARM: tegra: Convert PMC to a driver
    
    This commit converts the PMC support code to a platform driver. Because
    the boot process needs to call into this driver very early, also set up
    a minimal environment via an early initcall.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 94db3b6664df..b0f48a3946fa 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -28,6 +28,8 @@
 #include <linux/suspend.h>
 
 #include <soc/tegra/fuse.h>
+#include <soc/tegra/pm.h>
+#include <soc/tegra/pmc.h>
 
 #include <asm/cacheflush.h>
 #include <asm/idmap.h>
@@ -38,7 +40,6 @@
 
 #include "flowctrl.h"
 #include "iomap.h"
-#include "pmc.h"
 #include "pm.h"
 #include "reset.h"
 #include "sleep.h"
@@ -167,9 +168,29 @@ static int tegra_sleep_cpu(unsigned long v2p)
 	return 0;
 }
 
+static void tegra_pm_set(enum tegra_suspend_mode mode)
+{
+	u32 value;
+
+	switch (tegra_get_chip_id()) {
+	case TEGRA20:
+	case TEGRA30:
+		break;
+	default:
+		/* Turn off CRAIL */
+		value = flowctrl_read_cpu_csr(0);
+		value &= ~FLOW_CTRL_CSR_ENABLE_EXT_MASK;
+		value |= FLOW_CTRL_CSR_ENABLE_EXT_CRAIL;
+		flowctrl_write_cpu_csr(0, value);
+		break;
+	}
+
+	tegra_pmc_enter_suspend_mode(mode);
+}
+
 void tegra_idle_lp2_last(void)
 {
-	tegra_pmc_pm_set(TEGRA_SUSPEND_LP2);
+	tegra_pm_set(TEGRA_SUSPEND_LP2);
 
 	cpu_cluster_pm_enter();
 	suspend_cpu_complex();
@@ -268,8 +289,6 @@ static bool tegra_sleep_core_init(void)
 
 static void tegra_suspend_enter_lp1(void)
 {
-	tegra_pmc_suspend();
-
 	/* copy the reset vector & SDRAM shutdown code into IRAM */
 	memcpy(iram_save_addr, IO_ADDRESS(TEGRA_IRAM_LPx_RESUME_AREA),
 		iram_save_size);
@@ -281,8 +300,6 @@ static void tegra_suspend_enter_lp1(void)
 
 static void tegra_suspend_exit_lp1(void)
 {
-	tegra_pmc_resume();
-
 	/* restore IRAM */
 	memcpy(IO_ADDRESS(TEGRA_IRAM_LPx_RESUME_AREA), iram_save_addr,
 		iram_save_size);
@@ -307,7 +324,7 @@ static int tegra_suspend_enter(suspend_state_t state)
 
 	pr_info("Entering suspend state %s\n", lp_state[mode]);
 
-	tegra_pmc_pm_set(mode);
+	tegra_pm_set(mode);
 
 	local_fiq_disable();
 
@@ -355,7 +372,6 @@ void __init tegra_init_suspend(void)
 		return;
 
 	tegra_tear_down_cpu_init();
-	tegra_pmc_suspend_init();
 
 	if (mode >= TEGRA_SUSPEND_LP1) {
 		if (!tegra_lp1_iram_hook() || !tegra_sleep_core_init()) {

commit 304664eab93f9e95a8d28fbd9702ede88bb10cc5
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Jul 11 09:52:41 2014 +0200

    ARM: tegra: Use a function to get the chip ID
    
    Instead of using a simple variable access to get at the Tegra chip ID,
    use a function so that we can run additional code. This can be used to
    determine where the chip ID is being accessed without being available.
    That in turn will be handy for resolving boot sequence dependencies in
    order to convert more code to regular initcalls rather than a sequence
    fixed by Tegra SoC setup code.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index ae4826e43171..94db3b6664df 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -27,6 +27,8 @@
 #include <linux/spinlock.h>
 #include <linux/suspend.h>
 
+#include <soc/tegra/fuse.h>
+
 #include <asm/cacheflush.h>
 #include <asm/idmap.h>
 #include <asm/proc-fns.h>
@@ -35,7 +37,6 @@
 #include <asm/tlbflush.h>
 
 #include "flowctrl.h"
-#include "fuse.h"
 #include "iomap.h"
 #include "pmc.h"
 #include "pm.h"
@@ -53,7 +54,7 @@ static int (*tegra_sleep_func)(unsigned long v2p);
 
 static void tegra_tear_down_cpu_init(void)
 {
-	switch (tegra_chip_id) {
+	switch (tegra_get_chip_id()) {
 	case TEGRA20:
 		if (IS_ENABLED(CONFIG_ARCH_TEGRA_2x_SOC))
 			tegra_tear_down_cpu = tegra20_tear_down_cpu;
@@ -143,7 +144,7 @@ bool tegra_set_cpu_in_lp2(void)
 
 	if ((phy_cpu_id == 0) && cpumask_equal(cpu_lp2_mask, cpu_online_mask))
 		last_cpu = true;
-	else if (tegra_chip_id == TEGRA20 && phy_cpu_id == 1)
+	else if (tegra_get_chip_id() == TEGRA20 && phy_cpu_id == 1)
 		tegra20_cpu_set_resettable_soon();
 
 	spin_unlock(&tegra_lp2_lock);
@@ -212,7 +213,7 @@ static int tegra_sleep_core(unsigned long v2p)
  */
 static bool tegra_lp1_iram_hook(void)
 {
-	switch (tegra_chip_id) {
+	switch (tegra_get_chip_id()) {
 	case TEGRA20:
 		if (IS_ENABLED(CONFIG_ARCH_TEGRA_2x_SOC))
 			tegra20_lp1_iram_hook();
@@ -242,7 +243,7 @@ static bool tegra_lp1_iram_hook(void)
 
 static bool tegra_sleep_core_init(void)
 {
-	switch (tegra_chip_id) {
+	switch (tegra_get_chip_id()) {
 	case TEGRA20:
 		if (IS_ENABLED(CONFIG_ARCH_TEGRA_2x_SOC))
 			tegra20_sleep_core_init();

commit a0524acc94c91c72c2968a76eddc6f3afe82f9f2
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Jul 11 09:44:49 2014 +0200

    ARM: tegra: Sort includes alphabetically
    
    If these aren't sorted alphabetically, then the logical choice is to
    append new ones, however that creates a lot of potential for conflicts
    because every change will then add new includes in the same location.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index f55b05a29b55..ae4826e43171 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -16,30 +16,30 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <linux/kernel.h>
-#include <linux/spinlock.h>
-#include <linux/io.h>
+#include <linux/clk/tegra.h>
 #include <linux/cpumask.h>
-#include <linux/delay.h>
 #include <linux/cpu_pm.h>
-#include <linux/suspend.h>
+#include <linux/delay.h>
 #include <linux/err.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
 #include <linux/slab.h>
-#include <linux/clk/tegra.h>
+#include <linux/spinlock.h>
+#include <linux/suspend.h>
 
-#include <asm/smp_plat.h>
 #include <asm/cacheflush.h>
-#include <asm/suspend.h>
 #include <asm/idmap.h>
 #include <asm/proc-fns.h>
+#include <asm/smp_plat.h>
+#include <asm/suspend.h>
 #include <asm/tlbflush.h>
 
-#include "iomap.h"
-#include "reset.h"
 #include "flowctrl.h"
 #include "fuse.h"
-#include "pm.h"
+#include "iomap.h"
 #include "pmc.h"
+#include "pm.h"
+#include "reset.h"
 #include "sleep.h"
 
 #ifdef CONFIG_PM_SLEEP

commit 1ff6bbfd13ca2c114a5cb58e1a92d1e5d68ce0b7
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Jan 28 18:10:37 2014 -0500

    arm, pm, vmpressure: add missing slab.h includes
    
    arch/arm/mach-tegra/pm.c, kernel/power/console.c and mm/vmpressure.c
    were somehow getting slab.h indirectly through cgroup.h which in turn
    was getting it indirectly through xattr.h.  A scheduled cgroup change
    drops xattr.h inclusion from cgroup.h and breaks compilation of these
    three files.  Add explicit slab.h includes to the three files.
    
    A pending cgroup patch depends on this change and it'd be great if
    this can be routed through cgroup/for-3.14-fixes branch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: linux-tegra@vger.kernel.org
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: linux-pm@vger.kernel.org
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Balbir Singh <bsingharora@gmail.com>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: cgroups@vger.kernel.org

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 4ae0286b468d..f55b05a29b55 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -24,6 +24,7 @@
 #include <linux/cpu_pm.h>
 #include <linux/suspend.h>
 #include <linux/err.h>
+#include <linux/slab.h>
 #include <linux/clk/tegra.h>
 
 #include <asm/smp_plat.h>

commit f0c4ac1329452e5d31a03b4bb711c330065c0369
Author: Joseph Lo <josephl@nvidia.com>
Date:   Fri Oct 11 17:58:38 2013 +0800

    ARM: tegra: add LP1 support code for Tegra124
    
    The LP1 suspend procedure is the same with Tegra30 and Tegra114. Just
    need to update the difference of the register address, then we can
    continue to share the code.
    
    Signed-off-by: Joseph Lo <josephl@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 36ed88af1cc1..4ae0286b468d 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -59,8 +59,10 @@ static void tegra_tear_down_cpu_init(void)
 		break;
 	case TEGRA30:
 	case TEGRA114:
+	case TEGRA124:
 		if (IS_ENABLED(CONFIG_ARCH_TEGRA_3x_SOC) ||
-		    IS_ENABLED(CONFIG_ARCH_TEGRA_114_SOC))
+		    IS_ENABLED(CONFIG_ARCH_TEGRA_114_SOC) ||
+		    IS_ENABLED(CONFIG_ARCH_TEGRA_124_SOC))
 			tegra_tear_down_cpu = tegra30_tear_down_cpu;
 		break;
 	}
@@ -216,8 +218,10 @@ static bool tegra_lp1_iram_hook(void)
 		break;
 	case TEGRA30:
 	case TEGRA114:
+	case TEGRA124:
 		if (IS_ENABLED(CONFIG_ARCH_TEGRA_3x_SOC) ||
-		    IS_ENABLED(CONFIG_ARCH_TEGRA_114_SOC))
+		    IS_ENABLED(CONFIG_ARCH_TEGRA_114_SOC) ||
+		    IS_ENABLED(CONFIG_ARCH_TEGRA_124_SOC))
 			tegra30_lp1_iram_hook();
 		break;
 	default:
@@ -244,8 +248,10 @@ static bool tegra_sleep_core_init(void)
 		break;
 	case TEGRA30:
 	case TEGRA114:
+	case TEGRA124:
 		if (IS_ENABLED(CONFIG_ARCH_TEGRA_3x_SOC) ||
-		    IS_ENABLED(CONFIG_ARCH_TEGRA_114_SOC))
+		    IS_ENABLED(CONFIG_ARCH_TEGRA_114_SOC) ||
+		    IS_ENABLED(CONFIG_ARCH_TEGRA_124_SOC))
 			tegra30_sleep_core_init();
 		break;
 	default:

commit fddb770dbe468876ea6562e21f817813baa15082
Author: Stephen Warren <swarren@nvidia.com>
Date:   Tue Aug 20 16:19:15 2013 -0600

    ARM: tegra: move resume vector define to irammap.h
    
    irammap.h's purpose is to define the layout/usage of IRAM. As such,
    TEGRA_IRAM_CODE_AREA should have been added there rather than iomap.h.
    Move the define, and rename it something more descriptive.
    
    Cc: Joseph Lo <josephl@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index ed294a04e1d3..36ed88af1cc1 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -263,10 +263,10 @@ static void tegra_suspend_enter_lp1(void)
 	tegra_pmc_suspend();
 
 	/* copy the reset vector & SDRAM shutdown code into IRAM */
-	memcpy(iram_save_addr, IO_ADDRESS(TEGRA_IRAM_CODE_AREA),
-		iram_save_size);
-	memcpy(IO_ADDRESS(TEGRA_IRAM_CODE_AREA), tegra_lp1_iram.start_addr,
+	memcpy(iram_save_addr, IO_ADDRESS(TEGRA_IRAM_LPx_RESUME_AREA),
 		iram_save_size);
+	memcpy(IO_ADDRESS(TEGRA_IRAM_LPx_RESUME_AREA),
+		tegra_lp1_iram.start_addr, iram_save_size);
 
 	*((u32 *)tegra_cpu_lp1_mask) = 1;
 }
@@ -276,7 +276,7 @@ static void tegra_suspend_exit_lp1(void)
 	tegra_pmc_resume();
 
 	/* restore IRAM */
-	memcpy(IO_ADDRESS(TEGRA_IRAM_CODE_AREA), iram_save_addr,
+	memcpy(IO_ADDRESS(TEGRA_IRAM_LPx_RESUME_AREA), iram_save_addr,
 		iram_save_size);
 
 	*(u32 *)tegra_cpu_lp1_mask = 0;

commit bfa664f21b0357f2ad9cdf519f594ece36ec8f64
Merge: 5515d9981f5f b4f173752a56
Author: Kevin Hilman <khilman@linaro.org>
Date:   Wed Aug 21 10:16:55 2013 -0700

    Merge tag 'tegra-for-3.12-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/swarren/linux-tegra into next/soc
    
    From: Stephen Warren:
    ARM: tegra: core SoC enhancements for 3.12
    
    This branch includes a number of enhancements to core SoC support for
    Tegra devices. The major new features are:
    
    * Adds a new CPU-power-gated cpuidle state for Tegra114.
    * Adds initial system suspend support for Tegra114, initially supporting
      just CPU-power-gating during suspend.
    * Adds "LP1" suspend mode support for all of Tegra20/30/114. This mode
      both gates CPU power, and places the DRAM into self-refresh mode.
    * A new DT-driven PCIe driver to Tegra20/30. The driver is also moved
      from arch/arm/mach-tegra/ to drivers/pci/host/.
    
    The PCIe driver work depends on the following tag from Thomas Petazzoni:
    git://git.infradead.org/linux-mvebu.git mis-3.12.2
    ... which is merged into the middle of this pull request.
    
    * tag 'tegra-for-3.12-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/swarren/linux-tegra: (33 commits)
      ARM: tegra: disable LP2 cpuidle state if PCIe is enabled
      MAINTAINERS: Add myself as Tegra PCIe maintainer
      PCI: tegra: set up PADS_REFCLK_CFG1
      PCI: tegra: Add Tegra 30 PCIe support
      PCI: tegra: Move PCIe driver to drivers/pci/host
      PCI: msi: add default MSI operations for !HAVE_GENERIC_HARDIRQS platforms
      ARM: tegra: add LP1 suspend support for Tegra114
      ARM: tegra: add LP1 suspend support for Tegra20
      ARM: tegra: add LP1 suspend support for Tegra30
      ARM: tegra: add common LP1 suspend support
      clk: tegra114: add LP1 suspend/resume support
      ARM: tegra: config the polarity of the request of sys clock
      ARM: tegra: add common resume handling code for LP1 resuming
      ARM: pci: add ->add_bus() and ->remove_bus() hooks to hw_pci
      of: pci: add registry of MSI chips
      PCI: Introduce new MSI chip infrastructure
      PCI: remove ARCH_SUPPORTS_MSI kconfig option
      PCI: use weak functions for MSI arch-specific functions
      ARM: tegra: unify Tegra's Kconfig a bit more
      ARM: tegra: remove the limitation that Tegra114 can't support suspend
      ...
    
    Signed-off-by: Kevin Hilman <khilman@linaro.org>

commit e9f624499cc84a625648ccfbd550b74d17d52fb2
Author: Joseph Lo <josephl@nvidia.com>
Date:   Mon Aug 12 17:40:06 2013 +0800

    ARM: tegra: add LP1 suspend support for Tegra114
    
    The LP1 suspend mode will power off the CPU, clock gated the PLLs and put
    SDRAM to self-refresh mode. Any interrupt can wake up device from LP1. The
    sequence when LP1 suspending:
    
    * tunning off L1 data cache and the MMU
    * storing some EMC registers, DPD (deep power down) status, clk source of
      mselect and SCLK burst policy
    * putting SDRAM into self-refresh
    * switching CPU to CLK_M (12MHz OSC)
    * tunning off PLLM, PLLP, PLLA, PLLC and PLLX
    * switching SCLK to CLK_S (32KHz OSC)
    * shutting off the CPU rail
    
    The sequence of LP1 resuming:
    
    * re-enabling PLLM, PLLP, PLLA, PLLC and PLLX
    * restoring the clk source of mselect and SCLK burst policy
    * setting up CCLK burst policy to PLLX
    * restoring DPD status and some EMC registers
    * resuming SDRAM to normal mode
    * jumping to the "tegra_resume" from PMC_SCRATCH41
    
    Due to the SDRAM will be put into self-refresh mode, the low level
    procedures of LP1 suspending and resuming should be copied to
    TEGRA_IRAM_CODE_AREA (TEGRA_IRAM_BASE + SZ_4K) when suspending. Before
    restoring the CPU context when resuming, the SDRAM needs to be switched
    back to normal mode. And the PLLs need to be re-enabled, SCLK burst policy
    be restored. Then jumping to "tegra_resume" that was expected to be stored
    in PMC_SCRATCH41 to restore CPU context and back to kernel.
    
    Based on the work by: Bo Yan <byan@nvidia.com>
    
    Signed-off-by: Joseph Lo <josephl@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index e718350367e4..eaf6bd372ee1 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -215,7 +215,9 @@ static bool tegra_lp1_iram_hook(void)
 			tegra20_lp1_iram_hook();
 		break;
 	case TEGRA30:
-		if (IS_ENABLED(CONFIG_ARCH_TEGRA_3x_SOC))
+	case TEGRA114:
+		if (IS_ENABLED(CONFIG_ARCH_TEGRA_3x_SOC) ||
+		    IS_ENABLED(CONFIG_ARCH_TEGRA_114_SOC))
 			tegra30_lp1_iram_hook();
 		break;
 	default:
@@ -241,7 +243,9 @@ static bool tegra_sleep_core_init(void)
 			tegra20_sleep_core_init();
 		break;
 	case TEGRA30:
-		if (IS_ENABLED(CONFIG_ARCH_TEGRA_3x_SOC))
+	case TEGRA114:
+		if (IS_ENABLED(CONFIG_ARCH_TEGRA_3x_SOC) ||
+		    IS_ENABLED(CONFIG_ARCH_TEGRA_114_SOC))
 			tegra30_sleep_core_init();
 		break;
 	default:

commit 731a9274382f8e6f4961df79fe12ebcc5431a5df
Author: Joseph Lo <josephl@nvidia.com>
Date:   Mon Aug 12 17:40:05 2013 +0800

    ARM: tegra: add LP1 suspend support for Tegra20
    
    The LP1 suspend mode will power off the CPU, clock gated the PLLs and put
    SDRAM to self-refresh mode. Any interrupt can wake up device from LP1. The
    sequence when LP1 suspending:
    
    * tunning off L1 data cache and the MMU
    * putting SDRAM into self-refresh
    * storing some EMC registers and SCLK burst policy
    * switching CPU to CLK_M (12MHz OSC)
    * switching SCLK to CLK_S (32KHz OSC)
    * tunning off PLLM, PLLP and PLLC
    * shutting off the CPU rail
    
    The sequence of LP1 resuming:
    
    * re-enabling PLLM, PLLP, and PLLC
    * restoring some EMC registers and SCLK burst policy
    * setting up CCLK burst policy to PLLP
    * resuming SDRAM to normal mode
    * jumping to the "tegra_resume" from PMC_SCRATCH41
    
    Due to the SDRAM will be put into self-refresh mode, the low level
    procedures of LP1 suspending and resuming should be copied to
    TEGRA_IRAM_CODE_AREA (TEGRA_IRAM_BASE + SZ_4K) when suspending. Before
    restoring the CPU context when resuming, the SDRAM needs to be switched
    back to normal mode. And the PLLs need to be re-enabled, SCLK burst policy
    be restored, CCLK burst policy be set in PLLP. Then jumping to
    "tegra_resume" that was expected to be stored in PMC_SCRATCH41 to restore
    CPU context and back to kernel.
    
    Based on the work by:
    Colin Cross <ccross@android.com>
    Gary King <gking@nvidia.com>
    
    Signed-off-by: Joseph Lo <josephl@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 7739d5586cb7..e718350367e4 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -210,6 +210,10 @@ static int tegra_sleep_core(unsigned long v2p)
 static bool tegra_lp1_iram_hook(void)
 {
 	switch (tegra_chip_id) {
+	case TEGRA20:
+		if (IS_ENABLED(CONFIG_ARCH_TEGRA_2x_SOC))
+			tegra20_lp1_iram_hook();
+		break;
 	case TEGRA30:
 		if (IS_ENABLED(CONFIG_ARCH_TEGRA_3x_SOC))
 			tegra30_lp1_iram_hook();
@@ -232,6 +236,10 @@ static bool tegra_lp1_iram_hook(void)
 static bool tegra_sleep_core_init(void)
 {
 	switch (tegra_chip_id) {
+	case TEGRA20:
+		if (IS_ENABLED(CONFIG_ARCH_TEGRA_2x_SOC))
+			tegra20_sleep_core_init();
+		break;
 	case TEGRA30:
 		if (IS_ENABLED(CONFIG_ARCH_TEGRA_3x_SOC))
 			tegra30_sleep_core_init();

commit e7a932b1961c3936c7ae5b8d1628f39dc50a746d
Author: Joseph Lo <josephl@nvidia.com>
Date:   Mon Aug 12 17:40:04 2013 +0800

    ARM: tegra: add LP1 suspend support for Tegra30
    
    The LP1 suspend mode will power off the CPU, clock gated the PLLs and put
    SDRAM to self-refresh mode. Any interrupt can wake up device from LP1. The
    sequence when LP1 suspending:
    
    * tunning off L1 data cache and the MMU
    * storing some EMC registers, DPD (deep power down) status, clk source of
      mselect and SCLK burst policy
    * putting SDRAM into self-refresh
    * switching CPU to CLK_M (12MHz OSC)
    * tunning off PLLM, PLLP, PLLA, PLLC and PLLX
    * switching SCLK to CLK_S (32KHz OSC)
    * shutting off the CPU rail
    
    The sequence of LP1 resuming:
    
    * re-enabling PLLM, PLLP, PLLA, PLLC and PLLX
    * restoring the clk source of mselect and SCLK burst policy
    * setting up CCLK burst policy to PLLX
    * restoring DPD status and some EMC registers
    * resuming SDRAM to normal mode
    * jumping to the "tegra_resume" from PMC_SCRATCH41
    
    Due to the SDRAM will be put into self-refresh mode, the low level
    procedures of LP1 suspending and resuming should be copied to
    TEGRA_IRAM_CODE_AREA (TEGRA_IRAM_BASE + SZ_4K) when suspending. Before
    restoring the CPU context when resuming, the SDRAM needs to be switched
    back to normal mode. And the PLLs need to be re-enabled, SCLK burst policy
    be restored, CCLK burst policy be set in PLLX. Then jumping to
    "tegra_resume" that was expected to be stored in PMC_SCRATCH41 to restore
    CPU context and back to kernel.
    
    Based on the work by: Scott Williams <scwilliams@nvidia.com>
    
    Signed-off-by: Joseph Lo <josephl@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 10689924a6a7..7739d5586cb7 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -209,6 +209,15 @@ static int tegra_sleep_core(unsigned long v2p)
  */
 static bool tegra_lp1_iram_hook(void)
 {
+	switch (tegra_chip_id) {
+	case TEGRA30:
+		if (IS_ENABLED(CONFIG_ARCH_TEGRA_3x_SOC))
+			tegra30_lp1_iram_hook();
+		break;
+	default:
+		break;
+	}
+
 	if (!tegra_lp1_iram.start_addr || !tegra_lp1_iram.end_addr)
 		return false;
 
@@ -222,6 +231,15 @@ static bool tegra_lp1_iram_hook(void)
 
 static bool tegra_sleep_core_init(void)
 {
+	switch (tegra_chip_id) {
+	case TEGRA30:
+		if (IS_ENABLED(CONFIG_ARCH_TEGRA_3x_SOC))
+			tegra30_sleep_core_init();
+		break;
+	default:
+		break;
+	}
+
 	if (!tegra_sleep_core_finish)
 		return false;
 

commit 95872f427eca73b19ac9466c25afd9bb876dc1aa
Author: Joseph Lo <josephl@nvidia.com>
Date:   Mon Aug 12 17:40:03 2013 +0800

    ARM: tegra: add common LP1 suspend support
    
    The LP1 suspending mode on Tegra means CPU rail off, devices and PLLs are
    clock gated and SDRAM in self-refresh mode. That means the low level LP1
    suspending and resuming code couldn't be run on DRAM and the CPU must
    switch to the always on clock domain (a.k.a. CLK_M 12MHz oscillator). And
    the system clock (SCLK) would be switched to CLK_S, a 32KHz oscillator.
    The LP1 low level handling code need to be moved to IRAM area first. And
    marking the LP1 mask for indicating the Tegra device is in LP1. The CPU
    power timer needs to be re-calculated based on 32KHz that was originally
    based on PCLK.
    
    When resuming from LP1, the LP1 reset handler will resume PLLs and then
    put DRAM to normal mode. Then jumping to the "tegra_resume" that will
    restore full context before back to kernel. The "tegra_resume" handler
    was expected to be found in PMC_SCRATCH41 register.
    
    This is common LP1 procedures for Tegra, so we do these jobs mainly in
    this patch:
    * moving LP1 low level handling code to IRAM
    * marking LP1 mask
    * copying the physical address of "tegra_resume" to PMC_SCRATCH41
    * re-calculate the CPU power timer based on 32KHz
    
    Signed-off-by: Joseph Lo <josephl@nvidia.com>
    [swarren, replaced IRAM_CODE macro with IO_ADDRESS(TEGRA_IRAM_CODE_AREA)]
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 11bfce9473c1..10689924a6a7 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -37,12 +37,18 @@
 #include "reset.h"
 #include "flowctrl.h"
 #include "fuse.h"
+#include "pm.h"
 #include "pmc.h"
 #include "sleep.h"
 
 #ifdef CONFIG_PM_SLEEP
 static DEFINE_SPINLOCK(tegra_lp2_lock);
+static u32 iram_save_size;
+static void *iram_save_addr;
+struct tegra_lp1_iram tegra_lp1_iram;
 void (*tegra_tear_down_cpu)(void);
+void (*tegra_sleep_core_finish)(unsigned long v2p);
+static int (*tegra_sleep_func)(unsigned long v2p);
 
 static void tegra_tear_down_cpu_init(void)
 {
@@ -174,14 +180,78 @@ enum tegra_suspend_mode tegra_pm_validate_suspend_mode(
 				enum tegra_suspend_mode mode)
 {
 	/*
-	 * The Tegra devices only support suspending to LP2 currently.
+	 * The Tegra devices support suspending to LP1 or lower currently.
 	 */
-	if (mode > TEGRA_SUSPEND_LP2)
-		return TEGRA_SUSPEND_LP2;
+	if (mode > TEGRA_SUSPEND_LP1)
+		return TEGRA_SUSPEND_LP1;
 
 	return mode;
 }
 
+static int tegra_sleep_core(unsigned long v2p)
+{
+	setup_mm_for_reboot();
+	tegra_sleep_core_finish(v2p);
+
+	/* should never here */
+	BUG();
+
+	return 0;
+}
+
+/*
+ * tegra_lp1_iram_hook
+ *
+ * Hooking the address of LP1 reset vector and SDRAM self-refresh code in
+ * SDRAM. These codes not be copied to IRAM in this fuction. We need to
+ * copy these code to IRAM before LP0/LP1 suspend and restore the content
+ * of IRAM after resume.
+ */
+static bool tegra_lp1_iram_hook(void)
+{
+	if (!tegra_lp1_iram.start_addr || !tegra_lp1_iram.end_addr)
+		return false;
+
+	iram_save_size = tegra_lp1_iram.end_addr - tegra_lp1_iram.start_addr;
+	iram_save_addr = kmalloc(iram_save_size, GFP_KERNEL);
+	if (!iram_save_addr)
+		return false;
+
+	return true;
+}
+
+static bool tegra_sleep_core_init(void)
+{
+	if (!tegra_sleep_core_finish)
+		return false;
+
+	return true;
+}
+
+static void tegra_suspend_enter_lp1(void)
+{
+	tegra_pmc_suspend();
+
+	/* copy the reset vector & SDRAM shutdown code into IRAM */
+	memcpy(iram_save_addr, IO_ADDRESS(TEGRA_IRAM_CODE_AREA),
+		iram_save_size);
+	memcpy(IO_ADDRESS(TEGRA_IRAM_CODE_AREA), tegra_lp1_iram.start_addr,
+		iram_save_size);
+
+	*((u32 *)tegra_cpu_lp1_mask) = 1;
+}
+
+static void tegra_suspend_exit_lp1(void)
+{
+	tegra_pmc_resume();
+
+	/* restore IRAM */
+	memcpy(IO_ADDRESS(TEGRA_IRAM_CODE_AREA), iram_save_addr,
+		iram_save_size);
+
+	*(u32 *)tegra_cpu_lp1_mask = 0;
+}
+
 static const char *lp_state[TEGRA_MAX_SUSPEND_MODE] = {
 	[TEGRA_SUSPEND_NONE] = "none",
 	[TEGRA_SUSPEND_LP2] = "LP2",
@@ -205,6 +275,9 @@ static int __cpuinit tegra_suspend_enter(suspend_state_t state)
 
 	suspend_cpu_complex();
 	switch (mode) {
+	case TEGRA_SUSPEND_LP1:
+		tegra_suspend_enter_lp1();
+		break;
 	case TEGRA_SUSPEND_LP2:
 		tegra_set_cpu_in_lp2();
 		break;
@@ -212,9 +285,12 @@ static int __cpuinit tegra_suspend_enter(suspend_state_t state)
 		break;
 	}
 
-	cpu_suspend(PHYS_OFFSET - PAGE_OFFSET, &tegra_sleep_cpu);
+	cpu_suspend(PHYS_OFFSET - PAGE_OFFSET, tegra_sleep_func);
 
 	switch (mode) {
+	case TEGRA_SUSPEND_LP1:
+		tegra_suspend_exit_lp1();
+		break;
 	case TEGRA_SUSPEND_LP2:
 		tegra_clear_cpu_in_lp2();
 		break;
@@ -235,12 +311,36 @@ static const struct platform_suspend_ops tegra_suspend_ops = {
 
 void __init tegra_init_suspend(void)
 {
-	if (tegra_pmc_get_suspend_mode() == TEGRA_SUSPEND_NONE)
+	enum tegra_suspend_mode mode = tegra_pmc_get_suspend_mode();
+
+	if (mode == TEGRA_SUSPEND_NONE)
 		return;
 
 	tegra_tear_down_cpu_init();
 	tegra_pmc_suspend_init();
 
+	if (mode >= TEGRA_SUSPEND_LP1) {
+		if (!tegra_lp1_iram_hook() || !tegra_sleep_core_init()) {
+			pr_err("%s: unable to allocate memory for SDRAM"
+			       "self-refresh -- LP0/LP1 unavailable\n",
+			       __func__);
+			tegra_pmc_set_suspend_mode(TEGRA_SUSPEND_LP2);
+			mode = TEGRA_SUSPEND_LP2;
+		}
+	}
+
+	/* set up sleep function for cpu_suspend */
+	switch (mode) {
+	case TEGRA_SUSPEND_LP1:
+		tegra_sleep_func = tegra_sleep_core;
+		break;
+	case TEGRA_SUSPEND_LP2:
+		tegra_sleep_func = tegra_sleep_cpu;
+		break;
+	default:
+		break;
+	}
+
 	suspend_set_ops(&tegra_suspend_ops);
 }
 #endif

commit 9c0c4b43b194521e2cbf7064fbe35b8ce9e42149
Author: Joseph Lo <josephl@nvidia.com>
Date:   Wed Jul 3 17:50:45 2013 +0800

    ARM: tegra: remove the limitation that Tegra114 can't support suspend
    
    The Tegra114 can support suspend function now, removing the limitation.
    
    Signed-off-by: Joseph Lo <josephl@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 19cf360c7bdd..11bfce9473c1 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -173,10 +173,6 @@ void tegra_idle_lp2_last(void)
 enum tegra_suspend_mode tegra_pm_validate_suspend_mode(
 				enum tegra_suspend_mode mode)
 {
-	/* Tegra114 didn't support any suspending mode yet. */
-	if (tegra_chip_id == TEGRA114)
-		return TEGRA_SUSPEND_NONE;
-
 	/*
 	 * The Tegra devices only support suspending to LP2 currently.
 	 */

commit b573ad9f19ad56938a66c95fbc5122b77951cd5d
Author: Joseph Lo <josephl@nvidia.com>
Date:   Wed Jul 3 17:50:42 2013 +0800

    ARM: tegra: hook tegra_tear_down_cpu function
    
    Hooking tegra_tear_down_cpu for Tegra114 for supporting cluster power
    down when CPU cluster suspneded in LP2.
    
    Signed-off-by: Joseph Lo <josephl@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 94e69bee3da5..19cf360c7bdd 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -52,7 +52,9 @@ static void tegra_tear_down_cpu_init(void)
 			tegra_tear_down_cpu = tegra20_tear_down_cpu;
 		break;
 	case TEGRA30:
-		if (IS_ENABLED(CONFIG_ARCH_TEGRA_3x_SOC))
+	case TEGRA114:
+		if (IS_ENABLED(CONFIG_ARCH_TEGRA_3x_SOC) ||
+		    IS_ENABLED(CONFIG_ARCH_TEGRA_114_SOC))
 			tegra_tear_down_cpu = tegra30_tear_down_cpu;
 		break;
 	}

commit 8bd26e3a7e49af2697449bbcb7187a39dc85d672
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jun 17 15:43:14 2013 -0400

    arm: delete __cpuinit/__CPUINIT usage from all ARM users
    
    The __cpuinit type of throwaway sections might have made sense
    some time ago when RAM was more constrained, but now the savings
    do not offset the cost and complications.  For example, the fix in
    commit 5e427ec2d0 ("x86: Fix bit corruption at CPU resume time")
    is a good example of the nasty type of bugs that can be created
    with improper use of the various __init prefixes.
    
    After a discussion on LKML[1] it was decided that cpuinit should go
    the way of devinit and be phased out.  Once all the users are gone,
    we can then finally remove the macros themselves from linux/init.h.
    
    Note that some harmless section mismatch warnings may result, since
    notify_cpu_starting() and cpu_up() are arch independent (kernel/cpu.c)
    and are flagged as __cpuinit  -- so if we remove the __cpuinit from
    the arch specific callers, we will also get section mismatch warnings.
    As an intermediate step, we intend to turn the linux/init.h cpuinit
    related content into no-ops as early as possible, since that will get
    rid of these warnings.  In any case, they are temporary and harmless.
    
    This removes all the ARM uses of the __cpuinit macros from C code,
    and all __CPUINIT from assembly code.  It also had two ".previous"
    section statements that were paired off against __CPUINIT
    (aka .section ".cpuinit.text") that also get removed here.
    
    [1] https://lkml.org/lkml/2013/5/20/589
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 94e69bee3da5..261fec140c06 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -191,7 +191,7 @@ static const char *lp_state[TEGRA_MAX_SUSPEND_MODE] = {
 	[TEGRA_SUSPEND_LP0] = "LP0",
 };
 
-static int __cpuinit tegra_suspend_enter(suspend_state_t state)
+static int tegra_suspend_enter(suspend_state_t state)
 {
 	enum tegra_suspend_mode mode = tegra_pmc_get_suspend_mode();
 

commit 8f6a0b6528820f9efec36e5843181cc178fa9de8
Author: Joseph Lo <josephl@nvidia.com>
Date:   Tue Jun 4 18:47:35 2013 +0800

    ARM: tegra: don't pass CPU ID to tegra_{set,clear}_cpu_in_lp2
    
    tegra_{set,clear}_cpu_in_lp2 can easily determine which CPU ID they are
    running on; there is no need to pass the CPU ID into those functions.
    So, remove their CPU ID function parameter.
    
    Signed-off-by: Joseph Lo <josephl@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 5e6fb31ba4d9..94e69bee3da5 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -105,8 +105,9 @@ static void suspend_cpu_complex(void)
 	flowctrl_cpu_suspend_enter(cpu);
 }
 
-void tegra_clear_cpu_in_lp2(int phy_cpu_id)
+void tegra_clear_cpu_in_lp2(void)
 {
+	int phy_cpu_id = cpu_logical_map(smp_processor_id());
 	u32 *cpu_in_lp2 = tegra_cpu_lp2_mask;
 
 	spin_lock(&tegra_lp2_lock);
@@ -117,8 +118,9 @@ void tegra_clear_cpu_in_lp2(int phy_cpu_id)
 	spin_unlock(&tegra_lp2_lock);
 }
 
-bool tegra_set_cpu_in_lp2(int phy_cpu_id)
+bool tegra_set_cpu_in_lp2(void)
 {
+	int phy_cpu_id = cpu_logical_map(smp_processor_id());
 	bool last_cpu = false;
 	cpumask_t *cpu_lp2_mask = tegra_cpu_lp2_mask;
 	u32 *cpu_in_lp2 = tegra_cpu_lp2_mask;
@@ -206,7 +208,7 @@ static int __cpuinit tegra_suspend_enter(suspend_state_t state)
 	suspend_cpu_complex();
 	switch (mode) {
 	case TEGRA_SUSPEND_LP2:
-		tegra_set_cpu_in_lp2(0);
+		tegra_set_cpu_in_lp2();
 		break;
 	default:
 		break;
@@ -216,7 +218,7 @@ static int __cpuinit tegra_suspend_enter(suspend_state_t state)
 
 	switch (mode) {
 	case TEGRA_SUSPEND_LP2:
-		tegra_clear_cpu_in_lp2(0);
+		tegra_clear_cpu_in_lp2();
 		break;
 	default:
 		break;

commit bf91add4a0feb7a8624a1f6b3fd4d6dbe9dce1bc
Author: Joseph Lo <josephl@nvidia.com>
Date:   Tue Jun 4 18:47:33 2013 +0800

    ARM: tegra: hook tegra_tear_down_cpu function in the PM suspend init function
    
    The tegra_tear_down_cpu was used to cut off the CPU rail for various Tegra
    SoCs. Hooking it in the PM suspend init function and making the CPUidle
    driver more generic.
    
    Signed-off-by: Joseph Lo <josephl@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 45cf52c7e528..5e6fb31ba4d9 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -44,6 +44,20 @@
 static DEFINE_SPINLOCK(tegra_lp2_lock);
 void (*tegra_tear_down_cpu)(void);
 
+static void tegra_tear_down_cpu_init(void)
+{
+	switch (tegra_chip_id) {
+	case TEGRA20:
+		if (IS_ENABLED(CONFIG_ARCH_TEGRA_2x_SOC))
+			tegra_tear_down_cpu = tegra20_tear_down_cpu;
+		break;
+	case TEGRA30:
+		if (IS_ENABLED(CONFIG_ARCH_TEGRA_3x_SOC))
+			tegra_tear_down_cpu = tegra30_tear_down_cpu;
+		break;
+	}
+}
+
 /*
  * restore_cpu_complex
  *
@@ -224,6 +238,7 @@ void __init tegra_init_suspend(void)
 	if (tegra_pmc_get_suspend_mode() == TEGRA_SUSPEND_NONE)
 		return;
 
+	tegra_tear_down_cpu_init();
 	tegra_pmc_suspend_init();
 
 	suspend_set_ops(&tegra_suspend_ops);

commit 97b1007a2924aaa9126398623f6755a8c3c6a616
Merge: dfab34aa61a0 e0d20b69d3fa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 2 09:31:45 2013 -0700

    Merge tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform updates from Olof Johansson:
     "This branch contains part 1 of the platform updates for 3.10.  Among
      the highlights:
    
       - Support for the new Atmel Cortex-A5 based platforms (SAMA5D3)
       - New support for CSR SiRFatlas6 SoCs
       - A handful of updates for NVidia T114 (a.k.a. Tegra 4)
       - A bunch of updates for the shmobile platforms
       - A handful of updates for davinci
       - A few updates for Qualcomm MSM
       - Plus a handful of other patches, defconfig updates, etc."
    
    * tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (135 commits)
      ARM: tegra: pm: fix build error w/o PM_SLEEP
      ARM: davinci: ensure global variables are declared
      ARM: davinci: sram.c: fix incorrect type in assignment
      ARM: davinci: da8xx dt: make file local symbols static
      ARM: davinci: da8xx: add remoteproc support
      ARM: socfpga: Upgrade clk driver for socfpga to make use of dts clock entries
      ARM: socfpga: Add clock entries into device tree
      ARM: socfpga: Enable soft reset
      ARM: EXYNOS: replace cpumask by the corresponding macro
      ARM: EXYNOS: handle properly the return values
      ARM: EXYNOS: factor out the idle states
      ARM: OMAP4: Enable fix for Cortex-A9 erratas
      ARM: OMAP2+: Export SoC information to userspace
      ARM: OMAP2+: SoC name and revision unification
      ARM: OMAP2+: Move common part of late init into common function
      ARM: tegra: pm: remove duplicated include from pm.c
      ARM: davinci: da850: override mmc DT node device name
      ARM: davinci: da850: add mmc DT entries
      mmc: davinci_mmc: add DT support
      ARM: SAMSUNG: check processor type before cache restoration in resume
      ...

commit a7726350e06401929eac0aa0677a5467106565fc
Merge: 4d26aa305414 afcf7924ecab
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 2 09:03:55 2013 -0700

    Merge tag 'cleanup-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC cleanup from Olof Johansson:
     "Here is a collection of cleanup patches.  Among the pieces that stand
      out are:
    
       - The deletion of h720x platforms
       - Split of at91 non-dt platforms to their own Kconfig file to keep
         them separate
       - General cleanups and refactoring of i.MX and MXS platforms
       - Some restructuring of clock tables for OMAP
       - Convertion of PMC driver for Tegra to dt-only
       - Some renames of sunxi -> sun4i (Allwinner A10)
       - ... plus a bunch of other stuff that I haven't mentioned"
    
    * tag 'cleanup-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (119 commits)
      ARM: i.MX: remove unused ARCH_* configs
      ARM i.MX53: remove platform ahci support
      ARM: sunxi: Rework the restart code
      irqchip: sunxi: Rename sunxi to sun4i
      irqchip: sunxi: Make use of the IRQCHIP_DECLARE macro
      clocksource: sunxi: Rename sunxi to sun4i
      clocksource: sunxi: make use of CLKSRC_OF
      clocksource: sunxi: Cleanup the timer code
      ARM: at91: remove trailing semicolon from macros
      ARM: at91/setup: fix trivial typos
      ARM: EXYNOS: remove "config EXYNOS_DEV_DRM"
      ARM: EXYNOS: change the name of USB ohci header
      ARM: SAMSUNG: Remove unnecessary code for dma
      ARM: S3C24XX: Remove unused GPIO drive strength register definitions
      ARM: OMAP4+: PM: Restore CPU power state to ON with clockdomain force wakeup method
      ARM: S3C24XX: Removed unneeded dependency on CPU_S3C2412
      ARM: S3C24XX: Removed unneeded dependency on CPU_S3C2410
      ARM: S3C24XX: Removed unneeded dependency on ARCH_S3C24XX for boards
      ARM: SAMSUNG: Fix typo "CONFIG_SAMSUNG_DEV_RTC"
      ARM: S5P64X0: Fix typo "CONFIG_S5P64X0_SETUP_SDHCI"
      ...

commit 2058842e6d7833e41be7cc2434465e69bcd51d45
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Apr 23 15:36:26 2013 +0200

    ARM: tegra: call cpu_do_idle from C code
    
    When building a kernel for multiple CPU architecture levels,
    cpu_do_idle() is a macro for an indirect function call, which
    cannot be called from assembly code as Tegra does.
    
    Adding a trivial C wrapper for this function lets us build
    a tegra kernel with ARMv6 support enabled.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Joseph Lo <josephl@nvidia.com>
    Cc: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 0494f739c95f..04a8e06f59a9 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -162,6 +162,11 @@ bool tegra_set_cpu_in_lp2(int phy_cpu_id)
 	return last_cpu;
 }
 
+int tegra_cpu_do_idle(void)
+{
+	return cpu_do_idle();
+}
+
 static int tegra_sleep_cpu(unsigned long v2p)
 {
 	/* Switch to the identity mapping. */

commit 6cd2f8e7da502272248f4bdefcb952a68318e02b
Merge: 3be1812ea3b7 38be85de698e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Apr 9 16:32:20 2013 +0200

    Merge tag 'tegra-for-3.10-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/swarren/linux-tegra into next/soc
    
    From Stephen Warren <swarren@wwwdotorg.org>:
    
    ARM: tegra: core SoC support development
    
    This branch includes major development on the core Tegra SoC support code
    in the mach-tegra directory:
    
    * SMP support for Tegra114.
    * Exposes SoC chip ID and revision through standard sysfs files.
    * System-level suspend/resume for Tegra20/30. At present, this only
      supports "LP2" mode (CPU power-down), but provides the basis to
      implement "LP0"/"LP1" (various levels of core/chip power-down) in the
      hopefully near future.
    * A minor cleanup of a duplicate include, which was introduced in this
      branch.
    
    This branch is based on the previous cleanup pull request.
    
    * tag 'tegra-for-3.10-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/swarren/linux-tegra:
      ARM: tegra: pm: remove duplicated include from pm.c
      ARM: tegra: cpuidle: remove redundant parameters for powered-down mode
      ARM: tegra: pm: add platform suspend support
      ARM: dt: tegra: add bindings of power management configurations for PMC
      ARM: tegra: irq: add wake up handling
      gpio: tegra: add gpio wakeup source handling
      ARM: tegra: moving the CPU power timer function to PMC driver
      ARM: tegra: add clock source of PMC to device trees
      ARM: tegra: add speedo-based process id for Tegra114
      ARM: tegra: expose chip ID and revision
      ARM: tegra: bring up secondary CPU for Tegra114
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 38be85de698ef3f2755ee0eabf520530757860aa
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Fri Apr 5 14:58:52 2013 +0800

    ARM: tegra: pm: remove duplicated include from pm.c
    
    Remove duplicated include.
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 84d8742bdb1e..d0b7400e4606 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -39,7 +39,6 @@
 #include "fuse.h"
 #include "pmc.h"
 #include "sleep.h"
-#include "pmc.h"
 
 #ifdef CONFIG_PM_SLEEP
 static DEFINE_SPINLOCK(tegra_lp2_lock);

commit 4d82d0587b4a964ea3a7c73aa044b433000527dd
Author: Joseph Lo <josephl@nvidia.com>
Date:   Tue Apr 2 01:20:50 2013 +0000

    ARM: tegra: cpuidle: remove redundant parameters for powered-down mode
    
    After the patch series for system suspending support, tegra_idle_lp2_last()
    no longer uses its parameters cpu_on_time or cpu_off_time, so remove them.
    
    Signed-off-by: Joseph Lo <josephl@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 3a3318a83ad3..84d8742bdb1e 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -140,7 +140,7 @@ static int tegra_sleep_cpu(unsigned long v2p)
 	return 0;
 }
 
-void tegra_idle_lp2_last(u32 cpu_on_time, u32 cpu_off_time)
+void tegra_idle_lp2_last(void)
 {
 	tegra_pmc_pm_set(TEGRA_SUSPEND_LP2);
 

commit c8c2e6069065fdecfb195a2c438c7faa964aef22
Author: Joseph Lo <josephl@nvidia.com>
Date:   Wed Apr 3 19:31:47 2013 +0800

    ARM: tegra: pm: add platform suspend support
    
    Adding suspend to RAM support for Tegra platform. There are three suspend
    mode for Tegra. The difference were below.
    
    * LP2: CPU voltage off
    * LP1: CPU voltage off, DRAM in self-refresh
    * LP0: CPU + Core voltage off, DRAM in self-refresh
    
    After this patch, the LP2 suspend mode will be supported.
    
    Signed-off-by: Joseph Lo <josephl@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 5f5611f40b43..3a3318a83ad3 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -22,6 +22,7 @@
 #include <linux/cpumask.h>
 #include <linux/delay.h>
 #include <linux/cpu_pm.h>
+#include <linux/suspend.h>
 #include <linux/err.h>
 #include <linux/clk/tegra.h>
 
@@ -38,14 +39,10 @@
 #include "fuse.h"
 #include "pmc.h"
 #include "sleep.h"
-
-#define TEGRA_POWER_CPU_PWRREQ_OE	(1 << 16)  /* CPU pwr req enable */
-
-#define PMC_CTRL		0x0
+#include "pmc.h"
 
 #ifdef CONFIG_PM_SLEEP
 static DEFINE_SPINLOCK(tegra_lp2_lock);
-static void __iomem *pmc = IO_ADDRESS(TEGRA_PMC_BASE);
 void (*tegra_tear_down_cpu)(void);
 
 /*
@@ -145,14 +142,7 @@ static int tegra_sleep_cpu(unsigned long v2p)
 
 void tegra_idle_lp2_last(u32 cpu_on_time, u32 cpu_off_time)
 {
-	u32 mode;
-
-	/* Only the last cpu down does the final suspend steps */
-	mode = readl(pmc + PMC_CTRL);
-	mode |= TEGRA_POWER_CPU_PWRREQ_OE;
-	writel(mode, pmc + PMC_CTRL);
-
-	set_power_timers(cpu_on_time, cpu_off_time);
+	tegra_pmc_pm_set(TEGRA_SUSPEND_LP2);
 
 	cpu_cluster_pm_enter();
 	suspend_cpu_complex();
@@ -162,4 +152,81 @@ void tegra_idle_lp2_last(u32 cpu_on_time, u32 cpu_off_time)
 	restore_cpu_complex();
 	cpu_cluster_pm_exit();
 }
+
+enum tegra_suspend_mode tegra_pm_validate_suspend_mode(
+				enum tegra_suspend_mode mode)
+{
+	/* Tegra114 didn't support any suspending mode yet. */
+	if (tegra_chip_id == TEGRA114)
+		return TEGRA_SUSPEND_NONE;
+
+	/*
+	 * The Tegra devices only support suspending to LP2 currently.
+	 */
+	if (mode > TEGRA_SUSPEND_LP2)
+		return TEGRA_SUSPEND_LP2;
+
+	return mode;
+}
+
+static const char *lp_state[TEGRA_MAX_SUSPEND_MODE] = {
+	[TEGRA_SUSPEND_NONE] = "none",
+	[TEGRA_SUSPEND_LP2] = "LP2",
+	[TEGRA_SUSPEND_LP1] = "LP1",
+	[TEGRA_SUSPEND_LP0] = "LP0",
+};
+
+static int __cpuinit tegra_suspend_enter(suspend_state_t state)
+{
+	enum tegra_suspend_mode mode = tegra_pmc_get_suspend_mode();
+
+	if (WARN_ON(mode < TEGRA_SUSPEND_NONE ||
+		    mode >= TEGRA_MAX_SUSPEND_MODE))
+		return -EINVAL;
+
+	pr_info("Entering suspend state %s\n", lp_state[mode]);
+
+	tegra_pmc_pm_set(mode);
+
+	local_fiq_disable();
+
+	suspend_cpu_complex();
+	switch (mode) {
+	case TEGRA_SUSPEND_LP2:
+		tegra_set_cpu_in_lp2(0);
+		break;
+	default:
+		break;
+	}
+
+	cpu_suspend(PHYS_OFFSET - PAGE_OFFSET, &tegra_sleep_cpu);
+
+	switch (mode) {
+	case TEGRA_SUSPEND_LP2:
+		tegra_clear_cpu_in_lp2(0);
+		break;
+	default:
+		break;
+	}
+	restore_cpu_complex();
+
+	local_fiq_enable();
+
+	return 0;
+}
+
+static const struct platform_suspend_ops tegra_suspend_ops = {
+	.valid		= suspend_valid_only_mem,
+	.enter		= tegra_suspend_enter,
+};
+
+void __init tegra_init_suspend(void)
+{
+	if (tegra_pmc_get_suspend_mode() == TEGRA_SUSPEND_NONE)
+		return;
+
+	tegra_pmc_suspend_init();
+
+	suspend_set_ops(&tegra_suspend_ops);
+}
 #endif

commit 0337c3e0c3cbbb3a4f411c292f52fcc314abae67
Author: Joseph Lo <josephl@nvidia.com>
Date:   Wed Apr 3 19:31:28 2013 +0800

    ARM: tegra: moving the CPU power timer function to PMC driver
    
    The CPU power timer set up function was related to PMC register. Now moving
    it to PMC driver. And it also help to clean up the PM related code later.
    
    The timer was calculated based on the input clock of PMC. In this patch, we
    also get the clock from DT.
    
    Signed-off-by: Joseph Lo <josephl@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 0494f739c95f..5f5611f40b43 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -22,7 +22,6 @@
 #include <linux/cpumask.h>
 #include <linux/delay.h>
 #include <linux/cpu_pm.h>
-#include <linux/clk.h>
 #include <linux/err.h>
 #include <linux/clk/tegra.h>
 
@@ -37,52 +36,18 @@
 #include "reset.h"
 #include "flowctrl.h"
 #include "fuse.h"
+#include "pmc.h"
 #include "sleep.h"
 
 #define TEGRA_POWER_CPU_PWRREQ_OE	(1 << 16)  /* CPU pwr req enable */
 
 #define PMC_CTRL		0x0
-#define PMC_CPUPWRGOOD_TIMER	0xc8
-#define PMC_CPUPWROFF_TIMER	0xcc
 
 #ifdef CONFIG_PM_SLEEP
 static DEFINE_SPINLOCK(tegra_lp2_lock);
 static void __iomem *pmc = IO_ADDRESS(TEGRA_PMC_BASE);
-static struct clk *tegra_pclk;
 void (*tegra_tear_down_cpu)(void);
 
-static void set_power_timers(unsigned long us_on, unsigned long us_off)
-{
-	unsigned long long ticks;
-	unsigned long long pclk;
-	unsigned long rate;
-	static unsigned long tegra_last_pclk;
-
-	if (tegra_pclk == NULL) {
-		tegra_pclk = clk_get_sys(NULL, "pclk");
-		WARN_ON(IS_ERR(tegra_pclk));
-	}
-
-	rate = clk_get_rate(tegra_pclk);
-
-	if (WARN_ON_ONCE(rate <= 0))
-		pclk = 100000000;
-	else
-		pclk = rate;
-
-	if ((rate != tegra_last_pclk)) {
-		ticks = (us_on * pclk) + 999999ull;
-		do_div(ticks, 1000000);
-		writel((unsigned long)ticks, pmc + PMC_CPUPWRGOOD_TIMER);
-
-		ticks = (us_off * pclk) + 999999ull;
-		do_div(ticks, 1000000);
-		writel((unsigned long)ticks, pmc + PMC_CPUPWROFF_TIMER);
-		wmb();
-	}
-	tegra_last_pclk = pclk;
-}
-
 /*
  * restore_cpu_complex
  *

commit 6affb4826405dc1f53bae0e5c302a18f734a44ca
Author: Will Deacon <will.deacon@arm.com>
Date:   Mon Mar 25 18:19:11 2013 +0000

    ARM: tegra: use setup_mm_for_reboot rather than explicit pgd switch
    
    This patch changes the Tegra PM code to use the setup_mm_for_reboot
    helper rather than call cpu_switch_mm directly. This keeps things like
    TLB invalidation in one place.
    
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 0494f739c95f..acacbe8d1afc 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -164,12 +164,7 @@ bool tegra_set_cpu_in_lp2(int phy_cpu_id)
 
 static int tegra_sleep_cpu(unsigned long v2p)
 {
-	/* Switch to the identity mapping. */
-	cpu_switch_mm(idmap_pgd, &init_mm);
-
-	/* Flush the TLB. */
-	local_flush_tlb_all();
-
+	setup_mm_for_reboot();
 	tegra_sleep_cpu_finish(v2p);
 
 	/* should never here */

commit 02e75d648899df96b79a4f98380679f48b91e3d4
Author: Stephen Warren <swarren@nvidia.com>
Date:   Mon Mar 4 17:05:57 2013 -0700

    ARM: tegra: remove save/restore of CPU diag register
    
    Prior to this change, {save,restore}_cpu_arch_register() collaborated to
    maintain the value of the CPU diagnostic register across power cycles.
    This was required to maintain any CPU errata workaround enable bits in
    that register. However, now that the Tegra reset vector code always
    enables all required workarounds, there is no need to save and restore
    the diagnostic register; it is always explicitly programmed in the
    required manner.
    
    Hence, remove the save/restore logic.
    
    This has the advantage that the kernel always directly controls the value
    of this register every boot, rather than relying on a bootloader or other
    kernel code having previously written the correct value into it. This
    makes CPU0 (which was previously saved/restored) and CPUn (which should
    have been set up by the reset vector) be controlled in exactly the same
    way, which is easier to debug/find/...
    
    In particular, when converting Tegra to a multi-platform kernel, the CPU0
    diagnostic register value initially comes from the bootloader. Most Tegra
    bootloaders don't yet enable all required CPU bug workarounds. The
    previous commit updates the kernel to do so on any CPU power cycle.
    However, the save/restore code ends up over-writing the value with the
    old bootloader-driven value instead of the now more-likely-to-be-correct
    kernel value!
    
    Even irrespective of multi-platform conversion, this change limits the
    kernel's exposure to any WARs the bootloader didn't enable for CPU0: on
    the very first LP2 transition (CPU power-saving which power-cycles the
    CPU), the correct value will be enabled.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 523604de666f..0494f739c95f 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -46,26 +46,11 @@
 #define PMC_CPUPWROFF_TIMER	0xcc
 
 #ifdef CONFIG_PM_SLEEP
-static unsigned int g_diag_reg;
 static DEFINE_SPINLOCK(tegra_lp2_lock);
 static void __iomem *pmc = IO_ADDRESS(TEGRA_PMC_BASE);
 static struct clk *tegra_pclk;
 void (*tegra_tear_down_cpu)(void);
 
-void save_cpu_arch_register(void)
-{
-	/* read diagnostic register */
-	asm("mrc p15, 0, %0, c15, c0, 1" : "=r"(g_diag_reg) : : "cc");
-	return;
-}
-
-void restore_cpu_arch_register(void)
-{
-	/* write diagnostic register */
-	asm("mcr p15, 0, %0, c15, c0, 1" : : "r"(g_diag_reg) : "cc");
-	return;
-}
-
 static void set_power_timers(unsigned long us_on, unsigned long us_off)
 {
 	unsigned long long ticks;
@@ -119,8 +104,6 @@ static void restore_cpu_complex(void)
 	tegra_cpu_clock_resume();
 
 	flowctrl_cpu_suspend_exit(cpu);
-
-	restore_cpu_arch_register();
 }
 
 /*
@@ -145,8 +128,6 @@ static void suspend_cpu_complex(void)
 	tegra_cpu_clock_suspend();
 
 	flowctrl_cpu_suspend_enter(cpu);
-
-	save_cpu_arch_register();
 }
 
 void tegra_clear_cpu_in_lp2(int phy_cpu_id)

commit 5c1350bdfcebf47b3b6f83d62e5860259858a54a
Author: Joseph Lo <josephl@nvidia.com>
Date:   Tue Jan 15 22:10:38 2013 +0000

    ARM: tegra20: cpuidle: add powered-down state for secondary CPU
    
    The powered-down state of Tegra20 requires power gating both CPU cores.
    When the secondary CPU requests to enter powered-down state, it saves
    its own contexts and then enters WFI. The Tegra20 had a limition to
    power down both CPU cores. The secondary CPU must waits for CPU0 in
    powered-down state too. If the secondary CPU be woken up before CPU0
    entering powered-down state, then it needs to restore its CPU states
    and waits for next chance.
    
    Be aware of that, you may see the legacy power state "LP2" in the code
    which is exactly the same meaning of "CPU power down".
    
    Based on the work by:
    Colin Cross <ccross@android.com>
    Gary King <gking@nvidia.com>
    
    Signed-off-by: Joseph Lo <josephl@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index abfe9b93cc0c..523604de666f 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -36,6 +36,7 @@
 #include "iomap.h"
 #include "reset.h"
 #include "flowctrl.h"
+#include "fuse.h"
 #include "sleep.h"
 
 #define TEGRA_POWER_CPU_PWRREQ_OE	(1 << 16)  /* CPU pwr req enable */
@@ -173,6 +174,8 @@ bool tegra_set_cpu_in_lp2(int phy_cpu_id)
 
 	if ((phy_cpu_id == 0) && cpumask_equal(cpu_lp2_mask, cpu_online_mask))
 		last_cpu = true;
+	else if (tegra_chip_id == TEGRA20 && phy_cpu_id == 1)
+		tegra20_cpu_set_resettable_soon();
 
 	spin_unlock(&tegra_lp2_lock);
 	return last_cpu;

commit 89572c77cdffdf24f8fec50d3e38db6a18c04dbe
Author: Prashant Gaikwad <pgaikwad@nvidia.com>
Date:   Fri Jan 11 13:16:21 2013 +0530

    ARM: tegra: move tegra_cpu_car.h to linux/clk/tegra.h
    
    tegra_cpu_car_ops struct is going to be accessed from drivers/clk/tegra.
    Move the tegra_cpu_car_ops to include/linux/clk/tegra.h.
    
    Signed-off-by: Prashant Gaikwad <pgaikwad@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 498d70b33775..abfe9b93cc0c 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -24,6 +24,7 @@
 #include <linux/cpu_pm.h>
 #include <linux/clk.h>
 #include <linux/err.h>
+#include <linux/clk/tegra.h>
 
 #include <asm/smp_plat.h>
 #include <asm/cacheflush.h>
@@ -36,7 +37,6 @@
 #include "reset.h"
 #include "flowctrl.h"
 #include "sleep.h"
-#include "tegra_cpu_car.h"
 
 #define TEGRA_POWER_CPU_PWRREQ_OE	(1 << 16)  /* CPU pwr req enable */
 

commit 8c627fa6583a4894189a47a0bf868f7848b51748
Author: Joseph Lo <josephl@nvidia.com>
Date:   Fri Jan 4 17:32:21 2013 +0800

    ARM: tegra: clean up the CPUINIT section
    
    There are some redundant codes in the CPUINIT section that was caused by
    some codes not be organized well in "headsmp.S". Currently all the codes
    in "headsmp.S" were put into CPUINIT section. But actually it doesn't
    need to be loacted in CPUINIT section. There is no fuction access them
    in CPUINIT section and we will relocate them to IRAM.
    
    These codes also caused some unnecessary functions that access these
    codes been put into CPUINIT section too. This patch clean it up and put
    them into normal text section.
    
    Signed-off-by: Joseph Lo <josephl@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 1b11707eaca0..498d70b33775 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -148,7 +148,7 @@ static void suspend_cpu_complex(void)
 	save_cpu_arch_register();
 }
 
-void __cpuinit tegra_clear_cpu_in_lp2(int phy_cpu_id)
+void tegra_clear_cpu_in_lp2(int phy_cpu_id)
 {
 	u32 *cpu_in_lp2 = tegra_cpu_lp2_mask;
 
@@ -160,7 +160,7 @@ void __cpuinit tegra_clear_cpu_in_lp2(int phy_cpu_id)
 	spin_unlock(&tegra_lp2_lock);
 }
 
-bool __cpuinit tegra_set_cpu_in_lp2(int phy_cpu_id)
+bool tegra_set_cpu_in_lp2(int phy_cpu_id)
 {
 	bool last_cpu = false;
 	cpumask_t *cpu_lp2_mask = tegra_cpu_lp2_mask;

commit 29a0e7beab8e05be53d5b9c050253a4dc417041e
Author: Joseph Lo <josephl@nvidia.com>
Date:   Tue Nov 13 10:04:48 2012 +0800

    ARM: tegra: retain L2 content over CPU suspend/resume
    
    The L2 RAM is in different power domain from the CPU cluster. So the
    L2 content can be retained over CPU suspend/resume. To do that, we
    need to disable L2 after the MMU is disabled, and enable L2 before
    the MMU is enabled. But the L2 controller is in the same power domain
    with the CPU cluster. We need to restore it's settings and re-enable
    it after the power be resumed.
    
    Signed-off-by: Joseph Lo <josephl@nvidia.com>
    Acked-by: Peter De Schrijver <pdeschrijver@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index 1460c3db8245..1b11707eaca0 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -207,11 +207,9 @@ void tegra_idle_lp2_last(u32 cpu_on_time, u32 cpu_off_time)
 
 	cpu_cluster_pm_enter();
 	suspend_cpu_complex();
-	outer_disable();
 
 	cpu_suspend(PHYS_OFFSET - PAGE_OFFSET, &tegra_sleep_cpu);
 
-	outer_resume();
 	restore_cpu_complex();
 	cpu_cluster_pm_exit();
 }

commit d552920a02759cdc45d8507868de10ac2f5b9a18
Author: Joseph Lo <josephl@nvidia.com>
Date:   Wed Oct 31 17:41:21 2012 +0800

    ARM: tegra30: cpuidle: add powered-down state for CPU0
    
    This is a power gating idle mode. It support power gating vdd_cpu rail
    after all cpu cores in "powered-down" status. For Tegra30, the CPU0 can
    enter this state only when all secondary CPU is offline. We need to take
    care and make sure whole secondary CPUs were offline and checking the
    CPU power gate status. After that, the CPU0 can go into "powered-down"
    state safely. Then shut off the CPU rail.
    
    Be aware of that, you may see the legacy power state "LP2" in the code
    which is exactly the same meaning of "CPU power down".
    
    Base on the work by:
    Scott Williams <scwilliams@nvidia.com>
    
    Signed-off-by: Joseph Lo <josephl@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
index f88595abc471..1460c3db8245 100644
--- a/arch/arm/mach-tegra/pm.c
+++ b/arch/arm/mach-tegra/pm.c
@@ -20,13 +20,36 @@
 #include <linux/spinlock.h>
 #include <linux/io.h>
 #include <linux/cpumask.h>
+#include <linux/delay.h>
+#include <linux/cpu_pm.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+
+#include <asm/smp_plat.h>
+#include <asm/cacheflush.h>
+#include <asm/suspend.h>
+#include <asm/idmap.h>
+#include <asm/proc-fns.h>
+#include <asm/tlbflush.h>
 
 #include "iomap.h"
 #include "reset.h"
+#include "flowctrl.h"
+#include "sleep.h"
+#include "tegra_cpu_car.h"
+
+#define TEGRA_POWER_CPU_PWRREQ_OE	(1 << 16)  /* CPU pwr req enable */
+
+#define PMC_CTRL		0x0
+#define PMC_CPUPWRGOOD_TIMER	0xc8
+#define PMC_CPUPWROFF_TIMER	0xcc
 
 #ifdef CONFIG_PM_SLEEP
 static unsigned int g_diag_reg;
 static DEFINE_SPINLOCK(tegra_lp2_lock);
+static void __iomem *pmc = IO_ADDRESS(TEGRA_PMC_BASE);
+static struct clk *tegra_pclk;
+void (*tegra_tear_down_cpu)(void);
 
 void save_cpu_arch_register(void)
 {
@@ -42,6 +65,89 @@ void restore_cpu_arch_register(void)
 	return;
 }
 
+static void set_power_timers(unsigned long us_on, unsigned long us_off)
+{
+	unsigned long long ticks;
+	unsigned long long pclk;
+	unsigned long rate;
+	static unsigned long tegra_last_pclk;
+
+	if (tegra_pclk == NULL) {
+		tegra_pclk = clk_get_sys(NULL, "pclk");
+		WARN_ON(IS_ERR(tegra_pclk));
+	}
+
+	rate = clk_get_rate(tegra_pclk);
+
+	if (WARN_ON_ONCE(rate <= 0))
+		pclk = 100000000;
+	else
+		pclk = rate;
+
+	if ((rate != tegra_last_pclk)) {
+		ticks = (us_on * pclk) + 999999ull;
+		do_div(ticks, 1000000);
+		writel((unsigned long)ticks, pmc + PMC_CPUPWRGOOD_TIMER);
+
+		ticks = (us_off * pclk) + 999999ull;
+		do_div(ticks, 1000000);
+		writel((unsigned long)ticks, pmc + PMC_CPUPWROFF_TIMER);
+		wmb();
+	}
+	tegra_last_pclk = pclk;
+}
+
+/*
+ * restore_cpu_complex
+ *
+ * restores cpu clock setting, clears flow controller
+ *
+ * Always called on CPU 0.
+ */
+static void restore_cpu_complex(void)
+{
+	int cpu = smp_processor_id();
+
+	BUG_ON(cpu != 0);
+
+#ifdef CONFIG_SMP
+	cpu = cpu_logical_map(cpu);
+#endif
+
+	/* Restore the CPU clock settings */
+	tegra_cpu_clock_resume();
+
+	flowctrl_cpu_suspend_exit(cpu);
+
+	restore_cpu_arch_register();
+}
+
+/*
+ * suspend_cpu_complex
+ *
+ * saves pll state for use by restart_plls, prepares flow controller for
+ * transition to suspend state
+ *
+ * Must always be called on cpu 0.
+ */
+static void suspend_cpu_complex(void)
+{
+	int cpu = smp_processor_id();
+
+	BUG_ON(cpu != 0);
+
+#ifdef CONFIG_SMP
+	cpu = cpu_logical_map(cpu);
+#endif
+
+	/* Save the CPU clock settings */
+	tegra_cpu_clock_suspend();
+
+	flowctrl_cpu_suspend_enter(cpu);
+
+	save_cpu_arch_register();
+}
+
 void __cpuinit tegra_clear_cpu_in_lp2(int phy_cpu_id)
 {
 	u32 *cpu_in_lp2 = tegra_cpu_lp2_mask;
@@ -71,4 +177,42 @@ bool __cpuinit tegra_set_cpu_in_lp2(int phy_cpu_id)
 	spin_unlock(&tegra_lp2_lock);
 	return last_cpu;
 }
+
+static int tegra_sleep_cpu(unsigned long v2p)
+{
+	/* Switch to the identity mapping. */
+	cpu_switch_mm(idmap_pgd, &init_mm);
+
+	/* Flush the TLB. */
+	local_flush_tlb_all();
+
+	tegra_sleep_cpu_finish(v2p);
+
+	/* should never here */
+	BUG();
+
+	return 0;
+}
+
+void tegra_idle_lp2_last(u32 cpu_on_time, u32 cpu_off_time)
+{
+	u32 mode;
+
+	/* Only the last cpu down does the final suspend steps */
+	mode = readl(pmc + PMC_CTRL);
+	mode |= TEGRA_POWER_CPU_PWRREQ_OE;
+	writel(mode, pmc + PMC_CTRL);
+
+	set_power_timers(cpu_on_time, cpu_off_time);
+
+	cpu_cluster_pm_enter();
+	suspend_cpu_complex();
+	outer_disable();
+
+	cpu_suspend(PHYS_OFFSET - PAGE_OFFSET, &tegra_sleep_cpu);
+
+	outer_resume();
+	restore_cpu_complex();
+	cpu_cluster_pm_exit();
+}
 #endif

commit d457ef358f3c7179c428becda45b1dfd2b8cf98a
Author: Joseph Lo <josephl@nvidia.com>
Date:   Wed Oct 31 17:41:17 2012 +0800

    ARM: tegra30: cpuidle: add powered-down state for secondary CPUs
    
    This supports power-gated idle on secondary CPUs for Tegra30. The
    secondary CPUs can go into powered-down state independently. When
    CPU goes into this state, it saves it's contexts and puts itself
    to flow controlled WFI state. After that, it will been power gated.
    
    Be aware of that, you may see the legacy power state "LP2" in the
    code which is exactly the same meaning of "CPU power down".
    
    Based on the work by:
    Scott Williams <scwilliams@nvidia.com>
    
    Signed-off-by: Joseph Lo <josephl@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-tegra/pm.c b/arch/arm/mach-tegra/pm.c
new file mode 100644
index 000000000000..f88595abc471
--- /dev/null
+++ b/arch/arm/mach-tegra/pm.c
@@ -0,0 +1,74 @@
+/*
+ * CPU complex suspend & resume functions for Tegra SoCs
+ *
+ * Copyright (c) 2009-2012, NVIDIA Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+#include <linux/cpumask.h>
+
+#include "iomap.h"
+#include "reset.h"
+
+#ifdef CONFIG_PM_SLEEP
+static unsigned int g_diag_reg;
+static DEFINE_SPINLOCK(tegra_lp2_lock);
+
+void save_cpu_arch_register(void)
+{
+	/* read diagnostic register */
+	asm("mrc p15, 0, %0, c15, c0, 1" : "=r"(g_diag_reg) : : "cc");
+	return;
+}
+
+void restore_cpu_arch_register(void)
+{
+	/* write diagnostic register */
+	asm("mcr p15, 0, %0, c15, c0, 1" : : "r"(g_diag_reg) : "cc");
+	return;
+}
+
+void __cpuinit tegra_clear_cpu_in_lp2(int phy_cpu_id)
+{
+	u32 *cpu_in_lp2 = tegra_cpu_lp2_mask;
+
+	spin_lock(&tegra_lp2_lock);
+
+	BUG_ON(!(*cpu_in_lp2 & BIT(phy_cpu_id)));
+	*cpu_in_lp2 &= ~BIT(phy_cpu_id);
+
+	spin_unlock(&tegra_lp2_lock);
+}
+
+bool __cpuinit tegra_set_cpu_in_lp2(int phy_cpu_id)
+{
+	bool last_cpu = false;
+	cpumask_t *cpu_lp2_mask = tegra_cpu_lp2_mask;
+	u32 *cpu_in_lp2 = tegra_cpu_lp2_mask;
+
+	spin_lock(&tegra_lp2_lock);
+
+	BUG_ON((*cpu_in_lp2 & BIT(phy_cpu_id)));
+	*cpu_in_lp2 |= BIT(phy_cpu_id);
+
+	if ((phy_cpu_id == 0) && cpumask_equal(cpu_lp2_mask, cpu_online_mask))
+		last_cpu = true;
+
+	spin_unlock(&tegra_lp2_lock);
+	return last_cpu;
+}
+#endif
