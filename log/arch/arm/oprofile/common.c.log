commit 96d4f267e40f9509e8a66e2b39e8b95655617693
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 3 18:57:57 2019 -0800

    Remove 'type' argument from access_ok() function
    
    Nobody has actually used the type (VERIFY_READ vs VERIFY_WRITE) argument
    of the user address range verification function since we got rid of the
    old racy i386-only code to walk page tables by hand.
    
    It existed because the original 80386 would not honor the write protect
    bit when in kernel mode, so you had to do COW by hand before doing any
    user access.  But we haven't supported that in a long time, and these
    days the 'type' argument is a purely historical artifact.
    
    A discussion about extending 'user_access_begin()' to do the range
    checking resulted this patch, because there is no way we're going to
    move the old VERIFY_xyz interface to that model.  And it's best done at
    the end of the merge window when I've done most of my merges, so let's
    just get this done once and for all.
    
    This patch was mostly done with a sed-script, with manual fix-ups for
    the cases that weren't of the trivial 'access_ok(VERIFY_xyz' form.
    
    There were a couple of notable cases:
    
     - csky still had the old "verify_area()" name as an alias.
    
     - the iter_iov code had magical hardcoded knowledge of the actual
       values of VERIFY_{READ,WRITE} (not that they mattered, since nothing
       really used it)
    
     - microblaze used the type argument for a debug printout
    
    but other than those oddities this should be a total no-op patch.
    
    I tried to fix up all architectures, did fairly extensive grepping for
    access_ok() uses, and the changes are trivial, but I may have missed
    something.  Any missed conversion should be trivially fixable, though.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index cc649a1e46da..7cb3e0453fcd 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -88,7 +88,7 @@ static struct frame_tail* user_backtrace(struct frame_tail *tail)
 	struct frame_tail buftail[2];
 
 	/* Also check accessibility of one struct frame_tail beyond */
-	if (!access_ok(VERIFY_READ, tail, sizeof(buftail)))
+	if (!access_ok(tail, sizeof(buftail)))
 		return NULL;
 	if (__copy_from_user_inatomic(buftail, tail, sizeof(buftail)))
 		return NULL;

commit f15bdfe4fb264ac30d9c176f898cbd52cfd1ffa9
Merge: c89c3a6acb84 c70fbb01b11c
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Aug 5 10:27:25 2014 +0100

    Merge branch 'devel-stable' into for-next
    
    Conflicts:
            arch/arm/kernel/perf_event_cpu.c

commit e8a5dbc59e5ef7b120635fe8a57643f3bbbd0919
Author: Nikolay Borisov <Nikolay.Borisov@arm.com>
Date:   Tue Jun 3 19:51:32 2014 +0100

    ARM: 8075/1: oprofile: Use of arm_get_current_stackframe
    
    Use the newly introduced API so that FP is correctly referenced from
    either R7/R11 based on whether we are running in THUMB2 mode or not.
    
    Signed-off-by: Nikolay Borisov <Nikolay.Borisov@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Robert Richter <rric@kernel.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index 99c63d4b6af8..e6a3c4c92163 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -107,10 +107,7 @@ static void arm_backtrace(struct pt_regs * const regs, unsigned int depth)
 
 	if (!user_mode(regs)) {
 		struct stackframe frame;
-		frame.fp = regs->ARM_fp;
-		frame.sp = regs->ARM_sp;
-		frame.lr = regs->ARM_lr;
-		frame.pc = regs->ARM_pc;
+		arm_get_current_stackframe(regs, &frame);
 		walk_stackframe(&frame, report_trace, &depth);
 		return;
 	}

commit 3d1ff755e36705ad9ec96f740edc08d20c3e9a87
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Wed Dec 19 16:33:24 2012 +0000

    arm: perf: clean up PMU names
    
    The perf userspace tools can't handle dashes or spaces in PMU names,
    which conflicts with the current naming scheme in the arm perf backend.
    This prevents these PMUs from being accessed by name from the perf
    tools. Additionally the ARMv6 pmus are named "v6", which does not fully
    distinguish them in the sys/bus/event_source namespace.
    
    This patch renames the PMUs consistently to a lower case form with
    underscores, e.g. "armv6_1176", "armv7_cortex_a9". This is both readily
    accepted by today's perf tool, and far easier to type than the
    (apparently unused) convention in use previously. The OProfile name
    conversion code is updated to handle this.
    
    Due to a copy-paste error involving two "xscale1" entries, "xscale2" has
    never been matched by the name OProfile name mapping. While we're
    updating names, this is corrected.
    
    Acked-by: Will Deacon <will.deacon@arm.com>
    Tested-by: Christopher Covington <cov@codeaurora.org>
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    [sachin: fixed missing semicolons in armv6 backend]
    Signed-off-by: Sachin Kamat <sachin.kamat@samsung.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index 99c63d4b6af8..6826e3571df9 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -33,12 +33,14 @@ static struct op_perf_name {
 	char *perf_name;
 	char *op_name;
 } op_perf_name_map[] = {
-	{ "xscale1",		"arm/xscale1"	},
-	{ "xscale1",		"arm/xscale2"	},
-	{ "v6",			"arm/armv6"	},
-	{ "v6mpcore",		"arm/mpcore"	},
-	{ "ARMv7 Cortex-A8",	"arm/armv7"	},
-	{ "ARMv7 Cortex-A9",	"arm/armv7-ca9"	},
+	{ "armv5_xscale1",	"arm/xscale1"	},
+	{ "armv5_xscale2",	"arm/xscale2"	},
+	{ "armv6_1136",		"arm/armv6"	},
+	{ "armv6_1156",		"arm/armv6"	},
+	{ "armv6_1176",		"arm/armv6"	},
+	{ "armv6_11mpcore",	"arm/mpcore"	},
+	{ "armv7_cortex_a8",	"arm/armv7"	},
+	{ "armv7_cortex_a9",	"arm/armv7-ca9"	},
 };
 
 char *op_name_from_perf_id(void)

commit 4295b898f5a5c7e62ae68e7a4ecc4b414622ffe6
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Jul 6 15:45:00 2012 +0100

    ARM: 7448/1: perf: remove arm_perf_pmu_ids global enumeration
    
    In order to provide PMU name strings compatible with the OProfile
    user ABI, an enumeration of all PMUs is currently used by perf to
    identify each PMU uniquely. Unfortunately, this does not scale well
    in the presence of multiple PMUs and creates a single, global namespace
    across all PMUs in the system.
    
    This patch removes the enumeration and instead uses the name string
    for the PMU to map onto the OProfile variant. perf_pmu_name is
    implemented for CPU PMUs, which is all that OProfile cares about anyway.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index 4e0a371630b3..99c63d4b6af8 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -23,26 +23,37 @@
 #include <asm/ptrace.h>
 
 #ifdef CONFIG_HW_PERF_EVENTS
+
+/*
+ * OProfile has a curious naming scheme for the ARM PMUs, but they are
+ * part of the user ABI so we need to map from the perf PMU name for
+ * supported PMUs.
+ */
+static struct op_perf_name {
+	char *perf_name;
+	char *op_name;
+} op_perf_name_map[] = {
+	{ "xscale1",		"arm/xscale1"	},
+	{ "xscale1",		"arm/xscale2"	},
+	{ "v6",			"arm/armv6"	},
+	{ "v6mpcore",		"arm/mpcore"	},
+	{ "ARMv7 Cortex-A8",	"arm/armv7"	},
+	{ "ARMv7 Cortex-A9",	"arm/armv7-ca9"	},
+};
+
 char *op_name_from_perf_id(void)
 {
-	enum arm_perf_pmu_ids id = armpmu_get_pmu_id();
-
-	switch (id) {
-	case ARM_PERF_PMU_ID_XSCALE1:
-		return "arm/xscale1";
-	case ARM_PERF_PMU_ID_XSCALE2:
-		return "arm/xscale2";
-	case ARM_PERF_PMU_ID_V6:
-		return "arm/armv6";
-	case ARM_PERF_PMU_ID_V6MP:
-		return "arm/mpcore";
-	case ARM_PERF_PMU_ID_CA8:
-		return "arm/armv7";
-	case ARM_PERF_PMU_ID_CA9:
-		return "arm/armv7-ca9";
-	default:
-		return NULL;
+	int i;
+	struct op_perf_name names;
+	const char *perf_name = perf_pmu_name();
+
+	for (i = 0; i < ARRAY_SIZE(op_perf_name_map); ++i) {
+		names = op_perf_name_map[i];
+		if (!strcmp(names.perf_name, perf_name))
+			return names.op_name;
 	}
+
+	return NULL;
 }
 #endif
 

commit 55205c916e179e09773d98d290334d319f45ac6b
Author: Vladimir Zapolskiy <vladimir.zapolskiy@nokia.com>
Date:   Thu Dec 22 16:15:40 2011 +0100

    oprofile, arm/sh: Fix oprofile_arch_exit() linkage issue
    
    This change fixes a linking problem, which happens if oprofile
    is selected to be compiled as built-in:
    
      `oprofile_arch_exit' referenced in section `.init.text' of
      arch/arm/oprofile/built-in.o: defined in discarded section
      `.exit.text' of arch/arm/oprofile/built-in.o
    
    The problem is appeared after commit 87121ca504, which
    introduced oprofile_arch_exit() calls from __init function. Note
    that the aforementioned commit has been backported to stable
    branches, and the problem is known to be reproduced at least
    with 3.0.13 and 3.1.5 kernels.
    
    Signed-off-by: Vladimir Zapolskiy <vladimir.zapolskiy@nokia.com>
    Signed-off-by: Robert Richter <robert.richter@amd.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: oprofile-list <oprofile-list@lists.sourceforge.net>
    Cc: <stable@kernel.org>
    Link: http://lkml.kernel.org/r/20111222151540.GB16765@erda.amd.com
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index c074e66ad224..4e0a371630b3 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -116,7 +116,7 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	return oprofile_perf_init(ops);
 }
 
-void __exit oprofile_arch_exit(void)
+void oprofile_arch_exit(void)
 {
 	oprofile_perf_exit();
 }

commit 1cecd791f2708b621e619cf4df4636c97c9497e5
Merge: fef86db8feb2 a252852afaea
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 15 10:18:48 2011 -0800

    Merge branch 'perf-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'perf-fixes-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86: Fix text_poke_smp_batch() deadlock
      perf tools: Fix thread_map event synthesizing in top and record
      watchdog, nmi: Lower the severity of error messages
      ARM: oprofile: Fix backtraces in timer mode
      oprofile: Fix usage of CONFIG_HW_PERF_EVENTS for oprofile_perf_init and friends

commit cb06199b1df492fcfbaedd2256b5054f944b664f
Author: Rabin Vincent <rabin.vincent@stericsson.com>
Date:   Wed Feb 9 11:35:12 2011 +0100

    ARM: 6654/1: perf/oprofile: fix off-by-one in stack check
    
    Since tail is the previous fp - 1, we need to compare the new fp with tail + 1
    to ensure that we don't end up passing in the same tail again, in order to
    avoid a potential infinite loop in the perf interrupt handler (which has been
    observed to occur).  A similar fix seems to be needed in the OProfile code.
    
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Rabin Vincent <rabin.vincent@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index 8aa974491dfc..6adda2b5fa31 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -85,7 +85,7 @@ static struct frame_tail* user_backtrace(struct frame_tail *tail)
 
 	/* frame pointers should strictly progress back up the stack
 	 * (towards higher addresses) */
-	if (tail >= buftail[0].fp)
+	if (tail + 1 >= buftail[0].fp)
 		return NULL;
 
 	return buftail[0].fp-1;

commit d14dd7e20d5e526557f5d3cfef4046a642f80924
Author: Ari Kauppi <kauppi@papupata.org>
Date:   Thu Jan 20 13:57:19 2011 -0500

    ARM: oprofile: Fix backtraces in timer mode
    
    Always allow backtraces when using oprofile on ARM, even if a PMU
    isn't present. Restores functionality originally introduced in commit
    1b7b56982fdcd9d85effd76f3928cf5d6eb26155 ("oprofile: Always allow
    backtraces on ARM") by Richard Purdie.
    
    It is not that obvious, but there is now only one oprofile_arch_init()
    function. So the .backtrace callback is available also in timer mode.
    
    Implemented by removing code and using stubs for oprofile_perf_{init,
    exit} provided by <linux/oprofile.h>. This allows cleaning of other
    architecture specific implementations too.
    
    Cc: stable@kernel.org # 37.x
    Signed-off-by: Ari Kauppi <kauppi@papupata.org>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index 8aa974491dfc..2b663918c464 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -10,8 +10,6 @@
  */
 
 #include <linux/cpumask.h>
-#include <linux/err.h>
-#include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/mutex.h>
 #include <linux/oprofile.h>
@@ -46,6 +44,7 @@ char *op_name_from_perf_id(void)
 		return NULL;
 	}
 }
+#endif
 
 static int report_trace(struct stackframe *frame, void *d)
 {
@@ -111,6 +110,7 @@ static void arm_backtrace(struct pt_regs * const regs, unsigned int depth)
 
 int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
+	/* provide backtrace support also in timer mode: */
 	ops->backtrace		= arm_backtrace;
 
 	return oprofile_perf_init(ops);
@@ -120,11 +120,3 @@ void __exit oprofile_arch_exit(void)
 {
 	oprofile_perf_exit();
 }
-#else
-int __init oprofile_arch_init(struct oprofile_operations *ops)
-{
-	pr_info("oprofile: hardware counters not available\n");
-	return -ENODEV;
-}
-void __exit oprofile_arch_exit(void) {}
-#endif /* CONFIG_HW_PERF_EVENTS */

commit 3d90a00763b51e1db344a7430c966be723b67a29
Author: Matt Fleming <matt@console-pimps.org>
Date:   Mon Sep 27 20:45:08 2010 +0100

    oprofile: Abstract the perf-events backend
    
    Move the perf-events backend from arch/arm/oprofile into
    drivers/oprofile so that the code can be shared between architectures.
    
    This allows each architecture to maintain only a single copy of the PMU
    accessor functions instead of one for both perf and OProfile. It also
    becomes possible for other architectures to delete much of their
    OProfile code in favour of the common code now available in
    drivers/oprofile/oprofile_perf.c.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Tested-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index 8718311cb530..8aa974491dfc 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -25,136 +25,6 @@
 #include <asm/ptrace.h>
 
 #ifdef CONFIG_HW_PERF_EVENTS
-/*
- * Per performance monitor configuration as set via oprofilefs.
- */
-struct op_counter_config {
-	unsigned long count;
-	unsigned long enabled;
-	unsigned long event;
-	unsigned long unit_mask;
-	unsigned long kernel;
-	unsigned long user;
-	struct perf_event_attr attr;
-};
-
-static int oprofile_perf_enabled;
-static DEFINE_MUTEX(oprofile_perf_mutex);
-
-static struct op_counter_config *counter_config;
-static struct perf_event **perf_events[nr_cpumask_bits];
-static int num_counters;
-
-/*
- * Overflow callback for oprofile.
- */
-static void op_overflow_handler(struct perf_event *event, int unused,
-			struct perf_sample_data *data, struct pt_regs *regs)
-{
-	int id;
-	u32 cpu = smp_processor_id();
-
-	for (id = 0; id < num_counters; ++id)
-		if (perf_events[cpu][id] == event)
-			break;
-
-	if (id != num_counters)
-		oprofile_add_sample(regs, id);
-	else
-		pr_warning("oprofile: ignoring spurious overflow "
-				"on cpu %u\n", cpu);
-}
-
-/*
- * Called by oprofile_perf_setup to create perf attributes to mirror the oprofile
- * settings in counter_config. Attributes are created as `pinned' events and
- * so are permanently scheduled on the PMU.
- */
-static void op_perf_setup(void)
-{
-	int i;
-	u32 size = sizeof(struct perf_event_attr);
-	struct perf_event_attr *attr;
-
-	for (i = 0; i < num_counters; ++i) {
-		attr = &counter_config[i].attr;
-		memset(attr, 0, size);
-		attr->type		= PERF_TYPE_RAW;
-		attr->size		= size;
-		attr->config		= counter_config[i].event;
-		attr->sample_period	= counter_config[i].count;
-		attr->pinned		= 1;
-	}
-}
-
-static int op_create_counter(int cpu, int event)
-{
-	int ret = 0;
-	struct perf_event *pevent;
-
-	if (!counter_config[event].enabled || (perf_events[cpu][event] != NULL))
-		return ret;
-
-	pevent = perf_event_create_kernel_counter(&counter_config[event].attr,
-						  cpu, -1,
-						  op_overflow_handler);
-
-	if (IS_ERR(pevent)) {
-		ret = PTR_ERR(pevent);
-	} else if (pevent->state != PERF_EVENT_STATE_ACTIVE) {
-		pr_warning("oprofile: failed to enable event %d "
-				"on CPU %d\n", event, cpu);
-		ret = -EBUSY;
-	} else {
-		perf_events[cpu][event] = pevent;
-	}
-
-	return ret;
-}
-
-static void op_destroy_counter(int cpu, int event)
-{
-	struct perf_event *pevent = perf_events[cpu][event];
-
-	if (pevent) {
-		perf_event_release_kernel(pevent);
-		perf_events[cpu][event] = NULL;
-	}
-}
-
-/*
- * Called by oprofile_perf_start to create active perf events based on the
- * perviously configured attributes.
- */
-static int op_perf_start(void)
-{
-	int cpu, event, ret = 0;
-
-	for_each_online_cpu(cpu) {
-		for (event = 0; event < num_counters; ++event) {
-			ret = op_create_counter(cpu, event);
-			if (ret)
-				goto out;
-		}
-	}
-
-out:
-	return ret;
-}
-
-/*
- * Called by oprofile_perf_stop at the end of a profiling run.
- */
-static void op_perf_stop(void)
-{
-	int cpu, event;
-
-	for_each_online_cpu(cpu)
-		for (event = 0; event < num_counters; ++event)
-			op_destroy_counter(cpu, event);
-}
-
-
 char *op_name_from_perf_id(void)
 {
 	enum arm_perf_pmu_ids id = armpmu_get_pmu_id();
@@ -177,116 +47,6 @@ char *op_name_from_perf_id(void)
 	}
 }
 
-static int oprofile_perf_create_files(struct super_block *sb, struct dentry *root)
-{
-	unsigned int i;
-
-	for (i = 0; i < num_counters; i++) {
-		struct dentry *dir;
-		char buf[4];
-
-		snprintf(buf, sizeof buf, "%d", i);
-		dir = oprofilefs_mkdir(sb, root, buf);
-		oprofilefs_create_ulong(sb, dir, "enabled", &counter_config[i].enabled);
-		oprofilefs_create_ulong(sb, dir, "event", &counter_config[i].event);
-		oprofilefs_create_ulong(sb, dir, "count", &counter_config[i].count);
-		oprofilefs_create_ulong(sb, dir, "unit_mask", &counter_config[i].unit_mask);
-		oprofilefs_create_ulong(sb, dir, "kernel", &counter_config[i].kernel);
-		oprofilefs_create_ulong(sb, dir, "user", &counter_config[i].user);
-	}
-
-	return 0;
-}
-
-static int oprofile_perf_setup(void)
-{
-	spin_lock(&oprofilefs_lock);
-	op_perf_setup();
-	spin_unlock(&oprofilefs_lock);
-	return 0;
-}
-
-static int oprofile_perf_start(void)
-{
-	int ret = -EBUSY;
-
-	mutex_lock(&oprofile_perf_mutex);
-	if (!oprofile_perf_enabled) {
-		ret = 0;
-		op_perf_start();
-		oprofile_perf_enabled = 1;
-	}
-	mutex_unlock(&oprofile_perf_mutex);
-	return ret;
-}
-
-static void oprofile_perf_stop(void)
-{
-	mutex_lock(&oprofile_perf_mutex);
-	if (oprofile_perf_enabled)
-		op_perf_stop();
-	oprofile_perf_enabled = 0;
-	mutex_unlock(&oprofile_perf_mutex);
-}
-
-#ifdef CONFIG_PM
-static int oprofile_perf_suspend(struct platform_device *dev, pm_message_t state)
-{
-	mutex_lock(&oprofile_perf_mutex);
-	if (oprofile_perf_enabled)
-		op_perf_stop();
-	mutex_unlock(&oprofile_perf_mutex);
-	return 0;
-}
-
-static int oprofile_perf_resume(struct platform_device *dev)
-{
-	mutex_lock(&oprofile_perf_mutex);
-	if (oprofile_perf_enabled && op_perf_start())
-		oprofile_perf_enabled = 0;
-	mutex_unlock(&oprofile_perf_mutex);
-	return 0;
-}
-
-static struct platform_driver oprofile_driver = {
-	.driver		= {
-		.name		= "oprofile-perf",
-	},
-	.resume		= oprofile_perf_resume,
-	.suspend	= oprofile_perf_suspend,
-};
-
-static struct platform_device *oprofile_pdev;
-
-static int __init init_driverfs(void)
-{
-	int ret;
-
-	ret = platform_driver_register(&oprofile_driver);
-	if (ret)
-		goto out;
-
-	oprofile_pdev =	platform_device_register_simple(
-				oprofile_driver.driver.name, 0, NULL, 0);
-	if (IS_ERR(oprofile_pdev)) {
-		ret = PTR_ERR(oprofile_pdev);
-		platform_driver_unregister(&oprofile_driver);
-	}
-
-out:
-	return ret;
-}
-
-static void __exit exit_driverfs(void)
-{
-	platform_device_unregister(oprofile_pdev);
-	platform_driver_unregister(&oprofile_driver);
-}
-#else
-static int __init init_driverfs(void) { return 0; }
-#define exit_driverfs() do { } while (0)
-#endif /* CONFIG_PM */
-
 static int report_trace(struct stackframe *frame, void *d)
 {
 	unsigned int *depth = d;
@@ -349,66 +109,6 @@ static void arm_backtrace(struct pt_regs * const regs, unsigned int depth)
 		tail = user_backtrace(tail);
 }
 
-int __init oprofile_perf_init(struct oprofile_operations *ops)
-{
-	int cpu, ret = 0;
-
-	memset(&perf_events, 0, sizeof(perf_events));
-
-	num_counters = perf_num_counters();
-	if (num_counters <= 0) {
-		pr_info("oprofile: no performance counters\n");
-		ret = -ENODEV;
-		goto out;
-	}
-
-	counter_config = kcalloc(num_counters,
-			sizeof(struct op_counter_config), GFP_KERNEL);
-
-	if (!counter_config) {
-		pr_info("oprofile: failed to allocate %d "
-				"counters\n", num_counters);
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	ret = init_driverfs();
-	if (ret)
-		goto out;
-
-	for_each_possible_cpu(cpu) {
-		perf_events[cpu] = kcalloc(num_counters,
-				sizeof(struct perf_event *), GFP_KERNEL);
-		if (!perf_events[cpu]) {
-			pr_info("oprofile: failed to allocate %d perf events "
-					"for cpu %d\n", num_counters, cpu);
-			ret = -ENOMEM;
-			goto out;
-		}
-	}
-
-	ops->create_files	= oprofile_perf_create_files;
-	ops->setup		= oprofile_perf_setup;
-	ops->start		= oprofile_perf_start;
-	ops->stop		= oprofile_perf_stop;
-	ops->shutdown		= oprofile_perf_stop;
-	ops->cpu_type		= op_name_from_perf_id();
-
-	if (!ops->cpu_type)
-		ret = -ENODEV;
-	else
-		pr_info("oprofile: using %s\n", ops->cpu_type);
-
-out:
-	if (ret) {
-		for_each_possible_cpu(cpu)
-			kfree(perf_events[cpu]);
-		kfree(counter_config);
-	}
-
-	return ret;
-}
-
 int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
 	ops->backtrace		= arm_backtrace;
@@ -416,25 +116,6 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	return oprofile_perf_init(ops);
 }
 
-void __exit oprofile_perf_exit(void)
-{
-	int cpu, id;
-	struct perf_event *event;
-
-	for_each_possible_cpu(cpu) {
-		for (id = 0; id < num_counters; ++id) {
-			event = perf_events[cpu][id];
-			if (event)
-				perf_event_release_kernel(event);
-		}
-
-		kfree(perf_events[cpu]);
-	}
-
-	kfree(counter_config);
-	exit_driverfs();
-}
-
 void __exit oprofile_arch_exit(void)
 {
 	oprofile_perf_exit();

commit 58850e210cd207399cf6461326e322541b2ec81c
Author: Matt Fleming <matt@console-pimps.org>
Date:   Mon Sep 27 20:35:29 2010 +0100

    ARM: oprofile: Move non-ARM code into separate init/exit
    
    In preparation for moving the majority of this oprofile code into an
    architecture-neutral place separate the architecture-independent code
    into oprofile_perf_init() and oprofile_perf_exit().
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Tested-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index d18c9f3fcffb..8718311cb530 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -349,7 +349,7 @@ static void arm_backtrace(struct pt_regs * const regs, unsigned int depth)
 		tail = user_backtrace(tail);
 }
 
-int __init oprofile_arch_init(struct oprofile_operations *ops)
+int __init oprofile_perf_init(struct oprofile_operations *ops)
 {
 	int cpu, ret = 0;
 
@@ -387,7 +387,6 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 		}
 	}
 
-	ops->backtrace		= arm_backtrace;
 	ops->create_files	= oprofile_perf_create_files;
 	ops->setup		= oprofile_perf_setup;
 	ops->start		= oprofile_perf_start;
@@ -410,7 +409,14 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	return ret;
 }
 
-void __exit oprofile_arch_exit(void)
+int __init oprofile_arch_init(struct oprofile_operations *ops)
+{
+	ops->backtrace		= arm_backtrace;
+
+	return oprofile_perf_init(ops);
+}
+
+void __exit oprofile_perf_exit(void)
 {
 	int cpu, id;
 	struct perf_event *event;
@@ -428,6 +434,11 @@ void __exit oprofile_arch_exit(void)
 	kfree(counter_config);
 	exit_driverfs();
 }
+
+void __exit oprofile_arch_exit(void)
+{
+	oprofile_perf_exit();
+}
 #else
 int __init oprofile_arch_init(struct oprofile_operations *ops)
 {

commit 80e96b11f6cd261e1e569f3931604d656388af33
Author: Matt Fleming <matt@console-pimps.org>
Date:   Mon Sep 27 20:29:58 2010 +0100

    ARM: oprofile: Rename op_arm to oprofile_perf
    
    In preparation for moving the generic functions out of this file, give
    the functions more general names (e.g. remove "arm" from the names).
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Tested-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index 4f67cfab2c59..d18c9f3fcffb 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -38,8 +38,8 @@ struct op_counter_config {
 	struct perf_event_attr attr;
 };
 
-static int op_arm_enabled;
-static DEFINE_MUTEX(op_arm_mutex);
+static int oprofile_perf_enabled;
+static DEFINE_MUTEX(oprofile_perf_mutex);
 
 static struct op_counter_config *counter_config;
 static struct perf_event **perf_events[nr_cpumask_bits];
@@ -66,7 +66,7 @@ static void op_overflow_handler(struct perf_event *event, int unused,
 }
 
 /*
- * Called by op_arm_setup to create perf attributes to mirror the oprofile
+ * Called by oprofile_perf_setup to create perf attributes to mirror the oprofile
  * settings in counter_config. Attributes are created as `pinned' events and
  * so are permanently scheduled on the PMU.
  */
@@ -123,7 +123,7 @@ static void op_destroy_counter(int cpu, int event)
 }
 
 /*
- * Called by op_arm_start to create active perf events based on the
+ * Called by oprofile_perf_start to create active perf events based on the
  * perviously configured attributes.
  */
 static int op_perf_start(void)
@@ -143,7 +143,7 @@ static int op_perf_start(void)
 }
 
 /*
- * Called by op_arm_stop at the end of a profiling run.
+ * Called by oprofile_perf_stop at the end of a profiling run.
  */
 static void op_perf_stop(void)
 {
@@ -177,7 +177,7 @@ char *op_name_from_perf_id(void)
 	}
 }
 
-static int op_arm_create_files(struct super_block *sb, struct dentry *root)
+static int oprofile_perf_create_files(struct super_block *sb, struct dentry *root)
 {
 	unsigned int i;
 
@@ -198,7 +198,7 @@ static int op_arm_create_files(struct super_block *sb, struct dentry *root)
 	return 0;
 }
 
-static int op_arm_setup(void)
+static int oprofile_perf_setup(void)
 {
 	spin_lock(&oprofilefs_lock);
 	op_perf_setup();
@@ -206,54 +206,54 @@ static int op_arm_setup(void)
 	return 0;
 }
 
-static int op_arm_start(void)
+static int oprofile_perf_start(void)
 {
 	int ret = -EBUSY;
 
-	mutex_lock(&op_arm_mutex);
-	if (!op_arm_enabled) {
+	mutex_lock(&oprofile_perf_mutex);
+	if (!oprofile_perf_enabled) {
 		ret = 0;
 		op_perf_start();
-		op_arm_enabled = 1;
+		oprofile_perf_enabled = 1;
 	}
-	mutex_unlock(&op_arm_mutex);
+	mutex_unlock(&oprofile_perf_mutex);
 	return ret;
 }
 
-static void op_arm_stop(void)
+static void oprofile_perf_stop(void)
 {
-	mutex_lock(&op_arm_mutex);
-	if (op_arm_enabled)
+	mutex_lock(&oprofile_perf_mutex);
+	if (oprofile_perf_enabled)
 		op_perf_stop();
-	op_arm_enabled = 0;
-	mutex_unlock(&op_arm_mutex);
+	oprofile_perf_enabled = 0;
+	mutex_unlock(&oprofile_perf_mutex);
 }
 
 #ifdef CONFIG_PM
-static int op_arm_suspend(struct platform_device *dev, pm_message_t state)
+static int oprofile_perf_suspend(struct platform_device *dev, pm_message_t state)
 {
-	mutex_lock(&op_arm_mutex);
-	if (op_arm_enabled)
+	mutex_lock(&oprofile_perf_mutex);
+	if (oprofile_perf_enabled)
 		op_perf_stop();
-	mutex_unlock(&op_arm_mutex);
+	mutex_unlock(&oprofile_perf_mutex);
 	return 0;
 }
 
-static int op_arm_resume(struct platform_device *dev)
+static int oprofile_perf_resume(struct platform_device *dev)
 {
-	mutex_lock(&op_arm_mutex);
-	if (op_arm_enabled && op_perf_start())
-		op_arm_enabled = 0;
-	mutex_unlock(&op_arm_mutex);
+	mutex_lock(&oprofile_perf_mutex);
+	if (oprofile_perf_enabled && op_perf_start())
+		oprofile_perf_enabled = 0;
+	mutex_unlock(&oprofile_perf_mutex);
 	return 0;
 }
 
 static struct platform_driver oprofile_driver = {
 	.driver		= {
-		.name		= "arm-oprofile",
+		.name		= "oprofile-perf",
 	},
-	.resume		= op_arm_resume,
-	.suspend	= op_arm_suspend,
+	.resume		= oprofile_perf_resume,
+	.suspend	= oprofile_perf_suspend,
 };
 
 static struct platform_device *oprofile_pdev;
@@ -388,11 +388,11 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	}
 
 	ops->backtrace		= arm_backtrace;
-	ops->create_files	= op_arm_create_files;
-	ops->setup		= op_arm_setup;
-	ops->start		= op_arm_start;
-	ops->stop		= op_arm_stop;
-	ops->shutdown		= op_arm_stop;
+	ops->create_files	= oprofile_perf_create_files;
+	ops->setup		= oprofile_perf_setup;
+	ops->start		= oprofile_perf_start;
+	ops->stop		= oprofile_perf_stop;
+	ops->shutdown		= oprofile_perf_stop;
 	ops->cpu_type		= op_name_from_perf_id();
 
 	if (!ops->cpu_type)

commit 56946331b28d53232115a155ba662ab3dc598952
Author: Matt Fleming <matt@console-pimps.org>
Date:   Fri Oct 8 21:42:17 2010 +0100

    oprofile: Make op_name_from_perf_id() global
    
    Make op_name_from_perf_id() global so that we have a way for each
    architecture to construct an oprofile name for op->cpu_type. We need to
    remove the argument from the function prototype so that we can hide all
    implementation details inside the function.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index 1e971a7fcf82..4f67cfab2c59 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -155,8 +155,10 @@ static void op_perf_stop(void)
 }
 
 
-static char *op_name_from_perf_id(enum arm_perf_pmu_ids id)
+char *op_name_from_perf_id(void)
 {
+	enum arm_perf_pmu_ids id = armpmu_get_pmu_id();
+
 	switch (id) {
 	case ARM_PERF_PMU_ID_XSCALE1:
 		return "arm/xscale1";
@@ -391,7 +393,7 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	ops->start		= op_arm_start;
 	ops->stop		= op_arm_stop;
 	ops->shutdown		= op_arm_stop;
-	ops->cpu_type		= op_name_from_perf_id(armpmu_get_pmu_id());
+	ops->cpu_type		= op_name_from_perf_id();
 
 	if (!ops->cpu_type)
 		ret = -ENODEV;

commit 3bf101ba42a1c89b5afbc7492e7647dae5e18735
Author: Matt Fleming <matt@console-pimps.org>
Date:   Mon Sep 27 20:22:24 2010 +0100

    perf: Add helper function to return number of counters
    
    The number of counters for the registered pmu is needed in a few places
    so provide a helper function that returns this number.
    
    Signed-off-by: Matt Fleming <matt@console-pimps.org>
    Tested-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index d660cb8dab36..1e971a7fcf82 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -43,7 +43,7 @@ static DEFINE_MUTEX(op_arm_mutex);
 
 static struct op_counter_config *counter_config;
 static struct perf_event **perf_events[nr_cpumask_bits];
-static int perf_num_counters;
+static int num_counters;
 
 /*
  * Overflow callback for oprofile.
@@ -54,11 +54,11 @@ static void op_overflow_handler(struct perf_event *event, int unused,
 	int id;
 	u32 cpu = smp_processor_id();
 
-	for (id = 0; id < perf_num_counters; ++id)
+	for (id = 0; id < num_counters; ++id)
 		if (perf_events[cpu][id] == event)
 			break;
 
-	if (id != perf_num_counters)
+	if (id != num_counters)
 		oprofile_add_sample(regs, id);
 	else
 		pr_warning("oprofile: ignoring spurious overflow "
@@ -76,7 +76,7 @@ static void op_perf_setup(void)
 	u32 size = sizeof(struct perf_event_attr);
 	struct perf_event_attr *attr;
 
-	for (i = 0; i < perf_num_counters; ++i) {
+	for (i = 0; i < num_counters; ++i) {
 		attr = &counter_config[i].attr;
 		memset(attr, 0, size);
 		attr->type		= PERF_TYPE_RAW;
@@ -131,7 +131,7 @@ static int op_perf_start(void)
 	int cpu, event, ret = 0;
 
 	for_each_online_cpu(cpu) {
-		for (event = 0; event < perf_num_counters; ++event) {
+		for (event = 0; event < num_counters; ++event) {
 			ret = op_create_counter(cpu, event);
 			if (ret)
 				goto out;
@@ -150,7 +150,7 @@ static void op_perf_stop(void)
 	int cpu, event;
 
 	for_each_online_cpu(cpu)
-		for (event = 0; event < perf_num_counters; ++event)
+		for (event = 0; event < num_counters; ++event)
 			op_destroy_counter(cpu, event);
 }
 
@@ -179,7 +179,7 @@ static int op_arm_create_files(struct super_block *sb, struct dentry *root)
 {
 	unsigned int i;
 
-	for (i = 0; i < perf_num_counters; i++) {
+	for (i = 0; i < num_counters; i++) {
 		struct dentry *dir;
 		char buf[4];
 
@@ -353,14 +353,19 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 
 	memset(&perf_events, 0, sizeof(perf_events));
 
-	perf_num_counters = armpmu_get_max_events();
+	num_counters = perf_num_counters();
+	if (num_counters <= 0) {
+		pr_info("oprofile: no performance counters\n");
+		ret = -ENODEV;
+		goto out;
+	}
 
-	counter_config = kcalloc(perf_num_counters,
+	counter_config = kcalloc(num_counters,
 			sizeof(struct op_counter_config), GFP_KERNEL);
 
 	if (!counter_config) {
 		pr_info("oprofile: failed to allocate %d "
-				"counters\n", perf_num_counters);
+				"counters\n", num_counters);
 		ret = -ENOMEM;
 		goto out;
 	}
@@ -370,11 +375,11 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 		goto out;
 
 	for_each_possible_cpu(cpu) {
-		perf_events[cpu] = kcalloc(perf_num_counters,
+		perf_events[cpu] = kcalloc(num_counters,
 				sizeof(struct perf_event *), GFP_KERNEL);
 		if (!perf_events[cpu]) {
 			pr_info("oprofile: failed to allocate %d perf events "
-					"for cpu %d\n", perf_num_counters, cpu);
+					"for cpu %d\n", num_counters, cpu);
 			ret = -ENOMEM;
 			goto out;
 		}
@@ -409,7 +414,7 @@ void __exit oprofile_arch_exit(void)
 	struct perf_event *event;
 
 	for_each_possible_cpu(cpu) {
-		for (id = 0; id < perf_num_counters; ++id) {
+		for (id = 0; id < num_counters; ++id) {
 			event = perf_events[cpu][id];
 			if (event)
 				perf_event_release_kernel(event);

commit 4cbe75be5c6ae86bdc7daec864eeb2dfd66f48bb
Author: Robert Richter <robert.richter@amd.com>
Date:   Mon Aug 30 18:21:55 2010 +0200

    oprofile, arm: initialize perf_event pointers with NULL
    
    The pointers must be NULL'ed to avoid double-freeing the pointers in
    rare cases during reinitialization.
    
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index c3652f73fed4..d660cb8dab36 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -351,6 +351,8 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
 	int cpu, ret = 0;
 
+	memset(&perf_events, 0, sizeof(perf_events));
+
 	perf_num_counters = armpmu_get_max_events();
 
 	counter_config = kcalloc(perf_num_counters,

commit c7fd239a647ead1c336a051012d6bb96465ea8c6
Author: Will Deacon <will.deacon@arm.com>
Date:   Sun Aug 29 14:52:00 2010 -0400

    ARM: oprofile: fix and simplify init/exit functions
    
    Now that oprofile_arch_exit is only called when the OProfile module
    is unloaded, it can assume that init completed successfully and not
    have to worry about double frees or releasing NULL perf events.
    
    This patch ensures that oprofile_arch_init fails gracefully on ARM
    and simplifies the exit code based on the above.
    
    Cc: Robert Richter <robert.richter@amd.com>
    Cc: Matt Fleming <matt@console-pimps.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index 0691176899ff..c3652f73fed4 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -275,7 +275,7 @@ static int __init init_driverfs(void)
 	return ret;
 }
 
-static void  exit_driverfs(void)
+static void __exit exit_driverfs(void)
 {
 	platform_device_unregister(oprofile_pdev);
 	platform_driver_unregister(&oprofile_driver);
@@ -359,14 +359,13 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	if (!counter_config) {
 		pr_info("oprofile: failed to allocate %d "
 				"counters\n", perf_num_counters);
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto out;
 	}
 
 	ret = init_driverfs();
-	if (ret) {
-		kfree(counter_config);
-		return ret;
-	}
+	if (ret)
+		goto out;
 
 	for_each_possible_cpu(cpu) {
 		perf_events[cpu] = kcalloc(perf_num_counters,
@@ -374,9 +373,8 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 		if (!perf_events[cpu]) {
 			pr_info("oprofile: failed to allocate %d perf events "
 					"for cpu %d\n", perf_num_counters, cpu);
-			while (--cpu >= 0)
-				kfree(perf_events[cpu]);
-			return -ENOMEM;
+			ret = -ENOMEM;
+			goto out;
 		}
 	}
 
@@ -393,28 +391,33 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	else
 		pr_info("oprofile: using %s\n", ops->cpu_type);
 
+out:
+	if (ret) {
+		for_each_possible_cpu(cpu)
+			kfree(perf_events[cpu]);
+		kfree(counter_config);
+	}
+
 	return ret;
 }
 
-void oprofile_arch_exit(void)
+void __exit oprofile_arch_exit(void)
 {
 	int cpu, id;
 	struct perf_event *event;
 
-	if (*perf_events) {
-		exit_driverfs();
-		for_each_possible_cpu(cpu) {
-			for (id = 0; id < perf_num_counters; ++id) {
-				event = perf_events[cpu][id];
-				if (event != NULL)
-					perf_event_release_kernel(event);
-			}
-			kfree(perf_events[cpu]);
+	for_each_possible_cpu(cpu) {
+		for (id = 0; id < perf_num_counters; ++id) {
+			event = perf_events[cpu][id];
+			if (event)
+				perf_event_release_kernel(event);
 		}
+
+		kfree(perf_events[cpu]);
 	}
 
-	if (counter_config)
-		kfree(counter_config);
+	kfree(counter_config);
+	exit_driverfs();
 }
 #else
 int __init oprofile_arch_init(struct oprofile_operations *ops)
@@ -422,5 +425,5 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	pr_info("oprofile: hardware counters not available\n");
 	return -ENODEV;
 }
-void oprofile_arch_exit(void) {}
+void __exit oprofile_arch_exit(void) {}
 #endif /* CONFIG_HW_PERF_EVENTS */

commit d1e86d64bc48dedd0d68d182d0ce6951d8b4fd0d
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Apr 30 11:38:39 2010 +0100

    ARM: 6074/1: oprofile: convert from sysdev to platform device
    
    This is a reworking of an original patch posted by Aaro Koskinen:
    
    oprofile does not work with PM, because sysdev_suspend() is done with
    interrupts disabled and oprofile needs a mutex. Implementing oprofile
    as a platform device solves this problem.
    
    Cc: Aaro Koskinen <aaro.koskinen@nokia.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Aaro Koskinen <aaro.koskinen@nokia.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index aad83df89bac..0691176899ff 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -10,13 +10,14 @@
  */
 
 #include <linux/cpumask.h>
+#include <linux/err.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/mutex.h>
 #include <linux/oprofile.h>
 #include <linux/perf_event.h>
+#include <linux/platform_device.h>
 #include <linux/slab.h>
-#include <linux/sysdev.h>
 #include <asm/stacktrace.h>
 #include <linux/uaccess.h>
 
@@ -227,7 +228,7 @@ static void op_arm_stop(void)
 }
 
 #ifdef CONFIG_PM
-static int op_arm_suspend(struct sys_device *dev, pm_message_t state)
+static int op_arm_suspend(struct platform_device *dev, pm_message_t state)
 {
 	mutex_lock(&op_arm_mutex);
 	if (op_arm_enabled)
@@ -236,7 +237,7 @@ static int op_arm_suspend(struct sys_device *dev, pm_message_t state)
 	return 0;
 }
 
-static int op_arm_resume(struct sys_device *dev)
+static int op_arm_resume(struct platform_device *dev)
 {
 	mutex_lock(&op_arm_mutex);
 	if (op_arm_enabled && op_perf_start())
@@ -245,34 +246,42 @@ static int op_arm_resume(struct sys_device *dev)
 	return 0;
 }
 
-static struct sysdev_class oprofile_sysclass = {
-	.name		= "oprofile",
+static struct platform_driver oprofile_driver = {
+	.driver		= {
+		.name		= "arm-oprofile",
+	},
 	.resume		= op_arm_resume,
 	.suspend	= op_arm_suspend,
 };
 
-static struct sys_device device_oprofile = {
-	.id		= 0,
-	.cls		= &oprofile_sysclass,
-};
+static struct platform_device *oprofile_pdev;
 
 static int __init init_driverfs(void)
 {
 	int ret;
 
-	if (!(ret = sysdev_class_register(&oprofile_sysclass)))
-		ret = sysdev_register(&device_oprofile);
+	ret = platform_driver_register(&oprofile_driver);
+	if (ret)
+		goto out;
+
+	oprofile_pdev =	platform_device_register_simple(
+				oprofile_driver.driver.name, 0, NULL, 0);
+	if (IS_ERR(oprofile_pdev)) {
+		ret = PTR_ERR(oprofile_pdev);
+		platform_driver_unregister(&oprofile_driver);
+	}
 
+out:
 	return ret;
 }
 
 static void  exit_driverfs(void)
 {
-	sysdev_unregister(&device_oprofile);
-	sysdev_class_unregister(&oprofile_sysclass);
+	platform_device_unregister(oprofile_pdev);
+	platform_driver_unregister(&oprofile_driver);
 }
 #else
-#define init_driverfs()	do { } while (0)
+static int __init init_driverfs(void) { return 0; }
 #define exit_driverfs() do { } while (0)
 #endif /* CONFIG_PM */
 
@@ -353,6 +362,12 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 		return -ENOMEM;
 	}
 
+	ret = init_driverfs();
+	if (ret) {
+		kfree(counter_config);
+		return ret;
+	}
+
 	for_each_possible_cpu(cpu) {
 		perf_events[cpu] = kcalloc(perf_num_counters,
 				sizeof(struct perf_event *), GFP_KERNEL);
@@ -365,7 +380,6 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 		}
 	}
 
-	init_driverfs();
 	ops->backtrace		= arm_backtrace;
 	ops->create_files	= op_arm_create_files;
 	ops->setup		= op_arm_setup;

commit 8c1fc96f6fd1f361428ba805103af0d0eee65179
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Apr 30 11:36:54 2010 +0100

    ARM: 6072/1: oprofile: use perf-events framework as backend
    
    There are currently two hardware performance monitoring subsystems in
    the kernel for ARM: OProfile and perf-events. This creates the
    following problems:
    
    1.) Duplicate PMU accessor code. Inevitable code drift may lead to
    bugs in one framework that are fixed in the other.
    
    2.) Locking issues. OProfile doesn't reprogram hardware counters
    between profiling runs if the events to be monitored have not been
    changed. This means that other profiling frameworks cannot use the
    counters if OProfile is in use.
    
    3.) Due to differences in the two frameworks, it may not be possible to
    compare the results obtained by OProfile with those obtained by perf.
    
    This patch removes the OProfile PMU driver code and replaces it with
    calls to perf, therefore solving the issues mentioned above.
    
    The only userspace-visible change is the lack of SCU counter support
    for 11MPCore. This is currently unsupported by OProfile userspace tools anyway and therefore shouldn't cause any problems.
    
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Robert Richter <robert.richter@amd.com>
    Cc: Jamie Iles <jamie.iles@picochip.com>
    Cc: Jean Pihet <jpihet@mvista.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index 3fcd752d6146..aad83df89bac 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -2,32 +2,183 @@
  * @file common.c
  *
  * @remark Copyright 2004 Oprofile Authors
+ * @remark Copyright 2010 ARM Ltd.
  * @remark Read the file COPYING
  *
  * @author Zwane Mwaikambo
+ * @author Will Deacon [move to perf]
  */
 
+#include <linux/cpumask.h>
+#include <linux/errno.h>
 #include <linux/init.h>
+#include <linux/mutex.h>
 #include <linux/oprofile.h>
-#include <linux/errno.h>
+#include <linux/perf_event.h>
 #include <linux/slab.h>
 #include <linux/sysdev.h>
-#include <linux/mutex.h>
+#include <asm/stacktrace.h>
+#include <linux/uaccess.h>
+
+#include <asm/perf_event.h>
+#include <asm/ptrace.h>
 
-#include "op_counter.h"
-#include "op_arm_model.h"
+#ifdef CONFIG_HW_PERF_EVENTS
+/*
+ * Per performance monitor configuration as set via oprofilefs.
+ */
+struct op_counter_config {
+	unsigned long count;
+	unsigned long enabled;
+	unsigned long event;
+	unsigned long unit_mask;
+	unsigned long kernel;
+	unsigned long user;
+	struct perf_event_attr attr;
+};
 
-static struct op_arm_model_spec *op_arm_model;
 static int op_arm_enabled;
 static DEFINE_MUTEX(op_arm_mutex);
 
-struct op_counter_config *counter_config;
+static struct op_counter_config *counter_config;
+static struct perf_event **perf_events[nr_cpumask_bits];
+static int perf_num_counters;
+
+/*
+ * Overflow callback for oprofile.
+ */
+static void op_overflow_handler(struct perf_event *event, int unused,
+			struct perf_sample_data *data, struct pt_regs *regs)
+{
+	int id;
+	u32 cpu = smp_processor_id();
+
+	for (id = 0; id < perf_num_counters; ++id)
+		if (perf_events[cpu][id] == event)
+			break;
+
+	if (id != perf_num_counters)
+		oprofile_add_sample(regs, id);
+	else
+		pr_warning("oprofile: ignoring spurious overflow "
+				"on cpu %u\n", cpu);
+}
+
+/*
+ * Called by op_arm_setup to create perf attributes to mirror the oprofile
+ * settings in counter_config. Attributes are created as `pinned' events and
+ * so are permanently scheduled on the PMU.
+ */
+static void op_perf_setup(void)
+{
+	int i;
+	u32 size = sizeof(struct perf_event_attr);
+	struct perf_event_attr *attr;
+
+	for (i = 0; i < perf_num_counters; ++i) {
+		attr = &counter_config[i].attr;
+		memset(attr, 0, size);
+		attr->type		= PERF_TYPE_RAW;
+		attr->size		= size;
+		attr->config		= counter_config[i].event;
+		attr->sample_period	= counter_config[i].count;
+		attr->pinned		= 1;
+	}
+}
+
+static int op_create_counter(int cpu, int event)
+{
+	int ret = 0;
+	struct perf_event *pevent;
+
+	if (!counter_config[event].enabled || (perf_events[cpu][event] != NULL))
+		return ret;
+
+	pevent = perf_event_create_kernel_counter(&counter_config[event].attr,
+						  cpu, -1,
+						  op_overflow_handler);
+
+	if (IS_ERR(pevent)) {
+		ret = PTR_ERR(pevent);
+	} else if (pevent->state != PERF_EVENT_STATE_ACTIVE) {
+		pr_warning("oprofile: failed to enable event %d "
+				"on CPU %d\n", event, cpu);
+		ret = -EBUSY;
+	} else {
+		perf_events[cpu][event] = pevent;
+	}
+
+	return ret;
+}
+
+static void op_destroy_counter(int cpu, int event)
+{
+	struct perf_event *pevent = perf_events[cpu][event];
+
+	if (pevent) {
+		perf_event_release_kernel(pevent);
+		perf_events[cpu][event] = NULL;
+	}
+}
+
+/*
+ * Called by op_arm_start to create active perf events based on the
+ * perviously configured attributes.
+ */
+static int op_perf_start(void)
+{
+	int cpu, event, ret = 0;
+
+	for_each_online_cpu(cpu) {
+		for (event = 0; event < perf_num_counters; ++event) {
+			ret = op_create_counter(cpu, event);
+			if (ret)
+				goto out;
+		}
+	}
+
+out:
+	return ret;
+}
+
+/*
+ * Called by op_arm_stop at the end of a profiling run.
+ */
+static void op_perf_stop(void)
+{
+	int cpu, event;
+
+	for_each_online_cpu(cpu)
+		for (event = 0; event < perf_num_counters; ++event)
+			op_destroy_counter(cpu, event);
+}
+
+
+static char *op_name_from_perf_id(enum arm_perf_pmu_ids id)
+{
+	switch (id) {
+	case ARM_PERF_PMU_ID_XSCALE1:
+		return "arm/xscale1";
+	case ARM_PERF_PMU_ID_XSCALE2:
+		return "arm/xscale2";
+	case ARM_PERF_PMU_ID_V6:
+		return "arm/armv6";
+	case ARM_PERF_PMU_ID_V6MP:
+		return "arm/mpcore";
+	case ARM_PERF_PMU_ID_CA8:
+		return "arm/armv7";
+	case ARM_PERF_PMU_ID_CA9:
+		return "arm/armv7-ca9";
+	default:
+		return NULL;
+	}
+}
 
 static int op_arm_create_files(struct super_block *sb, struct dentry *root)
 {
 	unsigned int i;
 
-	for (i = 0; i < op_arm_model->num_counters; i++) {
+	for (i = 0; i < perf_num_counters; i++) {
 		struct dentry *dir;
 		char buf[4];
 
@@ -46,12 +197,10 @@ static int op_arm_create_files(struct super_block *sb, struct dentry *root)
 
 static int op_arm_setup(void)
 {
-	int ret;
-
 	spin_lock(&oprofilefs_lock);
-	ret = op_arm_model->setup_ctrs();
+	op_perf_setup();
 	spin_unlock(&oprofilefs_lock);
-	return ret;
+	return 0;
 }
 
 static int op_arm_start(void)
@@ -60,8 +209,9 @@ static int op_arm_start(void)
 
 	mutex_lock(&op_arm_mutex);
 	if (!op_arm_enabled) {
-		ret = op_arm_model->start();
-		op_arm_enabled = !ret;
+		ret = 0;
+		op_perf_start();
+		op_arm_enabled = 1;
 	}
 	mutex_unlock(&op_arm_mutex);
 	return ret;
@@ -71,7 +221,7 @@ static void op_arm_stop(void)
 {
 	mutex_lock(&op_arm_mutex);
 	if (op_arm_enabled)
-		op_arm_model->stop();
+		op_perf_stop();
 	op_arm_enabled = 0;
 	mutex_unlock(&op_arm_mutex);
 }
@@ -81,7 +231,7 @@ static int op_arm_suspend(struct sys_device *dev, pm_message_t state)
 {
 	mutex_lock(&op_arm_mutex);
 	if (op_arm_enabled)
-		op_arm_model->stop();
+		op_perf_stop();
 	mutex_unlock(&op_arm_mutex);
 	return 0;
 }
@@ -89,7 +239,7 @@ static int op_arm_suspend(struct sys_device *dev, pm_message_t state)
 static int op_arm_resume(struct sys_device *dev)
 {
 	mutex_lock(&op_arm_mutex);
-	if (op_arm_enabled && op_arm_model->start())
+	if (op_arm_enabled && op_perf_start())
 		op_arm_enabled = 0;
 	mutex_unlock(&op_arm_mutex);
 	return 0;
@@ -126,58 +276,137 @@ static void  exit_driverfs(void)
 #define exit_driverfs() do { } while (0)
 #endif /* CONFIG_PM */
 
-int __init oprofile_arch_init(struct oprofile_operations *ops)
+static int report_trace(struct stackframe *frame, void *d)
 {
-	struct op_arm_model_spec *spec = NULL;
-	int ret = -ENODEV;
+	unsigned int *depth = d;
 
-	ops->backtrace = arm_backtrace;
+	if (*depth) {
+		oprofile_add_trace(frame->pc);
+		(*depth)--;
+	}
 
-#ifdef CONFIG_CPU_XSCALE
-	spec = &op_xscale_spec;
-#endif
+	return *depth == 0;
+}
 
-#ifdef CONFIG_OPROFILE_ARMV6
-	spec = &op_armv6_spec;
-#endif
+/*
+ * The registers we're interested in are at the end of the variable
+ * length saved register structure. The fp points at the end of this
+ * structure so the address of this struct is:
+ * (struct frame_tail *)(xxx->fp)-1
+ */
+struct frame_tail {
+	struct frame_tail *fp;
+	unsigned long sp;
+	unsigned long lr;
+} __attribute__((packed));
 
-#ifdef CONFIG_OPROFILE_MPCORE
-	spec = &op_mpcore_spec;
-#endif
+static struct frame_tail* user_backtrace(struct frame_tail *tail)
+{
+	struct frame_tail buftail[2];
 
-#ifdef CONFIG_OPROFILE_ARMV7
-	spec = &op_armv7_spec;
-#endif
+	/* Also check accessibility of one struct frame_tail beyond */
+	if (!access_ok(VERIFY_READ, tail, sizeof(buftail)))
+		return NULL;
+	if (__copy_from_user_inatomic(buftail, tail, sizeof(buftail)))
+		return NULL;
 
-	if (spec) {
-		ret = spec->init();
-		if (ret < 0)
-			return ret;
+	oprofile_add_trace(buftail[0].lr);
 
-		counter_config = kcalloc(spec->num_counters, sizeof(struct op_counter_config),
-					 GFP_KERNEL);
-		if (!counter_config)
-			return -ENOMEM;
+	/* frame pointers should strictly progress back up the stack
+	 * (towards higher addresses) */
+	if (tail >= buftail[0].fp)
+		return NULL;
+
+	return buftail[0].fp-1;
+}
+
+static void arm_backtrace(struct pt_regs * const regs, unsigned int depth)
+{
+	struct frame_tail *tail = ((struct frame_tail *) regs->ARM_fp) - 1;
+
+	if (!user_mode(regs)) {
+		struct stackframe frame;
+		frame.fp = regs->ARM_fp;
+		frame.sp = regs->ARM_sp;
+		frame.lr = regs->ARM_lr;
+		frame.pc = regs->ARM_pc;
+		walk_stackframe(&frame, report_trace, &depth);
+		return;
+	}
+
+	while (depth-- && tail && !((unsigned long) tail & 3))
+		tail = user_backtrace(tail);
+}
+
+int __init oprofile_arch_init(struct oprofile_operations *ops)
+{
+	int cpu, ret = 0;
+
+	perf_num_counters = armpmu_get_max_events();
+
+	counter_config = kcalloc(perf_num_counters,
+			sizeof(struct op_counter_config), GFP_KERNEL);
 
-		op_arm_model = spec;
-		init_driverfs();
-		ops->create_files = op_arm_create_files;
-		ops->setup = op_arm_setup;
-		ops->shutdown = op_arm_stop;
-		ops->start = op_arm_start;
-		ops->stop = op_arm_stop;
-		ops->cpu_type = op_arm_model->name;
-		printk(KERN_INFO "oprofile: using %s\n", spec->name);
+	if (!counter_config) {
+		pr_info("oprofile: failed to allocate %d "
+				"counters\n", perf_num_counters);
+		return -ENOMEM;
 	}
 
+	for_each_possible_cpu(cpu) {
+		perf_events[cpu] = kcalloc(perf_num_counters,
+				sizeof(struct perf_event *), GFP_KERNEL);
+		if (!perf_events[cpu]) {
+			pr_info("oprofile: failed to allocate %d perf events "
+					"for cpu %d\n", perf_num_counters, cpu);
+			while (--cpu >= 0)
+				kfree(perf_events[cpu]);
+			return -ENOMEM;
+		}
+	}
+
+	init_driverfs();
+	ops->backtrace		= arm_backtrace;
+	ops->create_files	= op_arm_create_files;
+	ops->setup		= op_arm_setup;
+	ops->start		= op_arm_start;
+	ops->stop		= op_arm_stop;
+	ops->shutdown		= op_arm_stop;
+	ops->cpu_type		= op_name_from_perf_id(armpmu_get_pmu_id());
+
+	if (!ops->cpu_type)
+		ret = -ENODEV;
+	else
+		pr_info("oprofile: using %s\n", ops->cpu_type);
+
 	return ret;
 }
 
 void oprofile_arch_exit(void)
 {
-	if (op_arm_model) {
+	int cpu, id;
+	struct perf_event *event;
+
+	if (*perf_events) {
 		exit_driverfs();
-		op_arm_model = NULL;
+		for_each_possible_cpu(cpu) {
+			for (id = 0; id < perf_num_counters; ++id) {
+				event = perf_events[cpu][id];
+				if (event != NULL)
+					perf_event_release_kernel(event);
+			}
+			kfree(perf_events[cpu]);
+		}
 	}
-	kfree(counter_config);
+
+	if (counter_config)
+		kfree(counter_config);
+}
+#else
+int __init oprofile_arch_init(struct oprofile_operations *ops)
+{
+	pr_info("oprofile: hardware counters not available\n");
+	return -ENODEV;
 }
+void oprofile_arch_exit(void) {}
+#endif /* CONFIG_HW_PERF_EVENTS */

commit d7ac4e28ccc63ed6b4d67bd9c4a67cb9533eeb45
Author: Jean PIHET <jpihet@mvista.com>
Date:   Tue Aug 12 19:07:39 2008 +0100

    [ARM] 5195/1: ARMv7 Oprofile support
    
    Add Oprofile kernel support for ARMv7.
    Tested on OMAP3430 and OMAP3530 chipsets (Cortex-A8).
    
    Signed-off-by: Jean Pihet <jpihet@mvista.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index 0a5cf3a6438b..3fcd752d6146 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -145,6 +145,10 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	spec = &op_mpcore_spec;
 #endif
 
+#ifdef CONFIG_OPROFILE_ARMV7
+	spec = &op_armv7_spec;
+#endif
+
 	if (spec) {
 		ret = spec->init();
 		if (ret < 0)

commit af5ca3f4ec5cc4432a42a73b050dd8898ce8fd00
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Dec 20 02:09:39 2007 +0100

    Driver core: change sysdev classes to use dynamic kobject names
    
    All kobjects require a dynamically allocated name now. We no longer
    need to keep track if the name is statically assigned, we can just
    unconditionally free() all kobject names on cleanup.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index a9de727c9327..0a5cf3a6438b 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -96,7 +96,7 @@ static int op_arm_resume(struct sys_device *dev)
 }
 
 static struct sysdev_class oprofile_sysclass = {
-	set_kset_name("oprofile"),
+	.name		= "oprofile",
 	.resume		= op_arm_resume,
 	.suspend	= op_arm_suspend,
 };

commit 1b7b56982fdcd9d85effd76f3928cf5d6eb26155
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Tue Feb 27 12:09:33 2007 +0100

    [ARM] 4237/2: oprofile: Always allow backtraces on ARM
    
    Always allow backtrace when using oprofile on ARM, even if a PMU
    isn't present.
    
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index 0a007b931f63..a9de727c9327 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -131,6 +131,8 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	struct op_arm_model_spec *spec = NULL;
 	int ret = -ENODEV;
 
+	ops->backtrace = arm_backtrace;
+
 #ifdef CONFIG_CPU_XSCALE
 	spec = &op_xscale_spec;
 #endif
@@ -161,7 +163,6 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 		ops->start = op_arm_start;
 		ops->stop = op_arm_stop;
 		ops->cpu_type = op_arm_model->name;
-		ops->backtrace = arm_backtrace;
 		printk(KERN_INFO "oprofile: using %s\n", spec->name);
 	}
 

commit 10c03f69680e9e2acd8a9409a230aef37295ac49
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Dec 19 14:17:46 2006 +0000

    [ARM] oprofile: add ARM11 SMP support
    
    Add the glue for ARM11 SMP oprofile support, which also supports the
    performance monitor in the coherency unit.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index f1b24fbd8e67..0a007b931f63 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -139,6 +139,10 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	spec = &op_armv6_spec;
 #endif
 
+#ifdef CONFIG_OPROFILE_MPCORE
+	spec = &op_mpcore_spec;
+#endif
+
 	if (spec) {
 		ret = spec->init();
 		if (ret < 0)

commit 2d9e1ae06d8f0bb187ea083fabab2dfb6f589270
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Dec 19 12:41:22 2006 +0000

    [ARM] oprofile: add ARM11 UP support
    
    Add oprofile glue for ARM11 (ARMv6) oprofile support.  This
    connects the ARM11 core profiling support to the oprofile code
    for uniprocessor configurations.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index 6f833358cd06..f1b24fbd8e67 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -135,6 +135,10 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	spec = &op_xscale_spec;
 #endif
 
+#ifdef CONFIG_OPROFILE_ARMV6
+	spec = &op_armv6_spec;
+#endif
+
 	if (spec) {
 		ret = spec->init();
 		if (ret < 0)

commit 58e9ff56382bdce340d50b6ff22c422dc617106c
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Mar 20 16:52:32 2006 +0000

    [ARM] Use kcalloc to allocate counter_config array rather than kmalloc
    
    We need this to be zero initialised.  Since this is an array, use kcalloc
    rather than kzalloc or kmalloc.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index de72902ad0ca..6f833358cd06 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -140,7 +140,7 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 		if (ret < 0)
 			return ret;
 
-		counter_config = kmalloc(sizeof(struct op_counter_config) * spec->num_counters,
+		counter_config = kcalloc(spec->num_counters, sizeof(struct op_counter_config),
 					 GFP_KERNEL);
 		if (!counter_config)
 			return -ENOMEM;

commit ae92dc9f7bc9018f1d043f102747a1f1e4dd96fb
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Mar 16 11:32:51 2006 +0000

    [ARM] Oprofile: dynamically allocate counter_config
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index b57b6d11c9fb..de72902ad0ca 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -10,6 +10,7 @@
 #include <linux/init.h>
 #include <linux/oprofile.h>
 #include <linux/errno.h>
+#include <linux/slab.h>
 #include <linux/sysdev.h>
 #include <linux/mutex.h>
 
@@ -20,7 +21,7 @@ static struct op_arm_model_spec *op_arm_model;
 static int op_arm_enabled;
 static DEFINE_MUTEX(op_arm_mutex);
 
-struct op_counter_config counter_config[OP_MAX_COUNTER];
+struct op_counter_config *counter_config;
 
 static int op_arm_create_files(struct super_block *sb, struct dentry *root)
 {
@@ -28,7 +29,7 @@ static int op_arm_create_files(struct super_block *sb, struct dentry *root)
 
 	for (i = 0; i < op_arm_model->num_counters; i++) {
 		struct dentry *dir;
-		char buf[2];
+		char buf[4];
 
 		snprintf(buf, sizeof buf, "%d", i);
 		dir = oprofilefs_mkdir(sb, root, buf);
@@ -139,6 +140,11 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 		if (ret < 0)
 			return ret;
 
+		counter_config = kmalloc(sizeof(struct op_counter_config) * spec->num_counters,
+					 GFP_KERNEL);
+		if (!counter_config)
+			return -ENOMEM;
+
 		op_arm_model = spec;
 		init_driverfs();
 		ops->create_files = op_arm_create_files;
@@ -160,4 +166,5 @@ void oprofile_arch_exit(void)
 		exit_driverfs();
 		op_arm_model = NULL;
 	}
+	kfree(counter_config);
 }

commit 93ad79496c8831552d5f8ca7c182f149cc3cf19a
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Mar 16 11:38:16 2006 +0000

    [ARM] Oprofile: Convert semaphore to mutex
    
    op_arm_sem is being used as a mutex, so convert it to use
    real mutexes.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index 6f8bc1f0e6a1..b57b6d11c9fb 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -11,14 +11,14 @@
 #include <linux/oprofile.h>
 #include <linux/errno.h>
 #include <linux/sysdev.h>
-#include <asm/semaphore.h>
+#include <linux/mutex.h>
 
 #include "op_counter.h"
 #include "op_arm_model.h"
 
 static struct op_arm_model_spec *op_arm_model;
 static int op_arm_enabled;
-static struct semaphore op_arm_sem;
+static DEFINE_MUTEX(op_arm_mutex);
 
 struct op_counter_config counter_config[OP_MAX_COUNTER];
 
@@ -57,40 +57,40 @@ static int op_arm_start(void)
 {
 	int ret = -EBUSY;
 
-	down(&op_arm_sem);
+	mutex_lock(&op_arm_mutex);
 	if (!op_arm_enabled) {
 		ret = op_arm_model->start();
 		op_arm_enabled = !ret;
 	}
-	up(&op_arm_sem);
+	mutex_unlock(&op_arm_mutex);
 	return ret;
 }
 
 static void op_arm_stop(void)
 {
-	down(&op_arm_sem);
+	mutex_lock(&op_arm_mutex);
 	if (op_arm_enabled)
 		op_arm_model->stop();
 	op_arm_enabled = 0;
-	up(&op_arm_sem);
+	mutex_unlock(&op_arm_mutex);
 }
 
 #ifdef CONFIG_PM
 static int op_arm_suspend(struct sys_device *dev, pm_message_t state)
 {
-	down(&op_arm_sem);
+	mutex_lock(&op_arm_mutex);
 	if (op_arm_enabled)
 		op_arm_model->stop();
-	up(&op_arm_sem);
+	mutex_unlock(&op_arm_mutex);
 	return 0;
 }
 
 static int op_arm_resume(struct sys_device *dev)
 {
-	down(&op_arm_sem);
+	mutex_lock(&op_arm_mutex);
 	if (op_arm_enabled && op_arm_model->start())
 		op_arm_enabled = 0;
-	up(&op_arm_sem);
+	mutex_unlock(&op_arm_mutex);
 	return 0;
 }
 
@@ -135,8 +135,6 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 #endif
 
 	if (spec) {
-		init_MUTEX(&op_arm_sem);
-
 		ret = spec->init();
 		if (ret < 0)
 			return ret;
@@ -163,4 +161,3 @@ void oprofile_arch_exit(void)
 		op_arm_model = NULL;
 	}
 }
-

commit 7610dfa3723e87705964b29db9775620d96bf618
Author: Russ Dill <Russ.Dill@gmail.com>
Date:   Wed Feb 1 21:07:28 2006 +0000

    [ARM] 3295/1: Fix oprofile init return value
    
    Patch from Russ Dill
    
    The oprofile init code was broken in commit c6b9da. The new logic will
    always return -ENODEV. This fixes oprofile_arch_init to return 0 on
    success, and return the return value of spec->init() if applicable.
    
    Signed-off-by: Russ Dill <Russ.Dill@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index 1415930ceee1..6f8bc1f0e6a1 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -137,8 +137,9 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	if (spec) {
 		init_MUTEX(&op_arm_sem);
 
-		if (spec->init() < 0)
-			return -ENODEV;
+		ret = spec->init();
+		if (ret < 0)
+			return ret;
 
 		op_arm_model = spec;
 		init_driverfs();

commit c6b9dafce3e3b434a3e7ffd5072815c03d18cc84
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Oct 28 14:56:04 2005 +0100

    [ARM] 4/4 Combine oprofile common and init code
    
    There is nothing special about having the init code separate from
    the common code, so combine the two.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index 7ce6dfa06c85..1415930ceee1 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -125,27 +125,37 @@ static void  exit_driverfs(void)
 #define exit_driverfs() do { } while (0)
 #endif /* CONFIG_PM */
 
-int __init op_arm_init(struct oprofile_operations *ops, struct op_arm_model_spec *spec)
+int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
-	init_MUTEX(&op_arm_sem);
-
-	if (spec->init() < 0)
-		return -ENODEV;
-
-	op_arm_model = spec;
-	init_driverfs();
-	ops->create_files = op_arm_create_files;
-	ops->setup = op_arm_setup;
-	ops->shutdown = op_arm_stop;
-	ops->start = op_arm_start;
-	ops->stop = op_arm_stop;
-	ops->cpu_type = op_arm_model->name;
-	printk(KERN_INFO "oprofile: using %s\n", spec->name);
+	struct op_arm_model_spec *spec = NULL;
+	int ret = -ENODEV;
+
+#ifdef CONFIG_CPU_XSCALE
+	spec = &op_xscale_spec;
+#endif
+
+	if (spec) {
+		init_MUTEX(&op_arm_sem);
+
+		if (spec->init() < 0)
+			return -ENODEV;
+
+		op_arm_model = spec;
+		init_driverfs();
+		ops->create_files = op_arm_create_files;
+		ops->setup = op_arm_setup;
+		ops->shutdown = op_arm_stop;
+		ops->start = op_arm_start;
+		ops->stop = op_arm_stop;
+		ops->cpu_type = op_arm_model->name;
+		ops->backtrace = arm_backtrace;
+		printk(KERN_INFO "oprofile: using %s\n", spec->name);
+	}
 
-	return 0;
+	return ret;
 }
 
-void op_arm_exit(void)
+void oprofile_arch_exit(void)
 {
 	if (op_arm_model) {
 		exit_driverfs();

commit 55f052341ff75e5815b1f7f4d2d3b69314ea8712
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Oct 28 14:54:21 2005 +0100

    [ARM] 3/4 Rename common oprofile code
    
    The common oprofile code assumes the name "PMU" (from Intel's
    performance management unit).  This is misleading when we
    start adding oprofile support for other machine types which
    don't use the same terminology.  Call it op_arm_* instead of
    pmu_*.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index 02e5d6f45166..7ce6dfa06c85 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -16,17 +16,17 @@
 #include "op_counter.h"
 #include "op_arm_model.h"
 
-static struct op_arm_model_spec *pmu_model;
-static int pmu_enabled;
-static struct semaphore pmu_sem;
+static struct op_arm_model_spec *op_arm_model;
+static int op_arm_enabled;
+static struct semaphore op_arm_sem;
 
 struct op_counter_config counter_config[OP_MAX_COUNTER];
 
-static int pmu_create_files(struct super_block *sb, struct dentry *root)
+static int op_arm_create_files(struct super_block *sb, struct dentry *root)
 {
 	unsigned int i;
 
-	for (i = 0; i < pmu_model->num_counters; i++) {
+	for (i = 0; i < op_arm_model->num_counters; i++) {
 		struct dentry *dir;
 		char buf[2];
 
@@ -43,61 +43,61 @@ static int pmu_create_files(struct super_block *sb, struct dentry *root)
 	return 0;
 }
 
-static int pmu_setup(void)
+static int op_arm_setup(void)
 {
 	int ret;
 
 	spin_lock(&oprofilefs_lock);
-	ret = pmu_model->setup_ctrs();
+	ret = op_arm_model->setup_ctrs();
 	spin_unlock(&oprofilefs_lock);
 	return ret;
 }
 
-static int pmu_start(void)
+static int op_arm_start(void)
 {
 	int ret = -EBUSY;
 
-	down(&pmu_sem);
-	if (!pmu_enabled) {
-		ret = pmu_model->start();
-		pmu_enabled = !ret;
+	down(&op_arm_sem);
+	if (!op_arm_enabled) {
+		ret = op_arm_model->start();
+		op_arm_enabled = !ret;
 	}
-	up(&pmu_sem);
+	up(&op_arm_sem);
 	return ret;
 }
 
-static void pmu_stop(void)
+static void op_arm_stop(void)
 {
-	down(&pmu_sem);
-	if (pmu_enabled)
-		pmu_model->stop();
-	pmu_enabled = 0;
-	up(&pmu_sem);
+	down(&op_arm_sem);
+	if (op_arm_enabled)
+		op_arm_model->stop();
+	op_arm_enabled = 0;
+	up(&op_arm_sem);
 }
 
 #ifdef CONFIG_PM
-static int pmu_suspend(struct sys_device *dev, pm_message_t state)
+static int op_arm_suspend(struct sys_device *dev, pm_message_t state)
 {
-	down(&pmu_sem);
-	if (pmu_enabled)
-		pmu_model->stop();
-	up(&pmu_sem);
+	down(&op_arm_sem);
+	if (op_arm_enabled)
+		op_arm_model->stop();
+	up(&op_arm_sem);
 	return 0;
 }
 
-static int pmu_resume(struct sys_device *dev)
+static int op_arm_resume(struct sys_device *dev)
 {
-	down(&pmu_sem);
-	if (pmu_enabled && pmu_model->start())
-		pmu_enabled = 0;
-	up(&pmu_sem);
+	down(&op_arm_sem);
+	if (op_arm_enabled && op_arm_model->start())
+		op_arm_enabled = 0;
+	up(&op_arm_sem);
 	return 0;
 }
 
 static struct sysdev_class oprofile_sysclass = {
 	set_kset_name("oprofile"),
-	.resume		= pmu_resume,
-	.suspend	= pmu_suspend,
+	.resume		= op_arm_resume,
+	.suspend	= op_arm_suspend,
 };
 
 static struct sys_device device_oprofile = {
@@ -125,31 +125,31 @@ static void  exit_driverfs(void)
 #define exit_driverfs() do { } while (0)
 #endif /* CONFIG_PM */
 
-int __init pmu_init(struct oprofile_operations *ops, struct op_arm_model_spec *spec)
+int __init op_arm_init(struct oprofile_operations *ops, struct op_arm_model_spec *spec)
 {
-	init_MUTEX(&pmu_sem);
+	init_MUTEX(&op_arm_sem);
 
 	if (spec->init() < 0)
 		return -ENODEV;
 
-	pmu_model = spec;
+	op_arm_model = spec;
 	init_driverfs();
-	ops->create_files = pmu_create_files;
-	ops->setup = pmu_setup;
-	ops->shutdown = pmu_stop;
-	ops->start = pmu_start;
-	ops->stop = pmu_stop;
-	ops->cpu_type = pmu_model->name;
-	printk(KERN_INFO "oprofile: using %s PMU\n", spec->name);
+	ops->create_files = op_arm_create_files;
+	ops->setup = op_arm_setup;
+	ops->shutdown = op_arm_stop;
+	ops->start = op_arm_start;
+	ops->stop = op_arm_stop;
+	ops->cpu_type = op_arm_model->name;
+	printk(KERN_INFO "oprofile: using %s\n", spec->name);
 
 	return 0;
 }
 
-void pmu_exit(void)
+void op_arm_exit(void)
 {
-	if (pmu_model) {
+	if (op_arm_model) {
 		exit_driverfs();
-		pmu_model = NULL;
+		op_arm_model = NULL;
 	}
 }
 

commit 7c5b3fc20807279d8f8e78f1e2ef275128668796
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Oct 28 14:52:30 2005 +0100

    [ARM] 2/4 Fix oprofile suspend/resume
    
    The oprofile suspend/resume was missing locking.  If we failed
    to start oprofile on resume, we still reported that it was
    enabled.  Instead, disable oprofile on error.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index 5b1d752edbc3..02e5d6f45166 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -78,15 +78,19 @@ static void pmu_stop(void)
 #ifdef CONFIG_PM
 static int pmu_suspend(struct sys_device *dev, pm_message_t state)
 {
+	down(&pmu_sem);
 	if (pmu_enabled)
-		pmu_stop();
+		pmu_model->stop();
+	up(&pmu_sem);
 	return 0;
 }
 
 static int pmu_resume(struct sys_device *dev)
 {
-	if (pmu_enabled)
-		pmu_start();
+	down(&pmu_sem);
+	if (pmu_enabled && pmu_model->start())
+		pmu_enabled = 0;
+	up(&pmu_sem);
 	return 0;
 }
 

commit b5893c56ca7e664aef010a71c2638db768d4e996
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Oct 28 14:51:15 2005 +0100

    [ARM] 1/4 Move oprofile driver model code
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index e57dde882898..5b1d752edbc3 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -10,8 +10,8 @@
 #include <linux/init.h>
 #include <linux/oprofile.h>
 #include <linux/errno.h>
-#include <asm/semaphore.h>
 #include <linux/sysdev.h>
+#include <asm/semaphore.h>
 
 #include "op_counter.h"
 #include "op_arm_model.h"
@@ -20,57 +20,6 @@ static struct op_arm_model_spec *pmu_model;
 static int pmu_enabled;
 static struct semaphore pmu_sem;
 
-static int pmu_start(void);
-static int pmu_setup(void);
-static void pmu_stop(void);
-static int pmu_create_files(struct super_block *, struct dentry *);
-
-#ifdef CONFIG_PM
-static int pmu_suspend(struct sys_device *dev, pm_message_t state)
-{
-	if (pmu_enabled)
-		pmu_stop();
-	return 0;
-}
-
-static int pmu_resume(struct sys_device *dev)
-{
-	if (pmu_enabled)
-		pmu_start();
-	return 0;
-}
-
-static struct sysdev_class oprofile_sysclass = {
-	set_kset_name("oprofile"),
-	.resume		= pmu_resume,
-	.suspend	= pmu_suspend,
-};
-
-static struct sys_device device_oprofile = {
-	.id		= 0,
-	.cls		= &oprofile_sysclass,
-};
-
-static int __init init_driverfs(void)
-{
-	int ret;
-
-	if (!(ret = sysdev_class_register(&oprofile_sysclass)))
-		ret = sysdev_register(&device_oprofile);
-
-	return ret;
-}
-
-static void  exit_driverfs(void)
-{
-	sysdev_unregister(&device_oprofile);
-	sysdev_class_unregister(&oprofile_sysclass);
-}
-#else
-#define init_driverfs()	do { } while (0)
-#define exit_driverfs() do { } while (0)
-#endif /* CONFIG_PM */
-
 struct op_counter_config counter_config[OP_MAX_COUNTER];
 
 static int pmu_create_files(struct super_block *sb, struct dentry *root)
@@ -126,6 +75,52 @@ static void pmu_stop(void)
 	up(&pmu_sem);
 }
 
+#ifdef CONFIG_PM
+static int pmu_suspend(struct sys_device *dev, pm_message_t state)
+{
+	if (pmu_enabled)
+		pmu_stop();
+	return 0;
+}
+
+static int pmu_resume(struct sys_device *dev)
+{
+	if (pmu_enabled)
+		pmu_start();
+	return 0;
+}
+
+static struct sysdev_class oprofile_sysclass = {
+	set_kset_name("oprofile"),
+	.resume		= pmu_resume,
+	.suspend	= pmu_suspend,
+};
+
+static struct sys_device device_oprofile = {
+	.id		= 0,
+	.cls		= &oprofile_sysclass,
+};
+
+static int __init init_driverfs(void)
+{
+	int ret;
+
+	if (!(ret = sysdev_class_register(&oprofile_sysclass)))
+		ret = sysdev_register(&device_oprofile);
+
+	return ret;
+}
+
+static void  exit_driverfs(void)
+{
+	sysdev_unregister(&device_oprofile);
+	sysdev_class_unregister(&oprofile_sysclass);
+}
+#else
+#define init_driverfs()	do { } while (0)
+#define exit_driverfs() do { } while (0)
+#endif /* CONFIG_PM */
+
 int __init pmu_init(struct oprofile_operations *ops, struct op_arm_model_spec *spec)
 {
 	init_MUTEX(&pmu_sem);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
new file mode 100644
index 000000000000..e57dde882898
--- /dev/null
+++ b/arch/arm/oprofile/common.c
@@ -0,0 +1,156 @@
+/**
+ * @file common.c
+ *
+ * @remark Copyright 2004 Oprofile Authors
+ * @remark Read the file COPYING
+ *
+ * @author Zwane Mwaikambo
+ */
+
+#include <linux/init.h>
+#include <linux/oprofile.h>
+#include <linux/errno.h>
+#include <asm/semaphore.h>
+#include <linux/sysdev.h>
+
+#include "op_counter.h"
+#include "op_arm_model.h"
+
+static struct op_arm_model_spec *pmu_model;
+static int pmu_enabled;
+static struct semaphore pmu_sem;
+
+static int pmu_start(void);
+static int pmu_setup(void);
+static void pmu_stop(void);
+static int pmu_create_files(struct super_block *, struct dentry *);
+
+#ifdef CONFIG_PM
+static int pmu_suspend(struct sys_device *dev, pm_message_t state)
+{
+	if (pmu_enabled)
+		pmu_stop();
+	return 0;
+}
+
+static int pmu_resume(struct sys_device *dev)
+{
+	if (pmu_enabled)
+		pmu_start();
+	return 0;
+}
+
+static struct sysdev_class oprofile_sysclass = {
+	set_kset_name("oprofile"),
+	.resume		= pmu_resume,
+	.suspend	= pmu_suspend,
+};
+
+static struct sys_device device_oprofile = {
+	.id		= 0,
+	.cls		= &oprofile_sysclass,
+};
+
+static int __init init_driverfs(void)
+{
+	int ret;
+
+	if (!(ret = sysdev_class_register(&oprofile_sysclass)))
+		ret = sysdev_register(&device_oprofile);
+
+	return ret;
+}
+
+static void  exit_driverfs(void)
+{
+	sysdev_unregister(&device_oprofile);
+	sysdev_class_unregister(&oprofile_sysclass);
+}
+#else
+#define init_driverfs()	do { } while (0)
+#define exit_driverfs() do { } while (0)
+#endif /* CONFIG_PM */
+
+struct op_counter_config counter_config[OP_MAX_COUNTER];
+
+static int pmu_create_files(struct super_block *sb, struct dentry *root)
+{
+	unsigned int i;
+
+	for (i = 0; i < pmu_model->num_counters; i++) {
+		struct dentry *dir;
+		char buf[2];
+
+		snprintf(buf, sizeof buf, "%d", i);
+		dir = oprofilefs_mkdir(sb, root, buf);
+		oprofilefs_create_ulong(sb, dir, "enabled", &counter_config[i].enabled);
+		oprofilefs_create_ulong(sb, dir, "event", &counter_config[i].event);
+		oprofilefs_create_ulong(sb, dir, "count", &counter_config[i].count);
+		oprofilefs_create_ulong(sb, dir, "unit_mask", &counter_config[i].unit_mask);
+		oprofilefs_create_ulong(sb, dir, "kernel", &counter_config[i].kernel);
+		oprofilefs_create_ulong(sb, dir, "user", &counter_config[i].user);
+	}
+
+	return 0;
+}
+
+static int pmu_setup(void)
+{
+	int ret;
+
+	spin_lock(&oprofilefs_lock);
+	ret = pmu_model->setup_ctrs();
+	spin_unlock(&oprofilefs_lock);
+	return ret;
+}
+
+static int pmu_start(void)
+{
+	int ret = -EBUSY;
+
+	down(&pmu_sem);
+	if (!pmu_enabled) {
+		ret = pmu_model->start();
+		pmu_enabled = !ret;
+	}
+	up(&pmu_sem);
+	return ret;
+}
+
+static void pmu_stop(void)
+{
+	down(&pmu_sem);
+	if (pmu_enabled)
+		pmu_model->stop();
+	pmu_enabled = 0;
+	up(&pmu_sem);
+}
+
+int __init pmu_init(struct oprofile_operations *ops, struct op_arm_model_spec *spec)
+{
+	init_MUTEX(&pmu_sem);
+
+	if (spec->init() < 0)
+		return -ENODEV;
+
+	pmu_model = spec;
+	init_driverfs();
+	ops->create_files = pmu_create_files;
+	ops->setup = pmu_setup;
+	ops->shutdown = pmu_stop;
+	ops->start = pmu_start;
+	ops->stop = pmu_stop;
+	ops->cpu_type = pmu_model->name;
+	printk(KERN_INFO "oprofile: using %s PMU\n", spec->name);
+
+	return 0;
+}
+
+void pmu_exit(void)
+{
+	if (pmu_model) {
+		exit_driverfs();
+		pmu_model = NULL;
+	}
+}
+
