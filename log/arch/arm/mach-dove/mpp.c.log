commit ce78179ea6e042e2d3af0a1c71c105431ead483a
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jul 31 21:56:54 2019 +0200

    ARM: dove: clean up mach/*.h headers
    
    This is a simple move of all header files that are no longer
    included by anything else from the include/mach directory
    to the platform directory itself as preparation for
    multiplatform support.
    
    The mach/uncompress.h headers are left in place for now,
    and are mildly modified to be independent of the other
    headers. They will be removed entirely when ARCH_MULTIPLATFORM
    gets enabled and they become obsolete.
    
    Rather than updating the path names inside of the comments
    of each header, I delete those comments to avoid having to
    update them again, should they get moved or copied another
    time.
    
    Link: https://lore.kernel.org/r/20190731195713.3150463-13-arnd@arndb.de
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-dove/mpp.c b/arch/arm/mach-dove/mpp.c
index 8a433a51289c..6acd8488bb05 100644
--- a/arch/arm/mach-dove/mpp.c
+++ b/arch/arm/mach-dove/mpp.c
@@ -12,8 +12,8 @@
 #include <linux/gpio.h>
 #include <linux/io.h>
 #include <plat/mpp.h>
-#include <mach/dove.h>
 #include <plat/orion-gpio.h>
+#include "dove.h"
 #include "mpp.h"
 
 struct dove_mpp_grp {

commit 2746a7c272a3242f919fa2fd5a5f2d9f8a41173a
Author: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
Date:   Mon Jul 1 16:56:12 2013 +0200

    ARM: dove: fix missing __init section of dove_mpp_gpio_mode
    
    Legacy dove_mpp_gpio_mode calls orion_gpio_set_valid which is in
    __init section. Offending function is not, so this causes a section
    mismatch. To fix the mismatch, also move dove_mpp_gpio_mode to
    __init section.
    
    Signed-off-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-dove/mpp.c b/arch/arm/mach-dove/mpp.c
index 60bd729a1ba5..8a433a51289c 100644
--- a/arch/arm/mach-dove/mpp.c
+++ b/arch/arm/mach-dove/mpp.c
@@ -47,7 +47,7 @@ static const struct dove_mpp_grp dove_mpp_grp[] = {
 
 /* Enable gpio for a range of pins. mode should be a combination of
    GPIO_OUTPUT_OK | GPIO_INPUT_OK */
-static void dove_mpp_gpio_mode(int start, int end, int gpio_mode)
+static void __init dove_mpp_gpio_mode(int start, int end, int gpio_mode)
 {
 	int i;
 

commit ce91574c202b8581ad15bfb1427af824f462c3d2
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Wed Aug 29 10:16:55 2012 -0500

    ARM: orion: move custom gpio functions to orion-gpio.h
    
    Move custom orion platforms gpio code to orion-gpio to remove the
    dependency on mach/gpio.h.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>

diff --git a/arch/arm/mach-dove/mpp.c b/arch/arm/mach-dove/mpp.c
index 7f70afc26f91..60bd729a1ba5 100644
--- a/arch/arm/mach-dove/mpp.c
+++ b/arch/arm/mach-dove/mpp.c
@@ -13,6 +13,7 @@
 #include <linux/io.h>
 #include <plat/mpp.h>
 #include <mach/dove.h>
+#include <plat/orion-gpio.h>
 #include "mpp.h"
 
 struct dove_mpp_grp {

commit ca2ac5cc9548e954b295de16158a5a7e3b97873b
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Mon May 14 11:28:43 2012 +0200

    Dove: Fix Section mismatch warnings
    
    Add missing __init markups to GPIO and timer functions.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>

diff --git a/arch/arm/mach-dove/mpp.c b/arch/arm/mach-dove/mpp.c
index 51e0e411c9cb..7f70afc26f91 100644
--- a/arch/arm/mach-dove/mpp.c
+++ b/arch/arm/mach-dove/mpp.c
@@ -56,7 +56,7 @@ static void dove_mpp_gpio_mode(int start, int end, int gpio_mode)
 
 /* Dump all the extra MPP registers. The platform code will dump the
    registers for pins 0-23. */
-static void dove_mpp_dump_regs(void)
+static void __init dove_mpp_dump_regs(void)
 {
 	pr_debug("PMU_CTRL4_CTRL: %08x\n",
 		 readl(DOVE_MPP_CTRL4_VIRT_BASE));
@@ -67,7 +67,7 @@ static void dove_mpp_dump_regs(void)
 	pr_debug("MPP_GENERAL: %08x\n", readl(DOVE_MPP_GENERAL_VIRT_BASE));
 }
 
-static void dove_mpp_cfg_nfc(int sel)
+static void __init dove_mpp_cfg_nfc(int sel)
 {
 	u32 mpp_gen_cfg = readl(DOVE_MPP_GENERAL_VIRT_BASE);
 
@@ -78,7 +78,7 @@ static void dove_mpp_cfg_nfc(int sel)
 	dove_mpp_gpio_mode(64, 71, GPIO_OUTPUT_OK);
 }
 
-static void dove_mpp_cfg_au1(int sel)
+static void __init dove_mpp_cfg_au1(int sel)
 {
 	u32 mpp_ctrl4 = readl(DOVE_MPP_CTRL4_VIRT_BASE);
 	u32 ssp_ctrl1 = readl(DOVE_SSP_CTRL_STATUS_1);
@@ -118,7 +118,7 @@ static void dove_mpp_cfg_au1(int sel)
 
 /* Configure the group registers, enabling GPIO if sel indicates the
    pin is to be used for GPIO */
-static void dove_mpp_conf_grp(unsigned int *mpp_grp_list)
+static void __init dove_mpp_conf_grp(unsigned int *mpp_grp_list)
 {
 	u32 mpp_ctrl4 = readl(DOVE_MPP_CTRL4_VIRT_BASE);
 	int gpio_mode;

commit 3cff484d4b264ff467a3b45c544cbbbab69f0bf8
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun May 15 13:32:54 2011 +0200

    ARM: dove: Consolidate mpp code with platform mpp.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/mach-dove/mpp.c b/arch/arm/mach-dove/mpp.c
index c66c76346904..51e0e411c9cb 100644
--- a/arch/arm/mach-dove/mpp.c
+++ b/arch/arm/mach-dove/mpp.c
@@ -11,24 +11,17 @@
 #include <linux/kernel.h>
 #include <linux/gpio.h>
 #include <linux/io.h>
-
+#include <plat/mpp.h>
 #include <mach/dove.h>
-
 #include "mpp.h"
 
-#define MPP_NR_REGS 4
-#define MPP_CTRL(i)	((i) == 3 ?				\
-			 DOVE_MPP_CTRL4_VIRT_BASE :		\
-			 DOVE_MPP_VIRT_BASE + (i) * 4)
-#define PMU_SIG_REGS 2
-#define PMU_SIG_CTRL(i)	(DOVE_PMU_SIG_CTRL + (i) * 4)
-
 struct dove_mpp_grp {
 	int start;
 	int end;
 };
 
-static struct dove_mpp_grp dove_mpp_grp[] = {
+/* Map a group to a range of GPIO pins in that group */
+static const struct dove_mpp_grp dove_mpp_grp[] = {
 	[MPP_24_39] = {
 		.start	= 24,
 		.end	= 39,
@@ -38,8 +31,8 @@ static struct dove_mpp_grp dove_mpp_grp[] = {
 		.end	= 45,
 	},
 	[MPP_46_51] = {
-		.start	= 40,
-		.end	= 45,
+		.start	= 46,
+		.end	= 51,
 	},
 	[MPP_58_61] = {
 		.start	= 58,
@@ -51,6 +44,8 @@ static struct dove_mpp_grp dove_mpp_grp[] = {
 	},
 };
 
+/* Enable gpio for a range of pins. mode should be a combination of
+   GPIO_OUTPUT_OK | GPIO_INPUT_OK */
 static void dove_mpp_gpio_mode(int start, int end, int gpio_mode)
 {
 	int i;
@@ -59,24 +54,17 @@ static void dove_mpp_gpio_mode(int start, int end, int gpio_mode)
 		orion_gpio_set_valid(i, gpio_mode);
 }
 
+/* Dump all the extra MPP registers. The platform code will dump the
+   registers for pins 0-23. */
 static void dove_mpp_dump_regs(void)
 {
-#ifdef DEBUG
-	int i;
+	pr_debug("PMU_CTRL4_CTRL: %08x\n",
+		 readl(DOVE_MPP_CTRL4_VIRT_BASE));
 
-	pr_debug("MPP_CTRL regs:");
-	for (i = 0; i < MPP_NR_REGS; i++)
-		printk(" %08x", readl(MPP_CTRL(i)));
-	printk("\n");
+	pr_debug("PMU_MPP_GENERAL_CTRL: %08x\n",
+		 readl(DOVE_PMU_MPP_GENERAL_CTRL));
 
-	pr_debug("PMU_SIG_CTRL regs:");
-	for (i = 0; i < PMU_SIG_REGS; i++)
-		printk(" %08x", readl(PMU_SIG_CTRL(i)));
-	printk("\n");
-
-	pr_debug("PMU_MPP_GENERAL_CTRL: %08x\n", readl(DOVE_PMU_MPP_GENERAL_CTRL));
 	pr_debug("MPP_GENERAL: %08x\n", readl(DOVE_MPP_GENERAL_VIRT_BASE));
-#endif
 }
 
 static void dove_mpp_cfg_nfc(int sel)
@@ -92,7 +80,7 @@ static void dove_mpp_cfg_nfc(int sel)
 
 static void dove_mpp_cfg_au1(int sel)
 {
-	u32 mpp_ctrl4		= readl(DOVE_MPP_CTRL4_VIRT_BASE);
+	u32 mpp_ctrl4 = readl(DOVE_MPP_CTRL4_VIRT_BASE);
 	u32 ssp_ctrl1 = readl(DOVE_SSP_CTRL_STATUS_1);
 	u32 mpp_gen_ctrl = readl(DOVE_MPP_GENERAL_VIRT_BASE);
 	u32 global_cfg_2 = readl(DOVE_GLOBAL_CONFIG_2);
@@ -128,82 +116,46 @@ static void dove_mpp_cfg_au1(int sel)
 	writel(global_cfg_2, DOVE_GLOBAL_CONFIG_2);
 }
 
-static void dove_mpp_conf_grp(int num, int sel, u32 *mpp_ctrl)
-{
-	int start = dove_mpp_grp[num].start;
-	int end = dove_mpp_grp[num].end;
-	int gpio_mode = sel ? GPIO_OUTPUT_OK | GPIO_INPUT_OK : 0;
-
-	*mpp_ctrl &= ~(0x1 << num);
-	*mpp_ctrl |= sel << num;
-
-	dove_mpp_gpio_mode(start, end, gpio_mode);
-}
-
-void __init dove_mpp_conf(unsigned int *mpp_list)
+/* Configure the group registers, enabling GPIO if sel indicates the
+   pin is to be used for GPIO */
+static void dove_mpp_conf_grp(unsigned int *mpp_grp_list)
 {
-	u32 mpp_ctrl[MPP_NR_REGS];
-	u32 pmu_mpp_ctrl = 0;
-	u32 pmu_sig_ctrl[PMU_SIG_REGS];
-	int i;
-
-	for (i = 0; i < MPP_NR_REGS; i++)
-		mpp_ctrl[i] = readl(MPP_CTRL(i));
-
-	for (i = 0; i < PMU_SIG_REGS; i++)
-		pmu_sig_ctrl[i] = readl(PMU_SIG_CTRL(i));
-
-	pmu_mpp_ctrl = readl(DOVE_PMU_MPP_GENERAL_CTRL);
+	u32 mpp_ctrl4 = readl(DOVE_MPP_CTRL4_VIRT_BASE);
+	int gpio_mode;
 
-	dove_mpp_dump_regs();
-
-	for ( ; *mpp_list != MPP_END; mpp_list++) {
-		unsigned int num = MPP_NUM(*mpp_list);
-		unsigned int sel = MPP_SEL(*mpp_list);
-		int shift, gpio_mode;
-
-		if (num > MPP_MAX) {
-			pr_err("dove: invalid MPP number (%u)\n", num);
-			continue;
-		}
-
-		if (*mpp_list & MPP_NFC_MASK) {
-			dove_mpp_cfg_nfc(sel);
-			continue;
-		}
+	for ( ; *mpp_grp_list; mpp_grp_list++) {
+		unsigned int num = MPP_NUM(*mpp_grp_list);
+		unsigned int sel = MPP_SEL(*mpp_grp_list);
 
-		if (*mpp_list & MPP_AU1_MASK) {
-			dove_mpp_cfg_au1(sel);
+		if (num > MPP_GRP_MAX) {
+			pr_err("dove: invalid MPP GRP number (%u)\n", num);
 			continue;
 		}
 
-		if (*mpp_list & MPP_GRP_MASK) {
-			dove_mpp_conf_grp(num, sel, &mpp_ctrl[3]);
-			continue;
-		}
-
-		shift = (num & 7) << 2;
-		if (*mpp_list & MPP_PMU_MASK) {
-			pmu_mpp_ctrl |= (0x1 << num);
-			pmu_sig_ctrl[num / 8] &= ~(0xf << shift);
-			pmu_sig_ctrl[num / 8] |= 0xf << shift;
-			gpio_mode = 0;
-		} else {
-			mpp_ctrl[num / 8] &= ~(0xf << shift);
-			mpp_ctrl[num / 8] |= sel << shift;
-			gpio_mode = GPIO_OUTPUT_OK | GPIO_INPUT_OK;
-		}
+		mpp_ctrl4 &= ~(0x1 << num);
+		mpp_ctrl4 |= sel << num;
 
-		orion_gpio_set_valid(num, gpio_mode);
+		gpio_mode = sel ? GPIO_OUTPUT_OK | GPIO_INPUT_OK : 0;
+		dove_mpp_gpio_mode(dove_mpp_grp[num].start,
+				   dove_mpp_grp[num].end, gpio_mode);
 	}
+	writel(mpp_ctrl4, DOVE_MPP_CTRL4_VIRT_BASE);
+}
 
-	for (i = 0; i < MPP_NR_REGS; i++)
-		writel(mpp_ctrl[i], MPP_CTRL(i));
+/* Configure the various MPP pins on Dove */
+void __init dove_mpp_conf(unsigned int *mpp_list,
+			  unsigned int *mpp_grp_list,
+			  unsigned int grp_au1_52_57,
+			  unsigned int grp_nfc_64_71)
+{
+	dove_mpp_dump_regs();
 
-	for (i = 0; i < PMU_SIG_REGS; i++)
-		writel(pmu_sig_ctrl[i], PMU_SIG_CTRL(i));
+	/* Use platform code for pins 0-23 */
+	orion_mpp_conf(mpp_list, 0, MPP_MAX, DOVE_MPP_VIRT_BASE);
 
-	writel(pmu_mpp_ctrl, DOVE_PMU_MPP_GENERAL_CTRL);
+	dove_mpp_conf_grp(mpp_grp_list);
+	dove_mpp_cfg_au1(grp_au1_52_57);
+	dove_mpp_cfg_nfc(grp_nfc_64_71);
 
 	dove_mpp_dump_regs();
 }

commit a40bd62153db5031f2afacd1615be8759684ce18
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 28 11:26:09 2011 +0200

    arm: dove: Use correct GPIO_BASE and remove orion_gpio_init() leftover
    
    commit 9eac6d0 (ARM: Remove dependency of plat-orion GPIO code on mach
    directory includes) missed to convert one instance of
    DOVE_GPIO_VIRT_BASE and left the orion_gpio_init() in mpp.c
    
    Fix it up.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/mach-dove/mpp.c b/arch/arm/mach-dove/mpp.c
index 71db2bdf2f28..c66c76346904 100644
--- a/arch/arm/mach-dove/mpp.c
+++ b/arch/arm/mach-dove/mpp.c
@@ -147,9 +147,6 @@ void __init dove_mpp_conf(unsigned int *mpp_list)
 	u32 pmu_sig_ctrl[PMU_SIG_REGS];
 	int i;
 
-	/* Initialize gpiolib. */
-	orion_gpio_init();
-
 	for (i = 0; i < MPP_NR_REGS; i++)
 		mpp_ctrl[i] = readl(MPP_CTRL(i));
 

commit 5af244fdf2a2405b2181da2a32636f3ca5ef162e
Author: Mike Rapoport <mike@compulab.co.il>
Date:   Mon Nov 15 11:48:33 2010 +0200

    [ARM] Dove: add support for multi-purpose pins configuration
    
    Signed-off-by: Mike Rapoport <mike@compulab.co.il>
    Acked-by: Saeed Bishara <saeed@marvell.com>
    Signed-off-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/mach-dove/mpp.c b/arch/arm/mach-dove/mpp.c
new file mode 100644
index 000000000000..71db2bdf2f28
--- /dev/null
+++ b/arch/arm/mach-dove/mpp.c
@@ -0,0 +1,212 @@
+/*
+ * arch/arm/mach-dove/mpp.c
+ *
+ * MPP functions for Marvell Dove SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+
+#include <mach/dove.h>
+
+#include "mpp.h"
+
+#define MPP_NR_REGS 4
+#define MPP_CTRL(i)	((i) == 3 ?				\
+			 DOVE_MPP_CTRL4_VIRT_BASE :		\
+			 DOVE_MPP_VIRT_BASE + (i) * 4)
+#define PMU_SIG_REGS 2
+#define PMU_SIG_CTRL(i)	(DOVE_PMU_SIG_CTRL + (i) * 4)
+
+struct dove_mpp_grp {
+	int start;
+	int end;
+};
+
+static struct dove_mpp_grp dove_mpp_grp[] = {
+	[MPP_24_39] = {
+		.start	= 24,
+		.end	= 39,
+	},
+	[MPP_40_45] = {
+		.start	= 40,
+		.end	= 45,
+	},
+	[MPP_46_51] = {
+		.start	= 40,
+		.end	= 45,
+	},
+	[MPP_58_61] = {
+		.start	= 58,
+		.end	= 61,
+	},
+	[MPP_62_63] = {
+		.start	= 62,
+		.end	= 63,
+	},
+};
+
+static void dove_mpp_gpio_mode(int start, int end, int gpio_mode)
+{
+	int i;
+
+	for (i = start; i <= end; i++)
+		orion_gpio_set_valid(i, gpio_mode);
+}
+
+static void dove_mpp_dump_regs(void)
+{
+#ifdef DEBUG
+	int i;
+
+	pr_debug("MPP_CTRL regs:");
+	for (i = 0; i < MPP_NR_REGS; i++)
+		printk(" %08x", readl(MPP_CTRL(i)));
+	printk("\n");
+
+	pr_debug("PMU_SIG_CTRL regs:");
+	for (i = 0; i < PMU_SIG_REGS; i++)
+		printk(" %08x", readl(PMU_SIG_CTRL(i)));
+	printk("\n");
+
+	pr_debug("PMU_MPP_GENERAL_CTRL: %08x\n", readl(DOVE_PMU_MPP_GENERAL_CTRL));
+	pr_debug("MPP_GENERAL: %08x\n", readl(DOVE_MPP_GENERAL_VIRT_BASE));
+#endif
+}
+
+static void dove_mpp_cfg_nfc(int sel)
+{
+	u32 mpp_gen_cfg = readl(DOVE_MPP_GENERAL_VIRT_BASE);
+
+	mpp_gen_cfg &= ~0x1;
+	mpp_gen_cfg |= sel;
+	writel(mpp_gen_cfg, DOVE_MPP_GENERAL_VIRT_BASE);
+
+	dove_mpp_gpio_mode(64, 71, GPIO_OUTPUT_OK);
+}
+
+static void dove_mpp_cfg_au1(int sel)
+{
+	u32 mpp_ctrl4		= readl(DOVE_MPP_CTRL4_VIRT_BASE);
+	u32 ssp_ctrl1 = readl(DOVE_SSP_CTRL_STATUS_1);
+	u32 mpp_gen_ctrl = readl(DOVE_MPP_GENERAL_VIRT_BASE);
+	u32 global_cfg_2 = readl(DOVE_GLOBAL_CONFIG_2);
+
+	mpp_ctrl4 &= ~(DOVE_AU1_GPIO_SEL);
+	ssp_ctrl1 &= ~(DOVE_SSP_ON_AU1);
+	mpp_gen_ctrl &= ~(DOVE_AU1_SPDIFO_GPIO_EN);
+	global_cfg_2 &= ~(DOVE_TWSI_OPTION3_GPIO);
+
+	if (!sel || sel == 0x2)
+		dove_mpp_gpio_mode(52, 57, 0);
+	else
+		dove_mpp_gpio_mode(52, 57, GPIO_OUTPUT_OK | GPIO_INPUT_OK);
+
+	if (sel & 0x1) {
+		global_cfg_2 |= DOVE_TWSI_OPTION3_GPIO;
+		dove_mpp_gpio_mode(56, 57, 0);
+	}
+	if (sel & 0x2) {
+		mpp_gen_ctrl |= DOVE_AU1_SPDIFO_GPIO_EN;
+		dove_mpp_gpio_mode(57, 57, GPIO_OUTPUT_OK | GPIO_INPUT_OK);
+	}
+	if (sel & 0x4) {
+		ssp_ctrl1 |= DOVE_SSP_ON_AU1;
+		dove_mpp_gpio_mode(52, 55, 0);
+	}
+	if (sel & 0x8)
+		mpp_ctrl4 |= DOVE_AU1_GPIO_SEL;
+
+	writel(mpp_ctrl4, DOVE_MPP_CTRL4_VIRT_BASE);
+	writel(ssp_ctrl1, DOVE_SSP_CTRL_STATUS_1);
+	writel(mpp_gen_ctrl, DOVE_MPP_GENERAL_VIRT_BASE);
+	writel(global_cfg_2, DOVE_GLOBAL_CONFIG_2);
+}
+
+static void dove_mpp_conf_grp(int num, int sel, u32 *mpp_ctrl)
+{
+	int start = dove_mpp_grp[num].start;
+	int end = dove_mpp_grp[num].end;
+	int gpio_mode = sel ? GPIO_OUTPUT_OK | GPIO_INPUT_OK : 0;
+
+	*mpp_ctrl &= ~(0x1 << num);
+	*mpp_ctrl |= sel << num;
+
+	dove_mpp_gpio_mode(start, end, gpio_mode);
+}
+
+void __init dove_mpp_conf(unsigned int *mpp_list)
+{
+	u32 mpp_ctrl[MPP_NR_REGS];
+	u32 pmu_mpp_ctrl = 0;
+	u32 pmu_sig_ctrl[PMU_SIG_REGS];
+	int i;
+
+	/* Initialize gpiolib. */
+	orion_gpio_init();
+
+	for (i = 0; i < MPP_NR_REGS; i++)
+		mpp_ctrl[i] = readl(MPP_CTRL(i));
+
+	for (i = 0; i < PMU_SIG_REGS; i++)
+		pmu_sig_ctrl[i] = readl(PMU_SIG_CTRL(i));
+
+	pmu_mpp_ctrl = readl(DOVE_PMU_MPP_GENERAL_CTRL);
+
+	dove_mpp_dump_regs();
+
+	for ( ; *mpp_list != MPP_END; mpp_list++) {
+		unsigned int num = MPP_NUM(*mpp_list);
+		unsigned int sel = MPP_SEL(*mpp_list);
+		int shift, gpio_mode;
+
+		if (num > MPP_MAX) {
+			pr_err("dove: invalid MPP number (%u)\n", num);
+			continue;
+		}
+
+		if (*mpp_list & MPP_NFC_MASK) {
+			dove_mpp_cfg_nfc(sel);
+			continue;
+		}
+
+		if (*mpp_list & MPP_AU1_MASK) {
+			dove_mpp_cfg_au1(sel);
+			continue;
+		}
+
+		if (*mpp_list & MPP_GRP_MASK) {
+			dove_mpp_conf_grp(num, sel, &mpp_ctrl[3]);
+			continue;
+		}
+
+		shift = (num & 7) << 2;
+		if (*mpp_list & MPP_PMU_MASK) {
+			pmu_mpp_ctrl |= (0x1 << num);
+			pmu_sig_ctrl[num / 8] &= ~(0xf << shift);
+			pmu_sig_ctrl[num / 8] |= 0xf << shift;
+			gpio_mode = 0;
+		} else {
+			mpp_ctrl[num / 8] &= ~(0xf << shift);
+			mpp_ctrl[num / 8] |= sel << shift;
+			gpio_mode = GPIO_OUTPUT_OK | GPIO_INPUT_OK;
+		}
+
+		orion_gpio_set_valid(num, gpio_mode);
+	}
+
+	for (i = 0; i < MPP_NR_REGS; i++)
+		writel(mpp_ctrl[i], MPP_CTRL(i));
+
+	for (i = 0; i < PMU_SIG_REGS; i++)
+		writel(pmu_sig_ctrl[i], PMU_SIG_CTRL(i));
+
+	writel(pmu_mpp_ctrl, DOVE_PMU_MPP_GENERAL_CTRL);
+
+	dove_mpp_dump_regs();
+}
