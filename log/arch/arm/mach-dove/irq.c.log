commit ce78179ea6e042e2d3af0a1c71c105431ead483a
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jul 31 21:56:54 2019 +0200

    ARM: dove: clean up mach/*.h headers
    
    This is a simple move of all header files that are no longer
    included by anything else from the include/mach directory
    to the platform directory itself as preparation for
    multiplatform support.
    
    The mach/uncompress.h headers are left in place for now,
    and are mildly modified to be independent of the other
    headers. They will be removed entirely when ARCH_MULTIPLATFORM
    gets enabled and they become obsolete.
    
    Rather than updating the path names inside of the comments
    of each header, I delete those comments to avoid having to
    update them again, should they get moved or copied another
    time.
    
    Link: https://lore.kernel.org/r/20190731195713.3150463-13-arnd@arndb.de
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c
index d6627c1f7f30..31ccbcee2627 100644
--- a/arch/arm/mach-dove/irq.c
+++ b/arch/arm/mach-dove/irq.c
@@ -11,9 +11,12 @@
 #include <linux/irq.h>
 #include <linux/io.h>
 #include <asm/exception.h>
+
 #include <plat/irq.h>
-#include <mach/bridge-regs.h>
 #include <plat/orion-gpio.h>
+
+#include "pm.h"
+#include "bridge-regs.h"
 #include "common.h"
 
 static int __initdata gpio0_irqs[4] = {

commit c5d431e8c511788556651b91debd7d77d4508f4b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Dec 8 10:58:09 2015 +0000

    ARM: dove: convert legacy dove to PMU support
    
    Since Dove has non-DT support for various facilities in the PMU, convert
    the legacy support to use the new PMU driver.
    
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c
index ad785d34c1e7..d6627c1f7f30 100644
--- a/arch/arm/mach-dove/irq.c
+++ b/arch/arm/mach-dove/irq.c
@@ -7,88 +7,15 @@
  * License version 2.  This program is licensed "as is" without any
  * warranty of any kind, whether express or implied.
  */
-
-#include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/irq.h>
-#include <linux/gpio.h>
 #include <linux/io.h>
 #include <asm/exception.h>
-#include <asm/mach/arch.h>
 #include <plat/irq.h>
-#include <asm/mach/irq.h>
-#include <mach/pm.h>
 #include <mach/bridge-regs.h>
 #include <plat/orion-gpio.h>
 #include "common.h"
 
-static void pmu_irq_mask(struct irq_data *d)
-{
-	int pin = irq_to_pmu(d->irq);
-	u32 u;
-
-	u = readl(PMU_INTERRUPT_MASK);
-	u &= ~(1 << (pin & 31));
-	writel(u, PMU_INTERRUPT_MASK);
-}
-
-static void pmu_irq_unmask(struct irq_data *d)
-{
-	int pin = irq_to_pmu(d->irq);
-	u32 u;
-
-	u = readl(PMU_INTERRUPT_MASK);
-	u |= 1 << (pin & 31);
-	writel(u, PMU_INTERRUPT_MASK);
-}
-
-static void pmu_irq_ack(struct irq_data *d)
-{
-	int pin = irq_to_pmu(d->irq);
-	u32 u;
-
-	/*
-	 * The PMU mask register is not RW0C: it is RW.  This means that
-	 * the bits take whatever value is written to them; if you write
-	 * a '1', you will set the interrupt.
-	 *
-	 * Unfortunately this means there is NO race free way to clear
-	 * these interrupts.
-	 *
-	 * So, let's structure the code so that the window is as small as
-	 * possible.
-	 */
-	u = ~(1 << (pin & 31));
-	u &= readl_relaxed(PMU_INTERRUPT_CAUSE);
-	writel_relaxed(u, PMU_INTERRUPT_CAUSE);
-}
-
-static struct irq_chip pmu_irq_chip = {
-	.name		= "pmu_irq",
-	.irq_mask	= pmu_irq_mask,
-	.irq_unmask	= pmu_irq_unmask,
-	.irq_ack	= pmu_irq_ack,
-};
-
-static void pmu_irq_handler(struct irq_desc *desc)
-{
-	unsigned long cause = readl(PMU_INTERRUPT_CAUSE);
-	unsigned int irq;
-
-	cause &= readl(PMU_INTERRUPT_MASK);
-	if (cause == 0) {
-		do_bad_IRQ(desc);
-		return;
-	}
-
-	for (irq = 0; irq < NR_PMU_IRQS; irq++) {
-		if (!(cause & (1 << irq)))
-			continue;
-		irq = pmu_to_irq(irq);
-		generic_handle_irq(irq);
-	}
-}
-
 static int __initdata gpio0_irqs[4] = {
 	IRQ_DOVE_GPIO_0_7,
 	IRQ_DOVE_GPIO_8_15,
@@ -135,8 +62,6 @@ __exception_irq_entry dove_legacy_handle_irq(struct pt_regs *regs)
 
 void __init dove_init_irq(void)
 {
-	int i;
-
 	orion_irq_init(1, IRQ_VIRT_BASE + IRQ_MASK_LOW_OFF);
 	orion_irq_init(33, IRQ_VIRT_BASE + IRQ_MASK_HIGH_OFF);
 
@@ -153,17 +78,4 @@ void __init dove_init_irq(void)
 
 	orion_gpio_init(NULL, 64, 8, DOVE_GPIO2_VIRT_BASE, 0,
 			IRQ_DOVE_GPIO_START + 64, gpio2_irqs);
-
-	/*
-	 * Mask and clear PMU interrupts
-	 */
-	writel(0, PMU_INTERRUPT_MASK);
-	writel(0, PMU_INTERRUPT_CAUSE);
-
-	for (i = IRQ_DOVE_PMU_START; i < DOVE_NR_IRQS; i++) {
-		irq_set_chip_and_handler(i, &pmu_irq_chip, handle_level_irq);
-		irq_set_status_flags(i, IRQ_LEVEL);
-		irq_clear_status_flags(i, IRQ_NOREQUEST);
-	}
-	irq_set_chained_handler(IRQ_DOVE_PMU, pmu_irq_handler);
 }

commit 5cdbe5d23a8a0d7274d628bb9d5ff018d25075ca
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Dec 2 22:27:05 2015 +0100

    ARM: orion: use SPARSE_IRQ everywhere
    
    As a preparation for multiplatform support, this moves all the
    code using plat-orion over to use sparse irq support, which is
    enabled implicitly for multiplatform.
    
    In particular, the hardcoded NR_IRQS macro gets replaced with
    a machine specific one that is set in the machine descriptor
    in order to set up a static mapping for all legacy interrupts.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c
index b1c7cae1486b..ad785d34c1e7 100644
--- a/arch/arm/mach-dove/irq.c
+++ b/arch/arm/mach-dove/irq.c
@@ -160,7 +160,7 @@ void __init dove_init_irq(void)
 	writel(0, PMU_INTERRUPT_MASK);
 	writel(0, PMU_INTERRUPT_CAUSE);
 
-	for (i = IRQ_DOVE_PMU_START; i < NR_IRQS; i++) {
+	for (i = IRQ_DOVE_PMU_START; i < DOVE_NR_IRQS; i++) {
 		irq_set_chip_and_handler(i, &pmu_irq_chip, handle_level_irq);
 		irq_set_status_flags(i, IRQ_LEVEL);
 		irq_clear_status_flags(i, IRQ_NOREQUEST);

commit b8cd337c8e0330f4a29b3d1f69b7c73b324b1f8d
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Dec 2 22:27:04 2015 +0100

    ARM: orion: always use MULTI_IRQ_HANDLER
    
    As a preparation for multiplatform support, this enables
    the MULTI_IRQ_HANDLER code unconditionally on dove and
    orion5x, and introduces the respective code on mv78xx0,
    which did not have it so far. The classic entry-macro.S
    files are removed as they are now obsolete.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c
index bfb3703357c5..b1c7cae1486b 100644
--- a/arch/arm/mach-dove/irq.c
+++ b/arch/arm/mach-dove/irq.c
@@ -13,6 +13,7 @@
 #include <linux/irq.h>
 #include <linux/gpio.h>
 #include <linux/io.h>
+#include <asm/exception.h>
 #include <asm/mach/arch.h>
 #include <plat/irq.h>
 #include <asm/mach/irq.h>
@@ -109,14 +110,6 @@ static int __initdata gpio2_irqs[4] = {
 	0,
 };
 
-#ifdef CONFIG_MULTI_IRQ_HANDLER
-/*
- * Compiling with both non-DT and DT support enabled, will
- * break asm irq handler used by non-DT boards. Therefore,
- * we provide a C-style irq handler even for non-DT boards,
- * if MULTI_IRQ_HANDLER is set.
- */
-
 static void __iomem *dove_irq_base = IRQ_VIRT_BASE;
 
 static asmlinkage void
@@ -139,7 +132,6 @@ __exception_irq_entry dove_legacy_handle_irq(struct pt_regs *regs)
 		return;
 	}
 }
-#endif
 
 void __init dove_init_irq(void)
 {
@@ -148,9 +140,7 @@ void __init dove_init_irq(void)
 	orion_irq_init(1, IRQ_VIRT_BASE + IRQ_MASK_LOW_OFF);
 	orion_irq_init(33, IRQ_VIRT_BASE + IRQ_MASK_HIGH_OFF);
 
-#ifdef CONFIG_MULTI_IRQ_HANDLER
 	set_handle_irq(dove_legacy_handle_irq);
-#endif
 
 	/*
 	 * Initialize gpiolib for GPIOs 0-71.

commit bd0b9ac405e1794d72533c3d487aa65b6b955a0c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 14 10:42:37 2015 +0200

    genirq: Remove irq argument from irq flow handlers
    
    Most interrupt flow handlers do not use the irq argument. Those few
    which use it can retrieve the irq number from the irq descriptor.
    
    Remove the argument.
    
    Search and replace was done with coccinelle and some extra helper
    scripts around it. Thanks to Julia for her help!
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>

diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c
index 305d7c6242bb..bfb3703357c5 100644
--- a/arch/arm/mach-dove/irq.c
+++ b/arch/arm/mach-dove/irq.c
@@ -69,14 +69,14 @@ static struct irq_chip pmu_irq_chip = {
 	.irq_ack	= pmu_irq_ack,
 };
 
-static void pmu_irq_handler(unsigned int __irq, struct irq_desc *desc)
+static void pmu_irq_handler(struct irq_desc *desc)
 {
-	unsigned int irq = irq_desc_get_irq(desc);
 	unsigned long cause = readl(PMU_INTERRUPT_CAUSE);
+	unsigned int irq;
 
 	cause &= readl(PMU_INTERRUPT_MASK);
 	if (cause == 0) {
-		do_bad_IRQ(irq, desc);
+		do_bad_IRQ(desc);
 		return;
 	}
 

commit 39aa437e18cac7acae55481ed73feea0de497399
Merge: e8d36d5dbb6a f4acd122a738
Author: Olof Johansson <olof@lixom.net>
Date:   Wed Aug 5 17:24:11 2015 +0200

    Merge branch 'queue/irq/arm' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip into next/cleanup
    
    Merge "ARM: Interrupt cleanups and API change preparation" from Thomas
    Gleixner:
    
    The following patch series contains the following changes:
    
        - Consolidation of chained interrupt handler setup/removal
    
        - Switch to functions which avoid a redundant interrupt
          descriptor lookup
    
        - Preparation of interrupt flow handlers for the 'irq' argument
          removal
    
    * 'queue/irq/arm' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      ARM/orion/gpio: Prepare gpio_irq_handler for irq argument removal
      ARM/pxa: Prepare balloon3_irq_handler for irq argument removal
      ARM/pxa: Prepare *_irq_handler for irq argument removal
      ARM/dove: Prepare pmu_irq_handler for irq argument removal
      ARM/sa1111: Prepare sa1111_irq_handler for irq argument removal
      ARM/locomo: Prepare locomo_handler for irq argument removal
      ARM, irq: Use irq_desc_get_xxx() to avoid redundant lookup of irq_desc
      ARM/LPC32xx: Use irq_set_handler_locked()
      ARM/irq: Use access helper irq_data_get_affinity_mask()
      ARM/locomo: Consolidate chained IRQ handler install/remove
      ARM/orion: Consolidate chained IRQ handler install/remove
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit e8d36d5dbb6a6ec4f5222f8775d664ec29d5527d
Author: Rob Herring <robh@kernel.org>
Date:   Mon Jul 27 15:55:13 2015 -0500

    ARM: kill off set_irq_flags usage
    
    set_irq_flags is ARM specific with custom flags which have genirq
    equivalents. Convert drivers to use the genirq interfaces directly, so we
    can kill off set_irq_flags. The translation of flags is as follows:
    
    IRQF_VALID -> !IRQ_NOREQUEST
    IRQF_PROBE -> !IRQ_NOPROBE
    IRQF_NOAUTOEN -> IRQ_NOAUTOEN
    
    For IRQs managed by an irqdomain, the irqdomain core code handles clearing
    and setting IRQ_NOREQUEST already, so there is no need to do this in
    .map() functions and we can simply remove the set_irq_flags calls. Some
    users also modify IRQ_NOPROBE and this has been maintained although it
    is not clear that is really needed. There appears to be a great deal of
    blind copy and paste of this code.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Sekhar Nori <nsekhar@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Gregory Clement <gregory.clement@free-electrons.com>
    Acked-by: Hans Ulli Kroll <ulli.kroll@googlemail.com>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Acked-by: Krzysztof Halasa <khalasa@piap.pl>
    Cc: Greg Ungerer <gerg@uclinux.org>
    Cc: Roland Stigge <stigge@antcom.de>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Daniel Mack <daniel@zonque.org>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: Robert Jarzmik <robert.jarzmik@free.fr>
    Cc: Simtec Linux Team <linux@simtec.co.uk>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Acked-by: Wan ZongShun <mcuos.com@gmail.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-omap@vger.kernel.org
    Cc: linux-samsung-soc@vger.kernel.org
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c
index df0223f76fa9..ea7892e72242 100644
--- a/arch/arm/mach-dove/irq.c
+++ b/arch/arm/mach-dove/irq.c
@@ -172,7 +172,7 @@ void __init dove_init_irq(void)
 	for (i = IRQ_DOVE_PMU_START; i < NR_IRQS; i++) {
 		irq_set_chip_and_handler(i, &pmu_irq_chip, handle_level_irq);
 		irq_set_status_flags(i, IRQ_LEVEL);
-		set_irq_flags(i, IRQF_VALID);
+		irq_clear_status_flags(i, IRQ_NOREQUEST);
 	}
 	irq_set_chained_handler(IRQ_DOVE_PMU, pmu_irq_handler);
 }

commit 1c2d4afa77959f3ac7013041e35f5cbe241e9415
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 13 10:16:33 2015 +0200

    ARM/dove: Prepare pmu_irq_handler for irq argument removal
    
    The irq argument of most interrupt flow handlers is unused or merily
    used instead of a local variable. The handlers which need the irq
    argument can retrieve the irq number from the irq descriptor.
    
    Search and update was done with coccinelle and the invaluable help of
    Julia Lawall.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Russell King <linux+kernel@arm.linux.org.uk>
    Cc: linux-arm-kernel@lists.infradead.org

diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c
index df0223f76fa9..a50ea931b038 100644
--- a/arch/arm/mach-dove/irq.c
+++ b/arch/arm/mach-dove/irq.c
@@ -69,8 +69,9 @@ static struct irq_chip pmu_irq_chip = {
 	.irq_ack	= pmu_irq_ack,
 };
 
-static void pmu_irq_handler(unsigned int irq, struct irq_desc *desc)
+static void pmu_irq_handler(unsigned int __irq, struct irq_desc *desc)
 {
+	unsigned int irq = irq_desc_get_irq(desc);
 	unsigned long cause = readl(PMU_INTERRUPT_CAUSE);
 
 	cause &= readl(PMU_INTERRUPT_MASK);

commit 5d6bed2a9c8bc161bff4cc7cede00f2e0e27a7e7
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Jun 22 18:39:43 2015 +0100

    ARM: dove: fix legacy dove IRQ numbers
    
    v3.18 changed handle_IRQ() to call __handle_domain_irq(), which now
    rejects attempts to deliver IRQ0.  Since IRQ 0 is used as the timer
    interrupt (just like the PIT on x86), this causes boot to fail as the
    bogomips calibration never completes.
    
    Fix this by shuffling all interrupts up by one.
    
    Fixes: a71b092a9c68 ("ARM: Convert handle_IRQ to use __handle_domain_irq")
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c
index 4a5a7aedcb76..df0223f76fa9 100644
--- a/arch/arm/mach-dove/irq.c
+++ b/arch/arm/mach-dove/irq.c
@@ -126,14 +126,14 @@ __exception_irq_entry dove_legacy_handle_irq(struct pt_regs *regs)
 	stat = readl_relaxed(dove_irq_base + IRQ_CAUSE_LOW_OFF);
 	stat &= readl_relaxed(dove_irq_base + IRQ_MASK_LOW_OFF);
 	if (stat) {
-		unsigned int hwirq = __fls(stat);
+		unsigned int hwirq = 1 + __fls(stat);
 		handle_IRQ(hwirq, regs);
 		return;
 	}
 	stat = readl_relaxed(dove_irq_base + IRQ_CAUSE_HIGH_OFF);
 	stat &= readl_relaxed(dove_irq_base + IRQ_MASK_HIGH_OFF);
 	if (stat) {
-		unsigned int hwirq = 32 + __fls(stat);
+		unsigned int hwirq = 33 + __fls(stat);
 		handle_IRQ(hwirq, regs);
 		return;
 	}
@@ -144,8 +144,8 @@ void __init dove_init_irq(void)
 {
 	int i;
 
-	orion_irq_init(0, IRQ_VIRT_BASE + IRQ_MASK_LOW_OFF);
-	orion_irq_init(32, IRQ_VIRT_BASE + IRQ_MASK_HIGH_OFF);
+	orion_irq_init(1, IRQ_VIRT_BASE + IRQ_MASK_LOW_OFF);
+	orion_irq_init(33, IRQ_VIRT_BASE + IRQ_MASK_HIGH_OFF);
 
 #ifdef CONFIG_MULTI_IRQ_HANDLER
 	set_handle_irq(dove_legacy_handle_irq);

commit deac3d874ea1e1ef50604cec33ddfb01edb0c976
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Tue Apr 22 23:26:26 2014 +0200

    ARM: orion: switch to a per-platform handle_irq() function
    
    Moving to the Device Tree implies having CONFIG_MULTI_IRQ_HANDLER
    enabled, even for non-DT platforms (if we want both DT and non-DT
    platforms to be supported in a single kernel).
    
    However, the common CONFIG_MULTI_IRQ_HANDLER handler for non-DT
    platforms in plat-orion/irq.c doesn't match the needs of
    Orion5x. Also, it doesn't make much sense for orion_irq_init() to
    register the multi-IRQ handler: orion_irq_init() is called once for
    each IRQ cause/mask tuple, while the multi-IRQ handler only needs to
    be registered once.
    
    To solve this problem, we move the multi-IRQ handle in per-platform
    code: mach-kirkwood/irq.c and mach-dove/irq.c. The Orion5x variant
    will be introduced in a followup commit. Of course, this code will
    ultimately be completely removed once all boards are converted to the
    Device Tree.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Link: https://lkml.kernel.org/r/1398202002-28530-23-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c
index bc4344aa1009..4a5a7aedcb76 100644
--- a/arch/arm/mach-dove/irq.c
+++ b/arch/arm/mach-dove/irq.c
@@ -108,6 +108,38 @@ static int __initdata gpio2_irqs[4] = {
 	0,
 };
 
+#ifdef CONFIG_MULTI_IRQ_HANDLER
+/*
+ * Compiling with both non-DT and DT support enabled, will
+ * break asm irq handler used by non-DT boards. Therefore,
+ * we provide a C-style irq handler even for non-DT boards,
+ * if MULTI_IRQ_HANDLER is set.
+ */
+
+static void __iomem *dove_irq_base = IRQ_VIRT_BASE;
+
+static asmlinkage void
+__exception_irq_entry dove_legacy_handle_irq(struct pt_regs *regs)
+{
+	u32 stat;
+
+	stat = readl_relaxed(dove_irq_base + IRQ_CAUSE_LOW_OFF);
+	stat &= readl_relaxed(dove_irq_base + IRQ_MASK_LOW_OFF);
+	if (stat) {
+		unsigned int hwirq = __fls(stat);
+		handle_IRQ(hwirq, regs);
+		return;
+	}
+	stat = readl_relaxed(dove_irq_base + IRQ_CAUSE_HIGH_OFF);
+	stat &= readl_relaxed(dove_irq_base + IRQ_MASK_HIGH_OFF);
+	if (stat) {
+		unsigned int hwirq = 32 + __fls(stat);
+		handle_IRQ(hwirq, regs);
+		return;
+	}
+}
+#endif
+
 void __init dove_init_irq(void)
 {
 	int i;
@@ -115,6 +147,10 @@ void __init dove_init_irq(void)
 	orion_irq_init(0, IRQ_VIRT_BASE + IRQ_MASK_LOW_OFF);
 	orion_irq_init(32, IRQ_VIRT_BASE + IRQ_MASK_HIGH_OFF);
 
+#ifdef CONFIG_MULTI_IRQ_HANDLER
+	set_handle_irq(dove_legacy_handle_irq);
+#endif
+
 	/*
 	 * Initialize gpiolib for GPIOs 0-71.
 	 */

commit 5d3df935426271016b895aecaa247101b4bfa35e
Author: Russell King - ARM Linux <linux@arm.linux.org.uk>
Date:   Sun Nov 18 16:29:44 2012 +0000

    Dove: Attempt to fix PMU/RTC interrupts
    
    Fix the acknowledgement of PMU interrupts on Dove: some Dove hardware
    has not been sensibly designed so that interrupts can be handled in a
    race free manner.  The PMU is one such instance.
    
    The pending (aka 'cause') register is a bunch of RW bits, meaning that
    these bits can be both cleared and set by software (confirmed on the
    Armada-510 on the cubox.)
    
    Hardware sets the appropriate bit when an interrupt is asserted, and
    software is required to clear the bits which are to be processed.  If
    we write ~(1 << bit), then we end up asserting every other interrupt
    except the one we're processing.  So, we need to do a read-modify-write
    cycle to clear the asserted bit.
    
    However, any interrupts which occur in the middle of this cycle will
    also be written back as zero, which will also clear the new interrupts.
    
    The upshot of this is: there is _no_ way to safely clear down interrupts
    in this register (and other similarly behaving interrupt pending
    registers on this device.)  The patch below at least stops us creating
    new interrupts.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: stable@vger.kernel.org
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c
index 087711524e8a..bc4344aa1009 100644
--- a/arch/arm/mach-dove/irq.c
+++ b/arch/arm/mach-dove/irq.c
@@ -46,8 +46,20 @@ static void pmu_irq_ack(struct irq_data *d)
 	int pin = irq_to_pmu(d->irq);
 	u32 u;
 
+	/*
+	 * The PMU mask register is not RW0C: it is RW.  This means that
+	 * the bits take whatever value is written to them; if you write
+	 * a '1', you will set the interrupt.
+	 *
+	 * Unfortunately this means there is NO race free way to clear
+	 * these interrupts.
+	 *
+	 * So, let's structure the code so that the window is as small as
+	 * possible.
+	 */
 	u = ~(1 << (pin & 31));
-	writel(u, PMU_INTERRUPT_CAUSE);
+	u &= readl_relaxed(PMU_INTERRUPT_CAUSE);
+	writel_relaxed(u, PMU_INTERRUPT_CAUSE);
 }
 
 static struct irq_chip pmu_irq_chip = {

commit 0d601f613b8557cf6489f06251ae5dc383b811d0
Merge: d7ffa2234c18 5b40baee4a39
Author: Olof Johansson <olof@lixom.net>
Date:   Sat Sep 22 14:09:21 2012 -0700

    Merge branch 'kirkwood/addr_decode' of git://git.infradead.org/users/jcooper/linux into late/kirkwood
    
    * 'kirkwood/addr_decode' of git://git.infradead.org/users/jcooper/linux:
      arm: mvebu: add address decoding controller to the DT
      arm: mvebu: add basic address decoding support to Armada 370/XP
      arm: plat-orion: make bridge_virt_base non-const to support DT use case
      arm: plat-orion: introduce PLAT_ORION_LEGACY hidden config option
      arm: plat-orion: use void __iomem pointers for addr-map functions
      arm: plat-orion: use void __iomem pointers for time functions
      arm: plat-orion: use void __iomem pointers for MPP functions
      arm: plat-orion: use void __iomem pointers for UART registration functions
      arm: mach-mvebu: use IOMEM() for base address definitions
      arm: mach-orion5x: use IOMEM() for base address definitions
      arm: mach-mv78xx0: use IOMEM() for base address definitions
      arm: mach-kirkwood: use IOMEM() for base address definitions
      arm: mach-dove: use IOMEM() for base address definitions
      arm: mach-orion5x: use plus instead of or for address definitions
      arm: mach-mv78xx0: use plus instead of or for address definitions
      arm: mach-kirkwood: use plus instead of or for address definitions
      arm: mach-dove: use plus instead of or for address definitions
    
    This branch had quite a few conflicts, in particular with the PCI static
    map rework from Rob Herring, and a few other context conflicts due to
    changes in Kconfig, etc.
    
    I fixed up conflicts in:
            arch/arm/Kconfig
            arch/arm/mach-dove/common.c
            arch/arm/mach-dove/include/mach/dove.h
            arch/arm/mach-kirkwood/common.c
            arch/arm/mach-kirkwood/include/mach/kirkwood.h
            arch/arm/mach-mv78xx0/common.c
            arch/arm/mach-mv78xx0/include/mach/mv78xx0.h
            arch/arm/mach-orion5x/common.c
            arch/arm/mach-orion5x/include/mach/orion5x.h
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit c3c5a2815d0b7ebde157556685a0ef8ffa34b98c
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Tue Sep 11 14:27:18 2012 +0200

    arm: mach-dove: use IOMEM() for base address definitions
    
    We now define all virtual base address constants using IOMEM() so that
    those are naturally typed as void __iomem pointers, and we do the
    necessary adjustements in the mach-dove code.
    
    Note that we introduce a few temporary additional "unsigned long"
    casts when calling into plat-orion functions. Those are removed by
    followup patches converting plat-orion functions to void __iomem
    pointers as well.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c
index 9bc97a5baaa8..4ce306aff495 100644
--- a/arch/arm/mach-dove/irq.c
+++ b/arch/arm/mach-dove/irq.c
@@ -99,19 +99,19 @@ void __init dove_init_irq(void)
 {
 	int i;
 
-	orion_irq_init(0, (void __iomem *)(IRQ_VIRT_BASE + IRQ_MASK_LOW_OFF));
-	orion_irq_init(32, (void __iomem *)(IRQ_VIRT_BASE + IRQ_MASK_HIGH_OFF));
+	orion_irq_init(0, IRQ_VIRT_BASE + IRQ_MASK_LOW_OFF);
+	orion_irq_init(32, IRQ_VIRT_BASE + IRQ_MASK_HIGH_OFF);
 
 	/*
 	 * Initialize gpiolib for GPIOs 0-71.
 	 */
-	orion_gpio_init(NULL, 0, 32, (void __iomem *)DOVE_GPIO_LO_VIRT_BASE, 0,
+	orion_gpio_init(NULL, 0, 32, DOVE_GPIO_LO_VIRT_BASE, 0,
 			IRQ_DOVE_GPIO_START, gpio0_irqs);
 
-	orion_gpio_init(NULL, 32, 32, (void __iomem *)DOVE_GPIO_HI_VIRT_BASE, 0,
+	orion_gpio_init(NULL, 32, 32, DOVE_GPIO_HI_VIRT_BASE, 0,
 			IRQ_DOVE_GPIO_START + 32, gpio1_irqs);
 
-	orion_gpio_init(NULL, 64, 8, (void __iomem *)DOVE_GPIO2_VIRT_BASE, 0,
+	orion_gpio_init(NULL, 64, 8, DOVE_GPIO2_VIRT_BASE, 0,
 			IRQ_DOVE_GPIO_START + 64, gpio2_irqs);
 
 	/*

commit ce91574c202b8581ad15bfb1427af824f462c3d2
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Wed Aug 29 10:16:55 2012 -0500

    ARM: orion: move custom gpio functions to orion-gpio.h
    
    Move custom orion platforms gpio code to orion-gpio to remove the
    dependency on mach/gpio.h.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>

diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c
index 9bc97a5baaa8..186357f3b4db 100644
--- a/arch/arm/mach-dove/irq.c
+++ b/arch/arm/mach-dove/irq.c
@@ -18,6 +18,7 @@
 #include <asm/mach/irq.h>
 #include <mach/pm.h>
 #include <mach/bridge-regs.h>
+#include <plat/orion-gpio.h>
 #include "common.h"
 
 static void pmu_irq_mask(struct irq_data *d)

commit 278b45b06bf721b7cf5de67a0126786c60c720e6
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jun 27 13:40:04 2012 +0200

    ARM: Orion: DT support for IRQ and GPIO Controllers
    
    Both IRQ and GPIO controllers can now be represented in DT.  The IRQ
    controllers are setup first, and then the GPIO controllers. Interrupts
    for GPIO lines are placed directly after the main interrupts in the
    interrupt space.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@googlemail.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Tested-by: Josh Coombs <josh.coombs@gmail.com>
    Tested-by: Simon Baatz <gmbnomis@gmail.com>

diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c
index f07fd16e0c9b..9bc97a5baaa8 100644
--- a/arch/arm/mach-dove/irq.c
+++ b/arch/arm/mach-dove/irq.c
@@ -20,22 +20,6 @@
 #include <mach/bridge-regs.h>
 #include "common.h"
 
-static void gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
-{
-	int irqoff;
-	BUG_ON(irq < IRQ_DOVE_GPIO_0_7 || irq > IRQ_DOVE_HIGH_GPIO);
-
-	irqoff = irq <= IRQ_DOVE_GPIO_16_23 ? irq - IRQ_DOVE_GPIO_0_7 :
-		3 + irq - IRQ_DOVE_GPIO_24_31;
-
-	orion_gpio_irq_handler(irqoff << 3);
-	if (irq == IRQ_DOVE_HIGH_GPIO) {
-		orion_gpio_irq_handler(40);
-		orion_gpio_irq_handler(48);
-		orion_gpio_irq_handler(56);
-	}
-}
-
 static void pmu_irq_mask(struct irq_data *d)
 {
 	int pin = irq_to_pmu(d->irq);
@@ -90,6 +74,27 @@ static void pmu_irq_handler(unsigned int irq, struct irq_desc *desc)
 	}
 }
 
+static int __initdata gpio0_irqs[4] = {
+	IRQ_DOVE_GPIO_0_7,
+	IRQ_DOVE_GPIO_8_15,
+	IRQ_DOVE_GPIO_16_23,
+	IRQ_DOVE_GPIO_24_31,
+};
+
+static int __initdata gpio1_irqs[4] = {
+	IRQ_DOVE_HIGH_GPIO,
+	0,
+	0,
+	0,
+};
+
+static int __initdata gpio2_irqs[4] = {
+	0,
+	0,
+	0,
+	0,
+};
+
 void __init dove_init_irq(void)
 {
 	int i;
@@ -100,19 +105,14 @@ void __init dove_init_irq(void)
 	/*
 	 * Initialize gpiolib for GPIOs 0-71.
 	 */
-	orion_gpio_init(0, 32, DOVE_GPIO_LO_VIRT_BASE, 0,
-			IRQ_DOVE_GPIO_START);
-	irq_set_chained_handler(IRQ_DOVE_GPIO_0_7, gpio_irq_handler);
-	irq_set_chained_handler(IRQ_DOVE_GPIO_8_15, gpio_irq_handler);
-	irq_set_chained_handler(IRQ_DOVE_GPIO_16_23, gpio_irq_handler);
-	irq_set_chained_handler(IRQ_DOVE_GPIO_24_31, gpio_irq_handler);
-
-	orion_gpio_init(32, 32, DOVE_GPIO_HI_VIRT_BASE, 0,
-			IRQ_DOVE_GPIO_START + 32);
-	irq_set_chained_handler(IRQ_DOVE_HIGH_GPIO, gpio_irq_handler);
-
-	orion_gpio_init(64, 8, DOVE_GPIO2_VIRT_BASE, 0,
-			IRQ_DOVE_GPIO_START + 64);
+	orion_gpio_init(NULL, 0, 32, (void __iomem *)DOVE_GPIO_LO_VIRT_BASE, 0,
+			IRQ_DOVE_GPIO_START, gpio0_irqs);
+
+	orion_gpio_init(NULL, 32, 32, (void __iomem *)DOVE_GPIO_HI_VIRT_BASE, 0,
+			IRQ_DOVE_GPIO_START + 32, gpio1_irqs);
+
+	orion_gpio_init(NULL, 64, 8, (void __iomem *)DOVE_GPIO2_VIRT_BASE, 0,
+			IRQ_DOVE_GPIO_START + 64, gpio2_irqs);
 
 	/*
 	 * Mask and clear PMU interrupts

commit f38c02f3b338651e145aac2889ba976baf6b28b3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 13:35:09 2011 +0100

    arm: Fold irq_set_chip/irq_set_handler
    
    Use irq_set_chip_and_handler() instead. Converted with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c
index f038a19f4c6e..f07fd16e0c9b 100644
--- a/arch/arm/mach-dove/irq.c
+++ b/arch/arm/mach-dove/irq.c
@@ -121,8 +121,7 @@ void __init dove_init_irq(void)
 	writel(0, PMU_INTERRUPT_CAUSE);
 
 	for (i = IRQ_DOVE_PMU_START; i < NR_IRQS; i++) {
-		irq_set_chip(i, &pmu_irq_chip);
-		irq_set_handler(i, handle_level_irq);
+		irq_set_chip_and_handler(i, &pmu_irq_chip, handle_level_irq);
 		irq_set_status_flags(i, IRQ_LEVEL);
 		set_irq_flags(i, IRQF_VALID);
 	}

commit 6845664a6a7d443f03883db59d10749d38d98b8e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 13:25:22 2011 +0100

    arm: Cleanup the irq namespace
    
    Convert to the new function names. Automated with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c
index aac6e23763e0..f038a19f4c6e 100644
--- a/arch/arm/mach-dove/irq.c
+++ b/arch/arm/mach-dove/irq.c
@@ -102,14 +102,14 @@ void __init dove_init_irq(void)
 	 */
 	orion_gpio_init(0, 32, DOVE_GPIO_LO_VIRT_BASE, 0,
 			IRQ_DOVE_GPIO_START);
-	set_irq_chained_handler(IRQ_DOVE_GPIO_0_7, gpio_irq_handler);
-	set_irq_chained_handler(IRQ_DOVE_GPIO_8_15, gpio_irq_handler);
-	set_irq_chained_handler(IRQ_DOVE_GPIO_16_23, gpio_irq_handler);
-	set_irq_chained_handler(IRQ_DOVE_GPIO_24_31, gpio_irq_handler);
+	irq_set_chained_handler(IRQ_DOVE_GPIO_0_7, gpio_irq_handler);
+	irq_set_chained_handler(IRQ_DOVE_GPIO_8_15, gpio_irq_handler);
+	irq_set_chained_handler(IRQ_DOVE_GPIO_16_23, gpio_irq_handler);
+	irq_set_chained_handler(IRQ_DOVE_GPIO_24_31, gpio_irq_handler);
 
 	orion_gpio_init(32, 32, DOVE_GPIO_HI_VIRT_BASE, 0,
 			IRQ_DOVE_GPIO_START + 32);
-	set_irq_chained_handler(IRQ_DOVE_HIGH_GPIO, gpio_irq_handler);
+	irq_set_chained_handler(IRQ_DOVE_HIGH_GPIO, gpio_irq_handler);
 
 	orion_gpio_init(64, 8, DOVE_GPIO2_VIRT_BASE, 0,
 			IRQ_DOVE_GPIO_START + 64);
@@ -121,10 +121,10 @@ void __init dove_init_irq(void)
 	writel(0, PMU_INTERRUPT_CAUSE);
 
 	for (i = IRQ_DOVE_PMU_START; i < NR_IRQS; i++) {
-		set_irq_chip(i, &pmu_irq_chip);
-		set_irq_handler(i, handle_level_irq);
+		irq_set_chip(i, &pmu_irq_chip);
+		irq_set_handler(i, handle_level_irq);
 		irq_set_status_flags(i, IRQ_LEVEL);
 		set_irq_flags(i, IRQF_VALID);
 	}
-	set_irq_chained_handler(IRQ_DOVE_PMU, pmu_irq_handler);
+	irq_set_chained_handler(IRQ_DOVE_PMU, pmu_irq_handler);
 }

commit cf0d6b76c11b565f8d8b7d527d17b9f82eb3b3a5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 12:33:40 2011 +0100

    arm: dove: Use proper irq accessor functions
    
    Remove the obsolete desc_handle_irq() helper.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c
index 101707fa2e2c..aac6e23763e0 100644
--- a/arch/arm/mach-dove/irq.c
+++ b/arch/arm/mach-dove/irq.c
@@ -86,8 +86,7 @@ static void pmu_irq_handler(unsigned int irq, struct irq_desc *desc)
 		if (!(cause & (1 << irq)))
 			continue;
 		irq = pmu_to_irq(irq);
-		desc = irq_desc + irq;
-		desc_handle_irq(irq, desc);
+		generic_handle_irq(irq);
 	}
 }
 
@@ -124,7 +123,7 @@ void __init dove_init_irq(void)
 	for (i = IRQ_DOVE_PMU_START; i < NR_IRQS; i++) {
 		set_irq_chip(i, &pmu_irq_chip);
 		set_irq_handler(i, handle_level_irq);
-		irq_desc[i].status |= IRQ_LEVEL;
+		irq_set_status_flags(i, IRQ_LEVEL);
 		set_irq_flags(i, IRQF_VALID);
 	}
 	set_irq_chained_handler(IRQ_DOVE_PMU, pmu_irq_handler);

commit 9eac6d0a4e7e5149a7f86575b46d710ad2e05fe2
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Tue Dec 14 12:54:03 2010 +0100

    ARM: Remove dependency of plat-orion GPIO code on mach directory includes.
    
    This patch makes the various mach dirs that use the plat-orion GPIO
    code pass in GPIO-related platform info (GPIO controller base address,
    secondary base IRQ number, etc) explicitly, instead of having
    plat-orion get those values by including a mach dir include file --
    the latter mechanism is problematic if you want to support multiple
    ARM platforms in the same kernel image.
    
    Signed-off-by: Lennert Buytenhek <buytenh@secretlab.ca>
    Signed-off-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c
index 9317f0558b57..101707fa2e2c 100644
--- a/arch/arm/mach-dove/irq.c
+++ b/arch/arm/mach-dove/irq.c
@@ -99,11 +99,21 @@ void __init dove_init_irq(void)
 	orion_irq_init(32, (void __iomem *)(IRQ_VIRT_BASE + IRQ_MASK_HIGH_OFF));
 
 	/*
-	 * Mask and clear GPIO IRQ interrupts.
+	 * Initialize gpiolib for GPIOs 0-71.
 	 */
-	writel(0, GPIO_LEVEL_MASK(0));
-	writel(0, GPIO_EDGE_MASK(0));
-	writel(0, GPIO_EDGE_CAUSE(0));
+	orion_gpio_init(0, 32, DOVE_GPIO_LO_VIRT_BASE, 0,
+			IRQ_DOVE_GPIO_START);
+	set_irq_chained_handler(IRQ_DOVE_GPIO_0_7, gpio_irq_handler);
+	set_irq_chained_handler(IRQ_DOVE_GPIO_8_15, gpio_irq_handler);
+	set_irq_chained_handler(IRQ_DOVE_GPIO_16_23, gpio_irq_handler);
+	set_irq_chained_handler(IRQ_DOVE_GPIO_24_31, gpio_irq_handler);
+
+	orion_gpio_init(32, 32, DOVE_GPIO_HI_VIRT_BASE, 0,
+			IRQ_DOVE_GPIO_START + 32);
+	set_irq_chained_handler(IRQ_DOVE_HIGH_GPIO, gpio_irq_handler);
+
+	orion_gpio_init(64, 8, DOVE_GPIO2_VIRT_BASE, 0,
+			IRQ_DOVE_GPIO_START + 64);
 
 	/*
 	 * Mask and clear PMU interrupts
@@ -111,18 +121,6 @@ void __init dove_init_irq(void)
 	writel(0, PMU_INTERRUPT_MASK);
 	writel(0, PMU_INTERRUPT_CAUSE);
 
-	for (i = IRQ_DOVE_GPIO_START; i < IRQ_DOVE_PMU_START; i++) {
-		set_irq_chip(i, &orion_gpio_irq_chip);
-		set_irq_handler(i, handle_level_irq);
-		irq_desc[i].status |= IRQ_LEVEL;
-		set_irq_flags(i, IRQF_VALID);
-	}
-	set_irq_chained_handler(IRQ_DOVE_GPIO_0_7, gpio_irq_handler);
-	set_irq_chained_handler(IRQ_DOVE_GPIO_8_15, gpio_irq_handler);
-	set_irq_chained_handler(IRQ_DOVE_GPIO_16_23, gpio_irq_handler);
-	set_irq_chained_handler(IRQ_DOVE_GPIO_24_31, gpio_irq_handler);
-	set_irq_chained_handler(IRQ_DOVE_HIGH_GPIO, gpio_irq_handler);
-
 	for (i = IRQ_DOVE_PMU_START; i < NR_IRQS; i++) {
 		set_irq_chip(i, &pmu_irq_chip);
 		set_irq_handler(i, handle_level_irq);

commit aa456a6eba197f0774d68531342ba7f85ccf2971
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Mon Nov 29 10:27:47 2010 +0100

    ARM: dove: irq_data conversion.
    
    Signed-off-by: Lennert Buytenhek <buytenh@secretlab.ca>
    Acked-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c
index 61bfcb3b08c2..9317f0558b57 100644
--- a/arch/arm/mach-dove/irq.c
+++ b/arch/arm/mach-dove/irq.c
@@ -36,9 +36,9 @@ static void gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
 	}
 }
 
-static void pmu_irq_mask(unsigned int irq)
+static void pmu_irq_mask(struct irq_data *d)
 {
-	int pin = irq_to_pmu(irq);
+	int pin = irq_to_pmu(d->irq);
 	u32 u;
 
 	u = readl(PMU_INTERRUPT_MASK);
@@ -46,9 +46,9 @@ static void pmu_irq_mask(unsigned int irq)
 	writel(u, PMU_INTERRUPT_MASK);
 }
 
-static void pmu_irq_unmask(unsigned int irq)
+static void pmu_irq_unmask(struct irq_data *d)
 {
-	int pin = irq_to_pmu(irq);
+	int pin = irq_to_pmu(d->irq);
 	u32 u;
 
 	u = readl(PMU_INTERRUPT_MASK);
@@ -56,9 +56,9 @@ static void pmu_irq_unmask(unsigned int irq)
 	writel(u, PMU_INTERRUPT_MASK);
 }
 
-static void pmu_irq_ack(unsigned int irq)
+static void pmu_irq_ack(struct irq_data *d)
 {
-	int pin = irq_to_pmu(irq);
+	int pin = irq_to_pmu(d->irq);
 	u32 u;
 
 	u = ~(1 << (pin & 31));
@@ -67,9 +67,9 @@ static void pmu_irq_ack(unsigned int irq)
 
 static struct irq_chip pmu_irq_chip = {
 	.name		= "pmu_irq",
-	.mask		= pmu_irq_mask,
-	.unmask		= pmu_irq_unmask,
-	.ack		= pmu_irq_ack,
+	.irq_mask	= pmu_irq_mask,
+	.irq_unmask	= pmu_irq_unmask,
+	.irq_ack	= pmu_irq_ack,
 };
 
 static void pmu_irq_handler(unsigned int irq, struct irq_desc *desc)

commit edabd38e1a017e922e3e3b485ee3ddb4df433aa4
Author: Saeed Bishara <saeed@marvell.com>
Date:   Thu Aug 6 15:12:43 2009 +0300

    ARM: add base support for Marvell Dove SoC
    
    The Marvell Dove (88AP510) is a high-performance, highly integrated,
    low power SoC with high-end ARM-compatible processor (known as PJ4),
    graphics processing unit, high-definition video decoding acceleration
    hardware, and a broad range of peripherals.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Signed-off-by: Saeed Bishara <saeed@marvell.com>
    Signed-off-by: Nicolas Pitre <nico@marvell.com>

diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c
new file mode 100644
index 000000000000..61bfcb3b08c2
--- /dev/null
+++ b/arch/arm/mach-dove/irq.c
@@ -0,0 +1,133 @@
+/*
+ * arch/arm/mach-dove/irq.c
+ *
+ * Dove IRQ handling.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <asm/mach/arch.h>
+#include <plat/irq.h>
+#include <asm/mach/irq.h>
+#include <mach/pm.h>
+#include <mach/bridge-regs.h>
+#include "common.h"
+
+static void gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
+{
+	int irqoff;
+	BUG_ON(irq < IRQ_DOVE_GPIO_0_7 || irq > IRQ_DOVE_HIGH_GPIO);
+
+	irqoff = irq <= IRQ_DOVE_GPIO_16_23 ? irq - IRQ_DOVE_GPIO_0_7 :
+		3 + irq - IRQ_DOVE_GPIO_24_31;
+
+	orion_gpio_irq_handler(irqoff << 3);
+	if (irq == IRQ_DOVE_HIGH_GPIO) {
+		orion_gpio_irq_handler(40);
+		orion_gpio_irq_handler(48);
+		orion_gpio_irq_handler(56);
+	}
+}
+
+static void pmu_irq_mask(unsigned int irq)
+{
+	int pin = irq_to_pmu(irq);
+	u32 u;
+
+	u = readl(PMU_INTERRUPT_MASK);
+	u &= ~(1 << (pin & 31));
+	writel(u, PMU_INTERRUPT_MASK);
+}
+
+static void pmu_irq_unmask(unsigned int irq)
+{
+	int pin = irq_to_pmu(irq);
+	u32 u;
+
+	u = readl(PMU_INTERRUPT_MASK);
+	u |= 1 << (pin & 31);
+	writel(u, PMU_INTERRUPT_MASK);
+}
+
+static void pmu_irq_ack(unsigned int irq)
+{
+	int pin = irq_to_pmu(irq);
+	u32 u;
+
+	u = ~(1 << (pin & 31));
+	writel(u, PMU_INTERRUPT_CAUSE);
+}
+
+static struct irq_chip pmu_irq_chip = {
+	.name		= "pmu_irq",
+	.mask		= pmu_irq_mask,
+	.unmask		= pmu_irq_unmask,
+	.ack		= pmu_irq_ack,
+};
+
+static void pmu_irq_handler(unsigned int irq, struct irq_desc *desc)
+{
+	unsigned long cause = readl(PMU_INTERRUPT_CAUSE);
+
+	cause &= readl(PMU_INTERRUPT_MASK);
+	if (cause == 0) {
+		do_bad_IRQ(irq, desc);
+		return;
+	}
+
+	for (irq = 0; irq < NR_PMU_IRQS; irq++) {
+		if (!(cause & (1 << irq)))
+			continue;
+		irq = pmu_to_irq(irq);
+		desc = irq_desc + irq;
+		desc_handle_irq(irq, desc);
+	}
+}
+
+void __init dove_init_irq(void)
+{
+	int i;
+
+	orion_irq_init(0, (void __iomem *)(IRQ_VIRT_BASE + IRQ_MASK_LOW_OFF));
+	orion_irq_init(32, (void __iomem *)(IRQ_VIRT_BASE + IRQ_MASK_HIGH_OFF));
+
+	/*
+	 * Mask and clear GPIO IRQ interrupts.
+	 */
+	writel(0, GPIO_LEVEL_MASK(0));
+	writel(0, GPIO_EDGE_MASK(0));
+	writel(0, GPIO_EDGE_CAUSE(0));
+
+	/*
+	 * Mask and clear PMU interrupts
+	 */
+	writel(0, PMU_INTERRUPT_MASK);
+	writel(0, PMU_INTERRUPT_CAUSE);
+
+	for (i = IRQ_DOVE_GPIO_START; i < IRQ_DOVE_PMU_START; i++) {
+		set_irq_chip(i, &orion_gpio_irq_chip);
+		set_irq_handler(i, handle_level_irq);
+		irq_desc[i].status |= IRQ_LEVEL;
+		set_irq_flags(i, IRQF_VALID);
+	}
+	set_irq_chained_handler(IRQ_DOVE_GPIO_0_7, gpio_irq_handler);
+	set_irq_chained_handler(IRQ_DOVE_GPIO_8_15, gpio_irq_handler);
+	set_irq_chained_handler(IRQ_DOVE_GPIO_16_23, gpio_irq_handler);
+	set_irq_chained_handler(IRQ_DOVE_GPIO_24_31, gpio_irq_handler);
+	set_irq_chained_handler(IRQ_DOVE_HIGH_GPIO, gpio_irq_handler);
+
+	for (i = IRQ_DOVE_PMU_START; i < NR_IRQS; i++) {
+		set_irq_chip(i, &pmu_irq_chip);
+		set_irq_handler(i, handle_level_irq);
+		irq_desc[i].status |= IRQ_LEVEL;
+		set_irq_flags(i, IRQF_VALID);
+	}
+	set_irq_chained_handler(IRQ_DOVE_PMU, pmu_irq_handler);
+}
