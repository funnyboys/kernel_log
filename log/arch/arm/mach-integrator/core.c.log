commit 65fddcfca8ad14778f71a57672fd01e8112d30fa
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:42 2020 -0700

    mm: reorder includes after introduction of linux/pgtable.h
    
    The replacement of <asm/pgrable.h> with <linux/pgtable.h> made the include
    of the latter in the middle of asm includes.  Fix this up with the aid of
    the below script and manual adjustments here and there.
    
            import sys
            import re
    
            if len(sys.argv) is not 3:
                print "USAGE: %s <file> <header>" % (sys.argv[0])
                sys.exit(1)
    
            hdr_to_move="#include <linux/%s>" % sys.argv[2]
            moved = False
            in_hdrs = False
    
            with open(sys.argv[1], "r") as f:
                lines = f.readlines()
                for _line in lines:
                    line = _line.rstrip('
    ')
                    if line == hdr_to_move:
                        continue
                    if line.startswith("#include <linux/"):
                        in_hdrs = True
                    elif not moved and in_hdrs:
                        moved = True
                        print hdr_to_move
                    print line
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-4-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 7cda45a2ddef..0fe5e1dc9d89 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -21,10 +21,10 @@
 #include <linux/stat.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
+#include <linux/pgtable.h>
 
 #include <asm/mach-types.h>
 #include <asm/mach/time.h>
-#include <linux/pgtable.h>
 
 #include "hardware.h"
 #include "cm.h"

commit ca5999fde0a1761665a38e4c9a72dbcd7d190a81
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:38 2020 -0700

    mm: introduce include/linux/pgtable.h
    
    The include/linux/pgtable.h is going to be the home of generic page table
    manipulation functions.
    
    Start with moving asm-generic/pgtable.h to include/linux/pgtable.h and
    make the latter include asm/pgtable.h.
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-3-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 9da3ae232211..7cda45a2ddef 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -24,7 +24,7 @@
 
 #include <asm/mach-types.h>
 #include <asm/mach/time.h>
-#include <asm/pgtable.h>
+#include <linux/pgtable.h>
 
 #include "hardware.h"
 #include "cm.h"

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 948872a419c1..9da3ae232211 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -1,11 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  linux/arch/arm/mach-integrator/core.c
  *
  *  Copyright (C) 2000-2003 Deep Blue Solutions Ltd
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2, as
- * published by the Free Software Foundation.
  */
 #include <linux/types.h>
 #include <linux/kernel.h>

commit f956a785a282f6b5a3e7d59937548f8b7c04d1ac
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Oct 24 12:51:20 2014 +0200

    soc: move SoC driver for the ARM Integrator
    
    This creates a new SoC bus driver for the ARM Integrator
    family core modules to register the SoC bus and provide
    sysfs info for the core module. We delete the corresponding
    code from the Integrator machine and select this driver to
    get a clean result.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index b06fd9f99a46..948872a419c1 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -60,40 +60,6 @@ void cm_control(u32 mask, u32 set)
 	raw_spin_unlock_irqrestore(&cm_lock, flags);
 }
 
-static const char *integrator_arch_str(u32 id)
-{
-	switch ((id >> 16) & 0xff) {
-	case 0x00:
-		return "ASB little-endian";
-	case 0x01:
-		return "AHB little-endian";
-	case 0x03:
-		return "AHB-Lite system bus, bi-endian";
-	case 0x04:
-		return "AHB";
-	case 0x08:
-		return "AHB system bus, ASB processor bus";
-	default:
-		return "Unknown";
-	}
-}
-
-static const char *integrator_fpga_str(u32 id)
-{
-	switch ((id >> 12) & 0xf) {
-	case 0x01:
-		return "XC4062";
-	case 0x02:
-		return "XC4085";
-	case 0x03:
-		return "XVC600";
-	case 0x04:
-		return "EPM7256AE (Altera PLD)";
-	default:
-		return "Unknown";
-	}
-}
-
 void cm_clear_irqs(void)
 {
 	/* disable core module IRQs */
@@ -109,7 +75,6 @@ static const struct of_device_id cm_match[] = {
 void cm_init(void)
 {
 	struct device_node *cm = of_find_matching_node(NULL, cm_match);
-	u32 val;
 
 	if (!cm) {
 		pr_crit("no core module node found in device tree\n");
@@ -121,13 +86,6 @@ void cm_init(void)
 		return;
 	}
 	cm_clear_irqs();
-	val = readl(cm_base + INTEGRATOR_HDR_ID_OFFSET);
-	pr_info("Detected ARM core module:\n");
-	pr_info("    Manufacturer: %02x\n", (val >> 24));
-	pr_info("    Architecture: %s\n", integrator_arch_str(val));
-	pr_info("    FPGA: %s\n", integrator_fpga_str(val));
-	pr_info("    Build: %02x\n", (val >> 4) & 0xFF);
-	pr_info("    Rev: %c\n", ('A' + (val & 0x03)));
 }
 
 /*
@@ -139,56 +97,3 @@ void __init integrator_reserve(void)
 {
 	memblock_reserve(PHYS_OFFSET, __pa(swapper_pg_dir) - PHYS_OFFSET);
 }
-
-static u32 integrator_id;
-
-static ssize_t intcp_get_manf(struct device *dev,
-			      struct device_attribute *attr,
-			      char *buf)
-{
-	return sprintf(buf, "%02x\n", integrator_id >> 24);
-}
-
-static struct device_attribute intcp_manf_attr =
-	__ATTR(manufacturer,  S_IRUGO, intcp_get_manf,  NULL);
-
-static ssize_t intcp_get_arch(struct device *dev,
-			      struct device_attribute *attr,
-			      char *buf)
-{
-	return sprintf(buf, "%s\n", integrator_arch_str(integrator_id));
-}
-
-static struct device_attribute intcp_arch_attr =
-	__ATTR(architecture,  S_IRUGO, intcp_get_arch,  NULL);
-
-static ssize_t intcp_get_fpga(struct device *dev,
-			      struct device_attribute *attr,
-			      char *buf)
-{
-	return sprintf(buf, "%s\n", integrator_fpga_str(integrator_id));
-}
-
-static struct device_attribute intcp_fpga_attr =
-	__ATTR(fpga,  S_IRUGO, intcp_get_fpga,  NULL);
-
-static ssize_t intcp_get_build(struct device *dev,
-			       struct device_attribute *attr,
-			       char *buf)
-{
-	return sprintf(buf, "%02x\n", (integrator_id >> 4) & 0xFF);
-}
-
-static struct device_attribute intcp_build_attr =
-	__ATTR(build,  S_IRUGO, intcp_get_build,  NULL);
-
-
-
-void integrator_init_sysfs(struct device *parent, u32 id)
-{
-	integrator_id = id;
-	device_create_file(parent, &intcp_manf_attr);
-	device_create_file(parent, &intcp_arch_attr);
-	device_create_file(parent, &intcp_fpga_attr);
-	device_create_file(parent, &intcp_build_attr);
-}

commit b437c52c296715eaad77c949fcfc074911a72427
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Oct 17 16:18:59 2014 +0200

    ARM: integrator: move restart to the device tree
    
    Using the augmented reset driver for the Versatile family,
    we can move the reset handling for the Integrator out of the
    machine. We add a "syscon" attribute to the core module, and
    access the syscon registers using this handle. We need to
    select SYSCON, POWER, POWER_RESET and POWER_RESET_VERSATILE
    in order for the restart functionality to always be
    available on all systems (it should not be optional).
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index e3f3aca43efb..b06fd9f99a46 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -140,14 +140,6 @@ void __init integrator_reserve(void)
 	memblock_reserve(PHYS_OFFSET, __pa(swapper_pg_dir) - PHYS_OFFSET);
 }
 
-/*
- * To reset, we hit the on-board reset register in the system FPGA
- */
-void integrator_restart(enum reboot_mode mode, const char *cmd)
-{
-	cm_control(CM_CTRL_RESET, CM_CTRL_RESET);
-}
-
 static u32 integrator_id;
 
 static ssize_t intcp_get_manf(struct device *dev,

commit 1b1ef755bd910106fef15bd55386b60e88d73e16
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Feb 13 21:26:24 2014 +0100

    ARM: integrator: localize the hardware.h header
    
    As we move toward multiplatform support for the Integrator family
    we need to localize all <mach/*> headers. This moves the hardware.h
    header down to the machine folder. There are no users outside the
    machine in the kernel.
    
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Jonathan Austin <jonathan.austin@arm.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 7a330f541a9d..e3f3aca43efb 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -25,12 +25,11 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 
-#include <mach/hardware.h>
-
 #include <asm/mach-types.h>
 #include <asm/mach/time.h>
 #include <asm/pgtable.h>
 
+#include "hardware.h"
 #include "cm.h"
 #include "common.h"
 

commit f8487aa85b0f3c092bb3c1f27972b445a1944048
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Feb 13 21:20:57 2014 +0100

    ARM: integrator: merge platform.h to hardware.h
    
    There is no need to have the two separate headers <mach/platform.h>
    and <mach/hardware.h>, especially since we are now going to make them
    local files. There is not one single driver outside the mach-integrator
    folder referencing any of the files.
    
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Jonathan Austin <jonathan.austin@arm.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 00ddf20ed91b..7a330f541a9d 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -26,7 +26,6 @@
 #include <linux/of_address.h>
 
 #include <mach/hardware.h>
-#include <mach/platform.h>
 
 #include <asm/mach-types.h>
 #include <asm/mach/time.h>

commit bb4dbefe4c6ae3685152d03e318e093d5f6f795a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sun Jun 16 02:44:27 2013 +0200

    ARM: integrator: move CM base into device tree
    
    This moves the core module (CM) control base into the device
    tree. It is a simple memory range of 0x200 bytes. Move the
    cm header down into the machine directory and unexport the
    cm_control() symbol as no modules are using it.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index dd85cc9d234c..00ddf20ed91b 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -22,18 +22,21 @@
 #include <linux/amba/serial.h>
 #include <linux/io.h>
 #include <linux/stat.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
 
 #include <mach/hardware.h>
 #include <mach/platform.h>
-#include <mach/cm.h>
 
 #include <asm/mach-types.h>
 #include <asm/mach/time.h>
 #include <asm/pgtable.h>
 
+#include "cm.h"
 #include "common.h"
 
 static DEFINE_RAW_SPINLOCK(cm_lock);
+static void __iomem *cm_base;
 
 /**
  * cm_get - get the value from the CM_CTRL register
@@ -54,12 +57,80 @@ void cm_control(u32 mask, u32 set)
 	u32 val;
 
 	raw_spin_lock_irqsave(&cm_lock, flags);
-	val = readl(CM_CTRL) & ~mask;
-	writel(val | set, CM_CTRL);
+	val = readl(cm_base + INTEGRATOR_HDR_CTRL_OFFSET) & ~mask;
+	writel(val | set, cm_base + INTEGRATOR_HDR_CTRL_OFFSET);
 	raw_spin_unlock_irqrestore(&cm_lock, flags);
 }
 
-EXPORT_SYMBOL(cm_control);
+static const char *integrator_arch_str(u32 id)
+{
+	switch ((id >> 16) & 0xff) {
+	case 0x00:
+		return "ASB little-endian";
+	case 0x01:
+		return "AHB little-endian";
+	case 0x03:
+		return "AHB-Lite system bus, bi-endian";
+	case 0x04:
+		return "AHB";
+	case 0x08:
+		return "AHB system bus, ASB processor bus";
+	default:
+		return "Unknown";
+	}
+}
+
+static const char *integrator_fpga_str(u32 id)
+{
+	switch ((id >> 12) & 0xf) {
+	case 0x01:
+		return "XC4062";
+	case 0x02:
+		return "XC4085";
+	case 0x03:
+		return "XVC600";
+	case 0x04:
+		return "EPM7256AE (Altera PLD)";
+	default:
+		return "Unknown";
+	}
+}
+
+void cm_clear_irqs(void)
+{
+	/* disable core module IRQs */
+	writel(0xffffffffU, cm_base + INTEGRATOR_HDR_IC_OFFSET +
+		IRQ_ENABLE_CLEAR);
+}
+
+static const struct of_device_id cm_match[] = {
+	{ .compatible = "arm,core-module-integrator"},
+	{ },
+};
+
+void cm_init(void)
+{
+	struct device_node *cm = of_find_matching_node(NULL, cm_match);
+	u32 val;
+
+	if (!cm) {
+		pr_crit("no core module node found in device tree\n");
+		return;
+	}
+	cm_base = of_iomap(cm, 0);
+	if (!cm_base) {
+		pr_crit("could not remap core module\n");
+		return;
+	}
+	cm_clear_irqs();
+	val = readl(cm_base + INTEGRATOR_HDR_ID_OFFSET);
+	pr_info("Detected ARM core module:\n");
+	pr_info("    Manufacturer: %02x\n", (val >> 24));
+	pr_info("    Architecture: %s\n", integrator_arch_str(val));
+	pr_info("    FPGA: %s\n", integrator_fpga_str(val));
+	pr_info("    Build: %02x\n", (val >> 4) & 0xFF);
+	pr_info("    Rev: %c\n", ('A' + (val & 0x03)));
+}
 
 /*
  * We need to stop things allocating the low memory; ideally we need a
@@ -95,27 +166,7 @@ static ssize_t intcp_get_arch(struct device *dev,
 			      struct device_attribute *attr,
 			      char *buf)
 {
-	const char *arch;
-
-	switch ((integrator_id >> 16) & 0xff) {
-	case 0x00:
-		arch = "ASB little-endian";
-		break;
-	case 0x01:
-		arch = "AHB little-endian";
-		break;
-	case 0x03:
-		arch = "AHB-Lite system bus, bi-endian";
-		break;
-	case 0x04:
-		arch = "AHB";
-		break;
-	default:
-		arch = "Unknown";
-		break;
-	}
-
-	return sprintf(buf, "%s\n", arch);
+	return sprintf(buf, "%s\n", integrator_arch_str(integrator_id));
 }
 
 static struct device_attribute intcp_arch_attr =
@@ -125,24 +176,7 @@ static ssize_t intcp_get_fpga(struct device *dev,
 			      struct device_attribute *attr,
 			      char *buf)
 {
-	const char *fpga;
-
-	switch ((integrator_id >> 12) & 0xf) {
-	case 0x01:
-		fpga = "XC4062";
-		break;
-	case 0x02:
-		fpga = "XC4085";
-		break;
-	case 0x04:
-		fpga = "EPM7256AE (Altera PLD)";
-		break;
-	default:
-		fpga = "Unknown";
-		break;
-	}
-
-	return sprintf(buf, "%s\n", fpga);
+	return sprintf(buf, "%s\n", integrator_fpga_str(integrator_id));
 }
 
 static struct device_attribute intcp_fpga_attr =

commit 578fdfdf32a84ca17ed2090dba4ff2c8e688cc89
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sat Jun 15 23:58:15 2013 +0200

    ARM: integrator: decommission the <mach/irqs.h> header
    
    This header is no longer needed when we boot from the device tree.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 4698942f3ed3..dd85cc9d234c 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -26,7 +26,6 @@
 #include <mach/hardware.h>
 #include <mach/platform.h>
 #include <mach/cm.h>
-#include <mach/irqs.h>
 
 #include <asm/mach-types.h>
 #include <asm/mach/time.h>

commit d7057e1de8d6c180eb2ecd90b0cab9d1a8a4d8ab
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sat Jun 15 22:01:13 2013 +0200

    ARM: integrator: delete non-devicetree boot path
    
    The Device Tree boot path now supports everything the ATAG
    boot can provide, and the two are equivalent. This deletes
    the ATAG boot path from the Integrator/AP and
    Integrator/CP platforms to move them on to the future.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index c07c821fb6b3..4698942f3ed3 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -34,63 +34,6 @@
 
 #include "common.h"
 
-#ifdef CONFIG_ATAGS
-
-#define INTEGRATOR_RTC_IRQ	{ IRQ_RTCINT }
-#define INTEGRATOR_UART0_IRQ	{ IRQ_UARTINT0 }
-#define INTEGRATOR_UART1_IRQ	{ IRQ_UARTINT1 }
-#define KMI0_IRQ		{ IRQ_KMIINT0 }
-#define KMI1_IRQ		{ IRQ_KMIINT1 }
-
-static AMBA_APB_DEVICE(rtc, "rtc", 0,
-	INTEGRATOR_RTC_BASE, INTEGRATOR_RTC_IRQ, NULL);
-
-static AMBA_APB_DEVICE(uart0, "uart0", 0,
-	INTEGRATOR_UART0_BASE, INTEGRATOR_UART0_IRQ, NULL);
-
-static AMBA_APB_DEVICE(uart1, "uart1", 0,
-	INTEGRATOR_UART1_BASE, INTEGRATOR_UART1_IRQ, NULL);
-
-static AMBA_APB_DEVICE(kmi0, "kmi0", 0, KMI0_BASE, KMI0_IRQ, NULL);
-static AMBA_APB_DEVICE(kmi1, "kmi1", 0, KMI1_BASE, KMI1_IRQ, NULL);
-
-static struct amba_device *amba_devs[] __initdata = {
-	&rtc_device,
-	&uart0_device,
-	&uart1_device,
-	&kmi0_device,
-	&kmi1_device,
-};
-
-int __init integrator_init(bool is_cp)
-{
-	int i;
-
-	/*
-	 * The Integrator/AP lacks necessary AMBA PrimeCell IDs, so we need to
-	 * hard-code them. The Integator/CP and forward have proper cell IDs.
-	 * Else we leave them undefined to the bus driver can autoprobe them.
-	 */
-	if (!is_cp && IS_ENABLED(CONFIG_ARCH_INTEGRATOR_AP)) {
-		rtc_device.periphid	= 0x00041030;
-		uart0_device.periphid	= 0x00041010;
-		uart1_device.periphid	= 0x00041010;
-		kmi0_device.periphid	= 0x00041050;
-		kmi1_device.periphid	= 0x00041050;
-		uart0_device.dev.platform_data = &ap_uart_data;
-		uart1_device.dev.platform_data = &ap_uart_data;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
-		struct amba_device *d = amba_devs[i];
-		amba_device_register(d, &iomem_resource);
-	}
-
-	return 0;
-}
-
-#endif
-
 static DEFINE_RAW_SPINLOCK(cm_lock);
 
 /**

commit fb61f8622369aad275a4e3487b8aeec7a571fdde
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Oct 10 14:11:18 2013 +0200

    ARM: integrator: get the CM control register by proxy
    
    The CM_CTRL register was accessed directly from the LED driver,
    which does not work now that we get the base for the register
    from the device tree. Add an accessor function to do this and
    make the LED driver compile again.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 4cdfd7365925..c07c821fb6b3 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -93,6 +93,14 @@ int __init integrator_init(bool is_cp)
 
 static DEFINE_RAW_SPINLOCK(cm_lock);
 
+/**
+ * cm_get - get the value from the CM_CTRL register
+ */
+u32 cm_get(void)
+{
+	return readl(cm_base + INTEGRATOR_HDR_CTRL_OFFSET);
+}
+
 /**
  * cm_control - update the CM_CTRL register.
  * @mask: bits to change

commit 7b6d864b48d95e6ea1df7df64475b9cb9616dcf9
Author: Robin Holt <holt@sgi.com>
Date:   Mon Jul 8 16:01:40 2013 -0700

    reboot: arm: change reboot_mode to use enum reboot_mode
    
    Preparing to move the parsing of reboot= to generic kernel code forces
    the change in reboot_mode handling to use the enum.
    
    [akpm@linux-foundation.org: fix arch/arm/mach-socfpga/socfpga.c]
    Signed-off-by: Robin Holt <holt@sgi.com>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Russ Anderson <rja@sgi.com>
    Cc: Robin Holt <holt@sgi.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 81461d218717..4cdfd7365925 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -124,7 +124,7 @@ void __init integrator_reserve(void)
 /*
  * To reset, we hit the on-board reset register in the system FPGA
  */
-void integrator_restart(char mode, const char *cmd)
+void integrator_restart(enum reboot_mode mode, const char *cmd)
 {
 	cm_control(CM_CTRL_RESET, CM_CTRL_RESET);
 }

commit a02e0a831fc43ed580b8161a2ca5c29c3ae813d9
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Feb 14 13:43:29 2013 +0100

    ARM: integrator: fix build with INTEGRATOR_AP off
    
    The conditional declaration of ap_uart_data is broken
    and causes this build error:
    
    In file included from arch/arm/mach-integrator/core.c:35:0:
    arch/arm/mach-integrator/common.h:6:37: error: expected '=', ',', ';', 'asm' or '__attribute__' before '{' token
    
    Turning the check into an constant-expression if(IS_ENABLED()) statement
    creates more readable code and solves this problem as well.
    
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Russell King <linux@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 39c060f75e47..81461d218717 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -71,7 +71,7 @@ int __init integrator_init(bool is_cp)
 	 * hard-code them. The Integator/CP and forward have proper cell IDs.
 	 * Else we leave them undefined to the bus driver can autoprobe them.
 	 */
-	if (!is_cp) {
+	if (!is_cp && IS_ENABLED(CONFIG_ARCH_INTEGRATOR_AP)) {
 		rtc_device.periphid	= 0x00041030;
 		uart0_device.periphid	= 0x00041010;
 		uart1_device.periphid	= 0x00041010;

commit 379df2793efdca18e91cb8570f844ad1f83eb609
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sat Nov 17 19:24:23 2012 +0100

    ARM: integrator: push down SC dependencies
    
    This pushes the dependencies on the Integrator/AP system
    controller (SC) down into the PCI V3 driver and the
    AP-specific board file.
    
    First, the platform data for the PL010 UART is moved into
    the integrator_ap.c board file, and the Integrator/CP is
    assigned with NULL pdata. This way the callback functions
    can reference the dynamically remapped AP syscon address
    in both the ATAG and DT boot path, and this remapping
    is localized to the board file.
    
    Second the PCIv3 driver is making its own dynamic remapping
    of the SC for the few registers it is using. When we
    convert the PCIv3 driver over to using device tree having a
    dynamically assigned base address will be useful, but we
    will have to use the definition from <mach/platform.h> for
    now, the only improvement is that it's done dynamically.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 161fbf8596bd..39c060f75e47 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -18,7 +18,6 @@
 #include <linux/memblock.h>
 #include <linux/sched.h>
 #include <linux/smp.h>
-#include <linux/termios.h>
 #include <linux/amba/bus.h>
 #include <linux/amba/serial.h>
 #include <linux/io.h>
@@ -47,10 +46,10 @@ static AMBA_APB_DEVICE(rtc, "rtc", 0,
 	INTEGRATOR_RTC_BASE, INTEGRATOR_RTC_IRQ, NULL);
 
 static AMBA_APB_DEVICE(uart0, "uart0", 0,
-	INTEGRATOR_UART0_BASE, INTEGRATOR_UART0_IRQ, &integrator_uart_data);
+	INTEGRATOR_UART0_BASE, INTEGRATOR_UART0_IRQ, NULL);
 
 static AMBA_APB_DEVICE(uart1, "uart1", 0,
-	INTEGRATOR_UART1_BASE, INTEGRATOR_UART1_IRQ, &integrator_uart_data);
+	INTEGRATOR_UART1_BASE, INTEGRATOR_UART1_IRQ, NULL);
 
 static AMBA_APB_DEVICE(kmi0, "kmi0", 0, KMI0_BASE, KMI0_IRQ, NULL);
 static AMBA_APB_DEVICE(kmi1, "kmi1", 0, KMI1_BASE, KMI1_IRQ, NULL);
@@ -78,6 +77,8 @@ int __init integrator_init(bool is_cp)
 		uart1_device.periphid	= 0x00041010;
 		kmi0_device.periphid	= 0x00041050;
 		kmi1_device.periphid	= 0x00041050;
+		uart0_device.dev.platform_data = &ap_uart_data;
+		uart1_device.dev.platform_data = &ap_uart_data;
 	}
 
 	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
@@ -90,49 +91,6 @@ int __init integrator_init(bool is_cp)
 
 #endif
 
-/*
- * On the Integrator platform, the port RTS and DTR are provided by
- * bits in the following SC_CTRLS register bits:
- *        RTS  DTR
- *  UART0  7    6
- *  UART1  5    4
- */
-#define SC_CTRLC	__io_address(INTEGRATOR_SC_CTRLC)
-#define SC_CTRLS	__io_address(INTEGRATOR_SC_CTRLS)
-
-static void integrator_uart_set_mctrl(struct amba_device *dev, void __iomem *base, unsigned int mctrl)
-{
-	unsigned int ctrls = 0, ctrlc = 0, rts_mask, dtr_mask;
-	u32 phybase = dev->res.start;
-
-	if (phybase == INTEGRATOR_UART0_BASE) {
-		/* UART0 */
-		rts_mask = 1 << 4;
-		dtr_mask = 1 << 5;
-	} else {
-		/* UART1 */
-		rts_mask = 1 << 6;
-		dtr_mask = 1 << 7;
-	}
-
-	if (mctrl & TIOCM_RTS)
-		ctrlc |= rts_mask;
-	else
-		ctrls |= rts_mask;
-
-	if (mctrl & TIOCM_DTR)
-		ctrlc |= dtr_mask;
-	else
-		ctrls |= dtr_mask;
-
-	__raw_writel(ctrls, SC_CTRLS);
-	__raw_writel(ctrlc, SC_CTRLC);
-}
-
-struct amba_pl010_data integrator_uart_data = {
-	.set_mctrl = integrator_uart_set_mctrl,
-};
-
 static DEFINE_RAW_SPINLOCK(cm_lock);
 
 /**

commit e67ae6be734de909954e20317c38472af983b92c
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Nov 2 01:31:10 2012 +0100

    ARM: integrator: hook the AP into the SoC bus
    
    This hooks the Integrator/AP into the SoC bus when booting from
    device tree, by mapping the AP controller registers first,
    then registering the SoC device, and then populating the device
    tree with the SoC device as parent.
    
    Introduce some helpers in the core to provide sysfs files
    detailing the use of the SoC ID which will later be reused by
    the Integrator/CP patch for the same bus grouping.
    
    Cc: Lee Jones <lee.jones@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index ea22a17246d7..161fbf8596bd 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -22,6 +22,7 @@
 #include <linux/amba/bus.h>
 #include <linux/amba/serial.h>
 #include <linux/io.h>
+#include <linux/stat.h>
 
 #include <mach/hardware.h>
 #include <mach/platform.h>
@@ -169,3 +170,93 @@ void integrator_restart(char mode, const char *cmd)
 {
 	cm_control(CM_CTRL_RESET, CM_CTRL_RESET);
 }
+
+static u32 integrator_id;
+
+static ssize_t intcp_get_manf(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	return sprintf(buf, "%02x\n", integrator_id >> 24);
+}
+
+static struct device_attribute intcp_manf_attr =
+	__ATTR(manufacturer,  S_IRUGO, intcp_get_manf,  NULL);
+
+static ssize_t intcp_get_arch(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	const char *arch;
+
+	switch ((integrator_id >> 16) & 0xff) {
+	case 0x00:
+		arch = "ASB little-endian";
+		break;
+	case 0x01:
+		arch = "AHB little-endian";
+		break;
+	case 0x03:
+		arch = "AHB-Lite system bus, bi-endian";
+		break;
+	case 0x04:
+		arch = "AHB";
+		break;
+	default:
+		arch = "Unknown";
+		break;
+	}
+
+	return sprintf(buf, "%s\n", arch);
+}
+
+static struct device_attribute intcp_arch_attr =
+	__ATTR(architecture,  S_IRUGO, intcp_get_arch,  NULL);
+
+static ssize_t intcp_get_fpga(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	const char *fpga;
+
+	switch ((integrator_id >> 12) & 0xf) {
+	case 0x01:
+		fpga = "XC4062";
+		break;
+	case 0x02:
+		fpga = "XC4085";
+		break;
+	case 0x04:
+		fpga = "EPM7256AE (Altera PLD)";
+		break;
+	default:
+		fpga = "Unknown";
+		break;
+	}
+
+	return sprintf(buf, "%s\n", fpga);
+}
+
+static struct device_attribute intcp_fpga_attr =
+	__ATTR(fpga,  S_IRUGO, intcp_get_fpga,  NULL);
+
+static ssize_t intcp_get_build(struct device *dev,
+			       struct device_attribute *attr,
+			       char *buf)
+{
+	return sprintf(buf, "%02x\n", (integrator_id >> 4) & 0xFF);
+}
+
+static struct device_attribute intcp_build_attr =
+	__ATTR(build,  S_IRUGO, intcp_get_build,  NULL);
+
+
+
+void integrator_init_sysfs(struct device *parent, u32 id)
+{
+	integrator_id = id;
+	device_create_file(parent, &intcp_manf_attr);
+	device_create_file(parent, &intcp_arch_attr);
+	device_create_file(parent, &intcp_fpga_attr);
+	device_create_file(parent, &intcp_build_attr);
+}

commit 0e51793e162ca432fc5f04178cf82b80a92c2659
Merge: 5cad3598ea0c b4874a3d2986
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Oct 7 21:20:57 2012 +0900

    Merge branch 'for-linus' of git://git.linaro.org/people/rmk/linux-arm
    
    Pull ARM updates from Russell King:
     "This is the first chunk of ARM updates for this merge window.
      Conflicts are expected in two files - asm/timex.h and
      mach-integrator/integrator_cp.c.  Nothing particularly stands out more
      than anything else.
    
      Most of the growth is down to the opcodes stuff from Dave Martin,
      which is countered by Rob's patches to use more of the asm-generic
      headers on ARM."
    
    (A few more conflicts grew since then, but it all looked fairly trivial)
    
    * 'for-linus' of git://git.linaro.org/people/rmk/linux-arm: (44 commits)
      ARM: 7548/1: include linux/sched.h in syscall.h
      ARM: 7541/1: Add ARM ERRATA 775420 workaround
      ARM: ensure vm_struct has its phys_addr member filled in
      ARM: 7540/1: kexec: Check segment memory addresses
      ARM: 7539/1: kexec: scan for dtb magic in segments
      ARM: 7538/1: delay: add registration mechanism for delay timer sources
      ARM: 7536/1: smp: Formalize an IPI for wakeup
      ARM: 7525/1: ptrace: use updated syscall number for syscall auditing
      ARM: 7524/1: support syscall tracing
      ARM: 7519/1: integrator: convert platform devices to Device Tree
      ARM: 7518/1: integrator: convert AMBA devices to device tree
      ARM: 7517/1: integrator: initial device tree support
      ARM: 7516/1: plat-versatile: add DT support to FPGA IRQ
      ARM: 7515/1: integrator: check PL010 base address from resource
      ARM: 7514/1: integrator: call common init function from machine
      ARM: 7522/1: arch_timers: register a time/cycle counter
      ARM: 7523/1: arch_timers: enable the use of the virtual timer
      ARM: 7531/1: mark kernelmode mem{cpy,set} non-experimental
      ARM: 7520/1: Build dtb files in all target
      ARM: Fix build warning in arch/arm/mm/alignment.c
      ...

commit 8f446a7a069e0af0639385f67c78ee2279bca04c
Merge: 84be4ae2c038 04ef037c926d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 1 18:46:13 2012 -0700

    Merge tag 'drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM soc driver specific changes from Olof Johansson:
     - A long-coming conversion of various platforms to a common LED
       infrastructure
     - AT91 is moved over to use the newer MCI driver for MMC
     - Pincontrol conversions for samsung platforms
     - DT bindings for gscaler on samsung
     - i2c driver fixes for tegra, acked by i2c maintainer
    
    Fix up conflicts as per Olof.
    
    * tag 'drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (48 commits)
      drivers: bus: omap_l3: use resources instead of hardcoded irqs
      pinctrl: exynos: Fix wakeup IRQ domain registration check
      pinctrl: samsung: Uninline samsung_pinctrl_get_soc_data
      pinctrl: exynos: Correct the detection of wakeup-eint node
      pinctrl: exynos: Mark exynos_irq_demux_eint as inline
      pinctrl: exynos: Handle only unmasked wakeup interrupts
      pinctrl: exynos: Fix typos in gpio/wkup _irq_mask
      pinctrl: exynos: Set pin function to EINT in irq_set_type of GPIO EINTa
      drivers: bus: Move the OMAP interconnect driver to drivers/bus/
      i2c: tegra: dynamically control fast clk
      i2c: tegra: I2_M_NOSTART functionality not supported in Tegra20
      ARM: tegra: clock: remove unused clock entry for i2c
      ARM: tegra: clock: add connection name in i2c clock entry
      i2c: tegra: pass proper name for getting clock
      ARM: tegra: clock: add i2c fast clock entry in clock table
      ARM: EXYNOS: Adds G-Scaler device from Device Tree
      ARM: EXYNOS: Add clock support for G-Scaler
      ARM: EXYNOS: Enable pinctrl driver support for EXYNOS4 device tree enabled platform
      ARM: dts: Add pinctrl node entries for SAMSUNG EXYNOS4210 SoC
      ARM: EXYNOS: skip wakeup interrupt setup if pinctrl driver is used
      ...

commit b7a3f8db07c1bca303dbf038f108dd84638bcd82
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Sep 14 20:16:39 2012 +0000

    ARM: integrator: use __iomem pointers for MMIO
    
    ARM is moving to stricter checks on readl/write functions,
    so we need to use the correct types everywhere.
    
    This patch has a few small conflicts with stuff in linux-next, which
    we have to sort out in arm-soc.
    
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 3fa6c51390da..a432d4325f89 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -95,8 +95,8 @@ arch_initcall(integrator_init);
  *  UART0  7    6
  *  UART1  5    4
  */
-#define SC_CTRLC	IO_ADDRESS(INTEGRATOR_SC_CTRLC)
-#define SC_CTRLS	IO_ADDRESS(INTEGRATOR_SC_CTRLS)
+#define SC_CTRLC	__io_address(INTEGRATOR_SC_CTRLC)
+#define SC_CTRLS	__io_address(INTEGRATOR_SC_CTRLS)
 
 static void integrator_uart_set_mctrl(struct amba_device *dev, void __iomem *base, unsigned int mctrl)
 {

commit 4672cddff21f6edde857aa4b523bbc1bfc741cf8
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Sep 6 09:08:47 2012 +0100

    ARM: 7518/1: integrator: convert AMBA devices to device tree
    
    This converts the AMBA (PrimeCell) devices on the Integrator/AP
    and Integrator/CP over to probing from the Device Tree if the
    kernel is compiled for Device Tree support.
    
    We continue to #ifdef out all non-DT code and vice versa on
    respective boot type to get a clean cut.
    
    We need to add a bunch of auxdata (compare to the Versatile)
    to handle bus names and callbacks alike.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 268eadf6d3e6..1772c024e789 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -33,7 +33,9 @@
 #include <asm/mach/time.h>
 #include <asm/pgtable.h>
 
-static struct amba_pl010_data integrator_uart_data;
+#include "common.h"
+
+#ifdef CONFIG_ATAGS
 
 #define INTEGRATOR_RTC_IRQ	{ IRQ_RTCINT }
 #define INTEGRATOR_UART0_IRQ	{ IRQ_UARTINT0 }
@@ -86,6 +88,8 @@ int __init integrator_init(bool is_cp)
 	return 0;
 }
 
+#endif
+
 /*
  * On the Integrator platform, the port RTS and DTR are provided by
  * bits in the following SC_CTRLS register bits:
@@ -125,7 +129,7 @@ static void integrator_uart_set_mctrl(struct amba_device *dev, void __iomem *bas
 	__raw_writel(ctrlc, SC_CTRLC);
 }
 
-static struct amba_pl010_data integrator_uart_data = {
+struct amba_pl010_data integrator_uart_data = {
 	.set_mctrl = integrator_uart_set_mctrl,
 };
 

commit 2e6185f1fea6cf88e9ce25cde1d6291ddfb3d4f0
Merge: 7405a749ae14 fd301cc4e5ba
Author: Olof Johansson <olof@lixom.net>
Date:   Sun Sep 16 18:31:37 2012 -0700

    Merge tag 'tegra-for-3.7-drivers-i2c' of git://git.kernel.org/pub/scm/linux/kernel/git/swarren/linux-tegra into next/drivers
    
    From Stephen Warren:
    
    ARM: tegra: i2c driver enhancements mostly related to clocking
    
    This branch contains a number of fixes and cleanups to the Tegra I2C
    driver related to clocks. These are based on the common clock conversion
    in order to avoid duplicating the clock driver changes before and after
    the conversion. Finally, a bug-fix related to I2C_M_NOSTART is included.
    
    This branch is based on previous pull request tegra-for-3.7-common-clk.
    
    * tag 'tegra-for-3.7-drivers-i2c' of git://git.kernel.org/pub/scm/linux/kernel/git/swarren/linux-tegra:
      i2c: tegra: dynamically control fast clk
      i2c: tegra: I2_M_NOSTART functionality not supported in Tegra20
      ARM: tegra: clock: remove unused clock entry for i2c
      ARM: tegra: clock: add connection name in i2c clock entry
      i2c: tegra: pass proper name for getting clock
      ARM: tegra: clock: add i2c fast clock entry in clock table
      ARM: Tegra: Add smp_twd clock for Tegra20
      ARM: tegra: cpu-tegra: explicitly manage re-parenting
      ARM: tegra: fix overflow in tegra20_pll_clk_round_rate()
      ARM: tegra: Fix data type for io address
      ARM: tegra: remove tegra_timer from tegra_list_clks
      ARM: tegra30: clocks: fix the wrong tegra_audio_sync_clk_ops name
      ARM: tegra: clocks: separate tegra_clk_32k_ops from Tegra20 and Tegra30
      ARM: tegra: Remove duplicate code
      ARM: tegra: Port tegra to generic clock framework
      ARM: tegra: Add clk_tegra structure and helper functions
      ARM: tegra: Rename tegra20 clock file
      ARM: tegra20: Separate out clk ops and clk data
      ARM: tegra30: Separate out clk ops and clk data
      ARM: tegra: fix U16 divider range check
      ...
      + sync to v3.6-rc4
    
    Resolved remove/modify conflict in arch/arm/mach-sa1100/leds-hackkit.c
    caused by the sync with v3.6-rc4.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 2c88543b953581f70f05bf133a1b8f196c48ef23
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Sep 6 09:07:27 2012 +0100

    ARM: 7515/1: integrator: check PL010 base address from resource
    
    In the PL010 UART callback a comparison against the location of the
    statically allocated PL010 device is done to figure out which UART
    is doing the callback. This does not play well with dynamic devices
    such as in device tree, so let's check the base address of the
    memory resource inside the amba_device instead.
    
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 5ba4bc8c0aa3..268eadf6d3e6 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -99,11 +99,14 @@ int __init integrator_init(bool is_cp)
 static void integrator_uart_set_mctrl(struct amba_device *dev, void __iomem *base, unsigned int mctrl)
 {
 	unsigned int ctrls = 0, ctrlc = 0, rts_mask, dtr_mask;
+	u32 phybase = dev->res.start;
 
-	if (dev == &uart0_device) {
+	if (phybase == INTEGRATOR_UART0_BASE) {
+		/* UART0 */
 		rts_mask = 1 << 4;
 		dtr_mask = 1 << 5;
 	} else {
+		/* UART1 */
 		rts_mask = 1 << 6;
 		dtr_mask = 1 << 7;
 	}

commit 9bf26a180578b92890ed77890d4e9e9807adcda3
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Sep 6 09:06:52 2012 +0100

    ARM: 7514/1: integrator: call common init function from machine
    
    There is currently a common integrator_init() function set up
    to be called from an arch_initcall(). The problem is that it is
    using machine_is_integrator() which is not working with device
    tree, let's call this from respective machine initilization
    function and add a parameter to tell whether it's the
    Integrator/AP or Integrator/CP instead.
    
    There are still machine_is*() calls in the Integrator
    machines directory, but this one needs to be fixed lest we
    don't even get a UART console on the Integrator/AP after a
    Device Tree boot.
    
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 3fa6c51390da..5ba4bc8c0aa3 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -61,7 +61,7 @@ static struct amba_device *amba_devs[] __initdata = {
 	&kmi1_device,
 };
 
-static int __init integrator_init(void)
+int __init integrator_init(bool is_cp)
 {
 	int i;
 
@@ -70,7 +70,7 @@ static int __init integrator_init(void)
 	 * hard-code them. The Integator/CP and forward have proper cell IDs.
 	 * Else we leave them undefined to the bus driver can autoprobe them.
 	 */
-	if (machine_is_integrator()) {
+	if (!is_cp) {
 		rtc_device.periphid	= 0x00041030;
 		uart0_device.periphid	= 0x00041010;
 		uart1_device.periphid	= 0x00041010;
@@ -86,8 +86,6 @@ static int __init integrator_init(void)
 	return 0;
 }
 
-arch_initcall(integrator_init);
-
 /*
  * On the Integrator platform, the port RTS and DTR are provided by
  * bits in the following SC_CTRLS register bits:

commit 19e4ab54e7f5fe46a3c931afa7e786f11d57b558
Merge: 0d7614f09c1e fa8bbb13ab49
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Aug 13 16:45:48 2012 +0200

    Merge branch 'for-arm-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/cooloney/linux-leds into next/drivers
    
    From Bryan Wu <bryan.wu@canonical.com>:
    
    Based on Linus Walleij's ARM LED consolidation work, this patchset introduce a
    new generic led trigger for CPU not only for ARM but also for others.
    
    For enabling CPU idle event, CPU arch code should call ledtrig_cpu() stub to
    trigger idle start or idle end event.
    
    These patches convert old style LED driver in arch/arm to gpio_led or new led
    driver interface. Against 3.5 release and build successfully for all the machines.
    
    Test ledtrig-cpu driver on OMAP4 Panda board.
    
    v9 --> v10
     * fix compiling issue on versatile_defconfig reported by Russell King
     * rebase to 3.5 kernel and move patches to new git tree
    
    v8 --> v9:
     * use mutex to replace rw_sema pointed out by Tim Gardner
     * add a new struct led_trigger_cpu
     * add lock_is_inited to record mutex lock initialization
    
    v6 --> v7:
     * add a patch to unify the led-trigger name
     * fix some typo pointed
     * use BUG_ON to detect CPU numbers during building stage
    
    v5 --> v6:
     * replace  __get_cpu_var() to per_cpu()
     * remove smp_processor_id() which is wrong with for_each_possible_cpu()
     * test on real OMAP4 Panda board
     * add comments about CPU hotplug in the CPU LED trigger driver
    
    v4 --> v5:
     * rebase all the patches on top of latest linux-next
     * replace on_each_cpu() with for_each_possible_cpu()
     * add some description of ledtrig_cpu() API
     * remove old leds code from driver nwflash.c, which should use a new led trigger then
     * this trigger driver can be built as module now
    
    v3 --> v4:
     * fix a typo pointed by Jochen Friedrich
     * fix some building errors
     * add Reviewed-by and Tested-by into patch log
    
    v2 --> v3:
     * almost rewrote the whole ledtrig-cpu driver, which is more simple
     * every CPU will have a per-CPU trigger
     * cpu trigger can be assigned to any leds
     * fix a lockdep issue in led-trigger common code
     * other fix according to review
    
    v1 --> v2:
     * remove select operations in Kconfig of every machines
     * add back supporting of led in core module of mach-integrator
     * solidate name scheme in ledtrig-cpu.c
     * add comments of CPU_LED_* cpu led events
     * fold patches of RealView and Versatile together
     * add machine_is_ check during assabet led driver init
     * add some Acked-by in patch logs
     * remove code for simpad machine in machine-sa11000, since Jochen Friedrich
       introduced gpiolib and gpio-led driver for simpad
     * on Assabet and Netwinder machine, LED operations is reversed like:
       setting bit means turn off leds
       clearing bit means turn on leds
     * add a new function to read CM_CTRL register for led driver
    
    * 'for-arm-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/cooloney/linux-leds:
      ARM: use new LEDS CPU trigger stub to replace old one
      ARM: mach-sa1100: retire custom LED code
      ARM: mach-omap1: retire custom LED code
      ARM: mach-pnx4008: remove including old leds event API header file
      ARM: plat-samsung: remove including old leds event API header file
      ARM: mach-pxa: retire custom LED code
      char: nwflash: remove old led event code
      ARM: mach-footbridge: retire custom LED code
      ARM: mach-ebsa110: retire custom LED code
      ARM: mach-clps711x: retire custom LED code of P720T machine
      ARM: mach-integrator: retire custom LED code
      ARM: mach-integrator: move CM_CTRL to header file for accessing by other functions
      ARM: mach-orion5x: convert custom LED code to gpio_led and LED CPU trigger
      ARM: mach-shark: retire custom LED code
      ARM: mach-ks8695: remove leds driver, since nobody use it
      ARM: mach-realview and mach-versatile: retire custom LED code
      ARM: at91: convert old leds drivers to gpio_led and led_trigger drivers
      led-triggers: create a trigger for CPU activity
    
    Conflicts:
            arch/arm/mach-clps711x/p720t.c
            arch/arm/mach-sa1100/leds-cerf.c
            arch/arm/mach-sa1100/leds-lart.c
    
    Let's hope this is the last time we pull this and it doesn't cause
    more trouble. I have verified that version 10 causes no build
    warnings or errors any more, and the patches still look good.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit b434f5c95d2d9318482fda3af615ebcda7e2c0da
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Aug 4 10:31:24 2012 +0000

    ARM: integrator: include <linux/export.h>
    
    Without this patch, building integrator_defconfig results in:
    
    arch/arm/mach-integrator/core.c:150:1: warning: data definition has no type or storage class [enabled by default]
    arch/arm/mach-integrator/core.c:150:1: warning: type defaults to 'int' in declaration of 'EXPORT_SYMBOL' [-Wimplicit-int]
    arch/arm/mach-integrator/core.c:150:1: warning: parameter names (without types) in function declaration [enabled by default]
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Russell King <linux@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index ebf680bebdf2..3fa6c51390da 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -11,6 +11,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/device.h>
+#include <linux/export.h>
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>

commit 95f4965cf8a7cb7cdd987359cf48162f37bdd2d3
Author: Bryan Wu <bryan.wu@canonical.com>
Date:   Wed Mar 14 01:50:00 2012 +0800

    ARM: mach-integrator: retire custom LED code
    
    Use the LED in core module for CPU activity and also enable 4
    debugging LEDs in baseboard.
    
    The CPU activity LED is now handled by the trigger in the leds
    subsystem, retire this old CONFIG_LEDS-based code.
    
    Signed-off-by: Bryan Wu <bryan.wu@canonical.com>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 8c5356255a59..0c7c4ef0f7c1 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -28,7 +28,6 @@
 #include <mach/cm.h>
 #include <mach/irqs.h>
 
-#include <asm/leds.h>
 #include <asm/mach-types.h>
 #include <asm/mach/time.h>
 #include <asm/pgtable.h>

commit b7ea032e8ab5ac1eb667ae7566ceffc33f910259
Author: Bryan Wu <bryan.wu@canonical.com>
Date:   Wed Mar 14 01:46:50 2012 +0800

    ARM: mach-integrator: move CM_CTRL to header file for accessing by other functions
    
    Signed-off-by: Bryan Wu <bryan.wu@canonical.com>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index eaf6c6366ffa..8c5356255a59 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -172,8 +172,6 @@ static struct amba_pl010_data integrator_uart_data = {
 	.set_mctrl = integrator_uart_set_mctrl,
 };
 
-#define CM_CTRL	IO_ADDRESS(INTEGRATOR_HDR_CTRL)
-
 static DEFINE_RAW_SPINLOCK(cm_lock);
 
 /**

commit a613163dff04cbfcb7d66b06ef4a5f65498ee59b
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Jun 11 17:33:12 2012 +0200

    ARM: integrator: convert to common clock
    
    This converts the Integrator platform to use common clock
    and the ICST driver. Since from this point not all ARM
    reference platforms use the clock, we define
    CONFIG_PLAT_VERSATILE_CLOCK and select it for all platforms
    except the Integrator.
    
    Open issue: I could not use the .init_early() field of the
    machine descriptor to initialize the clocks, but had to
    move them to .init_irq(), so presumably .init_early() is
    so early that common clock is not up, and .init_machine()
    is too late since it's needed for the clockevent/clocksource
    initialization. Any suggestions on how to solve this is
    very welcome.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    [mturquette@linaro.org: use 'select' instead of versatile Kconfig]
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 2a20bba246fb..ebf680bebdf2 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -21,7 +21,6 @@
 #include <linux/amba/bus.h>
 #include <linux/amba/serial.h>
 #include <linux/io.h>
-#include <linux/clkdev.h>
 
 #include <mach/hardware.h>
 #include <mach/platform.h>
@@ -61,50 +60,6 @@ static struct amba_device *amba_devs[] __initdata = {
 	&kmi1_device,
 };
 
-/*
- * These are fixed clocks.
- */
-static struct clk clk24mhz = {
-	.rate	= 24000000,
-};
-
-static struct clk uartclk = {
-	.rate	= 14745600,
-};
-
-static struct clk dummy_apb_pclk;
-
-static struct clk_lookup lookups[] = {
-	{	/* Bus clock */
-		.con_id		= "apb_pclk",
-		.clk		= &dummy_apb_pclk,
-	}, {
-		/* Integrator/AP timer frequency */
-		.dev_id		= "ap_timer",
-		.clk		= &clk24mhz,
-	}, {	/* UART0 */
-		.dev_id		= "uart0",
-		.clk		= &uartclk,
-	}, {	/* UART1 */
-		.dev_id		= "uart1",
-		.clk		= &uartclk,
-	}, {	/* KMI0 */
-		.dev_id		= "kmi0",
-		.clk		= &clk24mhz,
-	}, {	/* KMI1 */
-		.dev_id		= "kmi1",
-		.clk		= &clk24mhz,
-	}, {	/* MMCI - IntegratorCP */
-		.dev_id		= "mmci",
-		.clk		= &uartclk,
-	}
-};
-
-void __init integrator_init_early(void)
-{
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-}
-
 static int __init integrator_init(void)
 {
 	int i;

commit d59fdcfc63a2d15b11dde10a85233b95cee0ad2e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Jun 11 00:14:15 2012 +0200

    ARM: integrator: put symbolic bus names on devices
    
    All the Integrator devices have bus names like "mb:16" which
    I think means "memory base 0x16000000" which is where the
    UART0 is. So let's call it "uart0" because that's what most
    platforms do these days.
    
    Change this everywhere for the integrator as we prepare for
    some core clock code movement.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index eaf6c6366ffa..2a20bba246fb 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -41,17 +41,17 @@ static struct amba_pl010_data integrator_uart_data;
 #define KMI0_IRQ		{ IRQ_KMIINT0 }
 #define KMI1_IRQ		{ IRQ_KMIINT1 }
 
-static AMBA_APB_DEVICE(rtc, "mb:15", 0,
+static AMBA_APB_DEVICE(rtc, "rtc", 0,
 	INTEGRATOR_RTC_BASE, INTEGRATOR_RTC_IRQ, NULL);
 
-static AMBA_APB_DEVICE(uart0, "mb:16", 0,
+static AMBA_APB_DEVICE(uart0, "uart0", 0,
 	INTEGRATOR_UART0_BASE, INTEGRATOR_UART0_IRQ, &integrator_uart_data);
 
-static AMBA_APB_DEVICE(uart1, "mb:17", 0,
+static AMBA_APB_DEVICE(uart1, "uart1", 0,
 	INTEGRATOR_UART1_BASE, INTEGRATOR_UART1_IRQ, &integrator_uart_data);
 
-static AMBA_APB_DEVICE(kmi0, "mb:18", 0, KMI0_BASE, KMI0_IRQ, NULL);
-static AMBA_APB_DEVICE(kmi1, "mb:19", 0, KMI1_BASE, KMI1_IRQ, NULL);
+static AMBA_APB_DEVICE(kmi0, "kmi0", 0, KMI0_BASE, KMI0_IRQ, NULL);
+static AMBA_APB_DEVICE(kmi1, "kmi1", 0, KMI1_BASE, KMI1_IRQ, NULL);
 
 static struct amba_device *amba_devs[] __initdata = {
 	&rtc_device,
@@ -83,19 +83,19 @@ static struct clk_lookup lookups[] = {
 		.dev_id		= "ap_timer",
 		.clk		= &clk24mhz,
 	}, {	/* UART0 */
-		.dev_id		= "mb:16",
+		.dev_id		= "uart0",
 		.clk		= &uartclk,
 	}, {	/* UART1 */
-		.dev_id		= "mb:17",
+		.dev_id		= "uart1",
 		.clk		= &uartclk,
 	}, {	/* KMI0 */
-		.dev_id		= "mb:18",
+		.dev_id		= "kmi0",
 		.clk		= &clk24mhz,
 	}, {	/* KMI1 */
-		.dev_id		= "mb:19",
+		.dev_id		= "kmi1",
 		.clk		= &clk24mhz,
 	}, {	/* MMCI - IntegratorCP */
-		.dev_id		= "mb:1c",
+		.dev_id		= "mmci",
 		.clk		= &uartclk,
 	}
 };

commit 12679a2d7e3bfbdc7586e3e86d1ca90c46659363
Merge: 1c036588772d b0df89868006
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 29 16:53:48 2012 -0700

    Merge branch 'for-linus' of git://git.linaro.org/people/rmk/linux-arm
    
    Pull more ARM updates from Russell King.
    
    This got a fair number of conflicts with the <asm/system.h> split, but
    also with some other sparse-irq and header file include cleanups.  They
    all looked pretty trivial, though.
    
    * 'for-linus' of git://git.linaro.org/people/rmk/linux-arm: (59 commits)
      ARM: fix Kconfig warning for HAVE_BPF_JIT
      ARM: 7361/1: provide XIP_VIRT_ADDR for no-MMU builds
      ARM: 7349/1: integrator: convert to sparse irqs
      ARM: 7259/3: net: JIT compiler for packet filters
      ARM: 7334/1: add jump label support
      ARM: 7333/2: jump label: detect %c support for ARM
      ARM: 7338/1: add support for early console output via semihosting
      ARM: use set_current_blocked() and block_sigmask()
      ARM: exec: remove redundant set_fs(USER_DS)
      ARM: 7332/1: extract out code patch function from kprobes
      ARM: 7331/1: extract out insn generation code from ftrace
      ARM: 7330/1: ftrace: use canonical Thumb-2 wide instruction format
      ARM: 7351/1: ftrace: remove useless memory checks
      ARM: 7316/1: kexec: EOI active and mask all interrupts in kexec crash path
      ARM: Versatile Express: add NO_IOPORT
      ARM: get rid of asm/irq.h in asm/prom.h
      ARM: 7319/1: Print debug info for SIGBUS in user faults
      ARM: 7318/1: gic: refactor irq_start assignment
      ARM: 7317/1: irq: avoid NULL check in for_each_irq_desc loop
      ARM: 7315/1: perf: add support for the Cortex-A7 PMU
      ...

commit 0195c00244dc2e9f522475868fa278c473ba7339
Merge: f21ce8f8447c 141124c02059
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 28 15:58:21 2012 -0700

    Merge tag 'split-asm_system_h-for-linus-20120328' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-asm_system
    
    Pull "Disintegrate and delete asm/system.h" from David Howells:
     "Here are a bunch of patches to disintegrate asm/system.h into a set of
      separate bits to relieve the problem of circular inclusion
      dependencies.
    
      I've built all the working defconfigs from all the arches that I can
      and made sure that they don't break.
    
      The reason for these patches is that I recently encountered a circular
      dependency problem that came about when I produced some patches to
      optimise get_order() by rewriting it to use ilog2().
    
      This uses bitops - and on the SH arch asm/bitops.h drags in
      asm-generic/get_order.h by a circuituous route involving asm/system.h.
    
      The main difficulty seems to be asm/system.h.  It holds a number of
      low level bits with no/few dependencies that are commonly used (eg.
      memory barriers) and a number of bits with more dependencies that
      aren't used in many places (eg.  switch_to()).
    
      These patches break asm/system.h up into the following core pieces:
    
        (1) asm/barrier.h
    
            Move memory barriers here.  This already done for MIPS and Alpha.
    
        (2) asm/switch_to.h
    
            Move switch_to() and related stuff here.
    
        (3) asm/exec.h
    
            Move arch_align_stack() here.  Other process execution related bits
            could perhaps go here from asm/processor.h.
    
        (4) asm/cmpxchg.h
    
            Move xchg() and cmpxchg() here as they're full word atomic ops and
            frequently used by atomic_xchg() and atomic_cmpxchg().
    
        (5) asm/bug.h
    
            Move die() and related bits.
    
        (6) asm/auxvec.h
    
            Move AT_VECTOR_SIZE_ARCH here.
    
      Other arch headers are created as needed on a per-arch basis."
    
    Fixed up some conflicts from other header file cleanups and moving code
    around that has happened in the meantime, so David's testing is somewhat
    weakened by that.  We'll find out anything that got broken and fix it..
    
    * tag 'split-asm_system_h-for-linus-20120328' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-asm_system: (38 commits)
      Delete all instances of asm/system.h
      Remove all #inclusions of asm/system.h
      Add #includes needed to permit the removal of asm/system.h
      Move all declarations of free_initmem() to linux/mm.h
      Disintegrate asm/system.h for OpenRISC
      Split arch_align_stack() out from asm-generic/system.h
      Split the switch_to() wrapper out of asm-generic/system.h
      Move the asm-generic/system.h xchg() implementation to asm-generic/cmpxchg.h
      Create asm-generic/barrier.h
      Make asm-generic/cmpxchg.h #include asm-generic/cmpxchg-local.h
      Disintegrate asm/system.h for Xtensa
      Disintegrate asm/system.h for Unicore32 [based on ver #3, changed by gxt]
      Disintegrate asm/system.h for Tile
      Disintegrate asm/system.h for Sparc
      Disintegrate asm/system.h for SH
      Disintegrate asm/system.h for Score
      Disintegrate asm/system.h for S390
      Disintegrate asm/system.h for PowerPC
      Disintegrate asm/system.h for PA-RISC
      Disintegrate asm/system.h for MN10300
      ...

commit 9f97da78bf018206fb623cd351d454af2f105fe0
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:01 2012 +0100

    Disintegrate asm/system.h for ARM
    
    Disintegrate asm/system.h for ARM.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Russell King <linux@arm.linux.org.uk>
    cc: linux-arm-kernel@lists.infradead.org

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 019f0ab08f66..d2fd9f33e6f1 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -27,7 +27,6 @@
 #include <mach/platform.h>
 #include <asm/irq.h>
 #include <mach/cm.h>
-#include <asm/system.h>
 #include <asm/leds.h>
 #include <asm/mach-types.h>
 #include <asm/mach/time.h>

commit b0df89868006517417251e02cc4ce5d4b0165885
Merge: 4ba21e868f4b 6c634726352f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Mar 27 11:30:31 2012 +0100

    Merge branch 'devel-stable' into for-linus
    
    Conflicts:
            arch/arm/Kconfig.debug
            arch/arm/plat-versatile/Kconfig
    Merge fixes:
            arch/arm/mach-integrator/Kconfig
            drivers/clocksource/Kconfig

commit 695436e3738ec6375a4a1026034d14433be3fb3a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sun Feb 26 10:46:48 2012 +0100

    ARM: 7349/1: integrator: convert to sparse irqs
    
    This converts the Integrator AP/CP to use sparse IRQs.
    Tested on both machines.
    
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 019f0ab08f66..cba1907c2e1c 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -25,8 +25,9 @@
 
 #include <mach/hardware.h>
 #include <mach/platform.h>
-#include <asm/irq.h>
 #include <mach/cm.h>
+#include <mach/irqs.h>
+
 #include <asm/system.h>
 #include <asm/leds.h>
 #include <asm/mach-types.h>

commit 2f64ccd9e0eb5686056f44ffaf5d33c7e9733972
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Dec 18 14:50:51 2011 +0000

    ARM: amba: integrator: use common amba device initializers
    
    Tested-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 29baef9d8f76..15b87f26ac96 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -35,67 +35,23 @@
 
 static struct amba_pl010_data integrator_uart_data;
 
-static struct amba_device rtc_device = {
-	.dev		= {
-		.init_name = "mb:15",
-	},
-	.res		= {
-		.start	= INTEGRATOR_RTC_BASE,
-		.end	= INTEGRATOR_RTC_BASE + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	.irq		= { IRQ_RTCINT },
-};
+#define INTEGRATOR_RTC_IRQ	{ IRQ_RTCINT }
+#define INTEGRATOR_UART0_IRQ	{ IRQ_UARTINT0 }
+#define INTEGRATOR_UART1_IRQ	{ IRQ_UARTINT1 }
+#define KMI0_IRQ		{ IRQ_KMIINT0 }
+#define KMI1_IRQ		{ IRQ_KMIINT1 }
 
-static struct amba_device uart0_device = {
-	.dev		= {
-		.init_name = "mb:16",
-		.platform_data = &integrator_uart_data,
-	},
-	.res		= {
-		.start	= INTEGRATOR_UART0_BASE,
-		.end	= INTEGRATOR_UART0_BASE + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	.irq		= { IRQ_UARTINT0 },
-};
+static AMBA_APB_DEVICE(rtc, "mb:15", 0,
+	INTEGRATOR_RTC_BASE, INTEGRATOR_RTC_IRQ, NULL);
 
-static struct amba_device uart1_device = {
-	.dev		= {
-		.init_name = "mb:17",
-		.platform_data = &integrator_uart_data,
-	},
-	.res		= {
-		.start	= INTEGRATOR_UART1_BASE,
-		.end	= INTEGRATOR_UART1_BASE + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	.irq		= { IRQ_UARTINT1 },
-};
+static AMBA_APB_DEVICE(uart0, "mb:16", 0,
+	INTEGRATOR_UART0_BASE, INTEGRATOR_UART0_IRQ, &integrator_uart_data);
 
-static struct amba_device kmi0_device = {
-	.dev		= {
-		.init_name = "mb:18",
-	},
-	.res		= {
-		.start	= KMI0_BASE,
-		.end	= KMI0_BASE + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	.irq		= { IRQ_KMIINT0 },
-};
+static AMBA_APB_DEVICE(uart1, "mb:17", 0,
+	INTEGRATOR_UART1_BASE, INTEGRATOR_UART1_IRQ, &integrator_uart_data);
 
-static struct amba_device kmi1_device = {
-	.dev		= {
-		.init_name = "mb:19",
-	},
-	.res		= {
-		.start	= KMI1_BASE,
-		.end	= KMI1_BASE + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	.irq		= { IRQ_KMIINT1 },
-};
+static AMBA_APB_DEVICE(kmi0, "mb:18", 0, KMI0_BASE, KMI0_IRQ, NULL);
+static AMBA_APB_DEVICE(kmi1, "mb:19", 0, KMI1_BASE, KMI1_IRQ, NULL);
 
 static struct amba_device *amba_devs[] __initdata = {
 	&rtc_device,

commit 0dada61a29ddaaca5985c76aafec341b4ad3e989
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Dec 18 11:40:46 2011 +0000

    ARM: amba: integrator/realview/versatile/vexpress: get rid of NO_IRQ initializers
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 019f0ab08f66..29baef9d8f76 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -44,7 +44,7 @@ static struct amba_device rtc_device = {
 		.end	= INTEGRATOR_RTC_BASE + SZ_4K - 1,
 		.flags	= IORESOURCE_MEM,
 	},
-	.irq		= { IRQ_RTCINT, NO_IRQ },
+	.irq		= { IRQ_RTCINT },
 };
 
 static struct amba_device uart0_device = {
@@ -57,7 +57,7 @@ static struct amba_device uart0_device = {
 		.end	= INTEGRATOR_UART0_BASE + SZ_4K - 1,
 		.flags	= IORESOURCE_MEM,
 	},
-	.irq		= { IRQ_UARTINT0, NO_IRQ },
+	.irq		= { IRQ_UARTINT0 },
 };
 
 static struct amba_device uart1_device = {
@@ -70,7 +70,7 @@ static struct amba_device uart1_device = {
 		.end	= INTEGRATOR_UART1_BASE + SZ_4K - 1,
 		.flags	= IORESOURCE_MEM,
 	},
-	.irq		= { IRQ_UARTINT1, NO_IRQ },
+	.irq		= { IRQ_UARTINT1 },
 };
 
 static struct amba_device kmi0_device = {
@@ -82,7 +82,7 @@ static struct amba_device kmi0_device = {
 		.end	= KMI0_BASE + SZ_4K - 1,
 		.flags	= IORESOURCE_MEM,
 	},
-	.irq		= { IRQ_KMIINT0, NO_IRQ },
+	.irq		= { IRQ_KMIINT0 },
 };
 
 static struct amba_device kmi1_device = {
@@ -94,7 +94,7 @@ static struct amba_device kmi1_device = {
 		.end	= KMI1_BASE + SZ_4K - 1,
 		.flags	= IORESOURCE_MEM,
 	},
-	.irq		= { IRQ_KMIINT1, NO_IRQ },
+	.irq		= { IRQ_KMIINT1 },
 };
 
 static struct amba_device *amba_devs[] __initdata = {

commit 7b9dd47136c07ffd883aff6926c7b281e4c1eea4
Merge: 2e0e94343691 0575fb754dbf
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jan 5 13:25:15 2012 +0000

    Merge branch 'restart' into for-linus
    
    Conflicts:
            arch/arm/mach-exynos/cpu.c
    
    The changes to arch/arm/mach-exynos/cpu.c were moved to
    mach-exynos/common.c.

commit 6338b66f8a8c5bc8ff8671acbfdda02756e92c0a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Nov 3 19:54:37 2011 +0000

    ARM: restart: integrator: use new restart hook
    
    Hook these platforms restart code into the new restart hook rather
    than using arch_reset().
    
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 4b38e13667ac..0a3e0974398a 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -238,3 +238,11 @@ void __init integrator_reserve(void)
 {
 	memblock_reserve(PHYS_OFFSET, __pa(swapper_pg_dir) - PHYS_OFFSET);
 }
+
+/*
+ * To reset, we hit the on-board reset register in the system FPGA
+ */
+void integrator_restart(char mode, const char *cmd)
+{
+	cm_control(CM_CTRL_RESET, CM_CTRL_RESET);
+}

commit ee35887e4acad8cb6b09c99e4d6a67ef7635f2fc
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Dec 20 11:55:19 2011 +0100

    ARM: 7238/1: integrator: only hardcode AP PrimeCell IDs
    
    We don't need to hardcode the peripheral IDs for the Integrator/CP,
    the numbers found in the hardware are correct anyway.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 4b38e13667ac..18584beda536 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -29,6 +29,7 @@
 #include <mach/cm.h>
 #include <asm/system.h>
 #include <asm/leds.h>
+#include <asm/mach-types.h>
 #include <asm/mach/time.h>
 #include <asm/pgtable.h>
 
@@ -44,7 +45,6 @@ static struct amba_device rtc_device = {
 		.flags	= IORESOURCE_MEM,
 	},
 	.irq		= { IRQ_RTCINT, NO_IRQ },
-	.periphid	= 0x00041030,
 };
 
 static struct amba_device uart0_device = {
@@ -58,7 +58,6 @@ static struct amba_device uart0_device = {
 		.flags	= IORESOURCE_MEM,
 	},
 	.irq		= { IRQ_UARTINT0, NO_IRQ },
-	.periphid	= 0x0041010,
 };
 
 static struct amba_device uart1_device = {
@@ -72,7 +71,6 @@ static struct amba_device uart1_device = {
 		.flags	= IORESOURCE_MEM,
 	},
 	.irq		= { IRQ_UARTINT1, NO_IRQ },
-	.periphid	= 0x0041010,
 };
 
 static struct amba_device kmi0_device = {
@@ -85,7 +83,6 @@ static struct amba_device kmi0_device = {
 		.flags	= IORESOURCE_MEM,
 	},
 	.irq		= { IRQ_KMIINT0, NO_IRQ },
-	.periphid	= 0x00041050,
 };
 
 static struct amba_device kmi1_device = {
@@ -98,7 +95,6 @@ static struct amba_device kmi1_device = {
 		.flags	= IORESOURCE_MEM,
 	},
 	.irq		= { IRQ_KMIINT1, NO_IRQ },
-	.periphid	= 0x00041050,
 };
 
 static struct amba_device *amba_devs[] __initdata = {
@@ -157,6 +153,19 @@ static int __init integrator_init(void)
 {
 	int i;
 
+	/*
+	 * The Integrator/AP lacks necessary AMBA PrimeCell IDs, so we need to
+	 * hard-code them. The Integator/CP and forward have proper cell IDs.
+	 * Else we leave them undefined to the bus driver can autoprobe them.
+	 */
+	if (machine_is_integrator()) {
+		rtc_device.periphid	= 0x00041030;
+		uart0_device.periphid	= 0x00041010;
+		uart1_device.periphid	= 0x00041010;
+		kmi0_device.periphid	= 0x00041050;
+		kmi1_device.periphid	= 0x00041050;
+	}
+
 	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
 		struct amba_device *d = amba_devs[i];
 		amba_device_register(d, &iomem_resource);

commit 3cfef9524677a4ecb392d6fbffe6ebce6302f1d4
Merge: 982653009b88 68cc3990a545
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 26 16:17:32 2011 +0200

    Merge branch 'core-locking-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    * 'core-locking-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (27 commits)
      rtmutex: Add missing rcu_read_unlock() in debug_rt_mutex_print_deadlock()
      lockdep: Comment all warnings
      lib: atomic64: Change the type of local lock to raw_spinlock_t
      locking, lib/atomic64: Annotate atomic64_lock::lock as raw
      locking, x86, iommu: Annotate qi->q_lock as raw
      locking, x86, iommu: Annotate irq_2_ir_lock as raw
      locking, x86, iommu: Annotate iommu->register_lock as raw
      locking, dma, ipu: Annotate bank_lock as raw
      locking, ARM: Annotate low level hw locks as raw
      locking, drivers/dca: Annotate dca_lock as raw
      locking, powerpc: Annotate uic->lock as raw
      locking, x86: mce: Annotate cmci_discover_lock as raw
      locking, ACPI: Annotate c3_lock as raw
      locking, oprofile: Annotate oprofilefs lock as raw
      locking, video: Annotate vga console lock as raw
      locking, latencytop: Annotate latency_lock as raw
      locking, timer_stats: Annotate table_lock as raw
      locking, rwsem: Annotate inner lock as raw
      locking, semaphores: Annotate inner lock as raw
      locking, sched: Annotate thread_group_cputimer as raw
      ...
    
    Fix up conflicts in kernel/posix-cpu-timers.c manually: making
    cputimer->cputime a raw lock conflicted with the ABBA fix in commit
    bcd5cff7216f ("cputimer: Cure lock inversion").

commit bb76079a7859fb33a23bef405517b6b653d9f649
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Sep 8 21:23:15 2011 +0100

    ARM: 7087/2: mach-integrator: get timer frequency from clock
    
    We already have a clock definition for the 24MHz clock in
    the Integrator, use that instead of some unclear defines
    from the platform.h header. Also delete the senseless
    comment that the file shouldn't be edited, I just edited it
    and the world didn't come to an end, so it's obviously
    false. If anyone still has the mentioned ".s file" and the
    s2h awk script generating that header, raise your hand
    (and give me your files).
    
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 77315b995681..82ebc8d772d3 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -126,6 +126,10 @@ static struct clk_lookup lookups[] = {
 	{	/* Bus clock */
 		.con_id		= "apb_pclk",
 		.clk		= &dummy_apb_pclk,
+	}, {
+		/* Integrator/AP timer frequency */
+		.dev_id		= "ap_timer",
+		.clk		= &clk24mhz,
 	}, {	/* UART0 */
 		.dev_id		= "mb:16",
 		.clk		= &uartclk,

commit bd31b85960a7fcb2d7ede216460b8da71a88411c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 3 08:44:46 2009 -0500

    locking, ARM: Annotate low level hw locks as raw
    
    Annotate the low level hardware locks which must not be preempted.
    
    In mainline this change documents the low level nature of
    the lock - otherwise there's no functional difference. Lockdep
    and Sparse checking will work as usual.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 77315b995681..0c20cf638575 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -205,7 +205,7 @@ static struct amba_pl010_data integrator_uart_data = {
 
 #define CM_CTRL	IO_ADDRESS(INTEGRATOR_HDR_CTRL)
 
-static DEFINE_SPINLOCK(cm_lock);
+static DEFINE_RAW_SPINLOCK(cm_lock);
 
 /**
  * cm_control - update the CM_CTRL register.
@@ -217,10 +217,10 @@ void cm_control(u32 mask, u32 set)
 	unsigned long flags;
 	u32 val;
 
-	spin_lock_irqsave(&cm_lock, flags);
+	raw_spin_lock_irqsave(&cm_lock, flags);
 	val = readl(CM_CTRL) & ~mask;
 	writel(val | set, CM_CTRL);
-	spin_unlock_irqrestore(&cm_lock, flags);
+	raw_spin_unlock_irqrestore(&cm_lock, flags);
 }
 
 EXPORT_SYMBOL(cm_control);

commit c735c9873d0c2f269fd16f4b04903da41a44cbcf
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jan 11 13:00:04 2011 +0000

    ARM: integrator: use new init_early for clock tree init
    
    Initialize the clock tree early.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index b8e884b450da..77315b995681 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -144,12 +144,15 @@ static struct clk_lookup lookups[] = {
 	}
 };
 
+void __init integrator_init_early(void)
+{
+	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
+}
+
 static int __init integrator_init(void)
 {
 	int i;
 
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-
 	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
 		struct amba_device *d = amba_devs[i];
 		amba_device_register(d, &iomem_resource);

commit 6d803ba736abb5e122dede70a4720e4843dd6df4
Author: Jean-Christop PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Wed Nov 17 10:04:33 2010 +0100

    ARM: 6483/1: arm & sh: factorised duplicated clkdev.c
    
    factorise some generic infrastructure to assist looking up struct clks
    for the ARM & SH architecture.
    
    as the code is identical at 99%
    
    put the arch specific code for allocation as example in asm/clkdev.h
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 8f4fb6d638f7..b8e884b450da 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -21,9 +21,8 @@
 #include <linux/amba/bus.h>
 #include <linux/amba/serial.h>
 #include <linux/io.h>
+#include <linux/clkdev.h>
 
-#include <asm/clkdev.h>
-#include <mach/clkdev.h>
 #include <mach/hardware.h>
 #include <mach/platform.h>
 #include <asm/irq.h>

commit b31fc7af78e17b0203e1cd5a195c590e8adeae0d
Merge: f13b1035ce8b 4037242c4f5f a0fb007bf0c7 cea0bb1bc59b 7d63397574c8 a9deb137e4eb 39ae702cd3b8 f4f5e28d2ee0 7cfe249475fd 4bd48940190a a3e5bb42898d
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jul 31 14:19:35 2010 +0100

    Merge branches 'at91', 'ep93xx', 'kexec', 'iop', 'lmb', 'nomadik', 'nuc', 'pl', 'spear' and 'versatile' into devel

commit 8d717a52d1b0959128be5134dd12608e8e4f2115
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat May 22 19:47:18 2010 +0100

    ARM: Convert platform reservations to use LMB rather than bootmem
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index f815a1863f70..bcb26f01b26c 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -14,7 +14,7 @@
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
-#include <linux/bootmem.h>
+#include <linux/memblock.h>
 #include <linux/sched.h>
 #include <linux/smp.h>
 #include <linux/termios.h>
@@ -225,5 +225,5 @@ EXPORT_SYMBOL(cm_control);
  */
 void __init integrator_reserve(void)
 {
-	reserve_bootmem(PHYS_OFFSET, __pa(swapper_pg_dir) - PHYS_OFFSET, BOOTMEM_DEFAULT);
+	memblock_reserve(PHYS_OFFSET, __pa(swapper_pg_dir) - PHYS_OFFSET);
 }

commit 3126c7bc4106c572ef47e2c220df5a00e7973379
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jul 15 11:01:17 2010 +0100

    ARM: AMBA: Add pclk definition for platforms using primecells
    
    Add a dummy clk definition for the APB pclk signal on all platforms
    using the AMBA bus infrastructure.  This ensures that these platforms
    continue to work when the core amba bus code controls the APB pclk.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index b02cfc06e0ae..a04d38609839 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -119,8 +119,13 @@ static struct clk uartclk = {
 	.rate	= 14745600,
 };
 
+static struct clk dummy_apb_pclk;
+
 static struct clk_lookup lookups[] = {
-	{	/* UART0 */
+	{	/* Bus clock */
+		.con_id		= "apb_pclk",
+		.clk		= &dummy_apb_pclk,
+	}, {	/* UART0 */
 		.dev_id		= "mb:16",
 		.clk		= &uartclk,
 	}, {	/* UART1 */

commit 98c672cf1fa2a56f6f43e3f48b1208b83845582c
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat May 22 18:18:57 2010 +0100

    ARM: Move platform memory reservations out of generic code
    
    Move the platform specific bootmem memory reservations out of
    arch/arm/mm/mmu.c into their respective platform files.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index b02cfc06e0ae..f815a1863f70 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -14,6 +14,7 @@
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
+#include <linux/bootmem.h>
 #include <linux/sched.h>
 #include <linux/smp.h>
 #include <linux/termios.h>
@@ -30,6 +31,7 @@
 #include <asm/system.h>
 #include <asm/leds.h>
 #include <asm/mach/time.h>
+#include <asm/pgtable.h>
 
 static struct amba_pl010_data integrator_uart_data;
 
@@ -215,3 +217,13 @@ void cm_control(u32 mask, u32 set)
 }
 
 EXPORT_SYMBOL(cm_control);
+
+/*
+ * We need to stop things allocating the low memory; ideally we need a
+ * better implementation of GFP_DMA which does not assume that DMA-able
+ * memory starts at zero.
+ */
+void __init integrator_reserve(void)
+{
+	reserve_bootmem(PHYS_OFFSET, __pa(swapper_pg_dir) - PHYS_OFFSET, BOOTMEM_DEFAULT);
+}

commit 6be4826e37122b25cb10b215fc84c3a0b1fe1402
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Jan 17 16:20:56 2010 +0000

    ARM: Integrator: move 16-bit timer support to Integrator/AP
    
    Only Integrator/AP has 16-bit timers, so move the support into the
    Integrator/AP specific support files.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index ac2b0c5c991b..b02cfc06e0ae 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -19,8 +19,6 @@
 #include <linux/termios.h>
 #include <linux/amba/bus.h>
 #include <linux/amba/serial.h>
-#include <linux/clocksource.h>
-#include <linux/clockchips.h>
 #include <linux/io.h>
 
 #include <asm/clkdev.h>
@@ -28,14 +26,11 @@
 #include <mach/hardware.h>
 #include <mach/platform.h>
 #include <asm/irq.h>
-#include <asm/hardware/arm_timer.h>
 #include <mach/cm.h>
 #include <asm/system.h>
 #include <asm/leds.h>
 #include <asm/mach/time.h>
 
-#include "common.h"
-
 static struct amba_pl010_data integrator_uart_data;
 
 static struct amba_device rtc_device = {
@@ -220,155 +215,3 @@ void cm_control(u32 mask, u32 set)
 }
 
 EXPORT_SYMBOL(cm_control);
-
-/*
- * Where is the timer (VA)?
- */
-#define TIMER0_VA_BASE IO_ADDRESS(INTEGRATOR_TIMER0_BASE)
-#define TIMER1_VA_BASE IO_ADDRESS(INTEGRATOR_TIMER1_BASE)
-#define TIMER2_VA_BASE IO_ADDRESS(INTEGRATOR_TIMER2_BASE)
-
-/*
- * How long is the timer interval?
- */
-#define TIMER_INTERVAL	(TICKS_PER_uSEC * mSEC_10)
-#if TIMER_INTERVAL >= 0x100000
-#define TICKS2USECS(x)	(256 * (x) / TICKS_PER_uSEC)
-#elif TIMER_INTERVAL >= 0x10000
-#define TICKS2USECS(x)	(16 * (x) / TICKS_PER_uSEC)
-#else
-#define TICKS2USECS(x)	((x) / TICKS_PER_uSEC)
-#endif
-
-static unsigned long timer_reload;
-
-static void __iomem * const clksrc_base = (void __iomem *)TIMER2_VA_BASE;
-
-static cycle_t timersp_read(struct clocksource *cs)
-{
-	return ~(readl(clksrc_base + TIMER_VALUE) & 0xffff);
-}
-
-static struct clocksource clocksource_timersp = {
-	.name		= "timer2",
-	.rating		= 200,
-	.read		= timersp_read,
-	.mask		= CLOCKSOURCE_MASK(16),
-	.shift		= 16,
-	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
-};
-
-static void integrator_clocksource_init(u32 khz)
-{
-	struct clocksource *cs = &clocksource_timersp;
-	void __iomem *base = clksrc_base;
-	u32 ctrl = TIMER_CTRL_ENABLE;
-
-	if (khz >= 1500) {
-		khz /= 16;
-		ctrl = TIMER_CTRL_DIV16;
-	}
-
-	writel(ctrl, base + TIMER_CTRL);
-	writel(0xffff, base + TIMER_LOAD);
-
-	cs->mult = clocksource_khz2mult(khz, cs->shift);
-	clocksource_register(cs);
-}
-
-static void __iomem * const clkevt_base = (void __iomem *)TIMER1_VA_BASE;
-
-/*
- * IRQ handler for the timer
- */
-static irqreturn_t integrator_timer_interrupt(int irq, void *dev_id)
-{
-	struct clock_event_device *evt = dev_id;
-
-	/* clear the interrupt */
-	writel(1, clkevt_base + TIMER_INTCLR);
-
-	evt->event_handler(evt);
-
-	return IRQ_HANDLED;
-}
-
-static void clkevt_set_mode(enum clock_event_mode mode, struct clock_event_device *evt)
-{
-	u32 ctrl = readl(clkevt_base + TIMER_CTRL) & ~TIMER_CTRL_ENABLE;
-
-	BUG_ON(mode == CLOCK_EVT_MODE_ONESHOT);
-
-	if (mode == CLOCK_EVT_MODE_PERIODIC) {
-		writel(ctrl, clkevt_base + TIMER_CTRL);
-		writel(timer_reload, clkevt_base + TIMER_LOAD);
-		ctrl |= TIMER_CTRL_PERIODIC | TIMER_CTRL_ENABLE;
-	}
-
-	writel(ctrl, clkevt_base + TIMER_CTRL);
-}
-
-static int clkevt_set_next_event(unsigned long next, struct clock_event_device *evt)
-{
-	unsigned long ctrl = readl(clkevt_base + TIMER_CTRL);
-
-	writel(ctrl & ~TIMER_CTRL_ENABLE, clkevt_base + TIMER_CTRL);
-	writel(next, clkevt_base + TIMER_LOAD);
-	writel(ctrl | TIMER_CTRL_ENABLE, clkevt_base + TIMER_CTRL);
-
-	return 0;
-}
-
-static struct clock_event_device integrator_clockevent = {
-	.name		= "timer1",
-	.shift		= 34,
-	.features	= CLOCK_EVT_FEAT_PERIODIC,
-	.set_mode	= clkevt_set_mode,
-	.set_next_event	= clkevt_set_next_event,
-	.rating		= 300,
-	.cpumask	= cpu_all_mask,
-};
-
-static struct irqaction integrator_timer_irq = {
-	.name		= "timer",
-	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
-	.handler	= integrator_timer_interrupt,
-	.dev_id		= &integrator_clockevent,
-};
-
-static void integrator_clockevent_init(u32 khz, unsigned int ctrl)
-{
-	struct clock_event_device *evt = &integrator_clockevent;
-
-	if (khz * 1000 > 0x100000 * HZ) {
-		khz /= 256;
-		ctrl |= TIMER_CTRL_DIV256;
-	} else if (khz * 1000 > 0x10000 * HZ) {
-		khz /= 16;
-		ctrl |= TIMER_CTRL_DIV16;
-	}
-
-	timer_reload = khz * 1000 / HZ;
-	writel(ctrl, clkevt_base + TIMER_CTRL);
-
-	evt->irq = IRQ_TIMERINT1;
-	evt->mult = div_sc(khz, NSEC_PER_MSEC, evt->shift);
-	evt->max_delta_ns = clockevent_delta2ns(0xffff, evt);
-	evt->min_delta_ns = clockevent_delta2ns(0xf, evt);
-
-	setup_irq(IRQ_TIMERINT1, &integrator_timer_irq);
-	clockevents_register_device(evt);
-}
-
-/*
- * Set up timer(s).
- */
-void __init integrator_time_init(u32 khz, unsigned int ctrl)
-{
-	writel(0, TIMER0_VA_BASE + TIMER_CTRL);
-	writel(0, TIMER1_VA_BASE + TIMER_CTRL);
-	writel(0, TIMER2_VA_BASE + TIMER_CTRL);
-
-	integrator_clocksource_init(khz);
-	integrator_clockevent_init(khz, ctrl);
-}

commit b830b9b5b3d04bc22f0b9ded85b713f7d3c11b7f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Jan 17 20:45:12 2010 +0000

    ARM: Integrator: convert to use register definitions
    
    Rather than using converted base address plus offset, use the register
    address itself now that IO_ADDRESS() can cope with these.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index d02f0e3afdcb..ac2b0c5c991b 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -166,8 +166,8 @@ arch_initcall(integrator_init);
  *  UART0  7    6
  *  UART1  5    4
  */
-#define SC_CTRLC	(IO_ADDRESS(INTEGRATOR_SC_BASE) + INTEGRATOR_SC_CTRLC_OFFSET)
-#define SC_CTRLS	(IO_ADDRESS(INTEGRATOR_SC_BASE) + INTEGRATOR_SC_CTRLS_OFFSET)
+#define SC_CTRLC	IO_ADDRESS(INTEGRATOR_SC_CTRLC)
+#define SC_CTRLS	IO_ADDRESS(INTEGRATOR_SC_CTRLS)
 
 static void integrator_uart_set_mctrl(struct amba_device *dev, void __iomem *base, unsigned int mctrl)
 {
@@ -199,7 +199,7 @@ static struct amba_pl010_data integrator_uart_data = {
 	.set_mctrl = integrator_uart_set_mctrl,
 };
 
-#define CM_CTRL	IO_ADDRESS(INTEGRATOR_HDR_BASE) + INTEGRATOR_HDR_CTRL_OFFSET
+#define CM_CTRL	IO_ADDRESS(INTEGRATOR_HDR_CTRL)
 
 static DEFINE_SPINLOCK(cm_lock);
 
@@ -224,9 +224,9 @@ EXPORT_SYMBOL(cm_control);
 /*
  * Where is the timer (VA)?
  */
-#define TIMER0_VA_BASE (IO_ADDRESS(INTEGRATOR_CT_BASE)+0x00000000)
-#define TIMER1_VA_BASE (IO_ADDRESS(INTEGRATOR_CT_BASE)+0x00000100)
-#define TIMER2_VA_BASE (IO_ADDRESS(INTEGRATOR_CT_BASE)+0x00000200)
+#define TIMER0_VA_BASE IO_ADDRESS(INTEGRATOR_TIMER0_BASE)
+#define TIMER1_VA_BASE IO_ADDRESS(INTEGRATOR_TIMER1_BASE)
+#define TIMER2_VA_BASE IO_ADDRESS(INTEGRATOR_TIMER2_BASE)
 
 /*
  * How long is the timer interval?

commit 861248d177145fc5861507e4607fec89fd0a0462
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Jan 15 22:12:46 2010 +0000

    ARM: Integrator: pass 'khz' to integrator_time_init
    
    This is now what the clocksource/clockevent initialization functions
    want, so give them the timer tick rate directly.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index b1ccbe3f233f..d02f0e3afdcb 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -363,12 +363,12 @@ static void integrator_clockevent_init(u32 khz, unsigned int ctrl)
 /*
  * Set up timer(s).
  */
-void __init integrator_time_init(unsigned long reload, unsigned int ctrl)
+void __init integrator_time_init(u32 khz, unsigned int ctrl)
 {
 	writel(0, TIMER0_VA_BASE + TIMER_CTRL);
 	writel(0, TIMER1_VA_BASE + TIMER_CTRL);
 	writel(0, TIMER2_VA_BASE + TIMER_CTRL);
 
-	integrator_clocksource_init(reload * HZ / 1000);
-	integrator_clockevent_init(reload * HZ / 1000, ctrl);
+	integrator_clocksource_init(khz);
+	integrator_clockevent_init(khz, ctrl);
 }

commit 13edd86d7a8b64735c60c308faac785a6f2257b2
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Jan 15 21:49:23 2010 +0000

    ARM: Integrator: convert to generic clockevent support
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 87c6f980944d..b1ccbe3f233f 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -20,6 +20,7 @@
 #include <linux/amba/bus.h>
 #include <linux/amba/serial.h>
 #include <linux/clocksource.h>
+#include <linux/clockchips.h>
 #include <linux/io.h>
 
 #include <asm/clkdev.h>
@@ -275,61 +276,99 @@ static void integrator_clocksource_init(u32 khz)
 	clocksource_register(cs);
 }
 
+static void __iomem * const clkevt_base = (void __iomem *)TIMER1_VA_BASE;
+
 /*
  * IRQ handler for the timer
  */
-static irqreturn_t
-integrator_timer_interrupt(int irq, void *dev_id)
+static irqreturn_t integrator_timer_interrupt(int irq, void *dev_id)
 {
-	/*
-	 * clear the interrupt
-	 */
-	writel(1, TIMER1_VA_BASE + TIMER_INTCLR);
+	struct clock_event_device *evt = dev_id;
+
+	/* clear the interrupt */
+	writel(1, clkevt_base + TIMER_INTCLR);
 
-	timer_tick();
+	evt->event_handler(evt);
 
 	return IRQ_HANDLED;
 }
 
+static void clkevt_set_mode(enum clock_event_mode mode, struct clock_event_device *evt)
+{
+	u32 ctrl = readl(clkevt_base + TIMER_CTRL) & ~TIMER_CTRL_ENABLE;
+
+	BUG_ON(mode == CLOCK_EVT_MODE_ONESHOT);
+
+	if (mode == CLOCK_EVT_MODE_PERIODIC) {
+		writel(ctrl, clkevt_base + TIMER_CTRL);
+		writel(timer_reload, clkevt_base + TIMER_LOAD);
+		ctrl |= TIMER_CTRL_PERIODIC | TIMER_CTRL_ENABLE;
+	}
+
+	writel(ctrl, clkevt_base + TIMER_CTRL);
+}
+
+static int clkevt_set_next_event(unsigned long next, struct clock_event_device *evt)
+{
+	unsigned long ctrl = readl(clkevt_base + TIMER_CTRL);
+
+	writel(ctrl & ~TIMER_CTRL_ENABLE, clkevt_base + TIMER_CTRL);
+	writel(next, clkevt_base + TIMER_LOAD);
+	writel(ctrl | TIMER_CTRL_ENABLE, clkevt_base + TIMER_CTRL);
+
+	return 0;
+}
+
+static struct clock_event_device integrator_clockevent = {
+	.name		= "timer1",
+	.shift		= 34,
+	.features	= CLOCK_EVT_FEAT_PERIODIC,
+	.set_mode	= clkevt_set_mode,
+	.set_next_event	= clkevt_set_next_event,
+	.rating		= 300,
+	.cpumask	= cpu_all_mask,
+};
+
 static struct irqaction integrator_timer_irq = {
-	.name		= "Integrator Timer Tick",
+	.name		= "timer",
 	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
 	.handler	= integrator_timer_interrupt,
+	.dev_id		= &integrator_clockevent,
 };
 
-/*
- * Set up timer interrupt, and return the current time in seconds.
- */
-void __init integrator_time_init(unsigned long reload, unsigned int ctrl)
+static void integrator_clockevent_init(u32 khz, unsigned int ctrl)
 {
-	unsigned int timer_ctrl = TIMER_CTRL_ENABLE | TIMER_CTRL_PERIODIC;
+	struct clock_event_device *evt = &integrator_clockevent;
 
-	integrator_clocksource_init(reload * HZ / 1000);
+	if (khz * 1000 > 0x100000 * HZ) {
+		khz /= 256;
+		ctrl |= TIMER_CTRL_DIV256;
+	} else if (khz * 1000 > 0x10000 * HZ) {
+		khz /= 16;
+		ctrl |= TIMER_CTRL_DIV16;
+	}
 
-	timer_reload = reload;
-	timer_ctrl |= ctrl;
+	timer_reload = khz * 1000 / HZ;
+	writel(ctrl, clkevt_base + TIMER_CTRL);
 
-	if (timer_reload > 0x100000) {
-		timer_reload >>= 8;
-		timer_ctrl |= TIMER_CTRL_DIV256;
-	} else if (timer_reload > 0x010000) {
-		timer_reload >>= 4;
-		timer_ctrl |= TIMER_CTRL_DIV16;
-	}
+	evt->irq = IRQ_TIMERINT1;
+	evt->mult = div_sc(khz, NSEC_PER_MSEC, evt->shift);
+	evt->max_delta_ns = clockevent_delta2ns(0xffff, evt);
+	evt->min_delta_ns = clockevent_delta2ns(0xf, evt);
 
-	/*
-	 * Initialise to a known state (all timers off)
-	 */
+	setup_irq(IRQ_TIMERINT1, &integrator_timer_irq);
+	clockevents_register_device(evt);
+}
+
+/*
+ * Set up timer(s).
+ */
+void __init integrator_time_init(unsigned long reload, unsigned int ctrl)
+{
 	writel(0, TIMER0_VA_BASE + TIMER_CTRL);
 	writel(0, TIMER1_VA_BASE + TIMER_CTRL);
 	writel(0, TIMER2_VA_BASE + TIMER_CTRL);
 
-	writel(timer_reload, TIMER1_VA_BASE + TIMER_LOAD);
-	writel(timer_reload, TIMER1_VA_BASE + TIMER_VALUE);
-	writel(timer_ctrl, TIMER1_VA_BASE + TIMER_CTRL);
-
-	/*
-	 * Make irqs happen for the system timer
-	 */
-	setup_irq(IRQ_TIMERINT1, &integrator_timer_irq);
+	integrator_clocksource_init(reload * HZ / 1000);
+	integrator_clockevent_init(reload * HZ / 1000, ctrl);
 }

commit b9cedda230793cbf58eb012ddadedd490cc8e129
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Jan 15 18:10:33 2010 +0000

    ARM: Integrator: convert to generic time support
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 096f899625f8..87c6f980944d 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -19,6 +19,7 @@
 #include <linux/termios.h>
 #include <linux/amba/bus.h>
 #include <linux/amba/serial.h>
+#include <linux/clocksource.h>
 #include <linux/io.h>
 
 #include <asm/clkdev.h>
@@ -225,7 +226,6 @@ EXPORT_SYMBOL(cm_control);
 #define TIMER0_VA_BASE (IO_ADDRESS(INTEGRATOR_CT_BASE)+0x00000000)
 #define TIMER1_VA_BASE (IO_ADDRESS(INTEGRATOR_CT_BASE)+0x00000100)
 #define TIMER2_VA_BASE (IO_ADDRESS(INTEGRATOR_CT_BASE)+0x00000200)
-#define VA_IC_BASE     IO_ADDRESS(INTEGRATOR_IC_BASE) 
 
 /*
  * How long is the timer interval?
@@ -241,42 +241,38 @@ EXPORT_SYMBOL(cm_control);
 
 static unsigned long timer_reload;
 
-/*
- * Returns number of ms since last clock interrupt.  Note that interrupts
- * will have been disabled by do_gettimeoffset()
- */
-unsigned long integrator_gettimeoffset(void)
+static void __iomem * const clksrc_base = (void __iomem *)TIMER2_VA_BASE;
+
+static cycle_t timersp_read(struct clocksource *cs)
 {
-	unsigned long ticks1, ticks2, status;
+	return ~(readl(clksrc_base + TIMER_VALUE) & 0xffff);
+}
 
-	/*
-	 * Get the current number of ticks.  Note that there is a race
-	 * condition between us reading the timer and checking for
-	 * an interrupt.  We get around this by ensuring that the
-	 * counter has not reloaded between our two reads.
-	 */
-	ticks2 = readl(TIMER1_VA_BASE + TIMER_VALUE) & 0xffff;
-	do {
-		ticks1 = ticks2;
-		status = __raw_readl(VA_IC_BASE + IRQ_RAW_STATUS);
-		ticks2 = readl(TIMER1_VA_BASE + TIMER_VALUE) & 0xffff;
-	} while (ticks2 > ticks1);
+static struct clocksource clocksource_timersp = {
+	.name		= "timer2",
+	.rating		= 200,
+	.read		= timersp_read,
+	.mask		= CLOCKSOURCE_MASK(16),
+	.shift		= 16,
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
 
-	/*
-	 * Number of ticks since last interrupt.
-	 */
-	ticks1 = timer_reload - ticks2;
+static void integrator_clocksource_init(u32 khz)
+{
+	struct clocksource *cs = &clocksource_timersp;
+	void __iomem *base = clksrc_base;
+	u32 ctrl = TIMER_CTRL_ENABLE;
 
-	/*
-	 * Interrupt pending?  If so, we've reloaded once already.
-	 */
-	if (status & (1 << IRQ_TIMERINT1))
-		ticks1 += timer_reload;
+	if (khz >= 1500) {
+		khz /= 16;
+		ctrl = TIMER_CTRL_DIV16;
+	}
 
-	/*
-	 * Convert the ticks to usecs
-	 */
-	return TICKS2USECS(ticks1);
+	writel(ctrl, base + TIMER_CTRL);
+	writel(0xffff, base + TIMER_LOAD);
+
+	cs->mult = clocksource_khz2mult(khz, cs->shift);
+	clocksource_register(cs);
 }
 
 /*
@@ -308,6 +304,8 @@ void __init integrator_time_init(unsigned long reload, unsigned int ctrl)
 {
 	unsigned int timer_ctrl = TIMER_CTRL_ENABLE | TIMER_CTRL_PERIODIC;
 
+	integrator_clocksource_init(reload * HZ / 1000);
+
 	timer_reload = reload;
 	timer_ctrl |= ctrl;
 

commit a285edcf18b8838814d645c7e411a337a825236e
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jan 14 19:59:37 2010 +0000

    ARM: Fix Versatile&Integrator includes to behave in the same way as Realview
    
    Realview doesn't include mach/platform.h in mach/hardware.h, so
    make versatile behave in the same way.  Also, move the definition
    of __io_address() into mach/hardware.h, just like Realview.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 8b390e36ba69..096f899625f8 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -24,6 +24,7 @@
 #include <asm/clkdev.h>
 #include <mach/clkdev.h>
 #include <mach/hardware.h>
+#include <mach/platform.h>
 #include <asm/irq.h>
 #include <asm/hardware/arm_timer.h>
 #include <mach/cm.h>

commit 0a0300dc8c4b3f3ce5c9ef5a0a4be5442590398f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jan 12 12:28:00 2010 +0000

    ARM: Consolidate clks_register() and similar
    
    Most machine classes want some way to register a block of clk_lookup
    structures, and most do it by implementing a clks_register() type
    function which walks an array, or by open-coding a loop.
    
    Consolidate all this into clkdev_add_table().
    
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Reviewed-by: Kevin Hilman <khilman@deeprootsystems.com>
    Acked-by: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index a0f60e55da6a..8b390e36ba69 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -144,8 +144,7 @@ static int __init integrator_init(void)
 {
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(lookups); i++)
-		clkdev_add(&lookups[i]);
+	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
 
 	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
 		struct amba_device *d = amba_devs[i];

commit a93ea9b357a4d4fce9a1f65bf9c152fb67c30716
Author: Rabin Vincent <rabin@rab.in>
Date:   Mon May 18 17:26:08 2009 +0100

    [ARM] 5517/1: integrator: don't put clock lookups in __initdata
    
    Remove the __initdata annotation for the clock lookups, since they
    will be needed when loading modules which use clk_get().
    
    Signed-off-by: Rabin Vincent <rabin@rab.in>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 6f8872913073..a0f60e55da6a 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -121,7 +121,7 @@ static struct clk uartclk = {
 	.rate	= 14745600,
 };
 
-static struct clk_lookup lookups[] __initdata = {
+static struct clk_lookup lookups[] = {
 	{	/* UART0 */
 		.dev_id		= "mb:16",
 		.clk		= &uartclk,

commit 1d559e29138834bbcdf34ac072232bf543bfc4e0
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Jan 6 10:44:43 2009 -0800

    arm: struct device - replace bus_id with dev_name(), dev_set_name()
    
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index c89c949b4d45..6f8872913073 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -37,7 +37,7 @@ static struct amba_pl010_data integrator_uart_data;
 
 static struct amba_device rtc_device = {
 	.dev		= {
-		.bus_id	= "mb:15",
+		.init_name = "mb:15",
 	},
 	.res		= {
 		.start	= INTEGRATOR_RTC_BASE,
@@ -50,7 +50,7 @@ static struct amba_device rtc_device = {
 
 static struct amba_device uart0_device = {
 	.dev		= {
-		.bus_id	= "mb:16",
+		.init_name = "mb:16",
 		.platform_data = &integrator_uart_data,
 	},
 	.res		= {
@@ -64,7 +64,7 @@ static struct amba_device uart0_device = {
 
 static struct amba_device uart1_device = {
 	.dev		= {
-		.bus_id	= "mb:17",
+		.init_name = "mb:17",
 		.platform_data = &integrator_uart_data,
 	},
 	.res		= {
@@ -78,7 +78,7 @@ static struct amba_device uart1_device = {
 
 static struct amba_device kmi0_device = {
 	.dev		= {
-		.bus_id	= "mb:18",
+		.init_name = "mb:18",
 	},
 	.res		= {
 		.start	= KMI0_BASE,
@@ -91,7 +91,7 @@ static struct amba_device kmi0_device = {
 
 static struct amba_device kmi1_device = {
 	.dev		= {
-		.bus_id	= "mb:19",
+		.init_name = "mb:19",
 	},
 	.res		= {
 		.start	= KMI1_BASE,

commit d72fbdf01fc77628c0b837d0dd2fd564fa26ede6
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Nov 8 20:08:08 2008 +0000

    [ARM] integrator: convert to clkdev and lookup clocks by device name
    
    People often point to the Integrator/Versatile/Realview
    implementations to justify using the consumer name as the sole
    selector for clocks.
    
    Eliminate this excuse by changing the Integrator implementation, so
    it provides a better example of how it should be done.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 595b7392ee4e..c89c949b4d45 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -21,6 +21,8 @@
 #include <linux/amba/serial.h>
 #include <linux/io.h>
 
+#include <asm/clkdev.h>
+#include <mach/clkdev.h>
 #include <mach/hardware.h>
 #include <asm/irq.h>
 #include <asm/hardware/arm_timer.h>
@@ -108,10 +110,43 @@ static struct amba_device *amba_devs[] __initdata = {
 	&kmi1_device,
 };
 
+/*
+ * These are fixed clocks.
+ */
+static struct clk clk24mhz = {
+	.rate	= 24000000,
+};
+
+static struct clk uartclk = {
+	.rate	= 14745600,
+};
+
+static struct clk_lookup lookups[] __initdata = {
+	{	/* UART0 */
+		.dev_id		= "mb:16",
+		.clk		= &uartclk,
+	}, {	/* UART1 */
+		.dev_id		= "mb:17",
+		.clk		= &uartclk,
+	}, {	/* KMI0 */
+		.dev_id		= "mb:18",
+		.clk		= &clk24mhz,
+	}, {	/* KMI1 */
+		.dev_id		= "mb:19",
+		.clk		= &clk24mhz,
+	}, {	/* MMCI - IntegratorCP */
+		.dev_id		= "mb:1c",
+		.clk		= &uartclk,
+	}
+};
+
 static int __init integrator_init(void)
 {
 	int i;
 
+	for (i = 0; i < ARRAY_SIZE(lookups); i++)
+		clkdev_add(&lookups[i]);
+
 	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
 		struct amba_device *d = amba_devs[i];
 		amba_device_register(d, &iomem_resource);

commit fced80c735941fa518ac67c0b61bbe153fb8c050
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Sep 6 12:10:45 2008 +0100

    [ARM] Convert asm/io.h to linux/io.h
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 8bacf6d4d097..595b7392ee4e 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -19,10 +19,10 @@
 #include <linux/termios.h>
 #include <linux/amba/bus.h>
 #include <linux/amba/serial.h>
+#include <linux/io.h>
 
 #include <mach/hardware.h>
 #include <asm/irq.h>
-#include <asm/io.h>
 #include <asm/hardware/arm_timer.h>
 #include <mach/cm.h>
 #include <asm/system.h>

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index f439bf12be5e..8bacf6d4d097 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -20,11 +20,11 @@
 #include <linux/amba/bus.h>
 #include <linux/amba/serial.h>
 
-#include <asm/arch/hardware.h>
+#include <mach/hardware.h>
 #include <asm/irq.h>
 #include <asm/io.h>
 #include <asm/hardware/arm_timer.h>
-#include <asm/arch/cm.h>
+#include <mach/cm.h>
 #include <asm/system.h>
 #include <asm/leds.h>
 #include <asm/mach/time.h>

commit be509729356b7433f73df2b9a966674a437fbbc1
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Aug 4 10:41:28 2008 +0100

    [ARM] Remove asm/hardware.h, use asm/arch/hardware.h instead
    
    Remove includes of asm/hardware.h in addition to asm/arch/hardware.h.
    Then, since asm/hardware.h only exists to include asm/arch/hardware.h,
    update everything to directly include asm/arch/hardware.h and remove
    asm/hardware.h.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 7fbbc17f8e8b..f439bf12be5e 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -20,7 +20,7 @@
 #include <linux/amba/bus.h>
 #include <linux/amba/serial.h>
 
-#include <asm/hardware.h>
+#include <asm/arch/hardware.h>
 #include <asm/irq.h>
 #include <asm/io.h>
 #include <asm/hardware/arm_timer.h>

commit 193c3cc12583344be01206078d9ad3fec5dbc397
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Jan 28 10:16:37 2008 +0000

    [ARM] Fix timer damage from d3d74453c34f8fd87674a8cf5b8a327c68f22e99
    
    Move the xtime write mode seqlock into timer_tick(), so it only
    surrounds the call to do_timer().
    
    This avoids a deadlock in update_process_times() ...
    hrtimer_get_softirq_time() which tries to get a read mode seqlock
    on xtime, thereby preventing booting.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index e9c82deb791d..7fbbc17f8e8b 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -250,8 +250,6 @@ unsigned long integrator_gettimeoffset(void)
 static irqreturn_t
 integrator_timer_interrupt(int irq, void *dev_id)
 {
-	write_seqlock(&xtime_lock);
-
 	/*
 	 * clear the interrupt
 	 */
@@ -259,8 +257,6 @@ integrator_timer_interrupt(int irq, void *dev_id)
 
 	timer_tick();
 
-	write_sequnlock(&xtime_lock);
-
 	return IRQ_HANDLED;
 }
 

commit 06ba255571b0a2f1fb7e49e7406364e4194f4e10
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon May 14 22:56:32 2007 +0100

    [ARM] Remove Integrator/CP SMP platform support
    
    The Integrator/CP SMP platform support was never fully merged, and now
    it's causing build breakage.  Remove it.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 897c21c2fb5b..e9c82deb791d 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -257,23 +257,7 @@ integrator_timer_interrupt(int irq, void *dev_id)
 	 */
 	writel(1, TIMER1_VA_BASE + TIMER_INTCLR);
 
-	/*
-	 * the clock tick routines are only processed on the
-	 * primary CPU
-	 */
-	if (hard_smp_processor_id() == 0) {
-		timer_tick();
-#ifdef CONFIG_SMP
-		smp_send_timer();
-#endif
-	}
-
-#ifdef CONFIG_SMP
-	/*
-	 * this is the ARM equivalent of the APIC timer interrupt
-	 */
-	update_process_times(user_mode(get_irq_regs()));
-#endif /* CONFIG_SMP */
+	timer_tick();
 
 	write_sequnlock(&xtime_lock);
 

commit b30fabadae2b3c1a65e3662be98f105d5718db70
Author: Bernhard Walle <bwalle@suse.de>
Date:   Tue May 8 00:35:39 2007 -0700

    Add IRQF_IRQPOLL flag on arm
    
    Add IRQF_IRQPOLL for each timer interrupt.
    
    Signed-off-by: Bernhard Walle <bwalle@suse.de>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 8d880cb9ba39..897c21c2fb5b 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -282,7 +282,7 @@ integrator_timer_interrupt(int irq, void *dev_id)
 
 static struct irqaction integrator_timer_irq = {
 	.name		= "Integrator Timer Tick",
-	.flags		= IRQF_DISABLED | IRQF_TIMER,
+	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
 	.handler	= integrator_timer_interrupt,
 };
 

commit 0cd61b68c340a4f901a06e8bb5e0dea4353161c0
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Fri Oct 6 10:53:39 2006 -0700

    Initial blind fixup for arm for irq changes
    
    Untested, but this should fix up the bulk of the totally mechanical
    issues, and should make the actual detail fixing easier.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 42021fdfa0c6..8d880cb9ba39 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -248,7 +248,7 @@ unsigned long integrator_gettimeoffset(void)
  * IRQ handler for the timer
  */
 static irqreturn_t
-integrator_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+integrator_timer_interrupt(int irq, void *dev_id)
 {
 	write_seqlock(&xtime_lock);
 
@@ -262,7 +262,7 @@ integrator_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 	 * primary CPU
 	 */
 	if (hard_smp_processor_id() == 0) {
-		timer_tick(regs);
+		timer_tick();
 #ifdef CONFIG_SMP
 		smp_send_timer();
 #endif
@@ -272,7 +272,7 @@ integrator_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 	/*
 	 * this is the ARM equivalent of the APIC timer interrupt
 	 */
-	update_process_times(user_mode(regs));
+	update_process_times(user_mode(get_irq_regs()));
 #endif /* CONFIG_SMP */
 
 	write_sequnlock(&xtime_lock);

commit 52e405eaa9806968e88b35d65e57acad954a5ab5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 3 02:20:05 2006 +0200

    [PATCH] ARM: fixup irqflags breakage after ARM genirq merge
    
    The irgflags consolidation did conflict with the ARM to generic IRQ
    conversion and was not applied for ARM. Fix it up.
    
    Use the new IRQF_ constants and remove the SA_INTERRUPT define
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 2d7e505e748f..42021fdfa0c6 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -282,7 +282,7 @@ integrator_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 
 static struct irqaction integrator_timer_irq = {
 	.name		= "Integrator Timer Tick",
-	.flags		= SA_INTERRUPT | SA_TIMER,
+	.flags		= IRQF_DISABLED | IRQF_TIMER,
 	.handler	= integrator_timer_interrupt,
 };
 

commit a03d4d2765a047914c1f278c11e98aee44dd10bb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 22:32:32 2006 +0100

    [ARM] 3687/1: ARM: Convert integrator to generic irq handling
    
    Patch from Thomas Gleixner
    
    From: Thomas Gleixner <tglx@linutronix.de>
    
    Fixup the conversion to generic irq subsystem.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 576a5e979c00..2d7e505e748f 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -13,6 +13,7 @@
 #include <linux/device.h>
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
+#include <linux/irq.h>
 #include <linux/sched.h>
 #include <linux/smp.h>
 #include <linux/termios.h>

commit fbb18a277a6f192404aa20ece49529acb1e1e76d
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Mar 26 23:13:39 2006 +0100

    [SERIAL] amba-pl010: allow platforms to specify modem control method
    
    The amba-pl010 hardware does not provide RTS and DTR control lines; it
    is expected that these will be implemented using GPIO.  Allow platforms
    to supply a function to implement manipulation of modem control lines.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 20071a2767cc..576a5e979c00 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -15,7 +15,9 @@
 #include <linux/interrupt.h>
 #include <linux/sched.h>
 #include <linux/smp.h>
+#include <linux/termios.h>
 #include <linux/amba/bus.h>
+#include <linux/amba/serial.h>
 
 #include <asm/hardware.h>
 #include <asm/irq.h>
@@ -28,6 +30,8 @@
 
 #include "common.h"
 
+static struct amba_pl010_data integrator_uart_data;
+
 static struct amba_device rtc_device = {
 	.dev		= {
 		.bus_id	= "mb:15",
@@ -44,6 +48,7 @@ static struct amba_device rtc_device = {
 static struct amba_device uart0_device = {
 	.dev		= {
 		.bus_id	= "mb:16",
+		.platform_data = &integrator_uart_data,
 	},
 	.res		= {
 		.start	= INTEGRATOR_UART0_BASE,
@@ -57,6 +62,7 @@ static struct amba_device uart0_device = {
 static struct amba_device uart1_device = {
 	.dev		= {
 		.bus_id	= "mb:17",
+		.platform_data = &integrator_uart_data,
 	},
 	.res		= {
 		.start	= INTEGRATOR_UART1_BASE,
@@ -115,6 +121,46 @@ static int __init integrator_init(void)
 
 arch_initcall(integrator_init);
 
+/*
+ * On the Integrator platform, the port RTS and DTR are provided by
+ * bits in the following SC_CTRLS register bits:
+ *        RTS  DTR
+ *  UART0  7    6
+ *  UART1  5    4
+ */
+#define SC_CTRLC	(IO_ADDRESS(INTEGRATOR_SC_BASE) + INTEGRATOR_SC_CTRLC_OFFSET)
+#define SC_CTRLS	(IO_ADDRESS(INTEGRATOR_SC_BASE) + INTEGRATOR_SC_CTRLS_OFFSET)
+
+static void integrator_uart_set_mctrl(struct amba_device *dev, void __iomem *base, unsigned int mctrl)
+{
+	unsigned int ctrls = 0, ctrlc = 0, rts_mask, dtr_mask;
+
+	if (dev == &uart0_device) {
+		rts_mask = 1 << 4;
+		dtr_mask = 1 << 5;
+	} else {
+		rts_mask = 1 << 6;
+		dtr_mask = 1 << 7;
+	}
+
+	if (mctrl & TIOCM_RTS)
+		ctrlc |= rts_mask;
+	else
+		ctrls |= rts_mask;
+
+	if (mctrl & TIOCM_DTR)
+		ctrlc |= dtr_mask;
+	else
+		ctrls |= dtr_mask;
+
+	__raw_writel(ctrls, SC_CTRLS);
+	__raw_writel(ctrlc, SC_CTRLC);
+}
+
+static struct amba_pl010_data integrator_uart_data = {
+	.set_mctrl = integrator_uart_set_mctrl,
+};
+
 #define CM_CTRL	IO_ADDRESS(INTEGRATOR_HDR_BASE) + INTEGRATOR_HDR_CTRL_OFFSET
 
 static DEFINE_SPINLOCK(cm_lock);

commit a62c80e559809e6c7851ec04d30575e85ad6f6ed
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Jan 7 13:52:45 2006 +0000

    [ARM] Move AMBA include files to include/linux/amba/
    
    Since the ARM AMBA bus is used on MIPS as well as ARM, we need
    to make the bus available for other architectures to use.  Move
    the AMBA include files from include/asm-arm/hardware/ to
    include/linux/amba/
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index dacbf504dae2..20071a2767cc 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -15,11 +15,11 @@
 #include <linux/interrupt.h>
 #include <linux/sched.h>
 #include <linux/smp.h>
+#include <linux/amba/bus.h>
 
 #include <asm/hardware.h>
 #include <asm/irq.h>
 #include <asm/io.h>
-#include <asm/hardware/amba.h>
 #include <asm/hardware/arm_timer.h>
 #include <asm/arch/cm.h>
 #include <asm/system.h>

commit 20f720ccce8864583365d844d48d3fe8d0d171ad
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Jun 29 18:26:19 2005 +0100

    [PATCH] ARM: Remove nmi_tick from integrator platforms
    
    The nmi watchdog code hasn't been merged for this platform yet.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 797c7fddaa0d..dacbf504dae2 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -215,7 +215,6 @@ integrator_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 	 * primary CPU
 	 */
 	if (hard_smp_processor_id() == 0) {
-		nmi_tick();
 		timer_tick(regs);
 #ifdef CONFIG_SMP
 		smp_send_timer();

commit b720f73296916e87c744193c57bc8687d35888fe
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Jun 29 15:15:54 2005 +0100

    [PATCH] ARM: Convert ARM timer implementations to use readl/writel
    
    Convert ARMs timer implementations to use readl/writel instead of accessing
    the registers via a struct.
    
    People have recently asked if accessing timers via a structure is the
    "right way" and its not the Linux way.  So fix this code to conform to
    "The Linux Way"(tm).
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 9222e57bd872..797c7fddaa0d 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -20,6 +20,7 @@
 #include <asm/irq.h>
 #include <asm/io.h>
 #include <asm/hardware/amba.h>
+#include <asm/hardware/arm_timer.h>
 #include <asm/arch/cm.h>
 #include <asm/system.h>
 #include <asm/leds.h>
@@ -156,16 +157,6 @@ EXPORT_SYMBOL(cm_control);
 #define TICKS2USECS(x)	((x) / TICKS_PER_uSEC)
 #endif
 
-/*
- * What does it look like?
- */
-typedef struct TimerStruct {
-	unsigned long TimerLoad;
-	unsigned long TimerValue;
-	unsigned long TimerControl;
-	unsigned long TimerClear;
-} TimerStruct_t;
-
 static unsigned long timer_reload;
 
 /*
@@ -174,7 +165,6 @@ static unsigned long timer_reload;
  */
 unsigned long integrator_gettimeoffset(void)
 {
-	volatile TimerStruct_t *timer1 = (TimerStruct_t *)TIMER1_VA_BASE;
 	unsigned long ticks1, ticks2, status;
 
 	/*
@@ -183,11 +173,11 @@ unsigned long integrator_gettimeoffset(void)
 	 * an interrupt.  We get around this by ensuring that the
 	 * counter has not reloaded between our two reads.
 	 */
-	ticks2 = timer1->TimerValue & 0xffff;
+	ticks2 = readl(TIMER1_VA_BASE + TIMER_VALUE) & 0xffff;
 	do {
 		ticks1 = ticks2;
 		status = __raw_readl(VA_IC_BASE + IRQ_RAW_STATUS);
-		ticks2 = timer1->TimerValue & 0xffff;
+		ticks2 = readl(TIMER1_VA_BASE + TIMER_VALUE) & 0xffff;
 	} while (ticks2 > ticks1);
 
 	/*
@@ -213,20 +203,19 @@ unsigned long integrator_gettimeoffset(void)
 static irqreturn_t
 integrator_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	volatile TimerStruct_t *timer1 = (volatile TimerStruct_t *)TIMER1_VA_BASE;
-
 	write_seqlock(&xtime_lock);
 
 	/*
 	 * clear the interrupt
 	 */
-	timer1->TimerClear = 1;
+	writel(1, TIMER1_VA_BASE + TIMER_INTCLR);
 
 	/*
 	 * the clock tick routines are only processed on the
 	 * primary CPU
 	 */
 	if (hard_smp_processor_id() == 0) {
+		nmi_tick();
 		timer_tick(regs);
 #ifdef CONFIG_SMP
 		smp_send_timer();
@@ -256,32 +245,29 @@ static struct irqaction integrator_timer_irq = {
  */
 void __init integrator_time_init(unsigned long reload, unsigned int ctrl)
 {
-	volatile TimerStruct_t *timer0 = (volatile TimerStruct_t *)TIMER0_VA_BASE;
-	volatile TimerStruct_t *timer1 = (volatile TimerStruct_t *)TIMER1_VA_BASE;
-	volatile TimerStruct_t *timer2 = (volatile TimerStruct_t *)TIMER2_VA_BASE;
-	unsigned int timer_ctrl = 0x80 | 0x40;	/* periodic */
+	unsigned int timer_ctrl = TIMER_CTRL_ENABLE | TIMER_CTRL_PERIODIC;
 
 	timer_reload = reload;
 	timer_ctrl |= ctrl;
 
 	if (timer_reload > 0x100000) {
 		timer_reload >>= 8;
-		timer_ctrl |= 0x08; /* /256 */
+		timer_ctrl |= TIMER_CTRL_DIV256;
 	} else if (timer_reload > 0x010000) {
 		timer_reload >>= 4;
-		timer_ctrl |= 0x04; /* /16 */
+		timer_ctrl |= TIMER_CTRL_DIV16;
 	}
 
 	/*
 	 * Initialise to a known state (all timers off)
 	 */
-	timer0->TimerControl = 0;
-	timer1->TimerControl = 0;
-	timer2->TimerControl = 0;
+	writel(0, TIMER0_VA_BASE + TIMER_CTRL);
+	writel(0, TIMER1_VA_BASE + TIMER_CTRL);
+	writel(0, TIMER2_VA_BASE + TIMER_CTRL);
 
-	timer1->TimerLoad    = timer_reload;
-	timer1->TimerValue   = timer_reload;
-	timer1->TimerControl = timer_ctrl;
+	writel(timer_reload, TIMER1_VA_BASE + TIMER_LOAD);
+	writel(timer_reload, TIMER1_VA_BASE + TIMER_VALUE);
+	writel(timer_ctrl, TIMER1_VA_BASE + TIMER_CTRL);
 
 	/*
 	 * Make irqs happen for the system timer

commit 09b8b5f843afc21daf710cc610e5ca890ee94696
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Jun 26 17:06:36 2005 +0100

    [PATCH] ARM: Add SA_TIMER flag to timer interrupts
    
    VST needs to know which timer handler is for the timer interrupt.
    Mark all timer interrupts with the SA_TIMER flag.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index bd1e5e3c9d34..9222e57bd872 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -247,8 +247,8 @@ integrator_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 
 static struct irqaction integrator_timer_irq = {
 	.name		= "Integrator Timer Tick",
-	.flags		= SA_INTERRUPT,
-	.handler	= integrator_timer_interrupt
+	.flags		= SA_INTERRUPT | SA_TIMER,
+	.handler	= integrator_timer_interrupt,
 };
 
 /*

commit a507ef3ac68f0671fdd3f824885cd7f1ea1040b1
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Jun 20 16:57:17 2005 +0100

    [PATCH] ARM: Remove nmi_tick() from Integrator.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index d302f0405fd2..bd1e5e3c9d34 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -227,7 +227,6 @@ integrator_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 	 * primary CPU
 	 */
 	if (hard_smp_processor_id() == 0) {
-		nmi_tick();
 		timer_tick(regs);
 #ifdef CONFIG_SMP
 		smp_send_timer();

commit 20cf33ea16253b9eed387cba022cb014563db40e
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Jun 18 10:15:46 2005 +0100

    [PATCH] ARM SMP: Add basic support Integrator/CP platform
    
    Add basic SMP support for the Integrator/CP platform.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index bd17b5154311..d302f0405fd2 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -14,6 +14,7 @@
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
 #include <linux/sched.h>
+#include <linux/smp.h>
 
 #include <asm/hardware.h>
 #include <asm/irq.h>
@@ -221,7 +222,24 @@ integrator_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 	 */
 	timer1->TimerClear = 1;
 
-	timer_tick(regs);
+	/*
+	 * the clock tick routines are only processed on the
+	 * primary CPU
+	 */
+	if (hard_smp_processor_id() == 0) {
+		nmi_tick();
+		timer_tick(regs);
+#ifdef CONFIG_SMP
+		smp_send_timer();
+#endif
+	}
+
+#ifdef CONFIG_SMP
+	/*
+	 * this is the ARM equivalent of the APIC timer interrupt
+	 */
+	update_process_times(user_mode(regs));
+#endif /* CONFIG_SMP */
 
 	write_sequnlock(&xtime_lock);
 

commit 1f9c381fa3e0b9b9042e310c69df87eaf9b46ea4
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue May 3 12:22:19 2005 +0100

    [PATCH] ARM: Clean up commenting/spacing for Integrator
    
    Signed-off-by: Russell King <rmk@arm.linux.org.uk>

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
index 86c50c3889b7..bd17b5154311 100644
--- a/arch/arm/mach-integrator/core.c
+++ b/arch/arm/mach-integrator/core.c
@@ -216,7 +216,9 @@ integrator_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 
 	write_seqlock(&xtime_lock);
 
-	// ...clear the interrupt
+	/*
+	 * clear the interrupt
+	 */
 	timer1->TimerClear = 1;
 
 	timer_tick(regs);
@@ -264,7 +266,7 @@ void __init integrator_time_init(unsigned long reload, unsigned int ctrl)
 	timer1->TimerValue   = timer_reload;
 	timer1->TimerControl = timer_ctrl;
 
-	/* 
+	/*
 	 * Make irqs happen for the system timer
 	 */
 	setup_irq(IRQ_TIMERINT1, &integrator_timer_irq);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/arm/mach-integrator/core.c b/arch/arm/mach-integrator/core.c
new file mode 100644
index 000000000000..86c50c3889b7
--- /dev/null
+++ b/arch/arm/mach-integrator/core.c
@@ -0,0 +1,271 @@
+/*
+ *  linux/arch/arm/mach-integrator/core.c
+ *
+ *  Copyright (C) 2000-2003 Deep Blue Solutions Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2, as
+ * published by the Free Software Foundation.
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/hardware/amba.h>
+#include <asm/arch/cm.h>
+#include <asm/system.h>
+#include <asm/leds.h>
+#include <asm/mach/time.h>
+
+#include "common.h"
+
+static struct amba_device rtc_device = {
+	.dev		= {
+		.bus_id	= "mb:15",
+	},
+	.res		= {
+		.start	= INTEGRATOR_RTC_BASE,
+		.end	= INTEGRATOR_RTC_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	.irq		= { IRQ_RTCINT, NO_IRQ },
+	.periphid	= 0x00041030,
+};
+
+static struct amba_device uart0_device = {
+	.dev		= {
+		.bus_id	= "mb:16",
+	},
+	.res		= {
+		.start	= INTEGRATOR_UART0_BASE,
+		.end	= INTEGRATOR_UART0_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	.irq		= { IRQ_UARTINT0, NO_IRQ },
+	.periphid	= 0x0041010,
+};
+
+static struct amba_device uart1_device = {
+	.dev		= {
+		.bus_id	= "mb:17",
+	},
+	.res		= {
+		.start	= INTEGRATOR_UART1_BASE,
+		.end	= INTEGRATOR_UART1_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	.irq		= { IRQ_UARTINT1, NO_IRQ },
+	.periphid	= 0x0041010,
+};
+
+static struct amba_device kmi0_device = {
+	.dev		= {
+		.bus_id	= "mb:18",
+	},
+	.res		= {
+		.start	= KMI0_BASE,
+		.end	= KMI0_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	.irq		= { IRQ_KMIINT0, NO_IRQ },
+	.periphid	= 0x00041050,
+};
+
+static struct amba_device kmi1_device = {
+	.dev		= {
+		.bus_id	= "mb:19",
+	},
+	.res		= {
+		.start	= KMI1_BASE,
+		.end	= KMI1_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	.irq		= { IRQ_KMIINT1, NO_IRQ },
+	.periphid	= 0x00041050,
+};
+
+static struct amba_device *amba_devs[] __initdata = {
+	&rtc_device,
+	&uart0_device,
+	&uart1_device,
+	&kmi0_device,
+	&kmi1_device,
+};
+
+static int __init integrator_init(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
+		struct amba_device *d = amba_devs[i];
+		amba_device_register(d, &iomem_resource);
+	}
+
+	return 0;
+}
+
+arch_initcall(integrator_init);
+
+#define CM_CTRL	IO_ADDRESS(INTEGRATOR_HDR_BASE) + INTEGRATOR_HDR_CTRL_OFFSET
+
+static DEFINE_SPINLOCK(cm_lock);
+
+/**
+ * cm_control - update the CM_CTRL register.
+ * @mask: bits to change
+ * @set: bits to set
+ */
+void cm_control(u32 mask, u32 set)
+{
+	unsigned long flags;
+	u32 val;
+
+	spin_lock_irqsave(&cm_lock, flags);
+	val = readl(CM_CTRL) & ~mask;
+	writel(val | set, CM_CTRL);
+	spin_unlock_irqrestore(&cm_lock, flags);
+}
+
+EXPORT_SYMBOL(cm_control);
+
+/*
+ * Where is the timer (VA)?
+ */
+#define TIMER0_VA_BASE (IO_ADDRESS(INTEGRATOR_CT_BASE)+0x00000000)
+#define TIMER1_VA_BASE (IO_ADDRESS(INTEGRATOR_CT_BASE)+0x00000100)
+#define TIMER2_VA_BASE (IO_ADDRESS(INTEGRATOR_CT_BASE)+0x00000200)
+#define VA_IC_BASE     IO_ADDRESS(INTEGRATOR_IC_BASE) 
+
+/*
+ * How long is the timer interval?
+ */
+#define TIMER_INTERVAL	(TICKS_PER_uSEC * mSEC_10)
+#if TIMER_INTERVAL >= 0x100000
+#define TICKS2USECS(x)	(256 * (x) / TICKS_PER_uSEC)
+#elif TIMER_INTERVAL >= 0x10000
+#define TICKS2USECS(x)	(16 * (x) / TICKS_PER_uSEC)
+#else
+#define TICKS2USECS(x)	((x) / TICKS_PER_uSEC)
+#endif
+
+/*
+ * What does it look like?
+ */
+typedef struct TimerStruct {
+	unsigned long TimerLoad;
+	unsigned long TimerValue;
+	unsigned long TimerControl;
+	unsigned long TimerClear;
+} TimerStruct_t;
+
+static unsigned long timer_reload;
+
+/*
+ * Returns number of ms since last clock interrupt.  Note that interrupts
+ * will have been disabled by do_gettimeoffset()
+ */
+unsigned long integrator_gettimeoffset(void)
+{
+	volatile TimerStruct_t *timer1 = (TimerStruct_t *)TIMER1_VA_BASE;
+	unsigned long ticks1, ticks2, status;
+
+	/*
+	 * Get the current number of ticks.  Note that there is a race
+	 * condition between us reading the timer and checking for
+	 * an interrupt.  We get around this by ensuring that the
+	 * counter has not reloaded between our two reads.
+	 */
+	ticks2 = timer1->TimerValue & 0xffff;
+	do {
+		ticks1 = ticks2;
+		status = __raw_readl(VA_IC_BASE + IRQ_RAW_STATUS);
+		ticks2 = timer1->TimerValue & 0xffff;
+	} while (ticks2 > ticks1);
+
+	/*
+	 * Number of ticks since last interrupt.
+	 */
+	ticks1 = timer_reload - ticks2;
+
+	/*
+	 * Interrupt pending?  If so, we've reloaded once already.
+	 */
+	if (status & (1 << IRQ_TIMERINT1))
+		ticks1 += timer_reload;
+
+	/*
+	 * Convert the ticks to usecs
+	 */
+	return TICKS2USECS(ticks1);
+}
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t
+integrator_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	volatile TimerStruct_t *timer1 = (volatile TimerStruct_t *)TIMER1_VA_BASE;
+
+	write_seqlock(&xtime_lock);
+
+	// ...clear the interrupt
+	timer1->TimerClear = 1;
+
+	timer_tick(regs);
+
+	write_sequnlock(&xtime_lock);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction integrator_timer_irq = {
+	.name		= "Integrator Timer Tick",
+	.flags		= SA_INTERRUPT,
+	.handler	= integrator_timer_interrupt
+};
+
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+void __init integrator_time_init(unsigned long reload, unsigned int ctrl)
+{
+	volatile TimerStruct_t *timer0 = (volatile TimerStruct_t *)TIMER0_VA_BASE;
+	volatile TimerStruct_t *timer1 = (volatile TimerStruct_t *)TIMER1_VA_BASE;
+	volatile TimerStruct_t *timer2 = (volatile TimerStruct_t *)TIMER2_VA_BASE;
+	unsigned int timer_ctrl = 0x80 | 0x40;	/* periodic */
+
+	timer_reload = reload;
+	timer_ctrl |= ctrl;
+
+	if (timer_reload > 0x100000) {
+		timer_reload >>= 8;
+		timer_ctrl |= 0x08; /* /256 */
+	} else if (timer_reload > 0x010000) {
+		timer_reload >>= 4;
+		timer_ctrl |= 0x04; /* /16 */
+	}
+
+	/*
+	 * Initialise to a known state (all timers off)
+	 */
+	timer0->TimerControl = 0;
+	timer1->TimerControl = 0;
+	timer2->TimerControl = 0;
+
+	timer1->TimerLoad    = timer_reload;
+	timer1->TimerValue   = timer_reload;
+	timer1->TimerControl = timer_ctrl;
+
+	/* 
+	 * Make irqs happen for the system timer
+	 */
+	setup_irq(IRQ_TIMERINT1, &integrator_timer_irq);
+}
