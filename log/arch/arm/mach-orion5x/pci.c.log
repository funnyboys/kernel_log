commit 97ad2bdcbe8598a69ee1f372ed6c0fbdb2869218
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Jun 28 15:13:55 2017 -0500

    ARM/PCI: Convert PCI scan API to pci_scan_root_bus_bridge()
    
    The introduction of pci_scan_root_bus_bridge() provides a PCI core API to
    scan a PCI root bus backed by an already initialized struct pci_host_bridge
    object, which simplifies the bus scan interface and makes the PCI scan root
    bus interface easier to generalize as members are added to the struct
    pci_host_bridge.
    
    Convert ARM bios32 code to pci_scan_root_bus_bridge() to improve the PCI
    root bus scanning interface.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    [bhelgaas: fold in warning fix from Arnd Bergmann <arnd@arndb.de>:
    http://lkml.kernel.org/r/20170621215323.3921382-1-arnd@arndb.de]
    [bhelgaas: set bridge->ops for mv78xx0]
    [bhelgaas: fold in fixes from Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>:
    http://lkml.kernel.org/r/20170701135457.GB8977@red-moon]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Andrew Lunn <andrew@lunn.ch>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index ecb998e7f8dc..76951bfbacf5 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -555,18 +555,27 @@ int __init orion5x_pci_sys_setup(int nr, struct pci_sys_data *sys)
 	return 0;
 }
 
-struct pci_bus __init *orion5x_pci_sys_scan_bus(int nr, struct pci_sys_data *sys)
+int __init orion5x_pci_sys_scan_bus(int nr, struct pci_host_bridge *bridge)
 {
-	if (nr == 0)
-		return pci_scan_root_bus(NULL, sys->busnr, &pcie_ops, sys,
-					 &sys->resources);
+	struct pci_sys_data *sys = pci_host_bridge_priv(bridge);
 
-	if (nr == 1 && !orion5x_pci_disabled)
-		return pci_scan_root_bus(NULL, sys->busnr, &pci_ops, sys,
-					 &sys->resources);
+	list_splice_init(&sys->resources, &bridge->windows);
+	bridge->dev.parent = NULL;
+	bridge->sysdata = sys;
+	bridge->busnr = sys->busnr;
+
+	if (nr == 0) {
+		bridge->ops = &pcie_ops;
+		return pci_scan_root_bus_bridge(bridge);
+	}
+
+	if (nr == 1 && !orion5x_pci_disabled) {
+		bridge->ops = &pci_ops;
+		return pci_scan_root_bus_bridge(bridge);
+	}
 
 	BUG();
-	return NULL;
+	return -ENODEV;
 }
 
 int __init orion5x_pci_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)

commit c22c2c6008d69ff2632f8a69c62782468c2bb5a0
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Dec 2 22:27:08 2015 +0100

    ARM: orion5x: clean up mach/*.h headers
    
    This is a simple move of all header files that are no longer
    included by anything else from the include/mach directory
    to the platform directory itself as preparation for
    multiplatform support.
    
    The mach/uncompress.h headers are left in place for now,
    and are mildly modified to be independent of the other
    headers. They will be removed entirely when ARCH_MULTIPLATFORM
    gets enabled and they become obsolete.
    
    Rather than updating the path names inside of the comments
    of each header, I delete those comments to avoid having to
    update them again, should they get moved or copied another
    time.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index b02f3947be51..ecb998e7f8dc 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -19,8 +19,8 @@
 #include <asm/mach/pci.h>
 #include <plat/pcie.h>
 #include <plat/addr-map.h>
-#include <mach/orion5x.h>
 #include "common.h"
+#include "orion5x.h"
 
 /*****************************************************************************
  * Orion has one PCIe controller and one PCI controller.

commit 9e808eb6a7689b61399f772a2576d779161769ec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Mar 12 15:07:04 2015 -0500

    PCI: Cleanup control flow
    
    Return errors immediately so the straightline path is the normal,
    no-error path.  No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index 87a12d6930ff..b02f3947be51 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -540,37 +540,33 @@ void __init orion5x_pci_set_cardbus_mode(void)
 
 int __init orion5x_pci_sys_setup(int nr, struct pci_sys_data *sys)
 {
-	int ret = 0;
-
 	vga_base = ORION5X_PCIE_MEM_PHYS_BASE;
 
 	if (nr == 0) {
 		orion_pcie_set_local_bus_nr(PCIE_BASE, sys->busnr);
-		ret = pcie_setup(sys);
-	} else if (nr == 1 && !orion5x_pci_disabled) {
+		return pcie_setup(sys);
+	}
+
+	if (nr == 1 && !orion5x_pci_disabled) {
 		orion5x_pci_set_bus_nr(sys->busnr);
-		ret = pci_setup(sys);
+		return pci_setup(sys);
 	}
 
-	return ret;
+	return 0;
 }
 
 struct pci_bus __init *orion5x_pci_sys_scan_bus(int nr, struct pci_sys_data *sys)
 {
-	struct pci_bus *bus;
+	if (nr == 0)
+		return pci_scan_root_bus(NULL, sys->busnr, &pcie_ops, sys,
+					 &sys->resources);
 
-	if (nr == 0) {
-		bus = pci_scan_root_bus(NULL, sys->busnr, &pcie_ops, sys,
-					&sys->resources);
-	} else if (nr == 1 && !orion5x_pci_disabled) {
-		bus = pci_scan_root_bus(NULL, sys->busnr, &pci_ops, sys,
-					&sys->resources);
-	} else {
-		bus = NULL;
-		BUG();
-	}
+	if (nr == 1 && !orion5x_pci_disabled)
+		return pci_scan_root_bus(NULL, sys->busnr, &pci_ops, sys,
+					 &sys->resources);
 
-	return bus;
+	BUG();
+	return NULL;
 }
 
 int __init orion5x_pci_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)

commit 4236666688e9dbc38d0c7a98b7cfa16c8961f752
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Oct 23 16:12:51 2013 +0200

    ARM: Orion5x: Fix warnings when using C=1.
    
    Add missing include files, missing static keyword, and use NULL instead
    of 0, in order to fix warnings when compiling with C=1.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index 7fab67053030..87a12d6930ff 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -240,11 +240,11 @@ static int __init pcie_setup(struct pci_sys_data *sys)
 #define PCI_BAR_SIZE_DDR_CS(n)	(((n) == 0) ? ORION5X_PCI_REG(0xc08) : \
 				 ((n) == 1) ? ORION5X_PCI_REG(0xd08) : \
 				 ((n) == 2) ? ORION5X_PCI_REG(0xc0c) : \
-				 ((n) == 3) ? ORION5X_PCI_REG(0xd0c) : 0)
+				 ((n) == 3) ? ORION5X_PCI_REG(0xd0c) : NULL)
 #define PCI_BAR_REMAP_DDR_CS(n)	(((n) == 0) ? ORION5X_PCI_REG(0xc48) : \
 				 ((n) == 1) ? ORION5X_PCI_REG(0xd48) : \
 				 ((n) == 2) ? ORION5X_PCI_REG(0xc4c) : \
-				 ((n) == 3) ? ORION5X_PCI_REG(0xd4c) : 0)
+				 ((n) == 3) ? ORION5X_PCI_REG(0xd4c) : NULL)
 #define PCI_BAR_ENABLE		ORION5X_PCI_REG(0xc3c)
 #define PCI_ADDR_DECODE_CTRL	ORION5X_PCI_REG(0xd3c)
 

commit 4ca2c04085a1caa903e92a5fc0da25362150aac2
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Fri Jul 26 10:17:42 2013 -0300

    ARM: orion5x: Move to ID based window creation
    
    With the introduction of the ID based MBus API, it's better
    to switch to use it instead of the current name based scheme.
    
    This will allow to deprecate the name based API, once every
    user is removed.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Tested-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index 503368023bb1..7fab67053030 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -157,11 +157,10 @@ static int __init pcie_setup(struct pci_sys_data *sys)
 	if (dev == MV88F5181_DEV_ID || dev == MV88F5182_DEV_ID) {
 		printk(KERN_NOTICE "Applying Orion-1/Orion-NAS PCIe config "
 				   "read transaction workaround\n");
-		mvebu_mbus_add_window_remap_flags("pcie0.0",
-						  ORION5X_PCIE_WA_PHYS_BASE,
-						  ORION5X_PCIE_WA_SIZE,
-						  MVEBU_MBUS_NO_REMAP,
-						  MVEBU_MBUS_PCI_WA);
+		mvebu_mbus_add_window_by_id(ORION_MBUS_PCIE_WA_TARGET,
+					    ORION_MBUS_PCIE_WA_ATTR,
+					    ORION5X_PCIE_WA_PHYS_BASE,
+					    ORION5X_PCIE_WA_SIZE);
 		pcie_ops.read = pcie_rd_conf_wa;
 	}
 

commit 5d1190ea69cd158835518d4132b3d98774073092
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Thu Mar 21 17:59:18 2013 +0100

    arm: mach-orion5x: convert to use mvebu-mbus driver
    
    This commit migrates the mach-orion5x platforms to use the mvebu-mbus
    driver and therefore removes the Orion5x-specific addr-map code.
    
    The dove_init_early() function now initializes the mvebu-mbus driver
    by calling mvebu_mbus_init().
    
    We also convert a number of orion5x_setup_xyz_win() calls to the
    appropriate mvebu_mbus_add_window() calls, as each board was doing its
    own setup for the NOR window or other devices. Ultimately, those
    devices will be probed from the DT.
    
    The common address decoding windows are now registered in the
    orion5x_setup_wins() function. It is worth noting that the four PCIe
    address decoding windows will ultimately no longer have to be
    registered here: it will be done automatically by the PCIe driver once
    Dove has been migrated to use the upcoming mvebu PCIe driver.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index 973db98a3c27..503368023bb1 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -157,8 +157,11 @@ static int __init pcie_setup(struct pci_sys_data *sys)
 	if (dev == MV88F5181_DEV_ID || dev == MV88F5182_DEV_ID) {
 		printk(KERN_NOTICE "Applying Orion-1/Orion-NAS PCIe config "
 				   "read transaction workaround\n");
-		orion5x_setup_pcie_wa_win(ORION5X_PCIE_WA_PHYS_BASE,
-					  ORION5X_PCIE_WA_SIZE);
+		mvebu_mbus_add_window_remap_flags("pcie0.0",
+						  ORION5X_PCIE_WA_PHYS_BASE,
+						  ORION5X_PCIE_WA_SIZE,
+						  MVEBU_MBUS_NO_REMAP,
+						  MVEBU_MBUS_PCI_WA);
 		pcie_ops.read = pcie_rd_conf_wa;
 	}
 

commit 3e762c86b337f6990cdbd71890921b4dd9351ed9
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Wed Mar 6 17:59:58 2013 +0100

    arm: mach-orion5x: use mv_mbus_dram_info() in PCI code
    
    The PCI code was directly accessing the orion_mbus_dram_info structure
    to get access to a description of the SDRAM chip selects in order to
    configure the PCIe -> SDRAM address decoding windows.
    
    However, with the introduction of the mvebu-mbus driver, we are going
    to remove this global structure and instead leave only the exported
    mv_mbus_dram_info() function to access this description of the SDRAM
    chip selects. Therefore, we simply switch to using this API.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index d9c7c3bf0d9c..973db98a3c27 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -402,8 +402,9 @@ static void __init orion5x_pci_master_slave_enable(void)
 	orion5x_pci_hw_wr_conf(bus_nr, 0, func, reg, 4, val | 0x7);
 }
 
-static void __init orion5x_setup_pci_wins(struct mbus_dram_target_info *dram)
+static void __init orion5x_setup_pci_wins(void)
 {
+	const struct mbus_dram_target_info *dram = mv_mbus_dram_info();
 	u32 win_enable;
 	int bus;
 	int i;
@@ -420,7 +421,7 @@ static void __init orion5x_setup_pci_wins(struct mbus_dram_target_info *dram)
 	bus = orion5x_pci_local_bus_nr();
 
 	for (i = 0; i < dram->num_cs; i++) {
-		struct mbus_dram_window *cs = dram->cs + i;
+		const struct mbus_dram_window *cs = dram->cs + i;
 		u32 func = PCI_CONF_FUNC_BAR_CS(cs->cs_index);
 		u32 reg;
 		u32 val;
@@ -467,7 +468,7 @@ static int __init pci_setup(struct pci_sys_data *sys)
 	/*
 	 * Point PCI unit MBUS decode windows to DRAM space.
 	 */
-	orion5x_setup_pci_wins(&orion_mbus_dram_info);
+	orion5x_setup_pci_wins();
 
 	/*
 	 * Master + Slave enable

commit 351a102dbf489d0e9c9b0883f76e2a94d895503d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 14:02:24 2012 -0800

    ARM: drivers: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index cd50e328db2a..d9c7c3bf0d9c 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -506,7 +506,7 @@ static int __init pci_setup(struct pci_sys_data *sys)
 /*****************************************************************************
  * General PCIe + PCI
  ****************************************************************************/
-static void __devinit rc_pci_fixup(struct pci_dev *dev)
+static void rc_pci_fixup(struct pci_dev *dev)
 {
 	/*
 	 * Prevent enumeration of root complex.

commit 0d601f613b8557cf6489f06251ae5dc383b811d0
Merge: d7ffa2234c18 5b40baee4a39
Author: Olof Johansson <olof@lixom.net>
Date:   Sat Sep 22 14:09:21 2012 -0700

    Merge branch 'kirkwood/addr_decode' of git://git.infradead.org/users/jcooper/linux into late/kirkwood
    
    * 'kirkwood/addr_decode' of git://git.infradead.org/users/jcooper/linux:
      arm: mvebu: add address decoding controller to the DT
      arm: mvebu: add basic address decoding support to Armada 370/XP
      arm: plat-orion: make bridge_virt_base non-const to support DT use case
      arm: plat-orion: introduce PLAT_ORION_LEGACY hidden config option
      arm: plat-orion: use void __iomem pointers for addr-map functions
      arm: plat-orion: use void __iomem pointers for time functions
      arm: plat-orion: use void __iomem pointers for MPP functions
      arm: plat-orion: use void __iomem pointers for UART registration functions
      arm: mach-mvebu: use IOMEM() for base address definitions
      arm: mach-orion5x: use IOMEM() for base address definitions
      arm: mach-mv78xx0: use IOMEM() for base address definitions
      arm: mach-kirkwood: use IOMEM() for base address definitions
      arm: mach-dove: use IOMEM() for base address definitions
      arm: mach-orion5x: use plus instead of or for address definitions
      arm: mach-mv78xx0: use plus instead of or for address definitions
      arm: mach-kirkwood: use plus instead of or for address definitions
      arm: mach-dove: use plus instead of or for address definitions
    
    This branch had quite a few conflicts, in particular with the PCI static
    map rework from Rob Herring, and a few other context conflicts due to
    changes in Kconfig, etc.
    
    I fixed up conflicts in:
            arch/arm/Kconfig
            arch/arm/mach-dove/common.c
            arch/arm/mach-dove/include/mach/dove.h
            arch/arm/mach-kirkwood/common.c
            arch/arm/mach-kirkwood/include/mach/kirkwood.h
            arch/arm/mach-mv78xx0/common.c
            arch/arm/mach-mv78xx0/include/mach/mv78xx0.h
            arch/arm/mach-orion5x/common.c
            arch/arm/mach-orion5x/include/mach/orion5x.h
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 3904a39321422d424f790d18a4746b99e1aed0e9
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Tue Sep 11 14:27:21 2012 +0200

    arm: mach-orion5x: use IOMEM() for base address definitions
    
    We now define all virtual base address constants using IOMEM() so that
    those are naturally typed as void __iomem pointers, and we do the
    necessary adjustements in the mach-orion5x code.
    
    Note that we introduce a few temporary additional "unsigned long"
    casts when calling into plat-orion functions. Those are removed by
    followup patches converting plat-orion functions to void __iomem
    pointers as well.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index b36f928d017c..b0822a864e0f 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -38,7 +38,7 @@
 /*****************************************************************************
  * PCIe controller
  ****************************************************************************/
-#define PCIE_BASE	((void __iomem *)ORION5X_PCIE_VIRT_BASE)
+#define PCIE_BASE	(ORION5X_PCIE_VIRT_BASE)
 
 void __init orion5x_pcie_id(u32 *dev, u32 *rev)
 {
@@ -111,7 +111,7 @@ static int pcie_rd_conf_wa(struct pci_bus *bus, u32 devfn,
 		return PCIBIOS_DEVICE_NOT_FOUND;
 	}
 
-	ret = orion_pcie_rd_conf_wa((void __iomem *)ORION5X_PCIE_WA_VIRT_BASE,
+	ret = orion_pcie_rd_conf_wa(ORION5X_PCIE_WA_VIRT_BASE,
 				    bus, devfn, where, size, val);
 
 	return ret;

commit 2332656aec7ae88248cbd9aa6b35c857bb449c94
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Tue Sep 11 14:27:17 2012 +0200

    arm: mach-orion5x: use plus instead of or for address definitions
    
    Since we are going to use IOMEM() to define many base virtual
    addresses, we can no longer use binary or to define the individual
    register addresses ("binary or" arithmetic on pointers is not
    allowed). Instead, use the more conventional plus operator to do so.
    
    The binary or operators were actually not useful because the low-order
    bits of the base address were always zero, so the usage of the binary
    or operators was effectively identical to a plus operator.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index cb19e1661bb3..b36f928d017c 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -198,7 +198,7 @@ static int __init pcie_setup(struct pci_sys_data *sys)
 /*****************************************************************************
  * PCI controller
  ****************************************************************************/
-#define ORION5X_PCI_REG(x)	(ORION5X_PCI_VIRT_BASE | (x))
+#define ORION5X_PCI_REG(x)	(ORION5X_PCI_VIRT_BASE + (x))
 #define PCI_MODE		ORION5X_PCI_REG(0xd00)
 #define PCI_CMD			ORION5X_PCI_REG(0xc00)
 #define PCI_P2P_CONF		ORION5X_PCI_REG(0x1d14)

commit 0a4b8c654615be5dd12d67e951446095bef8b565
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Fri Jul 6 10:59:30 2012 -0500

    ARM: orion5x: use fixed PCI i/o mapping
    
    Move orion5x PCI to fixed i/o mapping and remove io.h.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Lennert Buytenhek <kernel@wantstofly.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index cb19e1661bb3..6921d49b988d 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -162,35 +162,25 @@ static int __init pcie_setup(struct pci_sys_data *sys)
 		pcie_ops.read = pcie_rd_conf_wa;
 	}
 
+	pci_ioremap_io(sys->busnr * SZ_64K, ORION5X_PCIE_IO_PHYS_BASE);
+
 	/*
 	 * Request resources.
 	 */
-	res = kzalloc(sizeof(struct resource) * 2, GFP_KERNEL);
+	res = kzalloc(sizeof(struct resource), GFP_KERNEL);
 	if (!res)
 		panic("pcie_setup unable to alloc resources");
 
-	/*
-	 * IORESOURCE_IO
-	 */
-	sys->io_offset = 0;
-	res[0].name = "PCIe I/O Space";
-	res[0].flags = IORESOURCE_IO;
-	res[0].start = ORION5X_PCIE_IO_BUS_BASE;
-	res[0].end = res[0].start + ORION5X_PCIE_IO_SIZE - 1;
-	if (request_resource(&ioport_resource, &res[0]))
-		panic("Request PCIe IO resource failed\n");
-	pci_add_resource_offset(&sys->resources, &res[0], sys->io_offset);
-
 	/*
 	 * IORESOURCE_MEM
 	 */
-	res[1].name = "PCIe Memory Space";
-	res[1].flags = IORESOURCE_MEM;
-	res[1].start = ORION5X_PCIE_MEM_PHYS_BASE;
-	res[1].end = res[1].start + ORION5X_PCIE_MEM_SIZE - 1;
-	if (request_resource(&iomem_resource, &res[1]))
+	res->name = "PCIe Memory Space";
+	res->flags = IORESOURCE_MEM;
+	res->start = ORION5X_PCIE_MEM_PHYS_BASE;
+	res->end = res->start + ORION5X_PCIE_MEM_SIZE - 1;
+	if (request_resource(&iomem_resource, res))
 		panic("Request PCIe Memory resource failed\n");
-	pci_add_resource_offset(&sys->resources, &res[1], sys->mem_offset);
+	pci_add_resource_offset(&sys->resources, res, sys->mem_offset);
 
 	return 1;
 }
@@ -489,35 +479,25 @@ static int __init pci_setup(struct pci_sys_data *sys)
 	 */
 	orion5x_setbits(PCI_CMD, PCI_CMD_HOST_REORDER);
 
+	pci_ioremap_io(sys->busnr * SZ_64K, ORION5X_PCI_IO_PHYS_BASE);
+
 	/*
 	 * Request resources
 	 */
-	res = kzalloc(sizeof(struct resource) * 2, GFP_KERNEL);
+	res = kzalloc(sizeof(struct resource), GFP_KERNEL);
 	if (!res)
 		panic("pci_setup unable to alloc resources");
 
-	/*
-	 * IORESOURCE_IO
-	 */
-	sys->io_offset = 0;
-	res[0].name = "PCI I/O Space";
-	res[0].flags = IORESOURCE_IO;
-	res[0].start = ORION5X_PCI_IO_BUS_BASE;
-	res[0].end = res[0].start + ORION5X_PCI_IO_SIZE - 1;
-	if (request_resource(&ioport_resource, &res[0]))
-		panic("Request PCI IO resource failed\n");
-	pci_add_resource_offset(&sys->resources, &res[0], sys->io_offset);
-
 	/*
 	 * IORESOURCE_MEM
 	 */
-	res[1].name = "PCI Memory Space";
-	res[1].flags = IORESOURCE_MEM;
-	res[1].start = ORION5X_PCI_MEM_PHYS_BASE;
-	res[1].end = res[1].start + ORION5X_PCI_MEM_SIZE - 1;
-	if (request_resource(&iomem_resource, &res[1]))
+	res->name = "PCI Memory Space";
+	res->flags = IORESOURCE_MEM;
+	res->start = ORION5X_PCI_MEM_PHYS_BASE;
+	res->end = res->start + ORION5X_PCI_MEM_SIZE - 1;
+	if (request_resource(&iomem_resource, res))
 		panic("Request PCI Memory resource failed\n");
-	pci_add_resource_offset(&sys->resources, &res[1], sys->mem_offset);
+	pci_add_resource_offset(&sys->resources, res, sys->mem_offset);
 
 	return 1;
 }

commit 820d41cf0cd0e94a5661e093821e2e5c6b36a9d8
Merge: 6268b325c306 88b48684fe2d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 29 18:02:10 2012 -0700

    Merge tag 'cleanup2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull "ARM: cleanups of io includes" from Olof Johansson:
     "Rob Herring has done a sweeping change cleaning up all of the
      mach/io.h includes, moving some of the oft-repeated macros to a common
      location and removing a bunch of boiler plate.  This is another step
      closer to a common zImage for multiple platforms."
    
    Fix up various fairly trivial conflicts (<mach/io.h> removal vs changes
    around it, tegra localtimer.o is *still* gone, yadda-yadda).
    
    * tag 'cleanup2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (29 commits)
      ARM: tegra: Include assembler.h in sleep.S to fix build break
      ARM: pxa: use common IOMEM definition
      ARM: dma-mapping: convert ARCH_HAS_DMA_SET_COHERENT_MASK to kconfig symbol
      ARM: __io abuse cleanup
      ARM: create a common IOMEM definition
      ARM: iop13xx: fix missing declaration of iop13xx_init_early
      ARM: fix ioremap/iounmap for !CONFIG_MMU
      ARM: kill off __mem_pci
      ARM: remove bunch of now unused mach/io.h files
      ARM: make mach/io.h include optional
      ARM: clps711x: remove unneeded include of mach/io.h
      ARM: dove: add explicit include of dove.h to addr-map.c
      ARM: at91: add explicit include of hardware.h to uncompressor
      ARM: ep93xx: clean-up mach/io.h
      ARM: tegra: clean-up mach/io.h
      ARM: orion5x: clean-up mach/io.h
      ARM: davinci: remove unneeded mach/io.h include
      [media] davinci: remove includes of mach/io.h
      ARM: OMAP: Remove remaining includes for mach/io.h
      ARM: msm: clean-up mach/io.h
      ...

commit 8a52dd4f94abe147bbd4080664817a389c8b6818
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Fri Feb 10 18:29:09 2012 -0600

    ARM: orion5x: clean-up mach/io.h
    
    Move orion5x specific mach/io.h parts into common.h.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Lennert Buytenhek <kernel@wantstofly.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index 09a045f0c406..a9d21510c974 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -19,6 +19,7 @@
 #include <asm/mach/pci.h>
 #include <plat/pcie.h>
 #include <plat/addr-map.h>
+#include <mach/orion5x.h>
 #include "common.h"
 
 /*****************************************************************************

commit 9f786d033d025ab7d2c4d1b959aa81d935eb9e19
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 23 20:19:01 2012 -0700

    arm/PCI: get rid of device resource fixups
    
    Tell the PCI core about host bridge address translation so it can take
    care of bus-to-resource conversion for us.
    
    CC: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index 09a045f0c406..d6a91948e4dc 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -171,13 +171,14 @@ static int __init pcie_setup(struct pci_sys_data *sys)
 	/*
 	 * IORESOURCE_IO
 	 */
+	sys->io_offset = 0;
 	res[0].name = "PCIe I/O Space";
 	res[0].flags = IORESOURCE_IO;
 	res[0].start = ORION5X_PCIE_IO_BUS_BASE;
 	res[0].end = res[0].start + ORION5X_PCIE_IO_SIZE - 1;
 	if (request_resource(&ioport_resource, &res[0]))
 		panic("Request PCIe IO resource failed\n");
-	pci_add_resource(&sys->resources, &res[0]);
+	pci_add_resource_offset(&sys->resources, &res[0], sys->io_offset);
 
 	/*
 	 * IORESOURCE_MEM
@@ -188,9 +189,7 @@ static int __init pcie_setup(struct pci_sys_data *sys)
 	res[1].end = res[1].start + ORION5X_PCIE_MEM_SIZE - 1;
 	if (request_resource(&iomem_resource, &res[1]))
 		panic("Request PCIe Memory resource failed\n");
-	pci_add_resource(&sys->resources, &res[1]);
-
-	sys->io_offset = 0;
+	pci_add_resource_offset(&sys->resources, &res[1], sys->mem_offset);
 
 	return 1;
 }
@@ -499,13 +498,14 @@ static int __init pci_setup(struct pci_sys_data *sys)
 	/*
 	 * IORESOURCE_IO
 	 */
+	sys->io_offset = 0;
 	res[0].name = "PCI I/O Space";
 	res[0].flags = IORESOURCE_IO;
 	res[0].start = ORION5X_PCI_IO_BUS_BASE;
 	res[0].end = res[0].start + ORION5X_PCI_IO_SIZE - 1;
 	if (request_resource(&ioport_resource, &res[0]))
 		panic("Request PCI IO resource failed\n");
-	pci_add_resource(&sys->resources, &res[0]);
+	pci_add_resource_offset(&sys->resources, &res[0], sys->io_offset);
 
 	/*
 	 * IORESOURCE_MEM
@@ -516,9 +516,7 @@ static int __init pci_setup(struct pci_sys_data *sys)
 	res[1].end = res[1].start + ORION5X_PCI_MEM_SIZE - 1;
 	if (request_resource(&iomem_resource, &res[1]))
 		panic("Request PCI Memory resource failed\n");
-	pci_add_resource(&sys->resources, &res[1]);
-
-	sys->io_offset = 0;
+	pci_add_resource_offset(&sys->resources, &res[1], sys->mem_offset);
 
 	return 1;
 }

commit 7b67e751479d50b7f84d1a3cc5216eed5e534b66
Merge: 9f13a1fd452f 76ccc297018d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 11 18:50:26 2012 -0800

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci: (80 commits)
      x86/PCI: Expand the x86_msi_ops to have a restore MSIs.
      PCI: Increase resource array mask bit size in pcim_iomap_regions()
      PCI: DEVICE_COUNT_RESOURCE should be equal to PCI_NUM_RESOURCES
      PCI: pci_ids: add device ids for STA2X11 device (aka ConneXT)
      PNP: work around Dell 1536/1546 BIOS MMCONFIG bug that breaks USB
      x86/PCI: amd: factor out MMCONFIG discovery
      PCI: Enable ATS at the device state restore
      PCI: msi: fix imbalanced refcount of msi irq sysfs objects
      PCI: kconfig: English typo in pci/pcie/Kconfig
      PCI/PM/Runtime: make PCI traces quieter
      PCI: remove pci_create_bus()
      xtensa/PCI: convert to pci_scan_root_bus() for correct root bus resources
      x86/PCI: convert to pci_create_root_bus() and pci_scan_root_bus()
      x86/PCI: use pci_scan_bus() instead of pci_scan_bus_parented()
      x86/PCI: read Broadcom CNB20LE host bridge info before PCI scan
      sparc32, leon/PCI: convert to pci_scan_root_bus() for correct root bus resources
      sparc/PCI: convert to pci_create_root_bus()
      sh/PCI: convert to pci_scan_root_bus() for correct root bus resources
      powerpc/PCI: convert to pci_create_root_bus()
      powerpc/PCI: split PHB part out of pcibios_map_io_space()
      ...
    
    Fix up conflicts in drivers/pci/msi.c and include/linux/pci_regs.h due
    to the same patches being applied in other branches.

commit 37d15909ff6bf6e97e1d4447efa7f1a19e7a508e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 28 16:26:16 2011 -0600

    arm/PCI: convert to pci_scan_root_bus() for correct root bus resources
    
    Convert from pci_scan_bus() to pci_scan_root_bus() and remove root bus
    resource fixups.  This fixes the problem of "early" and "header" quirks
    seeing incorrect root bus resources.
    
    CC: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index bc4a920e26ee..4eb93647aab7 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -176,7 +176,7 @@ static int __init pcie_setup(struct pci_sys_data *sys)
 	res[0].end = res[0].start + ORION5X_PCIE_IO_SIZE - 1;
 	if (request_resource(&ioport_resource, &res[0]))
 		panic("Request PCIe IO resource failed\n");
-	sys->resource[0] = &res[0];
+	pci_add_resource(&sys->resources, &res[0]);
 
 	/*
 	 * IORESOURCE_MEM
@@ -187,9 +187,8 @@ static int __init pcie_setup(struct pci_sys_data *sys)
 	res[1].end = res[1].start + ORION5X_PCIE_MEM_SIZE - 1;
 	if (request_resource(&iomem_resource, &res[1]))
 		panic("Request PCIe Memory resource failed\n");
-	sys->resource[1] = &res[1];
+	pci_add_resource(&sys->resources, &res[1]);
 
-	sys->resource[2] = NULL;
 	sys->io_offset = 0;
 
 	return 1;
@@ -505,7 +504,7 @@ static int __init pci_setup(struct pci_sys_data *sys)
 	res[0].end = res[0].start + ORION5X_PCI_IO_SIZE - 1;
 	if (request_resource(&ioport_resource, &res[0]))
 		panic("Request PCI IO resource failed\n");
-	sys->resource[0] = &res[0];
+	pci_add_resource(&sys->resources, &res[0]);
 
 	/*
 	 * IORESOURCE_MEM
@@ -516,9 +515,8 @@ static int __init pci_setup(struct pci_sys_data *sys)
 	res[1].end = res[1].start + ORION5X_PCI_MEM_SIZE - 1;
 	if (request_resource(&iomem_resource, &res[1]))
 		panic("Request PCI Memory resource failed\n");
-	sys->resource[1] = &res[1];
+	pci_add_resource(&sys->resources, &res[1]);
 
-	sys->resource[2] = NULL;
 	sys->io_offset = 0;
 
 	return 1;
@@ -579,9 +577,11 @@ struct pci_bus __init *orion5x_pci_sys_scan_bus(int nr, struct pci_sys_data *sys
 	struct pci_bus *bus;
 
 	if (nr == 0) {
-		bus = pci_scan_bus(sys->busnr, &pcie_ops, sys);
+		bus = pci_scan_root_bus(NULL, sys->busnr, &pcie_ops, sys,
+					&sys->resources);
 	} else if (nr == 1 && !orion5x_pci_disabled) {
-		bus = pci_scan_bus(sys->busnr, &pci_ops, sys);
+		bus = pci_scan_root_bus(NULL, sys->busnr, &pci_ops, sys,
+					&sys->resources);
 	} else {
 		bus = NULL;
 		BUG();

commit 63a9332b232bdab0df6ef18a9f39e8d58a82bda4
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Dec 7 21:48:07 2011 +0100

    ARM: Orion: Get address map from plat-orion instead of via platform_data
    
    Use an getter function in plat-orion/addr-map.c to get the address map
    structure, rather than pass it to drivers in the platform_data
    structures. When the drivers are built for none orion platforms, a
    dummy function is provided instead which returns NULL.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Tested-by: Michael Walle <michael@walle.cc>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index ddfa01acdaaa..a494c470e3e4 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -146,7 +146,7 @@ static int __init pcie_setup(struct pci_sys_data *sys)
 	/*
 	 * Generic PCIe unit setup.
 	 */
-	orion_pcie_setup(PCIE_BASE, &orion_mbus_dram_info);
+	orion_pcie_setup(PCIE_BASE);
 
 	/*
 	 * Check whether to apply Orion-1/Orion-NAS PCIe config

commit 45173d5ed4c9a397db31623bf6469efbd3a239cd
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Dec 7 21:48:06 2011 +0100

    ARM: Orion: mbus_dram_info consolidation
    
    Move the *_mbus_dram_info structure into the orion platform and call it
    orion_mbus_dram_info everywhere.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Tested-by: Michael Walle <michael@walle.cc>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index bc4a920e26ee..ddfa01acdaaa 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -18,6 +18,7 @@
 #include <asm/irq.h>
 #include <asm/mach/pci.h>
 #include <plat/pcie.h>
+#include <plat/addr-map.h>
 #include "common.h"
 
 /*****************************************************************************
@@ -145,7 +146,7 @@ static int __init pcie_setup(struct pci_sys_data *sys)
 	/*
 	 * Generic PCIe unit setup.
 	 */
-	orion_pcie_setup(PCIE_BASE, &orion5x_mbus_dram_info);
+	orion_pcie_setup(PCIE_BASE, &orion_mbus_dram_info);
 
 	/*
 	 * Check whether to apply Orion-1/Orion-NAS PCIe config
@@ -477,7 +478,7 @@ static int __init pci_setup(struct pci_sys_data *sys)
 	/*
 	 * Point PCI unit MBUS decode windows to DRAM space.
 	 */
-	orion5x_setup_pci_wins(&orion5x_mbus_dram_info);
+	orion5x_setup_pci_wins(&orion_mbus_dram_info);
 
 	/*
 	 * Master + Slave enable

commit 158c0c623ab57e4e1cf705ce64b8efddc1cf82dd
Author: Bryan Wu <bryan.wu@canonical.com>
Date:   Wed Aug 17 17:29:38 2011 +0800

    ARM: mach-orion5x: add missing header file <linux/vga.h>
    
    This patch fixed following building error:
    --
    arch/arm/mach-orion5x/pci.c: In function 'orion5x_pci_sys_setup':
    arch/arm/mach-orion5x/pci.c:563:2: error: 'vga_base' undeclared (first use in this function)
    arch/arm/mach-orion5x/pci.c:563:2: note: each undeclared identifier is reported only once for each function it appears in
    make[1]: *** [arch/arm/mach-orion5x/pci.o] Error 1
    make[1]: *** Waiting for unfinished jobs....
    --
    
    Signed-off-by: Bryan Wu <bryan.wu@canonical.com>
    Acked-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index 28b8760ab9fa..bc4a920e26ee 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -14,6 +14,7 @@
 #include <linux/pci.h>
 #include <linux/slab.h>
 #include <linux/mbus.h>
+#include <video/vga.h>
 #include <asm/irq.h>
 #include <asm/mach/pci.h>
 #include <plat/pcie.h>

commit f85f19de90a9997583bb26e6f1f9297a4e152c18
Merge: b993fdbc7fe2 7b87c9df5602
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 29 23:35:05 2011 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6:
      PCI: remove printks about disabled bridge windows
      PCI: fold pci_calc_resource_flags() into decode_bar()
      PCI: treat mem BAR type "11" (reserved) as 32-bit, not 64-bit, BAR
      PCI: correct pcie_set_readrq write size
      PCI: pciehp: change wait time for valid configuration access
      x86/PCI: Preserve existing pci=bfsort whitelist for Dell systems
      PCI: ARI is a PCIe v2 feature
      x86/PCI: quirks: Use pci_dev->revision
      PCI: Make the struct pci_dev * argument of pci_fixup_irqs const.
      PCI hotplug: cpqphp: use pci_dev->vendor
      PCI hotplug: cpqphp: use pci_dev->subsystem_{vendor|device}
      x86/PCI: config space accessor functions should not ignore the segment argument
      PCI: Assign values to 'pci_obff_signal_type' enumeration constants
      x86/PCI: reduce severity of host bridge window conflict warnings
      PCI: enumerate the PCI device only removed out PCI hieratchy of OS when re-scanning PCI
      PCI: PCIe AER: add aer_recover_queue
      x86/PCI: select direct access mode for mmconfig option
      PCI hotplug: Rename is_ejectable which also exists in dock.c

commit d5341942d784134f2997b3ff82cd63cf71d1f932
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Jun 10 15:30:21 2011 +0100

    PCI: Make the struct pci_dev * argument of pci_fixup_irqs const.
    
    Aside of the usual motivation for constification,  this function has a
    history of being abused a hook for interrupt and other fixups so I turned
    this function const ages ago in the MIPS code but it should be done
    treewide.
    
    Due to function pointer passing in varous places a few other functions
    had to be constified as well.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    To: Anton Vorontsov <avorontsov@mvista.com>
    To: Chris Metcalf <cmetcalf@tilera.com>
    To: Colin Cross <ccross@android.com>
    Acked-by: "David S. Miller" <davem@davemloft.net>
    To: Eric Miao <eric.y.miao@gmail.com>
    To: Erik Gilling <konkers@android.com>
    Acked-by: Guan Xuetao <gxt@mprc.pku.edu.cn>
    To: "H. Peter Anvin" <hpa@zytor.com>
    To: Imre Kaloz <kaloz@openwrt.org>
    To: Ingo Molnar <mingo@redhat.com>
    To: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    To: Jesse Barnes <jbarnes@virtuousgeek.org>
    To: Krzysztof Halasa <khc@pm.waw.pl>
    To: Lennert Buytenhek <kernel@wantstofly.org>
    To: Matt Turner <mattst88@gmail.com>
    To: Nicolas Pitre <nico@fluxnic.net>
    To: Olof Johansson <olof@lixom.net>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    To: Richard Henderson <rth@twiddle.net>
    To: Russell King <linux@arm.linux.org.uk>
    To: Thomas Gleixner <tglx@linutronix.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: linux-alpha@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Cc: linux-pci@vger.kernel.org
    Cc: linux-sh@vger.kernel.org
    Cc: linux-tegra@vger.kernel.org
    Cc: sparclinux@vger.kernel.org
    Cc: x86@kernel.org
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index e8706f15a670..0415250396d4 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -587,7 +587,7 @@ struct pci_bus __init *orion5x_pci_sys_scan_bus(int nr, struct pci_sys_data *sys
 	return bus;
 }
 
-int __init orion5x_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+int __init orion5x_pci_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 {
 	int bus = dev->bus->number;
 

commit cc22b4c18540e5e8bf55c7d124044f9317527d3c
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Tue Jun 28 21:22:40 2011 -0500

    ARM: set vga memory base at run-time
    
    Convert the incorrectly named PCIMEM_BASE to a variable called vga_base.
    This removes the dependency on mach/hardware.h.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index e8706f15a670..f64965d4f8e8 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -560,6 +560,8 @@ int __init orion5x_pci_sys_setup(int nr, struct pci_sys_data *sys)
 {
 	int ret = 0;
 
+	vga_base = ORION5X_PCIE_MEM_PHYS_BASE;
+
 	if (nr == 0) {
 		orion_pcie_set_local_bus_nr(PCIE_BASE, sys->busnr);
 		ret = pcie_setup(sys);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index bdf96eb523bc..e8706f15a670 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -12,6 +12,7 @@
 
 #include <linux/kernel.h>
 #include <linux/pci.h>
+#include <linux/slab.h>
 #include <linux/mbus.h>
 #include <asm/irq.h>
 #include <asm/mach/pci.h>

commit af901ca181d92aac3a7dc265144a9081a86d8f39
Author: André Goddard Rosa <andre.goddard@gmail.com>
Date:   Sat Nov 14 13:09:05 2009 -0200

    tree-wide: fix assorted typos all over the place
    
    That is "success", "unknown", "through", "performance", "[re|un]mapping"
    , "access", "default", "reasonable", "[con]currently", "temperature"
    , "channel", "[un]used", "application", "example","hierarchy", "therefore"
    , "[over|under]flow", "contiguous", "threshold", "enough" and others.
    
    Signed-off-by: André Goddard Rosa <andre.goddard@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index 36dc5413cc97..bdf96eb523bc 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -463,7 +463,7 @@ static void __init orion5x_setup_pci_wins(struct mbus_dram_target_info *dram)
 	writel(win_enable, PCI_BAR_ENABLE);
 
 	/*
-	 * Disable automatic update of address remaping when writing to BARs.
+	 * Disable automatic update of address remapping when writing to BARs.
 	 */
 	orion5x_setbits(PCI_ADDR_DECODE_CTRL, 1);
 }

commit fdd8b079e33d4711527ace19798e9db99a056469
Author: Nicolas Pitre <nico@cam.org>
Date:   Wed Apr 22 20:08:17 2009 +0100

    [ARM] 5460/1: Orion: reduce namespace pollution
    
    Symbols like SOFT_RESET are way too generic to be exported at large.
    To avoid this, let's move the mbus bridge register defines into a
    separate file and include it where needed.  This affects mach-kirkwood,
    mach-loki, mach-mv78xx0 and mach-orion5x simultaneously as they all
    share code in plat-orion which relies on those defines.
    
    Some other defines have been moved to narrower scopes, or simply deleted
    when they had no user.
    
    This fixes compilation problem with mpt2sas on the above listed
    platforms.
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index d0a785a3b880..36dc5413cc97 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -196,6 +196,7 @@ static int __init pcie_setup(struct pci_sys_data *sys)
 /*****************************************************************************
  * PCI controller
  ****************************************************************************/
+#define ORION5X_PCI_REG(x)	(ORION5X_PCI_VIRT_BASE | (x))
 #define PCI_MODE		ORION5X_PCI_REG(0xd00)
 #define PCI_CMD			ORION5X_PCI_REG(0xc00)
 #define PCI_P2P_CONF		ORION5X_PCI_REG(0x1d14)

commit ff89c462dfe0df04f8938d513546896c2ddab525
Author: Nicolas Pitre <nico@cam.org>
Date:   Wed Jan 7 04:52:58 2009 +0100

    [ARM] 5360/1: Orion: fix compilation error
    
    Commit ba84be2338d3 broke the build.
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index a7b7d77b1b09..d0a785a3b880 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -13,6 +13,7 @@
 #include <linux/kernel.h>
 #include <linux/pci.h>
 #include <linux/mbus.h>
+#include <asm/irq.h>
 #include <asm/mach/pci.h>
 #include <plat/pcie.h>
 #include "common.h"

commit 7a6bb2622692495d1b7445a3e8c257601b803b02
Author: Per Andersson <avtobiff@gmail.com>
Date:   Mon Aug 11 12:00:52 2008 +0200

    [ARM] Orion: Fix boot crash on Kurobox Pro
    
    The Kurobox Pro crashes when any of the PCI controller registers
    are accessed.  This patch adds a function to the Orion PCI handling
    code that board support code can call to disable enumerating the
    PCI bus entirely, and makes the Kurobox Pro PCI-related init code
    call this function.
    
    Signed-off-by: Per Andersson <avtobiff@gmail.com>
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index fbceecc4b7ec..a7b7d77b1b09 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -541,6 +541,13 @@ static void __devinit rc_pci_fixup(struct pci_dev *dev)
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL, PCI_ANY_ID, rc_pci_fixup);
 
+static int orion5x_pci_disabled __initdata;
+
+void __init orion5x_pci_disable(void)
+{
+	orion5x_pci_disabled = 1;
+}
+
 void __init orion5x_pci_set_cardbus_mode(void)
 {
 	orion5x_pci_cardbus_mode = 1;
@@ -553,7 +560,7 @@ int __init orion5x_pci_sys_setup(int nr, struct pci_sys_data *sys)
 	if (nr == 0) {
 		orion_pcie_set_local_bus_nr(PCIE_BASE, sys->busnr);
 		ret = pcie_setup(sys);
-	} else if (nr == 1) {
+	} else if (nr == 1 && !orion5x_pci_disabled) {
 		orion5x_pci_set_bus_nr(sys->busnr);
 		ret = pci_setup(sys);
 	}
@@ -567,7 +574,7 @@ struct pci_bus __init *orion5x_pci_sys_scan_bus(int nr, struct pci_sys_data *sys
 
 	if (nr == 0) {
 		bus = pci_scan_bus(sys->busnr, &pcie_ops, sys);
-	} else if (nr == 1) {
+	} else if (nr == 1 && !orion5x_pci_disabled) {
 		bus = pci_scan_bus(sys->busnr, &pci_ops, sys);
 	} else {
 		bus = NULL;
@@ -584,7 +591,7 @@ int __init orion5x_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 	/*
 	 * PCIe endpoint?
 	 */
-	if (bus < orion5x_pci_local_bus_nr())
+	if (orion5x_pci_disabled || bus < orion5x_pci_local_bus_nr())
 		return IRQ_ORION5X_PCIE0_INT;
 
 	return -1;

commit 6f088f1d215be5250582b974f83f0e3aa6ad3a28
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Sat Aug 9 13:44:58 2008 +0200

    [ARM] Move include/asm-arm/plat-orion to arch/arm/plat-orion/include/plat
    
    This patch performs the equivalent include directory shuffle for
    plat-orion, and fixes up all users.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index 256a4f680935..fbceecc4b7ec 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -14,7 +14,7 @@
 #include <linux/pci.h>
 #include <linux/mbus.h>
 #include <asm/mach/pci.h>
-#include <asm/plat-orion/pcie.h>
+#include <plat/pcie.h>
 #include "common.h"
 
 /*****************************************************************************

commit da01bba3cb8814b17d809e09c301e1dad86fec87
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Thu Jun 26 17:12:50 2008 +0200

    [ARM] Orion: make PCI handling code deal with Cardbus slots
    
    The Cardbus connector does not have an IDSEL signal, and Cardbus
    cards are always the intended target of configuration transactions
    on their local PCI bus.  This means that if the Orion's PCI bus
    signals are hooked up to a Cardbus slot, the same set of PCI
    functions will will appear 31 times, for each of the PCI device
    IDs 1-31 (ID 0 is the host bridge).
    
    This patch adds a function to the Orion PCI handling code that board
    support code can call to enable Cardbus mode.  When Cardbus mode is
    enabled, configuration transactions on the PCI local bus are only
    allowed to PCI IDs 0 (host bridge) and 1 (cardbus device).
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index 025ef63b1ddb..256a4f680935 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -266,6 +266,8 @@ static int __init pcie_setup(struct pci_sys_data *sys)
  */
 static DEFINE_SPINLOCK(orion5x_pci_lock);
 
+static int orion5x_pci_cardbus_mode;
+
 static int orion5x_pci_local_bus_nr(void)
 {
 	u32 conf = readl(PCI_P2P_CONF);
@@ -321,14 +323,30 @@ static int orion5x_pci_hw_wr_conf(int bus, int dev, u32 func,
 	return ret;
 }
 
+static int orion5x_pci_valid_config(int bus, u32 devfn)
+{
+	if (bus == orion5x_pci_local_bus_nr()) {
+		/*
+		 * Don't go out for local device
+		 */
+		if (PCI_SLOT(devfn) == 0 && PCI_FUNC(devfn) != 0)
+			return 0;
+
+		/*
+		 * When the PCI signals are directly connected to a
+		 * Cardbus slot, ignore all but device IDs 0 and 1.
+		 */
+		if (orion5x_pci_cardbus_mode && PCI_SLOT(devfn) > 1)
+			return 0;
+	}
+
+	return 1;
+}
+
 static int orion5x_pci_rd_conf(struct pci_bus *bus, u32 devfn,
 				int where, int size, u32 *val)
 {
-	/*
-	 * Don't go out for local device
-	 */
-	if (bus->number == orion5x_pci_local_bus_nr() &&
-	    PCI_SLOT(devfn) == 0 && PCI_FUNC(devfn) != 0) {
+	if (!orion5x_pci_valid_config(bus->number, devfn)) {
 		*val = 0xffffffff;
 		return PCIBIOS_DEVICE_NOT_FOUND;
 	}
@@ -340,8 +358,7 @@ static int orion5x_pci_rd_conf(struct pci_bus *bus, u32 devfn,
 static int orion5x_pci_wr_conf(struct pci_bus *bus, u32 devfn,
 				int where, int size, u32 val)
 {
-	if (bus->number == orion5x_pci_local_bus_nr() &&
-	    PCI_SLOT(devfn) == 0 && PCI_FUNC(devfn) != 0)
+	if (!orion5x_pci_valid_config(bus->number, devfn))
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
 	return orion5x_pci_hw_wr_conf(bus->number, PCI_SLOT(devfn),
@@ -524,6 +541,11 @@ static void __devinit rc_pci_fixup(struct pci_dev *dev)
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL, PCI_ANY_ID, rc_pci_fixup);
 
+void __init orion5x_pci_set_cardbus_mode(void)
+{
+	orion5x_pci_cardbus_mode = 1;
+}
+
 int __init orion5x_pci_sys_setup(int nr, struct pci_sys_data *sys)
 {
 	int ret = 0;

commit 79e90dd5aa95adfdc3117db8a559da3d0195ba58
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Wed May 28 16:43:48 2008 +0200

    [ARM] Orion: nuke orion5x_{read,write}
    
    Nuke the Orion-specific orion5x_{read,write} wrappers.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index 275a50046c1f..025ef63b1ddb 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -268,7 +268,7 @@ static DEFINE_SPINLOCK(orion5x_pci_lock);
 
 static int orion5x_pci_local_bus_nr(void)
 {
-	u32 conf = orion5x_read(PCI_P2P_CONF);
+	u32 conf = readl(PCI_P2P_CONF);
 	return((conf & PCI_P2P_BUS_MASK) >> PCI_P2P_BUS_OFFS);
 }
 
@@ -278,11 +278,11 @@ static int orion5x_pci_hw_rd_conf(int bus, int dev, u32 func,
 	unsigned long flags;
 	spin_lock_irqsave(&orion5x_pci_lock, flags);
 
-	orion5x_write(PCI_CONF_ADDR, PCI_CONF_BUS(bus) |
-			PCI_CONF_DEV(dev) | PCI_CONF_REG(where) |
-			PCI_CONF_FUNC(func) | PCI_CONF_ADDR_EN);
+	writel(PCI_CONF_BUS(bus) |
+		PCI_CONF_DEV(dev) | PCI_CONF_REG(where) |
+		PCI_CONF_FUNC(func) | PCI_CONF_ADDR_EN, PCI_CONF_ADDR);
 
-	*val = orion5x_read(PCI_CONF_DATA);
+	*val = readl(PCI_CONF_DATA);
 
 	if (size == 1)
 		*val = (*val >> (8*(where & 0x3))) & 0xff;
@@ -302,9 +302,9 @@ static int orion5x_pci_hw_wr_conf(int bus, int dev, u32 func,
 
 	spin_lock_irqsave(&orion5x_pci_lock, flags);
 
-	orion5x_write(PCI_CONF_ADDR, PCI_CONF_BUS(bus) |
-			PCI_CONF_DEV(dev) | PCI_CONF_REG(where) |
-			PCI_CONF_FUNC(func) | PCI_CONF_ADDR_EN);
+	writel(PCI_CONF_BUS(bus) |
+		PCI_CONF_DEV(dev) | PCI_CONF_REG(where) |
+		PCI_CONF_FUNC(func) | PCI_CONF_ADDR_EN, PCI_CONF_ADDR);
 
 	if (size == 4) {
 		__raw_writel(val, PCI_CONF_DATA);
@@ -355,9 +355,9 @@ static struct pci_ops pci_ops = {
 
 static void __init orion5x_pci_set_bus_nr(int nr)
 {
-	u32 p2p = orion5x_read(PCI_P2P_CONF);
+	u32 p2p = readl(PCI_P2P_CONF);
 
-	if (orion5x_read(PCI_MODE) & PCI_MODE_PCIX) {
+	if (readl(PCI_MODE) & PCI_MODE_PCIX) {
 		/*
 		 * PCI-X mode
 		 */
@@ -374,7 +374,7 @@ static void __init orion5x_pci_set_bus_nr(int nr)
 		 */
 		p2p &= ~PCI_P2P_BUS_MASK;
 		p2p |= (nr << PCI_P2P_BUS_OFFS);
-		orion5x_write(PCI_P2P_CONF, p2p);
+		writel(p2p, PCI_P2P_CONF);
 	}
 }
 
@@ -401,7 +401,7 @@ static void __init orion5x_setup_pci_wins(struct mbus_dram_target_info *dram)
 	 * First, disable windows.
 	 */
 	win_enable = 0xffffffff;
-	orion5x_write(PCI_BAR_ENABLE, win_enable);
+	writel(win_enable, PCI_BAR_ENABLE);
 
 	/*
 	 * Setup windows for DDR banks.
@@ -427,10 +427,10 @@ static void __init orion5x_setup_pci_wins(struct mbus_dram_target_info *dram)
 		 */
 		reg = PCI_CONF_REG_BAR_HI_CS(cs->cs_index);
 		orion5x_pci_hw_wr_conf(bus, 0, func, reg, 4, 0);
-		orion5x_write(PCI_BAR_SIZE_DDR_CS(cs->cs_index),
-				(cs->size - 1) & 0xfffff000);
-		orion5x_write(PCI_BAR_REMAP_DDR_CS(cs->cs_index),
-				cs->base & 0xfffff000);
+		writel((cs->size - 1) & 0xfffff000,
+			PCI_BAR_SIZE_DDR_CS(cs->cs_index));
+		writel(cs->base & 0xfffff000,
+			PCI_BAR_REMAP_DDR_CS(cs->cs_index));
 
 		/*
 		 * Enable decode window for this chip select.
@@ -441,7 +441,7 @@ static void __init orion5x_setup_pci_wins(struct mbus_dram_target_info *dram)
 	/*
 	 * Re-enable decode windows.
 	 */
-	orion5x_write(PCI_BAR_ENABLE, win_enable);
+	writel(win_enable, PCI_BAR_ENABLE);
 
 	/*
 	 * Disable automatic update of address remaping when writing to BARs.

commit 386a048a1ea42ff9ac87ffa344c4c19a5cc59678
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Sat May 10 17:01:18 2008 +0200

    [ARM] Orion: move setting up PCIe WA window into PCIe setup path
    
    It makes no sense to do PCIe WA window setup in the individual
    board support files while the decision whether or not to use the
    PCIe WA access method is made in a different place, in the PCIe
    support code.
    
    This patch moves the configuration of a PCIe WA window from the
    individual Orion board support files to the central Orion PCIe
    support code.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Acked-by: Russell King <linux@arm.linux.org.uk>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index 1bbfe24607b0..275a50046c1f 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -152,6 +152,8 @@ static int __init pcie_setup(struct pci_sys_data *sys)
 	if (dev == MV88F5181_DEV_ID || dev == MV88F5182_DEV_ID) {
 		printk(KERN_NOTICE "Applying Orion-1/Orion-NAS PCIe config "
 				   "read transaction workaround\n");
+		orion5x_setup_pcie_wa_win(ORION5X_PCIE_WA_PHYS_BASE,
+					  ORION5X_PCIE_WA_SIZE);
 		pcie_ops.read = pcie_rd_conf_wa;
 	}
 

commit e7068ad337a991fba627148a4a57939fdc1e6a2d
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Sat May 10 16:30:01 2008 +0200

    [ARM] Orion: fix various whitespace and coding style issues
    
    More cosmetic cleanup:
    - Replace 8-space indents by proper tab indents.
    - In structure initialisers, use a trailing comma for every member.
    - Collapse "},\n{" in structure initialiers to "}, {".
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Acked-by: Russell King <linux@arm.linux.org.uk>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index 9d5d39fa19c3..1bbfe24607b0 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -240,13 +240,13 @@ static int __init pcie_setup(struct pci_sys_data *sys)
  * PCI Address Decode Windows registers
  */
 #define PCI_BAR_SIZE_DDR_CS(n)	(((n) == 0) ? ORION5X_PCI_REG(0xc08) : \
-				((n) == 1) ? ORION5X_PCI_REG(0xd08) :  \
-				((n) == 2) ? ORION5X_PCI_REG(0xc0c) :  \
-				((n) == 3) ? ORION5X_PCI_REG(0xd0c) : 0)
-#define PCI_BAR_REMAP_DDR_CS(n)	(((n) ==0) ? ORION5X_PCI_REG(0xc48) :  \
-				((n) == 1) ? ORION5X_PCI_REG(0xd48) :  \
-				((n) == 2) ? ORION5X_PCI_REG(0xc4c) :  \
-				((n) == 3) ? ORION5X_PCI_REG(0xd4c) : 0)
+				 ((n) == 1) ? ORION5X_PCI_REG(0xd08) : \
+				 ((n) == 2) ? ORION5X_PCI_REG(0xc0c) : \
+				 ((n) == 3) ? ORION5X_PCI_REG(0xd0c) : 0)
+#define PCI_BAR_REMAP_DDR_CS(n)	(((n) == 0) ? ORION5X_PCI_REG(0xc48) : \
+				 ((n) == 1) ? ORION5X_PCI_REG(0xd48) : \
+				 ((n) == 2) ? ORION5X_PCI_REG(0xc4c) : \
+				 ((n) == 3) ? ORION5X_PCI_REG(0xd4c) : 0)
 #define PCI_BAR_ENABLE		ORION5X_PCI_REG(0xc3c)
 #define PCI_ADDR_DECODE_CTRL	ORION5X_PCI_REG(0xd3c)
 

commit 92b913b08b18faa487b0c744282fafd944446ade
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Fri Apr 25 16:28:33 2008 -0400

    [ARM] Orion: fix ->map_irq() PCIe bus number check
    
    The current orion5x board ->map_irq() routines check whether a
    given bus number lives on the PCIe controller by comparing it with
    the PCIe controller's primary bus number.  This doesn't work in
    case there are multiple buses in the PCIe domain, i.e. if there
    exists a PCIe bridge on the primary PCIe bus.
    
    This patch adds a helper function (orion5x_pci_map_irq()) that
    returns the IRQ number for the given PCI device if that device has
    a hard-wired IRQ, or -1 otherwise, and makes each board's
    ->map_irq() function use this helper function.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Signed-off-by: Nicolas Pitre <nico@marvell.com>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index fdf99fca85b3..9d5d39fa19c3 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -41,11 +41,6 @@ void __init orion5x_pcie_id(u32 *dev, u32 *rev)
 	*rev = orion_pcie_rev(PCIE_BASE);
 }
 
-int __init orion5x_pcie_local_bus_nr(void)
-{
-	return orion_pcie_get_local_bus_nr(PCIE_BASE);
-}
-
 static int pcie_valid_config(int bus, int dev)
 {
 	/*
@@ -269,7 +264,7 @@ static int __init pcie_setup(struct pci_sys_data *sys)
  */
 static DEFINE_SPINLOCK(orion5x_pci_lock);
 
-int orion5x_pci_local_bus_nr(void)
+static int orion5x_pci_local_bus_nr(void)
 {
 	u32 conf = orion5x_read(PCI_P2P_CONF);
 	return((conf & PCI_P2P_BUS_MASK) >> PCI_P2P_BUS_OFFS);
@@ -557,3 +552,16 @@ struct pci_bus __init *orion5x_pci_sys_scan_bus(int nr, struct pci_sys_data *sys
 
 	return bus;
 }
+
+int __init orion5x_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int bus = dev->bus->number;
+
+	/*
+	 * PCIe endpoint?
+	 */
+	if (bus < orion5x_pci_local_bus_nr())
+		return IRQ_ORION5X_PCIE0_INT;
+
+	return -1;
+}

commit b488a5ed12c0d8417884d8c33fc0a1701a16c951
Author: Nicolas Pitre <nico@cam.org>
Date:   Wed Apr 9 21:08:35 2008 +0100

    [ARM] 4954/1: Orion: fix some function section mismatch
    
    Without this, lspci won't work.
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
index 27b4afc8f486..fdf99fca85b3 100644
--- a/arch/arm/mach-orion5x/pci.c
+++ b/arch/arm/mach-orion5x/pci.c
@@ -41,7 +41,7 @@ void __init orion5x_pcie_id(u32 *dev, u32 *rev)
 	*rev = orion_pcie_rev(PCIE_BASE);
 }
 
-int orion5x_pcie_local_bus_nr(void)
+int __init orion5x_pcie_local_bus_nr(void)
 {
 	return orion_pcie_get_local_bus_nr(PCIE_BASE);
 }

commit 9dd0b194bf6804b1998f0fe261b2606ec7b58d72
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Thu Mar 27 14:51:41 2008 -0400

    Orion: orion -> orion5x rename
    
    Do a global s/orion/orion5x/ of the Orion 5x-specific bits (i.e.
    not the plat-orion bits.)
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Reviewed-by: Tzachi Perelstein <tzachi@marvell.com>
    Acked-by: Saeed Bishara <saeed@marvell.com>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Nicolas Pitre <nico@marvell.com>

diff --git a/arch/arm/mach-orion5x/pci.c b/arch/arm/mach-orion5x/pci.c
new file mode 100644
index 000000000000..27b4afc8f486
--- /dev/null
+++ b/arch/arm/mach-orion5x/pci.c
@@ -0,0 +1,559 @@
+/*
+ * arch/arm/mach-orion5x/pci.c
+ *
+ * PCI and PCIe functions for Marvell Orion System On Chip
+ *
+ * Maintainer: Tzachi Perelstein <tzachi@marvell.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/mbus.h>
+#include <asm/mach/pci.h>
+#include <asm/plat-orion/pcie.h>
+#include "common.h"
+
+/*****************************************************************************
+ * Orion has one PCIe controller and one PCI controller.
+ *
+ * Note1: The local PCIe bus number is '0'. The local PCI bus number
+ * follows the scanned PCIe bridged busses, if any.
+ *
+ * Note2: It is possible for PCI/PCIe agents to access many subsystem's
+ * space, by configuring BARs and Address Decode Windows, e.g. flashes on
+ * device bus, Orion registers, etc. However this code only enable the
+ * access to DDR banks.
+ ****************************************************************************/
+
+
+/*****************************************************************************
+ * PCIe controller
+ ****************************************************************************/
+#define PCIE_BASE	((void __iomem *)ORION5X_PCIE_VIRT_BASE)
+
+void __init orion5x_pcie_id(u32 *dev, u32 *rev)
+{
+	*dev = orion_pcie_dev_id(PCIE_BASE);
+	*rev = orion_pcie_rev(PCIE_BASE);
+}
+
+int orion5x_pcie_local_bus_nr(void)
+{
+	return orion_pcie_get_local_bus_nr(PCIE_BASE);
+}
+
+static int pcie_valid_config(int bus, int dev)
+{
+	/*
+	 * Don't go out when trying to access --
+	 * 1. nonexisting device on local bus
+	 * 2. where there's no device connected (no link)
+	 */
+	if (bus == 0 && dev == 0)
+		return 1;
+
+	if (!orion_pcie_link_up(PCIE_BASE))
+		return 0;
+
+	if (bus == 0 && dev != 1)
+		return 0;
+
+	return 1;
+}
+
+
+/*
+ * PCIe config cycles are done by programming the PCIE_CONF_ADDR register
+ * and then reading the PCIE_CONF_DATA register. Need to make sure these
+ * transactions are atomic.
+ */
+static DEFINE_SPINLOCK(orion5x_pcie_lock);
+
+static int pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,
+			int size, u32 *val)
+{
+	unsigned long flags;
+	int ret;
+
+	if (pcie_valid_config(bus->number, PCI_SLOT(devfn)) == 0) {
+		*val = 0xffffffff;
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
+	spin_lock_irqsave(&orion5x_pcie_lock, flags);
+	ret = orion_pcie_rd_conf(PCIE_BASE, bus, devfn, where, size, val);
+	spin_unlock_irqrestore(&orion5x_pcie_lock, flags);
+
+	return ret;
+}
+
+static int pcie_rd_conf_wa(struct pci_bus *bus, u32 devfn,
+			   int where, int size, u32 *val)
+{
+	int ret;
+
+	if (pcie_valid_config(bus->number, PCI_SLOT(devfn)) == 0) {
+		*val = 0xffffffff;
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
+	/*
+	 * We only support access to the non-extended configuration
+	 * space when using the WA access method (or we would have to
+	 * sacrifice 256M of CPU virtual address space.)
+	 */
+	if (where >= 0x100) {
+		*val = 0xffffffff;
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
+	ret = orion_pcie_rd_conf_wa((void __iomem *)ORION5X_PCIE_WA_VIRT_BASE,
+				    bus, devfn, where, size, val);
+
+	return ret;
+}
+
+static int pcie_wr_conf(struct pci_bus *bus, u32 devfn,
+			int where, int size, u32 val)
+{
+	unsigned long flags;
+	int ret;
+
+	if (pcie_valid_config(bus->number, PCI_SLOT(devfn)) == 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	spin_lock_irqsave(&orion5x_pcie_lock, flags);
+	ret = orion_pcie_wr_conf(PCIE_BASE, bus, devfn, where, size, val);
+	spin_unlock_irqrestore(&orion5x_pcie_lock, flags);
+
+	return ret;
+}
+
+static struct pci_ops pcie_ops = {
+	.read = pcie_rd_conf,
+	.write = pcie_wr_conf,
+};
+
+
+static int __init pcie_setup(struct pci_sys_data *sys)
+{
+	struct resource *res;
+	int dev;
+
+	/*
+	 * Generic PCIe unit setup.
+	 */
+	orion_pcie_setup(PCIE_BASE, &orion5x_mbus_dram_info);
+
+	/*
+	 * Check whether to apply Orion-1/Orion-NAS PCIe config
+	 * read transaction workaround.
+	 */
+	dev = orion_pcie_dev_id(PCIE_BASE);
+	if (dev == MV88F5181_DEV_ID || dev == MV88F5182_DEV_ID) {
+		printk(KERN_NOTICE "Applying Orion-1/Orion-NAS PCIe config "
+				   "read transaction workaround\n");
+		pcie_ops.read = pcie_rd_conf_wa;
+	}
+
+	/*
+	 * Request resources.
+	 */
+	res = kzalloc(sizeof(struct resource) * 2, GFP_KERNEL);
+	if (!res)
+		panic("pcie_setup unable to alloc resources");
+
+	/*
+	 * IORESOURCE_IO
+	 */
+	res[0].name = "PCIe I/O Space";
+	res[0].flags = IORESOURCE_IO;
+	res[0].start = ORION5X_PCIE_IO_BUS_BASE;
+	res[0].end = res[0].start + ORION5X_PCIE_IO_SIZE - 1;
+	if (request_resource(&ioport_resource, &res[0]))
+		panic("Request PCIe IO resource failed\n");
+	sys->resource[0] = &res[0];
+
+	/*
+	 * IORESOURCE_MEM
+	 */
+	res[1].name = "PCIe Memory Space";
+	res[1].flags = IORESOURCE_MEM;
+	res[1].start = ORION5X_PCIE_MEM_PHYS_BASE;
+	res[1].end = res[1].start + ORION5X_PCIE_MEM_SIZE - 1;
+	if (request_resource(&iomem_resource, &res[1]))
+		panic("Request PCIe Memory resource failed\n");
+	sys->resource[1] = &res[1];
+
+	sys->resource[2] = NULL;
+	sys->io_offset = 0;
+
+	return 1;
+}
+
+/*****************************************************************************
+ * PCI controller
+ ****************************************************************************/
+#define PCI_MODE		ORION5X_PCI_REG(0xd00)
+#define PCI_CMD			ORION5X_PCI_REG(0xc00)
+#define PCI_P2P_CONF		ORION5X_PCI_REG(0x1d14)
+#define PCI_CONF_ADDR		ORION5X_PCI_REG(0xc78)
+#define PCI_CONF_DATA		ORION5X_PCI_REG(0xc7c)
+
+/*
+ * PCI_MODE bits
+ */
+#define PCI_MODE_64BIT			(1 << 2)
+#define PCI_MODE_PCIX			((1 << 4) | (1 << 5))
+
+/*
+ * PCI_CMD bits
+ */
+#define PCI_CMD_HOST_REORDER		(1 << 29)
+
+/*
+ * PCI_P2P_CONF bits
+ */
+#define PCI_P2P_BUS_OFFS		16
+#define PCI_P2P_BUS_MASK		(0xff << PCI_P2P_BUS_OFFS)
+#define PCI_P2P_DEV_OFFS		24
+#define PCI_P2P_DEV_MASK		(0x1f << PCI_P2P_DEV_OFFS)
+
+/*
+ * PCI_CONF_ADDR bits
+ */
+#define PCI_CONF_REG(reg)		((reg) & 0xfc)
+#define PCI_CONF_FUNC(func)		(((func) & 0x3) << 8)
+#define PCI_CONF_DEV(dev)		(((dev) & 0x1f) << 11)
+#define PCI_CONF_BUS(bus)		(((bus) & 0xff) << 16)
+#define PCI_CONF_ADDR_EN		(1 << 31)
+
+/*
+ * Internal configuration space
+ */
+#define PCI_CONF_FUNC_STAT_CMD		0
+#define PCI_CONF_REG_STAT_CMD		4
+#define PCIX_STAT			0x64
+#define PCIX_STAT_BUS_OFFS		8
+#define PCIX_STAT_BUS_MASK		(0xff << PCIX_STAT_BUS_OFFS)
+
+/*
+ * PCI Address Decode Windows registers
+ */
+#define PCI_BAR_SIZE_DDR_CS(n)	(((n) == 0) ? ORION5X_PCI_REG(0xc08) : \
+				((n) == 1) ? ORION5X_PCI_REG(0xd08) :  \
+				((n) == 2) ? ORION5X_PCI_REG(0xc0c) :  \
+				((n) == 3) ? ORION5X_PCI_REG(0xd0c) : 0)
+#define PCI_BAR_REMAP_DDR_CS(n)	(((n) ==0) ? ORION5X_PCI_REG(0xc48) :  \
+				((n) == 1) ? ORION5X_PCI_REG(0xd48) :  \
+				((n) == 2) ? ORION5X_PCI_REG(0xc4c) :  \
+				((n) == 3) ? ORION5X_PCI_REG(0xd4c) : 0)
+#define PCI_BAR_ENABLE		ORION5X_PCI_REG(0xc3c)
+#define PCI_ADDR_DECODE_CTRL	ORION5X_PCI_REG(0xd3c)
+
+/*
+ * PCI configuration helpers for BAR settings
+ */
+#define PCI_CONF_FUNC_BAR_CS(n)		((n) >> 1)
+#define PCI_CONF_REG_BAR_LO_CS(n)	(((n) & 1) ? 0x18 : 0x10)
+#define PCI_CONF_REG_BAR_HI_CS(n)	(((n) & 1) ? 0x1c : 0x14)
+
+/*
+ * PCI config cycles are done by programming the PCI_CONF_ADDR register
+ * and then reading the PCI_CONF_DATA register. Need to make sure these
+ * transactions are atomic.
+ */
+static DEFINE_SPINLOCK(orion5x_pci_lock);
+
+int orion5x_pci_local_bus_nr(void)
+{
+	u32 conf = orion5x_read(PCI_P2P_CONF);
+	return((conf & PCI_P2P_BUS_MASK) >> PCI_P2P_BUS_OFFS);
+}
+
+static int orion5x_pci_hw_rd_conf(int bus, int dev, u32 func,
+					u32 where, u32 size, u32 *val)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&orion5x_pci_lock, flags);
+
+	orion5x_write(PCI_CONF_ADDR, PCI_CONF_BUS(bus) |
+			PCI_CONF_DEV(dev) | PCI_CONF_REG(where) |
+			PCI_CONF_FUNC(func) | PCI_CONF_ADDR_EN);
+
+	*val = orion5x_read(PCI_CONF_DATA);
+
+	if (size == 1)
+		*val = (*val >> (8*(where & 0x3))) & 0xff;
+	else if (size == 2)
+		*val = (*val >> (8*(where & 0x3))) & 0xffff;
+
+	spin_unlock_irqrestore(&orion5x_pci_lock, flags);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int orion5x_pci_hw_wr_conf(int bus, int dev, u32 func,
+					u32 where, u32 size, u32 val)
+{
+	unsigned long flags;
+	int ret = PCIBIOS_SUCCESSFUL;
+
+	spin_lock_irqsave(&orion5x_pci_lock, flags);
+
+	orion5x_write(PCI_CONF_ADDR, PCI_CONF_BUS(bus) |
+			PCI_CONF_DEV(dev) | PCI_CONF_REG(where) |
+			PCI_CONF_FUNC(func) | PCI_CONF_ADDR_EN);
+
+	if (size == 4) {
+		__raw_writel(val, PCI_CONF_DATA);
+	} else if (size == 2) {
+		__raw_writew(val, PCI_CONF_DATA + (where & 0x3));
+	} else if (size == 1) {
+		__raw_writeb(val, PCI_CONF_DATA + (where & 0x3));
+	} else {
+		ret = PCIBIOS_BAD_REGISTER_NUMBER;
+	}
+
+	spin_unlock_irqrestore(&orion5x_pci_lock, flags);
+
+	return ret;
+}
+
+static int orion5x_pci_rd_conf(struct pci_bus *bus, u32 devfn,
+				int where, int size, u32 *val)
+{
+	/*
+	 * Don't go out for local device
+	 */
+	if (bus->number == orion5x_pci_local_bus_nr() &&
+	    PCI_SLOT(devfn) == 0 && PCI_FUNC(devfn) != 0) {
+		*val = 0xffffffff;
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
+	return orion5x_pci_hw_rd_conf(bus->number, PCI_SLOT(devfn),
+					PCI_FUNC(devfn), where, size, val);
+}
+
+static int orion5x_pci_wr_conf(struct pci_bus *bus, u32 devfn,
+				int where, int size, u32 val)
+{
+	if (bus->number == orion5x_pci_local_bus_nr() &&
+	    PCI_SLOT(devfn) == 0 && PCI_FUNC(devfn) != 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	return orion5x_pci_hw_wr_conf(bus->number, PCI_SLOT(devfn),
+					PCI_FUNC(devfn), where, size, val);
+}
+
+static struct pci_ops pci_ops = {
+	.read = orion5x_pci_rd_conf,
+	.write = orion5x_pci_wr_conf,
+};
+
+static void __init orion5x_pci_set_bus_nr(int nr)
+{
+	u32 p2p = orion5x_read(PCI_P2P_CONF);
+
+	if (orion5x_read(PCI_MODE) & PCI_MODE_PCIX) {
+		/*
+		 * PCI-X mode
+		 */
+		u32 pcix_status, bus, dev;
+		bus = (p2p & PCI_P2P_BUS_MASK) >> PCI_P2P_BUS_OFFS;
+		dev = (p2p & PCI_P2P_DEV_MASK) >> PCI_P2P_DEV_OFFS;
+		orion5x_pci_hw_rd_conf(bus, dev, 0, PCIX_STAT, 4, &pcix_status);
+		pcix_status &= ~PCIX_STAT_BUS_MASK;
+		pcix_status |= (nr << PCIX_STAT_BUS_OFFS);
+		orion5x_pci_hw_wr_conf(bus, dev, 0, PCIX_STAT, 4, pcix_status);
+	} else {
+		/*
+		 * PCI Conventional mode
+		 */
+		p2p &= ~PCI_P2P_BUS_MASK;
+		p2p |= (nr << PCI_P2P_BUS_OFFS);
+		orion5x_write(PCI_P2P_CONF, p2p);
+	}
+}
+
+static void __init orion5x_pci_master_slave_enable(void)
+{
+	int bus_nr, func, reg;
+	u32 val;
+
+	bus_nr = orion5x_pci_local_bus_nr();
+	func = PCI_CONF_FUNC_STAT_CMD;
+	reg = PCI_CONF_REG_STAT_CMD;
+	orion5x_pci_hw_rd_conf(bus_nr, 0, func, reg, 4, &val);
+	val |= (PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);
+	orion5x_pci_hw_wr_conf(bus_nr, 0, func, reg, 4, val | 0x7);
+}
+
+static void __init orion5x_setup_pci_wins(struct mbus_dram_target_info *dram)
+{
+	u32 win_enable;
+	int bus;
+	int i;
+
+	/*
+	 * First, disable windows.
+	 */
+	win_enable = 0xffffffff;
+	orion5x_write(PCI_BAR_ENABLE, win_enable);
+
+	/*
+	 * Setup windows for DDR banks.
+	 */
+	bus = orion5x_pci_local_bus_nr();
+
+	for (i = 0; i < dram->num_cs; i++) {
+		struct mbus_dram_window *cs = dram->cs + i;
+		u32 func = PCI_CONF_FUNC_BAR_CS(cs->cs_index);
+		u32 reg;
+		u32 val;
+
+		/*
+		 * Write DRAM bank base address register.
+		 */
+		reg = PCI_CONF_REG_BAR_LO_CS(cs->cs_index);
+		orion5x_pci_hw_rd_conf(bus, 0, func, reg, 4, &val);
+		val = (cs->base & 0xfffff000) | (val & 0xfff);
+		orion5x_pci_hw_wr_conf(bus, 0, func, reg, 4, val);
+
+		/*
+		 * Write DRAM bank size register.
+		 */
+		reg = PCI_CONF_REG_BAR_HI_CS(cs->cs_index);
+		orion5x_pci_hw_wr_conf(bus, 0, func, reg, 4, 0);
+		orion5x_write(PCI_BAR_SIZE_DDR_CS(cs->cs_index),
+				(cs->size - 1) & 0xfffff000);
+		orion5x_write(PCI_BAR_REMAP_DDR_CS(cs->cs_index),
+				cs->base & 0xfffff000);
+
+		/*
+		 * Enable decode window for this chip select.
+		 */
+		win_enable &= ~(1 << cs->cs_index);
+	}
+
+	/*
+	 * Re-enable decode windows.
+	 */
+	orion5x_write(PCI_BAR_ENABLE, win_enable);
+
+	/*
+	 * Disable automatic update of address remaping when writing to BARs.
+	 */
+	orion5x_setbits(PCI_ADDR_DECODE_CTRL, 1);
+}
+
+static int __init pci_setup(struct pci_sys_data *sys)
+{
+	struct resource *res;
+
+	/*
+	 * Point PCI unit MBUS decode windows to DRAM space.
+	 */
+	orion5x_setup_pci_wins(&orion5x_mbus_dram_info);
+
+	/*
+	 * Master + Slave enable
+	 */
+	orion5x_pci_master_slave_enable();
+
+	/*
+	 * Force ordering
+	 */
+	orion5x_setbits(PCI_CMD, PCI_CMD_HOST_REORDER);
+
+	/*
+	 * Request resources
+	 */
+	res = kzalloc(sizeof(struct resource) * 2, GFP_KERNEL);
+	if (!res)
+		panic("pci_setup unable to alloc resources");
+
+	/*
+	 * IORESOURCE_IO
+	 */
+	res[0].name = "PCI I/O Space";
+	res[0].flags = IORESOURCE_IO;
+	res[0].start = ORION5X_PCI_IO_BUS_BASE;
+	res[0].end = res[0].start + ORION5X_PCI_IO_SIZE - 1;
+	if (request_resource(&ioport_resource, &res[0]))
+		panic("Request PCI IO resource failed\n");
+	sys->resource[0] = &res[0];
+
+	/*
+	 * IORESOURCE_MEM
+	 */
+	res[1].name = "PCI Memory Space";
+	res[1].flags = IORESOURCE_MEM;
+	res[1].start = ORION5X_PCI_MEM_PHYS_BASE;
+	res[1].end = res[1].start + ORION5X_PCI_MEM_SIZE - 1;
+	if (request_resource(&iomem_resource, &res[1]))
+		panic("Request PCI Memory resource failed\n");
+	sys->resource[1] = &res[1];
+
+	sys->resource[2] = NULL;
+	sys->io_offset = 0;
+
+	return 1;
+}
+
+
+/*****************************************************************************
+ * General PCIe + PCI
+ ****************************************************************************/
+static void __devinit rc_pci_fixup(struct pci_dev *dev)
+{
+	/*
+	 * Prevent enumeration of root complex.
+	 */
+	if (dev->bus->parent == NULL && dev->devfn == 0) {
+		int i;
+
+		for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
+			dev->resource[i].start = 0;
+			dev->resource[i].end   = 0;
+			dev->resource[i].flags = 0;
+		}
+	}
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL, PCI_ANY_ID, rc_pci_fixup);
+
+int __init orion5x_pci_sys_setup(int nr, struct pci_sys_data *sys)
+{
+	int ret = 0;
+
+	if (nr == 0) {
+		orion_pcie_set_local_bus_nr(PCIE_BASE, sys->busnr);
+		ret = pcie_setup(sys);
+	} else if (nr == 1) {
+		orion5x_pci_set_bus_nr(sys->busnr);
+		ret = pci_setup(sys);
+	}
+
+	return ret;
+}
+
+struct pci_bus __init *orion5x_pci_sys_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	struct pci_bus *bus;
+
+	if (nr == 0) {
+		bus = pci_scan_bus(sys->busnr, &pcie_ops, sys);
+	} else if (nr == 1) {
+		bus = pci_scan_bus(sys->busnr, &pci_ops, sys);
+	} else {
+		bus = NULL;
+		BUG();
+	}
+
+	return bus;
+}
