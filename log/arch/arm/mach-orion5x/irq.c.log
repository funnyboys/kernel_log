commit fc05c24db0a602b54571d114a087bd1b251bae60
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Thu Jun 9 10:59:05 2016 +0100

    ARM: orion5x: make orion5x_legacy_handle_irq static
    
    The orion5x_legacy_handle_irq() is not used or declared outside
    of irq.c so make it static to avoid the following warning:
    
    arch/arm/mach-orion5x/irq.c:30:23: warning: symbol 'orion5x_legacy_handle_irq' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Acked-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index de980ef9cda1..ac4af2283bef 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -26,7 +26,7 @@ static int __initdata gpio0_irqs[4] = {
 	IRQ_ORION5X_GPIO_24_31,
 };
 
-asmlinkage void
+static asmlinkage void
 __exception_irq_entry orion5x_legacy_handle_irq(struct pt_regs *regs)
 {
 	u32 stat;

commit c22c2c6008d69ff2632f8a69c62782468c2bb5a0
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Dec 2 22:27:08 2015 +0100

    ARM: orion5x: clean up mach/*.h headers
    
    This is a simple move of all header files that are no longer
    included by anything else from the include/mach directory
    to the platform directory itself as preparation for
    multiplatform support.
    
    The mach/uncompress.h headers are left in place for now,
    and are mildly modified to be independent of the other
    headers. They will be removed entirely when ARCH_MULTIPLATFORM
    gets enabled and they become obsolete.
    
    Rather than updating the path names inside of the comments
    of each header, I delete those comments to avoid having to
    update them again, should they get moved or copied another
    time.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index 8678db1eb1bd..de980ef9cda1 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -13,10 +13,10 @@
 #include <linux/kernel.h>
 #include <linux/irq.h>
 #include <linux/io.h>
-#include <mach/bridge-regs.h>
 #include <plat/orion-gpio.h>
 #include <plat/irq.h>
 #include <asm/exception.h>
+#include "bridge-regs.h"
 #include "common.h"
 
 static int __initdata gpio0_irqs[4] = {

commit b8cd337c8e0330f4a29b3d1f69b7c73b324b1f8d
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Dec 2 22:27:04 2015 +0100

    ARM: orion: always use MULTI_IRQ_HANDLER
    
    As a preparation for multiplatform support, this enables
    the MULTI_IRQ_HANDLER code unconditionally on dove and
    orion5x, and introduces the respective code on mv78xx0,
    which did not have it so far. The classic entry-macro.S
    files are removed as they are now obsolete.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index 086ecb87d885..8678db1eb1bd 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -26,14 +26,6 @@ static int __initdata gpio0_irqs[4] = {
 	IRQ_ORION5X_GPIO_24_31,
 };
 
-#ifdef CONFIG_MULTI_IRQ_HANDLER
-/*
- * Compiling with both non-DT and DT support enabled, will
- * break asm irq handler used by non-DT boards. Therefore,
- * we provide a C-style irq handler even for non-DT boards,
- * if MULTI_IRQ_HANDLER is set.
- */
-
 asmlinkage void
 __exception_irq_entry orion5x_legacy_handle_irq(struct pt_regs *regs)
 {
@@ -47,15 +39,12 @@ __exception_irq_entry orion5x_legacy_handle_irq(struct pt_regs *regs)
 		return;
 	}
 }
-#endif
 
 void __init orion5x_init_irq(void)
 {
 	orion_irq_init(1, MAIN_IRQ_MASK);
 
-#ifdef CONFIG_MULTI_IRQ_HANDLER
 	set_handle_irq(orion5x_legacy_handle_irq);
-#endif
 
 	/*
 	 * Initialize gpiolib for GPIOs 0-31.

commit 5be9fc23cdb42e1d383ecc8eae8a8ff70a752708
Author: Benjamin Cama <benoar@dolka.fr>
Date:   Tue Jul 14 16:25:58 2015 +0200

    ARM: orion5x: fix legacy orion5x IRQ numbers
    
    Since v3.18, attempts to deliver IRQ0 are rejected, breaking orion5x.
    Fix this by increasing all interrupts by one, as did 5d6bed2a9c8b for
    dove. Also, force MULTI_IRQ_HANDLER for all orion platforms (including
    dove) as the specific handler is needed to shift back IRQ numbers by
    one.
    
    [gregory.clement@free-electrons.com]: moved the select
    MULTI_IRQ_HANDLER from PLAT_ORION_LEGACY to ARCH_ORION5X as it broke
    the build for dove.
    
    Fixes: a71b092a9c68 ("ARM: Convert handle_IRQ to use __handle_domain_irq")
    Signed-off-by: Benjamin Cama <benoar@dolka.fr>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Cc: <stable@vger.kernel.org>
    Tested-by: Detlef Vollmann <dv@vollmann.ch>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index cd4bac4d7e43..086ecb87d885 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -42,7 +42,7 @@ __exception_irq_entry orion5x_legacy_handle_irq(struct pt_regs *regs)
 	stat = readl_relaxed(MAIN_IRQ_CAUSE);
 	stat &= readl_relaxed(MAIN_IRQ_MASK);
 	if (stat) {
-		unsigned int hwirq = __fls(stat);
+		unsigned int hwirq = 1 + __fls(stat);
 		handle_IRQ(hwirq, regs);
 		return;
 	}
@@ -51,7 +51,7 @@ __exception_irq_entry orion5x_legacy_handle_irq(struct pt_regs *regs)
 
 void __init orion5x_init_irq(void)
 {
-	orion_irq_init(0, MAIN_IRQ_MASK);
+	orion_irq_init(1, MAIN_IRQ_MASK);
 
 #ifdef CONFIG_MULTI_IRQ_HANDLER
 	set_handle_irq(orion5x_legacy_handle_irq);

commit ab5ab9dbe6bd480d17f23b3a33510ae33e6ab280
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Tue Apr 22 23:26:27 2014 +0200

    ARM: orion5x: switch to DT interrupts and timer
    
    This commit switches the Orion5x platforms described through DT to use
    a DT-defined interrupt controller and timer.
    
    This involves:
    
     * Describing in the DT the bridge interrupt controller, which is a
       child interrupt controller to the main one, which is used for timer
       and watchdog interrupts.
    
     * Describing in the DT the timer.
    
     * Adding in the DT the interrupt specifications for the watchdog.
    
     * Selecting the ORION_IRQCHIP and ORION_TIMER drivers to be compiled.
    
     * Change board-dt.c to no longer have an ->init_time() callback,
       since the default callback will work fine: it calls
       clocksource_of_init() and of_clk_init(), as needed.
    
     * Implement a multi-IRQ handler for non-DT platforms in
       mach-orion5x/irq.c.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Link: https://lkml.kernel.org/r/1398202002-28530-24-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index 9654b0cc5892..cd4bac4d7e43 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -16,6 +16,7 @@
 #include <mach/bridge-regs.h>
 #include <plat/orion-gpio.h>
 #include <plat/irq.h>
+#include <asm/exception.h>
 #include "common.h"
 
 static int __initdata gpio0_irqs[4] = {
@@ -25,10 +26,37 @@ static int __initdata gpio0_irqs[4] = {
 	IRQ_ORION5X_GPIO_24_31,
 };
 
+#ifdef CONFIG_MULTI_IRQ_HANDLER
+/*
+ * Compiling with both non-DT and DT support enabled, will
+ * break asm irq handler used by non-DT boards. Therefore,
+ * we provide a C-style irq handler even for non-DT boards,
+ * if MULTI_IRQ_HANDLER is set.
+ */
+
+asmlinkage void
+__exception_irq_entry orion5x_legacy_handle_irq(struct pt_regs *regs)
+{
+	u32 stat;
+
+	stat = readl_relaxed(MAIN_IRQ_CAUSE);
+	stat &= readl_relaxed(MAIN_IRQ_MASK);
+	if (stat) {
+		unsigned int hwirq = __fls(stat);
+		handle_IRQ(hwirq, regs);
+		return;
+	}
+}
+#endif
+
 void __init orion5x_init_irq(void)
 {
 	orion_irq_init(0, MAIN_IRQ_MASK);
 
+#ifdef CONFIG_MULTI_IRQ_HANDLER
+	set_handle_irq(orion5x_legacy_handle_irq);
+#endif
+
 	/*
 	 * Initialize gpiolib for GPIOs 0-31.
 	 */

commit 4236666688e9dbc38d0c7a98b7cfa16c8961f752
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Oct 23 16:12:51 2013 +0200

    ARM: Orion5x: Fix warnings when using C=1.
    
    Add missing include files, missing static keyword, and use NULL instead
    of 0, in order to fix warnings when compiling with C=1.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index 30a192b9c517..9654b0cc5892 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -16,6 +16,7 @@
 #include <mach/bridge-regs.h>
 #include <plat/orion-gpio.h>
 #include <plat/irq.h>
+#include "common.h"
 
 static int __initdata gpio0_irqs[4] = {
 	IRQ_ORION5X_GPIO_0_7,

commit 0d601f613b8557cf6489f06251ae5dc383b811d0
Merge: d7ffa2234c18 5b40baee4a39
Author: Olof Johansson <olof@lixom.net>
Date:   Sat Sep 22 14:09:21 2012 -0700

    Merge branch 'kirkwood/addr_decode' of git://git.infradead.org/users/jcooper/linux into late/kirkwood
    
    * 'kirkwood/addr_decode' of git://git.infradead.org/users/jcooper/linux:
      arm: mvebu: add address decoding controller to the DT
      arm: mvebu: add basic address decoding support to Armada 370/XP
      arm: plat-orion: make bridge_virt_base non-const to support DT use case
      arm: plat-orion: introduce PLAT_ORION_LEGACY hidden config option
      arm: plat-orion: use void __iomem pointers for addr-map functions
      arm: plat-orion: use void __iomem pointers for time functions
      arm: plat-orion: use void __iomem pointers for MPP functions
      arm: plat-orion: use void __iomem pointers for UART registration functions
      arm: mach-mvebu: use IOMEM() for base address definitions
      arm: mach-orion5x: use IOMEM() for base address definitions
      arm: mach-mv78xx0: use IOMEM() for base address definitions
      arm: mach-kirkwood: use IOMEM() for base address definitions
      arm: mach-dove: use IOMEM() for base address definitions
      arm: mach-orion5x: use plus instead of or for address definitions
      arm: mach-mv78xx0: use plus instead of or for address definitions
      arm: mach-kirkwood: use plus instead of or for address definitions
      arm: mach-dove: use plus instead of or for address definitions
    
    This branch had quite a few conflicts, in particular with the PCI static
    map rework from Rob Herring, and a few other context conflicts due to
    changes in Kconfig, etc.
    
    I fixed up conflicts in:
            arch/arm/Kconfig
            arch/arm/mach-dove/common.c
            arch/arm/mach-dove/include/mach/dove.h
            arch/arm/mach-kirkwood/common.c
            arch/arm/mach-kirkwood/include/mach/kirkwood.h
            arch/arm/mach-mv78xx0/common.c
            arch/arm/mach-mv78xx0/include/mach/mv78xx0.h
            arch/arm/mach-orion5x/common.c
            arch/arm/mach-orion5x/include/mach/orion5x.h
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 3904a39321422d424f790d18a4746b99e1aed0e9
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Tue Sep 11 14:27:21 2012 +0200

    arm: mach-orion5x: use IOMEM() for base address definitions
    
    We now define all virtual base address constants using IOMEM() so that
    those are naturally typed as void __iomem pointers, and we do the
    necessary adjustements in the mach-orion5x code.
    
    Note that we introduce a few temporary additional "unsigned long"
    casts when calling into plat-orion functions. Those are removed by
    followup patches converting plat-orion functions to void __iomem
    pointers as well.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index 17da7091d310..bf9ff4f00818 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -12,6 +12,7 @@
 #include <linux/gpio.h>
 #include <linux/kernel.h>
 #include <linux/irq.h>
+#include <linux/io.h>
 #include <mach/bridge-regs.h>
 #include <plat/irq.h>
 
@@ -24,11 +25,11 @@ static int __initdata gpio0_irqs[4] = {
 
 void __init orion5x_init_irq(void)
 {
-	orion_irq_init(0, (void __iomem *)MAIN_IRQ_MASK);
+	orion_irq_init(0, MAIN_IRQ_MASK);
 
 	/*
 	 * Initialize gpiolib for GPIOs 0-31.
 	 */
-	orion_gpio_init(NULL, 0, 32, (void __iomem *)GPIO_VIRT_BASE, 0,
+	orion_gpio_init(NULL, 0, 32, GPIO_VIRT_BASE, 0,
 			IRQ_ORION5X_GPIO_START, gpio0_irqs);
 }

commit ce91574c202b8581ad15bfb1427af824f462c3d2
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Wed Aug 29 10:16:55 2012 -0500

    ARM: orion: move custom gpio functions to orion-gpio.h
    
    Move custom orion platforms gpio code to orion-gpio to remove the
    dependency on mach/gpio.h.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index 17da7091d310..e152641cdb0e 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -13,6 +13,7 @@
 #include <linux/kernel.h>
 #include <linux/irq.h>
 #include <mach/bridge-regs.h>
+#include <plat/orion-gpio.h>
 #include <plat/irq.h>
 
 static int __initdata gpio0_irqs[4] = {

commit 278b45b06bf721b7cf5de67a0126786c60c720e6
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jun 27 13:40:04 2012 +0200

    ARM: Orion: DT support for IRQ and GPIO Controllers
    
    Both IRQ and GPIO controllers can now be represented in DT.  The IRQ
    controllers are setup first, and then the GPIO controllers. Interrupts
    for GPIO lines are placed directly after the main interrupts in the
    interrupt space.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@googlemail.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Tested-by: Josh Coombs <josh.coombs@gmail.com>
    Tested-by: Simon Baatz <gmbnomis@gmail.com>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index b1b45fff776e..17da7091d310 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -11,19 +11,16 @@
  */
 #include <linux/gpio.h>
 #include <linux/kernel.h>
-#include <linux/init.h>
 #include <linux/irq.h>
-#include <linux/io.h>
 #include <mach/bridge-regs.h>
 #include <plat/irq.h>
-#include "common.h"
 
-static void gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
-{
-	BUG_ON(irq < IRQ_ORION5X_GPIO_0_7 || irq > IRQ_ORION5X_GPIO_24_31);
-
-	orion_gpio_irq_handler((irq - IRQ_ORION5X_GPIO_0_7) << 3);
-}
+static int __initdata gpio0_irqs[4] = {
+	IRQ_ORION5X_GPIO_0_7,
+	IRQ_ORION5X_GPIO_8_15,
+	IRQ_ORION5X_GPIO_16_23,
+	IRQ_ORION5X_GPIO_24_31,
+};
 
 void __init orion5x_init_irq(void)
 {
@@ -32,9 +29,6 @@ void __init orion5x_init_irq(void)
 	/*
 	 * Initialize gpiolib for GPIOs 0-31.
 	 */
-	orion_gpio_init(0, 32, GPIO_VIRT_BASE, 0, IRQ_ORION5X_GPIO_START);
-	irq_set_chained_handler(IRQ_ORION5X_GPIO_0_7, gpio_irq_handler);
-	irq_set_chained_handler(IRQ_ORION5X_GPIO_8_15, gpio_irq_handler);
-	irq_set_chained_handler(IRQ_ORION5X_GPIO_16_23, gpio_irq_handler);
-	irq_set_chained_handler(IRQ_ORION5X_GPIO_24_31, gpio_irq_handler);
+	orion_gpio_init(NULL, 0, 32, (void __iomem *)GPIO_VIRT_BASE, 0,
+			IRQ_ORION5X_GPIO_START, gpio0_irqs);
 }

commit 2f8163baada3dbd0ce891c35bc59ae46e773487a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jul 26 10:53:52 2011 +0100

    ARM: gpio: convert includes of mach/gpio.h and asm/gpio.h to linux/gpio.h
    
    Convert arch/arm includes of mach/gpio.h and asm/gpio.h to linux/gpio.h
    before we start consolidating the individual platform implementations
    of the gpio header files.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index 43cf8bc9767b..b1b45fff776e 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -9,12 +9,11 @@
  * License version 2.  This program is licensed "as is" without any
  * warranty of any kind, whether express or implied.
  */
-
+#include <linux/gpio.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/irq.h>
 #include <linux/io.h>
-#include <asm/gpio.h>
 #include <mach/bridge-regs.h>
 #include <plat/irq.h>
 #include "common.h"

commit 6845664a6a7d443f03883db59d10749d38d98b8e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 13:25:22 2011 +0100

    arm: Cleanup the irq namespace
    
    Convert to the new function names. Automated with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index ed85891f8699..43cf8bc9767b 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -34,8 +34,8 @@ void __init orion5x_init_irq(void)
 	 * Initialize gpiolib for GPIOs 0-31.
 	 */
 	orion_gpio_init(0, 32, GPIO_VIRT_BASE, 0, IRQ_ORION5X_GPIO_START);
-	set_irq_chained_handler(IRQ_ORION5X_GPIO_0_7, gpio_irq_handler);
-	set_irq_chained_handler(IRQ_ORION5X_GPIO_8_15, gpio_irq_handler);
-	set_irq_chained_handler(IRQ_ORION5X_GPIO_16_23, gpio_irq_handler);
-	set_irq_chained_handler(IRQ_ORION5X_GPIO_24_31, gpio_irq_handler);
+	irq_set_chained_handler(IRQ_ORION5X_GPIO_0_7, gpio_irq_handler);
+	irq_set_chained_handler(IRQ_ORION5X_GPIO_8_15, gpio_irq_handler);
+	irq_set_chained_handler(IRQ_ORION5X_GPIO_16_23, gpio_irq_handler);
+	irq_set_chained_handler(IRQ_ORION5X_GPIO_24_31, gpio_irq_handler);
 }

commit 9eac6d0a4e7e5149a7f86575b46d710ad2e05fe2
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Tue Dec 14 12:54:03 2010 +0100

    ARM: Remove dependency of plat-orion GPIO code on mach directory includes.
    
    This patch makes the various mach dirs that use the plat-orion GPIO
    code pass in GPIO-related platform info (GPIO controller base address,
    secondary base IRQ number, etc) explicitly, instead of having
    plat-orion get those values by including a mach dir include file --
    the latter mechanism is problematic if you want to support multiple
    ARM platforms in the same kernel image.
    
    Signed-off-by: Lennert Buytenhek <buytenh@secretlab.ca>
    Signed-off-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index d7512b925a85..ed85891f8699 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -28,27 +28,12 @@ static void gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
 
 void __init orion5x_init_irq(void)
 {
-	int i;
-
 	orion_irq_init(0, (void __iomem *)MAIN_IRQ_MASK);
 
 	/*
-	 * Mask and clear GPIO IRQ interrupts
-	 */
-	writel(0x0, GPIO_LEVEL_MASK(0));
-	writel(0x0, GPIO_EDGE_MASK(0));
-	writel(0x0, GPIO_EDGE_CAUSE(0));
-
-	/*
-	 * Register chained level handlers for GPIO IRQs by default.
-	 * User can use set_type() if he wants to use edge types handlers.
+	 * Initialize gpiolib for GPIOs 0-31.
 	 */
-	for (i = IRQ_ORION5X_GPIO_START; i < NR_IRQS; i++) {
-		set_irq_chip(i, &orion_gpio_irq_chip);
-		set_irq_handler(i, handle_level_irq);
-		irq_desc[i].status |= IRQ_LEVEL;
-		set_irq_flags(i, IRQF_VALID);
-	}
+	orion_gpio_init(0, 32, GPIO_VIRT_BASE, 0, IRQ_ORION5X_GPIO_START);
 	set_irq_chained_handler(IRQ_ORION5X_GPIO_0_7, gpio_irq_handler);
 	set_irq_chained_handler(IRQ_ORION5X_GPIO_8_15, gpio_irq_handler);
 	set_irq_chained_handler(IRQ_ORION5X_GPIO_16_23, gpio_irq_handler);

commit fdd8b079e33d4711527ace19798e9db99a056469
Author: Nicolas Pitre <nico@cam.org>
Date:   Wed Apr 22 20:08:17 2009 +0100

    [ARM] 5460/1: Orion: reduce namespace pollution
    
    Symbols like SOFT_RESET are way too generic to be exported at large.
    To avoid this, let's move the mbus bridge register defines into a
    separate file and include it where needed.  This affects mach-kirkwood,
    mach-loki, mach-mv78xx0 and mach-orion5x simultaneously as they all
    share code in plat-orion which relies on those defines.
    
    Some other defines have been moved to narrower scopes, or simply deleted
    when they had no user.
    
    This fixes compilation problem with mpt2sas on the above listed
    platforms.
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index e03f7b45cb0d..d7512b925a85 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -15,7 +15,7 @@
 #include <linux/irq.h>
 #include <linux/io.h>
 #include <asm/gpio.h>
-#include <mach/orion5x.h>
+#include <mach/bridge-regs.h>
 #include <plat/irq.h>
 #include "common.h"
 

commit fd4b9b3650076ffadbdd6e360eb198f5d61747c0
Author: Nicolas Pitre <nico@cam.org>
Date:   Tue Feb 17 20:45:50 2009 +0100

    [ARM] 5401/1: Orion: fix edge triggered GPIO interrupt support
    
    The GPIO interrupts can be configured as either level triggered or edge
    triggered, with a default of level triggered.  When an edge triggered
    interrupt is requested, the gpio_irq_set_type method is called which
    currently switches the given IRQ descriptor between two struct irq_chip
    instances: orion_gpio_irq_level_chip and orion_gpio_irq_edge_chip. This
    happens via __setup_irq() which also calls irq_chip_set_defaults() to
    assign default methods to uninitialized ones.  The problem is that
    irq_chip_set_defaults() is called before the irq_chip reference is
    switched, leaving the new irq_chip (orion_gpio_irq_edge_chip in this
    case) with uninitialized methods such as chip->startup() causing a kernel
    oops.
    
    Many solutions are possible, such as making irq_chip_set_defaults() global
    and calling it from gpio_irq_set_type(), or calling __irq_set_trigger()
    before irq_chip_set_defaults() in __setup_irq().  But those require
    modifications to the generic IRQ code which might have adverse effect on
    other architectures, and that would still be a fragile arrangement.
    Manually copying the missing methods from within gpio_irq_set_type()
    would be really ugly and it would break again the day new methods with
    automatic defaults are added.
    
    A better solution is to have a single irq_chip instance which can deal
    with both edge and level triggered interrupts.  It is also a good idea
    to switch the IRQ handler instead, as the edge IRQ handler allows for
    one edge IRQ event to be queued as the IRQ is actually masked only when
    that second IRQ is received, at which point the hardware can queue an
    additional IRQ event, making edge triggered interrupts a bit more
    reliable.
    
    Tested-by: Martin Michlmayr <tbm@cyrius.com>
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index 0caae43301e5..e03f7b45cb0d 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -44,7 +44,7 @@ void __init orion5x_init_irq(void)
 	 * User can use set_type() if he wants to use edge types handlers.
 	 */
 	for (i = IRQ_ORION5X_GPIO_START; i < NR_IRQS; i++) {
-		set_irq_chip(i, &orion_gpio_irq_level_chip);
+		set_irq_chip(i, &orion_gpio_irq_chip);
 		set_irq_handler(i, handle_level_irq);
 		irq_desc[i].status |= IRQ_LEVEL;
 		set_irq_flags(i, IRQF_VALID);

commit 07332318f33da6acd88abb762a8b6febdfc560a3
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Mon Oct 20 01:51:03 2008 +0200

    [ARM] Orion: share GPIO IRQ handling code
    
    Split off Orion GPIO IRQ handling code into plat-orion/.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Signed-off-by: Nicolas Pitre <nico@marvell.com>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index 6b2f1353797e..0caae43301e5 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -19,193 +19,38 @@
 #include <plat/irq.h>
 #include "common.h"
 
-/*****************************************************************************
- * Orion GPIO IRQ
- *
- * GPIO_IN_POL register controls whether GPIO_DATA_IN will hold the same
- * value of the line or the opposite value.
- *
- * Level IRQ handlers: DATA_IN is used directly as cause register.
- *                     Interrupt are masked by LEVEL_MASK registers.
- * Edge IRQ handlers:  Change in DATA_IN are latched in EDGE_CAUSE.
- *                     Interrupt are masked by EDGE_MASK registers.
- * Both-edge handlers: Similar to regular Edge handlers, but also swaps
- *                     the polarity to catch the next line transaction.
- *                     This is a race condition that might not perfectly
- *                     work on some use cases.
- *
- * Every eight GPIO lines are grouped (OR'ed) before going up to main
- * cause register.
- *
- *                    EDGE  cause    mask
- *        data-in   /--------| |-----| |----\
- *     -----| |-----                         ---- to main cause reg
- *           X      \----------------| |----/
- *        polarity    LEVEL          mask
- *
- ****************************************************************************/
-static void orion5x_gpio_irq_ack(u32 irq)
-{
-	int pin = irq_to_gpio(irq);
-	if (irq_desc[irq].status & IRQ_LEVEL)
-		/*
-		 * Mask bit for level interrupt
-		 */
-		orion5x_clrbits(GPIO_LEVEL_MASK, 1 << pin);
-	else
-		/*
-		 * Clear casue bit for egde interrupt
-		 */
-		orion5x_clrbits(GPIO_EDGE_CAUSE, 1 << pin);
-}
-
-static void orion5x_gpio_irq_mask(u32 irq)
-{
-	int pin = irq_to_gpio(irq);
-	if (irq_desc[irq].status & IRQ_LEVEL)
-		orion5x_clrbits(GPIO_LEVEL_MASK, 1 << pin);
-	else
-		orion5x_clrbits(GPIO_EDGE_MASK, 1 << pin);
-}
-
-static void orion5x_gpio_irq_unmask(u32 irq)
+static void gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
 {
-	int pin = irq_to_gpio(irq);
-	if (irq_desc[irq].status & IRQ_LEVEL)
-		orion5x_setbits(GPIO_LEVEL_MASK, 1 << pin);
-	else
-		orion5x_setbits(GPIO_EDGE_MASK, 1 << pin);
-}
-
-static int orion5x_gpio_set_irq_type(u32 irq, u32 type)
-{
-	int pin = irq_to_gpio(irq);
-	struct irq_desc *desc;
-
-	if ((readl(GPIO_IO_CONF(pin)) & (1 << pin)) == 0) {
-		printk(KERN_ERR "orion5x_gpio_set_irq_type failed "
-				"(irq %d, pin %d).\n", irq, pin);
-		return -EINVAL;
-	}
-
-	desc = irq_desc + irq;
-
-	switch (type) {
-	case IRQ_TYPE_LEVEL_HIGH:
-		desc->handle_irq = handle_level_irq;
-		desc->status |= IRQ_LEVEL;
-		orion5x_clrbits(GPIO_IN_POL(pin), (1 << pin));
-		break;
-	case IRQ_TYPE_LEVEL_LOW:
-		desc->handle_irq = handle_level_irq;
-		desc->status |= IRQ_LEVEL;
-		orion5x_setbits(GPIO_IN_POL(pin), (1 << pin));
-		break;
-	case IRQ_TYPE_EDGE_RISING:
-		desc->handle_irq = handle_edge_irq;
-		desc->status &= ~IRQ_LEVEL;
-		orion5x_clrbits(GPIO_IN_POL(pin), (1 << pin));
-		break;
-	case IRQ_TYPE_EDGE_FALLING:
-		desc->handle_irq = handle_edge_irq;
-		desc->status &= ~IRQ_LEVEL;
-		orion5x_setbits(GPIO_IN_POL(pin), (1 << pin));
-		break;
-	case IRQ_TYPE_EDGE_BOTH:
-		desc->handle_irq = handle_edge_irq;
-		desc->status &= ~IRQ_LEVEL;
-		/*
-		 * set initial polarity based on current input level
-		 */
-		if ((readl(GPIO_IN_POL(pin)) ^ readl(GPIO_DATA_IN(pin)))
-		    & (1 << pin))
-			orion5x_setbits(GPIO_IN_POL(pin), (1 << pin)); /* falling */
-		else
-			orion5x_clrbits(GPIO_IN_POL(pin), (1 << pin)); /* rising */
-
-		break;
-	default:
-		printk(KERN_ERR "failed to set irq=%d (type=%d)\n", irq, type);
-		return -EINVAL;
-	}
-
-	desc->status &= ~IRQ_TYPE_SENSE_MASK;
-	desc->status |= type & IRQ_TYPE_SENSE_MASK;
-
-	return 0;
-}
-
-static struct irq_chip orion5x_gpio_irq_chip = {
-	.name		= "Orion-IRQ-GPIO",
-	.ack		= orion5x_gpio_irq_ack,
-	.mask		= orion5x_gpio_irq_mask,
-	.unmask		= orion5x_gpio_irq_unmask,
-	.set_type	= orion5x_gpio_set_irq_type,
-};
-
-static void orion5x_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
-{
-	u32 cause, offs, pin;
-
 	BUG_ON(irq < IRQ_ORION5X_GPIO_0_7 || irq > IRQ_ORION5X_GPIO_24_31);
-	offs = (irq - IRQ_ORION5X_GPIO_0_7) * 8;
-	cause = (readl(GPIO_DATA_IN(offs)) & readl(GPIO_LEVEL_MASK)) |
-		(readl(GPIO_EDGE_CAUSE) & readl(GPIO_EDGE_MASK));
 
-	for (pin = offs; pin < offs + 8; pin++) {
-		if (cause & (1 << pin)) {
-			irq = gpio_to_irq(pin);
-			desc = irq_desc + irq;
-			if ((desc->status & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {
-				/* Swap polarity (race with GPIO line) */
-				u32 polarity = readl(GPIO_IN_POL(pin));
-				polarity ^= 1 << pin;
-				writel(polarity, GPIO_IN_POL(pin));
-			}
-			generic_handle_irq(irq);
-		}
-	}
+	orion_gpio_irq_handler((irq - IRQ_ORION5X_GPIO_0_7) << 3);
 }
 
-static void __init orion5x_init_gpio_irq(void)
+void __init orion5x_init_irq(void)
 {
 	int i;
-	struct irq_desc *desc;
+
+	orion_irq_init(0, (void __iomem *)MAIN_IRQ_MASK);
 
 	/*
 	 * Mask and clear GPIO IRQ interrupts
 	 */
-	writel(0x0, GPIO_LEVEL_MASK);
-	writel(0x0, GPIO_EDGE_MASK);
-	writel(0x0, GPIO_EDGE_CAUSE);
+	writel(0x0, GPIO_LEVEL_MASK(0));
+	writel(0x0, GPIO_EDGE_MASK(0));
+	writel(0x0, GPIO_EDGE_CAUSE(0));
 
 	/*
 	 * Register chained level handlers for GPIO IRQs by default.
 	 * User can use set_type() if he wants to use edge types handlers.
 	 */
 	for (i = IRQ_ORION5X_GPIO_START; i < NR_IRQS; i++) {
-		set_irq_chip(i, &orion5x_gpio_irq_chip);
+		set_irq_chip(i, &orion_gpio_irq_level_chip);
 		set_irq_handler(i, handle_level_irq);
-		desc = irq_desc + i;
-		desc->status |= IRQ_LEVEL;
+		irq_desc[i].status |= IRQ_LEVEL;
 		set_irq_flags(i, IRQF_VALID);
 	}
-	set_irq_chained_handler(IRQ_ORION5X_GPIO_0_7, orion5x_gpio_irq_handler);
-	set_irq_chained_handler(IRQ_ORION5X_GPIO_8_15, orion5x_gpio_irq_handler);
-	set_irq_chained_handler(IRQ_ORION5X_GPIO_16_23, orion5x_gpio_irq_handler);
-	set_irq_chained_handler(IRQ_ORION5X_GPIO_24_31, orion5x_gpio_irq_handler);
-}
-
-/*****************************************************************************
- * Orion Main IRQ
- ****************************************************************************/
-static void __init orion5x_init_main_irq(void)
-{
-	orion_irq_init(0, (void __iomem *)MAIN_IRQ_MASK);
-}
-
-void __init orion5x_init_irq(void)
-{
-	orion5x_init_main_irq();
-	orion5x_init_gpio_irq();
+	set_irq_chained_handler(IRQ_ORION5X_GPIO_0_7, gpio_irq_handler);
+	set_irq_chained_handler(IRQ_ORION5X_GPIO_8_15, gpio_irq_handler);
+	set_irq_chained_handler(IRQ_ORION5X_GPIO_16_23, gpio_irq_handler);
+	set_irq_chained_handler(IRQ_ORION5X_GPIO_24_31, gpio_irq_handler);
 }

commit 9569dae75f6f6987e79fa26cf6da3fc24006c996
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Mon Oct 20 01:51:03 2008 +0200

    [ARM] Orion: share GPIO handling code
    
    Split off Orion GPIO handling code into plat-orion/, and add
    support for multiple sets of (32) GPIO pins.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Signed-off-by: Nicolas Pitre <nico@marvell.com>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index 632a36f5cf14..6b2f1353797e 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -22,7 +22,7 @@
 /*****************************************************************************
  * Orion GPIO IRQ
  *
- * GPIO_IN_POL register controlls whether GPIO_DATA_IN will hold the same
+ * GPIO_IN_POL register controls whether GPIO_DATA_IN will hold the same
  * value of the line or the opposite value.
  *
  * Level IRQ handlers: DATA_IN is used directly as cause register.
@@ -82,7 +82,7 @@ static int orion5x_gpio_set_irq_type(u32 irq, u32 type)
 	int pin = irq_to_gpio(irq);
 	struct irq_desc *desc;
 
-	if ((readl(GPIO_IO_CONF) & (1 << pin)) == 0) {
+	if ((readl(GPIO_IO_CONF(pin)) & (1 << pin)) == 0) {
 		printk(KERN_ERR "orion5x_gpio_set_irq_type failed "
 				"(irq %d, pin %d).\n", irq, pin);
 		return -EINVAL;
@@ -94,22 +94,22 @@ static int orion5x_gpio_set_irq_type(u32 irq, u32 type)
 	case IRQ_TYPE_LEVEL_HIGH:
 		desc->handle_irq = handle_level_irq;
 		desc->status |= IRQ_LEVEL;
-		orion5x_clrbits(GPIO_IN_POL, (1 << pin));
+		orion5x_clrbits(GPIO_IN_POL(pin), (1 << pin));
 		break;
 	case IRQ_TYPE_LEVEL_LOW:
 		desc->handle_irq = handle_level_irq;
 		desc->status |= IRQ_LEVEL;
-		orion5x_setbits(GPIO_IN_POL, (1 << pin));
+		orion5x_setbits(GPIO_IN_POL(pin), (1 << pin));
 		break;
 	case IRQ_TYPE_EDGE_RISING:
 		desc->handle_irq = handle_edge_irq;
 		desc->status &= ~IRQ_LEVEL;
-		orion5x_clrbits(GPIO_IN_POL, (1 << pin));
+		orion5x_clrbits(GPIO_IN_POL(pin), (1 << pin));
 		break;
 	case IRQ_TYPE_EDGE_FALLING:
 		desc->handle_irq = handle_edge_irq;
 		desc->status &= ~IRQ_LEVEL;
-		orion5x_setbits(GPIO_IN_POL, (1 << pin));
+		orion5x_setbits(GPIO_IN_POL(pin), (1 << pin));
 		break;
 	case IRQ_TYPE_EDGE_BOTH:
 		desc->handle_irq = handle_edge_irq;
@@ -117,11 +117,11 @@ static int orion5x_gpio_set_irq_type(u32 irq, u32 type)
 		/*
 		 * set initial polarity based on current input level
 		 */
-		if ((readl(GPIO_IN_POL) ^ readl(GPIO_DATA_IN))
+		if ((readl(GPIO_IN_POL(pin)) ^ readl(GPIO_DATA_IN(pin)))
 		    & (1 << pin))
-			orion5x_setbits(GPIO_IN_POL, (1 << pin)); /* falling */
+			orion5x_setbits(GPIO_IN_POL(pin), (1 << pin)); /* falling */
 		else
-			orion5x_clrbits(GPIO_IN_POL, (1 << pin)); /* rising */
+			orion5x_clrbits(GPIO_IN_POL(pin), (1 << pin)); /* rising */
 
 		break;
 	default:
@@ -149,7 +149,7 @@ static void orion5x_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
 
 	BUG_ON(irq < IRQ_ORION5X_GPIO_0_7 || irq > IRQ_ORION5X_GPIO_24_31);
 	offs = (irq - IRQ_ORION5X_GPIO_0_7) * 8;
-	cause = (readl(GPIO_DATA_IN) & readl(GPIO_LEVEL_MASK)) |
+	cause = (readl(GPIO_DATA_IN(offs)) & readl(GPIO_LEVEL_MASK)) |
 		(readl(GPIO_EDGE_CAUSE) & readl(GPIO_EDGE_MASK));
 
 	for (pin = offs; pin < offs + 8; pin++) {
@@ -158,9 +158,9 @@ static void orion5x_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
 			desc = irq_desc + irq;
 			if ((desc->status & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {
 				/* Swap polarity (race with GPIO line) */
-				u32 polarity = readl(GPIO_IN_POL);
+				u32 polarity = readl(GPIO_IN_POL(pin));
 				polarity ^= 1 << pin;
-				writel(polarity, GPIO_IN_POL);
+				writel(polarity, GPIO_IN_POL(pin));
 			}
 			generic_handle_irq(irq);
 		}

commit 3f30a09a612bac2b531a206c2a58a292dd7ff182
Merge: 9e165acf1b9e fda50a1c49ad
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Oct 9 21:33:02 2008 +0100

    Merge branch 'pxa-all' into devel
    
    Conflicts:
    
            arch/arm/mach-pxa/Kconfig
            arch/arm/mach-pxa/corgi.c
            arch/arm/mach-pxa/include/mach/hardware.h
            arch/arm/mach-pxa/spitz.c

commit d8aa0251f12546e9bd1e9ee1d9782d6492819a04
Author: Dmitry Baryshkov <dbaryshkov@gmail.com>
Date:   Thu Oct 9 13:36:24 2008 +0100

    [ARM] 5298/1: Drop desc_handle_irq()
    
    desc_handle_irq() was declared as obsolete since long ago.
    Replace it with generic_handle_irq()
    
    Signed-off-by: Dmitry Baryshkov <dbaryshkov@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index 2545ff9e5830..15f27aa7f53e 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -162,7 +162,7 @@ static void orion5x_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
 				polarity ^= 1 << pin;
 				writel(polarity, GPIO_IN_POL);
 			}
-			desc_handle_irq(irq, desc);
+			generic_handle_irq(irq);
 		}
 	}
 }

commit fced80c735941fa518ac67c0b61bbe153fb8c050
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Sep 6 12:10:45 2008 +0100

    [ARM] Convert asm/io.h to linux/io.h
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index 2545ff9e5830..02ceeb3c6737 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -13,8 +13,8 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/irq.h>
+#include <linux/io.h>
 #include <asm/gpio.h>
-#include <asm/io.h>
 #include <mach/orion5x.h>
 #include <plat/irq.h>
 #include "common.h"

commit 6f088f1d215be5250582b974f83f0e3aa6ad3a28
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Sat Aug 9 13:44:58 2008 +0200

    [ARM] Move include/asm-arm/plat-orion to arch/arm/plat-orion/include/plat
    
    This patch performs the equivalent include directory shuffle for
    plat-orion, and fixes up all users.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index cc2a017fd2a9..2545ff9e5830 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -16,7 +16,7 @@
 #include <asm/gpio.h>
 #include <asm/io.h>
 #include <mach/orion5x.h>
-#include <asm/plat-orion/irq.h>
+#include <plat/irq.h>
 #include "common.h"
 
 /*****************************************************************************

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index 9ae3f6dc7839..cc2a017fd2a9 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -15,7 +15,7 @@
 #include <linux/irq.h>
 #include <asm/gpio.h>
 #include <asm/io.h>
-#include <asm/arch/orion5x.h>
+#include <mach/orion5x.h>
 #include <asm/plat-orion/irq.h>
 #include "common.h"
 

commit 6cab48602996cdbcb277375a8107d53e21e8c9b9
Author: Dmitry Baryshkov <dbaryshkov@gmail.com>
Date:   Sun Jul 27 04:23:31 2008 +0100

    [ARM] 5179/1: Replace obsolete IRQT_* and __IRQT_* values with IRQ_TYPE_*
    
    IRQT_* and __IRQT_* were obsoleted long ago by patch [3692/1].
    Remove them completely. Sed script for the reference:
    
    s/__IRQT_RISEDGE/IRQ_TYPE_EDGE_RISING/g
    s/__IRQT_FALEDGE/IRQ_TYPE_EDGE_FALLING/g
    s/__IRQT_LOWLVL/IRQ_TYPE_LEVEL_LOW/g
    s/__IRQT_HIGHLVL/IRQ_TYPE_LEVEL_HIGH/g
    s/IRQT_RISING/IRQ_TYPE_EDGE_RISING/g
    s/IRQT_FALLING/IRQ_TYPE_EDGE_FALLING/g
    s/IRQT_BOTHEDGE/IRQ_TYPE_EDGE_BOTH/g
    s/IRQT_LOW/IRQ_TYPE_LEVEL_LOW/g
    s/IRQT_HIGH/IRQ_TYPE_LEVEL_HIGH/g
    s/IRQT_PROBE/IRQ_TYPE_PROBE/g
    s/IRQT_NOEDGE/IRQ_TYPE_NONE/g
    
    Signed-off-by: Dmitry Baryshkov <dbaryshkov@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index e2a0084ab4a3..9ae3f6dc7839 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -91,27 +91,27 @@ static int orion5x_gpio_set_irq_type(u32 irq, u32 type)
 	desc = irq_desc + irq;
 
 	switch (type) {
-	case IRQT_HIGH:
+	case IRQ_TYPE_LEVEL_HIGH:
 		desc->handle_irq = handle_level_irq;
 		desc->status |= IRQ_LEVEL;
 		orion5x_clrbits(GPIO_IN_POL, (1 << pin));
 		break;
-	case IRQT_LOW:
+	case IRQ_TYPE_LEVEL_LOW:
 		desc->handle_irq = handle_level_irq;
 		desc->status |= IRQ_LEVEL;
 		orion5x_setbits(GPIO_IN_POL, (1 << pin));
 		break;
-	case IRQT_RISING:
+	case IRQ_TYPE_EDGE_RISING:
 		desc->handle_irq = handle_edge_irq;
 		desc->status &= ~IRQ_LEVEL;
 		orion5x_clrbits(GPIO_IN_POL, (1 << pin));
 		break;
-	case IRQT_FALLING:
+	case IRQ_TYPE_EDGE_FALLING:
 		desc->handle_irq = handle_edge_irq;
 		desc->status &= ~IRQ_LEVEL;
 		orion5x_setbits(GPIO_IN_POL, (1 << pin));
 		break;
-	case IRQT_BOTHEDGE:
+	case IRQ_TYPE_EDGE_BOTH:
 		desc->handle_irq = handle_edge_irq;
 		desc->status &= ~IRQ_LEVEL;
 		/*
@@ -156,7 +156,7 @@ static void orion5x_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
 		if (cause & (1 << pin)) {
 			irq = gpio_to_irq(pin);
 			desc = irq_desc + irq;
-			if ((desc->status & IRQ_TYPE_SENSE_MASK) == IRQT_BOTHEDGE) {
+			if ((desc->status & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {
 				/* Swap polarity (race with GPIO line) */
 				u32 polarity = readl(GPIO_IN_POL);
 				polarity ^= 1 << pin;

commit 79e90dd5aa95adfdc3117db8a559da3d0195ba58
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Wed May 28 16:43:48 2008 +0200

    [ARM] Orion: nuke orion5x_{read,write}
    
    Nuke the Orion-specific orion5x_{read,write} wrappers.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
index dd21f38c5d37..e2a0084ab4a3 100644
--- a/arch/arm/mach-orion5x/irq.c
+++ b/arch/arm/mach-orion5x/irq.c
@@ -82,7 +82,7 @@ static int orion5x_gpio_set_irq_type(u32 irq, u32 type)
 	int pin = irq_to_gpio(irq);
 	struct irq_desc *desc;
 
-	if ((orion5x_read(GPIO_IO_CONF) & (1 << pin)) == 0) {
+	if ((readl(GPIO_IO_CONF) & (1 << pin)) == 0) {
 		printk(KERN_ERR "orion5x_gpio_set_irq_type failed "
 				"(irq %d, pin %d).\n", irq, pin);
 		return -EINVAL;
@@ -117,7 +117,7 @@ static int orion5x_gpio_set_irq_type(u32 irq, u32 type)
 		/*
 		 * set initial polarity based on current input level
 		 */
-		if ((orion5x_read(GPIO_IN_POL) ^ orion5x_read(GPIO_DATA_IN))
+		if ((readl(GPIO_IN_POL) ^ readl(GPIO_DATA_IN))
 		    & (1 << pin))
 			orion5x_setbits(GPIO_IN_POL, (1 << pin)); /* falling */
 		else
@@ -149,8 +149,8 @@ static void orion5x_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
 
 	BUG_ON(irq < IRQ_ORION5X_GPIO_0_7 || irq > IRQ_ORION5X_GPIO_24_31);
 	offs = (irq - IRQ_ORION5X_GPIO_0_7) * 8;
-	cause = (orion5x_read(GPIO_DATA_IN) & orion5x_read(GPIO_LEVEL_MASK)) |
-		(orion5x_read(GPIO_EDGE_CAUSE) & orion5x_read(GPIO_EDGE_MASK));
+	cause = (readl(GPIO_DATA_IN) & readl(GPIO_LEVEL_MASK)) |
+		(readl(GPIO_EDGE_CAUSE) & readl(GPIO_EDGE_MASK));
 
 	for (pin = offs; pin < offs + 8; pin++) {
 		if (cause & (1 << pin)) {
@@ -158,9 +158,9 @@ static void orion5x_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
 			desc = irq_desc + irq;
 			if ((desc->status & IRQ_TYPE_SENSE_MASK) == IRQT_BOTHEDGE) {
 				/* Swap polarity (race with GPIO line) */
-				u32 polarity = orion5x_read(GPIO_IN_POL);
+				u32 polarity = readl(GPIO_IN_POL);
 				polarity ^= 1 << pin;
-				orion5x_write(GPIO_IN_POL, polarity);
+				writel(polarity, GPIO_IN_POL);
 			}
 			desc_handle_irq(irq, desc);
 		}
@@ -175,9 +175,9 @@ static void __init orion5x_init_gpio_irq(void)
 	/*
 	 * Mask and clear GPIO IRQ interrupts
 	 */
-	orion5x_write(GPIO_LEVEL_MASK, 0x0);
-	orion5x_write(GPIO_EDGE_MASK, 0x0);
-	orion5x_write(GPIO_EDGE_CAUSE, 0x0);
+	writel(0x0, GPIO_LEVEL_MASK);
+	writel(0x0, GPIO_EDGE_MASK);
+	writel(0x0, GPIO_EDGE_CAUSE);
 
 	/*
 	 * Register chained level handlers for GPIO IRQs by default.

commit 9dd0b194bf6804b1998f0fe261b2606ec7b58d72
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Thu Mar 27 14:51:41 2008 -0400

    Orion: orion -> orion5x rename
    
    Do a global s/orion/orion5x/ of the Orion 5x-specific bits (i.e.
    not the plat-orion bits.)
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Reviewed-by: Tzachi Perelstein <tzachi@marvell.com>
    Acked-by: Saeed Bishara <saeed@marvell.com>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Nicolas Pitre <nico@marvell.com>

diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c
new file mode 100644
index 000000000000..dd21f38c5d37
--- /dev/null
+++ b/arch/arm/mach-orion5x/irq.c
@@ -0,0 +1,211 @@
+/*
+ * arch/arm/mach-orion5x/irq.c
+ *
+ * Core IRQ functions for Marvell Orion System On Chip
+ *
+ * Maintainer: Tzachi Perelstein <tzachi@marvell.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <asm/arch/orion5x.h>
+#include <asm/plat-orion/irq.h>
+#include "common.h"
+
+/*****************************************************************************
+ * Orion GPIO IRQ
+ *
+ * GPIO_IN_POL register controlls whether GPIO_DATA_IN will hold the same
+ * value of the line or the opposite value.
+ *
+ * Level IRQ handlers: DATA_IN is used directly as cause register.
+ *                     Interrupt are masked by LEVEL_MASK registers.
+ * Edge IRQ handlers:  Change in DATA_IN are latched in EDGE_CAUSE.
+ *                     Interrupt are masked by EDGE_MASK registers.
+ * Both-edge handlers: Similar to regular Edge handlers, but also swaps
+ *                     the polarity to catch the next line transaction.
+ *                     This is a race condition that might not perfectly
+ *                     work on some use cases.
+ *
+ * Every eight GPIO lines are grouped (OR'ed) before going up to main
+ * cause register.
+ *
+ *                    EDGE  cause    mask
+ *        data-in   /--------| |-----| |----\
+ *     -----| |-----                         ---- to main cause reg
+ *           X      \----------------| |----/
+ *        polarity    LEVEL          mask
+ *
+ ****************************************************************************/
+static void orion5x_gpio_irq_ack(u32 irq)
+{
+	int pin = irq_to_gpio(irq);
+	if (irq_desc[irq].status & IRQ_LEVEL)
+		/*
+		 * Mask bit for level interrupt
+		 */
+		orion5x_clrbits(GPIO_LEVEL_MASK, 1 << pin);
+	else
+		/*
+		 * Clear casue bit for egde interrupt
+		 */
+		orion5x_clrbits(GPIO_EDGE_CAUSE, 1 << pin);
+}
+
+static void orion5x_gpio_irq_mask(u32 irq)
+{
+	int pin = irq_to_gpio(irq);
+	if (irq_desc[irq].status & IRQ_LEVEL)
+		orion5x_clrbits(GPIO_LEVEL_MASK, 1 << pin);
+	else
+		orion5x_clrbits(GPIO_EDGE_MASK, 1 << pin);
+}
+
+static void orion5x_gpio_irq_unmask(u32 irq)
+{
+	int pin = irq_to_gpio(irq);
+	if (irq_desc[irq].status & IRQ_LEVEL)
+		orion5x_setbits(GPIO_LEVEL_MASK, 1 << pin);
+	else
+		orion5x_setbits(GPIO_EDGE_MASK, 1 << pin);
+}
+
+static int orion5x_gpio_set_irq_type(u32 irq, u32 type)
+{
+	int pin = irq_to_gpio(irq);
+	struct irq_desc *desc;
+
+	if ((orion5x_read(GPIO_IO_CONF) & (1 << pin)) == 0) {
+		printk(KERN_ERR "orion5x_gpio_set_irq_type failed "
+				"(irq %d, pin %d).\n", irq, pin);
+		return -EINVAL;
+	}
+
+	desc = irq_desc + irq;
+
+	switch (type) {
+	case IRQT_HIGH:
+		desc->handle_irq = handle_level_irq;
+		desc->status |= IRQ_LEVEL;
+		orion5x_clrbits(GPIO_IN_POL, (1 << pin));
+		break;
+	case IRQT_LOW:
+		desc->handle_irq = handle_level_irq;
+		desc->status |= IRQ_LEVEL;
+		orion5x_setbits(GPIO_IN_POL, (1 << pin));
+		break;
+	case IRQT_RISING:
+		desc->handle_irq = handle_edge_irq;
+		desc->status &= ~IRQ_LEVEL;
+		orion5x_clrbits(GPIO_IN_POL, (1 << pin));
+		break;
+	case IRQT_FALLING:
+		desc->handle_irq = handle_edge_irq;
+		desc->status &= ~IRQ_LEVEL;
+		orion5x_setbits(GPIO_IN_POL, (1 << pin));
+		break;
+	case IRQT_BOTHEDGE:
+		desc->handle_irq = handle_edge_irq;
+		desc->status &= ~IRQ_LEVEL;
+		/*
+		 * set initial polarity based on current input level
+		 */
+		if ((orion5x_read(GPIO_IN_POL) ^ orion5x_read(GPIO_DATA_IN))
+		    & (1 << pin))
+			orion5x_setbits(GPIO_IN_POL, (1 << pin)); /* falling */
+		else
+			orion5x_clrbits(GPIO_IN_POL, (1 << pin)); /* rising */
+
+		break;
+	default:
+		printk(KERN_ERR "failed to set irq=%d (type=%d)\n", irq, type);
+		return -EINVAL;
+	}
+
+	desc->status &= ~IRQ_TYPE_SENSE_MASK;
+	desc->status |= type & IRQ_TYPE_SENSE_MASK;
+
+	return 0;
+}
+
+static struct irq_chip orion5x_gpio_irq_chip = {
+	.name		= "Orion-IRQ-GPIO",
+	.ack		= orion5x_gpio_irq_ack,
+	.mask		= orion5x_gpio_irq_mask,
+	.unmask		= orion5x_gpio_irq_unmask,
+	.set_type	= orion5x_gpio_set_irq_type,
+};
+
+static void orion5x_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
+{
+	u32 cause, offs, pin;
+
+	BUG_ON(irq < IRQ_ORION5X_GPIO_0_7 || irq > IRQ_ORION5X_GPIO_24_31);
+	offs = (irq - IRQ_ORION5X_GPIO_0_7) * 8;
+	cause = (orion5x_read(GPIO_DATA_IN) & orion5x_read(GPIO_LEVEL_MASK)) |
+		(orion5x_read(GPIO_EDGE_CAUSE) & orion5x_read(GPIO_EDGE_MASK));
+
+	for (pin = offs; pin < offs + 8; pin++) {
+		if (cause & (1 << pin)) {
+			irq = gpio_to_irq(pin);
+			desc = irq_desc + irq;
+			if ((desc->status & IRQ_TYPE_SENSE_MASK) == IRQT_BOTHEDGE) {
+				/* Swap polarity (race with GPIO line) */
+				u32 polarity = orion5x_read(GPIO_IN_POL);
+				polarity ^= 1 << pin;
+				orion5x_write(GPIO_IN_POL, polarity);
+			}
+			desc_handle_irq(irq, desc);
+		}
+	}
+}
+
+static void __init orion5x_init_gpio_irq(void)
+{
+	int i;
+	struct irq_desc *desc;
+
+	/*
+	 * Mask and clear GPIO IRQ interrupts
+	 */
+	orion5x_write(GPIO_LEVEL_MASK, 0x0);
+	orion5x_write(GPIO_EDGE_MASK, 0x0);
+	orion5x_write(GPIO_EDGE_CAUSE, 0x0);
+
+	/*
+	 * Register chained level handlers for GPIO IRQs by default.
+	 * User can use set_type() if he wants to use edge types handlers.
+	 */
+	for (i = IRQ_ORION5X_GPIO_START; i < NR_IRQS; i++) {
+		set_irq_chip(i, &orion5x_gpio_irq_chip);
+		set_irq_handler(i, handle_level_irq);
+		desc = irq_desc + i;
+		desc->status |= IRQ_LEVEL;
+		set_irq_flags(i, IRQF_VALID);
+	}
+	set_irq_chained_handler(IRQ_ORION5X_GPIO_0_7, orion5x_gpio_irq_handler);
+	set_irq_chained_handler(IRQ_ORION5X_GPIO_8_15, orion5x_gpio_irq_handler);
+	set_irq_chained_handler(IRQ_ORION5X_GPIO_16_23, orion5x_gpio_irq_handler);
+	set_irq_chained_handler(IRQ_ORION5X_GPIO_24_31, orion5x_gpio_irq_handler);
+}
+
+/*****************************************************************************
+ * Orion Main IRQ
+ ****************************************************************************/
+static void __init orion5x_init_main_irq(void)
+{
+	orion_irq_init(0, (void __iomem *)MAIN_IRQ_MASK);
+}
+
+void __init orion5x_init_irq(void)
+{
+	orion5x_init_main_irq();
+	orion5x_init_gpio_irq();
+}
