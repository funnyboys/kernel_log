commit c22c2c6008d69ff2632f8a69c62782468c2bb5a0
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Dec 2 22:27:08 2015 +0100

    ARM: orion5x: clean up mach/*.h headers
    
    This is a simple move of all header files that are no longer
    included by anything else from the include/mach directory
    to the platform directory itself as preparation for
    multiplatform support.
    
    The mach/uncompress.h headers are left in place for now,
    and are mildly modified to be independent of the other
    headers. They will be removed entirely when ARCH_MULTIPLATFORM
    gets enabled and they become obsolete.
    
    Rather than updating the path names inside of the comments
    of each header, I delete those comments to avoid having to
    update them again, should they get moved or copied another
    time.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/mach-orion5x/mpp.c b/arch/arm/mach-orion5x/mpp.c
index 5b70026f478c..19ef18594415 100644
--- a/arch/arm/mach-orion5x/mpp.c
+++ b/arch/arm/mach-orion5x/mpp.c
@@ -11,8 +11,8 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/io.h>
-#include <mach/hardware.h>
 #include <plat/mpp.h>
+#include "orion5x.h"
 #include "mpp.h"
 #include "common.h"
 

commit 63a9332b232bdab0df6ef18a9f39e8d58a82bda4
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Dec 7 21:48:07 2011 +0100

    ARM: Orion: Get address map from plat-orion instead of via platform_data
    
    Use an getter function in plat-orion/addr-map.c to get the address map
    structure, rather than pass it to drivers in the platform_data
    structures. When the drivers are built for none orion platforms, a
    dummy function is provided instead which returns NULL.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Tested-by: Michael Walle <michael@walle.cc>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/mach-orion5x/mpp.c b/arch/arm/mach-orion5x/mpp.c
index b6ddd7a5db6a..5b70026f478c 100644
--- a/arch/arm/mach-orion5x/mpp.c
+++ b/arch/arm/mach-orion5x/mpp.c
@@ -10,7 +10,6 @@
 
 #include <linux/kernel.h>
 #include <linux/init.h>
-#include <linux/mbus.h>
 #include <linux/io.h>
 #include <mach/hardware.h>
 #include <plat/mpp.h>

commit e8885cb68dbdaa0a292bf1defc98addd0aed9b04
Author: Imre Kaloz <kaloz@openwrt.org>
Date:   Mon Jul 18 22:05:12 2011 +0200

    ARM: orion5x: fixup 5181 MPP mask check
    
    During the refactoring of the Orion MPP code, the detection for
    the 5181l as been used to select the 5181 MPP mask, which is wrong.
    Select the 5181 mask for all 5181 variants.
    
    Signed-off-by: Imre Kaloz <kaloz@openwrt.org>
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>

diff --git a/arch/arm/mach-orion5x/mpp.c b/arch/arm/mach-orion5x/mpp.c
index f12c41b98d46..b6ddd7a5db6a 100644
--- a/arch/arm/mach-orion5x/mpp.c
+++ b/arch/arm/mach-orion5x/mpp.c
@@ -24,7 +24,7 @@ static unsigned int __init orion5x_variant(void)
 
 	orion5x_pcie_id(&dev, &rev);
 
-	if (dev == MV88F5181_DEV_ID && rev >= MV88F5181L_REV_A0)
+	if (dev == MV88F5181_DEV_ID)
 		return MPP_F5181_MASK;
 
 	if (dev == MV88F5182_DEV_ID)

commit 554cdaefd1cf7bb54b209c4e68c7cec87ce442a9
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun May 15 13:32:53 2011 +0200

    ARM: orion5x: Refactor mpp code to use common orion platform mpp.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/mach-orion5x/mpp.c b/arch/arm/mach-orion5x/mpp.c
index 2288207726e4..f12c41b98d46 100644
--- a/arch/arm/mach-orion5x/mpp.c
+++ b/arch/arm/mach-orion5x/mpp.c
@@ -12,154 +12,34 @@
 #include <linux/init.h>
 #include <linux/mbus.h>
 #include <linux/io.h>
-#include <asm/gpio.h>
 #include <mach/hardware.h>
-#include "common.h"
+#include <plat/mpp.h>
 #include "mpp.h"
+#include "common.h"
 
-static int is_5181l(void)
-{
-	u32 dev;
-	u32 rev;
-
-	orion5x_pcie_id(&dev, &rev);
-
-	return !!(dev == MV88F5181_DEV_ID && rev >= MV88F5181L_REV_A0);
-}
-
-static int is_5182(void)
+static unsigned int __init orion5x_variant(void)
 {
 	u32 dev;
 	u32 rev;
 
 	orion5x_pcie_id(&dev, &rev);
 
-	return !!(dev == MV88F5182_DEV_ID);
-}
+	if (dev == MV88F5181_DEV_ID && rev >= MV88F5181L_REV_A0)
+		return MPP_F5181_MASK;
 
-static int is_5281(void)
-{
-	u32 dev;
-	u32 rev;
+	if (dev == MV88F5182_DEV_ID)
+		return MPP_F5182_MASK;
 
-	orion5x_pcie_id(&dev, &rev);
+	if (dev == MV88F5281_DEV_ID)
+		return MPP_F5281_MASK;
 
-	return !!(dev == MV88F5281_DEV_ID);
+	printk(KERN_ERR "MPP setup: unknown orion5x variant "
+	       "(dev %#x rev %#x)\n", dev, rev);
+	return 0;
 }
 
-static int __init determine_type_encoding(int mpp, enum orion5x_mpp_type type)
+void __init orion5x_mpp_conf(unsigned int *mpp_list)
 {
-	switch (type) {
-	case MPP_UNUSED:
-	case MPP_GPIO:
-		if (mpp == 0)
-			return 3;
-		if (mpp >= 1 && mpp <= 15)
-			return 0;
-		if (mpp >= 16 && mpp <= 19) {
-			if (is_5182())
-				return 5;
-			if (type == MPP_UNUSED)
-				return 0;
-		}
-		return -1;
-
-	case MPP_PCIE_RST_OUTn:
-		if (mpp == 0)
-			return 0;
-		return -1;
-
-	case MPP_PCI_ARB:
-		if (mpp >= 0 && mpp <= 7)
-			return 2;
-		return -1;
-
-	case MPP_PCI_PMEn:
-		if (mpp == 2)
-			return 3;
-		return -1;
-
-	case MPP_GIGE:
-		if (mpp >= 8 && mpp <= 19)
-			return 1;
-		return -1;
-
-	case MPP_NAND:
-		if (is_5182() || is_5281()) {
-			if (mpp >= 4 && mpp <= 7)
-				return 4;
-			if (mpp >= 12 && mpp <= 17)
-				return 4;
-		}
-		return -1;
-
-	case MPP_PCI_CLK:
-		if (is_5181l() && mpp >= 6 && mpp <= 7)
-			return 5;
-		return -1;
-
-	case MPP_SATA_LED:
-		if (is_5182()) {
-			if (mpp >= 4 && mpp <= 7)
-				return 5;
-			if (mpp >= 12 && mpp <= 15)
-				return 5;
-		}
-		return -1;
-
-	case MPP_UART:
-		if (mpp >= 16 && mpp <= 19)
-			return 0;
-		return -1;
-	}
-
-	printk(KERN_INFO "unknown MPP type %d\n", type);
-
-	return -1;
-}
-
-void __init orion5x_mpp_conf(struct orion5x_mpp_mode *mode)
-{
-	u32 mpp_0_7_ctrl = readl(MPP_0_7_CTRL);
-	u32 mpp_8_15_ctrl = readl(MPP_8_15_CTRL);
-	u32 mpp_16_19_ctrl = readl(MPP_16_19_CTRL);
-
-	for ( ; mode->mpp >= 0; mode++) {
-		u32 *reg;
-		int num_type;
-		int shift;
-
-		if (mode->mpp >= 0 && mode->mpp <= 7)
-			reg = &mpp_0_7_ctrl;
-		else if (mode->mpp >= 8 && mode->mpp <= 15)
-			reg = &mpp_8_15_ctrl;
-		else if (mode->mpp >= 16 && mode->mpp <= 19)
-			reg = &mpp_16_19_ctrl;
-		else {
-			printk(KERN_ERR "orion5x_mpp_conf: invalid MPP "
-					"(%d)\n", mode->mpp);
-			continue;
-		}
-
-		num_type = determine_type_encoding(mode->mpp, mode->type);
-		if (num_type < 0) {
-			printk(KERN_ERR "orion5x_mpp_conf: invalid MPP "
-					"combination (%d, %d)\n", mode->mpp,
-					mode->type);
-			continue;
-		}
-
-		shift = (mode->mpp & 7) << 2;
-		*reg &= ~(0xf << shift);
-		*reg |= (num_type & 0xf) << shift;
-
-		if (mode->type == MPP_UNUSED && (mode->mpp < 16 || is_5182()))
-			orion_gpio_set_unused(mode->mpp);
-
-		orion_gpio_set_valid(mode->mpp, !!(mode->type == MPP_GPIO));
-	}
-
-	writel(mpp_0_7_ctrl, MPP_0_7_CTRL);
-	writel(mpp_8_15_ctrl, MPP_8_15_CTRL);
-	writel(mpp_16_19_ctrl, MPP_16_19_CTRL);
+	orion_mpp_conf(mpp_list, orion5x_variant(),
+		       MPP_MAX, ORION5X_DEV_BUS_VIRT_BASE);
 }

commit 9eac6d0a4e7e5149a7f86575b46d710ad2e05fe2
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Tue Dec 14 12:54:03 2010 +0100

    ARM: Remove dependency of plat-orion GPIO code on mach directory includes.
    
    This patch makes the various mach dirs that use the plat-orion GPIO
    code pass in GPIO-related platform info (GPIO controller base address,
    secondary base IRQ number, etc) explicitly, instead of having
    plat-orion get those values by including a mach dir include file --
    the latter mechanism is problematic if you want to support multiple
    ARM platforms in the same kernel image.
    
    Signed-off-by: Lennert Buytenhek <buytenh@secretlab.ca>
    Signed-off-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/mach-orion5x/mpp.c b/arch/arm/mach-orion5x/mpp.c
index db485d3b8144..2288207726e4 100644
--- a/arch/arm/mach-orion5x/mpp.c
+++ b/arch/arm/mach-orion5x/mpp.c
@@ -124,9 +124,6 @@ void __init orion5x_mpp_conf(struct orion5x_mpp_mode *mode)
 	u32 mpp_8_15_ctrl = readl(MPP_8_15_CTRL);
 	u32 mpp_16_19_ctrl = readl(MPP_16_19_CTRL);
 
-	/* Initialize gpiolib. */
-	orion_gpio_init();
-
 	for ( ; mode->mpp >= 0; mode++) {
 		u32 *reg;
 		int num_type;

commit 7350f419724fd9472d3b5cc521538713f9797b62
Author: Mike Rapoport <mike@compulab.co.il>
Date:   Wed Nov 3 17:22:00 2010 +0200

    ARM: orion5x/kirkwood/mv78xx0: fix MPP configuration corner cases
    
    Wrong MPP configuration would cause <cpu>_mpp_conf loop infinitely
    because the mpp list iterator would not be incremented.
    
    Signed-off-by: Mike Rapoport <mike@compulab.co.il>
    Signed-off-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/mach-orion5x/mpp.c b/arch/arm/mach-orion5x/mpp.c
index bc4c3b9aaf83..db485d3b8144 100644
--- a/arch/arm/mach-orion5x/mpp.c
+++ b/arch/arm/mach-orion5x/mpp.c
@@ -127,7 +127,7 @@ void __init orion5x_mpp_conf(struct orion5x_mpp_mode *mode)
 	/* Initialize gpiolib. */
 	orion_gpio_init();
 
-	while (mode->mpp >= 0) {
+	for ( ; mode->mpp >= 0; mode++) {
 		u32 *reg;
 		int num_type;
 		int shift;
@@ -160,8 +160,6 @@ void __init orion5x_mpp_conf(struct orion5x_mpp_mode *mode)
 			orion_gpio_set_unused(mode->mpp);
 
 		orion_gpio_set_valid(mode->mpp, !!(mode->type == MPP_GPIO));
-
-		mode++;
 	}
 
 	writel(mpp_0_7_ctrl, MPP_0_7_CTRL);

commit a88656553d18c324554855fccc730c9644048111
Author: Erik Benada <erikbenada@yahoo.ca>
Date:   Thu May 28 17:08:55 2009 -0700

    [ARM] orion: convert gpio to use gpiolib
    
    Signed-off-by: Erik Benada <erikbenada@yahoo.ca>
    
    [ nico: fix locking, additional cleanups ]
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>

diff --git a/arch/arm/mach-orion5x/mpp.c b/arch/arm/mach-orion5x/mpp.c
index e23a3f91d6c6..bc4c3b9aaf83 100644
--- a/arch/arm/mach-orion5x/mpp.c
+++ b/arch/arm/mach-orion5x/mpp.c
@@ -124,6 +124,9 @@ void __init orion5x_mpp_conf(struct orion5x_mpp_mode *mode)
 	u32 mpp_8_15_ctrl = readl(MPP_8_15_CTRL);
 	u32 mpp_16_19_ctrl = readl(MPP_16_19_CTRL);
 
+	/* Initialize gpiolib. */
+	orion_gpio_init();
+
 	while (mode->mpp >= 0) {
 		u32 *reg;
 		int num_type;

commit 9569dae75f6f6987e79fa26cf6da3fc24006c996
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Mon Oct 20 01:51:03 2008 +0200

    [ARM] Orion: share GPIO handling code
    
    Split off Orion GPIO handling code into plat-orion/, and add
    support for multiple sets of (32) GPIO pins.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Signed-off-by: Nicolas Pitre <nico@marvell.com>

diff --git a/arch/arm/mach-orion5x/mpp.c b/arch/arm/mach-orion5x/mpp.c
index 640ea2a3fc6c..e23a3f91d6c6 100644
--- a/arch/arm/mach-orion5x/mpp.c
+++ b/arch/arm/mach-orion5x/mpp.c
@@ -12,6 +12,7 @@
 #include <linux/init.h>
 #include <linux/mbus.h>
 #include <linux/io.h>
+#include <asm/gpio.h>
 #include <mach/hardware.h>
 #include "common.h"
 #include "mpp.h"
@@ -152,7 +153,10 @@ void __init orion5x_mpp_conf(struct orion5x_mpp_mode *mode)
 		*reg &= ~(0xf << shift);
 		*reg |= (num_type & 0xf) << shift;
 
-		orion5x_gpio_set_valid(mode->mpp, !!(mode->type == MPP_GPIO));
+		if (mode->type == MPP_UNUSED && (mode->mpp < 16 || is_5182()))
+			orion_gpio_set_unused(mode->mpp);
+
+		orion_gpio_set_valid(mode->mpp, !!(mode->type == MPP_GPIO));
 
 		mode++;
 	}

commit fced80c735941fa518ac67c0b61bbe153fb8c050
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Sep 6 12:10:45 2008 +0100

    [ARM] Convert asm/io.h to linux/io.h
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-orion5x/mpp.c b/arch/arm/mach-orion5x/mpp.c
index c04ab0e16ea1..640ea2a3fc6c 100644
--- a/arch/arm/mach-orion5x/mpp.c
+++ b/arch/arm/mach-orion5x/mpp.c
@@ -11,8 +11,8 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/mbus.h>
+#include <linux/io.h>
 #include <mach/hardware.h>
-#include <asm/io.h>
 #include "common.h"
 #include "mpp.h"
 

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-orion5x/mpp.c b/arch/arm/mach-orion5x/mpp.c
index 8eadc9b5b0a5..c04ab0e16ea1 100644
--- a/arch/arm/mach-orion5x/mpp.c
+++ b/arch/arm/mach-orion5x/mpp.c
@@ -11,7 +11,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/mbus.h>
-#include <asm/arch/hardware.h>
+#include <mach/hardware.h>
 #include <asm/io.h>
 #include "common.h"
 #include "mpp.h"

commit be509729356b7433f73df2b9a966674a437fbbc1
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Aug 4 10:41:28 2008 +0100

    [ARM] Remove asm/hardware.h, use asm/arch/hardware.h instead
    
    Remove includes of asm/hardware.h in addition to asm/arch/hardware.h.
    Then, since asm/hardware.h only exists to include asm/arch/hardware.h,
    update everything to directly include asm/arch/hardware.h and remove
    asm/hardware.h.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-orion5x/mpp.c b/arch/arm/mach-orion5x/mpp.c
index a48cadb01590..8eadc9b5b0a5 100644
--- a/arch/arm/mach-orion5x/mpp.c
+++ b/arch/arm/mach-orion5x/mpp.c
@@ -11,7 +11,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/mbus.h>
-#include <asm/hardware.h>
+#include <asm/arch/hardware.h>
 #include <asm/io.h>
 #include "common.h"
 #include "mpp.h"

commit 19cfd5c09f780ac870fd9d89201c4ebc0b22be81
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Sat May 10 23:25:46 2008 +0200

    [ARM] Orion: rework MPP handling
    
    Instead of having board code poke directly into the MPP configuration
    registers, and separately calling orion5x_gpio_set_valid_pins() to
    indicate which MPP pins can be used as GPIO pins, introduce a helper
    function for configuring the roles of each of the MPP pins, and have
    that helper function handle gpio validity internally.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Acked-by: Sylver Bruneau <sylver.bruneau@googlemail.com>
    Acked-by: Russell King <linux@arm.linux.org.uk>

diff --git a/arch/arm/mach-orion5x/mpp.c b/arch/arm/mach-orion5x/mpp.c
new file mode 100644
index 000000000000..a48cadb01590
--- /dev/null
+++ b/arch/arm/mach-orion5x/mpp.c
@@ -0,0 +1,163 @@
+/*
+ * arch/arm/mach-orion5x/mpp.c
+ *
+ * MPP functions for Marvell Orion 5x SoCs
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mbus.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include "common.h"
+#include "mpp.h"
+
+static int is_5181l(void)
+{
+	u32 dev;
+	u32 rev;
+
+	orion5x_pcie_id(&dev, &rev);
+
+	return !!(dev == MV88F5181_DEV_ID && rev >= MV88F5181L_REV_A0);
+}
+
+static int is_5182(void)
+{
+	u32 dev;
+	u32 rev;
+
+	orion5x_pcie_id(&dev, &rev);
+
+	return !!(dev == MV88F5182_DEV_ID);
+}
+
+static int is_5281(void)
+{
+	u32 dev;
+	u32 rev;
+
+	orion5x_pcie_id(&dev, &rev);
+
+	return !!(dev == MV88F5281_DEV_ID);
+}
+
+static int __init determine_type_encoding(int mpp, enum orion5x_mpp_type type)
+{
+	switch (type) {
+	case MPP_UNUSED:
+	case MPP_GPIO:
+		if (mpp == 0)
+			return 3;
+		if (mpp >= 1 && mpp <= 15)
+			return 0;
+		if (mpp >= 16 && mpp <= 19) {
+			if (is_5182())
+				return 5;
+			if (type == MPP_UNUSED)
+				return 0;
+		}
+		return -1;
+
+	case MPP_PCIE_RST_OUTn:
+		if (mpp == 0)
+			return 0;
+		return -1;
+
+	case MPP_PCI_ARB:
+		if (mpp >= 0 && mpp <= 7)
+			return 2;
+		return -1;
+
+	case MPP_PCI_PMEn:
+		if (mpp == 2)
+			return 3;
+		return -1;
+
+	case MPP_GIGE:
+		if (mpp >= 8 && mpp <= 19)
+			return 1;
+		return -1;
+
+	case MPP_NAND:
+		if (is_5182() || is_5281()) {
+			if (mpp >= 4 && mpp <= 7)
+				return 4;
+			if (mpp >= 12 && mpp <= 17)
+				return 4;
+		}
+		return -1;
+
+	case MPP_PCI_CLK:
+		if (is_5181l() && mpp >= 6 && mpp <= 7)
+			return 5;
+		return -1;
+
+	case MPP_SATA_LED:
+		if (is_5182()) {
+			if (mpp >= 4 && mpp <= 7)
+				return 5;
+			if (mpp >= 12 && mpp <= 15)
+				return 5;
+		}
+		return -1;
+
+	case MPP_UART:
+		if (mpp >= 16 && mpp <= 19)
+			return 0;
+		return -1;
+	}
+
+	printk(KERN_INFO "unknown MPP type %d\n", type);
+
+	return -1;
+}
+
+void __init orion5x_mpp_conf(struct orion5x_mpp_mode *mode)
+{
+	u32 mpp_0_7_ctrl = readl(MPP_0_7_CTRL);
+	u32 mpp_8_15_ctrl = readl(MPP_8_15_CTRL);
+	u32 mpp_16_19_ctrl = readl(MPP_16_19_CTRL);
+
+	while (mode->mpp >= 0) {
+		u32 *reg;
+		int num_type;
+		int shift;
+
+		if (mode->mpp >= 0 && mode->mpp <= 7)
+			reg = &mpp_0_7_ctrl;
+		else if (mode->mpp >= 8 && mode->mpp <= 15)
+			reg = &mpp_8_15_ctrl;
+		else if (mode->mpp >= 16 && mode->mpp <= 19)
+			reg = &mpp_16_19_ctrl;
+		else {
+			printk(KERN_ERR "orion5x_mpp_conf: invalid MPP "
+					"(%d)\n", mode->mpp);
+			continue;
+		}
+
+		num_type = determine_type_encoding(mode->mpp, mode->type);
+		if (num_type < 0) {
+			printk(KERN_ERR "orion5x_mpp_conf: invalid MPP "
+					"combination (%d, %d)\n", mode->mpp,
+					mode->type);
+			continue;
+		}
+
+		shift = (mode->mpp & 7) << 2;
+		*reg &= ~(0xf << shift);
+		*reg |= (num_type & 0xf) << shift;
+
+		orion5x_gpio_set_valid(mode->mpp, !!(mode->type == MPP_GPIO));
+
+		mode++;
+	}
+
+	writel(mpp_0_7_ctrl, MPP_0_7_CTRL);
+	writel(mpp_8_15_ctrl, MPP_8_15_CTRL);
+	writel(mpp_16_19_ctrl, MPP_16_19_CTRL);
+}
