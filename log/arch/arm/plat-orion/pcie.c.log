commit 59f16137b2a09b2fba7e4d00088f99ce0ea9a6de
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Wed Mar 6 17:59:57 2013 +0100

    arm: plat-orion: use mv_mbus_dram_info() in PCIe code
    
    The PCIe code was directly accessing the orion_mbus_dram_info
    structure to get access to a description of the SDRAM chip selects in
    order to configure the PCIe -> SDRAM address decoding
    windows.
    
    However, with the introduction of the orion-mbus driver, we are going
    to remove this global structure and instead leave only the exported
    mv_mbus_dram_info() function to access this description of the SDRAM
    chip selects. Therefore, we simply switch to using this API.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/plat-orion/pcie.c b/arch/arm/plat-orion/pcie.c
index f20a321088a2..8b8c06d2e9c4 100644
--- a/arch/arm/plat-orion/pcie.c
+++ b/arch/arm/plat-orion/pcie.c
@@ -120,12 +120,14 @@ void __init orion_pcie_reset(void __iomem *base)
  * BAR[0,2] -> disabled, BAR[1] -> covers all DRAM banks
  * WIN[0-3] -> DRAM bank[0-3]
  */
-static void __init orion_pcie_setup_wins(void __iomem *base,
-					 struct mbus_dram_target_info *dram)
+static void __init orion_pcie_setup_wins(void __iomem *base)
 {
+	const struct mbus_dram_target_info *dram;
 	u32 size;
 	int i;
 
+	dram = mv_mbus_dram_info();
+
 	/*
 	 * First, disable and clear BARs and windows.
 	 */
@@ -150,7 +152,7 @@ static void __init orion_pcie_setup_wins(void __iomem *base,
 	 */
 	size = 0;
 	for (i = 0; i < dram->num_cs; i++) {
-		struct mbus_dram_window *cs = dram->cs + i;
+		const struct mbus_dram_window *cs = dram->cs + i;
 
 		writel(cs->base & 0xffff0000, base + PCIE_WIN04_BASE_OFF(i));
 		writel(0, base + PCIE_WIN04_REMAP_OFF(i));
@@ -184,7 +186,7 @@ void __init orion_pcie_setup(void __iomem *base)
 	/*
 	 * Point PCIe unit MBUS decode windows to DRAM space.
 	 */
-	orion_pcie_setup_wins(base, &orion_mbus_dram_info);
+	orion_pcie_setup_wins(base);
 
 	/*
 	 * Master + slave enable.

commit 98d9986cb8bf65f8316b45244fdafc1d12c303be
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Apr 11 21:07:45 2012 +0200

    ARM: Kirkwood: Replace clock gating
    
    Add a varient of the basic clk-gate code. This variant calls a
    function before gating the clock off. This function is used to disable
    the SATA or PCIe PHY.
    
    Now that all the drivers prepare and enable there clk as needed, there
    is no need for the common code to keep track of which clocks need
    gating on. Let the common clock framework turn off clocks which are
    not used.
    
    Buy using the added clk varient, when the clk framework turns off SATA
    or PCIe clocks, we also disabled SATA and PCIe PHYs which were not
    needed.
    
    The function kirkwood_pcie_id() can now be called outside of __init
    code, so remove this property for it, and functions it calls.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Tested-by: Jamie Lentin <jm@lentin.co.uk>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/arch/arm/plat-orion/pcie.c b/arch/arm/plat-orion/pcie.c
index 86dbb5bdb172..f20a321088a2 100644
--- a/arch/arm/plat-orion/pcie.c
+++ b/arch/arm/plat-orion/pcie.c
@@ -52,12 +52,12 @@
 #define  PCIE_DEBUG_SOFT_RESET		(1<<20)
 
 
-u32 __init orion_pcie_dev_id(void __iomem *base)
+u32 orion_pcie_dev_id(void __iomem *base)
 {
 	return readl(base + PCIE_DEV_ID_OFF) >> 16;
 }
 
-u32 __init orion_pcie_rev(void __iomem *base)
+u32 orion_pcie_rev(void __iomem *base)
 {
 	return readl(base + PCIE_DEV_REV_OFF) & 0xff;
 }

commit 63a9332b232bdab0df6ef18a9f39e8d58a82bda4
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Dec 7 21:48:07 2011 +0100

    ARM: Orion: Get address map from plat-orion instead of via platform_data
    
    Use an getter function in plat-orion/addr-map.c to get the address map
    structure, rather than pass it to drivers in the platform_data
    structures. When the drivers are built for none orion platforms, a
    dummy function is provided instead which returns NULL.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Tested-by: Michael Walle <michael@walle.cc>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/plat-orion/pcie.c b/arch/arm/plat-orion/pcie.c
index af2d733c50b5..86dbb5bdb172 100644
--- a/arch/arm/plat-orion/pcie.c
+++ b/arch/arm/plat-orion/pcie.c
@@ -13,6 +13,7 @@
 #include <linux/mbus.h>
 #include <asm/mach/pci.h>
 #include <plat/pcie.h>
+#include <plat/addr-map.h>
 #include <linux/delay.h>
 
 /*
@@ -175,8 +176,7 @@ static void __init orion_pcie_setup_wins(void __iomem *base,
 	writel(((size - 1) & 0xffff0000) | 1, base + PCIE_BAR_CTRL_OFF(1));
 }
 
-void __init orion_pcie_setup(void __iomem *base,
-			     struct mbus_dram_target_info *dram)
+void __init orion_pcie_setup(void __iomem *base)
 {
 	u16 cmd;
 	u32 mask;
@@ -184,7 +184,7 @@ void __init orion_pcie_setup(void __iomem *base,
 	/*
 	 * Point PCIe unit MBUS decode windows to DRAM space.
 	 */
-	orion_pcie_setup_wins(base, dram);
+	orion_pcie_setup_wins(base, &orion_mbus_dram_info);
 
 	/*
 	 * Master + slave enable.

commit 3924996bab2845bdf9a9d16ff7c20445de1ab55d
Author: Nicolas Pitre <nico@fluxnic.net>
Date:   Thu Oct 21 15:48:33 2010 -0400

    [ARM] Kirkwood: restrict the scope of the PCIe reset workaround
    
    Commit 21f0ba90a447 "orion/kirkwood: reset PCIe unit on boot" made the
    reset of the PCIe unit unconditional.  While this may fix problems on some
    targets, this also causes problems on other targets.
    
    Saeed Bishara <saeed@marvell.com> said about the original problem: "We
    couln't pinpoint the root cause of this issue, actually we failed to
    reproduce that issue."
    
    So let's restrict the reset of the PCIe unit only to the target where
    the original problem was observed.
    
    Signed-off-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/plat-orion/pcie.c b/arch/arm/plat-orion/pcie.c
index 779553a1595e..af2d733c50b5 100644
--- a/arch/arm/plat-orion/pcie.c
+++ b/arch/arm/plat-orion/pcie.c
@@ -181,11 +181,6 @@ void __init orion_pcie_setup(void __iomem *base,
 	u16 cmd;
 	u32 mask;
 
-	/*
-	 * soft reset PCIe unit
-	 */
-	orion_pcie_reset(base);
-
 	/*
 	 * Point PCIe unit MBUS decode windows to DRAM space.
 	 */

commit 21f0ba90a447090153edeaf2f14f9f7e8bd9bc80
Author: Olaf Rempel <razzor@kopf-tisch.de>
Date:   Tue Jun 8 22:32:38 2010 +0200

    [ARM] orion/kirkwood: reset PCIe unit on boot
    
    Patch found in QNAPs vendor source package, with some cleanups
    (proper defines, shortened max. timeout from 1s to 200ms).
    
    Without this patch the PCIe SATA controller (Marvell 88sx7042/sata_mv)
    in my QNAP TS-419P (Marvell 88f6281/Kirkwood) stops working after a
    few minutes.
    
    The symptomes are described in this thread:
    http://marc.info/?l=linux-ide&m=124822863706181&w=2
    
    [ Note: this is a workaround in need of a better analysis/solution -- NP ]
    
    Acked-by: Saeed Bishara <saeed@marvell.com>
    Tested-by: Bernhard R. Link <brl@pcpool00.mathematik.uni-freiburg.de>
    Seconded-by: Martin Michlmayr <tbm@cyrius.com>
    I'm_not_very_happy_with_it-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Signed-off-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/plat-orion/pcie.c b/arch/arm/plat-orion/pcie.c
index 54c84a492a0f..779553a1595e 100644
--- a/arch/arm/plat-orion/pcie.c
+++ b/arch/arm/plat-orion/pcie.c
@@ -13,6 +13,7 @@
 #include <linux/mbus.h>
 #include <asm/mach/pci.h>
 #include <plat/pcie.h>
+#include <linux/delay.h>
 
 /*
  * PCIe unit register offsets.
@@ -46,6 +47,8 @@
 #define  PCIE_STAT_BUS_OFFS		8
 #define  PCIE_STAT_BUS_MASK		0xff
 #define  PCIE_STAT_LINK_DOWN		1
+#define PCIE_DEBUG_CTRL         0x1a60
+#define  PCIE_DEBUG_SOFT_RESET		(1<<20)
 
 
 u32 __init orion_pcie_dev_id(void __iomem *base)
@@ -85,6 +88,32 @@ void __init orion_pcie_set_local_bus_nr(void __iomem *base, int nr)
 	writel(stat, base + PCIE_STAT_OFF);
 }
 
+void __init orion_pcie_reset(void __iomem *base)
+{
+	u32 reg;
+	int i;
+
+	/*
+	 * MV-S104860-U0, Rev. C:
+	 * PCI Express Unit Soft Reset
+	 * When set, generates an internal reset in the PCI Express unit.
+	 * This bit should be cleared after the link is re-established.
+	 */
+	reg = readl(base + PCIE_DEBUG_CTRL);
+	reg |= PCIE_DEBUG_SOFT_RESET;
+	writel(reg, base + PCIE_DEBUG_CTRL);
+
+	for (i = 0; i < 20; i++) {
+		mdelay(10);
+
+		if (orion_pcie_link_up(base))
+			break;
+	}
+
+	reg &= ~(PCIE_DEBUG_SOFT_RESET);
+	writel(reg, base + PCIE_DEBUG_CTRL);
+}
+
 /*
  * Setup PCIE BARs and Address Decode Wins:
  * BAR[0,2] -> disabled, BAR[1] -> covers all DRAM banks
@@ -152,6 +181,11 @@ void __init orion_pcie_setup(void __iomem *base,
 	u16 cmd;
 	u32 mask;
 
+	/*
+	 * soft reset PCIe unit
+	 */
+	orion_pcie_reset(base);
+
 	/*
 	 * Point PCIe unit MBUS decode windows to DRAM space.
 	 */

commit 7788cd5557766d49343088b2edc544b186e2fe53
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Wed Dec 23 16:19:56 2009 +0100

    [ARM] Orion: fix PCIe inbound window programming when RAM size is not a power of two
    
    The PCIe inbound window size is supposed to be a power of two.  If
    the total amount of RAM installed in the system is not a power of two,
    round it up such that it is.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Signed-off-by: Nicolas Pitre <nico@marvell.com>

diff --git a/arch/arm/plat-orion/pcie.c b/arch/arm/plat-orion/pcie.c
index d41d41d78ad9..54c84a492a0f 100644
--- a/arch/arm/plat-orion/pcie.c
+++ b/arch/arm/plat-orion/pcie.c
@@ -132,6 +132,12 @@ static void __init orion_pcie_setup_wins(void __iomem *base,
 		size += cs->size;
 	}
 
+	/*
+	 * Round up 'size' to the nearest power of two.
+	 */
+	if ((size & (size - 1)) != 0)
+		size = 1 << fls(size);
+
 	/*
 	 * Setup BAR[1] to all DRAM banks.
 	 */

commit 82676d76252680fc035247fd4cfdb07ffce5db52
Author: Saeed Bishara <saeed@marvell.com>
Date:   Thu Nov 27 06:21:03 2008 -1100

    [ARM] Orion: fix bug in pcie configuration cycle function field mask
    
    The function field is 3 bits.
    
    Signed-off-by: Saeed Bishara <saeed@marvell.com>
    Signed-off-by: Nicolas Pitre <nico@marvell.com>

diff --git a/arch/arm/plat-orion/pcie.c b/arch/arm/plat-orion/pcie.c
index 883902fead89..d41d41d78ad9 100644
--- a/arch/arm/plat-orion/pcie.c
+++ b/arch/arm/plat-orion/pcie.c
@@ -35,7 +35,7 @@
 #define  PCIE_CONF_REG(r)		((((r) & 0xf00) << 16) | ((r) & 0xfc))
 #define  PCIE_CONF_BUS(b)		(((b) & 0xff) << 16)
 #define  PCIE_CONF_DEV(d)		(((d) & 0x1f) << 11)
-#define  PCIE_CONF_FUNC(f)		(((f) & 0x3) << 8)
+#define  PCIE_CONF_FUNC(f)		(((f) & 0x7) << 8)
 #define PCIE_CONF_DATA_OFF	0x18fc
 #define PCIE_MASK_OFF		0x1910
 #define PCIE_CTRL_OFF		0x1a00

commit 6f088f1d215be5250582b974f83f0e3aa6ad3a28
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Sat Aug 9 13:44:58 2008 +0200

    [ARM] Move include/asm-arm/plat-orion to arch/arm/plat-orion/include/plat
    
    This patch performs the equivalent include directory shuffle for
    plat-orion, and fixes up all users.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>

diff --git a/arch/arm/plat-orion/pcie.c b/arch/arm/plat-orion/pcie.c
index ca32c60e14d7..883902fead89 100644
--- a/arch/arm/plat-orion/pcie.c
+++ b/arch/arm/plat-orion/pcie.c
@@ -12,7 +12,7 @@
 #include <linux/pci.h>
 #include <linux/mbus.h>
 #include <asm/mach/pci.h>
-#include <asm/plat-orion/pcie.h>
+#include <plat/pcie.h>
 
 /*
  * PCIe unit register offsets.

commit a9311cfed241ebcd6b5f9be5c8c6d519bf22f9e7
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Sun Jun 22 22:45:09 2008 +0200

    [ARM] Orion: PCIe x4/x1 detection support
    
    The Discovery Duo (MV78xx0) has two x4 PCIe ports which can either
    be used in x4 mode or in quad x1 mode.  This patch adds an accessor
    function to the generic plat-orion PCIe handling code to detect in
    which of the two modes we're running (which is determined by strap
    pins and/or configured by the bootloader).
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>

diff --git a/arch/arm/plat-orion/pcie.c b/arch/arm/plat-orion/pcie.c
index abfda53f1800..ca32c60e14d7 100644
--- a/arch/arm/plat-orion/pcie.c
+++ b/arch/arm/plat-orion/pcie.c
@@ -39,6 +39,7 @@
 #define PCIE_CONF_DATA_OFF	0x18fc
 #define PCIE_MASK_OFF		0x1910
 #define PCIE_CTRL_OFF		0x1a00
+#define  PCIE_CTRL_X1_MODE		0x0001
 #define PCIE_STAT_OFF		0x1a04
 #define  PCIE_STAT_DEV_OFFS		20
 #define  PCIE_STAT_DEV_MASK		0x1f
@@ -62,6 +63,11 @@ int orion_pcie_link_up(void __iomem *base)
 	return !(readl(base + PCIE_STAT_OFF) & PCIE_STAT_LINK_DOWN);
 }
 
+int __init orion_pcie_x4_mode(void __iomem *base)
+{
+	return !(readl(base + PCIE_CTRL_OFF) & PCIE_CTRL_X1_MODE);
+}
+
 int orion_pcie_get_local_bus_nr(void __iomem *base)
 {
 	u32 stat = readl(base + PCIE_STAT_OFF);

commit b488a5ed12c0d8417884d8c33fc0a1701a16c951
Author: Nicolas Pitre <nico@cam.org>
Date:   Wed Apr 9 21:08:35 2008 +0100

    [ARM] 4954/1: Orion: fix some function section mismatch
    
    Without this, lspci won't work.
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/plat-orion/pcie.c b/arch/arm/plat-orion/pcie.c
index f01966a330ee..abfda53f1800 100644
--- a/arch/arm/plat-orion/pcie.c
+++ b/arch/arm/plat-orion/pcie.c
@@ -57,12 +57,12 @@ u32 __init orion_pcie_rev(void __iomem *base)
 	return readl(base + PCIE_DEV_REV_OFF) & 0xff;
 }
 
-int __init orion_pcie_link_up(void __iomem *base)
+int orion_pcie_link_up(void __iomem *base)
 {
 	return !(readl(base + PCIE_STAT_OFF) & PCIE_STAT_LINK_DOWN);
 }
 
-int __init orion_pcie_get_local_bus_nr(void __iomem *base)
+int orion_pcie_get_local_bus_nr(void __iomem *base)
 {
 	u32 stat = readl(base + PCIE_STAT_OFF);
 

commit abc0197d7a74e51a1581ce9971d7c2c0f2adadaf
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Thu Mar 27 14:51:40 2008 -0400

    plat-orion: share PCIe handling code
    
    Split off Orion PCIe handling code into plat-orion/.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Reviewed-by: Tzachi Perelstein <tzachi@marvell.com>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Nicolas Pitre <nico@marvell.com>

diff --git a/arch/arm/plat-orion/pcie.c b/arch/arm/plat-orion/pcie.c
new file mode 100644
index 000000000000..f01966a330ee
--- /dev/null
+++ b/arch/arm/plat-orion/pcie.c
@@ -0,0 +1,245 @@
+/*
+ * arch/arm/plat-orion/pcie.c
+ *
+ * Marvell Orion SoC PCIe handling.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/mbus.h>
+#include <asm/mach/pci.h>
+#include <asm/plat-orion/pcie.h>
+
+/*
+ * PCIe unit register offsets.
+ */
+#define PCIE_DEV_ID_OFF		0x0000
+#define PCIE_CMD_OFF		0x0004
+#define PCIE_DEV_REV_OFF	0x0008
+#define PCIE_BAR_LO_OFF(n)	(0x0010 + ((n) << 3))
+#define PCIE_BAR_HI_OFF(n)	(0x0014 + ((n) << 3))
+#define PCIE_HEADER_LOG_4_OFF	0x0128
+#define PCIE_BAR_CTRL_OFF(n)	(0x1804 + ((n - 1) * 4))
+#define PCIE_WIN04_CTRL_OFF(n)	(0x1820 + ((n) << 4))
+#define PCIE_WIN04_BASE_OFF(n)	(0x1824 + ((n) << 4))
+#define PCIE_WIN04_REMAP_OFF(n)	(0x182c + ((n) << 4))
+#define PCIE_WIN5_CTRL_OFF	0x1880
+#define PCIE_WIN5_BASE_OFF	0x1884
+#define PCIE_WIN5_REMAP_OFF	0x188c
+#define PCIE_CONF_ADDR_OFF	0x18f8
+#define  PCIE_CONF_ADDR_EN		0x80000000
+#define  PCIE_CONF_REG(r)		((((r) & 0xf00) << 16) | ((r) & 0xfc))
+#define  PCIE_CONF_BUS(b)		(((b) & 0xff) << 16)
+#define  PCIE_CONF_DEV(d)		(((d) & 0x1f) << 11)
+#define  PCIE_CONF_FUNC(f)		(((f) & 0x3) << 8)
+#define PCIE_CONF_DATA_OFF	0x18fc
+#define PCIE_MASK_OFF		0x1910
+#define PCIE_CTRL_OFF		0x1a00
+#define PCIE_STAT_OFF		0x1a04
+#define  PCIE_STAT_DEV_OFFS		20
+#define  PCIE_STAT_DEV_MASK		0x1f
+#define  PCIE_STAT_BUS_OFFS		8
+#define  PCIE_STAT_BUS_MASK		0xff
+#define  PCIE_STAT_LINK_DOWN		1
+
+
+u32 __init orion_pcie_dev_id(void __iomem *base)
+{
+	return readl(base + PCIE_DEV_ID_OFF) >> 16;
+}
+
+u32 __init orion_pcie_rev(void __iomem *base)
+{
+	return readl(base + PCIE_DEV_REV_OFF) & 0xff;
+}
+
+int __init orion_pcie_link_up(void __iomem *base)
+{
+	return !(readl(base + PCIE_STAT_OFF) & PCIE_STAT_LINK_DOWN);
+}
+
+int __init orion_pcie_get_local_bus_nr(void __iomem *base)
+{
+	u32 stat = readl(base + PCIE_STAT_OFF);
+
+	return (stat >> PCIE_STAT_BUS_OFFS) & PCIE_STAT_BUS_MASK;
+}
+
+void __init orion_pcie_set_local_bus_nr(void __iomem *base, int nr)
+{
+	u32 stat;
+
+	stat = readl(base + PCIE_STAT_OFF);
+	stat &= ~(PCIE_STAT_BUS_MASK << PCIE_STAT_BUS_OFFS);
+	stat |= nr << PCIE_STAT_BUS_OFFS;
+	writel(stat, base + PCIE_STAT_OFF);
+}
+
+/*
+ * Setup PCIE BARs and Address Decode Wins:
+ * BAR[0,2] -> disabled, BAR[1] -> covers all DRAM banks
+ * WIN[0-3] -> DRAM bank[0-3]
+ */
+static void __init orion_pcie_setup_wins(void __iomem *base,
+					 struct mbus_dram_target_info *dram)
+{
+	u32 size;
+	int i;
+
+	/*
+	 * First, disable and clear BARs and windows.
+	 */
+	for (i = 1; i <= 2; i++) {
+		writel(0, base + PCIE_BAR_CTRL_OFF(i));
+		writel(0, base + PCIE_BAR_LO_OFF(i));
+		writel(0, base + PCIE_BAR_HI_OFF(i));
+	}
+
+	for (i = 0; i < 5; i++) {
+		writel(0, base + PCIE_WIN04_CTRL_OFF(i));
+		writel(0, base + PCIE_WIN04_BASE_OFF(i));
+		writel(0, base + PCIE_WIN04_REMAP_OFF(i));
+	}
+
+	writel(0, base + PCIE_WIN5_CTRL_OFF);
+	writel(0, base + PCIE_WIN5_BASE_OFF);
+	writel(0, base + PCIE_WIN5_REMAP_OFF);
+
+	/*
+	 * Setup windows for DDR banks.  Count total DDR size on the fly.
+	 */
+	size = 0;
+	for (i = 0; i < dram->num_cs; i++) {
+		struct mbus_dram_window *cs = dram->cs + i;
+
+		writel(cs->base & 0xffff0000, base + PCIE_WIN04_BASE_OFF(i));
+		writel(0, base + PCIE_WIN04_REMAP_OFF(i));
+		writel(((cs->size - 1) & 0xffff0000) |
+			(cs->mbus_attr << 8) |
+			(dram->mbus_dram_target_id << 4) | 1,
+				base + PCIE_WIN04_CTRL_OFF(i));
+
+		size += cs->size;
+	}
+
+	/*
+	 * Setup BAR[1] to all DRAM banks.
+	 */
+	writel(dram->cs[0].base, base + PCIE_BAR_LO_OFF(1));
+	writel(0, base + PCIE_BAR_HI_OFF(1));
+	writel(((size - 1) & 0xffff0000) | 1, base + PCIE_BAR_CTRL_OFF(1));
+}
+
+void __init orion_pcie_setup(void __iomem *base,
+			     struct mbus_dram_target_info *dram)
+{
+	u16 cmd;
+	u32 mask;
+
+	/*
+	 * Point PCIe unit MBUS decode windows to DRAM space.
+	 */
+	orion_pcie_setup_wins(base, dram);
+
+	/*
+	 * Master + slave enable.
+	 */
+	cmd = readw(base + PCIE_CMD_OFF);
+	cmd |= PCI_COMMAND_IO;
+	cmd |= PCI_COMMAND_MEMORY;
+	cmd |= PCI_COMMAND_MASTER;
+	writew(cmd, base + PCIE_CMD_OFF);
+
+	/*
+	 * Enable interrupt lines A-D.
+	 */
+	mask = readl(base + PCIE_MASK_OFF);
+	mask |= 0x0f000000;
+	writel(mask, base + PCIE_MASK_OFF);
+}
+
+int orion_pcie_rd_conf(void __iomem *base, struct pci_bus *bus,
+		       u32 devfn, int where, int size, u32 *val)
+{
+	writel(PCIE_CONF_BUS(bus->number) |
+		PCIE_CONF_DEV(PCI_SLOT(devfn)) |
+		PCIE_CONF_FUNC(PCI_FUNC(devfn)) |
+		PCIE_CONF_REG(where) | PCIE_CONF_ADDR_EN,
+			base + PCIE_CONF_ADDR_OFF);
+
+	*val = readl(base + PCIE_CONF_DATA_OFF);
+
+	if (size == 1)
+		*val = (*val >> (8 * (where & 3))) & 0xff;
+	else if (size == 2)
+		*val = (*val >> (8 * (where & 3))) & 0xffff;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+int orion_pcie_rd_conf_tlp(void __iomem *base, struct pci_bus *bus,
+			   u32 devfn, int where, int size, u32 *val)
+{
+	writel(PCIE_CONF_BUS(bus->number) |
+		PCIE_CONF_DEV(PCI_SLOT(devfn)) |
+		PCIE_CONF_FUNC(PCI_FUNC(devfn)) |
+		PCIE_CONF_REG(where) | PCIE_CONF_ADDR_EN,
+			base + PCIE_CONF_ADDR_OFF);
+
+	*val = readl(base + PCIE_CONF_DATA_OFF);
+
+	if (bus->number != orion_pcie_get_local_bus_nr(base) ||
+	    PCI_FUNC(devfn) != 0)
+		*val = readl(base + PCIE_HEADER_LOG_4_OFF);
+
+	if (size == 1)
+		*val = (*val >> (8 * (where & 3))) & 0xff;
+	else if (size == 2)
+		*val = (*val >> (8 * (where & 3))) & 0xffff;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+int orion_pcie_rd_conf_wa(void __iomem *wa_base, struct pci_bus *bus,
+			  u32 devfn, int where, int size, u32 *val)
+{
+	*val = readl(wa_base + (PCIE_CONF_BUS(bus->number) |
+				PCIE_CONF_DEV(PCI_SLOT(devfn)) |
+				PCIE_CONF_FUNC(PCI_FUNC(devfn)) |
+				PCIE_CONF_REG(where)));
+
+	if (size == 1)
+		*val = (*val >> (8 * (where & 3))) & 0xff;
+	else if (size == 2)
+		*val = (*val >> (8 * (where & 3))) & 0xffff;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+int orion_pcie_wr_conf(void __iomem *base, struct pci_bus *bus,
+		       u32 devfn, int where, int size, u32 val)
+{
+	int ret = PCIBIOS_SUCCESSFUL;
+
+	writel(PCIE_CONF_BUS(bus->number) |
+		PCIE_CONF_DEV(PCI_SLOT(devfn)) |
+		PCIE_CONF_FUNC(PCI_FUNC(devfn)) |
+		PCIE_CONF_REG(where) | PCIE_CONF_ADDR_EN,
+			base + PCIE_CONF_ADDR_OFF);
+
+	if (size == 4) {
+		writel(val, base + PCIE_CONF_DATA_OFF);
+	} else if (size == 2) {
+		writew(val, base + PCIE_CONF_DATA_OFF + (where & 3));
+	} else if (size == 1) {
+		writeb(val, base + PCIE_CONF_DATA_OFF + (where & 3));
+	} else {
+		ret = PCIBIOS_BAD_REGISTER_NUMBER;
+	}
+
+	return ret;
+}
