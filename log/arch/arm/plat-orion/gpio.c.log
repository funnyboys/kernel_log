commit d6ea689345ecc27b636a8bb62bf07080f21f110c
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sun Oct 16 12:30:48 2016 +0200

    ARM/orion/gpio: Replace three seq_printf() calls by seq_puts() in orion_gpio_dbg_show()
    
    Strings which did not contain data format specifications should be put
    into a sequence. Thus use the corresponding function "seq_puts".
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index f74069386c13..26a531ebb6e9 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -478,13 +478,13 @@ static void orion_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)
 			   (data_in ^ in_pol) & msk  ? "hi" : "lo",
 			   in_pol & msk ? "lo" : "hi");
 		if (!((edg_msk | lvl_msk) & msk)) {
-			seq_printf(s, " disabled\n");
+			seq_puts(s, " disabled\n");
 			continue;
 		}
 		if (edg_msk & msk)
-			seq_printf(s, " edge ");
+			seq_puts(s, " edge ");
 		if (lvl_msk & msk)
-			seq_printf(s, " level");
+			seq_puts(s, " level");
 		seq_printf(s, " (%s)\n", cause & msk ? "pending" : "clear  ");
 	}
 }

commit 66d718ddaf1209b9449fc8a6244d06e7057e7bb7
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Dec 8 13:28:31 2015 +0100

    ARM: plat-orion: use gpiochip data pointer
    
    This makes the driver use the data pointer added to the gpio_chip
    to store a pointer to the state container instead of relying on
    container_of().
    
    Cc: arm@kernel.org
    Acked-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index 7bd22d8e5b11..f74069386c13 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -154,8 +154,7 @@ orion_gpio_is_valid(struct orion_gpio_chip *ochip, unsigned pin, int mode)
  */
 static int orion_gpio_request(struct gpio_chip *chip, unsigned pin)
 {
-	struct orion_gpio_chip *ochip =
-		container_of(chip, struct orion_gpio_chip, chip);
+	struct orion_gpio_chip *ochip = gpiochip_get_data(chip);
 
 	if (orion_gpio_is_valid(ochip, pin, GPIO_INPUT_OK) ||
 	    orion_gpio_is_valid(ochip, pin, GPIO_OUTPUT_OK))
@@ -166,8 +165,7 @@ static int orion_gpio_request(struct gpio_chip *chip, unsigned pin)
 
 static int orion_gpio_direction_input(struct gpio_chip *chip, unsigned pin)
 {
-	struct orion_gpio_chip *ochip =
-		container_of(chip, struct orion_gpio_chip, chip);
+	struct orion_gpio_chip *ochip = gpiochip_get_data(chip);
 	unsigned long flags;
 
 	if (!orion_gpio_is_valid(ochip, pin, GPIO_INPUT_OK))
@@ -182,8 +180,7 @@ static int orion_gpio_direction_input(struct gpio_chip *chip, unsigned pin)
 
 static int orion_gpio_get(struct gpio_chip *chip, unsigned pin)
 {
-	struct orion_gpio_chip *ochip =
-		container_of(chip, struct orion_gpio_chip, chip);
+	struct orion_gpio_chip *ochip = gpiochip_get_data(chip);
 	int val;
 
 	if (readl(GPIO_IO_CONF(ochip)) & (1 << pin)) {
@@ -198,8 +195,7 @@ static int orion_gpio_get(struct gpio_chip *chip, unsigned pin)
 static int
 orion_gpio_direction_output(struct gpio_chip *chip, unsigned pin, int value)
 {
-	struct orion_gpio_chip *ochip =
-		container_of(chip, struct orion_gpio_chip, chip);
+	struct orion_gpio_chip *ochip = gpiochip_get_data(chip);
 	unsigned long flags;
 
 	if (!orion_gpio_is_valid(ochip, pin, GPIO_OUTPUT_OK))
@@ -216,8 +212,7 @@ orion_gpio_direction_output(struct gpio_chip *chip, unsigned pin, int value)
 
 static void orion_gpio_set(struct gpio_chip *chip, unsigned pin, int value)
 {
-	struct orion_gpio_chip *ochip =
-		container_of(chip, struct orion_gpio_chip, chip);
+	struct orion_gpio_chip *ochip = gpiochip_get_data(chip);
 	unsigned long flags;
 
 	spin_lock_irqsave(&ochip->lock, flags);
@@ -227,8 +222,7 @@ static void orion_gpio_set(struct gpio_chip *chip, unsigned pin, int value)
 
 static int orion_gpio_to_irq(struct gpio_chip *chip, unsigned pin)
 {
-	struct orion_gpio_chip *ochip =
-		container_of(chip, struct orion_gpio_chip, chip);
+	struct orion_gpio_chip *ochip = gpiochip_get_data(chip);
 
 	return irq_create_mapping(ochip->domain,
 				  ochip->secondary_irq_base + pin);
@@ -445,8 +439,8 @@ static void gpio_irq_handler(struct irq_desc *desc)
 
 static void orion_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)
 {
-	struct orion_gpio_chip *ochip =
-		container_of(chip, struct orion_gpio_chip, chip);
+
+	struct orion_gpio_chip *ochip = gpiochip_get_data(chip);
 	u32 out, io_conf, blink, in_pol, data_in, cause, edg_msk, lvl_msk;
 	int i;
 
@@ -567,7 +561,7 @@ void __init orion_gpio_init(struct device_node *np,
 	ochip->mask_offset = mask_offset;
 	ochip->secondary_irq_base = secondary_irq_base;
 
-	gpiochip_add(&ochip->chip);
+	gpiochip_add_data(&ochip->chip, ochip);
 
 	/*
 	 * Mask and clear GPIO interrupts.

commit bd0b9ac405e1794d72533c3d487aa65b6b955a0c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 14 10:42:37 2015 +0200

    genirq: Remove irq argument from irq flow handlers
    
    Most interrupt flow handlers do not use the irq argument. Those few
    which use it can retrieve the irq number from the irq descriptor.
    
    Remove the argument.
    
    Search and replace was done with coccinelle and some extra helper
    scripts around it. Thanks to Julia for her help!
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index 79c33eca09a3..7bd22d8e5b11 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -407,7 +407,7 @@ static int gpio_irq_set_type(struct irq_data *d, u32 type)
 	return 0;
 }
 
-static void gpio_irq_handler(unsigned __irq, struct irq_desc *desc)
+static void gpio_irq_handler(struct irq_desc *desc)
 {
 	struct orion_gpio_chip *ochip = irq_desc_get_handler_data(desc);
 	u32 cause, type;

commit f4acd122a738d0601de3a96743859b9c7a82bd6a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 13 11:03:15 2015 +0200

    ARM/orion/gpio: Prepare gpio_irq_handler for irq argument removal
    
    The irq argument of most interrupt flow handlers is unused or merily
    used instead of a local variable. The handlers which need the irq
    argument can retrieve the irq number from the irq descriptor.
    
    In this case the irq argument is shadowed by a local variable already,
    so just rename it.
    
    Search and update was done with coccinelle and the invaluable help of
    Julia Lawall.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Russell King <linux+kernel@arm.linux.org.uk>
    Cc: linux-arm-kernel@lists.infradead.org

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index 62743f3ebef2..79c33eca09a3 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -407,7 +407,7 @@ static int gpio_irq_set_type(struct irq_data *d, u32 type)
 	return 0;
 }
 
-static void gpio_irq_handler(unsigned irq, struct irq_desc *desc)
+static void gpio_irq_handler(unsigned __irq, struct irq_desc *desc)
 {
 	struct orion_gpio_chip *ochip = irq_desc_get_handler_data(desc);
 	u32 cause, type;

commit f575398bff9ae08086b345ecf724568be53818ee
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Jun 4 12:13:19 2015 +0800

    ARM, irq: Use irq_desc_get_xxx() to avoid redundant lookup of irq_desc
    
    Use irq_desc_get_xxx() to avoid redundant lookup of irq_desc while we
    already have a pointer to corresponding irq_desc.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index 4a347dee75ff..62743f3ebef2 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -409,7 +409,7 @@ static int gpio_irq_set_type(struct irq_data *d, u32 type)
 
 static void gpio_irq_handler(unsigned irq, struct irq_desc *desc)
 {
-	struct orion_gpio_chip *ochip = irq_get_handler_data(irq);
+	struct orion_gpio_chip *ochip = irq_desc_get_handler_data(desc);
 	u32 cause, type;
 	int i;
 

commit 206287c2c8dd61b5316c0dab459208e82d68e48d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Jun 21 21:25:10 2015 +0200

    ARM/orion: Consolidate chained IRQ handler install/remove
    
    Chained irq handlers usually set up handler data as well. We now have
    a function to set both under irq_desc->lock. Replace the two calls
    with one.
    
    Search and conversion was done with coccinelle.
    
    Reported-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: linux-arm-kernel@lists.infradead.org

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index 5168a52a17f9..4a347dee75ff 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -582,8 +582,9 @@ void __init orion_gpio_init(struct device_node *np,
 
 	for (i = 0; i < 4; i++) {
 		if (irqs[i]) {
-			irq_set_handler_data(irqs[i], ochip);
-			irq_set_chained_handler(irqs[i], gpio_irq_handler);
+			irq_set_chained_handler_and_data(irqs[i],
+							 gpio_irq_handler,
+							 ochip);
 		}
 	}
 

commit 92a578b064d0227a3a7fbbdb9e29dbab7f8d400e
Merge: c75059c46293 e3d857e1ae78
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 10 21:17:00 2014 -0800

    Merge tag 'pm+acpi-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael Wysocki:
     "This time we have some more new material than we used to have during
      the last couple of development cycles.
    
      The most important part of it to me is the introduction of a unified
      interface for accessing device properties provided by platform
      firmware.  It works with Device Trees and ACPI in a uniform way and
      drivers using it need not worry about where the properties come from
      as long as the platform firmware (either DT or ACPI) makes them
      available.  It covers both devices and "bare" device node objects
      without struct device representation as that turns out to be necessary
      in some cases.  This has been in the works for quite a few months (and
      development cycles) and has been approved by all of the relevant
      maintainers.
    
      On top of that, some drivers are switched over to the new interface
      (at25, leds-gpio, gpio_keys_polled) and some additional changes are
      made to the core GPIO subsystem to allow device drivers to manipulate
      GPIOs in the "canonical" way on platforms that provide GPIO
      information in their ACPI tables, but don't assign names to GPIO lines
      (in which case the driver needs to do that on the basis of what it
      knows about the device in question).  That also has been approved by
      the GPIO core maintainers and the rfkill driver is now going to use
      it.
    
      Second is support for hardware P-states in the intel_pstate driver.
      It uses CPUID to detect whether or not the feature is supported by the
      processor in which case it will be enabled by default.  However, it
      can be disabled entirely from the kernel command line if necessary.
    
      Next is support for a platform firmware interface based on ACPI
      operation regions used by the PMIC (Power Management Integrated
      Circuit) chips on the Intel Baytrail-T and Baytrail-T-CR platforms.
      That interface is used for manipulating power resources and for
      thermal management: sensor temperature reporting, trip point setting
      and so on.
    
      Also the ACPI core is now going to support the _DEP configuration
      information in a limited way.  Basically, _DEP it supposed to reflect
      off-the-hierarchy dependencies between devices which may be very
      indirect, like when AML for one device accesses locations in an
      operation region handled by another device's driver (usually, the
      device depended on this way is a serial bus or GPIO controller).  The
      support added this time is sufficient to make the ACPI battery driver
      work on Asus T100A, but it is general enough to be able to cover some
      other use cases in the future.
    
      Finally, we have a new cpufreq driver for the Loongson1B processor.
    
      In addition to the above, there are fixes and cleanups all over the
      place as usual and a traditional ACPICA update to a recent upstream
      release.
    
      As far as the fixes go, the ACPI LPSS (Low-power Subsystem) driver for
      Intel platforms should be able to handle power management of the DMA
      engine correctly, the cpufreq-dt driver should interact with the
      thermal subsystem in a better way and the ACPI backlight driver should
      handle some more corner cases, among other things.
    
      On top of the ACPICA update there are fixes for race conditions in the
      ACPICA's interrupt handling code which might lead to some random and
      strange looking failures on some systems.
    
      In the cleanups department the most visible part is the series of
      commits targeted at getting rid of the CONFIG_PM_RUNTIME configuration
      option.  That was triggered by a discussion regarding the generic
      power domains code during which we realized that trying to support
      certain combinations of PM config options was painful and not really
      worth it, because nobody would use them in production anyway.  For
      this reason, we decided to make CONFIG_PM_SLEEP select
      CONFIG_PM_RUNTIME and that lead to the conclusion that the latter
      became redundant and CONFIG_PM could be used instead of it.  The
      material here makes that replacement in a major part of the tree, but
      there will be at least one more batch of that in the second part of
      the merge window.
    
      Specifics:
    
       - Support for retrieving device properties information from ACPI _DSD
         device configuration objects and a unified device properties
         interface for device drivers (and subsystems) on top of that.  As
         stated above, this works with Device Trees and ACPI and allows
         device drivers to be written in a platform firmware (DT or ACPI)
         agnostic way.  The at25, leds-gpio and gpio_keys_polled drivers are
         now going to use this new interface and the GPIO subsystem is
         additionally modified to allow device drivers to assign names to
         GPIO resources returned by ACPI _CRS objects (in case _DSD is not
         present or does not provide the expected data).  The changes in
         this set are mostly from Mika Westerberg, Rafael J Wysocki, Aaron
         Lu, and Darren Hart with some fixes from others (Fabio Estevam,
         Geert Uytterhoeven).
    
       - Support for Hardware Managed Performance States (HWP) as described
         in Volume 3, section 14.4, of the Intel SDM in the intel_pstate
         driver.  CPUID is used to detect whether or not the feature is
         supported by the processor.  If supported, it will be enabled
         automatically unless the intel_pstate=no_hwp switch is present in
         the kernel command line.  From Dirk Brandewie.
    
       - New Intel Broadwell-H ID for intel_pstate (Dirk Brandewie).
    
       - Support for firmware interface based on ACPI operation regions used
         by the PMIC chips on the Intel Baytrail-T and Baytrail-T-CR
         platforms for power resource control and thermal management (Aaron
         Lu).
    
       - Limited support for retrieving off-the-hierarchy dependencies
         between devices from ACPI _DEP device configuration objects and
         deferred probing support for the ACPI battery driver based on the
         _DEP information to make that driver work on Asus T100A (Lan
         Tianyu).
    
       - New cpufreq driver for the Loongson1B processor (Kelvin Cheung).
    
       - ACPICA update to upstream revision 20141107 which only affects
         tools (Bob Moore).
    
       - Fixes for race conditions in the ACPICA's interrupt handling code
         and in the ACPI code related to system suspend and resume (Lv Zheng
         and Rafael J Wysocki).
    
       - ACPI core fix for an RCU-related issue in the ioremap() regions
         management code that slowed down significantly after CPUs had been
         allowed to enter idle states even if they'd had RCU callbakcs
         queued and triggered some problems in certain proprietary graphics
         driver (and elsewhere).  The fix replaces synchronize_rcu() in that
         code with synchronize_rcu_expedited() which makes the issue go
         away.  From Konstantin Khlebnikov.
    
       - ACPI LPSS (Low-Power Subsystem) driver fix to handle power
         management of the DMA engine included into the LPSS correctly.  The
         problem is that the DMA engine doesn't have ACPI PM support of its
         own and it simply is turned off when the last LPSS device having
         ACPI PM support goes into D3cold.  To work around that, the PM
         domain used by the ACPI LPSS driver is redesigned so at least one
         device with ACPI PM support will be on as long as the DMA engine is
         in use.  From Andy Shevchenko.
    
       - ACPI backlight driver fix to avoid using it on "Win8-compatible"
         systems where it doesn't work and where it was used by default by
         mistake (Aaron Lu).
    
       - Assorted minor ACPI core fixes and cleanups from Tomasz Nowicki,
         Sudeep Holla, Huang Rui, Hanjun Guo, Fabian Frederick, and Ashwin
         Chaugule (mostly related to the upcoming ARM64 support).
    
       - Intel RAPL (Running Average Power Limit) power capping driver fixes
         and improvements including new processor IDs (Jacob Pan).
    
       - Generic power domains modification to power up domains after
         attaching devices to them to meet the expectations of device
         drivers and bus types assuming devices to be accessible at probe
         time (Ulf Hansson).
    
       - Preliminary support for controlling device clocks from the generic
         power domains core code and modifications of the ARM/shmobile
         platform to use that feature (Ulf Hansson).
    
       - Assorted minor fixes and cleanups of the generic power domains core
         code (Ulf Hansson, Geert Uytterhoeven).
    
       - Assorted minor fixes and cleanups of the device clocks control code
         in the PM core (Geert Uytterhoeven, Grygorii Strashko).
    
       - Consolidation of device power management Kconfig options by making
         CONFIG_PM_SLEEP select CONFIG_PM_RUNTIME and removing the latter
         which is now redundant (Rafael J Wysocki and Kevin Hilman).  That
         is the first batch of the changes needed for this purpose.
    
       - Core device runtime power management support code cleanup related
         to the execution of callbacks (Andrzej Hajda).
    
       - cpuidle ARM support improvements (Lorenzo Pieralisi).
    
       - cpuidle cleanup related to the CPUIDLE_FLAG_TIME_VALID flag and a
         new MAINTAINERS entry for ARM Exynos cpuidle (Daniel Lezcano and
         Bartlomiej Zolnierkiewicz).
    
       - New cpufreq driver callback (->ready) to be executed when the
         cpufreq core is ready to use a given policy object and cpufreq-dt
         driver modification to use that callback for cooling device
         registration (Viresh Kumar).
    
       - cpufreq core fixes and cleanups (Viresh Kumar, Vince Hsu, James
         Geboski, Tomeu Vizoso).
    
       - Assorted fixes and cleanups in the cpufreq-pcc, intel_pstate,
         cpufreq-dt, pxa2xx cpufreq drivers (Lenny Szubowicz, Ethan Zhao,
         Stefan Wahren, Petr Cvek).
    
       - OPP (Operating Performance Points) framework modification to allow
         OPPs to be removed too and update of a few cpufreq drivers
         (cpufreq-dt, exynos5440, imx6q, cpufreq) to remove OPPs (added
         during initialization) on driver removal (Viresh Kumar).
    
       - Hibernation core fixes and cleanups (Tina Ruchandani and Markus
         Elfring).
    
       - PM Kconfig fix related to CPU power management (Pankaj Dubey).
    
       - cpupower tool fix (Prarit Bhargava)"
    
    * tag 'pm+acpi-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (120 commits)
      i2c-omap / PM: Drop CONFIG_PM_RUNTIME from i2c-omap.c
      dmaengine / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      tools: cpupower: fix return checks for sysfs_get_idlestate_count()
      drivers: sh / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      e1000e / igb / PM: Eliminate CONFIG_PM_RUNTIME
      MMC / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      MFD / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      misc / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      media / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      input / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      leds: leds-gpio: Fix multiple instances registration without 'label' property
      iio / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      hsi / OMAP / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      i2c-hid / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      drm / exynos / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      gpio / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      hwrandom / exynos / PM: Use CONFIG_PM in #ifdef
      block / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      USB / PM: Drop CONFIG_PM_RUNTIME from the USB core
      PM: Merge the SET*_RUNTIME_PM_OPS() macros
      ...

commit d3eaf5875e36b37f1386a4e3e7562c5a6c35abd2
Merge: b2776bf7149b 29470ea8d828
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Dec 8 19:50:17 2014 +0100

    Merge branch 'device-properties'
    
    * device-properties:
      leds: leds-gpio: Fix multiple instances registration without 'label' property
      leds: leds-gpio: Fix legacy GPIO number case
      ACPI / property: Drop size_prop from acpi_dev_get_property_reference()
      leds: leds-gpio: Convert gpio_blink_set() to use GPIO descriptors
      ACPI / GPIO: Document ACPI GPIO mappings API
      net: rfkill: gpio: Add default GPIO driver mappings for ACPI
      ACPI / GPIO: Driver GPIO mappings for ACPI GPIOs
      input: gpio_keys_polled: Make use of device property API
      leds: leds-gpio: Make use of device property API
      gpio: Support for unified device properties interface
      Driver core: Unified interface for firmware node properties
      input: gpio_keys_polled: Add support for GPIO descriptors
      leds: leds-gpio: Add support for GPIO descriptors
      gpio: sch: Consolidate core and resume banks
      gpio / ACPI: Add support for _DSD device properties
      misc: at25: Make use of device property API
      ACPI: Allow drivers to match using Device Tree compatible property
      Driver core: Unified device properties interface for platform firmware
      ACPI: Add support for device specific properties

commit 2f90bce7ff1f760986d55d9cb3a834e8638b1295
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Tue Nov 25 16:19:12 2014 +0100

    ARM: orion: convert the irq_reg_{readl,writel} calls to the new API
    
    The commit "genirq: Generic chip: Change irq_reg_{readl,writel}
    arguments" modified the API. In the same tome the
    arch/arm/plat-orion/gpio.c file received a fix with the use of the old
    API: "ARM: orion: Fix for certain sequence of request_irq can cause
    irq storm". This commit fixes the use of the API.
    
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Acked-by: Olof Johansson <olof@lixom.net>
    Link: https://lkml.kernel.org/r/1416928752-24529-1-git-send-email-gregory.clement@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index e048f6198d68..14f6e647c739 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -505,9 +505,9 @@ static void orion_gpio_unmask_irq(struct irq_data *d)
 	u32 mask = d->mask;
 
 	irq_gc_lock(gc);
-	reg_val = irq_reg_readl(gc->reg_base + ct->regs.mask);
+	reg_val = irq_reg_readl(gc, ct->regs.mask);
 	reg_val |= mask;
-	irq_reg_writel(reg_val, gc->reg_base + ct->regs.mask);
+	irq_reg_writel(gc, reg_val, ct->regs.mask);
 	irq_gc_unlock(gc);
 }
 
@@ -519,9 +519,9 @@ static void orion_gpio_mask_irq(struct irq_data *d)
 	u32 reg_val;
 
 	irq_gc_lock(gc);
-	reg_val = irq_reg_readl(gc->reg_base + ct->regs.mask);
+	reg_val = irq_reg_readl(gc, ct->regs.mask);
 	reg_val &= ~mask;
-	irq_reg_writel(reg_val, gc->reg_base + ct->regs.mask);
+	irq_reg_writel(gc, reg_val, ct->regs.mask);
 	irq_gc_unlock(gc);
 }
 

commit c673a2b4008103525a3cf21bedf15ffac37bfef0
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Oct 31 13:40:58 2014 +0200

    leds: leds-gpio: Convert gpio_blink_set() to use GPIO descriptors
    
    Commit 21f2aae91e902aad ("leds: leds-gpio: Add support for GPIO
    descriptors") already converted most of the driver to use GPIO descriptors.
    What is still missing is the platform specific hook gpio_blink_set() and
    board files which pass legacy GPIO numbers to this driver in platform data.
    
    In this patch we handle the former and convert gpio_blink_set() to take
    GPIO descriptor instead. In order to do this we convert the existing four
    users to accept GPIO descriptor and translate it to legacy GPIO number in
    the platform code. This effectively "pushes" legacy GPIO number usage from
    the driver to platforms.
    
    Also add comment to the remaining block describing that it is legacy code
    path and we are getting rid of it eventually.
    
    Suggested-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index b61a3bcc2fa8..b357053f40d9 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -306,9 +306,10 @@ EXPORT_SYMBOL(orion_gpio_set_blink);
 
 #define ORION_BLINK_HALF_PERIOD 100 /* ms */
 
-int orion_gpio_led_blink_set(unsigned gpio, int state,
+int orion_gpio_led_blink_set(struct gpio_desc *desc, int state,
 	unsigned long *delay_on, unsigned long *delay_off)
 {
+	unsigned gpio = desc_to_gpio(desc);
 
 	if (delay_on && delay_off && !*delay_on && !*delay_off)
 		*delay_on = *delay_off = ORION_BLINK_HALF_PERIOD;

commit 9ece8839b1277fb9128ff6833411614ab6c88d68
Author: Evgeniy Dushistov <dushistov@mail.ru>
Date:   Sat Jul 26 19:56:59 2014 +0400

    ARM: orion: Fix for certain sequence of request_irq can cause irq storm
    
    The problem is that hardware handled by arm/plat-orion/gpio.c,
    require ack for edge irq, and no ack for level irq.
    
    The code handle this issue, by two "struct irq_chip_type" per
    one "struct irq_chip_generic". For one "struct irq_chip_generic"
    irq_ack pointer is setted, for another it is NULL.
    
    But we have only one mask_cache per two "struct irq_chip_type".
    So if we
    1)unmask interrupt A for "edge type" trigger,
    2)unmask interrupt B for "level type" trigger,
    3)unmask interrupt C for "edge type",
    
    we, because of usage of generic irq_gc_mask_clr_bit/irq_gc_mask_set_bit,
    have hardware configured to trigger interrupt B on "edge type",
    because of shared mask_cache. But kernel think that B is "level type",
    so when interrupt B occur via "edge" reason, we don't ack it,
    and B triggered again and again.
    
    Signed-off-by: Evgeniy A. Dushistov <dushistov@mail.ru>
    Link: https://lkml.kernel.org/r/20140726155659.GA22977@fifteen
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index b61a3bcc2fa8..e048f6198d68 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -497,6 +497,34 @@ static void orion_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)
 #define orion_gpio_dbg_show NULL
 #endif
 
+static void orion_gpio_unmask_irq(struct irq_data *d)
+{
+	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
+	struct irq_chip_type *ct = irq_data_get_chip_type(d);
+	u32 reg_val;
+	u32 mask = d->mask;
+
+	irq_gc_lock(gc);
+	reg_val = irq_reg_readl(gc->reg_base + ct->regs.mask);
+	reg_val |= mask;
+	irq_reg_writel(reg_val, gc->reg_base + ct->regs.mask);
+	irq_gc_unlock(gc);
+}
+
+static void orion_gpio_mask_irq(struct irq_data *d)
+{
+	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
+	struct irq_chip_type *ct = irq_data_get_chip_type(d);
+	u32 mask = d->mask;
+	u32 reg_val;
+
+	irq_gc_lock(gc);
+	reg_val = irq_reg_readl(gc->reg_base + ct->regs.mask);
+	reg_val &= ~mask;
+	irq_reg_writel(reg_val, gc->reg_base + ct->regs.mask);
+	irq_gc_unlock(gc);
+}
+
 void __init orion_gpio_init(struct device_node *np,
 			    int gpio_base, int ngpio,
 			    void __iomem *base, int mask_offset,
@@ -565,8 +593,8 @@ void __init orion_gpio_init(struct device_node *np,
 	ct = gc->chip_types;
 	ct->regs.mask = ochip->mask_offset + GPIO_LEVEL_MASK_OFF;
 	ct->type = IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW;
-	ct->chip.irq_mask = irq_gc_mask_clr_bit;
-	ct->chip.irq_unmask = irq_gc_mask_set_bit;
+	ct->chip.irq_mask = orion_gpio_mask_irq;
+	ct->chip.irq_unmask = orion_gpio_unmask_irq;
 	ct->chip.irq_set_type = gpio_irq_set_type;
 	ct->chip.name = ochip->chip.label;
 
@@ -575,8 +603,8 @@ void __init orion_gpio_init(struct device_node *np,
 	ct->regs.ack = GPIO_EDGE_CAUSE_OFF;
 	ct->type = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;
 	ct->chip.irq_ack = irq_gc_ack_clr_bit;
-	ct->chip.irq_mask = irq_gc_mask_clr_bit;
-	ct->chip.irq_unmask = irq_gc_mask_set_bit;
+	ct->chip.irq_mask = orion_gpio_mask_irq;
+	ct->chip.irq_unmask = orion_gpio_unmask_irq;
 	ct->chip.irq_set_type = gpio_irq_set_type;
 	ct->handler = handle_edge_irq;
 	ct->chip.name = ochip->chip.label;

commit 19e00f20e90e349cdeef3d7b63e6179215c9ff9d
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Tue Apr 22 23:26:42 2014 +0200

    ARM: orion: remove no longer needed gpio DT code
    
    Following the move to pure DT-based probing of the GPIO controllers on
    Orion5x, some code in plat-orion/orion-gpio.c can be removed as it is
    no longer used.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Link: https://lkml.kernel.org/r/1398202002-28530-39-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index 6816192a7561..b61a3bcc2fa8 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -597,51 +597,3 @@ void __init orion_gpio_init(struct device_node *np,
 
 	orion_gpio_chip_count++;
 }
-
-#ifdef CONFIG_OF
-static void __init orion_gpio_of_init_one(struct device_node *np,
-					  int irq_gpio_base)
-{
-	int ngpio, gpio_base, mask_offset;
-	void __iomem *base;
-	int ret, i;
-	int irqs[4];
-	int secondary_irq_base;
-
-	ret = of_property_read_u32(np, "ngpio", &ngpio);
-	if (ret)
-		goto out;
-	ret = of_property_read_u32(np, "mask-offset", &mask_offset);
-	if (ret == -EINVAL)
-		mask_offset = 0;
-	else
-		goto out;
-	base = of_iomap(np, 0);
-	if (!base)
-		goto out;
-
-	secondary_irq_base = irq_gpio_base + (32 * orion_gpio_chip_count);
-	gpio_base = 32 * orion_gpio_chip_count;
-
-	/* Get the interrupt numbers. Each chip can have up to 4
-	 * interrupt handlers, with each handler dealing with 8 GPIO
-	 * pins. */
-
-	for (i = 0; i < 4; i++)
-		irqs[i] = irq_of_parse_and_map(np, i);
-
-	orion_gpio_init(np, gpio_base, ngpio, base, mask_offset,
-			secondary_irq_base, irqs);
-	return;
-out:
-	pr_err("%s: %s: missing mandatory property\n", __func__, np->name);
-}
-
-void __init orion_gpio_of_init(int irq_gpio_base)
-{
-	struct device_node *np;
-
-	for_each_compatible_node(np, NULL, "marvell,orion-gpio")
-		orion_gpio_of_init_one(np, irq_gpio_base);
-}
-#endif

commit f88704c95b5a2634eff99e2d720031555c67fe81
Author: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
Date:   Fri Jun 14 18:40:47 2013 +0200

    arm: orion: Use irq_get_trigger_type() to get IRQ flags
    
    Use irq_get_trigger_type() to get the IRQ trigger type flags
    instead calling irqd_get_trigger_type(irq_get_irq_data(irq))
    
    Signed-off-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Samuel Ortiz <sameo@linux.intel.com>
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-mips@linux-mips.org
    Link: http://lkml.kernel.org/r/1371228049-27080-6-git-send-email-javier.martinez@collabora.co.uk
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index 249fe6333e18..6816192a7561 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -426,7 +426,7 @@ static void gpio_irq_handler(unsigned irq, struct irq_desc *desc)
 		if (!(cause & (1 << i)))
 			continue;
 
-		type = irqd_get_trigger_type(irq_get_irq_data(irq));
+		type = irq_get_trigger_type(irq);
 		if ((type & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {
 			/* Swap polarity (race with GPIO line) */
 			u32 polarity;

commit 5647ac0ad4f355817b788372a01cb293ed63bde4
Merge: 1763e735b0a0 f4c54050640e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 9 09:59:16 2013 -0700

    Merge tag 'gpio-for-linus' of git://git.secretlab.ca/git/linux
    
    Pull removal of GENERIC_GPIO from Grant Likely:
     "GENERIC_GPIO now synonymous with GPIOLIB.  There are no longer any
      valid cases for enableing GENERIC_GPIO without GPIOLIB, even though it
      is possible to do so which has been causing confusion and breakage.
      This branch does the work to completely eliminate GENERIC_GPIO."
    
    * tag 'gpio-for-linus' of git://git.secretlab.ca/git/linux:
      gpio: update gpio Chinese documentation
      Remove GENERIC_GPIO config option
      Convert selectors of GENERIC_GPIO to GPIOLIB
      blackfin: force use of gpiolib
      m68k: coldfire: use gpiolib
      mips: pnx833x: remove requirement for GENERIC_GPIO
      openrisc: default GENERIC_GPIO to false
      avr32: default GENERIC_GPIO to false
      xtensa: remove explicit selection of GENERIC_GPIO
      sh: replace CONFIG_GENERIC_GPIO by CONFIG_GPIOLIB
      powerpc: remove redundant GENERIC_GPIO selection
      unicore32: default GENERIC_GPIO to false
      unicore32: remove unneeded select GENERIC_GPIO
      arm: plat-orion: use GPIO driver on CONFIG_GPIOLIB
      arm: remove redundant GENERIC_GPIO selection
      mips: alchemy: require gpiolib
      mips: txx9: change GENERIC_GPIO to GPIOLIB
      mips: loongson: use GPIO driver on CONFIG_GPIOLIB
      mips: remove redundant GENERIC_GPIO select

commit 7fd2bf3d325478e6715cce3ede7de641ff596183
Author: Alexandre Courbot <acourbot@nvidia.com>
Date:   Thu Mar 28 05:07:46 2013 -0700

    Remove GENERIC_GPIO config option
    
    GENERIC_GPIO has been made equivalent to GPIOLIB in architecture code
    and all driver code has been switch to depend on GPIOLIB. It is thus
    safe to have GENERIC_GPIO removed.
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index c29ee7ea200b..59ddf4d0aca9 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -150,7 +150,7 @@ orion_gpio_is_valid(struct orion_gpio_chip *ochip, unsigned pin, int mode)
 }
 
 /*
- * GENERIC_GPIO primitives.
+ * GPIO primitives.
  */
 static int orion_gpio_request(struct gpio_chip *chip, unsigned pin)
 {

commit 8d007488731981e921346a46997dfe9f08cb8201
Author: Simon Guinot <simon.guinot@sequanux.org>
Date:   Sun Mar 24 15:45:30 2013 +0100

    ARM: Orion: add dbg_show function to gpio-orion driver
    
    This patch adds a dedicated dbg_show function to the gpio-mvebu driver.
    In addition to the generic gpiolib informations, this function displays
    informations related with the specific Marvell registers (blink enable,
    data in polarity, interrupt masks and cause).
    
    Signed-off-by: Simon Guinot <simon.guinot@sequanux.org>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index c29ee7ea200b..e39c2ba6e2fb 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -439,6 +439,64 @@ static void gpio_irq_handler(unsigned irq, struct irq_desc *desc)
 	}
 }
 
+#ifdef CONFIG_DEBUG_FS
+#include <linux/seq_file.h>
+
+static void orion_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)
+{
+	struct orion_gpio_chip *ochip =
+		container_of(chip, struct orion_gpio_chip, chip);
+	u32 out, io_conf, blink, in_pol, data_in, cause, edg_msk, lvl_msk;
+	int i;
+
+	out	= readl_relaxed(GPIO_OUT(ochip));
+	io_conf	= readl_relaxed(GPIO_IO_CONF(ochip));
+	blink	= readl_relaxed(GPIO_BLINK_EN(ochip));
+	in_pol	= readl_relaxed(GPIO_IN_POL(ochip));
+	data_in	= readl_relaxed(GPIO_DATA_IN(ochip));
+	cause	= readl_relaxed(GPIO_EDGE_CAUSE(ochip));
+	edg_msk	= readl_relaxed(GPIO_EDGE_MASK(ochip));
+	lvl_msk	= readl_relaxed(GPIO_LEVEL_MASK(ochip));
+
+	for (i = 0; i < chip->ngpio; i++) {
+		const char *label;
+		u32 msk;
+		bool is_out;
+
+		label = gpiochip_is_requested(chip, i);
+		if (!label)
+			continue;
+
+		msk = 1 << i;
+		is_out = !(io_conf & msk);
+
+		seq_printf(s, " gpio-%-3d (%-20.20s)", chip->base + i, label);
+
+		if (is_out) {
+			seq_printf(s, " out %s %s\n",
+				   out & msk ? "hi" : "lo",
+				   blink & msk ? "(blink )" : "");
+			continue;
+		}
+
+		seq_printf(s, " in  %s (act %s) - IRQ",
+			   (data_in ^ in_pol) & msk  ? "hi" : "lo",
+			   in_pol & msk ? "lo" : "hi");
+		if (!((edg_msk | lvl_msk) & msk)) {
+			seq_printf(s, " disabled\n");
+			continue;
+		}
+		if (edg_msk & msk)
+			seq_printf(s, " edge ");
+		if (lvl_msk & msk)
+			seq_printf(s, " level");
+		seq_printf(s, " (%s)\n", cause & msk ? "pending" : "clear  ");
+	}
+}
+#else
+#define orion_gpio_dbg_show NULL
+#endif
+
 void __init orion_gpio_init(struct device_node *np,
 			    int gpio_base, int ngpio,
 			    void __iomem *base, int mask_offset,
@@ -471,6 +529,7 @@ void __init orion_gpio_init(struct device_node *np,
 #ifdef CONFIG_OF
 	ochip->chip.of_node = np;
 #endif
+	ochip->chip.dbg_show = orion_gpio_dbg_show;
 
 	spin_lock_init(&ochip->lock);
 	ochip->base = (void __iomem *)base;

commit ce91574c202b8581ad15bfb1427af824f462c3d2
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Wed Aug 29 10:16:55 2012 -0500

    ARM: orion: move custom gpio functions to orion-gpio.h
    
    Move custom orion platforms gpio code to orion-gpio to remove the
    dependency on mach/gpio.h.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index dfda74fae6f2..c29ee7ea200b 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -23,7 +23,7 @@
 #include <linux/of.h>
 #include <linux/of_irq.h>
 #include <linux/of_address.h>
-#include <plat/gpio.h>
+#include <plat/orion-gpio.h>
 
 /*
  * GPIO unit register offsets.

commit 278b45b06bf721b7cf5de67a0126786c60c720e6
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jun 27 13:40:04 2012 +0200

    ARM: Orion: DT support for IRQ and GPIO Controllers
    
    Both IRQ and GPIO controllers can now be represented in DT.  The IRQ
    controllers are setup first, and then the GPIO controllers. Interrupts
    for GPIO lines are placed directly after the main interrupts in the
    interrupt space.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@googlemail.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Tested-by: Josh Coombs <josh.coombs@gmail.com>
    Tested-by: Simon Baatz <gmbnomis@gmail.com>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index af95af257301..dfda74fae6f2 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -8,15 +8,22 @@
  * warranty of any kind, whether express or implied.
  */
 
+#define DEBUG
+
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/irq.h>
+#include <linux/irqdomain.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
 #include <linux/bitops.h>
 #include <linux/io.h>
 #include <linux/gpio.h>
 #include <linux/leds.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <plat/gpio.h>
 
 /*
  * GPIO unit register offsets.
@@ -38,6 +45,7 @@ struct orion_gpio_chip {
 	unsigned long		valid_output;
 	int			mask_offset;
 	int			secondary_irq_base;
+	struct irq_domain       *domain;
 };
 
 static void __iomem *GPIO_OUT(struct orion_gpio_chip *ochip)
@@ -222,10 +230,10 @@ static int orion_gpio_to_irq(struct gpio_chip *chip, unsigned pin)
 	struct orion_gpio_chip *ochip =
 		container_of(chip, struct orion_gpio_chip, chip);
 
-	return ochip->secondary_irq_base + pin;
+	return irq_create_mapping(ochip->domain,
+				  ochip->secondary_irq_base + pin);
 }
 
-
 /*
  * Orion-specific GPIO API extensions.
  */
@@ -353,12 +361,10 @@ static int gpio_irq_set_type(struct irq_data *d, u32 type)
 	int pin;
 	u32 u;
 
-	pin = d->irq - gc->irq_base;
+	pin = d->hwirq - ochip->secondary_irq_base;
 
 	u = readl(GPIO_IO_CONF(ochip)) & (1 << pin);
 	if (!u) {
-		printk(KERN_ERR "orion gpio_irq_set_type failed "
-				"(irq %d, pin %d).\n", d->irq, pin);
 		return -EINVAL;
 	}
 
@@ -397,17 +403,53 @@ static int gpio_irq_set_type(struct irq_data *d, u32 type)
 			u &= ~(1 << pin);	/* rising */
 		writel(u, GPIO_IN_POL(ochip));
 	}
-
 	return 0;
 }
 
-void __init orion_gpio_init(int gpio_base, int ngpio,
-			    u32 base, int mask_offset, int secondary_irq_base)
+static void gpio_irq_handler(unsigned irq, struct irq_desc *desc)
+{
+	struct orion_gpio_chip *ochip = irq_get_handler_data(irq);
+	u32 cause, type;
+	int i;
+
+	if (ochip == NULL)
+		return;
+
+	cause = readl(GPIO_DATA_IN(ochip)) & readl(GPIO_LEVEL_MASK(ochip));
+	cause |= readl(GPIO_EDGE_CAUSE(ochip)) & readl(GPIO_EDGE_MASK(ochip));
+
+	for (i = 0; i < ochip->chip.ngpio; i++) {
+		int irq;
+
+		irq = ochip->secondary_irq_base + i;
+
+		if (!(cause & (1 << i)))
+			continue;
+
+		type = irqd_get_trigger_type(irq_get_irq_data(irq));
+		if ((type & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {
+			/* Swap polarity (race with GPIO line) */
+			u32 polarity;
+
+			polarity = readl(GPIO_IN_POL(ochip));
+			polarity ^= 1 << i;
+			writel(polarity, GPIO_IN_POL(ochip));
+		}
+		generic_handle_irq(irq);
+	}
+}
+
+void __init orion_gpio_init(struct device_node *np,
+			    int gpio_base, int ngpio,
+			    void __iomem *base, int mask_offset,
+			    int secondary_irq_base,
+			    int irqs[4])
 {
 	struct orion_gpio_chip *ochip;
 	struct irq_chip_generic *gc;
 	struct irq_chip_type *ct;
 	char gc_label[16];
+	int i;
 
 	if (orion_gpio_chip_count == ARRAY_SIZE(orion_gpio_chips))
 		return;
@@ -426,6 +468,10 @@ void __init orion_gpio_init(int gpio_base, int ngpio,
 	ochip->chip.base = gpio_base;
 	ochip->chip.ngpio = ngpio;
 	ochip->chip.can_sleep = 0;
+#ifdef CONFIG_OF
+	ochip->chip.of_node = np;
+#endif
+
 	spin_lock_init(&ochip->lock);
 	ochip->base = (void __iomem *)base;
 	ochip->valid_input = 0;
@@ -435,8 +481,6 @@ void __init orion_gpio_init(int gpio_base, int ngpio,
 
 	gpiochip_add(&ochip->chip);
 
-	orion_gpio_chip_count++;
-
 	/*
 	 * Mask and clear GPIO interrupts.
 	 */
@@ -444,16 +488,28 @@ void __init orion_gpio_init(int gpio_base, int ngpio,
 	writel(0, GPIO_EDGE_MASK(ochip));
 	writel(0, GPIO_LEVEL_MASK(ochip));
 
-	gc = irq_alloc_generic_chip("orion_gpio_irq", 2, secondary_irq_base,
+	/* Setup the interrupt handlers. Each chip can have up to 4
+	 * interrupt handlers, with each handler dealing with 8 GPIO
+	 * pins. */
+
+	for (i = 0; i < 4; i++) {
+		if (irqs[i]) {
+			irq_set_handler_data(irqs[i], ochip);
+			irq_set_chained_handler(irqs[i], gpio_irq_handler);
+		}
+	}
+
+	gc = irq_alloc_generic_chip("orion_gpio_irq", 2,
+				    secondary_irq_base,
 				    ochip->base, handle_level_irq);
 	gc->private = ochip;
-
 	ct = gc->chip_types;
 	ct->regs.mask = ochip->mask_offset + GPIO_LEVEL_MASK_OFF;
 	ct->type = IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW;
 	ct->chip.irq_mask = irq_gc_mask_clr_bit;
 	ct->chip.irq_unmask = irq_gc_mask_set_bit;
 	ct->chip.irq_set_type = gpio_irq_set_type;
+	ct->chip.name = ochip->chip.label;
 
 	ct++;
 	ct->regs.mask = ochip->mask_offset + GPIO_EDGE_MASK_OFF;
@@ -464,41 +520,69 @@ void __init orion_gpio_init(int gpio_base, int ngpio,
 	ct->chip.irq_unmask = irq_gc_mask_set_bit;
 	ct->chip.irq_set_type = gpio_irq_set_type;
 	ct->handler = handle_edge_irq;
+	ct->chip.name = ochip->chip.label;
 
 	irq_setup_generic_chip(gc, IRQ_MSK(ngpio), IRQ_GC_INIT_MASK_CACHE,
 			       IRQ_NOREQUEST, IRQ_LEVEL | IRQ_NOPROBE);
-}
 
-void orion_gpio_irq_handler(int pinoff)
-{
-	struct orion_gpio_chip *ochip;
-	u32 cause, type;
-	int i;
-
-	ochip = orion_gpio_chip_find(pinoff);
-	if (ochip == NULL)
-		return;
-
-	cause = readl(GPIO_DATA_IN(ochip)) & readl(GPIO_LEVEL_MASK(ochip));
-	cause |= readl(GPIO_EDGE_CAUSE(ochip)) & readl(GPIO_EDGE_MASK(ochip));
-
-	for (i = 0; i < ochip->chip.ngpio; i++) {
-		int irq;
+	/* Setup irq domain on top of the generic chip. */
+	ochip->domain = irq_domain_add_legacy(np,
+					      ochip->chip.ngpio,
+					      ochip->secondary_irq_base,
+					      ochip->secondary_irq_base,
+					      &irq_domain_simple_ops,
+					      ochip);
+	if (!ochip->domain)
+		panic("%s: couldn't allocate irq domain (DT).\n",
+		      ochip->chip.label);
 
-		irq = ochip->secondary_irq_base + i;
+	orion_gpio_chip_count++;
+}
 
-		if (!(cause & (1 << i)))
-			continue;
+#ifdef CONFIG_OF
+static void __init orion_gpio_of_init_one(struct device_node *np,
+					  int irq_gpio_base)
+{
+	int ngpio, gpio_base, mask_offset;
+	void __iomem *base;
+	int ret, i;
+	int irqs[4];
+	int secondary_irq_base;
+
+	ret = of_property_read_u32(np, "ngpio", &ngpio);
+	if (ret)
+		goto out;
+	ret = of_property_read_u32(np, "mask-offset", &mask_offset);
+	if (ret == -EINVAL)
+		mask_offset = 0;
+	else
+		goto out;
+	base = of_iomap(np, 0);
+	if (!base)
+		goto out;
+
+	secondary_irq_base = irq_gpio_base + (32 * orion_gpio_chip_count);
+	gpio_base = 32 * orion_gpio_chip_count;
+
+	/* Get the interrupt numbers. Each chip can have up to 4
+	 * interrupt handlers, with each handler dealing with 8 GPIO
+	 * pins. */
+
+	for (i = 0; i < 4; i++)
+		irqs[i] = irq_of_parse_and_map(np, i);
+
+	orion_gpio_init(np, gpio_base, ngpio, base, mask_offset,
+			secondary_irq_base, irqs);
+	return;
+out:
+	pr_err("%s: %s: missing mandatory property\n", __func__, np->name);
+}
 
-		type = irqd_get_trigger_type(irq_get_irq_data(irq));
-		if ((type & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {
-			/* Swap polarity (race with GPIO line) */
-			u32 polarity;
+void __init orion_gpio_of_init(int irq_gpio_base)
+{
+	struct device_node *np;
 
-			polarity = readl(GPIO_IN_POL(ochip));
-			polarity ^= 1 << i;
-			writel(polarity, GPIO_IN_POL(ochip));
-		}
-		generic_handle_irq(irq);
-	}
+	for_each_compatible_node(np, NULL, "marvell,orion-gpio")
+		orion_gpio_of_init_one(np, irq_gpio_base);
 }
+#endif

commit ff3e660b5a881b401b2b6735aa5334f433237dcb
Author: Arnaud Patard (Rtp) <arnaud.patard@rtp-net.org>
Date:   Wed Apr 18 23:16:40 2012 +0200

    orion/kirkwood: create a generic function for gpio led blinking
    
    dns323 and (at least) iconnect platforms are using hw led blinking, so,
    instead of having 2 identicals .gpio_blink_set gpio-led hooks, move
    dns323 code into gpio.c
    
    Signed-off-by: Arnaud Patard <arnaud.patard@rtp-net.org>
    Tested-By: Adam Baker <linux@baker-net.org.uk>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index d3401e77ff3d..af95af257301 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -16,6 +16,7 @@
 #include <linux/bitops.h>
 #include <linux/io.h>
 #include <linux/gpio.h>
+#include <linux/leds.h>
 
 /*
  * GPIO unit register offsets.
@@ -295,6 +296,28 @@ void orion_gpio_set_blink(unsigned pin, int blink)
 }
 EXPORT_SYMBOL(orion_gpio_set_blink);
 
+#define ORION_BLINK_HALF_PERIOD 100 /* ms */
+
+int orion_gpio_led_blink_set(unsigned gpio, int state,
+	unsigned long *delay_on, unsigned long *delay_off)
+{
+
+	if (delay_on && delay_off && !*delay_on && !*delay_off)
+		*delay_on = *delay_off = ORION_BLINK_HALF_PERIOD;
+
+	switch (state) {
+	case GPIO_LED_NO_BLINK_LOW:
+	case GPIO_LED_NO_BLINK_HIGH:
+		orion_gpio_set_blink(gpio, 0);
+		gpio_set_value(gpio, state);
+		break;
+	case GPIO_LED_BLINK:
+		orion_gpio_set_blink(gpio, 1);
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(orion_gpio_led_blink_set);
+
 
 /*****************************************************************************
  * Orion GPIO IRQ

commit 92a486eabefadca1169fbf15d737feeaf2bda844
Author: Arnaud Patard (Rtp) <arnaud.patard@rtp-net.org>
Date:   Wed Apr 18 23:16:39 2012 +0200

    kirkwood/orion: fix orion_gpio_set_blink
    
    gpio registers are for 32 gpios. Given that orion_gpio_set_blink is called
    directly and not through gpiolib, it needs to make sure that the pin value
    given to the internal functions are between 0 and 31.
    
    Signed-off-by: Arnaud Patard <arnaud.patard@rtp-net.org>
    Tested-By: Adam Baker <linux@baker-net.org.uk>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index 10d160888133..d3401e77ff3d 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -289,8 +289,8 @@ void orion_gpio_set_blink(unsigned pin, int blink)
 		return;
 
 	spin_lock_irqsave(&ochip->lock, flags);
-	__set_level(ochip, pin, 0);
-	__set_blinking(ochip, pin, blink);
+	__set_level(ochip, pin & 31, 0);
+	__set_blinking(ochip, pin & 31, blink);
 	spin_unlock_irqrestore(&ochip->lock, flags);
 }
 EXPORT_SYMBOL(orion_gpio_set_blink);

commit 0b35a45bde561d67ffd83b352764b48f936f46bb
Author: Holger Brunck <holger.brunck@keymile.com>
Date:   Mon Dec 19 17:49:48 2011 +0100

    ARM: plat-orion: make gpiochip label unique
    
    The former implementation adds a fix gpiochip label string
    to the framework. This is confusing because orion_gpio_init
    is called more than once and this ends up in different gpiochips
    with the same label.
    
    This patch adds the already present orion_gpio_chip_count to the
    label string to make it unique in the system.
    
    Signed-off-by: Holger Brunck <holger.brunck@keymile.com>
    Cc: Lennert Buytenhek <kernel@wantstofly.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index 41ab97ebe4cf..10d160888133 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -384,12 +384,16 @@ void __init orion_gpio_init(int gpio_base, int ngpio,
 	struct orion_gpio_chip *ochip;
 	struct irq_chip_generic *gc;
 	struct irq_chip_type *ct;
+	char gc_label[16];
 
 	if (orion_gpio_chip_count == ARRAY_SIZE(orion_gpio_chips))
 		return;
 
+	snprintf(gc_label, sizeof(gc_label), "orion_gpio%d",
+		orion_gpio_chip_count);
+
 	ochip = orion_gpio_chips + orion_gpio_chip_count;
-	ochip->chip.label = "orion_gpio";
+	ochip->chip.label = kstrdup(gc_label, GFP_KERNEL);
 	ochip->chip.request = orion_gpio_request;
 	ochip->chip.direction_input = orion_gpio_direction_input;
 	ochip->chip.get = orion_gpio_get;

commit 659fb32d1b67476f4ade25e9ea0e2642a5b9c4b5
Author: Simon Guinot <sguinot@lacie.com>
Date:   Wed Jul 6 12:41:31 2011 -0400

    genirq: replace irq_gc_ack() with {set,clr}_bit variants (fwd)
    
    This fixes a regression introduced by e59347a "arm: orion:
    Use generic irq chip".
    
    Depending on the device, interrupts acknowledgement is done by setting
    or by clearing a dedicated register. Replace irq_gc_ack() with some
    {set,clr}_bit variants allows to handle both cases.
    
    Note that this patch affects the following SoCs: Davinci, Samsung and
    Orion. Except for this last, the change is minor: irq_gc_ack() is just
    renamed into irq_gc_ack_set_bit().
    
    For the Orion SoCs, the edge GPIO interrupts support is currently
    broken. irq_gc_ack() try to acknowledge a such interrupt by setting
    the corresponding cause register bit. The Orion GPIO device expect the
    opposite. To fix this issue, the irq_gc_ack_clr_bit() variant is used.
    
    Tested on Network Space v2.
    
    Reported-by: Joey Oravec <joravec@drewtech.com>
    Signed-off-by: Simon Guinot <sguinot@lacie.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index 5b4fffab1eb4..41ab97ebe4cf 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -432,7 +432,7 @@ void __init orion_gpio_init(int gpio_base, int ngpio,
 	ct->regs.mask = ochip->mask_offset + GPIO_EDGE_MASK_OFF;
 	ct->regs.ack = GPIO_EDGE_CAUSE_OFF;
 	ct->type = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;
-	ct->chip.irq_ack = irq_gc_ack;
+	ct->chip.irq_ack = irq_gc_ack_clr_bit;
 	ct->chip.irq_mask = irq_gc_mask_clr_bit;
 	ct->chip.irq_unmask = irq_gc_mask_set_bit;
 	ct->chip.irq_set_type = gpio_irq_set_type;

commit e59347a1d15c0b1d9fdc510520f8fa78d7d19a5b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 14 19:17:57 2011 +0200

    arm: orion: Use generic irq chip
    
    The core interrupt chip is a straight forward conversion. The gpio
    chip is implemented with two instances of the irq_chip_type which can
    be switched with the irq_set_type function. That allows us to use the
    generic callbacks and avoids the conditionals in them.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index a431a138f402..5b4fffab1eb4 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -321,59 +321,16 @@ EXPORT_SYMBOL(orion_gpio_set_blink);
  *        polarity    LEVEL          mask
  *
  ****************************************************************************/
-static void gpio_irq_ack(struct irq_data *d)
-{
-	struct orion_gpio_chip *ochip = irq_data_get_irq_chip_data(d);
-	int type = irqd_get_trigger_type(d);
-
-	if (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) {
-		int pin = d->irq - ochip->secondary_irq_base;
-
-		writel(~(1 << pin), GPIO_EDGE_CAUSE(ochip));
-	}
-}
-
-static void gpio_irq_mask(struct irq_data *d)
-{
-	struct orion_gpio_chip *ochip = irq_data_get_irq_chip_data(d);
-	int type = irqd_get_trigger_type(d);
-	void __iomem *reg;
-	int pin;
-
-	if (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING))
-		reg = GPIO_EDGE_MASK(ochip);
-	else
-		reg = GPIO_LEVEL_MASK(ochip);
-
-	pin = d->irq - ochip->secondary_irq_base;
-
-	writel(readl(reg) & ~(1 << pin), reg);
-}
-
-static void gpio_irq_unmask(struct irq_data *d)
-{
-	struct orion_gpio_chip *ochip = irq_data_get_irq_chip_data(d);
-	int type = irqd_get_trigger_type(d);
-	void __iomem *reg;
-	int pin;
-
-	if (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING))
-		reg = GPIO_EDGE_MASK(ochip);
-	else
-		reg = GPIO_LEVEL_MASK(ochip);
-
-	pin = d->irq - ochip->secondary_irq_base;
-
-	writel(readl(reg) | (1 << pin), reg);
-}
 
 static int gpio_irq_set_type(struct irq_data *d, u32 type)
 {
-	struct orion_gpio_chip *ochip = irq_data_get_irq_chip_data(d);
+	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
+	struct irq_chip_type *ct = irq_data_get_chip_type(d);
+	struct orion_gpio_chip *ochip = gc->private;
 	int pin;
 	u32 u;
 
-	pin = d->irq - ochip->secondary_irq_base;
+	pin = d->irq - gc->irq_base;
 
 	u = readl(GPIO_IO_CONF(ochip)) & (1 << pin);
 	if (!u) {
@@ -382,18 +339,14 @@ static int gpio_irq_set_type(struct irq_data *d, u32 type)
 		return -EINVAL;
 	}
 
-	/*
-	 * Set edge/level type.
-	 */
-	if (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) {
-		__irq_set_handler_locked(d->irq, handle_edge_irq);
-	} else if (type & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) {
-		__irq_set_handler_locked(d->irq, handle_level_irq);
-	} else {
-		printk(KERN_ERR "failed to set irq=%d (type=%d)\n",
-		       d->irq, type);
+	type &= IRQ_TYPE_SENSE_MASK;
+	if (type == IRQ_TYPE_NONE)
 		return -EINVAL;
-	}
+
+	/* Check if we need to change chip and handler */
+	if (!(ct->type & type))
+		if (irq_setup_alt_chip(d, type))
+			return -EINVAL;
 
 	/*
 	 * Configure interrupt polarity.
@@ -425,19 +378,12 @@ static int gpio_irq_set_type(struct irq_data *d, u32 type)
 	return 0;
 }
 
-struct irq_chip orion_gpio_irq_chip = {
-	.name		= "orion_gpio_irq",
-	.irq_ack	= gpio_irq_ack,
-	.irq_mask	= gpio_irq_mask,
-	.irq_unmask	= gpio_irq_unmask,
-	.irq_set_type	= gpio_irq_set_type,
-};
-
 void __init orion_gpio_init(int gpio_base, int ngpio,
 			    u32 base, int mask_offset, int secondary_irq_base)
 {
 	struct orion_gpio_chip *ochip;
-	int i;
+	struct irq_chip_generic *gc;
+	struct irq_chip_type *ct;
 
 	if (orion_gpio_chip_count == ARRAY_SIZE(orion_gpio_chips))
 		return;
@@ -471,15 +417,29 @@ void __init orion_gpio_init(int gpio_base, int ngpio,
 	writel(0, GPIO_EDGE_MASK(ochip));
 	writel(0, GPIO_LEVEL_MASK(ochip));
 
-	for (i = 0; i < ngpio; i++) {
-		unsigned int irq = secondary_irq_base + i;
-
-		irq_set_chip_and_handler(irq, &orion_gpio_irq_chip,
-					 handle_level_irq);
-		irq_set_chip_data(irq, ochip);
-		irq_set_status_flags(irq, IRQ_LEVEL);
-		set_irq_flags(irq, IRQF_VALID);
-	}
+	gc = irq_alloc_generic_chip("orion_gpio_irq", 2, secondary_irq_base,
+				    ochip->base, handle_level_irq);
+	gc->private = ochip;
+
+	ct = gc->chip_types;
+	ct->regs.mask = ochip->mask_offset + GPIO_LEVEL_MASK_OFF;
+	ct->type = IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW;
+	ct->chip.irq_mask = irq_gc_mask_clr_bit;
+	ct->chip.irq_unmask = irq_gc_mask_set_bit;
+	ct->chip.irq_set_type = gpio_irq_set_type;
+
+	ct++;
+	ct->regs.mask = ochip->mask_offset + GPIO_EDGE_MASK_OFF;
+	ct->regs.ack = GPIO_EDGE_CAUSE_OFF;
+	ct->type = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;
+	ct->chip.irq_ack = irq_gc_ack;
+	ct->chip.irq_mask = irq_gc_mask_clr_bit;
+	ct->chip.irq_unmask = irq_gc_mask_set_bit;
+	ct->chip.irq_set_type = gpio_irq_set_type;
+	ct->handler = handle_edge_irq;
+
+	irq_setup_generic_chip(gc, IRQ_MSK(ngpio), IRQ_GC_INIT_MASK_CACHE,
+			       IRQ_NOREQUEST, IRQ_LEVEL | IRQ_NOPROBE);
 }
 
 void orion_gpio_irq_handler(int pinoff)

commit f38c02f3b338651e145aac2889ba976baf6b28b3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 13:35:09 2011 +0100

    arm: Fold irq_set_chip/irq_set_handler
    
    Use irq_set_chip_and_handler() instead. Converted with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index 9ea0ae4b782f..a431a138f402 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -474,8 +474,8 @@ void __init orion_gpio_init(int gpio_base, int ngpio,
 	for (i = 0; i < ngpio; i++) {
 		unsigned int irq = secondary_irq_base + i;
 
-		irq_set_chip(irq, &orion_gpio_irq_chip);
-		irq_set_handler(irq, handle_level_irq);
+		irq_set_chip_and_handler(irq, &orion_gpio_irq_chip,
+					 handle_level_irq);
 		irq_set_chip_data(irq, ochip);
 		irq_set_status_flags(irq, IRQ_LEVEL);
 		set_irq_flags(irq, IRQF_VALID);

commit 6845664a6a7d443f03883db59d10749d38d98b8e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 13:25:22 2011 +0100

    arm: Cleanup the irq namespace
    
    Convert to the new function names. Automated with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index 222327b2c230..9ea0ae4b782f 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -474,9 +474,9 @@ void __init orion_gpio_init(int gpio_base, int ngpio,
 	for (i = 0; i < ngpio; i++) {
 		unsigned int irq = secondary_irq_base + i;
 
-		set_irq_chip(irq, &orion_gpio_irq_chip);
-		set_irq_handler(irq, handle_level_irq);
-		set_irq_chip_data(irq, ochip);
+		irq_set_chip(irq, &orion_gpio_irq_chip);
+		irq_set_handler(irq, handle_level_irq);
+		irq_set_chip_data(irq, ochip);
 		irq_set_status_flags(irq, IRQ_LEVEL);
 		set_irq_flags(irq, IRQF_VALID);
 	}

commit e83bbb115e3afc87bdb1d375d33bcfe910920002
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 12:35:19 2011 +0100

    arm: Cleanup irq_desc access
    
    Use the proper wrappers and use the flow type in irq_data.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index 078894bc3b9a..222327b2c230 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -324,9 +324,8 @@ EXPORT_SYMBOL(orion_gpio_set_blink);
 static void gpio_irq_ack(struct irq_data *d)
 {
 	struct orion_gpio_chip *ochip = irq_data_get_irq_chip_data(d);
-	int type;
+	int type = irqd_get_trigger_type(d);
 
-	type = irq_desc[d->irq].status & IRQ_TYPE_SENSE_MASK;
 	if (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) {
 		int pin = d->irq - ochip->secondary_irq_base;
 
@@ -337,11 +336,10 @@ static void gpio_irq_ack(struct irq_data *d)
 static void gpio_irq_mask(struct irq_data *d)
 {
 	struct orion_gpio_chip *ochip = irq_data_get_irq_chip_data(d);
-	int type;
+	int type = irqd_get_trigger_type(d);
 	void __iomem *reg;
 	int pin;
 
-	type = irq_desc[d->irq].status & IRQ_TYPE_SENSE_MASK;
 	if (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING))
 		reg = GPIO_EDGE_MASK(ochip);
 	else
@@ -355,11 +353,10 @@ static void gpio_irq_mask(struct irq_data *d)
 static void gpio_irq_unmask(struct irq_data *d)
 {
 	struct orion_gpio_chip *ochip = irq_data_get_irq_chip_data(d);
-	int type;
+	int type = irqd_get_trigger_type(d);
 	void __iomem *reg;
 	int pin;
 
-	type = irq_desc[d->irq].status & IRQ_TYPE_SENSE_MASK;
 	if (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING))
 		reg = GPIO_EDGE_MASK(ochip);
 	else
@@ -389,9 +386,9 @@ static int gpio_irq_set_type(struct irq_data *d, u32 type)
 	 * Set edge/level type.
 	 */
 	if (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) {
-		set_irq_handler(d->irq, handle_edge_irq);
+		__irq_set_handler_locked(d->irq, handle_edge_irq);
 	} else if (type & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) {
-		set_irq_handler(d->irq, handle_level_irq);
+		__irq_set_handler_locked(d->irq, handle_level_irq);
 	} else {
 		printk(KERN_ERR "failed to set irq=%d (type=%d)\n",
 		       d->irq, type);
@@ -480,7 +477,7 @@ void __init orion_gpio_init(int gpio_base, int ngpio,
 		set_irq_chip(irq, &orion_gpio_irq_chip);
 		set_irq_handler(irq, handle_level_irq);
 		set_irq_chip_data(irq, ochip);
-		irq_desc[irq].status |= IRQ_LEVEL;
+		irq_set_status_flags(irq, IRQ_LEVEL);
 		set_irq_flags(irq, IRQF_VALID);
 	}
 }
@@ -488,7 +485,7 @@ void __init orion_gpio_init(int gpio_base, int ngpio,
 void orion_gpio_irq_handler(int pinoff)
 {
 	struct orion_gpio_chip *ochip;
-	u32 cause;
+	u32 cause, type;
 	int i;
 
 	ochip = orion_gpio_chip_find(pinoff);
@@ -500,15 +497,14 @@ void orion_gpio_irq_handler(int pinoff)
 
 	for (i = 0; i < ochip->chip.ngpio; i++) {
 		int irq;
-		struct irq_desc *desc;
 
 		irq = ochip->secondary_irq_base + i;
 
 		if (!(cause & (1 << i)))
 			continue;
 
-		desc = irq_desc + irq;
-		if ((desc->status & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {
+		type = irqd_get_trigger_type(irq_get_irq_data(irq));
+		if ((type & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {
 			/* Swap polarity (race with GPIO line) */
 			u32 polarity;
 
@@ -516,7 +512,6 @@ void orion_gpio_irq_handler(int pinoff)
 			polarity ^= 1 << i;
 			writel(polarity, GPIO_IN_POL(ochip));
 		}
-
-		desc_handle_irq(irq, desc);
+		generic_handle_irq(irq);
 	}
 }

commit 9eac6d0a4e7e5149a7f86575b46d710ad2e05fe2
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Tue Dec 14 12:54:03 2010 +0100

    ARM: Remove dependency of plat-orion GPIO code on mach directory includes.
    
    This patch makes the various mach dirs that use the plat-orion GPIO
    code pass in GPIO-related platform info (GPIO controller base address,
    secondary base IRQ number, etc) explicitly, instead of having
    plat-orion get those values by including a mach dir include file --
    the latter mechanism is problematic if you want to support multiple
    ARM platforms in the same kernel image.
    
    Signed-off-by: Lennert Buytenhek <buytenh@secretlab.ca>
    Signed-off-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index 5f3522314815..078894bc3b9a 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -17,55 +17,123 @@
 #include <linux/io.h>
 #include <linux/gpio.h>
 
-static DEFINE_SPINLOCK(gpio_lock);
-static unsigned long gpio_valid_input[BITS_TO_LONGS(GPIO_MAX)];
-static unsigned long gpio_valid_output[BITS_TO_LONGS(GPIO_MAX)];
+/*
+ * GPIO unit register offsets.
+ */
+#define GPIO_OUT_OFF		0x0000
+#define GPIO_IO_CONF_OFF	0x0004
+#define GPIO_BLINK_EN_OFF	0x0008
+#define GPIO_IN_POL_OFF		0x000c
+#define GPIO_DATA_IN_OFF	0x0010
+#define GPIO_EDGE_CAUSE_OFF	0x0014
+#define GPIO_EDGE_MASK_OFF	0x0018
+#define GPIO_LEVEL_MASK_OFF	0x001c
+
+struct orion_gpio_chip {
+	struct gpio_chip	chip;
+	spinlock_t		lock;
+	void __iomem		*base;
+	unsigned long		valid_input;
+	unsigned long		valid_output;
+	int			mask_offset;
+	int			secondary_irq_base;
+};
+
+static void __iomem *GPIO_OUT(struct orion_gpio_chip *ochip)
+{
+	return ochip->base + GPIO_OUT_OFF;
+}
+
+static void __iomem *GPIO_IO_CONF(struct orion_gpio_chip *ochip)
+{
+	return ochip->base + GPIO_IO_CONF_OFF;
+}
+
+static void __iomem *GPIO_BLINK_EN(struct orion_gpio_chip *ochip)
+{
+	return ochip->base + GPIO_BLINK_EN_OFF;
+}
+
+static void __iomem *GPIO_IN_POL(struct orion_gpio_chip *ochip)
+{
+	return ochip->base + GPIO_IN_POL_OFF;
+}
+
+static void __iomem *GPIO_DATA_IN(struct orion_gpio_chip *ochip)
+{
+	return ochip->base + GPIO_DATA_IN_OFF;
+}
+
+static void __iomem *GPIO_EDGE_CAUSE(struct orion_gpio_chip *ochip)
+{
+	return ochip->base + GPIO_EDGE_CAUSE_OFF;
+}
+
+static void __iomem *GPIO_EDGE_MASK(struct orion_gpio_chip *ochip)
+{
+	return ochip->base + ochip->mask_offset + GPIO_EDGE_MASK_OFF;
+}
+
+static void __iomem *GPIO_LEVEL_MASK(struct orion_gpio_chip *ochip)
+{
+	return ochip->base + ochip->mask_offset + GPIO_LEVEL_MASK_OFF;
+}
+
 
-static inline void __set_direction(unsigned pin, int input)
+static struct orion_gpio_chip orion_gpio_chips[2];
+static int orion_gpio_chip_count;
+
+static inline void
+__set_direction(struct orion_gpio_chip *ochip, unsigned pin, int input)
 {
 	u32 u;
 
-	u = readl(GPIO_IO_CONF(pin));
+	u = readl(GPIO_IO_CONF(ochip));
 	if (input)
-		u |= 1 << (pin & 31);
+		u |= 1 << pin;
 	else
-		u &= ~(1 << (pin & 31));
-	writel(u, GPIO_IO_CONF(pin));
+		u &= ~(1 << pin);
+	writel(u, GPIO_IO_CONF(ochip));
 }
 
-static void __set_level(unsigned pin, int high)
+static void __set_level(struct orion_gpio_chip *ochip, unsigned pin, int high)
 {
 	u32 u;
 
-	u = readl(GPIO_OUT(pin));
+	u = readl(GPIO_OUT(ochip));
 	if (high)
-		u |= 1 << (pin & 31);
+		u |= 1 << pin;
 	else
-		u &= ~(1 << (pin & 31));
-	writel(u, GPIO_OUT(pin));
+		u &= ~(1 << pin);
+	writel(u, GPIO_OUT(ochip));
 }
 
-static inline void __set_blinking(unsigned pin, int blink)
+static inline void
+__set_blinking(struct orion_gpio_chip *ochip, unsigned pin, int blink)
 {
 	u32 u;
 
-	u = readl(GPIO_BLINK_EN(pin));
+	u = readl(GPIO_BLINK_EN(ochip));
 	if (blink)
-		u |= 1 << (pin & 31);
+		u |= 1 << pin;
 	else
-		u &= ~(1 << (pin & 31));
-	writel(u, GPIO_BLINK_EN(pin));
+		u &= ~(1 << pin);
+	writel(u, GPIO_BLINK_EN(ochip));
 }
 
-static inline int orion_gpio_is_valid(unsigned pin, int mode)
+static inline int
+orion_gpio_is_valid(struct orion_gpio_chip *ochip, unsigned pin, int mode)
 {
-	if (pin < GPIO_MAX) {
-		if ((mode & GPIO_INPUT_OK) && !test_bit(pin, gpio_valid_input))
-			goto err_out;
-		if ((mode & GPIO_OUTPUT_OK) && !test_bit(pin, gpio_valid_output))
-			goto err_out;
-		return true;
-	}
+	if (pin >= ochip->chip.ngpio)
+		goto err_out;
+
+	if ((mode & GPIO_INPUT_OK) && !test_bit(pin, &ochip->valid_input))
+		goto err_out;
+
+	if ((mode & GPIO_OUTPUT_OK) && !test_bit(pin, &ochip->valid_output))
+		goto err_out;
+
+	return 1;
 
 err_out:
 	pr_debug("%s: invalid GPIO %d\n", __func__, pin);
@@ -75,134 +143,155 @@ static inline int orion_gpio_is_valid(unsigned pin, int mode)
 /*
  * GENERIC_GPIO primitives.
  */
+static int orion_gpio_request(struct gpio_chip *chip, unsigned pin)
+{
+	struct orion_gpio_chip *ochip =
+		container_of(chip, struct orion_gpio_chip, chip);
+
+	if (orion_gpio_is_valid(ochip, pin, GPIO_INPUT_OK) ||
+	    orion_gpio_is_valid(ochip, pin, GPIO_OUTPUT_OK))
+		return 0;
+
+	return -EINVAL;
+}
+
 static int orion_gpio_direction_input(struct gpio_chip *chip, unsigned pin)
 {
+	struct orion_gpio_chip *ochip =
+		container_of(chip, struct orion_gpio_chip, chip);
 	unsigned long flags;
 
-	if (!orion_gpio_is_valid(pin, GPIO_INPUT_OK))
+	if (!orion_gpio_is_valid(ochip, pin, GPIO_INPUT_OK))
 		return -EINVAL;
 
-	spin_lock_irqsave(&gpio_lock, flags);
-
-	/* Configure GPIO direction. */
-	__set_direction(pin, 1);
-
-	spin_unlock_irqrestore(&gpio_lock, flags);
+	spin_lock_irqsave(&ochip->lock, flags);
+	__set_direction(ochip, pin, 1);
+	spin_unlock_irqrestore(&ochip->lock, flags);
 
 	return 0;
 }
 
-static int orion_gpio_get_value(struct gpio_chip *chip, unsigned pin)
+static int orion_gpio_get(struct gpio_chip *chip, unsigned pin)
 {
+	struct orion_gpio_chip *ochip =
+		container_of(chip, struct orion_gpio_chip, chip);
 	int val;
 
-	if (readl(GPIO_IO_CONF(pin)) & (1 << (pin & 31)))
-		val = readl(GPIO_DATA_IN(pin)) ^ readl(GPIO_IN_POL(pin));
-	else
-		val = readl(GPIO_OUT(pin));
+	if (readl(GPIO_IO_CONF(ochip)) & (1 << pin)) {
+		val = readl(GPIO_DATA_IN(ochip)) ^ readl(GPIO_IN_POL(ochip));
+	} else {
+		val = readl(GPIO_OUT(ochip));
+	}
 
-	return (val >> (pin & 31)) & 1;
+	return (val >> pin) & 1;
 }
 
-static int orion_gpio_direction_output(struct gpio_chip *chip, unsigned pin,
-	int value)
+static int
+orion_gpio_direction_output(struct gpio_chip *chip, unsigned pin, int value)
 {
+	struct orion_gpio_chip *ochip =
+		container_of(chip, struct orion_gpio_chip, chip);
 	unsigned long flags;
 
-	if (!orion_gpio_is_valid(pin, GPIO_OUTPUT_OK))
+	if (!orion_gpio_is_valid(ochip, pin, GPIO_OUTPUT_OK))
 		return -EINVAL;
 
-	spin_lock_irqsave(&gpio_lock, flags);
-
-	/* Disable blinking. */
-	__set_blinking(pin, 0);
-
-	/* Configure GPIO output value. */
-	__set_level(pin, value);
-
-	/* Configure GPIO direction. */
-	__set_direction(pin, 0);
-
-	spin_unlock_irqrestore(&gpio_lock, flags);
+	spin_lock_irqsave(&ochip->lock, flags);
+	__set_blinking(ochip, pin, 0);
+	__set_level(ochip, pin, value);
+	__set_direction(ochip, pin, 0);
+	spin_unlock_irqrestore(&ochip->lock, flags);
 
 	return 0;
 }
 
-static void orion_gpio_set_value(struct gpio_chip *chip, unsigned pin,
-	int value)
+static void orion_gpio_set(struct gpio_chip *chip, unsigned pin, int value)
 {
+	struct orion_gpio_chip *ochip =
+		container_of(chip, struct orion_gpio_chip, chip);
 	unsigned long flags;
 
-	spin_lock_irqsave(&gpio_lock, flags);
-
-	/* Configure GPIO output value. */
-	__set_level(pin, value);
-
-	spin_unlock_irqrestore(&gpio_lock, flags);
+	spin_lock_irqsave(&ochip->lock, flags);
+	__set_level(ochip, pin, value);
+	spin_unlock_irqrestore(&ochip->lock, flags);
 }
 
-static int orion_gpio_request(struct gpio_chip *chip, unsigned pin)
+static int orion_gpio_to_irq(struct gpio_chip *chip, unsigned pin)
 {
-	if (orion_gpio_is_valid(pin, GPIO_INPUT_OK) ||
-	    orion_gpio_is_valid(pin, GPIO_OUTPUT_OK))
-		return 0;
-	return -EINVAL;
-}
+	struct orion_gpio_chip *ochip =
+		container_of(chip, struct orion_gpio_chip, chip);
 
-static struct gpio_chip orion_gpiochip = {
-	.label			= "orion_gpio",
-	.direction_input	= orion_gpio_direction_input,
-	.get			= orion_gpio_get_value,
-	.direction_output	= orion_gpio_direction_output,
-	.set			= orion_gpio_set_value,
-	.request		= orion_gpio_request,
-	.base			= 0,
-	.ngpio			= GPIO_MAX,
-	.can_sleep		= 0,
-};
-
-void __init orion_gpio_init(void)
-{
-	gpiochip_add(&orion_gpiochip);
+	return ochip->secondary_irq_base + pin;
 }
 
+
 /*
  * Orion-specific GPIO API extensions.
  */
+static struct orion_gpio_chip *orion_gpio_chip_find(int pin)
+{
+	int i;
+
+	for (i = 0; i < orion_gpio_chip_count; i++) {
+		struct orion_gpio_chip *ochip = orion_gpio_chips + i;
+		struct gpio_chip *chip = &ochip->chip;
+
+		if (pin >= chip->base && pin < chip->base + chip->ngpio)
+			return ochip;
+	}
+
+	return NULL;
+}
+
 void __init orion_gpio_set_unused(unsigned pin)
 {
+	struct orion_gpio_chip *ochip = orion_gpio_chip_find(pin);
+
+	if (ochip == NULL)
+		return;
+
+	pin -= ochip->chip.base;
+
 	/* Configure as output, drive low. */
-	__set_level(pin, 0);
-	__set_direction(pin, 0);
+	__set_level(ochip, pin, 0);
+	__set_direction(ochip, pin, 0);
 }
 
 void __init orion_gpio_set_valid(unsigned pin, int mode)
 {
+	struct orion_gpio_chip *ochip = orion_gpio_chip_find(pin);
+
+	if (ochip == NULL)
+		return;
+
+	pin -= ochip->chip.base;
+
 	if (mode == 1)
 		mode = GPIO_INPUT_OK | GPIO_OUTPUT_OK;
+
 	if (mode & GPIO_INPUT_OK)
-		__set_bit(pin, gpio_valid_input);
+		__set_bit(pin, &ochip->valid_input);
 	else
-		__clear_bit(pin, gpio_valid_input);
+		__clear_bit(pin, &ochip->valid_input);
+
 	if (mode & GPIO_OUTPUT_OK)
-		__set_bit(pin, gpio_valid_output);
+		__set_bit(pin, &ochip->valid_output);
 	else
-		__clear_bit(pin, gpio_valid_output);
+		__clear_bit(pin, &ochip->valid_output);
 }
 
 void orion_gpio_set_blink(unsigned pin, int blink)
 {
+	struct orion_gpio_chip *ochip = orion_gpio_chip_find(pin);
 	unsigned long flags;
 
-	spin_lock_irqsave(&gpio_lock, flags);
+	if (ochip == NULL)
+		return;
 
-	/* Set output value to zero. */
-	__set_level(pin, 0);
-
-	/* Set blinking. */
-	__set_blinking(pin, blink);
-
-	spin_unlock_irqrestore(&gpio_lock, flags);
+	spin_lock_irqsave(&ochip->lock, flags);
+	__set_level(ochip, pin, 0);
+	__set_blinking(ochip, pin, blink);
+	spin_unlock_irqrestore(&ochip->lock, flags);
 }
 EXPORT_SYMBOL(orion_gpio_set_blink);
 
@@ -234,59 +323,78 @@ EXPORT_SYMBOL(orion_gpio_set_blink);
  ****************************************************************************/
 static void gpio_irq_ack(struct irq_data *d)
 {
-	int type = irq_desc[d->irq].status & IRQ_TYPE_SENSE_MASK;
+	struct orion_gpio_chip *ochip = irq_data_get_irq_chip_data(d);
+	int type;
+
+	type = irq_desc[d->irq].status & IRQ_TYPE_SENSE_MASK;
 	if (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) {
-		int pin = irq_to_gpio(d->irq);
-		writel(~(1 << (pin & 31)), GPIO_EDGE_CAUSE(pin));
+		int pin = d->irq - ochip->secondary_irq_base;
+
+		writel(~(1 << pin), GPIO_EDGE_CAUSE(ochip));
 	}
 }
 
 static void gpio_irq_mask(struct irq_data *d)
 {
-	int pin = irq_to_gpio(d->irq);
-	int type = irq_desc[d->irq].status & IRQ_TYPE_SENSE_MASK;
-	u32 reg = (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) ?
-		GPIO_EDGE_MASK(pin) : GPIO_LEVEL_MASK(pin);
-	u32 u = readl(reg);
-	u &= ~(1 << (pin & 31));
-	writel(u, reg);
+	struct orion_gpio_chip *ochip = irq_data_get_irq_chip_data(d);
+	int type;
+	void __iomem *reg;
+	int pin;
+
+	type = irq_desc[d->irq].status & IRQ_TYPE_SENSE_MASK;
+	if (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING))
+		reg = GPIO_EDGE_MASK(ochip);
+	else
+		reg = GPIO_LEVEL_MASK(ochip);
+
+	pin = d->irq - ochip->secondary_irq_base;
+
+	writel(readl(reg) & ~(1 << pin), reg);
 }
 
 static void gpio_irq_unmask(struct irq_data *d)
 {
-	int pin = irq_to_gpio(d->irq);
-	int type = irq_desc[d->irq].status & IRQ_TYPE_SENSE_MASK;
-	u32 reg = (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) ?
-		GPIO_EDGE_MASK(pin) : GPIO_LEVEL_MASK(pin);
-	u32 u = readl(reg);
-	u |= 1 << (pin & 31);
-	writel(u, reg);
+	struct orion_gpio_chip *ochip = irq_data_get_irq_chip_data(d);
+	int type;
+	void __iomem *reg;
+	int pin;
+
+	type = irq_desc[d->irq].status & IRQ_TYPE_SENSE_MASK;
+	if (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING))
+		reg = GPIO_EDGE_MASK(ochip);
+	else
+		reg = GPIO_LEVEL_MASK(ochip);
+
+	pin = d->irq - ochip->secondary_irq_base;
+
+	writel(readl(reg) | (1 << pin), reg);
 }
 
 static int gpio_irq_set_type(struct irq_data *d, u32 type)
 {
-	int pin = irq_to_gpio(d->irq);
-	struct irq_desc *desc;
+	struct orion_gpio_chip *ochip = irq_data_get_irq_chip_data(d);
+	int pin;
 	u32 u;
 
-	u = readl(GPIO_IO_CONF(pin)) & (1 << (pin & 31));
+	pin = d->irq - ochip->secondary_irq_base;
+
+	u = readl(GPIO_IO_CONF(ochip)) & (1 << pin);
 	if (!u) {
 		printk(KERN_ERR "orion gpio_irq_set_type failed "
 				"(irq %d, pin %d).\n", d->irq, pin);
 		return -EINVAL;
 	}
 
-	desc = irq_desc + d->irq;
-
 	/*
 	 * Set edge/level type.
 	 */
 	if (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) {
-		desc->handle_irq = handle_edge_irq;
+		set_irq_handler(d->irq, handle_edge_irq);
 	} else if (type & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) {
-		desc->handle_irq = handle_level_irq;
+		set_irq_handler(d->irq, handle_level_irq);
 	} else {
-		printk(KERN_ERR "failed to set irq=%d (type=%d)\n", d->irq, type);
+		printk(KERN_ERR "failed to set irq=%d (type=%d)\n",
+		       d->irq, type);
 		return -EINVAL;
 	}
 
@@ -294,31 +402,29 @@ static int gpio_irq_set_type(struct irq_data *d, u32 type)
 	 * Configure interrupt polarity.
 	 */
 	if (type == IRQ_TYPE_EDGE_RISING || type == IRQ_TYPE_LEVEL_HIGH) {
-		u = readl(GPIO_IN_POL(pin));
-		u &= ~(1 << (pin & 31));
-		writel(u, GPIO_IN_POL(pin));
+		u = readl(GPIO_IN_POL(ochip));
+		u &= ~(1 << pin);
+		writel(u, GPIO_IN_POL(ochip));
 	} else if (type == IRQ_TYPE_EDGE_FALLING || type == IRQ_TYPE_LEVEL_LOW) {
-		u = readl(GPIO_IN_POL(pin));
-		u |= 1 << (pin & 31);
-		writel(u, GPIO_IN_POL(pin));
+		u = readl(GPIO_IN_POL(ochip));
+		u |= 1 << pin;
+		writel(u, GPIO_IN_POL(ochip));
 	} else if (type == IRQ_TYPE_EDGE_BOTH) {
 		u32 v;
 
-		v = readl(GPIO_IN_POL(pin)) ^ readl(GPIO_DATA_IN(pin));
+		v = readl(GPIO_IN_POL(ochip)) ^ readl(GPIO_DATA_IN(ochip));
 
 		/*
 		 * set initial polarity based on current input level
 		 */
-		u = readl(GPIO_IN_POL(pin));
-		if (v & (1 << (pin & 31)))
-			u |= 1 << (pin & 31);		/* falling */
+		u = readl(GPIO_IN_POL(ochip));
+		if (v & (1 << pin))
+			u |= 1 << pin;		/* falling */
 		else
-			u &= ~(1 << (pin & 31));	/* rising */
-		writel(u, GPIO_IN_POL(pin));
+			u &= ~(1 << pin);	/* rising */
+		writel(u, GPIO_IN_POL(ochip));
 	}
 
-	desc->status = (desc->status & ~IRQ_TYPE_SENSE_MASK) | type;
-
 	return 0;
 }
 
@@ -330,29 +436,87 @@ struct irq_chip orion_gpio_irq_chip = {
 	.irq_set_type	= gpio_irq_set_type,
 };
 
+void __init orion_gpio_init(int gpio_base, int ngpio,
+			    u32 base, int mask_offset, int secondary_irq_base)
+{
+	struct orion_gpio_chip *ochip;
+	int i;
+
+	if (orion_gpio_chip_count == ARRAY_SIZE(orion_gpio_chips))
+		return;
+
+	ochip = orion_gpio_chips + orion_gpio_chip_count;
+	ochip->chip.label = "orion_gpio";
+	ochip->chip.request = orion_gpio_request;
+	ochip->chip.direction_input = orion_gpio_direction_input;
+	ochip->chip.get = orion_gpio_get;
+	ochip->chip.direction_output = orion_gpio_direction_output;
+	ochip->chip.set = orion_gpio_set;
+	ochip->chip.to_irq = orion_gpio_to_irq;
+	ochip->chip.base = gpio_base;
+	ochip->chip.ngpio = ngpio;
+	ochip->chip.can_sleep = 0;
+	spin_lock_init(&ochip->lock);
+	ochip->base = (void __iomem *)base;
+	ochip->valid_input = 0;
+	ochip->valid_output = 0;
+	ochip->mask_offset = mask_offset;
+	ochip->secondary_irq_base = secondary_irq_base;
+
+	gpiochip_add(&ochip->chip);
+
+	orion_gpio_chip_count++;
+
+	/*
+	 * Mask and clear GPIO interrupts.
+	 */
+	writel(0, GPIO_EDGE_CAUSE(ochip));
+	writel(0, GPIO_EDGE_MASK(ochip));
+	writel(0, GPIO_LEVEL_MASK(ochip));
+
+	for (i = 0; i < ngpio; i++) {
+		unsigned int irq = secondary_irq_base + i;
+
+		set_irq_chip(irq, &orion_gpio_irq_chip);
+		set_irq_handler(irq, handle_level_irq);
+		set_irq_chip_data(irq, ochip);
+		irq_desc[irq].status |= IRQ_LEVEL;
+		set_irq_flags(irq, IRQF_VALID);
+	}
+}
+
 void orion_gpio_irq_handler(int pinoff)
 {
+	struct orion_gpio_chip *ochip;
 	u32 cause;
-	int pin;
+	int i;
 
-	cause = readl(GPIO_DATA_IN(pinoff)) & readl(GPIO_LEVEL_MASK(pinoff));
-	cause |= readl(GPIO_EDGE_CAUSE(pinoff)) & readl(GPIO_EDGE_MASK(pinoff));
+	ochip = orion_gpio_chip_find(pinoff);
+	if (ochip == NULL)
+		return;
 
-	for (pin = pinoff; pin < pinoff + 8; pin++) {
-		int irq = gpio_to_irq(pin);
-		struct irq_desc *desc = irq_desc + irq;
+	cause = readl(GPIO_DATA_IN(ochip)) & readl(GPIO_LEVEL_MASK(ochip));
+	cause |= readl(GPIO_EDGE_CAUSE(ochip)) & readl(GPIO_EDGE_MASK(ochip));
 
-		if (!(cause & (1 << (pin & 31))))
+	for (i = 0; i < ochip->chip.ngpio; i++) {
+		int irq;
+		struct irq_desc *desc;
+
+		irq = ochip->secondary_irq_base + i;
+
+		if (!(cause & (1 << i)))
 			continue;
 
+		desc = irq_desc + irq;
 		if ((desc->status & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {
 			/* Swap polarity (race with GPIO line) */
 			u32 polarity;
 
-			polarity = readl(GPIO_IN_POL(pin));
-			polarity ^= 1 << (pin & 31);
-			writel(polarity, GPIO_IN_POL(pin));
+			polarity = readl(GPIO_IN_POL(ochip));
+			polarity ^= 1 << i;
+			writel(polarity, GPIO_IN_POL(ochip));
 		}
+
 		desc_handle_irq(irq, desc);
 	}
 }

commit 3b0c8d40387482d6a446da9ef0c97fede20a7b89
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Mon Nov 29 11:17:38 2010 +0100

    ARM: plat-orion: irq_data conversion.
    
    Signed-off-by: Lennert Buytenhek <buytenh@secretlab.ca>
    Acked-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index e814803d4741..5f3522314815 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -232,20 +232,19 @@ EXPORT_SYMBOL(orion_gpio_set_blink);
  *        polarity    LEVEL          mask
  *
  ****************************************************************************/
-
-static void gpio_irq_ack(u32 irq)
+static void gpio_irq_ack(struct irq_data *d)
 {
-	int type = irq_desc[irq].status & IRQ_TYPE_SENSE_MASK;
+	int type = irq_desc[d->irq].status & IRQ_TYPE_SENSE_MASK;
 	if (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) {
-		int pin = irq_to_gpio(irq);
+		int pin = irq_to_gpio(d->irq);
 		writel(~(1 << (pin & 31)), GPIO_EDGE_CAUSE(pin));
 	}
 }
 
-static void gpio_irq_mask(u32 irq)
+static void gpio_irq_mask(struct irq_data *d)
 {
-	int pin = irq_to_gpio(irq);
-	int type = irq_desc[irq].status & IRQ_TYPE_SENSE_MASK;
+	int pin = irq_to_gpio(d->irq);
+	int type = irq_desc[d->irq].status & IRQ_TYPE_SENSE_MASK;
 	u32 reg = (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) ?
 		GPIO_EDGE_MASK(pin) : GPIO_LEVEL_MASK(pin);
 	u32 u = readl(reg);
@@ -253,10 +252,10 @@ static void gpio_irq_mask(u32 irq)
 	writel(u, reg);
 }
 
-static void gpio_irq_unmask(u32 irq)
+static void gpio_irq_unmask(struct irq_data *d)
 {
-	int pin = irq_to_gpio(irq);
-	int type = irq_desc[irq].status & IRQ_TYPE_SENSE_MASK;
+	int pin = irq_to_gpio(d->irq);
+	int type = irq_desc[d->irq].status & IRQ_TYPE_SENSE_MASK;
 	u32 reg = (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) ?
 		GPIO_EDGE_MASK(pin) : GPIO_LEVEL_MASK(pin);
 	u32 u = readl(reg);
@@ -264,20 +263,20 @@ static void gpio_irq_unmask(u32 irq)
 	writel(u, reg);
 }
 
-static int gpio_irq_set_type(u32 irq, u32 type)
+static int gpio_irq_set_type(struct irq_data *d, u32 type)
 {
-	int pin = irq_to_gpio(irq);
+	int pin = irq_to_gpio(d->irq);
 	struct irq_desc *desc;
 	u32 u;
 
 	u = readl(GPIO_IO_CONF(pin)) & (1 << (pin & 31));
 	if (!u) {
 		printk(KERN_ERR "orion gpio_irq_set_type failed "
-				"(irq %d, pin %d).\n", irq, pin);
+				"(irq %d, pin %d).\n", d->irq, pin);
 		return -EINVAL;
 	}
 
-	desc = irq_desc + irq;
+	desc = irq_desc + d->irq;
 
 	/*
 	 * Set edge/level type.
@@ -287,7 +286,7 @@ static int gpio_irq_set_type(u32 irq, u32 type)
 	} else if (type & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) {
 		desc->handle_irq = handle_level_irq;
 	} else {
-		printk(KERN_ERR "failed to set irq=%d (type=%d)\n", irq, type);
+		printk(KERN_ERR "failed to set irq=%d (type=%d)\n", d->irq, type);
 		return -EINVAL;
 	}
 
@@ -325,10 +324,10 @@ static int gpio_irq_set_type(u32 irq, u32 type)
 
 struct irq_chip orion_gpio_irq_chip = {
 	.name		= "orion_gpio_irq",
-	.ack		= gpio_irq_ack,
-	.mask		= gpio_irq_mask,
-	.unmask		= gpio_irq_unmask,
-	.set_type	= gpio_irq_set_type,
+	.irq_ack	= gpio_irq_ack,
+	.irq_mask	= gpio_irq_mask,
+	.irq_unmask	= gpio_irq_unmask,
+	.irq_set_type	= gpio_irq_set_type,
 };
 
 void orion_gpio_irq_handler(int pinoff)

commit a88656553d18c324554855fccc730c9644048111
Author: Erik Benada <erikbenada@yahoo.ca>
Date:   Thu May 28 17:08:55 2009 -0700

    [ARM] orion: convert gpio to use gpiolib
    
    Signed-off-by: Erik Benada <erikbenada@yahoo.ca>
    
    [ nico: fix locking, additional cleanups ]
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index 32eb9e33bebb..e814803d4741 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -15,10 +15,9 @@
 #include <linux/spinlock.h>
 #include <linux/bitops.h>
 #include <linux/io.h>
-#include <asm/gpio.h>
+#include <linux/gpio.h>
 
 static DEFINE_SPINLOCK(gpio_lock);
-static const char *gpio_label[GPIO_MAX];  /* non null for allocated GPIOs */
 static unsigned long gpio_valid_input[BITS_TO_LONGS(GPIO_MAX)];
 static unsigned long gpio_valid_output[BITS_TO_LONGS(GPIO_MAX)];
 
@@ -46,82 +45,54 @@ static void __set_level(unsigned pin, int high)
 	writel(u, GPIO_OUT(pin));
 }
 
-
-/*
- * GENERIC_GPIO primitives.
- */
-int gpio_direction_input(unsigned pin)
+static inline void __set_blinking(unsigned pin, int blink)
 {
-	unsigned long flags;
-
-	if (pin >= GPIO_MAX || !test_bit(pin, gpio_valid_input)) {
-		pr_debug("%s: invalid GPIO %d\n", __func__, pin);
-		return -EINVAL;
-	}
-
-	spin_lock_irqsave(&gpio_lock, flags);
-
-	/*
-	 * Some callers might not have used gpio_request(),
-	 * so flag this pin as requested now.
-	 */
-	if (gpio_label[pin] == NULL)
-		gpio_label[pin] = "?";
+	u32 u;
 
-	/*
-	 * Configure GPIO direction.
-	 */
-	__set_direction(pin, 1);
+	u = readl(GPIO_BLINK_EN(pin));
+	if (blink)
+		u |= 1 << (pin & 31);
+	else
+		u &= ~(1 << (pin & 31));
+	writel(u, GPIO_BLINK_EN(pin));
+}
 
-	spin_unlock_irqrestore(&gpio_lock, flags);
+static inline int orion_gpio_is_valid(unsigned pin, int mode)
+{
+	if (pin < GPIO_MAX) {
+		if ((mode & GPIO_INPUT_OK) && !test_bit(pin, gpio_valid_input))
+			goto err_out;
+		if ((mode & GPIO_OUTPUT_OK) && !test_bit(pin, gpio_valid_output))
+			goto err_out;
+		return true;
+	}
 
-	return 0;
+err_out:
+	pr_debug("%s: invalid GPIO %d\n", __func__, pin);
+	return false;
 }
-EXPORT_SYMBOL(gpio_direction_input);
 
-int gpio_direction_output(unsigned pin, int value)
+/*
+ * GENERIC_GPIO primitives.
+ */
+static int orion_gpio_direction_input(struct gpio_chip *chip, unsigned pin)
 {
 	unsigned long flags;
-	u32 u;
 
-	if (pin >= GPIO_MAX || !test_bit(pin, gpio_valid_output)) {
-		pr_debug("%s: invalid GPIO %d\n", __func__, pin);
+	if (!orion_gpio_is_valid(pin, GPIO_INPUT_OK))
 		return -EINVAL;
-	}
 
 	spin_lock_irqsave(&gpio_lock, flags);
 
-	/*
-	 * Some callers might not have used gpio_request(),
-	 * so flag this pin as requested now.
-	 */
-	if (gpio_label[pin] == NULL)
-		gpio_label[pin] = "?";
-
-	/*
-	 * Disable blinking.
-	 */
-	u = readl(GPIO_BLINK_EN(pin));
-	u &= ~(1 << (pin & 31));
-	writel(u, GPIO_BLINK_EN(pin));
-
-	/*
-	 * Configure GPIO output value.
-	 */
-	__set_level(pin, value);
-
-	/*
-	 * Configure GPIO direction.
-	 */
-	__set_direction(pin, 0);
+	/* Configure GPIO direction. */
+	__set_direction(pin, 1);
 
 	spin_unlock_irqrestore(&gpio_lock, flags);
 
 	return 0;
 }
-EXPORT_SYMBOL(gpio_direction_output);
 
-int gpio_get_value(unsigned pin)
+static int orion_gpio_get_value(struct gpio_chip *chip, unsigned pin)
 {
 	int val;
 
@@ -132,83 +103,75 @@ int gpio_get_value(unsigned pin)
 
 	return (val >> (pin & 31)) & 1;
 }
-EXPORT_SYMBOL(gpio_get_value);
 
-void gpio_set_value(unsigned pin, int value)
+static int orion_gpio_direction_output(struct gpio_chip *chip, unsigned pin,
+	int value)
 {
 	unsigned long flags;
-	u32 u;
+
+	if (!orion_gpio_is_valid(pin, GPIO_OUTPUT_OK))
+		return -EINVAL;
 
 	spin_lock_irqsave(&gpio_lock, flags);
 
-	/*
-	 * Disable blinking.
-	 */
-	u = readl(GPIO_BLINK_EN(pin));
-	u &= ~(1 << (pin & 31));
-	writel(u, GPIO_BLINK_EN(pin));
+	/* Disable blinking. */
+	__set_blinking(pin, 0);
 
-	/*
-	 * Configure GPIO output value.
-	 */
+	/* Configure GPIO output value. */
 	__set_level(pin, value);
 
+	/* Configure GPIO direction. */
+	__set_direction(pin, 0);
+
 	spin_unlock_irqrestore(&gpio_lock, flags);
+
+	return 0;
 }
-EXPORT_SYMBOL(gpio_set_value);
 
-int gpio_request(unsigned pin, const char *label)
+static void orion_gpio_set_value(struct gpio_chip *chip, unsigned pin,
+	int value)
 {
 	unsigned long flags;
-	int ret;
-
-	if (pin >= GPIO_MAX ||
-	    !(test_bit(pin, gpio_valid_input) ||
-	      test_bit(pin, gpio_valid_output))) {
-		pr_debug("%s: invalid GPIO %d\n", __func__, pin);
-		return -EINVAL;
-	}
 
 	spin_lock_irqsave(&gpio_lock, flags);
-	if (gpio_label[pin] == NULL) {
-		gpio_label[pin] = label ? label : "?";
-		ret = 0;
-	} else {
-		pr_debug("%s: GPIO %d already used as %s\n",
-			 __func__, pin, gpio_label[pin]);
-		ret = -EBUSY;
-	}
-	spin_unlock_irqrestore(&gpio_lock, flags);
 
-	return ret;
+	/* Configure GPIO output value. */
+	__set_level(pin, value);
+
+	spin_unlock_irqrestore(&gpio_lock, flags);
 }
-EXPORT_SYMBOL(gpio_request);
 
-void gpio_free(unsigned pin)
+static int orion_gpio_request(struct gpio_chip *chip, unsigned pin)
 {
-	if (pin >= GPIO_MAX ||
-	    !(test_bit(pin, gpio_valid_input) ||
-	      test_bit(pin, gpio_valid_output))) {
-		pr_debug("%s: invalid GPIO %d\n", __func__, pin);
-		return;
-	}
-
-	if (gpio_label[pin] == NULL)
-		pr_warning("%s: GPIO %d already freed\n", __func__, pin);
-	else
-		gpio_label[pin] = NULL;
+	if (orion_gpio_is_valid(pin, GPIO_INPUT_OK) ||
+	    orion_gpio_is_valid(pin, GPIO_OUTPUT_OK))
+		return 0;
+	return -EINVAL;
 }
-EXPORT_SYMBOL(gpio_free);
 
+static struct gpio_chip orion_gpiochip = {
+	.label			= "orion_gpio",
+	.direction_input	= orion_gpio_direction_input,
+	.get			= orion_gpio_get_value,
+	.direction_output	= orion_gpio_direction_output,
+	.set			= orion_gpio_set_value,
+	.request		= orion_gpio_request,
+	.base			= 0,
+	.ngpio			= GPIO_MAX,
+	.can_sleep		= 0,
+};
+
+void __init orion_gpio_init(void)
+{
+	gpiochip_add(&orion_gpiochip);
+}
 
 /*
  * Orion-specific GPIO API extensions.
  */
 void __init orion_gpio_set_unused(unsigned pin)
 {
-	/*
-	 * Configure as output, drive low.
-	 */
+	/* Configure as output, drive low. */
 	__set_level(pin, 0);
 	__set_direction(pin, 0);
 }
@@ -230,21 +193,14 @@ void __init orion_gpio_set_valid(unsigned pin, int mode)
 void orion_gpio_set_blink(unsigned pin, int blink)
 {
 	unsigned long flags;
-	u32 u;
 
 	spin_lock_irqsave(&gpio_lock, flags);
 
-	/*
-	 * Set output value to zero.
-	 */
+	/* Set output value to zero. */
 	__set_level(pin, 0);
 
-	u = readl(GPIO_BLINK_EN(pin));
-	if (blink)
-		u |= 1 << (pin & 31);
-	else
-		u &= ~(1 << (pin & 31));
-	writel(u, GPIO_BLINK_EN(pin));
+	/* Set blinking. */
+	__set_blinking(pin, blink);
 
 	spin_unlock_irqrestore(&gpio_lock, flags);
 }
@@ -368,7 +324,7 @@ static int gpio_irq_set_type(u32 irq, u32 type)
 }
 
 struct irq_chip orion_gpio_irq_chip = {
-	.name		= "orion_gpio",
+	.name		= "orion_gpio_irq",
 	.ack		= gpio_irq_ack,
 	.mask		= gpio_irq_mask,
 	.unmask		= gpio_irq_unmask,

commit 28d27cf4ce8378180eda32aa7d8e778c9e72a54f
Author: Nicolas Pitre <nico@cam.org>
Date:   Mon Feb 2 15:27:55 2009 -0500

    [ARM] Orion: make gpio /input/output validation separate
    
    Especially on Kirkwood, a couple GPIOs are actually only output capable.
    Let's separate the ability to configure a GPIO as input or output to
    accommodate this restriction.
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index 0d12c2164766..32eb9e33bebb 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -19,7 +19,8 @@
 
 static DEFINE_SPINLOCK(gpio_lock);
 static const char *gpio_label[GPIO_MAX];  /* non null for allocated GPIOs */
-static unsigned long gpio_valid[BITS_TO_LONGS(GPIO_MAX)];
+static unsigned long gpio_valid_input[BITS_TO_LONGS(GPIO_MAX)];
+static unsigned long gpio_valid_output[BITS_TO_LONGS(GPIO_MAX)];
 
 static inline void __set_direction(unsigned pin, int input)
 {
@@ -53,7 +54,7 @@ int gpio_direction_input(unsigned pin)
 {
 	unsigned long flags;
 
-	if (pin >= GPIO_MAX || !test_bit(pin, gpio_valid)) {
+	if (pin >= GPIO_MAX || !test_bit(pin, gpio_valid_input)) {
 		pr_debug("%s: invalid GPIO %d\n", __func__, pin);
 		return -EINVAL;
 	}
@@ -83,7 +84,7 @@ int gpio_direction_output(unsigned pin, int value)
 	unsigned long flags;
 	u32 u;
 
-	if (pin >= GPIO_MAX || !test_bit(pin, gpio_valid)) {
+	if (pin >= GPIO_MAX || !test_bit(pin, gpio_valid_output)) {
 		pr_debug("%s: invalid GPIO %d\n", __func__, pin);
 		return -EINVAL;
 	}
@@ -161,7 +162,9 @@ int gpio_request(unsigned pin, const char *label)
 	unsigned long flags;
 	int ret;
 
-	if (pin >= GPIO_MAX || !test_bit(pin, gpio_valid)) {
+	if (pin >= GPIO_MAX ||
+	    !(test_bit(pin, gpio_valid_input) ||
+	      test_bit(pin, gpio_valid_output))) {
 		pr_debug("%s: invalid GPIO %d\n", __func__, pin);
 		return -EINVAL;
 	}
@@ -183,7 +186,9 @@ EXPORT_SYMBOL(gpio_request);
 
 void gpio_free(unsigned pin)
 {
-	if (pin >= GPIO_MAX || !test_bit(pin, gpio_valid)) {
+	if (pin >= GPIO_MAX ||
+	    !(test_bit(pin, gpio_valid_input) ||
+	      test_bit(pin, gpio_valid_output))) {
 		pr_debug("%s: invalid GPIO %d\n", __func__, pin);
 		return;
 	}
@@ -208,12 +213,18 @@ void __init orion_gpio_set_unused(unsigned pin)
 	__set_direction(pin, 0);
 }
 
-void __init orion_gpio_set_valid(unsigned pin, int valid)
+void __init orion_gpio_set_valid(unsigned pin, int mode)
 {
-	if (valid)
-		__set_bit(pin, gpio_valid);
+	if (mode == 1)
+		mode = GPIO_INPUT_OK | GPIO_OUTPUT_OK;
+	if (mode & GPIO_INPUT_OK)
+		__set_bit(pin, gpio_valid_input);
 	else
-		__clear_bit(pin, gpio_valid);
+		__clear_bit(pin, gpio_valid_input);
+	if (mode & GPIO_OUTPUT_OK)
+		__set_bit(pin, gpio_valid_output);
+	else
+		__clear_bit(pin, gpio_valid_output);
 }
 
 void orion_gpio_set_blink(unsigned pin, int blink)

commit fd4b9b3650076ffadbdd6e360eb198f5d61747c0
Author: Nicolas Pitre <nico@cam.org>
Date:   Tue Feb 17 20:45:50 2009 +0100

    [ARM] 5401/1: Orion: fix edge triggered GPIO interrupt support
    
    The GPIO interrupts can be configured as either level triggered or edge
    triggered, with a default of level triggered.  When an edge triggered
    interrupt is requested, the gpio_irq_set_type method is called which
    currently switches the given IRQ descriptor between two struct irq_chip
    instances: orion_gpio_irq_level_chip and orion_gpio_irq_edge_chip. This
    happens via __setup_irq() which also calls irq_chip_set_defaults() to
    assign default methods to uninitialized ones.  The problem is that
    irq_chip_set_defaults() is called before the irq_chip reference is
    switched, leaving the new irq_chip (orion_gpio_irq_edge_chip in this
    case) with uninitialized methods such as chip->startup() causing a kernel
    oops.
    
    Many solutions are possible, such as making irq_chip_set_defaults() global
    and calling it from gpio_irq_set_type(), or calling __irq_set_trigger()
    before irq_chip_set_defaults() in __setup_irq().  But those require
    modifications to the generic IRQ code which might have adverse effect on
    other architectures, and that would still be a fragile arrangement.
    Manually copying the missing methods from within gpio_irq_set_type()
    would be really ugly and it would break again the day new methods with
    automatic defaults are added.
    
    A better solution is to have a single irq_chip instance which can deal
    with both edge and level triggered interrupts.  It is also a good idea
    to switch the IRQ handler instead, as the edge IRQ handler allows for
    one edge IRQ event to be queued as the IRQ is actually masked only when
    that second IRQ is received, at which point the hardware can queue an
    additional IRQ event, making edge triggered interrupts a bit more
    reliable.
    
    Tested-by: Martin Michlmayr <tbm@cyrius.com>
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index 967186425ca1..0d12c2164766 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -265,51 +265,36 @@ EXPORT_SYMBOL(orion_gpio_set_blink);
  *        polarity    LEVEL          mask
  *
  ****************************************************************************/
-static void gpio_irq_edge_ack(u32 irq)
-{
-	int pin = irq_to_gpio(irq);
-
-	writel(~(1 << (pin & 31)), GPIO_EDGE_CAUSE(pin));
-}
-
-static void gpio_irq_edge_mask(u32 irq)
-{
-	int pin = irq_to_gpio(irq);
-	u32 u;
-
-	u = readl(GPIO_EDGE_MASK(pin));
-	u &= ~(1 << (pin & 31));
-	writel(u, GPIO_EDGE_MASK(pin));
-}
 
-static void gpio_irq_edge_unmask(u32 irq)
+static void gpio_irq_ack(u32 irq)
 {
-	int pin = irq_to_gpio(irq);
-	u32 u;
-
-	u = readl(GPIO_EDGE_MASK(pin));
-	u |= 1 << (pin & 31);
-	writel(u, GPIO_EDGE_MASK(pin));
+	int type = irq_desc[irq].status & IRQ_TYPE_SENSE_MASK;
+	if (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) {
+		int pin = irq_to_gpio(irq);
+		writel(~(1 << (pin & 31)), GPIO_EDGE_CAUSE(pin));
+	}
 }
 
-static void gpio_irq_level_mask(u32 irq)
+static void gpio_irq_mask(u32 irq)
 {
 	int pin = irq_to_gpio(irq);
-	u32 u;
-
-	u = readl(GPIO_LEVEL_MASK(pin));
+	int type = irq_desc[irq].status & IRQ_TYPE_SENSE_MASK;
+	u32 reg = (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) ?
+		GPIO_EDGE_MASK(pin) : GPIO_LEVEL_MASK(pin);
+	u32 u = readl(reg);
 	u &= ~(1 << (pin & 31));
-	writel(u, GPIO_LEVEL_MASK(pin));
+	writel(u, reg);
 }
 
-static void gpio_irq_level_unmask(u32 irq)
+static void gpio_irq_unmask(u32 irq)
 {
 	int pin = irq_to_gpio(irq);
-	u32 u;
-
-	u = readl(GPIO_LEVEL_MASK(pin));
+	int type = irq_desc[irq].status & IRQ_TYPE_SENSE_MASK;
+	u32 reg = (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) ?
+		GPIO_EDGE_MASK(pin) : GPIO_LEVEL_MASK(pin);
+	u32 u = readl(reg);
 	u |= 1 << (pin & 31);
-	writel(u, GPIO_LEVEL_MASK(pin));
+	writel(u, reg);
 }
 
 static int gpio_irq_set_type(u32 irq, u32 type)
@@ -331,9 +316,9 @@ static int gpio_irq_set_type(u32 irq, u32 type)
 	 * Set edge/level type.
 	 */
 	if (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) {
-		desc->chip = &orion_gpio_irq_edge_chip;
+		desc->handle_irq = handle_edge_irq;
 	} else if (type & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) {
-		desc->chip = &orion_gpio_irq_level_chip;
+		desc->handle_irq = handle_level_irq;
 	} else {
 		printk(KERN_ERR "failed to set irq=%d (type=%d)\n", irq, type);
 		return -EINVAL;
@@ -371,19 +356,11 @@ static int gpio_irq_set_type(u32 irq, u32 type)
 	return 0;
 }
 
-struct irq_chip orion_gpio_irq_edge_chip = {
-	.name		= "orion_gpio_irq_edge",
-	.ack		= gpio_irq_edge_ack,
-	.mask		= gpio_irq_edge_mask,
-	.unmask		= gpio_irq_edge_unmask,
-	.set_type	= gpio_irq_set_type,
-};
-
-struct irq_chip orion_gpio_irq_level_chip = {
-	.name		= "orion_gpio_irq_level",
-	.mask		= gpio_irq_level_mask,
-	.mask_ack	= gpio_irq_level_mask,
-	.unmask		= gpio_irq_level_unmask,
+struct irq_chip orion_gpio_irq_chip = {
+	.name		= "orion_gpio",
+	.ack		= gpio_irq_ack,
+	.mask		= gpio_irq_mask,
+	.unmask		= gpio_irq_unmask,
 	.set_type	= gpio_irq_set_type,
 };
 

commit 07332318f33da6acd88abb762a8b6febdfc560a3
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Mon Oct 20 01:51:03 2008 +0200

    [ARM] Orion: share GPIO IRQ handling code
    
    Split off Orion GPIO IRQ handling code into plat-orion/.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Signed-off-by: Nicolas Pitre <nico@marvell.com>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
index d86fc085e489..967186425ca1 100644
--- a/arch/arm/plat-orion/gpio.c
+++ b/arch/arm/plat-orion/gpio.c
@@ -10,6 +10,7 @@
 
 #include <linux/kernel.h>
 #include <linux/init.h>
+#include <linux/irq.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
 #include <linux/bitops.h>
@@ -237,3 +238,178 @@ void orion_gpio_set_blink(unsigned pin, int blink)
 	spin_unlock_irqrestore(&gpio_lock, flags);
 }
 EXPORT_SYMBOL(orion_gpio_set_blink);
+
+
+/*****************************************************************************
+ * Orion GPIO IRQ
+ *
+ * GPIO_IN_POL register controls whether GPIO_DATA_IN will hold the same
+ * value of the line or the opposite value.
+ *
+ * Level IRQ handlers: DATA_IN is used directly as cause register.
+ *                     Interrupt are masked by LEVEL_MASK registers.
+ * Edge IRQ handlers:  Change in DATA_IN are latched in EDGE_CAUSE.
+ *                     Interrupt are masked by EDGE_MASK registers.
+ * Both-edge handlers: Similar to regular Edge handlers, but also swaps
+ *                     the polarity to catch the next line transaction.
+ *                     This is a race condition that might not perfectly
+ *                     work on some use cases.
+ *
+ * Every eight GPIO lines are grouped (OR'ed) before going up to main
+ * cause register.
+ *
+ *                    EDGE  cause    mask
+ *        data-in   /--------| |-----| |----\
+ *     -----| |-----                         ---- to main cause reg
+ *           X      \----------------| |----/
+ *        polarity    LEVEL          mask
+ *
+ ****************************************************************************/
+static void gpio_irq_edge_ack(u32 irq)
+{
+	int pin = irq_to_gpio(irq);
+
+	writel(~(1 << (pin & 31)), GPIO_EDGE_CAUSE(pin));
+}
+
+static void gpio_irq_edge_mask(u32 irq)
+{
+	int pin = irq_to_gpio(irq);
+	u32 u;
+
+	u = readl(GPIO_EDGE_MASK(pin));
+	u &= ~(1 << (pin & 31));
+	writel(u, GPIO_EDGE_MASK(pin));
+}
+
+static void gpio_irq_edge_unmask(u32 irq)
+{
+	int pin = irq_to_gpio(irq);
+	u32 u;
+
+	u = readl(GPIO_EDGE_MASK(pin));
+	u |= 1 << (pin & 31);
+	writel(u, GPIO_EDGE_MASK(pin));
+}
+
+static void gpio_irq_level_mask(u32 irq)
+{
+	int pin = irq_to_gpio(irq);
+	u32 u;
+
+	u = readl(GPIO_LEVEL_MASK(pin));
+	u &= ~(1 << (pin & 31));
+	writel(u, GPIO_LEVEL_MASK(pin));
+}
+
+static void gpio_irq_level_unmask(u32 irq)
+{
+	int pin = irq_to_gpio(irq);
+	u32 u;
+
+	u = readl(GPIO_LEVEL_MASK(pin));
+	u |= 1 << (pin & 31);
+	writel(u, GPIO_LEVEL_MASK(pin));
+}
+
+static int gpio_irq_set_type(u32 irq, u32 type)
+{
+	int pin = irq_to_gpio(irq);
+	struct irq_desc *desc;
+	u32 u;
+
+	u = readl(GPIO_IO_CONF(pin)) & (1 << (pin & 31));
+	if (!u) {
+		printk(KERN_ERR "orion gpio_irq_set_type failed "
+				"(irq %d, pin %d).\n", irq, pin);
+		return -EINVAL;
+	}
+
+	desc = irq_desc + irq;
+
+	/*
+	 * Set edge/level type.
+	 */
+	if (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) {
+		desc->chip = &orion_gpio_irq_edge_chip;
+	} else if (type & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) {
+		desc->chip = &orion_gpio_irq_level_chip;
+	} else {
+		printk(KERN_ERR "failed to set irq=%d (type=%d)\n", irq, type);
+		return -EINVAL;
+	}
+
+	/*
+	 * Configure interrupt polarity.
+	 */
+	if (type == IRQ_TYPE_EDGE_RISING || type == IRQ_TYPE_LEVEL_HIGH) {
+		u = readl(GPIO_IN_POL(pin));
+		u &= ~(1 << (pin & 31));
+		writel(u, GPIO_IN_POL(pin));
+	} else if (type == IRQ_TYPE_EDGE_FALLING || type == IRQ_TYPE_LEVEL_LOW) {
+		u = readl(GPIO_IN_POL(pin));
+		u |= 1 << (pin & 31);
+		writel(u, GPIO_IN_POL(pin));
+	} else if (type == IRQ_TYPE_EDGE_BOTH) {
+		u32 v;
+
+		v = readl(GPIO_IN_POL(pin)) ^ readl(GPIO_DATA_IN(pin));
+
+		/*
+		 * set initial polarity based on current input level
+		 */
+		u = readl(GPIO_IN_POL(pin));
+		if (v & (1 << (pin & 31)))
+			u |= 1 << (pin & 31);		/* falling */
+		else
+			u &= ~(1 << (pin & 31));	/* rising */
+		writel(u, GPIO_IN_POL(pin));
+	}
+
+	desc->status = (desc->status & ~IRQ_TYPE_SENSE_MASK) | type;
+
+	return 0;
+}
+
+struct irq_chip orion_gpio_irq_edge_chip = {
+	.name		= "orion_gpio_irq_edge",
+	.ack		= gpio_irq_edge_ack,
+	.mask		= gpio_irq_edge_mask,
+	.unmask		= gpio_irq_edge_unmask,
+	.set_type	= gpio_irq_set_type,
+};
+
+struct irq_chip orion_gpio_irq_level_chip = {
+	.name		= "orion_gpio_irq_level",
+	.mask		= gpio_irq_level_mask,
+	.mask_ack	= gpio_irq_level_mask,
+	.unmask		= gpio_irq_level_unmask,
+	.set_type	= gpio_irq_set_type,
+};
+
+void orion_gpio_irq_handler(int pinoff)
+{
+	u32 cause;
+	int pin;
+
+	cause = readl(GPIO_DATA_IN(pinoff)) & readl(GPIO_LEVEL_MASK(pinoff));
+	cause |= readl(GPIO_EDGE_CAUSE(pinoff)) & readl(GPIO_EDGE_MASK(pinoff));
+
+	for (pin = pinoff; pin < pinoff + 8; pin++) {
+		int irq = gpio_to_irq(pin);
+		struct irq_desc *desc = irq_desc + irq;
+
+		if (!(cause & (1 << (pin & 31))))
+			continue;
+
+		if ((desc->status & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {
+			/* Swap polarity (race with GPIO line) */
+			u32 polarity;
+
+			polarity = readl(GPIO_IN_POL(pin));
+			polarity ^= 1 << (pin & 31);
+			writel(polarity, GPIO_IN_POL(pin));
+		}
+		desc_handle_irq(irq, desc);
+	}
+}

commit 9569dae75f6f6987e79fa26cf6da3fc24006c996
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Mon Oct 20 01:51:03 2008 +0200

    [ARM] Orion: share GPIO handling code
    
    Split off Orion GPIO handling code into plat-orion/, and add
    support for multiple sets of (32) GPIO pins.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Signed-off-by: Nicolas Pitre <nico@marvell.com>

diff --git a/arch/arm/plat-orion/gpio.c b/arch/arm/plat-orion/gpio.c
new file mode 100644
index 000000000000..d86fc085e489
--- /dev/null
+++ b/arch/arm/plat-orion/gpio.c
@@ -0,0 +1,239 @@
+/*
+ * arch/arm/plat-orion/gpio.c
+ *
+ * Marvell Orion SoC GPIO handling.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/bitops.h>
+#include <linux/io.h>
+#include <asm/gpio.h>
+
+static DEFINE_SPINLOCK(gpio_lock);
+static const char *gpio_label[GPIO_MAX];  /* non null for allocated GPIOs */
+static unsigned long gpio_valid[BITS_TO_LONGS(GPIO_MAX)];
+
+static inline void __set_direction(unsigned pin, int input)
+{
+	u32 u;
+
+	u = readl(GPIO_IO_CONF(pin));
+	if (input)
+		u |= 1 << (pin & 31);
+	else
+		u &= ~(1 << (pin & 31));
+	writel(u, GPIO_IO_CONF(pin));
+}
+
+static void __set_level(unsigned pin, int high)
+{
+	u32 u;
+
+	u = readl(GPIO_OUT(pin));
+	if (high)
+		u |= 1 << (pin & 31);
+	else
+		u &= ~(1 << (pin & 31));
+	writel(u, GPIO_OUT(pin));
+}
+
+
+/*
+ * GENERIC_GPIO primitives.
+ */
+int gpio_direction_input(unsigned pin)
+{
+	unsigned long flags;
+
+	if (pin >= GPIO_MAX || !test_bit(pin, gpio_valid)) {
+		pr_debug("%s: invalid GPIO %d\n", __func__, pin);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&gpio_lock, flags);
+
+	/*
+	 * Some callers might not have used gpio_request(),
+	 * so flag this pin as requested now.
+	 */
+	if (gpio_label[pin] == NULL)
+		gpio_label[pin] = "?";
+
+	/*
+	 * Configure GPIO direction.
+	 */
+	__set_direction(pin, 1);
+
+	spin_unlock_irqrestore(&gpio_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_direction_input);
+
+int gpio_direction_output(unsigned pin, int value)
+{
+	unsigned long flags;
+	u32 u;
+
+	if (pin >= GPIO_MAX || !test_bit(pin, gpio_valid)) {
+		pr_debug("%s: invalid GPIO %d\n", __func__, pin);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&gpio_lock, flags);
+
+	/*
+	 * Some callers might not have used gpio_request(),
+	 * so flag this pin as requested now.
+	 */
+	if (gpio_label[pin] == NULL)
+		gpio_label[pin] = "?";
+
+	/*
+	 * Disable blinking.
+	 */
+	u = readl(GPIO_BLINK_EN(pin));
+	u &= ~(1 << (pin & 31));
+	writel(u, GPIO_BLINK_EN(pin));
+
+	/*
+	 * Configure GPIO output value.
+	 */
+	__set_level(pin, value);
+
+	/*
+	 * Configure GPIO direction.
+	 */
+	__set_direction(pin, 0);
+
+	spin_unlock_irqrestore(&gpio_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_direction_output);
+
+int gpio_get_value(unsigned pin)
+{
+	int val;
+
+	if (readl(GPIO_IO_CONF(pin)) & (1 << (pin & 31)))
+		val = readl(GPIO_DATA_IN(pin)) ^ readl(GPIO_IN_POL(pin));
+	else
+		val = readl(GPIO_OUT(pin));
+
+	return (val >> (pin & 31)) & 1;
+}
+EXPORT_SYMBOL(gpio_get_value);
+
+void gpio_set_value(unsigned pin, int value)
+{
+	unsigned long flags;
+	u32 u;
+
+	spin_lock_irqsave(&gpio_lock, flags);
+
+	/*
+	 * Disable blinking.
+	 */
+	u = readl(GPIO_BLINK_EN(pin));
+	u &= ~(1 << (pin & 31));
+	writel(u, GPIO_BLINK_EN(pin));
+
+	/*
+	 * Configure GPIO output value.
+	 */
+	__set_level(pin, value);
+
+	spin_unlock_irqrestore(&gpio_lock, flags);
+}
+EXPORT_SYMBOL(gpio_set_value);
+
+int gpio_request(unsigned pin, const char *label)
+{
+	unsigned long flags;
+	int ret;
+
+	if (pin >= GPIO_MAX || !test_bit(pin, gpio_valid)) {
+		pr_debug("%s: invalid GPIO %d\n", __func__, pin);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&gpio_lock, flags);
+	if (gpio_label[pin] == NULL) {
+		gpio_label[pin] = label ? label : "?";
+		ret = 0;
+	} else {
+		pr_debug("%s: GPIO %d already used as %s\n",
+			 __func__, pin, gpio_label[pin]);
+		ret = -EBUSY;
+	}
+	spin_unlock_irqrestore(&gpio_lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(gpio_request);
+
+void gpio_free(unsigned pin)
+{
+	if (pin >= GPIO_MAX || !test_bit(pin, gpio_valid)) {
+		pr_debug("%s: invalid GPIO %d\n", __func__, pin);
+		return;
+	}
+
+	if (gpio_label[pin] == NULL)
+		pr_warning("%s: GPIO %d already freed\n", __func__, pin);
+	else
+		gpio_label[pin] = NULL;
+}
+EXPORT_SYMBOL(gpio_free);
+
+
+/*
+ * Orion-specific GPIO API extensions.
+ */
+void __init orion_gpio_set_unused(unsigned pin)
+{
+	/*
+	 * Configure as output, drive low.
+	 */
+	__set_level(pin, 0);
+	__set_direction(pin, 0);
+}
+
+void __init orion_gpio_set_valid(unsigned pin, int valid)
+{
+	if (valid)
+		__set_bit(pin, gpio_valid);
+	else
+		__clear_bit(pin, gpio_valid);
+}
+
+void orion_gpio_set_blink(unsigned pin, int blink)
+{
+	unsigned long flags;
+	u32 u;
+
+	spin_lock_irqsave(&gpio_lock, flags);
+
+	/*
+	 * Set output value to zero.
+	 */
+	__set_level(pin, 0);
+
+	u = readl(GPIO_BLINK_EN(pin));
+	if (blink)
+		u |= 1 << (pin & 31);
+	else
+		u &= ~(1 << (pin & 31));
+	writel(u, GPIO_BLINK_EN(pin));
+
+	spin_unlock_irqrestore(&gpio_lock, flags);
+}
+EXPORT_SYMBOL(orion_gpio_set_blink);
