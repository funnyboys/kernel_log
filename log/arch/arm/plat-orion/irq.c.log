commit b8cd337c8e0330f4a29b3d1f69b7c73b324b1f8d
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Dec 2 22:27:04 2015 +0100

    ARM: orion: always use MULTI_IRQ_HANDLER
    
    As a preparation for multiplatform support, this enables
    the MULTI_IRQ_HANDLER code unconditionally on dove and
    orion5x, and introduces the respective code on mv78xx0,
    which did not have it so far. The classic entry-macro.S
    files are removed as they are now obsolete.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/plat-orion/irq.c b/arch/arm/plat-orion/irq.c
index 8c1fc06007c0..5b63b28b00ac 100644
--- a/arch/arm/plat-orion/irq.c
+++ b/arch/arm/plat-orion/irq.c
@@ -18,7 +18,6 @@
 #include <asm/exception.h>
 #include <plat/irq.h>
 #include <plat/orion-gpio.h>
-#include <mach/bridge-regs.h>
 
 void __init orion_irq_init(unsigned int irq_start, void __iomem *maskaddr)
 {

commit 880ff3e2255c05bac0d2010719da42a26fdbb185
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Tue Apr 22 23:26:41 2014 +0200

    ARM: orion: remove no longer needed DT IRQ code
    
    Following the move of the Orion5x Device Tree support to use
    irqchip_init() for the interrupt controller probing, the
    plat-orion/irq.c code for DT-probing of the interrupt controller is no
    longer necessary, so we can get rid of it.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Link: https://lkml.kernel.org/r/1398202002-28530-38-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/plat-orion/irq.c b/arch/arm/plat-orion/irq.c
index 27ec18b53595..8c1fc06007c0 100644
--- a/arch/arm/plat-orion/irq.c
+++ b/arch/arm/plat-orion/irq.c
@@ -38,35 +38,3 @@ void __init orion_irq_init(unsigned int irq_start, void __iomem *maskaddr)
 	irq_setup_generic_chip(gc, IRQ_MSK(32), IRQ_GC_INIT_MASK_CACHE,
 			       IRQ_NOREQUEST, IRQ_LEVEL | IRQ_NOPROBE);
 }
-
-#ifdef CONFIG_OF
-static int __init orion_add_irq_domain(struct device_node *np,
-				       struct device_node *interrupt_parent)
-{
-	int i = 0;
-	void __iomem *base;
-
-	do {
-		base = of_iomap(np, i);
-		if (base) {
-			orion_irq_init(i * 32, base + 0x04);
-			i++;
-		}
-	} while (base);
-
-	irq_domain_add_legacy(np, i * 32, 0, 0,
-			      &irq_domain_simple_ops, NULL);
-	return 0;
-}
-
-static const struct of_device_id orion_irq_match[] = {
-	{ .compatible = "marvell,orion-intc",
-	  .data = orion_add_irq_domain, },
-	{},
-};
-
-void __init orion_dt_init_irq(void)
-{
-	of_irq_init(orion_irq_match);
-}
-#endif

commit deac3d874ea1e1ef50604cec33ddfb01edb0c976
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Tue Apr 22 23:26:26 2014 +0200

    ARM: orion: switch to a per-platform handle_irq() function
    
    Moving to the Device Tree implies having CONFIG_MULTI_IRQ_HANDLER
    enabled, even for non-DT platforms (if we want both DT and non-DT
    platforms to be supported in a single kernel).
    
    However, the common CONFIG_MULTI_IRQ_HANDLER handler for non-DT
    platforms in plat-orion/irq.c doesn't match the needs of
    Orion5x. Also, it doesn't make much sense for orion_irq_init() to
    register the multi-IRQ handler: orion_irq_init() is called once for
    each IRQ cause/mask tuple, while the multi-IRQ handler only needs to
    be registered once.
    
    To solve this problem, we move the multi-IRQ handle in per-platform
    code: mach-kirkwood/irq.c and mach-dove/irq.c. The Orion5x variant
    will be introduced in a followup commit. Of course, this code will
    ultimately be completely removed once all boards are converted to the
    Device Tree.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Link: https://lkml.kernel.org/r/1398202002-28530-23-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/plat-orion/irq.c b/arch/arm/plat-orion/irq.c
index 807df142444b..27ec18b53595 100644
--- a/arch/arm/plat-orion/irq.c
+++ b/arch/arm/plat-orion/irq.c
@@ -20,47 +20,6 @@
 #include <plat/orion-gpio.h>
 #include <mach/bridge-regs.h>
 
-#ifdef CONFIG_MULTI_IRQ_HANDLER
-/*
- * Compiling with both non-DT and DT support enabled, will
- * break asm irq handler used by non-DT boards. Therefore,
- * we provide a C-style irq handler even for non-DT boards,
- * if MULTI_IRQ_HANDLER is set.
- *
- * Notes:
- * - this is prepared for Kirkwood and Dove only, update
- *   accordingly if you add Orion5x or MV78x00.
- * - Orion5x uses different macro names and has only one
- *   set of CAUSE/MASK registers.
- * - MV78x00 uses the same macro names but has a third
- *   set of CAUSE/MASK registers.
- *
- */
-
-static void __iomem *orion_irq_base = IRQ_VIRT_BASE;
-
-asmlinkage void
-__exception_irq_entry orion_legacy_handle_irq(struct pt_regs *regs)
-{
-	u32 stat;
-
-	stat = readl_relaxed(orion_irq_base + IRQ_CAUSE_LOW_OFF);
-	stat &= readl_relaxed(orion_irq_base + IRQ_MASK_LOW_OFF);
-	if (stat) {
-		unsigned int hwirq = __fls(stat);
-		handle_IRQ(hwirq, regs);
-		return;
-	}
-	stat = readl_relaxed(orion_irq_base + IRQ_CAUSE_HIGH_OFF);
-	stat &= readl_relaxed(orion_irq_base + IRQ_MASK_HIGH_OFF);
-	if (stat) {
-		unsigned int hwirq = 32 + __fls(stat);
-		handle_IRQ(hwirq, regs);
-		return;
-	}
-}
-#endif
-
 void __init orion_irq_init(unsigned int irq_start, void __iomem *maskaddr)
 {
 	struct irq_chip_generic *gc;
@@ -78,10 +37,6 @@ void __init orion_irq_init(unsigned int irq_start, void __iomem *maskaddr)
 	ct->chip.irq_unmask = irq_gc_mask_set_bit;
 	irq_setup_generic_chip(gc, IRQ_MSK(32), IRQ_GC_INIT_MASK_CACHE,
 			       IRQ_NOREQUEST, IRQ_LEVEL | IRQ_NOPROBE);
-
-#ifdef CONFIG_MULTI_IRQ_HANDLER
-	set_handle_irq(orion_legacy_handle_irq);
-#endif
 }
 
 #ifdef CONFIG_OF

commit f28d7de6bd4d41774744e011141945affa127da4
Author: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
Date:   Thu Jan 16 09:10:31 2014 +0100

    ARM: orion: provide C-style interrupt handler for MULTI_IRQ_HANDLER
    
    DT-enabled Marvell Kirkwood and Dove SoCs make use of an irqchip
    driver. As expected for irqchip drivers, it uses a C-style
    interrupt handler and therefore selects MULTI_IRQ_HANDLER.
    
    Now, compiling a kernel with both non-DT and DT support enabled,
    selecting MULTI_IRQ_HANDLER will break ASM irq handler used by
    non-DT boards.
    
    Therefore, we provide a C-style irq handler even for non-DT boards,
    if MULTI_IRQ_HANDLER is set. By installing the C-style irq handler
    in orion_irq_init this is transparent to all non-DT board files.
    
    While the regression report was filed on Marvell Kirkwood, also
    Marvell Dove non-DT boards are affected and fixed by this patch.
    
    Signed-off-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Tested-by: Ian Campbell <ijc@hellion.org.uk>
    Reported-by: Ian Campbell <ijc@hellion.org.uk>
    Cc: <stable@vger.kernel.org> # v3.12+
    Fixes: 2326f04321a9 ("ARM: kirkwood: convert to DT irqchip and clocksource")
    Fixes: f07d73e33d0e ("ARM: dove: convert to DT irqchip and clocksource")
    Acked-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/plat-orion/irq.c b/arch/arm/plat-orion/irq.c
index c492e1b3dfdb..807df142444b 100644
--- a/arch/arm/plat-orion/irq.c
+++ b/arch/arm/plat-orion/irq.c
@@ -15,8 +15,51 @@
 #include <linux/io.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
+#include <asm/exception.h>
 #include <plat/irq.h>
 #include <plat/orion-gpio.h>
+#include <mach/bridge-regs.h>
+
+#ifdef CONFIG_MULTI_IRQ_HANDLER
+/*
+ * Compiling with both non-DT and DT support enabled, will
+ * break asm irq handler used by non-DT boards. Therefore,
+ * we provide a C-style irq handler even for non-DT boards,
+ * if MULTI_IRQ_HANDLER is set.
+ *
+ * Notes:
+ * - this is prepared for Kirkwood and Dove only, update
+ *   accordingly if you add Orion5x or MV78x00.
+ * - Orion5x uses different macro names and has only one
+ *   set of CAUSE/MASK registers.
+ * - MV78x00 uses the same macro names but has a third
+ *   set of CAUSE/MASK registers.
+ *
+ */
+
+static void __iomem *orion_irq_base = IRQ_VIRT_BASE;
+
+asmlinkage void
+__exception_irq_entry orion_legacy_handle_irq(struct pt_regs *regs)
+{
+	u32 stat;
+
+	stat = readl_relaxed(orion_irq_base + IRQ_CAUSE_LOW_OFF);
+	stat &= readl_relaxed(orion_irq_base + IRQ_MASK_LOW_OFF);
+	if (stat) {
+		unsigned int hwirq = __fls(stat);
+		handle_IRQ(hwirq, regs);
+		return;
+	}
+	stat = readl_relaxed(orion_irq_base + IRQ_CAUSE_HIGH_OFF);
+	stat &= readl_relaxed(orion_irq_base + IRQ_MASK_HIGH_OFF);
+	if (stat) {
+		unsigned int hwirq = 32 + __fls(stat);
+		handle_IRQ(hwirq, regs);
+		return;
+	}
+}
+#endif
 
 void __init orion_irq_init(unsigned int irq_start, void __iomem *maskaddr)
 {
@@ -35,6 +78,10 @@ void __init orion_irq_init(unsigned int irq_start, void __iomem *maskaddr)
 	ct->chip.irq_unmask = irq_gc_mask_set_bit;
 	irq_setup_generic_chip(gc, IRQ_MSK(32), IRQ_GC_INIT_MASK_CACHE,
 			       IRQ_NOREQUEST, IRQ_LEVEL | IRQ_NOPROBE);
+
+#ifdef CONFIG_MULTI_IRQ_HANDLER
+	set_handle_irq(orion_legacy_handle_irq);
+#endif
 }
 
 #ifdef CONFIG_OF

commit fa8c5a811e0e7c3e1c49b2e58fcb4db549b5719a
Author: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
Date:   Tue Jul 2 13:03:43 2013 +0200

    ARM: plat-orion: add reg offset to DT irq driver stub
    
    With irqchip driver for Orion SoCs, reg layout of orion-intc has changed.
    This updates irq driver stub implemented before to the new reg layout by
    adding an offset to the base address passed by DT node. As orion5x still
    uses this stub, it cannot be removed yet.
    
    Signed-off-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/plat-orion/irq.c b/arch/arm/plat-orion/irq.c
index 8db0b981ca64..c492e1b3dfdb 100644
--- a/arch/arm/plat-orion/irq.c
+++ b/arch/arm/plat-orion/irq.c
@@ -47,7 +47,7 @@ static int __init orion_add_irq_domain(struct device_node *np,
 	do {
 		base = of_iomap(np, i);
 		if (base) {
-			orion_irq_init(i * 32, base);
+			orion_irq_init(i * 32, base + 0x04);
 			i++;
 		}
 	} while (base);

commit f9e7592230b72acb703e6c29691d587341b6c710
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sat Nov 17 17:00:44 2012 +0100

    ARM: Kirkwood: Make use of mvebu pincltl and gpio drivers
    
    Select the generic mvebu kirkwood pincltr driver and generic mvebu
    gpio driver. This requires minor changes to the DT, and the calls to
    configure plat-orion gpio driver are removed.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Tested-by: Michael Walle <michael@walle.cc>
    Tested-by: Simon Baatz <gmbnomis@gmail.com>
    Tested-by: Jamie Lentin <jm@lentin.co.uk>
    Tested-by: Joshua Coombs <josh.coombs@gmail.com>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/plat-orion/irq.c b/arch/arm/plat-orion/irq.c
index 1867944415ca..8db0b981ca64 100644
--- a/arch/arm/plat-orion/irq.c
+++ b/arch/arm/plat-orion/irq.c
@@ -41,7 +41,7 @@ void __init orion_irq_init(unsigned int irq_start, void __iomem *maskaddr)
 static int __init orion_add_irq_domain(struct device_node *np,
 				       struct device_node *interrupt_parent)
 {
-	int i = 0, irq_gpio;
+	int i = 0;
 	void __iomem *base;
 
 	do {
@@ -54,10 +54,6 @@ static int __init orion_add_irq_domain(struct device_node *np,
 
 	irq_domain_add_legacy(np, i * 32, 0, 0,
 			      &irq_domain_simple_ops, NULL);
-
-	irq_gpio = i * 32;
-	orion_gpio_of_init(irq_gpio);
-
 	return 0;
 }
 

commit ce91574c202b8581ad15bfb1427af824f462c3d2
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Wed Aug 29 10:16:55 2012 -0500

    ARM: orion: move custom gpio functions to orion-gpio.h
    
    Move custom orion platforms gpio code to orion-gpio to remove the
    dependency on mach/gpio.h.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>

diff --git a/arch/arm/plat-orion/irq.c b/arch/arm/plat-orion/irq.c
index d751964def4c..1867944415ca 100644
--- a/arch/arm/plat-orion/irq.c
+++ b/arch/arm/plat-orion/irq.c
@@ -16,7 +16,7 @@
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
 #include <plat/irq.h>
-#include <plat/gpio.h>
+#include <plat/orion-gpio.h>
 
 void __init orion_irq_init(unsigned int irq_start, void __iomem *maskaddr)
 {

commit 278b45b06bf721b7cf5de67a0126786c60c720e6
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Jun 27 13:40:04 2012 +0200

    ARM: Orion: DT support for IRQ and GPIO Controllers
    
    Both IRQ and GPIO controllers can now be represented in DT.  The IRQ
    controllers are setup first, and then the GPIO controllers. Interrupts
    for GPIO lines are placed directly after the main interrupts in the
    interrupt space.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@googlemail.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Tested-by: Josh Coombs <josh.coombs@gmail.com>
    Tested-by: Simon Baatz <gmbnomis@gmail.com>

diff --git a/arch/arm/plat-orion/irq.c b/arch/arm/plat-orion/irq.c
index 2d5b9c1ef389..d751964def4c 100644
--- a/arch/arm/plat-orion/irq.c
+++ b/arch/arm/plat-orion/irq.c
@@ -11,8 +11,12 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/irq.h>
+#include <linux/irqdomain.h>
 #include <linux/io.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
 #include <plat/irq.h>
+#include <plat/gpio.h>
 
 void __init orion_irq_init(unsigned int irq_start, void __iomem *maskaddr)
 {
@@ -32,3 +36,39 @@ void __init orion_irq_init(unsigned int irq_start, void __iomem *maskaddr)
 	irq_setup_generic_chip(gc, IRQ_MSK(32), IRQ_GC_INIT_MASK_CACHE,
 			       IRQ_NOREQUEST, IRQ_LEVEL | IRQ_NOPROBE);
 }
+
+#ifdef CONFIG_OF
+static int __init orion_add_irq_domain(struct device_node *np,
+				       struct device_node *interrupt_parent)
+{
+	int i = 0, irq_gpio;
+	void __iomem *base;
+
+	do {
+		base = of_iomap(np, i);
+		if (base) {
+			orion_irq_init(i * 32, base);
+			i++;
+		}
+	} while (base);
+
+	irq_domain_add_legacy(np, i * 32, 0, 0,
+			      &irq_domain_simple_ops, NULL);
+
+	irq_gpio = i * 32;
+	orion_gpio_of_init(irq_gpio);
+
+	return 0;
+}
+
+static const struct of_device_id orion_irq_match[] = {
+	{ .compatible = "marvell,orion-intc",
+	  .data = orion_add_irq_domain, },
+	{},
+};
+
+void __init orion_dt_init_irq(void)
+{
+	of_irq_init(orion_irq_match);
+}
+#endif

commit e59347a1d15c0b1d9fdc510520f8fa78d7d19a5b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Apr 14 19:17:57 2011 +0200

    arm: orion: Use generic irq chip
    
    The core interrupt chip is a straight forward conversion. The gpio
    chip is implemented with two instances of the irq_chip_type which can
    be switched with the irq_set_type function. That allows us to use the
    generic callbacks and avoids the conditionals in them.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/plat-orion/irq.c b/arch/arm/plat-orion/irq.c
index d8d638e09f8f..2d5b9c1ef389 100644
--- a/arch/arm/plat-orion/irq.c
+++ b/arch/arm/plat-orion/irq.c
@@ -14,52 +14,21 @@
 #include <linux/io.h>
 #include <plat/irq.h>
 
-static void orion_irq_mask(struct irq_data *d)
-{
-	void __iomem *maskaddr = irq_data_get_irq_chip_data(d);
-	u32 mask;
-
-	mask = readl(maskaddr);
-	mask &= ~(1 << (d->irq & 31));
-	writel(mask, maskaddr);
-}
-
-static void orion_irq_unmask(struct irq_data *d)
-{
-	void __iomem *maskaddr = irq_data_get_irq_chip_data(d);
-	u32 mask;
-
-	mask = readl(maskaddr);
-	mask |= 1 << (d->irq & 31);
-	writel(mask, maskaddr);
-}
-
-static struct irq_chip orion_irq_chip = {
-	.name		= "orion_irq",
-	.irq_mask	= orion_irq_mask,
-	.irq_mask_ack	= orion_irq_mask,
-	.irq_unmask	= orion_irq_unmask,
-};
-
 void __init orion_irq_init(unsigned int irq_start, void __iomem *maskaddr)
 {
-	unsigned int i;
+	struct irq_chip_generic *gc;
+	struct irq_chip_type *ct;
 
 	/*
 	 * Mask all interrupts initially.
 	 */
 	writel(0, maskaddr);
 
-	/*
-	 * Register IRQ sources.
-	 */
-	for (i = 0; i < 32; i++) {
-		unsigned int irq = irq_start + i;
-
-		irq_set_chip_and_handler(irq, &orion_irq_chip,
-					 handle_level_irq);
-		irq_set_chip_data(irq, maskaddr);
-		irq_set_status_flags(irq, IRQ_LEVEL);
-		set_irq_flags(irq, IRQF_VALID);
-	}
+	gc = irq_alloc_generic_chip("orion_irq", 1, irq_start, maskaddr,
+				    handle_level_irq);
+	ct = gc->chip_types;
+	ct->chip.irq_mask = irq_gc_mask_clr_bit;
+	ct->chip.irq_unmask = irq_gc_mask_set_bit;
+	irq_setup_generic_chip(gc, IRQ_MSK(32), IRQ_GC_INIT_MASK_CACHE,
+			       IRQ_NOREQUEST, IRQ_LEVEL | IRQ_NOPROBE);
 }

commit f38c02f3b338651e145aac2889ba976baf6b28b3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 13:35:09 2011 +0100

    arm: Fold irq_set_chip/irq_set_handler
    
    Use irq_set_chip_and_handler() instead. Converted with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/plat-orion/irq.c b/arch/arm/plat-orion/irq.c
index f533bdeaa72b..d8d638e09f8f 100644
--- a/arch/arm/plat-orion/irq.c
+++ b/arch/arm/plat-orion/irq.c
@@ -56,8 +56,8 @@ void __init orion_irq_init(unsigned int irq_start, void __iomem *maskaddr)
 	for (i = 0; i < 32; i++) {
 		unsigned int irq = irq_start + i;
 
-		irq_set_chip(irq, &orion_irq_chip);
-		irq_set_handler(irq, handle_level_irq);
+		irq_set_chip_and_handler(irq, &orion_irq_chip,
+					 handle_level_irq);
 		irq_set_chip_data(irq, maskaddr);
 		irq_set_status_flags(irq, IRQ_LEVEL);
 		set_irq_flags(irq, IRQF_VALID);

commit 9323f26186403433293e87e717a7785f74f75d80
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 13:29:39 2011 +0100

    arm: Reorder irq_set_ function calls
    
    Reorder
    irq_set_chip()
    irq_set_chip_data()
    irq_set_handler()
    
    to
    
    irq_set_chip()
    irq_set_handler()
    irq_set_chip_data()
    
    so the next patch can combine irq_set_chip() and irq_set_handler() to
    irq_set_chip_and_handler().
    
    Automated conversion with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/plat-orion/irq.c b/arch/arm/plat-orion/irq.c
index aba3ffed9427..f533bdeaa72b 100644
--- a/arch/arm/plat-orion/irq.c
+++ b/arch/arm/plat-orion/irq.c
@@ -57,8 +57,8 @@ void __init orion_irq_init(unsigned int irq_start, void __iomem *maskaddr)
 		unsigned int irq = irq_start + i;
 
 		irq_set_chip(irq, &orion_irq_chip);
-		irq_set_chip_data(irq, maskaddr);
 		irq_set_handler(irq, handle_level_irq);
+		irq_set_chip_data(irq, maskaddr);
 		irq_set_status_flags(irq, IRQ_LEVEL);
 		set_irq_flags(irq, IRQF_VALID);
 	}

commit 6845664a6a7d443f03883db59d10749d38d98b8e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 13:25:22 2011 +0100

    arm: Cleanup the irq namespace
    
    Convert to the new function names. Automated with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/plat-orion/irq.c b/arch/arm/plat-orion/irq.c
index c163f9079e4b..aba3ffed9427 100644
--- a/arch/arm/plat-orion/irq.c
+++ b/arch/arm/plat-orion/irq.c
@@ -56,9 +56,9 @@ void __init orion_irq_init(unsigned int irq_start, void __iomem *maskaddr)
 	for (i = 0; i < 32; i++) {
 		unsigned int irq = irq_start + i;
 
-		set_irq_chip(irq, &orion_irq_chip);
-		set_irq_chip_data(irq, maskaddr);
-		set_irq_handler(irq, handle_level_irq);
+		irq_set_chip(irq, &orion_irq_chip);
+		irq_set_chip_data(irq, maskaddr);
+		irq_set_handler(irq, handle_level_irq);
 		irq_set_status_flags(irq, IRQ_LEVEL);
 		set_irq_flags(irq, IRQF_VALID);
 	}

commit e83bbb115e3afc87bdb1d375d33bcfe910920002
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 12:35:19 2011 +0100

    arm: Cleanup irq_desc access
    
    Use the proper wrappers and use the flow type in irq_data.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/plat-orion/irq.c b/arch/arm/plat-orion/irq.c
index 7d0c7eb59f09..c163f9079e4b 100644
--- a/arch/arm/plat-orion/irq.c
+++ b/arch/arm/plat-orion/irq.c
@@ -59,7 +59,7 @@ void __init orion_irq_init(unsigned int irq_start, void __iomem *maskaddr)
 		set_irq_chip(irq, &orion_irq_chip);
 		set_irq_chip_data(irq, maskaddr);
 		set_irq_handler(irq, handle_level_irq);
-		irq_desc[irq].status |= IRQ_LEVEL;
+		irq_set_status_flags(irq, IRQ_LEVEL);
 		set_irq_flags(irq, IRQF_VALID);
 	}
 }

commit 3b0c8d40387482d6a446da9ef0c97fede20a7b89
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Mon Nov 29 11:17:38 2010 +0100

    ARM: plat-orion: irq_data conversion.
    
    Signed-off-by: Lennert Buytenhek <buytenh@secretlab.ca>
    Acked-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/plat-orion/irq.c b/arch/arm/plat-orion/irq.c
index 3f9d34fc738c..7d0c7eb59f09 100644
--- a/arch/arm/plat-orion/irq.c
+++ b/arch/arm/plat-orion/irq.c
@@ -14,31 +14,31 @@
 #include <linux/io.h>
 #include <plat/irq.h>
 
-static void orion_irq_mask(u32 irq)
+static void orion_irq_mask(struct irq_data *d)
 {
-	void __iomem *maskaddr = get_irq_chip_data(irq);
+	void __iomem *maskaddr = irq_data_get_irq_chip_data(d);
 	u32 mask;
 
 	mask = readl(maskaddr);
-	mask &= ~(1 << (irq & 31));
+	mask &= ~(1 << (d->irq & 31));
 	writel(mask, maskaddr);
 }
 
-static void orion_irq_unmask(u32 irq)
+static void orion_irq_unmask(struct irq_data *d)
 {
-	void __iomem *maskaddr = get_irq_chip_data(irq);
+	void __iomem *maskaddr = irq_data_get_irq_chip_data(d);
 	u32 mask;
 
 	mask = readl(maskaddr);
-	mask |= 1 << (irq & 31);
+	mask |= 1 << (d->irq & 31);
 	writel(mask, maskaddr);
 }
 
 static struct irq_chip orion_irq_chip = {
 	.name		= "orion_irq",
-	.mask		= orion_irq_mask,
-	.mask_ack	= orion_irq_mask,
-	.unmask		= orion_irq_unmask,
+	.irq_mask	= orion_irq_mask,
+	.irq_mask_ack	= orion_irq_mask,
+	.irq_unmask	= orion_irq_unmask,
 };
 
 void __init orion_irq_init(unsigned int irq_start, void __iomem *maskaddr)

commit 6f088f1d215be5250582b974f83f0e3aa6ad3a28
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Sat Aug 9 13:44:58 2008 +0200

    [ARM] Move include/asm-arm/plat-orion to arch/arm/plat-orion/include/plat
    
    This patch performs the equivalent include directory shuffle for
    plat-orion, and fixes up all users.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>

diff --git a/arch/arm/plat-orion/irq.c b/arch/arm/plat-orion/irq.c
index fe66a1835169..3f9d34fc738c 100644
--- a/arch/arm/plat-orion/irq.c
+++ b/arch/arm/plat-orion/irq.c
@@ -12,7 +12,7 @@
 #include <linux/init.h>
 #include <linux/irq.h>
 #include <linux/io.h>
-#include <asm/plat-orion/irq.h>
+#include <plat/irq.h>
 
 static void orion_irq_mask(u32 irq)
 {

commit 000e99c3334cdddaec020d7324fe4ca2a683d3dd
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Sun May 18 19:46:59 2008 +0200

    [ARM] Orion: top-level IRQs are level-triggered
    
    Make it clear that Orion top-level IRQs are level-triggered.  This
    means that we don't need an ->ack() handler, or at least, we don't
    need the ->ack() handler (or the acking part of the ->mask_ack()
    handler) to actually do anything.
    
    Given that, we might as well point our ->mask_ack() handler at the
    ->mask() handler instead of providing a dummy ->ack() handler, since
    providing a ->mask_ack() handler on level IRQ sources will prevent
    ->ack() from ever being called.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Acked-by: Russell King <linux@arm.linux.org.uk>

diff --git a/arch/arm/plat-orion/irq.c b/arch/arm/plat-orion/irq.c
index c5b669d234bc..fe66a1835169 100644
--- a/arch/arm/plat-orion/irq.c
+++ b/arch/arm/plat-orion/irq.c
@@ -36,8 +36,8 @@ static void orion_irq_unmask(u32 irq)
 
 static struct irq_chip orion_irq_chip = {
 	.name		= "orion_irq",
-	.ack		= orion_irq_mask,
 	.mask		= orion_irq_mask,
+	.mask_ack	= orion_irq_mask,
 	.unmask		= orion_irq_unmask,
 };
 
@@ -59,6 +59,7 @@ void __init orion_irq_init(unsigned int irq_start, void __iomem *maskaddr)
 		set_irq_chip(irq, &orion_irq_chip);
 		set_irq_chip_data(irq, maskaddr);
 		set_irq_handler(irq, handle_level_irq);
+		irq_desc[irq].status |= IRQ_LEVEL;
 		set_irq_flags(irq, IRQF_VALID);
 	}
 }

commit 01eb569823792ab83b2810fcb31fa38560b08951
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Thu Mar 27 14:51:40 2008 -0400

    plat-orion: share IRQ handling code
    
    Split off Orion IRQ handling code into plat-orion/, and add
    support for multiple sets of (32) interrupts.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Reviewed-by: Tzachi Perelstein <tzachi@marvell.com>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Nicolas Pitre <nico@marvell.com>

diff --git a/arch/arm/plat-orion/irq.c b/arch/arm/plat-orion/irq.c
new file mode 100644
index 000000000000..c5b669d234bc
--- /dev/null
+++ b/arch/arm/plat-orion/irq.c
@@ -0,0 +1,64 @@
+/*
+ * arch/arm/plat-orion/irq.c
+ *
+ * Marvell Orion SoC IRQ handling.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <asm/plat-orion/irq.h>
+
+static void orion_irq_mask(u32 irq)
+{
+	void __iomem *maskaddr = get_irq_chip_data(irq);
+	u32 mask;
+
+	mask = readl(maskaddr);
+	mask &= ~(1 << (irq & 31));
+	writel(mask, maskaddr);
+}
+
+static void orion_irq_unmask(u32 irq)
+{
+	void __iomem *maskaddr = get_irq_chip_data(irq);
+	u32 mask;
+
+	mask = readl(maskaddr);
+	mask |= 1 << (irq & 31);
+	writel(mask, maskaddr);
+}
+
+static struct irq_chip orion_irq_chip = {
+	.name		= "orion_irq",
+	.ack		= orion_irq_mask,
+	.mask		= orion_irq_mask,
+	.unmask		= orion_irq_unmask,
+};
+
+void __init orion_irq_init(unsigned int irq_start, void __iomem *maskaddr)
+{
+	unsigned int i;
+
+	/*
+	 * Mask all interrupts initially.
+	 */
+	writel(0, maskaddr);
+
+	/*
+	 * Register IRQ sources.
+	 */
+	for (i = 0; i < 32; i++) {
+		unsigned int irq = irq_start + i;
+
+		set_irq_chip(irq, &orion_irq_chip);
+		set_irq_chip_data(irq, maskaddr);
+		set_irq_handler(irq, handle_level_irq);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+}
