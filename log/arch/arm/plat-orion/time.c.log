commit 37b146e3f2b4bab1009245f45e1cd9a321efcbbe
Author: afzal mohammed <afzal.mohd.ma@gmail.com>
Date:   Sun Mar 1 17:53:30 2020 +0530

    ARM: orion: replace setup_irq() by request_irq()
    
    request_irq() is preferred over setup_irq(). Invocations of setup_irq()
    occur after memory allocators are ready.
    
    Per tglx[1], setup_irq() existed in olden days when allocators were not
    ready by the time early interrupts were initialized.
    
    Hence replace setup_irq() by request_irq().
    
    [1] https://lkml.kernel.org/r/alpine.DEB.2.20.1710191609480.1971@nanos
    
    Signed-off-by: afzal mohammed <afzal.mohd.ma@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index ffb93db68e9c..509d4824dc1c 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -177,12 +177,6 @@ static irqreturn_t orion_timer_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static struct irqaction orion_timer_irq = {
-	.name		= "orion_tick",
-	.flags		= IRQF_TIMER,
-	.handler	= orion_timer_interrupt
-};
-
 void __init
 orion_time_set_base(void __iomem *_timer_base)
 {
@@ -236,7 +230,9 @@ orion_time_init(void __iomem *_bridge_base, u32 _bridge_timer1_clr_mask,
 	/*
 	 * Setup clockevent timer (interrupt-driven).
 	 */
-	setup_irq(irq, &orion_timer_irq);
+	if (request_irq(irq, orion_timer_interrupt, IRQF_TIMER, "orion_tick",
+			NULL))
+		pr_err("Failed to request irq %u (orion_tick)\n", irq);
 	orion_clkevt.cpumask = cpumask_of(0);
 	clockevents_config_and_register(&orion_clkevt, tclk, 1, 0xfffffffe);
 }

commit f19768ce0e84ac8a1ab03f87784bdf94bf94e140
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Oct 19 16:00:35 2015 +0100

    ARM: orion: implement ARM delay timer
    
    Implement an ARM delay timer to be used for udelay() on orion legacy
    platforms.  This allows us to skip the delay loop calibration at boot.
    
    It also means that udelay() will be unaffected by CPU frequency changes
    when cpufreq is enabled on these platforms.
    
    Tested-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index 8085a8aac812..ffb93db68e9c 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -18,6 +18,7 @@
 #include <linux/irq.h>
 #include <linux/sched_clock.h>
 #include <plat/time.h>
+#include <asm/delay.h>
 
 /*
  * MBus bridge block registers.
@@ -188,6 +189,15 @@ orion_time_set_base(void __iomem *_timer_base)
 	timer_base = _timer_base;
 }
 
+static unsigned long orion_delay_timer_read(void)
+{
+	return ~readl(timer_base + TIMER0_VAL_OFF);
+}
+
+static struct delay_timer orion_delay_timer = {
+	.read_current_timer = orion_delay_timer_read,
+};
+
 void __init
 orion_time_init(void __iomem *_bridge_base, u32 _bridge_timer1_clr_mask,
 		unsigned int irq, unsigned int tclk)
@@ -202,6 +212,9 @@ orion_time_init(void __iomem *_bridge_base, u32 _bridge_timer1_clr_mask,
 
 	ticks_per_jiffy = (tclk + HZ/2) / HZ;
 
+	orion_delay_timer.freq = tclk;
+	register_current_timer_delay(&orion_delay_timer);
+
 	/*
 	 * Set scale and timer for sched_clock.
 	 */

commit 10dca88a4be632678088f5cbc20b54c2113ecb91
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/orion/time: Migrate to new 'set-state' interface
    
    Migrate orion driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Gregory Clement <gregory.clement@free-electrons.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index 261258f717fc..8085a8aac812 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -106,60 +106,63 @@ orion_clkevt_next_event(unsigned long delta, struct clock_event_device *dev)
 	return 0;
 }
 
-static void
-orion_clkevt_mode(enum clock_event_mode mode, struct clock_event_device *dev)
+static int orion_clkevt_shutdown(struct clock_event_device *evt)
 {
 	unsigned long flags;
 	u32 u;
 
 	local_irq_save(flags);
-	if (mode == CLOCK_EVT_MODE_PERIODIC) {
-		/*
-		 * Setup timer to fire at 1/HZ intervals.
-		 */
-		writel(ticks_per_jiffy - 1, timer_base + TIMER1_RELOAD_OFF);
-		writel(ticks_per_jiffy - 1, timer_base + TIMER1_VAL_OFF);
-
-		/*
-		 * Enable timer interrupt.
-		 */
-		u = readl(bridge_base + BRIDGE_MASK_OFF);
-		writel(u | BRIDGE_INT_TIMER1, bridge_base + BRIDGE_MASK_OFF);
-
-		/*
-		 * Enable timer.
-		 */
-		u = readl(timer_base + TIMER_CTRL_OFF);
-		writel(u | TIMER1_EN | TIMER1_RELOAD_EN,
-		       timer_base + TIMER_CTRL_OFF);
-	} else {
-		/*
-		 * Disable timer.
-		 */
-		u = readl(timer_base + TIMER_CTRL_OFF);
-		writel(u & ~TIMER1_EN, timer_base + TIMER_CTRL_OFF);
-
-		/*
-		 * Disable timer interrupt.
-		 */
-		u = readl(bridge_base + BRIDGE_MASK_OFF);
-		writel(u & ~BRIDGE_INT_TIMER1, bridge_base + BRIDGE_MASK_OFF);
-
-		/*
-		 * ACK pending timer interrupt.
-		 */
-		writel(bridge_timer1_clr_mask, bridge_base + BRIDGE_CAUSE_OFF);
-
-	}
+
+	/* Disable timer */
+	u = readl(timer_base + TIMER_CTRL_OFF);
+	writel(u & ~TIMER1_EN, timer_base + TIMER_CTRL_OFF);
+
+	/* Disable timer interrupt */
+	u = readl(bridge_base + BRIDGE_MASK_OFF);
+	writel(u & ~BRIDGE_INT_TIMER1, bridge_base + BRIDGE_MASK_OFF);
+
+	/* ACK pending timer interrupt */
+	writel(bridge_timer1_clr_mask, bridge_base + BRIDGE_CAUSE_OFF);
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static int orion_clkevt_set_periodic(struct clock_event_device *evt)
+{
+	unsigned long flags;
+	u32 u;
+
+	local_irq_save(flags);
+
+	/* Setup timer to fire at 1/HZ intervals */
+	writel(ticks_per_jiffy - 1, timer_base + TIMER1_RELOAD_OFF);
+	writel(ticks_per_jiffy - 1, timer_base + TIMER1_VAL_OFF);
+
+	/* Enable timer interrupt */
+	u = readl(bridge_base + BRIDGE_MASK_OFF);
+	writel(u | BRIDGE_INT_TIMER1, bridge_base + BRIDGE_MASK_OFF);
+
+	/* Enable timer */
+	u = readl(timer_base + TIMER_CTRL_OFF);
+	writel(u | TIMER1_EN | TIMER1_RELOAD_EN, timer_base + TIMER_CTRL_OFF);
+
 	local_irq_restore(flags);
+
+	return 0;
 }
 
 static struct clock_event_device orion_clkevt = {
-	.name		= "orion_tick",
-	.features	= CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_PERIODIC,
-	.rating		= 300,
-	.set_next_event	= orion_clkevt_next_event,
-	.set_mode	= orion_clkevt_mode,
+	.name			= "orion_tick",
+	.features		= CLOCK_EVT_FEAT_ONESHOT |
+				  CLOCK_EVT_FEAT_PERIODIC,
+	.rating			= 300,
+	.set_next_event		= orion_clkevt_next_event,
+	.set_state_shutdown	= orion_clkevt_shutdown,
+	.set_state_periodic	= orion_clkevt_set_periodic,
+	.set_state_oneshot	= orion_clkevt_shutdown,
+	.tick_resume		= orion_clkevt_shutdown,
 };
 
 static irqreturn_t orion_timer_interrupt(int irq, void *dev_id)

commit dfd10e7ae60c6c1b24b5d601744b4fd1ecab2f31
Merge: f2c73464d7b3 6373bb71875b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 23 18:40:49 2014 -0800

    Merge tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform changes from Olof Johansson:
     "New core SoC-specific changes.
    
      New platforms:
       * Introduction of a vendor, Hisilicon, and one of their SoCs with
         some random numerical product name.
       * Introduction of EFM32, embedded platform from Silicon Labs (ARMv7m,
         i.e. !MMU).
       * Marvell Berlin series of SoCs, which include the one in Chromecast.
       * MOXA platform support, ARM9-based platform used mostly in
         industrial products
       * Support for Freescale's i.MX50 SoC.
    
      Other work:
       * Renesas work for new platforms and drivers, and conversion over to
         more multiplatform-friendly device registration schemes.
       * SMP support for Allwinner sunxi platforms.
       * ... plus a bunch of other stuff across various platforms"
    
    * tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (201 commits)
      ARM: tegra: fix tegra_powergate_sequence_power_up() inline
      ARM: msm_defconfig: Update for multi-platform
      ARM: msm: Move MSM's DT based hardware to multi-platform support
      ARM: msm: Only build timer.c if required
      ARM: msm: Only build clock.c on proc_comm based platforms
      ARM: ux500: Enable system suspend with WFI support
      ARM: ux500: turn on PRINTK_TIME in u8500_defconfig
      ARM: shmobile: r8a7790: Fix I2C controller names
      ARM: msm: Simplify ARCH_MSM_DT config
      ARM: msm: Add support for MSM8974 SoC
      ARM: sunxi: select ARM_PSCI
      MAINTAINERS: Update Allwinner sunXi maintainer files
      ARM: sunxi: Select RESET_CONTROLLER
      ARM: imx: improve the comment of CCM lpm SW workaround
      ARM: imx: improve status check of clock gate
      ARM: imx: add necessary interface for pfd
      ARM: imx_v6_v7_defconfig: Select CONFIG_REGULATOR_PFUZE100
      ARM: imx_v6_v7_defconfig: Select MX35 and MX50 device tree support
      ARM: imx: Add cpu frequency scaling support
      ARM i.MX35: Add devicetree support.
      ...

commit 48fce88cb5fac1b9f9f1c3c756d1e5caa42d5692
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Wed Oct 23 16:12:50 2013 +0200

    ARM: Orion: Add missing includes
    
    Building with C=1 generates warnings because of missing includes and
    static keywords. Add them.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index df671d04c34d..15921a1839d7 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -17,6 +17,7 @@
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/sched_clock.h>
+#include <plat/time.h>
 
 /*
  * MBus bridge block registers.

commit eb4d552b933ac59c0c8e0604ff435c5208a82679
Author: Michael Opdenacker <michael.opdenacker@free-electrons.com>
Date:   Sat Oct 12 05:49:20 2013 +0200

    arm: plat-orion: remove deprecated IRQF_DISABLED
    
    This patch proposes to remove the use of the IRQF_DISABLED flag
    
    It's a NOOP since 2.6.35 and it will be removed one day.
    
    Signed-off-by: Michael Opdenacker <michael.opdenacker@free-electrons.com>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index 9d2b2ac74938..df671d04c34d 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -174,7 +174,7 @@ static irqreturn_t orion_timer_interrupt(int irq, void *dev_id)
 
 static struct irqaction orion_timer_irq = {
 	.name		= "orion_tick",
-	.flags		= IRQF_DISABLED | IRQF_TIMER,
+	.flags		= IRQF_TIMER,
 	.handler	= orion_timer_interrupt
 };
 

commit b44653baed01d63fb7de5378ad717158a51e83ce
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Nov 15 15:26:24 2013 -0800

    ARM: orion: Switch to sched_clock_register()
    
    The 32 bit sched_clock interface now supports 64 bits. Upgrade to
    the 64 bit function to allow us to remove the 32 bit registration
    interface.
    
    Cc: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Kevin Hilman <khilman@linaro.org>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index 9d2b2ac74938..dade2920e9a6 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -60,7 +60,7 @@ static u32 ticks_per_jiffy;
  * at least 7.5ns (133MHz TCLK).
  */
 
-static u32 notrace orion_read_sched_clock(void)
+static u64 notrace orion_read_sched_clock(void)
 {
 	return ~readl(timer_base + TIMER0_VAL_OFF);
 }
@@ -201,7 +201,7 @@ orion_time_init(void __iomem *_bridge_base, u32 _bridge_timer1_clr_mask,
 	/*
 	 * Set scale and timer for sched_clock.
 	 */
-	setup_sched_clock(orion_read_sched_clock, 32, tclk);
+	sched_clock_register(orion_read_sched_clock, 32, tclk);
 
 	/*
 	 * Setup free-running clocksource timer (interrupts

commit 38ff87f77af0b5a93fc8581cff1d6e5692ab8970
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Sat Jun 1 23:39:40 2013 -0700

    sched_clock: Make ARM's sched_clock generic for all architectures
    
    Nothing about the sched_clock implementation in the ARM port is
    specific to the architecture. Generalize the code so that other
    architectures can use it by selecting GENERIC_SCHED_CLOCK.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    [jstultz: Merge minor collisions with other patches in my tree]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index 5d5ac0f05422..9d2b2ac74938 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -16,7 +16,7 @@
 #include <linux/clockchips.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
-#include <asm/sched_clock.h>
+#include <linux/sched_clock.h>
 
 /*
  * MBus bridge block registers.

commit 838a2ae80a6ab52139fb1bf0a93ea8c5eff94488
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Sat Jan 12 11:50:05 2013 +0000

    ARM: use clockevents_config_and_register() where possible
    
    The clockevent core is able to figure out the best mult and shift,
    calculate min_delta_ns and max_delta_ns, with the necessary info passed
    into clockevents_config_and_register().  Use this combined configure
    and register function where possible to make the codes less error prone
    and gain some positive diff stat.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Reviewed-by: Anton Vorontsov <cbouatmailru@gmail.com>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Tested-by: Roland Stigge <stigge@antcom.de>
    Acked-by: Eric Miao <eric.y.miao@gmail.com>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: David Brown <davidb@codeaurora.org>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Barry Song <baohua.song@csr.com>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Tony Prisk <linux@prisktech.co.nz>
    Cc: Lennert Buytenhek <buytenh@wantstofly.org>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index 0f4fa863dd55..5d5ac0f05422 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -156,7 +156,6 @@ orion_clkevt_mode(enum clock_event_mode mode, struct clock_event_device *dev)
 static struct clock_event_device orion_clkevt = {
 	.name		= "orion_tick",
 	.features	= CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_PERIODIC,
-	.shift		= 32,
 	.rating		= 300,
 	.set_next_event	= orion_clkevt_next_event,
 	.set_mode	= orion_clkevt_mode,
@@ -221,9 +220,6 @@ orion_time_init(void __iomem *_bridge_base, u32 _bridge_timer1_clr_mask,
 	 * Setup clockevent timer (interrupt-driven).
 	 */
 	setup_irq(irq, &orion_timer_irq);
-	orion_clkevt.mult = div_sc(tclk, NSEC_PER_SEC, orion_clkevt.shift);
-	orion_clkevt.max_delta_ns = clockevent_delta2ns(0xfffffffe, &orion_clkevt);
-	orion_clkevt.min_delta_ns = clockevent_delta2ns(1, &orion_clkevt);
 	orion_clkevt.cpumask = cpumask_of(0);
-	clockevents_register_device(&orion_clkevt);
+	clockevents_config_and_register(&orion_clkevt, tclk, 1, 0xfffffffe);
 }

commit e96a0309f8545d539c1bf4acd5b58727a8f39818
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Tue Sep 11 14:27:25 2012 +0200

    arm: plat-orion: use void __iomem pointers for time functions
    
    The functions for time management now take void __iomem pointers, so
    we remove the temporary "unsigned long" casts from the mach-*/common.c
    files.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index 1ed8d1397fcf..0f4fa863dd55 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -180,13 +180,13 @@ static struct irqaction orion_timer_irq = {
 };
 
 void __init
-orion_time_set_base(u32 _timer_base)
+orion_time_set_base(void __iomem *_timer_base)
 {
-	timer_base = (void __iomem *)_timer_base;
+	timer_base = _timer_base;
 }
 
 void __init
-orion_time_init(u32 _bridge_base, u32 _bridge_timer1_clr_mask,
+orion_time_init(void __iomem *_bridge_base, u32 _bridge_timer1_clr_mask,
 		unsigned int irq, unsigned int tclk)
 {
 	u32 u;
@@ -194,7 +194,7 @@ orion_time_init(u32 _bridge_base, u32 _bridge_timer1_clr_mask,
 	/*
 	 * Set SoC-specific data.
 	 */
-	bridge_base = (void __iomem *)_bridge_base;
+	bridge_base = _bridge_base;
 	bridge_timer1_clr_mask = _bridge_timer1_clr_mask;
 
 	ticks_per_jiffy = (tclk + HZ/2) / HZ;

commit 2f0778afac79bd8d226225556858a636931eeabc
Author: Marc Zyngier <Marc.Zyngier@arm.com>
Date:   Thu Dec 15 12:19:23 2011 +0100

    ARM: 7205/2: sched_clock: allow sched_clock to be selected at runtime
    
    sched_clock() is yet another blocker on the road to the single
    image. This patch implements an idea by Russell King:
    
    http://www.spinics.net/lists/linux-omap/msg49561.html
    
    Instead of asking the platform to implement both sched_clock()
    itself and the rollover callback, simply register a read()
    function, and let the ARM code care about sched_clock() itself,
    the conversion to ns and the rollover. sched_clock() uses
    this read() function as an indirection to the platform code.
    If the platform doesn't provide a read(), the code falls back
    to the jiffy counter (just like the default sched_clock).
    
    This allow some simplifications and possibly some footprint gain
    when multiple platforms are compiled in. Among the drawbacks,
    the removal of the *_fixed_sched_clock optimization which could
    negatively impact some platforms (sa1100, tegra, versatile
    and omap).
    
    Tested on 11MPCore, OMAP4 and Tegra.
    
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Colin Cross <ccross@android.com>
    Cc: Erik Gilling <konkers@android.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Alessandro Rubini <rubini@unipv.it>
    Cc: STEricsson <STEricsson_nomadik_linux@list.st.com>
    Cc: Lennert Buytenhek <kernel@wantstofly.org>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Tested-by: Jamie Iles <jamie@jamieiles.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Krzysztof Halasa <khc@pm.waw.pl>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index 69a61367e4b8..1ed8d1397fcf 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -12,7 +12,6 @@
  */
 
 #include <linux/kernel.h>
-#include <linux/sched.h>
 #include <linux/timer.h>
 #include <linux/clockchips.h>
 #include <linux/interrupt.h>
@@ -60,24 +59,10 @@ static u32 ticks_per_jiffy;
  * Orion's sched_clock implementation. It has a resolution of
  * at least 7.5ns (133MHz TCLK).
  */
-static DEFINE_CLOCK_DATA(cd);
 
-unsigned long long notrace sched_clock(void)
+static u32 notrace orion_read_sched_clock(void)
 {
-	u32 cyc = ~readl(timer_base + TIMER0_VAL_OFF);
-	return cyc_to_sched_clock(&cd, cyc, (u32)~0);
-}
-
-
-static void notrace orion_update_sched_clock(void)
-{
-	u32 cyc = ~readl(timer_base + TIMER0_VAL_OFF);
-	update_sched_clock(&cd, cyc, (u32)~0);
-}
-
-static void __init setup_sched_clock(unsigned long tclk)
-{
-	init_sched_clock(&cd, orion_update_sched_clock, 32, tclk);
+	return ~readl(timer_base + TIMER0_VAL_OFF);
 }
 
 /*
@@ -217,7 +202,7 @@ orion_time_init(u32 _bridge_base, u32 _bridge_timer1_clr_mask,
 	/*
 	 * Set scale and timer for sched_clock.
 	 */
-	setup_sched_clock(tclk);
+	setup_sched_clock(orion_read_sched_clock, 32, tclk);
 
 	/*
 	 * Setup free-running clocksource timer (interrupts

commit bfe45e0be88d8a2e408226d473bff60da4a97d1f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun May 8 15:33:30 2011 +0100

    clocksource: convert ARM 32-bit down counting clocksources
    
    Convert SP804, MXC, Nomadik and Orion 32-bit down-counting clocksources
    to generic mmio clocksource infrastructure.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Alessandro Rubini <rubini@unipv.it>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Lennert Buytenhek <kernel@wantstofly.org>
    Acked-by: Nicolas Pitre <nico@fluxnic.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index 742b0323c57b..69a61367e4b8 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -80,24 +80,6 @@ static void __init setup_sched_clock(unsigned long tclk)
 	init_sched_clock(&cd, orion_update_sched_clock, 32, tclk);
 }
 
-/*
- * Clocksource handling.
- */
-static cycle_t orion_clksrc_read(struct clocksource *cs)
-{
-	return 0xffffffff - readl(timer_base + TIMER0_VAL_OFF);
-}
-
-static struct clocksource orion_clksrc = {
-	.name		= "orion_clocksource",
-	.rating		= 300,
-	.read		= orion_clksrc_read,
-	.mask		= CLOCKSOURCE_MASK(32),
-	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
-};
-
-
-
 /*
  * Clockevent handling.
  */
@@ -247,7 +229,8 @@ orion_time_init(u32 _bridge_base, u32 _bridge_timer1_clr_mask,
 	writel(u & ~BRIDGE_INT_TIMER0, bridge_base + BRIDGE_MASK_OFF);
 	u = readl(timer_base + TIMER_CTRL_OFF);
 	writel(u | TIMER0_EN | TIMER0_RELOAD_EN, timer_base + TIMER_CTRL_OFF);
-	clocksource_register_hz(&orion_clksrc, tclk);
+	clocksource_mmio_init(timer_base + TIMER0_VAL_OFF, "orion_clocksource",
+		tclk, 300, 32, clocksource_mmio_readl_down);
 
 	/*
 	 * Setup clockevent timer (interrupt-driven).

commit 4ee1f6b574765a6c97f945e6b0277e5ccac38cb5
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Fri Oct 15 16:50:26 2010 +0200

    ARM: Remove dependency of plat-orion time code on mach directory includes.
    
    This patch makes the various mach dirs that use the plat-orion time
    code pass in timer and bridge addresses explicitly, instead of having
    plat-orion get those values by including a mach dir include file --
    the latter mechanism is problematic if you want to support multiple
    ARM platforms in the same kernel image.
    
    Signed-off-by: Lennert Buytenhek <buytenh@secretlab.ca>
    Signed-off-by: Nicolas Pitre <nico@fluxnic.net>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index c3da2478b2aa..742b0323c57b 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -18,28 +18,42 @@
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <asm/sched_clock.h>
-#include <asm/mach/time.h>
-#include <mach/bridge-regs.h>
-#include <mach/hardware.h>
 
 /*
- * Number of timer ticks per jiffy.
+ * MBus bridge block registers.
  */
-static u32 ticks_per_jiffy;
+#define BRIDGE_CAUSE_OFF	0x0110
+#define BRIDGE_MASK_OFF		0x0114
+#define  BRIDGE_INT_TIMER0	 0x0002
+#define  BRIDGE_INT_TIMER1	 0x0004
 
 
 /*
  * Timer block registers.
  */
-#define TIMER_CTRL		(TIMER_VIRT_BASE + 0x0000)
-#define  TIMER0_EN		0x0001
-#define  TIMER0_RELOAD_EN	0x0002
-#define  TIMER1_EN		0x0004
-#define  TIMER1_RELOAD_EN	0x0008
-#define TIMER0_RELOAD		(TIMER_VIRT_BASE + 0x0010)
-#define TIMER0_VAL		(TIMER_VIRT_BASE + 0x0014)
-#define TIMER1_RELOAD		(TIMER_VIRT_BASE + 0x0018)
-#define TIMER1_VAL		(TIMER_VIRT_BASE + 0x001c)
+#define TIMER_CTRL_OFF		0x0000
+#define  TIMER0_EN		 0x0001
+#define  TIMER0_RELOAD_EN	 0x0002
+#define  TIMER1_EN		 0x0004
+#define  TIMER1_RELOAD_EN	 0x0008
+#define TIMER0_RELOAD_OFF	0x0010
+#define TIMER0_VAL_OFF		0x0014
+#define TIMER1_RELOAD_OFF	0x0018
+#define TIMER1_VAL_OFF		0x001c
+
+
+/*
+ * SoC-specific data.
+ */
+static void __iomem *bridge_base;
+static u32 bridge_timer1_clr_mask;
+static void __iomem *timer_base;
+
+
+/*
+ * Number of timer ticks per jiffy.
+ */
+static u32 ticks_per_jiffy;
 
 
 /*
@@ -50,14 +64,14 @@ static DEFINE_CLOCK_DATA(cd);
 
 unsigned long long notrace sched_clock(void)
 {
-	u32 cyc = 0xffffffff - readl(TIMER0_VAL);
+	u32 cyc = ~readl(timer_base + TIMER0_VAL_OFF);
 	return cyc_to_sched_clock(&cd, cyc, (u32)~0);
 }
 
 
 static void notrace orion_update_sched_clock(void)
 {
-	u32 cyc = 0xffffffff - readl(TIMER0_VAL);
+	u32 cyc = ~readl(timer_base + TIMER0_VAL_OFF);
 	update_sched_clock(&cd, cyc, (u32)~0);
 }
 
@@ -71,7 +85,7 @@ static void __init setup_sched_clock(unsigned long tclk)
  */
 static cycle_t orion_clksrc_read(struct clocksource *cs)
 {
-	return 0xffffffff - readl(TIMER0_VAL);
+	return 0xffffffff - readl(timer_base + TIMER0_VAL_OFF);
 }
 
 static struct clocksource orion_clksrc = {
@@ -101,23 +115,23 @@ orion_clkevt_next_event(unsigned long delta, struct clock_event_device *dev)
 	/*
 	 * Clear and enable clockevent timer interrupt.
 	 */
-	writel(BRIDGE_INT_TIMER1_CLR, BRIDGE_CAUSE);
+	writel(bridge_timer1_clr_mask, bridge_base + BRIDGE_CAUSE_OFF);
 
-	u = readl(BRIDGE_MASK);
+	u = readl(bridge_base + BRIDGE_MASK_OFF);
 	u |= BRIDGE_INT_TIMER1;
-	writel(u, BRIDGE_MASK);
+	writel(u, bridge_base + BRIDGE_MASK_OFF);
 
 	/*
 	 * Setup new clockevent timer value.
 	 */
-	writel(delta, TIMER1_VAL);
+	writel(delta, timer_base + TIMER1_VAL_OFF);
 
 	/*
 	 * Enable the timer.
 	 */
-	u = readl(TIMER_CTRL);
+	u = readl(timer_base + TIMER_CTRL_OFF);
 	u = (u & ~TIMER1_RELOAD_EN) | TIMER1_EN;
-	writel(u, TIMER_CTRL);
+	writel(u, timer_base + TIMER_CTRL_OFF);
 
 	local_irq_restore(flags);
 
@@ -135,37 +149,38 @@ orion_clkevt_mode(enum clock_event_mode mode, struct clock_event_device *dev)
 		/*
 		 * Setup timer to fire at 1/HZ intervals.
 		 */
-		writel(ticks_per_jiffy - 1, TIMER1_RELOAD);
-		writel(ticks_per_jiffy - 1, TIMER1_VAL);
+		writel(ticks_per_jiffy - 1, timer_base + TIMER1_RELOAD_OFF);
+		writel(ticks_per_jiffy - 1, timer_base + TIMER1_VAL_OFF);
 
 		/*
 		 * Enable timer interrupt.
 		 */
-		u = readl(BRIDGE_MASK);
-		writel(u | BRIDGE_INT_TIMER1, BRIDGE_MASK);
+		u = readl(bridge_base + BRIDGE_MASK_OFF);
+		writel(u | BRIDGE_INT_TIMER1, bridge_base + BRIDGE_MASK_OFF);
 
 		/*
 		 * Enable timer.
 		 */
-		u = readl(TIMER_CTRL);
-		writel(u | TIMER1_EN | TIMER1_RELOAD_EN, TIMER_CTRL);
+		u = readl(timer_base + TIMER_CTRL_OFF);
+		writel(u | TIMER1_EN | TIMER1_RELOAD_EN,
+		       timer_base + TIMER_CTRL_OFF);
 	} else {
 		/*
 		 * Disable timer.
 		 */
-		u = readl(TIMER_CTRL);
-		writel(u & ~TIMER1_EN, TIMER_CTRL);
+		u = readl(timer_base + TIMER_CTRL_OFF);
+		writel(u & ~TIMER1_EN, timer_base + TIMER_CTRL_OFF);
 
 		/*
 		 * Disable timer interrupt.
 		 */
-		u = readl(BRIDGE_MASK);
-		writel(u & ~BRIDGE_INT_TIMER1, BRIDGE_MASK);
+		u = readl(bridge_base + BRIDGE_MASK_OFF);
+		writel(u & ~BRIDGE_INT_TIMER1, bridge_base + BRIDGE_MASK_OFF);
 
 		/*
 		 * ACK pending timer interrupt.
 		 */
-		writel(BRIDGE_INT_TIMER1_CLR, BRIDGE_CAUSE);
+		writel(bridge_timer1_clr_mask, bridge_base + BRIDGE_CAUSE_OFF);
 
 	}
 	local_irq_restore(flags);
@@ -185,7 +200,7 @@ static irqreturn_t orion_timer_interrupt(int irq, void *dev_id)
 	/*
 	 * ACK timer interrupt and call event handler.
 	 */
-	writel(BRIDGE_INT_TIMER1_CLR, BRIDGE_CAUSE);
+	writel(bridge_timer1_clr_mask, bridge_base + BRIDGE_CAUSE_OFF);
 	orion_clkevt.event_handler(&orion_clkevt);
 
 	return IRQ_HANDLED;
@@ -197,31 +212,45 @@ static struct irqaction orion_timer_irq = {
 	.handler	= orion_timer_interrupt
 };
 
-void __init orion_time_init(unsigned int irq, unsigned int tclk)
+void __init
+orion_time_set_base(u32 _timer_base)
+{
+	timer_base = (void __iomem *)_timer_base;
+}
+
+void __init
+orion_time_init(u32 _bridge_base, u32 _bridge_timer1_clr_mask,
+		unsigned int irq, unsigned int tclk)
 {
 	u32 u;
 
+	/*
+	 * Set SoC-specific data.
+	 */
+	bridge_base = (void __iomem *)_bridge_base;
+	bridge_timer1_clr_mask = _bridge_timer1_clr_mask;
+
 	ticks_per_jiffy = (tclk + HZ/2) / HZ;
 
 	/*
-	 * Set scale and timer for sched_clock
+	 * Set scale and timer for sched_clock.
 	 */
 	setup_sched_clock(tclk);
 
 	/*
 	 * Setup free-running clocksource timer (interrupts
-	 * disabled.)
+	 * disabled).
 	 */
-	writel(0xffffffff, TIMER0_VAL);
-	writel(0xffffffff, TIMER0_RELOAD);
-	u = readl(BRIDGE_MASK);
-	writel(u & ~BRIDGE_INT_TIMER0, BRIDGE_MASK);
-	u = readl(TIMER_CTRL);
-	writel(u | TIMER0_EN | TIMER0_RELOAD_EN, TIMER_CTRL);
+	writel(0xffffffff, timer_base + TIMER0_VAL_OFF);
+	writel(0xffffffff, timer_base + TIMER0_RELOAD_OFF);
+	u = readl(bridge_base + BRIDGE_MASK_OFF);
+	writel(u & ~BRIDGE_INT_TIMER0, bridge_base + BRIDGE_MASK_OFF);
+	u = readl(timer_base + TIMER_CTRL_OFF);
+	writel(u | TIMER0_EN | TIMER0_RELOAD_EN, timer_base + TIMER_CTRL_OFF);
 	clocksource_register_hz(&orion_clksrc, tclk);
 
 	/*
-	 * Setup clockevent timer (interrupt-driven.)
+	 * Setup clockevent timer (interrupt-driven).
 	 */
 	setup_irq(irq, &orion_timer_irq);
 	orion_clkevt.mult = div_sc(tclk, NSEC_PER_SEC, orion_clkevt.shift);

commit f06a1624621527ef597ae4b3b795553fc1b2eff2
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Dec 15 21:55:06 2010 +0000

    ARM: orion: convert sched_clock() to use new infrastructure
    
    Convert orion platforms to use the new sched_clock() infrastructure for
    extending 32bit counters to full 64-bit nanoseconds.
    
    Acked-by: Nicolas Pitre <nico@fluxnic.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index 123f96f4194f..c3da2478b2aa 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -13,11 +13,11 @@
 
 #include <linux/kernel.h>
 #include <linux/sched.h>
-#include <linux/cnt32_to_63.h>
 #include <linux/timer.h>
 #include <linux/clockchips.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
+#include <asm/sched_clock.h>
 #include <asm/mach/time.h>
 #include <mach/bridge-regs.h>
 #include <mach/hardware.h>
@@ -44,52 +44,26 @@ static u32 ticks_per_jiffy;
 
 /*
  * Orion's sched_clock implementation. It has a resolution of
- * at least 7.5ns (133MHz TCLK) and a maximum value of 834 days.
- *
- * Because the hardware timer period is quite short (21 secs if
- * 200MHz TCLK) and because cnt32_to_63() needs to be called at
- * least once per half period to work properly, a kernel timer is
- * set up to ensure this requirement is always met.
+ * at least 7.5ns (133MHz TCLK).
  */
-#define TCLK2NS_SCALE_FACTOR 8
-
-static unsigned long tclk2ns_scale;
+static DEFINE_CLOCK_DATA(cd);
 
 unsigned long long notrace sched_clock(void)
 {
-	unsigned long long v = cnt32_to_63(0xffffffff - readl(TIMER0_VAL));
-	return (v * tclk2ns_scale) >> TCLK2NS_SCALE_FACTOR;
+	u32 cyc = 0xffffffff - readl(TIMER0_VAL);
+	return cyc_to_sched_clock(&cd, cyc, (u32)~0);
 }
 
-static struct timer_list cnt32_to_63_keepwarm_timer;
 
-static void cnt32_to_63_keepwarm(unsigned long data)
+static void notrace orion_update_sched_clock(void)
 {
-	mod_timer(&cnt32_to_63_keepwarm_timer, round_jiffies(jiffies + data));
-	(void) sched_clock();
+	u32 cyc = 0xffffffff - readl(TIMER0_VAL);
+	update_sched_clock(&cd, cyc, (u32)~0);
 }
 
 static void __init setup_sched_clock(unsigned long tclk)
 {
-	unsigned long long v;
-	unsigned long data;
-
-	v = NSEC_PER_SEC;
-	v <<= TCLK2NS_SCALE_FACTOR;
-	v += tclk/2;
-	do_div(v, tclk);
-	/*
-	 * We want an even value to automatically clear the top bit
-	 * returned by cnt32_to_63() without an additional run time
-	 * instruction. So if the LSB is 1 then round it up.
-	 */
-	if (v & 1)
-		v++;
-	tclk2ns_scale = v;
-
-	data = (0xffffffffUL / tclk / 2 - 2) * HZ;
-	setup_timer(&cnt32_to_63_keepwarm_timer, cnt32_to_63_keepwarm, data);
-	mod_timer(&cnt32_to_63_keepwarm_timer, round_jiffies(jiffies + data));
+	init_sched_clock(&cd, orion_update_sched_clock, 32, tclk);
 }
 
 /*

commit 5e06b6492e53ab2a4e467763a9ee9f70b032c301
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Dec 15 19:19:25 2010 +0000

    ARM: ensure all sched_clock() implementations are notrace marked
    
    ftrace requires sched_clock() to be notrace.  Ensure that all
    implementations are so marked.  Also make sure that they include
    linux/sched.h
    
    Also ensure OMAP clocksource read functions are marked notrace as
    they're used for sched_clock() too.
    
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Will Deacon <will.deacon@arm.com>
    Tested-by: Mikael Pettersson <mikpe@it.uu.se>
    Tested-by: Eric Miao <eric.y.miao@gmail.com>
    Tested-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index 11e2583e85e4..123f96f4194f 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -55,7 +55,7 @@ static u32 ticks_per_jiffy;
 
 static unsigned long tclk2ns_scale;
 
-unsigned long long sched_clock(void)
+unsigned long long notrace sched_clock(void)
 {
 	unsigned long long v = cnt32_to_63(0xffffffff - readl(TIMER0_VAL));
 	return (v * tclk2ns_scale) >> TCLK2NS_SCALE_FACTOR;

commit 1d0ac3cdf3d31ba84499c3a914aa2b54eecbf2af
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Dec 13 13:21:33 2010 +0000

    ARM: orion: update clock source registration
    
    In d7e81c2 (clocksource: Add clocksource_register_hz/khz interface) new
    interfaces were added which simplify (and optimize) the selection of the
    divisor shift/mult constants.  Switch over to using this new interface.
    
    Acked-by: Nicolas Pitre <nico@fluxnic.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index 715a30177f28..11e2583e85e4 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -102,7 +102,6 @@ static cycle_t orion_clksrc_read(struct clocksource *cs)
 
 static struct clocksource orion_clksrc = {
 	.name		= "orion_clocksource",
-	.shift		= 20,
 	.rating		= 300,
 	.read		= orion_clksrc_read,
 	.mask		= CLOCKSOURCE_MASK(32),
@@ -245,8 +244,7 @@ void __init orion_time_init(unsigned int irq, unsigned int tclk)
 	writel(u & ~BRIDGE_INT_TIMER0, BRIDGE_MASK);
 	u = readl(TIMER_CTRL);
 	writel(u | TIMER0_EN | TIMER0_RELOAD_EN, TIMER_CTRL);
-	orion_clksrc.mult = clocksource_hz2mult(tclk, orion_clksrc.shift);
-	clocksource_register(&orion_clksrc);
+	clocksource_register_hz(&orion_clksrc, tclk);
 
 	/*
 	 * Setup clockevent timer (interrupt-driven.)

commit a399e3fa795afa058e4485b25c498e0c5a860428
Author: Nicolas Pitre <nico@cam.org>
Date:   Fri May 15 00:42:36 2009 -0400

    [ARM] orion: make sure sched_clock() usage of cnt32_to_63() is safe
    
    With a TCLK = 200MHz, the half period of the hardware timer is roughly
    10 seconds. Because cnt32_to_63() must be called at least once per
    half period of the base hardware counter, it is a bit risky to rely
    solely on scheduling to generate frequent enough calls. Let's use a
    kernel timer to ensure this.
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index b856cec81702..715a30177f28 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -12,14 +12,15 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/cnt32_to_63.h>
+#include <linux/timer.h>
 #include <linux/clockchips.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <asm/mach/time.h>
 #include <mach/bridge-regs.h>
 #include <mach/hardware.h>
-#include <linux/sched.h>
-#include <linux/cnt32_to_63.h>
 
 /*
  * Number of timer ticks per jiffy.
@@ -44,14 +45,36 @@ static u32 ticks_per_jiffy;
 /*
  * Orion's sched_clock implementation. It has a resolution of
  * at least 7.5ns (133MHz TCLK) and a maximum value of 834 days.
+ *
+ * Because the hardware timer period is quite short (21 secs if
+ * 200MHz TCLK) and because cnt32_to_63() needs to be called at
+ * least once per half period to work properly, a kernel timer is
+ * set up to ensure this requirement is always met.
  */
 #define TCLK2NS_SCALE_FACTOR 8
 
 static unsigned long tclk2ns_scale;
 
-static void __init set_tclk2ns_scale(unsigned long tclk)
+unsigned long long sched_clock(void)
+{
+	unsigned long long v = cnt32_to_63(0xffffffff - readl(TIMER0_VAL));
+	return (v * tclk2ns_scale) >> TCLK2NS_SCALE_FACTOR;
+}
+
+static struct timer_list cnt32_to_63_keepwarm_timer;
+
+static void cnt32_to_63_keepwarm(unsigned long data)
+{
+	mod_timer(&cnt32_to_63_keepwarm_timer, round_jiffies(jiffies + data));
+	(void) sched_clock();
+}
+
+static void __init setup_sched_clock(unsigned long tclk)
 {
-	unsigned long long v = NSEC_PER_SEC;
+	unsigned long long v;
+	unsigned long data;
+
+	v = NSEC_PER_SEC;
 	v <<= TCLK2NS_SCALE_FACTOR;
 	v += tclk/2;
 	do_div(v, tclk);
@@ -63,12 +86,10 @@ static void __init set_tclk2ns_scale(unsigned long tclk)
 	if (v & 1)
 		v++;
 	tclk2ns_scale = v;
-}
 
-unsigned long long sched_clock(void)
-{
-	unsigned long long v = cnt32_to_63(0xffffffff - readl(TIMER0_VAL));
-	return (v * tclk2ns_scale) >> TCLK2NS_SCALE_FACTOR;
+	data = (0xffffffffUL / tclk / 2 - 2) * HZ;
+	setup_timer(&cnt32_to_63_keepwarm_timer, cnt32_to_63_keepwarm, data);
+	mod_timer(&cnt32_to_63_keepwarm_timer, round_jiffies(jiffies + data));
 }
 
 /*
@@ -210,9 +231,9 @@ void __init orion_time_init(unsigned int irq, unsigned int tclk)
 	ticks_per_jiffy = (tclk + HZ/2) / HZ;
 
 	/*
-	 * Set scale for sched_clock
+	 * Set scale and timer for sched_clock
 	 */
-	set_tclk2ns_scale(tclk);
+	setup_sched_clock(tclk);
 
 	/*
 	 * Setup free-running clocksource timer (interrupts
@@ -227,7 +248,6 @@ void __init orion_time_init(unsigned int irq, unsigned int tclk)
 	orion_clksrc.mult = clocksource_hz2mult(tclk, orion_clksrc.shift);
 	clocksource_register(&orion_clksrc);
 
-
 	/*
 	 * Setup clockevent timer (interrupt-driven.)
 	 */

commit 8a3269fc21cc4405d80b362139c078cf655a505a
Author: Stefan Agner <stefan@agner.ch>
Date:   Tue May 12 10:30:41 2009 -0700

    [ARM] orion: sched_clock implementation for orion platforms
    
    sched_clock implementation for orion platform. Its realized using
    free-running clocksource timer, which provides a resolution of 7.5ns
    (depending on tclk). It's derived from PXA's sched_clock implementation.
    
    [ nico: renamed orion2ns to tclk2ns, fixed max value in the comment ]
    
    Signed-off-by: Stefan Agner <stefan.agner@yahoo.com>
    Signed-off-by: Nicolas Pitre <nico@marvell.com>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index de8a001fc3a9..b856cec81702 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -17,6 +17,9 @@
 #include <linux/irq.h>
 #include <asm/mach/time.h>
 #include <mach/bridge-regs.h>
+#include <mach/hardware.h>
+#include <linux/sched.h>
+#include <linux/cnt32_to_63.h>
 
 /*
  * Number of timer ticks per jiffy.
@@ -38,6 +41,36 @@ static u32 ticks_per_jiffy;
 #define TIMER1_VAL		(TIMER_VIRT_BASE + 0x001c)
 
 
+/*
+ * Orion's sched_clock implementation. It has a resolution of
+ * at least 7.5ns (133MHz TCLK) and a maximum value of 834 days.
+ */
+#define TCLK2NS_SCALE_FACTOR 8
+
+static unsigned long tclk2ns_scale;
+
+static void __init set_tclk2ns_scale(unsigned long tclk)
+{
+	unsigned long long v = NSEC_PER_SEC;
+	v <<= TCLK2NS_SCALE_FACTOR;
+	v += tclk/2;
+	do_div(v, tclk);
+	/*
+	 * We want an even value to automatically clear the top bit
+	 * returned by cnt32_to_63() without an additional run time
+	 * instruction. So if the LSB is 1 then round it up.
+	 */
+	if (v & 1)
+		v++;
+	tclk2ns_scale = v;
+}
+
+unsigned long long sched_clock(void)
+{
+	unsigned long long v = cnt32_to_63(0xffffffff - readl(TIMER0_VAL));
+	return (v * tclk2ns_scale) >> TCLK2NS_SCALE_FACTOR;
+}
+
 /*
  * Clocksource handling.
  */
@@ -176,6 +209,10 @@ void __init orion_time_init(unsigned int irq, unsigned int tclk)
 
 	ticks_per_jiffy = (tclk + HZ/2) / HZ;
 
+	/*
+	 * Set scale for sched_clock
+	 */
+	set_tclk2ns_scale(tclk);
 
 	/*
 	 * Setup free-running clocksource timer (interrupts

commit 6ae85d6db4871d8dbcb5cc0e9056f97f1ca07061
Merge: d72cd3a90e4d fdd8b079e33d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 24 08:36:41 2009 -0700

    Merge master.kernel.org:/home/rmk/linux-2.6-arm
    
    * master.kernel.org:/home/rmk/linux-2.6-arm:
      [ARM] 5460/1: Orion: reduce namespace pollution
      [ARM] 5458/1: pcmcia: pxa2xx-sharpsl: check if we do have Scoop config
      [ARM] 5457/1: mach-imx gpio buildfix
      [ARM] 5456/1: add sys_preadv and sys_pwritev
      [ARM] pxa/pcm990: start external GPIOs immediately after built-in ones
      [ARM] pxa/palm27x: General fix for Palm27x aSoC driver
      [ARM] pxa/mioa701: use GPIO95 as AC97 reset line
      [ARM] pxa: merge AC97 platform data structures
      [ARM] pxa/magician: remove un-necessary #include of pxa-regs.h and hardware.h

commit fdd8b079e33d4711527ace19798e9db99a056469
Author: Nicolas Pitre <nico@cam.org>
Date:   Wed Apr 22 20:08:17 2009 +0100

    [ARM] 5460/1: Orion: reduce namespace pollution
    
    Symbols like SOFT_RESET are way too generic to be exported at large.
    To avoid this, let's move the mbus bridge register defines into a
    separate file and include it where needed.  This affects mach-kirkwood,
    mach-loki, mach-mv78xx0 and mach-orion5x simultaneously as they all
    share code in plat-orion which relies on those defines.
    
    Some other defines have been moved to narrower scopes, or simply deleted
    when they had no user.
    
    This fixes compilation problem with mpt2sas on the above listed
    platforms.
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index 6fa2923e6dca..bdeb166b4b20 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -16,7 +16,7 @@
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <asm/mach/time.h>
-#include <mach/hardware.h>
+#include <mach/bridge-regs.h>
 
 /*
  * Number of timer ticks per jiffy.

commit 8e19608e8b5c001e4a66ce482edc474f05fb7355
Author: Magnus Damm <damm@igel.co.jp>
Date:   Tue Apr 21 12:24:00 2009 -0700

    clocksource: pass clocksource to read() callback
    
    Pass clocksource pointer to the read() callback for clocksources.  This
    allows us to share the callback between multiple instances.
    
    [hugh@veritas.com: fix powerpc build of clocksource pass clocksource mods]
    [akpm@linux-foundation.org: cleanup]
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Hugh Dickins <hugh@veritas.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index 6fa2923e6dca..2faf9dba4ef7 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -41,7 +41,7 @@ static u32 ticks_per_jiffy;
 /*
  * Clocksource handling.
  */
-static cycle_t orion_clksrc_read(void)
+static cycle_t orion_clksrc_read(struct clocksource *cs)
 {
 	return 0xffffffff - readl(TIMER0_VAL);
 }

commit 320ab2b0b1e08e3805a3e1084a2f0eb1938d5d67
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Sat Dec 13 21:20:26 2008 +1030

    cpumask: convert struct clock_event_device to cpumask pointers.
    
    Impact: change calling convention of existing clock_event APIs
    
    struct clock_event_timer's cpumask field gets changed to take pointer,
    as does the ->broadcast function.
    
    Another single-patch change.  For safety, we BUG_ON() in
    clockevents_register_device() if it's not set.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index 544d6b327f3a..6fa2923e6dca 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -149,7 +149,6 @@ static struct clock_event_device orion_clkevt = {
 	.features	= CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_PERIODIC,
 	.shift		= 32,
 	.rating		= 300,
-	.cpumask	= CPU_MASK_CPU0,
 	.set_next_event	= orion_clkevt_next_event,
 	.set_mode	= orion_clkevt_mode,
 };
@@ -199,5 +198,6 @@ void __init orion_time_init(unsigned int irq, unsigned int tclk)
 	orion_clkevt.mult = div_sc(tclk, NSEC_PER_SEC, orion_clkevt.shift);
 	orion_clkevt.max_delta_ns = clockevent_delta2ns(0xfffffffe, &orion_clkevt);
 	orion_clkevt.min_delta_ns = clockevent_delta2ns(1, &orion_clkevt);
+	orion_clkevt.cpumask = cpumask_of(0);
 	clockevents_register_device(&orion_clkevt);
 }

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index 93c4ef9f0067..544d6b327f3a 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -16,7 +16,7 @@
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <asm/mach/time.h>
-#include <asm/arch/hardware.h>
+#include <mach/hardware.h>
 
 /*
  * Number of timer ticks per jiffy.

commit 1219715de70956557b9dedf3ee021a73d4f4ec52
Author: Ke Wei <kewei@marvell.com>
Date:   Fri May 23 10:23:22 2008 +0200

    [ARM] Orion: add a separate BRIDGE_INT_TIMER1_CLR define
    
    Some Feroceon-based SoCs have an MBUS bridge interrupt controller
    that requires writing a one instead of a zero to clear edge
    interrupt sources such as timer expiry.
    
    This patch adds a new BRIDGE_INT_TIMER1_CLR define, which platform
    code can set to either ~BRIDGE_INT_TIMER1 (write-zero-to-clear) or
    BRIDGE_INT_TIMER1 (write-one-to-clear) depending on the platform.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index 28b5285446e8..93c4ef9f0067 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -74,7 +74,7 @@ orion_clkevt_next_event(unsigned long delta, struct clock_event_device *dev)
 	/*
 	 * Clear and enable clockevent timer interrupt.
 	 */
-	writel(~BRIDGE_INT_TIMER1, BRIDGE_CAUSE);
+	writel(BRIDGE_INT_TIMER1_CLR, BRIDGE_CAUSE);
 
 	u = readl(BRIDGE_MASK);
 	u |= BRIDGE_INT_TIMER1;
@@ -138,7 +138,7 @@ orion_clkevt_mode(enum clock_event_mode mode, struct clock_event_device *dev)
 		/*
 		 * ACK pending timer interrupt.
 		 */
-		writel(~BRIDGE_INT_TIMER1, BRIDGE_CAUSE);
+		writel(BRIDGE_INT_TIMER1_CLR, BRIDGE_CAUSE);
 
 	}
 	local_irq_restore(flags);
@@ -159,7 +159,7 @@ static irqreturn_t orion_timer_interrupt(int irq, void *dev_id)
 	/*
 	 * ACK timer interrupt and call event handler.
 	 */
-	writel(~BRIDGE_INT_TIMER1, BRIDGE_CAUSE);
+	writel(BRIDGE_INT_TIMER1_CLR, BRIDGE_CAUSE);
 	orion_clkevt.event_handler(&orion_clkevt);
 
 	return IRQ_HANDLED;

commit 2bac1de2031aa4cad88a437d4410ec289da4f7dc
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Thu Mar 27 14:51:40 2008 -0400

    plat-orion: share time handling code
    
    Split off Orion time handling code into plat-orion/.
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Reviewed-by: Tzachi Perelstein <tzachi@marvell.com>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Nicolas Pitre <nico@marvell.com>

diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
new file mode 100644
index 000000000000..28b5285446e8
--- /dev/null
+++ b/arch/arm/plat-orion/time.c
@@ -0,0 +1,203 @@
+/*
+ * arch/arm/plat-orion/time.c
+ *
+ * Marvell Orion SoC timer handling.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ *
+ * Timer 0 is used as free-running clocksource, while timer 1 is
+ * used as clock_event_device.
+ */
+
+#include <linux/kernel.h>
+#include <linux/clockchips.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <asm/mach/time.h>
+#include <asm/arch/hardware.h>
+
+/*
+ * Number of timer ticks per jiffy.
+ */
+static u32 ticks_per_jiffy;
+
+
+/*
+ * Timer block registers.
+ */
+#define TIMER_CTRL		(TIMER_VIRT_BASE + 0x0000)
+#define  TIMER0_EN		0x0001
+#define  TIMER0_RELOAD_EN	0x0002
+#define  TIMER1_EN		0x0004
+#define  TIMER1_RELOAD_EN	0x0008
+#define TIMER0_RELOAD		(TIMER_VIRT_BASE + 0x0010)
+#define TIMER0_VAL		(TIMER_VIRT_BASE + 0x0014)
+#define TIMER1_RELOAD		(TIMER_VIRT_BASE + 0x0018)
+#define TIMER1_VAL		(TIMER_VIRT_BASE + 0x001c)
+
+
+/*
+ * Clocksource handling.
+ */
+static cycle_t orion_clksrc_read(void)
+{
+	return 0xffffffff - readl(TIMER0_VAL);
+}
+
+static struct clocksource orion_clksrc = {
+	.name		= "orion_clocksource",
+	.shift		= 20,
+	.rating		= 300,
+	.read		= orion_clksrc_read,
+	.mask		= CLOCKSOURCE_MASK(32),
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+
+
+/*
+ * Clockevent handling.
+ */
+static int
+orion_clkevt_next_event(unsigned long delta, struct clock_event_device *dev)
+{
+	unsigned long flags;
+	u32 u;
+
+	if (delta == 0)
+		return -ETIME;
+
+	local_irq_save(flags);
+
+	/*
+	 * Clear and enable clockevent timer interrupt.
+	 */
+	writel(~BRIDGE_INT_TIMER1, BRIDGE_CAUSE);
+
+	u = readl(BRIDGE_MASK);
+	u |= BRIDGE_INT_TIMER1;
+	writel(u, BRIDGE_MASK);
+
+	/*
+	 * Setup new clockevent timer value.
+	 */
+	writel(delta, TIMER1_VAL);
+
+	/*
+	 * Enable the timer.
+	 */
+	u = readl(TIMER_CTRL);
+	u = (u & ~TIMER1_RELOAD_EN) | TIMER1_EN;
+	writel(u, TIMER_CTRL);
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static void
+orion_clkevt_mode(enum clock_event_mode mode, struct clock_event_device *dev)
+{
+	unsigned long flags;
+	u32 u;
+
+	local_irq_save(flags);
+	if (mode == CLOCK_EVT_MODE_PERIODIC) {
+		/*
+		 * Setup timer to fire at 1/HZ intervals.
+		 */
+		writel(ticks_per_jiffy - 1, TIMER1_RELOAD);
+		writel(ticks_per_jiffy - 1, TIMER1_VAL);
+
+		/*
+		 * Enable timer interrupt.
+		 */
+		u = readl(BRIDGE_MASK);
+		writel(u | BRIDGE_INT_TIMER1, BRIDGE_MASK);
+
+		/*
+		 * Enable timer.
+		 */
+		u = readl(TIMER_CTRL);
+		writel(u | TIMER1_EN | TIMER1_RELOAD_EN, TIMER_CTRL);
+	} else {
+		/*
+		 * Disable timer.
+		 */
+		u = readl(TIMER_CTRL);
+		writel(u & ~TIMER1_EN, TIMER_CTRL);
+
+		/*
+		 * Disable timer interrupt.
+		 */
+		u = readl(BRIDGE_MASK);
+		writel(u & ~BRIDGE_INT_TIMER1, BRIDGE_MASK);
+
+		/*
+		 * ACK pending timer interrupt.
+		 */
+		writel(~BRIDGE_INT_TIMER1, BRIDGE_CAUSE);
+
+	}
+	local_irq_restore(flags);
+}
+
+static struct clock_event_device orion_clkevt = {
+	.name		= "orion_tick",
+	.features	= CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_PERIODIC,
+	.shift		= 32,
+	.rating		= 300,
+	.cpumask	= CPU_MASK_CPU0,
+	.set_next_event	= orion_clkevt_next_event,
+	.set_mode	= orion_clkevt_mode,
+};
+
+static irqreturn_t orion_timer_interrupt(int irq, void *dev_id)
+{
+	/*
+	 * ACK timer interrupt and call event handler.
+	 */
+	writel(~BRIDGE_INT_TIMER1, BRIDGE_CAUSE);
+	orion_clkevt.event_handler(&orion_clkevt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction orion_timer_irq = {
+	.name		= "orion_tick",
+	.flags		= IRQF_DISABLED | IRQF_TIMER,
+	.handler	= orion_timer_interrupt
+};
+
+void __init orion_time_init(unsigned int irq, unsigned int tclk)
+{
+	u32 u;
+
+	ticks_per_jiffy = (tclk + HZ/2) / HZ;
+
+
+	/*
+	 * Setup free-running clocksource timer (interrupts
+	 * disabled.)
+	 */
+	writel(0xffffffff, TIMER0_VAL);
+	writel(0xffffffff, TIMER0_RELOAD);
+	u = readl(BRIDGE_MASK);
+	writel(u & ~BRIDGE_INT_TIMER0, BRIDGE_MASK);
+	u = readl(TIMER_CTRL);
+	writel(u | TIMER0_EN | TIMER0_RELOAD_EN, TIMER_CTRL);
+	orion_clksrc.mult = clocksource_hz2mult(tclk, orion_clksrc.shift);
+	clocksource_register(&orion_clksrc);
+
+
+	/*
+	 * Setup clockevent timer (interrupt-driven.)
+	 */
+	setup_irq(irq, &orion_timer_irq);
+	orion_clkevt.mult = div_sc(tclk, NSEC_PER_SEC, orion_clkevt.shift);
+	orion_clkevt.max_delta_ns = clockevent_delta2ns(0xfffffffe, &orion_clkevt);
+	orion_clkevt.min_delta_ns = clockevent_delta2ns(1, &orion_clkevt);
+	clockevents_register_device(&orion_clkevt);
+}
