commit d3532910038bb1e95e9c5952e98dd1d18b636e8b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Aug 9 16:40:38 2019 +0200

    ARM: lpc32xx: clean up header files
    
    All device drivers have stopped relying on mach/*.h headers,
    so move the remaining headers into arch/arm/mach-lpc32xx/lpc32xx.h
    to prepare for multiplatform builds.
    
    The mach/entry-macro.S file has been unused for a long time now
    and can simply get removed.
    
    Link: https://lore.kernel.org/r/20190809144043.476786-13-arnd@arndb.de
    Acked-by: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-lpc32xx/pm.c b/arch/arm/mach-lpc32xx/pm.c
index 32bca351a73b..b27fa1b9f56c 100644
--- a/arch/arm/mach-lpc32xx/pm.c
+++ b/arch/arm/mach-lpc32xx/pm.c
@@ -70,8 +70,7 @@
 
 #include <asm/cacheflush.h>
 
-#include <mach/hardware.h>
-#include <mach/platform.h>
+#include "lpc32xx.h"
 #include "common.h"
 
 #define TEMP_IRAM_AREA  IO_ADDRESS(LPC32XX_IRAM_BASE)

commit 801da462e88dadad046bd24e0c4fdaa2fb95ee36
Author: zhong jiang <zhongjiang@huawei.com>
Date:   Fri Aug 10 10:40:51 2018 +0800

    ARM: lpc32xx: Use kmemdup to replace duplicating its implementation
    
    kmemdup is better than kmalloc() + memcpy(), and we do not like
    open code. So just use kmemdup instead.
    
    Signed-off-by: zhong jiang <zhongjiang@huawei.com>
    [vzapolskiy: resolved a merge conflict]
    Signed-off-by: Vladimir Zapolskiy <vz@mleia.com>

diff --git a/arch/arm/mach-lpc32xx/pm.c b/arch/arm/mach-lpc32xx/pm.c
index 5a4d31488d11..32bca351a73b 100644
--- a/arch/arm/mach-lpc32xx/pm.c
+++ b/arch/arm/mach-lpc32xx/pm.c
@@ -86,14 +86,11 @@ static int lpc32xx_pm_enter(suspend_state_t state)
 	void *iram_swap_area;
 
 	/* Allocate some space for temporary IRAM storage */
-	iram_swap_area = kmalloc(lpc32xx_sys_suspend_sz, GFP_KERNEL);
+	iram_swap_area = kmemdup((void *)TEMP_IRAM_AREA,
+				 lpc32xx_sys_suspend_sz, GFP_KERNEL);
 	if (!iram_swap_area)
 		return -ENOMEM;
 
-	/* Backup a small area of IRAM used for the suspend code */
-	memcpy(iram_swap_area, (void *) TEMP_IRAM_AREA,
-		lpc32xx_sys_suspend_sz);
-
 	/*
 	 * Copy code to suspend system into IRAM. The suspend code
 	 * needs to run from IRAM as DRAM may no longer be available

commit ac04fd656928e223ab7eca654d5e83b7f77ffc7b
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Jun 1 19:50:32 2017 +0200

    ARM: lpc32xx: Delete an error message for a failed memory allocation in lpc32xx_pm_enter()
    
    Omit an extra message for a memory allocation failure in this function.
    
    This issue was detected by using the Coccinelle software.
    
    Link: http://events.linuxfoundation.org/sites/events/files/slides/LCJ16-Refactor_Strings-WSang_0.pdf
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Vladimir Zapolskiy <vz@mleia.com>

diff --git a/arch/arm/mach-lpc32xx/pm.c b/arch/arm/mach-lpc32xx/pm.c
index 62471570d586..5a4d31488d11 100644
--- a/arch/arm/mach-lpc32xx/pm.c
+++ b/arch/arm/mach-lpc32xx/pm.c
@@ -87,12 +87,8 @@ static int lpc32xx_pm_enter(suspend_state_t state)
 
 	/* Allocate some space for temporary IRAM storage */
 	iram_swap_area = kmalloc(lpc32xx_sys_suspend_sz, GFP_KERNEL);
-	if (!iram_swap_area) {
-		printk(KERN_ERR
-		       "PM Suspend: cannot allocate memory to save portion "
-			"of SRAM\n");
+	if (!iram_swap_area)
 		return -ENOMEM;
-	}
 
 	/* Backup a small area of IRAM used for the suspend code */
 	memcpy(iram_swap_area, (void *) TEMP_IRAM_AREA,

commit d1193df9c3cbce699d07c352bb3c055cd827db4d
Author: Vladimir Zapolskiy <vz@mleia.com>
Date:   Thu Sep 8 06:00:09 2016 +0300

    ARM: lpc32xx: remove unused header file clock.h
    
    The removed clock.h file is a leftover after moving the platform to a
    common clock framework driver, it contains unused "struct clk"
    definition, which under circumstances may coalesce with a generic
    "struct clk" declaration for clock consumers. Also remove useless
    include of the removed local file from a single source file
    mach-lpc32xx/pm.c.
    
    Signed-off-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Sylvain Lemieux <slemieux.tyco@gmail.com>

diff --git a/arch/arm/mach-lpc32xx/pm.c b/arch/arm/mach-lpc32xx/pm.c
index 207e81275ff0..62471570d586 100644
--- a/arch/arm/mach-lpc32xx/pm.c
+++ b/arch/arm/mach-lpc32xx/pm.c
@@ -73,7 +73,6 @@
 #include <mach/hardware.h>
 #include <mach/platform.h>
 #include "common.h"
-#include "clock.h"
 
 #define TEMP_IRAM_AREA  IO_ADDRESS(LPC32XX_IRAM_BASE)
 

commit cfac337b0fbcad5181096ab72bb24a05bd444562
Author: Roland Stigge <stigge@antcom.de>
Date:   Mon Feb 27 17:31:24 2012 +0100

    ARM: LPC32xx: Fix missing and bad LPC32XX macros
    
    Some of the LPC32XX_* macros were typed ("LCP32XX_*"), which is fixed by this
    patch. (Besides another LCP doc typo.)
    
    Further, the LPC32XX_GPIO_P2_MUX_SET/CLR/STATE macros were missing.
    
    Signed-off-by: Roland Stigge <stigge@antcom.de>

diff --git a/arch/arm/mach-lpc32xx/pm.c b/arch/arm/mach-lpc32xx/pm.c
index b9c80597b7bf..207e81275ff0 100644
--- a/arch/arm/mach-lpc32xx/pm.c
+++ b/arch/arm/mach-lpc32xx/pm.c
@@ -13,7 +13,7 @@
 /*
  * LPC32XX CPU and system power management
  *
- * The LCP32XX has three CPU modes for controlling system power: run,
+ * The LPC32XX has three CPU modes for controlling system power: run,
  * direct-run, and halt modes. When switching between halt and run modes,
  * the CPU transistions through direct-run mode. For Linux, direct-run
  * mode is not used in normal operation. Halt mode is used when the

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/arch/arm/mach-lpc32xx/pm.c b/arch/arm/mach-lpc32xx/pm.c
index e76d41bb7056..b9c80597b7bf 100644
--- a/arch/arm/mach-lpc32xx/pm.c
+++ b/arch/arm/mach-lpc32xx/pm.c
@@ -41,7 +41,7 @@
  * DRAM clocking and refresh are slightly different for systems with DDR
  * DRAM or regular SDRAM devices. If SDRAM is used in the system, the
  * SDRAM will still be accessible in direct-run mode. In DDR based systems,
- * a transistion to direct-run mode will stop all DDR accesses (no clocks).
+ * a transition to direct-run mode will stop all DDR accesses (no clocks).
  * Because of this, the code to switch power modes and the code to enter
  * and exit DRAM self-refresh modes must not be executed in DRAM. A small
  * section of IRAM is used instead for this.

commit 2f55ac072f5344519348c0c94b3d2f4cca46847b
Author: Lionel Debroux <lionel_debroux@yahoo.fr>
Date:   Tue Nov 16 14:14:02 2010 +0100

    suspend: constify platform_suspend_ops
    
    While at it, fix two checkpatch errors.
    Several non-const struct instances constified by this patch were added after
    the introduction of platform_suspend_ops in checkpatch.pl's list of "should
    be const" structs (79404849e90a41ea2109bd0e2f7c7164b0c4ce73).
    
    Patch against mainline.
    Inspired by hunks of the grsecurity patch, updated for newer kernels.
    
    Signed-off-by: Lionel Debroux <lionel_debroux@yahoo.fr>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/arch/arm/mach-lpc32xx/pm.c b/arch/arm/mach-lpc32xx/pm.c
index a6e2aed9a49f..e76d41bb7056 100644
--- a/arch/arm/mach-lpc32xx/pm.c
+++ b/arch/arm/mach-lpc32xx/pm.c
@@ -123,7 +123,7 @@ static int lpc32xx_pm_enter(suspend_state_t state)
 	return 0;
 }
 
-static struct platform_suspend_ops lpc32xx_pm_ops = {
+static const struct platform_suspend_ops lpc32xx_pm_ops = {
 	.valid	= suspend_valid_only_mem,
 	.enter	= lpc32xx_pm_enter,
 };

commit 3c0e1947d9c171649f3bde13d1010ac6d7ce09c1
Author: Kevin Wells <wellsk40@gmail.com>
Date:   Tue Jul 27 08:35:56 2010 -0700

    ARM: LPC32XX: System suspend support
    
    Support for system suspend and resume
    
    Signed-off-by: Kevin Wells <wellsk40@gmail.com>

diff --git a/arch/arm/mach-lpc32xx/pm.c b/arch/arm/mach-lpc32xx/pm.c
new file mode 100644
index 000000000000..a6e2aed9a49f
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/pm.c
@@ -0,0 +1,146 @@
+/*
+ * arch/arm/mach-lpc32xx/pm.c
+ *
+ * Original authors: Vitaly Wool, Dmitry Chigirev <source@mvista.com>
+ * Modified by Kevin Wells <kevin.wells@nxp.com>
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+/*
+ * LPC32XX CPU and system power management
+ *
+ * The LCP32XX has three CPU modes for controlling system power: run,
+ * direct-run, and halt modes. When switching between halt and run modes,
+ * the CPU transistions through direct-run mode. For Linux, direct-run
+ * mode is not used in normal operation. Halt mode is used when the
+ * system is fully suspended.
+ *
+ * Run mode:
+ * The ARM CPU clock (HCLK_PLL), HCLK bus clock, and PCLK bus clocks are
+ * derived from the HCLK PLL. The HCLK and PCLK bus rates are divided from
+ * the HCLK_PLL rate. Linux runs in this mode.
+ *
+ * Direct-run mode:
+ * The ARM CPU clock, HCLK bus clock, and PCLK bus clocks are driven from
+ * SYSCLK. SYSCLK is usually around 13MHz, but may vary based on SYSCLK
+ * source or the frequency of the main oscillator. In this mode, the
+ * HCLK_PLL can be safely enabled, changed, or disabled.
+ *
+ * Halt mode:
+ * SYSCLK is gated off and the CPU and system clocks are halted.
+ * Peripherals based on the 32KHz oscillator clock (ie, RTC, touch,
+ * key scanner, etc.) still operate if enabled. In this state, an enabled
+ * system event (ie, GPIO state change, RTC match, key press, etc.) will
+ * wake the system up back into direct-run mode.
+ *
+ * DRAM refresh
+ * DRAM clocking and refresh are slightly different for systems with DDR
+ * DRAM or regular SDRAM devices. If SDRAM is used in the system, the
+ * SDRAM will still be accessible in direct-run mode. In DDR based systems,
+ * a transistion to direct-run mode will stop all DDR accesses (no clocks).
+ * Because of this, the code to switch power modes and the code to enter
+ * and exit DRAM self-refresh modes must not be executed in DRAM. A small
+ * section of IRAM is used instead for this.
+ *
+ * Suspend is handled with the following logic:
+ *  Backup a small area of IRAM used for the suspend code
+ *  Copy suspend code to IRAM
+ *  Transfer control to code in IRAM
+ *  Places DRAMs in self-refresh mode
+ *  Enter direct-run mode
+ *  Save state of HCLK_PLL PLL
+ *  Disable HCLK_PLL PLL
+ *  Enter halt mode - CPU and buses will stop
+ *  System enters direct-run mode when an enabled event occurs
+ *  HCLK PLL state is restored
+ *  Run mode is entered
+ *  DRAMS are placed back into normal mode
+ *  Code execution returns from IRAM
+ *  IRAM code are used for suspend is restored
+ *  Suspend mode is exited
+ */
+
+#include <linux/suspend.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+
+#include <asm/cacheflush.h>
+
+#include <mach/hardware.h>
+#include <mach/platform.h>
+#include "common.h"
+#include "clock.h"
+
+#define TEMP_IRAM_AREA  IO_ADDRESS(LPC32XX_IRAM_BASE)
+
+/*
+ * Both STANDBY and MEM suspend states are handled the same with no
+ * loss of CPU or memory state
+ */
+static int lpc32xx_pm_enter(suspend_state_t state)
+{
+	int (*lpc32xx_suspend_ptr) (void);
+	void *iram_swap_area;
+
+	/* Allocate some space for temporary IRAM storage */
+	iram_swap_area = kmalloc(lpc32xx_sys_suspend_sz, GFP_KERNEL);
+	if (!iram_swap_area) {
+		printk(KERN_ERR
+		       "PM Suspend: cannot allocate memory to save portion "
+			"of SRAM\n");
+		return -ENOMEM;
+	}
+
+	/* Backup a small area of IRAM used for the suspend code */
+	memcpy(iram_swap_area, (void *) TEMP_IRAM_AREA,
+		lpc32xx_sys_suspend_sz);
+
+	/*
+	 * Copy code to suspend system into IRAM. The suspend code
+	 * needs to run from IRAM as DRAM may no longer be available
+	 * when the PLL is stopped.
+	 */
+	memcpy((void *) TEMP_IRAM_AREA, &lpc32xx_sys_suspend,
+		lpc32xx_sys_suspend_sz);
+	flush_icache_range((unsigned long)TEMP_IRAM_AREA,
+		(unsigned long)(TEMP_IRAM_AREA) + lpc32xx_sys_suspend_sz);
+
+	/* Transfer to suspend code in IRAM */
+	lpc32xx_suspend_ptr = (void *) TEMP_IRAM_AREA;
+	flush_cache_all();
+	(void) lpc32xx_suspend_ptr();
+
+	/* Restore original IRAM contents */
+	memcpy((void *) TEMP_IRAM_AREA, iram_swap_area,
+		lpc32xx_sys_suspend_sz);
+
+	kfree(iram_swap_area);
+
+	return 0;
+}
+
+static struct platform_suspend_ops lpc32xx_pm_ops = {
+	.valid	= suspend_valid_only_mem,
+	.enter	= lpc32xx_pm_enter,
+};
+
+#define EMC_DYN_MEM_CTRL_OFS 0x20
+#define EMC_SRMMC           (1 << 3)
+#define EMC_CTRL_REG io_p2v(LPC32XX_EMC_BASE + EMC_DYN_MEM_CTRL_OFS)
+static int __init lpc32xx_pm_init(void)
+{
+	/*
+	 * Setup SDRAM self-refresh clock to automatically disable o
+	 * start of self-refresh. This only needs to be done once.
+	 */
+	__raw_writel(__raw_readl(EMC_CTRL_REG) | EMC_SRMMC, EMC_CTRL_REG);
+
+	suspend_set_ops(&lpc32xx_pm_ops);
+
+	return 0;
+}
+arch_initcall(lpc32xx_pm_init);
