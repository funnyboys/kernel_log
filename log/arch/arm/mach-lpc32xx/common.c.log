commit d3532910038bb1e95e9c5952e98dd1d18b636e8b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Aug 9 16:40:38 2019 +0200

    ARM: lpc32xx: clean up header files
    
    All device drivers have stopped relying on mach/*.h headers,
    so move the remaining headers into arch/arm/mach-lpc32xx/lpc32xx.h
    to prepare for multiplatform builds.
    
    The mach/entry-macro.S file has been unused for a long time now
    and can simply get removed.
    
    Link: https://lore.kernel.org/r/20190809144043.476786-13-arnd@arndb.de
    Acked-by: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index a475339333c1..304ea61a0716 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -13,8 +13,7 @@
 #include <asm/mach/map.h>
 #include <asm/system_info.h>
 
-#include <mach/hardware.h>
-#include <mach/platform.h>
+#include "lpc32xx.h"
 #include "common.h"
 
 /*

commit ecca1a6277aac10e40e4baba28adb893899b24b3
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Aug 9 16:40:33 2019 +0200

    net: lpc-enet: move phy setup into platform code
    
    Setting the phy mode requires touching a platform specific
    register, which prevents us from building the driver without
    its header files.
    
    Move it into a separate function in arch/arm/mach/lpc32xx
    to hide the core registers from the network driver.
    
    Link: https://lore.kernel.org/r/20190809144043.476786-8-arnd@arndb.de
    Acked-by: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index f648324d5fb4..a475339333c1 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -63,6 +63,18 @@ u32 lpc32xx_return_iram(void __iomem **mapbase, dma_addr_t *dmaaddr)
 }
 EXPORT_SYMBOL_GPL(lpc32xx_return_iram);
 
+void lpc32xx_set_phy_interface_mode(phy_interface_t mode)
+{
+	u32 tmp = __raw_readl(LPC32XX_CLKPWR_MACCLK_CTRL);
+	tmp &= ~LPC32XX_CLKPWR_MACCTRL_PINS_MSK;
+	if (mode == PHY_INTERFACE_MODE_MII)
+		tmp |= LPC32XX_CLKPWR_MACCTRL_USE_MII_PINS;
+	else
+		tmp |= LPC32XX_CLKPWR_MACCTRL_USE_RMII_PINS;
+	__raw_writel(tmp, LPC32XX_CLKPWR_MACCLK_CTRL);
+}
+EXPORT_SYMBOL_GPL(lpc32xx_set_phy_interface_mode);
+
 static struct map_desc lpc32xx_io_desc[] __initdata = {
 	{
 		.virtual	= (unsigned long)IO_ADDRESS(LPC32XX_AHB0_START),

commit 9dc03ffd996d4103cc2a11286d61e517bce27440
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Aug 9 16:40:32 2019 +0200

    net: lpc-enet: factor out iram access
    
    The lpc_eth driver uses a platform specific method to find
    the internal sram. This prevents building it on other machines.
    
    Rework to only use one function call and keep the other platform
    internals where they belong. Ideally this would look up the
    sram location from DT, but as this is a rarely used driver,
    I want to keep the modifications to a minimum.
    
    Link: https://lore.kernel.org/r/20190809144043.476786-7-arnd@arndb.de
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index 5b71b4fab2cd..f648324d5fb4 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -8,6 +8,7 @@
  */
 
 #include <linux/init.h>
+#include <linux/soc/nxp/lpc32xx-misc.h>
 
 #include <asm/mach/map.h>
 #include <asm/system_info.h>
@@ -32,7 +33,7 @@ void lpc32xx_get_uid(u32 devid[4])
  */
 #define LPC32XX_IRAM_BANK_SIZE SZ_128K
 static u32 iram_size;
-u32 lpc32xx_return_iram_size(void)
+u32 lpc32xx_return_iram(void __iomem **mapbase, dma_addr_t *dmaaddr)
 {
 	if (iram_size == 0) {
 		u32 savedval1, savedval2;
@@ -53,10 +54,14 @@ u32 lpc32xx_return_iram_size(void)
 		} else
 			iram_size = LPC32XX_IRAM_BANK_SIZE * 2;
 	}
+	if (dmaaddr)
+		*dmaaddr = LPC32XX_IRAM_BASE;
+	if (mapbase)
+		*mapbase = io_p2v(LPC32XX_IRAM_BASE);
 
 	return iram_size;
 }
-EXPORT_SYMBOL_GPL(lpc32xx_return_iram_size);
+EXPORT_SYMBOL_GPL(lpc32xx_return_iram);
 
 static struct map_desc lpc32xx_io_desc[] __initdata = {
 	{

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index 2f6067bce7c3..5b71b4fab2cd 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -1,19 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * arch/arm/mach-lpc32xx/common.c
  *
  * Author: Kevin Wells <kevin.wells@nxp.com>
  *
  * Copyright (C) 2010 NXP Semiconductors
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #include <linux/init.h>

commit d82b4b0a5ebeb55c3b88e49b38135a847736e6b5
Author: Vladimir Zapolskiy <vz@mleia.com>
Date:   Mon Apr 18 04:05:25 2016 +0300

    ARM: lpc32xx: remove leftovers of legacy clock source and provider drivers
    
    After switching the platform to common clock framework there is no
    more need to keep dead code in arch/arm/mach-lpc32xx, which glued
    legacy clock source and clock provider drivers, remove the leftovers.
    
    Acked-by: Sylvain Lemieux <slemieux.tyco@gmail.com>
    Signed-off-by: Vladimir Zapolskiy <vz@mleia.com>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index 5b7a1e78c3a5..2f6067bce7c3 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -17,13 +17,6 @@
  */
 
 #include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/err.h>
-#include <linux/i2c.h>
-#include <linux/i2c-pnx.h>
-#include <linux/io.h>
 
 #include <asm/mach/map.h>
 #include <asm/system_info.h>
@@ -43,19 +36,6 @@ void lpc32xx_get_uid(u32 devid[4])
 		devid[i] = __raw_readl(LPC32XX_CLKPWR_DEVID(i << 2));
 }
 
-/*
- * Returns SYSCLK source
- * 0 = PLL397, 1 = main oscillator
- */
-int clk_is_sysclk_mainosc(void)
-{
-	if ((__raw_readl(LPC32XX_CLKPWR_SYSCLK_CTRL) &
-		LPC32XX_CLKPWR_SYSCTRL_SYSCLKMUX) == 0)
-		return 1;
-
-	return 0;
-}
-
 /*
  * Detects and returns IRAM size for the device variation
  */
@@ -87,81 +67,6 @@ u32 lpc32xx_return_iram_size(void)
 }
 EXPORT_SYMBOL_GPL(lpc32xx_return_iram_size);
 
-/*
- * Computes PLL rate from PLL register and input clock
- */
-u32 clk_check_pll_setup(u32 ifreq, struct clk_pll_setup *pllsetup)
-{
-	u32 ilfreq, p, m, n, fcco, fref, cfreq;
-	int mode;
-
-	/*
-	 * PLL requirements
-	 * ifreq must be >= 1MHz and <= 20MHz
-	 * FCCO must be >= 156MHz and <= 320MHz
-	 * FREF must be >= 1MHz and <= 27MHz
-	 * Assume the passed input data is not valid
-	 */
-
-	ilfreq = ifreq;
-	m = pllsetup->pll_m;
-	n = pllsetup->pll_n;
-	p = pllsetup->pll_p;
-
-	mode = (pllsetup->cco_bypass_b15 << 2) |
-		(pllsetup->direct_output_b14 << 1) |
-	pllsetup->fdbk_div_ctrl_b13;
-
-	switch (mode) {
-	case 0x0: /* Non-integer mode */
-		cfreq = (m * ilfreq) / (2 * p * n);
-		fcco = (m * ilfreq) / n;
-		fref = ilfreq / n;
-		break;
-
-	case 0x1: /* integer mode */
-		cfreq = (m * ilfreq) / n;
-		fcco = (m * ilfreq) / (n * 2 * p);
-		fref = ilfreq / n;
-		break;
-
-	case 0x2:
-	case 0x3: /* Direct mode */
-		cfreq = (m * ilfreq) / n;
-		fcco = cfreq;
-		fref = ilfreq / n;
-		break;
-
-	case 0x4:
-	case 0x5: /* Bypass mode */
-		cfreq = ilfreq / (2 * p);
-		fcco = 156000000;
-		fref = 1000000;
-		break;
-
-	case 0x6:
-	case 0x7: /* Direct bypass mode */
-	default:
-		cfreq = ilfreq;
-		fcco = 156000000;
-		fref = 1000000;
-		break;
-	}
-
-	if (fcco < 156000000 || fcco > 320000000)
-		cfreq = 0;
-
-	if (fref < 1000000 || fref > 27000000)
-		cfreq = 0;
-
-	return (u32) cfreq;
-}
-
-u32 clk_get_pclk_div(void)
-{
-	return 1 + ((__raw_readl(LPC32XX_CLKPWR_HCLK_DIV) >> 2) & 0x1F);
-}
-
 static struct map_desc lpc32xx_io_desc[] __initdata = {
 	{
 		.virtual	= (unsigned long)IO_ADDRESS(LPC32XX_AHB0_START),

commit e21f56219bf636b4abd15a0b076a1c5cba381501
Author: Sylvain Lemieux <slemieux@tycoint.com>
Date:   Fri Mar 4 13:44:10 2016 -0500

    arm: lpc32xx: remove restart handler
    
    Remove the restart handler from "mach-lpc32xx";
    this functionality is now available in the
    pnx4008 watchdog driver.
    
    Signed-off-by: Sylvain Lemieux <slemieux@tycoint.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index 716e83eb1db8..5b7a1e78c3a5 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -194,21 +194,6 @@ void __init lpc32xx_map_io(void)
 	iotable_init(lpc32xx_io_desc, ARRAY_SIZE(lpc32xx_io_desc));
 }
 
-void lpc23xx_restart(enum reboot_mode mode, const char *cmd)
-{
-	/* Make sure WDT clocks are enabled */
-	__raw_writel(LPC32XX_CLKPWR_PWMCLK_WDOG_EN,
-		LPC32XX_CLKPWR_TIMER_CLK_CTRL);
-
-	/* Instant assert of RESETOUT_N with pulse length 1mS */
-	__raw_writel(13000, io_p2v(LPC32XX_WDTIM_BASE + 0x18));
-	__raw_writel(0x70, io_p2v(LPC32XX_WDTIM_BASE + 0xC));
-
-	/* Wait for watchdog to reset system */
-	while (1)
-		;
-}
-
 static int __init lpc32xx_check_uid(void)
 {
 	u32 uid[4];

commit 01100c022df5d9b8ac56d3705e33e69dc012a6e2
Author: Roland Stigge <stigge@antcom.de>
Date:   Tue Sep 9 15:13:14 2014 +0200

    ARM: LPC32xx: Fix reset function
    
    In the recent change to the reset function API (commit
    7b6d864b48d95e6ea1df7df64475b9cb9616dcf9), the mode argument changed from a
    char to an enum. lpc23xx_restart() only handles REBOOT_SOFT and REBOOT_HARD,
    but the new kernel code emits REBOOT_COLD (0) on reboots now which leads to
    lpc32xx simply not rebooting (but halting).
    
    This patch fixes this by just resetting unconditionally as on other platforms
    (e.g. mach-bcm2835).
    
    Pulling lpc32xx_watchdog_reset() into lpc23xx_restart() since the while() in
    lpc23xx_restart() is part of the procedure anyway and lpc32xx_watchdog_reset()
    isn't used anywhere else anymore.
    
    Signed-off-by: Roland Stigge <stigge@antcom.de>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index de03620d7fa7..716e83eb1db8 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -56,20 +56,6 @@ int clk_is_sysclk_mainosc(void)
 	return 0;
 }
 
-/*
- * System reset via the watchdog timer
- */
-static void lpc32xx_watchdog_reset(void)
-{
-	/* Make sure WDT clocks are enabled */
-	__raw_writel(LPC32XX_CLKPWR_PWMCLK_WDOG_EN,
-		LPC32XX_CLKPWR_TIMER_CLK_CTRL);
-
-	/* Instant assert of RESETOUT_N with pulse length 1mS */
-	__raw_writel(13000, io_p2v(LPC32XX_WDTIM_BASE + 0x18));
-	__raw_writel(0x70, io_p2v(LPC32XX_WDTIM_BASE + 0xC));
-}
-
 /*
  * Detects and returns IRAM size for the device variation
  */
@@ -210,16 +196,13 @@ void __init lpc32xx_map_io(void)
 
 void lpc23xx_restart(enum reboot_mode mode, const char *cmd)
 {
-	switch (mode) {
-	case REBOOT_SOFT:
-	case REBOOT_HARD:
-		lpc32xx_watchdog_reset();
-		break;
+	/* Make sure WDT clocks are enabled */
+	__raw_writel(LPC32XX_CLKPWR_PWMCLK_WDOG_EN,
+		LPC32XX_CLKPWR_TIMER_CLK_CTRL);
 
-	default:
-		/* Do nothing */
-		break;
-	}
+	/* Instant assert of RESETOUT_N with pulse length 1mS */
+	__raw_writel(13000, io_p2v(LPC32XX_WDTIM_BASE + 0x18));
+	__raw_writel(0x70, io_p2v(LPC32XX_WDTIM_BASE + 0xC));
 
 	/* Wait for watchdog to reset system */
 	while (1)

commit 22833d55741d5e4941ffe455ea4f9d7564ca246c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Feb 17 20:21:55 2014 +0100

    ARM: lpc32xx: export lpc32xx_return_iram_size
    
    This symbol is used by the lpc_eth driver, which may
    be a loadable module.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Roland Stigge <stigge@antcom.de>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index d7aa54c25c59..de03620d7fa7 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -99,6 +99,7 @@ u32 lpc32xx_return_iram_size(void)
 
 	return iram_size;
 }
+EXPORT_SYMBOL_GPL(lpc32xx_return_iram_size);
 
 /*
  * Computes PLL rate from PLL register and input clock

commit 7b6d864b48d95e6ea1df7df64475b9cb9616dcf9
Author: Robin Holt <holt@sgi.com>
Date:   Mon Jul 8 16:01:40 2013 -0700

    reboot: arm: change reboot_mode to use enum reboot_mode
    
    Preparing to move the parsing of reboot= to generic kernel code forces
    the change in reboot_mode handling to use the enum.
    
    [akpm@linux-foundation.org: fix arch/arm/mach-socfpga/socfpga.c]
    Signed-off-by: Robin Holt <holt@sgi.com>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Russ Anderson <rja@sgi.com>
    Cc: Robin Holt <holt@sgi.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index 0d4db8c544b5..d7aa54c25c59 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -207,11 +207,11 @@ void __init lpc32xx_map_io(void)
 	iotable_init(lpc32xx_io_desc, ARRAY_SIZE(lpc32xx_io_desc));
 }
 
-void lpc23xx_restart(char mode, const char *cmd)
+void lpc23xx_restart(enum reboot_mode mode, const char *cmd)
 {
 	switch (mode) {
-	case 's':
-	case 'h':
+	case REBOOT_SOFT:
+	case REBOOT_HARD:
 		lpc32xx_watchdog_reset();
 		break;
 

commit df38b24fa87ba4c386e50b83befd93d0518b7ea8
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Sep 14 20:20:24 2012 +0000

    ARM: lpc32xx: use __iomem pointers for MMIO
    
    ARM is moving to stricter checks on readl/write functions,
    so we need to use the correct types everywhere.
    
    Cc: Roland Stigge <stigge@antcom.de>
    Cc: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index a48dc2dec485..0d4db8c544b5 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -177,25 +177,25 @@ u32 clk_get_pclk_div(void)
 
 static struct map_desc lpc32xx_io_desc[] __initdata = {
 	{
-		.virtual	= IO_ADDRESS(LPC32XX_AHB0_START),
+		.virtual	= (unsigned long)IO_ADDRESS(LPC32XX_AHB0_START),
 		.pfn		= __phys_to_pfn(LPC32XX_AHB0_START),
 		.length		= LPC32XX_AHB0_SIZE,
 		.type		= MT_DEVICE
 	},
 	{
-		.virtual	= IO_ADDRESS(LPC32XX_AHB1_START),
+		.virtual	= (unsigned long)IO_ADDRESS(LPC32XX_AHB1_START),
 		.pfn		= __phys_to_pfn(LPC32XX_AHB1_START),
 		.length		= LPC32XX_AHB1_SIZE,
 		.type		= MT_DEVICE
 	},
 	{
-		.virtual	= IO_ADDRESS(LPC32XX_FABAPB_START),
+		.virtual	= (unsigned long)IO_ADDRESS(LPC32XX_FABAPB_START),
 		.pfn		= __phys_to_pfn(LPC32XX_FABAPB_START),
 		.length		= LPC32XX_FABAPB_SIZE,
 		.type		= MT_DEVICE
 	},
 	{
-		.virtual	= IO_ADDRESS(LPC32XX_IRAM_BASE),
+		.virtual	= (unsigned long)IO_ADDRESS(LPC32XX_IRAM_BASE),
 		.pfn		= __phys_to_pfn(LPC32XX_IRAM_BASE),
 		.length		= (LPC32XX_IRAM_BANK_SIZE * 2),
 		.type		= MT_DEVICE

commit e39942f527fb02b73236d872d22c1b6b8335266c
Author: Alexandre Pereira da Silva <aletes.xgr@gmail.com>
Date:   Fri Jul 20 14:01:51 2012 +0200

    ARM: LPC32xx: Set system serial based on cpu unique id
    
    LPC32xx SoC has a 128 bits unique id that can be used as a system
    serial number, if none has been provided by atags or dt.
    
    Signed-off-by: Alexandre Pereira da Silva <aletes.xgr@gmail.com>
    Signed-off-by: Roland Stigge <stigge@antcom.de>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index 5c96057b6d78..a48dc2dec485 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -26,6 +26,7 @@
 #include <linux/io.h>
 
 #include <asm/mach/map.h>
+#include <asm/system_info.h>
 
 #include <mach/hardware.h>
 #include <mach/platform.h>
@@ -224,7 +225,7 @@ void lpc23xx_restart(char mode, const char *cmd)
 		;
 }
 
-static int __init lpc32xx_display_uid(void)
+static int __init lpc32xx_check_uid(void)
 {
 	u32 uid[4];
 
@@ -233,6 +234,11 @@ static int __init lpc32xx_display_uid(void)
 	printk(KERN_INFO "LPC32XX unique ID: %08x%08x%08x%08x\n",
 		uid[3], uid[2], uid[1], uid[0]);
 
+	if (!system_serial_low && !system_serial_high) {
+		system_serial_low = uid[0];
+		system_serial_high = uid[1];
+	}
+
 	return 1;
 }
-arch_initcall(lpc32xx_display_uid);
+arch_initcall(lpc32xx_check_uid);

commit be20dbc87879582e121e0525adcada13b3a8f476
Author: Roland Stigge <stigge@antcom.de>
Date:   Sun Apr 22 12:01:19 2012 +0200

    ARM: LPC32xx: Move common code to common.c
    
    This patch moves non-boardspecific LPC32xx code to common.c
    
    Signed-off-by: Roland Stigge <stigge@antcom.de>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index 0a41e1ec0c3a..5c96057b6d78 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -223,3 +223,16 @@ void lpc23xx_restart(char mode, const char *cmd)
 	while (1)
 		;
 }
+
+static int __init lpc32xx_display_uid(void)
+{
+	u32 uid[4];
+
+	lpc32xx_get_uid(uid);
+
+	printk(KERN_INFO "LPC32XX unique ID: %08x%08x%08x%08x\n",
+		uid[3], uid[2], uid[1], uid[0]);
+
+	return 1;
+}
+arch_initcall(lpc32xx_display_uid);

commit f5c422713308e492eddc44a12134f9f249ddfbdb
Author: Roland Stigge <stigge@antcom.de>
Date:   Sun Apr 22 12:01:19 2012 +0200

    ARM: LPC32xx: Device tree support
    
    This patch does the actual device tree switch for the LPC32xx SoC.
    
    Signed-off-by: Roland Stigge <stigge@antcom.de>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index 6f255600fc97..0a41e1ec0c3a 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -31,198 +31,6 @@
 #include <mach/platform.h>
 #include "common.h"
 
-/*
- * Watchdog timer
- */
-static struct resource watchdog_resources[] = {
-	[0] = {
-		.start = LPC32XX_WDTIM_BASE,
-		.end = LPC32XX_WDTIM_BASE + SZ_4K - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-struct platform_device lpc32xx_watchdog_device = {
-	.name = "pnx4008-watchdog",
-	.id = -1,
-	.num_resources = ARRAY_SIZE(watchdog_resources),
-	.resource = watchdog_resources,
-};
-
-/*
- * I2C busses
- */
-static struct resource i2c0_resources[] = {
-	[0] = {
-		.start = LPC32XX_I2C1_BASE,
-		.end = LPC32XX_I2C1_BASE + 0x100 - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start = IRQ_LPC32XX_I2C_1,
-		.end = IRQ_LPC32XX_I2C_1,
-		.flags = IORESOURCE_IRQ,
-	},
-};
-
-static struct resource i2c1_resources[] = {
-	[0] = {
-		.start = LPC32XX_I2C2_BASE,
-		.end = LPC32XX_I2C2_BASE + 0x100 - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start = IRQ_LPC32XX_I2C_2,
-		.end = IRQ_LPC32XX_I2C_2,
-		.flags = IORESOURCE_IRQ,
-	},
-};
-
-static struct resource i2c2_resources[] = {
-	[0] = {
-		.start = LPC32XX_OTG_I2C_BASE,
-		.end = LPC32XX_OTG_I2C_BASE + 0x100 - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start = IRQ_LPC32XX_USB_I2C,
-		.end = IRQ_LPC32XX_USB_I2C,
-		.flags = IORESOURCE_IRQ,
-	},
-};
-
-struct platform_device lpc32xx_i2c0_device = {
-	.name = "pnx-i2c.0",
-	.id = 0,
-	.num_resources = ARRAY_SIZE(i2c0_resources),
-	.resource = i2c0_resources,
-};
-
-struct platform_device lpc32xx_i2c1_device = {
-	.name = "pnx-i2c.1",
-	.id = 1,
-	.num_resources = ARRAY_SIZE(i2c1_resources),
-	.resource = i2c1_resources,
-};
-
-struct platform_device lpc32xx_i2c2_device = {
-	.name = "pnx-i2c.2",
-	.id = 2,
-	.num_resources = ARRAY_SIZE(i2c2_resources),
-	.resource = i2c2_resources,
-};
-
-/* TSC (Touch Screen Controller) */
-
-static struct resource lpc32xx_tsc_resources[] = {
-	{
-		.start = LPC32XX_ADC_BASE,
-		.end = LPC32XX_ADC_BASE + SZ_4K - 1,
-		.flags = IORESOURCE_MEM,
-	}, {
-		.start = IRQ_LPC32XX_TS_IRQ,
-		.end = IRQ_LPC32XX_TS_IRQ,
-		.flags = IORESOURCE_IRQ,
-	},
-};
-
-struct platform_device lpc32xx_tsc_device = {
-	.name =  "ts-lpc32xx",
-	.id = -1,
-	.num_resources = ARRAY_SIZE(lpc32xx_tsc_resources),
-	.resource = lpc32xx_tsc_resources,
-};
-
-/* RTC */
-
-static struct resource lpc32xx_rtc_resources[] = {
-	{
-		.start = LPC32XX_RTC_BASE,
-		.end = LPC32XX_RTC_BASE + SZ_4K - 1,
-		.flags = IORESOURCE_MEM,
-	},{
-		.start = IRQ_LPC32XX_RTC,
-		.end = IRQ_LPC32XX_RTC,
-		.flags = IORESOURCE_IRQ,
-	},
-};
-
-struct platform_device lpc32xx_rtc_device = {
-	.name =  "rtc-lpc32xx",
-	.id = -1,
-	.num_resources = ARRAY_SIZE(lpc32xx_rtc_resources),
-	.resource = lpc32xx_rtc_resources,
-};
-
-/*
- * ADC support
- */
-static struct resource adc_resources[] = {
-	{
-		.start = LPC32XX_ADC_BASE,
-		.end = LPC32XX_ADC_BASE + SZ_4K - 1,
-		.flags = IORESOURCE_MEM,
-	}, {
-		.start = IRQ_LPC32XX_TS_IRQ,
-		.end = IRQ_LPC32XX_TS_IRQ,
-		.flags = IORESOURCE_IRQ,
-	},
-};
-
-struct platform_device lpc32xx_adc_device = {
-	.name =  "lpc32xx-adc",
-	.id = -1,
-	.num_resources = ARRAY_SIZE(adc_resources),
-	.resource = adc_resources,
-};
-
-/*
- * USB support
- */
-/* The dmamask must be set for OHCI to work */
-static u64 ohci_dmamask = ~(u32) 0;
-static struct resource ohci_resources[] = {
-	{
-		.start = IO_ADDRESS(LPC32XX_USB_BASE),
-		.end = IO_ADDRESS(LPC32XX_USB_BASE + 0x100 - 1),
-		.flags = IORESOURCE_MEM,
-	}, {
-		.start = IRQ_LPC32XX_USB_HOST,
-		.flags = IORESOURCE_IRQ,
-	},
-};
-struct platform_device lpc32xx_ohci_device = {
-	.name = "usb-ohci",
-	.id = -1,
-	.dev = {
-		.dma_mask = &ohci_dmamask,
-		.coherent_dma_mask = 0xFFFFFFFF,
-	},
-	.num_resources = ARRAY_SIZE(ohci_resources),
-	.resource = ohci_resources,
-};
-
-/*
- * Network Support
- */
-static struct resource net_resources[] = {
-	[0] = DEFINE_RES_MEM(LPC32XX_ETHERNET_BASE, SZ_4K),
-	[1] = DEFINE_RES_MEM(LPC32XX_IRAM_BASE, SZ_128K),
-	[2] = DEFINE_RES_IRQ(IRQ_LPC32XX_ETHERNET),
-};
-
-static u64 lpc32xx_mac_dma_mask = 0xffffffffUL;
-struct platform_device lpc32xx_net_device = {
-	.name = "lpc-eth",
-	.id = 0,
-	.dev = {
-		.dma_mask = &lpc32xx_mac_dma_mask,
-		.coherent_dma_mask = 0xffffffffUL,
-	},
-	.num_resources = ARRAY_SIZE(net_resources),
-	.resource = net_resources,
-};
-
 /*
  * Returns the unique ID for the device
  */

commit 1451ba3a5fa52d874e03a3380d053f3e6a5fcae4
Author: Roland Stigge <stigge@antcom.de>
Date:   Sun Apr 22 11:59:47 2012 +0200

    i2c-pnx.c: Use resources in platforms
    
    As a precondition for device tree conversion, the platforms using i2c-pnx.c are
    converted to using mem and irq resources instead of platform data.
    
    Signed-off-by: Roland Stigge <stigge@antcom.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index bbbf063a74c2..6f255600fc97 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -27,7 +27,6 @@
 
 #include <asm/mach/map.h>
 
-#include <mach/i2c.h>
 #include <mach/hardware.h>
 #include <mach/platform.h>
 #include "common.h"
@@ -53,46 +52,64 @@ struct platform_device lpc32xx_watchdog_device = {
 /*
  * I2C busses
  */
-static struct i2c_pnx_data i2c0_data = {
-	.name = I2C_CHIP_NAME "1",
-	.base = LPC32XX_I2C1_BASE,
-	.irq = IRQ_LPC32XX_I2C_1,
+static struct resource i2c0_resources[] = {
+	[0] = {
+		.start = LPC32XX_I2C1_BASE,
+		.end = LPC32XX_I2C1_BASE + 0x100 - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_LPC32XX_I2C_1,
+		.end = IRQ_LPC32XX_I2C_1,
+		.flags = IORESOURCE_IRQ,
+	},
 };
 
-static struct i2c_pnx_data i2c1_data = {
-	.name = I2C_CHIP_NAME "2",
-	.base = LPC32XX_I2C2_BASE,
-	.irq = IRQ_LPC32XX_I2C_2,
+static struct resource i2c1_resources[] = {
+	[0] = {
+		.start = LPC32XX_I2C2_BASE,
+		.end = LPC32XX_I2C2_BASE + 0x100 - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_LPC32XX_I2C_2,
+		.end = IRQ_LPC32XX_I2C_2,
+		.flags = IORESOURCE_IRQ,
+	},
 };
 
-static struct i2c_pnx_data i2c2_data = {
-	.name = "USB-I2C",
-	.base = LPC32XX_OTG_I2C_BASE,
-	.irq = IRQ_LPC32XX_USB_I2C,
+static struct resource i2c2_resources[] = {
+	[0] = {
+		.start = LPC32XX_OTG_I2C_BASE,
+		.end = LPC32XX_OTG_I2C_BASE + 0x100 - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_LPC32XX_USB_I2C,
+		.end = IRQ_LPC32XX_USB_I2C,
+		.flags = IORESOURCE_IRQ,
+	},
 };
 
 struct platform_device lpc32xx_i2c0_device = {
-	.name = "pnx-i2c",
+	.name = "pnx-i2c.0",
 	.id = 0,
-	.dev = {
-		.platform_data = &i2c0_data,
-	},
+	.num_resources = ARRAY_SIZE(i2c0_resources),
+	.resource = i2c0_resources,
 };
 
 struct platform_device lpc32xx_i2c1_device = {
-	.name = "pnx-i2c",
+	.name = "pnx-i2c.1",
 	.id = 1,
-	.dev = {
-		.platform_data = &i2c1_data,
-	},
+	.num_resources = ARRAY_SIZE(i2c1_resources),
+	.resource = i2c1_resources,
 };
 
 struct platform_device lpc32xx_i2c2_device = {
-	.name = "pnx-i2c",
+	.name = "pnx-i2c.2",
 	.id = 2,
-	.dev = {
-		.platform_data = &i2c2_data,
-	},
+	.num_resources = ARRAY_SIZE(i2c2_resources),
+	.resource = i2c2_resources,
 };
 
 /* TSC (Touch Screen Controller) */

commit c20b909be9ba27173294a52d08cab293ec030a2c
Author: Roland Stigge <stigge@antcom.de>
Date:   Mon Mar 12 22:27:28 2012 +0100

    ARM: LPC32xx: Ethernet support
    
    This patch adds ethernet support to the LPC32xx ARM architecture. The actual
    driver in drivers/net is contained in a separate patch.
    
    Signed-off-by: Roland Stigge <stigge@antcom.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index 11c900857b1b..bbbf063a74c2 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -185,6 +185,27 @@ struct platform_device lpc32xx_ohci_device = {
 	.resource = ohci_resources,
 };
 
+/*
+ * Network Support
+ */
+static struct resource net_resources[] = {
+	[0] = DEFINE_RES_MEM(LPC32XX_ETHERNET_BASE, SZ_4K),
+	[1] = DEFINE_RES_MEM(LPC32XX_IRAM_BASE, SZ_128K),
+	[2] = DEFINE_RES_IRQ(IRQ_LPC32XX_ETHERNET),
+};
+
+static u64 lpc32xx_mac_dma_mask = 0xffffffffUL;
+struct platform_device lpc32xx_net_device = {
+	.name = "lpc-eth",
+	.id = 0,
+	.dev = {
+		.dma_mask = &lpc32xx_mac_dma_mask,
+		.coherent_dma_mask = 0xffffffffUL,
+	},
+	.num_resources = ARRAY_SIZE(net_resources),
+	.resource = net_resources,
+};
+
 /*
  * Returns the unique ID for the device
  */

commit 48a5dedfa78899dad50b3b4ae30f07e27e6591ab
Author: Roland Stigge <stigge@antcom.de>
Date:   Mon Mar 12 22:23:43 2012 +0100

    ARM: LPC32xx: USB Support
    
    This patch adds OHCI support to the LPC32xx ARM platform. Besides the trivial
    addition of platform "usb-ohci" support, fixes for the USB PLL have been added
    to arch/arm/mach-lpc32xx/clock.c, ported from NXP's lpclinux.com.
    
    (This is the mach-lpc32xx specific part, the USB subsystem specific changes are
    in a separate patch for the USB maintainers.)
    
    Signed-off-by: Roland Stigge <stigge@antcom.de>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index 6c76bb36559b..11c900857b1b 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -159,6 +159,32 @@ struct platform_device lpc32xx_adc_device = {
 	.resource = adc_resources,
 };
 
+/*
+ * USB support
+ */
+/* The dmamask must be set for OHCI to work */
+static u64 ohci_dmamask = ~(u32) 0;
+static struct resource ohci_resources[] = {
+	{
+		.start = IO_ADDRESS(LPC32XX_USB_BASE),
+		.end = IO_ADDRESS(LPC32XX_USB_BASE + 0x100 - 1),
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = IRQ_LPC32XX_USB_HOST,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+struct platform_device lpc32xx_ohci_device = {
+	.name = "usb-ohci",
+	.id = -1,
+	.dev = {
+		.dma_mask = &ohci_dmamask,
+		.coherent_dma_mask = 0xFFFFFFFF,
+	},
+	.num_resources = ARRAY_SIZE(ohci_resources),
+	.resource = ohci_resources,
+};
+
 /*
  * Returns the unique ID for the device
  */

commit 678a0222edc9da43a22145d68647500ee85e6c04
Author: Roland Stigge <stigge@antcom.de>
Date:   Fri Feb 17 14:58:14 2012 +0100

    ARM: LPC32xx: ADC support for mach-lpc32xx
    
    This patch adds the mach specific support for the LPC32XX ADC driver (the
    latter being already in staging/iio)
    
    Signed-off-by: Roland Stigge <stigge@antcom.de>
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index 369b152896cd..6c76bb36559b 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -137,6 +137,28 @@ struct platform_device lpc32xx_rtc_device = {
 	.resource = lpc32xx_rtc_resources,
 };
 
+/*
+ * ADC support
+ */
+static struct resource adc_resources[] = {
+	{
+		.start = LPC32XX_ADC_BASE,
+		.end = LPC32XX_ADC_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = IRQ_LPC32XX_TS_IRQ,
+		.end = IRQ_LPC32XX_TS_IRQ,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device lpc32xx_adc_device = {
+	.name =  "lpc32xx-adc",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(adc_resources),
+	.resource = adc_resources,
+};
+
 /*
  * Returns the unique ID for the device
  */

commit e6849374f3fcec5a51ab6df40ae4d8034ba1c5e0
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Nov 5 12:18:20 2011 +0000

    ARM: restart: lpc32xx & u300: remove unnecessary printk
    
    Remove the:
            KERN_CRIT "RESET: Rebooting system\n" (lpc32xx)
            KERN_CRIT "RESET: shutting down/rebooting system\n" (u300)
    
    printk from the restart handler; we already print such a message from
    kernel_restart() in kernel/sys.c:
    
            KERN_EMERG "Restarting system.\n"
    
    so this is unnecessary.
    
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index b049fd1eb8e1..369b152896cd 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -317,8 +317,6 @@ void lpc23xx_restart(char mode, const char *cmd)
 	switch (mode) {
 	case 's':
 	case 'h':
-		printk(KERN_CRIT "RESET: Rebooting system\n");
-
 		lpc32xx_watchdog_reset();
 		break;
 

commit b23fcd9035a35b032c624ac2f23f40ea941d5355
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Nov 5 12:17:40 2011 +0000

    ARM: restart: lpc32xx: use new restart hook
    
    Hook these platforms restart code into the arm_pm_restart hook rather
    than using arch_reset().
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index 205b2dbb565b..b049fd1eb8e1 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -164,7 +164,7 @@ int clk_is_sysclk_mainosc(void)
 /*
  * System reset via the watchdog timer
  */
-void lpc32xx_watchdog_reset(void)
+static void lpc32xx_watchdog_reset(void)
 {
 	/* Make sure WDT clocks are enabled */
 	__raw_writel(LPC32XX_CLKPWR_PWMCLK_WDOG_EN,
@@ -311,3 +311,23 @@ void __init lpc32xx_map_io(void)
 {
 	iotable_init(lpc32xx_io_desc, ARRAY_SIZE(lpc32xx_io_desc));
 }
+
+void lpc23xx_restart(char mode, const char *cmd)
+{
+	switch (mode) {
+	case 's':
+	case 'h':
+		printk(KERN_CRIT "RESET: Rebooting system\n");
+
+		lpc32xx_watchdog_reset();
+		break;
+
+	default:
+		/* Do nothing */
+		break;
+	}
+
+	/* Wait for watchdog to reset system */
+	while (1)
+		;
+}

commit 1c72f9eaa53e920f142f4c1d20b4fc82b1a10ed5
Author: Wolfram Sang <w.sang@pengutronix.de>
Date:   Mon Mar 28 16:51:35 2011 +0200

    arm: lpc32xx: add rtc-device
    
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
    Tested-by: Kevin Wells <Kevin.wells@nxp.com>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index 6880b47a9ae5..205b2dbb565b 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -116,6 +116,27 @@ struct platform_device lpc32xx_tsc_device = {
 	.resource = lpc32xx_tsc_resources,
 };
 
+/* RTC */
+
+static struct resource lpc32xx_rtc_resources[] = {
+	{
+		.start = LPC32XX_RTC_BASE,
+		.end = LPC32XX_RTC_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},{
+		.start = IRQ_LPC32XX_RTC,
+		.end = IRQ_LPC32XX_RTC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device lpc32xx_rtc_device = {
+	.name =  "rtc-lpc32xx",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(lpc32xx_rtc_resources),
+	.resource = lpc32xx_rtc_resources,
+};
+
 /*
  * Returns the unique ID for the device
  */

commit 7db2b37751caa2f17b026223a382eca07c90c575
Author: Wolfram Sang <w.sang@pengutronix.de>
Date:   Mon Mar 21 16:14:43 2011 +0100

    arm: lpc32xx: add tsc-device
    
    Fix the clock name, too.
    
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
    Tested-by: Kevin Wells <Kevin.wells@nxp.com>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index ee24dc28e93e..6880b47a9ae5 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -95,6 +95,27 @@ struct platform_device lpc32xx_i2c2_device = {
 	},
 };
 
+/* TSC (Touch Screen Controller) */
+
+static struct resource lpc32xx_tsc_resources[] = {
+	{
+		.start = LPC32XX_ADC_BASE,
+		.end = LPC32XX_ADC_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = IRQ_LPC32XX_TS_IRQ,
+		.end = IRQ_LPC32XX_TS_IRQ,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device lpc32xx_tsc_device = {
+	.name =  "ts-lpc32xx",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(lpc32xx_tsc_resources),
+	.resource = lpc32xx_tsc_resources,
+};
+
 /*
  * Returns the unique ID for the device
  */

commit fc982e1ceaeb4dea3f3f8ceba5b934cee292944a
Author: Kevin Wells <wellsk40@gmail.com>
Date:   Tue Jul 27 08:42:46 2010 -0700

    ARM: LPC32XX: Misc support functions
    
    Misc support functions and prototypes used in the LPC32XX arch
    and platforms
    
    Signed-off-by: Kevin Wells <wellsk40@gmail.com>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>

diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
new file mode 100644
index 000000000000..ee24dc28e93e
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -0,0 +1,271 @@
+/*
+ * arch/arm/mach-lpc32xx/common.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/i2c-pnx.h>
+#include <linux/io.h>
+
+#include <asm/mach/map.h>
+
+#include <mach/i2c.h>
+#include <mach/hardware.h>
+#include <mach/platform.h>
+#include "common.h"
+
+/*
+ * Watchdog timer
+ */
+static struct resource watchdog_resources[] = {
+	[0] = {
+		.start = LPC32XX_WDTIM_BASE,
+		.end = LPC32XX_WDTIM_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+struct platform_device lpc32xx_watchdog_device = {
+	.name = "pnx4008-watchdog",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(watchdog_resources),
+	.resource = watchdog_resources,
+};
+
+/*
+ * I2C busses
+ */
+static struct i2c_pnx_data i2c0_data = {
+	.name = I2C_CHIP_NAME "1",
+	.base = LPC32XX_I2C1_BASE,
+	.irq = IRQ_LPC32XX_I2C_1,
+};
+
+static struct i2c_pnx_data i2c1_data = {
+	.name = I2C_CHIP_NAME "2",
+	.base = LPC32XX_I2C2_BASE,
+	.irq = IRQ_LPC32XX_I2C_2,
+};
+
+static struct i2c_pnx_data i2c2_data = {
+	.name = "USB-I2C",
+	.base = LPC32XX_OTG_I2C_BASE,
+	.irq = IRQ_LPC32XX_USB_I2C,
+};
+
+struct platform_device lpc32xx_i2c0_device = {
+	.name = "pnx-i2c",
+	.id = 0,
+	.dev = {
+		.platform_data = &i2c0_data,
+	},
+};
+
+struct platform_device lpc32xx_i2c1_device = {
+	.name = "pnx-i2c",
+	.id = 1,
+	.dev = {
+		.platform_data = &i2c1_data,
+	},
+};
+
+struct platform_device lpc32xx_i2c2_device = {
+	.name = "pnx-i2c",
+	.id = 2,
+	.dev = {
+		.platform_data = &i2c2_data,
+	},
+};
+
+/*
+ * Returns the unique ID for the device
+ */
+void lpc32xx_get_uid(u32 devid[4])
+{
+	int i;
+
+	for (i = 0; i < 4; i++)
+		devid[i] = __raw_readl(LPC32XX_CLKPWR_DEVID(i << 2));
+}
+
+/*
+ * Returns SYSCLK source
+ * 0 = PLL397, 1 = main oscillator
+ */
+int clk_is_sysclk_mainosc(void)
+{
+	if ((__raw_readl(LPC32XX_CLKPWR_SYSCLK_CTRL) &
+		LPC32XX_CLKPWR_SYSCTRL_SYSCLKMUX) == 0)
+		return 1;
+
+	return 0;
+}
+
+/*
+ * System reset via the watchdog timer
+ */
+void lpc32xx_watchdog_reset(void)
+{
+	/* Make sure WDT clocks are enabled */
+	__raw_writel(LPC32XX_CLKPWR_PWMCLK_WDOG_EN,
+		LPC32XX_CLKPWR_TIMER_CLK_CTRL);
+
+	/* Instant assert of RESETOUT_N with pulse length 1mS */
+	__raw_writel(13000, io_p2v(LPC32XX_WDTIM_BASE + 0x18));
+	__raw_writel(0x70, io_p2v(LPC32XX_WDTIM_BASE + 0xC));
+}
+
+/*
+ * Detects and returns IRAM size for the device variation
+ */
+#define LPC32XX_IRAM_BANK_SIZE SZ_128K
+static u32 iram_size;
+u32 lpc32xx_return_iram_size(void)
+{
+	if (iram_size == 0) {
+		u32 savedval1, savedval2;
+		void __iomem *iramptr1, *iramptr2;
+
+		iramptr1 = io_p2v(LPC32XX_IRAM_BASE);
+		iramptr2 = io_p2v(LPC32XX_IRAM_BASE + LPC32XX_IRAM_BANK_SIZE);
+		savedval1 = __raw_readl(iramptr1);
+		savedval2 = __raw_readl(iramptr2);
+
+		if (savedval1 == savedval2) {
+			__raw_writel(savedval2 + 1, iramptr2);
+			if (__raw_readl(iramptr1) == savedval2 + 1)
+				iram_size = LPC32XX_IRAM_BANK_SIZE;
+			else
+				iram_size = LPC32XX_IRAM_BANK_SIZE * 2;
+			__raw_writel(savedval2, iramptr2);
+		} else
+			iram_size = LPC32XX_IRAM_BANK_SIZE * 2;
+	}
+
+	return iram_size;
+}
+
+/*
+ * Computes PLL rate from PLL register and input clock
+ */
+u32 clk_check_pll_setup(u32 ifreq, struct clk_pll_setup *pllsetup)
+{
+	u32 ilfreq, p, m, n, fcco, fref, cfreq;
+	int mode;
+
+	/*
+	 * PLL requirements
+	 * ifreq must be >= 1MHz and <= 20MHz
+	 * FCCO must be >= 156MHz and <= 320MHz
+	 * FREF must be >= 1MHz and <= 27MHz
+	 * Assume the passed input data is not valid
+	 */
+
+	ilfreq = ifreq;
+	m = pllsetup->pll_m;
+	n = pllsetup->pll_n;
+	p = pllsetup->pll_p;
+
+	mode = (pllsetup->cco_bypass_b15 << 2) |
+		(pllsetup->direct_output_b14 << 1) |
+	pllsetup->fdbk_div_ctrl_b13;
+
+	switch (mode) {
+	case 0x0: /* Non-integer mode */
+		cfreq = (m * ilfreq) / (2 * p * n);
+		fcco = (m * ilfreq) / n;
+		fref = ilfreq / n;
+		break;
+
+	case 0x1: /* integer mode */
+		cfreq = (m * ilfreq) / n;
+		fcco = (m * ilfreq) / (n * 2 * p);
+		fref = ilfreq / n;
+		break;
+
+	case 0x2:
+	case 0x3: /* Direct mode */
+		cfreq = (m * ilfreq) / n;
+		fcco = cfreq;
+		fref = ilfreq / n;
+		break;
+
+	case 0x4:
+	case 0x5: /* Bypass mode */
+		cfreq = ilfreq / (2 * p);
+		fcco = 156000000;
+		fref = 1000000;
+		break;
+
+	case 0x6:
+	case 0x7: /* Direct bypass mode */
+	default:
+		cfreq = ilfreq;
+		fcco = 156000000;
+		fref = 1000000;
+		break;
+	}
+
+	if (fcco < 156000000 || fcco > 320000000)
+		cfreq = 0;
+
+	if (fref < 1000000 || fref > 27000000)
+		cfreq = 0;
+
+	return (u32) cfreq;
+}
+
+u32 clk_get_pclk_div(void)
+{
+	return 1 + ((__raw_readl(LPC32XX_CLKPWR_HCLK_DIV) >> 2) & 0x1F);
+}
+
+static struct map_desc lpc32xx_io_desc[] __initdata = {
+	{
+		.virtual	= IO_ADDRESS(LPC32XX_AHB0_START),
+		.pfn		= __phys_to_pfn(LPC32XX_AHB0_START),
+		.length		= LPC32XX_AHB0_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= IO_ADDRESS(LPC32XX_AHB1_START),
+		.pfn		= __phys_to_pfn(LPC32XX_AHB1_START),
+		.length		= LPC32XX_AHB1_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= IO_ADDRESS(LPC32XX_FABAPB_START),
+		.pfn		= __phys_to_pfn(LPC32XX_FABAPB_START),
+		.length		= LPC32XX_FABAPB_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= IO_ADDRESS(LPC32XX_IRAM_BASE),
+		.pfn		= __phys_to_pfn(LPC32XX_IRAM_BASE),
+		.length		= (LPC32XX_IRAM_BANK_SIZE * 2),
+		.type		= MT_DEVICE
+	},
+};
+
+void __init lpc32xx_map_io(void)
+{
+	iotable_init(lpc32xx_io_desc, ARRAY_SIZE(lpc32xx_io_desc));
+}
