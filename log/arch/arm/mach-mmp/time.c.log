commit 3819ad44025fbc03b32d41070b941acea86e6686
Author: Stephen Boyd <sboyd@kernel.org>
Date:   Wed Apr 8 23:44:14 2020 -0700

    ARM: mmp: Remove legacy clk code
    
    Remove all the legacy clk code that supports a non-common clk framework
    implementation of 'struct clk' in mach-mmp. This code doesn't look to be
    compiled anymore given that the MMP is fully supported in the
    multi-platform config via ARCH_MULTIPLATFORM as of commit 377524dc4d77
    ("ARM: mmp: move into ARCH_MULTIPLATFORM"). The ARCH_MULTIPLATFORM
    config selects COMMON_CLK and therefore the Makefile rule can never
    actually compile the code in these files.
    
    Cc: Lubomir Rintel <lkundrak@v3.sk>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>
    Link: https://lkml.kernel.org/r/20200409064416.83340-9-sboyd@kernel.org
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    [sboyd@kernel.org: Squash in a clock.h include removal found by Stephen
    Rothwell <sfr@canb.auug.org.au>]

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 049a65f47b42..41b2e8abc9e6 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -34,7 +34,6 @@
 #include "regs-apbc.h"
 #include "irqs.h"
 #include <linux/soc/mmp/cputype.h>
-#include "clock.h"
 
 #define TIMERS_VIRT_BASE	TIMERS1_VIRT_BASE
 

commit 2fcf53350810d0e2af9ef57a57957c6c739c5647
Author: afzal mohammed <afzal.mohd.ma@gmail.com>
Date:   Fri Mar 27 18:14:37 2020 +0530

    ARM: mmp: replace setup_irq() by request_irq()
    
    request_irq() is preferred over setup_irq(). Invocations of setup_irq()
    occur after memory allocators are ready.
    
    Per tglx[1], setup_irq() existed in olden days when allocators were not
    ready by the time early interrupts were initialized.
    
    Hence replace setup_irq() by request_irq().
    
    [1] https://lkml.kernel.org/r/alpine.DEB.2.20.1710191609480.1971@nanos
    
    Link: https://lore.kernel.org/r/20200327124437.4239-1-afzal.mohd.ma@gmail.com
    Signed-off-by: afzal mohammed <afzal.mohd.ma@gmail.com>
    Acked-by: Lubomir Rintel <lkundrak@v3.sk>
    Tested-by: Lubomir Rintel <lkundrak@v3.sk>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index c65cfc1ad99b..049a65f47b42 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -175,13 +175,6 @@ static void __init timer_config(void)
 	__raw_writel(0x2, mmp_timer_base + TMR_CER);
 }
 
-static struct irqaction timer_irq = {
-	.name		= "timer",
-	.flags		= IRQF_TIMER | IRQF_IRQPOLL,
-	.handler	= timer_interrupt,
-	.dev_id		= &ckevt,
-};
-
 void __init mmp_timer_init(int irq, unsigned long rate)
 {
 	timer_config();
@@ -190,7 +183,9 @@ void __init mmp_timer_init(int irq, unsigned long rate)
 
 	ckevt.cpumask = cpumask_of(0);
 
-	setup_irq(irq, &timer_irq);
+	if (request_irq(irq, timer_interrupt, IRQF_TIMER | IRQF_IRQPOLL,
+			"timer", &ckevt))
+		pr_err("Failed to request irq %d (timer)\n", irq);
 
 	clocksource_register_hz(&cksrc, rate);
 	clockevents_config_and_register(&ckevt, rate, MIN_DELTA, MAX_DELTA);

commit 0bd0f30bbf060891f58866a46083a9931f71787c
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Wed Dec 18 20:04:53 2019 +0100

    ARM: mmp: do not divide the clock rate
    
    This was done because the clock driver returned the wrong rate, which is
    fixed in "clk: mmp2: Fix the order of timer mux parents" patch.
    
    Link: https://lore.kernel.org/r/20191218190454.420358-2-lkundrak@v3.sk
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 110dcb3314d1..c65cfc1ad99b 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -207,7 +207,7 @@ static int __init mmp_dt_init_timer(struct device_node *np)
 		ret = clk_prepare_enable(clk);
 		if (ret)
 			return ret;
-		rate = clk_get_rate(clk) / 2;
+		rate = clk_get_rate(clk);
 	} else if (cpu_is_pj4()) {
 		rate = 6500000;
 	} else {

commit 32adcaa010fa85e09296a6a606ad07348ef349ed
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Thu Aug 8 15:47:24 2019 +0200

    ARM: mmp: move cputype.h to include/linux/soc/
    
    Let's move cputype.h away from mach-mmp/ so that the drivers outside that
    directory are able to tell the precise silicon revision. The MMP3 USB OTG
    PHY driver needs this.
    
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 8f4cacbf640e..110dcb3314d1 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -33,7 +33,7 @@
 #include "regs-timers.h"
 #include "regs-apbc.h"
 #include "irqs.h"
-#include "cputype.h"
+#include <linux/soc/mmp/cputype.h>
 #include "clock.h"
 
 #define TIMERS_VIRT_BASE	TIMERS1_VIRT_BASE

commit a9372a5fb20597a070d89f9402241d9012c0590f
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Thu May 16 08:19:37 2019 +0200

    ARM: mmp: add support for MMP3 SoC
    
    Similar to MMP2, which this patch is based on. Known differencies from MMP2
    are:
    
    * Two PJ4B cores instead of one PJ4
    * Tauros 3 L2 cache controller instead of Tauros 2
    * A GIC interrupt controller optionally used instead of the MMP one
    * A TWD local timer
    * Different USB2 PHY
    * A USB3 SS controller
    * More interrupt muxes
    
    Hard to tell what else is different, because documentation is not
    available.
    
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 3f6fd0be0051..8f4cacbf640e 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -155,7 +155,8 @@ static void __init timer_config(void)
 
 	__raw_writel(0x0, mmp_timer_base + TMR_CER); /* disable */
 
-	ccr &= (cpu_is_mmp2()) ? (TMR_CCR_CS_0(0) | TMR_CCR_CS_1(0)) :
+	ccr &= (cpu_is_mmp2() || cpu_is_mmp3()) ?
+		(TMR_CCR_CS_0(0) | TMR_CCR_CS_1(0)) :
 		(TMR_CCR_CS_0(3) | TMR_CCR_CS_1(3));
 	__raw_writel(ccr, mmp_timer_base + TMR_CCR);
 

commit 1732050f48a384fbe101b8586ed42caf874816eb
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Wed Jul 10 23:13:51 2019 +0200

    ARM: mmp: DT: convert timer driver to use TIMER_OF_DECLARE
    
    This makes things just a tiny bit simpler.
    
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 483df32583be..3f6fd0be0051 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -195,30 +195,17 @@ void __init mmp_timer_init(int irq, unsigned long rate)
 	clockevents_config_and_register(&ckevt, rate, MIN_DELTA, MAX_DELTA);
 }
 
-#ifdef CONFIG_OF
-static const struct of_device_id mmp_timer_dt_ids[] = {
-	{ .compatible = "mrvl,mmp-timer", },
-	{}
-};
-
-void __init mmp_dt_init_timer(void)
+static int __init mmp_dt_init_timer(struct device_node *np)
 {
-	struct device_node *np;
 	struct clk *clk;
 	int irq, ret;
 	unsigned long rate;
 
-	np = of_find_matching_node(NULL, mmp_timer_dt_ids);
-	if (!np) {
-		ret = -ENODEV;
-		goto out;
-	}
-
 	clk = of_clk_get(np, 0);
 	if (!IS_ERR(clk)) {
 		ret = clk_prepare_enable(clk);
 		if (ret)
-			goto out;
+			return ret;
 		rate = clk_get_rate(clk) / 2;
 	} else if (cpu_is_pj4()) {
 		rate = 6500000;
@@ -227,18 +214,15 @@ void __init mmp_dt_init_timer(void)
 	}
 
 	irq = irq_of_parse_and_map(np, 0);
-	if (!irq) {
-		ret = -EINVAL;
-		goto out;
-	}
+	if (!irq)
+		return -EINVAL;
+
 	mmp_timer_base = of_iomap(np, 0);
-	if (!mmp_timer_base) {
-		ret = -ENOMEM;
-		goto out;
-	}
+	if (!mmp_timer_base)
+		return -ENOMEM;
+
 	mmp_timer_init(irq, rate);
-	return;
-out:
-	pr_err("Failed to get timer from device tree with error:%d\n", ret);
+	return 0;
 }
-#endif
+
+TIMER_OF_DECLARE(mmp_timer, "mrvl,mmp-timer", mmp_dt_init_timer);

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index f9c295154b94..483df32583be 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * linux/arch/arm/mach-mmp/time.c
  *
@@ -12,10 +13,6 @@
  * The timers module actually includes three timers, each timer with up to
  * three match comparators. Timer #0 is used here in free-running mode as
  * the clock source, and match comparator #1 used as clock event device.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/init.h>

commit 12d3a30db4a3b3df5fbadf5974b9cf50544a9950
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Dec 10 21:43:01 2018 +0100

    ARM: mmp: fix timer_init calls
    
    The change to passing the timer frequency as a function argument
    was a good idea, but caused a build failure for one user that
    was missed in the update:
    
    arch/arm/mach-mmp/time.c: In function 'mmp_dt_init_timer':
    arch/arm/mach-mmp/time.c:242:2: error: implicit declaration of function 'timer_init'; did you mean 'hrtimer_init'? [-Werror=implicit-function-declaration]
    
    Change that as well to fix the build error, and rename the
    function to put it into a proper namespace and make it clearer
    what is actually going on.
    
    I saw that the high 6500000 HZ frequency was previously only
    set with CONFIG_MMP2, but is now also used with MMP (pxa910),
    so I'm changing that back here. Please make sure that the
    frequencies are all correct now.
    
    Fixes: f36797ee4380 ("ARM: mmp/mmp2: dt: enable the clock")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index eab0fd8a7343..f9c295154b94 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -184,7 +184,7 @@ static struct irqaction timer_irq = {
 	.dev_id		= &ckevt,
 };
 
-void __init timer_init(int irq, unsigned long rate)
+void __init mmp_timer_init(int irq, unsigned long rate)
 {
 	timer_config();
 
@@ -239,7 +239,7 @@ void __init mmp_dt_init_timer(void)
 		ret = -ENOMEM;
 		goto out;
 	}
-	timer_init(irq, rate);
+	mmp_timer_init(irq, rate);
 	return;
 out:
 	pr_err("Failed to get timer from device tree with error:%d\n", ret);

commit f36797ee43802b367e59f0f9a9805304a4ff0c98
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Wed Nov 28 18:53:20 2018 +0100

    ARM: mmp/mmp2: dt: enable the clock
    
    The device-tree booted MMP2 needs to enable the timer clock, otherwise
    it would stop ticking when the boot finishes.
    
    It can also use the clock rate from the clk, the non-DT boards need to
    keep using the hardcoded rates.
    
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 96ad1db0b04b..eab0fd8a7343 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -22,6 +22,7 @@
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
 #include <linux/clockchips.h>
+#include <linux/clk.h>
 
 #include <linux/io.h>
 #include <linux/irq.h>
@@ -38,12 +39,6 @@
 #include "cputype.h"
 #include "clock.h"
 
-#ifdef CONFIG_CPU_MMP2
-#define MMP_CLOCK_FREQ		6500000
-#else
-#define MMP_CLOCK_FREQ		3250000
-#endif
-
 #define TIMERS_VIRT_BASE	TIMERS1_VIRT_BASE
 
 #define MAX_DELTA		(0xfffffffe)
@@ -189,19 +184,18 @@ static struct irqaction timer_irq = {
 	.dev_id		= &ckevt,
 };
 
-void __init timer_init(int irq)
+void __init timer_init(int irq, unsigned long rate)
 {
 	timer_config();
 
-	sched_clock_register(mmp_read_sched_clock, 32, MMP_CLOCK_FREQ);
+	sched_clock_register(mmp_read_sched_clock, 32, rate);
 
 	ckevt.cpumask = cpumask_of(0);
 
 	setup_irq(irq, &timer_irq);
 
-	clocksource_register_hz(&cksrc, MMP_CLOCK_FREQ);
-	clockevents_config_and_register(&ckevt, MMP_CLOCK_FREQ,
-					MIN_DELTA, MAX_DELTA);
+	clocksource_register_hz(&cksrc, rate);
+	clockevents_config_and_register(&ckevt, rate, MIN_DELTA, MAX_DELTA);
 }
 
 #ifdef CONFIG_OF
@@ -213,7 +207,9 @@ static const struct of_device_id mmp_timer_dt_ids[] = {
 void __init mmp_dt_init_timer(void)
 {
 	struct device_node *np;
+	struct clk *clk;
 	int irq, ret;
+	unsigned long rate;
 
 	np = of_find_matching_node(NULL, mmp_timer_dt_ids);
 	if (!np) {
@@ -221,6 +217,18 @@ void __init mmp_dt_init_timer(void)
 		goto out;
 	}
 
+	clk = of_clk_get(np, 0);
+	if (!IS_ERR(clk)) {
+		ret = clk_prepare_enable(clk);
+		if (ret)
+			goto out;
+		rate = clk_get_rate(clk) / 2;
+	} else if (cpu_is_pj4()) {
+		rate = 6500000;
+	} else {
+		rate = 3250000;
+	}
+
 	irq = irq_of_parse_and_map(np, 0);
 	if (!irq) {
 		ret = -EINVAL;
@@ -231,7 +239,7 @@ void __init mmp_dt_init_timer(void)
 		ret = -ENOMEM;
 		goto out;
 	}
-	timer_init(irq);
+	timer_init(irq, rate);
 	return;
 out:
 	pr_err("Failed to get timer from device tree with error:%d\n", ret);

commit a5a1d1c2914b5316924c7893eb683a5420ebd3be
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Dec 21 20:32:01 2016 +0100

    clocksource: Use a plain u64 instead of cycle_t
    
    There is no point in having an extra type for extra confusion. u64 is
    unambiguous.
    
    Conversion was done with the following coccinelle script:
    
    @rem@
    @@
    -typedef u64 cycle_t;
    
    @fix@
    typedef cycle_t;
    @@
    -cycle_t
    +u64
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: John Stultz <john.stultz@linaro.org>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 3c2c92aaa0ae..96ad1db0b04b 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -144,7 +144,7 @@ static struct clock_event_device ckevt = {
 	.set_state_oneshot	= timer_set_shutdown,
 };
 
-static cycle_t clksrc_read(struct clocksource *cs)
+static u64 clksrc_read(struct clocksource *cs)
 {
 	return timer_read();
 }

commit b501fd7b1c0f10d3967d3abbd6c9d091b3384999
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Apr 15 20:38:32 2014 +0200

    ARM: mmp: make all header files local
    
    The mach/*.h headers are now inaccessible to any external code,
    so we can move them all into the mach-mmp directory itself
    and remove the subdirectories.
    
    A few headers are not used at all, so we remove them here.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index dbc697b2fda1..3c2c92aaa0ae 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -29,14 +29,13 @@
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
 #include <linux/sched_clock.h>
-
-#include <mach/addr-map.h>
-#include <mach/regs-timers.h>
-#include <mach/regs-apbc.h>
-#include <mach/irqs.h>
-#include <mach/cputype.h>
 #include <asm/mach/time.h>
 
+#include "addr-map.h"
+#include "regs-timers.h"
+#include "regs-apbc.h"
+#include "irqs.h"
+#include "cputype.h"
 #include "clock.h"
 
 #ifdef CONFIG_CPU_MMP2

commit a785fb39e1b7070da5d53a7d09b140c80c31974e
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 27 13:39:52 2015 +0530

    ARM/mmp/time: Migrate to new 'set-state' interface
    
    Migrate mmp driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    We weren't doing anything in set_mode(RESUME) except of
    local_irq_{save|restore}(), which isn't required and so ->tick_resume
    isn't implemented.
    
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 10bfa03e58d4..dbc697b2fda1 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -124,32 +124,25 @@ static int timer_set_next_event(unsigned long delta,
 	return 0;
 }
 
-static void timer_set_mode(enum clock_event_mode mode,
-			   struct clock_event_device *dev)
+static int timer_set_shutdown(struct clock_event_device *evt)
 {
 	unsigned long flags;
 
 	local_irq_save(flags);
-	switch (mode) {
-	case CLOCK_EVT_MODE_ONESHOT:
-	case CLOCK_EVT_MODE_UNUSED:
-	case CLOCK_EVT_MODE_SHUTDOWN:
-		/* disable the matching interrupt */
-		__raw_writel(0x00, mmp_timer_base + TMR_IER(0));
-		break;
-	case CLOCK_EVT_MODE_RESUME:
-	case CLOCK_EVT_MODE_PERIODIC:
-		break;
-	}
+	/* disable the matching interrupt */
+	__raw_writel(0x00, mmp_timer_base + TMR_IER(0));
 	local_irq_restore(flags);
+
+	return 0;
 }
 
 static struct clock_event_device ckevt = {
-	.name		= "clockevent",
-	.features	= CLOCK_EVT_FEAT_ONESHOT,
-	.rating		= 200,
-	.set_next_event	= timer_set_next_event,
-	.set_mode	= timer_set_mode,
+	.name			= "clockevent",
+	.features		= CLOCK_EVT_FEAT_ONESHOT,
+	.rating			= 200,
+	.set_next_event		= timer_set_next_event,
+	.set_state_shutdown	= timer_set_shutdown,
+	.set_state_oneshot	= timer_set_shutdown,
 };
 
 static cycle_t clksrc_read(struct clocksource *cs)

commit 444d2d33d8564f95df851ddaca80f640ca36934d
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Feb 18 21:19:56 2015 +0100

    ARM: make of_device_ids const
    
    of_device_ids (i.e. compatible strings and the respective data) are not
    supposed to change at runtime. All functions working with of_device_ids
    provided by <linux/of.h> work with const of_device_ids. So mark the
    non-const structs in arch/arm as const, too.
    
    While at it also add some __initconst annotations.
    
    Acked-by: Jason Cooper <jason@lakedameon.net>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 2756351dbb35..10bfa03e58d4 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -213,7 +213,7 @@ void __init timer_init(int irq)
 }
 
 #ifdef CONFIG_OF
-static struct of_device_id mmp_timer_dt_ids[] = {
+static const struct of_device_id mmp_timer_dt_ids[] = {
 	{ .compatible = "mrvl,mmp-timer", },
 	{}
 };

commit dfc25e4503aef6b82a1de4a0fbe19aafa8648fbe
Merge: 9f800363bb0e 8f881c67368f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 5 13:51:19 2014 -0700

    Merge tag 'cleanup-3.15' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC cleanups from Arnd Bergmann:
     "These cleanup patches are mainly move stuff around and should all be
      harmless.  They are mainly split out so that other branches can be
      based on top to avoid conflicts.
    
      Notable changes are:
    
       - We finally remove all mach/timex.h, after CLOCK_TICK_RATE is no
         longer used (Uwe Kleine-König)
       - The Qualcomm MSM platform is split out into legacy mach-msm and
         new-style mach-qcom, to allow easier maintainance of the new
         hardware support without regressions (Kumar Gala)
       - A rework of some of the Kconfig logic to simplify multiplatform
         support (Rob Herring)
       - Samsung Exynos gets closer to supporting multiplatform (Sachin
         Kamat and others)
       - mach-bcm3528 gets merged into mach-bcm (Stephen Warren)
       - at91 gains some common clock framework support (Alexandre Belloni,
         Jean-Jacques Hiblot and other French people)"
    
    * tag 'cleanup-3.15' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (89 commits)
      ARM: hisi: select HAVE_ARM_SCU only for SMP
      ARM: efm32: allow uncompress debug output
      ARM: prima2: build reset code standalone
      ARM: at91: add PWM clock
      ARM: at91: move sam9261 SoC to common clk
      ARM: at91: prepare common clk transition for sam9261 SoC
      ARM: at91: updated the at91_dt_defconfig with support for the ADS7846
      ARM: at91: dt: sam9261: Device Tree support for the at91sam9261ek
      ARM: at91: dt: defconfig: Added the sam9261 to the list of DT-enabled SOCs
      ARM: at91: dt: Add at91sam9261 dt SoC support
      ARM: at91: switch sam9rl to common clock framework
      ARM: at91/dt: define main clk frequency of at91sam9rlek
      ARM: at91/dt: define at91sam9rl clocks
      ARM: at91: prepare common clk transition for sam9rl SoCs
      ARM: at91: prepare sam9 dt boards transition to common clk
      ARM: at91: dt: sam9rl: Device Tree for the at91sam9rlek
      ARM: at91/defconfig: Add the sam9rl to the list of DT-enabled SOCs
      ARM: at91: Add at91sam9rl DT SoC support
      ARM: at91: prepare at91sam9rl DT transition
      ARM: at91/defconfig: refresh at91sam9260_9g20_defconfig
      ...

commit 9929eedc0c3495105018f3c632ee73b7fb4c1f72
Author: Michael Opdenacker <michael@free-electrons.com>
Date:   Tue Mar 4 22:07:26 2014 +0100

    ARM: 8001/1: mmp: remove deprecated IRQF_DISABLED
    
    This patch removes the use of the IRQF_DISABLED flag
    from arch/arm/mach-mmp/time.c
    
    It's a NOOP since 2.6.35 and it will be removed one day.
    
    Signed-off-by: Michael Opdenacker <michael.opdenacker@free-electrons.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 024022d91fe3..bbcd2322fd27 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -186,7 +186,7 @@ static void __init timer_config(void)
 
 static struct irqaction timer_irq = {
 	.name		= "timer",
-	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.flags		= IRQF_TIMER | IRQF_IRQPOLL,
 	.handler	= timer_interrupt,
 	.dev_id		= &ckevt,
 };

commit 11d73c56b96b4297bd96273e9a22b7c72d13f1fa
Merge: 6d0abeca3242 fb3174e4ad24
Author: Olof Johansson <olof@lixom.net>
Date:   Tue Feb 18 22:19:33 2014 -0800

    Merge tag 'dropmachtimexh-v2' of git://git.pengutronix.de/git/ukl/linux into next/cleanup
    
    This cleanup series gets rid of <mach/timex.h> for platforms not using
    ARCH_MULTIPLATFORM. (For multi-platform code it's already unused since
    387798b (ARM: initial multiplatform support).)
    
    To make this work some code out of arch/arm needed to be adapted. The
    respective changes got acks by their maintainers to be taken via armsoc
    (with Andrew Morton substituting for Alessandro Zummo as rtc maintainer).
    
    Compared to the previous pull request there was another patch added that
    fixes a (non-critical) regression on ixp4xx. Olof Johansson asked to not
    squash this fix into the original commit to save him from the need to
    reverify the series.
    
    * tag 'dropmachtimexh-v2' of git://git.pengutronix.de/git/ukl/linux:
      ARM: ixp4xx: fix timer latch calculation
      ARM: drop <mach/timex.h> for !ARCH_MULTIPLATFORM, too
      ARM: rpc: stop using <mach/timex.h>
      ARM: ixp4xx: stop using <mach/timex.h>
      input: ixp4xx-beeper: don't use symbols from <mach/timex.h>
      ARM: at91: don't use <mach/timex.h>
      ARM: ep93xx: stop using mach/timex.h
      ARM: mmp: stop using mach/timex.h
      ARM: netx: stop using mach/timex.h
      ARM: sa1100: stop using mach/timex.h
      clocksource: sirf/marco+prima2: drop usage of CLOCK_TICK_RATE
      rtc: pxa: drop unused #define TIMER_FREQ
      rtc: at91sam9: include <mach/hardware.h> explicitly
      ARM/serial: at91: switch atmel serial to use gpiolib
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit ea15811992c74cbfa42ecbfbb0fdaeb377c9fe54
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Tue Nov 12 20:56:02 2013 +0100

    ARM: mmp: stop using mach/timex.h
    
    mach/timex.h is the last remaining header that is unused for multiarch
    builds but necessary for singlearch builds. To allow to get rid of it
    for singlearch builds, too, drop its usage in mmp arch code by
    substituting CLOCK_TICK_RATE by a local cpp symbol.
    
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 7ac41e83cfef..fb57d1113f5c 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -39,6 +39,12 @@
 
 #include "clock.h"
 
+#ifdef CONFIG_CPU_MMP2
+#define MMP_CLOCK_FREQ		6500000
+#else
+#define MMP_CLOCK_FREQ		3250000
+#endif
+
 #define TIMERS_VIRT_BASE	TIMERS1_VIRT_BASE
 
 #define MAX_DELTA		(0xfffffffe)
@@ -195,14 +201,14 @@ void __init timer_init(int irq)
 {
 	timer_config();
 
-	setup_sched_clock(mmp_read_sched_clock, 32, CLOCK_TICK_RATE);
+	setup_sched_clock(mmp_read_sched_clock, 32, MMP_CLOCK_FREQ);
 
 	ckevt.cpumask = cpumask_of(0);
 
 	setup_irq(irq, &timer_irq);
 
-	clocksource_register_hz(&cksrc, CLOCK_TICK_RATE);
-	clockevents_config_and_register(&ckevt, CLOCK_TICK_RATE,
+	clocksource_register_hz(&cksrc, MMP_CLOCK_FREQ);
+	clockevents_config_and_register(&ckevt, MMP_CLOCK_FREQ,
 					MIN_DELTA, MAX_DELTA);
 }
 

commit e5c0228d61f5802a14be901ae7fb97781c125987
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Nov 15 15:26:15 2013 -0800

    ARM: mmp: Switch to sched_clock_register()
    
    The 32 bit sched_clock interface now supports 64 bits. Upgrade to
    the 64 bit function to allow us to remove the 32 bit registration
    interface.
    
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Kevin Hilman <khilman@linaro.org>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 7ac41e83cfef..024022d91fe3 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -61,7 +61,7 @@ static inline uint32_t timer_read(void)
 	return __raw_readl(mmp_timer_base + TMR_CVWR(1));
 }
 
-static u32 notrace mmp_read_sched_clock(void)
+static u64 notrace mmp_read_sched_clock(void)
 {
 	return timer_read();
 }
@@ -195,7 +195,7 @@ void __init timer_init(int irq)
 {
 	timer_config();
 
-	setup_sched_clock(mmp_read_sched_clock, 32, CLOCK_TICK_RATE);
+	sched_clock_register(mmp_read_sched_clock, 32, CLOCK_TICK_RATE);
 
 	ckevt.cpumask = cpumask_of(0);
 

commit 38ff87f77af0b5a93fc8581cff1d6e5692ab8970
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Sat Jun 1 23:39:40 2013 -0700

    sched_clock: Make ARM's sched_clock generic for all architectures
    
    Nothing about the sched_clock implementation in the ARM port is
    specific to the architecture. Generalize the code so that other
    architectures can use it by selecting GENERIC_SCHED_CLOCK.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    [jstultz: Merge minor collisions with other patches in my tree]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 86a18b3d252e..7ac41e83cfef 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -28,8 +28,8 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
+#include <linux/sched_clock.h>
 
-#include <asm/sched_clock.h>
 #include <mach/addr-map.h>
 #include <mach/regs-timers.h>
 #include <mach/regs-apbc.h>

commit 838a2ae80a6ab52139fb1bf0a93ea8c5eff94488
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Sat Jan 12 11:50:05 2013 +0000

    ARM: use clockevents_config_and_register() where possible
    
    The clockevent core is able to figure out the best mult and shift,
    calculate min_delta_ns and max_delta_ns, with the necessary info passed
    into clockevents_config_and_register().  Use this combined configure
    and register function where possible to make the codes less error prone
    and gain some positive diff stat.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Reviewed-by: Anton Vorontsov <cbouatmailru@gmail.com>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Tested-by: Roland Stigge <stigge@antcom.de>
    Acked-by: Eric Miao <eric.y.miao@gmail.com>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: David Brown <davidb@codeaurora.org>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Barry Song <baohua.song@csr.com>
    Tested-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Tony Prisk <linux@prisktech.co.nz>
    Cc: Lennert Buytenhek <buytenh@wantstofly.org>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 936447c70977..86a18b3d252e 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -141,7 +141,6 @@ static void timer_set_mode(enum clock_event_mode mode,
 static struct clock_event_device ckevt = {
 	.name		= "clockevent",
 	.features	= CLOCK_EVT_FEAT_ONESHOT,
-	.shift		= 32,
 	.rating		= 200,
 	.set_next_event	= timer_set_next_event,
 	.set_mode	= timer_set_mode,
@@ -198,15 +197,13 @@ void __init timer_init(int irq)
 
 	setup_sched_clock(mmp_read_sched_clock, 32, CLOCK_TICK_RATE);
 
-	ckevt.mult = div_sc(CLOCK_TICK_RATE, NSEC_PER_SEC, ckevt.shift);
-	ckevt.max_delta_ns = clockevent_delta2ns(MAX_DELTA, &ckevt);
-	ckevt.min_delta_ns = clockevent_delta2ns(MIN_DELTA, &ckevt);
 	ckevt.cpumask = cpumask_of(0);
 
 	setup_irq(irq, &timer_irq);
 
 	clocksource_register_hz(&cksrc, CLOCK_TICK_RATE);
-	clockevents_register_device(&ckevt);
+	clockevents_config_and_register(&ckevt, CLOCK_TICK_RATE,
+					MIN_DELTA, MAX_DELTA);
 }
 
 #ifdef CONFIG_OF

commit c68ef2b5921cf26225533c8ed109386578060a98
Author: Haojian Zhuang <haojian.zhuang@gmail.com>
Date:   Thu Apr 12 19:05:40 2012 +0800

    ARM: mmp: support DT in timer
    
    Parse timer from DTS file. Avoid to use hardcoding marco for register.
    
    Signed-off-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 71fc4ee4602c..936447c70977 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -25,6 +25,9 @@
 
 #include <linux/io.h>
 #include <linux/irq.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
 
 #include <asm/sched_clock.h>
 #include <mach/addr-map.h>
@@ -41,6 +44,8 @@
 #define MAX_DELTA		(0xfffffffe)
 #define MIN_DELTA		(16)
 
+static void __iomem *mmp_timer_base = TIMERS_VIRT_BASE;
+
 /*
  * FIXME: the timer needs some delay to stablize the counter capture
  */
@@ -48,12 +53,12 @@ static inline uint32_t timer_read(void)
 {
 	int delay = 100;
 
-	__raw_writel(1, TIMERS_VIRT_BASE + TMR_CVWR(1));
+	__raw_writel(1, mmp_timer_base + TMR_CVWR(1));
 
 	while (delay--)
 		cpu_relax();
 
-	return __raw_readl(TIMERS_VIRT_BASE + TMR_CVWR(1));
+	return __raw_readl(mmp_timer_base + TMR_CVWR(1));
 }
 
 static u32 notrace mmp_read_sched_clock(void)
@@ -68,12 +73,12 @@ static irqreturn_t timer_interrupt(int irq, void *dev_id)
 	/*
 	 * Clear pending interrupt status.
 	 */
-	__raw_writel(0x01, TIMERS_VIRT_BASE + TMR_ICR(0));
+	__raw_writel(0x01, mmp_timer_base + TMR_ICR(0));
 
 	/*
 	 * Disable timer 0.
 	 */
-	__raw_writel(0x02, TIMERS_VIRT_BASE + TMR_CER);
+	__raw_writel(0x02, mmp_timer_base + TMR_CER);
 
 	c->event_handler(c);
 
@@ -90,23 +95,23 @@ static int timer_set_next_event(unsigned long delta,
 	/*
 	 * Disable timer 0.
 	 */
-	__raw_writel(0x02, TIMERS_VIRT_BASE + TMR_CER);
+	__raw_writel(0x02, mmp_timer_base + TMR_CER);
 
 	/*
 	 * Clear and enable timer match 0 interrupt.
 	 */
-	__raw_writel(0x01, TIMERS_VIRT_BASE + TMR_ICR(0));
-	__raw_writel(0x01, TIMERS_VIRT_BASE + TMR_IER(0));
+	__raw_writel(0x01, mmp_timer_base + TMR_ICR(0));
+	__raw_writel(0x01, mmp_timer_base + TMR_IER(0));
 
 	/*
 	 * Setup new clockevent timer value.
 	 */
-	__raw_writel(delta - 1, TIMERS_VIRT_BASE + TMR_TN_MM(0, 0));
+	__raw_writel(delta - 1, mmp_timer_base + TMR_TN_MM(0, 0));
 
 	/*
 	 * Enable timer 0.
 	 */
-	__raw_writel(0x03, TIMERS_VIRT_BASE + TMR_CER);
+	__raw_writel(0x03, mmp_timer_base + TMR_CER);
 
 	local_irq_restore(flags);
 
@@ -124,7 +129,7 @@ static void timer_set_mode(enum clock_event_mode mode,
 	case CLOCK_EVT_MODE_UNUSED:
 	case CLOCK_EVT_MODE_SHUTDOWN:
 		/* disable the matching interrupt */
-		__raw_writel(0x00, TIMERS_VIRT_BASE + TMR_IER(0));
+		__raw_writel(0x00, mmp_timer_base + TMR_IER(0));
 		break;
 	case CLOCK_EVT_MODE_RESUME:
 	case CLOCK_EVT_MODE_PERIODIC:
@@ -157,27 +162,27 @@ static struct clocksource cksrc = {
 
 static void __init timer_config(void)
 {
-	uint32_t ccr = __raw_readl(TIMERS_VIRT_BASE + TMR_CCR);
+	uint32_t ccr = __raw_readl(mmp_timer_base + TMR_CCR);
 
-	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_CER); /* disable */
+	__raw_writel(0x0, mmp_timer_base + TMR_CER); /* disable */
 
 	ccr &= (cpu_is_mmp2()) ? (TMR_CCR_CS_0(0) | TMR_CCR_CS_1(0)) :
 		(TMR_CCR_CS_0(3) | TMR_CCR_CS_1(3));
-	__raw_writel(ccr, TIMERS_VIRT_BASE + TMR_CCR);
+	__raw_writel(ccr, mmp_timer_base + TMR_CCR);
 
 	/* set timer 0 to periodic mode, and timer 1 to free-running mode */
-	__raw_writel(0x2, TIMERS_VIRT_BASE + TMR_CMR);
+	__raw_writel(0x2, mmp_timer_base + TMR_CMR);
 
-	__raw_writel(0x1, TIMERS_VIRT_BASE + TMR_PLCR(0)); /* periodic */
-	__raw_writel(0x7, TIMERS_VIRT_BASE + TMR_ICR(0));  /* clear status */
-	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_IER(0));
+	__raw_writel(0x1, mmp_timer_base + TMR_PLCR(0)); /* periodic */
+	__raw_writel(0x7, mmp_timer_base + TMR_ICR(0));  /* clear status */
+	__raw_writel(0x0, mmp_timer_base + TMR_IER(0));
 
-	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_PLCR(1)); /* free-running */
-	__raw_writel(0x7, TIMERS_VIRT_BASE + TMR_ICR(1));  /* clear status */
-	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_IER(1));
+	__raw_writel(0x0, mmp_timer_base + TMR_PLCR(1)); /* free-running */
+	__raw_writel(0x7, mmp_timer_base + TMR_ICR(1));  /* clear status */
+	__raw_writel(0x0, mmp_timer_base + TMR_IER(1));
 
 	/* enable timer 1 counter */
-	__raw_writel(0x2, TIMERS_VIRT_BASE + TMR_CER);
+	__raw_writel(0x2, mmp_timer_base + TMR_CER);
 }
 
 static struct irqaction timer_irq = {
@@ -203,3 +208,37 @@ void __init timer_init(int irq)
 	clocksource_register_hz(&cksrc, CLOCK_TICK_RATE);
 	clockevents_register_device(&ckevt);
 }
+
+#ifdef CONFIG_OF
+static struct of_device_id mmp_timer_dt_ids[] = {
+	{ .compatible = "mrvl,mmp-timer", },
+	{}
+};
+
+void __init mmp_dt_init_timer(void)
+{
+	struct device_node *np;
+	int irq, ret;
+
+	np = of_find_matching_node(NULL, mmp_timer_dt_ids);
+	if (!np) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	irq = irq_of_parse_and_map(np, 0);
+	if (!irq) {
+		ret = -EINVAL;
+		goto out;
+	}
+	mmp_timer_base = of_iomap(np, 0);
+	if (!mmp_timer_base) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	timer_init(irq);
+	return;
+out:
+	pr_err("Failed to get timer from device tree with error:%d\n", ret);
+}
+#endif

commit 2f0778afac79bd8d226225556858a636931eeabc
Author: Marc Zyngier <Marc.Zyngier@arm.com>
Date:   Thu Dec 15 12:19:23 2011 +0100

    ARM: 7205/2: sched_clock: allow sched_clock to be selected at runtime
    
    sched_clock() is yet another blocker on the road to the single
    image. This patch implements an idea by Russell King:
    
    http://www.spinics.net/lists/linux-omap/msg49561.html
    
    Instead of asking the platform to implement both sched_clock()
    itself and the rollover callback, simply register a read()
    function, and let the ARM code care about sched_clock() itself,
    the conversion to ns and the rollover. sched_clock() uses
    this read() function as an indirection to the platform code.
    If the platform doesn't provide a read(), the code falls back
    to the jiffy counter (just like the default sched_clock).
    
    This allow some simplifications and possibly some footprint gain
    when multiple platforms are compiled in. Among the drawbacks,
    the removal of the *_fixed_sched_clock optimization which could
    negatively impact some platforms (sa1100, tegra, versatile
    and omap).
    
    Tested on 11MPCore, OMAP4 and Tegra.
    
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Colin Cross <ccross@android.com>
    Cc: Erik Gilling <konkers@android.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Alessandro Rubini <rubini@unipv.it>
    Cc: STEricsson <STEricsson_nomadik_linux@list.st.com>
    Cc: Lennert Buytenhek <kernel@wantstofly.org>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Tested-by: Jamie Iles <jamie@jamieiles.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Krzysztof Halasa <khc@pm.waw.pl>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 4e91ee6e27c8..71fc4ee4602c 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -25,7 +25,6 @@
 
 #include <linux/io.h>
 #include <linux/irq.h>
-#include <linux/sched.h>
 
 #include <asm/sched_clock.h>
 #include <mach/addr-map.h>
@@ -42,8 +41,6 @@
 #define MAX_DELTA		(0xfffffffe)
 #define MIN_DELTA		(16)
 
-static DEFINE_CLOCK_DATA(cd);
-
 /*
  * FIXME: the timer needs some delay to stablize the counter capture
  */
@@ -59,16 +56,9 @@ static inline uint32_t timer_read(void)
 	return __raw_readl(TIMERS_VIRT_BASE + TMR_CVWR(1));
 }
 
-unsigned long long notrace sched_clock(void)
+static u32 notrace mmp_read_sched_clock(void)
 {
-	u32 cyc = timer_read();
-	return cyc_to_sched_clock(&cd, cyc, (u32)~0);
-}
-
-static void notrace mmp_update_sched_clock(void)
-{
-	u32 cyc = timer_read();
-	update_sched_clock(&cd, cyc, (u32)~0);
+	return timer_read();
 }
 
 static irqreturn_t timer_interrupt(int irq, void *dev_id)
@@ -201,7 +191,7 @@ void __init timer_init(int irq)
 {
 	timer_config();
 
-	init_sched_clock(&cd, mmp_update_sched_clock, 32, CLOCK_TICK_RATE);
+	setup_sched_clock(mmp_read_sched_clock, 32, CLOCK_TICK_RATE);
 
 	ckevt.mult = div_sc(CLOCK_TICK_RATE, NSEC_PER_SEC, ckevt.shift);
 	ckevt.max_delta_ns = clockevent_delta2ns(MAX_DELTA, &ckevt);

commit af9dafb1dcf320a46783e09764c758bc4e32ed94
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Wed Aug 10 02:37:55 2011 +0800

    ARM: mmp: Change the way we use timer 0 as clockevent timer.
    
    Instead of setting up a match interrupt for 'current_time + delta'
    on ->set_next_event(), program timer 0 to count down from 'delta - 1'
    and trigger an interrupt when it reaches zero.
    
    Signed-off-by: Lennert Buytenhek <buytenh@laptop.org>
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index c53715edfa82..4e91ee6e27c8 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -75,28 +75,51 @@ static irqreturn_t timer_interrupt(int irq, void *dev_id)
 {
 	struct clock_event_device *c = dev_id;
 
-	/* disable and clear pending interrupt status */
-	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_IER(0));
-	__raw_writel(0x1, TIMERS_VIRT_BASE + TMR_ICR(0));
+	/*
+	 * Clear pending interrupt status.
+	 */
+	__raw_writel(0x01, TIMERS_VIRT_BASE + TMR_ICR(0));
+
+	/*
+	 * Disable timer 0.
+	 */
+	__raw_writel(0x02, TIMERS_VIRT_BASE + TMR_CER);
+
 	c->event_handler(c);
+
 	return IRQ_HANDLED;
 }
 
 static int timer_set_next_event(unsigned long delta,
 				struct clock_event_device *dev)
 {
-	unsigned long flags, next;
+	unsigned long flags;
 
 	local_irq_save(flags);
 
-	/* clear pending interrupt status and enable */
+	/*
+	 * Disable timer 0.
+	 */
+	__raw_writel(0x02, TIMERS_VIRT_BASE + TMR_CER);
+
+	/*
+	 * Clear and enable timer match 0 interrupt.
+	 */
 	__raw_writel(0x01, TIMERS_VIRT_BASE + TMR_ICR(0));
 	__raw_writel(0x01, TIMERS_VIRT_BASE + TMR_IER(0));
 
-	next = timer_read() + delta;
-	__raw_writel(next, TIMERS_VIRT_BASE + TMR_TN_MM(0, 0));
+	/*
+	 * Setup new clockevent timer value.
+	 */
+	__raw_writel(delta - 1, TIMERS_VIRT_BASE + TMR_TN_MM(0, 0));
+
+	/*
+	 * Enable timer 0.
+	 */
+	__raw_writel(0x03, TIMERS_VIRT_BASE + TMR_CER);
 
 	local_irq_restore(flags);
+
 	return 0;
 }
 
@@ -152,10 +175,10 @@ static void __init timer_config(void)
 		(TMR_CCR_CS_0(3) | TMR_CCR_CS_1(3));
 	__raw_writel(ccr, TIMERS_VIRT_BASE + TMR_CCR);
 
-	/* free-running mode */
-	__raw_writel(0x3, TIMERS_VIRT_BASE + TMR_CMR);
+	/* set timer 0 to periodic mode, and timer 1 to free-running mode */
+	__raw_writel(0x2, TIMERS_VIRT_BASE + TMR_CMR);
 
-	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_PLCR(0)); /* free-running */
+	__raw_writel(0x1, TIMERS_VIRT_BASE + TMR_PLCR(0)); /* periodic */
 	__raw_writel(0x7, TIMERS_VIRT_BASE + TMR_ICR(0));  /* clear status */
 	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_IER(0));
 
@@ -163,8 +186,8 @@ static void __init timer_config(void)
 	__raw_writel(0x7, TIMERS_VIRT_BASE + TMR_ICR(1));  /* clear status */
 	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_IER(1));
 
-	/* enable timer counter */
-	__raw_writel(0x3, TIMERS_VIRT_BASE + TMR_CER);
+	/* enable timer 1 counter */
+	__raw_writel(0x2, TIMERS_VIRT_BASE + TMR_CER);
 }
 
 static struct irqaction timer_irq = {

commit 71c0c341403cb141e3580817947e56a4386db4c8
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Wed Aug 10 02:37:34 2011 +0800

    ARM: mmp: Switch to using timer 1 as clocksource timer.
    
    Signed-off-by: Lennert Buytenhek <buytenh@laptop.org>
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 09e88c25fe8e..c53715edfa82 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -51,12 +51,12 @@ static inline uint32_t timer_read(void)
 {
 	int delay = 100;
 
-	__raw_writel(1, TIMERS_VIRT_BASE + TMR_CVWR(0));
+	__raw_writel(1, TIMERS_VIRT_BASE + TMR_CVWR(1));
 
 	while (delay--)
 		cpu_relax();
 
-	return __raw_readl(TIMERS_VIRT_BASE + TMR_CVWR(0));
+	return __raw_readl(TIMERS_VIRT_BASE + TMR_CVWR(1));
 }
 
 unsigned long long notrace sched_clock(void)

commit 7ce5ae39c46f159aee3b3427844f1491e1ccac74
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Wed Aug 10 02:36:59 2011 +0800

    ARM: mmp: Also start timer 1 on boot.
    
    Currently, arch-mmp/time.c uses timer 0 both as a clocksource timer
    and as a clockevent timer, the latter by setting up a comparator
    interrupt to match on 'current_time + delta'.  This is problematic
    if delta is small enough, as that can lead to 'current_time + delta'
    already being in the past when comparator setup has finished, leading
    to the requested event not triggering.
    
    As there is also a silicon issue that requires stopping a timer's
    counter while writing to one of its match registers, we'll switch to
    using two separate timers -- timer 0 as clockevent timer, which we'll
    start and stop on every invocation of ->set_next_event(), and timer 1
    as clocksource timer, which will be free-running.
    
    This first patch enables timer 1 on boot, so that we can use it as
    clocksource timer.
    
    Signed-off-by: Lennert Buytenhek <buytenh@laptop.org>
    Acked-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 99833b9485cf..09e88c25fe8e 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -145,23 +145,26 @@ static struct clocksource cksrc = {
 static void __init timer_config(void)
 {
 	uint32_t ccr = __raw_readl(TIMERS_VIRT_BASE + TMR_CCR);
-	uint32_t cer = __raw_readl(TIMERS_VIRT_BASE + TMR_CER);
-	uint32_t cmr = __raw_readl(TIMERS_VIRT_BASE + TMR_CMR);
 
-	__raw_writel(cer & ~0x1, TIMERS_VIRT_BASE + TMR_CER); /* disable */
+	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_CER); /* disable */
 
-	ccr &= (cpu_is_mmp2()) ? TMR_CCR_CS_0(0) : TMR_CCR_CS_0(3);
+	ccr &= (cpu_is_mmp2()) ? (TMR_CCR_CS_0(0) | TMR_CCR_CS_1(0)) :
+		(TMR_CCR_CS_0(3) | TMR_CCR_CS_1(3));
 	__raw_writel(ccr, TIMERS_VIRT_BASE + TMR_CCR);
 
 	/* free-running mode */
-	__raw_writel(cmr | 0x01, TIMERS_VIRT_BASE + TMR_CMR);
+	__raw_writel(0x3, TIMERS_VIRT_BASE + TMR_CMR);
 
 	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_PLCR(0)); /* free-running */
 	__raw_writel(0x7, TIMERS_VIRT_BASE + TMR_ICR(0));  /* clear status */
 	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_IER(0));
 
+	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_PLCR(1)); /* free-running */
+	__raw_writel(0x7, TIMERS_VIRT_BASE + TMR_ICR(1));  /* clear status */
+	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_IER(1));
+
 	/* enable timer counter */
-	__raw_writel(cer | 0x01, TIMERS_VIRT_BASE + TMR_CER);
+	__raw_writel(0x3, TIMERS_VIRT_BASE + TMR_CER);
 }
 
 static struct irqaction timer_irq = {

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index aeb9ae23e6ce..99833b9485cf 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -9,7 +9,7 @@
  *   2008-04-11: Jason Chagas <Jason.chagas@marvell.com>
  *   2008-10-08: Bin Yang <bin.yang@marvell.com>
  *
- * The timers module actually includes three timers, each timer with upto
+ * The timers module actually includes three timers, each timer with up to
  * three match comparators. Timer #0 is used here in free-running mode as
  * the clock source, and match comparator #1 used as clock event device.
  *

commit 28bb7bc61a8cd48716d38d9c153fdc524f09870a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Dec 15 21:46:48 2010 +0000

    ARM: mmp: convert sched_clock() to use new infrastructure
    
    Convert mmp to use the new sched_clock() infrastructure for extending
    32bit counters to full 64-bit nanoseconds.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index a2ea33d04e63..aeb9ae23e6ce 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -26,8 +26,8 @@
 #include <linux/io.h>
 #include <linux/irq.h>
 #include <linux/sched.h>
-#include <linux/cnt32_to_63.h>
 
+#include <asm/sched_clock.h>
 #include <mach/addr-map.h>
 #include <mach/regs-timers.h>
 #include <mach/regs-apbc.h>
@@ -42,23 +42,7 @@
 #define MAX_DELTA		(0xfffffffe)
 #define MIN_DELTA		(16)
 
-#define TCR2NS_SCALE_FACTOR	10
-
-static unsigned long tcr2ns_scale;
-
-static void __init set_tcr2ns_scale(unsigned long tcr_rate)
-{
-	unsigned long long v = 1000000000ULL << TCR2NS_SCALE_FACTOR;
-	do_div(v, tcr_rate);
-	tcr2ns_scale = v;
-	/*
-	 * We want an even value to automatically clear the top bit
-	 * returned by cnt32_to_63() without an additional run time
-	 * instruction. So if the LSB is 1 then round it up.
-	 */
-	if (tcr2ns_scale & 1)
-		tcr2ns_scale++;
-}
+static DEFINE_CLOCK_DATA(cd);
 
 /*
  * FIXME: the timer needs some delay to stablize the counter capture
@@ -77,8 +61,14 @@ static inline uint32_t timer_read(void)
 
 unsigned long long notrace sched_clock(void)
 {
-	unsigned long long v = cnt32_to_63(timer_read());
-	return (v * tcr2ns_scale) >> TCR2NS_SCALE_FACTOR;
+	u32 cyc = timer_read();
+	return cyc_to_sched_clock(&cd, cyc, (u32)~0);
+}
+
+static void notrace mmp_update_sched_clock(void)
+{
+	u32 cyc = timer_read();
+	update_sched_clock(&cd, cyc, (u32)~0);
 }
 
 static irqreturn_t timer_interrupt(int irq, void *dev_id)
@@ -185,7 +175,7 @@ void __init timer_init(int irq)
 {
 	timer_config();
 
-	set_tcr2ns_scale(CLOCK_TICK_RATE);
+	init_sched_clock(&cd, mmp_update_sched_clock, 32, CLOCK_TICK_RATE);
 
 	ckevt.mult = div_sc(CLOCK_TICK_RATE, NSEC_PER_SEC, ckevt.shift);
 	ckevt.max_delta_ns = clockevent_delta2ns(MAX_DELTA, &ckevt);

commit 5e06b6492e53ab2a4e467763a9ee9f70b032c301
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Dec 15 19:19:25 2010 +0000

    ARM: ensure all sched_clock() implementations are notrace marked
    
    ftrace requires sched_clock() to be notrace.  Ensure that all
    implementations are so marked.  Also make sure that they include
    linux/sched.h
    
    Also ensure OMAP clocksource read functions are marked notrace as
    they're used for sched_clock() too.
    
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Will Deacon <will.deacon@arm.com>
    Tested-by: Mikael Pettersson <mikpe@it.uu.se>
    Tested-by: Eric Miao <eric.y.miao@gmail.com>
    Tested-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 0c0ab0931735..a2ea33d04e63 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -75,7 +75,7 @@ static inline uint32_t timer_read(void)
 	return __raw_readl(TIMERS_VIRT_BASE + TMR_CVWR(0));
 }
 
-unsigned long long sched_clock(void)
+unsigned long long notrace sched_clock(void)
 {
 	unsigned long long v = cnt32_to_63(timer_read());
 	return (v * tcr2ns_scale) >> TCR2NS_SCALE_FACTOR;

commit 5975f496e07e0f1e396939308b815f99907440ea
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Dec 13 13:18:04 2010 +0000

    ARM: mmp: update clock source registration
    
    In d7e81c2 (clocksource: Add clocksource_register_hz/khz interface) new
    interfaces were added which simplify (and optimize) the selection of the
    divisor shift/mult constants.  Switch over to using this new interface.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index 66528193f939..0c0ab0931735 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -146,7 +146,6 @@ static cycle_t clksrc_read(struct clocksource *cs)
 
 static struct clocksource cksrc = {
 	.name		= "clocksource",
-	.shift		= 20,
 	.rating		= 200,
 	.read		= clksrc_read,
 	.mask		= CLOCKSOURCE_MASK(32),
@@ -193,10 +192,8 @@ void __init timer_init(int irq)
 	ckevt.min_delta_ns = clockevent_delta2ns(MIN_DELTA, &ckevt);
 	ckevt.cpumask = cpumask_of(0);
 
-	cksrc.mult = clocksource_hz2mult(CLOCK_TICK_RATE, cksrc.shift);
-
 	setup_irq(irq, &timer_irq);
 
-	clocksource_register(&cksrc);
+	clocksource_register_hz(&cksrc, CLOCK_TICK_RATE);
 	clockevents_register_device(&ckevt);
 }

commit 4d4a339dd51390066d09701876a499996f1a5fdc
Author: Eric Miao <eric.y.miao@gmail.com>
Date:   Thu Jul 15 21:54:20 2010 +0800

    [ARM] mmp: move mmp2 specific timer code to mmp2.c
    
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index cf75694e9687..66528193f939 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -200,24 +200,3 @@ void __init timer_init(int irq)
 	clocksource_register(&cksrc);
 	clockevents_register_device(&ckevt);
 }
-
-static void __init mmp2_timer_init(void)
-{
-	unsigned long clk_rst;
-
-	__raw_writel(APBC_APBCLK | APBC_RST, APBC_MMP2_TIMERS);
-
-	/*
-	 * enable bus/functional clock, enable 6.5MHz (divider 4),
-	 * release reset
-	 */
-	clk_rst = APBC_APBCLK | APBC_FNCLK | APBC_FNCLKSEL(1);
-	__raw_writel(clk_rst, APBC_MMP2_TIMERS);
-
-	timer_init(IRQ_MMP2_TIMER1);
-}
-
-struct sys_timer mmp2_timer = {
-	.init	= mmp2_timer_init,
-};
-

commit 2f7e8faef5a50efaa1c173e99bdaa29e0129bb99
Author: Haojian Zhuang <haojian.zhuang@marvell.com>
Date:   Fri Dec 4 09:41:28 2009 -0500

    [ARM] mmp: add support for Marvell MMP2
    
    Marvell MMP2 (aka ARMADA610) is a SoC based on PJ4 core. It's
    ARMv6 compatible.  Support basic interrupt handler and timer,
    and basic support for MMP2 based FLINT platform.
    
    Signed-off-by: Haojian Zhuang <haojian.zhuang@marvell.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index a8400bb891e7..cf75694e9687 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -30,7 +30,10 @@
 
 #include <mach/addr-map.h>
 #include <mach/regs-timers.h>
+#include <mach/regs-apbc.h>
 #include <mach/irqs.h>
+#include <mach/cputype.h>
+#include <asm/mach/time.h>
 
 #include "clock.h"
 
@@ -158,7 +161,7 @@ static void __init timer_config(void)
 
 	__raw_writel(cer & ~0x1, TIMERS_VIRT_BASE + TMR_CER); /* disable */
 
-	ccr &= TMR_CCR_CS_0(0x3);
+	ccr &= (cpu_is_mmp2()) ? TMR_CCR_CS_0(0) : TMR_CCR_CS_0(3);
 	__raw_writel(ccr, TIMERS_VIRT_BASE + TMR_CCR);
 
 	/* free-running mode */
@@ -197,3 +200,24 @@ void __init timer_init(int irq)
 	clocksource_register(&cksrc);
 	clockevents_register_device(&ckevt);
 }
+
+static void __init mmp2_timer_init(void)
+{
+	unsigned long clk_rst;
+
+	__raw_writel(APBC_APBCLK | APBC_RST, APBC_MMP2_TIMERS);
+
+	/*
+	 * enable bus/functional clock, enable 6.5MHz (divider 4),
+	 * release reset
+	 */
+	clk_rst = APBC_APBCLK | APBC_FNCLK | APBC_FNCLKSEL(1);
+	__raw_writel(clk_rst, APBC_MMP2_TIMERS);
+
+	timer_init(IRQ_MMP2_TIMER1);
+}
+
+struct sys_timer mmp2_timer = {
+	.init	= mmp2_timer_init,
+};
+

commit f5c81a327015844eb91087dd102648b5d984f33c
Author: Coly Li <coly.li@suse.de>
Date:   Thu Apr 23 03:04:45 2009 +0800

    [ARM] pxa: add parameter to clksrc_read() for pxa168/910
    
    This patch modifies parameter of clksrc_read() from 'void' to
    'struct clocksource *cs', which fixes compile warning for
    incompatible parameter type.
    
    Signed-off-by: Coly Li <coly.li@suse.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Eric Miao <eric.miao@marvell.com>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
index b03a6eda7419..a8400bb891e7 100644
--- a/arch/arm/mach-mmp/time.c
+++ b/arch/arm/mach-mmp/time.c
@@ -136,7 +136,7 @@ static struct clock_event_device ckevt = {
 	.set_mode	= timer_set_mode,
 };
 
-static cycle_t clksrc_read(void)
+static cycle_t clksrc_read(struct clocksource *cs)
 {
 	return timer_read();
 }

commit 49cbe78637eb0503f45fc9b556ec08918a616534
Author: Eric Miao <eric.miao@marvell.com>
Date:   Tue Jan 20 14:15:18 2009 +0800

    [ARM] pxa: add base support for Marvell's PXA168 processor line
    
    """The Marvell® PXA168 processor is the first in a family of application
    processors targeted at mass market opportunities in computing and consumer
    devices. It balances high computing and multimedia performance with low
    power consumption to support extended battery life, and includes a wealth
    of integrated peripherals to reduce overall BOM cost .... """
    
    See http://www.marvell.com/featured/pxa168.jsp for more information.
    
      1. Marvell Mohawk core is a hybrid of xscale3 and its own ARM core,
         there are many enhancements like instructions for flushing the
         whole D-cache, and so on
    
      2. Clock reuses Russell's common clkdev, and added the basic support
         for UART1/2.
    
      3. Devices are a bit different from the 'mach-pxa' way, the platform
         devices are now dynamically allocated only when necessary (i.e.
         when pxa_register_device() is called). Description for each device
         are stored in an array of 'struct pxa_device_desc'. Now that:
    
         a. this array of device description is marked with __initdata and
            can be freed up system is fully up
    
         b. which means board code has to add all needed devices early in
            his initializing function
    
         c. platform specific data can now be marked as __initdata since
            they are allocated and copied by platform_device_add_data()
    
      4. only the basic UART1/2/3 are added, more devices will come later.
    
    Signed-off-by: Jason Chagas <chagas@marvell.com>
    Signed-off-by: Eric Miao <eric.miao@marvell.com>

diff --git a/arch/arm/mach-mmp/time.c b/arch/arm/mach-mmp/time.c
new file mode 100644
index 000000000000..b03a6eda7419
--- /dev/null
+++ b/arch/arm/mach-mmp/time.c
@@ -0,0 +1,199 @@
+/*
+ * linux/arch/arm/mach-mmp/time.c
+ *
+ *   Support for clocksource and clockevents
+ *
+ * Copyright (C) 2008 Marvell International Ltd.
+ * All rights reserved.
+ *
+ *   2008-04-11: Jason Chagas <Jason.chagas@marvell.com>
+ *   2008-10-08: Bin Yang <bin.yang@marvell.com>
+ *
+ * The timers module actually includes three timers, each timer with upto
+ * three match comparators. Timer #0 is used here in free-running mode as
+ * the clock source, and match comparator #1 used as clock event device.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/clockchips.h>
+
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/sched.h>
+#include <linux/cnt32_to_63.h>
+
+#include <mach/addr-map.h>
+#include <mach/regs-timers.h>
+#include <mach/irqs.h>
+
+#include "clock.h"
+
+#define TIMERS_VIRT_BASE	TIMERS1_VIRT_BASE
+
+#define MAX_DELTA		(0xfffffffe)
+#define MIN_DELTA		(16)
+
+#define TCR2NS_SCALE_FACTOR	10
+
+static unsigned long tcr2ns_scale;
+
+static void __init set_tcr2ns_scale(unsigned long tcr_rate)
+{
+	unsigned long long v = 1000000000ULL << TCR2NS_SCALE_FACTOR;
+	do_div(v, tcr_rate);
+	tcr2ns_scale = v;
+	/*
+	 * We want an even value to automatically clear the top bit
+	 * returned by cnt32_to_63() without an additional run time
+	 * instruction. So if the LSB is 1 then round it up.
+	 */
+	if (tcr2ns_scale & 1)
+		tcr2ns_scale++;
+}
+
+/*
+ * FIXME: the timer needs some delay to stablize the counter capture
+ */
+static inline uint32_t timer_read(void)
+{
+	int delay = 100;
+
+	__raw_writel(1, TIMERS_VIRT_BASE + TMR_CVWR(0));
+
+	while (delay--)
+		cpu_relax();
+
+	return __raw_readl(TIMERS_VIRT_BASE + TMR_CVWR(0));
+}
+
+unsigned long long sched_clock(void)
+{
+	unsigned long long v = cnt32_to_63(timer_read());
+	return (v * tcr2ns_scale) >> TCR2NS_SCALE_FACTOR;
+}
+
+static irqreturn_t timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *c = dev_id;
+
+	/* disable and clear pending interrupt status */
+	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_IER(0));
+	__raw_writel(0x1, TIMERS_VIRT_BASE + TMR_ICR(0));
+	c->event_handler(c);
+	return IRQ_HANDLED;
+}
+
+static int timer_set_next_event(unsigned long delta,
+				struct clock_event_device *dev)
+{
+	unsigned long flags, next;
+
+	local_irq_save(flags);
+
+	/* clear pending interrupt status and enable */
+	__raw_writel(0x01, TIMERS_VIRT_BASE + TMR_ICR(0));
+	__raw_writel(0x01, TIMERS_VIRT_BASE + TMR_IER(0));
+
+	next = timer_read() + delta;
+	__raw_writel(next, TIMERS_VIRT_BASE + TMR_TN_MM(0, 0));
+
+	local_irq_restore(flags);
+	return 0;
+}
+
+static void timer_set_mode(enum clock_event_mode mode,
+			   struct clock_event_device *dev)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	switch (mode) {
+	case CLOCK_EVT_MODE_ONESHOT:
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+		/* disable the matching interrupt */
+		__raw_writel(0x00, TIMERS_VIRT_BASE + TMR_IER(0));
+		break;
+	case CLOCK_EVT_MODE_RESUME:
+	case CLOCK_EVT_MODE_PERIODIC:
+		break;
+	}
+	local_irq_restore(flags);
+}
+
+static struct clock_event_device ckevt = {
+	.name		= "clockevent",
+	.features	= CLOCK_EVT_FEAT_ONESHOT,
+	.shift		= 32,
+	.rating		= 200,
+	.set_next_event	= timer_set_next_event,
+	.set_mode	= timer_set_mode,
+};
+
+static cycle_t clksrc_read(void)
+{
+	return timer_read();
+}
+
+static struct clocksource cksrc = {
+	.name		= "clocksource",
+	.shift		= 20,
+	.rating		= 200,
+	.read		= clksrc_read,
+	.mask		= CLOCKSOURCE_MASK(32),
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+static void __init timer_config(void)
+{
+	uint32_t ccr = __raw_readl(TIMERS_VIRT_BASE + TMR_CCR);
+	uint32_t cer = __raw_readl(TIMERS_VIRT_BASE + TMR_CER);
+	uint32_t cmr = __raw_readl(TIMERS_VIRT_BASE + TMR_CMR);
+
+	__raw_writel(cer & ~0x1, TIMERS_VIRT_BASE + TMR_CER); /* disable */
+
+	ccr &= TMR_CCR_CS_0(0x3);
+	__raw_writel(ccr, TIMERS_VIRT_BASE + TMR_CCR);
+
+	/* free-running mode */
+	__raw_writel(cmr | 0x01, TIMERS_VIRT_BASE + TMR_CMR);
+
+	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_PLCR(0)); /* free-running */
+	__raw_writel(0x7, TIMERS_VIRT_BASE + TMR_ICR(0));  /* clear status */
+	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_IER(0));
+
+	/* enable timer counter */
+	__raw_writel(cer | 0x01, TIMERS_VIRT_BASE + TMR_CER);
+}
+
+static struct irqaction timer_irq = {
+	.name		= "timer",
+	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler	= timer_interrupt,
+	.dev_id		= &ckevt,
+};
+
+void __init timer_init(int irq)
+{
+	timer_config();
+
+	set_tcr2ns_scale(CLOCK_TICK_RATE);
+
+	ckevt.mult = div_sc(CLOCK_TICK_RATE, NSEC_PER_SEC, ckevt.shift);
+	ckevt.max_delta_ns = clockevent_delta2ns(MAX_DELTA, &ckevt);
+	ckevt.min_delta_ns = clockevent_delta2ns(MIN_DELTA, &ckevt);
+	ckevt.cpumask = cpumask_of(0);
+
+	cksrc.mult = clocksource_hz2mult(CLOCK_TICK_RATE, cksrc.shift);
+
+	setup_irq(irq, &timer_irq);
+
+	clocksource_register(&cksrc);
+	clockevents_register_device(&ckevt);
+}
