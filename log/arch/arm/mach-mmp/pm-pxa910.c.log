commit 32adcaa010fa85e09296a6a606ad07348ef349ed
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Thu Aug 8 15:47:24 2019 +0200

    ARM: mmp: move cputype.h to include/linux/soc/
    
    Let's move cputype.h away from mach-mmp/ so that the drivers outside that
    directory are able to tell the precise silicon revision. The MMP3 USB OTG
    PHY driver needs this.
    
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>

diff --git a/arch/arm/mach-mmp/pm-pxa910.c b/arch/arm/mach-mmp/pm-pxa910.c
index 58535ce206dc..69ebe18ff209 100644
--- a/arch/arm/mach-mmp/pm-pxa910.c
+++ b/arch/arm/mach-mmp/pm-pxa910.c
@@ -18,7 +18,7 @@
 #include <asm/mach-types.h>
 #include <asm/outercache.h>
 
-#include "cputype.h"
+#include <linux/soc/mmp/cputype.h>
 #include "addr-map.h"
 #include "pm-pxa910.h"
 #include "regs-icu.h"

commit 4cb2acc0df04cfad7bd9d7b01a205234cc5f9a2a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:39 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 506
    
    Based on 1 normalized pattern(s):
    
      this software program is licensed subject to the gnu general public
      license gpl version 2 june 1991 available at http www fsf org
      copyleft gpl html
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Daniel German <dmg@turingmachine.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081207.687420463@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-mmp/pm-pxa910.c b/arch/arm/mach-mmp/pm-pxa910.c
index 8b47600b3cdf..58535ce206dc 100644
--- a/arch/arm/mach-mmp/pm-pxa910.c
+++ b/arch/arm/mach-mmp/pm-pxa910.c
@@ -1,9 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * PXA910 Power Management Routines
  *
- * This software program is licensed subject to the GNU General Public License
- * (GPL).Version 2,June 1991, available at http://www.fsf.org/copyleft/gpl.html
- *
  * (C) Copyright 2009 Marvell International Ltd.
  * All Rights Reserved
  */

commit b501fd7b1c0f10d3967d3abbd6c9d091b3384999
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Apr 15 20:38:32 2014 +0200

    ARM: mmp: make all header files local
    
    The mach/*.h headers are now inaccessible to any external code,
    so we can move them all into the mach-mmp directory itself
    and remove the subdirectories.
    
    A few headers are not used at all, so we remove them here.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-mmp/pm-pxa910.c b/arch/arm/mach-mmp/pm-pxa910.c
index 7db5870d127f..8b47600b3cdf 100644
--- a/arch/arm/mach-mmp/pm-pxa910.c
+++ b/arch/arm/mach-mmp/pm-pxa910.c
@@ -19,12 +19,12 @@
 #include <linux/irq.h>
 #include <asm/mach-types.h>
 #include <asm/outercache.h>
-#include <mach/hardware.h>
-#include <mach/cputype.h>
-#include <mach/addr-map.h>
-#include <mach/pm-pxa910.h>
-#include <mach/regs-icu.h>
-#include <mach/irqs.h>
+
+#include "cputype.h"
+#include "addr-map.h"
+#include "pm-pxa910.h"
+#include "regs-icu.h"
+#include "irqs.h"
 
 int pxa910_set_wake(struct irq_data *data, unsigned int on)
 {

commit f81309067ff2d84788316c513a415f6bb8c9171f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Jun 1 23:44:46 2015 +0100

    ARM: move heavy barrier support out of line
    
    The existing memory barrier macro causes a significant amount of code
    to be inserted inline at every call site.  For example, in
    gpio_set_irq_type(), we have this for mb():
    
    c0344c08:       f57ff04e        dsb     st
    c0344c0c:       e59f8190        ldr     r8, [pc, #400]  ; c0344da4 <gpio_set_irq_type+0x230>
    c0344c10:       e3590004        cmp     r9, #4
    c0344c14:       e5983014        ldr     r3, [r8, #20]
    c0344c18:       0a000054        beq     c0344d70 <gpio_set_irq_type+0x1fc>
    c0344c1c:       e3530000        cmp     r3, #0
    c0344c20:       0a000004        beq     c0344c38 <gpio_set_irq_type+0xc4>
    c0344c24:       e50b2030        str     r2, [fp, #-48]  ; 0xffffffd0
    c0344c28:       e50bc034        str     ip, [fp, #-52]  ; 0xffffffcc
    c0344c2c:       e12fff33        blx     r3
    c0344c30:       e51bc034        ldr     ip, [fp, #-52]  ; 0xffffffcc
    c0344c34:       e51b2030        ldr     r2, [fp, #-48]  ; 0xffffffd0
    c0344c38:       e5963004        ldr     r3, [r6, #4]
    
    Moving the outer_cache_sync() call out of line reduces the impact of
    the barrier:
    
    c0344968:       f57ff04e        dsb     st
    c034496c:       e35a0004        cmp     sl, #4
    c0344970:       e50b2030        str     r2, [fp, #-48]  ; 0xffffffd0
    c0344974:       0a000044        beq     c0344a8c <gpio_set_irq_type+0x1b8>
    c0344978:       ebf363dd        bl      c001d8f4 <arm_heavy_mb>
    c034497c:       e5953004        ldr     r3, [r5, #4]
    
    This should reduce the cache footprint of this code.  Overall, this
    results in a reduction of around 20K in the kernel size:
    
        text    data      bss      dec     hex filename
    10773970  667392 10369656 21811018 14ccf4a ../build/imx6/vmlinux-old
    10754219  667392 10369656 21791267 14c8223 ../build/imx6/vmlinux-new
    
    Another advantage to this approach is that we can finally resolve the
    issue of SoCs which have their own memory barrier requirements within
    multiplatform kernels (such as OMAP.)  Here, the bus interconnects
    need additional handling to ensure that writes become visible in the
    correct order (eg, between dma_map() operations, writes to DMA
    coherent memory, and MMIO accesses.)
    
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Richard Woodruff <r-woodruff2@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-mmp/pm-pxa910.c b/arch/arm/mach-mmp/pm-pxa910.c
index 04c9daf9f8d7..7db5870d127f 100644
--- a/arch/arm/mach-mmp/pm-pxa910.c
+++ b/arch/arm/mach-mmp/pm-pxa910.c
@@ -18,6 +18,7 @@
 #include <linux/io.h>
 #include <linux/irq.h>
 #include <asm/mach-types.h>
+#include <asm/outercache.h>
 #include <mach/hardware.h>
 #include <mach/cputype.h>
 #include <mach/addr-map.h>

commit 49f3fbc7b8576fd578f3504c65aae9b8a212d0f6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Feb 23 21:40:13 2014 +0000

    arm: mmp: Remove pointless fiddling with irq internals
    
    The pm-mmp2 and pm-pxa910 power management related irq_set_wake
    callbacks fiddle pointlessly with the irq actions for no reason except
    for lack of understanding how the wakeup mechanism works.
    
    On supsend the core disables all interrupts lazily, i.e. it does not
    mask them at the irq controller level. So any interrupt which is
    firing during suspend will mark the corresponding interrupt line as
    pending. Just before the core powers down it checks whether there are
    interrupts pending from interrupt lines which are marked as wakeup
    sources and if so it aborts the suspend and resends the interrupts.
    If there was no interrupt at this point, the cpu goes into suspend
    with these interrupts unmasked.
    
    The IRQF_NO_SUSPEND flag for interrupt actions is a totally different
    mechanism. That allows the device driver to prevent the core from
    disabling the interrupt despite the fact that it is not marked as a
    wakeup source. This has nothing to do with the case at hand. It was
    introduced for special cases where lazy disable is not possible.
    
    Remove the nonsense along with the braindamaged boundary check. The
    core code does NOT call these functions out of boundary.
    
    Add a FIXME comment to an unhandled error path which merily printks
    some useless blurb instead of returning a proper error code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: arm <linux-arm-kernel@lists.infradead.org>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Link: http://lkml.kernel.org/r/20140223212737.214342433@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/mach-mmp/pm-pxa910.c b/arch/arm/mach-mmp/pm-pxa910.c
index 48981ca801a5..04c9daf9f8d7 100644
--- a/arch/arm/mach-mmp/pm-pxa910.c
+++ b/arch/arm/mach-mmp/pm-pxa910.c
@@ -27,22 +27,8 @@
 
 int pxa910_set_wake(struct irq_data *data, unsigned int on)
 {
-	int irq = data->irq;
-	struct irq_desc *desc = irq_to_desc(data->irq);
 	uint32_t awucrm = 0, apcr = 0;
-
-	if (unlikely(irq >= nr_irqs)) {
-		pr_err("IRQ nubmers are out of boundary!\n");
-		return -EINVAL;
-	}
-
-	if (on) {
-		if (desc->action)
-			desc->action->flags |= IRQF_NO_SUSPEND;
-	} else {
-		if (desc->action)
-			desc->action->flags &= ~IRQF_NO_SUSPEND;
-	}
+	int irq = data->irq;
 
 	/* setting wakeup sources */
 	switch (irq) {
@@ -115,9 +101,11 @@ int pxa910_set_wake(struct irq_data *data, unsigned int on)
 		if (irq >= IRQ_GPIO_START && irq < IRQ_BOARD_START) {
 			awucrm = MPMU_AWUCRM_WAKEUP(2);
 			apcr |= MPMU_APCR_SLPWP2;
-		} else
+		} else {
+			/* FIXME: This should return a proper error code ! */
 			printk(KERN_ERR "Error: no defined wake up source irq: %d\n",
 				irq);
+		}
 	}
 
 	if (on) {

commit 902ca2297180fe97f840427c114cc6dc7e77375e
Author: Chao Xie <chao.xie@marvell.com>
Date:   Mon May 7 11:24:01 2012 +0800

    ARM: mmp: add pm support for pxa910
    
    add suspend/resume functionality for pxa910
    
    Signed-off-by: Chao Xie <chao.xie@marvell.com>
    Signed-off-by: Raul Xiong <xjian@marvell.com>
    Signed-off-by: Haojian Zhuang <haojian.zhuang@gmail.com>

diff --git a/arch/arm/mach-mmp/pm-pxa910.c b/arch/arm/mach-mmp/pm-pxa910.c
new file mode 100644
index 000000000000..48981ca801a5
--- /dev/null
+++ b/arch/arm/mach-mmp/pm-pxa910.c
@@ -0,0 +1,285 @@
+/*
+ * PXA910 Power Management Routines
+ *
+ * This software program is licensed subject to the GNU General Public License
+ * (GPL).Version 2,June 1991, available at http://www.fsf.org/copyleft/gpl.html
+ *
+ * (C) Copyright 2009 Marvell International Ltd.
+ * All Rights Reserved
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/suspend.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+#include <mach/cputype.h>
+#include <mach/addr-map.h>
+#include <mach/pm-pxa910.h>
+#include <mach/regs-icu.h>
+#include <mach/irqs.h>
+
+int pxa910_set_wake(struct irq_data *data, unsigned int on)
+{
+	int irq = data->irq;
+	struct irq_desc *desc = irq_to_desc(data->irq);
+	uint32_t awucrm = 0, apcr = 0;
+
+	if (unlikely(irq >= nr_irqs)) {
+		pr_err("IRQ nubmers are out of boundary!\n");
+		return -EINVAL;
+	}
+
+	if (on) {
+		if (desc->action)
+			desc->action->flags |= IRQF_NO_SUSPEND;
+	} else {
+		if (desc->action)
+			desc->action->flags &= ~IRQF_NO_SUSPEND;
+	}
+
+	/* setting wakeup sources */
+	switch (irq) {
+	/* wakeup line 2 */
+	case IRQ_PXA910_AP_GPIO:
+		awucrm = MPMU_AWUCRM_WAKEUP(2);
+		apcr |= MPMU_APCR_SLPWP2;
+		break;
+	/* wakeup line 3 */
+	case IRQ_PXA910_KEYPAD:
+		awucrm = MPMU_AWUCRM_WAKEUP(3) | MPMU_AWUCRM_KEYPRESS;
+		apcr |= MPMU_APCR_SLPWP3;
+		break;
+	case IRQ_PXA910_ROTARY:
+		awucrm = MPMU_AWUCRM_WAKEUP(3) | MPMU_AWUCRM_NEWROTARY;
+		apcr |= MPMU_APCR_SLPWP3;
+		break;
+	case IRQ_PXA910_TRACKBALL:
+		awucrm = MPMU_AWUCRM_WAKEUP(3) | MPMU_AWUCRM_TRACKBALL;
+		apcr |= MPMU_APCR_SLPWP3;
+		break;
+	/* wakeup line 4 */
+	case IRQ_PXA910_AP1_TIMER1:
+		awucrm = MPMU_AWUCRM_WAKEUP(4) | MPMU_AWUCRM_AP1_TIMER_1;
+		apcr |= MPMU_APCR_SLPWP4;
+		break;
+	case IRQ_PXA910_AP1_TIMER2:
+		awucrm = MPMU_AWUCRM_WAKEUP(4) | MPMU_AWUCRM_AP1_TIMER_2;
+		apcr |= MPMU_APCR_SLPWP4;
+		break;
+	case IRQ_PXA910_AP1_TIMER3:
+		awucrm = MPMU_AWUCRM_WAKEUP(4) | MPMU_AWUCRM_AP1_TIMER_3;
+		apcr |= MPMU_APCR_SLPWP4;
+		break;
+	case IRQ_PXA910_AP2_TIMER1:
+		awucrm = MPMU_AWUCRM_WAKEUP(4) | MPMU_AWUCRM_AP2_TIMER_1;
+		apcr |= MPMU_APCR_SLPWP4;
+		break;
+	case IRQ_PXA910_AP2_TIMER2:
+		awucrm = MPMU_AWUCRM_WAKEUP(4) | MPMU_AWUCRM_AP2_TIMER_2;
+		apcr |= MPMU_APCR_SLPWP4;
+		break;
+	case IRQ_PXA910_AP2_TIMER3:
+		awucrm = MPMU_AWUCRM_WAKEUP(4) | MPMU_AWUCRM_AP2_TIMER_3;
+		apcr |= MPMU_APCR_SLPWP4;
+		break;
+	case IRQ_PXA910_RTC_ALARM:
+		awucrm = MPMU_AWUCRM_WAKEUP(4) | MPMU_AWUCRM_RTC_ALARM;
+		apcr |= MPMU_APCR_SLPWP4;
+		break;
+	/* wakeup line 5 */
+	case IRQ_PXA910_USB1:
+	case IRQ_PXA910_USB2:
+		awucrm = MPMU_AWUCRM_WAKEUP(5);
+		apcr |= MPMU_APCR_SLPWP5;
+		break;
+	/* wakeup line 6 */
+	case IRQ_PXA910_MMC:
+		awucrm = MPMU_AWUCRM_WAKEUP(6)
+			| MPMU_AWUCRM_SDH1
+			| MPMU_AWUCRM_SDH2;
+		apcr |= MPMU_APCR_SLPWP6;
+		break;
+	/* wakeup line 7 */
+	case IRQ_PXA910_PMIC_INT:
+		awucrm = MPMU_AWUCRM_WAKEUP(7);
+		apcr |= MPMU_APCR_SLPWP7;
+		break;
+	default:
+		if (irq >= IRQ_GPIO_START && irq < IRQ_BOARD_START) {
+			awucrm = MPMU_AWUCRM_WAKEUP(2);
+			apcr |= MPMU_APCR_SLPWP2;
+		} else
+			printk(KERN_ERR "Error: no defined wake up source irq: %d\n",
+				irq);
+	}
+
+	if (on) {
+		if (awucrm) {
+			awucrm |= __raw_readl(MPMU_AWUCRM);
+			__raw_writel(awucrm, MPMU_AWUCRM);
+		}
+		if (apcr) {
+			apcr = ~apcr & __raw_readl(MPMU_APCR);
+			__raw_writel(apcr, MPMU_APCR);
+		}
+	} else {
+		if (awucrm) {
+			awucrm = ~awucrm & __raw_readl(MPMU_AWUCRM);
+			__raw_writel(awucrm, MPMU_AWUCRM);
+		}
+		if (apcr) {
+			apcr |= __raw_readl(MPMU_APCR);
+			__raw_writel(apcr, MPMU_APCR);
+		}
+	}
+	return 0;
+}
+
+void pxa910_pm_enter_lowpower_mode(int state)
+{
+	uint32_t idle_cfg, apcr;
+
+	idle_cfg = __raw_readl(APMU_MOH_IDLE_CFG);
+	apcr = __raw_readl(MPMU_APCR);
+
+	apcr &= ~(MPMU_APCR_DDRCORSD | MPMU_APCR_APBSD | MPMU_APCR_AXISD
+		| MPMU_APCR_VCTCXOSD | MPMU_APCR_STBYEN);
+	idle_cfg &= ~(APMU_MOH_IDLE_CFG_MOH_IDLE
+		| APMU_MOH_IDLE_CFG_MOH_PWRDWN);
+
+	switch (state) {
+	case POWER_MODE_UDR:
+		/* only shutdown APB in UDR */
+		apcr |= MPMU_APCR_STBYEN | MPMU_APCR_APBSD;
+		/* fall through */
+	case POWER_MODE_SYS_SLEEP:
+		apcr |= MPMU_APCR_SLPEN;		/* set the SLPEN bit */
+		apcr |= MPMU_APCR_VCTCXOSD;		/* set VCTCXOSD */
+		/* fall through */
+	case POWER_MODE_APPS_SLEEP:
+		apcr |= MPMU_APCR_DDRCORSD;		/* set DDRCORSD */
+		/* fall through */
+	case POWER_MODE_APPS_IDLE:
+		apcr |= MPMU_APCR_AXISD;		/* set AXISDD bit */
+		/* fall through */
+	case POWER_MODE_CORE_EXTIDLE:
+		idle_cfg |= APMU_MOH_IDLE_CFG_MOH_IDLE;
+		idle_cfg |= APMU_MOH_IDLE_CFG_MOH_PWRDWN;
+		idle_cfg |= APMU_MOH_IDLE_CFG_MOH_PWR_SW(3)
+			| APMU_MOH_IDLE_CFG_MOH_L2_PWR_SW(3);
+		/* fall through */
+	case POWER_MODE_CORE_INTIDLE:
+		break;
+	}
+
+	/* program the memory controller hardware sleep type and auto wakeup */
+	idle_cfg |= APMU_MOH_IDLE_CFG_MOH_DIS_MC_SW_REQ;
+	idle_cfg |= APMU_MOH_IDLE_CFG_MOH_MC_WAKE_EN;
+	__raw_writel(0x0, APMU_MC_HW_SLP_TYPE);		/* auto refresh */
+
+	/* set DSPSD, DTCMSD, BBSD, MSASLPEN */
+	apcr |= MPMU_APCR_DSPSD | MPMU_APCR_DTCMSD | MPMU_APCR_BBSD
+		| MPMU_APCR_MSASLPEN;
+
+	/*always set SLEPEN bit mainly for MSA*/
+	apcr |= MPMU_APCR_SLPEN;
+
+	/* finally write the registers back */
+	__raw_writel(idle_cfg, APMU_MOH_IDLE_CFG);
+	__raw_writel(apcr, MPMU_APCR);
+
+}
+
+static int pxa910_pm_enter(suspend_state_t state)
+{
+	unsigned int idle_cfg, reg = 0;
+
+	/*pmic thread not completed,exit;otherwise system can't be waked up*/
+	reg = __raw_readl(ICU_INT_CONF(IRQ_PXA910_PMIC_INT));
+	if ((reg & 0x3) == 0)
+		return -EAGAIN;
+
+	idle_cfg = __raw_readl(APMU_MOH_IDLE_CFG);
+	idle_cfg |= APMU_MOH_IDLE_CFG_MOH_PWRDWN
+		| APMU_MOH_IDLE_CFG_MOH_SRAM_PWRDWN;
+	__raw_writel(idle_cfg, APMU_MOH_IDLE_CFG);
+
+	/* disable L2 */
+	outer_disable();
+	/* wait for l2 idle */
+	while (!(readl(CIU_REG(0x8)) & (1 << 16)))
+		udelay(1);
+
+	cpu_do_idle();
+
+	/* enable L2 */
+	outer_resume();
+	/* wait for l2 idle */
+	while (!(readl(CIU_REG(0x8)) & (1 << 16)))
+		udelay(1);
+
+	idle_cfg = __raw_readl(APMU_MOH_IDLE_CFG);
+	idle_cfg &= ~(APMU_MOH_IDLE_CFG_MOH_PWRDWN
+		| APMU_MOH_IDLE_CFG_MOH_SRAM_PWRDWN);
+	__raw_writel(idle_cfg, APMU_MOH_IDLE_CFG);
+
+	return 0;
+}
+
+/*
+ * Called after processes are frozen, but before we shut down devices.
+ */
+static int pxa910_pm_prepare(void)
+{
+	pxa910_pm_enter_lowpower_mode(POWER_MODE_UDR);
+	return 0;
+}
+
+/*
+ * Called after devices are re-setup, but before processes are thawed.
+ */
+static void pxa910_pm_finish(void)
+{
+	pxa910_pm_enter_lowpower_mode(POWER_MODE_CORE_INTIDLE);
+}
+
+static int pxa910_pm_valid(suspend_state_t state)
+{
+	return ((state == PM_SUSPEND_STANDBY) || (state == PM_SUSPEND_MEM));
+}
+
+static const struct platform_suspend_ops pxa910_pm_ops = {
+	.valid		= pxa910_pm_valid,
+	.prepare	= pxa910_pm_prepare,
+	.enter		= pxa910_pm_enter,
+	.finish		= pxa910_pm_finish,
+};
+
+static int __init pxa910_pm_init(void)
+{
+	uint32_t awucrm = 0;
+
+	if (!cpu_is_pxa910())
+		return -EIO;
+
+	suspend_set_ops(&pxa910_pm_ops);
+
+	/* Set the following bits for MMP3 playback with VCTXO on */
+	__raw_writel(__raw_readl(APMU_SQU_CLK_GATE_CTRL) | (1 << 30),
+		APMU_SQU_CLK_GATE_CTRL);
+	__raw_writel(__raw_readl(MPMU_FCCR) | (1 << 28), MPMU_FCCR);
+
+	awucrm |= MPMU_AWUCRM_AP_ASYNC_INT | MPMU_AWUCRM_AP_FULL_IDLE;
+	__raw_writel(awucrm, MPMU_AWUCRM);
+
+	return 0;
+}
+
+late_initcall(pxa910_pm_init);
