commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 69c2361ca688..0810f3abd810 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2002 ARM Ltd.
  * Copyright (C) 2008 STMicroelctronics.
@@ -5,10 +6,6 @@
  * Author: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
  *
  * This file is based on arm realview platform
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 #include <linux/init.h>
 #include <linux/errno.h>

commit a1a0db36d8c89243d989186108fe9196ad0e2c2d
Merge: 0a040b2113ec ca2dea434d10
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 3 16:15:48 2017 -0800

    Merge tag 'armsoc-late' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC late DT updates from Arnd Bergmann:
     "These updates have been kept in a separate branch mostly because they
      rely on updates to the respective clk drivers to keep the shared
      header files in sync.
    
      This includes two branches for arm64 dt updates, both following up on
      earlier changes for the same platforms that are already merged:
    
      Samsung:
       - add USB3 support in Exynos7
       - minor PM related updates
    
      Amlogic:
       - new machines: WeTek Set-top-boxes
       - various devices added to DT
    
      There are also a couple of bugfixes that trickled in since the start
      of the merge window:
    
       - The moxart_defconfig was not building the intended platform
       - CPU-hotplug was broken on ux500
       - Coresight was broken on Juno (never worked)"
    
    * tag 'armsoc-late' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (26 commits)
      ARM: deconfig: fix the moxart defconfig
      ARM: ux500: resume the second core properly
      arm64: dts: juno: update definition for programmable replicator
      arm64: dts: exynos: Add regulators for Vbus and Vbus-Boost
      arm64: dts: exynos: Add USB 3.0 controller node for Exynos7
      arm64: dts: exynos: Use macros for pinctrl configuration on Exynos7
      pinctrl: dt-bindings: samsung: Add Exynos7 specific pinctrl macro definitions
      arm64: dts: exynos: Add initial configuration for DISP clocks for TM2/TM2e
      ARM64: dts: meson-gxbb-p200: add ADC laddered keys
      ARM64: dts: meson: meson-gx: add the SAR ADC
      ARM64: dts: meson-gxl: add the pwm_ao_b pin
      ARM64: dts: meson-gx: add the missing pwm_AO_ab node
      clk: gxbb: fix CLKID_ETH defined twice
      ARM64: dts: meson-gxl: rename Nexbox A95x for consistency
      clk: gxbb: add the SAR ADC clocks and expose them
      dt-bindings: amlogic: Add WeTek boards
      ARM64: dts: meson-gxbb: Add support for WeTek Hub and Play
      dt-bindings: vendor-prefix: Add wetek vendor prefix
      ARM64: dts: meson-gxm: Rename q200 and q201 DT files for consistency
      ARM64: dts: meson-gx: Add HDMI HPD/DDC pinctrl nodes
      ...

commit 3131d970f0d86bea41811766d55fc638e382daf3
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Feb 27 10:13:38 2017 +0100

    ARM: ux500: resume the second core properly
    
    The pen hold/release scheme was copied over to Ux500 from the ARM
    reference designs like most of these at the time. It is not needed
    at all, and was mostly removed in commit c00def71efd9
    "ARM: ux500: simplify secondary CPU boot".
    
    However on the suspend/resume path and hot plug/unplug of CPUs,
    the .cpu_die() callback was still waiting for the pen to be
    released which made it spin forever and the second core never come
    back online after suspend/resume.
    
    Fix this by simply replacing the strange custom .cpu_die() with
    a oneline wfi() just like e.g. the qcom platform does. This fixes
    the issue and makes the second core come up properly after
    suspend/resume.
    
    As a side effect, this rids us of the completely surplus local
    setup.h and hotplug.c files, and we just compile this into platsmp.c
    with everything else SMP.
    
    Cc: stable@vger.kernel.org
    Fixes: c00def71efd9 ("ARM: ux500: simplify secondary CPU boot")
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index e0ee139fdebf..19c165aeecd2 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -23,8 +23,6 @@
 #include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
 
-#include "setup.h"
-
 #include "db8500-regs.h"
 
 /* Magic triggers in backup RAM */
@@ -90,6 +88,13 @@ static int ux500_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	return 0;
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+void ux500_cpu_die(unsigned int cpu)
+{
+	wfi();
+}
+#endif
+
 static const struct smp_operations ux500_smp_ops __initconst = {
 	.smp_prepare_cpus	= ux500_smp_prepare_cpus,
 	.smp_boot_secondary	= ux500_boot_secondary,

commit d4f4cf77b37eaea58ef863a4cbc95dad3880b524
Merge: f89db789de21 17a870bea3b8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 28 11:50:53 2017 -0800

    Merge branch 'for-linus' of git://git.armlinux.org.uk/~rmk/linux-arm
    
    Pull ARM updates from Russell King:
    
     - nommu updates from Afzal Mohammed cleaning up the vectors support
    
     - allow DMA memory "mapping" for nommu Benjamin Gaignard
    
     - fixing a correctness issue with R_ARM_PREL31 relocations in the
       module linker
    
     - add strlen() prototype for the decompressor
    
     - support for DEBUG_VIRTUAL from Florian Fainelli
    
     - adjusting memory bounds after memory reservations have been
       registered
    
     - unipher cache handling updates from Masahiro Yamada
    
     - initrd and Thumb Kconfig cleanups
    
    * 'for-linus' of git://git.armlinux.org.uk/~rmk/linux-arm: (23 commits)
      ARM: mm: round the initrd reservation to page boundaries
      ARM: mm: clean up initrd initialisation
      ARM: mm: move initrd init code out of arm_memblock_init()
      ARM: 8655/1: improve NOMMU definition of pgprot_*()
      ARM: 8654/1: decompressor: add strlen prototype
      ARM: 8652/1: cache-uniphier: clean up active way setup code
      ARM: 8651/1: cache-uniphier: include <linux/errno.h> instead of <linux/types.h>
      ARM: 8650/1: module: handle negative R_ARM_PREL31 addends correctly
      ARM: 8649/2: nommu: remove Hivecs configuration is asm
      ARM: 8648/2: nommu: display vectors base
      ARM: 8647/2: nommu: dynamic exception base address setting
      ARM: 8646/1: mmu: decouple VECTORS_BASE from Kconfig
      ARM: 8644/1: Reduce "CPU: shutdown" message to debug level
      ARM: 8641/1: treewide: Replace uses of virt_to_phys with __pa_symbol
      ARM: 8640/1: Add support for CONFIG_DEBUG_VIRTUAL
      ARM: 8639/1: Define KERNEL_START and KERNEL_END
      ARM: 8638/1: mtd: lart: Rename partition defines to be prefixed with PART_
      ARM: 8637/1: Adjust memory boundaries after reservations
      ARM: 8636/1: Cleanup sanity_check_meminfo
      ARM: add CPU_THUMB_CAPABLE to indicate possible Thumb support
      ...

commit 64fc2a947a9873700929ec0ef02b4654a04e0476
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sun Jan 15 03:59:29 2017 +0100

    ARM: 8641/1: treewide: Replace uses of virt_to_phys with __pa_symbol
    
    All low-level PM/SMP code using virt_to_phys() should actually use
    __pa_symbol() against kernel symbols. Update code where relevant to move
    away from virt_to_phys().
    
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Laura Abbott <labbott@redhat.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 8f2f615ff958..8c8f26389067 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -54,7 +54,7 @@ static void wakeup_secondary(void)
 	 * backup ram register at offset 0x1FF0, which is what boot rom code
 	 * is waiting for. This will wake up the secondary core from WFE.
 	 */
-	writel(virt_to_phys(secondary_startup),
+	writel(__pa_symbol(secondary_startup),
 	       backupram + UX500_CPU1_JUMPADDR_OFFSET);
 	writel(0xA1FEED01,
 	       backupram + UX500_CPU1_WAKEMAGIC_OFFSET);

commit 9e634cae725680905098747f6d972525daaf857e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Jun 2 16:10:06 2016 +0200

    ARM: ux500: simplify secondary boot
    
    Inline the wakeup_secondary() static function, and keep the
    backupram remapping around: it is reused when resuming from
    suspend so no point in remapping it every time.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 8f2f615ff958..e0ee139fdebf 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -31,10 +31,14 @@
 #define UX500_CPU1_JUMPADDR_OFFSET 0x1FF4
 #define UX500_CPU1_WAKEMAGIC_OFFSET 0x1FF0
 
-static void wakeup_secondary(void)
+static void __iomem *backupram;
+
+static void __init ux500_smp_prepare_cpus(unsigned int max_cpus)
 {
 	struct device_node *np;
-	static void __iomem *backupram;
+	static void __iomem *scu_base;
+	unsigned int ncores;
+	int i;
 
 	np = of_find_compatible_node(NULL, NULL, "ste,dbx500-backupram");
 	if (!np) {
@@ -48,29 +52,6 @@ static void wakeup_secondary(void)
 		return;
 	}
 
-	/*
-	 * write the address of secondary startup into the backup ram register
-	 * at offset 0x1FF4, then write the magic number 0xA1FEED01 to the
-	 * backup ram register at offset 0x1FF0, which is what boot rom code
-	 * is waiting for. This will wake up the secondary core from WFE.
-	 */
-	writel(virt_to_phys(secondary_startup),
-	       backupram + UX500_CPU1_JUMPADDR_OFFSET);
-	writel(0xA1FEED01,
-	       backupram + UX500_CPU1_WAKEMAGIC_OFFSET);
-
-	/* make sure write buffer is drained */
-	mb();
-	iounmap(backupram);
-}
-
-static void __init ux500_smp_prepare_cpus(unsigned int max_cpus)
-{
-	struct device_node *np;
-	static void __iomem *scu_base;
-	unsigned int ncores;
-	int i;
-
 	np = of_find_compatible_node(NULL, NULL, "arm,cortex-a9-scu");
 	if (!np) {
 		pr_err("No SCU base address\n");
@@ -92,7 +73,19 @@ static void __init ux500_smp_prepare_cpus(unsigned int max_cpus)
 
 static int ux500_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
-	wakeup_secondary();
+	/*
+	 * write the address of secondary startup into the backup ram register
+	 * at offset 0x1FF4, then write the magic number 0xA1FEED01 to the
+	 * backup ram register at offset 0x1FF0, which is what boot rom code
+	 * is waiting for. This will wake up the secondary core from WFE.
+	 */
+	writel(virt_to_phys(secondary_startup),
+	       backupram + UX500_CPU1_JUMPADDR_OFFSET);
+	writel(0xA1FEED01,
+	       backupram + UX500_CPU1_WAKEMAGIC_OFFSET);
+
+	/* make sure write buffer is drained */
+	mb();
 	arch_send_wakeup_ipi_mask(cpumask_of(cpu));
 	return 0;
 }

commit cd1dc431d02afda521bed53b7c87a678a3ac246f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jun 20 23:01:26 2016 +0200

    ARM: ux500: consolidate soc_device code in id.c
    
    Nothing else uses the global dbx500_asic_id structure, so
    we can merge the two small files that reference it into one.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 88b8ab4f300c..8f2f615ff958 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -26,7 +26,6 @@
 #include "setup.h"
 
 #include "db8500-regs.h"
-#include "id.h"
 
 /* Magic triggers in backup RAM */
 #define UX500_CPU1_JUMPADDR_OFFSET 0x1FF4

commit 75305275a721d33ae9abfaeed2817cec8b2fee9a
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 15 10:39:53 2015 +0900

    ARM: use const and __initconst for smp_operations
    
    These smp_operations structures are not over-written, so add "const"
    qualifier and replace __initdata with __initconst.
    
    Also, add "static" where it is possible.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Moritz Fischer <moritz.fischer@ettus.com>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org> # qcom part
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: Wei Xu <xuwei5@hisilicon.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Acked-by: Matthias Brugger <matthias.bgg@gmail.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 70766b963758..88b8ab4f300c 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -98,7 +98,7 @@ static int ux500_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	return 0;
 }
 
-struct smp_operations ux500_smp_ops __initdata = {
+static const struct smp_operations ux500_smp_ops __initconst = {
 	.smp_prepare_cpus	= ux500_smp_prepare_cpus,
 	.smp_boot_secondary	= ux500_boot_secondary,
 #ifdef CONFIG_HOTPLUG_CPU

commit c00def71efd919e8ae835a25f4f4c80a4b2d36d3
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Aug 3 09:26:52 2015 +0200

    ARM: ux500: simplify secondary CPU boot
    
    This removes a lot of ancient cruft from the Ux500 SMP boot.
    Instead of the pen grab/release, just point the ROM to
    secondary_boot() and start the second CPU there, then send
    the IPI.
    
    Use our own SMP enable method. This enables us to remove the
    last static mapping and get both CPUs booting properly.
    
    Tested this and it just works.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 62b1de922bd8..70766b963758 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -28,135 +28,81 @@
 #include "db8500-regs.h"
 #include "id.h"
 
-static void __iomem *scu_base;
-static void __iomem *backupram;
-
-/* This is called from headsmp.S to wakeup the secondary core */
-extern void u8500_secondary_startup(void);
-
-/*
- * Write pen_release in a way that is guaranteed to be visible to all
- * observers, irrespective of whether they're taking part in coherency
- * or not.  This is necessary for the hotplug code to work reliably.
- */
-static void write_pen_release(int val)
-{
-	pen_release = val;
-	smp_wmb();
-	sync_cache_w(&pen_release);
-}
-
-static DEFINE_SPINLOCK(boot_lock);
-
-static void ux500_secondary_init(unsigned int cpu)
-{
-	/*
-	 * let the primary processor know we're out of the
-	 * pen, then head off into the C entry point
-	 */
-	write_pen_release(-1);
-
-	/*
-	 * Synchronise with the boot thread.
-	 */
-	spin_lock(&boot_lock);
-	spin_unlock(&boot_lock);
-}
+/* Magic triggers in backup RAM */
+#define UX500_CPU1_JUMPADDR_OFFSET 0x1FF4
+#define UX500_CPU1_WAKEMAGIC_OFFSET 0x1FF0
 
-static int ux500_boot_secondary(unsigned int cpu, struct task_struct *idle)
+static void wakeup_secondary(void)
 {
-	unsigned long timeout;
-
-	/*
-	 * set synchronisation state between this boot processor
-	 * and the secondary one
-	 */
-	spin_lock(&boot_lock);
-
-	/*
-	 * The secondary processor is waiting to be released from
-	 * the holding pen - release it, then wait for it to flag
-	 * that it has been released by resetting pen_release.
-	 */
-	write_pen_release(cpu_logical_map(cpu));
-
-	arch_send_wakeup_ipi_mask(cpumask_of(cpu));
+	struct device_node *np;
+	static void __iomem *backupram;
 
-	timeout = jiffies + (1 * HZ);
-	while (time_before(jiffies, timeout)) {
-		if (pen_release == -1)
-			break;
+	np = of_find_compatible_node(NULL, NULL, "ste,dbx500-backupram");
+	if (!np) {
+		pr_err("No backupram base address\n");
+		return;
+	}
+	backupram = of_iomap(np, 0);
+	of_node_put(np);
+	if (!backupram) {
+		pr_err("No backupram remap\n");
+		return;
 	}
 
-	/*
-	 * now the secondary core is starting up let it run its
-	 * calibrations, then wait for it to finish
-	 */
-	spin_unlock(&boot_lock);
-
-	return pen_release != -1 ? -ENOSYS : 0;
-}
-
-static void __init wakeup_secondary(void)
-{
 	/*
 	 * write the address of secondary startup into the backup ram register
 	 * at offset 0x1FF4, then write the magic number 0xA1FEED01 to the
 	 * backup ram register at offset 0x1FF0, which is what boot rom code
-	 * is waiting for. This would wake up the secondary core from WFE
+	 * is waiting for. This will wake up the secondary core from WFE.
 	 */
-#define UX500_CPU1_JUMPADDR_OFFSET 0x1FF4
-	__raw_writel(virt_to_phys(u8500_secondary_startup),
-		     backupram + UX500_CPU1_JUMPADDR_OFFSET);
-
-#define UX500_CPU1_WAKEMAGIC_OFFSET 0x1FF0
-	__raw_writel(0xA1FEED01,
-		     backupram + UX500_CPU1_WAKEMAGIC_OFFSET);
+	writel(virt_to_phys(secondary_startup),
+	       backupram + UX500_CPU1_JUMPADDR_OFFSET);
+	writel(0xA1FEED01,
+	       backupram + UX500_CPU1_WAKEMAGIC_OFFSET);
 
 	/* make sure write buffer is drained */
 	mb();
+	iounmap(backupram);
 }
 
-/*
- * Initialise the CPU possible map early - this describes the CPUs
- * which may be present or become present in the system.
- */
-static void __init ux500_smp_init_cpus(void)
+static void __init ux500_smp_prepare_cpus(unsigned int max_cpus)
 {
-	unsigned int i, ncores;
 	struct device_node *np;
+	static void __iomem *scu_base;
+	unsigned int ncores;
+	int i;
 
 	np = of_find_compatible_node(NULL, NULL, "arm,cortex-a9-scu");
+	if (!np) {
+		pr_err("No SCU base address\n");
+		return;
+	}
 	scu_base = of_iomap(np, 0);
 	of_node_put(np);
-	if (!scu_base)
+	if (!scu_base) {
+		pr_err("No SCU remap\n");
 		return;
-	backupram = ioremap(U8500_BACKUPRAM0_BASE, SZ_8K);
-	ncores = scu_get_core_count(scu_base);
-
-	/* sanity check */
-	if (ncores > nr_cpu_ids) {
-		pr_warn("SMP: %u cores greater than maximum (%u), clipping\n",
-			ncores, nr_cpu_ids);
-		ncores = nr_cpu_ids;
 	}
 
+	scu_enable(scu_base);
+	ncores = scu_get_core_count(scu_base);
 	for (i = 0; i < ncores; i++)
 		set_cpu_possible(i, true);
+	iounmap(scu_base);
 }
 
-static void __init ux500_smp_prepare_cpus(unsigned int max_cpus)
+static int ux500_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
-	scu_enable(scu_base);
 	wakeup_secondary();
+	arch_send_wakeup_ipi_mask(cpumask_of(cpu));
+	return 0;
 }
 
 struct smp_operations ux500_smp_ops __initdata = {
-	.smp_init_cpus		= ux500_smp_init_cpus,
 	.smp_prepare_cpus	= ux500_smp_prepare_cpus,
-	.smp_secondary_init	= ux500_secondary_init,
 	.smp_boot_secondary	= ux500_boot_secondary,
 #ifdef CONFIG_HOTPLUG_CPU
 	.cpu_die		= ux500_cpu_die,
 #endif
 };
+CPU_METHOD_OF_DECLARE(ux500_smp, "ste,dbx500-smp", &ux500_smp_ops);

commit 58202033faca18198af21dabb7e75481d4a2cd8a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu May 14 09:46:40 2015 +0200

    ARM: ux500: get SCU base from device tree
    
    The SMP startup/shutdown code relied on a static SCU base
    address, let's get this from the device tree instead.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 1e13d0a8ad77..62b1de922bd8 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -16,6 +16,8 @@
 #include <linux/device.h>
 #include <linux/smp.h>
 #include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
 
 #include <asm/cacheflush.h>
 #include <asm/smp_plat.h>
@@ -122,8 +124,13 @@ static void __init wakeup_secondary(void)
 static void __init ux500_smp_init_cpus(void)
 {
 	unsigned int i, ncores;
+	struct device_node *np;
 
-	scu_base = ioremap(U8500_SCU_BASE, 0x100);
+	np = of_find_compatible_node(NULL, NULL, "arm,cortex-a9-scu");
+	scu_base = of_iomap(np, 0);
+	of_node_put(np);
+	if (!scu_base)
+		return;
 	backupram = ioremap(U8500_BACKUPRAM0_BASE, SZ_8K);
 	ncores = scu_get_core_count(scu_base);
 

commit 2d6dd1711346d1708eacdbb1b5e8a5a573562fd1
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu May 14 09:20:23 2015 +0200

    ARM: ux500: remove static maps from platsmp
    
    This removes the reliance on static maps for SCU and backupram
    for the SMP startup of the Ux500 SoC.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index a44967f3168c..1e13d0a8ad77 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -26,6 +26,9 @@
 #include "db8500-regs.h"
 #include "id.h"
 
+static void __iomem *scu_base;
+static void __iomem *backupram;
+
 /* This is called from headsmp.S to wakeup the secondary core */
 extern void u8500_secondary_startup(void);
 
@@ -41,16 +44,6 @@ static void write_pen_release(int val)
 	sync_cache_w(&pen_release);
 }
 
-static void __iomem *scu_base_addr(void)
-{
-	if (cpu_is_u8500_family() || cpu_is_ux540_family())
-		return __io_address(U8500_SCU_BASE);
-	else
-		ux500_unknown_soc();
-
-	return NULL;
-}
-
 static DEFINE_SPINLOCK(boot_lock);
 
 static void ux500_secondary_init(unsigned int cpu)
@@ -104,13 +97,6 @@ static int ux500_boot_secondary(unsigned int cpu, struct task_struct *idle)
 
 static void __init wakeup_secondary(void)
 {
-	void __iomem *backupram;
-
-	if (cpu_is_u8500_family() || cpu_is_ux540_family())
-		backupram = __io_address(U8500_BACKUPRAM0_BASE);
-	else
-		ux500_unknown_soc();
-
 	/*
 	 * write the address of secondary startup into the backup ram register
 	 * at offset 0x1FF4, then write the magic number 0xA1FEED01 to the
@@ -135,10 +121,11 @@ static void __init wakeup_secondary(void)
  */
 static void __init ux500_smp_init_cpus(void)
 {
-	void __iomem *scu_base = scu_base_addr();
 	unsigned int i, ncores;
 
-	ncores = scu_base ? scu_get_core_count(scu_base) : 1;
+	scu_base = ioremap(U8500_SCU_BASE, 0x100);
+	backupram = ioremap(U8500_BACKUPRAM0_BASE, SZ_8K);
+	ncores = scu_get_core_count(scu_base);
 
 	/* sanity check */
 	if (ncores > nr_cpu_ids) {
@@ -153,8 +140,7 @@ static void __init ux500_smp_init_cpus(void)
 
 static void __init ux500_smp_prepare_cpus(unsigned int max_cpus)
 {
-
-	scu_enable(scu_base_addr());
+	scu_enable(scu_base);
 	wakeup_secondary();
 }
 

commit f45913fde00f13f502730809d128e607da2a57c8
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Thu Dec 5 14:26:16 2013 -0500

    ARM: clean up cache handling in platform code
    
    We have a handy macro to replace open coded __cpuc_flush_dcache_area(()
    and outer_clean_range() sequences. Let's use it. No functional change.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 1f296e796a4f..a44967f3168c 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -38,8 +38,7 @@ static void write_pen_release(int val)
 {
 	pen_release = val;
 	smp_wmb();
-	__cpuc_flush_dcache_area((void *)&pen_release, sizeof(pen_release));
-	outer_clean_range(__pa(&pen_release), __pa(&pen_release + 1));
+	sync_cache_w(&pen_release);
 }
 
 static void __iomem *scu_base_addr(void)

commit 8bd26e3a7e49af2697449bbcb7187a39dc85d672
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jun 17 15:43:14 2013 -0400

    arm: delete __cpuinit/__CPUINIT usage from all ARM users
    
    The __cpuinit type of throwaway sections might have made sense
    some time ago when RAM was more constrained, but now the savings
    do not offset the cost and complications.  For example, the fix in
    commit 5e427ec2d0 ("x86: Fix bit corruption at CPU resume time")
    is a good example of the nasty type of bugs that can be created
    with improper use of the various __init prefixes.
    
    After a discussion on LKML[1] it was decided that cpuinit should go
    the way of devinit and be phased out.  Once all the users are gone,
    we can then finally remove the macros themselves from linux/init.h.
    
    Note that some harmless section mismatch warnings may result, since
    notify_cpu_starting() and cpu_up() are arch independent (kernel/cpu.c)
    and are flagged as __cpuinit  -- so if we remove the __cpuinit from
    the arch specific callers, we will also get section mismatch warnings.
    As an intermediate step, we intend to turn the linux/init.h cpuinit
    related content into no-ops as early as possible, since that will get
    rid of these warnings.  In any case, they are temporary and harmless.
    
    This removes all the ARM uses of the __cpuinit macros from C code,
    and all __CPUINIT from assembly code.  It also had two ".previous"
    section statements that were paired off against __CPUINIT
    (aka .section ".cpuinit.text") that also get removed here.
    
    [1] https://lkml.org/lkml/2013/5/20/589
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 14d90469392f..1f296e796a4f 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -54,7 +54,7 @@ static void __iomem *scu_base_addr(void)
 
 static DEFINE_SPINLOCK(boot_lock);
 
-static void __cpuinit ux500_secondary_init(unsigned int cpu)
+static void ux500_secondary_init(unsigned int cpu)
 {
 	/*
 	 * let the primary processor know we're out of the
@@ -69,7 +69,7 @@ static void __cpuinit ux500_secondary_init(unsigned int cpu)
 	spin_unlock(&boot_lock);
 }
 
-static int __cpuinit ux500_boot_secondary(unsigned int cpu, struct task_struct *idle)
+static int ux500_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	unsigned long timeout;
 

commit 99c6bcf46d2233d33e441834e958ed0bc22b190a
Merge: 97b1007a2924 2fdfe1c26fb9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 2 09:38:16 2013 -0700

    Merge tag 'multiplatform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC multiplatform updates from Olof Johansson:
     "More multiplatform enablement for ARM platforms.  The ones converted
      in this branch are:
    
       - bcm2835
       - cns3xxx
       - sirf
       - nomadik
       - msx
       - spear
       - tegra
       - ux500
    
      We're getting close to having most of them converted!
    
      One of the larger platforms remaining is Samsung Exynos, and there are
      a bunch of supporting patches in this merge window for it.  There was
      a patch in this branch to a early version of multiplatform conversion,
      but it ended up being reverted due to need of more bake time.  The
      revert commit is part of the branch since it would have required
      rebasing multiple dependent branches and they were stable by then"
    
    * tag 'multiplatform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (70 commits)
      mmc: sdhci-s3c: Fix operation on non-single image Samsung platforms
      clocksource: nomadik-mtu: fix up clocksource/timer
      Revert "ARM: exynos: enable multiplatform support"
      ARM: SPEAr13xx: Fix typo "ARCH_HAVE_CPUFREQ"
      ARM: exynos: enable multiplatform support
      rtc: s3c: make header file local
      mtd: onenand/samsung: make regs-onenand.h file local
      thermal/exynos: remove unnecessary header inclusions
      mmc: sdhci-s3c: remove platform dependencies
      ARM: samsung: move mfc device definition to s5p-dev-mfc.c
      ARM: exynos: move debug-macro.S to include/debug/
      ARM: exynos: prepare for sparse IRQ
      ARM: exynos: introduce EXYNOS_ATAGS symbol
      ARM: tegra: build assembly files with -march=armv7-a
      ARM: Push selects for TWD/SCU into machine entries
      ARM: ux500: build hotplug.o for ARMv7-a
      ARM: ux500: move to multiplatform
      ARM: ux500: make remaining headers local
      ARM: ux500: make irqs.h local to platform
      ARM: ux500: get rid of <mach/[hardware|db8500-regs].h>
      ...

commit e657bcf6db84864079b31909e911a69c813aa0c0
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Mar 21 22:51:12 2013 +0100

    ARM: ux500: make remaining headers local
    
    mach/setup.h and mach/devices.h are only needed from inside of mach-ux500
    now, so we can simply move them out of the include/mach directory.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 8a9c070ec206..12ad8ad850aa 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -22,7 +22,7 @@
 #include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
 
-#include <mach/setup.h>
+#include "setup.h"
 
 #include "db8500-regs.h"
 #include "id.h"

commit 174e7796624d2749359c3fdc673c1232b060d7f6
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Mar 19 15:41:55 2013 +0100

    ARM: ux500: get rid of <mach/[hardware|db8500-regs].h>
    
    This removes <mach/hardware.h> and <mach/db8500-regs.h>
    from the Ux500, merging them into the local include
    "db8500-regs.h" in mach-ux500. There is some impact
    outside the ux500 machine, but most of it is dealt with
    in earlier patches.
    
    Contains portions of a clean-up patch from Arnd Bergmann.
    
    Cc: Samuel Ortiz <sameo@linux.intel.com>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Mike Turquette <mturquette@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 18f7af339dc9..8a9c070ec206 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -22,9 +22,9 @@
 #include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
 
-#include <mach/hardware.h>
 #include <mach/setup.h>
 
+#include "db8500-regs.h"
 #include "id.h"
 
 /* This is called from headsmp.S to wakeup the secondary core */

commit c0114709ed85a5693eb74acdfa03d94f7f12e5b8
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Mon Jan 14 18:05:37 2013 +0000

    irqchip: gic: Perform the gic_secondary_init() call via CPU notifier
    
    All the calls to gic_secondary_init() pass 0 as the first argument.
    Since this function is called on each CPU when starting, it can be done
    in a platform-independent way via a CPU notifier registered by the GIC
    code.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Tested-by: Simon Horman <horms+renesas@verge.net.au>
    Acked-by: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Tested-by: Dinh Nguyen <dinguyen@altera.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Tested-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: David Brown <davidb@codeaurora.org>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Shiraz Hashim <shiraz.hashim@st.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Barry Song <baohua.song@csr.com>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 18f7af339dc9..152b1309b9af 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -16,7 +16,6 @@
 #include <linux/device.h>
 #include <linux/smp.h>
 #include <linux/io.h>
-#include <linux/irqchip/arm-gic.h>
 
 #include <asm/cacheflush.h>
 #include <asm/smp_plat.h>
@@ -57,13 +56,6 @@ static DEFINE_SPINLOCK(boot_lock);
 
 static void __cpuinit ux500_secondary_init(unsigned int cpu)
 {
-	/*
-	 * if any interrupts are already enabled for the primary
-	 * core (e.g. timer irq), then they will not have been enabled
-	 * for us: do so
-	 */
-	gic_secondary_init(0);
-
 	/*
 	 * let the primary processor know we're out of the
 	 * pen, then head off into the C entry point

commit 0b79f2772a0c49266e611a36d55a2d0e2a241929
Merge: 1576a31c61d4 7a4f26097d38
Author: Olof Johansson <olof@lixom.net>
Date:   Tue Jan 29 16:05:48 2013 -0800

    Merge tag 'ux500-no-idh' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-stericsson into next/cleanup
    
    From Linus Walleij:
    Removal of the <mach/id.h> include from ux500
    - First an ACKed MFD patch deleting the only consumer
      of these cpu_is* functions outside of mach-ux500
    - Introduce a new local cpu_is_u8580() in this patch
      set to avoid clashing with other patch sets.
    - Finally de-globalize <mach/id.h>.
    
    * tag 'ux500-no-idh' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-stericsson:
      ARM: ux500: de-globalize <mach/id.h>
      ARM: ux500: Introduce cpu_is_u8580()
      mfd: prcmu: delete pin control helpers
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 7a4f26097d389c16c9956bc03b81532698d97d64
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Sep 19 19:31:19 2012 +0200

    ARM: ux500: de-globalize <mach/id.h>
    
    This removes the file <mach/id.h> from the global kernel include
    scope, making it a pure mach-ux500 detail. All ASIC specifics
    needed by drivers shall henceforth be passed from either platform
    data or the device tree.
    
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 3db7782f3afb..1a92e071bd61 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -21,9 +21,12 @@
 #include <asm/hardware/gic.h>
 #include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
+
 #include <mach/hardware.h>
 #include <mach/setup.h>
 
+#include "id.h"
+
 /* This is called from headsmp.S to wakeup the secondary core */
 extern void u8500_secondary_startup(void);
 

commit 520f7bd73354f003a9a59937b28e4903d985c420
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Thu Dec 27 13:10:24 2012 -0600

    irqchip: Move ARM gic.h to include/linux/irqchip/arm-gic.h
    
    Now that we have GIC moved to drivers/irqchip and all GIC DT init for
    platforms using irqchip_init, move gic.h and update the remaining
    includes.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Anton Vorontsov <avorontsov@mvista.com>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: David Brown <davidb@codeaurora.org>
    Cc: Daniel Walker <dwalker@fifo99.com>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Viresh Kumar <viresh.linux@gmail.com>
    Cc: Shiraz Hashim <shiraz.hashim@st.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index fa07d4de6d85..b8adac93421f 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -16,9 +16,9 @@
 #include <linux/device.h>
 #include <linux/smp.h>
 #include <linux/io.h>
+#include <linux/irqchip/arm-gic.h>
 
 #include <asm/cacheflush.h>
-#include <asm/hardware/gic.h>
 #include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
 #include <mach/hardware.h>

commit b1cffebf1029c87e1f1984d48463ee21093a6bc7
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Mon Nov 26 15:05:48 2012 -0600

    ARM: GIC: remove direct use of gic_raise_softirq
    
    In preparation of moving gic code to drivers/irqchip, remove the direct
    platform dependencies on gic_raise_softirq. Move the setup of
    smp_cross_call into the gic code and use arch_send_wakeup_ipi_mask
    function to trigger wake-up IPIs.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: David Brown <davidb@codeaurora.org>
    Cc: Daniel Walker <dwalker@fifo99.com>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Shiraz Hashim <shiraz.hashim@st.com>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 79531f1dffbc..fa07d4de6d85 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -91,7 +91,7 @@ static int __cpuinit ux500_boot_secondary(unsigned int cpu, struct task_struct *
 	 */
 	write_pen_release(cpu_logical_map(cpu));
 
-	gic_raise_softirq(cpumask_of(cpu), 0);
+	arch_send_wakeup_ipi_mask(cpumask_of(cpu));
 
 	timeout = jiffies + (1 * HZ);
 	while (time_before(jiffies, timeout)) {
@@ -155,8 +155,6 @@ static void __init ux500_smp_init_cpus(void)
 
 	for (i = 0; i < ncores; i++)
 		set_cpu_possible(i, true);
-
-	set_smp_cross_call(gic_raise_softirq);
 }
 
 static void __init ux500_smp_prepare_cpus(unsigned int max_cpus)

commit 902ef5d77aeaff43bce8d3ce55c442a12eb71819
Author: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
Date:   Fri Nov 2 18:14:34 2012 +0530

    ARM: mach-ux500: use SGI0 to wake up the other core
    
    The commit 7d28e3eaa1a8e951251b942e7220f97114bd73b9
    ("ARM: ux500: wake secondary cpu via resched") makes use
    of schedule IPI to wake up the secondary core which seems
    incorrect. Rather use SGI0.
    
    Signed-off-by: srinidhi kasagar <srinidhi.kasagar@stericsson.com>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 3db7782f3afb..79531f1dffbc 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -91,7 +91,7 @@ static int __cpuinit ux500_boot_secondary(unsigned int cpu, struct task_struct *
 	 */
 	write_pen_release(cpu_logical_map(cpu));
 
-	smp_send_reschedule(cpu);
+	gic_raise_softirq(cpumask_of(cpu), 0);
 
 	timeout = jiffies + (1 * HZ);
 	while (time_before(jiffies, timeout)) {

commit 25468fe89f88c4ceeef94526e94ae0db176f6999
Merge: a283580c52d3 28e8e29c616f
Author: Olof Johansson <olof@lixom.net>
Date:   Sat Sep 22 00:06:21 2012 -0700

    Merge branch 'multiplatform/smp_ops' into next/multiplatform
    
    * multiplatform/smp_ops:
      ARM: consolidate pen_release instead of having per platform definitions
      ARM: smp: Make SMP operations mandatory
      ARM: SoC: convert spear13xx to SMP operations
      ARM: SoC: convert imx6q to SMP operations
      ARM: SoC: convert highbank to SMP operations
      ARM: SoC: convert shmobile SMP to SMP operations
      ARM: SoC: convert ux500 to SMP operations
      ARM: SoC: convert MSM to SMP operations
      ARM: SoC: convert Exynos4 to SMP operations
      ARM: SoC: convert Tegra to SMP operations
      ARM: SoC: convert OMAP4 to SMP operations
      ARM: SoC: convert VExpress/RealView to SMP operations
      ARM: SoC: add per-platform SMP operations
    
    Conflicts due to file moves or removals in:
            arch/arm/mach-msm/board-msm8960.c
            arch/arm/mach-msm/board-msm8x60.c
            arch/arm/mach-tegra/board-harmony.c
            arch/arm/mach-tegra/board-trimslice.c
    
    Conflicts due to board file cleanup:
            arch/arm/mach-tegra/board-paz00.c
    
    Conflicts due to cpu hotplug addition:
            arch/arm/mach-tegra/hotplug.c
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 28e8e29c616f947348cc66bea684d0035c76021a
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jun 12 11:16:27 2012 +0100

    ARM: consolidate pen_release instead of having per platform definitions
    
    Almost each SMP platform defines pen_release to manage booting secondary
    CPUs. This of course clashes with the single zImage effort.
    
    Add the pen_release definition to the ARM SMP code, and remove all others.
    This should only be used by platforms which lack any kind of CPU power
    management...
    
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index b6f4e0e787ec..d60873ee38bf 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -27,12 +27,6 @@
 /* This is called from headsmp.S to wakeup the secondary core */
 extern void u8500_secondary_startup(void);
 
-/*
- * control for which core is the next to come out of the secondary
- * boot "holding pen"
- */
-volatile int pen_release = -1;
-
 /*
  * Write pen_release in a way that is guaranteed to be visible to all
  * observers, irrespective of whether they're taking part in coherency

commit 5ac21a943e4052ef6743b09b6a06fbb683a3519d
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Thu Sep 8 13:15:22 2011 +0100

    ARM: SoC: convert ux500 to SMP operations
    
    Convert ux500 platforms to use struct smp_operations to provide
    their SMP and CPU hotplug operations.
    
    Cc: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: srinidhi kasagar <srinidhi.kasagar@stericsson.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index da1d5ad5bd45..b6f4e0e787ec 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -58,7 +58,7 @@ static void __iomem *scu_base_addr(void)
 
 static DEFINE_SPINLOCK(boot_lock);
 
-void __cpuinit platform_secondary_init(unsigned int cpu)
+static void __cpuinit ux500_secondary_init(unsigned int cpu)
 {
 	/*
 	 * if any interrupts are already enabled for the primary
@@ -80,7 +80,7 @@ void __cpuinit platform_secondary_init(unsigned int cpu)
 	spin_unlock(&boot_lock);
 }
 
-int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
+static int __cpuinit ux500_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	unsigned long timeout;
 
@@ -145,7 +145,7 @@ static void __init wakeup_secondary(void)
  * Initialise the CPU possible map early - this describes the CPUs
  * which may be present or become present in the system.
  */
-void __init smp_init_cpus(void)
+static void __init ux500_smp_init_cpus(void)
 {
 	void __iomem *scu_base = scu_base_addr();
 	unsigned int i, ncores;
@@ -165,9 +165,19 @@ void __init smp_init_cpus(void)
 	set_smp_cross_call(gic_raise_softirq);
 }
 
-void __init platform_smp_prepare_cpus(unsigned int max_cpus)
+static void __init ux500_smp_prepare_cpus(unsigned int max_cpus)
 {
 
 	scu_enable(scu_base_addr());
 	wakeup_secondary();
 }
+
+struct smp_operations ux500_smp_ops __initdata = {
+	.smp_init_cpus		= ux500_smp_init_cpus,
+	.smp_prepare_cpus	= ux500_smp_prepare_cpus,
+	.smp_secondary_init	= ux500_secondary_init,
+	.smp_boot_secondary	= ux500_boot_secondary,
+#ifdef CONFIG_HOTPLUG_CPU
+	.cpu_die		= ux500_cpu_die,
+#endif
+};

commit 79964bcd792fd9625affb4d7092ee09697f0409a
Author: Loic PALLARDY <loic.pallardy@st.com>
Date:   Mon Sep 3 15:10:23 2012 +0200

    ARM: ux500: Correct Ux500 family names usage
    
    Update users with cpu_is_ux540_family() to keep x540
    family functional.
    
    Signed-off-by: Loic Pallardy <loic.pallardy@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index cb35897c1ea3..a5dda68444db 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -118,7 +118,7 @@ static void __init wakeup_secondary(void)
 {
 	void __iomem *backupram;
 
-	if (cpu_is_u8500_family())
+	if (cpu_is_u8500_family() || cpu_is_ux540_family())
 		backupram = __io_address(U8500_BACKUPRAM0_BASE);
 	else
 		ux500_unknown_soc();

commit e1bbb55d11622012197a654af874f9f485ddbc47
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Aug 9 17:10:36 2012 +0200

    ARM: ux500: reform Ux500 family names
    
    Counting the U9540 and the new U8540 as a U8500 family member
    does not work. Instead, split the function in two:
    
    cpu_is_u8500_family() covering U8500 and U8520
    cpu_is_ux540_family() covering U9540 and U8540
    
    This works much better in practice. Update users to keep the
    same behaviour.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index da1d5ad5bd45..cb35897c1ea3 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -48,7 +48,7 @@ static void write_pen_release(int val)
 
 static void __iomem *scu_base_addr(void)
 {
-	if (cpu_is_u8500_family())
+	if (cpu_is_u8500_family() || cpu_is_ux540_family())
 		return __io_address(U8500_SCU_BASE);
 	else
 		ux500_unknown_soc();

commit 815acebff7ac578970986ca3f0ff406c92a0e243
Merge: 417f381c4568 72fb92200d6c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon May 14 16:29:32 2012 +0200

    Merge branch 'ux500/delete-u5500' into next/soc
    
    Conflicts:
            arch/arm/mach-ux500/cache-l2x0.c
            arch/arm/mach-ux500/clock.c
            arch/arm/mach-ux500/cpu.c
            arch/arm/mach-ux500/mbox-db5500.c
            arch/arm/mach-ux500/platsmp.c
            arch/arm/mach-ux500/timer.c
    
    Resolve lots of identical conflicts between the removal of
    u5500 and the addition of u8540.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 29746f48d1b2e903b23daf8cc951fcb47ff0110e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Apr 13 13:16:31 2012 +0200

    ARM: ux500: delete U5500 support
    
    This platform has been obsoleted and was only available inside of
    ST-Ericsson, no users of this code are left in the world. This
    deletes the core U5500 support entirely in the same manner as the
    obsoleted U8500 silicon was previously deleted.
    
    The cpu_is_u5500() macros that can read out the CPU ID is left
    until the next kernel cycle, this makes it possible to merge
    deletion of dependent drivers without breakage.
    
    This also has the upside of removing the mailbox driver which was
    our only driver that was outside the drivers/* hiearchy, now the
    machine directory only handles machines and nothing else.
    
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Rabin Vincent <rabin.vincent@stericsson.com>
    Cc: Jonas Aberg <jonas.aberg@stericsson.com>
    Cc: Per Forlin <per.forlin@stericsson.com>
    Cc: Ulf Hansson <ulf.hansson@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index eff5842f6232..e8cd51aa61e4 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -48,9 +48,7 @@ static void write_pen_release(int val)
 
 static void __iomem *scu_base_addr(void)
 {
-	if (cpu_is_u5500())
-		return __io_address(U5500_SCU_BASE);
-	else if (cpu_is_u8500())
+	if (cpu_is_u8500())
 		return __io_address(U8500_SCU_BASE);
 	else
 		ux500_unknown_soc();
@@ -120,9 +118,7 @@ static void __init wakeup_secondary(void)
 {
 	void __iomem *backupram;
 
-	if (cpu_is_u5500())
-		backupram = __io_address(U5500_BACKUPRAM0_BASE);
-	else if (cpu_is_u8500())
+	if (cpu_is_u8500())
 		backupram = __io_address(U8500_BACKUPRAM0_BASE);
 	else
 		ux500_unknown_soc();

commit bc71c0961c61d6082472203bfae9596899c9c896
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Jan 23 11:54:44 2012 +0100

    ARM: ux500: core U9540 support
    
    This adds support for the U9540 variant of the U8500 series. This
    is an application processor without internal modem. This is the
    most basic part with ASIC ID, CPU-related fixes, IRQ list, register
    ranges, timer, UART, and L2 cache setup. This is based on a patch
    by Michel Jaouen which was rewritten to fit with the latest 3.3
    kernel.
    
    ChangeLog v1->v2: deleted the irqs-db9540.h file since we expect to
      migrate to using Device Tree for getting the IRQs to devices.
    ChangeLog v2->v3: introduced a fixed virtual offset for the ROM
      as suggested by Arnd Bergmann.
    
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Sebastien Pasdeloup <sebastien.pasdeloup-nonst@stericsson.com>
    Signed-off-by: Michel Jaouen <michel.jaouen@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index eff5842f6232..f499a0703928 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -50,7 +50,7 @@ static void __iomem *scu_base_addr(void)
 {
 	if (cpu_is_u5500())
 		return __io_address(U5500_SCU_BASE);
-	else if (cpu_is_u8500())
+	else if (cpu_is_u8500_family())
 		return __io_address(U8500_SCU_BASE);
 	else
 		ux500_unknown_soc();
@@ -122,7 +122,7 @@ static void __init wakeup_secondary(void)
 
 	if (cpu_is_u5500())
 		backupram = __io_address(U5500_BACKUPRAM0_BASE);
-	else if (cpu_is_u8500())
+	else if (cpu_is_u8500_family())
 		backupram = __io_address(U8500_BACKUPRAM0_BASE);
 	else
 		ux500_unknown_soc();

commit 7d28e3eaa1a8e951251b942e7220f97114bd73b9
Author: Jonas Aaberg <jonas.aberg@stericsson.com>
Date:   Thu Dec 22 09:22:56 2011 +0100

    ARM: ux500: wake secondary cpu via resched
    
    Wake secondary cpu via resched instead of
    "Unknown IPI message 0x1"
    
    Signed-off-by: Jonas Aaberg <jonas.aberg@stericsson.com>
    Reviewed-by: Rickard Andersson <rickard.andersson@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index d2058ef8345f..eff5842f6232 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -99,7 +99,7 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	 */
 	write_pen_release(cpu_logical_map(cpu));
 
-	gic_raise_softirq(cpumask_of(cpu), 1);
+	smp_send_reschedule(cpu);
 
 	timeout = jiffies + (1 * HZ);
 	while (time_before(jiffies, timeout)) {

commit eb50439b92b6298bf209a982f295ba9c0f7cb30b
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Jan 20 12:01:12 2012 +0100

    ARM: 7293/1: logical_cpu_map: decouple CPU mapping from SMP
    
    It turns out that the logical CPU mapping is useful even when !CONFIG_SMP
    for manipulation of devices like interrupt and power controllers when
    running a UP kernel on a CPU other than 0. This can happen when kexecing
    a UP image from an SMP kernel.
    
    In the future, multi-cluster systems running AMP configurations will
    require something similar for mapping cluster IDs, so it makes sense to
    decouple this logic in preparation for this support.
    
    Acked-by: Yang Bai <hamo.by@gmail.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Reported-by: Joerg Roedel <joerg.roedel@amd.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index a19e398dade3..d2058ef8345f 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -19,6 +19,7 @@
 
 #include <asm/cacheflush.h>
 #include <asm/hardware/gic.h>
+#include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
 #include <mach/hardware.h>
 #include <mach/setup.h>

commit 6585dea1f99cc2265582ff2e4cc1727062136e92
Merge: 16ee792e45cf 97c24c1aa403
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 1 20:34:22 2011 -0700

    Merge branch 'next/cross-platform' of git://git.linaro.org/people/arnd/arm-soc
    
    * 'next/cross-platform' of git://git.linaro.org/people/arnd/arm-soc:
      arm/imx: use Kconfig choice for low-level debug UART selection
      ARM: realview: use Kconfig choice for debug UART selection
      ARM: plat-samsung: use Kconfig choice for debug UART selection
      ARM: versatile: convert logical CPU numbers to physical numbers
      ARM: ux500: convert logical CPU numbers to physical numbers
      ARM: shmobile: convert logical CPU numbers to physical numbers
      ARM: msm: convert logical CPU numbers to physical numbers
      ARM: exynos4: convert logical CPU numbers to physical numbers
    
    Fix up trivial conflict (config DEBUG_S3C_UART move/split vs addition of
    ARM_KPROBES_TEST option) in arch/arm/Kconfig.debug

commit a06f916b7a9b57447ceb875eb0a89f1a66b31bca
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Oct 20 22:04:18 2011 +0100

    ARM: smp: fix clipping of number of CPUs
    
    Rather than clipping the number of CPUs using the compile-time NR_CPUS
    constant, use the runtime nr_cpu_ids value instead.  This allows the
    nr_cpus command line option to work as expected.
    
    Cc: <stable@kernel.org>
    Reported-by: Mark Salter <msalter@redhat.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index a33df5f4c27a..eb5199102cfa 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -156,12 +156,10 @@ void __init smp_init_cpus(void)
 	ncores = scu_base ? scu_get_core_count(scu_base) : 1;
 
 	/* sanity check */
-	if (ncores > NR_CPUS) {
-		printk(KERN_WARNING
-		       "U8500: no. of cores (%d) greater than configured "
-		       "maximum of %d - clipping\n",
-		       ncores, NR_CPUS);
-		ncores = NR_CPUS;
+	if (ncores > nr_cpu_ids) {
+		pr_warn("SMP: %u cores greater than maximum (%u), clipping\n",
+			ncores, nr_cpu_ids);
+		ncores = nr_cpu_ids;
 	}
 
 	for (i = 0; i < ncores; i++)

commit 28763487b19eacca70374c1f62b3b8da2bba464f
Author: Will Deacon <will.deacon@arm.com>
Date:   Tue Aug 9 12:21:36 2011 +0100

    ARM: ux500: convert logical CPU numbers to physical numbers
    
    This patch uses the new cpu_logical_map() macro for converting logical
    CPU numbers into physical numbers when dealing with the pen_release
    variable in the SMP boot and CPU hotplug paths.
    
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index a33df5f4c27a..27e5281cd55d 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -96,7 +96,7 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	 * the holding pen - release it, then wait for it to flag
 	 * that it has been released by resetting pen_release.
 	 */
-	write_pen_release(cpu);
+	write_pen_release(cpu_logical_map(cpu));
 
 	gic_raise_softirq(cpumask_of(cpu), 1);
 

commit 7fa22bd5460bb2021729fa5a1012c60b9b3a56e2
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jul 7 01:56:51 2011 +0100

    ARM: 6993/1: platsmp: Allow secondary cpu hotplug with maxcpus=1
    
    If an ARM system has multiple cpus in the same socket and the
    kernel is booted with maxcpus=1, secondary cpus are possible but
    not present due to how platform_smp_prepare_cpus() is called.
    Since most typical ARM processors don't actually support physical
    hotplug, initialize the present map to be equal to the possible
    map in generic ARM SMP code. Also, always call
    platform_smp_prepare_cpus() as long as max_cpus is non-zero (0
    means no SMP) to allow platform code to do any SMP setup.
    
    After applying this patch it's possible to boot an ARM system
    with maxcpus=1 on the command line and then hotplug in secondary
    cpus via sysfs. This is more in line with how x86 does things.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: David Brown <davidb@codeaurora.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 0c527fe2cebb..a33df5f4c27a 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -172,14 +172,6 @@ void __init smp_init_cpus(void)
 
 void __init platform_smp_prepare_cpus(unsigned int max_cpus)
 {
-	int i;
-
-	/*
-	 * Initialise the present map, which describes the set of CPUs
-	 * actually populated at the present time.
-	 */
-	for (i = 0; i < max_cpus; i++)
-		set_cpu_present(i, true);
 
 	scu_enable(scu_base_addr());
 	wakeup_secondary();

commit 4d5336d50a7b4992c90729c27dae027a3426c48c
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri May 6 12:56:27 2011 +0100

    ARM: 6895/1: mach-ux500: fix SMP secondary startup regression
    
    Commit e2a083dc0da9aa6437e14811198379b18cdfa7f8
    "ARM: consolidate SMP cross call implementation" broke the ux500
    compilation since the smp.h header declared a function called
    from headsmp.S. This fixes it up by declaring it locally instead.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 4e338466839e..0c527fe2cebb 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -23,6 +23,9 @@
 #include <mach/hardware.h>
 #include <mach/setup.h>
 
+/* This is called from headsmp.S to wakeup the secondary core */
+extern void u8500_secondary_startup(void);
+
 /*
  * control for which core is the next to come out of the secondary
  * boot "holding pen"

commit 0f7b332f9777819a39a3b325690379a7efef89d1
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Apr 3 13:01:30 2011 +0100

    ARM: consolidate SMP cross call implementation
    
    Rather than having each platform class provide a mach/smp.h header for
    smp_cross_call(), arrange for them to register the function with the
    core ARM SMP code instead.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 4fff4d408417..4e338466839e 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -18,6 +18,7 @@
 #include <linux/io.h>
 
 #include <asm/cacheflush.h>
+#include <asm/hardware/gic.h>
 #include <asm/smp_scu.h>
 #include <mach/hardware.h>
 #include <mach/setup.h>
@@ -94,7 +95,7 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	 */
 	write_pen_release(cpu);
 
-	smp_cross_call(cpumask_of(cpu), 1);
+	gic_raise_softirq(cpumask_of(cpu), 1);
 
 	timeout = jiffies + (1 * HZ);
 	while (time_before(jiffies, timeout)) {
@@ -162,6 +163,8 @@ void __init smp_init_cpus(void)
 
 	for (i = 0; i < ncores; i++)
 		set_cpu_possible(i, true);
+
+	set_smp_cross_call(gic_raise_softirq);
 }
 
 void __init platform_smp_prepare_cpus(unsigned int max_cpus)

commit 92389ca8362c42952c7ebb8a0350ac522dcde0f4
Author: Rabin Vincent <rabin.vincent@stericsson.com>
Date:   Wed Dec 8 11:07:57 2010 +0530

    ux500: remove build-time changing macros
    
    To allow the possiblity of building U8500 and U5500 support in the same
    image.
    
    Signed-off-by: Rabin Vincent <rabin.vincent@stericsson.com>
    [Rebased to latest changes in Russells tree]
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index d77e76cb7edd..4fff4d408417 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -20,6 +20,7 @@
 #include <asm/cacheflush.h>
 #include <asm/smp_scu.h>
 #include <mach/hardware.h>
+#include <mach/setup.h>
 
 /*
  * control for which core is the next to come out of the secondary
@@ -40,6 +41,18 @@ static void write_pen_release(int val)
 	outer_clean_range(__pa(&pen_release), __pa(&pen_release + 1));
 }
 
+static void __iomem *scu_base_addr(void)
+{
+	if (cpu_is_u5500())
+		return __io_address(U5500_SCU_BASE);
+	else if (cpu_is_u8500())
+		return __io_address(U8500_SCU_BASE);
+	else
+		ux500_unknown_soc();
+
+	return NULL;
+}
+
 static DEFINE_SPINLOCK(boot_lock);
 
 void __cpuinit platform_secondary_init(unsigned int cpu)
@@ -100,21 +113,28 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 
 static void __init wakeup_secondary(void)
 {
+	void __iomem *backupram;
+
+	if (cpu_is_u5500())
+		backupram = __io_address(U5500_BACKUPRAM0_BASE);
+	else if (cpu_is_u8500())
+		backupram = __io_address(U8500_BACKUPRAM0_BASE);
+	else
+		ux500_unknown_soc();
+
 	/*
 	 * write the address of secondary startup into the backup ram register
 	 * at offset 0x1FF4, then write the magic number 0xA1FEED01 to the
 	 * backup ram register at offset 0x1FF0, which is what boot rom code
 	 * is waiting for. This would wake up the secondary core from WFE
 	 */
-#define U8500_CPU1_JUMPADDR_OFFSET 0x1FF4
+#define UX500_CPU1_JUMPADDR_OFFSET 0x1FF4
 	__raw_writel(virt_to_phys(u8500_secondary_startup),
-		__io_address(UX500_BACKUPRAM0_BASE) +
-		U8500_CPU1_JUMPADDR_OFFSET);
+		     backupram + UX500_CPU1_JUMPADDR_OFFSET);
 
-#define U8500_CPU1_WAKEMAGIC_OFFSET 0x1FF0
+#define UX500_CPU1_WAKEMAGIC_OFFSET 0x1FF0
 	__raw_writel(0xA1FEED01,
-		__io_address(UX500_BACKUPRAM0_BASE) +
-		U8500_CPU1_WAKEMAGIC_OFFSET);
+		     backupram + UX500_CPU1_WAKEMAGIC_OFFSET);
 
 	/* make sure write buffer is drained */
 	mb();
@@ -126,9 +146,10 @@ static void __init wakeup_secondary(void)
  */
 void __init smp_init_cpus(void)
 {
+	void __iomem *scu_base = scu_base_addr();
 	unsigned int i, ncores;
 
-	ncores = scu_get_core_count(__io_address(UX500_SCU_BASE));
+	ncores = scu_base ? scu_get_core_count(scu_base) : 1;
 
 	/* sanity check */
 	if (ncores > NR_CPUS) {
@@ -154,6 +175,6 @@ void __init platform_smp_prepare_cpus(unsigned int max_cpus)
 	for (i = 0; i < max_cpus; i++)
 		set_cpu_present(i, true);
 
-	scu_enable(__io_address(UX500_SCU_BASE));
+	scu_enable(scu_base_addr());
 	wakeup_secondary();
 }

commit 404a02cbd2ae8bf256a2fa1169bdfe86bb5ebb34
Merge: 28cdac6690cb 1051b9f0f9ea
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jan 6 22:33:32 2011 +0000

    Merge branch 'devel-stable' into devel
    
    Conflicts:
            arch/arm/mach-pxa/clock.c
            arch/arm/mach-pxa/clock.h

commit 4073723acb9cdcdbe4df9c0e0c376c65d1697e43
Merge: 58daf18cdcab 4ec3eb136345
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jan 6 22:32:52 2011 +0000

    Merge branch 'misc' into devel
    
    Conflicts:
            arch/arm/Kconfig
            arch/arm/common/Makefile
            arch/arm/kernel/Makefile
            arch/arm/kernel/smp.c

commit 3705ff6da538aff6dba535e2e9cbcbb9456d0d53
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Dec 18 10:53:12 2010 +0000

    ARM: Fix subtle race in CPU pen_release hotplug code
    
    There is a subtle race in the CPU hotplug code, where a CPU which has
    been offlined can online itself before being requested, which results
    in things going astray on the next online/offline cycle.
    
    What happens in the normal online/offline/online cycle is:
    
            CPU0                    CPU3
            requests boot of CPU3
            pen_release = 3
            flush cache line
                                    checks pen_release, reads 3
                                    starts boot
                                    pen_release = -1
            ... requests CPU3 offline ...
                                    ... dies ...
                                    checks pen_release, reads -1
            requests boot of CPU3
            pen_release = 3
            flush cache line
                                    checks pen_release, reads 3
                                    starts boot
                                    pen_release = -1
    
    However, as the write of -1 of pen_release is not fully flushed back to
    memory, and the checking of pen_release is done with caches disabled,
    this allows CPU3 the opportunity to read the old value of pen_release:
    
            CPU0                    CPU3
            requests boot of CPU3
            pen_release = 3
            flush cache line
                                    checks pen_release, reads 3
                                    starts boot
                                    pen_release = -1
            ... requests CPU3 offline ...
                                    ... dies ...
                                    checks pen_release, reads 3
                                    starts boot
                                    pen_release = -1
            requests boot of CPU3
            pen_release = 3
            flush cache line
    
    Fix this by grouping the write of pen_release along with its cache line
    flushing code to ensure that any update to pen_release is always pushed
    out to physical memory.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index ddedbc80c41f..f71175a766d7 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -27,6 +27,19 @@
  */
 volatile int __cpuinitdata pen_release = -1;
 
+/*
+ * Write pen_release in a way that is guaranteed to be visible to all
+ * observers, irrespective of whether they're taking part in coherency
+ * or not.  This is necessary for the hotplug code to work reliably.
+ */
+static void write_pen_release(int val)
+{
+	pen_release = val;
+	smp_wmb();
+	__cpuc_flush_dcache_area((void *)&pen_release, sizeof(pen_release));
+	outer_clean_range(__pa(&pen_release), __pa(&pen_release + 1));
+}
+
 static DEFINE_SPINLOCK(boot_lock);
 
 void __cpuinit platform_secondary_init(unsigned int cpu)
@@ -42,7 +55,7 @@ void __cpuinit platform_secondary_init(unsigned int cpu)
 	 * let the primary processor know we're out of the
 	 * pen, then head off into the C entry point
 	 */
-	pen_release = -1;
+	write_pen_release(-1);
 
 	/*
 	 * Synchronise with the boot thread.
@@ -66,9 +79,7 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	 * the holding pen - release it, then wait for it to flag
 	 * that it has been released by resetting pen_release.
 	 */
-	pen_release = cpu;
-	__cpuc_flush_dcache_area((void *)&pen_release, sizeof(pen_release));
-	outer_clean_range(__pa(&pen_release), __pa(&pen_release) + 1);
+	write_pen_release(cpu);
 
 	smp_cross_call(cpumask_of(cpu), 1);
 
@@ -89,9 +100,6 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 
 static void __init wakeup_secondary(void)
 {
-	/* nobody is to be released from the pen yet */
-	pen_release = -1;
-
 	/*
 	 * write the address of secondary startup into the backup ram register
 	 * at offset 0x1FF4, then write the magic number 0xA1FEED01 to the

commit 2c0136dba4e43b0916ccc9ecc7f11e6d6b73f046
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Dec 3 15:00:49 2010 +0000

    ARM: SMP: consolidate trace_hardirqs_off() into common SMP code
    
    All platforms call trace_hardirqs_off() in their secondary startup code,
    so move this into the core SMP code - it doesn't need to be in the
    per-platform code.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 458a288981cb..ddedbc80c41f 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -31,8 +31,6 @@ static DEFINE_SPINLOCK(boot_lock);
 
 void __cpuinit platform_secondary_init(unsigned int cpu)
 {
-	trace_hardirqs_off();
-
 	/*
 	 * if any interrupts are already enabled for the primary
 	 * core (e.g. timer irq), then they will not have been enabled

commit 05c74a6cbcfb416286a947668ba32f63d99fe74a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Dec 3 11:09:48 2010 +0000

    ARM: SMP: consolidate the common parts of smp_prepare_cpus()
    
    There is a certain amount of smp_prepare_cpus() which doesn't belong
    in the platform support code - that is, code which is invariant to the
    SMP implementation.  Move this code into arch/arm/kernel/smp.c, and
    add a platform_ prefix to the original function.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index fd40fa175913..458a288981cb 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -18,7 +18,6 @@
 #include <linux/io.h>
 
 #include <asm/cacheflush.h>
-#include <asm/localtimer.h>
 #include <asm/smp_scu.h>
 #include <mach/hardware.h>
 
@@ -138,20 +137,10 @@ void __init smp_init_cpus(void)
 		set_cpu_possible(i, true);
 }
 
-void __init smp_prepare_cpus(unsigned int max_cpus)
+void __init platform_smp_prepare_cpus(unsigned int max_cpus)
 {
-	unsigned int ncores = num_possible_cpus();
-	unsigned int cpu = smp_processor_id();
 	int i;
 
-	smp_store_cpu_info(cpu);
-
-	/*
-	 * are we trying to boot more cores than exist?
-	 */
-	if (max_cpus > ncores)
-		max_cpus = ncores;
-
 	/*
 	 * Initialise the present map, which describes the set of CPUs
 	 * actually populated at the present time.
@@ -159,13 +148,6 @@ void __init smp_prepare_cpus(unsigned int max_cpus)
 	for (i = 0; i < max_cpus; i++)
 		set_cpu_present(i, true);
 
-	if (max_cpus > 1) {
-		/*
-		 * Enable the local timer or broadcast device for the
-		 * boot CPU, but only if we have more than one CPU.
-		 */
-		percpu_timer_setup();
-		scu_enable(__io_address(UX500_SCU_BASE));
-		wakeup_secondary();
-	}
+	scu_enable(__io_address(UX500_SCU_BASE));
+	wakeup_secondary();
 }

commit fd778f0ad7dda1108281410ddca0d07936256d3c
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Dec 2 18:09:37 2010 +0000

    ARM: SMP: get rid of get_core_count()
    
    We don't need this small function as well as scu_get_core_count()
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index e31024e3a7cc..fd40fa175913 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -28,11 +28,6 @@
  */
 volatile int __cpuinitdata pen_release = -1;
 
-static unsigned int __init get_core_count(void)
-{
-	return scu_get_core_count(__io_address(UX500_SCU_BASE));
-}
-
 static DEFINE_SPINLOCK(boot_lock);
 
 void __cpuinit platform_secondary_init(unsigned int cpu)
@@ -126,7 +121,9 @@ static void __init wakeup_secondary(void)
  */
 void __init smp_init_cpus(void)
 {
-	unsigned int i, ncores = get_core_count();
+	unsigned int i, ncores;
+
+	ncores = scu_get_core_count(__io_address(UX500_SCU_BASE));
 
 	/* sanity check */
 	if (ncores > NR_CPUS) {

commit 8975b6c0fdd57e061f4d1040163778ceaf340ad8
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Dec 3 19:29:53 2010 +0000

    ARM: SMP: Clean up ncores sanity checks
    
    scu_get_core_count() never returns zero cores, so we don't need to
    check and correct if ncores is zero.
    
    Tegra was missing the check against NR_CPUS, leading to a potential
    bitfield overflow if this becomes the case.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index a51962b7579b..e31024e3a7cc 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -129,12 +129,6 @@ void __init smp_init_cpus(void)
 	unsigned int i, ncores = get_core_count();
 
 	/* sanity check */
-	if (ncores == 0) {
-		printk(KERN_ERR
-		       "U8500: strange CM count of 0? Default to 1\n");
-		ncores = 1;
-	}
-
 	if (ncores > NR_CPUS) {
 		printk(KERN_WARNING
 		       "U8500: no. of cores (%d) greater than configured "

commit bbc3d14e9aca023bb98e580aa1c9350af8effdb1
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Dec 3 10:42:58 2010 +0000

    ARM: SMP: move CPU number sanity checks to smp_init_cpus()
    
    Ensure that the number of CPUs is sanity checked before setting
    the number of possible CPUs.  This avoids any chance of overflowing
    the cpu_possible bitmap.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index b8987bd21249..a51962b7579b 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -128,16 +128,6 @@ void __init smp_init_cpus(void)
 {
 	unsigned int i, ncores = get_core_count();
 
-	for (i = 0; i < ncores; i++)
-		set_cpu_possible(i, true);
-}
-
-void __init smp_prepare_cpus(unsigned int max_cpus)
-{
-	unsigned int ncores = get_core_count();
-	unsigned int cpu = smp_processor_id();
-	int i;
-
 	/* sanity check */
 	if (ncores == 0) {
 		printk(KERN_ERR
@@ -145,14 +135,24 @@ void __init smp_prepare_cpus(unsigned int max_cpus)
 		ncores = 1;
 	}
 
-	if (ncores > num_possible_cpus())	{
+	if (ncores > NR_CPUS) {
 		printk(KERN_WARNING
 		       "U8500: no. of cores (%d) greater than configured "
 		       "maximum of %d - clipping\n",
-		       ncores, num_possible_cpus());
-		ncores = num_possible_cpus();
+		       ncores, NR_CPUS);
+		ncores = NR_CPUS;
 	}
 
+	for (i = 0; i < ncores; i++)
+		set_cpu_possible(i, true);
+}
+
+void __init smp_prepare_cpus(unsigned int max_cpus)
+{
+	unsigned int ncores = num_possible_cpus();
+	unsigned int cpu = smp_processor_id();
+	int i;
+
 	smp_store_cpu_info(cpu);
 
 	/*

commit 3c5728edbeb44819dba25a3c1b56702c87c9e419
Author: Jonas Aaberg <jonas.aberg@stericsson.com>
Date:   Wed Dec 15 08:36:02 2010 +0100

    ux500: platsmp: Fix section mismatch
    
    Signed-off-by: Jonas Aaberg <jonas.aberg@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 9e4c678de785..ade2e17f253c 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -26,7 +26,7 @@
  * control for which core is the next to come out of the secondary
  * boot "holding pen"
  */
-volatile int __cpuinitdata pen_release = -1;
+volatile int pen_release = -1;
 
 static unsigned int __init get_core_count(void)
 {

commit 384895330e0f3954d9478fd0853145f9c169df12
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Dec 4 16:01:03 2010 +0000

    ARM: GIC: Remove MMIO address from gic_cpu_init, rename to gic_secondary_init
    
    We don't need to re-pass the base address for the CPU interfaces to the
    GIC for secondary CPUs, as it will never be different from the boot CPU
    - and even if it was, we'd overwrite the boot CPU's base address.
    
    Get rid of this argument, and rename to gic_secondary_init().
    
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Tested-by: Abhijeet Dharmapurikar <adharmap@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 9e4c678de785..b5077b4c419f 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -44,7 +44,7 @@ void __cpuinit platform_secondary_init(unsigned int cpu)
 	 * core (e.g. timer irq), then they will not have been enabled
 	 * for us: do so
 	 */
-	gic_cpu_init(0, __io_address(UX500_GIC_CPU_BASE));
+	gic_secondary_init(0);
 
 	/*
 	 * let the primary processor know we're out of the

commit ad3b6993b9c5482e8a2ec5aed181538c921fdcbd
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Nov 15 09:42:08 2010 +0000

    ARM: SMP: pass an ipi number to smp_cross_call()
    
    This allows us to use smp_cross_call() to trigger a number of different
    software generated interrupts, rather than combining them all on one
    SGI.  Recover the SGI number via do_IPI.
    
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 9e4c678de785..b8987bd21249 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -78,7 +78,7 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	__cpuc_flush_dcache_area((void *)&pen_release, sizeof(pen_release));
 	outer_clean_range(__pa(&pen_release), __pa(&pen_release) + 1);
 
-	smp_cross_call(cpumask_of(cpu));
+	smp_cross_call(cpumask_of(cpu), 1);
 
 	timeout = jiffies + (1 * HZ);
 	while (time_before(jiffies, timeout)) {

commit 9d704c04ff8ae61b60935d67ce334b18fc70f1b2
Author: Sundar Iyer <sundar.iyer@stericsson.com>
Date:   Wed Sep 15 10:45:51 2010 +0100

    ARM: 6391/1: ux500: add CPU hotplug support
    
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Sundar Iyer <sundar.iyer@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 438ef16aec90..9e4c678de785 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -78,6 +78,8 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	__cpuc_flush_dcache_area((void *)&pen_release, sizeof(pen_release));
 	outer_clean_range(__pa(&pen_release), __pa(&pen_release) + 1);
 
+	smp_cross_call(cpumask_of(cpu));
+
 	timeout = jiffies + (1 * HZ);
 	while (time_before(jiffies, timeout)) {
 		if (pen_release == -1)

commit 817412d3a1391d4667494f16cd49455c62453c78
Author: Rabin Vincent <rabin.vincent@stericsson.com>
Date:   Mon May 3 08:31:35 2010 +0100

    ARM: 6088/1: ux500: use UX500_* macros instead of U8500_*
    
    So that the correct addresses get used on U5500.
    
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Acked-by: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Signed-off-by: Rabin Vincent <rabin.vincent@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 76dd9354bd18..438ef16aec90 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -30,7 +30,7 @@ volatile int __cpuinitdata pen_release = -1;
 
 static unsigned int __init get_core_count(void)
 {
-	return scu_get_core_count(__io_address(U8500_SCU_BASE));
+	return scu_get_core_count(__io_address(UX500_SCU_BASE));
 }
 
 static DEFINE_SPINLOCK(boot_lock);
@@ -44,7 +44,7 @@ void __cpuinit platform_secondary_init(unsigned int cpu)
 	 * core (e.g. timer irq), then they will not have been enabled
 	 * for us: do so
 	 */
-	gic_cpu_init(0, __io_address(U8500_GIC_CPU_BASE));
+	gic_cpu_init(0, __io_address(UX500_GIC_CPU_BASE));
 
 	/*
 	 * let the primary processor know we're out of the
@@ -106,12 +106,12 @@ static void __init wakeup_secondary(void)
 	 */
 #define U8500_CPU1_JUMPADDR_OFFSET 0x1FF4
 	__raw_writel(virt_to_phys(u8500_secondary_startup),
-		(void __iomem *)IO_ADDRESS(U8500_BACKUPRAM0_BASE) +
+		__io_address(UX500_BACKUPRAM0_BASE) +
 		U8500_CPU1_JUMPADDR_OFFSET);
 
 #define U8500_CPU1_WAKEMAGIC_OFFSET 0x1FF0
 	__raw_writel(0xA1FEED01,
-		(void __iomem *)IO_ADDRESS(U8500_BACKUPRAM0_BASE) +
+		__io_address(UX500_BACKUPRAM0_BASE) +
 		U8500_CPU1_WAKEMAGIC_OFFSET);
 
 	/* make sure write buffer is drained */
@@ -172,7 +172,7 @@ void __init smp_prepare_cpus(unsigned int max_cpus)
 		 * boot CPU, but only if we have more than one CPU.
 		 */
 		percpu_timer_setup();
-		scu_enable(__io_address(U8500_SCU_BASE));
+		scu_enable(__io_address(UX500_SCU_BASE));
 		wakeup_secondary();
 	}
 }

commit 8e797a7e4f588fb3b9cfe9860b00dcd3b14f8b60
Author: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
Date:   Sat Apr 3 19:10:45 2010 +0100

    ARM: 6027/1: ux500: enable l2x0 support
    
    This enables the l2x0 support and ensures that the secondary
    CPU can see the page table and secondary data at this point.
    
    Signed-off-by: srinidhi kasagar <srinidhi.kasagar@stericsson.com>
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
index 8dfe7ca245d8..76dd9354bd18 100644
--- a/arch/arm/mach-ux500/platsmp.c
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -75,7 +75,8 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	 * that it has been released by resetting pen_release.
 	 */
 	pen_release = cpu;
-	flush_cache_all();
+	__cpuc_flush_dcache_area((void *)&pen_release, sizeof(pen_release));
+	outer_clean_range(__pa(&pen_release), __pa(&pen_release) + 1);
 
 	timeout = jiffies + (1 * HZ);
 	while (time_before(jiffies, timeout)) {

commit aa44ef4d43b200c0e318ade2a3c24d00a6fd942a
Author: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
Date:   Sat Nov 28 08:17:18 2009 +0100

    ARM: 5831/1: ARM: U8500 core machine support
    
    Adds core support for the ST-Ericsson U8500
    platform. It supports memory mappings, binds to
    the existing modules like GIC, SCU, TWD and
    local timers and sets up the infrastructure for
    the secondary core.
    
    Reviewed-by: Alessandro Rubini <rubini@unipv.it>
    Reviewed-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: srinidhi kasagar <srinidhi.kasagar@stericsson.com>
    Acked-by: Andrea Gallo <andrea.gallo@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-ux500/platsmp.c b/arch/arm/mach-ux500/platsmp.c
new file mode 100644
index 000000000000..8dfe7ca245d8
--- /dev/null
+++ b/arch/arm/mach-ux500/platsmp.c
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2002 ARM Ltd.
+ * Copyright (C) 2008 STMicroelctronics.
+ * Copyright (C) 2009 ST-Ericsson.
+ * Author: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
+ *
+ * This file is based on arm realview platform
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+
+#include <asm/cacheflush.h>
+#include <asm/localtimer.h>
+#include <asm/smp_scu.h>
+#include <mach/hardware.h>
+
+/*
+ * control for which core is the next to come out of the secondary
+ * boot "holding pen"
+ */
+volatile int __cpuinitdata pen_release = -1;
+
+static unsigned int __init get_core_count(void)
+{
+	return scu_get_core_count(__io_address(U8500_SCU_BASE));
+}
+
+static DEFINE_SPINLOCK(boot_lock);
+
+void __cpuinit platform_secondary_init(unsigned int cpu)
+{
+	trace_hardirqs_off();
+
+	/*
+	 * if any interrupts are already enabled for the primary
+	 * core (e.g. timer irq), then they will not have been enabled
+	 * for us: do so
+	 */
+	gic_cpu_init(0, __io_address(U8500_GIC_CPU_BASE));
+
+	/*
+	 * let the primary processor know we're out of the
+	 * pen, then head off into the C entry point
+	 */
+	pen_release = -1;
+
+	/*
+	 * Synchronise with the boot thread.
+	 */
+	spin_lock(&boot_lock);
+	spin_unlock(&boot_lock);
+}
+
+int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	unsigned long timeout;
+
+	/*
+	 * set synchronisation state between this boot processor
+	 * and the secondary one
+	 */
+	spin_lock(&boot_lock);
+
+	/*
+	 * The secondary processor is waiting to be released from
+	 * the holding pen - release it, then wait for it to flag
+	 * that it has been released by resetting pen_release.
+	 */
+	pen_release = cpu;
+	flush_cache_all();
+
+	timeout = jiffies + (1 * HZ);
+	while (time_before(jiffies, timeout)) {
+		if (pen_release == -1)
+			break;
+	}
+
+	/*
+	 * now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	spin_unlock(&boot_lock);
+
+	return pen_release != -1 ? -ENOSYS : 0;
+}
+
+static void __init wakeup_secondary(void)
+{
+	/* nobody is to be released from the pen yet */
+	pen_release = -1;
+
+	/*
+	 * write the address of secondary startup into the backup ram register
+	 * at offset 0x1FF4, then write the magic number 0xA1FEED01 to the
+	 * backup ram register at offset 0x1FF0, which is what boot rom code
+	 * is waiting for. This would wake up the secondary core from WFE
+	 */
+#define U8500_CPU1_JUMPADDR_OFFSET 0x1FF4
+	__raw_writel(virt_to_phys(u8500_secondary_startup),
+		(void __iomem *)IO_ADDRESS(U8500_BACKUPRAM0_BASE) +
+		U8500_CPU1_JUMPADDR_OFFSET);
+
+#define U8500_CPU1_WAKEMAGIC_OFFSET 0x1FF0
+	__raw_writel(0xA1FEED01,
+		(void __iomem *)IO_ADDRESS(U8500_BACKUPRAM0_BASE) +
+		U8500_CPU1_WAKEMAGIC_OFFSET);
+
+	/* make sure write buffer is drained */
+	mb();
+}
+
+/*
+ * Initialise the CPU possible map early - this describes the CPUs
+ * which may be present or become present in the system.
+ */
+void __init smp_init_cpus(void)
+{
+	unsigned int i, ncores = get_core_count();
+
+	for (i = 0; i < ncores; i++)
+		set_cpu_possible(i, true);
+}
+
+void __init smp_prepare_cpus(unsigned int max_cpus)
+{
+	unsigned int ncores = get_core_count();
+	unsigned int cpu = smp_processor_id();
+	int i;
+
+	/* sanity check */
+	if (ncores == 0) {
+		printk(KERN_ERR
+		       "U8500: strange CM count of 0? Default to 1\n");
+		ncores = 1;
+	}
+
+	if (ncores > num_possible_cpus())	{
+		printk(KERN_WARNING
+		       "U8500: no. of cores (%d) greater than configured "
+		       "maximum of %d - clipping\n",
+		       ncores, num_possible_cpus());
+		ncores = num_possible_cpus();
+	}
+
+	smp_store_cpu_info(cpu);
+
+	/*
+	 * are we trying to boot more cores than exist?
+	 */
+	if (max_cpus > ncores)
+		max_cpus = ncores;
+
+	/*
+	 * Initialise the present map, which describes the set of CPUs
+	 * actually populated at the present time.
+	 */
+	for (i = 0; i < max_cpus; i++)
+		set_cpu_present(i, true);
+
+	if (max_cpus > 1) {
+		/*
+		 * Enable the local timer or broadcast device for the
+		 * boot CPU, but only if we have more than one CPU.
+		 */
+		percpu_timer_setup();
+		scu_enable(__io_address(U8500_SCU_BASE));
+		wakeup_secondary();
+	}
+}
