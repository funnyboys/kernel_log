commit 73c1b41e63f040e92669e61a02c7893933bfe743
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Dec 21 20:19:54 2016 +0100

    cpu/hotplug: Cleanup state names
    
    When the state names got added a script was used to add the extra argument
    to the calls. The script basically converted the state constant to a
    string, but the cleanup to convert these strings into meaningful ones did
    not happen.
    
    Replace all the useless strings with 'subsys/xxx/yyy:state' strings which
    are used in all the other places already.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Sebastian Siewior <bigeasy@linutronix.de>
    Link: http://lkml.kernel.org/r/20161221192112.085444152@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index ae2a018b9305..8f8748a0c84f 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -148,7 +148,7 @@ static void __init armada_370_coherency_init(struct device_node *np)
 	of_node_put(cpu_config_np);
 
 	cpuhp_setup_state_nocalls(CPUHP_AP_ARM_MVEBU_COHERENCY,
-				  "AP_ARM_MVEBU_COHERENCY",
+				  "arm/mvebu/coherency:starting",
 				  armada_xp_clear_l2_starting, NULL);
 exit:
 	set_cpu_coherent();

commit a6408f6cb63ac0958fee7dbce7861ffb540d8a49
Merge: 1a81a8f2a591 4fae16dffb81
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 29 13:55:30 2016 -0700

    Merge branch 'smp-hotplug-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull smp hotplug updates from Thomas Gleixner:
     "This is the next part of the hotplug rework.
    
       - Convert all notifiers with a priority assigned
    
       - Convert all CPU_STARTING/DYING notifiers
    
         The final removal of the STARTING/DYING infrastructure will happen
         when the merge window closes.
    
      Another 700 hundred line of unpenetrable maze gone :)"
    
    * 'smp-hotplug-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (70 commits)
      timers/core: Correct callback order during CPU hot plug
      leds/trigger/cpu: Move from CPU_STARTING to ONLINE level
      powerpc/numa: Convert to hotplug state machine
      arm/perf: Fix hotplug state machine conversion
      irqchip/armada: Avoid unused function warnings
      ARC/time: Convert to hotplug state machine
      clocksource/atlas7: Convert to hotplug state machine
      clocksource/armada-370-xp: Convert to hotplug state machine
      clocksource/exynos_mct: Convert to hotplug state machine
      clocksource/arm_global_timer: Convert to hotplug state machine
      rcu: Convert rcutree to hotplug state machine
      KVM/arm/arm64/vgic-new: Convert to hotplug state machine
      smp/cfd: Convert core to hotplug state machine
      x86/x2apic: Convert to CPU hotplug state machine
      profile: Convert to hotplug state machine
      timers/core: Convert to hotplug state machine
      hrtimer: Convert to hotplug state machine
      x86/tboot: Convert to hotplug state machine
      arm64/armv8 deprecated: Convert to hotplug state machine
      hwtracing/coresight-etm4x: Convert to hotplug state machine
      ...

commit 7fbbaebf8cd18cca58e84837fd80c07ea8d8bd56
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed Jul 13 17:16:08 2016 +0000

    ARM/mvebu: Convert to hotplug state machine
    
    Install the callbacks via the state machine.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Anna-Maria Gleixner <anna-maria@linutronix.de>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Gregory Clement <gregory.clement@free-electrons.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: rt@linutronix.de
    Link: http://lkml.kernel.org/r/20160713153333.503198935@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 7e989d61159c..77aaa5243a20 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -111,20 +111,12 @@ static struct notifier_block mvebu_hwcc_pci_nb __maybe_unused = {
 	.notifier_call = mvebu_hwcc_notifier,
 };
 
-static int armada_xp_clear_shared_l2_notifier_func(struct notifier_block *nfb,
-					unsigned long action, void *hcpu)
+static int armada_xp_clear_l2_starting(unsigned int cpu)
 {
-	if (action == CPU_STARTING || action == CPU_STARTING_FROZEN)
-		armada_xp_clear_shared_l2();
-
-	return NOTIFY_OK;
+	armada_xp_clear_shared_l2();
+	return 0;
 }
 
-static struct notifier_block armada_xp_clear_shared_l2_notifier = {
-	.notifier_call = armada_xp_clear_shared_l2_notifier_func,
-	.priority = 100,
-};
-
 static void __init armada_370_coherency_init(struct device_node *np)
 {
 	struct resource res;
@@ -155,8 +147,9 @@ static void __init armada_370_coherency_init(struct device_node *np)
 
 	of_node_put(cpu_config_np);
 
-	register_cpu_notifier(&armada_xp_clear_shared_l2_notifier);
-
+	cpuhp_setup_state_nocalls(CPUHP_AP_ARM_MVEBU_COHERENCY,
+				  "AP_ARM_MVEBU_COHERENCY",
+				  armada_xp_clear_l2_starting, NULL);
 exit:
 	set_cpu_coherent();
 }

commit 6a02734d420fca778554878d03017017537d92e1
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Thu Jun 16 15:42:26 2016 +0200

    ARM: mvebu: map PCI I/O regions strongly ordered
    
    In order for HW I/O coherency to work on Cortex-A9 based Marvell SoCs,
    all MMIO registers must be mapped strongly ordered. In commit
    1c8c3cf0b5239 ("ARM: 8060/1: mm: allow sub-architectures to override PCI
    I/O memory type") we implemented a new function,
    pci_ioremap_set_mem_type(), that allow sub-architecture code to override
    the memory type used to map PCI I/O regions.
    
    In the discussion around this patch series [1], Arnd Bergmann made the
    comment that maybe all PCI I/O regions should be mapped
    strongly-ordered, which would have made our proposal to add
    pci_ioremap_set_mem_type() irrelevant. So, we submitted a patch [2] that
    did what Arnd suggested.
    
    However, Russell in the end merged our initial proposal to add
    pci_ioremap_set_mem_type(), but it was never used anywhere. Further
    discussion with Arnd and other folks on IRC lead to the conclusion that
    in fact using strongly-ordered for all platforms was maybe not
    desirable, and therefore, using pci_ioremap_set_mem_type() was the most
    appropriate solution.
    
    As a consequence, this commit finally adds the
    pci_ioremap_set_mem_type() call in the mach-mvebu platform code, which
    was originally part of our initial patch series [3] and is necessary for
    the whole mechanism to work.
    
    [1] http://lists.infradead.org/pipermail/linux-arm-kernel/2014-May/256565.html
    [2] http://lists.infradead.org/pipermail/linux-arm-kernel/2014-May/256755.html
    [3] http://lists.infradead.org/pipermail/linux-arm-kernel/2014-May/256563.html
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 474abff7e855..e80f0dde2189 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -181,6 +181,7 @@ static void __init armada_375_380_coherency_init(struct device_node *np)
 
 	coherency_cpu_base = of_iomap(np, 0);
 	arch_ioremap_caller = armada_wa_ioremap_caller;
+	pci_ioremap_set_mem_type(MT_UNCACHED);
 
 	/*
 	 * We should switch the PL310 to I/O coherency mode only if

commit c5379ba8fccd99d5f99632c789f0393d84a57805
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Thu Jun 16 15:42:25 2016 +0200

    ARM: mvebu: fix HW I/O coherency related deadlocks
    
    Until now, our understanding for HW I/O coherency to work on the
    Cortex-A9 based Marvell SoC was that only the PCIe regions should be
    mapped strongly-ordered. However, we were still encountering some
    deadlocks, especially when testing the CESA crypto engine. After
    checking with the HW designers, it was concluded that all the MMIO
    registers should be mapped as strongly ordered for the HW I/O coherency
    mechanism to work properly.
    
    This fixes some easy to reproduce deadlocks with the CESA crypto engine
    driver (dmcrypt on a sufficiently large disk partition).
    
    Tested-by: Terry Stockert <stockert@inkblotadmirer.me>
    Tested-by: Romain Perier <romain.perier@free-electrons.com>
    Cc: Terry Stockert <stockert@inkblotadmirer.me>
    Cc: Romain Perier <romain.perier@free-electrons.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 7e989d61159c..474abff7e855 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -162,22 +162,16 @@ static void __init armada_370_coherency_init(struct device_node *np)
 }
 
 /*
- * This ioremap hook is used on Armada 375/38x to ensure that PCIe
- * memory areas are mapped as MT_UNCACHED instead of MT_DEVICE. This
- * is needed as a workaround for a deadlock issue between the PCIe
- * interface and the cache controller.
+ * This ioremap hook is used on Armada 375/38x to ensure that all MMIO
+ * areas are mapped as MT_UNCACHED instead of MT_DEVICE. This is
+ * needed for the HW I/O coherency mechanism to work properly without
+ * deadlock.
  */
 static void __iomem *
-armada_pcie_wa_ioremap_caller(phys_addr_t phys_addr, size_t size,
-			      unsigned int mtype, void *caller)
+armada_wa_ioremap_caller(phys_addr_t phys_addr, size_t size,
+			 unsigned int mtype, void *caller)
 {
-	struct resource pcie_mem;
-
-	mvebu_mbus_get_pcie_mem_aperture(&pcie_mem);
-
-	if (pcie_mem.start <= phys_addr && (phys_addr + size) <= pcie_mem.end)
-		mtype = MT_UNCACHED;
-
+	mtype = MT_UNCACHED;
 	return __arm_ioremap_caller(phys_addr, size, mtype, caller);
 }
 
@@ -186,7 +180,7 @@ static void __init armada_375_380_coherency_init(struct device_node *np)
 	struct device_node *cache_dn;
 
 	coherency_cpu_base = of_iomap(np, 0);
-	arch_ioremap_caller = armada_pcie_wa_ioremap_caller;
+	arch_ioremap_caller = armada_wa_ioremap_caller;
 
 	/*
 	 * We should switch the PL310 to I/O coherency mode only if

commit 60f23952317a34e8d41c22a6058dcb7bdaf91b96
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Feb 23 15:06:39 2016 +0100

    ARM: mvebu: mark mvebu_hwcc_pci_nb as __maybe_unused
    
    The coherency notifier block is only used when CONFIG_PCI
    is enabled, otherwise we get a warning:
    
    arch/arm/mach-mvebu/coherency.c:110:30: warning: 'mvebu_hwcc_pci_nb' defined but not used [-Wunused-variable]
    
    There is no nice way to use an if(IS_ENABLED()) check here to
    let the compiler know that it might be used, so let's mark
    the structure as __maybe_unused.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 55348ee5a352..7e989d61159c 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -107,7 +107,7 @@ static struct notifier_block mvebu_hwcc_nb = {
 	.notifier_call = mvebu_hwcc_notifier,
 };
 
-static struct notifier_block mvebu_hwcc_pci_nb = {
+static struct notifier_block mvebu_hwcc_pci_nb __maybe_unused = {
 	.notifier_call = mvebu_hwcc_notifier,
 };
 

commit d492cccac28493f26bb70038385a9ef4df19bdee
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Wed Jul 8 16:09:20 2015 +0200

    ARM: mvebu: add support to clear shared L2 bit on Armada XP
    
    For optimal performance, in a HW I/O coherency context such as the one
    used on Armada XP, the shared L2 bit of the CPU configuration register
    should be cleared.
    
    This commit adjusts the coherency fabric code used by Marvell EBU
    processors to clear this bit on Armada XP. Since it's a per-CPU
    register, it's cleared in set_cpu_coherent() for the boot CPU, and
    through a CPU notifier for the non-boot CPUs.
    
    [gregory.clement@free-electrons.com: rebasd on 4.3-rc1]
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 44eedf331ae7..55348ee5a352 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -40,6 +40,7 @@
 unsigned long coherency_phys_base;
 void __iomem *coherency_base;
 static void __iomem *coherency_cpu_base;
+static void __iomem *cpu_config_base;
 
 /* Coherency fabric registers */
 #define IO_SYNC_BARRIER_CTL_OFFSET		   0x0
@@ -65,6 +66,31 @@ static const struct of_device_id of_coherency_table[] = {
 int ll_enable_coherency(void);
 void ll_add_cpu_to_smp_group(void);
 
+#define CPU_CONFIG_SHARED_L2 BIT(16)
+
+/*
+ * Disable the "Shared L2 Present" bit in CPU Configuration register
+ * on Armada XP.
+ *
+ * The "Shared L2 Present" bit affects the "level of coherence" value
+ * in the clidr CP15 register.  Cache operation functions such as
+ * "flush all" and "invalidate all" operate on all the cache levels
+ * that included in the defined level of coherence. When HW I/O
+ * coherency is used, this bit causes unnecessary flushes of the L2
+ * cache.
+ */
+static void armada_xp_clear_shared_l2(void)
+{
+	u32 reg;
+
+	if (!cpu_config_base)
+		return;
+
+	reg = readl(cpu_config_base);
+	reg &= ~CPU_CONFIG_SHARED_L2;
+	writel(reg, cpu_config_base);
+}
+
 static int mvebu_hwcc_notifier(struct notifier_block *nb,
 			       unsigned long event, void *__dev)
 {
@@ -85,9 +111,24 @@ static struct notifier_block mvebu_hwcc_pci_nb = {
 	.notifier_call = mvebu_hwcc_notifier,
 };
 
+static int armada_xp_clear_shared_l2_notifier_func(struct notifier_block *nfb,
+					unsigned long action, void *hcpu)
+{
+	if (action == CPU_STARTING || action == CPU_STARTING_FROZEN)
+		armada_xp_clear_shared_l2();
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block armada_xp_clear_shared_l2_notifier = {
+	.notifier_call = armada_xp_clear_shared_l2_notifier_func,
+	.priority = 100,
+};
+
 static void __init armada_370_coherency_init(struct device_node *np)
 {
 	struct resource res;
+	struct device_node *cpu_config_np;
 
 	of_address_to_resource(np, 0, &res);
 	coherency_phys_base = res.start;
@@ -100,6 +141,23 @@ static void __init armada_370_coherency_init(struct device_node *np)
 	sync_cache_w(&coherency_phys_base);
 	coherency_base = of_iomap(np, 0);
 	coherency_cpu_base = of_iomap(np, 1);
+
+	cpu_config_np = of_find_compatible_node(NULL, NULL,
+						"marvell,armada-xp-cpu-config");
+	if (!cpu_config_np)
+		goto exit;
+
+	cpu_config_base = of_iomap(cpu_config_np, 0);
+	if (!cpu_config_base) {
+		of_node_put(cpu_config_np);
+		goto exit;
+	}
+
+	of_node_put(cpu_config_np);
+
+	register_cpu_notifier(&armada_xp_clear_shared_l2_notifier);
+
+exit:
 	set_cpu_coherent();
 }
 
@@ -204,6 +262,8 @@ int set_cpu_coherent(void)
 			pr_warn("Coherency fabric is not initialized\n");
 			return 1;
 		}
+
+		armada_xp_clear_shared_l2();
 		ll_add_cpu_to_smp_group();
 		return ll_enable_coherency();
 	}

commit 01049a5deb1d6b9fc3f2df512af09fddd0db6730
Author: Nadav Haklai <nadavh@marvell.com>
Date:   Wed Jul 8 17:02:30 2015 +0200

    ARM: mvebu: prepare set_cpu_coherent() for future extension
    
    This patch prepares the set_cpu_coherent() function in coherency.c to
    be extended to support other SoCs than Armada XP. It will be needed on
    Armada 38x to re-enable the coherency after exiting from suspend to
    RAM.
    
    This preparation simply moves the function further down in coherency.c
    so that it can use coherency_type(), and uses that function to only do
    the Armada XP specific work if we are on Armada XP.
    
    Signed-off-by: Nadav Haklai <nadavh@marvell.com>
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index e46e9ea1e187..44eedf331ae7 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -65,18 +65,6 @@ static const struct of_device_id of_coherency_table[] = {
 int ll_enable_coherency(void);
 void ll_add_cpu_to_smp_group(void);
 
-int set_cpu_coherent(void)
-{
-	if (!coherency_base) {
-		pr_warn("Can't make current CPU cache coherent.\n");
-		pr_warn("Coherency fabric is not initialized\n");
-		return 1;
-	}
-
-	ll_add_cpu_to_smp_group();
-	return ll_enable_coherency();
-}
-
 static int mvebu_hwcc_notifier(struct notifier_block *nb,
 			       unsigned long event, void *__dev)
 {
@@ -206,6 +194,23 @@ static int coherency_type(void)
 	return type;
 }
 
+int set_cpu_coherent(void)
+{
+	int type = coherency_type();
+
+	if (type == COHERENCY_FABRIC_TYPE_ARMADA_370_XP) {
+		if (!coherency_base) {
+			pr_warn("Can't make current CPU cache coherent.\n");
+			pr_warn("Coherency fabric is not initialized\n");
+			return 1;
+		}
+		ll_add_cpu_to_smp_group();
+		return ll_enable_coherency();
+	}
+
+	return 0;
+}
+
 int coherency_available(void)
 {
 	return coherency_type() != COHERENCY_FABRIC_TYPE_NONE;

commit 444d2d33d8564f95df851ddaca80f640ca36934d
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Feb 18 21:19:56 2015 +0100

    ARM: make of_device_ids const
    
    of_device_ids (i.e. compatible strings and the respective data) are not
    supposed to change at runtime. All functions working with of_device_ids
    provided by <linux/of.h> work with const of_device_ids. So mark the
    non-const structs in arch/arm as const, too.
    
    While at it also add some __initconst annotations.
    
    Acked-by: Jason Cooper <jason@lakedameon.net>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index b5895f040caa..e46e9ea1e187 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -51,7 +51,7 @@ enum {
 	COHERENCY_FABRIC_TYPE_ARMADA_380,
 };
 
-static struct of_device_id of_coherency_table[] = {
+static const struct of_device_id of_coherency_table[] = {
 	{.compatible = "marvell,coherency-fabric",
 	 .data = (void *) COHERENCY_FABRIC_TYPE_ARMADA_370_XP },
 	{.compatible = "marvell,armada-375-coherency-fabric",

commit 878ba61aa98cbb97a513757800e77613f856a029
Merge: ea7531ac4a9d df1a66812535
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 17 09:27:54 2015 -0800

    Merge tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform changes from Olof Johansson:
     "New and updated SoC support.  Also included are some cleanups where
      the platform maintainers hadn't separated cleanups from new developent
      in separate branches.
    
      Some of the larger things worth pointing out:
    
       - A large set of changes from Alexandre Belloni and Nicolas Ferre
         preparing at91 platforms for multiplatform and cleaning up quite a
         bit in the process.
    
       - Removal of CSR's "Marco" SoC platform that never made it out to the
         market.  We love seeing these since it means the vendor published
         support before product was out, which is exactly what we want!
    
      New platforms this release are:
    
       - Conexant Digicolor (CX92755 SoC)
       - Hisilicon HiP01 SoC
       - CSR/sirf Atlas7 SoC
       - ST STiH418 SoC
       - Common code changes for Nvidia Tegra132 (64-bit SoC)
    
      We're seeing more and more platforms having a harder time labelling
      changes as cleanups vs new development -- which is a good sign that
      we've come quite far on the cleanup effort.  So over time we might
      start combining the cleanup and new-development branches more"
    
    * tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (124 commits)
      ARM: at91/trivial: unify functions and machine names
      ARM: at91: remove at91_dt_initialize and machine init_early()
      ARM: at91: change board files into SoC files
      ARM: at91: remove at91_boot_soc
      ARM: at91: move alternative initial mapping to board-dt-sama5.c
      ARM: at91: merge all SOC_AT91SAM9xxx
      ARM: at91: at91rm9200: set idle and restart from rm9200_dt_device_init()
      ARM: digicolor: select syscon and timer
      ARM: zynq: Simplify SLCR initialization
      ARM: zynq: PM: Fixed simple typo.
      ARM: zynq: Setup default gpio number for Xilinx Zynq
      ARM: digicolor: add low level debug support
      ARM: initial support for Conexant Digicolor CX92755 SoC
      ARM: OMAP2+: Add dm816x hwmod support
      ARM: OMAP2+: Add clock domain support for dm816x
      ARM: OMAP2+: Add board-generic.c entry for ti81xx
      ARM: at91: pm: remove warning to remove SOC_AT91SAM9263 usage
      ARM: at91: remove unused mach/system_rev.h
      ARM: at91: stop using HAVE_AT91_DBGUx
      ARM: at91: fix ordering of SRAM and PM initialization
      ...

commit dcad68876c21bac709b01eda24e39d4410dc36a8
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Wed Jan 28 12:55:45 2015 +0100

    ARM: mvebu: don't set the PL310 in I/O coherency mode when I/O coherency is disabled
    
    Since commit f2c3c67f00 (merge commit that adds commit "ARM: mvebu:
    completely disable hardware I/O coherency"), we disable I/O coherency
    on Armada EBU platforms.
    
    However, we continue to initialize the coherency fabric, because this
    coherency fabric is needed on Armada XP for inter-CPU
    coherency. Unfortunately, due to this, we also continued to execute
    the coherency fabric initialization code for Armada 375/38x, which
    switched the PL310 into I/O coherent mode. This has the effect of
    disabling the outer cache sync operation: this is needed when I/O
    coherency is enabled to work around a PCIe/L2 deadlock. But obviously,
    when I/O coherency is disabled, having the outer cache sync operation
    is crucial.
    
    Therefore, this commit fixes the armada_375_380_coherency_init() so
    that the PL310 is switched to I/O coherent mode only if I/O coherency
    is enabled.
    
    Without this fix, all devices using DMA are broken on Armada 375/38x.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Tested-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Cc: <stable@vger.kernel.org> # v3.8+

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index caa21e9b8cd9..ccef8806bb58 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -189,6 +189,13 @@ static void __init armada_375_380_coherency_init(struct device_node *np)
 	coherency_cpu_base = of_iomap(np, 0);
 	arch_ioremap_caller = armada_pcie_wa_ioremap_caller;
 
+	/*
+	 * We should switch the PL310 to I/O coherency mode only if
+	 * I/O coherency is actually enabled.
+	 */
+	if (!coherency_available())
+		return;
+
 	/*
 	 * Add the PL310 property "arm,io-coherent". This makes sure the
 	 * outer sync operation is not used, which allows to

commit 1bd4d8a6de5cda605e8b99fbf081be2ea2959380
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Fri Jan 16 17:11:29 2015 +0100

    ARM: mvebu: use arm_coherent_dma_ops and re-enable hardware I/O coherency
    
    Now that we have enabled automatic I/O synchronization barriers, we no
    longer need any explicit barriers. We can therefore simplify
    arch/arm/mach-mvebu/coherency.c by using the existing
    arm_coherent_dma_ops instead of our custom mvebu_hwcc_dma_ops, and
    re-enable hardware I/O coherency support.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    [Andrew Lunn <andrew@lunn.ch>: Remove forgotten comment]
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index caa21e9b8cd9..440799ba664a 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -33,6 +33,7 @@
 #include <asm/smp_plat.h>
 #include <asm/cacheflush.h>
 #include <asm/mach/map.h>
+#include <asm/dma-mapping.h>
 #include "coherency.h"
 #include "mvebu-soc-id.h"
 
@@ -76,54 +77,6 @@ int set_cpu_coherent(void)
 	return ll_enable_coherency();
 }
 
-static inline void mvebu_hwcc_sync_io_barrier(void)
-{
-	writel(0x1, coherency_cpu_base + IO_SYNC_BARRIER_CTL_OFFSET);
-	while (readl(coherency_cpu_base + IO_SYNC_BARRIER_CTL_OFFSET) & 0x1);
-}
-
-static dma_addr_t mvebu_hwcc_dma_map_page(struct device *dev, struct page *page,
-				  unsigned long offset, size_t size,
-				  enum dma_data_direction dir,
-				  struct dma_attrs *attrs)
-{
-	if (dir != DMA_TO_DEVICE)
-		mvebu_hwcc_sync_io_barrier();
-	return pfn_to_dma(dev, page_to_pfn(page)) + offset;
-}
-
-
-static void mvebu_hwcc_dma_unmap_page(struct device *dev, dma_addr_t dma_handle,
-			      size_t size, enum dma_data_direction dir,
-			      struct dma_attrs *attrs)
-{
-	if (dir != DMA_TO_DEVICE)
-		mvebu_hwcc_sync_io_barrier();
-}
-
-static void mvebu_hwcc_dma_sync(struct device *dev, dma_addr_t dma_handle,
-			size_t size, enum dma_data_direction dir)
-{
-	if (dir != DMA_TO_DEVICE)
-		mvebu_hwcc_sync_io_barrier();
-}
-
-static struct dma_map_ops mvebu_hwcc_dma_ops = {
-	.alloc			= arm_dma_alloc,
-	.free			= arm_dma_free,
-	.mmap			= arm_dma_mmap,
-	.map_page		= mvebu_hwcc_dma_map_page,
-	.unmap_page		= mvebu_hwcc_dma_unmap_page,
-	.get_sgtable		= arm_dma_get_sgtable,
-	.map_sg			= arm_dma_map_sg,
-	.unmap_sg		= arm_dma_unmap_sg,
-	.sync_single_for_cpu	= mvebu_hwcc_dma_sync,
-	.sync_single_for_device	= mvebu_hwcc_dma_sync,
-	.sync_sg_for_cpu	= arm_dma_sync_sg_for_cpu,
-	.sync_sg_for_device	= arm_dma_sync_sg_for_device,
-	.set_dma_mask		= arm_dma_set_mask,
-};
-
 static int mvebu_hwcc_notifier(struct notifier_block *nb,
 			       unsigned long event, void *__dev)
 {
@@ -131,7 +84,7 @@ static int mvebu_hwcc_notifier(struct notifier_block *nb,
 
 	if (event != BUS_NOTIFY_ADD_DEVICE)
 		return NOTIFY_DONE;
-	set_dma_ops(dev, &mvebu_hwcc_dma_ops);
+	set_dma_ops(dev, &arm_coherent_dma_ops);
 
 	return NOTIFY_OK;
 }
@@ -246,14 +199,9 @@ static int coherency_type(void)
 	return type;
 }
 
-/*
- * As a precaution, we currently completely disable hardware I/O
- * coherency, until enough testing is done with automatic I/O
- * synchronization barriers to validate that it is a proper solution.
- */
 int coherency_available(void)
 {
-	return false;
+	return coherency_type() != COHERENCY_FABRIC_TYPE_NONE;
 }
 
 int __init coherency_init(void)

commit 8f1e8ee28660018a935c7576b9af8ffe1feab54c
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Fri Jan 16 17:11:27 2015 +0100

    ARM: mvebu: completely disable hardware I/O coherency
    
    The current hardware I/O coherency is known to cause problems with DMA
    coherent buffers, as it still requires explicit I/O synchronization
    barriers, which is not compatible with the semantics expected by the
    Linux DMA coherent buffers API.
    
    So, in order to have enough time to validate a new solution based on
    automatic I/O synchronization barriers, this commit disables hardware
    I/O coherency entirely. Future patches will re-enable it.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: <stable@vger.kernel.org> # v3.8+
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 3585cb394e9b..caa21e9b8cd9 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -246,9 +246,14 @@ static int coherency_type(void)
 	return type;
 }
 
+/*
+ * As a precaution, we currently completely disable hardware I/O
+ * coherency, until enough testing is done with automatic I/O
+ * synchronization barriers to validate that it is a proper solution.
+ */
 int coherency_available(void)
 {
-	return coherency_type() != COHERENCY_FABRIC_TYPE_NONE;
+	return false;
 }
 
 int __init coherency_init(void)

commit 316fbbc400875c647c3a220c7525ffa8d2c80306
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Thu Oct 30 12:39:41 2014 +0100

    ARM: mvebu: Clean-up the Armada XP support
    
    This patch removes the unneeded include of the armada-370-xp.h header.
    
    It also moves some declarations from this file into more accurate
    places.
    
    Finally, it also adds a comment explaining that we can't remove yet the
    smp field in the dt machine struct due to backward compatibly of the
    device tree.
    
    In a few releases, when the old device tree will be obsolete, we will be
    able to remove the smp field and then the armada-370-xp.h header.
    
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Tested-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Reviewed-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1414669184-16785-2-git-send-email-gregory.clement@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index c18da36c75b1..3585cb394e9b 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -33,7 +33,6 @@
 #include <asm/smp_plat.h>
 #include <asm/cacheflush.h>
 #include <asm/mach/map.h>
-#include "armada-370-xp.h"
 #include "coherency.h"
 #include "mvebu-soc-id.h"
 

commit e12f12ac1a3245d0f5d751de63d20d8dded03fc3
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Thu Nov 13 10:39:00 2014 +0100

    ARM: mvebu: update comments in coherency.c
    
    The coherency.c top-level comment mentions that it supports the
    coherency fabric for Armada 370 and XP, but it also supports the
    coherency fabric on Armada 375 and 38x, so this commit updates the
    comment accordingly.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1415871540-20302-6-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index e568b2ef6830..c18da36c75b1 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -1,5 +1,6 @@
 /*
- * Coherency fabric (Aurora) support for Armada 370 and XP platforms.
+ * Coherency fabric (Aurora) support for Armada 370, 375, 38x and XP
+ * platforms.
  *
  * Copyright (C) 2012 Marvell
  *
@@ -11,7 +12,7 @@
  * License version 2.  This program is licensed "as is" without any
  * warranty of any kind, whether express or implied.
  *
- * The Armada 370 and Armada XP SOCs have a coherency fabric which is
+ * The Armada 370, 375, 38x and XP SOCs have a coherency fabric which is
  * responsible for ensuring hardware coherency between all CPUs and between
  * CPUs and I/O masters. This file initializes the coherency fabric and
  * supplies basic routines for configuring and controlling hardware coherency

commit ef01c6c36bb8d176e5f2302507fb1f688875d3ab
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Thu Nov 13 10:38:59 2014 +0100

    ARM: mvebu: remove Armada 375 Z1 workaround for I/O coherency
    
    This reverts commit 5ab5afd8ba83 ("ARM: mvebu: implement Armada 375
    coherency workaround"), since we are removing the support for the very
    early Z1 revision of the Armada 375 SoC.
    
    This commit is an exact revert, with two exceptions:
    
     - minor adaptations needed due to other changes that have taken place
       in coherency.c since the original commit
    
     - keep the definition of pr_fmt. This shouldn't originally have been
       part of the Armada 375 Z1 workaround commit since it had nothing to
       do with it.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1415871540-20302-5-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index db2f5bd280dd..e568b2ef6830 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -28,7 +28,6 @@
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/mbus.h>
-#include <linux/clk.h>
 #include <linux/pci.h>
 #include <asm/smp_plat.h>
 #include <asm/cacheflush.h>
@@ -77,157 +76,8 @@ int set_cpu_coherent(void)
 	return ll_enable_coherency();
 }
 
-/*
- * The below code implements the I/O coherency workaround on Armada
- * 375. This workaround consists in using the two channels of the
- * first XOR engine to trigger a XOR transaction that serves as the
- * I/O coherency barrier.
- */
-
-static void __iomem *xor_base, *xor_high_base;
-static dma_addr_t coherency_wa_buf_phys[CONFIG_NR_CPUS];
-static void *coherency_wa_buf[CONFIG_NR_CPUS];
-static bool coherency_wa_enabled;
-
-#define XOR_CONFIG(chan)            (0x10 + (chan * 4))
-#define XOR_ACTIVATION(chan)        (0x20 + (chan * 4))
-#define WINDOW_BAR_ENABLE(chan)     (0x240 + ((chan) << 2))
-#define WINDOW_BASE(w)              (0x250 + ((w) << 2))
-#define WINDOW_SIZE(w)              (0x270 + ((w) << 2))
-#define WINDOW_REMAP_HIGH(w)        (0x290 + ((w) << 2))
-#define WINDOW_OVERRIDE_CTRL(chan)  (0x2A0 + ((chan) << 2))
-#define XOR_DEST_POINTER(chan)      (0x2B0 + (chan * 4))
-#define XOR_BLOCK_SIZE(chan)        (0x2C0 + (chan * 4))
-#define XOR_INIT_VALUE_LOW           0x2E0
-#define XOR_INIT_VALUE_HIGH          0x2E4
-
-static inline void mvebu_hwcc_armada375_sync_io_barrier_wa(void)
-{
-	int idx = smp_processor_id();
-
-	/* Write '1' to the first word of the buffer */
-	writel(0x1, coherency_wa_buf[idx]);
-
-	/* Wait until the engine is idle */
-	while ((readl(xor_base + XOR_ACTIVATION(idx)) >> 4) & 0x3)
-		;
-
-	dmb();
-
-	/* Trigger channel */
-	writel(0x1, xor_base + XOR_ACTIVATION(idx));
-
-	/* Poll the data until it is cleared by the XOR transaction */
-	while (readl(coherency_wa_buf[idx]))
-		;
-}
-
-static void __init armada_375_coherency_init_wa(void)
-{
-	const struct mbus_dram_target_info *dram;
-	struct device_node *xor_node;
-	struct property *xor_status;
-	struct clk *xor_clk;
-	u32 win_enable = 0;
-	int i;
-
-	pr_warn("enabling coherency workaround for Armada 375 Z1, one XOR engine disabled\n");
-
-	/*
-	 * Since the workaround uses one XOR engine, we grab a
-	 * reference to its Device Tree node first.
-	 */
-	xor_node = of_find_compatible_node(NULL, NULL, "marvell,orion-xor");
-	BUG_ON(!xor_node);
-
-	/*
-	 * Then we mark it as disabled so that the real XOR driver
-	 * will not use it.
-	 */
-	xor_status = kzalloc(sizeof(struct property), GFP_KERNEL);
-	BUG_ON(!xor_status);
-
-	xor_status->value = kstrdup("disabled", GFP_KERNEL);
-	BUG_ON(!xor_status->value);
-
-	xor_status->length = 8;
-	xor_status->name = kstrdup("status", GFP_KERNEL);
-	BUG_ON(!xor_status->name);
-
-	of_update_property(xor_node, xor_status);
-
-	/*
-	 * And we remap the registers, get the clock, and do the
-	 * initial configuration of the XOR engine.
-	 */
-	xor_base = of_iomap(xor_node, 0);
-	xor_high_base = of_iomap(xor_node, 1);
-
-	xor_clk = of_clk_get_by_name(xor_node, NULL);
-	BUG_ON(!xor_clk);
-
-	clk_prepare_enable(xor_clk);
-
-	dram = mv_mbus_dram_info();
-
-	for (i = 0; i < 8; i++) {
-		writel(0, xor_base + WINDOW_BASE(i));
-		writel(0, xor_base + WINDOW_SIZE(i));
-		if (i < 4)
-			writel(0, xor_base + WINDOW_REMAP_HIGH(i));
-	}
-
-	for (i = 0; i < dram->num_cs; i++) {
-		const struct mbus_dram_window *cs = dram->cs + i;
-		writel((cs->base & 0xffff0000) |
-		       (cs->mbus_attr << 8) |
-		       dram->mbus_dram_target_id, xor_base + WINDOW_BASE(i));
-		writel((cs->size - 1) & 0xffff0000, xor_base + WINDOW_SIZE(i));
-
-		win_enable |= (1 << i);
-		win_enable |= 3 << (16 + (2 * i));
-	}
-
-	writel(win_enable, xor_base + WINDOW_BAR_ENABLE(0));
-	writel(win_enable, xor_base + WINDOW_BAR_ENABLE(1));
-	writel(0, xor_base + WINDOW_OVERRIDE_CTRL(0));
-	writel(0, xor_base + WINDOW_OVERRIDE_CTRL(1));
-
-	for (i = 0; i < CONFIG_NR_CPUS; i++) {
-		coherency_wa_buf[i] = kzalloc(PAGE_SIZE, GFP_KERNEL);
-		BUG_ON(!coherency_wa_buf[i]);
-
-		/*
-		 * We can't use the DMA mapping API, since we don't
-		 * have a valid 'struct device' pointer
-		 */
-		coherency_wa_buf_phys[i] =
-			virt_to_phys(coherency_wa_buf[i]);
-		BUG_ON(!coherency_wa_buf_phys[i]);
-
-		/*
-		 * Configure the XOR engine for memset operation, with
-		 * a 128 bytes block size
-		 */
-		writel(0x444, xor_base + XOR_CONFIG(i));
-		writel(128, xor_base + XOR_BLOCK_SIZE(i));
-		writel(coherency_wa_buf_phys[i],
-		       xor_base + XOR_DEST_POINTER(i));
-	}
-
-	writel(0x0, xor_base + XOR_INIT_VALUE_LOW);
-	writel(0x0, xor_base + XOR_INIT_VALUE_HIGH);
-
-	coherency_wa_enabled = true;
-}
-
 static inline void mvebu_hwcc_sync_io_barrier(void)
 {
-	if (coherency_wa_enabled) {
-		mvebu_hwcc_armada375_sync_io_barrier_wa();
-		return;
-	}
-
 	writel(0x1, coherency_cpu_base + IO_SYNC_BARRIER_CTL_OFFSET);
 	while (readl(coherency_cpu_base + IO_SYNC_BARRIER_CTL_OFFSET) & 0x1);
 }
@@ -421,22 +271,9 @@ int __init coherency_init(void)
 
 static int __init coherency_late_init(void)
 {
-	int type = coherency_type();
-
-	if (type == COHERENCY_FABRIC_TYPE_NONE)
-		return 0;
-
-	if (type == COHERENCY_FABRIC_TYPE_ARMADA_375) {
-		u32 dev, rev;
-
-		if (mvebu_get_soc_id(&dev, &rev) == 0 &&
-		    rev == ARMADA_375_Z1_REV)
-			armada_375_coherency_init_wa();
-	}
-
-	bus_register_notifier(&platform_bus_type,
-			      &mvebu_hwcc_nb);
-
+	if (coherency_available())
+		bus_register_notifier(&platform_bus_type,
+				      &mvebu_hwcc_nb);
 	return 0;
 }
 

commit 3b8509b5f2c14403d4bfaec56842ad0ed5389022
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Thu Nov 13 10:38:58 2014 +0100

    ARM: mvebu: remove unused register offset definition
    
    Since commit b21dcafea36d ("arm: mvebu: remove dependency of SMP init
    on static I/O mapping"), the COHERENCY_FABRIC_CFG_OFFSET register
    offset definition is no longer used, so this commit removes it.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1415871540-20302-4-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index c31f4c00b1fc..db2f5bd280dd 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -42,8 +42,6 @@ void __iomem *coherency_base;
 static void __iomem *coherency_cpu_base;
 
 /* Coherency fabric registers */
-#define COHERENCY_FABRIC_CFG_OFFSET		   0x4
-
 #define IO_SYNC_BARRIER_CTL_OFFSET		   0x0
 
 enum {

commit e55355453600a33bb5ca4f71f2d7214875f3b061
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Thu Nov 13 10:38:57 2014 +0100

    ARM: mvebu: disable I/O coherency on non-SMP situations on Armada 370/375/38x/XP
    
    Enabling the hardware I/O coherency on Armada 370, Armada 375, Armada
    38x and Armada XP requires a certain number of conditions:
    
     - On Armada 370, the cache policy must be set to write-allocate.
    
     - On Armada 375, 38x and XP, the cache policy must be set to
       write-allocate, the pages must be mapped with the shareable
       attribute, and the SMP bit must be set
    
    Currently, on Armada XP, when CONFIG_SMP is enabled, those conditions
    are met. However, when Armada XP is used in a !CONFIG_SMP kernel, none
    of these conditions are met. With Armada 370, the situation is worse:
    since the processor is single core, regardless of whether CONFIG_SMP
    or !CONFIG_SMP is used, the cache policy will be set to write-back by
    the kernel and not write-allocate.
    
    Since solving this problem turns out to be quite complicated, and we
    don't want to let users with a mainline kernel known to have
    infrequent but existing data corruptions, this commit proposes to
    simply disable hardware I/O coherency in situations where it is known
    not to work.
    
    And basically, the is_smp() function of the kernel tells us whether it
    is OK to enable hardware I/O coherency or not, so this commit slightly
    refactors the coherency_type() function to return
    COHERENCY_FABRIC_TYPE_NONE when is_smp() is false, or the appropriate
    type of the coherency fabric in the other case.
    
    Thanks to this, the I/O coherency fabric will no longer be used at all
    in !CONFIG_SMP configurations. It will continue to be used in
    CONFIG_SMP configurations on Armada XP, Armada 375 and Armada 38x
    (which are multiple cores processors), but will no longer be used on
    Armada 370 (which is a single core processor).
    
    In the process, it simplifies the implementation of the
    coherency_type() function, and adds a missing call to of_node_put().
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Fixes: e60304f8cb7bb545e79fe62d9b9762460c254ec2 ("arm: mvebu: Add hardware I/O Coherency support")
    Cc: <stable@vger.kernel.org> # v3.8+
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Link: https://lkml.kernel.org/r/1415871540-20302-3-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 044b51185fcc..c31f4c00b1fc 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -361,25 +361,41 @@ static int coherency_type(void)
 {
 	struct device_node *np;
 	const struct of_device_id *match;
+	int type;
 
-	np = of_find_matching_node_and_match(NULL, of_coherency_table, &match);
-	if (np) {
-		int type = (int) match->data;
+	/*
+	 * The coherency fabric is needed:
+	 * - For coherency between processors on Armada XP, so only
+	 *   when SMP is enabled.
+	 * - For coherency between the processor and I/O devices, but
+	 *   this coherency requires many pre-requisites (write
+	 *   allocate cache policy, shareable pages, SMP bit set) that
+	 *   are only meant in SMP situations.
+	 *
+	 * Note that this means that on Armada 370, there is currently
+	 * no way to use hardware I/O coherency, because even when
+	 * CONFIG_SMP is enabled, is_smp() returns false due to the
+	 * Armada 370 being a single-core processor. To lift this
+	 * limitation, we would have to find a way to make the cache
+	 * policy set to write-allocate (on all Armada SoCs), and to
+	 * set the shareable attribute in page tables (on all Armada
+	 * SoCs except the Armada 370). Unfortunately, such decisions
+	 * are taken very early in the kernel boot process, at a point
+	 * where we don't know yet on which SoC we are running.
 
-		/* Armada 370/XP coherency works in both UP and SMP */
-		if (type == COHERENCY_FABRIC_TYPE_ARMADA_370_XP)
-			return type;
+	 */
+	if (!is_smp())
+		return COHERENCY_FABRIC_TYPE_NONE;
 
-		/* Armada 375 coherency works only on SMP */
-		else if (type == COHERENCY_FABRIC_TYPE_ARMADA_375 && is_smp())
-			return type;
+	np = of_find_matching_node_and_match(NULL, of_coherency_table, &match);
+	if (!np)
+		return COHERENCY_FABRIC_TYPE_NONE;
 
-		/* Armada 380 coherency works only on SMP */
-		else if (type == COHERENCY_FABRIC_TYPE_ARMADA_380 && is_smp())
-			return type;
-	}
+	type = (int) match->data;
+
+	of_node_put(np);
 
-	return COHERENCY_FABRIC_TYPE_NONE;
+	return type;
 }
 
 int coherency_available(void)

commit 2eb04ae010a8fb165ba7aa56e9aa8e7980887dee
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon Oct 27 16:32:35 2014 +0100

    ARM: mvebu: add missing of_node_put() call in coherency.c
    
    There is a missing of_node_put() to decrement the device_node
    reference counter after a of_find_matching_node() in coherency_init().
    
    Fixes: 501f928e0097 ("ARM: mvebu: add a coherency_available() call")
    Cc: <stable@vger.kernel.org> # v3.16+
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Link: https://lkml.kernel.org/r/1414423955-5933-4-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 2bdc3233abe2..044b51185fcc 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -400,6 +400,8 @@ int __init coherency_init(void)
 		 type == COHERENCY_FABRIC_TYPE_ARMADA_380)
 		armada_375_380_coherency_init(np);
 
+	of_node_put(np);
+
 	return 0;
 }
 

commit a728b977429383b3fe92b6e3bff9e69365609e0f
Author: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
Date:   Tue Jul 8 10:37:37 2014 -0300

    ARM: mvebu: Fix coherency bus notifiers by using separate notifiers
    
    Currently, the coherency fabric support registers two bus notifiers;
    one for platform, one for pci bus types, with the same notifier block.
    However, this is illegal and can cause serious issues: the notifier
    block is also a link in the notifier list and cannot be inserted twice.
    
    This commit fixes this by using different notifier blocks (with the same
    notifier callback) to set the platform and pci bus types notifiers.
    
    Fixes: b0063aad5dd8 ("ARM: mvebu: use hardware I/O coherency also for PCI devices")
    Reported-by: Paolo Pisati <p.pisati@gmail.com>
    Signed-off-by: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Link: https://lkml.kernel.org/r/1404826657-6977-1-git-send-email-ezequiel.garcia@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 477202fd39cc..2bdc3233abe2 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -292,6 +292,10 @@ static struct notifier_block mvebu_hwcc_nb = {
 	.notifier_call = mvebu_hwcc_notifier,
 };
 
+static struct notifier_block mvebu_hwcc_pci_nb = {
+	.notifier_call = mvebu_hwcc_notifier,
+};
+
 static void __init armada_370_coherency_init(struct device_node *np)
 {
 	struct resource res;
@@ -427,7 +431,7 @@ static int __init coherency_pci_init(void)
 {
 	if (coherency_available())
 		bus_register_notifier(&pci_bus_type,
-				       &mvebu_hwcc_nb);
+				       &mvebu_hwcc_pci_nb);
 	return 0;
 }
 

commit 8828ccc3f2a8e32ddf1a0e1a80742e8482f18cea
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Tue May 20 17:13:03 2014 +0200

    ARM: mvebu: coherency: fix registration of PCI bus notifier when !PCI
    
    Commit b0063aad5dd8 ("ARM: mvebu: use hardware I/O coherency also for
    PCI devices") added a reference to the pci_bus_type variable, but this
    variable is only available when CONFIG_PCI is enabled. Therefore,
    there is now a build failure in !CONFIG_PCI situations.
    
    This commit fixes that by enclosing the entire initcall into a
    IS_ENABLED(CONFIG_PCI) condition.
    
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1400598783-706-1-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index a2225070ac3d..477202fd39cc 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -422,6 +422,7 @@ static int __init coherency_late_init(void)
 
 postcore_initcall(coherency_late_init);
 
+#if IS_ENABLED(CONFIG_PCI)
 static int __init coherency_pci_init(void)
 {
 	if (coherency_available())
@@ -431,3 +432,4 @@ static int __init coherency_pci_init(void)
 }
 
 arch_initcall(coherency_pci_init);
+#endif

commit 497a92308af8e9385fa3d135f7f416a997e4b93b
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Thu May 15 16:59:34 2014 +0200

    ARM: mvebu: implement L2/PCIe deadlock workaround
    
    The Marvell Armada 375 and Armada 38x SOCs, which use the Cortex-A9
    CPU core, the PL310 cache and the Marvell PCIe hardware block are
    affected a L2/PCIe deadlock caused by a system erratum when hardware
    I/O coherency is used.
    
    This deadlock can be avoided by mapping the PCIe memory areas as
    strongly-ordered (note: MT_UNCACHED is strongly-ordered), and by
    removing the outer cache sync done in software. This is implemented in
    this patch by:
    
     * Registering a custom arch_ioremap_caller function that allows to
       make sure PCI memory regions are mapped MT_UNCACHED.
    
     * Adding at runtime the 'arm,io-coherent' property to the PL310 cache
       controller. This cannot be done permanently in the DT, because the
       hardware I/O coherency can only be enabled when CONFIG_SMP is
       enabled, in the current kernel situation.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1400165974-9059-4-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 5723178f6589..a2225070ac3d 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -32,6 +32,7 @@
 #include <linux/pci.h>
 #include <asm/smp_plat.h>
 #include <asm/cacheflush.h>
+#include <asm/mach/map.h>
 #include "armada-370-xp.h"
 #include "coherency.h"
 #include "mvebu-soc-id.h"
@@ -309,9 +310,47 @@ static void __init armada_370_coherency_init(struct device_node *np)
 	set_cpu_coherent();
 }
 
+/*
+ * This ioremap hook is used on Armada 375/38x to ensure that PCIe
+ * memory areas are mapped as MT_UNCACHED instead of MT_DEVICE. This
+ * is needed as a workaround for a deadlock issue between the PCIe
+ * interface and the cache controller.
+ */
+static void __iomem *
+armada_pcie_wa_ioremap_caller(phys_addr_t phys_addr, size_t size,
+			      unsigned int mtype, void *caller)
+{
+	struct resource pcie_mem;
+
+	mvebu_mbus_get_pcie_mem_aperture(&pcie_mem);
+
+	if (pcie_mem.start <= phys_addr && (phys_addr + size) <= pcie_mem.end)
+		mtype = MT_UNCACHED;
+
+	return __arm_ioremap_caller(phys_addr, size, mtype, caller);
+}
+
 static void __init armada_375_380_coherency_init(struct device_node *np)
 {
+	struct device_node *cache_dn;
+
 	coherency_cpu_base = of_iomap(np, 0);
+	arch_ioremap_caller = armada_pcie_wa_ioremap_caller;
+
+	/*
+	 * Add the PL310 property "arm,io-coherent". This makes sure the
+	 * outer sync operation is not used, which allows to
+	 * workaround the system erratum that causes deadlocks when
+	 * doing PCIe in an SMP situation on Armada 375 and Armada
+	 * 38x.
+	 */
+	for_each_compatible_node(cache_dn, NULL, "arm,pl310-cache") {
+		struct property *p;
+
+		p = kzalloc(sizeof(*p), GFP_KERNEL);
+		p->name = kstrdup("arm,io-coherent", GFP_KERNEL);
+		of_add_property(cache_dn, p);
+	}
 }
 
 static int coherency_type(void)

commit b0063aad5dd86308c9b9c433ac8f3ab5b49aab1b
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Tue May 13 18:04:30 2014 +0200

    ARM: mvebu: use hardware I/O coherency also for PCI devices
    
    Since the beginning of the introduction of hardware I/O coherency
    support for Armada 370 and Armada XP, the special DMA operations
    should have applied to all DMA capable devices. Unfortunately, while
    the original code properly took into account platform devices, it
    didn't take into account PCI devices, which can also be DMA masters.
    
    This commit fixes that by registering a bus notifier on pci_bus_type,
    to register our custom DMA operations, like is already done for
    platform devices. While doing this, we also rename
    mvebu_hwcc_platform_notifier() to mvebu_hwcc_notifier() and
    mvebu_hwcc_platform_nb to mvebu_hwcc_nb because they are no longer
    specific to platform devices.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1399997070-11434-1-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index d5a975b6a590..5723178f6589 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -29,6 +29,7 @@
 #include <linux/slab.h>
 #include <linux/mbus.h>
 #include <linux/clk.h>
+#include <linux/pci.h>
 #include <asm/smp_plat.h>
 #include <asm/cacheflush.h>
 #include "armada-370-xp.h"
@@ -274,8 +275,8 @@ static struct dma_map_ops mvebu_hwcc_dma_ops = {
 	.set_dma_mask		= arm_dma_set_mask,
 };
 
-static int mvebu_hwcc_platform_notifier(struct notifier_block *nb,
-				       unsigned long event, void *__dev)
+static int mvebu_hwcc_notifier(struct notifier_block *nb,
+			       unsigned long event, void *__dev)
 {
 	struct device *dev = __dev;
 
@@ -286,8 +287,8 @@ static int mvebu_hwcc_platform_notifier(struct notifier_block *nb,
 	return NOTIFY_OK;
 }
 
-static struct notifier_block mvebu_hwcc_platform_nb = {
-	.notifier_call = mvebu_hwcc_platform_notifier,
+static struct notifier_block mvebu_hwcc_nb = {
+	.notifier_call = mvebu_hwcc_notifier,
 };
 
 static void __init armada_370_coherency_init(struct device_node *np)
@@ -375,9 +376,19 @@ static int __init coherency_late_init(void)
 	}
 
 	bus_register_notifier(&platform_bus_type,
-			      &mvebu_hwcc_platform_nb);
+			      &mvebu_hwcc_nb);
 
 	return 0;
 }
 
 postcore_initcall(coherency_late_init);
+
+static int __init coherency_pci_init(void)
+{
+	if (coherency_available())
+		bus_register_notifier(&pci_bus_type,
+				       &mvebu_hwcc_nb);
+	return 0;
+}
+
+arch_initcall(coherency_pci_init);

commit 39438567179536c9f32e85d19586a11aebe1f860
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon May 5 17:05:26 2014 +0200

    ARM: mvebu: conditionalize Armada 375 coherency workaround
    
    The Armada 375 coherency workaround only needs to be applied to the Z1
    revision of the SoC. The A0 and later revisions have been fixed, and
    no longer need this workaround.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1399302326-6917-6-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 9d5ccd372712..d5a975b6a590 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -33,6 +33,7 @@
 #include <asm/cacheflush.h>
 #include "armada-370-xp.h"
 #include "coherency.h"
+#include "mvebu-soc-id.h"
 
 unsigned long coherency_phys_base;
 void __iomem *coherency_base;
@@ -365,8 +366,13 @@ static int __init coherency_late_init(void)
 	if (type == COHERENCY_FABRIC_TYPE_NONE)
 		return 0;
 
-	if (type == COHERENCY_FABRIC_TYPE_ARMADA_375)
-		armada_375_coherency_init_wa();
+	if (type == COHERENCY_FABRIC_TYPE_ARMADA_375) {
+		u32 dev, rev;
+
+		if (mvebu_get_soc_id(&dev, &rev) == 0 &&
+		    rev == ARMADA_375_Z1_REV)
+			armada_375_coherency_init_wa();
+	}
 
 	bus_register_notifier(&platform_bus_type,
 			      &mvebu_hwcc_platform_nb);

commit 2e8a5942f8751c03fdd50228a02909654d13f01d
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Mon Apr 14 17:10:08 2014 +0200

    ARM: mvebu: Split low level functions to manipulate HW coherency
    
    Actually enabling coherency and adding a CPU on a SMP group are two
    different operations which can be done separately. This patch splits
    this in two functions.
    
    Moreover as they use common pattern, this patch also creates local low
    level functions (ll_get_coherency_base and ll_get_cpuid) to be used by
    the exposed functions (ll_add_cpu_to_smp_group and
    ll_enable_coherency)
    
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Link: https://lkml.kernel.org/r/1397488214-20685-6-git-send-email-gregory.clement@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 944372a18ed6..9d5ccd372712 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -60,8 +60,9 @@ static struct of_device_id of_coherency_table[] = {
 	{ /* end of list */ },
 };
 
-/* Function defined in coherency_ll.S */
-int ll_set_cpu_coherent(void);
+/* Functions defined in coherency_ll.S */
+int ll_enable_coherency(void);
+void ll_add_cpu_to_smp_group(void);
 
 int set_cpu_coherent(void)
 {
@@ -71,7 +72,8 @@ int set_cpu_coherent(void)
 		return 1;
 	}
 
-	return ll_set_cpu_coherent();
+	ll_add_cpu_to_smp_group();
+	return ll_enable_coherency();
 }
 
 /*

commit 952f4ca79b4ec7114291aa711add1b36c6ba7515
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Mon Apr 14 17:10:07 2014 +0200

    ARM: mvebu: Remove the unused argument of set_cpu_coherent()
    
    set_cpu_coherent() took the SMP group ID as parameter. But this
    parameter was never used, and the CPU always uses the SMP group 0. So
    we can remove this parameter.
    
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Link: https://lkml.kernel.org/r/1397488214-20685-5-git-send-email-gregory.clement@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 2df90c998820..944372a18ed6 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -63,7 +63,7 @@ static struct of_device_id of_coherency_table[] = {
 /* Function defined in coherency_ll.S */
 int ll_set_cpu_coherent(void);
 
-int set_cpu_coherent(int smp_group_id)
+int set_cpu_coherent(void)
 {
 	if (!coherency_base) {
 		pr_warn("Can't make current CPU cache coherent.\n");
@@ -302,7 +302,7 @@ static void __init armada_370_coherency_init(struct device_node *np)
 	sync_cache_w(&coherency_phys_base);
 	coherency_base = of_iomap(np, 0);
 	coherency_cpu_base = of_iomap(np, 1);
-	set_cpu_coherent(0);
+	set_cpu_coherent();
 }
 
 static void __init armada_375_380_coherency_init(struct device_node *np)

commit b41375f71aceadb7d74a18aafba4da5024fc104b
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Mon Apr 14 17:10:06 2014 +0200

    ARM: mvebu: ll_set_cpu_coherent always uses the current CPU
    
    ll_set_cpu_coherent is always used on the current CPU, so instead of
    passing the CPU id as argument, ll_set_cpu_coherent() can find it by
    itself.
    
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Link: https://lkml.kernel.org/r/1397488214-20685-4-git-send-email-gregory.clement@free-electrons.com
    Acked-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 615dc0b6093e..2df90c998820 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -61,17 +61,17 @@ static struct of_device_id of_coherency_table[] = {
 };
 
 /* Function defined in coherency_ll.S */
-int ll_set_cpu_coherent(unsigned int hw_cpu_id);
+int ll_set_cpu_coherent(void);
 
-int set_cpu_coherent(unsigned int hw_cpu_id, int smp_group_id)
+int set_cpu_coherent(int smp_group_id)
 {
 	if (!coherency_base) {
-		pr_warn("Can't make CPU %d cache coherent.\n", hw_cpu_id);
+		pr_warn("Can't make current CPU cache coherent.\n");
 		pr_warn("Coherency fabric is not initialized\n");
 		return 1;
 	}
 
-	return ll_set_cpu_coherent(hw_cpu_id);
+	return ll_set_cpu_coherent();
 }
 
 /*
@@ -302,7 +302,7 @@ static void __init armada_370_coherency_init(struct device_node *np)
 	sync_cache_w(&coherency_phys_base);
 	coherency_base = of_iomap(np, 0);
 	coherency_cpu_base = of_iomap(np, 1);
-	set_cpu_coherent(cpu_logical_map(smp_processor_id()), 0);
+	set_cpu_coherent(0);
 }
 
 static void __init armada_375_380_coherency_init(struct device_node *np)
@@ -330,8 +330,6 @@ static int coherency_type(void)
 		/* Armada 380 coherency works only on SMP */
 		else if (type == COHERENCY_FABRIC_TYPE_ARMADA_380 && is_smp())
 			return type;
-
-		of_node_put(np);
 	}
 
 	return COHERENCY_FABRIC_TYPE_NONE;

commit ccd6a13180193700067bfdac5f7d7b436d757382
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Mon Apr 14 17:10:05 2014 +0200

    ARM: mvebu: remove the address parameter for ll_set_cpu_coherent
    
    In order to be able to deal with the MMU enabled and the MMU disabled
    cases, the base address of the coherency registers was passed to the
    function. The address by itself was not interesting as it can't change
    for a given SoC, the only thing we need is to have a distinction
    between the physical or the virtual address.
    
    This patch add a check of the MMU bit to choose the accurate address,
    then the calling function doesn't have to pass this information.
    
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Link: https://lkml.kernel.org/r/1397488214-20685-3-git-send-email-gregory.clement@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 489edd157cfb..615dc0b6093e 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -35,7 +35,7 @@
 #include "coherency.h"
 
 unsigned long coherency_phys_base;
-static void __iomem *coherency_base;
+void __iomem *coherency_base;
 static void __iomem *coherency_cpu_base;
 
 /* Coherency fabric registers */
@@ -61,7 +61,7 @@ static struct of_device_id of_coherency_table[] = {
 };
 
 /* Function defined in coherency_ll.S */
-int ll_set_cpu_coherent(void __iomem *base_addr, unsigned int hw_cpu_id);
+int ll_set_cpu_coherent(unsigned int hw_cpu_id);
 
 int set_cpu_coherent(unsigned int hw_cpu_id, int smp_group_id)
 {
@@ -71,7 +71,7 @@ int set_cpu_coherent(unsigned int hw_cpu_id, int smp_group_id)
 		return 1;
 	}
 
-	return ll_set_cpu_coherent(coherency_base, hw_cpu_id);
+	return ll_set_cpu_coherent(hw_cpu_id);
 }
 
 /*

commit d0de9323822fada543f2f244eb67f520aa21ed77
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon Apr 14 15:47:06 2014 +0200

    ARM: mvebu: add Armada 38x support to the coherency code
    
    The Armada 38x has a coherency unit that is similar to the one of the
    Armada 375 SoC, except that it does not have the bug of the Armada 375
    coherency unit that requires the XOR based workaround.
    
    This commit therefore extends the Marvell EBU coherency code with a
    new compatible string to support the Armada 38x coherency unit.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1397483228-25625-9-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 75db33ef93ee..489edd157cfb 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -47,6 +47,7 @@ enum {
 	COHERENCY_FABRIC_TYPE_NONE,
 	COHERENCY_FABRIC_TYPE_ARMADA_370_XP,
 	COHERENCY_FABRIC_TYPE_ARMADA_375,
+	COHERENCY_FABRIC_TYPE_ARMADA_380,
 };
 
 static struct of_device_id of_coherency_table[] = {
@@ -54,6 +55,8 @@ static struct of_device_id of_coherency_table[] = {
 	 .data = (void *) COHERENCY_FABRIC_TYPE_ARMADA_370_XP },
 	{.compatible = "marvell,armada-375-coherency-fabric",
 	 .data = (void *) COHERENCY_FABRIC_TYPE_ARMADA_375 },
+	{.compatible = "marvell,armada-380-coherency-fabric",
+	 .data = (void *) COHERENCY_FABRIC_TYPE_ARMADA_380 },
 	{ /* end of list */ },
 };
 
@@ -302,7 +305,7 @@ static void __init armada_370_coherency_init(struct device_node *np)
 	set_cpu_coherent(cpu_logical_map(smp_processor_id()), 0);
 }
 
-static void __init armada_375_coherency_init(struct device_node *np)
+static void __init armada_375_380_coherency_init(struct device_node *np)
 {
 	coherency_cpu_base = of_iomap(np, 0);
 }
@@ -324,6 +327,10 @@ static int coherency_type(void)
 		else if (type == COHERENCY_FABRIC_TYPE_ARMADA_375 && is_smp())
 			return type;
 
+		/* Armada 380 coherency works only on SMP */
+		else if (type == COHERENCY_FABRIC_TYPE_ARMADA_380 && is_smp())
+			return type;
+
 		of_node_put(np);
 	}
 
@@ -344,8 +351,9 @@ int __init coherency_init(void)
 
 	if (type == COHERENCY_FABRIC_TYPE_ARMADA_370_XP)
 		armada_370_coherency_init(np);
-	else if (type == COHERENCY_FABRIC_TYPE_ARMADA_375)
-		armada_375_coherency_init(np);
+	else if (type == COHERENCY_FABRIC_TYPE_ARMADA_375 ||
+		 type == COHERENCY_FABRIC_TYPE_ARMADA_380)
+		armada_375_380_coherency_init(np);
 
 	return 0;
 }

commit 5ab5afd8ba837560f76f8ee527271d2e819bcaef
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon Apr 14 15:47:05 2014 +0200

    ARM: mvebu: implement Armada 375 coherency workaround
    
    The early revisions of Armada 375 SOCs (Z1 stepping) have a bug in the
    I/O coherency unit that prevents using the normal method for the I/O
    coherency barrier. The recommended workaround is to use a XOR memset
    transfer to act as the I/O coherency barrier.
    
    This involves "borrowing" a XOR engine, which gets disabled in the
    Device Tree so the normal XOR driver doesn't use it.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1397483228-25625-8-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 7ccaf87fd772..75db33ef93ee 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -17,6 +17,8 @@
  * supplies basic routines for configuring and controlling hardware coherency
  */
 
+#define pr_fmt(fmt) "mvebu-coherency: " fmt
+
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/of_address.h>
@@ -24,6 +26,9 @@
 #include <linux/smp.h>
 #include <linux/dma-mapping.h>
 #include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/mbus.h>
+#include <linux/clk.h>
 #include <asm/smp_plat.h>
 #include <asm/cacheflush.h>
 #include "armada-370-xp.h"
@@ -66,8 +71,157 @@ int set_cpu_coherent(unsigned int hw_cpu_id, int smp_group_id)
 	return ll_set_cpu_coherent(coherency_base, hw_cpu_id);
 }
 
+/*
+ * The below code implements the I/O coherency workaround on Armada
+ * 375. This workaround consists in using the two channels of the
+ * first XOR engine to trigger a XOR transaction that serves as the
+ * I/O coherency barrier.
+ */
+
+static void __iomem *xor_base, *xor_high_base;
+static dma_addr_t coherency_wa_buf_phys[CONFIG_NR_CPUS];
+static void *coherency_wa_buf[CONFIG_NR_CPUS];
+static bool coherency_wa_enabled;
+
+#define XOR_CONFIG(chan)            (0x10 + (chan * 4))
+#define XOR_ACTIVATION(chan)        (0x20 + (chan * 4))
+#define WINDOW_BAR_ENABLE(chan)     (0x240 + ((chan) << 2))
+#define WINDOW_BASE(w)              (0x250 + ((w) << 2))
+#define WINDOW_SIZE(w)              (0x270 + ((w) << 2))
+#define WINDOW_REMAP_HIGH(w)        (0x290 + ((w) << 2))
+#define WINDOW_OVERRIDE_CTRL(chan)  (0x2A0 + ((chan) << 2))
+#define XOR_DEST_POINTER(chan)      (0x2B0 + (chan * 4))
+#define XOR_BLOCK_SIZE(chan)        (0x2C0 + (chan * 4))
+#define XOR_INIT_VALUE_LOW           0x2E0
+#define XOR_INIT_VALUE_HIGH          0x2E4
+
+static inline void mvebu_hwcc_armada375_sync_io_barrier_wa(void)
+{
+	int idx = smp_processor_id();
+
+	/* Write '1' to the first word of the buffer */
+	writel(0x1, coherency_wa_buf[idx]);
+
+	/* Wait until the engine is idle */
+	while ((readl(xor_base + XOR_ACTIVATION(idx)) >> 4) & 0x3)
+		;
+
+	dmb();
+
+	/* Trigger channel */
+	writel(0x1, xor_base + XOR_ACTIVATION(idx));
+
+	/* Poll the data until it is cleared by the XOR transaction */
+	while (readl(coherency_wa_buf[idx]))
+		;
+}
+
+static void __init armada_375_coherency_init_wa(void)
+{
+	const struct mbus_dram_target_info *dram;
+	struct device_node *xor_node;
+	struct property *xor_status;
+	struct clk *xor_clk;
+	u32 win_enable = 0;
+	int i;
+
+	pr_warn("enabling coherency workaround for Armada 375 Z1, one XOR engine disabled\n");
+
+	/*
+	 * Since the workaround uses one XOR engine, we grab a
+	 * reference to its Device Tree node first.
+	 */
+	xor_node = of_find_compatible_node(NULL, NULL, "marvell,orion-xor");
+	BUG_ON(!xor_node);
+
+	/*
+	 * Then we mark it as disabled so that the real XOR driver
+	 * will not use it.
+	 */
+	xor_status = kzalloc(sizeof(struct property), GFP_KERNEL);
+	BUG_ON(!xor_status);
+
+	xor_status->value = kstrdup("disabled", GFP_KERNEL);
+	BUG_ON(!xor_status->value);
+
+	xor_status->length = 8;
+	xor_status->name = kstrdup("status", GFP_KERNEL);
+	BUG_ON(!xor_status->name);
+
+	of_update_property(xor_node, xor_status);
+
+	/*
+	 * And we remap the registers, get the clock, and do the
+	 * initial configuration of the XOR engine.
+	 */
+	xor_base = of_iomap(xor_node, 0);
+	xor_high_base = of_iomap(xor_node, 1);
+
+	xor_clk = of_clk_get_by_name(xor_node, NULL);
+	BUG_ON(!xor_clk);
+
+	clk_prepare_enable(xor_clk);
+
+	dram = mv_mbus_dram_info();
+
+	for (i = 0; i < 8; i++) {
+		writel(0, xor_base + WINDOW_BASE(i));
+		writel(0, xor_base + WINDOW_SIZE(i));
+		if (i < 4)
+			writel(0, xor_base + WINDOW_REMAP_HIGH(i));
+	}
+
+	for (i = 0; i < dram->num_cs; i++) {
+		const struct mbus_dram_window *cs = dram->cs + i;
+		writel((cs->base & 0xffff0000) |
+		       (cs->mbus_attr << 8) |
+		       dram->mbus_dram_target_id, xor_base + WINDOW_BASE(i));
+		writel((cs->size - 1) & 0xffff0000, xor_base + WINDOW_SIZE(i));
+
+		win_enable |= (1 << i);
+		win_enable |= 3 << (16 + (2 * i));
+	}
+
+	writel(win_enable, xor_base + WINDOW_BAR_ENABLE(0));
+	writel(win_enable, xor_base + WINDOW_BAR_ENABLE(1));
+	writel(0, xor_base + WINDOW_OVERRIDE_CTRL(0));
+	writel(0, xor_base + WINDOW_OVERRIDE_CTRL(1));
+
+	for (i = 0; i < CONFIG_NR_CPUS; i++) {
+		coherency_wa_buf[i] = kzalloc(PAGE_SIZE, GFP_KERNEL);
+		BUG_ON(!coherency_wa_buf[i]);
+
+		/*
+		 * We can't use the DMA mapping API, since we don't
+		 * have a valid 'struct device' pointer
+		 */
+		coherency_wa_buf_phys[i] =
+			virt_to_phys(coherency_wa_buf[i]);
+		BUG_ON(!coherency_wa_buf_phys[i]);
+
+		/*
+		 * Configure the XOR engine for memset operation, with
+		 * a 128 bytes block size
+		 */
+		writel(0x444, xor_base + XOR_CONFIG(i));
+		writel(128, xor_base + XOR_BLOCK_SIZE(i));
+		writel(coherency_wa_buf_phys[i],
+		       xor_base + XOR_DEST_POINTER(i));
+	}
+
+	writel(0x0, xor_base + XOR_INIT_VALUE_LOW);
+	writel(0x0, xor_base + XOR_INIT_VALUE_HIGH);
+
+	coherency_wa_enabled = true;
+}
+
 static inline void mvebu_hwcc_sync_io_barrier(void)
 {
+	if (coherency_wa_enabled) {
+		mvebu_hwcc_armada375_sync_io_barrier_wa();
+		return;
+	}
+
 	writel(0x1, coherency_cpu_base + IO_SYNC_BARRIER_CTL_OFFSET);
 	while (readl(coherency_cpu_base + IO_SYNC_BARRIER_CTL_OFFSET) & 0x1);
 }
@@ -198,9 +352,17 @@ int __init coherency_init(void)
 
 static int __init coherency_late_init(void)
 {
-	if (coherency_available())
-		bus_register_notifier(&platform_bus_type,
-				      &mvebu_hwcc_platform_nb);
+	int type = coherency_type();
+
+	if (type == COHERENCY_FABRIC_TYPE_NONE)
+		return 0;
+
+	if (type == COHERENCY_FABRIC_TYPE_ARMADA_375)
+		armada_375_coherency_init_wa();
+
+	bus_register_notifier(&platform_bus_type,
+			      &mvebu_hwcc_platform_nb);
+
 	return 0;
 }
 

commit 77fa4b9ab0aafc0a06976814ad62aeff990dfd2c
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon Apr 14 15:47:04 2014 +0200

    ARM: mvebu: add Armada 375 support to the coherency code
    
    The Armada 375, like the Armada 370 and Armada XP, has a coherency
    unit. However, unlike the coherency unit of 370/XP which does both CPU
    and I/O coherency, the one on Armada 735 only does I/O
    coherency. Therefore, instead of having two sets of registers (the
    first one being used mainly to register each CPU in the coherency
    fabric, the second one being used for the I/O coherency barrier), it
    has only one set of register (for the I/O coherency barrier).
    
    This commit adds a new "marvell,armada-375-coherency-fabric"
    compatible string for this variant of the coherency fabric. The custom
    DMA operations, and the way of triggering an I/O barrier is the same
    as Armada 370/XP, so the code changes are minimal. However, the
    set_cpu_coherent() function is not needed on Armada 375 and will not
    work.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1397483228-25625-7-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 862100f7c836..7ccaf87fd772 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -41,11 +41,14 @@ static void __iomem *coherency_cpu_base;
 enum {
 	COHERENCY_FABRIC_TYPE_NONE,
 	COHERENCY_FABRIC_TYPE_ARMADA_370_XP,
+	COHERENCY_FABRIC_TYPE_ARMADA_375,
 };
 
 static struct of_device_id of_coherency_table[] = {
 	{.compatible = "marvell,coherency-fabric",
 	 .data = (void *) COHERENCY_FABRIC_TYPE_ARMADA_370_XP },
+	{.compatible = "marvell,armada-375-coherency-fabric",
+	 .data = (void *) COHERENCY_FABRIC_TYPE_ARMADA_375 },
 	{ /* end of list */ },
 };
 
@@ -145,6 +148,11 @@ static void __init armada_370_coherency_init(struct device_node *np)
 	set_cpu_coherent(cpu_logical_map(smp_processor_id()), 0);
 }
 
+static void __init armada_375_coherency_init(struct device_node *np)
+{
+	coherency_cpu_base = of_iomap(np, 0);
+}
+
 static int coherency_type(void)
 {
 	struct device_node *np;
@@ -158,6 +166,10 @@ static int coherency_type(void)
 		if (type == COHERENCY_FABRIC_TYPE_ARMADA_370_XP)
 			return type;
 
+		/* Armada 375 coherency works only on SMP */
+		else if (type == COHERENCY_FABRIC_TYPE_ARMADA_375 && is_smp())
+			return type;
+
 		of_node_put(np);
 	}
 
@@ -178,6 +190,8 @@ int __init coherency_init(void)
 
 	if (type == COHERENCY_FABRIC_TYPE_ARMADA_370_XP)
 		armada_370_coherency_init(np);
+	else if (type == COHERENCY_FABRIC_TYPE_ARMADA_375)
+		armada_375_coherency_init(np);
 
 	return 0;
 }

commit 5fbba0805165a4883c60cf159f272dd0d7205c44
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon Apr 14 15:47:02 2014 +0200

    ARM: mvebu: ARM: mvebu: use of_find_matching_node_and_match() in coherency.c
    
    In the mach-mvebu coherency code, instead of using
    of_find_matching_node() and then of_match_node(), directly use the
    of_find_matching_node_and_match() which does both at once.
    
    We take this opportunity to also simplify the initialization of the
    "type" variable.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1397483228-25625-5-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 296cf14f08a4..862100f7c836 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -148,14 +148,11 @@ static void __init armada_370_coherency_init(struct device_node *np)
 static int coherency_type(void)
 {
 	struct device_node *np;
+	const struct of_device_id *match;
 
-	np = of_find_matching_node(NULL, of_coherency_table);
+	np = of_find_matching_node_and_match(NULL, of_coherency_table, &match);
 	if (np) {
-		const struct of_device_id *match =
-			of_match_node(of_coherency_table, np);
-		int type;
-
-		type = (int) match->data;
+		int type = (int) match->data;
 
 		/* Armada 370/XP coherency works in both UP and SMP */
 		if (type == COHERENCY_FABRIC_TYPE_ARMADA_370_XP)

commit 501f928e009760f4987d4630265bb9fff28a6ecc
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon Apr 14 15:47:00 2014 +0200

    ARM: mvebu: add a coherency_available() call
    
    This commit extends the coherency fabric code to provide a
    coherency_available()function that the SoC code can call to be told
    whether coherency support is available or not. On Armada 370/XP,
    coherency support is available as soon as the relevant DT node is
    present. On some upcoming SoCs, the DT node needs to be present *and*
    the system running with CONFIG_SMP enabled.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1397483228-25625-3-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 434cf5f90a80..296cf14f08a4 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -39,6 +39,7 @@ static void __iomem *coherency_cpu_base;
 #define IO_SYNC_BARRIER_CTL_OFFSET		   0x0
 
 enum {
+	COHERENCY_FABRIC_TYPE_NONE,
 	COHERENCY_FABRIC_TYPE_ARMADA_370_XP,
 };
 
@@ -144,7 +145,7 @@ static void __init armada_370_coherency_init(struct device_node *np)
 	set_cpu_coherent(cpu_logical_map(smp_processor_id()), 0);
 }
 
-int __init coherency_init(void)
+static int coherency_type(void)
 {
 	struct device_node *np;
 
@@ -155,27 +156,40 @@ int __init coherency_init(void)
 		int type;
 
 		type = (int) match->data;
-		pr_info("Initializing Coherency fabric\n");
 
+		/* Armada 370/XP coherency works in both UP and SMP */
 		if (type == COHERENCY_FABRIC_TYPE_ARMADA_370_XP)
-			armada_370_coherency_init(np);
+			return type;
 
 		of_node_put(np);
 	}
 
-	return 0;
+	return COHERENCY_FABRIC_TYPE_NONE;
 }
 
-static int __init coherency_late_init(void)
+int coherency_available(void)
 {
+	return coherency_type() != COHERENCY_FABRIC_TYPE_NONE;
+}
+
+int __init coherency_init(void)
+{
+	int type = coherency_type();
 	struct device_node *np;
 
 	np = of_find_matching_node(NULL, of_coherency_table);
-	if (np) {
+
+	if (type == COHERENCY_FABRIC_TYPE_ARMADA_370_XP)
+		armada_370_coherency_init(np);
+
+	return 0;
+}
+
+static int __init coherency_late_init(void)
+{
+	if (coherency_available())
 		bus_register_notifier(&platform_bus_type,
 				      &mvebu_hwcc_platform_nb);
-		of_node_put(np);
-	}
 	return 0;
 }
 

commit 924d38f404936495b59ef7fa3ff232d978d64b18
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon Apr 14 15:46:59 2014 +0200

    ARM: mvebu: prepare coherency code to support more SOCs
    
    The code that handles the coherency fabric of Armada 370 and Armada XP
    in arch/arm/mach-mvebu/coherency.c made the assumption that there was
    only one type of coherency fabric. Unfortunately, it turns out that
    upcoming SoCs have a slightly different coherency unit.
    
    In preparation to the introduction of the coherency support for more
    SoCs, this commit:
    
     * Introduces a data associated to the compatible string in the
       compatible string match table, so that the code can differantiate
       the variant of coherency unit being used.
    
     * Separates the coherency unit initialization code into its own
       function.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1397483228-25625-2-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 4e9d58148ca7..434cf5f90a80 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -38,8 +38,13 @@ static void __iomem *coherency_cpu_base;
 
 #define IO_SYNC_BARRIER_CTL_OFFSET		   0x0
 
+enum {
+	COHERENCY_FABRIC_TYPE_ARMADA_370_XP,
+};
+
 static struct of_device_id of_coherency_table[] = {
-	{.compatible = "marvell,coherency-fabric"},
+	{.compatible = "marvell,coherency-fabric",
+	 .data = (void *) COHERENCY_FABRIC_TYPE_ARMADA_370_XP },
 	{ /* end of list */ },
 };
 
@@ -121,26 +126,40 @@ static struct notifier_block mvebu_hwcc_platform_nb = {
 	.notifier_call = mvebu_hwcc_platform_notifier,
 };
 
+static void __init armada_370_coherency_init(struct device_node *np)
+{
+	struct resource res;
+
+	of_address_to_resource(np, 0, &res);
+	coherency_phys_base = res.start;
+	/*
+	 * Ensure secondary CPUs will see the updated value,
+	 * which they read before they join the coherency
+	 * fabric, and therefore before they are coherent with
+	 * the boot CPU cache.
+	 */
+	sync_cache_w(&coherency_phys_base);
+	coherency_base = of_iomap(np, 0);
+	coherency_cpu_base = of_iomap(np, 1);
+	set_cpu_coherent(cpu_logical_map(smp_processor_id()), 0);
+}
+
 int __init coherency_init(void)
 {
 	struct device_node *np;
 
 	np = of_find_matching_node(NULL, of_coherency_table);
 	if (np) {
-		struct resource res;
+		const struct of_device_id *match =
+			of_match_node(of_coherency_table, np);
+		int type;
+
+		type = (int) match->data;
 		pr_info("Initializing Coherency fabric\n");
-		of_address_to_resource(np, 0, &res);
-		coherency_phys_base = res.start;
-		/*
-		 * Ensure secondary CPUs will see the updated value,
-		 * which they read before they join the coherency
-		 * fabric, and therefore before they are coherent with
-		 * the boot CPU cache.
-		 */
-		sync_cache_w(&coherency_phys_base);
-		coherency_base = of_iomap(np, 0);
-		coherency_cpu_base = of_iomap(np, 1);
-		set_cpu_coherent(cpu_logical_map(smp_processor_id()), 0);
+
+		if (type == COHERENCY_FABRIC_TYPE_ARMADA_370_XP)
+			armada_370_coherency_init(np);
+
 		of_node_put(np);
 	}
 

commit b12634e343bea9ce94ed3252fccbac347f8bb37f
Author: Jisheng Zhang <jszhang@marvell.com>
Date:   Thu Nov 7 17:02:38 2013 +0800

    ARM: mvebu: fix some sparse warnings
    
    This patch fixes conflicting types for 'set_cpu_coherent' and fixes the
    following sparse warnings.
    
    arch/arm/mach-mvebu/system-controller.c:42:38:
    warning: symbol 'armada_370_xp_system_controller' was not declared. Should it be static?
    arch/arm/mach-mvebu/system-controller.c:49:38:
    warning: symbol 'orion_system_controller' was not declared. Should it be static?
    arch/arm/mach-mvebu/system-controller.c:67:6:
    warning: symbol 'mvebu_restart' was not declared. Should it be static?
    arch/arm/mach-mvebu/coherency.c:31:15:
    warning: symbol 'coherency_phys_base' was not declared. Should it be static?
    arch/arm/mach-mvebu/coherency.c:48:5:
    warning: symbol 'set_cpu_coherent' was not declared. Should it be static?
    arch/arm/mach-mvebu/coherency.c:123:12:
    warning: symbol 'coherency_init' was not declared. Should it be static?
    arch/arm/mach-mvebu/pmsu.c:38:5: warning:
    symbol 'armada_xp_boot_cpu' was not declared. Should it be static?
    arch/arm/mach-mvebu/pmsu.c:61:12: warning:
    symbol 'armada_370_xp_pmsu_init' was not declared. Should it be static?
    arch/arm/mach-mvebu/platsmp.c:49:13: warning:
    symbol 'set_secondary_cpus_clock' was not declared. Should it be static?
    arch/arm/mach-mvebu/platsmp.c:97:13: warning:
    symbol 'armada_xp_smp_prepare_cpus' was not declared. Should it be static?
    arch/arm/mach-mvebu/hotplug.c:24:12: warning:
    symbol 'armada_xp_cpu_die' was not declared. Should it be static?
    
    Signed-off-by: Jisheng Zhang <jszhang@marvell.com>
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 58adf2fd9cfc..4e9d58148ca7 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -27,6 +27,7 @@
 #include <asm/smp_plat.h>
 #include <asm/cacheflush.h>
 #include "armada-370-xp.h"
+#include "coherency.h"
 
 unsigned long coherency_phys_base;
 static void __iomem *coherency_base;

commit abe511ac85de60f6d6ce1272b91c079d73bf8517
Author: Jisheng Zhang <jszhang@marvell.com>
Date:   Tue Aug 27 12:41:14 2013 +0800

    ARM: mvebu: add missing of_node_put() to fix reference leak
    
    Add of_node_put to properly decrement the refcount when we are
    done using a given node.
    
    Signed-off-by: Jisheng Zhang <jszhang@marvell.com>
    Reviewed-by: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    
    Conflicts:
            arch/arm/mach-mvebu/armada-370-xp.c
            arch/arm/mach-mvebu/platsmp.c

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 4c24303ec481..58adf2fd9cfc 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -140,6 +140,7 @@ int __init coherency_init(void)
 		coherency_base = of_iomap(np, 0);
 		coherency_cpu_base = of_iomap(np, 1);
 		set_cpu_coherent(cpu_logical_map(smp_processor_id()), 0);
+		of_node_put(np);
 	}
 
 	return 0;
@@ -147,9 +148,14 @@ int __init coherency_init(void)
 
 static int __init coherency_late_init(void)
 {
-	if (of_find_matching_node(NULL, of_coherency_table))
+	struct device_node *np;
+
+	np = of_find_matching_node(NULL, of_coherency_table);
+	if (np) {
 		bus_register_notifier(&platform_bus_type,
 				      &mvebu_hwcc_platform_nb);
+		of_node_put(np);
+	}
 	return 0;
 }
 

commit 8bd26e3a7e49af2697449bbcb7187a39dc85d672
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jun 17 15:43:14 2013 -0400

    arm: delete __cpuinit/__CPUINIT usage from all ARM users
    
    The __cpuinit type of throwaway sections might have made sense
    some time ago when RAM was more constrained, but now the savings
    do not offset the cost and complications.  For example, the fix in
    commit 5e427ec2d0 ("x86: Fix bit corruption at CPU resume time")
    is a good example of the nasty type of bugs that can be created
    with improper use of the various __init prefixes.
    
    After a discussion on LKML[1] it was decided that cpuinit should go
    the way of devinit and be phased out.  Once all the users are gone,
    we can then finally remove the macros themselves from linux/init.h.
    
    Note that some harmless section mismatch warnings may result, since
    notify_cpu_starting() and cpu_up() are arch independent (kernel/cpu.c)
    and are flagged as __cpuinit  -- so if we remove the __cpuinit from
    the arch specific callers, we will also get section mismatch warnings.
    As an intermediate step, we intend to turn the linux/init.h cpuinit
    related content into no-ops as early as possible, since that will get
    rid of these warnings.  In any case, they are temporary and harmless.
    
    This removes all the ARM uses of the __cpuinit macros from C code,
    and all __CPUINIT from assembly code.  It also had two ".previous"
    section statements that were paired off against __CPUINIT
    (aka .section ".cpuinit.text") that also get removed here.
    
    [1] https://lkml.org/lkml/2013/5/20/589
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index be117591f7f2..4c24303ec481 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -28,7 +28,7 @@
 #include <asm/cacheflush.h>
 #include "armada-370-xp.h"
 
-unsigned long __cpuinitdata coherency_phys_base;
+unsigned long coherency_phys_base;
 static void __iomem *coherency_base;
 static void __iomem *coherency_cpu_base;
 

commit 1919bff0e25f5f7ce43474a3b972405f51023e99
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Thu Jun 20 09:45:26 2013 +0200

    arm: mvebu: fix coherency_late_init() for multiplatform
    
    As noticed by Arnaud Patard (Rtp) <arnaud.patard@rtp-net.org>, commit
    865e0527d2d7 ('arm: mvebu: avoid hardcoded virtual address in
    coherency code') added a postcore_initcall() to register the bus
    notifier that the mvebu code needs to apply correct DMA operations on
    its platform devices breaks the multiplatform boot on other platforms,
    because the bus notifier registration is unconditional.
    
    This commit fixes that by registering the bus notifier only if we have
    the mvebu coherency unit described in the Device Tree. The conditional
    used is exactly the same in which the bus_register_notifier() call was
    originally enclosed before 865e0527d2d7 ('arm: mvebu: avoid hardcoded
    virtual address in coherency code').
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Reported-by: Arnaud Patard (Rtp) <arnaud.patard@rtp-net.org>
    Acked-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 32fcf69f4202..be117591f7f2 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -147,8 +147,9 @@ int __init coherency_init(void)
 
 static int __init coherency_late_init(void)
 {
-	bus_register_notifier(&platform_bus_type,
-			      &mvebu_hwcc_platform_nb);
+	if (of_find_matching_node(NULL, of_coherency_table))
+		bus_register_notifier(&platform_bus_type,
+				      &mvebu_hwcc_platform_nb);
 	return 0;
 }
 

commit 580ff0eea15c341d17d564f7e5c519df37033d8e
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Thu Jun 6 12:24:28 2013 +0200

    arm: mvebu: don't hardcode a physical address in headsmp.S
    
    Now that the coherency_init() function is called a bit earlier, we can
    actually read the physical address of the coherency unit registers
    from the Device Tree, and communicate that to the headsmp.S code,
    which avoids hardcoding a physical address.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index d74794a590f1..32fcf69f4202 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -25,8 +25,10 @@
 #include <linux/dma-mapping.h>
 #include <linux/platform_device.h>
 #include <asm/smp_plat.h>
+#include <asm/cacheflush.h>
 #include "armada-370-xp.h"
 
+unsigned long __cpuinitdata coherency_phys_base;
 static void __iomem *coherency_base;
 static void __iomem *coherency_cpu_base;
 
@@ -124,7 +126,17 @@ int __init coherency_init(void)
 
 	np = of_find_matching_node(NULL, of_coherency_table);
 	if (np) {
+		struct resource res;
 		pr_info("Initializing Coherency fabric\n");
+		of_address_to_resource(np, 0, &res);
+		coherency_phys_base = res.start;
+		/*
+		 * Ensure secondary CPUs will see the updated value,
+		 * which they read before they join the coherency
+		 * fabric, and therefore before they are coherent with
+		 * the boot CPU cache.
+		 */
+		sync_cache_w(&coherency_phys_base);
 		coherency_base = of_iomap(np, 0);
 		coherency_cpu_base = of_iomap(np, 1);
 		set_cpu_coherent(cpu_logical_map(smp_processor_id()), 0);

commit 865e0527d2d791083a40555f2ba872da5fbddda8
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Wed Jun 5 09:04:55 2013 +0200

    arm: mvebu: avoid hardcoded virtual address in coherency code
    
    Now that the coherency_get_cpu_count() function no longer requires a
    very early mapping of the coherency unit registers, we can avoid the
    hardcoded virtual address in coherency.c. However, the coherency
    features are still used quite early, so we need to do the of_iomap()
    early enough, at the ->init_timer() level, so we have the call of
    coherency_init() at this point.
    
    Unfortunately, at ->init_timer() time, it is not possible to register
    a bus notifier, so we add a separate coherency_late_init() function
    that gets called as as postcore_initcall(), when bus notifiers are
    available.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 46d66c0a7dc5..d74794a590f1 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -27,14 +27,7 @@
 #include <asm/smp_plat.h>
 #include "armada-370-xp.h"
 
-/*
- * Some functions in this file are called very early during SMP
- * initialization. At that time the device tree framework is not yet
- * ready, and it is not possible to get the register address to
- * ioremap it. That's why the pointer below is given with an initial
- * value matching its virtual mapping
- */
-static void __iomem *coherency_base = ARMADA_370_XP_REGS_VIRT_BASE + 0x20200;
+static void __iomem *coherency_base;
 static void __iomem *coherency_cpu_base;
 
 /* Coherency fabric registers */
@@ -135,9 +128,16 @@ int __init coherency_init(void)
 		coherency_base = of_iomap(np, 0);
 		coherency_cpu_base = of_iomap(np, 1);
 		set_cpu_coherent(cpu_logical_map(smp_processor_id()), 0);
-		bus_register_notifier(&platform_bus_type,
-					&mvebu_hwcc_platform_nb);
 	}
 
 	return 0;
 }
+
+static int __init coherency_late_init(void)
+{
+	bus_register_notifier(&platform_bus_type,
+			      &mvebu_hwcc_platform_nb);
+	return 0;
+}
+
+postcore_initcall(coherency_late_init);

commit b21dcafea36dd6249df9cf485a48c7337a8987af
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Wed Jun 5 09:04:54 2013 +0200

    arm: mvebu: remove dependency of SMP init on static I/O mapping
    
    The ->smp_init_cpus() function is called very early during boot, at a
    point where dynamic I/O mappings are not yet possible. However, in the
    Armada 370/XP implementation of this function, we have to get the
    number of CPUs. We used to do that by accessing a hardware register,
    which requires relying on a static I/O mapping set up by
    ->map_io(). Not only this requires hardcoding a virtual address, but
    it also prevents us from removing the static I/O mapping.
    
    So this commit changes the way used to get the number of CPUs: we now
    use the Device Tree, which is a representation of the hardware, and
    provides us the number of available CPUs. This is also more accurate,
    because it potentially allows to boot the Linux kernel on only a
    number of CPUs given by the Device Tree, instead of unconditionally on
    all CPUs.
    
    As a consequence, the coherency_get_cpu_count() function becomes no
    longer used, so we remove it.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 8278960066c3..46d66c0a7dc5 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -47,18 +47,6 @@ static struct of_device_id of_coherency_table[] = {
 	{ /* end of list */ },
 };
 
-#ifdef CONFIG_SMP
-int coherency_get_cpu_count(void)
-{
-	int reg, cnt;
-
-	reg = readl(coherency_base + COHERENCY_FABRIC_CFG_OFFSET);
-	cnt = (reg & 0xF) + 1;
-
-	return cnt;
-}
-#endif
-
 /* Function defined in coherency_ll.S */
 int ll_set_cpu_coherent(void __iomem *base_addr, unsigned int hw_cpu_id);
 

commit e60304f8cb7bb545e79fe62d9b9762460c254ec2
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Fri Oct 12 19:20:36 2012 +0200

    arm: mvebu: Add hardware I/O Coherency support
    
    Armada 370 and XP come with an unit called coherency fabric. This unit
    allows to use the Armada 370/XP as a nearly coherent architecture. The
    coherency mechanism uses snoop filters to ensure the coherency between
    caches, DRAM and devices. This mechanism needs a synchronization
    barrier which guarantees that all the memory writes initiated by the
    devices have reached their target and do not reside in intermediate
    write buffers. That's why the architecture is not totally coherent and
    we need to provide our own functions for some DMA operations.
    
    Beside the use of the coherency fabric, the device units will have to
    set the attribute flag of the decoding address window to select the
    accurate coherency process for the memory transaction. This is done
    each device driver programs the DRAM address windows. The value of the
    attribute set by the driver is retrieved through the
    orion_addr_map_cfg struct filled during the early initialization of
    the platform.
    
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Reviewed-by: Yehuda Yitschak <yehuday@marvell.com>
    Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 596ee66a9cc4..8278960066c3 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -22,6 +22,8 @@
 #include <linux/of_address.h>
 #include <linux/io.h>
 #include <linux/smp.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
 #include <asm/smp_plat.h>
 #include "armada-370-xp.h"
 
@@ -33,10 +35,13 @@
  * value matching its virtual mapping
  */
 static void __iomem *coherency_base = ARMADA_370_XP_REGS_VIRT_BASE + 0x20200;
+static void __iomem *coherency_cpu_base;
 
 /* Coherency fabric registers */
 #define COHERENCY_FABRIC_CFG_OFFSET		   0x4
 
+#define IO_SYNC_BARRIER_CTL_OFFSET		   0x0
+
 static struct of_device_id of_coherency_table[] = {
 	{.compatible = "marvell,coherency-fabric"},
 	{ /* end of list */ },
@@ -68,6 +73,70 @@ int set_cpu_coherent(unsigned int hw_cpu_id, int smp_group_id)
 	return ll_set_cpu_coherent(coherency_base, hw_cpu_id);
 }
 
+static inline void mvebu_hwcc_sync_io_barrier(void)
+{
+	writel(0x1, coherency_cpu_base + IO_SYNC_BARRIER_CTL_OFFSET);
+	while (readl(coherency_cpu_base + IO_SYNC_BARRIER_CTL_OFFSET) & 0x1);
+}
+
+static dma_addr_t mvebu_hwcc_dma_map_page(struct device *dev, struct page *page,
+				  unsigned long offset, size_t size,
+				  enum dma_data_direction dir,
+				  struct dma_attrs *attrs)
+{
+	if (dir != DMA_TO_DEVICE)
+		mvebu_hwcc_sync_io_barrier();
+	return pfn_to_dma(dev, page_to_pfn(page)) + offset;
+}
+
+
+static void mvebu_hwcc_dma_unmap_page(struct device *dev, dma_addr_t dma_handle,
+			      size_t size, enum dma_data_direction dir,
+			      struct dma_attrs *attrs)
+{
+	if (dir != DMA_TO_DEVICE)
+		mvebu_hwcc_sync_io_barrier();
+}
+
+static void mvebu_hwcc_dma_sync(struct device *dev, dma_addr_t dma_handle,
+			size_t size, enum dma_data_direction dir)
+{
+	if (dir != DMA_TO_DEVICE)
+		mvebu_hwcc_sync_io_barrier();
+}
+
+static struct dma_map_ops mvebu_hwcc_dma_ops = {
+	.alloc			= arm_dma_alloc,
+	.free			= arm_dma_free,
+	.mmap			= arm_dma_mmap,
+	.map_page		= mvebu_hwcc_dma_map_page,
+	.unmap_page		= mvebu_hwcc_dma_unmap_page,
+	.get_sgtable		= arm_dma_get_sgtable,
+	.map_sg			= arm_dma_map_sg,
+	.unmap_sg		= arm_dma_unmap_sg,
+	.sync_single_for_cpu	= mvebu_hwcc_dma_sync,
+	.sync_single_for_device	= mvebu_hwcc_dma_sync,
+	.sync_sg_for_cpu	= arm_dma_sync_sg_for_cpu,
+	.sync_sg_for_device	= arm_dma_sync_sg_for_device,
+	.set_dma_mask		= arm_dma_set_mask,
+};
+
+static int mvebu_hwcc_platform_notifier(struct notifier_block *nb,
+				       unsigned long event, void *__dev)
+{
+	struct device *dev = __dev;
+
+	if (event != BUS_NOTIFY_ADD_DEVICE)
+		return NOTIFY_DONE;
+	set_dma_ops(dev, &mvebu_hwcc_dma_ops);
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block mvebu_hwcc_platform_nb = {
+	.notifier_call = mvebu_hwcc_platform_notifier,
+};
+
 int __init coherency_init(void)
 {
 	struct device_node *np;
@@ -76,6 +145,10 @@ int __init coherency_init(void)
 	if (np) {
 		pr_info("Initializing Coherency fabric\n");
 		coherency_base = of_iomap(np, 0);
+		coherency_cpu_base = of_iomap(np, 1);
+		set_cpu_coherent(cpu_logical_map(smp_processor_id()), 0);
+		bus_register_notifier(&platform_bus_type,
+					&mvebu_hwcc_platform_nb);
 	}
 
 	return 0;

commit 009f13159bfdccd6e06fe3b62a39fee6dce26c39
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Thu Aug 2 11:16:29 2012 +0300

    arm: mvebu: Add support for coherency fabric in mach-mvebu
    
    The Armada 370 and Armada XP SOCs have a coherency fabric unit which
    is responsible for ensuring hardware coherency between all CPUs and
    between CPUs and I/O masters. This patch provides the basic support
    needed for SMP.
    
    Signed-off-by: Yehuda Yitschak <yehuday@marvell.com>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Reviewed-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
new file mode 100644
index 000000000000..596ee66a9cc4
--- /dev/null
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -0,0 +1,82 @@
+/*
+ * Coherency fabric (Aurora) support for Armada 370 and XP platforms.
+ *
+ * Copyright (C) 2012 Marvell
+ *
+ * Yehuda Yitschak <yehuday@marvell.com>
+ * Gregory Clement <gregory.clement@free-electrons.com>
+ * Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ *
+ * The Armada 370 and Armada XP SOCs have a coherency fabric which is
+ * responsible for ensuring hardware coherency between all CPUs and between
+ * CPUs and I/O masters. This file initializes the coherency fabric and
+ * supplies basic routines for configuring and controlling hardware coherency
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+#include <linux/smp.h>
+#include <asm/smp_plat.h>
+#include "armada-370-xp.h"
+
+/*
+ * Some functions in this file are called very early during SMP
+ * initialization. At that time the device tree framework is not yet
+ * ready, and it is not possible to get the register address to
+ * ioremap it. That's why the pointer below is given with an initial
+ * value matching its virtual mapping
+ */
+static void __iomem *coherency_base = ARMADA_370_XP_REGS_VIRT_BASE + 0x20200;
+
+/* Coherency fabric registers */
+#define COHERENCY_FABRIC_CFG_OFFSET		   0x4
+
+static struct of_device_id of_coherency_table[] = {
+	{.compatible = "marvell,coherency-fabric"},
+	{ /* end of list */ },
+};
+
+#ifdef CONFIG_SMP
+int coherency_get_cpu_count(void)
+{
+	int reg, cnt;
+
+	reg = readl(coherency_base + COHERENCY_FABRIC_CFG_OFFSET);
+	cnt = (reg & 0xF) + 1;
+
+	return cnt;
+}
+#endif
+
+/* Function defined in coherency_ll.S */
+int ll_set_cpu_coherent(void __iomem *base_addr, unsigned int hw_cpu_id);
+
+int set_cpu_coherent(unsigned int hw_cpu_id, int smp_group_id)
+{
+	if (!coherency_base) {
+		pr_warn("Can't make CPU %d cache coherent.\n", hw_cpu_id);
+		pr_warn("Coherency fabric is not initialized\n");
+		return 1;
+	}
+
+	return ll_set_cpu_coherent(coherency_base, hw_cpu_id);
+}
+
+int __init coherency_init(void)
+{
+	struct device_node *np;
+
+	np = of_find_matching_node(NULL, of_coherency_table);
+	if (np) {
+		pr_info("Initializing Coherency fabric\n");
+		coherency_base = of_iomap(np, 0);
+	}
+
+	return 0;
+}
