commit e9d50248d6d92957160bd2616a7e738a746b8231
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Tue Jun 7 20:03:47 2016 +0100

    mvebu: fix missing include of common.h in cpu-reset.c
    
    The mvebu_cpu_reset_deassert() is missing the definition for
    it, so include common.h where it is defined to fix the warning:
    
    arch/arm/mach-mvebu/cpu-reset.c:25:5: warning: symbol 'mvebu_cpu_reset_deassert' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/mach-mvebu/cpu-reset.c b/arch/arm/mach-mvebu/cpu-reset.c
index 4a2cadd6b48e..f33a31c6aff8 100644
--- a/arch/arm/mach-mvebu/cpu-reset.c
+++ b/arch/arm/mach-mvebu/cpu-reset.c
@@ -16,6 +16,8 @@
 #include <linux/io.h>
 #include <linux/resource.h>
 
+#include "common.h"
+
 static void __iomem *cpu_reset_base;
 static size_t cpu_reset_size;
 

commit 316fbbc400875c647c3a220c7525ffa8d2c80306
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Thu Oct 30 12:39:41 2014 +0100

    ARM: mvebu: Clean-up the Armada XP support
    
    This patch removes the unneeded include of the armada-370-xp.h header.
    
    It also moves some declarations from this file into more accurate
    places.
    
    Finally, it also adds a comment explaining that we can't remove yet the
    smp field in the dt machine struct due to backward compatibly of the
    device tree.
    
    In a few releases, when the old device tree will be obsolete, we will be
    able to remove the smp field and then the armada-370-xp.h header.
    
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Tested-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Reviewed-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1414669184-16785-2-git-send-email-gregory.clement@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/cpu-reset.c b/arch/arm/mach-mvebu/cpu-reset.c
index 60fb53787004..4a2cadd6b48e 100644
--- a/arch/arm/mach-mvebu/cpu-reset.c
+++ b/arch/arm/mach-mvebu/cpu-reset.c
@@ -15,7 +15,6 @@
 #include <linux/of_address.h>
 #include <linux/io.h>
 #include <linux/resource.h>
-#include "armada-370-xp.h"
 
 static void __iomem *cpu_reset_base;
 static size_t cpu_reset_size;

commit e65714740d65237c40878b63acad6bf921481974
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Tue Jun 24 17:13:51 2014 +0530

    ARM: mvebu: Staticize mvebu_cpu_reset_init
    
    'mvebu_cpu_reset_init' is local to this file.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Link: https://lkml.kernel.org/r/1403610235-22654-4-git-send-email-sachin.kamat@samsung.com
    Signed-off-by: Sachin Kamat <sachin.kamat@samsung.com>
    Acked-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Gregory Clement <gregory.clement@free-electrons.com>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/cpu-reset.c b/arch/arm/mach-mvebu/cpu-reset.c
index 4a8f9eebebea..60fb53787004 100644
--- a/arch/arm/mach-mvebu/cpu-reset.c
+++ b/arch/arm/mach-mvebu/cpu-reset.c
@@ -67,7 +67,7 @@ static int mvebu_cpu_reset_map(struct device_node *np, int res_idx)
 	return 0;
 }
 
-int __init mvebu_cpu_reset_init(void)
+static int __init mvebu_cpu_reset_init(void)
 {
 	struct device_node *np;
 	int res_idx;

commit 49754ffef5dca1d212e5fea5957a2a164585e92c
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon Apr 14 15:50:29 2014 +0200

    ARM: mvebu: start using the CPU reset driver
    
    This commit changes the PMSU driver to no longer map itself the CPU
    reset registers, and instead call into the CPU reset driver to
    deassert the secondary CPUs for SMP booting.
    
    In order to provide Device Tree backward compatibility, the CPU reset
    driver is extended to not only support its official compatible string
    "marvell,armada-370-cpu-reset", but to also look at the PMSU
    compatible string "marvell,armada-370-xp-pmsu" to find the CPU reset
    registers address. This allows old Device Tree to work correctly with
    newer kernel versions. Therefore, the CPU reset driver implements the
    following logic:
    
     * If one of the normal compatible strings
       "marvell,armada-370-cpu-reset" is found, then we map its first
       memory resource as the CPU reset registers.
    
     * Otherwise, if none of the normal compatible strings have been
       found, we look for the "marvell,armada-370-xp-pmsu" compatible
       string, and we map the second memory as the CPU reset registers.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1397483433-25836-3-git-send-email-thomas.petazzoni@free-electrons.com
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/cpu-reset.c b/arch/arm/mach-mvebu/cpu-reset.c
index 4ff4ce77f8b6..4a8f9eebebea 100644
--- a/arch/arm/mach-mvebu/cpu-reset.c
+++ b/arch/arm/mach-mvebu/cpu-reset.c
@@ -40,42 +40,63 @@ int mvebu_cpu_reset_deassert(int cpu)
 	return 0;
 }
 
-static int __init mvebu_cpu_reset_init(void)
+static int mvebu_cpu_reset_map(struct device_node *np, int res_idx)
 {
-	struct device_node *np;
 	struct resource res;
-	int ret = 0;
-
-	np = of_find_compatible_node(NULL, NULL,
-				     "marvell,armada-370-cpu-reset");
-	if (!np)
-		return 0;
 
-	if (of_address_to_resource(np, 0, &res)) {
+	if (of_address_to_resource(np, res_idx, &res)) {
 		pr_err("unable to get resource\n");
-		ret = -ENOENT;
-		goto out;
+		return -ENOENT;
 	}
 
 	if (!request_mem_region(res.start, resource_size(&res),
 				np->full_name)) {
 		pr_err("unable to request region\n");
-		ret = -EBUSY;
-		goto out;
+		return -EBUSY;
 	}
 
 	cpu_reset_base = ioremap(res.start, resource_size(&res));
 	if (!cpu_reset_base) {
 		pr_err("unable to map registers\n");
 		release_mem_region(res.start, resource_size(&res));
-		ret = -ENOMEM;
-		goto out;
+		return -ENOMEM;
 	}
 
 	cpu_reset_size = resource_size(&res);
 
-out:
+	return 0;
+}
+
+int __init mvebu_cpu_reset_init(void)
+{
+	struct device_node *np;
+	int res_idx;
+	int ret;
+
+	np = of_find_compatible_node(NULL, NULL,
+				     "marvell,armada-370-cpu-reset");
+	if (np) {
+		res_idx = 0;
+	} else {
+		/*
+		 * This code is kept for backward compatibility with
+		 * old Device Trees.
+		 */
+		np = of_find_compatible_node(NULL, NULL,
+					     "marvell,armada-370-xp-pmsu");
+		if (np) {
+			pr_warn(FW_WARN "deprecated pmsu binding\n");
+			res_idx = 1;
+		}
+	}
+
+	/* No reset node found */
+	if (!np)
+		return -ENODEV;
+
+	ret = mvebu_cpu_reset_map(np, res_idx);
 	of_node_put(np);
+
 	return ret;
 }
 

commit 3f20fb1153b374737acd40d42cb3cab2ae5dae35
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon Apr 14 15:50:28 2014 +0200

    ARM: mvebu: introduce CPU reset code
    
    The Armada 370 and Armada XP have registers that allow to reset the
    CPUs, which is particularly useful to take the secondary CPUs out of
    reset in the context of the SMP support.
    
    Unfortunately, an implementation mistake was originally made and the
    support for these registers was integrated into the PMSU driver, which
    is in fact completely unrelated. And it turns out that the Armada 375
    has the same CPU reset registers, but does not have the PMSU
    registers.
    
    Therefore, this commit creates a small CPU reset driver. All it does
    is provide a simple mvebu_cpu_reset_deassert() function that the SMP
    support code can call to take secondary CPUs out of reset. As of this
    commit, the driver isn't being used, it will be used through changes
    in the following commits.
    
    Note that we initially planned to use the 'reset controller'
    framework, but it requires the addition of "resets" properties in the
    Device Tree, which are causing too many problems if we want to keep
    the Device Tree backward compatibility. Moreover, the 'reset
    controller' framework is mainly useful when a device driver needs to
    request a reset of its device from a separate reset controller. In our
    case, the CPU reset handling and the SMP core code are both located in
    arch/arm/mach-mvebu/ and are tightly linked together, so there's no
    real benefit in going through a separate framework.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1397483433-25836-2-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/cpu-reset.c b/arch/arm/mach-mvebu/cpu-reset.c
new file mode 100644
index 000000000000..4ff4ce77f8b6
--- /dev/null
+++ b/arch/arm/mach-mvebu/cpu-reset.c
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2014 Marvell
+ *
+ * Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#define pr_fmt(fmt) "mvebu-cpureset: " fmt
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+#include <linux/resource.h>
+#include "armada-370-xp.h"
+
+static void __iomem *cpu_reset_base;
+static size_t cpu_reset_size;
+
+#define CPU_RESET_OFFSET(cpu) (cpu * 0x8)
+#define CPU_RESET_ASSERT      BIT(0)
+
+int mvebu_cpu_reset_deassert(int cpu)
+{
+	u32 reg;
+
+	if (!cpu_reset_base)
+		return -ENODEV;
+
+	if (CPU_RESET_OFFSET(cpu) >= cpu_reset_size)
+		return -EINVAL;
+
+	reg = readl(cpu_reset_base + CPU_RESET_OFFSET(cpu));
+	reg &= ~CPU_RESET_ASSERT;
+	writel(reg, cpu_reset_base + CPU_RESET_OFFSET(cpu));
+
+	return 0;
+}
+
+static int __init mvebu_cpu_reset_init(void)
+{
+	struct device_node *np;
+	struct resource res;
+	int ret = 0;
+
+	np = of_find_compatible_node(NULL, NULL,
+				     "marvell,armada-370-cpu-reset");
+	if (!np)
+		return 0;
+
+	if (of_address_to_resource(np, 0, &res)) {
+		pr_err("unable to get resource\n");
+		ret = -ENOENT;
+		goto out;
+	}
+
+	if (!request_mem_region(res.start, resource_size(&res),
+				np->full_name)) {
+		pr_err("unable to request region\n");
+		ret = -EBUSY;
+		goto out;
+	}
+
+	cpu_reset_base = ioremap(res.start, resource_size(&res));
+	if (!cpu_reset_base) {
+		pr_err("unable to map registers\n");
+		release_mem_region(res.start, resource_size(&res));
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	cpu_reset_size = resource_size(&res);
+
+out:
+	of_node_put(np);
+	return ret;
+}
+
+early_initcall(mvebu_cpu_reset_init);
