commit 77bc8c28ddac90287bc42c129002eb703288d550
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Mon Jun 18 17:32:30 2018 +0200

    ARM: mvebu: convert secondary CPU clock sync to hotplug state
    
    The current call site in boot_secondary is causing sleep in invalid context
    warnings, as this part of the code is running with interrrupts disabled and
    some of the calls into the clock framework might sleep on a mutex.
    
    Convert the secondary CPU clock sync to a hotplug state, which allows to
    call it from a sleepable context.
    
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index 4ffbbd217e82..c130497dc6cc 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -35,6 +35,8 @@
 #define AXP_BOOTROM_BASE 0xfff00000
 #define AXP_BOOTROM_SIZE 0x100000
 
+static struct clk *boot_cpu_clk;
+
 static struct clk *get_cpu_clk(int cpu)
 {
 	struct clk *cpu_clk;
@@ -48,30 +50,6 @@ static struct clk *get_cpu_clk(int cpu)
 	return cpu_clk;
 }
 
-static void set_secondary_cpu_clock(unsigned int cpu)
-{
-	int thiscpu;
-	unsigned long rate;
-	struct clk *cpu_clk;
-
-	thiscpu = get_cpu();
-
-	cpu_clk = get_cpu_clk(thiscpu);
-	if (!cpu_clk)
-		goto out;
-	clk_prepare_enable(cpu_clk);
-	rate = clk_get_rate(cpu_clk);
-
-	cpu_clk = get_cpu_clk(cpu);
-	if (!cpu_clk)
-		goto out;
-	clk_set_rate(cpu_clk, rate);
-	clk_prepare_enable(cpu_clk);
-
-out:
-	put_cpu();
-}
-
 static int armada_xp_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	int ret, hw_cpu;
@@ -79,7 +57,6 @@ static int armada_xp_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	pr_info("Booting CPU %d\n", cpu);
 
 	hw_cpu = cpu_logical_map(cpu);
-	set_secondary_cpu_clock(hw_cpu);
 	mvebu_pmsu_set_cpu_boot_addr(hw_cpu, armada_xp_secondary_startup);
 
 	/*
@@ -122,6 +99,19 @@ static void __init armada_xp_smp_init_cpus(void)
 		panic("Invalid number of CPUs in DT\n");
 }
 
+static int armada_xp_sync_secondary_clk(unsigned int cpu)
+{
+	struct clk *cpu_clk = get_cpu_clk(cpu);
+
+	if (!cpu_clk || !boot_cpu_clk)
+		return 0;
+
+	clk_prepare_enable(cpu_clk);
+	clk_set_rate(cpu_clk, clk_get_rate(boot_cpu_clk));
+
+	return 0;
+}
+
 static void __init armada_xp_smp_prepare_cpus(unsigned int max_cpus)
 {
 	struct device_node *node;
@@ -131,6 +121,14 @@ static void __init armada_xp_smp_prepare_cpus(unsigned int max_cpus)
 	flush_cache_all();
 	set_cpu_coherent();
 
+	boot_cpu_clk = get_cpu_clk(smp_processor_id());
+	if (boot_cpu_clk) {
+		clk_prepare_enable(boot_cpu_clk);
+		cpuhp_setup_state_nocalls(CPUHP_AP_ARM_MVEBU_SYNC_CLOCKS,
+					  "arm/mvebu/sync_clocks:online",
+					  armada_xp_sync_secondary_clk, NULL);
+	}
+
 	/*
 	 * In order to boot the secondary CPUs we need to ensure
 	 * the bootROM is mapped at the correct address.
@@ -223,7 +221,6 @@ static int mv98dx3236_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	int ret, hw_cpu;
 
 	hw_cpu = cpu_logical_map(cpu);
-	set_secondary_cpu_clock(hw_cpu);
 	mv98dx3236_resume_set_cpu_boot_addr(hw_cpu,
 					    armada_xp_secondary_startup);
 

commit 76127d6fe00062bddb25515d8a4f44633c41fe14
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Fri Jul 7 09:59:28 2017 +0200

    ARM: mvebu: use __pa_symbol in the mv98dx3236 platform SMP code
    
    As we already did for Armada XP switch from virt_to_phys() to
    __pa_symbol().
    
    The reason for it was well explained by Mark Rutland so let's quote him:
    
    "virt_to_phys() is intended to operate on the linear/direct mapping of
    RAM.
    
    __pa_symbol() is intended to operate on the kernel mapping, which may
    not be in the linear/direct mapping on all architectures. e.g. arm64 and
    x86_64 map the kernel image and RAM separately.
    
    On 32-bit ARM the kernel image mapping is tied to the linear/direct
    mapping, so that works, but as it's semantically wrong (and broken for
    generic code), the DEBUG_VIRTUAL checks complain."
    
    Fixes: db88977894ab ("arm: mvebu: support for SMP on 98DX3336 SoC")
    Cc: <stable@vger.kernel.org>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Tested-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index e62273aacb43..4ffbbd217e82 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -211,7 +211,7 @@ static int mv98dx3236_resume_set_cpu_boot_addr(int hw_cpu, void *boot_addr)
 		return PTR_ERR(base);
 
 	writel(0, base + MV98DX3236_CPU_RESUME_CTRL_REG);
-	writel(virt_to_phys(boot_addr), base + MV98DX3236_CPU_RESUME_ADDR_REG);
+	writel(__pa_symbol(boot_addr), base + MV98DX3236_CPU_RESUME_ADDR_REG);
 
 	iounmap(base);
 

commit db88977894aba193deee70b335c3db58b7ac6393
Author: Chris Packham <chris.packham@alliedtelesis.co.nz>
Date:   Mon Jan 30 12:20:32 2017 +1300

    arm: mvebu: support for SMP on 98DX3336 SoC
    
    Compared to the armada-xp the 98DX3336 uses different registers to set
    the boot address for the secondary CPU so a new enable-method is needed.
    This will only work if the machine definition doesn't define an overall
    smp_ops because there is not currently a way of overriding this from the
    device tree if it is set in the machine definition.
    
    Signed-off-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index 46c742d3bd41..e62273aacb43 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -184,3 +184,78 @@ const struct smp_operations armada_xp_smp_ops __initconst = {
 
 CPU_METHOD_OF_DECLARE(armada_xp_smp, "marvell,armada-xp-smp",
 		      &armada_xp_smp_ops);
+
+#define MV98DX3236_CPU_RESUME_CTRL_REG 0x08
+#define MV98DX3236_CPU_RESUME_ADDR_REG 0x04
+
+static const struct of_device_id of_mv98dx3236_resume_table[] = {
+	{
+		.compatible = "marvell,98dx3336-resume-ctrl",
+	},
+	{ /* end of list */ },
+};
+
+static int mv98dx3236_resume_set_cpu_boot_addr(int hw_cpu, void *boot_addr)
+{
+	struct device_node *np;
+	void __iomem *base;
+	WARN_ON(hw_cpu != 1);
+
+	np = of_find_matching_node(NULL, of_mv98dx3236_resume_table);
+	if (!np)
+		return -ENODEV;
+
+	base = of_io_request_and_map(np, 0, of_node_full_name(np));
+	of_node_put(np);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	writel(0, base + MV98DX3236_CPU_RESUME_CTRL_REG);
+	writel(virt_to_phys(boot_addr), base + MV98DX3236_CPU_RESUME_ADDR_REG);
+
+	iounmap(base);
+
+	return 0;
+}
+
+static int mv98dx3236_boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	int ret, hw_cpu;
+
+	hw_cpu = cpu_logical_map(cpu);
+	set_secondary_cpu_clock(hw_cpu);
+	mv98dx3236_resume_set_cpu_boot_addr(hw_cpu,
+					    armada_xp_secondary_startup);
+
+	/*
+	 * This is needed to wake up CPUs in the offline state after
+	 * using CPU hotplug.
+	 */
+	arch_send_wakeup_ipi_mask(cpumask_of(cpu));
+
+	/*
+	 * This is needed to take secondary CPUs out of reset on the
+	 * initial boot.
+	 */
+	ret = mvebu_cpu_reset_deassert(hw_cpu);
+	if (ret) {
+		pr_warn("unable to boot CPU: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct smp_operations mv98dx3236_smp_ops __initconst = {
+	.smp_init_cpus		= armada_xp_smp_init_cpus,
+	.smp_prepare_cpus	= armada_xp_smp_prepare_cpus,
+	.smp_boot_secondary	= mv98dx3236_boot_secondary,
+	.smp_secondary_init     = armada_xp_secondary_init,
+#ifdef CONFIG_HOTPLUG_CPU
+	.cpu_die		= armada_xp_cpu_die,
+	.cpu_kill               = armada_xp_cpu_kill,
+#endif
+};
+
+CPU_METHOD_OF_DECLARE(mv98dx3236_smp, "marvell,98dx3236-smp",
+		      &mv98dx3236_smp_ops);

commit 7d8f9ac16223cf14f199a96355b0add4ca286662
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Feb 8 15:17:12 2016 +0900

    ARM: mvebu: add missing of_node_put()
    
    This node pointer is returned by of_find_compatible_node() in this
    function.  It should be put before exitting this function.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index f9597b701028..46c742d3bd41 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -140,6 +140,7 @@ static void __init armada_xp_smp_prepare_cpus(unsigned int max_cpus)
 		panic("Cannot find 'marvell,bootrom' compatible node");
 
 	err = of_address_to_resource(node, 0, &res);
+	of_node_put(node);
 	if (err < 0)
 		panic("Cannot get 'bootrom' node address");
 

commit 75305275a721d33ae9abfaeed2817cec8b2fee9a
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 15 10:39:53 2015 +0900

    ARM: use const and __initconst for smp_operations
    
    These smp_operations structures are not over-written, so add "const"
    qualifier and replace __initdata with __initconst.
    
    Also, add "static" where it is possible.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Moritz Fischer <moritz.fischer@ettus.com>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org> # qcom part
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: Wei Xu <xuwei5@hisilicon.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Acked-by: Matthias Brugger <matthias.bgg@gmail.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index 58cc8c1575eb..f9597b701028 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -170,7 +170,7 @@ static int armada_xp_cpu_kill(unsigned int cpu)
 }
 #endif
 
-struct smp_operations armada_xp_smp_ops __initdata = {
+const struct smp_operations armada_xp_smp_ops __initconst = {
 	.smp_init_cpus		= armada_xp_smp_init_cpus,
 	.smp_prepare_cpus	= armada_xp_smp_prepare_cpus,
 	.smp_boot_secondary	= armada_xp_boot_secondary,

commit ab64920c3742ba992a3bf0b06f9750d1cad9d050
Merge: 756f80cee766 6e6db2bea3ea
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Dec 4 16:46:43 2014 +0100

    Merge tag 'mvebu-soc-suspend-3.19' of git://git.infradead.org/linux-mvebu into next/soc
    
    Pull "mvebu SoC suspend changes for v3.19" from Jason Cooper:
    
     - Armada 370/XP suspend/resume support
    
     - mvebu SoC driver suspend/resume support
        - irqchip
        - clocksource
        - mbus
        - clk
    
    * tag 'mvebu-soc-suspend-3.19' of git://git.infradead.org/linux-mvebu:
      ARM: mvebu: add SDRAM controller description for Armada XP
      ARM: mvebu: adjust mbus controller description on Armada 370/XP
      ARM: mvebu: add suspend/resume DT information for Armada XP GP
      ARM: mvebu: synchronize secondary CPU clocks on resume
      ARM: mvebu: make sure MMU is disabled in armada_370_xp_cpu_resume
      ARM: mvebu: Armada XP GP specific suspend/resume code
      ARM: mvebu: reserve the first 10 KB of each memory bank for suspend/resume
      ARM: mvebu: implement suspend/resume support for Armada XP
      clk: mvebu: add suspend/resume for gatable clocks
      bus: mvebu-mbus: provide a mechanism to save SDRAM window configuration
      bus: mvebu-mbus: suspend/resume support
      clocksource: time-armada-370-xp: add suspend/resume support
      irqchip: armada-370-xp: Add suspend/resume support
      Documentation: dt-bindings: minimal documentation for MVEBU SDRAM controller
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit b9b1de0f4da37dac76d812a27d6065eba02dc05b
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Fri Nov 21 17:00:10 2014 +0100

    ARM: mvebu: synchronize secondary CPU clocks on resume
    
    The Armada XP has multiple cores clocked by independent clocks. The
    SMP startup code contains a function called set_secondary_cpus_clock()
    called in armada_xp_smp_prepare_cpus() to ensure the clocks of the
    secondary CPUs match the clock of the boot CPU.
    
    With the introduction of suspend/resume, this operation is no longer
    needed when booting the system, but also when existing the suspend to
    RAM state. Therefore this commit reworks a bit the logic: instead of
    configuring the clock of all secondary CPUs in
    armada_xp_smp_prepare_cpus(), we do it on a per-secondary CPU basis in
    armada_xp_boot_secondary(), as this function gets called when existing
    suspend to RAM for each secondary CPU.
    
    Since the function now only takes care of one CPU, we rename it from
    set_secondary_cpus_clock() to set_secondary_cpu_clock(), and it looses
    its __init marker, as it is now used beyond the system initialization.
    
    Note that we can't use smp_processor_id() directly, because when
    exiting from suspend to RAM, the code is apparently executed with
    preemption enabled, so smp_processor_id() is not happy (prints a
    warning). We therefore switch to using get_cpu()/put_cpu(), even
    though we pretty much have the guarantee that the code starting the
    secondary CPUs is going to run on the boot CPU and will not be
    migrated.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Link: https://lkml.kernel.org/r/1416585613-2113-14-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index 895dc373c8a1..e65e69a7e65d 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -33,7 +33,7 @@
 #define AXP_BOOTROM_BASE 0xfff00000
 #define AXP_BOOTROM_SIZE 0x100000
 
-static struct clk *__init get_cpu_clk(int cpu)
+static struct clk *get_cpu_clk(int cpu)
 {
 	struct clk *cpu_clk;
 	struct device_node *np = of_get_cpu_node(cpu, NULL);
@@ -46,29 +46,28 @@ static struct clk *__init get_cpu_clk(int cpu)
 	return cpu_clk;
 }
 
-static void __init set_secondary_cpus_clock(void)
+static void set_secondary_cpu_clock(unsigned int cpu)
 {
-	int thiscpu, cpu;
+	int thiscpu;
 	unsigned long rate;
 	struct clk *cpu_clk;
 
-	thiscpu = smp_processor_id();
+	thiscpu = get_cpu();
+
 	cpu_clk = get_cpu_clk(thiscpu);
 	if (!cpu_clk)
-		return;
+		goto out;
 	clk_prepare_enable(cpu_clk);
 	rate = clk_get_rate(cpu_clk);
 
-	/* set all the other CPU clk to the same rate than the boot CPU */
-	for_each_possible_cpu(cpu) {
-		if (cpu == thiscpu)
-			continue;
-		cpu_clk = get_cpu_clk(cpu);
-		if (!cpu_clk)
-			return;
-		clk_set_rate(cpu_clk, rate);
-		clk_prepare_enable(cpu_clk);
-	}
+	cpu_clk = get_cpu_clk(cpu);
+	if (!cpu_clk)
+		goto out;
+	clk_set_rate(cpu_clk, rate);
+	clk_prepare_enable(cpu_clk);
+
+out:
+	put_cpu();
 }
 
 static int armada_xp_boot_secondary(unsigned int cpu, struct task_struct *idle)
@@ -78,6 +77,7 @@ static int armada_xp_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	pr_info("Booting CPU %d\n", cpu);
 
 	hw_cpu = cpu_logical_map(cpu);
+	set_secondary_cpu_clock(hw_cpu);
 	mvebu_pmsu_set_cpu_boot_addr(hw_cpu, armada_xp_secondary_startup);
 
 	/*
@@ -126,7 +126,6 @@ static void __init armada_xp_smp_prepare_cpus(unsigned int max_cpus)
 	struct resource res;
 	int err;
 
-	set_secondary_cpus_clock();
 	flush_cache_all();
 	set_cpu_coherent();
 

commit 316fbbc400875c647c3a220c7525ffa8d2c80306
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Thu Oct 30 12:39:41 2014 +0100

    ARM: mvebu: Clean-up the Armada XP support
    
    This patch removes the unneeded include of the armada-370-xp.h header.
    
    It also moves some declarations from this file into more accurate
    places.
    
    Finally, it also adds a comment explaining that we can't remove yet the
    smp field in the dt machine struct due to backward compatibly of the
    device tree.
    
    In a few releases, when the old device tree will be obsolete, we will be
    able to remove the smp field and then the armada-370-xp.h header.
    
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Tested-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Reviewed-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1414669184-16785-2-git-send-email-gregory.clement@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index 895dc373c8a1..622315c185b2 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -30,6 +30,8 @@
 #include "pmsu.h"
 #include "coherency.h"
 
+#define ARMADA_XP_MAX_CPUS 4
+
 #define AXP_BOOTROM_BASE 0xfff00000
 #define AXP_BOOTROM_SIZE 0x100000
 

commit 54ef3fe6970b040e9b6d1fc7f64f8dcab5cfb743
Merge: b03e119fff8a e53b1fd43249
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Thu Jul 24 23:10:02 2014 +0000

    Merge branch 'mvebu/soc-cpuidle' into mvebu/soc
    
    Conflicts:
            arch/arm/mach-mvebu/pmsu.c

commit 898ef3e9bfc7f5c94a1e67d0a540e224e2496909
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Wed Jul 23 15:00:42 2014 +0200

    ARM: mvebu: rename the armada_370_xp symbols to mvebu_v7 in pmsu.c
    
    Most of the function related to the PMSU are not specific to the
    Armada 370 or Armada XP SoCs. They can also be used for most of the
    other mvebu ARMv7 SoCs, and will actually be used to support cpuidle
    on Armada 38x.
    
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1406120453-29291-6-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index b6fa9f0c98b8..6da2b723d374 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -108,7 +108,7 @@ static int armada_xp_boot_secondary(unsigned int cpu, struct task_struct *idle)
  */
 static void armada_xp_secondary_init(unsigned int cpu)
 {
-	armada_370_xp_pmsu_idle_exit();
+	mvebu_v7_pmsu_idle_exit();
 }
 
 static void __init armada_xp_smp_init_cpus(void)

commit ba3ec5780bba27819bbc4f669e6c77418a00f14b
Merge: ba364fc752da ee2d8ea1e9bb
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Jul 22 20:46:48 2014 +0000

    Merge branch 'mvebu/soc-cpufreq' into mvebu/soc

commit 831e2518890f5ffd52706750b1cbf04feb2e7c59
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Wed Jul 9 17:45:09 2014 +0200

    ARM: mvebu: ensure CPU clocks are enabled
    
    In the Armada XP SMP support code, we are reading the clock frequency
    of the booting CPU, and use that to assign the same frequency to the
    other CPUs, and we do this while the clocks are disabled.
    
    However, the CPU clocks are in fact never prepared/enabled, and to
    support cpufreq, we now have two code paths to change the frequency of
    the CPU clocks in the CPU clock driver: one when the clock is enabled
    (dynamic frequency scaling), one when the clock is disabled (adjusting
    the CPU frequency before starting the CPU). In order for this to work,
    the CPU clocks now have to be prepared and enabled after the initial
    synchronization of the clock frequencies is done, so that all future
    rate changes of the CPU clocks will trigger a dynamic frequency
    scaling transition.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1404920715-19834-2-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index 88b976b31719..4880b0f70362 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -67,6 +67,7 @@ static void __init set_secondary_cpus_clock(void)
 		if (!cpu_clk)
 			return;
 		clk_set_rate(cpu_clk, rate);
+		clk_prepare_enable(cpu_clk);
 	}
 }
 

commit 26337779465637b761624d9752f52d1ec88f71d9
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Fri May 30 22:18:17 2014 +0200

    ARM: mvebu: implement CPU hotplug support for Armada XP
    
    This commit implements CPU hotplug support for the Marvell Armada XP
    platform. The CPU hotplug stub functions from hotplug.c are moved into
    platsmp.c, as it doesn't make much sense to have a separate file just
    for these two functions.
    
    In addition, this commit:
    
     * Implements the ->cpu_die() function of SMP operations by calling
       armada_370_xp_pmsu_idle_enter() to enter the deep idle state for
       CPUs going offline.
    
     * Implements a dummy ->cpu_kill() function, simply needed for the
       kernel to know we have CPU hotplug support.
    
     * The armada_xp_boot_secondary() function makes sure to wake up the
       CPU if waiting in deep idle state by sending an IPI. This is
       because armada_xp_boot_secondary() is now used in two different
       situations: for the initial boot of secondary CPUs (where CPU reset
       deassert is used to wake up CPUs) and for CPU hotplug (where an IPI
       is used to take CPU out of deep idle).
    
     * At boot time, we exit from the idle state in the
       ->smp_secondary_init() hook.
    
    This commit has been tested using CPU hotplug through sysfs
    (/sys/devices/system/cpu/cpuX/online) and using kexec.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1401481098-23326-5-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index 88b976b31719..b6fa9f0c98b8 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -78,6 +78,17 @@ static int armada_xp_boot_secondary(unsigned int cpu, struct task_struct *idle)
 
 	hw_cpu = cpu_logical_map(cpu);
 	mvebu_pmsu_set_cpu_boot_addr(hw_cpu, armada_xp_secondary_startup);
+
+	/*
+	 * This is needed to wake up CPUs in the offline state after
+	 * using CPU hotplug.
+	 */
+	arch_send_wakeup_ipi_mask(cpumask_of(cpu));
+
+	/*
+	 * This is needed to take secondary CPUs out of reset on the
+	 * initial boot.
+	 */
 	ret = mvebu_cpu_reset_deassert(hw_cpu);
 	if (ret) {
 		pr_warn("unable to boot CPU: %d\n", ret);
@@ -87,6 +98,19 @@ static int armada_xp_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	return 0;
 }
 
+/*
+ * When a CPU is brought back online, either through CPU hotplug, or
+ * because of the boot of a kexec'ed kernel, the PMSU configuration
+ * for this CPU might be in the deep idle state, preventing this CPU
+ * from receiving interrupts. Here, we therefore take out the current
+ * CPU from this state, which was entered by armada_xp_cpu_die()
+ * below.
+ */
+static void armada_xp_secondary_init(unsigned int cpu)
+{
+	armada_370_xp_pmsu_idle_exit();
+}
+
 static void __init armada_xp_smp_init_cpus(void)
 {
 	unsigned int ncores = num_possible_cpus();
@@ -122,12 +146,36 @@ static void __init armada_xp_smp_prepare_cpus(unsigned int max_cpus)
 		panic("The address for the BootROM is incorrect");
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+static void armada_xp_cpu_die(unsigned int cpu)
+{
+	/*
+	 * CPU hotplug is implemented by putting offline CPUs into the
+	 * deep idle sleep state.
+	 */
+	armada_370_xp_pmsu_idle_enter(true);
+}
+
+/*
+ * We need a dummy function, so that platform_can_cpu_hotplug() knows
+ * we support CPU hotplug. However, the function does not need to do
+ * anything, because CPUs going offline can enter the deep idle state
+ * by themselves, without any help from a still alive CPU.
+ */
+static int armada_xp_cpu_kill(unsigned int cpu)
+{
+	return 1;
+}
+#endif
+
 struct smp_operations armada_xp_smp_ops __initdata = {
 	.smp_init_cpus		= armada_xp_smp_init_cpus,
 	.smp_prepare_cpus	= armada_xp_smp_prepare_cpus,
 	.smp_boot_secondary	= armada_xp_boot_secondary,
+	.smp_secondary_init     = armada_xp_secondary_init,
 #ifdef CONFIG_HOTPLUG_CPU
 	.cpu_die		= armada_xp_cpu_die,
+	.cpu_kill               = armada_xp_cpu_kill,
 #endif
 };
 

commit 952f4ca79b4ec7114291aa711add1b36c6ba7515
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Mon Apr 14 17:10:07 2014 +0200

    ARM: mvebu: Remove the unused argument of set_cpu_coherent()
    
    set_cpu_coherent() took the SMP group ID as parameter. But this
    parameter was never used, and the CPU always uses the SMP group 0. So
    we can remove this parameter.
    
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Link: https://lkml.kernel.org/r/1397488214-20685-5-git-send-email-gregory.clement@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index 75436c0023a8..88b976b31719 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -103,7 +103,7 @@ static void __init armada_xp_smp_prepare_cpus(unsigned int max_cpus)
 
 	set_secondary_cpus_clock();
 	flush_cache_all();
-	set_cpu_coherent(0);
+	set_cpu_coherent();
 
 	/*
 	 * In order to boot the secondary CPUs we need to ensure

commit b41375f71aceadb7d74a18aafba4da5024fc104b
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Mon Apr 14 17:10:06 2014 +0200

    ARM: mvebu: ll_set_cpu_coherent always uses the current CPU
    
    ll_set_cpu_coherent is always used on the current CPU, so instead of
    passing the CPU id as argument, ll_set_cpu_coherent() can find it by
    itself.
    
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Link: https://lkml.kernel.org/r/1397488214-20685-4-git-send-email-gregory.clement@free-electrons.com
    Acked-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index 32bf78e80c48..75436c0023a8 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -103,7 +103,7 @@ static void __init armada_xp_smp_prepare_cpus(unsigned int max_cpus)
 
 	set_secondary_cpus_clock();
 	flush_cache_all();
-	set_cpu_coherent(cpu_logical_map(smp_processor_id()), 0);
+	set_cpu_coherent(0);
 
 	/*
 	 * In order to boot the secondary CPUs we need to ensure

commit 5194efc5c649a7fa622eae9af7df5dbcec940ea4
Merge: 2c9b2240bee3 bffbc6eabd0e
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Thu May 8 16:07:56 2014 +0000

    Merge branch 'mvebu/irqchip' into mvebu/soc

commit 2c9b2240bee340711048589023eb057f23fda356
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon Apr 14 15:53:59 2014 +0200

    ARM: mvebu: use CPU_METHOD_OF_DECLARE for SMP on Armada XP
    
    This commit adds the CPU_METHOD_OF_DECLARE declaration for the Armada
    XP SMP operations. Note that the .smp_ops field of Armada XP
    DT_MACHINE structure is kept, in order to ensure we remain compatible
    with older Device Trees that do not include the "enable-method"
    property for the CPUs.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1397483648-26611-3-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index e98075f7175a..e01ae51bee56 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -138,3 +138,6 @@ struct smp_operations armada_xp_smp_ops __initdata = {
 	.cpu_die		= armada_xp_cpu_die,
 #endif
 };
+
+CPU_METHOD_OF_DECLARE(armada_xp_smp, "marvell,armada-xp-smp",
+		      &armada_xp_smp_ops);

commit 05ad690608098b469d6052c700d96c35e697a955
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon Apr 14 15:53:58 2014 +0200

    ARM: mvebu: move Armada XP specific SMP initialization to platsmp.c
    
    The pmsu.c driver contained an armada_xp_boot_cpu() function that sets
    the boot address of a secondary CPUs and deasserts the reset. However,
    the Armada 375 needs a slightly different logic, so it makes more
    sense to move this code into the Armada XP specific platsmp.c.
    
    In order to achieve this, the mvebu_pmsu_set_cpu_boot_addr() function
    is exported. It will be needed for both the Armada XP and Armada 38x
    SMP implementations.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1397483648-26611-2-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index a6da03f5b24e..e98075f7175a 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -77,9 +77,17 @@ static void armada_xp_secondary_init(unsigned int cpu)
 
 static int armada_xp_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
+	int ret, hw_cpu;
+
 	pr_info("Booting CPU %d\n", cpu);
 
-	armada_xp_boot_cpu(cpu, armada_xp_secondary_startup);
+	hw_cpu = cpu_logical_map(cpu);
+	mvebu_pmsu_set_cpu_boot_addr(hw_cpu, armada_xp_secondary_startup);
+	ret = mvebu_cpu_reset_deassert(hw_cpu);
+	if (ret) {
+		pr_warn("unable to boot CPU: %d\n", ret);
+		return ret;
+	}
 
 	return 0;
 }

commit d7df84b3cecad4c768e4065d1d61b2f8fd02b7fa
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon Apr 14 15:54:02 2014 +0200

    irqchip: irq-armada-370-xp: Use cpu notifier to initialize secondary CPUs
    
    Some irqchip initialization must be done on secondary CPUs. On mvebu
    platforms, this is currently achieved by having the
    arch/arm/mach-mvebu/platsmp.c code directly call into a function
    exported by the irqchip driver, which isn't really nice.
    
    This commit changes this by using the same solution as the one used in
    the GIC driver: the irqchip driver registers a CPU notifier, which is
    used to do the secondary CPU IRQ initialization. This way, the irqchip
    driver is completely autonomous, and the function no longer needs to
    be exposed from the irqchip driver to the SoC code.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1397483648-26611-6-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index 6f06f6ddb51e..e43727f391f7 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -70,11 +70,6 @@ static void __init set_secondary_cpus_clock(void)
 	}
 }
 
-static void armada_xp_secondary_init(unsigned int cpu)
-{
-	armada_xp_mpic_smp_cpu_init();
-}
-
 static int armada_xp_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	pr_info("Booting CPU %d\n", cpu);
@@ -122,7 +117,6 @@ static void __init armada_xp_smp_prepare_cpus(unsigned int max_cpus)
 struct smp_operations armada_xp_smp_ops __initdata = {
 	.smp_init_cpus		= armada_xp_smp_init_cpus,
 	.smp_prepare_cpus	= armada_xp_smp_prepare_cpus,
-	.smp_secondary_init	= armada_xp_secondary_init,
 	.smp_boot_secondary	= armada_xp_boot_secondary,
 #ifdef CONFIG_HOTPLUG_CPU
 	.cpu_die		= armada_xp_cpu_die,

commit ef37d337e1d37bd84ccaa5811a8d1f00f8b3677c
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Mon Apr 14 15:54:01 2014 +0200

    irqchip: irq-armada-370-xp: Do the set_smp_cross_call() in the driver
    
    Instead of having the SoC code in arch/arm/mach-mvebu/platsmp.c do the
    set_smp_cross_call() to register the IPI-triggering function, it makes
    more sense to do exactly what the GIC driver is doing: let the irqchip
    driver do it. This way, it avoids having to expose the
    armada_mpic_send_doorbell() function between the irqchip driver and
    the SoC code.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Link: https://lkml.kernel.org/r/1397483648-26611-5-git-send-email-thomas.petazzoni@free-electrons.com
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index a6da03f5b24e..6f06f6ddb51e 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -90,8 +90,6 @@ static void __init armada_xp_smp_init_cpus(void)
 
 	if (ncores == 0 || ncores > ARMADA_XP_MAX_CPUS)
 		panic("Invalid number of CPUs in DT\n");
-
-	set_smp_cross_call(armada_mpic_send_doorbell);
 }
 
 static void __init armada_xp_smp_prepare_cpus(unsigned int max_cpus)

commit b12634e343bea9ce94ed3252fccbac347f8bb37f
Author: Jisheng Zhang <jszhang@marvell.com>
Date:   Thu Nov 7 17:02:38 2013 +0800

    ARM: mvebu: fix some sparse warnings
    
    This patch fixes conflicting types for 'set_cpu_coherent' and fixes the
    following sparse warnings.
    
    arch/arm/mach-mvebu/system-controller.c:42:38:
    warning: symbol 'armada_370_xp_system_controller' was not declared. Should it be static?
    arch/arm/mach-mvebu/system-controller.c:49:38:
    warning: symbol 'orion_system_controller' was not declared. Should it be static?
    arch/arm/mach-mvebu/system-controller.c:67:6:
    warning: symbol 'mvebu_restart' was not declared. Should it be static?
    arch/arm/mach-mvebu/coherency.c:31:15:
    warning: symbol 'coherency_phys_base' was not declared. Should it be static?
    arch/arm/mach-mvebu/coherency.c:48:5:
    warning: symbol 'set_cpu_coherent' was not declared. Should it be static?
    arch/arm/mach-mvebu/coherency.c:123:12:
    warning: symbol 'coherency_init' was not declared. Should it be static?
    arch/arm/mach-mvebu/pmsu.c:38:5: warning:
    symbol 'armada_xp_boot_cpu' was not declared. Should it be static?
    arch/arm/mach-mvebu/pmsu.c:61:12: warning:
    symbol 'armada_370_xp_pmsu_init' was not declared. Should it be static?
    arch/arm/mach-mvebu/platsmp.c:49:13: warning:
    symbol 'set_secondary_cpus_clock' was not declared. Should it be static?
    arch/arm/mach-mvebu/platsmp.c:97:13: warning:
    symbol 'armada_xp_smp_prepare_cpus' was not declared. Should it be static?
    arch/arm/mach-mvebu/hotplug.c:24:12: warning:
    symbol 'armada_xp_cpu_die' was not declared. Should it be static?
    
    Signed-off-by: Jisheng Zhang <jszhang@marvell.com>
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index ff69c2df298b..a6da03f5b24e 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -46,7 +46,7 @@ static struct clk *__init get_cpu_clk(int cpu)
 	return cpu_clk;
 }
 
-void __init set_secondary_cpus_clock(void)
+static void __init set_secondary_cpus_clock(void)
 {
 	int thiscpu, cpu;
 	unsigned long rate;
@@ -94,7 +94,7 @@ static void __init armada_xp_smp_init_cpus(void)
 	set_smp_cross_call(armada_mpic_send_doorbell);
 }
 
-void __init armada_xp_smp_prepare_cpus(unsigned int max_cpus)
+static void __init armada_xp_smp_prepare_cpus(unsigned int max_cpus)
 {
 	struct device_node *node;
 	struct resource res;

commit b4b50fd78b1e31989940dfc647e64453d0f7176a
Merge: dccfd1e439c1 f97c43bbdf8a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 6 13:30:06 2013 -0700

    Merge tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform changes from Olof Johansson:
     "This branch contains mostly additions and changes to platform
      enablement and SoC-level drivers.  Since there's sometimes a
      dependency on device-tree changes, there's also a fair amount of
      those in this branch.
    
      Pieces worth mentioning are:
    
       - Mbus driver for Marvell platforms, allowing kernel configuration
         and resource allocation of on-chip peripherals.
       - Enablement of the mbus infrastructure from Marvell PCI-e drivers.
       - Preparation of MSI support for Marvell platforms.
       - Addition of new PCI-e host controller driver for Tegra platforms
       - Some churn caused by sharing of macro names between i.MX 6Q and 6DL
         platforms in the device tree sources and header files.
       - Various suspend/PM updates for Tegra, including LP1 support.
       - Versatile Express support for MCPM, part of big little support.
       - Allwinner platform support for A20 and A31 SoCs (dual and quad
         Cortex-A7)
       - OMAP2+ support for DRA7, a new Cortex-A15-based SoC.
    
      The code that touches other architectures are patches moving MSI
      arch-specific functions over to weak symbols and removal of
      ARCH_SUPPORTS_MSI, acked by PCI maintainers"
    
    * tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (266 commits)
      tegra-cpuidle: provide stub when !CONFIG_CPU_IDLE
      PCI: tegra: replace devm_request_and_ioremap by devm_ioremap_resource
      ARM: tegra: Drop ARCH_SUPPORTS_MSI and sort list
      ARM: dts: vf610-twr: enable i2c0 device
      ARM: dts: i.MX51: Add one more I2C2 pinmux entry
      ARM: dts: i.MX51: Move pins configuration under "iomuxc" label
      ARM: dtsi: imx6qdl-sabresd: Add USB OTG vbus pin to pinctrl_hog
      ARM: dtsi: imx6qdl-sabresd: Add USB host 1 VBUS regulator
      ARM: dts: imx27-phytec-phycore-som: Enable AUDMUX
      ARM: dts: i.MX27: Disable AUDMUX in the template
      ARM: dts: wandboard: Add support for SDIO bcm4329
      ARM: i.MX5 clocks: Remove optional clock setup (CKIH1) from i.MX51 template
      ARM: dts: imx53-qsb: Make USBH1 functional
      ARM i.MX6Q: dts: Enable I2C1 with EEPROM and PMIC on Phytec phyFLEX-i.MX6 Ouad module
      ARM i.MX6Q: dts: Enable SPI NOR flash on Phytec phyFLEX-i.MX6 Ouad module
      ARM: dts: imx6qdl-sabresd: Add touchscreen support
      ARM: imx: add ocram clock for imx53
      ARM: dts: imx: ocram size is different between imx6q and imx6dl
      ARM: dts: imx27-phytec-phycore-som: Fix regulator settings
      ARM: dts: i.MX27: Remove clock name from CPU node
      ...

commit 8e73e367f7dc50f1d1bc22a63e5764bb4eea9b48
Merge: d2f3e9eb7c9e 7323f219533e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 6 13:21:16 2013 -0700

    Merge tag 'cleanup-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC cleanups from Olof Johansson:
     "This branch contains code cleanups, moves and removals for 3.12.
    
      There's a large number of various cleanups, and a nice net removal of
      13500 lines of code.
    
      Highlights worth mentioning are:
    
       - A series of patches from Stephen Boyd removing the ARM local timer
         API.
       - Move of Qualcomm MSM IOMMU code to drivers/iommu.
       - Samsung PWM driver cleanups from Tomasz Figa, removing legacy PWM
         driver and switching over to the drivers/pwm one.
       - Removal of some unusued auto-generated headers for OMAP2+ (PRM/CM).
    
      There's also a move of a header file out of include/linux/i2c/ to
      platform_data, where it really belongs.  It touches mostly ARM
      platform code for include changes so we took it through our tree"
    
    * tag 'cleanup-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (83 commits)
      ARM: OMAP2+: Add back the define for AM33XX_RST_GLOBAL_WARM_SW_MASK
      gpio: (gpio-pca953x) move header to linux/platform_data/
      arm: zynq: hotplug: Remove unreachable code
      ARM: SAMSUNG: Remove unnecessary exynos4_default_sdhci*()
      tegra: simplify use of devm_ioremap_resource
      ARM: SAMSUNG: Remove plat/regs-timer.h header
      ARM: SAMSUNG: Remove remaining uses of plat/regs-timer.h header
      ARM: SAMSUNG: Remove pwm-clock infrastructure
      ARM: SAMSUNG: Remove old PWM timer platform devices
      pwm: Remove superseded pwm-samsung-legacy driver
      ARM: SAMSUNG: Modify board files to use new PWM platform device
      ARM: SAMSUNG: Rework private data handling in dev-backlight
      pwm: Add new pwm-samsung driver
      ARM: mach-mvebu: remove redundant DT parsing and validation
      ARM: msm: Only compile io.c on platforms that use it
      iommu/msm: Move mach includes to iommu directory
      ARM: msm: Remove devices-iommu.c
      ARM: msm: Move mach/board.h contents to common.h
      ARM: msm: Migrate msm_timer to CLOCKSOURCE_OF_DECLARE
      ARM: msm: Remove TMR and TMR0 static mappings
      ...

commit f6cec7cd0777fa18723fce9d398fa7e53b6ef00c
Author: Sudeep KarkadaNagesha <sudeep.karkadanagesha@arm.com>
Date:   Wed Jul 3 16:01:42 2013 +0100

    ARM: mvebu: remove device tree parsing for cpu nodes
    
    Currently set_secondary_cpus_clock assume the CPU logical ordering
    and the MPDIR in DT are same, which is incorrect.
    
    Since the CPU device nodes can be retrieved in the logical ordering
    using the DT helper, we can remove the devices tree parsing.
    
    This patch removes DT parsing by making use of of_get_cpu_node.
    
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Acked-by: Gregory Clement <gregory.clement@free-electrons.com>
    Signed-off-by: Sudeep KarkadaNagesha <sudeep.karkadanagesha@arm.com>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index ce81d3031405..594b63db4215 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -29,45 +29,40 @@
 #include "pmsu.h"
 #include "coherency.h"
 
+static struct clk *__init get_cpu_clk(int cpu)
+{
+	struct clk *cpu_clk;
+	struct device_node *np = of_get_cpu_node(cpu, NULL);
+
+	if (WARN(!np, "missing cpu node\n"))
+		return NULL;
+	cpu_clk = of_clk_get(np, 0);
+	if (WARN_ON(IS_ERR(cpu_clk)))
+		return NULL;
+	return cpu_clk;
+}
+
 void __init set_secondary_cpus_clock(void)
 {
-	int thiscpu;
+	int thiscpu, cpu;
 	unsigned long rate;
-	struct clk *cpu_clk = NULL;
-	struct device_node *np = NULL;
+	struct clk *cpu_clk;
 
 	thiscpu = smp_processor_id();
-	for_each_node_by_type(np, "cpu") {
-		int err;
-		int cpu;
-
-		err = of_property_read_u32(np, "reg", &cpu);
-		if (WARN_ON(err))
-			return;
-
-		if (cpu == thiscpu) {
-			cpu_clk = of_clk_get(np, 0);
-			break;
-		}
-	}
-	if (WARN_ON(IS_ERR(cpu_clk)))
+	cpu_clk = get_cpu_clk(thiscpu);
+	if (!cpu_clk)
 		return;
 	clk_prepare_enable(cpu_clk);
 	rate = clk_get_rate(cpu_clk);
 
 	/* set all the other CPU clk to the same rate than the boot CPU */
-	for_each_node_by_type(np, "cpu") {
-		int err;
-		int cpu;
-
-		err = of_property_read_u32(np, "reg", &cpu);
-		if (WARN_ON(err))
+	for_each_possible_cpu(cpu) {
+		if (cpu == thiscpu)
+			continue;
+		cpu_clk = get_cpu_clk(cpu);
+		if (!cpu_clk)
 			return;
-
-		if (cpu != thiscpu) {
-			cpu_clk = of_clk_get(np, 0);
-			clk_set_rate(cpu_clk, rate);
-		}
+		clk_set_rate(cpu_clk, rate);
 	}
 }
 

commit fea67d3dfd13bcca4daa62cbafe6f8eb99523217
Merge: 8b2496a22810 a7160b7eaf2d
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Aug 15 23:26:49 2013 -0700

    Merge tag 'soc-3.12' of git://git.infradead.org/linux-mvebu into next/cleanup
    
    From Jason Cooper:
    mvebu soc changes for v3.12
    
     - mvebu
        - cleanup redundant code
    
    * tag 'soc-3.12' of git://git.infradead.org/linux-mvebu:
      ARM: mach-mvebu: remove redundant DT parsing and validation
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit f668adebf43556df9834f254479a44a20294dcf1
Merge: fac2e57742d9 a0cec7867ffd
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Aug 15 23:10:31 2013 -0700

    Merge tag 'drivers-3.12' of git://git.infradead.org/linux-mvebu into next/soc
    
    From Jason Cooper:
    mvebu drivers changes for v3.12
    
     - MBus devicetree bindings
     - devbus update for address decoding window, cleanup
    
    * tag 'drivers-3.12' of git://git.infradead.org/linux-mvebu: (35 commits)
      memory: mvebu-devbus: Remove unused variable
      ARM: mvebu: Relocate PCIe node in Armada 370 RD board
      ARM: mvebu: Fix AXP-WiFi-AP DT for MBUS DT binding
      ARM: mvebu: add support for the AXP WiFi AP board
      ARM: mvebu: use dts pre-processor for mv78230
      PCI: mvebu: Adapt to the new device tree layout
      bus: mvebu-mbus: Add devicetree binding
      ARM: kirkwood: Relocate PCIe device tree nodes
      ARM: kirkwood: Introduce MBUS_ID
      ARM: kirkwood: Introduce MBus DT node
      ARM: kirkwood: Use the preprocessor on device tree files
      ARM: kirkwood: Split DT and legacy MBus initialization
      ARM: mvebu: Relocate Armada 370/XP PCIe device tree nodes
      ARM: mvebu: Relocate Armada 370/XP DeviceBus device tree nodes
      ARM: mvebu: Add BootROM to Armada 370/XP device tree
      ARM: mvebu: Add MBus to Armada 370/XP device tree
      ARM: mvebu: Use the preprocessor on Armada 370/XP device tree files
      ARM: mvebu: Initialize MBus using the DT binding
      ARM: mvebu: Remove the harcoded BootROM window allocation
      bus: mvebu-mbus: Factorize Armada 370/XP data structures
      ...
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit a7160b7eaf2d914e1b552807b9d13acf23b47293
Author: Sudeep KarkadaNagesha <sudeep.karkadanagesha@arm.com>
Date:   Tue Jul 23 12:32:42 2013 +0100

    ARM: mach-mvebu: remove redundant DT parsing and validation
    
    arm_dt_init_cpu_maps parses the device tree, validates and sets the
    cpu_possible_mask appropriately. It is unnecessary to do another DT
    parse to get the number of cpus, use num_possible_cpus instead.
    
    Cc: Gregory Clement <gregory.clement@free-electrons.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Sudeep KarkadaNagesha <sudeep.karkadanagesha@arm.com>
    Acked-by: Gregory Clement <gregory.clement@free-electrons.com>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index 93f2f3ab45f1..9ccbbdb89a4d 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -88,28 +88,11 @@ static int __cpuinit armada_xp_boot_secondary(unsigned int cpu,
 
 static void __init armada_xp_smp_init_cpus(void)
 {
-	struct device_node *np;
-	unsigned int i, ncores;
+	unsigned int ncores = num_possible_cpus();
 
-	np = of_find_node_by_name(NULL, "cpus");
-	if (!np)
-		panic("No 'cpus' node found\n");
-
-	ncores = of_get_child_count(np);
 	if (ncores == 0 || ncores > ARMADA_XP_MAX_CPUS)
 		panic("Invalid number of CPUs in DT\n");
 
-	/* Limit possible CPUs to defconfig */
-	if (ncores > nr_cpu_ids) {
-		pr_warn("SMP: %d CPUs physically present. Only %d configured.",
-			ncores, nr_cpu_ids);
-		pr_warn("Clipping CPU count to %d\n", nr_cpu_ids);
-		ncores = nr_cpu_ids;
-	}
-
-	for (i = 0; i < ncores; i++)
-		set_cpu_possible(i, true);
-
 	set_smp_cross_call(armada_mpic_send_doorbell);
 }
 

commit 994c8c94b419e92a8d661f1fae760dc03e68b442
Author: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
Date:   Fri Jul 26 10:17:54 2013 -0300

    ARM: mvebu: Remove the harcoded BootROM window allocation
    
    The address decoding window to access the BootROM should not be
    allocated programatically, but instead declared in the device tree.
    
    Signed-off-by: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Tested-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index 93f2f3ab45f1..864bd83fa207 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -21,6 +21,7 @@
 #include <linux/smp.h>
 #include <linux/clk.h>
 #include <linux/of.h>
+#include <linux/of_address.h>
 #include <linux/mbus.h>
 #include <asm/cacheflush.h>
 #include <asm/smp_plat.h>
@@ -29,6 +30,9 @@
 #include "pmsu.h"
 #include "coherency.h"
 
+#define AXP_BOOTROM_BASE 0xfff00000
+#define AXP_BOOTROM_SIZE 0x100000
+
 void __init set_secondary_cpus_clock(void)
 {
 	int thiscpu;
@@ -115,10 +119,29 @@ static void __init armada_xp_smp_init_cpus(void)
 
 void __init armada_xp_smp_prepare_cpus(unsigned int max_cpus)
 {
+	struct device_node *node;
+	struct resource res;
+	int err;
+
 	set_secondary_cpus_clock();
 	flush_cache_all();
 	set_cpu_coherent(cpu_logical_map(smp_processor_id()), 0);
-	mvebu_mbus_add_window("bootrom", 0xfff00000, SZ_1M);
+
+	/*
+	 * In order to boot the secondary CPUs we need to ensure
+	 * the bootROM is mapped at the correct address.
+	 */
+	node = of_find_compatible_node(NULL, NULL, "marvell,bootrom");
+	if (!node)
+		panic("Cannot find 'marvell,bootrom' compatible node");
+
+	err = of_address_to_resource(node, 0, &res);
+	if (err < 0)
+		panic("Cannot get 'bootrom' node address");
+
+	if (res.start != AXP_BOOTROM_BASE ||
+	    resource_size(&res) != AXP_BOOTROM_SIZE)
+		panic("The address for the BootROM is incorrect");
 }
 
 struct smp_operations armada_xp_smp_ops __initdata = {

commit 8bd26e3a7e49af2697449bbcb7187a39dc85d672
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jun 17 15:43:14 2013 -0400

    arm: delete __cpuinit/__CPUINIT usage from all ARM users
    
    The __cpuinit type of throwaway sections might have made sense
    some time ago when RAM was more constrained, but now the savings
    do not offset the cost and complications.  For example, the fix in
    commit 5e427ec2d0 ("x86: Fix bit corruption at CPU resume time")
    is a good example of the nasty type of bugs that can be created
    with improper use of the various __init prefixes.
    
    After a discussion on LKML[1] it was decided that cpuinit should go
    the way of devinit and be phased out.  Once all the users are gone,
    we can then finally remove the macros themselves from linux/init.h.
    
    Note that some harmless section mismatch warnings may result, since
    notify_cpu_starting() and cpu_up() are arch independent (kernel/cpu.c)
    and are flagged as __cpuinit  -- so if we remove the __cpuinit from
    the arch specific callers, we will also get section mismatch warnings.
    As an intermediate step, we intend to turn the linux/init.h cpuinit
    related content into no-ops as early as possible, since that will get
    rid of these warnings.  In any case, they are temporary and harmless.
    
    This removes all the ARM uses of the __cpuinit macros from C code,
    and all __CPUINIT from assembly code.  It also had two ".previous"
    section statements that were paired off against __CPUINIT
    (aka .section ".cpuinit.text") that also get removed here.
    
    [1] https://lkml.org/lkml/2013/5/20/589
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index 93f2f3ab45f1..ce81d3031405 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -71,13 +71,12 @@ void __init set_secondary_cpus_clock(void)
 	}
 }
 
-static void __cpuinit armada_xp_secondary_init(unsigned int cpu)
+static void armada_xp_secondary_init(unsigned int cpu)
 {
 	armada_xp_mpic_smp_cpu_init();
 }
 
-static int __cpuinit armada_xp_boot_secondary(unsigned int cpu,
-					      struct task_struct *idle)
+static int armada_xp_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	pr_info("Booting CPU %d\n", cpu);
 

commit b21dcafea36dd6249df9cf485a48c7337a8987af
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Wed Jun 5 09:04:54 2013 +0200

    arm: mvebu: remove dependency of SMP init on static I/O mapping
    
    The ->smp_init_cpus() function is called very early during boot, at a
    point where dynamic I/O mappings are not yet possible. However, in the
    Armada 370/XP implementation of this function, we have to get the
    number of CPUs. We used to do that by accessing a hardware register,
    which requires relying on a static I/O mapping set up by
    ->map_io(). Not only this requires hardcoding a virtual address, but
    it also prevents us from removing the static I/O mapping.
    
    So this commit changes the way used to get the number of CPUs: we now
    use the Device Tree, which is a representation of the hardware, and
    provides us the number of available CPUs. This is also more accurate,
    because it potentially allows to boot the Linux kernel on only a
    number of CPUs given by the Device Tree, instead of unconditionally on
    all CPUs.
    
    As a consequence, the coherency_get_cpu_count() function becomes no
    longer used, so we remove it.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index 875ea748391c..93f2f3ab45f1 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -88,8 +88,16 @@ static int __cpuinit armada_xp_boot_secondary(unsigned int cpu,
 
 static void __init armada_xp_smp_init_cpus(void)
 {
+	struct device_node *np;
 	unsigned int i, ncores;
-	ncores = coherency_get_cpu_count();
+
+	np = of_find_node_by_name(NULL, "cpus");
+	if (!np)
+		panic("No 'cpus' node found\n");
+
+	ncores = of_get_child_count(np);
+	if (ncores == 0 || ncores > ARMADA_XP_MAX_CPUS)
+		panic("Invalid number of CPUs in DT\n");
 
 	/* Limit possible CPUs to defconfig */
 	if (ncores > nr_cpu_ids) {

commit 87e1bed4067e33a4636bffc03689ffb045d586d6
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Thu Mar 21 17:59:15 2013 +0100

    arm: mach-mvebu: convert to use mvebu-mbus driver
    
    The changes needed to migrate the mach-mvebu (Armada 370 and Armada
    XP) to the mvebu-mbus driver are fairly minimal, since not many
    devices currently supported on those SoCs use address decoding
    windows. The only one being the BootROM window, used to bring up
    secondary CPUs.
    
    However, this BootROM window needed for SMP brings an important
    requirement: the mvebu-mbus driver must be initialized at the
    ->early_init() time, otherwise the BootROM window cannot be setup
    early enough to be ready before the secondary CPUs are started.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
index fe16aaf7c19c..875ea748391c 100644
--- a/arch/arm/mach-mvebu/platsmp.c
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -21,6 +21,7 @@
 #include <linux/smp.h>
 #include <linux/clk.h>
 #include <linux/of.h>
+#include <linux/mbus.h>
 #include <asm/cacheflush.h>
 #include <asm/smp_plat.h>
 #include "common.h"
@@ -109,6 +110,7 @@ void __init armada_xp_smp_prepare_cpus(unsigned int max_cpus)
 	set_secondary_cpus_clock();
 	flush_cache_all();
 	set_cpu_coherent(cpu_logical_map(smp_processor_id()), 0);
+	mvebu_mbus_add_window("bootrom", 0xfff00000, SZ_1M);
 }
 
 struct smp_operations armada_xp_smp_ops __initdata = {

commit 45f5984a8a528f7507f3ec860d297934d4449ad1
Author: Gregory CLEMENT <gregory.clement@free-electrons.com>
Date:   Wed Nov 14 22:51:08 2012 +0100

    arm: mvebu: Add SMP support for Armada XP
    
    This enables SMP support on the Armada XP processor. It adds the
    mandatory functions to support SMP such as: the SMP initialization
    functions in platsmp.c, the secondary CPU entry point in headsmp.S and
    the CPU hotplug initial support in hotplug.c.
    
    Signed-off-by: Yehuda Yitschak <yehuday@marvell.com>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Reviewed-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm/mach-mvebu/platsmp.c b/arch/arm/mach-mvebu/platsmp.c
new file mode 100644
index 000000000000..fe16aaf7c19c
--- /dev/null
+++ b/arch/arm/mach-mvebu/platsmp.c
@@ -0,0 +1,122 @@
+/*
+ * Symmetric Multi Processing (SMP) support for Armada XP
+ *
+ * Copyright (C) 2012 Marvell
+ *
+ * Lior Amsalem <alior@marvell.com>
+ * Yehuda Yitschak <yehuday@marvell.com>
+ * Gregory CLEMENT <gregory.clement@free-electrons.com>
+ * Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ *
+ * The Armada XP SoC has 4 ARMv7 PJ4B CPUs running in full HW coherency
+ * This file implements the routines for preparing the SMP infrastructure
+ * and waking up the secondary CPUs
+ */
+
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <asm/cacheflush.h>
+#include <asm/smp_plat.h>
+#include "common.h"
+#include "armada-370-xp.h"
+#include "pmsu.h"
+#include "coherency.h"
+
+void __init set_secondary_cpus_clock(void)
+{
+	int thiscpu;
+	unsigned long rate;
+	struct clk *cpu_clk = NULL;
+	struct device_node *np = NULL;
+
+	thiscpu = smp_processor_id();
+	for_each_node_by_type(np, "cpu") {
+		int err;
+		int cpu;
+
+		err = of_property_read_u32(np, "reg", &cpu);
+		if (WARN_ON(err))
+			return;
+
+		if (cpu == thiscpu) {
+			cpu_clk = of_clk_get(np, 0);
+			break;
+		}
+	}
+	if (WARN_ON(IS_ERR(cpu_clk)))
+		return;
+	clk_prepare_enable(cpu_clk);
+	rate = clk_get_rate(cpu_clk);
+
+	/* set all the other CPU clk to the same rate than the boot CPU */
+	for_each_node_by_type(np, "cpu") {
+		int err;
+		int cpu;
+
+		err = of_property_read_u32(np, "reg", &cpu);
+		if (WARN_ON(err))
+			return;
+
+		if (cpu != thiscpu) {
+			cpu_clk = of_clk_get(np, 0);
+			clk_set_rate(cpu_clk, rate);
+		}
+	}
+}
+
+static void __cpuinit armada_xp_secondary_init(unsigned int cpu)
+{
+	armada_xp_mpic_smp_cpu_init();
+}
+
+static int __cpuinit armada_xp_boot_secondary(unsigned int cpu,
+					      struct task_struct *idle)
+{
+	pr_info("Booting CPU %d\n", cpu);
+
+	armada_xp_boot_cpu(cpu, armada_xp_secondary_startup);
+
+	return 0;
+}
+
+static void __init armada_xp_smp_init_cpus(void)
+{
+	unsigned int i, ncores;
+	ncores = coherency_get_cpu_count();
+
+	/* Limit possible CPUs to defconfig */
+	if (ncores > nr_cpu_ids) {
+		pr_warn("SMP: %d CPUs physically present. Only %d configured.",
+			ncores, nr_cpu_ids);
+		pr_warn("Clipping CPU count to %d\n", nr_cpu_ids);
+		ncores = nr_cpu_ids;
+	}
+
+	for (i = 0; i < ncores; i++)
+		set_cpu_possible(i, true);
+
+	set_smp_cross_call(armada_mpic_send_doorbell);
+}
+
+void __init armada_xp_smp_prepare_cpus(unsigned int max_cpus)
+{
+	set_secondary_cpus_clock();
+	flush_cache_all();
+	set_cpu_coherent(cpu_logical_map(smp_processor_id()), 0);
+}
+
+struct smp_operations armada_xp_smp_ops __initdata = {
+	.smp_init_cpus		= armada_xp_smp_init_cpus,
+	.smp_prepare_cpus	= armada_xp_smp_prepare_cpus,
+	.smp_secondary_init	= armada_xp_secondary_init,
+	.smp_boot_secondary	= armada_xp_boot_secondary,
+#ifdef CONFIG_HOTPLUG_CPU
+	.cpu_die		= armada_xp_cpu_die,
+#endif
+};
