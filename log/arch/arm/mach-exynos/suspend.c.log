commit 45984f0c70ccc03e09f97ee5d0749396547b6594
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Sat Jan 4 16:20:51 2020 +0100

    ARM: samsung: Rename Samsung and Exynos to lowercase
    
    Fix up inconsistent usage of upper and lowercase letters in "Samsung"
    and "Exynos" names.
    
    "SAMSUNG" and "EXYNOS" are not abbreviations but regular trademarked
    names.  Therefore they should be written with lowercase letters starting
    with capital letter.
    
    The lowercase "Exynos" name is promoted by its manufacturer Samsung
    Electronics Co., Ltd., in advertisement materials and on website.
    
    Although advertisement materials usually use uppercase "SAMSUNG", the
    lowercase version is used in all legal aspects (e.g. on Wikipedia and in
    privacy/legal statements on
    https://www.samsung.com/semiconductor/privacy-global/).
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 6a0d3448ea00..3bf14ca78b62 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -3,7 +3,7 @@
 // Copyright (c) 2011-2014 Samsung Electronics Co., Ltd.
 //		http://www.samsung.com
 //
-// EXYNOS - Suspend support
+// Exynos - Suspend support
 //
 // Based on arch/arm/mach-s3c2410/pm.c
 // Copyright (c) 2006 Simtec Electronics

commit a55e040c6f21f55f81c53c56e1d8095df35e1d02
Author: Phong Tran <tranmanphong@gmail.com>
Date:   Tue Jun 25 11:03:45 2019 +0700

    ARM: exynos: Cleanup cppcheck shifting warning
    
    Fix warning from cppcheck tool:
    "Shifting signed 32-bit value by 31 bits is undefined behaviour errors"
    
    Signed-off-by: Phong Tran <tranmanphong@gmail.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 8b1e6ab8504f..6a0d3448ea00 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -285,7 +285,7 @@ static void exynos_pm_set_wakeup_mask(void)
 	 * Set wake-up mask registers
 	 * EXYNOS_EINT_WAKEUP_MASK is set by pinctrl driver in late suspend.
 	 */
-	pmu_raw_writel(exynos_irqwake_intmask & ~(1 << 31), S5P_WAKEUP_MASK);
+	pmu_raw_writel(exynos_irqwake_intmask & ~BIT(31), S5P_WAKEUP_MASK);
 }
 
 static void exynos_pm_enter_sleep_mode(void)

commit 24d2c73ff28bcda48607eacc4bc804002dbf78d9
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jun 19 14:55:29 2019 +0200

    ARM: exynos: Only build MCPM support if used
    
    We get a link error for configurations that enable an Exynos
    SoC that does not require MCPM, but then manually enable
    MCPM anyway without also turning on the arm-cci:
    
    arch/arm/mach-exynos/mcpm-exynos.o: In function `exynos_pm_power_up_setup':
    mcpm-exynos.c:(.text+0x8): undefined reference to `cci_enable_port_for_self'
    
    Change it back to only build the code we actually need, by
    introducing a CONFIG_EXYNOS_MCPM that serves the same purpose
    as the older CONFIG_EXYNOS5420_MCPM.
    
    Fixes: 2997520c2d4e ("ARM: exynos: Set MCPM as mandatory for Exynos542x/5800 SoCs")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index be122af0de8f..8b1e6ab8504f 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -268,7 +268,7 @@ static int exynos5420_cpu_suspend(unsigned long arg)
 	unsigned int cluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);
 	unsigned int cpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);
 
-	if (IS_ENABLED(CONFIG_MCPM)) {
+	if (IS_ENABLED(CONFIG_EXYNOS_MCPM)) {
 		mcpm_set_entry_vector(cpu, cluster, exynos_cpu_resume);
 		mcpm_cpu_suspend();
 	}
@@ -351,7 +351,7 @@ static void exynos5420_pm_prepare(void)
 	exynos_pm_enter_sleep_mode();
 
 	/* ensure at least INFORM0 has the resume address */
-	if (IS_ENABLED(CONFIG_MCPM))
+	if (IS_ENABLED(CONFIG_EXYNOS_MCPM))
 		pmu_raw_writel(__pa_symbol(mcpm_entry_point), S5P_INFORM0);
 
 	tmp = pmu_raw_readl(EXYNOS_L2_OPTION(0));
@@ -455,7 +455,7 @@ static void exynos5420_prepare_pm_resume(void)
 	mpidr = read_cpuid_mpidr();
 	cluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);
 
-	if (IS_ENABLED(CONFIG_MCPM))
+	if (IS_ENABLED(CONFIG_EXYNOS_MCPM))
 		WARN_ON(mcpm_cpu_powered_up());
 
 	if (IS_ENABLED(CONFIG_HW_PERF_EVENTS) && cluster != 0) {

commit 2997520c2d4e4d112e7b237bfa5a17a968ffc4bf
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Tue Apr 9 11:56:02 2019 +0200

    ARM: exynos: Set MCPM as mandatory for Exynos542x/5800 SoCs
    
    Support for Exynos5420/5422/5800 SoCs requires MCPM to properly boot all
    CPU cores on all currectly supported platforms: Peach Pit (Exynos5420),
    Odroid XU3/XU3lite/XU4/HC1 (Exynos5422) and Peach Pi (Exynos5800).
    Without it some CPU cores fail to come online. Remove then the ability to
    disable MCPM and make it mandatory when Exynos542x/5800 support is
    enabled.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 64a57e703fc2..be122af0de8f 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -268,7 +268,7 @@ static int exynos5420_cpu_suspend(unsigned long arg)
 	unsigned int cluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);
 	unsigned int cpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);
 
-	if (IS_ENABLED(CONFIG_EXYNOS5420_MCPM)) {
+	if (IS_ENABLED(CONFIG_MCPM)) {
 		mcpm_set_entry_vector(cpu, cluster, exynos_cpu_resume);
 		mcpm_cpu_suspend();
 	}
@@ -351,7 +351,7 @@ static void exynos5420_pm_prepare(void)
 	exynos_pm_enter_sleep_mode();
 
 	/* ensure at least INFORM0 has the resume address */
-	if (IS_ENABLED(CONFIG_EXYNOS5420_MCPM))
+	if (IS_ENABLED(CONFIG_MCPM))
 		pmu_raw_writel(__pa_symbol(mcpm_entry_point), S5P_INFORM0);
 
 	tmp = pmu_raw_readl(EXYNOS_L2_OPTION(0));
@@ -455,7 +455,7 @@ static void exynos5420_prepare_pm_resume(void)
 	mpidr = read_cpuid_mpidr();
 	cluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);
 
-	if (IS_ENABLED(CONFIG_EXYNOS5420_MCPM))
+	if (IS_ENABLED(CONFIG_MCPM))
 		WARN_ON(mcpm_cpu_powered_up());
 
 	if (IS_ENABLED(CONFIG_HW_PERF_EVENTS) && cluster != 0) {

commit 629266bf7229cd6a550075f5961f95607b823b59
Author: Wen Yang <wen.yang99@zte.com.cn>
Date:   Tue Mar 5 19:33:54 2019 +0800

    ARM: exynos: Fix a leaked reference by adding missing of_node_put
    
    The call to of_get_next_child returns a node pointer with refcount
    incremented thus it must be explicitly decremented after the last
    usage.
    
    Detected by coccinelle with warnings like:
        arch/arm/mach-exynos/firmware.c:201:2-8: ERROR: missing of_node_put;
            acquired a node pointer with refcount incremented on line 193,
            but without a corresponding object release within this function.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Wen Yang <wen.yang99@zte.com.cn>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index c521af625e40..64a57e703fc2 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -669,8 +669,10 @@ void __init exynos_pm_init(void)
 
 	if (WARN_ON(!of_find_property(np, "interrupt-controller", NULL))) {
 		pr_warn("Outdated DT detected, suspend/resume will NOT work\n");
+		of_node_put(np);
 		return;
 	}
+	of_node_put(np);
 
 	pm_data = (const struct exynos_pm_data *) match->data;
 

commit 4d8e3e951a856777720272ce27f2c738a3eeef8c
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Mon Feb 18 15:34:12 2019 +0100

    ARM: exynos: Fix undefined instruction during Exynos5422 resume
    
    During early system resume on Exynos5422 with performance counters enabled
    the following kernel oops happens:
    
        Internal error: Oops - undefined instruction: 0 [#1] PREEMPT SMP ARM
        Modules linked in:
        CPU: 0 PID: 1433 Comm: bash Tainted: G        W         5.0.0-rc5-next-20190208-00023-gd5fb5a8a13e6-dirty #5480
        Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
        ...
        Flags: nZCv  IRQs off  FIQs off  Mode SVC_32  ISA ARM  Segment none
        Control: 10c5387d  Table: 4451006a  DAC: 00000051
        Process bash (pid: 1433, stack limit = 0xb7e0e22f)
        ...
        (reset_ctrl_regs) from [<c0112ad0>] (dbg_cpu_pm_notify+0x1c/0x24)
        (dbg_cpu_pm_notify) from [<c014c840>] (notifier_call_chain+0x44/0x84)
        (notifier_call_chain) from [<c014cbc0>] (__atomic_notifier_call_chain+0x7c/0x128)
        (__atomic_notifier_call_chain) from [<c01ffaac>] (cpu_pm_notify+0x30/0x54)
        (cpu_pm_notify) from [<c055116c>] (syscore_resume+0x98/0x3f4)
        (syscore_resume) from [<c0189350>] (suspend_devices_and_enter+0x97c/0xe74)
        (suspend_devices_and_enter) from [<c0189fb8>] (pm_suspend+0x770/0xc04)
        (pm_suspend) from [<c0187740>] (state_store+0x6c/0xcc)
        (state_store) from [<c09fa698>] (kobj_attr_store+0x14/0x20)
        (kobj_attr_store) from [<c030159c>] (sysfs_kf_write+0x4c/0x50)
        (sysfs_kf_write) from [<c0300620>] (kernfs_fop_write+0xfc/0x1e0)
        (kernfs_fop_write) from [<c0282be8>] (__vfs_write+0x2c/0x160)
        (__vfs_write) from [<c0282ea4>] (vfs_write+0xa4/0x16c)
        (vfs_write) from [<c0283080>] (ksys_write+0x40/0x8c)
        (ksys_write) from [<c0101000>] (ret_fast_syscall+0x0/0x28)
    
    Undefined instruction is triggered during CP14 reset, because bits: #16
    (Secure privileged invasive debug disabled) and #17 (Secure privileged
    noninvasive debug disable) are set in DSCR. Those bits depend on SPNIDEN
    and SPIDEN lines, which are provided by Secure JTAG hardware block. That
    block in turn is powered from cluster 0 (big/Eagle), but the Exynos5422
    boots on cluster 1 (LITTLE/KFC).
    
    To fix this issue it is enough to turn on the power on the cluster 0 for
    a while. This lets the Secure JTAG block to propagate the needed signals
    to LITTLE/KFC cores and change their DSCR.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 42f36843892e..c521af625e40 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -450,8 +450,27 @@ static void exynos3250_pm_resume(void)
 
 static void exynos5420_prepare_pm_resume(void)
 {
+	unsigned int mpidr, cluster;
+
+	mpidr = read_cpuid_mpidr();
+	cluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);
+
 	if (IS_ENABLED(CONFIG_EXYNOS5420_MCPM))
 		WARN_ON(mcpm_cpu_powered_up());
+
+	if (IS_ENABLED(CONFIG_HW_PERF_EVENTS) && cluster != 0) {
+		/*
+		 * When system is resumed on the LITTLE/KFC core (cluster 1),
+		 * the DSCR is not properly updated until the power is turned
+		 * on also for the cluster 0. Enable it for a while to
+		 * propagate the SPNIDEN and SPIDEN signals from Secure JTAG
+		 * block and avoid undefined instruction issue on CP14 reset.
+		 */
+		pmu_raw_writel(S5P_CORE_LOCAL_PWR_EN,
+				EXYNOS_COMMON_CONFIGURATION(0));
+		pmu_raw_writel(0,
+				EXYNOS_COMMON_CONFIGURATION(0));
+	}
 }
 
 static void exynos5420_pm_resume(void)

commit 3a1f2f38fb82b7a3bc7351d7e38df5a1e9c901d2
Author: Joonyoung Shim <jy0922.shim@samsung.com>
Date:   Mon Feb 18 15:34:11 2019 +0100

    ARM: exynos: Add CPU state management for Exynos542x under secure firmware
    
    Add required CPU state management done via secure monitor call for
    Exynos542x running unsed Secure Firmware.
    
    Signed-off-by: Joonyoung Shim <jy0922.shim@samsung.com>
    [mszyprow: rewrote code to use defines and sysram base address instead
     of the magic numbers, added second smc call in pm_resume, rephrased
     subject and commit message]
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index c1e082ab2a1e..42f36843892e 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -31,6 +31,7 @@
 #include <asm/suspend.h>
 
 #include "common.h"
+#include "smc.h"
 
 #define REG_TABLE_END (-1U)
 
@@ -62,6 +63,8 @@ struct exynos_pm_state {
 	int cpu_state;
 	unsigned int pmu_spare3;
 	void __iomem *sysram_base;
+	phys_addr_t sysram_phys;
+	bool secure_firmware;
 };
 
 static const struct exynos_pm_data *pm_data __ro_after_init;
@@ -340,6 +343,10 @@ static void exynos5420_pm_prepare(void)
 	pm_state.cpu_state = readl_relaxed(pm_state.sysram_base +
 					   EXYNOS5420_CPU_STATE);
 	writel_relaxed(0x0, pm_state.sysram_base + EXYNOS5420_CPU_STATE);
+	if (pm_state.secure_firmware)
+		exynos_smc(SMC_CMD_REG, SMC_REG_ID_SFR_W(pm_state.sysram_phys +
+							 EXYNOS5420_CPU_STATE),
+			   0, 0);
 
 	exynos_pm_enter_sleep_mode();
 
@@ -459,6 +466,11 @@ static void exynos5420_pm_resume(void)
 	/* Restore the sysram cpu state register */
 	writel_relaxed(pm_state.cpu_state,
 		       pm_state.sysram_base + EXYNOS5420_CPU_STATE);
+	if (pm_state.secure_firmware)
+		exynos_smc(SMC_CMD_REG,
+			   SMC_REG_ID_SFR_W(pm_state.sysram_phys +
+					    EXYNOS5420_CPU_STATE),
+			   EXYNOS_AFTR_MAGIC, 0);
 
 	pmu_raw_writel(EXYNOS5420_USE_STANDBY_WFI_ALL,
 			S5P_CENTRAL_SEQ_OPTION);
@@ -658,8 +670,11 @@ void __init exynos_pm_init(void)
 	 * Applicable as of now only to Exynos542x. If booted under secure
 	 * firmware, the non-secure region of sysram should be used.
 	 */
-	if (exynos_secure_firmware_available())
+	if (exynos_secure_firmware_available()) {
+		pm_state.sysram_phys = sysram_base_phys;
 		pm_state.sysram_base = sysram_ns_base_addr;
-	else
+		pm_state.secure_firmware = true;
+	} else {
 		pm_state.sysram_base = sysram_base_addr;
+	}
 }

commit e74673120b6b9497f1e044b3cf75d2fb5ed61fc3
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Mon Feb 18 15:34:09 2019 +0100

    ARM: exynos: Move Exynos542x CPU state reset to pm_prepare()
    
    Reset the CPU state entry in sysram in pm_prepare() callback. That entry
    doesn't need to be reset for every suspended CPU, so make it symmetic
    with the code, which restores it in pm_resume() callback.
    
    Tested on Samsung Chromebook2 Pit (Exynos5420) and Pi (Exynos5800)
    boards.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 0850505ac78b..c1e082ab2a1e 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -265,8 +265,6 @@ static int exynos5420_cpu_suspend(unsigned long arg)
 	unsigned int cluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);
 	unsigned int cpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);
 
-	writel_relaxed(0x0, pm_state.sysram_base + EXYNOS5420_CPU_STATE);
-
 	if (IS_ENABLED(CONFIG_EXYNOS5420_MCPM)) {
 		mcpm_set_entry_vector(cpu, cluster, exynos_cpu_resume);
 		mcpm_cpu_suspend();
@@ -341,6 +339,7 @@ static void exynos5420_pm_prepare(void)
 	 */
 	pm_state.cpu_state = readl_relaxed(pm_state.sysram_base +
 					   EXYNOS5420_CPU_STATE);
+	writel_relaxed(0x0, pm_state.sysram_base + EXYNOS5420_CPU_STATE);
 
 	exynos_pm_enter_sleep_mode();
 

commit b1658855f08754dc685bd75d12f0b5b0e2925f3f
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Wed Nov 14 16:30:58 2018 +0100

    ARM: samsung: Limit SAMSUNG_PM_DEBUG config option to non-Exynos platforms
    
    "Samsung PM Suspend debug" feature (controlled by SAMSUNG_PM_DEBUG
    config option) is not working properly (debug messages are not
    displayed after resume) on Exynos platforms because GPIOs restore
    code is not implemented.
    
    Add PLAT_S3C24XX, ARCH_S3C64XX and ARCH_S5PV210 dependencies to
    SAMSUNG_PM_DEBUG config option to hide it on Exynos platforms.
    Then convert Exynos code to not require <plat/pm-common.h>
    header (use pr_debug() directly instead of S3C_PMDBG() macro and
    remove redundant s3c_pm_*() calls).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index edd792d30302..0850505ac78b 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -30,8 +30,6 @@
 #include <asm/smp_scu.h>
 #include <asm/suspend.h>
 
-#include <plat/pm-common.h>
-
 #include "common.h"
 
 #define REG_TABLE_END (-1U)
@@ -498,11 +496,9 @@ static int exynos_suspend_enter(suspend_state_t state)
 	u32 eint_wakeup_mask = exynos_read_eint_wakeup_mask();
 	int ret;
 
-	s3c_pm_debug_init();
-
-	S3C_PMDBG("%s: suspending the system...\n", __func__);
+	pr_debug("%s: suspending the system...\n", __func__);
 
-	S3C_PMDBG("%s: wakeup masks: %08x,%08x\n", __func__,
+	pr_debug("%s: wakeup masks: %08x,%08x\n", __func__,
 		  exynos_irqwake_intmask, eint_wakeup_mask);
 
 	if (exynos_irqwake_intmask == -1U
@@ -512,7 +508,6 @@ static int exynos_suspend_enter(suspend_state_t state)
 		return -EINVAL;
 	}
 
-	s3c_pm_save_uarts();
 	if (pm_data->pm_prepare)
 		pm_data->pm_prepare();
 	flush_cache_all();
@@ -525,12 +520,11 @@ static int exynos_suspend_enter(suspend_state_t state)
 
 	if (pm_data->pm_resume_prepare)
 		pm_data->pm_resume_prepare();
-	s3c_pm_restore_uarts();
 
-	S3C_PMDBG("%s: wakeup stat: %08x\n", __func__,
+	pr_debug("%s: wakeup stat: %08x\n", __func__,
 			pmu_raw_readl(S5P_WAKEUP_STAT));
 
-	S3C_PMDBG("%s: resuming the system...\n", __func__);
+	pr_debug("%s: resuming the system...\n", __func__);
 
 	return 0;
 }

commit 7b981b18a48bdf346b5cdb286d45d1fb91da056f
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Mon Oct 15 15:48:27 2018 +0200

    ARM: exynos: Remove no longer needed s3c_pm_check_*() calls
    
    Since commit 6862fdf2201a ("ARM: samsung: Limit SAMSUNG_PM_CHECK
    config option to non-Exynos platforms") s3c_pm_check_*() calls
    are redundant and can be removed.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index e37834d91071..edd792d30302 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -516,7 +516,6 @@ static int exynos_suspend_enter(suspend_state_t state)
 	if (pm_data->pm_prepare)
 		pm_data->pm_prepare();
 	flush_cache_all();
-	s3c_pm_check_store();
 
 	ret = call_firmware_op(suspend);
 	if (ret == -ENOSYS)
@@ -531,8 +530,6 @@ static int exynos_suspend_enter(suspend_state_t state)
 	S3C_PMDBG("%s: wakeup stat: %08x\n", __func__,
 			pmu_raw_readl(S5P_WAKEUP_STAT));
 
-	s3c_pm_check_restore();
-
 	S3C_PMDBG("%s: resuming the system...\n", __func__);
 
 	return 0;
@@ -556,8 +553,6 @@ static int exynos_suspend_prepare(void)
 		return ret;
 	}
 
-	s3c_pm_check_prepare();
-
 	return 0;
 }
 
@@ -565,8 +560,6 @@ static void exynos_suspend_finish(void)
 {
 	int ret;
 
-	s3c_pm_check_cleanup();
-
 	ret = regulator_suspend_finish();
 	if (ret)
 		pr_warn("Failed to resume regulators from suspend (%d)\n", ret);

commit 2c80920f66f2333dd140715450d220724af3a400
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Mon Jul 23 19:53:01 2018 +0200

    ARM: exynos: Remove legacy setting of external wakeup interrupts
    
    Since Exynos/S5Pv210 pin-controller driver is taking care about setting
    the external wakeup interrupts mask, the legacy code can be removed.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Cc: Tomasz Figa <tomasz.figa@gmail.com>
    Cc: Sylwester Nawrocki <snawrocki@kernel.org>
    Acked-by: Tomasz Figa <tomasz.figa@gmail.com>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index bb8e3985acdb..e37834d91071 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -93,6 +93,11 @@ static const struct exynos_wkup_irq exynos5250_wkup_irq[] = {
 	{ /* sentinel */ },
 };
 
+static u32 exynos_read_eint_wakeup_mask(void)
+{
+	return pmu_raw_readl(EXYNOS_EINT_WAKEUP_MASK);
+}
+
 static int exynos_irq_set_wake(struct irq_data *data, unsigned int state)
 {
 	const struct exynos_wkup_irq *wkup_irq;
@@ -277,8 +282,10 @@ static int exynos5420_cpu_suspend(unsigned long arg)
 
 static void exynos_pm_set_wakeup_mask(void)
 {
-	/* Set wake-up mask registers */
-	pmu_raw_writel(exynos_get_eint_wake_mask(), EXYNOS_EINT_WAKEUP_MASK);
+	/*
+	 * Set wake-up mask registers
+	 * EXYNOS_EINT_WAKEUP_MASK is set by pinctrl driver in late suspend.
+	 */
 	pmu_raw_writel(exynos_irqwake_intmask & ~(1 << 31), S5P_WAKEUP_MASK);
 }
 
@@ -488,6 +495,7 @@ static void exynos5420_pm_resume(void)
 
 static int exynos_suspend_enter(suspend_state_t state)
 {
+	u32 eint_wakeup_mask = exynos_read_eint_wakeup_mask();
 	int ret;
 
 	s3c_pm_debug_init();
@@ -495,10 +503,10 @@ static int exynos_suspend_enter(suspend_state_t state)
 	S3C_PMDBG("%s: suspending the system...\n", __func__);
 
 	S3C_PMDBG("%s: wakeup masks: %08x,%08x\n", __func__,
-			exynos_irqwake_intmask, exynos_get_eint_wake_mask());
+		  exynos_irqwake_intmask, eint_wakeup_mask);
 
 	if (exynos_irqwake_intmask == -1U
-	    && exynos_get_eint_wake_mask() == -1U) {
+	    && eint_wakeup_mask == EXYNOS_EINT_WAKEUP_MASK_DISABLED) {
 		pr_err("%s: No wake-up sources!\n", __func__);
 		pr_err("%s: Aborting sleep\n", __func__);
 		return -EINVAL;

commit e0b35c1ab5ac5f0453d1093770e119bd8d63d85c
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Tue Jul 24 18:49:46 2018 +0200

    ARM: exynos: Fix imprecise abort during Exynos5422 suspend to RAM
    
    Suspend to RAM on Odroid XU3/XU4/HC1 family (Exynos5422) causes
    imprecise abort:
    
            PM: Syncing filesystems ... done.
            Freezing user space processes ... (elapsed 0.003 seconds) done.
            OOM killer disabled.
            Freezing remaining freezable tasks ... (elapsed 0.003 seconds) done.
            wake enabled for irq 139
            Disabling non-boot CPUs ...
            IRQ51 no longer affine to CPU1
            IRQ52 no longer affine to CPU2
            IRQ53 no longer affine to CPU3
            IRQ54 no longer affine to CPU4
            IRQ55 no longer affine to CPU5
            IRQ56 no longer affine to CPU6
            cpu cpu4: Dropping the link to regulator.40
            IRQ57 no longer affine to CPU7
            Unhandled fault: external abort on non-linefetch (0x1008) at 0xf081a028
            Internal error: : 1008 [#1] PREEMPT SMP ARM
    
    with last call trace in exynos_suspend_enter().
    
    The abort is caused by writing to register in secure part of sysram.
    Boards booted under secure firmware (e.g. Hardkernel Odroid boards)
    should access non-secure sysram.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 700d8d91ea93..bb8e3985acdb 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -63,6 +63,7 @@ struct exynos_pm_data {
 struct exynos_pm_state {
 	int cpu_state;
 	unsigned int pmu_spare3;
+	void __iomem *sysram_base;
 };
 
 static const struct exynos_pm_data *pm_data __ro_after_init;
@@ -261,7 +262,7 @@ static int exynos5420_cpu_suspend(unsigned long arg)
 	unsigned int cluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);
 	unsigned int cpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);
 
-	writel_relaxed(0x0, sysram_base_addr + EXYNOS5420_CPU_STATE);
+	writel_relaxed(0x0, pm_state.sysram_base + EXYNOS5420_CPU_STATE);
 
 	if (IS_ENABLED(CONFIG_EXYNOS5420_MCPM)) {
 		mcpm_set_entry_vector(cpu, cluster, exynos_cpu_resume);
@@ -333,7 +334,7 @@ static void exynos5420_pm_prepare(void)
 	 * needs to restore it back in case, the primary cpu fails to
 	 * suspend for any reason.
 	 */
-	pm_state.cpu_state = readl_relaxed(sysram_base_addr +
+	pm_state.cpu_state = readl_relaxed(pm_state.sysram_base +
 					   EXYNOS5420_CPU_STATE);
 
 	exynos_pm_enter_sleep_mode();
@@ -453,7 +454,7 @@ static void exynos5420_pm_resume(void)
 
 	/* Restore the sysram cpu state register */
 	writel_relaxed(pm_state.cpu_state,
-		       sysram_base_addr + EXYNOS5420_CPU_STATE);
+		       pm_state.sysram_base + EXYNOS5420_CPU_STATE);
 
 	pmu_raw_writel(EXYNOS5420_USE_STANDBY_WFI_ALL,
 			S5P_CENTRAL_SEQ_OPTION);
@@ -658,4 +659,13 @@ void __init exynos_pm_init(void)
 
 	register_syscore_ops(&exynos_pm_syscore_ops);
 	suspend_set_ops(&exynos_suspend_ops);
+
+	/*
+	 * Applicable as of now only to Exynos542x. If booted under secure
+	 * firmware, the non-secure region of sysram should be used.
+	 */
+	if (exynos_secure_firmware_available())
+		pm_state.sysram_base = sysram_ns_base_addr;
+	else
+		pm_state.sysram_base = sysram_base_addr;
 }

commit 687b5ae2e6c6682a2b0bda3b31a884ed564f9194
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Tue Jul 24 18:49:44 2018 +0200

    ARM: exynos: Store Exynos5420 register state in one variable
    
    Instead of keeping two static variables put them into one struct which
    later can grow.  This will reduce number of file-scope symbols.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 7ead3acd6fa4..700d8d91ea93 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -59,10 +59,14 @@ struct exynos_pm_data {
 	int (*cpu_suspend)(unsigned long);
 };
 
-static const struct exynos_pm_data *pm_data __ro_after_init;
+/* Used only on Exynos542x/5800 */
+struct exynos_pm_state {
+	int cpu_state;
+	unsigned int pmu_spare3;
+};
 
-static int exynos5420_cpu_state;
-static unsigned int exynos_pmu_spare3;
+static const struct exynos_pm_data *pm_data __ro_after_init;
+static struct exynos_pm_state pm_state;
 
 /*
  * GIC wake-up support
@@ -321,7 +325,7 @@ static void exynos5420_pm_prepare(void)
 	/* Set wake-up mask registers */
 	exynos_pm_set_wakeup_mask();
 
-	exynos_pmu_spare3 = pmu_raw_readl(S5P_PMU_SPARE3);
+	pm_state.pmu_spare3 = pmu_raw_readl(S5P_PMU_SPARE3);
 	/*
 	 * The cpu state needs to be saved and restored so that the
 	 * secondary CPUs will enter low power start. Though the U-Boot
@@ -329,8 +333,8 @@ static void exynos5420_pm_prepare(void)
 	 * needs to restore it back in case, the primary cpu fails to
 	 * suspend for any reason.
 	 */
-	exynos5420_cpu_state = readl_relaxed(sysram_base_addr +
-					     EXYNOS5420_CPU_STATE);
+	pm_state.cpu_state = readl_relaxed(sysram_base_addr +
+					   EXYNOS5420_CPU_STATE);
 
 	exynos_pm_enter_sleep_mode();
 
@@ -448,7 +452,7 @@ static void exynos5420_pm_resume(void)
 		       EXYNOS5_ARM_CORE0_SYS_PWR_REG);
 
 	/* Restore the sysram cpu state register */
-	writel_relaxed(exynos5420_cpu_state,
+	writel_relaxed(pm_state.cpu_state,
 		       sysram_base_addr + EXYNOS5420_CPU_STATE);
 
 	pmu_raw_writel(EXYNOS5420_USE_STANDBY_WFI_ALL,
@@ -457,7 +461,7 @@ static void exynos5420_pm_resume(void)
 	if (exynos_pm_central_resume())
 		goto early_wakeup;
 
-	pmu_raw_writel(exynos_pmu_spare3, S5P_PMU_SPARE3);
+	pmu_raw_writel(pm_state.pmu_spare3, S5P_PMU_SPARE3);
 
 early_wakeup:
 

commit 9e259f9352d52053058a234f7c062c4e4f56dc85
Merge: 5563ae9b39c5 f0fc40aff6fe
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Aug 23 13:44:43 2018 -0700

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM 32-bit SoC platform updates from Olof Johansson:
     "Most of the SoC updates in this cycle are cleanups and moves to more
      modern infrastructure:
    
       - Davinci was moved to common clock framework
    
       - OMAP1-based Amstrad E3 "Superphone" saw a bunch of cleanups to the
         keyboard interface (bitbanged AT keyboard via GPIO).
    
       - Removal of some stale code for Renesas platforms
    
       - Power management improvements for i.MX6LL"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (112 commits)
      ARM: uniphier: select RESET_CONTROLLER
      arm64: uniphier: select RESET_CONTROLLER
      ARM: uniphier: remove empty Makefile
      ARM: exynos: Clear global variable on init error path
      ARM: exynos: Remove outdated maintainer information
      ARM: shmobile: Always enable ARCH_TIMER on SoCs with A7 and/or A15
      ARM: shmobile: r8a7779: hide unused r8a7779_platform_cpu_kill
      soc: r9a06g032: don't build SMP files for non-SMP config
      ARM: shmobile: Add the R9A06G032 SMP enabler driver
      ARM: at91: pm: configure wakeup sources for ULP1 mode
      ARM: at91: pm: add PMC fast startup registers defines
      ARM: at91: pm: Add ULP1 mode support
      ARM: at91: pm: Use ULP0 naming instead of slow clock
      ARM: hisi: handle of_iomap and fix missing of_node_put
      ARM: hisi: check of_iomap and fix missing of_node_put
      ARM: hisi: fix error handling and missing of_node_put
      ARM: mx5: Set the DBGEN bit in ARM_GPC register
      ARM: imx51: Configure M4IF to avoid visual artifacts
      ARM: imx: call imx6sx_cpuidle_init() conditionally for 6sll
      ARM: imx: fix i.MX6SLL build
      ...

commit e5cda42c16d89720c29678f51d95a119490ef7d8
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Mon Jul 23 19:52:57 2018 +0200

    ARM: exynos: Define EINT_WAKEUP_MASK registers for S5Pv210 and Exynos5433
    
    S5Pv210 and Exynos5433/Exynos7 have different address of
    EINT_WAKEUP_MASK register.  Rename existing S5P_EINT_WAKEUP_MASK to
    avoid confusion and add new ones.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Cc: Tomasz Figa <tomasz.figa@gmail.com>
    Cc: Sylwester Nawrocki <snawrocki@kernel.org>
    Acked-by: Tomasz Figa <tomasz.figa@gmail.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index d3db306a5a70..f3384e3a675d 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -272,7 +272,7 @@ static int exynos5420_cpu_suspend(unsigned long arg)
 static void exynos_pm_set_wakeup_mask(void)
 {
 	/* Set wake-up mask registers */
-	pmu_raw_writel(exynos_get_eint_wake_mask(), S5P_EINT_WAKEUP_MASK);
+	pmu_raw_writel(exynos_get_eint_wake_mask(), EXYNOS_EINT_WAKEUP_MASK);
 	pmu_raw_writel(exynos_irqwake_intmask & ~(1 << 31), S5P_WAKEUP_MASK);
 }
 

commit cd4806911cee3901bc2b5eb95603cf1958720b57
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Tue Jul 24 18:48:14 2018 +0200

    ARM: exynos: Clear global variable on init error path
    
    For most of Exynos SoCs, Power Management Unit (PMU) address space is
    mapped into global variable 'pmu_base_addr' very early when initializing
    PMU interrupt controller.  A lot of other machine code depends on it so
    when doing iounmap() on this address, clear the global as well to avoid
    usage of invalid value (pointing to unmapped memory region).
    
    Properly mapped PMU address space is a requirement for all other machine
    code so this fix is purely theoretical.  Boot will fail immediately in
    many other places after following this error path.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index d3db306a5a70..941b0ffd9806 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -203,6 +203,7 @@ static int __init exynos_pmu_irq_init(struct device_node *node,
 					  NULL);
 	if (!domain) {
 		iounmap(pmu_base_addr);
+		pmu_base_addr = NULL;
 		return -ENOMEM;
 	}
 

commit 3c33710b453b4e17074092773872a4d87d9b3bb8
Author: Pankaj Dubey <pankaj.dubey@samsung.com>
Date:   Thu May 10 13:02:54 2018 +0200

    ARM: exynos: Remove static mapping of SCU SFR
    
    Lets remove static mapping of SCU SFR mainly used in CORTEX-A9 SoC based
    boards. Instead use mapping from device tree node of SCU.
    
    Signed-off-by: Pankaj Dubey <pankaj.dubey@samsung.com>
    Reviewed-by: Alim Akhtar <alim.akhtar@samsung.com>
    [mszyprow: rebased, added fallback to scu_a9_get_base() when no SCU DT
     node is available, removed compatibility break warning, fixed non-SMP
     build, keep SCU base mapping to avoid issues with calls from CPUidle]
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index c2ed997fedef..d3db306a5a70 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -30,8 +30,6 @@
 #include <asm/smp_scu.h>
 #include <asm/suspend.h>
 
-#include <mach/map.h>
-
 #include <plat/pm-common.h>
 
 #include "common.h"
@@ -401,7 +399,7 @@ static void exynos_pm_resume(void)
 		goto early_wakeup;
 
 	if (cpuid == ARM_CPU_PART_CORTEX_A9)
-		scu_enable(S5P_VA_SCU);
+		exynos_scu_enable();
 
 	if (call_firmware_op(resume) == -ENOSYS
 	    && cpuid == ARM_CPU_PART_CORTEX_A9)

commit 347863d47a17efa742799da468c64e9673658945
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Mon Dec 25 20:54:31 2017 +0100

    ARM: EXYNOS: Add SPDX license identifiers
    
    Replace GPL license statements with SPDX license identifiers (GPL-2.0
    and GPL-2.0+).
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 370d37ded7e7..c2ed997fedef 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -1,17 +1,13 @@
-/*
- * Copyright (c) 2011-2014 Samsung Electronics Co., Ltd.
- *		http://www.samsung.com
- *
- * EXYNOS - Suspend support
- *
- * Based on arch/arm/mach-s3c2410/pm.c
- * Copyright (c) 2006 Simtec Electronics
- *	Ben Dooks <ben@simtec.co.uk>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2011-2014 Samsung Electronics Co., Ltd.
+//		http://www.samsung.com
+//
+// EXYNOS - Suspend support
+//
+// Based on arch/arm/mach-s3c2410/pm.c
+// Copyright (c) 2006 Simtec Electronics
+//	Ben Dooks <ben@simtec.co.uk>
 
 #include <linux/init.h>
 #include <linux/suspend.h>

commit 9e43eca3c87476f75680f472ff3ebcd85f357b86
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Wed Oct 4 08:38:22 2017 +0200

    ARM: EXYNOS: Remove Exynos4212 related dead code
    
    Support for Exynos4212 SoCs has been removed by commit bca9085e0ae9 ("ARM:
    dts: exynos: remove Exynos4212 support (dead code)"), so there is no need
    to keep remaining dead code related to this SoC version.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index b529ba04ed16..370d37ded7e7 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -225,7 +225,6 @@ static int __init exynos_pmu_irq_init(struct device_node *node,
 
 EXYNOS_PMU_IRQ(exynos3250_pmu_irq, "samsung,exynos3250-pmu");
 EXYNOS_PMU_IRQ(exynos4210_pmu_irq, "samsung,exynos4210-pmu");
-EXYNOS_PMU_IRQ(exynos4212_pmu_irq, "samsung,exynos4212-pmu");
 EXYNOS_PMU_IRQ(exynos4412_pmu_irq, "samsung,exynos4412-pmu");
 EXYNOS_PMU_IRQ(exynos5250_pmu_irq, "samsung,exynos5250-pmu");
 EXYNOS_PMU_IRQ(exynos5420_pmu_irq, "samsung,exynos5420-pmu");
@@ -616,9 +615,6 @@ static const struct of_device_id exynos_pmu_of_device_ids[] __initconst = {
 	}, {
 		.compatible = "samsung,exynos4210-pmu",
 		.data = &exynos4_pm_data,
-	}, {
-		.compatible = "samsung,exynos4212-pmu",
-		.data = &exynos4_pm_data,
 	}, {
 		.compatible = "samsung,exynos4412-pmu",
 		.data = &exynos4_pm_data,

commit a8e65e06ec66f8657795162c51ee73bec116a890
Author: Rob Herring <robh@kernel.org>
Date:   Fri Jul 21 14:28:32 2017 -0500

    ARM: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Acked-by: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Javier Martinez Canillas <javier@osg.samsung.com>
    Cc: Fabio Estevam <fabio.estevam@nxp.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: "Benoît Cousson" <bcousson@baylibre.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 748cfb8d5212..b529ba04ed16 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -187,21 +187,20 @@ static int __init exynos_pmu_irq_init(struct device_node *node,
 	struct irq_domain *parent_domain, *domain;
 
 	if (!parent) {
-		pr_err("%s: no parent, giving up\n", node->full_name);
+		pr_err("%pOF: no parent, giving up\n", node);
 		return -ENODEV;
 	}
 
 	parent_domain = irq_find_host(parent);
 	if (!parent_domain) {
-		pr_err("%s: unable to obtain parent domain\n", node->full_name);
+		pr_err("%pOF: unable to obtain parent domain\n", node);
 		return -ENXIO;
 	}
 
 	pmu_base_addr = of_iomap(node, 0);
 
 	if (!pmu_base_addr) {
-		pr_err("%s: failed to find exynos pmu register\n",
-		       node->full_name);
+		pr_err("%pOF: failed to find exynos pmu register\n", node);
 		return -ENOMEM;
 	}
 

commit d4f4cf77b37eaea58ef863a4cbc95dad3880b524
Merge: f89db789de21 17a870bea3b8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 28 11:50:53 2017 -0800

    Merge branch 'for-linus' of git://git.armlinux.org.uk/~rmk/linux-arm
    
    Pull ARM updates from Russell King:
    
     - nommu updates from Afzal Mohammed cleaning up the vectors support
    
     - allow DMA memory "mapping" for nommu Benjamin Gaignard
    
     - fixing a correctness issue with R_ARM_PREL31 relocations in the
       module linker
    
     - add strlen() prototype for the decompressor
    
     - support for DEBUG_VIRTUAL from Florian Fainelli
    
     - adjusting memory bounds after memory reservations have been
       registered
    
     - unipher cache handling updates from Masahiro Yamada
    
     - initrd and Thumb Kconfig cleanups
    
    * 'for-linus' of git://git.armlinux.org.uk/~rmk/linux-arm: (23 commits)
      ARM: mm: round the initrd reservation to page boundaries
      ARM: mm: clean up initrd initialisation
      ARM: mm: move initrd init code out of arm_memblock_init()
      ARM: 8655/1: improve NOMMU definition of pgprot_*()
      ARM: 8654/1: decompressor: add strlen prototype
      ARM: 8652/1: cache-uniphier: clean up active way setup code
      ARM: 8651/1: cache-uniphier: include <linux/errno.h> instead of <linux/types.h>
      ARM: 8650/1: module: handle negative R_ARM_PREL31 addends correctly
      ARM: 8649/2: nommu: remove Hivecs configuration is asm
      ARM: 8648/2: nommu: display vectors base
      ARM: 8647/2: nommu: dynamic exception base address setting
      ARM: 8646/1: mmu: decouple VECTORS_BASE from Kconfig
      ARM: 8644/1: Reduce "CPU: shutdown" message to debug level
      ARM: 8641/1: treewide: Replace uses of virt_to_phys with __pa_symbol
      ARM: 8640/1: Add support for CONFIG_DEBUG_VIRTUAL
      ARM: 8639/1: Define KERNEL_START and KERNEL_END
      ARM: 8638/1: mtd: lart: Rename partition defines to be prefixed with PART_
      ARM: 8637/1: Adjust memory boundaries after reservations
      ARM: 8636/1: Cleanup sanity_check_meminfo
      ARM: add CPU_THUMB_CAPABLE to indicate possible Thumb support
      ...

commit 64fc2a947a9873700929ec0ef02b4654a04e0476
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sun Jan 15 03:59:29 2017 +0100

    ARM: 8641/1: treewide: Replace uses of virt_to_phys with __pa_symbol
    
    All low-level PM/SMP code using virt_to_phys() should actually use
    __pa_symbol() against kernel symbols. Update code where relevant to move
    away from virt_to_phys().
    
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Laura Abbott <labbott@redhat.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 06332f626565..97765be2cc12 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -344,7 +344,7 @@ static void exynos_pm_prepare(void)
 	exynos_pm_enter_sleep_mode();
 
 	/* ensure at least INFORM0 has the resume address */
-	pmu_raw_writel(virt_to_phys(exynos_cpu_resume), S5P_INFORM0);
+	pmu_raw_writel(__pa_symbol(exynos_cpu_resume), S5P_INFORM0);
 }
 
 static void exynos3250_pm_prepare(void)
@@ -361,7 +361,7 @@ static void exynos3250_pm_prepare(void)
 	exynos_pm_enter_sleep_mode();
 
 	/* ensure at least INFORM0 has the resume address */
-	pmu_raw_writel(virt_to_phys(exynos_cpu_resume), S5P_INFORM0);
+	pmu_raw_writel(__pa_symbol(exynos_cpu_resume), S5P_INFORM0);
 }
 
 static void exynos5420_pm_prepare(void)
@@ -386,7 +386,7 @@ static void exynos5420_pm_prepare(void)
 
 	/* ensure at least INFORM0 has the resume address */
 	if (IS_ENABLED(CONFIG_EXYNOS5420_MCPM))
-		pmu_raw_writel(virt_to_phys(mcpm_entry_point), S5P_INFORM0);
+		pmu_raw_writel(__pa_symbol(mcpm_entry_point), S5P_INFORM0);
 
 	tmp = pmu_raw_readl(EXYNOS5_ARM_L2_OPTION);
 	tmp &= ~EXYNOS5_USE_RETENTION;

commit b2e3c4319d40c9055c3c587cdb82ba69b50e919d
Merge: c61c15e08abb db27dd05b1da
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 23 15:57:04 2017 -0800

    Merge tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC driver updates from Arnd Bergmann:
     "Driver updates for ARM SoCs.
    
      A handful of driver changes this time around. The larger changes are:
    
       - Reset drivers for hi3660 and zx2967
    
       - AHCI driver for Davinci, acked by Tejun and brought in here due to
         platform dependencies
    
       - Cleanups of atmel-ebi (External Bus Interface)
    
       - Tweaks for Rockchip GRF (General Register File) usage (kitchensink
         misc register range on the SoCs)
    
       - PM domains changes for support of two new ZTE SoCs (zx296718 and
         zx2967)"
    
    * tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (53 commits)
      soc: samsung: pmu: Add register defines for pad retention control
      reset: make zx2967 explicitly non-modular
      reset: core: fix reset_control_put
      soc: samsung: pm_domains: Read domain name from the new label property
      soc: samsung: pm_domains: Remove message about failed memory allocation
      soc: samsung: pm_domains: Remove unused name field
      soc: samsung: pm_domains: Use full names in subdomains registration log
      sata: ahci-da850: un-hardcode the MPY bits
      sata: ahci-da850: add a workaround for controller instability
      sata: ahci: export ahci_do_hardreset() locally
      sata: ahci-da850: implement a workaround for the softreset quirk
      sata: ahci-da850: add device tree match table
      sata: ahci-da850: get the sata clock using a connection id
      soc: samsung: pmu: Remove duplicated define for ARM_L2_OPTION register
      memory: atmel-ebi: Enable the SMC clock if specified
      soc: samsung: pmu: Remove unused and duplicated defines
      memory: atmel-ebi: Properly handle multiple reference to the same CS
      memory: atmel-ebi: Fix the test to enable generic SMC logic
      soc: samsung: pm_domains: Add new Exynos5433 compatible
      soc: samsung: pmu: Add dummy support for Exynos5433 SoC
      ...

commit 6ae52c65e01991426e87bb0fb8a2ac9e032db7b1
Merge: af8999f67242 af1d09eefa72
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 23 15:33:54 2017 -0800

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform updates from Arnd Bergmann:
     "In the SoC branch we normally collect classic arch/arm/mach-*
      contents, i.e. C code changes for SoC platforms. This release cycle
      the diffstat is quite nice, in that we're removing 3x the amount of
      code that's being added.
    
      The main reason for this is that there's a removal of camera drivers
      for Freescale i.MX chips (driver was removed so the device
      registration isn't needed any more). There's also removal of display
      initialization code for OMAP that is no longer needed.
    
      The rest are mostly minor tweaks and cleanups; constification on
      Samsung platforms, cleanup of ux500 platform data, purge of other
      unused platform data/device seutp on i.MX and other good stuff.
    
      New SoC support this cycle is for two Allwinner platforms, H2+ and
      V3s"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (55 commits)
      ARM: ux500: remove deleted file from Makefile
      ARM: ep93xx: Disable TS-72xx watchdog before uncompressing
      ARM: ux500: cut some platform data
      MAINTAINERS: Update for the current location of the bcm2835 tree.
      ARM: davinci: remove BUG_ON() from da850_register_sata()
      ARM: davinci: da850: model the SATA refclk
      ARM: davinci: da850: add con_id for the SATA clock
      ARM: davinci: da8xx-dt: add OF_DEV_AUXDATA entry for SATA
      arm: mvebu: support for SMP on 98DX3336 SoC
      dt-bindings: video: exynos7-decon: Remove obsolete samsung,power-domain property
      soc: dove: constify reset_control_ops structures
      ARM: mv78xx0: fix possible PCI buffer overflow
      MAINTAINERS: transfer maintainership for the EZX platform
      ARM: shmobile: rcar-gen2: Add more register documentation
      ARM: tegra: paz00: Fix __initdata placement
      ARM: OMAP: clock: Remove unused mpurate cmdline option
      ARM: davinci: add skeleton for pdata-quirks
      arm: sunxi: add support for V3s SoC
      ARM: OMAP2+: omap_hwmod: Add support for earlycon
      arm: hisi: drop extern hip01_cpu_die
      ...

commit ee55ae6194a5439bde3a3b8ee0abda63c610e740
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Wed Jan 25 21:09:44 2017 +0200

    soc: samsung: pmu: Remove duplicated define for ARM_L2_OPTION register
    
    The register ARM_L2_OPTION (0x2608 in Exynos4 and Exynos5 PMU) was
    defined twice.  Both names were used in the Exynos542x code.  Simplify
    this.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 06332f626565..bf97de884eea 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -388,9 +388,9 @@ static void exynos5420_pm_prepare(void)
 	if (IS_ENABLED(CONFIG_EXYNOS5420_MCPM))
 		pmu_raw_writel(virt_to_phys(mcpm_entry_point), S5P_INFORM0);
 
-	tmp = pmu_raw_readl(EXYNOS5_ARM_L2_OPTION);
-	tmp &= ~EXYNOS5_USE_RETENTION;
-	pmu_raw_writel(tmp, EXYNOS5_ARM_L2_OPTION);
+	tmp = pmu_raw_readl(EXYNOS_L2_OPTION(0));
+	tmp &= ~EXYNOS_L2_USE_RETENTION;
+	pmu_raw_writel(tmp, EXYNOS_L2_OPTION(0));
 
 	tmp = pmu_raw_readl(EXYNOS5420_SFR_AXI_CGDIS1);
 	tmp |= EXYNOS5420_UFS;

commit 07731019c59c06e257aac351d774b2292c251dde
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Thu Jan 26 10:29:25 2017 +0100

    pinctrl: samsung: Move retention control from mach-exynos to the pinctrl driver
    
    This patch moves pad retention control from PMU driver to Exynos pin
    controller driver. This helps to avoid possible ordering and logical
    dependencies between machine, PMU and pin control code. Till now it
    worked fine only because sys_ops for PMU and pin controller were called
    in registration order.
    This is also a preparation for adding new features to Exynos pin
    controller driver, like runtime power management and suspending
    individual pin controllers, which might be a part of some power domain.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Tomasz Figa <tomasz.figa@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 06332f626565..10bc753624be 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -57,7 +57,6 @@ struct exynos_wkup_irq {
 struct exynos_pm_data {
 	const struct exynos_wkup_irq *wkup_irq;
 	unsigned int wake_disable_mask;
-	unsigned int *release_ret_regs;
 
 	void (*pm_prepare)(void);
 	void (*pm_resume_prepare)(void);
@@ -95,47 +94,6 @@ static const struct exynos_wkup_irq exynos5250_wkup_irq[] = {
 	{ /* sentinel */ },
 };
 
-static unsigned int exynos_release_ret_regs[] = {
-	S5P_PAD_RET_MAUDIO_OPTION,
-	S5P_PAD_RET_GPIO_OPTION,
-	S5P_PAD_RET_UART_OPTION,
-	S5P_PAD_RET_MMCA_OPTION,
-	S5P_PAD_RET_MMCB_OPTION,
-	S5P_PAD_RET_EBIA_OPTION,
-	S5P_PAD_RET_EBIB_OPTION,
-	REG_TABLE_END,
-};
-
-static unsigned int exynos3250_release_ret_regs[] = {
-	S5P_PAD_RET_MAUDIO_OPTION,
-	S5P_PAD_RET_GPIO_OPTION,
-	S5P_PAD_RET_UART_OPTION,
-	S5P_PAD_RET_MMCA_OPTION,
-	S5P_PAD_RET_MMCB_OPTION,
-	S5P_PAD_RET_EBIA_OPTION,
-	S5P_PAD_RET_EBIB_OPTION,
-	S5P_PAD_RET_MMC2_OPTION,
-	S5P_PAD_RET_SPI_OPTION,
-	REG_TABLE_END,
-};
-
-static unsigned int exynos5420_release_ret_regs[] = {
-	EXYNOS_PAD_RET_DRAM_OPTION,
-	EXYNOS_PAD_RET_MAUDIO_OPTION,
-	EXYNOS_PAD_RET_JTAG_OPTION,
-	EXYNOS5420_PAD_RET_GPIO_OPTION,
-	EXYNOS5420_PAD_RET_UART_OPTION,
-	EXYNOS5420_PAD_RET_MMCA_OPTION,
-	EXYNOS5420_PAD_RET_MMCB_OPTION,
-	EXYNOS5420_PAD_RET_MMCC_OPTION,
-	EXYNOS5420_PAD_RET_HSI_OPTION,
-	EXYNOS_PAD_RET_EBIA_OPTION,
-	EXYNOS_PAD_RET_EBIB_OPTION,
-	EXYNOS5420_PAD_RET_SPI_OPTION,
-	EXYNOS5420_PAD_RET_DRAM_COREBLK_OPTION,
-	REG_TABLE_END,
-};
-
 static int exynos_irq_set_wake(struct irq_data *data, unsigned int state)
 {
 	const struct exynos_wkup_irq *wkup_irq;
@@ -442,15 +400,6 @@ static int exynos5420_pm_suspend(void)
 	return 0;
 }
 
-static void exynos_pm_release_retention(void)
-{
-	unsigned int i;
-
-	for (i = 0; (pm_data->release_ret_regs[i] != REG_TABLE_END); i++)
-		pmu_raw_writel(EXYNOS_WAKEUP_FROM_LOWPWR,
-				pm_data->release_ret_regs[i]);
-}
-
 static void exynos_pm_resume(void)
 {
 	u32 cpuid = read_cpuid_part();
@@ -458,9 +407,6 @@ static void exynos_pm_resume(void)
 	if (exynos_pm_central_resume())
 		goto early_wakeup;
 
-	/* For release retention */
-	exynos_pm_release_retention();
-
 	if (cpuid == ARM_CPU_PART_CORTEX_A9)
 		scu_enable(S5P_VA_SCU);
 
@@ -482,9 +428,6 @@ static void exynos3250_pm_resume(void)
 	if (exynos_pm_central_resume())
 		goto early_wakeup;
 
-	/* For release retention */
-	exynos_pm_release_retention();
-
 	pmu_raw_writel(S5P_USE_STANDBY_WFI_ALL, S5P_CENTRAL_SEQ_OPTION);
 
 	if (call_firmware_op(resume) == -ENOSYS
@@ -522,9 +465,6 @@ static void exynos5420_pm_resume(void)
 	if (exynos_pm_central_resume())
 		goto early_wakeup;
 
-	/* For release retention */
-	exynos_pm_release_retention();
-
 	pmu_raw_writel(exynos_pmu_spare3, S5P_PMU_SPARE3);
 
 early_wakeup:
@@ -637,7 +577,6 @@ static const struct platform_suspend_ops exynos_suspend_ops = {
 static const struct exynos_pm_data exynos3250_pm_data = {
 	.wkup_irq	= exynos3250_wkup_irq,
 	.wake_disable_mask = ((0xFF << 8) | (0x1F << 1)),
-	.release_ret_regs = exynos3250_release_ret_regs,
 	.pm_suspend	= exynos_pm_suspend,
 	.pm_resume	= exynos3250_pm_resume,
 	.pm_prepare	= exynos3250_pm_prepare,
@@ -647,7 +586,6 @@ static const struct exynos_pm_data exynos3250_pm_data = {
 static const struct exynos_pm_data exynos4_pm_data = {
 	.wkup_irq	= exynos4_wkup_irq,
 	.wake_disable_mask = ((0xFF << 8) | (0x1F << 1)),
-	.release_ret_regs = exynos_release_ret_regs,
 	.pm_suspend	= exynos_pm_suspend,
 	.pm_resume	= exynos_pm_resume,
 	.pm_prepare	= exynos_pm_prepare,
@@ -657,7 +595,6 @@ static const struct exynos_pm_data exynos4_pm_data = {
 static const struct exynos_pm_data exynos5250_pm_data = {
 	.wkup_irq	= exynos5250_wkup_irq,
 	.wake_disable_mask = ((0xFF << 8) | (0x1F << 1)),
-	.release_ret_regs = exynos_release_ret_regs,
 	.pm_suspend	= exynos_pm_suspend,
 	.pm_resume	= exynos_pm_resume,
 	.pm_prepare	= exynos_pm_prepare,
@@ -667,7 +604,6 @@ static const struct exynos_pm_data exynos5250_pm_data = {
 static const struct exynos_pm_data exynos5420_pm_data = {
 	.wkup_irq	= exynos5250_wkup_irq,
 	.wake_disable_mask = (0x7F << 7) | (0x1F << 1),
-	.release_ret_regs = exynos5420_release_ret_regs,
 	.pm_resume_prepare = exynos5420_prepare_pm_resume,
 	.pm_resume	= exynos5420_pm_resume,
 	.pm_suspend	= exynos5420_pm_suspend,

commit 22dfab102cfab6a79c7eb1e57e38f2943dbefa03
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Sat Jan 14 14:36:39 2017 +0200

    ARM: EXYNOS: Remove Exynos4415 arch code (SoC not supported anymore)
    
    Support for Exynos4415 is going away because there are no internal nor
    external users.
    
    Since commit 46dcf0ff0de3 ("ARM: dts: exynos: Remove exynos4415.dtsi"),
    the platform cannot be instantiated so remove also the mach code.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Kukjin Kim <kgene@kernel.org>
    Reviewed-by: Chanwoo Choi <cw00.choi@samsung.com>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 518420241062..25e7c5326259 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -270,7 +270,6 @@ EXYNOS_PMU_IRQ(exynos3250_pmu_irq, "samsung,exynos3250-pmu");
 EXYNOS_PMU_IRQ(exynos4210_pmu_irq, "samsung,exynos4210-pmu");
 EXYNOS_PMU_IRQ(exynos4212_pmu_irq, "samsung,exynos4212-pmu");
 EXYNOS_PMU_IRQ(exynos4412_pmu_irq, "samsung,exynos4412-pmu");
-EXYNOS_PMU_IRQ(exynos4415_pmu_irq, "samsung,exynos4415-pmu");
 EXYNOS_PMU_IRQ(exynos5250_pmu_irq, "samsung,exynos5250-pmu");
 EXYNOS_PMU_IRQ(exynos5420_pmu_irq, "samsung,exynos5420-pmu");
 

commit 731d97c236833c2179ce6fe7a5eb32c46f71df27
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Sat Dec 10 15:47:33 2016 +0200

    ARM: EXYNOS: Annotate iomem and pm_data pointers __ro_after_init
    
    The pointers to __iomem sysram and exynos_pm_data are set only during
    initcalls.  Later the pointers itself are used only in read-only way so
    we can mark them __ro_after_init to increase code safeness.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index be29f06d04f1..518420241062 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -66,7 +66,7 @@ struct exynos_pm_data {
 	int (*cpu_suspend)(unsigned long);
 };
 
-static const struct exynos_pm_data *pm_data;
+static const struct exynos_pm_data *pm_data __ro_after_init;
 
 static int exynos5420_cpu_state;
 static unsigned int exynos_pmu_spare3;

commit b4765037fc8c392027e604cf05771f0ac2790303
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Sat Dec 10 15:47:32 2016 +0200

    ARM: EXYNOS: Constify list of retention registers
    
    The list of retention registers (release_ret_regs field of struct
    exynos_pm_data and arrays with values) are not modified and can be made
    const to improve the const safeness.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 06332f626565..be29f06d04f1 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -57,7 +57,7 @@ struct exynos_wkup_irq {
 struct exynos_pm_data {
 	const struct exynos_wkup_irq *wkup_irq;
 	unsigned int wake_disable_mask;
-	unsigned int *release_ret_regs;
+	const unsigned int *release_ret_regs;
 
 	void (*pm_prepare)(void);
 	void (*pm_resume_prepare)(void);
@@ -95,7 +95,7 @@ static const struct exynos_wkup_irq exynos5250_wkup_irq[] = {
 	{ /* sentinel */ },
 };
 
-static unsigned int exynos_release_ret_regs[] = {
+static const unsigned int exynos_release_ret_regs[] = {
 	S5P_PAD_RET_MAUDIO_OPTION,
 	S5P_PAD_RET_GPIO_OPTION,
 	S5P_PAD_RET_UART_OPTION,
@@ -106,7 +106,7 @@ static unsigned int exynos_release_ret_regs[] = {
 	REG_TABLE_END,
 };
 
-static unsigned int exynos3250_release_ret_regs[] = {
+static const unsigned int exynos3250_release_ret_regs[] = {
 	S5P_PAD_RET_MAUDIO_OPTION,
 	S5P_PAD_RET_GPIO_OPTION,
 	S5P_PAD_RET_UART_OPTION,
@@ -119,7 +119,7 @@ static unsigned int exynos3250_release_ret_regs[] = {
 	REG_TABLE_END,
 };
 
-static unsigned int exynos5420_release_ret_regs[] = {
+static const unsigned int exynos5420_release_ret_regs[] = {
 	EXYNOS_PAD_RET_DRAM_OPTION,
 	EXYNOS_PAD_RET_MAUDIO_OPTION,
 	EXYNOS_PAD_RET_JTAG_OPTION,

commit b030485220caf862c71db6fb8b8ad016ce7f7565
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Sun Aug 21 03:27:45 2016 -0400

    ARM: EXYNOS: Clear OF_POPULATED flag from PMU node in IRQ init callback
    
    The Exynos PMU node is an interrupt, clock and PMU (Power Management Unit)
    controller, and these functionalities are supported by different drivers
    that matches the same compatible strings.
    
    Since commit 15cc2ed6dcf9 ("of/irq: Mark initialised interrupt controllers
    as populated") the OF core flags interrupt controllers registered with the
    IRQCHIP_DECLARE() macro as OF_POPULATED, so platform devices with the same
    compatible string as the interrupt controller will not be registered.
    
    This prevents the PMU platform device to be registered so the Exynos PMU
    driver is never probed. This breaks (among other things) Suspend-to-RAM.
    
    Fix this by clearing the OF_POPULATED flag in the PMU IRQ init callback,
    to allow the Exynos PMU platform driver to be probed. The patch is based
    on Philipp Zabel's "ARM: imx6: mark GPC node as not populated after irq
    init to probe pm domain driver".
    
    Fixes: 15cc2ed6dcf9 ("of/irq: Mark initialised interrupt controllers as populated")
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 3750575c73c5..06332f626565 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -255,6 +255,12 @@ static int __init exynos_pmu_irq_init(struct device_node *node,
 		return -ENOMEM;
 	}
 
+	/*
+	 * Clear the OF_POPULATED flag set in of_irq_init so that
+	 * later the Exynos PMU platform device won't be skipped.
+	 */
+	of_node_clear_flag(node, OF_POPULATED);
+
 	return 0;
 }
 

commit 17e0645e6ba7d7e65ec3f3e77200caf13f57d776
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Tue Jun 21 11:20:28 2016 +0100

    ARM: EXYNOS: Fixup for __raw operations in suspend.c
    
    Fix the PMU code endian access code to deal with kernels built for
    big endian operation by changing the __raw IO accessors to the
    _relaxed variants.
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index f21690937b7d..3750575c73c5 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -301,7 +301,7 @@ static int exynos5420_cpu_suspend(unsigned long arg)
 	unsigned int cluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);
 	unsigned int cpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);
 
-	__raw_writel(0x0, sysram_base_addr + EXYNOS5420_CPU_STATE);
+	writel_relaxed(0x0, sysram_base_addr + EXYNOS5420_CPU_STATE);
 
 	if (IS_ENABLED(CONFIG_EXYNOS5420_MCPM)) {
 		mcpm_set_entry_vector(cpu, cluster, exynos_cpu_resume);
@@ -373,8 +373,8 @@ static void exynos5420_pm_prepare(void)
 	 * needs to restore it back in case, the primary cpu fails to
 	 * suspend for any reason.
 	 */
-	exynos5420_cpu_state = __raw_readl(sysram_base_addr +
-						EXYNOS5420_CPU_STATE);
+	exynos5420_cpu_state = readl_relaxed(sysram_base_addr +
+					     EXYNOS5420_CPU_STATE);
 
 	exynos_pm_enter_sleep_mode();
 
@@ -504,11 +504,11 @@ static void exynos5420_pm_resume(void)
 	/* Restore the CPU0 low power state register */
 	tmp = pmu_raw_readl(EXYNOS5_ARM_CORE0_SYS_PWR_REG);
 	pmu_raw_writel(tmp | S5P_CORE_LOCAL_PWR_EN,
-		EXYNOS5_ARM_CORE0_SYS_PWR_REG);
+		       EXYNOS5_ARM_CORE0_SYS_PWR_REG);
 
 	/* Restore the sysram cpu state register */
-	__raw_writel(exynos5420_cpu_state,
-		sysram_base_addr + EXYNOS5420_CPU_STATE);
+	writel_relaxed(exynos5420_cpu_state,
+		       sysram_base_addr + EXYNOS5420_CPU_STATE);
 
 	pmu_raw_writel(EXYNOS5420_USE_STANDBY_WFI_ALL,
 			S5P_CENTRAL_SEQ_OPTION);

commit 5901f4c279f7ddbd32041ce1166387ffa05b902d
Author: Pankaj Dubey <pankaj.dubey@samsung.com>
Date:   Mon Apr 11 13:12:26 2016 +0530

    ARM: EXYNOS: Remove SROM related register settings from mach-exynos
    
    As now we have dedicated driver for SROM controller, it will take care
    of saving register banks during S2R so we can safely remove these
    settings from mach-exynos.
    
    Signed-off-by: Pankaj Dubey <pankaj.dubey@samsung.com>
    Reviewed-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>
    [k.kozlowski: Need to select also SAMSUNG_MC]
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index fee2b003e662..f21690937b7d 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -34,10 +34,11 @@
 #include <asm/smp_scu.h>
 #include <asm/suspend.h>
 
+#include <mach/map.h>
+
 #include <plat/pm-common.h>
 
 #include "common.h"
-#include "regs-srom.h"
 
 #define REG_TABLE_END (-1U)
 
@@ -53,15 +54,6 @@ struct exynos_wkup_irq {
 	u32 mask;
 };
 
-static struct sleep_save exynos_core_save[] = {
-	/* SROM side */
-	SAVE_ITEM(S5P_SROM_BW),
-	SAVE_ITEM(S5P_SROM_BC0),
-	SAVE_ITEM(S5P_SROM_BC1),
-	SAVE_ITEM(S5P_SROM_BC2),
-	SAVE_ITEM(S5P_SROM_BC3),
-};
-
 struct exynos_pm_data {
 	const struct exynos_wkup_irq *wkup_irq;
 	unsigned int wake_disable_mask;
@@ -343,8 +335,6 @@ static void exynos_pm_prepare(void)
 	/* Set wake-up mask registers */
 	exynos_pm_set_wakeup_mask();
 
-	s3c_pm_do_save(exynos_core_save, ARRAY_SIZE(exynos_core_save));
-
 	exynos_pm_enter_sleep_mode();
 
 	/* ensure at least INFORM0 has the resume address */
@@ -375,8 +365,6 @@ static void exynos5420_pm_prepare(void)
 	/* Set wake-up mask registers */
 	exynos_pm_set_wakeup_mask();
 
-	s3c_pm_do_save(exynos_core_save, ARRAY_SIZE(exynos_core_save));
-
 	exynos_pmu_spare3 = pmu_raw_readl(S5P_PMU_SPARE3);
 	/*
 	 * The cpu state needs to be saved and restored so that the
@@ -467,8 +455,6 @@ static void exynos_pm_resume(void)
 	/* For release retention */
 	exynos_pm_release_retention();
 
-	s3c_pm_do_restore_core(exynos_core_save, ARRAY_SIZE(exynos_core_save));
-
 	if (cpuid == ARM_CPU_PART_CORTEX_A9)
 		scu_enable(S5P_VA_SCU);
 
@@ -535,8 +521,6 @@ static void exynos5420_pm_resume(void)
 
 	pmu_raw_writel(exynos_pmu_spare3, S5P_PMU_SPARE3);
 
-	s3c_pm_do_restore_core(exynos_core_save, ARRAY_SIZE(exynos_core_save));
-
 early_wakeup:
 
 	tmp = pmu_raw_readl(EXYNOS5420_SFR_AXI_CGDIS1);

commit 2262d6ef517f9f0d427015cb9a790b86a2c95fed
Author: Pankaj Dubey <pankaj.dubey@samsung.com>
Date:   Fri Dec 18 09:02:11 2015 +0530

    ARM: EXYNOS: Move pmu specific headers under "linux/soc/samsung"
    
    Moving Exynos PMU specific header file into "include/linux/soc/samsung"
    thus updated affected files under "mach-exynos" to use new location of
    these header files.
    
    Signed-off-by: Amit Daniel Kachhap <amitdanielk@gmail.com>
    [tested on Peach-Pi (Exynos5880)]
    Signed-off-by: Pankaj Dubey <pankaj.dubey@samsung.com>
    Reviewed-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    [for testing on Trats2 (Exynos4412) and Odroid XU3 (Exynos5422)]
    Tested-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index c169cc3049aa..fee2b003e662 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -24,6 +24,8 @@
 #include <linux/of_address.h>
 #include <linux/err.h>
 #include <linux/regulator/machine.h>
+#include <linux/soc/samsung/exynos-pmu.h>
+#include <linux/soc/samsung/exynos-regs-pmu.h>
 
 #include <asm/cacheflush.h>
 #include <asm/hardware/cache-l2x0.h>
@@ -35,8 +37,6 @@
 #include <plat/pm-common.h>
 
 #include "common.h"
-#include "exynos-pmu.h"
-#include "regs-pmu.h"
 #include "regs-srom.h"
 
 #define REG_TABLE_END (-1U)

commit a5e1d715a8d0696961d99d31d869aa522f1cad5a
Merge: 64fd8c8a0ff4 d3dc3df6330e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 10 14:48:36 2015 -0800

    Merge tag 'armsoc-cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC cleanups from Olof Johansson:
     "Again we have a sizable (but not huge) cleanup branch with a net delta
      of about -3k lines.
    
      Main contents here is:
    
       - A bunch of development/cleanup of a few PXA boards
       - Removal of bockw platforms on shmobile, since the platform has now
         gone completely multiplatform.  Whee!
       - move of the 32kHz timer on OMAP to a proper timesource
       - Misc cleanup of older OMAP material (incl removal of one board
         file)
       - Switch over to new common PWM lookup support for several platforms
    
      There's also a handful of other cleanups across the tree, but the
      above are the major pieces"
    
    * tag 'armsoc-cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (103 commits)
      ARM: OMAP3: hwmod data: Remove legacy mailbox data and addrs
      ARM: DRA7: hwmod data: Remove spinlock hwmod addrs
      ARM: OMAP4: hwmod data: Remove spinlock hwmod addrs
      ARM: DRA7/AM335x/AM437x: hwmod: Remove gpmc address space from hwmod data
      ARM: Remove __ref on hotplug cpu die path
      ARM: Remove open-coded version of IRQCHIP_DECLARE
      arm: omap2: board-generic: use omap4_local_timer_init for AM437x
      ARM: DRA7/AM335x/AM437x: hwmod: Remove elm address space from hwmod data
      ARM: OMAP: Remove duplicated operand in OR operation
      clocksource: ti-32k: make it depend on GENERIC_CLOCKSOURCE
      ARM: pxa: remove incorrect __init annotation on pxa27x_set_pwrmode
      ARM: pxa: raumfeld: make some variables static
      ARM: OMAP: Change all cpu_is_* occurences to soc_is_* for id.c
      ARM: OMAP2+: Rename cpu_is macros to soc_is
      arm: omap2: timer: limit hwmod usage to non-DT boots
      arm: omap2+: select 32k clocksource driver
      clocksource: add TI 32.768 Hz counter driver
      arm: omap2: timer: rename omap_sync32k_timer_init()
      arm: omap2: timer: always call clocksource_of_init() when DT
      arm: omap2: timer: move realtime_counter_init() around
      ...

commit 0cc09e85186082d414a89f85ec1b7ff588547f10
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Oct 16 15:21:10 2015 +0100

    ARM: Remove open-coded version of IRQCHIP_DECLARE
    
    Now that the IRQCHIP_DECLARE macro has been moved to linux/irqchip.h,
    it becomes possible to cleanup the open-coded versions of the same
    macro that have been added to some private irqchips implementations.
    
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Acked-by: Kukjin Kim <kgene@kernel.org>
    Acked-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index e00eb39453a4..dfb1fcf4042f 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -19,6 +19,7 @@
 #include <linux/cpu_pm.h>
 #include <linux/io.h>
 #include <linux/irq.h>
+#include <linux/irqchip.h>
 #include <linux/irqdomain.h>
 #include <linux/of_address.h>
 #include <linux/err.h>
@@ -262,7 +263,7 @@ static int __init exynos_pmu_irq_init(struct device_node *node,
 	return 0;
 }
 
-#define EXYNOS_PMU_IRQ(symbol, name)	OF_DECLARE_2(irqchip, symbol, name, exynos_pmu_irq_init)
+#define EXYNOS_PMU_IRQ(symbol, name)	IRQCHIP_DECLARE(symbol, name, exynos_pmu_irq_init)
 
 EXYNOS_PMU_IRQ(exynos3250_pmu_irq, "samsung,exynos3250-pmu");
 EXYNOS_PMU_IRQ(exynos4210_pmu_irq, "samsung,exynos4210-pmu");

commit f833f57ff25450b7161798dceaf8575a48d80249
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Oct 13 12:51:33 2015 +0100

    irqchip: Convert all alloc/xlate users from of_node to fwnode
    
    Since we now have a generic data structure to express an
    interrupt specifier, convert all hierarchical irqchips that
    are OF based to use a fwnode_handle as part of their alloc
    and xlate (which becomes translate) callbacks.
    
    As most of these drivers have dependencies (they exchange IRQ
    specifiers), change them all in a single, massive patch...
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-and-tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Graeme Gregory <graeme@xora.org.uk>
    Cc: Jake Oshins <jakeo@microsoft.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Link: http://lkml.kernel.org/r/1444737105-31573-6-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index af97afc6127a..5a7e47ceec91 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -177,54 +177,57 @@ static struct irq_chip exynos_pmu_chip = {
 #endif
 };
 
-static int exynos_pmu_domain_xlate(struct irq_domain *domain,
-				   struct device_node *controller,
-				   const u32 *intspec,
-				   unsigned int intsize,
-				   unsigned long *out_hwirq,
-				   unsigned int *out_type)
+static int exynos_pmu_domain_translate(struct irq_domain *d,
+				       struct irq_fwspec *fwspec,
+				       unsigned long *hwirq,
+				       unsigned int *type)
 {
-	if (irq_domain_get_of_node(domain) != controller)
-		return -EINVAL;	/* Shouldn't happen, really... */
-	if (intsize != 3)
-		return -EINVAL;	/* Not GIC compliant */
-	if (intspec[0] != 0)
-		return -EINVAL;	/* No PPI should point to this domain */
+	if (is_of_node(fwspec->fwnode)) {
+		if (fwspec->param_count != 3)
+			return -EINVAL;
 
-	*out_hwirq = intspec[1];
-	*out_type = intspec[2];
-	return 0;
+		/* No PPI should point to this domain */
+		if (fwspec->param[0] != 0)
+			return -EINVAL;
+
+		*hwirq = fwspec->param[1];
+		*type = fwspec->param[2];
+		return 0;
+	}
+
+	return -EINVAL;
 }
 
 static int exynos_pmu_domain_alloc(struct irq_domain *domain,
 				   unsigned int virq,
 				   unsigned int nr_irqs, void *data)
 {
-	struct of_phandle_args *args = data;
-	struct of_phandle_args parent_args;
+	struct irq_fwspec *fwspec = data;
+	struct irq_fwspec parent_fwspec;
 	irq_hw_number_t hwirq;
 	int i;
 
-	if (args->args_count != 3)
+	if (fwspec->param_count != 3)
 		return -EINVAL;	/* Not GIC compliant */
-	if (args->args[0] != 0)
+	if (fwspec->param[0] != 0)
 		return -EINVAL;	/* No PPI should point to this domain */
 
-	hwirq = args->args[1];
+	hwirq = fwspec->param[1];
 
 	for (i = 0; i < nr_irqs; i++)
 		irq_domain_set_hwirq_and_chip(domain, virq + i, hwirq + i,
 					      &exynos_pmu_chip, NULL);
 
-	parent_args = *args;
-	parent_args.np = irq_domain_get_of_node(domain->parent);
-	return irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, &parent_args);
+	parent_fwspec = *fwspec;
+	parent_fwspec.fwnode = domain->parent->fwnode;
+	return irq_domain_alloc_irqs_parent(domain, virq, nr_irqs,
+					    &parent_fwspec);
 }
 
 static const struct irq_domain_ops exynos_pmu_domain_ops = {
-	.xlate	= exynos_pmu_domain_xlate,
-	.alloc	= exynos_pmu_domain_alloc,
-	.free	= irq_domain_free_irqs_common,
+	.translate	= exynos_pmu_domain_translate,
+	.alloc		= exynos_pmu_domain_alloc,
+	.free		= irq_domain_free_irqs_common,
 };
 
 static int __init exynos_pmu_irq_init(struct device_node *node,

commit 5d4c9bc7767bc86eb9a0e66df783e3fbada7dc97
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Oct 13 12:51:29 2015 +0100

    irqdomain: Use irq_domain_get_of_node() instead of direct field access
    
    The struct irq_domain contains a "struct device_node *" field
    (of_node) that is almost the only link between the irqdomain
    and the device tree infrastructure.
    
    In order to prepare for the removal of that field, convert all
    users to use irq_domain_get_of_node() instead.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-and-tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Graeme Gregory <graeme@xora.org.uk>
    Cc: Jake Oshins <jakeo@microsoft.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Link: http://lkml.kernel.org/r/1444737105-31573-2-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index e00eb39453a4..af97afc6127a 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -184,7 +184,7 @@ static int exynos_pmu_domain_xlate(struct irq_domain *domain,
 				   unsigned long *out_hwirq,
 				   unsigned int *out_type)
 {
-	if (domain->of_node != controller)
+	if (irq_domain_get_of_node(domain) != controller)
 		return -EINVAL;	/* Shouldn't happen, really... */
 	if (intsize != 3)
 		return -EINVAL;	/* Not GIC compliant */
@@ -217,7 +217,7 @@ static int exynos_pmu_domain_alloc(struct irq_domain *domain,
 					      &exynos_pmu_chip, NULL);
 
 	parent_args = *args;
-	parent_args.np = domain->parent->of_node;
+	parent_args.np = irq_domain_get_of_node(domain->parent);
 	return irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, &parent_args);
 }
 

commit 8ace438f4c0f471e2277b9d3adb017599e2c8e5b
Author: Kukjin Kim <kgene@kernel.org>
Date:   Thu Jul 30 02:00:35 2015 +0900

    ARM: SAMSUNG: local regs-srom header in mach-exynos
    
    This patch moves regs-srom header file into mach-exynos.
    Because it is not used for others except mach-exynos.
    
    Cc: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index c506f8e9c3e5..e00eb39453a4 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -32,11 +32,11 @@
 #include <asm/suspend.h>
 
 #include <plat/pm-common.h>
-#include <plat/regs-srom.h>
 
 #include "common.h"
-#include "regs-pmu.h"
 #include "exynos-pmu.h"
+#include "regs-pmu.h"
+#include "regs-srom.h"
 
 #define REG_TABLE_END (-1U)
 

commit 054e6aa198b4bb42d059951e08f05147b64a79f9
Author: Krzysztof Kozlowski <k.kozlowski.k@gmail.com>
Date:   Sun Jun 14 13:38:23 2015 +0900

    ARM: EXYNOS: Remove duplicated define of SLEEP_MAGIC
    
    The magic cookie for entering sleep state was defined and used in
    two different places: firmware.c and suspend.c. Move it to one common
    place to reduce duplication.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski.k@gmail.com>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index f572219c7a40..c506f8e9c3e5 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -38,8 +38,6 @@
 #include "regs-pmu.h"
 #include "exynos-pmu.h"
 
-#define S5P_CHECK_SLEEP 0x00000BAD
-
 #define REG_TABLE_END (-1U)
 
 #define EXYNOS5420_CPU_STATE	0x28
@@ -331,7 +329,7 @@ static void exynos_pm_enter_sleep_mode(void)
 {
 	/* Set value of power down register for sleep mode */
 	exynos_sys_powerdown_conf(SYS_SLEEP);
-	pmu_raw_writel(S5P_CHECK_SLEEP, S5P_INFORM1);
+	pmu_raw_writel(EXYNOS_SLEEP_MAGIC, S5P_INFORM1);
 }
 
 static void exynos_pm_prepare(void)

commit e8a0b37d28ace440776c0a4fe3c65f5832a9a7ee
Merge: abea9629486c 002af195a8c7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 26 12:20:00 2015 -0700

    Merge branch 'for-linus' of git://ftp.arm.linux.org.uk/~rmk/linux-arm
    
    Pull ARM updates from Russell King:
     "Bigger items included in this update are:
    
       - A series of updates from Arnd for ARM randconfig build failures
       - Updates from Dmitry for StrongARM SA-1100 to move IRQ handling to
         drivers/irqchip/
       - Move ARMs SP804 timer to drivers/clocksource/
       - Perf updates from Mark Rutland in preparation to move the ARM perf
         code into drivers/ so it can be shared with ARM64.
       - MCPM updates from Nicolas
       - Add support for taking platform serial number from DT
       - Re-implement Keystone2 physical address space switch to conform to
         architecture requirements
       - Clean up ARMv7 LPAE code, which goes in hand with the Keystone2
         changes.
       - L2C cleanups to avoid unlocking caches if we're prevented by the
         secure support to unlock.
       - Avoid cleaning a potentially dirty cache containing stale data on
         CPU initialisation
       - Add ARM-only entry point for secondary startup (for machines that
         can only call into a Thumb kernel in ARM mode).  Same thing is also
         done for the resume entry point.
       - Provide arch_irqs_disabled via asm-generic
       - Enlarge ARMv7M vector table
       - Always use BFD linker for VDSO, as gold doesn't accept some of the
         options we need.
       - Fix an incorrect BSYM (for Thumb symbols) usage, and convert all
         BSYM compiler macros to a "badr" (for branch address).
       - Shut up compiler warnings provoked by our cmpxchg() implementation.
       - Ensure bad xchg sizes fail to link"
    
    * 'for-linus' of git://ftp.arm.linux.org.uk/~rmk/linux-arm: (75 commits)
      ARM: Fix build if CLKDEV_LOOKUP is not configured
      ARM: fix new BSYM() usage introduced via for-arm-soc branch
      ARM: 8383/1: nommu: avoid deprecated source register on mov
      ARM: 8391/1: l2c: add options to overwrite prefetching behavior
      ARM: 8390/1: irqflags: Get arch_irqs_disabled from asm-generic
      ARM: 8387/1: arm/mm/dma-mapping.c: Add arm_coherent_dma_mmap
      ARM: 8388/1: tcm: Don't crash when TCM banks are protected by TrustZone
      ARM: 8384/1: VDSO: force use of BFD linker
      ARM: 8385/1: VDSO: group link options
      ARM: cmpxchg: avoid warnings from macro-ized cmpxchg() implementations
      ARM: remove __bad_xchg definition
      ARM: 8369/1: ARMv7M: define size of vector table for Vybrid
      ARM: 8382/1: clocksource: make ARM_TIMER_SP804 depend on GENERIC_SCHED_CLOCK
      ARM: 8366/1: move Dual-Timer SP804 driver to drivers/clocksource
      ARM: 8365/1: introduce sp804_timer_disable and remove arm_timer.h inclusion
      ARM: 8364/1: fix BE32 module loading
      ARM: 8360/1: add secondary_startup_arm prototype in header file
      ARM: 8359/1: correct secondary_startup_arm mode
      ARM: proc-v7: sanitise and document registers around errata
      ARM: proc-v7: clean up MIDR access
      ...

commit 4aa705b18bf17c4ff33ff7bbcd3f0c596443fa81
Merge: c11d71621891 2879e43f0912
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 26 11:34:35 2015 -0700

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform support updates from Kevin Hilman:
     "Our SoC branch usually contains expanded support for new SoCs and
      other core platform code.  Some highlights from this round:
    
       - sunxi: SMP support for A23 SoC
       - socpga: big-endian support
       - pxa: conversion to common clock framework
       - bcm: SMP support for BCM63138
       - imx: support new I.MX7D SoC
       - zte: basic support for ZX296702 SoC"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (134 commits)
      ARM: zx: Add basic defconfig support for ZX296702
      ARM: dts: zx: add an initial zx296702 dts and doc
      clk: zx: add clock support to zx296702
      dt-bindings: Add #defines for ZTE ZX296702 clocks
      ARM: socfpga: fix build error due to secondary_startup
      MAINTAINERS: ARM64: EXYNOS: Extend entry for ARM64 DTS
      ARM: ep93xx: simone: support for SPI-based MMC/SD cards
      MAINTAINERS: update Shawn's email to use kernel.org one
      ARM: socfpga: support suspend to ram
      ARM: socfpga: add CPU_METHOD_OF_DECLARE for Arria 10
      ARM: socfpga: use CPU_METHOD_OF_DECLARE for socfpga_cyclone5
      ARM: EXYNOS: register power domain driver from core_initcall
      ARM: EXYNOS: use PS_HOLD based poweroff for all supported SoCs
      ARM: SAMSUNG: Constify platform_device_id
      ARM: EXYNOS: Constify irq_domain_ops
      ARM: EXYNOS: add coupled cpuidle support for Exynos3250
      ARM: EXYNOS: add exynos_get_boot_addr() helper
      ARM: EXYNOS: add exynos_set_boot_addr() helper
      ARM: EXYNOS: make exynos_core_restart() less verbose
      ARM: EXYNOS: fix exynos_boot_secondary() return value on timeout
      ...

commit fc4a2cc7c3ccb6e02337d9d83365032a131c9da1
Author: Krzysztof Kozlowski <k.kozlowski.k@gmail.com>
Date:   Mon Apr 27 19:48:59 2015 +0900

    ARM: EXYNOS: Constify irq_domain_ops
    
    The irq_domain_ops are not modified by the driver and the irqdomain
    core code accepts pointer to a const data.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski.k@gmail.com>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index c0b6dccbf7bd..f7f6c13df65d 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -223,7 +223,7 @@ static int exynos_pmu_domain_alloc(struct irq_domain *domain,
 	return irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, &parent_args);
 }
 
-static struct irq_domain_ops exynos_pmu_domain_ops = {
+static const struct irq_domain_ops exynos_pmu_domain_ops = {
 	.xlate	= exynos_pmu_domain_xlate,
 	.alloc	= exynos_pmu_domain_alloc,
 	.free	= irq_domain_free_irqs_common,

commit 1a02b6627bb9e7cefc8f7faf884172e8e8d87ac8
Merge: 8f1ab524b1b9 fe931229c61c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jun 1 17:05:43 2015 +0200

    Merge tag 'samsung-fixes-4.1-4' of https://github.com/krzk/linux into fixes
    
    Merge "ARM: EXYNOS: Fix for 4.1, 4th" from Krzysztof Kozlowski:
    
    Fix for Exynos3250 RTC wake-up interrupts after converting PMU
    wakeup to stacked domains. This allows waking up the device from
    suspend to RAM using S3C RTC driver (the RTC on SoC).
    
    The patch should be applied some time ago, unfortunately
    it seems it slipped through fingers.
    
    * tag 'samsung-fixes-4.1-4' of https://github.com/krzk/linux:
      ARM: exynos: Fix wake-up interrupts for Exynos3250

commit fe931229c61c04e0a7906c4ebef9623a4538a5ab
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Wed Apr 22 18:40:52 2015 +0100

    ARM: exynos: Fix wake-up interrupts for Exynos3250
    
    Commit 8b283c025443 (ARM: exynos4/5: convert pmu wakeup to
    stacked domains) changed the Exynos PMU code to use stacked
    domains. This has led to a number of interrupt numbers to be
    fixed.
    
    In the meantime, support for Exynos 3250 was added, missing
    the required change to this platform. This amounts to revert
    ace283a04a4a (ARM: EXYNOS: Fix wrong hwirq of RTC interrupt
    for Exynos3250 SoC), as the initial patch was right, just a
    bit early...
    
    Cc: Chanwoo Choi <cw00.choi@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Cc: Kukjin Kim <kgene@kernel.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-by: Chanwoo Choi <cw00.choi@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 3e6aea7f83af..40dce3628490 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -87,8 +87,8 @@ static unsigned int exynos_pmu_spare3;
 static u32 exynos_irqwake_intmask = 0xffffffff;
 
 static const struct exynos_wkup_irq exynos3250_wkup_irq[] = {
-	{ 105, BIT(1) }, /* RTC alarm */
-	{ 106, BIT(2) }, /* RTC tick */
+	{ 73, BIT(1) }, /* RTC alarm */
+	{ 74, BIT(2) }, /* RTC tick */
 	{ /* sentinel */ },
 };
 

commit 6f024978e74bda616b27183adee029b65eb27032
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Wed Mar 11 11:13:57 2015 +0100

    ARM: EXYNOS: Fix failed second suspend on Exynos4
    
    On Exynos4412 boards (Trats2, Odroid U3) after enabling L2 cache in
    56b60b8bce4a ("ARM: 8265/1: dts: exynos4: Add nodes for L2 cache
    controller") the second suspend to RAM failed. First suspend worked fine
    but the next one hang just after powering down of secondary CPUs (system
    consumed energy as it would be running but was not responsive).
    
    The issue was caused by enabling delayed reset assertion for CPU0 just
    after issuing power down of cores. This was introduced for Exynos4 in
    13cfa6c4f7fa ("ARM: EXYNOS: Fix CPU idle clock down after CPU off").
    
    The whole behavior is not well documented but after checking with vendor
    code this should be done like this (on Exynos4):
    1. Enable delayed reset assertion when system is running (for all CPUs).
    2. Disable delayed reset assertion before suspending the system.
       This can be done after powering off secondary CPUs.
    3. Re-enable the delayed reset assertion when system is resumed.
    
    Fixes: 13cfa6c4f7fa ("ARM: EXYNOS: Fix CPU idle clock down after CPU off")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Tested-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Tested-by: Chanwoo Choi <cw00.choi@samsung.com>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index b6f3ddc3cf8e..c0b6dccbf7bd 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -342,6 +342,8 @@ static void exynos_pm_enter_sleep_mode(void)
 
 static void exynos_pm_prepare(void)
 {
+	exynos_set_delayed_reset_assertion(false);
+
 	/* Set wake-up mask registers */
 	exynos_pm_set_wakeup_mask();
 
@@ -482,6 +484,7 @@ static void exynos_pm_resume(void)
 
 	/* Clear SLEEP mode set in INFORM1 */
 	pmu_raw_writel(0x0, S5P_INFORM1);
+	exynos_set_delayed_reset_assertion(true);
 }
 
 static void exynos3250_pm_resume(void)

commit e5cbec617f1791256197ebaca8b04c0eb96fc574
Author: Julien Grall <julien.grall@citrix.com>
Date:   Wed May 13 03:49:04 2015 +0900

    ARM: EXYNOS: Don't try to initialize suspend on old DT
    
    Since commit 8b283c025443 ("ARM: exynos4/5: convert pmu wakeup to
    stacked domains"), a suspend/resume is not supported on old DT.
    
    Although, rather than printing a warning and continue to boot, the
    kernel will segfault just after:
    
    ------------[ cut here ]------------
    
    WARNING: CPU: 1 PID: 1 at arch/arm/mach-exynos/suspend.c:726 exynos_pm_init+0x4c/0xc8()
    Modules linked in:
    CPU: 1 PID: 1 Comm: swapper/0 Not tainted 4.1.0-rc3 #1
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    [<c02181c4>] (unwind_backtrace) from [<c0213b2c>] (show_stack+0x10/0x14)
    [<c0213b2c>] (show_stack) from [<c0949890>] (dump_stack+0x70/0x8c)
    [<c0949890>] (dump_stack) from [<c024f0b0>] (warn_slowpath_common+0x74/0xac)
    [<c024f0b0>] (warn_slowpath_common) from [<c024f104>] (warn_slowpath_null+0x1c/0x24)
    [<c024f104>] (warn_slowpath_null) from [<c0cf1d28>] (exynos_pm_init+0x4c/0xc8)
    [<c0cf1d28>] (exynos_pm_init) from [<c0ceaae8>] (init_machine_late+0x1c/0x28)
    [<c0ceaae8>] (init_machine_late) from [<c020aa64>] (do_one_initcall+0x80/0x1d0)
    [<c020aa64>] (do_one_initcall) from [<c0ce8d4c>] (kernel_init_freeable+0x10c/0x1d8)
    [<c0ce8d4c>] (kernel_init_freeable) from [<c0944a2c>] (kernel_init+0x8/0xe4)
    [<c0944a2c>] (kernel_init) from [<c0210e60>] (ret_from_fork+0x14/0x34)
    ---[ end trace 335bd937d409f3c7 ]---
    Outdated DT detected, suspend/resume will NOT work
    Unable to handle kernel NULL pointer dereference at virtual address 00000608
    pgd = c0204000
    [00000608] *pgd=00000000
    Internal error: Oops: 5 [#1] SMP ARM
    Modules linked in:
    CPU: 1 PID: 1 Comm: swapper/0 Tainted: G        W       4.1.0-rc3 #1
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    task: db06c000 ti: db05a000 task.ti: db05a000
    PC is at exynos_pm_init+0x6c/0xc8
    LR is at exynos_pm_init+0x54/0xc8
    pc : [<c0cf1d48>]    lr : [<c0cf1d30>]    psr: 60000113
    sp : db05bee8  ip : 00000000  fp : 00000000
    r10: 00000116  r9 : c0dab2d4  r8 : d8d5f440
    r7 : c0db7ad8  r6 : c0db7ad8  r5 : 00000000  r4 : c0ceaacc
    r3 : c0eb2aec  r2 : c0951e40  r1 : 00000000  r0 : c0eb2acc
    Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
    Control: 10c5387d  Table: 6020406a  DAC: 00000015
    Process swapper/0 (pid: 1, stack limit = 0xdb05a220)
    Stack: (0xdb05bee8 to 0xdb05c000)
    bee0:                   c0db7ad8 c0d8fe34 c0cf17c8 c0ceaae8 00000000 c020aa64
    bf00: 00000033 c09580b8 db04fd00 c0ed79a4 c0eb1000 c0ce8588 c0ca2bc4 c0353fcc
    bf20: 00000000 c0df358c 60000113 00000000 dbfffba4 00000000 c0ca2bc4 c026654c
    bf40: c0b80134 c0ca1a64 00000007 00000007 c0df3554 c0d6c2f4 00000007 c0d6c2d4
    bf60: c0eb1000 c0ce8588 c0dab2d4 00000116 00000000 c0ce8d4c 00000007 00000007
    bf80: c0ce8588 c0944a24 00000000 c0944a24 00000000 00000000 00000000 00000000
    bfa0: 00000000 c0944a2c 00000000 c0210e60 00000000 00000000 00000000 00000000
    bfc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    bfe0: 00000000 00000000 00000000 00000000 00000013 00000000 00000000 00000000
    [<c0cf1d48>] (exynos_pm_init) from [<c0ceaae8>] (init_machine_late+0x1c/0x28)
    [<c0ceaae8>] (init_machine_late) from [<c020aa64>] (do_one_initcall+0x80/0x1d0)
    [<c020aa64>] (do_one_initcall) from [<c0ce8d4c>] (kernel_init_freeable+0x10c/0x1d8)
    [<c0ce8d4c>] (kernel_init_freeable) from [<c0944a2c>] (kernel_init+0x8/0xe4)
    [<c0944a2c>] (kernel_init) from [<c0210e60>] (ret_from_fork+0x14/0x34)
    Code: e59f005c e59220c0 e5901000 e5832000 (e591e608)
    ---[ end trace 335bd937d409f3c8 ]---
    
    This is happening because pmu_base_addr is only initialized when the
    PMU is an interrupt controller. It's not the case on old DT.
    
    Signed-off-by: Julien Grall <julien.grall@citrix.com>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 3e6aea7f83af..b6f3ddc3cf8e 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -723,8 +723,10 @@ void __init exynos_pm_init(void)
 		return;
 	}
 
-	if (WARN_ON(!of_find_property(np, "interrupt-controller", NULL)))
+	if (WARN_ON(!of_find_property(np, "interrupt-controller", NULL))) {
 		pr_warn("Outdated DT detected, suspend/resume will NOT work\n");
+		return;
+	}
 
 	pm_data = (const struct exynos_pm_data *) match->data;
 

commit 7895f73169ade9a74940ae6b0b4ee82faf286861
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Tue Apr 28 15:51:19 2015 -0400

    ARM: MCPM: remove residency argument from mcpm_cpu_suspend()
    
    This is currently unused.
    
    If a suspend must be limited to CPU level only by preventing the last man
    from triggering a cluster level suspend then this should be determined
    according to many other criteria the MCPM layer is currently not aware of.
    It is unlikely that mcpm_cpu_suspend() would be the proper conduit for
    that information anyway.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Dave Martin <Dave.Martin@arm.com>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 3e6aea7f83af..372bd0b099c1 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -311,13 +311,7 @@ static int exynos5420_cpu_suspend(unsigned long arg)
 
 	if (IS_ENABLED(CONFIG_EXYNOS5420_MCPM)) {
 		mcpm_set_entry_vector(cpu, cluster, exynos_cpu_resume);
-
-		/*
-		 * Residency value passed to mcpm_cpu_suspend back-end
-		 * has to be given clear semantics. Set to 0 as a
-		 * temporary value.
-		 */
-		mcpm_cpu_suspend(0);
+		mcpm_cpu_suspend();
 	}
 
 	pr_info("Failed to suspend the system\n");

commit e6c81cce5699ec6be3a7533b5ad7a062ab3357f2
Merge: d0440c59f52d a018bb2ff958
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 22 09:08:39 2015 -0700

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform updates from Olof Johansson:
     "Our SoC branch usually contains expanded support for new SoCs and
      other core platform code.  In this case, that includes:
    
       - support for the new Annapurna Labs "Alpine" platform
    
       - a rework greatly simplifying adding new platform support to the
         MCPM subsystem (Multi-cluster power management)
    
       - cpuidle and PM improvements for Exynos3250
    
       - misc updates for Renesas, OMAP, Meson, i.MX.  Some of these could
         have gone in other branches but ended up here for various reasons"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (53 commits)
      ARM: alpine: add support for generic pci
      ARM: Exynos: migrate DCSCB to the new MCPM backend abstraction
      ARM: vexpress: migrate DCSCB to the new MCPM backend abstraction
      ARM: vexpress: DCSCB: tighten CPU validity assertion
      ARM: vexpress: migrate TC2 to the new MCPM backend abstraction
      ARM: MCPM: move the algorithmic complexity to the core code
      ARM: EXYNOS: allow cpuidle driver usage on Exynos3250 SoC
      ARM: EXYNOS: add AFTR mode support for Exynos3250
      ARM: EXYNOS: add code for setting/clearing boot flag
      ARM: EXYNOS: fix CPU1 hotplug on Exynos3250
      ARM: S3C64XX: Use fixed IRQ bases to avoid conflicts on Cragganmore
      ARM: cygnus: fix const declaration bcm_cygnus_dt_compat
      ARM: DRA7: hwmod: Fix the hwmod class for GPTimer4
      ARM: DRA7: hwmod: Add data for GPTimers 13 through 16
      ARM: EXYNOS: Remove left over 'extra_save'
      ARM: EXYNOS: Constify exynos_pm_data array
      ARM: EXYNOS: use static in suspend.c
      ARM: EXYNOS: Use platform device name as power domain name
      ARM: EXYNOS: add support for async-bridge clocks for pm_domains
      ARM: omap-device: add missed callback for suspend-to-disk
      ...

commit b7dccbea6b079be01e07921264709f249009b8e8
Merge: 425b655ce479 a01e7b3258be
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Apr 11 11:17:28 2015 +0200

    Merge tag 'irqchip-core-4.1-3' of git://git.infradead.org/users/jcooper/linux into irq/core
    
    irqchip core change for v4.1 (round 3) from Jason Cooper
    
     Purge the gic_arch_extn hacks and abuse by using the new stacked domains
    
       NOTE: Due to the nature of these changes, patches crossing subsystems have
             been kept together in their own branches.
    
        - tegra
           - Handle the LIC properly
    
        - omap
           - Convert crossbar to stacked domains
           - kill arm,routable-irqs in GIC binding
    
        - exynos
           - Convert PMU wakeup to stacked domains
    
        - shmobile, ux500, zynq (irq_set_wake branch)
           - Switch from abusing gic_arch_extn to using gic_set_irqchip_flags

commit 8b283c025443e4c3a3323c92777f422fa504caa5
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Wed Mar 11 15:44:52 2015 +0000

    ARM: exynos4/5: convert pmu wakeup to stacked domains
    
    Exynos has been (ab)using the gic_arch_extn to provide
    wakeup from suspend, and it makes a lot of sense to convert
    this code to use stacked domains instead.
    
    This patch does just this, updating the DT files to actually
    reflect what the HW provides.
    
    BIG FAT WARNING: because the DTs were so far lying by not
    exposing the fact that the PMU block is actually the first
    interrupt controller in the chain for RTC, kernels with this patch
    applied wont have any suspend-resume facility when booted
    with old DTs, and old kernels with updated DTs may not even boot.
    
    Also, I strongly suspect that there is more than two wake-up
    interrupts on these platforms, but I leave it to the maintainers
    to fix their mess.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Link: https://lkml.kernel.org/r/1426088693-15724-2-git-send-email-marc.zyngier@arm.com
    [ jac: squash in maz's fixup from
      https://lkml.kernel.org/r/5506989D.9050703@arm.com ]
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 52e2b1a2fddb..7b09e7631245 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -18,7 +18,9 @@
 #include <linux/syscore_ops.h>
 #include <linux/cpu_pm.h>
 #include <linux/io.h>
-#include <linux/irqchip/arm-gic.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/of_address.h>
 #include <linux/err.h>
 #include <linux/regulator/machine.h>
 
@@ -43,8 +45,8 @@
 #define EXYNOS5420_CPU_STATE	0x28
 
 /**
- * struct exynos_wkup_irq - Exynos GIC to PMU IRQ mapping
- * @hwirq: Hardware IRQ signal of the GIC
+ * struct exynos_wkup_irq - PMU IRQ to mask mapping
+ * @hwirq: Hardware IRQ signal of the PMU
  * @mask: Mask in PMU wake-up mask register
  */
 struct exynos_wkup_irq {
@@ -93,14 +95,14 @@ static const struct exynos_wkup_irq exynos3250_wkup_irq[] = {
 };
 
 static const struct exynos_wkup_irq exynos4_wkup_irq[] = {
-	{ 76, BIT(1) }, /* RTC alarm */
-	{ 77, BIT(2) }, /* RTC tick */
+	{ 44, BIT(1) }, /* RTC alarm */
+	{ 45, BIT(2) }, /* RTC tick */
 	{ /* sentinel */ },
 };
 
 static const struct exynos_wkup_irq exynos5250_wkup_irq[] = {
-	{ 75, BIT(1) }, /* RTC alarm */
-	{ 76, BIT(2) }, /* RTC tick */
+	{ 43, BIT(1) }, /* RTC alarm */
+	{ 44, BIT(2) }, /* RTC tick */
 	{ /* sentinel */ },
 };
 
@@ -167,6 +169,113 @@ static int exynos_irq_set_wake(struct irq_data *data, unsigned int state)
 	return -ENOENT;
 }
 
+static struct irq_chip exynos_pmu_chip = {
+	.name			= "PMU",
+	.irq_eoi		= irq_chip_eoi_parent,
+	.irq_mask		= irq_chip_mask_parent,
+	.irq_unmask		= irq_chip_unmask_parent,
+	.irq_retrigger		= irq_chip_retrigger_hierarchy,
+	.irq_set_wake		= exynos_irq_set_wake,
+#ifdef CONFIG_SMP
+	.irq_set_affinity	= irq_chip_set_affinity_parent,
+#endif
+};
+
+static int exynos_pmu_domain_xlate(struct irq_domain *domain,
+				   struct device_node *controller,
+				   const u32 *intspec,
+				   unsigned int intsize,
+				   unsigned long *out_hwirq,
+				   unsigned int *out_type)
+{
+	if (domain->of_node != controller)
+		return -EINVAL;	/* Shouldn't happen, really... */
+	if (intsize != 3)
+		return -EINVAL;	/* Not GIC compliant */
+	if (intspec[0] != 0)
+		return -EINVAL;	/* No PPI should point to this domain */
+
+	*out_hwirq = intspec[1];
+	*out_type = intspec[2];
+	return 0;
+}
+
+static int exynos_pmu_domain_alloc(struct irq_domain *domain,
+				   unsigned int virq,
+				   unsigned int nr_irqs, void *data)
+{
+	struct of_phandle_args *args = data;
+	struct of_phandle_args parent_args;
+	irq_hw_number_t hwirq;
+	int i;
+
+	if (args->args_count != 3)
+		return -EINVAL;	/* Not GIC compliant */
+	if (args->args[0] != 0)
+		return -EINVAL;	/* No PPI should point to this domain */
+
+	hwirq = args->args[1];
+
+	for (i = 0; i < nr_irqs; i++)
+		irq_domain_set_hwirq_and_chip(domain, virq + i, hwirq + i,
+					      &exynos_pmu_chip, NULL);
+
+	parent_args = *args;
+	parent_args.np = domain->parent->of_node;
+	return irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, &parent_args);
+}
+
+static struct irq_domain_ops exynos_pmu_domain_ops = {
+	.xlate	= exynos_pmu_domain_xlate,
+	.alloc	= exynos_pmu_domain_alloc,
+	.free	= irq_domain_free_irqs_common,
+};
+
+static int __init exynos_pmu_irq_init(struct device_node *node,
+				      struct device_node *parent)
+{
+	struct irq_domain *parent_domain, *domain;
+
+	if (!parent) {
+		pr_err("%s: no parent, giving up\n", node->full_name);
+		return -ENODEV;
+	}
+
+	parent_domain = irq_find_host(parent);
+	if (!parent_domain) {
+		pr_err("%s: unable to obtain parent domain\n", node->full_name);
+		return -ENXIO;
+	}
+
+	pmu_base_addr = of_iomap(node, 0);
+
+	if (!pmu_base_addr) {
+		pr_err("%s: failed to find exynos pmu register\n",
+		       node->full_name);
+		return -ENOMEM;
+	}
+
+	domain = irq_domain_add_hierarchy(parent_domain, 0, 0,
+					  node, &exynos_pmu_domain_ops,
+					  NULL);
+	if (!domain) {
+		iounmap(pmu_base_addr);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+#define EXYNOS_PMU_IRQ(symbol, name)	OF_DECLARE_2(irqchip, symbol, name, exynos_pmu_irq_init)
+
+EXYNOS_PMU_IRQ(exynos3250_pmu_irq, "samsung,exynos3250-pmu");
+EXYNOS_PMU_IRQ(exynos4210_pmu_irq, "samsung,exynos4210-pmu");
+EXYNOS_PMU_IRQ(exynos4212_pmu_irq, "samsung,exynos4212-pmu");
+EXYNOS_PMU_IRQ(exynos4412_pmu_irq, "samsung,exynos4412-pmu");
+EXYNOS_PMU_IRQ(exynos4415_pmu_irq, "samsung,exynos4415-pmu");
+EXYNOS_PMU_IRQ(exynos5250_pmu_irq, "samsung,exynos5250-pmu");
+EXYNOS_PMU_IRQ(exynos5420_pmu_irq, "samsung,exynos5420-pmu");
+
 static int exynos_cpu_do_idle(void)
 {
 	/* issue the standby signal into the pm unit. */
@@ -615,17 +724,19 @@ static struct syscore_ops exynos_pm_syscore_ops;
 void __init exynos_pm_init(void)
 {
 	const struct of_device_id *match;
+	struct device_node *np;
 	u32 tmp;
 
-	of_find_matching_node_and_match(NULL, exynos_pmu_of_device_ids, &match);
-	if (!match) {
+	np = of_find_matching_node_and_match(NULL, exynos_pmu_of_device_ids, &match);
+	if (!np) {
 		pr_err("Failed to find PMU node\n");
 		return;
 	}
-	pm_data = (struct exynos_pm_data *) match->data;
 
-	/* Platform-specific GIC callback */
-	gic_arch_extn.irq_set_wake = exynos_irq_set_wake;
+	if (WARN_ON(!of_find_property(np, "interrupt-controller", NULL)))
+		pr_warn("Outdated DT detected, suspend/resume will NOT work\n");
+
+	pm_data = (struct exynos_pm_data *) match->data;
 
 	/* All wakeup disable */
 	tmp = pmu_raw_readl(S5P_WAKEUP_MASK);

commit 1cd3de0a27687e07457fd561e61480d2d2278875
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Wed Mar 18 02:34:38 2015 +0900

    ARM: EXYNOS: Remove left over 'extra_save'
    
    Since 32b0aa9aaeb4 ("ARM: EXYNOS: Remove i2c sys configuration related
    code") the Exynos 5250 no longer saves additional registers under
    'exynos_pm_data.extra_save' field.
    
    No one else uses this code so get rid of it making also 'exynos_pm_data'
    const everywhere.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Reviewed-by: Pankaj Dubey <pankaj.dubey@samsung.com>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 3800fd3d7760..89a6d3fb3284 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -63,8 +63,6 @@ static struct sleep_save exynos_core_save[] = {
 
 struct exynos_pm_data {
 	const struct exynos_wkup_irq *wkup_irq;
-	struct sleep_save *extra_save;
-	int num_extra_save;
 	unsigned int wake_disable_mask;
 	unsigned int *release_ret_regs;
 
@@ -75,7 +73,7 @@ struct exynos_pm_data {
 	int (*cpu_suspend)(unsigned long);
 };
 
-static struct exynos_pm_data *pm_data;
+static const struct exynos_pm_data *pm_data;
 
 static int exynos5420_cpu_state;
 static unsigned int exynos_pmu_spare3;
@@ -240,10 +238,6 @@ static void exynos_pm_prepare(void)
 
 	s3c_pm_do_save(exynos_core_save, ARRAY_SIZE(exynos_core_save));
 
-	 if (pm_data->extra_save)
-		s3c_pm_do_save(pm_data->extra_save,
-				pm_data->num_extra_save);
-
 	exynos_pm_enter_sleep_mode();
 
 	/* ensure at least INFORM0 has the resume address */
@@ -366,10 +360,6 @@ static void exynos_pm_resume(void)
 	/* For release retention */
 	exynos_pm_release_retention();
 
-	if (pm_data->extra_save)
-		s3c_pm_do_restore_core(pm_data->extra_save,
-					pm_data->num_extra_save);
-
 	s3c_pm_do_restore_core(exynos_core_save, ARRAY_SIZE(exynos_core_save));
 
 	if (cpuid == ARM_CPU_PART_CORTEX_A9)
@@ -622,7 +612,7 @@ void __init exynos_pm_init(void)
 		pr_err("Failed to find PMU node\n");
 		return;
 	}
-	pm_data = (struct exynos_pm_data *) match->data;
+	pm_data = (const struct exynos_pm_data *) match->data;
 
 	/* Platform-specific GIC callback */
 	gic_arch_extn.irq_set_wake = exynos_irq_set_wake;

commit 7383833784e9ce894563d4827ea79ab41fadfbd7
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Wed Mar 18 02:34:37 2015 +0900

    ARM: EXYNOS: Constify exynos_pm_data array
    
    The 'exynos5420_pm_data' is not modified and can be made const.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Reviewed-by: Pankaj Dubey <pankaj.dubey@samsung.com>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index f2f1201d8d33..3800fd3d7760 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -576,7 +576,7 @@ static const struct exynos_pm_data exynos5250_pm_data = {
 	.cpu_suspend	= exynos_cpu_suspend,
 };
 
-static struct exynos_pm_data exynos5420_pm_data = {
+static const struct exynos_pm_data exynos5420_pm_data = {
 	.wkup_irq	= exynos5250_wkup_irq,
 	.wake_disable_mask = (0x7F << 7) | (0x1F << 1),
 	.release_ret_regs = exynos5420_release_ret_regs,

commit 8c8a251130f173a69b7df4c3225668e39708f743
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Wed Mar 18 02:32:40 2015 +0900

    ARM: EXYNOS: use static in suspend.c
    
    The 'pm_data', 'exynos_release_ret_regs', 'exynos3250_release_ret_regs'
    and 'exynos5420_release_ret_regs' are not exported nor used outside of
    suspend.c file. Make them static.
    
    This fixes following sparse warnings:
    arch/arm/mach-exynos/suspend.c:83:23: warning: symbol 'pm_data' was not declared. Should it be static?
    arch/arm/mach-exynos/suspend.c:106:14: warning: symbol 'exynos_release_ret_regs' was not declared. Should it be static?
    arch/arm/mach-exynos/suspend.c:117:14: warning: symbol 'exynos5420_release_ret_regs' was not declared. Should it be static?
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Reviewed-by: Pankaj Dubey <pankaj.dubey@samsung.com>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 52e2b1a2fddb..f2f1201d8d33 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -75,7 +75,7 @@ struct exynos_pm_data {
 	int (*cpu_suspend)(unsigned long);
 };
 
-struct exynos_pm_data *pm_data;
+static struct exynos_pm_data *pm_data;
 
 static int exynos5420_cpu_state;
 static unsigned int exynos_pmu_spare3;
@@ -104,7 +104,7 @@ static const struct exynos_wkup_irq exynos5250_wkup_irq[] = {
 	{ /* sentinel */ },
 };
 
-unsigned int exynos_release_ret_regs[] = {
+static unsigned int exynos_release_ret_regs[] = {
 	S5P_PAD_RET_MAUDIO_OPTION,
 	S5P_PAD_RET_GPIO_OPTION,
 	S5P_PAD_RET_UART_OPTION,
@@ -115,7 +115,7 @@ unsigned int exynos_release_ret_regs[] = {
 	REG_TABLE_END,
 };
 
-unsigned int exynos3250_release_ret_regs[] = {
+static unsigned int exynos3250_release_ret_regs[] = {
 	S5P_PAD_RET_MAUDIO_OPTION,
 	S5P_PAD_RET_GPIO_OPTION,
 	S5P_PAD_RET_UART_OPTION,
@@ -128,7 +128,7 @@ unsigned int exynos3250_release_ret_regs[] = {
 	REG_TABLE_END,
 };
 
-unsigned int exynos5420_release_ret_regs[] = {
+static unsigned int exynos5420_release_ret_regs[] = {
 	EXYNOS_PAD_RET_DRAM_OPTION,
 	EXYNOS_PAD_RET_MAUDIO_OPTION,
 	EXYNOS_PAD_RET_JTAG_OPTION,

commit ace283a04a4a6c2e04814c43251191ef8f229b26
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Fri Feb 27 05:58:12 2015 +0900

    ARM: EXYNOS: Fix wrong hwirq of RTC interrupt for Exynos3250 SoC
    
    This patch fixes wrong hwirq of RTC irq for Exynos3250 SoC. When entering
    suspend state, 'enable_irq_wake fail' happen because of the mismatch of RTC hwirq.
    
    [  429.200937] Freezing user space processes ... (elapsed 0.002 seconds) done.
    [  429.203383] Freezing remaining freezable tasks ... (elapsed 0.000 seconds) done.
    [  429.209914] Suspending console(s) (use no_console_suspend to debug)
    [  429.370685] wake enabled for irq 65
    [  429.370837] wake enabled for irq 64
    [  429.370868] wake enabled for irq 79
    ...
    [  429.372120] s3c-rtc 10070000.rtc: enable_irq_wake failed
    
    Fixes: a4f582f5c5fe3 (ARM: EXYNOS: Add exynos3250 suspend-to-ram support)
    
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Reviewed-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 52e2b1a2fddb..318d127df147 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -87,8 +87,8 @@ static unsigned int exynos_pmu_spare3;
 static u32 exynos_irqwake_intmask = 0xffffffff;
 
 static const struct exynos_wkup_irq exynos3250_wkup_irq[] = {
-	{ 73, BIT(1) }, /* RTC alarm */
-	{ 74, BIT(2) }, /* RTC tick */
+	{ 105, BIT(1) }, /* RTC alarm */
+	{ 106, BIT(2) }, /* RTC tick */
 	{ /* sentinel */ },
 };
 

commit 444d2d33d8564f95df851ddaca80f640ca36934d
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Feb 18 21:19:56 2015 +0100

    ARM: make of_device_ids const
    
    of_device_ids (i.e. compatible strings and the respective data) are not
    supposed to change at runtime. All functions working with of_device_ids
    provided by <linux/of.h> work with const of_device_ids. So mark the
    non-const structs in arch/arm as const, too.
    
    While at it also add some __initconst annotations.
    
    Acked-by: Jason Cooper <jason@lakedameon.net>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 666ec3e5b03f..52e2b1a2fddb 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -587,7 +587,7 @@ static struct exynos_pm_data exynos5420_pm_data = {
 	.cpu_suspend	= exynos5420_cpu_suspend,
 };
 
-static struct of_device_id exynos_pmu_of_device_ids[] = {
+static const struct of_device_id exynos_pmu_of_device_ids[] __initconst = {
 	{
 		.compatible = "samsung,exynos3250-pmu",
 		.data = &exynos3250_pm_data,

commit 18656782a820f075cb5c168a2e381a8938b1550a
Merge: a233bb742aed 6f4554bdff68
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 17 09:38:59 2015 -0800

    Merge tag 'drivers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC driver updates from Olof Johansson:
     "These are changes for drivers that are intimately tied to some SoC and
      for some reason could not get merged through the respective subsystem
      maintainer tree.
    
      This time around, much of this is for at91, with the bulk of it being
      syscon and udc drivers.
    
      Also, there's:
       - coupled cpuidle support for Samsung Exynos4210
       - Renesas 73A0 common-clk work
       - of/platform changes to tear down DMA mappings on device destruction
       - a few updates to the TI Keystone knav code"
    
    * tag 'drivers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (26 commits)
      cpuidle: exynos: add coupled cpuidle support for exynos4210
      ARM: EXYNOS: apply S5P_CENTRAL_SEQ_OPTION fix only when necessary
      soc: ti: knav_qmss_queue: change knav_range_setup_acc_irq to static
      soc: ti: knav_qmss_queue: makefile tweak to build as dynamic module
      pcmcia: at91_cf: depend on !ARCH_MULTIPLATFORM
      soc: ti: knav_qmss_queue: export API calls for use by user driver
      of/platform: teardown DMA mappings on device destruction
      usb: gadget: at91_udc: Allocate udc instance
      usb: gadget: at91_udc: Update DT binding documentation
      usb: gadget: at91_udc: Rework for multi-platform kernel support
      usb: gadget: at91_udc: Simplify probe and remove functions
      usb: gadget: at91_udc: Remove non-DT handling code
      usb: gadget: at91_udc: Document DT clocks and clock-names property
      usb: gadget: at91_udc: Drop uclk clock
      usb: gadget: at91_udc: Fix clock names
      mfd: syscon: Add Atmel SMC binding doc
      mfd: syscon: Add atmel-smc registers definition
      mfd: syscon: Add Atmel Matrix bus DT binding documentation
      mfd: syscon: Add atmel-matrix registers definition
      clk: shmobile: fix sparse NULL pointer warning
      ...

commit 878ba61aa98cbb97a513757800e77613f856a029
Merge: ea7531ac4a9d df1a66812535
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 17 09:27:54 2015 -0800

    Merge tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform changes from Olof Johansson:
     "New and updated SoC support.  Also included are some cleanups where
      the platform maintainers hadn't separated cleanups from new developent
      in separate branches.
    
      Some of the larger things worth pointing out:
    
       - A large set of changes from Alexandre Belloni and Nicolas Ferre
         preparing at91 platforms for multiplatform and cleaning up quite a
         bit in the process.
    
       - Removal of CSR's "Marco" SoC platform that never made it out to the
         market.  We love seeing these since it means the vendor published
         support before product was out, which is exactly what we want!
    
      New platforms this release are:
    
       - Conexant Digicolor (CX92755 SoC)
       - Hisilicon HiP01 SoC
       - CSR/sirf Atlas7 SoC
       - ST STiH418 SoC
       - Common code changes for Nvidia Tegra132 (64-bit SoC)
    
      We're seeing more and more platforms having a harder time labelling
      changes as cleanups vs new development -- which is a good sign that
      we've come quite far on the cleanup effort.  So over time we might
      start combining the cleanup and new-development branches more"
    
    * tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (124 commits)
      ARM: at91/trivial: unify functions and machine names
      ARM: at91: remove at91_dt_initialize and machine init_early()
      ARM: at91: change board files into SoC files
      ARM: at91: remove at91_boot_soc
      ARM: at91: move alternative initial mapping to board-dt-sama5.c
      ARM: at91: merge all SOC_AT91SAM9xxx
      ARM: at91: at91rm9200: set idle and restart from rm9200_dt_device_init()
      ARM: digicolor: select syscon and timer
      ARM: zynq: Simplify SLCR initialization
      ARM: zynq: PM: Fixed simple typo.
      ARM: zynq: Setup default gpio number for Xilinx Zynq
      ARM: digicolor: add low level debug support
      ARM: initial support for Conexant Digicolor CX92755 SoC
      ARM: OMAP2+: Add dm816x hwmod support
      ARM: OMAP2+: Add clock domain support for dm816x
      ARM: OMAP2+: Add board-generic.c entry for ti81xx
      ARM: at91: pm: remove warning to remove SOC_AT91SAM9263 usage
      ARM: at91: remove unused mach/system_rev.h
      ARM: at91: stop using HAVE_AT91_DBGUx
      ARM: at91: fix ordering of SRAM and PM initialization
      ...

commit 865e8b76a04d018f23d809ebf735c52105e3adb2
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Sat Jan 24 14:05:50 2015 +0900

    ARM: EXYNOS: apply S5P_CENTRAL_SEQ_OPTION fix only when necessary
    
    Commit c2dd114d2486 ("ARM: EXYNOS: fix register setup for AFTR mode
    code") added S5P_CENTRAL_SEQ_OPTION register setup fix for all
    Exynos SoCs to AFTR mode code-path.  It turned out that for coupled
    cpuidle AFTR mode on Exynos4210 (added by the next patch) applying
    this fix causes lockup so enable it in the AFTR mode code-path only
    on SoCs that require it (in the suspend code-path it can be always
    applied like it was before commit c2dd114d2486 ("ARM: EXYNOS: fix
    register setup for AFTR mode code")
    
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Colin Cross <ccross@google.com>
    Cc: Tomasz Figa <tomasz.figa@gmail.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Reviewed-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index f8e7dcd17055..9c67a15f4a0f 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -282,6 +282,10 @@ static int exynos_pm_suspend(void)
 {
 	exynos_pm_central_suspend();
 
+	/* Setting SEQ_OPTION register */
+	pmu_raw_writel(S5P_USE_STANDBY_WFI0 | S5P_USE_STANDBY_WFE0,
+		       S5P_CENTRAL_SEQ_OPTION);
+
 	if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9)
 		exynos_cpu_save_register();
 

commit a4f582f5c5fe3e8eaef7ce637c894619bdee650e
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Mon Jan 12 17:41:34 2015 +0900

    ARM: EXYNOS: Add exynos3250 suspend-to-ram support
    
    This patch supports suspend-to-ram for Exynos3250 SoC
    and the SoC doesn't contain L2 cache.
    
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index f8e7dcd17055..d6feef31b468 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -91,6 +91,12 @@ static unsigned int exynos_pmu_spare3;
 
 static u32 exynos_irqwake_intmask = 0xffffffff;
 
+static const struct exynos_wkup_irq exynos3250_wkup_irq[] = {
+	{ 73, BIT(1) }, /* RTC alarm */
+	{ 74, BIT(2) }, /* RTC tick */
+	{ /* sentinel */ },
+};
+
 static const struct exynos_wkup_irq exynos4_wkup_irq[] = {
 	{ 76, BIT(1) }, /* RTC alarm */
 	{ 77, BIT(2) }, /* RTC tick */
@@ -114,6 +120,19 @@ unsigned int exynos_release_ret_regs[] = {
 	REG_TABLE_END,
 };
 
+unsigned int exynos3250_release_ret_regs[] = {
+	S5P_PAD_RET_MAUDIO_OPTION,
+	S5P_PAD_RET_GPIO_OPTION,
+	S5P_PAD_RET_UART_OPTION,
+	S5P_PAD_RET_MMCA_OPTION,
+	S5P_PAD_RET_MMCB_OPTION,
+	S5P_PAD_RET_EBIA_OPTION,
+	S5P_PAD_RET_EBIB_OPTION,
+	S5P_PAD_RET_MMC2_OPTION,
+	S5P_PAD_RET_SPI_OPTION,
+	REG_TABLE_END,
+};
+
 unsigned int exynos5420_release_ret_regs[] = {
 	EXYNOS_PAD_RET_DRAM_OPTION,
 	EXYNOS_PAD_RET_MAUDIO_OPTION,
@@ -173,6 +192,12 @@ static int exynos_cpu_suspend(unsigned long arg)
 	return exynos_cpu_do_idle();
 }
 
+static int exynos3250_cpu_suspend(unsigned long arg)
+{
+	flush_cache_all();
+	return exynos_cpu_do_idle();
+}
+
 static int exynos5420_cpu_suspend(unsigned long arg)
 {
 	/* MCPM works with HW CPU identifiers */
@@ -230,6 +255,23 @@ static void exynos_pm_prepare(void)
 	pmu_raw_writel(virt_to_phys(exynos_cpu_resume), S5P_INFORM0);
 }
 
+static void exynos3250_pm_prepare(void)
+{
+	unsigned int tmp;
+
+	/* Set wake-up mask registers */
+	exynos_pm_set_wakeup_mask();
+
+	tmp = pmu_raw_readl(EXYNOS3_ARM_L2_OPTION);
+	tmp &= ~EXYNOS5_OPTION_USE_RETENTION;
+	pmu_raw_writel(tmp, EXYNOS3_ARM_L2_OPTION);
+
+	exynos_pm_enter_sleep_mode();
+
+	/* ensure at least INFORM0 has the resume address */
+	pmu_raw_writel(virt_to_phys(exynos_cpu_resume), S5P_INFORM0);
+}
+
 static void exynos5420_pm_prepare(void)
 {
 	unsigned int tmp;
@@ -344,6 +386,28 @@ static void exynos_pm_resume(void)
 	pmu_raw_writel(0x0, S5P_INFORM1);
 }
 
+static void exynos3250_pm_resume(void)
+{
+	u32 cpuid = read_cpuid_part();
+
+	if (exynos_pm_central_resume())
+		goto early_wakeup;
+
+	/* For release retention */
+	exynos_pm_release_retention();
+
+	pmu_raw_writel(S5P_USE_STANDBY_WFI_ALL, S5P_CENTRAL_SEQ_OPTION);
+
+	if (call_firmware_op(resume) == -ENOSYS
+	    && cpuid == ARM_CPU_PART_CORTEX_A9)
+		exynos_cpu_restore_register();
+
+early_wakeup:
+
+	/* Clear SLEEP mode set in INFORM1 */
+	pmu_raw_writel(0x0, S5P_INFORM1);
+}
+
 static void exynos5420_prepare_pm_resume(void)
 {
 	if (IS_ENABLED(CONFIG_EXYNOS5420_MCPM))
@@ -483,6 +547,16 @@ static const struct platform_suspend_ops exynos_suspend_ops = {
 	.valid		= suspend_valid_only_mem,
 };
 
+static const struct exynos_pm_data exynos3250_pm_data = {
+	.wkup_irq	= exynos3250_wkup_irq,
+	.wake_disable_mask = ((0xFF << 8) | (0x1F << 1)),
+	.release_ret_regs = exynos3250_release_ret_regs,
+	.pm_suspend	= exynos_pm_suspend,
+	.pm_resume	= exynos3250_pm_resume,
+	.pm_prepare	= exynos3250_pm_prepare,
+	.cpu_suspend	= exynos3250_cpu_suspend,
+};
+
 static const struct exynos_pm_data exynos4_pm_data = {
 	.wkup_irq	= exynos4_wkup_irq,
 	.wake_disable_mask = ((0xFF << 8) | (0x1F << 1)),
@@ -518,6 +592,9 @@ static struct exynos_pm_data exynos5420_pm_data = {
 
 static struct of_device_id exynos_pmu_of_device_ids[] = {
 	{
+		.compatible = "samsung,exynos3250-pmu",
+		.data = &exynos3250_pm_data,
+	}, {
 		.compatible = "samsung,exynos4210-pmu",
 		.data = &exynos4_pm_data,
 	}, {

commit 32b0aa9aaeb4a493135ea6368a614aa89c3c5488
Author: Pankaj Dubey <pankaj.dubey@samsung.com>
Date:   Fri Jan 9 01:14:23 2015 +0900

    ARM: EXYNOS: Remove i2c sys configuration related code
    
    As all these code has been moved into i2c driver, now we can
    safely remove them from machine files.
    
    CC: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Pankaj Dubey <pankaj.dubey@samsung.com>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index f8e7dcd17055..342797b9bf3b 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -34,7 +34,6 @@
 
 #include "common.h"
 #include "regs-pmu.h"
-#include "regs-sys.h"
 #include "exynos-pmu.h"
 
 #define S5P_CHECK_SLEEP 0x00000BAD
@@ -53,10 +52,6 @@ struct exynos_wkup_irq {
 	u32 mask;
 };
 
-static struct sleep_save exynos5_sys_save[] = {
-	SAVE_ITEM(EXYNOS5_SYS_I2C_CFG),
-};
-
 static struct sleep_save exynos_core_save[] = {
 	/* SROM side */
 	SAVE_ITEM(S5P_SROM_BW),
@@ -497,8 +492,6 @@ static const struct exynos_pm_data exynos5250_pm_data = {
 	.wkup_irq	= exynos5250_wkup_irq,
 	.wake_disable_mask = ((0xFF << 8) | (0x1F << 1)),
 	.release_ret_regs = exynos_release_ret_regs,
-	.extra_save	= exynos5_sys_save,
-	.num_extra_save	= ARRAY_SIZE(exynos5_sys_save),
 	.pm_suspend	= exynos_pm_suspend,
 	.pm_resume	= exynos_pm_resume,
 	.pm_prepare	= exynos_pm_prepare,

commit c645a598f99768e6cc82129081458dfdd0c273b7
Author: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
Date:   Thu Nov 13 11:14:40 2014 +0900

    ARM: EXYNOS: Call regulator core suspend prepare and finish functions
    
    The regulator framework has a set of helpers functions to be used when
    the system is entering and leaving from suspend but these are not called
    on Exynos platforms. This means that the .set_suspend_* function handlers
    defined by regulator drivers are not called when the system is suspended.
    
    Suggested-by: Doug Anderson <dianders@chromium.org>
    Signed-off-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Reviewed-by: Doug Anderson <dianders@chromium.org>
    Reviewed-by: Chanwoo Choi <cw00.choi@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index cc8d2374f1b1..f8e7dcd17055 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -20,6 +20,7 @@
 #include <linux/io.h>
 #include <linux/irqchip/arm-gic.h>
 #include <linux/err.h>
+#include <linux/regulator/machine.h>
 
 #include <asm/cacheflush.h>
 #include <asm/hardware/cache-l2x0.h>
@@ -443,6 +444,22 @@ static int exynos_suspend_enter(suspend_state_t state)
 
 static int exynos_suspend_prepare(void)
 {
+	int ret;
+
+	/*
+	 * REVISIT: It would be better if struct platform_suspend_ops
+	 * .prepare handler get the suspend_state_t as a parameter to
+	 * avoid hard-coding the suspend to mem state. It's safe to do
+	 * it now only because the suspend_valid_only_mem function is
+	 * used as the .valid callback used to check if a given state
+	 * is supported by the platform anyways.
+	 */
+	ret = regulator_suspend_prepare(PM_SUSPEND_MEM);
+	if (ret) {
+		pr_err("Failed to prepare regulators for suspend (%d)\n", ret);
+		return ret;
+	}
+
 	s3c_pm_check_prepare();
 
 	return 0;
@@ -450,7 +467,13 @@ static int exynos_suspend_prepare(void)
 
 static void exynos_suspend_finish(void)
 {
+	int ret;
+
 	s3c_pm_check_cleanup();
+
+	ret = regulator_suspend_finish();
+	if (ret)
+		pr_warn("Failed to resume regulators from suspend (%d)\n", ret);
 }
 
 static const struct platform_suspend_ops exynos_suspend_ops = {

commit adc548d77c22daa371d5217b382a139b593dec47
Author: Abhilash Kesavan <a.kesavan@samsung.com>
Date:   Fri Nov 7 09:20:16 2014 +0900

    ARM: EXYNOS: Use MCPM call-backs to support S2R on exynos5420
    
    Use the MCPM layer to handle core suspend/resume on Exynos5420.
    Also, restore the entry address setup code post-resume.
    
    Signed-off-by: Abhilash Kesavan <a.kesavan@samsung.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Reviewed-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Tested-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 8cef6141c408..cc8d2374f1b1 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -24,6 +24,7 @@
 #include <asm/cacheflush.h>
 #include <asm/hardware/cache-l2x0.h>
 #include <asm/firmware.h>
+#include <asm/mcpm.h>
 #include <asm/smp_scu.h>
 #include <asm/suspend.h>
 
@@ -72,6 +73,7 @@ struct exynos_pm_data {
 	unsigned int *release_ret_regs;
 
 	void (*pm_prepare)(void);
+	void (*pm_resume_prepare)(void);
 	void (*pm_resume)(void);
 	int (*pm_suspend)(void);
 	int (*cpu_suspend)(unsigned long);
@@ -172,9 +174,28 @@ static int exynos_cpu_suspend(unsigned long arg)
 
 static int exynos5420_cpu_suspend(unsigned long arg)
 {
-	exynos_flush_cache_all();
+	/* MCPM works with HW CPU identifiers */
+	unsigned int mpidr = read_cpuid_mpidr();
+	unsigned int cluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);
+	unsigned int cpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);
+
 	__raw_writel(0x0, sysram_base_addr + EXYNOS5420_CPU_STATE);
-	return exynos_cpu_do_idle();
+
+	if (IS_ENABLED(CONFIG_EXYNOS5420_MCPM)) {
+		mcpm_set_entry_vector(cpu, cluster, exynos_cpu_resume);
+
+		/*
+		 * Residency value passed to mcpm_cpu_suspend back-end
+		 * has to be given clear semantics. Set to 0 as a
+		 * temporary value.
+		 */
+		mcpm_cpu_suspend(0);
+	}
+
+	pr_info("Failed to suspend the system\n");
+
+	/* return value != 0 means failure */
+	return 1;
 }
 
 static void exynos_pm_set_wakeup_mask(void)
@@ -189,9 +210,6 @@ static void exynos_pm_enter_sleep_mode(void)
 	/* Set value of power down register for sleep mode */
 	exynos_sys_powerdown_conf(SYS_SLEEP);
 	pmu_raw_writel(S5P_CHECK_SLEEP, S5P_INFORM1);
-
-	/* ensure at least INFORM0 has the resume address */
-	pmu_raw_writel(virt_to_phys(exynos_cpu_resume), S5P_INFORM0);
 }
 
 static void exynos_pm_prepare(void)
@@ -206,6 +224,9 @@ static void exynos_pm_prepare(void)
 				pm_data->num_extra_save);
 
 	exynos_pm_enter_sleep_mode();
+
+	/* ensure at least INFORM0 has the resume address */
+	pmu_raw_writel(virt_to_phys(exynos_cpu_resume), S5P_INFORM0);
 }
 
 static void exynos5420_pm_prepare(void)
@@ -230,6 +251,10 @@ static void exynos5420_pm_prepare(void)
 
 	exynos_pm_enter_sleep_mode();
 
+	/* ensure at least INFORM0 has the resume address */
+	if (IS_ENABLED(CONFIG_EXYNOS5420_MCPM))
+		pmu_raw_writel(virt_to_phys(mcpm_entry_point), S5P_INFORM0);
+
 	tmp = pmu_raw_readl(EXYNOS5_ARM_L2_OPTION);
 	tmp &= ~EXYNOS5_USE_RETENTION;
 	pmu_raw_writel(tmp, EXYNOS5_ARM_L2_OPTION);
@@ -318,10 +343,21 @@ static void exynos_pm_resume(void)
 	pmu_raw_writel(0x0, S5P_INFORM1);
 }
 
+static void exynos5420_prepare_pm_resume(void)
+{
+	if (IS_ENABLED(CONFIG_EXYNOS5420_MCPM))
+		WARN_ON(mcpm_cpu_powered_up());
+}
+
 static void exynos5420_pm_resume(void)
 {
 	unsigned long tmp;
 
+	/* Restore the CPU0 low power state register */
+	tmp = pmu_raw_readl(EXYNOS5_ARM_CORE0_SYS_PWR_REG);
+	pmu_raw_writel(tmp | S5P_CORE_LOCAL_PWR_EN,
+		EXYNOS5_ARM_CORE0_SYS_PWR_REG);
+
 	/* Restore the sysram cpu state register */
 	__raw_writel(exynos5420_cpu_state,
 		sysram_base_addr + EXYNOS5420_CPU_STATE);
@@ -391,6 +427,8 @@ static int exynos_suspend_enter(suspend_state_t state)
 	if (ret)
 		return ret;
 
+	if (pm_data->pm_resume_prepare)
+		pm_data->pm_resume_prepare();
 	s3c_pm_restore_uarts();
 
 	S3C_PMDBG("%s: wakeup stat: %08x\n", __func__,
@@ -448,6 +486,7 @@ static struct exynos_pm_data exynos5420_pm_data = {
 	.wkup_irq	= exynos5250_wkup_irq,
 	.wake_disable_mask = (0x7F << 7) | (0x1F << 1),
 	.release_ret_regs = exynos5420_release_ret_regs,
+	.pm_resume_prepare = exynos5420_prepare_pm_resume,
 	.pm_resume	= exynos5420_pm_resume,
 	.pm_suspend	= exynos5420_pm_suspend,
 	.pm_prepare	= exynos5420_pm_prepare,

commit 0fdf088fd84d87d6fc5d3961cc86feb8bd295398
Author: Vikas Sajjan <vikas.sajjan@samsung.com>
Date:   Fri Nov 7 09:17:36 2014 +0900

    ARM: EXYNOS: Add Suspend-to-RAM support for exynos5420
    
    Adds Suspend-to-RAM support for EXYNOS5420
    
    Signed-off-by: Vikas Sajjan <vikas.sajjan@samsung.com>
    Signed-off-by: Abhilash Kesavan <a.kesavan@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index 079d999b8b23..8cef6141c408 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -39,6 +39,8 @@
 
 #define REG_TABLE_END (-1U)
 
+#define EXYNOS5420_CPU_STATE	0x28
+
 /**
  * struct exynos_wkup_irq - Exynos GIC to PMU IRQ mapping
  * @hwirq: Hardware IRQ signal of the GIC
@@ -77,6 +79,9 @@ struct exynos_pm_data {
 
 struct exynos_pm_data *pm_data;
 
+static int exynos5420_cpu_state;
+static unsigned int exynos_pmu_spare3;
+
 /*
  * GIC wake-up support
  */
@@ -106,6 +111,23 @@ unsigned int exynos_release_ret_regs[] = {
 	REG_TABLE_END,
 };
 
+unsigned int exynos5420_release_ret_regs[] = {
+	EXYNOS_PAD_RET_DRAM_OPTION,
+	EXYNOS_PAD_RET_MAUDIO_OPTION,
+	EXYNOS_PAD_RET_JTAG_OPTION,
+	EXYNOS5420_PAD_RET_GPIO_OPTION,
+	EXYNOS5420_PAD_RET_UART_OPTION,
+	EXYNOS5420_PAD_RET_MMCA_OPTION,
+	EXYNOS5420_PAD_RET_MMCB_OPTION,
+	EXYNOS5420_PAD_RET_MMCC_OPTION,
+	EXYNOS5420_PAD_RET_HSI_OPTION,
+	EXYNOS_PAD_RET_EBIA_OPTION,
+	EXYNOS_PAD_RET_EBIB_OPTION,
+	EXYNOS5420_PAD_RET_SPI_OPTION,
+	EXYNOS5420_PAD_RET_DRAM_COREBLK_OPTION,
+	REG_TABLE_END,
+};
+
 static int exynos_irq_set_wake(struct irq_data *data, unsigned int state)
 {
 	const struct exynos_wkup_irq *wkup_irq;
@@ -136,11 +158,22 @@ static int exynos_cpu_do_idle(void)
 	pr_info("Failed to suspend the system\n");
 	return 1; /* Aborting suspend */
 }
-
-static int exynos_cpu_suspend(unsigned long arg)
+static void exynos_flush_cache_all(void)
 {
 	flush_cache_all();
 	outer_flush_all();
+}
+
+static int exynos_cpu_suspend(unsigned long arg)
+{
+	exynos_flush_cache_all();
+	return exynos_cpu_do_idle();
+}
+
+static int exynos5420_cpu_suspend(unsigned long arg)
+{
+	exynos_flush_cache_all();
+	__raw_writel(0x0, sysram_base_addr + EXYNOS5420_CPU_STATE);
 	return exynos_cpu_do_idle();
 }
 
@@ -175,6 +208,50 @@ static void exynos_pm_prepare(void)
 	exynos_pm_enter_sleep_mode();
 }
 
+static void exynos5420_pm_prepare(void)
+{
+	unsigned int tmp;
+
+	/* Set wake-up mask registers */
+	exynos_pm_set_wakeup_mask();
+
+	s3c_pm_do_save(exynos_core_save, ARRAY_SIZE(exynos_core_save));
+
+	exynos_pmu_spare3 = pmu_raw_readl(S5P_PMU_SPARE3);
+	/*
+	 * The cpu state needs to be saved and restored so that the
+	 * secondary CPUs will enter low power start. Though the U-Boot
+	 * is setting the cpu state with low power flag, the kernel
+	 * needs to restore it back in case, the primary cpu fails to
+	 * suspend for any reason.
+	 */
+	exynos5420_cpu_state = __raw_readl(sysram_base_addr +
+						EXYNOS5420_CPU_STATE);
+
+	exynos_pm_enter_sleep_mode();
+
+	tmp = pmu_raw_readl(EXYNOS5_ARM_L2_OPTION);
+	tmp &= ~EXYNOS5_USE_RETENTION;
+	pmu_raw_writel(tmp, EXYNOS5_ARM_L2_OPTION);
+
+	tmp = pmu_raw_readl(EXYNOS5420_SFR_AXI_CGDIS1);
+	tmp |= EXYNOS5420_UFS;
+	pmu_raw_writel(tmp, EXYNOS5420_SFR_AXI_CGDIS1);
+
+	tmp = pmu_raw_readl(EXYNOS5420_ARM_COMMON_OPTION);
+	tmp &= ~EXYNOS5420_L2RSTDISABLE_VALUE;
+	pmu_raw_writel(tmp, EXYNOS5420_ARM_COMMON_OPTION);
+
+	tmp = pmu_raw_readl(EXYNOS5420_FSYS2_OPTION);
+	tmp |= EXYNOS5420_EMULATION;
+	pmu_raw_writel(tmp, EXYNOS5420_FSYS2_OPTION);
+
+	tmp = pmu_raw_readl(EXYNOS5420_PSGEN_OPTION);
+	tmp |= EXYNOS5420_EMULATION;
+	pmu_raw_writel(tmp, EXYNOS5420_PSGEN_OPTION);
+}
+
+
 static int exynos_pm_suspend(void)
 {
 	exynos_pm_central_suspend();
@@ -185,6 +262,24 @@ static int exynos_pm_suspend(void)
 	return 0;
 }
 
+static int exynos5420_pm_suspend(void)
+{
+	u32 this_cluster;
+
+	exynos_pm_central_suspend();
+
+	/* Setting SEQ_OPTION register */
+
+	this_cluster = MPIDR_AFFINITY_LEVEL(read_cpuid_mpidr(), 1);
+	if (!this_cluster)
+		pmu_raw_writel(EXYNOS5420_ARM_USE_STANDBY_WFI0,
+				S5P_CENTRAL_SEQ_OPTION);
+	else
+		pmu_raw_writel(EXYNOS5420_KFC_USE_STANDBY_WFI0,
+				S5P_CENTRAL_SEQ_OPTION);
+	return 0;
+}
+
 static void exynos_pm_release_retention(void)
 {
 	unsigned int i;
@@ -223,6 +318,45 @@ static void exynos_pm_resume(void)
 	pmu_raw_writel(0x0, S5P_INFORM1);
 }
 
+static void exynos5420_pm_resume(void)
+{
+	unsigned long tmp;
+
+	/* Restore the sysram cpu state register */
+	__raw_writel(exynos5420_cpu_state,
+		sysram_base_addr + EXYNOS5420_CPU_STATE);
+
+	pmu_raw_writel(EXYNOS5420_USE_STANDBY_WFI_ALL,
+			S5P_CENTRAL_SEQ_OPTION);
+
+	if (exynos_pm_central_resume())
+		goto early_wakeup;
+
+	/* For release retention */
+	exynos_pm_release_retention();
+
+	pmu_raw_writel(exynos_pmu_spare3, S5P_PMU_SPARE3);
+
+	s3c_pm_do_restore_core(exynos_core_save, ARRAY_SIZE(exynos_core_save));
+
+early_wakeup:
+
+	tmp = pmu_raw_readl(EXYNOS5420_SFR_AXI_CGDIS1);
+	tmp &= ~EXYNOS5420_UFS;
+	pmu_raw_writel(tmp, EXYNOS5420_SFR_AXI_CGDIS1);
+
+	tmp = pmu_raw_readl(EXYNOS5420_FSYS2_OPTION);
+	tmp &= ~EXYNOS5420_EMULATION;
+	pmu_raw_writel(tmp, EXYNOS5420_FSYS2_OPTION);
+
+	tmp = pmu_raw_readl(EXYNOS5420_PSGEN_OPTION);
+	tmp &= ~EXYNOS5420_EMULATION;
+	pmu_raw_writel(tmp, EXYNOS5420_PSGEN_OPTION);
+
+	/* Clear SLEEP mode set in INFORM1 */
+	pmu_raw_writel(0x0, S5P_INFORM1);
+}
+
 /*
  * Suspend Ops
  */
@@ -310,6 +444,16 @@ static const struct exynos_pm_data exynos5250_pm_data = {
 	.cpu_suspend	= exynos_cpu_suspend,
 };
 
+static struct exynos_pm_data exynos5420_pm_data = {
+	.wkup_irq	= exynos5250_wkup_irq,
+	.wake_disable_mask = (0x7F << 7) | (0x1F << 1),
+	.release_ret_regs = exynos5420_release_ret_regs,
+	.pm_resume	= exynos5420_pm_resume,
+	.pm_suspend	= exynos5420_pm_suspend,
+	.pm_prepare	= exynos5420_pm_prepare,
+	.cpu_suspend	= exynos5420_cpu_suspend,
+};
+
 static struct of_device_id exynos_pmu_of_device_ids[] = {
 	{
 		.compatible = "samsung,exynos4210-pmu",
@@ -323,6 +467,9 @@ static struct of_device_id exynos_pmu_of_device_ids[] = {
 	}, {
 		.compatible = "samsung,exynos5250-pmu",
 		.data = &exynos5250_pm_data,
+	}, {
+		.compatible = "samsung,exynos5420-pmu",
+		.data = &exynos5420_pm_data,
 	},
 	{ /*sentinel*/ },
 };

commit 6b7bfd8292ab27180662bcba175e7a3822486c2d
Author: Pankaj Dubey <pankaj.dubey@samsung.com>
Date:   Fri Nov 7 09:26:47 2014 +0900

    ARM: EXYNOS: Move PMU specific definitions from common.h
    
    This patch moves PMU specific definitions into a new file
    as exynos-pmu.h.
    This will help in reducing dependency of common.h in pmu.c.
    
    Signed-off-by: Pankaj Dubey <pankaj.dubey@samsung.com>
    Reviewed-by: Tomasz Figa <t.figa@samsung.com>
    Tested-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
index f5d9773066eb..079d999b8b23 100644
--- a/arch/arm/mach-exynos/suspend.c
+++ b/arch/arm/mach-exynos/suspend.c
@@ -33,6 +33,7 @@
 #include "common.h"
 #include "regs-pmu.h"
 #include "regs-sys.h"
+#include "exynos-pmu.h"
 
 #define S5P_CHECK_SLEEP 0x00000BAD
 

commit 0d713cf1a6286aae6a12affab0887dbe2a4fbb83
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Sep 25 18:02:45 2014 +0900

    ARM: EXYNOS: Fix build with PM_SLEEP=n and ARM_EXYNOS_CPUIDLE=y
    
    Fix building of exynos_defconfig with CONFIG_PM_SLEEP disabled and
    CONFIG_ARM_EXYNOS_CPUIDLE enabled by:
    
    * adding EXYNOS_CPU_SUSPEND config option
    * always building sleep.o
    * building pm.o if EXYNOS_CPU_SUSPEND is enabled
    * moving suspend specific code from pm.c to suspend.c
    * enabling pm-common.o build also for EXYNOS_CPU_SUSPEND option
    
    [ Please note that there are no changes in the code moved from pm.c
      to suspend.c except making few functions non-static and cleaning
      up includes. ]
    
    Also while at it update Copyright dates.
    
    The build error messages:
    drivers/built-in.o: In function `exynos_enter_core0_aftr':
    /home/bzolnier/linux/drivers/cpuidle/cpuidle-exynos.c:36: undefined reference to `cpu_suspend'
    arch/arm/mach-exynos/built-in.o:(.data+0x74): undefined reference to `exynos_enter_aftr'
    make: *** [vmlinux] Error 1
    
    This patch has been tested on Exynos4210 based Origen board.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/suspend.c b/arch/arm/mach-exynos/suspend.c
new file mode 100644
index 000000000000..f5d9773066eb
--- /dev/null
+++ b/arch/arm/mach-exynos/suspend.c
@@ -0,0 +1,356 @@
+/*
+ * Copyright (c) 2011-2014 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * EXYNOS - Suspend support
+ *
+ * Based on arch/arm/mach-s3c2410/pm.c
+ * Copyright (c) 2006 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/suspend.h>
+#include <linux/syscore_ops.h>
+#include <linux/cpu_pm.h>
+#include <linux/io.h>
+#include <linux/irqchip/arm-gic.h>
+#include <linux/err.h>
+
+#include <asm/cacheflush.h>
+#include <asm/hardware/cache-l2x0.h>
+#include <asm/firmware.h>
+#include <asm/smp_scu.h>
+#include <asm/suspend.h>
+
+#include <plat/pm-common.h>
+#include <plat/regs-srom.h>
+
+#include "common.h"
+#include "regs-pmu.h"
+#include "regs-sys.h"
+
+#define S5P_CHECK_SLEEP 0x00000BAD
+
+#define REG_TABLE_END (-1U)
+
+/**
+ * struct exynos_wkup_irq - Exynos GIC to PMU IRQ mapping
+ * @hwirq: Hardware IRQ signal of the GIC
+ * @mask: Mask in PMU wake-up mask register
+ */
+struct exynos_wkup_irq {
+	unsigned int hwirq;
+	u32 mask;
+};
+
+static struct sleep_save exynos5_sys_save[] = {
+	SAVE_ITEM(EXYNOS5_SYS_I2C_CFG),
+};
+
+static struct sleep_save exynos_core_save[] = {
+	/* SROM side */
+	SAVE_ITEM(S5P_SROM_BW),
+	SAVE_ITEM(S5P_SROM_BC0),
+	SAVE_ITEM(S5P_SROM_BC1),
+	SAVE_ITEM(S5P_SROM_BC2),
+	SAVE_ITEM(S5P_SROM_BC3),
+};
+
+struct exynos_pm_data {
+	const struct exynos_wkup_irq *wkup_irq;
+	struct sleep_save *extra_save;
+	int num_extra_save;
+	unsigned int wake_disable_mask;
+	unsigned int *release_ret_regs;
+
+	void (*pm_prepare)(void);
+	void (*pm_resume)(void);
+	int (*pm_suspend)(void);
+	int (*cpu_suspend)(unsigned long);
+};
+
+struct exynos_pm_data *pm_data;
+
+/*
+ * GIC wake-up support
+ */
+
+static u32 exynos_irqwake_intmask = 0xffffffff;
+
+static const struct exynos_wkup_irq exynos4_wkup_irq[] = {
+	{ 76, BIT(1) }, /* RTC alarm */
+	{ 77, BIT(2) }, /* RTC tick */
+	{ /* sentinel */ },
+};
+
+static const struct exynos_wkup_irq exynos5250_wkup_irq[] = {
+	{ 75, BIT(1) }, /* RTC alarm */
+	{ 76, BIT(2) }, /* RTC tick */
+	{ /* sentinel */ },
+};
+
+unsigned int exynos_release_ret_regs[] = {
+	S5P_PAD_RET_MAUDIO_OPTION,
+	S5P_PAD_RET_GPIO_OPTION,
+	S5P_PAD_RET_UART_OPTION,
+	S5P_PAD_RET_MMCA_OPTION,
+	S5P_PAD_RET_MMCB_OPTION,
+	S5P_PAD_RET_EBIA_OPTION,
+	S5P_PAD_RET_EBIB_OPTION,
+	REG_TABLE_END,
+};
+
+static int exynos_irq_set_wake(struct irq_data *data, unsigned int state)
+{
+	const struct exynos_wkup_irq *wkup_irq;
+
+	if (!pm_data->wkup_irq)
+		return -ENOENT;
+	wkup_irq = pm_data->wkup_irq;
+
+	while (wkup_irq->mask) {
+		if (wkup_irq->hwirq == data->hwirq) {
+			if (!state)
+				exynos_irqwake_intmask |= wkup_irq->mask;
+			else
+				exynos_irqwake_intmask &= ~wkup_irq->mask;
+			return 0;
+		}
+		++wkup_irq;
+	}
+
+	return -ENOENT;
+}
+
+static int exynos_cpu_do_idle(void)
+{
+	/* issue the standby signal into the pm unit. */
+	cpu_do_idle();
+
+	pr_info("Failed to suspend the system\n");
+	return 1; /* Aborting suspend */
+}
+
+static int exynos_cpu_suspend(unsigned long arg)
+{
+	flush_cache_all();
+	outer_flush_all();
+	return exynos_cpu_do_idle();
+}
+
+static void exynos_pm_set_wakeup_mask(void)
+{
+	/* Set wake-up mask registers */
+	pmu_raw_writel(exynos_get_eint_wake_mask(), S5P_EINT_WAKEUP_MASK);
+	pmu_raw_writel(exynos_irqwake_intmask & ~(1 << 31), S5P_WAKEUP_MASK);
+}
+
+static void exynos_pm_enter_sleep_mode(void)
+{
+	/* Set value of power down register for sleep mode */
+	exynos_sys_powerdown_conf(SYS_SLEEP);
+	pmu_raw_writel(S5P_CHECK_SLEEP, S5P_INFORM1);
+
+	/* ensure at least INFORM0 has the resume address */
+	pmu_raw_writel(virt_to_phys(exynos_cpu_resume), S5P_INFORM0);
+}
+
+static void exynos_pm_prepare(void)
+{
+	/* Set wake-up mask registers */
+	exynos_pm_set_wakeup_mask();
+
+	s3c_pm_do_save(exynos_core_save, ARRAY_SIZE(exynos_core_save));
+
+	 if (pm_data->extra_save)
+		s3c_pm_do_save(pm_data->extra_save,
+				pm_data->num_extra_save);
+
+	exynos_pm_enter_sleep_mode();
+}
+
+static int exynos_pm_suspend(void)
+{
+	exynos_pm_central_suspend();
+
+	if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9)
+		exynos_cpu_save_register();
+
+	return 0;
+}
+
+static void exynos_pm_release_retention(void)
+{
+	unsigned int i;
+
+	for (i = 0; (pm_data->release_ret_regs[i] != REG_TABLE_END); i++)
+		pmu_raw_writel(EXYNOS_WAKEUP_FROM_LOWPWR,
+				pm_data->release_ret_regs[i]);
+}
+
+static void exynos_pm_resume(void)
+{
+	u32 cpuid = read_cpuid_part();
+
+	if (exynos_pm_central_resume())
+		goto early_wakeup;
+
+	/* For release retention */
+	exynos_pm_release_retention();
+
+	if (pm_data->extra_save)
+		s3c_pm_do_restore_core(pm_data->extra_save,
+					pm_data->num_extra_save);
+
+	s3c_pm_do_restore_core(exynos_core_save, ARRAY_SIZE(exynos_core_save));
+
+	if (cpuid == ARM_CPU_PART_CORTEX_A9)
+		scu_enable(S5P_VA_SCU);
+
+	if (call_firmware_op(resume) == -ENOSYS
+	    && cpuid == ARM_CPU_PART_CORTEX_A9)
+		exynos_cpu_restore_register();
+
+early_wakeup:
+
+	/* Clear SLEEP mode set in INFORM1 */
+	pmu_raw_writel(0x0, S5P_INFORM1);
+}
+
+/*
+ * Suspend Ops
+ */
+
+static int exynos_suspend_enter(suspend_state_t state)
+{
+	int ret;
+
+	s3c_pm_debug_init();
+
+	S3C_PMDBG("%s: suspending the system...\n", __func__);
+
+	S3C_PMDBG("%s: wakeup masks: %08x,%08x\n", __func__,
+			exynos_irqwake_intmask, exynos_get_eint_wake_mask());
+
+	if (exynos_irqwake_intmask == -1U
+	    && exynos_get_eint_wake_mask() == -1U) {
+		pr_err("%s: No wake-up sources!\n", __func__);
+		pr_err("%s: Aborting sleep\n", __func__);
+		return -EINVAL;
+	}
+
+	s3c_pm_save_uarts();
+	if (pm_data->pm_prepare)
+		pm_data->pm_prepare();
+	flush_cache_all();
+	s3c_pm_check_store();
+
+	ret = call_firmware_op(suspend);
+	if (ret == -ENOSYS)
+		ret = cpu_suspend(0, pm_data->cpu_suspend);
+	if (ret)
+		return ret;
+
+	s3c_pm_restore_uarts();
+
+	S3C_PMDBG("%s: wakeup stat: %08x\n", __func__,
+			pmu_raw_readl(S5P_WAKEUP_STAT));
+
+	s3c_pm_check_restore();
+
+	S3C_PMDBG("%s: resuming the system...\n", __func__);
+
+	return 0;
+}
+
+static int exynos_suspend_prepare(void)
+{
+	s3c_pm_check_prepare();
+
+	return 0;
+}
+
+static void exynos_suspend_finish(void)
+{
+	s3c_pm_check_cleanup();
+}
+
+static const struct platform_suspend_ops exynos_suspend_ops = {
+	.enter		= exynos_suspend_enter,
+	.prepare	= exynos_suspend_prepare,
+	.finish		= exynos_suspend_finish,
+	.valid		= suspend_valid_only_mem,
+};
+
+static const struct exynos_pm_data exynos4_pm_data = {
+	.wkup_irq	= exynos4_wkup_irq,
+	.wake_disable_mask = ((0xFF << 8) | (0x1F << 1)),
+	.release_ret_regs = exynos_release_ret_regs,
+	.pm_suspend	= exynos_pm_suspend,
+	.pm_resume	= exynos_pm_resume,
+	.pm_prepare	= exynos_pm_prepare,
+	.cpu_suspend	= exynos_cpu_suspend,
+};
+
+static const struct exynos_pm_data exynos5250_pm_data = {
+	.wkup_irq	= exynos5250_wkup_irq,
+	.wake_disable_mask = ((0xFF << 8) | (0x1F << 1)),
+	.release_ret_regs = exynos_release_ret_regs,
+	.extra_save	= exynos5_sys_save,
+	.num_extra_save	= ARRAY_SIZE(exynos5_sys_save),
+	.pm_suspend	= exynos_pm_suspend,
+	.pm_resume	= exynos_pm_resume,
+	.pm_prepare	= exynos_pm_prepare,
+	.cpu_suspend	= exynos_cpu_suspend,
+};
+
+static struct of_device_id exynos_pmu_of_device_ids[] = {
+	{
+		.compatible = "samsung,exynos4210-pmu",
+		.data = &exynos4_pm_data,
+	}, {
+		.compatible = "samsung,exynos4212-pmu",
+		.data = &exynos4_pm_data,
+	}, {
+		.compatible = "samsung,exynos4412-pmu",
+		.data = &exynos4_pm_data,
+	}, {
+		.compatible = "samsung,exynos5250-pmu",
+		.data = &exynos5250_pm_data,
+	},
+	{ /*sentinel*/ },
+};
+
+static struct syscore_ops exynos_pm_syscore_ops;
+
+void __init exynos_pm_init(void)
+{
+	const struct of_device_id *match;
+	u32 tmp;
+
+	of_find_matching_node_and_match(NULL, exynos_pmu_of_device_ids, &match);
+	if (!match) {
+		pr_err("Failed to find PMU node\n");
+		return;
+	}
+	pm_data = (struct exynos_pm_data *) match->data;
+
+	/* Platform-specific GIC callback */
+	gic_arch_extn.irq_set_wake = exynos_irq_set_wake;
+
+	/* All wakeup disable */
+	tmp = pmu_raw_readl(S5P_WAKEUP_MASK);
+	tmp |= pm_data->wake_disable_mask;
+	pmu_raw_writel(tmp, S5P_WAKEUP_MASK);
+
+	exynos_pm_syscore_ops.suspend	= pm_data->pm_suspend;
+	exynos_pm_syscore_ops.resume	= pm_data->pm_resume;
+
+	register_syscore_ops(&exynos_pm_syscore_ops);
+	suspend_set_ops(&exynos_suspend_ops);
+}
