commit 45984f0c70ccc03e09f97ee5d0749396547b6594
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Sat Jan 4 16:20:51 2020 +0100

    ARM: samsung: Rename Samsung and Exynos to lowercase
    
    Fix up inconsistent usage of upper and lowercase letters in "Samsung"
    and "Exynos" names.
    
    "SAMSUNG" and "EXYNOS" are not abbreviations but regular trademarked
    names.  Therefore they should be written with lowercase letters starting
    with capital letter.
    
    The lowercase "Exynos" name is promoted by its manufacturer Samsung
    Electronics Co., Ltd., in advertisement materials and on website.
    
    Although advertisement materials usually use uppercase "SAMSUNG", the
    lowercase version is used in all legal aspects (e.g. on Wikipedia and in
    privacy/legal statements on
    https://www.samsung.com/semiconductor/privacy-global/).
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 48e7fb38613e..78af34cc89cc 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -3,7 +3,7 @@
 // Copyright (c) 2011-2014 Samsung Electronics Co., Ltd.
 //		http://www.samsung.com
 //
-// EXYNOS - Power Management support
+// Exynos - Power Management support
 //
 // Based on arch/arm/mach-s3c2410/pm.c
 // Copyright (c) 2006 Simtec Electronics

commit 3c33710b453b4e17074092773872a4d87d9b3bb8
Author: Pankaj Dubey <pankaj.dubey@samsung.com>
Date:   Thu May 10 13:02:54 2018 +0200

    ARM: exynos: Remove static mapping of SCU SFR
    
    Lets remove static mapping of SCU SFR mainly used in CORTEX-A9 SoC based
    boards. Instead use mapping from device tree node of SCU.
    
    Signed-off-by: Pankaj Dubey <pankaj.dubey@samsung.com>
    Reviewed-by: Alim Akhtar <alim.akhtar@samsung.com>
    [mszyprow: rebased, added fallback to scu_a9_get_base() when no SCU DT
     node is available, removed compatibility break warning, fixed non-SMP
     build, keep SCU base mapping to avoid issues with calls from CPUidle]
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index a822c5073715..48e7fb38613e 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -22,8 +22,6 @@
 #include <asm/suspend.h>
 #include <asm/cacheflush.h>
 
-#include <mach/map.h>
-
 #include "common.h"
 
 static inline void __iomem *exynos_boot_vector_addr(void)
@@ -172,7 +170,7 @@ void exynos_enter_aftr(void)
 	cpu_suspend(0, exynos_aftr_finisher);
 
 	if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9) {
-		scu_enable(S5P_VA_SCU);
+		exynos_scu_enable();
 		if (call_firmware_op(resume) == -ENOSYS)
 			exynos_cpu_restore_register();
 	}

commit ae35c4835699933335e76ab2d6a245303592ceea
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Wed Mar 21 10:46:39 2018 +0100

    ARM: EXYNOS: Simplify code in coupled CPU idle hot path
    
    exynos_enter_aftr() is called by coupled CPU idle code every time CPU
    enters idle state, what can be considered as a hot path. Replace
    of_machine_is_compatible() call with a simple SoC revision check.
    
    of_machine_is_compatible() function performs a dozen of string comparisons
    during the full device tree walk, while soc_is_exynos4412() is a simple
    integer check on SoC revision variable.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index a1055a2b8d54..a822c5073715 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -163,7 +163,7 @@ void exynos_enter_aftr(void)
 
 	exynos_pm_central_suspend();
 
-	if (of_machine_is_compatible("samsung,exynos4412")) {
+	if (soc_is_exynos4412()) {
 		/* Setting SEQ_OPTION register */
 		pmu_raw_writel(S5P_USE_STANDBY_WFI0 | S5P_USE_STANDBY_WFE0,
 			       S5P_CENTRAL_SEQ_OPTION);

commit a7480dbcf983c31d8111f864c848e8a75116a87d
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Wed Mar 21 10:45:05 2018 +0100

    ARM: EXYNOS: Fix coupled CPU idle freeze on Exynos4210
    
    Since commit 04c8b0f82c7d ("irqchip/gic: Make locking a BL_SWITCHER only
    feature") coupled CPU idle freezes from time to time on Exynos4210. Later
    commit 313c8c16ee62 ("PM / CPU: replace raw_notifier with atomic_notifier")
    changed the context in which the CPU idle code is executed, what results
    in fully reproducible freeze all the time. However, almost the same coupled
    CPU idle code works fine on Exynos3250 regardless of the changes made in
    the mentioned commits.
    
    It turned out that the IPI call used on Exynos4210 is conflicting with the
    change done in the first mentioned commit in GIC. Fix this by using the
    same code path as for Exynos3250, instead of the IPI call for
    synchronization with second CPU core, call dsb_sev() directly.
    
    Tested on Exynos4210-based Trats and Origen boards.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    CC: <stable@vger.kernel.org> # v4.13+
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index dc4346ecf16d..a1055a2b8d54 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -271,11 +271,7 @@ static int exynos_cpu0_enter_aftr(void)
 				goto fail;
 
 			call_firmware_op(cpu_boot, 1);
-
-			if (soc_is_exynos3250())
-				dsb_sev();
-			else
-				arch_send_wakeup_ipi_mask(cpumask_of(1));
+			dsb_sev();
 		}
 	}
 fail:

commit 347863d47a17efa742799da468c64e9673658945
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Mon Dec 25 20:54:31 2017 +0100

    ARM: EXYNOS: Add SPDX license identifiers
    
    Replace GPL license statements with SPDX license identifiers (GPL-2.0
    and GPL-2.0+).
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index c9740d96db9e..dc4346ecf16d 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -1,17 +1,13 @@
-/*
- * Copyright (c) 2011-2014 Samsung Electronics Co., Ltd.
- *		http://www.samsung.com
- *
- * EXYNOS - Power Management support
- *
- * Based on arch/arm/mach-s3c2410/pm.c
- * Copyright (c) 2006 Simtec Electronics
- *	Ben Dooks <ben@simtec.co.uk>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
-*/
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (c) 2011-2014 Samsung Electronics Co., Ltd.
+//		http://www.samsung.com
+//
+// EXYNOS - Power Management support
+//
+// Based on arch/arm/mach-s3c2410/pm.c
+// Copyright (c) 2006 Simtec Electronics
+//	Ben Dooks <ben@simtec.co.uk>
 
 #include <linux/init.h>
 #include <linux/suspend.h>

commit 9e43eca3c87476f75680f472ff3ebcd85f357b86
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Wed Oct 4 08:38:22 2017 +0200

    ARM: EXYNOS: Remove Exynos4212 related dead code
    
    Support for Exynos4212 SoCs has been removed by commit bca9085e0ae9 ("ARM:
    dts: exynos: remove Exynos4212 support (dead code)"), so there is no need
    to keep remaining dead code related to this SoC version.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 1a7e5b5d08d8..c9740d96db9e 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -167,8 +167,7 @@ void exynos_enter_aftr(void)
 
 	exynos_pm_central_suspend();
 
-	if (of_machine_is_compatible("samsung,exynos4212") ||
-	    of_machine_is_compatible("samsung,exynos4412")) {
+	if (of_machine_is_compatible("samsung,exynos4412")) {
 		/* Setting SEQ_OPTION register */
 		pmu_raw_writel(S5P_USE_STANDBY_WFI0 | S5P_USE_STANDBY_WFE0,
 			       S5P_CENTRAL_SEQ_OPTION);

commit 64fc2a947a9873700929ec0ef02b4654a04e0476
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sun Jan 15 03:59:29 2017 +0100

    ARM: 8641/1: treewide: Replace uses of virt_to_phys with __pa_symbol
    
    All low-level PM/SMP code using virt_to_phys() should actually use
    __pa_symbol() against kernel symbols. Update code where relevant to move
    away from virt_to_phys().
    
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Laura Abbott <labbott@redhat.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 487295f4a56b..1a7e5b5d08d8 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -132,7 +132,7 @@ static void exynos_set_wakeupmask(long mask)
 
 static void exynos_cpu_set_boot_vector(long flags)
 {
-	writel_relaxed(virt_to_phys(exynos_cpu_resume),
+	writel_relaxed(__pa_symbol(exynos_cpu_resume),
 		       exynos_boot_vector_addr());
 	writel_relaxed(flags, exynos_boot_vector_flag());
 }
@@ -238,7 +238,7 @@ static int exynos_cpu0_enter_aftr(void)
 
 abort:
 	if (cpu_online(1)) {
-		unsigned long boot_addr = virt_to_phys(exynos_cpu_resume);
+		unsigned long boot_addr = __pa_symbol(exynos_cpu_resume);
 
 		/*
 		 * Set the boot vector to something non-zero
@@ -330,7 +330,7 @@ static int exynos_cpu1_powerdown(void)
 
 static void exynos_pre_enter_aftr(void)
 {
-	unsigned long boot_addr = virt_to_phys(exynos_cpu_resume);
+	unsigned long boot_addr = __pa_symbol(exynos_cpu_resume);
 
 	(void)exynos_set_boot_addr(1, boot_addr);
 }

commit d0ceee0b4d63d5a31e8ada86f7d07806b0ad6585
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Tue Jun 21 11:20:25 2016 +0100

    ARM: EXYNOS: Fixup endian in pm/pmu
    
    Fix the PMU code endian access code to deal with kernels built for big endian
    operation.
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index c43b776a51a3..487295f4a56b 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -132,9 +132,9 @@ static void exynos_set_wakeupmask(long mask)
 
 static void exynos_cpu_set_boot_vector(long flags)
 {
-	__raw_writel(virt_to_phys(exynos_cpu_resume),
-		     exynos_boot_vector_addr());
-	__raw_writel(flags, exynos_boot_vector_flag());
+	writel_relaxed(virt_to_phys(exynos_cpu_resume),
+		       exynos_boot_vector_addr());
+	writel_relaxed(flags, exynos_boot_vector_flag());
 }
 
 static int exynos_aftr_finisher(unsigned long flags)

commit a4781441f223ac11bc539c2e2bd86ffa0c967ca7
Author: Pankaj Dubey <pankaj.dubey@samsung.com>
Date:   Thu Feb 25 09:39:59 2016 +0530

    ARM: EXYNOS: Cleanup header files inclusion
    
    This includes trivial cleanup in exynos files such as
     - remove unused header files inclusion from exynos.c, s5p-dev-mfc.c,
       firmware.c, pm.c.
     - move inclusion of of.h from common.h to pm.c where it is really
       required
    
    Signed-off-by: Pankaj Dubey <pankaj.dubey@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index b9b9186f8781..c43b776a51a3 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -17,7 +17,7 @@
 #include <linux/suspend.h>
 #include <linux/cpu_pm.h>
 #include <linux/io.h>
-#include <linux/err.h>
+#include <linux/of.h>
 #include <linux/soc/samsung/exynos-regs-pmu.h>
 #include <linux/soc/samsung/exynos-pmu.h>
 
@@ -28,8 +28,6 @@
 
 #include <mach/map.h>
 
-#include <plat/pm-common.h>
-
 #include "common.h"
 
 static inline void __iomem *exynos_boot_vector_addr(void)

commit 2262d6ef517f9f0d427015cb9a790b86a2c95fed
Author: Pankaj Dubey <pankaj.dubey@samsung.com>
Date:   Fri Dec 18 09:02:11 2015 +0530

    ARM: EXYNOS: Move pmu specific headers under "linux/soc/samsung"
    
    Moving Exynos PMU specific header file into "include/linux/soc/samsung"
    thus updated affected files under "mach-exynos" to use new location of
    these header files.
    
    Signed-off-by: Amit Daniel Kachhap <amitdanielk@gmail.com>
    [tested on Peach-Pi (Exynos5880)]
    Signed-off-by: Pankaj Dubey <pankaj.dubey@samsung.com>
    Reviewed-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    [for testing on Trats2 (Exynos4412) and Odroid XU3 (Exynos5422)]
    Tested-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 9c1506b499bc..b9b9186f8781 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -18,6 +18,8 @@
 #include <linux/cpu_pm.h>
 #include <linux/io.h>
 #include <linux/err.h>
+#include <linux/soc/samsung/exynos-regs-pmu.h>
+#include <linux/soc/samsung/exynos-pmu.h>
 
 #include <asm/firmware.h>
 #include <asm/smp_scu.h>
@@ -29,8 +31,6 @@
 #include <plat/pm-common.h>
 
 #include "common.h"
-#include "exynos-pmu.h"
-#include "regs-pmu.h"
 
 static inline void __iomem *exynos_boot_vector_addr(void)
 {

commit af9971144dde808338919cb4f3849ea2ac60739f
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Wed Mar 18 14:09:57 2015 +0100

    ARM: EXYNOS: add coupled cpuidle support for Exynos3250
    
    The following patch adds coupled cpuidle support for Exynos3250 to
    an existing cpuidle-exynos driver.  As a result it enables AFTR mode
    to be used by default on Exynos3250 without the need to hot unplug
    CPU1 first.
    
    The detailed changelog:
    - use exynos_[get,set]_boot_addr() in cpuidle-exynos.c and then make
      cpu_boot_reg_base() static
    - use exynos_core_restart() in exynos_cpu0_enter_aftr()
    - add missing smp_rmb() to exynos_cpu0_enter_aftr() (to make the code
      in-sync with the platform SMP code)
    - add call_firmware_op(cpu_boot, 1) to exynos_cpu0_enter_aftr()
    - use dsb_sev() instead of IPI wakeup for Exynos3250 in
      exynos_cpu0_enter_aftr()
    - add CPU0 vs CPU1 synchronization based on S5P_PMU_SPARE2 register
      for Exynos3250 to cpuidle-exynos.c
    - add flush_cache_all() for CPU1/0 before powerdown/AFTR for
      Exynos3250 to exynos_wfi_finisher()/exynos_do_idle()
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index cc75ab448be3..9c1506b499bc 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -22,6 +22,7 @@
 #include <asm/firmware.h>
 #include <asm/smp_scu.h>
 #include <asm/suspend.h>
+#include <asm/cacheflush.h>
 
 #include <mach/map.h>
 
@@ -209,6 +210,8 @@ static int exynos_cpu0_enter_aftr(void)
 		 * sequence, let's wait for one of these to happen
 		 */
 		while (exynos_cpu_power_state(1)) {
+			unsigned long boot_addr;
+
 			/*
 			 * The other cpu may skip idle and boot back
 			 * up again
@@ -221,7 +224,11 @@ static int exynos_cpu0_enter_aftr(void)
 			 * boot back up again, getting stuck in the
 			 * boot rom code
 			 */
-			if (__raw_readl(cpu_boot_reg_base()) == 0)
+			ret = exynos_get_boot_addr(1, &boot_addr);
+			if (ret)
+				goto fail;
+			ret = -1;
+			if (boot_addr == 0)
 				goto abort;
 
 			cpu_relax();
@@ -233,11 +240,14 @@ static int exynos_cpu0_enter_aftr(void)
 
 abort:
 	if (cpu_online(1)) {
+		unsigned long boot_addr = virt_to_phys(exynos_cpu_resume);
+
 		/*
 		 * Set the boot vector to something non-zero
 		 */
-		__raw_writel(virt_to_phys(exynos_cpu_resume),
-			     cpu_boot_reg_base());
+		ret = exynos_set_boot_addr(1, boot_addr);
+		if (ret)
+			goto fail;
 		dsb();
 
 		/*
@@ -247,22 +257,42 @@ static int exynos_cpu0_enter_aftr(void)
 		while (exynos_cpu_power_state(1) != S5P_CORE_LOCAL_PWR_EN)
 			cpu_relax();
 
+		if (soc_is_exynos3250()) {
+			while (!pmu_raw_readl(S5P_PMU_SPARE2) &&
+			       !atomic_read(&cpu1_wakeup))
+				cpu_relax();
+
+			if (!atomic_read(&cpu1_wakeup))
+				exynos_core_restart(1);
+		}
+
 		while (!atomic_read(&cpu1_wakeup)) {
+			smp_rmb();
+
 			/*
 			 * Poke cpu1 out of the boot rom
 			 */
-			__raw_writel(virt_to_phys(exynos_cpu_resume),
-				     cpu_boot_reg_base());
 
-			arch_send_wakeup_ipi_mask(cpumask_of(1));
+			ret = exynos_set_boot_addr(1, boot_addr);
+			if (ret)
+				goto fail;
+
+			call_firmware_op(cpu_boot, 1);
+
+			if (soc_is_exynos3250())
+				dsb_sev();
+			else
+				arch_send_wakeup_ipi_mask(cpumask_of(1));
 		}
 	}
-
+fail:
 	return ret;
 }
 
 static int exynos_wfi_finisher(unsigned long flags)
 {
+	if (soc_is_exynos3250())
+		flush_cache_all();
 	cpu_do_idle();
 
 	return -1;
@@ -283,6 +313,9 @@ static int exynos_cpu1_powerdown(void)
 	 */
 	exynos_cpu_power_down(1);
 
+	if (soc_is_exynos3250())
+		pmu_raw_writel(0, S5P_PMU_SPARE2);
+
 	ret = cpu_suspend(0, exynos_wfi_finisher);
 
 	cpu_pm_exit();
@@ -299,7 +332,9 @@ static int exynos_cpu1_powerdown(void)
 
 static void exynos_pre_enter_aftr(void)
 {
-	__raw_writel(virt_to_phys(exynos_cpu_resume), cpu_boot_reg_base());
+	unsigned long boot_addr = virt_to_phys(exynos_cpu_resume);
+
+	(void)exynos_set_boot_addr(1, boot_addr);
 }
 
 static void exynos_post_enter_aftr(void)

commit e6c81cce5699ec6be3a7533b5ad7a062ab3357f2
Merge: d0440c59f52d a018bb2ff958
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 22 09:08:39 2015 -0700

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform updates from Olof Johansson:
     "Our SoC branch usually contains expanded support for new SoCs and
      other core platform code.  In this case, that includes:
    
       - support for the new Annapurna Labs "Alpine" platform
    
       - a rework greatly simplifying adding new platform support to the
         MCPM subsystem (Multi-cluster power management)
    
       - cpuidle and PM improvements for Exynos3250
    
       - misc updates for Renesas, OMAP, Meson, i.MX.  Some of these could
         have gone in other branches but ended up here for various reasons"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (53 commits)
      ARM: alpine: add support for generic pci
      ARM: Exynos: migrate DCSCB to the new MCPM backend abstraction
      ARM: vexpress: migrate DCSCB to the new MCPM backend abstraction
      ARM: vexpress: DCSCB: tighten CPU validity assertion
      ARM: vexpress: migrate TC2 to the new MCPM backend abstraction
      ARM: MCPM: move the algorithmic complexity to the core code
      ARM: EXYNOS: allow cpuidle driver usage on Exynos3250 SoC
      ARM: EXYNOS: add AFTR mode support for Exynos3250
      ARM: EXYNOS: add code for setting/clearing boot flag
      ARM: EXYNOS: fix CPU1 hotplug on Exynos3250
      ARM: S3C64XX: Use fixed IRQ bases to avoid conflicts on Cragganmore
      ARM: cygnus: fix const declaration bcm_cygnus_dt_compat
      ARM: DRA7: hwmod: Fix the hwmod class for GPTimer4
      ARM: DRA7: hwmod: Add data for GPTimers 13 through 16
      ARM: EXYNOS: Remove left over 'extra_save'
      ARM: EXYNOS: Constify exynos_pm_data array
      ARM: EXYNOS: use static in suspend.c
      ARM: EXYNOS: Use platform device name as power domain name
      ARM: EXYNOS: add support for async-bridge clocks for pm_domains
      ARM: omap-device: add missed callback for suspend-to-disk
      ...

commit 89366409748c2de0521cf4303bfb1247676882df
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Fri Mar 27 02:35:48 2015 +0900

    ARM: EXYNOS: add AFTR mode support for Exynos3250
    
    AFTR mode support brings reduced energy consumption and is
    a prerequisite for more advanced W-AFTR/LPA power saving modes.
    
    AFTR mode has been already supported on other Exynos SoCs for
    few years and this patch adds its support for Exynos3250 SoC.
    
    The differences in Exynos3250 SoC AFTR mode support when compared
    to Exynos4x12 SoCs are:
    - different secure firmware calls are used
    - different S5P_WAKEUP_MASK wakeup mask is used
    - S5P_WAKEUP_MASK2 wakeup mask needs to be set in addition to
      the standard S5P_WAKEUP_MASK one
    - C2_STATE BOOT mode flag needs to be set/cleared pre/post AFTR
    
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Tested-by: Chanwoo Choi <cw00.choi@samsung.com>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index e6209dadc00d..0a7e3afd6fc7 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -127,6 +127,8 @@ int exynos_pm_central_resume(void)
 static void exynos_set_wakeupmask(long mask)
 {
 	pmu_raw_writel(mask, S5P_WAKEUP_MASK);
+	if (soc_is_exynos3250())
+		pmu_raw_writel(0x0, S5P_WAKEUP_MASK2);
 }
 
 static void exynos_cpu_set_boot_vector(long flags)
@@ -140,7 +142,7 @@ static int exynos_aftr_finisher(unsigned long flags)
 {
 	int ret;
 
-	exynos_set_wakeupmask(0x0000ff3e);
+	exynos_set_wakeupmask(soc_is_exynos3250() ? 0x40003ffe : 0x0000ff3e);
 	/* Set value of power down register for aftr mode */
 	exynos_sys_powerdown_conf(SYS_AFTR);
 
@@ -157,8 +159,13 @@ static int exynos_aftr_finisher(unsigned long flags)
 
 void exynos_enter_aftr(void)
 {
+	unsigned int cpuid = smp_processor_id();
+
 	cpu_pm_enter();
 
+	if (soc_is_exynos3250())
+		exynos_set_boot_flag(cpuid, C2_STATE);
+
 	exynos_pm_central_suspend();
 
 	if (of_machine_is_compatible("samsung,exynos4212") ||
@@ -178,6 +185,9 @@ void exynos_enter_aftr(void)
 
 	exynos_pm_central_resume();
 
+	if (soc_is_exynos3250())
+		exynos_clear_boot_flag(cpuid, C2_STATE);
+
 	cpu_pm_exit();
 }
 

commit cfdda3535f87e752780ca18a57d13db58f6a6913
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Wed Mar 18 03:26:11 2015 +0900

    ARM: EXYNOS: Fix build breakage cpuidle on !SMP
    
    The Exynos cpuidle driver has coupled cpuidle built-in so it cannot be
    built without SMP:
    
    arch/arm/mach-exynos/pm.c: In function 'exynos_cpu0_enter_aftr':
    arch/arm/mach-exynos/pm.c:246:4: error: implicit declaration of function 'arch_send_wakeup_ipi_mask' [-Werror=implicit-function-declaration]
    arch/arm/mach-exynos/built-in.o: In function 'exynos_pre_enter_aftr':
    ../arch/arm/mach-exynos/pm.c:300: undefined reference to 'cpu_boot_reg_base'
    arch/arm/mach-exynos/built-in.o: In function 'exynos_cpu1_powerdown':
    ../arch/arm/mach-exynos/pm.c:282: undefined reference to 'exynos_cpu_power_down'
    
    Fix it by adding missing checks for SMP.
    
    Reported-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index e6209dadc00d..5685250693fd 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -181,6 +181,7 @@ void exynos_enter_aftr(void)
 	cpu_pm_exit();
 }
 
+#if defined(CONFIG_SMP) && defined(CONFIG_ARM_EXYNOS_CPUIDLE)
 static atomic_t cpu1_wakeup = ATOMIC_INIT(0);
 
 static int exynos_cpu0_enter_aftr(void)
@@ -302,3 +303,4 @@ struct cpuidle_exynos_data cpuidle_coupled_exynos_data = {
 	.pre_enter_aftr		= exynos_pre_enter_aftr,
 	.post_enter_aftr		= exynos_post_enter_aftr,
 };
+#endif /* CONFIG_SMP && CONFIG_ARM_EXYNOS_CPUIDLE */

commit 18656782a820f075cb5c168a2e381a8938b1550a
Merge: a233bb742aed 6f4554bdff68
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 17 09:38:59 2015 -0800

    Merge tag 'drivers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC driver updates from Olof Johansson:
     "These are changes for drivers that are intimately tied to some SoC and
      for some reason could not get merged through the respective subsystem
      maintainer tree.
    
      This time around, much of this is for at91, with the bulk of it being
      syscon and udc drivers.
    
      Also, there's:
       - coupled cpuidle support for Samsung Exynos4210
       - Renesas 73A0 common-clk work
       - of/platform changes to tear down DMA mappings on device destruction
       - a few updates to the TI Keystone knav code"
    
    * tag 'drivers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (26 commits)
      cpuidle: exynos: add coupled cpuidle support for exynos4210
      ARM: EXYNOS: apply S5P_CENTRAL_SEQ_OPTION fix only when necessary
      soc: ti: knav_qmss_queue: change knav_range_setup_acc_irq to static
      soc: ti: knav_qmss_queue: makefile tweak to build as dynamic module
      pcmcia: at91_cf: depend on !ARCH_MULTIPLATFORM
      soc: ti: knav_qmss_queue: export API calls for use by user driver
      of/platform: teardown DMA mappings on device destruction
      usb: gadget: at91_udc: Allocate udc instance
      usb: gadget: at91_udc: Update DT binding documentation
      usb: gadget: at91_udc: Rework for multi-platform kernel support
      usb: gadget: at91_udc: Simplify probe and remove functions
      usb: gadget: at91_udc: Remove non-DT handling code
      usb: gadget: at91_udc: Document DT clocks and clock-names property
      usb: gadget: at91_udc: Drop uclk clock
      usb: gadget: at91_udc: Fix clock names
      mfd: syscon: Add Atmel SMC binding doc
      mfd: syscon: Add atmel-smc registers definition
      mfd: syscon: Add Atmel Matrix bus DT binding documentation
      mfd: syscon: Add atmel-matrix registers definition
      clk: shmobile: fix sparse NULL pointer warning
      ...

commit 712eddf70225ab5ae65e946e22d2dfe6b93e8dd1
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Sat Jan 24 14:05:50 2015 +0900

    cpuidle: exynos: add coupled cpuidle support for exynos4210
    
    The following patch adds coupled cpuidle support for Exynos4210 to
    an existing cpuidle-exynos driver.  As a result it enables AFTR mode
    to be used by default on Exynos4210 without the need to hot unplug
    CPU1 first.
    
    The patch is heavily based on earlier cpuidle-exynos4210 driver from
    Daniel Lezcano:
    
    http://www.spinics.net/lists/linux-samsung-soc/msg28134.html
    
    Changes from Daniel's code include:
    - porting code to current kernels
    - fixing it to work on my setup (by using S5P_INFORM register
      instead of S5P_VA_SYSRAM one on Revison 1.1 and retrying poking
      CPU1 out of the BOOT ROM if necessary)
    - fixing rare lockup caused by waiting for CPU1 to get stuck in
      the BOOT ROM (CPU hotplug code in arch/arm/mach-exynos/platsmp.c
      doesn't require this and works fine)
    - moving Exynos specific code to arch/arm/mach-exynos/pm.c
    - using cpu_boot_reg_base() helper instead of BOOT_VECTOR macro
    - using exynos_cpu_*() helpers instead of accessing registers
      directly
    - using arch_send_wakeup_ipi_mask() instead of dsb_sev()
      (this matches CPU hotplug code in arch/arm/mach-exynos/platsmp.c)
    - integrating separate exynos4210-cpuidle driver into existing
      exynos-cpuidle one
    
    Cc: Colin Cross <ccross@google.com>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Cc: Tomasz Figa <tomasz.figa@gmail.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 159eb4c9779e..1f9cbd434c60 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -179,3 +179,125 @@ void exynos_enter_aftr(void)
 
 	cpu_pm_exit();
 }
+
+static atomic_t cpu1_wakeup = ATOMIC_INIT(0);
+
+static int exynos_cpu0_enter_aftr(void)
+{
+	int ret = -1;
+
+	/*
+	 * If the other cpu is powered on, we have to power it off, because
+	 * the AFTR state won't work otherwise
+	 */
+	if (cpu_online(1)) {
+		/*
+		 * We reach a sync point with the coupled idle state, we know
+		 * the other cpu will power down itself or will abort the
+		 * sequence, let's wait for one of these to happen
+		 */
+		while (exynos_cpu_power_state(1)) {
+			/*
+			 * The other cpu may skip idle and boot back
+			 * up again
+			 */
+			if (atomic_read(&cpu1_wakeup))
+				goto abort;
+
+			/*
+			 * The other cpu may bounce through idle and
+			 * boot back up again, getting stuck in the
+			 * boot rom code
+			 */
+			if (__raw_readl(cpu_boot_reg_base()) == 0)
+				goto abort;
+
+			cpu_relax();
+		}
+	}
+
+	exynos_enter_aftr();
+	ret = 0;
+
+abort:
+	if (cpu_online(1)) {
+		/*
+		 * Set the boot vector to something non-zero
+		 */
+		__raw_writel(virt_to_phys(exynos_cpu_resume),
+			     cpu_boot_reg_base());
+		dsb();
+
+		/*
+		 * Turn on cpu1 and wait for it to be on
+		 */
+		exynos_cpu_power_up(1);
+		while (exynos_cpu_power_state(1) != S5P_CORE_LOCAL_PWR_EN)
+			cpu_relax();
+
+		while (!atomic_read(&cpu1_wakeup)) {
+			/*
+			 * Poke cpu1 out of the boot rom
+			 */
+			__raw_writel(virt_to_phys(exynos_cpu_resume),
+				     cpu_boot_reg_base());
+
+			arch_send_wakeup_ipi_mask(cpumask_of(1));
+		}
+	}
+
+	return ret;
+}
+
+static int exynos_wfi_finisher(unsigned long flags)
+{
+	cpu_do_idle();
+
+	return -1;
+}
+
+static int exynos_cpu1_powerdown(void)
+{
+	int ret = -1;
+
+	/*
+	 * Idle sequence for cpu1
+	 */
+	if (cpu_pm_enter())
+		goto cpu1_aborted;
+
+	/*
+	 * Turn off cpu 1
+	 */
+	exynos_cpu_power_down(1);
+
+	ret = cpu_suspend(0, exynos_wfi_finisher);
+
+	cpu_pm_exit();
+
+cpu1_aborted:
+	dsb();
+	/*
+	 * Notify cpu 0 that cpu 1 is awake
+	 */
+	atomic_set(&cpu1_wakeup, 1);
+
+	return ret;
+}
+
+static void exynos_pre_enter_aftr(void)
+{
+	__raw_writel(virt_to_phys(exynos_cpu_resume), cpu_boot_reg_base());
+}
+
+static void exynos_post_enter_aftr(void)
+{
+	atomic_set(&cpu1_wakeup, 0);
+}
+
+struct cpuidle_exynos_data cpuidle_coupled_exynos_data = {
+	.cpu0_enter_aftr		= exynos_cpu0_enter_aftr,
+	.cpu1_powerdown		= exynos_cpu1_powerdown,
+	.pre_enter_aftr		= exynos_pre_enter_aftr,
+	.post_enter_aftr		= exynos_post_enter_aftr,
+};

commit 865e8b76a04d018f23d809ebf735c52105e3adb2
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Sat Jan 24 14:05:50 2015 +0900

    ARM: EXYNOS: apply S5P_CENTRAL_SEQ_OPTION fix only when necessary
    
    Commit c2dd114d2486 ("ARM: EXYNOS: fix register setup for AFTR mode
    code") added S5P_CENTRAL_SEQ_OPTION register setup fix for all
    Exynos SoCs to AFTR mode code-path.  It turned out that for coupled
    cpuidle AFTR mode on Exynos4210 (added by the next patch) applying
    this fix causes lockup so enable it in the AFTR mode code-path only
    on SoCs that require it (in the suspend code-path it can be always
    applied like it was before commit c2dd114d2486 ("ARM: EXYNOS: fix
    register setup for AFTR mode code")
    
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Colin Cross <ccross@google.com>
    Cc: Tomasz Figa <tomasz.figa@gmail.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Reviewed-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 86f3ecd88f78..159eb4c9779e 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -97,10 +97,6 @@ void exynos_pm_central_suspend(void)
 	tmp = pmu_raw_readl(S5P_CENTRAL_SEQ_CONFIGURATION);
 	tmp &= ~S5P_CENTRAL_LOWPWR_CFG;
 	pmu_raw_writel(tmp, S5P_CENTRAL_SEQ_CONFIGURATION);
-
-	/* Setting SEQ_OPTION register */
-	pmu_raw_writel(S5P_USE_STANDBY_WFI0 | S5P_USE_STANDBY_WFE0,
-		       S5P_CENTRAL_SEQ_OPTION);
 }
 
 int exynos_pm_central_resume(void)
@@ -164,6 +160,13 @@ void exynos_enter_aftr(void)
 
 	exynos_pm_central_suspend();
 
+	if (of_machine_is_compatible("samsung,exynos4212") ||
+	    of_machine_is_compatible("samsung,exynos4412")) {
+		/* Setting SEQ_OPTION register */
+		pmu_raw_writel(S5P_USE_STANDBY_WFI0 | S5P_USE_STANDBY_WFE0,
+			       S5P_CENTRAL_SEQ_OPTION);
+	}
+
 	cpu_suspend(0, exynos_aftr_finisher);
 
 	if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9) {

commit 32b0aa9aaeb4a493135ea6368a614aa89c3c5488
Author: Pankaj Dubey <pankaj.dubey@samsung.com>
Date:   Fri Jan 9 01:14:23 2015 +0900

    ARM: EXYNOS: Remove i2c sys configuration related code
    
    As all these code has been moved into i2c driver, now we can
    safely remove them from machine files.
    
    CC: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Pankaj Dubey <pankaj.dubey@samsung.com>
    Signed-off-by: Kukjin Kim <kgene@kernel.org>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 86f3ecd88f78..dfc8594e5b1f 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -23,12 +23,13 @@
 #include <asm/smp_scu.h>
 #include <asm/suspend.h>
 
+#include <mach/map.h>
+
 #include <plat/pm-common.h>
 
 #include "common.h"
 #include "exynos-pmu.h"
 #include "regs-pmu.h"
-#include "regs-sys.h"
 
 static inline void __iomem *exynos_boot_vector_addr(void)
 {

commit 6b7bfd8292ab27180662bcba175e7a3822486c2d
Author: Pankaj Dubey <pankaj.dubey@samsung.com>
Date:   Fri Nov 7 09:26:47 2014 +0900

    ARM: EXYNOS: Move PMU specific definitions from common.h
    
    This patch moves PMU specific definitions into a new file
    as exynos-pmu.h.
    This will help in reducing dependency of common.h in pmu.c.
    
    Signed-off-by: Pankaj Dubey <pankaj.dubey@samsung.com>
    Reviewed-by: Tomasz Figa <t.figa@samsung.com>
    Tested-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 4f10fa6bfe10..86f3ecd88f78 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -26,6 +26,7 @@
 #include <plat/pm-common.h>
 
 #include "common.h"
+#include "exynos-pmu.h"
 #include "regs-pmu.h"
 #include "regs-sys.h"
 

commit 0d713cf1a6286aae6a12affab0887dbe2a4fbb83
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Sep 25 18:02:45 2014 +0900

    ARM: EXYNOS: Fix build with PM_SLEEP=n and ARM_EXYNOS_CPUIDLE=y
    
    Fix building of exynos_defconfig with CONFIG_PM_SLEEP disabled and
    CONFIG_ARM_EXYNOS_CPUIDLE enabled by:
    
    * adding EXYNOS_CPU_SUSPEND config option
    * always building sleep.o
    * building pm.o if EXYNOS_CPU_SUSPEND is enabled
    * moving suspend specific code from pm.c to suspend.c
    * enabling pm-common.o build also for EXYNOS_CPU_SUSPEND option
    
    [ Please note that there are no changes in the code moved from pm.c
      to suspend.c except making few functions non-static and cleaning
      up includes. ]
    
    Also while at it update Copyright dates.
    
    The build error messages:
    drivers/built-in.o: In function `exynos_enter_core0_aftr':
    /home/bzolnier/linux/drivers/cpuidle/cpuidle-exynos.c:36: undefined reference to `cpu_suspend'
    arch/arm/mach-exynos/built-in.o:(.data+0x74): undefined reference to `exynos_enter_aftr'
    make: *** [vmlinux] Error 1
    
    This patch has been tested on Exynos4210 based Origen board.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 16c5c3206f14..4f10fa6bfe10 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011-2012 Samsung Electronics Co., Ltd.
+ * Copyright (c) 2011-2014 Samsung Electronics Co., Ltd.
  *		http://www.samsung.com
  *
  * EXYNOS - Power Management support
@@ -15,119 +15,20 @@
 
 #include <linux/init.h>
 #include <linux/suspend.h>
-#include <linux/syscore_ops.h>
 #include <linux/cpu_pm.h>
 #include <linux/io.h>
-#include <linux/irqchip/arm-gic.h>
 #include <linux/err.h>
-#include <linux/clk.h>
 
-#include <asm/cacheflush.h>
 #include <asm/firmware.h>
-#include <asm/hardware/cache-l2x0.h>
 #include <asm/smp_scu.h>
 #include <asm/suspend.h>
 
 #include <plat/pm-common.h>
-#include <plat/regs-srom.h>
-
-#include <mach/map.h>
 
 #include "common.h"
 #include "regs-pmu.h"
 #include "regs-sys.h"
 
-#define REG_TABLE_END (-1U)
-
-/**
- * struct exynos_wkup_irq - Exynos GIC to PMU IRQ mapping
- * @hwirq: Hardware IRQ signal of the GIC
- * @mask: Mask in PMU wake-up mask register
- */
-struct exynos_wkup_irq {
-	unsigned int hwirq;
-	u32 mask;
-};
-
-static struct sleep_save exynos5_sys_save[] = {
-	SAVE_ITEM(EXYNOS5_SYS_I2C_CFG),
-};
-
-static struct sleep_save exynos_core_save[] = {
-	/* SROM side */
-	SAVE_ITEM(S5P_SROM_BW),
-	SAVE_ITEM(S5P_SROM_BC0),
-	SAVE_ITEM(S5P_SROM_BC1),
-	SAVE_ITEM(S5P_SROM_BC2),
-	SAVE_ITEM(S5P_SROM_BC3),
-};
-
-struct exynos_pm_data {
-	const struct exynos_wkup_irq *wkup_irq;
-	struct sleep_save *extra_save;
-	int num_extra_save;
-	unsigned int wake_disable_mask;
-	unsigned int *release_ret_regs;
-
-	void (*pm_prepare)(void);
-	void (*pm_resume)(void);
-	int (*pm_suspend)(void);
-	int (*cpu_suspend)(unsigned long);
-};
-
-struct exynos_pm_data *pm_data;
-
-/*
- * GIC wake-up support
- */
-
-static u32 exynos_irqwake_intmask = 0xffffffff;
-
-static const struct exynos_wkup_irq exynos4_wkup_irq[] = {
-	{ 76, BIT(1) }, /* RTC alarm */
-	{ 77, BIT(2) }, /* RTC tick */
-	{ /* sentinel */ },
-};
-
-static const struct exynos_wkup_irq exynos5250_wkup_irq[] = {
-	{ 75, BIT(1) }, /* RTC alarm */
-	{ 76, BIT(2) }, /* RTC tick */
-	{ /* sentinel */ },
-};
-
-unsigned int exynos_release_ret_regs[] = {
-	S5P_PAD_RET_MAUDIO_OPTION,
-	S5P_PAD_RET_GPIO_OPTION,
-	S5P_PAD_RET_UART_OPTION,
-	S5P_PAD_RET_MMCA_OPTION,
-	S5P_PAD_RET_MMCB_OPTION,
-	S5P_PAD_RET_EBIA_OPTION,
-	S5P_PAD_RET_EBIB_OPTION,
-	REG_TABLE_END,
-};
-
-static int exynos_irq_set_wake(struct irq_data *data, unsigned int state)
-{
-	const struct exynos_wkup_irq *wkup_irq;
-
-	if (!pm_data->wkup_irq)
-		return -ENOENT;
-	wkup_irq = pm_data->wkup_irq;
-
-	while (wkup_irq->mask) {
-		if (wkup_irq->hwirq == data->hwirq) {
-			if (!state)
-				exynos_irqwake_intmask |= wkup_irq->mask;
-			else
-				exynos_irqwake_intmask &= ~wkup_irq->mask;
-			return 0;
-		}
-		++wkup_irq;
-	}
-
-	return -ENOENT;
-}
-
 static inline void __iomem *exynos_boot_vector_addr(void)
 {
 	if (samsung_rev() == EXYNOS4210_REV_1_1)
@@ -147,12 +48,11 @@ static inline void __iomem *exynos_boot_vector_flag(void)
 }
 
 #define S5P_CHECK_AFTR  0xFCBA0D10
-#define S5P_CHECK_SLEEP 0x00000BAD
 
 /* For Cortex-A9 Diagnostic and Power control register */
 static unsigned int save_arm_register[2];
 
-static void exynos_cpu_save_register(void)
+void exynos_cpu_save_register(void)
 {
 	unsigned long tmp;
 
@@ -169,7 +69,7 @@ static void exynos_cpu_save_register(void)
 	save_arm_register[1] = tmp;
 }
 
-static void exynos_cpu_restore_register(void)
+void exynos_cpu_restore_register(void)
 {
 	unsigned long tmp;
 
@@ -188,7 +88,7 @@ static void exynos_cpu_restore_register(void)
 		      : "cc");
 }
 
-static void exynos_pm_central_suspend(void)
+void exynos_pm_central_suspend(void)
 {
 	unsigned long tmp;
 
@@ -202,7 +102,7 @@ static void exynos_pm_central_suspend(void)
 		       S5P_CENTRAL_SEQ_OPTION);
 }
 
-static int exynos_pm_central_resume(void)
+int exynos_pm_central_resume(void)
 {
 	unsigned long tmp;
 
@@ -275,231 +175,3 @@ void exynos_enter_aftr(void)
 
 	cpu_pm_exit();
 }
-
-static int exynos_cpu_do_idle(void)
-{
-	/* issue the standby signal into the pm unit. */
-	cpu_do_idle();
-
-	pr_info("Failed to suspend the system\n");
-	return 1; /* Aborting suspend */
-}
-
-static int exynos_cpu_suspend(unsigned long arg)
-{
-	flush_cache_all();
-	outer_flush_all();
-	return exynos_cpu_do_idle();
-}
-
-static void exynos_pm_set_wakeup_mask(void)
-{
-	/* Set wake-up mask registers */
-	pmu_raw_writel(exynos_get_eint_wake_mask(), S5P_EINT_WAKEUP_MASK);
-	pmu_raw_writel(exynos_irqwake_intmask & ~(1 << 31), S5P_WAKEUP_MASK);
-}
-
-static void exynos_pm_enter_sleep_mode(void)
-{
-	/* Set value of power down register for sleep mode */
-	exynos_sys_powerdown_conf(SYS_SLEEP);
-	pmu_raw_writel(S5P_CHECK_SLEEP, S5P_INFORM1);
-
-	/* ensure at least INFORM0 has the resume address */
-	pmu_raw_writel(virt_to_phys(exynos_cpu_resume), S5P_INFORM0);
-}
-
-static void exynos_pm_prepare(void)
-{
-	/* Set wake-up mask registers */
-	exynos_pm_set_wakeup_mask();
-
-	s3c_pm_do_save(exynos_core_save, ARRAY_SIZE(exynos_core_save));
-
-	 if (pm_data->extra_save)
-		s3c_pm_do_save(pm_data->extra_save,
-				pm_data->num_extra_save);
-
-	exynos_pm_enter_sleep_mode();
-}
-
-static int exynos_pm_suspend(void)
-{
-	exynos_pm_central_suspend();
-
-	if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9)
-		exynos_cpu_save_register();
-
-	return 0;
-}
-
-static void exynos_pm_release_retention(void)
-{
-	unsigned int i;
-
-	for (i = 0; (pm_data->release_ret_regs[i] != REG_TABLE_END); i++)
-		pmu_raw_writel(EXYNOS_WAKEUP_FROM_LOWPWR,
-				pm_data->release_ret_regs[i]);
-}
-
-static void exynos_pm_resume(void)
-{
-	u32 cpuid = read_cpuid_part();
-
-	if (exynos_pm_central_resume())
-		goto early_wakeup;
-
-	/* For release retention */
-	exynos_pm_release_retention();
-
-	if (pm_data->extra_save)
-		s3c_pm_do_restore_core(pm_data->extra_save,
-					pm_data->num_extra_save);
-
-	s3c_pm_do_restore_core(exynos_core_save, ARRAY_SIZE(exynos_core_save));
-
-	if (cpuid == ARM_CPU_PART_CORTEX_A9)
-		scu_enable(S5P_VA_SCU);
-
-	if (call_firmware_op(resume) == -ENOSYS
-	    && cpuid == ARM_CPU_PART_CORTEX_A9)
-		exynos_cpu_restore_register();
-
-early_wakeup:
-
-	/* Clear SLEEP mode set in INFORM1 */
-	pmu_raw_writel(0x0, S5P_INFORM1);
-}
-
-/*
- * Suspend Ops
- */
-
-static int exynos_suspend_enter(suspend_state_t state)
-{
-	int ret;
-
-	s3c_pm_debug_init();
-
-	S3C_PMDBG("%s: suspending the system...\n", __func__);
-
-	S3C_PMDBG("%s: wakeup masks: %08x,%08x\n", __func__,
-			exynos_irqwake_intmask, exynos_get_eint_wake_mask());
-
-	if (exynos_irqwake_intmask == -1U
-	    && exynos_get_eint_wake_mask() == -1U) {
-		pr_err("%s: No wake-up sources!\n", __func__);
-		pr_err("%s: Aborting sleep\n", __func__);
-		return -EINVAL;
-	}
-
-	s3c_pm_save_uarts();
-	if (pm_data->pm_prepare)
-		pm_data->pm_prepare();
-	flush_cache_all();
-	s3c_pm_check_store();
-
-	ret = call_firmware_op(suspend);
-	if (ret == -ENOSYS)
-		ret = cpu_suspend(0, pm_data->cpu_suspend);
-	if (ret)
-		return ret;
-
-	s3c_pm_restore_uarts();
-
-	S3C_PMDBG("%s: wakeup stat: %08x\n", __func__,
-			pmu_raw_readl(S5P_WAKEUP_STAT));
-
-	s3c_pm_check_restore();
-
-	S3C_PMDBG("%s: resuming the system...\n", __func__);
-
-	return 0;
-}
-
-static int exynos_suspend_prepare(void)
-{
-	s3c_pm_check_prepare();
-
-	return 0;
-}
-
-static void exynos_suspend_finish(void)
-{
-	s3c_pm_check_cleanup();
-}
-
-static const struct platform_suspend_ops exynos_suspend_ops = {
-	.enter		= exynos_suspend_enter,
-	.prepare	= exynos_suspend_prepare,
-	.finish		= exynos_suspend_finish,
-	.valid		= suspend_valid_only_mem,
-};
-
-static const struct exynos_pm_data exynos4_pm_data = {
-	.wkup_irq	= exynos4_wkup_irq,
-	.wake_disable_mask = ((0xFF << 8) | (0x1F << 1)),
-	.release_ret_regs = exynos_release_ret_regs,
-	.pm_suspend	= exynos_pm_suspend,
-	.pm_resume	= exynos_pm_resume,
-	.pm_prepare	= exynos_pm_prepare,
-	.cpu_suspend	= exynos_cpu_suspend,
-};
-
-static const struct exynos_pm_data exynos5250_pm_data = {
-	.wkup_irq	= exynos5250_wkup_irq,
-	.wake_disable_mask = ((0xFF << 8) | (0x1F << 1)),
-	.release_ret_regs = exynos_release_ret_regs,
-	.extra_save	= exynos5_sys_save,
-	.num_extra_save	= ARRAY_SIZE(exynos5_sys_save),
-	.pm_suspend	= exynos_pm_suspend,
-	.pm_resume	= exynos_pm_resume,
-	.pm_prepare	= exynos_pm_prepare,
-	.cpu_suspend	= exynos_cpu_suspend,
-};
-
-static struct of_device_id exynos_pmu_of_device_ids[] = {
-	{
-		.compatible = "samsung,exynos4210-pmu",
-		.data = &exynos4_pm_data,
-	}, {
-		.compatible = "samsung,exynos4212-pmu",
-		.data = &exynos4_pm_data,
-	}, {
-		.compatible = "samsung,exynos4412-pmu",
-		.data = &exynos4_pm_data,
-	}, {
-		.compatible = "samsung,exynos5250-pmu",
-		.data = &exynos5250_pm_data,
-	},
-	{ /*sentinel*/ },
-};
-
-static struct syscore_ops exynos_pm_syscore_ops;
-
-void __init exynos_pm_init(void)
-{
-	const struct of_device_id *match;
-	u32 tmp;
-
-	of_find_matching_node_and_match(NULL, exynos_pmu_of_device_ids, &match);
-	if (!match) {
-		pr_err("Failed to find PMU node\n");
-		return;
-	}
-	pm_data = (struct exynos_pm_data *) match->data;
-
-	/* Platform-specific GIC callback */
-	gic_arch_extn.irq_set_wake = exynos_irq_set_wake;
-
-	/* All wakeup disable */
-	tmp = pmu_raw_readl(S5P_WAKEUP_MASK);
-	tmp |= pm_data->wake_disable_mask;
-	pmu_raw_writel(tmp, S5P_WAKEUP_MASK);
-
-	exynos_pm_syscore_ops.suspend	= pm_data->pm_suspend;
-	exynos_pm_syscore_ops.resume	= pm_data->pm_resume;
-
-	register_syscore_ops(&exynos_pm_syscore_ops);
-	suspend_set_ops(&exynos_suspend_ops);
-}

commit c2dd114d24865662a6d7381b101741fc898a0059
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Sep 25 17:59:41 2014 +0900

    ARM: EXYNOS: fix register setup for AFTR mode code
    
    Add S5P_CENTRAL_SEQ_OPTION register setup to cpuidle AFTR mode code
    by moving the relevant code from exynos_pm_suspend() (used only by
    suspend) to exynos_pm_central_suspend() (used by both suspend and
    AFTR).  Without this setup AFTR mode doesn't show any benefit over
    WFI one (at least on Exynos4412 SoC).  When this setup is applied
    AFTR mode reduces power consumption by ~12% (as measured on Trats2
    board).
    
    This change is a preparation for adding secure firmware support to
    EXYNOS cpuidle driver.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 6796fce923e2..16c5c3206f14 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -196,6 +196,10 @@ static void exynos_pm_central_suspend(void)
 	tmp = pmu_raw_readl(S5P_CENTRAL_SEQ_CONFIGURATION);
 	tmp &= ~S5P_CENTRAL_LOWPWR_CFG;
 	pmu_raw_writel(tmp, S5P_CENTRAL_SEQ_CONFIGURATION);
+
+	/* Setting SEQ_OPTION register */
+	pmu_raw_writel(S5P_USE_STANDBY_WFI0 | S5P_USE_STANDBY_WFE0,
+		       S5P_CENTRAL_SEQ_OPTION);
 }
 
 static int exynos_pm_central_resume(void)
@@ -321,15 +325,8 @@ static void exynos_pm_prepare(void)
 
 static int exynos_pm_suspend(void)
 {
-	unsigned long tmp;
-
 	exynos_pm_central_suspend();
 
-	/* Setting SEQ_OPTION register */
-
-	tmp = (S5P_USE_STANDBY_WFI0 | S5P_USE_STANDBY_WFE0);
-	pmu_raw_writel(tmp, S5P_CENTRAL_SEQ_OPTION);
-
 	if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9)
 		exynos_cpu_save_register();
 

commit a135e20185fe6f0258fa6837455043f3063601d8
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Sep 25 17:59:41 2014 +0900

    ARM: EXYNOS: add secure firmware support to AFTR mode code
    
    * Move cp15 registers saving to exynos_save_cp15() helper and add
      additional helper usage to do_idle firmware method.
    
    * Use resume firmware method instead of exynos_cpu_restore_register()
      and skip exynos_cpu_save_register() on boards with secure firmware
      enabled.
    
    * Use sysram_ns_base_addr + 0x24/0x20 addresses instead of the default
      ones used by exynos_cpu_set_boot_vector() on boards with secure
      firmware enabled.
    
    * Use do_idle firmware method instead of cpu_do_idle() on boards with
      secure firmware enabled.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 3407fc162449..6796fce923e2 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -236,11 +236,19 @@ static void exynos_cpu_set_boot_vector(long flags)
 
 static int exynos_aftr_finisher(unsigned long flags)
 {
+	int ret;
+
 	exynos_set_wakeupmask(0x0000ff3e);
-	exynos_cpu_set_boot_vector(S5P_CHECK_AFTR);
 	/* Set value of power down register for aftr mode */
 	exynos_sys_powerdown_conf(SYS_AFTR);
-	cpu_do_idle();
+
+	ret = call_firmware_op(do_idle, FW_DO_IDLE_AFTR);
+	if (ret == -ENOSYS) {
+		if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9)
+			exynos_cpu_save_register();
+		exynos_cpu_set_boot_vector(S5P_CHECK_AFTR);
+		cpu_do_idle();
+	}
 
 	return 1;
 }
@@ -250,14 +258,13 @@ void exynos_enter_aftr(void)
 	cpu_pm_enter();
 
 	exynos_pm_central_suspend();
-	if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9)
-		exynos_cpu_save_register();
 
 	cpu_suspend(0, exynos_aftr_finisher);
 
 	if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9) {
 		scu_enable(S5P_VA_SCU);
-		exynos_cpu_restore_register();
+		if (call_firmware_op(resume) == -ENOSYS)
+			exynos_cpu_restore_register();
 	}
 
 	exynos_pm_central_resume();

commit 134abc297e43438cdb47f30fc673680b16bc6339
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Sep 25 17:59:40 2014 +0900

    ARM: EXYNOS: replace EXYNOS_BOOT_VECTOR_* macros by static inlines
    
    Replace EXYNOS_BOOT_VECTOR_ADDR and EXYNOS_BOOT_VECTOR_FLAG macros
    by exynos_boot_vector_addr() and exynos_boot_vector_flag() static
    inlines.
    
    This patch shouldn't cause any functionality changes.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 047ac302835d..3407fc162449 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -128,16 +128,23 @@ static int exynos_irq_set_wake(struct irq_data *data, unsigned int state)
 	return -ENOENT;
 }
 
-#define EXYNOS_BOOT_VECTOR_ADDR	(samsung_rev() == EXYNOS4210_REV_1_1 ? \
-			pmu_base_addr + S5P_INFORM7 : \
-			(samsung_rev() == EXYNOS4210_REV_1_0 ? \
-			(sysram_base_addr + 0x24) : \
-			pmu_base_addr + S5P_INFORM0))
-#define EXYNOS_BOOT_VECTOR_FLAG	(samsung_rev() == EXYNOS4210_REV_1_1 ? \
-			pmu_base_addr + S5P_INFORM6 : \
-			(samsung_rev() == EXYNOS4210_REV_1_0 ? \
-			(sysram_base_addr + 0x20) : \
-			pmu_base_addr + S5P_INFORM1))
+static inline void __iomem *exynos_boot_vector_addr(void)
+{
+	if (samsung_rev() == EXYNOS4210_REV_1_1)
+		return pmu_base_addr + S5P_INFORM7;
+	else if (samsung_rev() == EXYNOS4210_REV_1_0)
+		return sysram_base_addr + 0x24;
+	return pmu_base_addr + S5P_INFORM0;
+}
+
+static inline void __iomem *exynos_boot_vector_flag(void)
+{
+	if (samsung_rev() == EXYNOS4210_REV_1_1)
+		return pmu_base_addr + S5P_INFORM6;
+	else if (samsung_rev() == EXYNOS4210_REV_1_0)
+		return sysram_base_addr + 0x20;
+	return pmu_base_addr + S5P_INFORM1;
+}
 
 #define S5P_CHECK_AFTR  0xFCBA0D10
 #define S5P_CHECK_SLEEP 0x00000BAD
@@ -222,8 +229,9 @@ static void exynos_set_wakeupmask(long mask)
 
 static void exynos_cpu_set_boot_vector(long flags)
 {
-	__raw_writel(virt_to_phys(exynos_cpu_resume), EXYNOS_BOOT_VECTOR_ADDR);
-	__raw_writel(flags, EXYNOS_BOOT_VECTOR_FLAG);
+	__raw_writel(virt_to_phys(exynos_cpu_resume),
+		     exynos_boot_vector_addr());
+	__raw_writel(flags, exynos_boot_vector_flag());
 }
 
 static int exynos_aftr_finisher(unsigned long flags)

commit 2b9d9c321b5900c7ce82110a81cf3827ca9b33c6
Author: Tomasz Figa <t.figa@samsung.com>
Date:   Wed Sep 24 01:24:39 2014 +0900

    ARM: EXYNOS: Add support for firmware-assisted suspend/resume
    
    On a numer of Exynos-based boards Linux kernel is running in non-secure
    mode under a secure firmware. This means that certain operations need to
    be handled in special way, with firmware assistance. System-wide
    suspend/resume is an example of such operations.
    
    This patch adds support for firmware-assisted suspend/resume by
    leveraging recently introduced suspend and resume firmware operations
    and modifying existing suspend/resume paths to account for presence of
    secure firmware.
    
    Signed-off-by: Tomasz Figa <t.figa@samsung.com>
    [kgene.kim@samsung.com: rebased]
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 16b23d156eec..047ac302835d 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -23,6 +23,7 @@
 #include <linux/clk.h>
 
 #include <asm/cacheflush.h>
+#include <asm/firmware.h>
 #include <asm/hardware/cache-l2x0.h>
 #include <asm/smp_scu.h>
 #include <asm/suspend.h>
@@ -331,12 +332,11 @@ static void exynos_pm_release_retention(void)
 
 static void exynos_pm_resume(void)
 {
+	u32 cpuid = read_cpuid_part();
+
 	if (exynos_pm_central_resume())
 		goto early_wakeup;
 
-	if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9)
-		exynos_cpu_restore_register();
-
 	/* For release retention */
 	exynos_pm_release_retention();
 
@@ -346,9 +346,13 @@ static void exynos_pm_resume(void)
 
 	s3c_pm_do_restore_core(exynos_core_save, ARRAY_SIZE(exynos_core_save));
 
-	if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9)
+	if (cpuid == ARM_CPU_PART_CORTEX_A9)
 		scu_enable(S5P_VA_SCU);
 
+	if (call_firmware_op(resume) == -ENOSYS
+	    && cpuid == ARM_CPU_PART_CORTEX_A9)
+		exynos_cpu_restore_register();
+
 early_wakeup:
 
 	/* Clear SLEEP mode set in INFORM1 */
@@ -383,7 +387,9 @@ static int exynos_suspend_enter(suspend_state_t state)
 	flush_cache_all();
 	s3c_pm_check_store();
 
-	ret = cpu_suspend(0, pm_data->cpu_suspend);
+	ret = call_firmware_op(suspend);
+	if (ret == -ENOSYS)
+		ret = cpu_suspend(0, pm_data->cpu_suspend);
 	if (ret)
 		return ret;
 

commit 066da1ae52c30ae7e2792dbbb0d6bcbba493245e
Author: Vikas Sajjan <vikas.sajjan@samsung.com>
Date:   Wed Sep 24 16:45:14 2014 +0900

    ARM: EXYNOS: Refactor the pm code to use DT based lookup
    
    Refactoring the pm.c to avoid using "soc_is_exynos" checks,
    instead use the DT based lookup.
    
    While at it, consolidate the common code across SoCs
    and create static helper functions.
    
    Signed-off-by: Vikas Sajjan <vikas.sajjan@samsung.com>
    Reviewed-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 31e209b38f41..16b23d156eec 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -36,6 +36,8 @@
 #include "regs-pmu.h"
 #include "regs-sys.h"
 
+#define REG_TABLE_END (-1U)
+
 /**
  * struct exynos_wkup_irq - Exynos GIC to PMU IRQ mapping
  * @hwirq: Hardware IRQ signal of the GIC
@@ -59,6 +61,21 @@ static struct sleep_save exynos_core_save[] = {
 	SAVE_ITEM(S5P_SROM_BC3),
 };
 
+struct exynos_pm_data {
+	const struct exynos_wkup_irq *wkup_irq;
+	struct sleep_save *extra_save;
+	int num_extra_save;
+	unsigned int wake_disable_mask;
+	unsigned int *release_ret_regs;
+
+	void (*pm_prepare)(void);
+	void (*pm_resume)(void);
+	int (*pm_suspend)(void);
+	int (*cpu_suspend)(unsigned long);
+};
+
+struct exynos_pm_data *pm_data;
+
 /*
  * GIC wake-up support
  */
@@ -77,14 +94,24 @@ static const struct exynos_wkup_irq exynos5250_wkup_irq[] = {
 	{ /* sentinel */ },
 };
 
+unsigned int exynos_release_ret_regs[] = {
+	S5P_PAD_RET_MAUDIO_OPTION,
+	S5P_PAD_RET_GPIO_OPTION,
+	S5P_PAD_RET_UART_OPTION,
+	S5P_PAD_RET_MMCA_OPTION,
+	S5P_PAD_RET_MMCB_OPTION,
+	S5P_PAD_RET_EBIA_OPTION,
+	S5P_PAD_RET_EBIB_OPTION,
+	REG_TABLE_END,
+};
+
 static int exynos_irq_set_wake(struct irq_data *data, unsigned int state)
 {
 	const struct exynos_wkup_irq *wkup_irq;
 
-	if (soc_is_exynos5250())
-		wkup_irq = exynos5250_wkup_irq;
-	else
-		wkup_irq = exynos4_wkup_irq;
+	if (!pm_data->wkup_irq)
+		return -ENOENT;
+	wkup_irq = pm_data->wkup_irq;
 
 	while (wkup_irq->mask) {
 		if (wkup_irq->hwirq == data->hwirq) {
@@ -229,15 +256,8 @@ void exynos_enter_aftr(void)
 	cpu_pm_exit();
 }
 
-static int exynos_cpu_suspend(unsigned long arg)
+static int exynos_cpu_do_idle(void)
 {
-#ifdef CONFIG_CACHE_L2X0
-	outer_flush_all();
-#endif
-
-	if (soc_is_exynos5250())
-		flush_cache_all();
-
 	/* issue the standby signal into the pm unit. */
 	cpu_do_idle();
 
@@ -245,29 +265,44 @@ static int exynos_cpu_suspend(unsigned long arg)
 	return 1; /* Aborting suspend */
 }
 
-static void exynos_pm_prepare(void)
+static int exynos_cpu_suspend(unsigned long arg)
 {
-	unsigned int tmp;
+	flush_cache_all();
+	outer_flush_all();
+	return exynos_cpu_do_idle();
+}
 
+static void exynos_pm_set_wakeup_mask(void)
+{
 	/* Set wake-up mask registers */
 	pmu_raw_writel(exynos_get_eint_wake_mask(), S5P_EINT_WAKEUP_MASK);
 	pmu_raw_writel(exynos_irqwake_intmask & ~(1 << 31), S5P_WAKEUP_MASK);
+}
 
-	s3c_pm_do_save(exynos_core_save, ARRAY_SIZE(exynos_core_save));
-
-	if (soc_is_exynos5250())
-		s3c_pm_do_save(exynos5_sys_save, ARRAY_SIZE(exynos5_sys_save));
-
+static void exynos_pm_enter_sleep_mode(void)
+{
 	/* Set value of power down register for sleep mode */
-
 	exynos_sys_powerdown_conf(SYS_SLEEP);
 	pmu_raw_writel(S5P_CHECK_SLEEP, S5P_INFORM1);
 
 	/* ensure at least INFORM0 has the resume address */
-
 	pmu_raw_writel(virt_to_phys(exynos_cpu_resume), S5P_INFORM0);
 }
 
+static void exynos_pm_prepare(void)
+{
+	/* Set wake-up mask registers */
+	exynos_pm_set_wakeup_mask();
+
+	s3c_pm_do_save(exynos_core_save, ARRAY_SIZE(exynos_core_save));
+
+	 if (pm_data->extra_save)
+		s3c_pm_do_save(pm_data->extra_save,
+				pm_data->num_extra_save);
+
+	exynos_pm_enter_sleep_mode();
+}
+
 static int exynos_pm_suspend(void)
 {
 	unsigned long tmp;
@@ -285,6 +320,15 @@ static int exynos_pm_suspend(void)
 	return 0;
 }
 
+static void exynos_pm_release_retention(void)
+{
+	unsigned int i;
+
+	for (i = 0; (pm_data->release_ret_regs[i] != REG_TABLE_END); i++)
+		pmu_raw_writel(EXYNOS_WAKEUP_FROM_LOWPWR,
+				pm_data->release_ret_regs[i]);
+}
+
 static void exynos_pm_resume(void)
 {
 	if (exynos_pm_central_resume())
@@ -294,18 +338,11 @@ static void exynos_pm_resume(void)
 		exynos_cpu_restore_register();
 
 	/* For release retention */
+	exynos_pm_release_retention();
 
-	pmu_raw_writel((1 << 28), S5P_PAD_RET_MAUDIO_OPTION);
-	pmu_raw_writel((1 << 28), S5P_PAD_RET_GPIO_OPTION);
-	pmu_raw_writel((1 << 28), S5P_PAD_RET_UART_OPTION);
-	pmu_raw_writel((1 << 28), S5P_PAD_RET_MMCA_OPTION);
-	pmu_raw_writel((1 << 28), S5P_PAD_RET_MMCB_OPTION);
-	pmu_raw_writel((1 << 28), S5P_PAD_RET_EBIA_OPTION);
-	pmu_raw_writel((1 << 28), S5P_PAD_RET_EBIB_OPTION);
-
-	if (soc_is_exynos5250())
-		s3c_pm_do_restore(exynos5_sys_save,
-			ARRAY_SIZE(exynos5_sys_save));
+	if (pm_data->extra_save)
+		s3c_pm_do_restore_core(pm_data->extra_save,
+					pm_data->num_extra_save);
 
 	s3c_pm_do_restore_core(exynos_core_save, ARRAY_SIZE(exynos_core_save));
 
@@ -316,15 +353,8 @@ static void exynos_pm_resume(void)
 
 	/* Clear SLEEP mode set in INFORM1 */
 	pmu_raw_writel(0x0, S5P_INFORM1);
-
-	return;
 }
 
-static struct syscore_ops exynos_pm_syscore_ops = {
-	.suspend	= exynos_pm_suspend,
-	.resume		= exynos_pm_resume,
-};
-
 /*
  * Suspend Ops
  */
@@ -348,11 +378,12 @@ static int exynos_suspend_enter(suspend_state_t state)
 	}
 
 	s3c_pm_save_uarts();
-	exynos_pm_prepare();
+	if (pm_data->pm_prepare)
+		pm_data->pm_prepare();
 	flush_cache_all();
 	s3c_pm_check_store();
 
-	ret = cpu_suspend(0, exynos_cpu_suspend);
+	ret = cpu_suspend(0, pm_data->cpu_suspend);
 	if (ret)
 		return ret;
 
@@ -387,18 +418,70 @@ static const struct platform_suspend_ops exynos_suspend_ops = {
 	.valid		= suspend_valid_only_mem,
 };
 
+static const struct exynos_pm_data exynos4_pm_data = {
+	.wkup_irq	= exynos4_wkup_irq,
+	.wake_disable_mask = ((0xFF << 8) | (0x1F << 1)),
+	.release_ret_regs = exynos_release_ret_regs,
+	.pm_suspend	= exynos_pm_suspend,
+	.pm_resume	= exynos_pm_resume,
+	.pm_prepare	= exynos_pm_prepare,
+	.cpu_suspend	= exynos_cpu_suspend,
+};
+
+static const struct exynos_pm_data exynos5250_pm_data = {
+	.wkup_irq	= exynos5250_wkup_irq,
+	.wake_disable_mask = ((0xFF << 8) | (0x1F << 1)),
+	.release_ret_regs = exynos_release_ret_regs,
+	.extra_save	= exynos5_sys_save,
+	.num_extra_save	= ARRAY_SIZE(exynos5_sys_save),
+	.pm_suspend	= exynos_pm_suspend,
+	.pm_resume	= exynos_pm_resume,
+	.pm_prepare	= exynos_pm_prepare,
+	.cpu_suspend	= exynos_cpu_suspend,
+};
+
+static struct of_device_id exynos_pmu_of_device_ids[] = {
+	{
+		.compatible = "samsung,exynos4210-pmu",
+		.data = &exynos4_pm_data,
+	}, {
+		.compatible = "samsung,exynos4212-pmu",
+		.data = &exynos4_pm_data,
+	}, {
+		.compatible = "samsung,exynos4412-pmu",
+		.data = &exynos4_pm_data,
+	}, {
+		.compatible = "samsung,exynos5250-pmu",
+		.data = &exynos5250_pm_data,
+	},
+	{ /*sentinel*/ },
+};
+
+static struct syscore_ops exynos_pm_syscore_ops;
+
 void __init exynos_pm_init(void)
 {
+	const struct of_device_id *match;
 	u32 tmp;
 
+	of_find_matching_node_and_match(NULL, exynos_pmu_of_device_ids, &match);
+	if (!match) {
+		pr_err("Failed to find PMU node\n");
+		return;
+	}
+	pm_data = (struct exynos_pm_data *) match->data;
+
 	/* Platform-specific GIC callback */
 	gic_arch_extn.irq_set_wake = exynos_irq_set_wake;
 
 	/* All wakeup disable */
 	tmp = pmu_raw_readl(S5P_WAKEUP_MASK);
-	tmp |= ((0xFF << 8) | (0x1F << 1));
+	tmp |= pm_data->wake_disable_mask;
 	pmu_raw_writel(tmp, S5P_WAKEUP_MASK);
 
+	exynos_pm_syscore_ops.suspend	= pm_data->pm_suspend;
+	exynos_pm_syscore_ops.resume	= pm_data->pm_resume;
+
 	register_syscore_ops(&exynos_pm_syscore_ops);
 	suspend_set_ops(&exynos_suspend_ops);
 }

commit 32ed35ff22ec03d8a935dfe8b90c599da4b4cb02
Author: Vikas Sajjan <vikas.sajjan@samsung.com>
Date:   Wed Sep 24 16:45:13 2014 +0900

    ARM: EXYNOS: Move Disabling of JPEG USE_RETENTION for exynos5250 to pmu.c
    
    Move the Disabling of JPEG USE_RETENTION for exynos5250 to pmu.c to
    make way for refactoring of pm.c and to create common functions across
    exynos4 and exynos5250.
    
    Signed-off-by: Vikas Sajjan <vikas.sajjan@samsung.com>
    Reviewed-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index abefacb45976..31e209b38f41 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -255,13 +255,8 @@ static void exynos_pm_prepare(void)
 
 	s3c_pm_do_save(exynos_core_save, ARRAY_SIZE(exynos_core_save));
 
-	if (soc_is_exynos5250()) {
+	if (soc_is_exynos5250())
 		s3c_pm_do_save(exynos5_sys_save, ARRAY_SIZE(exynos5_sys_save));
-		/* Disable USE_RETENTION of JPEG_MEM_OPTION */
-		tmp = pmu_raw_readl(EXYNOS5_JPEG_MEM_OPTION);
-		tmp &= ~EXYNOS5_OPTION_USE_RETENTION;
-		pmu_raw_writel(tmp, EXYNOS5_JPEG_MEM_OPTION);
-	}
 
 	/* Set value of power down register for sleep mode */
 

commit 01601b349582caa617618b5fa7d9b08bd328626a
Author: Tomasz Figa <t.figa@samsung.com>
Date:   Tue Aug 5 14:43:10 2014 +0200

    ARM: EXYNOS: Fix suspend/resume sequences
    
    Due to recent consolidation of Exynos suspend and cpuidle code, some
    parts of suspend and resume sequences are executed two times, once from
    exynos_pm_syscore_ops and then from exynos_cpu_pm_notifier() and thus it
    breaks suspend, at least on Exynos4-based boards. In addition, simple
    core power down from a cpuidle driver could, in case of CPU 0 could
    result in calling functions that are specific to suspend and deeper idle
    states.
    
    This patch fixes the issue by moving those operations outside the CPU PM
    notifier into suspend and AFTR code paths. This leads to a bit of code
    duplication, but allows additional code simplification, so in the end
    more code is removed than added.
    
    Fixes: 85f9f90808b4 ("ARM: EXYNOS: Use the cpu_pm notifier for pm")
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: arm@kernel.org
    Signed-off-by: Tomasz Figa <t.figa@samsung.com>
    [b.zolnierkie: ported patch over current changes]
    [b.zolnierkie: fixed exynos_aftr_finisher() return value]
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 18646b7e226b..abefacb45976 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -114,26 +114,6 @@ static int exynos_irq_set_wake(struct irq_data *data, unsigned int state)
 #define S5P_CHECK_AFTR  0xFCBA0D10
 #define S5P_CHECK_SLEEP 0x00000BAD
 
-/* Ext-GIC nIRQ/nFIQ is the only wakeup source in AFTR */
-static void exynos_set_wakeupmask(long mask)
-{
-	pmu_raw_writel(mask, S5P_WAKEUP_MASK);
-}
-
-static void exynos_cpu_set_boot_vector(long flags)
-{
-	__raw_writel(virt_to_phys(exynos_cpu_resume), EXYNOS_BOOT_VECTOR_ADDR);
-	__raw_writel(flags, EXYNOS_BOOT_VECTOR_FLAG);
-}
-
-void exynos_enter_aftr(void)
-{
-	exynos_set_wakeupmask(0x0000ff3e);
-	exynos_cpu_set_boot_vector(S5P_CHECK_AFTR);
-	/* Set value of power down register for aftr mode */
-	exynos_sys_powerdown_conf(SYS_AFTR);
-}
-
 /* For Cortex-A9 Diagnostic and Power control register */
 static unsigned int save_arm_register[2];
 
@@ -173,6 +153,82 @@ static void exynos_cpu_restore_register(void)
 		      : "cc");
 }
 
+static void exynos_pm_central_suspend(void)
+{
+	unsigned long tmp;
+
+	/* Setting Central Sequence Register for power down mode */
+	tmp = pmu_raw_readl(S5P_CENTRAL_SEQ_CONFIGURATION);
+	tmp &= ~S5P_CENTRAL_LOWPWR_CFG;
+	pmu_raw_writel(tmp, S5P_CENTRAL_SEQ_CONFIGURATION);
+}
+
+static int exynos_pm_central_resume(void)
+{
+	unsigned long tmp;
+
+	/*
+	 * If PMU failed while entering sleep mode, WFI will be
+	 * ignored by PMU and then exiting cpu_do_idle().
+	 * S5P_CENTRAL_LOWPWR_CFG bit will not be set automatically
+	 * in this situation.
+	 */
+	tmp = pmu_raw_readl(S5P_CENTRAL_SEQ_CONFIGURATION);
+	if (!(tmp & S5P_CENTRAL_LOWPWR_CFG)) {
+		tmp |= S5P_CENTRAL_LOWPWR_CFG;
+		pmu_raw_writel(tmp, S5P_CENTRAL_SEQ_CONFIGURATION);
+		/* clear the wakeup state register */
+		pmu_raw_writel(0x0, S5P_WAKEUP_STAT);
+		/* No need to perform below restore code */
+		return -1;
+	}
+
+	return 0;
+}
+
+/* Ext-GIC nIRQ/nFIQ is the only wakeup source in AFTR */
+static void exynos_set_wakeupmask(long mask)
+{
+	pmu_raw_writel(mask, S5P_WAKEUP_MASK);
+}
+
+static void exynos_cpu_set_boot_vector(long flags)
+{
+	__raw_writel(virt_to_phys(exynos_cpu_resume), EXYNOS_BOOT_VECTOR_ADDR);
+	__raw_writel(flags, EXYNOS_BOOT_VECTOR_FLAG);
+}
+
+static int exynos_aftr_finisher(unsigned long flags)
+{
+	exynos_set_wakeupmask(0x0000ff3e);
+	exynos_cpu_set_boot_vector(S5P_CHECK_AFTR);
+	/* Set value of power down register for aftr mode */
+	exynos_sys_powerdown_conf(SYS_AFTR);
+	cpu_do_idle();
+
+	return 1;
+}
+
+void exynos_enter_aftr(void)
+{
+	cpu_pm_enter();
+
+	exynos_pm_central_suspend();
+	if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9)
+		exynos_cpu_save_register();
+
+	cpu_suspend(0, exynos_aftr_finisher);
+
+	if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9) {
+		scu_enable(S5P_VA_SCU);
+		exynos_cpu_restore_register();
+	}
+
+	exynos_pm_central_resume();
+
+	cpu_pm_exit();
+}
+
 static int exynos_cpu_suspend(unsigned long arg)
 {
 #ifdef CONFIG_CACHE_L2X0
@@ -217,16 +273,6 @@ static void exynos_pm_prepare(void)
 	pmu_raw_writel(virt_to_phys(exynos_cpu_resume), S5P_INFORM0);
 }
 
-static void exynos_pm_central_suspend(void)
-{
-	unsigned long tmp;
-
-	/* Setting Central Sequence Register for power down mode */
-	tmp = pmu_raw_readl(S5P_CENTRAL_SEQ_CONFIGURATION);
-	tmp &= ~S5P_CENTRAL_LOWPWR_CFG;
-	pmu_raw_writel(tmp, S5P_CENTRAL_SEQ_CONFIGURATION);
-}
-
 static int exynos_pm_suspend(void)
 {
 	unsigned long tmp;
@@ -244,29 +290,6 @@ static int exynos_pm_suspend(void)
 	return 0;
 }
 
-static int exynos_pm_central_resume(void)
-{
-	unsigned long tmp;
-
-	/*
-	 * If PMU failed while entering sleep mode, WFI will be
-	 * ignored by PMU and then exiting cpu_do_idle().
-	 * S5P_CENTRAL_LOWPWR_CFG bit will not be set automatically
-	 * in this situation.
-	 */
-	tmp = pmu_raw_readl(S5P_CENTRAL_SEQ_CONFIGURATION);
-	if (!(tmp & S5P_CENTRAL_LOWPWR_CFG)) {
-		tmp |= S5P_CENTRAL_LOWPWR_CFG;
-		pmu_raw_writel(tmp, S5P_CENTRAL_SEQ_CONFIGURATION);
-		/* clear the wakeup state register */
-		pmu_raw_writel(0x0, S5P_WAKEUP_STAT);
-		/* No need to perform below restore code */
-		return -1;
-	}
-
-	return 0;
-}
-
 static void exynos_pm_resume(void)
 {
 	if (exynos_pm_central_resume())
@@ -369,44 +392,10 @@ static const struct platform_suspend_ops exynos_suspend_ops = {
 	.valid		= suspend_valid_only_mem,
 };
 
-static int exynos_cpu_pm_notifier(struct notifier_block *self,
-				  unsigned long cmd, void *v)
-{
-	int cpu = smp_processor_id();
-
-	switch (cmd) {
-	case CPU_PM_ENTER:
-		if (cpu == 0) {
-			exynos_pm_central_suspend();
-			if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9)
-				exynos_cpu_save_register();
-		}
-		break;
-
-	case CPU_PM_EXIT:
-		if (cpu == 0) {
-			if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9) {
-				scu_enable(S5P_VA_SCU);
-				exynos_cpu_restore_register();
-			}
-			exynos_pm_central_resume();
-		}
-		break;
-	}
-
-	return NOTIFY_OK;
-}
-
-static struct notifier_block exynos_cpu_pm_notifier_block = {
-	.notifier_call = exynos_cpu_pm_notifier,
-};
-
 void __init exynos_pm_init(void)
 {
 	u32 tmp;
 
-	cpu_pm_register_notifier(&exynos_cpu_pm_notifier_block);
-
 	/* Platform-specific GIC callback */
 	gic_arch_extn.irq_set_wake = exynos_irq_set_wake;
 

commit b3345d7c57d70e6cb6749af25cdbe80515582e99
Merge: 44c916d58b9e c2fff85e2181
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Aug 8 11:14:29 2014 -0700

    Merge tag 'soc-for-3.17' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform changes from Olof Johansson:
     "This is the bulk of new SoC enablement and other platform changes for
      3.17:
    
       - Samsung S5PV210 has been converted to DT and multiplatform
       - Clock drivers and bindings for some of the lower-end i.MX 1/2
         platforms
       - Kirkwood, one of the popular Marvell platforms, is folded into the
         mvebu platform code, removing mach-kirkwood
       - Hwmod data for TI AM43xx and DRA7 platforms
       - More additions of Renesas shmobile platform support
       - Removal of plat-samsung contents that can be removed with S5PV210
         being multiplatform/DT-enabled and the other two old platforms
         being removed
    
      New platforms (most with only basic support right now):
    
       - Hisilicon X5HD2 settop box chipset is introduced
       - Mediatek MT6589 (mobile chipset) is introduced
       - Broadcom BCM7xxx settop box chipset is introduced
    
      + as usual a lot other pieces all over the platform code"
    
    * tag 'soc-for-3.17' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (240 commits)
      ARM: hisi: remove smp from machine descriptor
      power: reset: move hisilicon reboot code
      ARM: dts: Add hix5hd2-dkb dts file.
      ARM: debug: Rename Hi3716 to HIX5HD2
      ARM: hisi: enable hix5hd2 SoC
      ARM: hisi: add ARCH_HISI
      MAINTAINERS: add entry for Broadcom ARM STB architecture
      ARM: brcmstb: select GISB arbiter and interrupt drivers
      ARM: brcmstb: add infrastructure for ARM-based Broadcom STB SoCs
      ARM: configs: enable SMP in bcm_defconfig
      ARM: add SMP support for Broadcom mobile SoCs
      Documentation: arm: misc updates to Marvell EBU SoC status
      Documentation: arm: add URLs to public datasheets for the Marvell Armada XP SoC
      ARM: mvebu: fix build without platforms selected
      ARM: mvebu: add cpuidle support for Armada 38x
      ARM: mvebu: add cpuidle support for Armada 370
      cpuidle: mvebu: add Armada 38x support
      cpuidle: mvebu: add Armada 370 support
      cpuidle: mvebu: rename the driver from armada-370-xp to mvebu-v7
      ARM: mvebu: export the SCU address
      ...

commit 44c916d58b9ef1f2c4aec2def57fa8289c716a60
Merge: 889fa782bf8e c4846a7823bf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Aug 8 11:00:26 2014 -0700

    Merge tag 'cleanup-for-3.17' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC cleanups from Olof Johansson:
     "This merge window brings a good size of cleanups on various platforms.
      Among the bigger ones:
    
       - Removal of Samsung s5pc100 and s5p64xx platforms.  Both of these
         have lacked active support for quite a while, and after asking
         around nobody showed interest in keeping them around.  If needed,
         they could be resurrected in the future but it's more likely that
         we would prefer reintroduction of them as DT and
         multiplatform-enabled platforms instead.
    
       - OMAP4 controller code register define diet.  They defined a lot of
         registers that were never actually used, etc.
    
       - Move of some of the Tegra platform code (PMC, APBIO, fuse,
         powergate) to drivers/soc so it can be shared with 64-bit code.
         This also converts them over to traditional driver models where
         possible.
    
       - Removal of legacy gpio-samsung driver, since the last users have
         been removed (moved to pinctrl)
    
      Plus a bunch of smaller changes for various platforms that sort of
      dissapear in the diffstat for the above.  clps711x cleanups, shmobile
      header file refactoring/moves for multiplatform friendliness, some
      misc cleanups, etc"
    
    * tag 'cleanup-for-3.17' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (117 commits)
      drivers: CCI: Correct use of ! and &
      video: clcd-versatile: Depend on ARM
      video: fix up versatile CLCD helper move
      MAINTAINERS: Add sdhci-st file to ARCH/STI architecture
      ARM: EXYNOS: Fix build breakge with PM_SLEEP=n
      MAINTAINERS: Remove Kirkwood
      ARM: tegra: Convert PMC to a driver
      soc/tegra: fuse: Set up in early initcall
      ARM: tegra: Always lock the CPU reset vector
      ARM: tegra: Setup CPU hotplug in a pure initcall
      soc/tegra: Implement runtime check for Tegra SoCs
      soc/tegra: fuse: fix dummy functions
      soc/tegra: fuse: move APB DMA into Tegra20 fuse driver
      soc/tegra: Add efuse and apbmisc bindings
      soc/tegra: Add efuse driver for Tegra
      ARM: tegra: move fuse exports to soc/tegra/fuse.h
      ARM: tegra: export apb dma readl/writel
      ARM: tegra: Use a function to get the chip ID
      ARM: tegra: Sort includes alphabetically
      ARM: tegra: Move includes to include/soc/tegra
      ...

commit c4846a7823bfd34ecb2dc56b025e19285432d08d
Merge: 94f30477fc5b fc5130de8309
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Aug 7 15:03:02 2014 -0700

    Merge branch 'next/fixes-non-critical' into next/cleanup
    
    Merging in the few fixes we had also received, no need to keep those in
    a separate branch.
    
    * next/fixes-non-critical:
      drivers: CCI: Correct use of ! and &
      MAINTAINERS: Add sdhci-st file to ARCH/STI architecture
      ARM: EXYNOS: Fix build breakge with PM_SLEEP=n
      ARM: omap2+: gpmc-nand: Use dynamic platform_device_alloc()
      omap16xx: Removes fixme no longer needed in ocpi_enable()
      ARM: dts: OMAP5: Add device nodes for ABB
      ARM: omap2+: usb-tusb6010.c: Cleaning up variable is set more than once
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 944483d0330bb497549977aa9649be6b7d0ede37
Merge: 03eea7cda201 fd9f5edf6e7e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Jul 26 17:54:21 2014 +0200

    Merge branch 'next/fixes-non-critical' into next/soc
    
    This resolves a nontrivial conflict against a bug fix
    in another branch.
    
    Conflicts:
            arch/arm/mach-exynos/pm.c
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 96bda115ec552ff75319f85828f6c333d101b401
Merge: 8e5655cd4f7e f1ff47454bb2
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Jul 26 12:01:10 2014 +0200

    Merge tag 's5pv210-dt' of git://git.kernel.org/pub/scm/linux/kernel/git/kgene/linux-samsung into next/soc
    
    Merge "Samsung S5PV210 DT support for v3.17" from Kukjin Kim:
    
    - support common clock framework for s5pv210 clock
    - add generic PHY driver on s5pv210 to support it via DT
    - add dt support for s5pv210-goni, smdkc110, smdkv210 and torbreck boards
    - remove board files from mach-s5pv210 and unused codes
    - enable multiplatform for s5pv210
    
    * tag 's5pv210-dt' of git://git.kernel.org/pub/scm/linux/kernel/git/kgene/linux-samsung:
      clk: samsung: s5pv210: Remove legacy board support
      ARM: SAMSUNG: Remove remaining legacy code
      gpio: samsung: Remove legacy support of S5PV210
      ARM: S5PV210: Enable multi-platform build support
      cpufreq: s5pv210: Make the driver multiplatform aware
      ARM: S5PV210: Register cpufreq platform device
      ARM: S5PV210: move debug-macro.S into the common space
      ARM: S5PV210: Untie PM support from legacy code
      ARM: S5PV210: Remove support for board files
      ARM: dts: Add Device tree for s5pc110/s5pv210 boards
      ARM: dts: Add Device tree for s5pv210 SoC
      ARM: S5PV210: Add board file for boot using Device Tree
      phy: Add support for S5PV210 to the Exynos USB 2.0 PHY driver
      clk: samsung: Add S5PV210 Audio Subsystem clock driver
      ARM: SAMSUNG: Remove legacy clock code
      serial: samsung: Remove support for legacy clock code
      cpufreq: s3c24xx: Remove some dead code
      ARM: S5PV210: Migrate clock handling to Common Clock Framework
      clk: samsung: Add clock driver for S5PV210 and compatible SoCs
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 2e94ac42898f84d76e3c21dd91bcd1c51c920dff
Author: Pankaj Dubey <pankaj.dubey@samsung.com>
Date:   Sat Jul 19 03:43:22 2014 +0900

    ARM: EXYNOS: Refactored code for using PMU address via DT
    
    Under "arm/mach-exynos" many files are using PMU register offsets.
    Since we have added support for accessing PMU base address via DT,
    now we can remove PMU mapping from exynosX_iodesc. Let's convert
    all these access using iomapped address.
    This will help us in removing static mapping of PMU base address
    as well as help in reducing dependency over machine header files.
    Thus helping for migration of PMU implementation from machine to
    driver folder which can be reused for ARM64 based SoC.
    
    Also as we have removed static mappings from "regs-pmu.h" it does
    not need map.h anymore. But "platsmp.c" needed this and till now it
    got included indirectly. So lets move header inclusion of
    "mach/map.h" from "regs-pmu.h" to "platsmp.c".
    
    Signed-off-by: Pankaj Dubey <pankaj.dubey@samsung.com>
    Reviewed-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index f127c0cefbb8..bcb96be1efee 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -111,7 +111,7 @@ static int exynos_irq_set_wake(struct irq_data *data, unsigned int state)
  */
 void exynos_cpu_power_down(int cpu)
 {
-	__raw_writel(0, EXYNOS_ARM_CORE_CONFIGURATION(cpu));
+	pmu_raw_writel(0, EXYNOS_ARM_CORE_CONFIGURATION(cpu));
 }
 
 /**
@@ -122,8 +122,8 @@ void exynos_cpu_power_down(int cpu)
  */
 void exynos_cpu_power_up(int cpu)
 {
-	__raw_writel(S5P_CORE_LOCAL_PWR_EN,
-		     EXYNOS_ARM_CORE_CONFIGURATION(cpu));
+	pmu_raw_writel(S5P_CORE_LOCAL_PWR_EN,
+			EXYNOS_ARM_CORE_CONFIGURATION(cpu));
 }
 
 /**
@@ -133,7 +133,7 @@ void exynos_cpu_power_up(int cpu)
  */
 int exynos_cpu_power_state(int cpu)
 {
-	return (__raw_readl(EXYNOS_ARM_CORE_STATUS(cpu)) &
+	return (pmu_raw_readl(EXYNOS_ARM_CORE_STATUS(cpu)) &
 			S5P_CORE_LOCAL_PWR_EN);
 }
 
@@ -143,7 +143,7 @@ int exynos_cpu_power_state(int cpu)
  */
 void exynos_cluster_power_down(int cluster)
 {
-	__raw_writel(0, EXYNOS_COMMON_CONFIGURATION(cluster));
+	pmu_raw_writel(0, EXYNOS_COMMON_CONFIGURATION(cluster));
 }
 
 /**
@@ -152,8 +152,8 @@ void exynos_cluster_power_down(int cluster)
  */
 void exynos_cluster_power_up(int cluster)
 {
-	__raw_writel(S5P_CORE_LOCAL_PWR_EN,
-		     EXYNOS_COMMON_CONFIGURATION(cluster));
+	pmu_raw_writel(S5P_CORE_LOCAL_PWR_EN,
+			EXYNOS_COMMON_CONFIGURATION(cluster));
 }
 
 /**
@@ -163,16 +163,20 @@ void exynos_cluster_power_up(int cluster)
  */
 int exynos_cluster_power_state(int cluster)
 {
-	return (__raw_readl(EXYNOS_COMMON_STATUS(cluster)) &
+	return (pmu_raw_readl(EXYNOS_COMMON_STATUS(cluster)) &
 			S5P_CORE_LOCAL_PWR_EN);
 }
 
 #define EXYNOS_BOOT_VECTOR_ADDR	(samsung_rev() == EXYNOS4210_REV_1_1 ? \
-			S5P_INFORM7 : (samsung_rev() == EXYNOS4210_REV_1_0 ? \
-			(sysram_base_addr + 0x24) : S5P_INFORM0))
+			pmu_base_addr + S5P_INFORM7 : \
+			(samsung_rev() == EXYNOS4210_REV_1_0 ? \
+			(sysram_base_addr + 0x24) : \
+			pmu_base_addr + S5P_INFORM0))
 #define EXYNOS_BOOT_VECTOR_FLAG	(samsung_rev() == EXYNOS4210_REV_1_1 ? \
-			S5P_INFORM6 : (samsung_rev() == EXYNOS4210_REV_1_0 ? \
-			(sysram_base_addr + 0x20) : S5P_INFORM1))
+			pmu_base_addr + S5P_INFORM6 : \
+			(samsung_rev() == EXYNOS4210_REV_1_0 ? \
+			(sysram_base_addr + 0x20) : \
+			pmu_base_addr + S5P_INFORM1))
 
 #define S5P_CHECK_AFTR  0xFCBA0D10
 #define S5P_CHECK_SLEEP 0x00000BAD
@@ -180,7 +184,7 @@ int exynos_cluster_power_state(int cluster)
 /* Ext-GIC nIRQ/nFIQ is the only wakeup source in AFTR */
 static void exynos_set_wakeupmask(long mask)
 {
-	__raw_writel(mask, S5P_WAKEUP_MASK);
+	pmu_raw_writel(mask, S5P_WAKEUP_MASK);
 }
 
 static void exynos_cpu_set_boot_vector(long flags)
@@ -257,27 +261,27 @@ static void exynos_pm_prepare(void)
 	unsigned int tmp;
 
 	/* Set wake-up mask registers */
-	__raw_writel(exynos_get_eint_wake_mask(), S5P_EINT_WAKEUP_MASK);
-	__raw_writel(exynos_irqwake_intmask & ~(1 << 31), S5P_WAKEUP_MASK);
+	pmu_raw_writel(exynos_get_eint_wake_mask(), S5P_EINT_WAKEUP_MASK);
+	pmu_raw_writel(exynos_irqwake_intmask & ~(1 << 31), S5P_WAKEUP_MASK);
 
 	s3c_pm_do_save(exynos_core_save, ARRAY_SIZE(exynos_core_save));
 
 	if (soc_is_exynos5250()) {
 		s3c_pm_do_save(exynos5_sys_save, ARRAY_SIZE(exynos5_sys_save));
 		/* Disable USE_RETENTION of JPEG_MEM_OPTION */
-		tmp = __raw_readl(EXYNOS5_JPEG_MEM_OPTION);
+		tmp = pmu_raw_readl(EXYNOS5_JPEG_MEM_OPTION);
 		tmp &= ~EXYNOS5_OPTION_USE_RETENTION;
-		__raw_writel(tmp, EXYNOS5_JPEG_MEM_OPTION);
+		pmu_raw_writel(tmp, EXYNOS5_JPEG_MEM_OPTION);
 	}
 
 	/* Set value of power down register for sleep mode */
 
 	exynos_sys_powerdown_conf(SYS_SLEEP);
-	__raw_writel(S5P_CHECK_SLEEP, S5P_INFORM1);
+	pmu_raw_writel(S5P_CHECK_SLEEP, S5P_INFORM1);
 
 	/* ensure at least INFORM0 has the resume address */
 
-	__raw_writel(virt_to_phys(exynos_cpu_resume), S5P_INFORM0);
+	pmu_raw_writel(virt_to_phys(exynos_cpu_resume), S5P_INFORM0);
 }
 
 static void exynos_pm_central_suspend(void)
@@ -285,9 +289,9 @@ static void exynos_pm_central_suspend(void)
 	unsigned long tmp;
 
 	/* Setting Central Sequence Register for power down mode */
-	tmp = __raw_readl(S5P_CENTRAL_SEQ_CONFIGURATION);
+	tmp = pmu_raw_readl(S5P_CENTRAL_SEQ_CONFIGURATION);
 	tmp &= ~S5P_CENTRAL_LOWPWR_CFG;
-	__raw_writel(tmp, S5P_CENTRAL_SEQ_CONFIGURATION);
+	pmu_raw_writel(tmp, S5P_CENTRAL_SEQ_CONFIGURATION);
 }
 
 static int exynos_pm_suspend(void)
@@ -299,7 +303,7 @@ static int exynos_pm_suspend(void)
 	/* Setting SEQ_OPTION register */
 
 	tmp = (S5P_USE_STANDBY_WFI0 | S5P_USE_STANDBY_WFE0);
-	__raw_writel(tmp, S5P_CENTRAL_SEQ_OPTION);
+	pmu_raw_writel(tmp, S5P_CENTRAL_SEQ_OPTION);
 
 	if (read_cpuid_part_number() == ARM_CPU_PART_CORTEX_A9)
 		exynos_cpu_save_register();
@@ -317,12 +321,12 @@ static int exynos_pm_central_resume(void)
 	 * S5P_CENTRAL_LOWPWR_CFG bit will not be set automatically
 	 * in this situation.
 	 */
-	tmp = __raw_readl(S5P_CENTRAL_SEQ_CONFIGURATION);
+	tmp = pmu_raw_readl(S5P_CENTRAL_SEQ_CONFIGURATION);
 	if (!(tmp & S5P_CENTRAL_LOWPWR_CFG)) {
 		tmp |= S5P_CENTRAL_LOWPWR_CFG;
-		__raw_writel(tmp, S5P_CENTRAL_SEQ_CONFIGURATION);
+		pmu_raw_writel(tmp, S5P_CENTRAL_SEQ_CONFIGURATION);
 		/* clear the wakeup state register */
-		__raw_writel(0x0, S5P_WAKEUP_STAT);
+		pmu_raw_writel(0x0, S5P_WAKEUP_STAT);
 		/* No need to perform below restore code */
 		return -1;
 	}
@@ -340,13 +344,13 @@ static void exynos_pm_resume(void)
 
 	/* For release retention */
 
-	__raw_writel((1 << 28), S5P_PAD_RET_MAUDIO_OPTION);
-	__raw_writel((1 << 28), S5P_PAD_RET_GPIO_OPTION);
-	__raw_writel((1 << 28), S5P_PAD_RET_UART_OPTION);
-	__raw_writel((1 << 28), S5P_PAD_RET_MMCA_OPTION);
-	__raw_writel((1 << 28), S5P_PAD_RET_MMCB_OPTION);
-	__raw_writel((1 << 28), S5P_PAD_RET_EBIA_OPTION);
-	__raw_writel((1 << 28), S5P_PAD_RET_EBIB_OPTION);
+	pmu_raw_writel((1 << 28), S5P_PAD_RET_MAUDIO_OPTION);
+	pmu_raw_writel((1 << 28), S5P_PAD_RET_GPIO_OPTION);
+	pmu_raw_writel((1 << 28), S5P_PAD_RET_UART_OPTION);
+	pmu_raw_writel((1 << 28), S5P_PAD_RET_MMCA_OPTION);
+	pmu_raw_writel((1 << 28), S5P_PAD_RET_MMCB_OPTION);
+	pmu_raw_writel((1 << 28), S5P_PAD_RET_EBIA_OPTION);
+	pmu_raw_writel((1 << 28), S5P_PAD_RET_EBIB_OPTION);
 
 	if (soc_is_exynos5250())
 		s3c_pm_do_restore(exynos5_sys_save,
@@ -360,7 +364,7 @@ static void exynos_pm_resume(void)
 early_wakeup:
 
 	/* Clear SLEEP mode set in INFORM1 */
-	__raw_writel(0x0, S5P_INFORM1);
+	pmu_raw_writel(0x0, S5P_INFORM1);
 
 	return;
 }
@@ -404,7 +408,7 @@ static int exynos_suspend_enter(suspend_state_t state)
 	s3c_pm_restore_uarts();
 
 	S3C_PMDBG("%s: wakeup stat: %08x\n", __func__,
-			__raw_readl(S5P_WAKEUP_STAT));
+			pmu_raw_readl(S5P_WAKEUP_STAT));
 
 	s3c_pm_check_restore();
 
@@ -475,9 +479,9 @@ void __init exynos_pm_init(void)
 	gic_arch_extn.irq_set_wake = exynos_irq_set_wake;
 
 	/* All wakeup disable */
-	tmp = __raw_readl(S5P_WAKEUP_MASK);
+	tmp = pmu_raw_readl(S5P_WAKEUP_MASK);
 	tmp |= ((0xFF << 8) | (0x1F << 1));
-	__raw_writel(tmp, S5P_WAKEUP_MASK);
+	pmu_raw_writel(tmp, S5P_WAKEUP_MASK);
 
 	register_syscore_ops(&exynos_pm_syscore_ops);
 	suspend_set_ops(&exynos_suspend_ops);

commit 7310d99ffcd15abe6c4168c36bb63a8e7dee617a
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Sat Jul 19 04:45:02 2014 +0900

    ARM: EXYNOS: Fix build breakge with PM_SLEEP=n
    
    Fix building of exynos_defconfig with disabled PM_SLEEP:
    CONFIG_PM_SLEEP=n
    CONFIG_PM_SLEEP_SMP=n
    CONFIG_SUSPEND=n
    by moving functions for power up/down of CPU and cluster to platsmp.c
    
    The build error messages:
    arch/arm/mach-exynos/built-in.o: In function `exynos_boot_secondary':
    arch/arm/mach-exynos/platsmp.c:111: undefined reference to `exynos_cpu_power_state'
    arch/arm/mach-exynos/platsmp.c:112: undefined reference to `exynos_cpu_power_up'
    arch/arm/mach-exynos/platsmp.c:116: undefined reference to `exynos_cpu_power_state'
    make: *** [vmlinux] Error 1
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Reviewed-by: Tomasz Figa <t.figa@samsung.com>,
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 202ca73e49c4..20a8e0efd5db 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -100,72 +100,6 @@ static int exynos_irq_set_wake(struct irq_data *data, unsigned int state)
 	return -ENOENT;
 }
 
-/**
- * exynos_core_power_down : power down the specified cpu
- * @cpu : the cpu to power down
- *
- * Power down the specified cpu. The sequence must be finished by a
- * call to cpu_do_idle()
- *
- */
-void exynos_cpu_power_down(int cpu)
-{
-	__raw_writel(0, EXYNOS_ARM_CORE_CONFIGURATION(cpu));
-}
-
-/**
- * exynos_cpu_power_up : power up the specified cpu
- * @cpu : the cpu to power up
- *
- * Power up the specified cpu
- */
-void exynos_cpu_power_up(int cpu)
-{
-	__raw_writel(S5P_CORE_LOCAL_PWR_EN,
-		     EXYNOS_ARM_CORE_CONFIGURATION(cpu));
-}
-
-/**
- * exynos_cpu_power_state : returns the power state of the cpu
- * @cpu : the cpu to retrieve the power state from
- *
- */
-int exynos_cpu_power_state(int cpu)
-{
-	return (__raw_readl(EXYNOS_ARM_CORE_STATUS(cpu)) &
-			S5P_CORE_LOCAL_PWR_EN);
-}
-
-/**
- * exynos_cluster_power_down : power down the specified cluster
- * @cluster : the cluster to power down
- */
-void exynos_cluster_power_down(int cluster)
-{
-	__raw_writel(0, EXYNOS_COMMON_CONFIGURATION(cluster));
-}
-
-/**
- * exynos_cluster_power_up : power up the specified cluster
- * @cluster : the cluster to power up
- */
-void exynos_cluster_power_up(int cluster)
-{
-	__raw_writel(S5P_CORE_LOCAL_PWR_EN,
-		     EXYNOS_COMMON_CONFIGURATION(cluster));
-}
-
-/**
- * exynos_cluster_power_state : returns the power state of the cluster
- * @cluster : the cluster to retrieve the power state from
- *
- */
-int exynos_cluster_power_state(int cluster)
-{
-	return (__raw_readl(EXYNOS_COMMON_STATUS(cluster)) &
-			S5P_CORE_LOCAL_PWR_EN);
-}
-
 #define EXYNOS_BOOT_VECTOR_ADDR	(samsung_rev() == EXYNOS4210_REV_1_1 ? \
 			S5P_INFORM7 : (samsung_rev() == EXYNOS4210_REV_1_0 ? \
 			(sysram_base_addr + 0x24) : S5P_INFORM0))

commit 32726d2d5502302ba5753854f5f2f12ba22681c4
Author: Tomasz Figa <t.figa@samsung.com>
Date:   Wed Jul 2 19:42:03 2014 +0200

    ARM: SAMSUNG: Remove legacy clock code
    
    Since S5PV210 now has a complete clock driver using Common Clock
    Framework, there is no reason to keep the old code. Remove it together
    with the whole legacy Samsung-specific clock framework which no longer
    has any users.
    
    Signed-off-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index f127c0cefbb8..a8b5af545d26 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -28,7 +28,6 @@
 #include <asm/suspend.h>
 
 #include <plat/pm-common.h>
-#include <plat/pll.h>
 #include <plat/regs-srom.h>
 
 #include <mach/map.h>

commit af040ffc9ba1e079ee4c0748aff64fa3d4716fa5
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jun 24 19:43:15 2014 +0100

    ARM: make it easier to check the CPU part number correctly
    
    Ensure that platform maintainers check the CPU part number in the right
    manner: the CPU part number is meaningless without also checking the
    CPU implement(e|o)r (choose your preferred spelling!)  Provide an
    interface which returns both the implementer and part number together,
    and update the definitions to include the implementer.
    
    Mark the old function as being deprecated... indeed, using the old
    function with the definitions will now always evaluate as false, so
    people must update their un-merged code to the new function.  While
    this could be avoided by adding new definitions, we'd also have to
    create new names for them which would be awkward.
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 202ca73e49c4..67d383de614f 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -300,7 +300,7 @@ static int exynos_pm_suspend(void)
 	tmp = (S5P_USE_STANDBY_WFI0 | S5P_USE_STANDBY_WFE0);
 	__raw_writel(tmp, S5P_CENTRAL_SEQ_OPTION);
 
-	if (read_cpuid_part_number() == ARM_CPU_PART_CORTEX_A9)
+	if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9)
 		exynos_cpu_save_register();
 
 	return 0;
@@ -334,7 +334,7 @@ static void exynos_pm_resume(void)
 	if (exynos_pm_central_resume())
 		goto early_wakeup;
 
-	if (read_cpuid_part_number() == ARM_CPU_PART_CORTEX_A9)
+	if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9)
 		exynos_cpu_restore_register();
 
 	/* For release retention */
@@ -353,7 +353,7 @@ static void exynos_pm_resume(void)
 
 	s3c_pm_do_restore_core(exynos_core_save, ARRAY_SIZE(exynos_core_save));
 
-	if (read_cpuid_part_number() == ARM_CPU_PART_CORTEX_A9)
+	if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9)
 		scu_enable(S5P_VA_SCU);
 
 early_wakeup:
@@ -440,15 +440,14 @@ static int exynos_cpu_pm_notifier(struct notifier_block *self,
 	case CPU_PM_ENTER:
 		if (cpu == 0) {
 			exynos_pm_central_suspend();
-			if (read_cpuid_part_number() == ARM_CPU_PART_CORTEX_A9)
+			if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9)
 				exynos_cpu_save_register();
 		}
 		break;
 
 	case CPU_PM_EXIT:
 		if (cpu == 0) {
-			if (read_cpuid_part_number() ==
-					ARM_CPU_PART_CORTEX_A9) {
+			if (read_cpuid_part() == ARM_CPU_PART_CORTEX_A9) {
 				scu_enable(S5P_VA_SCU);
 				exynos_cpu_restore_register();
 			}

commit 318fd20bd150f8451b7217546220c30dd7fe88e5
Author: Pankaj Dubey <pankaj.dubey@samsung.com>
Date:   Tue Jul 8 07:54:08 2014 +0900

    ARM: EXYNOS: Move SYSREG definition into sys-reg specific file
    
    While making PMU implementation to be device tree based, there are
    few register offsets related with SYSREG present in regs-pmu.h, so
    let's make a new header file "regs-sys.h" to keep all such SYSREG
    related register offsets and remove them from "regs-pmu.h"
    
    Signed-off-by: Pankaj Dubey <pankaj.dubey@samsung.com>
    Reviewed-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 202ca73e49c4..f127c0cefbb8 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -35,6 +35,7 @@
 
 #include "common.h"
 #include "regs-pmu.h"
+#include "regs-sys.h"
 
 /**
  * struct exynos_wkup_irq - Exynos GIC to PMU IRQ mapping

commit c0c3c3590d0d178cd461f0c29aca0e83294c4bc4
Author: Abhilash Kesavan <a.kesavan@samsung.com>
Date:   Wed Jun 18 08:08:49 2014 +0900

    ARM: EXYNOS: fix pm code to check for cortex A9 rather than the SoC
    
    We have an soc check to ensure that the scu and certain A9 specific
    registers are not accessed on Exynos5250 (which is A15 based).
    Rather than adding another soc specific check for 5420 let us test
    for the Cortex A9 primary part number.
    
    This resolves the below crash seen on exynos5420 during core switching
    after the CPUIdle consolidation series was merged.
    
    [  155.975589] [<c0013174>] (scu_enable) from [<c001b0dc>] (exynos_cpu_pm_notifier+0x80/0xc4)
    [  155.983833] [<c001b0dc>] (exynos_cpu_pm_notifier) from [<c003c1b0>] (notifier_call_chain+0x44/0x84)
    [  155.992851] [<c003c1b0>] (notifier_call_chain) from [<c007a49c>] (cpu_pm_notify+0x20/0x3c)
    [  156.001089] [<c007a49c>] (cpu_pm_notify) from [<c007a564>] (cpu_pm_exit+0x20/0x38)
    [  156.008635] [<c007a564>] (cpu_pm_exit) from [<c0019e98>] (bL_switcher_thread+0x298/0x40c)
    [  156.016788] [<c0019e98>] (bL_switcher_thread) from [<c003842c>] (kthread+0xcc/0xe8)
    [  156.024426] [<c003842c>] (kthread) from [<c000e438>] (ret_from_fork+0x14/0x3c)
    [  156.031621] Code: ea017fec c0530a00 c052e3f8 c0012dcc (e5903000
    
    Signed-off-by: Abhilash Kesavan <a.kesavan@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 87c0d34c7fba..202ca73e49c4 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -300,7 +300,7 @@ static int exynos_pm_suspend(void)
 	tmp = (S5P_USE_STANDBY_WFI0 | S5P_USE_STANDBY_WFE0);
 	__raw_writel(tmp, S5P_CENTRAL_SEQ_OPTION);
 
-	if (!soc_is_exynos5250())
+	if (read_cpuid_part_number() == ARM_CPU_PART_CORTEX_A9)
 		exynos_cpu_save_register();
 
 	return 0;
@@ -334,7 +334,7 @@ static void exynos_pm_resume(void)
 	if (exynos_pm_central_resume())
 		goto early_wakeup;
 
-	if (!soc_is_exynos5250())
+	if (read_cpuid_part_number() == ARM_CPU_PART_CORTEX_A9)
 		exynos_cpu_restore_register();
 
 	/* For release retention */
@@ -353,7 +353,7 @@ static void exynos_pm_resume(void)
 
 	s3c_pm_do_restore_core(exynos_core_save, ARRAY_SIZE(exynos_core_save));
 
-	if (!soc_is_exynos5250())
+	if (read_cpuid_part_number() == ARM_CPU_PART_CORTEX_A9)
 		scu_enable(S5P_VA_SCU);
 
 early_wakeup:
@@ -440,15 +440,18 @@ static int exynos_cpu_pm_notifier(struct notifier_block *self,
 	case CPU_PM_ENTER:
 		if (cpu == 0) {
 			exynos_pm_central_suspend();
-			exynos_cpu_save_register();
+			if (read_cpuid_part_number() == ARM_CPU_PART_CORTEX_A9)
+				exynos_cpu_save_register();
 		}
 		break;
 
 	case CPU_PM_EXIT:
 		if (cpu == 0) {
-			if (!soc_is_exynos5250())
+			if (read_cpuid_part_number() ==
+					ARM_CPU_PART_CORTEX_A9) {
 				scu_enable(S5P_VA_SCU);
-			exynos_cpu_restore_register();
+				exynos_cpu_restore_register();
+			}
 			exynos_pm_central_resume();
 		}
 		break;

commit 45e70b7d48d53d5eb193c6b3f012b31ca135fb4c
Merge: b5de1ce01a80 4c8d81934346
Author: Olof Johansson <olof@lixom.net>
Date:   Fri May 30 21:48:39 2014 -0700

    Merge tag 'samsung-drivers-2' of git://git.kernel.org/pub/scm/linux/kernel/git/kgene/linux-samsung into next/drivers
    
    Merge "Samsung 2nd drivers for 3.16" from Kukjin Kim:
    
    This is including fix exynos cpufreq driver compilation with
    ARCH_MULTIPLATFORM. Even though this is a work around, this
    is required for support exynos multiplatform for a while and
    will be updated in near future.
    
    This is based on tags/samsung-exynos.
    
    * tag 'samsung-drivers-2' of git://git.kernel.org/pub/scm/linux/kernel/git/kgene/linux-samsung: (24 commits)
      cpufreq: exynos: Fix driver compilation with ARCH_MULTIPLATFORM
      ARM: EXYNOS: Enable multi-platform build support
      ARM: EXYNOS: Consolidate Kconfig entries
      ARM: EXYNOS: Add support for EXYNOS5410 SoC
      ARM: EXYNOS: Support secondary CPU boot of Exynos3250
      ARM: EXYNOS: Add Exynos3250 SoC ID
      ARM: EXYNOS: Add 5800 SoC support
      ARM: EXYNOS: initial board support for exynos5260 SoC
      clk: exynos5250: Add missing sysmmu clocks for DISP and ISP blocks
      cpufreq: exynos: Fix the compile error
      ARM: S3C24XX: move debug-macro.S into the common space
      ARM: S3C24XX: use generic DEBUG_UART_PHY/_VIRT in debug macro
      ARM: S3C24XX: trim down debug uart handling
      ARM: compressed/head.S: remove s3c24xx special case
      ARM: EXYNOS: Remove unnecessary inclusion of cpu.h
      ARM: EXYNOS: Migrate Exynos specific macros from plat to mach
      ARM: EXYNOS: Remove exynos_subsys registration
      ARM: EXYNOS: Remove duplicate lines in Makefile
      ARM: EXYNOS: use v7_exit_coherency_flush macro for cache disabling
      ARM: dts: Remove g2d_pd node for exynos5420
      ...
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit cd245f59aae5d6ef265f46aa6cea78354d61b629
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Mon May 26 04:50:34 2014 +0900

    ARM: EXYNOS: Fix kernel panic when unplugging CPU1 on exynos
    
    A look at the code reveals use of S5P_VA_SYSRAM macro, in case of certain SoC
    revisions, which is not valid any longer, after SYSRAM started to be mapped
    dynamically. The new dynamic mapping is stored in sysram_base_addr variable,
    which is declared static in platsmp.c
    
    This fix makes sysram_base_addr non-static, declared it in common.h and used
    in pm.c instead of S5P_VA_SYSRAM.
    
    Suggested-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index f7b0b77582f6..0d1a46e7b021 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -169,10 +169,10 @@ int exynos_cluster_power_state(int cluster)
 
 #define EXYNOS_BOOT_VECTOR_ADDR	(samsung_rev() == EXYNOS4210_REV_1_1 ? \
 			S5P_INFORM7 : (samsung_rev() == EXYNOS4210_REV_1_0 ? \
-			(S5P_VA_SYSRAM + 0x24) : S5P_INFORM0))
+			(sysram_base_addr + 0x24) : S5P_INFORM0))
 #define EXYNOS_BOOT_VECTOR_FLAG	(samsung_rev() == EXYNOS4210_REV_1_1 ? \
 			S5P_INFORM6 : (samsung_rev() == EXYNOS4210_REV_1_0 ? \
-			(S5P_VA_SYSRAM + 0x20) : S5P_INFORM1))
+			(sysram_base_addr + 0x20) : S5P_INFORM1))
 
 #define S5P_CHECK_AFTR  0xFCBA0D10
 #define S5P_CHECK_SLEEP 0x00000BAD

commit e30b154bd2df3be95deda85ce5bc5a05a18896ef
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 9 06:56:24 2014 +0900

    ARM: EXYNOS: Move S5P_CHECK_SLEEP into pm.c
    
    This macro is only used there.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 8b268b5b42fa..f7b0b77582f6 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -174,7 +174,8 @@ int exynos_cluster_power_state(int cluster)
 			S5P_INFORM6 : (samsung_rev() == EXYNOS4210_REV_1_0 ? \
 			(S5P_VA_SYSRAM + 0x20) : S5P_INFORM1))
 
-#define S5P_CHECK_AFTR 0xFCBA0D10
+#define S5P_CHECK_AFTR  0xFCBA0D10
+#define S5P_CHECK_SLEEP 0x00000BAD
 
 /* Ext-GIC nIRQ/nFIQ is the only wakeup source in AFTR */
 static void exynos_set_wakeupmask(long mask)

commit 0ebc13e2a2353f76ecdca11cf4d49da0b4e77f09
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 9 06:55:12 2014 +0900

    ARM: EXYNOS: Move the power sequence call in the cpu_pm notifier
    
    The code to initiate and exit the powerdown sequence is the same in
    pm.c and cpuidle.c.
    
    Let's split the common part in the pm.c and reuse it from the cpu_pm notifier.
    
    That is one more step forward to make the cpuidle driver arch indenpendant.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Reviewed-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 179f7e09e20d..8b268b5b42fa 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -279,15 +279,21 @@ static void exynos_pm_prepare(void)
 	__raw_writel(virt_to_phys(exynos_cpu_resume), S5P_INFORM0);
 }
 
-static int exynos_pm_suspend(void)
+static void exynos_pm_central_suspend(void)
 {
 	unsigned long tmp;
 
 	/* Setting Central Sequence Register for power down mode */
-
 	tmp = __raw_readl(S5P_CENTRAL_SEQ_CONFIGURATION);
 	tmp &= ~S5P_CENTRAL_LOWPWR_CFG;
 	__raw_writel(tmp, S5P_CENTRAL_SEQ_CONFIGURATION);
+}
+
+static int exynos_pm_suspend(void)
+{
+	unsigned long tmp;
+
+	exynos_pm_central_suspend();
 
 	/* Setting SEQ_OPTION register */
 
@@ -300,7 +306,7 @@ static int exynos_pm_suspend(void)
 	return 0;
 }
 
-static void exynos_pm_resume(void)
+static int exynos_pm_central_resume(void)
 {
 	unsigned long tmp;
 
@@ -317,9 +323,17 @@ static void exynos_pm_resume(void)
 		/* clear the wakeup state register */
 		__raw_writel(0x0, S5P_WAKEUP_STAT);
 		/* No need to perform below restore code */
-		goto early_wakeup;
+		return -1;
 	}
 
+	return 0;
+}
+
+static void exynos_pm_resume(void)
+{
+	if (exynos_pm_central_resume())
+		goto early_wakeup;
+
 	if (!soc_is_exynos5250())
 		exynos_cpu_restore_register();
 
@@ -424,8 +438,10 @@ static int exynos_cpu_pm_notifier(struct notifier_block *self,
 
 	switch (cmd) {
 	case CPU_PM_ENTER:
-		if (cpu == 0)
+		if (cpu == 0) {
+			exynos_pm_central_suspend();
 			exynos_cpu_save_register();
+		}
 		break;
 
 	case CPU_PM_EXIT:
@@ -433,6 +449,7 @@ static int exynos_cpu_pm_notifier(struct notifier_block *self,
 			if (!soc_is_exynos5250())
 				scu_enable(S5P_VA_SCU);
 			exynos_cpu_restore_register();
+			exynos_pm_central_resume();
 		}
 		break;
 	}

commit 3681bafeb1e4781bdeaecd19aa8c9f6d0db90f6f
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 9 06:53:00 2014 +0900

    ARM: EXYNOS: Move the AFTR state function into pm.c
    
    In order to remove depedency on pm code, let's move the 'exynos_enter_aftr'
    function into the pm.c file as well as the other helper functions.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 24c638d2afd4..179f7e09e20d 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -167,6 +167,35 @@ int exynos_cluster_power_state(int cluster)
 			S5P_CORE_LOCAL_PWR_EN);
 }
 
+#define EXYNOS_BOOT_VECTOR_ADDR	(samsung_rev() == EXYNOS4210_REV_1_1 ? \
+			S5P_INFORM7 : (samsung_rev() == EXYNOS4210_REV_1_0 ? \
+			(S5P_VA_SYSRAM + 0x24) : S5P_INFORM0))
+#define EXYNOS_BOOT_VECTOR_FLAG	(samsung_rev() == EXYNOS4210_REV_1_1 ? \
+			S5P_INFORM6 : (samsung_rev() == EXYNOS4210_REV_1_0 ? \
+			(S5P_VA_SYSRAM + 0x20) : S5P_INFORM1))
+
+#define S5P_CHECK_AFTR 0xFCBA0D10
+
+/* Ext-GIC nIRQ/nFIQ is the only wakeup source in AFTR */
+static void exynos_set_wakeupmask(long mask)
+{
+	__raw_writel(mask, S5P_WAKEUP_MASK);
+}
+
+static void exynos_cpu_set_boot_vector(long flags)
+{
+	__raw_writel(virt_to_phys(exynos_cpu_resume), EXYNOS_BOOT_VECTOR_ADDR);
+	__raw_writel(flags, EXYNOS_BOOT_VECTOR_FLAG);
+}
+
+void exynos_enter_aftr(void)
+{
+	exynos_set_wakeupmask(0x0000ff3e);
+	exynos_cpu_set_boot_vector(S5P_CHECK_AFTR);
+	/* Set value of power down register for aftr mode */
+	exynos_sys_powerdown_conf(SYS_AFTR);
+}
+
 /* For Cortex-A9 Diagnostic and Power control register */
 static unsigned int save_arm_register[2];
 

commit 58afbc61a33928a764460bfa4ea85c9dbe9d0a77
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 9 06:53:26 2014 +0900

    ARM: EXYNOS: Remove ifdef for scu_enable in pm
    
    The scu_enable function is already a noop in the scu's header file is
    CONFIG_SMP=n, so no need to use these macros in the code.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Reviewed-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index fb1d9160991a..24c638d2afd4 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -310,7 +310,7 @@ static void exynos_pm_resume(void)
 
 	s3c_pm_do_restore_core(exynos_core_save, ARRAY_SIZE(exynos_core_save));
 
-	if (IS_ENABLED(CONFIG_SMP) && !soc_is_exynos5250())
+	if (!soc_is_exynos5250())
 		scu_enable(S5P_VA_SCU);
 
 early_wakeup:
@@ -401,10 +401,8 @@ static int exynos_cpu_pm_notifier(struct notifier_block *self,
 
 	case CPU_PM_EXIT:
 		if (cpu == 0) {
-#ifdef CONFIG_SMP
 			if (!soc_is_exynos5250())
 				scu_enable(S5P_VA_SCU);
-#endif
 			exynos_cpu_restore_register();
 		}
 		break;

commit 795537daae8a14dd05923ee78b687a821460d4f1
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 9 06:50:16 2014 +0900

    ARM: EXYNOS: Move scu_enable in the cpu_pm notifier
    
    We make the cpuidle code less arch dependent.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Reviewed-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 3eb80cd4607d..fb1d9160991a 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -400,8 +400,13 @@ static int exynos_cpu_pm_notifier(struct notifier_block *self,
 		break;
 
 	case CPU_PM_EXIT:
-		if (cpu == 0)
+		if (cpu == 0) {
+#ifdef CONFIG_SMP
+			if (!soc_is_exynos5250())
+				scu_enable(S5P_VA_SCU);
+#endif
 			exynos_cpu_restore_register();
+		}
 		break;
 	}
 

commit 85f9f90808b4437bbdff1dff2c80663dae57ab51
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 9 06:43:27 2014 +0900

    ARM: EXYNOS: Use the cpu_pm notifier for pm
    
    Use the cpu_pm_enter/exit notifier to group some pm code inside the
    pm file.
    
    The save and restore code is duplicated across pm.c and cpuidle.c. By
    using the cpu_pm notifier, we can factor out the routine.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Reviewed-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 86a46607969f..3eb80cd4607d 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -16,6 +16,7 @@
 #include <linux/init.h>
 #include <linux/suspend.h>
 #include <linux/syscore_ops.h>
+#include <linux/cpu_pm.h>
 #include <linux/io.h>
 #include <linux/irqchip/arm-gic.h>
 #include <linux/err.h>
@@ -387,10 +388,36 @@ static const struct platform_suspend_ops exynos_suspend_ops = {
 	.valid		= suspend_valid_only_mem,
 };
 
+static int exynos_cpu_pm_notifier(struct notifier_block *self,
+				  unsigned long cmd, void *v)
+{
+	int cpu = smp_processor_id();
+
+	switch (cmd) {
+	case CPU_PM_ENTER:
+		if (cpu == 0)
+			exynos_cpu_save_register();
+		break;
+
+	case CPU_PM_EXIT:
+		if (cpu == 0)
+			exynos_cpu_restore_register();
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block exynos_cpu_pm_notifier_block = {
+	.notifier_call = exynos_cpu_pm_notifier,
+};
+
 void __init exynos_pm_init(void)
 {
 	u32 tmp;
 
+	cpu_pm_register_notifier(&exynos_cpu_pm_notifier_block);
+
 	/* Platform-specific GIC callback */
 	gic_arch_extn.irq_set_wake = exynos_irq_set_wake;
 

commit 309e08c4ca5446ab9f3e8c17581e5515855d339d
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 9 06:43:27 2014 +0900

    ARM: EXYNOS: Encapsulate register access inside a function for pm
    
    That makes the code cleaner and encapsulted. The function will be
    reused in the next patch.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Reviewed-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 3f2ae864582e..86a46607969f 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -169,6 +169,42 @@ int exynos_cluster_power_state(int cluster)
 /* For Cortex-A9 Diagnostic and Power control register */
 static unsigned int save_arm_register[2];
 
+static void exynos_cpu_save_register(void)
+{
+	unsigned long tmp;
+
+	/* Save Power control register */
+	asm ("mrc p15, 0, %0, c15, c0, 0"
+	     : "=r" (tmp) : : "cc");
+
+	save_arm_register[0] = tmp;
+
+	/* Save Diagnostic register */
+	asm ("mrc p15, 0, %0, c15, c0, 1"
+	     : "=r" (tmp) : : "cc");
+
+	save_arm_register[1] = tmp;
+}
+
+static void exynos_cpu_restore_register(void)
+{
+	unsigned long tmp;
+
+	/* Restore Power control register */
+	tmp = save_arm_register[0];
+
+	asm volatile ("mcr p15, 0, %0, c15, c0, 0"
+		      : : "r" (tmp)
+		      : "cc");
+
+	/* Restore Diagnostic register */
+	tmp = save_arm_register[1];
+
+	asm volatile ("mcr p15, 0, %0, c15, c0, 1"
+		      : : "r" (tmp)
+		      : "cc");
+}
+
 static int exynos_cpu_suspend(unsigned long arg)
 {
 #ifdef CONFIG_CACHE_L2X0
@@ -228,17 +264,8 @@ static int exynos_pm_suspend(void)
 	tmp = (S5P_USE_STANDBY_WFI0 | S5P_USE_STANDBY_WFE0);
 	__raw_writel(tmp, S5P_CENTRAL_SEQ_OPTION);
 
-	if (!soc_is_exynos5250()) {
-		/* Save Power control register */
-		asm ("mrc p15, 0, %0, c15, c0, 0"
-		     : "=r" (tmp) : : "cc");
-		save_arm_register[0] = tmp;
-
-		/* Save Diagnostic register */
-		asm ("mrc p15, 0, %0, c15, c0, 1"
-		     : "=r" (tmp) : : "cc");
-		save_arm_register[1] = tmp;
-	}
+	if (!soc_is_exynos5250())
+		exynos_cpu_save_register();
 
 	return 0;
 }
@@ -262,19 +289,9 @@ static void exynos_pm_resume(void)
 		/* No need to perform below restore code */
 		goto early_wakeup;
 	}
-	if (!soc_is_exynos5250()) {
-		/* Restore Power control register */
-		tmp = save_arm_register[0];
-		asm volatile ("mcr p15, 0, %0, c15, c0, 0"
-			      : : "r" (tmp)
-			      : "cc");
-
-		/* Restore Diagnostic register */
-		tmp = save_arm_register[1];
-		asm volatile ("mcr p15, 0, %0, c15, c0, 1"
-			      : : "r" (tmp)
-			      : "cc");
-	}
+
+	if (!soc_is_exynos5250())
+		exynos_cpu_restore_register();
 
 	/* For release retention */
 

commit 4b245edc99f056f05a61cb2b1fd4604875cf8eab
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Tue May 13 07:12:00 2014 +0900

    ARM: EXYNOS: Remove unnecessary inclusion of cpu.h
    
    Exynos specific macros and declarations have been moved to
    mach-exynos. Inclusion of plat/cpu.h is no more necessary.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Reviewed-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 15af0ceb0a66..ca672e24b5cd 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -26,7 +26,6 @@
 #include <asm/smp_scu.h>
 #include <asm/suspend.h>
 
-#include <plat/cpu.h>
 #include <plat/pm-common.h>
 #include <plat/pll.h>
 #include <plat/regs-srom.h>

commit 096d21c6ebd01b3440d1e6063e646d9db8e31ac9
Author: Abhilash Kesavan <a.kesavan@samsung.com>
Date:   Fri May 16 04:23:26 2014 +0900

    ARM: EXYNOS: Add generic cluster power control functions
    
    Add generic cluster power control functions for exynos based SoCS
    for cluster power up/down and to know the cluster status.
    
    Signed-off-by: Abhilash Kesavan <a.kesavan@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index cbfe23598236..3f2ae864582e 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -136,6 +136,36 @@ int exynos_cpu_power_state(int cpu)
 			S5P_CORE_LOCAL_PWR_EN);
 }
 
+/**
+ * exynos_cluster_power_down : power down the specified cluster
+ * @cluster : the cluster to power down
+ */
+void exynos_cluster_power_down(int cluster)
+{
+	__raw_writel(0, EXYNOS_COMMON_CONFIGURATION(cluster));
+}
+
+/**
+ * exynos_cluster_power_up : power up the specified cluster
+ * @cluster : the cluster to power up
+ */
+void exynos_cluster_power_up(int cluster)
+{
+	__raw_writel(S5P_CORE_LOCAL_PWR_EN,
+		     EXYNOS_COMMON_CONFIGURATION(cluster));
+}
+
+/**
+ * exynos_cluster_power_state : returns the power state of the cluster
+ * @cluster : the cluster to retrieve the power state from
+ *
+ */
+int exynos_cluster_power_state(int cluster)
+{
+	return (__raw_readl(EXYNOS_COMMON_STATUS(cluster)) &
+			S5P_CORE_LOCAL_PWR_EN);
+}
+
 /* For Cortex-A9 Diagnostic and Power control register */
 static unsigned int save_arm_register[2];
 

commit d3af6976a24f8cebef23e72ade6d91ddd781c12b
Author: Leela Krishna Amudala <leela.krishna@linaro.org>
Date:   Fri May 16 04:23:24 2014 +0900

    ARM: EXYNOS: Add generic cpu power control functions for exynos SoCs
    
    Add generic cpu power control functions for exynos based
    SoCS for cpu power up/down and to know the cpu status.
    
    Signed-off-by: Leela Krishna Amudala <leela.krishna@linaro.org>
    Signed-off-by: Abhilash Kesavan <a.kesavan@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 15af0ceb0a66..cbfe23598236 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -100,6 +100,42 @@ static int exynos_irq_set_wake(struct irq_data *data, unsigned int state)
 	return -ENOENT;
 }
 
+/**
+ * exynos_core_power_down : power down the specified cpu
+ * @cpu : the cpu to power down
+ *
+ * Power down the specified cpu. The sequence must be finished by a
+ * call to cpu_do_idle()
+ *
+ */
+void exynos_cpu_power_down(int cpu)
+{
+	__raw_writel(0, EXYNOS_ARM_CORE_CONFIGURATION(cpu));
+}
+
+/**
+ * exynos_cpu_power_up : power up the specified cpu
+ * @cpu : the cpu to power up
+ *
+ * Power up the specified cpu
+ */
+void exynos_cpu_power_up(int cpu)
+{
+	__raw_writel(S5P_CORE_LOCAL_PWR_EN,
+		     EXYNOS_ARM_CORE_CONFIGURATION(cpu));
+}
+
+/**
+ * exynos_cpu_power_state : returns the power state of the cpu
+ * @cpu : the cpu to retrieve the power state from
+ *
+ */
+int exynos_cpu_power_state(int cpu)
+{
+	return (__raw_readl(EXYNOS_ARM_CORE_STATUS(cpu)) &
+			S5P_CORE_LOCAL_PWR_EN);
+}
+
 /* For Cortex-A9 Diagnostic and Power control register */
 static unsigned int save_arm_register[2];
 

commit dd8ac696b20c1be5ca4728045df10e882e01e91d
Author: Tomasz Figa <t.figa@samsung.com>
Date:   Tue Mar 18 07:28:30 2014 +0900

    ARM: EXYNOS: Allow wake-up using GIC interrupts
    
    This patch restores the ability to receive wake-up events from internal
    GIC interrupts, e.g. RTC tick or alarm interrupts.
    
    Signed-off-by: Tomasz Figa <t.figa@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index ada1c8374b77..15af0ceb0a66 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -17,6 +17,7 @@
 #include <linux/suspend.h>
 #include <linux/syscore_ops.h>
 #include <linux/io.h>
+#include <linux/irqchip/arm-gic.h>
 #include <linux/err.h>
 #include <linux/clk.h>
 
@@ -35,6 +36,16 @@
 #include "common.h"
 #include "regs-pmu.h"
 
+/**
+ * struct exynos_wkup_irq - Exynos GIC to PMU IRQ mapping
+ * @hwirq: Hardware IRQ signal of the GIC
+ * @mask: Mask in PMU wake-up mask register
+ */
+struct exynos_wkup_irq {
+	unsigned int hwirq;
+	u32 mask;
+};
+
 static struct sleep_save exynos5_sys_save[] = {
 	SAVE_ITEM(EXYNOS5_SYS_I2C_CFG),
 };
@@ -48,8 +59,47 @@ static struct sleep_save exynos_core_save[] = {
 	SAVE_ITEM(S5P_SROM_BC3),
 };
 
+/*
+ * GIC wake-up support
+ */
+
 static u32 exynos_irqwake_intmask = 0xffffffff;
 
+static const struct exynos_wkup_irq exynos4_wkup_irq[] = {
+	{ 76, BIT(1) }, /* RTC alarm */
+	{ 77, BIT(2) }, /* RTC tick */
+	{ /* sentinel */ },
+};
+
+static const struct exynos_wkup_irq exynos5250_wkup_irq[] = {
+	{ 75, BIT(1) }, /* RTC alarm */
+	{ 76, BIT(2) }, /* RTC tick */
+	{ /* sentinel */ },
+};
+
+static int exynos_irq_set_wake(struct irq_data *data, unsigned int state)
+{
+	const struct exynos_wkup_irq *wkup_irq;
+
+	if (soc_is_exynos5250())
+		wkup_irq = exynos5250_wkup_irq;
+	else
+		wkup_irq = exynos4_wkup_irq;
+
+	while (wkup_irq->mask) {
+		if (wkup_irq->hwirq == data->hwirq) {
+			if (!state)
+				exynos_irqwake_intmask |= wkup_irq->mask;
+			else
+				exynos_irqwake_intmask &= ~wkup_irq->mask;
+			return 0;
+		}
+		++wkup_irq;
+	}
+
+	return -ENOENT;
+}
+
 /* For Cortex-A9 Diagnostic and Power control register */
 static unsigned int save_arm_register[2];
 
@@ -258,6 +308,9 @@ void __init exynos_pm_init(void)
 {
 	u32 tmp;
 
+	/* Platform-specific GIC callback */
+	gic_arch_extn.irq_set_wake = exynos_irq_set_wake;
+
 	/* All wakeup disable */
 	tmp = __raw_readl(S5P_WAKEUP_MASK);
 	tmp |= ((0xFF << 8) | (0x1F << 1));

commit d710aa31874e2ff6e656dbd4807f4bd8d659eb93
Author: Tomasz Figa <t.figa@samsung.com>
Date:   Tue Mar 18 07:28:27 2014 +0900

    ARM: EXYNOS: Stop using legacy Samsung PM code
    
    Since Exynos SoCs does not follow most of the semantics of older SoCs
    when configuring the system to enter sleep, there is no reason to rely
    on the legacy Samsung PM core anymore.
    
    This patch adds local Exynos suspend ops and removes all the code left
    unnecessary. As a side effect, suspend support on Exynos becomes
    multiplatform-friendly.
    
    Signed-off-by: Tomasz Figa <t.figa@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 596ed13c4166..ada1c8374b77 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -23,14 +23,14 @@
 #include <asm/cacheflush.h>
 #include <asm/hardware/cache-l2x0.h>
 #include <asm/smp_scu.h>
+#include <asm/suspend.h>
 
 #include <plat/cpu.h>
-#include <plat/pm.h>
+#include <plat/pm-common.h>
 #include <plat/pll.h>
 #include <plat/regs-srom.h>
 
 #include <mach/map.h>
-#include <mach/pm-core.h>
 
 #include "common.h"
 #include "regs-pmu.h"
@@ -48,6 +48,7 @@ static struct sleep_save exynos_core_save[] = {
 	SAVE_ITEM(S5P_SROM_BC3),
 };
 
+static u32 exynos_irqwake_intmask = 0xffffffff;
 
 /* For Cortex-A9 Diagnostic and Power control register */
 static unsigned int save_arm_register[2];
@@ -72,6 +73,10 @@ static void exynos_pm_prepare(void)
 {
 	unsigned int tmp;
 
+	/* Set wake-up mask registers */
+	__raw_writel(exynos_get_eint_wake_mask(), S5P_EINT_WAKEUP_MASK);
+	__raw_writel(exynos_irqwake_intmask & ~(1 << 31), S5P_WAKEUP_MASK);
+
 	s3c_pm_do_save(exynos_core_save, ARRAY_SIZE(exynos_core_save));
 
 	if (soc_is_exynos5250()) {
@@ -89,7 +94,7 @@ static void exynos_pm_prepare(void)
 
 	/* ensure at least INFORM0 has the resume address */
 
-	__raw_writel(virt_to_phys(s3c_cpu_resume), S5P_INFORM0);
+	__raw_writel(virt_to_phys(exynos_cpu_resume), S5P_INFORM0);
 }
 
 static int exynos_pm_suspend(void)
@@ -187,14 +192,71 @@ static struct syscore_ops exynos_pm_syscore_ops = {
 	.resume		= exynos_pm_resume,
 };
 
-void __init exynos_pm_init(void)
+/*
+ * Suspend Ops
+ */
+
+static int exynos_suspend_enter(suspend_state_t state)
 {
-	u32 tmp;
+	int ret;
+
+	s3c_pm_debug_init();
+
+	S3C_PMDBG("%s: suspending the system...\n", __func__);
+
+	S3C_PMDBG("%s: wakeup masks: %08x,%08x\n", __func__,
+			exynos_irqwake_intmask, exynos_get_eint_wake_mask());
 
-	pm_cpu_prep = exynos_pm_prepare;
-	pm_cpu_sleep = exynos_cpu_suspend;
+	if (exynos_irqwake_intmask == -1U
+	    && exynos_get_eint_wake_mask() == -1U) {
+		pr_err("%s: No wake-up sources!\n", __func__);
+		pr_err("%s: Aborting sleep\n", __func__);
+		return -EINVAL;
+	}
+
+	s3c_pm_save_uarts();
+	exynos_pm_prepare();
+	flush_cache_all();
+	s3c_pm_check_store();
+
+	ret = cpu_suspend(0, exynos_cpu_suspend);
+	if (ret)
+		return ret;
+
+	s3c_pm_restore_uarts();
 
-	s3c_pm_init();
+	S3C_PMDBG("%s: wakeup stat: %08x\n", __func__,
+			__raw_readl(S5P_WAKEUP_STAT));
+
+	s3c_pm_check_restore();
+
+	S3C_PMDBG("%s: resuming the system...\n", __func__);
+
+	return 0;
+}
+
+static int exynos_suspend_prepare(void)
+{
+	s3c_pm_check_prepare();
+
+	return 0;
+}
+
+static void exynos_suspend_finish(void)
+{
+	s3c_pm_check_cleanup();
+}
+
+static const struct platform_suspend_ops exynos_suspend_ops = {
+	.enter		= exynos_suspend_enter,
+	.prepare	= exynos_suspend_prepare,
+	.finish		= exynos_suspend_finish,
+	.valid		= suspend_valid_only_mem,
+};
+
+void __init exynos_pm_init(void)
+{
+	u32 tmp;
 
 	/* All wakeup disable */
 	tmp = __raw_readl(S5P_WAKEUP_MASK);
@@ -202,4 +264,5 @@ void __init exynos_pm_init(void)
 	__raw_writel(tmp, S5P_WAKEUP_MASK);
 
 	register_syscore_ops(&exynos_pm_syscore_ops);
+	suspend_set_ops(&exynos_suspend_ops);
 }

commit 559ba237999d723ccba5b4a75cf6b280bac1ab21
Author: Tomasz Figa <t.figa@samsung.com>
Date:   Tue Mar 18 07:28:22 2014 +0900

    ARM: EXYNOS: Remove PM initcalls and useless indirection
    
    This patch simplifies Exynos PM initialization and makes it
    multiplatform friendly by replacing initcalls used originally to invoke
    all the initialization code with explicit function calls.
    
    In addition, an useless subsys_interface is removed, as all its .add_dev
    callback did was setting two function pointers.
    
    Signed-off-by: Tomasz Figa <t.figa@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index ba18214c9aca..596ed13c4166 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -92,39 +92,6 @@ static void exynos_pm_prepare(void)
 	__raw_writel(virt_to_phys(s3c_cpu_resume), S5P_INFORM0);
 }
 
-static int exynos_pm_add(struct device *dev, struct subsys_interface *sif)
-{
-	pm_cpu_prep = exynos_pm_prepare;
-	pm_cpu_sleep = exynos_cpu_suspend;
-
-	return 0;
-}
-
-static struct subsys_interface exynos_pm_interface = {
-	.name		= "exynos_pm",
-	.subsys		= &exynos_subsys,
-	.add_dev	= exynos_pm_add,
-};
-
-static __init int exynos_pm_drvinit(void)
-{
-	unsigned int tmp;
-
-	if (soc_is_exynos5440())
-		return 0;
-
-	s3c_pm_init();
-
-	/* All wakeup disable */
-
-	tmp = __raw_readl(S5P_WAKEUP_MASK);
-	tmp |= ((0xFF << 8) | (0x1F << 1));
-	__raw_writel(tmp, S5P_WAKEUP_MASK);
-
-	return subsys_interface_register(&exynos_pm_interface);
-}
-arch_initcall(exynos_pm_drvinit);
-
 static int exynos_pm_suspend(void)
 {
 	unsigned long tmp;
@@ -220,12 +187,19 @@ static struct syscore_ops exynos_pm_syscore_ops = {
 	.resume		= exynos_pm_resume,
 };
 
-static __init int exynos_pm_syscore_init(void)
+void __init exynos_pm_init(void)
 {
-	if (soc_is_exynos5440())
-		return 0;
+	u32 tmp;
+
+	pm_cpu_prep = exynos_pm_prepare;
+	pm_cpu_sleep = exynos_cpu_suspend;
+
+	s3c_pm_init();
+
+	/* All wakeup disable */
+	tmp = __raw_readl(S5P_WAKEUP_MASK);
+	tmp |= ((0xFF << 8) | (0x1F << 1));
+	__raw_writel(tmp, S5P_WAKEUP_MASK);
 
 	register_syscore_ops(&exynos_pm_syscore_ops);
-	return 0;
 }
-arch_initcall(exynos_pm_syscore_init);

commit e11d919e4aa2009077e3e4f829ff991d37adca61
Author: Tomasz Figa <t.figa@samsung.com>
Date:   Fri Feb 14 08:16:01 2014 +0900

    ARM: EXYNOS: Drop legacy Exynos4 clock suspend/resume code
    
    All the suspend/resume handling is already implemented in Exynos4 clock
    driver, so this legacy code can be safely dropped.
    
    Signed-off-by: Tomasz Figa <t.figa@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Reviewed-by: Thomas Abraham <thomas.ab@samsung.com>
    Reviewed-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index e00025bbbe89..ba18214c9aca 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -35,56 +35,6 @@
 #include "common.h"
 #include "regs-pmu.h"
 
-#define EXYNOS4_EPLL_LOCK			(S5P_VA_CMU + 0x0C010)
-#define EXYNOS4_VPLL_LOCK			(S5P_VA_CMU + 0x0C020)
-
-#define EXYNOS4_EPLL_CON0			(S5P_VA_CMU + 0x0C110)
-#define EXYNOS4_EPLL_CON1			(S5P_VA_CMU + 0x0C114)
-#define EXYNOS4_VPLL_CON0			(S5P_VA_CMU + 0x0C120)
-#define EXYNOS4_VPLL_CON1			(S5P_VA_CMU + 0x0C124)
-
-#define EXYNOS4_CLKSRC_MASK_TOP			(S5P_VA_CMU + 0x0C310)
-#define EXYNOS4_CLKSRC_MASK_CAM			(S5P_VA_CMU + 0x0C320)
-#define EXYNOS4_CLKSRC_MASK_TV			(S5P_VA_CMU + 0x0C324)
-#define EXYNOS4_CLKSRC_MASK_LCD0		(S5P_VA_CMU + 0x0C334)
-#define EXYNOS4_CLKSRC_MASK_MAUDIO		(S5P_VA_CMU + 0x0C33C)
-#define EXYNOS4_CLKSRC_MASK_FSYS		(S5P_VA_CMU + 0x0C340)
-#define EXYNOS4_CLKSRC_MASK_PERIL0		(S5P_VA_CMU + 0x0C350)
-#define EXYNOS4_CLKSRC_MASK_PERIL1		(S5P_VA_CMU + 0x0C354)
-
-#define EXYNOS4_CLKSRC_MASK_DMC			(S5P_VA_CMU + 0x10300)
-
-#define EXYNOS4_EPLLCON0_LOCKED_SHIFT		(29)
-#define EXYNOS4_VPLLCON0_LOCKED_SHIFT		(29)
-
-#define EXYNOS4210_CLKSRC_MASK_LCD1		(S5P_VA_CMU + 0x0C338)
-
-static const struct sleep_save exynos4_set_clksrc[] = {
-	{ .reg = EXYNOS4_CLKSRC_MASK_TOP		, .val = 0x00000001, },
-	{ .reg = EXYNOS4_CLKSRC_MASK_CAM		, .val = 0x11111111, },
-	{ .reg = EXYNOS4_CLKSRC_MASK_TV			, .val = 0x00000111, },
-	{ .reg = EXYNOS4_CLKSRC_MASK_LCD0		, .val = 0x00001111, },
-	{ .reg = EXYNOS4_CLKSRC_MASK_MAUDIO		, .val = 0x00000001, },
-	{ .reg = EXYNOS4_CLKSRC_MASK_FSYS		, .val = 0x01011111, },
-	{ .reg = EXYNOS4_CLKSRC_MASK_PERIL0		, .val = 0x01111111, },
-	{ .reg = EXYNOS4_CLKSRC_MASK_PERIL1		, .val = 0x01110111, },
-	{ .reg = EXYNOS4_CLKSRC_MASK_DMC		, .val = 0x00010000, },
-};
-
-static const struct sleep_save exynos4210_set_clksrc[] = {
-	{ .reg = EXYNOS4210_CLKSRC_MASK_LCD1		, .val = 0x00001111, },
-};
-
-static struct sleep_save exynos4_epll_save[] = {
-	SAVE_ITEM(EXYNOS4_EPLL_CON0),
-	SAVE_ITEM(EXYNOS4_EPLL_CON1),
-};
-
-static struct sleep_save exynos4_vpll_save[] = {
-	SAVE_ITEM(EXYNOS4_VPLL_CON0),
-	SAVE_ITEM(EXYNOS4_VPLL_CON1),
-};
-
 static struct sleep_save exynos5_sys_save[] = {
 	SAVE_ITEM(EXYNOS5_SYS_I2C_CFG),
 };
@@ -124,10 +74,7 @@ static void exynos_pm_prepare(void)
 
 	s3c_pm_do_save(exynos_core_save, ARRAY_SIZE(exynos_core_save));
 
-	if (!soc_is_exynos5250()) {
-		s3c_pm_do_save(exynos4_epll_save, ARRAY_SIZE(exynos4_epll_save));
-		s3c_pm_do_save(exynos4_vpll_save, ARRAY_SIZE(exynos4_vpll_save));
-	} else {
+	if (soc_is_exynos5250()) {
 		s3c_pm_do_save(exynos5_sys_save, ARRAY_SIZE(exynos5_sys_save));
 		/* Disable USE_RETENTION of JPEG_MEM_OPTION */
 		tmp = __raw_readl(EXYNOS5_JPEG_MEM_OPTION);
@@ -143,15 +90,6 @@ static void exynos_pm_prepare(void)
 	/* ensure at least INFORM0 has the resume address */
 
 	__raw_writel(virt_to_phys(s3c_cpu_resume), S5P_INFORM0);
-
-	/* Before enter central sequence mode, clock src register have to set */
-
-	if (!soc_is_exynos5250())
-		s3c_pm_do_restore_core(exynos4_set_clksrc, ARRAY_SIZE(exynos4_set_clksrc));
-
-	if (soc_is_exynos4210())
-		s3c_pm_do_restore_core(exynos4210_set_clksrc, ARRAY_SIZE(exynos4210_set_clksrc));
-
 }
 
 static int exynos_pm_add(struct device *dev, struct subsys_interface *sif)
@@ -162,73 +100,6 @@ static int exynos_pm_add(struct device *dev, struct subsys_interface *sif)
 	return 0;
 }
 
-static unsigned long pll_base_rate;
-
-static void exynos4_restore_pll(void)
-{
-	unsigned long pll_con, locktime, lockcnt;
-	unsigned long pll_in_rate;
-	unsigned int p_div, epll_wait = 0, vpll_wait = 0;
-
-	if (pll_base_rate == 0)
-		return;
-
-	pll_in_rate = pll_base_rate;
-
-	/* EPLL */
-	pll_con = exynos4_epll_save[0].val;
-
-	if (pll_con & (1 << 31)) {
-		pll_con &= (PLL46XX_PDIV_MASK << PLL46XX_PDIV_SHIFT);
-		p_div = (pll_con >> PLL46XX_PDIV_SHIFT);
-
-		pll_in_rate /= 1000000;
-
-		locktime = (3000 / pll_in_rate) * p_div;
-		lockcnt = locktime * 10000 / (10000 / pll_in_rate);
-
-		__raw_writel(lockcnt, EXYNOS4_EPLL_LOCK);
-
-		s3c_pm_do_restore_core(exynos4_epll_save,
-					ARRAY_SIZE(exynos4_epll_save));
-		epll_wait = 1;
-	}
-
-	pll_in_rate = pll_base_rate;
-
-	/* VPLL */
-	pll_con = exynos4_vpll_save[0].val;
-
-	if (pll_con & (1 << 31)) {
-		pll_in_rate /= 1000000;
-		/* 750us */
-		locktime = 750;
-		lockcnt = locktime * 10000 / (10000 / pll_in_rate);
-
-		__raw_writel(lockcnt, EXYNOS4_VPLL_LOCK);
-
-		s3c_pm_do_restore_core(exynos4_vpll_save,
-					ARRAY_SIZE(exynos4_vpll_save));
-		vpll_wait = 1;
-	}
-
-	/* Wait PLL locking */
-
-	do {
-		if (epll_wait) {
-			pll_con = __raw_readl(EXYNOS4_EPLL_CON0);
-			if (pll_con & (1 << EXYNOS4_EPLLCON0_LOCKED_SHIFT))
-				epll_wait = 0;
-		}
-
-		if (vpll_wait) {
-			pll_con = __raw_readl(EXYNOS4_VPLL_CON0);
-			if (pll_con & (1 << EXYNOS4_VPLLCON0_LOCKED_SHIFT))
-				vpll_wait = 0;
-		}
-	} while (epll_wait || vpll_wait);
-}
-
 static struct subsys_interface exynos_pm_interface = {
 	.name		= "exynos_pm",
 	.subsys		= &exynos_subsys,
@@ -237,7 +108,6 @@ static struct subsys_interface exynos_pm_interface = {
 
 static __init int exynos_pm_drvinit(void)
 {
-	struct clk *pll_base;
 	unsigned int tmp;
 
 	if (soc_is_exynos5440())
@@ -251,15 +121,6 @@ static __init int exynos_pm_drvinit(void)
 	tmp |= ((0xFF << 8) | (0x1F << 1));
 	__raw_writel(tmp, S5P_WAKEUP_MASK);
 
-	if (!soc_is_exynos5250()) {
-		pll_base = clk_get(NULL, "xtal");
-
-		if (!IS_ERR(pll_base)) {
-			pll_base_rate = clk_get_rate(pll_base);
-			clk_put(pll_base);
-		}
-	}
-
 	return subsys_interface_register(&exynos_pm_interface);
 }
 arch_initcall(exynos_pm_drvinit);
@@ -343,13 +204,8 @@ static void exynos_pm_resume(void)
 
 	s3c_pm_do_restore_core(exynos_core_save, ARRAY_SIZE(exynos_core_save));
 
-	if (!soc_is_exynos5250()) {
-		exynos4_restore_pll();
-
-#ifdef CONFIG_SMP
+	if (IS_ENABLED(CONFIG_SMP) && !soc_is_exynos5250())
 		scu_enable(S5P_VA_SCU);
-#endif
-	}
 
 early_wakeup:
 

commit 9c9239afe31f67d137ba6c45b244b509c2090567
Author: Kukjin Kim <kgene.kim@samsung.com>
Date:   Thu Dec 19 04:19:59 2013 +0900

    ARM: EXYNOS: local definitions for pm.c into mach-exynos dir
    
    Some of definitions in the regs-clock.h are used only for pm.c,
    so this moves them into the file.
    
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 11c37c4f04fb..e00025bbbe89 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -29,12 +29,36 @@
 #include <plat/pll.h>
 #include <plat/regs-srom.h>
 
-#include <mach/regs-clock.h>
+#include <mach/map.h>
 #include <mach/pm-core.h>
 
 #include "common.h"
 #include "regs-pmu.h"
 
+#define EXYNOS4_EPLL_LOCK			(S5P_VA_CMU + 0x0C010)
+#define EXYNOS4_VPLL_LOCK			(S5P_VA_CMU + 0x0C020)
+
+#define EXYNOS4_EPLL_CON0			(S5P_VA_CMU + 0x0C110)
+#define EXYNOS4_EPLL_CON1			(S5P_VA_CMU + 0x0C114)
+#define EXYNOS4_VPLL_CON0			(S5P_VA_CMU + 0x0C120)
+#define EXYNOS4_VPLL_CON1			(S5P_VA_CMU + 0x0C124)
+
+#define EXYNOS4_CLKSRC_MASK_TOP			(S5P_VA_CMU + 0x0C310)
+#define EXYNOS4_CLKSRC_MASK_CAM			(S5P_VA_CMU + 0x0C320)
+#define EXYNOS4_CLKSRC_MASK_TV			(S5P_VA_CMU + 0x0C324)
+#define EXYNOS4_CLKSRC_MASK_LCD0		(S5P_VA_CMU + 0x0C334)
+#define EXYNOS4_CLKSRC_MASK_MAUDIO		(S5P_VA_CMU + 0x0C33C)
+#define EXYNOS4_CLKSRC_MASK_FSYS		(S5P_VA_CMU + 0x0C340)
+#define EXYNOS4_CLKSRC_MASK_PERIL0		(S5P_VA_CMU + 0x0C350)
+#define EXYNOS4_CLKSRC_MASK_PERIL1		(S5P_VA_CMU + 0x0C354)
+
+#define EXYNOS4_CLKSRC_MASK_DMC			(S5P_VA_CMU + 0x10300)
+
+#define EXYNOS4_EPLLCON0_LOCKED_SHIFT		(29)
+#define EXYNOS4_VPLLCON0_LOCKED_SHIFT		(29)
+
+#define EXYNOS4210_CLKSRC_MASK_LCD1		(S5P_VA_CMU + 0x0C338)
+
 static const struct sleep_save exynos4_set_clksrc[] = {
 	{ .reg = EXYNOS4_CLKSRC_MASK_TOP		, .val = 0x00000001, },
 	{ .reg = EXYNOS4_CLKSRC_MASK_CAM		, .val = 0x11111111, },

commit 05a6380cef5ec2e832871a8bd591f6af4555c335
Author: Kukjin Kim <kgene.kim@samsung.com>
Date:   Thu Dec 19 04:07:32 2013 +0900

    ARM: EXYNOS: cleanup <mach/regs-irq.h>
    
    Remove useless inclusion <mach/regs-irq.h> for exynos.
    
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index a577eb929bee..11c37c4f04fb 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -29,7 +29,6 @@
 #include <plat/pll.h>
 #include <plat/regs-srom.h>
 
-#include <mach/regs-irq.h>
 #include <mach/regs-clock.h>
 #include <mach/pm-core.h>
 

commit 65c9a8530bec45cea1137635b7992bbb417de9de
Author: Kukjin Kim <kgene.kim@samsung.com>
Date:   Thu Dec 19 04:06:56 2013 +0900

    ARM: EXYNOS: local regs-pmu.h header file
    
    This moves regs-pmu.h file into mach-exynos directory.
    
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 7fb0f13d600d..a577eb929bee 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -31,10 +31,10 @@
 
 #include <mach/regs-irq.h>
 #include <mach/regs-clock.h>
-#include <mach/regs-pmu.h>
 #include <mach/pm-core.h>
 
 #include "common.h"
+#include "regs-pmu.h"
 
 static const struct sleep_save exynos4_set_clksrc[] = {
 	{ .reg = EXYNOS4_CLKSRC_MASK_TOP		, .val = 0x00000001, },

commit 7c394e7be4d267c02eaaac8fa197a7c1b023c99b
Author: Daniel Kurtz <djkurtz@chromium.org>
Date:   Thu Dec 12 07:09:33 2013 +0900

    ARM: EXYNOS: Constify clksrc immutable register restore tables
    
    The clksrc tables are constant, they are not used to store register values
    at suspend.
    
    size arch/arm/mach-exynos/pm.o
       text    data     bss
       1591     212      12    // Before
       1671     132      12    // After
    
    Signed-off-by: Daniel Kurtz <djkurtz@chromium.org>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index c679db577269..7fb0f13d600d 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -36,7 +36,7 @@
 
 #include "common.h"
 
-static struct sleep_save exynos4_set_clksrc[] = {
+static const struct sleep_save exynos4_set_clksrc[] = {
 	{ .reg = EXYNOS4_CLKSRC_MASK_TOP		, .val = 0x00000001, },
 	{ .reg = EXYNOS4_CLKSRC_MASK_CAM		, .val = 0x11111111, },
 	{ .reg = EXYNOS4_CLKSRC_MASK_TV			, .val = 0x00000111, },
@@ -48,7 +48,7 @@ static struct sleep_save exynos4_set_clksrc[] = {
 	{ .reg = EXYNOS4_CLKSRC_MASK_DMC		, .val = 0x00010000, },
 };
 
-static struct sleep_save exynos4210_set_clksrc[] = {
+static const struct sleep_save exynos4210_set_clksrc[] = {
 	{ .reg = EXYNOS4210_CLKSRC_MASK_LCD1		, .val = 0x00001111, },
 };
 

commit e085cad6c653e20e213a662ef32fb6191ae0197d
Author: Kukjin Kim <kgene.kim@samsung.com>
Date:   Wed Jun 26 22:29:44 2013 +0900

    ARM: EXYNOS: skip pm support on exynos5440
    
    EXYNOS5440 doesn't support PM and current single image for EXYNOS
    will be break without this patch. Actually, SSDK5440 cannot boot
    without this so this should be merged during rc.
    
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 41c20692a13f..c679db577269 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -217,6 +217,9 @@ static __init int exynos_pm_drvinit(void)
 	struct clk *pll_base;
 	unsigned int tmp;
 
+	if (soc_is_exynos5440())
+		return 0;
+
 	s3c_pm_init();
 
 	/* All wakeup disable */
@@ -340,6 +343,9 @@ static struct syscore_ops exynos_pm_syscore_ops = {
 
 static __init int exynos_pm_syscore_init(void)
 {
+	if (soc_is_exynos5440())
+		return 0;
+
 	register_syscore_ops(&exynos_pm_syscore_ops);
 	return 0;
 }

commit 1816b9ddd0d1e13f10868378501fa25a179d4709
Author: Tomasz Figa <t.figa@samsung.com>
Date:   Sat Jun 15 09:28:46 2013 +0900

    ARM: EXYNOS: Remove mach/regs-gpio.h header
    
    Contents of this header are not used any more and can be safely removed.
    
    Signed-off-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index e3faaa812016..41c20692a13f 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -30,7 +30,6 @@
 #include <plat/regs-srom.h>
 
 #include <mach/regs-irq.h>
-#include <mach/regs-gpio.h>
 #include <mach/regs-clock.h>
 #include <mach/regs-pmu.h>
 #include <mach/pm-core.h>

commit b274776c54c320763bc12eb035c0e244f76ccb43
Merge: b24174b0cbbe 3b1209e7994c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 21 14:58:40 2013 -0800

    Merge tag 'cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC cleanups from Arnd Bergmann:
     "A large number of cleanups, all over the platforms.  This is dominated
      largely by the Samsung platforms (s3c, s5p, exynos) and a few of the
      others moving code out of arch/arm into more appropriate subsystems.
    
      The clocksource and irqchip drivers are now abstracted to the point
      where platforms that are already cleaned up do not need to even
      specify the driver they use, it can all get configured from the device
      tree as we do for normal device drivers.  The clocksource changes
      basically touch every single platform in the process.
    
      We further clean up the use of platform specific header files here,
      with the goal of turning more of the platforms over to being
      "multiplatform" enabled, which implies that they cannot expose their
      headers to architecture independent code any more.
    
      It is expected that no functional changes are part of the cleanup.
      The overall reduction in total code lines is mostly the result of
      removing broken and obsolete code."
    
    * tag 'cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (133 commits)
      ARM: mvebu: correct gated clock documentation
      ARM: kirkwood: add missing include for nsa310
      ARM: exynos: move exynos4210-combiner to drivers/irqchip
      mfd: db8500-prcmu: update resource passing
      drivers/db8500-cpufreq: delete dangling include
      ARM: at91: remove NEOCORE 926 board
      sunxi: Cleanup the reset code and add meaningful registers defines
      ARM: S3C24XX: header mach/regs-mem.h local
      ARM: S3C24XX: header mach/regs-power.h local
      ARM: S3C24XX: header mach/regs-s3c2412-mem.h local
      ARM: S3C24XX: Remove plat-s3c24xx directory in arch/arm/
      ARM: S3C24XX: transform s3c2443 subirqs into new structure
      ARM: S3C24XX: modify s3c2443 irq init to initialize all irqs
      ARM: S3C24XX: move s3c2443 irq code to irq.c
      ARM: S3C24XX: transform s3c2416 irqs into new structure
      ARM: S3C24XX: modify s3c2416 irq init to initialize all irqs
      ARM: S3C24XX: move s3c2416 irq init to common irq code
      ARM: S3C24XX: Modify s3c_irq_wake to use the hwirq property
      ARM: S3C24XX: Move irq syscore-ops to irq-pm
      clocksource: always define CLOCKSOURCE_OF_DECLARE
      ...

commit d3fcacf52d24ff1b12d994d9ddb7496f651294a2
Author: Abhilash Kesavan <a.kesavan@samsung.com>
Date:   Fri Jan 25 10:40:19 2013 -0800

    ARM: SAMSUNG: Gracefully exit on suspend failure
    
    As per the Exynos5250 User Manual:
    When there are pending interrupt events, WFI/WFE instruction are
    ignored. To cancel the power-down sequence follow these steps:
    1) Disable system power-down using CENTRAL_SEQ_CONFIGURATION register
    2) Clear WAKEUP_STAT register
    3) Enable interrupt service routine for CPU
    
    Code for early wakeup for exynos already exists. Remove the panic
    on suspend failure, clear the wakeup state register and return 1
    from cpu_suspend to indicate a failed suspend (to a user daemon).
    
    Older Samsung SoCs have similar panics and I have removed them all.
    Haven't touched the S3C2410 sleep code.
    
    Signed-off-by: Abhilash Kesavan <a.kesavan@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index b9b539cac81e..5106ab83e593 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -91,8 +91,8 @@ static int exynos_cpu_suspend(unsigned long arg)
 	/* issue the standby signal into the pm unit. */
 	cpu_do_idle();
 
-	/* we should never get past here */
-	panic("sleep resumed to originator?");
+	pr_info("Failed to suspend the system\n");
+	return 1; /* Aborting suspend */
 }
 
 static void exynos_pm_prepare(void)
@@ -282,6 +282,8 @@ static void exynos_pm_resume(void)
 	if (!(tmp & S5P_CENTRAL_LOWPWR_CFG)) {
 		tmp |= S5P_CENTRAL_LOWPWR_CFG;
 		__raw_writel(tmp, S5P_CENTRAL_SEQ_CONFIGURATION);
+		/* clear the wakeup state register */
+		__raw_writel(0x0, S5P_WAKEUP_STAT);
 		/* No need to perform below restore code */
 		goto early_wakeup;
 	}

commit ccd458c15df62e4e7001a09b1b000b1fce696640
Author: Kukjin Kim <kgene.kim@samsung.com>
Date:   Mon Dec 31 10:06:48 2012 -0800

    ARM: EXYNOS: move mach/pmu.h file into common.h
    
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index b9b539cac81e..f459afda822a 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -34,7 +34,8 @@
 #include <mach/regs-clock.h>
 #include <mach/regs-pmu.h>
 #include <mach/pm-core.h>
-#include <mach/pmu.h>
+
+#include "common.h"
 
 static struct sleep_save exynos4_set_clksrc[] = {
 	{ .reg = EXYNOS4_CLKSRC_MASK_TOP		, .val = 0x00000001, },

commit 6a57d104c8cb5b6adad6784b4ce6e2f7f9961a3a
Merge: cebfa85eb86d c91321e8ff33
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 14 14:38:28 2012 -0800

    Merge tag 'soc2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM Soc updates, take 2, from Olof Johansson:
     "This is the second batch of SoC updates for the 3.8 merge window,
      containing parts that had dependencies on earlier branches such that
      we couldn't include them with the first branch.
    
      These are general updates for Samsung Exynos, Renesas/shmobile and a
      topic branch that adds SMP support to Altera's socfpga platform."
    
    Fix up conflicts mostly as per Olof.
    
    * tag 'soc2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      ARM: EXYNOS: Clock settings for SATA and SATA PHY
      ARM: EXYNOS: Add ARM down clock support
      ARM: EXYNOS: Fix i2c suspend/resume for legacy controller
      ARM: EXYNOS: Add aliases for i2c controller
      ARM: EXYNOS: Setup legacy i2c controller interrupts
      sh: clkfwk: fixup unsed variable warning
      Revert "ARM: shmobile: r8a7779: Replace modify_scu_cpu_psr with scu_power_mode"
      Revert "ARM: shmobile: sh73a0: Replace modify_scu_cpu_psr with scu_power_mode"
      Revert "ARM: shmobile: emev2: Replace modify_scu_cpu_psr with scu_power_mode"
      ARM: highbank: use common debug_ll_io_init
      ARM: shmobile: sh7372: sh7372_fsiXck_clk become non-global
      ARM: shmobile: sh7372: remove fsidivx clock
      ARM: socfpga: mark secondary_trampoline as cpuinit
      socfpga: map uart into virtual address space so that early_printk() works
      ARM: socfpga: fix build break for allyesconfig
      ARM: socfpga: Enable SMP for socfpga
      ARM: EXYNOS: Add dp clock support for EXYNOS5
      ARM: SAMSUNG: call clk_get_rate for debugfs rate files
      ARM: SAMSUNG: add clock_tree debugfs file in clock

commit 573e5bbe653d01dc0f27e2d97754db9246b501c8
Author: Abhilash Kesavan <a.kesavan@samsung.com>
Date:   Thu Nov 22 14:46:40 2012 +0900

    ARM: EXYNOS: Add flush_cache_all in suspend finisher
    
    The core cpu_suspend code no longer calls flush_cache_all to
    optimize the cpu idle flow. Add a call for the same in the
    exynos specific suspend code.
    
    Signed-off-by: Abhilash Kesavan <a.kesavan@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 8dedeb237924..8df6ec547f78 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -81,6 +81,9 @@ static int exynos_cpu_suspend(unsigned long arg)
 	outer_flush_all();
 #endif
 
+	if (soc_is_exynos5250())
+		flush_cache_all();
+
 	/* issue the standby signal into the pm unit. */
 	cpu_do_idle();
 

commit ebee8541475f2f70d9035265f059570d2f701d5f
Author: Inderpal Singh <inderpal.singh@samsung.com>
Date:   Thu Nov 22 14:46:27 2012 +0900

    ARM: EXYNOS: Fix soft reboot hang after suspend/resume
    
    Upon wake-up, clear the sleep mode set in INFORM1 register.
    
    Signed-off-by: Inderpal Singh <inderpal.singh@samsung.com>
    Tested-by: Abhilash Kesavan <a.kesavan@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index c06c992943a1..8dedeb237924 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -312,6 +312,10 @@ static void exynos_pm_resume(void)
 	}
 
 early_wakeup:
+
+	/* Clear SLEEP mode set in INFORM1 */
+	__raw_writel(0x0, S5P_INFORM1);
+
 	return;
 }
 

commit 86ffb0e83a55aef81e96a9cede28af576c9d5541
Author: Abhilash Kesavan <a.kesavan@samsung.com>
Date:   Tue Nov 20 18:20:45 2012 +0900

    ARM: EXYNOS: Fix i2c suspend/resume for legacy controller
    
    On resuming from suspend the i2c configuration register that is part
    of system controller resets to 0xf. This sets the interrupt source to
    the new high speed i2c rather than the legacy one that we are using.
    Save and restore the I2C_CFG register for exynos5 to fix this.
    
    Signed-off-by: Abhilash Kesavan <a.kesavan@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index c06c992943a1..8306c5276d1c 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -62,6 +62,10 @@ static struct sleep_save exynos4_vpll_save[] = {
 	SAVE_ITEM(EXYNOS4_VPLL_CON1),
 };
 
+static struct sleep_save exynos5_sys_save[] = {
+	SAVE_ITEM(EXYNOS5_SYS_I2C_CFG),
+};
+
 static struct sleep_save exynos_core_save[] = {
 	/* SROM side */
 	SAVE_ITEM(S5P_SROM_BW),
@@ -98,6 +102,7 @@ static void exynos_pm_prepare(void)
 		s3c_pm_do_save(exynos4_epll_save, ARRAY_SIZE(exynos4_epll_save));
 		s3c_pm_do_save(exynos4_vpll_save, ARRAY_SIZE(exynos4_vpll_save));
 	} else {
+		s3c_pm_do_save(exynos5_sys_save, ARRAY_SIZE(exynos5_sys_save));
 		/* Disable USE_RETENTION of JPEG_MEM_OPTION */
 		tmp = __raw_readl(EXYNOS5_JPEG_MEM_OPTION);
 		tmp &= ~EXYNOS5_OPTION_USE_RETENTION;
@@ -301,6 +306,10 @@ static void exynos_pm_resume(void)
 	__raw_writel((1 << 28), S5P_PAD_RET_EBIA_OPTION);
 	__raw_writel((1 << 28), S5P_PAD_RET_EBIB_OPTION);
 
+	if (soc_is_exynos5250())
+		s3c_pm_do_restore(exynos5_sys_save,
+			ARRAY_SIZE(exynos5_sys_save));
+
 	s3c_pm_do_restore_core(exynos_core_save, ARRAY_SIZE(exynos_core_save));
 
 	if (!soc_is_exynos5250()) {

commit 60e49ca654eea42e04912b259fa36bad2c3e56ef
Author: Jongpill Lee <boyko.lee@samsung.com>
Date:   Fri Feb 17 12:23:51 2012 +0900

    ARM: EXYNOS: Support suspend and resume for EXYNOS5250
    
    This patch adds function for suspend and resume of Exynos5250.
    
    Signed-off-by: Jongpill Lee <boyko.lee@samsung.com>
    [kgene.kim@samsung.com: re-worked on top of v3.4-rc7]
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 6aa3b47cee1c..c06c992943a1 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -77,7 +77,9 @@ static unsigned int save_arm_register[2];
 
 static int exynos_cpu_suspend(unsigned long arg)
 {
+#ifdef CONFIG_CACHE_L2X0
 	outer_flush_all();
+#endif
 
 	/* issue the standby signal into the pm unit. */
 	cpu_do_idle();
@@ -88,13 +90,19 @@ static int exynos_cpu_suspend(unsigned long arg)
 
 static void exynos_pm_prepare(void)
 {
-	u32 tmp;
+	unsigned int tmp;
 
 	s3c_pm_do_save(exynos_core_save, ARRAY_SIZE(exynos_core_save));
-	s3c_pm_do_save(exynos4_epll_save, ARRAY_SIZE(exynos4_epll_save));
-	s3c_pm_do_save(exynos4_vpll_save, ARRAY_SIZE(exynos4_vpll_save));
 
-	tmp = __raw_readl(S5P_INFORM1);
+	if (!soc_is_exynos5250()) {
+		s3c_pm_do_save(exynos4_epll_save, ARRAY_SIZE(exynos4_epll_save));
+		s3c_pm_do_save(exynos4_vpll_save, ARRAY_SIZE(exynos4_vpll_save));
+	} else {
+		/* Disable USE_RETENTION of JPEG_MEM_OPTION */
+		tmp = __raw_readl(EXYNOS5_JPEG_MEM_OPTION);
+		tmp &= ~EXYNOS5_OPTION_USE_RETENTION;
+		__raw_writel(tmp, EXYNOS5_JPEG_MEM_OPTION);
+	}
 
 	/* Set value of power down register for sleep mode */
 
@@ -107,7 +115,8 @@ static void exynos_pm_prepare(void)
 
 	/* Before enter central sequence mode, clock src register have to set */
 
-	s3c_pm_do_restore_core(exynos4_set_clksrc, ARRAY_SIZE(exynos4_set_clksrc));
+	if (!soc_is_exynos5250())
+		s3c_pm_do_restore_core(exynos4_set_clksrc, ARRAY_SIZE(exynos4_set_clksrc));
 
 	if (soc_is_exynos4210())
 		s3c_pm_do_restore_core(exynos4210_set_clksrc, ARRAY_SIZE(exynos4210_set_clksrc));
@@ -190,7 +199,7 @@ static void exynos4_restore_pll(void)
 }
 
 static struct subsys_interface exynos_pm_interface = {
-	.name		= "exynos4_pm",
+	.name		= "exynos_pm",
 	.subsys		= &exynos_subsys,
 	.add_dev	= exynos_pm_add,
 };
@@ -231,22 +240,22 @@ static int exynos_pm_suspend(void)
 	tmp &= ~S5P_CENTRAL_LOWPWR_CFG;
 	__raw_writel(tmp, S5P_CENTRAL_SEQ_CONFIGURATION);
 
-	if (soc_is_exynos4212() || soc_is_exynos4412()) {
-		tmp = __raw_readl(S5P_CENTRAL_SEQ_OPTION);
-		tmp &= ~(S5P_USE_STANDBYWFI_ISP_ARM |
-			 S5P_USE_STANDBYWFE_ISP_ARM);
-		__raw_writel(tmp, S5P_CENTRAL_SEQ_OPTION);
-	}
+	/* Setting SEQ_OPTION register */
 
-	/* Save Power control register */
-	asm ("mrc p15, 0, %0, c15, c0, 0"
-	     : "=r" (tmp) : : "cc");
-	save_arm_register[0] = tmp;
+	tmp = (S5P_USE_STANDBY_WFI0 | S5P_USE_STANDBY_WFE0);
+	__raw_writel(tmp, S5P_CENTRAL_SEQ_OPTION);
 
-	/* Save Diagnostic register */
-	asm ("mrc p15, 0, %0, c15, c0, 1"
-	     : "=r" (tmp) : : "cc");
-	save_arm_register[1] = tmp;
+	if (!soc_is_exynos5250()) {
+		/* Save Power control register */
+		asm ("mrc p15, 0, %0, c15, c0, 0"
+		     : "=r" (tmp) : : "cc");
+		save_arm_register[0] = tmp;
+
+		/* Save Diagnostic register */
+		asm ("mrc p15, 0, %0, c15, c0, 1"
+		     : "=r" (tmp) : : "cc");
+		save_arm_register[1] = tmp;
+	}
 
 	return 0;
 }
@@ -268,17 +277,19 @@ static void exynos_pm_resume(void)
 		/* No need to perform below restore code */
 		goto early_wakeup;
 	}
-	/* Restore Power control register */
-	tmp = save_arm_register[0];
-	asm volatile ("mcr p15, 0, %0, c15, c0, 0"
-		      : : "r" (tmp)
-		      : "cc");
-
-	/* Restore Diagnostic register */
-	tmp = save_arm_register[1];
-	asm volatile ("mcr p15, 0, %0, c15, c0, 1"
-		      : : "r" (tmp)
-		      : "cc");
+	if (!soc_is_exynos5250()) {
+		/* Restore Power control register */
+		tmp = save_arm_register[0];
+		asm volatile ("mcr p15, 0, %0, c15, c0, 0"
+			      : : "r" (tmp)
+			      : "cc");
+
+		/* Restore Diagnostic register */
+		tmp = save_arm_register[1];
+		asm volatile ("mcr p15, 0, %0, c15, c0, 1"
+			      : : "r" (tmp)
+			      : "cc");
+	}
 
 	/* For release retention */
 
@@ -292,11 +303,13 @@ static void exynos_pm_resume(void)
 
 	s3c_pm_do_restore_core(exynos_core_save, ARRAY_SIZE(exynos_core_save));
 
-	exynos4_restore_pll();
+	if (!soc_is_exynos5250()) {
+		exynos4_restore_pll();
 
 #ifdef CONFIG_SMP
-	scu_enable(S5P_VA_SCU);
+		scu_enable(S5P_VA_SCU);
 #endif
+	}
 
 early_wakeup:
 	return;
@@ -307,9 +320,9 @@ static struct syscore_ops exynos_pm_syscore_ops = {
 	.resume		= exynos_pm_resume,
 };
 
-static __init int exynos4_pm_syscore_init(void)
+static __init int exynos_pm_syscore_init(void)
 {
 	register_syscore_ops(&exynos_pm_syscore_ops);
 	return 0;
 }
-arch_initcall(exynos4_pm_syscore_init);
+arch_initcall(exynos_pm_syscore_init);

commit 7d44d2ba1abc1bc3c74c8d52e4b6b7be1dbe94b8
Author: Jongpill Lee <boyko.lee@samsung.com>
Date:   Fri Feb 17 09:51:31 2012 +0900

    ARM: EXYNOS: Add PMU table for EXYNOS5250
    
    This patch adds pmu table setting feature for EXYNOS5250.
    
    Signed-off-by: Jongpill Lee <boyko.lee@samsung.com>
    [kgene.kim@samsung.com: re-worked on top of v3.4-rc7]
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 2abc44da8aa0..6aa3b47cee1c 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -98,7 +98,7 @@ static void exynos_pm_prepare(void)
 
 	/* Set value of power down register for sleep mode */
 
-	exynos4_sys_powerdown_conf(SYS_SLEEP);
+	exynos_sys_powerdown_conf(SYS_SLEEP);
 	__raw_writel(S5P_CHECK_SLEEP, S5P_INFORM1);
 
 	/* ensure at least INFORM0 has the resume address */

commit c9347101d8a18ce5d356ac2def6d688fcba85b9b
Author: Jongpill Lee <boyko.lee@samsung.com>
Date:   Fri Feb 17 09:49:54 2012 +0900

    ARM: EXYNOS: Rename of function for pm.c
    
    This patch changes the function name of pmc. to support new
    EXYNOS SoCs commonly.
    
    Signed-off-by: Jongpill Lee <boyko.lee@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index a4d38045ec8e..2abc44da8aa0 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -1,9 +1,8 @@
-/* linux/arch/arm/mach-exynos4/pm.c
- *
- * Copyright (c) 2011 Samsung Electronics Co., Ltd.
+/*
+ * Copyright (c) 2011-2012 Samsung Electronics Co., Ltd.
  *		http://www.samsung.com
  *
- * EXYNOS4210 - Power Management support
+ * EXYNOS - Power Management support
  *
  * Based on arch/arm/mach-s3c2410/pm.c
  * Copyright (c) 2006 Simtec Electronics
@@ -63,7 +62,7 @@ static struct sleep_save exynos4_vpll_save[] = {
 	SAVE_ITEM(EXYNOS4_VPLL_CON1),
 };
 
-static struct sleep_save exynos4_core_save[] = {
+static struct sleep_save exynos_core_save[] = {
 	/* SROM side */
 	SAVE_ITEM(S5P_SROM_BW),
 	SAVE_ITEM(S5P_SROM_BC0),
@@ -76,7 +75,7 @@ static struct sleep_save exynos4_core_save[] = {
 /* For Cortex-A9 Diagnostic and Power control register */
 static unsigned int save_arm_register[2];
 
-static int exynos4_cpu_suspend(unsigned long arg)
+static int exynos_cpu_suspend(unsigned long arg)
 {
 	outer_flush_all();
 
@@ -87,11 +86,11 @@ static int exynos4_cpu_suspend(unsigned long arg)
 	panic("sleep resumed to originator?");
 }
 
-static void exynos4_pm_prepare(void)
+static void exynos_pm_prepare(void)
 {
 	u32 tmp;
 
-	s3c_pm_do_save(exynos4_core_save, ARRAY_SIZE(exynos4_core_save));
+	s3c_pm_do_save(exynos_core_save, ARRAY_SIZE(exynos_core_save));
 	s3c_pm_do_save(exynos4_epll_save, ARRAY_SIZE(exynos4_epll_save));
 	s3c_pm_do_save(exynos4_vpll_save, ARRAY_SIZE(exynos4_vpll_save));
 
@@ -115,10 +114,10 @@ static void exynos4_pm_prepare(void)
 
 }
 
-static int exynos4_pm_add(struct device *dev, struct subsys_interface *sif)
+static int exynos_pm_add(struct device *dev, struct subsys_interface *sif)
 {
-	pm_cpu_prep = exynos4_pm_prepare;
-	pm_cpu_sleep = exynos4_cpu_suspend;
+	pm_cpu_prep = exynos_pm_prepare;
+	pm_cpu_sleep = exynos_cpu_suspend;
 
 	return 0;
 }
@@ -190,13 +189,13 @@ static void exynos4_restore_pll(void)
 	} while (epll_wait || vpll_wait);
 }
 
-static struct subsys_interface exynos4_pm_interface = {
+static struct subsys_interface exynos_pm_interface = {
 	.name		= "exynos4_pm",
 	.subsys		= &exynos_subsys,
-	.add_dev	= exynos4_pm_add,
+	.add_dev	= exynos_pm_add,
 };
 
-static __init int exynos4_pm_drvinit(void)
+static __init int exynos_pm_drvinit(void)
 {
 	struct clk *pll_base;
 	unsigned int tmp;
@@ -209,18 +208,20 @@ static __init int exynos4_pm_drvinit(void)
 	tmp |= ((0xFF << 8) | (0x1F << 1));
 	__raw_writel(tmp, S5P_WAKEUP_MASK);
 
-	pll_base = clk_get(NULL, "xtal");
+	if (!soc_is_exynos5250()) {
+		pll_base = clk_get(NULL, "xtal");
 
-	if (!IS_ERR(pll_base)) {
-		pll_base_rate = clk_get_rate(pll_base);
-		clk_put(pll_base);
+		if (!IS_ERR(pll_base)) {
+			pll_base_rate = clk_get_rate(pll_base);
+			clk_put(pll_base);
+		}
 	}
 
-	return subsys_interface_register(&exynos4_pm_interface);
+	return subsys_interface_register(&exynos_pm_interface);
 }
-arch_initcall(exynos4_pm_drvinit);
+arch_initcall(exynos_pm_drvinit);
 
-static int exynos4_pm_suspend(void)
+static int exynos_pm_suspend(void)
 {
 	unsigned long tmp;
 
@@ -250,7 +251,7 @@ static int exynos4_pm_suspend(void)
 	return 0;
 }
 
-static void exynos4_pm_resume(void)
+static void exynos_pm_resume(void)
 {
 	unsigned long tmp;
 
@@ -289,7 +290,7 @@ static void exynos4_pm_resume(void)
 	__raw_writel((1 << 28), S5P_PAD_RET_EBIA_OPTION);
 	__raw_writel((1 << 28), S5P_PAD_RET_EBIB_OPTION);
 
-	s3c_pm_do_restore_core(exynos4_core_save, ARRAY_SIZE(exynos4_core_save));
+	s3c_pm_do_restore_core(exynos_core_save, ARRAY_SIZE(exynos_core_save));
 
 	exynos4_restore_pll();
 
@@ -301,14 +302,14 @@ static void exynos4_pm_resume(void)
 	return;
 }
 
-static struct syscore_ops exynos4_pm_syscore_ops = {
-	.suspend	= exynos4_pm_suspend,
-	.resume		= exynos4_pm_resume,
+static struct syscore_ops exynos_pm_syscore_ops = {
+	.suspend	= exynos_pm_suspend,
+	.resume		= exynos_pm_resume,
 };
 
 static __init int exynos4_pm_syscore_init(void)
 {
-	register_syscore_ops(&exynos4_pm_syscore_ops);
+	register_syscore_ops(&exynos_pm_syscore_ops);
 	return 0;
 }
 arch_initcall(exynos4_pm_syscore_init);

commit 063bd6f069cc001b526542b2edfdcd93326167b4
Author: Jongpill Lee <boyko.lee@samsung.com>
Date:   Thu Feb 16 10:47:06 2012 +0900

    ARM: EXYNOS: Remove GIC save & restore function
    
    This patch removes GIC save & restore functino in pm.c. Because when
    enalbe CPU_PM feature, GIC driver execute save and restore function
    in CPU_PM notifier.
    So it is not needed to GIC save & restore function at pm.c file.
    
    Signed-off-by: Jongpill Lee <boyko.lee@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 563dea9a6dbb..a4d38045ec8e 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -64,89 +64,6 @@ static struct sleep_save exynos4_vpll_save[] = {
 };
 
 static struct sleep_save exynos4_core_save[] = {
-	/* GIC side */
-	SAVE_ITEM(S5P_VA_GIC_CPU + 0x000),
-	SAVE_ITEM(S5P_VA_GIC_CPU + 0x004),
-	SAVE_ITEM(S5P_VA_GIC_CPU + 0x008),
-	SAVE_ITEM(S5P_VA_GIC_CPU + 0x00C),
-	SAVE_ITEM(S5P_VA_GIC_CPU + 0x014),
-	SAVE_ITEM(S5P_VA_GIC_CPU + 0x018),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x000),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x004),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x100),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x104),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x108),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x300),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x304),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x308),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x400),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x404),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x408),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x40C),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x410),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x414),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x418),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x41C),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x420),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x424),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x428),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x42C),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x430),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x434),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x438),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x43C),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x440),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x444),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x448),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x44C),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x450),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x454),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x458),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x45C),
-
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x800),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x804),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x808),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x80C),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x810),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x814),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x818),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x81C),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x820),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x824),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x828),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x82C),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x830),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x834),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x838),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x83C),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x840),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x844),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x848),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x84C),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x850),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x854),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x858),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0x85C),
-
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0xC00),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0xC04),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0xC08),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0xC0C),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0xC10),
-	SAVE_ITEM(S5P_VA_GIC_DIST + 0xC14),
-
-	SAVE_ITEM(S5P_VA_COMBINER_BASE + 0x000),
-	SAVE_ITEM(S5P_VA_COMBINER_BASE + 0x010),
-	SAVE_ITEM(S5P_VA_COMBINER_BASE + 0x020),
-	SAVE_ITEM(S5P_VA_COMBINER_BASE + 0x030),
-	SAVE_ITEM(S5P_VA_COMBINER_BASE + 0x040),
-	SAVE_ITEM(S5P_VA_COMBINER_BASE + 0x050),
-	SAVE_ITEM(S5P_VA_COMBINER_BASE + 0x060),
-	SAVE_ITEM(S5P_VA_COMBINER_BASE + 0x070),
-	SAVE_ITEM(S5P_VA_COMBINER_BASE + 0x080),
-	SAVE_ITEM(S5P_VA_COMBINER_BASE + 0x090),
-
 	/* SROM side */
 	SAVE_ITEM(S5P_SROM_BW),
 	SAVE_ITEM(S5P_SROM_BC0),

commit 2de05a57467c43f58802cdeaa547aee73396b6f3
Merge: ab5a4e6381d2 380c3a545f7d
Author: Kukjin Kim <kgene.kim@samsung.com>
Date:   Sun May 20 03:04:59 2012 +0900

    Merge branch 'next/devel-exynos5250-1' into next/devel-samsung-2

commit 9ee6af9c3fad48cddc0684d0c77d3ea1329e10a1
Author: Thomas Abraham <thomas.abraham@linaro.org>
Date:   Tue May 15 15:47:40 2012 +0900

    ARM: EXYNOS: Remove a new bus_type instance for EXYNOS5
    
    A seperate bus_type instance is not required for EXYNOS5. The
    existing bus_type instance used with EXYNOS4 is sufficient for
    both EXYNOS4 and EXYNOS5. This also solves issue of uninitialized
    usage of exynos4_subsys in EXYNOS4 power management code that is
    reused for EXYNOS5 also. In addition to that, the existing
    exynos4_subsys bus_type is renamed to exynos_subsys to indicate
    that it is reused on both EXYNOS4 and EXYNOS5 platforms.
    
    Signed-off-by: Thomas Abraham <thomas.abraham@linaro.org>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 428cfeb57724..7164aa95ad9d 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -275,7 +275,7 @@ static void exynos4_restore_pll(void)
 
 static struct subsys_interface exynos4_pm_interface = {
 	.name		= "exynos4_pm",
-	.subsys		= &exynos4_subsys,
+	.subsys		= &exynos_subsys,
 	.add_dev	= exynos4_pm_add,
 };
 

commit 5ddfa8428b9f21453b1160846143e0b50d51b27c
Author: Inderpal Singh <inderpal.singh@linaro.org>
Date:   Tue May 15 00:20:09 2012 +0900

    ARM: EXYNOS: Support Suspend/Resume for EXYNOS4412
    
    This patch provides the suspend/resume support for EXYNOS4412.
    
    Signed-off-by: Inderpal Singh <inderpal.singh@linaro.org>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 428cfeb57724..f0bb4677eb11 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -313,7 +313,7 @@ static int exynos4_pm_suspend(void)
 	tmp &= ~S5P_CENTRAL_LOWPWR_CFG;
 	__raw_writel(tmp, S5P_CENTRAL_SEQ_CONFIGURATION);
 
-	if (soc_is_exynos4212()) {
+	if (soc_is_exynos4212() || soc_is_exynos4412()) {
 		tmp = __raw_readl(S5P_CENTRAL_SEQ_OPTION);
 		tmp &= ~(S5P_USE_STANDBYWFI_ISP_ARM |
 			 S5P_USE_STANDBYWFE_ISP_ARM);

commit bde755679a3ba5af0d16231f8532e8373c5e2ecc
Merge: 62a16d025c68 44b2cef5ae6d
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Mar 19 20:52:33 2012 +0000

    Merge branch 'samsung/cleanup-exynos-clock' into next/soc
    
    Conflicts:
            arch/arm/mach-exynos/clock-exynos4.c
            arch/arm/mach-exynos/clock.c
    
    The cleanup moves the exynos4 clock implementation away, while
    the other branch modifies the file with the old name.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit a855039ee4b814782aebe2448d838944d2d29fcb
Author: Kukjin Kim <kgene.kim@samsung.com>
Date:   Fri Mar 9 14:19:10 2012 -0800

    ARM: EXYNOS: change the prefix S5P_ to EXYNOS4_ for clock
    
    This patch changes prefix of the clk register from S5P_ to
    EXYNOS4_ for new EXYNOS SoCs such as EXYNOS5 and adds prefix
    exynos4_ on clk declarations.
    
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index e19013051772..f105bd2b6765 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -38,29 +38,29 @@
 #include <mach/pmu.h>
 
 static struct sleep_save exynos4_set_clksrc[] = {
-	{ .reg = S5P_CLKSRC_MASK_TOP			, .val = 0x00000001, },
-	{ .reg = S5P_CLKSRC_MASK_CAM			, .val = 0x11111111, },
-	{ .reg = S5P_CLKSRC_MASK_TV			, .val = 0x00000111, },
-	{ .reg = S5P_CLKSRC_MASK_LCD0			, .val = 0x00001111, },
-	{ .reg = S5P_CLKSRC_MASK_MAUDIO			, .val = 0x00000001, },
-	{ .reg = S5P_CLKSRC_MASK_FSYS			, .val = 0x01011111, },
-	{ .reg = S5P_CLKSRC_MASK_PERIL0			, .val = 0x01111111, },
-	{ .reg = S5P_CLKSRC_MASK_PERIL1			, .val = 0x01110111, },
-	{ .reg = S5P_CLKSRC_MASK_DMC			, .val = 0x00010000, },
+	{ .reg = EXYNOS4_CLKSRC_MASK_TOP		, .val = 0x00000001, },
+	{ .reg = EXYNOS4_CLKSRC_MASK_CAM		, .val = 0x11111111, },
+	{ .reg = EXYNOS4_CLKSRC_MASK_TV			, .val = 0x00000111, },
+	{ .reg = EXYNOS4_CLKSRC_MASK_LCD0		, .val = 0x00001111, },
+	{ .reg = EXYNOS4_CLKSRC_MASK_MAUDIO		, .val = 0x00000001, },
+	{ .reg = EXYNOS4_CLKSRC_MASK_FSYS		, .val = 0x01011111, },
+	{ .reg = EXYNOS4_CLKSRC_MASK_PERIL0		, .val = 0x01111111, },
+	{ .reg = EXYNOS4_CLKSRC_MASK_PERIL1		, .val = 0x01110111, },
+	{ .reg = EXYNOS4_CLKSRC_MASK_DMC		, .val = 0x00010000, },
 };
 
 static struct sleep_save exynos4210_set_clksrc[] = {
-	{ .reg = S5P_CLKSRC_MASK_LCD1			, .val = 0x00001111, },
+	{ .reg = EXYNOS4210_CLKSRC_MASK_LCD1		, .val = 0x00001111, },
 };
 
 static struct sleep_save exynos4_epll_save[] = {
-	SAVE_ITEM(S5P_EPLL_CON0),
-	SAVE_ITEM(S5P_EPLL_CON1),
+	SAVE_ITEM(EXYNOS4_EPLL_CON0),
+	SAVE_ITEM(EXYNOS4_EPLL_CON1),
 };
 
 static struct sleep_save exynos4_vpll_save[] = {
-	SAVE_ITEM(S5P_VPLL_CON0),
-	SAVE_ITEM(S5P_VPLL_CON1),
+	SAVE_ITEM(EXYNOS4_VPLL_CON0),
+	SAVE_ITEM(EXYNOS4_VPLL_CON1),
 };
 
 static struct sleep_save exynos4_core_save[] = {
@@ -239,7 +239,7 @@ static void exynos4_restore_pll(void)
 		locktime = (3000 / pll_in_rate) * p_div;
 		lockcnt = locktime * 10000 / (10000 / pll_in_rate);
 
-		__raw_writel(lockcnt, S5P_EPLL_LOCK);
+		__raw_writel(lockcnt, EXYNOS4_EPLL_LOCK);
 
 		s3c_pm_do_restore_core(exynos4_epll_save,
 					ARRAY_SIZE(exynos4_epll_save));
@@ -257,7 +257,7 @@ static void exynos4_restore_pll(void)
 		locktime = 750;
 		lockcnt = locktime * 10000 / (10000 / pll_in_rate);
 
-		__raw_writel(lockcnt, S5P_VPLL_LOCK);
+		__raw_writel(lockcnt, EXYNOS4_VPLL_LOCK);
 
 		s3c_pm_do_restore_core(exynos4_vpll_save,
 					ARRAY_SIZE(exynos4_vpll_save));
@@ -268,14 +268,14 @@ static void exynos4_restore_pll(void)
 
 	do {
 		if (epll_wait) {
-			pll_con = __raw_readl(S5P_EPLL_CON0);
-			if (pll_con & (1 << S5P_EPLLCON0_LOCKED_SHIFT))
+			pll_con = __raw_readl(EXYNOS4_EPLL_CON0);
+			if (pll_con & (1 << EXYNOS4_EPLLCON0_LOCKED_SHIFT))
 				epll_wait = 0;
 		}
 
 		if (vpll_wait) {
-			pll_con = __raw_readl(S5P_VPLL_CON0);
-			if (pll_con & (1 << S5P_VPLLCON0_LOCKED_SHIFT))
+			pll_con = __raw_readl(EXYNOS4_VPLL_CON0);
+			if (pll_con & (1 << EXYNOS4_VPLLCON0_LOCKED_SHIFT))
 				vpll_wait = 0;
 		}
 	} while (epll_wait || vpll_wait);

commit f7c8faedf98aa5ec372e0191078ac7fe1e7fb067
Merge: acf346084bca 4d2e4d7f2c2b
Author: Olof Johansson <olof@lixom.net>
Date:   Sat Mar 10 09:51:26 2012 -0800

    Merge branch 'next/devel-samsung' of git://git.kernel.org/pub/scm/linux/kernel/git/kgene/linux-samsung into next/soc
    
    * 'next/devel-samsung' of git://git.kernel.org/pub/scm/linux/kernel/git/kgene/linux-samsung:
      ARM: EXYNOS: fix cycle count for periodic mode of clock event timers
      ARM: EXYNOS: add support JPEG
      ARM: EXYNOS: Add DMC1, allow PPMU access for DMC
      ARM: SAMSUNG: Correct MIPI-CSIS io memory resource definition
      ARM: SAMSUNG: fix __init attribute on regarding s3c_set_platdata()
      ARM: SAMSUNG: Add __init attribute to samsung_bl_set()
      ARM: S5PV210: Add usb otg phy control
      ARM: S3C64XX: Add usb otg phy control
      ARM: EXYNOS: Enable l2 configuration through device tree
      ARM: EXYNOS: remove useless code to save/restore L2
      ARM: EXYNOS: save L2 settings during bootup
      ARM: S5P: add L2 early resume code
      ARM: EXYNOS: Add support AFTR mode on EXYNOS4210
      ARM: SAMSUNG: use spin_lock_irqsave() in clk_{enable,disable}
      ARM: S3C64XX: Define some additional always off clocks
      ARM: S3C64XX: Reduce residency requirement for cpuidle WFI mode
      ARM: SAMSUNG: Add a callback 'notify_after' for PWM backlight control
      ARM: SAMSUNG: add G2D to plat-s5p and mach-exynos
      ARM: S3C64XX: Gate some more clocks by default
      ARM: S3C64XX: Add basic cpuidle driver

commit d0341c61a2f641c4f90f4ed4b0d538c9bcb63d18
Author: Amit Daniel Kachhap <amit.kachhap@linaro.org>
Date:   Thu Mar 8 02:09:06 2012 -0800

    ARM: EXYNOS: remove useless code to save/restore L2
    
    Following the merge of CPU PM notifiers and L2 resume code, this patch
    removes useless code to save and restore L2 registers.
    
    This is now automatically covered by suspend calls which integrated
    CPU PM notifiers and new sleep code that allows to resume L2 before MMU
    is turned on.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Amit Daniel Kachhap <amit.kachhap@linaro.org>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index a4f61a43c7ba..2dd55a191abd 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -155,13 +155,6 @@ static struct sleep_save exynos4_core_save[] = {
 	SAVE_ITEM(S5P_SROM_BC3),
 };
 
-static struct sleep_save exynos4_l2cc_save[] = {
-	SAVE_ITEM(S5P_VA_L2CC + L2X0_TAG_LATENCY_CTRL),
-	SAVE_ITEM(S5P_VA_L2CC + L2X0_DATA_LATENCY_CTRL),
-	SAVE_ITEM(S5P_VA_L2CC + L2X0_PREFETCH_CTRL),
-	SAVE_ITEM(S5P_VA_L2CC + L2X0_POWER_CTRL),
-	SAVE_ITEM(S5P_VA_L2CC + L2X0_AUX_CTRL),
-};
 
 /* For Cortex-A9 Diagnostic and Power control register */
 static unsigned int save_arm_register[2];
@@ -182,7 +175,6 @@ static void exynos4_pm_prepare(void)
 	u32 tmp;
 
 	s3c_pm_do_save(exynos4_core_save, ARRAY_SIZE(exynos4_core_save));
-	s3c_pm_do_save(exynos4_l2cc_save, ARRAY_SIZE(exynos4_l2cc_save));
 	s3c_pm_do_save(exynos4_epll_save, ARRAY_SIZE(exynos4_epll_save));
 	s3c_pm_do_save(exynos4_vpll_save, ARRAY_SIZE(exynos4_vpll_save));
 
@@ -386,13 +378,6 @@ static void exynos4_pm_resume(void)
 
 	scu_enable(S5P_VA_SCU);
 
-#ifdef CONFIG_CACHE_L2X0
-	s3c_pm_do_restore_core(exynos4_l2cc_save, ARRAY_SIZE(exynos4_l2cc_save));
-	outer_inv_all();
-	/* enable L2X0*/
-	writel_relaxed(1, S5P_VA_L2CC + L2X0_CTRL);
-#endif
-
 early_wakeup:
 	return;
 }

commit 9a60571ecf918162553592ef8c4b4450155394a0
Author: Jonghwan Choi <jhbird.choi@samsung.com>
Date:   Fri Jan 27 15:30:48 2012 +0900

    ARM: EXYNOS: Fix "warning: initialization from incompatible pointer type"
    
    Fix the wrong function prototype.
    
    Signed-off-by: Jonghwan Choi <jhbird.choi@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 2521b23553eb..e19013051772 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -206,7 +206,7 @@ static void exynos4_pm_prepare(void)
 
 }
 
-static int exynos4_pm_add(struct device *dev)
+static int exynos4_pm_add(struct device *dev, struct subsys_interface *sif)
 {
 	pm_cpu_prep = exynos4_pm_prepare;
 	pm_cpu_sleep = exynos4_cpu_suspend;

commit 556ef3e474dd87d627655dafdf1e7eaf4747e388
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Fri Jan 27 14:47:45 2012 +0900

    ARM: EXYNOS: fix non-SMP builds for EXYNOS4
    
    This patch fixes the following build issue, which happens only if
    SMP has been disabled:
    
    arch/arm/mach-exynos/built-in.o: In function `exynos4_pm_resume':
    arch/arm/mach-exynos/pm.c:387: undefined reference to `scu_enable'
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index a4f61a43c7ba..2521b23553eb 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -384,7 +384,9 @@ static void exynos4_pm_resume(void)
 
 	exynos4_restore_pll();
 
+#ifdef CONFIG_SMP
 	scu_enable(S5P_VA_SCU);
+#endif
 
 #ifdef CONFIG_CACHE_L2X0
 	s3c_pm_do_restore_core(exynos4_l2cc_save, ARRAY_SIZE(exynos4_l2cc_save));

commit 190a44e65b0f32eaf5b4db3969f5eb224f83a7a2
Merge: dfc1ebe76663 b48741cce3be
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 9 14:30:28 2012 -0800

    Merge tag 'cleanup2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Cleanups for the Samsung platforms
    
    Various cleanup changes that the device driver changes are built upon.
    Since the samsung cleanups depend on the device tree series, which
    depends on the first set of cleanups for tegra.
    
    * tag 'cleanup2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      ARM: EXYNOS: Use gpio_request_one
      ARM: S5PV210: Use gpio_request_one
      ARM: S3C64XX: Modified according to SPI consolidation work
      ARM: S5PV210: Modified files for SPI consolidation work
      ARM: S5P64X0: Modified files for SPI consolidation work
      ARM: S5PC100: Modified files for SPI consolidation work
      ARM: S3C64XX: Modified files for SPI consolidation work
      ARM: SAMSUNG: Consolidation of SPI platform devices to plat-samsung
      ARM: SAMSUNG: Remove SPI bus clocks from platform data
      ARM: S5PV210: Add SPI clkdev support
      ARM: S5P64X0: Add SPI clkdev support
      ARM: S5PC100: Add SPI clkdev support
      ARM: S3C64XX: Add SPI clkdev support
      spi/s3c64xx: Use bus clocks created using clkdev
      mmc: sdhci-s3c: Use generic clock names for sdhci bus clock options
      ARM: SAMSUNG: Add lookup of sdhci-s3c clocks using generic names
      ARM: SAMSUNG: Remove SDHCI bus clocks from platform data
      ARM: SAMSUNG: Use kmemdup rather than duplicating its implementation
      ARM: EXYNOS: remove exynos4_scu_enable()

commit 4a858cfc9af87cc60b3113c3b7b377a4305eac6a
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Dec 21 16:01:38 2011 -0800

    arm: convert sysdev_class to a regular subsystem
    
    After all sysdev classes are ported to regular driver core entities, the
    sysdev implementation will be entirely removed from the kernel.
    
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Cc: Vinod Koul <vinod.koul@intel.com>
    Cc: Boojin Kim <boojin.kim@samsung.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Lucas De Marchi <lucas.demarchi@profusion.mobi>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 509a435afd4b..c4f792dcad19 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -205,7 +205,7 @@ static void exynos4_pm_prepare(void)
 
 }
 
-static int exynos4_pm_add(struct sys_device *sysdev)
+static int exynos4_pm_add(struct device *dev)
 {
 	pm_cpu_prep = exynos4_pm_prepare;
 	pm_cpu_sleep = exynos4_cpu_suspend;
@@ -301,8 +301,10 @@ static void exynos4_restore_pll(void)
 	} while (epll_wait || vpll_wait);
 }
 
-static struct sysdev_driver exynos4_pm_driver = {
-	.add		= exynos4_pm_add,
+static struct subsys_interface exynos4_pm_interface = {
+	.name		= "exynos4_pm",
+	.subsys		= &exynos4_subsys,
+	.add_dev	= exynos4_pm_add,
 };
 
 static __init int exynos4_pm_drvinit(void)
@@ -325,7 +327,7 @@ static __init int exynos4_pm_drvinit(void)
 		clk_put(pll_base);
 	}
 
-	return sysdev_driver_register(&exynos4_sysclass, &exynos4_pm_driver);
+	return subsys_interface_register(&exynos4_pm_interface);
 }
 arch_initcall(exynos4_pm_drvinit);
 

commit 63b870f149cdcd253ae8da88d8b5a0b43a68965c
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Thu Nov 17 01:19:11 2011 +0900

    ARM: EXYNOS: remove exynos4_scu_enable()
    
    The exynos4_scu_enable() is a duplication of scu_enable().  Since
    commit '26a527e ARM: 7100/1: smp_scu: remove __init annotation from
    scu_enable()' makes scu_enable() available for non-init codes, exynos
    can directly call scu_enable() and save exynos4_scu_enable() now.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    [kgene.kim@samsung.com: added missing header]
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
index 509a435afd4b..4093fea849c3 100644
--- a/arch/arm/mach-exynos/pm.c
+++ b/arch/arm/mach-exynos/pm.c
@@ -23,6 +23,7 @@
 
 #include <asm/cacheflush.h>
 #include <asm/hardware/cache-l2x0.h>
+#include <asm/smp_scu.h>
 
 #include <plat/cpu.h>
 #include <plat/pm.h>
@@ -213,27 +214,6 @@ static int exynos4_pm_add(struct sys_device *sysdev)
 	return 0;
 }
 
-/* This function copy from linux/arch/arm/kernel/smp_scu.c */
-
-void exynos4_scu_enable(void __iomem *scu_base)
-{
-	u32 scu_ctrl;
-
-	scu_ctrl = __raw_readl(scu_base);
-	/* already enabled? */
-	if (scu_ctrl & 1)
-		return;
-
-	scu_ctrl |= 1;
-	__raw_writel(scu_ctrl, scu_base);
-
-	/*
-	 * Ensure that the data accessed by CPU0 before the SCU was
-	 * initialised is visible to the other CPUs.
-	 */
-	flush_cache_all();
-}
-
 static unsigned long pll_base_rate;
 
 static void exynos4_restore_pll(void)
@@ -402,7 +382,7 @@ static void exynos4_pm_resume(void)
 
 	exynos4_restore_pll();
 
-	exynos4_scu_enable(S5P_VA_SCU);
+	scu_enable(S5P_VA_SCU);
 
 #ifdef CONFIG_CACHE_L2X0
 	s3c_pm_do_restore_core(exynos4_l2cc_save, ARRAY_SIZE(exynos4_l2cc_save));

commit 830145796a5c8f1ca3f87ea619063c1d99a57df5
Author: Kukjin Kim <kgene.kim@samsung.com>
Date:   Sun Nov 6 13:54:56 2011 +0900

    ARM: EXYNOS: Add ARCH_EXYNOS and reorganize arch/arm/mach-exynos
    
    The arch/arm/mach-exynos4 directory (CONFIG_ARCH_EXYNOS4) has
    made for plaforms based on EXYNOS4 SoCs. But since upcoming
    Samsung's SoCs such as EXYNOS5 (ARM Cortex A15) can reuse most
    codes in current mach-exynos4, one mach-exynos directory will
    be used for them.
    
    This patch changes to CONFIG_ARCH_EXYNOS (arch/arm/mach-exynos)
    but keeps original CONFIG_ARCH_EXYNOS4 in mach-exynos/Kconfig to
    avoid changing in driver side.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Kukjin Kim <kgene.kim@samsung.com>

diff --git a/arch/arm/mach-exynos/pm.c b/arch/arm/mach-exynos/pm.c
new file mode 100644
index 000000000000..509a435afd4b
--- /dev/null
+++ b/arch/arm/mach-exynos/pm.c
@@ -0,0 +1,428 @@
+/* linux/arch/arm/mach-exynos4/pm.c
+ *
+ * Copyright (c) 2011 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * EXYNOS4210 - Power Management support
+ *
+ * Based on arch/arm/mach-s3c2410/pm.c
+ * Copyright (c) 2006 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/init.h>
+#include <linux/suspend.h>
+#include <linux/syscore_ops.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+
+#include <asm/cacheflush.h>
+#include <asm/hardware/cache-l2x0.h>
+
+#include <plat/cpu.h>
+#include <plat/pm.h>
+#include <plat/pll.h>
+#include <plat/regs-srom.h>
+
+#include <mach/regs-irq.h>
+#include <mach/regs-gpio.h>
+#include <mach/regs-clock.h>
+#include <mach/regs-pmu.h>
+#include <mach/pm-core.h>
+#include <mach/pmu.h>
+
+static struct sleep_save exynos4_set_clksrc[] = {
+	{ .reg = S5P_CLKSRC_MASK_TOP			, .val = 0x00000001, },
+	{ .reg = S5P_CLKSRC_MASK_CAM			, .val = 0x11111111, },
+	{ .reg = S5P_CLKSRC_MASK_TV			, .val = 0x00000111, },
+	{ .reg = S5P_CLKSRC_MASK_LCD0			, .val = 0x00001111, },
+	{ .reg = S5P_CLKSRC_MASK_MAUDIO			, .val = 0x00000001, },
+	{ .reg = S5P_CLKSRC_MASK_FSYS			, .val = 0x01011111, },
+	{ .reg = S5P_CLKSRC_MASK_PERIL0			, .val = 0x01111111, },
+	{ .reg = S5P_CLKSRC_MASK_PERIL1			, .val = 0x01110111, },
+	{ .reg = S5P_CLKSRC_MASK_DMC			, .val = 0x00010000, },
+};
+
+static struct sleep_save exynos4210_set_clksrc[] = {
+	{ .reg = S5P_CLKSRC_MASK_LCD1			, .val = 0x00001111, },
+};
+
+static struct sleep_save exynos4_epll_save[] = {
+	SAVE_ITEM(S5P_EPLL_CON0),
+	SAVE_ITEM(S5P_EPLL_CON1),
+};
+
+static struct sleep_save exynos4_vpll_save[] = {
+	SAVE_ITEM(S5P_VPLL_CON0),
+	SAVE_ITEM(S5P_VPLL_CON1),
+};
+
+static struct sleep_save exynos4_core_save[] = {
+	/* GIC side */
+	SAVE_ITEM(S5P_VA_GIC_CPU + 0x000),
+	SAVE_ITEM(S5P_VA_GIC_CPU + 0x004),
+	SAVE_ITEM(S5P_VA_GIC_CPU + 0x008),
+	SAVE_ITEM(S5P_VA_GIC_CPU + 0x00C),
+	SAVE_ITEM(S5P_VA_GIC_CPU + 0x014),
+	SAVE_ITEM(S5P_VA_GIC_CPU + 0x018),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x000),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x004),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x100),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x104),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x108),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x300),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x304),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x308),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x400),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x404),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x408),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x40C),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x410),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x414),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x418),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x41C),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x420),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x424),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x428),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x42C),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x430),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x434),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x438),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x43C),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x440),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x444),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x448),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x44C),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x450),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x454),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x458),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x45C),
+
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x800),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x804),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x808),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x80C),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x810),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x814),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x818),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x81C),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x820),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x824),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x828),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x82C),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x830),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x834),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x838),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x83C),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x840),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x844),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x848),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x84C),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x850),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x854),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x858),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0x85C),
+
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0xC00),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0xC04),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0xC08),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0xC0C),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0xC10),
+	SAVE_ITEM(S5P_VA_GIC_DIST + 0xC14),
+
+	SAVE_ITEM(S5P_VA_COMBINER_BASE + 0x000),
+	SAVE_ITEM(S5P_VA_COMBINER_BASE + 0x010),
+	SAVE_ITEM(S5P_VA_COMBINER_BASE + 0x020),
+	SAVE_ITEM(S5P_VA_COMBINER_BASE + 0x030),
+	SAVE_ITEM(S5P_VA_COMBINER_BASE + 0x040),
+	SAVE_ITEM(S5P_VA_COMBINER_BASE + 0x050),
+	SAVE_ITEM(S5P_VA_COMBINER_BASE + 0x060),
+	SAVE_ITEM(S5P_VA_COMBINER_BASE + 0x070),
+	SAVE_ITEM(S5P_VA_COMBINER_BASE + 0x080),
+	SAVE_ITEM(S5P_VA_COMBINER_BASE + 0x090),
+
+	/* SROM side */
+	SAVE_ITEM(S5P_SROM_BW),
+	SAVE_ITEM(S5P_SROM_BC0),
+	SAVE_ITEM(S5P_SROM_BC1),
+	SAVE_ITEM(S5P_SROM_BC2),
+	SAVE_ITEM(S5P_SROM_BC3),
+};
+
+static struct sleep_save exynos4_l2cc_save[] = {
+	SAVE_ITEM(S5P_VA_L2CC + L2X0_TAG_LATENCY_CTRL),
+	SAVE_ITEM(S5P_VA_L2CC + L2X0_DATA_LATENCY_CTRL),
+	SAVE_ITEM(S5P_VA_L2CC + L2X0_PREFETCH_CTRL),
+	SAVE_ITEM(S5P_VA_L2CC + L2X0_POWER_CTRL),
+	SAVE_ITEM(S5P_VA_L2CC + L2X0_AUX_CTRL),
+};
+
+/* For Cortex-A9 Diagnostic and Power control register */
+static unsigned int save_arm_register[2];
+
+static int exynos4_cpu_suspend(unsigned long arg)
+{
+	outer_flush_all();
+
+	/* issue the standby signal into the pm unit. */
+	cpu_do_idle();
+
+	/* we should never get past here */
+	panic("sleep resumed to originator?");
+}
+
+static void exynos4_pm_prepare(void)
+{
+	u32 tmp;
+
+	s3c_pm_do_save(exynos4_core_save, ARRAY_SIZE(exynos4_core_save));
+	s3c_pm_do_save(exynos4_l2cc_save, ARRAY_SIZE(exynos4_l2cc_save));
+	s3c_pm_do_save(exynos4_epll_save, ARRAY_SIZE(exynos4_epll_save));
+	s3c_pm_do_save(exynos4_vpll_save, ARRAY_SIZE(exynos4_vpll_save));
+
+	tmp = __raw_readl(S5P_INFORM1);
+
+	/* Set value of power down register for sleep mode */
+
+	exynos4_sys_powerdown_conf(SYS_SLEEP);
+	__raw_writel(S5P_CHECK_SLEEP, S5P_INFORM1);
+
+	/* ensure at least INFORM0 has the resume address */
+
+	__raw_writel(virt_to_phys(s3c_cpu_resume), S5P_INFORM0);
+
+	/* Before enter central sequence mode, clock src register have to set */
+
+	s3c_pm_do_restore_core(exynos4_set_clksrc, ARRAY_SIZE(exynos4_set_clksrc));
+
+	if (soc_is_exynos4210())
+		s3c_pm_do_restore_core(exynos4210_set_clksrc, ARRAY_SIZE(exynos4210_set_clksrc));
+
+}
+
+static int exynos4_pm_add(struct sys_device *sysdev)
+{
+	pm_cpu_prep = exynos4_pm_prepare;
+	pm_cpu_sleep = exynos4_cpu_suspend;
+
+	return 0;
+}
+
+/* This function copy from linux/arch/arm/kernel/smp_scu.c */
+
+void exynos4_scu_enable(void __iomem *scu_base)
+{
+	u32 scu_ctrl;
+
+	scu_ctrl = __raw_readl(scu_base);
+	/* already enabled? */
+	if (scu_ctrl & 1)
+		return;
+
+	scu_ctrl |= 1;
+	__raw_writel(scu_ctrl, scu_base);
+
+	/*
+	 * Ensure that the data accessed by CPU0 before the SCU was
+	 * initialised is visible to the other CPUs.
+	 */
+	flush_cache_all();
+}
+
+static unsigned long pll_base_rate;
+
+static void exynos4_restore_pll(void)
+{
+	unsigned long pll_con, locktime, lockcnt;
+	unsigned long pll_in_rate;
+	unsigned int p_div, epll_wait = 0, vpll_wait = 0;
+
+	if (pll_base_rate == 0)
+		return;
+
+	pll_in_rate = pll_base_rate;
+
+	/* EPLL */
+	pll_con = exynos4_epll_save[0].val;
+
+	if (pll_con & (1 << 31)) {
+		pll_con &= (PLL46XX_PDIV_MASK << PLL46XX_PDIV_SHIFT);
+		p_div = (pll_con >> PLL46XX_PDIV_SHIFT);
+
+		pll_in_rate /= 1000000;
+
+		locktime = (3000 / pll_in_rate) * p_div;
+		lockcnt = locktime * 10000 / (10000 / pll_in_rate);
+
+		__raw_writel(lockcnt, S5P_EPLL_LOCK);
+
+		s3c_pm_do_restore_core(exynos4_epll_save,
+					ARRAY_SIZE(exynos4_epll_save));
+		epll_wait = 1;
+	}
+
+	pll_in_rate = pll_base_rate;
+
+	/* VPLL */
+	pll_con = exynos4_vpll_save[0].val;
+
+	if (pll_con & (1 << 31)) {
+		pll_in_rate /= 1000000;
+		/* 750us */
+		locktime = 750;
+		lockcnt = locktime * 10000 / (10000 / pll_in_rate);
+
+		__raw_writel(lockcnt, S5P_VPLL_LOCK);
+
+		s3c_pm_do_restore_core(exynos4_vpll_save,
+					ARRAY_SIZE(exynos4_vpll_save));
+		vpll_wait = 1;
+	}
+
+	/* Wait PLL locking */
+
+	do {
+		if (epll_wait) {
+			pll_con = __raw_readl(S5P_EPLL_CON0);
+			if (pll_con & (1 << S5P_EPLLCON0_LOCKED_SHIFT))
+				epll_wait = 0;
+		}
+
+		if (vpll_wait) {
+			pll_con = __raw_readl(S5P_VPLL_CON0);
+			if (pll_con & (1 << S5P_VPLLCON0_LOCKED_SHIFT))
+				vpll_wait = 0;
+		}
+	} while (epll_wait || vpll_wait);
+}
+
+static struct sysdev_driver exynos4_pm_driver = {
+	.add		= exynos4_pm_add,
+};
+
+static __init int exynos4_pm_drvinit(void)
+{
+	struct clk *pll_base;
+	unsigned int tmp;
+
+	s3c_pm_init();
+
+	/* All wakeup disable */
+
+	tmp = __raw_readl(S5P_WAKEUP_MASK);
+	tmp |= ((0xFF << 8) | (0x1F << 1));
+	__raw_writel(tmp, S5P_WAKEUP_MASK);
+
+	pll_base = clk_get(NULL, "xtal");
+
+	if (!IS_ERR(pll_base)) {
+		pll_base_rate = clk_get_rate(pll_base);
+		clk_put(pll_base);
+	}
+
+	return sysdev_driver_register(&exynos4_sysclass, &exynos4_pm_driver);
+}
+arch_initcall(exynos4_pm_drvinit);
+
+static int exynos4_pm_suspend(void)
+{
+	unsigned long tmp;
+
+	/* Setting Central Sequence Register for power down mode */
+
+	tmp = __raw_readl(S5P_CENTRAL_SEQ_CONFIGURATION);
+	tmp &= ~S5P_CENTRAL_LOWPWR_CFG;
+	__raw_writel(tmp, S5P_CENTRAL_SEQ_CONFIGURATION);
+
+	if (soc_is_exynos4212()) {
+		tmp = __raw_readl(S5P_CENTRAL_SEQ_OPTION);
+		tmp &= ~(S5P_USE_STANDBYWFI_ISP_ARM |
+			 S5P_USE_STANDBYWFE_ISP_ARM);
+		__raw_writel(tmp, S5P_CENTRAL_SEQ_OPTION);
+	}
+
+	/* Save Power control register */
+	asm ("mrc p15, 0, %0, c15, c0, 0"
+	     : "=r" (tmp) : : "cc");
+	save_arm_register[0] = tmp;
+
+	/* Save Diagnostic register */
+	asm ("mrc p15, 0, %0, c15, c0, 1"
+	     : "=r" (tmp) : : "cc");
+	save_arm_register[1] = tmp;
+
+	return 0;
+}
+
+static void exynos4_pm_resume(void)
+{
+	unsigned long tmp;
+
+	/*
+	 * If PMU failed while entering sleep mode, WFI will be
+	 * ignored by PMU and then exiting cpu_do_idle().
+	 * S5P_CENTRAL_LOWPWR_CFG bit will not be set automatically
+	 * in this situation.
+	 */
+	tmp = __raw_readl(S5P_CENTRAL_SEQ_CONFIGURATION);
+	if (!(tmp & S5P_CENTRAL_LOWPWR_CFG)) {
+		tmp |= S5P_CENTRAL_LOWPWR_CFG;
+		__raw_writel(tmp, S5P_CENTRAL_SEQ_CONFIGURATION);
+		/* No need to perform below restore code */
+		goto early_wakeup;
+	}
+	/* Restore Power control register */
+	tmp = save_arm_register[0];
+	asm volatile ("mcr p15, 0, %0, c15, c0, 0"
+		      : : "r" (tmp)
+		      : "cc");
+
+	/* Restore Diagnostic register */
+	tmp = save_arm_register[1];
+	asm volatile ("mcr p15, 0, %0, c15, c0, 1"
+		      : : "r" (tmp)
+		      : "cc");
+
+	/* For release retention */
+
+	__raw_writel((1 << 28), S5P_PAD_RET_MAUDIO_OPTION);
+	__raw_writel((1 << 28), S5P_PAD_RET_GPIO_OPTION);
+	__raw_writel((1 << 28), S5P_PAD_RET_UART_OPTION);
+	__raw_writel((1 << 28), S5P_PAD_RET_MMCA_OPTION);
+	__raw_writel((1 << 28), S5P_PAD_RET_MMCB_OPTION);
+	__raw_writel((1 << 28), S5P_PAD_RET_EBIA_OPTION);
+	__raw_writel((1 << 28), S5P_PAD_RET_EBIB_OPTION);
+
+	s3c_pm_do_restore_core(exynos4_core_save, ARRAY_SIZE(exynos4_core_save));
+
+	exynos4_restore_pll();
+
+	exynos4_scu_enable(S5P_VA_SCU);
+
+#ifdef CONFIG_CACHE_L2X0
+	s3c_pm_do_restore_core(exynos4_l2cc_save, ARRAY_SIZE(exynos4_l2cc_save));
+	outer_inv_all();
+	/* enable L2X0*/
+	writel_relaxed(1, S5P_VA_L2CC + L2X0_CTRL);
+#endif
+
+early_wakeup:
+	return;
+}
+
+static struct syscore_ops exynos4_pm_syscore_ops = {
+	.suspend	= exynos4_pm_suspend,
+	.resume		= exynos4_pm_resume,
+};
+
+static __init int exynos4_pm_syscore_init(void)
+{
+	register_syscore_ops(&exynos4_pm_syscore_ops);
+	return 0;
+}
+arch_initcall(exynos4_pm_syscore_init);
