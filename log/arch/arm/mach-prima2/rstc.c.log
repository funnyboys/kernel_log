commit a636cd6c422865a74ff305039ff0f85adbe3a7bf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:34 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 4
    
    Based on 1 normalized pattern(s):
    
      licensed under gplv2 or later
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 118 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154040.961286471@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-prima2/rstc.c b/arch/arm/mach-prima2/rstc.c
index 7c251eb11d01..9d56606ac87f 100644
--- a/arch/arm/mach-prima2/rstc.c
+++ b/arch/arm/mach-prima2/rstc.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * reset controller for CSR SiRFprimaII
  *
  * Copyright (c) 2011 Cambridge Silicon Radio Limited, a CSR plc group company.
- *
- * Licensed under GPLv2 or later.
  */
 
 #include <linux/kernel.h>

commit e664c3fffdbcef3fd50858fd299eb2bde84dfaf8
Author: Barry Song <Baohua.Song@csr.com>
Date:   Sun Jan 4 14:48:20 2015 +0800

    ARM: sirf: drop Marco support in reset controller module
    
    Marco will not be supported any more. It has been replaced by CSR
    Atlas7.
    
    Signed-off-by: Barry Song <Baohua.Song@csr.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-prima2/rstc.c b/arch/arm/mach-prima2/rstc.c
index e1f1f86f6a95..7c251eb11d01 100644
--- a/arch/arm/mach-prima2/rstc.c
+++ b/arch/arm/mach-prima2/rstc.c
@@ -34,36 +34,20 @@ static int sirfsoc_reset_module(struct reset_controller_dev *rcdev,
 
 	mutex_lock(&rstc_lock);
 
-	if (of_device_is_compatible(rcdev->of_node, "sirf,prima2-rstc")) {
-		/*
-		 * Writing 1 to this bit resets corresponding block.
-		 * Writing 0 to this bit de-asserts reset signal of the
-		 * corresponding block. datasheet doesn't require explicit
-		 * delay between the set and clear of reset bit. it could
-		 * be shorter if tests pass.
-		 */
-		writel(readl(sirfsoc_rstc_base +
+	/*
+	 * Writing 1 to this bit resets corresponding block.
+	 * Writing 0 to this bit de-asserts reset signal of the
+	 * corresponding block. datasheet doesn't require explicit
+	 * delay between the set and clear of reset bit. it could
+	 * be shorter if tests pass.
+	 */
+	writel(readl(sirfsoc_rstc_base +
 			(reset_bit / 32) * 4) | (1 << reset_bit),
-			sirfsoc_rstc_base + (reset_bit / 32) * 4);
-		msleep(20);
-		writel(readl(sirfsoc_rstc_base +
+		sirfsoc_rstc_base + (reset_bit / 32) * 4);
+	msleep(20);
+	writel(readl(sirfsoc_rstc_base +
 			(reset_bit / 32) * 4) & ~(1 << reset_bit),
-			sirfsoc_rstc_base + (reset_bit / 32) * 4);
-	} else {
-		/*
-		 * For MARCO and POLO
-		 * Writing 1 to SET register resets corresponding block.
-		 * Writing 1 to CLEAR register de-asserts reset signal of the
-		 * corresponding block.
-		 * datasheet doesn't require explicit delay between the set and
-		 * clear of reset bit. it could be shorter if tests pass.
-		 */
-		writel(1 << reset_bit,
-			sirfsoc_rstc_base + (reset_bit / 32) * 8);
-		msleep(20);
-		writel(1 << reset_bit,
-			sirfsoc_rstc_base + (reset_bit / 32) * 8 + 4);
-	}
+		sirfsoc_rstc_base + (reset_bit / 32) * 4);
 
 	mutex_unlock(&rstc_lock);
 
@@ -106,7 +90,6 @@ static int sirfsoc_rstc_probe(struct platform_device *pdev)
 
 static const struct of_device_id rstc_ids[]  = {
 	{ .compatible = "sirf,prima2-rstc" },
-	{ .compatible = "sirf,marco-rstc" },
 	{},
 };
 

commit ea18faf9f6173bcb74bd4079dc0356be82d6d8ec
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:05 2014 +0200

    ARM: mach-prima2: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/arch/arm/mach-prima2/rstc.c b/arch/arm/mach-prima2/rstc.c
index 3dffcb2d714e..e1f1f86f6a95 100644
--- a/arch/arm/mach-prima2/rstc.c
+++ b/arch/arm/mach-prima2/rstc.c
@@ -114,7 +114,6 @@ static struct platform_driver sirfsoc_rstc_driver = {
 	.probe		= sirfsoc_rstc_probe,
 	.driver		= {
 		.name	= "sirfsoc_rstc",
-		.owner	= THIS_MODULE,
 		.of_match_table = rstc_ids,
 	},
 };

commit a2a2568311e2207d0c8874e28f578c0bbe3c63b3
Author: Xianglong Du <Xianglong.Du@csr.com>
Date:   Wed May 7 15:08:21 2014 +0800

    ARM: prima2: rstc: fix some minor checkpatch issues
    
    this patch fixes the below minor issues:
    
    WARNING: line over 80 characters
    39: FILE: arch/arm/mach-prima2/rstc.c:39:
    +                * Writing 1 to this bit resets corresponding block. Writing 0 to this
    
    WARNING: line over 80 characters
    41: FILE: arch/arm/mach-prima2/rstc.c:41:
    +                * datasheet doesn't require explicit delay between the set and clear
    
    WARNING: line over 80 characters
    44: FILE: arch/arm/mach-prima2/rstc.c:44:
    +               writel(readl(sirfsoc_rstc_base + (reset_bit / 32) * 4) | (1 << reset_bit),
    
    WARNING: msleep < 20ms can sleep for up to 20ms; see Documentation/timers/timers-howto.txt
    46: FILE: arch/arm/mach-prima2/rstc.c:46:
    +               msleep(10);
    
    WARNING: line over 80 characters
    47: FILE: arch/arm/mach-prima2/rstc.c:47:
    +               writel(readl(sirfsoc_rstc_base + (reset_bit / 32) * 4) & ~(1 << reset_bit),
    
    WARNING: line over 80 characters
    52: FILE: arch/arm/mach-prima2/rstc.c:52:
    +                * Writing 1 to SET register resets corresponding block. Writing 1 to CLEAR
    
    WARNING: line over 80 characters
    54: FILE: arch/arm/mach-prima2/rstc.c:54:
    +                * datasheet doesn't require explicit delay between the set and clear
    
    WARNING: line over 80 characters
    57: FILE: arch/arm/mach-prima2/rstc.c:57:
    +               writel(1 << reset_bit, sirfsoc_rstc_base + (reset_bit / 32) * 8);
    
    WARNING: msleep < 20ms can sleep for up to 20ms; see Documentation/timers/timers-howto.txt
    58: FILE: arch/arm/mach-prima2/rstc.c:58:
    +               msleep(10);
    
    WARNING: line over 80 characters
    59: FILE: arch/arm/mach-prima2/rstc.c:59:
    +               writel(1 << reset_bit, sirfsoc_rstc_base + (reset_bit / 32) * 8 + 4);
    
    total: 0 errors, 10 warnings, 120 lines checked
    
    Signed-off-by: Xianglong Du <Xianglong.Du@csr.com>
    Signed-off-by: Barry Song <Baohua.Song@csr.com>

diff --git a/arch/arm/mach-prima2/rstc.c b/arch/arm/mach-prima2/rstc.c
index 4887a2a4c698..3dffcb2d714e 100644
--- a/arch/arm/mach-prima2/rstc.c
+++ b/arch/arm/mach-prima2/rstc.c
@@ -36,27 +36,33 @@ static int sirfsoc_reset_module(struct reset_controller_dev *rcdev,
 
 	if (of_device_is_compatible(rcdev->of_node, "sirf,prima2-rstc")) {
 		/*
-		 * Writing 1 to this bit resets corresponding block. Writing 0 to this
-		 * bit de-asserts reset signal of the corresponding block.
-		 * datasheet doesn't require explicit delay between the set and clear
-		 * of reset bit. it could be shorter if tests pass.
+		 * Writing 1 to this bit resets corresponding block.
+		 * Writing 0 to this bit de-asserts reset signal of the
+		 * corresponding block. datasheet doesn't require explicit
+		 * delay between the set and clear of reset bit. it could
+		 * be shorter if tests pass.
 		 */
-		writel(readl(sirfsoc_rstc_base + (reset_bit / 32) * 4) | (1 << reset_bit),
+		writel(readl(sirfsoc_rstc_base +
+			(reset_bit / 32) * 4) | (1 << reset_bit),
 			sirfsoc_rstc_base + (reset_bit / 32) * 4);
-		msleep(10);
-		writel(readl(sirfsoc_rstc_base + (reset_bit / 32) * 4) & ~(1 << reset_bit),
+		msleep(20);
+		writel(readl(sirfsoc_rstc_base +
+			(reset_bit / 32) * 4) & ~(1 << reset_bit),
 			sirfsoc_rstc_base + (reset_bit / 32) * 4);
 	} else {
 		/*
 		 * For MARCO and POLO
-		 * Writing 1 to SET register resets corresponding block. Writing 1 to CLEAR
-		 * register de-asserts reset signal of the corresponding block.
-		 * datasheet doesn't require explicit delay between the set and clear
-		 * of reset bit. it could be shorter if tests pass.
+		 * Writing 1 to SET register resets corresponding block.
+		 * Writing 1 to CLEAR register de-asserts reset signal of the
+		 * corresponding block.
+		 * datasheet doesn't require explicit delay between the set and
+		 * clear of reset bit. it could be shorter if tests pass.
 		 */
-		writel(1 << reset_bit, sirfsoc_rstc_base + (reset_bit / 32) * 8);
-		msleep(10);
-		writel(1 << reset_bit, sirfsoc_rstc_base + (reset_bit / 32) * 8 + 4);
+		writel(1 << reset_bit,
+			sirfsoc_rstc_base + (reset_bit / 32) * 8);
+		msleep(20);
+		writel(1 << reset_bit,
+			sirfsoc_rstc_base + (reset_bit / 32) * 8 + 4);
 	}
 
 	mutex_unlock(&rstc_lock);

commit 48352e5286b455eaffed19a89d3a07e609bfa6d2
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Mar 11 10:53:31 2014 +0100

    ARM: prima2: build reset code standalone
    
    The prima2 platform code currently depends on the rstc
    implementation and that in turn depends on the reset
    controller framework. This removes the platform dependency
    by letting the driver access arm_pm_restart directly
    to turn the driver into a standalone entity, and also
    removes the dependency on the reset controller framework
    by using "if (IS_ENABLED(CONFIG_RESET_CONTROLLER))". This
    will cause all code that is used for the reset controller
    to be dropped by the compiler if the framework is disabled.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-prima2/rstc.c b/arch/arm/mach-prima2/rstc.c
index a59976743332..4887a2a4c698 100644
--- a/arch/arm/mach-prima2/rstc.c
+++ b/arch/arm/mach-prima2/rstc.c
@@ -17,9 +17,11 @@
 #include <linux/reboot.h>
 #include <linux/reset-controller.h>
 
+#include <asm/system_misc.h>
+
 #define SIRFSOC_RSTBIT_NUM	64
 
-void __iomem *sirfsoc_rstc_base;
+static void __iomem *sirfsoc_rstc_base;
 static DEFINE_MUTEX(rstc_lock);
 
 static int sirfsoc_reset_module(struct reset_controller_dev *rcdev,
@@ -71,6 +73,13 @@ static struct reset_controller_dev sirfsoc_reset_controller = {
 	.nr_resets = SIRFSOC_RSTBIT_NUM,
 };
 
+#define SIRFSOC_SYS_RST_BIT  BIT(31)
+
+static void sirfsoc_restart(enum reboot_mode mode, const char *cmd)
+{
+	writel(SIRFSOC_SYS_RST_BIT, sirfsoc_rstc_base);
+}
+
 static int sirfsoc_rstc_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
@@ -81,8 +90,10 @@ static int sirfsoc_rstc_probe(struct platform_device *pdev)
 	}
 
 	sirfsoc_reset_controller.of_node = np;
+	arm_pm_restart = sirfsoc_restart;
 
-	reset_controller_register(&sirfsoc_reset_controller);
+	if (IS_ENABLED(CONFIG_RESET_CONTROLLER))
+		reset_controller_register(&sirfsoc_reset_controller);
 
 	return 0;
 }
@@ -107,10 +118,3 @@ static int __init sirfsoc_rstc_init(void)
 	return platform_driver_register(&sirfsoc_rstc_driver);
 }
 subsys_initcall(sirfsoc_rstc_init);
-
-#define SIRFSOC_SYS_RST_BIT  BIT(31)
-
-void sirfsoc_restart(enum reboot_mode mode, const char *cmd)
-{
-	writel(SIRFSOC_SYS_RST_BIT, sirfsoc_rstc_base);
-}

commit e7eda91f6323bd7dc85598c639f5e4709efc2309
Author: Barry Song <Baohua.Song@csr.com>
Date:   Fri Jan 10 03:15:42 2014 +0000

    ARM: prima2: move to generic reset controller driver framework
    
    this moves to generic IP module reset framework, and make other drivers
    use common device_reset() API.
    
    Cc: Srinivas Kandagatla <srinivas.kandagatla@st.com>
    Signed-off-by: Barry Song <Baohua.Song@csr.com>
    Signed-off-by: Bin Shi <Bin.Shi@csr.com>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/arch/arm/mach-prima2/rstc.c b/arch/arm/mach-prima2/rstc.c
index ccb53391147a..a59976743332 100644
--- a/arch/arm/mach-prima2/rstc.c
+++ b/arch/arm/mach-prima2/rstc.c
@@ -13,57 +13,36 @@
 #include <linux/device.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
+#include <linux/platform_device.h>
 #include <linux/reboot.h>
+#include <linux/reset-controller.h>
+
+#define SIRFSOC_RSTBIT_NUM	64
 
 void __iomem *sirfsoc_rstc_base;
 static DEFINE_MUTEX(rstc_lock);
 
-static struct of_device_id rstc_ids[]  = {
-	{ .compatible = "sirf,prima2-rstc" },
-	{ .compatible = "sirf,marco-rstc" },
-	{},
-};
-
-static int __init sirfsoc_of_rstc_init(void)
-{
-	struct device_node *np;
-
-	np = of_find_matching_node(NULL, rstc_ids);
-	if (!np) {
-		pr_err("unable to find compatible sirf rstc node in dtb\n");
-		return -ENOENT;
-	}
-
-	sirfsoc_rstc_base = of_iomap(np, 0);
-	if (!sirfsoc_rstc_base)
-		panic("unable to map rstc cpu registers\n");
-
-	of_node_put(np);
-
-	return 0;
-}
-early_initcall(sirfsoc_of_rstc_init);
-
-int sirfsoc_reset_device(struct device *dev)
+static int sirfsoc_reset_module(struct reset_controller_dev *rcdev,
+					unsigned long sw_reset_idx)
 {
-	u32 reset_bit;
+	u32 reset_bit = sw_reset_idx;
 
-	if (of_property_read_u32(dev->of_node, "reset-bit", &reset_bit))
+	if (reset_bit >= SIRFSOC_RSTBIT_NUM)
 		return -EINVAL;
 
 	mutex_lock(&rstc_lock);
 
-	if (of_device_is_compatible(dev->of_node, "sirf,prima2-rstc")) {
+	if (of_device_is_compatible(rcdev->of_node, "sirf,prima2-rstc")) {
 		/*
 		 * Writing 1 to this bit resets corresponding block. Writing 0 to this
 		 * bit de-asserts reset signal of the corresponding block.
 		 * datasheet doesn't require explicit delay between the set and clear
 		 * of reset bit. it could be shorter if tests pass.
 		 */
-		writel(readl(sirfsoc_rstc_base + (reset_bit / 32) * 4) | reset_bit,
+		writel(readl(sirfsoc_rstc_base + (reset_bit / 32) * 4) | (1 << reset_bit),
 			sirfsoc_rstc_base + (reset_bit / 32) * 4);
 		msleep(10);
-		writel(readl(sirfsoc_rstc_base + (reset_bit / 32) * 4) & ~reset_bit,
+		writel(readl(sirfsoc_rstc_base + (reset_bit / 32) * 4) & ~(1 << reset_bit),
 			sirfsoc_rstc_base + (reset_bit / 32) * 4);
 	} else {
 		/*
@@ -73,9 +52,9 @@ int sirfsoc_reset_device(struct device *dev)
 		 * datasheet doesn't require explicit delay between the set and clear
 		 * of reset bit. it could be shorter if tests pass.
 		 */
-		writel(reset_bit, sirfsoc_rstc_base + (reset_bit / 32) * 8);
+		writel(1 << reset_bit, sirfsoc_rstc_base + (reset_bit / 32) * 8);
 		msleep(10);
-		writel(reset_bit, sirfsoc_rstc_base + (reset_bit / 32) * 8 + 4);
+		writel(1 << reset_bit, sirfsoc_rstc_base + (reset_bit / 32) * 8 + 4);
 	}
 
 	mutex_unlock(&rstc_lock);
@@ -83,6 +62,52 @@ int sirfsoc_reset_device(struct device *dev)
 	return 0;
 }
 
+static struct reset_control_ops sirfsoc_rstc_ops = {
+	.reset = sirfsoc_reset_module,
+};
+
+static struct reset_controller_dev sirfsoc_reset_controller = {
+	.ops = &sirfsoc_rstc_ops,
+	.nr_resets = SIRFSOC_RSTBIT_NUM,
+};
+
+static int sirfsoc_rstc_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	sirfsoc_rstc_base = of_iomap(np, 0);
+	if (!sirfsoc_rstc_base) {
+		dev_err(&pdev->dev, "unable to map rstc cpu registers\n");
+		return -ENOMEM;
+	}
+
+	sirfsoc_reset_controller.of_node = np;
+
+	reset_controller_register(&sirfsoc_reset_controller);
+
+	return 0;
+}
+
+static const struct of_device_id rstc_ids[]  = {
+	{ .compatible = "sirf,prima2-rstc" },
+	{ .compatible = "sirf,marco-rstc" },
+	{},
+};
+
+static struct platform_driver sirfsoc_rstc_driver = {
+	.probe		= sirfsoc_rstc_probe,
+	.driver		= {
+		.name	= "sirfsoc_rstc",
+		.owner	= THIS_MODULE,
+		.of_match_table = rstc_ids,
+	},
+};
+
+static int __init sirfsoc_rstc_init(void)
+{
+	return platform_driver_register(&sirfsoc_rstc_driver);
+}
+subsys_initcall(sirfsoc_rstc_init);
+
 #define SIRFSOC_SYS_RST_BIT  BIT(31)
 
 void sirfsoc_restart(enum reboot_mode mode, const char *cmd)

commit 7b6d864b48d95e6ea1df7df64475b9cb9616dcf9
Author: Robin Holt <holt@sgi.com>
Date:   Mon Jul 8 16:01:40 2013 -0700

    reboot: arm: change reboot_mode to use enum reboot_mode
    
    Preparing to move the parsing of reboot= to generic kernel code forces
    the change in reboot_mode handling to use the enum.
    
    [akpm@linux-foundation.org: fix arch/arm/mach-socfpga/socfpga.c]
    Signed-off-by: Robin Holt <holt@sgi.com>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Russ Anderson <rja@sgi.com>
    Cc: Robin Holt <holt@sgi.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-prima2/rstc.c b/arch/arm/mach-prima2/rstc.c
index d5e0cbc934c0..ccb53391147a 100644
--- a/arch/arm/mach-prima2/rstc.c
+++ b/arch/arm/mach-prima2/rstc.c
@@ -13,6 +13,7 @@
 #include <linux/device.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
+#include <linux/reboot.h>
 
 void __iomem *sirfsoc_rstc_base;
 static DEFINE_MUTEX(rstc_lock);
@@ -84,7 +85,7 @@ int sirfsoc_reset_device(struct device *dev)
 
 #define SIRFSOC_SYS_RST_BIT  BIT(31)
 
-void sirfsoc_restart(char mode, const char *cmd)
+void sirfsoc_restart(enum reboot_mode mode, const char *cmd)
 {
 	writel(SIRFSOC_SYS_RST_BIT, sirfsoc_rstc_base);
 }

commit 7e5955db458b2d349a8180242afebc78a13ed023
Author: Haojian Zhuang <haojian.zhuang@linaro.org>
Date:   Fri Jun 7 11:17:07 2013 +0800

    ARM: prima2: fix incorrect panic usage
    
    In prima2, some functions of checking DT is registered in initcall
    level. If it doesn't match the compatible name of sirf, kernel
    will panic. It blocks the usage of multiplatform on other verndor.
    
    The error message is in below.
    
    Knic - not syncing: unable to find compatible pwrc node in dtb
    CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.10.0-rc3-00006-gd7f26ea-dirty #86
    [<c0013adc>] (unwind_backtrace+0x0/0xf8) from [<c0011430>] (show_stack+0x10/0x1)
    [<c0011430>] (show_stack+0x10/0x14) from [<c026f724>] (panic+0x90/0x1e8)
    [<c026f724>] (panic+0x90/0x1e8) from [<c03267fc>] (sirfsoc_of_pwrc_init+0x24/0x)
    [<c03267fc>] (sirfsoc_of_pwrc_init+0x24/0x58) from [<c0320864>] (do_one_initcal)
    [<c0320864>] (do_one_initcall+0x90/0x150) from [<c0320a20>] (kernel_init_freeab)
    [<c0320a20>] (kernel_init_freeable+0xfc/0x1c4) from [<c026b9e8>] (kernel_init+0)
    [<c026b9e8>] (kernel_init+0x8/0xe4) from [<c000e158>] (ret_from_fork+0x14/0x3c)
    
    Signen-off-by: Haojian Zhuang <haojian.zhuang@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-prima2/rstc.c b/arch/arm/mach-prima2/rstc.c
index 435019ca0a48..d5e0cbc934c0 100644
--- a/arch/arm/mach-prima2/rstc.c
+++ b/arch/arm/mach-prima2/rstc.c
@@ -28,8 +28,10 @@ static int __init sirfsoc_of_rstc_init(void)
 	struct device_node *np;
 
 	np = of_find_matching_node(NULL, rstc_ids);
-	if (!np)
-		panic("unable to find compatible rstc node in dtb\n");
+	if (!np) {
+		pr_err("unable to find compatible sirf rstc node in dtb\n");
+		return -ENOENT;
+	}
 
 	sirfsoc_rstc_base = of_iomap(np, 0);
 	if (!sirfsoc_rstc_base)

commit 0ecb40ca35b093aa38f8b94069b6cbd3c7a25831
Author: Barry Song <Baohua.Song@csr.com>
Date:   Thu Dec 20 17:40:47 2012 +0800

    ARM: PRIMA2: rstc: enable the support for Marco
    
    marco has SET/CLEAR registers pair for rstc to avoid read-modify-write,
    this patch detects the mach typer and access registers based on SoC.
    
    Signed-off-by: Barry Song <Baohua.Song@csr.com>

diff --git a/arch/arm/mach-prima2/rstc.c b/arch/arm/mach-prima2/rstc.c
index 762adb73ab7c..435019ca0a48 100644
--- a/arch/arm/mach-prima2/rstc.c
+++ b/arch/arm/mach-prima2/rstc.c
@@ -19,6 +19,7 @@ static DEFINE_MUTEX(rstc_lock);
 
 static struct of_device_id rstc_ids[]  = {
 	{ .compatible = "sirf,prima2-rstc" },
+	{ .compatible = "sirf,marco-rstc" },
 	{},
 };
 
@@ -42,27 +43,37 @@ early_initcall(sirfsoc_of_rstc_init);
 
 int sirfsoc_reset_device(struct device *dev)
 {
-	const unsigned int *prop = of_get_property(dev->of_node, "reset-bit", NULL);
-	unsigned int reset_bit;
+	u32 reset_bit;
 
-	if (!prop)
-		return -ENODEV;
-
-	reset_bit = be32_to_cpup(prop);
+	if (of_property_read_u32(dev->of_node, "reset-bit", &reset_bit))
+		return -EINVAL;
 
 	mutex_lock(&rstc_lock);
 
-	/*
-	 * Writing 1 to this bit resets corresponding block. Writing 0 to this
-	 * bit de-asserts reset signal of the corresponding block.
-	 * datasheet doesn't require explicit delay between the set and clear
-	 * of reset bit. it could be shorter if tests pass.
-	 */
-	writel(readl(sirfsoc_rstc_base + (reset_bit / 32) * 4) | reset_bit,
-		sirfsoc_rstc_base + (reset_bit / 32) * 4);
-	msleep(10);
-	writel(readl(sirfsoc_rstc_base + (reset_bit / 32) * 4) & ~reset_bit,
-		sirfsoc_rstc_base + (reset_bit / 32) * 4);
+	if (of_device_is_compatible(dev->of_node, "sirf,prima2-rstc")) {
+		/*
+		 * Writing 1 to this bit resets corresponding block. Writing 0 to this
+		 * bit de-asserts reset signal of the corresponding block.
+		 * datasheet doesn't require explicit delay between the set and clear
+		 * of reset bit. it could be shorter if tests pass.
+		 */
+		writel(readl(sirfsoc_rstc_base + (reset_bit / 32) * 4) | reset_bit,
+			sirfsoc_rstc_base + (reset_bit / 32) * 4);
+		msleep(10);
+		writel(readl(sirfsoc_rstc_base + (reset_bit / 32) * 4) & ~reset_bit,
+			sirfsoc_rstc_base + (reset_bit / 32) * 4);
+	} else {
+		/*
+		 * For MARCO and POLO
+		 * Writing 1 to SET register resets corresponding block. Writing 1 to CLEAR
+		 * register de-asserts reset signal of the corresponding block.
+		 * datasheet doesn't require explicit delay between the set and clear
+		 * of reset bit. it could be shorter if tests pass.
+		 */
+		writel(reset_bit, sirfsoc_rstc_base + (reset_bit / 32) * 8);
+		msleep(10);
+		writel(reset_bit, sirfsoc_rstc_base + (reset_bit / 32) * 8 + 4);
+	}
 
 	mutex_unlock(&rstc_lock);
 

commit 125c4033f0187d7264f08d7cf1474252df4f4c17
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Nov 5 10:23:27 2011 +0000

    ARM: restart: prima2: use new restart hook
    
    Hook these platforms restart code into the new restart hook rather
    than using arch_reset().
    
    Reviewed-by: Barry Song <Baohua.Song@csr.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-prima2/rstc.c b/arch/arm/mach-prima2/rstc.c
index 492cfa8d2610..762adb73ab7c 100644
--- a/arch/arm/mach-prima2/rstc.c
+++ b/arch/arm/mach-prima2/rstc.c
@@ -68,3 +68,10 @@ int sirfsoc_reset_device(struct device *dev)
 
 	return 0;
 }
+
+#define SIRFSOC_SYS_RST_BIT  BIT(31)
+
+void sirfsoc_restart(char mode, const char *cmd)
+{
+	writel(SIRFSOC_SYS_RST_BIT, sirfsoc_rstc_base);
+}

commit 6a53747be5f02ba7b37ff5131330363270782dc3
Author: Jamie Iles <jamie@jamieiles.com>
Date:   Mon Aug 1 21:09:36 2011 +0100

    ARM: CSR: add missing sentinels to of_device_id tables
    
    The of_device_id tables used for matching should be terminated with
    empty sentinel values.
    
    Signed-off-by: Jamie Iles <jamie@jamieiles.com>
    Signed-off-by: Barry Song <baohua.song@csr.com>

diff --git a/arch/arm/mach-prima2/rstc.c b/arch/arm/mach-prima2/rstc.c
index d074786e83d4..492cfa8d2610 100644
--- a/arch/arm/mach-prima2/rstc.c
+++ b/arch/arm/mach-prima2/rstc.c
@@ -19,6 +19,7 @@ static DEFINE_MUTEX(rstc_lock);
 
 static struct of_device_id rstc_ids[]  = {
 	{ .compatible = "sirf,prima2-rstc" },
+	{},
 };
 
 static int __init sirfsoc_of_rstc_init(void)

commit 02c981c07bc95ac1e42ec6c817f0c28cf3fe993a
Author: Binghua Duan <binghua.duan@csr.com>
Date:   Fri Jul 8 17:40:12 2011 +0800

    ARM: CSR: Adding CSR SiRFprimaII board support
    
    SiRFprimaII is the latest generation application processor from CSRâ€™s
    Multifunction SoC product family. Designed around an ARM cortex A9 core,
    high-speed memory bus, advanced 3D accelerator and full-HD multi-format
    video decoder, SiRFprimaII is able to meet the needs of complicated
    applications for modern multifunction devices that require heavy concurrent
    applications and fluid user experience. Integrated with GPS baseband,
    analog and PMU, this new platform is designed to provide a cost effective
    solution for Automotive and Consumer markets.
    
    This patch adds the basic support for this SoC and EVB board based on device
    tree. It is following the ZYNQ of Xilinx in some degree.
    
    Signed-off-by: Binghua Duan <Binghua.Duan@csr.com>
    Signed-off-by: Rongjun Ying <Rongjun.Ying@csr.com>
    Signed-off-by: Zhiwu Song <Zhiwu.Song@csr.com>
    Signed-off-by: Yuping Luo <Yuping.Luo@csr.com>
    Signed-off-by: Bin Shi <Bin.Shi@csr.com>
    Signed-off-by: Huayi Li <Huayi.Li@csr.com>
    Signed-off-by: Barry Song <Baohua.Song@csr.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-prima2/rstc.c b/arch/arm/mach-prima2/rstc.c
new file mode 100644
index 000000000000..d074786e83d4
--- /dev/null
+++ b/arch/arm/mach-prima2/rstc.c
@@ -0,0 +1,69 @@
+/*
+ * reset controller for CSR SiRFprimaII
+ *
+ * Copyright (c) 2011 Cambridge Silicon Radio Limited, a CSR plc group company.
+ *
+ * Licensed under GPLv2 or later.
+ */
+
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+
+void __iomem *sirfsoc_rstc_base;
+static DEFINE_MUTEX(rstc_lock);
+
+static struct of_device_id rstc_ids[]  = {
+	{ .compatible = "sirf,prima2-rstc" },
+};
+
+static int __init sirfsoc_of_rstc_init(void)
+{
+	struct device_node *np;
+
+	np = of_find_matching_node(NULL, rstc_ids);
+	if (!np)
+		panic("unable to find compatible rstc node in dtb\n");
+
+	sirfsoc_rstc_base = of_iomap(np, 0);
+	if (!sirfsoc_rstc_base)
+		panic("unable to map rstc cpu registers\n");
+
+	of_node_put(np);
+
+	return 0;
+}
+early_initcall(sirfsoc_of_rstc_init);
+
+int sirfsoc_reset_device(struct device *dev)
+{
+	const unsigned int *prop = of_get_property(dev->of_node, "reset-bit", NULL);
+	unsigned int reset_bit;
+
+	if (!prop)
+		return -ENODEV;
+
+	reset_bit = be32_to_cpup(prop);
+
+	mutex_lock(&rstc_lock);
+
+	/*
+	 * Writing 1 to this bit resets corresponding block. Writing 0 to this
+	 * bit de-asserts reset signal of the corresponding block.
+	 * datasheet doesn't require explicit delay between the set and clear
+	 * of reset bit. it could be shorter if tests pass.
+	 */
+	writel(readl(sirfsoc_rstc_base + (reset_bit / 32) * 4) | reset_bit,
+		sirfsoc_rstc_base + (reset_bit / 32) * 4);
+	msleep(10);
+	writel(readl(sirfsoc_rstc_base + (reset_bit / 32) * 4) & ~reset_bit,
+		sirfsoc_rstc_base + (reset_bit / 32) * 4);
+
+	mutex_unlock(&rstc_lock);
+
+	return 0;
+}
