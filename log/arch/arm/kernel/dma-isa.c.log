commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/kernel/dma-isa.c b/arch/arm/kernel/dma-isa.c
index 10c45cc6b957..2d90ecce5a11 100644
--- a/arch/arm/kernel/dma-isa.c
+++ b/arch/arm/kernel/dma-isa.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  linux/arch/arm/kernel/dma-isa.c
  *
  *  Copyright (C) 1999-2000 Russell King
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  *  ISA DMA primitives
  *  Taken from various sources, including:
  *   linux/include/asm/dma.h: Defines for using and allocating dma channels.

commit 5ab6a91a1cacd827382897a80425df8a2d27744a
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Dec 21 14:56:38 2018 +0100

    arm: use a dummy struct device for ISA DMA use of the DMA API
    
    This gets rid of the last NULL dev argument passed to the DMA API.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/arch/arm/kernel/dma-isa.c b/arch/arm/kernel/dma-isa.c
index 84363fe7bad2..10c45cc6b957 100644
--- a/arch/arm/kernel/dma-isa.c
+++ b/arch/arm/kernel/dma-isa.c
@@ -55,6 +55,12 @@ static int isa_get_dma_residue(unsigned int chan, dma_t *dma)
 	return chan < 4 ? count : (count << 1);
 }
 
+static struct device isa_dma_dev = {
+	.init_name		= "fallback device",
+	.coherent_dma_mask	= ~(dma_addr_t)0,
+	.dma_mask		= &isa_dma_dev.coherent_dma_mask,
+};
+
 static void isa_enable_dma(unsigned int chan, dma_t *dma)
 {
 	if (dma->invalid) {
@@ -89,7 +95,7 @@ static void isa_enable_dma(unsigned int chan, dma_t *dma)
 			dma->sg = &dma->buf;
 			dma->sgcount = 1;
 			dma->buf.length = dma->count;
-			dma->buf.dma_address = dma_map_single(NULL,
+			dma->buf.dma_address = dma_map_single(&isa_dma_dev,
 				dma->addr, dma->count,
 				direction);
 		}

commit 4ed89f2228061422ce5f62545fd0b6f6648bd2cc
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Oct 28 11:26:42 2014 +0000

    ARM: convert printk(KERN_* to pr_*
    
    Convert many (but not all) printk(KERN_* to pr_* to simplify the code.
    We take the opportunity to join some printk lines together so we don't
    split the message across several lines, and we also add a few levels
    to some messages which were previously missing them.
    
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Tested-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma-isa.c b/arch/arm/kernel/dma-isa.c
index 360bb6d701f5..84363fe7bad2 100644
--- a/arch/arm/kernel/dma-isa.c
+++ b/arch/arm/kernel/dma-isa.c
@@ -213,8 +213,8 @@ void __init isa_init_dma(void)
 		for (chan = 0; chan < 8; chan++) {
 			int ret = isa_dma_add(chan, &isa_dma[chan]);
 			if (ret)
-				printk(KERN_ERR "ISADMA%u: unable to register: %d\n",
-					chan, ret);
+				pr_err("ISADMA%u: unable to register: %d\n",
+				       chan, ret);
 		}
 
 		request_dma(DMA_ISA_CASCADE, "cascade");

commit e8b8f5ef90b934bc9eaef7c8960ecd9dda9f7a62
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Dec 24 14:45:39 2009 +0000

    ARM: dma-isa: request cascade channel after registering it
    
    We can't request the cascade channel before it's been registered, so
    move it afterwards.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma-isa.c b/arch/arm/kernel/dma-isa.c
index 0e88e46fc732..360bb6d701f5 100644
--- a/arch/arm/kernel/dma-isa.c
+++ b/arch/arm/kernel/dma-isa.c
@@ -207,8 +207,6 @@ void __init isa_init_dma(void)
 		outb(0x32, 0x4d6);
 		outb(0x33, 0x4d6);
 
-		request_dma(DMA_ISA_CASCADE, "cascade");
-
 		for (i = 0; i < ARRAY_SIZE(dma_resources); i++)
 			request_resource(&ioport_resource, dma_resources + i);
 
@@ -218,5 +216,7 @@ void __init isa_init_dma(void)
 				printk(KERN_ERR "ISADMA%u: unable to register: %d\n",
 					chan, ret);
 		}
+
+		request_dma(DMA_ISA_CASCADE, "cascade");
 	}
 }

commit bc6447b8e4fdb3306ee6381df9650a1a8aa57c5b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Jan 2 12:18:53 2009 +0000

    [ARM] dma: make DMA_MODE_xxx reflect ISA DMA settings
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma-isa.c b/arch/arm/kernel/dma-isa.c
index da02a7ff3419..0e88e46fc732 100644
--- a/arch/arm/kernel/dma-isa.c
+++ b/arch/arm/kernel/dma-isa.c
@@ -24,11 +24,6 @@
 #include <asm/dma.h>
 #include <asm/mach/dma.h>
 
-#define ISA_DMA_MODE_READ	0x44
-#define ISA_DMA_MODE_WRITE	0x48
-#define ISA_DMA_MODE_CASCADE	0xc0
-#define ISA_DMA_AUTOINIT	0x10
-
 #define ISA_DMA_MASK		0
 #define ISA_DMA_MODE		1
 #define ISA_DMA_CLRFF		2
@@ -67,20 +62,17 @@ static void isa_enable_dma(unsigned int chan, dma_t *dma)
 		unsigned int mode;
 		enum dma_data_direction direction;
 
-		mode = chan & 3;
+		mode = (chan & 3) | dma->dma_mode;
 		switch (dma->dma_mode & DMA_MODE_MASK) {
 		case DMA_MODE_READ:
-			mode |= ISA_DMA_MODE_READ;
 			direction = DMA_FROM_DEVICE;
 			break;
 
 		case DMA_MODE_WRITE:
-			mode |= ISA_DMA_MODE_WRITE;
 			direction = DMA_TO_DEVICE;
 			break;
 
 		case DMA_MODE_CASCADE:
-			mode |= ISA_DMA_MODE_CASCADE;
 			direction = DMA_BIDIRECTIONAL;
 			break;
 
@@ -121,9 +113,6 @@ static void isa_enable_dma(unsigned int chan, dma_t *dma)
 		outb(length, isa_dma_port[chan][ISA_DMA_COUNT]);
 		outb(length >> 8, isa_dma_port[chan][ISA_DMA_COUNT]);
 
-		if (dma->dma_mode & DMA_AUTOINIT)
-			mode |= ISA_DMA_AUTOINIT;
-
 		outb(mode, isa_dma_port[chan][ISA_DMA_MODE]);
 		dma->invalid = 0;
 	}

commit 2f757f2ab7411cf0e2779012d8cda0cbf2f80d26
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Dec 8 16:33:30 2008 +0000

    [ARM] dma: rejig DMA initialization
    
    Rather than having the central DMA multiplexer call the architecture
    specific DMA initialization function, have each architecture DMA
    initialization function use core_initcall(), and register each DMA
    channel separately with the multiplexer.
    
    This removes the array of dma structures in the central multiplexer,
    replacing it with an array of pointers instead; this is more flexible
    since it allows the drivers to wrap the DMA structure (eventually
    allowing us to transition non-ISA DMA drivers away.)
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma-isa.c b/arch/arm/kernel/dma-isa.c
index 29eca48925d8..da02a7ff3419 100644
--- a/arch/arm/kernel/dma-isa.c
+++ b/arch/arm/kernel/dma-isa.c
@@ -160,7 +160,12 @@ static struct resource dma_resources[] = { {
 	.end	= 0x048f
 } };
 
-void __init isa_init_dma(dma_t *dma)
+static dma_t isa_dma[8];
+
+/*
+ * ISA DMA always starts at channel 0
+ */
+void __init isa_init_dma(void)
 {
 	/*
 	 * Try to autodetect presence of an ISA DMA controller.
@@ -178,10 +183,10 @@ void __init isa_init_dma(dma_t *dma)
 	outb(0xaa, 0x00);
 
 	if (inb(0) == 0x55 && inb(0) == 0xaa) {
-		int chan, i;
+		unsigned int chan, i;
 
 		for (chan = 0; chan < 8; chan++) {
-			dma[chan].d_ops = &isa_dma_ops;
+			isa_dma[chan].d_ops = &isa_dma_ops;
 			isa_disable_dma(chan, NULL);
 		}
 
@@ -217,5 +222,12 @@ void __init isa_init_dma(dma_t *dma)
 
 		for (i = 0; i < ARRAY_SIZE(dma_resources); i++)
 			request_resource(&ioport_resource, dma_resources + i);
+
+		for (chan = 0; chan < 8; chan++) {
+			int ret = isa_dma_add(chan, &isa_dma[chan]);
+			if (ret)
+				printk(KERN_ERR "ISADMA%u: unable to register: %d\n",
+					chan, ret);
+		}
 	}
 }

commit 1df8130278c4543555fea697e5714fbac300b899
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Dec 8 15:58:50 2008 +0000

    [ARM] dma: remove dmach_t typedef
    
    Remove a pointless integer typedef.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma-isa.c b/arch/arm/kernel/dma-isa.c
index 4a3a50495c60..29eca48925d8 100644
--- a/arch/arm/kernel/dma-isa.c
+++ b/arch/arm/kernel/dma-isa.c
@@ -49,25 +49,25 @@ static unsigned int isa_dma_port[8][7] = {
 	{  0xd4,  0xd6,  0xd8,  0x48a,  0x08a,  0xcc, 0xce }
 };
 
-static int isa_get_dma_residue(dmach_t channel, dma_t *dma)
+static int isa_get_dma_residue(unsigned int chan, dma_t *dma)
 {
-	unsigned int io_port = isa_dma_port[channel][ISA_DMA_COUNT];
+	unsigned int io_port = isa_dma_port[chan][ISA_DMA_COUNT];
 	int count;
 
 	count = 1 + inb(io_port);
 	count |= inb(io_port) << 8;
 
-	return channel < 4 ? count : (count << 1);
+	return chan < 4 ? count : (count << 1);
 }
 
-static void isa_enable_dma(dmach_t channel, dma_t *dma)
+static void isa_enable_dma(unsigned int chan, dma_t *dma)
 {
 	if (dma->invalid) {
 		unsigned long address, length;
 		unsigned int mode;
 		enum dma_data_direction direction;
 
-		mode = channel & 3;
+		mode = chan & 3;
 		switch (dma->dma_mode & DMA_MODE_MASK) {
 		case DMA_MODE_READ:
 			mode |= ISA_DMA_MODE_READ;
@@ -105,34 +105,34 @@ static void isa_enable_dma(dmach_t channel, dma_t *dma)
 		address = dma->buf.dma_address;
 		length  = dma->buf.length - 1;
 
-		outb(address >> 16, isa_dma_port[channel][ISA_DMA_PGLO]);
-		outb(address >> 24, isa_dma_port[channel][ISA_DMA_PGHI]);
+		outb(address >> 16, isa_dma_port[chan][ISA_DMA_PGLO]);
+		outb(address >> 24, isa_dma_port[chan][ISA_DMA_PGHI]);
 
-		if (channel >= 4) {
+		if (chan >= 4) {
 			address >>= 1;
 			length >>= 1;
 		}
 
-		outb(0, isa_dma_port[channel][ISA_DMA_CLRFF]);
+		outb(0, isa_dma_port[chan][ISA_DMA_CLRFF]);
 
-		outb(address, isa_dma_port[channel][ISA_DMA_ADDR]);
-		outb(address >> 8, isa_dma_port[channel][ISA_DMA_ADDR]);
+		outb(address, isa_dma_port[chan][ISA_DMA_ADDR]);
+		outb(address >> 8, isa_dma_port[chan][ISA_DMA_ADDR]);
 
-		outb(length, isa_dma_port[channel][ISA_DMA_COUNT]);
-		outb(length >> 8, isa_dma_port[channel][ISA_DMA_COUNT]);
+		outb(length, isa_dma_port[chan][ISA_DMA_COUNT]);
+		outb(length >> 8, isa_dma_port[chan][ISA_DMA_COUNT]);
 
 		if (dma->dma_mode & DMA_AUTOINIT)
 			mode |= ISA_DMA_AUTOINIT;
 
-		outb(mode, isa_dma_port[channel][ISA_DMA_MODE]);
+		outb(mode, isa_dma_port[chan][ISA_DMA_MODE]);
 		dma->invalid = 0;
 	}
-	outb(channel & 3, isa_dma_port[channel][ISA_DMA_MASK]);
+	outb(chan & 3, isa_dma_port[chan][ISA_DMA_MASK]);
 }
 
-static void isa_disable_dma(dmach_t channel, dma_t *dma)
+static void isa_disable_dma(unsigned int chan, dma_t *dma)
 {
-	outb(channel | 4, isa_dma_port[channel][ISA_DMA_MASK]);
+	outb(chan | 4, isa_dma_port[chan][ISA_DMA_MASK]);
 }
 
 static struct dma_ops isa_dma_ops = {
@@ -178,11 +178,11 @@ void __init isa_init_dma(dma_t *dma)
 	outb(0xaa, 0x00);
 
 	if (inb(0) == 0x55 && inb(0) == 0xaa) {
-		int channel, i;
+		int chan, i;
 
-		for (channel = 0; channel < 8; channel++) {
-			dma[channel].d_ops = &isa_dma_ops;
-			isa_disable_dma(channel, NULL);
+		for (chan = 0; chan < 8; chan++) {
+			dma[chan].d_ops = &isa_dma_ops;
+			isa_disable_dma(chan, NULL);
 		}
 
 		outb(0x40, 0x0b);

commit fced80c735941fa518ac67c0b61bbe153fb8c050
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Sep 6 12:10:45 2008 +0100

    [ARM] Convert asm/io.h to linux/io.h
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma-isa.c b/arch/arm/kernel/dma-isa.c
index 2f080a35a2d9..4a3a50495c60 100644
--- a/arch/arm/kernel/dma-isa.c
+++ b/arch/arm/kernel/dma-isa.c
@@ -19,10 +19,9 @@
 #include <linux/ioport.h>
 #include <linux/init.h>
 #include <linux/dma-mapping.h>
+#include <linux/io.h>
 
 #include <asm/dma.h>
-#include <asm/io.h>
-
 #include <asm/mach/dma.h>
 
 #define ISA_DMA_MODE_READ	0x44

commit df1a29032060680d258689448dca37bb003c4c2c
Author: Alejandro Martinez Ruiz <alex@flawedcode.org>
Date:   Wed Oct 17 12:14:25 2007 +0200

    [ARM] ARRAY_SIZE() cleanup
    
    Signed-off-by: Alejandro Martinez Ruiz <alex@flawedcode.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma-isa.c b/arch/arm/kernel/dma-isa.c
index 0a3e9ad297d8..2f080a35a2d9 100644
--- a/arch/arm/kernel/dma-isa.c
+++ b/arch/arm/kernel/dma-isa.c
@@ -216,7 +216,7 @@ void __init isa_init_dma(dma_t *dma)
 
 		request_dma(DMA_ISA_CASCADE, "cascade");
 
-		for (i = 0; i < sizeof(dma_resources) / sizeof(dma_resources[0]); i++)
+		for (i = 0; i < ARRAY_SIZE(dma_resources); i++)
 			request_resource(&ioport_resource, dma_resources + i);
 	}
 }

commit 3170a5e80be7db29ab5ccb6b4145cf28b4a156de
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue May 16 22:09:46 2006 +0100

    [ARM] arch/arm/kernel/dma-isa.c: named initializers
    
    This patch converts struct dma_resources to named initializers.
    
    Besides fixing a compile error in -mm, it didn't sound like a bad idea.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Acked-by: Alexander Schulz <alex@shark-linux.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma-isa.c b/arch/arm/kernel/dma-isa.c
index 03532769a97f..0a3e9ad297d8 100644
--- a/arch/arm/kernel/dma-isa.c
+++ b/arch/arm/kernel/dma-isa.c
@@ -143,12 +143,23 @@ static struct dma_ops isa_dma_ops = {
 	.residue	= isa_get_dma_residue,
 };
 
-static struct resource dma_resources[] = {
-	{ "dma1",		0x0000, 0x000f },
-	{ "dma low page", 	0x0080, 0x008f },
-	{ "dma2",		0x00c0, 0x00df },
-	{ "dma high page",	0x0480, 0x048f }
-};
+static struct resource dma_resources[] = { {
+	.name	= "dma1",
+	.start	= 0x0000,
+	.end	= 0x000f
+}, {
+	.name	= "dma low page",
+	.start	= 0x0080,
+	.end 	= 0x008f
+}, {
+	.name	= "dma2",
+	.start	= 0x00c0,
+	.end	= 0x00df
+}, {
+	.name	= "dma high page",
+	.start	= 0x0480,
+	.end	= 0x048f
+} };
 
 void __init isa_init_dma(dma_t *dma)
 {

commit 7cdad482974792419cfe4b0affca689170116f49
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Jan 4 15:08:30 2006 +0000

    [ARM] Remove '__address' from scatterlist and convert to DMA API
    
    The old __address element in struct scatterlist remained from older
    kernels because the ARM DMA emulation code made use of it.  Move
    this field into struct dma_struct, and convert DMA emulation code
    to setup a SG entry as required.
    
    Also, convert DMA emulation code to use the new DMA API rather
    than the PCI DMA API.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma-isa.c b/arch/arm/kernel/dma-isa.c
index e9a36304ec3e..03532769a97f 100644
--- a/arch/arm/kernel/dma-isa.c
+++ b/arch/arm/kernel/dma-isa.c
@@ -18,7 +18,7 @@
  */
 #include <linux/ioport.h>
 #include <linux/init.h>
-#include <linux/pci.h>
+#include <linux/dma-mapping.h>
 
 #include <asm/dma.h>
 #include <asm/io.h>
@@ -65,37 +65,41 @@ static void isa_enable_dma(dmach_t channel, dma_t *dma)
 {
 	if (dma->invalid) {
 		unsigned long address, length;
-		unsigned int mode, direction;
+		unsigned int mode;
+		enum dma_data_direction direction;
 
 		mode = channel & 3;
 		switch (dma->dma_mode & DMA_MODE_MASK) {
 		case DMA_MODE_READ:
 			mode |= ISA_DMA_MODE_READ;
-			direction = PCI_DMA_FROMDEVICE;
+			direction = DMA_FROM_DEVICE;
 			break;
 
 		case DMA_MODE_WRITE:
 			mode |= ISA_DMA_MODE_WRITE;
-			direction = PCI_DMA_TODEVICE;
+			direction = DMA_TO_DEVICE;
 			break;
 
 		case DMA_MODE_CASCADE:
 			mode |= ISA_DMA_MODE_CASCADE;
-			direction = PCI_DMA_BIDIRECTIONAL;
+			direction = DMA_BIDIRECTIONAL;
 			break;
 
 		default:
-			direction = PCI_DMA_NONE;
+			direction = DMA_NONE;
 			break;
 		}
 
-		if (!dma->using_sg) {
+		if (!dma->sg) {
 			/*
 			 * Cope with ISA-style drivers which expect cache
 			 * coherence.
 			 */
-			dma->buf.dma_address = pci_map_single(NULL,
-				dma->buf.__address, dma->buf.length,
+			dma->sg = &dma->buf;
+			dma->sgcount = 1;
+			dma->buf.length = dma->count;
+			dma->buf.dma_address = dma_map_single(NULL,
+				dma->addr, dma->count,
 				direction);
 		}
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/arm/kernel/dma-isa.c b/arch/arm/kernel/dma-isa.c
new file mode 100644
index 000000000000..e9a36304ec3e
--- /dev/null
+++ b/arch/arm/kernel/dma-isa.c
@@ -0,0 +1,207 @@
+/*
+ *  linux/arch/arm/kernel/dma-isa.c
+ *
+ *  Copyright (C) 1999-2000 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  ISA DMA primitives
+ *  Taken from various sources, including:
+ *   linux/include/asm/dma.h: Defines for using and allocating dma channels.
+ *     Written by Hennus Bergman, 1992.
+ *     High DMA channel support & info by Hannu Savolainen and John Boyd,
+ *     Nov. 1992.
+ *   arch/arm/kernel/dma-ebsa285.c
+ *   Copyright (C) 1998 Phil Blundell
+ */
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+
+#include <asm/dma.h>
+#include <asm/io.h>
+
+#include <asm/mach/dma.h>
+
+#define ISA_DMA_MODE_READ	0x44
+#define ISA_DMA_MODE_WRITE	0x48
+#define ISA_DMA_MODE_CASCADE	0xc0
+#define ISA_DMA_AUTOINIT	0x10
+
+#define ISA_DMA_MASK		0
+#define ISA_DMA_MODE		1
+#define ISA_DMA_CLRFF		2
+#define ISA_DMA_PGHI		3
+#define ISA_DMA_PGLO		4
+#define ISA_DMA_ADDR		5
+#define ISA_DMA_COUNT		6
+
+static unsigned int isa_dma_port[8][7] = {
+	/* MASK   MODE   CLRFF  PAGE_HI PAGE_LO ADDR COUNT */
+	{  0x0a,  0x0b,  0x0c,  0x487,  0x087,  0x00, 0x01 },
+	{  0x0a,  0x0b,  0x0c,  0x483,  0x083,  0x02, 0x03 },
+	{  0x0a,  0x0b,  0x0c,  0x481,  0x081,  0x04, 0x05 },
+	{  0x0a,  0x0b,  0x0c,  0x482,  0x082,  0x06, 0x07 },
+	{  0xd4,  0xd6,  0xd8,  0x000,  0x000,  0xc0, 0xc2 },
+	{  0xd4,  0xd6,  0xd8,  0x48b,  0x08b,  0xc4, 0xc6 },
+	{  0xd4,  0xd6,  0xd8,  0x489,  0x089,  0xc8, 0xca },
+	{  0xd4,  0xd6,  0xd8,  0x48a,  0x08a,  0xcc, 0xce }
+};
+
+static int isa_get_dma_residue(dmach_t channel, dma_t *dma)
+{
+	unsigned int io_port = isa_dma_port[channel][ISA_DMA_COUNT];
+	int count;
+
+	count = 1 + inb(io_port);
+	count |= inb(io_port) << 8;
+
+	return channel < 4 ? count : (count << 1);
+}
+
+static void isa_enable_dma(dmach_t channel, dma_t *dma)
+{
+	if (dma->invalid) {
+		unsigned long address, length;
+		unsigned int mode, direction;
+
+		mode = channel & 3;
+		switch (dma->dma_mode & DMA_MODE_MASK) {
+		case DMA_MODE_READ:
+			mode |= ISA_DMA_MODE_READ;
+			direction = PCI_DMA_FROMDEVICE;
+			break;
+
+		case DMA_MODE_WRITE:
+			mode |= ISA_DMA_MODE_WRITE;
+			direction = PCI_DMA_TODEVICE;
+			break;
+
+		case DMA_MODE_CASCADE:
+			mode |= ISA_DMA_MODE_CASCADE;
+			direction = PCI_DMA_BIDIRECTIONAL;
+			break;
+
+		default:
+			direction = PCI_DMA_NONE;
+			break;
+		}
+
+		if (!dma->using_sg) {
+			/*
+			 * Cope with ISA-style drivers which expect cache
+			 * coherence.
+			 */
+			dma->buf.dma_address = pci_map_single(NULL,
+				dma->buf.__address, dma->buf.length,
+				direction);
+		}
+
+		address = dma->buf.dma_address;
+		length  = dma->buf.length - 1;
+
+		outb(address >> 16, isa_dma_port[channel][ISA_DMA_PGLO]);
+		outb(address >> 24, isa_dma_port[channel][ISA_DMA_PGHI]);
+
+		if (channel >= 4) {
+			address >>= 1;
+			length >>= 1;
+		}
+
+		outb(0, isa_dma_port[channel][ISA_DMA_CLRFF]);
+
+		outb(address, isa_dma_port[channel][ISA_DMA_ADDR]);
+		outb(address >> 8, isa_dma_port[channel][ISA_DMA_ADDR]);
+
+		outb(length, isa_dma_port[channel][ISA_DMA_COUNT]);
+		outb(length >> 8, isa_dma_port[channel][ISA_DMA_COUNT]);
+
+		if (dma->dma_mode & DMA_AUTOINIT)
+			mode |= ISA_DMA_AUTOINIT;
+
+		outb(mode, isa_dma_port[channel][ISA_DMA_MODE]);
+		dma->invalid = 0;
+	}
+	outb(channel & 3, isa_dma_port[channel][ISA_DMA_MASK]);
+}
+
+static void isa_disable_dma(dmach_t channel, dma_t *dma)
+{
+	outb(channel | 4, isa_dma_port[channel][ISA_DMA_MASK]);
+}
+
+static struct dma_ops isa_dma_ops = {
+	.type		= "ISA",
+	.enable		= isa_enable_dma,
+	.disable	= isa_disable_dma,
+	.residue	= isa_get_dma_residue,
+};
+
+static struct resource dma_resources[] = {
+	{ "dma1",		0x0000, 0x000f },
+	{ "dma low page", 	0x0080, 0x008f },
+	{ "dma2",		0x00c0, 0x00df },
+	{ "dma high page",	0x0480, 0x048f }
+};
+
+void __init isa_init_dma(dma_t *dma)
+{
+	/*
+	 * Try to autodetect presence of an ISA DMA controller.
+	 * We do some minimal initialisation, and check that
+	 * channel 0's DMA address registers are writeable.
+	 */
+	outb(0xff, 0x0d);
+	outb(0xff, 0xda);
+
+	/*
+	 * Write high and low address, and then read them back
+	 * in the same order.
+	 */
+	outb(0x55, 0x00);
+	outb(0xaa, 0x00);
+
+	if (inb(0) == 0x55 && inb(0) == 0xaa) {
+		int channel, i;
+
+		for (channel = 0; channel < 8; channel++) {
+			dma[channel].d_ops = &isa_dma_ops;
+			isa_disable_dma(channel, NULL);
+		}
+
+		outb(0x40, 0x0b);
+		outb(0x41, 0x0b);
+		outb(0x42, 0x0b);
+		outb(0x43, 0x0b);
+
+		outb(0xc0, 0xd6);
+		outb(0x41, 0xd6);
+		outb(0x42, 0xd6);
+		outb(0x43, 0xd6);
+
+		outb(0, 0xd4);
+
+		outb(0x10, 0x08);
+		outb(0x10, 0xd0);
+
+		/*
+		 * Is this correct?  According to my documentation, it
+		 * doesn't appear to be.  It should be:
+		 *  outb(0x3f, 0x40b); outb(0x3f, 0x4d6);
+		 */
+		outb(0x30, 0x40b);
+		outb(0x31, 0x40b);
+		outb(0x32, 0x40b);
+		outb(0x33, 0x40b);
+		outb(0x31, 0x4d6);
+		outb(0x32, 0x4d6);
+		outb(0x33, 0x4d6);
+
+		request_dma(DMA_ISA_CASCADE, "cascade");
+
+		for (i = 0; i < sizeof(dma_resources) / sizeof(dma_resources[0]); i++)
+			request_resource(&ioport_resource, dma_resources + i);
+	}
+}
