commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index e3057c1b55b9..39c978698406 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -1,11 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  linux/arch/arm/kernel/devtree.c
  *
  *  Copyright (C) 2009 Canonical Ltd. <jeremy.kerr@canonical.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/init.h>

commit 57c8a661d95dff48dd9c2f2496139082bbaf241a
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:49 2018 -0700

    mm: remove include/linux/bootmem.h
    
    Move remaining definitions and declarations from include/linux/bootmem.h
    into include/linux/memblock.h and remove the redundant header.
    
    The includes were replaced with the semantic patch below and then
    semi-automated removal of duplicated '#include <linux/memblock.h>
    
    @@
    @@
    - #include <linux/bootmem.h>
    + #include <linux/memblock.h>
    
    [sfr@canb.auug.org.au: dma-direct: fix up for the removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181002185342.133d1680@canb.auug.org.au
    [sfr@canb.auug.org.au: powerpc: fix up for removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181005161406.73ef8727@canb.auug.org.au
    [sfr@canb.auug.org.au: x86/kaslr, ACPI/NUMA: fix for linux/bootmem.h removal]
      Link: http://lkml.kernel.org/r/20181008190341.5e396491@canb.auug.org.au
    Link: http://lkml.kernel.org/r/1536927045-23536-30-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index 13bcd3b867cb..e3057c1b55b9 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -12,7 +12,6 @@
 #include <linux/export.h>
 #include <linux/errno.h>
 #include <linux/types.h>
-#include <linux/bootmem.h>
 #include <linux/memblock.h>
 #include <linux/of.h>
 #include <linux/of_fdt.h>

commit d4866f751edf6d46d523b75979b3c6affed16510
Author: Rob Herring <robh@kernel.org>
Date:   Mon Aug 27 10:53:34 2018 -0500

    ARM: use for_each_of_cpu_node iterator
    
    Use the for_each_of_cpu_node iterator to iterate over cpu nodes. This
    has the side effect of defaulting to iterating using "cpu" node names in
    preference to the deprecated (for FDT) device_type == "cpu".
    
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index ecaa68dd1af5..13bcd3b867cb 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -87,14 +87,11 @@ void __init arm_dt_init_cpu_maps(void)
 	if (!cpus)
 		return;
 
-	for_each_child_of_node(cpus, cpu) {
+	for_each_of_cpu_node(cpu) {
 		const __be32 *cell;
 		int prop_bytes;
 		u32 hwid;
 
-		if (of_node_cmp(cpu->type, "cpu"))
-			continue;
-
 		pr_debug(" * %pOF...\n", cpu);
 		/*
 		 * A device tree containing CPU nodes with missing "reg"

commit a8e65e06ec66f8657795162c51ee73bec116a890
Author: Rob Herring <robh@kernel.org>
Date:   Fri Jul 21 14:28:32 2017 -0500

    ARM: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Acked-by: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Javier Martinez Canillas <javier@osg.samsung.com>
    Cc: Fabio Estevam <fabio.estevam@nxp.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: "Beno√Æt Cousson" <bcousson@baylibre.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index f676febbb270..ecaa68dd1af5 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -95,7 +95,7 @@ void __init arm_dt_init_cpu_maps(void)
 		if (of_node_cmp(cpu->type, "cpu"))
 			continue;
 
-		pr_debug(" * %s...\n", cpu->full_name);
+		pr_debug(" * %pOF...\n", cpu);
 		/*
 		 * A device tree containing CPU nodes with missing "reg"
 		 * properties is considered invalid to build the
@@ -103,8 +103,7 @@ void __init arm_dt_init_cpu_maps(void)
 		 */
 		cell = of_get_property(cpu, "reg", &prop_bytes);
 		if (!cell || prop_bytes < sizeof(*cell)) {
-			pr_debug(" * %s missing reg property\n",
-				     cpu->full_name);
+			pr_debug(" * %pOF missing reg property\n", cpu);
 			of_node_put(cpu);
 			return;
 		}

commit ba6dea4f7cedb4b1c17e36f4087675d817c2e24b
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Mon Sep 26 16:50:55 2016 +0100

    ARM: 8616/1: dt: Respect property size when parsing CPUs
    
    Whilst MPIDR values themselves are less than 32 bits, it is still
    perfectly valid for a DT to have #address-cells > 1 in the CPUs node,
    resulting in the "reg" property having leading zero cell(s). In that
    situation, the big-endian nature of the data conspires with the current
    behaviour of only reading the first cell to cause the kernel to think
    all CPUs have ID 0, and become resoundingly unhappy as a consequence.
    
    Take the full property length into account when parsing CPUs so as to
    be correct under any circumstances.
    
    Cc: Russell King <linux@armlinux.org.uk>
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index 40ecd5f514a2..f676febbb270 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -88,6 +88,8 @@ void __init arm_dt_init_cpu_maps(void)
 		return;
 
 	for_each_child_of_node(cpus, cpu) {
+		const __be32 *cell;
+		int prop_bytes;
 		u32 hwid;
 
 		if (of_node_cmp(cpu->type, "cpu"))
@@ -99,7 +101,8 @@ void __init arm_dt_init_cpu_maps(void)
 		 * properties is considered invalid to build the
 		 * cpu_logical_map.
 		 */
-		if (of_property_read_u32(cpu, "reg", &hwid)) {
+		cell = of_get_property(cpu, "reg", &prop_bytes);
+		if (!cell || prop_bytes < sizeof(*cell)) {
 			pr_debug(" * %s missing reg property\n",
 				     cpu->full_name);
 			of_node_put(cpu);
@@ -107,10 +110,15 @@ void __init arm_dt_init_cpu_maps(void)
 		}
 
 		/*
-		 * 8 MSBs must be set to 0 in the DT since the reg property
+		 * Bits n:24 must be set to 0 in the DT since the reg property
 		 * defines the MPIDR[23:0].
 		 */
-		if (hwid & ~MPIDR_HWID_BITMASK) {
+		do {
+			hwid = be32_to_cpu(*cell++);
+			prop_bytes -= sizeof(*cell);
+		} while (!hwid && prop_bytes > 0);
+
+		if (prop_bytes || (hwid & ~MPIDR_HWID_BITMASK)) {
 			of_node_put(cpu);
 			return;
 		}

commit 2374b063c3dfbb68a40b52067eaff81510f384b1
Author: Ben Dooks <ben-linux@fluff.org>
Date:   Fri Jun 17 18:21:07 2016 +0100

    ARM: 8581/1: add missing <asm/prom.h> to arch/arm/kernel/devtree.c
    
    Fix the following warnings by including declarations
    from <asm/prom.h>:
    
    arch/arm/kernel/devtree.c:69:13: warning: symbol 'arm_dt_init_cpu_maps' was not declared. Should it be static?
    arch/arm/kernel/devtree.c:210:27: warning: symbol 'setup_machine_fdt' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index f8966bb25f9d..40ecd5f514a2 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -23,6 +23,7 @@
 #include <asm/cputype.h>
 #include <asm/setup.h>
 #include <asm/page.h>
+#include <asm/prom.h>
 #include <asm/smp_plat.h>
 #include <asm/mach/arch.h>
 #include <asm/mach-types.h>

commit cb6f8344f8780d75929c6a20f1f094d2585003f4
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Apr 4 09:22:28 2016 +0100

    ARM: 8556/1: on a generic DT system: do not touch l2x0
    
    Set no bits, mask all bits in the AUX l2x0 register for the
    default DT ARM system: if anything needs to be modified, it
    should be done using DT bindings.
    
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index 2e26016a91a5..f8966bb25f9d 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -213,6 +213,8 @@ const struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)
 
 #if defined(CONFIG_ARCH_MULTIPLATFORM) || defined(CONFIG_ARM_SINGLE_ARMV7M)
 	DT_MACHINE_START(GENERIC_DT, "Generic DT based system")
+		.l2c_aux_val = 0x0,
+		.l2c_aux_mask = ~0x0,
 	MACHINE_END
 
 	mdesc_best = &__mach_desc_GENERIC_DT;

commit 70722803de91a7670979dcb5748631b4e3c1b219
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Dec 17 17:45:47 2015 +0100

    ARM: make default platform work for NOMMU
    
    Moving ARCH_VERSATILE into ARCH_MULTIPLATFORM means that it no longer
    works as the default target for MMU-less kernels. While we might
    want to get that working again in the future, it's also a rather
    bad default, and it makes sense to make ARM_SINGLE_V7M the default
    because that is what realistically all NOMMU users on ARM are using,
    and it actually is what gets selected by default in the absence of
    versatile in the choice statement.
    
    Related to this, 'allnoconfig' kernels fail to link with the new
    default, as they do not include a machine record:
    
    arm-linux-gnueabi-ld: no machine record defined
    
    For ARCH_MULTIPLATFORM kernels, we avoid this error by using a
    default machine descriptor that works for all trivial platforms,
    like ARCH_VIRT. The same reasoning applies for ARM_SINGLE_V7M,
    as that can also boot with empty machine descriptors both on
    qemu and on real hardware, as long as all the drivers are present.
    
    We could also follow up with a patch to remove the existing
    machine descriptors for the ARMv7M platforms, the only callback
    pointer the four platforms contain today is the armv7m_restart
    handler and we can simply make that the default for v7M with an
    add-on patch.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index 65addcbf5b30..2e26016a91a5 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -211,7 +211,7 @@ const struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)
 {
 	const struct machine_desc *mdesc, *mdesc_best = NULL;
 
-#ifdef CONFIG_ARCH_MULTIPLATFORM
+#if defined(CONFIG_ARCH_MULTIPLATFORM) || defined(CONFIG_ARM_SINGLE_ARMV7M)
 	DT_MACHINE_START(GENERIC_DT, "Generic DT based system")
 	MACHINE_END
 

commit a4283e41bbd80c629770f954cc5d013eb8851229
Author: Julia Lawall <julia.lawall@lip6.fr>
Date:   Sat Oct 10 23:41:42 2015 +0200

    arm: add missing of_node_put
    
    for_each_child_of_node performs an of_node_get on each iteration, so
    a break out of the loop requires an of_node_put.
    
    The of_node_put is duplicated in front of each error return, because the
    function contains a later error return that is beyond the end of the
    for_each_child_of_node and thus doesn't need of_node_put.
    
    The semantic patch that fixes this problem is as follows
    (http://coccinelle.lip6.fr):
    
    // <smpl>
    @@
    expression root,e;
    local idexpression child;
    iterator name for_each_child_of_node;
    @@
    
     for_each_child_of_node(root, child) {
       ... when != of_node_put(child)
           when != e = child
    (
       return child;
    |
    +  of_node_put(child);
    ?  return ...;
    )
       ...
     }
    
    @@
    expression root,e;
    local idexpression child;
    @@
    
     for_each_child_of_node(root, child) {
       ... when != of_node_put(child)
           when != e = child
    +  of_node_put(child);
    ?  break;
       ...
    }
    ... when != child
    // </smpl>
    
    Additionally, concatenated a string in an affected line to avoid introducing
    a checkpatch warning.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index 11c54de9f8cf..65addcbf5b30 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -101,6 +101,7 @@ void __init arm_dt_init_cpu_maps(void)
 		if (of_property_read_u32(cpu, "reg", &hwid)) {
 			pr_debug(" * %s missing reg property\n",
 				     cpu->full_name);
+			of_node_put(cpu);
 			return;
 		}
 
@@ -108,8 +109,10 @@ void __init arm_dt_init_cpu_maps(void)
 		 * 8 MSBs must be set to 0 in the DT since the reg property
 		 * defines the MPIDR[23:0].
 		 */
-		if (hwid & ~MPIDR_HWID_BITMASK)
+		if (hwid & ~MPIDR_HWID_BITMASK) {
+			of_node_put(cpu);
 			return;
+		}
 
 		/*
 		 * Duplicate MPIDRs are a recipe for disaster.
@@ -119,9 +122,11 @@ void __init arm_dt_init_cpu_maps(void)
 		 * to avoid matching valid MPIDR[23:0] values.
 		 */
 		for (j = 0; j < cpuidx; j++)
-			if (WARN(tmp_map[j] == hwid, "Duplicate /cpu reg "
-						     "properties in the DT\n"))
+			if (WARN(tmp_map[j] == hwid,
+				 "Duplicate /cpu reg properties in the DT\n")) {
+				of_node_put(cpu);
 				return;
+			}
 
 		/*
 		 * Build a stashed array of MPIDR values. Numbering scheme
@@ -143,6 +148,7 @@ void __init arm_dt_init_cpu_maps(void)
 					       "max cores %u, capping them\n",
 					       cpuidx, nr_cpu_ids)) {
 			cpuidx = nr_cpu_ids;
+			of_node_put(cpu);
 			break;
 		}
 

commit 5a12a597a8627b91fd9d94365853f9f69a4f399c
Author: Laura Abbott <lauraa@codeaurora.org>
Date:   Tue Jul 15 10:03:36 2014 -0700

    arm: Add devicetree fixup machine function
    
    Commit 1c2f87c22566cd057bc8cde10c37ae9da1a1bb76
    (ARM: 8025/1: Get rid of meminfo) dropped the upper bound on
    the number of memory banks that can be added as there was no
    technical need in the kernel. It turns out though, some bootloaders
    (specifically the arndale-octa exynos boards) may pass invalid memory
    information and rely on the kernel to not parse this data. This is a
    bug in the bootloader but we still need to work around this.
    Work around this by introducing a dt_fixup function. This function
    gets called before the flattened devicetree is scanned for memory
    and the like. In this fixup function for exynos, limit the maximum
    number of memory regions in the devicetree.
    
    Signed-off-by: Laura Abbott <lauraa@codeaurora.org>
    Tested-by: Andreas F√§rber <afaerber@suse.de>
    [glikely: Added a comment and fixed up function name]
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index e94a157ddff1..11c54de9f8cf 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -212,7 +212,7 @@ const struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)
 	mdesc_best = &__mach_desc_GENERIC_DT;
 #endif
 
-	if (!dt_phys || !early_init_dt_scan(phys_to_virt(dt_phys)))
+	if (!dt_phys || !early_init_dt_verify(phys_to_virt(dt_phys)))
 		return NULL;
 
 	mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach);
@@ -237,6 +237,12 @@ const struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)
 		dump_machine_table(); /* does not return */
 	}
 
+	/* We really don't want to do this, but sometimes firmware provides buggy data */
+	if (mdesc->dt_fixup)
+		mdesc->dt_fixup();
+
+	early_init_dt_scan_nodes();
+
 	/* Change machine number to match the mdesc we're using */
 	__machine_arch_type = mdesc->nr;
 

commit eb3d3ec567e868c8a3bfbfdfc9465ffd52983d11
Merge: c3c55a072039 bd63ce27d9d6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 5 15:57:04 2014 -0700

    Merge branch 'for-linus' of git://ftp.arm.linux.org.uk/~rmk/linux-arm into next
    
    Pull ARM updates from Russell King:
    
     - Major clean-up of the L2 cache support code.  The existing mess was
       becoming rather unmaintainable through all the additions that others
       have done over time.  This turns it into a much nicer structure, and
       implements a few performance improvements as well.
    
     - Clean up some of the CP15 control register tweaks for alignment
       support, moving some code and data into alignment.c
    
     - DMA properties for ARM, from Santosh and reviewed by DT people.  This
       adds DT properties to specify bus translations we can't discover
       automatically, and to indicate whether devices are coherent.
    
     - Hibernation support for ARM
    
     - Make ftrace work with read-only text in modules
    
     - add suspend support for PJ4B CPUs
    
     - rework interrupt masking for undefined instruction handling, which
       allows us to enable interrupts earlier in the handling of these
       exceptions.
    
     - support for big endian page tables
    
     - fix stacktrace support to exclude stacktrace functions from the
       trace, and add save_stack_trace_regs() implementation so that kprobes
       can record stack traces.
    
     - Add support for the Cortex-A17 CPU.
    
     - Remove last vestiges of ARM710 support.
    
     - Removal of ARM "meminfo" structure, finally converting us solely to
       memblock to handle the early memory initialisation.
    
    * 'for-linus' of git://ftp.arm.linux.org.uk/~rmk/linux-arm: (142 commits)
      ARM: ensure C page table setup code follows assembly code (part II)
      ARM: ensure C page table setup code follows assembly code
      ARM: consolidate last remaining open-coded alignment trap enable
      ARM: remove global cr_no_alignment
      ARM: remove CPU_CP15 conditional from alignment.c
      ARM: remove unused adjust_cr() function
      ARM: move "noalign" command line option to alignment.c
      ARM: provide common method to clear bits in CPU control register
      ARM: 8025/1: Get rid of meminfo
      ARM: 8060/1: mm: allow sub-architectures to override PCI I/O memory type
      ARM: 8066/1: correction for ARM patch 8031/2
      ARM: 8049/1: ftrace/add save_stack_trace_regs() implementation
      ARM: 8065/1: remove last use of CONFIG_CPU_ARM710
      ARM: 8062/1: Modify ldrt fixup handler to re-execute the userspace instruction
      ARM: 8047/1: rwsem: use asm-generic rwsem implementation
      ARM: l2c: trial at enabling some Cortex-A9 optimisations
      ARM: l2c: add warnings for stuff modifying aux_ctrl register values
      ARM: l2c: print a warning with L2C-310 caches if the cache size is modified
      ARM: l2c: remove old .set_debug method
      ARM: l2c: kill L2X0_AUX_CTRL_MASK before anyone else makes use of this
      ...

commit 1c2f87c22566cd057bc8cde10c37ae9da1a1bb76
Author: Laura Abbott <lauraa@codeaurora.org>
Date:   Sun Apr 13 22:54:58 2014 +0100

    ARM: 8025/1: Get rid of meminfo
    
    memblock is now fully integrated into the kernel and is the prefered
    method for tracking memory. Rather than reinvent the wheel with
    meminfo, migrate to using memblock directly instead of meminfo as
    an intermediate.
    
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Leif Lindholm <leif.lindholm@linaro.org>
    Signed-off-by: Laura Abbott <lauraa@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index c7419a585ddc..679a83d470cc 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -27,11 +27,6 @@
 #include <asm/mach/arch.h>
 #include <asm/mach-types.h>
 
-void __init early_init_dt_add_memory_arch(u64 base, u64 size)
-{
-	arm_add_memory(base, size);
-}
-
 void * __init early_init_dt_alloc_memory_arch(u64 size, u64 align)
 {
 	return memblock_virt_alloc(size, align);

commit 9a721c41113a50ccbe184d67a5e551feb99e36a9
Author: Rob Herring <robh@kernel.org>
Date:   Mon Mar 24 16:11:54 2014 -0500

    ARM: align cpu_method_of_table naming
    
    The cpu_method_of_table is the oddball of the various OF linker sections.
    In preparation to have common linker section definitions, align the
    cpu_method_of_table with the other definitions for the naming and ending
    with a blank struct.
    
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Russell King <linux@arm.linux.org.uk>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index 3e5a2056a466..ea9ce92a4b52 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -33,18 +33,21 @@ void __init early_init_dt_add_memory_arch(u64 base, u64 size)
 }
 
 #ifdef CONFIG_SMP
-extern struct of_cpu_method __cpu_method_of_table_begin[];
-extern struct of_cpu_method __cpu_method_of_table_end[];
+extern struct of_cpu_method __cpu_method_of_table[];
+
+static const struct of_cpu_method __cpu_method_of_table_sentinel
+	__used __section(__cpu_method_of_table_end);
+
 
 static int __init set_smp_ops_by_method(struct device_node *node)
 {
 	const char *method;
-	struct of_cpu_method *m = __cpu_method_of_table_begin;
+	struct of_cpu_method *m = __cpu_method_of_table;
 
 	if (of_property_read_string(node, "enable-method", &method))
 		return 0;
 
-	for (; m < __cpu_method_of_table_end; m++)
+	for (; m->method; m++)
 		if (!strcmp(m->method, method)) {
 			smp_set_ops(m->ops);
 			return 1;

commit d1552ce449eb0a8d2f0bd6599da3a8a3d7f77a84
Author: Rob Herring <robh@kernel.org>
Date:   Tue Apr 1 22:46:48 2014 -0500

    of/fdt: move memreserve and dtb memory reservations into core
    
    Move the /memreserve/ processing and dtb memory reservations into
    early_init_fdt_scan_reserved_mem. This converts arm, arm64, and powerpc
    as they are the only users of early_init_fdt_scan_reserved_mem.
    
    memblock_reserve is safe to call on the same region twice, so the
    reservation check for the dtb in powerpc 32-bit reservations is safe to
    remove.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Tested-by: Michal Simek <michal.simek@xilinx.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Tested-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Stephen Chivers <schivers@csc.com>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index 38f4711b4995..3e5a2056a466 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -32,33 +32,6 @@ void __init early_init_dt_add_memory_arch(u64 base, u64 size)
 	arm_add_memory(base, size);
 }
 
-void __init arm_dt_memblock_reserve(void)
-{
-	u64 *reserve_map, base, size;
-
-	if (!initial_boot_params)
-		return;
-
-	/* Reserve the dtb region */
-	memblock_reserve(virt_to_phys(initial_boot_params),
-			 be32_to_cpu(initial_boot_params->totalsize));
-
-	/*
-	 * Process the reserve map.  This will probably overlap the initrd
-	 * and dtb locations which are already reserved, but overlaping
-	 * doesn't hurt anything
-	 */
-	reserve_map = ((void*)initial_boot_params) +
-			be32_to_cpu(initial_boot_params->off_mem_rsvmap);
-	while (1) {
-		base = be64_to_cpup(reserve_map++);
-		size = be64_to_cpup(reserve_map++);
-		if (!size)
-			break;
-		memblock_reserve(base, size);
-	}
-}
-
 #ifdef CONFIG_SMP
 extern struct of_cpu_method __cpu_method_of_table_begin[];
 extern struct of_cpu_method __cpu_method_of_table_end[];

commit 9d0c4dfedd96ee54fc075b16d02f82499c8cc3a6
Author: Rob Herring <robh@kernel.org>
Date:   Tue Apr 1 23:49:03 2014 -0500

    of/fdt: update of_get_flat_dt_prop in prep for libfdt
    
    Make of_get_flat_dt_prop arguments compatible with libfdt fdt_getprop
    call in preparation to convert FDT code to use libfdt. Make the return
    value const and the property length ptr type an int.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Tested-by: Michal Simek <michal.simek@xilinx.com>
    Tested-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Stephen Chivers <schivers@csc.com>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index dff9cc0e9bd6..38f4711b4995 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -247,7 +247,7 @@ const struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)
 
 	if (!mdesc) {
 		const char *prop;
-		long size;
+		int size;
 		unsigned long dt_root;
 
 		early_print("\nError: unrecognized/unsupported "

commit 1f809b4b1221f35cd2995b5605c006a8903c340c
Author: Rob Herring <robh@kernel.org>
Date:   Thu Apr 3 13:13:46 2014 -0500

    ARM: dt: use default early_init_dt_alloc_memory_arch
    
    Now that ARM is using memblock instead of bootmem, the default version
    of early_init_dt_alloc_memory_arch can be used.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: linux-arm-kernel@lists.infradead.org
    Tested-by: Grant Likely <grant.likely@linaro.org>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index c7419a585ddc..dff9cc0e9bd6 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -32,11 +32,6 @@ void __init early_init_dt_add_memory_arch(u64 base, u64 size)
 	arm_add_memory(base, size);
 }
 
-void * __init early_init_dt_alloc_memory_arch(u64 size, u64 align)
-{
-	return memblock_virt_alloc(size, align);
-}
-
 void __init arm_dt_memblock_reserve(void)
 {
 	u64 *reserve_map, base, size;

commit 6c3ff8b11a16ec69199ab85b74a5fae6d9c59db7
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Oct 30 18:21:09 2013 -0700

    ARM: Introduce CPU_METHOD_OF_DECLARE() for cpu hotplug/smp
    
    The goal of multi-platform kernels is to remove the need for mach
    directories and machine descriptors. To further that goal,
    introduce CPU_METHOD_OF_DECLARE() to allow cpu hotplug/smp
    support to be separated from the machine descriptors.
    Implementers should specify an enable-method property in their
    cpus node and then implement a matching set of smp_ops in their
    hotplug/smp code, wiring it up with the CPU_METHOD_OF_DECLARE()
    macro. When the kernel is compiled we'll collect all the
    enable-method smp_ops into one section for use at boot.
    
    At boot time we'll look for an enable-method in each cpu node and
    try to match that against all known CPU enable methods in the
    kernel. If there are no enable-methods in the cpu nodes we
    fallback to the cpus node and try to use any enable-method found
    there. If that doesn't work we fall back to the old way of using
    the machine descriptor.
    
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: <devicetree@vger.kernel.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Kumar Gala <galak@codeaurora.org>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index f751714d52c1..c7419a585ddc 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -18,6 +18,7 @@
 #include <linux/of_fdt.h>
 #include <linux/of_irq.h>
 #include <linux/of_platform.h>
+#include <linux/smp.h>
 
 #include <asm/cputype.h>
 #include <asm/setup.h>
@@ -63,6 +64,34 @@ void __init arm_dt_memblock_reserve(void)
 	}
 }
 
+#ifdef CONFIG_SMP
+extern struct of_cpu_method __cpu_method_of_table_begin[];
+extern struct of_cpu_method __cpu_method_of_table_end[];
+
+static int __init set_smp_ops_by_method(struct device_node *node)
+{
+	const char *method;
+	struct of_cpu_method *m = __cpu_method_of_table_begin;
+
+	if (of_property_read_string(node, "enable-method", &method))
+		return 0;
+
+	for (; m < __cpu_method_of_table_end; m++)
+		if (!strcmp(m->method, method)) {
+			smp_set_ops(m->ops);
+			return 1;
+		}
+
+	return 0;
+}
+#else
+static inline int set_smp_ops_by_method(struct device_node *node)
+{
+	return 1;
+}
+#endif
+
+
 /*
  * arm_dt_init_cpu_maps - Function retrieves cpu nodes from the device tree
  * and builds the cpu logical map array containing MPIDR values related to
@@ -79,6 +108,7 @@ void __init arm_dt_init_cpu_maps(void)
 	 * read as 0.
 	 */
 	struct device_node *cpu, *cpus;
+	int found_method = 0;
 	u32 i, j, cpuidx = 1;
 	u32 mpidr = is_smp() ? read_cpuid_mpidr() & MPIDR_HWID_BITMASK : 0;
 
@@ -150,8 +180,18 @@ void __init arm_dt_init_cpu_maps(void)
 		}
 
 		tmp_map[i] = hwid;
+
+		if (!found_method)
+			found_method = set_smp_ops_by_method(cpu);
 	}
 
+	/*
+	 * Fallback to an enable-method in the cpus node if nothing found in
+	 * a cpu node.
+	 */
+	if (!found_method)
+		set_smp_ops_by_method(cpus);
+
 	if (!bootcpu_valid) {
 		pr_warn("DT missing boot CPU MPIDR[23:0], fall back to default cpu_logical_map\n");
 		return;

commit 9233d2be108f573caa21eb450411bf8fa68cadbb
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Tue Jan 21 15:50:47 2014 -0800

    arch/arm/kernel/: use memblock apis for early memory allocations
    
    Switch to memblock interfaces for early memory allocator instead of
    bootmem allocator.  No functional change in beahvior than what it is in
    current code from bootmem users points of view.
    
    Archs already converted to NO_BOOTMEM now directly use memblock
    interfaces instead of bootmem wrappers build on top of memblock.  And
    the archs which still uses bootmem, these new apis just fallback to
    exiting bootmem APIs.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Christoph Lameter <cl@linux-foundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index 34d5fd585bbb..f751714d52c1 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -33,7 +33,7 @@ void __init early_init_dt_add_memory_arch(u64 base, u64 size)
 
 void * __init early_init_dt_alloc_memory_arch(u64 size, u64 align)
 {
-	return alloc_bootmem_align(size, align);
+	return memblock_virt_alloc(size, align);
 }
 
 void __init arm_dt_memblock_reserve(void)

commit e44ef891e9e68b6ce7d3fd3bac73b7d5433050ae
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Wed Jan 8 18:24:21 2014 +0100

    ARM: 7934/1: DT/kernel: fix arch_match_cpu_phys_id to avoid erroneous match
    
    The MPIDR contains specific bitfields(MPIDR.Aff{2..0}) which uniquely
    identify a CPU, in addition to some non-identifying information and
    reserved bits. The ARM cpu binding defines the 'reg' property to only
    contain the affinity bits, and any cpu nodes with other bits set in
    their 'reg' entry are skipped.
    
    As such it is not necessary to mask the phys_id with MPIDR_HWID_BITMASK,
    and doing so could lead to matching erroneous CPU nodes in the device
    tree. This patch removes the masking of the physical identifier.
    
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index 739c3dfc1da2..34d5fd585bbb 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -171,7 +171,7 @@ void __init arm_dt_init_cpu_maps(void)
 
 bool arch_match_cpu_phys_id(int cpu, u64 phys_id)
 {
-	return (phys_id & MPIDR_HWID_BITMASK) == cpu_logical_map(cpu);
+	return phys_id == cpu_logical_map(cpu);
 }
 
 static const void * __init arch_get_next_mach(const char *const **match)

commit 6d67a9f672f4718a3a9060a96f859d0465663b55
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Tue Aug 27 21:43:49 2013 -0500

    arm: use common of_flat_dt_match_machine
    
    Convert arm to use the common of_flat_dt_match_machine function.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: linux-arm-kernel@lists.infradead.org

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index e7ce175b99e3..739c3dfc1da2 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -174,6 +174,19 @@ bool arch_match_cpu_phys_id(int cpu, u64 phys_id)
 	return (phys_id & MPIDR_HWID_BITMASK) == cpu_logical_map(cpu);
 }
 
+static const void * __init arch_get_next_mach(const char *const **match)
+{
+	static const struct machine_desc *mdesc = __arch_info_begin;
+	const struct machine_desc *m = mdesc;
+
+	if (m >= __arch_info_end)
+		return NULL;
+
+	mdesc++;
+	*match = m->dt_compat;
+	return m;
+}
+
 /**
  * setup_machine_fdt - Machine setup when an dtb was passed to the kernel
  * @dt_phys: physical address of dt blob
@@ -184,9 +197,6 @@ bool arch_match_cpu_phys_id(int cpu, u64 phys_id)
 const struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)
 {
 	const struct machine_desc *mdesc, *mdesc_best = NULL;
-	unsigned int score, mdesc_score = ~1;
-	unsigned long dt_root;
-	const char *model;
 
 #ifdef CONFIG_ARCH_MULTIPLATFORM
 	DT_MACHINE_START(GENERIC_DT, "Generic DT based system")
@@ -198,23 +208,17 @@ const struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)
 	if (!dt_phys || !early_init_dt_scan(phys_to_virt(dt_phys)))
 		return NULL;
 
+	mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach);
 
-	/* Search the mdescs for the 'best' compatible value match */
-	dt_root = of_get_flat_dt_root();
-	for_each_machine_desc(mdesc) {
-		score = of_flat_dt_match(dt_root, mdesc->dt_compat);
-		if (score > 0 && score < mdesc_score) {
-			mdesc_best = mdesc;
-			mdesc_score = score;
-		}
-	}
-	if (!mdesc_best) {
+	if (!mdesc) {
 		const char *prop;
 		long size;
+		unsigned long dt_root;
 
 		early_print("\nError: unrecognized/unsupported "
 			    "device tree compatible list:\n[ ");
 
+		dt_root = of_get_flat_dt_root();
 		prop = of_get_flat_dt_prop(dt_root, "compatible", &size);
 		while (size > 0) {
 			early_print("'%s' ", prop);
@@ -226,15 +230,8 @@ const struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)
 		dump_machine_table(); /* does not return */
 	}
 
-	model = of_get_flat_dt_prop(dt_root, "model", NULL);
-	if (!model)
-		model = of_get_flat_dt_prop(dt_root, "compatible", NULL);
-	if (!model)
-		model = "<unknown>";
-	pr_info("Machine: %s, model: %s\n", mdesc_best->name, model);
-
 	/* Change machine number to match the mdesc we're using */
-	__machine_arch_type = mdesc_best->nr;
+	__machine_arch_type = mdesc->nr;
 
-	return mdesc_best;
+	return mdesc;
 }

commit 56dc1f474add364b07254ad9690f4e244ca65ef4
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Mon Aug 26 10:13:01 2013 -0500

    arm: use early_init_dt_scan
    
    Convert arm to use new early_init_dt_scan function.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: linux-arm-kernel@lists.infradead.org

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index f35906b3d8c9..e7ce175b99e3 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -183,7 +183,6 @@ bool arch_match_cpu_phys_id(int cpu, u64 phys_id)
  */
 const struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)
 {
-	struct boot_param_header *devtree;
 	const struct machine_desc *mdesc, *mdesc_best = NULL;
 	unsigned int score, mdesc_score = ~1;
 	unsigned long dt_root;
@@ -196,17 +195,11 @@ const struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)
 	mdesc_best = &__mach_desc_GENERIC_DT;
 #endif
 
-	if (!dt_phys)
+	if (!dt_phys || !early_init_dt_scan(phys_to_virt(dt_phys)))
 		return NULL;
 
-	devtree = phys_to_virt(dt_phys);
-
-	/* check device tree validity */
-	if (be32_to_cpu(devtree->magic) != OF_DT_HEADER)
-		return NULL;
 
 	/* Search the mdescs for the 'best' compatible value match */
-	initial_boot_params = devtree;
 	dt_root = of_get_flat_dt_root();
 	for_each_machine_desc(mdesc) {
 		score = of_flat_dt_match(dt_root, mdesc->dt_compat);
@@ -240,13 +233,6 @@ const struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)
 		model = "<unknown>";
 	pr_info("Machine: %s, model: %s\n", mdesc_best->name, model);
 
-	/* Retrieve various information from the /chosen node */
-	of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);
-	/* Initialize {size,address}-cells info */
-	of_scan_flat_dt(early_init_dt_scan_root, NULL);
-	/* Setup memory, calling early_init_dt_add_memory_arch */
-	of_scan_flat_dt(early_init_dt_scan_memory, NULL);
-
 	/* Change machine number to match the mdesc we're using */
 	__machine_arch_type = mdesc_best->nr;
 

commit 2e032852245b3dcfe5461d7353e34eb6da095ccf
Merge: 356f9e74ffaa 141b97433d77
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 5 18:07:32 2013 -0700

    Merge branch 'for-linus' of git://git.linaro.org/people/rmk/linux-arm
    
    Pull ARM updates from Russell King:
     "This set includes adding support for Neon acceleration of RAID6 XOR
      code from Ard Biesheuvel, cache flushing and barrier updates from Will
      Deacon, and a cleanup to the ARM debug code which reduces the amount
      of code by about 500 lines.
    
      A few other cleanups, such as constifying the machine descriptors
      which already shouldn't be written to, cleaning up the printing of the
      L2 cache size"
    
    * 'for-linus' of git://git.linaro.org/people/rmk/linux-arm: (55 commits)
      ARM: 7826/1: debug: support debug ll on hisilicon soc
      ARM: 7830/1: delay: don't bother reporting bogomips in /proc/cpuinfo
      ARM: 7829/1: Add ".text.unlikely" and ".text.hot" to arm unwind tables
      ARM: 7828/1: ARMv7-M: implement restart routine common to all v7-M machines
      ARM: 7827/1: highbank: fix debug uart virtual address for LPAE
      ARM: 7823/1: errata: workaround Cortex-A15 erratum 773022
      ARM: 7806/1: allow DEBUG_UNCOMPRESS for Tegra
      ARM: 7793/1: debug: use generic option for ep93xx PL10x debug port
      ARM: debug: move SPEAr debug to generic PL01x code
      ARM: debug: move davinci debug to generic 8250 code
      ARM: debug: move keystone debug to generic 8250 code
      ARM: debug: remove DEBUG_ROCKCHIP_UART
      ARM: debug: provide generic option choices for 8250 and PL01x ports
      ARM: debug: move PL01X debug include into arch/arm/include/debug/
      ARM: debug: provide PL01x debug uart phys/virt address configuration options
      ARM: debug: add support for word accesses to debug/8250.S
      ARM: debug: move 8250 debug include into arch/arm/include/debug/
      ARM: debug: provide 8250 debug uart phys/virt address configuration options
      ARM: debug: provide 8250 debug uart register shift configuration option
      ARM: debug: provide 8250 debug uart flow control configuration option
      ...

commit 973e02c1e89768d13be259bf77f88b5cfd16bade
Author: Sudeep KarkadaNagesha <sudeep.karkadanagesha@arm.com>
Date:   Mon Jun 17 13:11:29 2013 +0100

    ARM: DT/kernel: define ARM specific arch_match_cpu_phys_id
    
    OF/DT core library now provides architecture specific hook to match the
    logical cpu index with the corresponding physical identifier. Most of the
    cpu DT node parsing and initialisation is contained in devtree.c. So it's
    better to define ARM specific arch_match_cpu_phys_id there.
    
    This mainly helps to avoid replication of the code doing CPU node parsing
    and physical(MPIDR) to logical mapping.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Sudeep KarkadaNagesha <sudeep.karkadanagesha@arm.com>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index 5859c8bc727c..2ee8a17d2b01 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -169,6 +169,11 @@ void __init arm_dt_init_cpu_maps(void)
 	}
 }
 
+bool arch_match_cpu_phys_id(int cpu, u64 phys_id)
+{
+	return (phys_id & MPIDR_HWID_BITMASK) == cpu_logical_map(cpu);
+}
+
 /**
  * setup_machine_fdt - Machine setup when an dtb was passed to the kernel
  * @dt_phys: physical address of dt blob

commit ff69a4c855066592f9e293cff8f54813614dd544
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Jul 26 14:55:59 2013 +0100

    ARM: constify machine_desc structure uses
    
    struct machine_desc records are defined everywhere as a 'const'
    structure, but unfortuantely it loses its const-ness through the use of
    linker magic - the symbols which surround the section are not declared
    const so it becomes possible not to use 'const' for pointers to these
    const structures.
    
    Let's fix this oversight - all pointers to these structures should be
    marked const too.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index 5859c8bc727c..eae1976f859d 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -176,10 +176,10 @@ void __init arm_dt_init_cpu_maps(void)
  * If a dtb was passed to the kernel in r2, then use it to choose the
  * correct machine_desc and to setup the system.
  */
-struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)
+const struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)
 {
 	struct boot_param_header *devtree;
-	struct machine_desc *mdesc, *mdesc_best = NULL;
+	const struct machine_desc *mdesc, *mdesc_best = NULL;
 	unsigned int score, mdesc_score = ~1;
 	unsigned long dt_root;
 	const char *model;
@@ -188,7 +188,7 @@ struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)
 	DT_MACHINE_START(GENERIC_DT, "Generic DT based system")
 	MACHINE_END
 
-	mdesc_best = (struct machine_desc *)&__mach_desc_GENERIC_DT;
+	mdesc_best = &__mach_desc_GENERIC_DT;
 #endif
 
 	if (!dt_phys)

commit 8d5bc1a6ac40885078bbb0552b4283a3e58c462e
Author: Olof Johansson <olof@lixom.net>
Date:   Sat Jun 29 16:25:14 2013 -0700

    ARM: dt: Only print warning, not WARN() on bad cpu map in device tree
    
    Due to recent changes and expecations of proper cpu bindings, there are
    now cases for many of the in-tree devicetrees where a WARN() will hit
    on boot due to badly formatted /cpus nodes.
    
    Downgrade this to a pr_warn() to be less alarmist, since it's not a
    new problem.
    
    Tested on Arndale, Cubox, Seaboard and Panda ES. Panda hits the WARN
    without this, the others do not.
    
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index 0905502bee15..5859c8bc727c 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -152,9 +152,10 @@ void __init arm_dt_init_cpu_maps(void)
 		tmp_map[i] = hwid;
 	}
 
-	if (WARN(!bootcpu_valid, "DT missing boot CPU MPIDR[23:0], "
-				 "fall back to default cpu_logical_map\n"))
+	if (!bootcpu_valid) {
+		pr_warn("DT missing boot CPU MPIDR[23:0], fall back to default cpu_logical_map\n");
 		return;
+	}
 
 	/*
 	 * Since the boot CPU node contains proper data, and all nodes have

commit 18d7f152df31e5a326301fdaad385e40874dff80
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Jun 19 10:40:48 2013 +0100

    ARM: 7763/1: kernel: fix __cpu_logical_map default initialization
    
    The __cpu_logical_map array is statically initialized to 0, which is a valid
    MPIDR value. To prevent issues with the current implementation, this patch
    defines an MPIDR_INVALID value, and statically initializes the
    __cpu_logical_map[] array to it. Entries in the arm_dt_init_cpu_maps()
    tmp_map array used to stash DT reg properties while parsing DT are initialized
    with the MPIDR_INVALID value as well for consistency.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index 904cad5ec657..0905502bee15 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -82,7 +82,7 @@ void __init arm_dt_init_cpu_maps(void)
 	u32 i, j, cpuidx = 1;
 	u32 mpidr = is_smp() ? read_cpuid_mpidr() & MPIDR_HWID_BITMASK : 0;
 
-	u32 tmp_map[NR_CPUS] = { [0 ... NR_CPUS-1] = UINT_MAX };
+	u32 tmp_map[NR_CPUS] = { [0 ... NR_CPUS-1] = MPIDR_INVALID };
 	bool bootcpu_valid = false;
 	cpus = of_find_node_by_path("/cpus");
 

commit 1ba9bf0a9ae779c1a2b3eb64951e4161d9bad7a9
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Jun 19 10:36:26 2013 +0100

    ARM: 7762/1: kernel: fix arm_dt_init_cpu_maps() to skip non-cpu nodes
    
    The introduction of the cpu-map topology node in the cpus node implies
    that cpus node might have children that are not cpu nodes. The DT
    parsing code needs updating otherwise it would check for cpu nodes
    properties in nodes that are not required to contain them, resulting
    in warnings that have no bearing on bindings defined in the dts source file.
    
    Cc: <stable@vger.kernel.org> [3.8+]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index 5af04f6daa33..904cad5ec657 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -92,6 +92,9 @@ void __init arm_dt_init_cpu_maps(void)
 	for_each_child_of_node(cpus, cpu) {
 		u32 hwid;
 
+		if (of_node_cmp(cpu->type, "cpu"))
+			continue;
+
 		pr_debug(" * %s...\n", cpu->full_name);
 		/*
 		 * A device tree containing CPU nodes with missing "reg"

commit 883a106b0866ca8d75b5520bdb3ca1cf8e3730ba
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Jan 31 17:51:18 2013 +0000

    ARM: default machine descriptor for multiplatform
    
    Since we now have default implementations for init_time and init_irq,
    the init_machine callback is the only one that is not yet optional,
    but since simple DT based platforms all have the same
    of_platform_populate function call in there, we can consolidate them
    as well, and then actually boot with a completely empty machine_desc.
    Unofortunately we cannot just default to an empty init_machine: We
    cannot call of_platform_populate before init_machine because that
    does not work in case of auxdata, and we cannot call it after
    init_machine either because the machine might need to run code
    after adding the devices.
    
    To take the final step, this adds support for booting without defining
    any machine_desc whatsoever.
    
    For the case that CONFIG_MULTIPLATFORM is enabled, it adds a
    global machine descriptor that never matches any machine but is
    used as a fallback if nothing else matches. We assume that without
    CONFIG_MULTIPLATFORM, we only want to boot on the systems that the kernel
    is built for, so we still retain the build-time warning for missing
    machine descriptors and the run-time warning when the platform does not
    match in that case.
    
    In the case that we run on a multiplatform kernel and the machine
    provides a fully populated device tree, we attempt to keep booting,
    hoping that no machine specific callbacks are necessary.
    
    Finally, this also removes the misguided "select ARCH_VEXPRESS" that
    was only added to avoid a build error for allnoconfig kernels.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Olof Johansson <olof@lixom.net>
    Cc: "Russell King - ARM Linux" <linux@arm.linux.org.uk>
    Cc: Rob Herring <robherring2@gmail.com>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index 70f1bdeb241b..5af04f6daa33 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -180,6 +180,13 @@ struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)
 	unsigned long dt_root;
 	const char *model;
 
+#ifdef CONFIG_ARCH_MULTIPLATFORM
+	DT_MACHINE_START(GENERIC_DT, "Generic DT based system")
+	MACHINE_END
+
+	mdesc_best = (struct machine_desc *)&__mach_desc_GENERIC_DT;
+#endif
+
 	if (!dt_phys)
 		return NULL;
 

commit ce7b175656a1903605f0184bf33acebff70bfe7f
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Thu Nov 22 18:02:54 2012 +0100

    ARM: 7585/1: kernel: fix nr_cpu_ids check in DT logical map init
    
    If a kernel is configured with a DT containing more /cpu nodes than
    nr_cpu_ids, the number of cpus must be capped in the DT parsing
    code. Current code carries out the check, but fails to cap the
    value and the check is executed after the cpu logical index is used,
    which can lead to memory corruption due to index overflow.
    
    This patch refactors the check against nr_cpu_ids and move it before
    any computed index is used in the parsing code.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Reported-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index aaf9add497fe..70f1bdeb241b 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -139,10 +139,14 @@ void __init arm_dt_init_cpu_maps(void)
 			i = cpuidx++;
 		}
 
-		tmp_map[i] = hwid;
-
-		if (cpuidx > nr_cpu_ids)
+		if (WARN(cpuidx > nr_cpu_ids, "DT /cpu %u nodes greater than "
+					       "max cores %u, capping them\n",
+					       cpuidx, nr_cpu_ids)) {
+			cpuidx = nr_cpu_ids;
 			break;
+		}
+
+		tmp_map[i] = hwid;
 	}
 
 	if (WARN(!bootcpu_valid, "DT missing boot CPU MPIDR[23:0], "

commit a0ae02405076ac32bd17ece976e914b5b6075bb0
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Thu Nov 17 17:31:51 2011 +0000

    ARM: kernel: add device tree init map function
    
    When booting through a device tree, the kernel cpu logical id map can be
    initialized using device tree data passed by FW or through an embedded blob.
    
    This patch adds a function that parses device tree "cpu" nodes and
    retrieves the corresponding CPUs hardware identifiers (MPIDR).
    It sets the possible cpus and the cpu logical map values according to
    the number of CPUs defined in the device tree and respective properties.
    
    The device tree HW identifiers are considered valid if all CPU nodes contain
    a "reg" property, there are no duplicate "reg" entries and the DT defines a
    CPU node whose "reg" property matches the MPIDR[23:0] of the boot CPU.
    
    The primary CPU is assigned cpu logical number 0 to keep the current convention
    valid.
    
    Current bindings documentation is included in the patch:
    
    Documentation/devicetree/bindings/arm/cpus.txt
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index bee7f9d47f02..aaf9add497fe 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -19,8 +19,10 @@
 #include <linux/of_irq.h>
 #include <linux/of_platform.h>
 
+#include <asm/cputype.h>
 #include <asm/setup.h>
 #include <asm/page.h>
+#include <asm/smp_plat.h>
 #include <asm/mach/arch.h>
 #include <asm/mach-types.h>
 
@@ -61,6 +63,104 @@ void __init arm_dt_memblock_reserve(void)
 	}
 }
 
+/*
+ * arm_dt_init_cpu_maps - Function retrieves cpu nodes from the device tree
+ * and builds the cpu logical map array containing MPIDR values related to
+ * logical cpus
+ *
+ * Updates the cpu possible mask with the number of parsed cpu nodes
+ */
+void __init arm_dt_init_cpu_maps(void)
+{
+	/*
+	 * Temp logical map is initialized with UINT_MAX values that are
+	 * considered invalid logical map entries since the logical map must
+	 * contain a list of MPIDR[23:0] values where MPIDR[31:24] must
+	 * read as 0.
+	 */
+	struct device_node *cpu, *cpus;
+	u32 i, j, cpuidx = 1;
+	u32 mpidr = is_smp() ? read_cpuid_mpidr() & MPIDR_HWID_BITMASK : 0;
+
+	u32 tmp_map[NR_CPUS] = { [0 ... NR_CPUS-1] = UINT_MAX };
+	bool bootcpu_valid = false;
+	cpus = of_find_node_by_path("/cpus");
+
+	if (!cpus)
+		return;
+
+	for_each_child_of_node(cpus, cpu) {
+		u32 hwid;
+
+		pr_debug(" * %s...\n", cpu->full_name);
+		/*
+		 * A device tree containing CPU nodes with missing "reg"
+		 * properties is considered invalid to build the
+		 * cpu_logical_map.
+		 */
+		if (of_property_read_u32(cpu, "reg", &hwid)) {
+			pr_debug(" * %s missing reg property\n",
+				     cpu->full_name);
+			return;
+		}
+
+		/*
+		 * 8 MSBs must be set to 0 in the DT since the reg property
+		 * defines the MPIDR[23:0].
+		 */
+		if (hwid & ~MPIDR_HWID_BITMASK)
+			return;
+
+		/*
+		 * Duplicate MPIDRs are a recipe for disaster.
+		 * Scan all initialized entries and check for
+		 * duplicates. If any is found just bail out.
+		 * temp values were initialized to UINT_MAX
+		 * to avoid matching valid MPIDR[23:0] values.
+		 */
+		for (j = 0; j < cpuidx; j++)
+			if (WARN(tmp_map[j] == hwid, "Duplicate /cpu reg "
+						     "properties in the DT\n"))
+				return;
+
+		/*
+		 * Build a stashed array of MPIDR values. Numbering scheme
+		 * requires that if detected the boot CPU must be assigned
+		 * logical id 0. Other CPUs get sequential indexes starting
+		 * from 1. If a CPU node with a reg property matching the
+		 * boot CPU MPIDR is detected, this is recorded so that the
+		 * logical map built from DT is validated and can be used
+		 * to override the map created in smp_setup_processor_id().
+		 */
+		if (hwid == mpidr) {
+			i = 0;
+			bootcpu_valid = true;
+		} else {
+			i = cpuidx++;
+		}
+
+		tmp_map[i] = hwid;
+
+		if (cpuidx > nr_cpu_ids)
+			break;
+	}
+
+	if (WARN(!bootcpu_valid, "DT missing boot CPU MPIDR[23:0], "
+				 "fall back to default cpu_logical_map\n"))
+		return;
+
+	/*
+	 * Since the boot CPU node contains proper data, and all nodes have
+	 * a reg property, the DT CPU list can be considered valid and the
+	 * logical map created in smp_setup_processor_id() can be overridden
+	 */
+	for (i = 0; i < cpuidx; i++) {
+		set_cpu_possible(i, true);
+		cpu_logical_map(i) = tmp_map[i];
+		pr_debug("cpu logical map 0x%x\n", cpu_logical_map(i));
+	}
+}
+
 /**
  * setup_machine_fdt - Machine setup when an dtb was passed to the kernel
  * @dt_phys: physical address of dt blob

commit ecea4ab6d3d8bb4122522398200f1cd2a06af6d5
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 22 10:58:34 2011 -0400

    arm: convert core files from module.h to export.h
    
    Many of the core ARM kernel files are not modules, but just
    including module.h for exporting symbols.  Now these files can
    use the lighter footprint export.h for this role.
    
    There are probably lots more, but ARM files of mach-* and plat-*
    don't get coverage via a simple yesconfig build.  They will have
    to be cleaned up and tested via using their respective configs.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index 1a33e9d6bb1f..bee7f9d47f02 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -9,7 +9,7 @@
  */
 
 #include <linux/init.h>
-#include <linux/module.h>
+#include <linux/export.h>
 #include <linux/errno.h>
 #include <linux/types.h>
 #include <linux/bootmem.h>

commit 08a543ad33fc188650801bd36eed4ffe272643e1
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Jul 26 03:19:06 2011 -0600

    irq: add irq_domain translation infrastructure
    
    This patch adds irq_domain infrastructure for translating from
    hardware irq numbers to linux irqs.  This is particularly important
    for architectures adding device tree support because the current
    implementation (excluding PowerPC and SPARC) cannot handle
    translation for more than a single interrupt controller.  irq_domain
    supports device tree translation for any number of interrupt
    controllers.
    
    This patch converts x86, Microblaze, ARM and MIPS to use irq_domain
    for device tree irq translation.  x86 is untested beyond compiling it,
    irq_domain is enabled for MIPS and Microblaze, but the old behaviour is
    preserved until the core code is modified to actually register an
    irq_domain yet.  On ARM it works and is required for much of the new
    ARM device tree board support.
    
    PowerPC has /not/ been converted to use this new infrastructure.  It
    is still missing some features before it can replace the virq
    infrastructure already in powerpc (see documentation on
    irq_domain_map/unmap for details).  Followup patches will add the
    missing pieces and migrate PowerPC to use irq_domain.
    
    SPARC has its own method of managing interrupts from the device tree
    and is unaffected by this change.
    
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index 0cdd7b456cb2..1a33e9d6bb1f 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -132,17 +132,3 @@ struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)
 
 	return mdesc_best;
 }
-
-/**
- * irq_create_of_mapping - Hook to resolve OF irq specifier into a Linux irq#
- *
- * Currently the mapping mechanism is trivial; simple flat hwirq numbers are
- * mapped 1:1 onto Linux irq numbers.  Cascaded irq controllers are not
- * supported.
- */
-unsigned int irq_create_of_mapping(struct device_node *controller,
-				   const u32 *intspec, unsigned int intsize)
-{
-	return intspec[0];
-}
-EXPORT_SYMBOL_GPL(irq_create_of_mapping);

commit f506cd48a4236b7045d092c9b92709ae6b4bdaf0
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Thu Jun 9 04:58:36 2011 +0100

    ARM: 6953/1: DT: don't try to access physical address zero
    
    If the DT physical address is zero, this is equivalent to no DT.
    Especially when the actual RAM physical address is not located at zero,
    the result of phys_to_virt() would point to la-la-land and crash the
    kernel, which crash is completely silent this early during boot.
    
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index a701e4226a6c..0cdd7b456cb2 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -76,6 +76,9 @@ struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)
 	unsigned long dt_root;
 	const char *model;
 
+	if (!dt_phys)
+		return NULL;
+
 	devtree = phys_to_virt(dt_phys);
 
 	/* check device tree validity */

commit 93c02ab40ae6e06cb24d14845d9f008fdd24f43d
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Apr 28 14:27:21 2011 -0600

    arm/dt: probe for platforms via the device tree
    
    If a dtb is passed to the kernel then the kernel needs to iterate
    through compiled-in mdescs looking for one that matches and move the
    dtb data to a safe location before it gets accidentally overwritten by
    the kernel.
    
    This patch creates a new function, setup_machine_fdt() which is
    analogous to the setup_machine_atags() created in the previous patch.
    It does all the early setup needed to use a device tree machine
    description.
    
    v5: - Print warning with neither dtb nor atags are passed to the kernel
        - Fix bug in setting of __machine_arch_type to the selected machine,
          not just the last machine in the list.
          Reported-by: Tixy <tixy@yxit.co.uk>
        - Copy command line directly into boot_command_line instead of cmd_line
    v4: - Dump some output when a matching machine_desc cannot be found
    v3: - Added processing of reserved list.
        - Backed out the v2 change that copied instead of reserved the
          dtb.  dtb is reserved again and the real problem was fixed by
          using alloc_bootmem_align() for early allocation of RAM for
          unflattening the tree.
        - Moved cmd_line and initrd changes to earlier patch to make series
          bisectable.
    v2: Changed to save the dtb by copying into an allocated buffer.
        - Since the dtb will very likely be passed in the first 16k of ram
          where the interrupt vectors live, memblock_reserve() is
          insufficient to protect the dtb data.
    
    [based on work originally written by Jeremy Kerr <jeremy.kerr@canonical.com>]
    Tested-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index 75e3df85b88c..a701e4226a6c 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -21,6 +21,8 @@
 
 #include <asm/setup.h>
 #include <asm/page.h>
+#include <asm/mach/arch.h>
+#include <asm/mach-types.h>
 
 void __init early_init_dt_add_memory_arch(u64 base, u64 size)
 {
@@ -32,6 +34,102 @@ void * __init early_init_dt_alloc_memory_arch(u64 size, u64 align)
 	return alloc_bootmem_align(size, align);
 }
 
+void __init arm_dt_memblock_reserve(void)
+{
+	u64 *reserve_map, base, size;
+
+	if (!initial_boot_params)
+		return;
+
+	/* Reserve the dtb region */
+	memblock_reserve(virt_to_phys(initial_boot_params),
+			 be32_to_cpu(initial_boot_params->totalsize));
+
+	/*
+	 * Process the reserve map.  This will probably overlap the initrd
+	 * and dtb locations which are already reserved, but overlaping
+	 * doesn't hurt anything
+	 */
+	reserve_map = ((void*)initial_boot_params) +
+			be32_to_cpu(initial_boot_params->off_mem_rsvmap);
+	while (1) {
+		base = be64_to_cpup(reserve_map++);
+		size = be64_to_cpup(reserve_map++);
+		if (!size)
+			break;
+		memblock_reserve(base, size);
+	}
+}
+
+/**
+ * setup_machine_fdt - Machine setup when an dtb was passed to the kernel
+ * @dt_phys: physical address of dt blob
+ *
+ * If a dtb was passed to the kernel in r2, then use it to choose the
+ * correct machine_desc and to setup the system.
+ */
+struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)
+{
+	struct boot_param_header *devtree;
+	struct machine_desc *mdesc, *mdesc_best = NULL;
+	unsigned int score, mdesc_score = ~1;
+	unsigned long dt_root;
+	const char *model;
+
+	devtree = phys_to_virt(dt_phys);
+
+	/* check device tree validity */
+	if (be32_to_cpu(devtree->magic) != OF_DT_HEADER)
+		return NULL;
+
+	/* Search the mdescs for the 'best' compatible value match */
+	initial_boot_params = devtree;
+	dt_root = of_get_flat_dt_root();
+	for_each_machine_desc(mdesc) {
+		score = of_flat_dt_match(dt_root, mdesc->dt_compat);
+		if (score > 0 && score < mdesc_score) {
+			mdesc_best = mdesc;
+			mdesc_score = score;
+		}
+	}
+	if (!mdesc_best) {
+		const char *prop;
+		long size;
+
+		early_print("\nError: unrecognized/unsupported "
+			    "device tree compatible list:\n[ ");
+
+		prop = of_get_flat_dt_prop(dt_root, "compatible", &size);
+		while (size > 0) {
+			early_print("'%s' ", prop);
+			size -= strlen(prop) + 1;
+			prop += strlen(prop) + 1;
+		}
+		early_print("]\n\n");
+
+		dump_machine_table(); /* does not return */
+	}
+
+	model = of_get_flat_dt_prop(dt_root, "model", NULL);
+	if (!model)
+		model = of_get_flat_dt_prop(dt_root, "compatible", NULL);
+	if (!model)
+		model = "<unknown>";
+	pr_info("Machine: %s, model: %s\n", mdesc_best->name, model);
+
+	/* Retrieve various information from the /chosen node */
+	of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);
+	/* Initialize {size,address}-cells info */
+	of_scan_flat_dt(early_init_dt_scan_root, NULL);
+	/* Setup memory, calling early_init_dt_add_memory_arch */
+	of_scan_flat_dt(early_init_dt_scan_memory, NULL);
+
+	/* Change machine number to match the mdesc we're using */
+	__machine_arch_type = mdesc_best->nr;
+
+	return mdesc_best;
+}
+
 /**
  * irq_create_of_mapping - Hook to resolve OF irq specifier into a Linux irq#
  *

commit 9eb8f6743b076b67f00776cda4330c802e157b41
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Apr 28 14:27:20 2011 -0600

    arm/dt: Allow CONFIG_OF on ARM
    
    Add some basic empty infrastructure for DT support on ARM.
    
    v5: - Fix off-by-one error in size calculation of initrd
        - Stop mucking with cmd_line, and load command line from dt into
          boot_command_line instead which matches the behaviour of ATAGS booting
    v3: - moved cmd_line export and initrd setup to this patch to make the
          series bisectable.
        - switched to alloc_bootmem_align() for allocation when
          unflattening the device tree.  memblock_alloc() was not the
          right interface.
    
    Signed-off-by: Jeremy Kerr <jeremy.kerr@canonical.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
new file mode 100644
index 000000000000..75e3df85b88c
--- /dev/null
+++ b/arch/arm/kernel/devtree.c
@@ -0,0 +1,47 @@
+/*
+ *  linux/arch/arm/kernel/devtree.c
+ *
+ *  Copyright (C) 2009 Canonical Ltd. <jeremy.kerr@canonical.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/bootmem.h>
+#include <linux/memblock.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+
+#include <asm/setup.h>
+#include <asm/page.h>
+
+void __init early_init_dt_add_memory_arch(u64 base, u64 size)
+{
+	arm_add_memory(base, size);
+}
+
+void * __init early_init_dt_alloc_memory_arch(u64 size, u64 align)
+{
+	return alloc_bootmem_align(size, align);
+}
+
+/**
+ * irq_create_of_mapping - Hook to resolve OF irq specifier into a Linux irq#
+ *
+ * Currently the mapping mechanism is trivial; simple flat hwirq numbers are
+ * mapped 1:1 onto Linux irq numbers.  Cascaded irq controllers are not
+ * supported.
+ */
+unsigned int irq_create_of_mapping(struct device_node *controller,
+				   const u32 *intspec, unsigned int intsize)
+{
+	return intspec[0];
+}
+EXPORT_SYMBOL_GPL(irq_create_of_mapping);
