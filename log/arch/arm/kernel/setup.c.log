commit 3e70ac06913ba5a3c613affb7c8df9fd6b4b24f9
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Wed Dec 18 16:44:47 2019 -0500

    arch/arm/setup: Drop dummy_con initialization
    
    con_init in tty/vt.c will now set conswitchp to dummy_con if it's unset.
    Drop it from arch setup code.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20191218214506.49252-6-nivedita@alum.mit.edu
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index d0a464e317ea..d8e18cdd96d3 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -1164,8 +1164,6 @@ void __init setup_arch(char **cmdline_p)
 #ifdef CONFIG_VT
 #if defined(CONFIG_VGA_CONSOLE)
 	conswitchp = &vga_con;
-#elif defined(CONFIG_DUMMY_CONSOLE)
-	conswitchp = &dummy_con;
 #endif
 #endif
 

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 5d78b6ac0429..d0a464e317ea 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -1,11 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  linux/arch/arm/kernel/setup.c
  *
  *  Copyright (C) 1995-2001 Russell King
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 #include <linux/efi.h>
 #include <linux/export.h>

commit 8a7f97b902f4fb0d94b355b6b3f1fbd7154cafb9
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Mar 11 23:30:31 2019 -0700

    treewide: add checks for the return value of memblock_alloc*()
    
    Add check for the return value of memblock_alloc*() functions and call
    panic() in case of error.  The panic message repeats the one used by
    panicing memblock allocators with adjustment of parameters to include
    only relevant ones.
    
    The replacement was mostly automated with semantic patches like the one
    below with manual massaging of format strings.
    
      @@
      expression ptr, size, align;
      @@
      ptr = memblock_alloc(size, align);
      + if (!ptr)
      +     panic("%s: Failed to allocate %lu bytes align=0x%lx\n", __func__, size, align);
    
    [anders.roxell@linaro.org: use '%pa' with 'phys_addr_t' type]
      Link: http://lkml.kernel.org/r/20190131161046.21886-1-anders.roxell@linaro.org
    [rppt@linux.ibm.com: fix format strings for panics after memblock_alloc]
      Link: http://lkml.kernel.org/r/1548950940-15145-1-git-send-email-rppt@linux.ibm.com
    [rppt@linux.ibm.com: don't panic if the allocation in sparse_buffer_init fails]
      Link: http://lkml.kernel.org/r/20190131074018.GD28876@rapoport-lnx
    [akpm@linux-foundation.org: fix xtensa printk warning]
    Link: http://lkml.kernel.org/r/1548057848-15136-20-git-send-email-rppt@linux.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Anders Roxell <anders.roxell@linaro.org>
    Reviewed-by: Guo Ren <ren_guo@c-sky.com>                [c-sky]
    Acked-by: Paul Burton <paul.burton@mips.com>            [MIPS]
    Acked-by: Heiko Carstens <heiko.carstens@de.ibm.com>    [s390]
    Reviewed-by: Juergen Gross <jgross@suse.com>            [Xen]
    Reviewed-by: Geert Uytterhoeven <geert@linux-m68k.org>  [m68k]
    Acked-by: Max Filippov <jcmvbkbc@gmail.com>             [xtensa]
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Christophe Leroy <christophe.leroy@c-s.fr>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Dennis Zhou <dennis@kernel.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 375b13f7e780..5d78b6ac0429 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -867,6 +867,9 @@ static void __init request_standard_resources(const struct machine_desc *mdesc)
 		boot_alias_start = phys_to_idmap(start);
 		if (arm_has_idmap_alias() && boot_alias_start != IDMAP_INVALID_ADDR) {
 			res = memblock_alloc(sizeof(*res), SMP_CACHE_BYTES);
+			if (!res)
+				panic("%s: Failed to allocate %zu bytes\n",
+				      __func__, sizeof(*res));
 			res->name = "System RAM (boot alias)";
 			res->start = boot_alias_start;
 			res->end = phys_to_idmap(end);
@@ -875,6 +878,9 @@ static void __init request_standard_resources(const struct machine_desc *mdesc)
 		}
 
 		res = memblock_alloc(sizeof(*res), SMP_CACHE_BYTES);
+		if (!res)
+			panic("%s: Failed to allocate %zu bytes\n", __func__,
+			      sizeof(*res));
 		res->name  = "System RAM";
 		res->start = start;
 		res->end = end;

commit cfaa9f029f8141e9ee8d621a126d9dd4cc89aa63
Merge: 1ce80e0fe98e 383fb3ee8024
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Nov 18 10:45:09 2018 -0800

    Merge branch 'spectre' of git://git.armlinux.org.uk/~rmk/linux-arm
    
    Pull ARM spectre updates from Russell King:
     "These are the currently known final bits that resolve the Spectre
      issues. big.Little systems used to be sufficiently identical in that
      there were no differences between individual CPUs in the system that
      mattered to the kernel. With the advent of the Spectre problem, the
      CPUs now have differences in how the workaround is applied.
    
      As a result of previous Spectre patches, these systems ended up
      reporting quite a lot of:
    
         "CPUx: Spectre v2: incorrect context switching function, system vulnerable"
    
      messages due to the action of the big.Little switcher causing the CPUs
      to be re-initialised regularly. This series resolves that issue by
      making the CPU vtable unique to each CPU.
    
      However, since this is used very early, before per-cpu is setup,
      per-cpu can't be used. We also have a problem that two of the methods
      are not called from preempt-safe paths, but thankfully these remain
      identical between all CPUs in the system. To make sure, we validate
      that these are identical during boot"
    
    * 'spectre' of git://git.armlinux.org.uk/~rmk/linux-arm:
      ARM: spectre-v2: per-CPU vtables to work around big.Little systems
      ARM: add PROC_VTABLE and PROC_TABLE macros
      ARM: clean up per-processor check_bugs method call
      ARM: split out processor lookup
      ARM: make lookup_processor_type() non-__init

commit 383fb3ee8024d596f488d2dbaf45e572897acbdb
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Thu Jul 19 12:21:31 2018 +0100

    ARM: spectre-v2: per-CPU vtables to work around big.Little systems
    
    In big.Little systems, some CPUs require the Spectre workarounds in
    paths such as the context switch, but other CPUs do not.  In order
    to handle these differences, we need per-CPU vtables.
    
    We are unable to use the kernel's per-CPU variables to support this
    as per-CPU is not initialised at times when we need access to the
    vtables, so we have to use an array indexed by logical CPU number.
    
    We use an array-of-pointers to avoid having function pointers in
    the kernel's read/write .data section.
    
    Reviewed-by: Julien Thierry <julien.thierry@arm.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index c214bd14a1fe..cd46a595422c 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -115,6 +115,11 @@ EXPORT_SYMBOL(elf_hwcap2);
 
 #ifdef MULTI_CPU
 struct processor processor __ro_after_init;
+#if defined(CONFIG_BIG_LITTLE) && defined(CONFIG_HARDEN_BRANCH_PREDICTOR)
+struct processor *cpu_vtable[NR_CPUS] = {
+	[0] = &processor,
+};
+#endif
 #endif
 #ifdef MULTI_TLB
 struct cpu_tlb_fns cpu_tlb __ro_after_init;

commit e209950fdd065d2cc46e6338e47e52841b830cba
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Thu Jul 19 12:17:38 2018 +0100

    ARM: add PROC_VTABLE and PROC_TABLE macros
    
    Allow the way we access members of the processor vtable to be changed
    at compile time.  We will need to move to per-CPU vtables to fix the
    Spectre variant 2 issues on big.Little systems.
    
    However, we have a couple of calls that do not need the vtable
    treatment, and indeed cause a kernel warning due to the (later) use
    of smp_processor_id(), so also introduce the PROC_TABLE macro for
    these which always use CPU 0's function pointers.
    
    Reviewed-by: Julien Thierry <julien.thierry@arm.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 05a4eb6b0d01..c214bd14a1fe 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -693,9 +693,7 @@ static void __init setup_processor(void)
 	cpu_name = list->cpu_name;
 	__cpu_architecture = __get_cpu_architecture();
 
-#ifdef MULTI_CPU
-	processor = *list->proc;
-#endif
+	init_proc_vtable(list->proc);
 #ifdef MULTI_TLB
 	cpu_tlb = *list->tlb;
 #endif

commit 65987a8553061515b5851b472081aedb9837a391
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Thu Jul 19 11:59:56 2018 +0100

    ARM: split out processor lookup
    
    Split out the lookup of the processor type and associated error handling
    from the rest of setup_processor() - we will need to use this in the
    secondary CPU bringup path for big.Little Spectre variant 2 mitigation.
    
    Reviewed-by: Julien Thierry <julien.thierry@arm.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index fc40a2b40595..05a4eb6b0d01 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -667,22 +667,29 @@ static void __init smp_build_mpidr_hash(void)
 }
 #endif
 
-static void __init setup_processor(void)
+/*
+ * locate processor in the list of supported processor types.  The linker
+ * builds this table for us from the entries in arch/arm/mm/proc-*.S
+ */
+struct proc_info_list *lookup_processor(u32 midr)
 {
-	struct proc_info_list *list;
+	struct proc_info_list *list = lookup_processor_type(midr);
 
-	/*
-	 * locate processor in the list of supported processor
-	 * types.  The linker builds this table for us from the
-	 * entries in arch/arm/mm/proc-*.S
-	 */
-	list = lookup_processor_type(read_cpuid_id());
 	if (!list) {
-		pr_err("CPU configuration botched (ID %08x), unable to continue.\n",
-		       read_cpuid_id());
-		while (1);
+		pr_err("CPU%u: configuration botched (ID %08x), CPU halted\n",
+		       smp_processor_id(), midr);
+		while (1)
+		/* can't use cpu_relax() here as it may require MMU setup */;
 	}
 
+	return list;
+}
+
+static void __init setup_processor(void)
+{
+	unsigned int midr = read_cpuid_id();
+	struct proc_info_list *list = lookup_processor(midr);
+
 	cpu_name = list->cpu_name;
 	__cpu_architecture = __get_cpu_architecture();
 
@@ -700,7 +707,7 @@ static void __init setup_processor(void)
 #endif
 
 	pr_info("CPU: %s [%08x] revision %d (ARMv%s), cr=%08lx\n",
-		cpu_name, read_cpuid_id(), read_cpuid_id() & 15,
+		list->cpu_name, midr, midr & 15,
 		proc_arch[cpu_architecture()], get_cr());
 
 	snprintf(init_utsname()->machine, __NEW_UTS_LEN + 1, "%s%c",

commit 7e1c4e27928e5f87b9b1eaf06dc31773b2f1e7f1
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:57 2018 -0700

    memblock: stop using implicit alignment to SMP_CACHE_BYTES
    
    When a memblock allocation APIs are called with align = 0, the alignment
    is implicitly set to SMP_CACHE_BYTES.
    
    Implicit alignment is done deep in the memblock allocator and it can
    come as a surprise.  Not that such an alignment would be wrong even
    when used incorrectly but it is better to be explicit for the sake of
    clarity and the prinicple of the least surprise.
    
    Replace all such uses of memblock APIs with the 'align' parameter
    explicitly set to SMP_CACHE_BYTES and stop implicit alignment assignment
    in the memblock internal allocation functions.
    
    For the case when memblock APIs are used via helper functions, e.g.  like
    iommu_arena_new_node() in Alpha, the helper functions were detected with
    Coccinelle's help and then manually examined and updated where
    appropriate.
    
    The direct memblock APIs users were updated using the semantic patch below:
    
    @@
    expression size, min_addr, max_addr, nid;
    @@
    (
    |
    - memblock_alloc_try_nid_raw(size, 0, min_addr, max_addr, nid)
    + memblock_alloc_try_nid_raw(size, SMP_CACHE_BYTES, min_addr, max_addr,
    nid)
    |
    - memblock_alloc_try_nid_nopanic(size, 0, min_addr, max_addr, nid)
    + memblock_alloc_try_nid_nopanic(size, SMP_CACHE_BYTES, min_addr, max_addr,
    nid)
    |
    - memblock_alloc_try_nid(size, 0, min_addr, max_addr, nid)
    + memblock_alloc_try_nid(size, SMP_CACHE_BYTES, min_addr, max_addr, nid)
    |
    - memblock_alloc(size, 0)
    + memblock_alloc(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_raw(size, 0)
    + memblock_alloc_raw(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_from(size, 0, min_addr)
    + memblock_alloc_from(size, SMP_CACHE_BYTES, min_addr)
    |
    - memblock_alloc_nopanic(size, 0)
    + memblock_alloc_nopanic(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_low(size, 0)
    + memblock_alloc_low(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_low_nopanic(size, 0)
    + memblock_alloc_low_nopanic(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_from_nopanic(size, 0, min_addr)
    + memblock_alloc_from_nopanic(size, SMP_CACHE_BYTES, min_addr)
    |
    - memblock_alloc_node(size, 0, nid)
    + memblock_alloc_node(size, SMP_CACHE_BYTES, nid)
    )
    
    [mhocko@suse.com: changelog update]
    [akpm@linux-foundation.org: coding-style fixes]
    [rppt@linux.ibm.com: fix missed uses of implicit alignment]
      Link: http://lkml.kernel.org/r/20181016133656.GA10925@rapoport-lnx
    Link: http://lkml.kernel.org/r/1538687224-17535-1-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Suggested-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Paul Burton <paul.burton@mips.com>    [MIPS]
    Acked-by: Michael Ellerman <mpe@ellerman.id.au> [powerpc]
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 840a4adc69fc..ac7e08886863 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -856,7 +856,7 @@ static void __init request_standard_resources(const struct machine_desc *mdesc)
 		 */
 		boot_alias_start = phys_to_idmap(start);
 		if (arm_has_idmap_alias() && boot_alias_start != IDMAP_INVALID_ADDR) {
-			res = memblock_alloc(sizeof(*res), 0);
+			res = memblock_alloc(sizeof(*res), SMP_CACHE_BYTES);
 			res->name = "System RAM (boot alias)";
 			res->start = boot_alias_start;
 			res->end = phys_to_idmap(end);
@@ -864,7 +864,7 @@ static void __init request_standard_resources(const struct machine_desc *mdesc)
 			request_resource(&iomem_resource, res);
 		}
 
-		res = memblock_alloc(sizeof(*res), 0);
+		res = memblock_alloc(sizeof(*res), SMP_CACHE_BYTES);
 		res->name  = "System RAM";
 		res->start = start;
 		res->end = end;

commit 57c8a661d95dff48dd9c2f2496139082bbaf241a
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:49 2018 -0700

    mm: remove include/linux/bootmem.h
    
    Move remaining definitions and declarations from include/linux/bootmem.h
    into include/linux/memblock.h and remove the redundant header.
    
    The includes were replaced with the semantic patch below and then
    semi-automated removal of duplicated '#include <linux/memblock.h>
    
    @@
    @@
    - #include <linux/bootmem.h>
    + #include <linux/memblock.h>
    
    [sfr@canb.auug.org.au: dma-direct: fix up for the removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181002185342.133d1680@canb.auug.org.au
    [sfr@canb.auug.org.au: powerpc: fix up for removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181005161406.73ef8727@canb.auug.org.au
    [sfr@canb.auug.org.au: x86/kaslr, ACPI/NUMA: fix for linux/bootmem.h removal]
      Link: http://lkml.kernel.org/r/20181008190341.5e396491@canb.auug.org.au
    Link: http://lkml.kernel.org/r/1536927045-23536-30-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 39e6090d23ac..840a4adc69fc 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -16,7 +16,6 @@
 #include <linux/utsname.h>
 #include <linux/initrd.h>
 #include <linux/console.h>
-#include <linux/bootmem.h>
 #include <linux/seq_file.h>
 #include <linux/screen_info.h>
 #include <linux/of_platform.h>

commit eb31d559f1e8390195372cd51cfb198da8bc84b9
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:08:04 2018 -0700

    memblock: remove _virt from APIs returning virtual address
    
    The conversion is done using
    
    sed -i 's@memblock_virt_alloc@memblock_alloc@g' \
            $(git grep -l memblock_virt_alloc)
    
    Link: http://lkml.kernel.org/r/1536927045-23536-8-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 4c249cb261f3..39e6090d23ac 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -857,7 +857,7 @@ static void __init request_standard_resources(const struct machine_desc *mdesc)
 		 */
 		boot_alias_start = phys_to_idmap(start);
 		if (arm_has_idmap_alias() && boot_alias_start != IDMAP_INVALID_ADDR) {
-			res = memblock_virt_alloc(sizeof(*res), 0);
+			res = memblock_alloc(sizeof(*res), 0);
 			res->name = "System RAM (boot alias)";
 			res->start = boot_alias_start;
 			res->end = phys_to_idmap(end);
@@ -865,7 +865,7 @@ static void __init request_standard_resources(const struct machine_desc *mdesc)
 			request_resource(&iomem_resource, res);
 		}
 
-		res = memblock_virt_alloc(sizeof(*res), 0);
+		res = memblock_alloc(sizeof(*res), 0);
 		res->name  = "System RAM";
 		res->start = start;
 		res->end = end;

commit 4c301f9b6a94bb383089bc847083e287e9bfc96e
Author: Palmer Dabbelt <palmer@sifive.com>
Date:   Fri Jun 22 10:01:23 2018 -0700

    ARM: Convert to GENERIC_IRQ_MULTI_HANDLER
    
    Converts the ARM interrupt code to use the recently added
    GENERIC_IRQ_MULTI_HANDLER, which is essentially just a copy of ARM's
    existhing MULTI_IRQ_HANDLER.  The only changes are:
    
    * handle_arch_irq is now defined in a generic C file instead of an
      arm-specific assembly file.
    
    * handle_arch_irq is now marked as __ro_after_init.
    
    Signed-off-by: Palmer Dabbelt <palmer@sifive.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux@armlinux.org.uk
    Cc: catalin.marinas@arm.com
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: jonas@southpole.se
    Cc: stefan.kristiansson@saunalahti.fi
    Cc: shorne@gmail.com
    Cc: jason@lakedaemon.net
    Cc: marc.zyngier@arm.com
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: nicolas.pitre@linaro.org
    Cc: vladimir.murzin@arm.com
    Cc: keescook@chromium.org
    Cc: jinb.park7@gmail.com
    Cc: yamada.masahiro@socionext.com
    Cc: alexandre.belloni@bootlin.com
    Cc: pombredanne@nexb.com
    Cc: Greg KH <gregkh@linuxfoundation.org>
    Cc: kstewart@linuxfoundation.org
    Cc: jhogan@kernel.org
    Cc: mark.rutland@arm.com
    Cc: ard.biesheuvel@linaro.org
    Cc: james.morse@arm.com
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: openrisc@lists.librecores.org
    Link: https://lkml.kernel.org/r/20180622170126.6308-3-palmer@sifive.com

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 35ca494c028c..4c249cb261f3 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -1145,7 +1145,7 @@ void __init setup_arch(char **cmdline_p)
 
 	reserve_crashkernel();
 
-#ifdef CONFIG_MULTI_IRQ_HANDLER
+#ifdef CONFIG_GENERIC_IRQ_MULTI_HANDLER
 	handle_arch_irq = mdesc->handle_irq;
 #endif
 

commit d4a451d5fc849f9a0a133255ed197b148fc323d0
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Apr 3 16:24:20 2018 +0200

    arch: remove the ARCH_PHYS_ADDR_T_64BIT config symbol
    
    Instead select the PHYS_ADDR_T_64BIT for 32-bit architectures that need a
    64-bit phys_addr_t type directly.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index fc40a2b40595..35ca494c028c 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -754,7 +754,7 @@ int __init arm_add_memory(u64 start, u64 size)
 	else
 		size -= aligned_start - start;
 
-#ifndef CONFIG_ARCH_PHYS_ADDR_T_64BIT
+#ifndef CONFIG_PHYS_ADDR_T_64BIT
 	if (aligned_start > ULONG_MAX) {
 		pr_crit("Ignoring memory at 0x%08llx outside 32-bit physical address space\n",
 			(long long)start);

commit 99cf8f903148347e3d2ac86ffe98bb04bebc6983
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Thu Sep 21 12:06:20 2017 +0100

    ARM: better diagnostics with missing/corrupt dtb
    
    With a kernel containing both DT and atag support, the diagnostics
    output when the dtb is missing or corrupt assume that we're trying
    to boot using atags and the machine ID, and only print the machine
    ID.  This is not useful for diagnosing a missing or corrupt dtb.
    
    Move the message into arch/arm/kernel/setup.c, and print the address
    of the dtb/atag list, and the first 16 bytes of memory of the dtb or
    atag list.
    
    This allows us to see whether the dtb was corrupted in some way,
    causing the fallback to the machine ID / atag list.
    
    Tested-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 8e9a3e40d949..fc40a2b40595 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -1069,6 +1069,16 @@ void __init setup_arch(char **cmdline_p)
 	mdesc = setup_machine_fdt(__atags_pointer);
 	if (!mdesc)
 		mdesc = setup_machine_tags(__atags_pointer, __machine_arch_type);
+	if (!mdesc) {
+		early_print("\nError: invalid dtb and unrecognized/unsupported machine ID\n");
+		early_print("  r1=0x%08x, r2=0x%08x\n", __machine_arch_type,
+			    __atags_pointer);
+		if (__atags_pointer)
+			early_print("  r2[]=%*ph\n", 16,
+				    phys_to_virt(__atags_pointer));
+		dump_machine_table();
+	}
+
 	machine_desc = mdesc;
 	machine_name = mdesc->name;
 	dump_stack_set_arch_desc("%s", mdesc->name);

commit 67556d7a851c20116923c23f1d49ecdec954e3a0
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Wed Jul 19 23:01:38 2017 +0100

    ARM: kexec: avoid allocating crashkernel region outside lowmem
    
    Allocating the crashkernel region outside lowmem causes the kernel to
    oops while trying to kexec into the new kernel:
    
    Loading crashdump kernel...
    Unable to handle kernel NULL pointer dereference at virtual address 00000000
    pgd = edd70000
    [00000000] *pgd=de19e835
    Internal error: Oops: 817 [#2] SMP ARM
    Modules linked in: ...
    CPU: 0 PID: 689 Comm: sh Not tainted 4.12.0-rc3-next-20170601-04015-gc3a5a20
    Hardware name: Generic DRA74X (Flattened Device Tree)
    task: edb32f00 task.stack: edf18000
    PC is at memcpy+0x50/0x330
    LR is at 0xe3c34001
    pc : [<c04baf30>]    lr : [<e3c34001>]    psr: 800c0193
    sp : edf19c2c  ip : 0a000001  fp : c0553170
    r10: c055316e  r9 : 00000001  r8 : e3130001
    r7 : e4903004  r6 : 0a000014  r5 : e3500000  r4 : e59f106c
    r3 : e59f0074  r2 : ffffffe8  r1 : c010fb88  r0 : 00000000
    Flags: Nzcv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment none
    Control: 10c5387d  Table: add7006a  DAC: 00000051
    Process sh (pid: 689, stack limit = 0xedf18218)
    Stack: (0xedf19c2c to 0xedf1a000)
    ...
    [<c04baf30>] (memcpy) from [<c010fae0>] (machine_kexec+0xa8/0x12c)
    [<c010fae0>] (machine_kexec) from [<c01e4104>] (__crash_kexec+0x5c/0x98)
    [<c01e4104>] (__crash_kexec) from [<c01e419c>] (crash_kexec+0x5c/0x68)
    [<c01e419c>] (crash_kexec) from [<c010c5c0>] (die+0x228/0x490)
    [<c010c5c0>] (die) from [<c011e520>] (__do_kernel_fault.part.0+0x54/0x1e4)
    [<c011e520>] (__do_kernel_fault.part.0) from [<c082412c>] (do_page_fault+0x1e8/0x400)
    [<c082412c>] (do_page_fault) from [<c010135c>] (do_DataAbort+0x38/0xb8)
    [<c010135c>] (do_DataAbort) from [<c0823584>] (__dabt_svc+0x64/0xa0)
    
    This is caused by image->control_code_page being a highmem page, so
    page_address(image->control_code_page) returns NULL.  In any case, we
    don't want the control page to be a highmem page.
    
    We already limit the crash kernel region to the top of 32-bit physical
    memory space.  Also limit it to the top of lowmem in physical space.
    
    Reported-by: Keerthy <j-keerthy@ti.com>
    Tested-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 4e80bf7420d4..8e9a3e40d949 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -987,6 +987,9 @@ static void __init reserve_crashkernel(void)
 
 	if (crash_base <= 0) {
 		unsigned long long crash_max = idmap_to_phys((u32)~0);
+		unsigned long long lowmem_max = __pa(high_memory - 1) + 1;
+		if (crash_max > lowmem_max)
+			crash_max = lowmem_max;
 		crash_base = memblock_find_in_range(CRASH_ALIGN, crash_max,
 						    crash_size, CRASH_ALIGN);
 		if (!crash_base) {

commit d360a687d99577110c181e67ebfb9a1b6fed63a2
Author: Vladimir Murzin <vladimir.murzin@arm.com>
Date:   Mon Jun 12 13:35:52 2017 +0100

    ARM: 8682/1: V7M: Set cacheid iff DminLine or IminLine is nonzero
    
    Cache support is optional feature in M-class cores, thus DminLine or
    IminLine of Cache Type Register is zero if caches are not implemented,
    but we check the whole CTR which has other features encoded there.
    Let's be more precise and check for DminLine and IminLine of CTR
    before we set cacheid.
    
    Signed-off-by: Vladimir Murzin <vladimir.murzin@arm.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 32e1a9513dc7..4e80bf7420d4 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -315,7 +315,7 @@ static void __init cacheid_init(void)
 	if (arch >= CPU_ARCH_ARMv6) {
 		unsigned int cachetype = read_cpuid_cachetype();
 
-		if ((arch == CPU_ARCH_ARMv7M) && !cachetype) {
+		if ((arch == CPU_ARCH_ARMv7M) && !(cachetype & 0xf000f)) {
 			cacheid = 0;
 		} else if ((cachetype & (7 << 29)) == 4 << 29) {
 			/* ARMv7 register format */

commit b089c31c519c3906c14801b6ec483e18a5152a50
Author: Jon Medhurst <tixy@linaro.org>
Date:   Mon Apr 10 11:13:59 2017 +0100

    ARM: 8667/3: Fix memory attribute inconsistencies when using fixmap
    
    To cope with the variety in ARM architectures and configurations, the
    pagetable attributes for kernel memory are generated at runtime to match
    the system the kernel finds itself on. This calculated value is stored
    in pgprot_kernel.
    
    However, when early fixmap support was added for ARM (commit
    a5f4c561b3b1) the attributes used for mappings were hard coded because
    pgprot_kernel is not set up early enough. Unfortunately, when fixmap is
    used after early boot this means the memory being mapped can have
    different attributes to existing mappings, potentially leading to
    unpredictable behaviour. A specific problem also exists due to the hard
    coded values not include the 'shareable' attribute which means on
    systems where this matters (e.g. those with multiple CPU clusters) the
    cache contents for a memory location can become inconsistent between
    CPUs.
    
    To resolve these issues we change fixmap to use the same memory
    attributes (from pgprot_kernel) that the rest of the kernel uses. To
    enable this we need to refactor the initialisation code so
    build_mem_type_table() is called early enough. Note, that relies on early
    param parsing for memory type overrides passed via the kernel command
    line, so we need to make sure this call is still after
    parse_early_params().
    
    [ardb: keep early_fixmap_init() before param parsing, for earlycon]
    
    Fixes: a5f4c561b3b1 ("ARM: 8415/1: early fixmap support for earlycon")
    Cc: <stable@vger.kernel.org> # v4.3+
    Tested-by: afzal mohammed <afzal.mohd.ma@gmail.com>
    Signed-off-by: Jon Medhurst <tixy@linaro.org>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index f4e54503afa9..32e1a9513dc7 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -80,7 +80,7 @@ __setup("fpe=", fpe_setup);
 
 extern void init_default_cache_policy(unsigned long);
 extern void paging_init(const struct machine_desc *desc);
-extern void early_paging_init(const struct machine_desc *);
+extern void early_mm_init(const struct machine_desc *);
 extern void adjust_lowmem_bounds(void);
 extern enum reboot_mode reboot_mode;
 extern void setup_dma_zone(const struct machine_desc *desc);
@@ -1088,7 +1088,7 @@ void __init setup_arch(char **cmdline_p)
 	parse_early_param();
 
 #ifdef CONFIG_MMU
-	early_paging_init(mdesc);
+	early_mm_init(mdesc);
 #endif
 	setup_dma_zone(mdesc);
 	xen_early_init();

commit 985626564eedc470ce2866e53938303368ad41b7
Author: Laura Abbott <labbott@redhat.com>
Date:   Fri Jan 13 22:51:45 2017 +0100

    ARM: 8637/1: Adjust memory boundaries after reservations
    
    adjust_lowmem_bounds is responsible for setting up the boundary for
    lowmem/highmem. This needs to be setup before memblock reservations can
    occur. At the time memblock reservations can occur, memory can also be
    removed from the system. The lowmem/highmem boundary and end of memory
    may be affected by this but it is currently not recalculated. On some
    systems this may be harmless, on others this may result in incorrect
    ranges being passed to the main memory allocator. Correct this by
    recalculating the lowmem/highmem boundary after all reservations have
    been made.
    
    Tested-by: Magnus Lilja <lilja.magnus@gmail.com>
    Signed-off-by: Laura Abbott <labbott@redhat.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 8a8051cf57d1..f4e54503afa9 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -1093,8 +1093,14 @@ void __init setup_arch(char **cmdline_p)
 	setup_dma_zone(mdesc);
 	xen_early_init();
 	efi_init();
+	/*
+	 * Make sure the calculation for lowmem/highmem is set appropriately
+	 * before reserving/allocating any mmeory
+	 */
 	adjust_lowmem_bounds();
 	arm_memblock_init(mdesc);
+	/* Memory may have been removed so recalculate the bounds. */
+	adjust_lowmem_bounds();
 
 	early_ioremap_reset();
 

commit 374d446d25d6271ee615952a3b7f123ba4983c35
Author: Laura Abbott <labbott@redhat.com>
Date:   Fri Jan 13 22:51:08 2017 +0100

    ARM: 8636/1: Cleanup sanity_check_meminfo
    
    The logic for sanity_check_meminfo has become difficult to
    follow. Clean up the code so it's more obvious what the code
    is actually trying to do. Additionally, meminfo is now removed
    so rename the function to better describe its purpose.
    
    Tested-by: Magnus Lilja <lilja.magnus@gmail.com>
    Reviewed-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Laura Abbott <lauraa@codeaurora.org>
    Signed-off-by: Laura Abbott <labbott@redhat.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 34e3f3c45634..8a8051cf57d1 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -81,7 +81,7 @@ __setup("fpe=", fpe_setup);
 extern void init_default_cache_policy(unsigned long);
 extern void paging_init(const struct machine_desc *desc);
 extern void early_paging_init(const struct machine_desc *);
-extern void sanity_check_meminfo(void);
+extern void adjust_lowmem_bounds(void);
 extern enum reboot_mode reboot_mode;
 extern void setup_dma_zone(const struct machine_desc *desc);
 
@@ -1093,7 +1093,7 @@ void __init setup_arch(char **cmdline_p)
 	setup_dma_zone(mdesc);
 	xen_early_init();
 	efi_init();
-	sanity_check_meminfo();
+	adjust_lowmem_bounds();
 	arm_memblock_init(mdesc);
 
 	early_ioremap_reset();

commit f5a5c89e36d0897b65e4e6bc2f646f75f8074263
Author: Jonathan Austin <jonathan.austin@arm.com>
Date:   Tue Aug 30 17:27:19 2016 +0100

    ARM: 8604/1: V7M: Add support for reading the CTR with read_cpuid_cachetype()
    
    With the addition of caches to the V7M Architecture a new Cache Type
    Register (CTR) is defined at 0xE000ED7C. This register serves the same
    purpose as the V7A/R version and accessed via the read_cpuid_cachetype.
    
    Signed-off-by: Jonathan Austin <jonathan.austin@arm.com>
    Signed-off-by: Vladimir Murzin <vladimir.murzin@arm.com>
    Tested-by: Andras Szemzo <sza@esh.hu>
    Tested-by: Joachim Eastwood <manabian@gmail.com>
    Tested-by: Alexandre TORGUE <alexandre.torgue@st.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index d7568808eb7b..34e3f3c45634 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -312,11 +312,12 @@ static void __init cacheid_init(void)
 {
 	unsigned int arch = cpu_architecture();
 
-	if (arch == CPU_ARCH_ARMv7M) {
-		cacheid = 0;
-	} else if (arch >= CPU_ARCH_ARMv6) {
+	if (arch >= CPU_ARCH_ARMv6) {
 		unsigned int cachetype = read_cpuid_cachetype();
-		if ((cachetype & (7 << 29)) == 4 << 29) {
+
+		if ((arch == CPU_ARCH_ARMv7M) && !cachetype) {
+			cacheid = 0;
+		} else if ((cachetype & (7 << 29)) == 4 << 29) {
 			/* ARMv7 register format */
 			arch = CPU_ARCH_ARMv7;
 			cacheid = CACHEID_VIPT_NONALIASING;

commit 26150aa96d60298de669e3d81a5b7e132b653ce7
Author: Jonathan Austin <jonathan.austin@arm.com>
Date:   Tue Aug 30 17:24:34 2016 +0100

    ARM: 8602/1: factor out CSSELR/CCSIDR operations that use cp15 directly
    
    Currently we use raw cp15 operations to access the cache setup data.
    
    This patch abstracts the CSSELR and CCSIDR accessors out to a header so
    that the implementation for them can be switched out as we do with other
    cpu/cachetype operations.
    
    Signed-off-by: Jonathan Austin <jonathan.austin@arm.com>
    Signed-off-by: Vladimir Murzin <vladimir.murzin@arm.com>
    Tested-by: Andras Szemzo <sza@esh.hu>
    Tested-by: Joachim Eastwood <manabian@gmail.com>
    Tested-by: Alexandre TORGUE <alexandre.torgue@st.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index aca999e17184..d7568808eb7b 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -290,12 +290,9 @@ static int cpu_has_aliasing_icache(unsigned int arch)
 	/* arch specifies the register format */
 	switch (arch) {
 	case CPU_ARCH_ARMv7:
-		asm("mcr	p15, 2, %0, c0, c0, 0 @ set CSSELR"
-		    : /* No output operands */
-		    : "r" (1));
+		set_csselr(CSSELR_ICACHE | CSSELR_L1);
 		isb();
-		asm("mrc	p15, 1, %0, c0, c0, 0 @ read CCSIDR"
-		    : "=r" (id_reg));
+		id_reg = read_ccsidr();
 		line_size = 4 << ((id_reg & 0x7) + 2);
 		num_sets = ((id_reg >> 13) & 0x7fff) + 1;
 		aliasing_icache = (line_size * num_sets) > PAGE_SIZE;

commit 7619751f8c900fa5fdd76db06f4caf095c56de8e
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Aug 10 22:46:49 2016 +0100

    ARM: 8595/2: apply more __ro_after_init
    
    Guided by grsecurity's analogous __read_only markings in arch/arm,
    this applies several uses of __ro_after_init to structures that are
    only updated during __init.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index df7f2a75e769..aca999e17184 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -114,19 +114,19 @@ EXPORT_SYMBOL(elf_hwcap2);
 
 
 #ifdef MULTI_CPU
-struct processor processor __read_mostly;
+struct processor processor __ro_after_init;
 #endif
 #ifdef MULTI_TLB
-struct cpu_tlb_fns cpu_tlb __read_mostly;
+struct cpu_tlb_fns cpu_tlb __ro_after_init;
 #endif
 #ifdef MULTI_USER
-struct cpu_user_fns cpu_user __read_mostly;
+struct cpu_user_fns cpu_user __ro_after_init;
 #endif
 #ifdef MULTI_CACHE
-struct cpu_cache_fns cpu_cache __read_mostly;
+struct cpu_cache_fns cpu_cache __ro_after_init;
 #endif
 #ifdef CONFIG_OUTER_CACHE
-struct outer_cache_fns outer_cache __read_mostly;
+struct outer_cache_fns outer_cache __ro_after_init;
 EXPORT_SYMBOL(outer_cache);
 #endif
 

commit 966fab00b0e19e0db3cb11d81bda5d0940176d5e
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Aug 2 14:05:51 2016 -0700

    ARM: kexec: advertise location of bootable RAM
    
    Advertise the location of bootable RAM to kexec-tools.  kexec needs to
    know where it can place the kernel in RAM, and so be executable when the
    system needs to jump into it.
    
    Advertise these areas in /proc/iomem with a "System RAM (boot alias)"
    tag.
    
    Link: http://lkml.kernel.org/r/E1b8ko4-0004HA-GF@rmk-PC.armlinux.org.uk
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Reviewed-by: Pratyush Anand <panand@redhat.com>
    Cc: Baoquan He <bhe@redhat.com>
    Cc: Keerthy <j-keerthy@ti.com>
    Cc: Vitaly Andrianov <vitalya@ti.com>
    Cc: Eric Biederman <ebiederm@xmission.com>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Vivek Goyal <vgoyal@redhat.com>
    Cc: Simon Horman <horms@verge.net.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 6c8c888c1152..df7f2a75e769 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -848,10 +848,29 @@ static void __init request_standard_resources(const struct machine_desc *mdesc)
 	kernel_data.end     = virt_to_phys(_end - 1);
 
 	for_each_memblock(memory, region) {
+		phys_addr_t start = __pfn_to_phys(memblock_region_memory_base_pfn(region));
+		phys_addr_t end = __pfn_to_phys(memblock_region_memory_end_pfn(region)) - 1;
+		unsigned long boot_alias_start;
+
+		/*
+		 * Some systems have a special memory alias which is only
+		 * used for booting.  We need to advertise this region to
+		 * kexec-tools so they know where bootable RAM is located.
+		 */
+		boot_alias_start = phys_to_idmap(start);
+		if (arm_has_idmap_alias() && boot_alias_start != IDMAP_INVALID_ADDR) {
+			res = memblock_virt_alloc(sizeof(*res), 0);
+			res->name = "System RAM (boot alias)";
+			res->start = boot_alias_start;
+			res->end = phys_to_idmap(end);
+			res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+			request_resource(&iomem_resource, res);
+		}
+
 		res = memblock_virt_alloc(sizeof(*res), 0);
 		res->name  = "System RAM";
-		res->start = __pfn_to_phys(memblock_region_memory_base_pfn(region));
-		res->end = __pfn_to_phys(memblock_region_memory_end_pfn(region)) - 1;
+		res->start = start;
+		res->end = end;
 		res->flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;
 
 		request_resource(&iomem_resource, res);

commit f7f0b7dc720f81b53afffb6779437086cdc3f62d
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Aug 2 14:05:48 2016 -0700

    ARM: kdump: advertise boot aliased crash kernel resource
    
    Advertise a resource which describes where the crash kernel is located
    in the boot view of RAM.  This allows kexec-tools to have this vital
    information.
    
    Link: http://lkml.kernel.org/r/E1b8knz-0004H4-Bd@rmk-PC.armlinux.org.uk
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Baoquan He <bhe@redhat.com>
    Cc: Keerthy <j-keerthy@ti.com>
    Cc: Pratyush Anand <panand@redhat.com>
    Cc: Vitaly Andrianov <vitalya@ti.com>
    Cc: Eric Biederman <ebiederm@xmission.com>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Vivek Goyal <vgoyal@redhat.com>
    Cc: Simon Horman <horms@verge.net.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index da2f6c360f6b..6c8c888c1152 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -1000,9 +1000,25 @@ static void __init reserve_crashkernel(void)
 		(unsigned long)(crash_base >> 20),
 		(unsigned long)(total_mem >> 20));
 
+	/* The crashk resource must always be located in normal mem */
 	crashk_res.start = crash_base;
 	crashk_res.end = crash_base + crash_size - 1;
 	insert_resource(&iomem_resource, &crashk_res);
+
+	if (arm_has_idmap_alias()) {
+		/*
+		 * If we have a special RAM alias for use at boot, we
+		 * need to advertise to kexec tools where the alias is.
+		 */
+		static struct resource crashk_boot_res = {
+			.name = "Crash kernel (boot alias)",
+			.flags = IORESOURCE_BUSY | IORESOURCE_MEM,
+		};
+
+		crashk_boot_res.start = phys_to_idmap(crash_base);
+		crashk_boot_res.end = crashk_boot_res.start + crash_size - 1;
+		insert_resource(&iomem_resource, &crashk_boot_res);
+	}
 }
 #else
 static inline void reserve_crashkernel(void) {}

commit f64d6e2aaa79f0ad588fd7ad595a0a8eb8f04645
Merge: 1056c9bd2702 099c0cbd2025
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 30 11:32:01 2016 -0700

    Merge tag 'devicetree-for-4.8' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull DeviceTree updates from Rob Herring:
    
     - remove most of_platform_populate() calls in arch code.  Now the DT
       core code calls it in the default case and platforms only need to
       call it if they have special needs
    
     - use pr_fmt on all the DT core print statements
    
     - CoreSight binding doc improvements to block name descriptions
    
     - add dt_to_config script which can parse dts files and list
       corresponding kernel config options
    
     - fix memory leak hit with a PowerMac DT
    
     - correct a bunch of STMicro compatible strings to use the correct
       vendor prefix
    
     - fix DA9052 PMIC binding doc to match what is actually used in dts
       files
    
    * tag 'devicetree-for-4.8' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (35 commits)
      documentation: da9052: Update regulator bindings names to match DA9052/53 DTS expectations
      xtensa: Partially Revert "xtensa: Remove unnecessary of_platform_populate with default match table"
      xtensa: Fix build error due to missing include file
      MIPS: ath79: Add missing include file
      Fix spelling errors in Documentation/devicetree
      ARM: dts: fix STMicroelectronics compatible strings
      powerpc/dts: fix STMicroelectronics compatible strings
      Documentation: dt: i2c: use correct STMicroelectronics vendor prefix
      scripts/dtc: dt_to_config - kernel config options for a devicetree
      of: fdt: mark unflattened tree as detached
      of: overlay: add resolver error prints
      coresight: document binding acronyms
      Documentation/devicetree: document cavium-pip rx-delay/tx-delay properties
      of: use pr_fmt prefix for all console printing
      of/irq: Mark initialised interrupt controllers as populated
      of: fix memory leak related to safe_name()
      Revert "of/platform: export of_default_bus_match_table"
      of: unittest: use of_platform_default_populate() to populate default bus
      memory: omap-gpmc: use of_platform_default_populate() to populate default bus
      bus: uniphier-system-bus: use of_platform_default_populate() to populate default bus
      ...

commit b5f00d18cc345bad3f5542b37886824c34a2a7ff
Merge: 27ae0c41ed2e 5f5a00eaa1dd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 29 13:03:49 2016 -0700

    Merge branch 'for-linus' of git://git.armlinux.org.uk/~rmk/linux-arm
    
    Pull ARM updates from Russell King:
     "Included in this update are:
    
       - Patches from Gregory Clement to fix the coherent DMA cases in our
         dma-mapping code.
    
       - A number of CPU errata updates and fixes.
    
       - ARM cpuidle improvements from Jisheng Zhang.
    
       - Fix from Kees for the location of _etext.
    
       - Cleanups from Masahiro Yamada to avoid duplicated messages during
         the kernel build, and remove CONFIG_ARCH_HAS_BARRIERS.
    
       - Remove a udelay loop limitation, allowing for faster CPUs to
         calibrate the delay correctly.
    
       - Cleanup some left-overs from the SW PAN implementation.
    
       - Ensure that a modified address limit is not visible to exception
         handlers"
    
    * 'for-linus' of git://git.armlinux.org.uk/~rmk/linux-arm: (21 commits)
      ARM: 8586/1: cpuidle: make arm_cpuidle_suspend() a bit more efficient
      ARM: 8585/1: cpuidle: fix !cpuidle_ops[cpu].init case during init
      ARM: 8561/4: dma-mapping: Fix the coherent case when iommu is used
      ARM: 8561/3: dma-mapping: Don't use outer_flush_range when the L2C is coherent
      ARM: 8560/1: errata: Workaround errata A12 825619 / A17 852421
      ARM: 8559/1: errata: Workaround erratum A12 821420
      ARM: 8558/1: errata: Workaround errata A12 818325/852422 A17 852423
      ARM: save and reset the address limit when entering an exception
      ARM: 8577/1: Fix Cortex-A15 798181 errata initialization
      ARM: 8584/1: floppy: avoid gcc-6 warning
      ARM: 8583/1: mm: fix location of _etext
      ARM: 8582/1: remove unused CONFIG_ARCH_HAS_BARRIERS
      ARM: 8306/1: loop_udelay: remove bogomips value limitation
      ARM: 8581/1: add missing <asm/prom.h> to arch/arm/kernel/devtree.c
      ARM: 8576/1: avoid duplicating "Kernel: arch/arm/boot/*Image is ready"
      ARM: 8556/1: on a generic DT system: do not touch l2x0
      ARM: uaccess: remove put_user() code duplication
      ARM: 8580/1: Remove orphaned __addr_ok() definition
      ARM: get rid of horrible *(unsigned int *)(regs + 1)
      ARM: introduce svc_pt_regs structure
      ...

commit 9b08aaa3199a4dffca73c7cdec813b483b5b2d3b
Author: Shannon Zhao <shannon.zhao@linaro.org>
Date:   Thu Apr 7 20:03:28 2016 +0800

    ARM: XEN: Move xen_early_init() before efi_init()
    
    Move xen_early_init() before efi_init(), then when calling efi_init()
    could initialize Xen specific UEFI.
    
    Check if it runs on Xen hypervisor through the flat dts.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Shannon Zhao <shannon.zhao@linaro.org>
    Reviewed-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Reviewed-by: Julien Grall <julien.grall@arm.com>
    Tested-by: Julien Grall <julien.grall@arm.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 7b5350060612..261dae6f3fec 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -1064,6 +1064,7 @@ void __init setup_arch(char **cmdline_p)
 	early_paging_init(mdesc);
 #endif
 	setup_dma_zone(mdesc);
+	xen_early_init();
 	efi_init();
 	sanity_check_meminfo();
 	arm_memblock_init(mdesc);
@@ -1080,7 +1081,6 @@ void __init setup_arch(char **cmdline_p)
 
 	arm_dt_init_cpu_maps();
 	psci_dt_init();
-	xen_early_init();
 #ifdef CONFIG_SMP
 	if (is_smp()) {
 		if (!mdesc->smp_init || !mdesc->smp_init()) {

commit 14c4a533e0996f95a0a64dfd0b6252d788cebc74
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Jun 23 21:28:47 2016 +0100

    ARM: 8583/1: mm: fix location of _etext
    
    The _etext position is defined to be the end of the kernel text code,
    and should not include any part of the data segments. This interferes
    with things that might check memory ranges and expect executable code
    up to _etext. Just to be conservative, leave the kernel resource as
    it was, using __init_begin instead of _etext as the end mark.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 7b5350060612..dd84f03dc2d4 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -844,7 +844,7 @@ static void __init request_standard_resources(const struct machine_desc *mdesc)
 	struct resource *res;
 
 	kernel_code.start   = virt_to_phys(_text);
-	kernel_code.end     = virt_to_phys(_etext - 1);
+	kernel_code.end     = virt_to_phys(__init_begin - 1);
 	kernel_data.start   = virt_to_phys(_sdata);
 	kernel_data.end     = virt_to_phys(_end - 1);
 

commit 850bea2335e42780a0752a75860d3fbcc3d12d6e
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Wed Jun 1 14:52:56 2016 +0800

    arm: Remove unnecessary of_platform_populate with default match table
    
    After patch "of/platform: Add common method to populate default bus",
    it is possible for arch code to remove unnecessary callers of
    of_platform_populate with default match table.
    
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Ray Jui <rjui@broadcom.com>
    Cc: Lee Jones <lee@kernel.org>
    Cc: Krzysztof Halasa <khalasa@piap.pl>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Santosh Shilimkar <ssantosh@kernel.org>
    Cc: Roland Stigge <stigge@antcom.de>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: Viresh Kumar <vireshk@kernel.org>
    Cc: Shiraz Hashim <shiraz.linux.kernel@gmail.com>
    Cc: Tony Prisk <linux@prisktech.co.nz>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 7e455339789b..2273acb9ebf6 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -904,11 +904,7 @@ static int __init customize_machine(void)
 	 */
 	if (machine_desc->init_machine)
 		machine_desc->init_machine();
-#ifdef CONFIG_OF
-	else
-		of_platform_populate(NULL, of_default_bus_match_table,
-					NULL, NULL);
-#endif
+
 	return 0;
 }
 arch_initcall(customize_machine);

commit bb8e15d60462a84a25a3bf33e8bc29b46c6d470a
Author: Kefeng Wang <wangkefeng.wang@huawei.com>
Date:   Wed Jun 1 14:06:15 2016 +0800

    of: iommu: make of_iommu_init() postcore_initcall_sync
    
    The of_iommu_init() is called multiple times by arch code,
    make it postcore_initcall_sync, then we can drop relevant
    calls fully.
    
    Note, the IOMMUs should have a chance to perform some basic
    initialisation before we start adding masters to them. So
    postcore_initcall_sync is good choice, it ensures of_iommu_init()
    called before of_platform_populate.
    
    Acked-by: Rich Felker <dalias@libc.org>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Acked-by: Joerg Roedel <jroedel@suse.de>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 7b5350060612..7e455339789b 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -19,7 +19,6 @@
 #include <linux/bootmem.h>
 #include <linux/seq_file.h>
 #include <linux/screen_info.h>
-#include <linux/of_iommu.h>
 #include <linux/of_platform.h>
 #include <linux/init.h>
 #include <linux/kexec.h>
@@ -903,7 +902,6 @@ static int __init customize_machine(void)
 	 * machine from the device tree, if no callback is provided,
 	 * otherwise we would always need an init_machine callback.
 	 */
-	of_iommu_init();
 	if (machine_desc->init_machine)
 		machine_desc->init_machine();
 #ifdef CONFIG_OF

commit a1c28b75a95808161cacbb3531c418abe248994e
Merge: a05a70db34ba 5632a9fbcd45
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 20 10:01:38 2016 -0700

    Merge branch 'for-linus' of git://git.armlinux.org.uk/~rmk/linux-arm
    
    Pull ARM updates from Russell King:
     "Changes included in this pull request:
    
       - revert pxa2xx-flash back to using ioremap_cached() and switch
         memremap() to use arch_memremap_wb()
    
       - remove pci=firmware command line argument handling
    
       - remove unnecessary arm_dma_set_mask() implementation, the generic
         implementation will do for ARM
    
       - removal of the ARM kallsyms "hack" to work around mode switching
         veneers and vectors located below PAGE_OFFSET
    
       - tidy up build system output a little
    
       - add L2 cache power management DT bindings
    
       - remove duplicated local_irq_disable() in reboot paths
    
       - handle AMBA primecell devices better at registration time with PM
         domains (needed for Samsung SoCs)
    
       - ARM specific preparation to support Keystone II kexec"
    
    * 'for-linus' of git://git.armlinux.org.uk/~rmk/linux-arm:
      ARM: 8567/1: cache-uniphier: activate ways for secondary CPUs
      ARM: 8570/2: Documentation: devicetree: Add PL310 PM bindings
      ARM: 8569/1: pl2x0: Add OF control of cache power management
      ARM: 8568/1: reboot: remove duplicated local_irq_disable()
      ARM: 8566/1: drivers: amba: properly handle devices with power domains
      ARM: provide arm_has_idmap_alias() helper
      ARM: kexec: remove 512MB restriction on kexec crashdump
      ARM: provide improved virt_to_idmap() functionality
      ARM: kexec: fix crashkernel= handling
      ARM: 8557/1: specify install, zinstall, and uinstall as PHONY targets
      ARM: 8562/1: suppress "include/generated/mach-types.h is up to date."
      ARM: 8553/1: kallsyms: remove --page-offset command line option
      ARM: 8552/1: kallsyms: remove special lower address limit for CONFIG_ARM
      ARM: 8555/1: kallsyms: ignore ARM mode switching veneers
      ARM: 8548/1: dma-mapping: remove arm_dma_set_mask()
      ARM: 8554/1: kernel: pci: remove pci=firmware command line parameter handling
      ARM: memremap: implement arch_memremap_wb()
      memremap: add arch specific hook for MEMREMAP_WB mappings
      mtd: pxa2xx-flash: switch back from memremap to ioremap_cached
      ARM: reintroduce ioremap_cached() for creating cached I/O mappings

commit 5632a9fbcd451892332d45553ce8b831d5143691
Merge: a41980f2a3eb e31db4c75687 07a7056ccce3 6427a840ff6a
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Thu May 19 10:31:35 2016 +0100

    Merge branches 'amba', 'devel-stable', 'kexec-for-next' and 'misc' into for-linus

commit d0506a2395eb07bef248de95016d9a8cf8a465ea
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Apr 1 14:47:36 2016 +0100

    ARM: kexec: remove 512MB restriction on kexec crashdump
    
    The real limit is the top of the visible physical address space with
    the MMU turned off.  Hence, we need to limit the crash kernel allocation
    running-view physical address of the top of the boot-view physical
    address space.
    
    Reviewed-by: Pratyush Anand <panand@redhat.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 77b54c461c52..d9317eec1eba 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -943,7 +943,6 @@ late_initcall(init_machine_late);
  * zImage relocating below the reserved region.
  */
 #define CRASH_ALIGN	(128 << 20)
-#define CRASH_ADDR_MAX	(PHYS_OFFSET + (512 << 20))
 
 static inline unsigned long long get_total_mem(void)
 {
@@ -973,9 +972,7 @@ static void __init reserve_crashkernel(void)
 		return;
 
 	if (crash_base <= 0) {
-		unsigned long long crash_max = CRASH_ADDR_MAX;
-		if (crash_max > (u32)~0)
-			crash_max = (u32)~0;
+		unsigned long long crash_max = idmap_to_phys((u32)~0);
 		crash_base = memblock_find_in_range(CRASH_ALIGN, crash_max,
 						    crash_size, CRASH_ALIGN);
 		if (!crash_base) {

commit 61603016e2122bf95328321b2f1a64277202b6e3
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Mar 14 19:34:37 2016 +0000

    ARM: kexec: fix crashkernel= handling
    
    When the kernel crashkernel parameter is specified with just a size, we
    are supposed to allocate a region from RAM to store the crashkernel.
    However, ARM merely reserves physical address zero with no checking that
    there is even RAM there.
    
    Fix this by lifting similar code from x86, importing it to ARM with the
    ARM specific parameters added.  In the absence of any platform specific
    information, we allocate the crashkernel region from the first 512MB of
    physical memory.
    
    Update the kdump documentation to reflect this change.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Reviewed-by: Pratyush Anand <panand@redhat.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 139791ed473d..77b54c461c52 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -938,6 +938,13 @@ static int __init init_machine_late(void)
 late_initcall(init_machine_late);
 
 #ifdef CONFIG_KEXEC
+/*
+ * The crash region must be aligned to 128MB to avoid
+ * zImage relocating below the reserved region.
+ */
+#define CRASH_ALIGN	(128 << 20)
+#define CRASH_ADDR_MAX	(PHYS_OFFSET + (512 << 20))
+
 static inline unsigned long long get_total_mem(void)
 {
 	unsigned long total;
@@ -965,6 +972,28 @@ static void __init reserve_crashkernel(void)
 	if (ret)
 		return;
 
+	if (crash_base <= 0) {
+		unsigned long long crash_max = CRASH_ADDR_MAX;
+		if (crash_max > (u32)~0)
+			crash_max = (u32)~0;
+		crash_base = memblock_find_in_range(CRASH_ALIGN, crash_max,
+						    crash_size, CRASH_ALIGN);
+		if (!crash_base) {
+			pr_err("crashkernel reservation failed - No suitable area found.\n");
+			return;
+		}
+	} else {
+		unsigned long long start;
+
+		start = memblock_find_in_range(crash_base,
+					       crash_base + crash_size,
+					       crash_size, SECTION_SIZE);
+		if (start != crash_base) {
+			pr_err("crashkernel reservation failed - memory is in use.\n");
+			return;
+		}
+	}
+
 	ret = memblock_reserve(crash_base, crash_size);
 	if (ret < 0) {
 		pr_warn("crashkernel reservation failed - memory is in use (0x%lx)\n",

commit 801820bee9bccb7c156af2b95c7208f428a06ae7
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Apr 25 21:06:53 2016 +0100

    efi/arm/libstub: Make screen_info accessible to the UEFI stub
    
    In order to hand over the framebuffer described by the GOP protocol and
    discovered by the UEFI stub, make struct screen_info accessible by the
    stub. This involves allocating a loader data buffer and passing it to the
    kernel proper via a UEFI Configuration Table, since the UEFI stub executes
    in the context of the decompressor, and cannot access the kernel's copy of
    struct screen_info directly.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: David Herrmann <dh.herrmann@gmail.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Peter Jones <pjones@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-efi@vger.kernel.org
    Link: http://lkml.kernel.org/r/1461614832-17633-22-git-send-email-matt@codeblueprint.co.uk
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 2c4bea39cf22..7d4e2850910c 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -883,7 +883,8 @@ static void __init request_standard_resources(const struct machine_desc *mdesc)
 		request_resource(&ioport_resource, &lp2);
 }
 
-#if defined(CONFIG_VGA_CONSOLE) || defined(CONFIG_DUMMY_CONSOLE)
+#if defined(CONFIG_VGA_CONSOLE) || defined(CONFIG_DUMMY_CONSOLE) || \
+    defined(CONFIG_EFI)
 struct screen_info screen_info = {
  .orig_video_lines	= 30,
  .orig_video_cols	= 80,

commit 03f1217e5fafac8eb9e28aa8d04a67b6db1e435b
Author: Vladimir Murzin <vladimir.murzin@arm.com>
Date:   Tue Apr 19 12:35:20 2016 +0100

    ARM: 8563/1: fix demoting HWCAP_SWP
    
    Commit b8c9592 "ARM: 8318/1: treat CPU feature register fields as signed
    quantities" accidentally altered cpuid register used to demote
    HWCAP_SWP.
    ARM ARM says that SyncPrim_instrs bits in ID_ISAR3 should be used with
    SynchPrim_instrs_frac from ID_ISAR4. So, follow this rule.
    
    Signed-off-by: Vladimir Murzin <vladimir.murzin@arm.com>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index a28fce0bdbbe..2c4bea39cf22 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -512,7 +512,7 @@ static void __init elf_hwcap_fixup(void)
 	 */
 	if (cpuid_feature_extract(CPUID_EXT_ISAR3, 12) > 1 ||
 	    (cpuid_feature_extract(CPUID_EXT_ISAR3, 12) == 1 &&
-	     cpuid_feature_extract(CPUID_EXT_ISAR3, 20) >= 3))
+	     cpuid_feature_extract(CPUID_EXT_ISAR4, 20) >= 3))
 		elf_hwcap &= ~HWCAP_SWP;
 }
 

commit 208fae5c3b9431013ad7bcea07cbcee114e7d163
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Mon Mar 14 02:55:45 2016 +0100

    ARM: 8550/1: protect idiv patching against undefined gcc behavior
    
    It was reported that a kernel with CONFIG_ARM_PATCH_IDIV=y stopped
    booting when compiled with the upcoming gcc 6.  Turns out that turning
    a function address into a writable array is undefined and gcc 6 decided
    it was OK to omit the store to the first word of the function while
    still preserving the store to the second word.
    
    Even though gcc 6 is now fixed to behave more coherently, it is a
    mystery that gcc 4 and gcc 5 actually produce wanted code in the kernel.
    And in fact the reduced test case to illustrate the issue does indeed
    break with gcc < 6 as well.
    
    In any case, let's guard the kernel against undefined compiler behavior
    by hiding the nature of the array location as suggested by gcc
    developers.
    
    Reference: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70128
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Reported-by: Marcin Juszkiewicz <mjuszkiewicz@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: stable@vger.kernel.org # v4.5
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 139791ed473d..a28fce0bdbbe 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -430,11 +430,13 @@ static void __init patch_aeabi_idiv(void)
 	pr_info("CPU: div instructions available: patching division code\n");
 
 	fn_addr = ((uintptr_t)&__aeabi_uidiv) & ~1;
+	asm ("" : "+g" (fn_addr));
 	((u32 *)fn_addr)[0] = udiv_instruction();
 	((u32 *)fn_addr)[1] = bx_lr_instruction();
 	flush_icache_range(fn_addr, fn_addr + 8);
 
 	fn_addr = ((uintptr_t)&__aeabi_idiv) & ~1;
+	asm ("" : "+g" (fn_addr));
 	((u32 *)fn_addr)[0] = sdiv_instruction();
 	((u32 *)fn_addr)[1] = bx_lr_instruction();
 	flush_icache_range(fn_addr, fn_addr + 8);

commit 35d98e93fe6a7ab612f6b389ce42c1dc135d6eef
Author: Toshi Kani <toshi.kani@hpe.com>
Date:   Tue Jan 26 21:57:22 2016 +0100

    arch: Set IORESOURCE_SYSTEM_RAM flag for System RAM
    
    Set IORESOURCE_SYSTEM_RAM in flags of resource ranges with
    "System RAM", "Kernel code", "Kernel data", and "Kernel bss".
    
    Note that:
    
     - IORESOURCE_SYSRAM (i.e. modifier bit) is set in flags when
       IORESOURCE_MEM is already set. IORESOURCE_SYSTEM_RAM is defined
       as (IORESOURCE_MEM|IORESOURCE_SYSRAM).
    
     - Some archs do not set 'flags' for children nodes, such as
       "Kernel code".  This patch does not change 'flags' in this
       case.
    
    Signed-off-by: Toshi Kani <toshi.kani@hpe.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Toshi Kani <toshi.kani@hp.com>
    Cc: linux-arch@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-mips@linux-mips.org
    Cc: linux-mm <linux-mm@kvack.org>
    Cc: linux-parisc@vger.kernel.org
    Cc: linux-s390@vger.kernel.org
    Cc: linux-sh@vger.kernel.org
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: sparclinux@vger.kernel.org
    Link: http://lkml.kernel.org/r/1453841853-11383-7-git-send-email-bp@alien8.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 7d0cba6f1cc5..139791ed473d 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -176,13 +176,13 @@ static struct resource mem_res[] = {
 		.name = "Kernel code",
 		.start = 0,
 		.end = 0,
-		.flags = IORESOURCE_MEM
+		.flags = IORESOURCE_SYSTEM_RAM
 	},
 	{
 		.name = "Kernel data",
 		.start = 0,
 		.end = 0,
-		.flags = IORESOURCE_MEM
+		.flags = IORESOURCE_SYSTEM_RAM
 	}
 };
 
@@ -851,7 +851,7 @@ static void __init request_standard_resources(const struct machine_desc *mdesc)
 		res->name  = "System RAM";
 		res->start = __pfn_to_phys(memblock_region_memory_base_pfn(region));
 		res->end = __pfn_to_phys(memblock_region_memory_end_pfn(region)) - 1;
-		res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+		res->flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;
 
 		request_resource(&iomem_resource, res);
 

commit 6660800fb7fd0f66faecb3c550fe59709220ade5
Merge: 598bcc6ea6ec 06312f44ad63
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jan 12 13:41:03 2016 +0000

    Merge branch 'devel-stable' into for-linus

commit 42f25bddd0a226d2431e057b9e01c5cc61067e12
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Sat Dec 12 02:49:21 2015 +0100

    ARM: 8477/1: runtime patch udiv/sdiv instructions into __aeabi_{u}idiv()
    
    The ARM compiler inserts calls to __aeabi_idiv() and
    __aeabi_uidiv() when it needs to perform division on signed and
    unsigned integers. If a processor has support for the sdiv and
    udiv instructions, the kernel may overwrite the beginning of those
    functions with those instructions and a "bx lr" to get better
    performance.
    
    To ensure that those functions are aligned to a 32-bit word for easier
    patching (which might not always be the case in Thumb mode) and that
    the two patched instructions end up in the same cache line, a 8-byte
    alignment is enforced when ARM_PATCH_IDIV is selected.
    
    This was heavily inspired by a previous patch from Stephen Boyd.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 20edd349d379..e07f567487cd 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -375,6 +375,72 @@ void __init early_print(const char *str, ...)
 	printk("%s", buf);
 }
 
+#ifdef CONFIG_ARM_PATCH_IDIV
+
+static inline u32 __attribute_const__ sdiv_instruction(void)
+{
+	if (IS_ENABLED(CONFIG_THUMB2_KERNEL)) {
+		/* "sdiv r0, r0, r1" */
+		u32 insn = __opcode_thumb32_compose(0xfb90, 0xf0f1);
+		return __opcode_to_mem_thumb32(insn);
+	}
+
+	/* "sdiv r0, r0, r1" */
+	return __opcode_to_mem_arm(0xe710f110);
+}
+
+static inline u32 __attribute_const__ udiv_instruction(void)
+{
+	if (IS_ENABLED(CONFIG_THUMB2_KERNEL)) {
+		/* "udiv r0, r0, r1" */
+		u32 insn = __opcode_thumb32_compose(0xfbb0, 0xf0f1);
+		return __opcode_to_mem_thumb32(insn);
+	}
+
+	/* "udiv r0, r0, r1" */
+	return __opcode_to_mem_arm(0xe730f110);
+}
+
+static inline u32 __attribute_const__ bx_lr_instruction(void)
+{
+	if (IS_ENABLED(CONFIG_THUMB2_KERNEL)) {
+		/* "bx lr; nop" */
+		u32 insn = __opcode_thumb32_compose(0x4770, 0x46c0);
+		return __opcode_to_mem_thumb32(insn);
+	}
+
+	/* "bx lr" */
+	return __opcode_to_mem_arm(0xe12fff1e);
+}
+
+static void __init patch_aeabi_idiv(void)
+{
+	extern void __aeabi_uidiv(void);
+	extern void __aeabi_idiv(void);
+	uintptr_t fn_addr;
+	unsigned int mask;
+
+	mask = IS_ENABLED(CONFIG_THUMB2_KERNEL) ? HWCAP_IDIVT : HWCAP_IDIVA;
+	if (!(elf_hwcap & mask))
+		return;
+
+	pr_info("CPU: div instructions available: patching division code\n");
+
+	fn_addr = ((uintptr_t)&__aeabi_uidiv) & ~1;
+	((u32 *)fn_addr)[0] = udiv_instruction();
+	((u32 *)fn_addr)[1] = bx_lr_instruction();
+	flush_icache_range(fn_addr, fn_addr + 8);
+
+	fn_addr = ((uintptr_t)&__aeabi_idiv) & ~1;
+	((u32 *)fn_addr)[0] = sdiv_instruction();
+	((u32 *)fn_addr)[1] = bx_lr_instruction();
+	flush_icache_range(fn_addr, fn_addr + 8);
+}
+
+#else
+static inline void patch_aeabi_idiv(void) { }
+#endif
+
 static void __init cpuid_init_hwcaps(void)
 {
 	int block;
@@ -642,6 +708,7 @@ static void __init setup_processor(void)
 	elf_hwcap = list->elf_hwcap;
 
 	cpuid_init_hwcaps();
+	patch_aeabi_idiv();
 
 #ifndef CONFIG_ARM_THUMB
 	elf_hwcap &= ~(HWCAP_THUMB | HWCAP_IDIVT);

commit da58fb6571bf40e5b2287d6aa3bbca04965f5677
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Thu Sep 24 13:49:52 2015 -0700

    ARM: wire up UEFI init and runtime support
    
    This adds support to the kernel proper for booting via UEFI. It shares
    most of the code with arm64, so this patch mostly just wires it up for
    use with ARM.
    
    Note that this does not include the EFI stub, it is added in a subsequent
    patch.
    
    Tested-by: Ryan Harkin <ryan.harkin@linaro.org>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 5df2bca57c42..b341b1c3b2fa 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -7,6 +7,7 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
+#include <linux/efi.h>
 #include <linux/export.h>
 #include <linux/kernel.h>
 #include <linux/stddef.h>
@@ -37,6 +38,7 @@
 #include <asm/cp15.h>
 #include <asm/cpu.h>
 #include <asm/cputype.h>
+#include <asm/efi.h>
 #include <asm/elf.h>
 #include <asm/early_ioremap.h>
 #include <asm/fixmap.h>
@@ -966,6 +968,7 @@ void __init setup_arch(char **cmdline_p)
 	early_paging_init(mdesc);
 #endif
 	setup_dma_zone(mdesc);
+	efi_init();
 	sanity_check_meminfo();
 	arm_memblock_init(mdesc);
 

commit 2937367b8a4b0d46ce3312cb997e4a240b02cf15
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Sep 1 08:59:28 2015 +0200

    ARM: add support for generic early_ioremap/early_memremap
    
    This enables the generic early_ioremap implementation for ARM.
    
    It uses the fixmap region reserved for kmap. Since early_ioremap
    is only supported before paging_init(), and kmap is only supported
    afterwards, this is guaranteed not to cause any clashes.
    
    Tested-by: Ryan Harkin <ryan.harkin@linaro.org>
    Reviewed-by: Matt Fleming <matt@codeblueprint.co.uk>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 20edd349d379..5df2bca57c42 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -38,6 +38,7 @@
 #include <asm/cpu.h>
 #include <asm/cputype.h>
 #include <asm/elf.h>
+#include <asm/early_ioremap.h>
 #include <asm/fixmap.h>
 #include <asm/procinfo.h>
 #include <asm/psci.h>
@@ -956,8 +957,8 @@ void __init setup_arch(char **cmdline_p)
 	strlcpy(cmd_line, boot_command_line, COMMAND_LINE_SIZE);
 	*cmdline_p = cmd_line;
 
-	if (IS_ENABLED(CONFIG_FIX_EARLYCON_MEM))
-		early_fixmap_init();
+	early_fixmap_init();
+	early_ioremap_init();
 
 	parse_early_param();
 
@@ -968,6 +969,8 @@ void __init setup_arch(char **cmdline_p)
 	sanity_check_meminfo();
 	arm_memblock_init(mdesc);
 
+	early_ioremap_reset();
+
 	paging_init(mdesc);
 	request_standard_resources(mdesc);
 

commit 3ff32a0def6e0d2e21a6c5ad1b00726592774018
Merge: 40d3f0285157 81497953e37b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Sep 3 15:28:50 2015 +0100

    Merge branch 'devel-stable' into for-linus
    
    Conflicts:
            drivers/perf/arm_pmu.c

commit a5f4c561b3b19a9bc43a81da6382b0098ebbc1fb
Author: Stefan Agner <stefan@agner.ch>
Date:   Thu Aug 13 00:01:52 2015 +0100

    ARM: 8415/1: early fixmap support for earlycon
    
    Add early fixmap support, initially to support permanent, fixed
    mapping support for early console. A temporary, early pte is
    created which is migrated to a permanent mapping in paging_init.
    This is also needed since the attributes may change as the memory
    types are initialized. The 3MiB range of fixmap spans two pte
    tables, but currently only one pte is created for early fixmap
    support.
    
    Re-add FIX_KMAP_BEGIN to the index calculation in highmem.c since
    the index for kmap does not start at zero anymore. This reverts
    4221e2e6b316 ("ARM: 8031/1: fixmap: remove FIX_KMAP_BEGIN and
    FIX_KMAP_END") to some extent.
    
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Laura Abbott <lauraa@codeaurora.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Stefan Agner <stefan@agner.ch>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 6bbec6042052..e2ecee6b70ca 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -37,6 +37,7 @@
 #include <asm/cpu.h>
 #include <asm/cputype.h>
 #include <asm/elf.h>
+#include <asm/fixmap.h>
 #include <asm/procinfo.h>
 #include <asm/psci.h>
 #include <asm/sections.h>
@@ -954,6 +955,9 @@ void __init setup_arch(char **cmdline_p)
 	strlcpy(cmd_line, boot_command_line, COMMAND_LINE_SIZE);
 	*cmdline_p = cmd_line;
 
+	if (IS_ENABLED(CONFIG_FIX_EARLYCON_MEM))
+		early_fixmap_init();
+
 	parse_early_param();
 
 #ifdef CONFIG_MMU

commit be120397e7709d9d5ed88317a385ce864a2603bc
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Fri Jul 31 15:46:19 2015 +0100

    ARM: migrate to common PSCI client code
    
    Now that the common PSCI client code has been factored out to
    drivers/firmware, and made safe for 32-bit use, move the 32-bit ARM code
    over to it. This results in a moderate reduction of duplicated lines,
    and will prevent further duplication as the PSCI client code is updated
    for PSCI 1.0 and beyond.
    
    The two legacy platform users of the PSCI invocation code are updated to
    account for interface changes. In both cases the power state parameter
    (which is constant) is now generated using macros, so that the
    pack/unpack logic can be killed in preparation for PSCI 1.0 power state
    changes.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Ashwin Chaugule <ashwin.chaugule@linaro.org>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 36c18b73c1f4..9c38bd42f04b 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -31,6 +31,7 @@
 #include <linux/bug.h>
 #include <linux/compiler.h>
 #include <linux/sort.h>
+#include <linux/psci.h>
 
 #include <asm/unified.h>
 #include <asm/cp15.h>
@@ -972,7 +973,7 @@ void __init setup_arch(char **cmdline_p)
 	unflatten_device_tree();
 
 	arm_dt_init_cpu_maps();
-	psci_init();
+	psci_dt_init();
 	xen_early_init();
 #ifdef CONFIG_SMP
 	if (is_smp()) {

commit 787047eea24a2443c366679ae6b5a3873a33b64e
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Jul 29 00:34:48 2015 +0100

    ARM: 8392/3: smp: Only expose /sys/.../cpuX/online if hotpluggable
    
    Writes to /sys/.../cpuX/online fail if we determine the platform
    doesn't support hotplug for that CPU. Furthermore, if the cpu_die
    op isn't specified the system hangs when we try to offline a CPU
    and it comes right back online unexpectedly. Let's figure this
    stuff out before we make the sysfs nodes so that the online file
    doesn't even exist if it isn't (at least sometimes) possible to
    hotplug the CPU.
    
    Add a new 'cpu_can_disable' op and repoint all 'cpu_disable'
    implementations at it because all implementers use the op to
    indicate if a CPU can be hotplugged or not in a static fashion.
    With PSCI we may need to add a 'cpu_disable' op so that the
    secure OS can be migrated off the CPU we're trying to hotplug.
    In this case, the 'cpu_can_disable' op will indicate that all
    CPUs are hotpluggable by returning true, but the 'cpu_disable' op
    will make a PSCI migration call and occasionally fail, denying
    the hotplug of a CPU. This shouldn't be any worse than x86 where
    we may indicate that all CPUs are hotpluggable but occasionally
    we can't offline a CPU due to check_irq_vectors_for_cpu_disable()
    failing to find a CPU to move vectors to.
    
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Nicolas Pitre <nico@linaro.org>
    Cc: Dave Martin <Dave.Martin@arm.com>
    Acked-by: Simon Horman <horms@verge.net.au> [shmobile portion]
    Tested-by: Simon Horman <horms@verge.net.au>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: <linux-sh@vger.kernel.org>
    Tested-by: Tyler Baker <tyler.baker@linaro.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 36c18b73c1f4..6bbec6042052 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -1015,7 +1015,7 @@ static int __init topology_init(void)
 
 	for_each_possible_cpu(cpu) {
 		struct cpuinfo_arm *cpuinfo = &per_cpu(cpu_data, cpu);
-		cpuinfo->cpu.hotpluggable = 1;
+		cpuinfo->cpu.hotpluggable = platform_can_hotplug_cpu(cpu);
 		register_cpu(&cpuinfo->cpu, cpu);
 	}
 

commit 7adf12b87f45a77d364464018fb8e9e1ac875152
Merge: 02201e3f1b46 6684fa1cdb1e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 1 11:53:46 2015 -0700

    Merge tag 'for-linus-4.2-rc0-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/xen/tip
    
    Pull xen updates from David Vrabel:
     "Xen features and cleanups for 4.2-rc0:
    
       - add "make xenconfig" to assist in generating configs for Xen guests
    
       - preparatory cleanups necessary for supporting 64 KiB pages in ARM
         guests
    
       - automatically use hvc0 as the default console in ARM guests"
    
    * tag 'for-linus-4.2-rc0-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/xen/tip:
      block/xen-blkback: s/nr_pages/nr_segs/
      block/xen-blkfront: Remove invalid comment
      block/xen-blkfront: Remove unused macro MAXIMUM_OUTSTANDING_BLOCK_REQS
      arm/xen: Drop duplicate define mfn_to_virt
      xen/grant-table: Remove unused macro SPP
      xen/xenbus: client: Fix call of virt_to_mfn in xenbus_grant_ring
      xen: Include xen/page.h rather than asm/xen/page.h
      kconfig: add xenconfig defconfig helper
      kconfig: clarify kvmconfig is for kvm
      xen/pcifront: Remove usage of struct timeval
      xen/tmem: use BUILD_BUG_ON() in favor of BUG_ON()
      hvc_xen: avoid uninitialized variable warning
      xenbus: avoid uninitialized variable warning
      xen/arm: allow console=hvc0 to be omitted for guests
      arm,arm64/xen: move Xen initialization earlier
      arm/xen: Correctly check if the event channel interrupt is present

commit 9de44aa4dc969e4a46c2bfbd33d65bfa6ad2a15d
Merge: 6fb18ac9366b 079ed3681d74 ec3bd0e68a67 c76f238e261b 0bbe6b5a73c0
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Jun 12 21:18:08 2015 +0100

    Merge branches 'arnd-fixes', 'clk', 'misc', 'v7' and 'fixes' into for-next

commit 1221ed10f2a56ecdd8ff75f436f52aca5ba0f1d3
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Apr 4 17:25:20 2015 +0100

    ARM: cleanup early_paging_init() calling
    
    Eliminate the needless nommu version of this function, and get rid of
    the proc_info_list structure argument - we no longer need this in order
    to fix up the page table entries.
    
    Acked-by: Santosh Shilimkar <ssantosh@kernel.org>
    Tested-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 6c777e908a24..979c1c5fe96a 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -75,8 +75,7 @@ __setup("fpe=", fpe_setup);
 
 extern void init_default_cache_policy(unsigned long);
 extern void paging_init(const struct machine_desc *desc);
-extern void early_paging_init(const struct machine_desc *,
-			      struct proc_info_list *);
+extern void early_paging_init(const struct machine_desc *);
 extern void sanity_check_meminfo(void);
 extern enum reboot_mode reboot_mode;
 extern void setup_dma_zone(const struct machine_desc *desc);
@@ -936,7 +935,9 @@ void __init setup_arch(char **cmdline_p)
 
 	parse_early_param();
 
-	early_paging_init(mdesc, lookup_processor_type(read_cpuid_id()));
+#ifdef CONFIG_MMU
+	early_paging_init(mdesc);
+#endif
 	setup_dma_zone(mdesc);
 	sanity_check_meminfo();
 	arm_memblock_init(mdesc);

commit 5882bfef6327093bff63569be19795170ff71e5f
Author: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
Date:   Wed May 6 14:13:31 2015 +0000

    arm,arm64/xen: move Xen initialization earlier
    
    Currently, Xen is initialized/discovered in an initcall. This doesn't
    allow us to support earlyprintk or choosing the preferred console when
    running on Xen.
    
    The current function xen_guest_init is now split in 2 parts:
        - xen_early_init: Check if there is a Xen node in the device tree
        and setup domain type
        - xen_guest_init: Retrieve the information from the device node and
        initialize Xen (grant table, shared page...)
    
    The former is called in setup_arch, while the latter is an initcall.
    
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Signed-off-by: Julien Grall <julien.grall@linaro.org>
    Acked-by: Ian Campbell <ian.campbell@citrix.com>
    Acked-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 6c777e908a24..aa9bfebe113f 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -46,6 +46,7 @@
 #include <asm/cacheflush.h>
 #include <asm/cachetype.h>
 #include <asm/tlbflush.h>
+#include <asm/xen/hypervisor.h>
 
 #include <asm/prom.h>
 #include <asm/mach/arch.h>
@@ -951,6 +952,7 @@ void __init setup_arch(char **cmdline_p)
 
 	arm_dt_init_cpu_maps();
 	psci_init();
+	xen_early_init();
 #ifdef CONFIG_SMP
 	if (is_smp()) {
 		if (!mdesc->smp_init || !mdesc->smp_init()) {

commit 3f599875e5202986b350618a617527ab441bf206
Author: Paul Kocialkowski <contact@paulk.fr>
Date:   Wed May 6 15:23:56 2015 +0100

    ARM: 8355/1: arch: Show the serial number from devicetree in cpuinfo
    
    This grabs the serial number shown in cpuinfo from the serial-number device-tree
    property in priority. When booting with ATAGs (and without device-tree), the
    provided number is still shown instead.
    
    Signed-off-by: Paul Kocialkowski <contact@paulk.fr>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 6c777e908a24..ee3e329ecf58 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -93,6 +93,9 @@ unsigned int __atags_pointer __initdata;
 unsigned int system_rev;
 EXPORT_SYMBOL(system_rev);
 
+const char *system_serial;
+EXPORT_SYMBOL(system_serial);
+
 unsigned int system_serial_low;
 EXPORT_SYMBOL(system_serial_low);
 
@@ -839,8 +842,25 @@ arch_initcall(customize_machine);
 
 static int __init init_machine_late(void)
 {
+	struct device_node *root;
+	int ret;
+
 	if (machine_desc->init_late)
 		machine_desc->init_late();
+
+	root = of_find_node_by_path("/");
+	if (root) {
+		ret = of_property_read_string(root, "serial-number",
+					      &system_serial);
+		if (ret)
+			system_serial = NULL;
+	}
+
+	if (!system_serial)
+		system_serial = kasprintf(GFP_KERNEL, "%08x%08x",
+					  system_serial_high,
+					  system_serial_low);
+
 	return 0;
 }
 late_initcall(init_machine_late);
@@ -1109,8 +1129,7 @@ static int c_show(struct seq_file *m, void *v)
 
 	seq_printf(m, "Hardware\t: %s\n", machine_name);
 	seq_printf(m, "Revision\t: %04x\n", system_rev);
-	seq_printf(m, "Serial\t\t: %08x%08x\n",
-		   system_serial_high, system_serial_low);
+	seq_printf(m, "Serial\t\t: %s\n", system_serial);
 
 	return 0;
 }

commit c848791f0336914a3081ea3fe029cf177d81de81
Merge: 79403cda3720 e5b61deb3af4 6c5c2a01fcfd
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Apr 14 22:28:25 2015 +0100

    Merge branches 'misc', 'vdso' and 'fixes' into for-next
    
    Conflicts:
            arch/arm/mm/proc-macros.S

commit a092aedb8115c16cb49bc64dd09cb20471ff942b
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Thu Mar 19 19:04:05 2015 +0100

    ARM: 8319/1: advertise availability of v8 Crypto instructions
    
    When running the 32-bit ARM kernel on ARMv8 capable bare metal (e.g.,
    32-bit Android userland and kernel on a Cortex-A53), or as a KVM guest
    on a 64-bit host, we should advertise the availability of the Crypto
    instructions, so that userland libraries such as OpenSSL may use them.
    (Support for the v8 Crypto instructions in the 32-bit build was added
    to OpenSSL more than six months ago)
    
    This adds the ID feature bit detection, and sets elf_hwcap2 accordingly.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 637c449e6060..910bb1796946 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -376,6 +376,7 @@ void __init early_print(const char *str, ...)
 static void __init cpuid_init_hwcaps(void)
 {
 	int block;
+	u32 isar5;
 
 	if (cpu_architecture() < CPU_ARCH_ARMv7)
 		return;
@@ -390,6 +391,27 @@ static void __init cpuid_init_hwcaps(void)
 	block = cpuid_feature_extract(CPUID_EXT_MMFR0, 0);
 	if (block >= 5)
 		elf_hwcap |= HWCAP_LPAE;
+
+	/* check for supported v8 Crypto instructions */
+	isar5 = read_cpuid_ext(CPUID_EXT_ISAR5);
+
+	block = cpuid_feature_extract_field(isar5, 4);
+	if (block >= 2)
+		elf_hwcap2 |= HWCAP2_PMULL;
+	if (block >= 1)
+		elf_hwcap2 |= HWCAP2_AES;
+
+	block = cpuid_feature_extract_field(isar5, 8);
+	if (block >= 1)
+		elf_hwcap2 |= HWCAP2_SHA1;
+
+	block = cpuid_feature_extract_field(isar5, 12);
+	if (block >= 1)
+		elf_hwcap2 |= HWCAP2_SHA2;
+
+	block = cpuid_feature_extract_field(isar5, 16);
+	if (block >= 1)
+		elf_hwcap2 |= HWCAP2_CRC32;
 }
 
 static void __init elf_hwcap_fixup(void)

commit b8c9592b4a6c93211c8163888a97880d608503b5
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Thu Mar 19 19:03:25 2015 +0100

    ARM: 8318/1: treat CPU feature register fields as signed quantities
    
    The various CPU feature registers consist of 4-bit blocks that
    represent signed quantities, whose positive values represent
    incremental features, and whose negative values are reserved.
    
    To improve forward compatibility, update the feature detection
    code to take possible future higher values into account, but
    ignore negative values.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index e55408e96559..637c449e6060 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -375,30 +375,26 @@ void __init early_print(const char *str, ...)
 
 static void __init cpuid_init_hwcaps(void)
 {
-	unsigned int divide_instrs, vmsa;
+	int block;
 
 	if (cpu_architecture() < CPU_ARCH_ARMv7)
 		return;
 
-	divide_instrs = (read_cpuid_ext(CPUID_EXT_ISAR0) & 0x0f000000) >> 24;
-
-	switch (divide_instrs) {
-	case 2:
+	block = cpuid_feature_extract(CPUID_EXT_ISAR0, 24);
+	if (block >= 2)
 		elf_hwcap |= HWCAP_IDIVA;
-	case 1:
+	if (block >= 1)
 		elf_hwcap |= HWCAP_IDIVT;
-	}
 
 	/* LPAE implies atomic ldrd/strd instructions */
-	vmsa = (read_cpuid_ext(CPUID_EXT_MMFR0) & 0xf) >> 0;
-	if (vmsa >= 5)
+	block = cpuid_feature_extract(CPUID_EXT_MMFR0, 0);
+	if (block >= 5)
 		elf_hwcap |= HWCAP_LPAE;
 }
 
 static void __init elf_hwcap_fixup(void)
 {
 	unsigned id = read_cpuid_id();
-	unsigned sync_prim;
 
 	/*
 	 * HWCAP_TLS is available only on 1136 r1p0 and later,
@@ -419,9 +415,9 @@ static void __init elf_hwcap_fixup(void)
 	 * avoid advertising SWP; it may not be atomic with
 	 * multiprocessing cores.
 	 */
-	sync_prim = ((read_cpuid_ext(CPUID_EXT_ISAR3) >> 8) & 0xf0) |
-		    ((read_cpuid_ext(CPUID_EXT_ISAR4) >> 20) & 0x0f);
-	if (sync_prim >= 0x13)
+	if (cpuid_feature_extract(CPUID_EXT_ISAR3, 12) > 1 ||
+	    (cpuid_feature_extract(CPUID_EXT_ISAR3, 12) == 1 &&
+	     cpuid_feature_extract(CPUID_EXT_ISAR3, 20) >= 3))
 		elf_hwcap &= ~HWCAP_SWP;
 }
 

commit 526299ce4eab2e35ba733b03771d112147676b12
Author: Mason <slash.tmp@free.fr>
Date:   Tue Mar 17 21:37:25 2015 +0100

    ARM: 8313/1: Use read_cpuid_ext() macro instead of inline asm
    
    Replace inline asm statement in __get_cpu_architecture() with equivalent
    macro invocation, i.e. read_cpuid_ext(CPUID_EXT_MMFR0);
    
    As an added bonus, this squashes a potential bug, described by Paul
    Walmsley in commit 067e710b9a98 ("ARM: 7801/1: prevent gcc 4.5 from
    reordering extended CP15 reads above is_smp() test").
    
    Signed-off-by: Marc Gonzalez <marc_gonzalez@sigmadesigns.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index e55408e96559..1d60bebea4b8 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -246,12 +246,9 @@ static int __get_cpu_architecture(void)
 		if (cpu_arch)
 			cpu_arch += CPU_ARCH_ARMv3;
 	} else if ((read_cpuid_id() & 0x000f0000) == 0x000f0000) {
-		unsigned int mmfr0;
-
 		/* Revised CPUID format. Read the Memory Model Feature
 		 * Register 0 and check for VMSAv7 or PMSAv7 */
-		asm("mrc	p15, 0, %0, c0, c1, 4"
-		    : "=r" (mmfr0));
+		unsigned int mmfr0 = read_cpuid_ext(CPUID_EXT_MMFR0);
 		if ((mmfr0 & 0x0000000f) >= 0x00000003 ||
 		    (mmfr0 & 0x000000f0) >= 0x00000030)
 			cpu_arch = CPU_ARCH_ARMv7;

commit 0ad4989d6270bec0a42598dd4d804569faedf228
Merge: 222713bb1e37 909ba297beb5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 24 09:57:01 2015 +1200

    Merge branch 'fixes' of git://ftp.arm.linux.org.uk/~rmk/linux-arm
    
    Pull ARM fixes from Russell King:
     "Another round of small ARM fixes.
    
      restore_user_regs early stack deallocation is buggy in the presence of
      FIQs which switch to SVC mode, and could lead to corrupted registers
      being returned to a user process given an inopportune FIQ event.
    
      Another bug was spotted in the ARM perf code where it could lose track
      of perf counter overflows, leading to incorrect perf results.
    
      Lastly, a bug in arm_add_memory() was spotted where the memory sizes
      aren't properly rounded.  As most people pass properly rounded sizes,
      this hasn't been noticed"
    
    * 'fixes' of git://ftp.arm.linux.org.uk/~rmk/linux-arm:
      ARM: 8292/1: mm: fix size rounding-down of arm_add_memory() function
      ARM: 8255/1: perf: Prevent wraparound during overflow
      ARM: 8266/1: Remove early stack deallocation from restore_user_regs

commit 909ba297beb50981a9d12364688d3c5f3084c6eb
Author: Masahiro Yamada <yamada.m@jp.panasonic.com>
Date:   Tue Jan 20 04:38:25 2015 +0100

    ARM: 8292/1: mm: fix size rounding-down of arm_add_memory() function
    
    The current rounding of "size" is wrong:
    
     - If "start" is sufficiently near the next page boundary, "size"
       is decremented by more than enough and the last page is lost.
    
     - If "size" is sufficiently small, it is wrapped around and gets
       a bogus value.
    
    Signed-off-by: Masahiro Yamada <yamada.m@jp.panasonic.com>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index f9c863911038..d13f185e7bd5 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -657,10 +657,13 @@ int __init arm_add_memory(u64 start, u64 size)
 
 	/*
 	 * Ensure that start/size are aligned to a page boundary.
-	 * Size is appropriately rounded down, start is rounded up.
+	 * Size is rounded down, start is rounded up.
 	 */
-	size -= start & ~PAGE_MASK;
 	aligned_start = PAGE_ALIGN(start);
+	if (aligned_start > start + size)
+		size = 0;
+	else
+		size -= aligned_start - start;
 
 #ifndef CONFIG_ARCH_PHYS_ADDR_T_64BIT
 	if (aligned_start > ULONG_MAX) {

commit 4bf9636c39ac70da091d5a2e28d3448eaa7f115c
Author: Pavel Machek <pavel@ucw.cz>
Date:   Sun Jan 4 20:01:23 2015 +0100

    Revert "ARM: 7830/1: delay: don't bother reporting bogomips in /proc/cpuinfo"
    
    Commit 9fc2105aeaaf ("ARM: 7830/1: delay: don't bother reporting
    bogomips in /proc/cpuinfo") breaks audio in python, and probably
    elsewhere, with message
    
      FATAL: cannot locate cpu MHz in /proc/cpuinfo
    
    I'm not the first one to hit it, see for example
    
      https://theredblacktree.wordpress.com/2014/08/10/fatal-cannot-locate-cpu-mhz-in-proccpuinfo/
      https://devtalk.nvidia.com/default/topic/765800/workaround-for-fatal-cannot-locate-cpu-mhz-in-proc-cpuinf/?offset=1
    
    Reading original changelog, I have to say "Stop breaking working setups.
    You know who you are!".
    
    Signed-off-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index f9c863911038..715ae19bc7c8 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -1046,6 +1046,15 @@ static int c_show(struct seq_file *m, void *v)
 		seq_printf(m, "model name\t: %s rev %d (%s)\n",
 			   cpu_name, cpuid & 15, elf_platform);
 
+#if defined(CONFIG_SMP)
+		seq_printf(m, "BogoMIPS\t: %lu.%02lu\n",
+			   per_cpu(cpu_data, i).loops_per_jiffy / (500000UL/HZ),
+			   (per_cpu(cpu_data, i).loops_per_jiffy / (5000UL/HZ)) % 100);
+#else
+		seq_printf(m, "BogoMIPS\t: %lu.%02lu\n",
+			   loops_per_jiffy / (500000/HZ),
+			   (loops_per_jiffy / (5000/HZ)) % 100);
+#endif
 		/* dump out the processor features */
 		seq_puts(m, "Features\t: ");
 

commit 6f51ee709e4c6b56f2c2a071da2d056a109b9d26
Merge: 205dc205ed3b fd522d279235
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 16 14:53:01 2014 -0800

    Merge tag 'iommu-config-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC/iommu configuration update from Arnd Bergmann:
     "The iomm-config branch contains work from Will Deacon, quoting his
      description:
    
        This series adds automatic IOMMU and DMA-mapping configuration for
        OF-based DMA masters described using the generic IOMMU devicetree
        bindings. Although there is plenty of future work around splitting up
        iommu_ops, adding default IOMMU domains and sorting out automatic IOMMU
        group creation for the platform_bus, this is already useful enough for
        people to port over their IOMMU drivers and start using the new probing
        infrastructure (indeed, Marek has patches queued for the Exynos IOMMU).
    
      The branch touches core ARM and IOMMU driver files, and the respective
      maintainers (Russell King and Joerg Roedel) agreed to have the
      contents merged through the arm-soc tree.
    
      The final version was ready just before the merge window, so we ended
      up delaying it a bit longer than the rest, but we don't expect to see
      regressions because this is just additional infrastructure that will
      get used in drivers starting in 3.20 but is unused so far"
    
    * tag 'iommu-config-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      iommu: store DT-probed IOMMU data privately
      arm: dma-mapping: plumb our iommu mapping ops into arch_setup_dma_ops
      arm: call iommu_init before of_platform_populate
      dma-mapping: detect and configure IOMMU in of_dma_configure
      iommu: fix initialization without 'add_device' callback
      iommu: provide helper function to configure an IOMMU for an of master
      iommu: add new iommu_ops callback for adding an OF device
      dma-mapping: replace set_arch_dma_coherent_ops with arch_setup_dma_ops
      iommu: provide early initialisation hook for IOMMU drivers

commit af4dda732ea044517f8beed4a38c852ea97e7690
Author: Will Deacon <will.deacon@arm.com>
Date:   Wed Aug 27 17:51:16 2014 +0100

    arm: call iommu_init before of_platform_populate
    
    We need to ensure that the IOMMUs in the system have a chance to perform
    some basic initialisation before we start adding masters to them.
    
    This patch adds a call to of_iommu_init before of_platform_populate.
    
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index c03106378b49..1cfc94aa7fa2 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -18,6 +18,7 @@
 #include <linux/bootmem.h>
 #include <linux/seq_file.h>
 #include <linux/screen_info.h>
+#include <linux/of_iommu.h>
 #include <linux/of_platform.h>
 #include <linux/init.h>
 #include <linux/kexec.h>
@@ -806,6 +807,7 @@ static int __init customize_machine(void)
 	 * machine from the device tree, if no callback is provided,
 	 * otherwise we would always need an init_machine callback.
 	 */
+	of_iommu_init();
 	if (machine_desc->init_machine)
 		machine_desc->init_machine();
 #ifdef CONFIG_OF

commit 719c9d1489bad6ff26fa1f6a7e3f760935663398
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Oct 28 12:40:26 2014 +0000

    ARM: add machine name to stack dump output
    
    The generic dump_stack() code provides the facility to include the
    machine name in the stack dump, which can be useful information.  Add
    a call to dump_stack_set_arch_desc() for the generic code to print
    this information.
    
    Tested-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index c03106378b49..8361652b6dab 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -900,6 +900,7 @@ void __init setup_arch(char **cmdline_p)
 		mdesc = setup_machine_tags(__atags_pointer, __machine_arch_type);
 	machine_desc = mdesc;
 	machine_name = mdesc->name;
+	dump_stack_set_arch_desc("%s", mdesc->name);
 
 	if (mdesc->reboot_mode != REBOOT_HARD)
 		reboot_mode = mdesc->reboot_mode;

commit c0e7f7ee717e2b4c5791e7422424c96b5008c39e
Author: Daniel Thompson <daniel.thompson@linaro.org>
Date:   Wed Sep 17 17:12:06 2014 +0100

    ARM: 8150/3: fiq: Replace default FIQ handler
    
    This patch introduces a new default FIQ handler that is structured in a
    similar way to the existing ARM exception handler and result in the FIQ
    being handled by C code running on the SVC stack (despite this code run
    in the FIQ handler is subject to severe limitations with respect to
    locking making normal interaction with the kernel impossible).
    
    This default handler allows concepts that on x86 would be handled using
    NMIs to be realized on ARM.
    
    Credit:
    
        This patch is a near complete re-write of a patch originally
        provided by Anton Vorontsov. Today only a couple of small fragments
        survive, however without Anton's work to build from this patch would
        not exist. Thanks also to Russell King for spoonfeeding me a variety
        of fixes during the review cycle.
    
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 84db893dedc2..c03106378b49 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -133,6 +133,7 @@ struct stack {
 	u32 irq[3];
 	u32 abt[3];
 	u32 und[3];
+	u32 fiq[3];
 } ____cacheline_aligned;
 
 #ifndef CONFIG_CPU_V7M
@@ -470,7 +471,10 @@ void notrace cpu_init(void)
 	"msr	cpsr_c, %5\n\t"
 	"add	r14, %0, %6\n\t"
 	"mov	sp, r14\n\t"
-	"msr	cpsr_c, %7"
+	"msr	cpsr_c, %7\n\t"
+	"add	r14, %0, %8\n\t"
+	"mov	sp, r14\n\t"
+	"msr	cpsr_c, %9"
 	    :
 	    : "r" (stk),
 	      PLC (PSR_F_BIT | PSR_I_BIT | IRQ_MODE),
@@ -479,6 +483,8 @@ void notrace cpu_init(void)
 	      "I" (offsetof(struct stack, abt[0])),
 	      PLC (PSR_F_BIT | PSR_I_BIT | UND_MODE),
 	      "I" (offsetof(struct stack, und[0])),
+	      PLC (PSR_F_BIT | PSR_I_BIT | FIQ_MODE),
+	      "I" (offsetof(struct stack, fiq[0])),
 	      PLC (PSR_F_BIT | PSR_I_BIT | SVC_MODE)
 	    : "r14");
 #endif

commit 58171bf2af6b547a560b304f6ab2b9edf1c31d5a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Jul 4 16:41:21 2014 +0100

    ARM: hwcap: disable HWCAP_SWP if the CPU advertises it has exclusives
    
    When the CPU has support for the byte and word exclusive operations,
    userspace should use them in preference to the SWP instructions.
    Detect the presence of these instructions by reading the ISAR CPU ID
    registers and adjust the ELF HWCAP mask appropriately.
    
    Note that ARM1136 < r1p0 has no ISAR4, so this is explicitly detected
    and the test disabled, leaving the current situation where HWCAP_SWP
    is set.
    
    Tested-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 8a16ee5d8a95..84db893dedc2 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -393,19 +393,34 @@ static void __init cpuid_init_hwcaps(void)
 		elf_hwcap |= HWCAP_LPAE;
 }
 
-static void __init feat_v6_fixup(void)
+static void __init elf_hwcap_fixup(void)
 {
-	int id = read_cpuid_id();
-
-	if ((id & 0xff0f0000) != 0x41070000)
-		return;
+	unsigned id = read_cpuid_id();
+	unsigned sync_prim;
 
 	/*
 	 * HWCAP_TLS is available only on 1136 r1p0 and later,
 	 * see also kuser_get_tls_init.
 	 */
-	if ((((id >> 4) & 0xfff) == 0xb36) && (((id >> 20) & 3) == 0))
+	if (read_cpuid_part() == ARM_CPU_PART_ARM1136 &&
+	    ((id >> 20) & 3) == 0) {
 		elf_hwcap &= ~HWCAP_TLS;
+		return;
+	}
+
+	/* Verify if CPUID scheme is implemented */
+	if ((id & 0x000f0000) != 0x000f0000)
+		return;
+
+	/*
+	 * If the CPU supports LDREX/STREX and LDREXB/STREXB,
+	 * avoid advertising SWP; it may not be atomic with
+	 * multiprocessing cores.
+	 */
+	sync_prim = ((read_cpuid_ext(CPUID_EXT_ISAR3) >> 8) & 0xf0) |
+		    ((read_cpuid_ext(CPUID_EXT_ISAR4) >> 20) & 0x0f);
+	if (sync_prim >= 0x13)
+		elf_hwcap &= ~HWCAP_SWP;
 }
 
 /*
@@ -609,7 +624,7 @@ static void __init setup_processor(void)
 #endif
 	erratum_a15_798181_init();
 
-	feat_v6_fixup();
+	elf_hwcap_fixup();
 
 	cacheid_init();
 	cpu_init();

commit 1fb333489fb917c704ad43e51b45c12f52215a9c
Merge: 20e7e364331d 3f8517e7937d 8ef418c7178f 1c2f87c22566
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jun 5 12:35:52 2014 +0100

    Merge branches 'alignment', 'fixes', 'l2c' (early part) and 'misc' into for-next

commit ca8f0b0a545f55b3dc6877cda24d609a8979c951
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue May 27 20:34:28 2014 +0100

    ARM: ensure C page table setup code follows assembly code
    
    Fix a long standing bug where, for ARMv6+, we don't fully ensure that
    the C code sets the same cache policy as the assembly code.  This was
    introduced partially by commit 11179d8ca28d ([ARM] 4497/1: Only allow
    safe cache configurations on ARMv6 and later) and also by adding SMP
    support.
    
    This patch sets the default cache policy based on the flags used by the
    assembly code, and then ensures that when a cache policy command line
    argument is used, we verify that on ARMv6, it matches the initial setup.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index df21f9f98945..f5120ca08671 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -72,6 +72,7 @@ static int __init fpe_setup(char *line)
 __setup("fpe=", fpe_setup);
 #endif
 
+extern void init_default_cache_policy(unsigned long);
 extern void paging_init(const struct machine_desc *desc);
 extern void early_paging_init(const struct machine_desc *,
 			      struct proc_info_list *);
@@ -603,7 +604,9 @@ static void __init setup_processor(void)
 #ifndef CONFIG_ARM_THUMB
 	elf_hwcap &= ~(HWCAP_THUMB | HWCAP_IDIVT);
 #endif
-
+#ifdef CONFIG_MMU
+	init_default_cache_policy(list->__cpu_mm_mmu_flags);
+#endif
 	erratum_a15_798181_init();
 
 	feat_v6_fixup();

commit 1c2f87c22566cd057bc8cde10c37ae9da1a1bb76
Author: Laura Abbott <lauraa@codeaurora.org>
Date:   Sun Apr 13 22:54:58 2014 +0100

    ARM: 8025/1: Get rid of meminfo
    
    memblock is now fully integrated into the kernel and is the prefered
    method for tracking memory. Rather than reinvent the wheel with
    meminfo, migrate to using memblock directly instead of meminfo as
    an intermediate.
    
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Leif Lindholm <leif.lindholm@linaro.org>
    Signed-off-by: Laura Abbott <lauraa@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 50e198c1e9c8..6d78ba47ea5b 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -628,15 +628,8 @@ void __init dump_machine_table(void)
 
 int __init arm_add_memory(u64 start, u64 size)
 {
-	struct membank *bank = &meminfo.bank[meminfo.nr_banks];
 	u64 aligned_start;
 
-	if (meminfo.nr_banks >= NR_BANKS) {
-		pr_crit("NR_BANKS too low, ignoring memory at 0x%08llx\n",
-			(long long)start);
-		return -EINVAL;
-	}
-
 	/*
 	 * Ensure that start/size are aligned to a page boundary.
 	 * Size is appropriately rounded down, start is rounded up.
@@ -677,17 +670,17 @@ int __init arm_add_memory(u64 start, u64 size)
 		aligned_start = PHYS_OFFSET;
 	}
 
-	bank->start = aligned_start;
-	bank->size = size & ~(phys_addr_t)(PAGE_SIZE - 1);
+	start = aligned_start;
+	size = size & ~(phys_addr_t)(PAGE_SIZE - 1);
 
 	/*
 	 * Check whether this memory region has non-zero size or
 	 * invalid node number.
 	 */
-	if (bank->size == 0)
+	if (size == 0)
 		return -EINVAL;
 
-	meminfo.nr_banks++;
+	memblock_add(start, size);
 	return 0;
 }
 
@@ -695,6 +688,7 @@ int __init arm_add_memory(u64 start, u64 size)
  * Pick out the memory size.  We look for mem=size@start,
  * where start and size are "size[KkMm]"
  */
+
 static int __init early_mem(char *p)
 {
 	static int usermem __initdata = 0;
@@ -709,7 +703,8 @@ static int __init early_mem(char *p)
 	 */
 	if (usermem == 0) {
 		usermem = 1;
-		meminfo.nr_banks = 0;
+		memblock_remove(memblock_start_of_DRAM(),
+			memblock_end_of_DRAM() - memblock_start_of_DRAM());
 	}
 
 	start = PHYS_OFFSET;
@@ -854,13 +849,6 @@ static void __init reserve_crashkernel(void)
 static inline void reserve_crashkernel(void) {}
 #endif /* CONFIG_KEXEC */
 
-static int __init meminfo_cmp(const void *_a, const void *_b)
-{
-	const struct membank *a = _a, *b = _b;
-	long cmp = bank_pfn_start(a) - bank_pfn_start(b);
-	return cmp < 0 ? -1 : cmp > 0 ? 1 : 0;
-}
-
 void __init hyp_mode_check(void)
 {
 #ifdef CONFIG_ARM_VIRT_EXT
@@ -903,12 +891,10 @@ void __init setup_arch(char **cmdline_p)
 
 	parse_early_param();
 
-	sort(&meminfo.bank, meminfo.nr_banks, sizeof(meminfo.bank[0]), meminfo_cmp, NULL);
-
 	early_paging_init(mdesc, lookup_processor_type(read_cpuid_id()));
 	setup_dma_zone(mdesc);
 	sanity_check_meminfo();
-	arm_memblock_init(&meminfo, mdesc);
+	arm_memblock_init(mdesc);
 
 	paging_init(mdesc);
 	request_standard_resources(mdesc);

commit 4585eaff634b1bbb09686895221b3645f53f7a60
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Apr 13 18:47:34 2014 +0100

    ARM: use get_cr() rather than cr_alignment
    
    Rather than reading the cr_alignment variable, use get_cr() to read
    directly from the hardware instead.  We have two places where this
    occurs, neither of them are performance critical.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 50e198c1e9c8..df21f9f98945 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -590,7 +590,7 @@ static void __init setup_processor(void)
 
 	pr_info("CPU: %s [%08x] revision %d (ARMv%s), cr=%08lx\n",
 		cpu_name, read_cpuid_id(), read_cpuid_id() & 15,
-		proc_arch[cpu_architecture()], cr_alignment);
+		proc_arch[cpu_architecture()], get_cr());
 
 	snprintf(init_utsname()->machine, __NEW_UTS_LEN + 1, "%s%c",
 		 list->arch_name, ENDIANNESS);

commit 95959e6a06720834fc80a210e37898341c63cb91
Merge: f210c53a82ab 95c52fe06335 e26a9e00afc4 dfdf5f63b438 aa4c5b962a7a 1ef2bf8227ab
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Apr 4 00:33:32 2014 +0100

    Merge branches 'amba', 'fixes', 'misc', 'mmci', 'unstable/omap-dma' and 'unstable/sa11x0' into for-next

commit 8258a9895c99cdaacad8edc4748c0a624c710961
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Feb 19 22:29:40 2014 +0100

    ARM: 7982/1: introduce HWCAP2 feature bits for ARMv8 Crypto Extensions
    
    This allocates feature bits 0-4 in HWCAP2 for the crypto and CRC
    extensions introduced in ARMv8.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index dbb5449d6b79..0a6c70b0b0f9 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -1009,6 +1009,11 @@ static const char *hwcap_str[] = {
 };
 
 static const char *hwcap2_str[] = {
+	"aes",
+	"pmull",
+	"sha1",
+	"sha2",
+	"crc32",
 	NULL
 };
 

commit b342ea4e4ff970518264c81eefd05f637e3f193a
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Feb 19 22:28:40 2014 +0100

    ARM: 7981/1: add support for AT_HWCAP2 ELF auxv entry
    
    This enables AT_HWCAP2 for ARM. The generic support for this
    new ELF auxv entry was added in commit 2171364d1a9 (powerpc:
    Add HWCAP2 aux entry)
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index b0df9761de6d..dbb5449d6b79 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -100,6 +100,9 @@ EXPORT_SYMBOL(system_serial_high);
 unsigned int elf_hwcap __read_mostly;
 EXPORT_SYMBOL(elf_hwcap);
 
+unsigned int elf_hwcap2 __read_mostly;
+EXPORT_SYMBOL(elf_hwcap2);
+
 
 #ifdef MULTI_CPU
 struct processor processor __read_mostly;
@@ -1005,6 +1008,10 @@ static const char *hwcap_str[] = {
 	NULL
 };
 
+static const char *hwcap2_str[] = {
+	NULL
+};
+
 static int c_show(struct seq_file *m, void *v)
 {
 	int i, j;
@@ -1028,6 +1035,10 @@ static int c_show(struct seq_file *m, void *v)
 			if (elf_hwcap & (1 << j))
 				seq_printf(m, "%s ", hwcap_str[j]);
 
+		for (j = 0; hwcap2_str[j]; j++)
+			if (elf_hwcap2 & (1 << j))
+				seq_printf(m, "%s ", hwcap2_str[j]);
+
 		seq_printf(m, "\nCPU implementer\t: 0x%02x\n", cpuid >> 24);
 		seq_printf(m, "CPU architecture: %s\n",
 			   proc_arch[cpu_architecture()]);

commit ca4744084772e1fee999391bee0fcdca5d91a757
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Thu Feb 6 19:50:35 2014 +0100

    ARM: 7952/1: mm: Fix the memblock allocation for LPAE machines
    
    Commit ad6492b8 added much needed memblock_virt_alloc_low() and further
    commit 07bacb3 {memblock, bootmem: restore goal for alloc_low} fixed
    the issue with low memory limit thanks to Yinghai. But even after all
    these fixes, there is still one case where the limit check done with
    ARCH_LOW_ADDRESS_LIMIT for low memory fails. Russell pointed out the
    issue with 32 bit LPAE machines in below thread.
            https://lkml.org/lkml/2014/1/28/364
    
    Since on some LPAE machines where memory start address is beyond 4GB,
    the low memory marker in memblock will be set to default
    ARCH_LOW_ADDRESS_LIMIT which is wrong. We can fix this by letting
    architectures set the ARCH_LOW_ADDRESS_LIMIT using another export
    similar to memblock_set_current_limit() but am not sure whether
    its worth the trouble. Tell me if you think otherwise.
    
    Rather am just trying to fix that one broken case using
    memblock_virt_alloc() in setup code since the memblock.current_limit
    is updated appropriately makes it work on all ARM 32 bit machines.
    
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Strashko, Grygorii <grygorii.strashko@ti.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index b0df9761de6d..1e8b030dbefd 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -731,7 +731,7 @@ static void __init request_standard_resources(const struct machine_desc *mdesc)
 	kernel_data.end     = virt_to_phys(_end - 1);
 
 	for_each_memblock(memory, region) {
-		res = memblock_virt_alloc_low(sizeof(*res), 0);
+		res = memblock_virt_alloc(sizeof(*res), 0);
 		res->name  = "System RAM";
 		res->start = __pfn_to_phys(memblock_region_memory_base_pfn(region));
 		res->end = __pfn_to_phys(memblock_region_memory_end_pfn(region)) - 1;

commit ad6492b80f60a2139fa9bf8fd79b182fe5e3647c
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Jan 27 17:06:49 2014 -0800

    memblock, nobootmem: add memblock_virt_alloc_low()
    
    The new memblock_virt APIs are used to replaced old bootmem API.
    
    We need to allocate page below 4G for swiotlb.
    
    That should fix regression on Andrew's system that is using swiotlb.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 1e8b030dbefd..b0df9761de6d 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -731,7 +731,7 @@ static void __init request_standard_resources(const struct machine_desc *mdesc)
 	kernel_data.end     = virt_to_phys(_end - 1);
 
 	for_each_memblock(memory, region) {
-		res = memblock_virt_alloc(sizeof(*res), 0);
+		res = memblock_virt_alloc_low(sizeof(*res), 0);
 		res->name  = "System RAM";
 		res->start = __pfn_to_phys(memblock_region_memory_base_pfn(region));
 		res->end = __pfn_to_phys(memblock_region_memory_end_pfn(region)) - 1;

commit f341535193c338b4ce4af8e32be51e6aae7f22a6
Merge: 13c789a6b219 857989a7fdd2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 23 18:34:03 2014 -0800

    Merge branch 'for-linus' of git://ftp.arm.linux.org.uk/~rmk/linux-arm
    
    Pull ARM updates from Russell King:
     "In this set, we have:
       - Refactoring of some of the old StrongARM-1100 GPIO code to make
         things simpler by Dmitry Eremin-Solenikov
       - Read-only and non-executable support for modules on ARM from Laura
         Abbot
       - Removal of unnecessary set_drvdata() calls in AMBA code
       - Some non-executable support for kernel lowmem mappings at the 1MB
         section granularity, and dumping of kernel page tables via debugfs
       - Some improvements for the timer/clock code on Footbridge platforms,
         and cleanup some of the LED code there
       - Fix fls/ffs() signatures to match x86 to prevent build warnings,
         particularly where these are used with min/max() macros
       - Avoid using the bootmem allocator on ARM (patches from Santosh
         Shilimkar)
       - Various asid/unaligned access updates from Will Deacon"
    
    * 'for-linus' of git://ftp.arm.linux.org.uk/~rmk/linux-arm: (51 commits)
      ARM: SMP implementations are not supposed to return from smp_ops.cpu_die()
      ARM: ignore memory below PHYS_OFFSET
      Fix select-induced Kconfig warning for ZBOOT_ROM
      ARM: fix ffs/fls implementations to match x86
      ARM: 7935/1: sa1100: collie: add gpio-keys configuration
      ARM: 7932/1: bcm: Add DEBUG_LL console support
      ARM: 7929/1: Remove duplicate SCHED_HRTICK config option
      ARM: 7928/1: kconfig: select HAVE_EFFICIENT_UNALIGNED_ACCESS for CPUv6+ && MMU
      ARM: 7927/1: dcache: select DCACHE_WORD_ACCESS for big-endian CPUs
      ARM: 7926/1: mm: flesh out and fix the comments in the ASID allocator
      ARM: 7925/1: mm: keep track of last ASID allocation to improve bitmap searching
      ARM: 7924/1: mm: don't bother with reserved ttbr0 when running with LPAE
      ARM: PCI: add legacy IDE IRQ implementation
      ARM: footbridge: cleanup LEDs code
      ARM: pgd allocation: retry on failure
      ARM: footbridge: add one-shot mode for DC21285 timer
      ARM: footbridge: add sched_clock implementation
      ARM: 7922/1: l2x0: add Marvell Tauros3 support
      ARM: 7877/1: use built-in byte swap function
      ARM: 7921/1: mcpm: remove redundant dsb instructions prior to sev
      ...

commit 9233d2be108f573caa21eb450411bf8fa68cadbb
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Tue Jan 21 15:50:47 2014 -0800

    arch/arm/kernel/: use memblock apis for early memory allocations
    
    Switch to memblock interfaces for early memory allocator instead of
    bootmem allocator.  No functional change in beahvior than what it is in
    current code from bootmem users points of view.
    
    Archs already converted to NO_BOOTMEM now directly use memblock
    interfaces instead of bootmem wrappers build on top of memblock.  And
    the archs which still uses bootmem, these new apis just fallback to
    exiting bootmem APIs.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Christoph Lameter <cl@linux-foundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 987a7f5bce5f..8ce1cbd08dba 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -717,7 +717,7 @@ static void __init request_standard_resources(const struct machine_desc *mdesc)
 	kernel_data.end     = virt_to_phys(_end - 1);
 
 	for_each_memblock(memory, region) {
-		res = alloc_bootmem_low(sizeof(*res));
+		res = memblock_virt_alloc(sizeof(*res), 0);
 		res->name  = "System RAM";
 		res->start = __pfn_to_phys(memblock_region_memory_base_pfn(region));
 		res->end = __pfn_to_phys(memblock_region_memory_end_pfn(region)) - 1;

commit 857989a7fdd2f6de42272578b8aaa413ed6e63e4
Merge: 6f14d778c15f 7990ac9cb25d
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jan 21 21:26:51 2014 +0000

    Merge branch 'devel-stable' into for-next

commit 571b14375019c3a66ef70d4d4a7083f4238aca30
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jan 11 11:22:18 2014 +0000

    ARM: ignore memory below PHYS_OFFSET
    
    If the kernel is loaded higher in physical memory than normal, and we
    calculate PHYS_OFFSET higher than the start of RAM, this leads to
    boot problems as we attempt to map part of this RAM into userspace.
    Rather than struggle with this, just truncate the mapping.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 7a2dd4689a75..061cea820e3f 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -660,6 +660,20 @@ int __init arm_add_memory(u64 start, u64 size)
 	}
 #endif
 
+	if (aligned_start < PHYS_OFFSET) {
+		if (aligned_start + size <= PHYS_OFFSET) {
+			pr_info("Ignoring memory below PHYS_OFFSET: 0x%08llx-0x%08llx\n",
+				aligned_start, aligned_start + size);
+			return -EINVAL;
+		}
+
+		pr_info("Ignoring memory below PHYS_OFFSET: 0x%08llx-0x%08llx\n",
+			aligned_start, (u64)PHYS_OFFSET);
+
+		size -= PHYS_OFFSET - aligned_start;
+		aligned_start = PHYS_OFFSET;
+	}
+
 	bank->start = aligned_start;
 	bank->size = size & ~(phys_addr_t)(PAGE_SIZE - 1);
 

commit 7990ac9cb25d378b6311f3591f010e53a9967066
Merge: 23f6620a360d 84f452b1e8fc
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Jan 13 23:36:45 2014 +0000

    Merge branch 'for_3.14/arm-no-bootmem' of git://git.kernel.org/pub/scm/linux/kernel/git/ssantosh/linux-keystone into devel-stable

commit 1b0f6681fcbc0e6365f42ef11beb882c9f73c945
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Dec 5 18:29:35 2013 +0100

    ARM: 7911/2: Clean up setup printks a bit
    
    Clean up the setup ARM printks a bit. Add printk level to a few
    that were missing (CPU: <...> ones, in particular), and switch from
    printk(KERN_* ..) to pr_*().
    
    Finally, un-wrap some long lines since it makes it harder to grep the
    sources from where an error came from and tweak some cases of indentation.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 987a7f5bce5f..7a2dd4689a75 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -334,7 +334,7 @@ static void __init cacheid_init(void)
 		cacheid = CACHEID_VIVT;
 	}
 
-	printk("CPU: %s data cache, %s instruction cache\n",
+	pr_info("CPU: %s data cache, %s instruction cache\n",
 		cache_is_vivt() ? "VIVT" :
 		cache_is_vipt_aliasing() ? "VIPT aliasing" :
 		cache_is_vipt_nonaliasing() ? "PIPT / VIPT nonaliasing" : "unknown",
@@ -416,7 +416,7 @@ void notrace cpu_init(void)
 	struct stack *stk = &stacks[cpu];
 
 	if (cpu >= NR_CPUS) {
-		printk(KERN_CRIT "CPU%u: bad primary CPU number\n", cpu);
+		pr_crit("CPU%u: bad primary CPU number\n", cpu);
 		BUG();
 	}
 
@@ -484,7 +484,7 @@ void __init smp_setup_processor_id(void)
 	 */
 	set_my_cpu_offset(0);
 
-	printk(KERN_INFO "Booting Linux on physical CPU 0x%x\n", mpidr);
+	pr_info("Booting Linux on physical CPU 0x%x\n", mpidr);
 }
 
 struct mpidr_hash mpidr_hash;
@@ -564,8 +564,8 @@ static void __init setup_processor(void)
 	 */
 	list = lookup_processor_type(read_cpuid_id());
 	if (!list) {
-		printk("CPU configuration botched (ID %08x), unable "
-		       "to continue.\n", read_cpuid_id());
+		pr_err("CPU configuration botched (ID %08x), unable to continue.\n",
+		       read_cpuid_id());
 		while (1);
 	}
 
@@ -585,9 +585,9 @@ static void __init setup_processor(void)
 	cpu_cache = *list->cache;
 #endif
 
-	printk("CPU: %s [%08x] revision %d (ARMv%s), cr=%08lx\n",
-	       cpu_name, read_cpuid_id(), read_cpuid_id() & 15,
-	       proc_arch[cpu_architecture()], cr_alignment);
+	pr_info("CPU: %s [%08x] revision %d (ARMv%s), cr=%08lx\n",
+		cpu_name, read_cpuid_id(), read_cpuid_id() & 15,
+		proc_arch[cpu_architecture()], cr_alignment);
 
 	snprintf(init_utsname()->machine, __NEW_UTS_LEN + 1, "%s%c",
 		 list->arch_name, ENDIANNESS);
@@ -629,8 +629,8 @@ int __init arm_add_memory(u64 start, u64 size)
 	u64 aligned_start;
 
 	if (meminfo.nr_banks >= NR_BANKS) {
-		printk(KERN_CRIT "NR_BANKS too low, "
-			"ignoring memory at 0x%08llx\n", (long long)start);
+		pr_crit("NR_BANKS too low, ignoring memory at 0x%08llx\n",
+			(long long)start);
 		return -EINVAL;
 	}
 
@@ -643,14 +643,14 @@ int __init arm_add_memory(u64 start, u64 size)
 
 #ifndef CONFIG_ARCH_PHYS_ADDR_T_64BIT
 	if (aligned_start > ULONG_MAX) {
-		printk(KERN_CRIT "Ignoring memory at 0x%08llx outside "
-		       "32-bit physical address space\n", (long long)start);
+		pr_crit("Ignoring memory at 0x%08llx outside 32-bit physical address space\n",
+			(long long)start);
 		return -EINVAL;
 	}
 
 	if (aligned_start + size > ULONG_MAX) {
-		printk(KERN_CRIT "Truncating memory at 0x%08llx to fit in "
-			"32-bit physical address space\n", (long long)start);
+		pr_crit("Truncating memory at 0x%08llx to fit in 32-bit physical address space\n",
+			(long long)start);
 		/*
 		 * To ensure bank->start + bank->size is representable in
 		 * 32 bits, we use ULONG_MAX as the upper limit rather than 4GB.
@@ -819,16 +819,15 @@ static void __init reserve_crashkernel(void)
 
 	ret = reserve_bootmem(crash_base, crash_size, BOOTMEM_EXCLUSIVE);
 	if (ret < 0) {
-		printk(KERN_WARNING "crashkernel reservation failed - "
-		       "memory is in use (0x%lx)\n", (unsigned long)crash_base);
+		pr_warn("crashkernel reservation failed - memory is in use (0x%lx)\n",
+			(unsigned long)crash_base);
 		return;
 	}
 
-	printk(KERN_INFO "Reserving %ldMB of memory at %ldMB "
-	       "for crashkernel (System RAM: %ldMB)\n",
-	       (unsigned long)(crash_size >> 20),
-	       (unsigned long)(crash_base >> 20),
-	       (unsigned long)(total_mem >> 20));
+	pr_info("Reserving %ldMB of memory at %ldMB for crashkernel (System RAM: %ldMB)\n",
+		(unsigned long)(crash_size >> 20),
+		(unsigned long)(crash_base >> 20),
+		(unsigned long)(total_mem >> 20));
 
 	crashk_res.start = crash_base;
 	crashk_res.end = crash_base + crash_size - 1;

commit 7c927322d349e37eef38d121c6f596ba816a40b2
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Mon Dec 2 20:29:59 2013 +0100

    ARM: 7909/1: mm: Call setup_dma_zone() post early_paging_init()
    
    To get updated __pv_phys_offset, setup_dma_zone() needs to be
    called after early_paging_init().
    
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Nicolas Pitre <nicolas.pitre@linaro.org>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 6a1b8a81b1ae..987a7f5bce5f 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -873,8 +873,6 @@ void __init setup_arch(char **cmdline_p)
 	machine_desc = mdesc;
 	machine_name = mdesc->name;
 
-	setup_dma_zone(mdesc);
-
 	if (mdesc->reboot_mode != REBOOT_HARD)
 		reboot_mode = mdesc->reboot_mode;
 
@@ -892,6 +890,7 @@ void __init setup_arch(char **cmdline_p)
 	sort(&meminfo.bank, meminfo.nr_banks, sizeof(meminfo.bank[0]), meminfo_cmp, NULL);
 
 	early_paging_init(mdesc, lookup_processor_type(read_cpuid_id()));
+	setup_dma_zone(mdesc);
 	sanity_check_meminfo();
 	arm_memblock_init(&meminfo, mdesc);
 

commit 84f452b1e8fc73ac0e31254c66e3e2260ce5263d
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Sun Jun 30 00:28:46 2013 -0400

    ARM: mm: Remove bootmem code and switch to NO_BOOTMEM
    
    Now with dma_mask series merged and max*pfn has consistent meaning on ARM
    as rest of the arch's thanks to RMK's mega series, lets switch ARM code
    to NO_BOOTMEM. With NO_BOOTMEM change, now we use memblock allocator to
    reserve space for crash kernel to have one less dependency with nobootmem
    allocator wrapper.
    
    Tested with both flat memory and sparse (faked) memory models with highmem
    enabled.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Nicolas Pitre <nicolas.pitre@linaro.org>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 6a1b8a81b1ae..e9f629f21769 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -817,7 +817,7 @@ static void __init reserve_crashkernel(void)
 	if (ret)
 		return;
 
-	ret = reserve_bootmem(crash_base, crash_size, BOOTMEM_EXCLUSIVE);
+	ret = memblock_reserve(crash_base, crash_size);
 	if (ret < 0) {
 		printk(KERN_WARNING "crashkernel reservation failed - "
 		       "memory is in use (0x%lx)\n", (unsigned long)crash_base);

commit f47671e2d861a2093179cd64dda22016664b2015
Merge: 8ceafbfa91ff 42cbe8271ca6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 14 08:51:29 2013 +0900

    Merge branch 'for-linus' of git://git.linaro.org/people/rmk/linux-arm
    
    Pull ARM updates from Russell King:
     "Included in this series are:
    
       1. BE8 (modern big endian) changes for ARM from Ben Dooks
       2. big.Little support from Nicolas Pitre and Dave Martin
       3. support for LPAE systems with all system memory above 4GB
       4. Perf updates from Will Deacon
       5. Additional prefetching and other performance improvements from Will.
       6. Neon-optimised AES implementation fro Ard.
       7. A number of smaller fixes scattered around the place.
    
      There is a rather horrid merge conflict in tools/perf - I was never
      notified of the conflict because it originally occurred between Will's
      tree and other stuff.  Consequently I have a resolution which Will
      forwarded me, which I'll forward on immediately after sending this
      mail.
    
      The other notable thing is I'm expecting some build breakage in the
      crypto stuff on ARM only with Ard's AES patches.  These were merged
      into a stable git branch which others had already pulled, so there's
      little I can do about this.  The problem is caused because these
      patches have a dependency on some code in the crypto git tree - I
      tried requesting a branch I can pull to resolve these, and all I got
      each time from the crypto people was "we'll revert our patches then"
      which would only make things worse since I still don't have the
      dependent patches.  I've no idea what's going on there or how to
      resolve that, and since I can't split these patches from the rest of
      this pull request, I'm rather stuck with pushing this as-is or
      reverting Ard's patches.
    
      Since it should "come out in the wash" I've left them in - the only
      build problems they seem to cause at the moment are with randconfigs,
      and since it's a new feature anyway.  However, if by -rc1 the
      dependencies aren't in, I think it'd be best to revert Ard's patches"
    
    I resolved the perf conflict roughly as per the patch sent by Russell,
    but there may be some differences.  Any errors are likely mine.  Let's
    see how the crypto issues work out..
    
    * 'for-linus' of git://git.linaro.org/people/rmk/linux-arm: (110 commits)
      ARM: 7868/1: arm/arm64: remove atomic_clear_mask() in "include/asm/atomic.h"
      ARM: 7867/1: include: asm: use 'int' instead of 'unsigned long' for 'oldval' in atomic_cmpxchg().
      ARM: 7866/1: include: asm: use 'long long' instead of 'u64' within atomic.h
      ARM: 7871/1: amba: Extend number of IRQS
      ARM: 7887/1: Don't smp_cross_call() on UP devices in arch_irq_work_raise()
      ARM: 7872/1: Support arch_irq_work_raise() via self IPIs
      ARM: 7880/1: Clear the IT state independent of the Thumb-2 mode
      ARM: 7878/1: nommu: Implement dummy early_paging_init()
      ARM: 7876/1: clear Thumb-2 IT state on exception handling
      ARM: 7874/2: bL_switcher: Remove cpu_hotplug_driver_{lock,unlock}()
      ARM: footbridge: fix build warnings for netwinder
      ARM: 7873/1: vfp: clear vfp_current_hw_state for dying cpu
      ARM: fix misplaced arch_virt_to_idmap()
      ARM: 7848/1: mcpm: Implement cpu_kill() to synchronise on powerdown
      ARM: 7847/1: mcpm: Factor out logical-to-physical CPU translation
      ARM: 7869/1: remove unused XSCALE_PMU Kconfig param
      ARM: 7864/1: Handle 64-bit memory in case of 32-bit phys_addr_t
      ARM: 7863/1: Let arm_add_memory() always use 64-bit arguments
      ARM: 7862/1: pcpu: replace __get_cpu_var_uses
      ARM: 7861/1: cacheflush: consolidate single-CPU ARMv7 cache disabling code
      ...

commit df762eccbadf87850fbee444d729e0f1b1e946f1
Merge: ec1e20a02fe3 70d42126877b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Nov 12 10:58:59 2013 +0000

    Merge branch 'devel-stable' into for-next
    
    Conflicts:
            arch/arm/include/asm/atomic.h
            arch/arm/include/asm/hardirq.h
            arch/arm/kernel/smp.c

commit 6d7d5da7d75c6df676c8b72d32b02ff024438f0c
Author: Magnus Damm <damm@opensource.se>
Date:   Tue Oct 22 17:59:54 2013 +0100

    ARM: 7864/1: Handle 64-bit memory in case of 32-bit phys_addr_t
    
    Use CONFIG_ARCH_PHYS_ADDR_T_64BIT to determine
    if ignoring or truncating of memory banks is
    neccessary. This may be needed in the case of
    64-bit memory bank addresses but when phys_addr_t
    is kept 32-bit.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 5ec4443af08b..53c3901f7ee3 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -624,6 +624,7 @@ void __init dump_machine_table(void)
 int __init arm_add_memory(u64 start, u64 size)
 {
 	struct membank *bank = &meminfo.bank[meminfo.nr_banks];
+	u64 aligned_start;
 
 	if (meminfo.nr_banks >= NR_BANKS) {
 		printk(KERN_CRIT "NR_BANKS too low, "
@@ -636,10 +637,16 @@ int __init arm_add_memory(u64 start, u64 size)
 	 * Size is appropriately rounded down, start is rounded up.
 	 */
 	size -= start & ~PAGE_MASK;
-	bank->start = PAGE_ALIGN(start);
+	aligned_start = PAGE_ALIGN(start);
 
-#ifndef CONFIG_ARM_LPAE
-	if (bank->start + size < bank->start) {
+#ifndef CONFIG_ARCH_PHYS_ADDR_T_64BIT
+	if (aligned_start > ULONG_MAX) {
+		printk(KERN_CRIT "Ignoring memory at 0x%08llx outside "
+		       "32-bit physical address space\n", (long long)start);
+		return -EINVAL;
+	}
+
+	if (aligned_start + size > ULONG_MAX) {
 		printk(KERN_CRIT "Truncating memory at 0x%08llx to fit in "
 			"32-bit physical address space\n", (long long)start);
 		/*
@@ -647,10 +654,11 @@ int __init arm_add_memory(u64 start, u64 size)
 		 * 32 bits, we use ULONG_MAX as the upper limit rather than 4GB.
 		 * This means we lose a page after masking.
 		 */
-		size = ULONG_MAX - bank->start;
+		size = ULONG_MAX - aligned_start;
 	}
 #endif
 
+	bank->start = aligned_start;
 	bank->size = size & ~(phys_addr_t)(PAGE_SIZE - 1);
 
 	/*

commit 6a5014aa037495a14ea083b621ed97fd0c3c7e9e
Author: Magnus Damm <damm@opensource.se>
Date:   Tue Oct 22 17:53:16 2013 +0100

    ARM: 7863/1: Let arm_add_memory() always use 64-bit arguments
    
    The DTB and/or the kernel command line may pass
    64-bit addresses regardless of kernel configuration,
    so update arm_add_memory() to take 64-bit arguments
    independently of the phys_addr_t size.
    
    This allows non-wrapping handling of high memory
    banks such as the second memory bank of APE6EVM
    (at 0x2_0000_0000) in case of 32-bit phys_addr_t.
    
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index a4852dea088b..5ec4443af08b 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -621,7 +621,7 @@ void __init dump_machine_table(void)
 		/* can't use cpu_relax() here as it may require MMU setup */;
 }
 
-int __init arm_add_memory(phys_addr_t start, phys_addr_t size)
+int __init arm_add_memory(u64 start, u64 size)
 {
 	struct membank *bank = &meminfo.bank[meminfo.nr_banks];
 
@@ -671,8 +671,8 @@ int __init arm_add_memory(phys_addr_t start, phys_addr_t size)
 static int __init early_mem(char *p)
 {
 	static int usermem __initdata = 0;
-	phys_addr_t size;
-	phys_addr_t start;
+	u64 size;
+	u64 start;
 	char *endp;
 
 	/*

commit 92871b94a5f9892e324c31960678387922c75049
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Wed Oct 9 17:26:44 2013 +0100

    ARM: 7855/1: Add check for Cortex-A15 errata 798181 ECO
    
    The work-around for A15 errata 798181 is not needed if appropriate ECO
    fixes have been applied to r3p2 and earlier core revisions. This can be
    checked by reading REVIDR register bits 4 and 9. If only bit 4 is set,
    then the IPI broadcast can be skipped.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Reviewed-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 0e1e2b3afa45..a4852dea088b 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -599,6 +599,8 @@ static void __init setup_processor(void)
 	elf_hwcap &= ~(HWCAP_THUMB | HWCAP_IDIVT);
 #endif
 
+	erratum_a15_798181_init();
+
 	feat_v6_fixup();
 
 	cacheid_init();

commit a77e0c7b2774fd52ce6bf25c2c3ffdccb7b110ff
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Wed Jul 31 12:44:46 2013 -0400

    ARM: mm: Recreate kernel mappings in early_paging_init()
    
    This patch adds a step in the init sequence, in order to recreate
    the kernel code/data page table mappings prior to full paging
    initialization.  This is necessary on LPAE systems that run out of
    a physical address space outside the 4G limit.  On these systems,
    this implementation provides a machine descriptor hook that allows
    the PHYS_OFFSET to be overridden in a machine specific fashion.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: R Sricharan <r.sricharan@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 0e1e2b3afa45..af7b7db4699e 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -73,6 +73,8 @@ __setup("fpe=", fpe_setup);
 #endif
 
 extern void paging_init(const struct machine_desc *desc);
+extern void early_paging_init(const struct machine_desc *,
+			      struct proc_info_list *);
 extern void sanity_check_meminfo(void);
 extern enum reboot_mode reboot_mode;
 extern void setup_dma_zone(const struct machine_desc *desc);
@@ -878,6 +880,8 @@ void __init setup_arch(char **cmdline_p)
 	parse_early_param();
 
 	sort(&meminfo.bank, meminfo.nr_banks, sizeof(meminfo.bank[0]), meminfo_cmp, NULL);
+
+	early_paging_init(mdesc, lookup_processor_type(read_cpuid_id()));
 	sanity_check_meminfo();
 	arm_memblock_init(&meminfo, mdesc);
 

commit e9faebc66ec74f1ab7f267d683b45e80faa69763
Author: Sudeep KarkadaNagesha <sudeep.karkadanagesha@arm.com>
Date:   Tue Aug 13 14:30:32 2013 +0100

    ARM: arch_timer: add support to configure and enable event stream
    
    This patch adds support for configuring the event stream frequency
    and enabling it.
    
    It also adds the hwcaps definitions to the user to detect this event
    stream feature.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Sudeep KarkadaNagesha <sudeep.karkadanagesha@arm.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 0e1e2b3afa45..5d65438685d8 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -975,6 +975,7 @@ static const char *hwcap_str[] = {
 	"idivt",
 	"vfpd32",
 	"lpae",
+	"evtstrm",
 	NULL
 };
 

commit 141b97433d77e39ac3ac111a7b3852192035259c
Merge: d8dfad3876e4 8d258beb76e3 5cc91e046088 9fc2105aeaaf
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Sep 5 10:34:15 2013 +0100

    Merge branches 'debug-choice', 'devel-stable' and 'misc' into for-linus

commit 9fc2105aeaaf56b0cf75296a84702d0f9e64437b
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Aug 30 18:10:16 2013 +0100

    ARM: 7830/1: delay: don't bother reporting bogomips in /proc/cpuinfo
    
    Now that we support a timer-backed delay loop, I'm quickly getting sick
    and tired of people complaining that their beloved bogomips value has
    decreased. You know who you are!
    
    This patch removes the bogomips line from /proc/cpuinfo, based on the
    reasoning that any program parsing this is already broken and, as such,
    won't be further broken if the field is removed.
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 863629989f02..6c1a8be5509d 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -991,15 +991,6 @@ static int c_show(struct seq_file *m, void *v)
 		seq_printf(m, "model name\t: %s rev %d (%s)\n",
 			   cpu_name, cpuid & 15, elf_platform);
 
-#if defined(CONFIG_SMP)
-		seq_printf(m, "BogoMIPS\t: %lu.%02lu\n",
-			   per_cpu(cpu_data, i).loops_per_jiffy / (500000UL/HZ),
-			   (per_cpu(cpu_data, i).loops_per_jiffy / (5000UL/HZ)) % 100);
-#else
-		seq_printf(m, "BogoMIPS\t: %lu.%02lu\n",
-			   loops_per_jiffy / (500000/HZ),
-			   (loops_per_jiffy / (5000/HZ)) % 100);
-#endif
 		/* dump out the processor features */
 		seq_puts(m, "Features\t: ");
 

commit ff69a4c855066592f9e293cff8f54813614dd544
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Jul 26 14:55:59 2013 +0100

    ARM: constify machine_desc structure uses
    
    struct machine_desc records are defined everywhere as a 'const'
    structure, but unfortuantely it loses its const-ness through the use of
    linker magic - the symbols which surround the section are not declared
    const so it becomes possible not to use 'const' for pointers to these
    const structures.
    
    Let's fix this oversight - all pointers to these structures should be
    marked const too.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 63af9a7ae512..863629989f02 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -72,10 +72,10 @@ static int __init fpe_setup(char *line)
 __setup("fpe=", fpe_setup);
 #endif
 
-extern void paging_init(struct machine_desc *desc);
+extern void paging_init(const struct machine_desc *desc);
 extern void sanity_check_meminfo(void);
 extern enum reboot_mode reboot_mode;
-extern void setup_dma_zone(struct machine_desc *desc);
+extern void setup_dma_zone(const struct machine_desc *desc);
 
 unsigned int processor_id;
 EXPORT_SYMBOL(processor_id);
@@ -139,7 +139,7 @@ EXPORT_SYMBOL(elf_platform);
 static const char *cpu_name;
 static const char *machine_name;
 static char __initdata cmd_line[COMMAND_LINE_SIZE];
-struct machine_desc *machine_desc __initdata;
+const struct machine_desc *machine_desc __initdata;
 
 static union { char c[4]; unsigned long l; } endian_test __initdata = { { 'l', '?', '?', 'b' } };
 #define ENDIANNESS ((char)endian_test.l)
@@ -607,7 +607,7 @@ static void __init setup_processor(void)
 
 void __init dump_machine_table(void)
 {
-	struct machine_desc *p;
+	const struct machine_desc *p;
 
 	early_print("Available machine support:\n\nID (hex)\tNAME\n");
 	for_each_machine_desc(p)
@@ -694,7 +694,7 @@ static int __init early_mem(char *p)
 }
 early_param("mem", early_mem);
 
-static void __init request_standard_resources(struct machine_desc *mdesc)
+static void __init request_standard_resources(const struct machine_desc *mdesc)
 {
 	struct memblock_region *region;
 	struct resource *res;
@@ -850,7 +850,7 @@ void __init hyp_mode_check(void)
 
 void __init setup_arch(char **cmdline_p)
 {
-	struct machine_desc *mdesc;
+	const struct machine_desc *mdesc;
 
 	setup_processor();
 	mdesc = setup_machine_fdt(__atags_pointer);

commit 8fbac214e5c594a0c2fe78c14adf2cdbb1febc92
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Thu Jul 18 17:20:33 2013 +0100

    ARM: 7787/1: virt: ensure visibility of __boot_cpu_mode
    
    Secondary CPUs write to __boot_cpu_mode with caches disabled, and thus a
    cached value of __boot_cpu_mode may be incoherent with that in memory.
    This could lead to a failure to detect mismatched boot modes.
    
    This patch adds flushing to ensure that writes by secondaries to
    __boot_cpu_mode are made visible before we test against it.
    
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Acked-by: Dave Martin <Dave.Martin@arm.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Christoffer Dall <cdall@cs.columbia.edu>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 96286cb383bd..afc2489ee13b 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -836,6 +836,8 @@ static int __init meminfo_cmp(const void *_a, const void *_b)
 void __init hyp_mode_check(void)
 {
 #ifdef CONFIG_ARM_VIRT_EXT
+	sync_boot_mode();
+
 	if (is_hyp_mode_available()) {
 		pr_info("CPU: All CPU(s) started in HYP mode.\n");
 		pr_info("CPU: Virtualization extensions available.\n");

commit ab8d46c0609843a83aef3f486365ca5e7c21d537
Author: Tetsuyuki Kobayashi <koba@kmckk.co.jp>
Date:   Mon Jul 22 14:58:17 2013 +0100

    ARM: 7788/1: elf: fix lpae hwcap feature reporting in proc/cpuinfo
    
    Commit a469abd0f868 ("ARM: elf: add new hwcap for identifying atomic
    ldrd/strd instructions") added a new hwcap to identify LPAE on CPUs
    which support it. Whilst the hwcap data is correct, the string reported
    in /proc/cpuinfo actually matches on HWCAP_VFPD32, which was missing
    an entry in the string table.
    
    This patch fixes this problem by adding a "vfpd32" string at the correct
    offset, preventing us from falsely advertising LPAE on CPUs which do not
    support it.
    
    [will: added commit message]
    
    Acked-by: Will Deacon <will.deacon@arm.com>
    Tested-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Tetsuyuki Kobayashi <koba@kmckk.co.jp>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 63af9a7ae512..96286cb383bd 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -971,6 +971,7 @@ static const char *hwcap_str[] = {
 	"vfpv4",
 	"idiva",
 	"idivt",
+	"vfpd32",
 	"lpae",
 	NULL
 };

commit 16d6d5b00ee75307bab7e4ede9452c97b28f30e2
Author: Robin Holt <holt@sgi.com>
Date:   Mon Jul 8 16:01:39 2013 -0700

    reboot: arm: prepare reboot_mode for moving to generic kernel code
    
    Prepare for the moving the parsing of reboot= to the generic kernel code
    by making reboot_mode into a more generic form.
    
    Signed-off-by: Robin Holt <holt@sgi.com>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Russ Anderson <rja@sgi.com>
    Cc: Robin Holt <holt@sgi.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 9b653278c9e8..63af9a7ae512 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -74,7 +74,7 @@ __setup("fpe=", fpe_setup);
 
 extern void paging_init(struct machine_desc *desc);
 extern void sanity_check_meminfo(void);
-extern void reboot_setup(char *str);
+extern enum reboot_mode reboot_mode;
 extern void setup_dma_zone(struct machine_desc *desc);
 
 unsigned int processor_id;
@@ -861,8 +861,8 @@ void __init setup_arch(char **cmdline_p)
 
 	setup_dma_zone(mdesc);
 
-	if (mdesc->restart_mode)
-		reboot_setup(&mdesc->restart_mode);
+	if (mdesc->reboot_mode != REBOOT_HARD)
+		reboot_mode = mdesc->reboot_mode;
 
 	init_mm.start_code = (unsigned long) _text;
 	init_mm.end_code   = (unsigned long) _etext;

commit 3c0c01ab742ddfaf6b6f2d64b890e77cda4b7727
Merge: cbd379b10019 809e660f438f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jun 29 11:44:43 2013 +0100

    Merge branch 'devel-stable' into for-next
    
    Conflicts:
            arch/arm/Makefile
            arch/arm/include/asm/glue-proc.h

commit cbd379b10019617457bda31eb243890f4377fa3e
Merge: 3e0a07f8c401 6c93dd438aad 1b21376a737a 012596200077
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jun 29 11:43:28 2013 +0100

    Merge branches 'fixes', 'mcpm', 'misc' and 'mmci' into for-next

commit 18d7f152df31e5a326301fdaad385e40874dff80
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Jun 19 10:40:48 2013 +0100

    ARM: 7763/1: kernel: fix __cpu_logical_map default initialization
    
    The __cpu_logical_map array is statically initialized to 0, which is a valid
    MPIDR value. To prevent issues with the current implementation, this patch
    defines an MPIDR_INVALID value, and statically initializes the
    __cpu_logical_map[] array to it. Entries in the arm_dt_init_cpu_maps()
    tmp_map array used to stash DT reg properties while parsing DT are initialized
    with the MPIDR_INVALID value as well for consistency.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 1522c7ae31b0..b4b1d397592b 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -444,7 +444,7 @@ void notrace cpu_init(void)
 	    : "r14");
 }
 
-int __cpu_logical_map[NR_CPUS];
+u32 __cpu_logical_map[NR_CPUS] = { [0 ... NR_CPUS-1] = MPIDR_INVALID };
 
 void __init smp_setup_processor_id(void)
 {

commit 8cf72172d739639f2699131821a3ebc291287cf2
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Thu May 16 10:32:09 2013 +0100

    ARM: kernel: build MPIDR hash function data structure
    
    On ARM SMP systems, cores are identified by their MPIDR register.
    The MPIDR guidelines in the ARM ARM do not provide strict enforcement of
    MPIDR layout, only recommendations that, if followed, split the MPIDR
    on ARM 32 bit platforms in three affinity levels. In multi-cluster
    systems like big.LITTLE, if the affinity guidelines are followed, the
    MPIDR can not be considered an index anymore. This means that the
    association between logical CPU in the kernel and the HW CPU identifier
    becomes somewhat more complicated requiring methods like hashing to
    associate a given MPIDR to a CPU logical index, in order for the look-up
    to be carried out in an efficient and scalable way.
    
    This patch provides a function in the kernel that starting from the
    cpu_logical_map, implement collision-free hashing of MPIDR values by checking
    all significative bits of MPIDR affinity level bitfields. The hashing
    can then be carried out through bits shifting and ORing; the resulting
    hash algorithm is a collision-free though not minimal hash that can be
    executed with few assembly instructions. The mpidr is filtered through a
    mpidr mask that is built by checking all bits that toggle in the set of
    MPIDRs corresponding to possible CPUs. Bits that do not toggle do not carry
    information so they do not contribute to the resulting hash.
    
    Pseudo code:
    
    /* check all bits that toggle, so they are required */
    for (i = 1, mpidr_mask = 0; i < num_possible_cpus(); i++)
            mpidr_mask |= (cpu_logical_map(i) ^ cpu_logical_map(0));
    
    /*
     * Build shifts to be applied to aff0, aff1, aff2 values to hash the mpidr
     * fls() returns the last bit set in a word, 0 if none
     * ffs() returns the first bit set in a word, 0 if none
     */
    fs0 = mpidr_mask[7:0] ? ffs(mpidr_mask[7:0]) - 1 : 0;
    fs1 = mpidr_mask[15:8] ? ffs(mpidr_mask[15:8]) - 1 : 0;
    fs2 = mpidr_mask[23:16] ? ffs(mpidr_mask[23:16]) - 1 : 0;
    ls0 = fls(mpidr_mask[7:0]);
    ls1 = fls(mpidr_mask[15:8]);
    ls2 = fls(mpidr_mask[23:16]);
    bits0 = ls0 - fs0;
    bits1 = ls1 - fs1;
    bits2 = ls2 - fs2;
    aff0_shift = fs0;
    aff1_shift = 8 + fs1 - bits0;
    aff2_shift = 16 + fs2 - (bits0 + bits1);
    u32 hash(u32 mpidr) {
            u32 l0, l1, l2;
            u32 mpidr_masked = mpidr & mpidr_mask;
            l0 = mpidr_masked & 0xff;
            l1 = mpidr_masked & 0xff00;
            l2 = mpidr_masked & 0xff0000;
            return (l0 >> aff0_shift | l1 >> aff1_shift | l2 >> aff2_shift);
    }
    
    The hashing algorithm relies on the inherent properties set in the ARM ARM
    recommendations for the MPIDR. Exotic configurations, where for instance the
    MPIDR values at a given affinity level have large holes, can end up requiring
    big hash tables since the compression of values that can be achieved through
    shifting is somewhat crippled when holes are present. Kernel warns if
    the number of buckets of the resulting hash table exceeds the number of
    possible CPUs by a factor of 4, which is a symptom of a very sparse HW
    MPIDR configuration.
    
    The hash algorithm is quite simple and can easily be implemented in assembly
    code, to be used in code paths where the kernel virtual address space is
    not set-up (ie cpu_resume) and instruction and data fetches are strongly
    ordered so code must be compact and must carry out few data accesses.
    
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Colin Cross <ccross@android.com>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Amit Kucheria <amit.kucheria@linaro.org>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Reviewed-by: Dave Martin <Dave.Martin@arm.com>
    Reviewed-by: Nicolas Pitre <nico@linaro.org>
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Tested-by: Stephen Warren <swarren@wwwdotorg.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index ca34224f891f..9048513cbe0d 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -478,6 +478,72 @@ void __init smp_setup_processor_id(void)
 	printk(KERN_INFO "Booting Linux on physical CPU 0x%x\n", mpidr);
 }
 
+struct mpidr_hash mpidr_hash;
+#ifdef CONFIG_SMP
+/**
+ * smp_build_mpidr_hash - Pre-compute shifts required at each affinity
+ *			  level in order to build a linear index from an
+ *			  MPIDR value. Resulting algorithm is a collision
+ *			  free hash carried out through shifting and ORing
+ */
+static void __init smp_build_mpidr_hash(void)
+{
+	u32 i, affinity;
+	u32 fs[3], bits[3], ls, mask = 0;
+	/*
+	 * Pre-scan the list of MPIDRS and filter out bits that do
+	 * not contribute to affinity levels, ie they never toggle.
+	 */
+	for_each_possible_cpu(i)
+		mask |= (cpu_logical_map(i) ^ cpu_logical_map(0));
+	pr_debug("mask of set bits 0x%x\n", mask);
+	/*
+	 * Find and stash the last and first bit set at all affinity levels to
+	 * check how many bits are required to represent them.
+	 */
+	for (i = 0; i < 3; i++) {
+		affinity = MPIDR_AFFINITY_LEVEL(mask, i);
+		/*
+		 * Find the MSB bit and LSB bits position
+		 * to determine how many bits are required
+		 * to express the affinity level.
+		 */
+		ls = fls(affinity);
+		fs[i] = affinity ? ffs(affinity) - 1 : 0;
+		bits[i] = ls - fs[i];
+	}
+	/*
+	 * An index can be created from the MPIDR by isolating the
+	 * significant bits at each affinity level and by shifting
+	 * them in order to compress the 24 bits values space to a
+	 * compressed set of values. This is equivalent to hashing
+	 * the MPIDR through shifting and ORing. It is a collision free
+	 * hash though not minimal since some levels might contain a number
+	 * of CPUs that is not an exact power of 2 and their bit
+	 * representation might contain holes, eg MPIDR[7:0] = {0x2, 0x80}.
+	 */
+	mpidr_hash.shift_aff[0] = fs[0];
+	mpidr_hash.shift_aff[1] = MPIDR_LEVEL_BITS + fs[1] - bits[0];
+	mpidr_hash.shift_aff[2] = 2*MPIDR_LEVEL_BITS + fs[2] -
+						(bits[1] + bits[0]);
+	mpidr_hash.mask = mask;
+	mpidr_hash.bits = bits[2] + bits[1] + bits[0];
+	pr_debug("MPIDR hash: aff0[%u] aff1[%u] aff2[%u] mask[0x%x] bits[%u]\n",
+				mpidr_hash.shift_aff[0],
+				mpidr_hash.shift_aff[1],
+				mpidr_hash.shift_aff[2],
+				mpidr_hash.mask,
+				mpidr_hash.bits);
+	/*
+	 * 4x is an arbitrary value used to warn on a hash table much bigger
+	 * than expected on most systems.
+	 */
+	if (mpidr_hash_size() > 4 * num_possible_cpus())
+		pr_warn("Large number of MPIDR hash buckets detected\n");
+	sync_cache_w(&mpidr_hash);
+}
+#endif
+
 static void __init setup_processor(void)
 {
 	struct proc_info_list *list;
@@ -825,6 +891,7 @@ void __init setup_arch(char **cmdline_p)
 				smp_set_ops(mdesc->smp);
 		}
 		smp_init_cpus();
+		smp_build_mpidr_hash();
 	}
 #endif
 

commit 3fbd55ec21e698221ffb43526090137b07c32586
Merge: b3f288de7c8a a469abd0f868
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jun 18 20:11:32 2013 +0100

    Merge branch 'for-rmk/lpae' of git://git.kernel.org/pub/scm/linux/kernel/git/will/linux into devel-stable
    
    Conflicts:
            arch/arm/kernel/smp.c
    
    Please pull these miscellaneous LPAE fixes I've been collecting for a while
    now for 3.11. They've been tested and reviewed by quite a few people, and most
    of the patches are pretty trivial. -- Will Deacon.

commit a469abd0f868c902b75532579bf87553dcf1b360
Author: Will Deacon <will.deacon@arm.com>
Date:   Mon Apr 8 17:13:12 2013 +0100

    ARM: elf: add new hwcap for identifying atomic ldrd/strd instructions
    
    CPUs implementing LPAE have atomic ldrd/strd instructions, meaning that
    userspace software can avoid having to use the exclusive variants of
    these instructions if they wish.
    
    This patch advertises the atomicity of these instructions via the
    hwcaps, so userspace can detect this CPU feature.
    
    Reported-by: Vladimir Danushevsky <vladimir.danushevsky@oracle.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 1522c7ae31b0..bdcd4dd13230 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -355,7 +355,7 @@ void __init early_print(const char *str, ...)
 
 static void __init cpuid_init_hwcaps(void)
 {
-	unsigned int divide_instrs;
+	unsigned int divide_instrs, vmsa;
 
 	if (cpu_architecture() < CPU_ARCH_ARMv7)
 		return;
@@ -368,6 +368,11 @@ static void __init cpuid_init_hwcaps(void)
 	case 1:
 		elf_hwcap |= HWCAP_IDIVT;
 	}
+
+	/* LPAE implies atomic ldrd/strd instructions */
+	vmsa = (read_cpuid_ext(CPUID_EXT_MMFR0) & 0xf) >> 0;
+	if (vmsa >= 5)
+		elf_hwcap |= HWCAP_LPAE;
 }
 
 static void __init feat_v6_fixup(void)
@@ -872,6 +877,7 @@ static const char *hwcap_str[] = {
 	"vfpv4",
 	"idiva",
 	"idivt",
+	"lpae",
 	NULL
 };
 

commit 78ecad0183bd7e49131da2b5aa82bee017db1cf0
Merge: f150abe1012f b382b940f821
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed May 22 10:52:32 2013 +0100

    Merge tag '3.10-rc2-psci-ops-11-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/sstabellini/xen into devel-stable
    
    Pull psci_smp_ops support from Stefano Stabellini:
    It contains the generic PSCI patch and the smp_init patch that we
    discussed so much about.  I think it would be helpful for other
    people if you could create a stable branch with these patches so
    that SoC devs can base their work on it.

commit f150abe1012f2fc7d444d33d651db32435038c11
Merge: 519fe2ecb755 6fae9cdafc92
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun May 19 01:22:53 2013 +0100

    Merge branch 'for-next' of git://git.pengutronix.de/git/ukl/linux into devel-stable
    
    Pull ARM-v7M support from Uwe Kleine-König:
    "All but the last patch were in next since next-20130418 without issues.
    The last patch fixes a problem in combination with
    
      8164f7a (ARM: 7680/1: Detect support for SDIV/UDIV from ISAR0 register)
    
    which triggers a WARN_ON without an implemented read_cpuid_ext.
    
    The branch merges fine into v3.10-rc1 and I'd be happy if you pulled it
    for 3.11-rc1. The only missing piece to be able to run a Cortex-M3 is
    the irqchip driver that will go in via Thomas Gleixner and platform
    specific stuff."

commit b382b940f821784107ca22de3455bb90e4512557
Author: Jon Medhurst <tixy@linaro.org>
Date:   Tue May 21 13:40:51 2013 +0000

    ARM: Enable selection of SMP operations at boot time
    
    Add a new 'smp_init' hook to machine_desc so platforms can specify a
    function to be used to setup smp ops instead of having a statically
    defined value.  The hook must return true when smp_ops are initialized.
    If false the static mdesc->smp_ops will be used by default.
    
    Add the definition of "bool" by including the linux/types.h file to
    asm/mach/arch.h and make it self-contained.
    
    Signed-off-by: Jon Medhurst <tixy@linaro.org>
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 8f7a6e9926a8..2b3ba15408bd 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -800,10 +800,12 @@ void __init setup_arch(char **cmdline_p)
 	psci_init();
 #ifdef CONFIG_SMP
 	if (is_smp()) {
-		if (psci_smp_available())
-			smp_set_ops(&psci_smp_ops);
-		else if (mdesc->smp)
-			smp_set_ops(mdesc->smp);
+		if (!mdesc->smp_init || !mdesc->smp_init()) {
+			if (psci_smp_available())
+				smp_set_ops(&psci_smp_ops);
+			else if (mdesc->smp)
+				smp_set_ops(mdesc->smp);
+		}
 		smp_init_cpus();
 	}
 #endif

commit 05774088391c7430f6a4c1d5d18196ef17bb3ba9
Author: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
Date:   Tue May 21 14:24:11 2013 +0000

    arm: introduce psci_smp_ops
    
    Rename virt_smp_ops to psci_smp_ops and move them to arch/arm/kernel/psci_smp.c.
    Remove mach-virt/platsmp.c, now unused.
    Compile psci_smp if CONFIG_ARM_PSCI and CONFIG_SMP.
    
    Add a cpu_die smp_op based on psci_ops.cpu_off.
    
    Initialize PSCI before setting smp_ops in setup_arch.
    
    If PSCI is available on the platform, prefer psci_smp_ops over the
    platform smp_ops.
    
    
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    CC: arnd@arndb.de
    CC: marc.zyngier@arm.com
    CC: linux@arm.linux.org.uk
    CC: nico@linaro.org
    CC: rob.herring@calxeda.com

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 1522c7ae31b0..8f7a6e9926a8 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -37,6 +37,7 @@
 #include <asm/cputype.h>
 #include <asm/elf.h>
 #include <asm/procinfo.h>
+#include <asm/psci.h>
 #include <asm/sections.h>
 #include <asm/setup.h>
 #include <asm/smp_plat.h>
@@ -796,9 +797,13 @@ void __init setup_arch(char **cmdline_p)
 	unflatten_device_tree();
 
 	arm_dt_init_cpu_maps();
+	psci_init();
 #ifdef CONFIG_SMP
 	if (is_smp()) {
-		smp_set_ops(mdesc->smp);
+		if (psci_smp_available())
+			smp_set_ops(&psci_smp_ops);
+		else if (mdesc->smp)
+			smp_set_ops(mdesc->smp);
 		smp_init_cpus();
 	}
 #endif

commit 9394c1c65e61eb6f4c1c99f342b49e451ec337b6
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Mon Mar 11 13:52:12 2013 +0100

    ARM: 7669/1: keep __my_cpu_offset consistent with generic one
    
    Commit 14318efb(ARM: 7587/1: implement optimized percpu variable access)
    introduces arm's __my_cpu_offset to optimize percpu vaiable access,
    which really works well on hackbench, but will cause __my_cpu_offset
    to return garbage value before it is initialized in cpu_init() called
    by setup_arch, so accessing percpu variable before setup_arch may cause
    kernel hang. But generic __my_cpu_offset always returns zero before
    percpu area is brought up, and won't hang kernel.
    
    So the patch tries to clear __my_cpu_offset on boot CPU early
    to avoid boot hang.
    
    At least now percpu variable is accessed by lockdep before
    setup_arch(), and enabling CONFIG_LOCK_STAT or CONFIG_DEBUG_LOCKDEP
    can trigger kernel hang.
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 1522c7ae31b0..dd1c6aacbaf9 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -456,6 +456,13 @@ void __init smp_setup_processor_id(void)
 	for (i = 1; i < nr_cpu_ids; ++i)
 		cpu_logical_map(i) = i == cpu ? 0 : i;
 
+	/*
+	 * clear __my_cpu_offset on boot CPU to avoid hang caused by
+	 * using percpu variable early, for example, lockdep will
+	 * access percpu variable inside lock_release
+	 */
+	set_my_cpu_offset(0);
+
 	printk(KERN_INFO "Booting Linux on physical CPU 0x%x\n", mpidr);
 }
 

commit 5497e7b8967118ee45f8ef2d301fce919a35d660
Merge: 8cbc95ee7487 eb16d3327353
Author: Olof Johansson <olof@lixom.net>
Date:   Thu May 9 13:05:00 2013 -0700

    Merge branch 'late/fixes' into fixes
    
    * late/fixes:
      ARM: OMAP2+: Fix unmet direct dependencies for SERIAL_OMAP
      ARM: ux500: always select ABX500_CORE
      ARM: SIRF: select SMP_ON_UP only on SMP builds
      ARM: SPEAr: conditionalize l2x0 support
      ARM: imx: build CPU suspend code only when needed
      ARM: OMAP: build SMP code only for OMAP4/5
      ARM: tegra: Tegra114 needs CPU_FREQ_TABLE
      ARM: default machine descriptor for multiplatform
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 946342d03ec4e8367bba7bb99e7155e97f69058a
Merge: 70100a022684 f8f02ec25ce3 1783d4574619 848a7b13aef0 6aaa189f8712 5e45a0a1975d
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu May 2 21:30:36 2013 +0100

    Merge branches 'devel-stable', 'entry', 'fixes', 'mach-types', 'misc' and 'smp-hotplug' into for-linus

commit 883a106b0866ca8d75b5520bdb3ca1cf8e3730ba
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Jan 31 17:51:18 2013 +0000

    ARM: default machine descriptor for multiplatform
    
    Since we now have default implementations for init_time and init_irq,
    the init_machine callback is the only one that is not yet optional,
    but since simple DT based platforms all have the same
    of_platform_populate function call in there, we can consolidate them
    as well, and then actually boot with a completely empty machine_desc.
    Unofortunately we cannot just default to an empty init_machine: We
    cannot call of_platform_populate before init_machine because that
    does not work in case of auxdata, and we cannot call it after
    init_machine either because the machine might need to run code
    after adding the devices.
    
    To take the final step, this adds support for booting without defining
    any machine_desc whatsoever.
    
    For the case that CONFIG_MULTIPLATFORM is enabled, it adds a
    global machine descriptor that never matches any machine but is
    used as a fallback if nothing else matches. We assume that without
    CONFIG_MULTIPLATFORM, we only want to boot on the systems that the kernel
    is built for, so we still retain the build-time warning for missing
    machine descriptors and the run-time warning when the platform does not
    match in that case.
    
    In the case that we run on a multiplatform kernel and the machine
    provides a fully populated device tree, we attempt to keep booting,
    hoping that no machine specific callbacks are necessary.
    
    Finally, this also removes the misguided "select ARCH_VEXPRESS" that
    was only added to avoid a build error for allnoconfig kernels.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Olof Johansson <olof@lixom.net>
    Cc: "Russell King - ARM Linux" <linux@arm.linux.org.uk>
    Cc: Rob Herring <robherring2@gmail.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 3f6cbb2e3eda..08a627b61b7d 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -18,6 +18,7 @@
 #include <linux/bootmem.h>
 #include <linux/seq_file.h>
 #include <linux/screen_info.h>
+#include <linux/of_platform.h>
 #include <linux/init.h>
 #include <linux/kexec.h>
 #include <linux/of_fdt.h>
@@ -640,9 +641,19 @@ struct screen_info screen_info = {
 
 static int __init customize_machine(void)
 {
-	/* customizes platform devices, or adds new ones */
+	/*
+	 * customizes platform devices, or adds new ones
+	 * On DT based machines, we fall back to populating the
+	 * machine from the device tree, if no callback is provided,
+	 * otherwise we would always need an init_machine callback.
+	 */
 	if (machine_desc->init_machine)
 		machine_desc->init_machine();
+#ifdef CONFIG_OF
+	else
+		of_platform_populate(NULL, of_default_bus_match_table,
+					NULL, NULL);
+#endif
 	return 0;
 }
 arch_initcall(customize_machine);

commit 1783d4574619aea9ff5d94e6506f288547fc6737
Author: Jon Medhurst <tixy@linaro.org>
Date:   Thu Apr 25 14:40:22 2013 +0100

    ARM: 7700/2: Make cpu_init() notrace
    
    On resume from CPU power down any trace hooks enabled in cpu_init()
    will get called before that function has done set_my_cpu_offset(),
    so any use of per-cpu variables by trace hook code will cause bad
    things to happen. Prevent this by marking the function notrace.
    
    This fixes lockups/crashes seen when enabling function tracer on TC2
    with the not yet mainlined cpuidle driver.
    
    Signed-off-by: Jon Medhurst <tixy@linaro.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 234e339196c0..63ae04bdda1b 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -389,7 +389,7 @@ static void __init feat_v6_fixup(void)
  *
  * cpu_init sets up the per-CPU stacks.
  */
-void cpu_init(void)
+void notrace cpu_init(void)
 {
 	unsigned int cpu = smp_processor_id();
 	struct stack *stk = &stacks[cpu];

commit 55bdd694116597d2f16510b121463cd579ba78da
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Fri May 21 18:06:41 2010 +0100

    ARM: Add base support for ARMv7-M
    
    This patch adds the base support for the ARMv7-M
    architecture. It consists of the corresponding arch/arm/mm/ files and
    various #ifdef's around the kernel. Exception handling is implemented by
    a subsequent patch.
    
    [ukleinek: squash in some changes originating from commit
    
    b5717ba (Cortex-M3: Add support for the Microcontroller Prototyping System)
    
    from the v2.6.33-arm1 patch stack, port to post 3.6, drop zImage
    support, drop reorganisation of pt_regs, assert CONFIG_CPU_V7M doesn't
    leak into installed headers and a few cosmetic changes]
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Jonathan Austin <jonathan.austin@arm.com>
    Tested-by: Jonathan Austin <jonathan.austin@arm.com>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 1cc9e1796415..829124590e4c 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -128,7 +128,9 @@ struct stack {
 	u32 und[3];
 } ____cacheline_aligned;
 
+#ifndef CONFIG_CPU_V7M
 static struct stack stacks[NR_CPUS];
+#endif
 
 char elf_platform[ELF_PLATFORM_SIZE];
 EXPORT_SYMBOL(elf_platform);
@@ -207,7 +209,7 @@ static const char *proc_arch[] = {
 	"5TEJ",
 	"6TEJ",
 	"7",
-	"?(11)",
+	"7M",
 	"?(12)",
 	"?(13)",
 	"?(14)",
@@ -216,6 +218,12 @@ static const char *proc_arch[] = {
 	"?(17)",
 };
 
+#ifdef CONFIG_CPU_V7M
+static int __get_cpu_architecture(void)
+{
+	return CPU_ARCH_ARMv7M;
+}
+#else
 static int __get_cpu_architecture(void)
 {
 	int cpu_arch;
@@ -248,6 +256,7 @@ static int __get_cpu_architecture(void)
 
 	return cpu_arch;
 }
+#endif
 
 int __pure cpu_architecture(void)
 {
@@ -293,7 +302,9 @@ static void __init cacheid_init(void)
 {
 	unsigned int arch = cpu_architecture();
 
-	if (arch >= CPU_ARCH_ARMv6) {
+	if (arch == CPU_ARCH_ARMv7M) {
+		cacheid = 0;
+	} else if (arch >= CPU_ARCH_ARMv6) {
 		unsigned int cachetype = read_cpuid_cachetype();
 		if ((cachetype & (7 << 29)) == 4 << 29) {
 			/* ARMv7 register format */
@@ -375,6 +386,7 @@ static void __init feat_v6_fixup(void)
  */
 void cpu_init(void)
 {
+#ifndef CONFIG_CPU_V7M
 	unsigned int cpu = smp_processor_id();
 	struct stack *stk = &stacks[cpu];
 
@@ -425,6 +437,7 @@ void cpu_init(void)
 	      "I" (offsetof(struct stack, und[0])),
 	      PLC (PSR_F_BIT | PSR_I_BIT | SVC_MODE)
 	    : "r14");
+#endif
 }
 
 int __cpu_logical_map[NR_CPUS];

commit de40614e92bf1b0308d953387b0cb9d3a5710186
Author: Joonsoo Kim <iamjoonsoo.kim@lge.com>
Date:   Fri Apr 5 03:16:51 2013 +0100

    ARM: 7694/1: ARM, TCM: initialize TCM in paging_init(), instead of setup_arch()
    
    tcm_init() call iotable_init() and it use early_alloc variants which
    do memblock allocation. Directly using memblock allocation after
    initializing bootmem should not permitted, because bootmem can't know
    where are additinally reserved.
    So move tcm_init() to a safe place before initalizing bootmem.
    
    (On the U300)
    
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index d343a6c3a6d1..234e339196c0 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -56,7 +56,6 @@
 #include <asm/virt.h>
 
 #include "atags.h"
-#include "tcm.h"
 
 
 #if defined(CONFIG_FPE_NWFPE) || defined(CONFIG_FPE_FASTFPE)
@@ -798,8 +797,6 @@ void __init setup_arch(char **cmdline_p)
 
 	reserve_crashkernel();
 
-	tcm_init();
-
 #ifdef CONFIG_MULTI_IRQ_HANDLER
 	handle_arch_irq = mdesc->handle_irq;
 #endif

commit 4e1db26a0b42e2b6e27c05d68adcc01709c2eed2
Author: Paul Bolle <pebolle@tiscali.nl>
Date:   Wed Apr 3 12:24:45 2013 +0100

    ARM: 7690/1: mm: fix CONFIG_LPAE typos
    
    CONFIG_LPAE doesn't exist: the correct option is CONFIG_ARM_LPAE, so fix
    up the two typos under arch/arm/.
    
    The fix to head.S is slightly scary, but this is just for setting up
    an early io-mapping for the serial port when running on a big-endian,
    LPAE system. Since these systems don't exist in the wild (at least, I
    have no access to one outside of kvmtool, which doesn't provide a serial
    port suitable for earlyprintk), then we can revisit the code later if it
    causes any problems.
    
    Signed-off-by: Paul Bolle <pebolle@tiscali.nl>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index f3ac13f69b7a..d343a6c3a6d1 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -544,7 +544,7 @@ int __init arm_add_memory(phys_addr_t start, phys_addr_t size)
 	size -= start & ~PAGE_MASK;
 	bank->start = PAGE_ALIGN(start);
 
-#ifndef CONFIG_LPAE
+#ifndef CONFIG_ARM_LPAE
 	if (bank->start + size < bank->start) {
 		printk(KERN_CRIT "Truncating memory at 0x%08llx to fit in "
 			"32-bit physical address space\n", (long long)start);

commit 8164f7af88d9ad3a757bd14f634b23997ee77f6b
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Mar 18 19:44:15 2013 +0100

    ARM: 7680/1: Detect support for SDIV/UDIV from ISAR0 register
    
    The ISAR0 register indicates support for the SDIV and UDIV
    instructions in both the Thumb and ARM instruction set. Read the
    register to detect the supported instructions and update the
    elf_hwcap mask as appropriate. This is better than adding more
    and more cpuid checks in proc-v7.S for each new cpu variant that
    supports these instructions.
    
    Acked-by: Will Deacon <will.deacon@arm.com>
    Cc: Stepan Moskovchenko <stepanm@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index e2c8bbffb0b1..f3ac13f69b7a 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -353,6 +353,23 @@ void __init early_print(const char *str, ...)
 	printk("%s", buf);
 }
 
+static void __init cpuid_init_hwcaps(void)
+{
+	unsigned int divide_instrs;
+
+	if (cpu_architecture() < CPU_ARCH_ARMv7)
+		return;
+
+	divide_instrs = (read_cpuid_ext(CPUID_EXT_ISAR0) & 0x0f000000) >> 24;
+
+	switch (divide_instrs) {
+	case 2:
+		elf_hwcap |= HWCAP_IDIVA;
+	case 1:
+		elf_hwcap |= HWCAP_IDIVT;
+	}
+}
+
 static void __init feat_v6_fixup(void)
 {
 	int id = read_cpuid_id();
@@ -483,6 +500,9 @@ static void __init setup_processor(void)
 	snprintf(elf_platform, ELF_PLATFORM_SIZE, "%s%c",
 		 list->elf_name, ENDIANNESS);
 	elf_hwcap = list->elf_hwcap;
+
+	cpuid_init_hwcaps();
+
 #ifndef CONFIG_ARM_THUMB
 	elf_hwcap &= ~(HWCAP_THUMB | HWCAP_IDIVT);
 #endif

commit c40e3641670eb6ebfdb71d4b0c775416ef95f4f0
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Mar 18 19:44:14 2013 +0100

    ARM: 7679/1: Clear IDIVT hwcap if CONFIG_ARM_THUMB=n
    
    Don't advertise support for the SDIV/UDIV thumb instructions if
    the kernel is not compiled with support for thumb userspace. This
    is in line with how we remove the THUMB hwcap in these
    configurations.
    
    Acked-by: Will Deacon <will.deacon@arm.com>
    Cc: Stepan Moskovchenko <stepanm@codeaurora.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 3f6cbb2e3eda..e2c8bbffb0b1 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -484,7 +484,7 @@ static void __init setup_processor(void)
 		 list->elf_name, ENDIANNESS);
 	elf_hwcap = list->elf_hwcap;
 #ifndef CONFIG_ARM_THUMB
-	elf_hwcap &= ~HWCAP_THUMB;
+	elf_hwcap &= ~(HWCAP_THUMB | HWCAP_IDIVT);
 #endif
 
 	feat_v6_fixup();

commit ac52e83f4c76992925e13d0f4e901ffd4c207261
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Jan 30 17:38:21 2013 +0100

    ARM: use read_cpuid_id() instead of read_cpuid(CPUID_ID)
    
    Both calls are identical currently. This patch prepares to deprecate
    read_cpuid on machines without cp15.
    
    Also move an unconditional usage of read_cpuid_cachetype to a more local
    scope as read_cpuid_cachetype uses read_cpuid, too.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Message-Id: 1359646587-1788-1-git-send-email-u.kleine-koenig@pengutronix.de

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 3f6cbb2e3eda..1cc9e1796415 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -291,10 +291,10 @@ static int cpu_has_aliasing_icache(unsigned int arch)
 
 static void __init cacheid_init(void)
 {
-	unsigned int cachetype = read_cpuid_cachetype();
 	unsigned int arch = cpu_architecture();
 
 	if (arch >= CPU_ARCH_ARMv6) {
+		unsigned int cachetype = read_cpuid_cachetype();
 		if ((cachetype & (7 << 29)) == 4 << 29) {
 			/* ARMv7 register format */
 			arch = CPU_ARCH_ARMv7;

commit b8b499c86be58cb309964fcab5b62ac4a240a878
Author: Alexander Shiyan <shc_work@mail.ru>
Date:   Wed Dec 12 08:32:11 2012 +0100

    ARM: 7602/1: Pass real "__machine_arch_type" variable to setup_machine_tags() procedure
    
    This modification is needed to proper boot the custom machines with
    the IDs that are not described in the mach-types.h table.
    
    Signed-off-by: Alexander Shiyan <shc_work@mail.ru>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 9a89bf4aefe1..3f6cbb2e3eda 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -733,7 +733,7 @@ void __init setup_arch(char **cmdline_p)
 	setup_processor();
 	mdesc = setup_machine_fdt(__atags_pointer);
 	if (!mdesc)
-		mdesc = setup_machine_tags(__atags_pointer, machine_arch_type);
+		mdesc = setup_machine_tags(__atags_pointer, __machine_arch_type);
 	machine_desc = mdesc;
 	machine_name = mdesc->name;
 

commit 14318efb322e2fe1a034c69463d725209eb9d548
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Thu Nov 29 20:39:54 2012 +0100

    ARM: 7587/1: implement optimized percpu variable access
    
    Use the previously unused TPIDRPRW register to store percpu offsets.
    TPIDRPRW is only accessible in PL1, so it can only be used in the kernel.
    
    This replaces 2 loads with a mrc instruction for each percpu variable
    access. With hackbench, the performance improvement is 1.4% on Cortex-A9
    (highbank). Taking an average of 30 runs of "hackbench -l 1000" yields:
    
    Before: 6.2191
    After: 6.1348
    
    Will Deacon reported similar delta on v6 with 11MPCore.
    
    The asm "memory clobber" are needed here to ensure the percpu offset
    gets reloaded. Testing by Will found that this would not happen in
    __schedule() which is a bit of a special case as preemption is disabled
    but the execution can move cores.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index f739fb1d217a..9a89bf4aefe1 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -383,6 +383,12 @@ void cpu_init(void)
 		BUG();
 	}
 
+	/*
+	 * This only works on resume and secondary cores. For booting on the
+	 * boot cpu, smp_prepare_boot_cpu is called after percpu area setup.
+	 */
+	set_my_cpu_offset(per_cpu_offset(cpu));
+
 	cpu_proc_init();
 
 	/*

commit 82b5df7bf27ca6cf642499bc3bcae1c93b9ac4ba
Merge: e38eb34aab13 b4b8f770eb10
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Nov 20 20:19:38 2012 +0000

    Merge branch 'bl-cpuinfo' of git://linux-arm.org/linux-2.6-lp into devel-stable

commit 5587164eea4aad88fcb79d9b21dc8f14fea598cd
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Dec 14 16:01:24 2011 +0000

    ARM: kernel: add cpu logical map DT init in setup_arch
    
    As soon as the device tree is unflattened the cpu logical to physical
    mapping is carried out in setup_arch to build a proper array of MPIDR and
    corresponding logical indexes.
    
    The mapping could have been carried out using the flattened DT blob and
    related primitives, but since the mapping is not needed by early boot
    code it can safely be executed when the device tree has been uncompressed to
    its tree data structure.
    
    This patch adds the arm_dt_init_cpu maps() function call in setup_arch().
    
    If the kernel is not compiled with DT support the function is empty and
    no logical mapping takes place through it; the mapping carried out in
    smp_setup_processor_id() is left unchanged.
    If DT is supported the mapping created in smp_setup_processor_id() is overriden.
    The DT mapping also sets the possible cpus mask, hence platform
    code need not set it again in the respective smp_init_cpus() functions.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 4515bf6abee0..d15f1c503f3d 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -759,6 +759,7 @@ void __init setup_arch(char **cmdline_p)
 
 	unflatten_device_tree();
 
+	arm_dt_init_cpu_maps();
 #ifdef CONFIG_SMP
 	if (is_smp()) {
 		smp_set_ops(mdesc->smp);

commit cb8cf4f821044f140ea5b9c8d4f816f0c05fab44
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Thu Nov 8 18:05:56 2012 +0000

    ARM: kernel: smp_setup_processor_id() updates
    
    This patch applies some basic changes to the smp_setup_processor_id()
    ARM implementation to make the code that builds cpu_logical_map more
    uniform across the kernel.
    
    The function now prints the full extent of the boot CPU MPIDR[23:0] and
    initializes the cpu_logical_map for CPUs up to nr_cpu_ids.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index da1d1aa20ad9..4515bf6abee0 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -426,13 +426,14 @@ int __cpu_logical_map[NR_CPUS];
 void __init smp_setup_processor_id(void)
 {
 	int i;
-	u32 cpu = is_smp() ? read_cpuid_mpidr() & 0xff : 0;
+	u32 mpidr = is_smp() ? read_cpuid_mpidr() & MPIDR_HWID_BITMASK : 0;
+	u32 cpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);
 
 	cpu_logical_map(0) = cpu;
-	for (i = 1; i < NR_CPUS; ++i)
+	for (i = 1; i < nr_cpu_ids; ++i)
 		cpu_logical_map(i) = i == cpu ? 0 : i;
 
-	printk(KERN_INFO "Booting Linux on physical CPU %d\n", cpu);
+	printk(KERN_INFO "Booting Linux on physical CPU 0x%x\n", mpidr);
 }
 
 static void __init setup_processor(void)

commit b4b8f770eb10a1bccaf8aa0ec1956e2dd7ed1e0a
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Sep 10 18:55:21 2012 +0100

    ARM: kernel: update cpuinfo to print all online CPUs features
    
    Currently, reading /proc/cpuinfo provides userspace with CPU ID of
    the CPU carrying out the read from the file. This is fine as long as all
    CPUs in the system are the same. With the advent of big.LITTLE and
    heterogenous ARM systems this approach provides user space with incorrect
    bits of information since CPU ids in the system might differ from the one
    provided by the CPU reading the file.
    
    This patch updates the cpuinfo show function so that a read from
    /proc/cpuinfo prints HW information for all online CPUs at once, mirroring
     x86 behaviour.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index da1d1aa20ad9..a15848f8b0ff 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -841,12 +841,9 @@ static const char *hwcap_str[] = {
 
 static int c_show(struct seq_file *m, void *v)
 {
-	int i;
-
-	seq_printf(m, "Processor\t: %s rev %d (%s)\n",
-		   cpu_name, read_cpuid_id() & 15, elf_platform);
+	int i, j;
+	u32 cpuid;
 
-#if defined(CONFIG_SMP)
 	for_each_online_cpu(i) {
 		/*
 		 * glibc reads /proc/cpuinfo to determine the number of
@@ -854,45 +851,48 @@ static int c_show(struct seq_file *m, void *v)
 		 * "processor".  Give glibc what it expects.
 		 */
 		seq_printf(m, "processor\t: %d\n", i);
-		seq_printf(m, "BogoMIPS\t: %lu.%02lu\n\n",
+		cpuid = is_smp() ? per_cpu(cpu_data, i).cpuid : read_cpuid_id();
+		seq_printf(m, "model name\t: %s rev %d (%s)\n",
+			   cpu_name, cpuid & 15, elf_platform);
+
+#if defined(CONFIG_SMP)
+		seq_printf(m, "BogoMIPS\t: %lu.%02lu\n",
 			   per_cpu(cpu_data, i).loops_per_jiffy / (500000UL/HZ),
 			   (per_cpu(cpu_data, i).loops_per_jiffy / (5000UL/HZ)) % 100);
-	}
-#else /* CONFIG_SMP */
-	seq_printf(m, "BogoMIPS\t: %lu.%02lu\n",
-		   loops_per_jiffy / (500000/HZ),
-		   (loops_per_jiffy / (5000/HZ)) % 100);
+#else
+		seq_printf(m, "BogoMIPS\t: %lu.%02lu\n",
+			   loops_per_jiffy / (500000/HZ),
+			   (loops_per_jiffy / (5000/HZ)) % 100);
 #endif
+		/* dump out the processor features */
+		seq_puts(m, "Features\t: ");
 
-	/* dump out the processor features */
-	seq_puts(m, "Features\t: ");
-
-	for (i = 0; hwcap_str[i]; i++)
-		if (elf_hwcap & (1 << i))
-			seq_printf(m, "%s ", hwcap_str[i]);
+		for (j = 0; hwcap_str[j]; j++)
+			if (elf_hwcap & (1 << j))
+				seq_printf(m, "%s ", hwcap_str[j]);
 
-	seq_printf(m, "\nCPU implementer\t: 0x%02x\n", read_cpuid_id() >> 24);
-	seq_printf(m, "CPU architecture: %s\n", proc_arch[cpu_architecture()]);
+		seq_printf(m, "\nCPU implementer\t: 0x%02x\n", cpuid >> 24);
+		seq_printf(m, "CPU architecture: %s\n",
+			   proc_arch[cpu_architecture()]);
 
-	if ((read_cpuid_id() & 0x0008f000) == 0x00000000) {
-		/* pre-ARM7 */
-		seq_printf(m, "CPU part\t: %07x\n", read_cpuid_id() >> 4);
-	} else {
-		if ((read_cpuid_id() & 0x0008f000) == 0x00007000) {
-			/* ARM7 */
-			seq_printf(m, "CPU variant\t: 0x%02x\n",
-				   (read_cpuid_id() >> 16) & 127);
+		if ((cpuid & 0x0008f000) == 0x00000000) {
+			/* pre-ARM7 */
+			seq_printf(m, "CPU part\t: %07x\n", cpuid >> 4);
 		} else {
-			/* post-ARM7 */
-			seq_printf(m, "CPU variant\t: 0x%x\n",
-				   (read_cpuid_id() >> 20) & 15);
+			if ((cpuid & 0x0008f000) == 0x00007000) {
+				/* ARM7 */
+				seq_printf(m, "CPU variant\t: 0x%02x\n",
+					   (cpuid >> 16) & 127);
+			} else {
+				/* post-ARM7 */
+				seq_printf(m, "CPU variant\t: 0x%x\n",
+					   (cpuid >> 20) & 15);
+			}
+			seq_printf(m, "CPU part\t: 0x%03x\n",
+				   (cpuid >> 4) & 0xfff);
 		}
-		seq_printf(m, "CPU part\t: 0x%03x\n",
-			   (read_cpuid_id() >> 4) & 0xfff);
+		seq_printf(m, "CPU revision\t: %d\n\n", cpuid & 15);
 	}
-	seq_printf(m, "CPU revision\t: %d\n", read_cpuid_id() & 15);
-
-	seq_puts(m, "\n");
 
 	seq_printf(m, "Hardware\t: %s\n", machine_name);
 	seq_printf(m, "Revision\t: %04x\n", system_rev);

commit a0f0dd57f4a85310d9936f1770a0424b49fef876
Merge: 2a552d5e63d7 846a136881b8
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Oct 11 10:55:04 2012 +0100

    Merge branch 'fixes' into for-linus
    
    Conflicts:
            arch/arm/kernel/smp.c

commit 0e51793e162ca432fc5f04178cf82b80a92c2659
Merge: 5cad3598ea0c b4874a3d2986
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Oct 7 21:20:57 2012 +0900

    Merge branch 'for-linus' of git://git.linaro.org/people/rmk/linux-arm
    
    Pull ARM updates from Russell King:
     "This is the first chunk of ARM updates for this merge window.
      Conflicts are expected in two files - asm/timex.h and
      mach-integrator/integrator_cp.c.  Nothing particularly stands out more
      than anything else.
    
      Most of the growth is down to the opcodes stuff from Dave Martin,
      which is countered by Rob's patches to use more of the asm-generic
      headers on ARM."
    
    (A few more conflicts grew since then, but it all looked fairly trivial)
    
    * 'for-linus' of git://git.linaro.org/people/rmk/linux-arm: (44 commits)
      ARM: 7548/1: include linux/sched.h in syscall.h
      ARM: 7541/1: Add ARM ERRATA 775420 workaround
      ARM: ensure vm_struct has its phys_addr member filled in
      ARM: 7540/1: kexec: Check segment memory addresses
      ARM: 7539/1: kexec: scan for dtb magic in segments
      ARM: 7538/1: delay: add registration mechanism for delay timer sources
      ARM: 7536/1: smp: Formalize an IPI for wakeup
      ARM: 7525/1: ptrace: use updated syscall number for syscall auditing
      ARM: 7524/1: support syscall tracing
      ARM: 7519/1: integrator: convert platform devices to Device Tree
      ARM: 7518/1: integrator: convert AMBA devices to device tree
      ARM: 7517/1: integrator: initial device tree support
      ARM: 7516/1: plat-versatile: add DT support to FPGA IRQ
      ARM: 7515/1: integrator: check PL010 base address from resource
      ARM: 7514/1: integrator: call common init function from machine
      ARM: 7522/1: arch_timers: register a time/cycle counter
      ARM: 7523/1: arch_timers: enable the use of the virtual timer
      ARM: 7531/1: mark kernelmode mem{cpy,set} non-experimental
      ARM: 7520/1: Build dtb files in all target
      ARM: Fix build warning in arch/arm/mm/alignment.c
      ...

commit 4588c34daabb5aebee9cbe90f0ca6ab11412f207
Author: Dave Martin <dave.martin@linaro.org>
Date:   Fri Feb 17 16:54:28 2012 +0000

    ARM: virt: Add boot-time diagnostics
    
    In order to easily detect pathological cases, print some diagnostics
    when the kernel boots.
    
    This also provides helpers to detect that HYP mode is actually available,
    which can be used by other subsystems to enable HYP specific features.
    
    Signed-off-by: Dave Martin <dave.martin@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index a81dcecc7343..04fd01feea86 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -55,6 +55,7 @@
 #include <asm/traps.h>
 #include <asm/unwind.h>
 #include <asm/memblock.h>
+#include <asm/virt.h>
 
 #if defined(CONFIG_DEPRECATED_PARAM_STRUCT)
 #include "compat.h"
@@ -937,6 +938,21 @@ static int __init meminfo_cmp(const void *_a, const void *_b)
 	return cmp < 0 ? -1 : cmp > 0 ? 1 : 0;
 }
 
+void __init hyp_mode_check(void)
+{
+#ifdef CONFIG_ARM_VIRT_EXT
+	if (is_hyp_mode_available()) {
+		pr_info("CPU: All CPU(s) started in HYP mode.\n");
+		pr_info("CPU: Virtualization extensions available.\n");
+	} else if (is_hyp_mode_mismatched()) {
+		pr_warn("CPU: WARNING: CPU(s) started in wrong/inconsistent modes (primary CPU mode 0x%x)\n",
+			__boot_cpu_mode & MODE_MASK);
+		pr_warn("CPU: This may indicate a broken bootloader or firmware.\n");
+	} else
+		pr_info("CPU: All CPU(s) started in SVC mode.\n");
+#endif
+}
+
 void __init setup_arch(char **cmdline_p)
 {
 	struct machine_desc *mdesc;
@@ -980,6 +996,10 @@ void __init setup_arch(char **cmdline_p)
 	if (is_smp())
 		smp_init_cpus();
 #endif
+
+	if (!is_smp())
+		hyp_mode_check();
+
 	reserve_crashkernel();
 
 	tcm_init();

commit abcee5fb0dfbb248d883a2f6bdb4820abe3ac524
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Thu Sep 8 09:06:10 2011 +0100

    ARM: SoC: add per-platform SMP operations
    
    This adds a 'struct smp_operations' to abstract the CPU initialization
    and hot plugging functions on SMP systems, which otherwise conflict
    in a multiplatform kernel. This also helps shmobile and potentially
    others that have more than one method to do these.
    
    To allow the kernel to continue building, the platform hooks are
    defined as weak symbols which are overrided by the platform code.
    Once all platforms are converted, the "weak" attribute will be
    removed and the function made static.
    
    Unlike the original version from Marc, this new version from Arnd
    does not use a generalized abstraction for per-soc data structures
    but only tries to solve the problem for the SMP operations. This
    way, we can collapse the previous four data structures into a
    single struct, which is less systematic but also easier to follow
    as a causal reader.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Nicolas Pitre <nico@fluxnic.net>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index a81dcecc7343..725f9f2a9541 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -977,8 +977,10 @@ void __init setup_arch(char **cmdline_p)
 	unflatten_device_tree();
 
 #ifdef CONFIG_SMP
-	if (is_smp())
+	if (is_smp()) {
+		smp_set_ops(mdesc->smp);
 		smp_init_cpus();
+	}
 #endif
 	reserve_crashkernel();
 

commit aa783b6fd60b3844e199b1c2d2f4068f3caa1358
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Sat Sep 1 03:00:15 2012 +0100

    ARM: 7505/1: split out ATAGS parsing
    
    Make ATAGS parsing into a source file of its own, namely atags_parse.c.
    Also rename compat.c to atags_compat.c to make it clearer what it is
    about.  Same for atags.c which is now atags_proc.c. Gather all the atags
    function declarations into a common atags.h.
    
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index a81dcecc7343..0785472460a8 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -21,11 +21,9 @@
 #include <linux/init.h>
 #include <linux/kexec.h>
 #include <linux/of_fdt.h>
-#include <linux/root_dev.h>
 #include <linux/cpu.h>
 #include <linux/interrupt.h>
 #include <linux/smp.h>
-#include <linux/fs.h>
 #include <linux/proc_fs.h>
 #include <linux/memblock.h>
 #include <linux/bug.h>
@@ -56,15 +54,9 @@
 #include <asm/unwind.h>
 #include <asm/memblock.h>
 
-#if defined(CONFIG_DEPRECATED_PARAM_STRUCT)
-#include "compat.h"
-#endif
 #include "atags.h"
 #include "tcm.h"
 
-#ifndef MEM_SIZE
-#define MEM_SIZE	(16*1024*1024)
-#endif
 
 #if defined(CONFIG_FPE_NWFPE) || defined(CONFIG_FPE_FASTFPE)
 char fpe_type[8];
@@ -145,7 +137,6 @@ static const char *machine_name;
 static char __initdata cmd_line[COMMAND_LINE_SIZE];
 struct machine_desc *machine_desc __initdata;
 
-static char default_command_line[COMMAND_LINE_SIZE] __initdata = CONFIG_CMDLINE;
 static union { char c[4]; unsigned long l; } endian_test __initdata = { { 'l', '?', '?', 'b' } };
 #define ENDIANNESS ((char)endian_test.l)
 
@@ -583,21 +574,6 @@ static int __init early_mem(char *p)
 }
 early_param("mem", early_mem);
 
-static void __init
-setup_ramdisk(int doload, int prompt, int image_start, unsigned int rd_sz)
-{
-#ifdef CONFIG_BLK_DEV_RAM
-	extern int rd_size, rd_image_start, rd_prompt, rd_doload;
-
-	rd_image_start = image_start;
-	rd_prompt = prompt;
-	rd_doload = doload;
-
-	if (rd_sz)
-		rd_size = rd_sz;
-#endif
-}
-
 static void __init request_standard_resources(struct machine_desc *mdesc)
 {
 	struct memblock_region *region;
@@ -643,35 +619,6 @@ static void __init request_standard_resources(struct machine_desc *mdesc)
 		request_resource(&ioport_resource, &lp2);
 }
 
-/*
- *  Tag parsing.
- *
- * This is the new way of passing data to the kernel at boot time.  Rather
- * than passing a fixed inflexible structure to the kernel, we pass a list
- * of variable-sized tags to the kernel.  The first tag must be a ATAG_CORE
- * tag for the list to be recognised (to distinguish the tagged list from
- * a param_struct).  The list is terminated with a zero-length tag (this tag
- * is not parsed in any way).
- */
-static int __init parse_tag_core(const struct tag *tag)
-{
-	if (tag->hdr.size > 2) {
-		if ((tag->u.core.flags & 1) == 0)
-			root_mountflags &= ~MS_RDONLY;
-		ROOT_DEV = old_decode_dev(tag->u.core.rootdev);
-	}
-	return 0;
-}
-
-__tagtable(ATAG_CORE, parse_tag_core);
-
-static int __init parse_tag_mem32(const struct tag *tag)
-{
-	return arm_add_memory(tag->u.mem.start, tag->u.mem.size);
-}
-
-__tagtable(ATAG_MEM, parse_tag_mem32);
-
 #if defined(CONFIG_VGA_CONSOLE) || defined(CONFIG_DUMMY_CONSOLE)
 struct screen_info screen_info = {
  .orig_video_lines	= 30,
@@ -681,117 +628,8 @@ struct screen_info screen_info = {
  .orig_video_isVGA	= 1,
  .orig_video_points	= 8
 };
-
-static int __init parse_tag_videotext(const struct tag *tag)
-{
-	screen_info.orig_x            = tag->u.videotext.x;
-	screen_info.orig_y            = tag->u.videotext.y;
-	screen_info.orig_video_page   = tag->u.videotext.video_page;
-	screen_info.orig_video_mode   = tag->u.videotext.video_mode;
-	screen_info.orig_video_cols   = tag->u.videotext.video_cols;
-	screen_info.orig_video_ega_bx = tag->u.videotext.video_ega_bx;
-	screen_info.orig_video_lines  = tag->u.videotext.video_lines;
-	screen_info.orig_video_isVGA  = tag->u.videotext.video_isvga;
-	screen_info.orig_video_points = tag->u.videotext.video_points;
-	return 0;
-}
-
-__tagtable(ATAG_VIDEOTEXT, parse_tag_videotext);
 #endif
 
-static int __init parse_tag_ramdisk(const struct tag *tag)
-{
-	setup_ramdisk((tag->u.ramdisk.flags & 1) == 0,
-		      (tag->u.ramdisk.flags & 2) == 0,
-		      tag->u.ramdisk.start, tag->u.ramdisk.size);
-	return 0;
-}
-
-__tagtable(ATAG_RAMDISK, parse_tag_ramdisk);
-
-static int __init parse_tag_serialnr(const struct tag *tag)
-{
-	system_serial_low = tag->u.serialnr.low;
-	system_serial_high = tag->u.serialnr.high;
-	return 0;
-}
-
-__tagtable(ATAG_SERIAL, parse_tag_serialnr);
-
-static int __init parse_tag_revision(const struct tag *tag)
-{
-	system_rev = tag->u.revision.rev;
-	return 0;
-}
-
-__tagtable(ATAG_REVISION, parse_tag_revision);
-
-static int __init parse_tag_cmdline(const struct tag *tag)
-{
-#if defined(CONFIG_CMDLINE_EXTEND)
-	strlcat(default_command_line, " ", COMMAND_LINE_SIZE);
-	strlcat(default_command_line, tag->u.cmdline.cmdline,
-		COMMAND_LINE_SIZE);
-#elif defined(CONFIG_CMDLINE_FORCE)
-	pr_warning("Ignoring tag cmdline (using the default kernel command line)\n");
-#else
-	strlcpy(default_command_line, tag->u.cmdline.cmdline,
-		COMMAND_LINE_SIZE);
-#endif
-	return 0;
-}
-
-__tagtable(ATAG_CMDLINE, parse_tag_cmdline);
-
-/*
- * Scan the tag table for this tag, and call its parse function.
- * The tag table is built by the linker from all the __tagtable
- * declarations.
- */
-static int __init parse_tag(const struct tag *tag)
-{
-	extern struct tagtable __tagtable_begin, __tagtable_end;
-	struct tagtable *t;
-
-	for (t = &__tagtable_begin; t < &__tagtable_end; t++)
-		if (tag->hdr.tag == t->tag) {
-			t->parse(tag);
-			break;
-		}
-
-	return t < &__tagtable_end;
-}
-
-/*
- * Parse all tags in the list, checking both the global and architecture
- * specific tag tables.
- */
-static void __init parse_tags(const struct tag *t)
-{
-	for (; t->hdr.size; t = tag_next(t))
-		if (!parse_tag(t))
-			printk(KERN_WARNING
-				"Ignoring unrecognised tag 0x%08x\n",
-				t->hdr.tag);
-}
-
-/*
- * This holds our defaults.
- */
-static struct init_tags {
-	struct tag_header hdr1;
-	struct tag_core   core;
-	struct tag_header hdr2;
-	struct tag_mem32  mem;
-	struct tag_header hdr3;
-} init_tags __initdata = {
-	{ tag_size(tag_core), ATAG_CORE },
-	{ 1, PAGE_SIZE, 0xff },
-	{ tag_size(tag_mem32), ATAG_MEM },
-	{ MEM_SIZE },
-	{ 0, ATAG_NONE }
-};
-
 static int __init customize_machine(void)
 {
 	/* customizes platform devices, or adds new ones */
@@ -858,78 +696,6 @@ static void __init reserve_crashkernel(void)
 static inline void reserve_crashkernel(void) {}
 #endif /* CONFIG_KEXEC */
 
-static void __init squash_mem_tags(struct tag *tag)
-{
-	for (; tag->hdr.size; tag = tag_next(tag))
-		if (tag->hdr.tag == ATAG_MEM)
-			tag->hdr.tag = ATAG_NONE;
-}
-
-static struct machine_desc * __init setup_machine_tags(unsigned int nr)
-{
-	struct tag *tags = (struct tag *)&init_tags;
-	struct machine_desc *mdesc = NULL, *p;
-	char *from = default_command_line;
-
-	init_tags.mem.start = PHYS_OFFSET;
-
-	/*
-	 * locate machine in the list of supported machines.
-	 */
-	for_each_machine_desc(p)
-		if (nr == p->nr) {
-			printk("Machine: %s\n", p->name);
-			mdesc = p;
-			break;
-		}
-
-	if (!mdesc) {
-		early_print("\nError: unrecognized/unsupported machine ID"
-			" (r1 = 0x%08x).\n\n", nr);
-		dump_machine_table(); /* does not return */
-	}
-
-	if (__atags_pointer)
-		tags = phys_to_virt(__atags_pointer);
-	else if (mdesc->atag_offset)
-		tags = (void *)(PAGE_OFFSET + mdesc->atag_offset);
-
-#if defined(CONFIG_DEPRECATED_PARAM_STRUCT)
-	/*
-	 * If we have the old style parameters, convert them to
-	 * a tag list.
-	 */
-	if (tags->hdr.tag != ATAG_CORE)
-		convert_to_tag_list(tags);
-#endif
-
-	if (tags->hdr.tag != ATAG_CORE) {
-#if defined(CONFIG_OF)
-		/*
-		 * If CONFIG_OF is set, then assume this is a reasonably
-		 * modern system that should pass boot parameters
-		 */
-		early_print("Warning: Neither atags nor dtb found\n");
-#endif
-		tags = (struct tag *)&init_tags;
-	}
-
-	if (mdesc->fixup)
-		mdesc->fixup(tags, &from, &meminfo);
-
-	if (tags->hdr.tag == ATAG_CORE) {
-		if (meminfo.nr_banks != 0)
-			squash_mem_tags(tags);
-		save_atags(tags);
-		parse_tags(tags);
-	}
-
-	/* parse_early_param needs a boot_command_line */
-	strlcpy(boot_command_line, from, COMMAND_LINE_SIZE);
-
-	return mdesc;
-}
-
 static int __init meminfo_cmp(const void *_a, const void *_b)
 {
 	const struct membank *a = _a, *b = _b;
@@ -944,7 +710,7 @@ void __init setup_arch(char **cmdline_p)
 	setup_processor();
 	mdesc = setup_machine_fdt(__atags_pointer);
 	if (!mdesc)
-		mdesc = setup_machine_tags(machine_arch_type);
+		mdesc = setup_machine_tags(__atags_pointer, machine_arch_type);
 	machine_desc = mdesc;
 	machine_name = mdesc->name;
 

commit a5d5f7daa744b34477c4a12728bde0a1694a1707
Author: Peter Maydell <peter.maydell@linaro.org>
Date:   Thu Jul 12 23:57:35 2012 +0100

    ARM: 7465/1: Handle >4GB memory sizes in device tree and mem=size@start option
    
    The memory regions which are passed to arm_add_memory() from
    device tree blobs via early_init_dt_add_memory_arch() can
    have sizes which are larger than will fit in a 32 bit integer,
    so switch to using a phys_addr_t to hold them, to avoid
    silently dropping the top 32 bits of the size. Similarly, use
    phys_addr_t in early_mem() so that mem=size@start command line
    options specifying more than 4GB behave sensibly.
    
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Peter Maydell <peter.maydell@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index e15d83bb4ea3..a81dcecc7343 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -508,7 +508,7 @@ void __init dump_machine_table(void)
 		/* can't use cpu_relax() here as it may require MMU setup */;
 }
 
-int __init arm_add_memory(phys_addr_t start, unsigned long size)
+int __init arm_add_memory(phys_addr_t start, phys_addr_t size)
 {
 	struct membank *bank = &meminfo.bank[meminfo.nr_banks];
 
@@ -538,7 +538,7 @@ int __init arm_add_memory(phys_addr_t start, unsigned long size)
 	}
 #endif
 
-	bank->size = size & PAGE_MASK;
+	bank->size = size & ~(phys_addr_t)(PAGE_SIZE - 1);
 
 	/*
 	 * Check whether this memory region has non-zero size or
@@ -558,7 +558,7 @@ int __init arm_add_memory(phys_addr_t start, unsigned long size)
 static int __init early_mem(char *p)
 {
 	static int usermem __initdata = 0;
-	unsigned long size;
+	phys_addr_t size;
 	phys_addr_t start;
 	char *endp;
 

commit f465d145d76803fe6332092775d891c8c509aa44
Merge: 30b842889eea 80b9abf97346
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat May 26 13:14:01 2012 -0700

    Merge tag 'cleanup-initcall' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull sweeping late_initcall cleanup for arm-soc from Olof Johansson:
     "This is a patch series from Shawn Guo that moves from individual
      late_initcalls() to using a member in the machine structure to invoke
      a platform's late initcalls.
    
      This cleanup is a step in the move towards multiplatform kernels since
      it would reduce the need to check for compatible platforms in each and
      every initcall."
    
    Fix up trivial conflicts in arch/arm/mach-{exynos/mach-universal_c210.c,
    imx/mach-cpuimx51.c, omap2/board-generic.c} due to changes nearby (and,
    in the case of cpuimx51.c the board support being deleted)
    
    * tag 'cleanup-initcall' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      ARM: ux500: use machine specific hook for late init
      ARM: tegra: use machine specific hook for late init
      ARM: shmobile: use machine specific hook for late init
      ARM: sa1100: use machine specific hook for late init
      ARM: s3c64xx: use machine specific hook for late init
      ARM: prima2: use machine specific hook for late init
      ARM: pnx4008: use machine specific hook for late init
      ARM: omap2: use machine specific hook for late init
      ARM: omap1: use machine specific hook for late init
      ARM: msm: use machine specific hook for late init
      ARM: imx: use machine specific hook for late init
      ARM: exynos: use machine specific hook for late init
      ARM: ep93xx: use machine specific hook for late init
      ARM: davinci: use machine specific hook for late init
      ARM: provide a late_initcall hook for platform initialization

commit c79095092834a18ae74cfc08def1a5a101dc106c
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Thu Dec 29 13:09:51 2011 +0100

    ARM: integrate CMA with DMA-mapping subsystem
    
    This patch adds support for CMA to dma-mapping subsystem for ARM
    architecture. By default a global CMA area is used, but specific devices
    are allowed to have their private memory areas if required (they can be
    created with dma_declare_contiguous() function during board
    initialisation).
    
    Contiguous memory areas reserved for DMA are remapped with 2-level page
    tables on boot. Once a buffer is requested, a low memory kernel mapping
    is updated to to match requested memory access type.
    
    GFP_ATOMIC allocations are performed from special pool which is created
    early during boot. This way remapping page attributes is not needed on
    allocation time.
    
    CMA has been enabled unconditionally for ARMv6+ systems.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    CC: Michal Nazarewicz <mina86@mina86.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Tested-by: Rob Clark <rob.clark@linaro.org>
    Tested-by: Ohad Ben-Cohen <ohad@wizery.com>
    Tested-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Tested-by: Robert Nelson <robertcnelson@gmail.com>
    Tested-by: Barry Song <Baohua.Song@csr.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index ebfac782593f..1b3096dfb964 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -81,6 +81,7 @@ __setup("fpe=", fpe_setup);
 extern void paging_init(struct machine_desc *desc);
 extern void sanity_check_meminfo(void);
 extern void reboot_setup(char *str);
+extern void setup_dma_zone(struct machine_desc *desc);
 
 unsigned int processor_id;
 EXPORT_SYMBOL(processor_id);
@@ -939,12 +940,8 @@ void __init setup_arch(char **cmdline_p)
 	machine_desc = mdesc;
 	machine_name = mdesc->name;
 
-#ifdef CONFIG_ZONE_DMA
-	if (mdesc->dma_zone_size) {
-		extern unsigned long arm_dma_zone_size;
-		arm_dma_zone_size = mdesc->dma_zone_size;
-	}
-#endif
+	setup_dma_zone(mdesc);
+
 	if (mdesc->restart_mode)
 		reboot_setup(&mdesc->restart_mode);
 

commit 90de41375ccf8373c0a39d04547f3e3c65d90ec0
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Wed Apr 25 22:24:44 2012 +0800

    ARM: provide a late_initcall hook for platform initialization
    
    This allows platforms to set up things that need to be done at
    late_initcall time.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Tested-by: Robert Lee <rob.lee@linaro.org>
    Tested-by: Stephen Warren <swarren@wwwdotorg.org>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index ebfac782593f..549f036a5cf8 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -800,6 +800,14 @@ static int __init customize_machine(void)
 }
 arch_initcall(customize_machine);
 
+static int __init init_machine_late(void)
+{
+	if (machine_desc->init_late)
+		machine_desc->init_late();
+	return 0;
+}
+late_initcall(init_machine_late);
+
 #ifdef CONFIG_KEXEC
 static inline unsigned long long get_total_mem(void)
 {

commit e5ab85800820edd907d3f43f285e1232f84d5a41
Author: Will Deacon <will.deacon@arm.com>
Date:   Thu Apr 12 17:15:08 2012 +0100

    ARM: 7382/1: mm: truncate memory banks to fit in 4GB space for classic MMU
    
    If a bank of memory spanning the 4GB boundary is added on a !CONFIG_LPAE
    kernel then we will hang early during boot since the memory bank will
    have wrapped around to zero.
    
    This patch truncates memory banks for !LPAE configurations when the end
    address is not representable in 32 bits.
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index b91411371ae1..ebfac782593f 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -523,7 +523,21 @@ int __init arm_add_memory(phys_addr_t start, unsigned long size)
 	 */
 	size -= start & ~PAGE_MASK;
 	bank->start = PAGE_ALIGN(start);
-	bank->size  = size & PAGE_MASK;
+
+#ifndef CONFIG_LPAE
+	if (bank->start + size < bank->start) {
+		printk(KERN_CRIT "Truncating memory at 0x%08llx to fit in "
+			"32-bit physical address space\n", (long long)start);
+		/*
+		 * To ensure bank->start + bank->size is representable in
+		 * 32 bits, we use ULONG_MAX as the upper limit rather than 4GB.
+		 * This means we lose a page after masking.
+		 */
+		size = ULONG_MAX - bank->start;
+	}
+#endif
+
+	bank->size = size & PAGE_MASK;
 
 	/*
 	 * Check whether this memory region has non-zero size or

commit 12679a2d7e3bfbdc7586e3e86d1ca90c46659363
Merge: 1c036588772d b0df89868006
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 29 16:53:48 2012 -0700

    Merge branch 'for-linus' of git://git.linaro.org/people/rmk/linux-arm
    
    Pull more ARM updates from Russell King.
    
    This got a fair number of conflicts with the <asm/system.h> split, but
    also with some other sparse-irq and header file include cleanups.  They
    all looked pretty trivial, though.
    
    * 'for-linus' of git://git.linaro.org/people/rmk/linux-arm: (59 commits)
      ARM: fix Kconfig warning for HAVE_BPF_JIT
      ARM: 7361/1: provide XIP_VIRT_ADDR for no-MMU builds
      ARM: 7349/1: integrator: convert to sparse irqs
      ARM: 7259/3: net: JIT compiler for packet filters
      ARM: 7334/1: add jump label support
      ARM: 7333/2: jump label: detect %c support for ARM
      ARM: 7338/1: add support for early console output via semihosting
      ARM: use set_current_blocked() and block_sigmask()
      ARM: exec: remove redundant set_fs(USER_DS)
      ARM: 7332/1: extract out code patch function from kprobes
      ARM: 7331/1: extract out insn generation code from ftrace
      ARM: 7330/1: ftrace: use canonical Thumb-2 wide instruction format
      ARM: 7351/1: ftrace: remove useless memory checks
      ARM: 7316/1: kexec: EOI active and mask all interrupts in kexec crash path
      ARM: Versatile Express: add NO_IOPORT
      ARM: get rid of asm/irq.h in asm/prom.h
      ARM: 7319/1: Print debug info for SIGBUS in user faults
      ARM: 7318/1: gic: refactor irq_start assignment
      ARM: 7317/1: irq: avoid NULL check in for_each_irq_desc loop
      ARM: 7315/1: perf: add support for the Cortex-A7 PMU
      ...

commit 9f97da78bf018206fb623cd351d454af2f105fe0
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:01 2012 +0100

    Disintegrate asm/system.h for ARM
    
    Disintegrate asm/system.h for ARM.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Russell King <linux@arm.linux.org.uk>
    cc: linux-arm-kernel@lists.infradead.org

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 615e992d738d..9e0fdb3a1988 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -50,6 +50,8 @@
 #include <asm/mach/arch.h>
 #include <asm/mach/irq.h>
 #include <asm/mach/time.h>
+#include <asm/system_info.h>
+#include <asm/system_misc.h>
 #include <asm/traps.h>
 #include <asm/unwind.h>
 #include <asm/memblock.h>

commit 15d07dc9c59eae51219c40253bdf920f62bb10f2
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Mar 28 18:30:01 2012 +0100

    ARM: move CP15 definitions to separate header file
    
    Avoid namespace conflicts with drivers over the CP15 definitions by
    moving CP15 related prototypes and definitions to a private header
    file.
    
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Tested-by: Stephen Warren <swarren@nvidia.com> [Tegra]
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Tested-by: H Hartley Sweeten <hsweeten@visionengravers.com> [EP93xx]
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index a255c39612ca..615e992d738d 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -33,6 +33,7 @@
 #include <linux/sort.h>
 
 #include <asm/unified.h>
+#include <asm/cp15.h>
 #include <asm/cpu.h>
 #include <asm/cputype.h>
 #include <asm/elf.h>
@@ -44,7 +45,6 @@
 #include <asm/cacheflush.h>
 #include <asm/cachetype.h>
 #include <asm/tlbflush.h>
-#include <asm/system.h>
 
 #include <asm/prom.h>
 #include <asm/mach/arch.h>

commit 195864cf3d6f5b6b743793bda3aaa2ff65d322ae
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jan 19 10:05:41 2012 +0000

    ARM: move CP15 definitions to separate header file
    
    Avoid namespace conflicts with drivers over the CP15 definitions by
    moving CP15 related prototypes and definitions to a private header
    file.
    
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Tested-by: Stephen Warren <swarren@nvidia.com> [Tegra]
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Tested-by: H Hartley Sweeten <hsweeten@visionengravers.com> [EP93xx]
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 9b65cb4589e2..e5c37fc1d1d6 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -34,6 +34,7 @@
 #include <linux/sort.h>
 
 #include <asm/unified.h>
+#include <asm/cp15.h>
 #include <asm/cpu.h>
 #include <asm/cputype.h>
 #include <asm/elf.h>
@@ -45,7 +46,6 @@
 #include <asm/cacheflush.h>
 #include <asm/cachetype.h>
 #include <asm/tlbflush.h>
-#include <asm/system.h>
 
 #include <asm/prom.h>
 #include <asm/mach/arch.h>

commit 94e5a85b3be0ce109d26aa6812b2a02c518a0e4b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Jan 18 15:32:49 2012 +0000

    ARM: earlier initialization of vectors page
    
    Initialize the contents of the vectors page immediately after we
    allocate the page, but before we map it.  This avoids any possible
    aliases with other mappings which may need to be flushed after the
    page has been mapped irrespective of the cache type.
    
    We follow this later with a flush_cache_all() after all static memory
    mappings have been initialized, which ensures that this is safe from
    any cache effects.
    
    Tested-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 129fbd55bde8..9b65cb4589e2 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -961,7 +961,6 @@ void __init setup_arch(char **cmdline_p)
 	conswitchp = &dummy_con;
 #endif
 #endif
-	early_trap_init();
 
 	if (mdesc->init_early)
 		mdesc->init_early();

commit eb50439b92b6298bf209a982f295ba9c0f7cb30b
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Jan 20 12:01:12 2012 +0100

    ARM: 7293/1: logical_cpu_map: decouple CPU mapping from SMP
    
    It turns out that the logical CPU mapping is useful even when !CONFIG_SMP
    for manipulation of devices like interrupt and power controllers when
    running a UP kernel on a CPU other than 0. This can happen when kexecing
    a UP image from an SMP kernel.
    
    In the future, multi-cluster systems running AMP configurations will
    require something similar for mapping cluster IDs, so it makes sense to
    decouple this logic in preparation for this support.
    
    Acked-by: Yang Bai <hamo.by@gmail.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Reported-by: Joerg Roedel <joerg.roedel@amd.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index ab70c9124538..a255c39612ca 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -426,6 +426,20 @@ void cpu_init(void)
 	    : "r14");
 }
 
+int __cpu_logical_map[NR_CPUS];
+
+void __init smp_setup_processor_id(void)
+{
+	int i;
+	u32 cpu = is_smp() ? read_cpuid_mpidr() & 0xff : 0;
+
+	cpu_logical_map(0) = cpu;
+	for (i = 1; i < NR_CPUS; ++i)
+		cpu_logical_map(i) = i == cpu ? 0 : i;
+
+	printk(KERN_INFO "Booting Linux on physical CPU %d\n", cpu);
+}
+
 static void __init setup_processor(void)
 {
 	struct proc_info_list *list;

commit 06e9905152cd124c53f571296e9904ea89c1a39a
Author: Fabio Estevam <festevam@gmail.com>
Date:   Fri Jan 13 17:06:59 2012 +0100

    ARM: 7277/1: setup.c: Fix build warning by removing unneeded header file
    
    Fix the following build warning:
    
      CC      arch/arm/kernel/setup.o
    In file included from arch/arm/kernel/setup.c:39:
    arch/arm/include/asm/elf.h:102:1: warning: "vmcore_elf64_check_arch" redefined
    In file included from arch/arm/kernel/setup.c:24:
    include/linux/crash_dump.h:30:1: warning: this is the location of the previous definition
    
    Since commit 93a72052 (crash_dump: export is_kdump_kernel to modules, consolidate elfcorehdr_addr, setup_elfcorehdr and saved_max_pfn)
    the inclusion of <linux/crash_dump.h> is no longer needed.
    
    Remove the inclusion of <linux/crash_dump.h> and the build warning is fixed.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 95653d03db7e..ab70c9124538 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -21,7 +21,6 @@
 #include <linux/init.h>
 #include <linux/kexec.h>
 #include <linux/of_fdt.h>
-#include <linux/crash_dump.h>
 #include <linux/root_dev.h>
 #include <linux/cpu.h>
 #include <linux/interrupt.h>

commit a36d8e5bc27316163c9d753af5966ee92ecbec59
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Jan 18 01:57:21 2012 +0100

    ARM: 7279/1: standardize /proc/iomem "Kernel code" name
    
    All other ports use "Kernel code" to identify the Kernel text segment
    in /proc/iomem. Change the ARM resources to do the same.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 129fbd55bde8..95653d03db7e 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -160,7 +160,7 @@ static struct resource mem_res[] = {
 		.flags = IORESOURCE_MEM
 	},
 	{
-		.name = "Kernel text",
+		.name = "Kernel code",
 		.start = 0,
 		.end = 0,
 		.flags = IORESOURCE_MEM

commit 770e1b035dcb6ec3f8ee69dda0815dd1e220a683
Merge: d3d0b024348c 7b9dd47136c0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 6 18:15:25 2012 -0800

    Merge branch 'for-linus' of git://ftp.arm.linux.org.uk/pub/linux/arm/kernel/git-cur/linux-2.6-arm
    
    * 'for-linus' of git://ftp.arm.linux.org.uk/pub/linux/arm/kernel/git-cur/linux-2.6-arm: (207 commits)
      ARM: 7267/1: Remove BUILD_BUG_ON from asm/bug.h
      ARM: 7269/1: mach-sa1100: fix sched_clock breakage
      ARM: 7198/1: arm/imx6: add restart support for imx6q
      ARM: restart: remove the now empty arch_reset()
      ARM: restart: remove comments about adding code to arch_reset()
      ARM: restart: lpc32xx & u300: remove unnecessary printk
      ARM: restart: plat-samsung: remove plat/reset.h and s5p_reset_hook
      ARM: restart: w90x900: use new restart hook
      ARM: restart: Versatile Express: use new restart hook
      ARM: restart: versatile: use new restart hook
      ARM: restart: u300: use new restart hook
      ARM: restart: tegra: use new restart hook
      ARM: restart: spear: use new restart hook
      ARM: restart: shark: use new restart hook
      ARM: restart: sa1100: use new restart hook
      ARM: 7252/1: restart: S5PV210: use new restart hook
      ARM: 7251/1: restart: S5PC100: use new restart hook
      ARM: 7250/1: restart: S5P64X0: use new restart hook
      ARM: 7266/1: restart: S3C64XX: use new restart hook
      ARM: 7265/1: restart: S3C24XX: use new restart hook
      ...
    
    Fix up trivial conflict in arch/arm/mm/init.c due to removal of
    memblock_init() clashing with the movement of the sorting of the meminfo
    array.

commit 2e0e943436912ffe0848ece58167edfe754edb96
Merge: a32737e1ca65 ef3a0bf5bfad
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jan 5 13:24:33 2012 +0000

    Merge branch 'devel-stable' into for-linus
    
    Conflicts:
            arch/arm/kernel/setup.c
            arch/arm/mach-shmobile/board-kota2.c

commit 45aa0663cc408617b79a2b53f0a5f50e94688a48
Merge: 511585a28e5b 7bd0b0f0da3b
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Dec 20 12:14:26 2011 +0100

    Merge branch 'memblock-kill-early_node_map' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/misc into core/memblock

commit 9811ccdfa94b4773c8030569bd8ec75eafa485ac
Author: Arnaud Patard <arnaud.patard@rtp-net.org>
Date:   Sun Dec 11 20:32:25 2011 +0100

    ARM: 7204/1: arch/arm/kernel/setup.c: initialize arm_dma_zone_size earlier
    
    arm_dma_zone_size is used by arm_bootmem_free() which is called by
    paging_init(). Thus it needs to be set before calling it.
    
    Signed-off-by: Arnaud Patard <arnaud.patard@rtp-net.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Cc: stable@kernel.org
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 1bdd0adbb7dd..8fc2c8fcbdc6 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -902,6 +902,12 @@ void __init setup_arch(char **cmdline_p)
 	machine_desc = mdesc;
 	machine_name = mdesc->name;
 
+#ifdef CONFIG_ZONE_DMA
+	if (mdesc->dma_zone_size) {
+		extern unsigned long arm_dma_zone_size;
+		arm_dma_zone_size = mdesc->dma_zone_size;
+	}
+#endif
 	if (mdesc->soft_reboot)
 		reboot_setup("s");
 
@@ -932,12 +938,6 @@ void __init setup_arch(char **cmdline_p)
 
 	tcm_init();
 
-#ifdef CONFIG_ZONE_DMA
-	if (mdesc->dma_zone_size) {
-		extern unsigned long arm_dma_zone_size;
-		arm_dma_zone_size = mdesc->dma_zone_size;
-	}
-#endif
 #ifdef CONFIG_MULTI_IRQ_HANDLER
 	handle_arch_irq = mdesc->handle_irq;
 #endif

commit 1c16d242aa441c11ccaeaa63b49712555b8bfaeb
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Dec 8 10:22:06 2011 -0800

    memblock: Fix include breakages caused by 24aa07882b
    
    24aa07882b (memblock, x86: Replace memblock_x86_reserve/free_range()
    with generic ones) removed arch/x86/include/asm/memblock.h and dropped
    its inclusion from include/linux/memblock.h which breaks other
    architectures which depended on the generic memblock.h pulling in the
    arch specific one.
    
    However, the proper fix isn't adding back the asm inclusion.  memblock
    doesn't have any arch dependent part and doesn't need arch specific
    header file and asm/memblock.h files are either practically empty or
    contain mostly unrelated arch specific stuff.
    
    * In microblaze, sh, powerpc, sparc and openrisc, asm/memblock.h is
      either empty or just contains unused MEMBLOCK_DBG() macro.  Remove
      them.
    
    * In arm and unicore32, asm/memblock.h contains arch specific stuff.
      Include it directly from its users.  It might be a good idea to
      rename the header file to avoid confusion.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 3448a3f9cc8c..6701ba99dea4 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -52,6 +52,7 @@
 #include <asm/mach/time.h>
 #include <asm/traps.h>
 #include <asm/unwind.h>
+#include <asm/memblock.h>
 
 #if defined(CONFIG_DEPRECATED_PARAM_STRUCT)
 #include "compat.h"

commit de66a979012dbc66b1ec0125795a3f79ee667b8a
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Dec 5 09:39:59 2011 +0100

    ARM: 7187/1: fix unwinding for XIP kernels
    
    The linker places the unwind tables in readonly sections. So when using
    an XIP kernel these are located in ROM and cannot be modified.
    For that reason the current approach to convert the relative offsets in
    the unwind index to absolute addresses early in the boot process doesn't
    work with XIP.
    
    The offsets in the unwind index section are signed 31 bit numbers and
    the structs are sorted by this offset. So it first has offsets between
    0x40000000 and 0x7fffffff (i.e. the negative offsets) and then offsets
    between 0x00000000 and 0x3fffffff. When seperating these two blocks the
    numbers are sorted even when interpreting the offsets as unsigned longs.
    
    So determine the first non-negative entry once and track that using the
    new origin pointer. The actual bisection can then use a plain unsigned
    long comparison. The only thing that makes the new bisection more
    complicated is that the offsets are relative to their position in the
    index section, so the key to search needs to be adapted accordingly in
    each step.
    
    Moreover several consts are added to catch future writes and rename the
    member "addr" of struct unwind_idx to "addr_offset" to better match the
    new semantic. (This has the additional benefit of breaking eventual
    users at compile time to make them aware of the change.)
    
    In my tests the new algorithm was a tad faster than the original and has
    the additional upside of not needing the initial conversion and so saves
    some boot time and it's possible to unwind even earlier.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Nicolas Pitre <nico@fluxnic.net>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 3448a3f9cc8c..1bdd0adbb7dd 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -895,8 +895,6 @@ void __init setup_arch(char **cmdline_p)
 {
 	struct machine_desc *mdesc;
 
-	unwind_init();
-
 	setup_processor();
 	mdesc = setup_machine_fdt(__atags_pointer);
 	if (!mdesc)

commit 73829af71fdb8655e7ba4b5a2a6612ad34a75a11
Merge: 742eaa6a6e35 0af362f8440a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Dec 5 23:27:54 2011 +0000

    Merge branch 'vmalloc' of git://git.linaro.org/people/nico/linux into devel-stable

commit 742eaa6a6e356a16788ce6530271de89bc4f8fb5
Merge: ba8bb18a03f8 ae72fd588a2b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Dec 5 23:20:17 2011 +0000

    Merge branch 'for-rmk' of git://git.kernel.org/pub/scm/linux/kernel/git/will/linux into devel-stable
    
    Conflicts:
            arch/arm/common/gic.c
            arch/arm/plat-omap/include/plat/common.h

commit 27a3f0e91bed0f4dcf0a363e5f5938126d1ff4e5
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Thu Aug 25 19:10:29 2011 -0400

    ARM: sort the meminfo array earlier
    
    The meminfo array has to be sorted before sanity_check_meminfo() in
    arch/arm/mm/mmu.c is called for it to work properly.  This also allows
    for a simpler find_limits() in arch/arm/mm/init.c.
    
    The sort is moved to arch/arm/kernel/setup.c because that's where the
    meminfo array is populated.  Eventually this should be improved upon
    to make the memory bank parser a bit more robust against problems
    such as overlapping memory ranges.
    
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 7e7977ab994f..44510f879312 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -31,6 +31,7 @@
 #include <linux/memblock.h>
 #include <linux/bug.h>
 #include <linux/compiler.h>
+#include <linux/sort.h>
 
 #include <asm/unified.h>
 #include <asm/cpu.h>
@@ -888,6 +889,12 @@ static struct machine_desc * __init setup_machine_tags(unsigned int nr)
 	return mdesc;
 }
 
+static int __init meminfo_cmp(const void *_a, const void *_b)
+{
+	const struct membank *a = _a, *b = _b;
+	long cmp = bank_pfn_start(a) - bank_pfn_start(b);
+	return cmp < 0 ? -1 : cmp > 0 ? 1 : 0;
+}
 
 void __init setup_arch(char **cmdline_p)
 {
@@ -916,6 +923,7 @@ void __init setup_arch(char **cmdline_p)
 
 	parse_early_param();
 
+	sort(&meminfo.bank, meminfo.nr_banks, sizeof(meminfo.bank[0]), meminfo_cmp, NULL);
 	sanity_check_meminfo();
 	arm_memblock_init(&meminfo, mdesc);
 

commit a34dbfb03f472ad3e063d3b1d1e88f7ef8f88bf1
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Nov 11 11:35:58 2011 +0100

    ARM: 7160/1: setup: avoid overflowing {elf,arch}_name from proc_info_list
    
    setup_processor copies the arch_name and elf_name fields out of the
    selected proc_info_list into two fixed size buffers.
    
    Since the proc_info_list structure is defined in a proc_*.S assembly
    file, this can lead to subtle errors if the strings defined there are
    too long (for example, corrupting the machine ID).
    
    This patch uses snprintf instead of sprintf to ensure that these buffers
    are not overrun.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 7e7977ab994f..3448a3f9cc8c 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -461,8 +461,10 @@ static void __init setup_processor(void)
 	       cpu_name, read_cpuid_id(), read_cpuid_id() & 15,
 	       proc_arch[cpu_architecture()], cr_alignment);
 
-	sprintf(init_utsname()->machine, "%s%c", list->arch_name, ENDIANNESS);
-	sprintf(elf_platform, "%s%c", list->elf_name, ENDIANNESS);
+	snprintf(init_utsname()->machine, __NEW_UTS_LEN + 1, "%s%c",
+		 list->arch_name, ENDIANNESS);
+	snprintf(elf_platform, ELF_PLATFORM_SIZE, "%s%c",
+		 list->elf_name, ENDIANNESS);
 	elf_hwcap = list->elf_hwcap;
 #ifndef CONFIG_ARM_THUMB
 	elf_hwcap &= ~HWCAP_THUMB;

commit b44c350d4104265cf3a6b4355dc1ee05c16aa5de
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Nov 1 14:27:33 2011 +0000

    ARM: restart: allow platforms more flexibility specifying restart mode
    
    Change 'soft_reboot' into a more generic 'restart_mode' variable,
    allowing the default restart mode to be specified.
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 4755e2827dc3..a753880e984b 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -902,8 +902,8 @@ void __init setup_arch(char **cmdline_p)
 	machine_desc = mdesc;
 	machine_name = mdesc->name;
 
-	if (mdesc->soft_reboot)
-		reboot_setup("s");
+	if (mdesc->restart_mode)
+		reboot_setup(&mdesc->restart_mode);
 
 	init_mm.start_code = (unsigned long) _text;
 	init_mm.end_code   = (unsigned long) _etext;

commit a528721da08a793e0cec6ef6281d404eddd6e27b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Nov 4 15:05:24 2011 +0000

    ARM: restart: add restart hook to machine_desc record
    
    Add a restart hook to the machine_desc record so we don't have to
    populate all platforms with init_early methods to initialize the
    arm_pm_restart function pointer.
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 7e7977ab994f..4755e2827dc3 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -922,6 +922,9 @@ void __init setup_arch(char **cmdline_p)
 	paging_init(mdesc);
 	request_standard_resources(mdesc);
 
+	if (mdesc->restart)
+		arm_pm_restart = mdesc->restart;
+
 	unflatten_device_tree();
 
 #ifdef CONFIG_SMP

commit ecea4ab6d3d8bb4122522398200f1cd2a06af6d5
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 22 10:58:34 2011 -0400

    arm: convert core files from module.h to export.h
    
    Many of the core ARM kernel files are not modules, but just
    including module.h for exporting symbols.  Now these files can
    use the lighter footprint export.h for this role.
    
    There are probably lots more, but ARM files of mach-* and plat-*
    don't get coverage via a simple yesconfig build.  They will have
    to be cleaned up and tested via using their respective configs.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index bda0a218f4a5..7e7977ab994f 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -7,7 +7,7 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
-#include <linux/module.h>
+#include <linux/export.h>
 #include <linux/kernel.h>
 #include <linux/stddef.h>
 #include <linux/ioport.h>

commit 1fdb24e969110fafea36d3b393bea438f702c87f
Merge: f362f98e7c44 531a6a941745
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 28 12:02:27 2011 -0700

    Merge branch 'devel-stable' of http://ftp.arm.linux.org.uk/pub/linux/arm/kernel/git-cur/linux-2.6-arm
    
    * 'devel-stable' of http://ftp.arm.linux.org.uk/pub/linux/arm/kernel/git-cur/linux-2.6-arm: (178 commits)
      ARM: 7139/1: fix compilation with CONFIG_ARM_ATAG_DTB_COMPAT and large TEXT_OFFSET
      ARM: gic, local timers: use the request_percpu_irq() interface
      ARM: gic: consolidate PPI handling
      ARM: switch from NO_MACH_MEMORY_H to NEED_MACH_MEMORY_H
      ARM: mach-s5p64x0: remove mach/memory.h
      ARM: mach-s3c64xx: remove mach/memory.h
      ARM: plat-mxc: remove mach/memory.h
      ARM: mach-prima2: remove mach/memory.h
      ARM: mach-zynq: remove mach/memory.h
      ARM: mach-bcmring: remove mach/memory.h
      ARM: mach-davinci: remove mach/memory.h
      ARM: mach-pxa: remove mach/memory.h
      ARM: mach-ixp4xx: remove mach/memory.h
      ARM: mach-h720x: remove mach/memory.h
      ARM: mach-vt8500: remove mach/memory.h
      ARM: mach-s5pc100: remove mach/memory.h
      ARM: mach-tegra: remove mach/memory.h
      ARM: plat-tcc: remove mach/memory.h
      ARM: mach-mmp: remove mach/memory.h
      ARM: mach-cns3xxx: remove mach/memory.h
      ...
    
    Fix up mostly pretty trivial conflicts in:
     - arch/arm/Kconfig
     - arch/arm/include/asm/localtimer.h
     - arch/arm/kernel/Makefile
     - arch/arm/mach-shmobile/board-ap4evb.c
     - arch/arm/mach-u300/core.c
     - arch/arm/mm/dma-mapping.c
     - arch/arm/mm/proc-v7.S
     - arch/arm/plat-omap/Kconfig
    largely due to some CONFIG option renaming (ie CONFIG_PM_SLEEP ->
    CONFIG_ARM_CPU_SUSPEND for the arm-specific suspend code etc) and
    addition of NEED_MACH_MEMORY_H next to HAVE_IDE.

commit 7f94e9cc5e965519d865bf20215036f359a1e299
Author: Will Deacon <will.deacon@arm.com>
Date:   Tue Aug 23 22:22:11 2011 +0100

    ARM: 7062/1: cache: detect PIPT I-cache using CTR
    
    The Cache Type Register L1Ip field identifies I-caches with a PIPT
    policy using the encoding 11b.
    
    This patch extends the cache policy parsing to identify PIPT I-caches
    correctly and prevent them from being treated as VIPT aliasing in cases
    where they are sufficiently large.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 93e39a3d2c1e..3fe93f75b55a 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -265,6 +265,10 @@ static int cpu_has_aliasing_icache(unsigned int arch)
 	int aliasing_icache;
 	unsigned int id_reg, num_sets, line_size;
 
+	/* PIPT caches never alias. */
+	if (icache_is_pipt())
+		return 0;
+
 	/* arch specifies the register format */
 	switch (arch) {
 	case CPU_ARCH_ARMv7:
@@ -299,8 +303,14 @@ static void __init cacheid_init(void)
 			/* ARMv7 register format */
 			arch = CPU_ARCH_ARMv7;
 			cacheid = CACHEID_VIPT_NONALIASING;
-			if ((cachetype & (3 << 14)) == 1 << 14)
+			switch (cachetype & (3 << 14)) {
+			case (1 << 14):
 				cacheid |= CACHEID_ASID_TAGGED;
+				break;
+			case (3 << 14):
+				cacheid |= CACHEID_PIPT;
+				break;
+			}
 		} else {
 			arch = CPU_ARCH_ARMv6;
 			if (cachetype & (1 << 23))
@@ -317,10 +327,11 @@ static void __init cacheid_init(void)
 	printk("CPU: %s data cache, %s instruction cache\n",
 		cache_is_vivt() ? "VIVT" :
 		cache_is_vipt_aliasing() ? "VIPT aliasing" :
-		cache_is_vipt_nonaliasing() ? "VIPT nonaliasing" : "unknown",
+		cache_is_vipt_nonaliasing() ? "PIPT / VIPT nonaliasing" : "unknown",
 		cache_is_vivt() ? "VIVT" :
 		icache_is_vivt_asid_tagged() ? "VIVT ASID tagged" :
 		icache_is_vipt_aliasing() ? "VIPT aliasing" :
+		icache_is_pipt() ? "PIPT" :
 		cache_is_vipt_nonaliasing() ? "VIPT nonaliasing" : "unknown");
 }
 

commit 0744a3ee37784dfda0025963716a36c3f1e3adcc
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Dec 20 10:37:50 2010 +0000

    ARM: platform fixups: remove mdesc argument to fixup function
    
    Get rid of the mdesc pointer in the fixup function call.  No one uses
    the mdesc pointer, it shouldn't be modified anyway, and we can't wrap
    it, so let's remove it.
    
    Platform files found by:
    
      $ regexp=$(git grep -h '\.fixup.*=' arch/arm |
                    sed 's!.*= *\([^,]*\),* *!\1!' | sort -u |
                    tr '\n' '|' | sed 's,|$,,;s,|,\\|,g')
      $ git grep $regexp arch/arm
    
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 10fce616e995..93e39a3d2c1e 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -879,7 +879,7 @@ static struct machine_desc * __init setup_machine_tags(unsigned int nr)
 	}
 
 	if (mdesc->fixup)
-		mdesc->fixup(mdesc, tags, &from, &meminfo);
+		mdesc->fixup(tags, &from, &meminfo);
 
 	if (tags->hdr.tag == ATAG_CORE) {
 		if (meminfo.nr_banks != 0)

commit 2ecccf90f2a6d821af4d33f086d59895e5d3bedc
Author: Dave Martin <dave.martin@linaro.org>
Date:   Fri Aug 19 17:58:35 2011 +0100

    ARM: 7029/1: Make cpu_architecture into a global variable
    
    The CPU architecture really should not be changing at runtime, so
    make it a global variable instead of a function.
    
    The cpu_architecture() function declared in <asm/system.h> remains
    the correct way to read this variable from C code.
    
    Signed-off-by: Dave Martin <dave.martin@linaro.org>
    Reviewed-by: Jon Medhurst <tixy@yxit.co.uk>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index e514c76043b4..10fce616e995 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -29,6 +29,8 @@
 #include <linux/fs.h>
 #include <linux/proc_fs.h>
 #include <linux/memblock.h>
+#include <linux/bug.h>
+#include <linux/compiler.h>
 
 #include <asm/unified.h>
 #include <asm/cpu.h>
@@ -42,6 +44,7 @@
 #include <asm/cacheflush.h>
 #include <asm/cachetype.h>
 #include <asm/tlbflush.h>
+#include <asm/system.h>
 
 #include <asm/prom.h>
 #include <asm/mach/arch.h>
@@ -115,6 +118,13 @@ struct outer_cache_fns outer_cache __read_mostly;
 EXPORT_SYMBOL(outer_cache);
 #endif
 
+/*
+ * Cached cpu_architecture() result for use by assembler code.
+ * C code should use the cpu_architecture() function instead of accessing this
+ * variable directly.
+ */
+int __cpu_architecture __read_mostly = CPU_ARCH_UNKNOWN;
+
 struct stack {
 	u32 irq[3];
 	u32 abt[3];
@@ -210,7 +220,7 @@ static const char *proc_arch[] = {
 	"?(17)",
 };
 
-int cpu_architecture(void)
+static int __get_cpu_architecture(void)
 {
 	int cpu_arch;
 
@@ -243,6 +253,13 @@ int cpu_architecture(void)
 	return cpu_arch;
 }
 
+int __pure cpu_architecture(void)
+{
+	BUG_ON(__cpu_architecture == CPU_ARCH_UNKNOWN);
+
+	return __cpu_architecture;
+}
+
 static int cpu_has_aliasing_icache(unsigned int arch)
 {
 	int aliasing_icache;
@@ -414,6 +431,7 @@ static void __init setup_processor(void)
 	}
 
 	cpu_name = list->cpu_name;
+	__cpu_architecture = __get_cpu_architecture();
 
 #ifdef MULTI_CPU
 	processor = *list->proc;

commit 4722cd7741c6404f967f7a7b8b666540b6c1663e
Merge: 1db3706b05b1 4fb0d2ea397a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Sep 16 21:45:16 2011 +0100

    Merge branch 'for-rmk' of git://linux-arm.org/linux-2.6-wd into devel-stable
    
    Conflicts:
            arch/arm/mach-imx/mach-cpuimx27.c

commit af6871683e25100813d35b3d802f1ed7b90b9f3a
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Tue Jul 5 22:38:19 2011 -0400

    ARM: remove boot_params from struct machine_desc
    
    Now that there is no more users, we can remove it from the kernel.
    
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 2737ba3f739c..78d197d6ec34 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -821,25 +821,6 @@ static struct machine_desc * __init setup_machine_tags(unsigned int nr)
 		tags = phys_to_virt(__atags_pointer);
 	else if (mdesc->atag_offset)
 		tags = (void *)(PAGE_OFFSET + mdesc->atag_offset);
-	else if (mdesc->boot_params) {
-#ifdef CONFIG_MMU
-		/*
-		 * We still are executing with a minimal MMU mapping created
-		 * with the presumption that the machine default for this
-		 * is located in the first MB of RAM.  Anything else will
-		 * fault and silently hang the kernel at this point.
-		 */
-		if (mdesc->boot_params < PHYS_OFFSET ||
-		    mdesc->boot_params >= PHYS_OFFSET + SZ_1M) {
-			printk(KERN_WARNING
-			       "Default boot params at physical 0x%08lx out of reach\n",
-			       mdesc->boot_params);
-		} else
-#endif
-		{
-			tags = phys_to_virt(mdesc->boot_params);
-		}
-	}
 
 #if defined(CONFIG_DEPRECATED_PARAM_STRUCT)
 	/*

commit 2bb9839e312ed55a6d5824ffa6077ce3d7d63b1e
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Tue Jul 5 22:38:10 2011 -0400

    ARM: introduce atag_offset to replace boot_params
    
    The boot_params member of the mdesc structure is used to provide a
    default physical address for the ATAG list.  Since this value is fixed
    at compile time and sometimes based on constants such as ARCH_PHYS_OFFSET,
    it gets in the way of runtime PHYS_OFFSET and CONFIG_ARM_PATCH_PHYS_VIRT
    usage.
    
    Let's introduce atag_offset which should contains only the relative
    offset from PHYS_OFFSET instead of an absolute value, in preparation
    to move all instance of boot_params over to it.
    
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Tested-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Tested-by: Petr Štetiar <ynezz@true.cz>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 70bca649e925..2737ba3f739c 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -819,6 +819,8 @@ static struct machine_desc * __init setup_machine_tags(unsigned int nr)
 
 	if (__atags_pointer)
 		tags = phys_to_virt(__atags_pointer);
+	else if (mdesc->atag_offset)
+		tags = (void *)(PAGE_OFFSET + mdesc->atag_offset);
 	else if (mdesc->boot_params) {
 #ifdef CONFIG_MMU
 		/*

commit 72dc53acd50db066a5a5ebe1f39fae73d7e62aa8
Author: Will Deacon <will.deacon@arm.com>
Date:   Wed Aug 3 12:37:04 2011 +0100

    ARM: cache: detect VIPT aliasing I-cache on ARMv6
    
    The current cache detection code does not check for an aliasing
    I-cache if the D-cache is found to be VIPT aliasing.
    
    This patch fixes the problem by always checking for an aliasing
    I-cache on v6 and later.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 70bca649e925..e514c76043b4 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -280,18 +280,19 @@ static void __init cacheid_init(void)
 	if (arch >= CPU_ARCH_ARMv6) {
 		if ((cachetype & (7 << 29)) == 4 << 29) {
 			/* ARMv7 register format */
+			arch = CPU_ARCH_ARMv7;
 			cacheid = CACHEID_VIPT_NONALIASING;
 			if ((cachetype & (3 << 14)) == 1 << 14)
 				cacheid |= CACHEID_ASID_TAGGED;
-			else if (cpu_has_aliasing_icache(CPU_ARCH_ARMv7))
-				cacheid |= CACHEID_VIPT_I_ALIASING;
-		} else if (cachetype & (1 << 23)) {
-			cacheid = CACHEID_VIPT_ALIASING;
 		} else {
-			cacheid = CACHEID_VIPT_NONALIASING;
-			if (cpu_has_aliasing_icache(CPU_ARCH_ARMv6))
-				cacheid |= CACHEID_VIPT_I_ALIASING;
+			arch = CPU_ARCH_ARMv6;
+			if (cachetype & (1 << 23))
+				cacheid = CACHEID_VIPT_ALIASING;
+			else
+				cacheid = CACHEID_VIPT_NONALIASING;
 		}
+		if (cpu_has_aliasing_icache(arch))
+			cacheid |= CACHEID_VIPT_I_ALIASING;
 	} else {
 		cacheid = CACHEID_VIVT;
 	}

commit 3ad55155b222f2a901405dea20ff7c68828ecd92
Merge: 06f365acef5c 6645cb61f3a1
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Jul 22 23:09:07 2011 +0100

    Merge branch 'devel-stable' into for-next
    
    Conflicts:
            arch/arm/kernel/entry-armv.S

commit 06f365acef5ca54fd5708a0d853c4a89609536f1
Merge: 4348810a241a 022ae537b23c 30891c90d811 e7d59db91a34 e2f81844efa2 4cde7e0dca98 7f294e4983b6 29cb3cd208dd 19dad35fe0f1
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Jul 22 23:08:48 2011 +0100

    Merge branches 'btc', 'dma', 'entry', 'fixes', 'linker-layout', 'misc', 'mmci', 'suspend' and 'vfp' into for-next

commit 07f1c295de593ec0b0dca3092299c048c03374da
Merge: 4aa96ccf9ee3 fb89fcfb1516
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Jul 18 23:00:42 2011 +0100

    Merge branch 'dma' of http://git.linaro.org/git/people/nico/linux into devel-stable

commit 4fddcaebb9014b4814f859420595cc419400fba6
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Tue Jul 5 22:28:08 2011 -0400

    ARM: add dma_zone_size to the machine_desc structure
    
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index ed11fb08b05a..e0db84d7e384 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -916,6 +916,12 @@ void __init setup_arch(char **cmdline_p)
 	cpu_init();
 	tcm_init();
 
+#ifdef CONFIG_ZONE_DMA
+	if (mdesc->dma_zone_size) {
+		extern unsigned long arm_dma_zone_size;
+		arm_dma_zone_size = mdesc->dma_zone_size;
+	}
+#endif
 #ifdef CONFIG_MULTI_IRQ_HANDLER
 	handle_arch_irq = mdesc->handle_irq;
 #endif

commit 4aa96ccf9ee35cdbd0d423e87a4d551019570218
Merge: cb5fd904f0f1 8f2ffa00fb3c
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Jul 15 10:06:42 2011 +0100

    Merge branch 'kprobes-thumb' of git://git.yxit.co.uk/linux into devel-stable

commit 254cdf8ec39653d19cce71b6622f38a6b62ac3a8
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Jun 3 14:15:22 2011 +0100

    ARM: hwcaps: add new HWCAP defines for ARMv7-A
    
    Modern ARMv7-A cores can optionally implement these new hardware
    features:
    
    - VFPv4:
        The latest version of the ARMv7 vector floating-point extensions,
        including hardware support for fused multiple accumulate. D16 or D32
        variants may be implemented.
    
    - Integer divide:
        The SDIV and UDIV instructions provide signed and unsigned integer
        division in hardware. When implemented, these instructions may be
        available in either both Thumb and ARM, or Thumb only.
    
    This patch adds new HWCAP defines to describe these new features. The
    integer divide capabilities are split into two bits for ARM and Thumb
    respectively. Whilst HWCAP_IDIVA should never be set if HWCAP_IDIVT is
    clear, separating the bits makes it easier to interpret from userspace.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index ed11fb08b05a..699df68fc840 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -977,6 +977,10 @@ static const char *hwcap_str[] = {
 	"neon",
 	"vfpv3",
 	"vfpv3d16",
+	"tls",
+	"vfpv4",
+	"idiva",
+	"idivt",
 	NULL
 };
 

commit 0371d3f7e8f1cddaee1f215e42c09a40e235d810
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jul 5 19:58:29 2011 +0100

    ARM: move memory layout sanity checking before meminfo initialization
    
    Ensure that the meminfo array is sanity checked before we pass the
    memory to memblock.  This helps to ensure that memblock and meminfo
    agree on the dimensions of memory, especially when more memory is
    passed than the kernel can deal with.
    
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index ed11fb08b05a..acbb447ac6b5 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -73,6 +73,7 @@ __setup("fpe=", fpe_setup);
 #endif
 
 extern void paging_init(struct machine_desc *desc);
+extern void sanity_check_meminfo(void);
 extern void reboot_setup(char *str);
 
 unsigned int processor_id;
@@ -900,6 +901,7 @@ void __init setup_arch(char **cmdline_p)
 
 	parse_early_param();
 
+	sanity_check_meminfo();
 	arm_memblock_init(&meminfo, mdesc);
 
 	paging_init(mdesc);

commit b69874e4f530b0103e507f695c010d00cb85a4df
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jun 21 18:57:31 2011 +0100

    ARM: pm: arrange for cpu_proc_init() to be called on resume
    
    cpu_proc_init() does processor specific initialization, which we do
    at boot time.  We have been omitting to do this on resume, which
    causes some of this initialization to be skipped.  We've also been
    skipping this on SMP initialization too.
    
    Ensure that cpu_proc_init() is always called appropriately by
    moving it into cpu_init(), and move cpu_init() to a more appropriate
    point in the boot initialization.
    
    Tested-by: Kevin Hilman <khilman@ti.com>
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index ed11fb08b05a..edcab02be64c 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -342,54 +342,6 @@ static void __init feat_v6_fixup(void)
 		elf_hwcap &= ~HWCAP_TLS;
 }
 
-static void __init setup_processor(void)
-{
-	struct proc_info_list *list;
-
-	/*
-	 * locate processor in the list of supported processor
-	 * types.  The linker builds this table for us from the
-	 * entries in arch/arm/mm/proc-*.S
-	 */
-	list = lookup_processor_type(read_cpuid_id());
-	if (!list) {
-		printk("CPU configuration botched (ID %08x), unable "
-		       "to continue.\n", read_cpuid_id());
-		while (1);
-	}
-
-	cpu_name = list->cpu_name;
-
-#ifdef MULTI_CPU
-	processor = *list->proc;
-#endif
-#ifdef MULTI_TLB
-	cpu_tlb = *list->tlb;
-#endif
-#ifdef MULTI_USER
-	cpu_user = *list->user;
-#endif
-#ifdef MULTI_CACHE
-	cpu_cache = *list->cache;
-#endif
-
-	printk("CPU: %s [%08x] revision %d (ARMv%s), cr=%08lx\n",
-	       cpu_name, read_cpuid_id(), read_cpuid_id() & 15,
-	       proc_arch[cpu_architecture()], cr_alignment);
-
-	sprintf(init_utsname()->machine, "%s%c", list->arch_name, ENDIANNESS);
-	sprintf(elf_platform, "%s%c", list->elf_name, ENDIANNESS);
-	elf_hwcap = list->elf_hwcap;
-#ifndef CONFIG_ARM_THUMB
-	elf_hwcap &= ~HWCAP_THUMB;
-#endif
-
-	feat_v6_fixup();
-
-	cacheid_init();
-	cpu_proc_init();
-}
-
 /*
  * cpu_init - initialise one CPU.
  *
@@ -405,6 +357,8 @@ void cpu_init(void)
 		BUG();
 	}
 
+	cpu_proc_init();
+
 	/*
 	 * Define the placement constraint for the inline asm directive below.
 	 * In Thumb-2, msr with an immediate value is not allowed.
@@ -441,6 +395,54 @@ void cpu_init(void)
 	    : "r14");
 }
 
+static void __init setup_processor(void)
+{
+	struct proc_info_list *list;
+
+	/*
+	 * locate processor in the list of supported processor
+	 * types.  The linker builds this table for us from the
+	 * entries in arch/arm/mm/proc-*.S
+	 */
+	list = lookup_processor_type(read_cpuid_id());
+	if (!list) {
+		printk("CPU configuration botched (ID %08x), unable "
+		       "to continue.\n", read_cpuid_id());
+		while (1);
+	}
+
+	cpu_name = list->cpu_name;
+
+#ifdef MULTI_CPU
+	processor = *list->proc;
+#endif
+#ifdef MULTI_TLB
+	cpu_tlb = *list->tlb;
+#endif
+#ifdef MULTI_USER
+	cpu_user = *list->user;
+#endif
+#ifdef MULTI_CACHE
+	cpu_cache = *list->cache;
+#endif
+
+	printk("CPU: %s [%08x] revision %d (ARMv%s), cr=%08lx\n",
+	       cpu_name, read_cpuid_id(), read_cpuid_id() & 15,
+	       proc_arch[cpu_architecture()], cr_alignment);
+
+	sprintf(init_utsname()->machine, "%s%c", list->arch_name, ENDIANNESS);
+	sprintf(elf_platform, "%s%c", list->elf_name, ENDIANNESS);
+	elf_hwcap = list->elf_hwcap;
+#ifndef CONFIG_ARM_THUMB
+	elf_hwcap &= ~HWCAP_THUMB;
+#endif
+
+	feat_v6_fixup();
+
+	cacheid_init();
+	cpu_init();
+}
+
 void __init dump_machine_table(void)
 {
 	struct machine_desc *p;
@@ -913,7 +915,6 @@ void __init setup_arch(char **cmdline_p)
 #endif
 	reserve_crashkernel();
 
-	cpu_init();
 	tcm_init();
 
 #ifdef CONFIG_MULTI_IRQ_HANDLER

commit 03eb14199e8a2ff2bc170b283305990151b0d619
Merge: d762f4383100 ede338f4ce2f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed May 25 00:08:17 2011 +0100

    Merge branch 'devicetree/arm-next' of git://git.secretlab.ca/git/linux-2.6 into devel-stable

commit 93c02ab40ae6e06cb24d14845d9f008fdd24f43d
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Apr 28 14:27:21 2011 -0600

    arm/dt: probe for platforms via the device tree
    
    If a dtb is passed to the kernel then the kernel needs to iterate
    through compiled-in mdescs looking for one that matches and move the
    dtb data to a safe location before it gets accidentally overwritten by
    the kernel.
    
    This patch creates a new function, setup_machine_fdt() which is
    analogous to the setup_machine_atags() created in the previous patch.
    It does all the early setup needed to use a device tree machine
    description.
    
    v5: - Print warning with neither dtb nor atags are passed to the kernel
        - Fix bug in setting of __machine_arch_type to the selected machine,
          not just the last machine in the list.
          Reported-by: Tixy <tixy@yxit.co.uk>
        - Copy command line directly into boot_command_line instead of cmd_line
    v4: - Dump some output when a matching machine_desc cannot be found
    v3: - Added processing of reserved list.
        - Backed out the v2 change that copied instead of reserved the
          dtb.  dtb is reserved again and the real problem was fixed by
          using alloc_bootmem_align() for early allocation of RAM for
          unflattening the tree.
        - Moved cmd_line and initrd changes to earlier patch to make series
          bisectable.
    v2: Changed to save the dtb by copying into an allocated buffer.
        - Since the dtb will very likely be passed in the first 16k of ram
          where the interrupt vectors live, memblock_reserve() is
          insufficient to protect the dtb data.
    
    [based on work originally written by Jeremy Kerr <jeremy.kerr@canonical.com>]
    Tested-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 42c2f0cedf1b..05db25ef3dd5 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -20,6 +20,7 @@
 #include <linux/screen_info.h>
 #include <linux/init.h>
 #include <linux/kexec.h>
+#include <linux/of_fdt.h>
 #include <linux/crash_dump.h>
 #include <linux/root_dev.h>
 #include <linux/cpu.h>
@@ -42,6 +43,7 @@
 #include <asm/cachetype.h>
 #include <asm/tlbflush.h>
 
+#include <asm/prom.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/irq.h>
 #include <asm/mach/time.h>
@@ -309,7 +311,7 @@ static void __init cacheid_init(void)
  */
 extern struct proc_info_list *lookup_processor_type(unsigned int);
 
-static void __init early_print(const char *str, ...)
+void __init early_print(const char *str, ...)
 {
 	extern void printascii(const char *);
 	char buf[256];
@@ -439,7 +441,7 @@ void cpu_init(void)
 	    : "r14");
 }
 
-static void __init dump_machine_table(void)
+void __init dump_machine_table(void)
 {
 	struct machine_desc *p;
 
@@ -837,8 +839,17 @@ static struct machine_desc * __init setup_machine_tags(unsigned int nr)
 	if (tags->hdr.tag != ATAG_CORE)
 		convert_to_tag_list(tags);
 #endif
-	if (tags->hdr.tag != ATAG_CORE)
+
+	if (tags->hdr.tag != ATAG_CORE) {
+#if defined(CONFIG_OF)
+		/*
+		 * If CONFIG_OF is set, then assume this is a reasonably
+		 * modern system that should pass boot parameters
+		 */
+		early_print("Warning: Neither atags nor dtb found\n");
+#endif
 		tags = (struct tag *)&init_tags;
+	}
 
 	if (mdesc->fixup)
 		mdesc->fixup(mdesc, tags, &from, &meminfo);
@@ -864,7 +875,9 @@ void __init setup_arch(char **cmdline_p)
 	unwind_init();
 
 	setup_processor();
-	mdesc = setup_machine_tags(machine_arch_type);
+	mdesc = setup_machine_fdt(__atags_pointer);
+	if (!mdesc)
+		mdesc = setup_machine_tags(machine_arch_type);
 	machine_desc = mdesc;
 	machine_name = mdesc->name;
 
@@ -887,6 +900,8 @@ void __init setup_arch(char **cmdline_p)
 	paging_init(mdesc);
 	request_standard_resources(mdesc);
 
+	unflatten_device_tree();
+
 #ifdef CONFIG_SMP
 	if (is_smp())
 		smp_init_cpus();

commit 6291319d4864848efc7b5d81389e2404fb478cb9
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Apr 28 14:27:21 2011 -0600

    arm/dt: consolidate atags setup into setup_machine_atags
    
    In preparation for adding device tree support, this patch consolidates
    all of the atag-specific setup into a single function.
    
    v5: - drop double printk("Machine; %s\n", ...); call.
        - leave copying boot_command_line in setup_arch() since it isn't
          atags specific.
    v4: - adapt to the removal of lookup_machine_type()
        - break out dump of machine_desc table into dump_machine_table()
          because the device tree probe code will use it.
        - Add for_each_machine_desc() macro
    
    Tested-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 109997e3fe4a..42c2f0cedf1b 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -439,25 +439,12 @@ void cpu_init(void)
 	    : "r14");
 }
 
-static struct machine_desc * __init setup_machine(unsigned int nr)
+static void __init dump_machine_table(void)
 {
-	extern struct machine_desc __arch_info_begin[], __arch_info_end[];
 	struct machine_desc *p;
 
-	/*
-	 * locate machine in the list of supported machines.
-	 */
-	for (p = __arch_info_begin; p < __arch_info_end; p++)
-		if (nr == p->nr) {
-			printk("Machine: %s\n", p->name);
-			return p;
-		}
-
-	early_print("\n"
-		"Error: unrecognized/unsupported machine ID (r1 = 0x%08x).\n\n"
-		"Available machine support:\n\nID (hex)\tNAME\n", nr);
-
-	for (p = __arch_info_begin; p < __arch_info_end; p++)
+	early_print("Available machine support:\n\nID (hex)\tNAME\n");
+	for_each_machine_desc(p)
 		early_print("%08x\t%s\n", p->nr, p->name);
 
 	early_print("\nPlease check your kernel config and/or bootloader.\n");
@@ -796,23 +783,29 @@ static void __init squash_mem_tags(struct tag *tag)
 			tag->hdr.tag = ATAG_NONE;
 }
 
-void __init setup_arch(char **cmdline_p)
+static struct machine_desc * __init setup_machine_tags(unsigned int nr)
 {
 	struct tag *tags = (struct tag *)&init_tags;
-	struct machine_desc *mdesc;
+	struct machine_desc *mdesc = NULL, *p;
 	char *from = default_command_line;
 
 	init_tags.mem.start = PHYS_OFFSET;
 
-	unwind_init();
-
-	setup_processor();
-	mdesc = setup_machine(machine_arch_type);
-	machine_desc = mdesc;
-	machine_name = mdesc->name;
+	/*
+	 * locate machine in the list of supported machines.
+	 */
+	for_each_machine_desc(p)
+		if (nr == p->nr) {
+			printk("Machine: %s\n", p->name);
+			mdesc = p;
+			break;
+		}
 
-	if (mdesc->soft_reboot)
-		reboot_setup("s");
+	if (!mdesc) {
+		early_print("\nError: unrecognized/unsupported machine ID"
+			" (r1 = 0x%08x).\n\n", nr);
+		dump_machine_table(); /* does not return */
+	}
 
 	if (__atags_pointer)
 		tags = phys_to_virt(__atags_pointer);
@@ -857,14 +850,32 @@ void __init setup_arch(char **cmdline_p)
 		parse_tags(tags);
 	}
 
+	/* parse_early_param needs a boot_command_line */
+	strlcpy(boot_command_line, from, COMMAND_LINE_SIZE);
+
+	return mdesc;
+}
+
+
+void __init setup_arch(char **cmdline_p)
+{
+	struct machine_desc *mdesc;
+
+	unwind_init();
+
+	setup_processor();
+	mdesc = setup_machine_tags(machine_arch_type);
+	machine_desc = mdesc;
+	machine_name = mdesc->name;
+
+	if (mdesc->soft_reboot)
+		reboot_setup("s");
+
 	init_mm.start_code = (unsigned long) _text;
 	init_mm.end_code   = (unsigned long) _etext;
 	init_mm.end_data   = (unsigned long) _edata;
 	init_mm.brk	   = (unsigned long) _end;
 
-	/* parse_early_param needs a boot_command_line */
-	strlcpy(boot_command_line, from, COMMAND_LINE_SIZE);
-
 	/* populate cmd_line too for later use, preserving boot_command_line */
 	strlcpy(cmd_line, boot_command_line, COMMAND_LINE_SIZE);
 	*cmdline_p = cmd_line;

commit 4394c1244249198c6b85093d46935b761b36ae05
Author: Victor Boivie <victor.boivie@sonyericsson.com>
Date:   Wed May 4 17:07:55 2011 +0100

    ARM: 6893/1: Allow for kernel command line concatenation
    
    This patch allows the provided CONFIG_CMDLINE to be concatenated
    with the one provided by the boot loader. This is useful to
    merge the static values defined in CONFIG_CMDLINE with the
    boot loader's (possibly) more dynamic values, such as startup
    reasons and more.
    
    Signed-off-by: Victor Boivie <victor.boivie@sonyericsson.com>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@sonyericsson.com>
    Signed-off-by: Oskar Andero <oskar.andero@sonyericsson.com>
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Acked-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 006c1e884eaf..6dce209a623b 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -672,11 +672,16 @@ __tagtable(ATAG_REVISION, parse_tag_revision);
 
 static int __init parse_tag_cmdline(const struct tag *tag)
 {
-#ifndef CONFIG_CMDLINE_FORCE
-	strlcpy(default_command_line, tag->u.cmdline.cmdline, COMMAND_LINE_SIZE);
-#else
+#if defined(CONFIG_CMDLINE_EXTEND)
+	strlcat(default_command_line, " ", COMMAND_LINE_SIZE);
+	strlcat(default_command_line, tag->u.cmdline.cmdline,
+		COMMAND_LINE_SIZE);
+#elif defined(CONFIG_CMDLINE_FORCE)
 	pr_warning("Ignoring tag cmdline (using the default kernel command line)\n");
-#endif /* CONFIG_CMDLINE_FORCE */
+#else
+	strlcpy(default_command_line, tag->u.cmdline.cmdline,
+		COMMAND_LINE_SIZE);
+#endif
 	return 0;
 }
 

commit 9eb8f6743b076b67f00776cda4330c802e157b41
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Apr 28 14:27:20 2011 -0600

    arm/dt: Allow CONFIG_OF on ARM
    
    Add some basic empty infrastructure for DT support on ARM.
    
    v5: - Fix off-by-one error in size calculation of initrd
        - Stop mucking with cmd_line, and load command line from dt into
          boot_command_line instead which matches the behaviour of ATAGS booting
    v3: - moved cmd_line export and initrd setup to this patch to make the
          series bisectable.
        - switched to alloc_bootmem_align() for allocation when
          unflattening the device tree.  memblock_alloc() was not the
          right interface.
    
    Signed-off-by: Jeremy Kerr <jeremy.kerr@canonical.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 006c1e884eaf..109997e3fe4a 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -466,7 +466,7 @@ static struct machine_desc * __init setup_machine(unsigned int nr)
 		/* can't use cpu_relax() here as it may require MMU setup */;
 }
 
-static int __init arm_add_memory(phys_addr_t start, unsigned long size)
+int __init arm_add_memory(phys_addr_t start, unsigned long size)
 {
 	struct membank *bank = &meminfo.bank[meminfo.nr_banks];
 

commit 2f284c846331fa44be1300a3c2c3e85800268a00
Merge: 93a72052be81 6f82f4db8018
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 23 20:37:26 2011 -0700

    Merge branch 'devel' of master.kernel.org:/home/rmk/linux-2.6-arm
    
    * 'devel' of master.kernel.org:/home/rmk/linux-2.6-arm: (35 commits)
      ARM: Update (and cut down) mach-types
      ARM: 6771/1: vexpress: add support for multiple core tiles
      ARM: 6797/1: hw_breakpoint: Fix newlines in WARNings
      ARM: 6751/1: vexpress: select applicable errata workarounds in Kconfig
      ARM: 6753/1: omap4: Enable ARM local timers with OMAP4430 es1.0 exception
      ARM: 6759/1: smp: Select local timers vs broadcast timer support runtime
      ARM: pgtable: add pud-level code
      ARM: 6673/1: LPAE: use phys_addr_t instead of unsigned long for start of membanks
      ARM: Use long long format when printing meminfo physical addresses
      ARM: integrator: add Integrator/CP sched_clock support
      ARM: realview/vexpress: consolidate SMP bringup code
      ARM: realview/vexpress: consolidate localtimer support
      ARM: integrator/versatile: consolidate FPGA IRQ handling code
      ARM: rationalize versatile family Kconfig/Makefile
      ARM: realview: remove old AMBA device DMA definitions
      ARM: versatile: remove old AMBA device DMA definitions
      ARM: vexpress: use new init_early for clock tree and sched_clock init
      ARM: realview: use new init_early for clock tree and sched_clock init
      ARM: versatile: use new init_early for clock tree and sched_clock init
      ARM: integrator: use new init_early for clock tree init
      ...

commit 93a72052be81823fa1584b9be037d51924f9efa4
Author: Olaf Hering <olaf@aepfle.de>
Date:   Wed Mar 23 16:43:29 2011 -0700

    crash_dump: export is_kdump_kernel to modules, consolidate elfcorehdr_addr, setup_elfcorehdr and saved_max_pfn
    
    The Xen PV drivers in a crashed HVM guest can not connect to the dom0
    backend drivers because both frontend and backend drivers are still in
    connected state.  To run the connection reset function only in case of a
    crashdump, the is_kdump_kernel() function needs to be available for the PV
    driver modules.
    
    Consolidate elfcorehdr_addr, setup_elfcorehdr and saved_max_pfn into
    kernel/crash_dump.c Also export elfcorehdr_addr to make is_kdump_kernel()
    usable for modules.
    
    Leave 'elfcorehdr' as early_param().  This changes powerpc from __setup()
    to early_param().  It adds an address range check from x86 also on ia64
    and powerpc.
    
    [akpm@linux-foundation.org: additional #includes]
    [akpm@linux-foundation.org: remove elfcorehdr_addr export]
    [akpm@linux-foundation.org: fix for Tejun's mm/nobootmem.c changes]
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index d1da92174277..c36c1a4250f3 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -788,30 +788,6 @@ static void __init reserve_crashkernel(void)
 static inline void reserve_crashkernel(void) {}
 #endif /* CONFIG_KEXEC */
 
-/*
- * Note: elfcorehdr_addr is not just limited to vmcore. It is also used by
- * is_kdump_kernel() to determine if we are booting after a panic. Hence
- * ifdef it under CONFIG_CRASH_DUMP and not CONFIG_PROC_VMCORE.
- */
-
-#ifdef CONFIG_CRASH_DUMP
-/*
- * elfcorehdr= specifies the location of elf core header stored by the crashed
- * kernel. This option will be passed by kexec loader to the capture kernel.
- */
-static int __init setup_elfcorehdr(char *arg)
-{
-	char *end;
-
-	if (!arg)
-		return -EINVAL;
-
-	elfcorehdr_addr = memparse(arg, &end);
-	return end > arg ? 0 : -EINVAL;
-}
-early_param("elfcorehdr", setup_elfcorehdr);
-#endif /* CONFIG_CRASH_DUMP */
-
 static void __init squash_mem_tags(struct tag *tag)
 {
 	for (; tag->hdr.size; tag = tag_next(tag))

commit 196f020fbbb83d246960548e73a40fd08f3e7866
Merge: 6d7ed21d17e6 7d85d61f6ad6 516295e5ab4b 3de4ade3d696
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Mar 20 09:32:12 2011 +0000

    Merge branches 'fixes', 'pgt-next' and 'versatile' into devel

commit 05e34754518b6a90d5c392790c032575fab12d66
Merge: bd1274dc005c b511d75d6150
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Mar 16 23:35:27 2011 +0000

    Merge branch 'p2v' into devel
    
    Conflicts:
            arch/arm/kernel/module.c
            arch/arm/mach-s5pv210/sleep.S

commit 1f0090a1eaa1b750a2fc5c99c91b790d5322a1fd
Merge: 2472f3c8d8fc 10a8c3839810
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Mar 16 23:35:25 2011 +0000

    Merge branch 'misc' into devel
    
    Conflicts:
            arch/arm/Kconfig

commit 3572bea8cbc57f0bef1e0f4580c01717df7026d8
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Mon Feb 21 06:57:33 2011 +0100

    ARM: 6748/1: ignore mdesc->boot_params if out of range
    
    The initial MMU table created in head.S contains a 1 MB mapping at the
    start of memory to let the early kernel boot code access the boot params
    specified by mdesc->boot_params.
    
    When using CONFIG_ARM_PATCH_PHYS_VIRT it is possible for the kernel to
    have a different idea of where the start of memory is at run time, making
    the compile-time determined mdesc->boot_params pointing to a memory area
    which is not mapped.  Any access to the boot params in that case will
    fault and silently hang the kernel at that point.  It is therefore a
    better idea to simply ignore mdesc->boot_params in that case and give
    the kernel a chance to print some diagnostic on the console later.
    
    If the bootloader provides a valid pointer in r2 to the kernel then this
    is used instead of mdesc->boot_params, and an explicit mapping is already
    created in the initial MMU table for it.  It is therefore a good idea to
    use that facility when using a relocated kernel.
    
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 6ce80106316e..f43f041a0977 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -839,8 +839,25 @@ void __init setup_arch(char **cmdline_p)
 
 	if (__atags_pointer)
 		tags = phys_to_virt(__atags_pointer);
-	else if (mdesc->boot_params)
-		tags = phys_to_virt(mdesc->boot_params);
+	else if (mdesc->boot_params) {
+#ifdef CONFIG_MMU
+		/*
+		 * We still are executing with a minimal MMU mapping created
+		 * with the presumption that the machine default for this
+		 * is located in the first MB of RAM.  Anything else will
+		 * fault and silently hang the kernel at this point.
+		 */
+		if (mdesc->boot_params < PHYS_OFFSET ||
+		    mdesc->boot_params >= PHYS_OFFSET + SZ_1M) {
+			printk(KERN_WARNING
+			       "Default boot params at physical 0x%08lx out of reach\n",
+			       mdesc->boot_params);
+		} else
+#endif
+		{
+			tags = phys_to_virt(mdesc->boot_params);
+		}
+	}
 
 #if defined(CONFIG_DEPRECATED_PARAM_STRUCT)
 	/*

commit dce72dd08c976c9e5e1367bf994b306b15ae87fe
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Mon Feb 21 07:00:32 2011 +0100

    ARM: 6749/1: fold lookup_machine_type() into setup_machine()
    
    Since commit 6fc31d54 there is no callers for lookup_machine_type()
    other than setup_machine(). And if the former fails it won't return,
    therefore the error path in the later is dead code.  Let's clean
    things up by merging them together.
    
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 056bf1878f8a..6ce80106316e 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -325,28 +325,6 @@ static void __init early_print(const char *str, ...)
 	printk("%s", buf);
 }
 
-static struct machine_desc * __init lookup_machine_type(unsigned int type)
-{
-	extern struct machine_desc __arch_info_begin[], __arch_info_end[];
-	struct machine_desc *p;
-
-	for (p = __arch_info_begin; p < __arch_info_end; p++)
-		if (type == p->nr)
-			return p;
-
-	early_print("\n"
-		"Error: unrecognized/unsupported machine ID (r1 = 0x%08x).\n\n"
-		"Available machine support:\n\nID (hex)\tNAME\n", type);
-
-	for (p = __arch_info_begin; p < __arch_info_end; p++)
-		early_print("%08x\t%s\n", p->nr, p->name);
-
-	early_print("\nPlease check your kernel config and/or bootloader.\n");
-
-	while (true)
-		/* can't use cpu_relax() here as it may require MMU setup */;
-}
-
 static void __init feat_v6_fixup(void)
 {
 	int id = read_cpuid_id();
@@ -463,21 +441,29 @@ void cpu_init(void)
 
 static struct machine_desc * __init setup_machine(unsigned int nr)
 {
-	struct machine_desc *list;
+	extern struct machine_desc __arch_info_begin[], __arch_info_end[];
+	struct machine_desc *p;
 
 	/*
 	 * locate machine in the list of supported machines.
 	 */
-	list = lookup_machine_type(nr);
-	if (!list) {
-		printk("Machine configuration botched (nr %d), unable "
-		       "to continue.\n", nr);
-		while (1);
-	}
+	for (p = __arch_info_begin; p < __arch_info_end; p++)
+		if (nr == p->nr) {
+			printk("Machine: %s\n", p->name);
+			return p;
+		}
 
-	printk("Machine: %s\n", list->name);
+	early_print("\n"
+		"Error: unrecognized/unsupported machine ID (r1 = 0x%08x).\n\n"
+		"Available machine support:\n\nID (hex)\tNAME\n", nr);
+
+	for (p = __arch_info_begin; p < __arch_info_end; p++)
+		early_print("%08x\t%s\n", p->nr, p->name);
 
-	return list;
+	early_print("\nPlease check your kernel config and/or bootloader.\n");
+
+	while (true)
+		/* can't use cpu_relax() here as it may require MMU setup */;
 }
 
 static int __init arm_add_memory(unsigned long start, unsigned long size)

commit f60892d3e36dcdd0d9f30db05beae7a446a93f28
Author: Will Deacon <will.deacon@arm.com>
Date:   Tue Feb 15 12:44:10 2011 +0100

    ARM: 6673/1: LPAE: use phys_addr_t instead of unsigned long for start of membanks
    
    The unsigned long datatype is not sufficient for mapping physical addresses
    >= 4GB.
    
    This patch ensures that the phys_addr_t datatype is used to represent
    the start address of a membank, which may reside above the 4GB boundary.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 77af580953e6..9d4a84402ae9 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -442,7 +442,7 @@ static struct machine_desc * __init setup_machine(unsigned int nr)
 	return list;
 }
 
-static int __init arm_add_memory(unsigned long start, unsigned long size)
+static int __init arm_add_memory(phys_addr_t start, unsigned long size)
 {
 	struct membank *bank = &meminfo.bank[meminfo.nr_banks];
 
@@ -478,7 +478,8 @@ static int __init arm_add_memory(unsigned long start, unsigned long size)
 static int __init early_mem(char *p)
 {
 	static int usermem __initdata = 0;
-	unsigned long size, start;
+	unsigned long size;
+	phys_addr_t start;
 	char *endp;
 
 	/*

commit 315cfe7835c9a3fe27f15519bdeee8bf0a293e33
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Tue Feb 15 18:06:57 2011 +0100

    ARM: 6676/1: Correct the cpu_architecture() function for ARMv7
    
    If ID_MMFR0[3:0] >= 3, the architecture version is ARMv7. The code was
    currently only testing for ID_MMFR0[3:0] == 3.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 420b8d6485d6..5ea4fb718b97 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -226,8 +226,8 @@ int cpu_architecture(void)
 		 * Register 0 and check for VMSAv7 or PMSAv7 */
 		asm("mrc	p15, 0, %0, c0, c1, 4"
 		    : "=r" (mmfr0));
-		if ((mmfr0 & 0x0000000f) == 0x00000003 ||
-		    (mmfr0 & 0x000000f0) == 0x00000030)
+		if ((mmfr0 & 0x0000000f) >= 0x00000003 ||
+		    (mmfr0 & 0x000000f0) >= 0x00000030)
 			cpu_arch = CPU_ARCH_ARMv7;
 		else if ((mmfr0 & 0x0000000f) == 0x00000002 ||
 			 (mmfr0 & 0x000000f0) == 0x00000020)

commit b75c178afaa975896e894bb2b6951dc4cd43c977
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Jan 4 19:03:16 2011 +0000

    ARM: P2V: avoid initializers and assembly using PHYS_OFFSET
    
    As PHYS_OFFSET will be becoming a variable, we can't have it used in
    initializers nor assembly code.  Replace those in generic code with
    a run-time initialization.  Replace those in platform code using the
    individual platform specific PLAT_PHYS_OFFSET.
    
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Acked-by: David Brown <davidb@codeaurora.org>
    Acked-by: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 78678b07901c..056bf1878f8a 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -740,7 +740,7 @@ static struct init_tags {
 	{ tag_size(tag_core), ATAG_CORE },
 	{ 1, PAGE_SIZE, 0xff },
 	{ tag_size(tag_mem32), ATAG_MEM },
-	{ MEM_SIZE, PHYS_OFFSET },
+	{ MEM_SIZE },
 	{ 0, ATAG_NONE }
 };
 
@@ -839,6 +839,8 @@ void __init setup_arch(char **cmdline_p)
 	struct machine_desc *mdesc;
 	char *from = default_command_line;
 
+	init_tags.mem.start = PHYS_OFFSET;
+
 	unwind_init();
 
 	setup_processor();

commit 6fc31d54443bdc25a8166be15e3920a7e39d195d
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Jan 12 17:50:42 2011 +0000

    ARM: Defer lookup of machine_type to setup.c
    
    Since the debug macros no longer depend on the machine type information,
    the machine type lookup can be deferred to setup_arch() in setup.c which
    simplifies the code somewhat.
    
    We also move the __error_a functionality into setup.c for displaying a
    message when a bad machine ID is passed to the kernel via the LL debug
    code.  We also log this into the kernel ring buffer which makes it
    possible to retrieve the message via a debugger.
    
    Original idea from Grant Likely.
    
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 420b8d6485d6..78678b07901c 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -308,7 +308,44 @@ static void __init cacheid_init(void)
  * already provide the required functionality.
  */
 extern struct proc_info_list *lookup_processor_type(unsigned int);
-extern struct machine_desc *lookup_machine_type(unsigned int);
+
+static void __init early_print(const char *str, ...)
+{
+	extern void printascii(const char *);
+	char buf[256];
+	va_list ap;
+
+	va_start(ap, str);
+	vsnprintf(buf, sizeof(buf), str, ap);
+	va_end(ap);
+
+#ifdef CONFIG_DEBUG_LL
+	printascii(buf);
+#endif
+	printk("%s", buf);
+}
+
+static struct machine_desc * __init lookup_machine_type(unsigned int type)
+{
+	extern struct machine_desc __arch_info_begin[], __arch_info_end[];
+	struct machine_desc *p;
+
+	for (p = __arch_info_begin; p < __arch_info_end; p++)
+		if (type == p->nr)
+			return p;
+
+	early_print("\n"
+		"Error: unrecognized/unsupported machine ID (r1 = 0x%08x).\n\n"
+		"Available machine support:\n\nID (hex)\tNAME\n", type);
+
+	for (p = __arch_info_begin; p < __arch_info_end; p++)
+		early_print("%08x\t%s\n", p->nr, p->name);
+
+	early_print("\nPlease check your kernel config and/or bootloader.\n");
+
+	while (true)
+		/* can't use cpu_relax() here as it may require MMU setup */;
+}
 
 static void __init feat_v6_fixup(void)
 {

commit 29a38193c15bd72ba96c57a805443ef46ea6a6ac
Author: Will Deacon <will.deacon@arm.com>
Date:   Tue Feb 15 14:31:37 2011 +0100

    ARM: 6674/1: LPAE: use long long format when printing physical addresses and ptes
    
    For the Kernel to support 2 level and 3 level page tables, physical
    addresses (and also page table entries) need to be 32 or 64-bits depending
    upon the configuration.
    
    This patch uses the %08llx conversion specifier for physical addresses
    and page table entries, ensuring that they are cast to (long long) so
    that common code can be used regardless of the datatype widths.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 336f14e0e5c2..77af580953e6 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -448,7 +448,7 @@ static int __init arm_add_memory(unsigned long start, unsigned long size)
 
 	if (meminfo.nr_banks >= NR_BANKS) {
 		printk(KERN_CRIT "NR_BANKS too low, "
-			"ignoring memory at %#lx\n", start);
+			"ignoring memory at 0x%08llx\n", (long long)start);
 		return -EINVAL;
 	}
 

commit 11b9369cbb0a13cabb581aec3e6812a171cf2fd7
Author: Dima Zavin <dima@android.com>
Date:   Fri Jan 14 23:05:14 2011 +0100

    ARM: 6625/1: use memblock memory regions for "System RAM" I/O resources
    
    Do not use memory bank info to request the "system ram" resources as
    they do not track holes created by memblock_remove inside
    machine's reserve callback. If the removed memory is passed as
    platform_device's ioresource, then drivers that call
    request_mem_region would fail due to a conflict with the incorrectly
    configured system ram resource.
    
    Instead, iterate through the regions of memblock.memory and add
    those as "System RAM" resources.
    
    Signed-off-by: Dima Zavin <dima@android.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 7c54e115055b..420b8d6485d6 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -518,25 +518,21 @@ setup_ramdisk(int doload, int prompt, int image_start, unsigned int rd_sz)
 #endif
 }
 
-static void __init
-request_standard_resources(struct meminfo *mi, struct machine_desc *mdesc)
+static void __init request_standard_resources(struct machine_desc *mdesc)
 {
+	struct memblock_region *region;
 	struct resource *res;
-	int i;
 
 	kernel_code.start   = virt_to_phys(_text);
 	kernel_code.end     = virt_to_phys(_etext - 1);
 	kernel_data.start   = virt_to_phys(_sdata);
 	kernel_data.end     = virt_to_phys(_end - 1);
 
-	for (i = 0; i < mi->nr_banks; i++) {
-		if (mi->bank[i].size == 0)
-			continue;
-
+	for_each_memblock(memory, region) {
 		res = alloc_bootmem_low(sizeof(*res));
 		res->name  = "System RAM";
-		res->start = mi->bank[i].start;
-		res->end   = mi->bank[i].start + mi->bank[i].size - 1;
+		res->start = __pfn_to_phys(memblock_region_memory_base_pfn(region));
+		res->end = __pfn_to_phys(memblock_region_memory_end_pfn(region)) - 1;
 		res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
 
 		request_resource(&iomem_resource, res);
@@ -859,7 +855,7 @@ void __init setup_arch(char **cmdline_p)
 	arm_memblock_init(&meminfo, mdesc);
 
 	paging_init(mdesc);
-	request_standard_resources(&meminfo, mdesc);
+	request_standard_resources(mdesc);
 
 #ifdef CONFIG_SMP
 	if (is_smp())

commit 22eeb8f6e0214a83ac6958a29a83572137f174bb
Author: Alexander Holler <holler@ahsoftware.de>
Date:   Wed Jan 12 14:08:37 2011 +0100

    ARM: 6620/1: Change misleading warning when CONFIG_CMDLINE_FORCE is used
    
    When CONFIG_CMDLINE_FORCE is used, the warning
    
      Ignoring unrecognised tag 0x54410009
    
    was displayed. Change this to
    
      Ignoring tag cmdline (using the default kernel command line)
    
    Signed-off-by: Alexander Holler <holler@ahsoftware.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 3455ad33de4c..7c54e115055b 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -650,15 +650,17 @@ static int __init parse_tag_revision(const struct tag *tag)
 
 __tagtable(ATAG_REVISION, parse_tag_revision);
 
-#ifndef CONFIG_CMDLINE_FORCE
 static int __init parse_tag_cmdline(const struct tag *tag)
 {
+#ifndef CONFIG_CMDLINE_FORCE
 	strlcpy(default_command_line, tag->u.cmdline.cmdline, COMMAND_LINE_SIZE);
+#else
+	pr_warning("Ignoring tag cmdline (using the default kernel command line)\n");
+#endif /* CONFIG_CMDLINE_FORCE */
 	return 0;
 }
 
 __tagtable(ATAG_CMDLINE, parse_tag_cmdline);
-#endif /* CONFIG_CMDLINE_FORCE */
 
 /*
  * Scan the tag table for this tag, and call its parse function.

commit dec12e62c03d26bbc7a142f067215a3a43cce7d0
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Dec 16 13:49:34 2010 +0000

    ARM: provide an early platform initialization hook
    
    This allows platforms to hook into the initialization early to setup
    things like scheduler clocks, etc.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index e53132eee27a..3455ad33de4c 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -880,6 +880,9 @@ void __init setup_arch(char **cmdline_p)
 #endif
 #endif
 	early_trap_init();
+
+	if (mdesc->init_early)
+		mdesc->init_early();
 }
 
 

commit 8ff1443c5439ecee7472b80cf12ecfc337e6ee98
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Dec 20 10:18:36 2010 +0000

    ARM: simplify early machine init hooks
    
    Rather than storing each machine init hook separately, store a
    pointer to the machine description record and dereference this
    instead.  This pointer is only available while the init sections
    are present, which is not a problem as we only use it from init
    code.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 0826f36330c4..e53132eee27a 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -126,6 +126,7 @@ EXPORT_SYMBOL(elf_platform);
 static const char *cpu_name;
 static const char *machine_name;
 static char __initdata cmd_line[COMMAND_LINE_SIZE];
+struct machine_desc *machine_desc __initdata;
 
 static char default_command_line[COMMAND_LINE_SIZE] __initdata = CONFIG_CMDLINE;
 static union { char c[4]; unsigned long l; } endian_test __initdata = { { 'l', '?', '?', 'b' } };
@@ -708,13 +709,11 @@ static struct init_tags {
 	{ 0, ATAG_NONE }
 };
 
-static void (*init_machine)(void) __initdata;
-
 static int __init customize_machine(void)
 {
 	/* customizes platform devices, or adds new ones */
-	if (init_machine)
-		init_machine();
+	if (machine_desc->init_machine)
+		machine_desc->init_machine();
 	return 0;
 }
 arch_initcall(customize_machine);
@@ -809,6 +808,7 @@ void __init setup_arch(char **cmdline_p)
 
 	setup_processor();
 	mdesc = setup_machine(machine_arch_type);
+	machine_desc = mdesc;
 	machine_name = mdesc->name;
 
 	if (mdesc->soft_reboot)
@@ -868,13 +868,6 @@ void __init setup_arch(char **cmdline_p)
 	cpu_init();
 	tcm_init();
 
-	/*
-	 * Set up various architecture-specific pointers
-	 */
-	arch_nr_irqs = mdesc->nr_irqs;
-	init_arch_irq = mdesc->init_irq;
-	system_timer = mdesc->timer;
-	init_machine = mdesc->init_machine;
 #ifdef CONFIG_MULTI_IRQ_HANDLER
 	handle_arch_irq = mdesc->handle_irq;
 #endif

commit 521086412ee423fbdfc7da81f257239c43f707b4
Author: eric miao <eric.y.miao@gmail.com>
Date:   Mon Dec 13 09:42:34 2010 +0100

    ARM: 6532/1: Allow machine to specify it's own IRQ handlers at run-time
    
    Normally different ARM platform has different way to decode the IRQ
    hardware status and demultiplex to the corresponding IRQ handler.
    This is highly optimized by macro irq_handler in entry-armv.S, and
    each machine defines their own macro to decode the IRQ number.
    However, this prevents multiple machine classes to be built into a
    single kernel.
    
    By allowing each machine to specify thier own handler, and making
    function pointer 'handle_arch_irq' to point to it at run time, this
    can be solved. And introduce CONFIG_MULTI_IRQ_HANDLER to allow both
    solutions to work.
    
    Comparing with the highly optimized macro of irq_handler, the new
    function must be written with care not to lose too much performance.
    And the IPI stuff on SMP is expected to move to the provided arch
    IRQ handler as well.
    
    The assembly code to invoke handle_arch_irq is optimized by Russell
    King.
    
    Signed-off-by: Eric Miao <eric.miao@canonical.com>
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 8075e592f902..0826f36330c4 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -875,6 +875,9 @@ void __init setup_arch(char **cmdline_p)
 	init_arch_irq = mdesc->init_irq;
 	system_timer = mdesc->timer;
 	init_machine = mdesc->init_machine;
+#ifdef CONFIG_MULTI_IRQ_HANDLER
+	handle_arch_irq = mdesc->handle_irq;
+#endif
 
 #ifdef CONFIG_VT
 #if defined(CONFIG_VGA_CONSOLE)

commit 0385ebc0c9b16fc2d8262c082843165313f7b1e4
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Dec 4 17:45:55 2010 +0000

    ARM: move high-usage mostly read variables in setup.c to __read_mostly
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 336f14e0e5c2..8075e592f902 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -75,9 +75,9 @@ extern void reboot_setup(char *str);
 
 unsigned int processor_id;
 EXPORT_SYMBOL(processor_id);
-unsigned int __machine_arch_type;
+unsigned int __machine_arch_type __read_mostly;
 EXPORT_SYMBOL(__machine_arch_type);
-unsigned int cacheid;
+unsigned int cacheid __read_mostly;
 EXPORT_SYMBOL(cacheid);
 
 unsigned int __atags_pointer __initdata;
@@ -91,24 +91,24 @@ EXPORT_SYMBOL(system_serial_low);
 unsigned int system_serial_high;
 EXPORT_SYMBOL(system_serial_high);
 
-unsigned int elf_hwcap;
+unsigned int elf_hwcap __read_mostly;
 EXPORT_SYMBOL(elf_hwcap);
 
 
 #ifdef MULTI_CPU
-struct processor processor;
+struct processor processor __read_mostly;
 #endif
 #ifdef MULTI_TLB
-struct cpu_tlb_fns cpu_tlb;
+struct cpu_tlb_fns cpu_tlb __read_mostly;
 #endif
 #ifdef MULTI_USER
-struct cpu_user_fns cpu_user;
+struct cpu_user_fns cpu_user __read_mostly;
 #endif
 #ifdef MULTI_CACHE
-struct cpu_cache_fns cpu_cache;
+struct cpu_cache_fns cpu_cache __read_mostly;
 #endif
 #ifdef CONFIG_OUTER_CACHE
-struct outer_cache_fns outer_cache;
+struct outer_cache_fns outer_cache __read_mostly;
 EXPORT_SYMBOL(outer_cache);
 #endif
 

commit 23beab76b490172a9ff3d52843e4d27a35b2a4c6
Merge: 8ed9059533eb 5fb31a96e1e0 80be7a7f6427 19852e59002f 29e29f27486e 725343fa748f 9e978f096241 f3af03de0b1c 5333a3de3cdd
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Oct 18 22:34:25 2010 +0100

    Merge branches 'at91', 'dcache', 'ftrace', 'hwbpt', 'misc', 'mmci', 's3c', 'st-ux' and 'unwind' into devel

commit 842eab40b6920819fff5caeefdb709f07d3f8e23
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Oct 1 14:12:22 2010 +0100

    ARM: vmlinux.lds: Refer to start of .data using _sdata rather than _data
    
    Use _sdata as the start of the data section, rather than _data.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 5a82c39ca85e..f38917174b71 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -491,7 +491,7 @@ request_standard_resources(struct meminfo *mi, struct machine_desc *mdesc)
 
 	kernel_code.start   = virt_to_phys(_text);
 	kernel_code.end     = virt_to_phys(_etext - 1);
-	kernel_data.start   = virt_to_phys(_data);
+	kernel_data.start   = virt_to_phys(_sdata);
 	kernel_data.end     = virt_to_phys(_end - 1);
 
 	for (i = 0; i < mi->nr_banks; i++) {

commit 5fb31a96e1e0078f1e82736ccd72a61ecabe6a4f
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Wed Oct 6 11:07:28 2010 +0100

    ARM: 6431/1: fix isb regression on CPU < v7
    
    The kernel does not compile for my ARM926EJ-S system U300 due to
    the isb instruction inserted in generic assember statement from
    commit 8925ec4c530094b878e7e28a1fd78e7122afd973, "ARM: 6385/1:
    setup: detect aliasing I-cache when D-cache is non-aliasing"
    hey the isb is only available when assembling for v7 so let's
    use the generic isb() macro from setup.h instead.
    
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 9fc483393bae..e0430d036cea 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -246,11 +246,12 @@ static int cpu_has_aliasing_icache(unsigned int arch)
 	/* arch specifies the register format */
 	switch (arch) {
 	case CPU_ARCH_ARMv7:
-		asm("mcr	p15, 2, %1, c0, c0, 0	@ set CSSELR\n"
-		    "isb\n"
-		    "mrc	p15, 1, %0, c0, c0, 0	@ read CCSIDR"
-		    : "=r" (id_reg)
+		asm("mcr	p15, 2, %0, c0, c0, 0 @ set CSSELR"
+		    : /* No output operands */
 		    : "r" (1));
+		isb();
+		asm("mrc	p15, 1, %0, c0, c0, 0 @ read CCSIDR"
+		    : "=r" (id_reg));
 		line_size = 4 << ((id_reg & 0x7) + 2);
 		num_sets = ((id_reg >> 13) & 0x7fff) + 1;
 		aliasing_icache = (line_size * num_sets) > PAGE_SIZE;

commit 8925ec4c530094b878e7e28a1fd78e7122afd973
Author: Will Deacon <will.deacon@arm.com>
Date:   Mon Sep 13 16:18:30 2010 +0100

    ARM: 6385/1: setup: detect aliasing I-cache when D-cache is non-aliasing
    
    Currently, the Kernel assumes that if a CPU has a non-aliasing D-cache
    then the I-cache is also non-aliasing. This may not be true on ARM cores
    from v6 onwards, which may have aliasing I-caches but non-aliasing
    D-caches.
    
    This patch adds a cpu_has_aliasing_icache function, which is called from
    cacheid_init and adds CACHEID_VIPT_I_ALIASING to the cacheid when
    appropriate. A utility macro, icache_is_vipt_aliasing(), is also
    provided.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index d5231ae7355a..9fc483393bae 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -238,6 +238,34 @@ int cpu_architecture(void)
 	return cpu_arch;
 }
 
+static int cpu_has_aliasing_icache(unsigned int arch)
+{
+	int aliasing_icache;
+	unsigned int id_reg, num_sets, line_size;
+
+	/* arch specifies the register format */
+	switch (arch) {
+	case CPU_ARCH_ARMv7:
+		asm("mcr	p15, 2, %1, c0, c0, 0	@ set CSSELR\n"
+		    "isb\n"
+		    "mrc	p15, 1, %0, c0, c0, 0	@ read CCSIDR"
+		    : "=r" (id_reg)
+		    : "r" (1));
+		line_size = 4 << ((id_reg & 0x7) + 2);
+		num_sets = ((id_reg >> 13) & 0x7fff) + 1;
+		aliasing_icache = (line_size * num_sets) > PAGE_SIZE;
+		break;
+	case CPU_ARCH_ARMv6:
+		aliasing_icache = read_cpuid_cachetype() & (1 << 11);
+		break;
+	default:
+		/* I-cache aliases will be handled by D-cache aliasing code */
+		aliasing_icache = 0;
+	}
+
+	return aliasing_icache;
+}
+
 static void __init cacheid_init(void)
 {
 	unsigned int cachetype = read_cpuid_cachetype();
@@ -249,10 +277,15 @@ static void __init cacheid_init(void)
 			cacheid = CACHEID_VIPT_NONALIASING;
 			if ((cachetype & (3 << 14)) == 1 << 14)
 				cacheid |= CACHEID_ASID_TAGGED;
-		} else if (cachetype & (1 << 23))
+			else if (cpu_has_aliasing_icache(CPU_ARCH_ARMv7))
+				cacheid |= CACHEID_VIPT_I_ALIASING;
+		} else if (cachetype & (1 << 23)) {
 			cacheid = CACHEID_VIPT_ALIASING;
-		else
+		} else {
 			cacheid = CACHEID_VIPT_NONALIASING;
+			if (cpu_has_aliasing_icache(CPU_ARCH_ARMv6))
+				cacheid |= CACHEID_VIPT_I_ALIASING;
+		}
 	} else {
 		cacheid = CACHEID_VIVT;
 	}
@@ -263,7 +296,7 @@ static void __init cacheid_init(void)
 		cache_is_vipt_nonaliasing() ? "VIPT nonaliasing" : "unknown",
 		cache_is_vivt() ? "VIVT" :
 		icache_is_vivt_asid_tagged() ? "VIVT ASID tagged" :
-		cache_is_vipt_aliasing() ? "VIPT aliasing" :
+		icache_is_vipt_aliasing() ? "VIPT aliasing" :
 		cache_is_vipt_nonaliasing() ? "VIPT nonaliasing" : "unknown");
 }
 

commit f00ec48fadf5e37e7889f14cff900aa70d18b644
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Sep 4 10:47:48 2010 +0100

    ARM: Allow SMP kernels to boot on UP systems
    
    UP systems do not implement all the instructions that SMP systems have,
    so in order to boot a SMP kernel on a UP system, we need to rewrite
    parts of the kernel.
    
    Do this using an 'alternatives' scheme, where the kernel code and data
    is modified prior to initialization to replace the SMP instructions,
    thereby rendering the problematical code ineffectual.  We use the linker
    to generate a list of 32-bit word locations and their replacement values,
    and run through these replacements when we detect a UP system.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index d5231ae7355a..5a82c39ca85e 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -36,6 +36,7 @@
 #include <asm/procinfo.h>
 #include <asm/sections.h>
 #include <asm/setup.h>
+#include <asm/smp_plat.h>
 #include <asm/mach-types.h>
 #include <asm/cacheflush.h>
 #include <asm/cachetype.h>
@@ -825,7 +826,8 @@ void __init setup_arch(char **cmdline_p)
 	request_standard_resources(&meminfo, mdesc);
 
 #ifdef CONFIG_SMP
-	smp_init_cpus();
+	if (is_smp())
+		smp_init_cpus();
 #endif
 	reserve_crashkernel();
 

commit 7b70c4275f28702b76b273c8534c38f8313812e9
Merge: ceb0885d3b01 a20df564d15b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jul 31 14:20:16 2010 +0100

    Merge branch 'devel-stable' into devel
    
    Conflicts:
            arch/arm/kernel/entry-armv.S
            arch/arm/kernel/setup.c
            arch/arm/mm/init.c

commit b31fc7af78e17b0203e1cd5a195c590e8adeae0d
Merge: f13b1035ce8b 4037242c4f5f a0fb007bf0c7 cea0bb1bc59b 7d63397574c8 a9deb137e4eb 39ae702cd3b8 f4f5e28d2ee0 7cfe249475fd 4bd48940190a a3e5bb42898d
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jul 31 14:19:35 2010 +0100

    Merge branches 'at91', 'ep93xx', 'kexec', 'iop', 'lmb', 'nomadik', 'nuc', 'pl', 'spear' and 'versatile' into devel

commit 8d717a52d1b0959128be5134dd12608e8e4f2115
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat May 22 19:47:18 2010 +0100

    ARM: Convert platform reservations to use LMB rather than bootmem
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index dfd293477751..31b2643bb0c6 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -716,7 +716,7 @@ void __init setup_arch(char **cmdline_p)
 
 	parse_early_param();
 
-	arm_memblock_init(&meminfo);
+	arm_memblock_init(&meminfo, mdesc);
 
 	paging_init(mdesc);
 	request_standard_resources(&meminfo, mdesc);

commit 2778f62056ada442414392d7ccd41188bb631619
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Jul 9 16:27:52 2010 +0100

    ARM: initial LMB trial
    
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 387d2e9cb51f..dfd293477751 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -25,6 +25,7 @@
 #include <linux/smp.h>
 #include <linux/fs.h>
 #include <linux/proc_fs.h>
+#include <linux/memblock.h>
 
 #include <asm/unified.h>
 #include <asm/cpu.h>
@@ -715,6 +716,8 @@ void __init setup_arch(char **cmdline_p)
 
 	parse_early_param();
 
+	arm_memblock_init(&meminfo);
+
 	paging_init(mdesc);
 	request_standard_resources(&meminfo, mdesc);
 

commit be370302742ff9948f2a42b15cb2ba174d97b930
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri May 7 17:40:33 2010 +0100

    ARM: Remove DISCONTIGMEM support
    
    Everything should now be using sparsemem rather than discontigmem, so
    remove the code supporting discontigmem from ARM.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 122d999bdc7c..387d2e9cb51f 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -402,13 +402,12 @@ static int __init arm_add_memory(unsigned long start, unsigned long size)
 	size -= start & ~PAGE_MASK;
 	bank->start = PAGE_ALIGN(start);
 	bank->size  = size & PAGE_MASK;
-	bank->node  = PHYS_TO_NID(start);
 
 	/*
 	 * Check whether this memory region has non-zero size or
 	 * invalid node number.
 	 */
-	if (bank->size == 0 || bank->node >= MAX_NUMNODES)
+	if (bank->size == 0)
 		return -EINVAL;
 
 	meminfo.nr_banks++;

commit cea0bb1bc59b94625e60b69aaa9ad6749d5b57dd
Author: Mika Westerberg <mika.westerberg@iki.fi>
Date:   Mon May 10 09:29:32 2010 +0100

    ARM: 6122/1: kdump: add support for elfcorehdr parameter
    
    This parameter is used by primary kernel to pass address of vmcore
    header to the dump capture kernel.
    
    Signed-off-by: Mika Westerberg <ext-mika.1.westerberg@nokia.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 714cbaaab3aa..2183bb83ac83 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -20,6 +20,7 @@
 #include <linux/screen_info.h>
 #include <linux/init.h>
 #include <linux/kexec.h>
+#include <linux/crash_dump.h>
 #include <linux/root_dev.h>
 #include <linux/cpu.h>
 #include <linux/interrupt.h>
@@ -730,6 +731,30 @@ static void __init reserve_crashkernel(void)
 static inline void reserve_crashkernel(void) {}
 #endif /* CONFIG_KEXEC */
 
+/*
+ * Note: elfcorehdr_addr is not just limited to vmcore. It is also used by
+ * is_kdump_kernel() to determine if we are booting after a panic. Hence
+ * ifdef it under CONFIG_CRASH_DUMP and not CONFIG_PROC_VMCORE.
+ */
+
+#ifdef CONFIG_CRASH_DUMP
+/*
+ * elfcorehdr= specifies the location of elf core header stored by the crashed
+ * kernel. This option will be passed by kexec loader to the capture kernel.
+ */
+static int __init setup_elfcorehdr(char *arg)
+{
+	char *end;
+
+	if (!arg)
+		return -EINVAL;
+
+	elfcorehdr_addr = memparse(arg, &end);
+	return end > arg ? 0 : -EINVAL;
+}
+early_param("elfcorehdr", setup_elfcorehdr);
+#endif /* CONFIG_CRASH_DUMP */
+
 void __init setup_arch(char **cmdline_p)
 {
 	struct tag *tags = (struct tag *)&init_tags;

commit 3c57fb43c8fcbe46541d3a0274f0b4c802c68927
Author: Mika Westerberg <mika.westerberg@iki.fi>
Date:   Mon May 10 09:20:22 2010 +0100

    ARM: 6116/1: kdump: reserve memory for crashkernel
    
    Implemented ARM support for command line option
    "crashkernel=size@start" which allows user to reserve some memory
    for a dump capture kernel.
    
    Signed-off-by: Mika Westerberg <ext-mika.1.westerberg@nokia.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 648c3c1e16c4..714cbaaab3aa 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -19,6 +19,7 @@
 #include <linux/seq_file.h>
 #include <linux/screen_info.h>
 #include <linux/init.h>
+#include <linux/kexec.h>
 #include <linux/root_dev.h>
 #include <linux/cpu.h>
 #include <linux/interrupt.h>
@@ -680,6 +681,55 @@ static int __init customize_machine(void)
 }
 arch_initcall(customize_machine);
 
+#ifdef CONFIG_KEXEC
+static inline unsigned long long get_total_mem(void)
+{
+	unsigned long total;
+
+	total = max_low_pfn - min_low_pfn;
+	return total << PAGE_SHIFT;
+}
+
+/**
+ * reserve_crashkernel() - reserves memory are for crash kernel
+ *
+ * This function reserves memory area given in "crashkernel=" kernel command
+ * line parameter. The memory reserved is used by a dump capture kernel when
+ * primary kernel is crashing.
+ */
+static void __init reserve_crashkernel(void)
+{
+	unsigned long long crash_size, crash_base;
+	unsigned long long total_mem;
+	int ret;
+
+	total_mem = get_total_mem();
+	ret = parse_crashkernel(boot_command_line, total_mem,
+				&crash_size, &crash_base);
+	if (ret)
+		return;
+
+	ret = reserve_bootmem(crash_base, crash_size, BOOTMEM_EXCLUSIVE);
+	if (ret < 0) {
+		printk(KERN_WARNING "crashkernel reservation failed - "
+		       "memory is in use (0x%lx)\n", (unsigned long)crash_base);
+		return;
+	}
+
+	printk(KERN_INFO "Reserving %ldMB of memory at %ldMB "
+	       "for crashkernel (System RAM: %ldMB)\n",
+	       (unsigned long)(crash_size >> 20),
+	       (unsigned long)(crash_base >> 20),
+	       (unsigned long)(total_mem >> 20));
+
+	crashk_res.start = crash_base;
+	crashk_res.end = crash_base + crash_size - 1;
+	insert_resource(&iomem_resource, &crashk_res);
+}
+#else
+static inline void reserve_crashkernel(void) {}
+#endif /* CONFIG_KEXEC */
+
 void __init setup_arch(char **cmdline_p)
 {
 	struct tag *tags = (struct tag *)&init_tags;
@@ -739,6 +789,7 @@ void __init setup_arch(char **cmdline_p)
 #ifdef CONFIG_SMP
 	smp_init_cpus();
 #endif
+	reserve_crashkernel();
 
 	cpu_init();
 	tcm_init();

commit f159f4ed55bb0fa5470800641e03a13a7e0eae6e
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Jul 5 14:53:10 2010 +0100

    ARM: 6207/1: Replace CONFIG_HAS_TLS_REG with HWCAP_TLS and check for it on V6
    
    The TLS register is only available on ARM1136 r1p0 and later.
    Set HWCAP_TLS flags if hardware TLS is available and test for
    it if CONFIG_CPU_32v6K is not set for V6.
    
    Note that we set the TLS instruction in __kuser_get_tls
    dynamically as suggested by Jamie Lokier <jamie@shareable.org>.
    
    Also the __switch_to code is optimized out in most cases as
    suggested by Nicolas Pitre <nico@fluxnic.net>.
    
    Reviewed-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 7ae65dc594a4..648c3c1e16c4 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -269,6 +269,21 @@ static void __init cacheid_init(void)
 extern struct proc_info_list *lookup_processor_type(unsigned int);
 extern struct machine_desc *lookup_machine_type(unsigned int);
 
+static void __init feat_v6_fixup(void)
+{
+	int id = read_cpuid_id();
+
+	if ((id & 0xff0f0000) != 0x41070000)
+		return;
+
+	/*
+	 * HWCAP_TLS is available only on 1136 r1p0 and later,
+	 * see also kuser_get_tls_init.
+	 */
+	if ((((id >> 4) & 0xfff) == 0xb36) && (((id >> 20) & 3) == 0))
+		elf_hwcap &= ~HWCAP_TLS;
+}
+
 static void __init setup_processor(void)
 {
 	struct proc_info_list *list;
@@ -311,6 +326,8 @@ static void __init setup_processor(void)
 	elf_hwcap &= ~HWCAP_THUMB;
 #endif
 
+	feat_v6_fixup();
+
 	cacheid_init();
 	cpu_proc_init();
 }

commit 354e6f72d6fd5d3d2963efe030265972866cd969
Author: eric miao <eric.y.miao@gmail.com>
Date:   Fri Jun 25 09:46:09 2010 +0100

    ARM: 6197/2: preliminary support for sparse IRQ
    
    So to allow NR_IRQS to be dynamic and platforms to specify the number
    of IRQs really needed.
    
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 122d999bdc7c..7ae65dc594a4 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -729,6 +729,7 @@ void __init setup_arch(char **cmdline_p)
 	/*
 	 * Set up various architecture-specific pointers
 	 */
+	arch_nr_irqs = mdesc->nr_irqs;
 	init_arch_irq = mdesc->init_irq;
 	system_timer = mdesc->timer;
 	init_machine = mdesc->init_machine;

commit 73a65b3f8587fa1c83768515ecc0bf6fa44ccdd1
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Tue Jan 19 10:13:14 2010 +0100

    ARM: deprecate support for old way to pass kernel parameters
    
    This was deprecated in 2001 and announced to live on for 5 years.
    
    For now provide a kernel parameter for those who still need it.
    
    Acked-by: Eric Miao <eric.miao@canonical.com>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 122d999bdc7c..cbc6ddb1c9bd 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -44,7 +44,9 @@
 #include <asm/traps.h>
 #include <asm/unwind.h>
 
+#if defined(CONFIG_DEPRECATED_PARAM_STRUCT)
 #include "compat.h"
+#endif
 #include "atags.h"
 #include "tcm.h"
 
@@ -663,6 +665,13 @@ static int __init customize_machine(void)
 }
 arch_initcall(customize_machine);
 
+static void __init squash_mem_tags(struct tag *tag)
+{
+	for (; tag->hdr.size; tag = tag_next(tag))
+		if (tag->hdr.tag == ATAG_MEM)
+			tag->hdr.tag = ATAG_NONE;
+}
+
 void __init setup_arch(char **cmdline_p)
 {
 	struct tag *tags = (struct tag *)&init_tags;
@@ -683,12 +692,14 @@ void __init setup_arch(char **cmdline_p)
 	else if (mdesc->boot_params)
 		tags = phys_to_virt(mdesc->boot_params);
 
+#if defined(CONFIG_DEPRECATED_PARAM_STRUCT)
 	/*
 	 * If we have the old style parameters, convert them to
 	 * a tag list.
 	 */
 	if (tags->hdr.tag != ATAG_CORE)
 		convert_to_tag_list(tags);
+#endif
 	if (tags->hdr.tag != ATAG_CORE)
 		tags = (struct tag *)&init_tags;
 

commit 92d2040d78f662f634efce7a5106bbed70b8708b
Author: Alexander Holler <holler@ahsoftware.de>
Date:   Tue Feb 16 19:04:53 2010 +0100

    ARM: 5939/1: ARM: Add option CMDLINE_FORCE to force usage of the in-kernel cmdline
    
    Add an option to force usage of the in-kernel cmdline even if the boot
    loader passes another command string to the kernel.
    
    Useful if someone cannot or don't want to change the
    command-line options of the boot loader but is able to change
    the kernel.
    
    Signed-off-by: Alexander Holler <holler@ahsoftware.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index c91c77b54dea..122d999bdc7c 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -593,6 +593,7 @@ static int __init parse_tag_revision(const struct tag *tag)
 
 __tagtable(ATAG_REVISION, parse_tag_revision);
 
+#ifndef CONFIG_CMDLINE_FORCE
 static int __init parse_tag_cmdline(const struct tag *tag)
 {
 	strlcpy(default_command_line, tag->u.cmdline.cmdline, COMMAND_LINE_SIZE);
@@ -600,6 +601,7 @@ static int __init parse_tag_cmdline(const struct tag *tag)
 }
 
 __tagtable(ATAG_CMDLINE, parse_tag_cmdline);
+#endif /* CONFIG_CMDLINE_FORCE */
 
 /*
  * Scan the tag table for this tag, and call its parse function.

commit ac0f6f927db539e03e1f3f61bcd4ed57d5cde7a9
Merge: b1bf9368407a 9f33be2c3a80
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 1 09:15:15 2010 -0800

    Merge branch 'for-linus' of master.kernel.org:/home/rmk/linux-2.6-arm
    
    * 'for-linus' of master.kernel.org:/home/rmk/linux-2.6-arm: (100 commits)
      ARM: Eliminate decompressor -Dstatic= PIC hack
      ARM: 5958/1: ARM: U300: fix inverted clk round rate
      ARM: 5956/1: misplaced parentheses
      ARM: 5955/1: ep93xx: move timer defines into core.c and document
      ARM: 5954/1: ep93xx: move gpio interrupt support to gpio.c
      ARM: 5953/1: ep93xx: fix broken build of clock.c
      ARM: 5952/1: ARM: MM: Add ARM_L1_CACHE_SHIFT_6 for handle inside each ARCH Kconfig
      ARM: 5949/1: NUC900 add gpio virtual memory map
      ARM: 5948/1: Enable timer0 to time4 clock support for nuc910
      ARM: 5940/2: ARM: MMCI: remove custom DBG macro and printk
      ARM: make_coherent(): fix problems with highpte, part 2
      MM: Pass a PTE pointer to update_mmu_cache() rather than the PTE itself
      ARM: 5945/1: ep93xx: include correct irq.h in core.c
      ARM: 5933/1: amba-pl011: support hardware flow control
      ARM: 5930/1: Add PKMAP area description to memory.txt.
      ARM: 5929/1: Add checks to detect overlap of memory regions.
      ARM: 5928/1: Change type of VMALLOC_END to unsigned long.
      ARM: 5927/1: Make delimiters of DMA area globally visibly.
      ARM: 5926/1: Add "Virtual kernel memory..." printout.
      ARM: 5920/1: OMAP4: Enable L2 Cache
      ...
    
    Fix up trivial conflict in arch/arm/mach-mx25/clock.c

commit 6c09f09d44690d341d970559b64779bef8b9236b
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Tue Feb 16 07:57:43 2010 +0100

    ARM: 5938/1: ARM: L2: export outer_cache_fns
    
    The 'outer_cache' variable is needed by the outer_inv_range(),
    outer_clean_range() and outer_flush_range() functions, which are
    declared as inline in asm/cacheflush.h.  Otherwise drivers built
    as a loadable module, which access these functions, will have
    an undefined symbol.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index c6c57b640b6b..621acad8ea43 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -102,6 +102,7 @@ struct cpu_cache_fns cpu_cache;
 #endif
 #ifdef CONFIG_OUTER_CACHE
 struct outer_cache_fns outer_cache;
+EXPORT_SYMBOL(outer_cache);
 #endif
 
 struct stack {

commit 48ab7e09e0a7c00a217f87e4b57dfbee9c603e79
Author: Jeremy Kerr <jeremy.kerr@canonical.com>
Date:   Wed Jan 27 01:13:31 2010 +0100

    ARM: 5906/1: arm: change command_line to cmd_line
    
    drivers/of/fdt expects a cmd_line symbol, while arm uses command_line.
    Change to the former, so that we can eventually share with the fdt
    code.
    
    Signed-off-by: Jeremy Kerr <jeremy.kerr@canonical.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index b01a56a03ed8..baf5959d639a 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -118,7 +118,7 @@ EXPORT_SYMBOL(elf_platform);
 
 static const char *cpu_name;
 static const char *machine_name;
-static char __initdata command_line[COMMAND_LINE_SIZE];
+static char __initdata cmd_line[COMMAND_LINE_SIZE];
 
 static char default_command_line[COMMAND_LINE_SIZE] __initdata = CONFIG_CMDLINE;
 static union { char c[4]; unsigned long l; } endian_test __initdata = { { 'l', '?', '?', 'b' } };
@@ -707,9 +707,9 @@ void __init setup_arch(char **cmdline_p)
 	/* parse_early_param needs a boot_command_line */
 	strlcpy(boot_command_line, from, COMMAND_LINE_SIZE);
 
-	/* populate command_line too for later use, preserving boot_command_line */
-	strlcpy(command_line, boot_command_line, COMMAND_LINE_SIZE);
-	*cmdline_p = command_line;
+	/* populate cmd_line too for later use, preserving boot_command_line */
+	strlcpy(cmd_line, boot_command_line, COMMAND_LINE_SIZE);
+	*cmdline_p = cmd_line;
 
 	parse_early_param();
 

commit 2b0d8c251b8876d530a6bf671eb5425838fa698a
Author: Jeremy Kerr <jeremy.kerr@canonical.com>
Date:   Mon Jan 11 23:17:34 2010 +0100

    ARM: 5880/1: arm: use generic infrastructure for early params
    
    The ARM setup code includes its own parser for early params, there's
    also one in the generic init code.
    
    This patch removes __early_init (and related code) from
    arch/arm/kernel/setup.c, and changes users to the generic early_init
    macro instead.
    
    The generic macro takes a char * argument, rather than char **, so we
    need to update the parser functions a little.
    
    Signed-off-by: Jeremy Kerr <jeremy.kerr@canonical.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 5357e48f2c39..b01a56a03ed8 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -418,10 +418,11 @@ static int __init arm_add_memory(unsigned long start, unsigned long size)
  * Pick out the memory size.  We look for mem=size@start,
  * where start and size are "size[KkMm]"
  */
-static void __init early_mem(char **p)
+static int __init early_mem(char *p)
 {
 	static int usermem __initdata = 0;
 	unsigned long size, start;
+	char *endp;
 
 	/*
 	 * If the user specifies memory size, we
@@ -434,52 +435,15 @@ static void __init early_mem(char **p)
 	}
 
 	start = PHYS_OFFSET;
-	size  = memparse(*p, p);
-	if (**p == '@')
-		start = memparse(*p + 1, p);
+	size  = memparse(p, &endp);
+	if (*endp == '@')
+		start = memparse(endp + 1, NULL);
 
 	arm_add_memory(start, size);
-}
-__early_param("mem=", early_mem);
 
-/*
- * Initial parsing of the command line.
- */
-static void __init parse_cmdline(char **cmdline_p, char *from)
-{
-	char c = ' ', *to = command_line;
-	int len = 0;
-
-	for (;;) {
-		if (c == ' ') {
-			extern struct early_params __early_begin, __early_end;
-			struct early_params *p;
-
-			for (p = &__early_begin; p < &__early_end; p++) {
-				int arglen = strlen(p->arg);
-
-				if (memcmp(from, p->arg, arglen) == 0) {
-					if (to != command_line)
-						to -= 1;
-					from += arglen;
-					p->fn(&from);
-
-					while (*from != ' ' && *from != '\0')
-						from++;
-					break;
-				}
-			}
-		}
-		c = *from++;
-		if (!c)
-			break;
-		if (COMMAND_LINE_SIZE <= ++len)
-			break;
-		*to++ = c;
-	}
-	*to = '\0';
-	*cmdline_p = command_line;
+	return 0;
 }
+early_param("mem", early_mem);
 
 static void __init
 setup_ramdisk(int doload, int prompt, int image_start, unsigned int rd_sz)
@@ -740,9 +704,15 @@ void __init setup_arch(char **cmdline_p)
 	init_mm.end_data   = (unsigned long) _edata;
 	init_mm.brk	   = (unsigned long) _end;
 
-	memcpy(boot_command_line, from, COMMAND_LINE_SIZE);
-	boot_command_line[COMMAND_LINE_SIZE-1] = '\0';
-	parse_cmdline(cmdline_p, from);
+	/* parse_early_param needs a boot_command_line */
+	strlcpy(boot_command_line, from, COMMAND_LINE_SIZE);
+
+	/* populate command_line too for later use, preserving boot_command_line */
+	strlcpy(command_line, boot_command_line, COMMAND_LINE_SIZE);
+	*cmdline_p = command_line;
+
+	parse_early_param();
+
 	paging_init(mdesc);
 	request_standard_resources(&meminfo, mdesc);
 

commit e119bfff1f102f8d1505910cd6c09df55c776b43
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Jan 10 17:23:29 2010 +0000

    ARM: Move creation of /proc/cpu out of alignment.c
    
    Always creating this directory avoids other users having to jump
    through silly hoops when they want to share this directory.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index c6c57b640b6b..5357e48f2c39 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -24,6 +24,7 @@
 #include <linux/interrupt.h>
 #include <linux/smp.h>
 #include <linux/fs.h>
+#include <linux/proc_fs.h>
 
 #include <asm/unified.h>
 #include <asm/cpu.h>
@@ -782,9 +783,21 @@ static int __init topology_init(void)
 
 	return 0;
 }
-
 subsys_initcall(topology_init);
 
+#ifdef CONFIG_HAVE_PROC_CPU
+static int __init proc_cpu_init(void)
+{
+	struct proc_dir_entry *res;
+
+	res = proc_mkdir("cpu", NULL);
+	if (!res)
+		return -ENOMEM;
+	return 0;
+}
+fs_initcall(proc_cpu_init);
+#endif
+
 static const char *hwcap_str[] = {
 	"swp",
 	"half",

commit bc581770cfdd8c17ea17d324dc05e2f9c599e7ca
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Tue Sep 15 17:30:37 2009 +0100

    ARM: 5580/2: ARM TCM (Tightly-Coupled Memory) support v3
    
    This adds the TCM interface to Linux, when active, it will
    detect and report TCM memories and sizes early in boot if
    present, introduce generic TCM memory handling, provide a
    generic TCM memory pool and select TCM memory for the U300
    platform.
    
    See the Documentation/arm/tcm.txt for documentation.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index d4d4f77c91b2..c6c57b640b6b 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -45,6 +45,7 @@
 
 #include "compat.h"
 #include "atags.h"
+#include "tcm.h"
 
 #ifndef MEM_SIZE
 #define MEM_SIZE	(16*1024*1024)
@@ -749,6 +750,7 @@ void __init setup_arch(char **cmdline_p)
 #endif
 
 	cpu_init();
+	tcm_init();
 
 	/*
 	 * Set up various architecture-specific pointers

commit b86040a59feb255a8193173caa4d5199464433d5
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Fri Jul 24 12:32:54 2009 +0100

    Thumb-2: Implementation of the unified start-up and exceptions code
    
    This patch implements the ARM/Thumb-2 unified kernel start-up and
    exception handling code.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index bc5e4128f9f3..d4d4f77c91b2 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -25,6 +25,7 @@
 #include <linux/smp.h>
 #include <linux/fs.h>
 
+#include <asm/unified.h>
 #include <asm/cpu.h>
 #include <asm/cputype.h>
 #include <asm/elf.h>
@@ -326,26 +327,39 @@ void cpu_init(void)
 		BUG();
 	}
 
+	/*
+	 * Define the placement constraint for the inline asm directive below.
+	 * In Thumb-2, msr with an immediate value is not allowed.
+	 */
+#ifdef CONFIG_THUMB2_KERNEL
+#define PLC	"r"
+#else
+#define PLC	"I"
+#endif
+
 	/*
 	 * setup stacks for re-entrant exception handlers
 	 */
 	__asm__ (
 	"msr	cpsr_c, %1\n\t"
-	"add	sp, %0, %2\n\t"
+	"add	r14, %0, %2\n\t"
+	"mov	sp, r14\n\t"
 	"msr	cpsr_c, %3\n\t"
-	"add	sp, %0, %4\n\t"
+	"add	r14, %0, %4\n\t"
+	"mov	sp, r14\n\t"
 	"msr	cpsr_c, %5\n\t"
-	"add	sp, %0, %6\n\t"
+	"add	r14, %0, %6\n\t"
+	"mov	sp, r14\n\t"
 	"msr	cpsr_c, %7"
 	    :
 	    : "r" (stk),
-	      "I" (PSR_F_BIT | PSR_I_BIT | IRQ_MODE),
+	      PLC (PSR_F_BIT | PSR_I_BIT | IRQ_MODE),
 	      "I" (offsetof(struct stack, irq[0])),
-	      "I" (PSR_F_BIT | PSR_I_BIT | ABT_MODE),
+	      PLC (PSR_F_BIT | PSR_I_BIT | ABT_MODE),
 	      "I" (offsetof(struct stack, abt[0])),
-	      "I" (PSR_F_BIT | PSR_I_BIT | UND_MODE),
+	      PLC (PSR_F_BIT | PSR_I_BIT | UND_MODE),
 	      "I" (offsetof(struct stack, und[0])),
-	      "I" (PSR_F_BIT | PSR_I_BIT | SVC_MODE)
+	      PLC (PSR_F_BIT | PSR_I_BIT | SVC_MODE)
 	    : "r14");
 }
 

commit 97fb44eb6bc01f4ffed4300e475aa15e44877375
Merge: e4707dd3e9d0 148854c65ea8
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Mar 13 21:44:51 2009 +0000

    Merge branch 'for-rmk' of git://git.pengutronix.de/git/imx/linux-2.6 into devel
    
    Conflicts:
    
            arch/arm/mach-at91/gpio.c

commit b57ee99fab25dbc12150fe66fe54dc52bc6de784
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Tue Mar 3 11:44:12 2009 +0100

    [ARM] 5417/1: Set the correct cacheid for ARMv6 CPUs with ARMv7 style MMU
    
    The cacheid_init() function assumes that if cpu_architecture() returns
    7, the caches are VIPT_NONALIASING. The cpu_architecture() function
    returns the version of the supported MMU features (e.g. TEX remapping)
    but it doesn't make any assumptions about the cache type. The patch adds
    the checking of the Cache Type Register for the ARMv7 format.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 7049815d66d5..68d6494c0389 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -233,12 +233,13 @@ static void __init cacheid_init(void)
 	unsigned int cachetype = read_cpuid_cachetype();
 	unsigned int arch = cpu_architecture();
 
-	if (arch >= CPU_ARCH_ARMv7) {
-		cacheid = CACHEID_VIPT_NONALIASING;
-		if ((cachetype & (3 << 14)) == 1 << 14)
-			cacheid |= CACHEID_ASID_TAGGED;
-	} else if (arch >= CPU_ARCH_ARMv6) {
-		if (cachetype & (1 << 23))
+	if (arch >= CPU_ARCH_ARMv6) {
+		if ((cachetype & (7 << 29)) == 4 << 29) {
+			/* ARMv7 register format */
+			cacheid = CACHEID_VIPT_NONALIASING;
+			if ((cachetype & (3 << 14)) == 1 << 14)
+				cacheid |= CACHEID_ASID_TAGGED;
+		} else if (cachetype & (1 << 23))
 			cacheid = CACHEID_VIPT_ALIASING;
 		else
 			cacheid = CACHEID_VIPT_NONALIASING;

commit bff595c15c92b9c5c8f3d32edefcef6c3cbdd59f
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Mon Feb 16 11:41:36 2009 +0100

    [ARM] 5383/2: unwind: Add core support for ARM stack unwinding
    
    This patch adds the main functionality for parsing the stack unwinding
    information generated by the ARM EABI toolchains. The unwinding
    information consists of an index with a pair of words per function and a
    table with unwinding instructions. For more information, see "Exception
    Handling ABI for the ARM Architecture" at:
    
    http://infocenter.arm.com/help/topic/com.arm.doc.subset.swdev.abi/index.html
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 645ec7436681..8d21427bb679 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -40,6 +40,7 @@
 #include <asm/mach/irq.h>
 #include <asm/mach/time.h>
 #include <asm/traps.h>
+#include <asm/unwind.h>
 
 #include "compat.h"
 #include "atags.h"
@@ -684,6 +685,8 @@ void __init setup_arch(char **cmdline_p)
 	struct machine_desc *mdesc;
 	char *from = default_command_line;
 
+	unwind_init();
+
 	setup_processor();
 	mdesc = setup_machine(machine_arch_type);
 	machine_name = mdesc->name;

commit 7279dc3e914635ab4b288ec39383272a06c466f3
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Wed Feb 11 13:13:56 2009 +0100

    [ARM] 5388/1: Add hwcap bits for VFPv3 and VFPv3D16
    
    The VFPv3D16 is a VFPv3 CPU configuration where only 16 double registers
    are present, as the VFPv2 configuration. This patch adds the
    corresponding hwcap bits so that applications or debuggers have more
    information about the supported features.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 7049815d66d5..645ec7436681 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -779,6 +779,8 @@ static const char *hwcap_str[] = {
 	"crunch",
 	"thumbee",
 	"neon",
+	"vfpv3",
+	"vfpv3d16",
 	NULL
 };
 

commit 37efe6427dd50e889473fb3c7fcec02dbbd098eb
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Dec 1 11:53:07 2008 +0000

    [ARM] use asm/sections.h
    
    Update to use the asm/sections.h header rather than declaring these
    symbols ourselves.  Change __data_start to _data to conform with the
    naming found within asm/sections.h.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 4f6ae06d0855..7049815d66d5 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -29,6 +29,7 @@
 #include <asm/cputype.h>
 #include <asm/elf.h>
 #include <asm/procinfo.h>
+#include <asm/sections.h>
 #include <asm/setup.h>
 #include <asm/mach-types.h>
 #include <asm/cacheflush.h>
@@ -61,7 +62,6 @@ __setup("fpe=", fpe_setup);
 
 extern void paging_init(struct machine_desc *desc);
 extern void reboot_setup(char *str);
-extern void _text, _etext, __data_start, _edata, _end;
 
 unsigned int processor_id;
 EXPORT_SYMBOL(processor_id);
@@ -484,10 +484,10 @@ request_standard_resources(struct meminfo *mi, struct machine_desc *mdesc)
 	struct resource *res;
 	int i;
 
-	kernel_code.start   = virt_to_phys(&_text);
-	kernel_code.end     = virt_to_phys(&_etext - 1);
-	kernel_data.start   = virt_to_phys(&__data_start);
-	kernel_data.end     = virt_to_phys(&_end - 1);
+	kernel_code.start   = virt_to_phys(_text);
+	kernel_code.end     = virt_to_phys(_etext - 1);
+	kernel_data.start   = virt_to_phys(_data);
+	kernel_data.end     = virt_to_phys(_end - 1);
 
 	for (i = 0; i < mi->nr_banks; i++) {
 		if (mi->bank[i].size == 0)
@@ -715,10 +715,10 @@ void __init setup_arch(char **cmdline_p)
 		parse_tags(tags);
 	}
 
-	init_mm.start_code = (unsigned long) &_text;
-	init_mm.end_code   = (unsigned long) &_etext;
-	init_mm.end_data   = (unsigned long) &_edata;
-	init_mm.brk	   = (unsigned long) &_end;
+	init_mm.start_code = (unsigned long) _text;
+	init_mm.end_code   = (unsigned long) _etext;
+	init_mm.end_data   = (unsigned long) _edata;
+	init_mm.brk	   = (unsigned long) _end;
 
 	memcpy(boot_command_line, from, COMMAND_LINE_SIZE);
 	boot_command_line[COMMAND_LINE_SIZE-1] = '\0';

commit 7ef4de17cc55a3c3b8d093743b1e3b845d8eba47
Merge: f412b09f4ed7 b5ee9002583f
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Nov 28 15:39:02 2008 +0000

    Merge branch 'highmem' into devel
    
    Conflicts:
    
            arch/arm/mach-clps7500/include/mach/memory.h

commit 4b5f32cee0cce7b9783ced5cbeabd17aa53c51fb
Author: Nicolas Pitre <nico@cam.org>
Date:   Mon Oct 6 13:24:40 2008 -0400

    [ARM] rationalize memory configuration code some more
    
    Currently there are two instances of struct meminfo: one in
    kernel/setup.c marked __initdata, and another in mm/init.c with
    permanent storage.  Let's keep only the later to directly populate
    the permanent version from arm_add_memory().
    
    Also move common validation tests between the MMU and non-MMU cases
    into arm_add_memory() to remove some duplication.  Protection against
    overflowing the membank array is also moved in there in order to cover
    the kernel cmdline parsing path as well.
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 1f1eecca7f55..d21786712c88 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -59,7 +59,7 @@ static int __init fpe_setup(char *line)
 __setup("fpe=", fpe_setup);
 #endif
 
-extern void paging_init(struct meminfo *, struct machine_desc *desc);
+extern void paging_init(struct machine_desc *desc);
 extern void reboot_setup(char *str);
 extern void _text, _etext, __data_start, _edata, _end;
 
@@ -112,7 +112,6 @@ static struct stack stacks[NR_CPUS];
 char elf_platform[ELF_PLATFORM_SIZE];
 EXPORT_SYMBOL(elf_platform);
 
-static struct meminfo meminfo __initdata = { 0, };
 static const char *cpu_name;
 static const char *machine_name;
 static char __initdata command_line[COMMAND_LINE_SIZE];
@@ -367,21 +366,34 @@ static struct machine_desc * __init setup_machine(unsigned int nr)
 	return list;
 }
 
-static void __init arm_add_memory(unsigned long start, unsigned long size)
+static int __init arm_add_memory(unsigned long start, unsigned long size)
 {
-	struct membank *bank;
+	struct membank *bank = &meminfo.bank[meminfo.nr_banks];
+
+	if (meminfo.nr_banks >= NR_BANKS) {
+		printk(KERN_CRIT "NR_BANKS too low, "
+			"ignoring memory at %#lx\n", start);
+		return -EINVAL;
+	}
 
 	/*
 	 * Ensure that start/size are aligned to a page boundary.
 	 * Size is appropriately rounded down, start is rounded up.
 	 */
 	size -= start & ~PAGE_MASK;
-
-	bank = &meminfo.bank[meminfo.nr_banks++];
-
 	bank->start = PAGE_ALIGN(start);
 	bank->size  = size & PAGE_MASK;
 	bank->node  = PHYS_TO_NID(start);
+
+	/*
+	 * Check whether this memory region has non-zero size or
+	 * invalid node number.
+	 */
+	if (bank->size == 0 || bank->node >= MAX_NUMNODES)
+		return -EINVAL;
+
+	meminfo.nr_banks++;
+	return 0;
 }
 
 /*
@@ -539,14 +551,7 @@ __tagtable(ATAG_CORE, parse_tag_core);
 
 static int __init parse_tag_mem32(const struct tag *tag)
 {
-	if (meminfo.nr_banks >= NR_BANKS) {
-		printk(KERN_WARNING
-		       "Ignoring memory bank 0x%08x size %dKB\n",
-			tag->u.mem.start, tag->u.mem.size / 1024);
-		return -EINVAL;
-	}
-	arm_add_memory(tag->u.mem.start, tag->u.mem.size);
-	return 0;
+	return arm_add_memory(tag->u.mem.start, tag->u.mem.size);
 }
 
 __tagtable(ATAG_MEM, parse_tag_mem32);
@@ -718,7 +723,7 @@ void __init setup_arch(char **cmdline_p)
 	memcpy(boot_command_line, from, COMMAND_LINE_SIZE);
 	boot_command_line[COMMAND_LINE_SIZE-1] = '\0';
 	parse_cmdline(cmdline_p, from);
-	paging_init(&meminfo, mdesc);
+	paging_init(mdesc);
 	request_standard_resources(&meminfo, mdesc);
 
 #ifdef CONFIG_SMP

commit 2bedbdf4148ebbe48c7a89449ab52e475a788f42
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Thu Nov 6 13:23:07 2008 +0000

    Add HWCAP_NEON to the ARM hwcap.h file
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 66e1a643ed14..d4dae3e9b294 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -773,6 +773,7 @@ static const char *hwcap_str[] = {
 	"iwmmxt",
 	"crunch",
 	"thumbee",
+	"neon",
 	NULL
 };
 

commit 4369ae16eec16e6a922d4333da88a58fbc201369
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Thu Nov 6 13:23:06 2008 +0000

    Add "thumbee" to the hwcap_str array
    
    This part was missed in the initial patch adding ThumbEE support.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 1f1eecca7f55..66e1a643ed14 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -772,6 +772,7 @@ static const char *hwcap_str[] = {
 	"java",
 	"iwmmxt",
 	"crunch",
+	"thumbee",
 	NULL
 };
 

commit 3319f5e51a20f3e3c59ed7dac9fc2d5c89aa2d9f
Author: Nicolas Pitre <nico@cam.org>
Date:   Thu Oct 2 03:29:22 2008 +0100

    [ARM] 5274/1: simplify request_standard_resources()
    
    There is no point converting memory bank addresses from physical to
    virtual just to convert them back to physical addresses.  Furthermore
    this isn't "right" for highmem even if in this case the end result is
    the correct one.
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index e4a975fa2d7e..1f1eecca7f55 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -478,18 +478,13 @@ request_standard_resources(struct meminfo *mi, struct machine_desc *mdesc)
 	kernel_data.end     = virt_to_phys(&_end - 1);
 
 	for (i = 0; i < mi->nr_banks; i++) {
-		unsigned long virt_start, virt_end;
-
 		if (mi->bank[i].size == 0)
 			continue;
 
-		virt_start = __phys_to_virt(mi->bank[i].start);
-		virt_end   = virt_start + mi->bank[i].size - 1;
-
 		res = alloc_bootmem_low(sizeof(*res));
 		res->name  = "System RAM";
-		res->start = __virt_to_phys(virt_start);
-		res->end   = __virt_to_phys(virt_end);
+		res->start = mi->bank[i].start;
+		res->end   = mi->bank[i].start + mi->bank[i].size - 1;
 		res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
 
 		request_resource(&iomem_resource, res);

commit 6c5da7aced798c7781f054a76c769b85f0173561
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Sep 30 19:31:44 2008 +0100

    [ARM] mm: move vmalloc= parsing to arch/arm/mm/mmu.c
    
    There's no point scattering this around the tree, the parsing
    of the parameter might as well live beside the code which uses
    it.  That also means we can make vmalloc_reserve a static
    variable.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 2f5d3641f2ed..e4a975fa2d7e 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -84,8 +84,6 @@ EXPORT_SYMBOL(system_serial_high);
 unsigned int elf_hwcap;
 EXPORT_SYMBOL(elf_hwcap);
 
-unsigned long __initdata vmalloc_reserve = 128 << 20;
-
 
 #ifdef MULTI_CPU
 struct processor processor;
@@ -414,17 +412,6 @@ static void __init early_mem(char **p)
 }
 __early_param("mem=", early_mem);
 
-/*
- * vmalloc=size forces the vmalloc area to be exactly 'size'
- * bytes. This can be used to increase (or decrease) the vmalloc
- * area - the default is 128m.
- */
-static void __init early_vmalloc(char **arg)
-{
-	vmalloc_reserve = memparse(*arg, arg);
-}
-__early_param("vmalloc=", early_vmalloc);
-
 /*
  * Initial parsing of the command line.
  */

commit 2b4ae1f1d2ae595ff2fc5597287881796e0e6bfc
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Sep 25 15:39:20 2008 +0100

    [ARM] Print details relevant to how we handle the cache
    
    This replaces the original cache type decoding printks.  We now
    indicate how we're treating the cache which we found, rather
    than what we found.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 5b121d81f9eb..2f5d3641f2ed 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -248,6 +248,15 @@ static void __init cacheid_init(void)
 	} else {
 		cacheid = CACHEID_VIVT;
 	}
+
+	printk("CPU: %s data cache, %s instruction cache\n",
+		cache_is_vivt() ? "VIVT" :
+		cache_is_vipt_aliasing() ? "VIPT aliasing" :
+		cache_is_vipt_nonaliasing() ? "VIPT nonaliasing" : "unknown",
+		cache_is_vivt() ? "VIVT" :
+		icache_is_vivt_asid_tagged() ? "VIVT ASID tagged" :
+		cache_is_vipt_aliasing() ? "VIPT aliasing" :
+		cache_is_vipt_nonaliasing() ? "VIPT nonaliasing" : "unknown");
 }
 
 /*

commit c0e9587841a0fd79bbf8296034faefb9afe72fb4
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Sep 25 15:35:28 2008 +0100

    [ARM] Introduce new bitmask based cache type macros
    
    Rather than trying to (inaccurately) decode the cache type from the
    registers each time we need to decide what type of cache we have,
    use a bitmask initialized early during boot.
    
    Since the setup is a one-off initialization, we can be a little more
    clever and take account of the CPU architecture as well.
    
    Note that we continue to achieve the compactness on optimised kernels
    by forcing tests to always-false or always-true as appropriate, thereby
    allowing the compiler to do build-time code elimination.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 1939c904dae3..5b121d81f9eb 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -67,6 +67,8 @@ unsigned int processor_id;
 EXPORT_SYMBOL(processor_id);
 unsigned int __machine_arch_type;
 EXPORT_SYMBOL(__machine_arch_type);
+unsigned int cacheid;
+EXPORT_SYMBOL(cacheid);
 
 unsigned int __atags_pointer __initdata;
 
@@ -229,6 +231,25 @@ int cpu_architecture(void)
 	return cpu_arch;
 }
 
+static void __init cacheid_init(void)
+{
+	unsigned int cachetype = read_cpuid_cachetype();
+	unsigned int arch = cpu_architecture();
+
+	if (arch >= CPU_ARCH_ARMv7) {
+		cacheid = CACHEID_VIPT_NONALIASING;
+		if ((cachetype & (3 << 14)) == 1 << 14)
+			cacheid |= CACHEID_ASID_TAGGED;
+	} else if (arch >= CPU_ARCH_ARMv6) {
+		if (cachetype & (1 << 23))
+			cacheid = CACHEID_VIPT_ALIASING;
+		else
+			cacheid = CACHEID_VIPT_NONALIASING;
+	} else {
+		cacheid = CACHEID_VIVT;
+	}
+}
+
 /*
  * These functions re-use the assembly code in head.S, which
  * already provide the required functionality.
@@ -278,6 +299,7 @@ static void __init setup_processor(void)
 	elf_hwcap &= ~HWCAP_THUMB;
 #endif
 
+	cacheid_init();
 	cpu_proc_init();
 }
 

commit 90f1e084783be9bbff4861fa8e460b76de2787f4
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Sep 25 14:45:02 2008 +0100

    [ARM] Remove cache type printks
    
    The cache type register found in ARMv5 and later CPUs changes format
    and meaning depending on the CPU architecture version.  Currently,
    this code:
    a) doesn't work for everything - Xscale's are identified as
       'unknown 5'.
    b) is not able to tell whether the caches are VIVT or VIPT from the
       cache type.
    c) prints rubbish on some ARMv6 and ARMv7+ CPUs.
    
    The two solutions to this are:
    1. Add yet more code to decode and print the various different register
       formats.
    2. Remove the code altogther.
    
    The code only exists to decode and print the cache parameters.
    Increasing the complexity of it just for the sake of a few prinks
    isn't worth it.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 61a2242b18b8..1939c904dae3 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -176,63 +176,6 @@ static struct resource io_res[] = {
 #define lp1 io_res[1]
 #define lp2 io_res[2]
 
-static const char *cache_types[16] = {
-	"write-through",
-	"write-back",
-	"write-back",
-	"undefined 3",
-	"undefined 4",
-	"undefined 5",
-	"write-back",
-	"write-back",
-	"undefined 8",
-	"undefined 9",
-	"undefined 10",
-	"undefined 11",
-	"undefined 12",
-	"undefined 13",
-	"write-back",
-	"undefined 15",
-};
-
-static const char *cache_clean[16] = {
-	"not required",
-	"read-block",
-	"cp15 c7 ops",
-	"undefined 3",
-	"undefined 4",
-	"undefined 5",
-	"cp15 c7 ops",
-	"cp15 c7 ops",
-	"undefined 8",
-	"undefined 9",
-	"undefined 10",
-	"undefined 11",
-	"undefined 12",
-	"undefined 13",
-	"cp15 c7 ops",
-	"undefined 15",
-};
-
-static const char *cache_lockdown[16] = {
-	"not supported",
-	"not supported",
-	"not supported",
-	"undefined 3",
-	"undefined 4",
-	"undefined 5",
-	"format A",
-	"format B",
-	"undefined 8",
-	"undefined 9",
-	"undefined 10",
-	"undefined 11",
-	"undefined 12",
-	"undefined 13",
-	"format C",
-	"undefined 15",
-};
-
 static const char *proc_arch[] = {
 	"undefined/unknown",
 	"3",
@@ -253,48 +196,6 @@ static const char *proc_arch[] = {
 	"?(17)",
 };
 
-#define CACHE_TYPE(x)	(((x) >> 25) & 15)
-#define CACHE_S(x)	((x) & (1 << 24))
-#define CACHE_DSIZE(x)	(((x) >> 12) & 4095)	/* only if S=1 */
-#define CACHE_ISIZE(x)	((x) & 4095)
-
-#define CACHE_SIZE(y)	(((y) >> 6) & 7)
-#define CACHE_ASSOC(y)	(((y) >> 3) & 7)
-#define CACHE_M(y)	((y) & (1 << 2))
-#define CACHE_LINE(y)	((y) & 3)
-
-static inline void dump_cache(const char *prefix, int cpu, unsigned int cache)
-{
-	unsigned int mult = 2 + (CACHE_M(cache) ? 1 : 0);
-
-	printk("CPU%u: %s: %d bytes, associativity %d, %d byte lines, %d sets\n",
-		cpu, prefix,
-		mult << (8 + CACHE_SIZE(cache)),
-		(mult << CACHE_ASSOC(cache)) >> 1,
-		8 << CACHE_LINE(cache),
-		1 << (6 + CACHE_SIZE(cache) - CACHE_ASSOC(cache) -
-			CACHE_LINE(cache)));
-}
-
-static void __init dump_cpu_info(int cpu)
-{
-	unsigned int info = read_cpuid_cachetype();
-
-	if (info != read_cpuid_id()) {
-		printk("CPU%u: D %s %s cache\n", cpu, cache_is_vivt() ? "VIVT" : "VIPT",
-		       cache_types[CACHE_TYPE(info)]);
-		if (CACHE_S(info)) {
-			dump_cache("I cache", cpu, CACHE_ISIZE(info));
-			dump_cache("D cache", cpu, CACHE_DSIZE(info));
-		} else {
-			dump_cache("cache", cpu, CACHE_ISIZE(info));
-		}
-	}
-
-	if (arch_is_coherent())
-		printk("Cache coherency enabled\n");
-}
-
 int cpu_architecture(void)
 {
 	int cpu_arch;
@@ -383,8 +284,7 @@ static void __init setup_processor(void)
 /*
  * cpu_init - initialise one CPU.
  *
- * cpu_init dumps the cache information, initialises SMP specific
- * information, and sets up the per-CPU stacks.
+ * cpu_init sets up the per-CPU stacks.
  */
 void cpu_init(void)
 {
@@ -396,9 +296,6 @@ void cpu_init(void)
 		BUG();
 	}
 
-	if (system_state == SYSTEM_BOOTING)
-		dump_cpu_info(cpu);
-
 	/*
 	 * setup stacks for re-entrant exception handlers
 	 */
@@ -865,22 +762,6 @@ static const char *hwcap_str[] = {
 	NULL
 };
 
-static void
-c_show_cache(struct seq_file *m, const char *type, unsigned int cache)
-{
-	unsigned int mult = 2 + (CACHE_M(cache) ? 1 : 0);
-
-	seq_printf(m, "%s size\t\t: %d\n"
-		      "%s assoc\t\t: %d\n"
-		      "%s line length\t: %d\n"
-		      "%s sets\t\t: %d\n",
-		type, mult << (8 + CACHE_SIZE(cache)),
-		type, (mult << CACHE_ASSOC(cache)) >> 1,
-		type, 8 << CACHE_LINE(cache),
-		type, 1 << (6 + CACHE_SIZE(cache) - CACHE_ASSOC(cache) -
-			    CACHE_LINE(cache)));
-}
-
 static int c_show(struct seq_file *m, void *v)
 {
 	int i;
@@ -934,27 +815,6 @@ static int c_show(struct seq_file *m, void *v)
 	}
 	seq_printf(m, "CPU revision\t: %d\n", read_cpuid_id() & 15);
 
-	{
-		unsigned int cache_info = read_cpuid_cachetype();
-		if (cache_info != read_cpuid_id()) {
-			seq_printf(m, "Cache type\t: %s\n"
-				      "Cache clean\t: %s\n"
-				      "Cache lockdown\t: %s\n"
-				      "Cache format\t: %s\n",
-				   cache_types[CACHE_TYPE(cache_info)],
-				   cache_clean[CACHE_TYPE(cache_info)],
-				   cache_lockdown[CACHE_TYPE(cache_info)],
-				   CACHE_S(cache_info) ? "Harvard" : "Unified");
-
-			if (CACHE_S(cache_info)) {
-				c_show_cache(m, "I", CACHE_ISIZE(cache_info));
-				c_show_cache(m, "D", CACHE_DSIZE(cache_info));
-			} else {
-				c_show_cache(m, "Cache", CACHE_ISIZE(cache_info));
-			}
-		}
-	}
-
 	seq_puts(m, "\n");
 
 	seq_printf(m, "Hardware\t: %s\n", machine_name);

commit 5ed5fdf50cbe8195522e2176d6356b357c0c963f
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Sep 6 11:23:30 2008 +0100

    [ARM] clean up a load of old declarations
    
    ... some of which are now in linux/*.h headers.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index f972fc3e979b..61a2242b18b8 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -61,8 +61,7 @@ __setup("fpe=", fpe_setup);
 
 extern void paging_init(struct meminfo *, struct machine_desc *desc);
 extern void reboot_setup(char *str);
-extern int root_mountflags;
-extern void _stext, _text, _etext, __data_start, _edata, _end;
+extern void _text, _etext, __data_start, _edata, _end;
 
 unsigned int processor_id;
 EXPORT_SYMBOL(processor_id);

commit 012d1f4af1b07e5ccfcd23b7c1dcdcc30a068257
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Sep 6 10:57:03 2008 +0100

    [ARM] move initrd code from kernel/setup.c to mm/init.c
    
    This quietens some sparse warnings about phys_initrd_start and
    phys_initrd_size.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 67d20e9a7451..f972fc3e979b 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -113,9 +113,6 @@ static struct stack stacks[NR_CPUS];
 char elf_platform[ELF_PLATFORM_SIZE];
 EXPORT_SYMBOL(elf_platform);
 
-unsigned long phys_initrd_start __initdata = 0;
-unsigned long phys_initrd_size __initdata = 0;
-
 static struct meminfo meminfo __initdata = { 0, };
 static const char *cpu_name;
 static const char *machine_name;
@@ -445,20 +442,6 @@ static struct machine_desc * __init setup_machine(unsigned int nr)
 	return list;
 }
 
-static void __init early_initrd(char **p)
-{
-	unsigned long start, size;
-
-	start = memparse(*p, p);
-	if (**p == ',') {
-		size = memparse((*p) + 1, p);
-
-		phys_initrd_start = start;
-		phys_initrd_size = size;
-	}
-}
-__early_param("initrd=", early_initrd);
-
 static void __init arm_add_memory(unsigned long start, unsigned long size)
 {
 	struct membank *bank;
@@ -696,26 +679,6 @@ static int __init parse_tag_ramdisk(const struct tag *tag)
 
 __tagtable(ATAG_RAMDISK, parse_tag_ramdisk);
 
-static int __init parse_tag_initrd(const struct tag *tag)
-{
-	printk(KERN_WARNING "ATAG_INITRD is deprecated; "
-		"please update your bootloader.\n");
-	phys_initrd_start = __virt_to_phys(tag->u.initrd.start);
-	phys_initrd_size = tag->u.initrd.size;
-	return 0;
-}
-
-__tagtable(ATAG_INITRD, parse_tag_initrd);
-
-static int __init parse_tag_initrd2(const struct tag *tag)
-{
-	phys_initrd_start = tag->u.initrd.start;
-	phys_initrd_size = tag->u.initrd.size;
-	return 0;
-}
-
-__tagtable(ATAG_INITRD2, parse_tag_initrd2);
-
 static int __init parse_tag_serialnr(const struct tag *tag)
 {
 	system_serial_low = tag->u.serialnr.low;

commit 09d9bae064724635df3920bcca47e077cfb23e76
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Sep 5 14:08:44 2008 +0100

    [ARM] sparse: fix several warnings
    
    arch/arm/kernel/process.c:270:6: warning: symbol 'show_fpregs' was not declared. Should it be static?
    
    This function isn't used, so can be removed.
    
    arch/arm/kernel/setup.c:532:9: warning: symbol 'len' shadows an earlier one
    arch/arm/kernel/setup.c:524:6: originally declared here
    
    A function containing two 'len's.
    
    arch/arm/mm/fault-armv.c:188:13: warning: symbol 'check_writebuffer_bugs' was not declared. Should it be static?
    arch/arm/mm/mmap.c:122:5: warning: symbol 'valid_phys_addr_range' was not declared. Should it be static?
    arch/arm/mm/mmap.c:137:5: warning: symbol 'valid_mmap_phys_addr_range' was not declared. Should it be static?
    
    Missing includes.
    
    arch/arm/kernel/traps.c:71:77: warning: Using plain integer as NULL pointer
    arch/arm/mm/ioremap.c:355:46: error: incompatible types in comparison expression (different address spaces)
    
    Sillies.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index e90422d374af..67d20e9a7451 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -529,12 +529,12 @@ static void __init parse_cmdline(char **cmdline_p, char *from)
 			struct early_params *p;
 
 			for (p = &__early_begin; p < &__early_end; p++) {
-				int len = strlen(p->arg);
+				int arglen = strlen(p->arg);
 
-				if (memcmp(from, p->arg, len) == 0) {
+				if (memcmp(from, p->arg, arglen) == 0) {
 					if (to != command_line)
 						to -= 1;
-					from += len;
+					from += arglen;
 					p->fn(&from);
 
 					while (*from != ' ' && *from != '\0')

commit 46097c7dd8bfaf9fb86565b6de45ab5a63afdd53
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Aug 10 18:10:19 2008 +0100

    [ARM] cachetype: move definitions to separate header
    
    Rather than pollute asm/cacheflush.h with the cache type definitions,
    move them to asm/cachetype.h, and include this new header where
    necessary.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index fb04703f2a8c..e90422d374af 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -32,6 +32,7 @@
 #include <asm/setup.h>
 #include <asm/mach-types.h>
 #include <asm/cacheflush.h>
+#include <asm/cachetype.h>
 #include <asm/tlbflush.h>
 
 #include <asm/mach/arch.h>

commit 0ba8b9b273c45dd23f60ff700e265a0069b33758
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Aug 10 18:08:10 2008 +0100

    [ARM] cputype: separate definitions, use them
    
    Add asm/cputype.h, moving functions and definitions from asm/system.h
    there.  Convert all users of 'processor_id' to the more efficient
    read_cpuid_id() function.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 2ca7038b67a7..fb04703f2a8c 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -26,6 +26,7 @@
 #include <linux/fs.h>
 
 #include <asm/cpu.h>
+#include <asm/cputype.h>
 #include <asm/elf.h>
 #include <asm/procinfo.h>
 #include <asm/setup.h>
@@ -280,9 +281,9 @@ static inline void dump_cache(const char *prefix, int cpu, unsigned int cache)
 
 static void __init dump_cpu_info(int cpu)
 {
-	unsigned int info = read_cpuid(CPUID_CACHETYPE);
+	unsigned int info = read_cpuid_cachetype();
 
-	if (info != processor_id) {
+	if (info != read_cpuid_id()) {
 		printk("CPU%u: D %s %s cache\n", cpu, cache_is_vivt() ? "VIVT" : "VIPT",
 		       cache_types[CACHE_TYPE(info)]);
 		if (CACHE_S(info)) {
@@ -301,15 +302,15 @@ int cpu_architecture(void)
 {
 	int cpu_arch;
 
-	if ((processor_id & 0x0008f000) == 0) {
+	if ((read_cpuid_id() & 0x0008f000) == 0) {
 		cpu_arch = CPU_ARCH_UNKNOWN;
-	} else if ((processor_id & 0x0008f000) == 0x00007000) {
-		cpu_arch = (processor_id & (1 << 23)) ? CPU_ARCH_ARMv4T : CPU_ARCH_ARMv3;
-	} else if ((processor_id & 0x00080000) == 0x00000000) {
-		cpu_arch = (processor_id >> 16) & 7;
+	} else if ((read_cpuid_id() & 0x0008f000) == 0x00007000) {
+		cpu_arch = (read_cpuid_id() & (1 << 23)) ? CPU_ARCH_ARMv4T : CPU_ARCH_ARMv3;
+	} else if ((read_cpuid_id() & 0x00080000) == 0x00000000) {
+		cpu_arch = (read_cpuid_id() >> 16) & 7;
 		if (cpu_arch)
 			cpu_arch += CPU_ARCH_ARMv3;
-	} else if ((processor_id & 0x000f0000) == 0x000f0000) {
+	} else if ((read_cpuid_id() & 0x000f0000) == 0x000f0000) {
 		unsigned int mmfr0;
 
 		/* Revised CPUID format. Read the Memory Model Feature
@@ -346,10 +347,10 @@ static void __init setup_processor(void)
 	 * types.  The linker builds this table for us from the
 	 * entries in arch/arm/mm/proc-*.S
 	 */
-	list = lookup_processor_type(processor_id);
+	list = lookup_processor_type(read_cpuid_id());
 	if (!list) {
 		printk("CPU configuration botched (ID %08x), unable "
-		       "to continue.\n", processor_id);
+		       "to continue.\n", read_cpuid_id());
 		while (1);
 	}
 
@@ -369,7 +370,7 @@ static void __init setup_processor(void)
 #endif
 
 	printk("CPU: %s [%08x] revision %d (ARMv%s), cr=%08lx\n",
-	       cpu_name, processor_id, (int)processor_id & 15,
+	       cpu_name, read_cpuid_id(), read_cpuid_id() & 15,
 	       proc_arch[cpu_architecture()], cr_alignment);
 
 	sprintf(init_utsname()->machine, "%s%c", list->arch_name, ENDIANNESS);
@@ -922,7 +923,7 @@ static int c_show(struct seq_file *m, void *v)
 	int i;
 
 	seq_printf(m, "Processor\t: %s rev %d (%s)\n",
-		   cpu_name, (int)processor_id & 15, elf_platform);
+		   cpu_name, read_cpuid_id() & 15, elf_platform);
 
 #if defined(CONFIG_SMP)
 	for_each_online_cpu(i) {
@@ -949,30 +950,30 @@ static int c_show(struct seq_file *m, void *v)
 		if (elf_hwcap & (1 << i))
 			seq_printf(m, "%s ", hwcap_str[i]);
 
-	seq_printf(m, "\nCPU implementer\t: 0x%02x\n", processor_id >> 24);
+	seq_printf(m, "\nCPU implementer\t: 0x%02x\n", read_cpuid_id() >> 24);
 	seq_printf(m, "CPU architecture: %s\n", proc_arch[cpu_architecture()]);
 
-	if ((processor_id & 0x0008f000) == 0x00000000) {
+	if ((read_cpuid_id() & 0x0008f000) == 0x00000000) {
 		/* pre-ARM7 */
-		seq_printf(m, "CPU part\t: %07x\n", processor_id >> 4);
+		seq_printf(m, "CPU part\t: %07x\n", read_cpuid_id() >> 4);
 	} else {
-		if ((processor_id & 0x0008f000) == 0x00007000) {
+		if ((read_cpuid_id() & 0x0008f000) == 0x00007000) {
 			/* ARM7 */
 			seq_printf(m, "CPU variant\t: 0x%02x\n",
-				   (processor_id >> 16) & 127);
+				   (read_cpuid_id() >> 16) & 127);
 		} else {
 			/* post-ARM7 */
 			seq_printf(m, "CPU variant\t: 0x%x\n",
-				   (processor_id >> 20) & 15);
+				   (read_cpuid_id() >> 20) & 15);
 		}
 		seq_printf(m, "CPU part\t: 0x%03x\n",
-			   (processor_id >> 4) & 0xfff);
+			   (read_cpuid_id() >> 4) & 0xfff);
 	}
-	seq_printf(m, "CPU revision\t: %d\n", processor_id & 15);
+	seq_printf(m, "CPU revision\t: %d\n", read_cpuid_id() & 15);
 
 	{
-		unsigned int cache_info = read_cpuid(CPUID_CACHETYPE);
-		if (cache_info != processor_id) {
+		unsigned int cache_info = read_cpuid_cachetype();
+		if (cache_info != read_cpuid_id()) {
 			seq_printf(m, "Cache type\t: %s\n"
 				      "Cache clean\t: %s\n"
 				      "Cache lockdown\t: %s\n"

commit 60296c71f6c5063e3c1f1d2619ca0b60940162e7
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Tue Aug 5 01:56:13 2008 +0200

    [ARM] prevent crashing when too much RAM installed
    
    This patch will truncate and/or ignore memory banks if their kernel
    direct mappings would (partially) overlap with the vmalloc area or
    the mappings between the vmalloc area and the address space top, to
    prevent crashing during early boot if there happens to be more RAM
    installed than we are expecting.
    
    Since the start of the vmalloc area is not at a fixed address (but
    the vmalloc end address is, via the per-platform VMALLOC_END define),
    a default area of 128M is reserved for vmalloc mappings, which can
    be shrunk or enlarged by passing an appropriate vmalloc= command line
    option as it is done on x86.
    
    On a board with a 3:1 user:kernel split, VMALLOC_END at 0xfe000000,
    two 512M RAM banks and vmalloc=128M (the default), this patch gives:
    
            Truncating RAM at 20000000-3fffffff to -35ffffff (vmalloc region overlap).
            Memory: 512MB 352MB = 864MB total
    
    On a board with a 3:1 user:kernel split, VMALLOC_END at 0xfe800000,
    two 256M RAM banks and vmalloc=768M, this patch gives:
    
            Truncating RAM at 00000000-0fffffff to -0e7fffff (vmalloc region overlap).
            Ignoring RAM at 10000000-1fffffff (vmalloc region overlap).
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Tested-by: Riku Voipio <riku.voipio@iki.fi>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 38f0e7940a13..2ca7038b67a7 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -81,6 +81,8 @@ EXPORT_SYMBOL(system_serial_high);
 unsigned int elf_hwcap;
 EXPORT_SYMBOL(elf_hwcap);
 
+unsigned long __initdata vmalloc_reserve = 128 << 20;
+
 
 #ifdef MULTI_CPU
 struct processor processor;
@@ -500,6 +502,17 @@ static void __init early_mem(char **p)
 }
 __early_param("mem=", early_mem);
 
+/*
+ * vmalloc=size forces the vmalloc area to be exactly 'size'
+ * bytes. This can be used to increase (or decrease) the vmalloc
+ * area - the default is 128m.
+ */
+static void __init early_vmalloc(char **arg)
+{
+	vmalloc_reserve = memparse(*arg, arg);
+}
+__early_param("vmalloc=", early_vmalloc);
+
 /*
  * Initial parsing of the command line.
  */

commit 5cbad0ebf45c5417104b383dc0e34f64fa7f2473
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Wed Feb 20 13:33:40 2008 -0600

    kgdb: support for ARCH=arm
    
    This patch adds the ARCH=arm specific a kgdb backend, originally
    written by Deepak Saxena <dsaxena@plexity.net> and George Davis
    <gdavis@mvista.com>.  Geoff Levand <geoffrey.levand@am.sony.com>,
    Nicolas Pitre, Manish Lachwani, and Jason Wessel have contributed
    various fixups here as well.
    
    The KGDB patch makes one change to the core ARM architecture such that
    the traps are initialized early for use with the debugger or other
    subsystems.
    
    [ mingo@elte.hu: small cleanups. ]
    [ ben-linux@fluff.org: fixed early_trap_init ]
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    Acked-by: Deepak Saxena <dsaxena@plexity.net>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index b7b0720bc1bb..38f0e7940a13 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -36,6 +36,7 @@
 #include <asm/mach/arch.h>
 #include <asm/mach/irq.h>
 #include <asm/mach/time.h>
+#include <asm/traps.h>
 
 #include "compat.h"
 #include "atags.h"
@@ -853,6 +854,7 @@ void __init setup_arch(char **cmdline_p)
 	conswitchp = &dummy_con;
 #endif
 #endif
+	early_trap_init();
 }
 
 

commit 2ffd6e182c4b9ae7bebc385c021e7d083bab406a
Author: Jan Engelhardt <jengelh@computergmbh.de>
Date:   Tue Jan 22 20:41:07 2008 +0100

    [ARM] constify function pointer tables
    
    Signed-off-by: Jan Engelhardt <jengelh@computergmbh.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index d3941a7b0455..b7b0720bc1bb 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -1001,7 +1001,7 @@ static void c_stop(struct seq_file *m, void *v)
 {
 }
 
-struct seq_operations cpuinfo_op = {
+const struct seq_operations cpuinfo_op = {
 	.start	= c_start,
 	.next	= c_next,
 	.stop	= c_stop,

commit 0d899e1b0000ddf78a75d7dcf9a9029d6f7f8091
Merge: a78de2f704a0 43816bcb7262 85e6c7a7dbdb 4cd9d6f774c7 c9a28fa7b9ac 41579f49da23
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Feb 4 17:54:39 2008 +0000

    Merge branches 'at91', 'ixp', 'master', 'misc', 'pxa' and 'realview' into devel
    
    * at91:
      [ARM] 4802/1: Fix typo and remove vague comment
      [ARM] 4660/3: at91: allow selecting UART for early kernel messages
      [ARM] 4739/1: at91sam9263: make gpio bank C and D irqs work
    
    * ixp:
      [ARM] 4809/2: ixp4xx: Merge dsmg600-power.c into dsmg600-setup.c
      [ARM] 4808/2: ixp4xx: Merge nas100d-power.c into nas100d-setup.c
      [ARM] 4807/2: ixp4xx: Merge nslu2-power.c into nslu2-setup.c
      [ARM] 4806/1: ixp4xx: Ethernet support for the nslu2 and nas100d boards
      [ARM] 4805/1: ixp4xx: Use leds-gpio driver instead of IXP4XX-GPIO-LED driver
      [ARM] 4715/2: Ethernet support for IXDP425 boards
      [ARM] 4714/2: Headers for IXP4xx built-in Ethernet and WAN drivers
      [ARM] 4713/3: Adds drivers for IXP4xx QMgr and NPE features
      [ARM] 4712/2: Adds functions to read and write IXP4xx "feature" bits
      [ARM] 4774/2: ixp4xx: Register dsmg600 rtc i2c_board_info
      [ARM] 4773/2: ixp4xx: Register nas100d rtc i2c_board_info
      [ARM] 4772/2: ixp4xx: Register nslu2 rtc i2c_board_info
      [ARM] 4769/2: ixp4xx: Button updates for the dsmg600 board
      [ARM] 4768/2: ixp4xx: Button and LED updates for the nas100d board
      [ARM] 4767/2: ixp4xx: Add bitops.h include to io.h
      [ARM] 4766/2: ixp4xx: Update ixp4xx_defconfig, enabling all supported boards
    
    * master:
      [ARM] 4810/1: - Fix 'section mismatch' building warnings
      [ARM] xtime_seqlock: fix more ARM machines for xtime deadlocking
      [ARM] 21285 serial: fix build error
    
    * misc:
      [ARM] 4736/1: Export atags to userspace and allow kexec to use customised atags
    
    * pxa:
      [ARM] 4798/1: pcm027: fix missing header file
      [ARM] 4803/1: pxa: fix building issue of poodle.c caused by patch 4737/1
      [ARM] 4801/1: pxa: fix building issues of missing pxa2xx-regs.h
      [ARM] pxa: introduce sysdev for pxa3xx static memory controller
      [ARM] pxa: add preliminary suspend/resume code for pxa3xx
      [ARM] pxa: introduce sysdev for GPIO register saving/restoring
      [ARM] pxa: introduce sysdev for IRQ register saving/restoring
      [ARM] pxa: fix the warning of undeclared "struct pxaohci_platform_data"
      [ARM] pxa: change set_kset_name() to direct name assignment for MFP sysclass
    
    * realview:
      [ARM] 4822/1: RealView: Change the REALVIEW_MPCORE configuration option
      [ARM] 4821/1: RealView: Remove the platform dependencies from localtimer.c
      [ARM] 4820/1: RealView: Select the timer IRQ at run-time
      [ARM] 4819/1: RealView: Fix entry-macro.S to work with multiple platforms
      [ARM] 4818/1: RealView: Add core-tile detection
      [ARM] 4817/1: RealView: Move the AMBA resource definitions to realview_eb.c
      [ARM] 4816/1: RealView: Move the platform-specific definitions into board-eb.h
      [ARM] 4815/1: RealView: Add clockevents suport for the local timers
      [ARM] 4814/1: RealView: Add broadcasting clockevents support for ARM11MPCore
      [ARM] 4813/1: Add SMP helper functions for clockevents support
      [ARM] 4812/1: RealView: clockevents support for the RealView platforms
      [ARM] 4811/1: RealView: clocksource support for the RealView platforms

commit 4cd9d6f774c7e0578bbc4409d4490d8f2097d40a
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Wed Jan 2 00:56:46 2008 +0100

    [ARM] 4736/1: Export atags to userspace and allow kexec to use customised atags
    
    Currently, the atags used by kexec are fixed to the ones originally used
    to boot the kernel. This is less than ideal as changing the commandline,
    initrd and other options would be a useful feature.
    
    This patch exports the atags used for the current kernel to userspace
    through an "atags" file in procfs. The presence of the file is
    controlled by its own Kconfig option and cleans up several ifdef blocks
    into a separate file. The tags for the new kernel are assumed to be at
    a fixed location before the kernel image itself. The location of the
    tags used to boot the original kernel is unimportant and no longer
    saved.
    
    Based on a patch from Uli Luckas <u.luckas@road.de>
    
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>
    Acked-by: Uli Luckas <u.luckas@road.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index bf56eb337df1..ae3712d39ab7 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -24,7 +24,6 @@
 #include <linux/interrupt.h>
 #include <linux/smp.h>
 #include <linux/fs.h>
-#include <linux/kexec.h>
 
 #include <asm/cpu.h>
 #include <asm/elf.h>
@@ -39,6 +38,7 @@
 #include <asm/mach/time.h>
 
 #include "compat.h"
+#include "atags.h"
 
 #ifndef MEM_SIZE
 #define MEM_SIZE	(16*1024*1024)
@@ -784,23 +784,6 @@ static int __init customize_machine(void)
 }
 arch_initcall(customize_machine);
 
-#ifdef CONFIG_KEXEC
-
-/* Physical addr of where the boot params should be for this machine */
-extern unsigned long kexec_boot_params_address;
-
-/* Physical addr of the buffer into which the boot params are copied */
-extern unsigned long kexec_boot_params_copy;
-
-/* Pointer to the boot params buffer, for manipulation and display */
-unsigned long kexec_boot_params;
-EXPORT_SYMBOL(kexec_boot_params);
-
-/* The buffer itself - make sure it is sized correctly */
-static unsigned long kexec_boot_params_buf[(KEXEC_BOOT_PARAMS_SIZE + 3) / 4];
-
-#endif
-
 void __init setup_arch(char **cmdline_p)
 {
 	struct tag *tags = (struct tag *)&init_tags;
@@ -819,18 +802,6 @@ void __init setup_arch(char **cmdline_p)
 	else if (mdesc->boot_params)
 		tags = phys_to_virt(mdesc->boot_params);
 
-#ifdef CONFIG_KEXEC
-	kexec_boot_params_copy = virt_to_phys(kexec_boot_params_buf);
-	kexec_boot_params = (unsigned long)kexec_boot_params_buf;
-	if (__atags_pointer) {
-		kexec_boot_params_address = __atags_pointer;
-		memcpy((void *)kexec_boot_params, tags, KEXEC_BOOT_PARAMS_SIZE);
-	} else if (mdesc->boot_params) {
-		kexec_boot_params_address = mdesc->boot_params;
-		memcpy((void *)kexec_boot_params, tags, KEXEC_BOOT_PARAMS_SIZE);
-	}
-#endif
-
 	/*
 	 * If we have the old style parameters, convert them to
 	 * a tag list.
@@ -846,6 +817,7 @@ void __init setup_arch(char **cmdline_p)
 	if (tags->hdr.tag == ATAG_CORE) {
 		if (meminfo.nr_banks != 0)
 			squash_mem_tags(tags);
+		save_atags(tags);
 		parse_tags(tags);
 	}
 

commit c18f65816ef80b67eb4511ed8359c2dfcd69680d
Author: Krzysztof Halasa <khc@pm.waw.pl>
Date:   Tue Dec 18 03:53:27 2007 +0100

    [ARM] 4712/2: Adds functions to read and write IXP4xx "feature" bits
    
    Adds functions to read and write IXP4xx "feature" (aka "fuse")
    bits, containing information about available/enabled CPU features.
    
    The uncompress.h included by boot/compressed/misc.c resides in
    a different space than rest of the kernel and thus can't use
    asm/hardware.h (including asm/arch/cpu.h - which, in turn, may use
    EXPORTed symbol "processor_id").
    
    Posted to linux-arm-kernel on 2 Dec 2007 and revised.
    
    Signed-off-by: Krzysztof Halasa <khc@pm.waw.pl>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index bf56eb337df1..dd37901f786a 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -62,6 +62,7 @@ extern int root_mountflags;
 extern void _stext, _text, _etext, __data_start, _edata, _end;
 
 unsigned int processor_id;
+EXPORT_SYMBOL(processor_id);
 unsigned int __machine_arch_type;
 EXPORT_SYMBOL(__machine_arch_type);
 

commit 033b8ffe3f1ea8174d51d125838ac6deea60f63f
Author: Mike Westerhof <mwester@dls.net>
Date:   Thu Oct 11 03:18:14 2007 +0100

    [ARM] 4599/1: Preserve ATAG list for use with kexec (2.6.23)
    
    This patch resolves a kexec boot failure that can occur because
    no ATAGs are passed in to the kexec'd kernel. Currently the
    newly-kexec'd kernel may fail if it requires specific ATAGs, or
    it may fail because the fixed memory location at which it expects
    to find the ATAGs may contain random data instead of ATAGs.
    
    The patch ensures that any ATAGs passed to the current kernel
    at boot time are copied to a static buffer, and are copied back
    when kexec copies the new kernel into place. Thus the new
    kernel sees the same ATAGs from kexec and the boot loader.
    
    The boot parameters are copied without regard to type, content,
    or length -- this patch's scope is limited soley to saving and
    restoring a fixed-size block of memory containing the kernel's
    boot parameters. Additional functionality to examine, alter, or
    replace the ATAGs (using kexec, for example) can be implemented
    by manipulating the static buffer containing the preserved ATAGs.
    
    Note: the size of the buffer (1.5KB) is selected to comfortably
    hold one of each ATAG type, including a maximum-length command
    line and the maximum number of ATAG_MEM structures currently
    supported by the kernel. Should an ATAG list exceed that limit,
    the list will be silently truncated to that limit (to do other-
    wise at that point in the boot process would make a simple
    problem exceedingly complicated).
    
    [Note: this is the same patch as 4579, modified to accomodate
    the ATAG changes introduced in 2.6.23]
    
    Signed-off-by: Mike Westerhof <mwester at dls.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index efac7df72d65..bf56eb337df1 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -24,6 +24,7 @@
 #include <linux/interrupt.h>
 #include <linux/smp.h>
 #include <linux/fs.h>
+#include <linux/kexec.h>
 
 #include <asm/cpu.h>
 #include <asm/elf.h>
@@ -783,6 +784,23 @@ static int __init customize_machine(void)
 }
 arch_initcall(customize_machine);
 
+#ifdef CONFIG_KEXEC
+
+/* Physical addr of where the boot params should be for this machine */
+extern unsigned long kexec_boot_params_address;
+
+/* Physical addr of the buffer into which the boot params are copied */
+extern unsigned long kexec_boot_params_copy;
+
+/* Pointer to the boot params buffer, for manipulation and display */
+unsigned long kexec_boot_params;
+EXPORT_SYMBOL(kexec_boot_params);
+
+/* The buffer itself - make sure it is sized correctly */
+static unsigned long kexec_boot_params_buf[(KEXEC_BOOT_PARAMS_SIZE + 3) / 4];
+
+#endif
+
 void __init setup_arch(char **cmdline_p)
 {
 	struct tag *tags = (struct tag *)&init_tags;
@@ -801,6 +819,18 @@ void __init setup_arch(char **cmdline_p)
 	else if (mdesc->boot_params)
 		tags = phys_to_virt(mdesc->boot_params);
 
+#ifdef CONFIG_KEXEC
+	kexec_boot_params_copy = virt_to_phys(kexec_boot_params_buf);
+	kexec_boot_params = (unsigned long)kexec_boot_params_buf;
+	if (__atags_pointer) {
+		kexec_boot_params_address = __atags_pointer;
+		memcpy((void *)kexec_boot_params, tags, KEXEC_BOOT_PARAMS_SIZE);
+	} else if (mdesc->boot_params) {
+		kexec_boot_params_address = mdesc->boot_params;
+		memcpy((void *)kexec_boot_params, tags, KEXEC_BOOT_PARAMS_SIZE);
+	}
+#endif
+
 	/*
 	 * If we have the old style parameters, convert them to
 	 * a tag list.

commit 180005c4efb76a81fd0abcef4c2412d238eea20c
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Tue Sep 25 16:49:45 2007 +0100

    [ARM] 4585/1: Correctly identify the CPU architecture version
    
    The cpu_architecture() function in arch/arm/kernel/setup.c only works
    with cores produced by ARM Ltd. The more generic approach is to read
    the ID_MMFR0 register and check for the VMSA or PMSA version
    supported. With this patch, the ARM11MPCore would be reported as ARMv7
    since its MMU is compatible with ARMv7.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 4de432ec903a..efac7df72d65 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -304,10 +304,23 @@ int cpu_architecture(void)
 		cpu_arch = (processor_id >> 16) & 7;
 		if (cpu_arch)
 			cpu_arch += CPU_ARCH_ARMv3;
-	} else {
-		/* the revised CPUID */
-		cpu_arch = ((processor_id >> 12) & 0xf) - 0xb + CPU_ARCH_ARMv6;
-	}
+	} else if ((processor_id & 0x000f0000) == 0x000f0000) {
+		unsigned int mmfr0;
+
+		/* Revised CPUID format. Read the Memory Model Feature
+		 * Register 0 and check for VMSAv7 or PMSAv7 */
+		asm("mrc	p15, 0, %0, c0, c1, 4"
+		    : "=r" (mmfr0));
+		if ((mmfr0 & 0x0000000f) == 0x00000003 ||
+		    (mmfr0 & 0x000000f0) == 0x00000030)
+			cpu_arch = CPU_ARCH_ARMv7;
+		else if ((mmfr0 & 0x0000000f) == 0x00000002 ||
+			 (mmfr0 & 0x000000f0) == 0x00000020)
+			cpu_arch = CPU_ARCH_ARMv6;
+		else
+			cpu_arch = CPU_ARCH_UNKNOWN;
+	} else
+		cpu_arch = CPU_ARCH_UNKNOWN;
 
 	return cpu_arch;
 }

commit 4e950f6f0189f65f8bf069cf2272649ef418f5e4
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Jul 30 02:36:13 2007 +0400

    Remove fs.h from mm.h
    
    Remove fs.h from mm.h. For this,
     1) Uninline vma_wants_writenotify(). It's pretty huge anyway.
     2) Add back fs.h or less bloated headers (err.h) to files that need it.
    
    As result, on x86_64 allyesconfig, fs.h dependencies cut down from 3929 files
    rebuilt down to 3444 (-12.3%).
    
    Cross-compile tested without regressions on my two usual configs and (sigh):
    
    alpha              arm-mx1ads        mips-bigsur          powerpc-ebony
    alpha-allnoconfig  arm-neponset      mips-capcella        powerpc-g5
    alpha-defconfig    arm-netwinder     mips-cobalt          powerpc-holly
    alpha-up           arm-netx          mips-db1000          powerpc-iseries
    arm                arm-ns9xxx        mips-db1100          powerpc-linkstation
    arm-assabet        arm-omap_h2_1610  mips-db1200          powerpc-lite5200
    arm-at91rm9200dk   arm-onearm        mips-db1500          powerpc-maple
    arm-at91rm9200ek   arm-picotux200    mips-db1550          powerpc-mpc7448_hpc2
    arm-at91sam9260ek  arm-pleb          mips-ddb5477         powerpc-mpc8272_ads
    arm-at91sam9261ek  arm-pnx4008       mips-decstation      powerpc-mpc8313_rdb
    arm-at91sam9263ek  arm-pxa255-idp    mips-e55             powerpc-mpc832x_mds
    arm-at91sam9rlek   arm-realview      mips-emma2rh         powerpc-mpc832x_rdb
    arm-ateb9200       arm-realview-smp  mips-excite          powerpc-mpc834x_itx
    arm-badge4         arm-rpc           mips-fulong          powerpc-mpc834x_itxgp
    arm-carmeva        arm-s3c2410       mips-ip22            powerpc-mpc834x_mds
    arm-cerfcube       arm-shannon       mips-ip27            powerpc-mpc836x_mds
    arm-clps7500       arm-shark         mips-ip32            powerpc-mpc8540_ads
    arm-collie         arm-simpad        mips-jazz            powerpc-mpc8544_ds
    arm-corgi          arm-spitz         mips-jmr3927         powerpc-mpc8560_ads
    arm-csb337         arm-trizeps4      mips-malta           powerpc-mpc8568mds
    arm-csb637         arm-versatile     mips-mipssim         powerpc-mpc85xx_cds
    arm-ebsa110        i386              mips-mpc30x          powerpc-mpc8641_hpcn
    arm-edb7211        i386-allnoconfig  mips-msp71xx         powerpc-mpc866_ads
    arm-em_x270        i386-defconfig    mips-ocelot          powerpc-mpc885_ads
    arm-ep93xx         i386-up           mips-pb1100          powerpc-pasemi
    arm-footbridge     ia64              mips-pb1500          powerpc-pmac32
    arm-fortunet       ia64-allnoconfig  mips-pb1550          powerpc-ppc64
    arm-h3600          ia64-bigsur       mips-pnx8550-jbs     powerpc-prpmc2800
    arm-h7201          ia64-defconfig    mips-pnx8550-stb810  powerpc-ps3
    arm-h7202          ia64-gensparse    mips-qemu            powerpc-pseries
    arm-hackkit        ia64-sim          mips-rbhma4200       powerpc-up
    arm-integrator     ia64-sn2          mips-rbhma4500       s390
    arm-iop13xx        ia64-tiger        mips-rm200           s390-allnoconfig
    arm-iop32x         ia64-up           mips-sb1250-swarm    s390-defconfig
    arm-iop33x         ia64-zx1          mips-sead            s390-up
    arm-ixp2000        m68k              mips-tb0219          sparc
    arm-ixp23xx        m68k-amiga        mips-tb0226          sparc-allnoconfig
    arm-ixp4xx         m68k-apollo       mips-tb0287          sparc-defconfig
    arm-jornada720     m68k-atari        mips-workpad         sparc-up
    arm-kafa           m68k-bvme6000     mips-wrppmc          sparc64
    arm-kb9202         m68k-hp300        mips-yosemite        sparc64-allnoconfig
    arm-ks8695         m68k-mac          parisc               sparc64-defconfig
    arm-lart           m68k-mvme147      parisc-allnoconfig   sparc64-up
    arm-lpd270         m68k-mvme16x      parisc-defconfig     um-x86_64
    arm-lpd7a400       m68k-q40          parisc-up            x86_64
    arm-lpd7a404       m68k-sun3         powerpc              x86_64-allnoconfig
    arm-lubbock        m68k-sun3x        powerpc-cell         x86_64-defconfig
    arm-lusl7200       mips              powerpc-celleb       x86_64-up
    arm-mainstone      mips-atlas        powerpc-chrp32
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 5be2e987b843..4de432ec903a 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -23,6 +23,7 @@
 #include <linux/cpu.h>
 #include <linux/interrupt.h>
 #include <linux/smp.h>
+#include <linux/fs.h>
 
 #include <asm/cpu.h>
 #include <asm/elf.h>

commit 9d20fdd58e74d4d26dc5216efaaa0f800c23dd3a
Author: Bill Gatliff <bgat@billgatliff.com>
Date:   Thu May 31 22:02:22 2007 +0100

    [ARM] 4423/1: add ATAGS support
    
    Examines the ATAGS pointer (r2) at boot, and interprets
    a nonzero value as a reference to an ATAGS structure. A
    suitable ATAGS structure replaces the kernel's command line.
    
    Signed-off-by: Bill Gatliff <bgat@billgatliff.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 650eac1bc0a6..5be2e987b843 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -63,6 +63,8 @@ unsigned int processor_id;
 unsigned int __machine_arch_type;
 EXPORT_SYMBOL(__machine_arch_type);
 
+unsigned int __atags_pointer __initdata;
+
 unsigned int system_rev;
 EXPORT_SYMBOL(system_rev);
 
@@ -780,7 +782,9 @@ void __init setup_arch(char **cmdline_p)
 	if (mdesc->soft_reboot)
 		reboot_setup("s");
 
-	if (mdesc->boot_params)
+	if (__atags_pointer)
+		tags = phys_to_virt(__atags_pointer);
+	else if (mdesc->boot_params)
 		tags = phys_to_virt(mdesc->boot_params);
 
 	/*

commit 1d28bff7c4ea138032b44d514351b7caceb9fba5
Author: Greg Ungerer <gerg@snapgear.com>
Date:   Thu May 17 06:12:22 2007 +0100

    [ARM] 4387/1: fix /proc/cpuinfo formatting for pre-ARM7 parts
    
    Fix the formating of the "CPU part" field to be consistent with
    the other fields for pre-ARM7 parts. One tab to many for them to
    all line up.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 0453dcc757b4..650eac1bc0a6 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -918,7 +918,7 @@ static int c_show(struct seq_file *m, void *v)
 
 	if ((processor_id & 0x0008f000) == 0x00000000) {
 		/* pre-ARM7 */
-		seq_printf(m, "CPU part\t\t: %07x\n", processor_id >> 4);
+		seq_printf(m, "CPU part\t: %07x\n", processor_id >> 4);
 	} else {
 		if ((processor_id & 0x0008f000) == 0x00007000) {
 			/* ARM7 */

commit 66fb8bd209926140844830762164a44afdbf44ef
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Mar 13 09:54:21 2007 +0000

    [ARM] Fix breakage caused by 72486f1f8f0a2bc828b9d30cf4690cf2dd6807fc
    
    72486f1f8f0a2bc828b9d30cf4690cf2dd6807fc inverted the sense for
    enabling hotplug CPU controls without reference to any other
    architecture other than i386, ia64 and PowerPC.  This left
    everyone else without hotplug CPU control.
    
    Fix ARM for this brain damage.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 03e37af315d7..0453dcc757b4 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -839,8 +839,11 @@ static int __init topology_init(void)
 {
 	int cpu;
 
-	for_each_possible_cpu(cpu)
-		register_cpu(&per_cpu(cpu_data, cpu).cpu, cpu);
+	for_each_possible_cpu(cpu) {
+		struct cpuinfo_arm *cpuinfo = &per_cpu(cpu_data, cpu);
+		cpuinfo->cpu.hotpluggable = 1;
+		register_cpu(&cpuinfo->cpu, cpu);
+	}
 
 	return 0;
 }

commit 59b8175c771040afcd4ad67022b0cc80c216b866
Merge: 920841d8d1d6 3b0eb4a195a1
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Mon Feb 19 13:18:39 2007 -0800

    Merge branch 'for-linus' of master.kernel.org:/home/rmk/linux-2.6-arm
    
    * 'for-linus' of master.kernel.org:/home/rmk/linux-2.6-arm: (117 commits)
      [ARM] 4058/2: iop32x: set ->broken_parity_status on n2100 onboard r8169 ports
      [ARM] 4140/1: AACI stability add ac97 timeout and retries
      [ARM] 4139/1: AACI record support
      [ARM] 4138/1: AACI: multiple channel support for IRQ handling
      [ARM] 4211/1: Provide a defconfig for ns9xxx
      [ARM] 4210/1: base for new machine type "NetSilicon NS9360"
      [ARM] 4222/1: S3C2443: Remove reference to missing S3C2443_PM
      [ARM] 4221/1: S3C2443: DMA support
      [ARM] 4220/1: S3C24XX: DMA system initialised from sysdev
      [ARM] 4219/1: S3C2443: DMA source definitions
      [ARM] 4218/1: S3C2412: fix CONFIG_CPU_S3C2412_ONLY wrt to S3C2443
      [ARM] 4217/1: S3C24XX: remove the dma channel show at startup
      [ARM] 4090/2: avoid clash between PXA and SA1111 defines
      [ARM] 4216/1: add .gitignore entries for ARM specific files
      [ARM] 4214/2: S3C2410: Add Armzone QT2410
      [ARM] 4215/1: s3c2410 usb device:  per-platform vbus_draw
      [ARM] 4213/1: S3C2410 - Update definition of ADCTSC_XY_PST
      [ARM] 4098/1: ARM: rtc_lock only used with rtc_cmos
      [ARM] 4137/1: Add kexec support
      [ARM] 4201/1: SMP barriers pair needed for the secondary boot process
      ...
    
    Fix up conflict due to typedef removal in sound/arm/aaci.h

commit cd81899a7d9e77ffd5280b10d0413fb241b18388
Author: Alon Bar-Lev <alon.barlev@gmail.com>
Date:   Mon Feb 12 00:54:06 2007 -0800

    [PATCH] Dynamic kernel command-line: arm
    
    1. Rename saved_command_line into boot_command_line.
    2. Set command_line as __initdata.
    
    Signed-off-by: Alon Bar-Lev <alon.barlev@gmail.com>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index bbab134cd82d..ed522151878b 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -106,7 +106,7 @@ unsigned long phys_initrd_size __initdata = 0;
 static struct meminfo meminfo __initdata = { 0, };
 static const char *cpu_name;
 static const char *machine_name;
-static char command_line[COMMAND_LINE_SIZE];
+static char __initdata command_line[COMMAND_LINE_SIZE];
 
 static char default_command_line[COMMAND_LINE_SIZE] __initdata = CONFIG_CMDLINE;
 static union { char c[4]; unsigned long l; } endian_test __initdata = { { 'l', '?', '?', 'b' } };
@@ -803,8 +803,8 @@ void __init setup_arch(char **cmdline_p)
 	init_mm.end_data   = (unsigned long) &_edata;
 	init_mm.brk	   = (unsigned long) &_end;
 
-	memcpy(saved_command_line, from, COMMAND_LINE_SIZE);
-	saved_command_line[COMMAND_LINE_SIZE-1] = '\0';
+	memcpy(boot_command_line, from, COMMAND_LINE_SIZE);
+	boot_command_line[COMMAND_LINE_SIZE-1] = '\0';
 	parse_cmdline(cmdline_p, from);
 	paging_init(&meminfo, mdesc);
 	request_standard_resources(&meminfo, mdesc);

commit 953233dc9958ba2b29753d0f24e37a33a076a5f6
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Mon Feb 5 14:48:08 2007 +0100

    [ARM] 4134/1: Add generic support for outer caches
    
    The outer cache can be L2 as on RealView/EB MPCore platform or even L3
    or further on ARMv7 cores. This patch adds the generic support for
    flushing the outer cache in the DMA operations.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index bbab134cd82d..243aea458057 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -88,6 +88,9 @@ struct cpu_user_fns cpu_user;
 #ifdef MULTI_CACHE
 struct cpu_cache_fns cpu_cache;
 #endif
+#ifdef CONFIG_OUTER_CACHE
+struct outer_cache_fns outer_cache;
+#endif
 
 struct stack {
 	u32 irq[3];

commit 99e4a6dda9dc4b863773c0a5857b762474b817cf
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Mon Dec 18 00:59:10 2006 +0100

    [ARM] 4054/1: ep93xx: add HWCAP_CRUNCH
    
    Add HWCAP_CRUNCH so that the dynamic linker knows whether it can
    use Crunch-optimised libraries or not.
    
    Signed-off-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index cf2bd4242803..bbab134cd82d 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -855,6 +855,7 @@ static const char *hwcap_str[] = {
 	"edsp",
 	"java",
 	"iwmmxt",
+	"crunch",
 	NULL
 };
 

commit efe90d273b6f365d37c0f82fbbd68a40982c3265
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Dec 8 15:22:20 2006 +0000

    [ARM] Handle HWCAP_VFP in VFP support code
    
    Don't set HWCAP_VFP in the processor support file; not only does it
    depend on the processor features, but it also depends on the support
    code being present.  Therefore, only set it if the support code
    detects that we have a VFP coprocessor attached.
    
    Also, move the VFP handling of the coprocessor access register into
    the VFP support code.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 238dd9b6db84..cf2bd4242803 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -354,9 +354,6 @@ static void __init setup_processor(void)
 #ifndef CONFIG_ARM_THUMB
 	elf_hwcap &= ~HWCAP_THUMB;
 #endif
-#ifndef CONFIG_VFP
-	elf_hwcap &= ~HWCAP_VFP;
-#endif
 
 	cpu_proc_init();
 }

commit 6705cda24fad1cb0ac82ac4f312df8ec735b39b0
Merge: 0215ffb08ce9 208a49f086ed d4f3e084adf5 05f96ef1189e 2dc20a51dc1e 47d7e524b7d5 285f5fa7e9a3
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Dec 7 23:07:26 2006 +0000

    [ARM] Merge individual ARM sub-trees
    
    Merge:
     Atmel AT91RM9200 and AT91SAM9260 changes
     General ARM developments
     Disconfiguous memory cleanups
     64-bit/32-bit division and sched_clock extension patches
     EP93xx support changes
     IOP support changes
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit 05f96ef1189ecbf2e8548056a0ca016e4f630cef
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Nov 30 20:44:49 2006 +0000

    [ARM] Allow gcc to optimise arm_add_memory a little more
    
    For some reason, gcc was calculating meminfo.bank[meminfo.nr_banks]
    repeatedly.  Use a pointer to it instead.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 29efc9f82057..75f1764933ab 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -441,16 +441,19 @@ __early_param("initrd=", early_initrd);
 
 static void __init arm_add_memory(unsigned long start, unsigned long size)
 {
+	struct membank *bank;
+
 	/*
 	 * Ensure that start/size are aligned to a page boundary.
 	 * Size is appropriately rounded down, start is rounded up.
 	 */
 	size -= start & ~PAGE_MASK;
 
-	meminfo.bank[meminfo.nr_banks].start = PAGE_ALIGN(start);
-	meminfo.bank[meminfo.nr_banks].size  = size & PAGE_MASK;
-	meminfo.bank[meminfo.nr_banks].node  = PHYS_TO_NID(start);
-	meminfo.nr_banks += 1;
+	bank = &meminfo.bank[meminfo.nr_banks++];
+
+	bank->start = PAGE_ALIGN(start);
+	bank->size  = size & PAGE_MASK;
+	bank->node  = PHYS_TO_NID(start);
 }
 
 /*

commit afe4b25e7d9260d85fccb2d13c9933a987bdfc8a
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Sun Dec 3 18:51:14 2006 +0100

    [ARM] 3881/4: xscale: clean up cp0/cp1 handling
    
    XScale cores either have a DSP coprocessor (which contains a single
    40 bit accumulator register), or an iWMMXt coprocessor (which contains
    eight 64 bit registers.)
    
    Because of the small amount of state in the DSP coprocessor, access to
    the DSP coprocessor (CP0) is always enabled, and DSP context switching
    is done unconditionally on every task switch.  Access to the iWMMXt
    coprocessor (CP0/CP1) is enabled only when an iWMMXt instruction is
    first issued, and iWMMXt context switching is done lazily.
    
    CONFIG_IWMMXT is supposed to mean 'the cpu we will be running on will
    have iWMMXt support', but boards are supposed to select this config
    symbol by hand, and at least one pxa27x board doesn't get this right,
    so on that board, proc-xscale.S will incorrectly assume that we have a
    DSP coprocessor, enable CP0 on boot, and we will then only save the
    first iWMMXt register (wR0) on context switches, which is Bad.
    
    This patch redefines CONFIG_IWMMXT as 'the cpu we will be running on
    might have iWMMXt support, and we will enable iWMMXt context switching
    if it does.'  This means that with this patch, running a CONFIG_IWMMXT=n
    kernel on an iWMMXt-capable CPU will no longer potentially corrupt iWMMXt
    state over context switches, and running a CONFIG_IWMMXT=y kernel on a
    non-iWMMXt capable CPU will still do DSP context save/restore.
    
    These changes should make iWMMXt work on PXA3xx, and as a side effect,
    enable proper acc0 save/restore on non-iWMMXt capable xsc3 cores such
    as IOP13xx and IXP23xx (which will not have CONFIG_CPU_XSCALE defined),
    as well as setting and using HWCAP_IWMMXT properly.
    
    Signed-off-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Acked-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 29efc9f82057..6f12d2686aaf 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -357,9 +357,6 @@ static void __init setup_processor(void)
 #ifndef CONFIG_VFP
 	elf_hwcap &= ~HWCAP_VFP;
 #endif
-#ifndef CONFIG_IWMMXT
-	elf_hwcap &= ~HWCAP_IWMMXT;
-#endif
 
 	cpu_proc_init();
 }

commit 8f7f9435e6df0985c877d10259393bdfaac3655f
Author: Paul Gortmaker <paul.gortmaker@com.rmk.(none)>
Date:   Fri Oct 27 05:13:19 2006 +0100

    [ARM] 3912/1: Make PXA270 advertise HWCAP_IWMMXT capability
    
    ARM patch 3756/1 added HWCAP_IWMMXT.  This patch adds support
    for broadcasting that info via /proc/cpuinfo and sets it for
    the CPU features of the PXA270.
    
    I've booted 19rc3 on a pxa270 and confirmed that the /proc/cpuinfo
    shows "iwmmxt" in the Features.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Nicolas Pitre <nico@cam.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 6bbd93dd186a..29efc9f82057 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -357,6 +357,9 @@ static void __init setup_processor(void)
 #ifndef CONFIG_VFP
 	elf_hwcap &= ~HWCAP_VFP;
 #endif
+#ifndef CONFIG_IWMMXT
+	elf_hwcap &= ~HWCAP_IWMMXT;
+#endif
 
 	cpu_proc_init();
 }
@@ -854,6 +857,7 @@ static const char *hwcap_str[] = {
 	"vfp",
 	"edsp",
 	"java",
+	"iwmmxt",
 	NULL
 };
 

commit 96b644bdec977b97a45133e5b4466ba47a7a5e65
Author: Serge E. Hallyn <serue@us.ibm.com>
Date:   Mon Oct 2 02:18:13 2006 -0700

    [PATCH] namespaces: utsname: use init_utsname when appropriate
    
    In some places, particularly drivers and __init code, the init utsns is the
    appropriate one to use.  This patch replaces those with a the init_utsname
    helper.
    
    Changes: Removed several uses of init_utsname().  Hope I picked all the
            right ones in net/ipv4/ipconfig.c.  These are now changed to
            utsname() (the per-process namespace utsname) in the previous
            patch (2/7)
    
    [akpm@osdl.org: CIFS fix]
    Signed-off-by: Serge E. Hallyn <serue@us.ibm.com>
    Cc: Kirill Korotaev <dev@openvz.org>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Herbert Poetzl <herbert@13thfloor.at>
    Cc: Andrey Savochkin <saw@sw.ru>
    Cc: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 0a722e77c143..6bbd93dd186a 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -348,7 +348,7 @@ static void __init setup_processor(void)
 	       cpu_name, processor_id, (int)processor_id & 15,
 	       proc_arch[cpu_architecture()], cr_alignment);
 
-	sprintf(system_utsname.machine, "%s%c", list->arch_name, ENDIANNESS);
+	sprintf(init_utsname()->machine, "%s%c", list->arch_name, ENDIANNESS);
 	sprintf(elf_platform, "%s%c", list->elf_name, ENDIANNESS);
 	elf_hwcap = list->elf_hwcap;
 #ifndef CONFIG_ARM_THUMB

commit 894673ee6122a3ce1958e1fe096901ba5356a96b
Author: Jon Smirl <jonsmir@gmail.com>
Date:   Mon Jul 10 04:44:13 2006 -0700

    [PATCH] tty: Remove include of screen_info.h from tty.h
    
    screen_info.h doesn't have anything to do with the tty layer and shouldn't be
    included by tty.h.  This patches removes the include and modifies all users to
    directly include screen_info.h.  struct screen_info is mainly used to
    communicate with the console drivers in drivers/video/console.  Note that this
    patch touches every arch and I have no way of testing it.  If there is a
    mistake the worst thing that will happen is a compile error.
    
    [akpm@osdl.org: fix arm build]
    [akpm@osdl.org: fix alpha build]
    Signed-off-by: Jon Smirl <jonsmir@gmail.com>
    Signed-off-by: Antonino Daplas <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index ed1c4d62d999..0a722e77c143 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -17,7 +17,7 @@
 #include <linux/console.h>
 #include <linux/bootmem.h>
 #include <linux/seq_file.h>
-#include <linux/tty.h>
+#include <linux/screen_info.h>
 #include <linux/init.h>
 #include <linux/root_dev.h>
 #include <linux/cpu.h>

commit 4e19025bc7be18e4d1dc8d1fde06c2d23927eb4d
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Jul 3 13:29:38 2006 +0100

    [ARM] Fix warnings in arch/arm/kernel/setup.c
    
    cr_alignment is unsigned long, so should be the format string.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 7d6a516c0b9f..ed1c4d62d999 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -344,7 +344,7 @@ static void __init setup_processor(void)
 	cpu_cache = *list->cache;
 #endif
 
-	printk("CPU: %s [%08x] revision %d (ARMv%s), cr=%08x\n",
+	printk("CPU: %s [%08x] revision %d (ARMv%s), cr=%08lx\n",
 	       cpu_name, processor_id, (int)processor_id & 15,
 	       proc_arch[cpu_architecture()], cr_alignment);
 

commit a8c4c20dfa8b28a3c99e33c639d9c2ea5657741e
Merge: 168d04b3b4de 2dc7667b9d06
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Sun Jul 2 15:04:12 2006 -0700

    Merge branch 'devel' of master.kernel.org:/home/rmk/linux-2.6-arm
    
    * 'devel' of master.kernel.org:/home/rmk/linux-2.6-arm: (44 commits)
      [ARM] 3541/2: workaround for PXA27x erratum E7
      [ARM] nommu: provide a way for correct control register value selection
      [ARM] 3705/1: add supersection support to ioremap()
      [ARM] 3707/1: iwmmxt: use the generic thread notifier infrastructure
      [ARM] 3706/2: ep93xx: add cirrus logic edb9315a support
      [ARM] 3704/1: format IOP Kconfig with tabs, create more consistency
      [ARM] 3703/1: Add help description for ARCH_EP80219
      [ARM] 3678/1: MMC: Make OMAP MMC work
      [ARM] 3677/1: OMAP: Update H2 defconfig
      [ARM] 3676/1: ARM: OMAP: Fix dmtimers and timer32k to compile on OMAP1
      [ARM] Add section support to ioremap
      [ARM] Fix sa11x0 SDRAM selection
      [ARM] Set bit 4 on section mappings correctly depending on CPU
      [ARM] 3666/1: TRIZEPS4 [1/5] core
      ARM: OMAP: Multiplexing for 24xx GPMC wait pin monitoring
      ARM: OMAP: Fix SRAM to use MT_MEMORY instead of MT_DEVICE
      ARM: OMAP: Update dmtimers
      ARM: OMAP: Make clock variables static
      ARM: OMAP: Fix GPMC compilation when DEBUG is defined
      ARM: OMAP: Mux updates for external DMA and GPIO
      ...

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 6bdf70def01f..7447a1987322 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -7,7 +7,6 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/stddef.h>

commit 1903ac54f8536b11478e4f01c339e10b538f59e0
Merge: 47c2a3aa4475 87937472ff8e
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Thu Jun 29 10:49:17 2006 -0700

    Merge master.kernel.org:/pub/scm/linux/kernel/git/gregkh/pci-2.6
    
    * master.kernel.org:/pub/scm/linux/kernel/git/gregkh/pci-2.6:
      [PATCH] i386: export memory more than 4G through /proc/iomem
      [PATCH] 64bit Resource: finally enable 64bit resource sizes
      [PATCH] 64bit Resource: convert a few remaining drivers to use resource_size_t where needed
      [PATCH] 64bit resource: change pnp core to use resource_size_t
      [PATCH] 64bit resource: change pci core and arch code to use resource_size_t
      [PATCH] 64bit resource: change resource core to use resource_size_t
      [PATCH] 64bit resource: introduce resource_size_t for the start and end of struct resource
      [PATCH] 64bit resource: fix up printks for resources in misc drivers
      [PATCH] 64bit resource: fix up printks for resources in arch and core code
      [PATCH] 64bit resource: fix up printks for resources in pcmcia drivers
      [PATCH] 64bit resource: fix up printks for resources in video drivers
      [PATCH] 64bit resource: fix up printks for resources in ide drivers
      [PATCH] 64bit resource: fix up printks for resources in mtd drivers
      [PATCH] 64bit resource: fix up printks for resources in pci core and hotplug drivers
      [PATCH] 64bit resource: fix up printks for resources in networks drivers
      [PATCH] 64bit resource: fix up printks for resources in sound drivers
      [PATCH] 64bit resource: C99 changes for struct resource declarations
    
    Fixed up trivial conflict in drivers/ide/pci/cmd64x.c (the printk that
    was changed by the 64-bit resources had been deleted in the meantime ;)

commit 264edb35ce5c85749bfdd2942c74b786ea1cde41
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Jun 29 15:03:09 2006 +0100

    [ARM] Remove yucky ifdefs to print "id(wb)BRR" suffix on CPU name
    
    The "id(wb)BRR" suffix reports which CPU debugging options were (or
    were not) selected at kernel build time.  Rather than have every
    proc-*.S file implement this, report the control register value,
    from which this information can be deduced.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 093ccba0503c..7d02f96eeb9d 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -315,9 +315,9 @@ static void __init setup_processor(void)
 	cpu_cache = *list->cache;
 #endif
 
-	printk("CPU: %s [%08x] revision %d (ARMv%s)\n",
+	printk("CPU: %s [%08x] revision %d (ARMv%s), cr=%08x\n",
 	       cpu_name, processor_id, (int)processor_id & 15,
-	       proc_arch[cpu_architecture()]);
+	       proc_arch[cpu_architecture()], cr_alignment);
 
 	sprintf(system_utsname.machine, "%s%c", list->arch_name, ENDIANNESS);
 	sprintf(elf_platform, "%s%c", list->elf_name, ENDIANNESS);

commit 76b67ed9dce69a6a329cdd66f94af1787f417b62
Author: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Date:   Tue Jun 27 02:53:41 2006 -0700

    [PATCH] node hotplug: register cpu: remove node struct
    
    With Goto-san's patch, we can add new pgdat/node at runtime.  I'm now
    considering node-hot-add with cpu + memory on ACPI.
    
    I found acpi container, which describes node, could evaluate cpu before
    memory. This means cpu-hot-add occurs before memory hot add.
    
    In most part, cpu-hot-add doesn't depend on node hot add.  But register_cpu(),
    which creates symbolic link from node to cpu, requires that node should be
    onlined before register_cpu().  When a node is onlined, its pgdat should be
    there.
    
    This patch-set holds off creating symbolic link from node to cpu
    until node is onlined.
    
    This removes node arguments from register_cpu().
    
    Now, register_cpu() requires 'struct node' as its argument.  But the array of
    struct node is now unified in driver/base/node.c now (By Goto's node hotplug
    patch).  We can get struct node in generic way.  So, this argument is not
    necessary now.
    
    This patch also guarantees add cpu under node only when node is onlined.  It
    is necessary for node-hot-add vs.  cpu-hot-add patch following this.
    
    Moreover, register_cpu calculates cpu->node_id by cpu_to_node() without regard
    to its 'struct node *root' argument.  This patch removes it.
    
    Also modify callers of register_cpu()/unregister_cpu, whose args are changed
    by register-cpu-remove-node-struct patch.
    
    [Brice.Goglin@ens-lyon.org: fix it]
    Signed-off-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Yasunori Goto <y-goto@jp.fujitsu.com>
    Cc: Ashok Raj <ashok.raj@intel.com>
    Cc: Dave Hansen <haveblue@us.ibm.com>
    Signed-off-by: Brice Goglin <Brice.Goglin@ens-lyon.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 9fc9af88c60c..093ccba0503c 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -808,7 +808,7 @@ static int __init topology_init(void)
 	int cpu;
 
 	for_each_possible_cpu(cpu)
-		register_cpu(&per_cpu(cpu_data, cpu).cpu, cpu, NULL);
+		register_cpu(&per_cpu(cpu_data, cpu).cpu, cpu);
 
 	return 0;
 }

commit 740e518efcd84ce5e53ecf3c4c9be08cf8f3747c
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 12 14:47:06 2006 -0700

    [PATCH] 64bit resource: C99 changes for struct resource declarations
    
    Based on an original patch from Ralf Baechle <ralf@linux-mips.org> and
    Vivek Goyal <vgoyal@in.ibm.com>.  This is needed in order to prepare for
    changing the size of resources.
    
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 9fc9af88c60c..d69412728854 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -119,9 +119,24 @@ DEFINE_PER_CPU(struct cpuinfo_arm, cpu_data);
  * Standard memory resources
  */
 static struct resource mem_res[] = {
-	{ "Video RAM",   0,     0,     IORESOURCE_MEM			},
-	{ "Kernel text", 0,     0,     IORESOURCE_MEM			},
-	{ "Kernel data", 0,     0,     IORESOURCE_MEM			}
+	{
+		.name = "Video RAM",
+		.start = 0,
+		.end = 0,
+		.flags = IORESOURCE_MEM
+	},
+	{
+		.name = "Kernel text",
+		.start = 0,
+		.end = 0,
+		.flags = IORESOURCE_MEM
+	},
+	{
+		.name = "Kernel data",
+		.start = 0,
+		.end = 0,
+		.flags = IORESOURCE_MEM
+	}
 };
 
 #define video_ram   mem_res[0]
@@ -129,9 +144,24 @@ static struct resource mem_res[] = {
 #define kernel_data mem_res[2]
 
 static struct resource io_res[] = {
-	{ "reserved",    0x3bc, 0x3be, IORESOURCE_IO | IORESOURCE_BUSY },
-	{ "reserved",    0x378, 0x37f, IORESOURCE_IO | IORESOURCE_BUSY },
-	{ "reserved",    0x278, 0x27f, IORESOURCE_IO | IORESOURCE_BUSY }
+	{
+		.name = "reserved",
+		.start = 0x3bc,
+		.end = 0x3be,
+		.flags = IORESOURCE_IO | IORESOURCE_BUSY
+	},
+	{
+		.name = "reserved",
+		.start = 0x378,
+		.end = 0x37f,
+		.flags = IORESOURCE_IO | IORESOURCE_BUSY
+	},
+	{
+		.name = "reserved",
+		.start = 0x278,
+		.end = 0x27f,
+		.flags = IORESOURCE_IO | IORESOURCE_BUSY
+	}
 };
 
 #define lp0 io_res[0]

commit 036999d50180a9eaaa79dfb1d7a940824e475f24
Author: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Date:   Thu Apr 20 21:48:02 2006 +0100

    [ARM] for_each_possible_cpu
    
    for_each_cpu() actually iterates across all possible CPUs.  We've had mistakes
    in the past where people were using for_each_cpu() where they should have been
    iterating across only online or present CPUs.  This is inefficient and
    possibly buggy.
    
    We're renaming for_each_cpu() to for_each_possible_cpu() to avoid this in the
    future.
    
    This patch replaces for_each_cpu with for_each_possible_cpu.
    
    Signed-off-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 673cab2ff65a..9fc9af88c60c 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -807,7 +807,7 @@ static int __init topology_init(void)
 {
 	int cpu;
 
-	for_each_cpu(cpu)
+	for_each_possible_cpu(cpu)
 		register_cpu(&per_cpu(cpu_data, cpu).cpu, cpu, NULL);
 
 	return 0;

commit 1c97b73e89af9a20e99450c554cffdd9327e827a
Author: Andrew Morton <akpm@osdl.org>
Date:   Thu Apr 20 21:41:18 2006 +0100

    [ARM] add_memory() build fix
    
    This is back again.  Offending patch is x86_64-mm-hotadd-reserve.patch
    
    arch/arm/kernel/setup.c:435: error: conflicting types for 'add_memory'
    include/linux/memory_hotplug.h:102: error: previous declaration of 'add_memory' was here
    arch/arm/kernel/setup.c:435: error: conflicting types for 'add_memory'
    include/linux/memory_hotplug.h:102: error: previous declaration of 'add_memory' was here
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 8cff73e668b3..673cab2ff65a 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -407,7 +407,7 @@ static void __init early_initrd(char **p)
 }
 __early_param("initrd=", early_initrd);
 
-static void __init add_memory(unsigned long start, unsigned long size)
+static void __init arm_add_memory(unsigned long start, unsigned long size)
 {
 	/*
 	 * Ensure that start/size are aligned to a page boundary.
@@ -445,7 +445,7 @@ static void __init early_mem(char **p)
 	if (**p == '@')
 		start = memparse(*p + 1, p);
 
-	add_memory(start, size);
+	arm_add_memory(start, size);
 }
 __early_param("mem=", early_mem);
 
@@ -587,7 +587,7 @@ static int __init parse_tag_mem32(const struct tag *tag)
 			tag->u.mem.start, tag->u.mem.size / 1024);
 		return -EINVAL;
 	}
-	add_memory(tag->u.mem.start, tag->u.mem.size);
+	arm_add_memory(tag->u.mem.start, tag->u.mem.size);
 	return 0;
 }
 

commit adeff42236aec0601ec979d1a41cd6d9cf5a8c05
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Mon Apr 10 21:32:35 2006 +0100

    [ARM] 3470/1: Clear the HWCAP bits for the disabled kernel features
    
    Patch from Catalin Marinas
    
    Glibc interprets the HWCAP bits and decides on what features to use.
    However, even if the features are present in the hardware, they are not
    always supported by the kernel and hence the corresponding bits have to be
    cleared from the elf_hwcap variable.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 437528403959..8cff73e668b3 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -322,6 +322,12 @@ static void __init setup_processor(void)
 	sprintf(system_utsname.machine, "%s%c", list->arch_name, ENDIANNESS);
 	sprintf(elf_platform, "%s%c", list->elf_name, ENDIANNESS);
 	elf_hwcap = list->elf_hwcap;
+#ifndef CONFIG_ARM_THUMB
+	elf_hwcap &= ~HWCAP_THUMB;
+#endif
+#ifndef CONFIG_VFP
+	elf_hwcap &= ~HWCAP_VFP;
+#endif
 
 	cpu_proc_init();
 }

commit 23759dc6430428897a36c4d493f611eca55c9481
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Sun Apr 2 00:07:39 2006 +0100

    [ARM] 3439/2: xsc3: add I/O coherency support
    
    Patch from Lennert Buytenhek
    
    This patch adds support for the I/O coherent cache available on the
    xsc3.  The approach is to provide a simple API to determine whether the
    chipset supports coherency by calling arch_is_coherent() and then
    setting the appropriate system memory PTE and PMD bits.  In addition,
    we call this API on dma_alloc_coherent() and dma_map_single() calls.
    A generic version exists that will compile out all the coherency-related
    code that is not needed on the majority of ARM systems.
    
    Note that we do not check for coherency in the dma_alloc_writecombine()
    function as that still requires a special PTE setting.  We also don't
    touch dma_mmap_coherent() as that is a special ARM-only API that is by
    definition only used on non-coherent system.
    
    Signed-off-by: Deepak Saxena <dsaxena@plexity.net>
    Signed-off-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index b7cd280bfd63..437528403959 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -252,6 +252,9 @@ static void __init dump_cpu_info(int cpu)
 			dump_cache("cache", cpu, CACHE_ISIZE(info));
 		}
 	}
+
+	if (arch_is_coherent())
+		printk("Cache coherency enabled\n");
 }
 
 int cpu_architecture(void)

commit 0f44ba1d1e67201c0c58af26eb441fa7014c89ec
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Feb 24 21:04:56 2006 +0000

    [ARM] Move read of processor ID out of lookup_processor_type()
    
    Read the processor ID at boot, and save it in "processor_id" as we
    did before.  Later, when we re-parse the CPU type in the setup.c code,
    re-use the value stored in "processor_id".
    
    This allows a cleaner work-around for noMMU devices without CP#15.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 08974cbe9824..b7cd280bfd63 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -278,7 +278,7 @@ int cpu_architecture(void)
  * These functions re-use the assembly code in head.S, which
  * already provide the required functionality.
  */
-extern struct proc_info_list *lookup_processor_type(void);
+extern struct proc_info_list *lookup_processor_type(unsigned int);
 extern struct machine_desc *lookup_machine_type(unsigned int);
 
 static void __init setup_processor(void)
@@ -290,7 +290,7 @@ static void __init setup_processor(void)
 	 * types.  The linker builds this table for us from the
 	 * entries in arch/arm/mm/proc-*.S
 	 */
-	list = lookup_processor_type();
+	list = lookup_processor_type(processor_id);
 	if (!list) {
 		printk("CPU configuration botched (ID %08x), unable "
 		       "to continue.\n", processor_id);

commit 4333298965cd62585bec891a6a5c9f4c806fc6bd
Author: Ben Dooks <ben-linux@fluff.org>
Date:   Wed Mar 15 23:18:08 2006 +0000

    [ARM] 3362/1: [cleanup] - duplicate decleration of mem_fclk_21285
    
    Patch from Ben Dooks
    
    arch/arm/kernel/setup.c declares mem_fclk_21285 when
    this is already declared in include/asm-arm/system.h
    
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index c214dc56be4a..08974cbe9824 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -55,7 +55,6 @@ static int __init fpe_setup(char *line)
 __setup("fpe=", fpe_setup);
 #endif
 
-extern unsigned int mem_fclk_21285;
 extern void paging_init(struct meminfo *, struct machine_desc *desc);
 extern void reboot_setup(char *str);
 extern int root_mountflags;

commit 0fc1c832123493aca4c6a8600179132651f48bdc
Author: Ben Dooks <ben-linux@fluff.org>
Date:   Wed Mar 15 23:17:30 2006 +0000

    [ARM] 3365/1: [cleanup] header for compat.c exported functions
    
    Patch from Ben Dooks
    
    arch/arm/kernel/compat.c exports two functions,
    convert_to_tag_list and squash_mem_tags which
    are not defined in any header files, and not
    used outside arch/arm/kernel.
    
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 68273b4dc882..c214dc56be4a 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -37,6 +37,8 @@
 #include <asm/mach/irq.h>
 #include <asm/mach/time.h>
 
+#include "compat.h"
+
 #ifndef MEM_SIZE
 #define MEM_SIZE	(16*1024*1024)
 #endif
@@ -55,8 +57,6 @@ __setup("fpe=", fpe_setup);
 
 extern unsigned int mem_fclk_21285;
 extern void paging_init(struct meminfo *, struct machine_desc *desc);
-extern void convert_to_tag_list(struct tag *tags);
-extern void squash_mem_tags(struct tag *tag);
 extern void reboot_setup(char *str);
 extern int root_mountflags;
 extern void _stext, _text, _etext, __data_start, _edata, _end;

commit 7bbb79403163e047c6e333ff169db34e3c969e65
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Feb 16 11:08:09 2006 +0000

    [ARM] Fix SMP initialisation oops
    
    A change to the SMP initialisation caused the following oops:
    
     CPU1: Booted secondary processor
     CPU1: D VIPT write-back cache
     CPU1: I cache: 32768 bytes, associativity 4, 32 byte lines, 256 sets
     CPU1: D cache: 32768 bytes, associativity 4, 32 byte lines, 256 sets
     <7>Calibrating delay loop... 83.14 BogoMIPS (lpj=415744)
     <1>Unable to handle kernel NULL pointer dereference at virtual address 0000001c
     ...
     PC is at enqueue_task+0x1c/0x64
     LR is at activate_task+0xcc/0xe4
    
    SMP initialisation now requires cpu_possible_map to be initialised in
    setup_arch().  Move this from smp_prepare_cpus() to smp_init_cpus()
    and call it from our setup_arch() if CONFIG_SMP is enabled.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index c45d10d07bde..68273b4dc882 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -23,6 +23,7 @@
 #include <linux/root_dev.h>
 #include <linux/cpu.h>
 #include <linux/interrupt.h>
+#include <linux/smp.h>
 
 #include <asm/cpu.h>
 #include <asm/elf.h>
@@ -771,6 +772,10 @@ void __init setup_arch(char **cmdline_p)
 	paging_init(&meminfo, mdesc);
 	request_standard_resources(&meminfo, mdesc);
 
+#ifdef CONFIG_SMP
+	smp_init_cpus();
+#endif
+
 	cpu_init();
 
 	/*

commit 6b090a25fe58067e4bf4515d5056df1f07b64849
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Thu Jan 12 16:28:16 2006 +0000

    [ARM] 3234/1: Update cpu_architecture() to deal with the new ID format
    
    Patch from Catalin Marinas
    
    Since ARM1176, the CPU ID format has changed and it will also be used for
    future ARM architectures.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 2cab741ad0f8..c45d10d07bde 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -205,7 +205,7 @@ static const char *proc_arch[] = {
 	"5TE",
 	"5TEJ",
 	"6TEJ",
-	"?(10)",
+	"7",
 	"?(11)",
 	"?(12)",
 	"?(13)",
@@ -258,14 +258,17 @@ int cpu_architecture(void)
 {
 	int cpu_arch;
 
-	if ((processor_id & 0x0000f000) == 0) {
+	if ((processor_id & 0x0008f000) == 0) {
 		cpu_arch = CPU_ARCH_UNKNOWN;
-	} else if ((processor_id & 0x0000f000) == 0x00007000) {
+	} else if ((processor_id & 0x0008f000) == 0x00007000) {
 		cpu_arch = (processor_id & (1 << 23)) ? CPU_ARCH_ARMv4T : CPU_ARCH_ARMv3;
-	} else {
+	} else if ((processor_id & 0x00080000) == 0x00000000) {
 		cpu_arch = (processor_id >> 16) & 7;
 		if (cpu_arch)
 			cpu_arch += CPU_ARCH_ARMv3;
+	} else {
+		/* the revised CPUID */
+		cpu_arch = ((processor_id >> 12) & 0xf) - 0xb + CPU_ARCH_ARMv6;
 	}
 
 	return cpu_arch;
@@ -863,11 +866,11 @@ static int c_show(struct seq_file *m, void *v)
 	seq_printf(m, "\nCPU implementer\t: 0x%02x\n", processor_id >> 24);
 	seq_printf(m, "CPU architecture: %s\n", proc_arch[cpu_architecture()]);
 
-	if ((processor_id & 0x0000f000) == 0x00000000) {
+	if ((processor_id & 0x0008f000) == 0x00000000) {
 		/* pre-ARM7 */
 		seq_printf(m, "CPU part\t\t: %07x\n", processor_id >> 4);
 	} else {
-		if ((processor_id & 0x0000f000) == 0x00007000) {
+		if ((processor_id & 0x0008f000) == 0x00007000) {
 			/* ARM7 */
 			seq_printf(m, "CPU variant\t: 0x%02x\n",
 				   (processor_id >> 16) & 127);

commit 78ff18a412da24a4b79c6a97000ef5e467e813da
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Jan 3 17:39:34 2006 +0000

    [ARM] Cleanup ARM includes
    
    arch/arm/kernel/entry-armv.S has contained a comment suggesting
    that asm/hardware.h and asm/arch/irqs.h should be moved into the
    asm/arch/entry-macro.S include.  So move the includes to these
    two files as required.
    
    Add missing includes (asm/hardware.h, asm/io.h) to asm/arch/system.h
    includes which use those facilities, and remove asm/io.h from
    kernel/process.c.
    
    Remove other unnecessary includes from arch/arm/kernel, arch/arm/mm
    and arch/arm/mach-footbridge.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 85774165e9fd..2cab741ad0f8 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -26,8 +26,6 @@
 
 #include <asm/cpu.h>
 #include <asm/elf.h>
-#include <asm/hardware.h>
-#include <asm/io.h>
 #include <asm/procinfo.h>
 #include <asm/setup.h>
 #include <asm/mach-types.h>

commit 1555972231f3202f00e04f7c42d2db858e11b874
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Nov 6 21:41:08 2005 +0000

    [ARM] Fix /proc/cpuinfo format for ARM SMP
    
    glibc expects to count lines beginning with "processor" to determine
    the number of processors, not lines beginning with "Processor".  So,
    give glibc the format it expects.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index a6d7fb81330e..85774165e9fd 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -839,7 +839,12 @@ static int c_show(struct seq_file *m, void *v)
 
 #if defined(CONFIG_SMP)
 	for_each_online_cpu(i) {
-		seq_printf(m, "Processor\t: %d\n", i);
+		/*
+		 * glibc reads /proc/cpuinfo to determine the number of
+		 * online processors, looking for lines beginning with
+		 * "processor".  Give glibc what it expects.
+		 */
+		seq_printf(m, "processor\t: %d\n", i);
 		seq_printf(m, "BogoMIPS\t: %lu.%02lu\n\n",
 			   per_cpu(cpu_data, i).loops_per_jiffy / (500000UL/HZ),
 			   (per_cpu(cpu_data, i).loops_per_jiffy / (5000UL/HZ)) % 100);

commit 32f8b97ca39421057d8adef05b7219127355d60c
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Nov 6 19:49:21 2005 +0000

    [ARM] Don't call dump_cpu_info unless we're booting
    
    We don't want to call dump_cpu_info() from cpu_init() after boot since
    it produces a lot of unnecessary noise - since cpu_init() gets called
    on resume and hotplug cpu insertion events.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index c9b69771f92e..a6d7fb81330e 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -338,7 +338,8 @@ void cpu_init(void)
 		BUG();
 	}
 
-	dump_cpu_info(cpu);
+	if (system_state == SYSTEM_BOOTING)
+		dump_cpu_info(cpu);
 
 	/*
 	 * setup stacks for re-entrant exception handlers

commit f9bd6ea446946b97208f9e1528eb5f9ef8f931cb
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Jul 4 10:43:36 2005 +0100

    [PATCH] ARM: Change 'param_offset' to 'boot_params'
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 35b7273cfdb4..c9b69771f92e 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -737,8 +737,8 @@ void __init setup_arch(char **cmdline_p)
 	if (mdesc->soft_reboot)
 		reboot_setup("s");
 
-	if (mdesc->param_offset)
-		tags = phys_to_virt(mdesc->param_offset);
+	if (mdesc->boot_params)
+		tags = phys_to_virt(mdesc->boot_params);
 
 	/*
 	 * If we have the old style parameters, convert them to

commit aaaa3f9e51245be3215ff67bb3c7aaf5abb82f00
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Wed Jun 29 15:34:39 2005 +0100

    [PATCH] ARM: 2769/1: cpu_init() stack setup fix
    
    Patch from Catalin Marinas
    
    The compiler allocates r14 for the stk variable in the __asm__ directive.
    This is a shadowed register and gets changed when the mode is changed,
    causing random values in the SP register. The patch adds a clobber for
    the r14 register.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 8cf733daa800..35b7273cfdb4 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -359,7 +359,8 @@ void cpu_init(void)
 	      "I" (offsetof(struct stack, abt[0])),
 	      "I" (PSR_F_BIT | PSR_I_BIT | UND_MODE),
 	      "I" (offsetof(struct stack, und[0])),
-	      "I" (PSR_F_BIT | PSR_I_BIT | SVC_MODE));
+	      "I" (PSR_F_BIT | PSR_I_BIT | SVC_MODE)
+	    : "r14");
 }
 
 static struct machine_desc * __init setup_machine(unsigned int nr)

commit 3a66941106855215127f8bf1afd06099b72dc75b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Jun 22 21:43:10 2005 +0100

    [PATCH] ARM: Ensure memory information is page aligned
    
    Ensure that meminfo.bank[] array contains page-aligned start/size
    information.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 9fed5fa194d9..8cf733daa800 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -395,6 +395,20 @@ static void __init early_initrd(char **p)
 }
 __early_param("initrd=", early_initrd);
 
+static void __init add_memory(unsigned long start, unsigned long size)
+{
+	/*
+	 * Ensure that start/size are aligned to a page boundary.
+	 * Size is appropriately rounded down, start is rounded up.
+	 */
+	size -= start & ~PAGE_MASK;
+
+	meminfo.bank[meminfo.nr_banks].start = PAGE_ALIGN(start);
+	meminfo.bank[meminfo.nr_banks].size  = size & PAGE_MASK;
+	meminfo.bank[meminfo.nr_banks].node  = PHYS_TO_NID(start);
+	meminfo.nr_banks += 1;
+}
+
 /*
  * Pick out the memory size.  We look for mem=size@start,
  * where start and size are "size[KkMm]"
@@ -419,10 +433,7 @@ static void __init early_mem(char **p)
 	if (**p == '@')
 		start = memparse(*p + 1, p);
 
-	meminfo.bank[meminfo.nr_banks].start = start;
-	meminfo.bank[meminfo.nr_banks].size  = size;
-	meminfo.bank[meminfo.nr_banks].node  = PHYS_TO_NID(start);
-	meminfo.nr_banks += 1;
+	add_memory(start, size);
 }
 __early_param("mem=", early_mem);
 
@@ -564,11 +575,7 @@ static int __init parse_tag_mem32(const struct tag *tag)
 			tag->u.mem.start, tag->u.mem.size / 1024);
 		return -EINVAL;
 	}
-	meminfo.bank[meminfo.nr_banks].start = tag->u.mem.start;
-	meminfo.bank[meminfo.nr_banks].size  = tag->u.mem.size;
-	meminfo.bank[meminfo.nr_banks].node  = PHYS_TO_NID(tag->u.mem.start);
-	meminfo.nr_banks += 1;
-
+	add_memory(tag->u.mem.start, tag->u.mem.size);
 	return 0;
 }
 

commit 36c5ed23b9f535d1c79986efb45f9c1f115e0997
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Jun 19 18:39:33 2005 +0100

    [PATCH] ARM SMP: Fix PXA/SA11x0 suspend resume crash
    
    We need to re-initialise the stack pointers for undefined, IRQ
    and abort mode handlers whenever we resume.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 7ecdda3f1253..9fed5fa194d9 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -328,7 +328,7 @@ static void __init setup_processor(void)
  * cpu_init dumps the cache information, initialises SMP specific
  * information, and sets up the per-CPU stacks.
  */
-void __init cpu_init(void)
+void cpu_init(void)
 {
 	unsigned int cpu = smp_processor_id();
 	struct stack *stk = &stacks[cpu];

commit ccea7a19e54349d4f40778304e1bb88da83d39e7
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue May 31 22:22:32 2005 +0100

    [PATCH] ARM SMP: Fix vector entry
    
    The current vector entry system does not allow for SMP.  In
    order to work around this, we need to eliminate our reliance
    on the fixed save areas, which breaks the way we enable
    alignment traps.  This patch changes the way we handle the
    save areas such that we can have one per CPU.
    
    Signed-off-by: Russell King <rmk@arm.linux.org.uk>

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index c2a7da3ac0f1..7ecdda3f1253 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -92,6 +92,14 @@ struct cpu_user_fns cpu_user;
 struct cpu_cache_fns cpu_cache;
 #endif
 
+struct stack {
+	u32 irq[3];
+	u32 abt[3];
+	u32 und[3];
+} ____cacheline_aligned;
+
+static struct stack stacks[NR_CPUS];
+
 char elf_platform[ELF_PLATFORM_SIZE];
 EXPORT_SYMBOL(elf_platform);
 
@@ -307,8 +315,6 @@ static void __init setup_processor(void)
 	       cpu_name, processor_id, (int)processor_id & 15,
 	       proc_arch[cpu_architecture()]);
 
-	dump_cpu_info(smp_processor_id());
-
 	sprintf(system_utsname.machine, "%s%c", list->arch_name, ENDIANNESS);
 	sprintf(elf_platform, "%s%c", list->elf_name, ENDIANNESS);
 	elf_hwcap = list->elf_hwcap;
@@ -316,6 +322,46 @@ static void __init setup_processor(void)
 	cpu_proc_init();
 }
 
+/*
+ * cpu_init - initialise one CPU.
+ *
+ * cpu_init dumps the cache information, initialises SMP specific
+ * information, and sets up the per-CPU stacks.
+ */
+void __init cpu_init(void)
+{
+	unsigned int cpu = smp_processor_id();
+	struct stack *stk = &stacks[cpu];
+
+	if (cpu >= NR_CPUS) {
+		printk(KERN_CRIT "CPU%u: bad primary CPU number\n", cpu);
+		BUG();
+	}
+
+	dump_cpu_info(cpu);
+
+	/*
+	 * setup stacks for re-entrant exception handlers
+	 */
+	__asm__ (
+	"msr	cpsr_c, %1\n\t"
+	"add	sp, %0, %2\n\t"
+	"msr	cpsr_c, %3\n\t"
+	"add	sp, %0, %4\n\t"
+	"msr	cpsr_c, %5\n\t"
+	"add	sp, %0, %6\n\t"
+	"msr	cpsr_c, %7"
+	    :
+	    : "r" (stk),
+	      "I" (PSR_F_BIT | PSR_I_BIT | IRQ_MODE),
+	      "I" (offsetof(struct stack, irq[0])),
+	      "I" (PSR_F_BIT | PSR_I_BIT | ABT_MODE),
+	      "I" (offsetof(struct stack, abt[0])),
+	      "I" (PSR_F_BIT | PSR_I_BIT | UND_MODE),
+	      "I" (offsetof(struct stack, und[0])),
+	      "I" (PSR_F_BIT | PSR_I_BIT | SVC_MODE));
+}
+
 static struct machine_desc * __init setup_machine(unsigned int nr)
 {
 	struct machine_desc *list;
@@ -715,6 +761,8 @@ void __init setup_arch(char **cmdline_p)
 	paging_init(&meminfo, mdesc);
 	request_standard_resources(&meminfo, mdesc);
 
+	cpu_init();
+
 	/*
 	 * Set up various architecture-specific pointers
 	 */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
new file mode 100644
index 000000000000..c2a7da3ac0f1
--- /dev/null
+++ b/arch/arm/kernel/setup.c
@@ -0,0 +1,875 @@
+/*
+ *  linux/arch/arm/kernel/setup.c
+ *
+ *  Copyright (C) 1995-2001 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/stddef.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/utsname.h>
+#include <linux/initrd.h>
+#include <linux/console.h>
+#include <linux/bootmem.h>
+#include <linux/seq_file.h>
+#include <linux/tty.h>
+#include <linux/init.h>
+#include <linux/root_dev.h>
+#include <linux/cpu.h>
+#include <linux/interrupt.h>
+
+#include <asm/cpu.h>
+#include <asm/elf.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/procinfo.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/cacheflush.h>
+#include <asm/tlbflush.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/time.h>
+
+#ifndef MEM_SIZE
+#define MEM_SIZE	(16*1024*1024)
+#endif
+
+#if defined(CONFIG_FPE_NWFPE) || defined(CONFIG_FPE_FASTFPE)
+char fpe_type[8];
+
+static int __init fpe_setup(char *line)
+{
+	memcpy(fpe_type, line, 8);
+	return 1;
+}
+
+__setup("fpe=", fpe_setup);
+#endif
+
+extern unsigned int mem_fclk_21285;
+extern void paging_init(struct meminfo *, struct machine_desc *desc);
+extern void convert_to_tag_list(struct tag *tags);
+extern void squash_mem_tags(struct tag *tag);
+extern void reboot_setup(char *str);
+extern int root_mountflags;
+extern void _stext, _text, _etext, __data_start, _edata, _end;
+
+unsigned int processor_id;
+unsigned int __machine_arch_type;
+EXPORT_SYMBOL(__machine_arch_type);
+
+unsigned int system_rev;
+EXPORT_SYMBOL(system_rev);
+
+unsigned int system_serial_low;
+EXPORT_SYMBOL(system_serial_low);
+
+unsigned int system_serial_high;
+EXPORT_SYMBOL(system_serial_high);
+
+unsigned int elf_hwcap;
+EXPORT_SYMBOL(elf_hwcap);
+
+
+#ifdef MULTI_CPU
+struct processor processor;
+#endif
+#ifdef MULTI_TLB
+struct cpu_tlb_fns cpu_tlb;
+#endif
+#ifdef MULTI_USER
+struct cpu_user_fns cpu_user;
+#endif
+#ifdef MULTI_CACHE
+struct cpu_cache_fns cpu_cache;
+#endif
+
+char elf_platform[ELF_PLATFORM_SIZE];
+EXPORT_SYMBOL(elf_platform);
+
+unsigned long phys_initrd_start __initdata = 0;
+unsigned long phys_initrd_size __initdata = 0;
+
+static struct meminfo meminfo __initdata = { 0, };
+static const char *cpu_name;
+static const char *machine_name;
+static char command_line[COMMAND_LINE_SIZE];
+
+static char default_command_line[COMMAND_LINE_SIZE] __initdata = CONFIG_CMDLINE;
+static union { char c[4]; unsigned long l; } endian_test __initdata = { { 'l', '?', '?', 'b' } };
+#define ENDIANNESS ((char)endian_test.l)
+
+DEFINE_PER_CPU(struct cpuinfo_arm, cpu_data);
+
+/*
+ * Standard memory resources
+ */
+static struct resource mem_res[] = {
+	{ "Video RAM",   0,     0,     IORESOURCE_MEM			},
+	{ "Kernel text", 0,     0,     IORESOURCE_MEM			},
+	{ "Kernel data", 0,     0,     IORESOURCE_MEM			}
+};
+
+#define video_ram   mem_res[0]
+#define kernel_code mem_res[1]
+#define kernel_data mem_res[2]
+
+static struct resource io_res[] = {
+	{ "reserved",    0x3bc, 0x3be, IORESOURCE_IO | IORESOURCE_BUSY },
+	{ "reserved",    0x378, 0x37f, IORESOURCE_IO | IORESOURCE_BUSY },
+	{ "reserved",    0x278, 0x27f, IORESOURCE_IO | IORESOURCE_BUSY }
+};
+
+#define lp0 io_res[0]
+#define lp1 io_res[1]
+#define lp2 io_res[2]
+
+static const char *cache_types[16] = {
+	"write-through",
+	"write-back",
+	"write-back",
+	"undefined 3",
+	"undefined 4",
+	"undefined 5",
+	"write-back",
+	"write-back",
+	"undefined 8",
+	"undefined 9",
+	"undefined 10",
+	"undefined 11",
+	"undefined 12",
+	"undefined 13",
+	"write-back",
+	"undefined 15",
+};
+
+static const char *cache_clean[16] = {
+	"not required",
+	"read-block",
+	"cp15 c7 ops",
+	"undefined 3",
+	"undefined 4",
+	"undefined 5",
+	"cp15 c7 ops",
+	"cp15 c7 ops",
+	"undefined 8",
+	"undefined 9",
+	"undefined 10",
+	"undefined 11",
+	"undefined 12",
+	"undefined 13",
+	"cp15 c7 ops",
+	"undefined 15",
+};
+
+static const char *cache_lockdown[16] = {
+	"not supported",
+	"not supported",
+	"not supported",
+	"undefined 3",
+	"undefined 4",
+	"undefined 5",
+	"format A",
+	"format B",
+	"undefined 8",
+	"undefined 9",
+	"undefined 10",
+	"undefined 11",
+	"undefined 12",
+	"undefined 13",
+	"format C",
+	"undefined 15",
+};
+
+static const char *proc_arch[] = {
+	"undefined/unknown",
+	"3",
+	"4",
+	"4T",
+	"5",
+	"5T",
+	"5TE",
+	"5TEJ",
+	"6TEJ",
+	"?(10)",
+	"?(11)",
+	"?(12)",
+	"?(13)",
+	"?(14)",
+	"?(15)",
+	"?(16)",
+	"?(17)",
+};
+
+#define CACHE_TYPE(x)	(((x) >> 25) & 15)
+#define CACHE_S(x)	((x) & (1 << 24))
+#define CACHE_DSIZE(x)	(((x) >> 12) & 4095)	/* only if S=1 */
+#define CACHE_ISIZE(x)	((x) & 4095)
+
+#define CACHE_SIZE(y)	(((y) >> 6) & 7)
+#define CACHE_ASSOC(y)	(((y) >> 3) & 7)
+#define CACHE_M(y)	((y) & (1 << 2))
+#define CACHE_LINE(y)	((y) & 3)
+
+static inline void dump_cache(const char *prefix, int cpu, unsigned int cache)
+{
+	unsigned int mult = 2 + (CACHE_M(cache) ? 1 : 0);
+
+	printk("CPU%u: %s: %d bytes, associativity %d, %d byte lines, %d sets\n",
+		cpu, prefix,
+		mult << (8 + CACHE_SIZE(cache)),
+		(mult << CACHE_ASSOC(cache)) >> 1,
+		8 << CACHE_LINE(cache),
+		1 << (6 + CACHE_SIZE(cache) - CACHE_ASSOC(cache) -
+			CACHE_LINE(cache)));
+}
+
+static void __init dump_cpu_info(int cpu)
+{
+	unsigned int info = read_cpuid(CPUID_CACHETYPE);
+
+	if (info != processor_id) {
+		printk("CPU%u: D %s %s cache\n", cpu, cache_is_vivt() ? "VIVT" : "VIPT",
+		       cache_types[CACHE_TYPE(info)]);
+		if (CACHE_S(info)) {
+			dump_cache("I cache", cpu, CACHE_ISIZE(info));
+			dump_cache("D cache", cpu, CACHE_DSIZE(info));
+		} else {
+			dump_cache("cache", cpu, CACHE_ISIZE(info));
+		}
+	}
+}
+
+int cpu_architecture(void)
+{
+	int cpu_arch;
+
+	if ((processor_id & 0x0000f000) == 0) {
+		cpu_arch = CPU_ARCH_UNKNOWN;
+	} else if ((processor_id & 0x0000f000) == 0x00007000) {
+		cpu_arch = (processor_id & (1 << 23)) ? CPU_ARCH_ARMv4T : CPU_ARCH_ARMv3;
+	} else {
+		cpu_arch = (processor_id >> 16) & 7;
+		if (cpu_arch)
+			cpu_arch += CPU_ARCH_ARMv3;
+	}
+
+	return cpu_arch;
+}
+
+/*
+ * These functions re-use the assembly code in head.S, which
+ * already provide the required functionality.
+ */
+extern struct proc_info_list *lookup_processor_type(void);
+extern struct machine_desc *lookup_machine_type(unsigned int);
+
+static void __init setup_processor(void)
+{
+	struct proc_info_list *list;
+
+	/*
+	 * locate processor in the list of supported processor
+	 * types.  The linker builds this table for us from the
+	 * entries in arch/arm/mm/proc-*.S
+	 */
+	list = lookup_processor_type();
+	if (!list) {
+		printk("CPU configuration botched (ID %08x), unable "
+		       "to continue.\n", processor_id);
+		while (1);
+	}
+
+	cpu_name = list->cpu_name;
+
+#ifdef MULTI_CPU
+	processor = *list->proc;
+#endif
+#ifdef MULTI_TLB
+	cpu_tlb = *list->tlb;
+#endif
+#ifdef MULTI_USER
+	cpu_user = *list->user;
+#endif
+#ifdef MULTI_CACHE
+	cpu_cache = *list->cache;
+#endif
+
+	printk("CPU: %s [%08x] revision %d (ARMv%s)\n",
+	       cpu_name, processor_id, (int)processor_id & 15,
+	       proc_arch[cpu_architecture()]);
+
+	dump_cpu_info(smp_processor_id());
+
+	sprintf(system_utsname.machine, "%s%c", list->arch_name, ENDIANNESS);
+	sprintf(elf_platform, "%s%c", list->elf_name, ENDIANNESS);
+	elf_hwcap = list->elf_hwcap;
+
+	cpu_proc_init();
+}
+
+static struct machine_desc * __init setup_machine(unsigned int nr)
+{
+	struct machine_desc *list;
+
+	/*
+	 * locate machine in the list of supported machines.
+	 */
+	list = lookup_machine_type(nr);
+	if (!list) {
+		printk("Machine configuration botched (nr %d), unable "
+		       "to continue.\n", nr);
+		while (1);
+	}
+
+	printk("Machine: %s\n", list->name);
+
+	return list;
+}
+
+static void __init early_initrd(char **p)
+{
+	unsigned long start, size;
+
+	start = memparse(*p, p);
+	if (**p == ',') {
+		size = memparse((*p) + 1, p);
+
+		phys_initrd_start = start;
+		phys_initrd_size = size;
+	}
+}
+__early_param("initrd=", early_initrd);
+
+/*
+ * Pick out the memory size.  We look for mem=size@start,
+ * where start and size are "size[KkMm]"
+ */
+static void __init early_mem(char **p)
+{
+	static int usermem __initdata = 0;
+	unsigned long size, start;
+
+	/*
+	 * If the user specifies memory size, we
+	 * blow away any automatically generated
+	 * size.
+	 */
+	if (usermem == 0) {
+		usermem = 1;
+		meminfo.nr_banks = 0;
+	}
+
+	start = PHYS_OFFSET;
+	size  = memparse(*p, p);
+	if (**p == '@')
+		start = memparse(*p + 1, p);
+
+	meminfo.bank[meminfo.nr_banks].start = start;
+	meminfo.bank[meminfo.nr_banks].size  = size;
+	meminfo.bank[meminfo.nr_banks].node  = PHYS_TO_NID(start);
+	meminfo.nr_banks += 1;
+}
+__early_param("mem=", early_mem);
+
+/*
+ * Initial parsing of the command line.
+ */
+static void __init parse_cmdline(char **cmdline_p, char *from)
+{
+	char c = ' ', *to = command_line;
+	int len = 0;
+
+	for (;;) {
+		if (c == ' ') {
+			extern struct early_params __early_begin, __early_end;
+			struct early_params *p;
+
+			for (p = &__early_begin; p < &__early_end; p++) {
+				int len = strlen(p->arg);
+
+				if (memcmp(from, p->arg, len) == 0) {
+					if (to != command_line)
+						to -= 1;
+					from += len;
+					p->fn(&from);
+
+					while (*from != ' ' && *from != '\0')
+						from++;
+					break;
+				}
+			}
+		}
+		c = *from++;
+		if (!c)
+			break;
+		if (COMMAND_LINE_SIZE <= ++len)
+			break;
+		*to++ = c;
+	}
+	*to = '\0';
+	*cmdline_p = command_line;
+}
+
+static void __init
+setup_ramdisk(int doload, int prompt, int image_start, unsigned int rd_sz)
+{
+#ifdef CONFIG_BLK_DEV_RAM
+	extern int rd_size, rd_image_start, rd_prompt, rd_doload;
+
+	rd_image_start = image_start;
+	rd_prompt = prompt;
+	rd_doload = doload;
+
+	if (rd_sz)
+		rd_size = rd_sz;
+#endif
+}
+
+static void __init
+request_standard_resources(struct meminfo *mi, struct machine_desc *mdesc)
+{
+	struct resource *res;
+	int i;
+
+	kernel_code.start   = virt_to_phys(&_text);
+	kernel_code.end     = virt_to_phys(&_etext - 1);
+	kernel_data.start   = virt_to_phys(&__data_start);
+	kernel_data.end     = virt_to_phys(&_end - 1);
+
+	for (i = 0; i < mi->nr_banks; i++) {
+		unsigned long virt_start, virt_end;
+
+		if (mi->bank[i].size == 0)
+			continue;
+
+		virt_start = __phys_to_virt(mi->bank[i].start);
+		virt_end   = virt_start + mi->bank[i].size - 1;
+
+		res = alloc_bootmem_low(sizeof(*res));
+		res->name  = "System RAM";
+		res->start = __virt_to_phys(virt_start);
+		res->end   = __virt_to_phys(virt_end);
+		res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+
+		request_resource(&iomem_resource, res);
+
+		if (kernel_code.start >= res->start &&
+		    kernel_code.end <= res->end)
+			request_resource(res, &kernel_code);
+		if (kernel_data.start >= res->start &&
+		    kernel_data.end <= res->end)
+			request_resource(res, &kernel_data);
+	}
+
+	if (mdesc->video_start) {
+		video_ram.start = mdesc->video_start;
+		video_ram.end   = mdesc->video_end;
+		request_resource(&iomem_resource, &video_ram);
+	}
+
+	/*
+	 * Some machines don't have the possibility of ever
+	 * possessing lp0, lp1 or lp2
+	 */
+	if (mdesc->reserve_lp0)
+		request_resource(&ioport_resource, &lp0);
+	if (mdesc->reserve_lp1)
+		request_resource(&ioport_resource, &lp1);
+	if (mdesc->reserve_lp2)
+		request_resource(&ioport_resource, &lp2);
+}
+
+/*
+ *  Tag parsing.
+ *
+ * This is the new way of passing data to the kernel at boot time.  Rather
+ * than passing a fixed inflexible structure to the kernel, we pass a list
+ * of variable-sized tags to the kernel.  The first tag must be a ATAG_CORE
+ * tag for the list to be recognised (to distinguish the tagged list from
+ * a param_struct).  The list is terminated with a zero-length tag (this tag
+ * is not parsed in any way).
+ */
+static int __init parse_tag_core(const struct tag *tag)
+{
+	if (tag->hdr.size > 2) {
+		if ((tag->u.core.flags & 1) == 0)
+			root_mountflags &= ~MS_RDONLY;
+		ROOT_DEV = old_decode_dev(tag->u.core.rootdev);
+	}
+	return 0;
+}
+
+__tagtable(ATAG_CORE, parse_tag_core);
+
+static int __init parse_tag_mem32(const struct tag *tag)
+{
+	if (meminfo.nr_banks >= NR_BANKS) {
+		printk(KERN_WARNING
+		       "Ignoring memory bank 0x%08x size %dKB\n",
+			tag->u.mem.start, tag->u.mem.size / 1024);
+		return -EINVAL;
+	}
+	meminfo.bank[meminfo.nr_banks].start = tag->u.mem.start;
+	meminfo.bank[meminfo.nr_banks].size  = tag->u.mem.size;
+	meminfo.bank[meminfo.nr_banks].node  = PHYS_TO_NID(tag->u.mem.start);
+	meminfo.nr_banks += 1;
+
+	return 0;
+}
+
+__tagtable(ATAG_MEM, parse_tag_mem32);
+
+#if defined(CONFIG_VGA_CONSOLE) || defined(CONFIG_DUMMY_CONSOLE)
+struct screen_info screen_info = {
+ .orig_video_lines	= 30,
+ .orig_video_cols	= 80,
+ .orig_video_mode	= 0,
+ .orig_video_ega_bx	= 0,
+ .orig_video_isVGA	= 1,
+ .orig_video_points	= 8
+};
+
+static int __init parse_tag_videotext(const struct tag *tag)
+{
+	screen_info.orig_x            = tag->u.videotext.x;
+	screen_info.orig_y            = tag->u.videotext.y;
+	screen_info.orig_video_page   = tag->u.videotext.video_page;
+	screen_info.orig_video_mode   = tag->u.videotext.video_mode;
+	screen_info.orig_video_cols   = tag->u.videotext.video_cols;
+	screen_info.orig_video_ega_bx = tag->u.videotext.video_ega_bx;
+	screen_info.orig_video_lines  = tag->u.videotext.video_lines;
+	screen_info.orig_video_isVGA  = tag->u.videotext.video_isvga;
+	screen_info.orig_video_points = tag->u.videotext.video_points;
+	return 0;
+}
+
+__tagtable(ATAG_VIDEOTEXT, parse_tag_videotext);
+#endif
+
+static int __init parse_tag_ramdisk(const struct tag *tag)
+{
+	setup_ramdisk((tag->u.ramdisk.flags & 1) == 0,
+		      (tag->u.ramdisk.flags & 2) == 0,
+		      tag->u.ramdisk.start, tag->u.ramdisk.size);
+	return 0;
+}
+
+__tagtable(ATAG_RAMDISK, parse_tag_ramdisk);
+
+static int __init parse_tag_initrd(const struct tag *tag)
+{
+	printk(KERN_WARNING "ATAG_INITRD is deprecated; "
+		"please update your bootloader.\n");
+	phys_initrd_start = __virt_to_phys(tag->u.initrd.start);
+	phys_initrd_size = tag->u.initrd.size;
+	return 0;
+}
+
+__tagtable(ATAG_INITRD, parse_tag_initrd);
+
+static int __init parse_tag_initrd2(const struct tag *tag)
+{
+	phys_initrd_start = tag->u.initrd.start;
+	phys_initrd_size = tag->u.initrd.size;
+	return 0;
+}
+
+__tagtable(ATAG_INITRD2, parse_tag_initrd2);
+
+static int __init parse_tag_serialnr(const struct tag *tag)
+{
+	system_serial_low = tag->u.serialnr.low;
+	system_serial_high = tag->u.serialnr.high;
+	return 0;
+}
+
+__tagtable(ATAG_SERIAL, parse_tag_serialnr);
+
+static int __init parse_tag_revision(const struct tag *tag)
+{
+	system_rev = tag->u.revision.rev;
+	return 0;
+}
+
+__tagtable(ATAG_REVISION, parse_tag_revision);
+
+static int __init parse_tag_cmdline(const struct tag *tag)
+{
+	strlcpy(default_command_line, tag->u.cmdline.cmdline, COMMAND_LINE_SIZE);
+	return 0;
+}
+
+__tagtable(ATAG_CMDLINE, parse_tag_cmdline);
+
+/*
+ * Scan the tag table for this tag, and call its parse function.
+ * The tag table is built by the linker from all the __tagtable
+ * declarations.
+ */
+static int __init parse_tag(const struct tag *tag)
+{
+	extern struct tagtable __tagtable_begin, __tagtable_end;
+	struct tagtable *t;
+
+	for (t = &__tagtable_begin; t < &__tagtable_end; t++)
+		if (tag->hdr.tag == t->tag) {
+			t->parse(tag);
+			break;
+		}
+
+	return t < &__tagtable_end;
+}
+
+/*
+ * Parse all tags in the list, checking both the global and architecture
+ * specific tag tables.
+ */
+static void __init parse_tags(const struct tag *t)
+{
+	for (; t->hdr.size; t = tag_next(t))
+		if (!parse_tag(t))
+			printk(KERN_WARNING
+				"Ignoring unrecognised tag 0x%08x\n",
+				t->hdr.tag);
+}
+
+/*
+ * This holds our defaults.
+ */
+static struct init_tags {
+	struct tag_header hdr1;
+	struct tag_core   core;
+	struct tag_header hdr2;
+	struct tag_mem32  mem;
+	struct tag_header hdr3;
+} init_tags __initdata = {
+	{ tag_size(tag_core), ATAG_CORE },
+	{ 1, PAGE_SIZE, 0xff },
+	{ tag_size(tag_mem32), ATAG_MEM },
+	{ MEM_SIZE, PHYS_OFFSET },
+	{ 0, ATAG_NONE }
+};
+
+static void (*init_machine)(void) __initdata;
+
+static int __init customize_machine(void)
+{
+	/* customizes platform devices, or adds new ones */
+	if (init_machine)
+		init_machine();
+	return 0;
+}
+arch_initcall(customize_machine);
+
+void __init setup_arch(char **cmdline_p)
+{
+	struct tag *tags = (struct tag *)&init_tags;
+	struct machine_desc *mdesc;
+	char *from = default_command_line;
+
+	setup_processor();
+	mdesc = setup_machine(machine_arch_type);
+	machine_name = mdesc->name;
+
+	if (mdesc->soft_reboot)
+		reboot_setup("s");
+
+	if (mdesc->param_offset)
+		tags = phys_to_virt(mdesc->param_offset);
+
+	/*
+	 * If we have the old style parameters, convert them to
+	 * a tag list.
+	 */
+	if (tags->hdr.tag != ATAG_CORE)
+		convert_to_tag_list(tags);
+	if (tags->hdr.tag != ATAG_CORE)
+		tags = (struct tag *)&init_tags;
+
+	if (mdesc->fixup)
+		mdesc->fixup(mdesc, tags, &from, &meminfo);
+
+	if (tags->hdr.tag == ATAG_CORE) {
+		if (meminfo.nr_banks != 0)
+			squash_mem_tags(tags);
+		parse_tags(tags);
+	}
+
+	init_mm.start_code = (unsigned long) &_text;
+	init_mm.end_code   = (unsigned long) &_etext;
+	init_mm.end_data   = (unsigned long) &_edata;
+	init_mm.brk	   = (unsigned long) &_end;
+
+	memcpy(saved_command_line, from, COMMAND_LINE_SIZE);
+	saved_command_line[COMMAND_LINE_SIZE-1] = '\0';
+	parse_cmdline(cmdline_p, from);
+	paging_init(&meminfo, mdesc);
+	request_standard_resources(&meminfo, mdesc);
+
+	/*
+	 * Set up various architecture-specific pointers
+	 */
+	init_arch_irq = mdesc->init_irq;
+	system_timer = mdesc->timer;
+	init_machine = mdesc->init_machine;
+
+#ifdef CONFIG_VT
+#if defined(CONFIG_VGA_CONSOLE)
+	conswitchp = &vga_con;
+#elif defined(CONFIG_DUMMY_CONSOLE)
+	conswitchp = &dummy_con;
+#endif
+#endif
+}
+
+
+static int __init topology_init(void)
+{
+	int cpu;
+
+	for_each_cpu(cpu)
+		register_cpu(&per_cpu(cpu_data, cpu).cpu, cpu, NULL);
+
+	return 0;
+}
+
+subsys_initcall(topology_init);
+
+static const char *hwcap_str[] = {
+	"swp",
+	"half",
+	"thumb",
+	"26bit",
+	"fastmult",
+	"fpa",
+	"vfp",
+	"edsp",
+	"java",
+	NULL
+};
+
+static void
+c_show_cache(struct seq_file *m, const char *type, unsigned int cache)
+{
+	unsigned int mult = 2 + (CACHE_M(cache) ? 1 : 0);
+
+	seq_printf(m, "%s size\t\t: %d\n"
+		      "%s assoc\t\t: %d\n"
+		      "%s line length\t: %d\n"
+		      "%s sets\t\t: %d\n",
+		type, mult << (8 + CACHE_SIZE(cache)),
+		type, (mult << CACHE_ASSOC(cache)) >> 1,
+		type, 8 << CACHE_LINE(cache),
+		type, 1 << (6 + CACHE_SIZE(cache) - CACHE_ASSOC(cache) -
+			    CACHE_LINE(cache)));
+}
+
+static int c_show(struct seq_file *m, void *v)
+{
+	int i;
+
+	seq_printf(m, "Processor\t: %s rev %d (%s)\n",
+		   cpu_name, (int)processor_id & 15, elf_platform);
+
+#if defined(CONFIG_SMP)
+	for_each_online_cpu(i) {
+		seq_printf(m, "Processor\t: %d\n", i);
+		seq_printf(m, "BogoMIPS\t: %lu.%02lu\n\n",
+			   per_cpu(cpu_data, i).loops_per_jiffy / (500000UL/HZ),
+			   (per_cpu(cpu_data, i).loops_per_jiffy / (5000UL/HZ)) % 100);
+	}
+#else /* CONFIG_SMP */
+	seq_printf(m, "BogoMIPS\t: %lu.%02lu\n",
+		   loops_per_jiffy / (500000/HZ),
+		   (loops_per_jiffy / (5000/HZ)) % 100);
+#endif
+
+	/* dump out the processor features */
+	seq_puts(m, "Features\t: ");
+
+	for (i = 0; hwcap_str[i]; i++)
+		if (elf_hwcap & (1 << i))
+			seq_printf(m, "%s ", hwcap_str[i]);
+
+	seq_printf(m, "\nCPU implementer\t: 0x%02x\n", processor_id >> 24);
+	seq_printf(m, "CPU architecture: %s\n", proc_arch[cpu_architecture()]);
+
+	if ((processor_id & 0x0000f000) == 0x00000000) {
+		/* pre-ARM7 */
+		seq_printf(m, "CPU part\t\t: %07x\n", processor_id >> 4);
+	} else {
+		if ((processor_id & 0x0000f000) == 0x00007000) {
+			/* ARM7 */
+			seq_printf(m, "CPU variant\t: 0x%02x\n",
+				   (processor_id >> 16) & 127);
+		} else {
+			/* post-ARM7 */
+			seq_printf(m, "CPU variant\t: 0x%x\n",
+				   (processor_id >> 20) & 15);
+		}
+		seq_printf(m, "CPU part\t: 0x%03x\n",
+			   (processor_id >> 4) & 0xfff);
+	}
+	seq_printf(m, "CPU revision\t: %d\n", processor_id & 15);
+
+	{
+		unsigned int cache_info = read_cpuid(CPUID_CACHETYPE);
+		if (cache_info != processor_id) {
+			seq_printf(m, "Cache type\t: %s\n"
+				      "Cache clean\t: %s\n"
+				      "Cache lockdown\t: %s\n"
+				      "Cache format\t: %s\n",
+				   cache_types[CACHE_TYPE(cache_info)],
+				   cache_clean[CACHE_TYPE(cache_info)],
+				   cache_lockdown[CACHE_TYPE(cache_info)],
+				   CACHE_S(cache_info) ? "Harvard" : "Unified");
+
+			if (CACHE_S(cache_info)) {
+				c_show_cache(m, "I", CACHE_ISIZE(cache_info));
+				c_show_cache(m, "D", CACHE_DSIZE(cache_info));
+			} else {
+				c_show_cache(m, "Cache", CACHE_ISIZE(cache_info));
+			}
+		}
+	}
+
+	seq_puts(m, "\n");
+
+	seq_printf(m, "Hardware\t: %s\n", machine_name);
+	seq_printf(m, "Revision\t: %04x\n", system_rev);
+	seq_printf(m, "Serial\t\t: %08x%08x\n",
+		   system_serial_high, system_serial_low);
+
+	return 0;
+}
+
+static void *c_start(struct seq_file *m, loff_t *pos)
+{
+	return *pos < 1 ? (void *)1 : NULL;
+}
+
+static void *c_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	++*pos;
+	return NULL;
+}
+
+static void c_stop(struct seq_file *m, void *v)
+{
+}
+
+struct seq_operations cpuinfo_op = {
+	.start	= c_start,
+	.next	= c_next,
+	.stop	= c_stop,
+	.show	= c_show
+};
