commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/kernel/dma.c b/arch/arm/kernel/dma.c
index 6739d37c2bc5..ba15b8666498 100644
--- a/arch/arm/kernel/dma.c
+++ b/arch/arm/kernel/dma.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  linux/arch/arm/kernel/dma.c
  *
  *  Copyright (C) 1995-2000 Russell King
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  *  Front-end to the DMA handling.  This handles the allocation/freeing
  *  of DMA channels, and provides a unified interface to the machines
  *  DMA facilities.

commit 3f3942aca6da351a12543aa776467791b63b3a78
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue May 15 15:57:23 2018 +0200

    proc: introduce proc_create_single{,_data}
    
    Variants of proc_create{,_data} that directly take a seq_file show
    callback and drastically reduces the boilerplate code in the callers.
    
    All trivial callers converted over.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/arch/arm/kernel/dma.c b/arch/arm/kernel/dma.c
index e651c4d0a0d9..6739d37c2bc5 100644
--- a/arch/arm/kernel/dma.c
+++ b/arch/arm/kernel/dma.c
@@ -276,21 +276,9 @@ static int proc_dma_show(struct seq_file *m, void *v)
 	return 0;
 }
 
-static int proc_dma_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, proc_dma_show, NULL);
-}
-
-static const struct file_operations proc_dma_operations = {
-	.open		= proc_dma_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
 static int __init proc_dma_init(void)
 {
-	proc_create("dma", 0, NULL, &proc_dma_operations);
+	proc_create_single("dma", 0, NULL, proc_dma_show);
 	return 0;
 }
 

commit 4ed89f2228061422ce5f62545fd0b6f6648bd2cc
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Oct 28 11:26:42 2014 +0000

    ARM: convert printk(KERN_* to pr_*
    
    Convert many (but not all) printk(KERN_* to pr_* to simplify the code.
    We take the opportunity to join some printk lines together so we don't
    split the message across several lines, and we also add a few levels
    to some messages which were previously missing them.
    
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Tested-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma.c b/arch/arm/kernel/dma.c
index 7b829d9663b1..e651c4d0a0d9 100644
--- a/arch/arm/kernel/dma.c
+++ b/arch/arm/kernel/dma.c
@@ -79,7 +79,7 @@ int request_dma(unsigned int chan, const char *device_id)
 	return ret;
 
 bad_dma:
-	printk(KERN_ERR "dma: trying to allocate DMA%d\n", chan);
+	pr_err("dma: trying to allocate DMA%d\n", chan);
 	return -EINVAL;
 
 busy:
@@ -100,7 +100,7 @@ void free_dma(unsigned int chan)
 		goto bad_dma;
 
 	if (dma->active) {
-		printk(KERN_ERR "dma%d: freeing active DMA\n", chan);
+		pr_err("dma%d: freeing active DMA\n", chan);
 		dma->d_ops->disable(chan, dma);
 		dma->active = 0;
 	}
@@ -111,11 +111,11 @@ void free_dma(unsigned int chan)
 		return;
 	}
 
-	printk(KERN_ERR "dma%d: trying to free free DMA\n", chan);
+	pr_err("dma%d: trying to free free DMA\n", chan);
 	return;
 
 bad_dma:
-	printk(KERN_ERR "dma: trying to free DMA%d\n", chan);
+	pr_err("dma: trying to free DMA%d\n", chan);
 }
 EXPORT_SYMBOL(free_dma);
 
@@ -126,8 +126,7 @@ void set_dma_sg (unsigned int chan, struct scatterlist *sg, int nr_sg)
 	dma_t *dma = dma_channel(chan);
 
 	if (dma->active)
-		printk(KERN_ERR "dma%d: altering DMA SG while "
-		       "DMA active\n", chan);
+		pr_err("dma%d: altering DMA SG while DMA active\n", chan);
 
 	dma->sg = sg;
 	dma->sgcount = nr_sg;
@@ -144,8 +143,7 @@ void __set_dma_addr (unsigned int chan, void *addr)
 	dma_t *dma = dma_channel(chan);
 
 	if (dma->active)
-		printk(KERN_ERR "dma%d: altering DMA address while "
-		       "DMA active\n", chan);
+		pr_err("dma%d: altering DMA address while DMA active\n", chan);
 
 	dma->sg = NULL;
 	dma->addr = addr;
@@ -162,8 +160,7 @@ void set_dma_count (unsigned int chan, unsigned long count)
 	dma_t *dma = dma_channel(chan);
 
 	if (dma->active)
-		printk(KERN_ERR "dma%d: altering DMA count while "
-		       "DMA active\n", chan);
+		pr_err("dma%d: altering DMA count while DMA active\n", chan);
 
 	dma->sg = NULL;
 	dma->count = count;
@@ -178,8 +175,7 @@ void set_dma_mode (unsigned int chan, unsigned int mode)
 	dma_t *dma = dma_channel(chan);
 
 	if (dma->active)
-		printk(KERN_ERR "dma%d: altering DMA mode while "
-		       "DMA active\n", chan);
+		pr_err("dma%d: altering DMA mode while DMA active\n", chan);
 
 	dma->dma_mode = mode;
 	dma->invalid = 1;
@@ -202,7 +198,7 @@ void enable_dma (unsigned int chan)
 	return;
 
 free_dma:
-	printk(KERN_ERR "dma%d: trying to enable free DMA\n", chan);
+	pr_err("dma%d: trying to enable free DMA\n", chan);
 	BUG();
 }
 EXPORT_SYMBOL(enable_dma);
@@ -223,7 +219,7 @@ void disable_dma (unsigned int chan)
 	return;
 
 free_dma:
-	printk(KERN_ERR "dma%d: trying to disable free DMA\n", chan);
+	pr_err("dma%d: trying to disable free DMA\n", chan);
 	BUG();
 }
 EXPORT_SYMBOL(disable_dma);
@@ -240,7 +236,7 @@ EXPORT_SYMBOL(dma_channel_active);
 
 void set_dma_page(unsigned int chan, char pagenr)
 {
-	printk(KERN_ERR "dma%d: trying to set_dma_page\n", chan);
+	pr_err("dma%d: trying to set_dma_page\n", chan);
 }
 EXPORT_SYMBOL(set_dma_page);
 

commit bd31b85960a7fcb2d7ede216460b8da71a88411c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 3 08:44:46 2009 -0500

    locking, ARM: Annotate low level hw locks as raw
    
    Annotate the low level hardware locks which must not be preempted.
    
    In mainline this change documents the low level nature of
    the lock - otherwise there's no functional difference. Lockdep
    and Sparse checking will work as usual.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/arm/kernel/dma.c b/arch/arm/kernel/dma.c
index 2c4a185f92cd..7b829d9663b1 100644
--- a/arch/arm/kernel/dma.c
+++ b/arch/arm/kernel/dma.c
@@ -23,7 +23,7 @@
 
 #include <asm/mach/dma.h>
 
-DEFINE_SPINLOCK(dma_spin_lock);
+DEFINE_RAW_SPINLOCK(dma_spin_lock);
 EXPORT_SYMBOL(dma_spin_lock);
 
 static dma_t *dma_chan[MAX_DMA_CHANNELS];

commit e193ba290f0228453341b41ab2bbdd963259f97e
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Dec 24 18:32:13 2009 +0000

    ARM: dma: add /proc/dma support to arch/arm/kernel/dma.c
    
    We have our own private implementation for ISA-like DMA which has been
    missing exposure via the /proc/dma interface.  Add support for this.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma.c b/arch/arm/kernel/dma.c
index 7d5b9fb01e71..2c4a185f92cd 100644
--- a/arch/arm/kernel/dma.c
+++ b/arch/arm/kernel/dma.c
@@ -16,6 +16,8 @@
 #include <linux/spinlock.h>
 #include <linux/errno.h>
 #include <linux/scatterlist.h>
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
 
 #include <asm/dma.h>
 
@@ -264,3 +266,37 @@ int get_dma_residue(unsigned int chan)
 	return ret;
 }
 EXPORT_SYMBOL(get_dma_residue);
+
+#ifdef CONFIG_PROC_FS
+static int proc_dma_show(struct seq_file *m, void *v)
+{
+	int i;
+
+	for (i = 0 ; i < MAX_DMA_CHANNELS ; i++) {
+		dma_t *dma = dma_channel(i);
+		if (dma && dma->lock)
+			seq_printf(m, "%2d: %s\n", i, dma->device_id);
+	}
+	return 0;
+}
+
+static int proc_dma_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_dma_show, NULL);
+}
+
+static const struct file_operations proc_dma_operations = {
+	.open		= proc_dma_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int __init proc_dma_init(void)
+{
+	proc_create("dma", 0, NULL, &proc_dma_operations);
+	return 0;
+}
+
+__initcall(proc_dma_init);
+#endif

commit f0ffc816250a8cc28e6824326e2d58333e058eca
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Jan 2 12:34:55 2009 +0000

    [ARM] dma: remove dmamode_t typedef
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma.c b/arch/arm/kernel/dma.c
index e7828fcd9544..7d5b9fb01e71 100644
--- a/arch/arm/kernel/dma.c
+++ b/arch/arm/kernel/dma.c
@@ -171,7 +171,7 @@ EXPORT_SYMBOL(set_dma_count);
 
 /* Set DMA direction mode
  */
-void set_dma_mode (unsigned int chan, dmamode_t mode)
+void set_dma_mode (unsigned int chan, unsigned int mode)
 {
 	dma_t *dma = dma_channel(chan);
 

commit d667522fdf637ef1b425518afe11aedba80364b2
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Dec 8 17:50:25 2008 +0000

    [ARM] dma: ensure that the single entry sg is properly initialized
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma.c b/arch/arm/kernel/dma.c
index aab24f03ea14..e7828fcd9544 100644
--- a/arch/arm/kernel/dma.c
+++ b/arch/arm/kernel/dma.c
@@ -15,6 +15,7 @@
 #include <linux/init.h>
 #include <linux/spinlock.h>
 #include <linux/errno.h>
+#include <linux/scatterlist.h>
 
 #include <asm/dma.h>
 
@@ -37,6 +38,9 @@ int __init isa_dma_add(unsigned int chan, dma_t *dma)
 {
 	if (!dma->d_ops)
 		return -EINVAL;
+
+	sg_init_table(&dma->buf, 1);
+
 	if (dma_chan[chan])
 		return -EBUSY;
 	dma_chan[chan] = dma;

commit 2f757f2ab7411cf0e2779012d8cda0cbf2f80d26
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Dec 8 16:33:30 2008 +0000

    [ARM] dma: rejig DMA initialization
    
    Rather than having the central DMA multiplexer call the architecture
    specific DMA initialization function, have each architecture DMA
    initialization function use core_initcall(), and register each DMA
    channel separately with the multiplexer.
    
    This removes the array of dma structures in the central multiplexer,
    replacing it with an array of pointers instead; this is more flexible
    since it allows the drivers to wrap the DMA structure (eventually
    allowing us to transition non-ISA DMA drivers away.)
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma.c b/arch/arm/kernel/dma.c
index 0ffea3fc22db..aab24f03ea14 100644
--- a/arch/arm/kernel/dma.c
+++ b/arch/arm/kernel/dma.c
@@ -23,16 +23,24 @@
 DEFINE_SPINLOCK(dma_spin_lock);
 EXPORT_SYMBOL(dma_spin_lock);
 
-static dma_t dma_chan[MAX_DMA_CHANNELS];
+static dma_t *dma_chan[MAX_DMA_CHANNELS];
 
 static inline dma_t *dma_channel(unsigned int chan)
 {
-	dma_t *dma = dma_chan + chan;
-
-	if (chan >= MAX_DMA_CHANNELS || !dma->d_ops)
+	if (chan >= MAX_DMA_CHANNELS)
 		return NULL;
 
-	return dma;
+	return dma_chan[chan];
+}
+
+int __init isa_dma_add(unsigned int chan, dma_t *dma)
+{
+	if (!dma->d_ops)
+		return -EINVAL;
+	if (dma_chan[chan])
+		return -EBUSY;
+	dma_chan[chan] = dma;
+	return 0;
 }
 
 /*
@@ -252,10 +260,3 @@ int get_dma_residue(unsigned int chan)
 	return ret;
 }
 EXPORT_SYMBOL(get_dma_residue);
-
-static int __init init_dma(void)
-{
-	arch_dma_init(dma_chan);
-	return 0;
-}
-core_initcall(init_dma);

commit 3afb6e9c635f735c751148beddc195daec0e35ec
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Dec 8 16:08:48 2008 +0000

    [ARM] dma: factor out code looking up the DMA channel
    
    This is a preparitory patch to allow us to easily change the way we
    add and lookup DMA channel structures.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma.c b/arch/arm/kernel/dma.c
index c31bf00e5bae..0ffea3fc22db 100644
--- a/arch/arm/kernel/dma.c
+++ b/arch/arm/kernel/dma.c
@@ -25,6 +25,16 @@ EXPORT_SYMBOL(dma_spin_lock);
 
 static dma_t dma_chan[MAX_DMA_CHANNELS];
 
+static inline dma_t *dma_channel(unsigned int chan)
+{
+	dma_t *dma = dma_chan + chan;
+
+	if (chan >= MAX_DMA_CHANNELS || !dma->d_ops)
+		return NULL;
+
+	return dma;
+}
+
 /*
  * Request DMA channel
  *
@@ -32,10 +42,10 @@ static dma_t dma_chan[MAX_DMA_CHANNELS];
  */
 int request_dma(unsigned int chan, const char *device_id)
 {
-	dma_t *dma = dma_chan + chan;
+	dma_t *dma = dma_channel(chan);
 	int ret;
 
-	if (chan >= MAX_DMA_CHANNELS || !dma->d_ops)
+	if (!dma)
 		goto bad_dma;
 
 	if (xchg(&dma->lock, 1) != 0)
@@ -70,9 +80,9 @@ EXPORT_SYMBOL(request_dma);
  */
 void free_dma(unsigned int chan)
 {
-	dma_t *dma = dma_chan + chan;
+	dma_t *dma = dma_channel(chan);
 
-	if (chan >= MAX_DMA_CHANNELS || !dma->d_ops)
+	if (!dma)
 		goto bad_dma;
 
 	if (dma->active) {
@@ -99,7 +109,7 @@ EXPORT_SYMBOL(free_dma);
  */
 void set_dma_sg (unsigned int chan, struct scatterlist *sg, int nr_sg)
 {
-	dma_t *dma = dma_chan + chan;
+	dma_t *dma = dma_channel(chan);
 
 	if (dma->active)
 		printk(KERN_ERR "dma%d: altering DMA SG while "
@@ -117,7 +127,7 @@ EXPORT_SYMBOL(set_dma_sg);
  */
 void __set_dma_addr (unsigned int chan, void *addr)
 {
-	dma_t *dma = dma_chan + chan;
+	dma_t *dma = dma_channel(chan);
 
 	if (dma->active)
 		printk(KERN_ERR "dma%d: altering DMA address while "
@@ -135,7 +145,7 @@ EXPORT_SYMBOL(__set_dma_addr);
  */
 void set_dma_count (unsigned int chan, unsigned long count)
 {
-	dma_t *dma = dma_chan + chan;
+	dma_t *dma = dma_channel(chan);
 
 	if (dma->active)
 		printk(KERN_ERR "dma%d: altering DMA count while "
@@ -151,7 +161,7 @@ EXPORT_SYMBOL(set_dma_count);
  */
 void set_dma_mode (unsigned int chan, dmamode_t mode)
 {
-	dma_t *dma = dma_chan + chan;
+	dma_t *dma = dma_channel(chan);
 
 	if (dma->active)
 		printk(KERN_ERR "dma%d: altering DMA mode while "
@@ -166,7 +176,7 @@ EXPORT_SYMBOL(set_dma_mode);
  */
 void enable_dma (unsigned int chan)
 {
-	dma_t *dma = dma_chan + chan;
+	dma_t *dma = dma_channel(chan);
 
 	if (!dma->lock)
 		goto free_dma;
@@ -187,7 +197,7 @@ EXPORT_SYMBOL(enable_dma);
  */
 void disable_dma (unsigned int chan)
 {
-	dma_t *dma = dma_chan + chan;
+	dma_t *dma = dma_channel(chan);
 
 	if (!dma->lock)
 		goto free_dma;
@@ -209,7 +219,8 @@ EXPORT_SYMBOL(disable_dma);
  */
 int dma_channel_active(unsigned int chan)
 {
-	return dma_chan[chan].active;
+	dma_t *dma = dma_channel(chan);
+	return dma->active;
 }
 EXPORT_SYMBOL(dma_channel_active);
 
@@ -221,7 +232,7 @@ EXPORT_SYMBOL(set_dma_page);
 
 void set_dma_speed(unsigned int chan, int cycle_ns)
 {
-	dma_t *dma = dma_chan + chan;
+	dma_t *dma = dma_channel(chan);
 	int ret = 0;
 
 	if (dma->d_ops->setspeed)
@@ -232,7 +243,7 @@ EXPORT_SYMBOL(set_dma_speed);
 
 int get_dma_residue(unsigned int chan)
 {
-	dma_t *dma = dma_chan + chan;
+	dma_t *dma = dma_channel(chan);
 	int ret = 0;
 
 	if (dma->d_ops->residue)
@@ -247,5 +258,4 @@ static int __init init_dma(void)
 	arch_dma_init(dma_chan);
 	return 0;
 }
-
 core_initcall(init_dma);

commit 1df8130278c4543555fea697e5714fbac300b899
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Dec 8 15:58:50 2008 +0000

    [ARM] dma: remove dmach_t typedef
    
    Remove a pointless integer typedef.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma.c b/arch/arm/kernel/dma.c
index d006085ed7e7..c31bf00e5bae 100644
--- a/arch/arm/kernel/dma.c
+++ b/arch/arm/kernel/dma.c
@@ -30,12 +30,12 @@ static dma_t dma_chan[MAX_DMA_CHANNELS];
  *
  * On certain platforms, we have to allocate an interrupt as well...
  */
-int request_dma(dmach_t channel, const char *device_id)
+int request_dma(unsigned int chan, const char *device_id)
 {
-	dma_t *dma = dma_chan + channel;
+	dma_t *dma = dma_chan + chan;
 	int ret;
 
-	if (channel >= MAX_DMA_CHANNELS || !dma->d_ops)
+	if (chan >= MAX_DMA_CHANNELS || !dma->d_ops)
 		goto bad_dma;
 
 	if (xchg(&dma->lock, 1) != 0)
@@ -47,7 +47,7 @@ int request_dma(dmach_t channel, const char *device_id)
 
 	ret = 0;
 	if (dma->d_ops->request)
-		ret = dma->d_ops->request(channel, dma);
+		ret = dma->d_ops->request(chan, dma);
 
 	if (ret)
 		xchg(&dma->lock, 0);
@@ -55,7 +55,7 @@ int request_dma(dmach_t channel, const char *device_id)
 	return ret;
 
 bad_dma:
-	printk(KERN_ERR "dma: trying to allocate DMA%d\n", channel);
+	printk(KERN_ERR "dma: trying to allocate DMA%d\n", chan);
 	return -EINVAL;
 
 busy:
@@ -68,42 +68,42 @@ EXPORT_SYMBOL(request_dma);
  *
  * On certain platforms, we have to free interrupt as well...
  */
-void free_dma(dmach_t channel)
+void free_dma(unsigned int chan)
 {
-	dma_t *dma = dma_chan + channel;
+	dma_t *dma = dma_chan + chan;
 
-	if (channel >= MAX_DMA_CHANNELS || !dma->d_ops)
+	if (chan >= MAX_DMA_CHANNELS || !dma->d_ops)
 		goto bad_dma;
 
 	if (dma->active) {
-		printk(KERN_ERR "dma%d: freeing active DMA\n", channel);
-		dma->d_ops->disable(channel, dma);
+		printk(KERN_ERR "dma%d: freeing active DMA\n", chan);
+		dma->d_ops->disable(chan, dma);
 		dma->active = 0;
 	}
 
 	if (xchg(&dma->lock, 0) != 0) {
 		if (dma->d_ops->free)
-			dma->d_ops->free(channel, dma);
+			dma->d_ops->free(chan, dma);
 		return;
 	}
 
-	printk(KERN_ERR "dma%d: trying to free free DMA\n", channel);
+	printk(KERN_ERR "dma%d: trying to free free DMA\n", chan);
 	return;
 
 bad_dma:
-	printk(KERN_ERR "dma: trying to free DMA%d\n", channel);
+	printk(KERN_ERR "dma: trying to free DMA%d\n", chan);
 }
 EXPORT_SYMBOL(free_dma);
 
 /* Set DMA Scatter-Gather list
  */
-void set_dma_sg (dmach_t channel, struct scatterlist *sg, int nr_sg)
+void set_dma_sg (unsigned int chan, struct scatterlist *sg, int nr_sg)
 {
-	dma_t *dma = dma_chan + channel;
+	dma_t *dma = dma_chan + chan;
 
 	if (dma->active)
 		printk(KERN_ERR "dma%d: altering DMA SG while "
-		       "DMA active\n", channel);
+		       "DMA active\n", chan);
 
 	dma->sg = sg;
 	dma->sgcount = nr_sg;
@@ -115,13 +115,13 @@ EXPORT_SYMBOL(set_dma_sg);
  *
  * Copy address to the structure, and set the invalid bit
  */
-void __set_dma_addr (dmach_t channel, void *addr)
+void __set_dma_addr (unsigned int chan, void *addr)
 {
-	dma_t *dma = dma_chan + channel;
+	dma_t *dma = dma_chan + chan;
 
 	if (dma->active)
 		printk(KERN_ERR "dma%d: altering DMA address while "
-		       "DMA active\n", channel);
+		       "DMA active\n", chan);
 
 	dma->sg = NULL;
 	dma->addr = addr;
@@ -133,13 +133,13 @@ EXPORT_SYMBOL(__set_dma_addr);
  *
  * Copy address to the structure, and set the invalid bit
  */
-void set_dma_count (dmach_t channel, unsigned long count)
+void set_dma_count (unsigned int chan, unsigned long count)
 {
-	dma_t *dma = dma_chan + channel;
+	dma_t *dma = dma_chan + chan;
 
 	if (dma->active)
 		printk(KERN_ERR "dma%d: altering DMA count while "
-		       "DMA active\n", channel);
+		       "DMA active\n", chan);
 
 	dma->sg = NULL;
 	dma->count = count;
@@ -149,13 +149,13 @@ EXPORT_SYMBOL(set_dma_count);
 
 /* Set DMA direction mode
  */
-void set_dma_mode (dmach_t channel, dmamode_t mode)
+void set_dma_mode (unsigned int chan, dmamode_t mode)
 {
-	dma_t *dma = dma_chan + channel;
+	dma_t *dma = dma_chan + chan;
 
 	if (dma->active)
 		printk(KERN_ERR "dma%d: altering DMA mode while "
-		       "DMA active\n", channel);
+		       "DMA active\n", chan);
 
 	dma->dma_mode = mode;
 	dma->invalid = 1;
@@ -164,42 +164,42 @@ EXPORT_SYMBOL(set_dma_mode);
 
 /* Enable DMA channel
  */
-void enable_dma (dmach_t channel)
+void enable_dma (unsigned int chan)
 {
-	dma_t *dma = dma_chan + channel;
+	dma_t *dma = dma_chan + chan;
 
 	if (!dma->lock)
 		goto free_dma;
 
 	if (dma->active == 0) {
 		dma->active = 1;
-		dma->d_ops->enable(channel, dma);
+		dma->d_ops->enable(chan, dma);
 	}
 	return;
 
 free_dma:
-	printk(KERN_ERR "dma%d: trying to enable free DMA\n", channel);
+	printk(KERN_ERR "dma%d: trying to enable free DMA\n", chan);
 	BUG();
 }
 EXPORT_SYMBOL(enable_dma);
 
 /* Disable DMA channel
  */
-void disable_dma (dmach_t channel)
+void disable_dma (unsigned int chan)
 {
-	dma_t *dma = dma_chan + channel;
+	dma_t *dma = dma_chan + chan;
 
 	if (!dma->lock)
 		goto free_dma;
 
 	if (dma->active == 1) {
 		dma->active = 0;
-		dma->d_ops->disable(channel, dma);
+		dma->d_ops->disable(chan, dma);
 	}
 	return;
 
 free_dma:
-	printk(KERN_ERR "dma%d: trying to disable free DMA\n", channel);
+	printk(KERN_ERR "dma%d: trying to disable free DMA\n", chan);
 	BUG();
 }
 EXPORT_SYMBOL(disable_dma);
@@ -207,36 +207,36 @@ EXPORT_SYMBOL(disable_dma);
 /*
  * Is the specified DMA channel active?
  */
-int dma_channel_active(dmach_t channel)
+int dma_channel_active(unsigned int chan)
 {
-	return dma_chan[channel].active;
+	return dma_chan[chan].active;
 }
 EXPORT_SYMBOL(dma_channel_active);
 
-void set_dma_page(dmach_t channel, char pagenr)
+void set_dma_page(unsigned int chan, char pagenr)
 {
-	printk(KERN_ERR "dma%d: trying to set_dma_page\n", channel);
+	printk(KERN_ERR "dma%d: trying to set_dma_page\n", chan);
 }
 EXPORT_SYMBOL(set_dma_page);
 
-void set_dma_speed(dmach_t channel, int cycle_ns)
+void set_dma_speed(unsigned int chan, int cycle_ns)
 {
-	dma_t *dma = dma_chan + channel;
+	dma_t *dma = dma_chan + chan;
 	int ret = 0;
 
 	if (dma->d_ops->setspeed)
-		ret = dma->d_ops->setspeed(channel, dma, cycle_ns);
+		ret = dma->d_ops->setspeed(chan, dma, cycle_ns);
 	dma->speed = ret;
 }
 EXPORT_SYMBOL(set_dma_speed);
 
-int get_dma_residue(dmach_t channel)
+int get_dma_residue(unsigned int chan)
 {
-	dma_t *dma = dma_chan + channel;
+	dma_t *dma = dma_chan + chan;
 	int ret = 0;
 
 	if (dma->d_ops->residue)
-		ret = dma->d_ops->residue(channel, dma);
+		ret = dma->d_ops->residue(chan, dma);
 
 	return ret;
 }

commit a70973c2141f98e2046f7ce9a29774bf254cf70f
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Fri Oct 3 00:31:19 2008 +0400

    proc: remove unused get_dma_list()
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>

diff --git a/arch/arm/kernel/dma.c b/arch/arm/kernel/dma.c
index ba99a2035523..d006085ed7e7 100644
--- a/arch/arm/kernel/dma.c
+++ b/arch/arm/kernel/dma.c
@@ -25,23 +25,6 @@ EXPORT_SYMBOL(dma_spin_lock);
 
 static dma_t dma_chan[MAX_DMA_CHANNELS];
 
-/*
- * Get dma list for /proc/dma
- */
-int get_dma_list(char *buf)
-{
-	dma_t *dma;
-	char *p = buf;
-	int i;
-
-	for (i = 0, dma = dma_chan; i < MAX_DMA_CHANNELS; i++, dma++)
-		if (dma->lock)
-			p += sprintf(p, "%2d: %14s %s\n", i,
-				     dma->d_ops->type, dma->device_id);
-
-	return p - buf;
-}
-
 /*
  * Request DMA channel
  *

commit ec14d7964bc3c89fb24c95af00d39033afc32f8e
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Mar 31 21:36:53 2007 +0100

    [ARM] Export dma_channel_active()
    
    dma_channel_active() is used by some modules and is part of our
    DMA API, so export it.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma.c b/arch/arm/kernel/dma.c
index 5a0f4bc5da95..ba99a2035523 100644
--- a/arch/arm/kernel/dma.c
+++ b/arch/arm/kernel/dma.c
@@ -228,6 +228,7 @@ int dma_channel_active(dmach_t channel)
 {
 	return dma_chan[channel].active;
 }
+EXPORT_SYMBOL(dma_channel_active);
 
 void set_dma_page(dmach_t channel, char pagenr)
 {

commit d7b4a75677f8f2a559b0c55a550b364e79a8d302
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Jan 4 15:52:45 2006 +0000

    [ARM] Move DMA exports to be next to each function
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma.c b/arch/arm/kernel/dma.c
index 62c8966a8b77..5a0f4bc5da95 100644
--- a/arch/arm/kernel/dma.c
+++ b/arch/arm/kernel/dma.c
@@ -21,6 +21,7 @@
 #include <asm/mach/dma.h>
 
 DEFINE_SPINLOCK(dma_spin_lock);
+EXPORT_SYMBOL(dma_spin_lock);
 
 static dma_t dma_chan[MAX_DMA_CHANNELS];
 
@@ -77,6 +78,7 @@ int request_dma(dmach_t channel, const char *device_id)
 busy:
 	return -EBUSY;
 }
+EXPORT_SYMBOL(request_dma);
 
 /*
  * Free DMA channel
@@ -108,6 +110,7 @@ void free_dma(dmach_t channel)
 bad_dma:
 	printk(KERN_ERR "dma: trying to free DMA%d\n", channel);
 }
+EXPORT_SYMBOL(free_dma);
 
 /* Set DMA Scatter-Gather list
  */
@@ -123,6 +126,7 @@ void set_dma_sg (dmach_t channel, struct scatterlist *sg, int nr_sg)
 	dma->sgcount = nr_sg;
 	dma->invalid = 1;
 }
+EXPORT_SYMBOL(set_dma_sg);
 
 /* Set DMA address
  *
@@ -140,6 +144,7 @@ void __set_dma_addr (dmach_t channel, void *addr)
 	dma->addr = addr;
 	dma->invalid = 1;
 }
+EXPORT_SYMBOL(__set_dma_addr);
 
 /* Set DMA byte count
  *
@@ -157,6 +162,7 @@ void set_dma_count (dmach_t channel, unsigned long count)
 	dma->count = count;
 	dma->invalid = 1;
 }
+EXPORT_SYMBOL(set_dma_count);
 
 /* Set DMA direction mode
  */
@@ -171,6 +177,7 @@ void set_dma_mode (dmach_t channel, dmamode_t mode)
 	dma->dma_mode = mode;
 	dma->invalid = 1;
 }
+EXPORT_SYMBOL(set_dma_mode);
 
 /* Enable DMA channel
  */
@@ -191,6 +198,7 @@ void enable_dma (dmach_t channel)
 	printk(KERN_ERR "dma%d: trying to enable free DMA\n", channel);
 	BUG();
 }
+EXPORT_SYMBOL(enable_dma);
 
 /* Disable DMA channel
  */
@@ -211,6 +219,7 @@ void disable_dma (dmach_t channel)
 	printk(KERN_ERR "dma%d: trying to disable free DMA\n", channel);
 	BUG();
 }
+EXPORT_SYMBOL(disable_dma);
 
 /*
  * Is the specified DMA channel active?
@@ -224,6 +233,7 @@ void set_dma_page(dmach_t channel, char pagenr)
 {
 	printk(KERN_ERR "dma%d: trying to set_dma_page\n", channel);
 }
+EXPORT_SYMBOL(set_dma_page);
 
 void set_dma_speed(dmach_t channel, int cycle_ns)
 {
@@ -234,6 +244,7 @@ void set_dma_speed(dmach_t channel, int cycle_ns)
 		ret = dma->d_ops->setspeed(channel, dma, cycle_ns);
 	dma->speed = ret;
 }
+EXPORT_SYMBOL(set_dma_speed);
 
 int get_dma_residue(dmach_t channel)
 {
@@ -245,6 +256,7 @@ int get_dma_residue(dmach_t channel)
 
 	return ret;
 }
+EXPORT_SYMBOL(get_dma_residue);
 
 static int __init init_dma(void)
 {
@@ -253,17 +265,3 @@ static int __init init_dma(void)
 }
 
 core_initcall(init_dma);
-
-EXPORT_SYMBOL(request_dma);
-EXPORT_SYMBOL(free_dma);
-EXPORT_SYMBOL(enable_dma);
-EXPORT_SYMBOL(disable_dma);
-EXPORT_SYMBOL(__set_dma_addr);
-EXPORT_SYMBOL(set_dma_count);
-EXPORT_SYMBOL(set_dma_mode);
-EXPORT_SYMBOL(set_dma_page);
-EXPORT_SYMBOL(get_dma_residue);
-EXPORT_SYMBOL(set_dma_sg);
-EXPORT_SYMBOL(set_dma_speed);
-
-EXPORT_SYMBOL(dma_spin_lock);

commit 95ba9fb06be4a8714c98df6097eab1808c72fa98
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Jan 4 15:51:51 2006 +0000

    [ARM] Remove definition of MAX_DMA_CHANNELS to zero
    
    Since we now only build arch/arm/kernel/dma.c on machine types
    which set ISA_DMA_API, we don't need to define MAX_DMA_CHANNELS
    to 0 to indicate this - this definition becomes superfluous.
    Remove it.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma.c b/arch/arm/kernel/dma.c
index 3b325ef55a28..62c8966a8b77 100644
--- a/arch/arm/kernel/dma.c
+++ b/arch/arm/kernel/dma.c
@@ -22,8 +22,6 @@
 
 DEFINE_SPINLOCK(dma_spin_lock);
 
-#if MAX_DMA_CHANNELS > 0
-
 static dma_t dma_chan[MAX_DMA_CHANNELS];
 
 /*
@@ -256,32 +254,6 @@ static int __init init_dma(void)
 
 core_initcall(init_dma);
 
-#else
-
-int request_dma(dmach_t channel, const char *device_id)
-{
-	return -EINVAL;
-}
-
-int get_dma_residue(dmach_t channel)
-{
-	return 0;
-}
-
-#define GLOBAL_ALIAS(_a,_b) asm (".set " #_a "," #_b "; .globl " #_a)
-GLOBAL_ALIAS(disable_dma, get_dma_residue);
-GLOBAL_ALIAS(enable_dma, get_dma_residue);
-GLOBAL_ALIAS(free_dma, get_dma_residue);
-GLOBAL_ALIAS(get_dma_list, get_dma_residue);
-GLOBAL_ALIAS(set_dma_mode, get_dma_residue);
-GLOBAL_ALIAS(set_dma_page, get_dma_residue);
-GLOBAL_ALIAS(set_dma_count, get_dma_residue);
-GLOBAL_ALIAS(__set_dma_addr, get_dma_residue);
-GLOBAL_ALIAS(set_dma_sg, get_dma_residue);
-GLOBAL_ALIAS(set_dma_speed, get_dma_residue);
-
-#endif
-
 EXPORT_SYMBOL(request_dma);
 EXPORT_SYMBOL(free_dma);
 EXPORT_SYMBOL(enable_dma);

commit 6842b9299272a9471a7e94e046b953f6ffe3db9d
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Jan 4 15:17:08 2006 +0000

    [ARM] Use core_initcall() to initialise ARM DMA
    
    There's no need to have DMA initialised at the same time as
    interrupts.  Move it to a core_initcall().
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma.c b/arch/arm/kernel/dma.c
index 913fd947528c..3b325ef55a28 100644
--- a/arch/arm/kernel/dma.c
+++ b/arch/arm/kernel/dma.c
@@ -248,11 +248,14 @@ int get_dma_residue(dmach_t channel)
 	return ret;
 }
 
-void __init init_dma(void)
+static int __init init_dma(void)
 {
 	arch_dma_init(dma_chan);
+	return 0;
 }
 
+core_initcall(init_dma);
+
 #else
 
 int request_dma(dmach_t channel, const char *device_id)
@@ -276,7 +279,6 @@ GLOBAL_ALIAS(set_dma_count, get_dma_residue);
 GLOBAL_ALIAS(__set_dma_addr, get_dma_residue);
 GLOBAL_ALIAS(set_dma_sg, get_dma_residue);
 GLOBAL_ALIAS(set_dma_speed, get_dma_residue);
-GLOBAL_ALIAS(init_dma, get_dma_residue);
 
 #endif
 

commit 7cdad482974792419cfe4b0affca689170116f49
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Jan 4 15:08:30 2006 +0000

    [ARM] Remove '__address' from scatterlist and convert to DMA API
    
    The old __address element in struct scatterlist remained from older
    kernels because the ARM DMA emulation code made use of it.  Move
    this field into struct dma_struct, and convert DMA emulation code
    to setup a SG entry as required.
    
    Also, convert DMA emulation code to use the new DMA API rather
    than the PCI DMA API.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma.c b/arch/arm/kernel/dma.c
index 3aedada71046..913fd947528c 100644
--- a/arch/arm/kernel/dma.c
+++ b/arch/arm/kernel/dma.c
@@ -123,7 +123,6 @@ void set_dma_sg (dmach_t channel, struct scatterlist *sg, int nr_sg)
 
 	dma->sg = sg;
 	dma->sgcount = nr_sg;
-	dma->using_sg = 1;
 	dma->invalid = 1;
 }
 
@@ -139,10 +138,8 @@ void __set_dma_addr (dmach_t channel, void *addr)
 		printk(KERN_ERR "dma%d: altering DMA address while "
 		       "DMA active\n", channel);
 
-	dma->sg = &dma->buf;
-	dma->sgcount = 1;
-	dma->buf.__address = addr;
-	dma->using_sg = 0;
+	dma->sg = NULL;
+	dma->addr = addr;
 	dma->invalid = 1;
 }
 
@@ -158,10 +155,8 @@ void set_dma_count (dmach_t channel, unsigned long count)
 		printk(KERN_ERR "dma%d: altering DMA count while "
 		       "DMA active\n", channel);
 
-	dma->sg = &dma->buf;
-	dma->sgcount = 1;
-	dma->buf.length = count;
-	dma->using_sg = 0;
+	dma->sg = NULL;
+	dma->count = count;
 	dma->invalid = 1;
 }
 

commit 333c9624b728a9e83b741ea75836aa114ec35272
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Jan 4 14:41:29 2006 +0000

    [ARM] Move ISA DMA bus_to_virt() out of set_dma_addr()
    
    Allow the compiler to optimise the bus_to_virt(virt_to_bus())
    transformation in the ARM ISA DMA interface.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma.c b/arch/arm/kernel/dma.c
index 8d6381cd8915..3aedada71046 100644
--- a/arch/arm/kernel/dma.c
+++ b/arch/arm/kernel/dma.c
@@ -131,7 +131,7 @@ void set_dma_sg (dmach_t channel, struct scatterlist *sg, int nr_sg)
  *
  * Copy address to the structure, and set the invalid bit
  */
-void set_dma_addr (dmach_t channel, unsigned long physaddr)
+void __set_dma_addr (dmach_t channel, void *addr)
 {
 	dma_t *dma = dma_chan + channel;
 
@@ -141,7 +141,7 @@ void set_dma_addr (dmach_t channel, unsigned long physaddr)
 
 	dma->sg = &dma->buf;
 	dma->sgcount = 1;
-	dma->buf.__address = bus_to_virt(physaddr);
+	dma->buf.__address = addr;
 	dma->using_sg = 0;
 	dma->invalid = 1;
 }
@@ -278,7 +278,7 @@ GLOBAL_ALIAS(get_dma_list, get_dma_residue);
 GLOBAL_ALIAS(set_dma_mode, get_dma_residue);
 GLOBAL_ALIAS(set_dma_page, get_dma_residue);
 GLOBAL_ALIAS(set_dma_count, get_dma_residue);
-GLOBAL_ALIAS(set_dma_addr, get_dma_residue);
+GLOBAL_ALIAS(__set_dma_addr, get_dma_residue);
 GLOBAL_ALIAS(set_dma_sg, get_dma_residue);
 GLOBAL_ALIAS(set_dma_speed, get_dma_residue);
 GLOBAL_ALIAS(init_dma, get_dma_residue);
@@ -289,7 +289,7 @@ EXPORT_SYMBOL(request_dma);
 EXPORT_SYMBOL(free_dma);
 EXPORT_SYMBOL(enable_dma);
 EXPORT_SYMBOL(disable_dma);
-EXPORT_SYMBOL(set_dma_addr);
+EXPORT_SYMBOL(__set_dma_addr);
 EXPORT_SYMBOL(set_dma_count);
 EXPORT_SYMBOL(set_dma_mode);
 EXPORT_SYMBOL(set_dma_page);

commit 78ff18a412da24a4b79c6a97000ef5e467e813da
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Jan 3 17:39:34 2006 +0000

    [ARM] Cleanup ARM includes
    
    arch/arm/kernel/entry-armv.S has contained a comment suggesting
    that asm/hardware.h and asm/arch/irqs.h should be moved into the
    asm/arch/entry-macro.S include.  So move the includes to these
    two files as required.
    
    Add missing includes (asm/hardware.h, asm/io.h) to asm/arch/system.h
    includes which use those facilities, and remove asm/io.h from
    kernel/process.c.
    
    Remove other unnecessary includes from arch/arm/kernel, arch/arm/mm
    and arch/arm/mach-footbridge.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/dma.c b/arch/arm/kernel/dma.c
index 2b7883884234..8d6381cd8915 100644
--- a/arch/arm/kernel/dma.c
+++ b/arch/arm/kernel/dma.c
@@ -12,8 +12,6 @@
  *  DMA facilities.
  */
 #include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/mman.h>
 #include <linux/init.h>
 #include <linux/spinlock.h>
 #include <linux/errno.h>

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/arm/kernel/dma.c b/arch/arm/kernel/dma.c
new file mode 100644
index 000000000000..2b7883884234
--- /dev/null
+++ b/arch/arm/kernel/dma.c
@@ -0,0 +1,302 @@
+/*
+ *  linux/arch/arm/kernel/dma.c
+ *
+ *  Copyright (C) 1995-2000 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Front-end to the DMA handling.  This handles the allocation/freeing
+ *  of DMA channels, and provides a unified interface to the machines
+ *  DMA facilities.
+ */
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/mman.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/errno.h>
+
+#include <asm/dma.h>
+
+#include <asm/mach/dma.h>
+
+DEFINE_SPINLOCK(dma_spin_lock);
+
+#if MAX_DMA_CHANNELS > 0
+
+static dma_t dma_chan[MAX_DMA_CHANNELS];
+
+/*
+ * Get dma list for /proc/dma
+ */
+int get_dma_list(char *buf)
+{
+	dma_t *dma;
+	char *p = buf;
+	int i;
+
+	for (i = 0, dma = dma_chan; i < MAX_DMA_CHANNELS; i++, dma++)
+		if (dma->lock)
+			p += sprintf(p, "%2d: %14s %s\n", i,
+				     dma->d_ops->type, dma->device_id);
+
+	return p - buf;
+}
+
+/*
+ * Request DMA channel
+ *
+ * On certain platforms, we have to allocate an interrupt as well...
+ */
+int request_dma(dmach_t channel, const char *device_id)
+{
+	dma_t *dma = dma_chan + channel;
+	int ret;
+
+	if (channel >= MAX_DMA_CHANNELS || !dma->d_ops)
+		goto bad_dma;
+
+	if (xchg(&dma->lock, 1) != 0)
+		goto busy;
+
+	dma->device_id = device_id;
+	dma->active    = 0;
+	dma->invalid   = 1;
+
+	ret = 0;
+	if (dma->d_ops->request)
+		ret = dma->d_ops->request(channel, dma);
+
+	if (ret)
+		xchg(&dma->lock, 0);
+
+	return ret;
+
+bad_dma:
+	printk(KERN_ERR "dma: trying to allocate DMA%d\n", channel);
+	return -EINVAL;
+
+busy:
+	return -EBUSY;
+}
+
+/*
+ * Free DMA channel
+ *
+ * On certain platforms, we have to free interrupt as well...
+ */
+void free_dma(dmach_t channel)
+{
+	dma_t *dma = dma_chan + channel;
+
+	if (channel >= MAX_DMA_CHANNELS || !dma->d_ops)
+		goto bad_dma;
+
+	if (dma->active) {
+		printk(KERN_ERR "dma%d: freeing active DMA\n", channel);
+		dma->d_ops->disable(channel, dma);
+		dma->active = 0;
+	}
+
+	if (xchg(&dma->lock, 0) != 0) {
+		if (dma->d_ops->free)
+			dma->d_ops->free(channel, dma);
+		return;
+	}
+
+	printk(KERN_ERR "dma%d: trying to free free DMA\n", channel);
+	return;
+
+bad_dma:
+	printk(KERN_ERR "dma: trying to free DMA%d\n", channel);
+}
+
+/* Set DMA Scatter-Gather list
+ */
+void set_dma_sg (dmach_t channel, struct scatterlist *sg, int nr_sg)
+{
+	dma_t *dma = dma_chan + channel;
+
+	if (dma->active)
+		printk(KERN_ERR "dma%d: altering DMA SG while "
+		       "DMA active\n", channel);
+
+	dma->sg = sg;
+	dma->sgcount = nr_sg;
+	dma->using_sg = 1;
+	dma->invalid = 1;
+}
+
+/* Set DMA address
+ *
+ * Copy address to the structure, and set the invalid bit
+ */
+void set_dma_addr (dmach_t channel, unsigned long physaddr)
+{
+	dma_t *dma = dma_chan + channel;
+
+	if (dma->active)
+		printk(KERN_ERR "dma%d: altering DMA address while "
+		       "DMA active\n", channel);
+
+	dma->sg = &dma->buf;
+	dma->sgcount = 1;
+	dma->buf.__address = bus_to_virt(physaddr);
+	dma->using_sg = 0;
+	dma->invalid = 1;
+}
+
+/* Set DMA byte count
+ *
+ * Copy address to the structure, and set the invalid bit
+ */
+void set_dma_count (dmach_t channel, unsigned long count)
+{
+	dma_t *dma = dma_chan + channel;
+
+	if (dma->active)
+		printk(KERN_ERR "dma%d: altering DMA count while "
+		       "DMA active\n", channel);
+
+	dma->sg = &dma->buf;
+	dma->sgcount = 1;
+	dma->buf.length = count;
+	dma->using_sg = 0;
+	dma->invalid = 1;
+}
+
+/* Set DMA direction mode
+ */
+void set_dma_mode (dmach_t channel, dmamode_t mode)
+{
+	dma_t *dma = dma_chan + channel;
+
+	if (dma->active)
+		printk(KERN_ERR "dma%d: altering DMA mode while "
+		       "DMA active\n", channel);
+
+	dma->dma_mode = mode;
+	dma->invalid = 1;
+}
+
+/* Enable DMA channel
+ */
+void enable_dma (dmach_t channel)
+{
+	dma_t *dma = dma_chan + channel;
+
+	if (!dma->lock)
+		goto free_dma;
+
+	if (dma->active == 0) {
+		dma->active = 1;
+		dma->d_ops->enable(channel, dma);
+	}
+	return;
+
+free_dma:
+	printk(KERN_ERR "dma%d: trying to enable free DMA\n", channel);
+	BUG();
+}
+
+/* Disable DMA channel
+ */
+void disable_dma (dmach_t channel)
+{
+	dma_t *dma = dma_chan + channel;
+
+	if (!dma->lock)
+		goto free_dma;
+
+	if (dma->active == 1) {
+		dma->active = 0;
+		dma->d_ops->disable(channel, dma);
+	}
+	return;
+
+free_dma:
+	printk(KERN_ERR "dma%d: trying to disable free DMA\n", channel);
+	BUG();
+}
+
+/*
+ * Is the specified DMA channel active?
+ */
+int dma_channel_active(dmach_t channel)
+{
+	return dma_chan[channel].active;
+}
+
+void set_dma_page(dmach_t channel, char pagenr)
+{
+	printk(KERN_ERR "dma%d: trying to set_dma_page\n", channel);
+}
+
+void set_dma_speed(dmach_t channel, int cycle_ns)
+{
+	dma_t *dma = dma_chan + channel;
+	int ret = 0;
+
+	if (dma->d_ops->setspeed)
+		ret = dma->d_ops->setspeed(channel, dma, cycle_ns);
+	dma->speed = ret;
+}
+
+int get_dma_residue(dmach_t channel)
+{
+	dma_t *dma = dma_chan + channel;
+	int ret = 0;
+
+	if (dma->d_ops->residue)
+		ret = dma->d_ops->residue(channel, dma);
+
+	return ret;
+}
+
+void __init init_dma(void)
+{
+	arch_dma_init(dma_chan);
+}
+
+#else
+
+int request_dma(dmach_t channel, const char *device_id)
+{
+	return -EINVAL;
+}
+
+int get_dma_residue(dmach_t channel)
+{
+	return 0;
+}
+
+#define GLOBAL_ALIAS(_a,_b) asm (".set " #_a "," #_b "; .globl " #_a)
+GLOBAL_ALIAS(disable_dma, get_dma_residue);
+GLOBAL_ALIAS(enable_dma, get_dma_residue);
+GLOBAL_ALIAS(free_dma, get_dma_residue);
+GLOBAL_ALIAS(get_dma_list, get_dma_residue);
+GLOBAL_ALIAS(set_dma_mode, get_dma_residue);
+GLOBAL_ALIAS(set_dma_page, get_dma_residue);
+GLOBAL_ALIAS(set_dma_count, get_dma_residue);
+GLOBAL_ALIAS(set_dma_addr, get_dma_residue);
+GLOBAL_ALIAS(set_dma_sg, get_dma_residue);
+GLOBAL_ALIAS(set_dma_speed, get_dma_residue);
+GLOBAL_ALIAS(init_dma, get_dma_residue);
+
+#endif
+
+EXPORT_SYMBOL(request_dma);
+EXPORT_SYMBOL(free_dma);
+EXPORT_SYMBOL(enable_dma);
+EXPORT_SYMBOL(disable_dma);
+EXPORT_SYMBOL(set_dma_addr);
+EXPORT_SYMBOL(set_dma_count);
+EXPORT_SYMBOL(set_dma_mode);
+EXPORT_SYMBOL(set_dma_page);
+EXPORT_SYMBOL(get_dma_residue);
+EXPORT_SYMBOL(set_dma_sg);
+EXPORT_SYMBOL(set_dma_speed);
+
+EXPORT_SYMBOL(dma_spin_lock);
