commit d8ed45c5dcd455fc5848d47f86883a1b872ac0d0
Author: Michel Lespinasse <walken@google.com>
Date:   Mon Jun 8 21:33:25 2020 -0700

    mmap locking API: use coccinelle to convert mmap_sem rwsem call sites
    
    This change converts the existing mmap_sem rwsem calls to use the new mmap
    locking API instead.
    
    The change is generated using coccinelle with the following rule:
    
    // spatch --sp-file mmap_lock_api.cocci --in-place --include-headers --dir .
    
    @@
    expression mm;
    @@
    (
    -init_rwsem
    +mmap_init_lock
    |
    -down_write
    +mmap_write_lock
    |
    -down_write_killable
    +mmap_write_lock_killable
    |
    -down_write_trylock
    +mmap_write_trylock
    |
    -up_write
    +mmap_write_unlock
    |
    -downgrade_write
    +mmap_write_downgrade
    |
    -down_read
    +mmap_read_lock
    |
    -down_read_killable
    +mmap_read_lock_killable
    |
    -down_read_trylock
    +mmap_read_trylock
    |
    -up_read
    +mmap_read_unlock
    )
    -(&mm->mmap_sem)
    +(mm)
    
    Signed-off-by: Michel Lespinasse <walken@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Daniel Jordan <daniel.m.jordan@oracle.com>
    Reviewed-by: Laurent Dufour <ldufour@linux.ibm.com>
    Reviewed-by: Vlastimil Babka <vbabka@suse.cz>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Jason Gunthorpe <jgg@ziepe.ca>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Cc: John Hubbard <jhubbard@nvidia.com>
    Cc: Liam Howlett <Liam.Howlett@oracle.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ying Han <yinghan@google.com>
    Link: http://lkml.kernel.org/r/20200520052908.204642-5-walken@google.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 46e478fb5ea2..58eaa1f60e16 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -431,7 +431,7 @@ int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
 	npages = 1; /* for sigpage */
 	npages += vdso_total_pages;
 
-	if (down_write_killable(&mm->mmap_sem))
+	if (mmap_write_lock_killable(mm))
 		return -EINTR;
 	hint = sigpage_addr(mm, npages);
 	addr = get_unmapped_area(NULL, hint, npages << PAGE_SHIFT, 0, 0);
@@ -458,7 +458,7 @@ int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
 	arm_install_vdso(mm, addr + PAGE_SIZE);
 
  up_fail:
-	up_write(&mm->mmap_sem);
+	mmap_write_unlock(mm);
 	return ret;
 }
 #endif

commit 167ee0b82429cb5df272808c7a21370b7c961ab2
Author: Amanieu d'Antras <amanieu@gmail.com>
Date:   Thu Jan 2 18:24:09 2020 +0100

    arm: Implement copy_thread_tls
    
    This is required for clone3 which passes the TLS value through a
    struct rather than a register.
    
    Signed-off-by: Amanieu d'Antras <amanieu@gmail.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: <stable@vger.kernel.org> # 5.3.x
    Link: https://lore.kernel.org/r/20200102172413.654385-4-amanieu@gmail.com
    Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index cea1c27c29cb..46e478fb5ea2 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -226,8 +226,8 @@ void release_thread(struct task_struct *dead_task)
 asmlinkage void ret_from_fork(void) __asm__("ret_from_fork");
 
 int
-copy_thread(unsigned long clone_flags, unsigned long stack_start,
-	    unsigned long stk_sz, struct task_struct *p)
+copy_thread_tls(unsigned long clone_flags, unsigned long stack_start,
+	    unsigned long stk_sz, struct task_struct *p, unsigned long tls)
 {
 	struct thread_info *thread = task_thread_info(p);
 	struct pt_regs *childregs = task_pt_regs(p);
@@ -261,7 +261,7 @@ copy_thread(unsigned long clone_flags, unsigned long stack_start,
 	clear_ptrace_hw_breakpoint(p);
 
 	if (clone_flags & CLONE_SETTLS)
-		thread->tp_value[0] = childregs->ARM_r3;
+		thread->tp_value[0] = tls;
 	thread->tp_value[1] = get_tpuser();
 
 	thread_notify(THREAD_NOTIFY_COPY, thread);

commit 83dc1d99429af7d73225294f216a510ba6f58e45
Author: Ben Dooks (Codethink) <ben.dooks@codethink.co.uk>
Date:   Fri Oct 11 13:53:32 2019 +0100

    ARM: 8920/1: share get_signal_page from signal.c to process.c
    
    The get_signal_page() function is defined in signal.c and used in
    process.c but there is no shared definition. Add one in signal.h to
    silence the following warning:
    
    arch/arm/kernel/signal.c:683:13: warning: symbol 'get_signal_page' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 9485acc520a4..cea1c27c29cb 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -36,6 +36,8 @@
 #include <asm/tls.h>
 #include <asm/vdso.h>
 
+#include "signal.h"
+
 #if defined(CONFIG_STACKPROTECTOR) && !defined(CONFIG_STACKPROTECTOR_PER_TASK)
 #include <linux/stackprotector.h>
 unsigned long __stack_chk_guard __read_mostly;

commit dba79c3df4a2275132759b0bc04c64b7a510af4a
Author: Alexandre Ghiti <alex@ghiti.fr>
Date:   Mon Sep 23 15:39:01 2019 -0700

    arm: use generic mmap top-down layout and brk randomization
    
    arm uses a top-down mmap layout by default that exactly fits the generic
    functions, so get rid of arch specific code and use the generic version by
    selecting ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT.
    
    As ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT selects ARCH_HAS_ELF_RANDOMIZE,
    use the generic version of arch_randomize_brk since it also fits.  Note
    that this commit also removes the possibility for arm to have elf
    randomization and no MMU: without MMU, the security added by randomization
    is worth nothing.
    
    Note that it is safe to remove STACK_RND_MASK since it matches the default
    value.
    
    Link: http://lkml.kernel.org/r/20190730055113.23635-9-alex@ghiti.fr
    Signed-off-by: Alexandre Ghiti <alex@ghiti.fr>
    Acked-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Luis Chamberlain <mcgrof@kernel.org>
    Cc: Albert Ou <aou@eecs.berkeley.edu>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index f934a6739fc0..9485acc520a4 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -319,11 +319,6 @@ unsigned long get_wchan(struct task_struct *p)
 	return 0;
 }
 
-unsigned long arch_randomize_brk(struct mm_struct *mm)
-{
-	return randomize_page(mm->brk, 0x02000000);
-}
-
 #ifdef CONFIG_MMU
 #ifdef CONFIG_KUSER_HELPERS
 /*

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 72cc0862a30e..f934a6739fc0 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  linux/arch/arm/kernel/process.c
  *
  *  Copyright (C) 1996-2000 Russell King - Converted to ARM.
  *  Original Copyright (C) 1995  Linus Torvalds
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 #include <stdarg.h>
 

commit 736706bee3298208343a76096370e4f6a5c55915
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 4 10:39:05 2019 -0800

    get rid of legacy 'get_ds()' function
    
    Every in-kernel use of this function defined it to KERNEL_DS (either as
    an actual define, or as an inline function).  It's an entirely
    historical artifact, and long long long ago used to actually read the
    segment selector valueof '%ds' on x86.
    
    Which in the kernel is always KERNEL_DS.
    
    Inspired by a patch from Jann Horn that just did this for a very small
    subset of users (the ones in fs/), along with Al who suggested a script.
    I then just took it to the logical extreme and removed all the remaining
    gunk.
    
    Roughly scripted with
    
       git grep -l '(get_ds())' -- :^tools/ | xargs sed -i 's/(get_ds())/(KERNEL_DS)/'
       git grep -lw 'get_ds' -- :^tools/ | xargs sed -i '/^#define get_ds()/d'
    
    plus manual fixups to remove a few unusual usage patterns, the couple of
    inline function cases and to fix up a comment that had become stale.
    
    The 'get_ds()' function remains in an x86 kvm selftest, since in user
    space it actually does something relevant.
    
    Inspired-by: Jann Horn <jannh@google.com>
    Inspired-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 16601d1442d1..72cc0862a30e 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -150,7 +150,7 @@ void __show_regs(struct pt_regs *regs)
 		if ((domain & domain_mask(DOMAIN_USER)) ==
 		    domain_val(DOMAIN_USER, DOMAIN_NOACCESS))
 			segment = "none";
-		else if (fs == get_ds())
+		else if (fs == KERNEL_DS)
 			segment = "kernel";
 		else
 			segment = "user";

commit 189af4657186da08a2e79fb8e906cfd82b2ccddc
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Thu Dec 6 09:32:57 2018 +0100

    ARM: smp: add support for per-task stack canaries
    
    On ARM, we currently only change the value of the stack canary when
    switching tasks if the kernel was built for UP. On SMP kernels, this
    is impossible since the stack canary value is obtained via a global
    symbol reference, which means
    a) all running tasks on all CPUs must use the same value
    b) we can only modify the value when no kernel stack frames are live
       on any CPU, which is effectively never.
    
    So instead, use a GCC plugin to add a RTL pass that replaces each
    reference to the address of the __stack_chk_guard symbol with an
    expression that produces the address of the 'stack_canary' field
    that is added to struct thread_info. This way, each task will use
    its own randomized value.
    
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Emese Revfy <re.emese@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Laura Abbott <labbott@redhat.com>
    Cc: kernel-hardening@lists.openwall.com
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 82ab015bf42b..16601d1442d1 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -39,7 +39,7 @@
 #include <asm/tls.h>
 #include <asm/vdso.h>
 
-#ifdef CONFIG_STACKPROTECTOR
+#if defined(CONFIG_STACKPROTECTOR) && !defined(CONFIG_STACKPROTECTOR_PER_TASK)
 #include <linux/stackprotector.h>
 unsigned long __stack_chk_guard __read_mostly;
 EXPORT_SYMBOL(__stack_chk_guard);
@@ -267,6 +267,10 @@ copy_thread(unsigned long clone_flags, unsigned long stack_start,
 
 	thread_notify(THREAD_NOTIFY_COPY, thread);
 
+#ifdef CONFIG_STACKPROTECTOR_PER_TASK
+	thread->stack_canary = p->stack_canary;
+#endif
+
 	return 0;
 }
 

commit a670468f5e0b5fad4db6e4d195f15915dc2a35c1
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Tue Aug 21 21:53:06 2018 -0700

    mm: zero out the vma in vma_init()
    
    Rather than in vm_area_alloc().  To ensure that the various oddball
    stack-based vmas are in a good state.  Some of the callers were zeroing
    them out, others were not.
    
    Acked-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index d9c299133111..82ab015bf42b 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -330,16 +330,15 @@ unsigned long arch_randomize_brk(struct mm_struct *mm)
  * atomic helpers. Insert it into the gate_vma so that it is visible
  * through ptrace and /proc/<pid>/mem.
  */
-static struct vm_area_struct gate_vma = {
-	.vm_start	= 0xffff0000,
-	.vm_end		= 0xffff0000 + PAGE_SIZE,
-	.vm_flags	= VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC,
-};
+static struct vm_area_struct gate_vma;
 
 static int __init gate_vma_init(void)
 {
 	vma_init(&gate_vma, NULL);
 	gate_vma.vm_page_prot = PAGE_READONLY_EXEC;
+	gate_vma.vm_start = 0xffff0000;
+	gate_vma.vm_end	= 0xffff0000 + PAGE_SIZE;
+	gate_vma.vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC;
 	return 0;
 }
 arch_initcall(gate_vma_init);

commit 2c4541e24c55e2847bede93e33d749280edd429a
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Thu Jul 26 16:37:30 2018 -0700

    mm: use vma_init() to initialize VMAs on stack and data segments
    
    Make sure to initialize all VMAs properly, not only those which come
    from vm_area_cachep.
    
    Link: http://lkml.kernel.org/r/20180724121139.62570-3-kirill.shutemov@linux.intel.com
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 225d1c58d2de..d9c299133111 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -338,6 +338,7 @@ static struct vm_area_struct gate_vma = {
 
 static int __init gate_vma_init(void)
 {
+	vma_init(&gate_vma, NULL);
 	gate_vma.vm_page_prot = PAGE_READONLY_EXEC;
 	return 0;
 }

commit 050e9baa9dc9fbd9ce2b27f0056990fc9e0a08a0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 14 12:21:18 2018 +0900

    Kbuild: rename CC_STACKPROTECTOR[_STRONG] config variables
    
    The changes to automatically test for working stack protector compiler
    support in the Kconfig files removed the special STACKPROTECTOR_AUTO
    option that picked the strongest stack protector that the compiler
    supported.
    
    That was all a nice cleanup - it makes no sense to have the AUTO case
    now that the Kconfig phase can just determine the compiler support
    directly.
    
    HOWEVER.
    
    It also meant that doing "make oldconfig" would now _disable_ the strong
    stackprotector if you had AUTO enabled, because in a legacy config file,
    the sane stack protector configuration would look like
    
      CONFIG_HAVE_CC_STACKPROTECTOR=y
      # CONFIG_CC_STACKPROTECTOR_NONE is not set
      # CONFIG_CC_STACKPROTECTOR_REGULAR is not set
      # CONFIG_CC_STACKPROTECTOR_STRONG is not set
      CONFIG_CC_STACKPROTECTOR_AUTO=y
    
    and when you ran this through "make oldconfig" with the Kbuild changes,
    it would ask you about the regular CONFIG_CC_STACKPROTECTOR (that had
    been renamed from CONFIG_CC_STACKPROTECTOR_REGULAR to just
    CONFIG_CC_STACKPROTECTOR), but it would think that the STRONG version
    used to be disabled (because it was really enabled by AUTO), and would
    disable it in the new config, resulting in:
    
      CONFIG_HAVE_CC_STACKPROTECTOR=y
      CONFIG_CC_HAS_STACKPROTECTOR_NONE=y
      CONFIG_CC_STACKPROTECTOR=y
      # CONFIG_CC_STACKPROTECTOR_STRONG is not set
      CONFIG_CC_HAS_SANE_STACKPROTECTOR=y
    
    That's dangerously subtle - people could suddenly find themselves with
    the weaker stack protector setup without even realizing.
    
    The solution here is to just rename not just the old RECULAR stack
    protector option, but also the strong one.  This does that by just
    removing the CC_ prefix entirely for the user choices, because it really
    is not about the compiler support (the compiler support now instead
    automatially impacts _visibility_ of the options to users).
    
    This results in "make oldconfig" actually asking the user for their
    choice, so that we don't have any silent subtle security model changes.
    The end result would generally look like this:
    
      CONFIG_HAVE_CC_STACKPROTECTOR=y
      CONFIG_CC_HAS_STACKPROTECTOR_NONE=y
      CONFIG_STACKPROTECTOR=y
      CONFIG_STACKPROTECTOR_STRONG=y
      CONFIG_CC_HAS_SANE_STACKPROTECTOR=y
    
    where the "CC_" versions really are about internal compiler
    infrastructure, not the user selections.
    
    Acked-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 1523cb18b109..225d1c58d2de 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -39,7 +39,7 @@
 #include <asm/tls.h>
 #include <asm/vdso.h>
 
-#ifdef CONFIG_CC_STACKPROTECTOR
+#ifdef CONFIG_STACKPROTECTOR
 #include <linux/stackprotector.h>
 unsigned long __stack_chk_guard __read_mostly;
 EXPORT_SYMBOL(__stack_chk_guard);

commit 3ea70d7ddbddef06222e75b1f94a3e5268812988
Author: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
Date:   Mon Dec 11 21:50:13 2017 +0900

    arm: do not use print_symbol()
    
    print_symbol() is a very old API that has been obsoleted by %pS format
    specifier in a normal printk() call.
    
    Replace print_symbol() with a direct printk("%pS") call.
    
    Link: http://lkml.kernel.org/r/20171211125025.2270-2-sergey.senozhatsky@gmail.com
    To: Andrew Morton <akpm@linux-foundation.org>
    To: Russell King <linux@armlinux.org.uk>
    To: Catalin Marinas <catalin.marinas@arm.com>
    To: Mark Salter <msalter@redhat.com>
    To: Tony Luck <tony.luck@intel.com>
    To: David Howells <dhowells@redhat.com>
    To: Yoshinori Sato <ysato@users.sourceforge.jp>
    To: Guan Xuetao <gxt@mprc.pku.edu.cn>
    To: Borislav Petkov <bp@alien8.de>
    To: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    To: Thomas Gleixner <tglx@linutronix.de>
    To: Peter Zijlstra <peterz@infradead.org>
    To: Vineet Gupta <vgupta@synopsys.com>
    To: Fengguang Wu <fengguang.wu@intel.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: LKML <linux-kernel@vger.kernel.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-c6x-dev@linux-c6x.org
    Cc: linux-ia64@vger.kernel.org
    Cc: linux-am33-list@redhat.com
    Cc: linux-sh@vger.kernel.org
    Cc: linux-edac@vger.kernel.org
    Cc: x86@kernel.org
    Cc: linux-snps-arc@lists.infradead.org
    Signed-off-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    [pmladek@suse.com: updated commit message, fixed complication warning]
    Signed-off-by: Petr Mladek <pmladek@suse.com>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index d96714e1858c..1523cb18b109 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -21,7 +21,6 @@
 #include <linux/unistd.h>
 #include <linux/user.h>
 #include <linux/interrupt.h>
-#include <linux/kallsyms.h>
 #include <linux/init.h>
 #include <linux/elfcore.h>
 #include <linux/pm.h>
@@ -121,8 +120,8 @@ void __show_regs(struct pt_regs *regs)
 
 	show_regs_print_info(KERN_DEFAULT);
 
-	print_symbol("PC is at %s\n", instruction_pointer(regs));
-	print_symbol("LR is at %s\n", regs->ARM_lr);
+	printk("PC is at %pS\n", (void *)instruction_pointer(regs));
+	printk("LR is at %pS\n", (void *)regs->ARM_lr);
 	printk("pc : [<%08lx>]    lr : [<%08lx>]    psr: %08lx\n",
 	       regs->ARM_pc, regs->ARM_lr, regs->ARM_cpsr);
 	printk("sp : %08lx  ip : %08lx  fp : %08lx\n",

commit 280e87e98c09b85b617c7b2752c8b504c4ea98f6
Author: Dmitry Safonov <dsafonov@virtuozzo.com>
Date:   Mon Jun 19 17:32:42 2017 +0100

    ARM: 8683/1: ARM32: Support mremap() for sigpage/vDSO
    
    CRIU restores application mappings on the same place where they
    were before Checkpoint. That means, that we need to move vDSO
    and sigpage during restore on exactly the same place where
    they were before C/R.
    
    Make mremap() code update mm->context.{sigpage,vdso} pointers
    during VMA move. Sigpage is used for landing after handling
    a signal - if the pointer is not updated during moving, the
    application might crash on any signal after mremap().
    
    vDSO pointer on ARM32 is used only for setting auxv at this moment,
    update it during mremap() in case of future usage.
    
    Without those updates, current work of CRIU on ARM32 is not reliable.
    Historically, we error Checkpointing if we find vDSO page on ARM32
    and suggest user to disable CONFIG_VDSO.
    But that's not correct - it goes from x86 where signal processing
    is ended in vDSO blob. For arm32 it's sigpage, which is not disabled
    with `CONFIG_VDSO=n'.
    
    Looks like C/R was working by luck - because userspace on ARM32 at
    this moment always sets SA_RESTORER.
    
    Signed-off-by: Dmitry Safonov <dsafonov@virtuozzo.com>
    Acked-by: Andy Lutomirski <luto@amacapital.net>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Cyrill Gorcunov <gorcunov@openvz.org>
    Cc: Pavel Emelyanov <xemul@virtuozzo.com>
    Cc: Christopher Covington <cov@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 151cece4a293..d96714e1858c 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -404,9 +404,17 @@ static unsigned long sigpage_addr(const struct mm_struct *mm,
 static struct page *signal_page;
 extern struct page *get_signal_page(void);
 
+static int sigpage_mremap(const struct vm_special_mapping *sm,
+		struct vm_area_struct *new_vma)
+{
+	current->mm->context.sigpage = new_vma->vm_start;
+	return 0;
+}
+
 static const struct vm_special_mapping sigpage_mapping = {
 	.name = "[sigpage]",
 	.pages = &signal_page,
+	.mremap = sigpage_mremap,
 };
 
 int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)

commit 801f19b9515fb61e8b2400f5555460f55f22571c
Author: Joe Perches <joe@perches.com>
Date:   Thu May 4 09:17:55 2017 +0100

    ARM: 8673/1: Fix __show_regs output timestamps
    
    Multiple line formats are not preferred as the second and
    subsequent lines may not have timestamps.
    
    Lacking timestamps makes reading the output a bit difficult.
    This also makes arm/arm64 output more similar.
    
    Previous:
    
    [ 1514.093231] pc : [<bf79c304>]    lr : [<bf79ced8>]    psr: a00f0013
    sp : ecdd7e20  ip : 00000000  fp : ffffffff
    
    New:
    
    [ 1514.093231] pc : [<bf79c304>]    lr : [<bf79ced8>]    psr: a00f0013
    [ 1514.105316] sp : ecdd7e20  ip : 00000000  fp : ffffffff
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 939e8b58c59d..151cece4a293 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -123,10 +123,10 @@ void __show_regs(struct pt_regs *regs)
 
 	print_symbol("PC is at %s\n", instruction_pointer(regs));
 	print_symbol("LR is at %s\n", regs->ARM_lr);
-	printk("pc : [<%08lx>]    lr : [<%08lx>]    psr: %08lx\n"
-	       "sp : %08lx  ip : %08lx  fp : %08lx\n",
-		regs->ARM_pc, regs->ARM_lr, regs->ARM_cpsr,
-		regs->ARM_sp, regs->ARM_ip, regs->ARM_fp);
+	printk("pc : [<%08lx>]    lr : [<%08lx>]    psr: %08lx\n",
+	       regs->ARM_pc, regs->ARM_lr, regs->ARM_cpsr);
+	printk("sp : %08lx  ip : %08lx  fp : %08lx\n",
+	       regs->ARM_sp, regs->ARM_ip, regs->ARM_fp);
 	printk("r10: %08lx  r9 : %08lx  r8 : %08lx\n",
 		regs->ARM_r10, regs->ARM_r9,
 		regs->ARM_r8);

commit 68db0cf10678630d286f4bbbbdfa102951a35faa
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 8 18:51:37 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <linux/sched/task_stack.h>
    
    We are going to split <linux/sched/task_stack.h> out of <linux/sched.h>, which
    will have to be picked up from other headers and a couple of .c files.
    
    Create a trivial placeholder <linux/sched/task_stack.h> file that just
    maps to <linux/sched.h> to make this patch obviously correct and
    bisectable.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index d4c7c9a1afa9..939e8b58c59d 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -14,6 +14,7 @@
 #include <linux/sched.h>
 #include <linux/sched/debug.h>
 #include <linux/sched/task.h>
+#include <linux/sched/task_stack.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/stddef.h>

commit 299300258d1bc4e997b7db340a2e06636757fe2e
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 8 18:51:36 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <linux/sched/task.h>
    
    We are going to split <linux/sched/task.h> out of <linux/sched.h>, which
    will have to be picked up from other headers and a couple of .c files.
    
    Create a trivial placeholder <linux/sched/task.h> file that just
    maps to <linux/sched.h> to make this patch obviously correct and
    bisectable.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 03d46395d1ff..d4c7c9a1afa9 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -13,6 +13,7 @@
 #include <linux/export.h>
 #include <linux/sched.h>
 #include <linux/sched/debug.h>
+#include <linux/sched/task.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/stddef.h>

commit b17b01533b719e9949e437abf66436a875739b40
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 8 18:51:35 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <linux/sched/debug.h>
    
    We are going to split <linux/sched/debug.h> out of <linux/sched.h>, which
    will have to be picked up from other headers and a couple of .c files.
    
    Create a trivial placeholder <linux/sched/debug.h> file that just
    maps to <linux/sched.h> to make this patch obviously correct and
    bisectable.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 91d2d5b01414..03d46395d1ff 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -12,6 +12,7 @@
 
 #include <linux/export.h>
 #include <linux/sched.h>
+#include <linux/sched/debug.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/stddef.h>

commit c984cbf2e34cd622b5531f776029f7b23ff17e50
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Oct 11 13:53:59 2016 -0700

    ARM: use simpler API for random address requests
    
    Currently, all callers to randomize_range() set the length to 0 and
    calculate end by adding a constant to the start address.  We can simplify
    the API to remove a bunch of needless checks and variables.
    
    Use the new randomize_addr(start, range) call to set the requested
    address.
    
    Link: http://lkml.kernel.org/r/20160803233913.32511-4-jason@lakedaemon.net
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: "Russell King - ARM Linux" <linux@arm.linux.org.uk>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 612eb530f33f..91d2d5b01414 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -318,8 +318,7 @@ unsigned long get_wchan(struct task_struct *p)
 
 unsigned long arch_randomize_brk(struct mm_struct *mm)
 {
-	unsigned long range_end = mm->brk + 0x02000000;
-	return randomize_range(mm->brk, range_end, 0) ? : mm->brk;
+	return randomize_page(mm->brk, 0x02000000);
 }
 
 #ifdef CONFIG_MMU

commit e6978e4bf181fb3b5f8cb6f71b4fe30fbf1b655c
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Fri May 13 11:40:20 2016 +0100

    ARM: save and reset the address limit when entering an exception
    
    When we enter an exception, the current address limit should not apply
    to the exception context: if the exception context wishes to access
    kernel space via the user accessors (eg, perf code), it must explicitly
    request such access.
    
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index f1c720c0d568..612eb530f33f 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -96,19 +96,23 @@ void __show_regs(struct pt_regs *regs)
 	unsigned long flags;
 	char buf[64];
 #ifndef CONFIG_CPU_V7M
-	unsigned int domain;
+	unsigned int domain, fs;
 #ifdef CONFIG_CPU_SW_DOMAIN_PAN
 	/*
 	 * Get the domain register for the parent context. In user
 	 * mode, we don't save the DACR, so lets use what it should
 	 * be. For other modes, we place it after the pt_regs struct.
 	 */
-	if (user_mode(regs))
+	if (user_mode(regs)) {
 		domain = DACR_UACCESS_ENABLE;
-	else
+		fs = get_fs();
+	} else {
 		domain = to_svc_pt_regs(regs)->dacr;
+		fs = to_svc_pt_regs(regs)->addr_limit;
+	}
 #else
 	domain = get_domain();
+	fs = get_fs();
 #endif
 #endif
 
@@ -144,7 +148,7 @@ void __show_regs(struct pt_regs *regs)
 		if ((domain & domain_mask(DOMAIN_USER)) ==
 		    domain_val(DOMAIN_USER, DOMAIN_NOACCESS))
 			segment = "none";
-		else if (get_fs() == get_ds())
+		else if (fs == get_ds())
 			segment = "kernel";
 		else
 			segment = "user";

commit 5fa9da5043a81b9eea5d4522d1371455bf64894a
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Fri May 13 10:26:10 2016 +0100

    ARM: get rid of horrible *(unsigned int *)(regs + 1)
    
    Get rid of the horrible "*(unsigned int *)(regs + 1)" to get at the
    parent context domain access register value, instead using the newly
    introduced svc_pt_regs structure.
    
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 4a803c5a1ff7..f1c720c0d568 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -106,7 +106,7 @@ void __show_regs(struct pt_regs *regs)
 	if (user_mode(regs))
 		domain = DACR_UACCESS_ENABLE;
 	else
-		domain = *(unsigned int *)(regs + 1);
+		domain = to_svc_pt_regs(regs)->dacr;
 #else
 	domain = get_domain();
 #endif

commit 69048176078adda4087a648c9b1812ddd800fad1
Author: Michal Hocko <mhocko@suse.com>
Date:   Mon May 23 16:25:54 2016 -0700

    vdso: make arch_setup_additional_pages wait for mmap_sem for write killable
    
    most architectures are relying on mmap_sem for write in their
    arch_setup_additional_pages.  If the waiting task gets killed by the oom
    killer it would block oom_reaper from asynchronous address space reclaim
    and reduce the chances of timely OOM resolving.  Wait for the lock in
    the killable mode and return with EINTR if the task got killed while
    waiting.
    
    Signed-off-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Andy Lutomirski <luto@amacapital.net> [x86 vdso]
    Acked-by: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index a647d6642f3e..4a803c5a1ff7 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -420,7 +420,8 @@ int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
 	npages = 1; /* for sigpage */
 	npages += vdso_total_pages;
 
-	down_write(&mm->mmap_sem);
+	if (down_write_killable(&mm->mmap_sem))
+		return -EINTR;
 	hint = sigpage_addr(mm, npages);
 	addr = get_unmapped_area(NULL, hint, npages << PAGE_SHIFT, 0, 0);
 	if (IS_ERR_VALUE(addr)) {

commit e64646946ed32902fd597fa6e514b1da84642de3
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Fri May 20 17:00:20 2016 -0700

    exit_thread: accept a task parameter to be exited
    
    We need to call exit_thread from copy_process in a fail path.  So make it
    accept task_struct as a parameter.
    
    [v2]
    * s390: exit_thread_runtime_instr doesn't make sense to be called for
      non-current tasks.
    * arm: fix the comment in vfp_thread_copy
    * change 'me' to 'tsk' for task_struct
    * now we can change only archs that actually have exit_thread
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Aurelien Jacquiot <a-jacquiot@ti.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chen Liqin <liqin.linux@gmail.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Cc: Haavard Skinnemoen <hskinnemoen@gmail.com>
    Cc: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Jesper Nilsson <jesper.nilsson@axis.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Koichi Yasutake <yasutake.koichi@jp.panasonic.com>
    Cc: Lennox Wu <lennox.wu@gmail.com>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Steven Miao <realmz6@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 4adfb46e3ee9..a647d6642f3e 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -193,9 +193,9 @@ EXPORT_SYMBOL_GPL(thread_notify_head);
 /*
  * Free current thread data structures etc..
  */
-void exit_thread(void)
+void exit_thread(struct task_struct *tsk)
 {
-	thread_notify(THREAD_NOTIFY_EXIT, current_thread_info());
+	thread_notify(THREAD_NOTIFY_EXIT, task_thread_info(tsk));
 }
 
 void flush_thread(void)

commit 77f1b959b0b6db7a7941b4b4f9d3d287c67d7c15
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Dec 3 14:34:45 2015 +0000

    ARM: report proper DACR value in oops dumps
    
    When printing the DACR value, we print the domain register value.
    This is incorrect, as with SW_PAN enabled, that is the current setting,
    rather than the faulting context's setting.  Arrange to print the
    faulting domain's saved DACR value instead.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 7a7c4cea5523..4adfb46e3ee9 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -95,6 +95,22 @@ void __show_regs(struct pt_regs *regs)
 {
 	unsigned long flags;
 	char buf[64];
+#ifndef CONFIG_CPU_V7M
+	unsigned int domain;
+#ifdef CONFIG_CPU_SW_DOMAIN_PAN
+	/*
+	 * Get the domain register for the parent context. In user
+	 * mode, we don't save the DACR, so lets use what it should
+	 * be. For other modes, we place it after the pt_regs struct.
+	 */
+	if (user_mode(regs))
+		domain = DACR_UACCESS_ENABLE;
+	else
+		domain = *(unsigned int *)(regs + 1);
+#else
+	domain = get_domain();
+#endif
+#endif
 
 	show_regs_print_info(KERN_DEFAULT);
 
@@ -123,21 +139,8 @@ void __show_regs(struct pt_regs *regs)
 
 #ifndef CONFIG_CPU_V7M
 	{
-		unsigned int domain = get_domain();
 		const char *segment;
 
-#ifdef CONFIG_CPU_SW_DOMAIN_PAN
-		/*
-		 * Get the domain register for the parent context. In user
-		 * mode, we don't save the DACR, so lets use what it should
-		 * be. For other modes, we place it after the pt_regs struct.
-		 */
-		if (user_mode(regs))
-			domain = DACR_UACCESS_ENABLE;
-		else
-			domain = *(unsigned int *)(regs + 1);
-#endif
-
 		if ((domain & domain_mask(DOMAIN_USER)) ==
 		    domain_val(DOMAIN_USER, DOMAIN_NOACCESS))
 			segment = "none";
@@ -163,11 +166,11 @@ void __show_regs(struct pt_regs *regs)
 		buf[0] = '\0';
 #ifdef CONFIG_CPU_CP15_MMU
 		{
-			unsigned int transbase, dac = get_domain();
+			unsigned int transbase;
 			asm("mrc p15, 0, %0, c2, c0\n\t"
 			    : "=r" (transbase));
 			snprintf(buf, sizeof(buf), "  Table: %08x  DAC: %08x",
-			  	transbase, dac);
+				transbase, domain);
 		}
 #endif
 		asm("mrc p15, 0, %0, c1, c0\n" : "=r" (ctrl));

commit 57e6bbcb4beb4c87aa93e78a1db08fdaab9ee65f
Merge: 6ff33f3902c3 c2172ce23030
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 14 12:24:10 2015 -0700

    Merge branch 'fixes' of git://ftp.arm.linux.org.uk/~rmk/linux-arm
    
    Pull ARM fixes from Russell King:
     "A number of fixes for the merge window, fixing a number of cases
      missed when testing the uaccess code, particularly cases which only
      show up with certain compiler versions"
    
    * 'fixes' of git://ftp.arm.linux.org.uk/~rmk/linux-arm:
      ARM: 8431/1: fix alignement of __bug_table section entries
      arm/xen: Enable user access to the kernel before issuing a privcmd call
      ARM: domains: add memory dependencies to get_domain/set_domain
      ARM: domains: thread_info.h no longer needs asm/domains.h
      ARM: uaccess: fix undefined instruction on ARMv7M/noMMU
      ARM: uaccess: remove unneeded uaccess_save_and_disable macro
      ARM: swpan: fix nwfpe for uaccess changes
      ARM: 8429/1: disable GCC SRA optimization

commit af4cb25df93d2e7a97d65db2bfacaa4400988dea
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Sep 9 21:19:49 2015 +0100

    ARM: uaccess: fix undefined instruction on ARMv7M/noMMU
    
    The use of get_domain() in copy_thread() results in an oops on
    ARMv7M/noMMU systems.  The thread cpu_domain value is only used when
    CONFIG_CPU_USE_DOMAINS is enabled, so there's no need to save the
    value in copy_thread() except when this is enabled, and this option
    will never be enabled on these platforms.
    
    Unhandled exception: IPSR = 00000006 LR = fffffff1
    CPU: 0 PID: 0 Comm: swapper Not tainted 4.2.0-next-20150909-00001-gb8ec5ad #41
    Hardware name: NXP LPC18xx/43xx (Device Tree)
    task: 2823fbe0 ti: 2823c000 task.ti: 2823c000
    PC is at copy_thread+0x18/0x92
    LR is at copy_thread+0x19/0x92
    pc : [<2800a46e>]    lr : [<2800a46f>]    psr: 4100000b
    sp : 2823df00  ip : 00000000  fp : 287c81c0
    r10: 00000000  r9 : 00800300  r8 : 287c8000
    r7 : 287c8000  r6 : 2818908d  r5 : 00000000  r4 : 287ca000
    r3 : 00000000  r2 : 00000000  r1 : fffffff0  r0 : 287ca048
    xPSR: 4100000b
    
    Reported-by: Ariel D'Alessandro <ariel@vanguardiasur.com.ar>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 3f18098dfd08..e550a4541f48 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -233,6 +233,7 @@ copy_thread(unsigned long clone_flags, unsigned long stack_start,
 
 	memset(&thread->cpu_context, 0, sizeof(struct cpu_context_save));
 
+#ifdef CONFIG_CPU_USE_DOMAINS
 	/*
 	 * Copy the initial value of the domain access control register
 	 * from the current thread: thread->addr_limit will have been
@@ -240,6 +241,7 @@ copy_thread(unsigned long clone_flags, unsigned long stack_start,
 	 * kernel/fork.c
 	 */
 	thread->cpu_domain = get_domain();
+#endif
 
 	if (likely(!(p->flags & PF_KTHREAD))) {
 		*childregs = *current_pt_regs();

commit 40d3f02851577da27b5cbb1538888301245ef1e7
Merge: e0aa3a665782 3939f3345050 9205b797dbe5 3fa609755c11 a5e090acbf54
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Sep 3 15:28:37 2015 +0100

    Merge branches 'cleanup', 'fixes', 'misc', 'omap-barrier' and 'uaccess' into for-linus

commit a5e090acbf545c0a3b04080f8a488b17ec41fe02
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Aug 19 20:40:41 2015 +0100

    ARM: software-based priviledged-no-access support
    
    Provide a software-based implementation of the priviledged no access
    support found in ARMv8.1.
    
    Userspace pages are mapped using a different domain number from the
    kernel and IO mappings.  If we switch the user domain to "no access"
    when we enter the kernel, we can prevent the kernel from touching
    userspace.
    
    However, the kernel needs to be able to access userspace via the
    various user accessor functions.  With the wrapping in the previous
    patch, we can temporarily enable access when the kernel needs user
    access, and re-disable it afterwards.
    
    This allows us to trap non-intended accesses to userspace, eg, caused
    by an inadvertent dereference of the LIST_POISON* values, which, with
    appropriate user mappings setup, can be made to succeed.  This in turn
    can allow use-after-free bugs to be further exploited than would
    otherwise be possible.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index e722f9b3c9b1..3f18098dfd08 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -129,12 +129,36 @@ void __show_regs(struct pt_regs *regs)
 	buf[4] = '\0';
 
 #ifndef CONFIG_CPU_V7M
-	printk("Flags: %s  IRQs o%s  FIQs o%s  Mode %s  ISA %s  Segment %s\n",
-		buf, interrupts_enabled(regs) ? "n" : "ff",
-		fast_interrupts_enabled(regs) ? "n" : "ff",
-		processor_modes[processor_mode(regs)],
-		isa_modes[isa_mode(regs)],
-		get_fs() == get_ds() ? "kernel" : "user");
+	{
+		unsigned int domain = get_domain();
+		const char *segment;
+
+#ifdef CONFIG_CPU_SW_DOMAIN_PAN
+		/*
+		 * Get the domain register for the parent context. In user
+		 * mode, we don't save the DACR, so lets use what it should
+		 * be. For other modes, we place it after the pt_regs struct.
+		 */
+		if (user_mode(regs))
+			domain = DACR_UACCESS_ENABLE;
+		else
+			domain = *(unsigned int *)(regs + 1);
+#endif
+
+		if ((domain & domain_mask(DOMAIN_USER)) ==
+		    domain_val(DOMAIN_USER, DOMAIN_NOACCESS))
+			segment = "none";
+		else if (get_fs() == get_ds())
+			segment = "kernel";
+		else
+			segment = "user";
+
+		printk("Flags: %s  IRQs o%s  FIQs o%s  Mode %s  ISA %s  Segment %s\n",
+			buf, interrupts_enabled(regs) ? "n" : "ff",
+			fast_interrupts_enabled(regs) ? "n" : "ff",
+			processor_modes[processor_mode(regs)],
+			isa_modes[isa_mode(regs)], segment);
+	}
 #else
 	printk("xPSR: %08lx\n", regs->ARM_cpsr);
 #endif

commit 9205b797dbe519a629267ec8c5766cd973d35063
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Aug 24 21:49:30 2015 +0100

    ARM: 8421/1: smp: Collapse arch_cpu_idle_dead() into cpu_die()
    
    The only caller of cpu_die() on ARM is arch_cpu_idle_dead(), so
    let's simplify the code by renaming cpu_die() to
    arch_cpu_idle_dead(). While were here, drop the __ref annotation
    because __cpuinit is gone nowadays.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index f192a2a41719..358984b7f249 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -91,13 +91,6 @@ void arch_cpu_idle_exit(void)
 	ledtrig_cpu(CPU_LED_IDLE_END);
 }
 
-#ifdef CONFIG_HOTPLUG_CPU
-void arch_cpu_idle_dead(void)
-{
-	cpu_die();
-}
-#endif
-
 void __show_regs(struct pt_regs *regs)
 {
 	unsigned long flags;

commit 1eef5d2f1b461c120bcd82077edee5ec706ac53b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Aug 19 21:23:48 2015 +0100

    ARM: domains: switch to keeping domain value in register
    
    Rather than modifying both the domain access control register and our
    per-thread copy, modify only the domain access control register, and
    use the per-thread copy to save and restore the register over context
    switches.  We can also avoid the explicit initialisation of the
    init thread_info structure.
    
    This allows us to avoid needing to gain access to the thread information
    at the uaccess control sites.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index f192a2a41719..e722f9b3c9b1 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -146,10 +146,9 @@ void __show_regs(struct pt_regs *regs)
 		buf[0] = '\0';
 #ifdef CONFIG_CPU_CP15_MMU
 		{
-			unsigned int transbase, dac;
+			unsigned int transbase, dac = get_domain();
 			asm("mrc p15, 0, %0, c2, c0\n\t"
-			    "mrc p15, 0, %1, c3, c0\n"
-			    : "=r" (transbase), "=r" (dac));
+			    : "=r" (transbase));
 			snprintf(buf, sizeof(buf), "  Table: %08x  DAC: %08x",
 			  	transbase, dac);
 		}
@@ -210,6 +209,14 @@ copy_thread(unsigned long clone_flags, unsigned long stack_start,
 
 	memset(&thread->cpu_context, 0, sizeof(struct cpu_context_save));
 
+	/*
+	 * Copy the initial value of the domain access control register
+	 * from the current thread: thread->addr_limit will have been
+	 * copied from the current thread via setup_thread_stack() in
+	 * kernel/fork.c
+	 */
+	thread->cpu_domain = get_domain();
+
 	if (likely(!(p->flags & PF_KTHREAD))) {
 		*childregs = *current_pt_regs();
 		childregs->ARM_r0 = 0;

commit c848791f0336914a3081ea3fe029cf177d81de81
Merge: 79403cda3720 e5b61deb3af4 6c5c2a01fcfd
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Apr 14 22:28:25 2015 +0100

    Merge branches 'misc', 'vdso' and 'fixes' into for-next
    
    Conflicts:
            arch/arm/mm/proc-macros.S

commit 045ab94e10ee17038066d71abc8fdce719ab56f9
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Apr 1 17:02:45 2015 +0100

    ARM: move reboot code to arch/arm/kernel/reboot.c
    
    Move shutdown and reboot related code to a separate file, out of
    process.c.  This helps to avoid polluting process.c with non-process
    related code.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 2bf1a162defb..f810a6cc3790 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -17,12 +17,9 @@
 #include <linux/stddef.h>
 #include <linux/unistd.h>
 #include <linux/user.h>
-#include <linux/delay.h>
-#include <linux/reboot.h>
 #include <linux/interrupt.h>
 #include <linux/kallsyms.h>
 #include <linux/init.h>
-#include <linux/cpu.h>
 #include <linux/elfcore.h>
 #include <linux/pm.h>
 #include <linux/tick.h>
@@ -31,17 +28,14 @@
 #include <linux/random.h>
 #include <linux/hw_breakpoint.h>
 #include <linux/leds.h>
-#include <linux/reboot.h>
 
-#include <asm/cacheflush.h>
-#include <asm/idmap.h>
 #include <asm/processor.h>
 #include <asm/thread_notify.h>
 #include <asm/stacktrace.h>
 #include <asm/system_misc.h>
 #include <asm/mach/time.h>
 #include <asm/tls.h>
-#include "reboot.h"
+#include <asm/vdso.h>
 
 #ifdef CONFIG_CC_STACKPROTECTOR
 #include <linux/stackprotector.h>
@@ -60,74 +54,6 @@ static const char *isa_modes[] __maybe_unused = {
   "ARM" , "Thumb" , "Jazelle", "ThumbEE"
 };
 
-extern void call_with_stack(void (*fn)(void *), void *arg, void *sp);
-typedef void (*phys_reset_t)(unsigned long);
-
-/*
- * A temporary stack to use for CPU reset. This is static so that we
- * don't clobber it with the identity mapping. When running with this
- * stack, any references to the current task *will not work* so you
- * should really do as little as possible before jumping to your reset
- * code.
- */
-static u64 soft_restart_stack[16];
-
-static void __soft_restart(void *addr)
-{
-	phys_reset_t phys_reset;
-
-	/* Take out a flat memory mapping. */
-	setup_mm_for_reboot();
-
-	/* Clean and invalidate caches */
-	flush_cache_all();
-
-	/* Turn off caching */
-	cpu_proc_fin();
-
-	/* Push out any further dirty data, and ensure cache is empty */
-	flush_cache_all();
-
-	/* Switch to the identity mapping. */
-	phys_reset = (phys_reset_t)(unsigned long)virt_to_phys(cpu_reset);
-	phys_reset((unsigned long)addr);
-
-	/* Should never get here. */
-	BUG();
-}
-
-void _soft_restart(unsigned long addr, bool disable_l2)
-{
-	u64 *stack = soft_restart_stack + ARRAY_SIZE(soft_restart_stack);
-
-	/* Disable interrupts first */
-	raw_local_irq_disable();
-	local_fiq_disable();
-
-	/* Disable the L2 if we're the last man standing. */
-	if (disable_l2)
-		outer_disable();
-
-	/* Change to the new stack and continue with the reset. */
-	call_with_stack(__soft_restart, (void *)addr, (void *)stack);
-
-	/* Should never get here. */
-	BUG();
-}
-
-void soft_restart(unsigned long addr)
-{
-	_soft_restart(addr, num_online_cpus() == 1);
-}
-
-/*
- * Function pointers to optional machine specific functions
- */
-void (*pm_power_off)(void);
-EXPORT_SYMBOL(pm_power_off);
-
-void (*arm_pm_restart)(enum reboot_mode reboot_mode, const char *cmd);
-
 /*
  * This is our default idle handler.
  */
@@ -172,79 +98,6 @@ void arch_cpu_idle_dead(void)
 }
 #endif
 
-/*
- * Called by kexec, immediately prior to machine_kexec().
- *
- * This must completely disable all secondary CPUs; simply causing those CPUs
- * to execute e.g. a RAM-based pin loop is not sufficient. This allows the
- * kexec'd kernel to use any and all RAM as it sees fit, without having to
- * avoid any code or data used by any SW CPU pin loop. The CPU hotplug
- * functionality embodied in disable_nonboot_cpus() to achieve this.
- */
-void machine_shutdown(void)
-{
-	disable_nonboot_cpus();
-}
-
-/*
- * Halting simply requires that the secondary CPUs stop performing any
- * activity (executing tasks, handling interrupts). smp_send_stop()
- * achieves this.
- */
-void machine_halt(void)
-{
-	local_irq_disable();
-	smp_send_stop();
-
-	local_irq_disable();
-	while (1);
-}
-
-/*
- * Power-off simply requires that the secondary CPUs stop performing any
- * activity (executing tasks, handling interrupts). smp_send_stop()
- * achieves this. When the system power is turned off, it will take all CPUs
- * with it.
- */
-void machine_power_off(void)
-{
-	local_irq_disable();
-	smp_send_stop();
-
-	if (pm_power_off)
-		pm_power_off();
-}
-
-/*
- * Restart requires that the secondary CPUs stop performing any activity
- * while the primary CPU resets the system. Systems with a single CPU can
- * use soft_restart() as their machine descriptor's .restart hook, since that
- * will cause the only available CPU to reset. Systems with multiple CPUs must
- * provide a HW restart implementation, to ensure that all CPUs reset at once.
- * This is required so that any code running after reset on the primary CPU
- * doesn't have to co-ordinate with other CPUs to ensure they aren't still
- * executing pre-reset code, and using RAM that the primary CPU's code wishes
- * to use. Implementing such co-ordination would be essentially impossible.
- */
-void machine_restart(char *cmd)
-{
-	local_irq_disable();
-	smp_send_stop();
-
-	if (arm_pm_restart)
-		arm_pm_restart(reboot_mode, cmd);
-	else
-		do_kernel_restart(cmd);
-
-	/* Give a grace period for failure to restart of 1s */
-	mdelay(1000);
-
-	/* Whoops - the platform was unable to reboot. Tell the user! */
-	printk("Reboot failed -- System halted\n");
-	local_irq_disable();
-	while (1);
-}
-
 void __show_regs(struct pt_regs *regs)
 {
 	unsigned long flags;

commit 767bf7e7a1e82a81c59778348d156993d0a6175d
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Apr 1 16:20:39 2015 +0100

    ARM: fix broken hibernation
    
    Normally, when a CPU wants to clear a cache line to zero in the external
    L2 cache, it would generate bus cycles to write each word as it would do
    with any other data access.
    
    However, a Cortex A9 connected to a L2C-310 has a specific feature where
    the CPU can detect this operation, and signal that it wants to zero an
    entire cache line.  This feature, known as Full Line of Zeros (FLZ),
    involves a non-standard AXI signalling mechanism which only the L2C-310
    can properly interpret.
    
    There are separate enable bits in both the L2C-310 and the Cortex A9 -
    the L2C-310 needs to be enabled and have the FLZ enable bit set in the
    auxiliary control register before the Cortex A9 has this feature
    enabled.
    
    Unfortunately, the suspend code was not respecting this - it's not
    obvious from the code:
    
    swsusp_arch_suspend()
     cpu_suspend() /* saves the Cortex A9 auxiliary control register */
      arch_save_image()
      soft_restart() /* turns off FLZ in Cortex A9, and disables L2C */
       cpu_resume() /* restores the Cortex A9 registers, inc auxcr */
    
    At this point, we end up with the L2C disabled, but the Cortex A9 with
    FLZ enabled - which means any memset() or zeroing of a full cache line
    will fail to take effect.
    
    A similar issue exists in the resume path, but it's slightly more
    complex:
    
    swsusp_arch_suspend()
     cpu_suspend() /* saves the Cortex A9 auxiliary control register */
      arch_save_image() /* image with A9 auxcr saved */
    ...
    swsusp_arch_resume()
     call_with_stack()
      arch_restore_image() /* restores image with A9 auxcr saved above */
      soft_restart() /* turns off FLZ in Cortex A9, and disables L2C */
       cpu_resume() /* restores the Cortex A9 registers, inc auxcr */
    
    Again, here we end up with the L2C disabled, but Cortex A9 FLZ enabled.
    
    There's no need to turn off the L2C in either of these two paths; there
    are benefits from not doing so - for example, the page copies will be
    faster with the L2C enabled.
    
    Hence, fix this by providing a variant of soft_restart() which can be
    used without turning the L2 cache controller off, and use it in both
    of these paths to keep the L2C enabled across the respective resume
    transitions.
    
    Fixes: 8ef418c7178f ("ARM: l2c: trial at enabling some Cortex-A9 optimisations")
    Reported-by: Sean Cross <xobs@kosagi.com>
    Tested-by: Sean Cross <xobs@kosagi.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index fdfa3a78ec8c..2bf1a162defb 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -41,6 +41,7 @@
 #include <asm/system_misc.h>
 #include <asm/mach/time.h>
 #include <asm/tls.h>
+#include "reboot.h"
 
 #ifdef CONFIG_CC_STACKPROTECTOR
 #include <linux/stackprotector.h>
@@ -95,7 +96,7 @@ static void __soft_restart(void *addr)
 	BUG();
 }
 
-void soft_restart(unsigned long addr)
+void _soft_restart(unsigned long addr, bool disable_l2)
 {
 	u64 *stack = soft_restart_stack + ARRAY_SIZE(soft_restart_stack);
 
@@ -104,7 +105,7 @@ void soft_restart(unsigned long addr)
 	local_fiq_disable();
 
 	/* Disable the L2 if we're the last man standing. */
-	if (num_online_cpus() == 1)
+	if (disable_l2)
 		outer_disable();
 
 	/* Change to the new stack and continue with the reset. */
@@ -114,6 +115,11 @@ void soft_restart(unsigned long addr)
 	BUG();
 }
 
+void soft_restart(unsigned long addr)
+{
+	_soft_restart(addr, num_online_cpus() == 1);
+}
+
 /*
  * Function pointers to optional machine specific functions
  */

commit ecf99a439105ebd0a507af1a9cd901a2e166bf9a
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Wed Mar 25 19:15:08 2015 +0100

    ARM: 8331/1: VDSO initialization, mapping, and synchronization
    
    Initialize the VDSO page list at boot, install the VDSO mapping at
    exec time, and update the data page during timer ticks.  This code is
    not built if CONFIG_VDSO is not enabled.
    
    Account for the VDSO length when randomizing the offset from the
    stack.  The [vdso] and [vvar] pages are placed immediately following
    the sigpage with separate _install_special_mapping calls.
    
    We want to "penalize" systems lacking the arch timer as little
    as possible.  Previous versions of this code installed the VDSO
    unconditionally and unmodified, making it a measurably slower way for
    glibc to invoke the real syscalls on such systems.  E.g. calling
    gettimeofday via glibc goes from ~560ns to ~630ns on i.MX6Q.
    
    If we can indicate to glibc that the time-related APIs in the VDSO are
    not accelerated, glibc can continue to invoke the syscalls directly
    instead of dispatching through the VDSO only to fall back to the slow
    path.
    
    Thus, if the architected timer is unusable for whatever reason, patch
    the VDSO at boot time so that symbol lookups for gettimeofday and
    clock_gettime return NULL.  (This is similar to what powerpc does and
    borrows code from there.)  This allows glibc to perform the syscall
    directly instead of passing control to the VDSO, which minimizes the
    penalty.  In my measurements the time taken for a gettimeofday call
    via glibc goes from ~560ns to ~580ns (again on i.MX6Q), and this is
    solely due to adding a test and branch to glibc's gettimeofday syscall
    wrapper.
    
    An alternative to patching the VDSO at boot would be to not install
    the VDSO at all when the arch timer isn't usable.  Another alternative
    is to include a separate "dummy" vdso.so without gettimeofday and
    clock_gettime, which would be selected at boot time.  Either of these
    would get cumbersome if the VDSO were to gain support for an API such
    as getcpu which is unrelated to arch timer support.
    
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index fdfa3a78ec8c..c50fe212fd89 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -41,6 +41,7 @@
 #include <asm/system_misc.h>
 #include <asm/mach/time.h>
 #include <asm/tls.h>
+#include <asm/vdso.h>
 
 #ifdef CONFIG_CC_STACKPROTECTOR
 #include <linux/stackprotector.h>
@@ -475,7 +476,7 @@ const char *arch_vma_name(struct vm_area_struct *vma)
 }
 
 /* If possible, provide a placement hint at a random offset from the
- * stack for the signal page.
+ * stack for the sigpage and vdso pages.
  */
 static unsigned long sigpage_addr(const struct mm_struct *mm,
 				  unsigned int npages)
@@ -519,6 +520,7 @@ int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
 {
 	struct mm_struct *mm = current->mm;
 	struct vm_area_struct *vma;
+	unsigned long npages;
 	unsigned long addr;
 	unsigned long hint;
 	int ret = 0;
@@ -528,9 +530,12 @@ int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
 	if (!signal_page)
 		return -ENOMEM;
 
+	npages = 1; /* for sigpage */
+	npages += vdso_total_pages;
+
 	down_write(&mm->mmap_sem);
-	hint = sigpage_addr(mm, 1);
-	addr = get_unmapped_area(NULL, hint, PAGE_SIZE, 0, 0);
+	hint = sigpage_addr(mm, npages);
+	addr = get_unmapped_area(NULL, hint, npages << PAGE_SHIFT, 0, 0);
 	if (IS_ERR_VALUE(addr)) {
 		ret = addr;
 		goto up_fail;
@@ -547,6 +552,12 @@ int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
 
 	mm->context.sigpage = addr;
 
+	/* Unlike the sigpage, failure to install the vdso is unlikely
+	 * to be fatal to the process, so no error check needed
+	 * here.
+	 */
+	arm_install_vdso(mm, addr + PAGE_SIZE);
+
  up_fail:
 	up_write(&mm->mmap_sem);
 	return ret;

commit f3a04202c519a1b496a63d83fc92067fe695f69a
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Dec 1 19:45:19 2014 +0100

    ARM: 8241/1: Update processor_modes for hyp and monitor mode
    
    If the kernel is running in hypervisor mode or monitor mode we'll
    print UK6_32 or UK10_32 if we call into __show_regs(). Let's
    update these strings to indicate the new modes that didn't exist
    when this code was written.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index fe972a2f3df3..fdfa3a78ec8c 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -51,8 +51,8 @@ EXPORT_SYMBOL(__stack_chk_guard);
 static const char *processor_modes[] __maybe_unused = {
   "USER_26", "FIQ_26" , "IRQ_26" , "SVC_26" , "UK4_26" , "UK5_26" , "UK6_26" , "UK7_26" ,
   "UK8_26" , "UK9_26" , "UK10_26", "UK11_26", "UK12_26", "UK13_26", "UK14_26", "UK15_26",
-  "USER_32", "FIQ_32" , "IRQ_32" , "SVC_32" , "UK4_32" , "UK5_32" , "UK6_32" , "ABT_32" ,
-  "UK8_32" , "UK9_32" , "UK10_32", "UND_32" , "UK12_32", "UK13_32", "UK14_32", "SYS_32"
+  "USER_32", "FIQ_32" , "IRQ_32" , "SVC_32" , "UK4_32" , "UK5_32" , "MON_32" , "ABT_32" ,
+  "UK8_32" , "UK9_32" , "HYP_32", "UND_32" , "UK12_32", "UK13_32", "UK14_32", "SYS_32"
 };
 
 static const char *isa_modes[] __maybe_unused = {

commit 93834c6419bccf102a17971c6b114826597a61c5
Merge: c798360cd143 6cd6d94d96d9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 10 16:38:02 2014 -0400

    Merge tag 'restart-handler-for-v3.18' of git://git.kernel.org/pub/scm/linux/kernel/git/groeck/linux-staging
    
    Pull restart handler infrastructure from Guenter Roeck:
     "This series was supposed to be pulled through various trees using it,
      and I did not plan to send a separate pull request.  As it turns out,
      the pinctrl tree did not merge with it, is now upstream, and uses it,
      meaning there are now build failures.
    
      Please pull this series directly to fix those build failures"
    
    * tag 'restart-handler-for-v3.18' of git://git.kernel.org/pub/scm/linux/kernel/git/groeck/linux-staging:
      arm/arm64: unexport restart handlers
      watchdog: sunxi: register restart handler with kernel restart handler
      watchdog: alim7101: register restart handler with kernel restart handler
      watchdog: moxart: register restart handler with kernel restart handler
      arm: support restart through restart handler call chain
      arm64: support restart through restart handler call chain
      power/restart: call machine_restart instead of arm_pm_restart
      kernel: add support for kernel restart handler call chain

commit d5d16892243e7755da706d03b34da85ea6a74117
Merge: 3467e765a592 ad684dce87fa f3354ab67476 421520ba9829
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Oct 2 21:47:02 2014 +0100

    Merge branches 'fiq' (early part), 'fixes', 'l2c' (early part) and 'misc' into for-next

commit 389522b0c0530658eb9f9a53410ec2494616d785
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Mon Sep 22 22:12:35 2014 +0100

    ARM: 8155/1: place sigpage at a random offset above stack
    
    The sigpage is currently placed alongside shared libraries etc in the
    address space.  Similar to what x86_64 does for its VDSO, place the
    sigpage at a randomized offset above the stack so that learning the
    base address of the sigpage doesn't help expose where shared libraries
    are loaded in the address space (and vice versa).
    
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 46fbbb3701a0..edd2ac3d7c44 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -475,6 +475,39 @@ const char *arch_vma_name(struct vm_area_struct *vma)
 	return is_gate_vma(vma) ? "[vectors]" : NULL;
 }
 
+/* If possible, provide a placement hint at a random offset from the
+ * stack for the signal page.
+ */
+static unsigned long sigpage_addr(const struct mm_struct *mm,
+				  unsigned int npages)
+{
+	unsigned long offset;
+	unsigned long first;
+	unsigned long last;
+	unsigned long addr;
+	unsigned int slots;
+
+	first = PAGE_ALIGN(mm->start_stack);
+
+	last = TASK_SIZE - (npages << PAGE_SHIFT);
+
+	/* No room after stack? */
+	if (first > last)
+		return 0;
+
+	/* Just enough room? */
+	if (first == last)
+		return first;
+
+	slots = ((last - first) >> PAGE_SHIFT) + 1;
+
+	offset = get_random_int() % slots;
+
+	addr = first + (offset << PAGE_SHIFT);
+
+	return addr;
+}
+
 static struct page *signal_page;
 extern struct page *get_signal_page(void);
 
@@ -488,6 +521,7 @@ int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
 	struct mm_struct *mm = current->mm;
 	struct vm_area_struct *vma;
 	unsigned long addr;
+	unsigned long hint;
 	int ret = 0;
 
 	if (!signal_page)
@@ -496,7 +530,8 @@ int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
 		return -ENOMEM;
 
 	down_write(&mm->mmap_sem);
-	addr = get_unmapped_area(NULL, 0, PAGE_SIZE, 0, 0);
+	hint = sigpage_addr(mm, 1);
+	addr = get_unmapped_area(NULL, hint, PAGE_SIZE, 0, 0);
 	if (IS_ERR_VALUE(addr)) {
 		ret = addr;
 		goto up_fail;

commit 02e0409a65560da66a747d2ac6023715b04659ea
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Mon Sep 22 22:08:42 2014 +0100

    ARM: 8154/1: use _install_special_mapping for sigpage
    
    _install_special_mapping allows the VMA to be identifed in
    /proc/pid/maps without the use of arch_vma_name, providing a
    slight net reduction in object size:
    
      text    data     bss     dec     hex filename
      2996      96     144    3236     ca4 arch/arm/kernel/process.o (before)
      2956     104     144    3204     c84 arch/arm/kernel/process.o (after)
    
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 81ef686a91ca..46fbbb3701a0 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -472,19 +472,23 @@ int in_gate_area_no_mm(unsigned long addr)
 
 const char *arch_vma_name(struct vm_area_struct *vma)
 {
-	return is_gate_vma(vma) ? "[vectors]" :
-		(vma->vm_mm && vma->vm_start == vma->vm_mm->context.sigpage) ?
-		 "[sigpage]" : NULL;
+	return is_gate_vma(vma) ? "[vectors]" : NULL;
 }
 
 static struct page *signal_page;
 extern struct page *get_signal_page(void);
 
+static const struct vm_special_mapping sigpage_mapping = {
+	.name = "[sigpage]",
+	.pages = &signal_page,
+};
+
 int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
 {
 	struct mm_struct *mm = current->mm;
+	struct vm_area_struct *vma;
 	unsigned long addr;
-	int ret;
+	int ret = 0;
 
 	if (!signal_page)
 		signal_page = get_signal_page();
@@ -498,12 +502,16 @@ int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
 		goto up_fail;
 	}
 
-	ret = install_special_mapping(mm, addr, PAGE_SIZE,
+	vma = _install_special_mapping(mm, addr, PAGE_SIZE,
 		VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC,
-		&signal_page);
+		&sigpage_mapping);
+
+	if (IS_ERR(vma)) {
+		ret = PTR_ERR(vma);
+		goto up_fail;
+	}
 
-	if (ret == 0)
-		mm->context.sigpage = addr;
+	mm->context.sigpage = addr;
 
  up_fail:
 	up_write(&mm->mmap_sem);

commit 6cd6d94d96d9b1cd8a62da91aac44cf56e301e75
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Fri Sep 26 00:03:17 2014 +0000

    arm/arm64: unexport restart handlers
    
    Implementing a restart handler in a module don't make sense as there would
    be no guarantee that the module is loaded when a restart is needed.
    Unexport arm_pm_restart to ensure that no one gets the idea to do it
    anyway.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jonas Jensen <jonas.jensen@gmail.com>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Tomasz Figa <t.figa@samsung.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Wim Van Sebroeck <wim@iguana.be>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index ea279f7a8767..250b6f652afc 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -121,7 +121,6 @@ void (*pm_power_off)(void);
 EXPORT_SYMBOL(pm_power_off);
 
 void (*arm_pm_restart)(enum reboot_mode reboot_mode, const char *cmd);
-EXPORT_SYMBOL_GPL(arm_pm_restart);
 
 /*
  * This is our default idle handler.

commit 1a9607a3be14a43868c5e6a35962e7f6be9bcfe1
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Fri Sep 26 00:03:17 2014 +0000

    arm: support restart through restart handler call chain
    
    The kernel core now supports a restart handler call chain for system
    restart functions.
    
    With this change, the arm_pm_restart callback is now optional, so drop its
    initialization and check if it is set before calling it.  Only call the
    kernel restart handler if arm_pm_restart is not set.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jonas Jensen <jonas.jensen@gmail.com>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Tomasz Figa <t.figa@samsung.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Wim Van Sebroeck <wim@iguana.be>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 81ef686a91ca..ea279f7a8767 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -114,17 +114,13 @@ void soft_restart(unsigned long addr)
 	BUG();
 }
 
-static void null_restart(enum reboot_mode reboot_mode, const char *cmd)
-{
-}
-
 /*
  * Function pointers to optional machine specific functions
  */
 void (*pm_power_off)(void);
 EXPORT_SYMBOL(pm_power_off);
 
-void (*arm_pm_restart)(enum reboot_mode reboot_mode, const char *cmd) = null_restart;
+void (*arm_pm_restart)(enum reboot_mode reboot_mode, const char *cmd);
 EXPORT_SYMBOL_GPL(arm_pm_restart);
 
 /*
@@ -230,7 +226,10 @@ void machine_restart(char *cmd)
 	local_irq_disable();
 	smp_send_stop();
 
-	arm_pm_restart(reboot_mode, cmd);
+	if (arm_pm_restart)
+		arm_pm_restart(reboot_mode, cmd);
+	else
+		do_kernel_restart(cmd);
 
 	/* Give a grace period for failure to restart of 1s */
 	mdelay(1000);

commit 7f038073c0a3e22e12344ab8b41d46547c072c82
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Sep 3 23:36:58 2014 +0100

    ARM: remove extraneous newline in show_regs()
    
    Remove an unnecessary newline in show_regs().
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 81ef686a91ca..52a21dafb27e 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -306,7 +306,6 @@ void __show_regs(struct pt_regs *regs)
 
 void show_regs(struct pt_regs * regs)
 {
-	printk("\n");
 	__show_regs(regs);
 	dump_stack();
 }

commit fbfb872f5f417cea48760c535e0ff027c88b507a
Author: Nathan Lynch <nathan_lynch@mentor.com>
Date:   Thu Sep 11 02:49:08 2014 +0100

    ARM: 8148/1: flush TLS and thumbee register state during exec
    
    The TPIDRURO and TPIDRURW registers need to be flushed during exec;
    otherwise TLS information is potentially leaked.  TPIDRURO in
    particular needs careful treatment.  Since flush_thread basically
    needs the same code used to set the TLS in arm_syscall, pull that into
    a common set_tls helper in tls.h and use it in both places.
    
    Similarly, TEEHBR needs to be cleared during exec as well.  Clearing
    its save slot in thread_info isn't right as there is no guarantee
    that a thread switch will occur before the new program runs.  Just
    setting the register directly is sufficient.
    
    Signed-off-by: Nathan Lynch <nathan_lynch@mentor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 81ef686a91ca..a35f6ebbd2c2 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -334,6 +334,8 @@ void flush_thread(void)
 	memset(&tsk->thread.debug, 0, sizeof(struct debug_info));
 	memset(&thread->fpstate, 0, sizeof(union fp_state));
 
+	flush_tls();
+
 	thread_notify(THREAD_NOTIFY_FLUSH, thread);
 }
 

commit ede1d63fccb7a397832ddbdee5951ec65194d93e
Merge: b42e6dc66bf3 98f07013149d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 11 11:56:40 2014 -0700

    Merge branch 'for-linus' of git://ftp.arm.linux.org.uk/~rmk/linux-arm
    
    Pull second set of ARM changes from Russell King:
     "This is the remainder of the ARM changes for this merge window.
      Included in this request are:
    
       - fixes for kprobes for big-endian support
       - fix tracing in soft_restart
       - avoid phys address overflow in kdump code
       - fix reporting of read-only pmd bits in kernel page table dump
       - remove unnecessary (and possibly buggy) call to outer_flush_all()
       - fix a three sparse warnings (missing header file for function
         prototypes)
       - fix pj4 crashing single zImage (thanks to arm-soc merging changes
         which enables this with knowledge that the corresponding fix had
         not even been submitted for my tree before the merge window opened)
       - vfp macro cleanups
       - dump register state on undefined instruction userspace faults when
         debugging"
    
    * 'for-linus' of git://ftp.arm.linux.org.uk/~rmk/linux-arm:
      Dump the registers on undefined instruction userspace faults
      ARM: 8018/1: Add {inc,dec}_preempt_count asm macros
      ARM: 8017/1: Move asm macro get_thread_info to asm/assembler.h
      ARM: 8016/1: Check cpu id in pj4_cp0_init.
      ARM: 8015/1: Add cpu_is_pj4 to distinguish PJ4 because it has some differences with V7
      ARM: add missing system_misc.h include to process.c
      ARM: 8009/1: dcscb.c: remove call to outer_flush_all()
      ARM: 8014/1: mm: fix reporting of read-only PMD bits
      ARM: 8012/1: kdump: Avoid overflow when converting pfn to physaddr
      ARM: 8010/1: avoid tracers in soft_restart
      ARM: kprobes-test: Workaround GAS .align bug
      ARM: kprobes-test: use <asm/opcodes.h> for Thumb instruction building
      ARM: kprobes-test: use <asm/opcodes.h> for ARM instruction building
      ARM: kprobes-test: use <asm/opcodes.h> for instruction accesses
      ARM: probes: fix instruction fetch order with <asm/opcodes.h>

commit 53f1d9afb4c85c4d6a107420188d84ddf76ebbc0
Merge: bce5669be3a8 c9d347e02776 b5b6b5f54428
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Apr 11 14:50:05 2014 +0100

    Merge branches 'fixes' and 'misc' into for-next

commit 779dd9590b00bd91b7811c24f0df34a9d91bfa0f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Apr 6 16:17:39 2014 +0100

    ARM: add missing system_misc.h include to process.c
    
    arm_pm_restart(), arm_pm_idle() and soft_restart() are all declared in
    system_misc.h, but this file is not included in process.c.  Add this
    missing include.  Found via sparse:
    
    arch/arm/kernel/process.c:98:6: warning: symbol 'soft_restart' was not declared. Should it be static?
    arch/arm/kernel/process.c:127:6: warning: symbol 'arm_pm_restart' was not declared. Should it be static?
    arch/arm/kernel/process.c:134:6: warning: symbol 'arm_pm_idle' was not declared. Should it be static?
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 92f7b15dd221..da450e06c9ae 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -39,6 +39,7 @@
 #include <asm/processor.h>
 #include <asm/thread_notify.h>
 #include <asm/stacktrace.h>
+#include <asm/system_misc.h>
 #include <asm/mach/time.h>
 #include <asm/tls.h>
 

commit c7d442f46c1bb18e48204f41c3d838c475eb5130
Author: Sebastian Capella <sebastian.capella@linaro.org>
Date:   Tue Mar 25 01:18:35 2014 +0100

    ARM: 8010/1: avoid tracers in soft_restart
    
    Use of tracers in local_irq_disable is causes abort loops when called
    with irqs disabled using a temporary stack.  Replace local_irq_disable
    with raw_local_irq_disable instead to avoid tracers.
    
    Signed-off-by: Sebastian Capella <sebastian.capella@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 92f7b15dd221..f58b723bec00 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -100,7 +100,7 @@ void soft_restart(unsigned long addr)
 	u64 *stack = soft_restart_stack + ARRAY_SIZE(soft_restart_stack);
 
 	/* Disable interrupts first */
-	local_irq_disable();
+	raw_local_irq_disable();
 	local_fiq_disable();
 
 	/* Disable the L2 if we're the last man standing. */

commit 2d1eb87ae1e6f3999e77989fd2f831b134270787
Merge: 2f997759dffe bce5669be3a8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 5 13:20:43 2014 -0700

    Merge branch 'for-linus' of git://ftp.arm.linux.org.uk/~rmk/linux-arm
    
    Pull ARM changes from Russell King:
    
     - Perf updates from Will Deacon:
       - Support for Qualcomm Krait processors (run perf on your phone!)
       - Support for Cortex-A12 (run perf stat on your FPGA!)
       - Support for perf_sample_event_took, allowing us to automatically decrease
         the sample rate if we can't handle the PMU interrupts quickly enough
         (run perf record on your FPGA!).
    
     - Basic uprobes support from David Long:
         This patch series adds basic uprobes support to ARM. It is based on
         patches developed earlier by Rabin Vincent. That approach of adding
         hooks into the kprobes instruction parsing code was not well received.
         This approach separates the ARM instruction parsing code in kprobes out
         into a separate set of functions which can be used by both kprobes and
         uprobes. Both kprobes and uprobes then provide their own semantic action
         tables to process the results of the parsing.
    
     - ARMv7M (microcontroller) updates from Uwe Kleine-König
    
     - OMAP DMA updates (recently added Vinod's Ack even though they've been
       sitting in linux-next for a few months) to reduce the reliance of
       omap-dma on the code in arch/arm.
    
     - SA11x0 changes from Dmitry Eremin-Solenikov and Alexander Shiyan
    
     - Support for Cortex-A12 CPU
    
     - Align support for ARMv6 with ARMv7 so they can cooperate better in a
       single zImage.
    
     - Addition of first AT_HWCAP2 feature bits for ARMv8 crypto support.
    
     - Removal of IRQ_DISABLED from various ARM files
    
     - Improved efficiency of virt_to_page() for single zImage
    
     - Patch from Ulf Hansson to permit runtime PM callbacks to be available for
       AMBA devices for suspend/resume as well.
    
     - Finally kill asm/system.h on ARM.
    
    * 'for-linus' of git://ftp.arm.linux.org.uk/~rmk/linux-arm: (89 commits)
      dmaengine: omap-dma: more consolidation of CCR register setup
      dmaengine: omap-dma: move IRQ handling to omap-dma
      dmaengine: omap-dma: move register read/writes into omap-dma.c
      ARM: omap: dma: get rid of 'p' allocation and clean up
      ARM: omap: move dma channel allocation into plat-omap code
      ARM: omap: dma: get rid of errata global
      ARM: omap: clean up DMA register accesses
      ARM: omap: remove almost-const variables
      ARM: omap: remove references to disable_irq_lch
      dmaengine: omap-dma: cleanup errata 3.3 handling
      dmaengine: omap-dma: provide register read/write functions
      dmaengine: omap-dma: use cached CCR value when enabling DMA
      dmaengine: omap-dma: move barrier to omap_dma_start_desc()
      dmaengine: omap-dma: move clnk_ctrl setting to preparation functions
      dmaengine: omap-dma: improve efficiency loading C.SA/C.EI/C.FI registers
      dmaengine: omap-dma: consolidate clearing channel status register
      dmaengine: omap-dma: move CCR buffering disable errata out of the fast path
      dmaengine: omap-dma: provide register definitions
      dmaengine: omap-dma: consolidate setup of CCR
      dmaengine: omap-dma: consolidate setup of CSDP
      ...

commit ad68cc7a777948b77f15a3dc3510918ff87ed0c0
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Wed Jan 29 12:45:09 2014 -0500

    sched/idle, ARM: Remove redundant cpuidle_idle_call()
    
    The core idle loop now takes care of it.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: linux-sh@vger.kernel.org
    Cc: linux-pm@vger.kernel.org
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: linaro-kernel@lists.linaro.org
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/n/tip-y2nbw5j3ma5siy5584919z5i@git.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 92f7b15dd221..adabeababeb0 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -30,7 +30,6 @@
 #include <linux/uaccess.h>
 #include <linux/random.h>
 #include <linux/hw_breakpoint.h>
-#include <linux/cpuidle.h>
 #include <linux/leds.h>
 #include <linux/reboot.h>
 
@@ -133,7 +132,11 @@ EXPORT_SYMBOL_GPL(arm_pm_restart);
 
 void (*arm_pm_idle)(void);
 
-static void default_idle(void)
+/*
+ * Called from the core idle loop.
+ */
+
+void arch_cpu_idle(void)
 {
 	if (arm_pm_idle)
 		arm_pm_idle();
@@ -167,15 +170,6 @@ void arch_cpu_idle_dead(void)
 }
 #endif
 
-/*
- * Called from the core idle loop.
- */
-void arch_cpu_idle(void)
-{
-	if (cpuidle_idle_call())
-		default_idle();
-}
-
 /*
  * Called by kexec, immediately prior to machine_kexec().
  *

commit e2e55fde3f2eaeb1d341508108a51a61dd0fb470
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Dec 16 10:38:57 2013 +0100

    ARM: show_regs: on v7-M there are no FIQs, different processor modes, ...
    
    no indication about irqs in PSR and only a single ISA. So skip the whole
    decoding and just print the xPSR on v7-M.
    
    Also mark two static variables as __maybe_unused to prevent the compiler
    from emitting:
    
            arch/arm/kernel/process.c:51:20: warning: 'processor_modes' defined but not used [-Wunused-variable]
            arch/arm/kernel/process.c:58:20: warning: 'isa_modes' defined but not used [-Wunused-variable]
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 92f7b15dd221..204f7d273319 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -48,14 +48,14 @@ unsigned long __stack_chk_guard __read_mostly;
 EXPORT_SYMBOL(__stack_chk_guard);
 #endif
 
-static const char *processor_modes[] = {
+static const char *processor_modes[] __maybe_unused = {
   "USER_26", "FIQ_26" , "IRQ_26" , "SVC_26" , "UK4_26" , "UK5_26" , "UK6_26" , "UK7_26" ,
   "UK8_26" , "UK9_26" , "UK10_26", "UK11_26", "UK12_26", "UK13_26", "UK14_26", "UK15_26",
   "USER_32", "FIQ_32" , "IRQ_32" , "SVC_32" , "UK4_32" , "UK5_32" , "UK6_32" , "ABT_32" ,
   "UK8_32" , "UK9_32" , "UK10_32", "UND_32" , "UK12_32", "UK13_32", "UK14_32", "SYS_32"
 };
 
-static const char *isa_modes[] = {
+static const char *isa_modes[] __maybe_unused = {
   "ARM" , "Thumb" , "Jazelle", "ThumbEE"
 };
 
@@ -276,12 +276,17 @@ void __show_regs(struct pt_regs *regs)
 	buf[3] = flags & PSR_V_BIT ? 'V' : 'v';
 	buf[4] = '\0';
 
+#ifndef CONFIG_CPU_V7M
 	printk("Flags: %s  IRQs o%s  FIQs o%s  Mode %s  ISA %s  Segment %s\n",
 		buf, interrupts_enabled(regs) ? "n" : "ff",
 		fast_interrupts_enabled(regs) ? "n" : "ff",
 		processor_modes[processor_mode(regs)],
 		isa_modes[isa_mode(regs)],
 		get_fs() == get_ds() ? "kernel" : "user");
+#else
+	printk("xPSR: %08lx\n", regs->ARM_cpsr);
+#endif
+
 #ifdef CONFIG_CPU_CP15
 	{
 		unsigned int ctrl;

commit 1b15ec7a7427d4188ba91b9bbac696250a059d22
Author: Konstantin Khlebnikov <k.khlebnikov@samsung.com>
Date:   Thu Dec 5 14:21:36 2013 +0100

    ARM: 7912/1: check stack pointer in get_wchan
    
    get_wchan() is lockless. Task may wakeup at any time and change its own stack,
    thus each next stack frame may be overwritten and filled with random stuff.
    
    /proc/$pid/stack interface had been disabled for non-current tasks, see [1]
    But 'wchan' still allows to trigger stack frame unwinding on volatile stack.
    
    This patch fixes oops in unwind_frame() by adding stack pointer validation on
    each step (as x86 code do), unwind_frame() already checks frame pointer.
    
    Also I've found another report of this oops on stackoverflow (irony).
    
    Link: http://www.spinics.net/lists/arm-kernel/msg110589.html [1]
    Link: http://stackoverflow.com/questions/18479894/unwind-frame-cause-a-kernel-paging-error
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Konstantin Khlebnikov <k.khlebnikov@samsung.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 94f6b05f9e24..92f7b15dd221 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -404,6 +404,7 @@ EXPORT_SYMBOL(dump_fpu);
 unsigned long get_wchan(struct task_struct *p)
 {
 	struct stackframe frame;
+	unsigned long stack_page;
 	int count = 0;
 	if (!p || p == current || p->state == TASK_RUNNING)
 		return 0;
@@ -412,9 +413,11 @@ unsigned long get_wchan(struct task_struct *p)
 	frame.sp = thread_saved_sp(p);
 	frame.lr = 0;			/* recovered from the stack */
 	frame.pc = thread_saved_pc(p);
+	stack_page = (unsigned long)task_stack_page(p);
 	do {
-		int ret = unwind_frame(&frame);
-		if (ret < 0)
+		if (frame.sp < stack_page ||
+		    frame.sp >= stack_page + THREAD_SIZE ||
+		    unwind_frame(&frame) < 0)
 			return 0;
 		if (!in_sched_functions(frame.pc))
 			return frame.pc;

commit 2a2822475d0e734adffab72644329d9c042ce2e1
Merge: 2103f6cba61a d9f966357b14
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Aug 13 20:23:28 2013 +0100

    Merge branch 'security-fixes' into fixes

commit 1d0bbf428924f94867542d49d436cf254b9dbd06
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Aug 6 09:49:14 2013 +0100

    ARM: Fix the world famous typo with is_gate_vma()
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index d03b5bd889c5..e28d43f74dbf 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -459,7 +459,7 @@ int in_gate_area_no_mm(unsigned long addr)
 {
 	return in_gate_area(NULL, addr);
 }
-#define is_gate_vma(vma)	((vma) = &gate_vma)
+#define is_gate_vma(vma)	((vma) == &gate_vma)
 #else
 #define is_gate_vma(vma)	0
 #endif

commit e35ac62d2202e31307c0f9b278a61e484c4727f2
Merge: 24195cad3e00 8c0cc8a5d90b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Aug 3 10:49:38 2013 +0100

    Merge branch 'security-fixes' into fixes

commit e0d407564b532d978b03ceccebd224a05d02f111
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Aug 3 10:30:05 2013 +0100

    ARM: fix a cockup in 48be69a02 (ARM: move signal handlers into a vdso-like page)
    
    Unfortunately, I never committed the fix to a nasty oops which can
    occur as a result of that commit:
    
    ------------[ cut here ]------------
    kernel BUG at /home/olof/work/batch/include/linux/mm.h:414!
    Internal error: Oops - BUG: 0 [#1] PREEMPT SMP ARM
    Modules linked in:
    CPU: 0 PID: 490 Comm: killall5 Not tainted 3.11.0-rc3-00288-gabe0308 #53
    task: e90acac0 ti: e9be8000 task.ti: e9be8000
    PC is at special_mapping_fault+0xa4/0xc4
    LR is at __do_fault+0x68/0x48c
    
    This doesn't show up unless you do quite a bit of testing; a simple
    boot test does not do this, so all my nightly tests were passing fine.
    
    The reason for this is that install_special_mapping() expects the
    page array to stick around, and as this was only inserting one page
    which was stored on the kernel stack, that's why this was blowing up.
    
    Reported-by: Olof Johansson <olof@lixom.net>
    Tested-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 1e6c33d01c05..d03b5bd889c5 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -471,17 +471,18 @@ const char *arch_vma_name(struct vm_area_struct *vma)
 		 "[sigpage]" : NULL;
 }
 
+static struct page *signal_page;
 extern struct page *get_signal_page(void);
 
 int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
 {
 	struct mm_struct *mm = current->mm;
-	struct page *page;
 	unsigned long addr;
 	int ret;
 
-	page = get_signal_page();
-	if (!page)
+	if (!signal_page)
+		signal_page = get_signal_page();
+	if (!signal_page)
 		return -ENOMEM;
 
 	down_write(&mm->mmap_sem);
@@ -493,7 +494,7 @@ int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
 
 	ret = install_special_mapping(mm, addr, PAGE_SIZE,
 		VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC,
-		&page);
+		&signal_page);
 
 	if (ret == 0)
 		mm->context.sigpage = addr;

commit 24195cad3e00557da166d629c8b0fd2f984f2170
Merge: 2449189bb7c7 a5463cd34354
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Aug 1 20:51:13 2013 +0100

    Merge branch 'security-fixes' into fixes

commit 44424c34049f41123a3a8b4853822f47f4ff03a2
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue Jul 30 23:09:46 2013 +0100

    ARM: 7803/1: Fix deadlock scenario with smp_send_stop()
    
    If one process calls sys_reboot and that process then stops other
    CPUs while those CPUs are within a spin_lock() region we can
    potentially encounter a deadlock scenario like below.
    
    CPU 0                   CPU 1
    -----                   -----
                            spin_lock(my_lock)
    smp_send_stop()
     <send IPI>             handle_IPI()
                             disable_preemption/irqs
                              while(1);
     <PREEMPT>
    spin_lock(my_lock) <--- Waits forever
    
    We shouldn't attempt to run any other tasks after we send a stop
    IPI to a CPU so disable preemption so that this task runs to
    completion. We use local_irq_disable() here for cross-arch
    consistency with x86.
    
    Reported-by: Sundarajan Srinivasan <sundaraj@codeaurora.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index d3ca4f6915af..08b47ebd3144 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -197,6 +197,7 @@ void machine_shutdown(void)
  */
 void machine_halt(void)
 {
+	local_irq_disable();
 	smp_send_stop();
 
 	local_irq_disable();
@@ -211,6 +212,7 @@ void machine_halt(void)
  */
 void machine_power_off(void)
 {
+	local_irq_disable();
 	smp_send_stop();
 
 	if (pm_power_off)
@@ -230,6 +232,7 @@ void machine_power_off(void)
  */
 void machine_restart(char *cmd)
 {
+	local_irq_disable();
 	smp_send_stop();
 
 	arm_pm_restart(reboot_mode, cmd);

commit a5463cd3435475386cbbe7b06e01292ac169d36f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Jul 31 21:58:56 2013 +0100

    ARM: make vectors page inaccessible from userspace
    
    If kuser helpers are not provided by the kernel, disable user access to
    the vectors page.  With the kuser helpers gone, there is no reason for
    this page to be visible to userspace.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 566d0d71a1e7..1e6c33d01c05 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -426,6 +426,7 @@ unsigned long arch_randomize_brk(struct mm_struct *mm)
 }
 
 #ifdef CONFIG_MMU
+#ifdef CONFIG_KUSER_HELPERS
 /*
  * The vectors page is always readable from user space for the
  * atomic helpers. Insert it into the gate_vma so that it is visible
@@ -458,10 +459,14 @@ int in_gate_area_no_mm(unsigned long addr)
 {
 	return in_gate_area(NULL, addr);
 }
+#define is_gate_vma(vma)	((vma) = &gate_vma)
+#else
+#define is_gate_vma(vma)	0
+#endif
 
 const char *arch_vma_name(struct vm_area_struct *vma)
 {
-	return (vma == &gate_vma) ? "[vectors]" :
+	return is_gate_vma(vma) ? "[vectors]" :
 		(vma->vm_mm && vma->vm_start == vma->vm_mm->context.sigpage) ?
 		 "[sigpage]" : NULL;
 }

commit 48be69a026b2c17350a5ef18a1959a919f60be7d
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Jul 24 00:29:18 2013 +0100

    ARM: move signal handlers into a vdso-like page
    
    Move the signal handlers into a VDSO page rather than keeping them in
    the vectors page.  This allows us to place them randomly within this
    page, and also map the page at a random location within userspace
    further protecting these code fragments from ROP attacks.  The new
    VDSO page is also poisoned in the same way as the vector page.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index d3ca4f6915af..566d0d71a1e7 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -428,8 +428,8 @@ unsigned long arch_randomize_brk(struct mm_struct *mm)
 #ifdef CONFIG_MMU
 /*
  * The vectors page is always readable from user space for the
- * atomic helpers and the signal restart code. Insert it into the
- * gate_vma so that it is visible through ptrace and /proc/<pid>/mem.
+ * atomic helpers. Insert it into the gate_vma so that it is visible
+ * through ptrace and /proc/<pid>/mem.
  */
 static struct vm_area_struct gate_vma = {
 	.vm_start	= 0xffff0000,
@@ -461,6 +461,40 @@ int in_gate_area_no_mm(unsigned long addr)
 
 const char *arch_vma_name(struct vm_area_struct *vma)
 {
-	return (vma == &gate_vma) ? "[vectors]" : NULL;
+	return (vma == &gate_vma) ? "[vectors]" :
+		(vma->vm_mm && vma->vm_start == vma->vm_mm->context.sigpage) ?
+		 "[sigpage]" : NULL;
+}
+
+extern struct page *get_signal_page(void);
+
+int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
+{
+	struct mm_struct *mm = current->mm;
+	struct page *page;
+	unsigned long addr;
+	int ret;
+
+	page = get_signal_page();
+	if (!page)
+		return -ENOMEM;
+
+	down_write(&mm->mmap_sem);
+	addr = get_unmapped_area(NULL, 0, PAGE_SIZE, 0, 0);
+	if (IS_ERR_VALUE(addr)) {
+		ret = addr;
+		goto up_fail;
+	}
+
+	ret = install_special_mapping(mm, addr, PAGE_SIZE,
+		VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC,
+		&page);
+
+	if (ret == 0)
+		mm->context.sigpage = addr;
+
+ up_fail:
+	up_write(&mm->mmap_sem);
+	return ret;
 }
 #endif

commit 1b3a5d02ee070c8f9943333b9b6370f486601e0f
Author: Robin Holt <holt@sgi.com>
Date:   Mon Jul 8 16:01:42 2013 -0700

    reboot: move arch/x86 reboot= handling to generic kernel
    
    Merge together the unicore32, arm, and x86 reboot= command line
    parameter handling.
    
    Signed-off-by: Robin Holt <holt@sgi.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Cc: Russ Anderson <rja@sgi.com>
    Cc: Robin Holt <holt@sgi.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index b7fdd864c839..d3ca4f6915af 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -176,16 +176,6 @@ void arch_cpu_idle(void)
 		default_idle();
 }
 
-enum reboot_mode reboot_mode = REBOOT_HARD;
-
-static int __init reboot_setup(char *str)
-{
-	if ('s' == str[0])
-		reboot_mode = REBOOT_SOFT;
-	return 1;
-}
-__setup("reboot=", reboot_setup);
-
 /*
  * Called by kexec, immediately prior to machine_kexec().
  *

commit 7b6d864b48d95e6ea1df7df64475b9cb9616dcf9
Author: Robin Holt <holt@sgi.com>
Date:   Mon Jul 8 16:01:40 2013 -0700

    reboot: arm: change reboot_mode to use enum reboot_mode
    
    Preparing to move the parsing of reboot= to generic kernel code forces
    the change in reboot_mode handling to use the enum.
    
    [akpm@linux-foundation.org: fix arch/arm/mach-socfpga/socfpga.c]
    Signed-off-by: Robin Holt <holt@sgi.com>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Russ Anderson <rja@sgi.com>
    Cc: Robin Holt <holt@sgi.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 2d544062fd7d..b7fdd864c839 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -32,6 +32,7 @@
 #include <linux/hw_breakpoint.h>
 #include <linux/cpuidle.h>
 #include <linux/leds.h>
+#include <linux/reboot.h>
 
 #include <asm/cacheflush.h>
 #include <asm/idmap.h>
@@ -113,7 +114,7 @@ void soft_restart(unsigned long addr)
 	BUG();
 }
 
-static void null_restart(char mode, const char *cmd)
+static void null_restart(enum reboot_mode reboot_mode, const char *cmd)
 {
 }
 
@@ -123,7 +124,7 @@ static void null_restart(char mode, const char *cmd)
 void (*pm_power_off)(void);
 EXPORT_SYMBOL(pm_power_off);
 
-void (*arm_pm_restart)(char str, const char *cmd) = null_restart;
+void (*arm_pm_restart)(enum reboot_mode reboot_mode, const char *cmd) = null_restart;
 EXPORT_SYMBOL_GPL(arm_pm_restart);
 
 /*

commit 16d6d5b00ee75307bab7e4ede9452c97b28f30e2
Author: Robin Holt <holt@sgi.com>
Date:   Mon Jul 8 16:01:39 2013 -0700

    reboot: arm: prepare reboot_mode for moving to generic kernel code
    
    Prepare for the moving the parsing of reboot= to the generic kernel code
    by making reboot_mode into a more generic form.
    
    Signed-off-by: Robin Holt <holt@sgi.com>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Russ Anderson <rja@sgi.com>
    Cc: Robin Holt <holt@sgi.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 7f1efcd4a6e9..2d544062fd7d 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -175,14 +175,14 @@ void arch_cpu_idle(void)
 		default_idle();
 }
 
-static char reboot_mode = 'h';
+enum reboot_mode reboot_mode = REBOOT_HARD;
 
-int __init reboot_setup(char *str)
+static int __init reboot_setup(char *str)
 {
-	reboot_mode = str[0];
+	if ('s' == str[0])
+		reboot_mode = REBOOT_SOFT;
 	return 1;
 }
-
 __setup("reboot=", reboot_setup);
 
 /*

commit cbd379b10019617457bda31eb243890f4377fa3e
Merge: 3e0a07f8c401 6c93dd438aad 1b21376a737a 012596200077
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jun 29 11:43:28 2013 +0100

    Merge branches 'fixes', 'mcpm', 'misc' and 'mmci' into for-next

commit a4780adeefd042482f624f5e0d577bf9cdcbb760
Author: André Hentschel <nerv@dawncrow.de>
Date:   Tue Jun 18 23:23:26 2013 +0100

    ARM: 7735/2: Preserve the user r/w register TPIDRURW on context switch and fork
    
    Since commit 6a1c53124aa1 the user writeable TLS register was zeroed to
    prevent it from being used as a covert channel between two tasks.
    
    There are more and more applications coming to Windows RT,
    Wine could support them, but mostly they expect to have
    the thread environment block (TEB) in TPIDRURW.
    
    This patch preserves that register per thread instead of clearing it.
    Unlike the TPIDRURO, which is already switched, the TPIDRURW
    can be updated from userspace so needs careful treatment in the case that we
    modify TPIDRURW and call fork(). To avoid this we must always read
    TPIDRURW in copy_thread.
    
    Signed-off-by: André Hentschel <nerv@dawncrow.de>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Jonathan Austin <jonathan.austin@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index f21970316836..087064148ebf 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -39,6 +39,7 @@
 #include <asm/thread_notify.h>
 #include <asm/stacktrace.h>
 #include <asm/mach/time.h>
+#include <asm/tls.h>
 
 #ifdef CONFIG_CC_STACKPROTECTOR
 #include <linux/stackprotector.h>
@@ -343,7 +344,8 @@ copy_thread(unsigned long clone_flags, unsigned long stack_start,
 	clear_ptrace_hw_breakpoint(p);
 
 	if (clone_flags & CLONE_SETTLS)
-		thread->tp_value = childregs->ARM_r3;
+		thread->tp_value[0] = childregs->ARM_r3;
+	thread->tp_value[1] = get_tpuser();
 
 	thread_notify(THREAD_NOTIFY_COPY, thread);
 

commit 19ab428f4b7988ef3ac727c680efc193ef53ce14
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Jun 14 16:14:14 2013 +0100

    ARM: 7759/1: decouple CPU offlining from reboot/shutdown
    
    Add comments to machine_shutdown()/halt()/power_off()/restart() that
    describe their purpose and/or requirements re: CPUs being active/not.
    
    In machine_shutdown(), replace the call to smp_send_stop() with a call to
    disable_nonboot_cpus(). This completely disables all but one CPU, thus
    satisfying the requirement that only a single CPU be active for kexec.
    Adjust Kconfig dependencies for this change.
    
    In machine_halt()/power_off()/restart(), call smp_send_stop() directly,
    rather than via machine_shutdown(); these functions don't need to
    completely de-activate all CPUs using hotplug, but rather just quiesce
    them.
    
    Remove smp_kill_cpus(), and its call from smp_send_stop().
    smp_kill_cpus() was indirectly calling smp_ops.cpu_kill() without calling
    smp_ops.cpu_die() on the target CPUs first. At least some implementations
    of smp_ops had issues with this; it caused cpu_kill() to hang on Tegra,
    for example. Since smp_send_stop() is only used for shutdown, halt, and
    power-off, there is no need to attempt any kind of CPU hotplug here.
    
    Adjust Kconfig to reflect that machine_shutdown() (and hence kexec)
    relies upon disable_nonboot_cpus(). However, this alone doesn't guarantee
    that hotplug will work, or even that hotplug is implemented for a
    particular piece of HW that a multi-platform zImage runs on. Hence, add
    error-checking to machine_kexec() to determine whether it did work.
    
    Suggested-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Tested-by:  Zhangfei Gao <zhangfei.gao@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 282de4826abb..6e8931ccf13e 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -184,30 +184,61 @@ int __init reboot_setup(char *str)
 
 __setup("reboot=", reboot_setup);
 
+/*
+ * Called by kexec, immediately prior to machine_kexec().
+ *
+ * This must completely disable all secondary CPUs; simply causing those CPUs
+ * to execute e.g. a RAM-based pin loop is not sufficient. This allows the
+ * kexec'd kernel to use any and all RAM as it sees fit, without having to
+ * avoid any code or data used by any SW CPU pin loop. The CPU hotplug
+ * functionality embodied in disable_nonboot_cpus() to achieve this.
+ */
 void machine_shutdown(void)
 {
-#ifdef CONFIG_SMP
-	smp_send_stop();
-#endif
+	disable_nonboot_cpus();
 }
 
+/*
+ * Halting simply requires that the secondary CPUs stop performing any
+ * activity (executing tasks, handling interrupts). smp_send_stop()
+ * achieves this.
+ */
 void machine_halt(void)
 {
-	machine_shutdown();
+	smp_send_stop();
+
 	local_irq_disable();
 	while (1);
 }
 
+/*
+ * Power-off simply requires that the secondary CPUs stop performing any
+ * activity (executing tasks, handling interrupts). smp_send_stop()
+ * achieves this. When the system power is turned off, it will take all CPUs
+ * with it.
+ */
 void machine_power_off(void)
 {
-	machine_shutdown();
+	smp_send_stop();
+
 	if (pm_power_off)
 		pm_power_off();
 }
 
+/*
+ * Restart requires that the secondary CPUs stop performing any activity
+ * while the primary CPU resets the system. Systems with a single CPU can
+ * use soft_restart() as their machine descriptor's .restart hook, since that
+ * will cause the only available CPU to reset. Systems with multiple CPUs must
+ * provide a HW restart implementation, to ensure that all CPUs reset at once.
+ * This is required so that any code running after reset on the primary CPU
+ * doesn't have to co-ordinate with other CPUs to ensure they aren't still
+ * executing pre-reset code, and using RAM that the primary CPU's code wishes
+ * to use. Implementing such co-ordination would be essentially impossible.
+ */
 void machine_restart(char *cmd)
 {
-	machine_shutdown();
+	smp_send_stop();
 
 	arm_pm_restart(reboot_mode, cmd);
 

commit 4ca46c5e1f38e32c90247686e9e17dae213ecbdb
Author: Steven Capper <steve.capper@linaro.org>
Date:   Thu May 16 17:16:11 2013 +0100

    ARM: 7727/1: remove the .vm_mm value from gate_vma
    
    If one reads /proc/$PID/smaps, the mmap_sem belonging to the
    address space of the task being examined is locked for reading.
    All the pages of the vmas belonging to the task's address space
    are then walked with this lock held.
    
    If a gate_vma is present in the architecture, it too is examined
    by the fs/proc/task_mmu.c code. As gate_vma doesn't belong to the
    address space of the task though, its pages are not walked.
    
    A recent cleanup (commit f6604efe) of the gate_vma initialisation
    code set the vm_mm value to &init_mm. Unfortunately a non-NULL
    vm_mm value in the gate_vma will cause the task_mmu code to attempt
    to walk the pages of the gate_vma (with no mmap-sem lock held). If
    one enables Transparent Huge Page support and vm debugging, this
    will then cause OOPses as pmd_trans_huge_lock is called without
    mmap_sem being locked.
    
    This patch removes the .vm_mm value from gate_vma, restoring the
    original behaviour of the task_mmu code.
    
    Signed-off-by: Steve Capper <steve.capper@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index f21970316836..282de4826abb 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -411,7 +411,6 @@ static struct vm_area_struct gate_vma = {
 	.vm_start	= 0xffff0000,
 	.vm_end		= 0xffff0000 + PAGE_SIZE,
 	.vm_flags	= VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC,
-	.vm_mm		= &init_mm,
 };
 
 static int __init gate_vma_init(void)

commit 8546dc1d4b671480961c3eaf4c0c102ae6848340
Merge: 9992ba72327f 33b9f582c5c1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 3 09:13:19 2013 -0700

    Merge branch 'for-linus' of git://git.linaro.org/people/rmk/linux-arm
    
    Pull ARM updates from Russell King:
     "The major items included in here are:
    
       - MCPM, multi-cluster power management, part of the infrastructure
         required for ARMs big.LITTLE support.
    
       - A rework of the ARM KVM code to allow re-use by ARM64.
    
       - Error handling cleanups of the IS_ERR_OR_NULL() madness and fixes
         of that stuff for arch/arm
    
       - Preparatory patches for Cortex-M3 support from Uwe Kleine-König.
    
      There is also a set of three patches in here from Hugh/Catalin to
      address freeing of inappropriate page tables on LPAE.  You already
      have these from akpm, but they were already part of my tree at the
      time he sent them, so unfortunately they'll end up with duplicate
      commits"
    
    * 'for-linus' of git://git.linaro.org/people/rmk/linux-arm: (77 commits)
      ARM: EXYNOS: remove unnecessary use of IS_ERR_VALUE()
      ARM: IMX: remove unnecessary use of IS_ERR_VALUE()
      ARM: OMAP: use consistent error checking
      ARM: cleanup: OMAP hwmod error checking
      ARM: 7709/1: mcpm: Add explicit AFLAGS to support v6/v7 multiplatform kernels
      ARM: 7700/2: Make cpu_init() notrace
      ARM: 7702/1: Set the page table freeing ceiling to TASK_SIZE
      ARM: 7701/1: mm: Allow arch code to control the user page table ceiling
      ARM: 7703/1: Disable preemption in broadcast_tlb*_a15_erratum()
      ARM: mcpm: provide an interface to set the SMP ops at run time
      ARM: mcpm: generic SMP secondary bringup and hotplug support
      ARM: mcpm_head.S: vlock-based first man election
      ARM: mcpm: Add baremetal voting mutexes
      ARM: mcpm: introduce helpers for platform coherency exit/setup
      ARM: mcpm: introduce the CPU/cluster power API
      ARM: multi-cluster PM: secondary kernel entry code
      ARM: cacheflush: add synchronization helpers for mixed cache state accesses
      ARM: cpu hotplug: remove majority of cache flushing from platforms
      ARM: smp: flush L1 cache in cpu_die()
      ARM: tegra: remove tegra specific cpu_disable()
      ...

commit 33b9f582c5c1db515412cc7efff28f7d1779321f
Merge: 946342d03ec4 008ca431822f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu May 2 21:31:29 2013 +0100

    Merge branch 'cleanup' into for-linus
    
    Conflicts:
            arch/arm/plat-omap/dmtimer.c

commit a43cb95d547a061ed5bf1acb28e0f5fd575e26c1
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Apr 30 15:27:17 2013 -0700

    dump_stack: unify debug information printed by show_regs()
    
    show_regs() is inherently arch-dependent but it does make sense to print
    generic debug information and some archs already do albeit in slightly
    different forms.  This patch introduces a generic function to print debug
    information from show_regs() so that different archs print out the same
    information and it's much easier to modify what's printed.
    
    show_regs_print_info() prints out the same debug info as dump_stack()
    does plus task and thread_info pointers.
    
    * Archs which didn't print debug info now do.
    
      alpha, arc, blackfin, c6x, cris, frv, h8300, hexagon, ia64, m32r,
      metag, microblaze, mn10300, openrisc, parisc, score, sh64, sparc,
      um, xtensa
    
    * Already prints debug info.  Replaced with show_regs_print_info().
      The printed information is superset of what used to be there.
    
      arm, arm64, avr32, mips, powerpc, sh32, tile, unicore32, x86
    
    * s390 is special in that it used to print arch-specific information
      along with generic debug info.  Heiko and Martin think that the
      arch-specific extra isn't worth keeping s390 specfic implementation.
      Converted to use the generic version.
    
    Note that now all archs print the debug info before actual register
    dumps.
    
    An example BUG() dump follows.
    
     kernel BUG at /work/os/work/kernel/workqueue.c:4841!
     invalid opcode: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC
     Modules linked in:
     CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.9.0-rc1-work+ #7
     Hardware name: empty empty/S3992, BIOS 080011  10/26/2007
     task: ffff88007c85e040 ti: ffff88007c860000 task.ti: ffff88007c860000
     RIP: 0010:[<ffffffff8234a07e>]  [<ffffffff8234a07e>] init_workqueues+0x4/0x6
     RSP: 0000:ffff88007c861ec8  EFLAGS: 00010246
     RAX: ffff88007c861fd8 RBX: ffffffff824466a8 RCX: 0000000000000001
     RDX: 0000000000000046 RSI: 0000000000000001 RDI: ffffffff8234a07a
     RBP: ffff88007c861ec8 R08: 0000000000000000 R09: 0000000000000000
     R10: 0000000000000001 R11: 0000000000000000 R12: ffffffff8234a07a
     R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000
     FS:  0000000000000000(0000) GS:ffff88007dc00000(0000) knlGS:0000000000000000
     CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
     CR2: ffff88015f7ff000 CR3: 00000000021f1000 CR4: 00000000000007f0
     DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
     DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
     Stack:
      ffff88007c861ef8 ffffffff81000312 ffffffff824466a8 ffff88007c85e650
      0000000000000003 0000000000000000 ffff88007c861f38 ffffffff82335e5d
      ffff88007c862080 ffffffff8223d8c0 ffff88007c862080 ffffffff81c47760
     Call Trace:
      [<ffffffff81000312>] do_one_initcall+0x122/0x170
      [<ffffffff82335e5d>] kernel_init_freeable+0x9b/0x1c8
      [<ffffffff81c47760>] ? rest_init+0x140/0x140
      [<ffffffff81c4776e>] kernel_init+0xe/0xf0
      [<ffffffff81c6be9c>] ret_from_fork+0x7c/0xb0
      [<ffffffff81c47760>] ? rest_init+0x140/0x140
      ...
    
    v2: Typo fix in x86-32.
    
    v3: CPU number dropped from show_regs_print_info() as
        dump_stack_print_info() has been updated to print it.  s390
        specific implementation dropped as requested by s390 maintainers.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: David S. Miller <davem@davemloft.net>
    Acked-by: Jesper Nilsson <jesper.nilsson@axis.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Fengguang Wu <fengguang.wu@intel.com>
    Cc: Mike Frysinger <vapier@gentoo.org>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Acked-by: Chris Metcalf <cmetcalf@tilera.com>           [tile bits]
    Acked-by: Richard Kuo <rkuo@codeaurora.org>             [hexagon bits]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index c9a5e2ce8aa9..ae58d3b37d9d 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -225,11 +225,8 @@ void __show_regs(struct pt_regs *regs)
 	unsigned long flags;
 	char buf[64];
 
-	printk("CPU: %d    %s  (%s %.*s)\n",
-		raw_smp_processor_id(), print_tainted(),
-		init_utsname()->release,
-		(int)strcspn(init_utsname()->version, " "),
-		init_utsname()->version);
+	show_regs_print_info(KERN_DEFAULT);
+
 	print_symbol("PC is at %s\n", instruction_pointer(regs));
 	print_symbol("LR is at %s\n", regs->ARM_lr);
 	printk("pc : [<%08lx>]    lr : [<%08lx>]    psr: %08lx\n"
@@ -284,7 +281,6 @@ void __show_regs(struct pt_regs *regs)
 void show_regs(struct pt_regs * regs)
 {
 	printk("\n");
-	printk("Pid: %d, comm: %20s\n", task_pid_nr(current), current->comm);
 	__show_regs(regs);
 	dump_stack();
 }

commit f7b861b7a6d9d1838cbbb5f4053e61578b86d134
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 21 22:49:38 2013 +0100

    arm: Use generic idle loop
    
    Use the generic idle loop and replace enable/disable_hlt with the
    respective core functions.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Paul McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Reviewed-by: Cc: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Tested-by: Kevin Hilman <khilman@linaro.org> # OMAP
    Link: http://lkml.kernel.org/r/20130321215233.826238797@linutronix.de

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 92884c86189d..c9a5e2ce8aa9 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -57,34 +57,6 @@ static const char *isa_modes[] = {
   "ARM" , "Thumb" , "Jazelle", "ThumbEE"
 };
 
-static volatile int hlt_counter;
-
-void disable_hlt(void)
-{
-	hlt_counter++;
-}
-
-void enable_hlt(void)
-{
-	hlt_counter--;
-	BUG_ON(hlt_counter < 0);
-}
-
-static int __init nohlt_setup(char *__unused)
-{
-	hlt_counter = 1;
-	return 1;
-}
-
-static int __init hlt_setup(char *__unused)
-{
-	hlt_counter = 0;
-	return 1;
-}
-
-__setup("nohlt", nohlt_setup);
-__setup("hlt", hlt_setup);
-
 extern void call_with_stack(void (*fn)(void *), void *arg, void *sp);
 typedef void (*phys_reset_t)(unsigned long);
 
@@ -168,54 +140,38 @@ static void default_idle(void)
 	local_irq_enable();
 }
 
-/*
- * The idle thread.
- * We always respect 'hlt_counter' to prevent low power idle.
- */
-void cpu_idle(void)
+void arch_cpu_idle_prepare(void)
 {
 	local_fiq_enable();
+}
 
-	/* endless idle loop with no priority at all */
-	while (1) {
-		tick_nohz_idle_enter();
-		rcu_idle_enter();
-		ledtrig_cpu(CPU_LED_IDLE_START);
-		while (!need_resched()) {
-#ifdef CONFIG_HOTPLUG_CPU
-			if (cpu_is_offline(smp_processor_id()))
-				cpu_die();
+void arch_cpu_idle_enter(void)
+{
+	ledtrig_cpu(CPU_LED_IDLE_START);
+#ifdef CONFIG_PL310_ERRATA_769419
+	wmb();
 #endif
+}
 
-			/*
-			 * We need to disable interrupts here
-			 * to ensure we don't miss a wakeup call.
-			 */
-			local_irq_disable();
-#ifdef CONFIG_PL310_ERRATA_769419
-			wmb();
+void arch_cpu_idle_exit(void)
+{
+	ledtrig_cpu(CPU_LED_IDLE_END);
+}
+
+#ifdef CONFIG_HOTPLUG_CPU
+void arch_cpu_idle_dead(void)
+{
+	cpu_die();
+}
 #endif
-			if (hlt_counter) {
-				local_irq_enable();
-				cpu_relax();
-			} else if (!need_resched()) {
-				stop_critical_timings();
-				if (cpuidle_idle_call())
-					default_idle();
-				start_critical_timings();
-				/*
-				 * default_idle functions must always
-				 * return with IRQs enabled.
-				 */
-				WARN_ON(irqs_disabled());
-			} else
-				local_irq_enable();
-		}
-		ledtrig_cpu(CPU_LED_IDLE_END);
-		rcu_idle_exit();
-		tick_nohz_idle_exit();
-		schedule_preempt_disabled();
-	}
+
+/*
+ * Called from the core idle loop.
+ */
+void arch_cpu_idle(void)
+{
+	if (cpuidle_idle_call())
+		default_idle();
 }
 
 static char reboot_mode = 'h';

commit 6546327ad187238ac63d2429701b32becb096fd8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 21 22:49:31 2013 +0100

    arch: Cleanup enable/disable_hlt
    
    enable/disable_hlt() does not need to be exported and can be killed on
    architectures which do not use it at all.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Paul McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Reviewed-by: Cc: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Link: http://lkml.kernel.org/r/20130321215233.377959540@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 047d3e40e470..92884c86189d 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -64,16 +64,12 @@ void disable_hlt(void)
 	hlt_counter++;
 }
 
-EXPORT_SYMBOL(disable_hlt);
-
 void enable_hlt(void)
 {
 	hlt_counter--;
 	BUG_ON(hlt_counter < 0);
 }
 
-EXPORT_SYMBOL(enable_hlt);
-
 static int __init nohlt_setup(char *__unused)
 {
 	hlt_counter = 1;

commit f6604efe0bee759f4db34757f2872b611288ef0f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Feb 23 17:55:39 2013 +0000

    ARM: cleanup gate_vma initialization
    
    Three's no need to have code initializing this by hand; it's more
    efficient to initialize the constant structure members directly.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index c6dec5fc20aa..9397069af175 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -464,15 +464,16 @@ unsigned long arch_randomize_brk(struct mm_struct *mm)
  * atomic helpers and the signal restart code. Insert it into the
  * gate_vma so that it is visible through ptrace and /proc/<pid>/mem.
  */
-static struct vm_area_struct gate_vma;
+static struct vm_area_struct gate_vma = {
+	.vm_start	= 0xffff0000,
+	.vm_end		= 0xffff0000 + PAGE_SIZE,
+	.vm_flags	= VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC,
+	.vm_mm		= &init_mm,
+};
 
 static int __init gate_vma_init(void)
 {
-	gate_vma.vm_start	= 0xffff0000;
-	gate_vma.vm_end		= 0xffff0000 + PAGE_SIZE;
-	gate_vma.vm_page_prot	= PAGE_READONLY_EXEC;
-	gate_vma.vm_flags	= VM_READ | VM_EXEC |
-				  VM_MAYREAD | VM_MAYEXEC;
+	gate_vma.vm_page_prot = PAGE_READONLY_EXEC;
 	return 0;
 }
 arch_initcall(gate_vma_init);

commit b0ea11497c8cbc5a66019814efa1733e47e47ab1
Author: Len Brown <len.brown@intel.com>
Date:   Sat Feb 9 22:22:38 2013 -0500

    ARM idle: delete pm_idle
    
    pm_idle() on ARM was a synonym for default_idle(),
    so simply invoke default_idle() directly.
    
    Signed-off-by: Len Brown <len.brown@intel.com>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Tested-by: Kevin Hilman <khilman@linaro.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index c6dec5fc20aa..047d3e40e470 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -172,14 +172,9 @@ static void default_idle(void)
 	local_irq_enable();
 }
 
-void (*pm_idle)(void) = default_idle;
-EXPORT_SYMBOL(pm_idle);
-
 /*
- * The idle thread, has rather strange semantics for calling pm_idle,
- * but this is what x86 does and we need to do the same, so that
- * things like cpuidle get called in the same way.  The only difference
- * is that we always respect 'hlt_counter' to prevent low power idle.
+ * The idle thread.
+ * We always respect 'hlt_counter' to prevent low power idle.
  */
 void cpu_idle(void)
 {
@@ -210,10 +205,10 @@ void cpu_idle(void)
 			} else if (!need_resched()) {
 				stop_critical_timings();
 				if (cpuidle_idle_call())
-					pm_idle();
+					default_idle();
 				start_critical_timings();
 				/*
-				 * pm_idle functions must always
+				 * default_idle functions must always
 				 * return with IRQs enabled.
 				 */
 				WARN_ON(irqs_disabled());

commit 9977d9b379cb77e0f67bd6f4563618106e58e11d
Merge: cf4af0122157 541880d9a2c7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 12 12:22:13 2012 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/signal
    
    Pull big execve/kernel_thread/fork unification series from Al Viro:
     "All architectures are converted to new model.  Quite a bit of that
      stuff is actually shared with architecture trees; in such cases it's
      literally shared branch pulled by both, not a cherry-pick.
    
      A lot of ugliness and black magic is gone (-3KLoC total in this one):
    
       - kernel_thread()/kernel_execve()/sys_execve() redesign.
    
         We don't do syscalls from kernel anymore for either kernel_thread()
         or kernel_execve():
    
         kernel_thread() is essentially clone(2) with callback run before we
         return to userland, the callbacks either never return or do
         successful do_execve() before returning.
    
         kernel_execve() is a wrapper for do_execve() - it doesn't need to
         do transition to user mode anymore.
    
         As a result kernel_thread() and kernel_execve() are
         arch-independent now - they live in kernel/fork.c and fs/exec.c
         resp.  sys_execve() is also in fs/exec.c and it's completely
         architecture-independent.
    
       - daemonize() is gone, along with its parts in fs/*.c
    
       - struct pt_regs * is no longer passed to do_fork/copy_process/
         copy_thread/do_execve/search_binary_handler/->load_binary/do_coredump.
    
       - sys_fork()/sys_vfork()/sys_clone() unified; some architectures
         still need wrappers (ones with callee-saved registers not saved in
         pt_regs on syscall entry), but the main part of those suckers is in
         kernel/fork.c now."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/signal: (113 commits)
      do_coredump(): get rid of pt_regs argument
      print_fatal_signal(): get rid of pt_regs argument
      ptrace_signal(): get rid of unused arguments
      get rid of ptrace_signal_deliver() arguments
      new helper: signal_pt_regs()
      unify default ptrace_signal_deliver
      flagday: kill pt_regs argument of do_fork()
      death to idle_regs()
      don't pass regs to copy_process()
      flagday: don't pass regs to copy_thread()
      bfin: switch to generic vfork, get rid of pointless wrappers
      xtensa: switch to generic clone()
      openrisc: switch to use of generic fork and clone
      unicore32: switch to generic clone(2)
      score: switch to generic fork/vfork/clone
      c6x: sanitize copy_thread(), get rid of clone(2) wrapper, switch to generic clone()
      take sys_fork/sys_vfork/sys_clone prototypes to linux/syscalls.h
      mn10300: switch to generic fork/vfork/clone
      h8300: switch to generic fork/vfork/clone
      tile: switch to generic clone()
      ...
    
    Conflicts:
            arch/microblaze/include/asm/Kbuild

commit afa86fc426ff7e7f5477f15da9c405d08d5cf790
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Oct 22 22:51:14 2012 -0400

    flagday: don't pass regs to copy_thread()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 4ab80bbb6d95..9800338c5d1b 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -376,7 +376,7 @@ asmlinkage void ret_from_fork(void) __asm__("ret_from_fork");
 
 int
 copy_thread(unsigned long clone_flags, unsigned long stack_start,
-	    unsigned long stk_sz, struct task_struct *p, struct pt_regs *unused)
+	    unsigned long stk_sz, struct task_struct *p)
 {
 	struct thread_info *thread = task_thread_info(p);
 	struct pt_regs *childregs = task_pt_regs(p);

commit 38a61b6b4a45ec8c82c75403848e1c579113c3c5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Oct 21 15:54:27 2012 -0400

    arm: switch to generic fork/vfork/clone
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 90084a6de35a..4ab80bbb6d95 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -376,17 +376,18 @@ asmlinkage void ret_from_fork(void) __asm__("ret_from_fork");
 
 int
 copy_thread(unsigned long clone_flags, unsigned long stack_start,
-	    unsigned long stk_sz, struct task_struct *p, struct pt_regs *regs)
+	    unsigned long stk_sz, struct task_struct *p, struct pt_regs *unused)
 {
 	struct thread_info *thread = task_thread_info(p);
 	struct pt_regs *childregs = task_pt_regs(p);
 
 	memset(&thread->cpu_context, 0, sizeof(struct cpu_context_save));
 
-	if (likely(regs)) {
-		*childregs = *regs;
+	if (likely(!(p->flags & PF_KTHREAD))) {
+		*childregs = *current_pt_regs();
 		childregs->ARM_r0 = 0;
-		childregs->ARM_sp = stack_start;
+		if (stack_start)
+			childregs->ARM_sp = stack_start;
 	} else {
 		memset(childregs, 0, sizeof(struct pt_regs));
 		thread->cpu_context.r4 = stk_sz;
@@ -399,7 +400,7 @@ copy_thread(unsigned long clone_flags, unsigned long stack_start,
 	clear_ptrace_hw_breakpoint(p);
 
 	if (clone_flags & CLONE_SETTLS)
-		thread->tp_value = regs->ARM_r3;
+		thread->tp_value = childregs->ARM_r3;
 
 	thread_notify(THREAD_NOTIFY_COPY, thread);
 

commit 9ecb47de3490b8f2d4b818568935da9ca2c22398
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Thu Nov 8 19:54:11 2012 +0100

    ARM: 7574/1: kernel/process.c: include idmap.h instead of redeclaring setup_mm_for_reboot()
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 45fd05186a39..44bc0b327e2b 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -34,6 +34,7 @@
 #include <linux/leds.h>
 
 #include <asm/cacheflush.h>
+#include <asm/idmap.h>
 #include <asm/processor.h>
 #include <asm/thread_notify.h>
 #include <asm/stacktrace.h>
@@ -56,8 +57,6 @@ static const char *isa_modes[] = {
   "ARM" , "Thumb" , "Jazelle", "ThumbEE"
 };
 
-extern void setup_mm_for_reboot(void);
-
 static volatile int hlt_counter;
 
 void disable_hlt(void)

commit 871df85a592396b36d4c40b3860e8d7373626552
Author: fwu <fwu@marvell.com>
Date:   Sat Sep 29 04:14:03 2012 +0100

    ARM: 7544/1: Add BUG_ON when hlt counter is wrongly used
    
    1. On ARM platform, "nohlt" can be used to prevent core from idle
       process, returning immediately.
    2. There are two interfaces, exported for other modules, named
       "disable_hlt" and "enable_hlt" are used to enable/disable the
       cpuidle mechanism by increasing/decreasing "hlt_counter".
       Disable_hlt and enable_hlt are paired operation,
       when you first call disable_hlt and then enable_hlt, the
       semantics are right.
    3. There is no obvious constraint to prevent user(driver/module)
       code to prevent the case that enable_hlt is ahead of disable_hlt,
       which is a fatal operation on kernel state change from user,
       and there is no any WARNING or notification if the case happens
       in current kernel code.
       This patch aims to report BUG when the case happens, just like
       what the kernel do when enable_irq is ahead of disable_irq.
    
    Link: https://patchwork.kernel.org/patch/1527881/
    
    Signed-off-by: fwu <fwu@marvell.com>
    Signed-off-by: YiLu Mao <ylmao@marvell.com>
    Signed-off-by: Ning Jiang <ning.jiang@marvell.com>
    Acked-by: Nicolas Pitre
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 90084a6de35a..45fd05186a39 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -70,6 +70,7 @@ EXPORT_SYMBOL(disable_hlt);
 void enable_hlt(void)
 {
 	hlt_counter--;
+	BUG_ON(hlt_counter < 0);
 }
 
 EXPORT_SYMBOL(enable_hlt);

commit 4e21fc138bfd7fe625ff5dc81541399aaf9d429b
Merge: 8418263e3547 5522be6a4624
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 13 10:05:52 2012 +0900

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/signal
    
    Pull third pile of kernel_execve() patches from Al Viro:
     "The last bits of infrastructure for kernel_thread() et.al., with
      alpha/arm/x86 use of those.  Plus sanitizing the asm glue and
      do_notify_resume() on alpha, fixing the "disabled irq while running
      task_work stuff" breakage there.
    
      At that point the rest of kernel_thread/kernel_execve/sys_execve work
      can be done independently for different architectures.  The only
      pending bits that do depend on having all architectures converted are
      restrictred to fs/* and kernel/* - that'll obviously have to wait for
      the next cycle.
    
      I thought we'd have to wait for all of them done before we start
      eliminating the longjump-style insanity in kernel_execve(), but it
      turned out there's a very simple way to do that without flagday-style
      changes."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/signal:
      alpha: switch to saner kernel_execve() semantics
      arm: switch to saner kernel_execve() semantics
      x86, um: convert to saner kernel_execve() semantics
      infrastructure for saner ret_from_kernel_thread semantics
      make sure that kernel_thread() callbacks call do_exit() themselves
      make sure that we always have a return path from kernel_execve()
      ppc: eeh_event should just use kthread_run()
      don't bother with kernel_thread/kernel_execve for launching linuxrc
      alpha: get rid of switch_stack argument of do_work_pending()
      alpha: don't bother passing switch_stack separately from regs
      alpha: take SIGPENDING/NOTIFY_RESUME loop into signal.c
      alpha: simplify TIF_NEED_RESCHED handling

commit 9fff2fa0db911b0b75ec1f9bec72460c0a676ef5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Oct 10 22:23:29 2012 -0400

    arm: switch to saner kernel_execve() semantics
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index c10e4395bc47..0f83fa2e58e3 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -373,7 +373,6 @@ void release_thread(struct task_struct *dead_task)
 }
 
 asmlinkage void ret_from_fork(void) __asm__("ret_from_fork");
-asmlinkage void ret_from_kernel_thread(void) __asm__("ret_from_kernel_thread");
 
 int
 copy_thread(unsigned long clone_flags, unsigned long stack_start,
@@ -388,13 +387,13 @@ copy_thread(unsigned long clone_flags, unsigned long stack_start,
 		*childregs = *regs;
 		childregs->ARM_r0 = 0;
 		childregs->ARM_sp = stack_start;
-		thread->cpu_context.pc = (unsigned long)ret_from_fork;
 	} else {
+		memset(childregs, 0, sizeof(struct pt_regs));
 		thread->cpu_context.r4 = stk_sz;
 		thread->cpu_context.r5 = stack_start;
-		thread->cpu_context.pc = (unsigned long)ret_from_kernel_thread;
 		childregs->ARM_cpsr = SVC_MODE;
 	}
+	thread->cpu_context.pc = (unsigned long)ret_from_fork;
 	thread->cpu_context.sp = (unsigned long)childregs;
 
 	clear_ptrace_hw_breakpoint(p);

commit 42859eea96ba6beabfb0369a1eeffa3c7d2bd9cb
Merge: f59b51fe3d30 f322220d6159
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 10 12:02:25 2012 +0900

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/signal
    
    Pull generic execve() changes from Al Viro:
     "This introduces the generic kernel_thread() and kernel_execve()
      functions, and switches x86, arm, alpha, um and s390 over to them."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/signal: (26 commits)
      s390: convert to generic kernel_execve()
      s390: switch to generic kernel_thread()
      s390: fold kernel_thread_helper() into ret_from_fork()
      s390: fold execve_tail() into start_thread(), convert to generic sys_execve()
      um: switch to generic kernel_thread()
      x86, um/x86: switch to generic sys_execve and kernel_execve
      x86: split ret_from_fork
      alpha: introduce ret_from_kernel_execve(), switch to generic kernel_execve()
      alpha: switch to generic kernel_thread()
      alpha: switch to generic sys_execve()
      arm: get rid of execve wrapper, switch to generic execve() implementation
      arm: optimized current_pt_regs()
      arm: introduce ret_from_kernel_execve(), switch to generic kernel_execve()
      arm: split ret_from_fork, simplify kernel_thread() [based on patch by rmk]
      generic sys_execve()
      generic kernel_execve()
      new helper: current_pt_regs()
      preparation for generic kernel_thread()
      um: kill thread->forking
      um: let signal_delivered() do SIGTRAP on singlestepping into handler
      ...

commit 9e14f828ee4a7a4a98703e380d180717a579fb35
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Sep 9 21:31:07 2012 -0400

    arm: split ret_from_fork, simplify kernel_thread() [based on patch by rmk]
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 693b744fd572..c10e4395bc47 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -373,6 +373,7 @@ void release_thread(struct task_struct *dead_task)
 }
 
 asmlinkage void ret_from_fork(void) __asm__("ret_from_fork");
+asmlinkage void ret_from_kernel_thread(void) __asm__("ret_from_kernel_thread");
 
 int
 copy_thread(unsigned long clone_flags, unsigned long stack_start,
@@ -381,13 +382,20 @@ copy_thread(unsigned long clone_flags, unsigned long stack_start,
 	struct thread_info *thread = task_thread_info(p);
 	struct pt_regs *childregs = task_pt_regs(p);
 
-	*childregs = *regs;
-	childregs->ARM_r0 = 0;
-	childregs->ARM_sp = stack_start;
-
 	memset(&thread->cpu_context, 0, sizeof(struct cpu_context_save));
+
+	if (likely(regs)) {
+		*childregs = *regs;
+		childregs->ARM_r0 = 0;
+		childregs->ARM_sp = stack_start;
+		thread->cpu_context.pc = (unsigned long)ret_from_fork;
+	} else {
+		thread->cpu_context.r4 = stk_sz;
+		thread->cpu_context.r5 = stack_start;
+		thread->cpu_context.pc = (unsigned long)ret_from_kernel_thread;
+		childregs->ARM_cpsr = SVC_MODE;
+	}
 	thread->cpu_context.sp = (unsigned long)childregs;
-	thread->cpu_context.pc = (unsigned long)ret_from_fork;
 
 	clear_ptrace_hw_breakpoint(p);
 
@@ -423,63 +431,6 @@ int dump_fpu (struct pt_regs *regs, struct user_fp *fp)
 }
 EXPORT_SYMBOL(dump_fpu);
 
-/*
- * Shuffle the argument into the correct register before calling the
- * thread function.  r4 is the thread argument, r5 is the pointer to
- * the thread function, and r6 points to the exit function.
- */
-extern void kernel_thread_helper(void);
-asm(	".pushsection .text\n"
-"	.align\n"
-"	.type	kernel_thread_helper, #function\n"
-"kernel_thread_helper:\n"
-#ifdef CONFIG_TRACE_IRQFLAGS
-"	bl	trace_hardirqs_on\n"
-#endif
-"	msr	cpsr_c, r7\n"
-"	mov	r0, r4\n"
-"	mov	lr, r6\n"
-"	mov	pc, r5\n"
-"	.size	kernel_thread_helper, . - kernel_thread_helper\n"
-"	.popsection");
-
-#ifdef CONFIG_ARM_UNWIND
-extern void kernel_thread_exit(long code);
-asm(	".pushsection .text\n"
-"	.align\n"
-"	.type	kernel_thread_exit, #function\n"
-"kernel_thread_exit:\n"
-"	.fnstart\n"
-"	.cantunwind\n"
-"	bl	do_exit\n"
-"	nop\n"
-"	.fnend\n"
-"	.size	kernel_thread_exit, . - kernel_thread_exit\n"
-"	.popsection");
-#else
-#define kernel_thread_exit	do_exit
-#endif
-
-/*
- * Create a kernel thread.
- */
-pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
-{
-	struct pt_regs regs;
-
-	memset(&regs, 0, sizeof(regs));
-
-	regs.ARM_r4 = (unsigned long)arg;
-	regs.ARM_r5 = (unsigned long)fn;
-	regs.ARM_r6 = (unsigned long)kernel_thread_exit;
-	regs.ARM_r7 = SVC_MODE | PSR_ENDSTATE | PSR_ISETSTATE;
-	regs.ARM_pc = (unsigned long)kernel_thread_helper;
-	regs.ARM_cpsr = regs.ARM_r7 | PSR_I_BIT;
-
-	return do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
-}
-EXPORT_SYMBOL(kernel_thread);
-
 unsigned long get_wchan(struct task_struct *p)
 {
 	struct stackframe frame;

commit 19e4ab54e7f5fe46a3c931afa7e786f11d57b558
Merge: 0d7614f09c1e fa8bbb13ab49
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Aug 13 16:45:48 2012 +0200

    Merge branch 'for-arm-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/cooloney/linux-leds into next/drivers
    
    From Bryan Wu <bryan.wu@canonical.com>:
    
    Based on Linus Walleij's ARM LED consolidation work, this patchset introduce a
    new generic led trigger for CPU not only for ARM but also for others.
    
    For enabling CPU idle event, CPU arch code should call ledtrig_cpu() stub to
    trigger idle start or idle end event.
    
    These patches convert old style LED driver in arch/arm to gpio_led or new led
    driver interface. Against 3.5 release and build successfully for all the machines.
    
    Test ledtrig-cpu driver on OMAP4 Panda board.
    
    v9 --> v10
     * fix compiling issue on versatile_defconfig reported by Russell King
     * rebase to 3.5 kernel and move patches to new git tree
    
    v8 --> v9:
     * use mutex to replace rw_sema pointed out by Tim Gardner
     * add a new struct led_trigger_cpu
     * add lock_is_inited to record mutex lock initialization
    
    v6 --> v7:
     * add a patch to unify the led-trigger name
     * fix some typo pointed
     * use BUG_ON to detect CPU numbers during building stage
    
    v5 --> v6:
     * replace  __get_cpu_var() to per_cpu()
     * remove smp_processor_id() which is wrong with for_each_possible_cpu()
     * test on real OMAP4 Panda board
     * add comments about CPU hotplug in the CPU LED trigger driver
    
    v4 --> v5:
     * rebase all the patches on top of latest linux-next
     * replace on_each_cpu() with for_each_possible_cpu()
     * add some description of ledtrig_cpu() API
     * remove old leds code from driver nwflash.c, which should use a new led trigger then
     * this trigger driver can be built as module now
    
    v3 --> v4:
     * fix a typo pointed by Jochen Friedrich
     * fix some building errors
     * add Reviewed-by and Tested-by into patch log
    
    v2 --> v3:
     * almost rewrote the whole ledtrig-cpu driver, which is more simple
     * every CPU will have a per-CPU trigger
     * cpu trigger can be assigned to any leds
     * fix a lockdep issue in led-trigger common code
     * other fix according to review
    
    v1 --> v2:
     * remove select operations in Kconfig of every machines
     * add back supporting of led in core module of mach-integrator
     * solidate name scheme in ledtrig-cpu.c
     * add comments of CPU_LED_* cpu led events
     * fold patches of RealView and Versatile together
     * add machine_is_ check during assabet led driver init
     * add some Acked-by in patch logs
     * remove code for simpad machine in machine-sa11000, since Jochen Friedrich
       introduced gpiolib and gpio-led driver for simpad
     * on Assabet and Netwinder machine, LED operations is reversed like:
       setting bit means turn off leds
       clearing bit means turn on leds
     * add a new function to read CM_CTRL register for led driver
    
    * 'for-arm-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/cooloney/linux-leds:
      ARM: use new LEDS CPU trigger stub to replace old one
      ARM: mach-sa1100: retire custom LED code
      ARM: mach-omap1: retire custom LED code
      ARM: mach-pnx4008: remove including old leds event API header file
      ARM: plat-samsung: remove including old leds event API header file
      ARM: mach-pxa: retire custom LED code
      char: nwflash: remove old led event code
      ARM: mach-footbridge: retire custom LED code
      ARM: mach-ebsa110: retire custom LED code
      ARM: mach-clps711x: retire custom LED code of P720T machine
      ARM: mach-integrator: retire custom LED code
      ARM: mach-integrator: move CM_CTRL to header file for accessing by other functions
      ARM: mach-orion5x: convert custom LED code to gpio_led and LED CPU trigger
      ARM: mach-shark: retire custom LED code
      ARM: mach-ks8695: remove leds driver, since nobody use it
      ARM: mach-realview and mach-versatile: retire custom LED code
      ARM: at91: convert old leds drivers to gpio_led and led_trigger drivers
      led-triggers: create a trigger for CPU activity
    
    Conflicts:
            arch/arm/mach-clps711x/p720t.c
            arch/arm/mach-sa1100/leds-cerf.c
            arch/arm/mach-sa1100/leds-lart.c
    
    Let's hope this is the last time we pull this and it doesn't cause
    more trouble. I have verified that version 10 causes no build
    warnings or errors any more, and the patches still look good.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit fa8bbb13ab49e77c00fa09e5504ec25b7176fb4b
Author: Bryan Wu <bryan.wu@canonical.com>
Date:   Wed Mar 14 02:26:56 2012 +0800

    ARM: use new LEDS CPU trigger stub to replace old one
    
    Cc:  Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Bryan Wu <bryan.wu@canonical.com>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 19c95ea65b2f..864580af1678 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -31,9 +31,9 @@
 #include <linux/random.h>
 #include <linux/hw_breakpoint.h>
 #include <linux/cpuidle.h>
+#include <linux/leds.h>
 
 #include <asm/cacheflush.h>
-#include <asm/leds.h>
 #include <asm/processor.h>
 #include <asm/thread_notify.h>
 #include <asm/stacktrace.h>
@@ -189,7 +189,7 @@ void cpu_idle(void)
 	while (1) {
 		tick_nohz_idle_enter();
 		rcu_idle_enter();
-		leds_event(led_idle_start);
+		ledtrig_cpu(CPU_LED_IDLE_START);
 		while (!need_resched()) {
 #ifdef CONFIG_HOTPLUG_CPU
 			if (cpu_is_offline(smp_processor_id()))
@@ -220,7 +220,7 @@ void cpu_idle(void)
 			} else
 				local_irq_enable();
 		}
-		leds_event(led_idle_end);
+		ledtrig_cpu(CPU_LED_IDLE_END);
 		rcu_idle_exit();
 		tick_nohz_idle_exit();
 		schedule_preempt_disabled();

commit 98bd8b96b26db3399a48202318dca4aaa2515355
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Fri Jul 13 08:19:34 2012 +0100

    ARM: 7466/1: disable interrupt before spinning endlessly
    
    The CPU will endlessly spin at the end of machine_halt and
    machine_restart calls.  However, this will lead to a soft lockup
    warning after about 20 seconds, if CONFIG_LOCKUP_DETECTOR is enabled,
    as system timer is still alive.
    
    Disable interrupt before going to spin endlessly, so that the lockup
    warning will never be seen.
    
    Cc: <stable@vger.kernel.org>
    Reported-by: Marek Vasut <marex@denx.de>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 19c95ea65b2f..693b744fd572 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -247,6 +247,7 @@ void machine_shutdown(void)
 void machine_halt(void)
 {
 	machine_shutdown();
+	local_irq_disable();
 	while (1);
 }
 
@@ -268,6 +269,7 @@ void machine_restart(char *cmd)
 
 	/* Whoops - the platform was unable to reboot. Tell the user! */
 	printk("Reboot failed -- System halted\n");
+	local_irq_disable();
 	while (1);
 }
 

commit 448eca90932d97856b6a6097fc50eef96d77dec0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 7 17:59:49 2012 +0000

    arm: Remove unused cpu_idle_wait()
    
    cpuidle uses a generic function now. Remove the unused code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Link: http://lkml.kernel.org/r/20120507175652.260797846@linutronix.de

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 2b7b017a20cd..19c95ea65b2f 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -157,26 +157,6 @@ EXPORT_SYMBOL(pm_power_off);
 void (*arm_pm_restart)(char str, const char *cmd) = null_restart;
 EXPORT_SYMBOL_GPL(arm_pm_restart);
 
-static void do_nothing(void *unused)
-{
-}
-
-/*
- * cpu_idle_wait - Used to ensure that all the CPUs discard old value of
- * pm_idle and update to new pm_idle value. Required while changing pm_idle
- * handler on SMP systems.
- *
- * Caller must have changed pm_idle to the new value before the call. Old
- * pm_idle value will not be used by any CPU after the return of this function.
- */
-void cpu_idle_wait(void)
-{
-	smp_mb();
-	/* kick all the CPUs so that they exit out of pm_idle */
-	smp_call_function(do_nothing, NULL, 1);
-}
-EXPORT_SYMBOL_GPL(cpu_idle_wait);
-
 /*
  * This is our default idle handler.
  */

commit 12679a2d7e3bfbdc7586e3e86d1ca90c46659363
Merge: 1c036588772d b0df89868006
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 29 16:53:48 2012 -0700

    Merge branch 'for-linus' of git://git.linaro.org/people/rmk/linux-arm
    
    Pull more ARM updates from Russell King.
    
    This got a fair number of conflicts with the <asm/system.h> split, but
    also with some other sparse-irq and header file include cleanups.  They
    all looked pretty trivial, though.
    
    * 'for-linus' of git://git.linaro.org/people/rmk/linux-arm: (59 commits)
      ARM: fix Kconfig warning for HAVE_BPF_JIT
      ARM: 7361/1: provide XIP_VIRT_ADDR for no-MMU builds
      ARM: 7349/1: integrator: convert to sparse irqs
      ARM: 7259/3: net: JIT compiler for packet filters
      ARM: 7334/1: add jump label support
      ARM: 7333/2: jump label: detect %c support for ARM
      ARM: 7338/1: add support for early console output via semihosting
      ARM: use set_current_blocked() and block_sigmask()
      ARM: exec: remove redundant set_fs(USER_DS)
      ARM: 7332/1: extract out code patch function from kprobes
      ARM: 7331/1: extract out insn generation code from ftrace
      ARM: 7330/1: ftrace: use canonical Thumb-2 wide instruction format
      ARM: 7351/1: ftrace: remove useless memory checks
      ARM: 7316/1: kexec: EOI active and mask all interrupts in kexec crash path
      ARM: Versatile Express: add NO_IOPORT
      ARM: get rid of asm/irq.h in asm/prom.h
      ARM: 7319/1: Print debug info for SIGBUS in user faults
      ARM: 7318/1: gic: refactor irq_start assignment
      ARM: 7317/1: irq: avoid NULL check in for_each_irq_desc loop
      ARM: 7315/1: perf: add support for the Cortex-A7 PMU
      ...

commit 0195c00244dc2e9f522475868fa278c473ba7339
Merge: f21ce8f8447c 141124c02059
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 28 15:58:21 2012 -0700

    Merge tag 'split-asm_system_h-for-linus-20120328' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-asm_system
    
    Pull "Disintegrate and delete asm/system.h" from David Howells:
     "Here are a bunch of patches to disintegrate asm/system.h into a set of
      separate bits to relieve the problem of circular inclusion
      dependencies.
    
      I've built all the working defconfigs from all the arches that I can
      and made sure that they don't break.
    
      The reason for these patches is that I recently encountered a circular
      dependency problem that came about when I produced some patches to
      optimise get_order() by rewriting it to use ilog2().
    
      This uses bitops - and on the SH arch asm/bitops.h drags in
      asm-generic/get_order.h by a circuituous route involving asm/system.h.
    
      The main difficulty seems to be asm/system.h.  It holds a number of
      low level bits with no/few dependencies that are commonly used (eg.
      memory barriers) and a number of bits with more dependencies that
      aren't used in many places (eg.  switch_to()).
    
      These patches break asm/system.h up into the following core pieces:
    
        (1) asm/barrier.h
    
            Move memory barriers here.  This already done for MIPS and Alpha.
    
        (2) asm/switch_to.h
    
            Move switch_to() and related stuff here.
    
        (3) asm/exec.h
    
            Move arch_align_stack() here.  Other process execution related bits
            could perhaps go here from asm/processor.h.
    
        (4) asm/cmpxchg.h
    
            Move xchg() and cmpxchg() here as they're full word atomic ops and
            frequently used by atomic_xchg() and atomic_cmpxchg().
    
        (5) asm/bug.h
    
            Move die() and related bits.
    
        (6) asm/auxvec.h
    
            Move AT_VECTOR_SIZE_ARCH here.
    
      Other arch headers are created as needed on a per-arch basis."
    
    Fixed up some conflicts from other header file cleanups and moving code
    around that has happened in the meantime, so David's testing is somewhat
    weakened by that.  We'll find out anything that got broken and fix it..
    
    * tag 'split-asm_system_h-for-linus-20120328' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-asm_system: (38 commits)
      Delete all instances of asm/system.h
      Remove all #inclusions of asm/system.h
      Add #includes needed to permit the removal of asm/system.h
      Move all declarations of free_initmem() to linux/mm.h
      Disintegrate asm/system.h for OpenRISC
      Split arch_align_stack() out from asm-generic/system.h
      Split the switch_to() wrapper out of asm-generic/system.h
      Move the asm-generic/system.h xchg() implementation to asm-generic/cmpxchg.h
      Create asm-generic/barrier.h
      Make asm-generic/cmpxchg.h #include asm-generic/cmpxchg-local.h
      Disintegrate asm/system.h for Xtensa
      Disintegrate asm/system.h for Unicore32 [based on ver #3, changed by gxt]
      Disintegrate asm/system.h for Tile
      Disintegrate asm/system.h for Sparc
      Disintegrate asm/system.h for SH
      Disintegrate asm/system.h for Score
      Disintegrate asm/system.h for S390
      Disintegrate asm/system.h for PowerPC
      Disintegrate asm/system.h for PA-RISC
      Disintegrate asm/system.h for MN10300
      ...

commit 9f97da78bf018206fb623cd351d454af2f105fe0
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:01 2012 +0100

    Disintegrate asm/system.h for ARM
    
    Disintegrate asm/system.h for ARM.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Russell King <linux@arm.linux.org.uk>
    cc: linux-arm-kernel@lists.infradead.org

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index c2ae3cd331fe..19917e89f13b 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -35,7 +35,6 @@
 #include <asm/cacheflush.h>
 #include <asm/leds.h>
 #include <asm/processor.h>
-#include <asm/system.h>
 #include <asm/thread_notify.h>
 #include <asm/stacktrace.h>
 #include <asm/mach/time.h>

commit b0df89868006517417251e02cc4ce5d4b0165885
Merge: 4ba21e868f4b 6c634726352f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Mar 27 11:30:31 2012 +0100

    Merge branch 'devel-stable' into for-linus
    
    Conflicts:
            arch/arm/Kconfig.debug
            arch/arm/plat-versatile/Kconfig
    Merge fixes:
            arch/arm/mach-integrator/Kconfig
            drivers/clocksource/Kconfig

commit f9d4861fc32b995b1616775614459b8f266c803c
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Jan 20 12:01:13 2012 +0100

    ARM: 7294/1: vectors: use gate_vma for vectors user mapping
    
    The current user mapping for the vectors page is inserted as a `horrible
    hack vma' into each task via arch_setup_additional_pages. This causes
    problems with the MM subsystem and vm_normal_page, as described here:
    
    https://lkml.org/lkml/2012/1/14/55
    
    Following the suggestion from Hugh in the above thread, this patch uses
    the gate_vma for the vectors user mapping, therefore consolidating
    the horrible hack VMAs into one.
    
    Acked-and-Tested-by: Nicolas Pitre <nico@linaro.org>
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 971d65c253a9..e11b523db332 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -526,22 +526,40 @@ unsigned long arch_randomize_brk(struct mm_struct *mm)
 #ifdef CONFIG_MMU
 /*
  * The vectors page is always readable from user space for the
- * atomic helpers and the signal restart code.  Let's declare a mapping
- * for it so it is visible through ptrace and /proc/<pid>/mem.
+ * atomic helpers and the signal restart code. Insert it into the
+ * gate_vma so that it is visible through ptrace and /proc/<pid>/mem.
  */
+static struct vm_area_struct gate_vma;
 
-int vectors_user_mapping(void)
+static int __init gate_vma_init(void)
 {
-	struct mm_struct *mm = current->mm;
-	return install_special_mapping(mm, 0xffff0000, PAGE_SIZE,
-				       VM_READ | VM_EXEC |
-				       VM_MAYREAD | VM_MAYEXEC |
-				       VM_ALWAYSDUMP | VM_RESERVED,
-				       NULL);
+	gate_vma.vm_start	= 0xffff0000;
+	gate_vma.vm_end		= 0xffff0000 + PAGE_SIZE;
+	gate_vma.vm_page_prot	= PAGE_READONLY_EXEC;
+	gate_vma.vm_flags	= VM_READ | VM_EXEC |
+				  VM_MAYREAD | VM_MAYEXEC |
+				  VM_ALWAYSDUMP;
+	return 0;
+}
+arch_initcall(gate_vma_init);
+
+struct vm_area_struct *get_gate_vma(struct mm_struct *mm)
+{
+	return &gate_vma;
+}
+
+int in_gate_area(struct mm_struct *mm, unsigned long addr)
+{
+	return (addr >= gate_vma.vm_start) && (addr < gate_vma.vm_end);
+}
+
+int in_gate_area_no_mm(unsigned long addr)
+{
+	return in_gate_area(NULL, addr);
 }
 
 const char *arch_vma_name(struct vm_area_struct *vma)
 {
-	return (vma->vm_start == 0xffff0000) ? "[vectors]" : NULL;
+	return (vma == &gate_vma) ? "[vectors]" : NULL;
 }
 #endif

commit 56c10bf82c10588b743e75a13a7949e11b9fc942
Merge: bab2d8c6020e 61b80086a525
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 23 17:30:49 2012 -0700

    Merge branch 'for-armsoc' of git://git.linaro.org/people/rmk/linux-arm
    
    Pull #1 ARM updates from Russell King:
     "This one covers stuff which Arnd is waiting for me to push, as this is
      shared between both our trees and probably other trees elsewhere.
    
      Essentially, this contains:
       - AMBA primecell device initializer updates - mostly shrinking the
         size of the device declarations in platform code to something more
         reasonable.
       - Getting rid of the NO_IRQ crap from AMBA primecell stuff.
       - Nicolas' idle cleanups.  This in combination with the restart
         cleanups from the last merge window results in a great many
         mach/system.h files being deleted."
    
    Yay: ~80 files, ~2000 lines deleted.
    
    * 'for-armsoc' of git://git.linaro.org/people/rmk/linux-arm: (60 commits)
      ARM: remove disable_fiq and arch_ret_to_user macros
      ARM: make entry-macro.S depend on !MULTI_IRQ_HANDLER
      ARM: rpc: make default fiq handler run-time installed
      ARM: make arch_ret_to_user macro optional
      ARM: amba: samsung: use common amba device initializers
      ARM: amba: spear: use common amba device initializers
      ARM: amba: nomadik: use common amba device initializers
      ARM: amba: u300: use common amba device initializers
      ARM: amba: lpc32xx: use common amba device initializers
      ARM: amba: netx: use common amba device initializers
      ARM: amba: bcmring: use common amba device initializers
      ARM: amba: ep93xx: use common amba device initializers
      ARM: amba: omap2: use common amba device initializers
      ARM: amba: integrator: use common amba device initializers
      ARM: amba: realview: get rid of private platform amba_device initializer
      ARM: amba: versatile: get rid of private platform amba_device initializer
      ARM: amba: vexpress: get rid of private platform amba_device initializer
      ARM: amba: provide common initializers for static amba devices
      ARM: amba: make use of -1 IRQs warn
      ARM: amba: u300: get rid of NO_IRQ initializers
      ...

commit 909af768e88867016f427264ae39d27a57b6a8ed
Author: Jason Baron <jbaron@redhat.com>
Date:   Fri Mar 23 15:02:51 2012 -0700

    coredump: remove VM_ALWAYSDUMP flag
    
    The motivation for this patchset was that I was looking at a way for a
    qemu-kvm process, to exclude the guest memory from its core dump, which
    can be quite large.  There are already a number of filter flags in
    /proc/<pid>/coredump_filter, however, these allow one to specify 'types'
    of kernel memory, not specific address ranges (which is needed in this
    case).
    
    Since there are no more vma flags available, the first patch eliminates
    the need for the 'VM_ALWAYSDUMP' flag.  The flag is used internally by
    the kernel to mark vdso and vsyscall pages.  However, it is simple
    enough to check if a vma covers a vdso or vsyscall page without the need
    for this flag.
    
    The second patch then replaces the 'VM_ALWAYSDUMP' flag with a new
    'VM_NODUMP' flag, which can be set by userspace using new madvise flags:
    'MADV_DONTDUMP', and unset via 'MADV_DODUMP'.  The core dump filters
    continue to work the same as before unless 'MADV_DONTDUMP' is set on the
    region.
    
    The qemu code which implements this features is at:
    
      http://people.redhat.com/~jbaron/qemu-dump/qemu-dump.patch
    
    In my testing the qemu core dump shrunk from 383MB -> 13MB with this
    patch.
    
    I also believe that the 'MADV_DONTDUMP' flag might be useful for
    security sensitive apps, which might want to select which areas are
    dumped.
    
    This patch:
    
    The VM_ALWAYSDUMP flag is currently used by the coredump code to
    indicate that a vma is part of a vsyscall or vdso section.  However, we
    can determine if a vma is in one these sections by checking it against
    the gate_vma and checking for a non-NULL return value from
    arch_vma_name().  Thus, freeing a valuable vma bit.
    
    Signed-off-by: Jason Baron <jbaron@redhat.com>
    Acked-by: Roland McGrath <roland@hack.frob.com>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Avi Kivity <avi@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index c2ae3cd331fe..219e4efee1a6 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -533,8 +533,7 @@ int vectors_user_mapping(void)
 	struct mm_struct *mm = current->mm;
 	return install_special_mapping(mm, 0xffff0000, PAGE_SIZE,
 				       VM_READ | VM_EXEC |
-				       VM_MAYREAD | VM_MAYEXEC |
-				       VM_ALWAYSDUMP | VM_RESERVED,
+				       VM_MAYREAD | VM_MAYEXEC | VM_RESERVED,
 				       NULL);
 }
 

commit bd2f55361f18347e890d52ff9cfd8895455ec11b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 21 12:33:18 2011 +0100

    sched/rt: Use schedule_preempt_disabled()
    
    Coccinelle based conversion.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/n/tip-24swm5zut3h9c4a6s46x8rws@git.kernel.org
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 971d65c253a9..c2ae3cd331fe 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -239,9 +239,7 @@ void cpu_idle(void)
 		leds_event(led_idle_end);
 		rcu_idle_exit();
 		tick_nohz_idle_exit();
-		preempt_enable_no_resched();
-		schedule();
-		preempt_disable();
+		schedule_preempt_disabled();
 	}
 }
 

commit ae940913030386884f259eb4d95ac4d93b57144f
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Mon Dec 19 03:03:58 2011 -0500

    ARM: substitute arch_idle()
    
    Now that all implementations of arch_idle() are equivalent to cpu_do_idle()
    we can just use the later directly and stop including mach/system.h.
    
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Acked-and-tested-by: Jamie Iles <jamie@jamieiles.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index ba9e7ef92bec..008e7ce766a7 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -61,8 +61,6 @@ extern void setup_mm_for_reboot(void);
 
 static volatile int hlt_counter;
 
-#include <mach/system.h>
-
 void disable_hlt(void)
 {
 	hlt_counter++;
@@ -191,7 +189,7 @@ static void default_idle(void)
 	if (arm_pm_idle)
 		arm_pm_idle();
 	else
-		arch_idle();
+		cpu_do_idle();
 	local_irq_enable();
 }
 

commit 4fa20439a80c008d33f2865b0db94dcb5da467e2
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Mon Aug 1 17:25:06 2011 -0400

    ARM: clean up idle handlers
    
    Let's factor out the need_resched() check instead of having it duplicated
    in every pm_idle implementations to avoid inconsistencies (omap2_pm_idle
    is missing it already).
    
    The forceful re-enablement of IRQs after pm_idle has returned can go.
    The warning certainly doesn't trigger for existing users.
    
    To get rid of the pm_idle calling convention oddity, let's introduce
    arm_pm_idle() allowing for the local_irq_enable() to be factored out
    from SOC specific implementations. The default pm_idle function becomes
    a wrapper for arm_pm_idle and it takes care of enabling IRQs closer to
    where they are initially disabled.
    
    And finally move the comment explaining the reason for that turning off
    of IRQs to a more proper location.
    
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Acked-and-tested-by: Jamie Iles <jamie@jamieiles.com>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 971d65c253a9..ba9e7ef92bec 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -181,12 +181,16 @@ void cpu_idle_wait(void)
 EXPORT_SYMBOL_GPL(cpu_idle_wait);
 
 /*
- * This is our default idle handler.  We need to disable
- * interrupts here to ensure we don't miss a wakeup call.
+ * This is our default idle handler.
  */
+
+void (*arm_pm_idle)(void);
+
 static void default_idle(void)
 {
-	if (!need_resched())
+	if (arm_pm_idle)
+		arm_pm_idle();
+	else
 		arch_idle();
 	local_irq_enable();
 }
@@ -215,6 +219,10 @@ void cpu_idle(void)
 				cpu_die();
 #endif
 
+			/*
+			 * We need to disable interrupts here
+			 * to ensure we don't miss a wakeup call.
+			 */
 			local_irq_disable();
 #ifdef CONFIG_PL310_ERRATA_769419
 			wmb();
@@ -222,19 +230,18 @@ void cpu_idle(void)
 			if (hlt_counter) {
 				local_irq_enable();
 				cpu_relax();
-			} else {
+			} else if (!need_resched()) {
 				stop_critical_timings();
 				if (cpuidle_idle_call())
 					pm_idle();
 				start_critical_timings();
 				/*
-				 * This will eventually be removed - pm_idle
-				 * functions should always return with IRQs
-				 * enabled.
+				 * pm_idle functions must always
+				 * return with IRQs enabled.
 				 */
 				WARN_ON(irqs_disabled());
+			} else
 				local_irq_enable();
-			}
 		}
 		leds_event(led_idle_end);
 		rcu_idle_exit();

commit 770e1b035dcb6ec3f8ee69dda0815dd1e220a683
Merge: d3d0b024348c 7b9dd47136c0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 6 18:15:25 2012 -0800

    Merge branch 'for-linus' of git://ftp.arm.linux.org.uk/pub/linux/arm/kernel/git-cur/linux-2.6-arm
    
    * 'for-linus' of git://ftp.arm.linux.org.uk/pub/linux/arm/kernel/git-cur/linux-2.6-arm: (207 commits)
      ARM: 7267/1: Remove BUILD_BUG_ON from asm/bug.h
      ARM: 7269/1: mach-sa1100: fix sched_clock breakage
      ARM: 7198/1: arm/imx6: add restart support for imx6q
      ARM: restart: remove the now empty arch_reset()
      ARM: restart: remove comments about adding code to arch_reset()
      ARM: restart: lpc32xx & u300: remove unnecessary printk
      ARM: restart: plat-samsung: remove plat/reset.h and s5p_reset_hook
      ARM: restart: w90x900: use new restart hook
      ARM: restart: Versatile Express: use new restart hook
      ARM: restart: versatile: use new restart hook
      ARM: restart: u300: use new restart hook
      ARM: restart: tegra: use new restart hook
      ARM: restart: spear: use new restart hook
      ARM: restart: shark: use new restart hook
      ARM: restart: sa1100: use new restart hook
      ARM: 7252/1: restart: S5PV210: use new restart hook
      ARM: 7251/1: restart: S5PC100: use new restart hook
      ARM: 7250/1: restart: S5P64X0: use new restart hook
      ARM: 7266/1: restart: S3C64XX: use new restart hook
      ARM: 7265/1: restart: S3C24XX: use new restart hook
      ...
    
    Fix up trivial conflict in arch/arm/mm/init.c due to removal of
    memblock_init() clashing with the movement of the sorting of the meminfo
    array.

commit 7b9dd47136c07ffd883aff6926c7b281e4c1eea4
Merge: 2e0e94343691 0575fb754dbf
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jan 5 13:25:15 2012 +0000

    Merge branch 'restart' into for-linus
    
    Conflicts:
            arch/arm/mach-exynos/cpu.c
    
    The changes to arch/arm/mach-exynos/cpu.c were moved to
    mach-exynos/common.c.

commit f88b8979d26615ce68772cebc85c3b556571afca
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Nov 5 21:30:00 2011 +0000

    ARM: restart: remove the now empty arch_reset()
    
    Remove the now empty arch_reset() from all the mach/system.h includes,
    and remove its callsite.  Remove arm_machine_restart() as this function
    no longer does anything useful.
    
    For samsung platforms, remove the include of mach/system-reset.h and
    plat/system-reset.h from their respective mach/system.h headers as these
    just define their arch_reset functions.  As a result, the s3c2410 and
    plat-samsung system-reset.h files are no longer referenced, so remove
    these files entirely.
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Acked-by: Jamie Iles <jamie@jamieiles.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index eeb3e16c6046..17859ce4e7be 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -117,14 +117,8 @@ void soft_restart(unsigned long addr)
 	cpu_reset(addr);
 }
 
-void arm_machine_restart(char mode, const char *cmd)
+static void null_restart(char mode, const char *cmd)
 {
-	/* Disable interrupts first */
-	local_irq_disable();
-	local_fiq_disable();
-
-	/* Call the architecture specific reboot code. */
-	arch_reset(mode, cmd);
 }
 
 /*
@@ -133,7 +127,7 @@ void arm_machine_restart(char mode, const char *cmd)
 void (*pm_power_off)(void);
 EXPORT_SYMBOL(pm_power_off);
 
-void (*arm_pm_restart)(char str, const char *cmd) = arm_machine_restart;
+void (*arm_pm_restart)(char str, const char *cmd) = null_restart;
 EXPORT_SYMBOL_GPL(arm_pm_restart);
 
 static void do_nothing(void *unused)

commit 4045407fd7740642b18bc802e8bab064e79a61e5
Merge: 59136ef3c596 4c5f830c4c9d
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jan 5 12:56:44 2012 +0000

    Merge branch 'restart-cleanup' into restart
    
    Conflicts:
            arch/arm/kernel/setup.c

commit 290130a17718c1451bb8a77a5e2510e0279bd5f3
Author: Will Deacon <will.deacon@arm.com>
Date:   Mon Jun 6 12:28:54 2011 +0100

    ARM: reset: implement soft_restart for jumping to a physical address
    
    Tools such as kexec and CPU hotplug require a way to reset the processor
    and branch to some code in physical space. This requires various bits of
    jiggery pokery with the caches and MMU which, when it goes wrong, tends
    to lock up the system.
    
    This patch fleshes out the soft_restart implementation so that it
    branches to the reset code using the identity mapping. This requires us
    to change to a temporary stack, held within the kernel image as a static
    array, to avoid conflicting with the new view of memory.
    
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index eeb3e16c6046..423bb2019451 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -92,17 +92,23 @@ static int __init hlt_setup(char *__unused)
 __setup("nohlt", nohlt_setup);
 __setup("hlt", hlt_setup);
 
-void soft_restart(unsigned long addr)
+extern void call_with_stack(void (*fn)(void *), void *arg, void *sp);
+typedef void (*phys_reset_t)(unsigned long);
+
+/*
+ * A temporary stack to use for CPU reset. This is static so that we
+ * don't clobber it with the identity mapping. When running with this
+ * stack, any references to the current task *will not work* so you
+ * should really do as little as possible before jumping to your reset
+ * code.
+ */
+static u64 soft_restart_stack[16];
+
+static void __soft_restart(void *addr)
 {
-	/* Disable interrupts first */
-	local_irq_disable();
-	local_fiq_disable();
+	phys_reset_t phys_reset;
 
-	/*
-	 * Tell the mm system that we are going to reboot -
-	 * we may need it to insert some 1:1 mappings so that
-	 * soft boot works.
-	 */
+	/* Take out a flat memory mapping. */
 	setup_mm_for_reboot();
 
 	/* Clean and invalidate caches */
@@ -114,7 +120,31 @@ void soft_restart(unsigned long addr)
 	/* Push out any further dirty data, and ensure cache is empty */
 	flush_cache_all();
 
-	cpu_reset(addr);
+	/* Switch to the identity mapping. */
+	phys_reset = (phys_reset_t)(unsigned long)virt_to_phys(cpu_reset);
+	phys_reset((unsigned long)addr);
+
+	/* Should never get here. */
+	BUG();
+}
+
+void soft_restart(unsigned long addr)
+{
+	u64 *stack = soft_restart_stack + ARRAY_SIZE(soft_restart_stack);
+
+	/* Disable interrupts first */
+	local_irq_disable();
+	local_fiq_disable();
+
+	/* Disable the L2 if we're the last man standing. */
+	if (num_online_cpus() == 1)
+		outer_disable();
+
+	/* Change to the new stack and continue with the reset. */
+	call_with_stack(__soft_restart, (void *)addr, (void *)stack);
+
+	/* Should never get here. */
+	BUG();
 }
 
 void arm_machine_restart(char mode, const char *cmd)

commit 1268fbc746ea1cd279886a740dcbad4ba5232225
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Thu Nov 17 18:48:14 2011 +0100

    nohz: Remove tick_nohz_idle_enter_norcu() / tick_nohz_idle_exit_norcu()
    
    Those two APIs were provided to optimize the calls of
    tick_nohz_idle_enter() and rcu_idle_enter() into a single
    irq disabled section. This way no interrupt happening in-between would
    needlessly process any RCU job.
    
    Now we are talking about an optimization for which benefits
    have yet to be measured. Let's start simple and completely decouple
    idle rcu and dyntick idle logics to simplify.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 47e34c091276..e8e8fe505df1 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -183,7 +183,8 @@ void cpu_idle(void)
 
 	/* endless idle loop with no priority at all */
 	while (1) {
-		tick_nohz_idle_enter_norcu();
+		tick_nohz_idle_enter();
+		rcu_idle_enter();
 		leds_event(led_idle_start);
 		while (!need_resched()) {
 #ifdef CONFIG_HOTPLUG_CPU
@@ -213,7 +214,8 @@ void cpu_idle(void)
 			}
 		}
 		leds_event(led_idle_end);
-		tick_nohz_idle_exit_norcu();
+		rcu_idle_exit();
+		tick_nohz_idle_exit();
 		preempt_enable_no_resched();
 		schedule();
 		preempt_disable();

commit 2bbb6817c0ac1b5f2a68d720f364f98eeb1ac4fd
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Sat Oct 8 16:01:00 2011 +0200

    nohz: Allow rcu extended quiescent state handling seperately from tick stop
    
    It is assumed that rcu won't be used once we switch to tickless
    mode and until we restart the tick. However this is not always
    true, as in x86-64 where we dereference the idle notifiers after
    the tick is stopped.
    
    To prepare for fixing this, add two new APIs:
    tick_nohz_idle_enter_norcu() and tick_nohz_idle_exit_norcu().
    
    If no use of RCU is made in the idle loop between
    tick_nohz_enter_idle() and tick_nohz_exit_idle() calls, the arch
    must instead call the new *_norcu() version such that the arch doesn't
    need to call rcu_idle_enter() and rcu_idle_exit().
    
    Otherwise the arch must call tick_nohz_enter_idle() and
    tick_nohz_exit_idle() and also call explicitly:
    
    - rcu_idle_enter() after its last use of RCU before the CPU is put
    to sleep.
    - rcu_idle_exit() before the first use of RCU after the CPU is woken
    up.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Mike Frysinger <vapier@gentoo.org>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Cc: David Miller <davem@davemloft.net>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Hans-Christian Egtvedt <hans-christian.egtvedt@atmel.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 3f1f8daf703c..47e34c091276 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -183,7 +183,7 @@ void cpu_idle(void)
 
 	/* endless idle loop with no priority at all */
 	while (1) {
-		tick_nohz_idle_enter();
+		tick_nohz_idle_enter_norcu();
 		leds_event(led_idle_start);
 		while (!need_resched()) {
 #ifdef CONFIG_HOTPLUG_CPU
@@ -213,7 +213,7 @@ void cpu_idle(void)
 			}
 		}
 		leds_event(led_idle_end);
-		tick_nohz_idle_exit();
+		tick_nohz_idle_exit_norcu();
 		preempt_enable_no_resched();
 		schedule();
 		preempt_disable();

commit 280f06774afedf849f0b34248ed6aff57d0f6908
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Fri Oct 7 18:22:06 2011 +0200

    nohz: Separate out irq exit and idle loop dyntick logic
    
    The tick_nohz_stop_sched_tick() function, which tries to delay
    the next timer tick as long as possible, can be called from two
    places:
    
    - From the idle loop to start the dytick idle mode
    - From interrupt exit if we have interrupted the dyntick
    idle mode, so that we reprogram the next tick event in
    case the irq changed some internal state that requires this
    action.
    
    There are only few minor differences between both that
    are handled by that function, driven by the ts->inidle
    cpu variable and the inidle parameter. The whole guarantees
    that we only update the dyntick mode on irq exit if we actually
    interrupted the dyntick idle mode, and that we enter in RCU extended
    quiescent state from idle loop entry only.
    
    Split this function into:
    
    - tick_nohz_idle_enter(), which sets ts->inidle to 1, enters
    dynticks idle mode unconditionally if it can, and enters into RCU
    extended quiescent state.
    
    - tick_nohz_irq_exit() which only updates the dynticks idle mode
    when ts->inidle is set (ie: if tick_nohz_idle_enter() has been called).
    
    To maintain symmetry, tick_nohz_restart_sched_tick() has been renamed
    into tick_nohz_idle_exit().
    
    This simplifies the code and micro-optimize the irq exit path (no need
    for local_irq_save there). This also prepares for the split between
    dynticks and rcu extended quiescent state logics. We'll need this split to
    further fix illegal uses of RCU in extended quiescent states in the idle
    loop.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Mike Frysinger <vapier@gentoo.org>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Cc: David Miller <davem@davemloft.net>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Hans-Christian Egtvedt <hans-christian.egtvedt@atmel.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 3d0c6fb74ae4..3f1f8daf703c 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -183,7 +183,7 @@ void cpu_idle(void)
 
 	/* endless idle loop with no priority at all */
 	while (1) {
-		tick_nohz_stop_sched_tick(1);
+		tick_nohz_idle_enter();
 		leds_event(led_idle_start);
 		while (!need_resched()) {
 #ifdef CONFIG_HOTPLUG_CPU
@@ -213,7 +213,7 @@ void cpu_idle(void)
 			}
 		}
 		leds_event(led_idle_end);
-		tick_nohz_restart_sched_tick();
+		tick_nohz_idle_exit();
 		preempt_enable_no_resched();
 		schedule();
 		preempt_disable();

commit 742eaa6a6e356a16788ce6530271de89bc4f8fb5
Merge: ba8bb18a03f8 ae72fd588a2b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Dec 5 23:20:17 2011 +0000

    Merge branch 'for-rmk' of git://git.kernel.org/pub/scm/linux/kernel/git/will/linux into devel-stable
    
    Conflicts:
            arch/arm/common/gic.c
            arch/arm/plat-omap/include/plat/common.h

commit 11ed0ba1754841316d4095478944300acf19acc3
Author: Will Deacon <will.deacon@arm.com>
Date:   Mon Nov 14 17:24:58 2011 +0100

    ARM: 7161/1: errata: no automatic store buffer drain
    
    This patch implements a workaround for PL310 erratum 769419. On
    revisions of the PL310 prior to r3p2, the Store Buffer does not
    automatically drain. This can cause normal, non-cacheable writes to be
    retained when the memory system is idle, leading to suboptimal I/O
    performance for drivers using coherent DMA.
    
    This patch adds an optional wmb() call to the cpu_idle loop. On systems
    with an outer cache, this causes an explicit flush of the store buffer.
    
    Cc: stable@vger.kernel.org
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Tested-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 75316f0dd02a..3d0c6fb74ae4 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -192,6 +192,9 @@ void cpu_idle(void)
 #endif
 
 			local_irq_disable();
+#ifdef CONFIG_PL310_ERRATA_769419
+			wmb();
+#endif
 			if (hlt_counter) {
 				local_irq_enable();
 				cpu_relax();

commit e879c862fb81b986095ae7a4676b2281c2f97957
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Nov 1 13:16:26 2011 +0000

    ARM: restart: only perform setup for restart when soft-restarting
    
    We only need to set the system up for a soft-restart if we're going to
    be doing a soft-restart.  Provide a new function (soft_restart()) which
    does the setup and final call for this, and make platforms use it.
    Eliminate the call to setup_restart() from the default handler.
    
    This means that platforms arch_reset() function is no longer called with
    the page tables prepared for a soft-restart, and caches will still be
    enabled.
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Viresh Kumar <viresh.kumar@st.com>
    Acked-by: Krzysztof Ha■asa <khc@pm.waw.pl>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Richard Purdie <richard.purdie@linuxfoundation.org>
    Acked-by: Wan ZongShun <mcuos.com@gmail.com>
    Acked-by: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 4181738452fc..1e8b3e2de7a3 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -92,7 +92,7 @@ static int __init hlt_setup(char *__unused)
 __setup("nohlt", nohlt_setup);
 __setup("hlt", hlt_setup);
 
-void arm_machine_restart(char mode, const char *cmd)
+void soft_restart(unsigned long addr)
 {
 	/* Disable interrupts first */
 	local_irq_disable();
@@ -114,7 +114,16 @@ void arm_machine_restart(char mode, const char *cmd)
 	/* Push out any further dirty data, and ensure cache is empty */
 	flush_cache_all();
 
-	/* Now call the architecture specific reboot code. */
+	cpu_reset(addr);
+}
+
+void arm_machine_restart(char mode, const char *cmd)
+{
+	/* Disable interrupts first */
+	local_irq_disable();
+	local_fiq_disable();
+
+	/* Call the architecture specific reboot code. */
 	arch_reset(mode, cmd);
 }
 

commit 5aafec15bdc54cf0722696c95091d7bd674bfcad
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Nov 1 10:15:27 2011 +0000

    ARM: restart: remove argument to setup_mm_for_reboot()
    
    setup_mm_for_reboot() doesn't make use of its argument, so remove it.
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 3bda1c379776..4181738452fc 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -57,7 +57,7 @@ static const char *isa_modes[] = {
   "ARM" , "Thumb" , "Jazelle", "ThumbEE"
 };
 
-extern void setup_mm_for_reboot(char mode);
+extern void setup_mm_for_reboot(void);
 
 static volatile int hlt_counter;
 
@@ -103,7 +103,7 @@ void arm_machine_restart(char mode, const char *cmd)
 	 * we may need it to insert some 1:1 mappings so that
 	 * soft boot works.
 	 */
-	setup_mm_for_reboot(mode);
+	setup_mm_for_reboot();
 
 	/* Clean and invalidate caches */
 	flush_cache_all();

commit ac15e00b1efe705b66a36d1a6a9db7f6ed524c43
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Oct 31 09:22:22 2011 +0000

    ARM: restart: move reboot failure handing into machine_restart()
    
    Move the failure to reboot into machine_restart() to always catch
    this condition, even if a platform decides to hook the restarting
    via arm_pm_restart().
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 75316f0dd02a..3bda1c379776 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -114,18 +114,8 @@ void arm_machine_restart(char mode, const char *cmd)
 	/* Push out any further dirty data, and ensure cache is empty */
 	flush_cache_all();
 
-	/*
-	 * Now call the architecture specific reboot code.
-	 */
+	/* Now call the architecture specific reboot code. */
 	arch_reset(mode, cmd);
-
-	/*
-	 * Whoops - the architecture was unable to reboot.
-	 * Tell the user!
-	 */
-	mdelay(1000);
-	printk("Reboot failed -- System halted\n");
-	while (1);
 }
 
 /*
@@ -250,7 +240,15 @@ void machine_power_off(void)
 void machine_restart(char *cmd)
 {
 	machine_shutdown();
+
 	arm_pm_restart(reboot_mode, cmd);
+
+	/* Give a grace period for failure to restart of 1s */
+	mdelay(1000);
+
+	/* Whoops - the platform was unable to reboot. Tell the user! */
+	printk("Reboot failed -- System halted\n");
+	while (1);
 }
 
 void __show_regs(struct pt_regs *regs)

commit ecea4ab6d3d8bb4122522398200f1cd2a06af6d5
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 22 10:58:34 2011 -0400

    arm: convert core files from module.h to export.h
    
    Many of the core ARM kernel files are not modules, but just
    including module.h for exporting symbols.  Now these files can
    use the lighter footprint export.h for this role.
    
    There are probably lots more, but ARM files of mach-* and plat-*
    don't get coverage via a simple yesconfig build.  They will have
    to be cleaned up and tested via using their respective configs.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index fd0814076ff6..75316f0dd02a 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -10,7 +10,7 @@
  */
 #include <stdarg.h>
 
-#include <linux/module.h>
+#include <linux/export.h>
 #include <linux/sched.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>

commit b380ab4f85d641574d91b12b333848a0731a497c
Author: Laura Abbott <lauraa@codeaurora.org>
Date:   Wed Aug 31 02:04:06 2011 +0100

    ARM: 7068/1: process: change from __backtrace to dump_stack in show_regs
    
    Currently, show_regs calls __backtrace which does
    nothing if CONFIG_FRAME_POINTER is not set. Switch to
    dump_stack which handles both CONFIG_FRAME_POINTER and
    CONFIG_ARM_UNWIND correctly.
    
    __backtrace is now superseded by dump_stack in general
    and show_regs was the last caller so remove __backtrace
    as well.
    
    Signed-off-by: Laura Abbott <lauraa@codeaurora.org>
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 1a347f481e5e..fd0814076ff6 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -319,7 +319,7 @@ void show_regs(struct pt_regs * regs)
 	printk("\n");
 	printk("Pid: %d, comm: %20s\n", task_pid_nr(current), current->comm);
 	__show_regs(regs);
-	__backtrace();
+	dump_stack();
 }
 
 ATOMIC_NOTIFIER_HEAD(thread_notify_head);

commit cbc158d6bfa1990f7869717bb5270867c66068d1
Author: David Brown <davidb@codeaurora.org>
Date:   Thu Aug 4 09:24:31 2011 -0700

    cpuidle: Consistent spelling of cpuidle_idle_call()
    
    Commit a0bfa1373859e9d11dc92561a8667588803e42d8 mispells
    cpuidle_idle_call() on ARM and SH code.  Fix this to be consistent.
    
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: x86@kernel.org
    Cc: Len Brown <len.brown@intel.com>
    Signed-off-by: David Brown <davidb@codeaurora.org>
    [ Also done by Mark Brown - th ebug has been around forever, and was
      noticed in -next, but the idle tree never picked it up. Bad bad bad ]
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index d7ee0d4c072d..1a347f481e5e 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -197,7 +197,7 @@ void cpu_idle(void)
 				cpu_relax();
 			} else {
 				stop_critical_timings();
-				if (cpuidle_call_idle())
+				if (cpuidle_idle_call())
 					pm_idle();
 				start_critical_timings();
 				/*

commit a0bfa1373859e9d11dc92561a8667588803e42d8
Author: Len Brown <len.brown@intel.com>
Date:   Fri Apr 1 19:34:59 2011 -0400

    cpuidle: stop depending on pm_idle
    
    cpuidle users should call cpuidle_call_idle() directly
    rather than via (pm_idle)() function pointer.
    
    Architecture may choose to continue using (pm_idle)(),
    but cpuidle need not depend on it:
    
      my_arch_cpu_idle()
            ...
            if(cpuidle_call_idle())
                    pm_idle();
    
    cc: Kevin Hilman <khilman@deeprootsystems.com>
    cc: Paul Mundt <lethal@linux-sh.org>
    cc: x86@kernel.org
    Acked-by: H. Peter Anvin <hpa@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 5e1e54197227..d7ee0d4c072d 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -30,6 +30,7 @@
 #include <linux/uaccess.h>
 #include <linux/random.h>
 #include <linux/hw_breakpoint.h>
+#include <linux/cpuidle.h>
 
 #include <asm/cacheflush.h>
 #include <asm/leds.h>
@@ -196,7 +197,8 @@ void cpu_idle(void)
 				cpu_relax();
 			} else {
 				stop_critical_timings();
-				pm_idle();
+				if (cpuidle_call_idle())
+					pm_idle();
 				start_critical_timings();
 				/*
 				 * This will eventually be removed - pm_idle

commit 2e82669acf03e5bf2080f5d3ef005168e67d8a51
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Wed Apr 6 16:16:29 2011 +0100

    ARM: 6867/1: Introduce THREAD_NOTIFY_COPY for copy_thread() hooks
    
    This patch adds THREAD_NOTIFY_COPY for calling registered handlers
    during the copy_thread() function call. It also changes the VFP handler
    to use a switch statement rather than if..else and ignore this event.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 94bbedbed639..5e1e54197227 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -372,6 +372,8 @@ copy_thread(unsigned long clone_flags, unsigned long stack_start,
 	if (clone_flags & CLONE_SETTLS)
 		thread->tp_value = regs->ARM_r3;
 
+	thread_notify(THREAD_NOTIFY_COPY, thread);
+
 	return 0;
 }
 

commit 6cde6d4217ff01422c093d3f7ff550b7a324e96e
Author: Will Deacon <will.deacon@arm.com>
Date:   Tue Jan 11 14:04:36 2011 +0100

    ARM: 6619/1: nommu: avoid mapping vectors page when !CONFIG_MMU
    
    When running without an MMU, we do not need to install a mapping for the
    vectors page. Attempting to do so causes a compile-time error because
    install_special_mapping is not defined.
    
    This patch adds compile-time guards to the vector mapping functions
    so that we can build nommu configurations once more.
    
    Acked-by: Greg Ungerer <gerg@uclinux.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index e76fcaadce03..94bbedbed639 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -483,6 +483,7 @@ unsigned long arch_randomize_brk(struct mm_struct *mm)
 	return randomize_range(mm->brk, range_end, 0) ? : mm->brk;
 }
 
+#ifdef CONFIG_MMU
 /*
  * The vectors page is always readable from user space for the
  * atomic helpers and the signal restart code.  Let's declare a mapping
@@ -503,3 +504,4 @@ const char *arch_vma_name(struct vm_area_struct *vma)
 {
 	return (vma->vm_start == 0xffff0000) ? "[vectors]" : NULL;
 }
+#endif

commit 809b4e00baf006a990a73329ba381d536c6fa277
Merge: a0a55682b83f 79a94c3538bd
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Oct 19 22:06:36 2010 +0100

    Merge branch 'devel-stable' into devel

commit 23beab76b490172a9ff3d52843e4d27a35b2a4c6
Merge: 8ed9059533eb 5fb31a96e1e0 80be7a7f6427 19852e59002f 29e29f27486e 725343fa748f 9e978f096241 f3af03de0b1c 5333a3de3cdd
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Oct 18 22:34:25 2010 +0100

    Merge branches 'at91', 'dcache', 'ftrace', 'hwbpt', 'misc', 'mmci', 's3c', 'st-ux' and 'unwind' into devel

commit c7b0aff44a0740eedd31b759fd08d9e25672fa76
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Fri Oct 1 22:13:47 2010 +0100

    ARM: 6428/1: add cpu_idle_wait() to support CPUidle on SMP systems.
    
    In order for CPUidle to work on SMP systems, an implementation of
    cpu_idle_wait() is needed.
    
    This patch duplicates the x86 implementation of cpu_idle_wait() for
    ARM.
    
    Tested-by: Colin Cross <ccross@android.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 401e38be1f78..23def52d2d24 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -135,6 +135,25 @@ EXPORT_SYMBOL(pm_power_off);
 void (*arm_pm_restart)(char str, const char *cmd) = arm_machine_restart;
 EXPORT_SYMBOL_GPL(arm_pm_restart);
 
+static void do_nothing(void *unused)
+{
+}
+
+/*
+ * cpu_idle_wait - Used to ensure that all the CPUs discard old value of
+ * pm_idle and update to new pm_idle value. Required while changing pm_idle
+ * handler on SMP systems.
+ *
+ * Caller must have changed pm_idle to the new value before the call. Old
+ * pm_idle value will not be used by any CPU after the return of this function.
+ */
+void cpu_idle_wait(void)
+{
+	smp_mb();
+	/* kick all the CPUs so that they exit out of pm_idle */
+	smp_call_function(do_nothing, NULL, 1);
+}
+EXPORT_SYMBOL_GPL(cpu_idle_wait);
 
 /*
  * This is our default idle handler.  We need to disable

commit ec706dab290c486837d4a825870ab052bf200279
Author: Nicolas Pitre <nico@fluxnic.net>
Date:   Thu Aug 26 23:10:50 2010 -0400

    ARM: add a vma entry for the user accessible vector page
    
    The kernel makes the high vector page visible to user space. This page
    contains (amongst others) small code segments that can be executed in
    user space.  Make this page visible through ptrace and /proc/<pid>/mem
    in order to let gdb perform code parsing needed for proper unwinding.
    
    For example, the ERESTART_RESTARTBLOCK handler actually has a stack
    frame -- it returns to a PC value stored on the user's stack.   To
    unwind after a "sleep" system call was interrupted twice, GDB would
    have to recognize this situation and understand that stack frame
    layout -- which it currently cannot do.
    
    We could fix this by hard-coding addresses in the vector page range into
    GDB, but that isn't really portable as not all of those addresses are
    guaranteed to remain stable across kernel releases.  And having the gdb
    process make an exception for this page and get  content from its own
    address space for it looks strange, and it is not future proof either.
    
    Being located above PAGE_OFFSET, this vma cannot be deleted by
    user space code.
    
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 401e38be1f78..66ac9c926200 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -458,3 +458,24 @@ unsigned long arch_randomize_brk(struct mm_struct *mm)
 	unsigned long range_end = mm->brk + 0x02000000;
 	return randomize_range(mm->brk, range_end, 0) ? : mm->brk;
 }
+
+/*
+ * The vectors page is always readable from user space for the
+ * atomic helpers and the signal restart code.  Let's declare a mapping
+ * for it so it is visible through ptrace and /proc/<pid>/mem.
+ */
+
+int vectors_user_mapping(void)
+{
+	struct mm_struct *mm = current->mm;
+	return install_special_mapping(mm, 0xffff0000, PAGE_SIZE,
+				       VM_READ | VM_EXEC |
+				       VM_MAYREAD | VM_MAYEXEC |
+				       VM_ALWAYSDUMP | VM_RESERVED,
+				       NULL);
+}
+
+const char *arch_vma_name(struct vm_area_struct *vma)
+{
+	return (vma->vm_start == 0xffff0000) ? "[vectors]" : NULL;
+}

commit 864232fa1a2f8dfe003438ef0851a56722740f3e
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Sep 3 10:42:55 2010 +0100

    ARM: 6357/1: hw-breakpoint: add new ptrace requests for hw-breakpoint interaction
    
    For debuggers to take advantage of the hw-breakpoint framework in the kernel,
    it is necessary to expose the API calls via a ptrace interface.
    
    This patch exposes the hardware breakpoints framework as a collection of
    virtual registers, accesible using PTRACE_SETHBPREGS and PTRACE_GETHBPREGS
    requests. The breakpoints are stored in the debug_info struct of the running
    thread.
    
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: S. Karthikeyan <informkarthik@gmail.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 401e38be1f78..974af1c3eb1d 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -29,6 +29,7 @@
 #include <linux/utsname.h>
 #include <linux/uaccess.h>
 #include <linux/random.h>
+#include <linux/hw_breakpoint.h>
 
 #include <asm/cacheflush.h>
 #include <asm/leds.h>
@@ -317,6 +318,8 @@ void flush_thread(void)
 	struct thread_info *thread = current_thread_info();
 	struct task_struct *tsk = current;
 
+	flush_ptrace_hw_breakpoint(tsk);
+
 	memset(thread->used_cp, 0, sizeof(thread->used_cp));
 	memset(&tsk->thread.debug, 0, sizeof(struct debug_info));
 	memset(&thread->fpstate, 0, sizeof(union fp_state));
@@ -345,6 +348,8 @@ copy_thread(unsigned long clone_flags, unsigned long stack_start,
 	thread->cpu_context.sp = (unsigned long)childregs;
 	thread->cpu_context.pc = (unsigned long)ret_from_fork;
 
+	clear_ptrace_hw_breakpoint(p);
+
 	if (clone_flags & CLONE_SETTLS)
 		thread->tp_value = regs->ARM_r3;
 

commit 7b70c4275f28702b76b273c8534c38f8313812e9
Merge: ceb0885d3b01 a20df564d15b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jul 31 14:20:16 2010 +0100

    Merge branch 'devel-stable' into devel
    
    Conflicts:
            arch/arm/kernel/entry-armv.S
            arch/arm/kernel/setup.c
            arch/arm/mm/init.c

commit 3d3f78d752bfada5b6041f2f7bd0833d8bdf7a4a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Jul 26 13:31:27 2010 +0100

    ARM: call machine_shutdown() from machine_halt(), etc
    
    x86 calls machine_shutdown() from the various machine_*() calls which
    take the machine down ready for halting, restarting, etc, and uses
    this to bring the system safely to a point where those actions can be
    performed.  Such actions are stopping the secondary CPUs.
    
    So, change the ARM implementation of these to reflect what x86 does.
    
    This solves kexec problems on ARM SMP platforms, where the secondary
    CPUs were left running across the kexec call.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index aaf51159203a..2e2ec97cc50c 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -198,19 +198,29 @@ int __init reboot_setup(char *str)
 
 __setup("reboot=", reboot_setup);
 
-void machine_halt(void)
+void machine_shutdown(void)
 {
+#ifdef CONFIG_SMP
+	smp_send_stop();
+#endif
 }
 
+void machine_halt(void)
+{
+	machine_shutdown();
+	while (1);
+}
 
 void machine_power_off(void)
 {
+	machine_shutdown();
 	if (pm_power_off)
 		pm_power_off();
 }
 
 void machine_restart(char *cmd)
 {
+	machine_shutdown();
 	arm_pm_restart(reboot_mode, cmd);
 }
 

commit 9ca03a21e320a6bf44559323527aba704bcc8772
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Jul 26 12:22:12 2010 +0100

    ARM: Factor out common code from cpu_proc_fin()
    
    All implementations of cpu_proc_fin() start by disabling interrupts
    and then flush caches.  Rather than have every processors proc_fin()
    implementation do this, move it out into generic code - and move the
    cache flush past setup_mm_for_reboot() (so it can benefit from having
    caches still enabled.)
    
    This allows cpu_proc_fin() to become independent of the L1/L2 cache
    types, and eventually move the L2 cache flushing into the L2 support
    code.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index a4a9cc88bec7..aaf51159203a 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -29,6 +29,7 @@
 #include <linux/utsname.h>
 #include <linux/uaccess.h>
 
+#include <asm/cacheflush.h>
 #include <asm/leds.h>
 #include <asm/processor.h>
 #include <asm/system.h>
@@ -84,10 +85,9 @@ __setup("hlt", hlt_setup);
 
 void arm_machine_restart(char mode, const char *cmd)
 {
-	/*
-	 * Clean and disable cache, and turn off interrupts
-	 */
-	cpu_proc_fin();
+	/* Disable interrupts first */
+	local_irq_disable();
+	local_fiq_disable();
 
 	/*
 	 * Tell the mm system that we are going to reboot -
@@ -96,6 +96,15 @@ void arm_machine_restart(char mode, const char *cmd)
 	 */
 	setup_mm_for_reboot(mode);
 
+	/* Clean and invalidate caches */
+	flush_cache_all();
+
+	/* Turn off caching */
+	cpu_proc_fin();
+
+	/* Push out any further dirty data, and ensure cache is empty */
+	flush_cache_all();
+
 	/*
 	 * Now call the architecture specific reboot code.
 	 */

commit 14764b01a5576ce23a9d0c95a027049206a19cef
Merge: fc4978b796e5 5ccd4302a20b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Jul 21 09:22:45 2010 +0100

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/nico/orion into devel-stable

commit ac78884e6d89714d18b32b5b7d574116ecfb7c88
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jul 10 10:10:18 2010 +0100

    ARM: lockdep: fix unannotated irqs-on
    
    CPU: Testing write buffer coherency: ok
    ------------[ cut here ]------------
    WARNING: at kernel/lockdep.c:3145 check_flags+0xcc/0x1dc()
    Modules linked in:
    [<c0035120>] (unwind_backtrace+0x0/0xf8) from [<c0355374>] (dump_stack+0x20/0x24)
    [<c0355374>] (dump_stack+0x20/0x24) from [<c0060c04>] (warn_slowpath_common+0x58/0x70)
    [<c0060c04>] (warn_slowpath_common+0x58/0x70) from [<c0060c3c>] (warn_slowpath_null+0x20/0x24)
    [<c0060c3c>] (warn_slowpath_null+0x20/0x24) from [<c008f224>] (check_flags+0xcc/0x1dc)
    [<c008f224>] (check_flags+0xcc/0x1dc) from [<c00945dc>] (lock_acquire+0x50/0x140)
    [<c00945dc>] (lock_acquire+0x50/0x140) from [<c0358434>] (_raw_spin_lock+0x50/0x88)
    [<c0358434>] (_raw_spin_lock+0x50/0x88) from [<c00fd114>] (set_task_comm+0x2c/0x60)
    [<c00fd114>] (set_task_comm+0x2c/0x60) from [<c007e184>] (kthreadd+0x30/0x108)
    [<c007e184>] (kthreadd+0x30/0x108) from [<c0030104>] (kernel_thread_exit+0x0/0x8)
    ---[ end trace 1b75b31a2719ed1c ]---
    possible reason: unannotated irqs-on.
    irq event stamp: 3
    hardirqs last  enabled at (2): [<c0059bb0>] finish_task_switch+0x48/0xb0
    hardirqs last disabled at (3): [<c002f0b0>] ret_slow_syscall+0xc/0x1c
    softirqs last  enabled at (0): [<c005f3e0>] copy_process+0x394/0xe5c
    softirqs last disabled at (0): [<(null)>] (null)
    
    Fix this by ensuring that the lockdep interrupt state is manipulated in
    the appropriate places.  We essentially treat userspace as an entirely
    separate environment which isn't relevant to lockdep (lockdep doesn't
    monitor userspace.)  We don't tell lockdep that IRQs will be enabled
    in that environment.
    
    Instead, when creating kernel threads (which is a rare event compared
    to entering/leaving userspace) we have to update the lockdep state.  Do
    this by starting threads with IRQs disabled, and in the kthread helper,
    tell lockdep that IRQs are enabled, and enable them.
    
    This provides lockdep with a consistent view of the current IRQ state
    in kernel space.
    
    This also revert portions of 0d928b0b616d1c5c5fe76019a87cba171ca91633
    which didn't fix the problem.
    
    Tested-by: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index acf5e6fdb6dc..a4a9cc88bec7 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -351,17 +351,21 @@ EXPORT_SYMBOL(dump_fpu);
 
 /*
  * Shuffle the argument into the correct register before calling the
- * thread function.  r1 is the thread argument, r2 is the pointer to
- * the thread function, and r3 points to the exit function.
+ * thread function.  r4 is the thread argument, r5 is the pointer to
+ * the thread function, and r6 points to the exit function.
  */
 extern void kernel_thread_helper(void);
 asm(	".pushsection .text\n"
 "	.align\n"
 "	.type	kernel_thread_helper, #function\n"
 "kernel_thread_helper:\n"
-"	mov	r0, r1\n"
-"	mov	lr, r3\n"
-"	mov	pc, r2\n"
+#ifdef CONFIG_TRACE_IRQFLAGS
+"	bl	trace_hardirqs_on\n"
+#endif
+"	msr	cpsr_c, r7\n"
+"	mov	r0, r4\n"
+"	mov	lr, r6\n"
+"	mov	pc, r5\n"
 "	.size	kernel_thread_helper, . - kernel_thread_helper\n"
 "	.popsection");
 
@@ -391,11 +395,12 @@ pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
 
 	memset(&regs, 0, sizeof(regs));
 
-	regs.ARM_r1 = (unsigned long)arg;
-	regs.ARM_r2 = (unsigned long)fn;
-	regs.ARM_r3 = (unsigned long)kernel_thread_exit;
+	regs.ARM_r4 = (unsigned long)arg;
+	regs.ARM_r5 = (unsigned long)fn;
+	regs.ARM_r6 = (unsigned long)kernel_thread_exit;
+	regs.ARM_r7 = SVC_MODE | PSR_ENDSTATE | PSR_ISETSTATE;
 	regs.ARM_pc = (unsigned long)kernel_thread_helper;
-	regs.ARM_cpsr = SVC_MODE | PSR_ENDSTATE | PSR_ISETSTATE;
+	regs.ARM_cpsr = regs.ARM_r7 | PSR_I_BIT;
 
 	return do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
 }

commit c743f38013aeff58ef6252601e397b5ba281c633
Author: Nicolas Pitre <nico@fluxnic.net>
Date:   Mon May 24 23:55:42 2010 -0400

    ARM: initial stack protector (-fstack-protector) support
    
    This is the very basic stuff without the changing canary upon
    task switch yet.  Just the Kconfig option and a constant canary
    value initialized at boot time.
    
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 1c6eb7ed9642..090ac9459da1 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -37,6 +37,12 @@
 #include <asm/stacktrace.h>
 #include <asm/mach/time.h>
 
+#ifdef CONFIG_CC_STACKPROTECTOR
+#include <linux/stackprotector.h>
+unsigned long __stack_chk_guard __read_mostly;
+EXPORT_SYMBOL(__stack_chk_guard);
+#endif
+
 static const char *processor_modes[] = {
   "USER_26", "FIQ_26" , "IRQ_26" , "SVC_26" , "UK4_26" , "UK5_26" , "UK6_26" , "UK7_26" ,
   "UK8_26" , "UK9_26" , "UK10_26", "UK11_26", "UK12_26", "UK13_26", "UK14_26", "UK15_26",

commit 990cb8acf23cab19a2930f1ed5e7dc108f89079b
Author: Nicolas Pitre <nico@fluxnic.net>
Date:   Mon Jun 14 16:27:19 2010 -0400

    [ARM] implement arch_randomize_brk()
    
    For this feature to take effect, CONFIG_COMPAT_BRK must be turned
    off.  This can safely be turned off for any EABI user space versions.
    
    Signed-off-by: Nicolas Pitre <nicolas.pitre@linaro.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index acf5e6fdb6dc..1c6eb7ed9642 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -28,6 +28,7 @@
 #include <linux/tick.h>
 #include <linux/utsname.h>
 #include <linux/uaccess.h>
+#include <linux/random.h>
 
 #include <asm/leds.h>
 #include <asm/processor.h>
@@ -421,3 +422,9 @@ unsigned long get_wchan(struct task_struct *p)
 	} while (count ++ < 16);
 	return 0;
 }
+
+unsigned long arch_randomize_brk(struct mm_struct *mm)
+{
+	unsigned long range_end = mm->brk + 0x02000000;
+	return randomize_range(mm->brk, range_end, 0) ? : mm->brk;
+}

commit 4260415f6a3b92c5c986398d96c314df37a4ccbf
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Apr 19 10:15:03 2010 +0100

    ARM: fix build error in arch/arm/kernel/process.c
    
    /tmp/ccJ3ssZW.s: Assembler messages:
    /tmp/ccJ3ssZW.s:1952: Error: can't resolve `.text' {.text section} - `.LFB1077'
    
    This is caused because:
    
            .section .data
            .section .text
            .section .text
            .previous
    
    does not return us to the .text section, but the .data section; this
    makes use of .previous dangerous if the ordering of previous sections
    is not known.
    
    Fix up the other users of .previous; .pushsection and .popsection are
    a safer pairing to use than .section and .previous.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 0e12e0acbf26..acf5e6fdb6dc 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -355,7 +355,7 @@ EXPORT_SYMBOL(dump_fpu);
  * the thread function, and r3 points to the exit function.
  */
 extern void kernel_thread_helper(void);
-asm(	".section .text\n"
+asm(	".pushsection .text\n"
 "	.align\n"
 "	.type	kernel_thread_helper, #function\n"
 "kernel_thread_helper:\n"
@@ -363,11 +363,11 @@ asm(	".section .text\n"
 "	mov	lr, r3\n"
 "	mov	pc, r2\n"
 "	.size	kernel_thread_helper, . - kernel_thread_helper\n"
-"	.previous");
+"	.popsection");
 
 #ifdef CONFIG_ARM_UNWIND
 extern void kernel_thread_exit(long code);
-asm(	".section .text\n"
+asm(	".pushsection .text\n"
 "	.align\n"
 "	.type	kernel_thread_exit, #function\n"
 "kernel_thread_exit:\n"
@@ -377,7 +377,7 @@ asm(	".section .text\n"
 "	nop\n"
 "	.fnend\n"
 "	.size	kernel_thread_exit, . - kernel_thread_exit\n"
-"	.previous");
+"	.popsection");
 #else
 #define kernel_thread_exit	do_exit
 #endif

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index ba2adefa53f7..0e12e0acbf26 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -16,7 +16,6 @@
 #include <linux/mm.h>
 #include <linux/stddef.h>
 #include <linux/unistd.h>
-#include <linux/slab.h>
 #include <linux/user.h>
 #include <linux/delay.h>
 #include <linux/reboot.h>

commit 22325525d8bb1478daddefec1b762e7882bcd515
Author: Rabin Vincent <rabin@rab.in>
Date:   Fri Jan 8 16:59:34 2010 +0100

    ARM: 5868/1: ARM: fix "BUG: using smp_processor_id() in preemptible code"
    
    Fix the following warning, which appears when the register dump for a
    faulting process is printed in a kernel with SMP, DEBUG_PREEMPT, and
    DEBUG_USER (with user_debug=31) enabled:
    
    BUG: using smp_processor_id() in preemptible [00000000] code: init/1
    caller is __show_regs+0x18/0x234
    Backtrace:
    [<c0159e5c>] (dump_backtrace+0x0/0x114) from [<c01faf30>] (dump_stack+0x18/0x1c)
     r6:c781a000 r5:c0157544 r4:00000001 r3:00000000
    [<c01faf18>] (dump_stack+0x0/0x1c) from [<c01e5230>] (debug_smp_processor_id+0xc4/0xf8)
    [<c01e516c>] (debug_smp_processor_id+0x0/0xf8) from [<c0157544>] (__show_regs+0x18/0x234)
     r6:c781bfb0 r5:00000000 r4:c781bfb0 r3:00000000
    [<c015752c>] (__show_regs+0x0/0x234) from [<c01577a0>] (show_regs+0x40/0x50)
    [<c0157760>] (show_regs+0x0/0x50) from [<c015c968>] (__do_user_fault+0x5c/0xa4)
     r4:c781c000 r3:00000000
    [<c015c90c>] (__do_user_fault+0x0/0xa4) from [<c015cbe0>] (do_page_fault+0x1b4/0x1e4)
     r7:00000000 r6:00010000 r5:c781bfb0 r4:c781c000
    [<c015ca2c>] (do_page_fault+0x0/0x1e4) from [<c01554c8>] (do_DataAbort+0x3c/0xa0)
    [<c015548c>] (do_DataAbort+0x0/0xa0) from [<c01560c4>] (ret_from_exception+0x0/0x10)
    
    Signed-off-by: Rabin Vincent <rabin@rab.in>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 67304138a2ca..ba2adefa53f7 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -212,7 +212,8 @@ void __show_regs(struct pt_regs *regs)
 	char buf[64];
 
 	printk("CPU: %d    %s  (%s %.*s)\n",
-		smp_processor_id(), print_tainted(), init_utsname()->release,
+		raw_smp_processor_id(), print_tainted(),
+		init_utsname()->release,
 		(int)strcspn(init_utsname()->version, " "),
 		init_utsname()->version);
 	print_symbol("PC is at %s\n", instruction_pointer(regs));

commit 797245f5da543074ee7db0e0516da744c89aa17f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Dec 18 14:34:43 2009 +0000

    ARM: Convert VFP/Crunch/XscaleCP thread_release() to exit_thread()
    
    This avoids races in the VFP code where the dead thread may have
    state on another CPU.  By moving this code to exit_thread(), we
    will be running as the thread, and therefore be running on the
    current CPU.
    
    This means that we can ensure that the only local state is accessed
    in the thread notifiers.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 0d96d0171c05..67304138a2ca 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -274,17 +274,18 @@ void show_regs(struct pt_regs * regs)
 	__backtrace();
 }
 
+ATOMIC_NOTIFIER_HEAD(thread_notify_head);
+
+EXPORT_SYMBOL_GPL(thread_notify_head);
+
 /*
  * Free current thread data structures etc..
  */
 void exit_thread(void)
 {
+	thread_notify(THREAD_NOTIFY_EXIT, current_thread_info());
 }
 
-ATOMIC_NOTIFIER_HEAD(thread_notify_head);
-
-EXPORT_SYMBOL_GPL(thread_notify_head);
-
 void flush_thread(void)
 {
 	struct thread_info *thread = current_thread_info();
@@ -299,9 +300,6 @@ void flush_thread(void)
 
 void release_thread(struct task_struct *dead_task)
 {
-	struct thread_info *thread = task_thread_info(dead_task);
-
-	thread_notify(THREAD_NOTIFY_RELEASE, thread);
 }
 
 asmlinkage void ret_from_fork(void) __asm__("ret_from_fork");

commit cde3f8607350666c4dd120dbbdbd9c70ffb2ea61
Author: Artem Bityutskiy <dedekind1@gmail.com>
Date:   Tue Oct 13 08:54:30 2009 +0100

    ARM: 5759/1: Add register information of threads to coredump
    
    Defines ELF_CORE_COPY_TASK_REGS so that CPU register information
    of every thread is included in coredump. Without this, only the faulting
    thread is coredumped.
    
    Cc: Roger Quadros <ext-roger.quadros@nokia.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Mika Westerberg <mika.westerberg@iki.fi>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 790fbee92ec5..0d96d0171c05 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -327,6 +327,15 @@ copy_thread(unsigned long clone_flags, unsigned long stack_start,
 	return 0;
 }
 
+/*
+ * Fill in the task's elfregs structure for a core dump.
+ */
+int dump_task_regs(struct task_struct *t, elf_gregset_t *elfregs)
+{
+	elf_core_copy_regs(elfregs, task_pt_regs(t));
+	return 1;
+}
+
 /*
  * fill in the fpe structure for a core dump...
  */

commit b86040a59feb255a8193173caa4d5199464433d5
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Fri Jul 24 12:32:54 2009 +0100

    Thumb-2: Implementation of the unified start-up and exceptions code
    
    This patch implements the ARM/Thumb-2 unified kernel start-up and
    exception handling code.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 39196dff478c..790fbee92ec5 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -388,7 +388,7 @@ pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
 	regs.ARM_r2 = (unsigned long)fn;
 	regs.ARM_r3 = (unsigned long)kernel_thread_exit;
 	regs.ARM_pc = (unsigned long)kernel_thread_helper;
-	regs.ARM_cpsr = SVC_MODE | PSR_ENDSTATE;
+	regs.ARM_cpsr = SVC_MODE | PSR_ENDSTATE | PSR_ISETSTATE;
 
 	return do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
 }

commit 9ccdac3662dbf3c75e8f8851a214bdf7d365a4bd
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Jun 22 22:34:55 2009 +0100

    [ARM] idle: clean up pm_idle calling, obey hlt_counter
    
    pm_idle is used by infrastructure (eg, cpuidle) which expects architectures
    to call it in a certain way.  Arrange for ARM to follow x86's lead on this
    and call pm_idle() with interrupts already disabled.  However, we expect
    pm_idle() to enable interrupts before it returns.
    
    Also, OMAP wants to be able to disable hlt-ing, so allow hlt_counter to
    prevent all calls to pm_idle.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 56820cce91a4..39196dff478c 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -114,9 +114,6 @@ void arm_machine_restart(char mode, const char *cmd)
 /*
  * Function pointers to optional machine specific functions
  */
-void (*pm_idle)(void);
-EXPORT_SYMBOL(pm_idle);
-
 void (*pm_power_off)(void);
 EXPORT_SYMBOL(pm_power_off);
 
@@ -130,20 +127,19 @@ EXPORT_SYMBOL_GPL(arm_pm_restart);
  */
 static void default_idle(void)
 {
-	if (hlt_counter)
-		cpu_relax();
-	else {
-		local_irq_disable();
-		if (!need_resched())
-			arch_idle();
-		local_irq_enable();
-	}
+	if (!need_resched())
+		arch_idle();
+	local_irq_enable();
 }
 
+void (*pm_idle)(void) = default_idle;
+EXPORT_SYMBOL(pm_idle);
+
 /*
- * The idle thread.  We try to conserve power, while trying to keep
- * overall latency low.  The architecture specific idle is passed
- * a value to indicate the level of "idleness" of the system.
+ * The idle thread, has rather strange semantics for calling pm_idle,
+ * but this is what x86 does and we need to do the same, so that
+ * things like cpuidle get called in the same way.  The only difference
+ * is that we always respect 'hlt_counter' to prevent low power idle.
  */
 void cpu_idle(void)
 {
@@ -151,21 +147,31 @@ void cpu_idle(void)
 
 	/* endless idle loop with no priority at all */
 	while (1) {
-		void (*idle)(void) = pm_idle;
-
+		tick_nohz_stop_sched_tick(1);
+		leds_event(led_idle_start);
+		while (!need_resched()) {
 #ifdef CONFIG_HOTPLUG_CPU
-		if (cpu_is_offline(smp_processor_id())) {
-			leds_event(led_idle_start);
-			cpu_die();
-		}
+			if (cpu_is_offline(smp_processor_id()))
+				cpu_die();
 #endif
 
-		if (!idle)
-			idle = default_idle;
-		leds_event(led_idle_start);
-		tick_nohz_stop_sched_tick(1);
-		while (!need_resched())
-			idle();
+			local_irq_disable();
+			if (hlt_counter) {
+				local_irq_enable();
+				cpu_relax();
+			} else {
+				stop_critical_timings();
+				pm_idle();
+				start_critical_timings();
+				/*
+				 * This will eventually be removed - pm_idle
+				 * functions should always return with IRQs
+				 * enabled.
+				 */
+				WARN_ON(irqs_disabled());
+				local_irq_enable();
+			}
+		}
 		leds_event(led_idle_end);
 		tick_nohz_restart_sched_tick();
 		preempt_enable_no_resched();

commit feb97c3644a560ffdf9a17c65b1df807b5b4432f
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Fri Jun 19 16:43:08 2009 +0100

    [ARM] 5559/1: Limit the stack unwinding caused by a kthread exit
    
    When a kthread function returns, it branches to do_exit(). However, the
    unwinding information isn't valid anymore and any stack trace caused by
    do_exit() may be incorrect. This patch adds a kernel_thread_exit()
    function and annotated with '.cantunwind' so that the unwinder stops
    when reaching it.
    
    Tested-by: Tony Lindgren <tony@atomide.com>
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 1585423699ee..56820cce91a4 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -352,6 +352,23 @@ asm(	".section .text\n"
 "	.size	kernel_thread_helper, . - kernel_thread_helper\n"
 "	.previous");
 
+#ifdef CONFIG_ARM_UNWIND
+extern void kernel_thread_exit(long code);
+asm(	".section .text\n"
+"	.align\n"
+"	.type	kernel_thread_exit, #function\n"
+"kernel_thread_exit:\n"
+"	.fnstart\n"
+"	.cantunwind\n"
+"	bl	do_exit\n"
+"	nop\n"
+"	.fnend\n"
+"	.size	kernel_thread_exit, . - kernel_thread_exit\n"
+"	.previous");
+#else
+#define kernel_thread_exit	do_exit
+#endif
+
 /*
  * Create a kernel thread.
  */
@@ -363,7 +380,7 @@ pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
 
 	regs.ARM_r1 = (unsigned long)arg;
 	regs.ARM_r2 = (unsigned long)fn;
-	regs.ARM_r3 = (unsigned long)do_exit;
+	regs.ARM_r3 = (unsigned long)kernel_thread_exit;
 	regs.ARM_pc = (unsigned long)kernel_thread_helper;
 	regs.ARM_cpsr = SVC_MODE | PSR_ENDSTATE;
 

commit 26584853a44c58f3d6ac7360d697a2ddcd1a3efa
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Sat May 30 14:00:18 2009 +0100

    Add core support for ARMv6/v7 big-endian
    
    Starting with ARMv6, the CPUs support the BE-8 variant of big-endian
    (byte-invariant). This patch adds the core support:
    
    - setting of the BE-8 mode via the CPSR.E register for both kernel and
      user threads
    - big-endian page table walking
    - REV used to rotate instructions read from memory during fault
      processing as they are still little-endian format
    - Kconfig and Makefile support for BE-8. The --be8 option must be passed
      to the final linking stage to convert the instructions to
      little-endian
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index c3265a2e7cd4..1585423699ee 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -365,7 +365,7 @@ pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
 	regs.ARM_r2 = (unsigned long)fn;
 	regs.ARM_r3 = (unsigned long)do_exit;
 	regs.ARM_pc = (unsigned long)kernel_thread_helper;
-	regs.ARM_cpsr = SVC_MODE;
+	regs.ARM_cpsr = SVC_MODE | PSR_ENDSTATE;
 
 	return do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
 }

commit 6f2c55b843836d26528c56a0968689accaedbc67
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Thu Apr 2 16:56:59 2009 -0700

    Simplify copy_thread()
    
    First argument unused since 2.3.11.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 2de14e2afdc5..c3265a2e7cd4 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -301,7 +301,7 @@ void release_thread(struct task_struct *dead_task)
 asmlinkage void ret_from_fork(void) __asm__("ret_from_fork");
 
 int
-copy_thread(int nr, unsigned long clone_flags, unsigned long stack_start,
+copy_thread(unsigned long clone_flags, unsigned long stack_start,
 	    unsigned long stk_sz, struct task_struct *p, struct pt_regs *regs)
 {
 	struct thread_info *thread = task_thread_info(p);

commit be093beb608edf821b45fe00a8a080fb5c6ed4af
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Mar 19 16:20:24 2009 +0000

    [ARM] pass reboot command line to arch_reset()
    
    OMAP wishes to pass state to the boot loader upon reboot in order to
    instruct it whether to wait for USB-based reflashing or not.  There is
    already a facility to do this via the reboot() syscall, except we ignore
    the string passed to machine_restart().
    
    This patch fixes things to pass this string to arch_reset().  This means
    that we keep the reboot mode limited to telling the kernel _how_ to
    perform the reboot which should be independent of what we request the
    boot loader to do.
    
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index af377c73d90b..2de14e2afdc5 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -83,7 +83,7 @@ static int __init hlt_setup(char *__unused)
 __setup("nohlt", nohlt_setup);
 __setup("hlt", hlt_setup);
 
-void arm_machine_restart(char mode)
+void arm_machine_restart(char mode, const char *cmd)
 {
 	/*
 	 * Clean and disable cache, and turn off interrupts
@@ -100,7 +100,7 @@ void arm_machine_restart(char mode)
 	/*
 	 * Now call the architecture specific reboot code.
 	 */
-	arch_reset(mode);
+	arch_reset(mode, cmd);
 
 	/*
 	 * Whoops - the architecture was unable to reboot.
@@ -120,7 +120,7 @@ EXPORT_SYMBOL(pm_idle);
 void (*pm_power_off)(void);
 EXPORT_SYMBOL(pm_power_off);
 
-void (*arm_pm_restart)(char str) = arm_machine_restart;
+void (*arm_pm_restart)(char str, const char *cmd) = arm_machine_restart;
 EXPORT_SYMBOL_GPL(arm_pm_restart);
 
 
@@ -195,9 +195,9 @@ void machine_power_off(void)
 		pm_power_off();
 }
 
-void machine_restart(char * __unused)
+void machine_restart(char *cmd)
 {
-	arm_pm_restart(reboot_mode);
+	arm_pm_restart(reboot_mode, cmd);
 }
 
 void __show_regs(struct pt_regs *regs)

commit 2d7c11bfc91637e5f9bc5f8c9a82aaffcc0e97aa
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Wed Feb 11 13:07:53 2009 +0100

    [ARM] 5382/1: unwind: Reorganise the stacktrace support
    
    This patch changes the walk_stacktrace and its callers for easier
    integration of stack unwinding. The arch/arm/kernel/stacktrace.h file is
    also moved to arch/arm/include/asm/stacktrace.h.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index d3ea6fa89521..af377c73d90b 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -34,6 +34,7 @@
 #include <asm/processor.h>
 #include <asm/system.h>
 #include <asm/thread_notify.h>
+#include <asm/stacktrace.h>
 #include <asm/mach/time.h>
 
 static const char *processor_modes[] = {
@@ -372,23 +373,21 @@ EXPORT_SYMBOL(kernel_thread);
 
 unsigned long get_wchan(struct task_struct *p)
 {
-	unsigned long fp, lr;
-	unsigned long stack_start, stack_end;
+	struct stackframe frame;
 	int count = 0;
 	if (!p || p == current || p->state == TASK_RUNNING)
 		return 0;
 
-	stack_start = (unsigned long)end_of_stack(p);
-	stack_end = (unsigned long)task_stack_page(p) + THREAD_SIZE;
-
-	fp = thread_saved_fp(p);
+	frame.fp = thread_saved_fp(p);
+	frame.sp = thread_saved_sp(p);
+	frame.lr = 0;			/* recovered from the stack */
+	frame.pc = thread_saved_pc(p);
 	do {
-		if (fp < stack_start || fp > stack_end)
+		int ret = unwind_frame(&frame);
+		if (ret < 0)
 			return 0;
-		lr = ((unsigned long *)fp)[-1];
-		if (!in_sched_functions(lr))
-			return lr;
-		fp = *(unsigned long *) (fp - 12);
+		if (!in_sched_functions(frame.pc))
+			return frame.pc;
 	} while (count ++ < 16);
 	return 0;
 }

commit 33fa9b13285e76fb95d940120964562e4c7081c2
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Sep 6 11:35:55 2008 +0100

    [ARM] Convert asm/uaccess.h to linux/uaccess.h
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 2ce9a401c8f2..d3ea6fa89521 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -28,12 +28,12 @@
 #include <linux/pm.h>
 #include <linux/tick.h>
 #include <linux/utsname.h>
+#include <linux/uaccess.h>
 
 #include <asm/leds.h>
 #include <asm/processor.h>
 #include <asm/system.h>
 #include <asm/thread_notify.h>
-#include <asm/uaccess.h>
 #include <asm/mach/time.h>
 
 static const char *processor_modes[] = {

commit 1de765c1e940e23d83ec57035769e8af003f8796
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Sep 6 10:14:24 2008 +0100

    [ARM] remove pc_pointer()
    
    pc_pointer() was a function to mask the PC for 26-bit ARMs, which
    we no longer support.  Remove it.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index a2e75420858e..2ce9a401c8f2 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -385,7 +385,7 @@ unsigned long get_wchan(struct task_struct *p)
 	do {
 		if (fp < stack_start || fp > stack_end)
 			return 0;
-		lr = pc_pointer (((unsigned long *)fp)[-1]);
+		lr = ((unsigned long *)fp)[-1];
 		if (!in_sched_functions(lr))
 			return lr;
 		fp = *(unsigned long *) (fp - 12);

commit 09d9bae064724635df3920bcca47e077cfb23e76
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Sep 5 14:08:44 2008 +0100

    [ARM] sparse: fix several warnings
    
    arch/arm/kernel/process.c:270:6: warning: symbol 'show_fpregs' was not declared. Should it be static?
    
    This function isn't used, so can be removed.
    
    arch/arm/kernel/setup.c:532:9: warning: symbol 'len' shadows an earlier one
    arch/arm/kernel/setup.c:524:6: originally declared here
    
    A function containing two 'len's.
    
    arch/arm/mm/fault-armv.c:188:13: warning: symbol 'check_writebuffer_bugs' was not declared. Should it be static?
    arch/arm/mm/mmap.c:122:5: warning: symbol 'valid_phys_addr_range' was not declared. Should it be static?
    arch/arm/mm/mmap.c:137:5: warning: symbol 'valid_mmap_phys_addr_range' was not declared. Should it be static?
    
    Missing includes.
    
    arch/arm/kernel/traps.c:71:77: warning: Using plain integer as NULL pointer
    arch/arm/mm/ioremap.c:355:46: error: incompatible types in comparison expression (different address spaces)
    
    Sillies.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 3fd882337064..a2e75420858e 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -267,35 +267,6 @@ void show_regs(struct pt_regs * regs)
 	__backtrace();
 }
 
-void show_fpregs(struct user_fp *regs)
-{
-	int i;
-
-	for (i = 0; i < 8; i++) {
-		unsigned long *p;
-		char type;
-
-		p = (unsigned long *)(regs->fpregs + i);
-
-		switch (regs->ftype[i]) {
-			case 1: type = 'f'; break;
-			case 2: type = 'd'; break;
-			case 3: type = 'e'; break;
-			default: type = '?'; break;
-		}
-		if (regs->init_flag)
-			type = '?';
-
-		printk("  f%d(%c): %08lx %08lx %08lx%c",
-			i, type, p[0], p[1], p[2], i & 1 ? '\n' : ' ');
-	}
-			
-
-	printk("FPSR: %08lx FPCR: %08lx\n",
-		(unsigned long)regs->fpsr,
-		(unsigned long)regs->fpcr);
-}
-
 /*
  * Free current thread data structures etc..
  */

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 89bfded70a1f..3fd882337064 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -51,7 +51,7 @@ extern void setup_mm_for_reboot(char mode);
 
 static volatile int hlt_counter;
 
-#include <asm/arch/system.h>
+#include <mach/system.h>
 
 void disable_hlt(void)
 {

commit 9b610fda0df5d0f0b0c64242e37441ad1b384aac
Merge: b8f8c3cf0a4a 5b664cb235e9
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Jul 18 19:53:16 2008 +0200

    Merge branch 'linus' into timers/nohz

commit b8f8c3cf0a4ac0632ec3f0e15e9dc0c29de917af
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 18 17:27:28 2008 +0200

    nohz: prevent tick stop outside of the idle loop
    
    Jack Ren and Eric Miao tracked down the following long standing
    problem in the NOHZ code:
    
            scheduler switch to idle task
            enable interrupts
    
    Window starts here
    
            ----> interrupt happens (does not set NEED_RESCHED)
                    irq_exit() stops the tick
    
            ----> interrupt happens (does set NEED_RESCHED)
    
            return from schedule()
    
            cpu_idle(): preempt_disable();
    
    Window ends here
    
    The interrupts can happen at any point inside the race window. The
    first interrupt stops the tick, the second one causes the scheduler to
    rerun and switch away from idle again and we end up with the tick
    disabled.
    
    The fact that it needs two interrupts where the first one does not set
    NEED_RESCHED and the second one does made the bug obscure and extremly
    hard to reproduce and analyse. Kudos to Jack and Eric.
    
    Solution: Limit the NOHZ functionality to the idle loop to make sure
    that we can not run into such a situation ever again.
    
    cpu_idle()
    {
            preempt_disable();
    
            while(1) {
                     tick_nohz_stop_sched_tick(1); <- tell NOHZ code that we
                                                      are in the idle loop
    
                     while (!need_resched())
                           halt();
    
                     tick_nohz_restart_sched_tick(); <- disables NOHZ mode
                     preempt_enable_no_resched();
                     schedule();
                     preempt_disable();
            }
    }
    
    In hindsight we should have done this forever, but ...
    
    /me grabs a large brown paperbag.
    
    Debugged-by: Jack Ren <jack.ren@marvell.com>,
    Debugged-by: eric miao <eric.y.miao@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 46bf2ede6128..84f5a4c778fb 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -164,7 +164,7 @@ void cpu_idle(void)
 		if (!idle)
 			idle = default_idle;
 		leds_event(led_idle_start);
-		tick_nohz_stop_sched_tick();
+		tick_nohz_stop_sched_tick(1);
 		while (!need_resched())
 			idle();
 		leds_event(led_idle_end);

commit 205bee6ad804d7034773b5978c74dde495df2301
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Apr 20 13:57:26 2008 +0100

    [ARM] dyntick: Remove obsolete and unused ARM dyntick support
    
    dyntick is superseded by the clocksource/clockevent infrastructure,
    using the NO_HZ configuration option.  No one implements dyntick on
    ARM anymore, so it's pointless keeping it around.  Remove dyntick
    support.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 46bf2ede6128..199b3680118b 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -133,10 +133,8 @@ static void default_idle(void)
 		cpu_relax();
 	else {
 		local_irq_disable();
-		if (!need_resched()) {
-			timer_dyn_reprogram();
+		if (!need_resched())
 			arch_idle();
-		}
 		local_irq_enable();
 	}
 }

commit 1eb114112381eb66ebacdace1b6e70d30d603f9c
Author: David Howells <dhowells@redhat.com>
Date:   Fri Feb 8 04:19:29 2008 -0800

    aout: remove unnecessary inclusions of {asm, linux}/a.out.h
    
    Remove now unnecessary inclusions of {asm,linux}/a.out.h.
    
    [akpm@linux-foundation.org: fix alpha build]
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 436380a5f4c7..46bf2ede6128 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -18,7 +18,6 @@
 #include <linux/unistd.h>
 #include <linux/slab.h>
 #include <linux/user.h>
-#include <linux/a.out.h>
 #include <linux/delay.h>
 #include <linux/reboot.h>
 #include <linux/interrupt.h>

commit 7fa3031500ec9b0a7460c8c23751799006ffee74
Author: David Howells <dhowells@redhat.com>
Date:   Fri Feb 8 04:19:28 2008 -0800

    aout: suppress A.OUT library support if !CONFIG_ARCH_SUPPORTS_AOUT
    
    Suppress A.OUT library support if CONFIG_ARCH_SUPPORTS_AOUT is not set.
    
    Not all architectures support the A.OUT binfmt, so the ELF binfmt should not
    be permitted to go looking for A.OUT libraries to load in such a case.  Not
    only that, but under such conditions A.OUT core dumps are not produced either.
    
    To make this work, this patch also does the following:
    
     (1) Makes the existence of the contents of linux/a.out.h contingent on
         CONFIG_ARCH_SUPPORTS_AOUT.
    
     (2) Renames dump_thread() to aout_dump_thread() as it's only called by A.OUT
         core dumping code.
    
     (3) Moves aout_dump_thread() into asm/a.out-core.h and makes it inline.  This
         is then included only where needed.  This means that this bit of arch
         code will be stored in the appropriate A.OUT binfmt module rather than
         the core kernel.
    
     (4) Drops A.OUT support for Blackfin (according to Mike Frysinger it's not
         needed) and FRV.
    
    This patch depends on the previous patch to move STACK_TOP[_MAX] out of
    asm/a.out.h and into asm/processor.h as they're required whether or not A.OUT
    format is available.
    
    [jdike@addtoit.com: uml: re-remove accidentally restored code]
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Jeff Dike <jdike@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 4f1a03124a74..436380a5f4c7 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -367,35 +367,6 @@ int dump_fpu (struct pt_regs *regs, struct user_fp *fp)
 }
 EXPORT_SYMBOL(dump_fpu);
 
-/*
- * fill in the user structure for a core dump..
- */
-void dump_thread(struct pt_regs * regs, struct user * dump)
-{
-	struct task_struct *tsk = current;
-
-	dump->magic = CMAGIC;
-	dump->start_code = tsk->mm->start_code;
-	dump->start_stack = regs->ARM_sp & ~(PAGE_SIZE - 1);
-
-	dump->u_tsize = (tsk->mm->end_code - tsk->mm->start_code) >> PAGE_SHIFT;
-	dump->u_dsize = (tsk->mm->brk - tsk->mm->start_data + PAGE_SIZE - 1) >> PAGE_SHIFT;
-	dump->u_ssize = 0;
-
-	dump->u_debugreg[0] = tsk->thread.debug.bp[0].address;
-	dump->u_debugreg[1] = tsk->thread.debug.bp[1].address;
-	dump->u_debugreg[2] = tsk->thread.debug.bp[0].insn.arm;
-	dump->u_debugreg[3] = tsk->thread.debug.bp[1].insn.arm;
-	dump->u_debugreg[4] = tsk->thread.debug.nsaved;
-
-	if (dump->start_stack < 0x04000000)
-		dump->u_ssize = (0x04000000 - dump->start_stack) >> PAGE_SHIFT;
-
-	dump->regs = *regs;
-	dump->u_fpvalid = dump_fpu (regs, &dump->u_fp);
-}
-EXPORT_SYMBOL(dump_thread);
-
 /*
  * Shuffle the argument into the correct register before calling the
  * thread function.  r1 is the thread argument, r2 is the pointer to

commit 19c5870c0eefd27c6d09d867465e0571262e05d0
Author: Alexey Dobriyan <adobriyan@openvz.org>
Date:   Thu Oct 18 23:40:41 2007 -0700

    Use helpers to obtain task pid in printks (arch code)
    
    One of the easiest things to isolate is the pid printed in kernel log.
    There was a patch, that made this for arch-independent code, this one makes
    so for arch/xxx files.
    
    It took some time to cross-compile it, but hopefully these are all the
    printks in arch code.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@openvz.org>
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 93b7f8e22dcc..4f1a03124a74 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -265,7 +265,7 @@ void __show_regs(struct pt_regs *regs)
 void show_regs(struct pt_regs * regs)
 {
 	printk("\n");
-	printk("Pid: %d, comm: %20s\n", current->pid, current->comm);
+	printk("Pid: %d, comm: %20s\n", task_pid_nr(current), current->comm);
 	__show_regs(regs);
 	__backtrace();
 }

commit 909d6c6c80311f800aee338e5fa528818b115951
Author: George G. Davis <gdavis@mvista.com>
Date:   Tue Jun 26 01:38:27 2007 +0100

    [ARM] 4453/1: Fully Decode ARM instruction set state in show_regs() tombstone
    
    The ARM show_regs() tombstone only partially decodes which ARM ISA was
    executing at the time a fault occurred displaying either "(T)" for the
    Thumb case or nothing at all for other cases.  This patch therefore
    explicitly identifies which state the processor is in at the time of
    a fault: ARM, Thumb, Jazelle or JazelleEE.
    
    Signed-off-by: George G. Davis <gdavis@mvista.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 842361777d4e..93b7f8e22dcc 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -44,6 +44,10 @@ static const char *processor_modes[] = {
   "UK8_32" , "UK9_32" , "UK10_32", "UND_32" , "UK12_32", "UK13_32", "UK14_32", "SYS_32"
 };
 
+static const char *isa_modes[] = {
+  "ARM" , "Thumb" , "Jazelle", "ThumbEE"
+};
+
 extern void setup_mm_for_reboot(char mode);
 
 static volatile int hlt_counter;
@@ -230,11 +234,11 @@ void __show_regs(struct pt_regs *regs)
 	buf[3] = flags & PSR_V_BIT ? 'V' : 'v';
 	buf[4] = '\0';
 
-	printk("Flags: %s  IRQs o%s  FIQs o%s  Mode %s%s  Segment %s\n",
+	printk("Flags: %s  IRQs o%s  FIQs o%s  Mode %s  ISA %s  Segment %s\n",
 		buf, interrupts_enabled(regs) ? "n" : "ff",
 		fast_interrupts_enabled(regs) ? "n" : "ff",
 		processor_modes[processor_mode(regs)],
-		thumb_mode(regs) ? " (T)" : "",
+		isa_modes[isa_mode(regs)],
 		get_fs() == get_ds() ? "kernel" : "user");
 #ifdef CONFIG_CPU_CP15
 	{

commit 154c772ebfb12ef66855510e6be2b12c85110b0c
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Jun 18 14:59:45 2007 +0100

    [ARM] Update show_regs/oops register format
    
    Add the kernel release and version information to the output of
    show_regs/oops.  Add the CPU PSR register.  Avoid using printk
    to output partial lines; always output a complete line.
    
    Re-combine the "Control" and "Table + DAC" lines after nommu
    separated them; we don't want to waste vertical screen space
    needlessly.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 5d6e6523598b..842361777d4e 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -28,6 +28,7 @@
 #include <linux/elfcore.h>
 #include <linux/pm.h>
 #include <linux/tick.h>
+#include <linux/utsname.h>
 
 #include <asm/leds.h>
 #include <asm/processor.h>
@@ -199,16 +200,19 @@ void machine_restart(char * __unused)
 
 void __show_regs(struct pt_regs *regs)
 {
-	unsigned long flags = condition_codes(regs);
+	unsigned long flags;
+	char buf[64];
 
-	printk("CPU: %d\n", smp_processor_id());
+	printk("CPU: %d    %s  (%s %.*s)\n",
+		smp_processor_id(), print_tainted(), init_utsname()->release,
+		(int)strcspn(init_utsname()->version, " "),
+		init_utsname()->version);
 	print_symbol("PC is at %s\n", instruction_pointer(regs));
 	print_symbol("LR is at %s\n", regs->ARM_lr);
-	printk("pc : [<%08lx>]    lr : [<%08lx>]    %s\n"
+	printk("pc : [<%08lx>]    lr : [<%08lx>]    psr: %08lx\n"
 	       "sp : %08lx  ip : %08lx  fp : %08lx\n",
-		instruction_pointer(regs),
-		regs->ARM_lr, print_tainted(), regs->ARM_sp,
-		regs->ARM_ip, regs->ARM_fp);
+		regs->ARM_pc, regs->ARM_lr, regs->ARM_cpsr,
+		regs->ARM_sp, regs->ARM_ip, regs->ARM_fp);
 	printk("r10: %08lx  r9 : %08lx  r8 : %08lx\n",
 		regs->ARM_r10, regs->ARM_r9,
 		regs->ARM_r8);
@@ -218,36 +222,39 @@ void __show_regs(struct pt_regs *regs)
 	printk("r3 : %08lx  r2 : %08lx  r1 : %08lx  r0 : %08lx\n",
 		regs->ARM_r3, regs->ARM_r2,
 		regs->ARM_r1, regs->ARM_r0);
-	printk("Flags: %c%c%c%c",
-		flags & PSR_N_BIT ? 'N' : 'n',
-		flags & PSR_Z_BIT ? 'Z' : 'z',
-		flags & PSR_C_BIT ? 'C' : 'c',
-		flags & PSR_V_BIT ? 'V' : 'v');
-	printk("  IRQs o%s  FIQs o%s  Mode %s%s  Segment %s\n",
-		interrupts_enabled(regs) ? "n" : "ff",
+
+	flags = regs->ARM_cpsr;
+	buf[0] = flags & PSR_N_BIT ? 'N' : 'n';
+	buf[1] = flags & PSR_Z_BIT ? 'Z' : 'z';
+	buf[2] = flags & PSR_C_BIT ? 'C' : 'c';
+	buf[3] = flags & PSR_V_BIT ? 'V' : 'v';
+	buf[4] = '\0';
+
+	printk("Flags: %s  IRQs o%s  FIQs o%s  Mode %s%s  Segment %s\n",
+		buf, interrupts_enabled(regs) ? "n" : "ff",
 		fast_interrupts_enabled(regs) ? "n" : "ff",
 		processor_modes[processor_mode(regs)],
 		thumb_mode(regs) ? " (T)" : "",
 		get_fs() == get_ds() ? "kernel" : "user");
-#if CONFIG_CPU_CP15
+#ifdef CONFIG_CPU_CP15
 	{
 		unsigned int ctrl;
-		  __asm__ (
-		"	mrc p15, 0, %0, c1, c0\n"
-		: "=r" (ctrl));
-		printk("Control: %04X\n", ctrl);
-	}
+
+		buf[0] = '\0';
 #ifdef CONFIG_CPU_CP15_MMU
-	{
-		unsigned int transbase, dac;
-		  __asm__ (
-		"	mrc p15, 0, %0, c2, c0\n"
-		"	mrc p15, 0, %1, c3, c0\n"
-		: "=r" (transbase), "=r" (dac));
-		printk("Table: %08X  DAC: %08X\n",
-		  	transbase, dac);
-	}
+		{
+			unsigned int transbase, dac;
+			asm("mrc p15, 0, %0, c2, c0\n\t"
+			    "mrc p15, 0, %1, c3, c0\n"
+			    : "=r" (transbase), "=r" (dac));
+			snprintf(buf, sizeof(buf), "  Table: %08x  DAC: %08x",
+			  	transbase, dac);
+		}
 #endif
+		asm("mrc p15, 0, %0, c1, c0\n" : "=r" (ctrl));
+
+		printk("Control: %08x%s\n", ctrl, buf);
+	}
 #endif
 }
 

commit 9e4559ddffc012a73ea0b54ed3b6a219c1483ae9
Author: Kevin Hilman <khilman@mvista.com>
Date:   Wed Mar 14 17:33:24 2007 +0100

    [ARM] 4258/2: Support for dynticks in idle loop
    
    And, wrap timer_tick() and sysdev suspend/resume in
    !GENERIC_CLOCKEVENTS since clockevent layer takes care
    of these.
    
    Signed-off-by: Kevin Hilman <khilman@mvista.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 8afd83d0cbdd..5d6e6523598b 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -27,6 +27,7 @@
 #include <linux/cpu.h>
 #include <linux/elfcore.h>
 #include <linux/pm.h>
+#include <linux/tick.h>
 
 #include <asm/leds.h>
 #include <asm/processor.h>
@@ -159,9 +160,11 @@ void cpu_idle(void)
 		if (!idle)
 			idle = default_idle;
 		leds_event(led_idle_start);
+		tick_nohz_stop_sched_tick();
 		while (!need_resched())
 			idle();
 		leds_event(led_idle_end);
+		tick_nohz_restart_sched_tick();
 		preempt_enable_no_resched();
 		schedule();
 		preempt_disable();

commit 0f0a00beb80624a446ba7c0152cd171008eeab2e
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Mar 3 19:45:25 2007 +0000

    [ARM] Remove needless linux/ptrace.h includes
    
    Lots of places in arch/arm were needlessly including linux/ptrace.h,
    resumably because we used to pass a struct pt_regs to interrupt
    handlers.  Now that we don't, all these ptrace.h includes are
    redundant.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 782af3cb213f..8afd83d0cbdd 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -16,7 +16,6 @@
 #include <linux/mm.h>
 #include <linux/stddef.h>
 #include <linux/unistd.h>
-#include <linux/ptrace.h>
 #include <linux/slab.h>
 #include <linux/user.h>
 #include <linux/a.out.h>

commit ae0a846e411dc0b568e8ccda584896310ee5f369
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Jan 9 12:57:37 2007 +0000

    [ARM] Move processor_modes[] to .../process.c
    
    bad_mode() currently prints the mode which caused the exception, and
    then causes an oops dump to be printed which again displays this
    information (since the CPSR in the struct pt_regs is correct.)  This
    leads to processor_modes[] being shared between traps.c and process.c
    with a local declaration of it.
    
    We can clean this up by moving processor_modes[] to process.c and
    removing the duplication, resulting in processor_modes[] becoming
    static.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index a9e8f7e55fd6..782af3cb213f 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -36,7 +36,13 @@
 #include <asm/uaccess.h>
 #include <asm/mach/time.h>
 
-extern const char *processor_modes[];
+static const char *processor_modes[] = {
+  "USER_26", "FIQ_26" , "IRQ_26" , "SVC_26" , "UK4_26" , "UK5_26" , "UK6_26" , "UK7_26" ,
+  "UK8_26" , "UK9_26" , "UK10_26", "UK11_26", "UK12_26", "UK13_26", "UK14_26", "UK15_26",
+  "USER_32", "FIQ_32" , "IRQ_32" , "SVC_32" , "UK4_32" , "UK5_32" , "UK6_32" , "ABT_32" ,
+  "UK8_32" , "UK9_32" , "UK10_32", "UND_32" , "UK12_32", "UK13_32", "UK14_32", "SYS_32"
+};
+
 extern void setup_mm_for_reboot(char mode);
 
 static volatile int hlt_counter;

commit 122214428a7bfab2c09b417f3acdb06222e81748
Author: Paul Gortmaker <paul.gortmaker@gmail.com>
Date:   Thu Nov 2 16:41:18 2006 +0100

    [ARM] 3911/2: Simplify alloc_thread_info on ARM
    
    Remove ARM local cache of 4 struct thread_info.
    Can cause oops under certain circumstances.
    
    Russell indicated the original optimization was
    required on older kernels to avoid thread starvation
    on memory fragmentation, but may no longer be
    required.  I've updated the patch to 19rc4 and
    ensured no <config.h> dain-bramage slipped in this
    time (sorry about that).
    
    Original description follows:
    
    I was given some test results which pointed to an
    Oops in alloc_thread_info (happened 2x), and after
    looking at the code, I see that ARM has its own
    local cache of 4 struct thread_info. There wasn't
    any clear (to me) synchronization between the
    alloc_thread_info and the free_thread_info.
    
    I looked over the other arch, and they all simply
    allocate them on an as needed basis, so I simplified
    the ARM to do the same, based on the other arch
    (e.g. PPC) and the folks doing the testing have
    indicated that this fixed the oops.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index bf35c178a877..a9e8f7e55fd6 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -280,67 +280,6 @@ void show_fpregs(struct user_fp *regs)
 		(unsigned long)regs->fpcr);
 }
 
-/*
- * Task structure and kernel stack allocation.
- */
-struct thread_info_list {
-	unsigned long *head;
-	unsigned int nr;
-};
-
-static DEFINE_PER_CPU(struct thread_info_list, thread_info_list) = { NULL, 0 };
-
-#define EXTRA_TASK_STRUCT	4
-
-struct thread_info *alloc_thread_info(struct task_struct *task)
-{
-	struct thread_info *thread = NULL;
-
-	if (EXTRA_TASK_STRUCT) {
-		struct thread_info_list *th = &get_cpu_var(thread_info_list);
-		unsigned long *p = th->head;
-
-		if (p) {
-			th->head = (unsigned long *)p[0];
-			th->nr -= 1;
-		}
-		put_cpu_var(thread_info_list);
-
-		thread = (struct thread_info *)p;
-	}
-
-	if (!thread)
-		thread = (struct thread_info *)
-			   __get_free_pages(GFP_KERNEL, THREAD_SIZE_ORDER);
-
-#ifdef CONFIG_DEBUG_STACK_USAGE
-	/*
-	 * The stack must be cleared if you want SYSRQ-T to
-	 * give sensible stack usage information
-	 */
-	if (thread)
-		memzero(thread, THREAD_SIZE);
-#endif
-	return thread;
-}
-
-void free_thread_info(struct thread_info *thread)
-{
-	if (EXTRA_TASK_STRUCT) {
-		struct thread_info_list *th = &get_cpu_var(thread_info_list);
-		if (th->nr < EXTRA_TASK_STRUCT) {
-			unsigned long *p = (unsigned long *)thread;
-			p[0] = (unsigned long)th->head;
-			th->head = p;
-			th->nr += 1;
-			put_cpu_var(thread_info_list);
-			return;
-		}
-		put_cpu_var(thread_info_list);
-	}
-	free_pages((unsigned long)thread, THREAD_SIZE_ORDER);
-}
-
 /*
  * Free current thread data structures etc..
  */

commit f12d0d7c7786af39435ef6ae9defe47fb58f6091
Author: Hyok S. Choi <hyok.choi@samsung.com>
Date:   Tue Sep 26 17:36:37 2006 +0900

    [ARM] nommu: manage the CP15 things
    
    All the current CP15 access codes in ARM arch can be categorized and
    conditioned by the defines as follows:
    
         Related operation  Safe condition
      a. any CP15 access    !CPU_CP15
      b. alignment trap     CPU_CP15_MMU
      c. D-cache(C-bit)     CPU_CP15
      d. I-cache            CPU_CP15 && !( CPU_ARM610 || CPU_ARM710 ||
                                    CPU_ARM720 || CPU_ARM740 ||
                                    CPU_XSCALE || CPU_XSC3 )
      e. alternate vector   CPU_CP15 && !CPU_ARM740
      f. TTB                CPU_CP15_MMU
      g. Domain             CPU_CP15_MMU
      h. FSR/FAR            CPU_CP15_MMU
    
    For example, alternate vector is supported if and only if
    "CPU_CP15 && !CPU_ARM740" is satisfied.
    
    Signed-off-by: Hyok S. Choi <hyok.choi@samsung.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 3079535afccd..bf35c178a877 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -221,16 +221,26 @@ void __show_regs(struct pt_regs *regs)
 		processor_modes[processor_mode(regs)],
 		thumb_mode(regs) ? " (T)" : "",
 		get_fs() == get_ds() ? "kernel" : "user");
+#if CONFIG_CPU_CP15
 	{
-		unsigned int ctrl, transbase, dac;
+		unsigned int ctrl;
 		  __asm__ (
 		"	mrc p15, 0, %0, c1, c0\n"
-		"	mrc p15, 0, %1, c2, c0\n"
-		"	mrc p15, 0, %2, c3, c0\n"
-		: "=r" (ctrl), "=r" (transbase), "=r" (dac));
-		printk("Control: %04X  Table: %08X  DAC: %08X\n",
-		  	ctrl, transbase, dac);
+		: "=r" (ctrl));
+		printk("Control: %04X\n", ctrl);
 	}
+#ifdef CONFIG_CPU_CP15_MMU
+	{
+		unsigned int transbase, dac;
+		  __asm__ (
+		"	mrc p15, 0, %0, c2, c0\n"
+		"	mrc p15, 0, %1, c3, c0\n"
+		: "=r" (transbase), "=r" (dac));
+		printk("Table: %08X  DAC: %08X\n",
+		  	transbase, dac);
+	}
+#endif
+#endif
 }
 
 void show_regs(struct pt_regs * regs)

commit a8c4c20dfa8b28a3c99e33c639d9c2ea5657741e
Merge: 168d04b3b4de 2dc7667b9d06
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Sun Jul 2 15:04:12 2006 -0700

    Merge branch 'devel' of master.kernel.org:/home/rmk/linux-2.6-arm
    
    * 'devel' of master.kernel.org:/home/rmk/linux-2.6-arm: (44 commits)
      [ARM] 3541/2: workaround for PXA27x erratum E7
      [ARM] nommu: provide a way for correct control register value selection
      [ARM] 3705/1: add supersection support to ioremap()
      [ARM] 3707/1: iwmmxt: use the generic thread notifier infrastructure
      [ARM] 3706/2: ep93xx: add cirrus logic edb9315a support
      [ARM] 3704/1: format IOP Kconfig with tabs, create more consistency
      [ARM] 3703/1: Add help description for ARCH_EP80219
      [ARM] 3678/1: MMC: Make OMAP MMC work
      [ARM] 3677/1: OMAP: Update H2 defconfig
      [ARM] 3676/1: ARM: OMAP: Fix dmtimers and timer32k to compile on OMAP1
      [ARM] Add section support to ioremap
      [ARM] Fix sa11x0 SDRAM selection
      [ARM] Set bit 4 on section mappings correctly depending on CPU
      [ARM] 3666/1: TRIZEPS4 [1/5] core
      ARM: OMAP: Multiplexing for 24xx GPMC wait pin monitoring
      ARM: OMAP: Fix SRAM to use MT_MEMORY instead of MT_DEVICE
      ARM: OMAP: Update dmtimers
      ARM: OMAP: Make clock variables static
      ARM: OMAP: Fix GPMC compilation when DEBUG is defined
      ARM: OMAP: Mux updates for external DMA and GPIO
      ...

commit ae95bfbb2b67eba5d67a0478a8715682a87e2616
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Sat Jul 1 19:56:48 2006 +0100

    [ARM] 3707/1: iwmmxt: use the generic thread notifier infrastructure
    
    Patch from Lennert Buytenhek
    
    This patch makes the iWMMXt context switch hook use the generic
    thread notifier infrastructure that was recently merged in commit
    d6551e884cf66de072b81f8b6d23259462c40baf.
    
    Signed-off-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index e1c77ee885a7..b5773a2549ee 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -353,9 +353,6 @@ void flush_thread(void)
 	memset(&thread->fpstate, 0, sizeof(union fp_state));
 
 	thread_notify(THREAD_NOTIFY_FLUSH, thread);
-#if defined(CONFIG_IWMMXT)
-	iwmmxt_task_release(thread);
-#endif
 }
 
 void release_thread(struct task_struct *dead_task)
@@ -363,9 +360,6 @@ void release_thread(struct task_struct *dead_task)
 	struct thread_info *thread = task_thread_info(dead_task);
 
 	thread_notify(THREAD_NOTIFY_RELEASE, thread);
-#if defined(CONFIG_IWMMXT)
-	iwmmxt_task_release(thread);
-#endif
 }
 
 asmlinkage void ret_from_fork(void) __asm__("ret_from_fork");

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index e1c77ee885a7..c3258b763c5d 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -10,7 +10,6 @@
  */
 #include <stdarg.h>
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/kernel.h>

commit d6551e884cf66de072b81f8b6d23259462c40baf
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Jun 21 13:31:52 2006 +0100

    [ARM] Add thread_notify infrastructure
    
    Some machine classes need to allow VFP support to be built into the
    kernel, but still allow the kernel to run even though VFP isn't
    present.  Unfortunately, the kernel hard-codes VFP instructions
    into the thread switch, which prevents this being run-time selectable.
    
    Solve this by introducing a notifier which things such as VFP can
    hook into to be informed of events which affect the VFP subsystem
    (eg, creation and destruction of threads, switches between threads.)
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 17c38dbf2f3c..e1c77ee885a7 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -33,6 +33,7 @@
 #include <asm/leds.h>
 #include <asm/processor.h>
 #include <asm/system.h>
+#include <asm/thread_notify.h>
 #include <asm/uaccess.h>
 #include <asm/mach/time.h>
 
@@ -338,13 +339,9 @@ void exit_thread(void)
 {
 }
 
-static void default_fp_init(union fp_state *fp)
-{
-	memset(fp, 0, sizeof(union fp_state));
-}
+ATOMIC_NOTIFIER_HEAD(thread_notify_head);
 
-void (*fp_init)(union fp_state *) = default_fp_init;
-EXPORT_SYMBOL(fp_init);
+EXPORT_SYMBOL_GPL(thread_notify_head);
 
 void flush_thread(void)
 {
@@ -353,22 +350,21 @@ void flush_thread(void)
 
 	memset(thread->used_cp, 0, sizeof(thread->used_cp));
 	memset(&tsk->thread.debug, 0, sizeof(struct debug_info));
+	memset(&thread->fpstate, 0, sizeof(union fp_state));
+
+	thread_notify(THREAD_NOTIFY_FLUSH, thread);
 #if defined(CONFIG_IWMMXT)
 	iwmmxt_task_release(thread);
-#endif
-	fp_init(&thread->fpstate);
-#if defined(CONFIG_VFP)
-	vfp_flush_thread(&thread->vfpstate);
 #endif
 }
 
 void release_thread(struct task_struct *dead_task)
 {
-#if defined(CONFIG_VFP)
-	vfp_release_thread(&task_thread_info(dead_task)->vfpstate);
-#endif
+	struct thread_info *thread = task_thread_info(dead_task);
+
+	thread_notify(THREAD_NOTIFY_RELEASE, thread);
 #if defined(CONFIG_IWMMXT)
-	iwmmxt_task_release(task_thread_info(dead_task));
+	iwmmxt_task_release(thread);
 #endif
 }
 

commit 74617fb6b825ea370ae72565f7543306bc08ef6e
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Mon Jun 19 19:57:12 2006 +0100

    [ARM] 3593/1: Add reboot and shutdown handlers for Zaurus handhelds
    
    Patch from Richard Purdie
    
    Add functionality to allow machine specific reboot handlers on ARM.
    Add machine specific reboot and poweroff handlers for all PXA Zaurus
    models.
    
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 7df6e1aaa323..17c38dbf2f3c 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -28,6 +28,7 @@
 #include <linux/init.h>
 #include <linux/cpu.h>
 #include <linux/elfcore.h>
+#include <linux/pm.h>
 
 #include <asm/leds.h>
 #include <asm/processor.h>
@@ -71,8 +72,36 @@ static int __init hlt_setup(char *__unused)
 __setup("nohlt", nohlt_setup);
 __setup("hlt", hlt_setup);
 
+void arm_machine_restart(char mode)
+{
+	/*
+	 * Clean and disable cache, and turn off interrupts
+	 */
+	cpu_proc_fin();
+
+	/*
+	 * Tell the mm system that we are going to reboot -
+	 * we may need it to insert some 1:1 mappings so that
+	 * soft boot works.
+	 */
+	setup_mm_for_reboot(mode);
+
+	/*
+	 * Now call the architecture specific reboot code.
+	 */
+	arch_reset(mode);
+
+	/*
+	 * Whoops - the architecture was unable to reboot.
+	 * Tell the user!
+	 */
+	mdelay(1000);
+	printk("Reboot failed -- System halted\n");
+	while (1);
+}
+
 /*
- * The following aren't currently used.
+ * Function pointers to optional machine specific functions
  */
 void (*pm_idle)(void);
 EXPORT_SYMBOL(pm_idle);
@@ -80,6 +109,10 @@ EXPORT_SYMBOL(pm_idle);
 void (*pm_power_off)(void);
 EXPORT_SYMBOL(pm_power_off);
 
+void (*arm_pm_restart)(char str) = arm_machine_restart;
+EXPORT_SYMBOL_GPL(arm_pm_restart);
+
+
 /*
  * This is our default idle handler.  We need to disable
  * interrupts here to ensure we don't miss a wakeup call.
@@ -151,33 +184,9 @@ void machine_power_off(void)
 		pm_power_off();
 }
 
-
 void machine_restart(char * __unused)
 {
-	/*
-	 * Clean and disable cache, and turn off interrupts
-	 */
-	cpu_proc_fin();
-
-	/*
-	 * Tell the mm system that we are going to reboot -
-	 * we may need it to insert some 1:1 mappings so that
-	 * soft boot works.
-	 */
-	setup_mm_for_reboot(reboot_mode);
-
-	/*
-	 * Now call the architecture specific reboot code.
-	 */
-	arch_reset(reboot_mode);
-
-	/*
-	 * Whoops - the architecture was unable to reboot.
-	 * Tell the user!
-	 */
-	mdelay(1000);
-	printk("Reboot failed -- System halted\n");
-	while (1);
+	arm_pm_restart(reboot_mode);
 }
 
 void __show_regs(struct pt_regs *regs)

commit 9d494ccb9ca297f80dc61a0d6357e88c86f44e92
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue May 16 11:33:15 2006 +0100

    [ARM] arch/arm/kernel/process.c: Fix warning
    
    arch/arm/kernel/process.c:314: warning: assignment makes integer from pointer without a cast
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 1a1539e3a946..7df6e1aaa323 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -311,7 +311,7 @@ void free_thread_info(struct thread_info *thread)
 		struct thread_info_list *th = &get_cpu_var(thread_info_list);
 		if (th->nr < EXTRA_TASK_STRUCT) {
 			unsigned long *p = (unsigned long *)thread;
-			p[0] = th->head;
+			p[0] = (unsigned long)th->head;
 			th->head = p;
 			th->nr += 1;
 			put_cpu_var(thread_info_list);

commit 1929ab8c6860a4a94109eed038b0fa9d12c81721
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue May 9 22:14:28 2006 +0100

    [ARM] Fix thread struct allocator for SMP case
    
    The ARM thread struct allocator is racy on SMP systems.  Fix it by
    turning it into a per-cpu based allocator.  This also allows keeps
    the cache cache warm for thread structs and kernel stacks.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 1ff75cee4b0d..1a1539e3a946 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -264,8 +264,12 @@ void show_fpregs(struct user_fp *regs)
 /*
  * Task structure and kernel stack allocation.
  */
-static unsigned long *thread_info_head;
-static unsigned int nr_thread_info;
+struct thread_info_list {
+	unsigned long *head;
+	unsigned int nr;
+};
+
+static DEFINE_PER_CPU(struct thread_info_list, thread_info_list) = { NULL, 0 };
 
 #define EXTRA_TASK_STRUCT	4
 
@@ -274,12 +278,15 @@ struct thread_info *alloc_thread_info(struct task_struct *task)
 	struct thread_info *thread = NULL;
 
 	if (EXTRA_TASK_STRUCT) {
-		unsigned long *p = thread_info_head;
+		struct thread_info_list *th = &get_cpu_var(thread_info_list);
+		unsigned long *p = th->head;
 
 		if (p) {
-			thread_info_head = (unsigned long *)p[0];
-			nr_thread_info -= 1;
+			th->head = (unsigned long *)p[0];
+			th->nr -= 1;
 		}
+		put_cpu_var(thread_info_list);
+
 		thread = (struct thread_info *)p;
 	}
 
@@ -300,13 +307,19 @@ struct thread_info *alloc_thread_info(struct task_struct *task)
 
 void free_thread_info(struct thread_info *thread)
 {
-	if (EXTRA_TASK_STRUCT && nr_thread_info < EXTRA_TASK_STRUCT) {
-		unsigned long *p = (unsigned long *)thread;
-		p[0] = (unsigned long)thread_info_head;
-		thread_info_head = p;
-		nr_thread_info += 1;
-	} else
-		free_pages((unsigned long)thread, THREAD_SIZE_ORDER);
+	if (EXTRA_TASK_STRUCT) {
+		struct thread_info_list *th = &get_cpu_var(thread_info_list);
+		if (th->nr < EXTRA_TASK_STRUCT) {
+			unsigned long *p = (unsigned long *)thread;
+			p[0] = th->head;
+			th->head = p;
+			th->nr += 1;
+			put_cpu_var(thread_info_list);
+			return;
+		}
+		put_cpu_var(thread_info_list);
+	}
+	free_pages((unsigned long)thread, THREAD_SIZE_ORDER);
 }
 
 /*

commit 0cb3463f04e771869f481e2dd44f66419e850586
Author: Adrian Bunk <bunk@stusta.de>
Date:   Fri Mar 31 02:32:07 2006 -0800

    [PATCH] unexport get_wchan
    
    The only user of get_wchan is the proc fs - and proc can't be built modular.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 489c069e5c3e..1ff75cee4b0d 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -474,4 +474,3 @@ unsigned long get_wchan(struct task_struct *p)
 	} while (count ++ < 16);
 	return 0;
 }
-EXPORT_SYMBOL(get_wchan);

commit 84dff1a73013dbdd7d770c332ab84cbfed24741b
Author: Ben Dooks <ben-linux@fluff.org>
Date:   Wed Mar 15 23:17:23 2006 +0000

    [ARM] 3363/1: [cleanup] process.c - fix warnings
    
    Patch from Ben Dooks
    
    Fix the following warnings from sparse:
    
    arch/arm/kernel/process.c:86:6: warning: symbol 'default_idle' was not declared. Should it be static?
    arch/arm/kernel/process.c:378:5: warning: symbol 'dump_fpu' was not declared.   Should it be static?
    
    Include <linux/elfcore.h> for dump_fpu() decleration, and
    make default_idle() static as it is not used outside the file.
    
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 4b4e4cf79c80..489c069e5c3e 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -27,6 +27,7 @@
 #include <linux/kallsyms.h>
 #include <linux/init.h>
 #include <linux/cpu.h>
+#include <linux/elfcore.h>
 
 #include <asm/leds.h>
 #include <asm/processor.h>
@@ -83,7 +84,7 @@ EXPORT_SYMBOL(pm_power_off);
  * This is our default idle handler.  We need to disable
  * interrupts here to ensure we don't miss a wakeup call.
  */
-void default_idle(void)
+static void default_idle(void)
 {
 	if (hlt_counter)
 		cpu_relax();

commit 32d39a9355780bc9aadcf76a2d2004bdbe0f4665
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Jan 12 01:05:58 2006 -0800

    [PATCH] arm: task_stack_page()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index ac6ed955ca0f..4b4e4cf79c80 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -460,7 +460,7 @@ unsigned long get_wchan(struct task_struct *p)
 		return 0;
 
 	stack_start = (unsigned long)end_of_stack(p);
-	stack_end = ((unsigned long)p->thread_info) + THREAD_SIZE;
+	stack_end = (unsigned long)task_stack_page(p) + THREAD_SIZE;
 
 	fp = thread_saved_fp(p);
 	do {

commit 552058239238342dfd2fa8d33a299a162b1a4f05
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Jan 12 01:05:57 2006 -0800

    [PATCH] arm: end_of_stack()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 91d107d33c8d..ac6ed955ca0f 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -459,7 +459,7 @@ unsigned long get_wchan(struct task_struct *p)
 	if (!p || p == current || p->state == TASK_RUNNING)
 		return 0;
 
-	stack_start = (unsigned long)(p->thread_info + 1);
+	stack_start = (unsigned long)end_of_stack(p);
 	stack_end = ((unsigned long)p->thread_info) + THREAD_SIZE;
 
 	fp = thread_saved_fp(p);

commit 815d5ec86eb8d5f57e5e4aa147bd1fb6338c58ac
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Jan 12 01:05:57 2006 -0800

    [PATCH] arm: task_pt_regs()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 46d0984b44ff..91d107d33c8d 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -355,10 +355,9 @@ int
 copy_thread(int nr, unsigned long clone_flags, unsigned long stack_start,
 	    unsigned long stk_sz, struct task_struct *p, struct pt_regs *regs)
 {
-	struct thread_info *thread = p->thread_info;
-	struct pt_regs *childregs;
+	struct thread_info *thread = task_thread_info(p);
+	struct pt_regs *childregs = task_pt_regs(p);
 
-	childregs = (void *)thread + THREAD_START_SP - sizeof(*regs);
 	*childregs = *regs;
 	childregs->ARM_r0 = 0;
 	childregs->ARM_sp = stack_start;

commit e7c1b32fd354c34c4dceb1736a485bc5d91f7c43
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Jan 12 01:05:56 2006 -0800

    [PATCH] arm: task_thread_info()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 54a21bdcba5c..46d0984b44ff 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -342,10 +342,10 @@ void flush_thread(void)
 void release_thread(struct task_struct *dead_task)
 {
 #if defined(CONFIG_VFP)
-	vfp_release_thread(&dead_task->thread_info->vfpstate);
+	vfp_release_thread(&task_thread_info(dead_task)->vfpstate);
 #endif
 #if defined(CONFIG_IWMMXT)
-	iwmmxt_task_release(dead_task->thread_info);
+	iwmmxt_task_release(task_thread_info(dead_task));
 #endif
 }
 

commit 78ff18a412da24a4b79c6a97000ef5e467e813da
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Jan 3 17:39:34 2006 +0000

    [ARM] Cleanup ARM includes
    
    arch/arm/kernel/entry-armv.S has contained a comment suggesting
    that asm/hardware.h and asm/arch/irqs.h should be moved into the
    asm/arch/entry-macro.S include.  So move the includes to these
    two files as required.
    
    Add missing includes (asm/hardware.h, asm/io.h) to asm/arch/system.h
    includes which use those facilities, and remove asm/io.h from
    kernel/process.c.
    
    Remove other unnecessary includes from arch/arm/kernel, arch/arm/mm
    and arch/arm/mach-footbridge.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 30494aab829a..54a21bdcba5c 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -28,10 +28,9 @@
 #include <linux/init.h>
 #include <linux/cpu.h>
 
-#include <asm/system.h>
-#include <asm/io.h>
 #include <asm/leds.h>
 #include <asm/processor.h>
+#include <asm/system.h>
 #include <asm/uaccess.h>
 #include <asm/mach/time.h>
 

commit ac111bfaa6b0b3c0edc63c27bd9617d6b08851ff
Merge: 19da9b8b6ef8 861e37ad5969
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Wed Nov 9 08:55:53 2005 -0800

    Merge master.kernel.org:/home/rmk/linux-2.6-arm

commit 64c7c8f88559624abdbe12b5da6502e8879f8d28
Author: Nick Piggin <nickpiggin@yahoo.com.au>
Date:   Tue Nov 8 21:39:04 2005 -0800

    [PATCH] sched: resched and cpu_idle rework
    
    Make some changes to the NEED_RESCHED and POLLING_NRFLAG to reduce
    confusion, and make their semantics rigid.  Improves efficiency of
    resched_task and some cpu_idle routines.
    
    * In resched_task:
    - TIF_NEED_RESCHED is only cleared with the task's runqueue lock held,
      and as we hold it during resched_task, then there is no need for an
      atomic test and set there. The only other time this should be set is
      when the task's quantum expires, in the timer interrupt - this is
      protected against because the rq lock is irq-safe.
    
    - If TIF_NEED_RESCHED is set, then we don't need to do anything. It
      won't get unset until the task get's schedule()d off.
    
    - If we are running on the same CPU as the task we resched, then set
      TIF_NEED_RESCHED and no further action is required.
    
    - If we are running on another CPU, and TIF_POLLING_NRFLAG is *not* set
      after TIF_NEED_RESCHED has been set, then we need to send an IPI.
    
    Using these rules, we are able to remove the test and set operation in
    resched_task, and make clear the previously vague semantics of
    POLLING_NRFLAG.
    
    * In idle routines:
    - Enter cpu_idle with preempt disabled. When the need_resched() condition
      becomes true, explicitly call schedule(). This makes things a bit clearer
      (IMO), but haven't updated all architectures yet.
    
    - Many do a test and clear of TIF_NEED_RESCHED for some reason. According
      to the resched_task rules, this isn't needed (and actually breaks the
      assumption that TIF_NEED_RESCHED is only cleared with the runqueue lock
      held). So remove that. Generally one less locked memory op when switching
      to the idle thread.
    
    - Many idle routines clear TIF_POLLING_NRFLAG, and only set it in the inner
      most polling idle loops. The above resched_task semantics allow it to be
      set until before the last time need_resched() is checked before going into
      a halt requiring interrupt wakeup.
    
      Many idle routines simply never enter such a halt, and so POLLING_NRFLAG
      can be always left set, completely eliminating resched IPIs when rescheduling
      the idle task.
    
      POLLING_NRFLAG width can be increased, to reduce the chance of resched IPIs.
    
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Con Kolivas <kernel@kolivas.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 93dd92cc12f8..c0f6a119de3b 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -86,12 +86,16 @@ EXPORT_SYMBOL(pm_power_off);
  */
 void default_idle(void)
 {
-	local_irq_disable();
-	if (!need_resched() && !hlt_counter) {
-		timer_dyn_reprogram();
-		arch_idle();
+	if (hlt_counter)
+		cpu_relax();
+	else {
+		local_irq_disable();
+		if (!need_resched()) {
+			timer_dyn_reprogram();
+			arch_idle();
+		}
+		local_irq_enable();
 	}
-	local_irq_enable();
 }
 
 /*

commit 5bfb5d690f36d316a5f3b4f7775fda996faa6b12
Author: Nick Piggin <nickpiggin@yahoo.com.au>
Date:   Tue Nov 8 21:39:01 2005 -0800

    [PATCH] sched: disable preempt in idle tasks
    
    Run idle threads with preempt disabled.
    
    Also corrected a bugs in arm26's cpu_idle (make it actually call schedule()).
    How did it ever work before?
    
    Might fix the CPU hotplugging hang which Nigel Cunningham noted.
    
    We think the bug hits if the idle thread is preempted after checking
    need_resched() and before going to sleep, then the CPU offlined.
    
    After calling stop_machine_run, the CPU eventually returns from preemption and
    into the idle thread and goes to sleep.  The CPU will continue executing
    previous idle and have no chance to call play_dead.
    
    By disabling preemption until we are ready to explicitly schedule, this bug is
    fixed and the idle threads generally become more robust.
    
    From: alexs <ashepard@u.washington.edu>
    
      PPC build fix
    
    From: Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
    
      MIPS build fix
    
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Signed-off-by: Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index ba298277becd..93dd92cc12f8 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -116,13 +116,13 @@ void cpu_idle(void)
 
 		if (!idle)
 			idle = default_idle;
-		preempt_disable();
 		leds_event(led_idle_start);
 		while (!need_resched())
 			idle();
 		leds_event(led_idle_end);
-		preempt_enable();
+		preempt_enable_no_resched();
 		schedule();
+		preempt_disable();
 	}
 }
 

commit c906107bb72b7bd5ecfc98cc807bdb8f34d17501
Author: Nicolas Pitre <nico@cam.org>
Date:   Wed Nov 9 14:09:31 2005 +0000

    [ARM] 3100/1: simplify a pointer computation
    
    Patch from Nicolas Pitre
    
    Looks clearer this way.
    
    Signed-off-by: Nicolas Pitre <nico@cam.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index ba298277becd..07fb744f8a68 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -355,7 +355,7 @@ copy_thread(int nr, unsigned long clone_flags, unsigned long stack_start,
 	struct thread_info *thread = p->thread_info;
 	struct pt_regs *childregs;
 
-	childregs = ((struct pt_regs *)((unsigned long)thread + THREAD_START_SP)) - 1;
+	childregs = (void *)thread + THREAD_START_SP - sizeof(*regs);
 	*childregs = *regs;
 	childregs->ARM_r0 = 0;
 	childregs->ARM_sp = stack_start;

commit a054a811597a17ffbe92bc4db04a4dc2f1b1ea55
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Nov 2 22:24:33 2005 +0000

    [ARM SMP] Add hotplug CPU infrastructure
    
    This patch adds the infrastructure to support hotplug CPU on ARM
    platforms.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 409db6d5ec99..ba298277becd 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -26,6 +26,7 @@
 #include <linux/interrupt.h>
 #include <linux/kallsyms.h>
 #include <linux/init.h>
+#include <linux/cpu.h>
 
 #include <asm/system.h>
 #include <asm/io.h>
@@ -105,6 +106,14 @@ void cpu_idle(void)
 	/* endless idle loop with no priority at all */
 	while (1) {
 		void (*idle)(void) = pm_idle;
+
+#ifdef CONFIG_HOTPLUG_CPU
+		if (cpu_is_offline(smp_processor_id())) {
+			leds_event(led_idle_start);
+			cpu_die();
+		}
+#endif
+
 		if (!idle)
 			idle = default_idle;
 		preempt_disable();

commit 59586e5a262a29361c45c929ea3253d4aec830b0
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Jul 26 11:36:01 2005 -0600

    [PATCH] Don't export machine_restart, machine_halt, or machine_power_off.
    
    machine_restart, machine_halt and machine_power_off are machine
    specific hooks deep into the reboot logic, that modules
    have no business messing with.  Usually code should be calling
    kernel_restart, kernel_halt, kernel_power_off, or
    emergency_restart. So don't export machine_restart,
    machine_halt, and machine_power_off so we can catch buggy users.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index bbea636ff687..409db6d5ec99 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -131,7 +131,6 @@ void machine_halt(void)
 {
 }
 
-EXPORT_SYMBOL(machine_halt);
 
 void machine_power_off(void)
 {
@@ -139,7 +138,6 @@ void machine_power_off(void)
 		pm_power_off();
 }
 
-EXPORT_SYMBOL(machine_power_off);
 
 void machine_restart(char * __unused)
 {
@@ -169,8 +167,6 @@ void machine_restart(char * __unused)
 	while (1);
 }
 
-EXPORT_SYMBOL(machine_restart);
-
 void __show_regs(struct pt_regs *regs)
 {
 	unsigned long flags = condition_codes(regs);

commit 2ea83398b75309d8fdc999c4bb252e72d7e4fd9d
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Jun 27 14:04:05 2005 +0100

    [PATCH] ARM: Add VST idle loop call
    
    This call allows the dynamic tick support to reprogram the timer
    immediately before the CPU idles.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 8f146a4b4752..bbea636ff687 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -32,6 +32,7 @@
 #include <asm/leds.h>
 #include <asm/processor.h>
 #include <asm/uaccess.h>
+#include <asm/mach/time.h>
 
 extern const char *processor_modes[];
 extern void setup_mm_for_reboot(char mode);
@@ -85,8 +86,10 @@ EXPORT_SYMBOL(pm_power_off);
 void default_idle(void)
 {
 	local_irq_disable();
-	if (!need_resched() && !hlt_counter)
+	if (!need_resched() && !hlt_counter) {
+		timer_dyn_reprogram();
 		arch_idle();
+	}
 	local_irq_enable();
 }
 

commit 4f7a18124c1a44858fb74a1c4234015009952959
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu May 5 13:11:00 2005 +0100

    [PATCH] ARM: Fix kernel stack offset calculations
    
    Various places in the ARM kernel implicitly assumed that kernel
    stacks are always 8K due to hard coded constants.  Replace these
    constants with definitions.
    
    Correct the allowable range of kernel stack pointer values within
    the allocation.  Arrange for the entire kernel stack to be zeroed,
    not just the upper 4K if CONFIG_DEBUG_STACK_USAGE is set.
    
    Signed-off-by: Russell King <rmk@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 26eacd3e5def..8f146a4b4752 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -256,8 +256,6 @@ static unsigned long *thread_info_head;
 static unsigned int nr_thread_info;
 
 #define EXTRA_TASK_STRUCT	4
-#define ll_alloc_task_struct() ((struct thread_info *) __get_free_pages(GFP_KERNEL,1))
-#define ll_free_task_struct(p) free_pages((unsigned long)(p),1)
 
 struct thread_info *alloc_thread_info(struct task_struct *task)
 {
@@ -274,17 +272,16 @@ struct thread_info *alloc_thread_info(struct task_struct *task)
 	}
 
 	if (!thread)
-		thread = ll_alloc_task_struct();
+		thread = (struct thread_info *)
+			   __get_free_pages(GFP_KERNEL, THREAD_SIZE_ORDER);
 
-#ifdef CONFIG_MAGIC_SYSRQ
+#ifdef CONFIG_DEBUG_STACK_USAGE
 	/*
 	 * The stack must be cleared if you want SYSRQ-T to
 	 * give sensible stack usage information
 	 */
-	if (thread) {
-		char *p = (char *)thread;
-		memzero(p+KERNEL_STACK_SIZE, KERNEL_STACK_SIZE);
-	}
+	if (thread)
+		memzero(thread, THREAD_SIZE);
 #endif
 	return thread;
 }
@@ -297,7 +294,7 @@ void free_thread_info(struct thread_info *thread)
 		thread_info_head = p;
 		nr_thread_info += 1;
 	} else
-		ll_free_task_struct(thread);
+		free_pages((unsigned long)thread, THREAD_SIZE_ORDER);
 }
 
 /*
@@ -350,7 +347,7 @@ copy_thread(int nr, unsigned long clone_flags, unsigned long stack_start,
 	struct thread_info *thread = p->thread_info;
 	struct pt_regs *childregs;
 
-	childregs = ((struct pt_regs *)((unsigned long)thread + THREAD_SIZE - 8)) - 1;
+	childregs = ((struct pt_regs *)((unsigned long)thread + THREAD_START_SP)) - 1;
 	*childregs = *regs;
 	childregs->ARM_r0 = 0;
 	childregs->ARM_sp = stack_start;
@@ -447,15 +444,17 @@ EXPORT_SYMBOL(kernel_thread);
 unsigned long get_wchan(struct task_struct *p)
 {
 	unsigned long fp, lr;
-	unsigned long stack_page;
+	unsigned long stack_start, stack_end;
 	int count = 0;
 	if (!p || p == current || p->state == TASK_RUNNING)
 		return 0;
 
-	stack_page = 4096 + (unsigned long)p->thread_info;
+	stack_start = (unsigned long)(p->thread_info + 1);
+	stack_end = ((unsigned long)p->thread_info) + THREAD_SIZE;
+
 	fp = thread_saved_fp(p);
 	do {
-		if (fp < stack_page || fp > 4092+stack_page)
+		if (fp < stack_start || fp > stack_end)
 			return 0;
 		lr = pc_pointer (((unsigned long *)fp)[-1]);
 		if (!in_sched_functions(lr))

commit 652a12ef98d16ccd1ee5cdf2c832ce5411ed3262
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Apr 17 15:50:36 2005 +0100

    [PATCH] ARM: showregs
    
    Fix show_regs() to provide a backtrace.  Provide a new __show_regs()
    function which implements the common subset of show_regs() and die().
    Add prototypes to asm-arm/system.h
    
    Signed-off-by: Russell King <rmk@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index dbd8ca89b385..26eacd3e5def 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -168,12 +168,11 @@ void machine_restart(char * __unused)
 
 EXPORT_SYMBOL(machine_restart);
 
-void show_regs(struct pt_regs * regs)
+void __show_regs(struct pt_regs *regs)
 {
-	unsigned long flags;
-
-	flags = condition_codes(regs);
+	unsigned long flags = condition_codes(regs);
 
+	printk("CPU: %d\n", smp_processor_id());
 	print_symbol("PC is at %s\n", instruction_pointer(regs));
 	print_symbol("LR is at %s\n", regs->ARM_lr);
 	printk("pc : [<%08lx>]    lr : [<%08lx>]    %s\n"
@@ -213,6 +212,14 @@ void show_regs(struct pt_regs * regs)
 	}
 }
 
+void show_regs(struct pt_regs * regs)
+{
+	printk("\n");
+	printk("Pid: %d, comm: %20s\n", current->pid, current->comm);
+	__show_regs(regs);
+	__backtrace();
+}
+
 void show_fpregs(struct user_fp *regs)
 {
 	int i;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
new file mode 100644
index 000000000000..dbd8ca89b385
--- /dev/null
+++ b/arch/arm/kernel/process.c
@@ -0,0 +1,460 @@
+/*
+ *  linux/arch/arm/kernel/process.c
+ *
+ *  Copyright (C) 1996-2000 Russell King - Converted to ARM.
+ *  Original Copyright (C) 1995  Linus Torvalds
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <stdarg.h>
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/stddef.h>
+#include <linux/unistd.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/user.h>
+#include <linux/a.out.h>
+#include <linux/delay.h>
+#include <linux/reboot.h>
+#include <linux/interrupt.h>
+#include <linux/kallsyms.h>
+#include <linux/init.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/leds.h>
+#include <asm/processor.h>
+#include <asm/uaccess.h>
+
+extern const char *processor_modes[];
+extern void setup_mm_for_reboot(char mode);
+
+static volatile int hlt_counter;
+
+#include <asm/arch/system.h>
+
+void disable_hlt(void)
+{
+	hlt_counter++;
+}
+
+EXPORT_SYMBOL(disable_hlt);
+
+void enable_hlt(void)
+{
+	hlt_counter--;
+}
+
+EXPORT_SYMBOL(enable_hlt);
+
+static int __init nohlt_setup(char *__unused)
+{
+	hlt_counter = 1;
+	return 1;
+}
+
+static int __init hlt_setup(char *__unused)
+{
+	hlt_counter = 0;
+	return 1;
+}
+
+__setup("nohlt", nohlt_setup);
+__setup("hlt", hlt_setup);
+
+/*
+ * The following aren't currently used.
+ */
+void (*pm_idle)(void);
+EXPORT_SYMBOL(pm_idle);
+
+void (*pm_power_off)(void);
+EXPORT_SYMBOL(pm_power_off);
+
+/*
+ * This is our default idle handler.  We need to disable
+ * interrupts here to ensure we don't miss a wakeup call.
+ */
+void default_idle(void)
+{
+	local_irq_disable();
+	if (!need_resched() && !hlt_counter)
+		arch_idle();
+	local_irq_enable();
+}
+
+/*
+ * The idle thread.  We try to conserve power, while trying to keep
+ * overall latency low.  The architecture specific idle is passed
+ * a value to indicate the level of "idleness" of the system.
+ */
+void cpu_idle(void)
+{
+	local_fiq_enable();
+
+	/* endless idle loop with no priority at all */
+	while (1) {
+		void (*idle)(void) = pm_idle;
+		if (!idle)
+			idle = default_idle;
+		preempt_disable();
+		leds_event(led_idle_start);
+		while (!need_resched())
+			idle();
+		leds_event(led_idle_end);
+		preempt_enable();
+		schedule();
+	}
+}
+
+static char reboot_mode = 'h';
+
+int __init reboot_setup(char *str)
+{
+	reboot_mode = str[0];
+	return 1;
+}
+
+__setup("reboot=", reboot_setup);
+
+void machine_halt(void)
+{
+}
+
+EXPORT_SYMBOL(machine_halt);
+
+void machine_power_off(void)
+{
+	if (pm_power_off)
+		pm_power_off();
+}
+
+EXPORT_SYMBOL(machine_power_off);
+
+void machine_restart(char * __unused)
+{
+	/*
+	 * Clean and disable cache, and turn off interrupts
+	 */
+	cpu_proc_fin();
+
+	/*
+	 * Tell the mm system that we are going to reboot -
+	 * we may need it to insert some 1:1 mappings so that
+	 * soft boot works.
+	 */
+	setup_mm_for_reboot(reboot_mode);
+
+	/*
+	 * Now call the architecture specific reboot code.
+	 */
+	arch_reset(reboot_mode);
+
+	/*
+	 * Whoops - the architecture was unable to reboot.
+	 * Tell the user!
+	 */
+	mdelay(1000);
+	printk("Reboot failed -- System halted\n");
+	while (1);
+}
+
+EXPORT_SYMBOL(machine_restart);
+
+void show_regs(struct pt_regs * regs)
+{
+	unsigned long flags;
+
+	flags = condition_codes(regs);
+
+	print_symbol("PC is at %s\n", instruction_pointer(regs));
+	print_symbol("LR is at %s\n", regs->ARM_lr);
+	printk("pc : [<%08lx>]    lr : [<%08lx>]    %s\n"
+	       "sp : %08lx  ip : %08lx  fp : %08lx\n",
+		instruction_pointer(regs),
+		regs->ARM_lr, print_tainted(), regs->ARM_sp,
+		regs->ARM_ip, regs->ARM_fp);
+	printk("r10: %08lx  r9 : %08lx  r8 : %08lx\n",
+		regs->ARM_r10, regs->ARM_r9,
+		regs->ARM_r8);
+	printk("r7 : %08lx  r6 : %08lx  r5 : %08lx  r4 : %08lx\n",
+		regs->ARM_r7, regs->ARM_r6,
+		regs->ARM_r5, regs->ARM_r4);
+	printk("r3 : %08lx  r2 : %08lx  r1 : %08lx  r0 : %08lx\n",
+		regs->ARM_r3, regs->ARM_r2,
+		regs->ARM_r1, regs->ARM_r0);
+	printk("Flags: %c%c%c%c",
+		flags & PSR_N_BIT ? 'N' : 'n',
+		flags & PSR_Z_BIT ? 'Z' : 'z',
+		flags & PSR_C_BIT ? 'C' : 'c',
+		flags & PSR_V_BIT ? 'V' : 'v');
+	printk("  IRQs o%s  FIQs o%s  Mode %s%s  Segment %s\n",
+		interrupts_enabled(regs) ? "n" : "ff",
+		fast_interrupts_enabled(regs) ? "n" : "ff",
+		processor_modes[processor_mode(regs)],
+		thumb_mode(regs) ? " (T)" : "",
+		get_fs() == get_ds() ? "kernel" : "user");
+	{
+		unsigned int ctrl, transbase, dac;
+		  __asm__ (
+		"	mrc p15, 0, %0, c1, c0\n"
+		"	mrc p15, 0, %1, c2, c0\n"
+		"	mrc p15, 0, %2, c3, c0\n"
+		: "=r" (ctrl), "=r" (transbase), "=r" (dac));
+		printk("Control: %04X  Table: %08X  DAC: %08X\n",
+		  	ctrl, transbase, dac);
+	}
+}
+
+void show_fpregs(struct user_fp *regs)
+{
+	int i;
+
+	for (i = 0; i < 8; i++) {
+		unsigned long *p;
+		char type;
+
+		p = (unsigned long *)(regs->fpregs + i);
+
+		switch (regs->ftype[i]) {
+			case 1: type = 'f'; break;
+			case 2: type = 'd'; break;
+			case 3: type = 'e'; break;
+			default: type = '?'; break;
+		}
+		if (regs->init_flag)
+			type = '?';
+
+		printk("  f%d(%c): %08lx %08lx %08lx%c",
+			i, type, p[0], p[1], p[2], i & 1 ? '\n' : ' ');
+	}
+			
+
+	printk("FPSR: %08lx FPCR: %08lx\n",
+		(unsigned long)regs->fpsr,
+		(unsigned long)regs->fpcr);
+}
+
+/*
+ * Task structure and kernel stack allocation.
+ */
+static unsigned long *thread_info_head;
+static unsigned int nr_thread_info;
+
+#define EXTRA_TASK_STRUCT	4
+#define ll_alloc_task_struct() ((struct thread_info *) __get_free_pages(GFP_KERNEL,1))
+#define ll_free_task_struct(p) free_pages((unsigned long)(p),1)
+
+struct thread_info *alloc_thread_info(struct task_struct *task)
+{
+	struct thread_info *thread = NULL;
+
+	if (EXTRA_TASK_STRUCT) {
+		unsigned long *p = thread_info_head;
+
+		if (p) {
+			thread_info_head = (unsigned long *)p[0];
+			nr_thread_info -= 1;
+		}
+		thread = (struct thread_info *)p;
+	}
+
+	if (!thread)
+		thread = ll_alloc_task_struct();
+
+#ifdef CONFIG_MAGIC_SYSRQ
+	/*
+	 * The stack must be cleared if you want SYSRQ-T to
+	 * give sensible stack usage information
+	 */
+	if (thread) {
+		char *p = (char *)thread;
+		memzero(p+KERNEL_STACK_SIZE, KERNEL_STACK_SIZE);
+	}
+#endif
+	return thread;
+}
+
+void free_thread_info(struct thread_info *thread)
+{
+	if (EXTRA_TASK_STRUCT && nr_thread_info < EXTRA_TASK_STRUCT) {
+		unsigned long *p = (unsigned long *)thread;
+		p[0] = (unsigned long)thread_info_head;
+		thread_info_head = p;
+		nr_thread_info += 1;
+	} else
+		ll_free_task_struct(thread);
+}
+
+/*
+ * Free current thread data structures etc..
+ */
+void exit_thread(void)
+{
+}
+
+static void default_fp_init(union fp_state *fp)
+{
+	memset(fp, 0, sizeof(union fp_state));
+}
+
+void (*fp_init)(union fp_state *) = default_fp_init;
+EXPORT_SYMBOL(fp_init);
+
+void flush_thread(void)
+{
+	struct thread_info *thread = current_thread_info();
+	struct task_struct *tsk = current;
+
+	memset(thread->used_cp, 0, sizeof(thread->used_cp));
+	memset(&tsk->thread.debug, 0, sizeof(struct debug_info));
+#if defined(CONFIG_IWMMXT)
+	iwmmxt_task_release(thread);
+#endif
+	fp_init(&thread->fpstate);
+#if defined(CONFIG_VFP)
+	vfp_flush_thread(&thread->vfpstate);
+#endif
+}
+
+void release_thread(struct task_struct *dead_task)
+{
+#if defined(CONFIG_VFP)
+	vfp_release_thread(&dead_task->thread_info->vfpstate);
+#endif
+#if defined(CONFIG_IWMMXT)
+	iwmmxt_task_release(dead_task->thread_info);
+#endif
+}
+
+asmlinkage void ret_from_fork(void) __asm__("ret_from_fork");
+
+int
+copy_thread(int nr, unsigned long clone_flags, unsigned long stack_start,
+	    unsigned long stk_sz, struct task_struct *p, struct pt_regs *regs)
+{
+	struct thread_info *thread = p->thread_info;
+	struct pt_regs *childregs;
+
+	childregs = ((struct pt_regs *)((unsigned long)thread + THREAD_SIZE - 8)) - 1;
+	*childregs = *regs;
+	childregs->ARM_r0 = 0;
+	childregs->ARM_sp = stack_start;
+
+	memset(&thread->cpu_context, 0, sizeof(struct cpu_context_save));
+	thread->cpu_context.sp = (unsigned long)childregs;
+	thread->cpu_context.pc = (unsigned long)ret_from_fork;
+
+	if (clone_flags & CLONE_SETTLS)
+		thread->tp_value = regs->ARM_r3;
+
+	return 0;
+}
+
+/*
+ * fill in the fpe structure for a core dump...
+ */
+int dump_fpu (struct pt_regs *regs, struct user_fp *fp)
+{
+	struct thread_info *thread = current_thread_info();
+	int used_math = thread->used_cp[1] | thread->used_cp[2];
+
+	if (used_math)
+		memcpy(fp, &thread->fpstate.soft, sizeof (*fp));
+
+	return used_math != 0;
+}
+EXPORT_SYMBOL(dump_fpu);
+
+/*
+ * fill in the user structure for a core dump..
+ */
+void dump_thread(struct pt_regs * regs, struct user * dump)
+{
+	struct task_struct *tsk = current;
+
+	dump->magic = CMAGIC;
+	dump->start_code = tsk->mm->start_code;
+	dump->start_stack = regs->ARM_sp & ~(PAGE_SIZE - 1);
+
+	dump->u_tsize = (tsk->mm->end_code - tsk->mm->start_code) >> PAGE_SHIFT;
+	dump->u_dsize = (tsk->mm->brk - tsk->mm->start_data + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	dump->u_ssize = 0;
+
+	dump->u_debugreg[0] = tsk->thread.debug.bp[0].address;
+	dump->u_debugreg[1] = tsk->thread.debug.bp[1].address;
+	dump->u_debugreg[2] = tsk->thread.debug.bp[0].insn.arm;
+	dump->u_debugreg[3] = tsk->thread.debug.bp[1].insn.arm;
+	dump->u_debugreg[4] = tsk->thread.debug.nsaved;
+
+	if (dump->start_stack < 0x04000000)
+		dump->u_ssize = (0x04000000 - dump->start_stack) >> PAGE_SHIFT;
+
+	dump->regs = *regs;
+	dump->u_fpvalid = dump_fpu (regs, &dump->u_fp);
+}
+EXPORT_SYMBOL(dump_thread);
+
+/*
+ * Shuffle the argument into the correct register before calling the
+ * thread function.  r1 is the thread argument, r2 is the pointer to
+ * the thread function, and r3 points to the exit function.
+ */
+extern void kernel_thread_helper(void);
+asm(	".section .text\n"
+"	.align\n"
+"	.type	kernel_thread_helper, #function\n"
+"kernel_thread_helper:\n"
+"	mov	r0, r1\n"
+"	mov	lr, r3\n"
+"	mov	pc, r2\n"
+"	.size	kernel_thread_helper, . - kernel_thread_helper\n"
+"	.previous");
+
+/*
+ * Create a kernel thread.
+ */
+pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
+{
+	struct pt_regs regs;
+
+	memset(&regs, 0, sizeof(regs));
+
+	regs.ARM_r1 = (unsigned long)arg;
+	regs.ARM_r2 = (unsigned long)fn;
+	regs.ARM_r3 = (unsigned long)do_exit;
+	regs.ARM_pc = (unsigned long)kernel_thread_helper;
+	regs.ARM_cpsr = SVC_MODE;
+
+	return do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+}
+EXPORT_SYMBOL(kernel_thread);
+
+unsigned long get_wchan(struct task_struct *p)
+{
+	unsigned long fp, lr;
+	unsigned long stack_page;
+	int count = 0;
+	if (!p || p == current || p->state == TASK_RUNNING)
+		return 0;
+
+	stack_page = 4096 + (unsigned long)p->thread_info;
+	fp = thread_saved_fp(p);
+	do {
+		if (fp < stack_page || fp > 4092+stack_page)
+			return 0;
+		lr = pc_pointer (((unsigned long *)fp)[-1]);
+		if (!in_sched_functions(lr))
+			return lr;
+		fp = *(unsigned long *) (fp - 12);
+	} while (count ++ < 16);
+	return 0;
+}
+EXPORT_SYMBOL(get_wchan);
