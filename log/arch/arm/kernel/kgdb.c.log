commit fe557319aa06c23cffc9346000f119547e0f289a
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jun 17 09:37:53 2020 +0200

    maccess: rename probe_kernel_{read,write} to copy_{from,to}_kernel_nofault
    
    Better describe what these functions do.
    
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/kgdb.c b/arch/arm/kernel/kgdb.c
index 6a95b9296640..7bd30c0a4280 100644
--- a/arch/arm/kernel/kgdb.c
+++ b/arch/arm/kernel/kgdb.c
@@ -236,7 +236,7 @@ int kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt)
 	/* patch_text() only supports int-sized breakpoints */
 	BUILD_BUG_ON(sizeof(int) != BREAK_INSTR_SIZE);
 
-	err = probe_kernel_read(bpt->saved_instr, (char *)bpt->bpt_addr,
+	err = copy_from_kernel_nofault(bpt->saved_instr, (char *)bpt->bpt_addr,
 				BREAK_INSTR_SIZE);
 	if (err)
 		return err;

commit cc0282975b3f887005c380adcf0af95915f0c1bb
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Thu Dec 6 20:07:40 2018 +0000

    kgdb/treewide: constify struct kgdb_arch arch_kgdb_ops
    
    checkpatch.pl reports the following:
    
      WARNING: struct kgdb_arch should normally be const
      #28: FILE: arch/mips/kernel/kgdb.c:397:
      +struct kgdb_arch arch_kgdb_ops = {
    
    This report makes sense, as all other ops struct, this
    one should also be const. This patch does the change.
    
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: x86@kernel.org
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Acked-by: Paul Burton <paul.burton@mips.com>
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Acked-by: Borislav Petkov <bp@suse.de>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>

diff --git a/arch/arm/kernel/kgdb.c b/arch/arm/kernel/kgdb.c
index d9a69e941463..6a95b9296640 100644
--- a/arch/arm/kernel/kgdb.c
+++ b/arch/arm/kernel/kgdb.c
@@ -262,7 +262,7 @@ int kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)
  * and we handle the normal undef case within the do_undefinstr
  * handler.
  */
-struct kgdb_arch arch_kgdb_ops = {
+const struct kgdb_arch arch_kgdb_ops = {
 #ifndef __ARMEB__
 	.gdb_bpt_instr		= {0xfe, 0xde, 0xff, 0xe7}
 #else /* ! __ARMEB__ */

commit 3cd99ac3559855f69afbc1d5080e17eaa12394ff
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue Dec 4 19:38:26 2018 -0800

    kgdb: Fix kgdb_roundup_cpus() for arches who used smp_call_function()
    
    When I had lockdep turned on and dropped into kgdb I got a nice splat
    on my system.  Specifically it hit:
      DEBUG_LOCKS_WARN_ON(current->hardirq_context)
    
    Specifically it looked like this:
      sysrq: SysRq : DEBUG
      ------------[ cut here ]------------
      DEBUG_LOCKS_WARN_ON(current->hardirq_context)
      WARNING: CPU: 0 PID: 0 at .../kernel/locking/lockdep.c:2875 lockdep_hardirqs_on+0xf0/0x160
      CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.19.0 #27
      pstate: 604003c9 (nZCv DAIF +PAN -UAO)
      pc : lockdep_hardirqs_on+0xf0/0x160
      ...
      Call trace:
       lockdep_hardirqs_on+0xf0/0x160
       trace_hardirqs_on+0x188/0x1ac
       kgdb_roundup_cpus+0x14/0x3c
       kgdb_cpu_enter+0x53c/0x5cc
       kgdb_handle_exception+0x180/0x1d4
       kgdb_compiled_brk_fn+0x30/0x3c
       brk_handler+0x134/0x178
       do_debug_exception+0xfc/0x178
       el1_dbg+0x18/0x78
       kgdb_breakpoint+0x34/0x58
       sysrq_handle_dbg+0x54/0x5c
       __handle_sysrq+0x114/0x21c
       handle_sysrq+0x30/0x3c
       qcom_geni_serial_isr+0x2dc/0x30c
      ...
      ...
      irq event stamp: ...45
      hardirqs last  enabled at (...44): [...] __do_softirq+0xd8/0x4e4
      hardirqs last disabled at (...45): [...] el1_irq+0x74/0x130
      softirqs last  enabled at (...42): [...] _local_bh_enable+0x2c/0x34
      softirqs last disabled at (...43): [...] irq_exit+0xa8/0x100
      ---[ end trace adf21f830c46e638 ]---
    
    Looking closely at it, it seems like a really bad idea to be calling
    local_irq_enable() in kgdb_roundup_cpus().  If nothing else that seems
    like it could violate spinlock semantics and cause a deadlock.
    
    Instead, let's use a private csd alongside
    smp_call_function_single_async() to round up the other CPUs.  Using
    smp_call_function_single_async() doesn't require interrupts to be
    enabled so we can remove the offending bit of code.
    
    In order to avoid duplicating this across all the architectures that
    use the default kgdb_roundup_cpus(), we'll add a "weak" implementation
    to debug_core.c.
    
    Looking at all the people who previously had copies of this code,
    there were a few variants.  I've attempted to keep the variants
    working like they used to.  Specifically:
    * For arch/arc we passed NULL to kgdb_nmicallback() instead of
      get_irq_regs().
    * For arch/mips there was a bit of extra code around
      kgdb_nmicallback()
    
    NOTE: In this patch we will still get into trouble if we try to round
    up a CPU that failed to round up before.  We'll try to round it up
    again and potentially hang when we try to grab the csd lock.  That's
    not new behavior but we'll still try to do better in a future patch.
    
    Suggested-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Rich Felker <dalias@libc.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>

diff --git a/arch/arm/kernel/kgdb.c b/arch/arm/kernel/kgdb.c
index f21077b077be..d9a69e941463 100644
--- a/arch/arm/kernel/kgdb.c
+++ b/arch/arm/kernel/kgdb.c
@@ -170,18 +170,6 @@ static struct undef_hook kgdb_compiled_brkpt_hook = {
 	.fn			= kgdb_compiled_brk_fn
 };
 
-static void kgdb_call_nmi_hook(void *ignored)
-{
-       kgdb_nmicallback(raw_smp_processor_id(), get_irq_regs());
-}
-
-void kgdb_roundup_cpus(void)
-{
-       local_irq_enable();
-       smp_call_function(kgdb_call_nmi_hook, NULL, 0);
-       local_irq_disable();
-}
-
 static int __kgdb_notify(struct die_args *args, unsigned long cmd)
 {
 	struct pt_regs *regs = args->regs;

commit 9ef7fa507d6b53a96de4da3298c5f01bde603c0a
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue Dec 4 19:38:25 2018 -0800

    kgdb: Remove irq flags from roundup
    
    The function kgdb_roundup_cpus() was passed a parameter that was
    documented as:
    
    > the flags that will be used when restoring the interrupts. There is
    > local_irq_save() call before kgdb_roundup_cpus().
    
    Nobody used those flags.  Anyone who wanted to temporarily turn on
    interrupts just did local_irq_enable() and local_irq_disable() without
    looking at them.  So we can definitely remove the flags.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Rich Felker <dalias@libc.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>

diff --git a/arch/arm/kernel/kgdb.c b/arch/arm/kernel/kgdb.c
index caa0dbe3dc61..f21077b077be 100644
--- a/arch/arm/kernel/kgdb.c
+++ b/arch/arm/kernel/kgdb.c
@@ -175,7 +175,7 @@ static void kgdb_call_nmi_hook(void *ignored)
        kgdb_nmicallback(raw_smp_processor_id(), get_irq_regs());
 }
 
-void kgdb_roundup_cpus(unsigned long flags)
+void kgdb_roundup_cpus(void)
 {
        local_irq_enable();
        smp_call_function(kgdb_call_nmi_hook, NULL, 0);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/kernel/kgdb.c b/arch/arm/kernel/kgdb.c
index 1bb4c40a3135..caa0dbe3dc61 100644
--- a/arch/arm/kernel/kgdb.c
+++ b/arch/arm/kernel/kgdb.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * arch/arm/kernel/kgdb.c
  *

commit ad61dd303a0f2439bb104349e2d2ec91a3010ce0
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon May 8 15:57:50 2017 -0700

    scripts/spelling.txt: add regsiter -> register spelling mistake
    
    This typo is quite common.  Fix it and add it to the spelling file so
    that checkpatch catches it earlier.
    
    Link: http://lkml.kernel.org/r/20170317011131.6881-2-sboyd@codeaurora.org
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/kgdb.c b/arch/arm/kernel/kgdb.c
index 9232caee7060..1bb4c40a3135 100644
--- a/arch/arm/kernel/kgdb.c
+++ b/arch/arm/kernel/kgdb.c
@@ -269,7 +269,7 @@ int kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)
 
 /*
  * Register our undef instruction hooks with ARM undef core.
- * We regsiter a hook specifically looking for the KGB break inst
+ * We register a hook specifically looking for the KGB break inst
  * and we handle the normal undef case within the do_undefinstr
  * handler.
  */

commit 001bf455d20645190beb98ff4ee450dfea1b7eb2
Author: Doug Anderson <armlinux@m.disordat.com>
Date:   Wed Sep 2 03:39:19 2015 +0100

    ARM: 8428/1: kgdb: Fix registers on sleeping tasks
    
    Dumping registers from other sleeping tasks in KGDB was totally
    failing for me.  All registers were reported as 0 in many cases.
    
    The code was using task_pt_regs(task) to try to get other thread
    registers.  This doesn't appear to be the right place to look.  From
    my tests, I saw non-zero values in this structure when we were looking
    at a kernel thread that had a userspace task associated with it, but
    it contained the register values from the userspace task.  So even in
    the cases where registers weren't reported as 0 we were still not
    showing the right thing.
    
    Instead of using task_pt_regs(task) let's use task_thread_info(task).
    This is the same place that is referred to when doing a dump of all
    sleeping task stacks (kdb_show_stack() -> show_stack() ->
    dump_backtrace() -> unwind_backtrace() -> thread_saved_sp()).
    
    As further evidence that this is the right thing to do, you can find
    the following comment in "gdbstub.c" right before it calls
    sleeping_thread_to_gdb_regs():
      Pull stuff saved during switch_to; nothing else is accessible (or
      even particularly relevant).  This should be enough for a stack
      trace.
    ...and if you look at switch_to() it only saves r4-r11, sp and lr.
    Those are the same registers that I'm getting out of the
    task_thread_info().
    
    With this change you can use "info thread" to see all tasks in the
    kernel and you can switch to other tasks and examine them in gdb.
    
    Signed-off-by: Doug Anderson <dianders@chromium.org>
    Tested-by: Stephen Boyd <sboyd@codeurora.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/kgdb.c b/arch/arm/kernel/kgdb.c
index fd9eefce0a7b..9232caee7060 100644
--- a/arch/arm/kernel/kgdb.c
+++ b/arch/arm/kernel/kgdb.c
@@ -74,7 +74,7 @@ int dbg_set_reg(int regno, void *mem, struct pt_regs *regs)
 void
 sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *task)
 {
-	struct pt_regs *thread_regs;
+	struct thread_info *ti;
 	int regno;
 
 	/* Just making sure... */
@@ -86,24 +86,17 @@ sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *task)
 		gdb_regs[regno] = 0;
 
 	/* Otherwise, we have only some registers from switch_to() */
-	thread_regs		= task_pt_regs(task);
-	gdb_regs[_R0]		= thread_regs->ARM_r0;
-	gdb_regs[_R1]		= thread_regs->ARM_r1;
-	gdb_regs[_R2]		= thread_regs->ARM_r2;
-	gdb_regs[_R3]		= thread_regs->ARM_r3;
-	gdb_regs[_R4]		= thread_regs->ARM_r4;
-	gdb_regs[_R5]		= thread_regs->ARM_r5;
-	gdb_regs[_R6]		= thread_regs->ARM_r6;
-	gdb_regs[_R7]		= thread_regs->ARM_r7;
-	gdb_regs[_R8]		= thread_regs->ARM_r8;
-	gdb_regs[_R9]		= thread_regs->ARM_r9;
-	gdb_regs[_R10]		= thread_regs->ARM_r10;
-	gdb_regs[_FP]		= thread_regs->ARM_fp;
-	gdb_regs[_IP]		= thread_regs->ARM_ip;
-	gdb_regs[_SPT]		= thread_regs->ARM_sp;
-	gdb_regs[_LR]		= thread_regs->ARM_lr;
-	gdb_regs[_PC]		= thread_regs->ARM_pc;
-	gdb_regs[_CPSR]		= thread_regs->ARM_cpsr;
+	ti			= task_thread_info(task);
+	gdb_regs[_R4]		= ti->cpu_context.r4;
+	gdb_regs[_R5]		= ti->cpu_context.r5;
+	gdb_regs[_R6]		= ti->cpu_context.r6;
+	gdb_regs[_R7]		= ti->cpu_context.r7;
+	gdb_regs[_R8]		= ti->cpu_context.r8;
+	gdb_regs[_R9]		= ti->cpu_context.r9;
+	gdb_regs[_R10]		= ti->cpu_context.sl;
+	gdb_regs[_FP]		= ti->cpu_context.fp;
+	gdb_regs[_SPT]		= ti->cpu_context.sp;
+	gdb_regs[_PC]		= ti->cpu_context.pc;
 }
 
 void kgdb_arch_set_pc(struct pt_regs *regs, unsigned long pc)

commit 7ae85dc7687c7e7119053d83d02c560ea217b772
Author: Doug Anderson <armlinux@m.disordat.com>
Date:   Wed Aug 26 18:26:49 2015 +0100

    ARM: 8425/1: kgdb: Don't try to stop the machine when setting breakpoints
    
    In (23a4e40 arm: kgdb: Handle read-only text / modules) we moved to
    using patch_text() to set breakpoints so that we could handle the case
    when we had CONFIG_DEBUG_RODATA.  That patch used patch_text().
    Unfortunately, patch_text() assumes that we're not in atomic context
    when it runs since it needs to grab a mutex and also wait for other
    CPUs to stop (which it does with a completion).
    
    This would result in a stack crawl if you had
    CONFIG_DEBUG_ATOMIC_SLEEP and tried to set a breakpoint in kgdb.  The
    crawl looked something like:
    
     BUG: scheduling while atomic: swapper/0/0/0x00010007
     CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.2.0-rc7-00133-geb63b34 #1073
     Hardware name: Rockchip (Device Tree)
      (unwind_backtrace) from [<c00133d4>] (show_stack+0x20/0x24)
      (show_stack) from [<c05400e8>] (dump_stack+0x84/0xb8)
      (dump_stack) from [<c004913c>] (__schedule_bug+0x54/0x6c)
      (__schedule_bug) from [<c054065c>] (__schedule+0x80/0x668)
      (__schedule) from [<c0540cfc>] (schedule+0xb8/0xd4)
      (schedule) from [<c0543a3c>] (schedule_timeout+0x2c/0x234)
      (schedule_timeout) from [<c05417c0>] (wait_for_common+0xf4/0x188)
      (wait_for_common) from [<c0541874>] (wait_for_completion+0x20/0x24)
      (wait_for_completion) from [<c00a0104>] (__stop_cpus+0x58/0x70)
      (__stop_cpus) from [<c00a0580>] (stop_cpus+0x3c/0x54)
      (stop_cpus) from [<c00a06c4>] (__stop_machine+0xcc/0xe8)
      (__stop_machine) from [<c00a0714>] (stop_machine+0x34/0x44)
      (stop_machine) from [<c00173e8>] (patch_text+0x28/0x34)
      (patch_text) from [<c001733c>] (kgdb_arch_set_breakpoint+0x40/0x4c)
      (kgdb_arch_set_breakpoint) from [<c00a0d68>] (kgdb_validate_break_address+0x2c/0x60)
      (kgdb_validate_break_address) from [<c00a0e90>] (dbg_set_sw_break+0x1c/0xdc)
      (dbg_set_sw_break) from [<c00a2e88>] (gdb_serial_stub+0x9c4/0xba4)
      (gdb_serial_stub) from [<c00a11cc>] (kgdb_cpu_enter+0x1f8/0x60c)
      (kgdb_cpu_enter) from [<c00a18cc>] (kgdb_handle_exception+0x19c/0x1d0)
      (kgdb_handle_exception) from [<c0016f7c>] (kgdb_compiled_brk_fn+0x30/0x3c)
      (kgdb_compiled_brk_fn) from [<c00091a4>] (do_undefinstr+0x1a4/0x20c)
      (do_undefinstr) from [<c001400c>] (__und_svc_finish+0x0/0x34)
    
    It turns out that when we're in kgdb all the CPUs are stopped anyway
    so there's no reason we should be calling patch_text().  We can
    instead directly call __patch_text() which assumes that CPUs have
    already been stopped.
    
    Fixes: 23a4e4050ba9 ("arm: kgdb: Handle read-only text / modules")
    Reported-by: Aapo Vienamo <avienamo@nvidia.com>
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/kgdb.c b/arch/arm/kernel/kgdb.c
index a6ad93c9bce3..fd9eefce0a7b 100644
--- a/arch/arm/kernel/kgdb.c
+++ b/arch/arm/kernel/kgdb.c
@@ -259,15 +259,17 @@ int kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt)
 	if (err)
 		return err;
 
-	patch_text((void *)bpt->bpt_addr,
-		   *(unsigned int *)arch_kgdb_ops.gdb_bpt_instr);
+	/* Machine is already stopped, so we can use __patch_text() directly */
+	__patch_text((void *)bpt->bpt_addr,
+		     *(unsigned int *)arch_kgdb_ops.gdb_bpt_instr);
 
 	return err;
 }
 
 int kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)
 {
-	patch_text((void *)bpt->bpt_addr, *(unsigned int *)bpt->saved_instr);
+	/* Machine is already stopped, so we can use __patch_text() directly */
+	__patch_text((void *)bpt->bpt_addr, *(unsigned int *)bpt->saved_instr);
 
 	return 0;
 }

commit fca08f326ae0423f03b097ff54de432fe77b95d0
Author: Wang Nan <wangnan0@huawei.com>
Date:   Fri Jan 9 10:19:49 2015 +0800

    ARM: probes: move all probe code to dedicate directory
    
    In discussion on LKML (https://lkml.org/lkml/2014/11/28/158), Russell
    King suggests to move all probe related code to arch/arm/probes. This
    patch does the work. Due to dependency on 'arch/arm/kernel/patch.h', this
    patch also moves patch.h to 'arch/arm/include/asm/patch.h', and related
    '#include' directives are also midified to '#include <asm/patch.h>'.
    
    Following is an overview of this patch:
    
     ./arch/arm/kernel/               ./arch/arm/probes/
     |-- Makefile                     |-- Makefile
     |-- probes-arm.c          ==>    |-- decode-arm.c
     |-- probes-arm.h          ==>    |-- decode-arm.h
     |-- probes-thumb.c        ==>    |-- decode-thumb.c
     |-- probes-thumb.h        ==>    |-- decode-thumb.h
     |-- probes.c              ==>    |-- decode.c
     |-- probes.h              ==>    |-- decode.h
     |                                |-- kprobes
     |                                |   |-- Makefile
     |-- kprobes-arm.c         ==>    |   |-- actions-arm.c
     |-- kprobes-common.c      ==>    |   |-- actions-common.c
     |-- kprobes-thumb.c       ==>    |   |-- actions-thumb.c
     |-- kprobes.c             ==>    |   |-- core.c
     |-- kprobes.h             ==>    |   |-- core.h
     |-- kprobes-test-arm.c    ==>    |   |-- test-arm.c
     |-- kprobes-test.c        ==>    |   |-- test-core.c
     |-- kprobes-test.h        ==>    |   |-- test-core.h
     |-- kprobes-test-thumb.c  ==>    |   `-- test-thumb.c
     |                                `-- uprobes
     |                                    |-- Makefile
     |-- uprobes-arm.c         ==>        |-- actions-arm.c
     |-- uprobes.c             ==>        |-- core.c
     |-- uprobes.h             ==>        `-- core.h
     |
     `-- patch.h               ==>    arch/arm/include/asm/patch.h
    
    Signed-off-by: Wang Nan <wangnan0@huawei.com>
    Acked-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Signed-off-by: Jon Medhurst <tixy@linaro.org>

diff --git a/arch/arm/kernel/kgdb.c b/arch/arm/kernel/kgdb.c
index 07db2f8a1b45..a6ad93c9bce3 100644
--- a/arch/arm/kernel/kgdb.c
+++ b/arch/arm/kernel/kgdb.c
@@ -14,10 +14,9 @@
 #include <linux/kgdb.h>
 #include <linux/uaccess.h>
 
+#include <asm/patch.h>
 #include <asm/traps.h>
 
-#include "patch.h"
-
 struct dbg_reg_def_t dbg_reg_def[DBG_MAX_REG_NUM] =
 {
 	{ "r0", 4, offsetof(struct pt_regs, ARM_r0)},

commit 23a4e4050ba9c98ab67db0980a9fb20e5096d9ea
Author: Doug Anderson <dianders@chromium.org>
Date:   Tue Apr 22 15:14:51 2014 -0700

    arm: kgdb: Handle read-only text / modules
    
    Handle the case where someone has set the text segment of the kernel
    as read-only by using the newly introduced "patch" mechanism.
    
    Signed-off-by: Doug Anderson <dianders@chromium.org>
    [kees: switched structure size check to BUILD_BUG_ON (sboyd)]
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>

diff --git a/arch/arm/kernel/kgdb.c b/arch/arm/kernel/kgdb.c
index a74b53c1b7df..07db2f8a1b45 100644
--- a/arch/arm/kernel/kgdb.c
+++ b/arch/arm/kernel/kgdb.c
@@ -12,8 +12,12 @@
 #include <linux/irq.h>
 #include <linux/kdebug.h>
 #include <linux/kgdb.h>
+#include <linux/uaccess.h>
+
 #include <asm/traps.h>
 
+#include "patch.h"
+
 struct dbg_reg_def_t dbg_reg_def[DBG_MAX_REG_NUM] =
 {
 	{ "r0", 4, offsetof(struct pt_regs, ARM_r0)},
@@ -244,6 +248,31 @@ void kgdb_arch_exit(void)
 	unregister_die_notifier(&kgdb_notifier);
 }
 
+int kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt)
+{
+	int err;
+
+	/* patch_text() only supports int-sized breakpoints */
+	BUILD_BUG_ON(sizeof(int) != BREAK_INSTR_SIZE);
+
+	err = probe_kernel_read(bpt->saved_instr, (char *)bpt->bpt_addr,
+				BREAK_INSTR_SIZE);
+	if (err)
+		return err;
+
+	patch_text((void *)bpt->bpt_addr,
+		   *(unsigned int *)arch_kgdb_ops.gdb_bpt_instr);
+
+	return err;
+}
+
+int kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)
+{
+	patch_text((void *)bpt->bpt_addr, *(unsigned int *)bpt->saved_instr);
+
+	return 0;
+}
+
 /*
  * Register our undef instruction hooks with ARM undef core.
  * We regsiter a hook specifically looking for the KGB break inst

commit 6bf755db4d5e7ccea61fb17727a183b9bd8945b1
Author: Omar Sandoval <osandov@osandov.com>
Date:   Fri Aug 1 18:14:06 2014 +0100

    ARM: 8124/1: don't enter kgdb when userspace executes a kgdb break instruction
    
    The kgdb breakpoint hooks (kgdb_brk_fn and kgdb_compiled_brk_fn)
    should only be entered when a kgdb break instruction is executed
    from the kernel. Otherwise, if kgdb is enabled, a userspace program
    can cause the kernel to drop into the debugger by executing either
    KGDB_BREAKINST or KGDB_COMPILED_BREAK.
    
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/kgdb.c b/arch/arm/kernel/kgdb.c
index 778c2f7024ff..a74b53c1b7df 100644
--- a/arch/arm/kernel/kgdb.c
+++ b/arch/arm/kernel/kgdb.c
@@ -160,12 +160,16 @@ static int kgdb_compiled_brk_fn(struct pt_regs *regs, unsigned int instr)
 static struct undef_hook kgdb_brkpt_hook = {
 	.instr_mask		= 0xffffffff,
 	.instr_val		= KGDB_BREAKINST,
+	.cpsr_mask		= MODE_MASK,
+	.cpsr_val		= SVC_MODE,
 	.fn			= kgdb_brk_fn
 };
 
 static struct undef_hook kgdb_compiled_brkpt_hook = {
 	.instr_mask		= 0xffffffff,
 	.instr_val		= KGDB_COMPILED_BREAK,
+	.cpsr_mask		= MODE_MASK,
+	.cpsr_val		= SVC_MODE,
 	.fn			= kgdb_compiled_brk_fn
 };
 

commit 834b2964b7ab047610da038e42d61dc8dac6339a
Author: Rabin Vincent <rabin@rab.in>
Date:   Tue Oct 26 12:49:00 2010 -0500

    kgdb,arm: fix register dump
    
    DBG_MAX_REG_NUM incorrectly had the number of indices in the GDB regs
    array rather than the number of registers, leading to an oops when the
    "rd" command is used in KDB.
    
    Cc: stable@kernel.org
    Signed-off-by: Rabin Vincent <rabin@rab.in>
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/arch/arm/kernel/kgdb.c b/arch/arm/kernel/kgdb.c
index d6e8b4d2e60d..778c2f7024ff 100644
--- a/arch/arm/kernel/kgdb.c
+++ b/arch/arm/kernel/kgdb.c
@@ -79,7 +79,7 @@ sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *task)
 		return;
 
 	/* Initialize to zero */
-	for (regno = 0; regno < DBG_MAX_REG_NUM; regno++)
+	for (regno = 0; regno < GDB_MAX_REGS; regno++)
 		gdb_regs[regno] = 0;
 
 	/* Otherwise, we have only some registers from switch_to() */

commit 2f174847b0fdd4eb9f482030a284db24aef7a97f
Author: eric miao <eric.y.miao@gmail.com>
Date:   Thu Aug 12 16:43:00 2010 +0100

    ARM: 6326/1: kgdb: fix GDB_MAX_REGS no longer used
    
    According to commit 22eeef4bb2a7fd225089c0044060ed1fbf091958
    
        kgdb,arm: Individual register get/set for arm
    
    It's now replaced by DBG_MAX_REG_NUM.
    
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/kgdb.c b/arch/arm/kernel/kgdb.c
index 778c2f7024ff..d6e8b4d2e60d 100644
--- a/arch/arm/kernel/kgdb.c
+++ b/arch/arm/kernel/kgdb.c
@@ -79,7 +79,7 @@ sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *task)
 		return;
 
 	/* Initialize to zero */
-	for (regno = 0; regno < GDB_MAX_REGS; regno++)
+	for (regno = 0; regno < DBG_MAX_REG_NUM; regno++)
 		gdb_regs[regno] = 0;
 
 	/* Otherwise, we have only some registers from switch_to() */

commit 62a0309c4c99274052e4829ed6a8fe579dd2c767
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Thu Aug 5 09:22:22 2010 -0500

    arm,kgdb: Add ability to trap into debugger on notify_die
    
    Now that ARM implements the notify die handlers, add the ability for
    the kernel debugger to receive the notifications.
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    CC: Russell King <linux@arm.linux.org.uk>
    CC: linux-arm-kernel@lists.infradead.org

diff --git a/arch/arm/kernel/kgdb.c b/arch/arm/kernel/kgdb.c
index cf846cade354..778c2f7024ff 100644
--- a/arch/arm/kernel/kgdb.c
+++ b/arch/arm/kernel/kgdb.c
@@ -10,6 +10,7 @@
  *           Deepak Saxena <dsaxena@plexity.net>
  */
 #include <linux/irq.h>
+#include <linux/kdebug.h>
 #include <linux/kgdb.h>
 #include <asm/traps.h>
 
@@ -180,6 +181,33 @@ void kgdb_roundup_cpus(unsigned long flags)
        local_irq_disable();
 }
 
+static int __kgdb_notify(struct die_args *args, unsigned long cmd)
+{
+	struct pt_regs *regs = args->regs;
+
+	if (kgdb_handle_exception(1, args->signr, cmd, regs))
+		return NOTIFY_DONE;
+	return NOTIFY_STOP;
+}
+static int
+kgdb_notify(struct notifier_block *self, unsigned long cmd, void *ptr)
+{
+	unsigned long flags;
+	int ret;
+
+	local_irq_save(flags);
+	ret = __kgdb_notify(ptr, cmd);
+	local_irq_restore(flags);
+
+	return ret;
+}
+
+static struct notifier_block kgdb_notifier = {
+	.notifier_call	= kgdb_notify,
+	.priority	= -INT_MAX,
+};
+
+
 /**
  *	kgdb_arch_init - Perform any architecture specific initalization.
  *
@@ -188,6 +216,11 @@ void kgdb_roundup_cpus(unsigned long flags)
  */
 int kgdb_arch_init(void)
 {
+	int ret = register_die_notifier(&kgdb_notifier);
+
+	if (ret != 0)
+		return ret;
+
 	register_undef_hook(&kgdb_brkpt_hook);
 	register_undef_hook(&kgdb_compiled_brkpt_hook);
 
@@ -204,6 +237,7 @@ void kgdb_arch_exit(void)
 {
 	unregister_undef_hook(&kgdb_brkpt_hook);
 	unregister_undef_hook(&kgdb_compiled_brkpt_hook);
+	unregister_die_notifier(&kgdb_notifier);
 }
 
 /*

commit 22eeef4bb2a7fd225089c0044060ed1fbf091958
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Thu Aug 5 09:22:21 2010 -0500

    kgdb,arm: Individual register get/set for arm
    
    Implement the ability to individually get and set registers for kdb
    and kgdb for arm.
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    CC: Russell King <linux@arm.linux.org.uk>
    CC: linux-arm-kernel@lists.infradead.org

diff --git a/arch/arm/kernel/kgdb.c b/arch/arm/kernel/kgdb.c
index c868a8864117..cf846cade354 100644
--- a/arch/arm/kernel/kgdb.c
+++ b/arch/arm/kernel/kgdb.c
@@ -13,54 +13,58 @@
 #include <linux/kgdb.h>
 #include <asm/traps.h>
 
-/* Make a local copy of the registers passed into the handler (bletch) */
-void pt_regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *kernel_regs)
+struct dbg_reg_def_t dbg_reg_def[DBG_MAX_REG_NUM] =
 {
-	int regno;
-
-	/* Initialize all to zero. */
-	for (regno = 0; regno < GDB_MAX_REGS; regno++)
-		gdb_regs[regno] = 0;
+	{ "r0", 4, offsetof(struct pt_regs, ARM_r0)},
+	{ "r1", 4, offsetof(struct pt_regs, ARM_r1)},
+	{ "r2", 4, offsetof(struct pt_regs, ARM_r2)},
+	{ "r3", 4, offsetof(struct pt_regs, ARM_r3)},
+	{ "r4", 4, offsetof(struct pt_regs, ARM_r4)},
+	{ "r5", 4, offsetof(struct pt_regs, ARM_r5)},
+	{ "r6", 4, offsetof(struct pt_regs, ARM_r6)},
+	{ "r7", 4, offsetof(struct pt_regs, ARM_r7)},
+	{ "r8", 4, offsetof(struct pt_regs, ARM_r8)},
+	{ "r9", 4, offsetof(struct pt_regs, ARM_r9)},
+	{ "r10", 4, offsetof(struct pt_regs, ARM_r10)},
+	{ "fp", 4, offsetof(struct pt_regs, ARM_fp)},
+	{ "ip", 4, offsetof(struct pt_regs, ARM_ip)},
+	{ "sp", 4, offsetof(struct pt_regs, ARM_sp)},
+	{ "lr", 4, offsetof(struct pt_regs, ARM_lr)},
+	{ "pc", 4, offsetof(struct pt_regs, ARM_pc)},
+	{ "f0", 12, -1 },
+	{ "f1", 12, -1 },
+	{ "f2", 12, -1 },
+	{ "f3", 12, -1 },
+	{ "f4", 12, -1 },
+	{ "f5", 12, -1 },
+	{ "f6", 12, -1 },
+	{ "f7", 12, -1 },
+	{ "fps", 4, -1 },
+	{ "cpsr", 4, offsetof(struct pt_regs, ARM_cpsr)},
+};
 
-	gdb_regs[_R0]		= kernel_regs->ARM_r0;
-	gdb_regs[_R1]		= kernel_regs->ARM_r1;
-	gdb_regs[_R2]		= kernel_regs->ARM_r2;
-	gdb_regs[_R3]		= kernel_regs->ARM_r3;
-	gdb_regs[_R4]		= kernel_regs->ARM_r4;
-	gdb_regs[_R5]		= kernel_regs->ARM_r5;
-	gdb_regs[_R6]		= kernel_regs->ARM_r6;
-	gdb_regs[_R7]		= kernel_regs->ARM_r7;
-	gdb_regs[_R8]		= kernel_regs->ARM_r8;
-	gdb_regs[_R9]		= kernel_regs->ARM_r9;
-	gdb_regs[_R10]		= kernel_regs->ARM_r10;
-	gdb_regs[_FP]		= kernel_regs->ARM_fp;
-	gdb_regs[_IP]		= kernel_regs->ARM_ip;
-	gdb_regs[_SPT]		= kernel_regs->ARM_sp;
-	gdb_regs[_LR]		= kernel_regs->ARM_lr;
-	gdb_regs[_PC]		= kernel_regs->ARM_pc;
-	gdb_regs[_CPSR]		= kernel_regs->ARM_cpsr;
+char *dbg_get_reg(int regno, void *mem, struct pt_regs *regs)
+{
+	if (regno >= DBG_MAX_REG_NUM || regno < 0)
+		return NULL;
+
+	if (dbg_reg_def[regno].offset != -1)
+		memcpy(mem, (void *)regs + dbg_reg_def[regno].offset,
+		       dbg_reg_def[regno].size);
+	else
+		memset(mem, 0, dbg_reg_def[regno].size);
+	return dbg_reg_def[regno].name;
 }
 
-/* Copy local gdb registers back to kgdb regs, for later copy to kernel */
-void gdb_regs_to_pt_regs(unsigned long *gdb_regs, struct pt_regs *kernel_regs)
+int dbg_set_reg(int regno, void *mem, struct pt_regs *regs)
 {
-	kernel_regs->ARM_r0	= gdb_regs[_R0];
-	kernel_regs->ARM_r1	= gdb_regs[_R1];
-	kernel_regs->ARM_r2	= gdb_regs[_R2];
-	kernel_regs->ARM_r3	= gdb_regs[_R3];
-	kernel_regs->ARM_r4	= gdb_regs[_R4];
-	kernel_regs->ARM_r5	= gdb_regs[_R5];
-	kernel_regs->ARM_r6	= gdb_regs[_R6];
-	kernel_regs->ARM_r7	= gdb_regs[_R7];
-	kernel_regs->ARM_r8	= gdb_regs[_R8];
-	kernel_regs->ARM_r9	= gdb_regs[_R9];
-	kernel_regs->ARM_r10	= gdb_regs[_R10];
-	kernel_regs->ARM_fp	= gdb_regs[_FP];
-	kernel_regs->ARM_ip	= gdb_regs[_IP];
-	kernel_regs->ARM_sp	= gdb_regs[_SPT];
-	kernel_regs->ARM_lr	= gdb_regs[_LR];
-	kernel_regs->ARM_pc	= gdb_regs[_PC];
-	kernel_regs->ARM_cpsr	= gdb_regs[_CPSR];
+	if (regno >= DBG_MAX_REG_NUM || regno < 0)
+		return -EINVAL;
+
+	if (dbg_reg_def[regno].offset != -1)
+		memcpy((void *)regs + dbg_reg_def[regno].offset, mem,
+		       dbg_reg_def[regno].size);
+	return 0;
 }
 
 void

commit dcc7871128e99458ca86186b7bc8bf27ff0c47b5
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Thu May 20 21:04:21 2010 -0500

    kgdb: core changes to support kdb
    
    These are the minimum changes to the kgdb core in order to enable an
    API to connect a new front end (kdb) to the debug core.
    
    This patch introduces the dbg_kdb_mode variable controls where the
    user level I/O is routed.  It will be routed to the gdbstub (kgdb) or
    to the kdb front end which is a simple shell available over the kgdboc
    connection.
    
    You can switch back and forth between kdb or the gdb stub mode of
    operation dynamically.  From gdb stub mode you can blindly type
    "$3#33", or from the kdb mode you can enter "kgdb" to switch to the
    gdb stub.
    
    The logic in the debug core depends on kdb to look for the typical gdb
    connection sequences and return immediately with KGDB_PASS_EVENT if a
    gdb serial command sequence is detected.  That should allow a
    reasonably seamless transition between kdb -> gdb without leaving the
    kernel exception state.  The two gdb serial queries that kdb is
    responsible for detecting are the "?" and "qSupported" packets.
    
    CC: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    Acked-by: Martin Hicks <mort@sgi.com>

diff --git a/arch/arm/kernel/kgdb.c b/arch/arm/kernel/kgdb.c
index a5b846b9895d..c868a8864117 100644
--- a/arch/arm/kernel/kgdb.c
+++ b/arch/arm/kernel/kgdb.c
@@ -98,6 +98,11 @@ sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *task)
 	gdb_regs[_CPSR]		= thread_regs->ARM_cpsr;
 }
 
+void kgdb_arch_set_pc(struct pt_regs *regs, unsigned long pc)
+{
+	regs->ARM_pc = pc;
+}
+
 static int compiled_break;
 
 int kgdb_arch_handle_exception(int exception_vector, int signo,

commit 5d8614cc5d6c5c02b7995ed97303481d4e3a8cc7
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Mar 12 11:03:58 2010 +0100

    ARM: 5989/1: ARM: KGDB: add support for SMP platforms
    
    To support SMP platforms, KGDB requires the architecture backend to
    implement the kgdb_roundup_cpus function.
    
    This patch, taken against 2.6.33, implements the function for ARM based
    on the MIPS port.
    
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Jean-Michel Hautbois <jhautbois@gmail.com>
    Cc: KGDB Mailing List <kgdb-bugreport@lists.sourceforge.net>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/kgdb.c b/arch/arm/kernel/kgdb.c
index ba8ccfede964..a5b846b9895d 100644
--- a/arch/arm/kernel/kgdb.c
+++ b/arch/arm/kernel/kgdb.c
@@ -9,6 +9,7 @@
  * Authors:  George Davis <davis_g@mvista.com>
  *           Deepak Saxena <dsaxena@plexity.net>
  */
+#include <linux/irq.h>
 #include <linux/kgdb.h>
 #include <asm/traps.h>
 
@@ -158,6 +159,18 @@ static struct undef_hook kgdb_compiled_brkpt_hook = {
 	.fn			= kgdb_compiled_brk_fn
 };
 
+static void kgdb_call_nmi_hook(void *ignored)
+{
+       kgdb_nmicallback(raw_smp_processor_id(), get_irq_regs());
+}
+
+void kgdb_roundup_cpus(unsigned long flags)
+{
+       local_irq_enable();
+       smp_call_function(kgdb_call_nmi_hook, NULL, 0);
+       local_irq_disable();
+}
+
 /**
  *	kgdb_arch_init - Perform any architecture specific initalization.
  *

commit d7161a65341556bacb5e6654e133803f46f51063
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Fri Sep 26 10:36:41 2008 -0500

    kgdb, x86, arm, mips, powerpc: ignore user space single stepping
    
    On the x86 arch, user space single step exceptions should be ignored
    if they occur in the kernel space, such as ptrace stepping through a
    system call.
    
    First check if it is kgdb that is executing a single step, then ensure
    it is not an accidental traversal into the user space, while in kgdb,
    any other time the TIF_SINGLESTEP is set, kgdb should ignore the
    exception.
    
    On x86, arm, mips and powerpc, the kgdb_contthread usage was
    inconsistent with the way single stepping is implemented in the kgdb
    core.  The arch specific stub should always set the
    kgdb_cpu_doing_single_step correctly if it is single stepping.  This
    allows kgdb to correctly process an instruction steps if ptrace
    happens to be requesting an instruction step over a system call.
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/arch/arm/kernel/kgdb.c b/arch/arm/kernel/kgdb.c
index aaffaecffcd1..ba8ccfede964 100644
--- a/arch/arm/kernel/kgdb.c
+++ b/arch/arm/kernel/kgdb.c
@@ -111,8 +111,6 @@ int kgdb_arch_handle_exception(int exception_vector, int signo,
 	case 'D':
 	case 'k':
 	case 'c':
-		kgdb_contthread = NULL;
-
 		/*
 		 * Try to read optional parameter, pc unchanged if no parm.
 		 * If this was a compiled breakpoint, we need to move

commit 5cbad0ebf45c5417104b383dc0e34f64fa7f2473
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Wed Feb 20 13:33:40 2008 -0600

    kgdb: support for ARCH=arm
    
    This patch adds the ARCH=arm specific a kgdb backend, originally
    written by Deepak Saxena <dsaxena@plexity.net> and George Davis
    <gdavis@mvista.com>.  Geoff Levand <geoffrey.levand@am.sony.com>,
    Nicolas Pitre, Manish Lachwani, and Jason Wessel have contributed
    various fixups here as well.
    
    The KGDB patch makes one change to the core ARM architecture such that
    the traps are initialized early for use with the debugger or other
    subsystems.
    
    [ mingo@elte.hu: small cleanups. ]
    [ ben-linux@fluff.org: fixed early_trap_init ]
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    Acked-by: Deepak Saxena <dsaxena@plexity.net>

diff --git a/arch/arm/kernel/kgdb.c b/arch/arm/kernel/kgdb.c
new file mode 100644
index 000000000000..aaffaecffcd1
--- /dev/null
+++ b/arch/arm/kernel/kgdb.c
@@ -0,0 +1,201 @@
+/*
+ * arch/arm/kernel/kgdb.c
+ *
+ * ARM KGDB support
+ *
+ * Copyright (c) 2002-2004 MontaVista Software, Inc
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * Authors:  George Davis <davis_g@mvista.com>
+ *           Deepak Saxena <dsaxena@plexity.net>
+ */
+#include <linux/kgdb.h>
+#include <asm/traps.h>
+
+/* Make a local copy of the registers passed into the handler (bletch) */
+void pt_regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *kernel_regs)
+{
+	int regno;
+
+	/* Initialize all to zero. */
+	for (regno = 0; regno < GDB_MAX_REGS; regno++)
+		gdb_regs[regno] = 0;
+
+	gdb_regs[_R0]		= kernel_regs->ARM_r0;
+	gdb_regs[_R1]		= kernel_regs->ARM_r1;
+	gdb_regs[_R2]		= kernel_regs->ARM_r2;
+	gdb_regs[_R3]		= kernel_regs->ARM_r3;
+	gdb_regs[_R4]		= kernel_regs->ARM_r4;
+	gdb_regs[_R5]		= kernel_regs->ARM_r5;
+	gdb_regs[_R6]		= kernel_regs->ARM_r6;
+	gdb_regs[_R7]		= kernel_regs->ARM_r7;
+	gdb_regs[_R8]		= kernel_regs->ARM_r8;
+	gdb_regs[_R9]		= kernel_regs->ARM_r9;
+	gdb_regs[_R10]		= kernel_regs->ARM_r10;
+	gdb_regs[_FP]		= kernel_regs->ARM_fp;
+	gdb_regs[_IP]		= kernel_regs->ARM_ip;
+	gdb_regs[_SPT]		= kernel_regs->ARM_sp;
+	gdb_regs[_LR]		= kernel_regs->ARM_lr;
+	gdb_regs[_PC]		= kernel_regs->ARM_pc;
+	gdb_regs[_CPSR]		= kernel_regs->ARM_cpsr;
+}
+
+/* Copy local gdb registers back to kgdb regs, for later copy to kernel */
+void gdb_regs_to_pt_regs(unsigned long *gdb_regs, struct pt_regs *kernel_regs)
+{
+	kernel_regs->ARM_r0	= gdb_regs[_R0];
+	kernel_regs->ARM_r1	= gdb_regs[_R1];
+	kernel_regs->ARM_r2	= gdb_regs[_R2];
+	kernel_regs->ARM_r3	= gdb_regs[_R3];
+	kernel_regs->ARM_r4	= gdb_regs[_R4];
+	kernel_regs->ARM_r5	= gdb_regs[_R5];
+	kernel_regs->ARM_r6	= gdb_regs[_R6];
+	kernel_regs->ARM_r7	= gdb_regs[_R7];
+	kernel_regs->ARM_r8	= gdb_regs[_R8];
+	kernel_regs->ARM_r9	= gdb_regs[_R9];
+	kernel_regs->ARM_r10	= gdb_regs[_R10];
+	kernel_regs->ARM_fp	= gdb_regs[_FP];
+	kernel_regs->ARM_ip	= gdb_regs[_IP];
+	kernel_regs->ARM_sp	= gdb_regs[_SPT];
+	kernel_regs->ARM_lr	= gdb_regs[_LR];
+	kernel_regs->ARM_pc	= gdb_regs[_PC];
+	kernel_regs->ARM_cpsr	= gdb_regs[_CPSR];
+}
+
+void
+sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *task)
+{
+	struct pt_regs *thread_regs;
+	int regno;
+
+	/* Just making sure... */
+	if (task == NULL)
+		return;
+
+	/* Initialize to zero */
+	for (regno = 0; regno < GDB_MAX_REGS; regno++)
+		gdb_regs[regno] = 0;
+
+	/* Otherwise, we have only some registers from switch_to() */
+	thread_regs		= task_pt_regs(task);
+	gdb_regs[_R0]		= thread_regs->ARM_r0;
+	gdb_regs[_R1]		= thread_regs->ARM_r1;
+	gdb_regs[_R2]		= thread_regs->ARM_r2;
+	gdb_regs[_R3]		= thread_regs->ARM_r3;
+	gdb_regs[_R4]		= thread_regs->ARM_r4;
+	gdb_regs[_R5]		= thread_regs->ARM_r5;
+	gdb_regs[_R6]		= thread_regs->ARM_r6;
+	gdb_regs[_R7]		= thread_regs->ARM_r7;
+	gdb_regs[_R8]		= thread_regs->ARM_r8;
+	gdb_regs[_R9]		= thread_regs->ARM_r9;
+	gdb_regs[_R10]		= thread_regs->ARM_r10;
+	gdb_regs[_FP]		= thread_regs->ARM_fp;
+	gdb_regs[_IP]		= thread_regs->ARM_ip;
+	gdb_regs[_SPT]		= thread_regs->ARM_sp;
+	gdb_regs[_LR]		= thread_regs->ARM_lr;
+	gdb_regs[_PC]		= thread_regs->ARM_pc;
+	gdb_regs[_CPSR]		= thread_regs->ARM_cpsr;
+}
+
+static int compiled_break;
+
+int kgdb_arch_handle_exception(int exception_vector, int signo,
+			       int err_code, char *remcom_in_buffer,
+			       char *remcom_out_buffer,
+			       struct pt_regs *linux_regs)
+{
+	unsigned long addr;
+	char *ptr;
+
+	switch (remcom_in_buffer[0]) {
+	case 'D':
+	case 'k':
+	case 'c':
+		kgdb_contthread = NULL;
+
+		/*
+		 * Try to read optional parameter, pc unchanged if no parm.
+		 * If this was a compiled breakpoint, we need to move
+		 * to the next instruction or we will just breakpoint
+		 * over and over again.
+		 */
+		ptr = &remcom_in_buffer[1];
+		if (kgdb_hex2long(&ptr, &addr))
+			linux_regs->ARM_pc = addr;
+		else if (compiled_break == 1)
+			linux_regs->ARM_pc += 4;
+
+		compiled_break = 0;
+
+		return 0;
+	}
+
+	return -1;
+}
+
+static int kgdb_brk_fn(struct pt_regs *regs, unsigned int instr)
+{
+	kgdb_handle_exception(1, SIGTRAP, 0, regs);
+
+	return 0;
+}
+
+static int kgdb_compiled_brk_fn(struct pt_regs *regs, unsigned int instr)
+{
+	compiled_break = 1;
+	kgdb_handle_exception(1, SIGTRAP, 0, regs);
+
+	return 0;
+}
+
+static struct undef_hook kgdb_brkpt_hook = {
+	.instr_mask		= 0xffffffff,
+	.instr_val		= KGDB_BREAKINST,
+	.fn			= kgdb_brk_fn
+};
+
+static struct undef_hook kgdb_compiled_brkpt_hook = {
+	.instr_mask		= 0xffffffff,
+	.instr_val		= KGDB_COMPILED_BREAK,
+	.fn			= kgdb_compiled_brk_fn
+};
+
+/**
+ *	kgdb_arch_init - Perform any architecture specific initalization.
+ *
+ *	This function will handle the initalization of any architecture
+ *	specific callbacks.
+ */
+int kgdb_arch_init(void)
+{
+	register_undef_hook(&kgdb_brkpt_hook);
+	register_undef_hook(&kgdb_compiled_brkpt_hook);
+
+	return 0;
+}
+
+/**
+ *	kgdb_arch_exit - Perform any architecture specific uninitalization.
+ *
+ *	This function will handle the uninitalization of any architecture
+ *	specific callbacks, for dynamic registration and unregistration.
+ */
+void kgdb_arch_exit(void)
+{
+	unregister_undef_hook(&kgdb_brkpt_hook);
+	unregister_undef_hook(&kgdb_compiled_brkpt_hook);
+}
+
+/*
+ * Register our undef instruction hooks with ARM undef core.
+ * We regsiter a hook specifically looking for the KGB break inst
+ * and we handle the normal undef case within the do_undefinstr
+ * handler.
+ */
+struct kgdb_arch arch_kgdb_ops = {
+#ifndef __ARMEB__
+	.gdb_bpt_instr		= {0xfe, 0xde, 0xff, 0xe7}
+#else /* ! __ARMEB__ */
+	.gdb_bpt_instr		= {0xe7, 0xff, 0xde, 0xfe}
+#endif
+};
