commit 40ff1ddb5570284e039e0ff14d7a859a73dc3673
Author: Vincent Whitchurch <vincent.whitchurch@axis.com>
Date:   Mon Dec 16 11:48:28 2019 +0100

    ARM: 8948/1: Prevent OOB access in stacktrace
    
    The stacktrace code can read beyond the stack size, when it attempts to
    read pt_regs from exception frames.
    
    This can happen on normal, non-corrupt stacks.  Since the unwind
    information in the extable is not correct for function prologues, the
    unwinding code can return data from the stack which is not actually the
    caller function address, and if in_entry_text() happens to succeed on
    this value, we can end up reading data from outside the task's stack
    when attempting to read pt_regs, since there is no bounds check.
    
    Example:
    
     [<8010e729>] (unwind_backtrace) from [<8010a9c9>] (show_stack+0x11/0x14)
     [<8010a9c9>] (show_stack) from [<8057d8d7>] (dump_stack+0x87/0xac)
     [<8057d8d7>] (dump_stack) from [<8012271d>] (tasklet_action_common.constprop.4+0xa5/0xa8)
     [<8012271d>] (tasklet_action_common.constprop.4) from [<80102333>] (__do_softirq+0x11b/0x31c)
     [<80102333>] (__do_softirq) from [<80122485>] (irq_exit+0xad/0xd8)
     [<80122485>] (irq_exit) from [<8015f3d7>] (__handle_domain_irq+0x47/0x84)
     [<8015f3d7>] (__handle_domain_irq) from [<8036a523>] (gic_handle_irq+0x43/0x78)
     [<8036a523>] (gic_handle_irq) from [<80101a49>] (__irq_svc+0x69/0xb4)
     Exception stack(0xeb491f58 to 0xeb491fa0)
     1f40:                                                       7eb14794 00000000
     1f60: ffffffff 008dd32c 008dd324 ffffffff 008dd314 0000002a 801011e4 eb490000
     1f80: 0000002a 7eb1478c 50c5387d eb491fa8 80101001 8023d09c 40080033 ffffffff
     [<80101a49>] (__irq_svc) from [<8023d09c>] (do_pipe2+0x0/0xac)
     [<8023d09c>] (do_pipe2) from [<ffffffff>] (0xffffffff)
     Exception stack(0xeb491fc8 to 0xeb492010)
     1fc0:                   008dd314 0000002a 00511ad8 008de4c8 7eb14790 7eb1478c
     1fe0: 00511e34 7eb14774 004c8557 76f44098 60080030 7eb14794 00000000 00000000
     2000: 00000001 00000000 ea846c00 ea847cc0
    
    In this example, the stack limit is 0xeb492000, but 16 bytes outside the
    stack have been read.
    
    Fix it by adding bounds checks.
    
    Signed-off-by: Vincent Whitchurch <vincent.whitchurch@axis.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index 71778bb0475b..cc726afea023 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -92,6 +92,8 @@ static int save_trace(struct stackframe *frame, void *d)
 		return 0;
 
 	regs = (struct pt_regs *)frame->sp;
+	if ((unsigned long)&regs[1] > ALIGN(frame->sp, THREAD_SIZE))
+		return 0;
 
 	trace->entries[trace->nr_entries++] = regs->ARM_pc;
 

commit 457c89965399115e5cd8bf38f9c597293405703d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:55 2019 +0100

    treewide: Add SPDX license identifier for missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have EXPORT_.*_SYMBOL_GPL inside which was used in the
       initial scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index 86870f40f9a0..71778bb0475b 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 #include <linux/export.h>
 #include <linux/sched.h>
 #include <linux/sched/debug.h>

commit 2a2bcfa0c94d8bc4770676a6799928036296c037
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Apr 10 12:27:57 2019 +0200

    arm/stacktrace: Remove the pointless ULONG_MAX marker
    
    Terminating the last trace entry with ULONG_MAX is a completely pointless
    exercise and none of the consumers can rely on it because it's
    inconsistently implemented across architectures. In fact quite some of the
    callers remove the entry and adjust stack_trace.nr_entries afterwards.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Alexander Potapenko <glider@google.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: linux-arm-kernel@lists.infradead.org
    Link: https://lkml.kernel.org/r/20190410103643.843075256@linutronix.de

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index a56e7c856ab5..86870f40f9a0 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -115,8 +115,6 @@ static noinline void __save_stack_trace(struct task_struct *tsk,
 		 * running on another CPU?  For now, ignore it as we
 		 * can't guarantee we won't explode.
 		 */
-		if (trace->nr_entries < trace->max_entries)
-			trace->entries[trace->nr_entries++] = ULONG_MAX;
 		return;
 #else
 		frame.fp = thread_saved_fp(tsk);
@@ -134,8 +132,6 @@ static noinline void __save_stack_trace(struct task_struct *tsk,
 	}
 
 	walk_stackframe(&frame, save_trace, &data);
-	if (trace->nr_entries < trace->max_entries)
-		trace->entries[trace->nr_entries++] = ULONG_MAX;
 }
 
 void save_stack_trace_regs(struct pt_regs *regs, struct stack_trace *trace)
@@ -153,8 +149,6 @@ void save_stack_trace_regs(struct pt_regs *regs, struct stack_trace *trace)
 	frame.pc = regs->ARM_pc;
 
 	walk_stackframe(&frame, save_trace, &data);
-	if (trace->nr_entries < trace->max_entries)
-		trace->entries[trace->nr_entries++] = ULONG_MAX;
 }
 
 void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)

commit c608906165355089a4de3c9133c72e81e011096c
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Fri Nov 24 23:54:22 2017 +0000

    ARM: probes: avoid adding kprobes to sensitive kernel-entry/exit code
    
    Avoid adding kprobes to any of the kernel entry/exit or startup
    assembly code, or code in the identity-mapped region.  This code does
    not conform to the standard C conventions, which means that the
    expectations of the kprobes code is not forfilled.
    
    Placing kprobes at some of these locations results in the kernel trying
    to return to userspace addresses while retaining the CPU in kernel mode.
    
    Tested-by: Naresh Kamboju <naresh.kamboju@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index 65228bf4c6df..a56e7c856ab5 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -3,6 +3,7 @@
 #include <linux/sched/debug.h>
 #include <linux/stacktrace.h>
 
+#include <asm/sections.h>
 #include <asm/stacktrace.h>
 #include <asm/traps.h>
 
@@ -63,7 +64,6 @@ EXPORT_SYMBOL(walk_stackframe);
 #ifdef CONFIG_STACKTRACE
 struct stack_trace_data {
 	struct stack_trace *trace;
-	unsigned long last_pc;
 	unsigned int no_sched_functions;
 	unsigned int skip;
 };
@@ -87,16 +87,7 @@ static int save_trace(struct stackframe *frame, void *d)
 	if (trace->nr_entries >= trace->max_entries)
 		return 1;
 
-	/*
-	 * in_exception_text() is designed to test if the PC is one of
-	 * the functions which has an exception stack above it, but
-	 * unfortunately what is in frame->pc is the return LR value,
-	 * not the saved PC value.  So, we need to track the previous
-	 * frame PC value when doing this.
-	 */
-	addr = data->last_pc;
-	data->last_pc = frame->pc;
-	if (!in_exception_text(addr))
+	if (!in_entry_text(frame->pc))
 		return 0;
 
 	regs = (struct pt_regs *)frame->sp;
@@ -114,7 +105,6 @@ static noinline void __save_stack_trace(struct task_struct *tsk,
 	struct stackframe frame;
 
 	data.trace = trace;
-	data.last_pc = ULONG_MAX;
 	data.skip = trace->skip;
 	data.no_sched_functions = nosched;
 

commit 9a3dc3186fc3795e076a4122da9e0258651a9631
Author: Dustin Brown <dustinb@codeaurora.org>
Date:   Mon Aug 7 19:44:01 2017 +0100

    ARM: 8691/1: Export save_stack_trace_tsk()
    
    The kernel watchdog is a great debugging tool for finding tasks that
    consume a disproportionate amount of CPU time in contiguous chunks. One
    can imagine building a similar watchdog for arbitrary driver threads
    using save_stack_trace_tsk() and print_stack_trace(). However, this is
    not viable for dynamically loaded driver modules on ARM platforms
    because save_stack_trace_tsk() is not exported for those architectures.
    Export save_stack_trace_tsk() for the ARM architecture to align with
    x86 and support various debugging use cases such as arbitrary driver
    thread watchdog timers.
    
    Signed-off-by: Dustin Brown <dustinb@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index 3a2fa203637a..65228bf4c6df 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -171,6 +171,7 @@ void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 {
 	__save_stack_trace(tsk, trace, 1);
 }
+EXPORT_SYMBOL(save_stack_trace_tsk);
 
 void save_stack_trace(struct stack_trace *trace)
 {

commit b17b01533b719e9949e437abf66436a875739b40
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 8 18:51:35 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <linux/sched/debug.h>
    
    We are going to split <linux/sched/debug.h> out of <linux/sched.h>, which
    will have to be picked up from other headers and a couple of .c files.
    
    Create a trivial placeholder <linux/sched/debug.h> file that just
    maps to <linux/sched.h> to make this patch obviously correct and
    bisectable.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index 92b72375c4c7..3a2fa203637a 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -1,5 +1,6 @@
 #include <linux/export.h>
 #include <linux/sched.h>
+#include <linux/sched/debug.h>
 #include <linux/stacktrace.h>
 
 #include <asm/stacktrace.h>

commit 74dbeee0fcded9525ddb42b53ee75dc62c8089d9
Author: Behan Webster <behanw@converseincode.com>
Date:   Sat Sep 27 00:31:08 2014 +0100

    ARM: 8172/1: Use current_stack_pointer in save_stack_trace_tsk
    
    Use the global current_stack_pointer to get the value of the stack pointer.
    This change supports being able to compile the kernel with both gcc and clang.
    
    Signed-off-by: Behan Webster <behanw@converseincode.com>
    Reviewed-by: Mark Charlebois <charlebm@gmail.com>
    Reviewed-by: Jan-Simon Möller <dl9pf@gmx.de>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index f065eb05d254..92b72375c4c7 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -134,12 +134,10 @@ static noinline void __save_stack_trace(struct task_struct *tsk,
 		frame.pc = thread_saved_pc(tsk);
 #endif
 	} else {
-		register unsigned long current_sp asm ("sp");
-
 		/* We don't want this function nor the caller */
 		data.skip += 2;
 		frame.fp = (unsigned long)__builtin_frame_address(0);
-		frame.sp = current_sp;
+		frame.sp = current_stack_pointer;
 		frame.lr = (unsigned long)__builtin_return_address(0);
 		frame.pc = (unsigned long)__save_stack_trace;
 	}

commit 9c986661638c69772f5479c4715061239ec61b29
Author: Lin Yongting <linyongting@gmail.com>
Date:   Sun May 4 16:27:41 2014 +0100

    ARM: 8049/1: ftrace/add save_stack_trace_regs() implementation
    
    When configure kprobe events of ftrace with "stacktrace" option enabled
    in arm, there is no stacktrace was recorded after the kprobe event was
    triggered. The root cause is no save_stack_trace_regs() function implemented.
    
    Implement the save_stack_trace_regs() function in arm, then ftrace will
    call this architecture-related function to record the stacktrace into
    ring buffer.
    
    After this fix, stacktrace can be recorded, for example:
    
     # mount -t debugfs nodev /sys/kernel/debug
     # echo "p:netrx net_rx_action" >> /sys/kernel/debug/tracing/kprobe_events
     # echo 1 > /sys/kernel/debug/tracing/events/kprobes/netrx/enable
     # echo 1 > /sys/kernel/debug/tracing/options/stacktrace
     # echo 1 > /sys/kernel/debug/tracing/tracing_on
     # ping 127.0.0.1 -c 1
     # echo 0 > /sys/kernel/debug/tracing/tracing_on
    
     # cat /sys/kernel/debug/tracing/trace
     # tracer: nop
     #
     # entries-in-buffer/entries-written: 12/12   #P:1
     #
     #                              _-----=> irqs-off
     #                             / _----=> need-resched
     #                            | / _---=> hardirq/softirq
     #                            || / _--=> preempt-depth
     #                            ||| /     delay
     #           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION
     #              | |       |   ||||       |         |
                 <------ missing some entries ---------------->
                 ping-1200  [000] dNs1   667.603250: netrx: (net_rx_action+0x0/0x1f8)
                 ping-1200  [000] dNs1   667.604738: <stack trace>
      => net_rx_action
      => do_softirq
      => local_bh_enable
      => ip_finish_output
      => ip_output
      => ip_local_out
      => ip_send_skb
      => ip_push_pending_frames
      => raw_sendmsg
      => inet_sendmsg
      => sock_sendmsg
      => SyS_sendto
      => ret_fast_syscall
    
    Signed-off-by: Lin Yongting <linyongting@gmail.com>
    Acked-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index 5a80ddfe7031..f065eb05d254 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -149,6 +149,25 @@ static noinline void __save_stack_trace(struct task_struct *tsk,
 		trace->entries[trace->nr_entries++] = ULONG_MAX;
 }
 
+void save_stack_trace_regs(struct pt_regs *regs, struct stack_trace *trace)
+{
+	struct stack_trace_data data;
+	struct stackframe frame;
+
+	data.trace = trace;
+	data.skip = trace->skip;
+	data.no_sched_functions = 0;
+
+	frame.fp = regs->ARM_fp;
+	frame.sp = regs->ARM_sp;
+	frame.lr = regs->ARM_lr;
+	frame.pc = regs->ARM_pc;
+
+	walk_stackframe(&frame, save_trace, &data);
+	if (trace->nr_entries < trace->max_entries)
+		trace->entries[trace->nr_entries++] = ULONG_MAX;
+}
+
 void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 {
 	__save_stack_trace(tsk, trace, 1);

commit 07b403415884e961920f55e6db462dff15d9df5a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat May 3 16:17:16 2014 +0100

    ARM: stacktrace: include exception PC value in stacktrace output
    
    When we unwind through an exception stack, include the saved PC value
    into the stack trace: this fills in an otherwise missed functions from
    the trace (as indicated below):
    
     [<c03f4424>] fec_enet_interrupt+0xa0/0xe8
     [<c0066c0c>] handle_irq_event_percpu+0x68/0x228
     [<c0066e18>] handle_irq_event+0x4c/0x6c
     [<c006a024>] handle_fasteoi_irq+0xac/0x198
     [<c00664b0>] generic_handle_irq+0x4c/0x60
     [<c000f014>] handle_IRQ+0x40/0x98
     [<c0008554>] gic_handle_irq+0x30/0x64
     [<c0012900>] __irq_svc+0x40/0x50
     [<c0029030>] __do_softirq+0xe0/0x2fc           <====
     [<c0029500>] irq_exit+0xb0/0x100
     [<c000f018>] handle_IRQ+0x44/0x98
     [<c0008554>] gic_handle_irq+0x30/0x64
     [<c0012900>] __irq_svc+0x40/0x50
     [<c000f34c>] arch_cpu_idle+0x30/0x38           <====
     [<c005e1e4>] cpu_startup_entry+0xac/0x214
     [<c066297c>] rest_init+0x68/0x80
     [<c08ccb10>] start_kernel+0x2fc/0x358
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index 6582c4adc182..5a80ddfe7031 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -3,6 +3,7 @@
 #include <linux/stacktrace.h>
 
 #include <asm/stacktrace.h>
+#include <asm/traps.h>
 
 #if defined(CONFIG_FRAME_POINTER) && !defined(CONFIG_ARM_UNWIND)
 /*
@@ -61,6 +62,7 @@ EXPORT_SYMBOL(walk_stackframe);
 #ifdef CONFIG_STACKTRACE
 struct stack_trace_data {
 	struct stack_trace *trace;
+	unsigned long last_pc;
 	unsigned int no_sched_functions;
 	unsigned int skip;
 };
@@ -69,6 +71,7 @@ static int save_trace(struct stackframe *frame, void *d)
 {
 	struct stack_trace_data *data = d;
 	struct stack_trace *trace = data->trace;
+	struct pt_regs *regs;
 	unsigned long addr = frame->pc;
 
 	if (data->no_sched_functions && in_sched_functions(addr))
@@ -80,6 +83,25 @@ static int save_trace(struct stackframe *frame, void *d)
 
 	trace->entries[trace->nr_entries++] = addr;
 
+	if (trace->nr_entries >= trace->max_entries)
+		return 1;
+
+	/*
+	 * in_exception_text() is designed to test if the PC is one of
+	 * the functions which has an exception stack above it, but
+	 * unfortunately what is in frame->pc is the return LR value,
+	 * not the saved PC value.  So, we need to track the previous
+	 * frame PC value when doing this.
+	 */
+	addr = data->last_pc;
+	data->last_pc = frame->pc;
+	if (!in_exception_text(addr))
+		return 0;
+
+	regs = (struct pt_regs *)frame->sp;
+
+	trace->entries[trace->nr_entries++] = regs->ARM_pc;
+
 	return trace->nr_entries >= trace->max_entries;
 }
 
@@ -91,6 +113,7 @@ static noinline void __save_stack_trace(struct task_struct *tsk,
 	struct stackframe frame;
 
 	data.trace = trace;
+	data.last_pc = ULONG_MAX;
 	data.skip = trace->skip;
 	data.no_sched_functions = nosched;
 

commit 3683f44c42e991d313dc301504ee0fca1aeb8580
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat May 3 11:03:28 2014 +0100

    ARM: stacktrace: avoid listing stacktrace functions in stacktrace
    
    While debugging the FEC ethernet driver using stacktrace, it was noticed
    that the stacktraces always begin as follows:
    
     [<c00117b4>] save_stack_trace_tsk+0x0/0x98
     [<c0011870>] save_stack_trace+0x24/0x28
     ...
    
    This is because the stack trace code includes the stack frames for itself.
    This is incorrect behaviour, and also leads to "skip" doing the wrong
    thing (which is the number of stack frames to avoid recording.)
    
    Perversely, it does the right thing when passed a non-current thread.  Fix
    this by ensuring that we have a known constant number of frames above the
    main stack trace function, and always skip these.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index af4e8c8a5422..6582c4adc182 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -83,13 +83,16 @@ static int save_trace(struct stackframe *frame, void *d)
 	return trace->nr_entries >= trace->max_entries;
 }
 
-void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
+/* This must be noinline to so that our skip calculation works correctly */
+static noinline void __save_stack_trace(struct task_struct *tsk,
+	struct stack_trace *trace, unsigned int nosched)
 {
 	struct stack_trace_data data;
 	struct stackframe frame;
 
 	data.trace = trace;
 	data.skip = trace->skip;
+	data.no_sched_functions = nosched;
 
 	if (tsk != current) {
 #ifdef CONFIG_SMP
@@ -102,7 +105,6 @@ void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 			trace->entries[trace->nr_entries++] = ULONG_MAX;
 		return;
 #else
-		data.no_sched_functions = 1;
 		frame.fp = thread_saved_fp(tsk);
 		frame.sp = thread_saved_sp(tsk);
 		frame.lr = 0;		/* recovered from the stack */
@@ -111,11 +113,12 @@ void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 	} else {
 		register unsigned long current_sp asm ("sp");
 
-		data.no_sched_functions = 0;
+		/* We don't want this function nor the caller */
+		data.skip += 2;
 		frame.fp = (unsigned long)__builtin_frame_address(0);
 		frame.sp = current_sp;
 		frame.lr = (unsigned long)__builtin_return_address(0);
-		frame.pc = (unsigned long)save_stack_trace_tsk;
+		frame.pc = (unsigned long)__save_stack_trace;
 	}
 
 	walk_stackframe(&frame, save_trace, &data);
@@ -123,9 +126,14 @@ void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 		trace->entries[trace->nr_entries++] = ULONG_MAX;
 }
 
+void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
+{
+	__save_stack_trace(tsk, trace, 1);
+}
+
 void save_stack_trace(struct stack_trace *trace)
 {
-	save_stack_trace_tsk(current, trace);
+	__save_stack_trace(current, trace, 0);
 }
 EXPORT_SYMBOL_GPL(save_stack_trace);
 #endif

commit 3abb6671a9c04479c4bd026798a05f857393b7e2
Author: Konstantin Khlebnikov <k.khlebnikov@samsung.com>
Date:   Thu Dec 5 14:23:48 2013 +0100

    ARM: 7913/1: fix framepointer check in unwind_frame
    
    This patch fixes corner case when (fp + 4) overflows unsigned long,
    for example: fp = 0xFFFFFFFF -> fp + 4 == 3.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Konstantin Khlebnikov <k.khlebnikov@samsung.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index 00f79e59985b..af4e8c8a5422 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -31,7 +31,7 @@ int notrace unwind_frame(struct stackframe *frame)
 	high = ALIGN(low, THREAD_SIZE);
 
 	/* check current frame pointer is within bounds */
-	if (fp < (low + 12) || fp + 4 >= high)
+	if (fp < low + 12 || fp > high - 4)
 		return -EINVAL;
 
 	/* restore the registers from the stack frame */

commit ecea4ab6d3d8bb4122522398200f1cd2a06af6d5
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 22 10:58:34 2011 -0400

    arm: convert core files from module.h to export.h
    
    Many of the core ARM kernel files are not modules, but just
    including module.h for exporting symbols.  Now these files can
    use the lighter footprint export.h for this role.
    
    There are probably lots more, but ARM files of mach-* and plat-*
    don't get coverage via a simple yesconfig build.  They will have
    to be cleaned up and tested via using their respective configs.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index 381d23a497c1..00f79e59985b 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -1,4 +1,4 @@
-#include <linux/module.h>
+#include <linux/export.h>
 #include <linux/sched.h>
 #include <linux/stacktrace.h>
 

commit d5996b2ff0e26cf7ed4c103084a2d6fc569e7216
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jan 15 09:27:04 2011 +0000

    ARM: fix /proc/$PID/stack on SMP
    
    Rabin Vincent reports:
    | On SMP, this BUG() in save_stack_trace_tsk() can be easily triggered
    | from user space by reading /proc/$PID/stack, where $PID is any pid but
    | the current process:
    |
    |       if (tsk != current) {
    | #ifdef CONFIG_SMP
    |               /*
    |                * What guarantees do we have here that 'tsk'
    |                * is not running on another CPU?
    |                */
    |               BUG();
    | #else
    
    Fix this by replacing the BUG() with an entry to terminate the stack
    trace, returning an empty trace - I'd rather not expose the dwarf
    unwinder to a volatile stack of a running thread.
    
    Reported-by: Rabin Vincent <rabin@rab.in>
    Tested-by: Rabin Vincent <rabin@rab.in>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index c2e112e1a05f..381d23a497c1 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -94,10 +94,13 @@ void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 	if (tsk != current) {
 #ifdef CONFIG_SMP
 		/*
-		 * What guarantees do we have here that 'tsk'
-		 * is not running on another CPU?
+		 * What guarantees do we have here that 'tsk' is not
+		 * running on another CPU?  For now, ignore it as we
+		 * can't guarantee we won't explode.
 		 */
-		BUG();
+		if (trace->nr_entries < trace->max_entries)
+			trace->entries[trace->nr_entries++] = ULONG_MAX;
+		return;
 #else
 		data.no_sched_functions = 1;
 		frame.fp = thread_saved_fp(tsk);

commit d33aadbf8e9ba0b844c2a4a03723969c913ab03a
Author: Will Deacon <will.deacon@arm.com>
Date:   Thu Nov 4 18:22:51 2010 +0100

    ARM: 6468/1: backtrace: fix calculation of thread stack base
    
    When unwinding stack frames we must take care not to unwind
    areas of memory that lie outside of the known extent of the stack.
    
    This patch fixes an incorrect calculation of the stack base where
    THREAD_SIZE is added to the stack pointer after it has already
    been aligned to this value. Since the ALIGN macro performs this
    addition internally, we end up overshooting the base by 8k.
    
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index 20b7411e47fd..c2e112e1a05f 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -28,7 +28,7 @@ int notrace unwind_frame(struct stackframe *frame)
 
 	/* only go to a higher address on the stack */
 	low = frame->sp;
-	high = ALIGN(low, THREAD_SIZE) + THREAD_SIZE;
+	high = ALIGN(low, THREAD_SIZE);
 
 	/* check current frame pointer is within bounds */
 	if (fp < (low + 12) || fp + 4 >= high)

commit 4bf1fa5a34aa2dd0d2cc58f0fc213a2e22d007a4
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Tue Jul 21 09:56:27 2009 +0100

    [ARM] 5613/1: implement CALLER_ADDRESSx
    
    From: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    
    As __builtin_return_address(n) doesn't work for ARM with n > 0, the
    kernel needs its own implementation.
    
    This fixes many warnings saying:
    
            warning: unsupported argument to '__builtin_return_address'
    
    The new methods and walk_stackframe must not be instrumented because
    CALLER_ADDRESSx is used in the various tracers and tracing the tracer is
    a bad idea.
    
    What's currently missing is an implementation using unwind tables.  This
    is not fatal though, it's just that the tracers don't get enough
    information to be really useful.
    
    Note that if both ARM_UNWIND and FRAME_POINTER are enabled,
    walk_stackframe uses unwind information.  So in this case the same
    implementation is used as when FRAME_POINTER is disabled.
    
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index 9f444e5cc165..20b7411e47fd 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -21,7 +21,7 @@
  * Note that with framepointer enabled, even the leaf functions have the same
  * prologue and epilogue, therefore we can ignore the LR value in this case.
  */
-int unwind_frame(struct stackframe *frame)
+int notrace unwind_frame(struct stackframe *frame)
 {
 	unsigned long high, low;
 	unsigned long fp = frame->fp;
@@ -43,7 +43,7 @@ int unwind_frame(struct stackframe *frame)
 }
 #endif
 
-void walk_stackframe(struct stackframe *frame,
+void notrace walk_stackframe(struct stackframe *frame,
 		     int (*fn)(struct stackframe *, void *), void *data)
 {
 	while (1) {

commit 2d7c11bfc91637e5f9bc5f8c9a82aaffcc0e97aa
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Wed Feb 11 13:07:53 2009 +0100

    [ARM] 5382/1: unwind: Reorganise the stacktrace support
    
    This patch changes the walk_stacktrace and its callers for easier
    integration of stack unwinding. The arch/arm/kernel/stacktrace.h file is
    also moved to arch/arm/include/asm/stacktrace.h.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index fc650f64df43..9f444e5cc165 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -2,35 +2,60 @@
 #include <linux/sched.h>
 #include <linux/stacktrace.h>
 
-#include "stacktrace.h"
-
-int walk_stackframe(unsigned long fp, unsigned long low, unsigned long high,
-		    int (*fn)(struct stackframe *, void *), void *data)
+#include <asm/stacktrace.h>
+
+#if defined(CONFIG_FRAME_POINTER) && !defined(CONFIG_ARM_UNWIND)
+/*
+ * Unwind the current stack frame and store the new register values in the
+ * structure passed as argument. Unwinding is equivalent to a function return,
+ * hence the new PC value rather than LR should be used for backtrace.
+ *
+ * With framepointer enabled, a simple function prologue looks like this:
+ *	mov	ip, sp
+ *	stmdb	sp!, {fp, ip, lr, pc}
+ *	sub	fp, ip, #4
+ *
+ * A simple function epilogue looks like this:
+ *	ldm	sp, {fp, sp, pc}
+ *
+ * Note that with framepointer enabled, even the leaf functions have the same
+ * prologue and epilogue, therefore we can ignore the LR value in this case.
+ */
+int unwind_frame(struct stackframe *frame)
 {
-	struct stackframe *frame;
-
-	do {
-		/*
-		 * Check current frame pointer is within bounds
-		 */
-		if (fp < (low + 12) || fp + 4 >= high)
-			break;
+	unsigned long high, low;
+	unsigned long fp = frame->fp;
 
-		frame = (struct stackframe *)(fp - 12);
+	/* only go to a higher address on the stack */
+	low = frame->sp;
+	high = ALIGN(low, THREAD_SIZE) + THREAD_SIZE;
 
-		if (fn(frame, data))
-			break;
+	/* check current frame pointer is within bounds */
+	if (fp < (low + 12) || fp + 4 >= high)
+		return -EINVAL;
 
-		/*
-		 * Update the low bound - the next frame must always
-		 * be at a higher address than the current frame.
-		 */
-		low = fp + 4;
-		fp = frame->fp;
-	} while (fp);
+	/* restore the registers from the stack frame */
+	frame->fp = *(unsigned long *)(fp - 12);
+	frame->sp = *(unsigned long *)(fp - 8);
+	frame->pc = *(unsigned long *)(fp - 4);
 
 	return 0;
 }
+#endif
+
+void walk_stackframe(struct stackframe *frame,
+		     int (*fn)(struct stackframe *, void *), void *data)
+{
+	while (1) {
+		int ret;
+
+		if (fn(frame, data))
+			break;
+		ret = unwind_frame(frame);
+		if (ret < 0)
+			break;
+	}
+}
 EXPORT_SYMBOL(walk_stackframe);
 
 #ifdef CONFIG_STACKTRACE
@@ -44,7 +69,7 @@ static int save_trace(struct stackframe *frame, void *d)
 {
 	struct stack_trace_data *data = d;
 	struct stack_trace *trace = data->trace;
-	unsigned long addr = frame->lr;
+	unsigned long addr = frame->pc;
 
 	if (data->no_sched_functions && in_sched_functions(addr))
 		return 0;
@@ -61,11 +86,10 @@ static int save_trace(struct stackframe *frame, void *d)
 void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 {
 	struct stack_trace_data data;
-	unsigned long fp, base;
+	struct stackframe frame;
 
 	data.trace = trace;
 	data.skip = trace->skip;
-	base = (unsigned long)task_stack_page(tsk);
 
 	if (tsk != current) {
 #ifdef CONFIG_SMP
@@ -76,14 +100,22 @@ void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 		BUG();
 #else
 		data.no_sched_functions = 1;
-		fp = thread_saved_fp(tsk);
+		frame.fp = thread_saved_fp(tsk);
+		frame.sp = thread_saved_sp(tsk);
+		frame.lr = 0;		/* recovered from the stack */
+		frame.pc = thread_saved_pc(tsk);
 #endif
 	} else {
+		register unsigned long current_sp asm ("sp");
+
 		data.no_sched_functions = 0;
-		asm("mov %0, fp" : "=r" (fp));
+		frame.fp = (unsigned long)__builtin_frame_address(0);
+		frame.sp = current_sp;
+		frame.lr = (unsigned long)__builtin_return_address(0);
+		frame.pc = (unsigned long)save_stack_trace_tsk;
 	}
 
-	walk_stackframe(fp, base, base + THREAD_SIZE, save_trace, &data);
+	walk_stackframe(&frame, save_trace, &data);
 	if (trace->nr_entries < trace->max_entries)
 		trace->entries[trace->nr_entries++] = ULONG_MAX;
 }

commit af5329cdf51cdd208a323e521faa46800a16d2ec
Merge: 1dc60c53d36b 7798ed0f57b4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 15 10:31:35 2008 -0700

    Merge branch 'core/stacktrace' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'core/stacktrace' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      generic-ipi: powerpc/generic-ipi tree build failure
      stacktrace: fix build failure on sparc64
      stacktrace: export save_stack_trace[_tsk]
      stacktrace: fix modular build, export print_stack_trace and save_stack_trace
      backtrace: replace timer with tasklet + completions
      stacktrace: add saved stack traces to backtrace self-test
      stacktrace: print_stack_trace() cleanup
      debugging: make stacktrace independent from DEBUG_KERNEL
      stacktrace: don't crash on invalid stack trace structs

commit 7b4c9505f2fd82b117dd015b561f723b9a5dab79
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jul 3 09:17:55 2008 +0200

    stacktrace: export save_stack_trace[_tsk]
    
    Andrew Morton reported this against linux-next:
    
    ERROR: ".save_stack_trace" [tests/backtracetest.ko] undefined!
    
    Reported-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index ae31deb2d065..6b3ffde5deaa 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -66,4 +66,5 @@ void save_stack_trace(struct stack_trace *trace)
 
 	walk_stackframe(fp, base, base + THREAD_SIZE, save_trace, &data);
 }
+EXPORT_SYMBOL_GPL(save_stack_trace);
 #endif

commit f76e9154736e9ab47b64940d0062f19c80225b7f
Author: Nicolas Pitre <nico@cam.org>
Date:   Thu Apr 24 01:31:46 2008 -0400

    [ARM] latencytop support
    
    Available for !SMP only at the moment.
    
    From Russell:
    
    |Basically, if a thread is running on a CPU, thread_saved_fp() is invalid.
    |So, the question is: what guarantees do we have here that 'tsk' is not
    |running on another CPU?
    
    Signed-off-by: Nicolas Pitre <nico@marvell.com>
    Tested-by: Lennert Buytenhek <buytenh@marvell.com>
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index ae31deb2d065..90e0c35ae60d 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -36,6 +36,7 @@ EXPORT_SYMBOL(walk_stackframe);
 #ifdef CONFIG_STACKTRACE
 struct stack_trace_data {
 	struct stack_trace *trace;
+	unsigned int no_sched_functions;
 	unsigned int skip;
 };
 
@@ -43,27 +44,52 @@ static int save_trace(struct stackframe *frame, void *d)
 {
 	struct stack_trace_data *data = d;
 	struct stack_trace *trace = data->trace;
+	unsigned long addr = frame->lr;
 
+	if (data->no_sched_functions && in_sched_functions(addr))
+		return 0;
 	if (data->skip) {
 		data->skip--;
 		return 0;
 	}
 
-	trace->entries[trace->nr_entries++] = frame->lr;
+	trace->entries[trace->nr_entries++] = addr;
 
 	return trace->nr_entries >= trace->max_entries;
 }
 
-void save_stack_trace(struct stack_trace *trace)
+void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 {
 	struct stack_trace_data data;
 	unsigned long fp, base;
 
 	data.trace = trace;
 	data.skip = trace->skip;
-	base = (unsigned long)task_stack_page(current);
-	asm("mov %0, fp" : "=r" (fp));
+	base = (unsigned long)task_stack_page(tsk);
+
+	if (tsk != current) {
+#ifdef CONFIG_SMP
+		/*
+		 * What guarantees do we have here that 'tsk'
+		 * is not running on another CPU?
+		 */
+		BUG();
+#else
+		data.no_sched_functions = 1;
+		fp = thread_saved_fp(tsk);
+#endif
+	} else {
+		data.no_sched_functions = 0;
+		asm("mov %0, fp" : "=r" (fp));
+	}
 
 	walk_stackframe(fp, base, base + THREAD_SIZE, save_trace, &data);
+	if (trace->nr_entries < trace->max_entries)
+		trace->entries[trace->nr_entries++] = ULONG_MAX;
+}
+
+void save_stack_trace(struct stack_trace *trace)
+{
+	save_stack_trace_tsk(current, trace);
 }
 #endif

commit 5b10c8e436b69f25b6dcb5586bbdc5e39c20ed1d
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat May 26 12:04:17 2007 +0100

    [ARM] Fix stacktrace FP range checking
    
    Fix an oops in the stacktrace code, caused by improper range checking.
    We subtract 12 off 'fp' before testing to see if it's below the low
    bound.  However, if 'fp' were zero before, it becomes a very large
    positive number, causing this test to succeed where it should fail.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index 8b63ad89d0a8..ae31deb2d065 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -13,7 +13,7 @@ int walk_stackframe(unsigned long fp, unsigned long low, unsigned long high,
 		/*
 		 * Check current frame pointer is within bounds
 		 */
-		if ((fp - 12) < low || fp + 4 >= high)
+		if (fp < (low + 12) || fp + 4 >= high)
 			break;
 
 		frame = (struct stackframe *)(fp - 12);

commit 7b104bcb8e460e45a1aebe3da9b86aacdb4cab12
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Tue May 15 20:37:20 2007 +0100

    arm: walk_stacktrace() needs to be exported
    
    oprofile depends on having it
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index 398d0c0511eb..8b63ad89d0a8 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -1,3 +1,4 @@
+#include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/stacktrace.h>
 
@@ -30,6 +31,7 @@ int walk_stackframe(unsigned long fp, unsigned long low, unsigned long high,
 
 	return 0;
 }
+EXPORT_SYMBOL(walk_stackframe);
 
 #ifdef CONFIG_STACKTRACE
 struct stack_trace_data {

commit fac0779029749dfe8d77a35c26606ebda7a8e176
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Thu May 10 22:33:05 2007 -0700

    [ARM] stacktrace fix
    
    ab1b6f03a10ba1f5638188ab06bf46e33ac3a160 said
    
     - remove the unused task argument to save_stack_trace, it's always current
    
    then broke arm:
    
    arch/arm/kernel/stacktrace.c:56: error: conflicting types for 'save_stack_trace'
    include/linux/stacktrace.h:11: error: previous declaration of 'save_stack_trace' was here
    arch/arm/kernel/stacktrace.c:56: error: conflicting types for 'save_stack_trace'
    include/linux/stacktrace.h:11: error: previous declaration of 'save_stack_trace' was here
    
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index 77ef35efaa8d..398d0c0511eb 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -52,21 +52,15 @@ static int save_trace(struct stackframe *frame, void *d)
 	return trace->nr_entries >= trace->max_entries;
 }
 
-void save_stack_trace(struct stack_trace *trace, struct task_struct *task)
+void save_stack_trace(struct stack_trace *trace)
 {
 	struct stack_trace_data data;
 	unsigned long fp, base;
 
 	data.trace = trace;
 	data.skip = trace->skip;
-
-	if (task) {
-		base = (unsigned long)task_stack_page(task);
-		fp = 0; /* FIXME */
-	} else {
-		base = (unsigned long)task_stack_page(current);
-		asm("mov %0, fp" : "=r" (fp));
-	}
+	base = (unsigned long)task_stack_page(current);
+	asm("mov %0, fp" : "=r" (fp));
 
 	walk_stackframe(fp, base, base + THREAD_SIZE, save_trace, &data);
 }

commit f16fb1ecc5a1cb2f7cc595179d1fe55e711e599f
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Apr 28 09:59:37 2007 +0100

    [ARM] Add stacktrace support and make oprofile use it
    
    Add support for stacktrace.  Use the new stacktrace code with
    oprofile instead of it's version; there's no point having
    multiple versions of stacktracing in the kernel.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
new file mode 100644
index 000000000000..77ef35efaa8d
--- /dev/null
+++ b/arch/arm/kernel/stacktrace.c
@@ -0,0 +1,73 @@
+#include <linux/sched.h>
+#include <linux/stacktrace.h>
+
+#include "stacktrace.h"
+
+int walk_stackframe(unsigned long fp, unsigned long low, unsigned long high,
+		    int (*fn)(struct stackframe *, void *), void *data)
+{
+	struct stackframe *frame;
+
+	do {
+		/*
+		 * Check current frame pointer is within bounds
+		 */
+		if ((fp - 12) < low || fp + 4 >= high)
+			break;
+
+		frame = (struct stackframe *)(fp - 12);
+
+		if (fn(frame, data))
+			break;
+
+		/*
+		 * Update the low bound - the next frame must always
+		 * be at a higher address than the current frame.
+		 */
+		low = fp + 4;
+		fp = frame->fp;
+	} while (fp);
+
+	return 0;
+}
+
+#ifdef CONFIG_STACKTRACE
+struct stack_trace_data {
+	struct stack_trace *trace;
+	unsigned int skip;
+};
+
+static int save_trace(struct stackframe *frame, void *d)
+{
+	struct stack_trace_data *data = d;
+	struct stack_trace *trace = data->trace;
+
+	if (data->skip) {
+		data->skip--;
+		return 0;
+	}
+
+	trace->entries[trace->nr_entries++] = frame->lr;
+
+	return trace->nr_entries >= trace->max_entries;
+}
+
+void save_stack_trace(struct stack_trace *trace, struct task_struct *task)
+{
+	struct stack_trace_data data;
+	unsigned long fp, base;
+
+	data.trace = trace;
+	data.skip = trace->skip;
+
+	if (task) {
+		base = (unsigned long)task_stack_page(task);
+		fp = 0; /* FIXME */
+	} else {
+		base = (unsigned long)task_stack_page(current);
+		asm("mov %0, fp" : "=r" (fp));
+	}
+
+	walk_stackframe(fp, base, base + THREAD_SIZE, save_trace, &data);
+}
+#endif
