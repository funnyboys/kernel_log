commit 586745f1598ccf71b0a5a6df2222dee0a865954e
Author: yu kuai <yukuai3@huawei.com>
Date:   Thu Jun 4 20:42:06 2020 +0800

    ARM: imx5: add missing put_device() call in imx_suspend_alloc_ocram()
    
    if of_find_device_by_node() succeed, imx_suspend_alloc_ocram() doesn't
    have a corresponding put_device(). Thus add a jump target to fix the
    exception handling for this function implementation.
    
    Fixes: 1579c7b9fe01 ("ARM: imx53: Set DDR pins to high impedance when in suspend to RAM.")
    Signed-off-by: yu kuai <yukuai3@huawei.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index f057df813f83..e9962b48e30c 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -295,14 +295,14 @@ static int __init imx_suspend_alloc_ocram(
 	if (!ocram_pool) {
 		pr_warn("%s: ocram pool unavailable!\n", __func__);
 		ret = -ENODEV;
-		goto put_node;
+		goto put_device;
 	}
 
 	ocram_base = gen_pool_alloc(ocram_pool, size);
 	if (!ocram_base) {
 		pr_warn("%s: unable to alloc ocram!\n", __func__);
 		ret = -ENOMEM;
-		goto put_node;
+		goto put_device;
 	}
 
 	phys = gen_pool_virt_to_phys(ocram_pool, ocram_base);
@@ -312,6 +312,8 @@ static int __init imx_suspend_alloc_ocram(
 	if (virt_out)
 		*virt_out = virt;
 
+put_device:
+	put_device(&pdev->dev);
 put_node:
 	of_node_put(node);
 

commit fcaf20360a5992b88603271ab814a200e28d0088
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:08 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 159
    
    Based on 1 normalized pattern(s):
    
      the code contained herein is licensed under the gnu general public
      license you may obtain a copy of the gnu general public license
      version 2 or later at the following locations http www opensource
      org licenses gpl license html http www gnu org copyleft gpl html
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 161 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.383790741@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index 868781fd460c..f057df813f83 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -1,12 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
  */
 #include <linux/suspend.h>
 #include <linux/clk.h>

commit c553138fbd1ee193a19101a36fb0814607ab4e7b
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Jan 27 17:59:35 2016 +0100

    ARM: imx: use endian-safe readl/readw/writel/writew
    
    Instead of __raw_*, define imx_* to *_relaxed and use those.
    
    Using imx_* was requested by Arnd because *_relaxed tends to
    indicate that the code was carefully reviewed to not require
    any synchronisation and otherwise be safe, which isn't the
    case here with the automatic conversion.
    
    The conversion itself was done using the following spatch
    (since that automatically adjusts the coding style unlike
    a simple search&replace).
    
    @@
    expression E1, E2;
    @@
    -__raw_writel(E1, E2)
    +imx_writel(E1, E2)
    @@
    expression E1, E2;
    @@
    -__raw_writew(E1, E2)
    +imx_writew(E1, E2)
    @@
    expression E1;
    @@
    -__raw_readl(E1)
    +imx_readl(E1)
    @@
    expression E1;
    @@
    -__raw_readw(E1)
    +imx_readw(E1)
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index 532d4b08276d..868781fd460c 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -153,15 +153,15 @@ static void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 	int stop_mode = 0;
 
 	/* always allow platform to issue a deep sleep mode request */
-	plat_lpc = __raw_readl(cortex_base + MXC_CORTEXA8_PLAT_LPC) &
+	plat_lpc = imx_readl(cortex_base + MXC_CORTEXA8_PLAT_LPC) &
 	    ~(MXC_CORTEXA8_PLAT_LPC_DSM);
-	ccm_clpcr = __raw_readl(ccm_base + MXC_CCM_CLPCR) &
+	ccm_clpcr = imx_readl(ccm_base + MXC_CCM_CLPCR) &
 		    ~(MXC_CCM_CLPCR_LPM_MASK);
-	arm_srpgcr = __raw_readl(gpc_base + MXC_SRPG_ARM_SRPGCR) &
+	arm_srpgcr = imx_readl(gpc_base + MXC_SRPG_ARM_SRPGCR) &
 		     ~(MXC_SRPGCR_PCR);
-	empgc0 = __raw_readl(gpc_base + MXC_SRPG_EMPGC0_SRPGCR) &
+	empgc0 = imx_readl(gpc_base + MXC_SRPG_EMPGC0_SRPGCR) &
 		 ~(MXC_SRPGCR_PCR);
-	empgc1 = __raw_readl(gpc_base + MXC_SRPG_EMPGC1_SRPGCR) &
+	empgc1 = imx_readl(gpc_base + MXC_SRPG_EMPGC1_SRPGCR) &
 		 ~(MXC_SRPGCR_PCR);
 
 	switch (mode) {
@@ -196,17 +196,17 @@ static void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 		return;
 	}
 
-	__raw_writel(plat_lpc, cortex_base + MXC_CORTEXA8_PLAT_LPC);
-	__raw_writel(ccm_clpcr, ccm_base + MXC_CCM_CLPCR);
-	__raw_writel(arm_srpgcr, gpc_base + MXC_SRPG_ARM_SRPGCR);
-	__raw_writel(arm_srpgcr, gpc_base + MXC_SRPG_NEON_SRPGCR);
+	imx_writel(plat_lpc, cortex_base + MXC_CORTEXA8_PLAT_LPC);
+	imx_writel(ccm_clpcr, ccm_base + MXC_CCM_CLPCR);
+	imx_writel(arm_srpgcr, gpc_base + MXC_SRPG_ARM_SRPGCR);
+	imx_writel(arm_srpgcr, gpc_base + MXC_SRPG_NEON_SRPGCR);
 
 	if (stop_mode) {
 		empgc0 |= MXC_SRPGCR_PCR;
 		empgc1 |= MXC_SRPGCR_PCR;
 
-		__raw_writel(empgc0, gpc_base + MXC_SRPG_EMPGC0_SRPGCR);
-		__raw_writel(empgc1, gpc_base + MXC_SRPG_EMPGC1_SRPGCR);
+		imx_writel(empgc0, gpc_base + MXC_SRPG_EMPGC0_SRPGCR);
+		imx_writel(empgc1, gpc_base + MXC_SRPG_EMPGC1_SRPGCR);
 	}
 }
 
@@ -228,8 +228,8 @@ static int mx5_suspend_enter(suspend_state_t state)
 		flush_cache_all();
 
 		/*clear the EMPGC0/1 bits */
-		__raw_writel(0, gpc_base + MXC_SRPG_EMPGC0_SRPGCR);
-		__raw_writel(0, gpc_base + MXC_SRPG_EMPGC1_SRPGCR);
+		imx_writel(0, gpc_base + MXC_SRPG_EMPGC0_SRPGCR);
+		imx_writel(0, gpc_base + MXC_SRPG_EMPGC1_SRPGCR);
 
 		if (imx5_suspend_in_ocram_fn)
 			imx5_suspend_in_ocram_fn(suspend_ocram_base);

commit 73858173593c31cb94bce63fe1c24eb803bb04e6
Author: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
Date:   Fri Sep 4 15:47:43 2015 -0700

    genalloc: add name arg to gen_pool_get() and devm_gen_pool_create()
    
    This change modifies gen_pool_get() and devm_gen_pool_create() client
    interfaces adding one more argument "name" of a gen_pool object.
    
    Due to implementation gen_pool_get() is capable to retrieve only one
    gen_pool associated with a device even if multiple gen_pools are created,
    fortunately right at the moment it is sufficient for the clients, hence
    provide NULL as a valid argument on both producer devm_gen_pool_create()
    and consumer gen_pool_get() sides.
    
    Because only one created gen_pool per device is addressable, explicitly
    add a restriction to devm_gen_pool_create() to create only one gen_pool
    per device, this implies two possible error codes returned by the
    function, account it on client side (only misc/sram).  This completes
    client side changes related to genalloc updates.
    
    [akpm@linux-foundation.org: gen_pool_get() cleanup]
    Signed-off-by: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Cc: Jean-Christophe Plagniol-Villard <plagnioj@jcrosoft.com>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index 1885676c23c0..532d4b08276d 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -297,7 +297,7 @@ static int __init imx_suspend_alloc_ocram(
 		goto put_node;
 	}
 
-	ocram_pool = gen_pool_get(&pdev->dev);
+	ocram_pool = gen_pool_get(&pdev->dev, NULL);
 	if (!ocram_pool) {
 		pr_warn("%s: ocram pool unavailable!\n", __func__);
 		ret = -ENODEV;

commit 0030edf296db8a7afb13573eb12977b7d399cd40
Author: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
Date:   Tue Jun 30 15:00:03 2015 -0700

    genalloc: rename dev_get_gen_pool() to gen_pool_get()
    
    To be consistent with other genalloc interface namings, rename
    dev_get_gen_pool() to gen_pool_get().  The original omitted "dev_" prefix
    is removed, since it points to argument type of the function, and so it
    does not bring any useful information.
    
    [akpm@linux-foundation.org: update arch/arm/mach-socfpga/pm.c]
    Signed-off-by: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: Vinod Koul <vinod.koul@intel.com>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Alan Tull <atull@opensource.altera.com>
    Cc: Dinh Nguyen <dinguyen@opensource.altera.com>
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index 0309ccda36a9..1885676c23c0 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -297,7 +297,7 @@ static int __init imx_suspend_alloc_ocram(
 		goto put_node;
 	}
 
-	ocram_pool = dev_get_gen_pool(&pdev->dev);
+	ocram_pool = gen_pool_get(&pdev->dev);
 	if (!ocram_pool) {
 		pr_warn("%s: ocram pool unavailable!\n", __func__);
 		ret = -ENODEV;

commit e20d7b5208c86111ead338ded8b25a0970eee661
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu May 21 14:06:30 2015 +0200

    ARM: imx: make imx51/3 suspend optional
    
    A recent change to the imx53 power management caused a build
    regression when CONFIG_SOC_IMX53 is disabled:
    
    mach-imx/built-in.o:(.init.rodata+0x60): undefined reference to `imx53_suspend'
    mach-imx/built-in.o:(.init.rodata+0x64): undefined reference to `imx53_suspend_sz'
    
    This avoids the problem by compiling the code in question
    conditionally on the presence of CONFIG_SOC_IMX53. For
    consistency, I'm also changing the same thing for
    CONFIG_SOC_IMX51.
    
    An additional benefit of this approach is reduced code size
    for kernels that only include support for one of the two
    SoCs.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Fixes: 1579c7b9fe01 ("ARM: imx53: Set DDR pins to high impedance when in suspend to RAM.")
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index a8d00b9c9236..0309ccda36a9 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -413,10 +413,12 @@ static int __init imx5_pm_common_init(const struct imx5_pm_data *data)
 
 void __init imx51_pm_init(void)
 {
-	imx5_pm_common_init(&imx51_pm_data);
+	if (IS_ENABLED(CONFIG_SOC_IMX51))
+		imx5_pm_common_init(&imx51_pm_data);
 }
 
 void __init imx53_pm_init(void)
 {
-	imx5_pm_common_init(&imx53_pm_data);
+	if (IS_ENABLED(CONFIG_SOC_IMX53))
+		imx5_pm_common_init(&imx53_pm_data);
 }

commit 1579c7b9fe0105a523440ec13b0c59da53c880e3
Author: Martin Fuzzey <mfuzzey@parkeon.com>
Date:   Tue May 12 15:31:03 2015 +0200

    ARM: imx53: Set DDR pins to high impedance when in suspend to RAM.
    
    In order to save power the DDR pins should be put into high
    impedance when in suspend to RAM.
    
    This requires manually requesting self refresh (rather than using the
    automatic mode implemented by the CCM / ESDCTL), followed by
    reconfiguring the IOMUXC.
    
    Of course the code to do this cannot itself run from DDR so the
    code is copied to and executed from internal memory.
    
    In my tests using a custom i.MX53 board with LPDDR2 RAM
    this reduced the suspend power consumption from 200mW to 60mW.
    
    Signed-off-by: Martin Fuzzey <mfuzzey@parkeon.com>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index b04025592d94..a8d00b9c9236 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -13,7 +13,14 @@
 #include <linux/io.h>
 #include <linux/err.h>
 #include <linux/export.h>
+
+#include <linux/genalloc.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+
 #include <asm/cacheflush.h>
+#include <asm/fncpy.h>
 #include <asm/system_misc.h>
 #include <asm/tlbflush.h>
 
@@ -49,10 +56,50 @@
  */
 #define IMX5_DEFAULT_CPU_IDLE_STATE WAIT_UNCLOCKED_POWER_OFF
 
+struct imx5_suspend_io_state {
+	u32	offset;
+	u32	clear;
+	u32	set;
+	u32	saved_value;
+};
+
 struct imx5_pm_data {
 	phys_addr_t ccm_addr;
 	phys_addr_t cortex_addr;
 	phys_addr_t gpc_addr;
+	phys_addr_t m4if_addr;
+	phys_addr_t iomuxc_addr;
+	void (*suspend_asm)(void __iomem *ocram_vbase);
+	const u32 *suspend_asm_sz;
+	const struct imx5_suspend_io_state *suspend_io_config;
+	int suspend_io_count;
+};
+
+static const struct imx5_suspend_io_state imx53_suspend_io_config[] = {
+#define MX53_DSE_HIGHZ_MASK (0x7 << 19)
+	{.offset = 0x584, .clear = MX53_DSE_HIGHZ_MASK}, /* DQM0 */
+	{.offset = 0x594, .clear = MX53_DSE_HIGHZ_MASK}, /* DQM1 */
+	{.offset = 0x560, .clear = MX53_DSE_HIGHZ_MASK}, /* DQM2 */
+	{.offset = 0x554, .clear = MX53_DSE_HIGHZ_MASK}, /* DQM3 */
+	{.offset = 0x574, .clear = MX53_DSE_HIGHZ_MASK}, /* CAS */
+	{.offset = 0x588, .clear = MX53_DSE_HIGHZ_MASK}, /* RAS */
+	{.offset = 0x578, .clear = MX53_DSE_HIGHZ_MASK}, /* SDCLK_0 */
+	{.offset = 0x570, .clear = MX53_DSE_HIGHZ_MASK}, /* SDCLK_1 */
+
+	{.offset = 0x580, .clear = MX53_DSE_HIGHZ_MASK}, /* SDODT0 */
+	{.offset = 0x564, .clear = MX53_DSE_HIGHZ_MASK}, /* SDODT1 */
+	{.offset = 0x57c, .clear = MX53_DSE_HIGHZ_MASK}, /* SDQS0 */
+	{.offset = 0x590, .clear = MX53_DSE_HIGHZ_MASK}, /* SDQS1 */
+	{.offset = 0x568, .clear = MX53_DSE_HIGHZ_MASK}, /* SDQS2 */
+	{.offset = 0x558, .clear = MX53_DSE_HIGHZ_MASK}, /* SDSQ3 */
+	{.offset = 0x6f0, .clear = MX53_DSE_HIGHZ_MASK}, /* GRP_ADDS */
+	{.offset = 0x718, .clear = MX53_DSE_HIGHZ_MASK}, /* GRP_BODS */
+	{.offset = 0x71c, .clear = MX53_DSE_HIGHZ_MASK}, /* GRP_B1DS */
+	{.offset = 0x728, .clear = MX53_DSE_HIGHZ_MASK}, /* GRP_B2DS */
+	{.offset = 0x72c, .clear = MX53_DSE_HIGHZ_MASK}, /* GRP_B3DS */
+
+	/* Controls the CKE signal which is required to leave self refresh */
+	{.offset = 0x720, .clear = MX53_DSE_HIGHZ_MASK, .set = 1 << 19}, /* CTLDS */
 };
 
 static const struct imx5_pm_data imx51_pm_data __initconst = {
@@ -65,11 +112,35 @@ static const struct imx5_pm_data imx53_pm_data __initconst = {
 	.ccm_addr = 0x53fd4000,
 	.cortex_addr = 0x63fa0000,
 	.gpc_addr = 0x53fd8000,
+	.m4if_addr = 0x63fd8000,
+	.iomuxc_addr = 0x53fa8000,
+	.suspend_asm = &imx53_suspend,
+	.suspend_asm_sz = &imx53_suspend_sz,
+	.suspend_io_config = imx53_suspend_io_config,
+	.suspend_io_count = ARRAY_SIZE(imx53_suspend_io_config),
 };
 
+#define MX5_MAX_SUSPEND_IOSTATE ARRAY_SIZE(imx53_suspend_io_config)
+
+/*
+ * This structure is for passing necessary data for low level ocram
+ * suspend code(arch/arm/mach-imx/suspend-imx53.S), if this struct
+ * definition is changed, the offset definition in that file
+ * must be also changed accordingly otherwise, the suspend to ocram
+ * function will be broken!
+ */
+struct imx5_cpu_suspend_info {
+	void __iomem	*m4if_base;
+	void __iomem	*iomuxc_base;
+	u32		io_count;
+	struct imx5_suspend_io_state io_state[MX5_MAX_SUSPEND_IOSTATE];
+} __aligned(8);
+
 static void __iomem *ccm_base;
 static void __iomem *cortex_base;
 static void __iomem *gpc_base;
+static void __iomem *suspend_ocram_base;
+static void (*imx5_suspend_in_ocram_fn)(void __iomem *ocram_vbase);
 
 /*
  * set cpu low power mode before WFI instruction. This function is called
@@ -159,8 +230,15 @@ static int mx5_suspend_enter(suspend_state_t state)
 		/*clear the EMPGC0/1 bits */
 		__raw_writel(0, gpc_base + MXC_SRPG_EMPGC0_SRPGCR);
 		__raw_writel(0, gpc_base + MXC_SRPG_EMPGC1_SRPGCR);
+
+		if (imx5_suspend_in_ocram_fn)
+			imx5_suspend_in_ocram_fn(suspend_ocram_base);
+		else
+			cpu_do_idle();
+
+	} else {
+		cpu_do_idle();
 	}
-	cpu_do_idle();
 
 	/* return registers to default idle state */
 	mx5_cpu_lp_set(IMX5_DEFAULT_CPU_IDLE_STATE);
@@ -192,6 +270,111 @@ static void imx5_pm_idle(void)
 	imx5_cpu_do_idle();
 }
 
+static int __init imx_suspend_alloc_ocram(
+				size_t size,
+				void __iomem **virt_out,
+				phys_addr_t *phys_out)
+{
+	struct device_node *node;
+	struct platform_device *pdev;
+	struct gen_pool *ocram_pool;
+	unsigned long ocram_base;
+	void __iomem *virt;
+	phys_addr_t phys;
+	int ret = 0;
+
+	/* Copied from imx6: TODO factorize */
+	node = of_find_compatible_node(NULL, NULL, "mmio-sram");
+	if (!node) {
+		pr_warn("%s: failed to find ocram node!\n", __func__);
+		return -ENODEV;
+	}
+
+	pdev = of_find_device_by_node(node);
+	if (!pdev) {
+		pr_warn("%s: failed to find ocram device!\n", __func__);
+		ret = -ENODEV;
+		goto put_node;
+	}
+
+	ocram_pool = dev_get_gen_pool(&pdev->dev);
+	if (!ocram_pool) {
+		pr_warn("%s: ocram pool unavailable!\n", __func__);
+		ret = -ENODEV;
+		goto put_node;
+	}
+
+	ocram_base = gen_pool_alloc(ocram_pool, size);
+	if (!ocram_base) {
+		pr_warn("%s: unable to alloc ocram!\n", __func__);
+		ret = -ENOMEM;
+		goto put_node;
+	}
+
+	phys = gen_pool_virt_to_phys(ocram_pool, ocram_base);
+	virt = __arm_ioremap_exec(phys, size, false);
+	if (phys_out)
+		*phys_out = phys;
+	if (virt_out)
+		*virt_out = virt;
+
+put_node:
+	of_node_put(node);
+
+	return ret;
+}
+
+static int __init imx5_suspend_init(const struct imx5_pm_data *soc_data)
+{
+	struct imx5_cpu_suspend_info *suspend_info;
+	int ret;
+	/* Need this to avoid compile error due to const typeof in fncpy.h */
+	void (*suspend_asm)(void __iomem *) = soc_data->suspend_asm;
+
+	if (!suspend_asm)
+		return 0;
+
+	if (!soc_data->suspend_asm_sz || !*soc_data->suspend_asm_sz)
+		return -EINVAL;
+
+	ret = imx_suspend_alloc_ocram(
+		*soc_data->suspend_asm_sz + sizeof(*suspend_info),
+		&suspend_ocram_base, NULL);
+	if (ret)
+		return ret;
+
+	suspend_info = suspend_ocram_base;
+
+	suspend_info->io_count = soc_data->suspend_io_count;
+	memcpy(suspend_info->io_state, soc_data->suspend_io_config,
+	       sizeof(*suspend_info->io_state) * soc_data->suspend_io_count);
+
+	suspend_info->m4if_base = ioremap(soc_data->m4if_addr, SZ_16K);
+	if (!suspend_info->m4if_base) {
+		ret = -ENOMEM;
+		goto failed_map_m4if;
+	}
+
+	suspend_info->iomuxc_base = ioremap(soc_data->iomuxc_addr, SZ_16K);
+	if (!suspend_info->iomuxc_base) {
+		ret = -ENOMEM;
+		goto failed_map_iomuxc;
+	}
+
+	imx5_suspend_in_ocram_fn = fncpy(
+		suspend_ocram_base + sizeof(*suspend_info),
+		suspend_asm,
+		*soc_data->suspend_asm_sz);
+
+	return 0;
+
+failed_map_iomuxc:
+	iounmap(suspend_info->m4if_base);
+
+failed_map_m4if:
+	return ret;
+}
+
 static int __init imx5_pm_common_init(const struct imx5_pm_data *data)
 {
 	int ret;
@@ -218,6 +401,11 @@ static int __init imx5_pm_common_init(const struct imx5_pm_data *data)
 	if (ret)
 		pr_warn("%s: cpuidle init failed %d\n", __func__, ret);
 
+	ret = imx5_suspend_init(data);
+	if (ret)
+		pr_warn("%s: No DDR LPM support with suspend %d!\n",
+			__func__, ret);
+
 	suspend_set_ops(&mx5_suspend_ops);
 
 	return 0;

commit f3a9249d096178d29bba69cece29da99a622ce28
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Sat Apr 25 22:38:19 2015 +0800

    ARM: imx5: let pm code map CCM block on its own
    
    We are about to move imx5 clock driver into drivers/clk, so let's get
    imx5 pm code map CCM block on its own rather than relying on clock
    driver to do the mapping.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index f1f80ab73e69..b04025592d94 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -50,16 +50,19 @@
 #define IMX5_DEFAULT_CPU_IDLE_STATE WAIT_UNCLOCKED_POWER_OFF
 
 struct imx5_pm_data {
+	phys_addr_t ccm_addr;
 	phys_addr_t cortex_addr;
 	phys_addr_t gpc_addr;
 };
 
 static const struct imx5_pm_data imx51_pm_data __initconst = {
+	.ccm_addr = 0x73fd4000,
 	.cortex_addr = 0x83fa0000,
 	.gpc_addr = 0x73fd8000,
 };
 
 static const struct imx5_pm_data imx53_pm_data __initconst = {
+	.ccm_addr = 0x53fd4000,
 	.cortex_addr = 0x63fa0000,
 	.gpc_addr = 0x53fd8000,
 };
@@ -68,11 +71,6 @@ static void __iomem *ccm_base;
 static void __iomem *cortex_base;
 static void __iomem *gpc_base;
 
-void __init imx5_pm_set_ccm_base(void __iomem *base)
-{
-	ccm_base = base;
-}
-
 /*
  * set cpu low power mode before WFI instruction. This function is called
  * mx5 because it can be used for mx51, and mx53.
@@ -208,6 +206,7 @@ static int __init imx5_pm_common_init(const struct imx5_pm_data *data)
 
 	arm_pm_idle = imx5_pm_idle;
 
+	ccm_base = ioremap(data->ccm_addr, SZ_16K);
 	cortex_base = ioremap(data->cortex_addr, SZ_16K);
 	gpc_base = ioremap(data->gpc_addr, SZ_16K);
 	WARN_ON(!ccm_base || !cortex_base || !gpc_base);

commit 36b66c3fc20ad9a50ae7f19b3c807c68259753df
Author: Shawn Guo <shawn.guo@freescale.com>
Date:   Tue May 20 14:55:15 2014 +0800

    ARM: imx5: use dynamic mapping for Cortex and GPC block
    
    The imx5 pm code uses static mapping to access Cortex and GPC registers.
    The patch create struct imx5_pm_data to encode physical address of
    Cortex and GPC block, and create dynamic mapping for them at run-time.
    
    Signed-off-by: Shawn Guo <shawn.guo@freescale.com>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index 3544c2524617..f1f80ab73e69 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -28,21 +28,14 @@
 #define MXC_CCM_CLPCR_VSTBY		(0x1 << 8)
 #define MXC_CCM_CLPCR_SBYOS		(0x1 << 6)
 
-#define MX51_CORTEXA8_BASE		MX51_IO_ADDRESS(MX51_ARM_BASE_ADDR)
-#define MXC_CORTEXA8_PLAT_LPC		(MX51_CORTEXA8_BASE + 0xc)
+#define MXC_CORTEXA8_PLAT_LPC		0xc
 #define MXC_CORTEXA8_PLAT_LPC_DSM	(1 << 0)
 #define MXC_CORTEXA8_PLAT_LPC_DBG_DSM	(1 << 1)
 
-#define MX51_GPC_BASE			MX51_IO_ADDRESS(MX51_GPC_BASE_ADDR)
-#define MXC_SRPG_NEON_BASE		(MX51_GPC_BASE + 0x280)
-#define MXC_SRPG_ARM_BASE		(MX51_GPC_BASE + 0x2a0)
-#define MXC_SRPG_EMPGC0_BASE		(MX51_GPC_BASE + 0x2c0)
-#define MXC_SRPG_EMPGC1_BASE		(MX51_GPC_BASE + 0x2d0)
-
-#define MXC_SRPG_NEON_SRPGCR		(MXC_SRPG_NEON_BASE + 0x0)
-#define MXC_SRPG_ARM_SRPGCR		(MXC_SRPG_ARM_BASE + 0x0)
-#define MXC_SRPG_EMPGC0_SRPGCR		(MXC_SRPG_EMPGC0_BASE + 0x0)
-#define MXC_SRPG_EMPGC1_SRPGCR		(MXC_SRPG_EMPGC1_BASE + 0x0)
+#define MXC_SRPG_NEON_SRPGCR		0x280
+#define MXC_SRPG_ARM_SRPGCR		0x2a0
+#define MXC_SRPG_EMPGC0_SRPGCR		0x2c0
+#define MXC_SRPG_EMPGC1_SRPGCR		0x2d0
 
 #define MXC_SRPGCR_PCR			1
 
@@ -56,7 +49,24 @@
  */
 #define IMX5_DEFAULT_CPU_IDLE_STATE WAIT_UNCLOCKED_POWER_OFF
 
+struct imx5_pm_data {
+	phys_addr_t cortex_addr;
+	phys_addr_t gpc_addr;
+};
+
+static const struct imx5_pm_data imx51_pm_data __initconst = {
+	.cortex_addr = 0x83fa0000,
+	.gpc_addr = 0x73fd8000,
+};
+
+static const struct imx5_pm_data imx53_pm_data __initconst = {
+	.cortex_addr = 0x63fa0000,
+	.gpc_addr = 0x53fd8000,
+};
+
 static void __iomem *ccm_base;
+static void __iomem *cortex_base;
+static void __iomem *gpc_base;
 
 void __init imx5_pm_set_ccm_base(void __iomem *base)
 {
@@ -74,13 +84,16 @@ static void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 	int stop_mode = 0;
 
 	/* always allow platform to issue a deep sleep mode request */
-	plat_lpc = __raw_readl(MXC_CORTEXA8_PLAT_LPC) &
+	plat_lpc = __raw_readl(cortex_base + MXC_CORTEXA8_PLAT_LPC) &
 	    ~(MXC_CORTEXA8_PLAT_LPC_DSM);
 	ccm_clpcr = __raw_readl(ccm_base + MXC_CCM_CLPCR) &
 		    ~(MXC_CCM_CLPCR_LPM_MASK);
-	arm_srpgcr = __raw_readl(MXC_SRPG_ARM_SRPGCR) & ~(MXC_SRPGCR_PCR);
-	empgc0 = __raw_readl(MXC_SRPG_EMPGC0_SRPGCR) & ~(MXC_SRPGCR_PCR);
-	empgc1 = __raw_readl(MXC_SRPG_EMPGC1_SRPGCR) & ~(MXC_SRPGCR_PCR);
+	arm_srpgcr = __raw_readl(gpc_base + MXC_SRPG_ARM_SRPGCR) &
+		     ~(MXC_SRPGCR_PCR);
+	empgc0 = __raw_readl(gpc_base + MXC_SRPG_EMPGC0_SRPGCR) &
+		 ~(MXC_SRPGCR_PCR);
+	empgc1 = __raw_readl(gpc_base + MXC_SRPG_EMPGC1_SRPGCR) &
+		 ~(MXC_SRPGCR_PCR);
 
 	switch (mode) {
 	case WAIT_CLOCKED:
@@ -114,17 +127,17 @@ static void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 		return;
 	}
 
-	__raw_writel(plat_lpc, MXC_CORTEXA8_PLAT_LPC);
+	__raw_writel(plat_lpc, cortex_base + MXC_CORTEXA8_PLAT_LPC);
 	__raw_writel(ccm_clpcr, ccm_base + MXC_CCM_CLPCR);
-	__raw_writel(arm_srpgcr, MXC_SRPG_ARM_SRPGCR);
-	__raw_writel(arm_srpgcr, MXC_SRPG_NEON_SRPGCR);
+	__raw_writel(arm_srpgcr, gpc_base + MXC_SRPG_ARM_SRPGCR);
+	__raw_writel(arm_srpgcr, gpc_base + MXC_SRPG_NEON_SRPGCR);
 
 	if (stop_mode) {
 		empgc0 |= MXC_SRPGCR_PCR;
 		empgc1 |= MXC_SRPGCR_PCR;
 
-		__raw_writel(empgc0, MXC_SRPG_EMPGC0_SRPGCR);
-		__raw_writel(empgc1, MXC_SRPG_EMPGC1_SRPGCR);
+		__raw_writel(empgc0, gpc_base + MXC_SRPG_EMPGC0_SRPGCR);
+		__raw_writel(empgc1, gpc_base + MXC_SRPG_EMPGC1_SRPGCR);
 	}
 }
 
@@ -146,8 +159,8 @@ static int mx5_suspend_enter(suspend_state_t state)
 		flush_cache_all();
 
 		/*clear the EMPGC0/1 bits */
-		__raw_writel(0, MXC_SRPG_EMPGC0_SRPGCR);
-		__raw_writel(0, MXC_SRPG_EMPGC1_SRPGCR);
+		__raw_writel(0, gpc_base + MXC_SRPG_EMPGC0_SRPGCR);
+		__raw_writel(0, gpc_base + MXC_SRPG_EMPGC1_SRPGCR);
 	}
 	cpu_do_idle();
 
@@ -181,7 +194,7 @@ static void imx5_pm_idle(void)
 	imx5_cpu_do_idle();
 }
 
-static int __init imx5_pm_common_init(void)
+static int __init imx5_pm_common_init(const struct imx5_pm_data *data)
 {
 	int ret;
 	struct clk *gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs");
@@ -195,17 +208,28 @@ static int __init imx5_pm_common_init(void)
 
 	arm_pm_idle = imx5_pm_idle;
 
-	WARN_ON(!ccm_base);
+	cortex_base = ioremap(data->cortex_addr, SZ_16K);
+	gpc_base = ioremap(data->gpc_addr, SZ_16K);
+	WARN_ON(!ccm_base || !cortex_base || !gpc_base);
 
 	/* Set the registers to the default cpu idle state. */
 	mx5_cpu_lp_set(IMX5_DEFAULT_CPU_IDLE_STATE);
 
-	return imx5_cpuidle_init();
+	ret = imx5_cpuidle_init();
+	if (ret)
+		pr_warn("%s: cpuidle init failed %d\n", __func__, ret);
+
+	suspend_set_ops(&mx5_suspend_ops);
+
+	return 0;
+}
+
+void __init imx51_pm_init(void)
+{
+	imx5_pm_common_init(&imx51_pm_data);
 }
 
-void __init imx5_pm_init(void)
+void __init imx53_pm_init(void)
 {
-	int ret = imx5_pm_common_init();
-	if (!ret)
-		suspend_set_ops(&mx5_suspend_ops);
+	imx5_pm_common_init(&imx53_pm_data);
 }

commit 4ef5e3870113c5caab22d4363d882b372f2c6b57
Author: Shawn Guo <shawn.guo@freescale.com>
Date:   Tue May 20 13:41:36 2014 +0800

    ARM: imx5: reuse clock CCM mapping in pm code
    
    The imx5 pm code needs to access CCM registers.  Let's remove the use
    of CCM static mapping in pm code by reusing the dynamic mapping created
    in clock code.
    
    Signed-off-by: Shawn Guo <shawn.guo@freescale.com>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index 7dfd005c9c9e..3544c2524617 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -21,8 +21,7 @@
 #include "cpuidle.h"
 #include "hardware.h"
 
-#define MX51_CCM_BASE			MX51_IO_ADDRESS(MX51_CCM_BASE_ADDR)
-#define MXC_CCM_CLPCR			(MX51_CCM_BASE + 0x54)
+#define MXC_CCM_CLPCR			0x54
 #define MXC_CCM_CLPCR_LPM_OFFSET	0
 #define MXC_CCM_CLPCR_LPM_MASK		0x3
 #define MXC_CCM_CLPCR_STBY_COUNT_OFFSET	9
@@ -57,6 +56,13 @@
  */
 #define IMX5_DEFAULT_CPU_IDLE_STATE WAIT_UNCLOCKED_POWER_OFF
 
+static void __iomem *ccm_base;
+
+void __init imx5_pm_set_ccm_base(void __iomem *base)
+{
+	ccm_base = base;
+}
+
 /*
  * set cpu low power mode before WFI instruction. This function is called
  * mx5 because it can be used for mx51, and mx53.
@@ -70,7 +76,8 @@ static void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 	/* always allow platform to issue a deep sleep mode request */
 	plat_lpc = __raw_readl(MXC_CORTEXA8_PLAT_LPC) &
 	    ~(MXC_CORTEXA8_PLAT_LPC_DSM);
-	ccm_clpcr = __raw_readl(MXC_CCM_CLPCR) & ~(MXC_CCM_CLPCR_LPM_MASK);
+	ccm_clpcr = __raw_readl(ccm_base + MXC_CCM_CLPCR) &
+		    ~(MXC_CCM_CLPCR_LPM_MASK);
 	arm_srpgcr = __raw_readl(MXC_SRPG_ARM_SRPGCR) & ~(MXC_SRPGCR_PCR);
 	empgc0 = __raw_readl(MXC_SRPG_EMPGC0_SRPGCR) & ~(MXC_SRPGCR_PCR);
 	empgc1 = __raw_readl(MXC_SRPG_EMPGC1_SRPGCR) & ~(MXC_SRPGCR_PCR);
@@ -108,7 +115,7 @@ static void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 	}
 
 	__raw_writel(plat_lpc, MXC_CORTEXA8_PLAT_LPC);
-	__raw_writel(ccm_clpcr, MXC_CCM_CLPCR);
+	__raw_writel(ccm_clpcr, ccm_base + MXC_CCM_CLPCR);
 	__raw_writel(arm_srpgcr, MXC_SRPG_ARM_SRPGCR);
 	__raw_writel(arm_srpgcr, MXC_SRPG_NEON_SRPGCR);
 
@@ -188,6 +195,8 @@ static int __init imx5_pm_common_init(void)
 
 	arm_pm_idle = imx5_pm_idle;
 
+	WARN_ON(!ccm_base);
+
 	/* Set the registers to the default cpu idle state. */
 	mx5_cpu_lp_set(IMX5_DEFAULT_CPU_IDLE_STATE);
 

commit e7d5eb3c4527e6b8c0d950d26037af2fa5ac7537
Author: Shawn Guo <shawn.guo@freescale.com>
Date:   Tue May 20 10:23:50 2014 +0800

    ARM: imx5: remove header crm-regs-imx5.h
    
    Most of the macros in crm-regs-imx5.h are used nowhere.  Let's move the
    needed ones into the C files, and remove the header.
    
    Signed-off-by: Shawn Guo <shawn.guo@freescale.com>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index 58aeaf5baaf6..7dfd005c9c9e 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -19,9 +19,34 @@
 
 #include "common.h"
 #include "cpuidle.h"
-#include "crm-regs-imx5.h"
 #include "hardware.h"
 
+#define MX51_CCM_BASE			MX51_IO_ADDRESS(MX51_CCM_BASE_ADDR)
+#define MXC_CCM_CLPCR			(MX51_CCM_BASE + 0x54)
+#define MXC_CCM_CLPCR_LPM_OFFSET	0
+#define MXC_CCM_CLPCR_LPM_MASK		0x3
+#define MXC_CCM_CLPCR_STBY_COUNT_OFFSET	9
+#define MXC_CCM_CLPCR_VSTBY		(0x1 << 8)
+#define MXC_CCM_CLPCR_SBYOS		(0x1 << 6)
+
+#define MX51_CORTEXA8_BASE		MX51_IO_ADDRESS(MX51_ARM_BASE_ADDR)
+#define MXC_CORTEXA8_PLAT_LPC		(MX51_CORTEXA8_BASE + 0xc)
+#define MXC_CORTEXA8_PLAT_LPC_DSM	(1 << 0)
+#define MXC_CORTEXA8_PLAT_LPC_DBG_DSM	(1 << 1)
+
+#define MX51_GPC_BASE			MX51_IO_ADDRESS(MX51_GPC_BASE_ADDR)
+#define MXC_SRPG_NEON_BASE		(MX51_GPC_BASE + 0x280)
+#define MXC_SRPG_ARM_BASE		(MX51_GPC_BASE + 0x2a0)
+#define MXC_SRPG_EMPGC0_BASE		(MX51_GPC_BASE + 0x2c0)
+#define MXC_SRPG_EMPGC1_BASE		(MX51_GPC_BASE + 0x2d0)
+
+#define MXC_SRPG_NEON_SRPGCR		(MXC_SRPG_NEON_BASE + 0x0)
+#define MXC_SRPG_ARM_SRPGCR		(MXC_SRPG_ARM_BASE + 0x0)
+#define MXC_SRPG_EMPGC0_SRPGCR		(MXC_SRPG_EMPGC0_BASE + 0x0)
+#define MXC_SRPG_EMPGC1_SRPGCR		(MXC_SRPG_EMPGC1_BASE + 0x0)
+
+#define MXC_SRPGCR_PCR			1
+
 /*
  * The WAIT_UNCLOCKED_POWER_OFF state only requires <= 500ns to exit.
  * This is also the lowest power state possible without affecting

commit 547dd1e089db9927ad95cfb525152fec5153cfeb
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Fri Jul 26 00:17:36 2013 -0300

    ARM: mx53: Allow suspend/resume
    
    Current imx53_pm_init() implementation is incomplete as it lacks calling
    suspend_set_ops().
    
    Use a single imx5_pm_init() function to handle both mx51 and mx53.
    
    This allows mx53 to enter in low-power mode.
    
    Tested on a mx53qsb:
    
    root@freescale /$ echo mem > /sys/power/state
    PM: Syncing filesystems ... done.
    mmc0: card e624 removed
    Freezing user space processes ... (elapsed 0.001 seconds) done.
    Freezing remaining freezable tasks ... (elapsed 0.001 seconds) done.
    Suspending console(s) (use no_console_suspend to debug)
    
    ... (Press Power button)
    
    PM: suspend of devices complete after 17.067 msecs
    PM: suspend devices took 0.020 seconds
    PM: late suspend of devices complete after 0.954 msecs
    PM: noirq suspend of devices complete after 1.288 msecs
    Disabling non-boot CPUs ...
    PM: noirq resume of devices complete after 0.680 msecs
    PM: early resume of devices complete after 0.914 msecs
    PM: resume of devices complete after 44.955 msecs
    PM: resume devices took 0.050 seconds
    Restarting tasks ... done.
    mmc0: host does not support reading read-only switch. assuming write-enable.
    mmc0: new SDHC card at address e624
    mmcblk0: mmc0:e624 SU04G 3.69 GiB
     mmcblk0: p1 p2 p3
    libphy: 63fec000.etherne:00 - Link is Down
    libphy: 63fec000.etherne:00 - Link is Up - 100/Full
    root@freescale /$
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index 82e79c658eb2..58aeaf5baaf6 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -169,14 +169,9 @@ static int __init imx5_pm_common_init(void)
 	return imx5_cpuidle_init();
 }
 
-void __init imx51_pm_init(void)
+void __init imx5_pm_init(void)
 {
 	int ret = imx5_pm_common_init();
 	if (!ret)
 		suspend_set_ops(&mx5_suspend_ops);
 }
-
-void __init imx53_pm_init(void)
-{
-	imx5_pm_common_init();
-}

commit 54a4644b7a31b017375018d8266a22d3eabfcf0e
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Tue Apr 23 08:54:45 2013 +0000

    ARM: imx: cpuidle: use init/exit common routine
    
    The code intializes the cpuidle driver at different places.
    The cpuidle driver for :
      * imx5 : is in the pm-imx5.c, the init function is in cpuidle.c
      * imx6 : is in cpuidle-imx6q.c, the init function is in cpuidle.c
               and cpuidle-imx6q.c
    
    Instead of having the cpuidle code spread across different files,
    let's create a driver for each SoC and use the common register function.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index 4b52b3e028ab..82e79c658eb2 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -149,32 +149,6 @@ static void imx5_pm_idle(void)
 	imx5_cpu_do_idle();
 }
 
-static int imx5_cpuidle_enter(struct cpuidle_device *dev,
-				struct cpuidle_driver *drv, int idx)
-{
-	int ret;
-
-	ret = imx5_cpu_do_idle();
-	if (ret < 0)
-		return ret;
-
-	return idx;
-}
-
-static struct cpuidle_driver imx5_cpuidle_driver = {
-	.name			= "imx5_cpuidle",
-	.owner			= THIS_MODULE,
-	.states[0]	= {
-		.enter			= imx5_cpuidle_enter,
-		.exit_latency		= 2,
-		.target_residency	= 1,
-		.flags			= CPUIDLE_FLAG_TIME_VALID,
-		.name			= "IMX5 SRPG",
-		.desc			= "CPU state retained,powered off",
-	},
-	.state_count		= 1,
-};
-
 static int __init imx5_pm_common_init(void)
 {
 	int ret;
@@ -192,8 +166,7 @@ static int __init imx5_pm_common_init(void)
 	/* Set the registers to the default cpu idle state. */
 	mx5_cpu_lp_set(IMX5_DEFAULT_CPU_IDLE_STATE);
 
-	imx_cpuidle_init(&imx5_cpuidle_driver);
-	return 0;
+	return imx5_cpuidle_init();
 }
 
 void __init imx51_pm_init(void)

commit 554c06ba3ee29cf453fca17e9e61120b75aa476d
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Tue Apr 23 08:54:31 2013 +0000

    cpuidle: remove en_core_tk_irqen flag
    
    The en_core_tk_irqen flag is set in all the cpuidle driver which
    means it is not necessary to specify this flag.
    
    Remove the flag and the code related to it.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Kevin Hilman <khilman@linaro.org>  # for mach-omap2/*
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index f67fd7ee8127..4b52b3e028ab 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -164,7 +164,6 @@ static int imx5_cpuidle_enter(struct cpuidle_device *dev,
 static struct cpuidle_driver imx5_cpuidle_driver = {
 	.name			= "imx5_cpuidle",
 	.owner			= THIS_MODULE,
-	.en_core_tk_irqen	= 1,
 	.states[0]	= {
 		.enter			= imx5_cpuidle_enter,
 		.exit_latency		= 2,

commit 7356420cd34e40fe27bf26555b0bf3f2849a43dd
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Tue Jan 22 10:40:55 2013 -0200

    ARM: imx: Remove mx508 support
    
    Only mx508 based board is mach-mx50_rdp and it has been marked as BROKEN
    for several releases.
    
    mx508 currently lacks clock support.
    
    In case someone needs to add mx508 support back, then the recommended approach
    is to use device tree.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index 2e063c2deb9e..f67fd7ee8127 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -34,7 +34,7 @@
 
 /*
  * set cpu low power mode before WFI instruction. This function is called
- * mx5 because it can be used for mx50, mx51, and mx53.
+ * mx5 because it can be used for mx51, and mx53.
  */
 static void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 {
@@ -85,10 +85,7 @@ static void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 	__raw_writel(plat_lpc, MXC_CORTEXA8_PLAT_LPC);
 	__raw_writel(ccm_clpcr, MXC_CCM_CLPCR);
 	__raw_writel(arm_srpgcr, MXC_SRPG_ARM_SRPGCR);
-
-	/* Enable NEON SRPG for all but MX50TO1.0. */
-	if (mx50_revision() != IMX_CHIP_REVISION_1_0)
-		__raw_writel(arm_srpgcr, MXC_SRPG_NEON_SRPGCR);
+	__raw_writel(arm_srpgcr, MXC_SRPG_NEON_SRPGCR);
 
 	if (stop_mode) {
 		empgc0 |= MXC_SRPGCR_PCR;

commit 50f2de61269bbe2f40bead1969a9594fa8599b93
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Fri Sep 14 14:14:45 2012 +0800

    ARM: imx: include hardware.h rather than mach/hardware.h
    
    It moves a bunch of header files included in hardware.h and itself
    from mach-imx/include/mach to mach-imx, and updates users to include
    hardware.h rather than mach/hardware.h.  The files in mach-imx/devices
    will need to include "../hardware.h".
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index a614702872f4..2e063c2deb9e 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -16,11 +16,11 @@
 #include <asm/cacheflush.h>
 #include <asm/system_misc.h>
 #include <asm/tlbflush.h>
-#include <mach/hardware.h>
 
 #include "common.h"
 #include "cpuidle.h"
 #include "crm-regs-imx5.h"
+#include "hardware.h"
 
 /*
  * The WAIT_UNCLOCKED_POWER_OFF state only requires <= 500ns to exit.

commit e29248c9a7522cb50edd29f2a717be8f323cbeb3
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Thu Sep 13 21:12:50 2012 +0800

    ARM: imx: ARM: imx: include cpuidle.h rather than mach/cpuidle.h
    
    Rename mach-imx/include/mach/cpuidle.h to mach-imx/cpuidle.h, and
    update users to include cpuidle.h rather than mach/cpuidle.h.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index 9fead8c4ea9d..a614702872f4 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -16,10 +16,10 @@
 #include <asm/cacheflush.h>
 #include <asm/system_misc.h>
 #include <asm/tlbflush.h>
-#include <mach/cpuidle.h>
 #include <mach/hardware.h>
 
 #include "common.h"
+#include "cpuidle.h"
 #include "crm-regs-imx5.h"
 
 /*

commit e3372474cfa0dc016f10ec47baddbd1ed0abecf3
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Thu Sep 13 21:01:00 2012 +0800

    ARM: imx: include common.h rather than mach/common.h
    
    Rename mach-imx/include/mach/common.h to mach-imx/common.h and update
    all users to include common.h rather than mach/common.h.
    
    It also removes an unneeded inclusion to common.h in
    mach-imx/devices/devices.c.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index 19621ed1ffa5..9fead8c4ea9d 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -16,9 +16,10 @@
 #include <asm/cacheflush.h>
 #include <asm/system_misc.h>
 #include <asm/tlbflush.h>
-#include <mach/common.h>
 #include <mach/cpuidle.h>
 #include <mach/hardware.h>
+
+#include "common.h"
 #include "crm-regs-imx5.h"
 
 /*

commit ccc12b32dc8c8e88a5b35f8df34ec7c80f2e10b0
Author: Robert Lee <rob.lee@linaro.org>
Date:   Mon May 21 17:50:29 2012 -0500

    ARM: imx: Add imx5 cpuidle
    
    Add cpuidle driver for imx5 platform.
    
    Signed-off-by: Robert Lee <rob.lee@linaro.org>
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index b3dcd8e50d5b..19621ed1ffa5 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -12,10 +12,12 @@
 #include <linux/clk.h>
 #include <linux/io.h>
 #include <linux/err.h>
+#include <linux/export.h>
 #include <asm/cacheflush.h>
 #include <asm/system_misc.h>
 #include <asm/tlbflush.h>
 #include <mach/common.h>
+#include <mach/cpuidle.h>
 #include <mach/hardware.h>
 #include "crm-regs-imx5.h"
 
@@ -134,12 +136,48 @@ static const struct platform_suspend_ops mx5_suspend_ops = {
 	.enter = mx5_suspend_enter,
 };
 
-static void imx5_pm_idle(void)
+static inline int imx5_cpu_do_idle(void)
 {
-	if (likely(!tzic_enable_wake()))
+	int ret = tzic_enable_wake();
+
+	if (likely(!ret))
 		cpu_do_idle();
+
+	return ret;
+}
+
+static void imx5_pm_idle(void)
+{
+	imx5_cpu_do_idle();
+}
+
+static int imx5_cpuidle_enter(struct cpuidle_device *dev,
+				struct cpuidle_driver *drv, int idx)
+{
+	int ret;
+
+	ret = imx5_cpu_do_idle();
+	if (ret < 0)
+		return ret;
+
+	return idx;
 }
 
+static struct cpuidle_driver imx5_cpuidle_driver = {
+	.name			= "imx5_cpuidle",
+	.owner			= THIS_MODULE,
+	.en_core_tk_irqen	= 1,
+	.states[0]	= {
+		.enter			= imx5_cpuidle_enter,
+		.exit_latency		= 2,
+		.target_residency	= 1,
+		.flags			= CPUIDLE_FLAG_TIME_VALID,
+		.name			= "IMX5 SRPG",
+		.desc			= "CPU state retained,powered off",
+	},
+	.state_count		= 1,
+};
+
 static int __init imx5_pm_common_init(void)
 {
 	int ret;
@@ -157,6 +195,7 @@ static int __init imx5_pm_common_init(void)
 	/* Set the registers to the default cpu idle state. */
 	mx5_cpu_lp_set(IMX5_DEFAULT_CPU_IDLE_STATE);
 
+	imx_cpuidle_init(&imx5_cpuidle_driver);
 	return 0;
 }
 

commit aa96a18d22dc7ad4dbc98cb0f4b2967a9fc979ca
Author: Robert Lee <rob.lee@linaro.org>
Date:   Mon May 21 17:50:27 2012 -0500

    ARM: imx: Enable imx53 low power idle
    
    Add various functionality needed to enable a imx53 low power idle
    state.  This includes adding the imx53 gpc_dvfs clock and making a
    common imx5_late_init function and initializing all imx53
     MACHINE_STATE late_init calls to imx5_late_init.
    
    Signed-off-by: Robert Lee <rob.lee@linaro.org>
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index baf93214f899..b3dcd8e50d5b 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -166,3 +166,8 @@ void __init imx51_pm_init(void)
 	if (!ret)
 		suspend_set_ops(&mx5_suspend_ops);
 }
+
+void __init imx53_pm_init(void)
+{
+	imx5_pm_common_init();
+}

commit 565fa91f236524b6ba4872903dc9cc9c874493e6
Author: Robert Lee <rob.lee@linaro.org>
Date:   Mon May 21 17:50:26 2012 -0500

    ARM: imx: clean and consolidate imx5 suspend and idle code
    
    The imx5 idle code that existed in mm-imx5.c is moved to pm-imx5.c.
    The imx5_pm_init call is now exported and called during the
    MACHINE_START late_init in supported imx5 platforms.
    
    Remove various enabling/disabling of the gpc_dvfs clock and
    enable it once during initialization.  This is a very low
    power clock that must be enabled during low power operations.
    
    There are only two "suspend_state_t" imx5 low power modes ever
    used.  STOP_POWER_OFF for suspend to mem and
    WAIT_UNCLOCKED_POWER_OFF for idle and suspend to standby.  The
    latter mode only requires 500 nanoseconds of extra hardware
    exit time beyond a basic WFI operation (WAIT_CLOCKED mode) so
    no other idle mode is necessary.  Given this information, it
    is more efficient to keep the registers in the often used
    WAIT_UNCLOCKED_POWER_OFF state and only to and from the
    STOP_POWER_OFF register state as needed when suspend to
    mem is required.
    
    Signed-off-by: Robert Lee <rob.lee@linaro.org>
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index e26a9cb05ed8..baf93214f899 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -13,18 +13,27 @@
 #include <linux/io.h>
 #include <linux/err.h>
 #include <asm/cacheflush.h>
+#include <asm/system_misc.h>
 #include <asm/tlbflush.h>
 #include <mach/common.h>
 #include <mach/hardware.h>
 #include "crm-regs-imx5.h"
 
-static struct clk *gpc_dvfs_clk;
+/*
+ * The WAIT_UNCLOCKED_POWER_OFF state only requires <= 500ns to exit.
+ * This is also the lowest power state possible without affecting
+ * non-cpu parts of the system.  For these reasons, imx5 should default
+ * to always using this state for cpu idling.  The PM_SUSPEND_STANDBY also
+ * uses this state and needs to take no action when registers remain confgiured
+ * for this state.
+ */
+#define IMX5_DEFAULT_CPU_IDLE_STATE WAIT_UNCLOCKED_POWER_OFF
 
 /*
  * set cpu low power mode before WFI instruction. This function is called
  * mx5 because it can be used for mx50, mx51, and mx53.
  */
-void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
+static void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 {
 	u32 plat_lpc, arm_srpgcr, ccm_clpcr;
 	u32 empgc0, empgc1;
@@ -87,11 +96,6 @@ void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 	}
 }
 
-static int mx5_suspend_prepare(void)
-{
-	return clk_prepare_enable(gpc_dvfs_clk);
-}
-
 static int mx5_suspend_enter(suspend_state_t state)
 {
 	switch (state) {
@@ -99,7 +103,7 @@ static int mx5_suspend_enter(suspend_state_t state)
 		mx5_cpu_lp_set(STOP_POWER_OFF);
 		break;
 	case PM_SUSPEND_STANDBY:
-		mx5_cpu_lp_set(WAIT_UNCLOCKED_POWER_OFF);
+		/* DEFAULT_IDLE_STATE already configured */
 		break;
 	default:
 		return -EINVAL;
@@ -114,12 +118,10 @@ static int mx5_suspend_enter(suspend_state_t state)
 		__raw_writel(0, MXC_SRPG_EMPGC1_SRPGCR);
 	}
 	cpu_do_idle();
-	return 0;
-}
 
-static void mx5_suspend_finish(void)
-{
-	clk_disable_unprepare(gpc_dvfs_clk);
+	/* return registers to default idle state */
+	mx5_cpu_lp_set(IMX5_DEFAULT_CPU_IDLE_STATE);
+	return 0;
 }
 
 static int mx5_pm_valid(suspend_state_t state)
@@ -129,25 +131,38 @@ static int mx5_pm_valid(suspend_state_t state)
 
 static const struct platform_suspend_ops mx5_suspend_ops = {
 	.valid = mx5_pm_valid,
-	.prepare = mx5_suspend_prepare,
 	.enter = mx5_suspend_enter,
-	.finish = mx5_suspend_finish,
 };
 
-static int __init mx5_pm_init(void)
+static void imx5_pm_idle(void)
 {
-	if (!cpu_is_mx51() && !cpu_is_mx53())
-		return 0;
+	if (likely(!tzic_enable_wake()))
+		cpu_do_idle();
+}
+
+static int __init imx5_pm_common_init(void)
+{
+	int ret;
+	struct clk *gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs");
+
+	if (IS_ERR(gpc_dvfs_clk))
+		return PTR_ERR(gpc_dvfs_clk);
 
-	if (gpc_dvfs_clk == NULL)
-		gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs");
+	ret = clk_prepare_enable(gpc_dvfs_clk);
+	if (ret)
+		return ret;
 
-	if (!IS_ERR(gpc_dvfs_clk)) {
-		if (cpu_is_mx51())
-			suspend_set_ops(&mx5_suspend_ops);
-	} else
-		return -EPERM;
+	arm_pm_idle = imx5_pm_idle;
+
+	/* Set the registers to the default cpu idle state. */
+	mx5_cpu_lp_set(IMX5_DEFAULT_CPU_IDLE_STATE);
 
 	return 0;
 }
-device_initcall(mx5_pm_init);
+
+void __init imx51_pm_init(void)
+{
+	int ret = imx5_pm_common_init();
+	if (!ret)
+		suspend_set_ops(&mx5_suspend_ops);
+}

commit d816c6e644fd5b63fa7dbf865360db218753a212
Author: Richard Zhao <richard.zhao@linaro.org>
Date:   Tue Nov 15 14:48:03 2011 +0800

    ARM: pm-imx5: add clk_prepare/clk_unprepare
    
    It's for migrating to generic clk framework API.
    
    Signed-off-by: Richard Zhao <richard.zhao@linaro.org>
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
index 6dc093448057..e26a9cb05ed8 100644
--- a/arch/arm/mach-imx/pm-imx5.c
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -89,7 +89,7 @@ void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 
 static int mx5_suspend_prepare(void)
 {
-	return clk_enable(gpc_dvfs_clk);
+	return clk_prepare_enable(gpc_dvfs_clk);
 }
 
 static int mx5_suspend_enter(suspend_state_t state)
@@ -119,7 +119,7 @@ static int mx5_suspend_enter(suspend_state_t state)
 
 static void mx5_suspend_finish(void)
 {
-	clk_disable(gpc_dvfs_clk);
+	clk_disable_unprepare(gpc_dvfs_clk);
 }
 
 static int mx5_pm_valid(suspend_state_t state)

commit eaed435a7b870a38d89dbdb535c7842d618d3214
Merge: a99cbf6b43a7 3f07f355704b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 23 14:50:30 2012 -0800

    Merge tag 'arm-soc-imx-move' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Consolidate i.MX 5 platforms to be under the new shared i.MX 3/5/6 tree.
    
    * tag 'arm-soc-imx-move' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      ARM i.MX: Update defconfig
      ARM i.MX: Merge i.MX5 support into mach-imx
      ARM i.MX5: remove unnecessary includes from board files
    
    Fix up fairly trivial conflicts due to various changes nearby in
    arch/arm/{mach,plat}-imx/{Kconfig,Makefile}
    
    Pull request had been sent to the wrong email address, but happened
    before the merge window closed.  I'm merging the MX 5 consolidation,
    since it apparently will help the next development window and will avoid
    conflicts later as per Arnd.

commit 784a90c0a7d8f5aa94b6c7d295ad44ae8e045aa3
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Mon Nov 7 12:36:48 2011 +0100

    ARM i.MX: Merge i.MX5 support into mach-imx
    
    This patch moves the contents of arch/arm/mach-mx5 to arch/arm/mach-imx
    and adjusts the Makefile/Kconfig entries in a way that it's possible
    to compile i.MX5 together with i.MX3/6.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    Tested-by: Dirk Behme <dirk.behme@de.bosch.com>

diff --git a/arch/arm/mach-imx/pm-imx5.c b/arch/arm/mach-imx/pm-imx5.c
new file mode 100644
index 000000000000..3d57b5d429fe
--- /dev/null
+++ b/arch/arm/mach-imx/pm-imx5.c
@@ -0,0 +1,156 @@
+/*
+ *  Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/suspend.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <asm/cacheflush.h>
+#include <asm/tlbflush.h>
+#include <mach/common.h>
+#include <mach/hardware.h>
+#include "crm-regs-imx5.h"
+
+static struct clk *gpc_dvfs_clk;
+
+/*
+ * set cpu low power mode before WFI instruction. This function is called
+ * mx5 because it can be used for mx50, mx51, and mx53.
+ */
+void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
+{
+	u32 plat_lpc, arm_srpgcr, ccm_clpcr;
+	u32 empgc0, empgc1;
+	int stop_mode = 0;
+
+	/* always allow platform to issue a deep sleep mode request */
+	plat_lpc = __raw_readl(MXC_CORTEXA8_PLAT_LPC) &
+	    ~(MXC_CORTEXA8_PLAT_LPC_DSM);
+	ccm_clpcr = __raw_readl(MXC_CCM_CLPCR) & ~(MXC_CCM_CLPCR_LPM_MASK);
+	arm_srpgcr = __raw_readl(MXC_SRPG_ARM_SRPGCR) & ~(MXC_SRPGCR_PCR);
+	empgc0 = __raw_readl(MXC_SRPG_EMPGC0_SRPGCR) & ~(MXC_SRPGCR_PCR);
+	empgc1 = __raw_readl(MXC_SRPG_EMPGC1_SRPGCR) & ~(MXC_SRPGCR_PCR);
+
+	switch (mode) {
+	case WAIT_CLOCKED:
+		break;
+	case WAIT_UNCLOCKED:
+		ccm_clpcr |= 0x1 << MXC_CCM_CLPCR_LPM_OFFSET;
+		break;
+	case WAIT_UNCLOCKED_POWER_OFF:
+	case STOP_POWER_OFF:
+		plat_lpc |= MXC_CORTEXA8_PLAT_LPC_DSM
+			    | MXC_CORTEXA8_PLAT_LPC_DBG_DSM;
+		if (mode == WAIT_UNCLOCKED_POWER_OFF) {
+			ccm_clpcr |= 0x1 << MXC_CCM_CLPCR_LPM_OFFSET;
+			ccm_clpcr &= ~MXC_CCM_CLPCR_VSTBY;
+			ccm_clpcr &= ~MXC_CCM_CLPCR_SBYOS;
+			stop_mode = 0;
+		} else {
+			ccm_clpcr |= 0x2 << MXC_CCM_CLPCR_LPM_OFFSET;
+			ccm_clpcr |= 0x3 << MXC_CCM_CLPCR_STBY_COUNT_OFFSET;
+			ccm_clpcr |= MXC_CCM_CLPCR_VSTBY;
+			ccm_clpcr |= MXC_CCM_CLPCR_SBYOS;
+			stop_mode = 1;
+		}
+		arm_srpgcr |= MXC_SRPGCR_PCR;
+
+		if (tzic_enable_wake(1) != 0)
+			return;
+		break;
+	case STOP_POWER_ON:
+		ccm_clpcr |= 0x2 << MXC_CCM_CLPCR_LPM_OFFSET;
+		break;
+	default:
+		printk(KERN_WARNING "UNKNOWN cpu power mode: %d\n", mode);
+		return;
+	}
+
+	__raw_writel(plat_lpc, MXC_CORTEXA8_PLAT_LPC);
+	__raw_writel(ccm_clpcr, MXC_CCM_CLPCR);
+	__raw_writel(arm_srpgcr, MXC_SRPG_ARM_SRPGCR);
+
+	/* Enable NEON SRPG for all but MX50TO1.0. */
+	if (mx50_revision() != IMX_CHIP_REVISION_1_0)
+		__raw_writel(arm_srpgcr, MXC_SRPG_NEON_SRPGCR);
+
+	if (stop_mode) {
+		empgc0 |= MXC_SRPGCR_PCR;
+		empgc1 |= MXC_SRPGCR_PCR;
+
+		__raw_writel(empgc0, MXC_SRPG_EMPGC0_SRPGCR);
+		__raw_writel(empgc1, MXC_SRPG_EMPGC1_SRPGCR);
+	}
+}
+
+static int mx5_suspend_prepare(void)
+{
+	return clk_enable(gpc_dvfs_clk);
+}
+
+static int mx5_suspend_enter(suspend_state_t state)
+{
+	switch (state) {
+	case PM_SUSPEND_MEM:
+		mx5_cpu_lp_set(STOP_POWER_OFF);
+		break;
+	case PM_SUSPEND_STANDBY:
+		mx5_cpu_lp_set(WAIT_UNCLOCKED_POWER_OFF);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (state == PM_SUSPEND_MEM) {
+		local_flush_tlb_all();
+		flush_cache_all();
+
+		/*clear the EMPGC0/1 bits */
+		__raw_writel(0, MXC_SRPG_EMPGC0_SRPGCR);
+		__raw_writel(0, MXC_SRPG_EMPGC1_SRPGCR);
+	}
+	cpu_do_idle();
+	return 0;
+}
+
+static void mx5_suspend_finish(void)
+{
+	clk_disable(gpc_dvfs_clk);
+}
+
+static int mx5_pm_valid(suspend_state_t state)
+{
+	return (state > PM_SUSPEND_ON && state <= PM_SUSPEND_MAX);
+}
+
+static const struct platform_suspend_ops mx5_suspend_ops = {
+	.valid = mx5_pm_valid,
+	.prepare = mx5_suspend_prepare,
+	.enter = mx5_suspend_enter,
+	.finish = mx5_suspend_finish,
+};
+
+static int __init mx5_pm_init(void)
+{
+	if (!cpu_is_mx51() && !cpu_is_mx53())
+		return 0;
+
+	if (gpc_dvfs_clk == NULL)
+		gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs");
+
+	if (!IS_ERR(gpc_dvfs_clk)) {
+		if (cpu_is_mx51())
+			suspend_set_ops(&mx5_suspend_ops);
+	} else
+		return -EPERM;
+
+	return 0;
+}
+device_initcall(mx5_pm_init);
