commit 62d1c1df85832d75acacb1e5cab2b1e7b80d3c1e
Author: Anson Huang <Anson.Huang@nxp.com>
Date:   Wed Feb 26 12:16:57 2020 +0800

    ARM: imx: Remove unnecessary blank lines
    
    Remove unnecessary blank lines for cleanup.
    
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index fb3cba87940d..ebc4339b8be4 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -111,7 +111,6 @@ void imx_gpc_mask_all(void)
 		gpc_saved_imrs[i] = readl_relaxed(reg_imr1 + i * 4);
 		writel_relaxed(~0, reg_imr1 + i * 4);
 	}
-
 }
 
 void imx_gpc_restore_all(void)

commit 4a4fb66119eb7135e6ce9cf61488c86f9888bb15
Author: Anson Huang <Anson.Huang@nxp.com>
Date:   Thu Feb 13 16:35:33 2020 +0800

    ARM: imx: Add missing of_node_put()
    
    After finishing using device node got from of_find_compatible_node(),
    of_node_put() needs to be called.
    
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index e96baa493318..fb3cba87940d 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -282,4 +282,5 @@ void __init imx_gpc_check_dt(void)
 		/* map GPC, so that at least CPUidle and WARs keep working */
 		gpc_base = of_iomap(np, 0);
 	}
+	of_node_put(np);
 }

commit 6384a04bba158ef927b3abe782b536cca07d11b1
Author: Anson Huang <Anson.Huang@nxp.com>
Date:   Fri Feb 14 11:06:46 2020 +0800

    ARM: imx: Remove unused include of linux/irqchip/arm-gic.h
    
    linux/irqchip/arm-gic.h is NOT used at all, no need to include it.
    
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index b5b557fe2c49..e96baa493318 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -10,7 +10,7 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
-#include <linux/irqchip/arm-gic.h>
+
 #include "common.h"
 #include "hardware.h"
 

commit fcaf20360a5992b88603271ab814a200e28d0088
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:08 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 159
    
    Based on 1 normalized pattern(s):
    
      the code contained herein is licensed under the gnu general public
      license you may obtain a copy of the gnu general public license
      version 2 or later at the following locations http www opensource
      org licenses gpl license html http www gnu org copyleft gpl html
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 161 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.383790741@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index e11159d40fb8..b5b557fe2c49 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -1,13 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright 2011-2013 Freescale Semiconductor, Inc.
  * Copyright 2011 Linaro Ltd.
- *
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
  */
 
 #include <linux/io.h>

commit c791bbbf812a18a7831619783f12a316beeac558
Author: Anson Huang <Anson.Huang@nxp.com>
Date:   Sun Jun 3 10:33:44 2018 +0800

    ARM: imx: add L2 page power control for GPC
    
    Some platforms like i.MX6UL/i.MX6SLL have L2
    page power control in GPC, it needs to be
    disabled if ARM is power gated and L2 is NOT
    flushed, add GPC interface to control it.
    
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Reviewed-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index de535cb679b3..e11159d40fb8 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -20,6 +20,7 @@
 #include "common.h"
 #include "hardware.h"
 
+#define GPC_CNTR		0x0
 #define GPC_IMR1		0x008
 #define GPC_PGC_CPU_PDN		0x2a0
 #define GPC_PGC_CPU_PUPSCR	0x2a4
@@ -27,6 +28,8 @@
 #define GPC_PGC_SW2ISO_SHIFT	0x8
 #define GPC_PGC_SW_SHIFT	0x0
 
+#define GPC_CNTR_L2_PGE_SHIFT	22
+
 #define IMR_NUM			4
 #define GPC_MAX_IRQS		(IMR_NUM * 32)
 
@@ -51,6 +54,17 @@ void imx_gpc_set_arm_power_in_lpm(bool power_off)
 	writel_relaxed(power_off, gpc_base + GPC_PGC_CPU_PDN);
 }
 
+void imx_gpc_set_l2_mem_power_in_lpm(bool power_off)
+{
+	u32 val;
+
+	val = readl_relaxed(gpc_base + GPC_CNTR);
+	val &= ~(1 << GPC_CNTR_L2_PGE_SHIFT);
+	if (power_off)
+		val |= 1 << GPC_CNTR_L2_PGE_SHIFT;
+	writel_relaxed(val, gpc_base + GPC_CNTR);
+}
+
 void imx_gpc_pre_suspend(bool arm_power_off)
 {
 	void __iomem *reg_imr1 = gpc_base + GPC_IMR1;

commit a8e65e06ec66f8657795162c51ee73bec116a890
Author: Rob Herring <robh@kernel.org>
Date:   Fri Jul 21 14:28:32 2017 -0500

    ARM: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Acked-by: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Javier Martinez Canillas <javier@osg.samsung.com>
    Cc: Fabio Estevam <fabio.estevam@nxp.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: "Beno√Æt Cousson" <bcousson@baylibre.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 93f584ba0130..de535cb679b3 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -224,13 +224,13 @@ static int __init imx_gpc_init(struct device_node *node,
 	int i;
 
 	if (!parent) {
-		pr_err("%s: no parent, giving up\n", node->full_name);
+		pr_err("%pOF: no parent, giving up\n", node);
 		return -ENODEV;
 	}
 
 	parent_domain = irq_find_host(parent);
 	if (!parent_domain) {
-		pr_err("%s: unable to obtain parent domain\n", node->full_name);
+		pr_err("%pOF: unable to obtain parent domain\n", node);
 		return -ENXIO;
 	}
 

commit 721cabf6c6600dbe689ee2782bc087270e97e652
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Fri Feb 17 20:02:44 2017 +0100

    soc: imx: move PGC handling to a new GPC driver
    
    This is an almost complete re-write of the previous GPC power gating control
    code found in the IMX architecture code. It supports both the old and the new
    DT binding, allowing more domains to be added later and generally makes the
    driver easier to extend, while keeping compatibility with existing DTBs.
    
    As the result, all functionality regarding the power gating controller
    gets removed from the IMX architecture GPC driver.  It keeps only the
    IRQ controller code in the architecture, as this is closely coupled to
    the CPU idle implementation.
    
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 1dc2a34b9dbd..93f584ba0130 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -10,26 +10,17 @@
  * http://www.gnu.org/copyleft/gpl.html
  */
 
-#include <linux/clk.h>
-#include <linux/delay.h>
 #include <linux/io.h>
 #include <linux/irq.h>
 #include <linux/irqchip.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
-#include <linux/platform_device.h>
-#include <linux/pm_domain.h>
-#include <linux/regulator/consumer.h>
 #include <linux/irqchip/arm-gic.h>
 #include "common.h"
 #include "hardware.h"
 
-#define GPC_CNTR		0x000
 #define GPC_IMR1		0x008
-#define GPC_PGC_GPU_PDN		0x260
-#define GPC_PGC_GPU_PUPSCR	0x264
-#define GPC_PGC_GPU_PDNSCR	0x268
 #define GPC_PGC_CPU_PDN		0x2a0
 #define GPC_PGC_CPU_PUPSCR	0x2a4
 #define GPC_PGC_CPU_PDNSCR	0x2a8
@@ -39,18 +30,6 @@
 #define IMR_NUM			4
 #define GPC_MAX_IRQS		(IMR_NUM * 32)
 
-#define GPU_VPU_PUP_REQ		BIT(1)
-#define GPU_VPU_PDN_REQ		BIT(0)
-
-#define GPC_CLK_MAX		6
-
-struct pu_domain {
-	struct generic_pm_domain base;
-	struct regulator *reg;
-	struct clk *clk[GPC_CLK_MAX];
-	int num_clks;
-};
-
 static void __iomem *gpc_base;
 static u32 gpc_wake_irqs[IMR_NUM];
 static u32 gpc_saved_imrs[IMR_NUM];
@@ -296,199 +275,3 @@ void __init imx_gpc_check_dt(void)
 		gpc_base = of_iomap(np, 0);
 	}
 }
-
-static void _imx6q_pm_pu_power_off(struct generic_pm_domain *genpd)
-{
-	int iso, iso2sw;
-	u32 val;
-
-	/* Read ISO and ISO2SW power down delays */
-	val = readl_relaxed(gpc_base + GPC_PGC_GPU_PDNSCR);
-	iso = val & 0x3f;
-	iso2sw = (val >> 8) & 0x3f;
-
-	/* Gate off PU domain when GPU/VPU when powered down */
-	writel_relaxed(0x1, gpc_base + GPC_PGC_GPU_PDN);
-
-	/* Request GPC to power down GPU/VPU */
-	val = readl_relaxed(gpc_base + GPC_CNTR);
-	val |= GPU_VPU_PDN_REQ;
-	writel_relaxed(val, gpc_base + GPC_CNTR);
-
-	/* Wait ISO + ISO2SW IPG clock cycles */
-	ndelay((iso + iso2sw) * 1000 / 66);
-}
-
-static int imx6q_pm_pu_power_off(struct generic_pm_domain *genpd)
-{
-	struct pu_domain *pu = container_of(genpd, struct pu_domain, base);
-
-	_imx6q_pm_pu_power_off(genpd);
-
-	if (pu->reg)
-		regulator_disable(pu->reg);
-
-	return 0;
-}
-
-static int imx6q_pm_pu_power_on(struct generic_pm_domain *genpd)
-{
-	struct pu_domain *pu = container_of(genpd, struct pu_domain, base);
-	int i, ret, sw, sw2iso;
-	u32 val;
-
-	if (pu->reg)
-		ret = regulator_enable(pu->reg);
-	if (pu->reg && ret) {
-		pr_err("%s: failed to enable regulator: %d\n", __func__, ret);
-		return ret;
-	}
-
-	/* Enable reset clocks for all devices in the PU domain */
-	for (i = 0; i < pu->num_clks; i++)
-		clk_prepare_enable(pu->clk[i]);
-
-	/* Gate off PU domain when GPU/VPU when powered down */
-	writel_relaxed(0x1, gpc_base + GPC_PGC_GPU_PDN);
-
-	/* Read ISO and ISO2SW power down delays */
-	val = readl_relaxed(gpc_base + GPC_PGC_GPU_PUPSCR);
-	sw = val & 0x3f;
-	sw2iso = (val >> 8) & 0x3f;
-
-	/* Request GPC to power up GPU/VPU */
-	val = readl_relaxed(gpc_base + GPC_CNTR);
-	val |= GPU_VPU_PUP_REQ;
-	writel_relaxed(val, gpc_base + GPC_CNTR);
-
-	/* Wait ISO + ISO2SW IPG clock cycles */
-	ndelay((sw + sw2iso) * 1000 / 66);
-
-	/* Disable reset clocks for all devices in the PU domain */
-	for (i = 0; i < pu->num_clks; i++)
-		clk_disable_unprepare(pu->clk[i]);
-
-	return 0;
-}
-
-static struct generic_pm_domain imx6q_arm_domain = {
-	.name = "ARM",
-};
-
-static struct pu_domain imx6q_pu_domain = {
-	.base = {
-		.name = "PU",
-		.power_off = imx6q_pm_pu_power_off,
-		.power_on = imx6q_pm_pu_power_on,
-	},
-};
-
-static struct generic_pm_domain imx6sl_display_domain = {
-	.name = "DISPLAY",
-};
-
-static struct generic_pm_domain *imx_gpc_domains[] = {
-	&imx6q_arm_domain,
-	&imx6q_pu_domain.base,
-	&imx6sl_display_domain,
-};
-
-static struct genpd_onecell_data imx_gpc_onecell_data = {
-	.domains = imx_gpc_domains,
-	.num_domains = ARRAY_SIZE(imx_gpc_domains),
-};
-
-static int imx_gpc_genpd_init(struct device *dev, struct regulator *pu_reg)
-{
-	struct clk *clk;
-	int i, ret;
-
-	imx6q_pu_domain.reg = pu_reg;
-
-	for (i = 0; ; i++) {
-		clk = of_clk_get(dev->of_node, i);
-		if (IS_ERR(clk))
-			break;
-		if (i >= GPC_CLK_MAX) {
-			dev_err(dev, "more than %d clocks\n", GPC_CLK_MAX);
-			goto clk_err;
-		}
-		imx6q_pu_domain.clk[i] = clk;
-	}
-	imx6q_pu_domain.num_clks = i;
-
-	/* Enable power always in case bootloader disabled it. */
-	imx6q_pm_pu_power_on(&imx6q_pu_domain.base);
-
-	if (!IS_ENABLED(CONFIG_PM_GENERIC_DOMAINS))
-		return 0;
-
-	imx6q_pu_domain.base.states = devm_kzalloc(dev,
-					sizeof(*imx6q_pu_domain.base.states),
-					GFP_KERNEL);
-	if (!imx6q_pu_domain.base.states)
-		return -ENOMEM;
-
-	imx6q_pu_domain.base.states[0].power_off_latency_ns = 25000;
-	imx6q_pu_domain.base.states[0].power_on_latency_ns = 2000000;
-	imx6q_pu_domain.base.state_count = 1;
-
-	for (i = 0; i < ARRAY_SIZE(imx_gpc_domains); i++)
-		pm_genpd_init(imx_gpc_domains[i], NULL, false);
-
-	ret =  of_genpd_add_provider_onecell(dev->of_node,
-					     &imx_gpc_onecell_data);
-	if (ret)
-		goto power_off;
-
-	return 0;
-
-power_off:
-	imx6q_pm_pu_power_off(&imx6q_pu_domain.base);
-clk_err:
-	while (i--)
-		clk_put(imx6q_pu_domain.clk[i]);
-	imx6q_pu_domain.reg = NULL;
-	return -EINVAL;
-}
-
-static int imx_gpc_probe(struct platform_device *pdev)
-{
-	struct regulator *pu_reg;
-	int ret;
-
-	/* bail out if DT too old and doesn't provide the necessary info */
-	if (!of_property_read_bool(pdev->dev.of_node, "#power-domain-cells"))
-		return 0;
-
-	pu_reg = devm_regulator_get_optional(&pdev->dev, "pu");
-	if (PTR_ERR(pu_reg) == -ENODEV)
-		pu_reg = NULL;
-	if (IS_ERR(pu_reg)) {
-		ret = PTR_ERR(pu_reg);
-		dev_err(&pdev->dev, "failed to get pu regulator: %d\n", ret);
-		return ret;
-	}
-
-	return imx_gpc_genpd_init(&pdev->dev, pu_reg);
-}
-
-static const struct of_device_id imx_gpc_dt_ids[] = {
-	{ .compatible = "fsl,imx6q-gpc" },
-	{ .compatible = "fsl,imx6sl-gpc" },
-	{ }
-};
-
-static struct platform_driver imx_gpc_driver = {
-	.driver = {
-		.name = "imx-gpc",
-		.of_match_table = imx_gpc_dt_ids,
-	},
-	.probe = imx_gpc_probe,
-};
-
-static int __init imx_pgc_init(void)
-{
-	return platform_driver_register(&imx_gpc_driver);
-}
-subsys_initcall(imx_pgc_init);

commit cc773e75a0e21deca6f7e6621a1a7bbc3ad92b88
Merge: 69973b830859 598da548ef78
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Dec 12 20:43:19 2016 +0100

    Merge branch 'pm-domains'
    
    * pm-domains:
      PM / Domains: Fix compatible for domain idle state
      PM / Domains: Do not print PM domain add error message if EPROBE_DEFER
      PM / Domains: Fix a warning message
      PM / Domains: check for negative return from of_count_phandle_with_args()
      PM / doc: Update device documentation for devices in IRQ-safe PM domains
      PM / Domains: Support IRQ safe PM domains
      PM / Domains: Abstract genpd locking
      dt/bindings / PM/Domains: Update binding for PM domain idle states
      PM / Domains: Save the fwnode in genpd_power_state
      PM / Domains: Allow domain power states to be read from DT
      PM / Domains: Add residency property to genpd states
      PM / Domains: Make genpd state allocation dynamic
    
    Conflicts:
            arch/arm/mach-imx/gpc.c

commit f9d1f7a7ad919c93dfb708aae6e19d33c5437443
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Sat Oct 22 10:20:56 2016 -0200

    ARM: imx: gpc: Fix the imx_gpc_genpd_init() error path
    
    If of_genpd_add_provider_onecell() fails the following kernel crash is
    observed on a kernel built with multi_v7_defconfig:
    
    [    1.739301] [00000040] *pgd=00000000
    [    1.739310] Internal error: Oops: 5 [#1] SMP ARM
    [    1.739319] Modules linked in:
    [    1.739328] CPU: 1 PID: 95 Comm: kworker/1:4 Not tainted 4.8.0-11897-g6b5e09a #1
    [    1.739331] Hardware name: Freescale i.MX6 Quad/DualLite (Device Tree)
    [    1.739352] Workqueue: pm genpd_power_off_work_fn
    [    1.739356] task: ee63d400 task.stack: ee70a000
    [    1.739365] PC is at mutex_lock+0xc/0x4c
    [    1.739374] LR is at regulator_disable+0x2c/0x60
    [    1.739379] pc : [<c0bc0da0>]    lr : [<c06e4b10>]    psr: 60000013
    [    1.739379] sp : ee70beb0  ip : 10624dd3  fp : ee6e6280
    [    1.739382] r10: eefb0900  r9 : 00000000  r8 : c1309918
    [    1.739385] r7 : 00000000  r6 : 00000040  r5 : 00000000  r4 : 00000040
    [    1.739390] r3 : 0000004c  r2 : 7fffd540  r1 : 000001e4  r0 : 00000040
    
    Instead of returning of_genpd_add_provider_onecell() directly,
    we should check its return value and in the case of error we
    should unwind the previously taken actions, which in these case are:
    - Call imx6q_pm_pu_power_off()
    - Set imx6q_pu_domain.reg back to NULL
    
    Setting imx6q_pu_domain.reg to NULL in the error case is important
    as it will prevent further operations in the pu_reg regulator.
    
    This kernel crash is not observed with imx_v6_v7_defconfig because
    it selects GPU and VPU drivers, which are consumers of the GPC block
    and thus change the refcount of the pu_reg regulator.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index d0463e9d8a08..b54db47f6f32 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -408,7 +408,7 @@ static struct genpd_onecell_data imx_gpc_onecell_data = {
 static int imx_gpc_genpd_init(struct device *dev, struct regulator *pu_reg)
 {
 	struct clk *clk;
-	int i;
+	int i, ret;
 
 	imx6q_pu_domain.reg = pu_reg;
 
@@ -432,12 +432,20 @@ static int imx_gpc_genpd_init(struct device *dev, struct regulator *pu_reg)
 
 	for (i = 0; i < ARRAY_SIZE(imx_gpc_domains); i++)
 		pm_genpd_init(imx_gpc_domains[i], NULL, false);
-	return of_genpd_add_provider_onecell(dev->of_node,
+
+	ret =  of_genpd_add_provider_onecell(dev->of_node,
 					     &imx_gpc_onecell_data);
+	if (ret)
+		goto power_off;
+
+	return 0;
 
+power_off:
+	imx6q_pm_pu_power_off(&imx6q_pu_domain.base);
 clk_err:
 	while (i--)
 		clk_put(imx6q_pu_domain.clk[i]);
+	imx6q_pu_domain.reg = NULL;
 	return -EINVAL;
 }
 

commit eef0b282bb586259d35548851cf6a4ce847bb804
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Sat Oct 22 10:20:55 2016 -0200

    ARM: imx: gpc: Initialize all power domains
    
    Since commit 0159ec670763dd ("PM / Domains: Verify the PM domain is present
    when adding a provider") the following regression is observed on imx6:
    
    imx-gpc: probe of 20dc000.gpc failed with error -22
    
    The gpc probe fails because of_genpd_add_provider_onecell() now checks
    if all the domains are initialized via pm_genpd_present() function
    and it fails because not all the power domains are initialized.
    
    In order to fix this error, initialize all the power domains from
    imx_gpc_domains[], not only the imx6q_pu_domain.base one.
    
    Reported-by: Olof's autobooter <build@lixom.net>
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 0df062d8b2c9..d0463e9d8a08 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -430,7 +430,8 @@ static int imx_gpc_genpd_init(struct device *dev, struct regulator *pu_reg)
 	if (!IS_ENABLED(CONFIG_PM_GENERIC_DOMAINS))
 		return 0;
 
-	pm_genpd_init(&imx6q_pu_domain.base, NULL, false);
+	for (i = 0; i < ARRAY_SIZE(imx_gpc_domains); i++)
+		pm_genpd_init(imx_gpc_domains[i], NULL, false);
 	return of_genpd_add_provider_onecell(dev->of_node,
 					     &imx_gpc_onecell_data);
 

commit 59d65b73a23cee48e6f3e44686f199d79b7ee854
Author: Lina Iyer <lina.iyer@linaro.org>
Date:   Fri Oct 14 10:47:49 2016 -0700

    PM / Domains: Make genpd state allocation dynamic
    
    Allow PM Domain states to be defined dynamically by the drivers. This
    removes the limitation on the maximum number of states possible for a
    domain.
    
    Suggested-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Lina Iyer <lina.iyer@linaro.org>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Kevin Hilman <khilman@baylibre.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 0df062d8b2c9..57a410bbb6a2 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -380,13 +380,6 @@ static struct pu_domain imx6q_pu_domain = {
 		.name = "PU",
 		.power_off = imx6q_pm_pu_power_off,
 		.power_on = imx6q_pm_pu_power_on,
-		.states = {
-			[0] = {
-				.power_off_latency_ns = 25000,
-				.power_on_latency_ns = 2000000,
-			},
-		},
-		.state_count = 1,
 	},
 };
 
@@ -430,6 +423,16 @@ static int imx_gpc_genpd_init(struct device *dev, struct regulator *pu_reg)
 	if (!IS_ENABLED(CONFIG_PM_GENERIC_DOMAINS))
 		return 0;
 
+	imx6q_pu_domain.base.states = devm_kzalloc(dev,
+					sizeof(*imx6q_pu_domain.base.states),
+					GFP_KERNEL);
+	if (!imx6q_pu_domain.base.states)
+		return -ENOMEM;
+
+	imx6q_pu_domain.base.states[0].power_off_latency_ns = 25000;
+	imx6q_pu_domain.base.states[0].power_on_latency_ns = 2000000;
+	imx6q_pu_domain.base.state_count = 1;
+
 	pm_genpd_init(&imx6q_pu_domain.base, NULL, false);
 	return of_genpd_add_provider_onecell(dev->of_node,
 					     &imx_gpc_onecell_data);

commit 255c0397bc402e3fcc8833c214f49b2108f04d1a
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Tue Aug 9 16:18:52 2016 +0200

    ARM: imx6: mark GPC node as not populated after irq init to probe pm domain driver
    
    Since IRQCHIP_DECLARE now flags the GPC node as already populated, the
    GPC power domain driver is never probed unless we clear the flag again.
    
    Fixes: 15cc2ed6dcf9 ("of/irq: Mark initialised interrupt controllers as populated")
    Suggested-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Cc: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index fd8720532471..0df062d8b2c9 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -271,6 +271,12 @@ static int __init imx_gpc_init(struct device_node *node,
 	for (i = 0; i < IMR_NUM; i++)
 		writel_relaxed(~0, gpc_base + GPC_IMR1 + i * 4);
 
+	/*
+	 * Clear the OF_POPULATED flag set in of_irq_init so that
+	 * later the GPC power domain driver will not be skipped.
+	 */
+	of_node_clear_flag(node, OF_POPULATED);
+
 	return 0;
 }
 IRQCHIP_DECLARE(imx_gpc, "fsl,imx6q-gpc", imx_gpc_init);

commit eaa2d73ef9985f9e0fee7c3f04268c729100498d
Author: Axel Haslam <ahaslam+renesas@baylibre.com>
Date:   Mon Feb 15 11:10:52 2016 +0100

    ARM: imx6: pm: declare pm domain latency on power_state struct
    
    The generic_pm_domain structure uses an array of latencies to be able to
    declare multiple intermediate states.
    
    Declare a single "OFF" state with the default latencies So that the
    power_off_latency_ns and power_on_latency_ns fields of generic_pm_domain
    structure can be eventually removed.
    
    [ Lina: pm_genpd_init() argument changev ]
    Signed-off-by: Lina Iyer <lina.iyer@linaro.org>
    Signed-off-by: Axel Haslam <ahaslam+renesas@baylibre.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index cfc696b972f3..fd8720532471 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -374,8 +374,13 @@ static struct pu_domain imx6q_pu_domain = {
 		.name = "PU",
 		.power_off = imx6q_pm_pu_power_off,
 		.power_on = imx6q_pm_pu_power_on,
-		.power_off_latency_ns = 25000,
-		.power_on_latency_ns = 2000000,
+		.states = {
+			[0] = {
+				.power_off_latency_ns = 25000,
+				.power_on_latency_ns = 2000000,
+			},
+		},
+		.state_count = 1,
 	},
 };
 

commit 4699ccbf8cf2f962031b88de7851f610030e5c17
Author: Anson Huang <b20788@freescale.com>
Date:   Tue Oct 20 18:44:19 2015 +0800

    ARM: imx: add platform irq type setting in gpc
    
    GPC irq domain is a child domain of GIC, now all of platform irqs
    are inside GPC domain, during the module populate, all devices irq
    should have correct type setting in GIC, however, there is no
    .irq_set_type callback setting in GPC, so the irq_set_type will be
    skipped and cause all irqs' type in /proc/interrupt are "edge" which
    mismatch with irq type setting in dtb file. Since GPC has no irq
    type setting, so just tell kernel to use irq_chip_set_type_parent.
    
    Signed-off-by: Anson Huang <Anson.Huang@freescale.com>
    Cc: <stable@vger.kernel.org> # 4.1+
    Reviewed-by: Lucas Stach <l.stach@pengutronix.de>
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 8e7976a4c3e7..cfc696b972f3 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -177,6 +177,7 @@ static struct irq_chip imx_gpc_chip = {
 	.irq_unmask		= imx_gpc_irq_unmask,
 	.irq_retrigger		= irq_chip_retrigger_hierarchy,
 	.irq_set_wake		= imx_gpc_irq_set_wake,
+	.irq_set_type           = irq_chip_set_type_parent,
 #ifdef CONFIG_SMP
 	.irq_set_affinity	= irq_chip_set_affinity_parent,
 #endif

commit a5e1d715a8d0696961d99d31d869aa522f1cad5a
Merge: 64fd8c8a0ff4 d3dc3df6330e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 10 14:48:36 2015 -0800

    Merge tag 'armsoc-cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC cleanups from Olof Johansson:
     "Again we have a sizable (but not huge) cleanup branch with a net delta
      of about -3k lines.
    
      Main contents here is:
    
       - A bunch of development/cleanup of a few PXA boards
       - Removal of bockw platforms on shmobile, since the platform has now
         gone completely multiplatform.  Whee!
       - move of the 32kHz timer on OMAP to a proper timesource
       - Misc cleanup of older OMAP material (incl removal of one board
         file)
       - Switch over to new common PWM lookup support for several platforms
    
      There's also a handful of other cleanups across the tree, but the
      above are the major pieces"
    
    * tag 'armsoc-cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (103 commits)
      ARM: OMAP3: hwmod data: Remove legacy mailbox data and addrs
      ARM: DRA7: hwmod data: Remove spinlock hwmod addrs
      ARM: OMAP4: hwmod data: Remove spinlock hwmod addrs
      ARM: DRA7/AM335x/AM437x: hwmod: Remove gpmc address space from hwmod data
      ARM: Remove __ref on hotplug cpu die path
      ARM: Remove open-coded version of IRQCHIP_DECLARE
      arm: omap2: board-generic: use omap4_local_timer_init for AM437x
      ARM: DRA7/AM335x/AM437x: hwmod: Remove elm address space from hwmod data
      ARM: OMAP: Remove duplicated operand in OR operation
      clocksource: ti-32k: make it depend on GENERIC_CLOCKSOURCE
      ARM: pxa: remove incorrect __init annotation on pxa27x_set_pwrmode
      ARM: pxa: raumfeld: make some variables static
      ARM: OMAP: Change all cpu_is_* occurences to soc_is_* for id.c
      ARM: OMAP2+: Rename cpu_is macros to soc_is
      arm: omap2: timer: limit hwmod usage to non-DT boots
      arm: omap2+: select 32k clocksource driver
      clocksource: add TI 32.768 Hz counter driver
      arm: omap2: timer: rename omap_sync32k_timer_init()
      arm: omap2: timer: always call clocksource_of_init() when DT
      arm: omap2: timer: move realtime_counter_init() around
      ...

commit 0cc09e85186082d414a89f85ec1b7ff588547f10
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Oct 16 15:21:10 2015 +0100

    ARM: Remove open-coded version of IRQCHIP_DECLARE
    
    Now that the IRQCHIP_DECLARE macro has been moved to linux/irqchip.h,
    it becomes possible to cleanup the open-coded versions of the same
    macro that have been added to some private irqchips implementations.
    
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Acked-by: Kukjin Kim <kgene@kernel.org>
    Acked-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 8c4467fad837..f2783b087d33 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -14,6 +14,7 @@
 #include <linux/delay.h>
 #include <linux/io.h>
 #include <linux/irq.h>
+#include <linux/irqchip.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
@@ -268,12 +269,7 @@ static int __init imx_gpc_init(struct device_node *node,
 
 	return 0;
 }
-
-/*
- * We cannot use the IRQCHIP_DECLARE macro that lives in
- * drivers/irqchip, so we're forced to roll our own. Not very nice.
- */
-OF_DECLARE_2(irqchip, imx_gpc, "fsl,imx6q-gpc", imx_gpc_init);
+IRQCHIP_DECLARE(imx_gpc, "fsl,imx6q-gpc", imx_gpc_init);
 
 void __init imx_gpc_check_dt(void)
 {

commit f833f57ff25450b7161798dceaf8575a48d80249
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Oct 13 12:51:33 2015 +0100

    irqchip: Convert all alloc/xlate users from of_node to fwnode
    
    Since we now have a generic data structure to express an
    interrupt specifier, convert all hierarchical irqchips that
    are OF based to use a fwnode_handle as part of their alloc
    and xlate (which becomes translate) callbacks.
    
    As most of these drivers have dependencies (they exchange IRQ
    specifiers), change them all in a single, massive patch...
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-and-tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Graeme Gregory <graeme@xora.org.uk>
    Cc: Jake Oshins <jakeo@microsoft.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Link: http://lkml.kernel.org/r/1444737105-31573-6-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 7b32255028fe..10bf7159b27d 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -181,40 +181,42 @@ static struct irq_chip imx_gpc_chip = {
 #endif
 };
 
-static int imx_gpc_domain_xlate(struct irq_domain *domain,
-				struct device_node *controller,
-				const u32 *intspec,
-				unsigned int intsize,
-				unsigned long *out_hwirq,
-				unsigned int *out_type)
+static int imx_gpc_domain_translate(struct irq_domain *d,
+				    struct irq_fwspec *fwspec,
+				    unsigned long *hwirq,
+				    unsigned int *type)
 {
-	if (irq_domain_get_of_node(domain) != controller)
-		return -EINVAL;	/* Shouldn't happen, really... */
-	if (intsize != 3)
-		return -EINVAL;	/* Not GIC compliant */
-	if (intspec[0] != 0)
-		return -EINVAL;	/* No PPI should point to this domain */
+	if (is_of_node(fwspec->fwnode)) {
+		if (fwspec->param_count != 3)
+			return -EINVAL;
 
-	*out_hwirq = intspec[1];
-	*out_type = intspec[2];
-	return 0;
+		/* No PPI should point to this domain */
+		if (fwspec->param[0] != 0)
+			return -EINVAL;
+
+		*hwirq = fwspec->param[1];
+		*type = fwspec->param[2];
+		return 0;
+	}
+
+	return -EINVAL;
 }
 
 static int imx_gpc_domain_alloc(struct irq_domain *domain,
 				  unsigned int irq,
 				  unsigned int nr_irqs, void *data)
 {
-	struct of_phandle_args *args = data;
-	struct of_phandle_args parent_args;
+	struct irq_fwspec *fwspec = data;
+	struct irq_fwspec parent_fwspec;
 	irq_hw_number_t hwirq;
 	int i;
 
-	if (args->args_count != 3)
+	if (fwspec->param_count != 3)
 		return -EINVAL;	/* Not GIC compliant */
-	if (args->args[0] != 0)
+	if (fwspec->param[0] != 0)
 		return -EINVAL;	/* No PPI should point to this domain */
 
-	hwirq = args->args[1];
+	hwirq = fwspec->param[1];
 	if (hwirq >= GPC_MAX_IRQS)
 		return -EINVAL;	/* Can't deal with this */
 
@@ -222,15 +224,16 @@ static int imx_gpc_domain_alloc(struct irq_domain *domain,
 		irq_domain_set_hwirq_and_chip(domain, irq + i, hwirq + i,
 					      &imx_gpc_chip, NULL);
 
-	parent_args = *args;
-	parent_args.np = irq_domain_get_of_node(domain->parent);
-	return irq_domain_alloc_irqs_parent(domain, irq, nr_irqs, &parent_args);
+	parent_fwspec = *fwspec;
+	parent_fwspec.fwnode = domain->parent->fwnode;
+	return irq_domain_alloc_irqs_parent(domain, irq, nr_irqs,
+					    &parent_fwspec);
 }
 
 static const struct irq_domain_ops imx_gpc_domain_ops = {
-	.xlate	= imx_gpc_domain_xlate,
-	.alloc	= imx_gpc_domain_alloc,
-	.free	= irq_domain_free_irqs_common,
+	.translate	= imx_gpc_domain_translate,
+	.alloc		= imx_gpc_domain_alloc,
+	.free		= irq_domain_free_irqs_common,
 };
 
 static int __init imx_gpc_init(struct device_node *node,

commit 5d4c9bc7767bc86eb9a0e66df783e3fbada7dc97
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Oct 13 12:51:29 2015 +0100

    irqdomain: Use irq_domain_get_of_node() instead of direct field access
    
    The struct irq_domain contains a "struct device_node *" field
    (of_node) that is almost the only link between the irqdomain
    and the device tree infrastructure.
    
    In order to prepare for the removal of that field, convert all
    users to use irq_domain_get_of_node() instead.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-and-tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Cc: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Cc: Graeme Gregory <graeme@xora.org.uk>
    Cc: Jake Oshins <jakeo@microsoft.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Link: http://lkml.kernel.org/r/1444737105-31573-2-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 8c4467fad837..7b32255028fe 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -188,7 +188,7 @@ static int imx_gpc_domain_xlate(struct irq_domain *domain,
 				unsigned long *out_hwirq,
 				unsigned int *out_type)
 {
-	if (domain->of_node != controller)
+	if (irq_domain_get_of_node(domain) != controller)
 		return -EINVAL;	/* Shouldn't happen, really... */
 	if (intsize != 3)
 		return -EINVAL;	/* Not GIC compliant */
@@ -223,7 +223,7 @@ static int imx_gpc_domain_alloc(struct irq_domain *domain,
 					      &imx_gpc_chip, NULL);
 
 	parent_args = *args;
-	parent_args.np = domain->parent->of_node;
+	parent_args.np = irq_domain_get_of_node(domain->parent);
 	return irq_domain_alloc_irqs_parent(domain, irq, nr_irqs, &parent_args);
 }
 

commit d438462c20a300139c2e5e65b96cadaa21b58d9a
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Tue Jun 30 14:48:24 2015 +0200

    ARM: imx6: gpc: always enable PU domain if CONFIG_PM is not set
    
    If CONFIG_PM is not set the PU power domain needs to be enabled always,
    otherwise there are two failure scenarios which will hang the system if
    one of the devices in the PU domain is accessed.
    
    1. New DTs (4.1+) drop the "always-on" property from the PU regulator, so
    if it isn't properly enabled by the GPC code it will be disabled at the
    end of boot.
    
    2. If the bootloader already disabled the PU domain the GPC explicitly
    needs to enable it again, even if the kernel doesn't do any power
    management. This is a bit hypothetical, as it requires to boot a
    mainline kernel on a downstream bootloader, as no mainline bootloader
    disables the PM domains.
    
    Cc: <stable@vger.kernel.org> # 4.1
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 80bad29d609a..8c4467fad837 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -291,8 +291,6 @@ void __init imx_gpc_check_dt(void)
 	}
 }
 
-#ifdef CONFIG_PM_GENERIC_DOMAINS
-
 static void _imx6q_pm_pu_power_off(struct generic_pm_domain *genpd)
 {
 	int iso, iso2sw;
@@ -399,7 +397,6 @@ static struct genpd_onecell_data imx_gpc_onecell_data = {
 static int imx_gpc_genpd_init(struct device *dev, struct regulator *pu_reg)
 {
 	struct clk *clk;
-	bool is_off;
 	int i;
 
 	imx6q_pu_domain.reg = pu_reg;
@@ -416,18 +413,13 @@ static int imx_gpc_genpd_init(struct device *dev, struct regulator *pu_reg)
 	}
 	imx6q_pu_domain.num_clks = i;
 
-	is_off = IS_ENABLED(CONFIG_PM);
-	if (is_off) {
-		_imx6q_pm_pu_power_off(&imx6q_pu_domain.base);
-	} else {
-		/*
-		 * Enable power if compiled without CONFIG_PM in case the
-		 * bootloader disabled it.
-		 */
-		imx6q_pm_pu_power_on(&imx6q_pu_domain.base);
-	}
+	/* Enable power always in case bootloader disabled it. */
+	imx6q_pm_pu_power_on(&imx6q_pu_domain.base);
+
+	if (!IS_ENABLED(CONFIG_PM_GENERIC_DOMAINS))
+		return 0;
 
-	pm_genpd_init(&imx6q_pu_domain.base, NULL, is_off);
+	pm_genpd_init(&imx6q_pu_domain.base, NULL, false);
 	return of_genpd_add_provider_onecell(dev->of_node,
 					     &imx_gpc_onecell_data);
 
@@ -437,13 +429,6 @@ static int imx_gpc_genpd_init(struct device *dev, struct regulator *pu_reg)
 	return -EINVAL;
 }
 
-#else
-static inline int imx_gpc_genpd_init(struct device *dev, struct regulator *reg)
-{
-	return 0;
-}
-#endif /* CONFIG_PM_GENERIC_DOMAINS */
-
 static int imx_gpc_probe(struct platform_device *pdev)
 {
 	struct regulator *pu_reg;

commit 4aa705b18bf17c4ff33ff7bbcd3f0c596443fa81
Merge: c11d71621891 2879e43f0912
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 26 11:34:35 2015 -0700

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform support updates from Kevin Hilman:
     "Our SoC branch usually contains expanded support for new SoCs and
      other core platform code.  Some highlights from this round:
    
       - sunxi: SMP support for A23 SoC
       - socpga: big-endian support
       - pxa: conversion to common clock framework
       - bcm: SMP support for BCM63138
       - imx: support new I.MX7D SoC
       - zte: basic support for ZX296702 SoC"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (134 commits)
      ARM: zx: Add basic defconfig support for ZX296702
      ARM: dts: zx: add an initial zx296702 dts and doc
      clk: zx: add clock support to zx296702
      dt-bindings: Add #defines for ZTE ZX296702 clocks
      ARM: socfpga: fix build error due to secondary_startup
      MAINTAINERS: ARM64: EXYNOS: Extend entry for ARM64 DTS
      ARM: ep93xx: simone: support for SPI-based MMC/SD cards
      MAINTAINERS: update Shawn's email to use kernel.org one
      ARM: socfpga: support suspend to ram
      ARM: socfpga: add CPU_METHOD_OF_DECLARE for Arria 10
      ARM: socfpga: use CPU_METHOD_OF_DECLARE for socfpga_cyclone5
      ARM: EXYNOS: register power domain driver from core_initcall
      ARM: EXYNOS: use PS_HOLD based poweroff for all supported SoCs
      ARM: SAMSUNG: Constify platform_device_id
      ARM: EXYNOS: Constify irq_domain_ops
      ARM: EXYNOS: add coupled cpuidle support for Exynos3250
      ARM: EXYNOS: add exynos_get_boot_addr() helper
      ARM: EXYNOS: add exynos_set_boot_addr() helper
      ARM: EXYNOS: make exynos_core_restart() less verbose
      ARM: EXYNOS: fix exynos_boot_secondary() return value on timeout
      ...

commit c11d716218910c3aa2bac1bb641e6086ad649555
Merge: 47a469421d79 e75ea4569d6d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 26 11:08:27 2015 -0700

    Merge tag 'armsoc-cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC cleanups from Kevin Hilman:
     "A relatively small setup of cleanups this time around, and similar to
      last time the bulk of it is removal of legacy board support:
    
       - OMAP: removal of legacy (non-DT) booting for several platforms
    
       - i.MX: remove some legacy board files"
    
    * tag 'armsoc-cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (36 commits)
      ARM: fix EFM32 build breakage caused by cpu_resume_arm
      ARM: 8389/1: Add cpu_resume_arm() for firmwares that resume in ARM state
      ARM: v7 setup function should invalidate L1 cache
      mach-omap2: Remove use of deprecated marco, PTR_RET in devices.c
      ARM: OMAP2+: Remove calls to deprecacted marco,PTR_RET in the files,fb.c and pmu.c
      ARM: OMAP2+: Constify irq_domain_ops
      ARM: OMAP2+: use symbolic defines for console loglevels instead of numbers
      ARM: at91: remove useless Makefile.boot
      ARM: at91: remove at91rm9200_sdramc.h
      ARM: at91: remove mach/at91_ramc.h and mach/at91rm9200_mc.h
      ARM: at91/pm: use the atmel-mc syscon defines
      pcmcia: at91_cf: Use syscon to configure the MC/smc
      ARM: at91: declare the at91rm9200 memory controller as a syscon
      mfd: syscon: Add Atmel MC (Memory Controller) registers definition
      ARM: at91: drop sam9_smc.c
      ata: at91: use syscon to configure the smc
      ARM: ux500: delete static resource defines
      ARM: ux500: rename ux500_map_io
      ARM: ux500: look up PRCMU resource from DT
      ARM: ux500: kill off L2CC static map
      ...

commit 9b589a83cf1b2bb89b6e4af7ffafe5cda33e756c
Author: Krzysztof Kozlowski <k.kozlowski.k@gmail.com>
Date:   Mon Apr 27 21:51:39 2015 +0900

    ARM: imx: Constify irq_domain_ops
    
    The irq_domain_ops are not modified by the driver and the irqdomain core
    code accepts pointer to a const data.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski.k@gmail.com>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 4d60005e9277..9051dc02dc79 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -227,7 +227,7 @@ static int imx_gpc_domain_alloc(struct irq_domain *domain,
 	return irq_domain_alloc_irqs_parent(domain, irq, nr_irqs, &parent_args);
 }
 
-static struct irq_domain_ops imx_gpc_domain_ops = {
+static const struct irq_domain_ops imx_gpc_domain_ops = {
 	.xlate	= imx_gpc_domain_xlate,
 	.alloc	= imx_gpc_domain_alloc,
 	.free	= irq_domain_free_irqs_common,

commit b17c70cd9211e9bbcd77a489f9c60f3d1bd4c392
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Wed May 27 10:10:26 2015 +0200

    ARM: imx6: gpc: don't register power domain if DT data is missing
    
    If the devicetree is too old and does not provide the regulator and clocks
    for the power domain, we need to avoid registering the power domain.
    Otherwise runtime PM will try to control the domain, which will lead to
    machine hangs without the proper DT configuration data.
    
    This restores functionality to the kernel 4.0 level if an old DT is
    detected, where the power domain is constantly powered on.
    
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index bbf015056221..6d0893a3828e 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -449,6 +449,10 @@ static int imx_gpc_probe(struct platform_device *pdev)
 	struct regulator *pu_reg;
 	int ret;
 
+	/* bail out if DT too old and doesn't provide the necessary info */
+	if (!of_property_read_bool(pdev->dev.of_node, "#power-domain-cells"))
+		return 0;
+
 	pu_reg = devm_regulator_get_optional(&pdev->dev, "pu");
 	if (PTR_ERR(pu_reg) == -ENODEV)
 		pu_reg = NULL;

commit 634a603760c26d163ff92751d91ac7b859e879c4
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Tue May 26 18:43:36 2015 +0200

    ARM: imx6: allow booting with old DT
    
    The GPC rewrite to IRQ domains has been on the premise that it may break
    suspend/resume for new kernels on old DT, but otherwise keep things working
    from a user perspective. This was an accepted compromise to be able to move
    the GIC cleanup forward.
    
    What actually happened was that booting a new kernel on an old DT crashes
    before even the console is up, so the user does not even see the warning
    that the DT is too old. The warning message suggests that this has been
    known before, which is clearly unacceptable.
    
    Fix the early crash by mapping the GPC memory space if the IRQ controller
    doesn't claim it. This keeps at least CPUidle and the needed CPU wakeup
    workarounds working. With this fixed the system is able to boot up
    properly minus the expected suspend/resume breakage.
    
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 4d60005e9277..bbf015056221 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -280,9 +280,15 @@ void __init imx_gpc_check_dt(void)
 	struct device_node *np;
 
 	np = of_find_compatible_node(NULL, NULL, "fsl,imx6q-gpc");
-	if (WARN_ON(!np ||
-		    !of_find_property(np, "interrupt-controller", NULL)))
-		pr_warn("Outdated DT detected, system is about to crash!!!\n");
+	if (WARN_ON(!np))
+		return;
+
+	if (WARN_ON(!of_find_property(np, "interrupt-controller", NULL))) {
+		pr_warn("Outdated DT detected, suspend/resume will NOT work\n");
+
+		/* map GPC, so that at least CPUidle and WARs keep working */
+		gpc_base = of_iomap(np, 0);
+	}
 }
 
 #ifdef CONFIG_PM_GENERIC_DOMAINS

commit cb2e1a234c163d429712c0fa8eef8ab01499b738
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Sat May 9 08:51:23 2015 -0300

    ARM: imx: gpc: Remove .owner field
    
    This platform_driver does not need to set an owner as it will be
    populated by the driver core.
    
    The semantic patch that makes this change is available
    in scripts/coccinelle/api/platform_no_drv_owner.cocci.
    
    More information about semantic patching is available at
    http://coccinelle.lip6.fr/
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 4d60005e9277..c478a20c898e 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -464,7 +464,6 @@ static const struct of_device_id imx_gpc_dt_ids[] = {
 static struct platform_driver imx_gpc_driver = {
 	.driver = {
 		.name = "imx-gpc",
-		.owner = THIS_MODULE,
 		.of_match_table = imx_gpc_dt_ids,
 	},
 	.probe = imx_gpc_probe,

commit 14517564795a5cd22e2da3119037f9883383fae9
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Mar 13 16:05:37 2015 +0000

    ARM: imx6: Warn when an old DT is detected
    
    Now that the GPC has been converted to be a full blown irqchip
    (and not a mole on the side of the GIC), booting a new kernel
    with an old DT is likely to result in a rough ride for the user.
    
    This patch makes sure such a situation is promptly detected and
    the user made aware that a DT update is in order.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 5d32e35fbe47..4d60005e9277 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -275,6 +275,16 @@ static int __init imx_gpc_init(struct device_node *node,
  */
 OF_DECLARE_2(irqchip, imx_gpc, "fsl,imx6q-gpc", imx_gpc_init);
 
+void __init imx_gpc_check_dt(void)
+{
+	struct device_node *np;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,imx6q-gpc");
+	if (WARN_ON(!np ||
+		    !of_find_property(np, "interrupt-controller", NULL)))
+		pr_warn("Outdated DT detected, system is about to crash!!!\n");
+}
+
 #ifdef CONFIG_PM_GENERIC_DOMAINS
 
 static void _imx6q_pm_pu_power_off(struct generic_pm_domain *genpd)

commit e33b67523f556aa7ddb09f1c7fa4de5c080670c9
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Thu Mar 12 08:40:37 2015 +0000

    ARM: imx6: Allow GPC interrupts affinity to be changed
    
    While converting the GPC code to a stacked irqchip, we lost the
    possibility to change the CPU affinity of an interrupt routed
    through the GPC.
    
    This patch restore the expected behaviour by forwarding the
    affinity setup to the underlying irqchip (GIC).
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 6f1f77ed0c71..5d32e35fbe47 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -170,12 +170,15 @@ static void imx_gpc_irq_mask(struct irq_data *d)
 }
 
 static struct irq_chip imx_gpc_chip = {
-	.name		= "GPC",
-	.irq_eoi	= irq_chip_eoi_parent,
-	.irq_mask	= imx_gpc_irq_mask,
-	.irq_unmask	= imx_gpc_irq_unmask,
-	.irq_retrigger	= irq_chip_retrigger_hierarchy,
-	.irq_set_wake	= imx_gpc_irq_set_wake,
+	.name			= "GPC",
+	.irq_eoi		= irq_chip_eoi_parent,
+	.irq_mask		= imx_gpc_irq_mask,
+	.irq_unmask		= imx_gpc_irq_unmask,
+	.irq_retrigger		= irq_chip_retrigger_hierarchy,
+	.irq_set_wake		= imx_gpc_irq_set_wake,
+#ifdef CONFIG_SMP
+	.irq_set_affinity	= irq_chip_set_affinity_parent,
+#endif
 };
 
 static int imx_gpc_domain_xlate(struct irq_domain *domain,

commit b923ff6af0d5a806a3996dac6d4393cd9792d0f4
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Mon Feb 23 17:45:18 2015 +0000

    ARM: imx6: convert GPC to stacked domains
    
    IMX6 has been (ab)using the gic_arch_extn to provide
    wakeup from suspend, and it makes a lot of sense to convert
    this code to use stacked domains instead.
    
    This patch does just this, updating the DT files to actually
    reflect what the HW provides.
    
    BIG FAT WARNING: because the DTs were so far lying by not
    exposing the fact that the GPC block is actually the first
    interrupt controller in the chain, kernels with this patch
    applied wont have any suspend-resume facility when booted
    with old DTs, and old kernels with updated DTs won't even boot.
    
    Tested-by: Stefan Agner <stefan@agner.ch>
    Acked-by: Stefan Agner <stefan@agner.ch>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 029f59ce2712..6f1f77ed0c71 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -36,6 +36,7 @@
 #define GPC_PGC_SW_SHIFT	0x0
 
 #define IMR_NUM			4
+#define GPC_MAX_IRQS		(IMR_NUM * 32)
 
 #define GPU_VPU_PUP_REQ		BIT(1)
 #define GPU_VPU_PDN_REQ		BIT(0)
@@ -99,17 +100,17 @@ void imx_gpc_post_resume(void)
 
 static int imx_gpc_irq_set_wake(struct irq_data *d, unsigned int on)
 {
-	unsigned int idx = d->hwirq / 32 - 1;
+	unsigned int idx = d->hwirq / 32;
 	u32 mask;
 
-	/* Sanity check for SPI irq */
-	if (d->hwirq < 32)
-		return -EINVAL;
-
 	mask = 1 << d->hwirq % 32;
 	gpc_wake_irqs[idx] = on ? gpc_wake_irqs[idx] | mask :
 				  gpc_wake_irqs[idx] & ~mask;
 
+	/*
+	 * Do *not* call into the parent, as the GIC doesn't have any
+	 * wake-up facility...
+	 */
 	return 0;
 }
 
@@ -139,7 +140,7 @@ void imx_gpc_hwirq_unmask(unsigned int hwirq)
 	void __iomem *reg;
 	u32 val;
 
-	reg = gpc_base + GPC_IMR1 + (hwirq / 32 - 1) * 4;
+	reg = gpc_base + GPC_IMR1 + hwirq / 32 * 4;
 	val = readl_relaxed(reg);
 	val &= ~(1 << hwirq % 32);
 	writel_relaxed(val, reg);
@@ -150,7 +151,7 @@ void imx_gpc_hwirq_mask(unsigned int hwirq)
 	void __iomem *reg;
 	u32 val;
 
-	reg = gpc_base + GPC_IMR1 + (hwirq / 32 - 1) * 4;
+	reg = gpc_base + GPC_IMR1 + hwirq / 32 * 4;
 	val = readl_relaxed(reg);
 	val |= 1 << (hwirq % 32);
 	writel_relaxed(val, reg);
@@ -158,41 +159,119 @@ void imx_gpc_hwirq_mask(unsigned int hwirq)
 
 static void imx_gpc_irq_unmask(struct irq_data *d)
 {
-	/* Sanity check for SPI irq */
-	if (d->hwirq < 32)
-		return;
-
 	imx_gpc_hwirq_unmask(d->hwirq);
+	irq_chip_unmask_parent(d);
 }
 
 static void imx_gpc_irq_mask(struct irq_data *d)
 {
-	/* Sanity check for SPI irq */
-	if (d->hwirq < 32)
-		return;
-
 	imx_gpc_hwirq_mask(d->hwirq);
+	irq_chip_mask_parent(d);
 }
 
-void __init imx_gpc_init(void)
+static struct irq_chip imx_gpc_chip = {
+	.name		= "GPC",
+	.irq_eoi	= irq_chip_eoi_parent,
+	.irq_mask	= imx_gpc_irq_mask,
+	.irq_unmask	= imx_gpc_irq_unmask,
+	.irq_retrigger	= irq_chip_retrigger_hierarchy,
+	.irq_set_wake	= imx_gpc_irq_set_wake,
+};
+
+static int imx_gpc_domain_xlate(struct irq_domain *domain,
+				struct device_node *controller,
+				const u32 *intspec,
+				unsigned int intsize,
+				unsigned long *out_hwirq,
+				unsigned int *out_type)
 {
-	struct device_node *np;
+	if (domain->of_node != controller)
+		return -EINVAL;	/* Shouldn't happen, really... */
+	if (intsize != 3)
+		return -EINVAL;	/* Not GIC compliant */
+	if (intspec[0] != 0)
+		return -EINVAL;	/* No PPI should point to this domain */
+
+	*out_hwirq = intspec[1];
+	*out_type = intspec[2];
+	return 0;
+}
+
+static int imx_gpc_domain_alloc(struct irq_domain *domain,
+				  unsigned int irq,
+				  unsigned int nr_irqs, void *data)
+{
+	struct of_phandle_args *args = data;
+	struct of_phandle_args parent_args;
+	irq_hw_number_t hwirq;
 	int i;
 
-	np = of_find_compatible_node(NULL, NULL, "fsl,imx6q-gpc");
-	gpc_base = of_iomap(np, 0);
-	WARN_ON(!gpc_base);
+	if (args->args_count != 3)
+		return -EINVAL;	/* Not GIC compliant */
+	if (args->args[0] != 0)
+		return -EINVAL;	/* No PPI should point to this domain */
+
+	hwirq = args->args[1];
+	if (hwirq >= GPC_MAX_IRQS)
+		return -EINVAL;	/* Can't deal with this */
+
+	for (i = 0; i < nr_irqs; i++)
+		irq_domain_set_hwirq_and_chip(domain, irq + i, hwirq + i,
+					      &imx_gpc_chip, NULL);
+
+	parent_args = *args;
+	parent_args.np = domain->parent->of_node;
+	return irq_domain_alloc_irqs_parent(domain, irq, nr_irqs, &parent_args);
+}
+
+static struct irq_domain_ops imx_gpc_domain_ops = {
+	.xlate	= imx_gpc_domain_xlate,
+	.alloc	= imx_gpc_domain_alloc,
+	.free	= irq_domain_free_irqs_common,
+};
+
+static int __init imx_gpc_init(struct device_node *node,
+			       struct device_node *parent)
+{
+	struct irq_domain *parent_domain, *domain;
+	int i;
+
+	if (!parent) {
+		pr_err("%s: no parent, giving up\n", node->full_name);
+		return -ENODEV;
+	}
+
+	parent_domain = irq_find_host(parent);
+	if (!parent_domain) {
+		pr_err("%s: unable to obtain parent domain\n", node->full_name);
+		return -ENXIO;
+	}
+
+	gpc_base = of_iomap(node, 0);
+	if (WARN_ON(!gpc_base))
+	        return -ENOMEM;
+
+	domain = irq_domain_add_hierarchy(parent_domain, 0, GPC_MAX_IRQS,
+					  node, &imx_gpc_domain_ops,
+					  NULL);
+	if (!domain) {
+		iounmap(gpc_base);
+		return -ENOMEM;
+	}
 
 	/* Initially mask all interrupts */
 	for (i = 0; i < IMR_NUM; i++)
 		writel_relaxed(~0, gpc_base + GPC_IMR1 + i * 4);
 
-	/* Register GPC as the secondary interrupt controller behind GIC */
-	gic_arch_extn.irq_mask = imx_gpc_irq_mask;
-	gic_arch_extn.irq_unmask = imx_gpc_irq_unmask;
-	gic_arch_extn.irq_set_wake = imx_gpc_irq_set_wake;
+	return 0;
 }
 
+/*
+ * We cannot use the IRQCHIP_DECLARE macro that lives in
+ * drivers/irqchip, so we're forced to roll our own. Not very nice.
+ */
+OF_DECLARE_2(irqchip, imx_gpc, "fsl,imx6q-gpc", imx_gpc_init);
+
 #ifdef CONFIG_PM_GENERIC_DOMAINS
 
 static void _imx6q_pm_pu_power_off(struct generic_pm_domain *genpd)

commit 00eb60a8b4f7a4aa00fd8abd68c2dc7aec55df19
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Mon Feb 23 18:40:12 2015 +0100

    ARM: imx6: gpc: Add PU power domain for GPU/VPU
    
    When generic pm domain support is enabled, the PGC can be used
    to completely gate power to the PU power domain containing GPU3D,
    GPU2D, and VPU cores.
    This code triggers the PGC powerdown sequence to disable the GPU/VPU
    isolation cells and gate power and then disables the PU regulator.
    To reenable, the reverse powerup sequence is triggered after the PU
    regulator is enabled again.
    The GPU and VPU devices in the PU power domain temporarily need
    to be clocked during powerup, so that the reset machinery can work.
    
    [Avoid explicit regulator enabling in probe, unless !PM]
    Signed-off-by: Markus Pargmann <mpa@pengutronix.de>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 745caa18ab2c..029f59ce2712 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -10,15 +10,25 @@
  * http://www.gnu.org/copyleft/gpl.html
  */
 
+#include <linux/clk.h>
+#include <linux/delay.h>
 #include <linux/io.h>
 #include <linux/irq.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/pm_domain.h>
+#include <linux/regulator/consumer.h>
 #include <linux/irqchip/arm-gic.h>
 #include "common.h"
+#include "hardware.h"
 
+#define GPC_CNTR		0x000
 #define GPC_IMR1		0x008
+#define GPC_PGC_GPU_PDN		0x260
+#define GPC_PGC_GPU_PUPSCR	0x264
+#define GPC_PGC_GPU_PDNSCR	0x268
 #define GPC_PGC_CPU_PDN		0x2a0
 #define GPC_PGC_CPU_PUPSCR	0x2a4
 #define GPC_PGC_CPU_PDNSCR	0x2a8
@@ -27,6 +37,18 @@
 
 #define IMR_NUM			4
 
+#define GPU_VPU_PUP_REQ		BIT(1)
+#define GPU_VPU_PDN_REQ		BIT(0)
+
+#define GPC_CLK_MAX		6
+
+struct pu_domain {
+	struct generic_pm_domain base;
+	struct regulator *reg;
+	struct clk *clk[GPC_CLK_MAX];
+	int num_clks;
+};
+
 static void __iomem *gpc_base;
 static u32 gpc_wake_irqs[IMR_NUM];
 static u32 gpc_saved_imrs[IMR_NUM];
@@ -170,3 +192,194 @@ void __init imx_gpc_init(void)
 	gic_arch_extn.irq_unmask = imx_gpc_irq_unmask;
 	gic_arch_extn.irq_set_wake = imx_gpc_irq_set_wake;
 }
+
+#ifdef CONFIG_PM_GENERIC_DOMAINS
+
+static void _imx6q_pm_pu_power_off(struct generic_pm_domain *genpd)
+{
+	int iso, iso2sw;
+	u32 val;
+
+	/* Read ISO and ISO2SW power down delays */
+	val = readl_relaxed(gpc_base + GPC_PGC_GPU_PDNSCR);
+	iso = val & 0x3f;
+	iso2sw = (val >> 8) & 0x3f;
+
+	/* Gate off PU domain when GPU/VPU when powered down */
+	writel_relaxed(0x1, gpc_base + GPC_PGC_GPU_PDN);
+
+	/* Request GPC to power down GPU/VPU */
+	val = readl_relaxed(gpc_base + GPC_CNTR);
+	val |= GPU_VPU_PDN_REQ;
+	writel_relaxed(val, gpc_base + GPC_CNTR);
+
+	/* Wait ISO + ISO2SW IPG clock cycles */
+	ndelay((iso + iso2sw) * 1000 / 66);
+}
+
+static int imx6q_pm_pu_power_off(struct generic_pm_domain *genpd)
+{
+	struct pu_domain *pu = container_of(genpd, struct pu_domain, base);
+
+	_imx6q_pm_pu_power_off(genpd);
+
+	if (pu->reg)
+		regulator_disable(pu->reg);
+
+	return 0;
+}
+
+static int imx6q_pm_pu_power_on(struct generic_pm_domain *genpd)
+{
+	struct pu_domain *pu = container_of(genpd, struct pu_domain, base);
+	int i, ret, sw, sw2iso;
+	u32 val;
+
+	if (pu->reg)
+		ret = regulator_enable(pu->reg);
+	if (pu->reg && ret) {
+		pr_err("%s: failed to enable regulator: %d\n", __func__, ret);
+		return ret;
+	}
+
+	/* Enable reset clocks for all devices in the PU domain */
+	for (i = 0; i < pu->num_clks; i++)
+		clk_prepare_enable(pu->clk[i]);
+
+	/* Gate off PU domain when GPU/VPU when powered down */
+	writel_relaxed(0x1, gpc_base + GPC_PGC_GPU_PDN);
+
+	/* Read ISO and ISO2SW power down delays */
+	val = readl_relaxed(gpc_base + GPC_PGC_GPU_PUPSCR);
+	sw = val & 0x3f;
+	sw2iso = (val >> 8) & 0x3f;
+
+	/* Request GPC to power up GPU/VPU */
+	val = readl_relaxed(gpc_base + GPC_CNTR);
+	val |= GPU_VPU_PUP_REQ;
+	writel_relaxed(val, gpc_base + GPC_CNTR);
+
+	/* Wait ISO + ISO2SW IPG clock cycles */
+	ndelay((sw + sw2iso) * 1000 / 66);
+
+	/* Disable reset clocks for all devices in the PU domain */
+	for (i = 0; i < pu->num_clks; i++)
+		clk_disable_unprepare(pu->clk[i]);
+
+	return 0;
+}
+
+static struct generic_pm_domain imx6q_arm_domain = {
+	.name = "ARM",
+};
+
+static struct pu_domain imx6q_pu_domain = {
+	.base = {
+		.name = "PU",
+		.power_off = imx6q_pm_pu_power_off,
+		.power_on = imx6q_pm_pu_power_on,
+		.power_off_latency_ns = 25000,
+		.power_on_latency_ns = 2000000,
+	},
+};
+
+static struct generic_pm_domain imx6sl_display_domain = {
+	.name = "DISPLAY",
+};
+
+static struct generic_pm_domain *imx_gpc_domains[] = {
+	&imx6q_arm_domain,
+	&imx6q_pu_domain.base,
+	&imx6sl_display_domain,
+};
+
+static struct genpd_onecell_data imx_gpc_onecell_data = {
+	.domains = imx_gpc_domains,
+	.num_domains = ARRAY_SIZE(imx_gpc_domains),
+};
+
+static int imx_gpc_genpd_init(struct device *dev, struct regulator *pu_reg)
+{
+	struct clk *clk;
+	bool is_off;
+	int i;
+
+	imx6q_pu_domain.reg = pu_reg;
+
+	for (i = 0; ; i++) {
+		clk = of_clk_get(dev->of_node, i);
+		if (IS_ERR(clk))
+			break;
+		if (i >= GPC_CLK_MAX) {
+			dev_err(dev, "more than %d clocks\n", GPC_CLK_MAX);
+			goto clk_err;
+		}
+		imx6q_pu_domain.clk[i] = clk;
+	}
+	imx6q_pu_domain.num_clks = i;
+
+	is_off = IS_ENABLED(CONFIG_PM);
+	if (is_off) {
+		_imx6q_pm_pu_power_off(&imx6q_pu_domain.base);
+	} else {
+		/*
+		 * Enable power if compiled without CONFIG_PM in case the
+		 * bootloader disabled it.
+		 */
+		imx6q_pm_pu_power_on(&imx6q_pu_domain.base);
+	}
+
+	pm_genpd_init(&imx6q_pu_domain.base, NULL, is_off);
+	return of_genpd_add_provider_onecell(dev->of_node,
+					     &imx_gpc_onecell_data);
+
+clk_err:
+	while (i--)
+		clk_put(imx6q_pu_domain.clk[i]);
+	return -EINVAL;
+}
+
+#else
+static inline int imx_gpc_genpd_init(struct device *dev, struct regulator *reg)
+{
+	return 0;
+}
+#endif /* CONFIG_PM_GENERIC_DOMAINS */
+
+static int imx_gpc_probe(struct platform_device *pdev)
+{
+	struct regulator *pu_reg;
+	int ret;
+
+	pu_reg = devm_regulator_get_optional(&pdev->dev, "pu");
+	if (PTR_ERR(pu_reg) == -ENODEV)
+		pu_reg = NULL;
+	if (IS_ERR(pu_reg)) {
+		ret = PTR_ERR(pu_reg);
+		dev_err(&pdev->dev, "failed to get pu regulator: %d\n", ret);
+		return ret;
+	}
+
+	return imx_gpc_genpd_init(&pdev->dev, pu_reg);
+}
+
+static const struct of_device_id imx_gpc_dt_ids[] = {
+	{ .compatible = "fsl,imx6q-gpc" },
+	{ .compatible = "fsl,imx6sl-gpc" },
+	{ }
+};
+
+static struct platform_driver imx_gpc_driver = {
+	.driver = {
+		.name = "imx-gpc",
+		.owner = THIS_MODULE,
+		.of_match_table = imx_gpc_dt_ids,
+	},
+	.probe = imx_gpc_probe,
+};
+
+static int __init imx_pgc_init(void)
+{
+	return platform_driver_register(&imx_gpc_driver);
+}
+subsys_initcall(imx_pgc_init);

commit 05136f0897b526b9cd090c93b95bbd1b67c18cc5
Author: Anson Huang <b20788@freescale.com>
Date:   Wed Dec 17 12:24:12 2014 +0800

    ARM: imx: support arm power off in cpuidle for i.mx6sx
    
    This patch introduces an independent cpuidle driver for
    i.MX6SX, and supports arm power off in idle, totally
    3 levels of cpuidle are supported as below:
    
    1. ARM WFI;
    2. SOC in WAIT mode;
    3. SOC in WAIT mode + ARM power off.
    
    ARM power off can save at least 5mW power.
    
    This patch also replaces imx6q_enable_rbc with imx6_enable_rbc.
    
    Signed-off-by: Anson Huang <b20788@freescale.com>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 5f3602ec74fa..745caa18ab2c 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -20,6 +20,10 @@
 
 #define GPC_IMR1		0x008
 #define GPC_PGC_CPU_PDN		0x2a0
+#define GPC_PGC_CPU_PUPSCR	0x2a4
+#define GPC_PGC_CPU_PDNSCR	0x2a8
+#define GPC_PGC_SW2ISO_SHIFT	0x8
+#define GPC_PGC_SW_SHIFT	0x0
 
 #define IMR_NUM			4
 
@@ -27,6 +31,23 @@ static void __iomem *gpc_base;
 static u32 gpc_wake_irqs[IMR_NUM];
 static u32 gpc_saved_imrs[IMR_NUM];
 
+void imx_gpc_set_arm_power_up_timing(u32 sw2iso, u32 sw)
+{
+	writel_relaxed((sw2iso << GPC_PGC_SW2ISO_SHIFT) |
+		(sw << GPC_PGC_SW_SHIFT), gpc_base + GPC_PGC_CPU_PUPSCR);
+}
+
+void imx_gpc_set_arm_power_down_timing(u32 sw2iso, u32 sw)
+{
+	writel_relaxed((sw2iso << GPC_PGC_SW2ISO_SHIFT) |
+		(sw << GPC_PGC_SW_SHIFT), gpc_base + GPC_PGC_CPU_PDNSCR);
+}
+
+void imx_gpc_set_arm_power_in_lpm(bool power_off)
+{
+	writel_relaxed(power_off, gpc_base + GPC_PGC_CPU_PDN);
+}
+
 void imx_gpc_pre_suspend(bool arm_power_off)
 {
 	void __iomem *reg_imr1 = gpc_base + GPC_IMR1;
@@ -34,7 +55,7 @@ void imx_gpc_pre_suspend(bool arm_power_off)
 
 	/* Tell GPC to power off ARM core when suspend */
 	if (arm_power_off)
-		writel_relaxed(0x1, gpc_base + GPC_PGC_CPU_PDN);
+		imx_gpc_set_arm_power_in_lpm(arm_power_off);
 
 	for (i = 0; i < IMR_NUM; i++) {
 		gpc_saved_imrs[i] = readl_relaxed(reg_imr1 + i * 4);
@@ -48,7 +69,7 @@ void imx_gpc_post_resume(void)
 	int i;
 
 	/* Keep ARM core powered on for other low-power modes */
-	writel_relaxed(0x0, gpc_base + GPC_PGC_CPU_PDN);
+	imx_gpc_set_arm_power_in_lpm(false);
 
 	for (i = 0; i < IMR_NUM; i++)
 		writel_relaxed(gpc_saved_imrs[i], reg_imr1 + i * 4);

commit 65bb688aab9424849e94f74d555542fa76cd3d5a
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Dec 2 16:05:26 2014 +0000

    ARM: imx6: fix bogus use of irq_get_irq_data
    
    The imx6 PM code seems to be quite creative in its use of irq_data,
    using something that is very much a hardware interrupt number where
    we expect a virtual one.  Yes, it worked so far, but that's only
    luck, and it will definitely explode in 3.19.
    
    Fix it by using a pair of helper functions that deal with the
    actual hardware.
    
    Tested-by: Fabio Estevam <fabio.estevam@freescale.com>
    Acked-by: Philipp Zabel <p.zabel@pengutronix.de>
    Acked-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 1455829c735e..5f3602ec74fa 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -91,34 +91,44 @@ void imx_gpc_restore_all(void)
 		writel_relaxed(gpc_saved_imrs[i], reg_imr1 + i * 4);
 }
 
-void imx_gpc_irq_unmask(struct irq_data *d)
+void imx_gpc_hwirq_unmask(unsigned int hwirq)
 {
 	void __iomem *reg;
 	u32 val;
 
-	/* Sanity check for SPI irq */
-	if (d->hwirq < 32)
-		return;
-
-	reg = gpc_base + GPC_IMR1 + (d->hwirq / 32 - 1) * 4;
+	reg = gpc_base + GPC_IMR1 + (hwirq / 32 - 1) * 4;
 	val = readl_relaxed(reg);
-	val &= ~(1 << d->hwirq % 32);
+	val &= ~(1 << hwirq % 32);
 	writel_relaxed(val, reg);
 }
 
-void imx_gpc_irq_mask(struct irq_data *d)
+void imx_gpc_hwirq_mask(unsigned int hwirq)
 {
 	void __iomem *reg;
 	u32 val;
 
+	reg = gpc_base + GPC_IMR1 + (hwirq / 32 - 1) * 4;
+	val = readl_relaxed(reg);
+	val |= 1 << (hwirq % 32);
+	writel_relaxed(val, reg);
+}
+
+static void imx_gpc_irq_unmask(struct irq_data *d)
+{
+	/* Sanity check for SPI irq */
+	if (d->hwirq < 32)
+		return;
+
+	imx_gpc_hwirq_unmask(d->hwirq);
+}
+
+static void imx_gpc_irq_mask(struct irq_data *d)
+{
 	/* Sanity check for SPI irq */
 	if (d->hwirq < 32)
 		return;
 
-	reg = gpc_base + GPC_IMR1 + (d->hwirq / 32 - 1) * 4;
-	val = readl_relaxed(reg);
-	val |= 1 << (d->hwirq % 32);
-	writel_relaxed(val, reg);
+	imx_gpc_hwirq_mask(d->hwirq);
 }
 
 void __init imx_gpc_init(void)

commit e2fd06f6be690a1a9697c0c6338843a35cbd70a3
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Dec 2 16:05:25 2014 +0000

    ARM: imx: irq: fix buggy usage of irq_data irq field
    
    mach-imx directly references to the irq field in
    struct irq_data, and uses this to directly poke hardware register.
    
    But irq is the *virtual* irq number, something that has nothing
    to do with the actual HW irq (stored in the hwirq field). And once
    we put the stacked domain code in action, the whole thing explodes,
    as these two values are *very* different.
    
    Just replacing all instances of irq with hwirq fixes the issue.
    
    Tested-by: Fabio Estevam <fabio.estevam@freescale.com>
    Acked-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 82ea74e68482..1455829c735e 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -56,14 +56,14 @@ void imx_gpc_post_resume(void)
 
 static int imx_gpc_irq_set_wake(struct irq_data *d, unsigned int on)
 {
-	unsigned int idx = d->irq / 32 - 1;
+	unsigned int idx = d->hwirq / 32 - 1;
 	u32 mask;
 
 	/* Sanity check for SPI irq */
-	if (d->irq < 32)
+	if (d->hwirq < 32)
 		return -EINVAL;
 
-	mask = 1 << d->irq % 32;
+	mask = 1 << d->hwirq % 32;
 	gpc_wake_irqs[idx] = on ? gpc_wake_irqs[idx] | mask :
 				  gpc_wake_irqs[idx] & ~mask;
 
@@ -97,12 +97,12 @@ void imx_gpc_irq_unmask(struct irq_data *d)
 	u32 val;
 
 	/* Sanity check for SPI irq */
-	if (d->irq < 32)
+	if (d->hwirq < 32)
 		return;
 
-	reg = gpc_base + GPC_IMR1 + (d->irq / 32 - 1) * 4;
+	reg = gpc_base + GPC_IMR1 + (d->hwirq / 32 - 1) * 4;
 	val = readl_relaxed(reg);
-	val &= ~(1 << d->irq % 32);
+	val &= ~(1 << d->hwirq % 32);
 	writel_relaxed(val, reg);
 }
 
@@ -112,12 +112,12 @@ void imx_gpc_irq_mask(struct irq_data *d)
 	u32 val;
 
 	/* Sanity check for SPI irq */
-	if (d->irq < 32)
+	if (d->hwirq < 32)
 		return;
 
-	reg = gpc_base + GPC_IMR1 + (d->irq / 32 - 1) * 4;
+	reg = gpc_base + GPC_IMR1 + (d->hwirq / 32 - 1) * 4;
 	val = readl_relaxed(reg);
-	val |= 1 << (d->irq % 32);
+	val |= 1 << (d->hwirq % 32);
 	writel_relaxed(val, reg);
 }
 

commit 80c0ecdce802bd642dc7127cc77cea04e0a71bf5
Author: Anson Huang <b20788@freescale.com>
Date:   Mon Jun 23 16:42:44 2014 +0800

    ARM: imx: add standby mode support for suspend
    
    Add standby mode support for suspend, to enter standby mode:
    
    echo standby > /sys/power/state;
    
    Use UART or RTC alarm to wake up system, when system enters
    standby mode, SOC will enter STOP mode with ARM core kept
    power on and 24M XTAL on.
    
    Signed-off-by: Anson Huang <b20788@freescale.com>
    Signed-off-by: Shawn Guo <shawn.guo@freescale.com>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 586e0171a652..82ea74e68482 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -27,13 +27,14 @@ static void __iomem *gpc_base;
 static u32 gpc_wake_irqs[IMR_NUM];
 static u32 gpc_saved_imrs[IMR_NUM];
 
-void imx_gpc_pre_suspend(void)
+void imx_gpc_pre_suspend(bool arm_power_off)
 {
 	void __iomem *reg_imr1 = gpc_base + GPC_IMR1;
 	int i;
 
 	/* Tell GPC to power off ARM core when suspend */
-	writel_relaxed(0x1, gpc_base + GPC_PGC_CPU_PDN);
+	if (arm_power_off)
+		writel_relaxed(0x1, gpc_base + GPC_PGC_CPU_PDN);
 
 	for (i = 0; i < IMR_NUM; i++) {
 		gpc_saved_imrs[i] = readl_relaxed(reg_imr1 + i * 4);

commit d48866fefdac239a4e02777e712aad60db9ee8a8
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Wed Oct 16 19:52:00 2013 +0800

    ARM: imx: ensure dsm_request signal is not asserted when setting LPM
    
    There is a defect in imx6 LPM design.  When SW tries to enter low power
    mode with following sequence, the chip will enter low power mode before
    A9 CPU execute WFI instruction:
    
    1. Set CCM_CLPCR[1:0] to 2'b00;
    2. ARM CPU enters WFI;
    3. ARM CPU wakeup from an interrupt event, which is masked by GPC or not
       visible to GPC, such as interrupt from local timer;
    4. Set CCM_CLPCR[1:0] to 2'b01 or 2'b10;
    5. ARM CPU execute WFI.
    
    Before the last step, the chip will enter WAIT mode if CCM_CLPCR[1:0] is
    set to 2'b01, or enter STOP mode if CCM_CLPCR[1:0] is set to 2'b10.
    
    The patch implements a recommended workaround for this issue.
    
    1. SW triggers irq #32(IOMUX) to be always pending manually by setting
       IOMUX_GPR1_GINT bit;
    2. SW should then unmask it in GPC before setting CCM LPM;
    3. SW should mask it right after CCM LPM is set (bit0-1 of CCM_CLPCR).
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index 44a65e9ff1fc..586e0171a652 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -90,7 +90,7 @@ void imx_gpc_restore_all(void)
 		writel_relaxed(gpc_saved_imrs[i], reg_imr1 + i * 4);
 }
 
-static void imx_gpc_irq_unmask(struct irq_data *d)
+void imx_gpc_irq_unmask(struct irq_data *d)
 {
 	void __iomem *reg;
 	u32 val;
@@ -105,7 +105,7 @@ static void imx_gpc_irq_unmask(struct irq_data *d)
 	writel_relaxed(val, reg);
 }
 
-static void imx_gpc_irq_mask(struct irq_data *d)
+void imx_gpc_irq_mask(struct irq_data *d)
 {
 	void __iomem *reg;
 	u32 val;

commit fcba914542082b272f31c8e4c40000b88ed3208d
Merge: a8c4b90e670b 5c5f0421a8ee
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 11:02:18 2013 -0700

    Merge tag 'soc-for-linus-3' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform updates (part 3) from Arnd Bergmann:
     "This is the third and smallest of the SoC specific updates.  Changes
      include:
    
       - SMP support for the Xilinx zynq platform
       - Smaller imx changes
       - LPAE support for mvebu
       - Moving the orion5x, kirkwood, dove and mvebu platforms to a common
         "mbus" driver for their internal devices.
    
      It would be good to get feedback on the location of the "mbus" driver.
      Since this is used on multiple platforms may potentially get shared
      with other architectures (powerpc and arm64), it was moved to
      drivers/bus/.  We expect other similar drivers to get moved to the
      same place in order to avoid creating more top-level directories under
      drivers/ or cluttering up the messy drivers/misc/ even more."
    
    * tag 'soc-for-linus-3' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (50 commits)
      ARM: imx: reset_controller may be disabled
      ARM: mvebu: Align the internal registers virtual base to support LPAE
      ARM: mvebu: Limit the DMA zone when LPAE is selected
      arm: plat-orion: remove addr-map code
      arm: mach-mv78xx0: convert to use the mvebu-mbus driver
      arm: mach-orion5x: convert to use mvebu-mbus driver
      arm: mach-dove: convert to use mvebu-mbus driver
      arm: mach-kirkwood: convert to use mvebu-mbus driver
      arm: mach-mvebu: convert to use mvebu-mbus driver
      ARM i.MX53: set CLK_SET_RATE_PARENT flag on the tve_ext_sel clock
      ARM i.MX53: tve_di clock is not part of the CCM, but of TVE
      ARM i.MX53: make tve_ext_sel propagate rate change to PLL
      ARM i.MX53: Remove unused tve_gate clkdev entry
      ARM i.MX5: Remove tve_sel clock from i.MX53 clock tree
      ARM: i.MX5: Add PATA and SRTC clocks
      ARM: imx: do not bring up unavailable cores
      ARM: imx: add initial imx6dl support
      ARM: imx1: mm: add call to mxc_device_init
      ARM: imx_v4_v5_defconfig: Add CONFIG_GPIO_SYSFS
      ARM: imx_v6_v7_defconfig: Select CONFIG_PERF_EVENTS
      ...

commit 263475d4e0b0623fb7a22f8ac0a5c01017eabf20
Author: Anson Huang <b20788@freescale.com>
Date:   Thu Mar 21 10:58:06 2013 -0400

    ARM: imx: enable RBC to support anatop LPM mode
    
    RBC is to control whether some ANATOP sub modules
    can enter lpm mode when SOC is into STOP mode, if
    RBC is enabled and PMIC_VSTBY_REQ is set, ANATOP
    will have below behaviors:
    
    1. Digital LDOs(CORE, SOC and PU) are bypassed;
    2. Analog LDOs(1P1, 2P5, 3P0) are disabled;
    
    As the 2P5 is necessary for DRAM IO pre-drive in
    STOP mode, so we need to enable weak 2P5 in STOP
    mode when 2P5 LDO is disabled.
    
    For RBC settings, there are some rules as below
    due to hardware design:
    
    1. All interrupts must be masked during operating
       RBC registers;
    2. At least 2 CKIL(32K) cycles is needed after the
       RBC setting is changed.
    
    Signed-off-by: Anson Huang <b20788@freescale.com>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index a96ccc7f5012..c20445c56032 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011 Freescale Semiconductor, Inc.
+ * Copyright 2011-2013 Freescale Semiconductor, Inc.
  * Copyright 2011 Linaro Ltd.
  *
  * The code contained herein is licensed under the GNU General Public
@@ -68,6 +68,27 @@ static int imx_gpc_irq_set_wake(struct irq_data *d, unsigned int on)
 	return 0;
 }
 
+void imx_gpc_mask_all(void)
+{
+	void __iomem *reg_imr1 = gpc_base + GPC_IMR1;
+	int i;
+
+	for (i = 0; i < IMR_NUM; i++) {
+		gpc_saved_imrs[i] = readl_relaxed(reg_imr1 + i * 4);
+		writel_relaxed(~0, reg_imr1 + i * 4);
+	}
+
+}
+
+void imx_gpc_restore_all(void)
+{
+	void __iomem *reg_imr1 = gpc_base + GPC_IMR1;
+	int i;
+
+	for (i = 0; i < IMR_NUM; i++)
+		writel_relaxed(gpc_saved_imrs[i], reg_imr1 + i * 4);
+}
+
 static void imx_gpc_irq_unmask(struct irq_data *d)
 {
 	void __iomem *reg;

commit 9a67a6fd36fea1ab360249e4b7ef2d29d3e2fac8
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Mon Mar 25 09:20:42 2013 -0300

    ARM: mach-imx: gpc: Include "common.h"
    
    Fix the following sparse warnings:
    
    arch/arm/mach-imx/gpc.c:29:6: warning: symbol 'imx_gpc_pre_suspend' was not declared. Should it be static?
    arch/arm/mach-imx/gpc.c:43:6: warning: symbol 'imx_gpc_post_resume' was not declared. Should it be static?
    arch/arm/mach-imx/gpc.c:71:6: warning: symbol 'imx_gpc_mask_all' was not declared. Should it be static?
    arch/arm/mach-imx/gpc.c:83:6: warning: symbol 'imx_gpc_restore_all' was not declared. Should it be static?
    arch/arm/mach-imx/gpc.c:122:13: warning: symbol 'imx_gpc_init' was not declared. Should it be static?
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index a96ccc7f5012..02b61cdf39b9 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -16,6 +16,7 @@
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
 #include <linux/irqchip/arm-gic.h>
+#include "common.h"
 
 #define GPC_IMR1		0x008
 #define GPC_PGC_CPU_PDN		0x2a0

commit 4227961650884a06757f80877d5dce0bddc723d4
Merge: ef4acb75a019 e5f9dec8ff5f
Author: Olof Johansson <olof@lixom.net>
Date:   Mon Feb 4 22:24:20 2013 -0800

    Merge tag 'imx6q-cpudile-3.9' of git://git.linaro.org/people/shawnguo/linux-2.6 into next/soc
    
    From Shawn Guo:
    imx6q cpuidle support for 3.9
    
     - It's based on imx-cleanup-3.9 to avoid conflicts.
    
    * tag 'imx6q-cpudile-3.9' of git://git.linaro.org/people/shawnguo/linux-2.6:
      ARM: imx6q: support WAIT mode using cpuidle
      ARM: imx: move imx6q_cpuidle_driver into a separate file
      ARM: imx: mask gpc interrupts initially
      ARM: imx: return zero in case next event gets a large increment
      ARM: imx: Remove mx508 support
      ARM: imx: Remove mach-mx51_3ds board
      ARM: imx: use debug_ll_io_init() for imx6q
      ARM: imx: remove unused imx6q_clock_map_io()
      ARM: mach-imx: Kconfig: Do not select Babbage for MACH_IMX51_DT
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    
    Still, two delete/change conflicts caused by imx/cleanup:
    
            arch/arm/mach-imx/mach-mx50_rdp.c
            arch/arm/mach-imx/mach-mx51_3ds.c

commit 485863b8fa02d515e48ce6b59f01d62172d2fe0d
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Tue Dec 4 22:55:13 2012 +0800

    ARM: imx: mask gpc interrupts initially
    
    Mask gpc interrupts initially to avoid suspicious interrupts.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index e1537f9e45b8..722e5df7e44e 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -101,11 +101,16 @@ static void imx_gpc_irq_mask(struct irq_data *d)
 void __init imx_gpc_init(void)
 {
 	struct device_node *np;
+	int i;
 
 	np = of_find_compatible_node(NULL, NULL, "fsl,imx6q-gpc");
 	gpc_base = of_iomap(np, 0);
 	WARN_ON(!gpc_base);
 
+	/* Initially mask all interrupts */
+	for (i = 0; i < IMR_NUM; i++)
+		writel_relaxed(~0, gpc_base + GPC_IMR1 + i * 4);
+
 	/* Register GPC as the secondary interrupt controller behind GIC */
 	gic_arch_extn.irq_mask = imx_gpc_irq_mask;
 	gic_arch_extn.irq_unmask = imx_gpc_irq_unmask;

commit 520f7bd73354f003a9a59937b28e4903d985c420
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Thu Dec 27 13:10:24 2012 -0600

    irqchip: Move ARM gic.h to include/linux/irqchip/arm-gic.h
    
    Now that we have GIC moved to drivers/irqchip and all GIC DT init for
    platforms using irqchip_init, move gic.h and update the remaining
    includes.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Anton Vorontsov <avorontsov@mvista.com>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: David Brown <davidb@codeaurora.org>
    Cc: Daniel Walker <dwalker@fifo99.com>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Viresh Kumar <viresh.linux@gmail.com>
    Cc: Shiraz Hashim <shiraz.hashim@st.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
index e1537f9e45b8..ff24920699e4 100644
--- a/arch/arm/mach-imx/gpc.c
+++ b/arch/arm/mach-imx/gpc.c
@@ -15,7 +15,7 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
-#include <asm/hardware/gic.h>
+#include <linux/irqchip/arm-gic.h>
 
 #define GPC_IMR1		0x008
 #define GPC_PGC_CPU_PDN		0x2a0

commit 9fbbe6890c88aa332efe61d5894108dd8b932530
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Tue Sep 6 14:39:44 2011 +0800

    arm/imx6q: add core drivers clock, gpc, mmdc and src
    
    It adds a number of core drivers support for imx6q, including clock,
    General Power Controller (gpc), Multi Mode DDR Controller(mmdc) and
    System Reset Controller (src).
    
    Signed-off-by: Ranjani Vaidyanathan <ra5478@freescale.com>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/gpc.c b/arch/arm/mach-imx/gpc.c
new file mode 100644
index 000000000000..e1537f9e45b8
--- /dev/null
+++ b/arch/arm/mach-imx/gpc.c
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <asm/hardware/gic.h>
+
+#define GPC_IMR1		0x008
+#define GPC_PGC_CPU_PDN		0x2a0
+
+#define IMR_NUM			4
+
+static void __iomem *gpc_base;
+static u32 gpc_wake_irqs[IMR_NUM];
+static u32 gpc_saved_imrs[IMR_NUM];
+
+void imx_gpc_pre_suspend(void)
+{
+	void __iomem *reg_imr1 = gpc_base + GPC_IMR1;
+	int i;
+
+	/* Tell GPC to power off ARM core when suspend */
+	writel_relaxed(0x1, gpc_base + GPC_PGC_CPU_PDN);
+
+	for (i = 0; i < IMR_NUM; i++) {
+		gpc_saved_imrs[i] = readl_relaxed(reg_imr1 + i * 4);
+		writel_relaxed(~gpc_wake_irqs[i], reg_imr1 + i * 4);
+	}
+}
+
+void imx_gpc_post_resume(void)
+{
+	void __iomem *reg_imr1 = gpc_base + GPC_IMR1;
+	int i;
+
+	/* Keep ARM core powered on for other low-power modes */
+	writel_relaxed(0x0, gpc_base + GPC_PGC_CPU_PDN);
+
+	for (i = 0; i < IMR_NUM; i++)
+		writel_relaxed(gpc_saved_imrs[i], reg_imr1 + i * 4);
+}
+
+static int imx_gpc_irq_set_wake(struct irq_data *d, unsigned int on)
+{
+	unsigned int idx = d->irq / 32 - 1;
+	u32 mask;
+
+	/* Sanity check for SPI irq */
+	if (d->irq < 32)
+		return -EINVAL;
+
+	mask = 1 << d->irq % 32;
+	gpc_wake_irqs[idx] = on ? gpc_wake_irqs[idx] | mask :
+				  gpc_wake_irqs[idx] & ~mask;
+
+	return 0;
+}
+
+static void imx_gpc_irq_unmask(struct irq_data *d)
+{
+	void __iomem *reg;
+	u32 val;
+
+	/* Sanity check for SPI irq */
+	if (d->irq < 32)
+		return;
+
+	reg = gpc_base + GPC_IMR1 + (d->irq / 32 - 1) * 4;
+	val = readl_relaxed(reg);
+	val &= ~(1 << d->irq % 32);
+	writel_relaxed(val, reg);
+}
+
+static void imx_gpc_irq_mask(struct irq_data *d)
+{
+	void __iomem *reg;
+	u32 val;
+
+	/* Sanity check for SPI irq */
+	if (d->irq < 32)
+		return;
+
+	reg = gpc_base + GPC_IMR1 + (d->irq / 32 - 1) * 4;
+	val = readl_relaxed(reg);
+	val |= 1 << (d->irq % 32);
+	writel_relaxed(val, reg);
+}
+
+void __init imx_gpc_init(void)
+{
+	struct device_node *np;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,imx6q-gpc");
+	gpc_base = of_iomap(np, 0);
+	WARN_ON(!gpc_base);
+
+	/* Register GPC as the secondary interrupt controller behind GIC */
+	gic_arch_extn.irq_mask = imx_gpc_irq_mask;
+	gic_arch_extn.irq_unmask = imx_gpc_irq_unmask;
+	gic_arch_extn.irq_set_wake = imx_gpc_irq_set_wake;
+}
