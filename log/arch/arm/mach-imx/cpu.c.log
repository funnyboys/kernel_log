commit 52102a3ba6a617449f4b057880d73be93310a7c7
Author: Peng Fan <peng.fan@nxp.com>
Date:   Wed May 20 13:51:29 2020 +0800

    soc: imx: move cpu code to drivers/soc/imx
    
    Move the soc device register code to drivers/soc/imx to align with
    i.MX8.
    
    Signed-off-by: Peng Fan <peng.fan@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index 75ffcba9f878..65c7224f5250 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -1,25 +1,13 @@
 // SPDX-License-Identifier: GPL-2.0
 #include <linux/err.h>
-#include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/io.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
-#include <linux/regmap.h>
-#include <linux/slab.h>
-#include <linux/sys_soc.h>
 
 #include "hardware.h"
 #include "common.h"
 
-#define OCOTP_UID_H	0x420
-#define OCOTP_UID_L	0x410
-
-#define OCOTP_ULP_UID_1		0x4b0
-#define OCOTP_ULP_UID_2		0x4c0
-#define OCOTP_ULP_UID_3		0x4d0
-#define OCOTP_ULP_UID_4		0x4e0
-
 unsigned int __mxc_cpu_type;
 static unsigned int imx_soc_revision;
 
@@ -82,173 +70,3 @@ void __init imx_aips_allow_unprivileged_access(
 		imx_set_aips(aips_base_addr);
 	}
 }
-
-static int __init imx_soc_device_init(void)
-{
-	struct soc_device_attribute *soc_dev_attr;
-	const char *ocotp_compat = NULL;
-	struct soc_device *soc_dev;
-	struct device_node *root;
-	struct regmap *ocotp = NULL;
-	const char *soc_id;
-	u64 soc_uid = 0;
-	u32 val;
-	int ret;
-
-	soc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);
-	if (!soc_dev_attr)
-		return -ENOMEM;
-
-	soc_dev_attr->family = "Freescale i.MX";
-
-	root = of_find_node_by_path("/");
-	ret = of_property_read_string(root, "model", &soc_dev_attr->machine);
-	of_node_put(root);
-	if (ret)
-		goto free_soc;
-
-	switch (__mxc_cpu_type) {
-	case MXC_CPU_MX1:
-		soc_id = "i.MX1";
-		break;
-	case MXC_CPU_MX21:
-		soc_id = "i.MX21";
-		break;
-	case MXC_CPU_MX25:
-		soc_id = "i.MX25";
-		break;
-	case MXC_CPU_MX27:
-		soc_id = "i.MX27";
-		break;
-	case MXC_CPU_MX31:
-		soc_id = "i.MX31";
-		break;
-	case MXC_CPU_MX35:
-		soc_id = "i.MX35";
-		break;
-	case MXC_CPU_MX51:
-		soc_id = "i.MX51";
-		break;
-	case MXC_CPU_MX53:
-		soc_id = "i.MX53";
-		break;
-	case MXC_CPU_IMX6SL:
-		ocotp_compat = "fsl,imx6sl-ocotp";
-		soc_id = "i.MX6SL";
-		break;
-	case MXC_CPU_IMX6DL:
-		ocotp_compat = "fsl,imx6q-ocotp";
-		soc_id = "i.MX6DL";
-		break;
-	case MXC_CPU_IMX6SX:
-		ocotp_compat = "fsl,imx6sx-ocotp";
-		soc_id = "i.MX6SX";
-		break;
-	case MXC_CPU_IMX6Q:
-		ocotp_compat = "fsl,imx6q-ocotp";
-		soc_id = "i.MX6Q";
-		break;
-	case MXC_CPU_IMX6UL:
-		ocotp_compat = "fsl,imx6ul-ocotp";
-		soc_id = "i.MX6UL";
-		break;
-	case MXC_CPU_IMX6ULL:
-		ocotp_compat = "fsl,imx6ull-ocotp";
-		soc_id = "i.MX6ULL";
-		break;
-	case MXC_CPU_IMX6ULZ:
-		ocotp_compat = "fsl,imx6ull-ocotp";
-		soc_id = "i.MX6ULZ";
-		break;
-	case MXC_CPU_IMX6SLL:
-		ocotp_compat = "fsl,imx6sll-ocotp";
-		soc_id = "i.MX6SLL";
-		break;
-	case MXC_CPU_IMX7D:
-		ocotp_compat = "fsl,imx7d-ocotp";
-		soc_id = "i.MX7D";
-		break;
-	case MXC_CPU_IMX7ULP:
-		ocotp_compat = "fsl,imx7ulp-ocotp";
-		soc_id = "i.MX7ULP";
-		break;
-	case MXC_CPU_VF500:
-		ocotp_compat = "fsl,vf610-ocotp";
-		soc_id = "VF500";
-		break;
-	case MXC_CPU_VF510:
-		ocotp_compat = "fsl,vf610-ocotp";
-		soc_id = "VF510";
-		break;
-	case MXC_CPU_VF600:
-		ocotp_compat = "fsl,vf610-ocotp";
-		soc_id = "VF600";
-		break;
-	case MXC_CPU_VF610:
-		ocotp_compat = "fsl,vf610-ocotp";
-		soc_id = "VF610";
-		break;
-	default:
-		soc_id = "Unknown";
-	}
-	soc_dev_attr->soc_id = soc_id;
-
-	if (ocotp_compat) {
-		ocotp = syscon_regmap_lookup_by_compatible(ocotp_compat);
-		if (IS_ERR(ocotp))
-			pr_err("%s: failed to find %s regmap!\n", __func__, ocotp_compat);
-	}
-
-	if (!IS_ERR_OR_NULL(ocotp)) {
-		if (__mxc_cpu_type == MXC_CPU_IMX7ULP) {
-			regmap_read(ocotp, OCOTP_ULP_UID_4, &val);
-			soc_uid = val & 0xffff;
-			regmap_read(ocotp, OCOTP_ULP_UID_3, &val);
-			soc_uid <<= 16;
-			soc_uid |= val & 0xffff;
-			regmap_read(ocotp, OCOTP_ULP_UID_2, &val);
-			soc_uid <<= 16;
-			soc_uid |= val & 0xffff;
-			regmap_read(ocotp, OCOTP_ULP_UID_1, &val);
-			soc_uid <<= 16;
-			soc_uid |= val & 0xffff;
-		} else {
-			regmap_read(ocotp, OCOTP_UID_H, &val);
-			soc_uid = val;
-			regmap_read(ocotp, OCOTP_UID_L, &val);
-			soc_uid <<= 32;
-			soc_uid |= val;
-		}
-	}
-
-	soc_dev_attr->revision = kasprintf(GFP_KERNEL, "%d.%d",
-					   (imx_soc_revision >> 4) & 0xf,
-					   imx_soc_revision & 0xf);
-	if (!soc_dev_attr->revision) {
-		ret = -ENOMEM;
-		goto free_soc;
-	}
-
-	soc_dev_attr->serial_number = kasprintf(GFP_KERNEL, "%016llX", soc_uid);
-	if (!soc_dev_attr->serial_number) {
-		ret = -ENOMEM;
-		goto free_rev;
-	}
-
-	soc_dev = soc_device_register(soc_dev_attr);
-	if (IS_ERR(soc_dev)) {
-		ret = PTR_ERR(soc_dev);
-		goto free_serial_number;
-	}
-
-	return 0;
-
-free_serial_number:
-	kfree(soc_dev_attr->serial_number);
-free_rev:
-	kfree(soc_dev_attr->revision);
-free_soc:
-	kfree(soc_dev_attr);
-	return ret;
-}
-device_initcall(imx_soc_device_init);

commit d2199b34871b859d33cd08398af5f1530241cb4e
Author: Peng Fan <peng.fan@nxp.com>
Date:   Wed May 20 13:51:27 2020 +0800

    ARM: imx: use device_initcall for imx_soc_device_init
    
    This is preparation to move imx_soc_device_init to drivers/soc/imx/
    
    There is no reason to must put dt devices under /sys/devices/soc0,
    they could also be under /sys/devices/platform, so we could
    pass NULL as parent when calling of_platform_default_populate.
    
    Following soc-imx8.c soc-imx-scu.c using device_initcall, need
    to change return type to int type for imx_soc_device_init.
    
    Signed-off-by: Peng Fan <peng.fan@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index e3d12b21d6f6..75ffcba9f878 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -83,7 +83,7 @@ void __init imx_aips_allow_unprivileged_access(
 	}
 }
 
-struct device * __init imx_soc_device_init(void)
+static int __init imx_soc_device_init(void)
 {
 	struct soc_device_attribute *soc_dev_attr;
 	const char *ocotp_compat = NULL;
@@ -97,7 +97,7 @@ struct device * __init imx_soc_device_init(void)
 
 	soc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);
 	if (!soc_dev_attr)
-		return NULL;
+		return -ENOMEM;
 
 	soc_dev_attr->family = "Freescale i.MX";
 
@@ -224,18 +224,24 @@ struct device * __init imx_soc_device_init(void)
 	soc_dev_attr->revision = kasprintf(GFP_KERNEL, "%d.%d",
 					   (imx_soc_revision >> 4) & 0xf,
 					   imx_soc_revision & 0xf);
-	if (!soc_dev_attr->revision)
+	if (!soc_dev_attr->revision) {
+		ret = -ENOMEM;
 		goto free_soc;
+	}
 
 	soc_dev_attr->serial_number = kasprintf(GFP_KERNEL, "%016llX", soc_uid);
-	if (!soc_dev_attr->serial_number)
+	if (!soc_dev_attr->serial_number) {
+		ret = -ENOMEM;
 		goto free_rev;
+	}
 
 	soc_dev = soc_device_register(soc_dev_attr);
-	if (IS_ERR(soc_dev))
+	if (IS_ERR(soc_dev)) {
+		ret = PTR_ERR(soc_dev);
 		goto free_serial_number;
+	}
 
-	return soc_device_to_device(soc_dev);
+	return 0;
 
 free_serial_number:
 	kfree(soc_dev_attr->serial_number);
@@ -243,5 +249,6 @@ struct device * __init imx_soc_device_init(void)
 	kfree(soc_dev_attr->revision);
 free_soc:
 	kfree(soc_dev_attr);
-	return NULL;
+	return ret;
 }
+device_initcall(imx_soc_device_init);

commit dceb213ca4a7a8778786bb2eb49ade722a083fdc
Author: Andrey Smirnov <andrew.smirnov@gmail.com>
Date:   Thu Mar 26 10:42:32 2020 -0700

    ARM: vf610: report soc info via soc device
    
    The patch adds plumbing to soc device info code necessary to support
    Vybrid devices. Use case in mind for this is CAAM driver, which
    utilizes said API.
    
    Signed-off-by: Andrey Smirnov <andrew.smirnov@gmail.com>
    Cc: Lucas Stach <l.stach@pengutronix.de>
    Cc: Chris Healy <cphealy@gmail.com>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-imx@nxp.com
    Tested-by: Chris Healy <cphealy@gmail.com>
    Reviewed-by: Fabio Estevam <festevam@gmail.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index 06f8d64b65af..e3d12b21d6f6 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -172,6 +172,22 @@ struct device * __init imx_soc_device_init(void)
 		ocotp_compat = "fsl,imx7ulp-ocotp";
 		soc_id = "i.MX7ULP";
 		break;
+	case MXC_CPU_VF500:
+		ocotp_compat = "fsl,vf610-ocotp";
+		soc_id = "VF500";
+		break;
+	case MXC_CPU_VF510:
+		ocotp_compat = "fsl,vf610-ocotp";
+		soc_id = "VF510";
+		break;
+	case MXC_CPU_VF600:
+		ocotp_compat = "fsl,vf610-ocotp";
+		soc_id = "VF600";
+		break;
+	case MXC_CPU_VF610:
+		ocotp_compat = "fsl,vf610-ocotp";
+		soc_id = "VF610";
+		break;
 	default:
 		soc_id = "Unknown";
 	}

commit b3082f1bf8a604c9a0f483b5d6060d7255c2a51b
Author: Anson Huang <Anson.Huang@nxp.com>
Date:   Mon Nov 4 15:35:31 2019 +0800

    ARM: imx: Add i.MX7ULP SoC serial number support
    
    i.MX7ULP's unique ID layout in OCOTP is different from other
    i.MX6/7 SoCs as below:
    
    OCOTP layout            unique ID
    
    0x4b0 bit[15:0]         bit[15:0]
    0x4c0 bit[15:0]         bit[31:16]
    0x4d0 bit[15:0]         bit[47:32]
    0x4e0 bit[15:0]         bit[63:48]
    
    Add support for reading serial number from OCOTP on i.MX7ULP.
    
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index 871f98342d50..06f8d64b65af 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -15,6 +15,11 @@
 #define OCOTP_UID_H	0x420
 #define OCOTP_UID_L	0x410
 
+#define OCOTP_ULP_UID_1		0x4b0
+#define OCOTP_ULP_UID_2		0x4c0
+#define OCOTP_ULP_UID_3		0x4d0
+#define OCOTP_ULP_UID_4		0x4e0
+
 unsigned int __mxc_cpu_type;
 static unsigned int imx_soc_revision;
 
@@ -164,6 +169,7 @@ struct device * __init imx_soc_device_init(void)
 		soc_id = "i.MX7D";
 		break;
 	case MXC_CPU_IMX7ULP:
+		ocotp_compat = "fsl,imx7ulp-ocotp";
 		soc_id = "i.MX7ULP";
 		break;
 	default:
@@ -178,11 +184,25 @@ struct device * __init imx_soc_device_init(void)
 	}
 
 	if (!IS_ERR_OR_NULL(ocotp)) {
-		regmap_read(ocotp, OCOTP_UID_H, &val);
-		soc_uid = val;
-		regmap_read(ocotp, OCOTP_UID_L, &val);
-		soc_uid <<= 32;
-		soc_uid |= val;
+		if (__mxc_cpu_type == MXC_CPU_IMX7ULP) {
+			regmap_read(ocotp, OCOTP_ULP_UID_4, &val);
+			soc_uid = val & 0xffff;
+			regmap_read(ocotp, OCOTP_ULP_UID_3, &val);
+			soc_uid <<= 16;
+			soc_uid |= val & 0xffff;
+			regmap_read(ocotp, OCOTP_ULP_UID_2, &val);
+			soc_uid <<= 16;
+			soc_uid |= val & 0xffff;
+			regmap_read(ocotp, OCOTP_ULP_UID_1, &val);
+			soc_uid <<= 16;
+			soc_uid |= val & 0xffff;
+		} else {
+			regmap_read(ocotp, OCOTP_UID_H, &val);
+			soc_uid = val;
+			regmap_read(ocotp, OCOTP_UID_L, &val);
+			soc_uid <<= 32;
+			soc_uid |= val;
+		}
 	}
 
 	soc_dev_attr->revision = kasprintf(GFP_KERNEL, "%d.%d",

commit 7947e3238b64c00c396e6f5738f94c4d653bc6a2
Author: Leonard Crestez <leonard.crestez@nxp.com>
Date:   Tue Dec 10 23:49:28 2019 +0200

    ARM: imx: Fix boot crash if ocotp is not found
    
    The imx_soc_device_init functions tries to fetch the ocotp regmap in
    order to soc serial number. If regmap fetch fails then a message is
    printed but regmap_read is called anyway and the system crashes.
    
    Failing to lookup ocotp regmap shouldn't be a fatal boot error so check
    that the pointer is valid.
    
    Only side-effect of ocotp lookup failure now is that serial number will
    be reported as all-zeros which is acceptable.
    
    Cc: stable@vger.kernel.org
    Fixes: 8267ff89b713 ("ARM: imx: Add serial number support for i.MX6/7 SoCs")
    Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
    Tested-by: Christoph Niedermaier <cniedermaier@dh-electronics.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index 0fb0c4a264c3..871f98342d50 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -84,7 +84,7 @@ struct device * __init imx_soc_device_init(void)
 	const char *ocotp_compat = NULL;
 	struct soc_device *soc_dev;
 	struct device_node *root;
-	struct regmap *ocotp;
+	struct regmap *ocotp = NULL;
 	const char *soc_id;
 	u64 soc_uid = 0;
 	u32 val;
@@ -175,7 +175,9 @@ struct device * __init imx_soc_device_init(void)
 		ocotp = syscon_regmap_lookup_by_compatible(ocotp_compat);
 		if (IS_ERR(ocotp))
 			pr_err("%s: failed to find %s regmap!\n", __func__, ocotp_compat);
+	}
 
+	if (!IS_ERR_OR_NULL(ocotp)) {
 		regmap_read(ocotp, OCOTP_UID_H, &val);
 		soc_uid = val;
 		regmap_read(ocotp, OCOTP_UID_L, &val);

commit 125ad46f3861520fdebd15c38e4bc412a7add01c
Author: Christoph Niedermaier <cniedermaier@dh-electronics.com>
Date:   Thu Dec 5 09:38:51 2019 +0000

    ARM: imx: Correct ocotp id for serial number support of i.MX6ULL/ULZ SoCs
    
    After the commit 8267ff89b713 ("ARM: imx: Add serial number support for i.MX6/7 SoCs")
    the kernel doesn't start on i.MX6ULL/ULZ SoC.
    Tested on next-20191205.
    
    For i.MX6ULL/ULZ the variable "ocotp_compat" is set to "fsl,imx6ul-ocotp", but with commit
    ffbc34bf0e9c ("nvmem: imx-ocotp: Implement i.MX6ULL/ULZ support") and commit
    f243bc821ee3 ("ARM: dts: imx6ull: Fix i.MX6ULL/ULZ ocotp compatible") the value
    "fsl,imx6ull-ocotp" is already defined and set in device tree...
    
    By setting "ocotp_compat" to "fsl,imx6ull-ocotp" the kernel does boot.
    
    Fixes: 8267ff89b713 ("ARM: imx: Add serial number support for i.MX6/7 SoCs")
    Signed-off-by: Christoph Niedermaier <cniedermaier@dh-electronics.com>
    Reviewed-by: Fabio Estevam <festevam@gmail.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index d8118031c51f..0fb0c4a264c3 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -148,11 +148,11 @@ struct device * __init imx_soc_device_init(void)
 		soc_id = "i.MX6UL";
 		break;
 	case MXC_CPU_IMX6ULL:
-		ocotp_compat = "fsl,imx6ul-ocotp";
+		ocotp_compat = "fsl,imx6ull-ocotp";
 		soc_id = "i.MX6ULL";
 		break;
 	case MXC_CPU_IMX6ULZ:
-		ocotp_compat = "fsl,imx6ul-ocotp";
+		ocotp_compat = "fsl,imx6ull-ocotp";
 		soc_id = "i.MX6ULZ";
 		break;
 	case MXC_CPU_IMX6SLL:

commit 8267ff89b71317407f2c6938bd66f3a87070e45f
Author: Anson Huang <Anson.Huang@nxp.com>
Date:   Mon Oct 28 17:16:01 2019 +0800

    ARM: imx: Add serial number support for i.MX6/7 SoCs
    
    i.MX6/7 SoCs have a 64-bit SoC unique ID stored in OCOTP,
    it can be used as SoC serial number, add this support for
    i.MX6Q/6DL/6SL/6SX/6SLL/6UL/6ULL/6ULZ/7D, see below example
    on i.MX6Q:
    
    root@imx6qpdlsolox:~# cat /sys/devices/soc0/serial_number
    240F31D4E1FDFCA7
    
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index 0b137eeffb61..d8118031c51f 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -1,15 +1,20 @@
 // SPDX-License-Identifier: GPL-2.0
 #include <linux/err.h>
+#include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/io.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
+#include <linux/regmap.h>
 #include <linux/slab.h>
 #include <linux/sys_soc.h>
 
 #include "hardware.h"
 #include "common.h"
 
+#define OCOTP_UID_H	0x420
+#define OCOTP_UID_L	0x410
+
 unsigned int __mxc_cpu_type;
 static unsigned int imx_soc_revision;
 
@@ -76,9 +81,13 @@ void __init imx_aips_allow_unprivileged_access(
 struct device * __init imx_soc_device_init(void)
 {
 	struct soc_device_attribute *soc_dev_attr;
+	const char *ocotp_compat = NULL;
 	struct soc_device *soc_dev;
 	struct device_node *root;
+	struct regmap *ocotp;
 	const char *soc_id;
+	u64 soc_uid = 0;
+	u32 val;
 	int ret;
 
 	soc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);
@@ -119,30 +128,39 @@ struct device * __init imx_soc_device_init(void)
 		soc_id = "i.MX53";
 		break;
 	case MXC_CPU_IMX6SL:
+		ocotp_compat = "fsl,imx6sl-ocotp";
 		soc_id = "i.MX6SL";
 		break;
 	case MXC_CPU_IMX6DL:
+		ocotp_compat = "fsl,imx6q-ocotp";
 		soc_id = "i.MX6DL";
 		break;
 	case MXC_CPU_IMX6SX:
+		ocotp_compat = "fsl,imx6sx-ocotp";
 		soc_id = "i.MX6SX";
 		break;
 	case MXC_CPU_IMX6Q:
+		ocotp_compat = "fsl,imx6q-ocotp";
 		soc_id = "i.MX6Q";
 		break;
 	case MXC_CPU_IMX6UL:
+		ocotp_compat = "fsl,imx6ul-ocotp";
 		soc_id = "i.MX6UL";
 		break;
 	case MXC_CPU_IMX6ULL:
+		ocotp_compat = "fsl,imx6ul-ocotp";
 		soc_id = "i.MX6ULL";
 		break;
 	case MXC_CPU_IMX6ULZ:
+		ocotp_compat = "fsl,imx6ul-ocotp";
 		soc_id = "i.MX6ULZ";
 		break;
 	case MXC_CPU_IMX6SLL:
+		ocotp_compat = "fsl,imx6sll-ocotp";
 		soc_id = "i.MX6SLL";
 		break;
 	case MXC_CPU_IMX7D:
+		ocotp_compat = "fsl,imx7d-ocotp";
 		soc_id = "i.MX7D";
 		break;
 	case MXC_CPU_IMX7ULP:
@@ -153,18 +171,36 @@ struct device * __init imx_soc_device_init(void)
 	}
 	soc_dev_attr->soc_id = soc_id;
 
+	if (ocotp_compat) {
+		ocotp = syscon_regmap_lookup_by_compatible(ocotp_compat);
+		if (IS_ERR(ocotp))
+			pr_err("%s: failed to find %s regmap!\n", __func__, ocotp_compat);
+
+		regmap_read(ocotp, OCOTP_UID_H, &val);
+		soc_uid = val;
+		regmap_read(ocotp, OCOTP_UID_L, &val);
+		soc_uid <<= 32;
+		soc_uid |= val;
+	}
+
 	soc_dev_attr->revision = kasprintf(GFP_KERNEL, "%d.%d",
 					   (imx_soc_revision >> 4) & 0xf,
 					   imx_soc_revision & 0xf);
 	if (!soc_dev_attr->revision)
 		goto free_soc;
 
+	soc_dev_attr->serial_number = kasprintf(GFP_KERNEL, "%016llX", soc_uid);
+	if (!soc_dev_attr->serial_number)
+		goto free_rev;
+
 	soc_dev = soc_device_register(soc_dev_attr);
 	if (IS_ERR(soc_dev))
-		goto free_rev;
+		goto free_serial_number;
 
 	return soc_device_to_device(soc_dev);
 
+free_serial_number:
+	kfree(soc_dev_attr->serial_number);
 free_rev:
 	kfree(soc_dev_attr->revision);
 free_soc:

commit de70d0e9d43dd5fa899ce3a1560a4d2536b6b71e
Author: A.s. Dong <aisheng.dong@nxp.com>
Date:   Sat Nov 10 15:13:04 2018 +0000

    ARM: imx: add initial support for imx7ulp
    
    The i.MX 7ULP family of processors features NXP's advanced implementation
    of the Arm Cortex-A7 core, the Arm Cortex-M4 core, as well as a 3D and 2D
    Graphics Processing Units (GPUs).
    
    This patch aims to add an initial support for imx7ulp. Note that we need
    configure power mode to Partial Stop mode 3 with system/bus clock enabled
    first as the default enabled STOP mode will gate off system/bus clock when
    execute WFI in MX7ULP SoC.
    
    And there's still no MXC_CPU_IMX7ULP IDs read from register as ULP has no
    anatop as before. So we encode one with 0xff in reverse order in case new
    ones will be in the future.
    
    Cc: Shawn Guo <shawnguo@kernel.org>
    Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
    Reviewed-by: Fabio Estevam <festevam@gmail.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index c73593e09121..0b137eeffb61 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -145,6 +145,9 @@ struct device * __init imx_soc_device_init(void)
 	case MXC_CPU_IMX7D:
 		soc_id = "i.MX7D";
 		break;
+	case MXC_CPU_IMX7ULP:
+		soc_id = "i.MX7ULP";
+		break;
 	default:
 		soc_id = "Unknown";
 	}

commit c90dec00cc84942614bc41f75dc24a87b6d5763b
Author: Anson Huang <Anson.Huang@nxp.com>
Date:   Sun Sep 30 11:32:26 2018 +0800

    ARM: imx: add i.mx6ulz msl support
    
    The i.MX 6ULZ processor is a high-performance, ultra
    cost-efficient consumer Linux processor featuring an
    advanced implementation of a single Arm® Cortex®-A7 core,
    which operates at speeds up to 900 MHz.
    
    This patch adds basic MSL support for i.MX6ULZ, the
    i.MX6ULZ has same soc_id as i.MX6ULL, and SRC_SBMR2 bit[6]
    is to differentiate i.MX6ULZ from i.MX6ULL, 1'b1 means
    i.MX6ULZ and 1'b0 means i.MX6ULL.
    
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index c6b1bf97a6c1..c73593e09121 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -136,6 +136,9 @@ struct device * __init imx_soc_device_init(void)
 	case MXC_CPU_IMX6ULL:
 		soc_id = "i.MX6ULL";
 		break;
+	case MXC_CPU_IMX6ULZ:
+		soc_id = "i.MX6ULZ";
+		break;
 	case MXC_CPU_IMX6SLL:
 		soc_id = "i.MX6SLL";
 		break;

commit cff70654d8289311c427625020d9f74348ad856e
Author: Nicholas Mc Guire <hofrat@osadl.org>
Date:   Sun Jul 8 10:32:54 2018 +0200

    ARM: imx: flag failure of of_iomap
    
     imx_set_aips is assuming that the address returned from of_iomap is
    valid which it probably is in the normal case - as the call site
    is void error propagation is not possible but never the less at least
    a WARN_ON() seems warranted here.
    
    Signed-off-by: Nicholas Mc Guire <hofrat@osadl.org>
    Fixes: commit e57e4ab5fc2e ("ARM: i.MX: allow disabling supervisor protect via DT")
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index 32969f34486a..c6b1bf97a6c1 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -68,6 +68,7 @@ void __init imx_aips_allow_unprivileged_access(
 
 	for_each_compatible_node(np, NULL, compat) {
 		aips_base_addr = of_iomap(np, 0);
+		WARN_ON(!aips_base_addr);
 		imx_set_aips(aips_base_addr);
 	}
 }

commit dee5dee2a5b285d20f55a4758d3a51349691eeea
Author: Bai Ping <ping.bai@nxp.com>
Date:   Thu Mar 8 17:34:55 2018 +0800

    ARM: imx: Add basic msl support for imx6sll
    
    Add basic MSL support for i.MX6SLL.
    
    The i.MX 6SoloLiteLite application processors are NXP's latest
    additions to a growing family of multimedia-focused products
    offering high-performance processing optimized for lowest power
    consumption. The i.MX 6SoloLiteLite processors feature NXP's advanced
    implementation of the ARM Cortex-A9 core, which can be interfaced
    with LPDDR3 and LPDDR2 DRAM memory devices.
    
    Signed-off-by: Bai Ping <ping.bai@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index d4e55f2a897e..32969f34486a 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -135,6 +135,9 @@ struct device * __init imx_soc_device_init(void)
 	case MXC_CPU_IMX6ULL:
 		soc_id = "i.MX6ULL";
 		break;
+	case MXC_CPU_IMX6SLL:
+		soc_id = "i.MX6SLL";
+		break;
 	case MXC_CPU_IMX7D:
 		soc_id = "i.MX7D";
 		break;

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index 94906ed49392..d4e55f2a897e 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 #include <linux/err.h>
 #include <linux/module.h>
 #include <linux/io.h>

commit b3ea575770c7eeb259c77b6861cd14d00eb309df
Author: Leonard Crestez <leonard.crestez@nxp.com>
Date:   Tue Jun 6 20:50:42 2017 +0300

    ARM: imx: Add MXC_CPU_IMX6ULL and cpu_is_imx6ull
    
    Support for imx6ull is already present but it's based on
    of_machine_is_compatible("fsl,imx6ull") checks. Add it to the MXC_CPU_*
    enumeration as well.
    
    This also fixes /sys/devices/soc0/soc_id reading "Unknown".
    
    Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
    Reviewed-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index b3347d32349f..94906ed49392 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -131,6 +131,9 @@ struct device * __init imx_soc_device_init(void)
 	case MXC_CPU_IMX6UL:
 		soc_id = "i.MX6UL";
 		break;
+	case MXC_CPU_IMX6ULL:
+		soc_id = "i.MX6ULL";
+		break;
 	case MXC_CPU_IMX7D:
 		soc_id = "i.MX7D";
 		break;

commit 44af782227b3977b98be6967533b0d23add40eb4
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jun 24 12:50:01 2016 +0200

    ARM: imx: remove cpu_is_mx*()
    
    The mxc_cpu_type and cpu_is_mx() logic is largely unused, and the
    few remaining users were easy to convert into simpler code. Now that
    they are gone, we can remove all those macros as well.
    
    The related cpu_is_imx6*() set of function unfortunately is harder
    to remove, so those are staying around for now.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index 6a96b7cf468f..b3347d32349f 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -10,8 +10,6 @@
 #include "common.h"
 
 unsigned int __mxc_cpu_type;
-EXPORT_SYMBOL(__mxc_cpu_type);
-
 static unsigned int imx_soc_revision;
 
 void mxc_set_cpu_type(unsigned int type)

commit c553138fbd1ee193a19101a36fb0814607ab4e7b
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Jan 27 17:59:35 2016 +0100

    ARM: imx: use endian-safe readl/readw/writel/writew
    
    Instead of __raw_*, define imx_* to *_relaxed and use those.
    
    Using imx_* was requested by Arnd because *_relaxed tends to
    indicate that the code was carefully reviewed to not require
    any synchronisation and otherwise be safe, which isn't the
    case here with the automatic conversion.
    
    The conversion itself was done using the following spatch
    (since that automatically adjusts the coding style unlike
    a simple search&replace).
    
    @@
    expression E1, E2;
    @@
    -__raw_writel(E1, E2)
    +imx_writel(E1, E2)
    @@
    expression E1, E2;
    @@
    -__raw_writew(E1, E2)
    +imx_writew(E1, E2)
    @@
    expression E1;
    @@
    -__raw_readl(E1)
    +imx_readl(E1)
    @@
    expression E1;
    @@
    -__raw_readw(E1)
    +imx_readw(E1)
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index 5b0f752d5507..6a96b7cf468f 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -45,20 +45,20 @@ void __init imx_set_aips(void __iomem *base)
  * Set all MPROTx to be non-bufferable, trusted for R/W,
  * not forced to user-mode.
  */
-	__raw_writel(0x77777777, base + 0x0);
-	__raw_writel(0x77777777, base + 0x4);
+	imx_writel(0x77777777, base + 0x0);
+	imx_writel(0x77777777, base + 0x4);
 
 /*
  * Set all OPACRx to be non-bufferable, to not require
  * supervisor privilege level for access, allow for
  * write access and untrusted master access.
  */
-	__raw_writel(0x0, base + 0x40);
-	__raw_writel(0x0, base + 0x44);
-	__raw_writel(0x0, base + 0x48);
-	__raw_writel(0x0, base + 0x4C);
-	reg = __raw_readl(base + 0x50) & 0x00FFFFFF;
-	__raw_writel(reg, base + 0x50);
+	imx_writel(0x0, base + 0x40);
+	imx_writel(0x0, base + 0x44);
+	imx_writel(0x0, base + 0x48);
+	imx_writel(0x0, base + 0x4C);
+	reg = imx_readl(base + 0x50) & 0x00FFFFFF;
+	imx_writel(reg, base + 0x50);
 }
 
 void __init imx_aips_allow_unprivileged_access(

commit 022d0716bb7e8e0f11eff4ee65fb1e62ffe8f6e1
Author: Frank Li <Frank.Li@freescale.com>
Date:   Fri Jul 10 02:09:41 2015 +0800

    ARM: imx: add i.mx6ul msl support
    
    i.MX6UL is a new SOC, add MSL support
    
    Signed-off-by: Frank Li <Frank.Li@freescale.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index a7fa92a7b1d7..5b0f752d5507 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -130,6 +130,9 @@ struct device * __init imx_soc_device_init(void)
 	case MXC_CPU_IMX6Q:
 		soc_id = "i.MX6Q";
 		break;
+	case MXC_CPU_IMX6UL:
+		soc_id = "i.MX6UL";
+		break;
 	case MXC_CPU_IMX7D:
 		soc_id = "i.MX7D";
 		break;

commit 5739b919cf6c1395f3f58dd7759bf0555fb68769
Author: Anson Huang <b20788@freescale.com>
Date:   Fri May 8 01:35:55 2015 +0800

    ARM: imx: add msl support for imx7d
    
    Add i.MX7D MSL support.
    
    Signed-off-by: Anson Huang <b20788@freescale.com>
    Signed-off-by: Frank Li <Frank.Li@freescale.com>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index df42c14ff749..a7fa92a7b1d7 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -130,6 +130,9 @@ struct device * __init imx_soc_device_init(void)
 	case MXC_CPU_IMX6Q:
 		soc_id = "i.MX6Q";
 		break;
+	case MXC_CPU_IMX7D:
+		soc_id = "i.MX7D";
+		break;
 	default:
 		soc_id = "Unknown";
 	}

commit e57e4ab5fc2e4e58447d13493c3e567b61359523
Author: Steffen Trumtrar <s.trumtrar@pengutronix.de>
Date:   Mon Jul 7 11:41:26 2014 +0200

    ARM: i.MX: allow disabling supervisor protect via DT
    
    The i.MX SoCs allow to setup fine grained access rights to peripherals on the
    AIPS bus.
    This is done via the Peripheral Access Register (PAR) in e.g. the i.MX21
    or in later SoC versions the Off-Platform Peripheral Access Control Register
    (OPACR), e.g. i.MX53.
    Under certain circumstances this leads to problems in which bus masters are
    not granted their access rights to peripherals.
    To be able to disable these restrictions on DT platforms, add a helper function
    that looks for AIPS nodes in the DT and disables them for every compatible node
    it finds.
    The compatible has to be declared in the mach-specific entry file, where this
    helper function should then be called.
    
    Signed-off-by: Steffen Trumtrar <s.trumtrar@pengutronix.de>
    Signed-off-by: Shawn Guo <shawn.guo@freescale.com>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index bbe8ff1f0412..df42c14ff749 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -2,6 +2,7 @@
 #include <linux/module.h>
 #include <linux/io.h>
 #include <linux/of.h>
+#include <linux/of_address.h>
 #include <linux/slab.h>
 #include <linux/sys_soc.h>
 
@@ -60,6 +61,18 @@ void __init imx_set_aips(void __iomem *base)
 	__raw_writel(reg, base + 0x50);
 }
 
+void __init imx_aips_allow_unprivileged_access(
+		const char *compat)
+{
+	void __iomem *aips_base_addr;
+	struct device_node *np;
+
+	for_each_compatible_node(np, NULL, compat) {
+		aips_base_addr = of_iomap(np, 0);
+		imx_set_aips(aips_base_addr);
+	}
+}
+
 struct device * __init imx_soc_device_init(void)
 {
 	struct soc_device_attribute *soc_dev_attr;

commit d9654dceb315ccdabf4a5494109a4cc0fb2408a4
Author: Shawn Guo <shawn.guo@freescale.com>
Date:   Tue May 13 21:46:16 2014 +0800

    ARM: imx: add basic imx6sx SoC support
    
    Add basic suppport for i.MX6 SoloX SoC.
    
    Signed-off-by: Anson Huang <b20788@freescale.com>
    Signed-off-by: Shawn Guo <shawn.guo@freescale.com>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index ba3b498a67ec..bbe8ff1f0412 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -111,6 +111,9 @@ struct device * __init imx_soc_device_init(void)
 	case MXC_CPU_IMX6DL:
 		soc_id = "i.MX6DL";
 		break;
+	case MXC_CPU_IMX6SX:
+		soc_id = "i.MX6SX";
+		break;
 	case MXC_CPU_IMX6Q:
 		soc_id = "i.MX6Q";
 		break;

commit 1ddd35be8b71855329c4c7e8910b00fd2bc0f6dc
Author: Thierry Reding <thierry.reding@gmail.com>
Date:   Mon Sep 30 14:04:51 2013 +0200

    ARM: imx: Include linux/err.h
    
    The IS_ERR() macro is defined in the linux/err.h header file, so include
    it explicitly.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index fae2c9a78744..ba3b498a67ec 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -1,4 +1,4 @@
-
+#include <linux/err.h>
 #include <linux/module.h>
 #include <linux/io.h>
 #include <linux/of.h>

commit a28875462bd493fc1bb041c21f811b4a0577a497
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Tue Aug 13 16:59:28 2013 +0800

    ARM: imx6: report soc info via soc device
    
    The patch enables soc bus infrastructure and adds a function
    imx_soc_device_init() to report soc info via soc device interface for
    imx6qdl and imx6sl.  With the support, user space can get soc related
    info by looking at sysfs like below.
    
      $ cat /sys/devices/soc0/machine
      Freescale i.MX6 Quad SABRE Smart Device Board
      $ cat /sys/devices/soc0/family
      Freescale i.MX
      $ cat /sys/devices/soc0/soc_id
      i.MX6Q
      $ cat /sys/devices/soc0/revision
      1.2
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index 51f6c51ca878..fae2c9a78744 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -1,6 +1,9 @@
 
 #include <linux/module.h>
 #include <linux/io.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/sys_soc.h>
 
 #include "hardware.h"
 #include "common.h"
@@ -56,3 +59,81 @@ void __init imx_set_aips(void __iomem *base)
 	reg = __raw_readl(base + 0x50) & 0x00FFFFFF;
 	__raw_writel(reg, base + 0x50);
 }
+
+struct device * __init imx_soc_device_init(void)
+{
+	struct soc_device_attribute *soc_dev_attr;
+	struct soc_device *soc_dev;
+	struct device_node *root;
+	const char *soc_id;
+	int ret;
+
+	soc_dev_attr = kzalloc(sizeof(*soc_dev_attr), GFP_KERNEL);
+	if (!soc_dev_attr)
+		return NULL;
+
+	soc_dev_attr->family = "Freescale i.MX";
+
+	root = of_find_node_by_path("/");
+	ret = of_property_read_string(root, "model", &soc_dev_attr->machine);
+	of_node_put(root);
+	if (ret)
+		goto free_soc;
+
+	switch (__mxc_cpu_type) {
+	case MXC_CPU_MX1:
+		soc_id = "i.MX1";
+		break;
+	case MXC_CPU_MX21:
+		soc_id = "i.MX21";
+		break;
+	case MXC_CPU_MX25:
+		soc_id = "i.MX25";
+		break;
+	case MXC_CPU_MX27:
+		soc_id = "i.MX27";
+		break;
+	case MXC_CPU_MX31:
+		soc_id = "i.MX31";
+		break;
+	case MXC_CPU_MX35:
+		soc_id = "i.MX35";
+		break;
+	case MXC_CPU_MX51:
+		soc_id = "i.MX51";
+		break;
+	case MXC_CPU_MX53:
+		soc_id = "i.MX53";
+		break;
+	case MXC_CPU_IMX6SL:
+		soc_id = "i.MX6SL";
+		break;
+	case MXC_CPU_IMX6DL:
+		soc_id = "i.MX6DL";
+		break;
+	case MXC_CPU_IMX6Q:
+		soc_id = "i.MX6Q";
+		break;
+	default:
+		soc_id = "Unknown";
+	}
+	soc_dev_attr->soc_id = soc_id;
+
+	soc_dev_attr->revision = kasprintf(GFP_KERNEL, "%d.%d",
+					   (imx_soc_revision >> 4) & 0xf,
+					   imx_soc_revision & 0xf);
+	if (!soc_dev_attr->revision)
+		goto free_soc;
+
+	soc_dev = soc_device_register(soc_dev_attr);
+	if (IS_ERR(soc_dev))
+		goto free_rev;
+
+	return soc_device_to_device(soc_dev);
+
+free_rev:
+	kfree(soc_dev_attr->revision);
+free_soc:
+	kfree(soc_dev_attr);
+	return NULL;
+}

commit bfefdff8f91aa0a9ff1291d18d54498af276a6e5
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Tue Aug 13 13:54:02 2013 +0800

    ARM: imx: add soc revision helper functions
    
    Similar to what we do for cpu type, the patch adds helper functions
    imx_set_soc_revision() and imx_get_soc_revision() to maintain
    imx_soc_revision in cpu.c.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index e70e3acbf9bd..51f6c51ca878 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -8,11 +8,23 @@
 unsigned int __mxc_cpu_type;
 EXPORT_SYMBOL(__mxc_cpu_type);
 
+static unsigned int imx_soc_revision;
+
 void mxc_set_cpu_type(unsigned int type)
 {
 	__mxc_cpu_type = type;
 }
 
+void imx_set_soc_revision(unsigned int rev)
+{
+	imx_soc_revision = rev;
+}
+
+unsigned int imx_get_soc_revision(void)
+{
+	return imx_soc_revision;
+}
+
 void imx_print_silicon_rev(const char *cpu, int srev)
 {
 	if (srev == IMX_CHIP_REVISION_UNKNOWN)

commit e7feaaa75db6f2d1cace8d26ba3fa54df020b1a5
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Mon Mar 25 09:20:28 2013 -0300

    ARM: mach-imx: cpu: Include "common.h"
    
    Fix the following sparse warnings:
    
    arch/arm/mach-imx/cpu.c:10:6: warning: symbol 'mxc_set_cpu_type' was not declared. Should it be static?
    arch/arm/mach-imx/cpu.c:15:6: warning: symbol 'imx_print_silicon_rev' was not declared. Should it be static?
    arch/arm/mach-imx/cpu.c:24:13: warning: symbol 'imx_set_aips' was not declared. Should it be static?
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index 03fcbd082593..e70e3acbf9bd 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -3,6 +3,7 @@
 #include <linux/io.h>
 
 #include "hardware.h"
+#include "common.h"
 
 unsigned int __mxc_cpu_type;
 EXPORT_SYMBOL(__mxc_cpu_type);

commit 50f2de61269bbe2f40bead1969a9594fa8599b93
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Fri Sep 14 14:14:45 2012 +0800

    ARM: imx: include hardware.h rather than mach/hardware.h
    
    It moves a bunch of header files included in hardware.h and itself
    from mach-imx/include/mach to mach-imx, and updates users to include
    hardware.h rather than mach/hardware.h.  The files in mach-imx/devices
    will need to include "../hardware.h".
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
index 220dd6f93126..03fcbd082593 100644
--- a/arch/arm/mach-imx/cpu.c
+++ b/arch/arm/mach-imx/cpu.c
@@ -1,7 +1,8 @@
 
 #include <linux/module.h>
 #include <linux/io.h>
-#include <mach/hardware.h>
+
+#include "hardware.h"
 
 unsigned int __mxc_cpu_type;
 EXPORT_SYMBOL(__mxc_cpu_type);

commit 3995eb82050a81e11217a0b88b2a5eddd53eb4d6
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Thu Sep 13 19:48:07 2012 +0800

    ARM: imx: merge plat-mxc into mach-imx
    
    It's really unnecessary to have plat-mxc, and let's merge it into
    mach-imx.  It's pretty much just a bunch of file renaming and
    Kconfig/Makefile merge.
    
    To make the change less invasive, we keep using Kconfig symbol
    CONFIG_ARCH_MXC for mach-imx sub-architecture.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-imx/cpu.c b/arch/arm/mach-imx/cpu.c
new file mode 100644
index 000000000000..220dd6f93126
--- /dev/null
+++ b/arch/arm/mach-imx/cpu.c
@@ -0,0 +1,44 @@
+
+#include <linux/module.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+
+unsigned int __mxc_cpu_type;
+EXPORT_SYMBOL(__mxc_cpu_type);
+
+void mxc_set_cpu_type(unsigned int type)
+{
+	__mxc_cpu_type = type;
+}
+
+void imx_print_silicon_rev(const char *cpu, int srev)
+{
+	if (srev == IMX_CHIP_REVISION_UNKNOWN)
+		pr_info("CPU identified as %s, unknown revision\n", cpu);
+	else
+		pr_info("CPU identified as %s, silicon rev %d.%d\n",
+				cpu, (srev >> 4) & 0xf, srev & 0xf);
+}
+
+void __init imx_set_aips(void __iomem *base)
+{
+	unsigned int reg;
+/*
+ * Set all MPROTx to be non-bufferable, trusted for R/W,
+ * not forced to user-mode.
+ */
+	__raw_writel(0x77777777, base + 0x0);
+	__raw_writel(0x77777777, base + 0x4);
+
+/*
+ * Set all OPACRx to be non-bufferable, to not require
+ * supervisor privilege level for access, allow for
+ * write access and untrusted master access.
+ */
+	__raw_writel(0x0, base + 0x40);
+	__raw_writel(0x0, base + 0x44);
+	__raw_writel(0x0, base + 0x48);
+	__raw_writel(0x0, base + 0x4C);
+	reg = __raw_readl(base + 0x50) & 0x00FFFFFF;
+	__raw_writel(reg, base + 0x50);
+}
