commit fcaf20360a5992b88603271ab814a200e28d0088
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:08 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 159
    
    Based on 1 normalized pattern(s):
    
      the code contained herein is licensed under the gnu general public
      license you may obtain a copy of the gnu general public license
      version 2 or later at the following locations http www opensource
      org licenses gpl license html http www gnu org copyleft gpl html
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 161 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.383790741@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-imx/cpu-imx5.c b/arch/arm/mach-imx/cpu-imx5.c
index e210bac18840..ad56263778f9 100644
--- a/arch/arm/mach-imx/cpu-imx5.c
+++ b/arch/arm/mach-imx/cpu-imx5.c
@@ -1,13 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  *
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- *
  * This file contains the CPU initialization code.
  */
 

commit 26b754f99402d6e7fc4e07d67a2597e6ebabde8b
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Tue Jul 10 13:31:48 2018 -0300

    ARM: mx5: Set the DBGEN bit in ARM_GPC register
    
    On i.MX51/i.MX53 it is necessary to set the DBGEN bit in
    ARM_GPC register in order to turn on the debug clocks.
    
    The DBGEN bit of ARM_GPC register has the following description
    in the i.MX53 Reference Manual:
    
    "This allows the user to manually activate clocks within the debug
    system. This register bit directly controls the platform's dbgen_out
    output signal which connects to the DAP_SYS to enable all debug clocks.
    Once enabled, the clocks cannot be disabled except by asserting the
    disable_trace input of the DAP_SYS."
    
    Based on a previous patch from Sebastian Reichel.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/cpu-imx5.c b/arch/arm/mach-imx/cpu-imx5.c
index 4f2d1c772f85..e210bac18840 100644
--- a/arch/arm/mach-imx/cpu-imx5.c
+++ b/arch/arm/mach-imx/cpu-imx5.c
@@ -117,3 +117,48 @@ int mx53_revision(void)
 	return mx5_cpu_rev;
 }
 EXPORT_SYMBOL(mx53_revision);
+
+#define ARM_GPC		0x4
+#define DBGEN		BIT(16)
+
+/*
+ * This enables the DBGEN bit in ARM_GPC register, which is
+ * required for accessing some performance counter features.
+ * Technically it is only required while perf is used, but to
+ * keep the source code simple we just enable it all the time
+ * when the kernel configuration allows using the feature.
+ */
+void __init imx5_pmu_init(void)
+{
+	void __iomem *tigerp_base;
+	struct device_node *np;
+	u32 gpc;
+
+	if (!IS_ENABLED(CONFIG_ARM_PMU))
+		return;
+
+	np = of_find_compatible_node(NULL, NULL, "arm,cortex-a8-pmu");
+	if (!np)
+		return;
+
+	if (!of_property_read_bool(np, "secure-reg-access"))
+		goto exit;
+
+	of_node_put(np);
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,imx51-tigerp");
+	if (!np)
+		return;
+
+	tigerp_base = of_iomap(np, 0);
+	if (!tigerp_base)
+		goto exit;
+
+	gpc = readl_relaxed(tigerp_base + ARM_GPC);
+	gpc |= DBGEN;
+	writel_relaxed(gpc, tigerp_base + ARM_GPC);
+	iounmap(tigerp_base);
+exit:
+	of_node_put(np);
+
+}

commit 505c19f8bcb310f6e125c8c58e401a7093c82f5a
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jun 24 12:50:00 2016 +0200

    ARM: imx: remove last call to cpu_is_mx5*
    
    The check for cpu_is_mx51/cpu_is_mx53() in mx51_revision()/mx53_revision()
    is just a safety precaution, but there are only two callers of this
    are using it only on the correct CPUs, and none of the other respective
    functions have this extra check.
    
    Removing these lets us kill off the cpu_is_* functions.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Shawn Guo <shawnguo@kernel.org>

diff --git a/arch/arm/mach-imx/cpu-imx5.c b/arch/arm/mach-imx/cpu-imx5.c
index 3403bac94a31..4f2d1c772f85 100644
--- a/arch/arm/mach-imx/cpu-imx5.c
+++ b/arch/arm/mach-imx/cpu-imx5.c
@@ -60,13 +60,9 @@ static int get_mx51_srev(void)
 /*
  * Returns:
  *	the silicon revision of the cpu
- *	-EINVAL - not a mx51
  */
 int mx51_revision(void)
 {
-	if (!cpu_is_mx51())
-		return -EINVAL;
-
 	if (mx5_cpu_rev == -1)
 		mx5_cpu_rev = get_mx51_srev();
 
@@ -112,13 +108,9 @@ static int get_mx53_srev(void)
 /*
  * Returns:
  *	the silicon revision of the cpu
- *	-EINVAL - not a mx53
  */
 int mx53_revision(void)
 {
-	if (!cpu_is_mx53())
-		return -EINVAL;
-
 	if (mx5_cpu_rev == -1)
 		mx5_cpu_rev = get_mx53_srev();
 

commit ee18a7154ee080af82cb81e93f1fdcbd44176d5e
Author: Shawn Guo <shawn.guo@freescale.com>
Date:   Mon May 19 22:23:43 2014 +0800

    ARM: imx5: retrieve iim base from device tree
    
    Instead of using static define and mapping, the patch changes imx5 code
    that reads chip revision from IIM to retrieve base address from device
    tree and use dynamic mapping.
    
    Signed-off-by: Shawn Guo <shawn.guo@freescale.com>

diff --git a/arch/arm/mach-imx/cpu-imx5.c b/arch/arm/mach-imx/cpu-imx5.c
index c1c99a72c6a1..3403bac94a31 100644
--- a/arch/arm/mach-imx/cpu-imx5.c
+++ b/arch/arm/mach-imx/cpu-imx5.c
@@ -16,6 +16,8 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
 
 #include "hardware.h"
 #include "common.h"
@@ -24,10 +26,26 @@ static int mx5_cpu_rev = -1;
 
 #define IIM_SREV 0x24
 
+static u32 imx5_read_srev_reg(const char *compat)
+{
+	void __iomem *iim_base;
+	struct device_node *np;
+	u32 srev;
+
+	np = of_find_compatible_node(NULL, NULL, compat);
+	iim_base = of_iomap(np, 0);
+	WARN_ON(!iim_base);
+
+	srev = readl(iim_base + IIM_SREV) & 0xff;
+
+	iounmap(iim_base);
+
+	return srev;
+}
+
 static int get_mx51_srev(void)
 {
-	void __iomem *iim_base = MX51_IO_ADDRESS(MX51_IIM_BASE_ADDR);
-	u32 rev = readl(iim_base + IIM_SREV) & 0xff;
+	u32 rev = imx5_read_srev_reg("fsl,imx51-iim");
 
 	switch (rev) {
 	case 0x0:
@@ -77,8 +95,7 @@ int __init mx51_neon_fixup(void)
 
 static int get_mx53_srev(void)
 {
-	void __iomem *iim_base = MX51_IO_ADDRESS(MX53_IIM_BASE_ADDR);
-	u32 rev = readl(iim_base + IIM_SREV) & 0xff;
+	u32 rev = imx5_read_srev_reg("fsl,imx53-iim");
 
 	switch (rev) {
 	case 0x0:

commit 22567796220cc275e360cdb4bf9ca56067ebc5f0
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Mon Mar 25 09:20:31 2013 -0300

    ARM: mach-imx: cpu-imx5: Include "common.h"
    
    Fix the following sparse warnings:
    
    arch/arm/mach-imx/cpu-imx5.c:65:12: warning: symbol 'mx51_neon_fixup' was not declared. Should it be static?
    arch/arm/mach-imx/cpu-imx5.c:99:5: warning: symbol 'mx53_revision' was not declared. Should it be static?
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/cpu-imx5.c b/arch/arm/mach-imx/cpu-imx5.c
index d7ce72252a4e..c1c99a72c6a1 100644
--- a/arch/arm/mach-imx/cpu-imx5.c
+++ b/arch/arm/mach-imx/cpu-imx5.c
@@ -18,6 +18,7 @@
 #include <linux/io.h>
 
 #include "hardware.h"
+#include "common.h"
 
 static int mx5_cpu_rev = -1;
 

commit 7356420cd34e40fe27bf26555b0bf3f2849a43dd
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Tue Jan 22 10:40:55 2013 -0200

    ARM: imx: Remove mx508 support
    
    Only mx508 based board is mach-mx50_rdp and it has been marked as BROKEN
    for several releases.
    
    mx508 currently lacks clock support.
    
    In case someone needs to add mx508 support back, then the recommended approach
    is to use device tree.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>

diff --git a/arch/arm/mach-imx/cpu-imx5.c b/arch/arm/mach-imx/cpu-imx5.c
index d88760014ff9..d7ce72252a4e 100644
--- a/arch/arm/mach-imx/cpu-imx5.c
+++ b/arch/arm/mach-imx/cpu-imx5.c
@@ -22,7 +22,6 @@
 static int mx5_cpu_rev = -1;
 
 #define IIM_SREV 0x24
-#define MX50_HW_ADADIG_DIGPROG	0xB0
 
 static int get_mx51_srev(void)
 {
@@ -108,41 +107,3 @@ int mx53_revision(void)
 	return mx5_cpu_rev;
 }
 EXPORT_SYMBOL(mx53_revision);
-
-static int get_mx50_srev(void)
-{
-	void __iomem *anatop = ioremap(MX50_ANATOP_BASE_ADDR, SZ_8K);
-	u32 rev;
-
-	if (!anatop) {
-		mx5_cpu_rev = -EINVAL;
-		return 0;
-	}
-
-	rev = readl(anatop + MX50_HW_ADADIG_DIGPROG);
-	rev &= 0xff;
-
-	iounmap(anatop);
-	if (rev == 0x0)
-		return IMX_CHIP_REVISION_1_0;
-	else if (rev == 0x1)
-		return IMX_CHIP_REVISION_1_1;
-	return 0;
-}
-
-/*
- * Returns:
- *	the silicon revision of the cpu
- *	-EINVAL - not a mx50
- */
-int mx50_revision(void)
-{
-	if (!cpu_is_mx50())
-		return -EINVAL;
-
-	if (mx5_cpu_rev == -1)
-		mx5_cpu_rev = get_mx50_srev();
-
-	return mx5_cpu_rev;
-}
-EXPORT_SYMBOL(mx50_revision);

commit 50f2de61269bbe2f40bead1969a9594fa8599b93
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Fri Sep 14 14:14:45 2012 +0800

    ARM: imx: include hardware.h rather than mach/hardware.h
    
    It moves a bunch of header files included in hardware.h and itself
    from mach-imx/include/mach to mach-imx, and updates users to include
    hardware.h rather than mach/hardware.h.  The files in mach-imx/devices
    will need to include "../hardware.h".
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-imx/cpu-imx5.c b/arch/arm/mach-imx/cpu-imx5.c
index 8eb15a2fcaf9..d88760014ff9 100644
--- a/arch/arm/mach-imx/cpu-imx5.c
+++ b/arch/arm/mach-imx/cpu-imx5.c
@@ -15,9 +15,10 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/module.h>
-#include <mach/hardware.h>
 #include <linux/io.h>
 
+#include "hardware.h"
+
 static int mx5_cpu_rev = -1;
 
 #define IIM_SREV 0x24

commit 8321b758e08cae7fb02663f26efee4ba985c2ae5
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Thu Apr 26 11:42:34 2012 +0800

    ARM: imx: use machine specific hook for late init
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>

diff --git a/arch/arm/mach-imx/cpu-imx5.c b/arch/arm/mach-imx/cpu-imx5.c
index aa15c517d06e..8eb15a2fcaf9 100644
--- a/arch/arm/mach-imx/cpu-imx5.c
+++ b/arch/arm/mach-imx/cpu-imx5.c
@@ -62,11 +62,8 @@ EXPORT_SYMBOL(mx51_revision);
  * Dependent on link order - so the assumption is that vfp_init is called
  * before us.
  */
-static int __init mx51_neon_fixup(void)
+int __init mx51_neon_fixup(void)
 {
-	if (!cpu_is_mx51())
-		return 0;
-
 	if (mx51_revision() < IMX_CHIP_REVISION_3_0 &&
 			(elf_hwcap & HWCAP_NEON)) {
 		elf_hwcap &= ~HWCAP_NEON;
@@ -75,7 +72,6 @@ static int __init mx51_neon_fixup(void)
 	return 0;
 }
 
-late_initcall(mx51_neon_fixup);
 #endif
 
 static int get_mx53_srev(void)

commit aa6a9fa1f27414bd099c405bde7c42a3c99078f9
Author: Fabio Estevam <festevam@gmail.com>
Date:   Fri Mar 2 07:45:58 2012 -0300

    ARM: mx5: Use common function for configuring AIPS
    
    Now that a common imx_set_aips() function is available, use it on mx51 and mx53.
    
    This lets the code smaller and cleaner.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>

diff --git a/arch/arm/mach-imx/cpu-imx5.c b/arch/arm/mach-imx/cpu-imx5.c
index 5e2e7a843860..aa15c517d06e 100644
--- a/arch/arm/mach-imx/cpu-imx5.c
+++ b/arch/arm/mach-imx/cpu-imx5.c
@@ -149,39 +149,3 @@ int mx50_revision(void)
 	return mx5_cpu_rev;
 }
 EXPORT_SYMBOL(mx50_revision);
-
-static int __init post_cpu_init(void)
-{
-	unsigned int reg;
-	void __iomem *base;
-
-	if (cpu_is_mx51() || cpu_is_mx53()) {
-		if (cpu_is_mx51())
-			base = MX51_IO_ADDRESS(MX51_AIPS1_BASE_ADDR);
-		else
-			base = MX53_IO_ADDRESS(MX53_AIPS1_BASE_ADDR);
-
-		__raw_writel(0x0, base + 0x40);
-		__raw_writel(0x0, base + 0x44);
-		__raw_writel(0x0, base + 0x48);
-		__raw_writel(0x0, base + 0x4C);
-		reg = __raw_readl(base + 0x50) & 0x00FFFFFF;
-		__raw_writel(reg, base + 0x50);
-
-		if (cpu_is_mx51())
-			base = MX51_IO_ADDRESS(MX51_AIPS2_BASE_ADDR);
-		else
-			base = MX53_IO_ADDRESS(MX53_AIPS2_BASE_ADDR);
-
-		__raw_writel(0x0, base + 0x40);
-		__raw_writel(0x0, base + 0x44);
-		__raw_writel(0x0, base + 0x48);
-		__raw_writel(0x0, base + 0x4C);
-		reg = __raw_readl(base + 0x50) & 0x00FFFFFF;
-		__raw_writel(reg, base + 0x50);
-	}
-
-	return 0;
-}
-
-postcore_initcall(post_cpu_init);

commit eaed435a7b870a38d89dbdb535c7842d618d3214
Merge: a99cbf6b43a7 3f07f355704b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 23 14:50:30 2012 -0800

    Merge tag 'arm-soc-imx-move' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Consolidate i.MX 5 platforms to be under the new shared i.MX 3/5/6 tree.
    
    * tag 'arm-soc-imx-move' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      ARM i.MX: Update defconfig
      ARM i.MX: Merge i.MX5 support into mach-imx
      ARM i.MX5: remove unnecessary includes from board files
    
    Fix up fairly trivial conflicts due to various changes nearby in
    arch/arm/{mach,plat}-imx/{Kconfig,Makefile}
    
    Pull request had been sent to the wrong email address, but happened
    before the merge window closed.  I'm merging the MX 5 consolidation,
    since it apparently will help the next development window and will avoid
    conflicts later as per Arnd.

commit 784a90c0a7d8f5aa94b6c7d295ad44ae8e045aa3
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Mon Nov 7 12:36:48 2011 +0100

    ARM i.MX: Merge i.MX5 support into mach-imx
    
    This patch moves the contents of arch/arm/mach-mx5 to arch/arm/mach-imx
    and adjusts the Makefile/Kconfig entries in a way that it's possible
    to compile i.MX5 together with i.MX3/6.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    Tested-by: Dirk Behme <dirk.behme@de.bosch.com>

diff --git a/arch/arm/mach-imx/cpu-imx5.c b/arch/arm/mach-imx/cpu-imx5.c
new file mode 100644
index 000000000000..5c5328257dca
--- /dev/null
+++ b/arch/arm/mach-imx/cpu-imx5.c
@@ -0,0 +1,186 @@
+/*
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ *
+ * This file contains the CPU initialization code.
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <mach/hardware.h>
+#include <asm/io.h>
+
+static int mx5_cpu_rev = -1;
+
+#define IIM_SREV 0x24
+#define MX50_HW_ADADIG_DIGPROG	0xB0
+
+static int get_mx51_srev(void)
+{
+	void __iomem *iim_base = MX51_IO_ADDRESS(MX51_IIM_BASE_ADDR);
+	u32 rev = readl(iim_base + IIM_SREV) & 0xff;
+
+	switch (rev) {
+	case 0x0:
+		return IMX_CHIP_REVISION_2_0;
+	case 0x10:
+		return IMX_CHIP_REVISION_3_0;
+	default:
+		return IMX_CHIP_REVISION_UNKNOWN;
+	}
+}
+
+/*
+ * Returns:
+ *	the silicon revision of the cpu
+ *	-EINVAL - not a mx51
+ */
+int mx51_revision(void)
+{
+	if (!cpu_is_mx51())
+		return -EINVAL;
+
+	if (mx5_cpu_rev == -1)
+		mx5_cpu_rev = get_mx51_srev();
+
+	return mx5_cpu_rev;
+}
+EXPORT_SYMBOL(mx51_revision);
+
+#ifdef CONFIG_NEON
+
+/*
+ * All versions of the silicon before Rev. 3 have broken NEON implementations.
+ * Dependent on link order - so the assumption is that vfp_init is called
+ * before us.
+ */
+static int __init mx51_neon_fixup(void)
+{
+	if (!cpu_is_mx51())
+		return 0;
+
+	if (mx51_revision() < IMX_CHIP_REVISION_3_0 && (elf_hwcap & HWCAP_NEON)) {
+		elf_hwcap &= ~HWCAP_NEON;
+		pr_info("Turning off NEON support, detected broken NEON implementation\n");
+	}
+	return 0;
+}
+
+late_initcall(mx51_neon_fixup);
+#endif
+
+static int get_mx53_srev(void)
+{
+	void __iomem *iim_base = MX51_IO_ADDRESS(MX53_IIM_BASE_ADDR);
+	u32 rev = readl(iim_base + IIM_SREV) & 0xff;
+
+	switch (rev) {
+	case 0x0:
+		return IMX_CHIP_REVISION_1_0;
+	case 0x2:
+		return IMX_CHIP_REVISION_2_0;
+	case 0x3:
+		return IMX_CHIP_REVISION_2_1;
+	default:
+		return IMX_CHIP_REVISION_UNKNOWN;
+	}
+}
+
+/*
+ * Returns:
+ *	the silicon revision of the cpu
+ *	-EINVAL - not a mx53
+ */
+int mx53_revision(void)
+{
+	if (!cpu_is_mx53())
+		return -EINVAL;
+
+	if (mx5_cpu_rev == -1)
+		mx5_cpu_rev = get_mx53_srev();
+
+	return mx5_cpu_rev;
+}
+EXPORT_SYMBOL(mx53_revision);
+
+static int get_mx50_srev(void)
+{
+	void __iomem *anatop = ioremap(MX50_ANATOP_BASE_ADDR, SZ_8K);
+	u32 rev;
+
+	if (!anatop) {
+		mx5_cpu_rev = -EINVAL;
+		return 0;
+	}
+
+	rev = readl(anatop + MX50_HW_ADADIG_DIGPROG);
+	rev &= 0xff;
+
+	iounmap(anatop);
+	if (rev == 0x0)
+		return IMX_CHIP_REVISION_1_0;
+	else if (rev == 0x1)
+		return IMX_CHIP_REVISION_1_1;
+	return 0;
+}
+
+/*
+ * Returns:
+ *	the silicon revision of the cpu
+ *	-EINVAL - not a mx50
+ */
+int mx50_revision(void)
+{
+	if (!cpu_is_mx50())
+		return -EINVAL;
+
+	if (mx5_cpu_rev == -1)
+		mx5_cpu_rev = get_mx50_srev();
+
+	return mx5_cpu_rev;
+}
+EXPORT_SYMBOL(mx50_revision);
+
+static int __init post_cpu_init(void)
+{
+	unsigned int reg;
+	void __iomem *base;
+
+	if (cpu_is_mx51() || cpu_is_mx53()) {
+		if (cpu_is_mx51())
+			base = MX51_IO_ADDRESS(MX51_AIPS1_BASE_ADDR);
+		else
+			base = MX53_IO_ADDRESS(MX53_AIPS1_BASE_ADDR);
+
+		__raw_writel(0x0, base + 0x40);
+		__raw_writel(0x0, base + 0x44);
+		__raw_writel(0x0, base + 0x48);
+		__raw_writel(0x0, base + 0x4C);
+		reg = __raw_readl(base + 0x50) & 0x00FFFFFF;
+		__raw_writel(reg, base + 0x50);
+
+		if (cpu_is_mx51())
+			base = MX51_IO_ADDRESS(MX51_AIPS2_BASE_ADDR);
+		else
+			base = MX53_IO_ADDRESS(MX53_AIPS2_BASE_ADDR);
+
+		__raw_writel(0x0, base + 0x40);
+		__raw_writel(0x0, base + 0x44);
+		__raw_writel(0x0, base + 0x48);
+		__raw_writel(0x0, base + 0x4C);
+		reg = __raw_readl(base + 0x50) & 0x00FFFFFF;
+		__raw_writel(reg, base + 0x50);
+	}
+
+	return 0;
+}
+
+postcore_initcall(post_cpu_init);
