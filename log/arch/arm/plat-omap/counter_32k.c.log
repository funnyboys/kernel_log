commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index fcc5bfec8bd1..7a729ade2105 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * OMAP 32ksynctimer/counter_32k-related code
  *
@@ -6,10 +7,6 @@
  * Tony Lindgren <tony@atomide.com>
  * Added OMAP4 support - Santosh Shilimkar <santosh.shilimkar@ti.com>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  * NOTE: This timer is not the same timer as the old OMAP1 MPU timer.
  */
 #include <linux/kernel.h>

commit 227e3958a780499b3ec41c36d4752ac4f4962874
Author: Pavel Tatashin <pasha.tatashin@oracle.com>
Date:   Thu Jul 19 16:55:37 2018 -0400

    ARM/time: Remove read_boot_clock64()
    
    read_boot_clock64() is deleted, and replaced with
    read_persistent_wall_and_boot_offset().
    
    The default implementation of read_persistent_wall_and_boot_offset()
    provides a better fallback than the current stubs for read_boot_clock64()
    that arm has with no users, so remove the old code.
    
    Signed-off-by: Pavel Tatashin <pasha.tatashin@oracle.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: steven.sistare@oracle.com
    Cc: daniel.m.jordan@oracle.com
    Cc: linux@armlinux.org.uk
    Cc: schwidefsky@de.ibm.com
    Cc: heiko.carstens@de.ibm.com
    Cc: john.stultz@linaro.org
    Cc: sboyd@codeaurora.org
    Cc: hpa@zytor.com
    Cc: douly.fnst@cn.fujitsu.com
    Cc: peterz@infradead.org
    Cc: prarit@redhat.com
    Cc: feng.tang@intel.com
    Cc: pmladek@suse.com
    Cc: gnomes@lxorguk.ukuu.org.uk
    Cc: linux-s390@vger.kernel.org
    Cc: boris.ostrovsky@oracle.com
    Cc: jgross@suse.com
    Cc: pbonzini@redhat.com
    Link: https://lkml.kernel.org/r/20180719205545.16512-19-pasha.tatashin@oracle.com

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 2438b96004c1..fcc5bfec8bd1 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -110,7 +110,7 @@ int __init omap_init_clocksource_32k(void __iomem *vbase)
 	}
 
 	sched_clock_register(omap_32k_read_sched_clock, 32, 32768);
-	register_persistent_clock(NULL, omap_read_persistent_clock64);
+	register_persistent_clock(omap_read_persistent_clock64);
 	pr_info("OMAP clocksource: 32k_counter at 32768 Hz\n");
 
 	return 0;

commit cb850717b076d979058d52529e15f1736359d811
Author: Xunlei Pang <pang.xunlei@linaro.org>
Date:   Wed Apr 1 20:34:26 2015 -0700

    ARM, clocksource/drivers: Provide read_boot_clock64() and read_persistent_clock64() and use them
    
    As part of addressing "y2038 problem" for in-kernel uses, this
    patch converts read_boot_clock() to read_boot_clock64() and
    read_persistent_clock() to read_persistent_clock64() using
    timespec64 by converting clock_access_fn to use timespec64.
    
    Signed-off-by: Xunlei Pang <pang.xunlei@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Acked-by: Thierry Reding <treding@nvidia.com> (for tegra part)
    Cc: Russell King <rmk@dyn-67.arm.linux.org.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1427945681-29972-7-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index b7b7b0793228..2438b96004c1 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -70,14 +70,6 @@ static void omap_read_persistent_clock64(struct timespec64 *ts)
 	*ts = persistent_ts;
 }
 
-static void omap_read_persistent_clock(struct timespec *ts)
-{
-	struct timespec64 ts64;
-
-	omap_read_persistent_clock64(&ts64);
-	*ts = timespec64_to_timespec(ts64);
-}
-
 /**
  * omap_init_clocksource_32k - setup and register counter 32k as a
  * kernel clocksource
@@ -118,7 +110,7 @@ int __init omap_init_clocksource_32k(void __iomem *vbase)
 	}
 
 	sched_clock_register(omap_32k_read_sched_clock, 32, 32768);
-	register_persistent_clock(NULL, omap_read_persistent_clock);
+	register_persistent_clock(NULL, omap_read_persistent_clock64);
 	pr_info("OMAP clocksource: 32k_counter at 32768 Hz\n");
 
 	return 0;

commit a451570c008b9e19592e29f15cfd295bdf818c7a
Author: Xunlei Pang <pang.xunlei@linaro.org>
Date:   Wed Apr 1 20:34:24 2015 -0700

    ARM: OMAP: 32k counter: Provide y2038-safe omap_read_persistent_clock() replacement
    
    As part of addressing "y2038 problem" for in-kernel uses, this
    patch adds the y2038-safe omap_read_persistent_clock64() using
    timespec64.
    
    Because we rely on some subsequent changes to convert arm
    multiarch support, omap_read_persistent_clock() will be removed
    then.
    
    Also remove the needless spinlock, because
    read_persistent_clock() doesn't run simultaneously.
    
    Signed-off-by: Xunlei Pang <pang.xunlei@linaro.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1427945681-29972-5-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 43cf74561cfd..b7b7b0793228 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -44,24 +44,20 @@ static u64 notrace omap_32k_read_sched_clock(void)
 }
 
 /**
- * omap_read_persistent_clock -  Return time from a persistent clock.
+ * omap_read_persistent_clock64 -  Return time from a persistent clock.
  *
  * Reads the time from a source which isn't disabled during PM, the
  * 32k sync timer.  Convert the cycles elapsed since last read into
- * nsecs and adds to a monotonically increasing timespec.
+ * nsecs and adds to a monotonically increasing timespec64.
  */
-static struct timespec persistent_ts;
+static struct timespec64 persistent_ts;
 static cycles_t cycles;
 static unsigned int persistent_mult, persistent_shift;
-static DEFINE_SPINLOCK(read_persistent_clock_lock);
 
-static void omap_read_persistent_clock(struct timespec *ts)
+static void omap_read_persistent_clock64(struct timespec64 *ts)
 {
 	unsigned long long nsecs;
 	cycles_t last_cycles;
-	unsigned long flags;
-
-	spin_lock_irqsave(&read_persistent_clock_lock, flags);
 
 	last_cycles = cycles;
 	cycles = sync32k_cnt_reg ? readl_relaxed(sync32k_cnt_reg) : 0;
@@ -69,11 +65,17 @@ static void omap_read_persistent_clock(struct timespec *ts)
 	nsecs = clocksource_cyc2ns(cycles - last_cycles,
 					persistent_mult, persistent_shift);
 
-	timespec_add_ns(&persistent_ts, nsecs);
+	timespec64_add_ns(&persistent_ts, nsecs);
 
 	*ts = persistent_ts;
+}
+
+static void omap_read_persistent_clock(struct timespec *ts)
+{
+	struct timespec64 ts64;
 
-	spin_unlock_irqrestore(&read_persistent_clock_lock, flags);
+	omap_read_persistent_clock64(&ts64);
+	*ts = timespec64_to_timespec(ts64);
 }
 
 /**

commit fba9e07208c0f9d92d9f73761c99c8612039da44
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Mar 11 21:16:40 2015 -0700

    clocksource: Rename __clocksource_updatefreq_*() to __clocksource_update_freq_*()
    
    Ingo requested this function be renamed to improve readability,
    so I've renamed __clocksource_updatefreq_scale() as well as the
    __clocksource_updatefreq_hz/khz() functions to avoid
    squishedtogethernames.
    
    This touches some of the sh clocksources, which I've not tested.
    
    The arch/arm/plat-omap change is just a comment change for
    consistency.
    
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Prarit Bhargava <prarit@redhat.com>
    Cc: Richard Cochran <richardcochran@gmail.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1426133800-29329-13-git-send-email-john.stultz@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 61b4d705c267..43cf74561cfd 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -103,7 +103,7 @@ int __init omap_init_clocksource_32k(void __iomem *vbase)
 
 	/*
 	 * 120000 rough estimate from the calculations in
-	 * __clocksource_updatefreq_scale.
+	 * __clocksource_update_freq_scale.
 	 */
 	clocks_calc_mult_shift(&persistent_mult, &persistent_shift,
 			32768, NSEC_PER_SEC, 120000);

commit f6f3b50f996b938b034b14b5084108b2acfcae7d
Author: Victor Kamensky <victor.kamensky@linaro.org>
Date:   Tue Apr 15 20:37:48 2014 +0300

    ARM: OMAP: counter-32k: raw read and write endian fix
    
    All OMAP IP blocks expect LE data, but CPU may operate in BE mode.
    Need to use endian neutral functions to read/write h/w registers.
    I.e instead of __raw_read[lw] and __raw_write[lw] functions code
    need to use read[lw]_relaxed and write[lw]_relaxed functions.
    If the first simply reads/writes register, the second will byteswap
    it if host operates in BE mode.
    
    Changes are trivial sed like replacement of __raw_xxx functions
    with xxx_relaxed variant.
    
    Signed-off-by: Victor Kamensky <victor.kamensky@linaro.org>
    Signed-off-by: Taras Kondratiuk <taras.kondratiuk@linaro.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 384a776d8eb2..61b4d705c267 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -40,7 +40,7 @@ static void __iomem *sync32k_cnt_reg;
 
 static u64 notrace omap_32k_read_sched_clock(void)
 {
-	return sync32k_cnt_reg ? __raw_readl(sync32k_cnt_reg) : 0;
+	return sync32k_cnt_reg ? readl_relaxed(sync32k_cnt_reg) : 0;
 }
 
 /**
@@ -64,7 +64,7 @@ static void omap_read_persistent_clock(struct timespec *ts)
 	spin_lock_irqsave(&read_persistent_clock_lock, flags);
 
 	last_cycles = cycles;
-	cycles = sync32k_cnt_reg ? __raw_readl(sync32k_cnt_reg) : 0;
+	cycles = sync32k_cnt_reg ? readl_relaxed(sync32k_cnt_reg) : 0;
 
 	nsecs = clocksource_cyc2ns(cycles - last_cycles,
 					persistent_mult, persistent_shift);
@@ -95,7 +95,7 @@ int __init omap_init_clocksource_32k(void __iomem *vbase)
 	 * The 'SCHEME' bits(30-31) of the revision register is used
 	 * to identify the version.
 	 */
-	if (__raw_readl(vbase + OMAP2_32KSYNCNT_REV_OFF) &
+	if (readl_relaxed(vbase + OMAP2_32KSYNCNT_REV_OFF) &
 						OMAP2_32KSYNCNT_REV_SCHEME)
 		sync32k_cnt_reg = vbase + OMAP2_32KSYNCNT_CR_OFF_HIGH;
 	else

commit 8f0678f7be42c15aaf18b8655cbdcb8b56a812ff
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Nov 15 15:26:23 2013 -0800

    ARM: OMAP: Switch to sched_clock_register()
    
    The 32 bit sched_clock interface now supports 64 bits. Upgrade to
    the 64 bit function to allow us to remove the 32 bit registration
    interface.
    
    Cc: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Kevin Hilman <khilman@linaro.org>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index d9bc98eb2a6b..384a776d8eb2 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -38,7 +38,7 @@
  */
 static void __iomem *sync32k_cnt_reg;
 
-static u32 notrace omap_32k_read_sched_clock(void)
+static u64 notrace omap_32k_read_sched_clock(void)
 {
 	return sync32k_cnt_reg ? __raw_readl(sync32k_cnt_reg) : 0;
 }
@@ -115,7 +115,7 @@ int __init omap_init_clocksource_32k(void __iomem *vbase)
 		return ret;
 	}
 
-	setup_sched_clock(omap_32k_read_sched_clock, 32, 32768);
+	sched_clock_register(omap_32k_read_sched_clock, 32, 32768);
 	register_persistent_clock(NULL, omap_read_persistent_clock);
 	pr_info("OMAP clocksource: 32k_counter at 32768 Hz\n");
 

commit 38ff87f77af0b5a93fc8581cff1d6e5692ab8970
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Sat Jun 1 23:39:40 2013 -0700

    sched_clock: Make ARM's sched_clock generic for all architectures
    
    Nothing about the sched_clock implementation in the ARM port is
    specific to the architecture. Generalize the code so that other
    architectures can use it by selecting GENERIC_SCHED_CLOCK.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    [jstultz: Merge minor collisions with other patches in my tree]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 5b0b86bb34bb..d9bc98eb2a6b 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -18,9 +18,9 @@
 #include <linux/err.h>
 #include <linux/io.h>
 #include <linux/clocksource.h>
+#include <linux/sched_clock.h>
 
 #include <asm/mach/time.h>
-#include <asm/sched_clock.h>
 
 #include <plat/counter-32k.h>
 

commit 6ccc432f705f1cbf150355b6936b335c87a9accd
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Dec 10 11:48:44 2012 -0700

    ARM: OMAP: 32k counter: resolve sparse warnings
    
    Commit 1fe97c8f6a1de67a5f56e029a818903d5bed8017 ("ARM: OMAP: Make OMAP
    clocksource source selection using kernel param") results in a new warning
    from sparse:
    
    arch/arm/plat-omap/counter_32k.c:86:12: warning: symbol 'omap_init_clocksource_32k' was not declared. Should it be static?
    
    This second version fixes this warning by including <plat/counter-32k.h>,
    at Tony's request.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Vaibhav Hiremath <hvaibhav@ti.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index f3771cdb9838..5b0b86bb34bb 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -22,6 +22,8 @@
 #include <asm/mach/time.h>
 #include <asm/sched_clock.h>
 
+#include <plat/counter-32k.h>
+
 /* OMAP2_32KSYNCNT_CR_OFF: offset of 32ksync counter register */
 #define OMAP2_32KSYNCNT_REV_OFF		0x0
 #define OMAP2_32KSYNCNT_REV_SCHEME	(0x3 << 30)

commit 5c2e88525b5f1cdc72c9eefba72dae13be7e5d20
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Oct 29 16:45:47 2012 -0700

    ARM: OMAP: Remove plat-omap/common.h
    
    Most of the prototypes in plat-omap/common.h are not
    common to omap1 and omap2+, they are local to omap2+
    and should not be in plat-omap/common.h.
    
    The only shared function prototype in this file is
    omap_init_clocksource_32k(), let's put that into
    counter-32k.h.
    
    Note that the new plat/counter-32k.h must not be
    included from drivers, that will break omap2+ build
    for CONFIG_MULTIPLATFORM.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 66bf3f9324fe..f3771cdb9838 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -22,8 +22,6 @@
 #include <asm/mach/time.h>
 #include <asm/sched_clock.h>
 
-#include "common.h"
-
 /* OMAP2_32KSYNCNT_CR_OFF: offset of 32ksync counter register */
 #define OMAP2_32KSYNCNT_REV_OFF		0x0
 #define OMAP2_32KSYNCNT_REV_SCHEME	(0x3 << 30)

commit a135eaae524acba1509a3b19c97fae556e4da7cd
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Sep 27 10:33:34 2012 -0600

    ARM: OMAP: remove plat/clock.h
    
    Remove arch/arm/plat-omap/include/plat/clock.h by merging it into
    arch/arm/mach-omap1/clock.h and arch/arm/mach-omap2/clock.h.
    The goal here is to facilitate ARM single image kernels by removing
    includes via the "plat/" symlink.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    [tony@atomide.com: fixed to remove duplicate clock.h includes]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 8e847de4c744..66bf3f9324fe 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -23,7 +23,6 @@
 #include <asm/sched_clock.h>
 
 #include "common.h"
-#include <plat/clock.h>
 
 /* OMAP2_32KSYNCNT_CR_OFF: offset of 32ksync counter register */
 #define OMAP2_32KSYNCNT_REV_OFF		0x0

commit e6a6e5ad17ee090f8d48a3b0758338a97124539f
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Sep 27 17:11:15 2012 -0700

    ARM: OMAP: Make plat/common.h local to mach-omap1 and mach-omap2
    
    We cannot keep this in plat/common.h for common zImage support.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 87ba8dd0d791..8e847de4c744 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -22,7 +22,7 @@
 #include <asm/mach/time.h>
 #include <asm/sched_clock.h>
 
-#include <plat/common.h>
+#include "common.h"
 #include <plat/clock.h>
 
 /* OMAP2_32KSYNCNT_CR_OFF: offset of 32ksync counter register */

commit 9d7d6e363b06934221b81a859d509844c97380df
Author: Colin Cross <ccross@android.com>
Date:   Mon Oct 8 14:01:12 2012 -0700

    ARM: OMAP: counter: add locking to read_persistent_clock
    
    read_persistent_clock uses a global variable, use a spinlock to
    ensure non-atomic updates to the variable don't overlap and cause
    time to move backwards.
    
    Signed-off-by: Colin Cross <ccross@android.com>
    Signed-off-by: R Sricharan <r.sricharan@ti.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 2e826f1faf7b..87ba8dd0d791 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -52,22 +52,29 @@ static u32 notrace omap_32k_read_sched_clock(void)
  * nsecs and adds to a monotonically increasing timespec.
  */
 static struct timespec persistent_ts;
-static cycles_t cycles, last_cycles;
+static cycles_t cycles;
 static unsigned int persistent_mult, persistent_shift;
+static DEFINE_SPINLOCK(read_persistent_clock_lock);
+
 static void omap_read_persistent_clock(struct timespec *ts)
 {
 	unsigned long long nsecs;
-	cycles_t delta;
-	struct timespec *tsp = &persistent_ts;
+	cycles_t last_cycles;
+	unsigned long flags;
+
+	spin_lock_irqsave(&read_persistent_clock_lock, flags);
 
 	last_cycles = cycles;
 	cycles = sync32k_cnt_reg ? __raw_readl(sync32k_cnt_reg) : 0;
-	delta = cycles - last_cycles;
 
-	nsecs = clocksource_cyc2ns(delta, persistent_mult, persistent_shift);
+	nsecs = clocksource_cyc2ns(cycles - last_cycles,
+					persistent_mult, persistent_shift);
+
+	timespec_add_ns(&persistent_ts, nsecs);
+
+	*ts = persistent_ts;
 
-	timespec_add_ns(tsp, nsecs);
-	*ts = *tsp;
+	spin_unlock_irqrestore(&read_persistent_clock_lock, flags);
 }
 
 /**

commit dbc04161048dd5e5c3c58546688a0cc0854051e9
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Aug 31 10:59:07 2012 -0700

    ARM: OMAP: Split plat/hardware.h, use local soc.h for omap2+
    
    As the plat and mach includes need to disappear for single zImage work,
    we need to remove plat/hardware.h.
    
    Do this by splitting plat/hardware.h into omap1 and omap2+ specific files.
    
    The old plat/hardware.h already has omap1 only defines, so it gets moved
    to mach/hardware.h for omap1. For omap2+, we use the local soc.h
    that for now just includes the related SoC headers to keep this patch more
    readable.
    
    Note that the local soc.h still includes plat/cpu.h that can be dealt
    with in later patches. Let's also include plat/serial.h from common.h for
    all the board-*.c files. This allows making the include files local later
    on without patching these files again.
    
    Note that only minimal changes are done in this patch for the
    drivers/watchdog/omap_wdt.c driver to keep things compiling. Further
    patches are needed to eventually remove cpu_is_omap usage in the drivers.
    
    Also only minimal changes are done to sound/soc/omap/* to remove the
    unneeded includes and to define OMAP44XX_MCPDM_L3_BASE locally so there's
    no need to include omap44xx.h.
    
    While at it, also sort some of the includes in the standard way.
    
    Cc: linux-watchdog@vger.kernel.org
    Cc: alsa-devel@alsa-project.org
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Jarkko Nikula <jarkko.nikula@bitmer.com>
    Cc: Liam Girdwood <lrg@ti.com>
    Acked-by: Wim Van Sebroeck <wim@iguana.be>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 902d2ffdce9b..2e826f1faf7b 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -22,9 +22,7 @@
 #include <asm/mach/time.h>
 #include <asm/sched_clock.h>
 
-#include <plat/hardware.h>
 #include <plat/common.h>
-
 #include <plat/clock.h>
 
 /* OMAP2_32KSYNCNT_CR_OFF: offset of 32ksync counter register */

commit cf3a6ec2c0a499ef019d25d4dbc79df66e7d3f0c
Author: Igor Grinberg <grinberg@compulab.co.il>
Date:   Wed Aug 29 02:18:57 2012 +0300

    ARM: OMAP: remove plat/board.h file
    
    plat/board.h file is now empty - remove it.
    
    Cc: Jarkko Lavinen <jarkko.lavinen@nokia.com>
    Cc: Chris Ball <cjb@laptop.org>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: linux-mmc@vger.kernel.org
    Cc: linux-mtd@lists.infradead.org
    Signed-off-by: Igor Grinberg <grinberg@compulab.co.il>
    Acked-by: Chris Ball <cjb@laptop.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index dbf1e03029a5..902d2ffdce9b 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -24,7 +24,6 @@
 
 #include <plat/hardware.h>
 #include <plat/common.h>
-#include <plat/board.h>
 
 #include <plat/clock.h>
 

commit b009366f285d03e69aeea5f8cc466782dd6f0004
Author: R Sricharan <r.sricharan@ti.com>
Date:   Thu May 10 14:17:22 2012 +0530

    ARM: OMAP: counter-32k: Select the CR register offset using the IP scheme
    
    OMAP socs has a legacy and a highlander version of the
    32k sync counter IP. The register offsets vary between the
    highlander and the legacy scheme. So use the 'SCHEME'
    bits(30-31) of the revision register to distinguish between
    the two versions and choose the CR register offset accordingly.
    
    Signed-off-by: R Sricharan <r.sricharan@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 2132c4f389e1..dbf1e03029a5 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -29,7 +29,10 @@
 #include <plat/clock.h>
 
 /* OMAP2_32KSYNCNT_CR_OFF: offset of 32ksync counter register */
-#define OMAP2_32KSYNCNT_CR_OFF		0x10
+#define OMAP2_32KSYNCNT_REV_OFF		0x0
+#define OMAP2_32KSYNCNT_REV_SCHEME	(0x3 << 30)
+#define OMAP2_32KSYNCNT_CR_OFF_LOW	0x10
+#define OMAP2_32KSYNCNT_CR_OFF_HIGH	0x30
 
 /*
  * 32KHz clocksource ... always available, on pretty most chips except
@@ -84,9 +87,16 @@ int __init omap_init_clocksource_32k(void __iomem *vbase)
 	int ret;
 
 	/*
-	 * 32k sync Counter register offset is at 0x10
+	 * 32k sync Counter IP register offsets vary between the
+	 * highlander version and the legacy ones.
+	 * The 'SCHEME' bits(30-31) of the revision register is used
+	 * to identify the version.
 	 */
-	sync32k_cnt_reg = vbase + OMAP2_32KSYNCNT_CR_OFF;
+	if (__raw_readl(vbase + OMAP2_32KSYNCNT_REV_OFF) &
+						OMAP2_32KSYNCNT_REV_SCHEME)
+		sync32k_cnt_reg = vbase + OMAP2_32KSYNCNT_CR_OFF_HIGH;
+	else
+		sync32k_cnt_reg = vbase + OMAP2_32KSYNCNT_CR_OFF_LOW;
 
 	/*
 	 * 120000 rough estimate from the calculations in

commit 2c757fd5d1a92086f225a75a8fac7cab242d11b0
Merge: ce53044c68cf 424663566c43
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat May 26 12:31:49 2012 -0700

    Merge tag 'cleanup2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull arm-soc cleanups (part 2) from Olof Johansson:
     "More cleanups, continuing an earlier set with omap and samsung
      specific cleanups.  These could not go into the first set because they
      have dependencies on various other series that in turn depend on the
      first cleanups."
    
    Fixed up conflicts in arch/arm/plat-omap/counter_32k.c due to commit
    bd0493eaaf5c: "move read_{boot,persistent}_clock to the architecture
    level" that changed how the persistent clocks were handled.  And trivial
    conflicts in arch/arm/mach-omap1/common.h due to just independent
    changes close to each other.
    
    * tag 'cleanup2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (35 commits)
      ARM: SAMSUNG: merge plat-s5p into plat-samsung
      ARM: SAMSUNG: move options for common s5p into plat-samsung/Kconfig
      ARM: SAMSUNG: move setup code for s5p mfc and mipiphy into plat-samsung
      ARM: SAMSUNG: move platform device for s5p uart into plat-samsung
      ARM: SAMSUNG: move hr timer for common s5p into plat-samsung
      ARM: SAMSUNG: move pm part for common s5p into plat-samsung
      ARM: SAMSUNG: move interrupt part for common s5p into plat-samsung
      ARM: SAMSUNG: move clock part for common s5p into plat-samsung
      ARM: S3C24XX: Use common macro to define resources on dev-uart.c
      ARM: S3C24XX: move common clock init into common.c
      ARM: S3C24XX: move common power-management code to mach-s3c24xx
      ARM: S3C24XX: move plat-s3c24xx/dev-uart.c into common.c
      ARM: S3C24XX: move plat-s3c24xx/cpu.c
      ARM: OMAP2+: Kconfig: convert SOC_OMAPAM33XX to SOC_AM33XX
      ARM: OMAP2+: Kconfig: convert SOC_OMAPTI81XX to SOC_TI81XX
      GPMC: add ECC control definitions
      ARM: OMAP2+: dmtimer: remove redundant sysconfig context restore
      ARM: OMAP: AM35xx: convert 3517 detection/flags to AM35xx
      ARM: OMAP: AM35xx: remove redunant cpu_is checks for AM3505
      ARM: OMAP1: Pass dma request lines in platform data to MMC driver
      ...

commit 1fe97c8f6a1de67a5f56e029a818903d5bed8017
Author: Vaibhav Hiremath <hvaibhav@ti.com>
Date:   Wed May 9 10:07:05 2012 -0700

    ARM: OMAP: Make OMAP clocksource source selection using kernel param
    
    Current OMAP code supports couple of clocksource options based
    on compilation flag (CONFIG_OMAP_32K_TIMER). The 32KHz sync-timer
    and a gptimer which can run on 32KHz or system clock (e.g 38.4 MHz).
    So there can be 3 options -
    
    1. 32KHz sync-timer
    2. Sys_clock based (e.g 13/19.2/26/38.4 MHz) gptimer
    3. 32KHz based gptimer.
    
    The optional gptimer based clocksource was added so that it can
    give the high precision than sync-timer, so expected usage was 2
    and not 3.
    Unfortunately option 2, clocksource doesn't meet the requirement of
    free-running clock as per clocksource need. It stops in low power states
    when sys_clock is cut. That makes gptimer based clocksource option
    useless for OMAP2/3/4 devices with sys_clock as a clock input.
    So, in order to use option 2, deeper idle state MUST be disabled.
    
    Option 3 will still work but it is no better than 32K sync-timer
    based clocksource.
    
    We must support both sync timer and gptimer based clocksource as
    some OMAP based derivative SoCs like AM33XX does not have the
    sync timer.
    
    Considering above, make sync-timer and gptimer clocksource runtime
    selectable so that both OMAP and AMXXXX continue to use the same code.
    
    And, in order to precisely configure/setup sched_clock for given
    clocksource, decision has to be made early enough in boot sequence.
    
    So, the solution is,
    
    Use standard kernel parameter ("clocksource=") to override
    default 32k_sync-timer, in addition to this, we also use hwmod database
    lookup mechanism, through which at run-time we can identify availability
    of 32k-sync timer on the device, else fall back to gptimer.
    
    Also, moved low-level SoC specific init code to respective files,
    (mach-omap1/timer32k.c and mach-omap2/timer.c)
    
    Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Kevin Hilman <khilman@ti.com>
    Tested-by: Kevin Hilman <khilman@ti.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tarun Kanti DebBarma <tarun.kanti@ti.com>
    Cc: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 5068fe5a6910..b2f634ba7bc7 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -27,19 +27,20 @@
 
 #include <plat/clock.h>
 
+/* OMAP2_32KSYNCNT_CR_OFF: offset of 32ksync counter register */
+#define OMAP2_32KSYNCNT_CR_OFF		0x10
+
 /*
  * 32KHz clocksource ... always available, on pretty most chips except
  * OMAP 730 and 1510.  Other timers could be used as clocksources, with
  * higher resolution in free-running counter modes (e.g. 12 MHz xtal),
  * but systems won't necessarily want to spend resources that way.
  */
-static void __iomem *timer_32k_base;
-
-#define OMAP16XX_TIMER_32K_SYNCHRONIZED		0xfffbc410
+static void __iomem *sync32k_cnt_reg;
 
 static u32 notrace omap_32k_read_sched_clock(void)
 {
-	return timer_32k_base ? __raw_readl(timer_32k_base) : 0;
+	return sync32k_cnt_reg ? __raw_readl(sync32k_cnt_reg) : 0;
 }
 
 /**
@@ -59,7 +60,7 @@ void read_persistent_clock(struct timespec *ts)
 	struct timespec *tsp = &persistent_ts;
 
 	last_cycles = cycles;
-	cycles = timer_32k_base ? __raw_readl(timer_32k_base) : 0;
+	cycles = sync32k_cnt_reg ? __raw_readl(sync32k_cnt_reg) : 0;
 	delta = cycles - last_cycles;
 
 	nsecs = clocksource_cyc2ns(delta, persistent_mult, persistent_shift);
@@ -68,54 +69,40 @@ void read_persistent_clock(struct timespec *ts)
 	*ts = *tsp;
 }
 
-int __init omap_init_clocksource_32k(void)
+/**
+ * omap_init_clocksource_32k - setup and register counter 32k as a
+ * kernel clocksource
+ * @pbase: base addr of counter_32k module
+ * @size: size of counter_32k to map
+ *
+ * Returns 0 upon success or negative error code upon failure.
+ *
+ */
+int __init omap_init_clocksource_32k(void __iomem *vbase)
 {
-	static char err[] __initdata = KERN_ERR
-			"%s: can't register clocksource!\n";
-
-	if (cpu_is_omap16xx() || cpu_class_is_omap2()) {
-		u32 pbase;
-		unsigned long size = SZ_4K;
-		void __iomem *base;
-		struct clk *sync_32k_ick;
-
-		if (cpu_is_omap16xx()) {
-			pbase = OMAP16XX_TIMER_32K_SYNCHRONIZED;
-			size = SZ_1K;
-		} else if (cpu_is_omap2420())
-			pbase = OMAP2420_32KSYNCT_BASE + 0x10;
-		else if (cpu_is_omap2430())
-			pbase = OMAP2430_32KSYNCT_BASE + 0x10;
-		else if (cpu_is_omap34xx())
-			pbase = OMAP3430_32KSYNCT_BASE + 0x10;
-		else if (cpu_is_omap44xx())
-			pbase = OMAP4430_32KSYNCT_BASE + 0x10;
-		else
-			return -ENODEV;
-
-		/* For this to work we must have a static mapping in io.c for this area */
-		base = ioremap(pbase, size);
-		if (!base)
-			return -ENODEV;
-
-		sync_32k_ick = clk_get(NULL, "omap_32ksync_ick");
-		if (!IS_ERR(sync_32k_ick))
-			clk_enable(sync_32k_ick);
-
-		timer_32k_base = base;
-
-		/*
-		 * 120000 rough estimate from the calculations in
-		 * __clocksource_updatefreq_scale.
-		 */
-		clocks_calc_mult_shift(&persistent_mult, &persistent_shift,
-				32768, NSEC_PER_SEC, 120000);
-
-		if (clocksource_mmio_init(base, "32k_counter", 32768, 250, 32,
-					  clocksource_mmio_readl_up))
-			printk(err, "32k_counter");
-
-		setup_sched_clock(omap_32k_read_sched_clock, 32, 32768);
+	int ret;
+
+	/*
+	 * 32k sync Counter register offset is at 0x10
+	 */
+	sync32k_cnt_reg = vbase + OMAP2_32KSYNCNT_CR_OFF;
+
+	/*
+	 * 120000 rough estimate from the calculations in
+	 * __clocksource_updatefreq_scale.
+	 */
+	clocks_calc_mult_shift(&persistent_mult, &persistent_shift,
+			32768, NSEC_PER_SEC, 120000);
+
+	ret = clocksource_mmio_init(sync32k_cnt_reg, "32k_counter", 32768,
+				250, 32, clocksource_mmio_readl_up);
+	if (ret) {
+		pr_err("32k_counter: can't register clocksource\n");
+		return ret;
 	}
+
+	setup_sched_clock(omap_32k_read_sched_clock, 32, 32768);
+	pr_info("OMAP clocksource: 32k_counter at 32768 Hz\n");
+
 	return 0;
 }

commit bd0493eaaf5c7a1ea00786d46cc2f4af44e76f28
Author: Marc Zyngier <Marc.Zyngier@arm.com>
Date:   Sat May 5 19:28:44 2012 +0100

    ARM: 7413/1: move read_{boot,persistent}_clock to the architecture level
    
    At the moment, read_persistent_clock is implemented at the
    platform level, which makes it impossible to compile these
    platforms in a single kernel.
    
    Implement these two functions at the architecture level, and
    provide a thin registration interface for both read_boot_clock
    and read_persistent_clock. The two affected platforms (OMAP and
    Tegra) are converted at the same time.
    
    Reported-by: Jeff Ohlstein <johlstei@codeaurora.org>
    Tested-by: Stephen Warren <swarren@wwwdotorg.org>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 5068fe5a6910..44ae077dbc28 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -19,6 +19,7 @@
 #include <linux/io.h>
 #include <linux/clocksource.h>
 
+#include <asm/mach/time.h>
 #include <asm/sched_clock.h>
 
 #include <plat/hardware.h>
@@ -43,7 +44,7 @@ static u32 notrace omap_32k_read_sched_clock(void)
 }
 
 /**
- * read_persistent_clock -  Return time from a persistent clock.
+ * omap_read_persistent_clock -  Return time from a persistent clock.
  *
  * Reads the time from a source which isn't disabled during PM, the
  * 32k sync timer.  Convert the cycles elapsed since last read into
@@ -52,7 +53,7 @@ static u32 notrace omap_32k_read_sched_clock(void)
 static struct timespec persistent_ts;
 static cycles_t cycles, last_cycles;
 static unsigned int persistent_mult, persistent_shift;
-void read_persistent_clock(struct timespec *ts)
+static void omap_read_persistent_clock(struct timespec *ts)
 {
 	unsigned long long nsecs;
 	cycles_t delta;
@@ -116,6 +117,7 @@ int __init omap_init_clocksource_32k(void)
 			printk(err, "32k_counter");
 
 		setup_sched_clock(omap_32k_read_sched_clock, 32, 32768);
+		register_persistent_clock(NULL, omap_read_persistent_clock);
 	}
 	return 0;
 }

commit 2c799cef4d145af2182594a41cb5e5b42f2535c5
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Feb 24 10:34:35 2012 -0800

    ARM: OMAP: Remove plat/io.h by splitting it into mach/io.h and mach/hardware.h
    
    This is needed to minimize io.h so the SoC specific io.h
    for ARMs can removed.
    
    Note that minimal driver changes for DSS and RNG are needed to
    include cpu.h for SoC detection macros.
    
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Matt Mackall <mpm@selenic.com>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 5f0f2292b7fb..5068fe5a6910 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -21,6 +21,7 @@
 
 #include <asm/sched_clock.h>
 
+#include <plat/hardware.h>
 #include <plat/common.h>
 #include <plat/board.h>
 

commit 2f0778afac79bd8d226225556858a636931eeabc
Author: Marc Zyngier <Marc.Zyngier@arm.com>
Date:   Thu Dec 15 12:19:23 2011 +0100

    ARM: 7205/2: sched_clock: allow sched_clock to be selected at runtime
    
    sched_clock() is yet another blocker on the road to the single
    image. This patch implements an idea by Russell King:
    
    http://www.spinics.net/lists/linux-omap/msg49561.html
    
    Instead of asking the platform to implement both sched_clock()
    itself and the rollover callback, simply register a read()
    function, and let the ARM code care about sched_clock() itself,
    the conversion to ns and the rollover. sched_clock() uses
    this read() function as an indirection to the platform code.
    If the platform doesn't provide a read(), the code falls back
    to the jiffy counter (just like the default sched_clock).
    
    This allow some simplifications and possibly some footprint gain
    when multiple platforms are compiled in. Among the drawbacks,
    the removal of the *_fixed_sched_clock optimization which could
    negatively impact some platforms (sa1100, tegra, versatile
    and omap).
    
    Tested on 11MPCore, OMAP4 and Tegra.
    
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Colin Cross <ccross@android.com>
    Cc: Erik Gilling <konkers@android.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Alessandro Rubini <rubini@unipv.it>
    Cc: STEricsson <STEricsson_nomadik_linux@list.st.com>
    Cc: Lennert Buytenhek <kernel@wantstofly.org>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Tested-by: Jamie Iles <jamie@jamieiles.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Krzysztof Halasa <khc@pm.waw.pl>
    Acked-by: Kukjin Kim <kgene.kim@samsung.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index a6cbb712da51..5f0f2292b7fb 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -17,7 +17,6 @@
 #include <linux/clk.h>
 #include <linux/err.h>
 #include <linux/io.h>
-#include <linux/sched.h>
 #include <linux/clocksource.h>
 
 #include <asm/sched_clock.h>
@@ -37,41 +36,9 @@ static void __iomem *timer_32k_base;
 
 #define OMAP16XX_TIMER_32K_SYNCHRONIZED		0xfffbc410
 
-/*
- * Returns current time from boot in nsecs. It's OK for this to wrap
- * around for now, as it's just a relative time stamp.
- */
-static DEFINE_CLOCK_DATA(cd);
-
-/*
- * Constants generated by clocks_calc_mult_shift(m, s, 32768, NSEC_PER_SEC, 60).
- * This gives a resolution of about 30us and a wrap period of about 36hrs.
- */
-#define SC_MULT		4000000000u
-#define SC_SHIFT	17
-
-static inline unsigned long long notrace _omap_32k_sched_clock(void)
-{
-	u32 cyc = timer_32k_base ? __raw_readl(timer_32k_base) : 0;
-	return cyc_to_fixed_sched_clock(&cd, cyc, (u32)~0, SC_MULT, SC_SHIFT);
-}
-
-#if defined(CONFIG_OMAP_32K_TIMER) && !defined(CONFIG_OMAP_MPU_TIMER)
-unsigned long long notrace sched_clock(void)
-{
-	return _omap_32k_sched_clock();
-}
-#else
-unsigned long long notrace omap_32k_sched_clock(void)
-{
-	return _omap_32k_sched_clock();
-}
-#endif
-
-static void notrace omap_update_sched_clock(void)
+static u32 notrace omap_32k_read_sched_clock(void)
 {
-	u32 cyc = timer_32k_base ? __raw_readl(timer_32k_base) : 0;
-	update_sched_clock(&cd, cyc, (u32)~0);
+	return timer_32k_base ? __raw_readl(timer_32k_base) : 0;
 }
 
 /**
@@ -147,8 +114,7 @@ int __init omap_init_clocksource_32k(void)
 					  clocksource_mmio_readl_up))
 			printk(err, "32k_counter");
 
-		init_fixed_sched_clock(&cd, omap_update_sched_clock, 32,
-				       32768, SC_MULT, SC_SHIFT);
+		setup_sched_clock(omap_32k_read_sched_clock, 32, 32768);
 	}
 	return 0;
 }

commit 354a183f536a8edf6cb80ee3e3f393736e278810
Author: Russell King - ARM Linux <linux@arm.linux.org.uk>
Date:   Sun Jul 10 23:05:34 2011 -0700

    Convert OMAPs 32kHz clocksource implementation to use the generic MMIO
    clocksource support.  This achieves several things:
    
    1. It means we get rid of all these helper functions which frankly should
       never have been necessary.
    2. It means omap_readl() inside these helper functions does not appear in
       ftrace output.
    
    Another plus is that we avoid the overhead of calculating the address to
    read each time, but a minus is that we use readl() which has a barrier.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    [tony@atomide.com: updated to use ioremap]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index c13bc3d3eb2c..a6cbb712da51 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -18,6 +18,7 @@
 #include <linux/err.h>
 #include <linux/io.h>
 #include <linux/sched.h>
+#include <linux/clocksource.h>
 
 #include <asm/sched_clock.h>
 
@@ -26,87 +27,16 @@
 
 #include <plat/clock.h>
 
-
 /*
  * 32KHz clocksource ... always available, on pretty most chips except
  * OMAP 730 and 1510.  Other timers could be used as clocksources, with
  * higher resolution in free-running counter modes (e.g. 12 MHz xtal),
  * but systems won't necessarily want to spend resources that way.
  */
+static void __iomem *timer_32k_base;
 
 #define OMAP16XX_TIMER_32K_SYNCHRONIZED		0xfffbc410
 
-#include <linux/clocksource.h>
-
-/*
- * offset_32k holds the init time counter value. It is then subtracted
- * from every counter read to achieve a counter that counts time from the
- * kernel boot (needed for sched_clock()).
- */
-static u32 offset_32k __read_mostly;
-
-#ifdef CONFIG_ARCH_OMAP16XX
-static cycle_t notrace omap16xx_32k_read(struct clocksource *cs)
-{
-	return omap_readl(OMAP16XX_TIMER_32K_SYNCHRONIZED) - offset_32k;
-}
-#else
-#define omap16xx_32k_read	NULL
-#endif
-
-#ifdef CONFIG_SOC_OMAP2420
-static cycle_t notrace omap2420_32k_read(struct clocksource *cs)
-{
-	return omap_readl(OMAP2420_32KSYNCT_BASE + 0x10) - offset_32k;
-}
-#else
-#define omap2420_32k_read	NULL
-#endif
-
-#ifdef CONFIG_SOC_OMAP2430
-static cycle_t notrace omap2430_32k_read(struct clocksource *cs)
-{
-	return omap_readl(OMAP2430_32KSYNCT_BASE + 0x10) - offset_32k;
-}
-#else
-#define omap2430_32k_read	NULL
-#endif
-
-#ifdef CONFIG_ARCH_OMAP3
-static cycle_t notrace omap34xx_32k_read(struct clocksource *cs)
-{
-	return omap_readl(OMAP3430_32KSYNCT_BASE + 0x10) - offset_32k;
-}
-#else
-#define omap34xx_32k_read	NULL
-#endif
-
-#ifdef CONFIG_ARCH_OMAP4
-static cycle_t notrace omap44xx_32k_read(struct clocksource *cs)
-{
-	return omap_readl(OMAP4430_32KSYNCT_BASE + 0x10) - offset_32k;
-}
-#else
-#define omap44xx_32k_read	NULL
-#endif
-
-/*
- * Kernel assumes that sched_clock can be called early but may not have
- * things ready yet.
- */
-static cycle_t notrace omap_32k_read_dummy(struct clocksource *cs)
-{
-	return 0;
-}
-
-static struct clocksource clocksource_32k = {
-	.name		= "32k_counter",
-	.rating		= 250,
-	.read		= omap_32k_read_dummy,
-	.mask		= CLOCKSOURCE_MASK(32),
-	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
-};
-
 /*
  * Returns current time from boot in nsecs. It's OK for this to wrap
  * around for now, as it's just a relative time stamp.
@@ -122,7 +52,7 @@ static DEFINE_CLOCK_DATA(cd);
 
 static inline unsigned long long notrace _omap_32k_sched_clock(void)
 {
-	u32 cyc = clocksource_32k.read(&clocksource_32k);
+	u32 cyc = timer_32k_base ? __raw_readl(timer_32k_base) : 0;
 	return cyc_to_fixed_sched_clock(&cd, cyc, (u32)~0, SC_MULT, SC_SHIFT);
 }
 
@@ -140,7 +70,7 @@ unsigned long long notrace omap_32k_sched_clock(void)
 
 static void notrace omap_update_sched_clock(void)
 {
-	u32 cyc = clocksource_32k.read(&clocksource_32k);
+	u32 cyc = timer_32k_base ? __raw_readl(timer_32k_base) : 0;
 	update_sched_clock(&cd, cyc, (u32)~0);
 }
 
@@ -153,6 +83,7 @@ static void notrace omap_update_sched_clock(void)
  */
 static struct timespec persistent_ts;
 static cycles_t cycles, last_cycles;
+static unsigned int persistent_mult, persistent_shift;
 void read_persistent_clock(struct timespec *ts)
 {
 	unsigned long long nsecs;
@@ -160,11 +91,10 @@ void read_persistent_clock(struct timespec *ts)
 	struct timespec *tsp = &persistent_ts;
 
 	last_cycles = cycles;
-	cycles = clocksource_32k.read(&clocksource_32k);
+	cycles = timer_32k_base ? __raw_readl(timer_32k_base) : 0;
 	delta = cycles - last_cycles;
 
-	nsecs = clocksource_cyc2ns(delta,
-				   clocksource_32k.mult, clocksource_32k.shift);
+	nsecs = clocksource_cyc2ns(delta, persistent_mult, persistent_shift);
 
 	timespec_add_ns(tsp, nsecs);
 	*ts = *tsp;
@@ -176,29 +106,46 @@ int __init omap_init_clocksource_32k(void)
 			"%s: can't register clocksource!\n";
 
 	if (cpu_is_omap16xx() || cpu_class_is_omap2()) {
+		u32 pbase;
+		unsigned long size = SZ_4K;
+		void __iomem *base;
 		struct clk *sync_32k_ick;
 
-		if (cpu_is_omap16xx())
-			clocksource_32k.read = omap16xx_32k_read;
-		else if (cpu_is_omap2420())
-			clocksource_32k.read = omap2420_32k_read;
+		if (cpu_is_omap16xx()) {
+			pbase = OMAP16XX_TIMER_32K_SYNCHRONIZED;
+			size = SZ_1K;
+		} else if (cpu_is_omap2420())
+			pbase = OMAP2420_32KSYNCT_BASE + 0x10;
 		else if (cpu_is_omap2430())
-			clocksource_32k.read = omap2430_32k_read;
+			pbase = OMAP2430_32KSYNCT_BASE + 0x10;
 		else if (cpu_is_omap34xx())
-			clocksource_32k.read = omap34xx_32k_read;
+			pbase = OMAP3430_32KSYNCT_BASE + 0x10;
 		else if (cpu_is_omap44xx())
-			clocksource_32k.read = omap44xx_32k_read;
+			pbase = OMAP4430_32KSYNCT_BASE + 0x10;
 		else
 			return -ENODEV;
 
+		/* For this to work we must have a static mapping in io.c for this area */
+		base = ioremap(pbase, size);
+		if (!base)
+			return -ENODEV;
+
 		sync_32k_ick = clk_get(NULL, "omap_32ksync_ick");
 		if (!IS_ERR(sync_32k_ick))
 			clk_enable(sync_32k_ick);
 
-		offset_32k = clocksource_32k.read(&clocksource_32k);
+		timer_32k_base = base;
+
+		/*
+		 * 120000 rough estimate from the calculations in
+		 * __clocksource_updatefreq_scale.
+		 */
+		clocks_calc_mult_shift(&persistent_mult, &persistent_shift,
+				32768, NSEC_PER_SEC, 120000);
 
-		if (clocksource_register_hz(&clocksource_32k, 32768))
-			printk(err, clocksource_32k.name);
+		if (clocksource_mmio_init(base, "32k_counter", 32768, 250, 32,
+					  clocksource_mmio_readl_up))
+			printk(err, "32k_counter");
 
 		init_fixed_sched_clock(&cd, omap_update_sched_clock, 32,
 				       32768, SC_MULT, SC_SHIFT);

commit 3d05a3e80c44cb792fc8194fd9abdb431dea5420
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Mar 29 15:54:49 2011 -0700

    omap2+: Use dmtimer macros for clocksource
    
    Use dmtimer macros for clocksource. As with the clockevent,
    this allows us to initialize the rest of dmtimer code later on.
    
    Note that eventually we will be initializing the timesource
    from init_early so sched_clock will work properly for
    CONFIG_PRINTK_TIME.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index f7fed6080190..c13bc3d3eb2c 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -126,7 +126,7 @@ static inline unsigned long long notrace _omap_32k_sched_clock(void)
 	return cyc_to_fixed_sched_clock(&cd, cyc, (u32)~0, SC_MULT, SC_SHIFT);
 }
 
-#ifndef CONFIG_OMAP_MPU_TIMER
+#if defined(CONFIG_OMAP_32K_TIMER) && !defined(CONFIG_OMAP_MPU_TIMER)
 unsigned long long notrace sched_clock(void)
 {
 	return _omap_32k_sched_clock();

commit 59b479e0985f0b795d68331d6443a7f89c47768d
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Jan 27 16:39:40 2011 -0800

    omap: Start using CONFIG_SOC_OMAP
    
    We want to have just CONFIG_ARCH_OMAP2, 3 and 4. The rest
    are nowadays just subcategories of these.
    
    Search and replace the following:
    
    ARCH_OMAP2420           SOC_OMAP2420
    ARCH_OMAP2430           SOC_OMAP2430
    ARCH_OMAP3430           SOC_OMAP3430
    
    No functional changes.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Thomas Weber <weber@corscience.de>
    Acked-by: Sourav Poddar <sourav.poddar@ti.com>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 862dda95d61d..f7fed6080190 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -54,7 +54,7 @@ static cycle_t notrace omap16xx_32k_read(struct clocksource *cs)
 #define omap16xx_32k_read	NULL
 #endif
 
-#ifdef CONFIG_ARCH_OMAP2420
+#ifdef CONFIG_SOC_OMAP2420
 static cycle_t notrace omap2420_32k_read(struct clocksource *cs)
 {
 	return omap_readl(OMAP2420_32KSYNCT_BASE + 0x10) - offset_32k;
@@ -63,7 +63,7 @@ static cycle_t notrace omap2420_32k_read(struct clocksource *cs)
 #define omap2420_32k_read	NULL
 #endif
 
-#ifdef CONFIG_ARCH_OMAP2430
+#ifdef CONFIG_SOC_OMAP2430
 static cycle_t notrace omap2430_32k_read(struct clocksource *cs)
 {
 	return omap_readl(OMAP2430_32KSYNCT_BASE + 0x10) - offset_32k;

commit 4912cf04b202a9d0bdc4082ecb9247943584450d
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Jan 18 17:00:00 2011 -0800

    omap1: Fix sched_clock implementation when both MPU timer and 32K timer are used
    
    Earlier patches select HAVE_SCHED_CLOCK for omaps. To have working sched_clock
    also for MPU timer, we need to implement it in a way where the right one gets
    selected during the runtime.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 5d7b08b5a13a..862dda95d61d 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -120,12 +120,24 @@ static DEFINE_CLOCK_DATA(cd);
 #define SC_MULT		4000000000u
 #define SC_SHIFT	17
 
-unsigned long long notrace sched_clock(void)
+static inline unsigned long long notrace _omap_32k_sched_clock(void)
 {
 	u32 cyc = clocksource_32k.read(&clocksource_32k);
 	return cyc_to_fixed_sched_clock(&cd, cyc, (u32)~0, SC_MULT, SC_SHIFT);
 }
 
+#ifndef CONFIG_OMAP_MPU_TIMER
+unsigned long long notrace sched_clock(void)
+{
+	return _omap_32k_sched_clock();
+}
+#else
+unsigned long long notrace omap_32k_sched_clock(void)
+{
+	return _omap_32k_sched_clock();
+}
+#endif
+
 static void notrace omap_update_sched_clock(void)
 {
 	u32 cyc = clocksource_32k.read(&clocksource_32k);

commit 05b5ca9b100300c8b98429962071aa66c5d2460e
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Jan 18 12:42:23 2011 -0800

    omap1: Fix booting for 15xx and 730 with omap1_defconfig
    
    For omap15xx and 730 we need to use the MPU timer
    as the 32K timer is not available. For omap16xx
    we want to use the 32K timer because of PM. Fix this
    by allowing to build in both timers.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 0367998ff685..5d7b08b5a13a 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -36,8 +36,6 @@
 
 #define OMAP16XX_TIMER_32K_SYNCHRONIZED		0xfffbc410
 
-#if !(defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP15XX))
-
 #include <linux/clocksource.h>
 
 /*
@@ -195,6 +193,3 @@ int __init omap_init_clocksource_32k(void)
 	}
 	return 0;
 }
-
-#endif	/* !(defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP15XX)) */
-

commit d8328f3b85f34c0dc5866f10bf6e7842fb511d62
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Jan 15 21:32:01 2011 -0700

    OMAP: counter_32k: init clocksource as part of machine timer init
    
    After commit dc548fbbd2ecd0fc3b02301d551e5f8e19ae58fd ("ARM: omap: convert
    sched_clock() to use new infrastructure"), OMAPs that use the 32KiHz
    "synchronization timer" as their clocksource crash during boot:
    
    [    0.000000] OMAP clockevent source: GPTIMER1 at 32768 Hz
    [    0.000000] Unable to handle kernel NULL pointer dereference at virtual address 00000000
    [    0.000000] pgd = c0004000
    [    0.000000] [00000000] *pgd=00000000
    [    0.000000] Internal error: Oops: 80000005 [#1] SMP
    [    0.000000] last sysfs file:
    [    0.000000] Modules linked in:
    [    0.000000] CPU: 0    Tainted: G        W    (2.6.37-07734-g2467802 #7)
    [    0.000000] PC is at 0x0
    [    0.000000] LR is at sched_clock_poll+0x2c/0x3c
    [    0.000000] pc : [<00000000>]    lr : [<c0060b74>]    psr: 600001d3
    [    0.000000] sp : c058bfd0  ip : c058a000  fp : 00000000
    [    0.000000] r10: 00000000  r9 : 411fc092  r8 : 800330c8
    [    0.000000] r7 : c05a08e0  r6 : c0034c48  r5 : c05ffc40  r4 : c0034c4c
    [    0.000000] r3 : c05ffe6c  r2 : c05a0bc0  r1 : c059f098  r0 : 00000000
    [    0.000000] Flags: nZCv  IRQs off  FIQs off  Mode SVC_32  ISA ARM  Segment kernel
    [    0.000000] Control: 10c53c7f  Table: 8000404a  DAC: 00000017
    
    This is due to the recent ARM init_sched_clock() changes and the late
    initialization of the counter_32k clock source.  More information here:
    
       http://marc.info/?l=linux-omap&m=129513468605208&w=2
    
    Fix by initializing the counter_32k clocksource during the machine timer
    initialization.
    
    Reported-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Tested-by: Thomas Weber <weber@corscience.de>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index ea4644021fb9..0367998ff685 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -160,7 +160,7 @@ void read_persistent_clock(struct timespec *ts)
 	*ts = *tsp;
 }
 
-static int __init omap_init_clocksource_32k(void)
+int __init omap_init_clocksource_32k(void)
 {
 	static char err[] __initdata = KERN_ERR
 			"%s: can't register clocksource!\n";
@@ -195,7 +195,6 @@ static int __init omap_init_clocksource_32k(void)
 	}
 	return 0;
 }
-arch_initcall(omap_init_clocksource_32k);
 
 #endif	/* !(defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP15XX)) */
 

commit 58daf18cdcab550262a5f4681e1f1e073e21965a
Merge: aa312be1987d 0af85dda39d9
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Jan 5 18:09:03 2011 +0000

    Merge branch 'clksrc' into devel
    
    Conflicts:
            arch/arm/mach-vexpress/v2m.c
            arch/arm/plat-omap/counter_32k.c
            arch/arm/plat-versatile/Makefile

commit dc548fbbd2ecd0fc3b02301d551e5f8e19ae58fd
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Dec 15 21:53:51 2010 +0000

    ARM: omap: convert sched_clock() to use new infrastructure
    
    Convert omap to use the new sched_clock() infrastructure for extending
    32bit counters to full 64-bit nanoseconds.
    
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index aed301bfa2f9..1b558efbe732 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -18,6 +18,8 @@
 #include <linux/io.h>
 #include <linux/sched.h>
 
+#include <asm/sched_clock.h>
+
 #include <plat/common.h>
 #include <plat/board.h>
 
@@ -110,10 +112,25 @@ static struct clocksource clocksource_32k = {
  * Returns current time from boot in nsecs. It's OK for this to wrap
  * around for now, as it's just a relative time stamp.
  */
+static DEFINE_CLOCK_DATA(cd);
+
+/*
+ * Constants generated by clocks_calc_mult_shift(m, s, 32768, NSEC_PER_SEC, 60).
+ * This gives a resolution of about 30us and a wrap period of about 36hrs.
+ */
+#define SC_MULT		4000000000u
+#define SC_SHIFT	17
+
 unsigned long long notrace sched_clock(void)
 {
-	return clocksource_cyc2ns(clocksource_32k.read(&clocksource_32k),
-				  clocksource_32k.mult, clocksource_32k.shift);
+	u32 cyc = clocksource_32k.read(&clocksource_32k);
+	return cyc_to_fixed_sched_clock(&cd, cyc, (u32)~0, SC_MULT, SC_SHIFT);
+}
+
+static void notrace omap_update_sched_clock(void)
+{
+	u32 cyc = clocksource_32k.read(&clocksource_32k);
+	update_sched_clock(&cd, cyc, (u32)~0);
 }
 
 /**
@@ -171,6 +188,9 @@ static int __init omap_init_clocksource_32k(void)
 
 		if (clocksource_register_hz(&clocksource_32k, 32768))
 			printk(err, clocksource_32k.name);
+
+		init_fixed_sched_clock(&cd, omap_update_sched_clock, 32,
+				       32768, SC_MULT, SC_SHIFT);
 	}
 	return 0;
 }

commit 5e06b6492e53ab2a4e467763a9ee9f70b032c301
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Dec 15 19:19:25 2010 +0000

    ARM: ensure all sched_clock() implementations are notrace marked
    
    ftrace requires sched_clock() to be notrace.  Ensure that all
    implementations are so marked.  Also make sure that they include
    linux/sched.h
    
    Also ensure OMAP clocksource read functions are marked notrace as
    they're used for sched_clock() too.
    
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Will Deacon <will.deacon@arm.com>
    Tested-by: Mikael Pettersson <mikpe@it.uu.se>
    Tested-by: Eric Miao <eric.y.miao@gmail.com>
    Tested-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 8f149f51cb46..aed301bfa2f9 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -16,6 +16,7 @@
 #include <linux/init.h>
 #include <linux/clk.h>
 #include <linux/io.h>
+#include <linux/sched.h>
 
 #include <plat/common.h>
 #include <plat/board.h>
@@ -44,7 +45,7 @@
 static u32 offset_32k __read_mostly;
 
 #ifdef CONFIG_ARCH_OMAP16XX
-static cycle_t omap16xx_32k_read(struct clocksource *cs)
+static cycle_t notrace omap16xx_32k_read(struct clocksource *cs)
 {
 	return omap_readl(OMAP16XX_TIMER_32K_SYNCHRONIZED) - offset_32k;
 }
@@ -53,7 +54,7 @@ static cycle_t omap16xx_32k_read(struct clocksource *cs)
 #endif
 
 #ifdef CONFIG_ARCH_OMAP2420
-static cycle_t omap2420_32k_read(struct clocksource *cs)
+static cycle_t notrace omap2420_32k_read(struct clocksource *cs)
 {
 	return omap_readl(OMAP2420_32KSYNCT_BASE + 0x10) - offset_32k;
 }
@@ -62,7 +63,7 @@ static cycle_t omap2420_32k_read(struct clocksource *cs)
 #endif
 
 #ifdef CONFIG_ARCH_OMAP2430
-static cycle_t omap2430_32k_read(struct clocksource *cs)
+static cycle_t notrace omap2430_32k_read(struct clocksource *cs)
 {
 	return omap_readl(OMAP2430_32KSYNCT_BASE + 0x10) - offset_32k;
 }
@@ -71,7 +72,7 @@ static cycle_t omap2430_32k_read(struct clocksource *cs)
 #endif
 
 #ifdef CONFIG_ARCH_OMAP3
-static cycle_t omap34xx_32k_read(struct clocksource *cs)
+static cycle_t notrace omap34xx_32k_read(struct clocksource *cs)
 {
 	return omap_readl(OMAP3430_32KSYNCT_BASE + 0x10) - offset_32k;
 }
@@ -80,7 +81,7 @@ static cycle_t omap34xx_32k_read(struct clocksource *cs)
 #endif
 
 #ifdef CONFIG_ARCH_OMAP4
-static cycle_t omap44xx_32k_read(struct clocksource *cs)
+static cycle_t notrace omap44xx_32k_read(struct clocksource *cs)
 {
 	return omap_readl(OMAP4430_32KSYNCT_BASE + 0x10) - offset_32k;
 }
@@ -92,7 +93,7 @@ static cycle_t omap44xx_32k_read(struct clocksource *cs)
  * Kernel assumes that sched_clock can be called early but may not have
  * things ready yet.
  */
-static cycle_t omap_32k_read_dummy(struct clocksource *cs)
+static cycle_t notrace omap_32k_read_dummy(struct clocksource *cs)
 {
 	return 0;
 }
@@ -109,7 +110,7 @@ static struct clocksource clocksource_32k = {
  * Returns current time from boot in nsecs. It's OK for this to wrap
  * around for now, as it's just a relative time stamp.
  */
-unsigned long long sched_clock(void)
+unsigned long long notrace sched_clock(void)
 {
 	return clocksource_cyc2ns(clocksource_32k.read(&clocksource_32k),
 				  clocksource_32k.mult, clocksource_32k.shift);

commit 8437c25e78c3af2b31bf6c8942494e34e267f446
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Dec 13 13:18:44 2010 +0000

    ARM: omap: update clock source registration
    
    In d7e81c2 (clocksource: Add clocksource_register_hz/khz interface) new
    interfaces were added which simplify (and optimize) the selection of the
    divisor shift/mult constants.  Switch over to using this new interface.
    
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 155fe43a672b..8f149f51cb46 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -102,7 +102,6 @@ static struct clocksource clocksource_32k = {
 	.rating		= 250,
 	.read		= omap_32k_read_dummy,
 	.mask		= CLOCKSOURCE_MASK(32),
-	.shift		= 10,
 	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
@@ -167,12 +166,9 @@ static int __init omap_init_clocksource_32k(void)
 		if (sync_32k_ick)
 			clk_enable(sync_32k_ick);
 
-		clocksource_32k.mult = clocksource_hz2mult(32768,
-					    clocksource_32k.shift);
-
 		offset_32k = clocksource_32k.read(&clocksource_32k);
 
-		if (clocksource_register(&clocksource_32k))
+		if (clocksource_register_hz(&clocksource_32k, 32768))
 			printk(err, clocksource_32k.name);
 	}
 	return 0;

commit cb9675f3282f5565cc9e3698cc847355c1194871
Author: Vasiliy Kulikov <segoon@openwall.com>
Date:   Fri Nov 26 17:06:02 2010 +0000

    arm: plat-omap: counter_32k: use IS_ERR() instead of NULL check
    
    clk_get() returns ERR_PTR() on error, not NULL.
    
    Signed-off-by: Vasiliy Kulikov <segoon@openwall.com>
    Acked-by: Kevin Hilman <khilman@deeprootsystems.com>
    [tony@atomide.com: updated to include err.h to compile on omap1]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 155fe43a672b..8722a136f3a5 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -16,6 +16,7 @@
 #include <linux/init.h>
 #include <linux/clk.h>
 #include <linux/io.h>
+#include <linux/err.h>
 
 #include <plat/common.h>
 #include <plat/board.h>
@@ -164,7 +165,7 @@ static int __init omap_init_clocksource_32k(void)
 			return -ENODEV;
 
 		sync_32k_ick = clk_get(NULL, "omap_32ksync_ick");
-		if (sync_32k_ick)
+		if (!IS_ERR(sync_32k_ick))
 			clk_enable(sync_32k_ick);
 
 		clocksource_32k.mult = clocksource_hz2mult(32768,

commit aa218dafd7b37ba92fcfdd6d5c8d459772f88042
Author: Paul Walmsley <paul@pwsan.com>
Date:   Fri Oct 8 11:40:19 2010 -0600

    OMAP: split plat-omap/common.c
    
    Split plat-omap/common.c into three pieces:
    
    1. the 32KiHz sync timer and clocksource code, which now lives in
       plat-omap/counter_32k.c;
    
    2. the OMAP2+ common code, which has been moved to mach-omap2/common.c;
    
    3. and the remainder of the OMAP-wide common code, which includes the
       deprecated ATAGs code and a deprecated video RAM reservation function.
    
    The primary motivation for doing this is to move the OMAP2+-specific parts
    into an OMAP2+-specific file, so that build breakage related to the
    System Control Module code can be resolved.
    
    Benot Cousson <b-cousson@ti.com> suggested a new filename and found
    some bugs in the counter_32k.c comments - thanks Benot.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
new file mode 100644
index 000000000000..155fe43a672b
--- /dev/null
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -0,0 +1,183 @@
+/*
+ * OMAP 32ksynctimer/counter_32k-related code
+ *
+ * Copyright (C) 2009 Texas Instruments
+ * Copyright (C) 2010 Nokia Corporation
+ * Tony Lindgren <tony@atomide.com>
+ * Added OMAP4 support - Santosh Shilimkar <santosh.shilimkar@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * NOTE: This timer is not the same timer as the old OMAP1 MPU timer.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+#include <plat/common.h>
+#include <plat/board.h>
+
+#include <plat/clock.h>
+
+
+/*
+ * 32KHz clocksource ... always available, on pretty most chips except
+ * OMAP 730 and 1510.  Other timers could be used as clocksources, with
+ * higher resolution in free-running counter modes (e.g. 12 MHz xtal),
+ * but systems won't necessarily want to spend resources that way.
+ */
+
+#define OMAP16XX_TIMER_32K_SYNCHRONIZED		0xfffbc410
+
+#if !(defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP15XX))
+
+#include <linux/clocksource.h>
+
+/*
+ * offset_32k holds the init time counter value. It is then subtracted
+ * from every counter read to achieve a counter that counts time from the
+ * kernel boot (needed for sched_clock()).
+ */
+static u32 offset_32k __read_mostly;
+
+#ifdef CONFIG_ARCH_OMAP16XX
+static cycle_t omap16xx_32k_read(struct clocksource *cs)
+{
+	return omap_readl(OMAP16XX_TIMER_32K_SYNCHRONIZED) - offset_32k;
+}
+#else
+#define omap16xx_32k_read	NULL
+#endif
+
+#ifdef CONFIG_ARCH_OMAP2420
+static cycle_t omap2420_32k_read(struct clocksource *cs)
+{
+	return omap_readl(OMAP2420_32KSYNCT_BASE + 0x10) - offset_32k;
+}
+#else
+#define omap2420_32k_read	NULL
+#endif
+
+#ifdef CONFIG_ARCH_OMAP2430
+static cycle_t omap2430_32k_read(struct clocksource *cs)
+{
+	return omap_readl(OMAP2430_32KSYNCT_BASE + 0x10) - offset_32k;
+}
+#else
+#define omap2430_32k_read	NULL
+#endif
+
+#ifdef CONFIG_ARCH_OMAP3
+static cycle_t omap34xx_32k_read(struct clocksource *cs)
+{
+	return omap_readl(OMAP3430_32KSYNCT_BASE + 0x10) - offset_32k;
+}
+#else
+#define omap34xx_32k_read	NULL
+#endif
+
+#ifdef CONFIG_ARCH_OMAP4
+static cycle_t omap44xx_32k_read(struct clocksource *cs)
+{
+	return omap_readl(OMAP4430_32KSYNCT_BASE + 0x10) - offset_32k;
+}
+#else
+#define omap44xx_32k_read	NULL
+#endif
+
+/*
+ * Kernel assumes that sched_clock can be called early but may not have
+ * things ready yet.
+ */
+static cycle_t omap_32k_read_dummy(struct clocksource *cs)
+{
+	return 0;
+}
+
+static struct clocksource clocksource_32k = {
+	.name		= "32k_counter",
+	.rating		= 250,
+	.read		= omap_32k_read_dummy,
+	.mask		= CLOCKSOURCE_MASK(32),
+	.shift		= 10,
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+/*
+ * Returns current time from boot in nsecs. It's OK for this to wrap
+ * around for now, as it's just a relative time stamp.
+ */
+unsigned long long sched_clock(void)
+{
+	return clocksource_cyc2ns(clocksource_32k.read(&clocksource_32k),
+				  clocksource_32k.mult, clocksource_32k.shift);
+}
+
+/**
+ * read_persistent_clock -  Return time from a persistent clock.
+ *
+ * Reads the time from a source which isn't disabled during PM, the
+ * 32k sync timer.  Convert the cycles elapsed since last read into
+ * nsecs and adds to a monotonically increasing timespec.
+ */
+static struct timespec persistent_ts;
+static cycles_t cycles, last_cycles;
+void read_persistent_clock(struct timespec *ts)
+{
+	unsigned long long nsecs;
+	cycles_t delta;
+	struct timespec *tsp = &persistent_ts;
+
+	last_cycles = cycles;
+	cycles = clocksource_32k.read(&clocksource_32k);
+	delta = cycles - last_cycles;
+
+	nsecs = clocksource_cyc2ns(delta,
+				   clocksource_32k.mult, clocksource_32k.shift);
+
+	timespec_add_ns(tsp, nsecs);
+	*ts = *tsp;
+}
+
+static int __init omap_init_clocksource_32k(void)
+{
+	static char err[] __initdata = KERN_ERR
+			"%s: can't register clocksource!\n";
+
+	if (cpu_is_omap16xx() || cpu_class_is_omap2()) {
+		struct clk *sync_32k_ick;
+
+		if (cpu_is_omap16xx())
+			clocksource_32k.read = omap16xx_32k_read;
+		else if (cpu_is_omap2420())
+			clocksource_32k.read = omap2420_32k_read;
+		else if (cpu_is_omap2430())
+			clocksource_32k.read = omap2430_32k_read;
+		else if (cpu_is_omap34xx())
+			clocksource_32k.read = omap34xx_32k_read;
+		else if (cpu_is_omap44xx())
+			clocksource_32k.read = omap44xx_32k_read;
+		else
+			return -ENODEV;
+
+		sync_32k_ick = clk_get(NULL, "omap_32ksync_ick");
+		if (sync_32k_ick)
+			clk_enable(sync_32k_ick);
+
+		clocksource_32k.mult = clocksource_hz2mult(32768,
+					    clocksource_32k.shift);
+
+		offset_32k = clocksource_32k.read(&clocksource_32k);
+
+		if (clocksource_register(&clocksource_32k))
+			printk(err, clocksource_32k.name);
+	}
+	return 0;
+}
+arch_initcall(omap_init_clocksource_32k);
+
+#endif	/* !(defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP15XX)) */
+
