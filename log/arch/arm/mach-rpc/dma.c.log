commit 24e44913aa746098349370a0f279733c0cadcba7
Merge: 31cc088a4f5d 7e8a0f108990
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 19 17:05:08 2019 -0700

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc
    
    Pull ARM SoC platform updates from Olof Johansson:
     "SoC platform changes. Main theme this merge window:
    
       - The Netx platform (Netx 100/500) platform is removed by Linus
         Walleij-- the SoC doesn't have active maintainers with hardware,
         and in discussions with the vendor the agreement was that it's OK
         to remove.
    
       - Russell King has a series of patches that cleans up and refactors
         SA1101 and RiscPC support"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc: (47 commits)
      ARM: stm32: use "depends on" instead of "if" after prompt
      ARM: sa1100: convert to common clock framework
      ARM: exynos: Cleanup cppcheck shifting warning
      ARM: pxa/lubbock: remove lubbock_set_misc_wr() from global view
      ARM: exynos: Only build MCPM support if used
      arm: add missing include platform-data/atmel.h
      ARM: davinci: Use GPIO lookup table for DA850 LEDs
      ARM: OMAP2: drop explicit assembler architecture
      ARM: use arch_extension directive instead of arch argument
      ARM: imx: Switch imx7d to imx-cpufreq-dt for speed-grading
      ARM: bcm: Enable PINCTRL for ARCH_BRCMSTB
      ARM: bcm: Enable ARCH_HAS_RESET_CONTROLLER for ARCH_BRCMSTB
      ARM: riscpc: enable chained scatterlist support
      ARM: riscpc: reduce IRQ handling code
      ARM: riscpc: move RiscPC assembly files from arch/arm/lib to mach-rpc
      ARM: riscpc: parse video information from tagged list
      ARM: riscpc: add ecard quirk for Atomwide 3port serial card
      MAINTAINERS: mvebu: Add git entry
      soc: ti: pm33xx: Add a print while entering RTC only mode with DDR in self-refresh
      ARM: OMAP2+: Make some variables static
      ...

commit 1f6db18fbd764ea3079eba289652b622f9c8c5ef
Merge: d6c8204659eb 0b40deeef6d9
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Wed Jul 3 11:44:46 2019 +0100

    Merge branch 'sa1100-for-next'; commit 'riscpc^{/ARM: riscpc: enable chained scatterlist support}' into for-arm-soc

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index f2703ca17954..488d5c3b37f4 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  linux/arch/arm/mach-rpc/dma.c
  *
  *  Copyright (C) 1998 Russell King
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  *  DMA functions specific to RiscPC architecture
  */
 #include <linux/mman.h>

commit 090a37ceda3ecb02061a1415239aa1a64c184833
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Thu May 2 17:56:49 2019 +0100

    ARM: riscpc: dma: use __iomem pointers for writing DMA
    
    Use __iomem pointers for efficiency to write the DMA registers.
    This avoids the compiler emitting several instructions for each access
    to calculate the register address.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index 6140472d148e..eeda808a7320 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -27,9 +27,9 @@
 
 struct iomd_dma {
 	struct dma_struct	dma;
-	unsigned int		state;
-	unsigned long		base;		/* Controller base address */
+	void __iomem		*base;		/* Controller base address */
 	int			irq;		/* Controller IRQ */
+	unsigned int		state;
 	dma_addr_t		cur_addr;
 	unsigned int		cur_len;
 	dma_addr_t		dma_addr;
@@ -98,12 +98,12 @@ static void iomd_get_next_sg(struct iomd_dma *idma)
 static irqreturn_t iomd_dma_handle(int irq, void *dev_id)
 {
 	struct iomd_dma *idma = dev_id;
-	unsigned long base = idma->base;
+	void __iomem *base = idma->base;
 	unsigned int state = idma->state;
 	unsigned int status, cur, end;
 
 	do {
-		status = iomd_readb(base + ST);
+		status = readb(base + ST);
 		if (!(status & DMA_ST_INT))
 			goto out;
 
@@ -119,8 +119,8 @@ static irqreturn_t iomd_dma_handle(int irq, void *dev_id)
 			cur = CURB;
 			end = ENDB;
 		}
-		iomd_writel(idma->cur_addr, base + cur);
-		iomd_writel(idma->cur_len, base + end);
+		writel(idma->cur_addr, base + cur);
+		writel(idma->cur_len, base + end);
 
 		if (status & DMA_ST_OFL &&
 		    idma->cur_len == (DMA_END_S|DMA_END_L))
@@ -152,7 +152,7 @@ static void iomd_free_dma(unsigned int chan, dma_t *dma)
 static void iomd_enable_dma(unsigned int chan, dma_t *dma)
 {
 	struct iomd_dma *idma = container_of(dma, struct iomd_dma, dma);
-	unsigned long dma_base = idma->base;
+	void __iomem *base = idma->base;
 	unsigned int ctrl = TRANSFER_SIZE | DMA_CR_E;
 
 	if (idma->dma.invalid) {
@@ -175,27 +175,27 @@ static void iomd_enable_dma(unsigned int chan, dma_t *dma)
 		idma->dma_addr = idma->dma.sg->dma_address;
 		idma->dma_len = idma->dma.sg->length;
 
-		iomd_writeb(DMA_CR_C, dma_base + CR);
+		writeb(DMA_CR_C, base + CR);
 		idma->state = DMA_ST_AB;
 	}
 
 	if (idma->dma.dma_mode == DMA_MODE_READ)
 		ctrl |= DMA_CR_D;
 
-	iomd_writeb(ctrl, dma_base + CR);
+	writeb(ctrl, base + CR);
 	enable_irq(idma->irq);
 }
 
 static void iomd_disable_dma(unsigned int chan, dma_t *dma)
 {
 	struct iomd_dma *idma = container_of(dma, struct iomd_dma, dma);
-	unsigned long dma_base = idma->base;
+	void __iomem *base = idma->base;
 	unsigned long flags;
 
 	local_irq_save(flags);
 	if (idma->state != ~DMA_ST_AB)
 		disable_irq(idma->irq);
-	iomd_writeb(0, dma_base + CR);
+	writeb(0, base + CR);
 	local_irq_restore(flags);
 }
 
@@ -358,17 +358,17 @@ static int __init rpc_dma_init(void)
 	 */
 	iomd_writeb(DMA_EXT_IO3|DMA_EXT_IO2, IOMD_DMAEXT);
 
-	iomd_dma[DMA_0].base	= IOMD_IO0CURA;
+	iomd_dma[DMA_0].base	= IOMD_BASE + IOMD_IO0CURA;
 	iomd_dma[DMA_0].irq	= IRQ_DMA0;
-	iomd_dma[DMA_1].base	= IOMD_IO1CURA;
+	iomd_dma[DMA_1].base	= IOMD_BASE + IOMD_IO1CURA;
 	iomd_dma[DMA_1].irq	= IRQ_DMA1;
-	iomd_dma[DMA_2].base	= IOMD_IO2CURA;
+	iomd_dma[DMA_2].base	= IOMD_BASE + IOMD_IO2CURA;
 	iomd_dma[DMA_2].irq	= IRQ_DMA2;
-	iomd_dma[DMA_3].base	= IOMD_IO3CURA;
+	iomd_dma[DMA_3].base	= IOMD_BASE + IOMD_IO3CURA;
 	iomd_dma[DMA_3].irq	= IRQ_DMA3;
-	iomd_dma[DMA_S0].base	= IOMD_SD0CURA;
+	iomd_dma[DMA_S0].base	= IOMD_BASE + IOMD_SD0CURA;
 	iomd_dma[DMA_S0].irq	= IRQ_DMAS0;
-	iomd_dma[DMA_S1].base	= IOMD_SD1CURA;
+	iomd_dma[DMA_S1].base	= IOMD_BASE + IOMD_SD1CURA;
 	iomd_dma[DMA_S1].irq	= IRQ_DMAS1;
 
 	for (i = DMA_0; i <= DMA_S1; i++) {

commit e659587c64b3d48a9293e34eb854967654ed98f7
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Thu May 2 17:50:55 2019 +0100

    ARM: riscpc: dma: improve address/length writing
    
    Rearrange writing the DMA addresses to generate more efficient code.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index e2b9c95d853b..6140472d148e 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -100,7 +100,7 @@ static irqreturn_t iomd_dma_handle(int irq, void *dev_id)
 	struct iomd_dma *idma = dev_id;
 	unsigned long base = idma->base;
 	unsigned int state = idma->state;
-	unsigned int status;
+	unsigned int status, cur, end;
 
 	do {
 		status = iomd_readb(base + ST);
@@ -110,21 +110,17 @@ static irqreturn_t iomd_dma_handle(int irq, void *dev_id)
 		if ((state ^ status) & DMA_ST_AB)
 			iomd_get_next_sg(idma);
 
-		switch (status & (DMA_ST_OFL | DMA_ST_AB)) {
-		case DMA_ST_OFL:			/* OIA */
-		case DMA_ST_AB:				/* .IB */
-			iomd_writel(idma->cur_addr, base + CURA);
-			iomd_writel(idma->cur_len, base + ENDA);
-			state = DMA_ST_AB;
-			break;
-
-		case DMA_ST_OFL | DMA_ST_AB:		/* OIB */
-		case 0:					/* .IA */
-			iomd_writel(idma->cur_addr, base + CURB);
-			iomd_writel(idma->cur_len, base + ENDB);
-			state = 0;
-			break;
+		// This efficiently implements state = OFL != AB ? AB : 0
+		state = ((status >> 2) ^ status) & DMA_ST_AB;
+		if (state) {
+			cur = CURA;
+			end = ENDA;
+		} else {
+			cur = CURB;
+			end = ENDB;
 		}
+		iomd_writel(idma->cur_addr, base + cur);
+		iomd_writel(idma->cur_len, base + end);
 
 		if (status & DMA_ST_OFL &&
 		    idma->cur_len == (DMA_END_S|DMA_END_L))

commit 39694ed0dbe17de1eff7850e7481bef98047130c
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Thu May 2 17:43:36 2019 +0100

    ARM: riscpc: dma: make state a local variable
    
    Make state a local variable to avoid rewriting it in the DMA loop.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index 37750c6493b4..e2b9c95d853b 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -99,15 +99,15 @@ static irqreturn_t iomd_dma_handle(int irq, void *dev_id)
 {
 	struct iomd_dma *idma = dev_id;
 	unsigned long base = idma->base;
+	unsigned int state = idma->state;
+	unsigned int status;
 
 	do {
-		unsigned int status;
-
 		status = iomd_readb(base + ST);
 		if (!(status & DMA_ST_INT))
-			return IRQ_HANDLED;
+			goto out;
 
-		if ((idma->state ^ status) & DMA_ST_AB)
+		if ((state ^ status) & DMA_ST_AB)
 			iomd_get_next_sg(idma);
 
 		switch (status & (DMA_ST_OFL | DMA_ST_AB)) {
@@ -115,14 +115,14 @@ static irqreturn_t iomd_dma_handle(int irq, void *dev_id)
 		case DMA_ST_AB:				/* .IB */
 			iomd_writel(idma->cur_addr, base + CURA);
 			iomd_writel(idma->cur_len, base + ENDA);
-			idma->state = DMA_ST_AB;
+			state = DMA_ST_AB;
 			break;
 
 		case DMA_ST_OFL | DMA_ST_AB:		/* OIB */
 		case 0:					/* .IA */
 			iomd_writel(idma->cur_addr, base + CURB);
 			iomd_writel(idma->cur_len, base + ENDB);
-			idma->state = 0;
+			state = 0;
 			break;
 		}
 
@@ -131,9 +131,10 @@ static irqreturn_t iomd_dma_handle(int irq, void *dev_id)
 			break;
 	} while (1);
 
-	idma->state = ~DMA_ST_AB;
+	state = ~DMA_ST_AB;
 	disable_irq_nosync(irq);
-
+out:
+	idma->state = state;
 	return IRQ_HANDLED;
 }
 

commit 8194468fadaaac5e04558d955e7bff8692212459
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Thu May 2 17:37:51 2019 +0100

    ARM: riscpc: dma: eliminate "cur_sg" scatterlist usage
    
    All we really need is the DMA address and size, we don't need the
    baggage of a full scatterlist structure.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index c4c96661eb89..37750c6493b4 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -30,7 +30,8 @@ struct iomd_dma {
 	unsigned int		state;
 	unsigned long		base;		/* Controller base address */
 	int			irq;		/* Controller IRQ */
-	struct scatterlist	cur_sg;		/* Current controller buffer */
+	dma_addr_t		cur_addr;
+	unsigned int		cur_len;
 	dma_addr_t		dma_addr;
 	unsigned int		dma_len;
 };
@@ -53,13 +54,13 @@ typedef enum {
 #define CR	(IOMD_IO0CR - IOMD_IO0CURA)
 #define ST	(IOMD_IO0ST - IOMD_IO0CURA)
 
-static void iomd_get_next_sg(struct scatterlist *sg, struct iomd_dma *idma)
+static void iomd_get_next_sg(struct iomd_dma *idma)
 {
 	unsigned long end, offset, flags = 0;
 
 	if (idma->dma.sg) {
-		sg->dma_address = idma->dma_addr;
-		offset = sg->dma_address & ~PAGE_MASK;
+		idma->cur_addr = idma->dma_addr;
+		offset = idma->cur_addr & ~PAGE_MASK;
 
 		end = offset + idma->dma_len;
 
@@ -69,7 +70,7 @@ static void iomd_get_next_sg(struct scatterlist *sg, struct iomd_dma *idma)
 		if (offset + TRANSFER_SIZE >= end)
 			flags |= DMA_END_L;
 
-		sg->length = end - TRANSFER_SIZE;
+		idma->cur_len = end - TRANSFER_SIZE;
 
 		idma->dma_len -= end - offset;
 		idma->dma_addr += end - offset;
@@ -87,11 +88,11 @@ static void iomd_get_next_sg(struct scatterlist *sg, struct iomd_dma *idma)
 		}
 	} else {
 		flags = DMA_END_S | DMA_END_L;
-		sg->dma_address = 0;
-		sg->length = 0;
+		idma->cur_addr = 0;
+		idma->cur_len = 0;
 	}
 
-	sg->length |= flags;
+	idma->cur_len |= flags;
 }
 
 static irqreturn_t iomd_dma_handle(int irq, void *dev_id)
@@ -107,26 +108,26 @@ static irqreturn_t iomd_dma_handle(int irq, void *dev_id)
 			return IRQ_HANDLED;
 
 		if ((idma->state ^ status) & DMA_ST_AB)
-			iomd_get_next_sg(&idma->cur_sg, idma);
+			iomd_get_next_sg(idma);
 
 		switch (status & (DMA_ST_OFL | DMA_ST_AB)) {
 		case DMA_ST_OFL:			/* OIA */
 		case DMA_ST_AB:				/* .IB */
-			iomd_writel(idma->cur_sg.dma_address, base + CURA);
-			iomd_writel(idma->cur_sg.length, base + ENDA);
+			iomd_writel(idma->cur_addr, base + CURA);
+			iomd_writel(idma->cur_len, base + ENDA);
 			idma->state = DMA_ST_AB;
 			break;
 
 		case DMA_ST_OFL | DMA_ST_AB:		/* OIB */
 		case 0:					/* .IA */
-			iomd_writel(idma->cur_sg.dma_address, base + CURB);
-			iomd_writel(idma->cur_sg.length, base + ENDB);
+			iomd_writel(idma->cur_addr, base + CURB);
+			iomd_writel(idma->cur_len, base + ENDB);
 			idma->state = 0;
 			break;
 		}
 
 		if (status & DMA_ST_OFL &&
-		    idma->cur_sg.length == (DMA_END_S|DMA_END_L))
+		    idma->cur_len == (DMA_END_S|DMA_END_L))
 			break;
 	} while (1);
 

commit ffd9a1ba9fdb7f2bd1d1ad9b9243d34e96756ba2
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Thu May 2 17:19:18 2019 +0100

    ARM: riscpc: fix DMA
    
    DMA got broken a while back in two different ways:
    1) a change in the behaviour of disable_irq() to wait for the interrupt
       to finish executing causes us to deadlock at the end of DMA.
    2) a change to avoid modifying the scatterlist left the first transfer
       uninitialised.
    
    DMA is only used with expansion cards, so has gone unnoticed.
    
    Fixes: fa4e99899932 ("[ARM] dma: RiscPC: don't modify DMA SG entries")
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index fb48f3141fb4..c4c96661eb89 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -131,7 +131,7 @@ static irqreturn_t iomd_dma_handle(int irq, void *dev_id)
 	} while (1);
 
 	idma->state = ~DMA_ST_AB;
-	disable_irq(irq);
+	disable_irq_nosync(irq);
 
 	return IRQ_HANDLED;
 }
@@ -174,6 +174,9 @@ static void iomd_enable_dma(unsigned int chan, dma_t *dma)
 				DMA_FROM_DEVICE : DMA_TO_DEVICE);
 		}
 
+		idma->dma_addr = idma->dma.sg->dma_address;
+		idma->dma_len = idma->dma.sg->length;
+
 		iomd_writeb(DMA_CR_C, dma_base + CR);
 		idma->state = DMA_ST_AB;
 	}

commit 5ab6a91a1cacd827382897a80425df8a2d27744a
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Dec 21 14:56:38 2018 +0100

    arm: use a dummy struct device for ISA DMA use of the DMA API
    
    This gets rid of the last NULL dev argument passed to the DMA API.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index fb48f3141fb4..f2703ca17954 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -151,6 +151,12 @@ static void iomd_free_dma(unsigned int chan, dma_t *dma)
 	free_irq(idma->irq, idma);
 }
 
+static struct device isa_dma_dev = {
+	.init_name		= "fallback device",
+	.coherent_dma_mask	= ~(dma_addr_t)0,
+	.dma_mask		= &isa_dma_dev.coherent_dma_mask,
+};
+
 static void iomd_enable_dma(unsigned int chan, dma_t *dma)
 {
 	struct iomd_dma *idma = container_of(dma, struct iomd_dma, dma);
@@ -168,7 +174,7 @@ static void iomd_enable_dma(unsigned int chan, dma_t *dma)
 			idma->dma.sg = &idma->dma.buf;
 			idma->dma.sgcount = 1;
 			idma->dma.buf.length = idma->dma.count;
-			idma->dma.buf.dma_address = dma_map_single(NULL,
+			idma->dma.buf.dma_address = dma_map_single(&isa_dma_dev,
 				idma->dma.addr, idma->dma.count,
 				idma->dma.dma_mode == DMA_MODE_READ ?
 				DMA_FROM_DEVICE : DMA_TO_DEVICE);

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index 6d3517dc4772..fb48f3141fb4 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -20,7 +20,7 @@
 #include <asm/fiq.h>
 #include <asm/irq.h>
 #include <mach/hardware.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 #include <asm/mach/dma.h>
 #include <asm/hardware/iomd.h>

commit 78f6db99522bbdd2f2a90c963744bd51c8602990
Author: Michael Opdenacker <michael@free-electrons.com>
Date:   Tue Mar 4 22:04:50 2014 +0100

    ARM: 8000/1: misc: remove deprecated IRQF_DISABLED
    
    This patch removes the use of the IRQF_DISABLED flag
    from miscellaneous code in mach-xxx and plat-xxx
    
    This flag is a NOOP since 2.6.35 and it will be removed one day.
    
    Signed-off-by: Michael Opdenacker <michael.opdenacker@free-electrons.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Greg Ungerer <gerg@uclinux.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index 85883b2e0e49..6d3517dc4772 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -141,7 +141,7 @@ static int iomd_request_dma(unsigned int chan, dma_t *dma)
 	struct iomd_dma *idma = container_of(dma, struct iomd_dma, dma);
 
 	return request_irq(idma->irq, iomd_dma_handle,
-			   IRQF_DISABLED, idma->dma.device_id, idma);
+			   0, idma->dma.device_id, idma);
 }
 
 static void iomd_free_dma(unsigned int chan, dma_t *dma)

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index c47d974d52bd..85883b2e0e49 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -9,7 +9,6 @@
  *
  *  DMA functions specific to RiscPC architecture
  */
-#include <linux/slab.h>
 #include <linux/mman.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>

commit fa4e998999322bc1b11d2c8b19b9fa2016fd1548
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Feb 21 21:38:56 2009 +0000

    [ARM] dma: RiscPC: don't modify DMA SG entries
    
    We should not be modifying the scatterlist passed to us from the
    driver code; doing so breaks assumptions made by the DMA API code,
    and could cause problems if the driver retries a transfer using an
    old scatterlist.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index 1f77cdca26e9..c47d974d52bd 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -32,6 +32,8 @@ struct iomd_dma {
 	unsigned long		base;		/* Controller base address */
 	int			irq;		/* Controller IRQ */
 	struct scatterlist	cur_sg;		/* Current controller buffer */
+	dma_addr_t		dma_addr;
+	unsigned int		dma_len;
 };
 
 #if 0
@@ -57,10 +59,10 @@ static void iomd_get_next_sg(struct scatterlist *sg, struct iomd_dma *idma)
 	unsigned long end, offset, flags = 0;
 
 	if (idma->dma.sg) {
-		sg->dma_address = idma->dma.sg->dma_address;
+		sg->dma_address = idma->dma_addr;
 		offset = sg->dma_address & ~PAGE_MASK;
 
-		end = offset + idma->dma.sg->length;
+		end = offset + idma->dma_len;
 
 		if (end > PAGE_SIZE)
 			end = PAGE_SIZE;
@@ -70,12 +72,14 @@ static void iomd_get_next_sg(struct scatterlist *sg, struct iomd_dma *idma)
 
 		sg->length = end - TRANSFER_SIZE;
 
-		idma->dma.sg->length -= end - offset;
-		idma->dma.sg->dma_address += end - offset;
+		idma->dma_len -= end - offset;
+		idma->dma_addr += end - offset;
 
-		if (idma->dma.sg->length == 0) {
+		if (idma->dma_len == 0) {
 			if (idma->dma.sgcount > 1) {
 				idma->dma.sg = sg_next(idma->dma.sg);
+				idma->dma_addr = idma->dma.sg->dma_address;
+				idma->dma_len = idma->dma.sg->length;
 				idma->dma.sgcount--;
 			} else {
 				idma->dma.sg = NULL;

commit 308d333ad6cc12e39adaed22dc10bac48e17742a
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Feb 21 21:36:22 2009 +0000

    [ARM] dma: move IOMD and floppy DMA structures to RiscPC DMA code
    
    There's no point these being in a generic include file when they're
    only used in arch/arm/mach-rpc/dma.c.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index a5987bbed60d..1f77cdca26e9 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -26,6 +26,14 @@
 #include <asm/mach/dma.h>
 #include <asm/hardware/iomd.h>
 
+struct iomd_dma {
+	struct dma_struct	dma;
+	unsigned int		state;
+	unsigned long		base;		/* Controller base address */
+	int			irq;		/* Controller IRQ */
+	struct scatterlist	cur_sg;		/* Current controller buffer */
+};
+
 #if 0
 typedef enum {
 	dma_size_8	= 1,
@@ -242,6 +250,11 @@ static struct fiq_handler fh = {
 	.name	= "floppydma"
 };
 
+struct floppy_dma {
+	struct dma_struct	dma;
+	unsigned int		fiq;
+};
+
 static void floppy_enable_dma(unsigned int chan, dma_t *dma)
 {
 	struct floppy_dma *fdma = container_of(dma, struct floppy_dma, dma);

commit 9e28d7e8c5422a47db886c4104221ea165595de0
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Dec 8 19:03:58 2008 +0000

    [ARM] dma: convert IOMD DMA to use sg_next()
    
    ... rather than incrementing the sg pointer.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index 0163592b2af0..a5987bbed60d 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -67,7 +67,7 @@ static void iomd_get_next_sg(struct scatterlist *sg, struct iomd_dma *idma)
 
 		if (idma->dma.sg->length == 0) {
 			if (idma->dma.sgcount > 1) {
-				idma->dma.sg++;
+				idma->dma.sg = sg_next(idma->dma.sg);
 				idma->dma.sgcount--;
 			} else {
 				idma->dma.sg = NULL;

commit ad9dd94c384f7ee37b798a9349b8c42da8fa99ab
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Dec 8 17:35:48 2008 +0000

    [ARM] dma: move RiscPC specific DMA data out of dma_struct
    
    Separate the RiscPC specific (IOMD and floppy FIQ) data out of the core
    DMA structure by making the IOMD and floppy DMA supersets.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index efcf6718d1d0..0163592b2af0 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -44,15 +44,15 @@ typedef enum {
 #define CR	(IOMD_IO0CR - IOMD_IO0CURA)
 #define ST	(IOMD_IO0ST - IOMD_IO0CURA)
 
-static void iomd_get_next_sg(struct scatterlist *sg, dma_t *dma)
+static void iomd_get_next_sg(struct scatterlist *sg, struct iomd_dma *idma)
 {
 	unsigned long end, offset, flags = 0;
 
-	if (dma->sg) {
-		sg->dma_address = dma->sg->dma_address;
+	if (idma->dma.sg) {
+		sg->dma_address = idma->dma.sg->dma_address;
 		offset = sg->dma_address & ~PAGE_MASK;
 
-		end = offset + dma->sg->length;
+		end = offset + idma->dma.sg->length;
 
 		if (end > PAGE_SIZE)
 			end = PAGE_SIZE;
@@ -62,15 +62,15 @@ static void iomd_get_next_sg(struct scatterlist *sg, dma_t *dma)
 
 		sg->length = end - TRANSFER_SIZE;
 
-		dma->sg->length -= end - offset;
-		dma->sg->dma_address += end - offset;
+		idma->dma.sg->length -= end - offset;
+		idma->dma.sg->dma_address += end - offset;
 
-		if (dma->sg->length == 0) {
-			if (dma->sgcount > 1) {
-				dma->sg++;
-				dma->sgcount--;
+		if (idma->dma.sg->length == 0) {
+			if (idma->dma.sgcount > 1) {
+				idma->dma.sg++;
+				idma->dma.sgcount--;
 			} else {
-				dma->sg = NULL;
+				idma->dma.sg = NULL;
 				flags |= DMA_END_S;
 			}
 		}
@@ -85,8 +85,8 @@ static void iomd_get_next_sg(struct scatterlist *sg, dma_t *dma)
 
 static irqreturn_t iomd_dma_handle(int irq, void *dev_id)
 {
-	dma_t *dma = (dma_t *)dev_id;
-	unsigned long base = dma->dma_base;
+	struct iomd_dma *idma = dev_id;
+	unsigned long base = idma->base;
 
 	do {
 		unsigned int status;
@@ -95,31 +95,31 @@ static irqreturn_t iomd_dma_handle(int irq, void *dev_id)
 		if (!(status & DMA_ST_INT))
 			return IRQ_HANDLED;
 
-		if ((dma->state ^ status) & DMA_ST_AB)
-			iomd_get_next_sg(&dma->cur_sg, dma);
+		if ((idma->state ^ status) & DMA_ST_AB)
+			iomd_get_next_sg(&idma->cur_sg, idma);
 
 		switch (status & (DMA_ST_OFL | DMA_ST_AB)) {
 		case DMA_ST_OFL:			/* OIA */
 		case DMA_ST_AB:				/* .IB */
-			iomd_writel(dma->cur_sg.dma_address, base + CURA);
-			iomd_writel(dma->cur_sg.length, base + ENDA);
-			dma->state = DMA_ST_AB;
+			iomd_writel(idma->cur_sg.dma_address, base + CURA);
+			iomd_writel(idma->cur_sg.length, base + ENDA);
+			idma->state = DMA_ST_AB;
 			break;
 
 		case DMA_ST_OFL | DMA_ST_AB:		/* OIB */
 		case 0:					/* .IA */
-			iomd_writel(dma->cur_sg.dma_address, base + CURB);
-			iomd_writel(dma->cur_sg.length, base + ENDB);
-			dma->state = 0;
+			iomd_writel(idma->cur_sg.dma_address, base + CURB);
+			iomd_writel(idma->cur_sg.length, base + ENDB);
+			idma->state = 0;
 			break;
 		}
 
 		if (status & DMA_ST_OFL &&
-		    dma->cur_sg.length == (DMA_END_S|DMA_END_L))
+		    idma->cur_sg.length == (DMA_END_S|DMA_END_L))
 			break;
 	} while (1);
 
-	dma->state = ~DMA_ST_AB;
+	idma->state = ~DMA_ST_AB;
 	disable_irq(irq);
 
 	return IRQ_HANDLED;
@@ -127,56 +127,62 @@ static irqreturn_t iomd_dma_handle(int irq, void *dev_id)
 
 static int iomd_request_dma(unsigned int chan, dma_t *dma)
 {
-	return request_irq(dma->dma_irq, iomd_dma_handle,
-			   IRQF_DISABLED, dma->device_id, dma);
+	struct iomd_dma *idma = container_of(dma, struct iomd_dma, dma);
+
+	return request_irq(idma->irq, iomd_dma_handle,
+			   IRQF_DISABLED, idma->dma.device_id, idma);
 }
 
 static void iomd_free_dma(unsigned int chan, dma_t *dma)
 {
-	free_irq(dma->dma_irq, dma);
+	struct iomd_dma *idma = container_of(dma, struct iomd_dma, dma);
+
+	free_irq(idma->irq, idma);
 }
 
 static void iomd_enable_dma(unsigned int chan, dma_t *dma)
 {
-	unsigned long dma_base = dma->dma_base;
+	struct iomd_dma *idma = container_of(dma, struct iomd_dma, dma);
+	unsigned long dma_base = idma->base;
 	unsigned int ctrl = TRANSFER_SIZE | DMA_CR_E;
 
-	if (dma->invalid) {
-		dma->invalid = 0;
+	if (idma->dma.invalid) {
+		idma->dma.invalid = 0;
 
 		/*
 		 * Cope with ISA-style drivers which expect cache
 		 * coherence.
 		 */
-		if (!dma->sg) {
-			dma->sg = &dma->buf;
-			dma->sgcount = 1;
-			dma->buf.length = dma->count;
-			dma->buf.dma_address = dma_map_single(NULL,
-				dma->addr, dma->count,
-				dma->dma_mode == DMA_MODE_READ ?
+		if (!idma->dma.sg) {
+			idma->dma.sg = &idma->dma.buf;
+			idma->dma.sgcount = 1;
+			idma->dma.buf.length = idma->dma.count;
+			idma->dma.buf.dma_address = dma_map_single(NULL,
+				idma->dma.addr, idma->dma.count,
+				idma->dma.dma_mode == DMA_MODE_READ ?
 				DMA_FROM_DEVICE : DMA_TO_DEVICE);
 		}
 
 		iomd_writeb(DMA_CR_C, dma_base + CR);
-		dma->state = DMA_ST_AB;
+		idma->state = DMA_ST_AB;
 	}
-		
-	if (dma->dma_mode == DMA_MODE_READ)
+
+	if (idma->dma.dma_mode == DMA_MODE_READ)
 		ctrl |= DMA_CR_D;
 
 	iomd_writeb(ctrl, dma_base + CR);
-	enable_irq(dma->dma_irq);
+	enable_irq(idma->irq);
 }
 
 static void iomd_disable_dma(unsigned int chan, dma_t *dma)
 {
-	unsigned long dma_base = dma->dma_base;
+	struct iomd_dma *idma = container_of(dma, struct iomd_dma, dma);
+	unsigned long dma_base = idma->base;
 	unsigned long flags;
 
 	local_irq_save(flags);
-	if (dma->state != ~DMA_ST_AB)
-		disable_irq(dma->dma_irq);
+	if (idma->state != ~DMA_ST_AB)
+		disable_irq(idma->irq);
 	iomd_writeb(0, dma_base + CR);
 	local_irq_restore(flags);
 }
@@ -238,14 +244,15 @@ static struct fiq_handler fh = {
 
 static void floppy_enable_dma(unsigned int chan, dma_t *dma)
 {
+	struct floppy_dma *fdma = container_of(dma, struct floppy_dma, dma);
 	void *fiqhandler_start;
 	unsigned int fiqhandler_length;
 	struct pt_regs regs;
 
-	if (dma->sg)
+	if (fdma->dma.sg)
 		BUG();
 
-	if (dma->dma_mode == DMA_MODE_READ) {
+	if (fdma->dma.dma_mode == DMA_MODE_READ) {
 		extern unsigned char floppy_fiqin_start, floppy_fiqin_end;
 		fiqhandler_start = &floppy_fiqin_start;
 		fiqhandler_length = &floppy_fiqin_end - &floppy_fiqin_start;
@@ -255,8 +262,8 @@ static void floppy_enable_dma(unsigned int chan, dma_t *dma)
 		fiqhandler_length = &floppy_fiqout_end - &floppy_fiqout_start;
 	}
 
-	regs.ARM_r9  = dma->count;
-	regs.ARM_r10 = (unsigned long)dma->addr;
+	regs.ARM_r9  = fdma->dma.count;
+	regs.ARM_r10 = (unsigned long)fdma->dma.addr;
 	regs.ARM_fp  = (unsigned long)FLOPPYDMA_BASE;
 
 	if (claim_fiq(&fh)) {
@@ -266,12 +273,13 @@ static void floppy_enable_dma(unsigned int chan, dma_t *dma)
 
 	set_fiq_handler(fiqhandler_start, fiqhandler_length);
 	set_fiq_regs(&regs);
-	enable_fiq(dma->dma_irq);
+	enable_fiq(fdma->fiq);
 }
 
 static void floppy_disable_dma(unsigned int chan, dma_t *dma)
 {
-	disable_fiq(dma->dma_irq);
+	struct floppy_dma *fdma = container_of(dma, struct floppy_dma, dma);
+	disable_fiq(fdma->fiq);
 	release_fiq(&fh);
 }
 
@@ -302,11 +310,13 @@ static struct dma_ops sound_dma_ops = {
 	.disable	= sound_enable_disable_dma,
 };
 
-static dma_t iomd_dma[6];
+static struct iomd_dma iomd_dma[6];
 
-static dma_t floppy_dma = {
-	.dma_irq	= FIQ_FLOPPYDATA,
-	.d_ops		= &floppy_dma_ops,
+static struct floppy_dma floppy_dma = {
+	.dma		= {
+		.d_ops	= &floppy_dma_ops,
+	},
+	.fiq		= FIQ_FLOPPYDATA,
 };
 
 static dma_t sound_dma = {
@@ -331,28 +341,28 @@ static int __init rpc_dma_init(void)
 	 */
 	iomd_writeb(DMA_EXT_IO3|DMA_EXT_IO2, IOMD_DMAEXT);
 
-	iomd_dma[DMA_0].dma_base	= IOMD_IO0CURA;
-	iomd_dma[DMA_0].dma_irq		= IRQ_DMA0;
-	iomd_dma[DMA_1].dma_base	= IOMD_IO1CURA;
-	iomd_dma[DMA_1].dma_irq		= IRQ_DMA1;
-	iomd_dma[DMA_2].dma_base	= IOMD_IO2CURA;
-	iomd_dma[DMA_2].dma_irq		= IRQ_DMA2;
-	iomd_dma[DMA_3].dma_base	= IOMD_IO3CURA;
-	iomd_dma[DMA_3].dma_irq		= IRQ_DMA3;
-	iomd_dma[DMA_S0].dma_base	= IOMD_SD0CURA;
-	iomd_dma[DMA_S0].dma_irq	= IRQ_DMAS0;
-	iomd_dma[DMA_S1].dma_base	= IOMD_SD1CURA;
-	iomd_dma[DMA_S1].dma_irq	= IRQ_DMAS1;
+	iomd_dma[DMA_0].base	= IOMD_IO0CURA;
+	iomd_dma[DMA_0].irq	= IRQ_DMA0;
+	iomd_dma[DMA_1].base	= IOMD_IO1CURA;
+	iomd_dma[DMA_1].irq	= IRQ_DMA1;
+	iomd_dma[DMA_2].base	= IOMD_IO2CURA;
+	iomd_dma[DMA_2].irq	= IRQ_DMA2;
+	iomd_dma[DMA_3].base	= IOMD_IO3CURA;
+	iomd_dma[DMA_3].irq	= IRQ_DMA3;
+	iomd_dma[DMA_S0].base	= IOMD_SD0CURA;
+	iomd_dma[DMA_S0].irq	= IRQ_DMAS0;
+	iomd_dma[DMA_S1].base	= IOMD_SD1CURA;
+	iomd_dma[DMA_S1].irq	= IRQ_DMAS1;
 
 	for (i = DMA_0; i <= DMA_S1; i++) {
-		iomd_dma[i].d_ops = &iomd_dma_ops;
+		iomd_dma[i].dma.d_ops = &iomd_dma_ops;
 
-		ret = isa_dma_add(i, &iomd_dma[i]);
+		ret = isa_dma_add(i, &iomd_dma[i].dma);
 		if (ret)
 			printk("IOMDDMA%u: unable to register: %d\n", i, ret);
 	}
 
-	ret = isa_dma_add(DMA_VIRTUAL_FLOPPY, &floppy_dma);
+	ret = isa_dma_add(DMA_VIRTUAL_FLOPPY, &floppy_dma.dma);
 	if (ret)
 		printk("IOMDFLOPPY: unable to register: %d\n", ret);
 	ret = isa_dma_add(DMA_VIRTUAL_SOUND, &sound_dma);

commit 2f757f2ab7411cf0e2779012d8cda0cbf2f80d26
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Dec 8 16:33:30 2008 +0000

    [ARM] dma: rejig DMA initialization
    
    Rather than having the central DMA multiplexer call the architecture
    specific DMA initialization function, have each architecture DMA
    initialization function use core_initcall(), and register each DMA
    channel separately with the multiplexer.
    
    This removes the array of dma structures in the central multiplexer,
    replacing it with an array of pointers instead; this is more flexible
    since it allows the drivers to wrap the DMA structure (eventually
    allowing us to transition non-ISA DMA drivers away.)
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index a86d3ed859a7..efcf6718d1d0 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -302,8 +302,22 @@ static struct dma_ops sound_dma_ops = {
 	.disable	= sound_enable_disable_dma,
 };
 
-void __init arch_dma_init(dma_t *dma)
+static dma_t iomd_dma[6];
+
+static dma_t floppy_dma = {
+	.dma_irq	= FIQ_FLOPPYDATA,
+	.d_ops		= &floppy_dma_ops,
+};
+
+static dma_t sound_dma = {
+	.d_ops		= &sound_dma_ops,
+};
+
+static int __init rpc_dma_init(void)
 {
+	unsigned int i;
+	int ret;
+
 	iomd_writeb(0, IOMD_IO0CR);
 	iomd_writeb(0, IOMD_IO1CR);
 	iomd_writeb(0, IOMD_IO2CR);
@@ -311,31 +325,39 @@ void __init arch_dma_init(dma_t *dma)
 
 	iomd_writeb(0xa0, IOMD_DMATCR);
 
-	dma[DMA_0].dma_base		= IOMD_IO0CURA;
-	dma[DMA_0].dma_irq		= IRQ_DMA0;
-	dma[DMA_0].d_ops		= &iomd_dma_ops;
-	dma[DMA_1].dma_base		= IOMD_IO1CURA;
-	dma[DMA_1].dma_irq		= IRQ_DMA1;
-	dma[DMA_1].d_ops		= &iomd_dma_ops;
-	dma[DMA_2].dma_base		= IOMD_IO2CURA;
-	dma[DMA_2].dma_irq		= IRQ_DMA2;
-	dma[DMA_2].d_ops		= &iomd_dma_ops;
-	dma[DMA_3].dma_base		= IOMD_IO3CURA;
-	dma[DMA_3].dma_irq		= IRQ_DMA3;
-	dma[DMA_3].d_ops		= &iomd_dma_ops;
-	dma[DMA_S0].dma_base		= IOMD_SD0CURA;
-	dma[DMA_S0].dma_irq		= IRQ_DMAS0;
-	dma[DMA_S0].d_ops		= &iomd_dma_ops;
-	dma[DMA_S1].dma_base		= IOMD_SD1CURA;
-	dma[DMA_S1].dma_irq		= IRQ_DMAS1;
-	dma[DMA_S1].d_ops		= &iomd_dma_ops;
-	dma[DMA_VIRTUAL_FLOPPY].dma_irq	= FIQ_FLOPPYDATA;
-	dma[DMA_VIRTUAL_FLOPPY].d_ops	= &floppy_dma_ops;
-	dma[DMA_VIRTUAL_SOUND].d_ops	= &sound_dma_ops;
-
 	/*
 	 * Setup DMA channels 2,3 to be for podules
 	 * and channels 0,1 for internal devices
 	 */
 	iomd_writeb(DMA_EXT_IO3|DMA_EXT_IO2, IOMD_DMAEXT);
+
+	iomd_dma[DMA_0].dma_base	= IOMD_IO0CURA;
+	iomd_dma[DMA_0].dma_irq		= IRQ_DMA0;
+	iomd_dma[DMA_1].dma_base	= IOMD_IO1CURA;
+	iomd_dma[DMA_1].dma_irq		= IRQ_DMA1;
+	iomd_dma[DMA_2].dma_base	= IOMD_IO2CURA;
+	iomd_dma[DMA_2].dma_irq		= IRQ_DMA2;
+	iomd_dma[DMA_3].dma_base	= IOMD_IO3CURA;
+	iomd_dma[DMA_3].dma_irq		= IRQ_DMA3;
+	iomd_dma[DMA_S0].dma_base	= IOMD_SD0CURA;
+	iomd_dma[DMA_S0].dma_irq	= IRQ_DMAS0;
+	iomd_dma[DMA_S1].dma_base	= IOMD_SD1CURA;
+	iomd_dma[DMA_S1].dma_irq	= IRQ_DMAS1;
+
+	for (i = DMA_0; i <= DMA_S1; i++) {
+		iomd_dma[i].d_ops = &iomd_dma_ops;
+
+		ret = isa_dma_add(i, &iomd_dma[i]);
+		if (ret)
+			printk("IOMDDMA%u: unable to register: %d\n", i, ret);
+	}
+
+	ret = isa_dma_add(DMA_VIRTUAL_FLOPPY, &floppy_dma);
+	if (ret)
+		printk("IOMDFLOPPY: unable to register: %d\n", ret);
+	ret = isa_dma_add(DMA_VIRTUAL_SOUND, &sound_dma);
+	if (ret)
+		printk("IOMDSOUND: unable to register: %d\n", ret);
+	return 0;
 }
+core_initcall(rpc_dma_init);

commit 1df8130278c4543555fea697e5714fbac300b899
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Dec 8 15:58:50 2008 +0000

    [ARM] dma: remove dmach_t typedef
    
    Remove a pointless integer typedef.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index 7958a30f8932..a86d3ed859a7 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -125,18 +125,18 @@ static irqreturn_t iomd_dma_handle(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int iomd_request_dma(dmach_t channel, dma_t *dma)
+static int iomd_request_dma(unsigned int chan, dma_t *dma)
 {
 	return request_irq(dma->dma_irq, iomd_dma_handle,
 			   IRQF_DISABLED, dma->device_id, dma);
 }
 
-static void iomd_free_dma(dmach_t channel, dma_t *dma)
+static void iomd_free_dma(unsigned int chan, dma_t *dma)
 {
 	free_irq(dma->dma_irq, dma);
 }
 
-static void iomd_enable_dma(dmach_t channel, dma_t *dma)
+static void iomd_enable_dma(unsigned int chan, dma_t *dma)
 {
 	unsigned long dma_base = dma->dma_base;
 	unsigned int ctrl = TRANSFER_SIZE | DMA_CR_E;
@@ -169,7 +169,7 @@ static void iomd_enable_dma(dmach_t channel, dma_t *dma)
 	enable_irq(dma->dma_irq);
 }
 
-static void iomd_disable_dma(dmach_t channel, dma_t *dma)
+static void iomd_disable_dma(unsigned int chan, dma_t *dma)
 {
 	unsigned long dma_base = dma->dma_base;
 	unsigned long flags;
@@ -181,7 +181,7 @@ static void iomd_disable_dma(dmach_t channel, dma_t *dma)
 	local_irq_restore(flags);
 }
 
-static int iomd_set_dma_speed(dmach_t channel, dma_t *dma, int cycle)
+static int iomd_set_dma_speed(unsigned int chan, dma_t *dma, int cycle)
 {
 	int tcr, speed;
 
@@ -197,7 +197,7 @@ static int iomd_set_dma_speed(dmach_t channel, dma_t *dma, int cycle)
 	tcr = iomd_readb(IOMD_DMATCR);
 	speed &= 3;
 
-	switch (channel) {
+	switch (chan) {
 	case DMA_0:
 		tcr = (tcr & ~0x03) | speed;
 		break;
@@ -236,7 +236,7 @@ static struct fiq_handler fh = {
 	.name	= "floppydma"
 };
 
-static void floppy_enable_dma(dmach_t channel, dma_t *dma)
+static void floppy_enable_dma(unsigned int chan, dma_t *dma)
 {
 	void *fiqhandler_start;
 	unsigned int fiqhandler_length;
@@ -269,13 +269,13 @@ static void floppy_enable_dma(dmach_t channel, dma_t *dma)
 	enable_fiq(dma->dma_irq);
 }
 
-static void floppy_disable_dma(dmach_t channel, dma_t *dma)
+static void floppy_disable_dma(unsigned int chan, dma_t *dma)
 {
 	disable_fiq(dma->dma_irq);
 	release_fiq(&fh);
 }
 
-static int floppy_get_residue(dmach_t channel, dma_t *dma)
+static int floppy_get_residue(unsigned int chan, dma_t *dma)
 {
 	struct pt_regs regs;
 	get_fiq_regs(&regs);
@@ -292,7 +292,7 @@ static struct dma_ops floppy_dma_ops = {
 /*
  * This is virtual DMA - we don't need anything here.
  */
-static void sound_enable_disable_dma(dmach_t channel, dma_t *dma)
+static void sound_enable_disable_dma(unsigned int chan, dma_t *dma)
 {
 }
 

commit fced80c735941fa518ac67c0b61bbe153fb8c050
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Sep 6 12:10:45 2008 +0100

    [ARM] Convert asm/io.h to linux/io.h
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index 4b19fe484190..7958a30f8932 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -14,11 +14,11 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/dma-mapping.h>
+#include <linux/io.h>
 
 #include <asm/page.h>
 #include <asm/dma.h>
 #include <asm/fiq.h>
-#include <asm/io.h>
 #include <asm/irq.h>
 #include <mach/hardware.h>
 #include <asm/uaccess.h>

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index fb1d42b53785..4b19fe484190 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -20,7 +20,7 @@
 #include <asm/fiq.h>
 #include <asm/io.h>
 #include <asm/irq.h>
-#include <asm/arch/hardware.h>
+#include <mach/hardware.h>
 #include <asm/uaccess.h>
 
 #include <asm/mach/dma.h>

commit be509729356b7433f73df2b9a966674a437fbbc1
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Aug 4 10:41:28 2008 +0100

    [ARM] Remove asm/hardware.h, use asm/arch/hardware.h instead
    
    Remove includes of asm/hardware.h in addition to asm/arch/hardware.h.
    Then, since asm/hardware.h only exists to include asm/arch/hardware.h,
    update everything to directly include asm/arch/hardware.h and remove
    asm/hardware.h.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index 596379a4cf82..fb1d42b53785 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -20,7 +20,7 @@
 #include <asm/fiq.h>
 #include <asm/io.h>
 #include <asm/irq.h>
-#include <asm/hardware.h>
+#include <asm/arch/hardware.h>
 #include <asm/uaccess.h>
 
 #include <asm/mach/dma.h>

commit 0cd61b68c340a4f901a06e8bb5e0dea4353161c0
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Fri Oct 6 10:53:39 2006 -0700

    Initial blind fixup for arm for irq changes
    
    Untested, but this should fix up the bulk of the totally mechanical
    issues, and should make the actual detail fixing easier.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index ac511d41d4d7..596379a4cf82 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -83,7 +83,7 @@ static void iomd_get_next_sg(struct scatterlist *sg, dma_t *dma)
 	sg->length |= flags;
 }
 
-static irqreturn_t iomd_dma_handle(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t iomd_dma_handle(int irq, void *dev_id)
 {
 	dma_t *dma = (dma_t *)dev_id;
 	unsigned long base = dma->dma_base;

commit 52e405eaa9806968e88b35d65e57acad954a5ab5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 3 02:20:05 2006 +0200

    [PATCH] ARM: fixup irqflags breakage after ARM genirq merge
    
    The irgflags consolidation did conflict with the ARM to generic IRQ
    conversion and was not applied for ARM. Fix it up.
    
    Use the new IRQF_ constants and remove the SA_INTERRUPT define
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index bd86ffba8810..ac511d41d4d7 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -128,7 +128,7 @@ static irqreturn_t iomd_dma_handle(int irq, void *dev_id, struct pt_regs *regs)
 static int iomd_request_dma(dmach_t channel, dma_t *dma)
 {
 	return request_irq(dma->dma_irq, iomd_dma_handle,
-			   SA_INTERRUPT, dma->device_id, dma);
+			   IRQF_DISABLED, dma->device_id, dma);
 }
 
 static void iomd_free_dma(dmach_t channel, dma_t *dma)

commit 7cdad482974792419cfe4b0affca689170116f49
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Jan 4 15:08:30 2006 +0000

    [ARM] Remove '__address' from scatterlist and convert to DMA API
    
    The old __address element in struct scatterlist remained from older
    kernels because the ARM DMA emulation code made use of it.  Move
    this field into struct dma_struct, and convert DMA emulation code
    to setup a SG entry as required.
    
    Also, convert DMA emulation code to use the new DMA API rather
    than the PCI DMA API.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
index bc0747439fb3..bd86ffba8810 100644
--- a/arch/arm/mach-rpc/dma.c
+++ b/arch/arm/mach-rpc/dma.c
@@ -13,7 +13,7 @@
 #include <linux/mman.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
-#include <linux/pci.h>
+#include <linux/dma-mapping.h>
 
 #include <asm/page.h>
 #include <asm/dma.h>
@@ -148,11 +148,14 @@ static void iomd_enable_dma(dmach_t channel, dma_t *dma)
 		 * Cope with ISA-style drivers which expect cache
 		 * coherence.
 		 */
-		if (!dma->using_sg) {
-			dma->buf.dma_address = pci_map_single(NULL,
-				dma->buf.__address, dma->buf.length,
+		if (!dma->sg) {
+			dma->sg = &dma->buf;
+			dma->sgcount = 1;
+			dma->buf.length = dma->count;
+			dma->buf.dma_address = dma_map_single(NULL,
+				dma->addr, dma->count,
 				dma->dma_mode == DMA_MODE_READ ?
-				PCI_DMA_FROMDEVICE : PCI_DMA_TODEVICE);
+				DMA_FROM_DEVICE : DMA_TO_DEVICE);
 		}
 
 		iomd_writeb(DMA_CR_C, dma_base + CR);
@@ -239,7 +242,7 @@ static void floppy_enable_dma(dmach_t channel, dma_t *dma)
 	unsigned int fiqhandler_length;
 	struct pt_regs regs;
 
-	if (dma->using_sg)
+	if (dma->sg)
 		BUG();
 
 	if (dma->dma_mode == DMA_MODE_READ) {
@@ -252,8 +255,8 @@ static void floppy_enable_dma(dmach_t channel, dma_t *dma)
 		fiqhandler_length = &floppy_fiqout_end - &floppy_fiqout_start;
 	}
 
-	regs.ARM_r9  = dma->buf.length;
-	regs.ARM_r10 = (unsigned long)dma->buf.__address;
+	regs.ARM_r9  = dma->count;
+	regs.ARM_r10 = (unsigned long)dma->addr;
 	regs.ARM_fp  = (unsigned long)FLOPPYDMA_BASE;
 
 	if (claim_fiq(&fh)) {

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/arm/mach-rpc/dma.c b/arch/arm/mach-rpc/dma.c
new file mode 100644
index 000000000000..bc0747439fb3
--- /dev/null
+++ b/arch/arm/mach-rpc/dma.c
@@ -0,0 +1,338 @@
+/*
+ *  linux/arch/arm/mach-rpc/dma.c
+ *
+ *  Copyright (C) 1998 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  DMA functions specific to RiscPC architecture
+ */
+#include <linux/slab.h>
+#include <linux/mman.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+
+#include <asm/page.h>
+#include <asm/dma.h>
+#include <asm/fiq.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/uaccess.h>
+
+#include <asm/mach/dma.h>
+#include <asm/hardware/iomd.h>
+
+#if 0
+typedef enum {
+	dma_size_8	= 1,
+	dma_size_16	= 2,
+	dma_size_32	= 4,
+	dma_size_128	= 16
+} dma_size_t;
+#endif
+
+#define TRANSFER_SIZE	2
+
+#define CURA	(0)
+#define ENDA	(IOMD_IO0ENDA - IOMD_IO0CURA)
+#define CURB	(IOMD_IO0CURB - IOMD_IO0CURA)
+#define ENDB	(IOMD_IO0ENDB - IOMD_IO0CURA)
+#define CR	(IOMD_IO0CR - IOMD_IO0CURA)
+#define ST	(IOMD_IO0ST - IOMD_IO0CURA)
+
+static void iomd_get_next_sg(struct scatterlist *sg, dma_t *dma)
+{
+	unsigned long end, offset, flags = 0;
+
+	if (dma->sg) {
+		sg->dma_address = dma->sg->dma_address;
+		offset = sg->dma_address & ~PAGE_MASK;
+
+		end = offset + dma->sg->length;
+
+		if (end > PAGE_SIZE)
+			end = PAGE_SIZE;
+
+		if (offset + TRANSFER_SIZE >= end)
+			flags |= DMA_END_L;
+
+		sg->length = end - TRANSFER_SIZE;
+
+		dma->sg->length -= end - offset;
+		dma->sg->dma_address += end - offset;
+
+		if (dma->sg->length == 0) {
+			if (dma->sgcount > 1) {
+				dma->sg++;
+				dma->sgcount--;
+			} else {
+				dma->sg = NULL;
+				flags |= DMA_END_S;
+			}
+		}
+	} else {
+		flags = DMA_END_S | DMA_END_L;
+		sg->dma_address = 0;
+		sg->length = 0;
+	}
+
+	sg->length |= flags;
+}
+
+static irqreturn_t iomd_dma_handle(int irq, void *dev_id, struct pt_regs *regs)
+{
+	dma_t *dma = (dma_t *)dev_id;
+	unsigned long base = dma->dma_base;
+
+	do {
+		unsigned int status;
+
+		status = iomd_readb(base + ST);
+		if (!(status & DMA_ST_INT))
+			return IRQ_HANDLED;
+
+		if ((dma->state ^ status) & DMA_ST_AB)
+			iomd_get_next_sg(&dma->cur_sg, dma);
+
+		switch (status & (DMA_ST_OFL | DMA_ST_AB)) {
+		case DMA_ST_OFL:			/* OIA */
+		case DMA_ST_AB:				/* .IB */
+			iomd_writel(dma->cur_sg.dma_address, base + CURA);
+			iomd_writel(dma->cur_sg.length, base + ENDA);
+			dma->state = DMA_ST_AB;
+			break;
+
+		case DMA_ST_OFL | DMA_ST_AB:		/* OIB */
+		case 0:					/* .IA */
+			iomd_writel(dma->cur_sg.dma_address, base + CURB);
+			iomd_writel(dma->cur_sg.length, base + ENDB);
+			dma->state = 0;
+			break;
+		}
+
+		if (status & DMA_ST_OFL &&
+		    dma->cur_sg.length == (DMA_END_S|DMA_END_L))
+			break;
+	} while (1);
+
+	dma->state = ~DMA_ST_AB;
+	disable_irq(irq);
+
+	return IRQ_HANDLED;
+}
+
+static int iomd_request_dma(dmach_t channel, dma_t *dma)
+{
+	return request_irq(dma->dma_irq, iomd_dma_handle,
+			   SA_INTERRUPT, dma->device_id, dma);
+}
+
+static void iomd_free_dma(dmach_t channel, dma_t *dma)
+{
+	free_irq(dma->dma_irq, dma);
+}
+
+static void iomd_enable_dma(dmach_t channel, dma_t *dma)
+{
+	unsigned long dma_base = dma->dma_base;
+	unsigned int ctrl = TRANSFER_SIZE | DMA_CR_E;
+
+	if (dma->invalid) {
+		dma->invalid = 0;
+
+		/*
+		 * Cope with ISA-style drivers which expect cache
+		 * coherence.
+		 */
+		if (!dma->using_sg) {
+			dma->buf.dma_address = pci_map_single(NULL,
+				dma->buf.__address, dma->buf.length,
+				dma->dma_mode == DMA_MODE_READ ?
+				PCI_DMA_FROMDEVICE : PCI_DMA_TODEVICE);
+		}
+
+		iomd_writeb(DMA_CR_C, dma_base + CR);
+		dma->state = DMA_ST_AB;
+	}
+		
+	if (dma->dma_mode == DMA_MODE_READ)
+		ctrl |= DMA_CR_D;
+
+	iomd_writeb(ctrl, dma_base + CR);
+	enable_irq(dma->dma_irq);
+}
+
+static void iomd_disable_dma(dmach_t channel, dma_t *dma)
+{
+	unsigned long dma_base = dma->dma_base;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	if (dma->state != ~DMA_ST_AB)
+		disable_irq(dma->dma_irq);
+	iomd_writeb(0, dma_base + CR);
+	local_irq_restore(flags);
+}
+
+static int iomd_set_dma_speed(dmach_t channel, dma_t *dma, int cycle)
+{
+	int tcr, speed;
+
+	if (cycle < 188)
+		speed = 3;
+	else if (cycle <= 250)
+		speed = 2;
+	else if (cycle < 438)
+		speed = 1;
+	else
+		speed = 0;
+
+	tcr = iomd_readb(IOMD_DMATCR);
+	speed &= 3;
+
+	switch (channel) {
+	case DMA_0:
+		tcr = (tcr & ~0x03) | speed;
+		break;
+
+	case DMA_1:
+		tcr = (tcr & ~0x0c) | (speed << 2);
+		break;
+
+	case DMA_2:
+		tcr = (tcr & ~0x30) | (speed << 4);
+		break;
+
+	case DMA_3:
+		tcr = (tcr & ~0xc0) | (speed << 6);
+		break;
+
+	default:
+		break;
+	}
+
+	iomd_writeb(tcr, IOMD_DMATCR);
+
+	return speed;
+}
+
+static struct dma_ops iomd_dma_ops = {
+	.type		= "IOMD",
+	.request	= iomd_request_dma,
+	.free		= iomd_free_dma,
+	.enable		= iomd_enable_dma,
+	.disable	= iomd_disable_dma,
+	.setspeed	= iomd_set_dma_speed,
+};
+
+static struct fiq_handler fh = {
+	.name	= "floppydma"
+};
+
+static void floppy_enable_dma(dmach_t channel, dma_t *dma)
+{
+	void *fiqhandler_start;
+	unsigned int fiqhandler_length;
+	struct pt_regs regs;
+
+	if (dma->using_sg)
+		BUG();
+
+	if (dma->dma_mode == DMA_MODE_READ) {
+		extern unsigned char floppy_fiqin_start, floppy_fiqin_end;
+		fiqhandler_start = &floppy_fiqin_start;
+		fiqhandler_length = &floppy_fiqin_end - &floppy_fiqin_start;
+	} else {
+		extern unsigned char floppy_fiqout_start, floppy_fiqout_end;
+		fiqhandler_start = &floppy_fiqout_start;
+		fiqhandler_length = &floppy_fiqout_end - &floppy_fiqout_start;
+	}
+
+	regs.ARM_r9  = dma->buf.length;
+	regs.ARM_r10 = (unsigned long)dma->buf.__address;
+	regs.ARM_fp  = (unsigned long)FLOPPYDMA_BASE;
+
+	if (claim_fiq(&fh)) {
+		printk("floppydma: couldn't claim FIQ.\n");
+		return;
+	}
+
+	set_fiq_handler(fiqhandler_start, fiqhandler_length);
+	set_fiq_regs(&regs);
+	enable_fiq(dma->dma_irq);
+}
+
+static void floppy_disable_dma(dmach_t channel, dma_t *dma)
+{
+	disable_fiq(dma->dma_irq);
+	release_fiq(&fh);
+}
+
+static int floppy_get_residue(dmach_t channel, dma_t *dma)
+{
+	struct pt_regs regs;
+	get_fiq_regs(&regs);
+	return regs.ARM_r9;
+}
+
+static struct dma_ops floppy_dma_ops = {
+	.type		= "FIQDMA",
+	.enable		= floppy_enable_dma,
+	.disable	= floppy_disable_dma,
+	.residue	= floppy_get_residue,
+};
+
+/*
+ * This is virtual DMA - we don't need anything here.
+ */
+static void sound_enable_disable_dma(dmach_t channel, dma_t *dma)
+{
+}
+
+static struct dma_ops sound_dma_ops = {
+	.type		= "VIRTUAL",
+	.enable		= sound_enable_disable_dma,
+	.disable	= sound_enable_disable_dma,
+};
+
+void __init arch_dma_init(dma_t *dma)
+{
+	iomd_writeb(0, IOMD_IO0CR);
+	iomd_writeb(0, IOMD_IO1CR);
+	iomd_writeb(0, IOMD_IO2CR);
+	iomd_writeb(0, IOMD_IO3CR);
+
+	iomd_writeb(0xa0, IOMD_DMATCR);
+
+	dma[DMA_0].dma_base		= IOMD_IO0CURA;
+	dma[DMA_0].dma_irq		= IRQ_DMA0;
+	dma[DMA_0].d_ops		= &iomd_dma_ops;
+	dma[DMA_1].dma_base		= IOMD_IO1CURA;
+	dma[DMA_1].dma_irq		= IRQ_DMA1;
+	dma[DMA_1].d_ops		= &iomd_dma_ops;
+	dma[DMA_2].dma_base		= IOMD_IO2CURA;
+	dma[DMA_2].dma_irq		= IRQ_DMA2;
+	dma[DMA_2].d_ops		= &iomd_dma_ops;
+	dma[DMA_3].dma_base		= IOMD_IO3CURA;
+	dma[DMA_3].dma_irq		= IRQ_DMA3;
+	dma[DMA_3].d_ops		= &iomd_dma_ops;
+	dma[DMA_S0].dma_base		= IOMD_SD0CURA;
+	dma[DMA_S0].dma_irq		= IRQ_DMAS0;
+	dma[DMA_S0].d_ops		= &iomd_dma_ops;
+	dma[DMA_S1].dma_base		= IOMD_SD1CURA;
+	dma[DMA_S1].dma_irq		= IRQ_DMAS1;
+	dma[DMA_S1].d_ops		= &iomd_dma_ops;
+	dma[DMA_VIRTUAL_FLOPPY].dma_irq	= FIQ_FLOPPYDATA;
+	dma[DMA_VIRTUAL_FLOPPY].d_ops	= &floppy_dma_ops;
+	dma[DMA_VIRTUAL_SOUND].d_ops	= &sound_dma_ops;
+
+	/*
+	 * Setup DMA channels 2,3 to be for podules
+	 * and channels 0,1 for internal devices
+	 */
+	iomd_writeb(DMA_EXT_IO3|DMA_EXT_IO2, IOMD_DMAEXT);
+}
