commit 05002cf1779ace3b0e1ed6a8cd6c67876fd47d9d
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Tue May 21 16:30:38 2019 +0100

    ARM: riscpc: reduce IRQ handling code
    
    Reduce the amount of IRQ handling code that RiscPC requires; there's no
    need for this duplication if we place the virtual iomem base address for
    each bank directly in the irq_data structure.  Provide helpers to get
    the base address, and setup the base address and register mask.
    
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/mach-rpc/irq.c b/arch/arm/mach-rpc/irq.c
index 7f0f40178634..803aeb126f0e 100644
--- a/arch/arm/mach-rpc/irq.c
+++ b/arch/arm/mach-rpc/irq.c
@@ -8,110 +8,64 @@
 #include <asm/irq.h>
 #include <asm/fiq.h>
 
-static void iomd_ack_irq_a(struct irq_data *d)
-{
-	unsigned int val, mask;
-
-	mask = 1 << d->irq;
-	val = iomd_readb(IOMD_IRQMASKA);
-	iomd_writeb(val & ~mask, IOMD_IRQMASKA);
-	iomd_writeb(mask, IOMD_IRQCLRA);
-}
-
-static void iomd_mask_irq_a(struct irq_data *d)
-{
-	unsigned int val, mask;
+// These are offsets from the stat register for each IRQ bank
+#define STAT	0x00
+#define REQ	0x04
+#define CLR	0x04
+#define MASK	0x08
 
-	mask = 1 << d->irq;
-	val = iomd_readb(IOMD_IRQMASKA);
-	iomd_writeb(val & ~mask, IOMD_IRQMASKA);
-}
-
-static void iomd_unmask_irq_a(struct irq_data *d)
+static void __iomem *iomd_get_base(struct irq_data *d)
 {
-	unsigned int val, mask;
+	void *cd = irq_data_get_irq_chip_data(d);
 
-	mask = 1 << d->irq;
-	val = iomd_readb(IOMD_IRQMASKA);
-	iomd_writeb(val | mask, IOMD_IRQMASKA);
+	return (void __iomem *)(unsigned long)cd;
 }
 
-static struct irq_chip iomd_a_chip = {
-	.irq_ack	= iomd_ack_irq_a,
-	.irq_mask	= iomd_mask_irq_a,
-	.irq_unmask	= iomd_unmask_irq_a,
-};
-
-static void iomd_mask_irq_b(struct irq_data *d)
+static void iomd_set_base_mask(unsigned int irq, void __iomem *base, u32 mask)
 {
-	unsigned int val, mask;
+	struct irq_data *d = irq_get_irq_data(irq);
 
-	mask = 1 << (d->irq & 7);
-	val = iomd_readb(IOMD_IRQMASKB);
-	iomd_writeb(val & ~mask, IOMD_IRQMASKB);
+	d->mask = mask;
+	irq_set_chip_data(irq, (void *)(unsigned long)base);
 }
 
-static void iomd_unmask_irq_b(struct irq_data *d)
+static void iomd_irq_mask_ack(struct irq_data *d)
 {
-	unsigned int val, mask;
+	void __iomem *base = iomd_get_base(d);
+	unsigned int val, mask = d->mask;
 
-	mask = 1 << (d->irq & 7);
-	val = iomd_readb(IOMD_IRQMASKB);
-	iomd_writeb(val | mask, IOMD_IRQMASKB);
+	val = readb(base + MASK);
+	writeb(val & ~mask, base + MASK);
+	writeb(mask, base + CLR);
 }
 
-static struct irq_chip iomd_b_chip = {
-	.irq_ack	= iomd_mask_irq_b,
-	.irq_mask	= iomd_mask_irq_b,
-	.irq_unmask	= iomd_unmask_irq_b,
-};
-
-static void iomd_mask_irq_dma(struct irq_data *d)
+static void iomd_irq_mask(struct irq_data *d)
 {
-	unsigned int val, mask;
+	void __iomem *base = iomd_get_base(d);
+	unsigned int val, mask = d->mask;
 
-	mask = 1 << (d->irq & 7);
-	val = iomd_readb(IOMD_DMAMASK);
-	iomd_writeb(val & ~mask, IOMD_DMAMASK);
+	val = readb(base + MASK);
+	writeb(val & ~mask, base + MASK);
 }
 
-static void iomd_unmask_irq_dma(struct irq_data *d)
+static void iomd_irq_unmask(struct irq_data *d)
 {
-	unsigned int val, mask;
+	void __iomem *base = iomd_get_base(d);
+	unsigned int val, mask = d->mask;
 
-	mask = 1 << (d->irq & 7);
-	val = iomd_readb(IOMD_DMAMASK);
-	iomd_writeb(val | mask, IOMD_DMAMASK);
+	val = readb(base + MASK);
+	writeb(val | mask, base + MASK);
 }
 
-static struct irq_chip iomd_dma_chip = {
-	.irq_ack	= iomd_mask_irq_dma,
-	.irq_mask	= iomd_mask_irq_dma,
-	.irq_unmask	= iomd_unmask_irq_dma,
+static struct irq_chip iomd_chip_clr = {
+	.irq_mask_ack	= iomd_irq_mask_ack,
+	.irq_mask	= iomd_irq_mask,
+	.irq_unmask	= iomd_irq_unmask,
 };
 
-static void iomd_mask_irq_fiq(struct irq_data *d)
-{
-	unsigned int val, mask;
-
-	mask = 1 << (d->irq & 7);
-	val = iomd_readb(IOMD_FIQMASK);
-	iomd_writeb(val & ~mask, IOMD_FIQMASK);
-}
-
-static void iomd_unmask_irq_fiq(struct irq_data *d)
-{
-	unsigned int val, mask;
-
-	mask = 1 << (d->irq & 7);
-	val = iomd_readb(IOMD_FIQMASK);
-	iomd_writeb(val | mask, IOMD_FIQMASK);
-}
-
-static struct irq_chip iomd_fiq_chip = {
-	.irq_ack	= iomd_mask_irq_fiq,
-	.irq_mask	= iomd_mask_irq_fiq,
-	.irq_unmask	= iomd_unmask_irq_fiq,
+static struct irq_chip iomd_chip_noclr = {
+	.irq_mask	= iomd_irq_mask,
+	.irq_unmask	= iomd_irq_unmask,
 };
 
 extern unsigned char rpc_default_fiq_start, rpc_default_fiq_end;
@@ -141,30 +95,37 @@ void __init rpc_init_irq(void)
 
 		switch (irq) {
 		case 0 ... 7:
-			irq_set_chip_and_handler(irq, &iomd_a_chip,
+			irq_set_chip_and_handler(irq, &iomd_chip_clr,
 						 handle_level_irq);
 			irq_modify_status(irq, clr, set);
+			iomd_set_base_mask(irq, IOMD_BASE + IOMD_IRQSTATA,
+					   BIT(irq));
 			break;
 
 		case 8 ... 15:
-			irq_set_chip_and_handler(irq, &iomd_b_chip,
+			irq_set_chip_and_handler(irq, &iomd_chip_noclr,
 						 handle_level_irq);
 			irq_modify_status(irq, clr, set);
+			iomd_set_base_mask(irq, IOMD_BASE + IOMD_IRQSTATB,
+					   BIT(irq - 8));
 			break;
 
 		case 16 ... 21:
-			irq_set_chip_and_handler(irq, &iomd_dma_chip,
+			irq_set_chip_and_handler(irq, &iomd_chip_noclr,
 						 handle_level_irq);
 			irq_modify_status(irq, clr, set);
+			iomd_set_base_mask(irq, IOMD_BASE + IOMD_DMASTAT,
+					   BIT(irq - 16));
 			break;
 
 		case 64 ... 71:
-			irq_set_chip(irq, &iomd_fiq_chip);
+			irq_set_chip(irq, &iomd_chip_noclr);
 			irq_modify_status(irq, clr, set);
+			iomd_set_base_mask(irq, IOMD_BASE + IOMD_FIQSTAT,
+					   BIT(irq - 64));
 			break;
 		}
 	}
 
 	init_FIQ(FIQ_START);
 }
-

commit 63a0666bca9311f35017be454587f3ba903644b8
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Sat Apr 27 22:43:49 2019 +0100

    ARM: riscpc: fix lack of keyboard interrupts after irq conversion
    
    Fix lack of keyboard interrupts for RiscPC due to incorrect conversion.
    
    Fixes: e8d36d5dbb6a ("ARM: kill off set_irq_flags usage")
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/mach-rpc/irq.c b/arch/arm/mach-rpc/irq.c
index b8a61cb11207..7f0f40178634 100644
--- a/arch/arm/mach-rpc/irq.c
+++ b/arch/arm/mach-rpc/irq.c
@@ -118,7 +118,7 @@ extern unsigned char rpc_default_fiq_start, rpc_default_fiq_end;
 
 void __init rpc_init_irq(void)
 {
-	unsigned int irq, clr, set = 0;
+	unsigned int irq, clr, set;
 
 	iomd_writeb(0, IOMD_IRQMASKA);
 	iomd_writeb(0, IOMD_IRQMASKB);
@@ -130,6 +130,7 @@ void __init rpc_init_irq(void)
 
 	for (irq = 0; irq < NR_IRQS; irq++) {
 		clr = IRQ_NOREQUEST;
+		set = 0;
 
 		if (irq <= 6 || (irq >= 9 && irq <= 15))
 			clr |= IRQ_NOPROBE;

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-rpc/irq.c b/arch/arm/mach-rpc/irq.c
index 66502e6207fe..b8a61cb11207 100644
--- a/arch/arm/mach-rpc/irq.c
+++ b/arch/arm/mach-rpc/irq.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/io.h>

commit e8d36d5dbb6a6ec4f5222f8775d664ec29d5527d
Author: Rob Herring <robh@kernel.org>
Date:   Mon Jul 27 15:55:13 2015 -0500

    ARM: kill off set_irq_flags usage
    
    set_irq_flags is ARM specific with custom flags which have genirq
    equivalents. Convert drivers to use the genirq interfaces directly, so we
    can kill off set_irq_flags. The translation of flags is as follows:
    
    IRQF_VALID -> !IRQ_NOREQUEST
    IRQF_PROBE -> !IRQ_NOPROBE
    IRQF_NOAUTOEN -> IRQ_NOAUTOEN
    
    For IRQs managed by an irqdomain, the irqdomain core code handles clearing
    and setting IRQ_NOREQUEST already, so there is no need to do this in
    .map() functions and we can simply remove the set_irq_flags calls. Some
    users also modify IRQ_NOPROBE and this has been maintained although it
    is not clear that is really needed. There appears to be a great deal of
    blind copy and paste of this code.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Sekhar Nori <nsekhar@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Gregory Clement <gregory.clement@free-electrons.com>
    Acked-by: Hans Ulli Kroll <ulli.kroll@googlemail.com>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Acked-by: Krzysztof Halasa <khalasa@piap.pl>
    Cc: Greg Ungerer <gerg@uclinux.org>
    Cc: Roland Stigge <stigge@antcom.de>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Daniel Mack <daniel@zonque.org>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: Robert Jarzmik <robert.jarzmik@free.fr>
    Cc: Simtec Linux Team <linux@simtec.co.uk>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Acked-by: Wan ZongShun <mcuos.com@gmail.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-omap@vger.kernel.org
    Cc: linux-samsung-soc@vger.kernel.org
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-rpc/irq.c b/arch/arm/mach-rpc/irq.c
index 3e4fa849c64d..66502e6207fe 100644
--- a/arch/arm/mach-rpc/irq.c
+++ b/arch/arm/mach-rpc/irq.c
@@ -117,7 +117,7 @@ extern unsigned char rpc_default_fiq_start, rpc_default_fiq_end;
 
 void __init rpc_init_irq(void)
 {
-	unsigned int irq, flags;
+	unsigned int irq, clr, set = 0;
 
 	iomd_writeb(0, IOMD_IRQMASKA);
 	iomd_writeb(0, IOMD_IRQMASKB);
@@ -128,37 +128,37 @@ void __init rpc_init_irq(void)
 		&rpc_default_fiq_end - &rpc_default_fiq_start);
 
 	for (irq = 0; irq < NR_IRQS; irq++) {
-		flags = IRQF_VALID;
+		clr = IRQ_NOREQUEST;
 
 		if (irq <= 6 || (irq >= 9 && irq <= 15))
-			flags |= IRQF_PROBE;
+			clr |= IRQ_NOPROBE;
 
 		if (irq == 21 || (irq >= 16 && irq <= 19) ||
 		    irq == IRQ_KEYBOARDTX)
-			flags |= IRQF_NOAUTOEN;
+			set |= IRQ_NOAUTOEN;
 
 		switch (irq) {
 		case 0 ... 7:
 			irq_set_chip_and_handler(irq, &iomd_a_chip,
 						 handle_level_irq);
-			set_irq_flags(irq, flags);
+			irq_modify_status(irq, clr, set);
 			break;
 
 		case 8 ... 15:
 			irq_set_chip_and_handler(irq, &iomd_b_chip,
 						 handle_level_irq);
-			set_irq_flags(irq, flags);
+			irq_modify_status(irq, clr, set);
 			break;
 
 		case 16 ... 21:
 			irq_set_chip_and_handler(irq, &iomd_dma_chip,
 						 handle_level_irq);
-			set_irq_flags(irq, flags);
+			irq_modify_status(irq, clr, set);
 			break;
 
 		case 64 ... 71:
 			irq_set_chip(irq, &iomd_fiq_chip);
-			set_irq_flags(irq, IRQF_VALID);
+			irq_modify_status(irq, clr, set);
 			break;
 		}
 	}

commit bc89663aa5c7ca620f58c34ab531ca409119becc
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Thu Jun 28 14:42:08 2012 +0800

    ARM: fiq: change FIQ_START to a variable
    
    The commit a2be01b (ARM: only include mach/irqs.h for !SPARSE_IRQ)
    makes mach/irqs.h only be included for !SPARSE_IRQ build.  There are
    a nubmer of platforms have FIQ_START defined in mach/irqs.h for FIQ
    support.
    
      arch/arm/mach-rpc/include/mach/irqs.h:#define FIQ_START         64
      arch/arm/mach-s3c24xx/include/mach/irqs.h:#define FIQ_START             IRQ_EINT0
      arch/arm/plat-mxc/include/mach/irqs.h:#define FIQ_START 0
    
    If SPARSE_IRQ is enabled for any of these platforms, the following
    compile error will be seen.
    
      arch/arm/kernel/fiq.c: In function ‘enable_fiq’:
      arch/arm/kernel/fiq.c:127:19: error: ‘FIQ_START’ undeclared (first use in this function)
      arch/arm/kernel/fiq.c:127:19: note: each undeclared identifier is reported only once for each function it appears in
      arch/arm/kernel/fiq.c: In function ‘disable_fiq’:
      arch/arm/kernel/fiq.c:132:20: error: ‘FIQ_START’ undeclared (first use in this function)
    
    The patch changes fiq code to have init_FIQ take FIQ_START from
    platforms as a parameter and assign it to variable fiq_start which
    is to replace FIQ_START uses in enable_fiq/disable_fiq.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-rpc/irq.c b/arch/arm/mach-rpc/irq.c
index cf0e669eaf1a..3e4fa849c64d 100644
--- a/arch/arm/mach-rpc/irq.c
+++ b/arch/arm/mach-rpc/irq.c
@@ -163,6 +163,6 @@ void __init rpc_init_irq(void)
 		}
 	}
 
-	init_FIQ();
+	init_FIQ(FIQ_START);
 }
 

commit 78cbaaca6908c2ddf1bd26cf58c408938654e3d8
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Wed Feb 8 18:24:23 2012 -0600

    ARM: rpc: make default fiq handler run-time installed
    
    Only rpc uses disable_fiq macro. Change it to a run-time installed
    default FIQ handler. The handler is installed before FIQ is enabled
    so the behavior should be unchanged.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>

diff --git a/arch/arm/mach-rpc/irq.c b/arch/arm/mach-rpc/irq.c
index 2e1b5309fbab..cf0e669eaf1a 100644
--- a/arch/arm/mach-rpc/irq.c
+++ b/arch/arm/mach-rpc/irq.c
@@ -5,6 +5,7 @@
 #include <asm/mach/irq.h>
 #include <asm/hardware/iomd.h>
 #include <asm/irq.h>
+#include <asm/fiq.h>
 
 static void iomd_ack_irq_a(struct irq_data *d)
 {
@@ -112,6 +113,8 @@ static struct irq_chip iomd_fiq_chip = {
 	.irq_unmask	= iomd_unmask_irq_fiq,
 };
 
+extern unsigned char rpc_default_fiq_start, rpc_default_fiq_end;
+
 void __init rpc_init_irq(void)
 {
 	unsigned int irq, flags;
@@ -121,6 +124,9 @@ void __init rpc_init_irq(void)
 	iomd_writeb(0, IOMD_FIQMASK);
 	iomd_writeb(0, IOMD_DMAMASK);
 
+	set_fiq_handler(&rpc_default_fiq_start,
+		&rpc_default_fiq_end - &rpc_default_fiq_start);
+
 	for (irq = 0; irq < NR_IRQS; irq++) {
 		flags = IRQF_VALID;
 

commit f38c02f3b338651e145aac2889ba976baf6b28b3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 13:35:09 2011 +0100

    arm: Fold irq_set_chip/irq_set_handler
    
    Use irq_set_chip_and_handler() instead. Converted with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/mach-rpc/irq.c b/arch/arm/mach-rpc/irq.c
index 49fb9886f56c..2e1b5309fbab 100644
--- a/arch/arm/mach-rpc/irq.c
+++ b/arch/arm/mach-rpc/irq.c
@@ -133,20 +133,20 @@ void __init rpc_init_irq(void)
 
 		switch (irq) {
 		case 0 ... 7:
-			irq_set_chip(irq, &iomd_a_chip);
-			irq_set_handler(irq, handle_level_irq);
+			irq_set_chip_and_handler(irq, &iomd_a_chip,
+						 handle_level_irq);
 			set_irq_flags(irq, flags);
 			break;
 
 		case 8 ... 15:
-			irq_set_chip(irq, &iomd_b_chip);
-			irq_set_handler(irq, handle_level_irq);
+			irq_set_chip_and_handler(irq, &iomd_b_chip,
+						 handle_level_irq);
 			set_irq_flags(irq, flags);
 			break;
 
 		case 16 ... 21:
-			irq_set_chip(irq, &iomd_dma_chip);
-			irq_set_handler(irq, handle_level_irq);
+			irq_set_chip_and_handler(irq, &iomd_dma_chip,
+						 handle_level_irq);
 			set_irq_flags(irq, flags);
 			break;
 

commit 6845664a6a7d443f03883db59d10749d38d98b8e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 13:25:22 2011 +0100

    arm: Cleanup the irq namespace
    
    Convert to the new function names. Automated with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arm/mach-rpc/irq.c b/arch/arm/mach-rpc/irq.c
index d29cd9b737fc..49fb9886f56c 100644
--- a/arch/arm/mach-rpc/irq.c
+++ b/arch/arm/mach-rpc/irq.c
@@ -133,25 +133,25 @@ void __init rpc_init_irq(void)
 
 		switch (irq) {
 		case 0 ... 7:
-			set_irq_chip(irq, &iomd_a_chip);
-			set_irq_handler(irq, handle_level_irq);
+			irq_set_chip(irq, &iomd_a_chip);
+			irq_set_handler(irq, handle_level_irq);
 			set_irq_flags(irq, flags);
 			break;
 
 		case 8 ... 15:
-			set_irq_chip(irq, &iomd_b_chip);
-			set_irq_handler(irq, handle_level_irq);
+			irq_set_chip(irq, &iomd_b_chip);
+			irq_set_handler(irq, handle_level_irq);
 			set_irq_flags(irq, flags);
 			break;
 
 		case 16 ... 21:
-			set_irq_chip(irq, &iomd_dma_chip);
-			set_irq_handler(irq, handle_level_irq);
+			irq_set_chip(irq, &iomd_dma_chip);
+			irq_set_handler(irq, handle_level_irq);
 			set_irq_flags(irq, flags);
 			break;
 
 		case 64 ... 71:
-			set_irq_chip(irq, &iomd_fiq_chip);
+			irq_set_chip(irq, &iomd_fiq_chip);
 			set_irq_flags(irq, IRQF_VALID);
 			break;
 		}

commit 9a364da73d84bb5181fc8a0f85d497b596f0d560
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Mon Nov 29 11:07:20 2010 +0100

    ARM: rpc: irq_data conversion.
    
    Signed-off-by: Lennert Buytenhek <buytenh@secretlab.ca>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-rpc/irq.c b/arch/arm/mach-rpc/irq.c
index 9dd15d679c5d..d29cd9b737fc 100644
--- a/arch/arm/mach-rpc/irq.c
+++ b/arch/arm/mach-rpc/irq.c
@@ -6,110 +6,110 @@
 #include <asm/hardware/iomd.h>
 #include <asm/irq.h>
 
-static void iomd_ack_irq_a(unsigned int irq)
+static void iomd_ack_irq_a(struct irq_data *d)
 {
 	unsigned int val, mask;
 
-	mask = 1 << irq;
+	mask = 1 << d->irq;
 	val = iomd_readb(IOMD_IRQMASKA);
 	iomd_writeb(val & ~mask, IOMD_IRQMASKA);
 	iomd_writeb(mask, IOMD_IRQCLRA);
 }
 
-static void iomd_mask_irq_a(unsigned int irq)
+static void iomd_mask_irq_a(struct irq_data *d)
 {
 	unsigned int val, mask;
 
-	mask = 1 << irq;
+	mask = 1 << d->irq;
 	val = iomd_readb(IOMD_IRQMASKA);
 	iomd_writeb(val & ~mask, IOMD_IRQMASKA);
 }
 
-static void iomd_unmask_irq_a(unsigned int irq)
+static void iomd_unmask_irq_a(struct irq_data *d)
 {
 	unsigned int val, mask;
 
-	mask = 1 << irq;
+	mask = 1 << d->irq;
 	val = iomd_readb(IOMD_IRQMASKA);
 	iomd_writeb(val | mask, IOMD_IRQMASKA);
 }
 
 static struct irq_chip iomd_a_chip = {
-	.ack	= iomd_ack_irq_a,
-	.mask	= iomd_mask_irq_a,
-	.unmask = iomd_unmask_irq_a,
+	.irq_ack	= iomd_ack_irq_a,
+	.irq_mask	= iomd_mask_irq_a,
+	.irq_unmask	= iomd_unmask_irq_a,
 };
 
-static void iomd_mask_irq_b(unsigned int irq)
+static void iomd_mask_irq_b(struct irq_data *d)
 {
 	unsigned int val, mask;
 
-	mask = 1 << (irq & 7);
+	mask = 1 << (d->irq & 7);
 	val = iomd_readb(IOMD_IRQMASKB);
 	iomd_writeb(val & ~mask, IOMD_IRQMASKB);
 }
 
-static void iomd_unmask_irq_b(unsigned int irq)
+static void iomd_unmask_irq_b(struct irq_data *d)
 {
 	unsigned int val, mask;
 
-	mask = 1 << (irq & 7);
+	mask = 1 << (d->irq & 7);
 	val = iomd_readb(IOMD_IRQMASKB);
 	iomd_writeb(val | mask, IOMD_IRQMASKB);
 }
 
 static struct irq_chip iomd_b_chip = {
-	.ack	= iomd_mask_irq_b,
-	.mask	= iomd_mask_irq_b,
-	.unmask = iomd_unmask_irq_b,
+	.irq_ack	= iomd_mask_irq_b,
+	.irq_mask	= iomd_mask_irq_b,
+	.irq_unmask	= iomd_unmask_irq_b,
 };
 
-static void iomd_mask_irq_dma(unsigned int irq)
+static void iomd_mask_irq_dma(struct irq_data *d)
 {
 	unsigned int val, mask;
 
-	mask = 1 << (irq & 7);
+	mask = 1 << (d->irq & 7);
 	val = iomd_readb(IOMD_DMAMASK);
 	iomd_writeb(val & ~mask, IOMD_DMAMASK);
 }
 
-static void iomd_unmask_irq_dma(unsigned int irq)
+static void iomd_unmask_irq_dma(struct irq_data *d)
 {
 	unsigned int val, mask;
 
-	mask = 1 << (irq & 7);
+	mask = 1 << (d->irq & 7);
 	val = iomd_readb(IOMD_DMAMASK);
 	iomd_writeb(val | mask, IOMD_DMAMASK);
 }
 
 static struct irq_chip iomd_dma_chip = {
-	.ack	= iomd_mask_irq_dma,
-	.mask	= iomd_mask_irq_dma,
-	.unmask = iomd_unmask_irq_dma,
+	.irq_ack	= iomd_mask_irq_dma,
+	.irq_mask	= iomd_mask_irq_dma,
+	.irq_unmask	= iomd_unmask_irq_dma,
 };
 
-static void iomd_mask_irq_fiq(unsigned int irq)
+static void iomd_mask_irq_fiq(struct irq_data *d)
 {
 	unsigned int val, mask;
 
-	mask = 1 << (irq & 7);
+	mask = 1 << (d->irq & 7);
 	val = iomd_readb(IOMD_FIQMASK);
 	iomd_writeb(val & ~mask, IOMD_FIQMASK);
 }
 
-static void iomd_unmask_irq_fiq(unsigned int irq)
+static void iomd_unmask_irq_fiq(struct irq_data *d)
 {
 	unsigned int val, mask;
 
-	mask = 1 << (irq & 7);
+	mask = 1 << (d->irq & 7);
 	val = iomd_readb(IOMD_FIQMASK);
 	iomd_writeb(val | mask, IOMD_FIQMASK);
 }
 
 static struct irq_chip iomd_fiq_chip = {
-	.ack	= iomd_mask_irq_fiq,
-	.mask	= iomd_mask_irq_fiq,
-	.unmask = iomd_unmask_irq_fiq,
+	.irq_ack	= iomd_mask_irq_fiq,
+	.irq_mask	= iomd_mask_irq_fiq,
+	.irq_unmask	= iomd_unmask_irq_fiq,
 };
 
 void __init rpc_init_irq(void)

commit fced80c735941fa518ac67c0b61bbe153fb8c050
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Sep 6 12:10:45 2008 +0100

    [ARM] Convert asm/io.h to linux/io.h
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-rpc/irq.c b/arch/arm/mach-rpc/irq.c
index 7a029621db43..9dd15d679c5d 100644
--- a/arch/arm/mach-rpc/irq.c
+++ b/arch/arm/mach-rpc/irq.c
@@ -1,10 +1,10 @@
 #include <linux/init.h>
 #include <linux/list.h>
+#include <linux/io.h>
 
 #include <asm/mach/irq.h>
 #include <asm/hardware/iomd.h>
 #include <asm/irq.h>
-#include <asm/io.h>
 
 static void iomd_ack_irq_a(unsigned int irq)
 {

commit 10dd5ce28d78e2440e8fa1135d17e33399d75340
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Nov 23 11:41:32 2006 +0000

    [ARM] Remove compatibility layer for ARM irqs
    
    set_irq_chipdata -> set_irq_chip_data
    get_irq_chipdata -> get_irq_chip_data
    do_level_IRQ -> handle_level_irq
    do_edge_IRQ -> handle_edge_irq
    do_simple_IRQ -> handle_simple_irq
    irqdesc -> irq_desc
    irqchip -> irq_chip
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-rpc/irq.c b/arch/arm/mach-rpc/irq.c
index 56b2716f8cf5..7a029621db43 100644
--- a/arch/arm/mach-rpc/irq.c
+++ b/arch/arm/mach-rpc/irq.c
@@ -34,7 +34,7 @@ static void iomd_unmask_irq_a(unsigned int irq)
 	iomd_writeb(val | mask, IOMD_IRQMASKA);
 }
 
-static struct irqchip iomd_a_chip = {
+static struct irq_chip iomd_a_chip = {
 	.ack	= iomd_ack_irq_a,
 	.mask	= iomd_mask_irq_a,
 	.unmask = iomd_unmask_irq_a,
@@ -58,7 +58,7 @@ static void iomd_unmask_irq_b(unsigned int irq)
 	iomd_writeb(val | mask, IOMD_IRQMASKB);
 }
 
-static struct irqchip iomd_b_chip = {
+static struct irq_chip iomd_b_chip = {
 	.ack	= iomd_mask_irq_b,
 	.mask	= iomd_mask_irq_b,
 	.unmask = iomd_unmask_irq_b,
@@ -82,7 +82,7 @@ static void iomd_unmask_irq_dma(unsigned int irq)
 	iomd_writeb(val | mask, IOMD_DMAMASK);
 }
 
-static struct irqchip iomd_dma_chip = {
+static struct irq_chip iomd_dma_chip = {
 	.ack	= iomd_mask_irq_dma,
 	.mask	= iomd_mask_irq_dma,
 	.unmask = iomd_unmask_irq_dma,
@@ -106,7 +106,7 @@ static void iomd_unmask_irq_fiq(unsigned int irq)
 	iomd_writeb(val | mask, IOMD_FIQMASK);
 }
 
-static struct irqchip iomd_fiq_chip = {
+static struct irq_chip iomd_fiq_chip = {
 	.ack	= iomd_mask_irq_fiq,
 	.mask	= iomd_mask_irq_fiq,
 	.unmask = iomd_unmask_irq_fiq,
@@ -134,19 +134,19 @@ void __init rpc_init_irq(void)
 		switch (irq) {
 		case 0 ... 7:
 			set_irq_chip(irq, &iomd_a_chip);
-			set_irq_handler(irq, do_level_IRQ);
+			set_irq_handler(irq, handle_level_irq);
 			set_irq_flags(irq, flags);
 			break;
 
 		case 8 ... 15:
 			set_irq_chip(irq, &iomd_b_chip);
-			set_irq_handler(irq, do_level_IRQ);
+			set_irq_handler(irq, handle_level_irq);
 			set_irq_flags(irq, flags);
 			break;
 
 		case 16 ... 21:
 			set_irq_chip(irq, &iomd_dma_chip);
-			set_irq_handler(irq, do_level_IRQ);
+			set_irq_handler(irq, handle_level_irq);
 			set_irq_flags(irq, flags);
 			break;
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/arm/mach-rpc/irq.c b/arch/arm/mach-rpc/irq.c
new file mode 100644
index 000000000000..56b2716f8cf5
--- /dev/null
+++ b/arch/arm/mach-rpc/irq.c
@@ -0,0 +1,162 @@
+#include <linux/init.h>
+#include <linux/list.h>
+
+#include <asm/mach/irq.h>
+#include <asm/hardware/iomd.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+static void iomd_ack_irq_a(unsigned int irq)
+{
+	unsigned int val, mask;
+
+	mask = 1 << irq;
+	val = iomd_readb(IOMD_IRQMASKA);
+	iomd_writeb(val & ~mask, IOMD_IRQMASKA);
+	iomd_writeb(mask, IOMD_IRQCLRA);
+}
+
+static void iomd_mask_irq_a(unsigned int irq)
+{
+	unsigned int val, mask;
+
+	mask = 1 << irq;
+	val = iomd_readb(IOMD_IRQMASKA);
+	iomd_writeb(val & ~mask, IOMD_IRQMASKA);
+}
+
+static void iomd_unmask_irq_a(unsigned int irq)
+{
+	unsigned int val, mask;
+
+	mask = 1 << irq;
+	val = iomd_readb(IOMD_IRQMASKA);
+	iomd_writeb(val | mask, IOMD_IRQMASKA);
+}
+
+static struct irqchip iomd_a_chip = {
+	.ack	= iomd_ack_irq_a,
+	.mask	= iomd_mask_irq_a,
+	.unmask = iomd_unmask_irq_a,
+};
+
+static void iomd_mask_irq_b(unsigned int irq)
+{
+	unsigned int val, mask;
+
+	mask = 1 << (irq & 7);
+	val = iomd_readb(IOMD_IRQMASKB);
+	iomd_writeb(val & ~mask, IOMD_IRQMASKB);
+}
+
+static void iomd_unmask_irq_b(unsigned int irq)
+{
+	unsigned int val, mask;
+
+	mask = 1 << (irq & 7);
+	val = iomd_readb(IOMD_IRQMASKB);
+	iomd_writeb(val | mask, IOMD_IRQMASKB);
+}
+
+static struct irqchip iomd_b_chip = {
+	.ack	= iomd_mask_irq_b,
+	.mask	= iomd_mask_irq_b,
+	.unmask = iomd_unmask_irq_b,
+};
+
+static void iomd_mask_irq_dma(unsigned int irq)
+{
+	unsigned int val, mask;
+
+	mask = 1 << (irq & 7);
+	val = iomd_readb(IOMD_DMAMASK);
+	iomd_writeb(val & ~mask, IOMD_DMAMASK);
+}
+
+static void iomd_unmask_irq_dma(unsigned int irq)
+{
+	unsigned int val, mask;
+
+	mask = 1 << (irq & 7);
+	val = iomd_readb(IOMD_DMAMASK);
+	iomd_writeb(val | mask, IOMD_DMAMASK);
+}
+
+static struct irqchip iomd_dma_chip = {
+	.ack	= iomd_mask_irq_dma,
+	.mask	= iomd_mask_irq_dma,
+	.unmask = iomd_unmask_irq_dma,
+};
+
+static void iomd_mask_irq_fiq(unsigned int irq)
+{
+	unsigned int val, mask;
+
+	mask = 1 << (irq & 7);
+	val = iomd_readb(IOMD_FIQMASK);
+	iomd_writeb(val & ~mask, IOMD_FIQMASK);
+}
+
+static void iomd_unmask_irq_fiq(unsigned int irq)
+{
+	unsigned int val, mask;
+
+	mask = 1 << (irq & 7);
+	val = iomd_readb(IOMD_FIQMASK);
+	iomd_writeb(val | mask, IOMD_FIQMASK);
+}
+
+static struct irqchip iomd_fiq_chip = {
+	.ack	= iomd_mask_irq_fiq,
+	.mask	= iomd_mask_irq_fiq,
+	.unmask = iomd_unmask_irq_fiq,
+};
+
+void __init rpc_init_irq(void)
+{
+	unsigned int irq, flags;
+
+	iomd_writeb(0, IOMD_IRQMASKA);
+	iomd_writeb(0, IOMD_IRQMASKB);
+	iomd_writeb(0, IOMD_FIQMASK);
+	iomd_writeb(0, IOMD_DMAMASK);
+
+	for (irq = 0; irq < NR_IRQS; irq++) {
+		flags = IRQF_VALID;
+
+		if (irq <= 6 || (irq >= 9 && irq <= 15))
+			flags |= IRQF_PROBE;
+
+		if (irq == 21 || (irq >= 16 && irq <= 19) ||
+		    irq == IRQ_KEYBOARDTX)
+			flags |= IRQF_NOAUTOEN;
+
+		switch (irq) {
+		case 0 ... 7:
+			set_irq_chip(irq, &iomd_a_chip);
+			set_irq_handler(irq, do_level_IRQ);
+			set_irq_flags(irq, flags);
+			break;
+
+		case 8 ... 15:
+			set_irq_chip(irq, &iomd_b_chip);
+			set_irq_handler(irq, do_level_IRQ);
+			set_irq_flags(irq, flags);
+			break;
+
+		case 16 ... 21:
+			set_irq_chip(irq, &iomd_dma_chip);
+			set_irq_handler(irq, do_level_IRQ);
+			set_irq_flags(irq, flags);
+			break;
+
+		case 64 ... 71:
+			set_irq_chip(irq, &iomd_fiq_chip);
+			set_irq_flags(irq, IRQF_VALID);
+			break;
+		}
+	}
+
+	init_FIQ();
+}
+
