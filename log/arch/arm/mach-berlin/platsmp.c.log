commit eb14767c8a9117fdd84fc79e6263c85a4d8ec934
Author: Jisheng Zhang <Jisheng.Zhang@synaptics.com>
Date:   Wed May 16 16:07:52 2018 +0800

    ARM: berlin: switch to SPDX license identifier
    
    Use the appropriate SPDX license identifier and drop the previous
    boilerplate license text.
    
    Signed-off-by: Jisheng Zhang <Jisheng.Zhang@synaptics.com>

diff --git a/arch/arm/mach-berlin/platsmp.c b/arch/arm/mach-berlin/platsmp.c
index a8ae4a566d99..593fc4a69d84 100644
--- a/arch/arm/mach-berlin/platsmp.c
+++ b/arch/arm/mach-berlin/platsmp.c
@@ -1,11 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2014 Marvell Technology Group Ltd.
  *
  * Antoine Ténart <antoine.tenart@free-electrons.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/io.h>

commit e03b48098ed8729e643b8d9b13a5b250fc403ad2
Author: Jisheng Zhang <Jisheng.Zhang@synaptics.com>
Date:   Mon May 7 15:28:06 2018 +0800

    arm: berlin: remove non-necessary flush_cache_all()
    
    I believe the flush_cache_all() after scu_enable() is to "Ensure that
    the data accessed by CPU0 before the SCU was initialised is visible
    to the other CPUs." as commented in scu_enable(). So here
    flush_cache_all() is a duplication, remove it.
    
    Signed-off-by: Jisheng Zhang <Jisheng.Zhang@synaptics.com>

diff --git a/arch/arm/mach-berlin/platsmp.c b/arch/arm/mach-berlin/platsmp.c
index 7586b7aec272..a8ae4a566d99 100644
--- a/arch/arm/mach-berlin/platsmp.c
+++ b/arch/arm/mach-berlin/platsmp.c
@@ -81,7 +81,6 @@ static void __init berlin_smp_prepare_cpus(unsigned int max_cpus)
 		goto unmap_scu;
 
 	scu_enable(scu_base);
-	flush_cache_all();
 
 	/*
 	 * Write the first instruction the CPU will execute after being reset

commit d2ca5f2491c1246adf3847101fdc538a3b89439c
Author: Afzal Mohammed <afzal.mohd.ma@gmail.com>
Date:   Sun Jan 29 17:31:32 2017 +0100

    ARM: 8646/1: mmu: decouple VECTORS_BASE from Kconfig
    
    For MMU configurations, VECTORS_BASE is always 0xffff0000, a macro
    definition will suffice.
    
    For no-MMU, exception base address is dynamically determined in
    subsequent patches. To preserve bisectability, now make the
    macro applicable for no-MMU scenario too.
    
    Thanks to 0-DAY kernel test infrastructure that found the
    bisectability issue. This macro will be restricted to MMU case upon
    dynamically determining exception base address for no-MMU.
    
    Once exception address is handled dynamically for no-MMU,
    VECTORS_BASE can be removed from Kconfig.
    
    Signed-off-by: afzal mohammed <afzal.mohd.ma@gmail.com>
    Tested-by: Vladimir Murzin <vladimir.murzin@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-berlin/platsmp.c b/arch/arm/mach-berlin/platsmp.c
index 1167b0ed92c8..7586b7aec272 100644
--- a/arch/arm/mach-berlin/platsmp.c
+++ b/arch/arm/mach-berlin/platsmp.c
@@ -15,6 +15,7 @@
 
 #include <asm/cacheflush.h>
 #include <asm/cp15.h>
+#include <asm/memory.h>
 #include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
 
@@ -75,7 +76,7 @@ static void __init berlin_smp_prepare_cpus(unsigned int max_cpus)
 	if (!cpu_ctrl)
 		goto unmap_scu;
 
-	vectors_base = ioremap(CONFIG_VECTORS_BASE, SZ_32K);
+	vectors_base = ioremap(VECTORS_BASE, SZ_32K);
 	if (!vectors_base)
 		goto unmap_scu;
 

commit 64fc2a947a9873700929ec0ef02b4654a04e0476
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sun Jan 15 03:59:29 2017 +0100

    ARM: 8641/1: treewide: Replace uses of virt_to_phys with __pa_symbol
    
    All low-level PM/SMP code using virt_to_phys() should actually use
    __pa_symbol() against kernel symbols. Update code where relevant to move
    away from virt_to_phys().
    
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Laura Abbott <labbott@redhat.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-berlin/platsmp.c b/arch/arm/mach-berlin/platsmp.c
index 93f90688db18..1167b0ed92c8 100644
--- a/arch/arm/mach-berlin/platsmp.c
+++ b/arch/arm/mach-berlin/platsmp.c
@@ -92,7 +92,7 @@ static void __init berlin_smp_prepare_cpus(unsigned int max_cpus)
 	 * Write the secondary startup address into the SW reset address
 	 * vector. This is used by boot_inst.
 	 */
-	writel(virt_to_phys(secondary_startup), vectors_base + SW_RESET_ADDR);
+	writel(__pa_symbol(secondary_startup), vectors_base + SW_RESET_ADDR);
 
 	iounmap(vectors_base);
 unmap_scu:

commit 75305275a721d33ae9abfaeed2817cec8b2fee9a
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 15 10:39:53 2015 +0900

    ARM: use const and __initconst for smp_operations
    
    These smp_operations structures are not over-written, so add "const"
    qualifier and replace __initdata with __initconst.
    
    Also, add "static" where it is possible.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Moritz Fischer <moritz.fischer@ettus.com>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org> # qcom part
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: Wei Xu <xuwei5@hisilicon.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Acked-by: Matthias Brugger <matthias.bgg@gmail.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-berlin/platsmp.c b/arch/arm/mach-berlin/platsmp.c
index 405cd37e4fba..93f90688db18 100644
--- a/arch/arm/mach-berlin/platsmp.c
+++ b/arch/arm/mach-berlin/platsmp.c
@@ -119,7 +119,7 @@ static int berlin_cpu_kill(unsigned int cpu)
 }
 #endif
 
-static struct smp_operations berlin_smp_ops __initdata = {
+static const struct smp_operations berlin_smp_ops __initconst = {
 	.smp_prepare_cpus	= berlin_smp_prepare_cpus,
 	.smp_boot_secondary	= berlin_boot_secondary,
 #ifdef CONFIG_HOTPLUG_CPU

commit a7b3d5a715f489ee542e59d722281c9f16da50dc
Author: Jisheng Zhang <jszhang@marvell.com>
Date:   Mon Sep 14 14:47:45 2015 +0800

    arm: berlin: add CPU hotplug support
    
    Add cpu hotplug support for berlin SoCs such as BG2 and BG2Q. These SoC
    don't support power off cpu independently, but we also want cpu hotplug
    support in these SoCs. We achieve this goal by putting the dying CPU in
    WFI state after the coherency is disabled, then asserting the dying CPU
    reset bit to put the CPU in reset state.
    
    Signed-off-by: Jisheng Zhang <jszhang@marvell.com>
    Signed-off-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>

diff --git a/arch/arm/mach-berlin/platsmp.c b/arch/arm/mach-berlin/platsmp.c
index 64cb1ab182c4..405cd37e4fba 100644
--- a/arch/arm/mach-berlin/platsmp.c
+++ b/arch/arm/mach-berlin/platsmp.c
@@ -14,6 +14,7 @@
 #include <linux/of_address.h>
 
 #include <asm/cacheflush.h>
+#include <asm/cp15.h>
 #include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
 
@@ -98,8 +99,32 @@ static void __init berlin_smp_prepare_cpus(unsigned int max_cpus)
 	iounmap(scu_base);
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+static void berlin_cpu_die(unsigned int cpu)
+{
+	v7_exit_coherency_flush(louis);
+	while (1)
+		cpu_do_idle();
+}
+
+static int berlin_cpu_kill(unsigned int cpu)
+{
+	u32 val;
+
+	val = readl(cpu_ctrl + CPU_RESET_NON_SC);
+	val &= ~BIT(cpu_logical_map(cpu));
+	writel(val, cpu_ctrl + CPU_RESET_NON_SC);
+
+	return 1;
+}
+#endif
+
 static struct smp_operations berlin_smp_ops __initdata = {
 	.smp_prepare_cpus	= berlin_smp_prepare_cpus,
 	.smp_boot_secondary	= berlin_boot_secondary,
+#ifdef CONFIG_HOTPLUG_CPU
+	.cpu_die		= berlin_cpu_die,
+	.cpu_kill		= berlin_cpu_kill,
+#endif
 };
 CPU_METHOD_OF_DECLARE(berlin_smp, "marvell,berlin-smp", &berlin_smp_ops);

commit ac7fc233b2c337880d7d973be19f6fb03108d6f7
Author: Jisheng Zhang <jszhang@marvell.com>
Date:   Mon Sep 14 14:47:44 2015 +0800

    arm: berlin: use non-self-cleared reset register to reset cpu
    
    In Berlin SoCs, there are two kinds of cpu reset control registers: the
    first one's corresponding bits will be self-cleared after some cycles,
    while the second one's bits won't. Previously the first kind of reset
    control register is used, this patch uses the second kind one to prepare
    for the next hotplug commit.
    
    Signed-off-by: Jisheng Zhang <jszhang@marvell.com>
    Signed-off-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>

diff --git a/arch/arm/mach-berlin/platsmp.c b/arch/arm/mach-berlin/platsmp.c
index 34a3753e7356..64cb1ab182c4 100644
--- a/arch/arm/mach-berlin/platsmp.c
+++ b/arch/arm/mach-berlin/platsmp.c
@@ -17,7 +17,12 @@
 #include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
 
-#define CPU_RESET		0x00
+/*
+ * There are two reset registers, one with self-clearing (SC)
+ * reset and one with non-self-clearing reset (NON_SC).
+ */
+#define CPU_RESET_SC		0x00
+#define CPU_RESET_NON_SC	0x20
 
 #define RESET_VECT		0x00
 #define SW_RESET_ADDR		0x94
@@ -30,9 +35,11 @@ static inline void berlin_perform_reset_cpu(unsigned int cpu)
 {
 	u32 val;
 
-	val = readl(cpu_ctrl + CPU_RESET);
+	val = readl(cpu_ctrl + CPU_RESET_NON_SC);
+	val &= ~BIT(cpu_logical_map(cpu));
+	writel(val, cpu_ctrl + CPU_RESET_NON_SC);
 	val |= BIT(cpu_logical_map(cpu));
-	writel(val, cpu_ctrl + CPU_RESET);
+	writel(val, cpu_ctrl + CPU_RESET_NON_SC);
 }
 
 static int berlin_boot_secondary(unsigned int cpu, struct task_struct *idle)

commit 02b4e2756e01c623cc4dbceae4b07be75252db5b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue May 19 17:06:44 2015 +0100

    ARM: v7 setup function should invalidate L1 cache
    
    All ARMv5 and older CPUs invalidate their caches in the early assembly
    setup function, prior to enabling the MMU.  This is because the L1
    cache should not contain any data relevant to the execution of the
    kernel at this point; all data should have been flushed out to memory.
    
    This requirement should also be true for ARMv6 and ARMv7 CPUs - indeed,
    these typically do not search their caches when caching is disabled (as
    it needs to be when the MMU is disabled) so this change should be safe.
    
    ARMv7 allows there to be CPUs which search their caches while caching is
    disabled, and it's permitted that the cache is uninitialised at boot;
    for these, the architecture reference manual requires that an
    implementation specific code sequence is used immediately after reset
    to ensure that the cache is placed into a sane state.  Such
    functionality is definitely outside the remit of the Linux kernel, and
    must be done by the SoC's firmware before _any_ CPU gets to the Linux
    kernel.
    
    Changing the data cache clean+invalidate to a mere invalidate allows us
    to get rid of a lot of platform specific hacks around this issue for
    their secondary CPU bringup paths - some of which were buggy.
    
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Tested-by: Florian Fainelli <f.fainelli@gmail.com>
    Tested-by: Heiko Stuebner <heiko@sntech.de>
    Tested-by: Dinh Nguyen <dinguyen@opensource.altera.com>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Tested-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Acked-by: Shawn Guo <shawn.guo@linaro.org>
    Tested-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Tested-by: Michal Simek <michal.simek@xilinx.com>
    Tested-by: Wei Xu <xuwei5@hisilicon.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-berlin/platsmp.c b/arch/arm/mach-berlin/platsmp.c
index 702e7982015a..34a3753e7356 100644
--- a/arch/arm/mach-berlin/platsmp.c
+++ b/arch/arm/mach-berlin/platsmp.c
@@ -22,7 +22,6 @@
 #define RESET_VECT		0x00
 #define SW_RESET_ADDR		0x94
 
-extern void berlin_secondary_startup(void);
 extern u32 boot_inst;
 
 static void __iomem *cpu_ctrl;
@@ -85,7 +84,7 @@ static void __init berlin_smp_prepare_cpus(unsigned int max_cpus)
 	 * Write the secondary startup address into the SW reset address
 	 * vector. This is used by boot_inst.
 	 */
-	writel(virt_to_phys(berlin_secondary_startup), vectors_base + SW_RESET_ADDR);
+	writel(virt_to_phys(secondary_startup), vectors_base + SW_RESET_ADDR);
 
 	iounmap(vectors_base);
 unmap_scu:

commit 7b7dfdd2b9927c1861bb6d03ca35261f1739aceb
Author: Antoine Ténart <antoine.tenart@free-electrons.com>
Date:   Wed Jun 4 18:03:42 2014 +0200

    ARM: berlin: add SMP support
    
    Adds SMP support for Berlin SoCs. Secondary CPUs are reset, then
    execute the instruction we put in the reset exception register, setting
    the pc at the address contained in the software reset address register,
    which is the physical address of the Berlin secondary startup.
    
    This implementation avoid using the pen lock mechanism.
    
    Signed-off-by: Antoine Ténart <antoine.tenart@free-electrons.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>

diff --git a/arch/arm/mach-berlin/platsmp.c b/arch/arm/mach-berlin/platsmp.c
new file mode 100644
index 000000000000..702e7982015a
--- /dev/null
+++ b/arch/arm/mach-berlin/platsmp.c
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2014 Marvell Technology Group Ltd.
+ *
+ * Antoine Ténart <antoine.tenart@free-electrons.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+
+#include <asm/cacheflush.h>
+#include <asm/smp_plat.h>
+#include <asm/smp_scu.h>
+
+#define CPU_RESET		0x00
+
+#define RESET_VECT		0x00
+#define SW_RESET_ADDR		0x94
+
+extern void berlin_secondary_startup(void);
+extern u32 boot_inst;
+
+static void __iomem *cpu_ctrl;
+
+static inline void berlin_perform_reset_cpu(unsigned int cpu)
+{
+	u32 val;
+
+	val = readl(cpu_ctrl + CPU_RESET);
+	val |= BIT(cpu_logical_map(cpu));
+	writel(val, cpu_ctrl + CPU_RESET);
+}
+
+static int berlin_boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	if (!cpu_ctrl)
+		return -EFAULT;
+
+	/*
+	 * Reset the CPU, making it to execute the instruction in the reset
+	 * exception vector.
+	 */
+	berlin_perform_reset_cpu(cpu);
+
+	return 0;
+}
+
+static void __init berlin_smp_prepare_cpus(unsigned int max_cpus)
+{
+	struct device_node *np;
+	void __iomem *scu_base;
+	void __iomem *vectors_base;
+
+	np = of_find_compatible_node(NULL, NULL, "arm,cortex-a9-scu");
+	scu_base = of_iomap(np, 0);
+	of_node_put(np);
+	if (!scu_base)
+		return;
+
+	np = of_find_compatible_node(NULL, NULL, "marvell,berlin-cpu-ctrl");
+	cpu_ctrl = of_iomap(np, 0);
+	of_node_put(np);
+	if (!cpu_ctrl)
+		goto unmap_scu;
+
+	vectors_base = ioremap(CONFIG_VECTORS_BASE, SZ_32K);
+	if (!vectors_base)
+		goto unmap_scu;
+
+	scu_enable(scu_base);
+	flush_cache_all();
+
+	/*
+	 * Write the first instruction the CPU will execute after being reset
+	 * in the reset exception vector.
+	 */
+	writel(boot_inst, vectors_base + RESET_VECT);
+
+	/*
+	 * Write the secondary startup address into the SW reset address
+	 * vector. This is used by boot_inst.
+	 */
+	writel(virt_to_phys(berlin_secondary_startup), vectors_base + SW_RESET_ADDR);
+
+	iounmap(vectors_base);
+unmap_scu:
+	iounmap(scu_base);
+}
+
+static struct smp_operations berlin_smp_ops __initdata = {
+	.smp_prepare_cpus	= berlin_smp_prepare_cpus,
+	.smp_boot_secondary	= berlin_boot_secondary,
+};
+CPU_METHOD_OF_DECLARE(berlin_smp, "marvell,berlin-smp", &berlin_smp_ops);
