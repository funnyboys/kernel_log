commit fe2da896fd9469317ff693fb08a86d9c435e101a
Merge: cd0f3aaebc5b e73f65930f88
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 28 08:37:04 2019 +0800

    Merge tag 'armsoc-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc
    
    Pull ARM SoC fixes from Olof Johansson:
     "A smaller batch of fixes, nothing that stands out as risky or scary.
    
      Mostly DTS tweaks for a few issues:
    
       - GPU fixlets for Meson
    
       - CPU idle fix for LS1028A
    
       - PWM interrupt fixes for i.MX6UL
    
      Also, enable a driver (FSL_EDMA) on arm64 defconfig, and a warning and
      two MAINTAINER tweaks"
    
    * tag 'armsoc-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc:
      ARM: dts: imx6ul: fix PWM[1-4] interrupts
      ARM: omap2: remove incorrect __init annotation
      ARM: dts: gemini Fix up DNS-313 compatible string
      ARM: dts: Blank D-Link DIR-685 console
      arm64: defconfig: Enable FSL_EDMA driver
      arm64: dts: ls1028a: Fix CPU idle fail.
      MAINTAINERS: BCM53573: Add internal Broadcom mailing list
      MAINTAINERS: BCM2835: Add internal Broadcom mailing list
      ARM: dts: meson8b: fix the operating voltage of the Mali GPU
      ARM: dts: meson8b: drop undocumented property from the Mali GPU node
      ARM: dts: meson8: fix GPU interrupts and drop an undocumented property

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 05858f966f7d..fd4a3bf27993 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * OMAP3xxx PRM module functions
  *
@@ -6,10 +7,6 @@
  * Benoît Cousson
  * Paul Walmsley
  * Rajendra Nayak <rnayak@ti.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/kernel.h>

commit 27e23d8975270df6999f8b5b3156fc0c04927451
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jun 19 15:04:54 2019 +0200

    ARM: omap2: remove incorrect __init annotation
    
    omap3xxx_prm_enable_io_wakeup() is marked __init, but its caller is not, so
    we get a warning with clang-8:
    
    WARNING: vmlinux.o(.text+0x343c8): Section mismatch in reference from the function omap3xxx_prm_late_init() to the function .init.text:omap3xxx_prm_enable_io_wakeup()
    The function omap3xxx_prm_late_init() references
    the function __init omap3xxx_prm_enable_io_wakeup().
    This is often because omap3xxx_prm_late_init lacks a __init
    annotation or the annotation of omap3xxx_prm_enable_io_wakeup is wrong.
    
    When building with gcc, omap3xxx_prm_enable_io_wakeup() is always
    inlined, so we never noticed in the past.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Nathan Chancellor <natechancellor@gmail.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Andrew Murray <andrew.murray@arm.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 05858f966f7d..dfa65fc2c82b 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -433,7 +433,7 @@ static void omap3_prm_reconfigure_io_chain(void)
  * registers, and omap3xxx_prm_reconfigure_io_chain() must be called.
  * No return value.
  */
-static void __init omap3xxx_prm_enable_io_wakeup(void)
+static void omap3xxx_prm_enable_io_wakeup(void)
 {
 	if (prm_features & PRM_HAS_IO_WAKEUP)
 		omap2_prm_set_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD,

commit 82e5051ba4e7c6d3820e3ab87c1f20a6531d64a8
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 10 14:27:06 2017 -0700

    ARM: OMAP3: Remove legacy IRQ for PRM
    
    We have this coming from device tree and legacy booting is
    no longer needed.
    
    Cc: Lokesh Vutla <lokeshvutla@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index a2dd13217c89..05858f966f7d 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -704,12 +704,18 @@ static int omap3xxx_prm_late_init(void)
 			omap3430_pre_es3_1_reconfigure_io_chain;
 
 	np = of_find_matching_node(NULL, omap3_prm_dt_match_table);
-	if (np) {
-		irq_num = of_irq_get(np, 0);
-		if (irq_num > 0)
-			omap3_prcm_irq_setup.irq = irq_num;
+	if (!np) {
+		pr_err("PRM: no device tree node for interrupt?\n");
+
+		return -ENODEV;
 	}
 
+	irq_num = of_irq_get(np, 0);
+	if (irq_num == -EPROBE_DEFER)
+		return irq_num;
+
+	omap3_prcm_irq_setup.irq = irq_num;
+
 	omap3xxx_prm_enable_io_wakeup();
 
 	return omap_prcm_register_chain_handler(&omap3_prcm_irq_setup);

commit d683878dbeab3cd5cd073e40b41f24a4c7f62415
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Tue Aug 15 08:53:18 2017 -0700

    ARM: OMAP3+: PRM: fix of_irq_get() result check
    
    of_irq_get() may return 0 as well as a nagative error number on failure
    (and never on success), however omap3xxx_prm_late_init() regards 0 as a
    valid IRQ -- fix this.
    
    Fixes: 1e037794f7f ("ARM: OMAP3+: PRM: register interrupt information from DT")
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 64f6451499a7..a2dd13217c89 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -706,7 +706,7 @@ static int omap3xxx_prm_late_init(void)
 	np = of_find_matching_node(NULL, omap3_prm_dt_match_table);
 	if (np) {
 		irq_num = of_irq_get(np, 0);
-		if (irq_num >= 0)
+		if (irq_num > 0)
 			omap3_prcm_irq_setup.irq = irq_num;
 	}
 

commit 324dd7a6ac27b388e605ef136f23c88a5e49edbe
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Jun 27 01:48:38 2017 -0700

    ARM: OMAP2+: Fix omap3 prm shared irq
    
    Shared interrupts with IRQ_NOAUTOEN got a warning added with commit
    04c848d39879 ("genirq: Warn when IRQ_NOAUTOEN is used with shared
    interrupts").
    
    Let's just drop the IRQ_NOAUTOEN use for omap3 PRM shared interrupt as
    it does not seem to cause any other issues based on my testing. We have
    moved a lot of the code to initialize later, and whatever problems the
    legacy booting had seem to be gone now with pinctrl driver and device
    tree based booting.
    
    Otherwise we will get:
    
    WARNING: CPU: 0 PID: 1 at kernel/irq/manage.c:1348 __setup_irq+0x5d0/0x64c
    [<c01b0260>] (__setup_irq) from [<c01b0480>]
    (request_threaded_irq+0xdc/0x188)
    [<c01b0480>] (request_threaded_irq) from [<c051c780>]
    (pcs_probe+0x6ec/0x8a4)
    [<c051c780>] (pcs_probe) from [<c05a84b8>] (platform_drv_probe+0x50/0xb0)
    [<c05a84b8>] (platform_drv_probe) from [<c05a6288>]
    (driver_probe_device+0x33c/0x478)
    
    Note that we also need to remove the related enable_irq() to avoid
    getting the following:
    
    WARNING: CPU: 0 PID: 1 at kernel/irq/manage.c:529 enable_irq+0x34/0x70
    [<c01afa04>] (enable_irq) from [<c0c0f1fc>] (omap3_pm_init+0x118/0x3f8)
    [<c0c0f1fc>] (omap3_pm_init) from [<c0c0ae7c>] (am35xx_init_late+0x10/0x18)
    
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 382e236fbfd9..64f6451499a7 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -692,7 +692,6 @@ static int omap3xxx_prm_late_init(void)
 {
 	struct device_node *np;
 	int irq_num;
-	int ret;
 
 	if (!(prm_features & PRM_HAS_IO_WAKEUP))
 		return 0;
@@ -712,12 +711,8 @@ static int omap3xxx_prm_late_init(void)
 	}
 
 	omap3xxx_prm_enable_io_wakeup();
-	ret = omap_prcm_register_chain_handler(&omap3_prcm_irq_setup);
-	if (!ret)
-		irq_set_status_flags(omap_prcm_event_to_irq("io"),
-				     IRQ_NOAUTOEN);
 
-	return ret;
+	return omap_prcm_register_chain_handler(&omap3_prcm_irq_setup);
 }
 
 static void __exit omap3xxx_prm_exit(void)

commit 67d00470accf5c58abbb23a44c867c5f15437976
Merge: 018b732458ac 70f05be32133
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Jun 12 03:27:30 2017 -0700

    Merge branch 'omap-for-v4.13/clkctrl' into omap-for-v4.13/soc-v4

commit 2a26d31b1bae5d07b97fc05755053295da686ec7
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 31 15:51:36 2017 -0700

    ARM: OMAP2+: Remove unused legacy code for PRM
    
    We are now booting all mach-omap2 in device tree only mode.
    Any code that is only called in legacy boot mode where
    of_have_populated_dt() is not set is safe to remove now.
    
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 718981bb80cd..395cf43b5c5e 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -690,6 +690,8 @@ static const struct of_device_id omap3_prm_dt_match_table[] = {
 
 static int omap3xxx_prm_late_init(void)
 {
+	struct device_node *np;
+	int irq_num;
 	int ret;
 
 	if (!(prm_features & PRM_HAS_IO_WAKEUP))
@@ -702,16 +704,11 @@ static int omap3xxx_prm_late_init(void)
 		omap3_prcm_irq_setup.reconfigure_io_chain =
 			omap3430_pre_es3_1_reconfigure_io_chain;
 
-	if (of_have_populated_dt()) {
-		struct device_node *np;
-		int irq_num;
-
-		np = of_find_matching_node(NULL, omap3_prm_dt_match_table);
-		if (np) {
-			irq_num = of_irq_get(np, 0);
-			if (irq_num >= 0)
-				omap3_prcm_irq_setup.irq = irq_num;
-		}
+	np = of_find_matching_node(NULL, omap3_prm_dt_match_table);
+	if (np) {
+		irq_num = of_irq_get(np, 0);
+		if (irq_num >= 0)
+			omap3_prcm_irq_setup.irq = irq_num;
 	}
 
 	omap3xxx_prm_enable_io_wakeup();

commit 90129336712c3c8dcd0d81a5dfaea52dd8391e62
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed May 31 18:00:00 2017 +0300

    ARM: OMAP2+: PRCM: store also physical addresses for instances
    
    In some cases the physical address info is needed, so store this
    under the existing cm*_base, prm_base and prcm_mpu_base variables.
    These are converted now to structs that contain both virtual and
    physical address base for the instance.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 718981bb80cd..50291a063aab 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -676,7 +676,7 @@ static struct prm_ll_data omap3xxx_prm_ll_data = {
 int __init omap3xxx_prm_init(const struct omap_prcm_init_data *data)
 {
 	omap2_clk_legacy_provider_init(TI_CLKM_PRM,
-				       prm_base + OMAP3430_IVA2_MOD);
+				       prm_base.va + OMAP3430_IVA2_MOD);
 	if (omap3_has_io_wakeup())
 		prm_features |= PRM_HAS_IO_WAKEUP;
 

commit 4ae46efcff19445afbf49fe7038de6020f37fefe
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Oct 24 12:00:21 2016 +0100

    ARM: OMAP2+: PRM: initialize en_uart4_mask and grpsel_uart4_mask
    
    In the case where has_uart4 is false, en_uart4_mask and grpsel_uart4_mask
    are not initialized and so any garbage value is being logically or'd into
    the write of PM_WKEN and OMAP3430_PM_MPUGRPSEL.  Fix this by initializing
    these masks to zero.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 62680aad2126..718981bb80cd 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -319,6 +319,9 @@ void __init omap3_prm_init_pm(bool has_uart4, bool has_iva)
 	if (has_uart4) {
 		en_uart4_mask = OMAP3630_EN_UART4_MASK;
 		grpsel_uart4_mask = OMAP3630_GRPSEL_UART4_MASK;
+	} else {
+		en_uart4_mask = 0;
+		grpsel_uart4_mask = 0;
 	}
 
 	/* Enable wakeups in PER */

commit ab7b2ffcf576a49b51c240dcd68ca4b7cd60b84d
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Nov 20 15:02:59 2014 +0200

    ARM: OMAP2+: PRM: move SoC specific init calls within a generic API
    
    This gets rid of need for some exported driver APIs, and simplifies the
    initialization of the PRM driver. Done in preparation to make PRM a
    separate driver. The init data is now also passed to the SoC specific
    implementations, allowing future expansion to add feature flags etc.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index a347993a7bfe..62680aad2126 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -670,12 +670,10 @@ static struct prm_ll_data omap3xxx_prm_ll_data = {
 	.vp_clear_txdone = &omap3_prm_vp_clear_txdone,
 };
 
-int __init omap3xxx_prm_init(void)
+int __init omap3xxx_prm_init(const struct omap_prcm_init_data *data)
 {
 	omap2_clk_legacy_provider_init(TI_CLKM_PRM,
 				       prm_base + OMAP3430_IVA2_MOD);
-	omap2_prm_base_init();
-
 	if (omap3_has_io_wakeup())
 		prm_features |= PRM_HAS_IO_WAKEUP;
 

commit ae521d4d9c54995df1e0fb53ef6820374a3cae4e
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Nov 11 17:17:18 2014 +0200

    ARM: OMAP2+: PRM: determine PRM base address from device tree
    
    There is no need to provide the PRM base address through a low-level API
    from the low-level IO init, as this information is available through DT.
    Re-routed the parsing function to be called from the PRM drivers also to
    simplify the implementation under io.c.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 2b478adc337d..a347993a7bfe 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -29,6 +29,7 @@
 #include "prm-regbits-34xx.h"
 #include "cm3xxx.h"
 #include "cm-regbits-34xx.h"
+#include "clock.h"
 
 static void omap3xxx_prm_read_pending_irqs(unsigned long *events);
 static void omap3xxx_prm_ocp_barrier(void);
@@ -671,6 +672,10 @@ static struct prm_ll_data omap3xxx_prm_ll_data = {
 
 int __init omap3xxx_prm_init(void)
 {
+	omap2_clk_legacy_provider_init(TI_CLKM_PRM,
+				       prm_base + OMAP3430_IVA2_MOD);
+	omap2_prm_base_init();
+
 	if (omap3_has_io_wakeup())
 		prm_features |= PRM_HAS_IO_WAKEUP;
 

commit e9f1ddcdec54d32892a0a749de017a39c6c84beb
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Apr 4 15:52:01 2014 +0300

    ARM: OMAP3+: PRM: add common APIs for prm_vp_check/clear_txdone
    
    PRM driver now only exports a generic API for clearing / checking
    VP txdone status.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index a4443344affe..2b478adc337d 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -96,7 +96,7 @@ static struct omap3_vp omap3_vp[] = {
 
 #define MAX_VP_ID ARRAY_SIZE(omap3_vp);
 
-u32 omap3_prm_vp_check_txdone(u8 vp_id)
+static u32 omap3_prm_vp_check_txdone(u8 vp_id)
 {
 	struct omap3_vp *vp = &omap3_vp[vp_id];
 	u32 irqstatus;
@@ -106,7 +106,7 @@ u32 omap3_prm_vp_check_txdone(u8 vp_id)
 	return irqstatus & vp->tranxdone_status;
 }
 
-void omap3_prm_vp_clear_txdone(u8 vp_id)
+static void omap3_prm_vp_clear_txdone(u8 vp_id)
 {
 	struct omap3_vp *vp = &omap3_vp[vp_id];
 
@@ -665,6 +665,8 @@ static struct prm_ll_data omap3xxx_prm_ll_data = {
 	.is_hardreset_asserted = &omap2_prm_is_hardreset_asserted,
 	.reset_system = &omap3xxx_prm_dpll3_reset,
 	.clear_mod_irqs = &omap3xxx_prm_clear_mod_irqs,
+	.vp_check_txdone = &omap3_prm_vp_check_txdone,
+	.vp_clear_txdone = &omap3_prm_vp_clear_txdone,
 };
 
 int __init omap3xxx_prm_init(void)

commit 9cb6d36371b0a9935de92bf250c7152f5b50fdc1
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Apr 4 12:31:51 2014 +0300

    ARM: OMAP2+: PRM: add generic API for clear_mod_irqs
    
    OMAP2/3 now use generic API for the prm_clear_mod_irqs, the SoC specific
    implementation details are provided through prm_ll_data.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 4cc72e828421..a4443344affe 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -226,7 +226,7 @@ static void omap3xxx_prm_restore_irqen(u32 *saved_mask)
  * that any peripheral wake-up events occurring while attempting to
  * clear the PM_WKST_x are detected and cleared.
  */
-int omap3xxx_prm_clear_mod_irqs(s16 module, u8 regs, u32 wkst_mask)
+static int omap3xxx_prm_clear_mod_irqs(s16 module, u8 regs, u32 wkst_mask)
 {
 	u32 wkst, fclk, iclk, clken;
 	u16 wkst_off = (regs == 3) ? OMAP3430ES2_PM_WKST3 : PM_WKST1;
@@ -664,6 +664,7 @@ static struct prm_ll_data omap3xxx_prm_ll_data = {
 	.deassert_hardreset = &omap2_prm_deassert_hardreset,
 	.is_hardreset_asserted = &omap2_prm_is_hardreset_asserted,
 	.reset_system = &omap3xxx_prm_dpll3_reset,
+	.clear_mod_irqs = &omap3xxx_prm_clear_mod_irqs,
 };
 
 int __init omap3xxx_prm_init(void)

commit f0caa5270bcf97c6a51c89d44747da00c0d67bb8
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Apr 4 12:14:27 2014 +0300

    ARM: OMAP3: PRM: invert the wkst_mask for the prm_clear_mod_irqs
    
    This makes the API the same as used with OMAP2, and makes it possible
    to implement a generic driver API for the functionality.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 5713bbdf83bc..4cc72e828421 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -217,7 +217,7 @@ static void omap3xxx_prm_restore_irqen(u32 *saved_mask)
  * omap3xxx_prm_clear_mod_irqs - clear wake-up events from PRCM interrupt
  * @module: PRM module to clear wakeups from
  * @regs: register set to clear, 1 or 3
- * @ignore_bits: wakeup status bits to ignore
+ * @wkst_mask: wkst bits to clear
  *
  * The purpose of this function is to clear any wake-up events latched
  * in the PRCM PM_WKST_x registers. It is possible that a wake-up event
@@ -226,7 +226,7 @@ static void omap3xxx_prm_restore_irqen(u32 *saved_mask)
  * that any peripheral wake-up events occurring while attempting to
  * clear the PM_WKST_x are detected and cleared.
  */
-int omap3xxx_prm_clear_mod_irqs(s16 module, u8 regs, u32 ignore_bits)
+int omap3xxx_prm_clear_mod_irqs(s16 module, u8 regs, u32 wkst_mask)
 {
 	u32 wkst, fclk, iclk, clken;
 	u16 wkst_off = (regs == 3) ? OMAP3430ES2_PM_WKST3 : PM_WKST1;
@@ -238,7 +238,7 @@ int omap3xxx_prm_clear_mod_irqs(s16 module, u8 regs, u32 ignore_bits)
 
 	wkst = omap2_prm_read_mod_reg(module, wkst_off);
 	wkst &= omap2_prm_read_mod_reg(module, grpsel_off);
-	wkst &= ~ignore_bits;
+	wkst &= wkst_mask;
 	if (wkst) {
 		iclk = omap2_cm_read_mod_reg(module, iclk_off);
 		fclk = omap2_cm_read_mod_reg(module, fclk_off);
@@ -254,7 +254,7 @@ int omap3xxx_prm_clear_mod_irqs(s16 module, u8 regs, u32 ignore_bits)
 			omap2_cm_set_mod_reg_bits(clken, module, fclk_off);
 			omap2_prm_write_mod_reg(wkst, module, wkst_off);
 			wkst = omap2_prm_read_mod_reg(module, wkst_off);
-			wkst &= ~ignore_bits;
+			wkst &= wkst_mask;
 			c++;
 		}
 		omap2_cm_write_mod_reg(iclk, module, iclk_off);

commit 444d2d33d8564f95df851ddaca80f640ca36934d
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Feb 18 21:19:56 2015 +0100

    ARM: make of_device_ids const
    
    of_device_ids (i.e. compatible strings and the respective data) are not
    supposed to change at runtime. All functions working with of_device_ids
    provided by <linux/of.h> work with const of_device_ids. So mark the
    non-const structs in arch/arm as const, too.
    
    While at it also add some __initconst annotations.
    
    Acked-by: Jason Cooper <jason@lakedameon.net>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index c5e00c6714b1..5713bbdf83bc 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -674,7 +674,7 @@ int __init omap3xxx_prm_init(void)
 	return prm_register(&omap3xxx_prm_ll_data);
 }
 
-static struct of_device_id omap3_prm_dt_match_table[] = {
+static const struct of_device_id omap3_prm_dt_match_table[] = {
 	{ .compatible = "ti,omap3-prm" },
 	{ }
 };

commit 61c8621e2bd14faad9b89ab2284955b28000bcd5
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:26 2014 -0700

    ARM: OMAP2+: PRM: provide generic API for system reset
    
    This patch combines the various prm_warm_reset calls under a common
    API prm_reset_system, and adds the SoC specific implementation under
    prm_ll_data.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 9da15e9db6d2..c5e00c6714b1 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -136,7 +136,7 @@ u32 omap3_prm_vcvp_rmw(u32 mask, u32 bits, u8 offset)
  * recommended way to restart the SoC, considering Errata i520.  No
  * return value.
  */
-void omap3xxx_prm_dpll3_reset(void)
+static void omap3xxx_prm_dpll3_reset(void)
 {
 	omap2_prm_set_mod_reg_bits(OMAP_RST_DPLL3_MASK, OMAP3430_GR_MOD,
 				   OMAP2_RM_RSTCTRL);
@@ -663,6 +663,7 @@ static struct prm_ll_data omap3xxx_prm_ll_data = {
 	.assert_hardreset = &omap2_prm_assert_hardreset,
 	.deassert_hardreset = &omap2_prm_deassert_hardreset,
 	.is_hardreset_asserted = &omap2_prm_is_hardreset_asserted,
+	.reset_system = &omap3xxx_prm_dpll3_reset,
 };
 
 int __init omap3xxx_prm_init(void)

commit 4984eeaf71f033d1ca6b644e4fcdef4b3e6a97b4
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:26 2014 -0700

    ARM: OMAP3+: PRM: add generic API for reconfiguring I/O chain
    
    This adds a generic API for reconfiguring the I/O chain. The implementation
    will call the SoC specific function registered during init time. The SoC
    specific reconfigure functions are also made static, as they don't need
    to be accessed outside the PRM driver itself.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    [tony@atomide.com: updated for recent omap3 prcm fixes]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index cb71354c503c..9da15e9db6d2 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -380,7 +380,7 @@ void __init omap3_prm_init_pm(bool has_uart4, bool has_iva)
  * The ST_IO_CHAIN bit does not exist in 3430 before es3.1. The only
  * thing we can do is toggle EN_IO bit for earlier omaps.
  */
-void omap3430_pre_es3_1_reconfigure_io_chain(void)
+static void omap3430_pre_es3_1_reconfigure_io_chain(void)
 {
 	omap2_prm_clear_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD,
 				     PM_WKEN);
@@ -398,7 +398,7 @@ void omap3430_pre_es3_1_reconfigure_io_chain(void)
  * deasserting WUCLKIN and clearing the ST_IO_CHAIN WKST bit.  No
  * return value. These registers are only available in 3430 es3.1 and later.
  */
-void omap3_prm_reconfigure_io_chain(void)
+static void omap3_prm_reconfigure_io_chain(void)
 {
 	int i = 0;
 
@@ -420,15 +420,6 @@ void omap3_prm_reconfigure_io_chain(void)
 	omap2_prm_read_mod_reg(WKUP_MOD, PM_WKST);
 }
 
-/**
- * omap3xxx_prm_reconfigure_io_chain - reconfigure I/O chain
- */
-void omap3xxx_prm_reconfigure_io_chain(void)
-{
-	if (omap3_prcm_irq_setup.reconfigure_io_chain)
-		omap3_prcm_irq_setup.reconfigure_io_chain();
-}
-
 /**
  * omap3xxx_prm_enable_io_wakeup - enable wakeup events from I/O wakeup latches
  *

commit c8e069d7a6a7963b44264a3c9e80aa4d13fd3093
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:26 2014 -0700

    ARM: OMAP3: PRM: make PRCM interrupt handler related functions static
    
    These are not needed outside the PRM driver, so make them static and
    remove the prototypes from the public header.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 956e0ca2fb64..cb71354c503c 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -30,6 +30,11 @@
 #include "cm3xxx.h"
 #include "cm-regbits-34xx.h"
 
+static void omap3xxx_prm_read_pending_irqs(unsigned long *events);
+static void omap3xxx_prm_ocp_barrier(void);
+static void omap3xxx_prm_save_and_clear_irqen(u32 *saved_mask);
+static void omap3xxx_prm_restore_irqen(u32 *saved_mask);
+
 static const struct omap_prcm_irq omap3_prcm_irqs[] = {
 	OMAP_PRCM_IRQ("wkup",	0,	0),
 	OMAP_PRCM_IRQ("io",	9,	1),
@@ -147,7 +152,7 @@ void omap3xxx_prm_dpll3_reset(void)
  * MPU IRQs, and store the result into the u32 pointed to by @events.
  * No return value.
  */
-void omap3xxx_prm_read_pending_irqs(unsigned long *events)
+static void omap3xxx_prm_read_pending_irqs(unsigned long *events)
 {
 	u32 mask, st;
 
@@ -166,7 +171,7 @@ void omap3xxx_prm_read_pending_irqs(unsigned long *events)
  * block, to avoid race conditions after acknowledging or clearing IRQ
  * bits.  No return value.
  */
-void omap3xxx_prm_ocp_barrier(void)
+static void omap3xxx_prm_ocp_barrier(void)
 {
 	omap2_prm_read_mod_reg(OCP_MOD, OMAP3_PRM_REVISION_OFFSET);
 }
@@ -182,7 +187,7 @@ void omap3xxx_prm_ocp_barrier(void)
  * returning; otherwise, spurious interrupts might occur.  No return
  * value.
  */
-void omap3xxx_prm_save_and_clear_irqen(u32 *saved_mask)
+static void omap3xxx_prm_save_and_clear_irqen(u32 *saved_mask)
 {
 	saved_mask[0] = omap2_prm_read_mod_reg(OCP_MOD,
 					       OMAP3_PRM_IRQENABLE_MPU_OFFSET);
@@ -202,7 +207,7 @@ void omap3xxx_prm_save_and_clear_irqen(u32 *saved_mask)
  * barrier should be needed here; any pending PRM interrupts will fire
  * once the writes reach the PRM.  No return value.
  */
-void omap3xxx_prm_restore_irqen(u32 *saved_mask)
+static void omap3xxx_prm_restore_irqen(u32 *saved_mask)
 {
 	omap2_prm_write_mod_reg(saved_mask[0], OCP_MOD,
 				OMAP3_PRM_IRQENABLE_MPU_OFFSET);

commit 1bc28b3472dc44e6282b464fdb851adcea859be7
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:25 2014 -0700

    ARM: OMAP2+: PRM: add generic API for checking hardreset status
    
    PRM driver now has a generic API for checking hardreset status. SoC
    specific support functions are registered through the prm_ll_data.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 7298311c9ab7..956e0ca2fb64 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -666,6 +666,7 @@ static struct prm_ll_data omap3xxx_prm_ll_data = {
 	.late_init = &omap3xxx_prm_late_init,
 	.assert_hardreset = &omap2_prm_assert_hardreset,
 	.deassert_hardreset = &omap2_prm_deassert_hardreset,
+	.is_hardreset_asserted = &omap2_prm_is_hardreset_asserted,
 };
 
 int __init omap3xxx_prm_init(void)

commit 37fb59d7e0b471f3aacd26bfdbb64a4dc71f189b
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:25 2014 -0700

    ARM: OMAP2+: PRM: add generic API for deasserting hardware reset
    
    PRM driver now has a generic API for deasserting hardware resets. SoC
    specific support functions are registered through the prm_ll_data.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 8d9a7d49d6dc..7298311c9ab7 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -665,6 +665,7 @@ static struct prm_ll_data omap3xxx_prm_ll_data = {
 	.read_reset_sources = &omap3xxx_prm_read_reset_sources,
 	.late_init = &omap3xxx_prm_late_init,
 	.assert_hardreset = &omap2_prm_assert_hardreset,
+	.deassert_hardreset = &omap2_prm_deassert_hardreset,
 };
 
 int __init omap3xxx_prm_init(void)

commit efd44dc35f550e0cedd983d13e180da5e0d368a9
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:24 2014 -0700

    ARM: OMAP2+: PRM: add generic API for asserting hardware reset
    
    PRM driver now has a generic API for asserting hardware resets. SoC
    specific support functions are registered through the prm_ll_data.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index ff08da385a2d..8d9a7d49d6dc 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -664,6 +664,7 @@ static int omap3xxx_prm_late_init(void);
 static struct prm_ll_data omap3xxx_prm_ll_data = {
 	.read_reset_sources = &omap3xxx_prm_read_reset_sources,
 	.late_init = &omap3xxx_prm_late_init,
+	.assert_hardreset = &omap2_prm_assert_hardreset,
 };
 
 int __init omap3xxx_prm_init(void)

commit cf377ad7d42c566356d79049536d9cb37499cb77
Merge: 212fe84a6f21 d8f0faa339b0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 8 17:13:04 2014 -0400

    Merge tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform changes from Arnd Bergmann:
     "New and updated SoC support.  Among the things new for this release
      are:
    
       - at91: Added support for the new SAMA5D4 SoC, following the earlier
         SAMA5D3
       - bcm: Added support for BCM63XX family of DSL SoCs
       - hisi: Added support for HiP04 server-class SoC
       - meson: Initial support for the Amlogic Meson6 (aka 8726MX) platform
       - shmobile: added support for new r8a7794 (R-Car E2) automotive SoC
    
      Noteworthy changes to existing SoC support are:
    
       - imx: convert i.MX1 to device tree
       - omap: lots of power management work
       - omap: base support to enable moving to standard UART driver
       - shmobile: lots of progress for multiplatform support, still
         ongoing"
    
    * tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (171 commits)
      ARM: hisi: depend on ARCH_MULTI_V7
      CNS3xxx: Fix debug UART.
      ARM: at91: fix nommu build regression
      ARM: meson: add basic support for MesonX SoCs
      ARM: meson: debug: add debug UART for earlyprintk support
      irq: Export handle_fasteoi_irq
      ARM: mediatek: Add earlyprintk support for mt6589
      ARM: hisi: Fix platmcpm compilation when ARMv6 is selected
      ARM: debug: fix alphanumerical order on debug uarts
      ARM: at91: document Atmel SMART compatibles
      ARM: at91: add sama5d4 support to sama5_defconfig
      ARM: at91: dt: add device tree file for SAMA5D4ek board
      ARM: at91: dt: add device tree file for SAMA5D4 SoC
      ARM: at91: SAMA5D4 SoC detection code and low level routines
      ARM: at91: introduce basic SAMA5D4 support
      clk: at91: add a driver for the h32mx clock
      ARM: pxa3xx: provide specific platform_devices for all ssp ports
      ARM: pxa: ssp: provide platform_device_id for PXA3xx
      ARM: OMAP4+: Remove static iotable mappings for SRAM
      ARM: OMAP4+: Move SRAM data to DT
      ...

commit 7db143b89137de06ed289cf8b302f3bbbc5baa1f
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Sep 16 15:09:44 2014 -0700

    ARM: OMAP3: Fix I/O chain clock line assertion timed out error
    
    We are getting "PRM: I/O chain clock line assertion timed out" errors
    on early omaps for device tree based booting. This is because we are
    unconditionally calling reconfigure_io_chain while legacy booting
    has omap3_has_io_chain_ctrl() checks in place in omap_hwmod.c.
    
    For device tree based booting, we are calling reconfigure_io_chain
    unconditionally from pinctrl framework. So we need to add a check for
    omap3_has_io_chain_ctrl() to avoid the errors for trying to access
    a register that does not exist.
    
    For es3.0, the documentation in "4.11.2 Device Off-Mode Configuration"
    just mentions PM_WKEN_WKUP[8] bit. For es3.1, there's a new chapter in
    documentation for "4.11.2.2 I/O Wake-Up Mechanism" that describes the
    PM_WKEN_WKUP[16] ST_IO_CHAIN bit. So PM_WKEN_WKUP[16] bit did not get
    added until in es3.1 probaly to fix issues with flakey wake-up events.
    
    We are doing proper checks for ST_IO_CHAIN already in id.c and with
    omap3_has_io_chain_ctrl(). For more information, see also commit
    b02b917211d5 ("ARM: OMAP3: PM: fix I/O wakeup and I/O chain clock
    control detection").
    
    Let's fix the issue by selecting the right function during init for
    reconfigure_io_chain depending on the omap revision. For es3.0 and
    earlier we need to just toggle EN_IO. By doing this, we can move the
    check for omap3_has_io_chain_ctrl() from omap_hwmod.c to the init code
    in prm_3xxx.c. And then we can unconditionally call reconfigure_io_chain.
    
    Thanks to Paul Walmsley and Nishanth Menon for help with debugging the
    issue.
    
    Fixes: 30a69ef785e8 ("ARM: OMAP: Move DT wake-up event handling over to use pinctrl-single-omap")
    Cc: Kevin Hilman <khilman@kernel.org>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Reviewed-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 2458be6fc67b..372de3edf4a5 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -45,7 +45,7 @@ static struct omap_prcm_irq_setup omap3_prcm_irq_setup = {
 	.ocp_barrier		= &omap3xxx_prm_ocp_barrier,
 	.save_and_clear_irqen	= &omap3xxx_prm_save_and_clear_irqen,
 	.restore_irqen		= &omap3xxx_prm_restore_irqen,
-	.reconfigure_io_chain	= &omap3xxx_prm_reconfigure_io_chain,
+	.reconfigure_io_chain	= NULL,
 };
 
 /*
@@ -369,15 +369,30 @@ void __init omap3_prm_init_pm(bool has_uart4, bool has_iva)
 }
 
 /**
- * omap3xxx_prm_reconfigure_io_chain - clear latches and reconfigure I/O chain
+ * omap3430_pre_es3_1_reconfigure_io_chain - restart wake-up daisy chain
+ *
+ * The ST_IO_CHAIN bit does not exist in 3430 before es3.1. The only
+ * thing we can do is toggle EN_IO bit for earlier omaps.
+ */
+void omap3430_pre_es3_1_reconfigure_io_chain(void)
+{
+	omap2_prm_clear_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD,
+				     PM_WKEN);
+	omap2_prm_set_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD,
+				   PM_WKEN);
+	omap2_prm_read_mod_reg(WKUP_MOD, PM_WKEN);
+}
+
+/**
+ * omap3_prm_reconfigure_io_chain - clear latches and reconfigure I/O chain
  *
  * Clear any previously-latched I/O wakeup events and ensure that the
  * I/O wakeup gates are aligned with the current mux settings.  Works
  * by asserting WUCLKIN, waiting for WUCLKOUT to be asserted, and then
  * deasserting WUCLKIN and clearing the ST_IO_CHAIN WKST bit.  No
- * return value.
+ * return value. These registers are only available in 3430 es3.1 and later.
  */
-void omap3xxx_prm_reconfigure_io_chain(void)
+void omap3_prm_reconfigure_io_chain(void)
 {
 	int i = 0;
 
@@ -399,6 +414,15 @@ void omap3xxx_prm_reconfigure_io_chain(void)
 	omap2_prm_read_mod_reg(WKUP_MOD, PM_WKST);
 }
 
+/**
+ * omap3xxx_prm_reconfigure_io_chain - reconfigure I/O chain
+ */
+void omap3xxx_prm_reconfigure_io_chain(void)
+{
+	if (omap3_prcm_irq_setup.reconfigure_io_chain)
+		omap3_prcm_irq_setup.reconfigure_io_chain();
+}
+
 /**
  * omap3xxx_prm_enable_io_wakeup - enable wakeup events from I/O wakeup latches
  *
@@ -656,6 +680,13 @@ static int omap3xxx_prm_late_init(void)
 	if (!(prm_features & PRM_HAS_IO_WAKEUP))
 		return 0;
 
+	if (omap3_has_io_chain_ctrl())
+		omap3_prcm_irq_setup.reconfigure_io_chain =
+			omap3_prm_reconfigure_io_chain;
+	else
+		omap3_prcm_irq_setup.reconfigure_io_chain =
+			omap3430_pre_es3_1_reconfigure_io_chain;
+
 	omap3xxx_prm_enable_io_wakeup();
 	ret = omap_prcm_register_chain_handler(&omap3_prcm_irq_setup);
 	if (!ret)

commit 1e037794f7f00ff464db446ace892dae84175a6a
Author: Nishanth Menon <nm@ti.com>
Date:   Tue Aug 12 07:05:19 2014 -0500

    ARM: OMAP3+: PRM: register interrupt information from DT
    
    Allow the PRM interrupt information to be picked up from device tree.
    OMAP3 may use legacy boot and needs to be compatible with old dtbs
    (without interrupt populated), for these, we use the value which is
    pre-populated.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 2458be6fc67b..e0088e0508f8 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -17,6 +17,7 @@
 #include <linux/err.h>
 #include <linux/io.h>
 #include <linux/irq.h>
+#include <linux/of_irq.h>
 
 #include "soc.h"
 #include "common.h"
@@ -649,6 +650,11 @@ int __init omap3xxx_prm_init(void)
 	return prm_register(&omap3xxx_prm_ll_data);
 }
 
+static struct of_device_id omap3_prm_dt_match_table[] = {
+	{ .compatible = "ti,omap3-prm" },
+	{ }
+};
+
 static int omap3xxx_prm_late_init(void)
 {
 	int ret;
@@ -656,6 +662,18 @@ static int omap3xxx_prm_late_init(void)
 	if (!(prm_features & PRM_HAS_IO_WAKEUP))
 		return 0;
 
+	if (of_have_populated_dt()) {
+		struct device_node *np;
+		int irq_num;
+
+		np = of_find_matching_node(NULL, omap3_prm_dt_match_table);
+		if (np) {
+			irq_num = of_irq_get(np, 0);
+			if (irq_num >= 0)
+				omap3_prcm_irq_setup.irq = irq_num;
+		}
+	}
+
 	omap3xxx_prm_enable_io_wakeup();
 	ret = omap_prcm_register_chain_handler(&omap3_prcm_irq_setup);
 	if (!ret)

commit ba12c24286296159a1271eb19f2fc5c2ef59fbde
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Mar 4 17:43:04 2014 +0200

    ARM: OMAP3: control: isolate control module init to its own function
    
    Control module related PM initializations are now moved within control
    module driver. Done in preparation to isolate the code to its own driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 75dfe8efdfe0..2458be6fc67b 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -28,7 +28,6 @@
 #include "prm-regbits-34xx.h"
 #include "cm3xxx.h"
 #include "cm-regbits-34xx.h"
-#include "control.h"
 
 static const struct omap_prcm_irq omap3_prcm_irqs[] = {
 	OMAP_PRCM_IRQ("wkup",	0,	0),
@@ -366,8 +365,6 @@ void __init omap3_prm_init_pm(bool has_uart4, bool has_iva)
 	/* We need to idle iva2_pwrdm even on am3703 with no iva2. */
 	omap3xxx_prm_iva_idle();
 
-	omap3_ctrl_setup_d2d_padconf();
-
 	omap3_prm_reset_modem();
 }
 
@@ -470,9 +467,6 @@ void omap3xxx_prm_iva_idle(void)
 	omap2_cm_write_mod_reg(OMAP3430_CM_FCLKEN_IVA2_EN_IVA2_MASK,
 			       OMAP3430_IVA2_MOD, CM_FCLKEN);
 
-	/* Set IVA2 boot mode to 'idle' */
-	omap3_ctrl_set_iva_bootmode_idle();
-
 	/* Un-reset IVA2 */
 	omap2_prm_write_mod_reg(0, OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);
 

commit c2148e5930cdd2dd964e18fb7057c1e07f63c363
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Mar 4 17:24:21 2014 +0200

    ARM: OMAP3: PRM: move modem reset and iva2 idle to PRM driver
    
    Done in preparation to move PRM into its own driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 48218a450cb0..75dfe8efdfe0 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -362,6 +362,13 @@ void __init omap3_prm_init_pm(bool has_uart4, bool has_iva)
 
 	/* Clear any pending PRCM interrupts */
 	omap2_prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
+
+	/* We need to idle iva2_pwrdm even on am3703 with no iva2. */
+	omap3xxx_prm_iva_idle();
+
+	omap3_ctrl_setup_d2d_padconf();
+
+	omap3_prm_reset_modem();
 }
 
 /**

commit c5180a2b3e26d9b82277986f830c89a50103e65a
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Feb 26 17:30:43 2014 +0200

    ARM: OMAP3: PRM: move PRM init code from PM core to the driver
    
    Helps to isolate the PRM driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 4d93b844bcc4..48218a450cb0 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -274,6 +274,96 @@ void __init omap3_prm_reset_modem(void)
 	omap2_prm_write_mod_reg(0, CORE_MOD, OMAP2_RM_RSTCTRL);
 }
 
+/**
+ * omap3_prm_init_pm - initialize PM related registers for PRM
+ * @has_uart4: SoC has UART4
+ * @has_iva: SoC has IVA
+ *
+ * Initializes PRM registers for PM use. Called from PM init.
+ */
+void __init omap3_prm_init_pm(bool has_uart4, bool has_iva)
+{
+	u32 en_uart4_mask;
+	u32 grpsel_uart4_mask;
+
+	/*
+	 * Enable control of expternal oscillator through
+	 * sys_clkreq. In the long run clock framework should
+	 * take care of this.
+	 */
+	omap2_prm_rmw_mod_reg_bits(OMAP_AUTOEXTCLKMODE_MASK,
+				   1 << OMAP_AUTOEXTCLKMODE_SHIFT,
+				   OMAP3430_GR_MOD,
+				   OMAP3_PRM_CLKSRC_CTRL_OFFSET);
+
+	/* setup wakup source */
+	omap2_prm_write_mod_reg(OMAP3430_EN_IO_MASK | OMAP3430_EN_GPIO1_MASK |
+				OMAP3430_EN_GPT1_MASK | OMAP3430_EN_GPT12_MASK,
+				WKUP_MOD, PM_WKEN);
+	/* No need to write EN_IO, that is always enabled */
+	omap2_prm_write_mod_reg(OMAP3430_GRPSEL_GPIO1_MASK |
+				OMAP3430_GRPSEL_GPT1_MASK |
+				OMAP3430_GRPSEL_GPT12_MASK,
+				WKUP_MOD, OMAP3430_PM_MPUGRPSEL);
+
+	/* Enable PM_WKEN to support DSS LPR */
+	omap2_prm_write_mod_reg(OMAP3430_PM_WKEN_DSS_EN_DSS_MASK,
+				OMAP3430_DSS_MOD, PM_WKEN);
+
+	if (has_uart4) {
+		en_uart4_mask = OMAP3630_EN_UART4_MASK;
+		grpsel_uart4_mask = OMAP3630_GRPSEL_UART4_MASK;
+	}
+
+	/* Enable wakeups in PER */
+	omap2_prm_write_mod_reg(en_uart4_mask |
+				OMAP3430_EN_GPIO2_MASK |
+				OMAP3430_EN_GPIO3_MASK |
+				OMAP3430_EN_GPIO4_MASK |
+				OMAP3430_EN_GPIO5_MASK |
+				OMAP3430_EN_GPIO6_MASK |
+				OMAP3430_EN_UART3_MASK |
+				OMAP3430_EN_MCBSP2_MASK |
+				OMAP3430_EN_MCBSP3_MASK |
+				OMAP3430_EN_MCBSP4_MASK,
+				OMAP3430_PER_MOD, PM_WKEN);
+
+	/* and allow them to wake up MPU */
+	omap2_prm_write_mod_reg(grpsel_uart4_mask |
+				OMAP3430_GRPSEL_GPIO2_MASK |
+				OMAP3430_GRPSEL_GPIO3_MASK |
+				OMAP3430_GRPSEL_GPIO4_MASK |
+				OMAP3430_GRPSEL_GPIO5_MASK |
+				OMAP3430_GRPSEL_GPIO6_MASK |
+				OMAP3430_GRPSEL_UART3_MASK |
+				OMAP3430_GRPSEL_MCBSP2_MASK |
+				OMAP3430_GRPSEL_MCBSP3_MASK |
+				OMAP3430_GRPSEL_MCBSP4_MASK,
+				OMAP3430_PER_MOD, OMAP3430_PM_MPUGRPSEL);
+
+	/* Don't attach IVA interrupts */
+	if (has_iva) {
+		omap2_prm_write_mod_reg(0, WKUP_MOD, OMAP3430_PM_IVAGRPSEL);
+		omap2_prm_write_mod_reg(0, CORE_MOD, OMAP3430_PM_IVAGRPSEL1);
+		omap2_prm_write_mod_reg(0, CORE_MOD, OMAP3430ES2_PM_IVAGRPSEL3);
+		omap2_prm_write_mod_reg(0, OMAP3430_PER_MOD,
+					OMAP3430_PM_IVAGRPSEL);
+	}
+
+	/* Clear any pending 'reset' flags */
+	omap2_prm_write_mod_reg(0xffffffff, MPU_MOD, OMAP2_RM_RSTST);
+	omap2_prm_write_mod_reg(0xffffffff, CORE_MOD, OMAP2_RM_RSTST);
+	omap2_prm_write_mod_reg(0xffffffff, OMAP3430_PER_MOD, OMAP2_RM_RSTST);
+	omap2_prm_write_mod_reg(0xffffffff, OMAP3430_EMU_MOD, OMAP2_RM_RSTST);
+	omap2_prm_write_mod_reg(0xffffffff, OMAP3430_NEON_MOD, OMAP2_RM_RSTST);
+	omap2_prm_write_mod_reg(0xffffffff, OMAP3430_DSS_MOD, OMAP2_RM_RSTST);
+	omap2_prm_write_mod_reg(0xffffffff, OMAP3430ES2_USBHOST_MOD,
+				OMAP2_RM_RSTST);
+
+	/* Clear any pending PRCM interrupts */
+	omap2_prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
+}
+
 /**
  * omap3xxx_prm_reconfigure_io_chain - clear latches and reconfigure I/O chain
  *

commit 7e28b465fdea3f0601a1c76e47c50d05c7c603e2
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Feb 26 12:00:16 2014 +0200

    ARM: OMAP3: PRM: add API for saving PRM scratchpad contents
    
    This isolates the PRM register access within the PRM driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 4733c28d9d64..4d93b844bcc4 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -409,6 +409,15 @@ int omap3xxx_prm_clear_global_cold_reset(void)
 	return 0;
 }
 
+void omap3_prm_save_scratchpad_contents(u32 *ptr)
+{
+	*ptr++ = omap2_prm_read_mod_reg(OMAP3430_GR_MOD,
+					OMAP3_PRM_CLKSRC_CTRL_OFFSET);
+
+	*ptr++ = omap2_prm_read_mod_reg(OMAP3430_GR_MOD,
+					OMAP3_PRM_CLKSEL_OFFSET);
+}
+
 /* Powerdomain low-level functions */
 
 static int omap3_pwrdm_set_next_pwrst(struct powerdomain *pwrdm, u8 pwrst)

commit 9efcea09b0b56488e46ab3a36fe8dbce9eded529
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Feb 26 11:54:29 2014 +0200

    ARM: OMAP3: PRM: add API for checking and clearing cold reset status
    
    This isolates the PRM register access within the PRM driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index e46ff7184c9d..4733c28d9d64 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -389,6 +389,26 @@ void omap3xxx_prm_iva_idle(void)
 				OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);
 }
 
+/**
+ * omap3xxx_prm_clear_global_cold_reset - checks the global cold reset status
+ *					  and clears it if asserted
+ *
+ * Checks if cold-reset has occurred and clears the status bit if yes. Returns
+ * 1 if cold-reset has occurred, 0 otherwise.
+ */
+int omap3xxx_prm_clear_global_cold_reset(void)
+{
+	if (omap2_prm_read_mod_reg(OMAP3430_GR_MOD, OMAP3_PRM_RSTST_OFFSET) &
+	    OMAP3430_GLOBAL_COLD_RST_MASK) {
+		omap2_prm_set_mod_reg_bits(OMAP3430_GLOBAL_COLD_RST_MASK,
+					   OMAP3430_GR_MOD,
+					   OMAP3_PRM_RSTST_OFFSET);
+		return 1;
+	}
+
+	return 0;
+}
+
 /* Powerdomain low-level functions */
 
 static int omap3_pwrdm_set_next_pwrst(struct powerdomain *pwrdm, u8 pwrst)

commit 55c6c3ad90f606d458d798b36f8ffca98c1894e0
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Mar 4 15:48:33 2014 +0200

    ARM: OMAP3: PRM: move modem reset to PRM driver
    
    This is a more proper isolation of the code. Done in preparation of making
    PRM an individual driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index a575b6964bf9..e46ff7184c9d 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -259,6 +259,21 @@ int omap3xxx_prm_clear_mod_irqs(s16 module, u8 regs, u32 ignore_bits)
 	return c;
 }
 
+/**
+ * omap3_prm_reset_modem - toggle reset signal for modem
+ *
+ * Toggles the reset signal to modem IP block. Required to allow
+ * OMAP3430 without stacked modem to idle properly.
+ */
+void __init omap3_prm_reset_modem(void)
+{
+	omap2_prm_write_mod_reg(
+		OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RSTPWRON_MASK |
+		OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RST_MASK,
+				CORE_MOD, OMAP2_RM_RSTCTRL);
+	omap2_prm_write_mod_reg(0, CORE_MOD, OMAP2_RM_RSTCTRL);
+}
+
 /**
  * omap3xxx_prm_reconfigure_io_chain - clear latches and reconfigure I/O chain
  *

commit 9de367fae0d9907e19d065e0381ecd3f4003e08f
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Feb 25 18:04:56 2014 +0200

    ARM: OMAP3: PRM: move iva reset to PRM driver
    
    This is a more proper isolation of the code. Done in preparation of making
    PRM an individual driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 014ba70d2dfb..a575b6964bf9 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -28,6 +28,7 @@
 #include "prm-regbits-34xx.h"
 #include "cm3xxx.h"
 #include "cm-regbits-34xx.h"
+#include "control.h"
 
 static const struct omap_prcm_irq omap3_prcm_irqs[] = {
 	OMAP_PRCM_IRQ("wkup",	0,	0),
@@ -329,6 +330,50 @@ static u32 omap3xxx_prm_read_reset_sources(void)
 	return r;
 }
 
+/**
+ * omap3xxx_prm_iva_idle - ensure IVA is in idle so it can be put into retention
+ *
+ * In cases where IVA2 is activated by bootcode, it may prevent
+ * full-chip retention or off-mode because it is not idle.  This
+ * function forces the IVA2 into idle state so it can go
+ * into retention/off and thus allow full-chip retention/off.
+ */
+void omap3xxx_prm_iva_idle(void)
+{
+	/* ensure IVA2 clock is disabled */
+	omap2_cm_write_mod_reg(0, OMAP3430_IVA2_MOD, CM_FCLKEN);
+
+	/* if no clock activity, nothing else to do */
+	if (!(omap2_cm_read_mod_reg(OMAP3430_IVA2_MOD, OMAP3430_CM_CLKSTST) &
+	      OMAP3430_CLKACTIVITY_IVA2_MASK))
+		return;
+
+	/* Reset IVA2 */
+	omap2_prm_write_mod_reg(OMAP3430_RST1_IVA2_MASK |
+				OMAP3430_RST2_IVA2_MASK |
+				OMAP3430_RST3_IVA2_MASK,
+				OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);
+
+	/* Enable IVA2 clock */
+	omap2_cm_write_mod_reg(OMAP3430_CM_FCLKEN_IVA2_EN_IVA2_MASK,
+			       OMAP3430_IVA2_MOD, CM_FCLKEN);
+
+	/* Set IVA2 boot mode to 'idle' */
+	omap3_ctrl_set_iva_bootmode_idle();
+
+	/* Un-reset IVA2 */
+	omap2_prm_write_mod_reg(0, OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);
+
+	/* Disable IVA2 clock */
+	omap2_cm_write_mod_reg(0, OMAP3430_IVA2_MOD, CM_FCLKEN);
+
+	/* Reset IVA2 */
+	omap2_prm_write_mod_reg(OMAP3430_RST1_IVA2_MASK |
+				OMAP3430_RST2_IVA2_MASK |
+				OMAP3430_RST3_IVA2_MASK,
+				OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);
+}
+
 /* Powerdomain low-level functions */
 
 static int omap3_pwrdm_set_next_pwrst(struct powerdomain *pwrdm, u8 pwrst)

commit 0efc0f6ec2d6c6497e401df171705c5762f5a061
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Feb 25 15:40:30 2014 +0200

    ARM: OMAP3: PRM: move prcm wakeup helper to prm driver
    
    Done in preparation to make the prm an individual driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 4bd7a2dca8af..014ba70d2dfb 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -26,6 +26,8 @@
 #include "prm2xxx_3xxx.h"
 #include "cm2xxx_3xxx.h"
 #include "prm-regbits-34xx.h"
+#include "cm3xxx.h"
+#include "cm-regbits-34xx.h"
 
 static const struct omap_prcm_irq omap3_prcm_irqs[] = {
 	OMAP_PRCM_IRQ("wkup",	0,	0),
@@ -205,6 +207,57 @@ void omap3xxx_prm_restore_irqen(u32 *saved_mask)
 				OMAP3_PRM_IRQENABLE_MPU_OFFSET);
 }
 
+/**
+ * omap3xxx_prm_clear_mod_irqs - clear wake-up events from PRCM interrupt
+ * @module: PRM module to clear wakeups from
+ * @regs: register set to clear, 1 or 3
+ * @ignore_bits: wakeup status bits to ignore
+ *
+ * The purpose of this function is to clear any wake-up events latched
+ * in the PRCM PM_WKST_x registers. It is possible that a wake-up event
+ * may occur whilst attempting to clear a PM_WKST_x register and thus
+ * set another bit in this register. A while loop is used to ensure
+ * that any peripheral wake-up events occurring while attempting to
+ * clear the PM_WKST_x are detected and cleared.
+ */
+int omap3xxx_prm_clear_mod_irqs(s16 module, u8 regs, u32 ignore_bits)
+{
+	u32 wkst, fclk, iclk, clken;
+	u16 wkst_off = (regs == 3) ? OMAP3430ES2_PM_WKST3 : PM_WKST1;
+	u16 fclk_off = (regs == 3) ? OMAP3430ES2_CM_FCLKEN3 : CM_FCLKEN1;
+	u16 iclk_off = (regs == 3) ? CM_ICLKEN3 : CM_ICLKEN1;
+	u16 grpsel_off = (regs == 3) ?
+		OMAP3430ES2_PM_MPUGRPSEL3 : OMAP3430_PM_MPUGRPSEL;
+	int c = 0;
+
+	wkst = omap2_prm_read_mod_reg(module, wkst_off);
+	wkst &= omap2_prm_read_mod_reg(module, grpsel_off);
+	wkst &= ~ignore_bits;
+	if (wkst) {
+		iclk = omap2_cm_read_mod_reg(module, iclk_off);
+		fclk = omap2_cm_read_mod_reg(module, fclk_off);
+		while (wkst) {
+			clken = wkst;
+			omap2_cm_set_mod_reg_bits(clken, module, iclk_off);
+			/*
+			 * For USBHOST, we don't know whether HOST1 or
+			 * HOST2 woke us up, so enable both f-clocks
+			 */
+			if (module == OMAP3430ES2_USBHOST_MOD)
+				clken |= 1 << OMAP3430ES2_EN_USBHOST2_SHIFT;
+			omap2_cm_set_mod_reg_bits(clken, module, fclk_off);
+			omap2_prm_write_mod_reg(wkst, module, wkst_off);
+			wkst = omap2_prm_read_mod_reg(module, wkst_off);
+			wkst &= ~ignore_bits;
+			c++;
+		}
+		omap2_cm_write_mod_reg(iclk, module, iclk_off);
+		omap2_cm_write_mod_reg(fclk, module, fclk_off);
+	}
+
+	return c;
+}
+
 /**
  * omap3xxx_prm_reconfigure_io_chain - clear latches and reconfigure I/O chain
  *

commit ea351c1603df0607b68eb4663b82ba7a70519d2e
Merge: be2d62844819 70fcebf1965b
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri May 16 15:26:22 2014 -0700

    Merge tag 'for-v3.16/prcm-cleanup-a' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into omap-for-v3.16/prcm
    
    Some OMAP PRCM cleanup patches.  These help prepare to convert the PRCM
    code into drivers.
    
    Basic build, boot, and PM test results are available here:
    
    http://www.pwsan.com/omap/testlogs/prcm-cleanup-v3.16/20140515213244/
    
    Conflicts:
            arch/arm/mach-omap2/cm3xxx.c
            arch/arm/mach-omap2/cm44xx.c
    
    Also fixed up new section mismatch warnings.

commit b550e47f5e9e74999f754371bdc79331d19f84a3
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Mar 31 18:15:45 2014 +0300

    ARM: OMAP3/4: PRM: add support of late_init call to prm_ll_ops
    
    SoC specific late_init call is now registered during PRM init, and will
    be called automatically by PRM core. This helps to get rid of some
    redundant initcalls and cpu_is_X checks from the PRM code.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 9c95ac21c5b3..4a792fd1363c 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -401,8 +401,11 @@ struct pwrdm_ops omap3_pwrdm_operations = {
  *
  */
 
+static int omap3xxx_prm_late_init(void);
+
 static struct prm_ll_data omap3xxx_prm_ll_data = {
 	.read_reset_sources = &omap3xxx_prm_read_reset_sources,
+	.late_init = &omap3xxx_prm_late_init,
 };
 
 int __init omap3xxx_prm_init(void)
@@ -417,9 +420,6 @@ static int __init omap3xxx_prm_late_init(void)
 {
 	int ret;
 
-	if (!cpu_is_omap34xx())
-		return 0;
-
 	if (!(prm_features & PRM_HAS_IO_WAKEUP))
 		return 0;
 
@@ -431,7 +431,6 @@ static int __init omap3xxx_prm_late_init(void)
 
 	return ret;
 }
-omap_subsys_initcall(omap3xxx_prm_late_init);
 
 static void __exit omap3xxx_prm_exit(void)
 {

commit 2541d15f16479fd56debe1ea55dee03c3886e33c
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Mar 31 18:15:44 2014 +0300

    ARM: OMAP3/OMAP4: PRM: add prm_features flags and add IO wakeup under it
    
    prm_features flag will contain SoC specific feature enabler flags. Initially
    IO wakeup is added under this. Helps to get rid of runtime cpu_is_X checks.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 2631b9f2b3d8..9c95ac21c5b3 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -247,7 +247,7 @@ void omap3xxx_prm_reconfigure_io_chain(void)
  */
 static void __init omap3xxx_prm_enable_io_wakeup(void)
 {
-	if (omap3_has_io_wakeup())
+	if (prm_features & PRM_HAS_IO_WAKEUP)
 		omap2_prm_set_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD,
 					   PM_WKEN);
 }
@@ -407,6 +407,9 @@ static struct prm_ll_data omap3xxx_prm_ll_data = {
 
 int __init omap3xxx_prm_init(void)
 {
+	if (omap3_has_io_wakeup())
+		prm_features |= PRM_HAS_IO_WAKEUP;
+
 	return prm_register(&omap3xxx_prm_ll_data);
 }
 
@@ -417,6 +420,9 @@ static int __init omap3xxx_prm_late_init(void)
 	if (!cpu_is_omap34xx())
 		return 0;
 
+	if (!(prm_features & PRM_HAS_IO_WAKEUP))
+		return 0;
+
 	omap3xxx_prm_enable_io_wakeup();
 	ret = omap_prcm_register_chain_handler(&omap3_prcm_irq_setup);
 	if (!ret)

commit 81243651ba25c4418af26c3c6f1aeabb41f734e0
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Mar 31 18:15:43 2014 +0300

    ARM: OMAP3/4: PRM: provide io chain reconfig function through irq setup
    
    This helps to make the PRM registration modular, and also gets rid of a
    cpu type check done later.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 4c89aa2f1e81..2631b9f2b3d8 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -43,6 +43,7 @@ static struct omap_prcm_irq_setup omap3_prcm_irq_setup = {
 	.ocp_barrier		= &omap3xxx_prm_ocp_barrier,
 	.save_and_clear_irqen	= &omap3xxx_prm_save_and_clear_irqen,
 	.restore_irqen		= &omap3xxx_prm_restore_irqen,
+	.reconfigure_io_chain	= &omap3xxx_prm_reconfigure_io_chain,
 };
 
 /*

commit d8871cd245ece932ced994457e044d0f68b0aab4
Author: Tero Kristo <t-kristo@ti.com>
Date:   Sun May 11 19:54:58 2014 -0600

    ARM: OMAP2+: PRM: remove unnecessary cpu_is_XXX calls from prm_init / exit
    
    Done in preparation to make PRM its own driver, as the cpu_is_XXX calls are
    not available outside mach-omap2 folder.
    
    The init functions are called only from cpu specific init chain, and thus
    don't need to double check against cpu type.
    
    The exit calls check against the data provided during init-time registration
    and thus don't need cpu check either.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    [paul@pwsan.com: updated to apply]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 7721990d2006..4c89aa2f1e81 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -406,9 +406,6 @@ static struct prm_ll_data omap3xxx_prm_ll_data = {
 
 int __init omap3xxx_prm_init(void)
 {
-	if (!cpu_is_omap34xx())
-		return 0;
-
 	return prm_register(&omap3xxx_prm_ll_data);
 }
 
@@ -431,11 +428,6 @@ omap_subsys_initcall(omap3xxx_prm_late_init);
 
 static void __exit omap3xxx_prm_exit(void)
 {
-	if (!cpu_is_omap34xx())
-		return;
-
-	/* Should never happen */
-	WARN(prm_unregister(&omap3xxx_prm_ll_data),
-	     "%s: prm_ll_data function pointer mismatch\n", __func__);
+	prm_unregister(&omap3xxx_prm_ll_data);
 }
 __exitcall(omap3xxx_prm_exit);

commit b76c8b19b082c3fc84725de0d3ba5ee1f571c0ae
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Jan 11 11:24:18 2013 -0800

    ARM: OMAP2+: Use omap initcalls
    
    This way the initcalls don't run on other SoCs on multiplatform
    kernels. Otherwise we'll get something like this when booting
    on vexpress:
    
    omap_hwmod: _ensure_mpu_hwmod_is_setup: MPU initiator hwmod mpu not yet registered
    ...
    WARNING: at arch/arm/mach-omap2/pm.c:82 _init_omap_device+0x74/0x94()
    _init_omap_device: could not find omap_hwmod for mpu
    ...
    omap-dma-engine omap-dma-engine: OMAP DMA engine driver
    ...
    
    Tested-by: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index e648bd55b072..7721990d2006 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -427,7 +427,7 @@ static int __init omap3xxx_prm_late_init(void)
 
 	return ret;
 }
-subsys_initcall(omap3xxx_prm_late_init);
+omap_subsys_initcall(omap3xxx_prm_late_init);
 
 static void __exit omap3xxx_prm_exit(void)
 {

commit 2cd1f483b8c80b2f6b032edddb18f4946f94c4fc
Merge: d1c3ed669a2d 7e7fff8254e3
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Jan 3 11:04:21 2013 -0800

    Merge tag 'omap-fixes-a2-for-v3.8-rc' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into omap-for-v3.8-rc2/fixes
    
    Some OMAP PRCM and sparse fixes against v3.8-rc1.  A basic set of test
    logs are available here:
    
        http://www.pwsan.com/omap/testlogs/prcm_fixes_b_3.8-rc/20130102120724/
    
    The 3730 Beagle XM here has an intermittent failure mounting SD root,
    but the suspicion right now is that this is due to a failing SD card,
    rather than any change introduced by these patches.
    
    This second version includes a few changes requested by Tony Lindgren.

commit 7e7fff8254e318cede06a1a8c55b0d86dd4d8c5b
Author: Paul Walmsley <paul@pwsan.com>
Date:   Fri Dec 28 02:10:44 2012 -0700

    ARM: OMAP2/3: PRM: fix bogus OMAP2xxx powerstate return values
    
    On OMAP2xxx chips, the register bitfields for the
    PM_PWSTCTRL_*.POWERSTATE and PM_PWSTST_*.LASTSTATEENTERED are
    different than those used on OMAP3/4.  The order is reversed.  So, for
    example, on OMAP2xxx, 0x0 indicates 'ON'; but on OMAP3/4, 0x0
    indicates 'OFF'.  Similarly, on OMAP2xxx, 0x3 indicates 'OFF', but on
    OMAP3/4, 0x3 indicates 'ON'.
    
    To fix this, we treat the OMAP3/4 values as the powerdomain API
    values, and create new low-level powerdomain functions for the
    OMAP2xxx chips which translate between the OMAP2xxx values and the
    OMAP3/4 values.
    
    Without this patch, the conversion of the OMAP2xxx PM code to the
    functional powerstate code results in a non-booting kernel.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index db198d058584..4d43474d7455 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -278,6 +278,28 @@ static u32 omap3xxx_prm_read_reset_sources(void)
 
 /* Powerdomain low-level functions */
 
+static int omap3_pwrdm_set_next_pwrst(struct powerdomain *pwrdm, u8 pwrst)
+{
+	omap2_prm_rmw_mod_reg_bits(OMAP_POWERSTATE_MASK,
+				   (pwrst << OMAP_POWERSTATE_SHIFT),
+				   pwrdm->prcm_offs, OMAP2_PM_PWSTCTRL);
+	return 0;
+}
+
+static int omap3_pwrdm_read_next_pwrst(struct powerdomain *pwrdm)
+{
+	return omap2_prm_read_mod_bits_shift(pwrdm->prcm_offs,
+					     OMAP2_PM_PWSTCTRL,
+					     OMAP_POWERSTATE_MASK);
+}
+
+static int omap3_pwrdm_read_pwrst(struct powerdomain *pwrdm)
+{
+	return omap2_prm_read_mod_bits_shift(pwrdm->prcm_offs,
+					     OMAP2_PM_PWSTST,
+					     OMAP_POWERSTATEST_MASK);
+}
+
 /* Applicable only for OMAP3. Not supported on OMAP2 */
 static int omap3_pwrdm_read_prev_pwrst(struct powerdomain *pwrdm)
 {
@@ -356,9 +378,9 @@ static int omap3_pwrdm_disable_hdwr_sar(struct powerdomain *pwrdm)
 }
 
 struct pwrdm_ops omap3_pwrdm_operations = {
-	.pwrdm_set_next_pwrst	= omap2_pwrdm_set_next_pwrst,
-	.pwrdm_read_next_pwrst	= omap2_pwrdm_read_next_pwrst,
-	.pwrdm_read_pwrst	= omap2_pwrdm_read_pwrst,
+	.pwrdm_set_next_pwrst	= omap3_pwrdm_set_next_pwrst,
+	.pwrdm_read_next_pwrst	= omap3_pwrdm_read_next_pwrst,
+	.pwrdm_read_pwrst	= omap3_pwrdm_read_pwrst,
 	.pwrdm_read_prev_pwrst	= omap3_pwrdm_read_prev_pwrst,
 	.pwrdm_set_logic_retst	= omap2_pwrdm_set_logic_retst,
 	.pwrdm_read_logic_pwrst	= omap3_pwrdm_read_logic_pwrst,

commit e8d3d47a98cd7184a86d58febc00b4ac47485332
Author: Tony Lindgren <tony@atomide.com>
Date:   Sun Dec 16 11:29:58 2012 -0800

    ARM: OMAP2+: Drop plat/cpu.h for omap2plus
    
    The cpu_is_omap macros are now local to arch/arm/mach-omap2
    in soc.h and plat/cpu.h can finally be dropped for omap2+.
    Thanks everybody for help with fixing the drivers.
    
    Note that we can now also remove the unused plat/cpu.h from
    smartreflex.c and isp.c as they will cause compile errors
    with ARCH_MULTIPLATFORM enabled.
    
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Acked-by: Jean Pihet <jean.pihet@newoldbits.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index db198d058584..39822aabcff3 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -18,9 +18,8 @@
 #include <linux/io.h>
 #include <linux/irq.h>
 
+#include "soc.h"
 #include "common.h"
-#include <plat/cpu.h>
-
 #include "vp.h"
 #include "powerdomain.h"
 #include "prm3xxx.h"

commit 63a293e0005eb86c76657256737a931add8acbdc
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Nov 21 16:15:16 2012 -0700

    ARM: OMAP2+: PRM: initialize some PRM functions early
    
    Some PRM functions will need to be called by the hwmod code early in
    kernel init.  To handle this, split the PRM initialization code into
    early and late phases.  The early init is handled via mach-omap2/io.c,
    while the late init is handled by subsys_initcall().
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index b86116cf0db9..db198d058584 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -383,27 +383,30 @@ static struct prm_ll_data omap3xxx_prm_ll_data = {
 	.read_reset_sources = &omap3xxx_prm_read_reset_sources,
 };
 
-static int __init omap3xxx_prm_init(void)
+int __init omap3xxx_prm_init(void)
+{
+	if (!cpu_is_omap34xx())
+		return 0;
+
+	return prm_register(&omap3xxx_prm_ll_data);
+}
+
+static int __init omap3xxx_prm_late_init(void)
 {
 	int ret;
 
 	if (!cpu_is_omap34xx())
 		return 0;
 
-	ret = prm_register(&omap3xxx_prm_ll_data);
-	if (ret)
-		return ret;
-
 	omap3xxx_prm_enable_io_wakeup();
 	ret = omap_prcm_register_chain_handler(&omap3_prcm_irq_setup);
 	if (!ret)
 		irq_set_status_flags(omap_prcm_event_to_irq("io"),
 				     IRQ_NOAUTOEN);
 
-
 	return ret;
 }
-subsys_initcall(omap3xxx_prm_init);
+subsys_initcall(omap3xxx_prm_late_init);
 
 static void __exit omap3xxx_prm_exit(void)
 {

commit b99db36cdf37decb1b5575c5f293d170cbbc53d6
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Oct 29 20:59:29 2012 -0600

    ARM: OMAP2+: PRCM: remove obsolete prcm.[ch]
    
    arch/arm/mach-omap2/prcm.c and arch/arm/plat-omap/include/plat/prcm.h
    are now completely unused and can be removed.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Vaibhav Hiremath <hvaibhav@ti.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 5435673ac9ce..b86116cf0db9 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -20,7 +20,6 @@
 
 #include "common.h"
 #include <plat/cpu.h>
-#include <plat/prcm.h>
 
 #include "vp.h"
 #include "powerdomain.h"

commit d08cce6a1d6952a7774e4b61066d469c16d47a11
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Oct 29 20:55:46 2012 -0600

    ARM: OMAP2/3: PRM: add SoC reset functions (using the CORE DPLL method)
    
    Add SoC reset functions into the PRM code.  These functions are based
    on code from mach-omap2/prcm.c.  They reset the SoC using the CORE DPLL
    reset method (as opposed to one of the other two or three chip reset
    methods).
    
    Adding them here will facilitate their removal from
    arch/arm/mach-omap2/prcm.c.  (prcm.c is deprecated.)
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Vaibhav Hiremath <hvaibhav@ti.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 1fea656b2ca8..5435673ac9ce 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -122,6 +122,21 @@ u32 omap3_prm_vcvp_rmw(u32 mask, u32 bits, u8 offset)
 	return omap2_prm_rmw_mod_reg_bits(mask, bits, OMAP3430_GR_MOD, offset);
 }
 
+/**
+ * omap3xxx_prm_dpll3_reset - use DPLL3 reset to reboot the OMAP SoC
+ *
+ * Set the DPLL3 reset bit, which should reboot the SoC.  This is the
+ * recommended way to restart the SoC, considering Errata i520.  No
+ * return value.
+ */
+void omap3xxx_prm_dpll3_reset(void)
+{
+	omap2_prm_set_mod_reg_bits(OMAP_RST_DPLL3_MASK, OMAP3430_GR_MOD,
+				   OMAP2_RM_RSTCTRL);
+	/* OCP barrier */
+	omap2_prm_read_mod_reg(OMAP3430_GR_MOD, OMAP2_RM_RSTCTRL);
+}
+
 /**
  * omap3xxx_prm_read_pending_irqs - read pending PRM MPU IRQs into @events
  * @events: ptr to a u32, preallocated by caller

commit 2bb2a5d30abb0dc99d074877bfad2056142c730b
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Oct 21 01:01:13 2012 -0600

    ARM: OMAP2+: PRM: create PRM reset source API for the watchdog timer driver
    
    The OMAP watchdog timer driver needs to determine what caused the SoC
    to reset for its GETBOOTSTATUS ioctl.  So, define a set of standard
    reset sources across OMAP SoCs.  For OMAP2xxx, 3xxx, and 4xxx SoCs,
    define mappings from the SoC-specific reset source register bits to
    the standardized reset source IDs.  Create SoC-specific PRM functions
    that read the appropriate per-SoC register and use the mapping to
    return the standardized reset bits.  Register the SoC-specific PRM
    functions with the common PRM code via prm_register().  Create a
    function in the common PRM code, prm_read_reset_sources(), that
    calls the SoC-specific function, registered during boot.
    
    This patch does not yet handle some SoCs, such as AM33xx.  Those SoCs
    were not handled by the code this will replace.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index e276ff270ac5..1fea656b2ca8 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -47,6 +47,27 @@ static struct omap_prcm_irq_setup omap3_prcm_irq_setup = {
 	.restore_irqen		= &omap3xxx_prm_restore_irqen,
 };
 
+/*
+ * omap3_prm_reset_src_map - map from bits in the PRM_RSTST hardware
+ *   register (which are specific to OMAP3xxx SoCs) to reset source ID
+ *   bit shifts (which is an OMAP SoC-independent enumeration)
+ */
+static struct prm_reset_src_map omap3xxx_prm_reset_src_map[] = {
+	{ OMAP3430_GLOBAL_COLD_RST_SHIFT, OMAP_GLOBAL_COLD_RST_SRC_ID_SHIFT },
+	{ OMAP3430_GLOBAL_SW_RST_SHIFT, OMAP_GLOBAL_WARM_RST_SRC_ID_SHIFT },
+	{ OMAP3430_SECURITY_VIOL_RST_SHIFT, OMAP_SECU_VIOL_RST_SRC_ID_SHIFT },
+	{ OMAP3430_MPU_WD_RST_SHIFT, OMAP_MPU_WD_RST_SRC_ID_SHIFT },
+	{ OMAP3430_SECURE_WD_RST_SHIFT, OMAP_MPU_WD_RST_SRC_ID_SHIFT },
+	{ OMAP3430_EXTERNAL_WARM_RST_SHIFT, OMAP_EXTWARM_RST_SRC_ID_SHIFT },
+	{ OMAP3430_VDD1_VOLTAGE_MANAGER_RST_SHIFT,
+	  OMAP_VDD_MPU_VM_RST_SRC_ID_SHIFT },
+	{ OMAP3430_VDD2_VOLTAGE_MANAGER_RST_SHIFT,
+	  OMAP_VDD_CORE_VM_RST_SRC_ID_SHIFT },
+	{ OMAP3430_ICEPICK_RST_SHIFT, OMAP_ICEPICK_RST_SRC_ID_SHIFT },
+	{ OMAP3430_ICECRUSHER_RST_SHIFT, OMAP_ICECRUSHER_RST_SRC_ID_SHIFT },
+	{ -1, -1 },
+};
+
 /* PRM VP */
 
 /*
@@ -217,6 +238,30 @@ static void __init omap3xxx_prm_enable_io_wakeup(void)
 					   PM_WKEN);
 }
 
+/**
+ * omap3xxx_prm_read_reset_sources - return the last SoC reset source
+ *
+ * Return a u32 representing the last reset sources of the SoC.  The
+ * returned reset source bits are standardized across OMAP SoCs.
+ */
+static u32 omap3xxx_prm_read_reset_sources(void)
+{
+	struct prm_reset_src_map *p;
+	u32 r = 0;
+	u32 v;
+
+	v = omap2_prm_read_mod_reg(WKUP_MOD, OMAP2_RM_RSTST);
+
+	p = omap3xxx_prm_reset_src_map;
+	while (p->reg_shift >= 0 && p->std_shift >= 0) {
+		if (v & (1 << p->reg_shift))
+			r |= 1 << p->std_shift;
+		p++;
+	}
+
+	return r;
+}
+
 /* Powerdomain low-level functions */
 
 /* Applicable only for OMAP3. Not supported on OMAP2 */
@@ -320,6 +365,10 @@ struct pwrdm_ops omap3_pwrdm_operations = {
  *
  */
 
+static struct prm_ll_data omap3xxx_prm_ll_data = {
+	.read_reset_sources = &omap3xxx_prm_read_reset_sources,
+};
+
 static int __init omap3xxx_prm_init(void)
 {
 	int ret;
@@ -327,12 +376,28 @@ static int __init omap3xxx_prm_init(void)
 	if (!cpu_is_omap34xx())
 		return 0;
 
+	ret = prm_register(&omap3xxx_prm_ll_data);
+	if (ret)
+		return ret;
+
 	omap3xxx_prm_enable_io_wakeup();
 	ret = omap_prcm_register_chain_handler(&omap3_prcm_irq_setup);
 	if (!ret)
 		irq_set_status_flags(omap_prcm_event_to_irq("io"),
 				     IRQ_NOAUTOEN);
 
+
 	return ret;
 }
 subsys_initcall(omap3xxx_prm_init);
+
+static void __exit omap3xxx_prm_exit(void)
+{
+	if (!cpu_is_omap34xx())
+		return;
+
+	/* Should never happen */
+	WARN(prm_unregister(&omap3xxx_prm_ll_data),
+	     "%s: prm_ll_data function pointer mismatch\n", __func__);
+}
+__exitcall(omap3xxx_prm_exit);

commit 498153995b9ff41279be54fc56facb92f5cad793
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Oct 21 01:01:10 2012 -0600

    ARM: OMAP2+: powerdomain/PRM: move the low-level powerdomain functions into PRM
    
    Move the low-level SoC-specific powerdomain control functions into
    prm*.c.  For example, OMAP2xxx low-level powerdomain functions go into
    prm2xxx.c.  Then remove the unnecessary powerdomain*xxx*.c files.
    
    The objective is to centralize low-level PRM register accesses into
    the prm*.[ch] files, and then to export an OMAP SoC-independent API to
    higher-level OMAP power management code.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Cc: Vaibhav Hiremath <hvaibhav@ti.com>
    Acked-by: Rajendra Nayak <rnayak@ti.com>
    Reviewed-by: Russ Dill <Russ.Dill@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
index 88f7d8de7da9..e276ff270ac5 100644
--- a/arch/arm/mach-omap2/prm3xxx.c
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -5,6 +5,7 @@
  * Copyright (C) 2010 Nokia Corporation
  * Benoît Cousson
  * Paul Walmsley
+ * Rajendra Nayak <rnayak@ti.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -22,8 +23,9 @@
 #include <plat/prcm.h>
 
 #include "vp.h"
-
+#include "powerdomain.h"
 #include "prm3xxx.h"
+#include "prm2xxx_3xxx.h"
 #include "cm2xxx_3xxx.h"
 #include "prm-regbits-34xx.h"
 
@@ -215,6 +217,109 @@ static void __init omap3xxx_prm_enable_io_wakeup(void)
 					   PM_WKEN);
 }
 
+/* Powerdomain low-level functions */
+
+/* Applicable only for OMAP3. Not supported on OMAP2 */
+static int omap3_pwrdm_read_prev_pwrst(struct powerdomain *pwrdm)
+{
+	return omap2_prm_read_mod_bits_shift(pwrdm->prcm_offs,
+					     OMAP3430_PM_PREPWSTST,
+					     OMAP3430_LASTPOWERSTATEENTERED_MASK);
+}
+
+static int omap3_pwrdm_read_logic_pwrst(struct powerdomain *pwrdm)
+{
+	return omap2_prm_read_mod_bits_shift(pwrdm->prcm_offs,
+					     OMAP2_PM_PWSTST,
+					     OMAP3430_LOGICSTATEST_MASK);
+}
+
+static int omap3_pwrdm_read_logic_retst(struct powerdomain *pwrdm)
+{
+	return omap2_prm_read_mod_bits_shift(pwrdm->prcm_offs,
+					     OMAP2_PM_PWSTCTRL,
+					     OMAP3430_LOGICSTATEST_MASK);
+}
+
+static int omap3_pwrdm_read_prev_logic_pwrst(struct powerdomain *pwrdm)
+{
+	return omap2_prm_read_mod_bits_shift(pwrdm->prcm_offs,
+					     OMAP3430_PM_PREPWSTST,
+					     OMAP3430_LASTLOGICSTATEENTERED_MASK);
+}
+
+static int omap3_get_mem_bank_lastmemst_mask(u8 bank)
+{
+	switch (bank) {
+	case 0:
+		return OMAP3430_LASTMEM1STATEENTERED_MASK;
+	case 1:
+		return OMAP3430_LASTMEM2STATEENTERED_MASK;
+	case 2:
+		return OMAP3430_LASTSHAREDL2CACHEFLATSTATEENTERED_MASK;
+	case 3:
+		return OMAP3430_LASTL2FLATMEMSTATEENTERED_MASK;
+	default:
+		WARN_ON(1); /* should never happen */
+		return -EEXIST;
+	}
+	return 0;
+}
+
+static int omap3_pwrdm_read_prev_mem_pwrst(struct powerdomain *pwrdm, u8 bank)
+{
+	u32 m;
+
+	m = omap3_get_mem_bank_lastmemst_mask(bank);
+
+	return omap2_prm_read_mod_bits_shift(pwrdm->prcm_offs,
+				OMAP3430_PM_PREPWSTST, m);
+}
+
+static int omap3_pwrdm_clear_all_prev_pwrst(struct powerdomain *pwrdm)
+{
+	omap2_prm_write_mod_reg(0, pwrdm->prcm_offs, OMAP3430_PM_PREPWSTST);
+	return 0;
+}
+
+static int omap3_pwrdm_enable_hdwr_sar(struct powerdomain *pwrdm)
+{
+	return omap2_prm_rmw_mod_reg_bits(0,
+					  1 << OMAP3430ES2_SAVEANDRESTORE_SHIFT,
+					  pwrdm->prcm_offs, OMAP2_PM_PWSTCTRL);
+}
+
+static int omap3_pwrdm_disable_hdwr_sar(struct powerdomain *pwrdm)
+{
+	return omap2_prm_rmw_mod_reg_bits(1 << OMAP3430ES2_SAVEANDRESTORE_SHIFT,
+					  0, pwrdm->prcm_offs,
+					  OMAP2_PM_PWSTCTRL);
+}
+
+struct pwrdm_ops omap3_pwrdm_operations = {
+	.pwrdm_set_next_pwrst	= omap2_pwrdm_set_next_pwrst,
+	.pwrdm_read_next_pwrst	= omap2_pwrdm_read_next_pwrst,
+	.pwrdm_read_pwrst	= omap2_pwrdm_read_pwrst,
+	.pwrdm_read_prev_pwrst	= omap3_pwrdm_read_prev_pwrst,
+	.pwrdm_set_logic_retst	= omap2_pwrdm_set_logic_retst,
+	.pwrdm_read_logic_pwrst	= omap3_pwrdm_read_logic_pwrst,
+	.pwrdm_read_logic_retst	= omap3_pwrdm_read_logic_retst,
+	.pwrdm_read_prev_logic_pwrst	= omap3_pwrdm_read_prev_logic_pwrst,
+	.pwrdm_set_mem_onst	= omap2_pwrdm_set_mem_onst,
+	.pwrdm_set_mem_retst	= omap2_pwrdm_set_mem_retst,
+	.pwrdm_read_mem_pwrst	= omap2_pwrdm_read_mem_pwrst,
+	.pwrdm_read_mem_retst	= omap2_pwrdm_read_mem_retst,
+	.pwrdm_read_prev_mem_pwrst	= omap3_pwrdm_read_prev_mem_pwrst,
+	.pwrdm_clear_all_prev_pwrst	= omap3_pwrdm_clear_all_prev_pwrst,
+	.pwrdm_enable_hdwr_sar	= omap3_pwrdm_enable_hdwr_sar,
+	.pwrdm_disable_hdwr_sar	= omap3_pwrdm_disable_hdwr_sar,
+	.pwrdm_wait_transition	= omap2_pwrdm_wait_transition,
+};
+
+/*
+ *
+ */
+
 static int __init omap3xxx_prm_init(void)
 {
 	int ret;

commit 139563ad27e7baad7935b8113940f0d804cf513b
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Oct 21 01:01:10 2012 -0600

    ARM: OMAP2+: PRM: split PRM functions into OMAP2, OMAP3-specific files
    
    Move OMAP3xxx-specific PRM functions & macros into prm3xxx.[ch] and
    OMAP2xxx-specific macros into prm2xxx.h.  (prm2xxx.c will be created
    by a subsequent patch when it's needed.)  Move basic PRM register
    access functions into static inline functions in prm2xxx_3xxx.h, leaving
    only OMAP2/3 hardreset functions in prm2xxx_3xxx.c.
    
    Also clarify the initcall function naming to reinforce that this code
    is specifically for the PRM IP block.
    
    This is in preparation for the upcoming powerdomain series and the
    upcoming move of this code to drivers/.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Reviewed-by: Russ Dill <Russ.Dill@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/prm3xxx.c b/arch/arm/mach-omap2/prm3xxx.c
new file mode 100644
index 000000000000..88f7d8de7da9
--- /dev/null
+++ b/arch/arm/mach-omap2/prm3xxx.c
@@ -0,0 +1,233 @@
+/*
+ * OMAP3xxx PRM module functions
+ *
+ * Copyright (C) 2010-2012 Texas Instruments, Inc.
+ * Copyright (C) 2010 Nokia Corporation
+ * Benoît Cousson
+ * Paul Walmsley
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+
+#include "common.h"
+#include <plat/cpu.h>
+#include <plat/prcm.h>
+
+#include "vp.h"
+
+#include "prm3xxx.h"
+#include "cm2xxx_3xxx.h"
+#include "prm-regbits-34xx.h"
+
+static const struct omap_prcm_irq omap3_prcm_irqs[] = {
+	OMAP_PRCM_IRQ("wkup",	0,	0),
+	OMAP_PRCM_IRQ("io",	9,	1),
+};
+
+static struct omap_prcm_irq_setup omap3_prcm_irq_setup = {
+	.ack			= OMAP3_PRM_IRQSTATUS_MPU_OFFSET,
+	.mask			= OMAP3_PRM_IRQENABLE_MPU_OFFSET,
+	.nr_regs		= 1,
+	.irqs			= omap3_prcm_irqs,
+	.nr_irqs		= ARRAY_SIZE(omap3_prcm_irqs),
+	.irq			= 11 + OMAP_INTC_START,
+	.read_pending_irqs	= &omap3xxx_prm_read_pending_irqs,
+	.ocp_barrier		= &omap3xxx_prm_ocp_barrier,
+	.save_and_clear_irqen	= &omap3xxx_prm_save_and_clear_irqen,
+	.restore_irqen		= &omap3xxx_prm_restore_irqen,
+};
+
+/* PRM VP */
+
+/*
+ * struct omap3_vp - OMAP3 VP register access description.
+ * @tranxdone_status: VP_TRANXDONE_ST bitmask in PRM_IRQSTATUS_MPU reg
+ */
+struct omap3_vp {
+	u32 tranxdone_status;
+};
+
+static struct omap3_vp omap3_vp[] = {
+	[OMAP3_VP_VDD_MPU_ID] = {
+		.tranxdone_status = OMAP3430_VP1_TRANXDONE_ST_MASK,
+	},
+	[OMAP3_VP_VDD_CORE_ID] = {
+		.tranxdone_status = OMAP3430_VP2_TRANXDONE_ST_MASK,
+	},
+};
+
+#define MAX_VP_ID ARRAY_SIZE(omap3_vp);
+
+u32 omap3_prm_vp_check_txdone(u8 vp_id)
+{
+	struct omap3_vp *vp = &omap3_vp[vp_id];
+	u32 irqstatus;
+
+	irqstatus = omap2_prm_read_mod_reg(OCP_MOD,
+					   OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
+	return irqstatus & vp->tranxdone_status;
+}
+
+void omap3_prm_vp_clear_txdone(u8 vp_id)
+{
+	struct omap3_vp *vp = &omap3_vp[vp_id];
+
+	omap2_prm_write_mod_reg(vp->tranxdone_status,
+				OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
+}
+
+u32 omap3_prm_vcvp_read(u8 offset)
+{
+	return omap2_prm_read_mod_reg(OMAP3430_GR_MOD, offset);
+}
+
+void omap3_prm_vcvp_write(u32 val, u8 offset)
+{
+	omap2_prm_write_mod_reg(val, OMAP3430_GR_MOD, offset);
+}
+
+u32 omap3_prm_vcvp_rmw(u32 mask, u32 bits, u8 offset)
+{
+	return omap2_prm_rmw_mod_reg_bits(mask, bits, OMAP3430_GR_MOD, offset);
+}
+
+/**
+ * omap3xxx_prm_read_pending_irqs - read pending PRM MPU IRQs into @events
+ * @events: ptr to a u32, preallocated by caller
+ *
+ * Read PRM_IRQSTATUS_MPU bits, AND'ed with the currently-enabled PRM
+ * MPU IRQs, and store the result into the u32 pointed to by @events.
+ * No return value.
+ */
+void omap3xxx_prm_read_pending_irqs(unsigned long *events)
+{
+	u32 mask, st;
+
+	/* XXX Can the mask read be avoided (e.g., can it come from RAM?) */
+	mask = omap2_prm_read_mod_reg(OCP_MOD, OMAP3_PRM_IRQENABLE_MPU_OFFSET);
+	st = omap2_prm_read_mod_reg(OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
+
+	events[0] = mask & st;
+}
+
+/**
+ * omap3xxx_prm_ocp_barrier - force buffered MPU writes to the PRM to complete
+ *
+ * Force any buffered writes to the PRM IP block to complete.  Needed
+ * by the PRM IRQ handler, which reads and writes directly to the IP
+ * block, to avoid race conditions after acknowledging or clearing IRQ
+ * bits.  No return value.
+ */
+void omap3xxx_prm_ocp_barrier(void)
+{
+	omap2_prm_read_mod_reg(OCP_MOD, OMAP3_PRM_REVISION_OFFSET);
+}
+
+/**
+ * omap3xxx_prm_save_and_clear_irqen - save/clear PRM_IRQENABLE_MPU reg
+ * @saved_mask: ptr to a u32 array to save IRQENABLE bits
+ *
+ * Save the PRM_IRQENABLE_MPU register to @saved_mask.  @saved_mask
+ * must be allocated by the caller.  Intended to be used in the PRM
+ * interrupt handler suspend callback.  The OCP barrier is needed to
+ * ensure the write to disable PRM interrupts reaches the PRM before
+ * returning; otherwise, spurious interrupts might occur.  No return
+ * value.
+ */
+void omap3xxx_prm_save_and_clear_irqen(u32 *saved_mask)
+{
+	saved_mask[0] = omap2_prm_read_mod_reg(OCP_MOD,
+					       OMAP3_PRM_IRQENABLE_MPU_OFFSET);
+	omap2_prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQENABLE_MPU_OFFSET);
+
+	/* OCP barrier */
+	omap2_prm_read_mod_reg(OCP_MOD, OMAP3_PRM_REVISION_OFFSET);
+}
+
+/**
+ * omap3xxx_prm_restore_irqen - set PRM_IRQENABLE_MPU register from args
+ * @saved_mask: ptr to a u32 array of IRQENABLE bits saved previously
+ *
+ * Restore the PRM_IRQENABLE_MPU register from @saved_mask.  Intended
+ * to be used in the PRM interrupt handler resume callback to restore
+ * values saved by omap3xxx_prm_save_and_clear_irqen().  No OCP
+ * barrier should be needed here; any pending PRM interrupts will fire
+ * once the writes reach the PRM.  No return value.
+ */
+void omap3xxx_prm_restore_irqen(u32 *saved_mask)
+{
+	omap2_prm_write_mod_reg(saved_mask[0], OCP_MOD,
+				OMAP3_PRM_IRQENABLE_MPU_OFFSET);
+}
+
+/**
+ * omap3xxx_prm_reconfigure_io_chain - clear latches and reconfigure I/O chain
+ *
+ * Clear any previously-latched I/O wakeup events and ensure that the
+ * I/O wakeup gates are aligned with the current mux settings.  Works
+ * by asserting WUCLKIN, waiting for WUCLKOUT to be asserted, and then
+ * deasserting WUCLKIN and clearing the ST_IO_CHAIN WKST bit.  No
+ * return value.
+ */
+void omap3xxx_prm_reconfigure_io_chain(void)
+{
+	int i = 0;
+
+	omap2_prm_set_mod_reg_bits(OMAP3430_EN_IO_CHAIN_MASK, WKUP_MOD,
+				   PM_WKEN);
+
+	omap_test_timeout(omap2_prm_read_mod_reg(WKUP_MOD, PM_WKST) &
+			  OMAP3430_ST_IO_CHAIN_MASK,
+			  MAX_IOPAD_LATCH_TIME, i);
+	if (i == MAX_IOPAD_LATCH_TIME)
+		pr_warn("PRM: I/O chain clock line assertion timed out\n");
+
+	omap2_prm_clear_mod_reg_bits(OMAP3430_EN_IO_CHAIN_MASK, WKUP_MOD,
+				     PM_WKEN);
+
+	omap2_prm_set_mod_reg_bits(OMAP3430_ST_IO_CHAIN_MASK, WKUP_MOD,
+				   PM_WKST);
+
+	omap2_prm_read_mod_reg(WKUP_MOD, PM_WKST);
+}
+
+/**
+ * omap3xxx_prm_enable_io_wakeup - enable wakeup events from I/O wakeup latches
+ *
+ * Activates the I/O wakeup event latches and allows events logged by
+ * those latches to signal a wakeup event to the PRCM.  For I/O
+ * wakeups to occur, WAKEUPENABLE bits must be set in the pad mux
+ * registers, and omap3xxx_prm_reconfigure_io_chain() must be called.
+ * No return value.
+ */
+static void __init omap3xxx_prm_enable_io_wakeup(void)
+{
+	if (omap3_has_io_wakeup())
+		omap2_prm_set_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD,
+					   PM_WKEN);
+}
+
+static int __init omap3xxx_prm_init(void)
+{
+	int ret;
+
+	if (!cpu_is_omap34xx())
+		return 0;
+
+	omap3xxx_prm_enable_io_wakeup();
+	ret = omap_prcm_register_chain_handler(&omap3_prcm_irq_setup);
+	if (!ret)
+		irq_set_status_flags(omap_prcm_event_to_irq("io"),
+				     IRQ_NOAUTOEN);
+
+	return ret;
+}
+subsys_initcall(omap3xxx_prm_init);
