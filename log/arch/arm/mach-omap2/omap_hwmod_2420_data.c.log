commit 64dbc3d55d60fd115e058e9f1689542daa37356c
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu May 7 09:59:31 2020 -0700

    ARM: dts: Configure system timers for omap2
    
    We can now init system timers using the dmtimer and 32k counter
    based on only devicetree data and drivers/clocksource timers.
    Let's configure the clocksource and clockevent, and drop the old
    unused platform data.
    
    As we're just dropping platform data, and the early platform data
    init is based on the custom ti,hwmods property, we want to drop
    both the platform data and ti,hwmods property in a single patch.
    
    Since the dmtimer can use both 32k clock and system clock as the
    source, let's also configure the SoC specific default values. The
    board specific dts files can reconfigure these with assigned-clocks
    and assigned-clock-parents as needed.
    
    Let's also update the dts file to use #include while at it.
    
    Cc: devicetree@vger.kernel.org
    Cc: Aaro Koskinen <aaro.koskinen@iki.fi>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Keerthy <j-keerthy@ti.com>
    Cc: Lokesh Vutla <lokeshvutla@ti.com>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index b14442cf6179..558fae4375ba 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -264,14 +264,6 @@ static struct omap_hwmod_ocp_if omap2420_l3__dsp = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* l4_wkup -> timer1 */
-static struct omap_hwmod_ocp_if omap2420_l4_wkup__timer1 = {
-	.master		= &omap2xxx_l4_wkup_hwmod,
-	.slave		= &omap2xxx_timer1_hwmod,
-	.clk		= "gpt1_ick",
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
 /* l4_wkup -> wd_timer2 */
 static struct omap_hwmod_ocp_if omap2420_l4_wkup__wd_timer2 = {
 	.master		= &omap2xxx_l4_wkup_hwmod,
@@ -352,15 +344,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__hdq1w = {
 	.flags		= OMAP_FIREWALL_L4 | OCPIF_SWSUP_IDLE,
 };
 
-
-/* l4_wkup -> 32ksync_counter */
-static struct omap_hwmod_ocp_if omap2420_l4_wkup__counter_32k = {
-	.master		= &omap2xxx_l4_wkup_hwmod,
-	.slave		= &omap2xxx_counter_32k_hwmod,
-	.clk		= "sync_32k_ick",
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
 static struct omap_hwmod_ocp_if omap2420_l3__gpmc = {
 	.master		= &omap2xxx_l3_main_hwmod,
 	.slave		= &omap2xxx_gpmc_hwmod,
@@ -382,8 +365,6 @@ static struct omap_hwmod_ocp_if *omap2420_hwmod_ocp_ifs[] __initdata = {
 	&omap2420_l4_core__i2c2,
 	&omap2420_l3__iva,
 	&omap2420_l3__dsp,
-	&omap2420_l4_wkup__timer1,
-	&omap2xxx_l4_core__timer2,
 	&omap2xxx_l4_core__timer3,
 	&omap2xxx_l4_core__timer4,
 	&omap2xxx_l4_core__timer5,
@@ -411,7 +392,6 @@ static struct omap_hwmod_ocp_if *omap2420_hwmod_ocp_ifs[] __initdata = {
 	&omap2xxx_l4_core__sham,
 	&omap2xxx_l4_core__aes,
 	&omap2420_l4_core__hdq1w,
-	&omap2420_l4_wkup__counter_32k,
 	&omap2420_l3__gpmc,
 	NULL,
 };

commit 37b156ecf71ab74f8e991562f8d13825aaf07512
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Dec 10 08:10:31 2019 -0800

    ARM: OMAP2+: Drop legacy platform data for sdma
    
    We can now probe devices with ti-sysc interconnect driver and dts
    data. Let's drop the related platform data and custom ti,hwmods
    dts property.
    
    As we're just dropping data, and the early platform data init
    is based on the custom ti,hwmods property, we want to drop both
    the platform data and ti,hwmods property in a single patch.
    
    Cc: Aaro Koskinen <aaro.koskinen@iki.fi>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Russell King <rmk+kernel@armlinux.org.uk>
    Cc: Vinod Koul <vkoul@kernel.org>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 6127314ee97b..b14442cf6179 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -11,7 +11,6 @@
  */
 
 #include <linux/platform_data/i2c-omap.h>
-#include <linux/omap-dma.h>
 
 #include "omap_hwmod.h"
 #include "l3_2xxx.h"
@@ -126,13 +125,6 @@ static struct omap_hwmod omap2420_i2c2_hwmod = {
 	.flags		= HWMOD_16BIT_REG,
 };
 
-static struct omap_hwmod omap2420_dma_system_hwmod = {
-	.name		= "dma",
-	.class		= &omap2xxx_dma_hwmod_class,
-	.main_clk	= "core_l3_ck",
-	.flags		= HWMOD_NO_IDLEST,
-};
-
 /* mailbox */
 static struct omap_hwmod omap2420_mailbox_hwmod = {
 	.name		= "mailbox",
@@ -320,22 +312,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio4 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* dma_system -> L3 */
-static struct omap_hwmod_ocp_if omap2420_dma_system__l3 = {
-	.master		= &omap2420_dma_system_hwmod,
-	.slave		= &omap2xxx_l3_main_hwmod,
-	.clk		= "core_l3_ck",
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4_core -> dma_system */
-static struct omap_hwmod_ocp_if omap2420_l4_core__dma_system = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2420_dma_system_hwmod,
-	.clk		= "sdma_ick",
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
 /* l4_core -> mailbox */
 static struct omap_hwmod_ocp_if omap2420_l4_core__mailbox = {
 	.master		= &omap2xxx_l4_core_hwmod,
@@ -427,8 +403,6 @@ static struct omap_hwmod_ocp_if *omap2420_hwmod_ocp_ifs[] __initdata = {
 	&omap2420_l4_wkup__gpio2,
 	&omap2420_l4_wkup__gpio3,
 	&omap2420_l4_wkup__gpio4,
-	&omap2420_dma_system__l3,
-	&omap2420_l4_core__dma_system,
 	&omap2420_l4_core__mailbox,
 	&omap2420_l4_core__mcbsp1,
 	&omap2420_l4_core__mcbsp2,

commit c6797bcde3070bb143a5ccbb5fe054f1ef6252e9
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Dec 16 14:41:53 2019 -0800

    ARM: OMAP2+: Configure dma_plat_info directly and drop dma_dev_attr
    
    Let's prepare things for passing dma_plat_info to the dmaengine driver in
    device tree auxdata. To do that, we want to configure dma_plat_info
    directly. And we can also drop the related dma_dev_attr data.
    
    Cc: Aaro Koskinen <aaro.koskinen@iki.fi>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Russell King <rmk+kernel@armlinux.org.uk>
    Cc: Vinod Koul <vkoul@kernel.org>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index d49df96b4052..6127314ee97b 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -126,18 +126,10 @@ static struct omap_hwmod omap2420_i2c2_hwmod = {
 	.flags		= HWMOD_16BIT_REG,
 };
 
-/* dma attributes */
-static struct omap_dma_dev_attr dma_dev_attr = {
-	.dev_caps  = RESERVE_CHANNEL | DMA_LINKED_LCH | GLOBAL_PRIORITY |
-						IS_CSSA_32 | IS_CDSA_32,
-	.lch_count = 32,
-};
-
 static struct omap_hwmod omap2420_dma_system_hwmod = {
 	.name		= "dma",
 	.class		= &omap2xxx_dma_hwmod_class,
 	.main_clk	= "core_l3_ck",
-	.dev_attr	= &dma_dev_attr,
 	.flags		= HWMOD_NO_IDLEST,
 };
 

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 8122c8d4b69a..d49df96b4052 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * omap_hwmod_2420_data.c - hardware modules present on the OMAP2420 chips
  *
@@ -5,10 +6,6 @@
  * Copyright (C) 2012 Texas Instruments, Inc.
  * Paul Walmsley
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  * XXX handle crossbar/shared link difference for L3?
  * XXX these should be marked initdata for multi-OMAP kernels
  */

commit 70451127873fee41b966328e1617ccc04f6998e7
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Mar 21 11:00:21 2019 -0700

    ARM: OMAP2+: Remove hwmod .rev data and use local SoC checks instead
    
    We can just check for omap2 and 3 for i2c and smartreflex locally.
    The rest of the .rev data is already unused.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index d684fac8f592..8122c8d4b69a 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -91,7 +91,6 @@ static struct omap_hwmod_class_sysconfig i2c_sysc = {
 static struct omap_hwmod_class i2c_class = {
 	.name		= "i2c",
 	.sysc		= &i2c_sysc,
-	.rev		= OMAP_I2C_IP_VERSION_1,
 	.reset		= &omap_i2c_reset,
 };
 

commit 79fc540fd543f47e77e1c7d407f2c082872a4625
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Thu Apr 19 22:00:10 2018 +0200

    i2c: omap: move header to platform_data
    
    This header only contains platform_data. Move it to the proper directory.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index fe66cf247874..d684fac8f592 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -13,7 +13,7 @@
  * XXX these should be marked initdata for multi-OMAP kernels
  */
 
-#include <linux/i2c-omap.h>
+#include <linux/platform_data/i2c-omap.h>
 #include <linux/omap-dma.h>
 
 #include "omap_hwmod.h"

commit 1cddc364584e76c16354d34326c671aac2a23e4f
Author: Suman Anna <s-anna@ti.com>
Date:   Mon Feb 12 19:32:40 2018 -0600

    ARM: OMAP2+: Cleanup omap2_spi_dev_attr and other legacy data
    
    The omap2_spi_dev_attr data was used to supply instance-specific
    data for legacy non-DT devices. The SPI legacy device support
    including the usage of the hwmod class revision data has been
    dropped in commit 6f3ab009a178 ("ARM: OMAP2+: Remove unused legacy
    code for device init") and this data is therefore no longer needed.
    So, cleanup the structure and all the associated data in various
    hwmod data files.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 9f16b1b8d882..fe66cf247874 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -14,7 +14,6 @@
  */
 
 #include <linux/i2c-omap.h>
-#include <linux/platform_data/spi-omap2-mcspi.h>
 #include <linux/omap-dma.h>
 
 #include "omap_hwmod.h"

commit cc7e3fb6413a79e22a144f48361ec4be0b888614
Author: Suman Anna <s-anna@ti.com>
Date:   Mon Feb 12 19:32:39 2018 -0600

    ARM: OMAP2+: Cleanup omap_timer_capability_dev_attr usage
    
    The omap_timer_capability_dev_attr data was used to supply instance
    specific capabilities (like always-on, PWM functionality or ability
    to interrupt DSP cores) for legacy non-DT devices. These capabilities
    are now provided through device-tree properties. The legacy device
    support has been cleaned up in commit 8d39ff3d1696 ("ARM: OMAP2+:
    Remove unused legacy code for timer") and this data is therefore
    no longer needed. So, cleanup the structure and all the associated
    data in various hwmod data files.
    
    While at this, remove the stale header in hwmod data files that
    already do not have any timer capability data.
    
    Cc: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 1fdfd4568899..9f16b1b8d882 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -16,7 +16,6 @@
 #include <linux/i2c-omap.h>
 #include <linux/platform_data/spi-omap2-mcspi.h>
 #include <linux/omap-dma.h>
-#include <plat/dmtimer.h>
 
 #include "omap_hwmod.h"
 #include "l3_2xxx.h"

commit 5297e1d7679560212355ecb88b700be6c0bc378b
Author: Suman Anna <s-anna@ti.com>
Date:   Mon Feb 12 19:32:38 2018 -0600

    ARM: OMAP2+: Cleanup omap_i2c_dev_attr usage
    
    The omap_i2c_dev_attr data was used to supply instance-specific
    data for legacy non-DT devices. The I2C legacy device support has
    been cleaned up in commit 65fa3e719f36 ("ARM: OMAP2+: Remove legacy
    i2c.c platform init code") and this data is therefore no longer
    needed. So, cleanup the structure and all the associated data in
    various hwmod data files.
    
    The i2c-omap.h header is still needed because of the need for
    various OMAP_I2C_IP_VERSION_x macros.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 0afb014b211f..1fdfd4568899 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -97,13 +97,6 @@ static struct omap_hwmod_class i2c_class = {
 	.reset		= &omap_i2c_reset,
 };
 
-static struct omap_i2c_dev_attr i2c_dev_attr = {
-	.flags		= OMAP_I2C_FLAG_NO_FIFO |
-			  OMAP_I2C_FLAG_SIMPLE_CLOCK |
-			  OMAP_I2C_FLAG_16BIT_DATA_REG |
-			  OMAP_I2C_FLAG_BUS_SHIFT_2,
-};
-
 /* I2C1 */
 static struct omap_hwmod omap2420_i2c1_hwmod = {
 	.name		= "i2c1",
@@ -116,7 +109,6 @@ static struct omap_hwmod omap2420_i2c1_hwmod = {
 		},
 	},
 	.class		= &i2c_class,
-	.dev_attr	= &i2c_dev_attr,
 	/*
 	 * From mach-omap2/pm24xx.c: "Putting MPU into the WFI state
 	 * while a transfer is active seems to cause the I2C block to
@@ -137,7 +129,6 @@ static struct omap_hwmod omap2420_i2c2_hwmod = {
 		},
 	},
 	.class		= &i2c_class,
-	.dev_attr	= &i2c_dev_attr,
 	.flags		= HWMOD_16BIT_REG,
 };
 

commit a7cb4671e1d98d5b49957e1599469c301d7d352d
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Dec 14 08:23:33 2017 -0800

    ARM: OMAP2+: Drop unused legacy data for prcm_reg_id and module_bit
    
    We are now using clock drivers in driver/clk/ti for enabling and disabling
    modules and these are all unused.
    
    Let's also remove the related unused defines in cm-regbits-24xx.h and
    cm-regbits-34xx.h.
    
    Reported-by: H. Nikolaus Schaller <hns@goldelico.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 1a15a347945a..0afb014b211f 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -111,8 +111,6 @@ static struct omap_hwmod omap2420_i2c1_hwmod = {
 	.prcm		= {
 		.omap2 = {
 			.module_offs = CORE_MOD,
-			.prcm_reg_id = 1,
-			.module_bit = OMAP2420_EN_I2C1_SHIFT,
 			.idlest_reg_id = 1,
 			.idlest_idle_bit = OMAP2420_ST_I2C1_SHIFT,
 		},
@@ -134,8 +132,6 @@ static struct omap_hwmod omap2420_i2c2_hwmod = {
 	.prcm		= {
 		.omap2 = {
 			.module_offs = CORE_MOD,
-			.prcm_reg_id = 1,
-			.module_bit = OMAP2420_EN_I2C2_SHIFT,
 			.idlest_reg_id = 1,
 			.idlest_idle_bit = OMAP2420_ST_I2C2_SHIFT,
 		},
@@ -167,8 +163,6 @@ static struct omap_hwmod omap2420_mailbox_hwmod = {
 	.main_clk	= "mailboxes_ick",
 	.prcm		= {
 		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_MAILBOXES_SHIFT,
 			.module_offs = CORE_MOD,
 			.idlest_reg_id = 1,
 			.idlest_idle_bit = OMAP24XX_ST_MAILBOXES_SHIFT,
@@ -197,8 +191,6 @@ static struct omap_hwmod omap2420_mcbsp1_hwmod = {
 	.main_clk	= "mcbsp1_fck",
 	.prcm		= {
 		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_MCBSP1_SHIFT,
 			.module_offs = CORE_MOD,
 			.idlest_reg_id = 1,
 			.idlest_idle_bit = OMAP24XX_ST_MCBSP1_SHIFT,
@@ -215,8 +207,6 @@ static struct omap_hwmod omap2420_mcbsp2_hwmod = {
 	.main_clk	= "mcbsp2_fck",
 	.prcm		= {
 		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_MCBSP2_SHIFT,
 			.module_offs = CORE_MOD,
 			.idlest_reg_id = 1,
 			.idlest_idle_bit = OMAP24XX_ST_MCBSP2_SHIFT,
@@ -247,8 +237,6 @@ static struct omap_hwmod omap2420_msdi1_hwmod = {
 	.main_clk	= "mmc_fck",
 	.prcm		= {
 		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP2420_EN_MMC_SHIFT,
 			.module_offs = CORE_MOD,
 			.idlest_reg_id = 1,
 			.idlest_idle_bit = OMAP2420_ST_MMC_SHIFT,
@@ -264,8 +252,6 @@ static struct omap_hwmod omap2420_hdq1w_hwmod = {
 	.prcm		= {
 		.omap2 = {
 			.module_offs = CORE_MOD,
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_HDQ_SHIFT,
 			.idlest_reg_id = 1,
 			.idlest_idle_bit = OMAP24XX_ST_HDQ_SHIFT,
 		},

commit 9cffb1a0504ddc7b291cf882002ee4a794eb3fec
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 10 14:27:33 2017 -0700

    ARM: OMAP2+: Drop legacy struct omap_hwmod_addr_space
    
    With all of mach-omap2 booting now in device tree only mode,
    we can get the module IO range from device tree and just drop
    the legacy hwmod struct omap_hwmod_addr_space.
    
    Cc: Lokesh Vutla <lokeshvutla@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index dc6a81dbc127..1a15a347945a 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -370,7 +370,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__dma_system = {
 	.master		= &omap2xxx_l4_core_hwmod,
 	.slave		= &omap2420_dma_system_hwmod,
 	.clk		= "sdma_ick",
-	.addr		= omap2_dma_system_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 

commit fe97874a41bf911350bae6bda7fc044d12c76a4a
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 10 14:27:19 2017 -0700

    ARM: OMAP2+: Drop omap_hwmod_irq_info
    
    With the previous patches removing the need for legacy IRQs
    now that all of mach-omap2 is booting in device tree only mode,
    we can drop struct omap_hwmod_irq_info.
    
    Note that we can now also finally drop omap4_xlate_irq.
    
    Cc: Lokesh Vutla <lokeshvutla@ti.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 65b1647092bd..dc6a81dbc127 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -155,7 +155,6 @@ static struct omap_dma_dev_attr dma_dev_attr = {
 static struct omap_hwmod omap2420_dma_system_hwmod = {
 	.name		= "dma",
 	.class		= &omap2xxx_dma_hwmod_class,
-	.mpu_irqs	= omap2_dma_system_irqs,
 	.main_clk	= "core_l3_ck",
 	.dev_attr	= &dma_dev_attr,
 	.flags		= HWMOD_NO_IDLEST,

commit 635b3801e0bb59ce7440588a63b4d54f320d0cbc
Author: Suman Anna <s-anna@ti.com>
Date:   Fri Jul 11 16:44:41 2014 -0500

    ARM: OMAP2: hwmod_data: Remove legacy mailbox data and addrs
    
    OMAP2 devices are devicetree boot only, and the legacy mode
    of mailbox device creation should no longer be used, so remove
    the mailbox attribute data and the hwmod addr space used for
    creating mailboxes in legacy mode.
    
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 2f15979c2e9c..65b1647092bd 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -16,7 +16,6 @@
 #include <linux/i2c-omap.h>
 #include <linux/platform_data/spi-omap2-mcspi.h>
 #include <linux/omap-dma.h>
-#include <linux/platform_data/mailbox-omap.h>
 #include <plat/dmtimer.h>
 
 #include "omap_hwmod.h"
@@ -163,18 +162,6 @@ static struct omap_hwmod omap2420_dma_system_hwmod = {
 };
 
 /* mailbox */
-static struct omap_mbox_dev_info omap2420_mailbox_info[] = {
-	{ .name = "dsp", .tx_id = 0, .rx_id = 1, .irq_id = 0, .usr_id = 0 },
-	{ .name = "iva", .tx_id = 2, .rx_id = 3, .irq_id = 1, .usr_id = 3 },
-};
-
-static struct omap_mbox_pdata omap2420_mailbox_attrs = {
-	.num_users	= 4,
-	.num_fifos	= 6,
-	.info_cnt	= ARRAY_SIZE(omap2420_mailbox_info),
-	.info		= omap2420_mailbox_info,
-};
-
 static struct omap_hwmod omap2420_mailbox_hwmod = {
 	.name		= "mailbox",
 	.class		= &omap2xxx_mailbox_hwmod_class,
@@ -188,7 +175,6 @@ static struct omap_hwmod omap2420_mailbox_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_MAILBOXES_SHIFT,
 		},
 	},
-	.dev_attr	= &omap2420_mailbox_attrs,
 };
 
 /*

commit b05ef2159dd373034332151ff7341d0231fae799
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Nov 25 15:17:12 2013 -0800

    ARM: OMAP2+: Remove legacy hwmod entries for omap2
    
    These now come from device tree except for DSS and DMA that
    still uses hwmod to initialize. That will get fixed when we
    DSS gets device tree bindings and we move completely to the
    dmaengine API.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    [tony@atomide.com: updated to add trailing commas to structs]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index d8b9d60f854f..2f15979c2e9c 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -108,8 +108,6 @@ static struct omap_i2c_dev_attr i2c_dev_attr = {
 /* I2C1 */
 static struct omap_hwmod omap2420_i2c1_hwmod = {
 	.name		= "i2c1",
-	.mpu_irqs	= omap2_i2c1_mpu_irqs,
-	.sdma_reqs	= omap2_i2c1_sdma_reqs,
 	.main_clk	= "i2c1_fck",
 	.prcm		= {
 		.omap2 = {
@@ -133,8 +131,6 @@ static struct omap_hwmod omap2420_i2c1_hwmod = {
 /* I2C2 */
 static struct omap_hwmod omap2420_i2c2_hwmod = {
 	.name		= "i2c2",
-	.mpu_irqs	= omap2_i2c2_mpu_irqs,
-	.sdma_reqs	= omap2_i2c2_sdma_reqs,
 	.main_clk	= "i2c2_fck",
 	.prcm		= {
 		.omap2 = {
@@ -179,16 +175,9 @@ static struct omap_mbox_pdata omap2420_mailbox_attrs = {
 	.info		= omap2420_mailbox_info,
 };
 
-static struct omap_hwmod_irq_info omap2420_mailbox_irqs[] = {
-	{ .name = "dsp", .irq = 26 + OMAP_INTC_START, },
-	{ .name = "iva", .irq = 34 + OMAP_INTC_START, },
-	{ .irq = -1 },
-};
-
 static struct omap_hwmod omap2420_mailbox_hwmod = {
 	.name		= "mailbox",
 	.class		= &omap2xxx_mailbox_hwmod_class,
-	.mpu_irqs	= omap2420_mailbox_irqs,
 	.main_clk	= "mailboxes_ick",
 	.prcm		= {
 		.omap2 = {
@@ -217,17 +206,9 @@ static struct omap_hwmod_opt_clk mcbsp_opt_clks[] = {
 };
 
 /* mcbsp1 */
-static struct omap_hwmod_irq_info omap2420_mcbsp1_irqs[] = {
-	{ .name = "tx", .irq = 59 + OMAP_INTC_START, },
-	{ .name = "rx", .irq = 60 + OMAP_INTC_START, },
-	{ .irq = -1 },
-};
-
 static struct omap_hwmod omap2420_mcbsp1_hwmod = {
 	.name		= "mcbsp1",
 	.class		= &omap2420_mcbsp_hwmod_class,
-	.mpu_irqs	= omap2420_mcbsp1_irqs,
-	.sdma_reqs	= omap2_mcbsp1_sdma_reqs,
 	.main_clk	= "mcbsp1_fck",
 	.prcm		= {
 		.omap2 = {
@@ -243,17 +224,9 @@ static struct omap_hwmod omap2420_mcbsp1_hwmod = {
 };
 
 /* mcbsp2 */
-static struct omap_hwmod_irq_info omap2420_mcbsp2_irqs[] = {
-	{ .name = "tx", .irq = 62 + OMAP_INTC_START, },
-	{ .name = "rx", .irq = 63 + OMAP_INTC_START, },
-	{ .irq = -1 },
-};
-
 static struct omap_hwmod omap2420_mcbsp2_hwmod = {
 	.name		= "mcbsp2",
 	.class		= &omap2420_mcbsp_hwmod_class,
-	.mpu_irqs	= omap2420_mcbsp2_irqs,
-	.sdma_reqs	= omap2_mcbsp2_sdma_reqs,
 	.main_clk	= "mcbsp2_fck",
 	.prcm		= {
 		.omap2 = {
@@ -283,22 +256,9 @@ static struct omap_hwmod_class omap2420_msdi_hwmod_class = {
 };
 
 /* msdi1 */
-static struct omap_hwmod_irq_info omap2420_msdi1_irqs[] = {
-	{ .irq = 83 + OMAP_INTC_START, },
-	{ .irq = -1 },
-};
-
-static struct omap_hwmod_dma_info omap2420_msdi1_sdma_reqs[] = {
-	{ .name = "tx", .dma_req = 61 }, /* OMAP24XX_DMA_MMC1_TX */
-	{ .name = "rx", .dma_req = 62 }, /* OMAP24XX_DMA_MMC1_RX */
-	{ .dma_req = -1 }
-};
-
 static struct omap_hwmod omap2420_msdi1_hwmod = {
 	.name		= "msdi1",
 	.class		= &omap2420_msdi_hwmod_class,
-	.mpu_irqs	= omap2420_msdi1_irqs,
-	.sdma_reqs	= omap2420_msdi1_sdma_reqs,
 	.main_clk	= "mmc_fck",
 	.prcm		= {
 		.omap2 = {
@@ -315,7 +275,6 @@ static struct omap_hwmod omap2420_msdi1_hwmod = {
 /* HDQ1W/1-wire */
 static struct omap_hwmod omap2420_hdq1w_hwmod = {
 	.name		= "hdq1w",
-	.mpu_irqs	= omap2_hdq1w_mpu_irqs,
 	.main_clk	= "hdq_fck",
 	.prcm		= {
 		.omap2 = {
@@ -338,7 +297,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__i2c1 = {
 	.master		= &omap2xxx_l4_core_hwmod,
 	.slave		= &omap2420_i2c1_hwmod,
 	.clk		= "i2c1_ick",
-	.addr		= omap2_i2c1_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -347,7 +305,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__i2c2 = {
 	.master		= &omap2xxx_l4_core_hwmod,
 	.slave		= &omap2420_i2c2_hwmod,
 	.clk		= "i2c2_ick",
-	.addr		= omap2_i2c2_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -367,111 +324,51 @@ static struct omap_hwmod_ocp_if omap2420_l3__dsp = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-static struct omap_hwmod_addr_space omap2420_timer1_addrs[] = {
-	{
-		.pa_start	= 0x48028000,
-		.pa_end		= 0x48028000 + SZ_1K - 1,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 /* l4_wkup -> timer1 */
 static struct omap_hwmod_ocp_if omap2420_l4_wkup__timer1 = {
 	.master		= &omap2xxx_l4_wkup_hwmod,
 	.slave		= &omap2xxx_timer1_hwmod,
 	.clk		= "gpt1_ick",
-	.addr		= omap2420_timer1_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
 /* l4_wkup -> wd_timer2 */
-static struct omap_hwmod_addr_space omap2420_wd_timer2_addrs[] = {
-	{
-		.pa_start	= 0x48022000,
-		.pa_end		= 0x4802207f,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 static struct omap_hwmod_ocp_if omap2420_l4_wkup__wd_timer2 = {
 	.master		= &omap2xxx_l4_wkup_hwmod,
 	.slave		= &omap2xxx_wd_timer2_hwmod,
 	.clk		= "mpu_wdt_ick",
-	.addr		= omap2420_wd_timer2_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
 /* l4_wkup -> gpio1 */
-static struct omap_hwmod_addr_space omap2420_gpio1_addr_space[] = {
-	{
-		.pa_start	= 0x48018000,
-		.pa_end		= 0x480181ff,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio1 = {
 	.master		= &omap2xxx_l4_wkup_hwmod,
 	.slave		= &omap2xxx_gpio1_hwmod,
 	.clk		= "gpios_ick",
-	.addr		= omap2420_gpio1_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
 /* l4_wkup -> gpio2 */
-static struct omap_hwmod_addr_space omap2420_gpio2_addr_space[] = {
-	{
-		.pa_start	= 0x4801a000,
-		.pa_end		= 0x4801a1ff,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio2 = {
 	.master		= &omap2xxx_l4_wkup_hwmod,
 	.slave		= &omap2xxx_gpio2_hwmod,
 	.clk		= "gpios_ick",
-	.addr		= omap2420_gpio2_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
 /* l4_wkup -> gpio3 */
-static struct omap_hwmod_addr_space omap2420_gpio3_addr_space[] = {
-	{
-		.pa_start	= 0x4801c000,
-		.pa_end		= 0x4801c1ff,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio3 = {
 	.master		= &omap2xxx_l4_wkup_hwmod,
 	.slave		= &omap2xxx_gpio3_hwmod,
 	.clk		= "gpios_ick",
-	.addr		= omap2420_gpio3_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
 /* l4_wkup -> gpio4 */
-static struct omap_hwmod_addr_space omap2420_gpio4_addr_space[] = {
-	{
-		.pa_start	= 0x4801e000,
-		.pa_end		= 0x4801e1ff,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio4 = {
 	.master		= &omap2xxx_l4_wkup_hwmod,
 	.slave		= &omap2xxx_gpio4_hwmod,
 	.clk		= "gpios_ick",
-	.addr		= omap2420_gpio4_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -496,7 +393,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__dma_system = {
 static struct omap_hwmod_ocp_if omap2420_l4_core__mailbox = {
 	.master		= &omap2xxx_l4_core_hwmod,
 	.slave		= &omap2420_mailbox_hwmod,
-	.addr		= omap2_mailbox_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -505,7 +401,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp1 = {
 	.master		= &omap2xxx_l4_core_hwmod,
 	.slave		= &omap2420_mcbsp1_hwmod,
 	.clk		= "mcbsp1_ick",
-	.addr		= omap2_mcbsp1_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -514,25 +409,14 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp2 = {
 	.master		= &omap2xxx_l4_core_hwmod,
 	.slave		= &omap2420_mcbsp2_hwmod,
 	.clk		= "mcbsp2_ick",
-	.addr		= omap2xxx_mcbsp2_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-static struct omap_hwmod_addr_space omap2420_msdi1_addrs[] = {
-	{
-		.pa_start	= 0x4809c000,
-		.pa_end		= 0x4809c000 + SZ_128 - 1,
-		.flags		= ADDR_TYPE_RT,
-	},
-	{ }
-};
-
 /* l4_core -> msdi1 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__msdi1 = {
 	.master		= &omap2xxx_l4_core_hwmod,
 	.slave		= &omap2420_msdi1_hwmod,
 	.clk		= "mmc_ick",
-	.addr		= omap2420_msdi1_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -541,36 +425,16 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__hdq1w = {
 	.master		= &omap2xxx_l4_core_hwmod,
 	.slave		= &omap2420_hdq1w_hwmod,
 	.clk		= "hdq_ick",
-	.addr		= omap2_hdq1w_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 	.flags		= OMAP_FIREWALL_L4 | OCPIF_SWSUP_IDLE,
 };
 
 
 /* l4_wkup -> 32ksync_counter */
-static struct omap_hwmod_addr_space omap2420_counter_32k_addrs[] = {
-	{
-		.pa_start	= 0x48004000,
-		.pa_end		= 0x4800401f,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
-static struct omap_hwmod_addr_space omap2420_gpmc_addrs[] = {
-	{
-		.pa_start	= 0x6800a000,
-		.pa_end		= 0x6800afff,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 static struct omap_hwmod_ocp_if omap2420_l4_wkup__counter_32k = {
 	.master		= &omap2xxx_l4_wkup_hwmod,
 	.slave		= &omap2xxx_counter_32k_hwmod,
 	.clk		= "sync_32k_ick",
-	.addr		= omap2420_counter_32k_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -578,7 +442,6 @@ static struct omap_hwmod_ocp_if omap2420_l3__gpmc = {
 	.master		= &omap2xxx_l3_main_hwmod,
 	.slave		= &omap2xxx_gpmc_hwmod,
 	.clk		= "core_l3_ck",
-	.addr		= omap2420_gpmc_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 

commit fe32c1f6024e357f586b1d666237cab80a1215ce
Author: Suman Anna <s-anna@ti.com>
Date:   Tue May 7 17:30:27 2013 -0500

    ARM: OMAP2+: add user and fifo info to mailbox platform data
    
    The different generations of OMAP2+ SoCs have almost the same
    mailbox IP, but the IP has configurable parameters for number
    of users (interrupts it can generate out towards processors)
    and number of fifos (the base unidirectional h/w communication
    channel). This data cannot be read from any registers, and so
    has been added to the platform data.
    
    This data together with the interrupt-type configuration can be
    used in properly figuring out the number of registers to save
    and restore in the OMAP mailbox driver code.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Suman Anna <s-anna@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index dbcb928eea50..d8b9d60f854f 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -173,6 +173,8 @@ static struct omap_mbox_dev_info omap2420_mailbox_info[] = {
 };
 
 static struct omap_mbox_pdata omap2420_mailbox_attrs = {
+	.num_users	= 4,
+	.num_fifos	= 6,
 	.info_cnt	= ARRAY_SIZE(omap2420_mailbox_info),
 	.info		= omap2420_mailbox_info,
 };

commit b8a7cf8e2b15a3abac0a9e376b6b7ed4bbb6ee8e
Author: Suman Anna <s-anna@ti.com>
Date:   Mon Jan 28 17:21:58 2013 -0600

    ARM: OMAP2+: mbox: remove dependencies with soc.h
    
    The OMAP mailbox platform driver code has been cleaned up to
    remove the dependencies with soc.h in preparation for moving
    the mailbox code to drivers folder.
    
    The code relied on cpu_is_xxx/soc_is_xxx macros previously to
    pick the the right set of mailbox devices and register with the
    mailbox driver. This data is now represented in a concise format
    and moved to the respective omap_hwmod data files and published
    to the driver through the platform data.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Suman Anna <s-anna@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 5137cc84b504..dbcb928eea50 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -16,6 +16,7 @@
 #include <linux/i2c-omap.h>
 #include <linux/platform_data/spi-omap2-mcspi.h>
 #include <linux/omap-dma.h>
+#include <linux/platform_data/mailbox-omap.h>
 #include <plat/dmtimer.h>
 
 #include "omap_hwmod.h"
@@ -166,6 +167,16 @@ static struct omap_hwmod omap2420_dma_system_hwmod = {
 };
 
 /* mailbox */
+static struct omap_mbox_dev_info omap2420_mailbox_info[] = {
+	{ .name = "dsp", .tx_id = 0, .rx_id = 1, .irq_id = 0, .usr_id = 0 },
+	{ .name = "iva", .tx_id = 2, .rx_id = 3, .irq_id = 1, .usr_id = 3 },
+};
+
+static struct omap_mbox_pdata omap2420_mailbox_attrs = {
+	.info_cnt	= ARRAY_SIZE(omap2420_mailbox_info),
+	.info		= omap2420_mailbox_info,
+};
+
 static struct omap_hwmod_irq_info omap2420_mailbox_irqs[] = {
 	{ .name = "dsp", .irq = 26 + OMAP_INTC_START, },
 	{ .name = "iva", .irq = 34 + OMAP_INTC_START, },
@@ -186,6 +197,7 @@ static struct omap_hwmod omap2420_mailbox_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_MAILBOXES_SHIFT,
 		},
 	},
+	.dev_attr	= &omap2420_mailbox_attrs,
 };
 
 /*

commit 660ffd6ba2405ed7ff614ab73f282e056c47d8f6
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Fri Dec 21 09:28:09 2012 -0700

    ARM: OMAP2xxx: hwmod: Convert AES crypto devcie data to hwmod
    
    Convert the device data for the OMAP2 AES crypto IP from
    explicit platform_data to hwmod.
    
    CC: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    [paul@pwsan.com: fixed lines causing sparse warnings]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 0c192e0403ba..5137cc84b504 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -611,6 +611,7 @@ static struct omap_hwmod_ocp_if *omap2420_hwmod_ocp_ifs[] __initdata = {
 	&omap2420_l4_core__msdi1,
 	&omap2xxx_l4_core__rng,
 	&omap2xxx_l4_core__sham,
+	&omap2xxx_l4_core__aes,
 	&omap2420_l4_core__hdq1w,
 	&omap2420_l4_wkup__counter_32k,
 	&omap2420_l3__gpmc,

commit e569e994b7b1f76324b9bd5f42ae477973687b72
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Sat Mar 30 15:49:19 2013 -0600

    ARM: OMAP2xxx: hwmod: Convert SHAM crypto device data to hwmod
    
    Convert the device data for the OMAP2 SHAM crypto IP from
    explicit platform_data to hwmod.
    
    CC: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    [paul@pwsan.com: fixed lines causing sparse warnings]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 6a764af6c6d3..0c192e0403ba 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -610,6 +610,7 @@ static struct omap_hwmod_ocp_if *omap2420_hwmod_ocp_ifs[] __initdata = {
 	&omap2420_l4_core__mcbsp2,
 	&omap2420_l4_core__msdi1,
 	&omap2xxx_l4_core__rng,
+	&omap2xxx_l4_core__sham,
 	&omap2420_l4_core__hdq1w,
 	&omap2420_l4_wkup__counter_32k,
 	&omap2420_l3__gpmc,

commit aff2f7d90fc6553aa309db2a635d8e5d70d84916
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Jan 26 00:48:56 2013 -0700

    ARM: OMAP2420: hwmod data/PM: use hwmod to block WFI when I2C active
    
    Use the HWMOD_BLOCK_WFI flag in the hwmod data to prevent the MPU from
    entering WFI when the I2C devices are active.  No idea why this is needed;
    this could certainly bear further investigation if anyone is interested.
    The objective here is to remove some custom code from the OMAP24xx PM
    code.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index b5efe58c0be0..6a764af6c6d3 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -121,7 +121,12 @@ static struct omap_hwmod omap2420_i2c1_hwmod = {
 	},
 	.class		= &i2c_class,
 	.dev_attr	= &i2c_dev_attr,
-	.flags		= HWMOD_16BIT_REG,
+	/*
+	 * From mach-omap2/pm24xx.c: "Putting MPU into the WFI state
+	 * while a transfer is active seems to cause the I2C block to
+	 * timeout. Why? Good question."
+	 */
+	.flags		= (HWMOD_16BIT_REG | HWMOD_BLOCK_WFI),
 };
 
 /* I2C2 */

commit 48d224d1efec98b0b78e511150b4f5752beceb7c
Merge: 9121dfca73d8 45c3eb7d3a07
Author: Olof Johansson <olof@lixom.net>
Date:   Fri Nov 30 21:47:21 2012 -0800

    Merge tag 'tags/omap-for-v3.8/cleanup-multiplatform-no-clock-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into next/pm2
    
    From Tony Lindgren:
    Remaining patches to allow omap2+ to build with multiplatform
    enabled. Unfortunately the DMA header patch had to be redone
    to avoid adding new multiplatform specific include paths, the
    other patches are just trivial compile fixes.
    
    Note that this does not yet contain the necessary Kconfig
    changes as we are still waiting for some drivers to get
    fixed up first.
    
    * tag 'tags/omap-for-v3.8/cleanup-multiplatform-no-clock-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap:
      ARM: OMAP: Move plat-omap/dma-omap.h to include/linux/omap-dma.h
      ASoC: OMAP: mcbsp fixes for enabling ARM multiplatform support
      watchdog: OMAP: fixup for ARM multiplatform support
    
    Conflicts due to surrounding changes in:
            arch/arm/mach-omap2/omap_hwmod_2420_data.c
            arch/arm/mach-omap2/omap_hwmod_2430_data.c
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 45c3eb7d3a07eb08d1b5b0f5983a996d41610b84
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Nov 30 08:41:50 2012 -0800

    ARM: OMAP: Move plat-omap/dma-omap.h to include/linux/omap-dma.h
    
    Based on earlier discussions[1] we attempted to find a suitable
    location for the omap DMA header in commit 2b6c4e73 (ARM: OMAP:
    DMA: Move plat/dma.h to plat-omap/dma-omap.h) until the conversion
    to dmaengine is complete.
    
    Unfortunately that was before I was able to try to test compile
    of the ARM multiplatform builds for omap2+, and the end result
    was not very good.
    
    So I'm creating yet another all over the place patch to cut the
    last dependency for building omap2+ for ARM multiplatform. After
    this, we have finally removed the driver dependencies to the
    arch/arm code, except for few drivers that are being worked on.
    
    The other option was to make the <plat-omap/dma-omap.h> path
    to work, but we'd have to add some new header directory to for
    multiplatform builds.
    
    Or we would have to manually include arch/arm/plat-omap/include
    again from arch/arm/Makefile for omap2+.
    
    Neither of these alternatives sound appealing as they will
    likely lead addition of various other headers exposed to the
    drivers, which we want to avoid for the multiplatform kernels.
    
    Since we already have a minimal include/linux/omap-dma.h,
    let's just use that instead and add a note to it to not
    use the custom omap DMA functions any longer where possible.
    
    Note that converting omap DMA to dmaengine depends on
    dmaengine supporting automatically incrementing the FIFO
    address at the device end, and converting all the remaining
    legacy drivers. So it's going to be few more merge windows.
    
    [1] https://patchwork.kernel.org/patch/1519591/#
    
    cc: Russell King <linux@arm.linux.org.uk>
    cc: Kevin Hilman <khilman@ti.com>
    cc: "Beno√Æt Cousson" <b-cousson@ti.com>
    cc: Herbert Xu <herbert@gondor.apana.org.au>
    cc: "David S. Miller" <davem@davemloft.net>
    cc: Vinod Koul <vinod.koul@intel.com>
    cc: Dan Williams <djbw@fb.com>
    cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    cc: David Woodhouse <dwmw2@infradead.org>
    cc: Kyungmin Park <kyungmin.park@samsung.com>
    cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    cc: Florian Tobias Schandinat <FlorianSchandinat@gmx.de>
    cc: Hans Verkuil <hans.verkuil@cisco.com>
    cc: Vaibhav Hiremath <hvaibhav@ti.com>
    cc: Lokesh Vutla <lokeshvutla@ti.com>
    cc: Rusty Russell <rusty@rustcorp.com.au>
    cc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    cc: Afzal Mohammed <afzal@ti.com>
    cc: linux-crypto@vger.kernel.org
    cc: linux-media@vger.kernel.org
    cc: linux-mtd@lists.infradead.org
    cc: linux-usb@vger.kernel.org
    cc: linux-fbdev@vger.kernel.org
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index a8b3368dca3d..10af996aa479 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -16,7 +16,7 @@
 #include <linux/i2c-omap.h>
 #include <linux/platform_data/spi-omap2-mcspi.h>
 
-#include <plat-omap/dma-omap.h>
+#include <linux/omap-dma.h>
 #include <plat/dmtimer.h>
 
 #include "omap_hwmod.h"

commit f7863f7924951f64068eb5214a3dbecde3807a9a
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Mon Oct 1 15:12:29 2012 -0500

    ARM: OMAP: Remove unnecessary inclusion of dmtimer.h
    
    Some source files are including dmtimer.h but not actually using any dmtimer
    definitions or functions. Therefore, remove the inclusion dmtimer.h from these
    source files.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Acked-by: Omar Ramirez Luna <omar.luna@linaro.org>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index a8b3368dca3d..e8efe3d1da6c 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -17,7 +17,6 @@
 #include <linux/platform_data/spi-omap2-mcspi.h>
 
 #include <plat-omap/dma-omap.h>
-#include <plat/dmtimer.h>
 
 #include "omap_hwmod.h"
 #include "l3_2xxx.h"

commit 3d82cbbb3aadb4f8a30e3f614e51be96574a0855
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Oct 15 12:50:46 2012 -0700

    ARM: OMAP: Split plat/serial.h for omap1 and omap2+
    
    For omap1, we'll keep mach/serial.h around for 8250.c hardware
    workarounds. For omap2+, we no longer need mach/serial.h and
    can make it local to mach-omap2.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 3efed3d633d1..a8b3368dca3d 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -29,6 +29,7 @@
 #include "prm-regbits-24xx.h"
 #include "i2c.h"
 #include "mmc.h"
+#include "serial.h"
 #include "wd_timer.h"
 
 /*

commit 2a296c8f89bc6aaf91b255c7d631fcbbfaf840ec
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 2 17:41:35 2012 -0700

    ARM: OMAP: Make plat/omap_hwmod.h local to mach-omap2
    
    Let's make omap_hwmod local to mach-omap2 for
    ARM common zImage support.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 95a0053b6ae1..3efed3d633d1 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -16,9 +16,10 @@
 #include <linux/i2c-omap.h>
 #include <linux/platform_data/spi-omap2-mcspi.h>
 
-#include <plat/omap_hwmod.h>
 #include <plat-omap/dma-omap.h>
 #include <plat/dmtimer.h>
+
+#include "omap_hwmod.h"
 #include "l3_2xxx.h"
 #include "l4_2xxx.h"
 

commit 3a8761c0272c961c707e5af2eb0179adf3ef7e14
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Oct 8 09:11:22 2012 -0700

    ARM: OMAP: Split plat-omap/i2c.c into mach-omap1 and mach-omap2
    
    There's no need to keep the device related things in the
    common i2c.c as omap2+ is using hwmod. Split the code to
    mach-omap1 and mach-omap2 parts and only leave common
    code to plat-omap/i2c.c.
    
    Note that as omap1 only has one i2c controller, we can
    now remove the old device related macros.
    
    Reviewed-by: Shubhrajyoti D <shubhrajyoti@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 80bbbee57649..95a0053b6ae1 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -12,12 +12,12 @@
  * XXX handle crossbar/shared link difference for L3?
  * XXX these should be marked initdata for multi-OMAP kernels
  */
+
+#include <linux/i2c-omap.h>
 #include <linux/platform_data/spi-omap2-mcspi.h>
 
 #include <plat/omap_hwmod.h>
 #include <plat-omap/dma-omap.h>
-#include <plat/serial.h>
-#include <plat/i2c.h>
 #include <plat/dmtimer.h>
 #include "l3_2xxx.h"
 #include "l4_2xxx.h"
@@ -26,6 +26,7 @@
 
 #include "cm-regbits-24xx.h"
 #include "prm-regbits-24xx.h"
+#include "i2c.h"
 #include "mmc.h"
 #include "wd_timer.h"
 

commit 46cddc01aa6a017193ae7320ef8bfc8242782a66
Merge: 99f0b8d6b09b 53db20d123f7
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Oct 17 11:13:42 2012 -0700

    Merge branch 'omap-for-v3.8/cleanup-headers-mmc' into omap-for-v3.8/cleanup-headers
    
    Conflicts:
            arch/arm/mach-omap1/devices.c
            arch/arm/mach-omap2/omap_hwmod_33xx_data.c
            arch/arm/mach-omap2/omap_hwmod_3xxx_data.c
            drivers/mmc/host/omap.c

commit 2b6c4e73248758bac8e1ed81b0d0664da0fff6f8
Author: Lokesh Vutla <lokeshvutla@ti.com>
Date:   Mon Oct 15 14:04:53 2012 -0700

    ARM: OMAP: DMA: Move plat/dma.h to plat-omap/dma-omap.h
    
    Move plat/dma.h to plat-omap/dma-omap.h as part of single
    zImage work
    
    Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index b5db6007c523..917b1f47598e 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -15,7 +15,7 @@
 #include <linux/platform_data/spi-omap2-mcspi.h>
 
 #include <plat/omap_hwmod.h>
-#include <plat/dma.h>
+#include <plat-omap/dma-omap.h>
 #include <plat/serial.h>
 #include <plat/i2c.h>
 #include <plat/dmtimer.h>

commit 68f39e74fbc3e58ad52d008072bddacc9eee1c7e
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Oct 15 12:09:43 2012 -0700

    ARM: OMAP: Split plat/mmc.h into local headers and platform_data
    
    We need to remove this from plat for ARM common zImage
    support.
    
    Also remove includes not needed by the omap_hsmmc.c driver.
    
    Cc: linux-mmc@vger.kernel.org
    Acked-by: Chris Ball <cjb@laptop.org>
    Acked-by: Venkatraman S <svenkatr@ti.com>
    [tony@atomide.com: fold in removal of unused driver includes]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index b5db6007c523..82ad9a57661e 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -21,12 +21,12 @@
 #include <plat/dmtimer.h>
 #include "l3_2xxx.h"
 #include "l4_2xxx.h"
-#include <plat/mmc.h>
 
 #include "omap_hwmod_common_data.h"
 
 #include "cm-regbits-24xx.h"
 #include "prm-regbits-24xx.h"
+#include "mmc.h"
 #include "wd_timer.h"
 
 /*

commit 54d69df5849ec2e660aa12ac75562618c10fb499
Merge: ad932bb6b549 46f2007c1efa
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Oct 4 20:17:25 2012 -0700

    Merge branch 'late/kirkwood' into late/soc
    
    Merge in the late Kirkwood branch with the OMAP late branch for upstream
    submission.
    
    Final contents described in shared tag.
    
    Fixup remove/change conflicts in arch/arm/mach-omap2/devices.c and
    drivers/spi/spi-omap2-mcspi.c.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit e9b0a2fb0af562092aab1b56abf9d13f1abc7381
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Sep 23 17:28:25 2012 -0600

    ARM: OMAP2xxx: hwmod/CM: add RNG integration data
    
    Add integration data for the hardware random number generator IP block
    on some OMAP SoCs.  This appears to be present on at least OMAP2xxx
    and OMAP3xxx SoCs, although it is not so easy to tell.  It may also be
    present on other OMAP2+ SoCs.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 5fcd225d207e..e778ff4e1887 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -601,6 +601,7 @@ static struct omap_hwmod_ocp_if *omap2420_hwmod_ocp_ifs[] __initdata = {
 	&omap2420_l4_core__mcbsp1,
 	&omap2420_l4_core__mcbsp2,
 	&omap2420_l4_core__msdi1,
+	&omap2xxx_l4_core__rng,
 	&omap2420_l4_core__hdq1w,
 	&omap2420_l4_wkup__counter_32k,
 	&omap2420_l3__gpmc,

commit 49484a60ff665ccac2e4f2314753a21daa0c2f9e
Author: Afzal Mohammed <afzal@ti.com>
Date:   Sun Sep 23 17:28:24 2012 -0600

    ARM: OMAP2/3: hwmod data: add gpmc
    
    Add gpmc hwmod and associated interconnect data
    
    Signed-off-by: Afzal Mohammed <afzal@ti.com>
    [paul@pwsan.com: added comments to the use of HWMOD_INIT_NO_RESET]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 4e81637640e9..5fcd225d207e 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -535,6 +535,15 @@ static struct omap_hwmod_addr_space omap2420_counter_32k_addrs[] = {
 	{ }
 };
 
+static struct omap_hwmod_addr_space omap2420_gpmc_addrs[] = {
+	{
+		.pa_start	= 0x6800a000,
+		.pa_end		= 0x6800afff,
+		.flags		= ADDR_TYPE_RT
+	},
+	{ }
+};
+
 static struct omap_hwmod_ocp_if omap2420_l4_wkup__counter_32k = {
 	.master		= &omap2xxx_l4_wkup_hwmod,
 	.slave		= &omap2xxx_counter_32k_hwmod,
@@ -543,6 +552,14 @@ static struct omap_hwmod_ocp_if omap2420_l4_wkup__counter_32k = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
+static struct omap_hwmod_ocp_if omap2420_l3__gpmc = {
+	.master		= &omap2xxx_l3_main_hwmod,
+	.slave		= &omap2xxx_gpmc_hwmod,
+	.clk		= "core_l3_ck",
+	.addr		= omap2420_gpmc_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
 static struct omap_hwmod_ocp_if *omap2420_hwmod_ocp_ifs[] __initdata = {
 	&omap2xxx_l3_main__l4_core,
 	&omap2xxx_mpu__l3_main,
@@ -586,6 +603,7 @@ static struct omap_hwmod_ocp_if *omap2420_hwmod_ocp_ifs[] __initdata = {
 	&omap2420_l4_core__msdi1,
 	&omap2420_l4_core__hdq1w,
 	&omap2420_l4_wkup__counter_32k,
+	&omap2420_l3__gpmc,
 	NULL,
 };
 

commit 70606b1c40765f3d73d60c057072370e010ed3ab
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Sep 20 11:42:07 2012 -0700

    ARM: OMAP2+: Make l4_2xxx.h local
    
    This can be local to mach-omap2.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 4802ab92bf5f..10575a1bc1f1 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -20,7 +20,7 @@
 #include <plat/i2c.h>
 #include <plat/dmtimer.h>
 #include "l3_2xxx.h"
-#include <plat/l4_2xxx.h>
+#include "l4_2xxx.h"
 #include <plat/mmc.h>
 
 #include "omap_hwmod_common_data.h"

commit 1e0f51a9e786a0119267b2a44724db5f4667668b
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Sep 20 11:42:02 2012 -0700

    ARM: OMAP2+: Make l3_2xxx.h local
    
    This can be local to mach-omap2.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 5547fa35707c..4802ab92bf5f 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -19,7 +19,7 @@
 #include <plat/serial.h>
 #include <plat/i2c.h>
 #include <plat/dmtimer.h>
-#include <plat/l3_2xxx.h>
+#include "l3_2xxx.h"
 #include <plat/l4_2xxx.h>
 #include <plat/mmc.h>
 

commit 2203747c97712975accc5e69bdaf1ad38a691635
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Aug 24 15:21:06 2012 +0200

    ARM: omap: move platform_data definitions
    
    Platform data for device drivers should be defined in
    include/linux/platform_data/*.h, not in the architecture
    and platform specific directories.
    
    This moves such data out of the omap include directories
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: "Beno√Æt Cousson" <b-cousson@ti.com>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Ohad Ben-Cohen <ohad@wizery.com>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Omar Ramirez Luna <omar.ramirez@ti.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Florian Tobias Schandinat <FlorianSchandinat@gmx.de>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Jarkko Nikula <jarkko.nikula@bitmer.com>
    Cc: Liam Girdwood <lrg@ti.com>
    Cc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Cc: Jean Pihet <j-pihet@ti.com>
    Cc: J Keerthy <j-keerthy@ti.com>
    Cc: linux-omap@vger.kernel.org

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 4e81637640e9..5547fa35707c 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -12,11 +12,12 @@
  * XXX handle crossbar/shared link difference for L3?
  * XXX these should be marked initdata for multi-OMAP kernels
  */
+#include <linux/platform_data/spi-omap2-mcspi.h>
+
 #include <plat/omap_hwmod.h>
 #include <plat/dma.h>
 #include <plat/serial.h>
 #include <plat/i2c.h>
-#include <plat/mcspi.h>
 #include <plat/dmtimer.h>
 #include <plat/l3_2xxx.h>
 #include <plat/l4_2xxx.h>

commit dbc04161048dd5e5c3c58546688a0cc0854051e9
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Aug 31 10:59:07 2012 -0700

    ARM: OMAP: Split plat/hardware.h, use local soc.h for omap2+
    
    As the plat and mach includes need to disappear for single zImage work,
    we need to remove plat/hardware.h.
    
    Do this by splitting plat/hardware.h into omap1 and omap2+ specific files.
    
    The old plat/hardware.h already has omap1 only defines, so it gets moved
    to mach/hardware.h for omap1. For omap2+, we use the local soc.h
    that for now just includes the related SoC headers to keep this patch more
    readable.
    
    Note that the local soc.h still includes plat/cpu.h that can be dealt
    with in later patches. Let's also include plat/serial.h from common.h for
    all the board-*.c files. This allows making the include files local later
    on without patching these files again.
    
    Note that only minimal changes are done in this patch for the
    drivers/watchdog/omap_wdt.c driver to keep things compiling. Further
    patches are needed to eventually remove cpu_is_omap usage in the drivers.
    
    Also only minimal changes are done to sound/soc/omap/* to remove the
    unneeded includes and to define OMAP44XX_MCPDM_L3_BASE locally so there's
    no need to include omap44xx.h.
    
    While at it, also sort some of the includes in the standard way.
    
    Cc: linux-watchdog@vger.kernel.org
    Cc: alsa-devel@alsa-project.org
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Jarkko Nikula <jarkko.nikula@bitmer.com>
    Cc: Liam Girdwood <lrg@ti.com>
    Acked-by: Wim Van Sebroeck <wim@iguana.be>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 1645d3f73207..4e81637640e9 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -13,7 +13,6 @@
  * XXX these should be marked initdata for multi-OMAP kernels
  */
 #include <plat/omap_hwmod.h>
-#include <plat/cpu.h>
 #include <plat/dma.h>
 #include <plat/serial.h>
 #include <plat/i2c.h>

commit 7d7e1eba7e92c2f9c76db80adc24836e7a114bfb
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Aug 27 17:43:01 2012 -0700

    ARM: OMAP2+: Prepare for irqs.h removal
    
    As the interrupts should only be defined in the platform_data, and
    eventually coming from device tree, there's no need to define them
    in header files.
    
    Let's remove the hardcoded references to irqs.h and fix up the includes
    so we don't rely on headers included in irqs.h. Note that we're
    defining OMAP_INTC_START as 0 to the interrupts. This will be needed
    when we enable SPARSE_IRQ. For some drivers we need to add
    #include <plat/cpu.h> for now until these drivers are fixed to
    remove cpu_is_omapxxxx() usage.
    
    While at it, sort som of the includes the standard way, and add
    the trailing commas where they are missing in the related data
    structures.
    
    Note that for drivers/staging/tidspbridge we just define things
    locally.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 5b49ebfd4df6..1645d3f73207 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -13,7 +13,6 @@
  * XXX these should be marked initdata for multi-OMAP kernels
  */
 #include <plat/omap_hwmod.h>
-#include <mach/irqs.h>
 #include <plat/cpu.h>
 #include <plat/dma.h>
 #include <plat/serial.h>
@@ -161,9 +160,9 @@ static struct omap_hwmod omap2420_dma_system_hwmod = {
 
 /* mailbox */
 static struct omap_hwmod_irq_info omap2420_mailbox_irqs[] = {
-	{ .name = "dsp", .irq = 26 },
-	{ .name = "iva", .irq = 34 },
-	{ .irq = -1 }
+	{ .name = "dsp", .irq = 26 + OMAP_INTC_START, },
+	{ .name = "iva", .irq = 34 + OMAP_INTC_START, },
+	{ .irq = -1 },
 };
 
 static struct omap_hwmod omap2420_mailbox_hwmod = {
@@ -198,9 +197,9 @@ static struct omap_hwmod_opt_clk mcbsp_opt_clks[] = {
 
 /* mcbsp1 */
 static struct omap_hwmod_irq_info omap2420_mcbsp1_irqs[] = {
-	{ .name = "tx", .irq = 59 },
-	{ .name = "rx", .irq = 60 },
-	{ .irq = -1 }
+	{ .name = "tx", .irq = 59 + OMAP_INTC_START, },
+	{ .name = "rx", .irq = 60 + OMAP_INTC_START, },
+	{ .irq = -1 },
 };
 
 static struct omap_hwmod omap2420_mcbsp1_hwmod = {
@@ -224,9 +223,9 @@ static struct omap_hwmod omap2420_mcbsp1_hwmod = {
 
 /* mcbsp2 */
 static struct omap_hwmod_irq_info omap2420_mcbsp2_irqs[] = {
-	{ .name = "tx", .irq = 62 },
-	{ .name = "rx", .irq = 63 },
-	{ .irq = -1 }
+	{ .name = "tx", .irq = 62 + OMAP_INTC_START, },
+	{ .name = "rx", .irq = 63 + OMAP_INTC_START, },
+	{ .irq = -1 },
 };
 
 static struct omap_hwmod omap2420_mcbsp2_hwmod = {
@@ -264,8 +263,8 @@ static struct omap_hwmod_class omap2420_msdi_hwmod_class = {
 
 /* msdi1 */
 static struct omap_hwmod_irq_info omap2420_msdi1_irqs[] = {
-	{ .irq = 83 },
-	{ .irq = -1 }
+	{ .irq = 83 + OMAP_INTC_START, },
+	{ .irq = -1 },
 };
 
 static struct omap_hwmod_dma_info omap2420_msdi1_sdma_reqs[] = {

commit 4b25408f1f61c35b70a19a41053b5e5e3224e97f
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Aug 30 15:37:24 2012 -0700

    ARM: OMAP: Move gpio.h to include/linux/platform_data
    
    This way we can remove includes of plat/gpio.h which won't work
    with the single zImage support.
    
    Note that we also remove the cpu_class_is_omap2() check
    in gpio-omap.c as the drivers should not call it as we need to
    make it local to arch/arm/mach-omap2 for single zImage support.
    
    While at it, arrange the related includes in the standard way.
    
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: linux-mtd@lists.infradead.org
    Cc: alsa-devel@alsa-project.org
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 50cfab61b0e2..5b49ebfd4df6 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -18,7 +18,6 @@
 #include <plat/dma.h>
 #include <plat/serial.h>
 #include <plat/i2c.h>
-#include <plat/gpio.h>
 #include <plat/mcspi.h>
 #include <plat/dmtimer.h>
 #include <plat/l3_2xxx.h>

commit 07b3a13957aa250ff5b5409b8ed756b113544112
Merge: d44f42e6af48 3d3635c4d77a 0a179eaa436e 7039154bb218 868c157df972
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Jun 20 20:11:36 2012 -0600

    Merge branches 'clock_cleanup_misc_3.6', 'control_clean_dspbridge_writes_cleanup_3.6', 'hwmod_soc_conditional_cleanup_3.6', 'mcbsp_clock_aliases_cleanup_3.6' and 'remove_clkdm_requirement_from_hwmod_3.6' into omap_cleanup_a_3.6
    
    Conflicts:
            arch/arm/mach-omap2/omap_hwmod.c

commit b3153100a0b1624dd82d67e956f9229a6a2dbc1b
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Mon Jun 18 16:18:42 2012 -0600

    ARM: OMAP2: Move McBSP fck clock alias to hwmod data for OMAP2420
    
    Remove the existing alias for pad_fck, prcm_fck from the clock data and
    add them as opt_clks to the hwmod data.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index a7640d1b215e..910d256f3abe 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -192,6 +192,11 @@ static struct omap_hwmod_class omap2420_mcbsp_hwmod_class = {
 	.name = "mcbsp",
 };
 
+static struct omap_hwmod_opt_clk mcbsp_opt_clks[] = {
+	{ .role = "pad_fck", .clk = "mcbsp_clks" },
+	{ .role = "prcm_fck", .clk = "func_96m_ck" },
+};
+
 /* mcbsp1 */
 static struct omap_hwmod_irq_info omap2420_mcbsp1_irqs[] = {
 	{ .name = "tx", .irq = 59 },
@@ -214,6 +219,8 @@ static struct omap_hwmod omap2420_mcbsp1_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_MCBSP1_SHIFT,
 		},
 	},
+	.opt_clks	= mcbsp_opt_clks,
+	.opt_clks_cnt	= ARRAY_SIZE(mcbsp_opt_clks),
 };
 
 /* mcbsp2 */
@@ -238,6 +245,8 @@ static struct omap_hwmod omap2420_mcbsp2_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_MCBSP2_SHIFT,
 		},
 	},
+	.opt_clks	= mcbsp_opt_clks,
+	.opt_clks_cnt	= ARRAY_SIZE(mcbsp_opt_clks),
 };
 
 static struct omap_hwmod_class_sysconfig omap2420_msdi_sysc = {

commit 9ebfd285371835b1c0243d15aaacd72d5def76f8
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Jun 18 12:12:23 2012 -0600

    ARM: OMAP2+: hwmod: use init-time function ptrs for enable/disable module
    
    The enable/disable module functions are specific to SoCs with
    OMAP4-class PRCM.  Rather than use cpu_is* checks at runtime inside
    the enable/disable module functions, use cpu_is at init time to
    initialize function pointers only for SoCs that need them.
    
    NOTE: the cpu_is* check for _enable_module was different than
          the one for _disable_module, and this patch uses
          cpu_is_omap44xx() for both.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>
    [paul@pwsan.com: moved soc_ops function pointers to be per-kernel rather than
     per-hwmod since they do not vary by hwmod; added kerneldoc]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index a7640d1b215e..5b1938b52d09 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -585,5 +585,6 @@ static struct omap_hwmod_ocp_if *omap2420_hwmod_ocp_ifs[] __initdata = {
 
 int __init omap2420_hwmod_init(void)
 {
+	omap_hwmod_init();
 	return omap_hwmod_register_links(omap2420_hwmod_ocp_ifs);
 }

commit c8d82ff68fb6873691536cf33021977efbf5593c
Author: Vaibhav Hiremath <hvaibhav@ti.com>
Date:   Tue May 8 11:34:30 2012 -0600

    ARM: OMAP2/3: hwmod data: Add 32k-sync timer data to hwmod database
    
    Add 32k-sync timer hwmod-data and add ocp_if details to
    omap2 & 3 hwmod table.
    
    Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 85419f86b280..a7640d1b215e 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -519,6 +519,24 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__hdq1w = {
 };
 
 
+/* l4_wkup -> 32ksync_counter */
+static struct omap_hwmod_addr_space omap2420_counter_32k_addrs[] = {
+	{
+		.pa_start	= 0x48004000,
+		.pa_end		= 0x4800401f,
+		.flags		= ADDR_TYPE_RT
+	},
+	{ }
+};
+
+static struct omap_hwmod_ocp_if omap2420_l4_wkup__counter_32k = {
+	.master		= &omap2xxx_l4_wkup_hwmod,
+	.slave		= &omap2xxx_counter_32k_hwmod,
+	.clk		= "sync_32k_ick",
+	.addr		= omap2420_counter_32k_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
 static struct omap_hwmod_ocp_if *omap2420_hwmod_ocp_ifs[] __initdata = {
 	&omap2xxx_l3_main__l4_core,
 	&omap2xxx_mpu__l3_main,
@@ -561,6 +579,7 @@ static struct omap_hwmod_ocp_if *omap2420_hwmod_ocp_ifs[] __initdata = {
 	&omap2420_l4_core__mcbsp2,
 	&omap2420_l4_core__msdi1,
 	&omap2420_l4_core__hdq1w,
+	&omap2420_l4_wkup__counter_32k,
 	NULL,
 };
 

commit f32bd7787561ceb887e45d81ca41d6c7a903751f
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue May 8 11:34:28 2012 -0600

    ARM: OMAP2xxx: hwmod data: add HDQ/1-wire hwmod
    
    Add the HDQ1W hwmod for all OMAP2xxx devices.
    
    Assume that OMAP2xxx chips have the same HDQ idle handling bug
    as OMAP3:
    
       http://www.spinics.net/lists/linux-omap/msg63576.html
    
    and set the OCPIF_SWSUP_IDLE flag accordingly on the HDQ's OCP interface.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 0c08d3f11f69..85419f86b280 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -284,6 +284,23 @@ static struct omap_hwmod omap2420_msdi1_hwmod = {
 	.flags		= HWMOD_16BIT_REG,
 };
 
+/* HDQ1W/1-wire */
+static struct omap_hwmod omap2420_hdq1w_hwmod = {
+	.name		= "hdq1w",
+	.mpu_irqs	= omap2_hdq1w_mpu_irqs,
+	.main_clk	= "hdq_fck",
+	.prcm		= {
+		.omap2 = {
+			.module_offs = CORE_MOD,
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_HDQ_SHIFT,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_HDQ_SHIFT,
+		},
+	},
+	.class		= &omap2_hdq1w_class,
+};
+
 /*
  * interfaces
  */
@@ -491,6 +508,17 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__msdi1 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
+/* l4_core -> hdq1w interface */
+static struct omap_hwmod_ocp_if omap2420_l4_core__hdq1w = {
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2420_hdq1w_hwmod,
+	.clk		= "hdq_ick",
+	.addr		= omap2_hdq1w_addr_space,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+	.flags		= OMAP_FIREWALL_L4 | OCPIF_SWSUP_IDLE,
+};
+
+
 static struct omap_hwmod_ocp_if *omap2420_hwmod_ocp_ifs[] __initdata = {
 	&omap2xxx_l3_main__l4_core,
 	&omap2xxx_mpu__l3_main,
@@ -532,6 +560,7 @@ static struct omap_hwmod_ocp_if *omap2420_hwmod_ocp_ifs[] __initdata = {
 	&omap2420_l4_core__mcbsp1,
 	&omap2420_l4_core__mcbsp2,
 	&omap2420_l4_core__msdi1,
+	&omap2420_l4_core__hdq1w,
 	NULL,
 };
 

commit ad1b6662eb5fe293e8b402497b3835710848c389
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue May 8 17:23:33 2012 -0600

    ARM: OMAP2420: hwmod data: Add MMC hwmod data for 2420
    
    Add MMC for 2420 so we can pass the DMA request lines the same
    way as we already do on omap2430 and later.
    
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    [paul@pwsan.com: updated to apply on top of the 3.5 hwmod cleanup;
     changed mmc hwmod name/class to "msdi" as documented in the 2420 TRM Rev X;
     added sysconfig register information; added 16 bit register width flag;
     added MSDI custom reset code]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 2c087ffc6a92..0c08d3f11f69 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -23,6 +23,7 @@
 #include <plat/dmtimer.h>
 #include <plat/l3_2xxx.h>
 #include <plat/l4_2xxx.h>
+#include <plat/mmc.h>
 
 #include "omap_hwmod_common_data.h"
 
@@ -239,6 +240,50 @@ static struct omap_hwmod omap2420_mcbsp2_hwmod = {
 	},
 };
 
+static struct omap_hwmod_class_sysconfig omap2420_msdi_sysc = {
+	.rev_offs	= 0x3c,
+	.sysc_offs	= 0x64,
+	.syss_offs	= 0x68,
+	.sysc_flags	= (SYSC_HAS_SOFTRESET | SYSS_HAS_RESET_STATUS),
+	.sysc_fields	= &omap_hwmod_sysc_type1,
+};
+
+static struct omap_hwmod_class omap2420_msdi_hwmod_class = {
+	.name	= "msdi",
+	.sysc	= &omap2420_msdi_sysc,
+	.reset	= &omap_msdi_reset,
+};
+
+/* msdi1 */
+static struct omap_hwmod_irq_info omap2420_msdi1_irqs[] = {
+	{ .irq = 83 },
+	{ .irq = -1 }
+};
+
+static struct omap_hwmod_dma_info omap2420_msdi1_sdma_reqs[] = {
+	{ .name = "tx", .dma_req = 61 }, /* OMAP24XX_DMA_MMC1_TX */
+	{ .name = "rx", .dma_req = 62 }, /* OMAP24XX_DMA_MMC1_RX */
+	{ .dma_req = -1 }
+};
+
+static struct omap_hwmod omap2420_msdi1_hwmod = {
+	.name		= "msdi1",
+	.class		= &omap2420_msdi_hwmod_class,
+	.mpu_irqs	= omap2420_msdi1_irqs,
+	.sdma_reqs	= omap2420_msdi1_sdma_reqs,
+	.main_clk	= "mmc_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP2420_EN_MMC_SHIFT,
+			.module_offs = CORE_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP2420_ST_MMC_SHIFT,
+		},
+	},
+	.flags		= HWMOD_16BIT_REG,
+};
+
 /*
  * interfaces
  */
@@ -428,6 +473,24 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp2 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
+static struct omap_hwmod_addr_space omap2420_msdi1_addrs[] = {
+	{
+		.pa_start	= 0x4809c000,
+		.pa_end		= 0x4809c000 + SZ_128 - 1,
+		.flags		= ADDR_TYPE_RT,
+	},
+	{ }
+};
+
+/* l4_core -> msdi1 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__msdi1 = {
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2420_msdi1_hwmod,
+	.clk		= "mmc_ick",
+	.addr		= omap2420_msdi1_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
 static struct omap_hwmod_ocp_if *omap2420_hwmod_ocp_ifs[] __initdata = {
 	&omap2xxx_l3_main__l4_core,
 	&omap2xxx_mpu__l3_main,
@@ -468,6 +531,7 @@ static struct omap_hwmod_ocp_if *omap2420_hwmod_ocp_ifs[] __initdata = {
 	&omap2420_l4_core__mailbox,
 	&omap2420_l4_core__mcbsp1,
 	&omap2420_l4_core__mcbsp2,
+	&omap2420_l4_core__msdi1,
 	NULL,
 };
 

commit 3af35fbcd088e0b675fa423a879c596384894180
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Apr 19 04:04:38 2012 -0600

    ARM: OMAP2xxx: hwmod data: start to fix the IVA1, IVA2 and DSP
    
    N800 logs this message on boot:
    
    [    0.182281] omap_hwmod: iva: cannot be enabled for reset (3)
    
    Fix by creating basic IVA1 and DSP hwmods for OMAP2420, and a basic IVA2
    hwmod for OMAP2430.  There is still more information to be added, but
    this should resolve the immediate issue.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index b01b66a85f2e..2c087ffc6a92 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -43,10 +43,41 @@
  * IP blocks
  */
 
-/* IVA2 (IVA2) */
+/* IVA1 (IVA1) */
+static struct omap_hwmod_class iva1_hwmod_class = {
+	.name		= "iva1",
+};
+
+static struct omap_hwmod_rst_info omap2420_iva_resets[] = {
+	{ .name = "iva", .rst_shift = 8 },
+};
+
 static struct omap_hwmod omap2420_iva_hwmod = {
 	.name		= "iva",
-	.class		= &iva_hwmod_class,
+	.class		= &iva1_hwmod_class,
+	.clkdm_name	= "iva1_clkdm",
+	.rst_lines	= omap2420_iva_resets,
+	.rst_lines_cnt	= ARRAY_SIZE(omap2420_iva_resets),
+	.main_clk	= "iva1_ifck",
+};
+
+/* DSP */
+static struct omap_hwmod_class dsp_hwmod_class = {
+	.name		= "dsp",
+};
+
+static struct omap_hwmod_rst_info omap2420_dsp_resets[] = {
+	{ .name = "logic", .rst_shift = 0 },
+	{ .name = "mmu", .rst_shift = 1 },
+};
+
+static struct omap_hwmod omap2420_dsp_hwmod = {
+	.name		= "dsp",
+	.class		= &dsp_hwmod_class,
+	.clkdm_name	= "dsp_clkdm",
+	.rst_lines	= omap2420_dsp_resets,
+	.rst_lines_cnt	= ARRAY_SIZE(omap2420_dsp_resets),
+	.main_clk	= "dsp_fck",
 };
 
 /* I2C common */
@@ -234,7 +265,15 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__i2c2 = {
 static struct omap_hwmod_ocp_if omap2420_l3__iva = {
 	.master		= &omap2xxx_l3_main_hwmod,
 	.slave		= &omap2420_iva_hwmod,
-	.clk		= "iva1_ifck",
+	.clk		= "core_l3_ck",
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* DSP <- L3 interface */
+static struct omap_hwmod_ocp_if omap2420_l3__dsp = {
+	.master		= &omap2xxx_l3_main_hwmod,
+	.slave		= &omap2420_dsp_hwmod,
+	.clk		= "dsp_ick",
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -402,6 +441,7 @@ static struct omap_hwmod_ocp_if *omap2420_hwmod_ocp_ifs[] __initdata = {
 	&omap2420_l4_core__i2c1,
 	&omap2420_l4_core__i2c2,
 	&omap2420_l3__iva,
+	&omap2420_l3__dsp,
 	&omap2420_l4_wkup__timer1,
 	&omap2xxx_l4_core__timer2,
 	&omap2xxx_l4_core__timer3,

commit 6a29755fd7b92dc58908826f8d570a20a07a6fce
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Apr 19 04:04:34 2012 -0600

    ARM: OMAP2xxx: hwmod data: share common interface data
    
    Several struct omap_hwmod_ocp_if records can be shared between OMAP2420
    and OMAP2430.  Move these shared records out of the chip-specific files
    into mach-omap2/omap_hwmod_2xxx_interconnect_data.c.  This should save some
    memory and source lines, at the cost of readability.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Beno√Æt Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 75c57d35bcca..b01b66a85f2e 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -212,85 +212,6 @@ static struct omap_hwmod omap2420_mcbsp2_hwmod = {
  * interfaces
  */
 
-/* L3 -> L4_CORE interface */
-static struct omap_hwmod_ocp_if omap2420_l3_main__l4_core = {
-	.master	= &omap2xxx_l3_main_hwmod,
-	.slave	= &omap2xxx_l4_core_hwmod,
-	.user	= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* MPU -> L3 interface */
-static struct omap_hwmod_ocp_if omap2420_mpu__l3_main = {
-	.master = &omap2xxx_mpu_hwmod,
-	.slave	= &omap2xxx_l3_main_hwmod,
-	.user	= OCP_USER_MPU,
-};
-
-/* DSS -> l3 */
-static struct omap_hwmod_ocp_if omap2420_dss__l3 = {
-	.master		= &omap2xxx_dss_core_hwmod,
-	.slave		= &omap2xxx_l3_main_hwmod,
-	.fw = {
-		.omap2 = {
-			.l3_perm_bit  = OMAP2_L3_CORE_FW_CONNID_DSS,
-			.flags	= OMAP_FIREWALL_L3,
-		}
-	},
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4 core -> mcspi1 interface */
-static struct omap_hwmod_ocp_if omap2420_l4_core__mcspi1 = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2xxx_mcspi1_hwmod,
-	.clk		= "mcspi1_ick",
-	.addr		= omap2_mcspi1_addr_space,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4 core -> mcspi2 interface */
-static struct omap_hwmod_ocp_if omap2420_l4_core__mcspi2 = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2xxx_mcspi2_hwmod,
-	.clk		= "mcspi2_ick",
-	.addr		= omap2_mcspi2_addr_space,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* L4_CORE -> L4_WKUP interface */
-static struct omap_hwmod_ocp_if omap2420_l4_core__l4_wkup = {
-	.master	= &omap2xxx_l4_core_hwmod,
-	.slave	= &omap2xxx_l4_wkup_hwmod,
-	.user	= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* L4 CORE -> UART1 interface */
-static struct omap_hwmod_ocp_if omap2_l4_core__uart1 = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2xxx_uart1_hwmod,
-	.clk		= "uart1_ick",
-	.addr		= omap2xxx_uart1_addr_space,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* L4 CORE -> UART2 interface */
-static struct omap_hwmod_ocp_if omap2_l4_core__uart2 = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2xxx_uart2_hwmod,
-	.clk		= "uart2_ick",
-	.addr		= omap2xxx_uart2_addr_space,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* L4 PER -> UART3 interface */
-static struct omap_hwmod_ocp_if omap2_l4_core__uart3 = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2xxx_uart3_hwmod,
-	.clk		= "uart3_ick",
-	.addr		= omap2xxx_uart3_addr_space,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
 /* L4 CORE -> I2C1 interface */
 static struct omap_hwmod_ocp_if omap2420_l4_core__i2c1 = {
 	.master		= &omap2xxx_l4_core_hwmod,
@@ -335,105 +256,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_wkup__timer1 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* l4_core -> timer2 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer2 = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2xxx_timer2_hwmod,
-	.clk		= "gpt2_ick",
-	.addr		= omap2xxx_timer2_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4_core -> timer3 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer3 = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2xxx_timer3_hwmod,
-	.clk		= "gpt3_ick",
-	.addr		= omap2xxx_timer3_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4_core -> timer4 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer4 = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2xxx_timer4_hwmod,
-	.clk		= "gpt4_ick",
-	.addr		= omap2xxx_timer4_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4_core -> timer5 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer5 = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2xxx_timer5_hwmod,
-	.clk		= "gpt5_ick",
-	.addr		= omap2xxx_timer5_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4_core -> timer6 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer6 = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2xxx_timer6_hwmod,
-	.clk		= "gpt6_ick",
-	.addr		= omap2xxx_timer6_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4_core -> timer7 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer7 = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2xxx_timer7_hwmod,
-	.clk		= "gpt7_ick",
-	.addr		= omap2xxx_timer7_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4_core -> timer8 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer8 = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2xxx_timer8_hwmod,
-	.clk		= "gpt8_ick",
-	.addr		= omap2xxx_timer8_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4_core -> timer9 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer9 = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2xxx_timer9_hwmod,
-	.clk		= "gpt9_ick",
-	.addr		= omap2xxx_timer9_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4_core -> timer10 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer10 = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2xxx_timer10_hwmod,
-	.clk		= "gpt10_ick",
-	.addr		= omap2_timer10_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4_core -> timer11 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer11 = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2xxx_timer11_hwmod,
-	.clk		= "gpt11_ick",
-	.addr		= omap2_timer11_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4_core -> timer12 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer12 = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2xxx_timer12_hwmod,
-	.clk		= "gpt12_ick",
-	.addr		= omap2xxx_timer12_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
 /* l4_wkup -> wd_timer2 */
 static struct omap_hwmod_addr_space omap2420_wd_timer2_addrs[] = {
 	{
@@ -452,67 +274,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_wkup__wd_timer2 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* l4_core -> dss */
-static struct omap_hwmod_ocp_if omap2420_l4_core__dss = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2xxx_dss_core_hwmod,
-	.clk		= "dss_ick",
-	.addr		= omap2_dss_addrs,
-	.fw = {
-		.omap2 = {
-			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_CORE_REGION,
-			.flags	= OMAP_FIREWALL_L4,
-		}
-	},
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4_core -> dss_dispc */
-static struct omap_hwmod_ocp_if omap2420_l4_core__dss_dispc = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2xxx_dss_dispc_hwmod,
-	.clk		= "dss_ick",
-	.addr		= omap2_dss_dispc_addrs,
-	.fw = {
-		.omap2 = {
-			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_DISPC_REGION,
-			.flags	= OMAP_FIREWALL_L4,
-		}
-	},
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4_core -> dss_rfbi */
-static struct omap_hwmod_ocp_if omap2420_l4_core__dss_rfbi = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2xxx_dss_rfbi_hwmod,
-	.clk		= "dss_ick",
-	.addr		= omap2_dss_rfbi_addrs,
-	.fw = {
-		.omap2 = {
-			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_CORE_REGION,
-			.flags	= OMAP_FIREWALL_L4,
-		}
-	},
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4_core -> dss_venc */
-static struct omap_hwmod_ocp_if omap2420_l4_core__dss_venc = {
-	.master		= &omap2xxx_l4_core_hwmod,
-	.slave		= &omap2xxx_dss_venc_hwmod,
-	.clk		= "dss_ick",
-	.addr		= omap2_dss_venc_addrs,
-	.fw = {
-		.omap2 = {
-			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_VENC_REGION,
-			.flags	= OMAP_FIREWALL_L4,
-		}
-	},
-	.flags		= OCPIF_SWSUP_IDLE,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
 /* l4_wkup -> gpio1 */
 static struct omap_hwmod_addr_space omap2420_gpio1_addr_space[] = {
 	{
@@ -629,12 +390,12 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp2 = {
 };
 
 static struct omap_hwmod_ocp_if *omap2420_hwmod_ocp_ifs[] __initdata = {
-	&omap2420_l3_main__l4_core,
-	&omap2420_mpu__l3_main,
-	&omap2420_dss__l3,
-	&omap2420_l4_core__mcspi1,
-	&omap2420_l4_core__mcspi2,
-	&omap2420_l4_core__l4_wkup,
+	&omap2xxx_l3_main__l4_core,
+	&omap2xxx_mpu__l3_main,
+	&omap2xxx_dss__l3,
+	&omap2xxx_l4_core__mcspi1,
+	&omap2xxx_l4_core__mcspi2,
+	&omap2xxx_l4_core__l4_wkup,
 	&omap2_l4_core__uart1,
 	&omap2_l4_core__uart2,
 	&omap2_l4_core__uart3,
@@ -642,22 +403,22 @@ static struct omap_hwmod_ocp_if *omap2420_hwmod_ocp_ifs[] __initdata = {
 	&omap2420_l4_core__i2c2,
 	&omap2420_l3__iva,
 	&omap2420_l4_wkup__timer1,
-	&omap2420_l4_core__timer2,
-	&omap2420_l4_core__timer3,
-	&omap2420_l4_core__timer4,
-	&omap2420_l4_core__timer5,
-	&omap2420_l4_core__timer6,
-	&omap2420_l4_core__timer7,
-	&omap2420_l4_core__timer8,
-	&omap2420_l4_core__timer9,
-	&omap2420_l4_core__timer10,
-	&omap2420_l4_core__timer11,
-	&omap2420_l4_core__timer12,
+	&omap2xxx_l4_core__timer2,
+	&omap2xxx_l4_core__timer3,
+	&omap2xxx_l4_core__timer4,
+	&omap2xxx_l4_core__timer5,
+	&omap2xxx_l4_core__timer6,
+	&omap2xxx_l4_core__timer7,
+	&omap2xxx_l4_core__timer8,
+	&omap2xxx_l4_core__timer9,
+	&omap2xxx_l4_core__timer10,
+	&omap2xxx_l4_core__timer11,
+	&omap2xxx_l4_core__timer12,
 	&omap2420_l4_wkup__wd_timer2,
-	&omap2420_l4_core__dss,
-	&omap2420_l4_core__dss_dispc,
-	&omap2420_l4_core__dss_rfbi,
-	&omap2420_l4_core__dss_venc,
+	&omap2xxx_l4_core__dss,
+	&omap2xxx_l4_core__dss_dispc,
+	&omap2xxx_l4_core__dss_rfbi,
+	&omap2xxx_l4_core__dss_venc,
 	&omap2420_l4_wkup__gpio1,
 	&omap2420_l4_wkup__gpio2,
 	&omap2420_l4_wkup__gpio3,

commit cb48427ef7ee274528bf0132bb69a7ca378dc9d2
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Apr 19 04:04:33 2012 -0600

    ARM: OMAP2xxx: hwmod data: share common hwmods between OMAP2420 and OMAP2430
    
    After the link registration conversion, it's much easier to share some
    hwmod data between OMAP2420 and 2430.  Move the shareable data into a
    common file.  This should save some memory and lines of source, at the
    cost of readability.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Beno√Æt Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index f74335ff4097..75c57d35bcca 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -43,417 +43,12 @@
  * IP blocks
  */
 
-/* L3 */
-static struct omap_hwmod omap2420_l3_main_hwmod = {
-	.name		= "l3_main",
-	.class		= &l3_hwmod_class,
-	.flags		= HWMOD_NO_IDLEST,
-};
-
-/* L4 CORE */
-static struct omap_hwmod omap2420_l4_core_hwmod = {
-	.name		= "l4_core",
-	.class		= &l4_hwmod_class,
-	.flags		= HWMOD_NO_IDLEST,
-};
-
-/* L4 WKUP */
-static struct omap_hwmod omap2420_l4_wkup_hwmod = {
-	.name		= "l4_wkup",
-	.class		= &l4_hwmod_class,
-	.flags		= HWMOD_NO_IDLEST,
-};
-
-/* MPU */
-static struct omap_hwmod omap2420_mpu_hwmod = {
-	.name		= "mpu",
-	.class		= &mpu_hwmod_class,
-	.main_clk	= "mpu_ck",
-};
-
 /* IVA2 (IVA2) */
 static struct omap_hwmod omap2420_iva_hwmod = {
 	.name		= "iva",
 	.class		= &iva_hwmod_class,
 };
 
-/* always-on timers dev attribute */
-static struct omap_timer_capability_dev_attr capability_alwon_dev_attr = {
-	.timer_capability	= OMAP_TIMER_ALWON,
-};
-
-/* pwm timers dev attribute */
-static struct omap_timer_capability_dev_attr capability_pwm_dev_attr = {
-	.timer_capability	= OMAP_TIMER_HAS_PWM,
-};
-
-/* timer1 */
-static struct omap_hwmod omap2420_timer1_hwmod = {
-	.name		= "timer1",
-	.mpu_irqs	= omap2_timer1_mpu_irqs,
-	.main_clk	= "gpt1_fck",
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_GPT1_SHIFT,
-			.module_offs = WKUP_MOD,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_ST_GPT1_SHIFT,
-		},
-	},
-	.dev_attr	= &capability_alwon_dev_attr,
-	.class		= &omap2xxx_timer_hwmod_class,
-};
-
-/* timer2 */
-static struct omap_hwmod omap2420_timer2_hwmod = {
-	.name		= "timer2",
-	.mpu_irqs	= omap2_timer2_mpu_irqs,
-	.main_clk	= "gpt2_fck",
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_GPT2_SHIFT,
-			.module_offs = CORE_MOD,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_ST_GPT2_SHIFT,
-		},
-	},
-	.dev_attr	= &capability_alwon_dev_attr,
-	.class		= &omap2xxx_timer_hwmod_class,
-};
-
-/* timer3 */
-static struct omap_hwmod omap2420_timer3_hwmod = {
-	.name		= "timer3",
-	.mpu_irqs	= omap2_timer3_mpu_irqs,
-	.main_clk	= "gpt3_fck",
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_GPT3_SHIFT,
-			.module_offs = CORE_MOD,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_ST_GPT3_SHIFT,
-		},
-	},
-	.dev_attr	= &capability_alwon_dev_attr,
-	.class		= &omap2xxx_timer_hwmod_class,
-};
-
-/* timer4 */
-static struct omap_hwmod omap2420_timer4_hwmod = {
-	.name		= "timer4",
-	.mpu_irqs	= omap2_timer4_mpu_irqs,
-	.main_clk	= "gpt4_fck",
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_GPT4_SHIFT,
-			.module_offs = CORE_MOD,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_ST_GPT4_SHIFT,
-		},
-	},
-	.dev_attr	= &capability_alwon_dev_attr,
-	.class		= &omap2xxx_timer_hwmod_class,
-};
-
-/* timer5 */
-static struct omap_hwmod omap2420_timer5_hwmod = {
-	.name		= "timer5",
-	.mpu_irqs	= omap2_timer5_mpu_irqs,
-	.main_clk	= "gpt5_fck",
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_GPT5_SHIFT,
-			.module_offs = CORE_MOD,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_ST_GPT5_SHIFT,
-		},
-	},
-	.dev_attr	= &capability_alwon_dev_attr,
-	.class		= &omap2xxx_timer_hwmod_class,
-};
-
-/* timer6 */
-static struct omap_hwmod omap2420_timer6_hwmod = {
-	.name		= "timer6",
-	.mpu_irqs	= omap2_timer6_mpu_irqs,
-	.main_clk	= "gpt6_fck",
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_GPT6_SHIFT,
-			.module_offs = CORE_MOD,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_ST_GPT6_SHIFT,
-		},
-	},
-	.dev_attr	= &capability_alwon_dev_attr,
-	.class		= &omap2xxx_timer_hwmod_class,
-};
-
-/* timer7 */
-static struct omap_hwmod omap2420_timer7_hwmod = {
-	.name		= "timer7",
-	.mpu_irqs	= omap2_timer7_mpu_irqs,
-	.main_clk	= "gpt7_fck",
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_GPT7_SHIFT,
-			.module_offs = CORE_MOD,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_ST_GPT7_SHIFT,
-		},
-	},
-	.dev_attr	= &capability_alwon_dev_attr,
-	.class		= &omap2xxx_timer_hwmod_class,
-};
-
-/* timer8 */
-static struct omap_hwmod omap2420_timer8_hwmod = {
-	.name		= "timer8",
-	.mpu_irqs	= omap2_timer8_mpu_irqs,
-	.main_clk	= "gpt8_fck",
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_GPT8_SHIFT,
-			.module_offs = CORE_MOD,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_ST_GPT8_SHIFT,
-		},
-	},
-	.dev_attr	= &capability_alwon_dev_attr,
-	.class		= &omap2xxx_timer_hwmod_class,
-};
-
-/* timer9 */
-static struct omap_hwmod omap2420_timer9_hwmod = {
-	.name		= "timer9",
-	.mpu_irqs	= omap2_timer9_mpu_irqs,
-	.main_clk	= "gpt9_fck",
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_GPT9_SHIFT,
-			.module_offs = CORE_MOD,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_ST_GPT9_SHIFT,
-		},
-	},
-	.dev_attr	= &capability_pwm_dev_attr,
-	.class		= &omap2xxx_timer_hwmod_class,
-};
-
-/* timer10 */
-static struct omap_hwmod omap2420_timer10_hwmod = {
-	.name		= "timer10",
-	.mpu_irqs	= omap2_timer10_mpu_irqs,
-	.main_clk	= "gpt10_fck",
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_GPT10_SHIFT,
-			.module_offs = CORE_MOD,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_ST_GPT10_SHIFT,
-		},
-	},
-	.dev_attr	= &capability_pwm_dev_attr,
-	.class		= &omap2xxx_timer_hwmod_class,
-};
-
-/* timer11 */
-static struct omap_hwmod omap2420_timer11_hwmod = {
-	.name		= "timer11",
-	.mpu_irqs	= omap2_timer11_mpu_irqs,
-	.main_clk	= "gpt11_fck",
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_GPT11_SHIFT,
-			.module_offs = CORE_MOD,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_ST_GPT11_SHIFT,
-		},
-	},
-	.dev_attr	= &capability_pwm_dev_attr,
-	.class		= &omap2xxx_timer_hwmod_class,
-};
-
-/* timer12 */
-static struct omap_hwmod omap2420_timer12_hwmod = {
-	.name		= "timer12",
-	.mpu_irqs	= omap2xxx_timer12_mpu_irqs,
-	.main_clk	= "gpt12_fck",
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_GPT12_SHIFT,
-			.module_offs = CORE_MOD,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_ST_GPT12_SHIFT,
-		},
-	},
-	.dev_attr	= &capability_pwm_dev_attr,
-	.class		= &omap2xxx_timer_hwmod_class,
-};
-
-static struct omap_hwmod omap2420_wd_timer2_hwmod = {
-	.name		= "wd_timer2",
-	.class		= &omap2xxx_wd_timer_hwmod_class,
-	.main_clk	= "mpu_wdt_fck",
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_MPU_WDT_SHIFT,
-			.module_offs = WKUP_MOD,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_ST_MPU_WDT_SHIFT,
-		},
-	},
-};
-
-/* UART1 */
-static struct omap_hwmod omap2420_uart1_hwmod = {
-	.name		= "uart1",
-	.mpu_irqs	= omap2_uart1_mpu_irqs,
-	.sdma_reqs	= omap2_uart1_sdma_reqs,
-	.main_clk	= "uart1_fck",
-	.prcm		= {
-		.omap2 = {
-			.module_offs = CORE_MOD,
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_UART1_SHIFT,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_EN_UART1_SHIFT,
-		},
-	},
-	.class		= &omap2_uart_class,
-};
-
-/* UART2 */
-static struct omap_hwmod omap2420_uart2_hwmod = {
-	.name		= "uart2",
-	.mpu_irqs	= omap2_uart2_mpu_irqs,
-	.sdma_reqs	= omap2_uart2_sdma_reqs,
-	.main_clk	= "uart2_fck",
-	.prcm		= {
-		.omap2 = {
-			.module_offs = CORE_MOD,
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_UART2_SHIFT,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_EN_UART2_SHIFT,
-		},
-	},
-	.class		= &omap2_uart_class,
-};
-
-/* UART3 */
-static struct omap_hwmod omap2420_uart3_hwmod = {
-	.name		= "uart3",
-	.mpu_irqs	= omap2_uart3_mpu_irqs,
-	.sdma_reqs	= omap2_uart3_sdma_reqs,
-	.main_clk	= "uart3_fck",
-	.prcm		= {
-		.omap2 = {
-			.module_offs = CORE_MOD,
-			.prcm_reg_id = 2,
-			.module_bit = OMAP24XX_EN_UART3_SHIFT,
-			.idlest_reg_id = 2,
-			.idlest_idle_bit = OMAP24XX_EN_UART3_SHIFT,
-		},
-	},
-	.class		= &omap2_uart_class,
-};
-
-/* dss */
-
-static struct omap_hwmod_opt_clk dss_opt_clks[] = {
-	/*
-	 * The DSS HW needs all DSS clocks enabled during reset. The dss_core
-	 * driver does not use these clocks.
-	 */
-	{ .role = "tv_clk", .clk = "dss_54m_fck" },
-	{ .role = "sys_clk", .clk = "dss2_fck" },
-};
-
-static struct omap_hwmod omap2420_dss_core_hwmod = {
-	.name		= "dss_core",
-	.class		= &omap2_dss_hwmod_class,
-	.main_clk	= "dss1_fck", /* instead of dss_fck */
-	.sdma_reqs	= omap2xxx_dss_sdma_chs,
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_DSS1_SHIFT,
-			.module_offs = CORE_MOD,
-			.idlest_reg_id = 1,
-			.idlest_stdby_bit = OMAP24XX_ST_DSS_SHIFT,
-		},
-	},
-	.opt_clks	= dss_opt_clks,
-	.opt_clks_cnt = ARRAY_SIZE(dss_opt_clks),
-	.flags		= HWMOD_NO_IDLEST | HWMOD_CONTROL_OPT_CLKS_IN_RESET,
-};
-
-static struct omap_hwmod omap2420_dss_dispc_hwmod = {
-	.name		= "dss_dispc",
-	.class		= &omap2_dispc_hwmod_class,
-	.mpu_irqs	= omap2_dispc_irqs,
-	.main_clk	= "dss1_fck",
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_DSS1_SHIFT,
-			.module_offs = CORE_MOD,
-			.idlest_reg_id = 1,
-			.idlest_stdby_bit = OMAP24XX_ST_DSS_SHIFT,
-		},
-	},
-	.flags		= HWMOD_NO_IDLEST,
-	.dev_attr	= &omap2_3_dss_dispc_dev_attr
-};
-
-static struct omap_hwmod_opt_clk dss_rfbi_opt_clks[] = {
-	{ .role = "ick", .clk = "dss_ick" },
-};
-
-static struct omap_hwmod omap2420_dss_rfbi_hwmod = {
-	.name		= "dss_rfbi",
-	.class		= &omap2_rfbi_hwmod_class,
-	.main_clk	= "dss1_fck",
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_DSS1_SHIFT,
-			.module_offs = CORE_MOD,
-		},
-	},
-	.opt_clks	= dss_rfbi_opt_clks,
-	.opt_clks_cnt	= ARRAY_SIZE(dss_rfbi_opt_clks),
-	.flags		= HWMOD_NO_IDLEST,
-};
-
-static struct omap_hwmod omap2420_dss_venc_hwmod = {
-	.name		= "dss_venc",
-	.class		= &omap2_venc_hwmod_class,
-	.main_clk	= "dss_54m_fck",
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_DSS1_SHIFT,
-			.module_offs = CORE_MOD,
-		},
-	},
-	.flags		= HWMOD_NO_IDLEST,
-};
-
 /* I2C common */
 static struct omap_hwmod_class_sysconfig i2c_sysc = {
 	.rev_offs	= 0x00,
@@ -517,88 +112,6 @@ static struct omap_hwmod omap2420_i2c2_hwmod = {
 	.flags		= HWMOD_16BIT_REG,
 };
 
-/* gpio dev_attr */
-static struct omap_gpio_dev_attr gpio_dev_attr = {
-	.bank_width = 32,
-	.dbck_flag = false,
-};
-
-/* gpio1 */
-static struct omap_hwmod omap2420_gpio1_hwmod = {
-	.name		= "gpio1",
-	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
-	.mpu_irqs	= omap2_gpio1_irqs,
-	.main_clk	= "gpios_fck",
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_GPIOS_SHIFT,
-			.module_offs = WKUP_MOD,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_ST_GPIOS_SHIFT,
-		},
-	},
-	.class		= &omap2xxx_gpio_hwmod_class,
-	.dev_attr	= &gpio_dev_attr,
-};
-
-/* gpio2 */
-static struct omap_hwmod omap2420_gpio2_hwmod = {
-	.name		= "gpio2",
-	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
-	.mpu_irqs	= omap2_gpio2_irqs,
-	.main_clk	= "gpios_fck",
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_GPIOS_SHIFT,
-			.module_offs = WKUP_MOD,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_ST_GPIOS_SHIFT,
-		},
-	},
-	.class		= &omap2xxx_gpio_hwmod_class,
-	.dev_attr	= &gpio_dev_attr,
-};
-
-/* gpio3 */
-static struct omap_hwmod omap2420_gpio3_hwmod = {
-	.name		= "gpio3",
-	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
-	.mpu_irqs	= omap2_gpio3_irqs,
-	.main_clk	= "gpios_fck",
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_GPIOS_SHIFT,
-			.module_offs = WKUP_MOD,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_ST_GPIOS_SHIFT,
-		},
-	},
-	.class		= &omap2xxx_gpio_hwmod_class,
-	.dev_attr	= &gpio_dev_attr,
-};
-
-/* gpio4 */
-static struct omap_hwmod omap2420_gpio4_hwmod = {
-	.name		= "gpio4",
-	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
-	.mpu_irqs	= omap2_gpio4_irqs,
-	.main_clk	= "gpios_fck",
-	.prcm		= {
-		.omap2 = {
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_GPIOS_SHIFT,
-			.module_offs = WKUP_MOD,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_ST_GPIOS_SHIFT,
-		},
-	},
-	.class		= &omap2xxx_gpio_hwmod_class,
-	.dev_attr	= &gpio_dev_attr,
-};
-
 /* dma attributes */
 static struct omap_dma_dev_attr dma_dev_attr = {
 	.dev_caps  = RESERVE_CHANNEL | DMA_LINKED_LCH | GLOBAL_PRIORITY |
@@ -638,52 +151,6 @@ static struct omap_hwmod omap2420_mailbox_hwmod = {
 	},
 };
 
-/* mcspi1 */
-static struct omap2_mcspi_dev_attr omap_mcspi1_dev_attr = {
-	.num_chipselect = 4,
-};
-
-static struct omap_hwmod omap2420_mcspi1_hwmod = {
-	.name		= "mcspi1",
-	.mpu_irqs	= omap2_mcspi1_mpu_irqs,
-	.sdma_reqs	= omap2_mcspi1_sdma_reqs,
-	.main_clk	= "mcspi1_fck",
-	.prcm		= {
-		.omap2 = {
-			.module_offs = CORE_MOD,
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_MCSPI1_SHIFT,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_ST_MCSPI1_SHIFT,
-		},
-	},
-	.class		= &omap2xxx_mcspi_class,
-	.dev_attr	= &omap_mcspi1_dev_attr,
-};
-
-/* mcspi2 */
-static struct omap2_mcspi_dev_attr omap_mcspi2_dev_attr = {
-	.num_chipselect = 2,
-};
-
-static struct omap_hwmod omap2420_mcspi2_hwmod = {
-	.name		= "mcspi2",
-	.mpu_irqs	= omap2_mcspi2_mpu_irqs,
-	.sdma_reqs	= omap2_mcspi2_sdma_reqs,
-	.main_clk	= "mcspi2_fck",
-	.prcm		= {
-		.omap2 = {
-			.module_offs = CORE_MOD,
-			.prcm_reg_id = 1,
-			.module_bit = OMAP24XX_EN_MCSPI2_SHIFT,
-			.idlest_reg_id = 1,
-			.idlest_idle_bit = OMAP24XX_ST_MCSPI2_SHIFT,
-		},
-	},
-	.class		= &omap2xxx_mcspi_class,
-	.dev_attr	= &omap_mcspi2_dev_attr,
-};
-
 /*
  * 'mcbsp' class
  * multi channel buffered serial port controller
@@ -747,22 +214,22 @@ static struct omap_hwmod omap2420_mcbsp2_hwmod = {
 
 /* L3 -> L4_CORE interface */
 static struct omap_hwmod_ocp_if omap2420_l3_main__l4_core = {
-	.master	= &omap2420_l3_main_hwmod,
-	.slave	= &omap2420_l4_core_hwmod,
+	.master	= &omap2xxx_l3_main_hwmod,
+	.slave	= &omap2xxx_l4_core_hwmod,
 	.user	= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
 /* MPU -> L3 interface */
 static struct omap_hwmod_ocp_if omap2420_mpu__l3_main = {
-	.master = &omap2420_mpu_hwmod,
-	.slave	= &omap2420_l3_main_hwmod,
+	.master = &omap2xxx_mpu_hwmod,
+	.slave	= &omap2xxx_l3_main_hwmod,
 	.user	= OCP_USER_MPU,
 };
 
 /* DSS -> l3 */
 static struct omap_hwmod_ocp_if omap2420_dss__l3 = {
-	.master		= &omap2420_dss_core_hwmod,
-	.slave		= &omap2420_l3_main_hwmod,
+	.master		= &omap2xxx_dss_core_hwmod,
+	.slave		= &omap2xxx_l3_main_hwmod,
 	.fw = {
 		.omap2 = {
 			.l3_perm_bit  = OMAP2_L3_CORE_FW_CONNID_DSS,
@@ -774,8 +241,8 @@ static struct omap_hwmod_ocp_if omap2420_dss__l3 = {
 
 /* l4 core -> mcspi1 interface */
 static struct omap_hwmod_ocp_if omap2420_l4_core__mcspi1 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_mcspi1_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2xxx_mcspi1_hwmod,
 	.clk		= "mcspi1_ick",
 	.addr		= omap2_mcspi1_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -783,8 +250,8 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__mcspi1 = {
 
 /* l4 core -> mcspi2 interface */
 static struct omap_hwmod_ocp_if omap2420_l4_core__mcspi2 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_mcspi2_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2xxx_mcspi2_hwmod,
 	.clk		= "mcspi2_ick",
 	.addr		= omap2_mcspi2_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -792,15 +259,15 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__mcspi2 = {
 
 /* L4_CORE -> L4_WKUP interface */
 static struct omap_hwmod_ocp_if omap2420_l4_core__l4_wkup = {
-	.master	= &omap2420_l4_core_hwmod,
-	.slave	= &omap2420_l4_wkup_hwmod,
+	.master	= &omap2xxx_l4_core_hwmod,
+	.slave	= &omap2xxx_l4_wkup_hwmod,
 	.user	= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
 /* L4 CORE -> UART1 interface */
 static struct omap_hwmod_ocp_if omap2_l4_core__uart1 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_uart1_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2xxx_uart1_hwmod,
 	.clk		= "uart1_ick",
 	.addr		= omap2xxx_uart1_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -808,8 +275,8 @@ static struct omap_hwmod_ocp_if omap2_l4_core__uart1 = {
 
 /* L4 CORE -> UART2 interface */
 static struct omap_hwmod_ocp_if omap2_l4_core__uart2 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_uart2_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2xxx_uart2_hwmod,
 	.clk		= "uart2_ick",
 	.addr		= omap2xxx_uart2_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -817,8 +284,8 @@ static struct omap_hwmod_ocp_if omap2_l4_core__uart2 = {
 
 /* L4 PER -> UART3 interface */
 static struct omap_hwmod_ocp_if omap2_l4_core__uart3 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_uart3_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2xxx_uart3_hwmod,
 	.clk		= "uart3_ick",
 	.addr		= omap2xxx_uart3_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -826,7 +293,7 @@ static struct omap_hwmod_ocp_if omap2_l4_core__uart3 = {
 
 /* L4 CORE -> I2C1 interface */
 static struct omap_hwmod_ocp_if omap2420_l4_core__i2c1 = {
-	.master		= &omap2420_l4_core_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
 	.slave		= &omap2420_i2c1_hwmod,
 	.clk		= "i2c1_ick",
 	.addr		= omap2_i2c1_addr_space,
@@ -835,7 +302,7 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__i2c1 = {
 
 /* L4 CORE -> I2C2 interface */
 static struct omap_hwmod_ocp_if omap2420_l4_core__i2c2 = {
-	.master		= &omap2420_l4_core_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
 	.slave		= &omap2420_i2c2_hwmod,
 	.clk		= "i2c2_ick",
 	.addr		= omap2_i2c2_addr_space,
@@ -844,7 +311,7 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__i2c2 = {
 
 /* IVA <- L3 interface */
 static struct omap_hwmod_ocp_if omap2420_l3__iva = {
-	.master		= &omap2420_l3_main_hwmod,
+	.master		= &omap2xxx_l3_main_hwmod,
 	.slave		= &omap2420_iva_hwmod,
 	.clk		= "iva1_ifck",
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -861,8 +328,8 @@ static struct omap_hwmod_addr_space omap2420_timer1_addrs[] = {
 
 /* l4_wkup -> timer1 */
 static struct omap_hwmod_ocp_if omap2420_l4_wkup__timer1 = {
-	.master		= &omap2420_l4_wkup_hwmod,
-	.slave		= &omap2420_timer1_hwmod,
+	.master		= &omap2xxx_l4_wkup_hwmod,
+	.slave		= &omap2xxx_timer1_hwmod,
 	.clk		= "gpt1_ick",
 	.addr		= omap2420_timer1_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -870,8 +337,8 @@ static struct omap_hwmod_ocp_if omap2420_l4_wkup__timer1 = {
 
 /* l4_core -> timer2 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer2 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer2_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2xxx_timer2_hwmod,
 	.clk		= "gpt2_ick",
 	.addr		= omap2xxx_timer2_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -879,8 +346,8 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer2 = {
 
 /* l4_core -> timer3 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer3 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer3_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2xxx_timer3_hwmod,
 	.clk		= "gpt3_ick",
 	.addr		= omap2xxx_timer3_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -888,8 +355,8 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer3 = {
 
 /* l4_core -> timer4 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer4 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer4_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2xxx_timer4_hwmod,
 	.clk		= "gpt4_ick",
 	.addr		= omap2xxx_timer4_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -897,8 +364,8 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer4 = {
 
 /* l4_core -> timer5 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer5 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer5_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2xxx_timer5_hwmod,
 	.clk		= "gpt5_ick",
 	.addr		= omap2xxx_timer5_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -906,8 +373,8 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer5 = {
 
 /* l4_core -> timer6 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer6 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer6_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2xxx_timer6_hwmod,
 	.clk		= "gpt6_ick",
 	.addr		= omap2xxx_timer6_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -915,8 +382,8 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer6 = {
 
 /* l4_core -> timer7 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer7 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer7_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2xxx_timer7_hwmod,
 	.clk		= "gpt7_ick",
 	.addr		= omap2xxx_timer7_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -924,8 +391,8 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer7 = {
 
 /* l4_core -> timer8 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer8 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer8_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2xxx_timer8_hwmod,
 	.clk		= "gpt8_ick",
 	.addr		= omap2xxx_timer8_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -933,8 +400,8 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer8 = {
 
 /* l4_core -> timer9 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer9 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer9_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2xxx_timer9_hwmod,
 	.clk		= "gpt9_ick",
 	.addr		= omap2xxx_timer9_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -942,8 +409,8 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer9 = {
 
 /* l4_core -> timer10 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer10 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer10_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2xxx_timer10_hwmod,
 	.clk		= "gpt10_ick",
 	.addr		= omap2_timer10_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -951,8 +418,8 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer10 = {
 
 /* l4_core -> timer11 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer11 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer11_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2xxx_timer11_hwmod,
 	.clk		= "gpt11_ick",
 	.addr		= omap2_timer11_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -960,8 +427,8 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer11 = {
 
 /* l4_core -> timer12 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer12 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer12_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2xxx_timer12_hwmod,
 	.clk		= "gpt12_ick",
 	.addr		= omap2xxx_timer12_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -978,8 +445,8 @@ static struct omap_hwmod_addr_space omap2420_wd_timer2_addrs[] = {
 };
 
 static struct omap_hwmod_ocp_if omap2420_l4_wkup__wd_timer2 = {
-	.master		= &omap2420_l4_wkup_hwmod,
-	.slave		= &omap2420_wd_timer2_hwmod,
+	.master		= &omap2xxx_l4_wkup_hwmod,
+	.slave		= &omap2xxx_wd_timer2_hwmod,
 	.clk		= "mpu_wdt_ick",
 	.addr		= omap2420_wd_timer2_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -987,8 +454,8 @@ static struct omap_hwmod_ocp_if omap2420_l4_wkup__wd_timer2 = {
 
 /* l4_core -> dss */
 static struct omap_hwmod_ocp_if omap2420_l4_core__dss = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_dss_core_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2xxx_dss_core_hwmod,
 	.clk		= "dss_ick",
 	.addr		= omap2_dss_addrs,
 	.fw = {
@@ -1002,8 +469,8 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__dss = {
 
 /* l4_core -> dss_dispc */
 static struct omap_hwmod_ocp_if omap2420_l4_core__dss_dispc = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_dss_dispc_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2xxx_dss_dispc_hwmod,
 	.clk		= "dss_ick",
 	.addr		= omap2_dss_dispc_addrs,
 	.fw = {
@@ -1017,8 +484,8 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__dss_dispc = {
 
 /* l4_core -> dss_rfbi */
 static struct omap_hwmod_ocp_if omap2420_l4_core__dss_rfbi = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_dss_rfbi_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2xxx_dss_rfbi_hwmod,
 	.clk		= "dss_ick",
 	.addr		= omap2_dss_rfbi_addrs,
 	.fw = {
@@ -1032,8 +499,8 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__dss_rfbi = {
 
 /* l4_core -> dss_venc */
 static struct omap_hwmod_ocp_if omap2420_l4_core__dss_venc = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_dss_venc_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
+	.slave		= &omap2xxx_dss_venc_hwmod,
 	.clk		= "dss_ick",
 	.addr		= omap2_dss_venc_addrs,
 	.fw = {
@@ -1057,8 +524,8 @@ static struct omap_hwmod_addr_space omap2420_gpio1_addr_space[] = {
 };
 
 static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio1 = {
-	.master		= &omap2420_l4_wkup_hwmod,
-	.slave		= &omap2420_gpio1_hwmod,
+	.master		= &omap2xxx_l4_wkup_hwmod,
+	.slave		= &omap2xxx_gpio1_hwmod,
 	.clk		= "gpios_ick",
 	.addr		= omap2420_gpio1_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -1075,8 +542,8 @@ static struct omap_hwmod_addr_space omap2420_gpio2_addr_space[] = {
 };
 
 static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio2 = {
-	.master		= &omap2420_l4_wkup_hwmod,
-	.slave		= &omap2420_gpio2_hwmod,
+	.master		= &omap2xxx_l4_wkup_hwmod,
+	.slave		= &omap2xxx_gpio2_hwmod,
 	.clk		= "gpios_ick",
 	.addr		= omap2420_gpio2_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -1093,8 +560,8 @@ static struct omap_hwmod_addr_space omap2420_gpio3_addr_space[] = {
 };
 
 static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio3 = {
-	.master		= &omap2420_l4_wkup_hwmod,
-	.slave		= &omap2420_gpio3_hwmod,
+	.master		= &omap2xxx_l4_wkup_hwmod,
+	.slave		= &omap2xxx_gpio3_hwmod,
 	.clk		= "gpios_ick",
 	.addr		= omap2420_gpio3_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -1111,8 +578,8 @@ static struct omap_hwmod_addr_space omap2420_gpio4_addr_space[] = {
 };
 
 static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio4 = {
-	.master		= &omap2420_l4_wkup_hwmod,
-	.slave		= &omap2420_gpio4_hwmod,
+	.master		= &omap2xxx_l4_wkup_hwmod,
+	.slave		= &omap2xxx_gpio4_hwmod,
 	.clk		= "gpios_ick",
 	.addr		= omap2420_gpio4_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -1121,14 +588,14 @@ static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio4 = {
 /* dma_system -> L3 */
 static struct omap_hwmod_ocp_if omap2420_dma_system__l3 = {
 	.master		= &omap2420_dma_system_hwmod,
-	.slave		= &omap2420_l3_main_hwmod,
+	.slave		= &omap2xxx_l3_main_hwmod,
 	.clk		= "core_l3_ck",
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
 /* l4_core -> dma_system */
 static struct omap_hwmod_ocp_if omap2420_l4_core__dma_system = {
-	.master		= &omap2420_l4_core_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
 	.slave		= &omap2420_dma_system_hwmod,
 	.clk		= "sdma_ick",
 	.addr		= omap2_dma_system_addrs,
@@ -1137,7 +604,7 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__dma_system = {
 
 /* l4_core -> mailbox */
 static struct omap_hwmod_ocp_if omap2420_l4_core__mailbox = {
-	.master		= &omap2420_l4_core_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
 	.slave		= &omap2420_mailbox_hwmod,
 	.addr		= omap2_mailbox_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
@@ -1145,7 +612,7 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__mailbox = {
 
 /* l4_core -> mcbsp1 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp1 = {
-	.master		= &omap2420_l4_core_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
 	.slave		= &omap2420_mcbsp1_hwmod,
 	.clk		= "mcbsp1_ick",
 	.addr		= omap2_mcbsp1_addrs,
@@ -1154,7 +621,7 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp1 = {
 
 /* l4_core -> mcbsp2 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp2 = {
-	.master		= &omap2420_l4_core_hwmod,
+	.master		= &omap2xxx_l4_core_hwmod,
 	.slave		= &omap2420_mcbsp2_hwmod,
 	.clk		= "mcbsp2_ick",
 	.addr		= omap2xxx_mcbsp2_addrs,

commit 844a3b632b76f5d5e85eb9b9edfbd7de41e4999f
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Apr 19 04:04:33 2012 -0600

    ARM: OMAP2+: hwmod data: remove forward declarations, reorganize
    
    Reorganize the hwmod data to declare the IP blocks first and the
    interconnects second.  This allows us to remove the forward
    declarations, which this patch also does. Saves some lines of source
    data.  While here, take the opportunity to synchronize the order of
    the OMAP44xx hwmod data with the autogenerator output -- it's slightly
    different due to past mismerges -- and fix a few minor typos and
    whitespace problems in the files.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Beno√Æt Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 42921ff12e86..f74335ff4097 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -33,55 +33,15 @@
 /*
  * OMAP2420 hardware module integration data
  *
- * ALl of the data in this section should be autogeneratable from the
+ * All of the data in this section should be autogeneratable from the
  * TI hardware database or other technical documentation.  Data that
  * is driver-specific or driver-kernel integration-specific belongs
  * elsewhere.
  */
 
-static struct omap_hwmod omap2420_mpu_hwmod;
-static struct omap_hwmod omap2420_iva_hwmod;
-static struct omap_hwmod omap2420_l3_main_hwmod;
-static struct omap_hwmod omap2420_l4_core_hwmod;
-static struct omap_hwmod omap2420_dss_core_hwmod;
-static struct omap_hwmod omap2420_dss_dispc_hwmod;
-static struct omap_hwmod omap2420_dss_rfbi_hwmod;
-static struct omap_hwmod omap2420_dss_venc_hwmod;
-static struct omap_hwmod omap2420_wd_timer2_hwmod;
-static struct omap_hwmod omap2420_gpio1_hwmod;
-static struct omap_hwmod omap2420_gpio2_hwmod;
-static struct omap_hwmod omap2420_gpio3_hwmod;
-static struct omap_hwmod omap2420_gpio4_hwmod;
-static struct omap_hwmod omap2420_dma_system_hwmod;
-static struct omap_hwmod omap2420_mcspi1_hwmod;
-static struct omap_hwmod omap2420_mcspi2_hwmod;
-
-/* L3 -> L4_CORE interface */
-static struct omap_hwmod_ocp_if omap2420_l3_main__l4_core = {
-	.master	= &omap2420_l3_main_hwmod,
-	.slave	= &omap2420_l4_core_hwmod,
-	.user	= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* MPU -> L3 interface */
-static struct omap_hwmod_ocp_if omap2420_mpu__l3_main = {
-	.master = &omap2420_mpu_hwmod,
-	.slave	= &omap2420_l3_main_hwmod,
-	.user	= OCP_USER_MPU,
-};
-
-/* DSS -> l3 */
-static struct omap_hwmod_ocp_if omap2420_dss__l3 = {
-	.master		= &omap2420_dss_core_hwmod,
-	.slave		= &omap2420_l3_main_hwmod,
-	.fw = {
-		.omap2 = {
-			.l3_perm_bit  = OMAP2_L3_CORE_FW_CONNID_DSS,
-			.flags	= OMAP_FIREWALL_L3,
-		}
-	},
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
+/*
+ * IP blocks
+ */
 
 /* L3 */
 static struct omap_hwmod omap2420_l3_main_hwmod = {
@@ -90,85 +50,6 @@ static struct omap_hwmod omap2420_l3_main_hwmod = {
 	.flags		= HWMOD_NO_IDLEST,
 };
 
-static struct omap_hwmod omap2420_l4_wkup_hwmod;
-static struct omap_hwmod omap2420_uart1_hwmod;
-static struct omap_hwmod omap2420_uart2_hwmod;
-static struct omap_hwmod omap2420_uart3_hwmod;
-static struct omap_hwmod omap2420_i2c1_hwmod;
-static struct omap_hwmod omap2420_i2c2_hwmod;
-static struct omap_hwmod omap2420_mcbsp1_hwmod;
-static struct omap_hwmod omap2420_mcbsp2_hwmod;
-
-/* l4 core -> mcspi1 interface */
-static struct omap_hwmod_ocp_if omap2420_l4_core__mcspi1 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_mcspi1_hwmod,
-	.clk		= "mcspi1_ick",
-	.addr		= omap2_mcspi1_addr_space,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4 core -> mcspi2 interface */
-static struct omap_hwmod_ocp_if omap2420_l4_core__mcspi2 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_mcspi2_hwmod,
-	.clk		= "mcspi2_ick",
-	.addr		= omap2_mcspi2_addr_space,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* L4_CORE -> L4_WKUP interface */
-static struct omap_hwmod_ocp_if omap2420_l4_core__l4_wkup = {
-	.master	= &omap2420_l4_core_hwmod,
-	.slave	= &omap2420_l4_wkup_hwmod,
-	.user	= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* L4 CORE -> UART1 interface */
-static struct omap_hwmod_ocp_if omap2_l4_core__uart1 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_uart1_hwmod,
-	.clk		= "uart1_ick",
-	.addr		= omap2xxx_uart1_addr_space,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* L4 CORE -> UART2 interface */
-static struct omap_hwmod_ocp_if omap2_l4_core__uart2 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_uart2_hwmod,
-	.clk		= "uart2_ick",
-	.addr		= omap2xxx_uart2_addr_space,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* L4 PER -> UART3 interface */
-static struct omap_hwmod_ocp_if omap2_l4_core__uart3 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_uart3_hwmod,
-	.clk		= "uart3_ick",
-	.addr		= omap2xxx_uart3_addr_space,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* L4 CORE -> I2C1 interface */
-static struct omap_hwmod_ocp_if omap2420_l4_core__i2c1 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_i2c1_hwmod,
-	.clk		= "i2c1_ick",
-	.addr		= omap2_i2c1_addr_space,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* L4 CORE -> I2C2 interface */
-static struct omap_hwmod_ocp_if omap2420_l4_core__i2c2 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_i2c2_hwmod,
-	.clk		= "i2c2_ick",
-	.addr		= omap2_i2c2_addr_space,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
 /* L4 CORE */
 static struct omap_hwmod omap2420_l4_core_hwmod = {
 	.name		= "l4_core",
@@ -190,22 +71,7 @@ static struct omap_hwmod omap2420_mpu_hwmod = {
 	.main_clk	= "mpu_ck",
 };
 
-/*
- * IVA1 interface data
- */
-
-/* IVA <- L3 interface */
-static struct omap_hwmod_ocp_if omap2420_l3__iva = {
-	.master		= &omap2420_l3_main_hwmod,
-	.slave		= &omap2420_iva_hwmod,
-	.clk		= "iva1_ifck",
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/*
- * IVA2 (IVA2)
- */
-
+/* IVA2 (IVA2) */
 static struct omap_hwmod omap2420_iva_hwmod = {
 	.name		= "iva",
 	.class		= &iva_hwmod_class,
@@ -213,36 +79,15 @@ static struct omap_hwmod omap2420_iva_hwmod = {
 
 /* always-on timers dev attribute */
 static struct omap_timer_capability_dev_attr capability_alwon_dev_attr = {
-	.timer_capability       = OMAP_TIMER_ALWON,
+	.timer_capability	= OMAP_TIMER_ALWON,
 };
 
 /* pwm timers dev attribute */
 static struct omap_timer_capability_dev_attr capability_pwm_dev_attr = {
-	.timer_capability       = OMAP_TIMER_HAS_PWM,
+	.timer_capability	= OMAP_TIMER_HAS_PWM,
 };
 
 /* timer1 */
-static struct omap_hwmod omap2420_timer1_hwmod;
-
-static struct omap_hwmod_addr_space omap2420_timer1_addrs[] = {
-	{
-		.pa_start	= 0x48028000,
-		.pa_end		= 0x48028000 + SZ_1K - 1,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
-/* l4_wkup -> timer1 */
-static struct omap_hwmod_ocp_if omap2420_l4_wkup__timer1 = {
-	.master		= &omap2420_l4_wkup_hwmod,
-	.slave		= &omap2420_timer1_hwmod,
-	.clk		= "gpt1_ick",
-	.addr		= omap2420_timer1_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* timer1 hwmod */
 static struct omap_hwmod omap2420_timer1_hwmod = {
 	.name		= "timer1",
 	.mpu_irqs	= omap2_timer1_mpu_irqs,
@@ -261,18 +106,6 @@ static struct omap_hwmod omap2420_timer1_hwmod = {
 };
 
 /* timer2 */
-static struct omap_hwmod omap2420_timer2_hwmod;
-
-/* l4_core -> timer2 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer2 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer2_hwmod,
-	.clk		= "gpt2_ick",
-	.addr		= omap2xxx_timer2_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* timer2 hwmod */
 static struct omap_hwmod omap2420_timer2_hwmod = {
 	.name		= "timer2",
 	.mpu_irqs	= omap2_timer2_mpu_irqs,
@@ -291,18 +124,6 @@ static struct omap_hwmod omap2420_timer2_hwmod = {
 };
 
 /* timer3 */
-static struct omap_hwmod omap2420_timer3_hwmod;
-
-/* l4_core -> timer3 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer3 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer3_hwmod,
-	.clk		= "gpt3_ick",
-	.addr		= omap2xxx_timer3_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* timer3 hwmod */
 static struct omap_hwmod omap2420_timer3_hwmod = {
 	.name		= "timer3",
 	.mpu_irqs	= omap2_timer3_mpu_irqs,
@@ -321,18 +142,6 @@ static struct omap_hwmod omap2420_timer3_hwmod = {
 };
 
 /* timer4 */
-static struct omap_hwmod omap2420_timer4_hwmod;
-
-/* l4_core -> timer4 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer4 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer4_hwmod,
-	.clk		= "gpt4_ick",
-	.addr		= omap2xxx_timer4_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* timer4 hwmod */
 static struct omap_hwmod omap2420_timer4_hwmod = {
 	.name		= "timer4",
 	.mpu_irqs	= omap2_timer4_mpu_irqs,
@@ -351,18 +160,6 @@ static struct omap_hwmod omap2420_timer4_hwmod = {
 };
 
 /* timer5 */
-static struct omap_hwmod omap2420_timer5_hwmod;
-
-/* l4_core -> timer5 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer5 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer5_hwmod,
-	.clk		= "gpt5_ick",
-	.addr		= omap2xxx_timer5_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* timer5 hwmod */
 static struct omap_hwmod omap2420_timer5_hwmod = {
 	.name		= "timer5",
 	.mpu_irqs	= omap2_timer5_mpu_irqs,
@@ -380,20 +177,7 @@ static struct omap_hwmod omap2420_timer5_hwmod = {
 	.class		= &omap2xxx_timer_hwmod_class,
 };
 
-
 /* timer6 */
-static struct omap_hwmod omap2420_timer6_hwmod;
-
-/* l4_core -> timer6 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer6 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer6_hwmod,
-	.clk		= "gpt6_ick",
-	.addr		= omap2xxx_timer6_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* timer6 hwmod */
 static struct omap_hwmod omap2420_timer6_hwmod = {
 	.name		= "timer6",
 	.mpu_irqs	= omap2_timer6_mpu_irqs,
@@ -412,18 +196,6 @@ static struct omap_hwmod omap2420_timer6_hwmod = {
 };
 
 /* timer7 */
-static struct omap_hwmod omap2420_timer7_hwmod;
-
-/* l4_core -> timer7 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer7 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer7_hwmod,
-	.clk		= "gpt7_ick",
-	.addr		= omap2xxx_timer7_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* timer7 hwmod */
 static struct omap_hwmod omap2420_timer7_hwmod = {
 	.name		= "timer7",
 	.mpu_irqs	= omap2_timer7_mpu_irqs,
@@ -442,18 +214,6 @@ static struct omap_hwmod omap2420_timer7_hwmod = {
 };
 
 /* timer8 */
-static struct omap_hwmod omap2420_timer8_hwmod;
-
-/* l4_core -> timer8 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer8 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer8_hwmod,
-	.clk		= "gpt8_ick",
-	.addr		= omap2xxx_timer8_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* timer8 hwmod */
 static struct omap_hwmod omap2420_timer8_hwmod = {
 	.name		= "timer8",
 	.mpu_irqs	= omap2_timer8_mpu_irqs,
@@ -472,18 +232,6 @@ static struct omap_hwmod omap2420_timer8_hwmod = {
 };
 
 /* timer9 */
-static struct omap_hwmod omap2420_timer9_hwmod;
-
-/* l4_core -> timer9 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer9 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer9_hwmod,
-	.clk		= "gpt9_ick",
-	.addr		= omap2xxx_timer9_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* timer9 hwmod */
 static struct omap_hwmod omap2420_timer9_hwmod = {
 	.name		= "timer9",
 	.mpu_irqs	= omap2_timer9_mpu_irqs,
@@ -502,18 +250,6 @@ static struct omap_hwmod omap2420_timer9_hwmod = {
 };
 
 /* timer10 */
-static struct omap_hwmod omap2420_timer10_hwmod;
-
-/* l4_core -> timer10 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer10 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer10_hwmod,
-	.clk		= "gpt10_ick",
-	.addr		= omap2_timer10_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* timer10 hwmod */
 static struct omap_hwmod omap2420_timer10_hwmod = {
 	.name		= "timer10",
 	.mpu_irqs	= omap2_timer10_mpu_irqs,
@@ -532,18 +268,6 @@ static struct omap_hwmod omap2420_timer10_hwmod = {
 };
 
 /* timer11 */
-static struct omap_hwmod omap2420_timer11_hwmod;
-
-/* l4_core -> timer11 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer11 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer11_hwmod,
-	.clk		= "gpt11_ick",
-	.addr		= omap2_timer11_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* timer11 hwmod */
 static struct omap_hwmod omap2420_timer11_hwmod = {
 	.name		= "timer11",
 	.mpu_irqs	= omap2_timer11_mpu_irqs,
@@ -562,18 +286,6 @@ static struct omap_hwmod omap2420_timer11_hwmod = {
 };
 
 /* timer12 */
-static struct omap_hwmod omap2420_timer12_hwmod;
-
-/* l4_core -> timer12 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__timer12 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_timer12_hwmod,
-	.clk		= "gpt12_ick",
-	.addr		= omap2xxx_timer12_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* timer12 hwmod */
 static struct omap_hwmod omap2420_timer12_hwmod = {
 	.name		= "timer12",
 	.mpu_irqs	= omap2xxx_timer12_mpu_irqs,
@@ -591,24 +303,6 @@ static struct omap_hwmod omap2420_timer12_hwmod = {
 	.class		= &omap2xxx_timer_hwmod_class,
 };
 
-/* l4_wkup -> wd_timer2 */
-static struct omap_hwmod_addr_space omap2420_wd_timer2_addrs[] = {
-	{
-		.pa_start	= 0x48022000,
-		.pa_end		= 0x4802207f,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
-static struct omap_hwmod_ocp_if omap2420_l4_wkup__wd_timer2 = {
-	.master		= &omap2420_l4_wkup_hwmod,
-	.slave		= &omap2420_wd_timer2_hwmod,
-	.clk		= "mpu_wdt_ick",
-	.addr		= omap2420_wd_timer2_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
 static struct omap_hwmod omap2420_wd_timer2_hwmod = {
 	.name		= "wd_timer2",
 	.class		= &omap2xxx_wd_timer_hwmod_class,
@@ -625,7 +319,6 @@ static struct omap_hwmod omap2420_wd_timer2_hwmod = {
 };
 
 /* UART1 */
-
 static struct omap_hwmod omap2420_uart1_hwmod = {
 	.name		= "uart1",
 	.mpu_irqs	= omap2_uart1_mpu_irqs,
@@ -644,7 +337,6 @@ static struct omap_hwmod omap2420_uart1_hwmod = {
 };
 
 /* UART2 */
-
 static struct omap_hwmod omap2420_uart2_hwmod = {
 	.name		= "uart2",
 	.mpu_irqs	= omap2_uart2_mpu_irqs,
@@ -663,7 +355,6 @@ static struct omap_hwmod omap2420_uart2_hwmod = {
 };
 
 /* UART3 */
-
 static struct omap_hwmod omap2420_uart3_hwmod = {
 	.name		= "uart3",
 	.mpu_irqs	= omap2_uart3_mpu_irqs,
@@ -683,21 +374,6 @@ static struct omap_hwmod omap2420_uart3_hwmod = {
 
 /* dss */
 
-/* l4_core -> dss */
-static struct omap_hwmod_ocp_if omap2420_l4_core__dss = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_dss_core_hwmod,
-	.clk		= "dss_ick",
-	.addr		= omap2_dss_addrs,
-	.fw = {
-		.omap2 = {
-			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_CORE_REGION,
-			.flags	= OMAP_FIREWALL_L4,
-		}
-	},
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
 static struct omap_hwmod_opt_clk dss_opt_clks[] = {
 	/*
 	 * The DSS HW needs all DSS clocks enabled during reset. The dss_core
@@ -726,21 +402,6 @@ static struct omap_hwmod omap2420_dss_core_hwmod = {
 	.flags		= HWMOD_NO_IDLEST | HWMOD_CONTROL_OPT_CLKS_IN_RESET,
 };
 
-/* l4_core -> dss_dispc */
-static struct omap_hwmod_ocp_if omap2420_l4_core__dss_dispc = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_dss_dispc_hwmod,
-	.clk		= "dss_ick",
-	.addr		= omap2_dss_dispc_addrs,
-	.fw = {
-		.omap2 = {
-			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_DISPC_REGION,
-			.flags	= OMAP_FIREWALL_L4,
-		}
-	},
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
 static struct omap_hwmod omap2420_dss_dispc_hwmod = {
 	.name		= "dss_dispc",
 	.class		= &omap2_dispc_hwmod_class,
@@ -759,21 +420,6 @@ static struct omap_hwmod omap2420_dss_dispc_hwmod = {
 	.dev_attr	= &omap2_3_dss_dispc_dev_attr
 };
 
-/* l4_core -> dss_rfbi */
-static struct omap_hwmod_ocp_if omap2420_l4_core__dss_rfbi = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_dss_rfbi_hwmod,
-	.clk		= "dss_ick",
-	.addr		= omap2_dss_rfbi_addrs,
-	.fw = {
-		.omap2 = {
-			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_CORE_REGION,
-			.flags	= OMAP_FIREWALL_L4,
-		}
-	},
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
 static struct omap_hwmod_opt_clk dss_rfbi_opt_clks[] = {
 	{ .role = "ick", .clk = "dss_ick" },
 };
@@ -794,21 +440,6 @@ static struct omap_hwmod omap2420_dss_rfbi_hwmod = {
 	.flags		= HWMOD_NO_IDLEST,
 };
 
-/* l4_core -> dss_venc */
-static struct omap_hwmod_ocp_if omap2420_l4_core__dss_venc = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_dss_venc_hwmod,
-	.clk		= "dss_ick",
-	.addr		= omap2_dss_venc_addrs,
-	.fw = {
-		.omap2 = {
-			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_VENC_REGION,
-			.flags	= OMAP_FIREWALL_L4,
-		}
-	},
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
 static struct omap_hwmod omap2420_dss_venc_hwmod = {
 	.name		= "dss_venc",
 	.class		= &omap2_venc_hwmod_class,
@@ -847,7 +478,6 @@ static struct omap_i2c_dev_attr i2c_dev_attr = {
 };
 
 /* I2C1 */
-
 static struct omap_hwmod omap2420_i2c1_hwmod = {
 	.name		= "i2c1",
 	.mpu_irqs	= omap2_i2c1_mpu_irqs,
@@ -868,7 +498,6 @@ static struct omap_hwmod omap2420_i2c1_hwmod = {
 };
 
 /* I2C2 */
-
 static struct omap_hwmod omap2420_i2c2_hwmod = {
 	.name		= "i2c2",
 	.mpu_irqs	= omap2_i2c2_mpu_irqs,
@@ -888,78 +517,6 @@ static struct omap_hwmod omap2420_i2c2_hwmod = {
 	.flags		= HWMOD_16BIT_REG,
 };
 
-/* l4_wkup -> gpio1 */
-static struct omap_hwmod_addr_space omap2420_gpio1_addr_space[] = {
-	{
-		.pa_start	= 0x48018000,
-		.pa_end		= 0x480181ff,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
-static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio1 = {
-	.master		= &omap2420_l4_wkup_hwmod,
-	.slave		= &omap2420_gpio1_hwmod,
-	.clk		= "gpios_ick",
-	.addr		= omap2420_gpio1_addr_space,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4_wkup -> gpio2 */
-static struct omap_hwmod_addr_space omap2420_gpio2_addr_space[] = {
-	{
-		.pa_start	= 0x4801a000,
-		.pa_end		= 0x4801a1ff,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
-static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio2 = {
-	.master		= &omap2420_l4_wkup_hwmod,
-	.slave		= &omap2420_gpio2_hwmod,
-	.clk		= "gpios_ick",
-	.addr		= omap2420_gpio2_addr_space,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4_wkup -> gpio3 */
-static struct omap_hwmod_addr_space omap2420_gpio3_addr_space[] = {
-	{
-		.pa_start	= 0x4801c000,
-		.pa_end		= 0x4801c1ff,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
-static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio3 = {
-	.master		= &omap2420_l4_wkup_hwmod,
-	.slave		= &omap2420_gpio3_hwmod,
-	.clk		= "gpios_ick",
-	.addr		= omap2420_gpio3_addr_space,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4_wkup -> gpio4 */
-static struct omap_hwmod_addr_space omap2420_gpio4_addr_space[] = {
-	{
-		.pa_start	= 0x4801e000,
-		.pa_end		= 0x4801e1ff,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
-static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio4 = {
-	.master		= &omap2420_l4_wkup_hwmod,
-	.slave		= &omap2420_gpio4_hwmod,
-	.clk		= "gpios_ick",
-	.addr		= omap2420_gpio4_addr_space,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
 /* gpio dev_attr */
 static struct omap_gpio_dev_attr gpio_dev_attr = {
 	.bank_width = 32,
@@ -1049,23 +606,6 @@ static struct omap_dma_dev_attr dma_dev_attr = {
 	.lch_count = 32,
 };
 
-/* dma_system -> L3 */
-static struct omap_hwmod_ocp_if omap2420_dma_system__l3 = {
-	.master		= &omap2420_dma_system_hwmod,
-	.slave		= &omap2420_l3_main_hwmod,
-	.clk		= "core_l3_ck",
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
-/* l4_core -> dma_system */
-static struct omap_hwmod_ocp_if omap2420_l4_core__dma_system = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_dma_system_hwmod,
-	.clk		= "sdma_ick",
-	.addr		= omap2_dma_system_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
 static struct omap_hwmod omap2420_dma_system_hwmod = {
 	.name		= "dma",
 	.class		= &omap2xxx_dma_hwmod_class,
@@ -1076,21 +616,12 @@ static struct omap_hwmod omap2420_dma_system_hwmod = {
 };
 
 /* mailbox */
-static struct omap_hwmod omap2420_mailbox_hwmod;
 static struct omap_hwmod_irq_info omap2420_mailbox_irqs[] = {
 	{ .name = "dsp", .irq = 26 },
 	{ .name = "iva", .irq = 34 },
 	{ .irq = -1 }
 };
 
-/* l4_core -> mailbox */
-static struct omap_hwmod_ocp_if omap2420_l4_core__mailbox = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_mailbox_hwmod,
-	.addr		= omap2_mailbox_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
 static struct omap_hwmod omap2420_mailbox_hwmod = {
 	.name		= "mailbox",
 	.class		= &omap2xxx_mailbox_hwmod_class,
@@ -1169,15 +700,6 @@ static struct omap_hwmod_irq_info omap2420_mcbsp1_irqs[] = {
 	{ .irq = -1 }
 };
 
-/* l4_core -> mcbsp1 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp1 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_mcbsp1_hwmod,
-	.clk		= "mcbsp1_ick",
-	.addr		= omap2_mcbsp1_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
 static struct omap_hwmod omap2420_mcbsp1_hwmod = {
 	.name		= "mcbsp1",
 	.class		= &omap2420_mcbsp_hwmod_class,
@@ -1202,15 +724,6 @@ static struct omap_hwmod_irq_info omap2420_mcbsp2_irqs[] = {
 	{ .irq = -1 }
 };
 
-/* l4_core -> mcbsp2 */
-static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp2 = {
-	.master		= &omap2420_l4_core_hwmod,
-	.slave		= &omap2420_mcbsp2_hwmod,
-	.clk		= "mcbsp2_ick",
-	.addr		= omap2xxx_mcbsp2_addrs,
-	.user		= OCP_USER_MPU | OCP_USER_SDMA,
-};
-
 static struct omap_hwmod omap2420_mcbsp2_hwmod = {
 	.name		= "mcbsp2",
 	.class		= &omap2420_mcbsp_hwmod_class,
@@ -1228,6 +741,426 @@ static struct omap_hwmod omap2420_mcbsp2_hwmod = {
 	},
 };
 
+/*
+ * interfaces
+ */
+
+/* L3 -> L4_CORE interface */
+static struct omap_hwmod_ocp_if omap2420_l3_main__l4_core = {
+	.master	= &omap2420_l3_main_hwmod,
+	.slave	= &omap2420_l4_core_hwmod,
+	.user	= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* MPU -> L3 interface */
+static struct omap_hwmod_ocp_if omap2420_mpu__l3_main = {
+	.master = &omap2420_mpu_hwmod,
+	.slave	= &omap2420_l3_main_hwmod,
+	.user	= OCP_USER_MPU,
+};
+
+/* DSS -> l3 */
+static struct omap_hwmod_ocp_if omap2420_dss__l3 = {
+	.master		= &omap2420_dss_core_hwmod,
+	.slave		= &omap2420_l3_main_hwmod,
+	.fw = {
+		.omap2 = {
+			.l3_perm_bit  = OMAP2_L3_CORE_FW_CONNID_DSS,
+			.flags	= OMAP_FIREWALL_L3,
+		}
+	},
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4 core -> mcspi1 interface */
+static struct omap_hwmod_ocp_if omap2420_l4_core__mcspi1 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_mcspi1_hwmod,
+	.clk		= "mcspi1_ick",
+	.addr		= omap2_mcspi1_addr_space,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4 core -> mcspi2 interface */
+static struct omap_hwmod_ocp_if omap2420_l4_core__mcspi2 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_mcspi2_hwmod,
+	.clk		= "mcspi2_ick",
+	.addr		= omap2_mcspi2_addr_space,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* L4_CORE -> L4_WKUP interface */
+static struct omap_hwmod_ocp_if omap2420_l4_core__l4_wkup = {
+	.master	= &omap2420_l4_core_hwmod,
+	.slave	= &omap2420_l4_wkup_hwmod,
+	.user	= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* L4 CORE -> UART1 interface */
+static struct omap_hwmod_ocp_if omap2_l4_core__uart1 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_uart1_hwmod,
+	.clk		= "uart1_ick",
+	.addr		= omap2xxx_uart1_addr_space,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* L4 CORE -> UART2 interface */
+static struct omap_hwmod_ocp_if omap2_l4_core__uart2 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_uart2_hwmod,
+	.clk		= "uart2_ick",
+	.addr		= omap2xxx_uart2_addr_space,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* L4 PER -> UART3 interface */
+static struct omap_hwmod_ocp_if omap2_l4_core__uart3 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_uart3_hwmod,
+	.clk		= "uart3_ick",
+	.addr		= omap2xxx_uart3_addr_space,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* L4 CORE -> I2C1 interface */
+static struct omap_hwmod_ocp_if omap2420_l4_core__i2c1 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_i2c1_hwmod,
+	.clk		= "i2c1_ick",
+	.addr		= omap2_i2c1_addr_space,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* L4 CORE -> I2C2 interface */
+static struct omap_hwmod_ocp_if omap2420_l4_core__i2c2 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_i2c2_hwmod,
+	.clk		= "i2c2_ick",
+	.addr		= omap2_i2c2_addr_space,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* IVA <- L3 interface */
+static struct omap_hwmod_ocp_if omap2420_l3__iva = {
+	.master		= &omap2420_l3_main_hwmod,
+	.slave		= &omap2420_iva_hwmod,
+	.clk		= "iva1_ifck",
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+static struct omap_hwmod_addr_space omap2420_timer1_addrs[] = {
+	{
+		.pa_start	= 0x48028000,
+		.pa_end		= 0x48028000 + SZ_1K - 1,
+		.flags		= ADDR_TYPE_RT
+	},
+	{ }
+};
+
+/* l4_wkup -> timer1 */
+static struct omap_hwmod_ocp_if omap2420_l4_wkup__timer1 = {
+	.master		= &omap2420_l4_wkup_hwmod,
+	.slave		= &omap2420_timer1_hwmod,
+	.clk		= "gpt1_ick",
+	.addr		= omap2420_timer1_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_core -> timer2 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer2 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer2_hwmod,
+	.clk		= "gpt2_ick",
+	.addr		= omap2xxx_timer2_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_core -> timer3 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer3 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer3_hwmod,
+	.clk		= "gpt3_ick",
+	.addr		= omap2xxx_timer3_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_core -> timer4 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer4 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer4_hwmod,
+	.clk		= "gpt4_ick",
+	.addr		= omap2xxx_timer4_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_core -> timer5 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer5 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer5_hwmod,
+	.clk		= "gpt5_ick",
+	.addr		= omap2xxx_timer5_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_core -> timer6 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer6 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer6_hwmod,
+	.clk		= "gpt6_ick",
+	.addr		= omap2xxx_timer6_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_core -> timer7 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer7 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer7_hwmod,
+	.clk		= "gpt7_ick",
+	.addr		= omap2xxx_timer7_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_core -> timer8 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer8 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer8_hwmod,
+	.clk		= "gpt8_ick",
+	.addr		= omap2xxx_timer8_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_core -> timer9 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer9 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer9_hwmod,
+	.clk		= "gpt9_ick",
+	.addr		= omap2xxx_timer9_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_core -> timer10 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer10 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer10_hwmod,
+	.clk		= "gpt10_ick",
+	.addr		= omap2_timer10_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_core -> timer11 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer11 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer11_hwmod,
+	.clk		= "gpt11_ick",
+	.addr		= omap2_timer11_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_core -> timer12 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer12 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer12_hwmod,
+	.clk		= "gpt12_ick",
+	.addr		= omap2xxx_timer12_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_wkup -> wd_timer2 */
+static struct omap_hwmod_addr_space omap2420_wd_timer2_addrs[] = {
+	{
+		.pa_start	= 0x48022000,
+		.pa_end		= 0x4802207f,
+		.flags		= ADDR_TYPE_RT
+	},
+	{ }
+};
+
+static struct omap_hwmod_ocp_if omap2420_l4_wkup__wd_timer2 = {
+	.master		= &omap2420_l4_wkup_hwmod,
+	.slave		= &omap2420_wd_timer2_hwmod,
+	.clk		= "mpu_wdt_ick",
+	.addr		= omap2420_wd_timer2_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_core -> dss */
+static struct omap_hwmod_ocp_if omap2420_l4_core__dss = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_dss_core_hwmod,
+	.clk		= "dss_ick",
+	.addr		= omap2_dss_addrs,
+	.fw = {
+		.omap2 = {
+			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_CORE_REGION,
+			.flags	= OMAP_FIREWALL_L4,
+		}
+	},
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_core -> dss_dispc */
+static struct omap_hwmod_ocp_if omap2420_l4_core__dss_dispc = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_dss_dispc_hwmod,
+	.clk		= "dss_ick",
+	.addr		= omap2_dss_dispc_addrs,
+	.fw = {
+		.omap2 = {
+			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_DISPC_REGION,
+			.flags	= OMAP_FIREWALL_L4,
+		}
+	},
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_core -> dss_rfbi */
+static struct omap_hwmod_ocp_if omap2420_l4_core__dss_rfbi = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_dss_rfbi_hwmod,
+	.clk		= "dss_ick",
+	.addr		= omap2_dss_rfbi_addrs,
+	.fw = {
+		.omap2 = {
+			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_CORE_REGION,
+			.flags	= OMAP_FIREWALL_L4,
+		}
+	},
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_core -> dss_venc */
+static struct omap_hwmod_ocp_if omap2420_l4_core__dss_venc = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_dss_venc_hwmod,
+	.clk		= "dss_ick",
+	.addr		= omap2_dss_venc_addrs,
+	.fw = {
+		.omap2 = {
+			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_VENC_REGION,
+			.flags	= OMAP_FIREWALL_L4,
+		}
+	},
+	.flags		= OCPIF_SWSUP_IDLE,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_wkup -> gpio1 */
+static struct omap_hwmod_addr_space omap2420_gpio1_addr_space[] = {
+	{
+		.pa_start	= 0x48018000,
+		.pa_end		= 0x480181ff,
+		.flags		= ADDR_TYPE_RT
+	},
+	{ }
+};
+
+static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio1 = {
+	.master		= &omap2420_l4_wkup_hwmod,
+	.slave		= &omap2420_gpio1_hwmod,
+	.clk		= "gpios_ick",
+	.addr		= omap2420_gpio1_addr_space,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_wkup -> gpio2 */
+static struct omap_hwmod_addr_space omap2420_gpio2_addr_space[] = {
+	{
+		.pa_start	= 0x4801a000,
+		.pa_end		= 0x4801a1ff,
+		.flags		= ADDR_TYPE_RT
+	},
+	{ }
+};
+
+static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio2 = {
+	.master		= &omap2420_l4_wkup_hwmod,
+	.slave		= &omap2420_gpio2_hwmod,
+	.clk		= "gpios_ick",
+	.addr		= omap2420_gpio2_addr_space,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_wkup -> gpio3 */
+static struct omap_hwmod_addr_space omap2420_gpio3_addr_space[] = {
+	{
+		.pa_start	= 0x4801c000,
+		.pa_end		= 0x4801c1ff,
+		.flags		= ADDR_TYPE_RT
+	},
+	{ }
+};
+
+static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio3 = {
+	.master		= &omap2420_l4_wkup_hwmod,
+	.slave		= &omap2420_gpio3_hwmod,
+	.clk		= "gpios_ick",
+	.addr		= omap2420_gpio3_addr_space,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_wkup -> gpio4 */
+static struct omap_hwmod_addr_space omap2420_gpio4_addr_space[] = {
+	{
+		.pa_start	= 0x4801e000,
+		.pa_end		= 0x4801e1ff,
+		.flags		= ADDR_TYPE_RT
+	},
+	{ }
+};
+
+static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio4 = {
+	.master		= &omap2420_l4_wkup_hwmod,
+	.slave		= &omap2420_gpio4_hwmod,
+	.clk		= "gpios_ick",
+	.addr		= omap2420_gpio4_addr_space,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* dma_system -> L3 */
+static struct omap_hwmod_ocp_if omap2420_dma_system__l3 = {
+	.master		= &omap2420_dma_system_hwmod,
+	.slave		= &omap2420_l3_main_hwmod,
+	.clk		= "core_l3_ck",
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_core -> dma_system */
+static struct omap_hwmod_ocp_if omap2420_l4_core__dma_system = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_dma_system_hwmod,
+	.clk		= "sdma_ick",
+	.addr		= omap2_dma_system_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_core -> mailbox */
+static struct omap_hwmod_ocp_if omap2420_l4_core__mailbox = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_mailbox_hwmod,
+	.addr		= omap2_mailbox_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_core -> mcbsp1 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp1 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_mcbsp1_hwmod,
+	.clk		= "mcbsp1_ick",
+	.addr		= omap2_mcbsp1_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_core -> mcbsp2 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp2 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_mcbsp2_hwmod,
+	.clk		= "mcbsp2_ick",
+	.addr		= omap2xxx_mcbsp2_addrs,
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
 static struct omap_hwmod_ocp_if *omap2420_hwmod_ocp_ifs[] __initdata = {
 	&omap2420_l3_main__l4_core,
 	&omap2420_mpu__l3_main,

commit 0a78c5c5963d3bb2119795f9442a3eeec3aebc1a
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Apr 19 04:04:31 2012 -0600

    ARM: OMAP2+: hwmod data: convert to link registration
    
    Register interconnect links between IP blocks, rather than the IP
    blocks themselves.  (The IP blocks will be registered as a side-effect
    of registering the links.)
    
    The objective is to reduce the number of lines of static data and
    facilitate the sharing of IP block data between different SoCs.  These
    objectives come at the penalty of increased boot time due to increased
    computation.
    
    While here, fix a few whitespace problems and inaccurate variable names.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Beno√Æt Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 3e8938005da8..42921ff12e86 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -2,6 +2,7 @@
  * omap_hwmod_2420_data.c - hardware modules present on the OMAP2420 chips
  *
  * Copyright (C) 2009-2011 Nokia Corporation
+ * Copyright (C) 2012 Texas Instruments, Inc.
  * Paul Walmsley
  *
  * This program is free software; you can redistribute it and/or modify
@@ -69,11 +70,6 @@ static struct omap_hwmod_ocp_if omap2420_mpu__l3_main = {
 	.user	= OCP_USER_MPU,
 };
 
-/* Slave interfaces on the L3 interconnect */
-static struct omap_hwmod_ocp_if *omap2420_l3_main_slaves[] = {
-	&omap2420_mpu__l3_main,
-};
-
 /* DSS -> l3 */
 static struct omap_hwmod_ocp_if omap2420_dss__l3 = {
 	.master		= &omap2420_dss_core_hwmod,
@@ -87,19 +83,10 @@ static struct omap_hwmod_ocp_if omap2420_dss__l3 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* Master interfaces on the L3 interconnect */
-static struct omap_hwmod_ocp_if *omap2420_l3_main_masters[] = {
-	&omap2420_l3_main__l4_core,
-};
-
 /* L3 */
 static struct omap_hwmod omap2420_l3_main_hwmod = {
 	.name		= "l3_main",
 	.class		= &l3_hwmod_class,
-	.masters	= omap2420_l3_main_masters,
-	.masters_cnt	= ARRAY_SIZE(omap2420_l3_main_masters),
-	.slaves		= omap2420_l3_main_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_l3_main_slaves),
 	.flags		= HWMOD_NO_IDLEST,
 };
 
@@ -182,64 +169,25 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__i2c2 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* Slave interfaces on the L4_CORE interconnect */
-static struct omap_hwmod_ocp_if *omap2420_l4_core_slaves[] = {
-	&omap2420_l3_main__l4_core,
-};
-
-/* Master interfaces on the L4_CORE interconnect */
-static struct omap_hwmod_ocp_if *omap2420_l4_core_masters[] = {
-	&omap2420_l4_core__l4_wkup,
-	&omap2_l4_core__uart1,
-	&omap2_l4_core__uart2,
-	&omap2_l4_core__uart3,
-	&omap2420_l4_core__i2c1,
-	&omap2420_l4_core__i2c2
-};
-
 /* L4 CORE */
 static struct omap_hwmod omap2420_l4_core_hwmod = {
 	.name		= "l4_core",
 	.class		= &l4_hwmod_class,
-	.masters	= omap2420_l4_core_masters,
-	.masters_cnt	= ARRAY_SIZE(omap2420_l4_core_masters),
-	.slaves		= omap2420_l4_core_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_l4_core_slaves),
 	.flags		= HWMOD_NO_IDLEST,
 };
 
-/* Slave interfaces on the L4_WKUP interconnect */
-static struct omap_hwmod_ocp_if *omap2420_l4_wkup_slaves[] = {
-	&omap2420_l4_core__l4_wkup,
-};
-
-/* Master interfaces on the L4_WKUP interconnect */
-static struct omap_hwmod_ocp_if *omap2420_l4_wkup_masters[] = {
-};
-
 /* L4 WKUP */
 static struct omap_hwmod omap2420_l4_wkup_hwmod = {
 	.name		= "l4_wkup",
 	.class		= &l4_hwmod_class,
-	.masters	= omap2420_l4_wkup_masters,
-	.masters_cnt	= ARRAY_SIZE(omap2420_l4_wkup_masters),
-	.slaves		= omap2420_l4_wkup_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_l4_wkup_slaves),
 	.flags		= HWMOD_NO_IDLEST,
 };
 
-/* Master interfaces on the MPU device */
-static struct omap_hwmod_ocp_if *omap2420_mpu_masters[] = {
-	&omap2420_mpu__l3_main,
-};
-
 /* MPU */
 static struct omap_hwmod omap2420_mpu_hwmod = {
 	.name		= "mpu",
 	.class		= &mpu_hwmod_class,
 	.main_clk	= "mpu_ck",
-	.masters	= omap2420_mpu_masters,
-	.masters_cnt	= ARRAY_SIZE(omap2420_mpu_masters),
 };
 
 /*
@@ -254,10 +202,6 @@ static struct omap_hwmod_ocp_if omap2420_l3__iva = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-static struct omap_hwmod_ocp_if *omap2420_iva_masters[] = {
-	&omap2420_l3__iva,
-};
-
 /*
  * IVA2 (IVA2)
  */
@@ -265,8 +209,6 @@ static struct omap_hwmod_ocp_if *omap2420_iva_masters[] = {
 static struct omap_hwmod omap2420_iva_hwmod = {
 	.name		= "iva",
 	.class		= &iva_hwmod_class,
-	.masters	= omap2420_iva_masters,
-	.masters_cnt	= ARRAY_SIZE(omap2420_iva_masters),
 };
 
 /* always-on timers dev attribute */
@@ -300,11 +242,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_wkup__timer1 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* timer1 slave port */
-static struct omap_hwmod_ocp_if *omap2420_timer1_slaves[] = {
-	&omap2420_l4_wkup__timer1,
-};
-
 /* timer1 hwmod */
 static struct omap_hwmod omap2420_timer1_hwmod = {
 	.name		= "timer1",
@@ -320,8 +257,6 @@ static struct omap_hwmod omap2420_timer1_hwmod = {
 		},
 	},
 	.dev_attr	= &capability_alwon_dev_attr,
-	.slaves		= omap2420_timer1_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_timer1_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
 };
 
@@ -337,11 +272,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer2 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* timer2 slave port */
-static struct omap_hwmod_ocp_if *omap2420_timer2_slaves[] = {
-	&omap2420_l4_core__timer2,
-};
-
 /* timer2 hwmod */
 static struct omap_hwmod omap2420_timer2_hwmod = {
 	.name		= "timer2",
@@ -357,8 +287,6 @@ static struct omap_hwmod omap2420_timer2_hwmod = {
 		},
 	},
 	.dev_attr	= &capability_alwon_dev_attr,
-	.slaves		= omap2420_timer2_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_timer2_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
 };
 
@@ -374,11 +302,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer3 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* timer3 slave port */
-static struct omap_hwmod_ocp_if *omap2420_timer3_slaves[] = {
-	&omap2420_l4_core__timer3,
-};
-
 /* timer3 hwmod */
 static struct omap_hwmod omap2420_timer3_hwmod = {
 	.name		= "timer3",
@@ -394,8 +317,6 @@ static struct omap_hwmod omap2420_timer3_hwmod = {
 		},
 	},
 	.dev_attr	= &capability_alwon_dev_attr,
-	.slaves		= omap2420_timer3_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_timer3_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
 };
 
@@ -411,11 +332,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer4 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* timer4 slave port */
-static struct omap_hwmod_ocp_if *omap2420_timer4_slaves[] = {
-	&omap2420_l4_core__timer4,
-};
-
 /* timer4 hwmod */
 static struct omap_hwmod omap2420_timer4_hwmod = {
 	.name		= "timer4",
@@ -431,8 +347,6 @@ static struct omap_hwmod omap2420_timer4_hwmod = {
 		},
 	},
 	.dev_attr	= &capability_alwon_dev_attr,
-	.slaves		= omap2420_timer4_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_timer4_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
 };
 
@@ -448,11 +362,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer5 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* timer5 slave port */
-static struct omap_hwmod_ocp_if *omap2420_timer5_slaves[] = {
-	&omap2420_l4_core__timer5,
-};
-
 /* timer5 hwmod */
 static struct omap_hwmod omap2420_timer5_hwmod = {
 	.name		= "timer5",
@@ -468,8 +377,6 @@ static struct omap_hwmod omap2420_timer5_hwmod = {
 		},
 	},
 	.dev_attr	= &capability_alwon_dev_attr,
-	.slaves		= omap2420_timer5_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_timer5_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
 };
 
@@ -486,11 +393,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer6 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* timer6 slave port */
-static struct omap_hwmod_ocp_if *omap2420_timer6_slaves[] = {
-	&omap2420_l4_core__timer6,
-};
-
 /* timer6 hwmod */
 static struct omap_hwmod omap2420_timer6_hwmod = {
 	.name		= "timer6",
@@ -506,8 +408,6 @@ static struct omap_hwmod omap2420_timer6_hwmod = {
 		},
 	},
 	.dev_attr	= &capability_alwon_dev_attr,
-	.slaves		= omap2420_timer6_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_timer6_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
 };
 
@@ -523,11 +423,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer7 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* timer7 slave port */
-static struct omap_hwmod_ocp_if *omap2420_timer7_slaves[] = {
-	&omap2420_l4_core__timer7,
-};
-
 /* timer7 hwmod */
 static struct omap_hwmod omap2420_timer7_hwmod = {
 	.name		= "timer7",
@@ -543,8 +438,6 @@ static struct omap_hwmod omap2420_timer7_hwmod = {
 		},
 	},
 	.dev_attr	= &capability_alwon_dev_attr,
-	.slaves		= omap2420_timer7_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_timer7_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
 };
 
@@ -560,11 +453,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer8 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* timer8 slave port */
-static struct omap_hwmod_ocp_if *omap2420_timer8_slaves[] = {
-	&omap2420_l4_core__timer8,
-};
-
 /* timer8 hwmod */
 static struct omap_hwmod omap2420_timer8_hwmod = {
 	.name		= "timer8",
@@ -580,8 +468,6 @@ static struct omap_hwmod omap2420_timer8_hwmod = {
 		},
 	},
 	.dev_attr	= &capability_alwon_dev_attr,
-	.slaves		= omap2420_timer8_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_timer8_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
 };
 
@@ -597,11 +483,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer9 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* timer9 slave port */
-static struct omap_hwmod_ocp_if *omap2420_timer9_slaves[] = {
-	&omap2420_l4_core__timer9,
-};
-
 /* timer9 hwmod */
 static struct omap_hwmod omap2420_timer9_hwmod = {
 	.name		= "timer9",
@@ -617,8 +498,6 @@ static struct omap_hwmod omap2420_timer9_hwmod = {
 		},
 	},
 	.dev_attr	= &capability_pwm_dev_attr,
-	.slaves		= omap2420_timer9_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_timer9_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
 };
 
@@ -634,11 +513,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer10 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* timer10 slave port */
-static struct omap_hwmod_ocp_if *omap2420_timer10_slaves[] = {
-	&omap2420_l4_core__timer10,
-};
-
 /* timer10 hwmod */
 static struct omap_hwmod omap2420_timer10_hwmod = {
 	.name		= "timer10",
@@ -654,8 +528,6 @@ static struct omap_hwmod omap2420_timer10_hwmod = {
 		},
 	},
 	.dev_attr	= &capability_pwm_dev_attr,
-	.slaves		= omap2420_timer10_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_timer10_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
 };
 
@@ -671,11 +543,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer11 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* timer11 slave port */
-static struct omap_hwmod_ocp_if *omap2420_timer11_slaves[] = {
-	&omap2420_l4_core__timer11,
-};
-
 /* timer11 hwmod */
 static struct omap_hwmod omap2420_timer11_hwmod = {
 	.name		= "timer11",
@@ -691,8 +558,6 @@ static struct omap_hwmod omap2420_timer11_hwmod = {
 		},
 	},
 	.dev_attr	= &capability_pwm_dev_attr,
-	.slaves		= omap2420_timer11_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_timer11_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
 };
 
@@ -708,11 +573,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer12 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* timer12 slave port */
-static struct omap_hwmod_ocp_if *omap2420_timer12_slaves[] = {
-	&omap2420_l4_core__timer12,
-};
-
 /* timer12 hwmod */
 static struct omap_hwmod omap2420_timer12_hwmod = {
 	.name		= "timer12",
@@ -728,8 +588,6 @@ static struct omap_hwmod omap2420_timer12_hwmod = {
 		},
 	},
 	.dev_attr	= &capability_pwm_dev_attr,
-	.slaves		= omap2420_timer12_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_timer12_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
 };
 
@@ -751,11 +609,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_wkup__wd_timer2 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* wd_timer2 */
-static struct omap_hwmod_ocp_if *omap2420_wd_timer2_slaves[] = {
-	&omap2420_l4_wkup__wd_timer2,
-};
-
 static struct omap_hwmod omap2420_wd_timer2_hwmod = {
 	.name		= "wd_timer2",
 	.class		= &omap2xxx_wd_timer_hwmod_class,
@@ -769,16 +622,10 @@ static struct omap_hwmod omap2420_wd_timer2_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_MPU_WDT_SHIFT,
 		},
 	},
-	.slaves		= omap2420_wd_timer2_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_wd_timer2_slaves),
 };
 
 /* UART1 */
 
-static struct omap_hwmod_ocp_if *omap2420_uart1_slaves[] = {
-	&omap2_l4_core__uart1,
-};
-
 static struct omap_hwmod omap2420_uart1_hwmod = {
 	.name		= "uart1",
 	.mpu_irqs	= omap2_uart1_mpu_irqs,
@@ -793,17 +640,11 @@ static struct omap_hwmod omap2420_uart1_hwmod = {
 			.idlest_idle_bit = OMAP24XX_EN_UART1_SHIFT,
 		},
 	},
-	.slaves		= omap2420_uart1_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_uart1_slaves),
 	.class		= &omap2_uart_class,
 };
 
 /* UART2 */
 
-static struct omap_hwmod_ocp_if *omap2420_uart2_slaves[] = {
-	&omap2_l4_core__uart2,
-};
-
 static struct omap_hwmod omap2420_uart2_hwmod = {
 	.name		= "uart2",
 	.mpu_irqs	= omap2_uart2_mpu_irqs,
@@ -818,17 +659,11 @@ static struct omap_hwmod omap2420_uart2_hwmod = {
 			.idlest_idle_bit = OMAP24XX_EN_UART2_SHIFT,
 		},
 	},
-	.slaves		= omap2420_uart2_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_uart2_slaves),
 	.class		= &omap2_uart_class,
 };
 
 /* UART3 */
 
-static struct omap_hwmod_ocp_if *omap2420_uart3_slaves[] = {
-	&omap2_l4_core__uart3,
-};
-
 static struct omap_hwmod omap2420_uart3_hwmod = {
 	.name		= "uart3",
 	.mpu_irqs	= omap2_uart3_mpu_irqs,
@@ -843,16 +678,10 @@ static struct omap_hwmod omap2420_uart3_hwmod = {
 			.idlest_idle_bit = OMAP24XX_EN_UART3_SHIFT,
 		},
 	},
-	.slaves		= omap2420_uart3_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_uart3_slaves),
 	.class		= &omap2_uart_class,
 };
 
 /* dss */
-/* dss master ports */
-static struct omap_hwmod_ocp_if *omap2420_dss_masters[] = {
-	&omap2420_dss__l3,
-};
 
 /* l4_core -> dss */
 static struct omap_hwmod_ocp_if omap2420_l4_core__dss = {
@@ -869,11 +698,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__dss = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* dss slave ports */
-static struct omap_hwmod_ocp_if *omap2420_dss_slaves[] = {
-	&omap2420_l4_core__dss,
-};
-
 static struct omap_hwmod_opt_clk dss_opt_clks[] = {
 	/*
 	 * The DSS HW needs all DSS clocks enabled during reset. The dss_core
@@ -899,10 +723,6 @@ static struct omap_hwmod omap2420_dss_core_hwmod = {
 	},
 	.opt_clks	= dss_opt_clks,
 	.opt_clks_cnt = ARRAY_SIZE(dss_opt_clks),
-	.slaves		= omap2420_dss_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_dss_slaves),
-	.masters	= omap2420_dss_masters,
-	.masters_cnt	= ARRAY_SIZE(omap2420_dss_masters),
 	.flags		= HWMOD_NO_IDLEST | HWMOD_CONTROL_OPT_CLKS_IN_RESET,
 };
 
@@ -921,11 +741,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__dss_dispc = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* dss_dispc slave ports */
-static struct omap_hwmod_ocp_if *omap2420_dss_dispc_slaves[] = {
-	&omap2420_l4_core__dss_dispc,
-};
-
 static struct omap_hwmod omap2420_dss_dispc_hwmod = {
 	.name		= "dss_dispc",
 	.class		= &omap2_dispc_hwmod_class,
@@ -940,8 +755,6 @@ static struct omap_hwmod omap2420_dss_dispc_hwmod = {
 			.idlest_stdby_bit = OMAP24XX_ST_DSS_SHIFT,
 		},
 	},
-	.slaves		= omap2420_dss_dispc_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_dss_dispc_slaves),
 	.flags		= HWMOD_NO_IDLEST,
 	.dev_attr	= &omap2_3_dss_dispc_dev_attr
 };
@@ -961,11 +774,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__dss_rfbi = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* dss_rfbi slave ports */
-static struct omap_hwmod_ocp_if *omap2420_dss_rfbi_slaves[] = {
-	&omap2420_l4_core__dss_rfbi,
-};
-
 static struct omap_hwmod_opt_clk dss_rfbi_opt_clks[] = {
 	{ .role = "ick", .clk = "dss_ick" },
 };
@@ -983,8 +791,6 @@ static struct omap_hwmod omap2420_dss_rfbi_hwmod = {
 	},
 	.opt_clks	= dss_rfbi_opt_clks,
 	.opt_clks_cnt	= ARRAY_SIZE(dss_rfbi_opt_clks),
-	.slaves		= omap2420_dss_rfbi_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_dss_rfbi_slaves),
 	.flags		= HWMOD_NO_IDLEST,
 };
 
@@ -1003,11 +809,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__dss_venc = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* dss_venc slave ports */
-static struct omap_hwmod_ocp_if *omap2420_dss_venc_slaves[] = {
-	&omap2420_l4_core__dss_venc,
-};
-
 static struct omap_hwmod omap2420_dss_venc_hwmod = {
 	.name		= "dss_venc",
 	.class		= &omap2_venc_hwmod_class,
@@ -1019,8 +820,6 @@ static struct omap_hwmod omap2420_dss_venc_hwmod = {
 			.module_offs = CORE_MOD,
 		},
 	},
-	.slaves		= omap2420_dss_venc_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_dss_venc_slaves),
 	.flags		= HWMOD_NO_IDLEST,
 };
 
@@ -1049,10 +848,6 @@ static struct omap_i2c_dev_attr i2c_dev_attr = {
 
 /* I2C1 */
 
-static struct omap_hwmod_ocp_if *omap2420_i2c1_slaves[] = {
-	&omap2420_l4_core__i2c1,
-};
-
 static struct omap_hwmod omap2420_i2c1_hwmod = {
 	.name		= "i2c1",
 	.mpu_irqs	= omap2_i2c1_mpu_irqs,
@@ -1067,8 +862,6 @@ static struct omap_hwmod omap2420_i2c1_hwmod = {
 			.idlest_idle_bit = OMAP2420_ST_I2C1_SHIFT,
 		},
 	},
-	.slaves		= omap2420_i2c1_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_i2c1_slaves),
 	.class		= &i2c_class,
 	.dev_attr	= &i2c_dev_attr,
 	.flags		= HWMOD_16BIT_REG,
@@ -1076,10 +869,6 @@ static struct omap_hwmod omap2420_i2c1_hwmod = {
 
 /* I2C2 */
 
-static struct omap_hwmod_ocp_if *omap2420_i2c2_slaves[] = {
-	&omap2420_l4_core__i2c2,
-};
-
 static struct omap_hwmod omap2420_i2c2_hwmod = {
 	.name		= "i2c2",
 	.mpu_irqs	= omap2_i2c2_mpu_irqs,
@@ -1094,8 +883,6 @@ static struct omap_hwmod omap2420_i2c2_hwmod = {
 			.idlest_idle_bit = OMAP2420_ST_I2C2_SHIFT,
 		},
 	},
-	.slaves		= omap2420_i2c2_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_i2c2_slaves),
 	.class		= &i2c_class,
 	.dev_attr	= &i2c_dev_attr,
 	.flags		= HWMOD_16BIT_REG,
@@ -1180,10 +967,6 @@ static struct omap_gpio_dev_attr gpio_dev_attr = {
 };
 
 /* gpio1 */
-static struct omap_hwmod_ocp_if *omap2420_gpio1_slaves[] = {
-	&omap2420_l4_wkup__gpio1,
-};
-
 static struct omap_hwmod omap2420_gpio1_hwmod = {
 	.name		= "gpio1",
 	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
@@ -1198,17 +981,11 @@ static struct omap_hwmod omap2420_gpio1_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_GPIOS_SHIFT,
 		},
 	},
-	.slaves		= omap2420_gpio1_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_gpio1_slaves),
 	.class		= &omap2xxx_gpio_hwmod_class,
 	.dev_attr	= &gpio_dev_attr,
 };
 
 /* gpio2 */
-static struct omap_hwmod_ocp_if *omap2420_gpio2_slaves[] = {
-	&omap2420_l4_wkup__gpio2,
-};
-
 static struct omap_hwmod omap2420_gpio2_hwmod = {
 	.name		= "gpio2",
 	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
@@ -1223,17 +1000,11 @@ static struct omap_hwmod omap2420_gpio2_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_GPIOS_SHIFT,
 		},
 	},
-	.slaves		= omap2420_gpio2_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_gpio2_slaves),
 	.class		= &omap2xxx_gpio_hwmod_class,
 	.dev_attr	= &gpio_dev_attr,
 };
 
 /* gpio3 */
-static struct omap_hwmod_ocp_if *omap2420_gpio3_slaves[] = {
-	&omap2420_l4_wkup__gpio3,
-};
-
 static struct omap_hwmod omap2420_gpio3_hwmod = {
 	.name		= "gpio3",
 	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
@@ -1248,17 +1019,11 @@ static struct omap_hwmod omap2420_gpio3_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_GPIOS_SHIFT,
 		},
 	},
-	.slaves		= omap2420_gpio3_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_gpio3_slaves),
 	.class		= &omap2xxx_gpio_hwmod_class,
 	.dev_attr	= &gpio_dev_attr,
 };
 
 /* gpio4 */
-static struct omap_hwmod_ocp_if *omap2420_gpio4_slaves[] = {
-	&omap2420_l4_wkup__gpio4,
-};
-
 static struct omap_hwmod omap2420_gpio4_hwmod = {
 	.name		= "gpio4",
 	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
@@ -1273,8 +1038,6 @@ static struct omap_hwmod omap2420_gpio4_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_GPIOS_SHIFT,
 		},
 	},
-	.slaves		= omap2420_gpio4_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_gpio4_slaves),
 	.class		= &omap2xxx_gpio_hwmod_class,
 	.dev_attr	= &gpio_dev_attr,
 };
@@ -1294,11 +1057,6 @@ static struct omap_hwmod_ocp_if omap2420_dma_system__l3 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* dma_system master ports */
-static struct omap_hwmod_ocp_if *omap2420_dma_system_masters[] = {
-	&omap2420_dma_system__l3,
-};
-
 /* l4_core -> dma_system */
 static struct omap_hwmod_ocp_if omap2420_l4_core__dma_system = {
 	.master		= &omap2420_l4_core_hwmod,
@@ -1308,20 +1066,11 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__dma_system = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* dma_system slave ports */
-static struct omap_hwmod_ocp_if *omap2420_dma_system_slaves[] = {
-	&omap2420_l4_core__dma_system,
-};
-
 static struct omap_hwmod omap2420_dma_system_hwmod = {
 	.name		= "dma",
 	.class		= &omap2xxx_dma_hwmod_class,
 	.mpu_irqs	= omap2_dma_system_irqs,
 	.main_clk	= "core_l3_ck",
-	.slaves		= omap2420_dma_system_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_dma_system_slaves),
-	.masters	= omap2420_dma_system_masters,
-	.masters_cnt	= ARRAY_SIZE(omap2420_dma_system_masters),
 	.dev_attr	= &dma_dev_attr,
 	.flags		= HWMOD_NO_IDLEST,
 };
@@ -1342,11 +1091,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__mailbox = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* mailbox slave ports */
-static struct omap_hwmod_ocp_if *omap2420_mailbox_slaves[] = {
-	&omap2420_l4_core__mailbox,
-};
-
 static struct omap_hwmod omap2420_mailbox_hwmod = {
 	.name		= "mailbox",
 	.class		= &omap2xxx_mailbox_hwmod_class,
@@ -1361,15 +1105,9 @@ static struct omap_hwmod omap2420_mailbox_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_MAILBOXES_SHIFT,
 		},
 	},
-	.slaves		= omap2420_mailbox_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_mailbox_slaves),
 };
 
 /* mcspi1 */
-static struct omap_hwmod_ocp_if *omap2420_mcspi1_slaves[] = {
-	&omap2420_l4_core__mcspi1,
-};
-
 static struct omap2_mcspi_dev_attr omap_mcspi1_dev_attr = {
 	.num_chipselect = 4,
 };
@@ -1388,17 +1126,11 @@ static struct omap_hwmod omap2420_mcspi1_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_MCSPI1_SHIFT,
 		},
 	},
-	.slaves		= omap2420_mcspi1_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_mcspi1_slaves),
 	.class		= &omap2xxx_mcspi_class,
 	.dev_attr	= &omap_mcspi1_dev_attr,
 };
 
 /* mcspi2 */
-static struct omap_hwmod_ocp_if *omap2420_mcspi2_slaves[] = {
-	&omap2420_l4_core__mcspi2,
-};
-
 static struct omap2_mcspi_dev_attr omap_mcspi2_dev_attr = {
 	.num_chipselect = 2,
 };
@@ -1417,8 +1149,6 @@ static struct omap_hwmod omap2420_mcspi2_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_MCSPI2_SHIFT,
 		},
 	},
-	.slaves		= omap2420_mcspi2_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_mcspi2_slaves),
 	.class		= &omap2xxx_mcspi_class,
 	.dev_attr	= &omap_mcspi2_dev_attr,
 };
@@ -1448,11 +1178,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp1 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* mcbsp1 slave ports */
-static struct omap_hwmod_ocp_if *omap2420_mcbsp1_slaves[] = {
-	&omap2420_l4_core__mcbsp1,
-};
-
 static struct omap_hwmod omap2420_mcbsp1_hwmod = {
 	.name		= "mcbsp1",
 	.class		= &omap2420_mcbsp_hwmod_class,
@@ -1468,8 +1193,6 @@ static struct omap_hwmod omap2420_mcbsp1_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_MCBSP1_SHIFT,
 		},
 	},
-	.slaves		= omap2420_mcbsp1_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_mcbsp1_slaves),
 };
 
 /* mcbsp2 */
@@ -1488,11 +1211,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp2 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* mcbsp2 slave ports */
-static struct omap_hwmod_ocp_if *omap2420_mcbsp2_slaves[] = {
-	&omap2420_l4_core__mcbsp2,
-};
-
 static struct omap_hwmod omap2420_mcbsp2_hwmod = {
 	.name		= "mcbsp2",
 	.class		= &omap2420_mcbsp_hwmod_class,
@@ -1508,66 +1226,51 @@ static struct omap_hwmod omap2420_mcbsp2_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_MCBSP2_SHIFT,
 		},
 	},
-	.slaves		= omap2420_mcbsp2_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_mcbsp2_slaves),
-};
-
-static __initdata struct omap_hwmod *omap2420_hwmods[] = {
-	&omap2420_l3_main_hwmod,
-	&omap2420_l4_core_hwmod,
-	&omap2420_l4_wkup_hwmod,
-	&omap2420_mpu_hwmod,
-	&omap2420_iva_hwmod,
-
-	&omap2420_timer1_hwmod,
-	&omap2420_timer2_hwmod,
-	&omap2420_timer3_hwmod,
-	&omap2420_timer4_hwmod,
-	&omap2420_timer5_hwmod,
-	&omap2420_timer6_hwmod,
-	&omap2420_timer7_hwmod,
-	&omap2420_timer8_hwmod,
-	&omap2420_timer9_hwmod,
-	&omap2420_timer10_hwmod,
-	&omap2420_timer11_hwmod,
-	&omap2420_timer12_hwmod,
-
-	&omap2420_wd_timer2_hwmod,
-	&omap2420_uart1_hwmod,
-	&omap2420_uart2_hwmod,
-	&omap2420_uart3_hwmod,
-	/* dss class */
-	&omap2420_dss_core_hwmod,
-	&omap2420_dss_dispc_hwmod,
-	&omap2420_dss_rfbi_hwmod,
-	&omap2420_dss_venc_hwmod,
-	/* i2c class */
-	&omap2420_i2c1_hwmod,
-	&omap2420_i2c2_hwmod,
-
-	/* gpio class */
-	&omap2420_gpio1_hwmod,
-	&omap2420_gpio2_hwmod,
-	&omap2420_gpio3_hwmod,
-	&omap2420_gpio4_hwmod,
-
-	/* dma_system class*/
-	&omap2420_dma_system_hwmod,
-
-	/* mailbox class */
-	&omap2420_mailbox_hwmod,
-
-	/* mcbsp class */
-	&omap2420_mcbsp1_hwmod,
-	&omap2420_mcbsp2_hwmod,
-
-	/* mcspi class */
-	&omap2420_mcspi1_hwmod,
-	&omap2420_mcspi2_hwmod,
+};
+
+static struct omap_hwmod_ocp_if *omap2420_hwmod_ocp_ifs[] __initdata = {
+	&omap2420_l3_main__l4_core,
+	&omap2420_mpu__l3_main,
+	&omap2420_dss__l3,
+	&omap2420_l4_core__mcspi1,
+	&omap2420_l4_core__mcspi2,
+	&omap2420_l4_core__l4_wkup,
+	&omap2_l4_core__uart1,
+	&omap2_l4_core__uart2,
+	&omap2_l4_core__uart3,
+	&omap2420_l4_core__i2c1,
+	&omap2420_l4_core__i2c2,
+	&omap2420_l3__iva,
+	&omap2420_l4_wkup__timer1,
+	&omap2420_l4_core__timer2,
+	&omap2420_l4_core__timer3,
+	&omap2420_l4_core__timer4,
+	&omap2420_l4_core__timer5,
+	&omap2420_l4_core__timer6,
+	&omap2420_l4_core__timer7,
+	&omap2420_l4_core__timer8,
+	&omap2420_l4_core__timer9,
+	&omap2420_l4_core__timer10,
+	&omap2420_l4_core__timer11,
+	&omap2420_l4_core__timer12,
+	&omap2420_l4_wkup__wd_timer2,
+	&omap2420_l4_core__dss,
+	&omap2420_l4_core__dss_dispc,
+	&omap2420_l4_core__dss_rfbi,
+	&omap2420_l4_core__dss_venc,
+	&omap2420_l4_wkup__gpio1,
+	&omap2420_l4_wkup__gpio2,
+	&omap2420_l4_wkup__gpio3,
+	&omap2420_l4_wkup__gpio4,
+	&omap2420_dma_system__l3,
+	&omap2420_l4_core__dma_system,
+	&omap2420_l4_core__mailbox,
+	&omap2420_l4_core__mcbsp1,
+	&omap2420_l4_core__mcbsp2,
 	NULL,
 };
 
 int __init omap2420_hwmod_init(void)
 {
-	return omap_hwmod_register(omap2420_hwmods);
+	return omap_hwmod_register_links(omap2420_hwmod_ocp_ifs);
 }

commit bec9381157159e654be16f69e4e8882ab4e609bd
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Apr 19 04:03:50 2012 -0600

    ARM: OMAP2/3: hwmod data: update old names
    
    Some of the 2xxx and 3xxx hwmod data files use the old naming style
    for hwmods, ending in a "_hwmod".  These names are used by the OMAP
    integration code to map hwmods to platform_devices, so they need to be
    consistent, or the platform_devices won't be created.  Remove the
    _hwmod suffix to conform with the rest of the OMAP SoC data.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index a6bde34e443a..3e8938005da8 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -1375,7 +1375,7 @@ static struct omap2_mcspi_dev_attr omap_mcspi1_dev_attr = {
 };
 
 static struct omap_hwmod omap2420_mcspi1_hwmod = {
-	.name		= "mcspi1_hwmod",
+	.name		= "mcspi1",
 	.mpu_irqs	= omap2_mcspi1_mpu_irqs,
 	.sdma_reqs	= omap2_mcspi1_sdma_reqs,
 	.main_clk	= "mcspi1_fck",
@@ -1404,7 +1404,7 @@ static struct omap2_mcspi_dev_attr omap_mcspi2_dev_attr = {
 };
 
 static struct omap_hwmod omap2420_mcspi2_hwmod = {
-	.name		= "mcspi2_hwmod",
+	.name		= "mcspi2",
 	.mpu_irqs	= omap2_mcspi2_mpu_irqs,
 	.sdma_reqs	= omap2_mcspi2_sdma_reqs,
 	.main_clk	= "mcspi2_fck",

commit 1f5e6247ca99287bac87aff4971a7eee9c2b223a
Author: Archit Taneja <archit@ti.com>
Date:   Fri Apr 13 13:31:55 2012 +0530

    ARM: OMAP2/3: VENC hwmods: Remove OCPIF_SWSUP_IDLE flag from VENC slave interface
    
    The clocks for all DSS slave interfaces were recently changed to "dss_ick" on
    OMAP2 and OMAP3, this clock can be autoidled by PRCM. The VENC interface
    previously had "dss_54m_fck" as it's clock which couldn't be autoidled, and
    hence the OCPIF_SWSUP_IDLE flag was needed.
    
    Remove the OCPIF_SWSUP_IDLE flag from VENC interfaces as it's clock is
    now "dss_ick".  This allows the PRCM hardware to autoidle the VENC
    interface clocks when they are not active, rather than relying on the
    software to do it, which can keep the interface clocks active
    unnecessarily.
    
    Signed-off-by: Archit Taneja <archit@ti.com>
    [paul@pwsan.com: add a short description of the fix to the commit log]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index a5409ce3f323..a6bde34e443a 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -1000,7 +1000,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__dss_venc = {
 			.flags	= OMAP_FIREWALL_L4,
 		}
 	},
-	.flags		= OCPIF_SWSUP_IDLE,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 

commit b923d40dd4211c4ef7d4efa2bd81b7ca1d8744c1
Author: Archit Taneja <archit@ti.com>
Date:   Thu Oct 6 18:04:08 2011 -0600

    ARM: OMAP2PLUS: DSS: Ensure DSS works correctly if display is enabled in bootloader
    
    Resetting DISPC when a DISPC output is enabled causes the DSS to go into an
    inconsistent state. Thus if the bootloader has enabled a display, the hwmod code
    cannot reset the DISPC module just like that, but the outputs need to be
    disabled first.
    
    Add function dispc_disable_outputs() which disables all active overlay manager
    and ensure all frame transfers are completed.
    
    Modify omap_dss_reset() to call this function and clear DSS_CONTROL,
    DSS_SDI_CONTROL and DSS_PLL_CONTROL so that DSS is in a clean state when the
    DSS2 driver starts.
    
    This resolves the hang issue(caused by a L3 error during boot) seen on the
    beagle board C3, which has a factory bootloader that enables display. The issue
    is resolved with this patch.
    
    Thanks to Tomi and Sricharan for some additional testing.
    
    Acked-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Tested-by: R, Sricharan <r.sricharan@ti.com>
    Signed-off-by: Archit Taneja <archit@ti.com>
    [paul@pwsan.com: restructured code, removed omap_{read,write}l(), removed
     cpu_is_omap*() calls and converted to dev_attr]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 74037a5807af..a5409ce3f323 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -943,6 +943,7 @@ static struct omap_hwmod omap2420_dss_dispc_hwmod = {
 	.slaves		= omap2420_dss_dispc_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_dss_dispc_slaves),
 	.flags		= HWMOD_NO_IDLEST,
+	.dev_attr	= &omap2_3_dss_dispc_dev_attr
 };
 
 /* l4_core -> dss_rfbi */

commit b8ac10d8b75843c9ddd6aadf70a0cdf8aa783659
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Nov 8 03:16:09 2011 -0700

    ARM: OMAP2xxx: HWMOD: fix DSS clock data
    
    The OMAP2xxx HWMOD data currently contains two errors with DSS clocks:
    
    - dss_rfbi is missing ick opt-clock, which is needed for RFBI to
      calculate timings
    
    - dss_venc's interface and main clocks are wrong, causing VENC to fail
      to start
    
    These problems were temporarily fixed with a DSS patch
    9ede365aa6f74428a1f69c21ca1cf21213167576 ("HACK: OMAP: DSS2: clk hack
    for OMAP2/3"), which can be reverted after this patch (and the similar
    patches for other OMAPs).
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 5160e3509d5d..74037a5807af 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -965,6 +965,10 @@ static struct omap_hwmod_ocp_if *omap2420_dss_rfbi_slaves[] = {
 	&omap2420_l4_core__dss_rfbi,
 };
 
+static struct omap_hwmod_opt_clk dss_rfbi_opt_clks[] = {
+	{ .role = "ick", .clk = "dss_ick" },
+};
+
 static struct omap_hwmod omap2420_dss_rfbi_hwmod = {
 	.name		= "dss_rfbi",
 	.class		= &omap2_rfbi_hwmod_class,
@@ -976,6 +980,8 @@ static struct omap_hwmod omap2420_dss_rfbi_hwmod = {
 			.module_offs = CORE_MOD,
 		},
 	},
+	.opt_clks	= dss_rfbi_opt_clks,
+	.opt_clks_cnt	= ARRAY_SIZE(dss_rfbi_opt_clks),
 	.slaves		= omap2420_dss_rfbi_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_dss_rfbi_slaves),
 	.flags		= HWMOD_NO_IDLEST,
@@ -985,7 +991,7 @@ static struct omap_hwmod omap2420_dss_rfbi_hwmod = {
 static struct omap_hwmod_ocp_if omap2420_l4_core__dss_venc = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_dss_venc_hwmod,
-	.clk		= "dss_54m_fck",
+	.clk		= "dss_ick",
 	.addr		= omap2_dss_venc_addrs,
 	.fw = {
 		.omap2 = {
@@ -1005,7 +1011,7 @@ static struct omap_hwmod_ocp_if *omap2420_dss_venc_slaves[] = {
 static struct omap_hwmod omap2420_dss_venc_hwmod = {
 	.name		= "dss_venc",
 	.class		= &omap2_venc_hwmod_class,
-	.main_clk	= "dss1_fck",
+	.main_clk	= "dss_54m_fck",
 	.prcm		= {
 		.omap2 = {
 			.prcm_reg_id = 1,

commit 1258ea596fe0422272525d9ec8a25b703de4623f
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Tue Nov 8 03:16:09 2011 -0700

    ARM: OMAP2xxx: HWMOD: Fix DSS reset
    
    DSS needs all DSS clocks to be enabled to be able to finish reset
    properly. Before v3.1-rc1 the omapdss driver was managing clocks and
    resets correctly. However, when omapdss started using runtime PM at
    v3.1-rc1, the responsibility for the reset moved to HWMOD framework.
    
    HWMOD framework does not currently enable all the DSS clocks when
    resetting the DSS hardware. This hasn't caused any problems so far, but
    we may just have been lucky.
    
    This patch sets HWMOD_CONTROL_OPT_CLKS_IN_RESET for dss_core in OMAP2xxx
    HWMOD data, fixing the issue.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    [paul@pwsan.com: merged duplicate .flags fields]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 6d7206213525..5160e3509d5d 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -875,6 +875,10 @@ static struct omap_hwmod_ocp_if *omap2420_dss_slaves[] = {
 };
 
 static struct omap_hwmod_opt_clk dss_opt_clks[] = {
+	/*
+	 * The DSS HW needs all DSS clocks enabled during reset. The dss_core
+	 * driver does not use these clocks.
+	 */
 	{ .role = "tv_clk", .clk = "dss_54m_fck" },
 	{ .role = "sys_clk", .clk = "dss2_fck" },
 };
@@ -899,7 +903,7 @@ static struct omap_hwmod omap2420_dss_core_hwmod = {
 	.slaves_cnt	= ARRAY_SIZE(omap2420_dss_slaves),
 	.masters	= omap2420_dss_masters,
 	.masters_cnt	= ARRAY_SIZE(omap2420_dss_masters),
-	.flags		= HWMOD_NO_IDLEST,
+	.flags		= HWMOD_NO_IDLEST | HWMOD_CONTROL_OPT_CLKS_IN_RESET,
 };
 
 /* l4_core -> dss_dispc */

commit c345c8b09d7a131f3571af55341038054a79efbd
Author: Tarun Kanti DebBarma <tarun.kanti@ti.com>
Date:   Tue Sep 20 17:00:18 2011 +0530

    ARM: OMAP2+: dmtimer: convert to platform devices
    
    Add routines to converts dmtimers to platform devices. The device data
    is obtained from hwmod database of respective platform and is registered
    to device model after successful binding to driver.
    In addition, capability attribute of each of the timers is added in
    hwmod database.
    
    Signed-off-by: Tarun Kanti DebBarma <tarun.kanti@ti.com>
    Signed-off-by: Thara Gopinath <thara@ti.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Cousson, Benoit <b-cousson@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index b6ea69a5c2f8..6d7206213525 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -269,6 +269,16 @@ static struct omap_hwmod omap2420_iva_hwmod = {
 	.masters_cnt	= ARRAY_SIZE(omap2420_iva_masters),
 };
 
+/* always-on timers dev attribute */
+static struct omap_timer_capability_dev_attr capability_alwon_dev_attr = {
+	.timer_capability       = OMAP_TIMER_ALWON,
+};
+
+/* pwm timers dev attribute */
+static struct omap_timer_capability_dev_attr capability_pwm_dev_attr = {
+	.timer_capability       = OMAP_TIMER_HAS_PWM,
+};
+
 /* timer1 */
 static struct omap_hwmod omap2420_timer1_hwmod;
 
@@ -309,6 +319,7 @@ static struct omap_hwmod omap2420_timer1_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_GPT1_SHIFT,
 		},
 	},
+	.dev_attr	= &capability_alwon_dev_attr,
 	.slaves		= omap2420_timer1_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer1_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
@@ -345,6 +356,7 @@ static struct omap_hwmod omap2420_timer2_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_GPT2_SHIFT,
 		},
 	},
+	.dev_attr	= &capability_alwon_dev_attr,
 	.slaves		= omap2420_timer2_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer2_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
@@ -381,6 +393,7 @@ static struct omap_hwmod omap2420_timer3_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_GPT3_SHIFT,
 		},
 	},
+	.dev_attr	= &capability_alwon_dev_attr,
 	.slaves		= omap2420_timer3_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer3_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
@@ -417,6 +430,7 @@ static struct omap_hwmod omap2420_timer4_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_GPT4_SHIFT,
 		},
 	},
+	.dev_attr	= &capability_alwon_dev_attr,
 	.slaves		= omap2420_timer4_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer4_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
@@ -453,6 +467,7 @@ static struct omap_hwmod omap2420_timer5_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_GPT5_SHIFT,
 		},
 	},
+	.dev_attr	= &capability_alwon_dev_attr,
 	.slaves		= omap2420_timer5_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer5_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
@@ -490,6 +505,7 @@ static struct omap_hwmod omap2420_timer6_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_GPT6_SHIFT,
 		},
 	},
+	.dev_attr	= &capability_alwon_dev_attr,
 	.slaves		= omap2420_timer6_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer6_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
@@ -526,6 +542,7 @@ static struct omap_hwmod omap2420_timer7_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_GPT7_SHIFT,
 		},
 	},
+	.dev_attr	= &capability_alwon_dev_attr,
 	.slaves		= omap2420_timer7_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer7_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
@@ -562,6 +579,7 @@ static struct omap_hwmod omap2420_timer8_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_GPT8_SHIFT,
 		},
 	},
+	.dev_attr	= &capability_alwon_dev_attr,
 	.slaves		= omap2420_timer8_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer8_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
@@ -598,6 +616,7 @@ static struct omap_hwmod omap2420_timer9_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_GPT9_SHIFT,
 		},
 	},
+	.dev_attr	= &capability_pwm_dev_attr,
 	.slaves		= omap2420_timer9_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer9_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
@@ -634,6 +653,7 @@ static struct omap_hwmod omap2420_timer10_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_GPT10_SHIFT,
 		},
 	},
+	.dev_attr	= &capability_pwm_dev_attr,
 	.slaves		= omap2420_timer10_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer10_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
@@ -670,6 +690,7 @@ static struct omap_hwmod omap2420_timer11_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_GPT11_SHIFT,
 		},
 	},
+	.dev_attr	= &capability_pwm_dev_attr,
 	.slaves		= omap2420_timer11_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer11_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
@@ -706,6 +727,7 @@ static struct omap_hwmod omap2420_timer12_hwmod = {
 			.idlest_idle_bit = OMAP24XX_ST_GPT12_SHIFT,
 		},
 	},
+	.dev_attr	= &capability_pwm_dev_attr,
 	.slaves		= omap2420_timer12_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer12_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,

commit d6504acd2125984c61dce24727dd3842d0144015
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Sep 14 17:23:19 2011 -0600

    OMAP2+: hwmod: remove OMAP_CHIP*
    
    At Tony's request, remove the OMAP_CHIP* flags from the hwmod data, and
    replace it instead with chip family, variant, and ES level-specific lists
    of hwmods to register.
    
    Thanks to Gra≈ævydas Ignotas <notasas@gmail.com> for finding a bug in the
    AM3517/3505 support, and for other review comments.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Gra≈ævydas Ignotas <notasas@gmail.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index a015c69068f6..b6ea69a5c2f8 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -100,7 +100,6 @@ static struct omap_hwmod omap2420_l3_main_hwmod = {
 	.masters_cnt	= ARRAY_SIZE(omap2420_l3_main_masters),
 	.slaves		= omap2420_l3_main_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_l3_main_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 	.flags		= HWMOD_NO_IDLEST,
 };
 
@@ -206,7 +205,6 @@ static struct omap_hwmod omap2420_l4_core_hwmod = {
 	.masters_cnt	= ARRAY_SIZE(omap2420_l4_core_masters),
 	.slaves		= omap2420_l4_core_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_l4_core_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 	.flags		= HWMOD_NO_IDLEST,
 };
 
@@ -227,7 +225,6 @@ static struct omap_hwmod omap2420_l4_wkup_hwmod = {
 	.masters_cnt	= ARRAY_SIZE(omap2420_l4_wkup_masters),
 	.slaves		= omap2420_l4_wkup_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_l4_wkup_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 	.flags		= HWMOD_NO_IDLEST,
 };
 
@@ -243,7 +240,6 @@ static struct omap_hwmod omap2420_mpu_hwmod = {
 	.main_clk	= "mpu_ck",
 	.masters	= omap2420_mpu_masters,
 	.masters_cnt	= ARRAY_SIZE(omap2420_mpu_masters),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
 /*
@@ -271,7 +267,6 @@ static struct omap_hwmod omap2420_iva_hwmod = {
 	.class		= &iva_hwmod_class,
 	.masters	= omap2420_iva_masters,
 	.masters_cnt	= ARRAY_SIZE(omap2420_iva_masters),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
 /* timer1 */
@@ -317,7 +312,6 @@ static struct omap_hwmod omap2420_timer1_hwmod = {
 	.slaves		= omap2420_timer1_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer1_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
 /* timer2 */
@@ -354,7 +348,6 @@ static struct omap_hwmod omap2420_timer2_hwmod = {
 	.slaves		= omap2420_timer2_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer2_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
 /* timer3 */
@@ -391,7 +384,6 @@ static struct omap_hwmod omap2420_timer3_hwmod = {
 	.slaves		= omap2420_timer3_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer3_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
 /* timer4 */
@@ -428,7 +420,6 @@ static struct omap_hwmod omap2420_timer4_hwmod = {
 	.slaves		= omap2420_timer4_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer4_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
 /* timer5 */
@@ -465,7 +456,6 @@ static struct omap_hwmod omap2420_timer5_hwmod = {
 	.slaves		= omap2420_timer5_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer5_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
 
@@ -503,7 +493,6 @@ static struct omap_hwmod omap2420_timer6_hwmod = {
 	.slaves		= omap2420_timer6_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer6_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
 /* timer7 */
@@ -540,7 +529,6 @@ static struct omap_hwmod omap2420_timer7_hwmod = {
 	.slaves		= omap2420_timer7_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer7_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
 /* timer8 */
@@ -577,7 +565,6 @@ static struct omap_hwmod omap2420_timer8_hwmod = {
 	.slaves		= omap2420_timer8_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer8_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
 /* timer9 */
@@ -614,7 +601,6 @@ static struct omap_hwmod omap2420_timer9_hwmod = {
 	.slaves		= omap2420_timer9_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer9_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
 /* timer10 */
@@ -651,7 +637,6 @@ static struct omap_hwmod omap2420_timer10_hwmod = {
 	.slaves		= omap2420_timer10_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer10_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
 /* timer11 */
@@ -688,7 +673,6 @@ static struct omap_hwmod omap2420_timer11_hwmod = {
 	.slaves		= omap2420_timer11_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer11_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
 /* timer12 */
@@ -725,7 +709,6 @@ static struct omap_hwmod omap2420_timer12_hwmod = {
 	.slaves		= omap2420_timer12_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer12_slaves),
 	.class		= &omap2xxx_timer_hwmod_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
 /* l4_wkup -> wd_timer2 */
@@ -766,7 +749,6 @@ static struct omap_hwmod omap2420_wd_timer2_hwmod = {
 	},
 	.slaves		= omap2420_wd_timer2_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_wd_timer2_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
 /* UART1 */
@@ -792,7 +774,6 @@ static struct omap_hwmod omap2420_uart1_hwmod = {
 	.slaves		= omap2420_uart1_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_uart1_slaves),
 	.class		= &omap2_uart_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
 /* UART2 */
@@ -818,7 +799,6 @@ static struct omap_hwmod omap2420_uart2_hwmod = {
 	.slaves		= omap2420_uart2_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_uart2_slaves),
 	.class		= &omap2_uart_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
 /* UART3 */
@@ -844,7 +824,6 @@ static struct omap_hwmod omap2420_uart3_hwmod = {
 	.slaves		= omap2420_uart3_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_uart3_slaves),
 	.class		= &omap2_uart_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
 /* dss */
@@ -898,7 +877,6 @@ static struct omap_hwmod omap2420_dss_core_hwmod = {
 	.slaves_cnt	= ARRAY_SIZE(omap2420_dss_slaves),
 	.masters	= omap2420_dss_masters,
 	.masters_cnt	= ARRAY_SIZE(omap2420_dss_masters),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 	.flags		= HWMOD_NO_IDLEST,
 };
 
@@ -938,7 +916,6 @@ static struct omap_hwmod omap2420_dss_dispc_hwmod = {
 	},
 	.slaves		= omap2420_dss_dispc_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_dss_dispc_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 	.flags		= HWMOD_NO_IDLEST,
 };
 
@@ -975,7 +952,6 @@ static struct omap_hwmod omap2420_dss_rfbi_hwmod = {
 	},
 	.slaves		= omap2420_dss_rfbi_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_dss_rfbi_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 	.flags		= HWMOD_NO_IDLEST,
 };
 
@@ -1013,7 +989,6 @@ static struct omap_hwmod omap2420_dss_venc_hwmod = {
 	},
 	.slaves		= omap2420_dss_venc_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_dss_venc_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 	.flags		= HWMOD_NO_IDLEST,
 };
 
@@ -1064,7 +1039,6 @@ static struct omap_hwmod omap2420_i2c1_hwmod = {
 	.slaves_cnt	= ARRAY_SIZE(omap2420_i2c1_slaves),
 	.class		= &i2c_class,
 	.dev_attr	= &i2c_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 	.flags		= HWMOD_16BIT_REG,
 };
 
@@ -1092,7 +1066,6 @@ static struct omap_hwmod omap2420_i2c2_hwmod = {
 	.slaves_cnt	= ARRAY_SIZE(omap2420_i2c2_slaves),
 	.class		= &i2c_class,
 	.dev_attr	= &i2c_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 	.flags		= HWMOD_16BIT_REG,
 };
 
@@ -1197,7 +1170,6 @@ static struct omap_hwmod omap2420_gpio1_hwmod = {
 	.slaves_cnt	= ARRAY_SIZE(omap2420_gpio1_slaves),
 	.class		= &omap2xxx_gpio_hwmod_class,
 	.dev_attr	= &gpio_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
 /* gpio2 */
@@ -1223,7 +1195,6 @@ static struct omap_hwmod omap2420_gpio2_hwmod = {
 	.slaves_cnt	= ARRAY_SIZE(omap2420_gpio2_slaves),
 	.class		= &omap2xxx_gpio_hwmod_class,
 	.dev_attr	= &gpio_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
 /* gpio3 */
@@ -1249,7 +1220,6 @@ static struct omap_hwmod omap2420_gpio3_hwmod = {
 	.slaves_cnt	= ARRAY_SIZE(omap2420_gpio3_slaves),
 	.class		= &omap2xxx_gpio_hwmod_class,
 	.dev_attr	= &gpio_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
 /* gpio4 */
@@ -1275,7 +1245,6 @@ static struct omap_hwmod omap2420_gpio4_hwmod = {
 	.slaves_cnt	= ARRAY_SIZE(omap2420_gpio4_slaves),
 	.class		= &omap2xxx_gpio_hwmod_class,
 	.dev_attr	= &gpio_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
 /* dma attributes */
@@ -1322,7 +1291,6 @@ static struct omap_hwmod omap2420_dma_system_hwmod = {
 	.masters	= omap2420_dma_system_masters,
 	.masters_cnt	= ARRAY_SIZE(omap2420_dma_system_masters),
 	.dev_attr	= &dma_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 	.flags		= HWMOD_NO_IDLEST,
 };
 
@@ -1363,7 +1331,6 @@ static struct omap_hwmod omap2420_mailbox_hwmod = {
 	},
 	.slaves		= omap2420_mailbox_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_mailbox_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
 /* mcspi1 */
@@ -1393,7 +1360,6 @@ static struct omap_hwmod omap2420_mcspi1_hwmod = {
 	.slaves_cnt	= ARRAY_SIZE(omap2420_mcspi1_slaves),
 	.class		= &omap2xxx_mcspi_class,
 	.dev_attr	= &omap_mcspi1_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
 /* mcspi2 */
@@ -1423,7 +1389,6 @@ static struct omap_hwmod omap2420_mcspi2_hwmod = {
 	.slaves_cnt	= ARRAY_SIZE(omap2420_mcspi2_slaves),
 	.class		= &omap2xxx_mcspi_class,
 	.dev_attr	= &omap_mcspi2_dev_attr,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
 /*
@@ -1473,7 +1438,6 @@ static struct omap_hwmod omap2420_mcbsp1_hwmod = {
 	},
 	.slaves		= omap2420_mcbsp1_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_mcbsp1_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
 /* mcbsp2 */
@@ -1514,7 +1478,6 @@ static struct omap_hwmod omap2420_mcbsp2_hwmod = {
 	},
 	.slaves		= omap2420_mcbsp2_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_mcbsp2_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
 static __initdata struct omap_hwmod *omap2420_hwmods[] = {

commit 6d3c55fd4f0f94a9455d30df9414ddb0f755f402
Author: Avinash.H.M <avinashhm@ti.com>
Date:   Sun Jul 10 05:27:16 2011 -0600

    OMAP: hwmod: fix the i2c-reset timeout during bootup
    
    The sequence of _ocp_softreset doesn't work for i2c. The i2c module has a
    special sequence to reset the module. The sequence is
     - Disable the I2C.
     - Write to SOFTRESET bit.
     - Enable the I2C.
     - Poll on the RESETDONE bit.
    The sequence is implemented as a function and the i2c_class is updated with
    the correct 'reset' pointer.  omap_hwmod_softreset function is implemented
    which triggers the softreset by writing into sysconfig register. On following
    this sequence, i2c module resets properly and timeouts are not seen.
    
    Cc: Rajendra Nayak <rnayak@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Avinash.H.M <avinashhm@ti.com>
    [paul@pwsan.com: combined this patch with a patch to remove
     HWMOD_INIT_NO_RESET from the 44xx hwmod flags; change register
     offset conditional code to use the IP block revision; minor code
     cleanup]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 7af251448a7e..a015c69068f6 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -1030,6 +1030,7 @@ static struct omap_hwmod_class i2c_class = {
 	.name		= "i2c",
 	.sysc		= &i2c_sysc,
 	.rev		= OMAP_I2C_IP_VERSION_1,
+	.reset		= &omap_i2c_reset,
 };
 
 static struct omap_i2c_dev_attr i2c_dev_attr = {

commit 4d4441a6221ca3a30290045b7b696e5134646449
Author: Andy Green <andy@warmcat.com>
Date:   Sun Jul 10 05:27:16 2011 -0600

    I2C: OMAP2+: add correct functionality flags to all omap2plus i2c dev_attr
    
    This adds the new functionality flags for omap i2c unit to all OMAP2
    hwmod definitions
    
    Cc: patches@linaro.org
    Cc: Ben Dooks <ben-linux@fluff.org>
    Reported-by: Peter Maydell <peter.maydell@linaro.org>
    Signed-off-by: Andy Green <andy.green@linaro.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 95f547cf35d8..7af251448a7e 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -1032,7 +1032,12 @@ static struct omap_hwmod_class i2c_class = {
 	.rev		= OMAP_I2C_IP_VERSION_1,
 };
 
-static struct omap_i2c_dev_attr i2c_dev_attr;
+static struct omap_i2c_dev_attr i2c_dev_attr = {
+	.flags		= OMAP_I2C_FLAG_NO_FIFO |
+			  OMAP_I2C_FLAG_SIMPLE_CLOCK |
+			  OMAP_I2C_FLAG_16BIT_DATA_REG |
+			  OMAP_I2C_FLAG_BUS_SHIFT_2,
+};
 
 /* I2C1 */
 

commit db791a75299bb6212ec984bdbe4ab581dbc07902
Author: Andy Green <andy@warmcat.com>
Date:   Sun Jul 10 05:27:15 2011 -0600

    I2C: OMAP2+: Tag all OMAP2+ hwmod defintions with I2C IP revision
    
    Since we cannot trust (or even reliably find) the OMAP I2C
    peripheral unit's own revision register, we must inform the
    OMAP i2c driver of which IP version it is running on.  We
    do this by tagging the omap_hwmod_class for i2c on all the
    OMAP2+ platform / cpu specific hwmod init and passing it up
    to the driver (next patches).
    
    Cc: patches@linaro.org
    Cc: Ben Dooks <ben-linux@fluff.org>
    Reported-by: Peter Maydell <peter.maydell@linaro.org>
    Signed-off-by: Andy Green <andy.green@linaro.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index f3901abf2c28..95f547cf35d8 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -1029,6 +1029,7 @@ static struct omap_hwmod_class_sysconfig i2c_sysc = {
 static struct omap_hwmod_class i2c_class = {
 	.name		= "i2c",
 	.sysc		= &i2c_sysc,
+	.rev		= OMAP_I2C_IP_VERSION_1,
 };
 
 static struct omap_i2c_dev_attr i2c_dev_attr;

commit 273b9465bc68d4f4bcdedc34411b231e26b48416
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Jul 9 19:14:08 2011 -0600

    omap_hwmod: share identical omap_hwmod_class, omap_hwmod_class_sysconfig arrays
    
    To reduce kernel source file data duplication, share struct
    omap_hwmod_class and omap_hwmod_class_sysconfig arrays across OMAP2xxx
    and 3xxx hwmod data files.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 6acc01f58902..f3901abf2c28 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -274,24 +274,6 @@ static struct omap_hwmod omap2420_iva_hwmod = {
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
-/* Timer Common */
-static struct omap_hwmod_class_sysconfig omap2420_timer_sysc = {
-	.rev_offs	= 0x0000,
-	.sysc_offs	= 0x0010,
-	.syss_offs	= 0x0014,
-	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_CLOCKACTIVITY |
-			   SYSC_HAS_ENAWAKEUP | SYSC_HAS_SOFTRESET |
-			   SYSC_HAS_AUTOIDLE),
-	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
-	.sysc_fields    = &omap_hwmod_sysc_type1,
-};
-
-static struct omap_hwmod_class omap2420_timer_hwmod_class = {
-	.name = "timer",
-	.sysc = &omap2420_timer_sysc,
-	.rev = OMAP_TIMER_IP_VERSION_1,
-};
-
 /* timer1 */
 static struct omap_hwmod omap2420_timer1_hwmod;
 
@@ -334,7 +316,7 @@ static struct omap_hwmod omap2420_timer1_hwmod = {
 	},
 	.slaves		= omap2420_timer1_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer1_slaves),
-	.class		= &omap2420_timer_hwmod_class,
+	.class		= &omap2xxx_timer_hwmod_class,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
@@ -371,7 +353,7 @@ static struct omap_hwmod omap2420_timer2_hwmod = {
 	},
 	.slaves		= omap2420_timer2_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer2_slaves),
-	.class		= &omap2420_timer_hwmod_class,
+	.class		= &omap2xxx_timer_hwmod_class,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
@@ -408,7 +390,7 @@ static struct omap_hwmod omap2420_timer3_hwmod = {
 	},
 	.slaves		= omap2420_timer3_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer3_slaves),
-	.class		= &omap2420_timer_hwmod_class,
+	.class		= &omap2xxx_timer_hwmod_class,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
@@ -445,7 +427,7 @@ static struct omap_hwmod omap2420_timer4_hwmod = {
 	},
 	.slaves		= omap2420_timer4_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer4_slaves),
-	.class		= &omap2420_timer_hwmod_class,
+	.class		= &omap2xxx_timer_hwmod_class,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
@@ -482,7 +464,7 @@ static struct omap_hwmod omap2420_timer5_hwmod = {
 	},
 	.slaves		= omap2420_timer5_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer5_slaves),
-	.class		= &omap2420_timer_hwmod_class,
+	.class		= &omap2xxx_timer_hwmod_class,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
@@ -520,7 +502,7 @@ static struct omap_hwmod omap2420_timer6_hwmod = {
 	},
 	.slaves		= omap2420_timer6_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer6_slaves),
-	.class		= &omap2420_timer_hwmod_class,
+	.class		= &omap2xxx_timer_hwmod_class,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
@@ -557,7 +539,7 @@ static struct omap_hwmod omap2420_timer7_hwmod = {
 	},
 	.slaves		= omap2420_timer7_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer7_slaves),
-	.class		= &omap2420_timer_hwmod_class,
+	.class		= &omap2xxx_timer_hwmod_class,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
@@ -594,7 +576,7 @@ static struct omap_hwmod omap2420_timer8_hwmod = {
 	},
 	.slaves		= omap2420_timer8_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer8_slaves),
-	.class		= &omap2420_timer_hwmod_class,
+	.class		= &omap2xxx_timer_hwmod_class,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
@@ -631,7 +613,7 @@ static struct omap_hwmod omap2420_timer9_hwmod = {
 	},
 	.slaves		= omap2420_timer9_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer9_slaves),
-	.class		= &omap2420_timer_hwmod_class,
+	.class		= &omap2xxx_timer_hwmod_class,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
@@ -668,7 +650,7 @@ static struct omap_hwmod omap2420_timer10_hwmod = {
 	},
 	.slaves		= omap2420_timer10_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer10_slaves),
-	.class		= &omap2420_timer_hwmod_class,
+	.class		= &omap2xxx_timer_hwmod_class,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
@@ -705,7 +687,7 @@ static struct omap_hwmod omap2420_timer11_hwmod = {
 	},
 	.slaves		= omap2420_timer11_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer11_slaves),
-	.class		= &omap2420_timer_hwmod_class,
+	.class		= &omap2xxx_timer_hwmod_class,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
@@ -742,7 +724,7 @@ static struct omap_hwmod omap2420_timer12_hwmod = {
 	},
 	.slaves		= omap2420_timer12_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_timer12_slaves),
-	.class		= &omap2420_timer_hwmod_class,
+	.class		= &omap2xxx_timer_hwmod_class,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
@@ -764,27 +746,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_wkup__wd_timer2 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/*
- * 'wd_timer' class
- * 32-bit watchdog upward counter that generates a pulse on the reset pin on
- * overflow condition
- */
-
-static struct omap_hwmod_class_sysconfig omap2420_wd_timer_sysc = {
-	.rev_offs	= 0x0000,
-	.sysc_offs	= 0x0010,
-	.syss_offs	= 0x0014,
-	.sysc_flags	= (SYSC_HAS_EMUFREE | SYSC_HAS_SOFTRESET |
-			   SYSC_HAS_AUTOIDLE | SYSS_HAS_RESET_STATUS),
-	.sysc_fields    = &omap_hwmod_sysc_type1,
-};
-
-static struct omap_hwmod_class omap2420_wd_timer_hwmod_class = {
-	.name		= "wd_timer",
-	.sysc		= &omap2420_wd_timer_sysc,
-	.pre_shutdown	= &omap2_wd_timer_disable
-};
-
 /* wd_timer2 */
 static struct omap_hwmod_ocp_if *omap2420_wd_timer2_slaves[] = {
 	&omap2420_l4_wkup__wd_timer2,
@@ -792,7 +753,7 @@ static struct omap_hwmod_ocp_if *omap2420_wd_timer2_slaves[] = {
 
 static struct omap_hwmod omap2420_wd_timer2_hwmod = {
 	.name		= "wd_timer2",
-	.class		= &omap2420_wd_timer_hwmod_class,
+	.class		= &omap2xxx_wd_timer_hwmod_class,
 	.main_clk	= "mpu_wdt_fck",
 	.prcm		= {
 		.omap2 = {
@@ -808,24 +769,6 @@ static struct omap_hwmod omap2420_wd_timer2_hwmod = {
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
-/* UART */
-
-static struct omap_hwmod_class_sysconfig uart_sysc = {
-	.rev_offs	= 0x50,
-	.sysc_offs	= 0x54,
-	.syss_offs	= 0x58,
-	.sysc_flags	= (SYSC_HAS_SIDLEMODE |
-			   SYSC_HAS_ENAWAKEUP | SYSC_HAS_SOFTRESET |
-			   SYSC_HAS_AUTOIDLE | SYSS_HAS_RESET_STATUS),
-	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
-	.sysc_fields    = &omap_hwmod_sysc_type1,
-};
-
-static struct omap_hwmod_class uart_class = {
-	.name = "uart",
-	.sysc = &uart_sysc,
-};
-
 /* UART1 */
 
 static struct omap_hwmod_ocp_if *omap2420_uart1_slaves[] = {
@@ -848,7 +791,7 @@ static struct omap_hwmod omap2420_uart1_hwmod = {
 	},
 	.slaves		= omap2420_uart1_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_uart1_slaves),
-	.class		= &uart_class,
+	.class		= &omap2_uart_class,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
@@ -874,7 +817,7 @@ static struct omap_hwmod omap2420_uart2_hwmod = {
 	},
 	.slaves		= omap2420_uart2_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_uart2_slaves),
-	.class		= &uart_class,
+	.class		= &omap2_uart_class,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
@@ -900,28 +843,10 @@ static struct omap_hwmod omap2420_uart3_hwmod = {
 	},
 	.slaves		= omap2420_uart3_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_uart3_slaves),
-	.class		= &uart_class,
+	.class		= &omap2_uart_class,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
-/*
- * 'dss' class
- * display sub-system
- */
-
-static struct omap_hwmod_class_sysconfig omap2420_dss_sysc = {
-	.rev_offs	= 0x0000,
-	.sysc_offs	= 0x0010,
-	.syss_offs	= 0x0014,
-	.sysc_flags	= (SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
-	.sysc_fields	= &omap_hwmod_sysc_type1,
-};
-
-static struct omap_hwmod_class omap2420_dss_hwmod_class = {
-	.name = "dss",
-	.sysc = &omap2420_dss_sysc,
-};
-
 /* dss */
 /* dss master ports */
 static struct omap_hwmod_ocp_if *omap2420_dss_masters[] = {
@@ -955,7 +880,7 @@ static struct omap_hwmod_opt_clk dss_opt_clks[] = {
 
 static struct omap_hwmod omap2420_dss_core_hwmod = {
 	.name		= "dss_core",
-	.class		= &omap2420_dss_hwmod_class,
+	.class		= &omap2_dss_hwmod_class,
 	.main_clk	= "dss1_fck", /* instead of dss_fck */
 	.sdma_reqs	= omap2xxx_dss_sdma_chs,
 	.prcm		= {
@@ -977,27 +902,6 @@ static struct omap_hwmod omap2420_dss_core_hwmod = {
 	.flags		= HWMOD_NO_IDLEST,
 };
 
-/*
- * 'dispc' class
- * display controller
- */
-
-static struct omap_hwmod_class_sysconfig omap2420_dispc_sysc = {
-	.rev_offs	= 0x0000,
-	.sysc_offs	= 0x0010,
-	.syss_offs	= 0x0014,
-	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_MIDLEMODE |
-			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
-	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
-			   MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
-	.sysc_fields	= &omap_hwmod_sysc_type1,
-};
-
-static struct omap_hwmod_class omap2420_dispc_hwmod_class = {
-	.name = "dispc",
-	.sysc = &omap2420_dispc_sysc,
-};
-
 /* l4_core -> dss_dispc */
 static struct omap_hwmod_ocp_if omap2420_l4_core__dss_dispc = {
 	.master		= &omap2420_l4_core_hwmod,
@@ -1020,7 +924,7 @@ static struct omap_hwmod_ocp_if *omap2420_dss_dispc_slaves[] = {
 
 static struct omap_hwmod omap2420_dss_dispc_hwmod = {
 	.name		= "dss_dispc",
-	.class		= &omap2420_dispc_hwmod_class,
+	.class		= &omap2_dispc_hwmod_class,
 	.mpu_irqs	= omap2_dispc_irqs,
 	.main_clk	= "dss1_fck",
 	.prcm		= {
@@ -1038,26 +942,6 @@ static struct omap_hwmod omap2420_dss_dispc_hwmod = {
 	.flags		= HWMOD_NO_IDLEST,
 };
 
-/*
- * 'rfbi' class
- * remote frame buffer interface
- */
-
-static struct omap_hwmod_class_sysconfig omap2420_rfbi_sysc = {
-	.rev_offs	= 0x0000,
-	.sysc_offs	= 0x0010,
-	.syss_offs	= 0x0014,
-	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET |
-			   SYSC_HAS_AUTOIDLE),
-	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
-	.sysc_fields	= &omap_hwmod_sysc_type1,
-};
-
-static struct omap_hwmod_class omap2420_rfbi_hwmod_class = {
-	.name = "rfbi",
-	.sysc = &omap2420_rfbi_sysc,
-};
-
 /* l4_core -> dss_rfbi */
 static struct omap_hwmod_ocp_if omap2420_l4_core__dss_rfbi = {
 	.master		= &omap2420_l4_core_hwmod,
@@ -1080,7 +964,7 @@ static struct omap_hwmod_ocp_if *omap2420_dss_rfbi_slaves[] = {
 
 static struct omap_hwmod omap2420_dss_rfbi_hwmod = {
 	.name		= "dss_rfbi",
-	.class		= &omap2420_rfbi_hwmod_class,
+	.class		= &omap2_rfbi_hwmod_class,
 	.main_clk	= "dss1_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1095,15 +979,6 @@ static struct omap_hwmod omap2420_dss_rfbi_hwmod = {
 	.flags		= HWMOD_NO_IDLEST,
 };
 
-/*
- * 'venc' class
- * video encoder
- */
-
-static struct omap_hwmod_class omap2420_venc_hwmod_class = {
-	.name = "venc",
-};
-
 /* l4_core -> dss_venc */
 static struct omap_hwmod_ocp_if omap2420_l4_core__dss_venc = {
 	.master		= &omap2420_l4_core_hwmod,
@@ -1127,7 +1002,7 @@ static struct omap_hwmod_ocp_if *omap2420_dss_venc_slaves[] = {
 
 static struct omap_hwmod omap2420_dss_venc_hwmod = {
 	.name		= "dss_venc",
-	.class		= &omap2420_venc_hwmod_class,
+	.class		= &omap2_venc_hwmod_class,
 	.main_clk	= "dss1_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1292,27 +1167,6 @@ static struct omap_gpio_dev_attr gpio_dev_attr = {
 	.dbck_flag = false,
 };
 
-static struct omap_hwmod_class_sysconfig omap242x_gpio_sysc = {
-	.rev_offs	= 0x0000,
-	.sysc_offs	= 0x0010,
-	.syss_offs	= 0x0014,
-	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
-			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE |
-			   SYSS_HAS_RESET_STATUS),
-	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
-	.sysc_fields    = &omap_hwmod_sysc_type1,
-};
-
-/*
- * 'gpio' class
- * general purpose io module
- */
-static struct omap_hwmod_class omap242x_gpio_hwmod_class = {
-	.name = "gpio",
-	.sysc = &omap242x_gpio_sysc,
-	.rev = 0,
-};
-
 /* gpio1 */
 static struct omap_hwmod_ocp_if *omap2420_gpio1_slaves[] = {
 	&omap2420_l4_wkup__gpio1,
@@ -1334,7 +1188,7 @@ static struct omap_hwmod omap2420_gpio1_hwmod = {
 	},
 	.slaves		= omap2420_gpio1_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_gpio1_slaves),
-	.class		= &omap242x_gpio_hwmod_class,
+	.class		= &omap2xxx_gpio_hwmod_class,
 	.dev_attr	= &gpio_dev_attr,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
@@ -1360,7 +1214,7 @@ static struct omap_hwmod omap2420_gpio2_hwmod = {
 	},
 	.slaves		= omap2420_gpio2_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_gpio2_slaves),
-	.class		= &omap242x_gpio_hwmod_class,
+	.class		= &omap2xxx_gpio_hwmod_class,
 	.dev_attr	= &gpio_dev_attr,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
@@ -1386,7 +1240,7 @@ static struct omap_hwmod omap2420_gpio3_hwmod = {
 	},
 	.slaves		= omap2420_gpio3_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_gpio3_slaves),
-	.class		= &omap242x_gpio_hwmod_class,
+	.class		= &omap2xxx_gpio_hwmod_class,
 	.dev_attr	= &gpio_dev_attr,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
@@ -1412,28 +1266,11 @@ static struct omap_hwmod omap2420_gpio4_hwmod = {
 	},
 	.slaves		= omap2420_gpio4_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_gpio4_slaves),
-	.class		= &omap242x_gpio_hwmod_class,
+	.class		= &omap2xxx_gpio_hwmod_class,
 	.dev_attr	= &gpio_dev_attr,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
-/* system dma */
-static struct omap_hwmod_class_sysconfig omap2420_dma_sysc = {
-	.rev_offs	= 0x0000,
-	.sysc_offs	= 0x002c,
-	.syss_offs	= 0x0028,
-	.sysc_flags	= (SYSC_HAS_SOFTRESET | SYSC_HAS_MIDLEMODE |
-			   SYSC_HAS_CLOCKACTIVITY | SYSC_HAS_EMUFREE |
-			   SYSC_HAS_AUTOIDLE | SYSS_HAS_RESET_STATUS),
-	.idlemodes	= (MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
-	.sysc_fields	= &omap_hwmod_sysc_type1,
-};
-
-static struct omap_hwmod_class omap2420_dma_hwmod_class = {
-	.name = "dma",
-	.sysc = &omap2420_dma_sysc,
-};
-
 /* dma attributes */
 static struct omap_dma_dev_attr dma_dev_attr = {
 	.dev_caps  = RESERVE_CHANNEL | DMA_LINKED_LCH | GLOBAL_PRIORITY |
@@ -1470,7 +1307,7 @@ static struct omap_hwmod_ocp_if *omap2420_dma_system_slaves[] = {
 
 static struct omap_hwmod omap2420_dma_system_hwmod = {
 	.name		= "dma",
-	.class		= &omap2420_dma_hwmod_class,
+	.class		= &omap2xxx_dma_hwmod_class,
 	.mpu_irqs	= omap2_dma_system_irqs,
 	.main_clk	= "core_l3_ck",
 	.slaves		= omap2420_dma_system_slaves,
@@ -1482,27 +1319,6 @@ static struct omap_hwmod omap2420_dma_system_hwmod = {
 	.flags		= HWMOD_NO_IDLEST,
 };
 
-/*
- * 'mailbox' class
- * mailbox module allowing communication between the on-chip processors
- * using a queued mailbox-interrupt mechanism.
- */
-
-static struct omap_hwmod_class_sysconfig omap2420_mailbox_sysc = {
-	.rev_offs	= 0x000,
-	.sysc_offs	= 0x010,
-	.syss_offs	= 0x014,
-	.sysc_flags	= (SYSC_HAS_CLOCKACTIVITY | SYSC_HAS_SIDLEMODE |
-			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
-	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
-	.sysc_fields	= &omap_hwmod_sysc_type1,
-};
-
-static struct omap_hwmod_class omap2420_mailbox_hwmod_class = {
-	.name = "mailbox",
-	.sysc = &omap2420_mailbox_sysc,
-};
-
 /* mailbox */
 static struct omap_hwmod omap2420_mailbox_hwmod;
 static struct omap_hwmod_irq_info omap2420_mailbox_irqs[] = {
@@ -1526,7 +1342,7 @@ static struct omap_hwmod_ocp_if *omap2420_mailbox_slaves[] = {
 
 static struct omap_hwmod omap2420_mailbox_hwmod = {
 	.name		= "mailbox",
-	.class		= &omap2420_mailbox_hwmod_class,
+	.class		= &omap2xxx_mailbox_hwmod_class,
 	.mpu_irqs	= omap2420_mailbox_irqs,
 	.main_clk	= "mailboxes_ick",
 	.prcm		= {
@@ -1543,29 +1359,6 @@ static struct omap_hwmod omap2420_mailbox_hwmod = {
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
-/*
- * 'mcspi' class
- * multichannel serial port interface (mcspi) / master/slave synchronous serial
- * bus
- */
-
-static struct omap_hwmod_class_sysconfig omap2420_mcspi_sysc = {
-	.rev_offs	= 0x0000,
-	.sysc_offs	= 0x0010,
-	.syss_offs	= 0x0014,
-	.sysc_flags	= (SYSC_HAS_CLOCKACTIVITY | SYSC_HAS_SIDLEMODE |
-				SYSC_HAS_ENAWAKEUP | SYSC_HAS_SOFTRESET |
-				SYSC_HAS_AUTOIDLE | SYSS_HAS_RESET_STATUS),
-	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
-	.sysc_fields    = &omap_hwmod_sysc_type1,
-};
-
-static struct omap_hwmod_class omap2420_mcspi_class = {
-	.name = "mcspi",
-	.sysc = &omap2420_mcspi_sysc,
-	.rev = OMAP2_MCSPI_REV,
-};
-
 /* mcspi1 */
 static struct omap_hwmod_ocp_if *omap2420_mcspi1_slaves[] = {
 	&omap2420_l4_core__mcspi1,
@@ -1591,8 +1384,8 @@ static struct omap_hwmod omap2420_mcspi1_hwmod = {
 	},
 	.slaves		= omap2420_mcspi1_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_mcspi1_slaves),
-	.class		= &omap2420_mcspi_class,
-	.dev_attr       = &omap_mcspi1_dev_attr,
+	.class		= &omap2xxx_mcspi_class,
+	.dev_attr	= &omap_mcspi1_dev_attr,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
@@ -1621,8 +1414,8 @@ static struct omap_hwmod omap2420_mcspi2_hwmod = {
 	},
 	.slaves		= omap2420_mcspi2_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_mcspi2_slaves),
-	.class		= &omap2420_mcspi_class,
-	.dev_attr       = &omap_mcspi2_dev_attr,
+	.class		= &omap2xxx_mcspi_class,
+	.dev_attr	= &omap_mcspi2_dev_attr,
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 

commit d826ebfa49aeb8a8f4d216165e5e00826741ad9c
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Jul 9 19:14:07 2011 -0600

    omap_hwmod: share identical omap_hwmod_dma_info arrays
    
    To reduce kernel source file data duplication, share struct
    omap_hwmod_dma_info arrays across OMAP2xxx and 3xxx hwmod data files.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 60c817e63c3b..6acc01f58902 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -828,12 +828,6 @@ static struct omap_hwmod_class uart_class = {
 
 /* UART1 */
 
-static struct omap_hwmod_dma_info uart1_sdma_reqs[] = {
-	{ .name = "rx",	.dma_req = OMAP24XX_DMA_UART1_RX, },
-	{ .name = "tx",	.dma_req = OMAP24XX_DMA_UART1_TX, },
-	{ .dma_req = -1 }
-};
-
 static struct omap_hwmod_ocp_if *omap2420_uart1_slaves[] = {
 	&omap2_l4_core__uart1,
 };
@@ -841,7 +835,7 @@ static struct omap_hwmod_ocp_if *omap2420_uart1_slaves[] = {
 static struct omap_hwmod omap2420_uart1_hwmod = {
 	.name		= "uart1",
 	.mpu_irqs	= omap2_uart1_mpu_irqs,
-	.sdma_reqs	= uart1_sdma_reqs,
+	.sdma_reqs	= omap2_uart1_sdma_reqs,
 	.main_clk	= "uart1_fck",
 	.prcm		= {
 		.omap2 = {
@@ -860,12 +854,6 @@ static struct omap_hwmod omap2420_uart1_hwmod = {
 
 /* UART2 */
 
-static struct omap_hwmod_dma_info uart2_sdma_reqs[] = {
-	{ .name = "rx",	.dma_req = OMAP24XX_DMA_UART2_RX, },
-	{ .name = "tx",	.dma_req = OMAP24XX_DMA_UART2_TX, },
-	{ .dma_req = -1 }
-};
-
 static struct omap_hwmod_ocp_if *omap2420_uart2_slaves[] = {
 	&omap2_l4_core__uart2,
 };
@@ -873,7 +861,7 @@ static struct omap_hwmod_ocp_if *omap2420_uart2_slaves[] = {
 static struct omap_hwmod omap2420_uart2_hwmod = {
 	.name		= "uart2",
 	.mpu_irqs	= omap2_uart2_mpu_irqs,
-	.sdma_reqs	= uart2_sdma_reqs,
+	.sdma_reqs	= omap2_uart2_sdma_reqs,
 	.main_clk	= "uart2_fck",
 	.prcm		= {
 		.omap2 = {
@@ -892,12 +880,6 @@ static struct omap_hwmod omap2420_uart2_hwmod = {
 
 /* UART3 */
 
-static struct omap_hwmod_dma_info uart3_sdma_reqs[] = {
-	{ .name = "rx",	.dma_req = OMAP24XX_DMA_UART3_RX, },
-	{ .name = "tx",	.dma_req = OMAP24XX_DMA_UART3_TX, },
-	{ .dma_req = -1 }
-};
-
 static struct omap_hwmod_ocp_if *omap2420_uart3_slaves[] = {
 	&omap2_l4_core__uart3,
 };
@@ -905,7 +887,7 @@ static struct omap_hwmod_ocp_if *omap2420_uart3_slaves[] = {
 static struct omap_hwmod omap2420_uart3_hwmod = {
 	.name		= "uart3",
 	.mpu_irqs	= omap2_uart3_mpu_irqs,
-	.sdma_reqs	= uart3_sdma_reqs,
+	.sdma_reqs	= omap2_uart3_sdma_reqs,
 	.main_clk	= "uart3_fck",
 	.prcm		= {
 		.omap2 = {
@@ -940,11 +922,6 @@ static struct omap_hwmod_class omap2420_dss_hwmod_class = {
 	.sysc = &omap2420_dss_sysc,
 };
 
-static struct omap_hwmod_dma_info omap2420_dss_sdma_chs[] = {
-	{ .name = "dispc", .dma_req = 5 },
-	{ .dma_req = -1 }
-};
-
 /* dss */
 /* dss master ports */
 static struct omap_hwmod_ocp_if *omap2420_dss_masters[] = {
@@ -980,7 +957,7 @@ static struct omap_hwmod omap2420_dss_core_hwmod = {
 	.name		= "dss_core",
 	.class		= &omap2420_dss_hwmod_class,
 	.main_clk	= "dss1_fck", /* instead of dss_fck */
-	.sdma_reqs	= omap2420_dss_sdma_chs,
+	.sdma_reqs	= omap2xxx_dss_sdma_chs,
 	.prcm		= {
 		.omap2 = {
 			.prcm_reg_id = 1,
@@ -1183,12 +1160,6 @@ static struct omap_i2c_dev_attr i2c_dev_attr;
 
 /* I2C1 */
 
-static struct omap_hwmod_dma_info i2c1_sdma_reqs[] = {
-	{ .name = "tx", .dma_req = OMAP24XX_DMA_I2C1_TX },
-	{ .name = "rx", .dma_req = OMAP24XX_DMA_I2C1_RX },
-	{ .dma_req = -1 }
-};
-
 static struct omap_hwmod_ocp_if *omap2420_i2c1_slaves[] = {
 	&omap2420_l4_core__i2c1,
 };
@@ -1196,7 +1167,7 @@ static struct omap_hwmod_ocp_if *omap2420_i2c1_slaves[] = {
 static struct omap_hwmod omap2420_i2c1_hwmod = {
 	.name		= "i2c1",
 	.mpu_irqs	= omap2_i2c1_mpu_irqs,
-	.sdma_reqs	= i2c1_sdma_reqs,
+	.sdma_reqs	= omap2_i2c1_sdma_reqs,
 	.main_clk	= "i2c1_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1217,12 +1188,6 @@ static struct omap_hwmod omap2420_i2c1_hwmod = {
 
 /* I2C2 */
 
-static struct omap_hwmod_dma_info i2c2_sdma_reqs[] = {
-	{ .name = "tx", .dma_req = OMAP24XX_DMA_I2C2_TX },
-	{ .name = "rx", .dma_req = OMAP24XX_DMA_I2C2_RX },
-	{ .dma_req = -1 }
-};
-
 static struct omap_hwmod_ocp_if *omap2420_i2c2_slaves[] = {
 	&omap2420_l4_core__i2c2,
 };
@@ -1230,7 +1195,7 @@ static struct omap_hwmod_ocp_if *omap2420_i2c2_slaves[] = {
 static struct omap_hwmod omap2420_i2c2_hwmod = {
 	.name		= "i2c2",
 	.mpu_irqs	= omap2_i2c2_mpu_irqs,
-	.sdma_reqs	= i2c2_sdma_reqs,
+	.sdma_reqs	= omap2_i2c2_sdma_reqs,
 	.main_clk	= "i2c2_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1602,18 +1567,6 @@ static struct omap_hwmod_class omap2420_mcspi_class = {
 };
 
 /* mcspi1 */
-static struct omap_hwmod_dma_info omap2420_mcspi1_sdma_reqs[] = {
-	{ .name = "tx0", .dma_req = 35 }, /* DMA_SPI1_TX0 */
-	{ .name = "rx0", .dma_req = 36 }, /* DMA_SPI1_RX0 */
-	{ .name = "tx1", .dma_req = 37 }, /* DMA_SPI1_TX1 */
-	{ .name = "rx1", .dma_req = 38 }, /* DMA_SPI1_RX1 */
-	{ .name = "tx2", .dma_req = 39 }, /* DMA_SPI1_TX2 */
-	{ .name = "rx2", .dma_req = 40 }, /* DMA_SPI1_RX2 */
-	{ .name = "tx3", .dma_req = 41 }, /* DMA_SPI1_TX3 */
-	{ .name = "rx3", .dma_req = 42 }, /* DMA_SPI1_RX3 */
-	{ .dma_req = -1 }
-};
-
 static struct omap_hwmod_ocp_if *omap2420_mcspi1_slaves[] = {
 	&omap2420_l4_core__mcspi1,
 };
@@ -1625,7 +1578,7 @@ static struct omap2_mcspi_dev_attr omap_mcspi1_dev_attr = {
 static struct omap_hwmod omap2420_mcspi1_hwmod = {
 	.name		= "mcspi1_hwmod",
 	.mpu_irqs	= omap2_mcspi1_mpu_irqs,
-	.sdma_reqs	= omap2420_mcspi1_sdma_reqs,
+	.sdma_reqs	= omap2_mcspi1_sdma_reqs,
 	.main_clk	= "mcspi1_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1644,14 +1597,6 @@ static struct omap_hwmod omap2420_mcspi1_hwmod = {
 };
 
 /* mcspi2 */
-static struct omap_hwmod_dma_info omap2420_mcspi2_sdma_reqs[] = {
-	{ .name = "tx0", .dma_req = 43 }, /* DMA_SPI2_TX0 */
-	{ .name = "rx0", .dma_req = 44 }, /* DMA_SPI2_RX0 */
-	{ .name = "tx1", .dma_req = 45 }, /* DMA_SPI2_TX1 */
-	{ .name = "rx1", .dma_req = 46 }, /* DMA_SPI2_RX1 */
-	{ .dma_req = -1 }
-};
-
 static struct omap_hwmod_ocp_if *omap2420_mcspi2_slaves[] = {
 	&omap2420_l4_core__mcspi2,
 };
@@ -1663,7 +1608,7 @@ static struct omap2_mcspi_dev_attr omap_mcspi2_dev_attr = {
 static struct omap_hwmod omap2420_mcspi2_hwmod = {
 	.name		= "mcspi2_hwmod",
 	.mpu_irqs	= omap2_mcspi2_mpu_irqs,
-	.sdma_reqs	= omap2420_mcspi2_sdma_reqs,
+	.sdma_reqs	= omap2_mcspi2_sdma_reqs,
 	.main_clk	= "mcspi2_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1697,12 +1642,6 @@ static struct omap_hwmod_irq_info omap2420_mcbsp1_irqs[] = {
 	{ .irq = -1 }
 };
 
-static struct omap_hwmod_dma_info omap2420_mcbsp1_sdma_chs[] = {
-	{ .name = "rx", .dma_req = 32 },
-	{ .name = "tx", .dma_req = 31 },
-	{ .dma_req = -1 }
-};
-
 /* l4_core -> mcbsp1 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp1 = {
 	.master		= &omap2420_l4_core_hwmod,
@@ -1721,7 +1660,7 @@ static struct omap_hwmod omap2420_mcbsp1_hwmod = {
 	.name		= "mcbsp1",
 	.class		= &omap2420_mcbsp_hwmod_class,
 	.mpu_irqs	= omap2420_mcbsp1_irqs,
-	.sdma_reqs	= omap2420_mcbsp1_sdma_chs,
+	.sdma_reqs	= omap2_mcbsp1_sdma_reqs,
 	.main_clk	= "mcbsp1_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1744,12 +1683,6 @@ static struct omap_hwmod_irq_info omap2420_mcbsp2_irqs[] = {
 	{ .irq = -1 }
 };
 
-static struct omap_hwmod_dma_info omap2420_mcbsp2_sdma_chs[] = {
-	{ .name = "rx", .dma_req = 34 },
-	{ .name = "tx", .dma_req = 33 },
-	{ .dma_req = -1 }
-};
-
 /* l4_core -> mcbsp2 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp2 = {
 	.master		= &omap2420_l4_core_hwmod,
@@ -1768,7 +1701,7 @@ static struct omap_hwmod omap2420_mcbsp2_hwmod = {
 	.name		= "mcbsp2",
 	.class		= &omap2420_mcbsp_hwmod_class,
 	.mpu_irqs	= omap2420_mcbsp2_irqs,
-	.sdma_reqs	= omap2420_mcbsp2_sdma_chs,
+	.sdma_reqs	= omap2_mcbsp2_sdma_reqs,
 	.main_clk	= "mcbsp2_fck",
 	.prcm		= {
 		.omap2 = {

commit bc6149587b309e3231e5ac7138b84197813e17ec
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Jul 9 19:14:07 2011 -0600

    omap_hwmod: use a terminator record with omap_hwmod_dma_info arrays
    
    Previously, struct omap_hwmod_dma_info arrays were unterminated; and
    users of these arrays used the ARRAY_SIZE() macro to determine the
    length of the array.  However, ARRAY_SIZE() only works when the array
    is in the same scope as the macro user.
    
    So far this hasn't been a problem.  However, to reduce duplicated
    data, a subsequent patch will move common data to a separate, shared
    file.  When this is done, ARRAY_SIZE() will no longer be usable.
    
    This patch removes ARRAY_SIZE() usage for struct omap_hwmod_dma_info
    arrays and uses a sentinel value (irq == -1) as the array terminator
    instead.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 73157eef2590..60c817e63c3b 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -831,6 +831,7 @@ static struct omap_hwmod_class uart_class = {
 static struct omap_hwmod_dma_info uart1_sdma_reqs[] = {
 	{ .name = "rx",	.dma_req = OMAP24XX_DMA_UART1_RX, },
 	{ .name = "tx",	.dma_req = OMAP24XX_DMA_UART1_TX, },
+	{ .dma_req = -1 }
 };
 
 static struct omap_hwmod_ocp_if *omap2420_uart1_slaves[] = {
@@ -841,7 +842,6 @@ static struct omap_hwmod omap2420_uart1_hwmod = {
 	.name		= "uart1",
 	.mpu_irqs	= omap2_uart1_mpu_irqs,
 	.sdma_reqs	= uart1_sdma_reqs,
-	.sdma_reqs_cnt	= ARRAY_SIZE(uart1_sdma_reqs),
 	.main_clk	= "uart1_fck",
 	.prcm		= {
 		.omap2 = {
@@ -863,6 +863,7 @@ static struct omap_hwmod omap2420_uart1_hwmod = {
 static struct omap_hwmod_dma_info uart2_sdma_reqs[] = {
 	{ .name = "rx",	.dma_req = OMAP24XX_DMA_UART2_RX, },
 	{ .name = "tx",	.dma_req = OMAP24XX_DMA_UART2_TX, },
+	{ .dma_req = -1 }
 };
 
 static struct omap_hwmod_ocp_if *omap2420_uart2_slaves[] = {
@@ -873,7 +874,6 @@ static struct omap_hwmod omap2420_uart2_hwmod = {
 	.name		= "uart2",
 	.mpu_irqs	= omap2_uart2_mpu_irqs,
 	.sdma_reqs	= uart2_sdma_reqs,
-	.sdma_reqs_cnt	= ARRAY_SIZE(uart2_sdma_reqs),
 	.main_clk	= "uart2_fck",
 	.prcm		= {
 		.omap2 = {
@@ -895,6 +895,7 @@ static struct omap_hwmod omap2420_uart2_hwmod = {
 static struct omap_hwmod_dma_info uart3_sdma_reqs[] = {
 	{ .name = "rx",	.dma_req = OMAP24XX_DMA_UART3_RX, },
 	{ .name = "tx",	.dma_req = OMAP24XX_DMA_UART3_TX, },
+	{ .dma_req = -1 }
 };
 
 static struct omap_hwmod_ocp_if *omap2420_uart3_slaves[] = {
@@ -905,7 +906,6 @@ static struct omap_hwmod omap2420_uart3_hwmod = {
 	.name		= "uart3",
 	.mpu_irqs	= omap2_uart3_mpu_irqs,
 	.sdma_reqs	= uart3_sdma_reqs,
-	.sdma_reqs_cnt	= ARRAY_SIZE(uart3_sdma_reqs),
 	.main_clk	= "uart3_fck",
 	.prcm		= {
 		.omap2 = {
@@ -942,6 +942,7 @@ static struct omap_hwmod_class omap2420_dss_hwmod_class = {
 
 static struct omap_hwmod_dma_info omap2420_dss_sdma_chs[] = {
 	{ .name = "dispc", .dma_req = 5 },
+	{ .dma_req = -1 }
 };
 
 /* dss */
@@ -980,7 +981,6 @@ static struct omap_hwmod omap2420_dss_core_hwmod = {
 	.class		= &omap2420_dss_hwmod_class,
 	.main_clk	= "dss1_fck", /* instead of dss_fck */
 	.sdma_reqs	= omap2420_dss_sdma_chs,
-	.sdma_reqs_cnt	= ARRAY_SIZE(omap2420_dss_sdma_chs),
 	.prcm		= {
 		.omap2 = {
 			.prcm_reg_id = 1,
@@ -1186,6 +1186,7 @@ static struct omap_i2c_dev_attr i2c_dev_attr;
 static struct omap_hwmod_dma_info i2c1_sdma_reqs[] = {
 	{ .name = "tx", .dma_req = OMAP24XX_DMA_I2C1_TX },
 	{ .name = "rx", .dma_req = OMAP24XX_DMA_I2C1_RX },
+	{ .dma_req = -1 }
 };
 
 static struct omap_hwmod_ocp_if *omap2420_i2c1_slaves[] = {
@@ -1196,7 +1197,6 @@ static struct omap_hwmod omap2420_i2c1_hwmod = {
 	.name		= "i2c1",
 	.mpu_irqs	= omap2_i2c1_mpu_irqs,
 	.sdma_reqs	= i2c1_sdma_reqs,
-	.sdma_reqs_cnt	= ARRAY_SIZE(i2c1_sdma_reqs),
 	.main_clk	= "i2c1_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1220,6 +1220,7 @@ static struct omap_hwmod omap2420_i2c1_hwmod = {
 static struct omap_hwmod_dma_info i2c2_sdma_reqs[] = {
 	{ .name = "tx", .dma_req = OMAP24XX_DMA_I2C2_TX },
 	{ .name = "rx", .dma_req = OMAP24XX_DMA_I2C2_RX },
+	{ .dma_req = -1 }
 };
 
 static struct omap_hwmod_ocp_if *omap2420_i2c2_slaves[] = {
@@ -1230,7 +1231,6 @@ static struct omap_hwmod omap2420_i2c2_hwmod = {
 	.name		= "i2c2",
 	.mpu_irqs	= omap2_i2c2_mpu_irqs,
 	.sdma_reqs	= i2c2_sdma_reqs,
-	.sdma_reqs_cnt	= ARRAY_SIZE(i2c2_sdma_reqs),
 	.main_clk	= "i2c2_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1611,6 +1611,7 @@ static struct omap_hwmod_dma_info omap2420_mcspi1_sdma_reqs[] = {
 	{ .name = "rx2", .dma_req = 40 }, /* DMA_SPI1_RX2 */
 	{ .name = "tx3", .dma_req = 41 }, /* DMA_SPI1_TX3 */
 	{ .name = "rx3", .dma_req = 42 }, /* DMA_SPI1_RX3 */
+	{ .dma_req = -1 }
 };
 
 static struct omap_hwmod_ocp_if *omap2420_mcspi1_slaves[] = {
@@ -1625,7 +1626,6 @@ static struct omap_hwmod omap2420_mcspi1_hwmod = {
 	.name		= "mcspi1_hwmod",
 	.mpu_irqs	= omap2_mcspi1_mpu_irqs,
 	.sdma_reqs	= omap2420_mcspi1_sdma_reqs,
-	.sdma_reqs_cnt	= ARRAY_SIZE(omap2420_mcspi1_sdma_reqs),
 	.main_clk	= "mcspi1_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1649,6 +1649,7 @@ static struct omap_hwmod_dma_info omap2420_mcspi2_sdma_reqs[] = {
 	{ .name = "rx0", .dma_req = 44 }, /* DMA_SPI2_RX0 */
 	{ .name = "tx1", .dma_req = 45 }, /* DMA_SPI2_TX1 */
 	{ .name = "rx1", .dma_req = 46 }, /* DMA_SPI2_RX1 */
+	{ .dma_req = -1 }
 };
 
 static struct omap_hwmod_ocp_if *omap2420_mcspi2_slaves[] = {
@@ -1663,7 +1664,6 @@ static struct omap_hwmod omap2420_mcspi2_hwmod = {
 	.name		= "mcspi2_hwmod",
 	.mpu_irqs	= omap2_mcspi2_mpu_irqs,
 	.sdma_reqs	= omap2420_mcspi2_sdma_reqs,
-	.sdma_reqs_cnt	= ARRAY_SIZE(omap2420_mcspi2_sdma_reqs),
 	.main_clk	= "mcspi2_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1700,6 +1700,7 @@ static struct omap_hwmod_irq_info omap2420_mcbsp1_irqs[] = {
 static struct omap_hwmod_dma_info omap2420_mcbsp1_sdma_chs[] = {
 	{ .name = "rx", .dma_req = 32 },
 	{ .name = "tx", .dma_req = 31 },
+	{ .dma_req = -1 }
 };
 
 /* l4_core -> mcbsp1 */
@@ -1721,7 +1722,6 @@ static struct omap_hwmod omap2420_mcbsp1_hwmod = {
 	.class		= &omap2420_mcbsp_hwmod_class,
 	.mpu_irqs	= omap2420_mcbsp1_irqs,
 	.sdma_reqs	= omap2420_mcbsp1_sdma_chs,
-	.sdma_reqs_cnt	= ARRAY_SIZE(omap2420_mcbsp1_sdma_chs),
 	.main_clk	= "mcbsp1_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1747,6 +1747,7 @@ static struct omap_hwmod_irq_info omap2420_mcbsp2_irqs[] = {
 static struct omap_hwmod_dma_info omap2420_mcbsp2_sdma_chs[] = {
 	{ .name = "rx", .dma_req = 34 },
 	{ .name = "tx", .dma_req = 33 },
+	{ .dma_req = -1 }
 };
 
 /* l4_core -> mcbsp2 */
@@ -1768,7 +1769,6 @@ static struct omap_hwmod omap2420_mcbsp2_hwmod = {
 	.class		= &omap2420_mcbsp_hwmod_class,
 	.mpu_irqs	= omap2420_mcbsp2_irqs,
 	.sdma_reqs	= omap2420_mcbsp2_sdma_chs,
-	.sdma_reqs_cnt	= ARRAY_SIZE(omap2420_mcbsp2_sdma_chs),
 	.main_clk	= "mcbsp2_fck",
 	.prcm		= {
 		.omap2 = {

commit 0d619a89998d308c48d06b033eccb7374c456f12
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Jul 9 19:14:07 2011 -0600

    omap_hwmod: share identical omap_hwmod_mpu_irqs arrays
    
    To reduce kernel source file data duplication, share struct
    omap_hwmod_mpu_irqs arrays across OMAP2xxx and 3xxx hwmod data files.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 04730d33ba5c..73157eef2590 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -294,10 +294,6 @@ static struct omap_hwmod_class omap2420_timer_hwmod_class = {
 
 /* timer1 */
 static struct omap_hwmod omap2420_timer1_hwmod;
-static struct omap_hwmod_irq_info omap2420_timer1_mpu_irqs[] = {
-	{ .irq = 37, },
-	{ .irq = -1 }
-};
 
 static struct omap_hwmod_addr_space omap2420_timer1_addrs[] = {
 	{
@@ -325,7 +321,7 @@ static struct omap_hwmod_ocp_if *omap2420_timer1_slaves[] = {
 /* timer1 hwmod */
 static struct omap_hwmod omap2420_timer1_hwmod = {
 	.name		= "timer1",
-	.mpu_irqs	= omap2420_timer1_mpu_irqs,
+	.mpu_irqs	= omap2_timer1_mpu_irqs,
 	.main_clk	= "gpt1_fck",
 	.prcm		= {
 		.omap2 = {
@@ -344,11 +340,6 @@ static struct omap_hwmod omap2420_timer1_hwmod = {
 
 /* timer2 */
 static struct omap_hwmod omap2420_timer2_hwmod;
-static struct omap_hwmod_irq_info omap2420_timer2_mpu_irqs[] = {
-	{ .irq = 38, },
-	{ .irq = -1 }
-};
-
 
 /* l4_core -> timer2 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer2 = {
@@ -367,7 +358,7 @@ static struct omap_hwmod_ocp_if *omap2420_timer2_slaves[] = {
 /* timer2 hwmod */
 static struct omap_hwmod omap2420_timer2_hwmod = {
 	.name		= "timer2",
-	.mpu_irqs	= omap2420_timer2_mpu_irqs,
+	.mpu_irqs	= omap2_timer2_mpu_irqs,
 	.main_clk	= "gpt2_fck",
 	.prcm		= {
 		.omap2 = {
@@ -386,10 +377,6 @@ static struct omap_hwmod omap2420_timer2_hwmod = {
 
 /* timer3 */
 static struct omap_hwmod omap2420_timer3_hwmod;
-static struct omap_hwmod_irq_info omap2420_timer3_mpu_irqs[] = {
-	{ .irq = 39, },
-	{ .irq = -1 }
-};
 
 /* l4_core -> timer3 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer3 = {
@@ -408,7 +395,7 @@ static struct omap_hwmod_ocp_if *omap2420_timer3_slaves[] = {
 /* timer3 hwmod */
 static struct omap_hwmod omap2420_timer3_hwmod = {
 	.name		= "timer3",
-	.mpu_irqs	= omap2420_timer3_mpu_irqs,
+	.mpu_irqs	= omap2_timer3_mpu_irqs,
 	.main_clk	= "gpt3_fck",
 	.prcm		= {
 		.omap2 = {
@@ -427,10 +414,6 @@ static struct omap_hwmod omap2420_timer3_hwmod = {
 
 /* timer4 */
 static struct omap_hwmod omap2420_timer4_hwmod;
-static struct omap_hwmod_irq_info omap2420_timer4_mpu_irqs[] = {
-	{ .irq = 40, },
-	{ .irq = -1 }
-};
 
 /* l4_core -> timer4 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer4 = {
@@ -449,7 +432,7 @@ static struct omap_hwmod_ocp_if *omap2420_timer4_slaves[] = {
 /* timer4 hwmod */
 static struct omap_hwmod omap2420_timer4_hwmod = {
 	.name		= "timer4",
-	.mpu_irqs	= omap2420_timer4_mpu_irqs,
+	.mpu_irqs	= omap2_timer4_mpu_irqs,
 	.main_clk	= "gpt4_fck",
 	.prcm		= {
 		.omap2 = {
@@ -468,10 +451,6 @@ static struct omap_hwmod omap2420_timer4_hwmod = {
 
 /* timer5 */
 static struct omap_hwmod omap2420_timer5_hwmod;
-static struct omap_hwmod_irq_info omap2420_timer5_mpu_irqs[] = {
-	{ .irq = 41, },
-	{ .irq = -1 }
-};
 
 /* l4_core -> timer5 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer5 = {
@@ -490,7 +469,7 @@ static struct omap_hwmod_ocp_if *omap2420_timer5_slaves[] = {
 /* timer5 hwmod */
 static struct omap_hwmod omap2420_timer5_hwmod = {
 	.name		= "timer5",
-	.mpu_irqs	= omap2420_timer5_mpu_irqs,
+	.mpu_irqs	= omap2_timer5_mpu_irqs,
 	.main_clk	= "gpt5_fck",
 	.prcm		= {
 		.omap2 = {
@@ -510,10 +489,6 @@ static struct omap_hwmod omap2420_timer5_hwmod = {
 
 /* timer6 */
 static struct omap_hwmod omap2420_timer6_hwmod;
-static struct omap_hwmod_irq_info omap2420_timer6_mpu_irqs[] = {
-	{ .irq = 42, },
-	{ .irq = -1 }
-};
 
 /* l4_core -> timer6 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer6 = {
@@ -532,7 +507,7 @@ static struct omap_hwmod_ocp_if *omap2420_timer6_slaves[] = {
 /* timer6 hwmod */
 static struct omap_hwmod omap2420_timer6_hwmod = {
 	.name		= "timer6",
-	.mpu_irqs	= omap2420_timer6_mpu_irqs,
+	.mpu_irqs	= omap2_timer6_mpu_irqs,
 	.main_clk	= "gpt6_fck",
 	.prcm		= {
 		.omap2 = {
@@ -551,10 +526,6 @@ static struct omap_hwmod omap2420_timer6_hwmod = {
 
 /* timer7 */
 static struct omap_hwmod omap2420_timer7_hwmod;
-static struct omap_hwmod_irq_info omap2420_timer7_mpu_irqs[] = {
-	{ .irq = 43, },
-	{ .irq = -1 }
-};
 
 /* l4_core -> timer7 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer7 = {
@@ -573,7 +544,7 @@ static struct omap_hwmod_ocp_if *omap2420_timer7_slaves[] = {
 /* timer7 hwmod */
 static struct omap_hwmod omap2420_timer7_hwmod = {
 	.name		= "timer7",
-	.mpu_irqs	= omap2420_timer7_mpu_irqs,
+	.mpu_irqs	= omap2_timer7_mpu_irqs,
 	.main_clk	= "gpt7_fck",
 	.prcm		= {
 		.omap2 = {
@@ -592,10 +563,6 @@ static struct omap_hwmod omap2420_timer7_hwmod = {
 
 /* timer8 */
 static struct omap_hwmod omap2420_timer8_hwmod;
-static struct omap_hwmod_irq_info omap2420_timer8_mpu_irqs[] = {
-	{ .irq = 44, },
-	{ .irq = -1 }
-};
 
 /* l4_core -> timer8 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer8 = {
@@ -614,7 +581,7 @@ static struct omap_hwmod_ocp_if *omap2420_timer8_slaves[] = {
 /* timer8 hwmod */
 static struct omap_hwmod omap2420_timer8_hwmod = {
 	.name		= "timer8",
-	.mpu_irqs	= omap2420_timer8_mpu_irqs,
+	.mpu_irqs	= omap2_timer8_mpu_irqs,
 	.main_clk	= "gpt8_fck",
 	.prcm		= {
 		.omap2 = {
@@ -633,10 +600,6 @@ static struct omap_hwmod omap2420_timer8_hwmod = {
 
 /* timer9 */
 static struct omap_hwmod omap2420_timer9_hwmod;
-static struct omap_hwmod_irq_info omap2420_timer9_mpu_irqs[] = {
-	{ .irq = 45, },
-	{ .irq = -1 }
-};
 
 /* l4_core -> timer9 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer9 = {
@@ -655,7 +618,7 @@ static struct omap_hwmod_ocp_if *omap2420_timer9_slaves[] = {
 /* timer9 hwmod */
 static struct omap_hwmod omap2420_timer9_hwmod = {
 	.name		= "timer9",
-	.mpu_irqs	= omap2420_timer9_mpu_irqs,
+	.mpu_irqs	= omap2_timer9_mpu_irqs,
 	.main_clk	= "gpt9_fck",
 	.prcm		= {
 		.omap2 = {
@@ -674,10 +637,6 @@ static struct omap_hwmod omap2420_timer9_hwmod = {
 
 /* timer10 */
 static struct omap_hwmod omap2420_timer10_hwmod;
-static struct omap_hwmod_irq_info omap2420_timer10_mpu_irqs[] = {
-	{ .irq = 46, },
-	{ .irq = -1 }
-};
 
 /* l4_core -> timer10 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer10 = {
@@ -696,7 +655,7 @@ static struct omap_hwmod_ocp_if *omap2420_timer10_slaves[] = {
 /* timer10 hwmod */
 static struct omap_hwmod omap2420_timer10_hwmod = {
 	.name		= "timer10",
-	.mpu_irqs	= omap2420_timer10_mpu_irqs,
+	.mpu_irqs	= omap2_timer10_mpu_irqs,
 	.main_clk	= "gpt10_fck",
 	.prcm		= {
 		.omap2 = {
@@ -715,10 +674,6 @@ static struct omap_hwmod omap2420_timer10_hwmod = {
 
 /* timer11 */
 static struct omap_hwmod omap2420_timer11_hwmod;
-static struct omap_hwmod_irq_info omap2420_timer11_mpu_irqs[] = {
-	{ .irq = 47, },
-	{ .irq = -1 }
-};
 
 /* l4_core -> timer11 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer11 = {
@@ -737,7 +692,7 @@ static struct omap_hwmod_ocp_if *omap2420_timer11_slaves[] = {
 /* timer11 hwmod */
 static struct omap_hwmod omap2420_timer11_hwmod = {
 	.name		= "timer11",
-	.mpu_irqs	= omap2420_timer11_mpu_irqs,
+	.mpu_irqs	= omap2_timer11_mpu_irqs,
 	.main_clk	= "gpt11_fck",
 	.prcm		= {
 		.omap2 = {
@@ -756,10 +711,6 @@ static struct omap_hwmod omap2420_timer11_hwmod = {
 
 /* timer12 */
 static struct omap_hwmod omap2420_timer12_hwmod;
-static struct omap_hwmod_irq_info omap2420_timer12_mpu_irqs[] = {
-	{ .irq = 48, },
-	{ .irq = -1 }
-};
 
 /* l4_core -> timer12 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer12 = {
@@ -778,7 +729,7 @@ static struct omap_hwmod_ocp_if *omap2420_timer12_slaves[] = {
 /* timer12 hwmod */
 static struct omap_hwmod omap2420_timer12_hwmod = {
 	.name		= "timer12",
-	.mpu_irqs	= omap2420_timer12_mpu_irqs,
+	.mpu_irqs	= omap2xxx_timer12_mpu_irqs,
 	.main_clk	= "gpt12_fck",
 	.prcm		= {
 		.omap2 = {
@@ -877,11 +828,6 @@ static struct omap_hwmod_class uart_class = {
 
 /* UART1 */
 
-static struct omap_hwmod_irq_info uart1_mpu_irqs[] = {
-	{ .irq = INT_24XX_UART1_IRQ, },
-	{ .irq = -1 }
-};
-
 static struct omap_hwmod_dma_info uart1_sdma_reqs[] = {
 	{ .name = "rx",	.dma_req = OMAP24XX_DMA_UART1_RX, },
 	{ .name = "tx",	.dma_req = OMAP24XX_DMA_UART1_TX, },
@@ -893,7 +839,7 @@ static struct omap_hwmod_ocp_if *omap2420_uart1_slaves[] = {
 
 static struct omap_hwmod omap2420_uart1_hwmod = {
 	.name		= "uart1",
-	.mpu_irqs	= uart1_mpu_irqs,
+	.mpu_irqs	= omap2_uart1_mpu_irqs,
 	.sdma_reqs	= uart1_sdma_reqs,
 	.sdma_reqs_cnt	= ARRAY_SIZE(uart1_sdma_reqs),
 	.main_clk	= "uart1_fck",
@@ -914,11 +860,6 @@ static struct omap_hwmod omap2420_uart1_hwmod = {
 
 /* UART2 */
 
-static struct omap_hwmod_irq_info uart2_mpu_irqs[] = {
-	{ .irq = INT_24XX_UART2_IRQ, },
-	{ .irq = -1 }
-};
-
 static struct omap_hwmod_dma_info uart2_sdma_reqs[] = {
 	{ .name = "rx",	.dma_req = OMAP24XX_DMA_UART2_RX, },
 	{ .name = "tx",	.dma_req = OMAP24XX_DMA_UART2_TX, },
@@ -930,7 +871,7 @@ static struct omap_hwmod_ocp_if *omap2420_uart2_slaves[] = {
 
 static struct omap_hwmod omap2420_uart2_hwmod = {
 	.name		= "uart2",
-	.mpu_irqs	= uart2_mpu_irqs,
+	.mpu_irqs	= omap2_uart2_mpu_irqs,
 	.sdma_reqs	= uart2_sdma_reqs,
 	.sdma_reqs_cnt	= ARRAY_SIZE(uart2_sdma_reqs),
 	.main_clk	= "uart2_fck",
@@ -951,11 +892,6 @@ static struct omap_hwmod omap2420_uart2_hwmod = {
 
 /* UART3 */
 
-static struct omap_hwmod_irq_info uart3_mpu_irqs[] = {
-	{ .irq = INT_24XX_UART3_IRQ, },
-	{ .irq = -1 }
-};
-
 static struct omap_hwmod_dma_info uart3_sdma_reqs[] = {
 	{ .name = "rx",	.dma_req = OMAP24XX_DMA_UART3_RX, },
 	{ .name = "tx",	.dma_req = OMAP24XX_DMA_UART3_TX, },
@@ -967,7 +903,7 @@ static struct omap_hwmod_ocp_if *omap2420_uart3_slaves[] = {
 
 static struct omap_hwmod omap2420_uart3_hwmod = {
 	.name		= "uart3",
-	.mpu_irqs	= uart3_mpu_irqs,
+	.mpu_irqs	= omap2_uart3_mpu_irqs,
 	.sdma_reqs	= uart3_sdma_reqs,
 	.sdma_reqs_cnt	= ARRAY_SIZE(uart3_sdma_reqs),
 	.main_clk	= "uart3_fck",
@@ -1085,11 +1021,6 @@ static struct omap_hwmod_class omap2420_dispc_hwmod_class = {
 	.sysc = &omap2420_dispc_sysc,
 };
 
-static struct omap_hwmod_irq_info omap2420_dispc_irqs[] = {
-	{ .irq = 25 },
-	{ .irq = -1 }
-};
-
 /* l4_core -> dss_dispc */
 static struct omap_hwmod_ocp_if omap2420_l4_core__dss_dispc = {
 	.master		= &omap2420_l4_core_hwmod,
@@ -1113,7 +1044,7 @@ static struct omap_hwmod_ocp_if *omap2420_dss_dispc_slaves[] = {
 static struct omap_hwmod omap2420_dss_dispc_hwmod = {
 	.name		= "dss_dispc",
 	.class		= &omap2420_dispc_hwmod_class,
-	.mpu_irqs	= omap2420_dispc_irqs,
+	.mpu_irqs	= omap2_dispc_irqs,
 	.main_clk	= "dss1_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1252,11 +1183,6 @@ static struct omap_i2c_dev_attr i2c_dev_attr;
 
 /* I2C1 */
 
-static struct omap_hwmod_irq_info i2c1_mpu_irqs[] = {
-	{ .irq = INT_24XX_I2C1_IRQ, },
-	{ .irq = -1 }
-};
-
 static struct omap_hwmod_dma_info i2c1_sdma_reqs[] = {
 	{ .name = "tx", .dma_req = OMAP24XX_DMA_I2C1_TX },
 	{ .name = "rx", .dma_req = OMAP24XX_DMA_I2C1_RX },
@@ -1268,7 +1194,7 @@ static struct omap_hwmod_ocp_if *omap2420_i2c1_slaves[] = {
 
 static struct omap_hwmod omap2420_i2c1_hwmod = {
 	.name		= "i2c1",
-	.mpu_irqs	= i2c1_mpu_irqs,
+	.mpu_irqs	= omap2_i2c1_mpu_irqs,
 	.sdma_reqs	= i2c1_sdma_reqs,
 	.sdma_reqs_cnt	= ARRAY_SIZE(i2c1_sdma_reqs),
 	.main_clk	= "i2c1_fck",
@@ -1291,11 +1217,6 @@ static struct omap_hwmod omap2420_i2c1_hwmod = {
 
 /* I2C2 */
 
-static struct omap_hwmod_irq_info i2c2_mpu_irqs[] = {
-	{ .irq = INT_24XX_I2C2_IRQ, },
-	{ .irq = -1 }
-};
-
 static struct omap_hwmod_dma_info i2c2_sdma_reqs[] = {
 	{ .name = "tx", .dma_req = OMAP24XX_DMA_I2C2_TX },
 	{ .name = "rx", .dma_req = OMAP24XX_DMA_I2C2_RX },
@@ -1307,7 +1228,7 @@ static struct omap_hwmod_ocp_if *omap2420_i2c2_slaves[] = {
 
 static struct omap_hwmod omap2420_i2c2_hwmod = {
 	.name		= "i2c2",
-	.mpu_irqs	= i2c2_mpu_irqs,
+	.mpu_irqs	= omap2_i2c2_mpu_irqs,
 	.sdma_reqs	= i2c2_sdma_reqs,
 	.sdma_reqs_cnt	= ARRAY_SIZE(i2c2_sdma_reqs),
 	.main_clk	= "i2c2_fck",
@@ -1428,11 +1349,6 @@ static struct omap_hwmod_class omap242x_gpio_hwmod_class = {
 };
 
 /* gpio1 */
-static struct omap_hwmod_irq_info omap242x_gpio1_irqs[] = {
-	{ .irq = 29 }, /* INT_24XX_GPIO_BANK1 */
-	{ .irq = -1 }
-};
-
 static struct omap_hwmod_ocp_if *omap2420_gpio1_slaves[] = {
 	&omap2420_l4_wkup__gpio1,
 };
@@ -1440,7 +1356,7 @@ static struct omap_hwmod_ocp_if *omap2420_gpio1_slaves[] = {
 static struct omap_hwmod omap2420_gpio1_hwmod = {
 	.name		= "gpio1",
 	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
-	.mpu_irqs	= omap242x_gpio1_irqs,
+	.mpu_irqs	= omap2_gpio1_irqs,
 	.main_clk	= "gpios_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1459,11 +1375,6 @@ static struct omap_hwmod omap2420_gpio1_hwmod = {
 };
 
 /* gpio2 */
-static struct omap_hwmod_irq_info omap242x_gpio2_irqs[] = {
-	{ .irq = 30 }, /* INT_24XX_GPIO_BANK2 */
-	{ .irq = -1 }
-};
-
 static struct omap_hwmod_ocp_if *omap2420_gpio2_slaves[] = {
 	&omap2420_l4_wkup__gpio2,
 };
@@ -1471,7 +1382,7 @@ static struct omap_hwmod_ocp_if *omap2420_gpio2_slaves[] = {
 static struct omap_hwmod omap2420_gpio2_hwmod = {
 	.name		= "gpio2",
 	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
-	.mpu_irqs	= omap242x_gpio2_irqs,
+	.mpu_irqs	= omap2_gpio2_irqs,
 	.main_clk	= "gpios_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1490,11 +1401,6 @@ static struct omap_hwmod omap2420_gpio2_hwmod = {
 };
 
 /* gpio3 */
-static struct omap_hwmod_irq_info omap242x_gpio3_irqs[] = {
-	{ .irq = 31 }, /* INT_24XX_GPIO_BANK3 */
-	{ .irq = -1 }
-};
-
 static struct omap_hwmod_ocp_if *omap2420_gpio3_slaves[] = {
 	&omap2420_l4_wkup__gpio3,
 };
@@ -1502,7 +1408,7 @@ static struct omap_hwmod_ocp_if *omap2420_gpio3_slaves[] = {
 static struct omap_hwmod omap2420_gpio3_hwmod = {
 	.name		= "gpio3",
 	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
-	.mpu_irqs	= omap242x_gpio3_irqs,
+	.mpu_irqs	= omap2_gpio3_irqs,
 	.main_clk	= "gpios_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1521,11 +1427,6 @@ static struct omap_hwmod omap2420_gpio3_hwmod = {
 };
 
 /* gpio4 */
-static struct omap_hwmod_irq_info omap242x_gpio4_irqs[] = {
-	{ .irq = 32 }, /* INT_24XX_GPIO_BANK4 */
-	{ .irq = -1 }
-};
-
 static struct omap_hwmod_ocp_if *omap2420_gpio4_slaves[] = {
 	&omap2420_l4_wkup__gpio4,
 };
@@ -1533,7 +1434,7 @@ static struct omap_hwmod_ocp_if *omap2420_gpio4_slaves[] = {
 static struct omap_hwmod omap2420_gpio4_hwmod = {
 	.name		= "gpio4",
 	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
-	.mpu_irqs	= omap242x_gpio4_irqs,
+	.mpu_irqs	= omap2_gpio4_irqs,
 	.main_clk	= "gpios_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1575,14 +1476,6 @@ static struct omap_dma_dev_attr dma_dev_attr = {
 	.lch_count = 32,
 };
 
-static struct omap_hwmod_irq_info omap2420_dma_system_irqs[] = {
-	{ .name = "0", .irq = 12 }, /* INT_24XX_SDMA_IRQ0 */
-	{ .name = "1", .irq = 13 }, /* INT_24XX_SDMA_IRQ1 */
-	{ .name = "2", .irq = 14 }, /* INT_24XX_SDMA_IRQ2 */
-	{ .name = "3", .irq = 15 }, /* INT_24XX_SDMA_IRQ3 */
-	{ .irq = -1 }
-};
-
 /* dma_system -> L3 */
 static struct omap_hwmod_ocp_if omap2420_dma_system__l3 = {
 	.master		= &omap2420_dma_system_hwmod,
@@ -1613,7 +1506,7 @@ static struct omap_hwmod_ocp_if *omap2420_dma_system_slaves[] = {
 static struct omap_hwmod omap2420_dma_system_hwmod = {
 	.name		= "dma",
 	.class		= &omap2420_dma_hwmod_class,
-	.mpu_irqs	= omap2420_dma_system_irqs,
+	.mpu_irqs	= omap2_dma_system_irqs,
 	.main_clk	= "core_l3_ck",
 	.slaves		= omap2420_dma_system_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_dma_system_slaves),
@@ -1709,11 +1602,6 @@ static struct omap_hwmod_class omap2420_mcspi_class = {
 };
 
 /* mcspi1 */
-static struct omap_hwmod_irq_info omap2420_mcspi1_mpu_irqs[] = {
-	{ .irq = 65 },
-	{ .irq = -1 }
-};
-
 static struct omap_hwmod_dma_info omap2420_mcspi1_sdma_reqs[] = {
 	{ .name = "tx0", .dma_req = 35 }, /* DMA_SPI1_TX0 */
 	{ .name = "rx0", .dma_req = 36 }, /* DMA_SPI1_RX0 */
@@ -1735,7 +1623,7 @@ static struct omap2_mcspi_dev_attr omap_mcspi1_dev_attr = {
 
 static struct omap_hwmod omap2420_mcspi1_hwmod = {
 	.name		= "mcspi1_hwmod",
-	.mpu_irqs	= omap2420_mcspi1_mpu_irqs,
+	.mpu_irqs	= omap2_mcspi1_mpu_irqs,
 	.sdma_reqs	= omap2420_mcspi1_sdma_reqs,
 	.sdma_reqs_cnt	= ARRAY_SIZE(omap2420_mcspi1_sdma_reqs),
 	.main_clk	= "mcspi1_fck",
@@ -1756,11 +1644,6 @@ static struct omap_hwmod omap2420_mcspi1_hwmod = {
 };
 
 /* mcspi2 */
-static struct omap_hwmod_irq_info omap2420_mcspi2_mpu_irqs[] = {
-	{ .irq = 66 },
-	{ .irq = -1 }
-};
-
 static struct omap_hwmod_dma_info omap2420_mcspi2_sdma_reqs[] = {
 	{ .name = "tx0", .dma_req = 43 }, /* DMA_SPI2_TX0 */
 	{ .name = "rx0", .dma_req = 44 }, /* DMA_SPI2_RX0 */
@@ -1778,7 +1661,7 @@ static struct omap2_mcspi_dev_attr omap_mcspi2_dev_attr = {
 
 static struct omap_hwmod omap2420_mcspi2_hwmod = {
 	.name		= "mcspi2_hwmod",
-	.mpu_irqs	= omap2420_mcspi2_mpu_irqs,
+	.mpu_irqs	= omap2_mcspi2_mpu_irqs,
 	.sdma_reqs	= omap2420_mcspi2_sdma_reqs,
 	.sdma_reqs_cnt	= ARRAY_SIZE(omap2420_mcspi2_sdma_reqs),
 	.main_clk	= "mcspi2_fck",

commit 212738a4499d278254ed6fdb400e3b4be4cb1de2
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Jul 9 19:14:06 2011 -0600

    omap_hwmod: use a terminator record with omap_hwmod_mpu_irqs arrays
    
    Previously, struct omap_hwmod_mpu_irqs arrays were unterminated; and
    users of these arrays used the ARRAY_SIZE() macro to determine the
    length of the array.  However, ARRAY_SIZE() only works when the array
    is in the same scope as the macro user.
    
    So far this hasn't been a problem.  However, to reduce duplicated
    data, a subsequent patch will move common data to a separate, shared
    file.  When this is done, ARRAY_SIZE() will no longer be usable.
    
    This patch removes ARRAY_SIZE() usage for struct omap_hwmod_mpu_irqs
    arrays and uses a sentinel value (irq == -1) as the array terminator
    instead.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 3ec625c40c1f..04730d33ba5c 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -296,6 +296,7 @@ static struct omap_hwmod_class omap2420_timer_hwmod_class = {
 static struct omap_hwmod omap2420_timer1_hwmod;
 static struct omap_hwmod_irq_info omap2420_timer1_mpu_irqs[] = {
 	{ .irq = 37, },
+	{ .irq = -1 }
 };
 
 static struct omap_hwmod_addr_space omap2420_timer1_addrs[] = {
@@ -325,7 +326,6 @@ static struct omap_hwmod_ocp_if *omap2420_timer1_slaves[] = {
 static struct omap_hwmod omap2420_timer1_hwmod = {
 	.name		= "timer1",
 	.mpu_irqs	= omap2420_timer1_mpu_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer1_mpu_irqs),
 	.main_clk	= "gpt1_fck",
 	.prcm		= {
 		.omap2 = {
@@ -346,6 +346,7 @@ static struct omap_hwmod omap2420_timer1_hwmod = {
 static struct omap_hwmod omap2420_timer2_hwmod;
 static struct omap_hwmod_irq_info omap2420_timer2_mpu_irqs[] = {
 	{ .irq = 38, },
+	{ .irq = -1 }
 };
 
 
@@ -367,7 +368,6 @@ static struct omap_hwmod_ocp_if *omap2420_timer2_slaves[] = {
 static struct omap_hwmod omap2420_timer2_hwmod = {
 	.name		= "timer2",
 	.mpu_irqs	= omap2420_timer2_mpu_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer2_mpu_irqs),
 	.main_clk	= "gpt2_fck",
 	.prcm		= {
 		.omap2 = {
@@ -388,6 +388,7 @@ static struct omap_hwmod omap2420_timer2_hwmod = {
 static struct omap_hwmod omap2420_timer3_hwmod;
 static struct omap_hwmod_irq_info omap2420_timer3_mpu_irqs[] = {
 	{ .irq = 39, },
+	{ .irq = -1 }
 };
 
 /* l4_core -> timer3 */
@@ -408,7 +409,6 @@ static struct omap_hwmod_ocp_if *omap2420_timer3_slaves[] = {
 static struct omap_hwmod omap2420_timer3_hwmod = {
 	.name		= "timer3",
 	.mpu_irqs	= omap2420_timer3_mpu_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer3_mpu_irqs),
 	.main_clk	= "gpt3_fck",
 	.prcm		= {
 		.omap2 = {
@@ -429,6 +429,7 @@ static struct omap_hwmod omap2420_timer3_hwmod = {
 static struct omap_hwmod omap2420_timer4_hwmod;
 static struct omap_hwmod_irq_info omap2420_timer4_mpu_irqs[] = {
 	{ .irq = 40, },
+	{ .irq = -1 }
 };
 
 /* l4_core -> timer4 */
@@ -449,7 +450,6 @@ static struct omap_hwmod_ocp_if *omap2420_timer4_slaves[] = {
 static struct omap_hwmod omap2420_timer4_hwmod = {
 	.name		= "timer4",
 	.mpu_irqs	= omap2420_timer4_mpu_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer4_mpu_irqs),
 	.main_clk	= "gpt4_fck",
 	.prcm		= {
 		.omap2 = {
@@ -470,6 +470,7 @@ static struct omap_hwmod omap2420_timer4_hwmod = {
 static struct omap_hwmod omap2420_timer5_hwmod;
 static struct omap_hwmod_irq_info omap2420_timer5_mpu_irqs[] = {
 	{ .irq = 41, },
+	{ .irq = -1 }
 };
 
 /* l4_core -> timer5 */
@@ -490,7 +491,6 @@ static struct omap_hwmod_ocp_if *omap2420_timer5_slaves[] = {
 static struct omap_hwmod omap2420_timer5_hwmod = {
 	.name		= "timer5",
 	.mpu_irqs	= omap2420_timer5_mpu_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer5_mpu_irqs),
 	.main_clk	= "gpt5_fck",
 	.prcm		= {
 		.omap2 = {
@@ -512,6 +512,7 @@ static struct omap_hwmod omap2420_timer5_hwmod = {
 static struct omap_hwmod omap2420_timer6_hwmod;
 static struct omap_hwmod_irq_info omap2420_timer6_mpu_irqs[] = {
 	{ .irq = 42, },
+	{ .irq = -1 }
 };
 
 /* l4_core -> timer6 */
@@ -532,7 +533,6 @@ static struct omap_hwmod_ocp_if *omap2420_timer6_slaves[] = {
 static struct omap_hwmod omap2420_timer6_hwmod = {
 	.name		= "timer6",
 	.mpu_irqs	= omap2420_timer6_mpu_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer6_mpu_irqs),
 	.main_clk	= "gpt6_fck",
 	.prcm		= {
 		.omap2 = {
@@ -553,6 +553,7 @@ static struct omap_hwmod omap2420_timer6_hwmod = {
 static struct omap_hwmod omap2420_timer7_hwmod;
 static struct omap_hwmod_irq_info omap2420_timer7_mpu_irqs[] = {
 	{ .irq = 43, },
+	{ .irq = -1 }
 };
 
 /* l4_core -> timer7 */
@@ -573,7 +574,6 @@ static struct omap_hwmod_ocp_if *omap2420_timer7_slaves[] = {
 static struct omap_hwmod omap2420_timer7_hwmod = {
 	.name		= "timer7",
 	.mpu_irqs	= omap2420_timer7_mpu_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer7_mpu_irqs),
 	.main_clk	= "gpt7_fck",
 	.prcm		= {
 		.omap2 = {
@@ -594,6 +594,7 @@ static struct omap_hwmod omap2420_timer7_hwmod = {
 static struct omap_hwmod omap2420_timer8_hwmod;
 static struct omap_hwmod_irq_info omap2420_timer8_mpu_irqs[] = {
 	{ .irq = 44, },
+	{ .irq = -1 }
 };
 
 /* l4_core -> timer8 */
@@ -614,7 +615,6 @@ static struct omap_hwmod_ocp_if *omap2420_timer8_slaves[] = {
 static struct omap_hwmod omap2420_timer8_hwmod = {
 	.name		= "timer8",
 	.mpu_irqs	= omap2420_timer8_mpu_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer8_mpu_irqs),
 	.main_clk	= "gpt8_fck",
 	.prcm		= {
 		.omap2 = {
@@ -635,6 +635,7 @@ static struct omap_hwmod omap2420_timer8_hwmod = {
 static struct omap_hwmod omap2420_timer9_hwmod;
 static struct omap_hwmod_irq_info omap2420_timer9_mpu_irqs[] = {
 	{ .irq = 45, },
+	{ .irq = -1 }
 };
 
 /* l4_core -> timer9 */
@@ -655,7 +656,6 @@ static struct omap_hwmod_ocp_if *omap2420_timer9_slaves[] = {
 static struct omap_hwmod omap2420_timer9_hwmod = {
 	.name		= "timer9",
 	.mpu_irqs	= omap2420_timer9_mpu_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer9_mpu_irqs),
 	.main_clk	= "gpt9_fck",
 	.prcm		= {
 		.omap2 = {
@@ -676,6 +676,7 @@ static struct omap_hwmod omap2420_timer9_hwmod = {
 static struct omap_hwmod omap2420_timer10_hwmod;
 static struct omap_hwmod_irq_info omap2420_timer10_mpu_irqs[] = {
 	{ .irq = 46, },
+	{ .irq = -1 }
 };
 
 /* l4_core -> timer10 */
@@ -696,7 +697,6 @@ static struct omap_hwmod_ocp_if *omap2420_timer10_slaves[] = {
 static struct omap_hwmod omap2420_timer10_hwmod = {
 	.name		= "timer10",
 	.mpu_irqs	= omap2420_timer10_mpu_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer10_mpu_irqs),
 	.main_clk	= "gpt10_fck",
 	.prcm		= {
 		.omap2 = {
@@ -717,6 +717,7 @@ static struct omap_hwmod omap2420_timer10_hwmod = {
 static struct omap_hwmod omap2420_timer11_hwmod;
 static struct omap_hwmod_irq_info omap2420_timer11_mpu_irqs[] = {
 	{ .irq = 47, },
+	{ .irq = -1 }
 };
 
 /* l4_core -> timer11 */
@@ -737,7 +738,6 @@ static struct omap_hwmod_ocp_if *omap2420_timer11_slaves[] = {
 static struct omap_hwmod omap2420_timer11_hwmod = {
 	.name		= "timer11",
 	.mpu_irqs	= omap2420_timer11_mpu_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer11_mpu_irqs),
 	.main_clk	= "gpt11_fck",
 	.prcm		= {
 		.omap2 = {
@@ -758,6 +758,7 @@ static struct omap_hwmod omap2420_timer11_hwmod = {
 static struct omap_hwmod omap2420_timer12_hwmod;
 static struct omap_hwmod_irq_info omap2420_timer12_mpu_irqs[] = {
 	{ .irq = 48, },
+	{ .irq = -1 }
 };
 
 /* l4_core -> timer12 */
@@ -778,7 +779,6 @@ static struct omap_hwmod_ocp_if *omap2420_timer12_slaves[] = {
 static struct omap_hwmod omap2420_timer12_hwmod = {
 	.name		= "timer12",
 	.mpu_irqs	= omap2420_timer12_mpu_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer12_mpu_irqs),
 	.main_clk	= "gpt12_fck",
 	.prcm		= {
 		.omap2 = {
@@ -879,6 +879,7 @@ static struct omap_hwmod_class uart_class = {
 
 static struct omap_hwmod_irq_info uart1_mpu_irqs[] = {
 	{ .irq = INT_24XX_UART1_IRQ, },
+	{ .irq = -1 }
 };
 
 static struct omap_hwmod_dma_info uart1_sdma_reqs[] = {
@@ -893,7 +894,6 @@ static struct omap_hwmod_ocp_if *omap2420_uart1_slaves[] = {
 static struct omap_hwmod omap2420_uart1_hwmod = {
 	.name		= "uart1",
 	.mpu_irqs	= uart1_mpu_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(uart1_mpu_irqs),
 	.sdma_reqs	= uart1_sdma_reqs,
 	.sdma_reqs_cnt	= ARRAY_SIZE(uart1_sdma_reqs),
 	.main_clk	= "uart1_fck",
@@ -916,6 +916,7 @@ static struct omap_hwmod omap2420_uart1_hwmod = {
 
 static struct omap_hwmod_irq_info uart2_mpu_irqs[] = {
 	{ .irq = INT_24XX_UART2_IRQ, },
+	{ .irq = -1 }
 };
 
 static struct omap_hwmod_dma_info uart2_sdma_reqs[] = {
@@ -930,7 +931,6 @@ static struct omap_hwmod_ocp_if *omap2420_uart2_slaves[] = {
 static struct omap_hwmod omap2420_uart2_hwmod = {
 	.name		= "uart2",
 	.mpu_irqs	= uart2_mpu_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(uart2_mpu_irqs),
 	.sdma_reqs	= uart2_sdma_reqs,
 	.sdma_reqs_cnt	= ARRAY_SIZE(uart2_sdma_reqs),
 	.main_clk	= "uart2_fck",
@@ -953,6 +953,7 @@ static struct omap_hwmod omap2420_uart2_hwmod = {
 
 static struct omap_hwmod_irq_info uart3_mpu_irqs[] = {
 	{ .irq = INT_24XX_UART3_IRQ, },
+	{ .irq = -1 }
 };
 
 static struct omap_hwmod_dma_info uart3_sdma_reqs[] = {
@@ -967,7 +968,6 @@ static struct omap_hwmod_ocp_if *omap2420_uart3_slaves[] = {
 static struct omap_hwmod omap2420_uart3_hwmod = {
 	.name		= "uart3",
 	.mpu_irqs	= uart3_mpu_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(uart3_mpu_irqs),
 	.sdma_reqs	= uart3_sdma_reqs,
 	.sdma_reqs_cnt	= ARRAY_SIZE(uart3_sdma_reqs),
 	.main_clk	= "uart3_fck",
@@ -1087,6 +1087,7 @@ static struct omap_hwmod_class omap2420_dispc_hwmod_class = {
 
 static struct omap_hwmod_irq_info omap2420_dispc_irqs[] = {
 	{ .irq = 25 },
+	{ .irq = -1 }
 };
 
 /* l4_core -> dss_dispc */
@@ -1113,7 +1114,6 @@ static struct omap_hwmod omap2420_dss_dispc_hwmod = {
 	.name		= "dss_dispc",
 	.class		= &omap2420_dispc_hwmod_class,
 	.mpu_irqs	= omap2420_dispc_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_dispc_irqs),
 	.main_clk	= "dss1_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1254,6 +1254,7 @@ static struct omap_i2c_dev_attr i2c_dev_attr;
 
 static struct omap_hwmod_irq_info i2c1_mpu_irqs[] = {
 	{ .irq = INT_24XX_I2C1_IRQ, },
+	{ .irq = -1 }
 };
 
 static struct omap_hwmod_dma_info i2c1_sdma_reqs[] = {
@@ -1268,7 +1269,6 @@ static struct omap_hwmod_ocp_if *omap2420_i2c1_slaves[] = {
 static struct omap_hwmod omap2420_i2c1_hwmod = {
 	.name		= "i2c1",
 	.mpu_irqs	= i2c1_mpu_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(i2c1_mpu_irqs),
 	.sdma_reqs	= i2c1_sdma_reqs,
 	.sdma_reqs_cnt	= ARRAY_SIZE(i2c1_sdma_reqs),
 	.main_clk	= "i2c1_fck",
@@ -1293,6 +1293,7 @@ static struct omap_hwmod omap2420_i2c1_hwmod = {
 
 static struct omap_hwmod_irq_info i2c2_mpu_irqs[] = {
 	{ .irq = INT_24XX_I2C2_IRQ, },
+	{ .irq = -1 }
 };
 
 static struct omap_hwmod_dma_info i2c2_sdma_reqs[] = {
@@ -1307,7 +1308,6 @@ static struct omap_hwmod_ocp_if *omap2420_i2c2_slaves[] = {
 static struct omap_hwmod omap2420_i2c2_hwmod = {
 	.name		= "i2c2",
 	.mpu_irqs	= i2c2_mpu_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(i2c2_mpu_irqs),
 	.sdma_reqs	= i2c2_sdma_reqs,
 	.sdma_reqs_cnt	= ARRAY_SIZE(i2c2_sdma_reqs),
 	.main_clk	= "i2c2_fck",
@@ -1430,6 +1430,7 @@ static struct omap_hwmod_class omap242x_gpio_hwmod_class = {
 /* gpio1 */
 static struct omap_hwmod_irq_info omap242x_gpio1_irqs[] = {
 	{ .irq = 29 }, /* INT_24XX_GPIO_BANK1 */
+	{ .irq = -1 }
 };
 
 static struct omap_hwmod_ocp_if *omap2420_gpio1_slaves[] = {
@@ -1440,7 +1441,6 @@ static struct omap_hwmod omap2420_gpio1_hwmod = {
 	.name		= "gpio1",
 	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
 	.mpu_irqs	= omap242x_gpio1_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap242x_gpio1_irqs),
 	.main_clk	= "gpios_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1461,6 +1461,7 @@ static struct omap_hwmod omap2420_gpio1_hwmod = {
 /* gpio2 */
 static struct omap_hwmod_irq_info omap242x_gpio2_irqs[] = {
 	{ .irq = 30 }, /* INT_24XX_GPIO_BANK2 */
+	{ .irq = -1 }
 };
 
 static struct omap_hwmod_ocp_if *omap2420_gpio2_slaves[] = {
@@ -1471,7 +1472,6 @@ static struct omap_hwmod omap2420_gpio2_hwmod = {
 	.name		= "gpio2",
 	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
 	.mpu_irqs	= omap242x_gpio2_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap242x_gpio2_irqs),
 	.main_clk	= "gpios_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1492,6 +1492,7 @@ static struct omap_hwmod omap2420_gpio2_hwmod = {
 /* gpio3 */
 static struct omap_hwmod_irq_info omap242x_gpio3_irqs[] = {
 	{ .irq = 31 }, /* INT_24XX_GPIO_BANK3 */
+	{ .irq = -1 }
 };
 
 static struct omap_hwmod_ocp_if *omap2420_gpio3_slaves[] = {
@@ -1502,7 +1503,6 @@ static struct omap_hwmod omap2420_gpio3_hwmod = {
 	.name		= "gpio3",
 	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
 	.mpu_irqs	= omap242x_gpio3_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap242x_gpio3_irqs),
 	.main_clk	= "gpios_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1523,6 +1523,7 @@ static struct omap_hwmod omap2420_gpio3_hwmod = {
 /* gpio4 */
 static struct omap_hwmod_irq_info omap242x_gpio4_irqs[] = {
 	{ .irq = 32 }, /* INT_24XX_GPIO_BANK4 */
+	{ .irq = -1 }
 };
 
 static struct omap_hwmod_ocp_if *omap2420_gpio4_slaves[] = {
@@ -1533,7 +1534,6 @@ static struct omap_hwmod omap2420_gpio4_hwmod = {
 	.name		= "gpio4",
 	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
 	.mpu_irqs	= omap242x_gpio4_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap242x_gpio4_irqs),
 	.main_clk	= "gpios_fck",
 	.prcm		= {
 		.omap2 = {
@@ -1580,6 +1580,7 @@ static struct omap_hwmod_irq_info omap2420_dma_system_irqs[] = {
 	{ .name = "1", .irq = 13 }, /* INT_24XX_SDMA_IRQ1 */
 	{ .name = "2", .irq = 14 }, /* INT_24XX_SDMA_IRQ2 */
 	{ .name = "3", .irq = 15 }, /* INT_24XX_SDMA_IRQ3 */
+	{ .irq = -1 }
 };
 
 /* dma_system -> L3 */
@@ -1613,7 +1614,6 @@ static struct omap_hwmod omap2420_dma_system_hwmod = {
 	.name		= "dma",
 	.class		= &omap2420_dma_hwmod_class,
 	.mpu_irqs	= omap2420_dma_system_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_dma_system_irqs),
 	.main_clk	= "core_l3_ck",
 	.slaves		= omap2420_dma_system_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_dma_system_slaves),
@@ -1650,6 +1650,7 @@ static struct omap_hwmod omap2420_mailbox_hwmod;
 static struct omap_hwmod_irq_info omap2420_mailbox_irqs[] = {
 	{ .name = "dsp", .irq = 26 },
 	{ .name = "iva", .irq = 34 },
+	{ .irq = -1 }
 };
 
 /* l4_core -> mailbox */
@@ -1669,7 +1670,6 @@ static struct omap_hwmod omap2420_mailbox_hwmod = {
 	.name		= "mailbox",
 	.class		= &omap2420_mailbox_hwmod_class,
 	.mpu_irqs	= omap2420_mailbox_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_mailbox_irqs),
 	.main_clk	= "mailboxes_ick",
 	.prcm		= {
 		.omap2 = {
@@ -1711,6 +1711,7 @@ static struct omap_hwmod_class omap2420_mcspi_class = {
 /* mcspi1 */
 static struct omap_hwmod_irq_info omap2420_mcspi1_mpu_irqs[] = {
 	{ .irq = 65 },
+	{ .irq = -1 }
 };
 
 static struct omap_hwmod_dma_info omap2420_mcspi1_sdma_reqs[] = {
@@ -1735,7 +1736,6 @@ static struct omap2_mcspi_dev_attr omap_mcspi1_dev_attr = {
 static struct omap_hwmod omap2420_mcspi1_hwmod = {
 	.name		= "mcspi1_hwmod",
 	.mpu_irqs	= omap2420_mcspi1_mpu_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_mcspi1_mpu_irqs),
 	.sdma_reqs	= omap2420_mcspi1_sdma_reqs,
 	.sdma_reqs_cnt	= ARRAY_SIZE(omap2420_mcspi1_sdma_reqs),
 	.main_clk	= "mcspi1_fck",
@@ -1758,6 +1758,7 @@ static struct omap_hwmod omap2420_mcspi1_hwmod = {
 /* mcspi2 */
 static struct omap_hwmod_irq_info omap2420_mcspi2_mpu_irqs[] = {
 	{ .irq = 66 },
+	{ .irq = -1 }
 };
 
 static struct omap_hwmod_dma_info omap2420_mcspi2_sdma_reqs[] = {
@@ -1778,7 +1779,6 @@ static struct omap2_mcspi_dev_attr omap_mcspi2_dev_attr = {
 static struct omap_hwmod omap2420_mcspi2_hwmod = {
 	.name		= "mcspi2_hwmod",
 	.mpu_irqs	= omap2420_mcspi2_mpu_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_mcspi2_mpu_irqs),
 	.sdma_reqs	= omap2420_mcspi2_sdma_reqs,
 	.sdma_reqs_cnt	= ARRAY_SIZE(omap2420_mcspi2_sdma_reqs),
 	.main_clk	= "mcspi2_fck",
@@ -1811,6 +1811,7 @@ static struct omap_hwmod_class omap2420_mcbsp_hwmod_class = {
 static struct omap_hwmod_irq_info omap2420_mcbsp1_irqs[] = {
 	{ .name = "tx", .irq = 59 },
 	{ .name = "rx", .irq = 60 },
+	{ .irq = -1 }
 };
 
 static struct omap_hwmod_dma_info omap2420_mcbsp1_sdma_chs[] = {
@@ -1836,7 +1837,6 @@ static struct omap_hwmod omap2420_mcbsp1_hwmod = {
 	.name		= "mcbsp1",
 	.class		= &omap2420_mcbsp_hwmod_class,
 	.mpu_irqs	= omap2420_mcbsp1_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_mcbsp1_irqs),
 	.sdma_reqs	= omap2420_mcbsp1_sdma_chs,
 	.sdma_reqs_cnt	= ARRAY_SIZE(omap2420_mcbsp1_sdma_chs),
 	.main_clk	= "mcbsp1_fck",
@@ -1858,6 +1858,7 @@ static struct omap_hwmod omap2420_mcbsp1_hwmod = {
 static struct omap_hwmod_irq_info omap2420_mcbsp2_irqs[] = {
 	{ .name = "tx", .irq = 62 },
 	{ .name = "rx", .irq = 63 },
+	{ .irq = -1 }
 };
 
 static struct omap_hwmod_dma_info omap2420_mcbsp2_sdma_chs[] = {
@@ -1883,7 +1884,6 @@ static struct omap_hwmod omap2420_mcbsp2_hwmod = {
 	.name		= "mcbsp2",
 	.class		= &omap2420_mcbsp_hwmod_class,
 	.mpu_irqs	= omap2420_mcbsp2_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_mcbsp2_irqs),
 	.sdma_reqs	= omap2420_mcbsp2_sdma_chs,
 	.sdma_reqs_cnt	= ARRAY_SIZE(omap2420_mcbsp2_sdma_chs),
 	.main_clk	= "mcbsp2_fck",

commit ded11383fc14a7483cf30700ffc253caf37c9933
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Jul 9 19:14:06 2011 -0600

    omap_hwmod: share identical omap_hwmod_addr_space arrays
    
    To reduce kernel source file data duplication, share struct
    omap_hwmod_addr_space arrays across OMAP2xxx and 3xxx hwmod data
    files.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 1a7ce3ec0c0b..3ec625c40c1f 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -114,38 +114,20 @@ static struct omap_hwmod omap2420_mcbsp1_hwmod;
 static struct omap_hwmod omap2420_mcbsp2_hwmod;
 
 /* l4 core -> mcspi1 interface */
-static struct omap_hwmod_addr_space omap2420_mcspi1_addr_space[] = {
-	{
-		.pa_start	= 0x48098000,
-		.pa_end		= 0x480980ff,
-		.flags		= ADDR_TYPE_RT,
-	},
-	{ }
-};
-
 static struct omap_hwmod_ocp_if omap2420_l4_core__mcspi1 = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_mcspi1_hwmod,
 	.clk		= "mcspi1_ick",
-	.addr		= omap2420_mcspi1_addr_space,
+	.addr		= omap2_mcspi1_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
 /* l4 core -> mcspi2 interface */
-static struct omap_hwmod_addr_space omap2420_mcspi2_addr_space[] = {
-	{
-		.pa_start	= 0x4809a000,
-		.pa_end		= 0x4809a0ff,
-		.flags		= ADDR_TYPE_RT,
-	},
-	{ }
-};
-
 static struct omap_hwmod_ocp_if omap2420_l4_core__mcspi2 = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_mcspi2_hwmod,
 	.clk		= "mcspi2_ick",
-	.addr		= omap2420_mcspi2_addr_space,
+	.addr		= omap2_mcspi2_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -157,95 +139,47 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__l4_wkup = {
 };
 
 /* L4 CORE -> UART1 interface */
-static struct omap_hwmod_addr_space omap2420_uart1_addr_space[] = {
-	{
-		.pa_start	= OMAP2_UART1_BASE,
-		.pa_end		= OMAP2_UART1_BASE + SZ_8K - 1,
-		.flags		= ADDR_MAP_ON_INIT | ADDR_TYPE_RT,
-	},
-	{ }
-};
-
 static struct omap_hwmod_ocp_if omap2_l4_core__uart1 = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_uart1_hwmod,
 	.clk		= "uart1_ick",
-	.addr		= omap2420_uart1_addr_space,
+	.addr		= omap2xxx_uart1_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
 /* L4 CORE -> UART2 interface */
-static struct omap_hwmod_addr_space omap2420_uart2_addr_space[] = {
-	{
-		.pa_start	= OMAP2_UART2_BASE,
-		.pa_end		= OMAP2_UART2_BASE + SZ_1K - 1,
-		.flags		= ADDR_MAP_ON_INIT | ADDR_TYPE_RT,
-	},
-	{ }
-};
-
 static struct omap_hwmod_ocp_if omap2_l4_core__uart2 = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_uart2_hwmod,
 	.clk		= "uart2_ick",
-	.addr		= omap2420_uart2_addr_space,
+	.addr		= omap2xxx_uart2_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
 /* L4 PER -> UART3 interface */
-static struct omap_hwmod_addr_space omap2420_uart3_addr_space[] = {
-	{
-		.pa_start	= OMAP2_UART3_BASE,
-		.pa_end		= OMAP2_UART3_BASE + SZ_1K - 1,
-		.flags		= ADDR_MAP_ON_INIT | ADDR_TYPE_RT,
-	},
-	{ }
-};
-
 static struct omap_hwmod_ocp_if omap2_l4_core__uart3 = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_uart3_hwmod,
 	.clk		= "uart3_ick",
-	.addr		= omap2420_uart3_addr_space,
+	.addr		= omap2xxx_uart3_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
-/* I2C IP block address space length (in bytes) */
-#define OMAP2_I2C_AS_LEN		128
-
 /* L4 CORE -> I2C1 interface */
-static struct omap_hwmod_addr_space omap2420_i2c1_addr_space[] = {
-	{
-		.pa_start	= 0x48070000,
-		.pa_end		= 0x48070000 + OMAP2_I2C_AS_LEN - 1,
-		.flags		= ADDR_TYPE_RT,
-	},
-	{ }
-};
-
 static struct omap_hwmod_ocp_if omap2420_l4_core__i2c1 = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_i2c1_hwmod,
 	.clk		= "i2c1_ick",
-	.addr		= omap2420_i2c1_addr_space,
+	.addr		= omap2_i2c1_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
 /* L4 CORE -> I2C2 interface */
-static struct omap_hwmod_addr_space omap2420_i2c2_addr_space[] = {
-	{
-		.pa_start	= 0x48072000,
-		.pa_end		= 0x48072000 + OMAP2_I2C_AS_LEN - 1,
-		.flags		= ADDR_TYPE_RT,
-	},
-	{ }
-};
-
 static struct omap_hwmod_ocp_if omap2420_l4_core__i2c2 = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_i2c2_hwmod,
 	.clk		= "i2c2_ick",
-	.addr		= omap2420_i2c2_addr_space,
+	.addr		= omap2_i2c2_addr_space,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -414,21 +348,13 @@ static struct omap_hwmod_irq_info omap2420_timer2_mpu_irqs[] = {
 	{ .irq = 38, },
 };
 
-static struct omap_hwmod_addr_space omap2420_timer2_addrs[] = {
-	{
-		.pa_start	= 0x4802a000,
-		.pa_end		= 0x4802a000 + SZ_1K - 1,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
 
 /* l4_core -> timer2 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer2 = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_timer2_hwmod,
 	.clk		= "gpt2_ick",
-	.addr		= omap2420_timer2_addrs,
+	.addr		= omap2xxx_timer2_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -464,21 +390,12 @@ static struct omap_hwmod_irq_info omap2420_timer3_mpu_irqs[] = {
 	{ .irq = 39, },
 };
 
-static struct omap_hwmod_addr_space omap2420_timer3_addrs[] = {
-	{
-		.pa_start	= 0x48078000,
-		.pa_end		= 0x48078000 + SZ_1K - 1,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 /* l4_core -> timer3 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer3 = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_timer3_hwmod,
 	.clk		= "gpt3_ick",
-	.addr		= omap2420_timer3_addrs,
+	.addr		= omap2xxx_timer3_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -514,21 +431,12 @@ static struct omap_hwmod_irq_info omap2420_timer4_mpu_irqs[] = {
 	{ .irq = 40, },
 };
 
-static struct omap_hwmod_addr_space omap2420_timer4_addrs[] = {
-	{
-		.pa_start	= 0x4807a000,
-		.pa_end		= 0x4807a000 + SZ_1K - 1,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 /* l4_core -> timer4 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer4 = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_timer4_hwmod,
 	.clk		= "gpt4_ick",
-	.addr		= omap2420_timer4_addrs,
+	.addr		= omap2xxx_timer4_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -564,21 +472,12 @@ static struct omap_hwmod_irq_info omap2420_timer5_mpu_irqs[] = {
 	{ .irq = 41, },
 };
 
-static struct omap_hwmod_addr_space omap2420_timer5_addrs[] = {
-	{
-		.pa_start	= 0x4807c000,
-		.pa_end		= 0x4807c000 + SZ_1K - 1,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 /* l4_core -> timer5 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer5 = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_timer5_hwmod,
 	.clk		= "gpt5_ick",
-	.addr		= omap2420_timer5_addrs,
+	.addr		= omap2xxx_timer5_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -615,21 +514,12 @@ static struct omap_hwmod_irq_info omap2420_timer6_mpu_irqs[] = {
 	{ .irq = 42, },
 };
 
-static struct omap_hwmod_addr_space omap2420_timer6_addrs[] = {
-	{
-		.pa_start	= 0x4807e000,
-		.pa_end		= 0x4807e000 + SZ_1K - 1,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 /* l4_core -> timer6 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer6 = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_timer6_hwmod,
 	.clk		= "gpt6_ick",
-	.addr		= omap2420_timer6_addrs,
+	.addr		= omap2xxx_timer6_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -665,21 +555,12 @@ static struct omap_hwmod_irq_info omap2420_timer7_mpu_irqs[] = {
 	{ .irq = 43, },
 };
 
-static struct omap_hwmod_addr_space omap2420_timer7_addrs[] = {
-	{
-		.pa_start	= 0x48080000,
-		.pa_end		= 0x48080000 + SZ_1K - 1,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 /* l4_core -> timer7 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer7 = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_timer7_hwmod,
 	.clk		= "gpt7_ick",
-	.addr		= omap2420_timer7_addrs,
+	.addr		= omap2xxx_timer7_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -715,21 +596,12 @@ static struct omap_hwmod_irq_info omap2420_timer8_mpu_irqs[] = {
 	{ .irq = 44, },
 };
 
-static struct omap_hwmod_addr_space omap2420_timer8_addrs[] = {
-	{
-		.pa_start	= 0x48082000,
-		.pa_end		= 0x48082000 + SZ_1K - 1,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 /* l4_core -> timer8 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer8 = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_timer8_hwmod,
 	.clk		= "gpt8_ick",
-	.addr		= omap2420_timer8_addrs,
+	.addr		= omap2xxx_timer8_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -765,21 +637,12 @@ static struct omap_hwmod_irq_info omap2420_timer9_mpu_irqs[] = {
 	{ .irq = 45, },
 };
 
-static struct omap_hwmod_addr_space omap2420_timer9_addrs[] = {
-	{
-		.pa_start	= 0x48084000,
-		.pa_end		= 0x48084000 + SZ_1K - 1,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 /* l4_core -> timer9 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer9 = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_timer9_hwmod,
 	.clk		= "gpt9_ick",
-	.addr		= omap2420_timer9_addrs,
+	.addr		= omap2xxx_timer9_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -815,21 +678,12 @@ static struct omap_hwmod_irq_info omap2420_timer10_mpu_irqs[] = {
 	{ .irq = 46, },
 };
 
-static struct omap_hwmod_addr_space omap2420_timer10_addrs[] = {
-	{
-		.pa_start	= 0x48086000,
-		.pa_end		= 0x48086000 + SZ_1K - 1,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 /* l4_core -> timer10 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer10 = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_timer10_hwmod,
 	.clk		= "gpt10_ick",
-	.addr		= omap2420_timer10_addrs,
+	.addr		= omap2_timer10_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -865,21 +719,12 @@ static struct omap_hwmod_irq_info omap2420_timer11_mpu_irqs[] = {
 	{ .irq = 47, },
 };
 
-static struct omap_hwmod_addr_space omap2420_timer11_addrs[] = {
-	{
-		.pa_start	= 0x48088000,
-		.pa_end		= 0x48088000 + SZ_1K - 1,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 /* l4_core -> timer11 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer11 = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_timer11_hwmod,
 	.clk		= "gpt11_ick",
-	.addr		= omap2420_timer11_addrs,
+	.addr		= omap2_timer11_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -915,21 +760,12 @@ static struct omap_hwmod_irq_info omap2420_timer12_mpu_irqs[] = {
 	{ .irq = 48, },
 };
 
-static struct omap_hwmod_addr_space omap2420_timer12_addrs[] = {
-	{
-		.pa_start	= 0x4808a000,
-		.pa_end		= 0x4808a000 + SZ_1K - 1,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 /* l4_core -> timer12 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__timer12 = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_timer12_hwmod,
 	.clk		= "gpt12_ick",
-	.addr		= omap2420_timer12_addrs,
+	.addr		= omap2xxx_timer12_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -1178,21 +1014,12 @@ static struct omap_hwmod_ocp_if *omap2420_dss_masters[] = {
 	&omap2420_dss__l3,
 };
 
-static struct omap_hwmod_addr_space omap2420_dss_addrs[] = {
-	{
-		.pa_start	= 0x48050000,
-		.pa_end		= 0x480503FF,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 /* l4_core -> dss */
 static struct omap_hwmod_ocp_if omap2420_l4_core__dss = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_dss_core_hwmod,
 	.clk		= "dss_ick",
-	.addr		= omap2420_dss_addrs,
+	.addr		= omap2_dss_addrs,
 	.fw = {
 		.omap2 = {
 			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_CORE_REGION,
@@ -1262,21 +1089,12 @@ static struct omap_hwmod_irq_info omap2420_dispc_irqs[] = {
 	{ .irq = 25 },
 };
 
-static struct omap_hwmod_addr_space omap2420_dss_dispc_addrs[] = {
-	{
-		.pa_start	= 0x48050400,
-		.pa_end		= 0x480507FF,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 /* l4_core -> dss_dispc */
 static struct omap_hwmod_ocp_if omap2420_l4_core__dss_dispc = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_dss_dispc_hwmod,
 	.clk		= "dss_ick",
-	.addr		= omap2420_dss_dispc_addrs,
+	.addr		= omap2_dss_dispc_addrs,
 	.fw = {
 		.omap2 = {
 			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_DISPC_REGION,
@@ -1332,21 +1150,12 @@ static struct omap_hwmod_class omap2420_rfbi_hwmod_class = {
 	.sysc = &omap2420_rfbi_sysc,
 };
 
-static struct omap_hwmod_addr_space omap2420_dss_rfbi_addrs[] = {
-	{
-		.pa_start	= 0x48050800,
-		.pa_end		= 0x48050BFF,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 /* l4_core -> dss_rfbi */
 static struct omap_hwmod_ocp_if omap2420_l4_core__dss_rfbi = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_dss_rfbi_hwmod,
 	.clk		= "dss_ick",
-	.addr		= omap2420_dss_rfbi_addrs,
+	.addr		= omap2_dss_rfbi_addrs,
 	.fw = {
 		.omap2 = {
 			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_CORE_REGION,
@@ -1387,22 +1196,12 @@ static struct omap_hwmod_class omap2420_venc_hwmod_class = {
 	.name = "venc",
 };
 
-/* dss_venc */
-static struct omap_hwmod_addr_space omap2420_dss_venc_addrs[] = {
-	{
-		.pa_start	= 0x48050C00,
-		.pa_end		= 0x48050FFF,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 /* l4_core -> dss_venc */
 static struct omap_hwmod_ocp_if omap2420_l4_core__dss_venc = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_dss_venc_hwmod,
 	.clk		= "dss_54m_fck",
-	.addr		= omap2420_dss_venc_addrs,
+	.addr		= omap2_dss_venc_addrs,
 	.fw = {
 		.omap2 = {
 			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_VENC_REGION,
@@ -1783,15 +1582,6 @@ static struct omap_hwmod_irq_info omap2420_dma_system_irqs[] = {
 	{ .name = "3", .irq = 15 }, /* INT_24XX_SDMA_IRQ3 */
 };
 
-static struct omap_hwmod_addr_space omap2420_dma_system_addrs[] = {
-	{
-		.pa_start	= 0x48056000,
-		.pa_end		= 0x48056fff,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 /* dma_system -> L3 */
 static struct omap_hwmod_ocp_if omap2420_dma_system__l3 = {
 	.master		= &omap2420_dma_system_hwmod,
@@ -1810,7 +1600,7 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__dma_system = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_dma_system_hwmod,
 	.clk		= "sdma_ick",
-	.addr		= omap2420_dma_system_addrs,
+	.addr		= omap2_dma_system_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -1862,20 +1652,11 @@ static struct omap_hwmod_irq_info omap2420_mailbox_irqs[] = {
 	{ .name = "iva", .irq = 34 },
 };
 
-static struct omap_hwmod_addr_space omap2420_mailbox_addrs[] = {
-	{
-		.pa_start	= 0x48094000,
-		.pa_end		= 0x480941ff,
-		.flags		= ADDR_TYPE_RT,
-	},
-	{ }
-};
-
 /* l4_core -> mailbox */
 static struct omap_hwmod_ocp_if omap2420_l4_core__mailbox = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_mailbox_hwmod,
-	.addr		= omap2420_mailbox_addrs,
+	.addr		= omap2_mailbox_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -2037,22 +1818,12 @@ static struct omap_hwmod_dma_info omap2420_mcbsp1_sdma_chs[] = {
 	{ .name = "tx", .dma_req = 31 },
 };
 
-static struct omap_hwmod_addr_space omap2420_mcbsp1_addrs[] = {
-	{
-		.name		= "mpu",
-		.pa_start	= 0x48074000,
-		.pa_end		= 0x480740ff,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 /* l4_core -> mcbsp1 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp1 = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_mcbsp1_hwmod,
 	.clk		= "mcbsp1_ick",
-	.addr		= omap2420_mcbsp1_addrs,
+	.addr		= omap2_mcbsp1_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -2094,22 +1865,12 @@ static struct omap_hwmod_dma_info omap2420_mcbsp2_sdma_chs[] = {
 	{ .name = "tx", .dma_req = 33 },
 };
 
-static struct omap_hwmod_addr_space omap2420_mcbsp2_addrs[] = {
-	{
-		.name		= "mpu",
-		.pa_start	= 0x48076000,
-		.pa_end		= 0x480760ff,
-		.flags		= ADDR_TYPE_RT
-	},
-	{ }
-};
-
 /* l4_core -> mcbsp2 */
 static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp2 = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_mcbsp2_hwmod,
 	.clk		= "mcbsp2_ick",
-	.addr		= omap2420_mcbsp2_addrs,
+	.addr		= omap2xxx_mcbsp2_addrs,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 

commit 78183f3fdf76f422431a81852468be01b36db325
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Jul 9 19:14:05 2011 -0600

    omap_hwmod: use a null structure record to terminate omap_hwmod_addr_space arrays
    
    Previously, struct omap_hwmod_addr_space arrays were unterminated; and
    users of these arrays used the ARRAY_SIZE() macro to determine the
    length of the array.  However, ARRAY_SIZE() only works when the array
    is in the same scope as the macro user.
    
    So far this hasn't been a problem.  However, to reduce duplicated
    data, a subsequent patch will move common data to a separate, shared
    file.  When this is done, ARRAY_SIZE() will no longer be usable.
    
    This patch removes ARRAY_SIZE() usage for struct omap_hwmod_addr_space
    arrays and uses a null structure member as the array terminator
    instead.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index c4d0ae87d62a..1a7ce3ec0c0b 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -1,7 +1,7 @@
 /*
  * omap_hwmod_2420_data.c - hardware modules present on the OMAP2420 chips
  *
- * Copyright (C) 2009-2010 Nokia Corporation
+ * Copyright (C) 2009-2011 Nokia Corporation
  * Paul Walmsley
  *
  * This program is free software; you can redistribute it and/or modify
@@ -120,6 +120,7 @@ static struct omap_hwmod_addr_space omap2420_mcspi1_addr_space[] = {
 		.pa_end		= 0x480980ff,
 		.flags		= ADDR_TYPE_RT,
 	},
+	{ }
 };
 
 static struct omap_hwmod_ocp_if omap2420_l4_core__mcspi1 = {
@@ -127,7 +128,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__mcspi1 = {
 	.slave		= &omap2420_mcspi1_hwmod,
 	.clk		= "mcspi1_ick",
 	.addr		= omap2420_mcspi1_addr_space,
-	.addr_cnt	= ARRAY_SIZE(omap2420_mcspi1_addr_space),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -138,6 +138,7 @@ static struct omap_hwmod_addr_space omap2420_mcspi2_addr_space[] = {
 		.pa_end		= 0x4809a0ff,
 		.flags		= ADDR_TYPE_RT,
 	},
+	{ }
 };
 
 static struct omap_hwmod_ocp_if omap2420_l4_core__mcspi2 = {
@@ -145,7 +146,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__mcspi2 = {
 	.slave		= &omap2420_mcspi2_hwmod,
 	.clk		= "mcspi2_ick",
 	.addr		= omap2420_mcspi2_addr_space,
-	.addr_cnt	= ARRAY_SIZE(omap2420_mcspi2_addr_space),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -163,6 +163,7 @@ static struct omap_hwmod_addr_space omap2420_uart1_addr_space[] = {
 		.pa_end		= OMAP2_UART1_BASE + SZ_8K - 1,
 		.flags		= ADDR_MAP_ON_INIT | ADDR_TYPE_RT,
 	},
+	{ }
 };
 
 static struct omap_hwmod_ocp_if omap2_l4_core__uart1 = {
@@ -170,7 +171,6 @@ static struct omap_hwmod_ocp_if omap2_l4_core__uart1 = {
 	.slave		= &omap2420_uart1_hwmod,
 	.clk		= "uart1_ick",
 	.addr		= omap2420_uart1_addr_space,
-	.addr_cnt	= ARRAY_SIZE(omap2420_uart1_addr_space),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -181,6 +181,7 @@ static struct omap_hwmod_addr_space omap2420_uart2_addr_space[] = {
 		.pa_end		= OMAP2_UART2_BASE + SZ_1K - 1,
 		.flags		= ADDR_MAP_ON_INIT | ADDR_TYPE_RT,
 	},
+	{ }
 };
 
 static struct omap_hwmod_ocp_if omap2_l4_core__uart2 = {
@@ -188,7 +189,6 @@ static struct omap_hwmod_ocp_if omap2_l4_core__uart2 = {
 	.slave		= &omap2420_uart2_hwmod,
 	.clk		= "uart2_ick",
 	.addr		= omap2420_uart2_addr_space,
-	.addr_cnt	= ARRAY_SIZE(omap2420_uart2_addr_space),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -199,6 +199,7 @@ static struct omap_hwmod_addr_space omap2420_uart3_addr_space[] = {
 		.pa_end		= OMAP2_UART3_BASE + SZ_1K - 1,
 		.flags		= ADDR_MAP_ON_INIT | ADDR_TYPE_RT,
 	},
+	{ }
 };
 
 static struct omap_hwmod_ocp_if omap2_l4_core__uart3 = {
@@ -206,7 +207,6 @@ static struct omap_hwmod_ocp_if omap2_l4_core__uart3 = {
 	.slave		= &omap2420_uart3_hwmod,
 	.clk		= "uart3_ick",
 	.addr		= omap2420_uart3_addr_space,
-	.addr_cnt	= ARRAY_SIZE(omap2420_uart3_addr_space),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -220,6 +220,7 @@ static struct omap_hwmod_addr_space omap2420_i2c1_addr_space[] = {
 		.pa_end		= 0x48070000 + OMAP2_I2C_AS_LEN - 1,
 		.flags		= ADDR_TYPE_RT,
 	},
+	{ }
 };
 
 static struct omap_hwmod_ocp_if omap2420_l4_core__i2c1 = {
@@ -227,7 +228,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__i2c1 = {
 	.slave		= &omap2420_i2c1_hwmod,
 	.clk		= "i2c1_ick",
 	.addr		= omap2420_i2c1_addr_space,
-	.addr_cnt	= ARRAY_SIZE(omap2420_i2c1_addr_space),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -238,6 +238,7 @@ static struct omap_hwmod_addr_space omap2420_i2c2_addr_space[] = {
 		.pa_end		= 0x48072000 + OMAP2_I2C_AS_LEN - 1,
 		.flags		= ADDR_TYPE_RT,
 	},
+	{ }
 };
 
 static struct omap_hwmod_ocp_if omap2420_l4_core__i2c2 = {
@@ -245,7 +246,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__i2c2 = {
 	.slave		= &omap2420_i2c2_hwmod,
 	.clk		= "i2c2_ick",
 	.addr		= omap2420_i2c2_addr_space,
-	.addr_cnt	= ARRAY_SIZE(omap2420_i2c2_addr_space),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -370,6 +370,7 @@ static struct omap_hwmod_addr_space omap2420_timer1_addrs[] = {
 		.pa_end		= 0x48028000 + SZ_1K - 1,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 /* l4_wkup -> timer1 */
@@ -378,7 +379,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_wkup__timer1 = {
 	.slave		= &omap2420_timer1_hwmod,
 	.clk		= "gpt1_ick",
 	.addr		= omap2420_timer1_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_timer1_addrs),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -420,6 +420,7 @@ static struct omap_hwmod_addr_space omap2420_timer2_addrs[] = {
 		.pa_end		= 0x4802a000 + SZ_1K - 1,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 /* l4_core -> timer2 */
@@ -428,7 +429,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer2 = {
 	.slave		= &omap2420_timer2_hwmod,
 	.clk		= "gpt2_ick",
 	.addr		= omap2420_timer2_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_timer2_addrs),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -470,6 +470,7 @@ static struct omap_hwmod_addr_space omap2420_timer3_addrs[] = {
 		.pa_end		= 0x48078000 + SZ_1K - 1,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 /* l4_core -> timer3 */
@@ -478,7 +479,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer3 = {
 	.slave		= &omap2420_timer3_hwmod,
 	.clk		= "gpt3_ick",
 	.addr		= omap2420_timer3_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_timer3_addrs),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -520,6 +520,7 @@ static struct omap_hwmod_addr_space omap2420_timer4_addrs[] = {
 		.pa_end		= 0x4807a000 + SZ_1K - 1,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 /* l4_core -> timer4 */
@@ -528,7 +529,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer4 = {
 	.slave		= &omap2420_timer4_hwmod,
 	.clk		= "gpt4_ick",
 	.addr		= omap2420_timer4_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_timer4_addrs),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -570,6 +570,7 @@ static struct omap_hwmod_addr_space omap2420_timer5_addrs[] = {
 		.pa_end		= 0x4807c000 + SZ_1K - 1,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 /* l4_core -> timer5 */
@@ -578,7 +579,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer5 = {
 	.slave		= &omap2420_timer5_hwmod,
 	.clk		= "gpt5_ick",
 	.addr		= omap2420_timer5_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_timer5_addrs),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -621,6 +621,7 @@ static struct omap_hwmod_addr_space omap2420_timer6_addrs[] = {
 		.pa_end		= 0x4807e000 + SZ_1K - 1,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 /* l4_core -> timer6 */
@@ -629,7 +630,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer6 = {
 	.slave		= &omap2420_timer6_hwmod,
 	.clk		= "gpt6_ick",
 	.addr		= omap2420_timer6_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_timer6_addrs),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -671,6 +671,7 @@ static struct omap_hwmod_addr_space omap2420_timer7_addrs[] = {
 		.pa_end		= 0x48080000 + SZ_1K - 1,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 /* l4_core -> timer7 */
@@ -679,7 +680,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer7 = {
 	.slave		= &omap2420_timer7_hwmod,
 	.clk		= "gpt7_ick",
 	.addr		= omap2420_timer7_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_timer7_addrs),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -721,6 +721,7 @@ static struct omap_hwmod_addr_space omap2420_timer8_addrs[] = {
 		.pa_end		= 0x48082000 + SZ_1K - 1,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 /* l4_core -> timer8 */
@@ -729,7 +730,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer8 = {
 	.slave		= &omap2420_timer8_hwmod,
 	.clk		= "gpt8_ick",
 	.addr		= omap2420_timer8_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_timer8_addrs),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -771,6 +771,7 @@ static struct omap_hwmod_addr_space omap2420_timer9_addrs[] = {
 		.pa_end		= 0x48084000 + SZ_1K - 1,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 /* l4_core -> timer9 */
@@ -779,7 +780,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer9 = {
 	.slave		= &omap2420_timer9_hwmod,
 	.clk		= "gpt9_ick",
 	.addr		= omap2420_timer9_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_timer9_addrs),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -821,6 +821,7 @@ static struct omap_hwmod_addr_space omap2420_timer10_addrs[] = {
 		.pa_end		= 0x48086000 + SZ_1K - 1,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 /* l4_core -> timer10 */
@@ -829,7 +830,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer10 = {
 	.slave		= &omap2420_timer10_hwmod,
 	.clk		= "gpt10_ick",
 	.addr		= omap2420_timer10_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_timer10_addrs),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -871,6 +871,7 @@ static struct omap_hwmod_addr_space omap2420_timer11_addrs[] = {
 		.pa_end		= 0x48088000 + SZ_1K - 1,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 /* l4_core -> timer11 */
@@ -879,7 +880,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer11 = {
 	.slave		= &omap2420_timer11_hwmod,
 	.clk		= "gpt11_ick",
 	.addr		= omap2420_timer11_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_timer11_addrs),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -921,6 +921,7 @@ static struct omap_hwmod_addr_space omap2420_timer12_addrs[] = {
 		.pa_end		= 0x4808a000 + SZ_1K - 1,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 /* l4_core -> timer12 */
@@ -929,7 +930,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__timer12 = {
 	.slave		= &omap2420_timer12_hwmod,
 	.clk		= "gpt12_ick",
 	.addr		= omap2420_timer12_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_timer12_addrs),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -966,6 +966,7 @@ static struct omap_hwmod_addr_space omap2420_wd_timer2_addrs[] = {
 		.pa_end		= 0x4802207f,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 static struct omap_hwmod_ocp_if omap2420_l4_wkup__wd_timer2 = {
@@ -973,7 +974,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_wkup__wd_timer2 = {
 	.slave		= &omap2420_wd_timer2_hwmod,
 	.clk		= "mpu_wdt_ick",
 	.addr		= omap2420_wd_timer2_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_wd_timer2_addrs),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -1184,6 +1184,7 @@ static struct omap_hwmod_addr_space omap2420_dss_addrs[] = {
 		.pa_end		= 0x480503FF,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 /* l4_core -> dss */
@@ -1192,7 +1193,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__dss = {
 	.slave		= &omap2420_dss_core_hwmod,
 	.clk		= "dss_ick",
 	.addr		= omap2420_dss_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_dss_addrs),
 	.fw = {
 		.omap2 = {
 			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_CORE_REGION,
@@ -1268,6 +1268,7 @@ static struct omap_hwmod_addr_space omap2420_dss_dispc_addrs[] = {
 		.pa_end		= 0x480507FF,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 /* l4_core -> dss_dispc */
@@ -1276,7 +1277,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__dss_dispc = {
 	.slave		= &omap2420_dss_dispc_hwmod,
 	.clk		= "dss_ick",
 	.addr		= omap2420_dss_dispc_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_dss_dispc_addrs),
 	.fw = {
 		.omap2 = {
 			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_DISPC_REGION,
@@ -1338,6 +1338,7 @@ static struct omap_hwmod_addr_space omap2420_dss_rfbi_addrs[] = {
 		.pa_end		= 0x48050BFF,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 /* l4_core -> dss_rfbi */
@@ -1346,7 +1347,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__dss_rfbi = {
 	.slave		= &omap2420_dss_rfbi_hwmod,
 	.clk		= "dss_ick",
 	.addr		= omap2420_dss_rfbi_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_dss_rfbi_addrs),
 	.fw = {
 		.omap2 = {
 			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_CORE_REGION,
@@ -1394,6 +1394,7 @@ static struct omap_hwmod_addr_space omap2420_dss_venc_addrs[] = {
 		.pa_end		= 0x48050FFF,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 /* l4_core -> dss_venc */
@@ -1402,7 +1403,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__dss_venc = {
 	.slave		= &omap2420_dss_venc_hwmod,
 	.clk		= "dss_54m_fck",
 	.addr		= omap2420_dss_venc_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_dss_venc_addrs),
 	.fw = {
 		.omap2 = {
 			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_VENC_REGION,
@@ -1536,6 +1536,7 @@ static struct omap_hwmod_addr_space omap2420_gpio1_addr_space[] = {
 		.pa_end		= 0x480181ff,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio1 = {
@@ -1543,7 +1544,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio1 = {
 	.slave		= &omap2420_gpio1_hwmod,
 	.clk		= "gpios_ick",
 	.addr		= omap2420_gpio1_addr_space,
-	.addr_cnt	= ARRAY_SIZE(omap2420_gpio1_addr_space),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -1554,6 +1554,7 @@ static struct omap_hwmod_addr_space omap2420_gpio2_addr_space[] = {
 		.pa_end		= 0x4801a1ff,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio2 = {
@@ -1561,7 +1562,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio2 = {
 	.slave		= &omap2420_gpio2_hwmod,
 	.clk		= "gpios_ick",
 	.addr		= omap2420_gpio2_addr_space,
-	.addr_cnt	= ARRAY_SIZE(omap2420_gpio2_addr_space),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -1572,6 +1572,7 @@ static struct omap_hwmod_addr_space omap2420_gpio3_addr_space[] = {
 		.pa_end		= 0x4801c1ff,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio3 = {
@@ -1579,7 +1580,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio3 = {
 	.slave		= &omap2420_gpio3_hwmod,
 	.clk		= "gpios_ick",
 	.addr		= omap2420_gpio3_addr_space,
-	.addr_cnt	= ARRAY_SIZE(omap2420_gpio3_addr_space),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -1590,6 +1590,7 @@ static struct omap_hwmod_addr_space omap2420_gpio4_addr_space[] = {
 		.pa_end		= 0x4801e1ff,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio4 = {
@@ -1597,7 +1598,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio4 = {
 	.slave		= &omap2420_gpio4_hwmod,
 	.clk		= "gpios_ick",
 	.addr		= omap2420_gpio4_addr_space,
-	.addr_cnt	= ARRAY_SIZE(omap2420_gpio4_addr_space),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -1789,6 +1789,7 @@ static struct omap_hwmod_addr_space omap2420_dma_system_addrs[] = {
 		.pa_end		= 0x48056fff,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 /* dma_system -> L3 */
@@ -1810,7 +1811,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__dma_system = {
 	.slave		= &omap2420_dma_system_hwmod,
 	.clk		= "sdma_ick",
 	.addr		= omap2420_dma_system_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_dma_system_addrs),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -1868,6 +1868,7 @@ static struct omap_hwmod_addr_space omap2420_mailbox_addrs[] = {
 		.pa_end		= 0x480941ff,
 		.flags		= ADDR_TYPE_RT,
 	},
+	{ }
 };
 
 /* l4_core -> mailbox */
@@ -1875,7 +1876,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__mailbox = {
 	.master		= &omap2420_l4_core_hwmod,
 	.slave		= &omap2420_mailbox_hwmod,
 	.addr		= omap2420_mailbox_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_mailbox_addrs),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -2044,6 +2044,7 @@ static struct omap_hwmod_addr_space omap2420_mcbsp1_addrs[] = {
 		.pa_end		= 0x480740ff,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 /* l4_core -> mcbsp1 */
@@ -2052,7 +2053,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp1 = {
 	.slave		= &omap2420_mcbsp1_hwmod,
 	.clk		= "mcbsp1_ick",
 	.addr		= omap2420_mcbsp1_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_mcbsp1_addrs),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
@@ -2101,6 +2101,7 @@ static struct omap_hwmod_addr_space omap2420_mcbsp2_addrs[] = {
 		.pa_end		= 0x480760ff,
 		.flags		= ADDR_TYPE_RT
 	},
+	{ }
 };
 
 /* l4_core -> mcbsp2 */
@@ -2109,7 +2110,6 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp2 = {
 	.slave		= &omap2420_mcbsp2_hwmod,
 	.clk		= "mcbsp2_ick",
 	.addr		= omap2420_mcbsp2_addrs,
-	.addr_cnt	= ARRAY_SIZE(omap2420_mcbsp2_addrs),
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 

commit f95440ca5bdd3ed3e31c2fbad07b9056b31ad18c
Author: Avinash.H.M <avinashhm@ti.com>
Date:   Tue Apr 5 21:10:15 2011 +0530

    OMAP2/3: hwmod: fix gpio-reset timeouts seen during bootup.
    
    GPIO module expects the debounce clocks to be enabled during reset. It doesn't
    reset properly and timeouts are seen, if this clock isn't enabled during
    reset. Add the HWMOD_CONTROL_OPT_CLKS_IN_RESET flags to the GPIO HWMODs, with
    which the debounce clocks are enabled during reset.
    
    Cc: Rajendra Nayak <rnayak@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Avinash.H.M <avinashhm@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index f50e56a8115b..c4d0ae87d62a 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -1639,6 +1639,7 @@ static struct omap_hwmod_ocp_if *omap2420_gpio1_slaves[] = {
 
 static struct omap_hwmod omap2420_gpio1_hwmod = {
 	.name		= "gpio1",
+	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
 	.mpu_irqs	= omap242x_gpio1_irqs,
 	.mpu_irqs_cnt	= ARRAY_SIZE(omap242x_gpio1_irqs),
 	.main_clk	= "gpios_fck",
@@ -1669,6 +1670,7 @@ static struct omap_hwmod_ocp_if *omap2420_gpio2_slaves[] = {
 
 static struct omap_hwmod omap2420_gpio2_hwmod = {
 	.name		= "gpio2",
+	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
 	.mpu_irqs	= omap242x_gpio2_irqs,
 	.mpu_irqs_cnt	= ARRAY_SIZE(omap242x_gpio2_irqs),
 	.main_clk	= "gpios_fck",
@@ -1699,6 +1701,7 @@ static struct omap_hwmod_ocp_if *omap2420_gpio3_slaves[] = {
 
 static struct omap_hwmod omap2420_gpio3_hwmod = {
 	.name		= "gpio3",
+	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
 	.mpu_irqs	= omap242x_gpio3_irqs,
 	.mpu_irqs_cnt	= ARRAY_SIZE(omap242x_gpio3_irqs),
 	.main_clk	= "gpios_fck",
@@ -1729,6 +1732,7 @@ static struct omap_hwmod_ocp_if *omap2420_gpio4_slaves[] = {
 
 static struct omap_hwmod omap2420_gpio4_hwmod = {
 	.name		= "gpio4",
+	.flags		= HWMOD_CONTROL_OPT_CLKS_IN_RESET,
 	.mpu_irqs	= omap242x_gpio4_irqs,
 	.mpu_irqs_cnt	= ARRAY_SIZE(omap242x_gpio4_irqs),
 	.main_clk	= "gpios_fck",

commit 1286eeb2fd22ddb4c56390f957e854ec06bab9fd
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Tue Apr 19 10:15:36 2011 -0600

    OMAP2+: hwmod data: Fix wrong dma_system end address
    
    OMAP2420, 2430 and 3xxx were using the OMAP4 end address
    that unfortunately is not located at the same base address.
    Moreover the OMAP4 size was set to 256 instead of 4096.
    
    Change all .pa_end to set them to .pa_start + 0xfff
    
    Cc: "G, Manjunath Kondaiah" <manjugk@ti.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Reported-by: Michael Fillinger <m-fillinger@ti.com>
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 8eb3ce1bbfbe..f50e56a8115b 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -1782,7 +1782,7 @@ static struct omap_hwmod_irq_info omap2420_dma_system_irqs[] = {
 static struct omap_hwmod_addr_space omap2420_dma_system_addrs[] = {
 	{
 		.pa_start	= 0x48056000,
-		.pa_end		= 0x4a0560ff,
+		.pa_end		= 0x48056fff,
 		.flags		= ADDR_TYPE_RT
 	},
 };

commit da49252fb0392d8196833ef3da92e48fb371f8d7
Merge: eddecbb601c9 b295d6e593e0
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Tue Mar 22 14:27:36 2011 +0900

    Merge branch 'for-paul' of git://gitorious.org/linux-omap-dss2/linux
    
    Conflicts:
            arch/arm/mach-omap2/board-overo.c
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

commit affe360d13e54b415cde2f11cee02369b4ed54bd
Author: archit taneja <archit@ti.com>
Date:   Wed Feb 23 08:41:03 2011 +0000

    OMAP: DSS2: Have separate irq handlers for DISPC and DSI
    
    Currently, the core DSS platform device requests for an irq line for OMAP2 and
    OMAP3. Make DISPC and DSI platform devices request for a shared IRQ line.
    
    On OMAP3, the logical OR of DSI and DISPC interrupt lines goes to the MPU. There
    is a register DSS_IRQSTATUS which tells if the interrupt came from DISPC or DSI.
    
    On OMAP2, there is no DSI, only DISPC interrupts goto the MPU. There is no
    DSS_IRQSTATUS register.
    
    Hence, it makes more sense to have separate irq handlers corresponding to the
    DSS sub modules instead of having a common handler.
    
    Since on OMAP3 the logical OR of the lines goes to MPU, the irq line is shared
    among the IRQ handlers.
    
    The hwmod irq info has been removed for DSS to DISPC and DSI for OMAP2 and OMAP3
    hwmod databases. The Probes of DISPC and DSI now request for irq handlers.
    
    Signed-off-by: Archit Taneja <archit@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 61e58bd27aec..3a1ad0074978 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -1168,11 +1168,6 @@ static struct omap_hwmod_class omap2420_dss_hwmod_class = {
 	.sysc = &omap2420_dss_sysc,
 };
 
-/* dss */
-static struct omap_hwmod_irq_info omap2420_dss_irqs[] = {
-	{ .irq = 25 },
-};
-
 static struct omap_hwmod_dma_info omap2420_dss_sdma_chs[] = {
 	{ .name = "dispc", .dma_req = 5 },
 };
@@ -1221,8 +1216,6 @@ static struct omap_hwmod omap2420_dss_core_hwmod = {
 	.name		= "dss_core",
 	.class		= &omap2420_dss_hwmod_class,
 	.main_clk	= "dss1_fck", /* instead of dss_fck */
-	.mpu_irqs	= omap2420_dss_irqs,
-	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_dss_irqs),
 	.sdma_reqs	= omap2420_dss_sdma_chs,
 	.sdma_reqs_cnt	= ARRAY_SIZE(omap2420_dss_sdma_chs),
 	.prcm		= {
@@ -1265,6 +1258,10 @@ static struct omap_hwmod_class omap2420_dispc_hwmod_class = {
 	.sysc = &omap2420_dispc_sysc,
 };
 
+static struct omap_hwmod_irq_info omap2420_dispc_irqs[] = {
+	{ .irq = 25 },
+};
+
 static struct omap_hwmod_addr_space omap2420_dss_dispc_addrs[] = {
 	{
 		.pa_start	= 0x48050400,
@@ -1297,6 +1294,8 @@ static struct omap_hwmod_ocp_if *omap2420_dss_dispc_slaves[] = {
 static struct omap_hwmod omap2420_dss_dispc_hwmod = {
 	.name		= "dss_dispc",
 	.class		= &omap2420_dispc_hwmod_class,
+	.mpu_irqs	= omap2420_dispc_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_dispc_irqs),
 	.main_clk	= "dss1_fck",
 	.prcm		= {
 		.omap2 = {

commit 2d403fe03070b541cc93cfa915f6e6c592cf231c
Merge: 21ace5452ce3 cc1226e76350
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Mar 10 22:43:05 2011 -0700

    Merge remote branch 'remotes/origin/hwmod_a_2.6.39' into tmp-integration-2.6.39-20110310-024
    
    Conflicts:
            arch/arm/mach-omap2/omap_hwmod_2430_data.c
            arch/arm/mach-omap2/omap_hwmod_3xxx_data.c
            arch/arm/plat-omap/include/plat/omap_hwmod.h

commit d73d65fab1c29c3c0f9736aed9cb55ea53843b00
Author: Avinash.H.M <avinashhm@ti.com>
Date:   Thu Mar 3 14:22:46 2011 -0700

    omap: hwmod: add syss reset done flags to omap2, omap3 hwmods
    
    Some of the omap2, omap3 peripherals support software reset. This
    can be done through the softreset bit in sysconfig register.
    The reset status can be checked through resetdone bit of
    sysstatus register. syss_has_reset_status is added to the hwmod
    database of peripherals which have resetdone bit in sysstatus register.
    
    Cc: Rajendra Nayak <rnayak@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Reviewed-by: Govindraj.R <govindraj.raja@ti.com>
    Signed-off-by: Avinash.H.M <avinashhm@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index b85c630b64d6..e8046b4ec6a4 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -308,7 +308,7 @@ static struct omap_hwmod_class_sysconfig omap2420_wd_timer_sysc = {
 	.sysc_offs	= 0x0010,
 	.syss_offs	= 0x0014,
 	.sysc_flags	= (SYSC_HAS_EMUFREE | SYSC_HAS_SOFTRESET |
-			   SYSC_HAS_AUTOIDLE),
+			   SYSC_HAS_AUTOIDLE | SYSS_HAS_RESET_STATUS),
 	.sysc_fields    = &omap_hwmod_sysc_type1,
 };
 
@@ -349,7 +349,7 @@ static struct omap_hwmod_class_sysconfig uart_sysc = {
 	.syss_offs	= 0x58,
 	.sysc_flags	= (SYSC_HAS_SIDLEMODE |
 			   SYSC_HAS_ENAWAKEUP | SYSC_HAS_SOFTRESET |
-			   SYSC_HAS_AUTOIDLE),
+			   SYSC_HAS_AUTOIDLE | SYSS_HAS_RESET_STATUS),
 	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
 	.sysc_fields    = &omap_hwmod_sysc_type1,
 };
@@ -475,7 +475,7 @@ static struct omap_hwmod_class_sysconfig i2c_sysc = {
 	.rev_offs	= 0x00,
 	.sysc_offs	= 0x20,
 	.syss_offs	= 0x10,
-	.sysc_flags	= SYSC_HAS_SOFTRESET,
+	.sysc_flags	= (SYSC_HAS_SOFTRESET | SYSS_HAS_RESET_STATUS),
 	.sysc_fields	= &omap_hwmod_sysc_type1,
 };
 
@@ -647,7 +647,8 @@ static struct omap_hwmod_class_sysconfig omap242x_gpio_sysc = {
 	.sysc_offs	= 0x0010,
 	.syss_offs	= 0x0014,
 	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
-			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
+			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE |
+			   SYSS_HAS_RESET_STATUS),
 	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
 	.sysc_fields    = &omap_hwmod_sysc_type1,
 };
@@ -789,7 +790,7 @@ static struct omap_hwmod_class_sysconfig omap2420_dma_sysc = {
 	.syss_offs	= 0x0028,
 	.sysc_flags	= (SYSC_HAS_SOFTRESET | SYSC_HAS_MIDLEMODE |
 			   SYSC_HAS_CLOCKACTIVITY | SYSC_HAS_EMUFREE |
-			   SYSC_HAS_AUTOIDLE),
+			   SYSC_HAS_AUTOIDLE | SYSS_HAS_RESET_STATUS),
 	.idlemodes	= (MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
 	.sysc_fields	= &omap_hwmod_sysc_type1,
 };

commit c39bee8ac4aca750c85609ba0847599b36feb693
Author: Paul Walmsley <paul@pwsan.com>
Date:   Fri Mar 4 06:02:15 2011 +0000

    OMAP2/3: VENC hwmod: add OCPIF_SWSUP_IDLE flag to interface
    
    According to the hwmod interface data, the DSS submodule "VENC" uses a
    clock, "dss_54m_fck"/"dss_tv_fck", which the PRCM cannot autoidle.  By
    default, the hwmod code assumes that interface clocks can be autoidled
    by the PRCM.  When the interface clock can't be autoidled by the PRCM,
    those interfaces must be marked with the OCPIF_SWSUP_IDLE flag.
    Otherwise, the "interface clock" will always have a non-zero use
    count, and the device won't enter idle.  This problem was observed on
    N8x0.
    
    Fix the immediate problem by marking the VENC interface with the
    OCPIF_SWSUP_IDLE flag.  But it's not clear that
    "dss_54m_fck"/"dss_tv_fck" is really the correct interface clock for
    VENC.  It may be that the VENC interface should use a
    hardware-autoidling interface clock.  This is the situation on OMAP4,
    which uses "l3_div_ck" as the VENC interface clock, which can be
    autoidled by the PRCM.  Clarification from TI is needed.
    
    Problem found and patch tested on N8x0 by Tony Lindgren
    <tony@atomide.com>.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Senthilvadivu Guruswamy <svadivu@ti.com>
    Cc: Sumit Semwal <sumit.semwal@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: Beno√Æt Cousson <b-cousson@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index e0bc2c7a15de..61e58bd27aec 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -1410,6 +1410,7 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__dss_venc = {
 			.flags	= OMAP_FIREWALL_L4,
 		}
 	},
+	.flags		= OCPIF_SWSUP_IDLE,
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 

commit b2833a0578453449dce1b8b8e54f67a544c5e37f
Merge: 12d7d4e0ed8f d594f1f31afe b176654e7796 0a0d128d023a 0005ae73cfe4
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Mar 2 17:11:18 2011 -0800

    Merge branches 'devel-iommu-mailbox', 'devel-mcbsp', 'devel-board' and 'devel-hsmmc' into omap-for-linus
    
    Conflicts:
            arch/arm/mach-omap2/omap_hwmod_44xx_data.c

commit 550c8092c55c22db8f843bad070fd1731292a75e
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Feb 28 11:58:14 2011 -0700

    OMAP2+: hwmod: rename some init functions
    
    Rename omap_hwmod_init() to omap_hwmod_register().  Rename
    omap_hwmod_late_init() to omap_hwmod_setup_all().  Also change all of
    the callers to reflect the new names.  While here, update some
    copyrights.
    
    Suggested by Tony Lindgren <tony@atomide.com>.
    
    N.B. The comment in mach-omap2/serial.c may no longer be correct, given
         recent changes in init order.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Beno√Æt Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index c2f84aa114b2..e58621aa9b34 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -1990,5 +1990,5 @@ static __initdata struct omap_hwmod *omap2420_hwmods[] = {
 
 int __init omap2420_hwmod_init(void)
 {
-	return omap_hwmod_init(omap2420_hwmods);
+	return omap_hwmod_register(omap2420_hwmods);
 }

commit eddb12624d9a8087f1f8f1a2812f840c5e8191ac
Author: Thara Gopinath <thara@ti.com>
Date:   Wed Feb 23 00:14:04 2011 -0700

    OMAP2420: hwmod data: add dmtimer
    
    Add dmtimer data.
    
    Signed-off-by: Thara Gopinath <thara@ti.com>
    Signed-off-by: Tarun Kanti DebBarma <tarun.kanti@ti.com>
    Acked-by: Benoit Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index f323c6bb22de..c2f84aa114b2 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -19,6 +19,7 @@
 #include <plat/i2c.h>
 #include <plat/gpio.h>
 #include <plat/mcspi.h>
+#include <plat/dmtimer.h>
 #include <plat/l3_2xxx.h>
 #include <plat/l4_2xxx.h>
 
@@ -337,6 +338,625 @@ static struct omap_hwmod omap2420_iva_hwmod = {
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
+/* Timer Common */
+static struct omap_hwmod_class_sysconfig omap2420_timer_sysc = {
+	.rev_offs	= 0x0000,
+	.sysc_offs	= 0x0010,
+	.syss_offs	= 0x0014,
+	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_CLOCKACTIVITY |
+			   SYSC_HAS_ENAWAKEUP | SYSC_HAS_SOFTRESET |
+			   SYSC_HAS_AUTOIDLE),
+	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
+	.sysc_fields    = &omap_hwmod_sysc_type1,
+};
+
+static struct omap_hwmod_class omap2420_timer_hwmod_class = {
+	.name = "timer",
+	.sysc = &omap2420_timer_sysc,
+	.rev = OMAP_TIMER_IP_VERSION_1,
+};
+
+/* timer1 */
+static struct omap_hwmod omap2420_timer1_hwmod;
+static struct omap_hwmod_irq_info omap2420_timer1_mpu_irqs[] = {
+	{ .irq = 37, },
+};
+
+static struct omap_hwmod_addr_space omap2420_timer1_addrs[] = {
+	{
+		.pa_start	= 0x48028000,
+		.pa_end		= 0x48028000 + SZ_1K - 1,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+/* l4_wkup -> timer1 */
+static struct omap_hwmod_ocp_if omap2420_l4_wkup__timer1 = {
+	.master		= &omap2420_l4_wkup_hwmod,
+	.slave		= &omap2420_timer1_hwmod,
+	.clk		= "gpt1_ick",
+	.addr		= omap2420_timer1_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_timer1_addrs),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* timer1 slave port */
+static struct omap_hwmod_ocp_if *omap2420_timer1_slaves[] = {
+	&omap2420_l4_wkup__timer1,
+};
+
+/* timer1 hwmod */
+static struct omap_hwmod omap2420_timer1_hwmod = {
+	.name		= "timer1",
+	.mpu_irqs	= omap2420_timer1_mpu_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer1_mpu_irqs),
+	.main_clk	= "gpt1_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_GPT1_SHIFT,
+			.module_offs = WKUP_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_GPT1_SHIFT,
+		},
+	},
+	.slaves		= omap2420_timer1_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_timer1_slaves),
+	.class		= &omap2420_timer_hwmod_class,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
+};
+
+/* timer2 */
+static struct omap_hwmod omap2420_timer2_hwmod;
+static struct omap_hwmod_irq_info omap2420_timer2_mpu_irqs[] = {
+	{ .irq = 38, },
+};
+
+static struct omap_hwmod_addr_space omap2420_timer2_addrs[] = {
+	{
+		.pa_start	= 0x4802a000,
+		.pa_end		= 0x4802a000 + SZ_1K - 1,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+/* l4_core -> timer2 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer2 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer2_hwmod,
+	.clk		= "gpt2_ick",
+	.addr		= omap2420_timer2_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_timer2_addrs),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* timer2 slave port */
+static struct omap_hwmod_ocp_if *omap2420_timer2_slaves[] = {
+	&omap2420_l4_core__timer2,
+};
+
+/* timer2 hwmod */
+static struct omap_hwmod omap2420_timer2_hwmod = {
+	.name		= "timer2",
+	.mpu_irqs	= omap2420_timer2_mpu_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer2_mpu_irqs),
+	.main_clk	= "gpt2_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_GPT2_SHIFT,
+			.module_offs = CORE_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_GPT2_SHIFT,
+		},
+	},
+	.slaves		= omap2420_timer2_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_timer2_slaves),
+	.class		= &omap2420_timer_hwmod_class,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
+};
+
+/* timer3 */
+static struct omap_hwmod omap2420_timer3_hwmod;
+static struct omap_hwmod_irq_info omap2420_timer3_mpu_irqs[] = {
+	{ .irq = 39, },
+};
+
+static struct omap_hwmod_addr_space omap2420_timer3_addrs[] = {
+	{
+		.pa_start	= 0x48078000,
+		.pa_end		= 0x48078000 + SZ_1K - 1,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+/* l4_core -> timer3 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer3 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer3_hwmod,
+	.clk		= "gpt3_ick",
+	.addr		= omap2420_timer3_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_timer3_addrs),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* timer3 slave port */
+static struct omap_hwmod_ocp_if *omap2420_timer3_slaves[] = {
+	&omap2420_l4_core__timer3,
+};
+
+/* timer3 hwmod */
+static struct omap_hwmod omap2420_timer3_hwmod = {
+	.name		= "timer3",
+	.mpu_irqs	= omap2420_timer3_mpu_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer3_mpu_irqs),
+	.main_clk	= "gpt3_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_GPT3_SHIFT,
+			.module_offs = CORE_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_GPT3_SHIFT,
+		},
+	},
+	.slaves		= omap2420_timer3_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_timer3_slaves),
+	.class		= &omap2420_timer_hwmod_class,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
+};
+
+/* timer4 */
+static struct omap_hwmod omap2420_timer4_hwmod;
+static struct omap_hwmod_irq_info omap2420_timer4_mpu_irqs[] = {
+	{ .irq = 40, },
+};
+
+static struct omap_hwmod_addr_space omap2420_timer4_addrs[] = {
+	{
+		.pa_start	= 0x4807a000,
+		.pa_end		= 0x4807a000 + SZ_1K - 1,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+/* l4_core -> timer4 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer4 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer4_hwmod,
+	.clk		= "gpt4_ick",
+	.addr		= omap2420_timer4_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_timer4_addrs),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* timer4 slave port */
+static struct omap_hwmod_ocp_if *omap2420_timer4_slaves[] = {
+	&omap2420_l4_core__timer4,
+};
+
+/* timer4 hwmod */
+static struct omap_hwmod omap2420_timer4_hwmod = {
+	.name		= "timer4",
+	.mpu_irqs	= omap2420_timer4_mpu_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer4_mpu_irqs),
+	.main_clk	= "gpt4_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_GPT4_SHIFT,
+			.module_offs = CORE_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_GPT4_SHIFT,
+		},
+	},
+	.slaves		= omap2420_timer4_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_timer4_slaves),
+	.class		= &omap2420_timer_hwmod_class,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
+};
+
+/* timer5 */
+static struct omap_hwmod omap2420_timer5_hwmod;
+static struct omap_hwmod_irq_info omap2420_timer5_mpu_irqs[] = {
+	{ .irq = 41, },
+};
+
+static struct omap_hwmod_addr_space omap2420_timer5_addrs[] = {
+	{
+		.pa_start	= 0x4807c000,
+		.pa_end		= 0x4807c000 + SZ_1K - 1,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+/* l4_core -> timer5 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer5 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer5_hwmod,
+	.clk		= "gpt5_ick",
+	.addr		= omap2420_timer5_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_timer5_addrs),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* timer5 slave port */
+static struct omap_hwmod_ocp_if *omap2420_timer5_slaves[] = {
+	&omap2420_l4_core__timer5,
+};
+
+/* timer5 hwmod */
+static struct omap_hwmod omap2420_timer5_hwmod = {
+	.name		= "timer5",
+	.mpu_irqs	= omap2420_timer5_mpu_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer5_mpu_irqs),
+	.main_clk	= "gpt5_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_GPT5_SHIFT,
+			.module_offs = CORE_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_GPT5_SHIFT,
+		},
+	},
+	.slaves		= omap2420_timer5_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_timer5_slaves),
+	.class		= &omap2420_timer_hwmod_class,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
+};
+
+
+/* timer6 */
+static struct omap_hwmod omap2420_timer6_hwmod;
+static struct omap_hwmod_irq_info omap2420_timer6_mpu_irqs[] = {
+	{ .irq = 42, },
+};
+
+static struct omap_hwmod_addr_space omap2420_timer6_addrs[] = {
+	{
+		.pa_start	= 0x4807e000,
+		.pa_end		= 0x4807e000 + SZ_1K - 1,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+/* l4_core -> timer6 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer6 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer6_hwmod,
+	.clk		= "gpt6_ick",
+	.addr		= omap2420_timer6_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_timer6_addrs),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* timer6 slave port */
+static struct omap_hwmod_ocp_if *omap2420_timer6_slaves[] = {
+	&omap2420_l4_core__timer6,
+};
+
+/* timer6 hwmod */
+static struct omap_hwmod omap2420_timer6_hwmod = {
+	.name		= "timer6",
+	.mpu_irqs	= omap2420_timer6_mpu_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer6_mpu_irqs),
+	.main_clk	= "gpt6_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_GPT6_SHIFT,
+			.module_offs = CORE_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_GPT6_SHIFT,
+		},
+	},
+	.slaves		= omap2420_timer6_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_timer6_slaves),
+	.class		= &omap2420_timer_hwmod_class,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
+};
+
+/* timer7 */
+static struct omap_hwmod omap2420_timer7_hwmod;
+static struct omap_hwmod_irq_info omap2420_timer7_mpu_irqs[] = {
+	{ .irq = 43, },
+};
+
+static struct omap_hwmod_addr_space omap2420_timer7_addrs[] = {
+	{
+		.pa_start	= 0x48080000,
+		.pa_end		= 0x48080000 + SZ_1K - 1,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+/* l4_core -> timer7 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer7 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer7_hwmod,
+	.clk		= "gpt7_ick",
+	.addr		= omap2420_timer7_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_timer7_addrs),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* timer7 slave port */
+static struct omap_hwmod_ocp_if *omap2420_timer7_slaves[] = {
+	&omap2420_l4_core__timer7,
+};
+
+/* timer7 hwmod */
+static struct omap_hwmod omap2420_timer7_hwmod = {
+	.name		= "timer7",
+	.mpu_irqs	= omap2420_timer7_mpu_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer7_mpu_irqs),
+	.main_clk	= "gpt7_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_GPT7_SHIFT,
+			.module_offs = CORE_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_GPT7_SHIFT,
+		},
+	},
+	.slaves		= omap2420_timer7_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_timer7_slaves),
+	.class		= &omap2420_timer_hwmod_class,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
+};
+
+/* timer8 */
+static struct omap_hwmod omap2420_timer8_hwmod;
+static struct omap_hwmod_irq_info omap2420_timer8_mpu_irqs[] = {
+	{ .irq = 44, },
+};
+
+static struct omap_hwmod_addr_space omap2420_timer8_addrs[] = {
+	{
+		.pa_start	= 0x48082000,
+		.pa_end		= 0x48082000 + SZ_1K - 1,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+/* l4_core -> timer8 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer8 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer8_hwmod,
+	.clk		= "gpt8_ick",
+	.addr		= omap2420_timer8_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_timer8_addrs),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* timer8 slave port */
+static struct omap_hwmod_ocp_if *omap2420_timer8_slaves[] = {
+	&omap2420_l4_core__timer8,
+};
+
+/* timer8 hwmod */
+static struct omap_hwmod omap2420_timer8_hwmod = {
+	.name		= "timer8",
+	.mpu_irqs	= omap2420_timer8_mpu_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer8_mpu_irqs),
+	.main_clk	= "gpt8_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_GPT8_SHIFT,
+			.module_offs = CORE_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_GPT8_SHIFT,
+		},
+	},
+	.slaves		= omap2420_timer8_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_timer8_slaves),
+	.class		= &omap2420_timer_hwmod_class,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
+};
+
+/* timer9 */
+static struct omap_hwmod omap2420_timer9_hwmod;
+static struct omap_hwmod_irq_info omap2420_timer9_mpu_irqs[] = {
+	{ .irq = 45, },
+};
+
+static struct omap_hwmod_addr_space omap2420_timer9_addrs[] = {
+	{
+		.pa_start	= 0x48084000,
+		.pa_end		= 0x48084000 + SZ_1K - 1,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+/* l4_core -> timer9 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer9 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer9_hwmod,
+	.clk		= "gpt9_ick",
+	.addr		= omap2420_timer9_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_timer9_addrs),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* timer9 slave port */
+static struct omap_hwmod_ocp_if *omap2420_timer9_slaves[] = {
+	&omap2420_l4_core__timer9,
+};
+
+/* timer9 hwmod */
+static struct omap_hwmod omap2420_timer9_hwmod = {
+	.name		= "timer9",
+	.mpu_irqs	= omap2420_timer9_mpu_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer9_mpu_irqs),
+	.main_clk	= "gpt9_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_GPT9_SHIFT,
+			.module_offs = CORE_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_GPT9_SHIFT,
+		},
+	},
+	.slaves		= omap2420_timer9_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_timer9_slaves),
+	.class		= &omap2420_timer_hwmod_class,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
+};
+
+/* timer10 */
+static struct omap_hwmod omap2420_timer10_hwmod;
+static struct omap_hwmod_irq_info omap2420_timer10_mpu_irqs[] = {
+	{ .irq = 46, },
+};
+
+static struct omap_hwmod_addr_space omap2420_timer10_addrs[] = {
+	{
+		.pa_start	= 0x48086000,
+		.pa_end		= 0x48086000 + SZ_1K - 1,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+/* l4_core -> timer10 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer10 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer10_hwmod,
+	.clk		= "gpt10_ick",
+	.addr		= omap2420_timer10_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_timer10_addrs),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* timer10 slave port */
+static struct omap_hwmod_ocp_if *omap2420_timer10_slaves[] = {
+	&omap2420_l4_core__timer10,
+};
+
+/* timer10 hwmod */
+static struct omap_hwmod omap2420_timer10_hwmod = {
+	.name		= "timer10",
+	.mpu_irqs	= omap2420_timer10_mpu_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer10_mpu_irqs),
+	.main_clk	= "gpt10_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_GPT10_SHIFT,
+			.module_offs = CORE_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_GPT10_SHIFT,
+		},
+	},
+	.slaves		= omap2420_timer10_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_timer10_slaves),
+	.class		= &omap2420_timer_hwmod_class,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
+};
+
+/* timer11 */
+static struct omap_hwmod omap2420_timer11_hwmod;
+static struct omap_hwmod_irq_info omap2420_timer11_mpu_irqs[] = {
+	{ .irq = 47, },
+};
+
+static struct omap_hwmod_addr_space omap2420_timer11_addrs[] = {
+	{
+		.pa_start	= 0x48088000,
+		.pa_end		= 0x48088000 + SZ_1K - 1,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+/* l4_core -> timer11 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer11 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer11_hwmod,
+	.clk		= "gpt11_ick",
+	.addr		= omap2420_timer11_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_timer11_addrs),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* timer11 slave port */
+static struct omap_hwmod_ocp_if *omap2420_timer11_slaves[] = {
+	&omap2420_l4_core__timer11,
+};
+
+/* timer11 hwmod */
+static struct omap_hwmod omap2420_timer11_hwmod = {
+	.name		= "timer11",
+	.mpu_irqs	= omap2420_timer11_mpu_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer11_mpu_irqs),
+	.main_clk	= "gpt11_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_GPT11_SHIFT,
+			.module_offs = CORE_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_GPT11_SHIFT,
+		},
+	},
+	.slaves		= omap2420_timer11_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_timer11_slaves),
+	.class		= &omap2420_timer_hwmod_class,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
+};
+
+/* timer12 */
+static struct omap_hwmod omap2420_timer12_hwmod;
+static struct omap_hwmod_irq_info omap2420_timer12_mpu_irqs[] = {
+	{ .irq = 48, },
+};
+
+static struct omap_hwmod_addr_space omap2420_timer12_addrs[] = {
+	{
+		.pa_start	= 0x4808a000,
+		.pa_end		= 0x4808a000 + SZ_1K - 1,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+/* l4_core -> timer12 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__timer12 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_timer12_hwmod,
+	.clk		= "gpt12_ick",
+	.addr		= omap2420_timer12_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_timer12_addrs),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* timer12 slave port */
+static struct omap_hwmod_ocp_if *omap2420_timer12_slaves[] = {
+	&omap2420_l4_core__timer12,
+};
+
+/* timer12 hwmod */
+static struct omap_hwmod omap2420_timer12_hwmod = {
+	.name		= "timer12",
+	.mpu_irqs	= omap2420_timer12_mpu_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_timer12_mpu_irqs),
+	.main_clk	= "gpt12_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_GPT12_SHIFT,
+			.module_offs = CORE_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_GPT12_SHIFT,
+		},
+	},
+	.slaves		= omap2420_timer12_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_timer12_slaves),
+	.class		= &omap2420_timer_hwmod_class,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
+};
+
 /* l4_wkup -> wd_timer2 */
 static struct omap_hwmod_addr_space omap2420_wd_timer2_addrs[] = {
 	{
@@ -1326,6 +1946,20 @@ static __initdata struct omap_hwmod *omap2420_hwmods[] = {
 	&omap2420_l4_wkup_hwmod,
 	&omap2420_mpu_hwmod,
 	&omap2420_iva_hwmod,
+
+	&omap2420_timer1_hwmod,
+	&omap2420_timer2_hwmod,
+	&omap2420_timer3_hwmod,
+	&omap2420_timer4_hwmod,
+	&omap2420_timer5_hwmod,
+	&omap2420_timer6_hwmod,
+	&omap2420_timer7_hwmod,
+	&omap2420_timer8_hwmod,
+	&omap2420_timer9_hwmod,
+	&omap2420_timer10_hwmod,
+	&omap2420_timer11_hwmod,
+	&omap2420_timer12_hwmod,
+
 	&omap2420_wd_timer2_hwmod,
 	&omap2420_uart1_hwmod,
 	&omap2420_uart2_hwmod,

commit 3cb72fa4fed52437484a699ba78ad926ff4483c5
Author: Charulatha V <charu@ti.com>
Date:   Thu Feb 24 12:51:46 2011 -0800

    OMAP2420: hwmod data: Add McBSP
    
    Add McBSP hwmod data for OMAP2420.
    
    Also add macros in prcm-common.h for idlest bit of OMAP24XX McBSP devices
    
    Signed-off-by: Charulatha V <charu@ti.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Shubhrajyoti D <shubhrajyoti@ti.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 19ad9d053ded..e44ecb465519 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -109,6 +109,8 @@ static struct omap_hwmod omap2420_uart2_hwmod;
 static struct omap_hwmod omap2420_uart3_hwmod;
 static struct omap_hwmod omap2420_i2c1_hwmod;
 static struct omap_hwmod omap2420_i2c2_hwmod;
+static struct omap_hwmod omap2420_mcbsp1_hwmod;
+static struct omap_hwmod omap2420_mcbsp2_hwmod;
 
 /* l4 core -> mcspi1 interface */
 static struct omap_hwmod_addr_space omap2420_mcspi1_addr_space[] = {
@@ -1390,6 +1392,129 @@ static struct omap_hwmod omap2420_mcspi2_hwmod = {
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
+/*
+ * 'mcbsp' class
+ * multi channel buffered serial port controller
+ */
+
+static struct omap_hwmod_class omap2420_mcbsp_hwmod_class = {
+	.name = "mcbsp",
+};
+
+/* mcbsp1 */
+static struct omap_hwmod_irq_info omap2420_mcbsp1_irqs[] = {
+	{ .name = "tx", .irq = 59 },
+	{ .name = "rx", .irq = 60 },
+};
+
+static struct omap_hwmod_dma_info omap2420_mcbsp1_sdma_chs[] = {
+	{ .name = "rx", .dma_req = 32 },
+	{ .name = "tx", .dma_req = 31 },
+};
+
+static struct omap_hwmod_addr_space omap2420_mcbsp1_addrs[] = {
+	{
+		.name		= "mpu",
+		.pa_start	= 0x48074000,
+		.pa_end		= 0x480740ff,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+/* l4_core -> mcbsp1 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp1 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_mcbsp1_hwmod,
+	.clk		= "mcbsp1_ick",
+	.addr		= omap2420_mcbsp1_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_mcbsp1_addrs),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* mcbsp1 slave ports */
+static struct omap_hwmod_ocp_if *omap2420_mcbsp1_slaves[] = {
+	&omap2420_l4_core__mcbsp1,
+};
+
+static struct omap_hwmod omap2420_mcbsp1_hwmod = {
+	.name		= "mcbsp1",
+	.class		= &omap2420_mcbsp_hwmod_class,
+	.mpu_irqs	= omap2420_mcbsp1_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_mcbsp1_irqs),
+	.sdma_reqs	= omap2420_mcbsp1_sdma_chs,
+	.sdma_reqs_cnt	= ARRAY_SIZE(omap2420_mcbsp1_sdma_chs),
+	.main_clk	= "mcbsp1_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_MCBSP1_SHIFT,
+			.module_offs = CORE_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_MCBSP1_SHIFT,
+		},
+	},
+	.slaves		= omap2420_mcbsp1_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_mcbsp1_slaves),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+};
+
+/* mcbsp2 */
+static struct omap_hwmod_irq_info omap2420_mcbsp2_irqs[] = {
+	{ .name = "tx", .irq = 62 },
+	{ .name = "rx", .irq = 63 },
+};
+
+static struct omap_hwmod_dma_info omap2420_mcbsp2_sdma_chs[] = {
+	{ .name = "rx", .dma_req = 34 },
+	{ .name = "tx", .dma_req = 33 },
+};
+
+static struct omap_hwmod_addr_space omap2420_mcbsp2_addrs[] = {
+	{
+		.name		= "mpu",
+		.pa_start	= 0x48076000,
+		.pa_end		= 0x480760ff,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+/* l4_core -> mcbsp2 */
+static struct omap_hwmod_ocp_if omap2420_l4_core__mcbsp2 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_mcbsp2_hwmod,
+	.clk		= "mcbsp2_ick",
+	.addr		= omap2420_mcbsp2_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_mcbsp2_addrs),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* mcbsp2 slave ports */
+static struct omap_hwmod_ocp_if *omap2420_mcbsp2_slaves[] = {
+	&omap2420_l4_core__mcbsp2,
+};
+
+static struct omap_hwmod omap2420_mcbsp2_hwmod = {
+	.name		= "mcbsp2",
+	.class		= &omap2420_mcbsp_hwmod_class,
+	.mpu_irqs	= omap2420_mcbsp2_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_mcbsp2_irqs),
+	.sdma_reqs	= omap2420_mcbsp2_sdma_chs,
+	.sdma_reqs_cnt	= ARRAY_SIZE(omap2420_mcbsp2_sdma_chs),
+	.main_clk	= "mcbsp2_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_MCBSP2_SHIFT,
+			.module_offs = CORE_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_MCBSP2_SHIFT,
+		},
+	},
+	.slaves		= omap2420_mcbsp2_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_mcbsp2_slaves),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+};
+
 static __initdata struct omap_hwmod *omap2420_hwmods[] = {
 	&omap2420_l3_main_hwmod,
 	&omap2420_l4_core_hwmod,
@@ -1421,6 +1546,10 @@ static __initdata struct omap_hwmod *omap2420_hwmods[] = {
 	/* mailbox class */
 	&omap2420_mailbox_hwmod,
 
+	/* mcbsp class */
+	&omap2420_mcbsp1_hwmod,
+	&omap2420_mcbsp2_hwmod,
+
 	/* mcspi class */
 	&omap2420_mcspi1_hwmod,
 	&omap2420_mcspi2_hwmod,

commit fca1ab55f9a9f7e862a03a68c2b5577c15c344df
Author: Omar Ramirez Luna <omar.ramirez@ti.com>
Date:   Thu Feb 24 12:51:32 2011 -0800

    OMAP2: hwmod data: add mailbox data
    
    Mailbox hwmod data for omap2430 and 2420.
    
    Signed-off-by: Omar Ramirez Luna <omar.ramirez@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index f323c6bb22de..19ad9d053ded 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -1207,6 +1207,76 @@ static struct omap_hwmod omap2420_dma_system_hwmod = {
 	.flags		= HWMOD_NO_IDLEST,
 };
 
+/*
+ * 'mailbox' class
+ * mailbox module allowing communication between the on-chip processors
+ * using a queued mailbox-interrupt mechanism.
+ */
+
+static struct omap_hwmod_class_sysconfig omap2420_mailbox_sysc = {
+	.rev_offs	= 0x000,
+	.sysc_offs	= 0x010,
+	.syss_offs	= 0x014,
+	.sysc_flags	= (SYSC_HAS_CLOCKACTIVITY | SYSC_HAS_SIDLEMODE |
+			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
+	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
+	.sysc_fields	= &omap_hwmod_sysc_type1,
+};
+
+static struct omap_hwmod_class omap2420_mailbox_hwmod_class = {
+	.name = "mailbox",
+	.sysc = &omap2420_mailbox_sysc,
+};
+
+/* mailbox */
+static struct omap_hwmod omap2420_mailbox_hwmod;
+static struct omap_hwmod_irq_info omap2420_mailbox_irqs[] = {
+	{ .name = "dsp", .irq = 26 },
+	{ .name = "iva", .irq = 34 },
+};
+
+static struct omap_hwmod_addr_space omap2420_mailbox_addrs[] = {
+	{
+		.pa_start	= 0x48094000,
+		.pa_end		= 0x480941ff,
+		.flags		= ADDR_TYPE_RT,
+	},
+};
+
+/* l4_core -> mailbox */
+static struct omap_hwmod_ocp_if omap2420_l4_core__mailbox = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_mailbox_hwmod,
+	.addr		= omap2420_mailbox_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_mailbox_addrs),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* mailbox slave ports */
+static struct omap_hwmod_ocp_if *omap2420_mailbox_slaves[] = {
+	&omap2420_l4_core__mailbox,
+};
+
+static struct omap_hwmod omap2420_mailbox_hwmod = {
+	.name		= "mailbox",
+	.class		= &omap2420_mailbox_hwmod_class,
+	.mpu_irqs	= omap2420_mailbox_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_mailbox_irqs),
+	.main_clk	= "mailboxes_ick",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_MAILBOXES_SHIFT,
+			.module_offs = CORE_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_MAILBOXES_SHIFT,
+		},
+	},
+	.slaves		= omap2420_mailbox_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_mailbox_slaves),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+};
+
 /*
  * 'mcspi' class
  * multichannel serial port interface (mcspi) / master/slave synchronous serial
@@ -1348,6 +1418,9 @@ static __initdata struct omap_hwmod *omap2420_hwmods[] = {
 	/* dma_system class*/
 	&omap2420_dma_system_hwmod,
 
+	/* mailbox class */
+	&omap2420_mailbox_hwmod,
+
 	/* mcspi class */
 	&omap2420_mcspi1_hwmod,
 	&omap2420_mcspi2_hwmod,

commit 996746ca127d722c279325552cdcc48b20079a61
Author: Senthilvadivu Guruswamy <svadivu@ti.com>
Date:   Tue Feb 22 09:50:36 2011 +0200

    OMAP2420: hwmod data: add DSS DISPC RFBI VENC
    
    Hwmod needs database of all IPs in a system. This patch generates the hwmod
    database for OMAP2420 Display Sub System,. Since DSS is also considered as an
    IP as DISPC, RFBI, name it as dss_core.
    
    Acked-by: Benoit Cousson <b-cousson@ti.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Tested-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Sumit Semwal <sumit.semwal@ti.com>
    Signed-off-by: Senthilvadivu Guruswamy <svadivu@ti.com>
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 7fffd340c76f..f323c6bb22de 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -19,6 +19,8 @@
 #include <plat/i2c.h>
 #include <plat/gpio.h>
 #include <plat/mcspi.h>
+#include <plat/l3_2xxx.h>
+#include <plat/l4_2xxx.h>
 
 #include "omap_hwmod_common_data.h"
 
@@ -39,6 +41,10 @@ static struct omap_hwmod omap2420_mpu_hwmod;
 static struct omap_hwmod omap2420_iva_hwmod;
 static struct omap_hwmod omap2420_l3_main_hwmod;
 static struct omap_hwmod omap2420_l4_core_hwmod;
+static struct omap_hwmod omap2420_dss_core_hwmod;
+static struct omap_hwmod omap2420_dss_dispc_hwmod;
+static struct omap_hwmod omap2420_dss_rfbi_hwmod;
+static struct omap_hwmod omap2420_dss_venc_hwmod;
 static struct omap_hwmod omap2420_wd_timer2_hwmod;
 static struct omap_hwmod omap2420_gpio1_hwmod;
 static struct omap_hwmod omap2420_gpio2_hwmod;
@@ -67,6 +73,19 @@ static struct omap_hwmod_ocp_if *omap2420_l3_main_slaves[] = {
 	&omap2420_mpu__l3_main,
 };
 
+/* DSS -> l3 */
+static struct omap_hwmod_ocp_if omap2420_dss__l3 = {
+	.master		= &omap2420_dss_core_hwmod,
+	.slave		= &omap2420_l3_main_hwmod,
+	.fw = {
+		.omap2 = {
+			.l3_perm_bit  = OMAP2_L3_CORE_FW_CONNID_DSS,
+			.flags	= OMAP_FIREWALL_L3,
+		}
+	},
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
 /* Master interfaces on the L3 interconnect */
 static struct omap_hwmod_ocp_if *omap2420_l3_main_masters[] = {
 	&omap2420_l3_main__l4_core,
@@ -509,6 +528,291 @@ static struct omap_hwmod omap2420_uart3_hwmod = {
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
+/*
+ * 'dss' class
+ * display sub-system
+ */
+
+static struct omap_hwmod_class_sysconfig omap2420_dss_sysc = {
+	.rev_offs	= 0x0000,
+	.sysc_offs	= 0x0010,
+	.syss_offs	= 0x0014,
+	.sysc_flags	= (SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
+	.sysc_fields	= &omap_hwmod_sysc_type1,
+};
+
+static struct omap_hwmod_class omap2420_dss_hwmod_class = {
+	.name = "dss",
+	.sysc = &omap2420_dss_sysc,
+};
+
+/* dss */
+static struct omap_hwmod_irq_info omap2420_dss_irqs[] = {
+	{ .irq = 25 },
+};
+
+static struct omap_hwmod_dma_info omap2420_dss_sdma_chs[] = {
+	{ .name = "dispc", .dma_req = 5 },
+};
+
+/* dss */
+/* dss master ports */
+static struct omap_hwmod_ocp_if *omap2420_dss_masters[] = {
+	&omap2420_dss__l3,
+};
+
+static struct omap_hwmod_addr_space omap2420_dss_addrs[] = {
+	{
+		.pa_start	= 0x48050000,
+		.pa_end		= 0x480503FF,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+/* l4_core -> dss */
+static struct omap_hwmod_ocp_if omap2420_l4_core__dss = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_dss_core_hwmod,
+	.clk		= "dss_ick",
+	.addr		= omap2420_dss_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_dss_addrs),
+	.fw = {
+		.omap2 = {
+			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_CORE_REGION,
+			.flags	= OMAP_FIREWALL_L4,
+		}
+	},
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* dss slave ports */
+static struct omap_hwmod_ocp_if *omap2420_dss_slaves[] = {
+	&omap2420_l4_core__dss,
+};
+
+static struct omap_hwmod_opt_clk dss_opt_clks[] = {
+	{ .role = "tv_clk", .clk = "dss_54m_fck" },
+	{ .role = "sys_clk", .clk = "dss2_fck" },
+};
+
+static struct omap_hwmod omap2420_dss_core_hwmod = {
+	.name		= "dss_core",
+	.class		= &omap2420_dss_hwmod_class,
+	.main_clk	= "dss1_fck", /* instead of dss_fck */
+	.mpu_irqs	= omap2420_dss_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_dss_irqs),
+	.sdma_reqs	= omap2420_dss_sdma_chs,
+	.sdma_reqs_cnt	= ARRAY_SIZE(omap2420_dss_sdma_chs),
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_DSS1_SHIFT,
+			.module_offs = CORE_MOD,
+			.idlest_reg_id = 1,
+			.idlest_stdby_bit = OMAP24XX_ST_DSS_SHIFT,
+		},
+	},
+	.opt_clks	= dss_opt_clks,
+	.opt_clks_cnt = ARRAY_SIZE(dss_opt_clks),
+	.slaves		= omap2420_dss_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_dss_slaves),
+	.masters	= omap2420_dss_masters,
+	.masters_cnt	= ARRAY_SIZE(omap2420_dss_masters),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+	.flags		= HWMOD_NO_IDLEST,
+};
+
+/*
+ * 'dispc' class
+ * display controller
+ */
+
+static struct omap_hwmod_class_sysconfig omap2420_dispc_sysc = {
+	.rev_offs	= 0x0000,
+	.sysc_offs	= 0x0010,
+	.syss_offs	= 0x0014,
+	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_MIDLEMODE |
+			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
+	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
+			   MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
+	.sysc_fields	= &omap_hwmod_sysc_type1,
+};
+
+static struct omap_hwmod_class omap2420_dispc_hwmod_class = {
+	.name = "dispc",
+	.sysc = &omap2420_dispc_sysc,
+};
+
+static struct omap_hwmod_addr_space omap2420_dss_dispc_addrs[] = {
+	{
+		.pa_start	= 0x48050400,
+		.pa_end		= 0x480507FF,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+/* l4_core -> dss_dispc */
+static struct omap_hwmod_ocp_if omap2420_l4_core__dss_dispc = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_dss_dispc_hwmod,
+	.clk		= "dss_ick",
+	.addr		= omap2420_dss_dispc_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_dss_dispc_addrs),
+	.fw = {
+		.omap2 = {
+			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_DISPC_REGION,
+			.flags	= OMAP_FIREWALL_L4,
+		}
+	},
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* dss_dispc slave ports */
+static struct omap_hwmod_ocp_if *omap2420_dss_dispc_slaves[] = {
+	&omap2420_l4_core__dss_dispc,
+};
+
+static struct omap_hwmod omap2420_dss_dispc_hwmod = {
+	.name		= "dss_dispc",
+	.class		= &omap2420_dispc_hwmod_class,
+	.main_clk	= "dss1_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_DSS1_SHIFT,
+			.module_offs = CORE_MOD,
+			.idlest_reg_id = 1,
+			.idlest_stdby_bit = OMAP24XX_ST_DSS_SHIFT,
+		},
+	},
+	.slaves		= omap2420_dss_dispc_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_dss_dispc_slaves),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+	.flags		= HWMOD_NO_IDLEST,
+};
+
+/*
+ * 'rfbi' class
+ * remote frame buffer interface
+ */
+
+static struct omap_hwmod_class_sysconfig omap2420_rfbi_sysc = {
+	.rev_offs	= 0x0000,
+	.sysc_offs	= 0x0010,
+	.syss_offs	= 0x0014,
+	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET |
+			   SYSC_HAS_AUTOIDLE),
+	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
+	.sysc_fields	= &omap_hwmod_sysc_type1,
+};
+
+static struct omap_hwmod_class omap2420_rfbi_hwmod_class = {
+	.name = "rfbi",
+	.sysc = &omap2420_rfbi_sysc,
+};
+
+static struct omap_hwmod_addr_space omap2420_dss_rfbi_addrs[] = {
+	{
+		.pa_start	= 0x48050800,
+		.pa_end		= 0x48050BFF,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+/* l4_core -> dss_rfbi */
+static struct omap_hwmod_ocp_if omap2420_l4_core__dss_rfbi = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_dss_rfbi_hwmod,
+	.clk		= "dss_ick",
+	.addr		= omap2420_dss_rfbi_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_dss_rfbi_addrs),
+	.fw = {
+		.omap2 = {
+			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_CORE_REGION,
+			.flags	= OMAP_FIREWALL_L4,
+		}
+	},
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* dss_rfbi slave ports */
+static struct omap_hwmod_ocp_if *omap2420_dss_rfbi_slaves[] = {
+	&omap2420_l4_core__dss_rfbi,
+};
+
+static struct omap_hwmod omap2420_dss_rfbi_hwmod = {
+	.name		= "dss_rfbi",
+	.class		= &omap2420_rfbi_hwmod_class,
+	.main_clk	= "dss1_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_DSS1_SHIFT,
+			.module_offs = CORE_MOD,
+		},
+	},
+	.slaves		= omap2420_dss_rfbi_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_dss_rfbi_slaves),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+	.flags		= HWMOD_NO_IDLEST,
+};
+
+/*
+ * 'venc' class
+ * video encoder
+ */
+
+static struct omap_hwmod_class omap2420_venc_hwmod_class = {
+	.name = "venc",
+};
+
+/* dss_venc */
+static struct omap_hwmod_addr_space omap2420_dss_venc_addrs[] = {
+	{
+		.pa_start	= 0x48050C00,
+		.pa_end		= 0x48050FFF,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+/* l4_core -> dss_venc */
+static struct omap_hwmod_ocp_if omap2420_l4_core__dss_venc = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_dss_venc_hwmod,
+	.clk		= "dss_54m_fck",
+	.addr		= omap2420_dss_venc_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_dss_venc_addrs),
+	.fw = {
+		.omap2 = {
+			.l4_fw_region  = OMAP2420_L4_CORE_FW_DSS_VENC_REGION,
+			.flags	= OMAP_FIREWALL_L4,
+		}
+	},
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* dss_venc slave ports */
+static struct omap_hwmod_ocp_if *omap2420_dss_venc_slaves[] = {
+	&omap2420_l4_core__dss_venc,
+};
+
+static struct omap_hwmod omap2420_dss_venc_hwmod = {
+	.name		= "dss_venc",
+	.class		= &omap2420_venc_hwmod_class,
+	.main_clk	= "dss1_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_DSS1_SHIFT,
+			.module_offs = CORE_MOD,
+		},
+	},
+	.slaves		= omap2420_dss_venc_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_dss_venc_slaves),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+	.flags		= HWMOD_NO_IDLEST,
+};
+
 /* I2C common */
 static struct omap_hwmod_class_sysconfig i2c_sysc = {
 	.rev_offs	= 0x00,
@@ -1026,6 +1330,12 @@ static __initdata struct omap_hwmod *omap2420_hwmods[] = {
 	&omap2420_uart1_hwmod,
 	&omap2420_uart2_hwmod,
 	&omap2420_uart3_hwmod,
+	/* dss class */
+	&omap2420_dss_core_hwmod,
+	&omap2420_dss_dispc_hwmod,
+	&omap2420_dss_rfbi_hwmod,
+	&omap2420_dss_venc_hwmod,
+	/* i2c class */
 	&omap2420_i2c1_hwmod,
 	&omap2420_i2c2_hwmod,
 

commit 617871deacea4e1a5713dd37564dc94a392d80c3
Author: Charulatha V <charu@ti.com>
Date:   Thu Feb 17 09:53:09 2011 -0800

    OMAP2420: hwmod data: Add McSPI
    
    Update the omap2420 hwmod data with the McSPI info.
    Add a device attribute structure which will be used
    for passing number of chipselects from hwmod data.
    Add revision macros to be passed from rev field from
    hwmod.
    
    Signed-off-by: Charulatha V <charu@ti.com>
    Signed-off-by: Govindraj.R <govindraj.raja@ti.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index b85c630b64d6..7fffd340c76f 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -18,6 +18,7 @@
 #include <plat/serial.h>
 #include <plat/i2c.h>
 #include <plat/gpio.h>
+#include <plat/mcspi.h>
 
 #include "omap_hwmod_common_data.h"
 
@@ -44,6 +45,8 @@ static struct omap_hwmod omap2420_gpio2_hwmod;
 static struct omap_hwmod omap2420_gpio3_hwmod;
 static struct omap_hwmod omap2420_gpio4_hwmod;
 static struct omap_hwmod omap2420_dma_system_hwmod;
+static struct omap_hwmod omap2420_mcspi1_hwmod;
+static struct omap_hwmod omap2420_mcspi2_hwmod;
 
 /* L3 -> L4_CORE interface */
 static struct omap_hwmod_ocp_if omap2420_l3_main__l4_core = {
@@ -88,6 +91,42 @@ static struct omap_hwmod omap2420_uart3_hwmod;
 static struct omap_hwmod omap2420_i2c1_hwmod;
 static struct omap_hwmod omap2420_i2c2_hwmod;
 
+/* l4 core -> mcspi1 interface */
+static struct omap_hwmod_addr_space omap2420_mcspi1_addr_space[] = {
+	{
+		.pa_start	= 0x48098000,
+		.pa_end		= 0x480980ff,
+		.flags		= ADDR_TYPE_RT,
+	},
+};
+
+static struct omap_hwmod_ocp_if omap2420_l4_core__mcspi1 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_mcspi1_hwmod,
+	.clk		= "mcspi1_ick",
+	.addr		= omap2420_mcspi1_addr_space,
+	.addr_cnt	= ARRAY_SIZE(omap2420_mcspi1_addr_space),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4 core -> mcspi2 interface */
+static struct omap_hwmod_addr_space omap2420_mcspi2_addr_space[] = {
+	{
+		.pa_start	= 0x4809a000,
+		.pa_end		= 0x4809a0ff,
+		.flags		= ADDR_TYPE_RT,
+	},
+};
+
+static struct omap_hwmod_ocp_if omap2420_l4_core__mcspi2 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_mcspi2_hwmod,
+	.clk		= "mcspi2_ick",
+	.addr		= omap2420_mcspi2_addr_space,
+	.addr_cnt	= ARRAY_SIZE(omap2420_mcspi2_addr_space),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
 /* L4_CORE -> L4_WKUP interface */
 static struct omap_hwmod_ocp_if omap2420_l4_core__l4_wkup = {
 	.master	= &omap2420_l4_core_hwmod,
@@ -864,6 +903,119 @@ static struct omap_hwmod omap2420_dma_system_hwmod = {
 	.flags		= HWMOD_NO_IDLEST,
 };
 
+/*
+ * 'mcspi' class
+ * multichannel serial port interface (mcspi) / master/slave synchronous serial
+ * bus
+ */
+
+static struct omap_hwmod_class_sysconfig omap2420_mcspi_sysc = {
+	.rev_offs	= 0x0000,
+	.sysc_offs	= 0x0010,
+	.syss_offs	= 0x0014,
+	.sysc_flags	= (SYSC_HAS_CLOCKACTIVITY | SYSC_HAS_SIDLEMODE |
+				SYSC_HAS_ENAWAKEUP | SYSC_HAS_SOFTRESET |
+				SYSC_HAS_AUTOIDLE | SYSS_HAS_RESET_STATUS),
+	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
+	.sysc_fields    = &omap_hwmod_sysc_type1,
+};
+
+static struct omap_hwmod_class omap2420_mcspi_class = {
+	.name = "mcspi",
+	.sysc = &omap2420_mcspi_sysc,
+	.rev = OMAP2_MCSPI_REV,
+};
+
+/* mcspi1 */
+static struct omap_hwmod_irq_info omap2420_mcspi1_mpu_irqs[] = {
+	{ .irq = 65 },
+};
+
+static struct omap_hwmod_dma_info omap2420_mcspi1_sdma_reqs[] = {
+	{ .name = "tx0", .dma_req = 35 }, /* DMA_SPI1_TX0 */
+	{ .name = "rx0", .dma_req = 36 }, /* DMA_SPI1_RX0 */
+	{ .name = "tx1", .dma_req = 37 }, /* DMA_SPI1_TX1 */
+	{ .name = "rx1", .dma_req = 38 }, /* DMA_SPI1_RX1 */
+	{ .name = "tx2", .dma_req = 39 }, /* DMA_SPI1_TX2 */
+	{ .name = "rx2", .dma_req = 40 }, /* DMA_SPI1_RX2 */
+	{ .name = "tx3", .dma_req = 41 }, /* DMA_SPI1_TX3 */
+	{ .name = "rx3", .dma_req = 42 }, /* DMA_SPI1_RX3 */
+};
+
+static struct omap_hwmod_ocp_if *omap2420_mcspi1_slaves[] = {
+	&omap2420_l4_core__mcspi1,
+};
+
+static struct omap2_mcspi_dev_attr omap_mcspi1_dev_attr = {
+	.num_chipselect = 4,
+};
+
+static struct omap_hwmod omap2420_mcspi1_hwmod = {
+	.name		= "mcspi1_hwmod",
+	.mpu_irqs	= omap2420_mcspi1_mpu_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_mcspi1_mpu_irqs),
+	.sdma_reqs	= omap2420_mcspi1_sdma_reqs,
+	.sdma_reqs_cnt	= ARRAY_SIZE(omap2420_mcspi1_sdma_reqs),
+	.main_clk	= "mcspi1_fck",
+	.prcm		= {
+		.omap2 = {
+			.module_offs = CORE_MOD,
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_MCSPI1_SHIFT,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_MCSPI1_SHIFT,
+		},
+	},
+	.slaves		= omap2420_mcspi1_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_mcspi1_slaves),
+	.class		= &omap2420_mcspi_class,
+	.dev_attr       = &omap_mcspi1_dev_attr,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+};
+
+/* mcspi2 */
+static struct omap_hwmod_irq_info omap2420_mcspi2_mpu_irqs[] = {
+	{ .irq = 66 },
+};
+
+static struct omap_hwmod_dma_info omap2420_mcspi2_sdma_reqs[] = {
+	{ .name = "tx0", .dma_req = 43 }, /* DMA_SPI2_TX0 */
+	{ .name = "rx0", .dma_req = 44 }, /* DMA_SPI2_RX0 */
+	{ .name = "tx1", .dma_req = 45 }, /* DMA_SPI2_TX1 */
+	{ .name = "rx1", .dma_req = 46 }, /* DMA_SPI2_RX1 */
+};
+
+static struct omap_hwmod_ocp_if *omap2420_mcspi2_slaves[] = {
+	&omap2420_l4_core__mcspi2,
+};
+
+static struct omap2_mcspi_dev_attr omap_mcspi2_dev_attr = {
+	.num_chipselect = 2,
+};
+
+static struct omap_hwmod omap2420_mcspi2_hwmod = {
+	.name		= "mcspi2_hwmod",
+	.mpu_irqs	= omap2420_mcspi2_mpu_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_mcspi2_mpu_irqs),
+	.sdma_reqs	= omap2420_mcspi2_sdma_reqs,
+	.sdma_reqs_cnt	= ARRAY_SIZE(omap2420_mcspi2_sdma_reqs),
+	.main_clk	= "mcspi2_fck",
+	.prcm		= {
+		.omap2 = {
+			.module_offs = CORE_MOD,
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_MCSPI2_SHIFT,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_MCSPI2_SHIFT,
+		},
+	},
+	.slaves		= omap2420_mcspi2_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_mcspi2_slaves),
+	.class		= &omap2420_mcspi_class,
+	.dev_attr       = &omap_mcspi2_dev_attr,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+};
+
 static __initdata struct omap_hwmod *omap2420_hwmods[] = {
 	&omap2420_l3_main_hwmod,
 	&omap2420_l4_core_hwmod,
@@ -885,6 +1037,10 @@ static __initdata struct omap_hwmod *omap2420_hwmods[] = {
 
 	/* dma_system class*/
 	&omap2420_dma_system_hwmod,
+
+	/* mcspi class */
+	&omap2420_mcspi1_hwmod,
+	&omap2420_mcspi2_hwmod,
 	NULL,
 };
 

commit ff2516fbef20ed9edd9cc2fc8b8b48d5cb5a932f
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 21 15:39:15 2010 -0700

    OMAP2+: wd_timer: disable on boot via hwmod postsetup mechanism
    
    The OMAP watchdog timer IP blocks require a specific set of register
    writes to occur before they will be disabled[1], even if the device
    clocks appear to be disabled in the CM_*CLKEN registers.  In the MPU
    watchdog case, failure to execute this reset sequence will eventually
    cause the watchdog to reset the OMAP unexpectedly.
    
    Previously, the code to disable this watchdog was manually called from
    mach-omap2/devices.c during device initialization.  This causes the
    watchdog to be unconditionally disabled for a portion of kernel
    initialization.  This should be controllable by the board-*.c files,
    since some system integrators will want full watchdog coverage of
    kernel initialization.  Also, the watchdog disable code was not
    connected to the hwmod shutdown code.  This means that calling
    omap_hwmod_shutdown() will not, in fact, disable the watchdog, and the
    goal of omap_hwmod_shutdown() is to be able to shutdown any on-chip
    OMAP device.
    
    To resolve the latter problem, populate the pre_shutdown pointer in
    the watchdog timer hwmod classes with a function that executes the
    watchdog shutdown sequence.  This allows the hwmod code to fully
    disable the watchdog.
    
    Then, to allow some board files to support watchdog coverage
    throughout kernel initialization, add common code to mach-omap2/io.c
    to cause the MPU watchdog to be disabled on boot unless a board file
    specifically requests it to remain enabled.  Board files can do this
    by changing the watchdog timer hwmod's postsetup state between the
    omap2_init_common_infrastructure() and omap2_init_common_devices()
    function calls.
    
    1. OMAP34xx Multimedia Device Silicon Revision 3.1.x Rev. ZH
       [SWPU222H], Section 16.4.3.6, "Start/Stop Sequence for WDTs (Using
       WDTi.WSPR Register)"
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Beno√Æt Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Charulatha Varadarajan <charu@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 42606f6b0cdf..b85c630b64d6 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -23,6 +23,7 @@
 
 #include "cm-regbits-24xx.h"
 #include "prm-regbits-24xx.h"
+#include "wd_timer.h"
 
 /*
  * OMAP2420 hardware module integration data
@@ -312,8 +313,9 @@ static struct omap_hwmod_class_sysconfig omap2420_wd_timer_sysc = {
 };
 
 static struct omap_hwmod_class omap2420_wd_timer_hwmod_class = {
-	.name = "wd_timer",
-	.sysc = &omap2420_wd_timer_sysc,
+	.name		= "wd_timer",
+	.sysc		= &omap2420_wd_timer_sysc,
+	.pre_shutdown	= &omap2_wd_timer_disable
 };
 
 /* wd_timer2 */

commit 745685df95961ebbf0bcafcf28f31217a75070ae
Author: G, Manjunath Kondaiah <manjugk@ti.com>
Date:   Mon Dec 20 18:27:18 2010 -0800

    OMAP2420: hwmod data: add system DMA
    
    Add OMAP2420 DMA hwmod data and also add required
    DMA device attributes.
    
    Signed-off-by: G, Manjunath Kondaiah <manjugk@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index d95342599793..42606f6b0cdf 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -42,6 +42,7 @@ static struct omap_hwmod omap2420_gpio1_hwmod;
 static struct omap_hwmod omap2420_gpio2_hwmod;
 static struct omap_hwmod omap2420_gpio3_hwmod;
 static struct omap_hwmod omap2420_gpio4_hwmod;
+static struct omap_hwmod omap2420_dma_system_hwmod;
 
 /* L3 -> L4_CORE interface */
 static struct omap_hwmod_ocp_if omap2420_l3_main__l4_core = {
@@ -779,6 +780,88 @@ static struct omap_hwmod omap2420_gpio4_hwmod = {
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
+/* system dma */
+static struct omap_hwmod_class_sysconfig omap2420_dma_sysc = {
+	.rev_offs	= 0x0000,
+	.sysc_offs	= 0x002c,
+	.syss_offs	= 0x0028,
+	.sysc_flags	= (SYSC_HAS_SOFTRESET | SYSC_HAS_MIDLEMODE |
+			   SYSC_HAS_CLOCKACTIVITY | SYSC_HAS_EMUFREE |
+			   SYSC_HAS_AUTOIDLE),
+	.idlemodes	= (MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
+	.sysc_fields	= &omap_hwmod_sysc_type1,
+};
+
+static struct omap_hwmod_class omap2420_dma_hwmod_class = {
+	.name = "dma",
+	.sysc = &omap2420_dma_sysc,
+};
+
+/* dma attributes */
+static struct omap_dma_dev_attr dma_dev_attr = {
+	.dev_caps  = RESERVE_CHANNEL | DMA_LINKED_LCH | GLOBAL_PRIORITY |
+						IS_CSSA_32 | IS_CDSA_32,
+	.lch_count = 32,
+};
+
+static struct omap_hwmod_irq_info omap2420_dma_system_irqs[] = {
+	{ .name = "0", .irq = 12 }, /* INT_24XX_SDMA_IRQ0 */
+	{ .name = "1", .irq = 13 }, /* INT_24XX_SDMA_IRQ1 */
+	{ .name = "2", .irq = 14 }, /* INT_24XX_SDMA_IRQ2 */
+	{ .name = "3", .irq = 15 }, /* INT_24XX_SDMA_IRQ3 */
+};
+
+static struct omap_hwmod_addr_space omap2420_dma_system_addrs[] = {
+	{
+		.pa_start	= 0x48056000,
+		.pa_end		= 0x4a0560ff,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+/* dma_system -> L3 */
+static struct omap_hwmod_ocp_if omap2420_dma_system__l3 = {
+	.master		= &omap2420_dma_system_hwmod,
+	.slave		= &omap2420_l3_main_hwmod,
+	.clk		= "core_l3_ck",
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* dma_system master ports */
+static struct omap_hwmod_ocp_if *omap2420_dma_system_masters[] = {
+	&omap2420_dma_system__l3,
+};
+
+/* l4_core -> dma_system */
+static struct omap_hwmod_ocp_if omap2420_l4_core__dma_system = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_dma_system_hwmod,
+	.clk		= "sdma_ick",
+	.addr		= omap2420_dma_system_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_dma_system_addrs),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* dma_system slave ports */
+static struct omap_hwmod_ocp_if *omap2420_dma_system_slaves[] = {
+	&omap2420_l4_core__dma_system,
+};
+
+static struct omap_hwmod omap2420_dma_system_hwmod = {
+	.name		= "dma",
+	.class		= &omap2420_dma_hwmod_class,
+	.mpu_irqs	= omap2420_dma_system_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap2420_dma_system_irqs),
+	.main_clk	= "core_l3_ck",
+	.slaves		= omap2420_dma_system_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_dma_system_slaves),
+	.masters	= omap2420_dma_system_masters,
+	.masters_cnt	= ARRAY_SIZE(omap2420_dma_system_masters),
+	.dev_attr	= &dma_dev_attr,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+	.flags		= HWMOD_NO_IDLEST,
+};
+
 static __initdata struct omap_hwmod *omap2420_hwmods[] = {
 	&omap2420_l3_main_hwmod,
 	&omap2420_l4_core_hwmod,
@@ -797,6 +880,9 @@ static __initdata struct omap_hwmod *omap2420_hwmods[] = {
 	&omap2420_gpio2_hwmod,
 	&omap2420_gpio3_hwmod,
 	&omap2420_gpio4_hwmod,
+
+	/* dma_system class*/
+	&omap2420_dma_system_hwmod,
 	NULL,
 };
 

commit 59c348c38fbe85e6e86c711b9a38c37315008d9e
Author: Varadarajan, Charulatha <charu@ti.com>
Date:   Tue Dec 7 16:26:56 2010 -0800

    OMAP2420: hwmod data: Add GPIO
    
    Add GPIO hwmod data for OMAP2420 and add the required
    GPIO device attributes in the gpio header file
    
    Also remove "omap24xx.h" header file as it is not required
    anymore.
    
    Signed-off-by: Charulatha V <charu@ti.com>
    Acked-by: Benoit Cousson <b-cousson@ti.com>
    Acked-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index a1a3dd6303b4..d95342599793 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -17,7 +17,7 @@
 #include <plat/dma.h>
 #include <plat/serial.h>
 #include <plat/i2c.h>
-#include <plat/omap24xx.h>
+#include <plat/gpio.h>
 
 #include "omap_hwmod_common_data.h"
 
@@ -38,6 +38,10 @@ static struct omap_hwmod omap2420_iva_hwmod;
 static struct omap_hwmod omap2420_l3_main_hwmod;
 static struct omap_hwmod omap2420_l4_core_hwmod;
 static struct omap_hwmod omap2420_wd_timer2_hwmod;
+static struct omap_hwmod omap2420_gpio1_hwmod;
+static struct omap_hwmod omap2420_gpio2_hwmod;
+static struct omap_hwmod omap2420_gpio3_hwmod;
+static struct omap_hwmod omap2420_gpio4_hwmod;
 
 /* L3 -> L4_CORE interface */
 static struct omap_hwmod_ocp_if omap2420_l3_main__l4_core = {
@@ -557,6 +561,224 @@ static struct omap_hwmod omap2420_i2c2_hwmod = {
 	.flags		= HWMOD_16BIT_REG,
 };
 
+/* l4_wkup -> gpio1 */
+static struct omap_hwmod_addr_space omap2420_gpio1_addr_space[] = {
+	{
+		.pa_start	= 0x48018000,
+		.pa_end		= 0x480181ff,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio1 = {
+	.master		= &omap2420_l4_wkup_hwmod,
+	.slave		= &omap2420_gpio1_hwmod,
+	.clk		= "gpios_ick",
+	.addr		= omap2420_gpio1_addr_space,
+	.addr_cnt	= ARRAY_SIZE(omap2420_gpio1_addr_space),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_wkup -> gpio2 */
+static struct omap_hwmod_addr_space omap2420_gpio2_addr_space[] = {
+	{
+		.pa_start	= 0x4801a000,
+		.pa_end		= 0x4801a1ff,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio2 = {
+	.master		= &omap2420_l4_wkup_hwmod,
+	.slave		= &omap2420_gpio2_hwmod,
+	.clk		= "gpios_ick",
+	.addr		= omap2420_gpio2_addr_space,
+	.addr_cnt	= ARRAY_SIZE(omap2420_gpio2_addr_space),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_wkup -> gpio3 */
+static struct omap_hwmod_addr_space omap2420_gpio3_addr_space[] = {
+	{
+		.pa_start	= 0x4801c000,
+		.pa_end		= 0x4801c1ff,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio3 = {
+	.master		= &omap2420_l4_wkup_hwmod,
+	.slave		= &omap2420_gpio3_hwmod,
+	.clk		= "gpios_ick",
+	.addr		= omap2420_gpio3_addr_space,
+	.addr_cnt	= ARRAY_SIZE(omap2420_gpio3_addr_space),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* l4_wkup -> gpio4 */
+static struct omap_hwmod_addr_space omap2420_gpio4_addr_space[] = {
+	{
+		.pa_start	= 0x4801e000,
+		.pa_end		= 0x4801e1ff,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+static struct omap_hwmod_ocp_if omap2420_l4_wkup__gpio4 = {
+	.master		= &omap2420_l4_wkup_hwmod,
+	.slave		= &omap2420_gpio4_hwmod,
+	.clk		= "gpios_ick",
+	.addr		= omap2420_gpio4_addr_space,
+	.addr_cnt	= ARRAY_SIZE(omap2420_gpio4_addr_space),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* gpio dev_attr */
+static struct omap_gpio_dev_attr gpio_dev_attr = {
+	.bank_width = 32,
+	.dbck_flag = false,
+};
+
+static struct omap_hwmod_class_sysconfig omap242x_gpio_sysc = {
+	.rev_offs	= 0x0000,
+	.sysc_offs	= 0x0010,
+	.syss_offs	= 0x0014,
+	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
+			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
+	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
+	.sysc_fields    = &omap_hwmod_sysc_type1,
+};
+
+/*
+ * 'gpio' class
+ * general purpose io module
+ */
+static struct omap_hwmod_class omap242x_gpio_hwmod_class = {
+	.name = "gpio",
+	.sysc = &omap242x_gpio_sysc,
+	.rev = 0,
+};
+
+/* gpio1 */
+static struct omap_hwmod_irq_info omap242x_gpio1_irqs[] = {
+	{ .irq = 29 }, /* INT_24XX_GPIO_BANK1 */
+};
+
+static struct omap_hwmod_ocp_if *omap2420_gpio1_slaves[] = {
+	&omap2420_l4_wkup__gpio1,
+};
+
+static struct omap_hwmod omap2420_gpio1_hwmod = {
+	.name		= "gpio1",
+	.mpu_irqs	= omap242x_gpio1_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap242x_gpio1_irqs),
+	.main_clk	= "gpios_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_GPIOS_SHIFT,
+			.module_offs = WKUP_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_GPIOS_SHIFT,
+		},
+	},
+	.slaves		= omap2420_gpio1_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_gpio1_slaves),
+	.class		= &omap242x_gpio_hwmod_class,
+	.dev_attr	= &gpio_dev_attr,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+};
+
+/* gpio2 */
+static struct omap_hwmod_irq_info omap242x_gpio2_irqs[] = {
+	{ .irq = 30 }, /* INT_24XX_GPIO_BANK2 */
+};
+
+static struct omap_hwmod_ocp_if *omap2420_gpio2_slaves[] = {
+	&omap2420_l4_wkup__gpio2,
+};
+
+static struct omap_hwmod omap2420_gpio2_hwmod = {
+	.name		= "gpio2",
+	.mpu_irqs	= omap242x_gpio2_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap242x_gpio2_irqs),
+	.main_clk	= "gpios_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_GPIOS_SHIFT,
+			.module_offs = WKUP_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_GPIOS_SHIFT,
+		},
+	},
+	.slaves		= omap2420_gpio2_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_gpio2_slaves),
+	.class		= &omap242x_gpio_hwmod_class,
+	.dev_attr	= &gpio_dev_attr,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+};
+
+/* gpio3 */
+static struct omap_hwmod_irq_info omap242x_gpio3_irqs[] = {
+	{ .irq = 31 }, /* INT_24XX_GPIO_BANK3 */
+};
+
+static struct omap_hwmod_ocp_if *omap2420_gpio3_slaves[] = {
+	&omap2420_l4_wkup__gpio3,
+};
+
+static struct omap_hwmod omap2420_gpio3_hwmod = {
+	.name		= "gpio3",
+	.mpu_irqs	= omap242x_gpio3_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap242x_gpio3_irqs),
+	.main_clk	= "gpios_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_GPIOS_SHIFT,
+			.module_offs = WKUP_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_GPIOS_SHIFT,
+		},
+	},
+	.slaves		= omap2420_gpio3_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_gpio3_slaves),
+	.class		= &omap242x_gpio_hwmod_class,
+	.dev_attr	= &gpio_dev_attr,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+};
+
+/* gpio4 */
+static struct omap_hwmod_irq_info omap242x_gpio4_irqs[] = {
+	{ .irq = 32 }, /* INT_24XX_GPIO_BANK4 */
+};
+
+static struct omap_hwmod_ocp_if *omap2420_gpio4_slaves[] = {
+	&omap2420_l4_wkup__gpio4,
+};
+
+static struct omap_hwmod omap2420_gpio4_hwmod = {
+	.name		= "gpio4",
+	.mpu_irqs	= omap242x_gpio4_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(omap242x_gpio4_irqs),
+	.main_clk	= "gpios_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_GPIOS_SHIFT,
+			.module_offs = WKUP_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_GPIOS_SHIFT,
+		},
+	},
+	.slaves		= omap2420_gpio4_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_gpio4_slaves),
+	.class		= &omap242x_gpio_hwmod_class,
+	.dev_attr	= &gpio_dev_attr,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+};
+
 static __initdata struct omap_hwmod *omap2420_hwmods[] = {
 	&omap2420_l3_main_hwmod,
 	&omap2420_l4_core_hwmod,
@@ -569,6 +791,12 @@ static __initdata struct omap_hwmod *omap2420_hwmods[] = {
 	&omap2420_uart3_hwmod,
 	&omap2420_i2c1_hwmod,
 	&omap2420_i2c2_hwmod,
+
+	/* gpio class */
+	&omap2420_gpio1_hwmod,
+	&omap2420_gpio2_hwmod,
+	&omap2420_gpio3_hwmod,
+	&omap2420_gpio4_hwmod,
 	NULL,
 };
 

commit 2004290f55f03c52e22044a5843928cf0f6cc56a
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Sep 30 02:40:12 2010 +0530

    OMAP2xxx: hwmod: add I2C hwmods for OMAP2420, 2430
    
    Add hwmod structures for I2C controllers on OMAP2420/2430.
    
    NOTE: I2C module on OMAP2420 has 16bit registers and causes imprecise
    aborts if 32bits are read/written to it.  Use the HWMOD_16BIT_REG flag
    to notify the hmwod framework of this hard requirement so that
    __raw_writew/readw is used to read /write the mdoule registers.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index adf6e3632a2b..a1a3dd6303b4 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -16,11 +16,13 @@
 #include <plat/cpu.h>
 #include <plat/dma.h>
 #include <plat/serial.h>
+#include <plat/i2c.h>
+#include <plat/omap24xx.h>
 
 #include "omap_hwmod_common_data.h"
 
-#include "prm-regbits-24xx.h"
 #include "cm-regbits-24xx.h"
+#include "prm-regbits-24xx.h"
 
 /*
  * OMAP2420 hardware module integration data
@@ -77,6 +79,8 @@ static struct omap_hwmod omap2420_l4_wkup_hwmod;
 static struct omap_hwmod omap2420_uart1_hwmod;
 static struct omap_hwmod omap2420_uart2_hwmod;
 static struct omap_hwmod omap2420_uart3_hwmod;
+static struct omap_hwmod omap2420_i2c1_hwmod;
+static struct omap_hwmod omap2420_i2c2_hwmod;
 
 /* L4_CORE -> L4_WKUP interface */
 static struct omap_hwmod_ocp_if omap2420_l4_core__l4_wkup = {
@@ -139,6 +143,45 @@ static struct omap_hwmod_ocp_if omap2_l4_core__uart3 = {
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
+/* I2C IP block address space length (in bytes) */
+#define OMAP2_I2C_AS_LEN		128
+
+/* L4 CORE -> I2C1 interface */
+static struct omap_hwmod_addr_space omap2420_i2c1_addr_space[] = {
+	{
+		.pa_start	= 0x48070000,
+		.pa_end		= 0x48070000 + OMAP2_I2C_AS_LEN - 1,
+		.flags		= ADDR_TYPE_RT,
+	},
+};
+
+static struct omap_hwmod_ocp_if omap2420_l4_core__i2c1 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_i2c1_hwmod,
+	.clk		= "i2c1_ick",
+	.addr		= omap2420_i2c1_addr_space,
+	.addr_cnt	= ARRAY_SIZE(omap2420_i2c1_addr_space),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* L4 CORE -> I2C2 interface */
+static struct omap_hwmod_addr_space omap2420_i2c2_addr_space[] = {
+	{
+		.pa_start	= 0x48072000,
+		.pa_end		= 0x48072000 + OMAP2_I2C_AS_LEN - 1,
+		.flags		= ADDR_TYPE_RT,
+	},
+};
+
+static struct omap_hwmod_ocp_if omap2420_l4_core__i2c2 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_i2c2_hwmod,
+	.clk		= "i2c2_ick",
+	.addr		= omap2420_i2c2_addr_space,
+	.addr_cnt	= ARRAY_SIZE(omap2420_i2c2_addr_space),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
 /* Slave interfaces on the L4_CORE interconnect */
 static struct omap_hwmod_ocp_if *omap2420_l4_core_slaves[] = {
 	&omap2420_l3_main__l4_core,
@@ -150,6 +193,8 @@ static struct omap_hwmod_ocp_if *omap2420_l4_core_masters[] = {
 	&omap2_l4_core__uart1,
 	&omap2_l4_core__uart2,
 	&omap2_l4_core__uart3,
+	&omap2420_l4_core__i2c1,
+	&omap2420_l4_core__i2c2
 };
 
 /* L4 CORE */
@@ -418,6 +463,100 @@ static struct omap_hwmod omap2420_uart3_hwmod = {
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
+/* I2C common */
+static struct omap_hwmod_class_sysconfig i2c_sysc = {
+	.rev_offs	= 0x00,
+	.sysc_offs	= 0x20,
+	.syss_offs	= 0x10,
+	.sysc_flags	= SYSC_HAS_SOFTRESET,
+	.sysc_fields	= &omap_hwmod_sysc_type1,
+};
+
+static struct omap_hwmod_class i2c_class = {
+	.name		= "i2c",
+	.sysc		= &i2c_sysc,
+};
+
+static struct omap_i2c_dev_attr i2c_dev_attr;
+
+/* I2C1 */
+
+static struct omap_hwmod_irq_info i2c1_mpu_irqs[] = {
+	{ .irq = INT_24XX_I2C1_IRQ, },
+};
+
+static struct omap_hwmod_dma_info i2c1_sdma_reqs[] = {
+	{ .name = "tx", .dma_req = OMAP24XX_DMA_I2C1_TX },
+	{ .name = "rx", .dma_req = OMAP24XX_DMA_I2C1_RX },
+};
+
+static struct omap_hwmod_ocp_if *omap2420_i2c1_slaves[] = {
+	&omap2420_l4_core__i2c1,
+};
+
+static struct omap_hwmod omap2420_i2c1_hwmod = {
+	.name		= "i2c1",
+	.mpu_irqs	= i2c1_mpu_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(i2c1_mpu_irqs),
+	.sdma_reqs	= i2c1_sdma_reqs,
+	.sdma_reqs_cnt	= ARRAY_SIZE(i2c1_sdma_reqs),
+	.main_clk	= "i2c1_fck",
+	.prcm		= {
+		.omap2 = {
+			.module_offs = CORE_MOD,
+			.prcm_reg_id = 1,
+			.module_bit = OMAP2420_EN_I2C1_SHIFT,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP2420_ST_I2C1_SHIFT,
+		},
+	},
+	.slaves		= omap2420_i2c1_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_i2c1_slaves),
+	.class		= &i2c_class,
+	.dev_attr	= &i2c_dev_attr,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+	.flags		= HWMOD_16BIT_REG,
+};
+
+/* I2C2 */
+
+static struct omap_hwmod_irq_info i2c2_mpu_irqs[] = {
+	{ .irq = INT_24XX_I2C2_IRQ, },
+};
+
+static struct omap_hwmod_dma_info i2c2_sdma_reqs[] = {
+	{ .name = "tx", .dma_req = OMAP24XX_DMA_I2C2_TX },
+	{ .name = "rx", .dma_req = OMAP24XX_DMA_I2C2_RX },
+};
+
+static struct omap_hwmod_ocp_if *omap2420_i2c2_slaves[] = {
+	&omap2420_l4_core__i2c2,
+};
+
+static struct omap_hwmod omap2420_i2c2_hwmod = {
+	.name		= "i2c2",
+	.mpu_irqs	= i2c2_mpu_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(i2c2_mpu_irqs),
+	.sdma_reqs	= i2c2_sdma_reqs,
+	.sdma_reqs_cnt	= ARRAY_SIZE(i2c2_sdma_reqs),
+	.main_clk	= "i2c2_fck",
+	.prcm		= {
+		.omap2 = {
+			.module_offs = CORE_MOD,
+			.prcm_reg_id = 1,
+			.module_bit = OMAP2420_EN_I2C2_SHIFT,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP2420_ST_I2C2_SHIFT,
+		},
+	},
+	.slaves		= omap2420_i2c2_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_i2c2_slaves),
+	.class		= &i2c_class,
+	.dev_attr	= &i2c_dev_attr,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+	.flags		= HWMOD_16BIT_REG,
+};
+
 static __initdata struct omap_hwmod *omap2420_hwmods[] = {
 	&omap2420_l3_main_hwmod,
 	&omap2420_l4_core_hwmod,
@@ -428,6 +567,8 @@ static __initdata struct omap_hwmod *omap2420_hwmods[] = {
 	&omap2420_uart1_hwmod,
 	&omap2420_uart2_hwmod,
 	&omap2420_uart3_hwmod,
+	&omap2420_i2c1_hwmod,
+	&omap2420_i2c2_hwmod,
 	NULL,
 };
 
@@ -435,5 +576,3 @@ int __init omap2420_hwmod_init(void)
 {
 	return omap_hwmod_init(omap2420_hwmods);
 }
-
-

commit 69758ab7a1e2de5636a2188d5357dd03140bf1d8
Merge: 963bfb093923 257f23d87f93
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Fri Oct 1 13:24:10 2010 -0700

    manual merge for pm-hwmod-uart due to conflicts

commit 046465b76a41a32a8d56e691b167fb9ba7729970
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Mon Sep 27 20:19:30 2010 +0530

    OMAP2/3: UART: add omap_hwmod data for UARTs 1-4
    
    This patch adds omap_hwmod data for UARTs on OMAP2 and OMAP3
    platforms.
    
    UART4 support for 3630 and OMAP2 hwmod data added by Govindraj R.
    
    Signed-off-by: Govindraj.R <govindraj.raja@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 3cc768e8bc04..ba145f7d5896 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -15,6 +15,7 @@
 #include <mach/irqs.h>
 #include <plat/cpu.h>
 #include <plat/dma.h>
+#include <plat/serial.h>
 
 #include "omap_hwmod_common_data.h"
 
@@ -71,6 +72,9 @@ static struct omap_hwmod omap2420_l3_main_hwmod = {
 };
 
 static struct omap_hwmod omap2420_l4_wkup_hwmod;
+static struct omap_hwmod omap2420_uart1_hwmod;
+static struct omap_hwmod omap2420_uart2_hwmod;
+static struct omap_hwmod omap2420_uart3_hwmod;
 
 /* L4_CORE -> L4_WKUP interface */
 static struct omap_hwmod_ocp_if omap2420_l4_core__l4_wkup = {
@@ -79,6 +83,60 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__l4_wkup = {
 	.user	= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
+/* L4 CORE -> UART1 interface */
+static struct omap_hwmod_addr_space omap2420_uart1_addr_space[] = {
+	{
+		.pa_start	= OMAP2_UART1_BASE,
+		.pa_end		= OMAP2_UART1_BASE + SZ_8K - 1,
+		.flags		= ADDR_MAP_ON_INIT | ADDR_TYPE_RT,
+	},
+};
+
+static struct omap_hwmod_ocp_if omap2_l4_core__uart1 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_uart1_hwmod,
+	.clk		= "uart1_ick",
+	.addr		= omap2420_uart1_addr_space,
+	.addr_cnt	= ARRAY_SIZE(omap2420_uart1_addr_space),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* L4 CORE -> UART2 interface */
+static struct omap_hwmod_addr_space omap2420_uart2_addr_space[] = {
+	{
+		.pa_start	= OMAP2_UART2_BASE,
+		.pa_end		= OMAP2_UART2_BASE + SZ_1K - 1,
+		.flags		= ADDR_MAP_ON_INIT | ADDR_TYPE_RT,
+	},
+};
+
+static struct omap_hwmod_ocp_if omap2_l4_core__uart2 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_uart2_hwmod,
+	.clk		= "uart2_ick",
+	.addr		= omap2420_uart2_addr_space,
+	.addr_cnt	= ARRAY_SIZE(omap2420_uart2_addr_space),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* L4 PER -> UART3 interface */
+static struct omap_hwmod_addr_space omap2420_uart3_addr_space[] = {
+	{
+		.pa_start	= OMAP2_UART3_BASE,
+		.pa_end		= OMAP2_UART3_BASE + SZ_1K - 1,
+		.flags		= ADDR_MAP_ON_INIT | ADDR_TYPE_RT,
+	},
+};
+
+static struct omap_hwmod_ocp_if omap2_l4_core__uart3 = {
+	.master		= &omap2420_l4_core_hwmod,
+	.slave		= &omap2420_uart3_hwmod,
+	.clk		= "uart3_ick",
+	.addr		= omap2420_uart3_addr_space,
+	.addr_cnt	= ARRAY_SIZE(omap2420_uart3_addr_space),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
 /* Slave interfaces on the L4_CORE interconnect */
 static struct omap_hwmod_ocp_if *omap2420_l4_core_slaves[] = {
 	&omap2420_l3_main__l4_core,
@@ -87,6 +145,9 @@ static struct omap_hwmod_ocp_if *omap2420_l4_core_slaves[] = {
 /* Master interfaces on the L4_CORE interconnect */
 static struct omap_hwmod_ocp_if *omap2420_l4_core_masters[] = {
 	&omap2420_l4_core__l4_wkup,
+	&omap2_l4_core__uart1,
+	&omap2_l4_core__uart2,
+	&omap2_l4_core__uart3,
 };
 
 /* L4 CORE */
@@ -165,12 +226,144 @@ static struct omap_hwmod omap2420_iva_hwmod = {
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
+/* UART */
+
+static struct omap_hwmod_class_sysconfig uart_sysc = {
+	.rev_offs	= 0x50,
+	.sysc_offs	= 0x54,
+	.syss_offs	= 0x58,
+	.sysc_flags	= (SYSC_HAS_SIDLEMODE |
+			   SYSC_HAS_ENAWAKEUP | SYSC_HAS_SOFTRESET |
+			   SYSC_HAS_AUTOIDLE),
+	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
+	.sysc_fields    = &omap_hwmod_sysc_type1,
+};
+
+static struct omap_hwmod_class uart_class = {
+	.name = "uart",
+	.sysc = &uart_sysc,
+};
+
+/* UART1 */
+
+static struct omap_hwmod_irq_info uart1_mpu_irqs[] = {
+	{ .irq = INT_24XX_UART1_IRQ, },
+};
+
+static struct omap_hwmod_dma_info uart1_sdma_reqs[] = {
+	{ .name = "rx",	.dma_req = OMAP24XX_DMA_UART1_RX, },
+	{ .name = "tx",	.dma_req = OMAP24XX_DMA_UART1_TX, },
+};
+
+static struct omap_hwmod_ocp_if *omap2420_uart1_slaves[] = {
+	&omap2_l4_core__uart1,
+};
+
+static struct omap_hwmod omap2420_uart1_hwmod = {
+	.name		= "uart1",
+	.mpu_irqs	= uart1_mpu_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(uart1_mpu_irqs),
+	.sdma_reqs	= uart1_sdma_reqs,
+	.sdma_reqs_cnt	= ARRAY_SIZE(uart1_sdma_reqs),
+	.main_clk	= "uart1_fck",
+	.prcm		= {
+		.omap2 = {
+			.module_offs = CORE_MOD,
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_UART1_SHIFT,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_EN_UART1_SHIFT,
+		},
+	},
+	.slaves		= omap2420_uart1_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_uart1_slaves),
+	.class		= &uart_class,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+};
+
+/* UART2 */
+
+static struct omap_hwmod_irq_info uart2_mpu_irqs[] = {
+	{ .irq = INT_24XX_UART2_IRQ, },
+};
+
+static struct omap_hwmod_dma_info uart2_sdma_reqs[] = {
+	{ .name = "rx",	.dma_req = OMAP24XX_DMA_UART2_RX, },
+	{ .name = "tx",	.dma_req = OMAP24XX_DMA_UART2_TX, },
+};
+
+static struct omap_hwmod_ocp_if *omap2420_uart2_slaves[] = {
+	&omap2_l4_core__uart2,
+};
+
+static struct omap_hwmod omap2420_uart2_hwmod = {
+	.name		= "uart2",
+	.mpu_irqs	= uart2_mpu_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(uart2_mpu_irqs),
+	.sdma_reqs	= uart2_sdma_reqs,
+	.sdma_reqs_cnt	= ARRAY_SIZE(uart2_sdma_reqs),
+	.main_clk	= "uart2_fck",
+	.prcm		= {
+		.omap2 = {
+			.module_offs = CORE_MOD,
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_UART2_SHIFT,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_EN_UART2_SHIFT,
+		},
+	},
+	.slaves		= omap2420_uart2_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_uart2_slaves),
+	.class		= &uart_class,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+};
+
+/* UART3 */
+
+static struct omap_hwmod_irq_info uart3_mpu_irqs[] = {
+	{ .irq = INT_24XX_UART3_IRQ, },
+};
+
+static struct omap_hwmod_dma_info uart3_sdma_reqs[] = {
+	{ .name = "rx",	.dma_req = OMAP24XX_DMA_UART3_RX, },
+	{ .name = "tx",	.dma_req = OMAP24XX_DMA_UART3_TX, },
+};
+
+static struct omap_hwmod_ocp_if *omap2420_uart3_slaves[] = {
+	&omap2_l4_core__uart3,
+};
+
+static struct omap_hwmod omap2420_uart3_hwmod = {
+	.name		= "uart3",
+	.mpu_irqs	= uart3_mpu_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(uart3_mpu_irqs),
+	.sdma_reqs	= uart3_sdma_reqs,
+	.sdma_reqs_cnt	= ARRAY_SIZE(uart3_sdma_reqs),
+	.main_clk	= "uart3_fck",
+	.prcm		= {
+		.omap2 = {
+			.module_offs = CORE_MOD,
+			.prcm_reg_id = 2,
+			.module_bit = OMAP24XX_EN_UART3_SHIFT,
+			.idlest_reg_id = 2,
+			.idlest_idle_bit = OMAP24XX_EN_UART3_SHIFT,
+		},
+	},
+	.slaves		= omap2420_uart3_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_uart3_slaves),
+	.class		= &uart_class,
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+};
+
 static __initdata struct omap_hwmod *omap2420_hwmods[] = {
 	&omap2420_l3_main_hwmod,
 	&omap2420_l4_core_hwmod,
 	&omap2420_l4_wkup_hwmod,
 	&omap2420_mpu_hwmod,
 	&omap2420_iva_hwmod,
+	&omap2420_uart1_hwmod,
+	&omap2420_uart2_hwmod,
+	&omap2420_uart3_hwmod,
 	NULL,
 };
 

commit a714b9cfabcc385540a493733bd4958d37e982d3
Author: Varadarajan, Charulatha <charu@ti.com>
Date:   Thu Sep 23 20:02:39 2010 +0530

    OMAP2420: hwmod data: Add watchdog timer
    
    Add watchdog timer hwmod data for OMAP2420 chip
    
    Signed-off-by: Charulatha V <charu@ti.com>
    Acked-by: Cousson, Benoit <b-cousson@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 3cc768e8bc04..66678d98ad96 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -19,6 +19,7 @@
 #include "omap_hwmod_common_data.h"
 
 #include "prm-regbits-24xx.h"
+#include "cm-regbits-24xx.h"
 
 /*
  * OMAP2420 hardware module integration data
@@ -33,6 +34,7 @@ static struct omap_hwmod omap2420_mpu_hwmod;
 static struct omap_hwmod omap2420_iva_hwmod;
 static struct omap_hwmod omap2420_l3_main_hwmod;
 static struct omap_hwmod omap2420_l4_core_hwmod;
+static struct omap_hwmod omap2420_wd_timer2_hwmod;
 
 /* L3 -> L4_CORE interface */
 static struct omap_hwmod_ocp_if omap2420_l3_main__l4_core = {
@@ -165,12 +167,74 @@ static struct omap_hwmod omap2420_iva_hwmod = {
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
 };
 
+/* l4_wkup -> wd_timer2 */
+static struct omap_hwmod_addr_space omap2420_wd_timer2_addrs[] = {
+	{
+		.pa_start	= 0x48022000,
+		.pa_end		= 0x4802207f,
+		.flags		= ADDR_TYPE_RT
+	},
+};
+
+static struct omap_hwmod_ocp_if omap2420_l4_wkup__wd_timer2 = {
+	.master		= &omap2420_l4_wkup_hwmod,
+	.slave		= &omap2420_wd_timer2_hwmod,
+	.clk		= "mpu_wdt_ick",
+	.addr		= omap2420_wd_timer2_addrs,
+	.addr_cnt	= ARRAY_SIZE(omap2420_wd_timer2_addrs),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/*
+ * 'wd_timer' class
+ * 32-bit watchdog upward counter that generates a pulse on the reset pin on
+ * overflow condition
+ */
+
+static struct omap_hwmod_class_sysconfig omap2420_wd_timer_sysc = {
+	.rev_offs	= 0x0000,
+	.sysc_offs	= 0x0010,
+	.syss_offs	= 0x0014,
+	.sysc_flags	= (SYSC_HAS_EMUFREE | SYSC_HAS_SOFTRESET |
+			   SYSC_HAS_AUTOIDLE),
+	.sysc_fields    = &omap_hwmod_sysc_type1,
+};
+
+static struct omap_hwmod_class omap2420_wd_timer_hwmod_class = {
+	.name = "wd_timer",
+	.sysc = &omap2420_wd_timer_sysc,
+};
+
+/* wd_timer2 */
+static struct omap_hwmod_ocp_if *omap2420_wd_timer2_slaves[] = {
+	&omap2420_l4_wkup__wd_timer2,
+};
+
+static struct omap_hwmod omap2420_wd_timer2_hwmod = {
+	.name		= "wd_timer2",
+	.class		= &omap2420_wd_timer_hwmod_class,
+	.main_clk	= "mpu_wdt_fck",
+	.prcm		= {
+		.omap2 = {
+			.prcm_reg_id = 1,
+			.module_bit = OMAP24XX_EN_MPU_WDT_SHIFT,
+			.module_offs = WKUP_MOD,
+			.idlest_reg_id = 1,
+			.idlest_idle_bit = OMAP24XX_ST_MPU_WDT_SHIFT,
+		},
+	},
+	.slaves		= omap2420_wd_timer2_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_wd_timer2_slaves),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+};
+
 static __initdata struct omap_hwmod *omap2420_hwmods[] = {
 	&omap2420_l3_main_hwmod,
 	&omap2420_l4_core_hwmod,
 	&omap2420_l4_wkup_hwmod,
 	&omap2420_mpu_hwmod,
 	&omap2420_iva_hwmod,
+	&omap2420_wd_timer2_hwmod,
 	NULL,
 };
 

commit 08072acf3a23febd1b676f1d908c6c0b9ddf167c
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Jul 26 16:34:33 2010 -0600

    OMAP2: hwmod data: add IVA1 (2420), IVA2 (2430) hwmods
    
    Add IVA1 hwmod data for OMAP2420 and IVA2 hwmod data for 2430.  The data
    is based on Beno√Æt Cousson's hwmod data for the OMAP3 IVA blocks.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Beno√Æt Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 8c90b27db2e7..3cc768e8bc04 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -30,6 +30,7 @@
  */
 
 static struct omap_hwmod omap2420_mpu_hwmod;
+static struct omap_hwmod omap2420_iva_hwmod;
 static struct omap_hwmod omap2420_l3_main_hwmod;
 static struct omap_hwmod omap2420_l4_core_hwmod;
 
@@ -136,11 +137,40 @@ static struct omap_hwmod omap2420_mpu_hwmod = {
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 };
 
+/*
+ * IVA1 interface data
+ */
+
+/* IVA <- L3 interface */
+static struct omap_hwmod_ocp_if omap2420_l3__iva = {
+	.master		= &omap2420_l3_main_hwmod,
+	.slave		= &omap2420_iva_hwmod,
+	.clk		= "iva1_ifck",
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+static struct omap_hwmod_ocp_if *omap2420_iva_masters[] = {
+	&omap2420_l3__iva,
+};
+
+/*
+ * IVA2 (IVA2)
+ */
+
+static struct omap_hwmod omap2420_iva_hwmod = {
+	.name		= "iva",
+	.class		= &iva_hwmod_class,
+	.masters	= omap2420_iva_masters,
+	.masters_cnt	= ARRAY_SIZE(omap2420_iva_masters),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
+};
+
 static __initdata struct omap_hwmod *omap2420_hwmods[] = {
 	&omap2420_l3_main_hwmod,
 	&omap2420_l4_core_hwmod,
 	&omap2420_l4_wkup_hwmod,
 	&omap2420_mpu_hwmod,
+	&omap2420_iva_hwmod,
 	NULL,
 };
 

commit 4a7cf90a01a642969e61879337f6524dbdde05c2
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Mon Jul 26 16:34:32 2010 -0600

    OMAP2&3: hwmod: Replace l3 -> l3_main
    
    Replace all the struct that contain l3 with l3_main in order
    to be consistent with the OMAP4 naming convention.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index 646386cf8679..8c90b27db2e7 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -30,41 +30,41 @@
  */
 
 static struct omap_hwmod omap2420_mpu_hwmod;
-static struct omap_hwmod omap2420_l3_hwmod;
+static struct omap_hwmod omap2420_l3_main_hwmod;
 static struct omap_hwmod omap2420_l4_core_hwmod;
 
 /* L3 -> L4_CORE interface */
-static struct omap_hwmod_ocp_if omap2420_l3__l4_core = {
-	.master	= &omap2420_l3_hwmod,
+static struct omap_hwmod_ocp_if omap2420_l3_main__l4_core = {
+	.master	= &omap2420_l3_main_hwmod,
 	.slave	= &omap2420_l4_core_hwmod,
 	.user	= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
 /* MPU -> L3 interface */
-static struct omap_hwmod_ocp_if omap2420_mpu__l3 = {
+static struct omap_hwmod_ocp_if omap2420_mpu__l3_main = {
 	.master = &omap2420_mpu_hwmod,
-	.slave	= &omap2420_l3_hwmod,
+	.slave	= &omap2420_l3_main_hwmod,
 	.user	= OCP_USER_MPU,
 };
 
 /* Slave interfaces on the L3 interconnect */
-static struct omap_hwmod_ocp_if *omap2420_l3_slaves[] = {
-	&omap2420_mpu__l3,
+static struct omap_hwmod_ocp_if *omap2420_l3_main_slaves[] = {
+	&omap2420_mpu__l3_main,
 };
 
 /* Master interfaces on the L3 interconnect */
-static struct omap_hwmod_ocp_if *omap2420_l3_masters[] = {
-	&omap2420_l3__l4_core,
+static struct omap_hwmod_ocp_if *omap2420_l3_main_masters[] = {
+	&omap2420_l3_main__l4_core,
 };
 
 /* L3 */
-static struct omap_hwmod omap2420_l3_hwmod = {
+static struct omap_hwmod omap2420_l3_main_hwmod = {
 	.name		= "l3_main",
 	.class		= &l3_hwmod_class,
-	.masters	= omap2420_l3_masters,
-	.masters_cnt	= ARRAY_SIZE(omap2420_l3_masters),
-	.slaves		= omap2420_l3_slaves,
-	.slaves_cnt	= ARRAY_SIZE(omap2420_l3_slaves),
+	.masters	= omap2420_l3_main_masters,
+	.masters_cnt	= ARRAY_SIZE(omap2420_l3_main_masters),
+	.slaves		= omap2420_l3_main_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_l3_main_slaves),
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
 	.flags		= HWMOD_NO_IDLEST,
 };
@@ -80,7 +80,7 @@ static struct omap_hwmod_ocp_if omap2420_l4_core__l4_wkup = {
 
 /* Slave interfaces on the L4_CORE interconnect */
 static struct omap_hwmod_ocp_if *omap2420_l4_core_slaves[] = {
-	&omap2420_l3__l4_core,
+	&omap2420_l3_main__l4_core,
 };
 
 /* Master interfaces on the L4_CORE interconnect */
@@ -123,7 +123,7 @@ static struct omap_hwmod omap2420_l4_wkup_hwmod = {
 
 /* Master interfaces on the MPU device */
 static struct omap_hwmod_ocp_if *omap2420_mpu_masters[] = {
-	&omap2420_mpu__l3,
+	&omap2420_mpu__l3_main,
 };
 
 /* MPU */
@@ -137,7 +137,7 @@ static struct omap_hwmod omap2420_mpu_hwmod = {
 };
 
 static __initdata struct omap_hwmod *omap2420_hwmods[] = {
-	&omap2420_l3_hwmod,
+	&omap2420_l3_main_hwmod,
 	&omap2420_l4_core_hwmod,
 	&omap2420_l4_wkup_hwmod,
 	&omap2420_mpu_hwmod,

commit fa98347ebf1c516e49694e1584cd96a63428676a
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Mon Jul 26 16:34:29 2010 -0600

    OMAP2&3: hwmod: Remove _hwmod prefix in name string
    
    In the lastest OMAP4 hwmod data file, the _hwmod was removed
    in order to save some memory space and because it does not
    bring a lot.
    Align OMAP2420, 2430 and 3430 data files with the same convention.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Acked-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index a8b57a648c7d..646386cf8679 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -59,7 +59,7 @@ static struct omap_hwmod_ocp_if *omap2420_l3_masters[] = {
 
 /* L3 */
 static struct omap_hwmod omap2420_l3_hwmod = {
-	.name		= "l3_hwmod",
+	.name		= "l3_main",
 	.class		= &l3_hwmod_class,
 	.masters	= omap2420_l3_masters,
 	.masters_cnt	= ARRAY_SIZE(omap2420_l3_masters),
@@ -90,7 +90,7 @@ static struct omap_hwmod_ocp_if *omap2420_l4_core_masters[] = {
 
 /* L4 CORE */
 static struct omap_hwmod omap2420_l4_core_hwmod = {
-	.name		= "l4_core_hwmod",
+	.name		= "l4_core",
 	.class		= &l4_hwmod_class,
 	.masters	= omap2420_l4_core_masters,
 	.masters_cnt	= ARRAY_SIZE(omap2420_l4_core_masters),
@@ -111,7 +111,7 @@ static struct omap_hwmod_ocp_if *omap2420_l4_wkup_masters[] = {
 
 /* L4 WKUP */
 static struct omap_hwmod omap2420_l4_wkup_hwmod = {
-	.name		= "l4_wkup_hwmod",
+	.name		= "l4_wkup",
 	.class		= &l4_hwmod_class,
 	.masters	= omap2420_l4_wkup_masters,
 	.masters_cnt	= ARRAY_SIZE(omap2420_l4_wkup_masters),

commit 2eb1875d2b7560e70c19a11daa00e06e0de9eea1
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Mon Jul 26 16:34:28 2010 -0600

    OMAP2/3: hwmod: L3 and L4 CORE/PER/WKUP hwmods don't have IDLEST
    
    Since these hwmods do not have IDLEST, set the HWMOD_NO_IDLEST flag,
    otherwise _enable() will fail due to failing _wait_target_ready().
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index e5530c51f77d..a8b57a648c7d 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -65,7 +65,8 @@ static struct omap_hwmod omap2420_l3_hwmod = {
 	.masters_cnt	= ARRAY_SIZE(omap2420_l3_masters),
 	.slaves		= omap2420_l3_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_l3_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+	.flags		= HWMOD_NO_IDLEST,
 };
 
 static struct omap_hwmod omap2420_l4_wkup_hwmod;
@@ -95,7 +96,8 @@ static struct omap_hwmod omap2420_l4_core_hwmod = {
 	.masters_cnt	= ARRAY_SIZE(omap2420_l4_core_masters),
 	.slaves		= omap2420_l4_core_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_l4_core_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+	.flags		= HWMOD_NO_IDLEST,
 };
 
 /* Slave interfaces on the L4_WKUP interconnect */
@@ -115,7 +117,8 @@ static struct omap_hwmod omap2420_l4_wkup_hwmod = {
 	.masters_cnt	= ARRAY_SIZE(omap2420_l4_wkup_masters),
 	.slaves		= omap2420_l4_wkup_slaves,
 	.slaves_cnt	= ARRAY_SIZE(omap2420_l4_wkup_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+	.flags		= HWMOD_NO_IDLEST,
 };
 
 /* Master interfaces on the MPU device */

commit 5c2c02961ea39d7bbe4d87f362ab3173a424794b
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Thu May 20 12:31:10 2010 -0600

    OMAP: hwmod: Rename hwmod name for the MPU
    
    In the lastest OMAP4 hwmod data file, the _hwmod was removed
    in order to save some memory space and because it does not
    bring a lot.
    
    The same cleanup will be have to done for other hwmods in
    OMAP2 & 3 data files.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Rajendra Nayak <rnayak@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index eb7ee2453b24..e5530c51f77d 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -125,7 +125,7 @@ static struct omap_hwmod_ocp_if *omap2420_mpu_masters[] = {
 
 /* MPU */
 static struct omap_hwmod omap2420_mpu_hwmod = {
-	.name		= "mpu_hwmod",
+	.name		= "mpu",
 	.class		= &mpu_hwmod_class,
 	.main_clk	= "mpu_ck",
 	.masters	= omap2420_mpu_masters,

commit 43b40992ce21def8d5957f32d7ddb728af89bfce
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Feb 22 22:09:34 2010 -0700

    OMAP hwmod: add hwmod class support
    
    Add support for categorizing and iterating over hardware IP blocks by
    the "class" of the IP block.  The class is the type of the IP block:
    e.g., "timer", "timer1ms", etc.  Move the OCP_SYSCONFIG/SYSSTATUS data
    from the struct omap_hwmod into the struct omap_hwmod_class, since
    it's expected to stay consistent for each class.  While here, fix some
    comments.
    
    The hwmod_class structures in this patch were designed and proposed by
    Beno√Æt Cousson <b-cousson@ti.com> and were refined in a discussion
    between Thara Gopinath <thara@ti.com>, Kevin Hilman
    <khilman@deeprootsystems.com>, and myself.
    
    This patch uses WARN() lines that are longer than 80 characters, as
    Kevin noted a broader lkml consensus to increase greppability by
    keeping the messages all on one line.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Beno√Æt Cousson <b-cousson@ti.com>
    Cc: Thara Gopinath <thara@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
index a1c5839fc52d..eb7ee2453b24 100644
--- a/arch/arm/mach-omap2/omap_hwmod_2420_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -16,6 +16,8 @@
 #include <plat/cpu.h>
 #include <plat/dma.h>
 
+#include "omap_hwmod_common_data.h"
+
 #include "prm-regbits-24xx.h"
 
 /*
@@ -58,6 +60,7 @@ static struct omap_hwmod_ocp_if *omap2420_l3_masters[] = {
 /* L3 */
 static struct omap_hwmod omap2420_l3_hwmod = {
 	.name		= "l3_hwmod",
+	.class		= &l3_hwmod_class,
 	.masters	= omap2420_l3_masters,
 	.masters_cnt	= ARRAY_SIZE(omap2420_l3_masters),
 	.slaves		= omap2420_l3_slaves,
@@ -87,6 +90,7 @@ static struct omap_hwmod_ocp_if *omap2420_l4_core_masters[] = {
 /* L4 CORE */
 static struct omap_hwmod omap2420_l4_core_hwmod = {
 	.name		= "l4_core_hwmod",
+	.class		= &l4_hwmod_class,
 	.masters	= omap2420_l4_core_masters,
 	.masters_cnt	= ARRAY_SIZE(omap2420_l4_core_masters),
 	.slaves		= omap2420_l4_core_slaves,
@@ -106,6 +110,7 @@ static struct omap_hwmod_ocp_if *omap2420_l4_wkup_masters[] = {
 /* L4 WKUP */
 static struct omap_hwmod omap2420_l4_wkup_hwmod = {
 	.name		= "l4_wkup_hwmod",
+	.class		= &l4_hwmod_class,
 	.masters	= omap2420_l4_wkup_masters,
 	.masters_cnt	= ARRAY_SIZE(omap2420_l4_wkup_masters),
 	.slaves		= omap2420_l4_wkup_slaves,
@@ -121,6 +126,7 @@ static struct omap_hwmod_ocp_if *omap2420_mpu_masters[] = {
 /* MPU */
 static struct omap_hwmod omap2420_mpu_hwmod = {
 	.name		= "mpu_hwmod",
+	.class		= &mpu_hwmod_class,
 	.main_clk	= "mpu_ck",
 	.masters	= omap2420_mpu_masters,
 	.masters_cnt	= ARRAY_SIZE(omap2420_mpu_masters),

commit 7359154e94623f6a5a68a77b9fcfbef40633c93f
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Feb 22 22:09:32 2010 -0700

    OMAP hwmod: convert header files with static allocations into C files
    
    Code should be able to #include any header file without the fear that
    the header file will go allocating memory.  This is a coding style
    issue, similar to commit 82e9bd588563c4e22ebb55b684ebec7e310cc715.
    Move the existing hwmod data from .h files to .c files.
    
    While here, convert "omap34xx" to "omap3xxx" in the hwmod files, since
    most of these structures should be reusable across all OMAP3 chips.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Beno√Æt Cousson <b-cousson@ti.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod_2420_data.c b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
new file mode 100644
index 000000000000..a1c5839fc52d
--- /dev/null
+++ b/arch/arm/mach-omap2/omap_hwmod_2420_data.c
@@ -0,0 +1,143 @@
+/*
+ * omap_hwmod_2420_data.c - hardware modules present on the OMAP2420 chips
+ *
+ * Copyright (C) 2009-2010 Nokia Corporation
+ * Paul Walmsley
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * XXX handle crossbar/shared link difference for L3?
+ * XXX these should be marked initdata for multi-OMAP kernels
+ */
+#include <plat/omap_hwmod.h>
+#include <mach/irqs.h>
+#include <plat/cpu.h>
+#include <plat/dma.h>
+
+#include "prm-regbits-24xx.h"
+
+/*
+ * OMAP2420 hardware module integration data
+ *
+ * ALl of the data in this section should be autogeneratable from the
+ * TI hardware database or other technical documentation.  Data that
+ * is driver-specific or driver-kernel integration-specific belongs
+ * elsewhere.
+ */
+
+static struct omap_hwmod omap2420_mpu_hwmod;
+static struct omap_hwmod omap2420_l3_hwmod;
+static struct omap_hwmod omap2420_l4_core_hwmod;
+
+/* L3 -> L4_CORE interface */
+static struct omap_hwmod_ocp_if omap2420_l3__l4_core = {
+	.master	= &omap2420_l3_hwmod,
+	.slave	= &omap2420_l4_core_hwmod,
+	.user	= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* MPU -> L3 interface */
+static struct omap_hwmod_ocp_if omap2420_mpu__l3 = {
+	.master = &omap2420_mpu_hwmod,
+	.slave	= &omap2420_l3_hwmod,
+	.user	= OCP_USER_MPU,
+};
+
+/* Slave interfaces on the L3 interconnect */
+static struct omap_hwmod_ocp_if *omap2420_l3_slaves[] = {
+	&omap2420_mpu__l3,
+};
+
+/* Master interfaces on the L3 interconnect */
+static struct omap_hwmod_ocp_if *omap2420_l3_masters[] = {
+	&omap2420_l3__l4_core,
+};
+
+/* L3 */
+static struct omap_hwmod omap2420_l3_hwmod = {
+	.name		= "l3_hwmod",
+	.masters	= omap2420_l3_masters,
+	.masters_cnt	= ARRAY_SIZE(omap2420_l3_masters),
+	.slaves		= omap2420_l3_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_l3_slaves),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
+};
+
+static struct omap_hwmod omap2420_l4_wkup_hwmod;
+
+/* L4_CORE -> L4_WKUP interface */
+static struct omap_hwmod_ocp_if omap2420_l4_core__l4_wkup = {
+	.master	= &omap2420_l4_core_hwmod,
+	.slave	= &omap2420_l4_wkup_hwmod,
+	.user	= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* Slave interfaces on the L4_CORE interconnect */
+static struct omap_hwmod_ocp_if *omap2420_l4_core_slaves[] = {
+	&omap2420_l3__l4_core,
+};
+
+/* Master interfaces on the L4_CORE interconnect */
+static struct omap_hwmod_ocp_if *omap2420_l4_core_masters[] = {
+	&omap2420_l4_core__l4_wkup,
+};
+
+/* L4 CORE */
+static struct omap_hwmod omap2420_l4_core_hwmod = {
+	.name		= "l4_core_hwmod",
+	.masters	= omap2420_l4_core_masters,
+	.masters_cnt	= ARRAY_SIZE(omap2420_l4_core_masters),
+	.slaves		= omap2420_l4_core_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_l4_core_slaves),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
+};
+
+/* Slave interfaces on the L4_WKUP interconnect */
+static struct omap_hwmod_ocp_if *omap2420_l4_wkup_slaves[] = {
+	&omap2420_l4_core__l4_wkup,
+};
+
+/* Master interfaces on the L4_WKUP interconnect */
+static struct omap_hwmod_ocp_if *omap2420_l4_wkup_masters[] = {
+};
+
+/* L4 WKUP */
+static struct omap_hwmod omap2420_l4_wkup_hwmod = {
+	.name		= "l4_wkup_hwmod",
+	.masters	= omap2420_l4_wkup_masters,
+	.masters_cnt	= ARRAY_SIZE(omap2420_l4_wkup_masters),
+	.slaves		= omap2420_l4_wkup_slaves,
+	.slaves_cnt	= ARRAY_SIZE(omap2420_l4_wkup_slaves),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420)
+};
+
+/* Master interfaces on the MPU device */
+static struct omap_hwmod_ocp_if *omap2420_mpu_masters[] = {
+	&omap2420_mpu__l3,
+};
+
+/* MPU */
+static struct omap_hwmod omap2420_mpu_hwmod = {
+	.name		= "mpu_hwmod",
+	.main_clk	= "mpu_ck",
+	.masters	= omap2420_mpu_masters,
+	.masters_cnt	= ARRAY_SIZE(omap2420_mpu_masters),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP2420),
+};
+
+static __initdata struct omap_hwmod *omap2420_hwmods[] = {
+	&omap2420_l3_hwmod,
+	&omap2420_l4_core_hwmod,
+	&omap2420_l4_wkup_hwmod,
+	&omap2420_mpu_hwmod,
+	NULL,
+};
+
+int __init omap2420_hwmod_init(void)
+{
+	return omap_hwmod_init(omap2420_hwmods);
+}
+
+
