commit 87c59ca22b484a08cb3764a3f7f7315297bafc9b
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Tue Oct 8 13:33:36 2019 +0100

    ARM: OMAP2+: do not export am43xx_control functions
    
    Do not export am43xx_control_{save,restore}_context to avoid
    the foloowing warnings:
    
    arch/arm/mach-omap2/control.c:687:6: warning: symbol 'am43xx_control_save_context' was not declared. Should it be static?
    arch/arm/mach-omap2/control.c:701:6: warning: symbol 'am43xx_control_restore_context' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index c84b5e260617..73338cf80d76 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -684,7 +684,7 @@ static u32 am33xx_control_vals[ARRAY_SIZE(am43xx_control_reg_offsets)];
  *
  * Save the wkup domain registers
  */
-void am43xx_control_save_context(void)
+static void am43xx_control_save_context(void)
 {
 	int i;
 
@@ -698,7 +698,7 @@ void am43xx_control_save_context(void)
  *
  * Restore the wkup domain registers
  */
-void am43xx_control_restore_context(void)
+static void am43xx_control_restore_context(void)
 {
 	int i;
 

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 0bbfb20e193f..c84b5e260617 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * OMAP2/3 System Control Module register access
  *
@@ -5,10 +6,6 @@
  * Copyright (C) 2007 Nokia Corporation
  *
  * Written by Paul Walmsley
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 #undef DEBUG
 

commit 38c4b121b0fb6b3a861345bad8d4d3db621f1829
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue May 22 23:51:39 2018 +0530

    ARM: AM43XX: Add functions to save/restore am43xx control registers
    
    These registers are part of the wkup domain and are lost during RTC only
    suspend and also hibernation, so storing/restoring their state is
    necessary.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 180da403639e..0bbfb20e193f 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -17,6 +17,7 @@
 #include <linux/of_address.h>
 #include <linux/regmap.h>
 #include <linux/mfd/syscon.h>
+#include <linux/cpu_pm.h>
 
 #include "soc.h"
 #include "iomap.h"
@@ -621,6 +622,110 @@ void __init omap3_ctrl_init(void)
 }
 #endif /* CONFIG_ARCH_OMAP3 && CONFIG_PM */
 
+static unsigned long am43xx_control_reg_offsets[] = {
+	AM33XX_CONTROL_SYSCONFIG_OFFSET,
+	AM33XX_CONTROL_STATUS_OFFSET,
+	AM43XX_CONTROL_MPU_L2_CTRL_OFFSET,
+	AM33XX_CONTROL_CORE_SLDO_CTRL_OFFSET,
+	AM33XX_CONTROL_MPU_SLDO_CTRL_OFFSET,
+	AM33XX_CONTROL_CLK32KDIVRATIO_CTRL_OFFSET,
+	AM33XX_CONTROL_BANDGAP_CTRL_OFFSET,
+	AM33XX_CONTROL_BANDGAP_TRIM_OFFSET,
+	AM33XX_CONTROL_PLL_CLKINPULOW_CTRL_OFFSET,
+	AM33XX_CONTROL_MOSC_CTRL_OFFSET,
+	AM33XX_CONTROL_DEEPSLEEP_CTRL_OFFSET,
+	AM43XX_CONTROL_DISPLAY_PLL_SEL_OFFSET,
+	AM33XX_CONTROL_INIT_PRIORITY_0_OFFSET,
+	AM33XX_CONTROL_INIT_PRIORITY_1_OFFSET,
+	AM33XX_CONTROL_TPTC_CFG_OFFSET,
+	AM33XX_CONTROL_USB_CTRL0_OFFSET,
+	AM33XX_CONTROL_USB_CTRL1_OFFSET,
+	AM43XX_CONTROL_USB_CTRL2_OFFSET,
+	AM43XX_CONTROL_GMII_SEL_OFFSET,
+	AM43XX_CONTROL_MPUSS_CTRL_OFFSET,
+	AM43XX_CONTROL_TIMER_CASCADE_CTRL_OFFSET,
+	AM43XX_CONTROL_PWMSS_CTRL_OFFSET,
+	AM33XX_CONTROL_MREQPRIO_0_OFFSET,
+	AM33XX_CONTROL_MREQPRIO_1_OFFSET,
+	AM33XX_CONTROL_HW_EVENT_SEL_GRP1_OFFSET,
+	AM33XX_CONTROL_HW_EVENT_SEL_GRP2_OFFSET,
+	AM33XX_CONTROL_HW_EVENT_SEL_GRP3_OFFSET,
+	AM33XX_CONTROL_HW_EVENT_SEL_GRP4_OFFSET,
+	AM33XX_CONTROL_SMRT_CTRL_OFFSET,
+	AM33XX_CONTROL_MPUSS_HW_DEBUG_SEL_OFFSET,
+	AM43XX_CONTROL_CQDETECT_STS_OFFSET,
+	AM43XX_CONTROL_CQDETECT_STS2_OFFSET,
+	AM43XX_CONTROL_VTP_CTRL_OFFSET,
+	AM33XX_CONTROL_VREF_CTRL_OFFSET,
+	AM33XX_CONTROL_TPCC_EVT_MUX_0_3_OFFSET,
+	AM33XX_CONTROL_TPCC_EVT_MUX_4_7_OFFSET,
+	AM33XX_CONTROL_TPCC_EVT_MUX_8_11_OFFSET,
+	AM33XX_CONTROL_TPCC_EVT_MUX_12_15_OFFSET,
+	AM33XX_CONTROL_TPCC_EVT_MUX_16_19_OFFSET,
+	AM33XX_CONTROL_TPCC_EVT_MUX_20_23_OFFSET,
+	AM33XX_CONTROL_TPCC_EVT_MUX_24_27_OFFSET,
+	AM33XX_CONTROL_TPCC_EVT_MUX_28_31_OFFSET,
+	AM33XX_CONTROL_TPCC_EVT_MUX_32_35_OFFSET,
+	AM33XX_CONTROL_TPCC_EVT_MUX_36_39_OFFSET,
+	AM33XX_CONTROL_TPCC_EVT_MUX_40_43_OFFSET,
+	AM33XX_CONTROL_TPCC_EVT_MUX_44_47_OFFSET,
+	AM33XX_CONTROL_TPCC_EVT_MUX_48_51_OFFSET,
+	AM33XX_CONTROL_TPCC_EVT_MUX_52_55_OFFSET,
+	AM33XX_CONTROL_TPCC_EVT_MUX_56_59_OFFSET,
+	AM33XX_CONTROL_TPCC_EVT_MUX_60_63_OFFSET,
+	AM33XX_CONTROL_TIMER_EVT_CAPT_OFFSET,
+	AM33XX_CONTROL_ECAP_EVT_CAPT_OFFSET,
+	AM33XX_CONTROL_ADC_EVT_CAPT_OFFSET,
+	AM43XX_CONTROL_ADC1_EVT_CAPT_OFFSET,
+	AM33XX_CONTROL_RESET_ISO_OFFSET,
+};
+
+static u32 am33xx_control_vals[ARRAY_SIZE(am43xx_control_reg_offsets)];
+
+/**
+ * am43xx_control_save_context - Save the wakeup domain registers
+ *
+ * Save the wkup domain registers
+ */
+void am43xx_control_save_context(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(am43xx_control_reg_offsets); i++)
+		am33xx_control_vals[i] =
+				omap_ctrl_readl(am43xx_control_reg_offsets[i]);
+}
+
+/**
+ * am43xx_control_restore_context - Restore the wakeup domain registers
+ *
+ * Restore the wkup domain registers
+ */
+void am43xx_control_restore_context(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(am43xx_control_reg_offsets); i++)
+		omap_ctrl_writel(am33xx_control_vals[i],
+				 am43xx_control_reg_offsets[i]);
+}
+
+static int cpu_notifier(struct notifier_block *nb, unsigned long cmd, void *v)
+{
+	switch (cmd) {
+	case CPU_CLUSTER_PM_ENTER:
+		if (enable_off_mode)
+			am43xx_control_save_context();
+		break;
+	case CPU_CLUSTER_PM_EXIT:
+		if (enable_off_mode)
+			am43xx_control_restore_context();
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
 struct control_init_data {
 	int index;
 	void __iomem *mem;
@@ -699,6 +804,7 @@ int __init omap_control_init(void)
 	const struct omap_prcm_init_data *data;
 	int ret;
 	struct regmap *syscon;
+	static struct notifier_block nb;
 
 	for_each_matching_node_and_match(np, omap_scrm_dt_match_table, &match) {
 		data = match->data;
@@ -731,6 +837,12 @@ int __init omap_control_init(void)
 		}
 	}
 
+	/* Only AM43XX can lose ctrl registers context during rtc-ddr suspend */
+	if (soc_is_am43xx()) {
+		nb.notifier_call = cpu_notifier;
+		cpu_pm_register_notifier(&nb);
+	}
+
 	return 0;
 }
 

commit 5aa6d80624d54d8aefaed8a4798b7aaa56290ccc
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Mar 14 15:53:13 2018 +0200

    ARM: OMAP5: control: add support for control module wkup pad config
    
    Match the new compatible string in the control module driver. The base
    infra maps the required syscon ranges and clock registers if available.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 632adb2b7d03..180da403639e 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -636,6 +636,10 @@ static const struct control_init_data omap2_ctrl_data = {
 	.offset = -OMAP2_CONTROL_GENERAL,
 };
 
+static const struct control_init_data ctrl_aux_data = {
+	.index = TI_CLKM_CTRL_AUX,
+};
+
 static const struct of_device_id omap_scrm_dt_match_table[] = {
 	{ .compatible = "ti,am3-scm", .data = &ctrl_data },
 	{ .compatible = "ti,am4-scm", .data = &ctrl_data },
@@ -645,6 +649,7 @@ static const struct of_device_id omap_scrm_dt_match_table[] = {
 	{ .compatible = "ti,dm816-scrm", .data = &ctrl_data },
 	{ .compatible = "ti,omap4-scm-core", .data = &ctrl_data },
 	{ .compatible = "ti,omap5-scm-core", .data = &ctrl_data },
+	{ .compatible = "ti,omap5-scm-wkup-pad-conf", .data = &ctrl_aux_data },
 	{ .compatible = "ti,dra7-scm-core", .data = &ctrl_data },
 	{ }
 };

commit 04dfac09068766550e3173aac88ff70d70958050
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Mar 14 15:53:10 2018 +0200

    ARM: omap2+: control: add support for auxiliary control module instances
    
    Control module can have multiple instances in a system, each with separate
    address space and features. Add base support for these auxiliary instances,
    with support for syscon and clock mappings under them.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index bd8089ff929f..632adb2b7d03 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -623,6 +623,7 @@ void __init omap3_ctrl_init(void)
 
 struct control_init_data {
 	int index;
+	void __iomem *mem;
 	s16 offset;
 };
 
@@ -660,15 +661,21 @@ int __init omap2_control_base_init(void)
 	struct device_node *np;
 	const struct of_device_id *match;
 	struct control_init_data *data;
+	void __iomem *mem;
 
 	for_each_matching_node_and_match(np, omap_scrm_dt_match_table, &match) {
 		data = (struct control_init_data *)match->data;
 
-		omap2_ctrl_base = of_iomap(np, 0);
-		if (!omap2_ctrl_base)
+		mem = of_iomap(np, 0);
+		if (!mem)
 			return -ENOMEM;
 
-		omap2_ctrl_offset = data->offset;
+		if (data->index == TI_CLKM_CTRL) {
+			omap2_ctrl_base = mem;
+			omap2_ctrl_offset = data->offset;
+		}
+
+		data->mem = mem;
 	}
 
 	return 0;
@@ -713,7 +720,7 @@ int __init omap_control_init(void)
 		} else {
 			/* No scm_conf found, direct access */
 			ret = omap2_clk_provider_init(np, data->index, NULL,
-						      omap2_ctrl_base);
+						      data->mem);
 			if (ret)
 				return ret;
 		}

commit 64fc2a947a9873700929ec0ef02b4654a04e0476
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sun Jan 15 03:59:29 2017 +0100

    ARM: 8641/1: treewide: Replace uses of virt_to_phys with __pa_symbol
    
    All low-level PM/SMP code using virt_to_phys() should actually use
    __pa_symbol() against kernel symbols. Update code where relevant to move
    away from virt_to_phys().
    
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Laura Abbott <labbott@redhat.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 1662071bb2cc..bd8089ff929f 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -315,15 +315,15 @@ void omap3_save_scratchpad_contents(void)
 	scratchpad_contents.boot_config_ptr = 0x0;
 	if (cpu_is_omap3630())
 		scratchpad_contents.public_restore_ptr =
-			virt_to_phys(omap3_restore_3630);
+			__pa_symbol(omap3_restore_3630);
 	else if (omap_rev() != OMAP3430_REV_ES3_0 &&
 					omap_rev() != OMAP3430_REV_ES3_1 &&
 					omap_rev() != OMAP3430_REV_ES3_1_2)
 		scratchpad_contents.public_restore_ptr =
-			virt_to_phys(omap3_restore);
+			__pa_symbol(omap3_restore);
 	else
 		scratchpad_contents.public_restore_ptr =
-			virt_to_phys(omap3_restore_es3);
+			__pa_symbol(omap3_restore_es3);
 
 	if (omap_type() == OMAP2_DEVICE_TYPE_GP)
 		scratchpad_contents.secure_ram_restore_ptr = 0x0;
@@ -395,7 +395,7 @@ void omap3_save_scratchpad_contents(void)
 	sdrc_block_contents.flags = 0x0;
 	sdrc_block_contents.block_size = 0x0;
 
-	arm_context_addr = virt_to_phys(omap3_arm_context);
+	arm_context_addr = __pa_symbol(omap3_arm_context);
 
 	/* Copy all the contents to the scratchpad location */
 	scratchpad_address = OMAP2_L4_IO_ADDRESS(OMAP343X_SCRATCHPAD);

commit d9d806b90260fbcd9bd1d43db492bfcbc19f014a
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Feb 22 09:22:38 2016 -0800

    ARM: OMAP2+: Fix out of range register access with syscon_config.max_register
    
    If syscon_config.max_register is initialized like it should be, we have
    omap_ctrl_read/write() fail with out of range register access at least
    for omap3.
    
    We have omap3.dtsi setting up a regmap range for scm_conf, but we now
    have omap_ctrl_read/write() also attempt to use the regmap. However,
    omap_ctrl_read/write() is also used for other register ranges in the
    system control module (SCM).
    
    Let's fix the issue by just removing the regmap_read/write() usage for
    control module as suggested by Tero Kristo <t-kristo@ti.com>.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index cf5855174c93..1662071bb2cc 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -36,7 +36,6 @@
 
 static void __iomem *omap2_ctrl_base;
 static s16 omap2_ctrl_offset;
-static struct regmap *omap2_ctrl_syscon;
 
 #if defined(CONFIG_ARCH_OMAP3) && defined(CONFIG_PM)
 struct omap3_scratchpad {
@@ -166,16 +165,9 @@ u16 omap_ctrl_readw(u16 offset)
 
 u32 omap_ctrl_readl(u16 offset)
 {
-	u32 val;
-
 	offset &= 0xfffc;
-	if (!omap2_ctrl_syscon)
-		val = readl_relaxed(omap2_ctrl_base + offset);
-	else
-		regmap_read(omap2_ctrl_syscon, omap2_ctrl_offset + offset,
-			    &val);
 
-	return val;
+	return readl_relaxed(omap2_ctrl_base + offset);
 }
 
 void omap_ctrl_writeb(u8 val, u16 offset)
@@ -207,11 +199,7 @@ void omap_ctrl_writew(u16 val, u16 offset)
 void omap_ctrl_writel(u32 val, u16 offset)
 {
 	offset &= 0xfffc;
-	if (!omap2_ctrl_syscon)
-		writel_relaxed(val, omap2_ctrl_base + offset);
-	else
-		regmap_write(omap2_ctrl_syscon, omap2_ctrl_offset + offset,
-			     val);
+	writel_relaxed(val, omap2_ctrl_base + offset);
 }
 
 #ifdef CONFIG_ARCH_OMAP3
@@ -715,8 +703,6 @@ int __init omap_control_init(void)
 			if (IS_ERR(syscon))
 				return PTR_ERR(syscon);
 
-			omap2_ctrl_syscon = syscon;
-
 			if (of_get_child_by_name(scm_conf, "clocks")) {
 				ret = omap2_clk_provider_init(scm_conf,
 							      data->index,
@@ -724,9 +710,6 @@ int __init omap_control_init(void)
 				if (ret)
 					return ret;
 			}
-
-			iounmap(omap2_ctrl_base);
-			omap2_ctrl_base = NULL;
 		} else {
 			/* No scm_conf found, direct access */
 			ret = omap2_clk_provider_init(np, data->index, NULL,

commit 9444f103469f40c47993a1dd87687d126054969c
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Jul 16 01:55:57 2015 -0700

    ARM: OMAP2+: Fix scm compatible for dm814x
    
    Fix scm compatible for dm814x.
    
    Cc: Matthijs van Duin <matthijsvanduin@gmail.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index f008930277ed..cf5855174c93 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -652,6 +652,7 @@ static const struct of_device_id omap_scrm_dt_match_table[] = {
 	{ .compatible = "ti,am4-scm", .data = &ctrl_data },
 	{ .compatible = "ti,omap2-scm", .data = &omap2_ctrl_data },
 	{ .compatible = "ti,omap3-scm", .data = &omap2_ctrl_data },
+	{ .compatible = "ti,dm814-scm", .data = &ctrl_data },
 	{ .compatible = "ti,dm816-scrm", .data = &ctrl_data },
 	{ .compatible = "ti,omap4-scm-core", .data = &ctrl_data },
 	{ .compatible = "ti,omap5-scm-core", .data = &ctrl_data },

commit b96b332fd518cd4d08104bc5ca552ac1ade7e2c7
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 20 09:23:43 2015 -0700

    ARM: OMAP3: Add support for configuring MMC pins as GPIO pins
    
    Some devices are using the MMC1 pins 4..8 as GPIO pins, and in
    this case they need to be configured for 1.8V IO voltage if not
    done by the bootloader as otherwise some devices like smsc911x
    won't work properly.
    
    Let's also make sure this register is saved and restored for
    idle.
    
    Cc: Tim Nordell <tim.nordell@logicpd.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index af95a624fe71..f008930277ed 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -112,6 +112,7 @@ struct omap3_control_regs {
 	u32 csirxfe;
 	u32 iva2_bootaddr;
 	u32 iva2_bootmod;
+	u32 wkup_ctrl;
 	u32 debobs_0;
 	u32 debobs_1;
 	u32 debobs_2;
@@ -455,6 +456,7 @@ void omap3_control_save_context(void)
 			omap_ctrl_readl(OMAP343X_CONTROL_IVA2_BOOTADDR);
 	control_context.iva2_bootmod =
 			omap_ctrl_readl(OMAP343X_CONTROL_IVA2_BOOTMOD);
+	control_context.wkup_ctrl = omap_ctrl_readl(OMAP34XX_CONTROL_WKUP_CTRL);
 	control_context.debobs_0 = omap_ctrl_readl(OMAP343X_CONTROL_DEBOBS(0));
 	control_context.debobs_1 = omap_ctrl_readl(OMAP343X_CONTROL_DEBOBS(1));
 	control_context.debobs_2 = omap_ctrl_readl(OMAP343X_CONTROL_DEBOBS(2));
@@ -512,6 +514,7 @@ void omap3_control_restore_context(void)
 					OMAP343X_CONTROL_IVA2_BOOTADDR);
 	omap_ctrl_writel(control_context.iva2_bootmod,
 					OMAP343X_CONTROL_IVA2_BOOTMOD);
+	omap_ctrl_writel(control_context.wkup_ctrl, OMAP34XX_CONTROL_WKUP_CTRL);
 	omap_ctrl_writel(control_context.debobs_0, OMAP343X_CONTROL_DEBOBS(0));
 	omap_ctrl_writel(control_context.debobs_1, OMAP343X_CONTROL_DEBOBS(1));
 	omap_ctrl_writel(control_context.debobs_2, OMAP343X_CONTROL_DEBOBS(2));

commit ca125b5e31f5ada6844f57c5a8e7cd104d26c8fa
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Feb 12 11:47:04 2015 +0200

    ARM: OMAP4+: control: add support for initializing control module via DT
    
    OMAP4, OMAP5 and DRA7 now parse DT entries for control module address spaces,
    and set up syscon mappings appropriately. Low level IO init is updated to
    remove the legacy control module mappings for these devices also.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index c8565d3dbefe..af95a624fe71 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -650,6 +650,9 @@ static const struct of_device_id omap_scrm_dt_match_table[] = {
 	{ .compatible = "ti,omap2-scm", .data = &omap2_ctrl_data },
 	{ .compatible = "ti,omap3-scm", .data = &omap2_ctrl_data },
 	{ .compatible = "ti,dm816-scrm", .data = &ctrl_data },
+	{ .compatible = "ti,omap4-scm-core", .data = &ctrl_data },
+	{ .compatible = "ti,omap5-scm-core", .data = &ctrl_data },
+	{ .compatible = "ti,dra7-scm-core", .data = &ctrl_data },
 	{ }
 };
 

commit efde234674d9db08b762d9faef4dbbaa2eba3a2e
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Feb 20 10:08:52 2015 +0200

    ARM: OMAP4+: control: remove support for legacy pad read/write
    
    omap4_ctrl_pad_readl/writel are no longer used by anybody, so remove
    these. Syscon / pinctrl should be used to access the padconf area
    instead.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 404778449ef7..c8565d3dbefe 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -36,7 +36,6 @@
 
 static void __iomem *omap2_ctrl_base;
 static s16 omap2_ctrl_offset;
-static void __iomem *omap4_ctrl_pad_base;
 static struct regmap *omap2_ctrl_syscon;
 
 #if defined(CONFIG_ARCH_OMAP3) && defined(CONFIG_PM)
@@ -139,13 +138,9 @@ struct omap3_control_regs {
 static struct omap3_control_regs control_context;
 #endif /* CONFIG_ARCH_OMAP3 && CONFIG_PM */
 
-#define OMAP4_CTRL_PAD_REGADDR(reg)	(omap4_ctrl_pad_base + (reg))
-
-void __init omap2_set_globals_control(void __iomem *ctrl,
-				      void __iomem *ctrl_pad)
+void __init omap2_set_globals_control(void __iomem *ctrl)
 {
 	omap2_ctrl_base = ctrl;
-	omap4_ctrl_pad_base = ctrl_pad;
 }
 
 u8 omap_ctrl_readb(u16 offset)
@@ -218,23 +213,6 @@ void omap_ctrl_writel(u32 val, u16 offset)
 			     val);
 }
 
-/*
- * On OMAP4 control pad are not addressable from control
- * core base. So the common omap_ctrl_read/write APIs breaks
- * Hence export separate APIs to manage the omap4 pad control
- * registers. This APIs will work only for OMAP4
- */
-
-u32 omap4_ctrl_pad_readl(u16 offset)
-{
-	return readl_relaxed(OMAP4_CTRL_PAD_REGADDR(offset));
-}
-
-void omap4_ctrl_pad_writel(u32 val, u16 offset)
-{
-	writel_relaxed(val, OMAP4_CTRL_PAD_REGADDR(offset));
-}
-
 #ifdef CONFIG_ARCH_OMAP3
 
 /**

commit 83a5d6c98af24bb4531dfc05e7c2d3ac2562c6d9
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Feb 12 10:25:40 2015 +0200

    ARM: dts: am4372: add minimal l4 bus layout with control module support
    
    This patch creates an l4_wkup interconnect for AM43xx, and moves some of
    the generic peripherals under it. System control module nodes are moved
    under this new interconnect also, and the SCM clock layout is changed
    to use the renamed SCM nodea as the clock provider.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 477e2c8f26a6..404778449ef7 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -668,7 +668,7 @@ static const struct control_init_data omap2_ctrl_data = {
 
 static const struct of_device_id omap_scrm_dt_match_table[] = {
 	{ .compatible = "ti,am3-scm", .data = &ctrl_data },
-	{ .compatible = "ti,am4-scrm", .data = &ctrl_data },
+	{ .compatible = "ti,am4-scm", .data = &ctrl_data },
 	{ .compatible = "ti,omap2-scm", .data = &omap2_ctrl_data },
 	{ .compatible = "ti,omap3-scm", .data = &omap2_ctrl_data },
 	{ .compatible = "ti,dm816-scrm", .data = &ctrl_data },

commit e3bc5358e0977b95652625f9329ba68f1ebb1a42
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Mar 20 13:08:29 2015 +0200

    ARM: dts: am33xx: add minimal l4 bus layout with control module support
    
    This patch creates an l4_wkup interconnect for AM33xx, and moves some of
    the generic peripherals under it. System control module nodes are moved
    under this new interconnect also, and the SCM clock layout is changed
    to use the renamed SCM node as the clock provider.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 30f5aff7645f..477e2c8f26a6 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -667,7 +667,7 @@ static const struct control_init_data omap2_ctrl_data = {
 };
 
 static const struct of_device_id omap_scrm_dt_match_table[] = {
-	{ .compatible = "ti,am3-scrm", .data = &ctrl_data },
+	{ .compatible = "ti,am3-scm", .data = &ctrl_data },
 	{ .compatible = "ti,am4-scrm", .data = &ctrl_data },
 	{ .compatible = "ti,omap2-scm", .data = &omap2_ctrl_data },
 	{ .compatible = "ti,omap3-scm", .data = &omap2_ctrl_data },

commit b8845074cfbbd1d1b46720a1b563d7b4240dac21
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Feb 24 16:22:45 2015 +0200

    ARM: dts: omap3: add minimal l4 bus layout with control module support
    
    This patch creates an l4_core interconnect for OMAP3, and moves some
    of the generic peripherals under it. System control module nodes are
    moved under this new interconnect also, and the SCM clock layout
    is changed to use the renamed SCM node as the clock provider.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Reported-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index eb592ea51b78..30f5aff7645f 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -670,7 +670,7 @@ static const struct of_device_id omap_scrm_dt_match_table[] = {
 	{ .compatible = "ti,am3-scrm", .data = &ctrl_data },
 	{ .compatible = "ti,am4-scrm", .data = &ctrl_data },
 	{ .compatible = "ti,omap2-scm", .data = &omap2_ctrl_data },
-	{ .compatible = "ti,omap3-scrm", .data = &ctrl_data },
+	{ .compatible = "ti,omap3-scm", .data = &omap2_ctrl_data },
 	{ .compatible = "ti,dm816-scrm", .data = &ctrl_data },
 	{ }
 };

commit 72b10ac00eb1c154037e398371685d3f1d2d4793
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Feb 12 10:38:16 2015 +0200

    ARM: dts: omap24xx: add minimal l4 bus layout with control module support
    
    This patch creates an l4 / l4-wkup interconnects for omap2420 / omap2430
    SoCs, and moves some of the generic peripherals under it. System control
    module nodes are moved under this new interconnect also, and the SCM
    clock layout is changed to use the new SCM node as the clock provider.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 4970c5cb1a11..eb592ea51b78 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -661,10 +661,15 @@ static struct control_init_data ctrl_data = {
 	.index = TI_CLKM_CTRL,
 };
 
+static const struct control_init_data omap2_ctrl_data = {
+	.index = TI_CLKM_CTRL,
+	.offset = -OMAP2_CONTROL_GENERAL,
+};
+
 static const struct of_device_id omap_scrm_dt_match_table[] = {
 	{ .compatible = "ti,am3-scrm", .data = &ctrl_data },
 	{ .compatible = "ti,am4-scrm", .data = &ctrl_data },
-	{ .compatible = "ti,omap2-scrm", .data = &ctrl_data },
+	{ .compatible = "ti,omap2-scm", .data = &omap2_ctrl_data },
 	{ .compatible = "ti,omap3-scrm", .data = &ctrl_data },
 	{ .compatible = "ti,dm816-scrm", .data = &ctrl_data },
 	{ }

commit e5b635742e9824c8c0fc7fc524a24024cf88a448
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Feb 12 11:24:11 2015 +0200

    ARM: OMAP2+: control: add syscon support for register accesses
    
    Control module driver needs to support syscon for register accesses, as
    the DT hierarchy for control module driver is going to be changed. All
    the control module related features will be moved under control module
    node, including clocks, pinctrl, and generic configuration register
    access. Temporary iomap is still provided very early in the boot for
    access while syscon is not yet ready.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 202fc725426b..4970c5cb1a11 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -15,6 +15,8 @@
 #include <linux/kernel.h>
 #include <linux/io.h>
 #include <linux/of_address.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
 
 #include "soc.h"
 #include "iomap.h"
@@ -33,7 +35,9 @@
 #define PADCONF_SAVE_DONE		0x1
 
 static void __iomem *omap2_ctrl_base;
+static s16 omap2_ctrl_offset;
 static void __iomem *omap4_ctrl_pad_base;
+static struct regmap *omap2_ctrl_syscon;
 
 #if defined(CONFIG_ARCH_OMAP3) && defined(CONFIG_PM)
 struct omap3_scratchpad {
@@ -135,7 +139,6 @@ struct omap3_control_regs {
 static struct omap3_control_regs control_context;
 #endif /* CONFIG_ARCH_OMAP3 && CONFIG_PM */
 
-#define OMAP_CTRL_REGADDR(reg)		(omap2_ctrl_base + (reg))
 #define OMAP4_CTRL_PAD_REGADDR(reg)	(omap4_ctrl_pad_base + (reg))
 
 void __init omap2_set_globals_control(void __iomem *ctrl,
@@ -147,32 +150,72 @@ void __init omap2_set_globals_control(void __iomem *ctrl,
 
 u8 omap_ctrl_readb(u16 offset)
 {
-	return readb_relaxed(OMAP_CTRL_REGADDR(offset));
+	u32 val;
+	u8 byte_offset = offset & 0x3;
+
+	val = omap_ctrl_readl(offset);
+
+	return (val >> (byte_offset * 8)) & 0xff;
 }
 
 u16 omap_ctrl_readw(u16 offset)
 {
-	return readw_relaxed(OMAP_CTRL_REGADDR(offset));
+	u32 val;
+	u16 byte_offset = offset & 0x2;
+
+	val = omap_ctrl_readl(offset);
+
+	return (val >> (byte_offset * 8)) & 0xffff;
 }
 
 u32 omap_ctrl_readl(u16 offset)
 {
-	return readl_relaxed(OMAP_CTRL_REGADDR(offset));
+	u32 val;
+
+	offset &= 0xfffc;
+	if (!omap2_ctrl_syscon)
+		val = readl_relaxed(omap2_ctrl_base + offset);
+	else
+		regmap_read(omap2_ctrl_syscon, omap2_ctrl_offset + offset,
+			    &val);
+
+	return val;
 }
 
 void omap_ctrl_writeb(u8 val, u16 offset)
 {
-	writeb_relaxed(val, OMAP_CTRL_REGADDR(offset));
+	u32 tmp;
+	u8 byte_offset = offset & 0x3;
+
+	tmp = omap_ctrl_readl(offset);
+
+	tmp &= 0xffffffff ^ (0xff << (byte_offset * 8));
+	tmp |= val << (byte_offset * 8);
+
+	omap_ctrl_writel(tmp, offset);
 }
 
 void omap_ctrl_writew(u16 val, u16 offset)
 {
-	writew_relaxed(val, OMAP_CTRL_REGADDR(offset));
+	u32 tmp;
+	u8 byte_offset = offset & 0x2;
+
+	tmp = omap_ctrl_readl(offset);
+
+	tmp &= 0xffffffff ^ (0xffff << (byte_offset * 8));
+	tmp |= val << (byte_offset * 8);
+
+	omap_ctrl_writel(tmp, offset);
 }
 
 void omap_ctrl_writel(u32 val, u16 offset)
 {
-	writel_relaxed(val, OMAP_CTRL_REGADDR(offset));
+	offset &= 0xfffc;
+	if (!omap2_ctrl_syscon)
+		writel_relaxed(val, omap2_ctrl_base + offset);
+	else
+		regmap_write(omap2_ctrl_syscon, omap2_ctrl_offset + offset,
+			     val);
 }
 
 /*
@@ -611,7 +654,7 @@ void __init omap3_ctrl_init(void)
 
 struct control_init_data {
 	int index;
-	void __iomem *mem;
+	s16 offset;
 };
 
 static struct control_init_data ctrl_data = {
@@ -639,17 +682,15 @@ int __init omap2_control_base_init(void)
 	struct device_node *np;
 	const struct of_device_id *match;
 	struct control_init_data *data;
-	void __iomem *mem;
 
 	for_each_matching_node_and_match(np, omap_scrm_dt_match_table, &match) {
 		data = (struct control_init_data *)match->data;
 
-		mem = of_iomap(np, 0);
-		if (!mem)
+		omap2_ctrl_base = of_iomap(np, 0);
+		if (!omap2_ctrl_base)
 			return -ENOMEM;
 
-		omap2_ctrl_base = mem;
-		data->mem = mem;
+		omap2_ctrl_offset = data->offset;
 	}
 
 	return 0;
@@ -663,17 +704,46 @@ int __init omap2_control_base_init(void)
  */
 int __init omap_control_init(void)
 {
-	struct device_node *np;
+	struct device_node *np, *scm_conf;
 	const struct of_device_id *match;
 	const struct omap_prcm_init_data *data;
 	int ret;
+	struct regmap *syscon;
 
 	for_each_matching_node_and_match(np, omap_scrm_dt_match_table, &match) {
 		data = match->data;
 
-		ret = omap2_clk_provider_init(np, data->index, NULL, data->mem);
-		if (ret)
-			return ret;
+		/*
+		 * Check if we have scm_conf node, if yes, use this to
+		 * access clock registers.
+		 */
+		scm_conf = of_get_child_by_name(np, "scm_conf");
+
+		if (scm_conf) {
+			syscon = syscon_node_to_regmap(scm_conf);
+
+			if (IS_ERR(syscon))
+				return PTR_ERR(syscon);
+
+			omap2_ctrl_syscon = syscon;
+
+			if (of_get_child_by_name(scm_conf, "clocks")) {
+				ret = omap2_clk_provider_init(scm_conf,
+							      data->index,
+							      syscon, NULL);
+				if (ret)
+					return ret;
+			}
+
+			iounmap(omap2_ctrl_base);
+			omap2_ctrl_base = NULL;
+		} else {
+			/* No scm_conf found, direct access */
+			ret = omap2_clk_provider_init(np, data->index, NULL,
+						      omap2_ctrl_base);
+			if (ret)
+				return ret;
+		}
 	}
 
 	return 0;

commit ae0f6798474053eb76863fa9b3befd9deea58ba6
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Feb 6 16:20:13 2015 +0200

    ARM: OMAP2+: control: remove API for getting control module base address
    
    This shall not be used anymore, as control module driver is converted
    into using regmap.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 4b4094685087..202fc725426b 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -145,11 +145,6 @@ void __init omap2_set_globals_control(void __iomem *ctrl,
 	omap4_ctrl_pad_base = ctrl_pad;
 }
 
-void __iomem *omap_ctrl_base_get(void)
-{
-	return omap2_ctrl_base;
-}
-
 u8 omap_ctrl_readb(u16 offset)
 {
 	return readb_relaxed(OMAP_CTRL_REGADDR(offset));

commit 80cbb224b789d256ad5cb36b0af3e5c04ed46bca
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Feb 6 16:00:32 2015 +0200

    ARM: OMAP2+: clock: add low-level support for regmap
    
    Some of the TI clock providers will be converted to use syscon, thus
    low-level regmap support is needed for the clock drivers also. This
    patch adds this support, which can be enabled for individual drivers
    in later patches.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 21ff32c6001a..4b4094685087 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -676,7 +676,7 @@ int __init omap_control_init(void)
 	for_each_matching_node_and_match(np, omap_scrm_dt_match_table, &match) {
 		data = match->data;
 
-		ret = omap2_clk_provider_init(np, data->index, data->mem);
+		ret = omap2_clk_provider_init(np, data->index, NULL, data->mem);
 		if (ret)
 			return ret;
 	}

commit 2208bf115fecae211480ea41d25e6d56ec20d405
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Nov 13 19:17:34 2014 +0200

    ARM: OMAP2+: control: determine control module base address from DT
    
    There is no need to provide the control module base address through a
    low-level API from the low-level IO init, as this information is
    available through DT. This patch adds a new API to initialize the
    control module though, but mostly makes the old API obsolete. The
    old API can be completely removed once OMAP3 is made DT only.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index e8818242f968..21ff32c6001a 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -616,6 +616,7 @@ void __init omap3_ctrl_init(void)
 
 struct control_init_data {
 	int index;
+	void __iomem *mem;
 };
 
 static struct control_init_data ctrl_data = {
@@ -627,9 +628,38 @@ static const struct of_device_id omap_scrm_dt_match_table[] = {
 	{ .compatible = "ti,am4-scrm", .data = &ctrl_data },
 	{ .compatible = "ti,omap2-scrm", .data = &ctrl_data },
 	{ .compatible = "ti,omap3-scrm", .data = &ctrl_data },
+	{ .compatible = "ti,dm816-scrm", .data = &ctrl_data },
 	{ }
 };
 
+/**
+ * omap2_control_base_init - initialize iomappings for the control driver
+ *
+ * Detects and initializes the iomappings for the control driver, based
+ * on the DT data. Returns 0 in success, negative error value
+ * otherwise.
+ */
+int __init omap2_control_base_init(void)
+{
+	struct device_node *np;
+	const struct of_device_id *match;
+	struct control_init_data *data;
+	void __iomem *mem;
+
+	for_each_matching_node_and_match(np, omap_scrm_dt_match_table, &match) {
+		data = (struct control_init_data *)match->data;
+
+		mem = of_iomap(np, 0);
+		if (!mem)
+			return -ENOMEM;
+
+		omap2_ctrl_base = mem;
+		data->mem = mem;
+	}
+
+	return 0;
+}
+
 /**
  * omap_control_init - low level init for the control driver
  *
@@ -639,7 +669,6 @@ static const struct of_device_id omap_scrm_dt_match_table[] = {
 int __init omap_control_init(void)
 {
 	struct device_node *np;
-	void __iomem *mem;
 	const struct of_device_id *match;
 	const struct omap_prcm_init_data *data;
 	int ret;
@@ -647,14 +676,22 @@ int __init omap_control_init(void)
 	for_each_matching_node_and_match(np, omap_scrm_dt_match_table, &match) {
 		data = match->data;
 
-		mem = of_iomap(np, 0);
-		if (!mem)
-			return -ENOMEM;
-
-		ret = omap2_clk_provider_init(np, data->index, mem);
+		ret = omap2_clk_provider_init(np, data->index, data->mem);
 		if (ret)
 			return ret;
 	}
 
 	return 0;
 }
+
+/**
+ * omap3_control_legacy_iomap_init - legacy iomap init for clock providers
+ *
+ * Legacy iomap init for clock provider. Needed only by legacy boot mode,
+ * where the base addresses are not parsed from DT, but still required
+ * by the clock driver to be setup properly.
+ */
+void __init omap3_control_legacy_iomap_init(void)
+{
+	omap2_clk_legacy_provider_init(TI_CLKM_SCRM, omap2_ctrl_base);
+}

commit fe87414f71d0035756cf91a80ac256557d16b488
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Mar 12 18:33:45 2014 +0200

    ARM: OMAP2+: PRCM: split PRCM module init to their own driver files
    
    Splits the clock related provider module inits under their own driver files.
    Previously this was done for all modules under the common PRM driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index da041b4ab29c..e8818242f968 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -14,6 +14,7 @@
 
 #include <linux/kernel.h>
 #include <linux/io.h>
+#include <linux/of_address.h>
 
 #include "soc.h"
 #include "iomap.h"
@@ -25,6 +26,7 @@
 #include "sdrc.h"
 #include "pm.h"
 #include "control.h"
+#include "clock.h"
 
 /* Used by omap3_ctrl_save_padconf() */
 #define START_PADCONF_SAVE		0x2
@@ -611,3 +613,48 @@ void __init omap3_ctrl_init(void)
 	omap3_ctrl_setup_d2d_padconf();
 }
 #endif /* CONFIG_ARCH_OMAP3 && CONFIG_PM */
+
+struct control_init_data {
+	int index;
+};
+
+static struct control_init_data ctrl_data = {
+	.index = TI_CLKM_CTRL,
+};
+
+static const struct of_device_id omap_scrm_dt_match_table[] = {
+	{ .compatible = "ti,am3-scrm", .data = &ctrl_data },
+	{ .compatible = "ti,am4-scrm", .data = &ctrl_data },
+	{ .compatible = "ti,omap2-scrm", .data = &ctrl_data },
+	{ .compatible = "ti,omap3-scrm", .data = &ctrl_data },
+	{ }
+};
+
+/**
+ * omap_control_init - low level init for the control driver
+ *
+ * Initializes the low level clock infrastructure for control driver.
+ * Returns 0 in success, negative error value in failure.
+ */
+int __init omap_control_init(void)
+{
+	struct device_node *np;
+	void __iomem *mem;
+	const struct of_device_id *match;
+	const struct omap_prcm_init_data *data;
+	int ret;
+
+	for_each_matching_node_and_match(np, omap_scrm_dt_match_table, &match) {
+		data = match->data;
+
+		mem = of_iomap(np, 0);
+		if (!mem)
+			return -ENOMEM;
+
+		ret = omap2_clk_provider_init(np, data->index, mem);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}

commit ae21e6180a03c147514c606b4e649690e0cbd40e
Author: Jeremy Vial <jvial@adeneo-embedded.com>
Date:   Thu Jul 31 15:10:34 2014 +0200

    ARM: OMAP3: Fix coding style problems in arch/arm/mach-omap2/control.c
    
    Fix coding style problems in arch/arm/mach-omap2/control.c.
    
    Signed-off-by: Jeremy Vial <jvial@adeneo-embedded.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index e84e3b4bfde1..da041b4ab29c 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -280,6 +280,7 @@ void omap3_clear_scratchpad_contents(void)
 	u32 max_offset = OMAP343X_SCRATCHPAD_ROM_OFFSET;
 	void __iomem *v_addr;
 	u32 offset = 0;
+
 	v_addr = OMAP2_L4_IO_ADDRESS(OMAP343X_SCRATCHPAD_ROM);
 	if (omap3xxx_prm_clear_global_cold_reset()) {
 		for ( ; offset <= max_offset; offset += 0x4)
@@ -464,7 +465,6 @@ void omap3_control_save_context(void)
 	control_context.csi = omap_ctrl_readl(OMAP343X_CONTROL_CSI);
 	control_context.padconf_sys_nirq =
 		omap_ctrl_readl(OMAP343X_CONTROL_PADCONF_SYSNIRQ);
-	return;
 }
 
 void omap3_control_restore_context(void)
@@ -522,7 +522,6 @@ void omap3_control_restore_context(void)
 	omap_ctrl_writel(control_context.csi, OMAP343X_CONTROL_CSI);
 	omap_ctrl_writel(control_context.padconf_sys_nirq,
 			 OMAP343X_CONTROL_PADCONF_SYSNIRQ);
-	return;
 }
 
 void omap3630_ctrl_disable_rta(void)

commit 9b5f7428f8b16bd8980213f2b70baf1dd0b9e36c
Author: Jeremy Vial <jvial@adeneo-embedded.com>
Date:   Thu Jul 31 15:10:33 2014 +0200

    ARM: OMAP3: Fix choice of omap3_restore_es function in OMAP34XX rev3.1.2 case.
    
    According to the comment “restore_es3: applies to 34xx >= ES3.0" in
    "arch/arm/mach-omap2/sleep34xx.S”, omap3_restore_es3 should be used
    if the revision of an OMAP34xx is ES3.1.2.
    
    Signed-off-by: Jeremy Vial <jvial@adeneo-embedded.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index f4796c002070..e84e3b4bfde1 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -309,7 +309,8 @@ void omap3_save_scratchpad_contents(void)
 		scratchpad_contents.public_restore_ptr =
 			virt_to_phys(omap3_restore_3630);
 	else if (omap_rev() != OMAP3430_REV_ES3_0 &&
-					omap_rev() != OMAP3430_REV_ES3_1)
+					omap_rev() != OMAP3430_REV_ES3_1 &&
+					omap_rev() != OMAP3430_REV_ES3_1_2)
 		scratchpad_contents.public_restore_ptr =
 			virt_to_phys(omap3_restore);
 	else

commit ba12c24286296159a1271eb19f2fc5c2ef59fbde
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Mar 4 17:43:04 2014 +0200

    ARM: OMAP3: control: isolate control module init to its own function
    
    Control module related PM initializations are now moved within control
    module driver. Done in preparation to isolate the code to its own driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index f432ffc0deb2..f4796c002070 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -564,7 +564,7 @@ int omap3_ctrl_save_padconf(void)
  * Sets the bootmode for IVA2 to idle. This is needed by the PM code to
  * force disable IVA2 so that it does not prevent any low-power states.
  */
-void omap3_ctrl_set_iva_bootmode_idle(void)
+static void __init omap3_ctrl_set_iva_bootmode_idle(void)
 {
 	omap_ctrl_writel(OMAP3_IVA2_BOOTMOD_IDLE,
 			 OMAP343X_CONTROL_IVA2_BOOTMOD);
@@ -576,7 +576,7 @@ void omap3_ctrl_set_iva_bootmode_idle(void)
  * Sets up the pads controlling the stacked modem in such way that the
  * device can enter idle.
  */
-void omap3_ctrl_setup_d2d_padconf(void)
+static void __init omap3_ctrl_setup_d2d_padconf(void)
 {
 	u16 mask, padconf;
 
@@ -595,4 +595,19 @@ void omap3_ctrl_setup_d2d_padconf(void)
 	padconf |= mask;
 	omap_ctrl_writew(padconf, OMAP3_PADCONF_SAD2D_IDLEACK);
 }
+
+/**
+ * omap3_ctrl_init - does static initializations for control module
+ *
+ * Initializes system control module. This sets up the sysconfig autoidle,
+ * and sets up modem and iva2 so that they can be idled properly.
+ */
+void __init omap3_ctrl_init(void)
+{
+	omap_ctrl_writel(OMAP3430_AUTOIDLE_MASK, OMAP2_CONTROL_SYSCONFIG);
+
+	omap3_ctrl_set_iva_bootmode_idle();
+
+	omap3_ctrl_setup_d2d_padconf();
+}
 #endif /* CONFIG_ARCH_OMAP3 && CONFIG_PM */

commit bbd36f9f03eceee5c208db83049142171e6338f6
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Mar 4 17:17:06 2014 +0200

    ARM: OMAP3: control: add API for setting up the modem pads
    
    This patch moves the functionality from PM core to control driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 83080949d0d3..f432ffc0deb2 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -569,4 +569,30 @@ void omap3_ctrl_set_iva_bootmode_idle(void)
 	omap_ctrl_writel(OMAP3_IVA2_BOOTMOD_IDLE,
 			 OMAP343X_CONTROL_IVA2_BOOTMOD);
 }
+
+/**
+ * omap3_ctrl_setup_d2d_padconf - setup stacked modem pads for idle
+ *
+ * Sets up the pads controlling the stacked modem in such way that the
+ * device can enter idle.
+ */
+void omap3_ctrl_setup_d2d_padconf(void)
+{
+	u16 mask, padconf;
+
+	/*
+	 * In a stand alone OMAP3430 where there is not a stacked
+	 * modem for the D2D Idle Ack and D2D MStandby must be pulled
+	 * high. S CONTROL_PADCONF_SAD2D_IDLEACK and
+	 * CONTROL_PADCONF_SAD2D_MSTDBY to have a pull up.
+	 */
+	mask = (1 << 4) | (1 << 3); /* pull-up, enabled */
+	padconf = omap_ctrl_readw(OMAP3_PADCONF_SAD2D_MSTANDBY);
+	padconf |= mask;
+	omap_ctrl_writew(padconf, OMAP3_PADCONF_SAD2D_MSTANDBY);
+
+	padconf = omap_ctrl_readw(OMAP3_PADCONF_SAD2D_IDLEACK);
+	padconf |= mask;
+	omap_ctrl_writew(padconf, OMAP3_PADCONF_SAD2D_IDLEACK);
+}
 #endif /* CONFIG_ARCH_OMAP3 && CONFIG_PM */

commit 7e28b465fdea3f0601a1c76e47c50d05c7c603e2
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Feb 26 12:00:16 2014 +0200

    ARM: OMAP3: PRM: add API for saving PRM scratchpad contents
    
    This isolates the PRM register access within the PRM driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index f8eb3e4354ad..83080949d0d3 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -44,8 +44,7 @@ struct omap3_scratchpad {
 };
 
 struct omap3_scratchpad_prcm_block {
-	u32 prm_clksrc_ctrl;
-	u32 prm_clksel;
+	u32 prm_contents[2];
 	u32 cm_contents[11];
 	u32 prcm_block_size;
 };
@@ -327,13 +326,7 @@ void omap3_save_scratchpad_contents(void)
 	scratchpad_contents.sdrc_block_offset = 0x64;
 
 	/* Populate the PRCM block contents */
-	prcm_block_contents.prm_clksrc_ctrl =
-		omap2_prm_read_mod_reg(OMAP3430_GR_MOD,
-				       OMAP3_PRM_CLKSRC_CTRL_OFFSET);
-	prcm_block_contents.prm_clksel =
-		omap2_prm_read_mod_reg(OMAP3430_CCR_MOD,
-				       OMAP3_PRM_CLKSEL_OFFSET);
-
+	omap3_prm_save_scratchpad_contents(prcm_block_contents.prm_contents);
 	omap3_cm_save_scratchpad_contents(prcm_block_contents.cm_contents);
 
 	prcm_block_contents.prcm_block_size = 0x0;

commit 9efcea09b0b56488e46ab3a36fe8dbce9eded529
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Feb 26 11:54:29 2014 +0200

    ARM: OMAP3: PRM: add API for checking and clearing cold reset status
    
    This isolates the PRM register access within the PRM driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 751f3549bf6f..f8eb3e4354ad 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -282,13 +282,9 @@ void omap3_clear_scratchpad_contents(void)
 	void __iomem *v_addr;
 	u32 offset = 0;
 	v_addr = OMAP2_L4_IO_ADDRESS(OMAP343X_SCRATCHPAD_ROM);
-	if (omap2_prm_read_mod_reg(OMAP3430_GR_MOD, OMAP3_PRM_RSTST_OFFSET) &
-	    OMAP3430_GLOBAL_COLD_RST_MASK) {
+	if (omap3xxx_prm_clear_global_cold_reset()) {
 		for ( ; offset <= max_offset; offset += 0x4)
 			writel_relaxed(0x0, (v_addr + offset));
-		omap2_prm_set_mod_reg_bits(OMAP3430_GLOBAL_COLD_RST_MASK,
-					   OMAP3430_GR_MOD,
-					   OMAP3_PRM_RSTST_OFFSET);
 	}
 }
 

commit edfaf05c2fcb853fcf35f12aeb9c340f5913337f
Author: Victor Kamensky <victor.kamensky@linaro.org>
Date:   Tue Apr 15 20:37:46 2014 +0300

    ARM: OMAP2+: raw read and write endian fix
    
    All OMAP IP blocks expect LE data, but CPU may operate in BE mode.
    Need to use endian neutral functions to read/write h/w registers.
    I.e instead of __raw_read[lw] and __raw_write[lw] functions code
    need to use read[lw]_relaxed and write[lw]_relaxed functions.
    If the first simply reads/writes register, the second will byteswap
    it if host operates in BE mode.
    
    Changes are trivial sed like replacement of __raw_xxx functions
    with xxx_relaxed variant.
    
    Signed-off-by: Victor Kamensky <victor.kamensky@linaro.org>
    Signed-off-by: Taras Kondratiuk <taras.kondratiuk@linaro.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 44bb4d544dcf..751f3549bf6f 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -151,32 +151,32 @@ void __iomem *omap_ctrl_base_get(void)
 
 u8 omap_ctrl_readb(u16 offset)
 {
-	return __raw_readb(OMAP_CTRL_REGADDR(offset));
+	return readb_relaxed(OMAP_CTRL_REGADDR(offset));
 }
 
 u16 omap_ctrl_readw(u16 offset)
 {
-	return __raw_readw(OMAP_CTRL_REGADDR(offset));
+	return readw_relaxed(OMAP_CTRL_REGADDR(offset));
 }
 
 u32 omap_ctrl_readl(u16 offset)
 {
-	return __raw_readl(OMAP_CTRL_REGADDR(offset));
+	return readl_relaxed(OMAP_CTRL_REGADDR(offset));
 }
 
 void omap_ctrl_writeb(u8 val, u16 offset)
 {
-	__raw_writeb(val, OMAP_CTRL_REGADDR(offset));
+	writeb_relaxed(val, OMAP_CTRL_REGADDR(offset));
 }
 
 void omap_ctrl_writew(u16 val, u16 offset)
 {
-	__raw_writew(val, OMAP_CTRL_REGADDR(offset));
+	writew_relaxed(val, OMAP_CTRL_REGADDR(offset));
 }
 
 void omap_ctrl_writel(u32 val, u16 offset)
 {
-	__raw_writel(val, OMAP_CTRL_REGADDR(offset));
+	writel_relaxed(val, OMAP_CTRL_REGADDR(offset));
 }
 
 /*
@@ -188,12 +188,12 @@ void omap_ctrl_writel(u32 val, u16 offset)
 
 u32 omap4_ctrl_pad_readl(u16 offset)
 {
-	return __raw_readl(OMAP4_CTRL_PAD_REGADDR(offset));
+	return readl_relaxed(OMAP4_CTRL_PAD_REGADDR(offset));
 }
 
 void omap4_ctrl_pad_writel(u32 val, u16 offset)
 {
-	__raw_writel(val, OMAP4_CTRL_PAD_REGADDR(offset));
+	writel_relaxed(val, OMAP4_CTRL_PAD_REGADDR(offset));
 }
 
 #ifdef CONFIG_ARCH_OMAP3
@@ -222,7 +222,7 @@ void omap3_ctrl_write_boot_mode(u8 bootmode)
 	 *
 	 * XXX This should use some omap_ctrl_writel()-type function
 	 */
-	__raw_writel(l, OMAP2_L4_IO_ADDRESS(OMAP343X_SCRATCHPAD + 4));
+	writel_relaxed(l, OMAP2_L4_IO_ADDRESS(OMAP343X_SCRATCHPAD + 4));
 }
 
 #endif
@@ -285,7 +285,7 @@ void omap3_clear_scratchpad_contents(void)
 	if (omap2_prm_read_mod_reg(OMAP3430_GR_MOD, OMAP3_PRM_RSTST_OFFSET) &
 	    OMAP3430_GLOBAL_COLD_RST_MASK) {
 		for ( ; offset <= max_offset; offset += 0x4)
-			__raw_writel(0x0, (v_addr + offset));
+			writel_relaxed(0x0, (v_addr + offset));
 		omap2_prm_set_mod_reg_bits(OMAP3430_GLOBAL_COLD_RST_MASK,
 					   OMAP3430_GR_MOD,
 					   OMAP3_PRM_RSTST_OFFSET);

commit 49e03402327ab69a26f604398982ef14123900a2
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Oct 11 19:15:38 2013 +0300

    ARM: OMAP3: control: add API for setting IVA bootmode
    
    OMAP3 PM core requires IVA2 bootmode to be set to idle during init. Currently,
    a direct register write is used for this. Add a new ctrl API for this purpose
    instead.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index a59711454543..44bb4d544dcf 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -569,4 +569,15 @@ int omap3_ctrl_save_padconf(void)
 	return 0;
 }
 
+/**
+ * omap3_ctrl_set_iva_bootmode_idle - sets the IVA2 bootmode to idle
+ *
+ * Sets the bootmode for IVA2 to idle. This is needed by the PM code to
+ * force disable IVA2 so that it does not prevent any low-power states.
+ */
+void omap3_ctrl_set_iva_bootmode_idle(void)
+{
+	omap_ctrl_writel(OMAP3_IVA2_BOOTMOD_IDLE,
+			 OMAP343X_CONTROL_IVA2_BOOTMOD);
+}
 #endif /* CONFIG_ARCH_OMAP3 && CONFIG_PM */

commit c6a2d839d0dba8a06f55c7b06f8ce33bdbe4aea3
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Oct 11 19:15:34 2013 +0300

    ARM: OMAP3: CM/control: move CM scratchpad save to CM driver
    
    OMAP3 PM code for off-mode currently saves the scratchpad contents for CM
    registers within OMAP control module driver. However, as we are separating
    CM code into its own driver, this must be moved also. This patch adds a
    new API for saving the CM scratchpad contents and uses this from the high
    level scratchpad save function.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 31e0dfe4a4ea..a59711454543 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -46,17 +46,7 @@ struct omap3_scratchpad {
 struct omap3_scratchpad_prcm_block {
 	u32 prm_clksrc_ctrl;
 	u32 prm_clksel;
-	u32 cm_clksel_core;
-	u32 cm_clksel_wkup;
-	u32 cm_clken_pll;
-	u32 cm_autoidle_pll;
-	u32 cm_clksel1_pll;
-	u32 cm_clksel2_pll;
-	u32 cm_clksel3_pll;
-	u32 cm_clken_pll_mpu;
-	u32 cm_autoidle_pll_mpu;
-	u32 cm_clksel1_pll_mpu;
-	u32 cm_clksel2_pll_mpu;
+	u32 cm_contents[11];
 	u32 prcm_block_size;
 };
 
@@ -347,34 +337,9 @@ void omap3_save_scratchpad_contents(void)
 	prcm_block_contents.prm_clksel =
 		omap2_prm_read_mod_reg(OMAP3430_CCR_MOD,
 				       OMAP3_PRM_CLKSEL_OFFSET);
-	prcm_block_contents.cm_clksel_core =
-			omap2_cm_read_mod_reg(CORE_MOD, CM_CLKSEL);
-	prcm_block_contents.cm_clksel_wkup =
-			omap2_cm_read_mod_reg(WKUP_MOD, CM_CLKSEL);
-	prcm_block_contents.cm_clken_pll =
-			omap2_cm_read_mod_reg(PLL_MOD, CM_CLKEN);
-	/*
-	 * As per erratum i671, ROM code does not respect the PER DPLL
-	 * programming scheme if CM_AUTOIDLE_PLL..AUTO_PERIPH_DPLL == 1.
-	 * Then,  in anycase, clear these bits to avoid extra latencies.
-	 */
-	prcm_block_contents.cm_autoidle_pll =
-			omap2_cm_read_mod_reg(PLL_MOD, CM_AUTOIDLE) &
-			~OMAP3430_AUTO_PERIPH_DPLL_MASK;
-	prcm_block_contents.cm_clksel1_pll =
-			omap2_cm_read_mod_reg(PLL_MOD, OMAP3430_CM_CLKSEL1_PLL);
-	prcm_block_contents.cm_clksel2_pll =
-			omap2_cm_read_mod_reg(PLL_MOD, OMAP3430_CM_CLKSEL2_PLL);
-	prcm_block_contents.cm_clksel3_pll =
-			omap2_cm_read_mod_reg(PLL_MOD, OMAP3430_CM_CLKSEL3);
-	prcm_block_contents.cm_clken_pll_mpu =
-			omap2_cm_read_mod_reg(MPU_MOD, OMAP3430_CM_CLKEN_PLL);
-	prcm_block_contents.cm_autoidle_pll_mpu =
-			omap2_cm_read_mod_reg(MPU_MOD, OMAP3430_CM_AUTOIDLE_PLL);
-	prcm_block_contents.cm_clksel1_pll_mpu =
-			omap2_cm_read_mod_reg(MPU_MOD, OMAP3430_CM_CLKSEL1_PLL);
-	prcm_block_contents.cm_clksel2_pll_mpu =
-			omap2_cm_read_mod_reg(MPU_MOD, OMAP3430_CM_CLKSEL2_PLL);
+
+	omap3_cm_save_scratchpad_contents(prcm_block_contents.cm_contents);
+
 	prcm_block_contents.prcm_block_size = 0x0;
 
 	/* Populate the SDRC block contents */

commit 668468b161745df666b75fbfb76d14155b0f9df6
Author: Suman Anna <s-anna@ti.com>
Date:   Wed Apr 17 16:31:03 2013 -0500

    ARM: OMAP2+: control: add OMAP5 support for dsp boot programming
    
    Support for OMAP5 is added to the omap_dsp_ctrl_write_boot_addr()
    to enable the DSP boot.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 2adb2683f074..31e0dfe4a4ea 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -249,6 +249,7 @@ void omap_ctrl_write_dsp_boot_addr(u32 bootaddr)
 	u32 offset = cpu_is_omap243x() ? OMAP243X_CONTROL_IVA2_BOOTADDR :
 		     cpu_is_omap34xx() ? OMAP343X_CONTROL_IVA2_BOOTADDR :
 		     cpu_is_omap44xx() ? OMAP4_CTRL_MODULE_CORE_DSP_BOOTADDR :
+		     soc_is_omap54xx() ? OMAP4_CTRL_MODULE_CORE_DSP_BOOTADDR :
 		     0;
 
 	if (!offset) {

commit b6a4226c14001b0aa20b11c69190cb89d2237d3d
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Oct 29 20:50:21 2012 -0600

    ARM: OMAP2+: common: remove mach-omap2/common.c globals and map_common_io code
    
    Get rid of the mach-omap2/common.c globals by moving the global
    initialization for IP block addresses that must occur early into
    mach-omap2/io.c.  In the process, remove the *_map_common_io*() and
    SoC-specific *set_globals* functions.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Vaibhav Hiremath <hvaibhav@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 06375ad20917..2adb2683f074 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -147,13 +147,11 @@ static struct omap3_control_regs control_context;
 #define OMAP_CTRL_REGADDR(reg)		(omap2_ctrl_base + (reg))
 #define OMAP4_CTRL_PAD_REGADDR(reg)	(omap4_ctrl_pad_base + (reg))
 
-void __init omap2_set_globals_control(struct omap_globals *omap2_globals)
+void __init omap2_set_globals_control(void __iomem *ctrl,
+				      void __iomem *ctrl_pad)
 {
-	if (omap2_globals->ctrl)
-		omap2_ctrl_base = omap2_globals->ctrl;
-
-	if (omap2_globals->ctrl_pad)
-		omap4_ctrl_pad_base = omap2_globals->ctrl_pad;
+	omap2_ctrl_base = ctrl;
+	omap4_ctrl_pad_base = ctrl_pad;
 }
 
 void __iomem *omap_ctrl_base_get(void)

commit 8634155ef41d3a035f2ea0b6c5bed2806f2788bc
Merge: 6d02643d64b4 2bb2a5d30abb
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Oct 24 17:05:59 2012 -0700

    Merge tag 'omap-cleanup-a-for-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into omap-for-v3.8/cleanup-prcm
    
    The first set of OMAP PRM/CM-related cleanup patches for 3.8.
    Prepares for the future move of the PRM/CM code to drivers/.  Also
    includes some prcm.[ch] cleanup patches from the WDTIMER cleanup
    series that don't need external acks.
    
    Basic test logs for this branch on top of v3.7-rc2 are here:
    
    http://www.pwsan.com/omap/testlogs/prcm_cleanup_a_3.8/20121021123719/
    
    But due to the number of unrelated regressions present in v3.7-rc[12],
    it's not particularly usable as a testing base.  With reverts, fixes,
    and workarounds applied as documented in:
    
    http://www.pwsan.com/omap/testlogs/test_v3.7-rc2/20121020134755/README.txt
    
    the following test logs were obtained:
    
    http://www.pwsan.com/omap/testlogs/prcm_cleanup_a_3.8/20121020231757/
    
    which indicate that the series tests cleanly.
    
    Conflicts:
            arch/arm/mach-omap2/Makefile
            arch/arm/mach-omap2/clockdomain2xxx_3xxx.c
            arch/arm/mach-omap2/pm24xx.c

commit ff4ae5d9319b86f940e410e92659c50f9879ff46
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Oct 21 01:01:11 2012 -0600

    ARM: OMAP2+: CM/hwmod: split CM functions into OMAP2, OMAP3-specific files
    
    Move OMAP3xxx-specific CM functions & macros into cm3xxx.[ch] and
    OMAP2xxx-specific macros into cm2xxx.[ch].  Move basic CM register
    access functions into static inline functions in cm2xxx_3xxx.h,
    leaving only OMAP2/3 hardreset functions in cm2xxx_3xxx.c.
    
    As part of this, split the CM and hwmod code that waits for devices to
    become ready into SoC-specific functions.
    
    This is in preparation for the upcoming move of this code to drivers/.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Reviewed-by: Russ Dill <Russ.Dill@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 1220e0ef0b86..a7d1eb8fb57c 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -23,7 +23,7 @@
 #include "cm-regbits-34xx.h"
 #include "prm-regbits-34xx.h"
 #include "prm3xxx.h"
-#include "cm2xxx_3xxx.h"
+#include "cm3xxx.h"
 #include "sdrc.h"
 #include "pm.h"
 #include "control.h"

commit 139563ad27e7baad7935b8113940f0d804cf513b
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Oct 21 01:01:10 2012 -0600

    ARM: OMAP2+: PRM: split PRM functions into OMAP2, OMAP3-specific files
    
    Move OMAP3xxx-specific PRM functions & macros into prm3xxx.[ch] and
    OMAP2xxx-specific macros into prm2xxx.h.  (prm2xxx.c will be created
    by a subsequent patch when it's needed.)  Move basic PRM register
    access functions into static inline functions in prm2xxx_3xxx.h, leaving
    only OMAP2/3 hardreset functions in prm2xxx_3xxx.c.
    
    Also clarify the initcall function naming to reinforce that this code
    is specifically for the PRM IP block.
    
    This is in preparation for the upcoming powerdomain series and the
    upcoming move of this code to drivers/.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Reviewed-by: Russ Dill <Russ.Dill@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index d1ff8399a222..1220e0ef0b86 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -22,7 +22,7 @@
 #include "common.h"
 #include "cm-regbits-34xx.h"
 #include "prm-regbits-34xx.h"
-#include "prm2xxx_3xxx.h"
+#include "prm3xxx.h"
 #include "cm2xxx_3xxx.h"
 #include "sdrc.h"
 #include "pm.h"

commit 3e6ece13d966a20a38ee7adfac452a47455ccd7a
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Oct 17 00:46:45 2012 +0000

    ARM: OMAP: move plat-omap/include/plat/sdrc.h into mach-omap2/sdrc.h
    
    Remove arch/arm/plat-omap/include/plat/sdrc.h by folding its contents
    into arch/arm/mach-omap2/sdrc.h.  The objective is to assist Tony in
    cleaning out arch/arm/plat-omap/, as his upstreams request.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Tony Lindgren <tony@atomide.com>
    [tony@atomide.com: updated to remove rotate macros]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index d1ff8399a222..bf2be5c5468d 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -1,7 +1,7 @@
 /*
  * OMAP2/3 System Control Module register access
  *
- * Copyright (C) 2007 Texas Instruments, Inc.
+ * Copyright (C) 2007, 2012 Texas Instruments, Inc.
  * Copyright (C) 2007 Nokia Corporation
  *
  * Written by Paul Walmsley
@@ -15,8 +15,6 @@
 #include <linux/kernel.h>
 #include <linux/io.h>
 
-#include <plat/sdrc.h>
-
 #include "soc.h"
 #include "iomap.h"
 #include "common.h"

commit dbc04161048dd5e5c3c58546688a0cc0854051e9
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Aug 31 10:59:07 2012 -0700

    ARM: OMAP: Split plat/hardware.h, use local soc.h for omap2+
    
    As the plat and mach includes need to disappear for single zImage work,
    we need to remove plat/hardware.h.
    
    Do this by splitting plat/hardware.h into omap1 and omap2+ specific files.
    
    The old plat/hardware.h already has omap1 only defines, so it gets moved
    to mach/hardware.h for omap1. For omap2+, we use the local soc.h
    that for now just includes the related SoC headers to keep this patch more
    readable.
    
    Note that the local soc.h still includes plat/cpu.h that can be dealt
    with in later patches. Let's also include plat/serial.h from common.h for
    all the board-*.c files. This allows making the include files local later
    on without patching these files again.
    
    Note that only minimal changes are done in this patch for the
    drivers/watchdog/omap_wdt.c driver to keep things compiling. Further
    patches are needed to eventually remove cpu_is_omap usage in the drivers.
    
    Also only minimal changes are done to sound/soc/omap/* to remove the
    unneeded includes and to define OMAP44XX_MCPDM_L3_BASE locally so there's
    no need to include omap44xx.h.
    
    While at it, also sort some of the includes in the standard way.
    
    Cc: linux-watchdog@vger.kernel.org
    Cc: alsa-devel@alsa-project.org
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Jarkko Nikula <jarkko.nikula@bitmer.com>
    Cc: Liam Girdwood <lrg@ti.com>
    Acked-by: Wim Van Sebroeck <wim@iguana.be>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 3223b81e7532..d1ff8399a222 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -15,9 +15,9 @@
 #include <linux/kernel.h>
 #include <linux/io.h>
 
-#include <plat/hardware.h>
 #include <plat/sdrc.h>
 
+#include "soc.h"
 #include "iomap.h"
 #include "common.h"
 #include "cm-regbits-34xx.h"

commit 90f1380ef6436a3f5425f942ea0b3f78e1cca142
Author: Omar Ramirez Luna <omar.luna@linaro.org>
Date:   Mon Jun 18 16:18:09 2012 -0600

    ARM: OMAP2+: control: new APIs to configure boot address and mode
    
    SCM contains boot addr and boot mode registers to control
    other processors on different OMAP versions. It controls the
    boot address and mode for DSP based subsystems like: IVA 2.1
    (OMAP2430), IVA 2.2 (OMAP3) and DSP (OMAP4).
    
    If contained within SCM registers, when a processor is
    booting it uses BOOTADDR to start running the code at that
    location. BOOTMOD register specifies a different set of
    modes for the processor to execute when booting (from direct,
    idle, self-loop, user and default).
    
    Since there was no offset associated with OMAP4, this patch
    defines it.
    
    Signed-off-by: Omar Ramirez Luna <omar.luna@linaro.org>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 08e674bb0417..3223b81e7532 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -241,6 +241,49 @@ void omap3_ctrl_write_boot_mode(u8 bootmode)
 
 #endif
 
+/**
+ * omap_ctrl_write_dsp_boot_addr - set boot address for a remote processor
+ * @bootaddr: physical address of the boot loader
+ *
+ * Set boot address for the boot loader of a supported processor
+ * when a power ON sequence occurs.
+ */
+void omap_ctrl_write_dsp_boot_addr(u32 bootaddr)
+{
+	u32 offset = cpu_is_omap243x() ? OMAP243X_CONTROL_IVA2_BOOTADDR :
+		     cpu_is_omap34xx() ? OMAP343X_CONTROL_IVA2_BOOTADDR :
+		     cpu_is_omap44xx() ? OMAP4_CTRL_MODULE_CORE_DSP_BOOTADDR :
+		     0;
+
+	if (!offset) {
+		pr_err("%s: unsupported omap type\n", __func__);
+		return;
+	}
+
+	omap_ctrl_writel(bootaddr, offset);
+}
+
+/**
+ * omap_ctrl_write_dsp_boot_mode - set boot mode for a remote processor
+ * @bootmode: 8-bit value to pass to some boot code
+ *
+ * Sets boot mode for the boot loader of a supported processor
+ * when a power ON sequence occurs.
+ */
+void omap_ctrl_write_dsp_boot_mode(u8 bootmode)
+{
+	u32 offset = cpu_is_omap243x() ? OMAP243X_CONTROL_IVA2_BOOTMOD :
+		     cpu_is_omap34xx() ? OMAP343X_CONTROL_IVA2_BOOTMOD :
+		     0;
+
+	if (!offset) {
+		pr_err("%s: unsupported omap type\n", __func__);
+		return;
+	}
+
+	omap_ctrl_writel(bootmode, offset);
+}
+
 #if defined(CONFIG_ARCH_OMAP3) && defined(CONFIG_PM)
 /*
  * Clears the scratchpad contents in case of cold boot-

commit 2b43e4e5863fb41d85c3a6583fdeea2ebf3d2b50
Author: Tony Lindgren <tony@atomide.com>
Date:   Sat Mar 3 09:47:45 2012 -0800

    ARM: OMAP2+: Fix build error after merge
    
    Commit 9890ce44 (ARM: get rid of asm/irq.h in asm/prom.h)
    removed include of asm/irq.h in asm/prom.h. This commit
    together with recent omap cleanup to remove io.h causes
    build breakage:
    
    arrch/arm/mach-omap2/control.c: In function 'omap3_ctrl_write_boot_mode':
    arch/arm/mach-omap2/control.c:238: error:
    'OMAP343X_CTRL_BASE' undeclared (first use in this function)
    ...
    
    Fix this by including hardware.h directly where needed
    instead of relying on asm/irq.h in asm/prom.h.
    
    Reported-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 2fd5fd1abb4f..08e674bb0417 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -15,6 +15,7 @@
 #include <linux/kernel.h>
 #include <linux/io.h>
 
+#include <plat/hardware.h>
 #include <plat/sdrc.h>
 
 #include "iomap.h"

commit ee0839c22cdda7f2e5f06e2d0351e2b49e0975ff
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Feb 24 10:34:35 2012 -0800

    ARM: OMAP2+: Move most of plat/io.h into local iomap.h
    
    There's no need to have these defines in plat/io.h.
    
    Note that we now need to ifdef omap_read/write calls
    as they will be available for omap1 only.
    
    While at it, clean up the includes to group them like
    they typically are grouped.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 114c037e433c..2fd5fd1abb4f 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -15,9 +15,10 @@
 #include <linux/kernel.h>
 #include <linux/io.h>
 
-#include "common.h"
 #include <plat/sdrc.h>
 
+#include "iomap.h"
+#include "common.h"
 #include "cm-regbits-34xx.h"
 #include "prm-regbits-34xx.h"
 #include "prm2xxx_3xxx.h"

commit 4e65331c6bb4a777bd61a4dac0daa9fc47777b63
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Nov 10 22:45:17 2011 +0100

    ARM: 7159/1: OMAP: Introduce local common.h files
    
    As suggested by Russell King - ARM Linux <linux@arm.linux.org.uk>,
    there's no need to keep local prototypes in non-local headers.
    
    Add mach-omap1/common.h and mach-omap2/common.h and move the
    local prototypes there from plat/common.h and mach/omap4-common.h.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index e34d27f8c49c..114c037e433c 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -15,7 +15,7 @@
 #include <linux/kernel.h>
 #include <linux/io.h>
 
-#include <plat/common.h>
+#include "common.h"
 #include <plat/sdrc.h>
 
 #include "cm-regbits-34xx.h"

commit 4c3cf90117f1f4906d5975aeccc5ffd414807fd2
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 4 18:17:41 2011 -0700

    ARM: OMAP: Move set_globals initialization to happen in init_early
    
    Otherwise we can't do generic map_io as we currently rely on
    static mappings that work only because of arch_ioremap.
    
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index aab884fecc55..e34d27f8c49c 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -149,17 +149,11 @@ static struct omap3_control_regs control_context;
 
 void __init omap2_set_globals_control(struct omap_globals *omap2_globals)
 {
-	/* Static mapping, never released */
-	if (omap2_globals->ctrl) {
-		omap2_ctrl_base = ioremap(omap2_globals->ctrl, SZ_4K);
-		WARN_ON(!omap2_ctrl_base);
-	}
+	if (omap2_globals->ctrl)
+		omap2_ctrl_base = omap2_globals->ctrl;
 
-	/* Static mapping, never released */
-	if (omap2_globals->ctrl_pad) {
-		omap4_ctrl_pad_base = ioremap(omap2_globals->ctrl_pad, SZ_4K);
-		WARN_ON(!omap4_ctrl_pad_base);
-	}
+	if (omap2_globals->ctrl_pad)
+		omap4_ctrl_pad_base = omap2_globals->ctrl_pad;
 }
 
 void __iomem *omap_ctrl_base_get(void)

commit 14c79bbed7e06135bcbccb2b92c19df7115b4502
Author: Kevin Hilman <khilman@ti.com>
Date:   Thu Jun 23 17:16:14 2011 -0700

    ARM: pm: omap34xx: remove get_*_restore_pointer functions, directly use entry points
    
    Upon return from off-mode, the ROM code jumps to a restore function
    saved in the scratchpad.  Based on SoC revision or errata, this
    restore entry point is different.  Current code uses some helper
    functions in sleep34xx.S (get_*_restore_pointer) to get the restore
    function entry point.
    
    When returning from off-mode, this code is executed from SDRAM, so
    there's no reason to use these helper functions when using the SDRAM
    entry points directly would work just fine.
    
    This patch uses ENTRY/ENDPROC to create "real" entry points for these
    functions, and uses those values directly when writing the scratchpad.
    
    Tested all three entry points
    - restore_es3: 3430/n900
    - restore_3630: 3630/Zoom3
    - restore: 3530/Overo
    
    Suggested-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index da53ba3917ca..aab884fecc55 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -286,14 +286,15 @@ void omap3_save_scratchpad_contents(void)
 	scratchpad_contents.boot_config_ptr = 0x0;
 	if (cpu_is_omap3630())
 		scratchpad_contents.public_restore_ptr =
-			virt_to_phys(get_omap3630_restore_pointer());
+			virt_to_phys(omap3_restore_3630);
 	else if (omap_rev() != OMAP3430_REV_ES3_0 &&
 					omap_rev() != OMAP3430_REV_ES3_1)
 		scratchpad_contents.public_restore_ptr =
-			virt_to_phys(get_restore_pointer());
+			virt_to_phys(omap3_restore);
 	else
 		scratchpad_contents.public_restore_ptr =
-			virt_to_phys(get_es3_restore_pointer());
+			virt_to_phys(omap3_restore_es3);
+
 	if (omap_type() == OMAP2_DEVICE_TYPE_GP)
 		scratchpad_contents.secure_ram_restore_ptr = 0x0;
 	else

commit a8ae645c014bc01090367de84f7601ad11628971
Author: Eduardo Valentin <eduardo.valentin@ti.com>
Date:   Wed Apr 13 18:21:07 2011 +0300

    OMAP3: PM: Do not rely on ROM code to restore CM_AUTOIDLE_PLL.AUTO_PERIPH_DPLL
    
    As per OMAP3 erratum (i671), ROM code adds extra latencies while
    restoring CM_AUTOIDLE_PLL register, if AUTO_PERIPH_DPLL is equal to 1.
    
    This patch stores 0's in scratchpad content area corresponding to
    AUTO_PERIPH_DPLL, to prevent ROM code to try to lock per DPLL, since
    it won't respect proper programing scheme.
    
    This register is then stored in prcm context. The saving and restore
    is now done by kernel side.
    
    Here follow the erratum description
    
    DESCRIPTION
    
    After OFF mode transition, among many restorations, the ROM Code restores the
    CM_AUTOIDLE_PLL register, and after that, it tries to relock the PER DPLL.
    
    In case the restoration data stored in scratchpad memory contains a field
    CM_AUTOIDLE_PLL.AUTO_PERIPH_DPLL = 1, then the way the ROM Code restores and
    locks the PER DPLL does not respect the PER DPLL programming scheme.
    
    In that case, the DPLL might not lock. Meanwhile, when trying to lock the PER
    DPLL, the ROM Code does not hang. Only extra latencies are introduced at
    wake-up.
    
    WORKAROUND
    
    When saving the context-restore structure in scratchpad memory, in order to
    respect the PER DPLL programming scheme, it is advised to store 0 in the
    CM_AUTOIDLE_PLL.AUTO_PERIPH_DPLL field of the saved structure.
    
    After wake-up, the application should store in CM_AUTOIDLE_PLL register the
    right desired value.
    
    Signed-off-by: Eduardo Valentin <eduardo.valentin@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index df0c75c31998..da53ba3917ca 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -316,8 +316,14 @@ void omap3_save_scratchpad_contents(void)
 			omap2_cm_read_mod_reg(WKUP_MOD, CM_CLKSEL);
 	prcm_block_contents.cm_clken_pll =
 			omap2_cm_read_mod_reg(PLL_MOD, CM_CLKEN);
+	/*
+	 * As per erratum i671, ROM code does not respect the PER DPLL
+	 * programming scheme if CM_AUTOIDLE_PLL..AUTO_PERIPH_DPLL == 1.
+	 * Then,  in anycase, clear these bits to avoid extra latencies.
+	 */
 	prcm_block_contents.cm_autoidle_pll =
-			omap2_cm_read_mod_reg(PLL_MOD, CM_AUTOIDLE);
+			omap2_cm_read_mod_reg(PLL_MOD, CM_AUTOIDLE) &
+			~OMAP3430_AUTO_PERIPH_DPLL_MASK;
 	prcm_block_contents.cm_clksel1_pll =
 			omap2_cm_read_mod_reg(PLL_MOD, OMAP3430_CM_CLKSEL1_PLL);
 	prcm_block_contents.cm_clksel2_pll =

commit 8bc2e98bcb280009cb0f85ce64e5f79b1669f9ff
Author: Eduardo Valentin <eduardo.valentin@ti.com>
Date:   Wed Apr 13 18:21:06 2011 +0300

    OMAP2+: PM: Fix the saving of CM_AUTOIDLE_PLL register on scratchpad area
    
    The saving of CCR.CM_AUTOIDLE_PLL is done in scratchpad area.
    
    However, in current code, the saving is done for CM_AUTOIDLE2_PLL
    (offset 0x34) instead of CM_AUTOIDLE_PLL (offset 0x30).
    
    This patch changes the code to save the correct register.
    
    Signed-off-by: Eduardo Valentin <eduardo.valentin@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 695279419020..df0c75c31998 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -317,7 +317,7 @@ void omap3_save_scratchpad_contents(void)
 	prcm_block_contents.cm_clken_pll =
 			omap2_cm_read_mod_reg(PLL_MOD, CM_CLKEN);
 	prcm_block_contents.cm_autoidle_pll =
-			omap2_cm_read_mod_reg(PLL_MOD, OMAP3430_CM_AUTOIDLE_PLL);
+			omap2_cm_read_mod_reg(PLL_MOD, CM_AUTOIDLE);
 	prcm_block_contents.cm_clksel1_pll =
 			omap2_cm_read_mod_reg(PLL_MOD, OMAP3430_CM_CLKSEL1_PLL);
 	prcm_block_contents.cm_clksel2_pll =

commit 596efe4792c50163578578bd4fe470f97652aad7
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 21 21:05:16 2010 -0700

    OMAP3: control/PM: move padconf save code to mach-omap2/control.c
    
    Move the padconf save code from pm34xx.c to the System Control Module
    code in mach-omap2/control.c.  This is part of the general push to
    move direct register access from middle-layer core code to low-level
    core code, so the middle-layer code can be abstracted to work on
    multiple platforms and cleaned up.
    
    In the medium-to-long term, this code should be called by the mux
    layer code, not the PM idle code.  This is because, according to the
    TRM, saving the padconf only needs to be done when the padconf
    changes[1].
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Tested-by: Rajendra Nayak <rnayak@ti.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    
    1. OMAP34xx Multimedia Device Silicon Revision 3.1.x [Rev. ZH] [SWPU222H]
       Section 4.11.4 "Device Off-Mode Sequences"

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 61101e807df1..695279419020 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -26,6 +26,10 @@
 #include "pm.h"
 #include "control.h"
 
+/* Used by omap3_ctrl_save_padconf() */
+#define START_PADCONF_SAVE		0x2
+#define PADCONF_SAVE_DONE		0x1
+
 static void __iomem *omap2_ctrl_base;
 static void __iomem *omap4_ctrl_pad_base;
 
@@ -530,4 +534,31 @@ void omap3630_ctrl_disable_rta(void)
 	omap_ctrl_writel(OMAP36XX_RTA_DISABLE, OMAP36XX_CONTROL_MEM_RTA_CTRL);
 }
 
+/**
+ * omap3_ctrl_save_padconf - save padconf registers to scratchpad RAM
+ *
+ * Tell the SCM to start saving the padconf registers, then wait for
+ * the process to complete.  Returns 0 unconditionally, although it
+ * should also eventually be able to return -ETIMEDOUT, if the save
+ * does not complete.
+ *
+ * XXX This function is missing a timeout.  What should it be?
+ */
+int omap3_ctrl_save_padconf(void)
+{
+	u32 cpo;
+
+	/* Save the padconf registers */
+	cpo = omap_ctrl_readl(OMAP343X_CONTROL_PADCONF_OFF);
+	cpo |= START_PADCONF_SAVE;
+	omap_ctrl_writel(cpo, OMAP343X_CONTROL_PADCONF_OFF);
+
+	/* wait for the save to complete */
+	while (!(omap_ctrl_readl(OMAP343X_CONTROL_GENERAL_PURPOSE_STATUS)
+		 & PADCONF_SAVE_DONE))
+		udelay(1);
+
+	return 0;
+}
+
 #endif /* CONFIG_ARCH_OMAP3 && CONFIG_PM */

commit c4d7e58fb52c632d8e33cd23a4917d7a7f8302ac
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 21 21:05:14 2010 -0700

    OMAP2/3: PRM/CM: prefix OMAP2 PRM/CM functions with "omap2_"
    
    Now that OMAP4-specific PRCM functions have been added, distinguish the
    existing OMAP2/3-specific PRCM functions by prefixing them with "omap2_".
    
    This patch should not result in any functional change.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Jarkko Nikula <jhnikula@gmail.com>
    Cc: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Cc: Liam Girdwood <lrg@slimlogic.co.uk>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Rajendra Nayak <rnayak@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 2506edfc4acb..61101e807df1 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -252,13 +252,13 @@ void omap3_clear_scratchpad_contents(void)
 	void __iomem *v_addr;
 	u32 offset = 0;
 	v_addr = OMAP2_L4_IO_ADDRESS(OMAP343X_SCRATCHPAD_ROM);
-	if (prm_read_mod_reg(OMAP3430_GR_MOD, OMAP3_PRM_RSTST_OFFSET) &
+	if (omap2_prm_read_mod_reg(OMAP3430_GR_MOD, OMAP3_PRM_RSTST_OFFSET) &
 	    OMAP3430_GLOBAL_COLD_RST_MASK) {
 		for ( ; offset <= max_offset; offset += 0x4)
 			__raw_writel(0x0, (v_addr + offset));
-		prm_set_mod_reg_bits(OMAP3430_GLOBAL_COLD_RST_MASK,
-				     OMAP3430_GR_MOD,
-				     OMAP3_PRM_RSTST_OFFSET);
+		omap2_prm_set_mod_reg_bits(OMAP3430_GLOBAL_COLD_RST_MASK,
+					   OMAP3430_GR_MOD,
+					   OMAP3_PRM_RSTST_OFFSET);
 	}
 }
 
@@ -300,32 +300,34 @@ void omap3_save_scratchpad_contents(void)
 	scratchpad_contents.sdrc_block_offset = 0x64;
 
 	/* Populate the PRCM block contents */
-	prcm_block_contents.prm_clksrc_ctrl = prm_read_mod_reg(OMAP3430_GR_MOD,
-			OMAP3_PRM_CLKSRC_CTRL_OFFSET);
-	prcm_block_contents.prm_clksel = prm_read_mod_reg(OMAP3430_CCR_MOD,
-			OMAP3_PRM_CLKSEL_OFFSET);
+	prcm_block_contents.prm_clksrc_ctrl =
+		omap2_prm_read_mod_reg(OMAP3430_GR_MOD,
+				       OMAP3_PRM_CLKSRC_CTRL_OFFSET);
+	prcm_block_contents.prm_clksel =
+		omap2_prm_read_mod_reg(OMAP3430_CCR_MOD,
+				       OMAP3_PRM_CLKSEL_OFFSET);
 	prcm_block_contents.cm_clksel_core =
-			cm_read_mod_reg(CORE_MOD, CM_CLKSEL);
+			omap2_cm_read_mod_reg(CORE_MOD, CM_CLKSEL);
 	prcm_block_contents.cm_clksel_wkup =
-			cm_read_mod_reg(WKUP_MOD, CM_CLKSEL);
+			omap2_cm_read_mod_reg(WKUP_MOD, CM_CLKSEL);
 	prcm_block_contents.cm_clken_pll =
-			cm_read_mod_reg(PLL_MOD, CM_CLKEN);
+			omap2_cm_read_mod_reg(PLL_MOD, CM_CLKEN);
 	prcm_block_contents.cm_autoidle_pll =
-			cm_read_mod_reg(PLL_MOD, OMAP3430_CM_AUTOIDLE_PLL);
+			omap2_cm_read_mod_reg(PLL_MOD, OMAP3430_CM_AUTOIDLE_PLL);
 	prcm_block_contents.cm_clksel1_pll =
-			cm_read_mod_reg(PLL_MOD, OMAP3430_CM_CLKSEL1_PLL);
+			omap2_cm_read_mod_reg(PLL_MOD, OMAP3430_CM_CLKSEL1_PLL);
 	prcm_block_contents.cm_clksel2_pll =
-			cm_read_mod_reg(PLL_MOD, OMAP3430_CM_CLKSEL2_PLL);
+			omap2_cm_read_mod_reg(PLL_MOD, OMAP3430_CM_CLKSEL2_PLL);
 	prcm_block_contents.cm_clksel3_pll =
-			cm_read_mod_reg(PLL_MOD, OMAP3430_CM_CLKSEL3);
+			omap2_cm_read_mod_reg(PLL_MOD, OMAP3430_CM_CLKSEL3);
 	prcm_block_contents.cm_clken_pll_mpu =
-			cm_read_mod_reg(MPU_MOD, OMAP3430_CM_CLKEN_PLL);
+			omap2_cm_read_mod_reg(MPU_MOD, OMAP3430_CM_CLKEN_PLL);
 	prcm_block_contents.cm_autoidle_pll_mpu =
-			cm_read_mod_reg(MPU_MOD, OMAP3430_CM_AUTOIDLE_PLL);
+			omap2_cm_read_mod_reg(MPU_MOD, OMAP3430_CM_AUTOIDLE_PLL);
 	prcm_block_contents.cm_clksel1_pll_mpu =
-			cm_read_mod_reg(MPU_MOD, OMAP3430_CM_CLKSEL1_PLL);
+			omap2_cm_read_mod_reg(MPU_MOD, OMAP3430_CM_CLKSEL1_PLL);
 	prcm_block_contents.cm_clksel2_pll_mpu =
-			cm_read_mod_reg(MPU_MOD, OMAP3430_CM_CLKSEL2_PLL);
+			omap2_cm_read_mod_reg(MPU_MOD, OMAP3430_CM_CLKSEL2_PLL);
 	prcm_block_contents.prcm_block_size = 0x0;
 
 	/* Populate the SDRC block contents */

commit 59fb659b065f52fcc2deed293cfbfc58f890376c
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 21 15:30:55 2010 -0700

    OMAP2/3: PRCM: split OMAP2/3-specific PRCM code into OMAP2/3-specific files
    
    In preparation for adding OMAP4-specific PRCM accessor/mutator
    functions, split the existing OMAP2/3 PRCM code into OMAP2/3-specific
    files.  Most of what was in mach-omap2/{cm,prm}.{c,h} has now been
    moved into mach-omap2/{cm,prm}2xxx_3xxx.{c,h}, since it was
    OMAP2xxx/3xxx-specific.
    
    This process also requires the #includes in each of these files to be
    changed to reference the new file name.  As part of doing so, add some
    comments into plat-omap/sram.c and plat-omap/mcbsp.c, which use
    "sideways includes", to indicate that these users of the PRM/CM includes
    should not be doing so.
    
    Thanks to Felipe Contreras <felipe.contreras@gmail.com> for comments on this
    patch.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Jarkko Nikula <jhnikula@gmail.com>
    Cc: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Cc: Liam Girdwood <lrg@slimlogic.co.uk>
    Cc: Omar Ramirez Luna <omar.ramirez@ti.com>
    Acked-by: Omar Ramirez Luna <omar.ramirez@ti.com>
    Cc: Felipe Contreras <felipe.contreras@gmail.com>
    Acked-by: Felipe Contreras <felipe.contreras@gmail.com>
    Cc: Greg Kroah-Hartman <greg@kroah.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Kevin Hilman <khilman@deeprootsystems.com>
    Tested-by: Kevin Hilman <khilman@deeprootsystems.com>
    Tested-by: Rajendra Nayak <rnayak@ti.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index b066c6e110a6..2506edfc4acb 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -20,8 +20,8 @@
 
 #include "cm-regbits-34xx.h"
 #include "prm-regbits-34xx.h"
-#include "cm.h"
-#include "prm.h"
+#include "prm2xxx_3xxx.h"
+#include "cm2xxx_3xxx.h"
 #include "sdrc.h"
 #include "pm.h"
 #include "control.h"

commit f5f9d132d1c212bf3828c7926d95f79e0c20d243
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 21 15:30:53 2010 -0700

    OMAP3: control/PRCM: move CONTROL_PADCONF_SYS_NIRQ save/restore to SCM code
    
    For some reason, the PRCM context save/restore code also saves and
    restores a single System Control Module register,
    CONTROL_PADCONF_SYS_NIRQ.  This is probably just an error -- the
    register should be handled by SCM code -- so this patch moves it
    there.
    
    If this register really does need to be saved and restored before the
    rest of the PRCM registers, the code to do so should live in the SCM
    code, and the PM code should call this separate function.  This
    register pertains to devices with a stacked modem, so this patch is
    unlikely to affect most OMAP devices out there.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Reviewed-by: Kevin Hilman <khilman@deeprootsystems.com>
    Tested-by: Kevin Hilman <khilman@deeprootsystems.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Rajendra Nayak <rnayak@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index d058f7c3ec6a..b066c6e110a6 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -134,6 +134,7 @@ struct omap3_control_regs {
 	u32 sramldo4;
 	u32 sramldo5;
 	u32 csi;
+	u32 padconf_sys_nirq;
 };
 
 static struct omap3_control_regs control_context;
@@ -457,6 +458,8 @@ void omap3_control_save_context(void)
 	control_context.sramldo4 = omap_ctrl_readl(OMAP343X_CONTROL_SRAMLDO4);
 	control_context.sramldo5 = omap_ctrl_readl(OMAP343X_CONTROL_SRAMLDO5);
 	control_context.csi = omap_ctrl_readl(OMAP343X_CONTROL_CSI);
+	control_context.padconf_sys_nirq =
+		omap_ctrl_readl(OMAP343X_CONTROL_PADCONF_SYSNIRQ);
 	return;
 }
 
@@ -513,6 +516,8 @@ void omap3_control_restore_context(void)
 	omap_ctrl_writel(control_context.sramldo4, OMAP343X_CONTROL_SRAMLDO4);
 	omap_ctrl_writel(control_context.sramldo5, OMAP343X_CONTROL_SRAMLDO5);
 	omap_ctrl_writel(control_context.csi, OMAP343X_CONTROL_CSI);
+	omap_ctrl_writel(control_context.padconf_sys_nirq,
+			 OMAP343X_CONTROL_PADCONF_SYSNIRQ);
 	return;
 }
 

commit 166353bd75587a2158d713af1b9489a79e0ce297
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 21 20:01:21 2010 -0700

    OMAP3: control/PRCM: add omap3_ctrl_write_boot_mode()
    
    Get rid of the open-coded scratchpad write in mach-omap2/prcm.c and
    replace it with an actual API, omap3_ctrl_write_boot_mode().  While
    there, get rid of the gratuitous omap_writel().
    
    There's not much documentation available for what should wind up in
    the scratchpad here, so more documentation would be appreciated.
    Also, at some point, we should formalize our treatment of the scratchpad;
    right now, accesses to the scratchpad are not well-documented.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Reviewed-by: Kevin Hilman <khilman@deeprootsystems.com>
    Tested-by: Kevin Hilman <khilman@deeprootsystems.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 0269bb055b69..d058f7c3ec6a 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -209,6 +209,37 @@ void omap4_ctrl_pad_writel(u32 val, u16 offset)
 	__raw_writel(val, OMAP4_CTRL_PAD_REGADDR(offset));
 }
 
+#ifdef CONFIG_ARCH_OMAP3
+
+/**
+ * omap3_ctrl_write_boot_mode - set scratchpad boot mode for the next boot
+ * @bootmode: 8-bit value to pass to some boot code
+ *
+ * Set the bootmode in the scratchpad RAM.  This is used after the
+ * system restarts.  Not sure what actually uses this - it may be the
+ * bootloader, rather than the boot ROM - contrary to the preserved
+ * comment below.  No return value.
+ */
+void omap3_ctrl_write_boot_mode(u8 bootmode)
+{
+	u32 l;
+
+	l = ('B' << 24) | ('M' << 16) | bootmode;
+
+	/*
+	 * Reserve the first word in scratchpad for communicating
+	 * with the boot ROM. A pointer to a data structure
+	 * describing the boot process can be stored there,
+	 * cf. OMAP34xx TRM, Initialization / Software Booting
+	 * Configuration.
+	 *
+	 * XXX This should use some omap_ctrl_writel()-type function
+	 */
+	__raw_writel(l, OMAP2_L4_IO_ADDRESS(OMAP343X_SCRATCHPAD + 4));
+}
+
+#endif
+
 #if defined(CONFIG_ARCH_OMAP3) && defined(CONFIG_PM)
 /*
  * Clears the scratchpad contents in case of cold boot-

commit f7dfe3d8a98b7c4869c09826e3a65663cb9c71be
Author: Jean Pihet <j-pihet@ti.com>
Date:   Sat Dec 18 16:44:45 2010 +0100

    OMAP3: rework of the ASM sleep code execution paths
    
    - Reworked and simplified the execution paths for better
      readability and to avoid duplication of code,
    - Added comments on the entry and exit points and the interaction
      with the ROM code for OFF mode restore,
    - Reworked the existing comments for better readability.
    
    Tested on N900 and Beagleboard with full RET and OFF modes,
    using cpuidle and suspend.
    
    Signed-off-by: Jean Pihet <j-pihet@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 27ed558fdf54..0269bb055b69 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -239,7 +239,14 @@ void omap3_save_scratchpad_contents(void)
 	struct omap3_scratchpad_prcm_block prcm_block_contents;
 	struct omap3_scratchpad_sdrc_block sdrc_block_contents;
 
-	/* Populate the Scratchpad contents */
+	/*
+	 * Populate the Scratchpad contents
+	 *
+	 * The "get_*restore_pointer" functions are used to provide a
+	 * physical restore address where the ROM code jumps while waking
+	 * up from MPU OFF/OSWR state.
+	 * The restore pointer is stored into the scratchpad.
+	 */
 	scratchpad_contents.boot_config_ptr = 0x0;
 	if (cpu_is_omap3630())
 		scratchpad_contents.public_restore_ptr =

commit 458e999eb14a301d4176783c8fcb277f5d009b4e
Author: Nishanth Menon <nm@ti.com>
Date:   Mon Dec 20 14:05:06 2010 -0600

    OMAP3630: PM: Erratum i608: disable RTA
    
    Erratum id: i608
    RTA (Retention Till Access) feature is not supported and leads to device
    stability issues when enabled. This impacts modules with embedded memories
    on OMAP3630
    
    Workaround is to disable RTA on boot and coming out of core off.
    For disabling RTA coming out of off mode, we do this by overriding the
    restore pointer for 3630 as the first point of entry before caches are
    touched and is common for GP and HS devices. To disable earlier than
    this could be possible by modifying the PPA for HS devices, but not for
    GP devices.
    
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Tony Lindgren <tony@atomide.com>
    
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    
    [ambresh@ti.com: co-developer]
    Signed-off-by: Ambresh K <ambresh@ti.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 1fa3294b6048..27ed558fdf54 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -241,7 +241,10 @@ void omap3_save_scratchpad_contents(void)
 
 	/* Populate the Scratchpad contents */
 	scratchpad_contents.boot_config_ptr = 0x0;
-	if (omap_rev() != OMAP3430_REV_ES3_0 &&
+	if (cpu_is_omap3630())
+		scratchpad_contents.public_restore_ptr =
+			virt_to_phys(get_omap3630_restore_pointer());
+	else if (omap_rev() != OMAP3430_REV_ES3_0 &&
 					omap_rev() != OMAP3430_REV_ES3_1)
 		scratchpad_contents.public_restore_ptr =
 			virt_to_phys(get_restore_pointer());
@@ -474,4 +477,12 @@ void omap3_control_restore_context(void)
 	omap_ctrl_writel(control_context.csi, OMAP343X_CONTROL_CSI);
 	return;
 }
+
+void omap3630_ctrl_disable_rta(void)
+{
+	if (!cpu_is_omap3630())
+		return;
+	omap_ctrl_writel(OMAP36XX_RTA_DISABLE, OMAP36XX_CONTROL_MEM_RTA_CTRL);
+}
+
 #endif /* CONFIG_ARCH_OMAP3 && CONFIG_PM */

commit 4814ced5116e3b73dc4f63eec84999739fc8ed11
Author: Paul Walmsley <paul@pwsan.com>
Date:   Fri Oct 8 11:40:20 2010 -0600

    OMAP: control: move plat-omap/control.h to mach-omap2/control.h
    
    Only OMAP2+ platforms have the System Control Module (SCM) IP block.
    In the past, we've kept the SCM header file in plat-omap.  This has
    led to abuse - device drivers including it; includes being added that
    create implicit dependencies on OMAP2+ builds; etc.
    
    In response, move the SCM headers into mach-omap2/.
    
    As part of this, remove the direct SCM access from the OMAP UDC
    driver.  It was clearly broken.  The UDC code needs an indepth review for
    use on OMAP2+ chips.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Cory Maccarrone <darkstar6262@gmail.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 5d9b30dd6e56..1fa3294b6048 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -16,14 +16,15 @@
 #include <linux/io.h>
 
 #include <plat/common.h>
-#include <plat/control.h>
 #include <plat/sdrc.h>
+
 #include "cm-regbits-34xx.h"
 #include "prm-regbits-34xx.h"
 #include "cm.h"
 #include "prm.h"
 #include "sdrc.h"
 #include "pm.h"
+#include "control.h"
 
 static void __iomem *omap2_ctrl_base;
 static void __iomem *omap4_ctrl_pad_base;

commit 38815733972655ee3cbfc34e254c403c332693c3
Author: Manjunath Kondaiah G <manjugk@ti.com>
Date:   Fri Oct 8 09:56:37 2010 -0700

    OMAP: mach-omap2: Fix static declaration warnings
    
    This patch fixes sparse warnings due to non declaration of
    static structures and variables.
    
    Sparse warning logs fixed:
    arch/arm/mach-omap2/control.c:88:6: warning: symbol 'omap3_secure_ram_storage' was not declared. Should it be static?
    n
    arch/arm/mach-omap2/timer-gp.c:50:22: warning: symbol 'gptimer_wakeup' was not declared. Should it be static?
    arch/arm/mach-omap2/timer-gp.c:240:18: warning: symbol 'omap_timer' was not declared. Should it be static?
    arch/arm/mach-omap2/prcm.c:121:24: warning: symbol 'prcm_context' was not declared. Should it be static?
    arch/arm/mach-omap2/mux2420.c:510:29: warning: symbol 'omap2420_pop_ball' was not declared. Should it be static?
    arch/arm/mach-omap2/mux2430.c:589:29: warning: symbol 'omap2430_pop_ball' was not declared. Should it be static?
    arch/arm/mach-omap2/mux34xx.c:934:28: warning: symbol 'omap3_cus_subset' was not declared. Should it be static?
    arch/arm/mach-omap2/mux34xx.c:1080:29: warning: symbol 'omap3_cus_ball' was not declared. Should it be static?
    arch/arm/mach-omap2/mux34xx.c:1272:28: warning: symbol 'omap3_cbb_subset' was not declared. Should it be static?
    arch/arm/mach-omap2/mux34xx.c:1393:29: warning: symbol 'omap3_cbb_ball' was not declared. Should it be static?
    arch/arm/mach-omap2/mux34xx.c:1603:28: warning: symbol 'omap36xx_cbp_subset' was not declared. Should it be static?
    arch/arm/mach-omap2/mux34xx.c:1821:29: warning: symbol 'omap36xx_cbp_ball' was not declared. Should it be static?
    arch/arm/mach-omap2/pm-debug.c:165:15: warning: symbol 'pm_dbg_dir' was not declared. Should it be static?
    arch/arm/mach-omap2/board-omap3evm.c:587:30: warning: symbol 'ads7846_config' was not declared. Should it be static?
    arch/arm/mach-omap2/board-omap3evm.c:606:23: warning: symbol 'omap3evm_spi_board_info' was not declared. Should it be static?
    arch/arm/mach-omap2/board-rx51-sdram.c:46:25: warning: symbol 'rx51_sdrc_params' was not declared. Should it be static?
    arch/arm/mach-omap2/board-rx51-sdram.c:211:25: warning: symbol 'rx51_get_sdram_timings' was not declared. Should it be static?
    arch/arm/mach-omap2/board-omap3touchbook.c:64:15: warning: symbol 'touchbook_revision' was not declared. Should it be static?
    arch/arm/mach-omap2/board-am3517evm.c:350:24: warning: symbol 'am3517_evm_dss_device' was not declared. Should it be static?
    arch/arm/mach-omap2/board-omap3stalker.c:567:23: warning: symbol 'omap3stalker_spi_board_info' was not declared. Should it be static?
    
    Signed-off-by: Manjunath Kondaiah G <manjugk@ti.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index d21faba3866b..5d9b30dd6e56 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -23,6 +23,7 @@
 #include "cm.h"
 #include "prm.h"
 #include "sdrc.h"
+#include "pm.h"
 
 static void __iomem *omap2_ctrl_base;
 static void __iomem *omap4_ctrl_pad_base;

commit 4d63bc1de704c6f413979261bf42781cf364eb14
Author: Manjunath Kondaiah G <manjugk@ti.com>
Date:   Fri Oct 8 09:56:11 2010 -0700

    OMAP: mach-omap2: Fix incorrect assignment warnings
    
    This patch fixes below sparse warnings for incorrect assignments.
    
    arch/arm/mach-omap2/control.c:195:16: warning: incorrect type in assignment (different address spaces)
    arch/arm/mach-omap2/control.c:195:16:    expected unsigned int [usertype] *v_addr
    arch/arm/mach-omap2/control.c:195:16:    got void [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/control.c:199:25: warning: incorrect type in argument 1 (different address spaces)
    arch/arm/mach-omap2/control.c:199:25:    expected void const volatile [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/control.c:199:25:    got unsigned int [usertype] *
    arch/arm/mach-omap2/control.c:320:28: warning: incorrect type in assignment (different address spaces)
    arch/arm/mach-omap2/control.c:320:28:    expected void *[noderef] <asn:2>scratchpad_address
    arch/arm/mach-omap2/control.c:320:28:    got void [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/control.c:321:9: warning: incorrect type in argument 1 (different address spaces)
    arch/arm/mach-omap2/control.c:321:9:    expected void volatile [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/control.c:321:9:    got void *[noderef] <asn:2>scratchpad_address
    arch/arm/mach-omap2/control.c:324:9: warning: incorrect type in argument 1 (different address spaces)
    arch/arm/mach-omap2/control.c:324:9:    expected void volatile [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/control.c:324:9:    got void *
    arch/arm/mach-omap2/control.c:327:9: warning: incorrect type in argument 1 (different address spaces)
    arch/arm/mach-omap2/control.c:327:9:    expected void volatile [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/control.c:327:9:    got void *
    arch/arm/mach-omap2/control.c:334:9: warning: incorrect type in argument 1 (different address spaces)
    arch/arm/mach-omap2/control.c:334:9:    expected void volatile [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/control.c:334:9:    got void *
    arch/arm/mach-omap2/control.c:321:9: warning: dereference of noderef expression
    arch/arm/mach-omap2/control.c:324:9: warning: dereference of noderef expression
    arch/arm/mach-omap2/control.c:327:9: warning: dereference of noderef expression
    arch/arm/mach-omap2/control.c:334:9: warning: dereference of noderef expression
    
    arch/arm/mach-omap2/pm34xx.c:323:28: warning: incorrect type in assignment (different address spaces)
    arch/arm/mach-omap2/pm34xx.c:323:28:    expected unsigned int [usertype] *scratchpad_address
    arch/arm/mach-omap2/pm34xx.c:323:28:    got void [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/pm34xx.c:326:26: warning: incorrect type in argument 1 (different address spaces)
    arch/arm/mach-omap2/pm34xx.c:326:26:    expected void const volatile [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/pm34xx.c:326:26:    got unsigned int [usertype] *
    arch/arm/mach-omap2/pm34xx.c:329:26: warning: incorrect type in argument 1 (different address spaces)
    arch/arm/mach-omap2/pm34xx.c:329:26:    expected void const volatile [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/pm34xx.c:329:26:    got unsigned int [usertype] *
    arch/arm/mach-omap2/pm34xx.c:334:29: warning: incorrect type in argument 1 (different address spaces)
    arch/arm/mach-omap2/pm34xx.c:334:29:    expected void const volatile [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/pm34xx.c:334:29:    got unsigned int [usertype] *
    
    Signed-off-by: Manjunath Kondaiah G <manjugk@ti.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 8b3c469e7bcd..d21faba3866b 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -215,7 +215,7 @@ void omap4_ctrl_pad_writel(u32 val, u16 offset)
 void omap3_clear_scratchpad_contents(void)
 {
 	u32 max_offset = OMAP343X_SCRATCHPAD_ROM_OFFSET;
-	u32 *v_addr;
+	void __iomem *v_addr;
 	u32 offset = 0;
 	v_addr = OMAP2_L4_IO_ADDRESS(OMAP343X_SCRATCHPAD_ROM);
 	if (prm_read_mod_reg(OMAP3430_GR_MOD, OMAP3_PRM_RSTST_OFFSET) &
@@ -231,7 +231,7 @@ void omap3_clear_scratchpad_contents(void)
 /* Populate the scratchpad structure with restore structure */
 void omap3_save_scratchpad_contents(void)
 {
-	void * __iomem scratchpad_address;
+	void  __iomem *scratchpad_address;
 	u32 arm_context_addr;
 	struct omap3_scratchpad scratchpad_contents;
 	struct omap3_scratchpad_prcm_block prcm_block_contents;

commit 70ba71a25e02ef7b8796723c8615955620e465ff
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Mon Sep 27 14:02:57 2010 -0600

    omap4: control: Add accessor api's for pad control module
    
    On OMAP4 control pad are not addressable from control
    core base. So the common omap_ctrl_read/write APIs breaks
    Hence export separate APIs to manage the omap4 pad control
    registers.
    
    This APIs will work only for OMAP4
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 99c0eb645d4d..8b3c469e7bcd 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -138,6 +138,7 @@ static struct omap3_control_regs control_context;
 #endif /* CONFIG_ARCH_OMAP3 && CONFIG_PM */
 
 #define OMAP_CTRL_REGADDR(reg)		(omap2_ctrl_base + (reg))
+#define OMAP4_CTRL_PAD_REGADDR(reg)	(omap4_ctrl_pad_base + (reg))
 
 void __init omap2_set_globals_control(struct omap_globals *omap2_globals)
 {
@@ -189,6 +190,23 @@ void omap_ctrl_writel(u32 val, u16 offset)
 	__raw_writel(val, OMAP_CTRL_REGADDR(offset));
 }
 
+/*
+ * On OMAP4 control pad are not addressable from control
+ * core base. So the common omap_ctrl_read/write APIs breaks
+ * Hence export separate APIs to manage the omap4 pad control
+ * registers. This APIs will work only for OMAP4
+ */
+
+u32 omap4_ctrl_pad_readl(u16 offset)
+{
+	return __raw_readl(OMAP4_CTRL_PAD_REGADDR(offset));
+}
+
+void omap4_ctrl_pad_writel(u32 val, u16 offset)
+{
+	__raw_writel(val, OMAP4_CTRL_PAD_REGADDR(offset));
+}
+
 #if defined(CONFIG_ARCH_OMAP3) && defined(CONFIG_PM)
 /*
  * Clears the scratchpad contents in case of cold boot-

commit 0c3492467c99f3d0d83a48012ee6e672b016759c
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Mon Sep 27 14:02:57 2010 -0600

    omap4: control: Add ctrl_pad_base to omap_globals
    
    On omap4 control module is divided in four IP blocks.
    - CTRL_MODULE_CORE                      0x4a002000
    - CTRL_MODULE_PAD_CORE          0x4a100000
    - CTRL_MODULE_WKUP                      0x4a30c000
    - CTRL_MODULE_PAD_WKUP          0x4a31e000
    
    Addressing all the modules with single base address is not possible
    considering 16 bit offsets. The mux code manages the pad core and pad
    wakeup related base address inside the mux framework. For other usage
    only control core and control pad bases are necessary. So this patch
    maps only needed pad control base address which is used by device drivers
    and infrastructure code
    
    The main control core base is still kept same in this patch to
    keep git-bisect working. This will be fixed in the relevant patch
    in this series.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index a8d20eef2306..99c0eb645d4d 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -25,6 +25,7 @@
 #include "sdrc.h"
 
 static void __iomem *omap2_ctrl_base;
+static void __iomem *omap4_ctrl_pad_base;
 
 #if defined(CONFIG_ARCH_OMAP3) && defined(CONFIG_PM)
 struct omap3_scratchpad {
@@ -145,6 +146,12 @@ void __init omap2_set_globals_control(struct omap_globals *omap2_globals)
 		omap2_ctrl_base = ioremap(omap2_globals->ctrl, SZ_4K);
 		WARN_ON(!omap2_ctrl_base);
 	}
+
+	/* Static mapping, never released */
+	if (omap2_globals->ctrl_pad) {
+		omap4_ctrl_pad_base = ioremap(omap2_globals->ctrl_pad, SZ_4K);
+		WARN_ON(!omap4_ctrl_pad_base);
+	}
 }
 
 void __iomem *omap_ctrl_base_get(void)

commit 2bc4ef71c5a3b6986b452d6c530777974d11ef4a
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue May 18 18:47:24 2010 -0600

    OMAP3 PRCM: convert OMAP3 PRCM macros to the _SHIFT/_MASK suffixes
    
    Fix all of the remaining OMAP3 PRCM register shift/bitmask macros that
    did not use the _SHIFT/_MASK suffixes to use them.  This makes the use
    of these macros consistent.  It is intended to reduce error, as code
    can be inspected visually by reviewers to ensure that bitshifts and
    bitmasks are used in the appropriate places.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 43f8a33655d4..a8d20eef2306 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -194,11 +194,12 @@ void omap3_clear_scratchpad_contents(void)
 	u32 offset = 0;
 	v_addr = OMAP2_L4_IO_ADDRESS(OMAP343X_SCRATCHPAD_ROM);
 	if (prm_read_mod_reg(OMAP3430_GR_MOD, OMAP3_PRM_RSTST_OFFSET) &
-		OMAP3430_GLOBAL_COLD_RST) {
+	    OMAP3430_GLOBAL_COLD_RST_MASK) {
 		for ( ; offset <= max_offset; offset += 0x4)
 			__raw_writel(0x0, (v_addr + offset));
-		prm_set_mod_reg_bits(OMAP3430_GLOBAL_COLD_RST, OMAP3430_GR_MOD,
-			OMAP3_PRM_RSTST_OFFSET);
+		prm_set_mod_reg_bits(OMAP3430_GLOBAL_COLD_RST_MASK,
+				     OMAP3430_GR_MOD,
+				     OMAP3_PRM_RSTST_OFFSET);
 	}
 }
 

commit b7ebb10b0a9793effa4a74a3c29049b44c6b8176
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Mon Feb 15 18:03:37 2010 +0530

    omap2/3/4: ioremap omap_globals module
    
    This is a clean-up patch towards dynamic allocation of IO space
    instead of using harcoded macros to calculate virtual addresses.
    
    Also update the sdrc, prcm and control module to allocate
    iospace dynamically
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Reviewed-by: Kevin Hilman <khilman@deeprootsystems.com>
    Reviewed-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index cdd1f35636dd..43f8a33655d4 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -140,7 +140,11 @@ static struct omap3_control_regs control_context;
 
 void __init omap2_set_globals_control(struct omap_globals *omap2_globals)
 {
-	omap2_ctrl_base = omap2_globals->ctrl;
+	/* Static mapping, never released */
+	if (omap2_globals->ctrl) {
+		omap2_ctrl_base = ioremap(omap2_globals->ctrl, SZ_4K);
+		WARN_ON(!omap2_ctrl_base);
+	}
 }
 
 void __iomem *omap_ctrl_base_get(void)

commit f265dc4c5d39f2bd369d97c87a7bd89061b159d4
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Tue Jun 9 22:30:41 2009 +0530

    OMAP3: PM: Program SDRC to send self refresh on timeout of AUTO_CNT
    
    Due to an OMAP3 errata (1.142), on HS/EMU devices SDRC should be
    programed to issue automatic self refresh on timeout
    of AUTO_CNT = 1 prior to any transition to OFF mode.
    This is needed only on sil rev's ES3.0 and above.
    
    This patch enables the above needed WA in the SDRC power register
    value stored in scratchpad, so that ROM code restores this value
    in SDRC POWER on the wakeup path.
    The original SDRC POWER register value is stored and restored back
    in omap_sram_idle() function.
    
    This fixes some random crashes observed while stressing suspend
    on HS/EMU devices.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Kalle Jokiniemi <kalle.jokiniemi@digia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 2ff8d7cc60a2..cdd1f35636dd 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -265,7 +265,21 @@ void omap3_save_scratchpad_contents(void)
 			(sdrc_read_reg(SDRC_ERR_TYPE) & 0xFFFF);
 	sdrc_block_contents.dll_a_ctrl = sdrc_read_reg(SDRC_DLLA_CTRL);
 	sdrc_block_contents.dll_b_ctrl = 0x0;
-	sdrc_block_contents.power = sdrc_read_reg(SDRC_POWER);
+	/*
+	 * Due to a OMAP3 errata (1.142), on EMU/HS devices SRDC should
+	 * be programed to issue automatic self refresh on timeout
+	 * of AUTO_CNT = 1 prior to any transition to OFF mode.
+	 */
+	if ((omap_type() != OMAP2_DEVICE_TYPE_GP)
+			&& (omap_rev() >= OMAP3430_REV_ES3_0))
+		sdrc_block_contents.power = (sdrc_read_reg(SDRC_POWER) &
+				~(SDRC_POWER_AUTOCOUNT_MASK|
+				SDRC_POWER_CLKCTRL_MASK)) |
+				(1 << SDRC_POWER_AUTOCOUNT_SHIFT) |
+				SDRC_SELF_REFRESH_ON_AUTOCOUNT;
+	else
+		sdrc_block_contents.power = sdrc_read_reg(SDRC_POWER);
+
 	sdrc_block_contents.cs_0 = 0x0;
 	sdrc_block_contents.mcfg_0 = sdrc_read_reg(SDRC_MCFG_0);
 	sdrc_block_contents.mr_0 = (sdrc_read_reg(SDRC_MR_0) & 0xFFFF);

commit 0795a75a369b931150074a14473f024359b7f25c
Author: Tero Kristo <tero.kristo@nokia.com>
Date:   Mon Oct 13 17:58:50 2008 +0300

    OMAP3: PM: SDRC auto-refresh workaround for off-mode
    
    Errata: ES3.0, ES3.1 SDRC not sending auto-refresh when OMAP wakes-up
    from OFF mode
    
    Signed-off-by: Tero Kristo <tero.kristo@nokia.com>
    Signed-off-by: Kalle Jokiniemi <kalle.jokiniemi@digia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index c41565ec16e3..2ff8d7cc60a2 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -209,8 +209,13 @@ void omap3_save_scratchpad_contents(void)
 
 	/* Populate the Scratchpad contents */
 	scratchpad_contents.boot_config_ptr = 0x0;
-	scratchpad_contents.public_restore_ptr =
-			 virt_to_phys(get_restore_pointer());
+	if (omap_rev() != OMAP3430_REV_ES3_0 &&
+					omap_rev() != OMAP3430_REV_ES3_1)
+		scratchpad_contents.public_restore_ptr =
+			virt_to_phys(get_restore_pointer());
+	else
+		scratchpad_contents.public_restore_ptr =
+			virt_to_phys(get_es3_restore_pointer());
 	if (omap_type() == OMAP2_DEVICE_TYPE_GP)
 		scratchpad_contents.secure_ram_restore_ptr = 0x0;
 	else

commit cb0cb2b815bf073dc0211ab224682a6caf6c89ce
Author: Kalle Jokiniemi <kalle.jokiniemi@digia.com>
Date:   Tue May 12 14:02:16 2009 +0300

    OMAP3: PM: Fix PLL_MOD CLKEN offset in scratchpad
    
    The CM_CLKEN_PLL register saved in scratchpad memory
    was wrongly using offset of 0x0004 instead of 0x0000.
    
    The effect of this was that boot ROM code would
    restore the wrong value when waking up from off mode.
    This wrong value, however, will be overwritten by
    prcm context restore. Still, a short period of wrong
    clock settings in CM_CLKEN_PLL remained between ROM
    code and prcm context restore. This is fixed by the
    patch.
    
    Problem reported by: Jouni Hogander <jouni.hogander@nokia.com>
    
    Signed-off-by: Kalle Jokiniemi <kalle.jokiniemi@digia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index b84cff7087b0..c41565ec16e3 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -230,7 +230,7 @@ void omap3_save_scratchpad_contents(void)
 	prcm_block_contents.cm_clksel_wkup =
 			cm_read_mod_reg(WKUP_MOD, CM_CLKSEL);
 	prcm_block_contents.cm_clken_pll =
-			cm_read_mod_reg(PLL_MOD, OMAP3430_CM_CLKEN_PLL);
+			cm_read_mod_reg(PLL_MOD, CM_CLKEN);
 	prcm_block_contents.cm_autoidle_pll =
 			cm_read_mod_reg(PLL_MOD, OMAP3430_CM_AUTOIDLE_PLL);
 	prcm_block_contents.cm_clksel1_pll =

commit 27d59a4a2def42307349079f2e3538d96934c379
Author: Tero Kristo <tero.kristo@nokia.com>
Date:   Mon Oct 13 13:15:00 2008 +0300

    OMAP3 PM: off-mode support for HS/EMU devices
    
    For HS/EMU devices, some additional resources need to be
    saved/restored for off-mode support.  Namely, saving the secure RAM
    and a pointer to it in the scratchpad.
    
    Signed-off-by: Tero Kristo <tero.kristo@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 3ea417d7a1b5..b84cff7087b0 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -85,6 +85,8 @@ struct omap3_scratchpad_sdrc_block {
 	u32 block_size;
 };
 
+void *omap3_secure_ram_storage;
+
 /*
  * This is used to store ARM registers in SDRAM before attempting
  * an MPU OFF. The save and restore happens from the SRAM sleep code.
@@ -209,7 +211,11 @@ void omap3_save_scratchpad_contents(void)
 	scratchpad_contents.boot_config_ptr = 0x0;
 	scratchpad_contents.public_restore_ptr =
 			 virt_to_phys(get_restore_pointer());
-	scratchpad_contents.secure_ram_restore_ptr = 0x0;
+	if (omap_type() == OMAP2_DEVICE_TYPE_GP)
+		scratchpad_contents.secure_ram_restore_ptr = 0x0;
+	else
+		scratchpad_contents.secure_ram_restore_ptr =
+			(u32) __pa(omap3_secure_ram_storage);
 	scratchpad_contents.sdrc_module_semaphore = 0x0;
 	scratchpad_contents.prcm_block_offset = 0x2C;
 	scratchpad_contents.sdrc_block_offset = 0x64;

commit c96631e13888e9be3a80aae291ed671d4d573ec9
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Sep 26 17:49:02 2008 +0530

    OMAP3: PM: SCM context save/restore
    
    Add context save and restore for the System Control Module to suport
    off-mode.
    
    ETK and debobs definitions added by Peter De Schrijver.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Peter 'p2' De Schrijver <peter.de-schrijver@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 03e1bce3b3bb..3ea417d7a1b5 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -26,6 +26,7 @@
 
 static void __iomem *omap2_ctrl_base;
 
+#if defined(CONFIG_ARCH_OMAP3) && defined(CONFIG_PM)
 struct omap3_scratchpad {
 	u32 boot_config_ptr;
 	u32 public_restore_ptr;
@@ -92,6 +93,47 @@ struct omap3_scratchpad_sdrc_block {
  */
 u32 omap3_arm_context[128];
 
+struct omap3_control_regs {
+	u32 sysconfig;
+	u32 devconf0;
+	u32 mem_dftrw0;
+	u32 mem_dftrw1;
+	u32 msuspendmux_0;
+	u32 msuspendmux_1;
+	u32 msuspendmux_2;
+	u32 msuspendmux_3;
+	u32 msuspendmux_4;
+	u32 msuspendmux_5;
+	u32 sec_ctrl;
+	u32 devconf1;
+	u32 csirxfe;
+	u32 iva2_bootaddr;
+	u32 iva2_bootmod;
+	u32 debobs_0;
+	u32 debobs_1;
+	u32 debobs_2;
+	u32 debobs_3;
+	u32 debobs_4;
+	u32 debobs_5;
+	u32 debobs_6;
+	u32 debobs_7;
+	u32 debobs_8;
+	u32 prog_io0;
+	u32 prog_io1;
+	u32 dss_dpll_spreading;
+	u32 core_dpll_spreading;
+	u32 per_dpll_spreading;
+	u32 usbhost_dpll_spreading;
+	u32 pbias_lite;
+	u32 temp_sensor;
+	u32 sramldo4;
+	u32 sramldo5;
+	u32 csi;
+};
+
+static struct omap3_control_regs control_context;
+#endif /* CONFIG_ARCH_OMAP3 && CONFIG_PM */
+
 #define OMAP_CTRL_REGADDR(reg)		(omap2_ctrl_base + (reg))
 
 void __init omap2_set_globals_control(struct omap_globals *omap2_globals)
@@ -134,7 +176,7 @@ void omap_ctrl_writel(u32 val, u16 offset)
 	__raw_writel(val, OMAP_CTRL_REGADDR(offset));
 }
 
-#ifdef CONFIG_ARCH_OMAP3
+#if defined(CONFIG_ARCH_OMAP3) && defined(CONFIG_PM)
 /*
  * Clears the scratchpad contents in case of cold boot-
  * called during bootup
@@ -264,4 +306,115 @@ void omap3_save_scratchpad_contents(void)
 		sizeof(sdrc_block_contents), &arm_context_addr, 4);
 }
 
-#endif /* CONFIG_ARCH_OMAP3 */
+void omap3_control_save_context(void)
+{
+	control_context.sysconfig = omap_ctrl_readl(OMAP2_CONTROL_SYSCONFIG);
+	control_context.devconf0 = omap_ctrl_readl(OMAP2_CONTROL_DEVCONF0);
+	control_context.mem_dftrw0 =
+			omap_ctrl_readl(OMAP343X_CONTROL_MEM_DFTRW0);
+	control_context.mem_dftrw1 =
+			omap_ctrl_readl(OMAP343X_CONTROL_MEM_DFTRW1);
+	control_context.msuspendmux_0 =
+			omap_ctrl_readl(OMAP2_CONTROL_MSUSPENDMUX_0);
+	control_context.msuspendmux_1 =
+			omap_ctrl_readl(OMAP2_CONTROL_MSUSPENDMUX_1);
+	control_context.msuspendmux_2 =
+			omap_ctrl_readl(OMAP2_CONTROL_MSUSPENDMUX_2);
+	control_context.msuspendmux_3 =
+			omap_ctrl_readl(OMAP2_CONTROL_MSUSPENDMUX_3);
+	control_context.msuspendmux_4 =
+			omap_ctrl_readl(OMAP2_CONTROL_MSUSPENDMUX_4);
+	control_context.msuspendmux_5 =
+			omap_ctrl_readl(OMAP2_CONTROL_MSUSPENDMUX_5);
+	control_context.sec_ctrl = omap_ctrl_readl(OMAP2_CONTROL_SEC_CTRL);
+	control_context.devconf1 = omap_ctrl_readl(OMAP343X_CONTROL_DEVCONF1);
+	control_context.csirxfe = omap_ctrl_readl(OMAP343X_CONTROL_CSIRXFE);
+	control_context.iva2_bootaddr =
+			omap_ctrl_readl(OMAP343X_CONTROL_IVA2_BOOTADDR);
+	control_context.iva2_bootmod =
+			omap_ctrl_readl(OMAP343X_CONTROL_IVA2_BOOTMOD);
+	control_context.debobs_0 = omap_ctrl_readl(OMAP343X_CONTROL_DEBOBS(0));
+	control_context.debobs_1 = omap_ctrl_readl(OMAP343X_CONTROL_DEBOBS(1));
+	control_context.debobs_2 = omap_ctrl_readl(OMAP343X_CONTROL_DEBOBS(2));
+	control_context.debobs_3 = omap_ctrl_readl(OMAP343X_CONTROL_DEBOBS(3));
+	control_context.debobs_4 = omap_ctrl_readl(OMAP343X_CONTROL_DEBOBS(4));
+	control_context.debobs_5 = omap_ctrl_readl(OMAP343X_CONTROL_DEBOBS(5));
+	control_context.debobs_6 = omap_ctrl_readl(OMAP343X_CONTROL_DEBOBS(6));
+	control_context.debobs_7 = omap_ctrl_readl(OMAP343X_CONTROL_DEBOBS(7));
+	control_context.debobs_8 = omap_ctrl_readl(OMAP343X_CONTROL_DEBOBS(8));
+	control_context.prog_io0 = omap_ctrl_readl(OMAP343X_CONTROL_PROG_IO0);
+	control_context.prog_io1 = omap_ctrl_readl(OMAP343X_CONTROL_PROG_IO1);
+	control_context.dss_dpll_spreading =
+			omap_ctrl_readl(OMAP343X_CONTROL_DSS_DPLL_SPREADING);
+	control_context.core_dpll_spreading =
+			omap_ctrl_readl(OMAP343X_CONTROL_CORE_DPLL_SPREADING);
+	control_context.per_dpll_spreading =
+			omap_ctrl_readl(OMAP343X_CONTROL_PER_DPLL_SPREADING);
+	control_context.usbhost_dpll_spreading =
+		omap_ctrl_readl(OMAP343X_CONTROL_USBHOST_DPLL_SPREADING);
+	control_context.pbias_lite =
+			omap_ctrl_readl(OMAP343X_CONTROL_PBIAS_LITE);
+	control_context.temp_sensor =
+			omap_ctrl_readl(OMAP343X_CONTROL_TEMP_SENSOR);
+	control_context.sramldo4 = omap_ctrl_readl(OMAP343X_CONTROL_SRAMLDO4);
+	control_context.sramldo5 = omap_ctrl_readl(OMAP343X_CONTROL_SRAMLDO5);
+	control_context.csi = omap_ctrl_readl(OMAP343X_CONTROL_CSI);
+	return;
+}
+
+void omap3_control_restore_context(void)
+{
+	omap_ctrl_writel(control_context.sysconfig, OMAP2_CONTROL_SYSCONFIG);
+	omap_ctrl_writel(control_context.devconf0, OMAP2_CONTROL_DEVCONF0);
+	omap_ctrl_writel(control_context.mem_dftrw0,
+					OMAP343X_CONTROL_MEM_DFTRW0);
+	omap_ctrl_writel(control_context.mem_dftrw1,
+					OMAP343X_CONTROL_MEM_DFTRW1);
+	omap_ctrl_writel(control_context.msuspendmux_0,
+					OMAP2_CONTROL_MSUSPENDMUX_0);
+	omap_ctrl_writel(control_context.msuspendmux_1,
+					OMAP2_CONTROL_MSUSPENDMUX_1);
+	omap_ctrl_writel(control_context.msuspendmux_2,
+					OMAP2_CONTROL_MSUSPENDMUX_2);
+	omap_ctrl_writel(control_context.msuspendmux_3,
+					OMAP2_CONTROL_MSUSPENDMUX_3);
+	omap_ctrl_writel(control_context.msuspendmux_4,
+					OMAP2_CONTROL_MSUSPENDMUX_4);
+	omap_ctrl_writel(control_context.msuspendmux_5,
+					OMAP2_CONTROL_MSUSPENDMUX_5);
+	omap_ctrl_writel(control_context.sec_ctrl, OMAP2_CONTROL_SEC_CTRL);
+	omap_ctrl_writel(control_context.devconf1, OMAP343X_CONTROL_DEVCONF1);
+	omap_ctrl_writel(control_context.csirxfe, OMAP343X_CONTROL_CSIRXFE);
+	omap_ctrl_writel(control_context.iva2_bootaddr,
+					OMAP343X_CONTROL_IVA2_BOOTADDR);
+	omap_ctrl_writel(control_context.iva2_bootmod,
+					OMAP343X_CONTROL_IVA2_BOOTMOD);
+	omap_ctrl_writel(control_context.debobs_0, OMAP343X_CONTROL_DEBOBS(0));
+	omap_ctrl_writel(control_context.debobs_1, OMAP343X_CONTROL_DEBOBS(1));
+	omap_ctrl_writel(control_context.debobs_2, OMAP343X_CONTROL_DEBOBS(2));
+	omap_ctrl_writel(control_context.debobs_3, OMAP343X_CONTROL_DEBOBS(3));
+	omap_ctrl_writel(control_context.debobs_4, OMAP343X_CONTROL_DEBOBS(4));
+	omap_ctrl_writel(control_context.debobs_5, OMAP343X_CONTROL_DEBOBS(5));
+	omap_ctrl_writel(control_context.debobs_6, OMAP343X_CONTROL_DEBOBS(6));
+	omap_ctrl_writel(control_context.debobs_7, OMAP343X_CONTROL_DEBOBS(7));
+	omap_ctrl_writel(control_context.debobs_8, OMAP343X_CONTROL_DEBOBS(8));
+	omap_ctrl_writel(control_context.prog_io0, OMAP343X_CONTROL_PROG_IO0);
+	omap_ctrl_writel(control_context.prog_io1, OMAP343X_CONTROL_PROG_IO1);
+	omap_ctrl_writel(control_context.dss_dpll_spreading,
+					OMAP343X_CONTROL_DSS_DPLL_SPREADING);
+	omap_ctrl_writel(control_context.core_dpll_spreading,
+					OMAP343X_CONTROL_CORE_DPLL_SPREADING);
+	omap_ctrl_writel(control_context.per_dpll_spreading,
+					OMAP343X_CONTROL_PER_DPLL_SPREADING);
+	omap_ctrl_writel(control_context.usbhost_dpll_spreading,
+				OMAP343X_CONTROL_USBHOST_DPLL_SPREADING);
+	omap_ctrl_writel(control_context.pbias_lite,
+					OMAP343X_CONTROL_PBIAS_LITE);
+	omap_ctrl_writel(control_context.temp_sensor,
+					OMAP343X_CONTROL_TEMP_SENSOR);
+	omap_ctrl_writel(control_context.sramldo4, OMAP343X_CONTROL_SRAMLDO4);
+	omap_ctrl_writel(control_context.sramldo5, OMAP343X_CONTROL_SRAMLDO5);
+	omap_ctrl_writel(control_context.csi, OMAP343X_CONTROL_CSI);
+	return;
+}
+#endif /* CONFIG_ARCH_OMAP3 && CONFIG_PM */

commit 8014078684377257e3a83ac45db95711929850c5
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Sep 26 17:48:46 2008 +0530

    OMAP3: PM: Populate scratchpad contents
    
    This patch populates the scratchpad contents as expected by the
    bootROM code.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 6adb360c6d45..03e1bce3b3bb 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -17,9 +17,81 @@
 
 #include <plat/common.h>
 #include <plat/control.h>
+#include <plat/sdrc.h>
+#include "cm-regbits-34xx.h"
+#include "prm-regbits-34xx.h"
+#include "cm.h"
+#include "prm.h"
+#include "sdrc.h"
 
 static void __iomem *omap2_ctrl_base;
 
+struct omap3_scratchpad {
+	u32 boot_config_ptr;
+	u32 public_restore_ptr;
+	u32 secure_ram_restore_ptr;
+	u32 sdrc_module_semaphore;
+	u32 prcm_block_offset;
+	u32 sdrc_block_offset;
+};
+
+struct omap3_scratchpad_prcm_block {
+	u32 prm_clksrc_ctrl;
+	u32 prm_clksel;
+	u32 cm_clksel_core;
+	u32 cm_clksel_wkup;
+	u32 cm_clken_pll;
+	u32 cm_autoidle_pll;
+	u32 cm_clksel1_pll;
+	u32 cm_clksel2_pll;
+	u32 cm_clksel3_pll;
+	u32 cm_clken_pll_mpu;
+	u32 cm_autoidle_pll_mpu;
+	u32 cm_clksel1_pll_mpu;
+	u32 cm_clksel2_pll_mpu;
+	u32 prcm_block_size;
+};
+
+struct omap3_scratchpad_sdrc_block {
+	u16 sysconfig;
+	u16 cs_cfg;
+	u16 sharing;
+	u16 err_type;
+	u32 dll_a_ctrl;
+	u32 dll_b_ctrl;
+	u32 power;
+	u32 cs_0;
+	u32 mcfg_0;
+	u16 mr_0;
+	u16 emr_1_0;
+	u16 emr_2_0;
+	u16 emr_3_0;
+	u32 actim_ctrla_0;
+	u32 actim_ctrlb_0;
+	u32 rfr_ctrl_0;
+	u32 cs_1;
+	u32 mcfg_1;
+	u16 mr_1;
+	u16 emr_1_1;
+	u16 emr_2_1;
+	u16 emr_3_1;
+	u32 actim_ctrla_1;
+	u32 actim_ctrlb_1;
+	u32 rfr_ctrl_1;
+	u16 dcdl_1_ctrl;
+	u16 dcdl_2_ctrl;
+	u32 flags;
+	u32 block_size;
+};
+
+/*
+ * This is used to store ARM registers in SDRAM before attempting
+ * an MPU OFF. The save and restore happens from the SRAM sleep code.
+ * The address is stored in scratchpad, so that it can be used
+ * during the restore path.
+ */
+u32 omap3_arm_context[128];
+
 #define OMAP_CTRL_REGADDR(reg)		(omap2_ctrl_base + (reg))
 
 void __init omap2_set_globals_control(struct omap_globals *omap2_globals)
@@ -62,3 +134,134 @@ void omap_ctrl_writel(u32 val, u16 offset)
 	__raw_writel(val, OMAP_CTRL_REGADDR(offset));
 }
 
+#ifdef CONFIG_ARCH_OMAP3
+/*
+ * Clears the scratchpad contents in case of cold boot-
+ * called during bootup
+ */
+void omap3_clear_scratchpad_contents(void)
+{
+	u32 max_offset = OMAP343X_SCRATCHPAD_ROM_OFFSET;
+	u32 *v_addr;
+	u32 offset = 0;
+	v_addr = OMAP2_L4_IO_ADDRESS(OMAP343X_SCRATCHPAD_ROM);
+	if (prm_read_mod_reg(OMAP3430_GR_MOD, OMAP3_PRM_RSTST_OFFSET) &
+		OMAP3430_GLOBAL_COLD_RST) {
+		for ( ; offset <= max_offset; offset += 0x4)
+			__raw_writel(0x0, (v_addr + offset));
+		prm_set_mod_reg_bits(OMAP3430_GLOBAL_COLD_RST, OMAP3430_GR_MOD,
+			OMAP3_PRM_RSTST_OFFSET);
+	}
+}
+
+/* Populate the scratchpad structure with restore structure */
+void omap3_save_scratchpad_contents(void)
+{
+	void * __iomem scratchpad_address;
+	u32 arm_context_addr;
+	struct omap3_scratchpad scratchpad_contents;
+	struct omap3_scratchpad_prcm_block prcm_block_contents;
+	struct omap3_scratchpad_sdrc_block sdrc_block_contents;
+
+	/* Populate the Scratchpad contents */
+	scratchpad_contents.boot_config_ptr = 0x0;
+	scratchpad_contents.public_restore_ptr =
+			 virt_to_phys(get_restore_pointer());
+	scratchpad_contents.secure_ram_restore_ptr = 0x0;
+	scratchpad_contents.sdrc_module_semaphore = 0x0;
+	scratchpad_contents.prcm_block_offset = 0x2C;
+	scratchpad_contents.sdrc_block_offset = 0x64;
+
+	/* Populate the PRCM block contents */
+	prcm_block_contents.prm_clksrc_ctrl = prm_read_mod_reg(OMAP3430_GR_MOD,
+			OMAP3_PRM_CLKSRC_CTRL_OFFSET);
+	prcm_block_contents.prm_clksel = prm_read_mod_reg(OMAP3430_CCR_MOD,
+			OMAP3_PRM_CLKSEL_OFFSET);
+	prcm_block_contents.cm_clksel_core =
+			cm_read_mod_reg(CORE_MOD, CM_CLKSEL);
+	prcm_block_contents.cm_clksel_wkup =
+			cm_read_mod_reg(WKUP_MOD, CM_CLKSEL);
+	prcm_block_contents.cm_clken_pll =
+			cm_read_mod_reg(PLL_MOD, OMAP3430_CM_CLKEN_PLL);
+	prcm_block_contents.cm_autoidle_pll =
+			cm_read_mod_reg(PLL_MOD, OMAP3430_CM_AUTOIDLE_PLL);
+	prcm_block_contents.cm_clksel1_pll =
+			cm_read_mod_reg(PLL_MOD, OMAP3430_CM_CLKSEL1_PLL);
+	prcm_block_contents.cm_clksel2_pll =
+			cm_read_mod_reg(PLL_MOD, OMAP3430_CM_CLKSEL2_PLL);
+	prcm_block_contents.cm_clksel3_pll =
+			cm_read_mod_reg(PLL_MOD, OMAP3430_CM_CLKSEL3);
+	prcm_block_contents.cm_clken_pll_mpu =
+			cm_read_mod_reg(MPU_MOD, OMAP3430_CM_CLKEN_PLL);
+	prcm_block_contents.cm_autoidle_pll_mpu =
+			cm_read_mod_reg(MPU_MOD, OMAP3430_CM_AUTOIDLE_PLL);
+	prcm_block_contents.cm_clksel1_pll_mpu =
+			cm_read_mod_reg(MPU_MOD, OMAP3430_CM_CLKSEL1_PLL);
+	prcm_block_contents.cm_clksel2_pll_mpu =
+			cm_read_mod_reg(MPU_MOD, OMAP3430_CM_CLKSEL2_PLL);
+	prcm_block_contents.prcm_block_size = 0x0;
+
+	/* Populate the SDRC block contents */
+	sdrc_block_contents.sysconfig =
+			(sdrc_read_reg(SDRC_SYSCONFIG) & 0xFFFF);
+	sdrc_block_contents.cs_cfg =
+			(sdrc_read_reg(SDRC_CS_CFG) & 0xFFFF);
+	sdrc_block_contents.sharing =
+			(sdrc_read_reg(SDRC_SHARING) & 0xFFFF);
+	sdrc_block_contents.err_type =
+			(sdrc_read_reg(SDRC_ERR_TYPE) & 0xFFFF);
+	sdrc_block_contents.dll_a_ctrl = sdrc_read_reg(SDRC_DLLA_CTRL);
+	sdrc_block_contents.dll_b_ctrl = 0x0;
+	sdrc_block_contents.power = sdrc_read_reg(SDRC_POWER);
+	sdrc_block_contents.cs_0 = 0x0;
+	sdrc_block_contents.mcfg_0 = sdrc_read_reg(SDRC_MCFG_0);
+	sdrc_block_contents.mr_0 = (sdrc_read_reg(SDRC_MR_0) & 0xFFFF);
+	sdrc_block_contents.emr_1_0 = 0x0;
+	sdrc_block_contents.emr_2_0 = 0x0;
+	sdrc_block_contents.emr_3_0 = 0x0;
+	sdrc_block_contents.actim_ctrla_0 =
+			sdrc_read_reg(SDRC_ACTIM_CTRL_A_0);
+	sdrc_block_contents.actim_ctrlb_0 =
+			sdrc_read_reg(SDRC_ACTIM_CTRL_B_0);
+	sdrc_block_contents.rfr_ctrl_0 =
+			sdrc_read_reg(SDRC_RFR_CTRL_0);
+	sdrc_block_contents.cs_1 = 0x0;
+	sdrc_block_contents.mcfg_1 = sdrc_read_reg(SDRC_MCFG_1);
+	sdrc_block_contents.mr_1 = sdrc_read_reg(SDRC_MR_1) & 0xFFFF;
+	sdrc_block_contents.emr_1_1 = 0x0;
+	sdrc_block_contents.emr_2_1 = 0x0;
+	sdrc_block_contents.emr_3_1 = 0x0;
+	sdrc_block_contents.actim_ctrla_1 =
+			sdrc_read_reg(SDRC_ACTIM_CTRL_A_1);
+	sdrc_block_contents.actim_ctrlb_1 =
+			sdrc_read_reg(SDRC_ACTIM_CTRL_B_1);
+	sdrc_block_contents.rfr_ctrl_1 =
+			sdrc_read_reg(SDRC_RFR_CTRL_1);
+	sdrc_block_contents.dcdl_1_ctrl = 0x0;
+	sdrc_block_contents.dcdl_2_ctrl = 0x0;
+	sdrc_block_contents.flags = 0x0;
+	sdrc_block_contents.block_size = 0x0;
+
+	arm_context_addr = virt_to_phys(omap3_arm_context);
+
+	/* Copy all the contents to the scratchpad location */
+	scratchpad_address = OMAP2_L4_IO_ADDRESS(OMAP343X_SCRATCHPAD);
+	memcpy_toio(scratchpad_address, &scratchpad_contents,
+		 sizeof(scratchpad_contents));
+	/* Scratchpad contents being 32 bits, a divide by 4 done here */
+	memcpy_toio(scratchpad_address +
+		scratchpad_contents.prcm_block_offset,
+		&prcm_block_contents, sizeof(prcm_block_contents));
+	memcpy_toio(scratchpad_address +
+		scratchpad_contents.sdrc_block_offset,
+		&sdrc_block_contents, sizeof(sdrc_block_contents));
+	/*
+	 * Copies the address of the location in SDRAM where ARM
+	 * registers get saved during a MPU OFF transition.
+	 */
+	memcpy_toio(scratchpad_address +
+		scratchpad_contents.sdrc_block_offset +
+		sizeof(sdrc_block_contents), &arm_context_addr, 4);
+}
+
+#endif /* CONFIG_ARCH_OMAP3 */

commit ce491cf85466c3377228c5a852ea627ec5136956
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 20 09:40:47 2009 -0700

    omap: headers: Move remaining headers from include/mach to include/plat
    
    Move the remaining headers under plat-omap/include/mach
    to plat-omap/include/plat. Also search and replace the
    files using these headers to include using the right path.
    
    This was done with:
    
    #!/bin/bash
    mach_dir_old="arch/arm/plat-omap/include/mach"
    plat_dir_new="arch/arm/plat-omap/include/plat"
    headers=$(cd $mach_dir_old && ls *.h)
    omap_dirs="arch/arm/*omap*/ \
    drivers/video/omap \
    sound/soc/omap"
    other_files="drivers/leds/leds-ams-delta.c \
    drivers/mfd/menelaus.c \
    drivers/mfd/twl4030-core.c \
    drivers/mtd/nand/ams-delta.c"
    
    for header in $headers; do
            old="#include <mach\/$header"
            new="#include <plat\/$header"
            for dir in $omap_dirs; do
                    find $dir -type f -name \*.[chS] | \
                            xargs sed -i "s/$old/$new/"
            done
            find drivers/ -type f -name \*omap*.[chS] | \
                    xargs sed -i "s/$old/$new/"
            for file in $other_files; do
                    sed -i "s/$old/$new/" $file
            done
    done
    
    for header in $(ls $mach_dir_old/*.h); do
            git mv $header $plat_dir_new/
    done
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 5f3aad977842..6adb360c6d45 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -15,8 +15,8 @@
 #include <linux/kernel.h>
 #include <linux/io.h>
 
-#include <mach/common.h>
-#include <mach/control.h>
+#include <plat/common.h>
+#include <plat/control.h>
 
 static void __iomem *omap2_ctrl_base;
 

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 51f70300996f..5f3aad977842 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -15,8 +15,8 @@
 #include <linux/kernel.h>
 #include <linux/io.h>
 
-#include <asm/arch/common.h>
-#include <asm/arch/control.h>
+#include <mach/common.h>
+#include <mach/control.h>
 
 static void __iomem *omap2_ctrl_base;
 

commit a58caad11301a5bdc2d7b76596ab5477221f7a9b
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Jul 3 12:24:44 2008 +0300

    ARM: OMAP: Introduce omap_globals and prcm access functions for multi-omap
    
    New struct omap_globals contains the omap processor specific
    module bases. Use omap_globals to set the various base addresses
    to make detecting omap chip type simpler.
    
    Also introduce OMAP1_IO_ADDRESS and OMAP2_IO_ADDRESS for future multi-omap
    patches.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index a5d86a49c213..51f70300996f 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -13,22 +13,21 @@
 #undef DEBUG
 
 #include <linux/kernel.h>
+#include <linux/io.h>
 
-#include <asm/io.h>
-
+#include <asm/arch/common.h>
 #include <asm/arch/control.h>
 
-static u32 omap2_ctrl_base;
+static void __iomem *omap2_ctrl_base;
 
-#define OMAP_CTRL_REGADDR(reg)	(void __iomem *)IO_ADDRESS(omap2_ctrl_base \
-								+ (reg))
+#define OMAP_CTRL_REGADDR(reg)		(omap2_ctrl_base + (reg))
 
-void omap_ctrl_base_set(u32 base)
+void __init omap2_set_globals_control(struct omap_globals *omap2_globals)
 {
-	omap2_ctrl_base = base;
+	omap2_ctrl_base = omap2_globals->ctrl;
 }
 
-u32 omap_ctrl_base_get(void)
+void __iomem *omap_ctrl_base_get(void)
 {
 	return omap2_ctrl_base;
 }
@@ -50,25 +49,16 @@ u32 omap_ctrl_readl(u16 offset)
 
 void omap_ctrl_writeb(u8 val, u16 offset)
 {
-	pr_debug("omap_ctrl_writeb: writing 0x%0x to 0x%0x\n", val,
-		 (u32)OMAP_CTRL_REGADDR(offset));
-
 	__raw_writeb(val, OMAP_CTRL_REGADDR(offset));
 }
 
 void omap_ctrl_writew(u16 val, u16 offset)
 {
-	pr_debug("omap_ctrl_writew: writing 0x%0x to 0x%0x\n", val,
-		 (u32)OMAP_CTRL_REGADDR(offset));
-
 	__raw_writew(val, OMAP_CTRL_REGADDR(offset));
 }
 
 void omap_ctrl_writel(u32 val, u16 offset)
 {
-	pr_debug("omap_ctrl_writel: writing 0x%0x to 0x%0x\n", val,
-		 (u32)OMAP_CTRL_REGADDR(offset));
-
 	__raw_writel(val, OMAP_CTRL_REGADDR(offset));
 }
 

commit 69d88a00a240fbed07fb6943c862ea3188e9097d
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Mar 18 10:02:50 2008 +0200

    ARM: OMAP2: Add common register access for 24xx and 34xx
    
    This patch adds common register access for 24xx and 34xx power
    and clock management in order to share code between 24xx and 34xx.
    
    Only change USB platform init code to use new register access, other
    access will be changed in later patches.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
new file mode 100644
index 000000000000..a5d86a49c213
--- /dev/null
+++ b/arch/arm/mach-omap2/control.c
@@ -0,0 +1,74 @@
+/*
+ * OMAP2/3 System Control Module register access
+ *
+ * Copyright (C) 2007 Texas Instruments, Inc.
+ * Copyright (C) 2007 Nokia Corporation
+ *
+ * Written by Paul Walmsley
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#undef DEBUG
+
+#include <linux/kernel.h>
+
+#include <asm/io.h>
+
+#include <asm/arch/control.h>
+
+static u32 omap2_ctrl_base;
+
+#define OMAP_CTRL_REGADDR(reg)	(void __iomem *)IO_ADDRESS(omap2_ctrl_base \
+								+ (reg))
+
+void omap_ctrl_base_set(u32 base)
+{
+	omap2_ctrl_base = base;
+}
+
+u32 omap_ctrl_base_get(void)
+{
+	return omap2_ctrl_base;
+}
+
+u8 omap_ctrl_readb(u16 offset)
+{
+	return __raw_readb(OMAP_CTRL_REGADDR(offset));
+}
+
+u16 omap_ctrl_readw(u16 offset)
+{
+	return __raw_readw(OMAP_CTRL_REGADDR(offset));
+}
+
+u32 omap_ctrl_readl(u16 offset)
+{
+	return __raw_readl(OMAP_CTRL_REGADDR(offset));
+}
+
+void omap_ctrl_writeb(u8 val, u16 offset)
+{
+	pr_debug("omap_ctrl_writeb: writing 0x%0x to 0x%0x\n", val,
+		 (u32)OMAP_CTRL_REGADDR(offset));
+
+	__raw_writeb(val, OMAP_CTRL_REGADDR(offset));
+}
+
+void omap_ctrl_writew(u16 val, u16 offset)
+{
+	pr_debug("omap_ctrl_writew: writing 0x%0x to 0x%0x\n", val,
+		 (u32)OMAP_CTRL_REGADDR(offset));
+
+	__raw_writew(val, OMAP_CTRL_REGADDR(offset));
+}
+
+void omap_ctrl_writel(u32 val, u16 offset)
+{
+	pr_debug("omap_ctrl_writel: writing 0x%0x to 0x%0x\n", val,
+		 (u32)OMAP_CTRL_REGADDR(offset));
+
+	__raw_writel(val, OMAP_CTRL_REGADDR(offset));
+}
+
