commit a18fb07623813aaee1a69873c785865695a32c9e
Author: Chen Tao <chentao107@huawei.com>
Date:   Fri Jun 19 18:42:40 2020 +0800

    ARM: OMAP2+: Fix possible memory leak in omap_hwmod_allocate_module
    
    Fix memory leak in omap_hwmod_allocate_module not freeing in
    handling error path.
    
    Fixes: 8c87970543b17("ARM: OMAP2+: Add functions to allocate module data from device tree")
    Signed-off-by: Chen Tao <chentao107@huawei.com>
    Reviewed-by: Paul Walmsley <paul@pwsan.com>
    [tony@atomide.com: fix call iounmap for missing regs]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index c630457bb228..15b29a179c8a 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3435,7 +3435,7 @@ static int omap_hwmod_allocate_module(struct device *dev, struct omap_hwmod *oh,
 		regs = ioremap(data->module_pa,
 			       data->module_size);
 		if (!regs)
-			return -ENOMEM;
+			goto out_free_sysc;
 	}
 
 	/*
@@ -3445,13 +3445,13 @@ static int omap_hwmod_allocate_module(struct device *dev, struct omap_hwmod *oh,
 	if (oh->class->name && strcmp(oh->class->name, data->name)) {
 		class = kmemdup(oh->class, sizeof(*oh->class), GFP_KERNEL);
 		if (!class)
-			return -ENOMEM;
+			goto out_unmap;
 	}
 
 	if (list_empty(&oh->slave_ports)) {
 		oi = kcalloc(1, sizeof(*oi), GFP_KERNEL);
 		if (!oi)
-			return -ENOMEM;
+			goto out_free_class;
 
 		/*
 		 * Note that we assume interconnect interface clocks will be
@@ -3478,6 +3478,14 @@ static int omap_hwmod_allocate_module(struct device *dev, struct omap_hwmod *oh,
 	spin_unlock_irqrestore(&oh->_lock, flags);
 
 	return 0;
+
+out_free_class:
+	kfree(class);
+out_unmap:
+	iounmap(regs);
+out_free_sysc:
+	kfree(sysc);
+	return -ENOMEM;
 }
 
 static const struct omap_hwmod_reset omap24xx_reset_quirks[] = {

commit 77cad9dbc957f23a73169e8a8971186744296614
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 27 16:32:06 2020 -0700

    ARM: OMAP2+: Fix legacy mode dss_reset
    
    We must check for "dss_core" instead of "dss" to avoid also matching
    also "dss_dispc". This only matters for the mixed case of data
    configured in device tree but with legacy booting ti,hwmods property
    still enabled.
    
    Fixes: 8b30919a4e3c ("ARM: OMAP2+: Handle reset quirks for dynamically allocated modules")
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 82706af307de..c630457bb228 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3489,7 +3489,7 @@ static const struct omap_hwmod_reset dra7_reset_quirks[] = {
 };
 
 static const struct omap_hwmod_reset omap_reset_quirks[] = {
-	{ .match = "dss", .len = 3, .reset = omap_dss_reset, },
+	{ .match = "dss_core", .len = 8, .reset = omap_dss_reset, },
 	{ .match = "hdq1w", .len = 5, .reset = omap_hdq1w_reset, },
 	{ .match = "i2c", .len = 3, .reset = omap_i2c_reset, },
 	{ .match = "wd_timer", .len = 8, .reset = omap2_wd_timer_reset, },

commit f4a5ac7bd96f13b67e0f554c3c7f1b6740e3dbdf
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Feb 21 10:57:17 2020 -0800

    ARM: OMAP2+: Improve handling of ti-sysc related sysc_fields
    
    We can currently get a cryptic warning sysc_fields (ptrval) != (ptrval)
    if the legacy platform data has no sysc_fields defined while the newer
    dts data has them. This warning appears only when booting still with
    legacy "ti,hwmods" custom property set. This can happen at least with
    DSS related modules where we may not have sysc_fields defined in the
    in the legacy data.
    
    Let's not error out on missing legacy data sysc_fields, and show a more
    descriptive warning for other cases.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 17d337ed18be..82706af307de 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3148,15 +3148,14 @@ static int omap_hwmod_check_sysc(struct device *dev,
 /**
  * omap_hwmod_init_regbits - init sysconfig specific register bits
  * @dev: struct device
+ * @oh: module
  * @data: module data
  * @sysc_fields: new sysc configuration
  */
-static int omap_hwmod_init_regbits(struct device *dev,
+static int omap_hwmod_init_regbits(struct device *dev, struct omap_hwmod *oh,
 				   const struct ti_sysc_module_data *data,
 				   struct sysc_regbits **sysc_fields)
 {
-	*sysc_fields = NULL;
-
 	switch (data->cap->type) {
 	case TI_SYSC_OMAP2:
 	case TI_SYSC_OMAP2_TIMER:
@@ -3191,6 +3190,12 @@ static int omap_hwmod_init_regbits(struct device *dev,
 		*sysc_fields = &omap_hwmod_sysc_type_usb_host_fs;
 		break;
 	default:
+		*sysc_fields = NULL;
+		if (!oh->class->sysc->sysc_fields)
+			return 0;
+
+		dev_err(dev, "sysc_fields not found\n");
+
 		return -EINVAL;
 	}
 
@@ -3356,9 +3361,9 @@ static int omap_hwmod_check_module(struct device *dev,
 	if (!oh->class->sysc)
 		return -ENODEV;
 
-	if (sysc_fields != oh->class->sysc->sysc_fields)
-		dev_warn(dev, "sysc_fields %p != %p\n", sysc_fields,
-			 oh->class->sysc->sysc_fields);
+	if (oh->class->sysc->sysc_fields &&
+	    sysc_fields != oh->class->sysc->sysc_fields)
+		dev_warn(dev, "sysc_fields mismatch\n");
 
 	if (rev_offs != oh->class->sysc->rev_offs)
 		dev_warn(dev, "rev_offs %08x != %08x\n", rev_offs,
@@ -3574,7 +3579,7 @@ int omap_hwmod_init_module(struct device *dev,
 
 	cookie->data = oh;
 
-	error = omap_hwmod_init_regbits(dev, data, &sysc_fields);
+	error = omap_hwmod_init_regbits(dev, oh, data, &sysc_fields);
 	if (error)
 		return error;
 

commit 19c8915ca38f8ac4d1fe380c342ce36c6eb03e15
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Dec 10 08:10:09 2019 -0800

    ARM: OMAP2+: Drop legacy platform data for omap4 aess
    
    We can now probe devices with ti-sysc interconnect driver and dts
    data. Let's drop the related platform data and custom ti,hwmods
    dts property.
    
    As we're just dropping data, and the early platform data init
    is based on the custom ti,hwmods property, we want to drop both
    the platform data and ti,hwmods property in a single patch.
    
    Cc: Keerthy <j-keerthy@ti.com>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Tested-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index a136788db839..17d337ed18be 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1852,23 +1852,6 @@ static int _omap4_get_context_lost(struct omap_hwmod *oh)
 	return oh->prcm.omap4.context_lost_counter;
 }
 
-/**
- * _enable_preprogram - Pre-program an IP block during the _enable() process
- * @oh: struct omap_hwmod *
- *
- * Some IP blocks (such as AESS) require some additional programming
- * after enable before they can enter idle.  If a function pointer to
- * do so is present in the hwmod data, then call it and pass along the
- * return value; otherwise, return 0.
- */
-static int _enable_preprogram(struct omap_hwmod *oh)
-{
-	if (!oh->class->enable_preprogram)
-		return 0;
-
-	return oh->class->enable_preprogram(oh);
-}
-
 /**
  * _enable - enable an omap_hwmod
  * @oh: struct omap_hwmod *
@@ -1952,7 +1935,6 @@ static int _enable(struct omap_hwmod *oh)
 				_update_sysc_cache(oh);
 			_enable_sysc(oh);
 		}
-		r = _enable_preprogram(oh);
 	} else {
 		if (soc_ops.disable_module)
 			soc_ops.disable_module(oh);

commit 645ad6f3ca450ecd30e79d168563d79448317674
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Oct 16 08:21:50 2019 -0700

    ARM: OMAP2+: Drop unused enable_wakeup and disable_wakeup
    
    We're only using static _enable_wakeup(), the others have no callers.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 203664c40d3d..a136788db839 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -623,39 +623,6 @@ static int _enable_wakeup(struct omap_hwmod *oh, u32 *v)
 	return 0;
 }
 
-/**
- * _disable_wakeup: clear OCP_SYSCONFIG.ENAWAKEUP bit in the hardware
- * @oh: struct omap_hwmod *
- *
- * Prevent the hardware module @oh to send wakeups.  Returns -EINVAL
- * upon error or 0 upon success.
- */
-static int _disable_wakeup(struct omap_hwmod *oh, u32 *v)
-{
-	if (!oh->class->sysc ||
-	    !((oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP) ||
-	      (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP) ||
-	      (oh->class->sysc->idlemodes & MSTANDBY_SMART_WKUP)))
-		return -EINVAL;
-
-	if (!oh->class->sysc->sysc_fields) {
-		WARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);
-		return -EINVAL;
-	}
-
-	if (oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP)
-		*v &= ~(0x1 << oh->class->sysc->sysc_fields->enwkup_shift);
-
-	if (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP)
-		_set_slave_idlemode(oh, HWMOD_IDLEMODE_SMART, v);
-	if (oh->class->sysc->idlemodes & MSTANDBY_SMART_WKUP)
-		_set_master_standbymode(oh, HWMOD_IDLEMODE_SMART, v);
-
-	/* XXX test pwrdm_get_wken for this hwmod's subsystem */
-
-	return 0;
-}
-
 static struct clockdomain *_get_clkdm(struct omap_hwmod *oh)
 {
 	struct clk_hw_omap *clk;
@@ -3867,70 +3834,6 @@ void __iomem *omap_hwmod_get_mpu_rt_va(struct omap_hwmod *oh)
  * for context save/restore operations?
  */
 
-/**
- * omap_hwmod_enable_wakeup - allow device to wake up the system
- * @oh: struct omap_hwmod *
- *
- * Sets the module OCP socket ENAWAKEUP bit to allow the module to
- * send wakeups to the PRCM, and enable I/O ring wakeup events for
- * this IP block if it has dynamic mux entries.  Eventually this
- * should set PRCM wakeup registers to cause the PRCM to receive
- * wakeup events from the module.  Does not set any wakeup routing
- * registers beyond this point - if the module is to wake up any other
- * module or subsystem, that must be set separately.  Called by
- * omap_device code.  Returns -EINVAL on error or 0 upon success.
- */
-int omap_hwmod_enable_wakeup(struct omap_hwmod *oh)
-{
-	unsigned long flags;
-	u32 v;
-
-	spin_lock_irqsave(&oh->_lock, flags);
-
-	if (oh->class->sysc &&
-	    (oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP)) {
-		v = oh->_sysc_cache;
-		_enable_wakeup(oh, &v);
-		_write_sysconfig(v, oh);
-	}
-
-	spin_unlock_irqrestore(&oh->_lock, flags);
-
-	return 0;
-}
-
-/**
- * omap_hwmod_disable_wakeup - prevent device from waking the system
- * @oh: struct omap_hwmod *
- *
- * Clears the module OCP socket ENAWAKEUP bit to prevent the module
- * from sending wakeups to the PRCM, and disable I/O ring wakeup
- * events for this IP block if it has dynamic mux entries.  Eventually
- * this should clear PRCM wakeup registers to cause the PRCM to ignore
- * wakeup events from the module.  Does not set any wakeup routing
- * registers beyond this point - if the module is to wake up any other
- * module or subsystem, that must be set separately.  Called by
- * omap_device code.  Returns -EINVAL on error or 0 upon success.
- */
-int omap_hwmod_disable_wakeup(struct omap_hwmod *oh)
-{
-	unsigned long flags;
-	u32 v;
-
-	spin_lock_irqsave(&oh->_lock, flags);
-
-	if (oh->class->sysc &&
-	    (oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP)) {
-		v = oh->_sysc_cache;
-		_disable_wakeup(oh, &v);
-		_write_sysconfig(v, oh);
-	}
-
-	spin_unlock_irqrestore(&oh->_lock, flags);
-
-	return 0;
-}
-
 /**
  * omap_hwmod_assert_hardreset - assert the HW reset line of submodules
  * contained in the hwmod module.

commit 8362fd64f07eaef7155c94fca8dee91c4f99a666
Merge: 24e44913aa74 8c0993621c3e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 19 17:13:56 2019 -0700

    Merge tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc
    
    Pull ARM SoC-related driver updates from Olof Johansson:
     "Various driver updates for platforms and a couple of the small driver
      subsystems we merge through our tree:
    
       - A driver for SCU (system control) on NXP i.MX8QXP
    
       - Qualcomm Always-on Subsystem messaging driver (AOSS QMP)
    
       - Qualcomm PM support for MSM8998
    
       - Support for a newer version of DRAM PHY driver for Broadcom (DPFE)
    
       - Reset controller support for Bitmain BM1880
    
       - TI SCI (System Control Interface) support for CPU control on AM654
         processors
    
       - More TI sysc refactoring and rework"
    
    * tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc: (84 commits)
      reset: remove redundant null check on pointer dev
      soc: rockchip: work around clang warning
      dt-bindings: reset: imx7: Fix the spelling of 'indices'
      soc: imx: Add i.MX8MN SoC driver support
      soc: aspeed: lpc-ctrl: Fix probe error handling
      soc: qcom: geni: Add support for ACPI
      firmware: ti_sci: Fix gcc unused-but-set-variable warning
      firmware: ti_sci: Use the correct style for SPDX License Identifier
      soc: imx8: Use existing of_root directly
      soc: imx8: Fix potential kernel dump in error path
      firmware/psci: psci_checker: Park kthreads before stopping them
      memory: move jedec_ddr.h from include/memory to drivers/memory/
      memory: move jedec_ddr_data.c from lib/ to drivers/memory/
      MAINTAINERS: Remove myself as qcom maintainer
      soc: aspeed: lpc-ctrl: make parameter optional
      soc: qcom: apr: Don't use reg for domain id
      soc: qcom: fix QCOM_AOSS_QMP dependency and build errors
      memory: tegra: Fix -Wunused-const-variable
      firmware: tegra: Early resume BPMP
      soc/tegra: Select pinctrl for Tegra194
      ...

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 405ac24def05..e0350476feaa 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * omap_hwmod implementation for OMAP2/3/4
  *
@@ -10,10 +11,6 @@
  * Tony Lindgren, Rajendra Nayak, Vikram Pandita, Sakari Poussa, Anand
  * Sawant, Santosh Shilimkar, Richard Woodruff
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  * Introduction
  * ------------
  * One way to view an OMAP SoC is as a collection of largely unrelated

commit 2b2f7def058a5386838ef4dba70a860285f79e66
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon May 27 04:51:53 2019 -0700

    bus: ti-sysc: Add support for missing clockdomain handling
    
    We need to let ti-sysc driver manage clockdomain autoidle for the
    duration of of reset, enable and idle. And we need to do it before we
    enable the clock and after we disable it. Currently we are still
    relying on platform callbacks indirectly managing clockdomain autoidle.
    But I noticed that for device tree only probed drivers it now happens
    only after we enabling the clocks and before we disable the clocks,
    while it should be the other way around. So far I have not noticed
    any issues with this though.
    
    Let's add new ti_sysc_clkdm_deny_idle() and ti_sysc_clkdm_allow_idle()
    functions for ti-sysc driver to use to manage clockdomains directly via
    platform data callbacks. Note that we can implement the clockdomain
    functions in pdata-quirks.c as for probing devices without "ti,hwmods"
    custom property we don't need to use the other platform data callbacks.
    
    Let's do this in one patch as there's is still an unlikely chance we
    may need to apply this as a fix for v5.2 for dropping legacy platform
    data for some devices. We also do have the option of adding back the
    platform data if needed in case of trouble.
    
    Tested-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 405ac24def05..932ba221e8e7 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3445,6 +3445,7 @@ static int omap_hwmod_check_module(struct device *dev,
  * @dev: struct device
  * @oh: module
  * @sysc_fields: sysc register bits
+ * @clockdomain: clockdomain
  * @rev_offs: revision register offset
  * @sysc_offs: sysconfig register offset
  * @syss_offs: sysstatus register offset
@@ -3456,6 +3457,7 @@ static int omap_hwmod_check_module(struct device *dev,
 static int omap_hwmod_allocate_module(struct device *dev, struct omap_hwmod *oh,
 				      const struct ti_sysc_module_data *data,
 				      struct sysc_regbits *sysc_fields,
+				      struct clockdomain *clkdm,
 				      s32 rev_offs, s32 sysc_offs,
 				      s32 syss_offs, u32 sysc_flags,
 				      u32 idlemodes)
@@ -3463,8 +3465,6 @@ static int omap_hwmod_allocate_module(struct device *dev, struct omap_hwmod *oh,
 	struct omap_hwmod_class_sysconfig *sysc;
 	struct omap_hwmod_class *class = NULL;
 	struct omap_hwmod_ocp_if *oi = NULL;
-	struct clockdomain *clkdm = NULL;
-	struct clk *clk = NULL;
 	void __iomem *regs = NULL;
 	unsigned long flags;
 
@@ -3511,36 +3511,6 @@ static int omap_hwmod_allocate_module(struct device *dev, struct omap_hwmod *oh,
 		oi->user = OCP_USER_MPU | OCP_USER_SDMA;
 	}
 
-	if (!oh->_clk) {
-		struct clk_hw_omap *hwclk;
-
-		clk = of_clk_get_by_name(dev->of_node, "fck");
-		if (!IS_ERR(clk))
-			clk_prepare(clk);
-		else
-			clk = NULL;
-
-		/*
-		 * Populate clockdomain based on dts clock. It is needed for
-		 * clkdm_deny_idle() and clkdm_allow_idle() until we have have
-		 * interconnect driver and reset driver capable of blocking
-		 * clockdomain idle during reset, enable and idle.
-		 */
-		if (clk) {
-			hwclk = to_clk_hw_omap(__clk_get_hw(clk));
-			if (hwclk && hwclk->clkdm_name)
-				clkdm = clkdm_lookup(hwclk->clkdm_name);
-		}
-
-		/*
-		 * Note that we assume interconnect driver manages the clocks
-		 * and do not need to populate oh->_clk for dynamically
-		 * allocated modules.
-		 */
-		clk_unprepare(clk);
-		clk_put(clk);
-	}
-
 	spin_lock_irqsave(&oh->_lock, flags);
 	if (regs)
 		oh->_mpu_rt_va = regs;
@@ -3626,7 +3596,7 @@ int omap_hwmod_init_module(struct device *dev,
 	u32 sysc_flags, idlemodes;
 	int error;
 
-	if (!dev || !data)
+	if (!dev || !data || !data->name || !cookie)
 		return -EINVAL;
 
 	oh = _lookup(data->name);
@@ -3697,7 +3667,8 @@ int omap_hwmod_init_module(struct device *dev,
 		return error;
 
 	return omap_hwmod_allocate_module(dev, oh, data, sysc_fields,
-					  rev_offs, sysc_offs, syss_offs,
+					  cookie->clkdm, rev_offs,
+					  sysc_offs, syss_offs,
 					  sysc_flags, idlemodes);
 }
 

commit 22c58fd70ca48a29505922b1563826593b08cc00
Merge: a455eda33faa 7a0c4c17089a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 16 08:31:32 2019 -0700

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc
    
    Pull ARM SoC platform updates from Olof Johansson:
     "SoC updates, mostly refactorings and cleanups of old legacy platforms.
    
      Major themes this release:
    
       - Conversion of ixp4xx to a modern platform (drivers, DT, bindings)
    
       - Moving some of the ep93xx headers around to get it closer to
         multiplatform enabled.
    
       - Cleanups of Davinci
    
      This also contains a few patches that were queued up as fixes before
      5.1 but I didn't get sent in before release"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc: (123 commits)
      ARM: debug-ll: add default address for digicolor
      ARM: u300: regulator: add MODULE_LICENSE()
      ARM: ep93xx: move private headers out of mach/*
      ARM: ep93xx: move pinctrl interfaces into include/linux/soc
      ARM: ep93xx: keypad: stop using mach/platform.h
      ARM: ep93xx: move network platform data to separate header
      ARM: stm32: add AMBA support for stm32 family
      MAINTAINERS: update arch/arm/mach-davinci
      ARM: rockchip: add missing of_node_put in rockchip_smp_prepare_pmu
      ARM: dts: Add queue manager and NPE to the IXP4xx DTSI
      soc: ixp4xx: qmgr: Add DT probe code
      soc: ixp4xx: qmgr: Add DT bindings for IXP4xx qmgr
      soc: ixp4xx: npe: Add DT probe code
      soc: ixp4xx: Add DT bindings for IXP4xx NPE
      soc: ixp4xx: qmgr: Pass resources
      soc: ixp4xx: Remove unused functions
      soc: ixp4xx: Uninline several functions
      soc: ixp4xx: npe: Pass addresses as resources
      ARM: ixp4xx: Turn the QMGR into a platform device
      ARM: ixp4xx: Turn the NPE into a platform device
      ...

commit a348f05361c968cf4a54b6a4f3aeb6f9a271956a
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Apr 4 11:11:03 2019 +0300

    ARM: omap2+: hwmod: drop CLK_IS_BASIC flag usage
    
    CLK_IS_BASIC flag is about to get deprecated, and as such, can't be used.
    Instead, the API call for checking whether a clock is of type hw_omap shall
    be used, so convert the code to use this.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Stephen Boyd <sboyd@kernel.org>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 3a04c73ac03c..baadddf9aad4 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -648,10 +648,10 @@ static struct clockdomain *_get_clkdm(struct omap_hwmod *oh)
 	if (oh->clkdm) {
 		return oh->clkdm;
 	} else if (oh->_clk) {
-		if (__clk_get_flags(oh->_clk) & CLK_IS_BASIC)
+		if (!omap2_clk_is_hw_omap(__clk_get_hw(oh->_clk)))
 			return NULL;
 		clk = to_clk_hw_omap(__clk_get_hw(oh->_clk));
-		return  clk->clkdm;
+		return clk->clkdm;
 	}
 	return NULL;
 }

commit b4a9a7a38917e9f947b5e69f7e8d4138d4c82845
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Mar 21 13:27:08 2019 -0700

    bus: ti-sysc: Handle swsup idle mode quirks
    
    In preparation of dropping interconnect target module platform data in
    favor of devicetree based data, we must pass swsup idle quirks to the
    platform data functions.
    
    For now, let's only tag the UART modules with the SWSUP_SIDLE_ACT quirk.
    The other modules will get tagged with swsup quirks as we drop the
    platform data and test the changes.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 4a924e444f8d..4af2e9f0966d 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3683,6 +3683,12 @@ int omap_hwmod_init_module(struct device *dev,
 		oh->flags |= HWMOD_INIT_NO_RESET;
 	if (data->cfg->quirks & SYSC_QUIRK_USE_CLOCKACT)
 		oh->flags |= HWMOD_SET_DEFAULT_CLOCKACT;
+	if (data->cfg->quirks & SYSC_QUIRK_SWSUP_SIDLE)
+		oh->flags |= HWMOD_SWSUP_SIDLE;
+	if (data->cfg->quirks & SYSC_QUIRK_SWSUP_SIDLE_ACT)
+		oh->flags |= HWMOD_SWSUP_SIDLE_ACT;
+	if (data->cfg->quirks & SYSC_QUIRK_SWSUP_MSTANDBY)
+		oh->flags |= HWMOD_SWSUP_MSTANDBY;
 
 	error = omap_hwmod_check_module(dev, oh, data, sysc_fields,
 					rev_offs, sysc_offs, syss_offs,

commit 10645e81b9677c5ed9de371b382234564eb73660
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Mar 22 08:08:06 2019 -0700

    bus: ti-sysc: Pass clockactivity quirk to platform functions
    
    We already have the clockactivity quirk set for some modules like i2c,
    timers and smartreflex. But we're not passing it to the platform functions
    yet. Let's start doing that in preparation of dropping interconnect target
    module platform data in favor of device tree based data.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index a985844dbe39..4a924e444f8d 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3681,6 +3681,8 @@ int omap_hwmod_init_module(struct device *dev,
 		oh->flags |= HWMOD_INIT_NO_IDLE;
 	if (data->cfg->quirks & SYSC_QUIRK_NO_RESET_ON_INIT)
 		oh->flags |= HWMOD_INIT_NO_RESET;
+	if (data->cfg->quirks & SYSC_QUIRK_USE_CLOCKACT)
+		oh->flags |= HWMOD_SET_DEFAULT_CLOCKACT;
 
 	error = omap_hwmod_check_module(dev, oh, data, sysc_fields,
 					rev_offs, sysc_offs, syss_offs,

commit 386cb76681ca6248878c7b76d3d5aa0e8b8a07bb
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Mar 22 07:49:30 2019 -0700

    bus: ti-sysc: Handle missed no-idle property in addition to no-idle-on-init
    
    We have ti,no-idle in use in addition to ti,no-idle-on-init but we're
    missing handling for it in the ti-sysc interconnect target module driver.
    
    Let's also group the idle defines together and update the binding
    documentation for it.
    
    Cc: devicetree@vger.kernel.org
    Reviewed-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 9170fbfb7c59..a985844dbe39 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3675,6 +3675,8 @@ int omap_hwmod_init_module(struct device *dev,
 	if (error)
 		return error;
 
+	if (data->cfg->quirks & SYSC_QUIRK_NO_IDLE)
+		oh->flags |= HWMOD_NO_IDLE;
 	if (data->cfg->quirks & SYSC_QUIRK_NO_IDLE_ON_INIT)
 		oh->flags |= HWMOD_INIT_NO_IDLE;
 	if (data->cfg->quirks & SYSC_QUIRK_NO_RESET_ON_INIT)

commit 8b30919a4e3c7aba32dd72e8208147a6496cb16c
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Mar 21 11:00:21 2019 -0700

    ARM: OMAP2+: Handle reset quirks for dynamically allocated modules
    
    For dynamically allocated struct omap_hwmod data, we need to populate
    the device IP specific reset quirks.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index ed3d503167f4..9170fbfb7c59 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -155,6 +155,8 @@
 #include "soc.h"
 #include "common.h"
 #include "clockdomain.h"
+#include "hdq1w.h"
+#include "mmc.h"
 #include "powerdomain.h"
 #include "cm2xxx.h"
 #include "cm3xxx.h"
@@ -165,6 +167,7 @@
 #include "prm33xx.h"
 #include "prminst44xx.h"
 #include "pm.h"
+#include "wd_timer.h"
 
 /* Name of the OMAP hwmod for the MPU */
 #define MPU_INITIATOR_NAME		"mpu"
@@ -204,6 +207,20 @@ struct clkctrl_provider {
 
 static LIST_HEAD(clkctrl_providers);
 
+/**
+ * struct omap_hwmod_reset - IP specific reset functions
+ * @match: string to match against the module name
+ * @len: number of characters to match
+ * @reset: IP specific reset function
+ *
+ * Used only in cases where struct omap_hwmod is dynamically allocated.
+ */
+struct omap_hwmod_reset {
+	const char *match;
+	int len;
+	int (*reset)(struct omap_hwmod *oh);
+};
+
 /**
  * struct omap_hwmod_soc_ops - fn ptrs for some SoC-specific operations
  * @enable_module: function to enable a module (via MODULEMODE)
@@ -3542,6 +3559,57 @@ static int omap_hwmod_allocate_module(struct device *dev, struct omap_hwmod *oh,
 	return 0;
 }
 
+static const struct omap_hwmod_reset omap24xx_reset_quirks[] = {
+	{ .match = "msdi", .len = 4, .reset = omap_msdi_reset, },
+};
+
+static const struct omap_hwmod_reset dra7_reset_quirks[] = {
+	{ .match = "pcie", .len = 4, .reset = dra7xx_pciess_reset, },
+};
+
+static const struct omap_hwmod_reset omap_reset_quirks[] = {
+	{ .match = "dss", .len = 3, .reset = omap_dss_reset, },
+	{ .match = "hdq1w", .len = 5, .reset = omap_hdq1w_reset, },
+	{ .match = "i2c", .len = 3, .reset = omap_i2c_reset, },
+	{ .match = "wd_timer", .len = 8, .reset = omap2_wd_timer_reset, },
+};
+
+static void
+omap_hwmod_init_reset_quirk(struct device *dev, struct omap_hwmod *oh,
+			    const struct ti_sysc_module_data *data,
+			    const struct omap_hwmod_reset *quirks,
+			    int quirks_sz)
+{
+	const struct omap_hwmod_reset *quirk;
+	int i;
+
+	for (i = 0; i < quirks_sz; i++) {
+		quirk = &quirks[i];
+		if (!strncmp(data->name, quirk->match, quirk->len)) {
+			oh->class->reset = quirk->reset;
+
+			return;
+		}
+	}
+}
+
+static void
+omap_hwmod_init_reset_quirks(struct device *dev, struct omap_hwmod *oh,
+			     const struct ti_sysc_module_data *data)
+{
+	if (soc_is_omap24xx())
+		omap_hwmod_init_reset_quirk(dev, oh, data,
+					    omap24xx_reset_quirks,
+					    ARRAY_SIZE(omap24xx_reset_quirks));
+
+	if (soc_is_dra7xx())
+		omap_hwmod_init_reset_quirk(dev, oh, data, dra7_reset_quirks,
+					    ARRAY_SIZE(dra7_reset_quirks));
+
+	omap_hwmod_init_reset_quirk(dev, oh, data, omap_reset_quirks,
+				    ARRAY_SIZE(omap_reset_quirks));
+}
+
 /**
  * omap_hwmod_init_module - initialize new module
  * @dev: struct device
@@ -3580,6 +3648,8 @@ int omap_hwmod_init_module(struct device *dev,
 			return -ENOMEM;
 		}
 
+		omap_hwmod_init_reset_quirks(dev, oh, data);
+
 		oh->class->name = data->name;
 		mutex_lock(&list_lock);
 		error = _register(oh);

commit b57250fa5eb35cd805e7eee7f7b5a4b3b3cb4227
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Mar 21 11:00:21 2019 -0700

    ARM: OMAP2+: Allocate struct omap_hwmod based on dts data
    
    With ti-sysc interconnect target module, we can allocate struct omap_hwmod
    data based on the devicetree data. This allows dropping the static SoC
    specific data eventually so we will only boot with data we actually need.
    
    To allocate struct omap_hwmod dynamically, we need to add a mutex for
    modifying the list, and remove __init for few functions.
    
    Note that we are not initialized oh->_clk or the optional clocks and their
    related quirks. That can be directly handled by the interconnect target
    module driver.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index dc172fff9ced..ed3d503167f4 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -235,6 +235,7 @@ static struct omap_hwmod_soc_ops soc_ops;
 
 /* omap_hwmod_list contains all registered struct omap_hwmods */
 static LIST_HEAD(omap_hwmod_list);
+static DEFINE_MUTEX(list_lock);
 
 /* mpu_oh: used to add/remove MPU initiator from sleepdep list */
 static struct omap_hwmod *mpu_oh;
@@ -2624,7 +2625,7 @@ static int _setup(struct omap_hwmod *oh, void *data)
  * that the copy process would be relatively complex due to the large number
  * of substructures.
  */
-static int __init _register(struct omap_hwmod *oh)
+static int _register(struct omap_hwmod *oh)
 {
 	if (!oh || !oh->name || !oh->class || !oh->class->name ||
 	    (oh->_state != _HWMOD_STATE_UNKNOWN))
@@ -2663,7 +2664,7 @@ static int __init _register(struct omap_hwmod *oh)
  * locking in this code.  Changes to this assumption will require
  * additional locking.  Returns 0.
  */
-static int __init _add_link(struct omap_hwmod_ocp_if *oi)
+static int _add_link(struct omap_hwmod_ocp_if *oi)
 {
 	pr_debug("omap_hwmod: %s -> %s: adding link\n", oi->master->name,
 		 oi->slave->name);
@@ -3444,6 +3445,9 @@ static int omap_hwmod_allocate_module(struct device *dev, struct omap_hwmod *oh,
 {
 	struct omap_hwmod_class_sysconfig *sysc;
 	struct omap_hwmod_class *class = NULL;
+	struct omap_hwmod_ocp_if *oi = NULL;
+	struct clockdomain *clkdm = NULL;
+	struct clk *clk = NULL;
 	void __iomem *regs = NULL;
 	unsigned long flags;
 
@@ -3476,13 +3480,62 @@ static int omap_hwmod_allocate_module(struct device *dev, struct omap_hwmod *oh,
 			return -ENOMEM;
 	}
 
+	if (list_empty(&oh->slave_ports)) {
+		oi = kcalloc(1, sizeof(*oi), GFP_KERNEL);
+		if (!oi)
+			return -ENOMEM;
+
+		/*
+		 * Note that we assume interconnect interface clocks will be
+		 * managed by the interconnect driver for OCPIF_SWSUP_IDLE case
+		 * on omap24xx and omap3.
+		 */
+		oi->slave = oh;
+		oi->user = OCP_USER_MPU | OCP_USER_SDMA;
+	}
+
+	if (!oh->_clk) {
+		struct clk_hw_omap *hwclk;
+
+		clk = of_clk_get_by_name(dev->of_node, "fck");
+		if (!IS_ERR(clk))
+			clk_prepare(clk);
+		else
+			clk = NULL;
+
+		/*
+		 * Populate clockdomain based on dts clock. It is needed for
+		 * clkdm_deny_idle() and clkdm_allow_idle() until we have have
+		 * interconnect driver and reset driver capable of blocking
+		 * clockdomain idle during reset, enable and idle.
+		 */
+		if (clk) {
+			hwclk = to_clk_hw_omap(__clk_get_hw(clk));
+			if (hwclk && hwclk->clkdm_name)
+				clkdm = clkdm_lookup(hwclk->clkdm_name);
+		}
+
+		/*
+		 * Note that we assume interconnect driver manages the clocks
+		 * and do not need to populate oh->_clk for dynamically
+		 * allocated modules.
+		 */
+		clk_unprepare(clk);
+		clk_put(clk);
+	}
+
 	spin_lock_irqsave(&oh->_lock, flags);
 	if (regs)
 		oh->_mpu_rt_va = regs;
 	if (class)
 		oh->class = class;
 	oh->class->sysc = sysc;
+	if (oi)
+		_add_link(oi);
+	if (clkdm)
+		oh->clkdm = clkdm;
 	oh->_state = _HWMOD_STATE_INITIALIZED;
+	oh->_postsetup_state = _HWMOD_STATE_DEFAULT;
 	_setup(oh, NULL);
 	spin_unlock_irqrestore(&oh->_lock, flags);
 
@@ -3509,8 +3562,29 @@ int omap_hwmod_init_module(struct device *dev,
 		return -EINVAL;
 
 	oh = _lookup(data->name);
-	if (!oh)
-		return -ENODEV;
+	if (!oh) {
+		oh = kzalloc(sizeof(*oh), GFP_KERNEL);
+		if (!oh)
+			return -ENOMEM;
+
+		oh->name = data->name;
+		oh->_state = _HWMOD_STATE_UNKNOWN;
+		lockdep_register_key(&oh->hwmod_key);
+
+		/* Unused, can be handled by PRM driver handling resets */
+		oh->prcm.omap4.flags = HWMOD_OMAP4_NO_CONTEXT_LOSS_BIT;
+
+		oh->class = kzalloc(sizeof(*oh->class), GFP_KERNEL);
+		if (!oh->class) {
+			kfree(oh);
+			return -ENOMEM;
+		}
+
+		oh->class->name = data->name;
+		mutex_lock(&list_lock);
+		error = _register(oh);
+		mutex_unlock(&list_lock);
+	}
 
 	cookie->data = oh;
 

commit 513a4abb19d55253ea9490288986ec781a78b786
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Mar 21 11:00:21 2019 -0700

    ARM: OMAP2+: Prepare class allocation for dynamically allocated modules
    
    For dynamically allocated sysconfig data we only need to allocate a new
    class for the cases where the class is shared. For dynamically allocated
    struct omap_hwmod we will always allocate a new class.
    
    Let's add detection for when we need to allocate a new class by comparing
    the class name against the module name. If they match, there's no need
    to allocate a new calls as we don't have case of mixed platform data and
    dts data initialized modules for the same class.
    
    Let's also move the init of class data inside the spinlock.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index b88cf32cf8a9..dc172fff9ced 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3443,7 +3443,7 @@ static int omap_hwmod_allocate_module(struct device *dev, struct omap_hwmod *oh,
 				      u32 idlemodes)
 {
 	struct omap_hwmod_class_sysconfig *sysc;
-	struct omap_hwmod_class *class;
+	struct omap_hwmod_class *class = NULL;
 	void __iomem *regs = NULL;
 	unsigned long flags;
 
@@ -3467,19 +3467,21 @@ static int omap_hwmod_allocate_module(struct device *dev, struct omap_hwmod *oh,
 	}
 
 	/*
-	 * We need new oh->class as the other devices in the same class
+	 * We may need a new oh->class as the other devices in the same class
 	 * may not yet have ioremapped their registers.
 	 */
-	class = kmemdup(oh->class, sizeof(*oh->class), GFP_KERNEL);
-	if (!class)
-		return -ENOMEM;
-
-	class->sysc = sysc;
+	if (oh->class->name && strcmp(oh->class->name, data->name)) {
+		class = kmemdup(oh->class, sizeof(*oh->class), GFP_KERNEL);
+		if (!class)
+			return -ENOMEM;
+	}
 
 	spin_lock_irqsave(&oh->_lock, flags);
 	if (regs)
 		oh->_mpu_rt_va = regs;
-	oh->class = class;
+	if (class)
+		oh->class = class;
+	oh->class->sysc = sysc;
 	oh->_state = _HWMOD_STATE_INITIALIZED;
 	_setup(oh, NULL);
 	spin_unlock_irqrestore(&oh->_lock, flags);

commit 798bd175ab0d8024652ddba2cacaba6768c63c30
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Mar 21 11:00:21 2019 -0700

    ARM: OMAP2+: Make interconnect target module allocation functions static
    
    Only omap_hwmod_init_module() gets called, the rest of the interconnect
    target module allocation functions can be static.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 21afaf630caa..b88cf32cf8a9 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3241,9 +3241,10 @@ static int omap_hwmod_init_regbits(struct device *dev,
  * @sysc_offs: sysc register offset
  * @syss_offs: syss register offset
  */
-int omap_hwmod_init_reg_offs(struct device *dev,
-			     const struct ti_sysc_module_data *data,
-			     s32 *rev_offs, s32 *sysc_offs, s32 *syss_offs)
+static int omap_hwmod_init_reg_offs(struct device *dev,
+				    const struct ti_sysc_module_data *data,
+				    s32 *rev_offs, s32 *sysc_offs,
+				    s32 *syss_offs)
 {
 	*rev_offs = -ENODEV;
 	*sysc_offs = 0;
@@ -3267,9 +3268,9 @@ int omap_hwmod_init_reg_offs(struct device *dev,
  * @data: module data
  * @sysc_flags: module configuration
  */
-int omap_hwmod_init_sysc_flags(struct device *dev,
-			       const struct ti_sysc_module_data *data,
-			       u32 *sysc_flags)
+static int omap_hwmod_init_sysc_flags(struct device *dev,
+				      const struct ti_sysc_module_data *data,
+				      u32 *sysc_flags)
 {
 	*sysc_flags = 0;
 
@@ -3341,9 +3342,9 @@ int omap_hwmod_init_sysc_flags(struct device *dev,
  * @data: module data
  * @idlemodes: module supported idle modes
  */
-int omap_hwmod_init_idlemodes(struct device *dev,
-			      const struct ti_sysc_module_data *data,
-			      u32 *idlemodes)
+static int omap_hwmod_init_idlemodes(struct device *dev,
+				     const struct ti_sysc_module_data *data,
+				     u32 *idlemodes)
 {
 	*idlemodes = 0;
 
@@ -3434,11 +3435,12 @@ static int omap_hwmod_check_module(struct device *dev,
  *
  * Note that the allocations here cannot use devm as ti-sysc can rebind.
  */
-int omap_hwmod_allocate_module(struct device *dev, struct omap_hwmod *oh,
-			       const struct ti_sysc_module_data *data,
-			       struct sysc_regbits *sysc_fields,
-			       s32 rev_offs, s32 sysc_offs, s32 syss_offs,
-			       u32 sysc_flags, u32 idlemodes)
+static int omap_hwmod_allocate_module(struct device *dev, struct omap_hwmod *oh,
+				      const struct ti_sysc_module_data *data,
+				      struct sysc_regbits *sysc_fields,
+				      s32 rev_offs, s32 sysc_offs,
+				      s32 syss_offs, u32 sysc_flags,
+				      u32 idlemodes)
 {
 	struct omap_hwmod_class_sysconfig *sysc;
 	struct omap_hwmod_class *class;

commit 7f0d078667a494466991aa7133f49594f32ff6a2
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Mar 21 11:00:21 2019 -0700

    ARM: OMAP2+: Fix potentially uninitialized return value for _setup_reset()
    
    Commit 747834ab8347 ("ARM: OMAP2+: hwmod: revise hardreset behavior") made
    the call to _enable() conditional based on no oh->rst_lines_cnt. This
    caused the return value to be potentially uninitialized. Curiously we see
    no compiler warnings for this, probably as this gets inlined.
    
    We call _setup_reset() from _setup() and only _setup_postsetup() if the
    return value is zero. Currently the return value can be uninitialized for
    cases where oh->rst_lines_cnt is set and HWMOD_INIT_NO_RESET is not set.
    
    Fixes: 747834ab8347 ("ARM: OMAP2+: hwmod: revise hardreset behavior")
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 3a04c73ac03c..21afaf630caa 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2465,7 +2465,7 @@ static void _setup_iclk_autoidle(struct omap_hwmod *oh)
  */
 static int _setup_reset(struct omap_hwmod *oh)
 {
-	int r;
+	int r = 0;
 
 	if (oh->_state != _HWMOD_STATE_INITIALIZED)
 		return -EINVAL;

commit 12af39cad78e9cb8172793ca5d7f369eb144578b
Author: Andreas Kemnade <andreas@kemnade.info>
Date:   Wed Jan 16 23:04:29 2019 +0100

    ARM: OMAP2+: hwmod: disable ick autoidling when a hwmod requires that
    
    Deny autoidle for hwmods with the OCPIF_SWSUP_IDLE flag,
    that makes hwmods working properly which cannot handle
    autoidle properly in lower power states.
    Affected is e. g. the omap_hdq.
    Since an ick might have mulitple users, autoidle is disabled
    when an individual user requires that rather than in
    _setup_iclk_autoidle. dss_ick is an example for that.
    
    Signed-off-by: Andreas Kemnade <andreas@kemnade.info>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index b5531dd3ae9c..3a04c73ac03c 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1002,8 +1002,10 @@ static int _enable_clocks(struct omap_hwmod *oh)
 		clk_enable(oh->_clk);
 
 	list_for_each_entry(os, &oh->slave_ports, node) {
-		if (os->_clk && (os->flags & OCPIF_SWSUP_IDLE))
+		if (os->_clk && (os->flags & OCPIF_SWSUP_IDLE)) {
+			omap2_clk_deny_idle(os->_clk);
 			clk_enable(os->_clk);
+		}
 	}
 
 	/* The opt clocks are controlled by the device driver. */
@@ -1055,8 +1057,10 @@ static int _disable_clocks(struct omap_hwmod *oh)
 		clk_disable(oh->_clk);
 
 	list_for_each_entry(os, &oh->slave_ports, node) {
-		if (os->_clk && (os->flags & OCPIF_SWSUP_IDLE))
+		if (os->_clk && (os->flags & OCPIF_SWSUP_IDLE)) {
 			clk_disable(os->_clk);
+			omap2_clk_allow_idle(os->_clk);
+		}
 	}
 
 	if (oh->flags & HWMOD_OPT_CLKS_NEEDED)
@@ -2436,9 +2440,13 @@ static void _setup_iclk_autoidle(struct omap_hwmod *oh)
 			continue;
 
 		if (os->flags & OCPIF_SWSUP_IDLE) {
-			/* XXX omap_iclk_deny_idle(c); */
+			/*
+			 * we might have multiple users of one iclk with
+			 * different requirements, disable autoidle when
+			 * the module is enabled, e.g. dss iclk
+			 */
 		} else {
-			/* XXX omap_iclk_allow_idle(c); */
+			/* we are enabling autoidle afterwards anyways */
 			clk_enable(os->_clk);
 		}
 	}

commit d36377c6eb071e3d0751e9e0e3c19198c58d9a5d
Merge: 0922275ef157 a6f119a06960
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 31 17:32:35 2018 -0800

    Merge tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC driver updates from Olof Johansson:
     "Misc driver updates for platforms, many of them power related.
    
       - Rockchip adds power domain support for rk3066 and rk3188
    
       - Amlogic adds a power measurement driver
    
       - Allwinner adds SRAM support for three platforms (F1C100, H5, A64
         C1)
    
       - Wakeup and ti-sysc (platform bus) fixes for OMAP/DRA7
    
       - Broadcom fixes suspend/resume with Thumb2 kernels, and improves
         stability of a handful of firmware/platform interfaces
    
       - PXA completes their conversion to dmaengine framework
    
       - Renesas does a bunch of PM cleanups across many platforms
    
       - Tegra adds support for suspend/resume on T186/T194, which includes
         some driver cleanups and addition of wake events
    
       - Tegra also adds a driver for memory controller (EMC) on Tegra2
    
       - i.MX tweaks power domain bindings, and adds support for i.MX8MQ in
         GPC
    
       - Atmel adds identifiers and LPDDR2 support for a new SoC, SAM9X60
    
      and misc cleanups across several platforms"
    
    * tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (73 commits)
      ARM: at91: add support in soc driver for new SAM9X60
      ARM: at91: add support in soc driver for LPDDR2 SiP
      memory: omap-gpmc: Use of_node_name_eq for node name comparisons
      bus: ti-sysc: Check for no-reset and no-idle flags at the child level
      ARM: OMAP2+: Check also the first dts child for hwmod flags
      soc: amlogic: meson-clk-measure: Add missing REGMAP_MMIO dependency
      soc: imx: gpc: Increase GPC_CLK_MAX to 7
      soc: renesas: rcar-sysc: Fix power domain control after system resume
      soc: renesas: rcar-sysc: Merge PM Domain registration and linking
      soc: renesas: rcar-sysc: Remove rcar_sysc_power_{down,up}() helpers
      soc: renesas: r8a77990-sysc: Fix initialization order of 3DG-{A,B}
      dt-bindings: sram: sunxi: Add compatible for the A64 SRAM C1
      dt-bindings: sram: sunxi: Add bindings for the H5 with SRAM C1
      dt-bindings: sram: Add Allwinner suniv F1C100s
      soc: sunxi: sram: Add support for the H5 SoC system control
      soc: sunxi: sram: Enable EMAC clock access for H3 variant
      soc: imx: gpcv2: add support for i.MX8MQ SoC
      soc: imx: gpcv2: move register access table to domain data
      soc: imx: gpcv2: prefix i.MX7 specific defines
      dmaengine: pxa: make the filter function internal
      ...

commit 4f2122473363b569db652dc09029715ad808e1a6
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Dec 10 14:11:10 2018 -0800

    ARM: OMAP2+: Check also the first dts child for hwmod flags
    
    Until the board specific dts files are updated to have hwmod
    flags at the interconnect target module level, we want to keep
    things working both for old and new dts files.
    
    So let's also check the first child for hwmod flags. The module
    flags are for the whole module, so only the first child should
    ever have them.
    
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Reported-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 083dcd9942ce..b506d5d9da82 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2345,6 +2345,17 @@ static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data,
 	return 0;
 }
 
+static void __init parse_module_flags(struct omap_hwmod *oh,
+				      struct device_node *np)
+{
+	if (of_find_property(np, "ti,no-reset-on-init", NULL))
+		oh->flags |= HWMOD_INIT_NO_RESET;
+	if (of_find_property(np, "ti,no-idle-on-init", NULL))
+		oh->flags |= HWMOD_INIT_NO_IDLE;
+	if (of_find_property(np, "ti,no-idle", NULL))
+		oh->flags |= HWMOD_NO_IDLE;
+}
+
 /**
  * _init - initialize internal data for the hwmod @oh
  * @oh: struct omap_hwmod *
@@ -2392,12 +2403,12 @@ static int __init _init(struct omap_hwmod *oh, void *data)
 	}
 
 	if (np) {
-		if (of_find_property(np, "ti,no-reset-on-init", NULL))
-			oh->flags |= HWMOD_INIT_NO_RESET;
-		if (of_find_property(np, "ti,no-idle-on-init", NULL))
-			oh->flags |= HWMOD_INIT_NO_IDLE;
-		if (of_find_property(np, "ti,no-idle", NULL))
-			oh->flags |= HWMOD_NO_IDLE;
+		struct device_node *child;
+
+		parse_module_flags(oh, np);
+		child = of_get_next_child(np, NULL);
+		if (child)
+			parse_module_flags(oh, child);
 	}
 
 	oh->_state = _HWMOD_STATE_INITIALIZED;

commit c10b26abeb53cabc1e6271a167d3f3d396ce0218
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Wed Oct 17 17:52:07 2018 -0700

    ARM: OMAP2+: hwmod: Fix some section annotations
    
    When building the kernel with Clang, the following section mismatch
    warnings appears:
    
    WARNING: vmlinux.o(.text+0x2d398): Section mismatch in reference from
    the function _setup() to the function .init.text:_setup_iclk_autoidle()
    The function _setup() references
    the function __init _setup_iclk_autoidle().
    This is often because _setup lacks a __init
    annotation or the annotation of _setup_iclk_autoidle is wrong.
    
    WARNING: vmlinux.o(.text+0x2d3a0): Section mismatch in reference from
    the function _setup() to the function .init.text:_setup_reset()
    The function _setup() references
    the function __init _setup_reset().
    This is often because _setup lacks a __init
    annotation or the annotation of _setup_reset is wrong.
    
    WARNING: vmlinux.o(.text+0x2d408): Section mismatch in reference from
    the function _setup() to the function .init.text:_setup_postsetup()
    The function _setup() references
    the function __init _setup_postsetup().
    This is often because _setup lacks a __init
    annotation or the annotation of _setup_postsetup is wrong.
    
    _setup is used in omap_hwmod_allocate_module, which isn't marked __init
    and looks like it shouldn't be, meaning to fix these warnings, those
    functions must be moved out of the init section, which this patch does.
    
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 083dcd9942ce..921c9aaee63f 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2413,7 +2413,7 @@ static int __init _init(struct omap_hwmod *oh, void *data)
  * a stub; implementing this properly requires iclk autoidle usecounting in
  * the clock code.   No return value.
  */
-static void __init _setup_iclk_autoidle(struct omap_hwmod *oh)
+static void _setup_iclk_autoidle(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_ocp_if *os;
 
@@ -2444,7 +2444,7 @@ static void __init _setup_iclk_autoidle(struct omap_hwmod *oh)
  * reset.  Returns 0 upon success or a negative error code upon
  * failure.
  */
-static int __init _setup_reset(struct omap_hwmod *oh)
+static int _setup_reset(struct omap_hwmod *oh)
 {
 	int r;
 
@@ -2505,7 +2505,7 @@ static int __init _setup_reset(struct omap_hwmod *oh)
  *
  * No return value.
  */
-static void __init _setup_postsetup(struct omap_hwmod *oh)
+static void _setup_postsetup(struct omap_hwmod *oh)
 {
 	u8 postsetup_state;
 

commit 7e1c4e27928e5f87b9b1eaf06dc31773b2f1e7f1
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:57 2018 -0700

    memblock: stop using implicit alignment to SMP_CACHE_BYTES
    
    When a memblock allocation APIs are called with align = 0, the alignment
    is implicitly set to SMP_CACHE_BYTES.
    
    Implicit alignment is done deep in the memblock allocator and it can
    come as a surprise.  Not that such an alignment would be wrong even
    when used incorrectly but it is better to be explicit for the sake of
    clarity and the prinicple of the least surprise.
    
    Replace all such uses of memblock APIs with the 'align' parameter
    explicitly set to SMP_CACHE_BYTES and stop implicit alignment assignment
    in the memblock internal allocation functions.
    
    For the case when memblock APIs are used via helper functions, e.g.  like
    iommu_arena_new_node() in Alpha, the helper functions were detected with
    Coccinelle's help and then manually examined and updated where
    appropriate.
    
    The direct memblock APIs users were updated using the semantic patch below:
    
    @@
    expression size, min_addr, max_addr, nid;
    @@
    (
    |
    - memblock_alloc_try_nid_raw(size, 0, min_addr, max_addr, nid)
    + memblock_alloc_try_nid_raw(size, SMP_CACHE_BYTES, min_addr, max_addr,
    nid)
    |
    - memblock_alloc_try_nid_nopanic(size, 0, min_addr, max_addr, nid)
    + memblock_alloc_try_nid_nopanic(size, SMP_CACHE_BYTES, min_addr, max_addr,
    nid)
    |
    - memblock_alloc_try_nid(size, 0, min_addr, max_addr, nid)
    + memblock_alloc_try_nid(size, SMP_CACHE_BYTES, min_addr, max_addr, nid)
    |
    - memblock_alloc(size, 0)
    + memblock_alloc(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_raw(size, 0)
    + memblock_alloc_raw(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_from(size, 0, min_addr)
    + memblock_alloc_from(size, SMP_CACHE_BYTES, min_addr)
    |
    - memblock_alloc_nopanic(size, 0)
    + memblock_alloc_nopanic(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_low(size, 0)
    + memblock_alloc_low(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_low_nopanic(size, 0)
    + memblock_alloc_low_nopanic(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_from_nopanic(size, 0, min_addr)
    + memblock_alloc_from_nopanic(size, SMP_CACHE_BYTES, min_addr)
    |
    - memblock_alloc_node(size, 0, nid)
    + memblock_alloc_node(size, SMP_CACHE_BYTES, nid)
    )
    
    [mhocko@suse.com: changelog update]
    [akpm@linux-foundation.org: coding-style fixes]
    [rppt@linux.ibm.com: fix missed uses of implicit alignment]
      Link: http://lkml.kernel.org/r/20181016133656.GA10925@rapoport-lnx
    Link: http://lkml.kernel.org/r/1538687224-17535-1-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Suggested-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Paul Burton <paul.burton@mips.com>    [MIPS]
    Acked-by: Michael Ellerman <mpe@ellerman.id.au> [powerpc]
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index cd5732ab0cdf..083dcd9942ce 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -726,7 +726,7 @@ static int __init _setup_clkctrl_provider(struct device_node *np)
 	u64 size;
 	int i;
 
-	provider = memblock_alloc(sizeof(*provider), 0);
+	provider = memblock_alloc(sizeof(*provider), SMP_CACHE_BYTES);
 	if (!provider)
 		return -ENOMEM;
 
@@ -736,12 +736,14 @@ static int __init _setup_clkctrl_provider(struct device_node *np)
 		of_property_count_elems_of_size(np, "reg", sizeof(u32)) / 2;
 
 	provider->addr =
-		memblock_alloc(sizeof(void *) * provider->num_addrs, 0);
+		memblock_alloc(sizeof(void *) * provider->num_addrs,
+			       SMP_CACHE_BYTES);
 	if (!provider->addr)
 		return -ENOMEM;
 
 	provider->size =
-		memblock_alloc(sizeof(u32) * provider->num_addrs, 0);
+		memblock_alloc(sizeof(u32) * provider->num_addrs,
+			       SMP_CACHE_BYTES);
 	if (!provider->size)
 		return -ENOMEM;
 

commit 57c8a661d95dff48dd9c2f2496139082bbaf241a
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:49 2018 -0700

    mm: remove include/linux/bootmem.h
    
    Move remaining definitions and declarations from include/linux/bootmem.h
    into include/linux/memblock.h and remove the redundant header.
    
    The includes were replaced with the semantic patch below and then
    semi-automated removal of duplicated '#include <linux/memblock.h>
    
    @@
    @@
    - #include <linux/bootmem.h>
    + #include <linux/memblock.h>
    
    [sfr@canb.auug.org.au: dma-direct: fix up for the removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181002185342.133d1680@canb.auug.org.au
    [sfr@canb.auug.org.au: powerpc: fix up for removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181005161406.73ef8727@canb.auug.org.au
    [sfr@canb.auug.org.au: x86/kaslr, ACPI/NUMA: fix for linux/bootmem.h removal]
      Link: http://lkml.kernel.org/r/20181008190341.5e396491@canb.auug.org.au
    Link: http://lkml.kernel.org/r/1536927045-23536-30-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 1f9b34a7eccd..cd5732ab0cdf 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -141,7 +141,7 @@
 #include <linux/cpu.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
-#include <linux/bootmem.h>
+#include <linux/memblock.h>
 
 #include <linux/platform_data/ti-sysc.h>
 

commit eb31d559f1e8390195372cd51cfb198da8bc84b9
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:08:04 2018 -0700

    memblock: remove _virt from APIs returning virtual address
    
    The conversion is done using
    
    sed -i 's@memblock_virt_alloc@memblock_alloc@g' \
            $(git grep -l memblock_virt_alloc)
    
    Link: http://lkml.kernel.org/r/1536927045-23536-8-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 56a1fe90d394..1f9b34a7eccd 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -726,7 +726,7 @@ static int __init _setup_clkctrl_provider(struct device_node *np)
 	u64 size;
 	int i;
 
-	provider = memblock_virt_alloc(sizeof(*provider), 0);
+	provider = memblock_alloc(sizeof(*provider), 0);
 	if (!provider)
 		return -ENOMEM;
 
@@ -736,12 +736,12 @@ static int __init _setup_clkctrl_provider(struct device_node *np)
 		of_property_count_elems_of_size(np, "reg", sizeof(u32)) / 2;
 
 	provider->addr =
-		memblock_virt_alloc(sizeof(void *) * provider->num_addrs, 0);
+		memblock_alloc(sizeof(void *) * provider->num_addrs, 0);
 	if (!provider->addr)
 		return -ENOMEM;
 
 	provider->size =
-		memblock_virt_alloc(sizeof(u32) * provider->num_addrs, 0);
+		memblock_alloc(sizeof(u32) * provider->num_addrs, 0);
 	if (!provider->size)
 		return -ENOMEM;
 

commit 6e77137927639fad66e17c06b50fd319d6b59833
Author: Rob Herring <robh@kernel.org>
Date:   Tue Aug 28 10:44:27 2018 -0500

    ARM: OMAP2+: Convert to using %pOFn instead of device_node.name
    
    In preparation to remove the node name pointer from struct device_node,
    convert printf users to use the %pOFn format specifier.
    
    Cc: "Benot Cousson" <bcousson@baylibre.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: linux-omap@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    [tony@atomide.com: updated against clkctrl and rt_idx changes]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 327cc70e4f18..56a1fe90d394 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2121,8 +2121,8 @@ static int of_dev_find_hwmod(struct device_node *np,
 		if (res)
 			continue;
 		if (!strcmp(p, oh->name)) {
-			pr_debug("omap_hwmod: dt %s[%i] uses hwmod %s\n",
-				 np->name, i, oh->name);
+			pr_debug("omap_hwmod: dt %pOFn[%i] uses hwmod %s\n",
+				 np, i, oh->name);
 			return i;
 		}
 	}
@@ -2255,8 +2255,8 @@ int omap_hwmod_parse_module_range(struct omap_hwmod *oh,
 		return -ENOENT;
 
 	if (nr_addr != 1 || nr_size != 1) {
-		pr_err("%s: invalid range for %s->%s\n", __func__,
-		       oh->name, np->name);
+		pr_err("%s: invalid range for %s->%pOFn\n", __func__,
+		       oh->name, np);
 		return -EINVAL;
 	}
 
@@ -2264,8 +2264,8 @@ int omap_hwmod_parse_module_range(struct omap_hwmod *oh,
 	base = of_translate_address(np, ranges++);
 	size = be32_to_cpup(ranges);
 
-	pr_debug("omap_hwmod: %s %s at 0x%llx size 0x%llx\n",
-		 oh ? oh->name : "", np->name, base, size);
+	pr_debug("omap_hwmod: %s %pOFn at 0x%llx size 0x%llx\n",
+		 oh->name, np, base, size);
 
 	if (oh && oh->mpu_rt_idx) {
 		omap_hwmod_fix_mpu_rt_idx(oh, np, res);
@@ -2373,8 +2373,8 @@ static int __init _init(struct omap_hwmod *oh, void *data)
 	if (r)
 		pr_debug("omap_hwmod: %s missing dt data\n", oh->name);
 	else if (np && index)
-		pr_warn("omap_hwmod: %s using broken dt data from %s\n",
-			oh->name, np->name);
+		pr_warn("omap_hwmod: %s using broken dt data from %pOFn\n",
+			oh->name, np);
 
 	r = _init_mpu_rt_base(oh, NULL, index, np);
 	if (r < 0) {

commit 1b9c30fe01df01c17c5ddd9b4ea02b2ca186d5e7
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Aug 31 18:01:23 2018 +0300

    ARM: OMAP2+: hwmod_core: improve the support for clkctrl clocks
    
    This patch adds support for split memory ranges for clkctrl providers.
    This is necessary to support the coming clockdomain based split of
    clkctrl provider ranges, instead of the current CM instance based one.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index cd65ea4e9c54..327cc70e4f18 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -188,16 +188,16 @@
 
 /**
  * struct clkctrl_provider - clkctrl provider mapping data
- * @addr: base address for the provider
- * @size: size of the provider address space
- * @offset: offset of the provider from PRCM instance base
+ * @num_addrs: number of base address ranges for the provider
+ * @addr: base address(es) for the provider
+ * @size: size(s) of the provider address space(s)
  * @node: device node associated with the provider
  * @link: list link
  */
 struct clkctrl_provider {
-	u32			addr;
-	u32			size;
-	u16			offset;
+	int			num_addrs;
+	u32			*addr;
+	u32			*size;
 	struct device_node	*node;
 	struct list_head	link;
 };
@@ -724,23 +724,34 @@ static int __init _setup_clkctrl_provider(struct device_node *np)
 	const __be32 *addrp;
 	struct clkctrl_provider *provider;
 	u64 size;
+	int i;
 
 	provider = memblock_virt_alloc(sizeof(*provider), 0);
 	if (!provider)
 		return -ENOMEM;
 
-	addrp = of_get_address(np, 0, &size, NULL);
-	provider->addr = (u32)of_translate_address(np, addrp);
-	addrp = of_get_address(np->parent, 0, NULL, NULL);
-	provider->offset = provider->addr -
-			   (u32)of_translate_address(np->parent, addrp);
-	provider->addr &= ~0xff;
-	provider->size = size | 0xff;
 	provider->node = np;
 
-	pr_debug("%s: %s: %x...%x [+%x]\n", __func__, np->parent->name,
-		 provider->addr, provider->addr + provider->size,
-		 provider->offset);
+	provider->num_addrs =
+		of_property_count_elems_of_size(np, "reg", sizeof(u32)) / 2;
+
+	provider->addr =
+		memblock_virt_alloc(sizeof(void *) * provider->num_addrs, 0);
+	if (!provider->addr)
+		return -ENOMEM;
+
+	provider->size =
+		memblock_virt_alloc(sizeof(u32) * provider->num_addrs, 0);
+	if (!provider->size)
+		return -ENOMEM;
+
+	for (i = 0; i < provider->num_addrs; i++) {
+		addrp = of_get_address(np, i, &size, NULL);
+		provider->addr[i] = (u32)of_translate_address(np, addrp);
+		provider->size[i] = size;
+		pr_debug("%s: %pOF: %x...%x\n", __func__, np, provider->addr[i],
+			 provider->addr[i] + provider->size[i]);
+	}
 
 	list_add(&provider->link, &clkctrl_providers);
 
@@ -787,23 +798,26 @@ static struct clk *_lookup_clkctrl_clk(struct omap_hwmod *oh)
 	pr_debug("%s: %s: addr=%x\n", __func__, oh->name, addr);
 
 	list_for_each_entry(provider, &clkctrl_providers, link) {
-		if (provider->addr <= addr &&
-		    provider->addr + provider->size >= addr) {
-			struct of_phandle_args clkspec;
+		int i;
 
-			clkspec.np = provider->node;
-			clkspec.args_count = 2;
-			clkspec.args[0] = addr - provider->addr -
-					  provider->offset;
-			clkspec.args[1] = 0;
+		for (i = 0; i < provider->num_addrs; i++) {
+			if (provider->addr[i] <= addr &&
+			    provider->addr[i] + provider->size[i] > addr) {
+				struct of_phandle_args clkspec;
 
-			clk = of_clk_get_from_provider(&clkspec);
+				clkspec.np = provider->node;
+				clkspec.args_count = 2;
+				clkspec.args[0] = addr - provider->addr[0];
+				clkspec.args[1] = 0;
 
-			pr_debug("%s: %s got %p (offset=%x, provider=%s)\n",
-				 __func__, oh->name, clk, clkspec.args[0],
-				 provider->node->parent->name);
+				clk = of_clk_get_from_provider(&clkspec);
 
-			return clk;
+				pr_debug("%s: %s got %p (offset=%x, provider=%pOF)\n",
+					 __func__, oh->name, clk,
+					 clkspec.args[0], provider->node);
+
+				return clk;
+			}
 		}
 	}
 

commit 1dbcb97c656eed1a244c960b8b3a469c3d20ce7b
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Aug 8 01:07:04 2018 -0700

    ARM: OMAP2+: Fix module address for modules using mpu_rt_idx
    
    If we use device tree data for a module interconnect target we want
    to map the control registers from the module start. Legacy hwmod platform
    data however is using child IP offsets for cpsw module with mpu_rt_idx.
    
    In cases where we have the interconnect target module already using device
    tree data with legacy hwmod platform data still around, the sysc register
    area is not adjusted for mpu_rt_idx causing wrong registers being accessed.
    
    Let's fix the issue for mixed dts and platform data mode by ioremapping
    the module registers using child IP offset if mpu_rt_idx is set. For
    device tree only data there's no reason to use mpu_rt_idx.
    
    Fixes: 6c72b3550672 ("ARM: OMAP2+: Parse module IO range from dts for legacy
    "ti,hwmods" support")
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 7f759abcf49c..cd65ea4e9c54 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2160,6 +2160,37 @@ static int of_dev_hwmod_lookup(struct device_node *np,
 	return -ENODEV;
 }
 
+/**
+ * omap_hwmod_fix_mpu_rt_idx - fix up mpu_rt_idx register offsets
+ *
+ * @oh: struct omap_hwmod *
+ * @np: struct device_node *
+ *
+ * Fix up module register offsets for modules with mpu_rt_idx.
+ * Only needed for cpsw with interconnect target module defined
+ * in device tree while still using legacy hwmod platform data
+ * for rev, sysc and syss registers.
+ *
+ * Can be removed when all cpsw hwmod platform data has been
+ * dropped.
+ */
+static void omap_hwmod_fix_mpu_rt_idx(struct omap_hwmod *oh,
+				      struct device_node *np,
+				      struct resource *res)
+{
+	struct device_node *child = NULL;
+	int error;
+
+	child = of_get_next_child(np, child);
+	if (!child)
+		return;
+
+	error = of_address_to_resource(child, oh->mpu_rt_idx, res);
+	if (error)
+		pr_err("%s: error mapping mpu_rt_idx: %i\n",
+		       __func__, error);
+}
+
 /**
  * omap_hwmod_parse_module_range - map module IO range from device tree
  * @oh: struct omap_hwmod *
@@ -2222,6 +2253,12 @@ int omap_hwmod_parse_module_range(struct omap_hwmod *oh,
 	pr_debug("omap_hwmod: %s %s at 0x%llx size 0x%llx\n",
 		 oh ? oh->name : "", np->name, base, size);
 
+	if (oh && oh->mpu_rt_idx) {
+		omap_hwmod_fix_mpu_rt_idx(oh, np, res);
+
+		return 0;
+	}
+
 	res->start = base;
 	res->end = base + size - 1;
 	res->flags = IORESOURCE_MEM;

commit 4769c003e0fcff0ee001a9102e2605bdaa5880f0
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Aug 8 01:07:03 2018 -0700

    ARM: OMAP2+: Fix null hwmod for ti-sysc debug
    
    We may call omap_hwmod_parse_module_range() with no hwmod allocated yet
    and may have debug enabled. Let's fix this by checking for hwmod before
    trying to use it's name.
    
    Fixes: 6c72b3550672 ("ARM: OMAP2+: Parse module IO range from dts for legacy
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 2ceffd85dd3d..7f759abcf49c 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2220,7 +2220,7 @@ int omap_hwmod_parse_module_range(struct omap_hwmod *oh,
 	size = be32_to_cpup(ranges);
 
 	pr_debug("omap_hwmod: %s %s at 0x%llx size 0x%llx\n",
-		 oh->name, np->name, base, size);
+		 oh ? oh->name : "", np->name, base, size);
 
 	res->start = base;
 	res->end = base + size - 1;

commit 103fd8e7ac1f5f8e332970a95c79cd32c537798a
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Apr 16 10:21:15 2018 -0700

    ARM: OMAP2+: Use signed value for sysc register offsets
    
    We currently don't know if a revision register exists or not. Zero is
    often a valid offset for the revision register. As we are still checking
    device tree data against platform data, we will get bogus warnings with
    correct device tree data because of incomplete platform data.
    
    Let's fix the issue by using signed offsets and tag the revision registers
    that don't exist with -ENODEV, and init the missing ones with the correct
    revision register offset.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index e7d23e200ecc..2ceffd85dd3d 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -481,7 +481,7 @@ static int _wait_softreset_complete(struct omap_hwmod *oh)
 
 	sysc = oh->class->sysc;
 
-	if (sysc->sysc_flags & SYSS_HAS_RESET_STATUS)
+	if (sysc->sysc_flags & SYSS_HAS_RESET_STATUS && sysc->syss_offs > 0)
 		omap_test_timeout((omap_hwmod_read(oh, sysc->syss_offs)
 				   & SYSS_RESETDONE_MASK),
 				  MAX_MODULE_SOFTRESET_WAIT, c);
@@ -3171,19 +3171,19 @@ static int omap_hwmod_init_regbits(struct device *dev,
  */
 int omap_hwmod_init_reg_offs(struct device *dev,
 			     const struct ti_sysc_module_data *data,
-			     u32 *rev_offs, u32 *sysc_offs, u32 *syss_offs)
+			     s32 *rev_offs, s32 *sysc_offs, s32 *syss_offs)
 {
-	*rev_offs = 0;
+	*rev_offs = -ENODEV;
 	*sysc_offs = 0;
 	*syss_offs = 0;
 
-	if (data->offsets[SYSC_REVISION] > 0)
+	if (data->offsets[SYSC_REVISION] >= 0)
 		*rev_offs = data->offsets[SYSC_REVISION];
 
-	if (data->offsets[SYSC_SYSCONFIG] > 0)
+	if (data->offsets[SYSC_SYSCONFIG] >= 0)
 		*sysc_offs = data->offsets[SYSC_SYSCONFIG];
 
-	if (data->offsets[SYSC_SYSSTATUS] > 0)
+	if (data->offsets[SYSC_SYSSTATUS] >= 0)
 		*syss_offs = data->offsets[SYSC_SYSSTATUS];
 
 	return 0;
@@ -3312,8 +3312,8 @@ static int omap_hwmod_check_module(struct device *dev,
 				   struct omap_hwmod *oh,
 				   const struct ti_sysc_module_data *data,
 				   struct sysc_regbits *sysc_fields,
-				   u32 rev_offs, u32 sysc_offs,
-				   u32 syss_offs, u32 sysc_flags,
+				   s32 rev_offs, s32 sysc_offs,
+				   s32 syss_offs, u32 sysc_flags,
 				   u32 idlemodes)
 {
 	if (!oh->class->sysc)
@@ -3365,7 +3365,7 @@ static int omap_hwmod_check_module(struct device *dev,
 int omap_hwmod_allocate_module(struct device *dev, struct omap_hwmod *oh,
 			       const struct ti_sysc_module_data *data,
 			       struct sysc_regbits *sysc_fields,
-			       u32 rev_offs, u32 sysc_offs, u32 syss_offs,
+			       s32 rev_offs, s32 sysc_offs, s32 syss_offs,
 			       u32 sysc_flags, u32 idlemodes)
 {
 	struct omap_hwmod_class_sysconfig *sysc;
@@ -3425,7 +3425,8 @@ int omap_hwmod_init_module(struct device *dev,
 {
 	struct omap_hwmod *oh;
 	struct sysc_regbits *sysc_fields;
-	u32 rev_offs, sysc_offs, syss_offs, sysc_flags, idlemodes;
+	s32 rev_offs, sysc_offs, syss_offs;
+	u32 sysc_flags, idlemodes;
 	int error;
 
 	if (!dev || !data)

commit 3bf5c70d06ce1d91cc73cee68bc6c4f850192cb0
Merge: 18b4788badea 695eea3d2c7f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Mar 7 16:26:43 2018 +0100

    Merge tag 'omap-for-v4.17/ti-sysc-signed' of ssh://gitolite.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into next/soc
    
    Pull "Driver changes for ti-sysc for v4.17" from Tony Lindgren:
    
    This series of changes enables the use device tree based sysconfig
    data for ti-sysc driver. As we already have SmartReflex data configured,
    we use that as the first driver to enable. To do that in a way where
    SmartReflex is not probed twice, we need to prepare the SmartReflex
    driver before flipping dts data on for it in the last patch of the
    series.
    
    To avoid regressions, we are checking the passed dts data against
    existing platform data since we still have it available. Then after the
    dts files are converted, we can simply drop the related platform data
    at some point in the future.
    
    * tag 'omap-for-v4.17/ti-sysc-signed' of ssh://gitolite.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap:
      ARM: OMAP2+: Enable ti-sysc to use device tree data for smartreflex
      PM / AVS: SmartReflex: Prepare to use device tree based probing
      ARM: OMAP2+: Try to parse earlycon from parent too
      ARM: OMAP2+: Add checks for device tree based sysconfig data
      ARM: OMAP2+: Add functions to allocate module data from device tree
      bus: ti-sysc: Handle some devices in omap_device compatible way
      bus: ti-sysc: Add support for platform data callbacks
      bus: ti-sysc: Remove unnecessary debugging statements
      bus: ti-sysc: Improve handling for no-reset-on-init and no-idle-on-init
      bus: ti-sysc: Handle stdout-path for debug console
      bus: ti-sysc: Add suspend and resume handling
      bus: ti-sysc: Add fck clock alias for children with notifier_block
      ARM: OMAP2+: Prepare to pass auxdata for smartreflex

commit 15618256224769621b2c2300f66ad9513135ffaa
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Feb 22 14:04:25 2018 -0800

    ARM: OMAP2+: Try to parse earlycon from parent too
    
    With ti-sysc driver the "ti,hwmods" property will be moved to the
    interconnect target module instead of the child device. To keep
    earlycon working, we need to match against the interconnect target
    module in the ti-sysc case.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index fca22f7ac0e3..2d554a48eb61 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3492,6 +3492,12 @@ static void __init omap_hwmod_setup_earlycon_flags(void)
 			if (np) {
 				uart = of_get_property(np, "ti,hwmods", NULL);
 				oh = omap_hwmod_lookup(uart);
+				if (!oh) {
+					uart = of_get_property(np->parent,
+							       "ti,hwmods",
+							       NULL);
+					oh = omap_hwmod_lookup(uart);
+				}
 				if (oh)
 					oh->flags |= DEBUG_OMAPUART_FLAGS;
 			}

commit a88443068572aaa79048bc19c741e0edae17faa7
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Feb 23 08:59:23 2018 -0800

    ARM: OMAP2+: Add checks for device tree based sysconfig data
    
    We can check the device tree based sysconfig data against the existing
    platform data to make sure we're not introducing regressions. Then at
    some point after the sysconfig data comes from device tree, we can just
    drop the related platform data.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 20895fcadbf5..fca22f7ac0e3 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3062,6 +3062,53 @@ int __init omap_hwmod_setup_one(const char *oh_name)
 	return 0;
 }
 
+static void omap_hwmod_check_one(struct device *dev,
+				 const char *name, s8 v1, u8 v2)
+{
+	if (v1 < 0)
+		return;
+
+	if (v1 != v2)
+		dev_warn(dev, "%s %d != %d\n", name, v1, v2);
+}
+
+/**
+ * omap_hwmod_check_sysc - check sysc against platform sysc
+ * @dev: struct device
+ * @data: module data
+ * @sysc_fields: new sysc configuration
+ */
+static int omap_hwmod_check_sysc(struct device *dev,
+				 const struct ti_sysc_module_data *data,
+				 struct sysc_regbits *sysc_fields)
+{
+	const struct sysc_regbits *regbits = data->cap->regbits;
+
+	omap_hwmod_check_one(dev, "dmadisable_shift",
+			     regbits->dmadisable_shift,
+			     sysc_fields->dmadisable_shift);
+	omap_hwmod_check_one(dev, "midle_shift",
+			     regbits->midle_shift,
+			     sysc_fields->midle_shift);
+	omap_hwmod_check_one(dev, "sidle_shift",
+			     regbits->sidle_shift,
+			     sysc_fields->sidle_shift);
+	omap_hwmod_check_one(dev, "clkact_shift",
+			     regbits->clkact_shift,
+			     sysc_fields->clkact_shift);
+	omap_hwmod_check_one(dev, "enwkup_shift",
+			     regbits->enwkup_shift,
+			     sysc_fields->enwkup_shift);
+	omap_hwmod_check_one(dev, "srst_shift",
+			     regbits->srst_shift,
+			     sysc_fields->srst_shift);
+	omap_hwmod_check_one(dev, "autoidle_shift",
+			     regbits->autoidle_shift,
+			     sysc_fields->autoidle_shift);
+
+	return 0;
+}
+
 /**
  * omap_hwmod_init_regbits - init sysconfig specific register bits
  * @dev: struct device
@@ -3111,7 +3158,7 @@ static int omap_hwmod_init_regbits(struct device *dev,
 		return -EINVAL;
 	}
 
-	return 0;
+	return omap_hwmod_check_sysc(dev, data, *sysc_fields);
 }
 
 /**
@@ -3249,6 +3296,59 @@ int omap_hwmod_init_idlemodes(struct device *dev,
 	return 0;
 }
 
+/**
+ * omap_hwmod_check_module - check new module against platform data
+ * @dev: struct device
+ * @oh: module
+ * @data: new module data
+ * @sysc_fields: sysc register bits
+ * @rev_offs: revision register offset
+ * @sysc_offs: sysconfig register offset
+ * @syss_offs: sysstatus register offset
+ * @sysc_flags: sysc specific flags
+ * @idlemodes: sysc supported idlemodes
+ */
+static int omap_hwmod_check_module(struct device *dev,
+				   struct omap_hwmod *oh,
+				   const struct ti_sysc_module_data *data,
+				   struct sysc_regbits *sysc_fields,
+				   u32 rev_offs, u32 sysc_offs,
+				   u32 syss_offs, u32 sysc_flags,
+				   u32 idlemodes)
+{
+	if (!oh->class->sysc)
+		return -ENODEV;
+
+	if (sysc_fields != oh->class->sysc->sysc_fields)
+		dev_warn(dev, "sysc_fields %p != %p\n", sysc_fields,
+			 oh->class->sysc->sysc_fields);
+
+	if (rev_offs != oh->class->sysc->rev_offs)
+		dev_warn(dev, "rev_offs %08x != %08x\n", rev_offs,
+			 oh->class->sysc->rev_offs);
+	if (sysc_offs != oh->class->sysc->sysc_offs)
+		dev_warn(dev, "sysc_offs %08x != %08x\n", sysc_offs,
+			 oh->class->sysc->sysc_offs);
+	if (syss_offs != oh->class->sysc->syss_offs)
+		dev_warn(dev, "syss_offs %08x != %08x\n", syss_offs,
+			 oh->class->sysc->syss_offs);
+
+	if (sysc_flags != oh->class->sysc->sysc_flags)
+		dev_warn(dev, "sysc_flags %08x != %08x\n", sysc_flags,
+			 oh->class->sysc->sysc_flags);
+
+	if (idlemodes != oh->class->sysc->idlemodes)
+		dev_warn(dev, "idlemodes %08x != %08x\n", idlemodes,
+			 oh->class->sysc->idlemodes);
+
+	if (data->cfg->srst_udelay != oh->class->sysc->srst_udelay)
+		dev_warn(dev, "srst_udelay %i != %i\n",
+			 data->cfg->srst_udelay,
+			 oh->class->sysc->srst_udelay);
+
+	return 0;
+}
+
 /**
  * omap_hwmod_allocate_module - allocate new module
  * @dev: struct device
@@ -3359,8 +3459,11 @@ int omap_hwmod_init_module(struct device *dev,
 	if (data->cfg->quirks & SYSC_QUIRK_NO_RESET_ON_INIT)
 		oh->flags |= HWMOD_INIT_NO_RESET;
 
-	if (oh->class->sysc)
-		return 0;
+	error = omap_hwmod_check_module(dev, oh, data, sysc_fields,
+					rev_offs, sysc_offs, syss_offs,
+					sysc_flags, idlemodes);
+	if (!error)
+		return error;
 
 	return omap_hwmod_allocate_module(dev, oh, data, sysc_fields,
 					  rev_offs, sysc_offs, syss_offs,

commit 8c87970543b17adfbd829ec1541c72a7da518acf
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Feb 22 14:04:56 2018 -0800

    ARM: OMAP2+: Add functions to allocate module data from device tree
    
    We can have ti-sysc driver manage the interconnect target module via
    platform data callback functions to hwmod code. This allows initializing
    and idling the devices using dts data instead of the legacy static data
    for interconnect target modules.
    
    Let's add functions to configure the module sysconfig data with platform
    callbacks from ti-sysc driver.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 124f9af34a15..20895fcadbf5 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -145,6 +145,8 @@
 
 #include <linux/platform_data/ti-sysc.h>
 
+#include <dt-bindings/bus/ti-sysc.h>
+
 #include <asm/system_misc.h>
 
 #include "clock.h"
@@ -2498,7 +2500,7 @@ static void __init _setup_postsetup(struct omap_hwmod *oh)
  * affects the IP block hardware, or system integration hardware
  * associated with the IP block.  Returns 0.
  */
-static int __init _setup(struct omap_hwmod *oh, void *data)
+static int _setup(struct omap_hwmod *oh, void *data)
 {
 	if (oh->_state != _HWMOD_STATE_INITIALIZED)
 		return 0;
@@ -3060,6 +3062,311 @@ int __init omap_hwmod_setup_one(const char *oh_name)
 	return 0;
 }
 
+/**
+ * omap_hwmod_init_regbits - init sysconfig specific register bits
+ * @dev: struct device
+ * @data: module data
+ * @sysc_fields: new sysc configuration
+ */
+static int omap_hwmod_init_regbits(struct device *dev,
+				   const struct ti_sysc_module_data *data,
+				   struct sysc_regbits **sysc_fields)
+{
+	*sysc_fields = NULL;
+
+	switch (data->cap->type) {
+	case TI_SYSC_OMAP2:
+	case TI_SYSC_OMAP2_TIMER:
+		*sysc_fields = &omap_hwmod_sysc_type1;
+		break;
+	case TI_SYSC_OMAP3_SHAM:
+		*sysc_fields = &omap3_sham_sysc_fields;
+		break;
+	case TI_SYSC_OMAP3_AES:
+		*sysc_fields = &omap3xxx_aes_sysc_fields;
+		break;
+	case TI_SYSC_OMAP4:
+	case TI_SYSC_OMAP4_TIMER:
+		*sysc_fields = &omap_hwmod_sysc_type2;
+		break;
+	case TI_SYSC_OMAP4_SIMPLE:
+		*sysc_fields = &omap_hwmod_sysc_type3;
+		break;
+	case TI_SYSC_OMAP34XX_SR:
+		*sysc_fields = &omap34xx_sr_sysc_fields;
+		break;
+	case TI_SYSC_OMAP36XX_SR:
+		*sysc_fields = &omap36xx_sr_sysc_fields;
+		break;
+	case TI_SYSC_OMAP4_SR:
+		*sysc_fields = &omap36xx_sr_sysc_fields;
+		break;
+	case TI_SYSC_OMAP4_MCASP:
+		*sysc_fields = &omap_hwmod_sysc_type_mcasp;
+		break;
+	case TI_SYSC_OMAP4_USB_HOST_FS:
+		*sysc_fields = &omap_hwmod_sysc_type_usb_host_fs;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/**
+ * omap_hwmod_init_reg_offs - initialize sysconfig register offsets
+ * @dev: struct device
+ * @data: module data
+ * @rev_offs: revision register offset
+ * @sysc_offs: sysc register offset
+ * @syss_offs: syss register offset
+ */
+int omap_hwmod_init_reg_offs(struct device *dev,
+			     const struct ti_sysc_module_data *data,
+			     u32 *rev_offs, u32 *sysc_offs, u32 *syss_offs)
+{
+	*rev_offs = 0;
+	*sysc_offs = 0;
+	*syss_offs = 0;
+
+	if (data->offsets[SYSC_REVISION] > 0)
+		*rev_offs = data->offsets[SYSC_REVISION];
+
+	if (data->offsets[SYSC_SYSCONFIG] > 0)
+		*sysc_offs = data->offsets[SYSC_SYSCONFIG];
+
+	if (data->offsets[SYSC_SYSSTATUS] > 0)
+		*syss_offs = data->offsets[SYSC_SYSSTATUS];
+
+	return 0;
+}
+
+/**
+ * omap_hwmod_init_sysc_flags - initialize sysconfig features
+ * @dev: struct device
+ * @data: module data
+ * @sysc_flags: module configuration
+ */
+int omap_hwmod_init_sysc_flags(struct device *dev,
+			       const struct ti_sysc_module_data *data,
+			       u32 *sysc_flags)
+{
+	*sysc_flags = 0;
+
+	switch (data->cap->type) {
+	case TI_SYSC_OMAP2:
+	case TI_SYSC_OMAP2_TIMER:
+		/* See SYSC_OMAP2_* in include/dt-bindings/bus/ti-sysc.h */
+		if (data->cfg->sysc_val & SYSC_OMAP2_CLOCKACTIVITY)
+			*sysc_flags |= SYSC_HAS_CLOCKACTIVITY;
+		if (data->cfg->sysc_val & SYSC_OMAP2_EMUFREE)
+			*sysc_flags |= SYSC_HAS_EMUFREE;
+		if (data->cfg->sysc_val & SYSC_OMAP2_ENAWAKEUP)
+			*sysc_flags |= SYSC_HAS_ENAWAKEUP;
+		if (data->cfg->sysc_val & SYSC_OMAP2_SOFTRESET)
+			*sysc_flags |= SYSC_HAS_SOFTRESET;
+		if (data->cfg->sysc_val & SYSC_OMAP2_AUTOIDLE)
+			*sysc_flags |= SYSC_HAS_AUTOIDLE;
+		break;
+	case TI_SYSC_OMAP4:
+	case TI_SYSC_OMAP4_TIMER:
+		/* See SYSC_OMAP4_* in include/dt-bindings/bus/ti-sysc.h */
+		if (data->cfg->sysc_val & SYSC_OMAP4_DMADISABLE)
+			*sysc_flags |= SYSC_HAS_DMADISABLE;
+		if (data->cfg->sysc_val & SYSC_OMAP4_FREEEMU)
+			*sysc_flags |= SYSC_HAS_EMUFREE;
+		if (data->cfg->sysc_val & SYSC_OMAP4_SOFTRESET)
+			*sysc_flags |= SYSC_HAS_SOFTRESET;
+		break;
+	case TI_SYSC_OMAP34XX_SR:
+	case TI_SYSC_OMAP36XX_SR:
+		/* See SYSC_OMAP3_SR_* in include/dt-bindings/bus/ti-sysc.h */
+		if (data->cfg->sysc_val & SYSC_OMAP3_SR_ENAWAKEUP)
+			*sysc_flags |= SYSC_HAS_ENAWAKEUP;
+		break;
+	default:
+		if (data->cap->regbits->emufree_shift >= 0)
+			*sysc_flags |= SYSC_HAS_EMUFREE;
+		if (data->cap->regbits->enwkup_shift >= 0)
+			*sysc_flags |= SYSC_HAS_ENAWAKEUP;
+		if (data->cap->regbits->srst_shift >= 0)
+			*sysc_flags |= SYSC_HAS_SOFTRESET;
+		if (data->cap->regbits->autoidle_shift >= 0)
+			*sysc_flags |= SYSC_HAS_AUTOIDLE;
+		break;
+	}
+
+	if (data->cap->regbits->midle_shift >= 0 &&
+	    data->cfg->midlemodes)
+		*sysc_flags |= SYSC_HAS_MIDLEMODE;
+
+	if (data->cap->regbits->sidle_shift >= 0 &&
+	    data->cfg->sidlemodes)
+		*sysc_flags |= SYSC_HAS_SIDLEMODE;
+
+	if (data->cfg->quirks & SYSC_QUIRK_UNCACHED)
+		*sysc_flags |= SYSC_NO_CACHE;
+	if (data->cfg->quirks & SYSC_QUIRK_RESET_STATUS)
+		*sysc_flags |= SYSC_HAS_RESET_STATUS;
+
+	if (data->cfg->syss_mask & 1)
+		*sysc_flags |= SYSS_HAS_RESET_STATUS;
+
+	return 0;
+}
+
+/**
+ * omap_hwmod_init_idlemodes - initialize module idle modes
+ * @dev: struct device
+ * @data: module data
+ * @idlemodes: module supported idle modes
+ */
+int omap_hwmod_init_idlemodes(struct device *dev,
+			      const struct ti_sysc_module_data *data,
+			      u32 *idlemodes)
+{
+	*idlemodes = 0;
+
+	if (data->cfg->midlemodes & BIT(SYSC_IDLE_FORCE))
+		*idlemodes |= MSTANDBY_FORCE;
+	if (data->cfg->midlemodes & BIT(SYSC_IDLE_NO))
+		*idlemodes |= MSTANDBY_NO;
+	if (data->cfg->midlemodes & BIT(SYSC_IDLE_SMART))
+		*idlemodes |= MSTANDBY_SMART;
+	if (data->cfg->midlemodes & BIT(SYSC_IDLE_SMART_WKUP))
+		*idlemodes |= MSTANDBY_SMART_WKUP;
+
+	if (data->cfg->sidlemodes & BIT(SYSC_IDLE_FORCE))
+		*idlemodes |= SIDLE_FORCE;
+	if (data->cfg->sidlemodes & BIT(SYSC_IDLE_NO))
+		*idlemodes |= SIDLE_NO;
+	if (data->cfg->sidlemodes & BIT(SYSC_IDLE_SMART))
+		*idlemodes |= SIDLE_SMART;
+	if (data->cfg->sidlemodes & BIT(SYSC_IDLE_SMART_WKUP))
+		*idlemodes |= SIDLE_SMART_WKUP;
+
+	return 0;
+}
+
+/**
+ * omap_hwmod_allocate_module - allocate new module
+ * @dev: struct device
+ * @oh: module
+ * @sysc_fields: sysc register bits
+ * @rev_offs: revision register offset
+ * @sysc_offs: sysconfig register offset
+ * @syss_offs: sysstatus register offset
+ * @sysc_flags: sysc specific flags
+ * @idlemodes: sysc supported idlemodes
+ *
+ * Note that the allocations here cannot use devm as ti-sysc can rebind.
+ */
+int omap_hwmod_allocate_module(struct device *dev, struct omap_hwmod *oh,
+			       const struct ti_sysc_module_data *data,
+			       struct sysc_regbits *sysc_fields,
+			       u32 rev_offs, u32 sysc_offs, u32 syss_offs,
+			       u32 sysc_flags, u32 idlemodes)
+{
+	struct omap_hwmod_class_sysconfig *sysc;
+	struct omap_hwmod_class *class;
+	void __iomem *regs = NULL;
+	unsigned long flags;
+
+	sysc = kzalloc(sizeof(*sysc), GFP_KERNEL);
+	if (!sysc)
+		return -ENOMEM;
+
+	sysc->sysc_fields = sysc_fields;
+	sysc->rev_offs = rev_offs;
+	sysc->sysc_offs = sysc_offs;
+	sysc->syss_offs = syss_offs;
+	sysc->sysc_flags = sysc_flags;
+	sysc->idlemodes = idlemodes;
+	sysc->srst_udelay = data->cfg->srst_udelay;
+
+	if (!oh->_mpu_rt_va) {
+		regs = ioremap(data->module_pa,
+			       data->module_size);
+		if (!regs)
+			return -ENOMEM;
+	}
+
+	/*
+	 * We need new oh->class as the other devices in the same class
+	 * may not yet have ioremapped their registers.
+	 */
+	class = kmemdup(oh->class, sizeof(*oh->class), GFP_KERNEL);
+	if (!class)
+		return -ENOMEM;
+
+	class->sysc = sysc;
+
+	spin_lock_irqsave(&oh->_lock, flags);
+	if (regs)
+		oh->_mpu_rt_va = regs;
+	oh->class = class;
+	oh->_state = _HWMOD_STATE_INITIALIZED;
+	_setup(oh, NULL);
+	spin_unlock_irqrestore(&oh->_lock, flags);
+
+	return 0;
+}
+
+/**
+ * omap_hwmod_init_module - initialize new module
+ * @dev: struct device
+ * @data: module data
+ * @cookie: cookie for the caller to use for later calls
+ */
+int omap_hwmod_init_module(struct device *dev,
+			   const struct ti_sysc_module_data *data,
+			   struct ti_sysc_cookie *cookie)
+{
+	struct omap_hwmod *oh;
+	struct sysc_regbits *sysc_fields;
+	u32 rev_offs, sysc_offs, syss_offs, sysc_flags, idlemodes;
+	int error;
+
+	if (!dev || !data)
+		return -EINVAL;
+
+	oh = _lookup(data->name);
+	if (!oh)
+		return -ENODEV;
+
+	cookie->data = oh;
+
+	error = omap_hwmod_init_regbits(dev, data, &sysc_fields);
+	if (error)
+		return error;
+
+	error = omap_hwmod_init_reg_offs(dev, data, &rev_offs,
+					 &sysc_offs, &syss_offs);
+	if (error)
+		return error;
+
+	error = omap_hwmod_init_sysc_flags(dev, data, &sysc_flags);
+	if (error)
+		return error;
+
+	error = omap_hwmod_init_idlemodes(dev, data, &idlemodes);
+	if (error)
+		return error;
+
+	if (data->cfg->quirks & SYSC_QUIRK_NO_IDLE_ON_INIT)
+		oh->flags |= HWMOD_INIT_NO_IDLE;
+	if (data->cfg->quirks & SYSC_QUIRK_NO_RESET_ON_INIT)
+		oh->flags |= HWMOD_INIT_NO_RESET;
+
+	if (oh->class->sysc)
+		return 0;
+
+	return omap_hwmod_allocate_module(dev, oh, data, sysc_fields,
+					  rev_offs, sysc_offs, syss_offs,
+					  sysc_flags, idlemodes);
+}
+
 /**
  * omap_hwmod_setup_earlycon_flags - set up flags for early console
  *

commit 60c99c7749f2a86e8891b003496fa8f6e985b8b5
Merge: 7928b2cbe55b 392ea5dd0ff2
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Feb 14 08:27:41 2018 -0800

    Merge branch 'omap-for-v4.16/soc' into omap-for-v4.16/fixes

commit fe53d1443a146326b49d57fe6336b5c2a725223f
Merge: adbc128fa8b4 796543a64ebf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 1 16:35:31 2018 -0800

    Merge tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC driver updates from Arnd Bergmann:
     "A number of new drivers get added this time, along with many
      low-priority bugfixes. The most interesting changes by subsystem are:
    
      bus drivers:
       - Updates to the Broadcom bus interface driver to support newer SoC
         types
       - The TI OMAP sysc driver now supports updated DT bindings
    
      memory controllers:
       - A new driver for Tegra186 gets added
       - A new driver for the ti-emif sram, to allow relocating
         suspend/resume handlers there
    
      SoC specific:
       - A new driver for Qualcomm QMI, the interface to the modem on MSM
         SoCs
       - A new driver for power domains on the actions S700 SoC
       - A driver for the Xilinx Zynq VCU logicoreIP
    
      reset controllers:
       - A new driver for Amlogic Meson-AGX
       - various bug fixes
    
      tee subsystem:
       - A new user interface got added to enable asynchronous communication
         with the TEE supplicant.
       - A new method of using user space memory for communication with the
         TEE is added"
    
    * tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (84 commits)
      of: platform: fix OF node refcount leak
      soc: fsl: guts: Add a NULL check for devm_kasprintf()
      bus: ti-sysc: Fix smartreflex sysc mask
      psci: add CPU_IDLE dependency
      soc: xilinx: Fix Kconfig alignment
      soc: xilinx: xlnx_vcu: Use bitwise & rather than logical && on clkoutdiv
      soc: xilinx: xlnx_vcu: Depends on HAS_IOMEM for xlnx_vcu
      soc: bcm: brcmstb: Be multi-platform compatible
      soc: brcmstb: biuctrl: exit without warning on non brcmstb platforms
      Revert "soc: brcmstb: Only register SoC device on STB platforms"
      bus: omap: add MODULE_LICENSE tags
      soc: brcmstb: Only register SoC device on STB platforms
      tee: shm: Potential NULL dereference calling tee_shm_register()
      soc: xilinx: xlnx_vcu: Add Xilinx ZYNQMP VCU logicoreIP init driver
      dt-bindings: soc: xilinx: Add DT bindings to xlnx_vcu driver
      soc: xilinx: Create folder structure for soc specific drivers
      of: platform: populate /firmware/ node from of_platform_default_populate_init()
      soc: samsung: Add SPDX license identifiers
      soc: qcom: smp2p: Use common error handling code in qcom_smp2p_probe()
      tee: shm: don't put_page on null shm->pages
      ...

commit 0ca14cdea789f70c4dc7ef5844aad52cb9675aee
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Sep 14 14:50:58 2017 +0200

    ARM: omap: hwmod: fix section mismatch warnings
    
    Older compilers choose not to inline _setup_clkctrl_provider(),
    leading to a harmless warning:
    
    WARNING: vmlinux.o(.text+0x27b34): Section mismatch in reference from the function _setup_clkctrl_provider() to the function .init.text:memblock_virt_alloc_try_nid()
    The function _setup_clkctrl_provider() references
    the function __init memblock_virt_alloc_try_nid().
    This is often because _setup_clkctrl_provider lacks a __init
    annotation or the annotation of memblock_virt_alloc_try_nid is wrong.
    
    This annotates it as __init as well, which lets the linker
    see that it is actually correct.
    
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 5eff27e4f24b..1cfe9aff4ac7 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -715,7 +715,7 @@ static const struct of_device_id ti_clkctrl_match_table[] __initconst = {
 	{ }
 };
 
-static int _setup_clkctrl_provider(struct device_node *np)
+static int __init _setup_clkctrl_provider(struct device_node *np)
 {
 	const __be32 *addrp;
 	struct clkctrl_provider *provider;
@@ -743,7 +743,7 @@ static int _setup_clkctrl_provider(struct device_node *np)
 	return 0;
 }
 
-static int _init_clkctrl_providers(void)
+static int __init _init_clkctrl_providers(void)
 {
 	struct device_node *np;
 	int ret = 0;

commit 392ea5dd0ff265f7557405fcbdf35acd34cf4ab8
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Dec 22 11:26:03 2017 +0200

    ARM: OMAP2+: hwmod_core: enable optional clocks before main clock
    
    The optional clocks must be enabled before the main clock after the
    transition to clkctrl controlled clocks is done. Otherwise the module
    we attempt to enable might be stuck in transition.
    
    Reported-by: Keerthy <j-keerthy@ti.com>
    Tested-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 5eff27e4f24b..b1d446c57556 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -975,6 +975,9 @@ static int _enable_clocks(struct omap_hwmod *oh)
 
 	pr_debug("omap_hwmod: %s: enabling clocks\n", oh->name);
 
+	if (oh->flags & HWMOD_OPT_CLKS_NEEDED)
+		_enable_optional_clocks(oh);
+
 	if (oh->_clk)
 		clk_enable(oh->_clk);
 
@@ -983,9 +986,6 @@ static int _enable_clocks(struct omap_hwmod *oh)
 			clk_enable(os->_clk);
 	}
 
-	if (oh->flags & HWMOD_OPT_CLKS_NEEDED)
-		_enable_optional_clocks(oh);
-
 	/* The opt clocks are controlled by the device driver. */
 
 	return 0;

commit 49a0a3d805df3b7b4f8a04db6dbf55aa36fd762c
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Dec 15 09:41:05 2017 -0800

    bus: ti-sysc: Make omap_hwmod_sysc_fields into sysc_regbits platform data
    
    We want to be able to configure hwmod sysc data from ti-sysc driver using
    platform data callbacks. So let's make struct omap_hwmod_sysc_fields into
    struct sysc_data and have it available for both ti-sysc driver and hwmod
    code.
    
    Note that we can make it use s8 instead of u8 as the hwmod code uses the
    feature flags to check for this field. However, for ti-sysc we can use
    -ENODEV to indicate a feature is not supported in the hardware and can
    simplify the code that way.
    
    And let's add also emufree_shift as the dts files will be describing the
    hardware for the SYSCONFIG register capbilities mask.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 104256a5f0f7..fbc738c844b3 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -143,6 +143,8 @@
 #include <linux/of_address.h>
 #include <linux/bootmem.h>
 
+#include <linux/platform_data/ti-sysc.h>
+
 #include <asm/system_misc.h>
 
 #include "clock.h"

commit 2b96be3df5a494e0e90176a54655cf7ad1313b4c
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Aug 9 11:57:12 2017 +0300

    ARM: OMAP2+: hwmod: calculate physical register address on am33xx
    
    Add support for the address translation logic for am33xx. Needed for
    mapping hwmods towards their corresponding clkctrl providers and clocks.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 4b256c83c17b..5eff27e4f24b 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3519,6 +3519,7 @@ void __init omap_hwmod_init(void)
 		soc_ops.is_hardreset_asserted = _omap4_is_hardreset_asserted;
 		soc_ops.init_clkdm = _init_clkdm;
 		soc_ops.disable_direct_prcm = _omap4_disable_direct_prcm;
+		soc_ops.xlate_clkctrl = _omap4_xlate_clkctrl;
 	} else {
 		WARN(1, "omap_hwmod: unknown SoC type\n");
 	}

commit 6e83ecaa453d0e574723cc94f46eae74e3820a41
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Aug 4 17:41:50 2017 +0300

    ARM: OMAP2+: hwmod: fix clkctrl address translation logic
    
    There are cases where clkctrl clock offsets do not match the corresponding
    clockdomain, and this case the existing mapping functionality will fail.
    Fix this by adding the whole address range for a clkctrl provider and
    matching the actual clkctrl registers against these ranges.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 104256a5f0f7..4b256c83c17b 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -185,15 +185,15 @@
 /**
  * struct clkctrl_provider - clkctrl provider mapping data
  * @addr: base address for the provider
- * @offset: base offset for the provider
- * @clkdm: base clockdomain for provider
+ * @size: size of the provider address space
+ * @offset: offset of the provider from PRCM instance base
  * @node: device node associated with the provider
  * @link: list link
  */
 struct clkctrl_provider {
 	u32			addr;
+	u32			size;
 	u16			offset;
-	struct clockdomain	*clkdm;
 	struct device_node	*node;
 	struct list_head	link;
 };
@@ -223,8 +223,7 @@ struct omap_hwmod_soc_ops {
 	void (*update_context_lost)(struct omap_hwmod *oh);
 	int (*get_context_lost)(struct omap_hwmod *oh);
 	int (*disable_direct_prcm)(struct omap_hwmod *oh);
-	u32 (*xlate_clkctrl)(struct omap_hwmod *oh,
-			     struct clkctrl_provider *provider);
+	u32 (*xlate_clkctrl)(struct omap_hwmod *oh);
 };
 
 /* soc_ops: adapts the omap_hwmod code to the currently-booted SoC */
@@ -716,45 +715,28 @@ static const struct of_device_id ti_clkctrl_match_table[] __initconst = {
 	{ }
 };
 
-static int _match_clkdm(struct clockdomain *clkdm, void *user)
-{
-	struct clkctrl_provider *provider = user;
-
-	if (clkdm_xlate_address(clkdm) == provider->addr) {
-		pr_debug("%s: Matched clkdm %s for addr %x (%s)\n", __func__,
-			 clkdm->name, provider->addr,
-			 provider->node->parent->name);
-		provider->clkdm = clkdm;
-
-		return -1;
-	}
-
-	return 0;
-}
-
 static int _setup_clkctrl_provider(struct device_node *np)
 {
 	const __be32 *addrp;
 	struct clkctrl_provider *provider;
+	u64 size;
 
 	provider = memblock_virt_alloc(sizeof(*provider), 0);
 	if (!provider)
 		return -ENOMEM;
 
-	addrp = of_get_address(np, 0, NULL, NULL);
+	addrp = of_get_address(np, 0, &size, NULL);
 	provider->addr = (u32)of_translate_address(np, addrp);
-	provider->offset = provider->addr & 0xff;
+	addrp = of_get_address(np->parent, 0, NULL, NULL);
+	provider->offset = provider->addr -
+			   (u32)of_translate_address(np->parent, addrp);
 	provider->addr &= ~0xff;
+	provider->size = size | 0xff;
 	provider->node = np;
 
-	clkdm_for_each(_match_clkdm, provider);
-
-	if (!provider->clkdm) {
-		pr_err("%s: nothing matched for node %s (%x)\n",
-		       __func__, np->parent->name, provider->addr);
-		memblock_free_early(__pa(provider), sizeof(*provider));
-		return -EINVAL;
-	}
+	pr_debug("%s: %s: %x...%x [+%x]\n", __func__, np->parent->name,
+		 provider->addr, provider->addr + provider->size,
+		 provider->offset);
 
 	list_add(&provider->link, &clkctrl_providers);
 
@@ -775,32 +757,48 @@ static int _init_clkctrl_providers(void)
 	return ret;
 }
 
-static u32 _omap4_xlate_clkctrl(struct omap_hwmod *oh,
-				struct clkctrl_provider *provider)
+static u32 _omap4_xlate_clkctrl(struct omap_hwmod *oh)
 {
-	return oh->prcm.omap4.clkctrl_offs -
-	       provider->offset - provider->clkdm->clkdm_offs;
+	if (!oh->prcm.omap4.modulemode)
+		return 0;
+
+	return omap_cm_xlate_clkctrl(oh->clkdm->prcm_partition,
+				     oh->clkdm->cm_inst,
+				     oh->prcm.omap4.clkctrl_offs);
 }
 
 static struct clk *_lookup_clkctrl_clk(struct omap_hwmod *oh)
 {
 	struct clkctrl_provider *provider;
 	struct clk *clk;
+	u32 addr;
 
 	if (!soc_ops.xlate_clkctrl)
 		return NULL;
 
+	addr = soc_ops.xlate_clkctrl(oh);
+	if (!addr)
+		return NULL;
+
+	pr_debug("%s: %s: addr=%x\n", __func__, oh->name, addr);
+
 	list_for_each_entry(provider, &clkctrl_providers, link) {
-		if (provider->clkdm == oh->clkdm) {
+		if (provider->addr <= addr &&
+		    provider->addr + provider->size >= addr) {
 			struct of_phandle_args clkspec;
 
 			clkspec.np = provider->node;
 			clkspec.args_count = 2;
-			clkspec.args[0] = soc_ops.xlate_clkctrl(oh, provider);
+			clkspec.args[0] = addr - provider->addr -
+					  provider->offset;
 			clkspec.args[1] = 0;
 
 			clk = of_clk_get_from_provider(&clkspec);
 
+			pr_debug("%s: %s got %p (offset=%x, provider=%s)\n",
+				 __func__, oh->name, clk, clkspec.args[0],
+				 provider->node->parent->name);
+
 			return clk;
 		}
 	}

commit 9cffb1a0504ddc7b291cf882002ee4a794eb3fec
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 10 14:27:33 2017 -0700

    ARM: OMAP2+: Drop legacy struct omap_hwmod_addr_space
    
    With all of mach-omap2 booting now in device tree only mode,
    we can get the module IO range from device tree and just drop
    the legacy hwmod struct omap_hwmod_addr_space.
    
    Cc: Lokesh Vutla <lokeshvutla@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 29b6c85f6ce8..104256a5f0f7 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1101,82 +1101,6 @@ static int _omap4_wait_target_disable(struct omap_hwmod *oh)
 					oh->prcm.omap4.clkctrl_offs, 0);
 }
 
-/**
- * _count_ocp_if_addr_spaces - count the number of address space entries for @oh
- * @oh: struct omap_hwmod *oh
- *
- * Count and return the number of address space ranges associated with
- * the hwmod @oh.  Used to allocate struct resource data.  Returns 0
- * if @oh is NULL.
- */
-static int _count_ocp_if_addr_spaces(struct omap_hwmod_ocp_if *os)
-{
-	struct omap_hwmod_addr_space *mem;
-	int i = 0;
-
-	if (!os || !os->addr)
-		return 0;
-
-	do {
-		mem = &os->addr[i++];
-	} while (mem->pa_start != mem->pa_end);
-
-	return i-1;
-}
-
-/**
- * _get_addr_space_by_name - fetch address space start & end by name
- * @oh: struct omap_hwmod * to operate on
- * @name: pointer to the name of the address space to fetch (optional)
- * @pa_start: pointer to a u32 to store the starting address to
- * @pa_end: pointer to a u32 to store the ending address to
- *
- * Retrieve address space start and end addresses for the IP block
- * pointed to by @oh.  The data will be filled into the addresses
- * pointed to by @pa_start and @pa_end.  When @name is non-null, the
- * address space data associated with the named entry will be
- * returned.  If @name is null, the first matching entry will be
- * returned.  Data order is not meaningful in hwmod data, so callers
- * are strongly encouraged to use a non-null @name whenever possible
- * to avoid unpredictable effects if hwmod data is later added that
- * causes data ordering to change.  Returns 0 upon success or a
- * negative error code upon error.
- */
-static int _get_addr_space_by_name(struct omap_hwmod *oh, const char *name,
-				   u32 *pa_start, u32 *pa_end)
-{
-	int j;
-	struct omap_hwmod_ocp_if *os;
-	bool found = false;
-
-	list_for_each_entry(os, &oh->slave_ports, node) {
-
-		if (!os->addr)
-			return -ENOENT;
-
-		j = 0;
-		while (os->addr[j].pa_start != os->addr[j].pa_end) {
-			if (name == os->addr[j].name ||
-			    !strcmp(name, os->addr[j].name)) {
-				found = true;
-				break;
-			}
-			j++;
-		}
-
-		if (found)
-			break;
-	}
-
-	if (!found)
-		return -ENOENT;
-
-	*pa_start = os->addr[j].pa_start;
-	*pa_end = os->addr[j].pa_end;
-
-	return 0;
-}
-
 /**
  * _save_mpu_port_index - find and save the index to @oh's MPU port
  * @oh: struct omap_hwmod *
@@ -1227,32 +1151,6 @@ static struct omap_hwmod_ocp_if *_find_mpu_rt_port(struct omap_hwmod *oh)
 	return oh->_mpu_port;
 };
 
-/**
- * _find_mpu_rt_addr_space - return MPU register target address space for @oh
- * @oh: struct omap_hwmod *
- *
- * Returns a pointer to the struct omap_hwmod_addr_space record representing
- * the register target MPU address space; or returns NULL upon error.
- */
-static struct omap_hwmod_addr_space * __init _find_mpu_rt_addr_space(struct omap_hwmod *oh)
-{
-	struct omap_hwmod_ocp_if *os;
-	struct omap_hwmod_addr_space *mem;
-	int found = 0, i = 0;
-
-	os = _find_mpu_rt_port(oh);
-	if (!os || !os->addr)
-		return NULL;
-
-	do {
-		mem = &os->addr[i++];
-		if (mem->flags & ADDR_TYPE_RT)
-			found = 1;
-	} while (!found && mem->pa_start != mem->pa_end);
-
-	return (found) ? mem : NULL;
-}
-
 /**
  * _enable_sysc - try to bring a module out of idle via OCP_SYSCONFIG
  * @oh: struct omap_hwmod *
@@ -2349,7 +2247,6 @@ int omap_hwmod_parse_module_range(struct omap_hwmod *oh,
 static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data,
 				    int index, struct device_node *np)
 {
-	struct omap_hwmod_addr_space *mem;
 	void __iomem *va_start = NULL;
 	struct resource res;
 	int error;
@@ -2367,35 +2264,22 @@ static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data,
 	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
 		return -ENXIO;
 
-	mem = _find_mpu_rt_addr_space(oh);
-	if (!mem) {
-		pr_debug("omap_hwmod: %s: no MPU register target found\n",
-			 oh->name);
-
-		/* Extract the IO space from device tree blob */
-		if (!np) {
-			pr_err("omap_hwmod: %s: no dt node\n", oh->name);
-			return -ENXIO;
-		}
-
-		/* Do we have a dts range for the interconnect target module? */
-		error = omap_hwmod_parse_module_range(oh, np, &res);
-		if (!error)
-			va_start = ioremap(res.start, resource_size(&res));
-
-		/* No ranges, rely on device reg entry */
-		if (!va_start)
-			va_start = of_iomap(np, index + oh->mpu_rt_idx);
-	} else {
-		va_start = ioremap(mem->pa_start, mem->pa_end - mem->pa_start);
+	if (!np) {
+		pr_err("omap_hwmod: %s: no dt node\n", oh->name);
+		return -ENXIO;
 	}
 
+	/* Do we have a dts range for the interconnect target module? */
+	error = omap_hwmod_parse_module_range(oh, np, &res);
+	if (!error)
+		va_start = ioremap(res.start, resource_size(&res));
+
+	/* No ranges, rely on device reg entry */
+	if (!va_start)
+		va_start = of_iomap(np, index + oh->mpu_rt_idx);
 	if (!va_start) {
-		if (mem)
-			pr_err("omap_hwmod: %s: Could not ioremap\n", oh->name);
-		else
-			pr_err("omap_hwmod: %s: Missing dt reg%i for %pOF\n",
-			       oh->name, index, np);
+		pr_err("omap_hwmod: %s: Missing dt reg%i for %pOF\n",
+		       oh->name, index, np);
 		return -ENXIO;
 	}
 
@@ -3299,117 +3183,6 @@ int omap_hwmod_shutdown(struct omap_hwmod *oh)
  * IP block data retrieval functions
  */
 
-/**
- * omap_hwmod_count_resources - count number of struct resources needed by hwmod
- * @oh: struct omap_hwmod *
- * @flags: Type of resources to include when counting (IRQ/DMA/MEM)
- *
- * Count the number of struct resource array elements necessary to
- * contain omap_hwmod @oh resources.  Intended to be called by code
- * that registers omap_devices.  Intended to be used to determine the
- * size of a dynamically-allocated struct resource array, before
- * calling omap_hwmod_fill_resources().  Returns the number of struct
- * resource array elements needed.
- *
- * XXX This code is not optimized.  It could attempt to merge adjacent
- * resource IDs.
- *
- */
-int omap_hwmod_count_resources(struct omap_hwmod *oh, unsigned long flags)
-{
-	int ret = 0;
-
-	if (flags & IORESOURCE_MEM) {
-		struct omap_hwmod_ocp_if *os;
-
-		list_for_each_entry(os, &oh->slave_ports, node)
-			ret += _count_ocp_if_addr_spaces(os);
-	}
-
-	return ret;
-}
-
-/**
- * omap_hwmod_fill_resources - fill struct resource array with hwmod data
- * @oh: struct omap_hwmod *
- * @res: pointer to the first element of an array of struct resource to fill
- *
- * Fill the struct resource array @res with resource data from the
- * omap_hwmod @oh.  Intended to be called by code that registers
- * omap_devices.  See also omap_hwmod_count_resources().  Returns the
- * number of array elements filled.
- */
-int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
-{
-	struct omap_hwmod_ocp_if *os;
-	int j, addr_cnt;
-	int r = 0;
-
-	/* For each memory area, fill in array.*/
-
-	list_for_each_entry(os, &oh->slave_ports, node) {
-		addr_cnt = _count_ocp_if_addr_spaces(os);
-
-		for (j = 0; j < addr_cnt; j++) {
-			(res + r)->name = (os->addr + j)->name;
-			(res + r)->start = (os->addr + j)->pa_start;
-			(res + r)->end = (os->addr + j)->pa_end;
-			(res + r)->flags = IORESOURCE_MEM;
-			r++;
-		}
-	}
-
-	return r;
-}
-
-/**
- * omap_hwmod_get_resource_byname - fetch IP block integration data by name
- * @oh: struct omap_hwmod * to operate on
- * @type: one of the IORESOURCE_* constants from include/linux/ioport.h
- * @name: pointer to the name of the data to fetch (optional)
- * @rsrc: pointer to a struct resource, allocated by the caller
- *
- * Retrieve MPU IRQ, SDMA request line, or address space start/end
- * data for the IP block pointed to by @oh.  The data will be filled
- * into a struct resource record pointed to by @rsrc.  The struct
- * resource must be allocated by the caller.  When @name is non-null,
- * the data associated with the matching entry in the IRQ/SDMA/address
- * space hwmod data arrays will be returned.  If @name is null, the
- * first array entry will be returned.  Data order is not meaningful
- * in hwmod data, so callers are strongly encouraged to use a non-null
- * @name whenever possible to avoid unpredictable effects if hwmod
- * data is later added that causes data ordering to change.  This
- * function is only intended for use by OMAP core code.  Device
- * drivers should not call this function - the appropriate bus-related
- * data accessor functions should be used instead.  Returns 0 upon
- * success or a negative error code upon error.
- */
-int omap_hwmod_get_resource_byname(struct omap_hwmod *oh, unsigned int type,
-				   const char *name, struct resource *rsrc)
-{
-	int r;
-	u32 pa_start, pa_end;
-
-	if (!oh || !rsrc)
-		return -EINVAL;
-
-	if (type == IORESOURCE_MEM) {
-		r = _get_addr_space_by_name(oh, name, &pa_start, &pa_end);
-		if (r)
-			return r;
-
-		rsrc->start = pa_start;
-		rsrc->end = pa_end;
-	} else {
-		return -EINVAL;
-	}
-
-	rsrc->flags = type;
-	rsrc->name = name;
-
-	return 0;
-}
-
 /**
  * omap_hwmod_get_pwrdm - return pointer to this module's main powerdomain
  * @oh: struct omap_hwmod *

commit c2b84a9bb3414cabaa039b8860a694464a0bad06
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 10 14:27:26 2017 -0700

    ARM: OMAP2+: Drop omap_hwmod_dma_info
    
    We have all of mach-omap2 booting in device tree only
    mode now, and this data is populated from device tree.
    
    Note that once we have removed support for the omap legacy
    DMA, we can also drop struct omap_dma_dev_attr.
    
    Cc: Lokesh Vutla <lokeshvutla@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 5a0fbdec339a..29b6c85f6ce8 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1101,29 +1101,6 @@ static int _omap4_wait_target_disable(struct omap_hwmod *oh)
 					oh->prcm.omap4.clkctrl_offs, 0);
 }
 
-/**
- * _count_sdma_reqs - count the number of SDMA request lines associated with @oh
- * @oh: struct omap_hwmod *oh
- *
- * Count and return the number of SDMA request lines associated with
- * the hwmod @oh.  Used to allocate struct resource data.  Returns 0
- * if @oh is NULL.
- */
-static int _count_sdma_reqs(struct omap_hwmod *oh)
-{
-	struct omap_hwmod_dma_info *ohdi;
-	int i = 0;
-
-	if (!oh || !oh->sdma_reqs)
-		return 0;
-
-	do {
-		ohdi = &oh->sdma_reqs[i++];
-	} while (ohdi->dma_req != -1);
-
-	return i-1;
-}
-
 /**
  * _count_ocp_if_addr_spaces - count the number of address space entries for @oh
  * @oh: struct omap_hwmod *oh
@@ -1147,49 +1124,6 @@ static int _count_ocp_if_addr_spaces(struct omap_hwmod_ocp_if *os)
 	return i-1;
 }
 
-/**
- * _get_sdma_req_by_name - fetch SDMA request line ID by name
- * @oh: struct omap_hwmod * to operate on
- * @name: pointer to the name of the SDMA request line to fetch (optional)
- * @dma: pointer to an unsigned int to store the request line ID to
- *
- * Retrieve an SDMA request line ID named by @name on the IP block
- * pointed to by @oh.  The ID will be filled into the address pointed
- * to by @dma.  When @name is non-null, the request line ID associated
- * with the named entry will be returned.  If @name is null, the first
- * matching entry will be returned.  Data order is not meaningful in
- * hwmod data, so callers are strongly encouraged to use a non-null
- * @name whenever possible to avoid unpredictable effects if hwmod
- * data is later added that causes data ordering to change.  Returns 0
- * upon success or a negative error code upon error.
- */
-static int _get_sdma_req_by_name(struct omap_hwmod *oh, const char *name,
-				 unsigned int *dma)
-{
-	int i;
-	bool found = false;
-
-	if (!oh->sdma_reqs)
-		return -ENOENT;
-
-	i = 0;
-	while (oh->sdma_reqs[i].dma_req != -1) {
-		if (name == oh->sdma_reqs[i].name ||
-		    !strcmp(name, oh->sdma_reqs[i].name)) {
-			found = true;
-			break;
-		}
-		i++;
-	}
-
-	if (!found)
-		return -ENOENT;
-
-	*dma = oh->sdma_reqs[i].dma_req;
-
-	return 0;
-}
-
 /**
  * _get_addr_space_by_name - fetch address space start & end by name
  * @oh: struct omap_hwmod * to operate on
@@ -3385,9 +3319,6 @@ int omap_hwmod_count_resources(struct omap_hwmod *oh, unsigned long flags)
 {
 	int ret = 0;
 
-	if (flags & IORESOURCE_DMA)
-		ret += _count_sdma_reqs(oh);
-
 	if (flags & IORESOURCE_MEM) {
 		struct omap_hwmod_ocp_if *os;
 
@@ -3411,19 +3342,10 @@ int omap_hwmod_count_resources(struct omap_hwmod *oh, unsigned long flags)
 int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 {
 	struct omap_hwmod_ocp_if *os;
-	int i, j, sdma_reqs_cnt, addr_cnt;
+	int j, addr_cnt;
 	int r = 0;
 
-	/* For each DMA, memory area, fill in array.*/
-
-	sdma_reqs_cnt = _count_sdma_reqs(oh);
-	for (i = 0; i < sdma_reqs_cnt; i++) {
-		(res + r)->name = (oh->sdma_reqs + i)->name;
-		(res + r)->start = (oh->sdma_reqs + i)->dma_req;
-		(res + r)->end = (oh->sdma_reqs + i)->dma_req;
-		(res + r)->flags = IORESOURCE_DMA;
-		r++;
-	}
+	/* For each memory area, fill in array.*/
 
 	list_for_each_entry(os, &oh->slave_ports, node) {
 		addr_cnt = _count_ocp_if_addr_spaces(os);
@@ -3440,33 +3362,6 @@ int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 	return r;
 }
 
-/**
- * omap_hwmod_fill_dma_resources - fill struct resource array with dma data
- * @oh: struct omap_hwmod *
- * @res: pointer to the array of struct resource to fill
- *
- * Fill the struct resource array @res with dma resource data from the
- * omap_hwmod @oh.  Intended to be called by code that registers
- * omap_devices.  See also omap_hwmod_count_resources().  Returns the
- * number of array elements filled.
- */
-int omap_hwmod_fill_dma_resources(struct omap_hwmod *oh, struct resource *res)
-{
-	int i, sdma_reqs_cnt;
-	int r = 0;
-
-	sdma_reqs_cnt = _count_sdma_reqs(oh);
-	for (i = 0; i < sdma_reqs_cnt; i++) {
-		(res + r)->name = (oh->sdma_reqs + i)->name;
-		(res + r)->start = (oh->sdma_reqs + i)->dma_req;
-		(res + r)->end = (oh->sdma_reqs + i)->dma_req;
-		(res + r)->flags = IORESOURCE_DMA;
-		r++;
-	}
-
-	return r;
-}
-
 /**
  * omap_hwmod_get_resource_byname - fetch IP block integration data by name
  * @oh: struct omap_hwmod * to operate on
@@ -3493,20 +3388,12 @@ int omap_hwmod_get_resource_byname(struct omap_hwmod *oh, unsigned int type,
 				   const char *name, struct resource *rsrc)
 {
 	int r;
-	unsigned int dma;
 	u32 pa_start, pa_end;
 
 	if (!oh || !rsrc)
 		return -EINVAL;
 
-	if (type == IORESOURCE_DMA) {
-		r = _get_sdma_req_by_name(oh, name, &dma);
-		if (r)
-			return r;
-
-		rsrc->start = dma;
-		rsrc->end = dma;
-	} else if (type == IORESOURCE_MEM) {
+	if (type == IORESOURCE_MEM) {
 		r = _get_addr_space_by_name(oh, name, &pa_start, &pa_end);
 		if (r)
 			return r;

commit fe97874a41bf911350bae6bda7fc044d12c76a4a
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 10 14:27:19 2017 -0700

    ARM: OMAP2+: Drop omap_hwmod_irq_info
    
    With the previous patches removing the need for legacy IRQs
    now that all of mach-omap2 is booting in device tree only mode,
    we can drop struct omap_hwmod_irq_info.
    
    Note that we can now also finally drop omap4_xlate_irq.
    
    Cc: Lokesh Vutla <lokeshvutla@ti.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index de69fb37098c..5a0fbdec339a 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1101,29 +1101,6 @@ static int _omap4_wait_target_disable(struct omap_hwmod *oh)
 					oh->prcm.omap4.clkctrl_offs, 0);
 }
 
-/**
- * _count_mpu_irqs - count the number of MPU IRQ lines associated with @oh
- * @oh: struct omap_hwmod *oh
- *
- * Count and return the number of MPU IRQs associated with the hwmod
- * @oh.  Used to allocate struct resource data.  Returns 0 if @oh is
- * NULL.
- */
-static int _count_mpu_irqs(struct omap_hwmod *oh)
-{
-	struct omap_hwmod_irq_info *ohii;
-	int i = 0;
-
-	if (!oh || !oh->mpu_irqs)
-		return 0;
-
-	do {
-		ohii = &oh->mpu_irqs[i++];
-	} while (ohii->irq != -1);
-
-	return i-1;
-}
-
 /**
  * _count_sdma_reqs - count the number of SDMA request lines associated with @oh
  * @oh: struct omap_hwmod *oh
@@ -1170,50 +1147,6 @@ static int _count_ocp_if_addr_spaces(struct omap_hwmod_ocp_if *os)
 	return i-1;
 }
 
-/**
- * _get_mpu_irq_by_name - fetch MPU interrupt line number by name
- * @oh: struct omap_hwmod * to operate on
- * @name: pointer to the name of the MPU interrupt number to fetch (optional)
- * @irq: pointer to an unsigned int to store the MPU IRQ number to
- *
- * Retrieve a MPU hardware IRQ line number named by @name associated
- * with the IP block pointed to by @oh.  The IRQ number will be filled
- * into the address pointed to by @dma.  When @name is non-null, the
- * IRQ line number associated with the named entry will be returned.
- * If @name is null, the first matching entry will be returned.  Data
- * order is not meaningful in hwmod data, so callers are strongly
- * encouraged to use a non-null @name whenever possible to avoid
- * unpredictable effects if hwmod data is later added that causes data
- * ordering to change.  Returns 0 upon success or a negative error
- * code upon error.
- */
-static int _get_mpu_irq_by_name(struct omap_hwmod *oh, const char *name,
-				unsigned int *irq)
-{
-	int i;
-	bool found = false;
-
-	if (!oh->mpu_irqs)
-		return -ENOENT;
-
-	i = 0;
-	while (oh->mpu_irqs[i].irq != -1) {
-		if (name == oh->mpu_irqs[i].name ||
-		    !strcmp(name, oh->mpu_irqs[i].name)) {
-			found = true;
-			break;
-		}
-		i++;
-	}
-
-	if (!found)
-		return -ENOENT;
-
-	*irq = oh->mpu_irqs[i].irq;
-
-	return 0;
-}
-
 /**
  * _get_sdma_req_by_name - fetch SDMA request line ID by name
  * @oh: struct omap_hwmod * to operate on
@@ -3452,9 +3385,6 @@ int omap_hwmod_count_resources(struct omap_hwmod *oh, unsigned long flags)
 {
 	int ret = 0;
 
-	if (flags & IORESOURCE_IRQ)
-		ret += _count_mpu_irqs(oh);
-
 	if (flags & IORESOURCE_DMA)
 		ret += _count_sdma_reqs(oh);
 
@@ -3481,25 +3411,10 @@ int omap_hwmod_count_resources(struct omap_hwmod *oh, unsigned long flags)
 int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 {
 	struct omap_hwmod_ocp_if *os;
-	int i, j, mpu_irqs_cnt, sdma_reqs_cnt, addr_cnt;
+	int i, j, sdma_reqs_cnt, addr_cnt;
 	int r = 0;
 
-	/* For each IRQ, DMA, memory area, fill in array.*/
-
-	mpu_irqs_cnt = _count_mpu_irqs(oh);
-	for (i = 0; i < mpu_irqs_cnt; i++) {
-		unsigned int irq;
-
-		if (oh->xlate_irq)
-			irq = oh->xlate_irq((oh->mpu_irqs + i)->irq);
-		else
-			irq = (oh->mpu_irqs + i)->irq;
-		(res + r)->name = (oh->mpu_irqs + i)->name;
-		(res + r)->start = irq;
-		(res + r)->end = irq;
-		(res + r)->flags = IORESOURCE_IRQ;
-		r++;
-	}
+	/* For each DMA, memory area, fill in array.*/
 
 	sdma_reqs_cnt = _count_sdma_reqs(oh);
 	for (i = 0; i < sdma_reqs_cnt; i++) {
@@ -3578,20 +3493,13 @@ int omap_hwmod_get_resource_byname(struct omap_hwmod *oh, unsigned int type,
 				   const char *name, struct resource *rsrc)
 {
 	int r;
-	unsigned int irq, dma;
+	unsigned int dma;
 	u32 pa_start, pa_end;
 
 	if (!oh || !rsrc)
 		return -EINVAL;
 
-	if (type == IORESOURCE_IRQ) {
-		r = _get_mpu_irq_by_name(oh, name, &irq);
-		if (r)
-			return r;
-
-		rsrc->start = irq;
-		rsrc->end = irq;
-	} else if (type == IORESOURCE_DMA) {
+	if (type == IORESOURCE_DMA) {
 		r = _get_sdma_req_by_name(oh, name, &dma);
 		if (r)
 			return r;

commit 6c72b35506728b2669835cfa8c245ac3f1c15659
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 10 14:23:27 2017 -0700

    ARM: OMAP2+: Parse module IO range from dts for legacy "ti,hwmods" support
    
    When removing legacy platform data for IO ranges for the hwmod
    interconnect code, we still need to support the "ti,hwmods"
    property.
    
    And as we're going to use a generic sysc device driver to handle the
    interconnect target instances, we can parse the information needed
    for legacy "ti,hwmods" IO range from the dts. It's always the first
    range the interconnect target module provides.
    
    Note that we want to parse the range instead of the first child
    device IO regs as the child device may not always be defined.
    
    The child IP device node may not exist in cases where there is no
    driver binding for the device, or when the child IP block may not
    even be functional for some SoC revisions. But the IO range of the
    interconnect target module is always known.
    
    Cc: "Benot Cousson" <bcousson@baylibre.com>
    Cc: Lokesh Vutla <lokeshvutla@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index d50101d44795..de69fb37098c 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2393,6 +2393,75 @@ static int of_dev_hwmod_lookup(struct device_node *np,
 	return -ENODEV;
 }
 
+/**
+ * omap_hwmod_parse_module_range - map module IO range from device tree
+ * @oh: struct omap_hwmod *
+ * @np: struct device_node *
+ *
+ * Parse the device tree range an interconnect target module provides
+ * for it's child device IP blocks. This way we can support the old
+ * "ti,hwmods" property with just dts data without a need for platform
+ * data for IO resources. And we don't need all the child IP device
+ * nodes available in the dts.
+ */
+int omap_hwmod_parse_module_range(struct omap_hwmod *oh,
+				  struct device_node *np,
+				  struct resource *res)
+{
+	struct property *prop;
+	const __be32 *ranges;
+	const char *name;
+	u32 nr_addr, nr_size;
+	u64 base, size;
+	int len, error;
+
+	if (!res)
+		return -EINVAL;
+
+	ranges = of_get_property(np, "ranges", &len);
+	if (!ranges)
+		return -ENOENT;
+
+	len /= sizeof(*ranges);
+
+	if (len < 3)
+		return -EINVAL;
+
+	of_property_for_each_string(np, "compatible", prop, name)
+		if (!strncmp("ti,sysc-", name, 8))
+			break;
+
+	if (!name)
+		return -ENOENT;
+
+	error = of_property_read_u32(np, "#address-cells", &nr_addr);
+	if (error)
+		return -ENOENT;
+
+	error = of_property_read_u32(np, "#size-cells", &nr_size);
+	if (error)
+		return -ENOENT;
+
+	if (nr_addr != 1 || nr_size != 1) {
+		pr_err("%s: invalid range for %s->%s\n", __func__,
+		       oh->name, np->name);
+		return -EINVAL;
+	}
+
+	ranges++;
+	base = of_translate_address(np, ranges++);
+	size = be32_to_cpup(ranges);
+
+	pr_debug("omap_hwmod: %s %s at 0x%llx size 0x%llx\n",
+		 oh->name, np->name, base, size);
+
+	res->start = base;
+	res->end = base + size - 1;
+	res->flags = IORESOURCE_MEM;
+
+	return 0;
+}
+
 /**
  * _init_mpu_rt_base - populate the virtual address for a hwmod
  * @oh: struct omap_hwmod * to locate the virtual address
@@ -2415,6 +2484,8 @@ static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data,
 {
 	struct omap_hwmod_addr_space *mem;
 	void __iomem *va_start = NULL;
+	struct resource res;
+	int error;
 
 	if (!oh)
 		return -EINVAL;
@@ -2440,7 +2511,14 @@ static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data,
 			return -ENXIO;
 		}
 
-		va_start = of_iomap(np, index + oh->mpu_rt_idx);
+		/* Do we have a dts range for the interconnect target module? */
+		error = omap_hwmod_parse_module_range(oh, np, &res);
+		if (!error)
+			va_start = ioremap(res.start, resource_size(&res));
+
+		/* No ranges, rely on device reg entry */
+		if (!va_start)
+			va_start = of_iomap(np, index + oh->mpu_rt_idx);
 	} else {
 		va_start = ioremap(mem->pa_start, mem->pa_end - mem->pa_start);
 	}

commit 8823ddf25d34e32c8691b9244e9b8aa120f1cff6
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Aug 29 10:03:33 2017 -0700

    ARM: OMAP2+: Fix overwriting of clkctrl and modulemode values
    
    We are currently overwiting the hwmod clkctrl registers if we
    configure a clock ctrl clock from device tree.
    
    While this does not expose any bugs except for kernel coders
    when debugging things, it should be fixed for correctness.
    It is now impossible to use the hwmod data for checking the
    clkctrl register values after booting for debugging or
    generating dts data from hwmod data.
    
    Let's fix the issue by adding a helper to detect if clkctrl
    clock is configured.
    
    Cc: Lokesh Vutla <lokeshvutla@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 2dbd63239c54..d50101d44795 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -993,6 +993,34 @@ static int _enable_clocks(struct omap_hwmod *oh)
 	return 0;
 }
 
+/**
+ * _omap4_clkctrl_managed_by_clkfwk - true if clkctrl managed by clock framework
+ * @oh: struct omap_hwmod *
+ */
+static bool _omap4_clkctrl_managed_by_clkfwk(struct omap_hwmod *oh)
+{
+	if (oh->prcm.omap4.flags & HWMOD_OMAP4_CLKFWK_CLKCTR_CLOCK)
+		return true;
+
+	return false;
+}
+
+/**
+ * _omap4_has_clkctrl_clock - returns true if a module has clkctrl clock
+ * @oh: struct omap_hwmod *
+ */
+static bool _omap4_has_clkctrl_clock(struct omap_hwmod *oh)
+{
+	if (oh->prcm.omap4.clkctrl_offs)
+		return true;
+
+	if (!oh->prcm.omap4.clkctrl_offs &&
+	    oh->prcm.omap4.flags & HWMOD_OMAP4_ZERO_CLKCTRL_OFFSET)
+		return true;
+
+	return false;
+}
+
 /**
  * _disable_clocks - disable hwmod main clock and interface clocks
  * @oh: struct omap_hwmod *
@@ -1030,7 +1058,8 @@ static int _disable_clocks(struct omap_hwmod *oh)
  */
 static void _omap4_enable_module(struct omap_hwmod *oh)
 {
-	if (!oh->clkdm || !oh->prcm.omap4.modulemode)
+	if (!oh->clkdm || !oh->prcm.omap4.modulemode ||
+	    _omap4_clkctrl_managed_by_clkfwk(oh))
 		return;
 
 	pr_debug("omap_hwmod: %s: %s: %d\n",
@@ -1061,8 +1090,10 @@ static int _omap4_wait_target_disable(struct omap_hwmod *oh)
 	if (oh->flags & HWMOD_NO_IDLEST)
 		return 0;
 
-	if (!oh->prcm.omap4.clkctrl_offs &&
-	    !(oh->prcm.omap4.flags & HWMOD_OMAP4_ZERO_CLKCTRL_OFFSET))
+	if (_omap4_clkctrl_managed_by_clkfwk(oh))
+		return 0;
+
+	if (!_omap4_has_clkctrl_clock(oh))
 		return 0;
 
 	return omap_cm_wait_module_idle(oh->clkdm->prcm_partition,
@@ -1847,7 +1878,8 @@ static int _omap4_disable_module(struct omap_hwmod *oh)
 {
 	int v;
 
-	if (!oh->clkdm || !oh->prcm.omap4.modulemode)
+	if (!oh->clkdm || !oh->prcm.omap4.modulemode ||
+	    _omap4_clkctrl_managed_by_clkfwk(oh))
 		return -EINVAL;
 
 	/*
@@ -2829,8 +2861,10 @@ static int _omap4_wait_target_ready(struct omap_hwmod *oh)
 	if (!_find_mpu_rt_port(oh))
 		return 0;
 
-	if (!oh->prcm.omap4.clkctrl_offs &&
-	    !(oh->prcm.omap4.flags & HWMOD_OMAP4_ZERO_CLKCTRL_OFFSET))
+	if (_omap4_clkctrl_managed_by_clkfwk(oh))
+		return 0;
+
+	if (!_omap4_has_clkctrl_clock(oh))
 		return 0;
 
 	/* XXX check module SIDLEMODE, hardreset status */
@@ -2986,8 +3020,7 @@ static int _omap4_disable_direct_prcm(struct omap_hwmod *oh)
 	if (!oh)
 		return -EINVAL;
 
-	oh->prcm.omap4.clkctrl_offs = 0;
-	oh->prcm.omap4.modulemode = 0;
+	oh->prcm.omap4.flags |= HWMOD_OMAP4_CLKFWK_CLKCTR_CLOCK;
 
 	return 0;
 }

commit a8e65e06ec66f8657795162c51ee73bec116a890
Author: Rob Herring <robh@kernel.org>
Date:   Fri Jul 21 14:28:32 2017 -0500

    ARM: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Acked-by: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Kukjin Kim <kgene@kernel.org>
    Cc: Javier Martinez Canillas <javier@osg.samsung.com>
    Cc: Fabio Estevam <fabio.estevam@nxp.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: "Benot Cousson" <bcousson@baylibre.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 3b47ded5fa0c..2dbd63239c54 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2417,8 +2417,8 @@ static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data,
 		if (mem)
 			pr_err("omap_hwmod: %s: Could not ioremap\n", oh->name);
 		else
-			pr_err("omap_hwmod: %s: Missing dt reg%i for %s\n",
-			       oh->name, index, np->full_name);
+			pr_err("omap_hwmod: %s: Missing dt reg%i for %pOF\n",
+			       oh->name, index, np);
 		return -ENXIO;
 	}
 

commit 67d00470accf5c58abbb23a44c867c5f15437976
Merge: 018b732458ac 70f05be32133
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Jun 12 03:27:30 2017 -0700

    Merge branch 'omap-for-v4.13/clkctrl' into omap-for-v4.13/soc-v4

commit 1aa8f0cb19e59a0def9925d401d628c1846c3270
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 31 15:51:37 2017 -0700

    ARM: OMAP2+: Remove unused legacy code for interconnects
    
    We are now booting all mach-omap2 in device tree only mode.
    Any code that is only called in legacy boot mode where
    of_have_populated_dt() is not set is safe to remove now.
    
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 8bcea0d83fa0..0f7afdaf80d3 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2334,24 +2334,21 @@ static int __init _init(struct omap_hwmod *oh, void *data)
 {
 	int r, index;
 	struct device_node *np = NULL;
+	struct device_node *bus;
 
 	if (oh->_state != _HWMOD_STATE_REGISTERED)
 		return 0;
 
-	if (of_have_populated_dt()) {
-		struct device_node *bus;
-
-		bus = of_find_node_by_name(NULL, "ocp");
-		if (!bus)
-			return -ENODEV;
+	bus = of_find_node_by_name(NULL, "ocp");
+	if (!bus)
+		return -ENODEV;
 
-		r = of_dev_hwmod_lookup(bus, oh, &index, &np);
-		if (r)
-			pr_debug("omap_hwmod: %s missing dt data\n", oh->name);
-		else if (np && index)
-			pr_warn("omap_hwmod: %s using broken dt data from %s\n",
-				oh->name, np->name);
-	}
+	r = of_dev_hwmod_lookup(bus, oh, &index, &np);
+	if (r)
+		pr_debug("omap_hwmod: %s missing dt data\n", oh->name);
+	else if (np && index)
+		pr_warn("omap_hwmod: %s using broken dt data from %s\n",
+			oh->name, np->name);
 
 	r = _init_mpu_rt_base(oh, NULL, index, np);
 	if (r < 0) {

commit 70f05be3213393f20f01e4d59625df7ee49fe32f
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed May 31 18:00:03 2017 +0300

    ARM: OMAP2+: hwmod: populate clkctrl clocks for hwmods if available
    
    If clkctrl clocks are available on a device, populate these automatically
    to replace hwmod main_clk info. First, the patch parses all "ti,clkctrl"
    compatible nodes and maps these against existing clockdomain data. Once
    done, individual hwmod init routines can search for a clkctrl clock
    handle based on the clockdomain info and the created mapping.
    
    This patch also drops the obsolete "_mod_ck" search as the implementation
    required for this was not accepted usptream.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 8bcea0d83fa0..e1107670acb6 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -141,6 +141,7 @@
 #include <linux/cpu.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
+#include <linux/bootmem.h>
 
 #include <asm/system_misc.h>
 
@@ -181,6 +182,24 @@
  */
 #define MOD_CLK_MAX_NAME_LEN		32
 
+/**
+ * struct clkctrl_provider - clkctrl provider mapping data
+ * @addr: base address for the provider
+ * @offset: base offset for the provider
+ * @clkdm: base clockdomain for provider
+ * @node: device node associated with the provider
+ * @link: list link
+ */
+struct clkctrl_provider {
+	u32			addr;
+	u16			offset;
+	struct clockdomain	*clkdm;
+	struct device_node	*node;
+	struct list_head	link;
+};
+
+static LIST_HEAD(clkctrl_providers);
+
 /**
  * struct omap_hwmod_soc_ops - fn ptrs for some SoC-specific operations
  * @enable_module: function to enable a module (via MODULEMODE)
@@ -204,6 +223,8 @@ struct omap_hwmod_soc_ops {
 	void (*update_context_lost)(struct omap_hwmod *oh);
 	int (*get_context_lost)(struct omap_hwmod *oh);
 	int (*disable_direct_prcm)(struct omap_hwmod *oh);
+	u32 (*xlate_clkctrl)(struct omap_hwmod *oh,
+			     struct clkctrl_provider *provider);
 };
 
 /* soc_ops: adapts the omap_hwmod code to the currently-booted SoC */
@@ -690,6 +711,103 @@ static int _del_initiator_dep(struct omap_hwmod *oh, struct omap_hwmod *init_oh)
 	return clkdm_del_sleepdep(clkdm, init_clkdm);
 }
 
+static const struct of_device_id ti_clkctrl_match_table[] __initconst = {
+	{ .compatible = "ti,clkctrl" },
+	{ }
+};
+
+static int _match_clkdm(struct clockdomain *clkdm, void *user)
+{
+	struct clkctrl_provider *provider = user;
+
+	if (clkdm_xlate_address(clkdm) == provider->addr) {
+		pr_debug("%s: Matched clkdm %s for addr %x (%s)\n", __func__,
+			 clkdm->name, provider->addr,
+			 provider->node->parent->name);
+		provider->clkdm = clkdm;
+
+		return -1;
+	}
+
+	return 0;
+}
+
+static int _setup_clkctrl_provider(struct device_node *np)
+{
+	const __be32 *addrp;
+	struct clkctrl_provider *provider;
+
+	provider = memblock_virt_alloc(sizeof(*provider), 0);
+	if (!provider)
+		return -ENOMEM;
+
+	addrp = of_get_address(np, 0, NULL, NULL);
+	provider->addr = (u32)of_translate_address(np, addrp);
+	provider->offset = provider->addr & 0xff;
+	provider->addr &= ~0xff;
+	provider->node = np;
+
+	clkdm_for_each(_match_clkdm, provider);
+
+	if (!provider->clkdm) {
+		pr_err("%s: nothing matched for node %s (%x)\n",
+		       __func__, np->parent->name, provider->addr);
+		memblock_free_early(__pa(provider), sizeof(*provider));
+		return -EINVAL;
+	}
+
+	list_add(&provider->link, &clkctrl_providers);
+
+	return 0;
+}
+
+static int _init_clkctrl_providers(void)
+{
+	struct device_node *np;
+	int ret = 0;
+
+	for_each_matching_node(np, ti_clkctrl_match_table) {
+		ret = _setup_clkctrl_provider(np);
+		if (ret)
+			break;
+	}
+
+	return ret;
+}
+
+static u32 _omap4_xlate_clkctrl(struct omap_hwmod *oh,
+				struct clkctrl_provider *provider)
+{
+	return oh->prcm.omap4.clkctrl_offs -
+	       provider->offset - provider->clkdm->clkdm_offs;
+}
+
+static struct clk *_lookup_clkctrl_clk(struct omap_hwmod *oh)
+{
+	struct clkctrl_provider *provider;
+	struct clk *clk;
+
+	if (!soc_ops.xlate_clkctrl)
+		return NULL;
+
+	list_for_each_entry(provider, &clkctrl_providers, link) {
+		if (provider->clkdm == oh->clkdm) {
+			struct of_phandle_args clkspec;
+
+			clkspec.np = provider->node;
+			clkspec.args_count = 2;
+			clkspec.args[0] = soc_ops.xlate_clkctrl(oh, provider);
+			clkspec.args[1] = 0;
+
+			clk = of_clk_get_from_provider(&clkspec);
+
+			return clk;
+		}
+	}
+
+	return NULL;
+}
+
 /**
  * _init_main_clk - get a struct clk * for the the hwmod's main functional clk
  * @oh: struct omap_hwmod *
@@ -701,22 +819,16 @@ static int _del_initiator_dep(struct omap_hwmod *oh, struct omap_hwmod *init_oh)
 static int _init_main_clk(struct omap_hwmod *oh)
 {
 	int ret = 0;
-	char name[MOD_CLK_MAX_NAME_LEN];
-	struct clk *clk;
-	static const char modck[] = "_mod_ck";
+	struct clk *clk = NULL;
 
-	if (strlen(oh->name) >= MOD_CLK_MAX_NAME_LEN - strlen(modck))
-		pr_warn("%s: warning: cropping name for %s\n", __func__,
-			oh->name);
-
-	strlcpy(name, oh->name, MOD_CLK_MAX_NAME_LEN - strlen(modck));
-	strlcat(name, modck, MOD_CLK_MAX_NAME_LEN);
+	clk = _lookup_clkctrl_clk(oh);
 
-	clk = clk_get(NULL, name);
-	if (!IS_ERR(clk)) {
+	if (!IS_ERR_OR_NULL(clk)) {
+		pr_debug("%s: mapped main_clk %s for %s\n", __func__,
+			 __clk_get_name(clk), oh->name);
+		oh->main_clk = __clk_get_name(clk);
 		oh->_clk = clk;
 		soc_ops.disable_direct_prcm(oh);
-		oh->main_clk = kstrdup(name, GFP_KERNEL);
 	} else {
 		if (!oh->main_clk)
 			return 0;
@@ -1482,13 +1594,13 @@ static int _init_clkdm(struct omap_hwmod *oh)
  * _init_clocks - clk_get() all clocks associated with this hwmod. Retrieve as
  * well the clockdomain.
  * @oh: struct omap_hwmod *
- * @data: not used; pass NULL
+ * @np: device_node mapped to this hwmod
  *
  * Called by omap_hwmod_setup_*() (after omap2_clk_init()).
  * Resolves all clock names embedded in the hwmod.  Returns 0 on
  * success, or a negative error code on failure.
  */
-static int _init_clocks(struct omap_hwmod *oh, void *data)
+static int _init_clocks(struct omap_hwmod *oh, struct device_node *np)
 {
 	int ret = 0;
 
@@ -2360,7 +2472,7 @@ static int __init _init(struct omap_hwmod *oh, void *data)
 		return 0;
 	}
 
-	r = _init_clocks(oh, NULL);
+	r = _init_clocks(oh, np);
 	if (r < 0) {
 		WARN(1, "omap_hwmod: %s: couldn't init clocks\n", oh->name);
 		return -EINVAL;
@@ -3722,6 +3834,7 @@ void __init omap_hwmod_init(void)
 		soc_ops.update_context_lost = _omap4_update_context_lost;
 		soc_ops.get_context_lost = _omap4_get_context_lost;
 		soc_ops.disable_direct_prcm = _omap4_disable_direct_prcm;
+		soc_ops.xlate_clkctrl = _omap4_xlate_clkctrl;
 	} else if (cpu_is_ti814x() || cpu_is_ti816x() || soc_is_am33xx() ||
 		   soc_is_am43xx()) {
 		soc_ops.enable_module = _omap4_enable_module;
@@ -3736,6 +3849,8 @@ void __init omap_hwmod_init(void)
 		WARN(1, "omap_hwmod: unknown SoC type\n");
 	}
 
+	_init_clkctrl_providers();
+
 	inited = true;
 }
 

commit 8ff42da411474893ae373d4280ea88954fa97fcc
Author: Roger Quadros <rogerq@ti.com>
Date:   Fri Mar 17 10:58:18 2017 +0200

    ARM: OMAP2+ hwmod: Allow modules to disable HW_AUTO
    
    Introduce HWMOD_CLKDM_NOAUTO flag that allows the hwmod's
    clockdomain to be prevented from HW_AUTO while the hwmod is active.
    
    This is needed to workaround some modules which don't function
    correctly with HW_AUTO. e.g. DCAN on DRA7.
    
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    [nsekhar@ti.com: rebased to v4.9 kernel]
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 8a4039325845..8bcea0d83fa0 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2027,7 +2027,7 @@ static int _enable(struct omap_hwmod *oh)
 
 	r = (soc_ops.wait_target_ready) ? soc_ops.wait_target_ready(oh) :
 		-EINVAL;
-	if (oh->clkdm)
+	if (oh->clkdm && !(oh->flags & HWMOD_CLKDM_NOAUTO))
 		clkdm_allow_idle(oh->clkdm);
 
 	if (!r) {
@@ -2084,7 +2084,12 @@ static int _idle(struct omap_hwmod *oh)
 		_idle_sysc(oh);
 	_del_initiator_dep(oh, mpu_oh);
 
-	if (oh->clkdm)
+	/*
+	 * If HWMOD_CLKDM_NOAUTO is set then we don't
+	 * deny idle the clkdm again since idle was already denied
+	 * in _enable()
+	 */
+	if (oh->clkdm && !(oh->flags & HWMOD_CLKDM_NOAUTO))
 		clkdm_deny_idle(oh->clkdm);
 
 	if (oh->flags & HWMOD_BLOCK_WFI)

commit ca5339b18c6b0a94d869ef72861bc8423c788ad0
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Mar 14 13:13:19 2017 -0700

    ARM: OMAP2+: Remove unused CLOCKACT_TEST_ICLK
    
    This is not used so let's remove it.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 33b36c392210..8a4039325845 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1328,7 +1328,7 @@ static void _enable_sysc(struct omap_hwmod *oh)
 	 */
 	if ((oh->flags & HWMOD_SET_DEFAULT_CLOCKACT) &&
 	    (sf & SYSC_HAS_CLOCKACTIVITY))
-		_set_clockactivity(oh, oh->class->sysc->clockact, &v);
+		_set_clockactivity(oh, CLOCKACT_TEST_ICLK, &v);
 
 	_write_sysconfig(v, oh);
 

commit b8e1bddc9826c08ba479a785ea3c212ed6f54ef8
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Mar 14 13:13:19 2017 -0700

    ARM: OMAP2+: Use list_for_each_entry for hwmod slave_ports
    
    We are just iterating over the slave_ports lists, so we can
    use list_for_each_entry() no problem.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 7b7ba6d48e83..33b36c392210 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -220,29 +220,6 @@ static bool inited;
 
 /* Private functions */
 
-/**
- * _fetch_next_ocp_if - return the next OCP interface in a list
- * @p: ptr to a ptr to the list_head inside the ocp_if to return
- * @i: pointer to the index of the element pointed to by @p in the list
- *
- * Return a pointer to the struct omap_hwmod_ocp_if record
- * containing the struct list_head pointed to by @p, and increment
- * @p such that a future call to this routine will return the next
- * record.
- */
-static struct omap_hwmod_ocp_if *_fetch_next_ocp_if(struct list_head **p,
-						    int *i)
-{
-	struct omap_hwmod_ocp_if *oi;
-
-	oi = list_entry(*p, struct omap_hwmod_ocp_if, node);
-	*p = (*p)->next;
-
-	*i = *i + 1;
-
-	return oi;
-}
-
 /**
  * _update_sysc_cache - return the module OCP_SYSCONFIG register, keep copy
  * @oh: struct omap_hwmod *
@@ -779,15 +756,10 @@ static int _init_main_clk(struct omap_hwmod *oh)
 static int _init_interface_clks(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_ocp_if *os;
-	struct list_head *p;
 	struct clk *c;
-	int i = 0;
 	int ret = 0;
 
-	p = oh->slave_ports.next;
-
-	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(&p, &i);
+	list_for_each_entry(os, &oh->slave_ports, node) {
 		if (!os->clk)
 			continue;
 
@@ -890,19 +862,13 @@ static void _disable_optional_clocks(struct omap_hwmod *oh)
 static int _enable_clocks(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_ocp_if *os;
-	struct list_head *p;
-	int i = 0;
 
 	pr_debug("omap_hwmod: %s: enabling clocks\n", oh->name);
 
 	if (oh->_clk)
 		clk_enable(oh->_clk);
 
-	p = oh->slave_ports.next;
-
-	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(&p, &i);
-
+	list_for_each_entry(os, &oh->slave_ports, node) {
 		if (os->_clk && (os->flags & OCPIF_SWSUP_IDLE))
 			clk_enable(os->_clk);
 	}
@@ -924,19 +890,13 @@ static int _enable_clocks(struct omap_hwmod *oh)
 static int _disable_clocks(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_ocp_if *os;
-	struct list_head *p;
-	int i = 0;
 
 	pr_debug("omap_hwmod: %s: disabling clocks\n", oh->name);
 
 	if (oh->_clk)
 		clk_disable(oh->_clk);
 
-	p = oh->slave_ports.next;
-
-	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(&p, &i);
-
+	list_for_each_entry(os, &oh->slave_ports, node) {
 		if (os->_clk && (os->flags & OCPIF_SWSUP_IDLE))
 			clk_disable(os->_clk);
 	}
@@ -1175,16 +1135,11 @@ static int _get_sdma_req_by_name(struct omap_hwmod *oh, const char *name,
 static int _get_addr_space_by_name(struct omap_hwmod *oh, const char *name,
 				   u32 *pa_start, u32 *pa_end)
 {
-	int i, j;
+	int j;
 	struct omap_hwmod_ocp_if *os;
-	struct list_head *p = NULL;
 	bool found = false;
 
-	p = oh->slave_ports.next;
-
-	i = 0;
-	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(&p, &i);
+	list_for_each_entry(os, &oh->slave_ports, node) {
 
 		if (!os->addr)
 			return -ENOENT;
@@ -1224,18 +1179,13 @@ static int _get_addr_space_by_name(struct omap_hwmod *oh, const char *name,
 static void __init _save_mpu_port_index(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_ocp_if *os = NULL;
-	struct list_head *p;
-	int i = 0;
 
 	if (!oh)
 		return;
 
 	oh->_int_flags |= _HWMOD_NO_MPU_PORT;
 
-	p = oh->slave_ports.next;
-
-	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(&p, &i);
+	list_for_each_entry(os, &oh->slave_ports, node) {
 		if (os->user & OCP_USER_MPU) {
 			oh->_mpu_port = os;
 			oh->_int_flags &= ~_HWMOD_NO_MPU_PORT;
@@ -2436,15 +2386,11 @@ static int __init _init(struct omap_hwmod *oh, void *data)
 static void __init _setup_iclk_autoidle(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_ocp_if *os;
-	struct list_head *p;
-	int i = 0;
+
 	if (oh->_state != _HWMOD_STATE_INITIALIZED)
 		return;
 
-	p = oh->slave_ports.next;
-
-	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(&p, &i);
+	list_for_each_entry(os, &oh->slave_ports, node) {
 		if (!os->_clk)
 			continue;
 
@@ -3288,14 +3234,10 @@ int omap_hwmod_count_resources(struct omap_hwmod *oh, unsigned long flags)
 		ret += _count_sdma_reqs(oh);
 
 	if (flags & IORESOURCE_MEM) {
-		int i = 0;
 		struct omap_hwmod_ocp_if *os;
-		struct list_head *p = oh->slave_ports.next;
 
-		while (i < oh->slaves_cnt) {
-			os = _fetch_next_ocp_if(&p, &i);
+		list_for_each_entry(os, &oh->slave_ports, node)
 			ret += _count_ocp_if_addr_spaces(os);
-		}
 	}
 
 	return ret;
@@ -3314,7 +3256,6 @@ int omap_hwmod_count_resources(struct omap_hwmod *oh, unsigned long flags)
 int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 {
 	struct omap_hwmod_ocp_if *os;
-	struct list_head *p;
 	int i, j, mpu_irqs_cnt, sdma_reqs_cnt, addr_cnt;
 	int r = 0;
 
@@ -3344,11 +3285,7 @@ int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 		r++;
 	}
 
-	p = oh->slave_ports.next;
-
-	i = 0;
-	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(&p, &i);
+	list_for_each_entry(os, &oh->slave_ports, node) {
 		addr_cnt = _count_ocp_if_addr_spaces(os);
 
 		for (j = 0; j < addr_cnt; j++) {

commit a1e312355d41cd63b9f47081ade9168eedc4574d
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Mar 14 13:13:19 2017 -0700

    ARM: OMAP2+: Remove mostly unused hwmod linkspace
    
    We want to be able to dynamically allocate struct omap_hwmod_ocp_if and
    struct omap_hwmod at device driver probe time based on .dts data.
    
    Current setup with the linkspace using memblock_virt_alloc() makes
    this tricky, so let's get rid of struct linkspace and directly set up
    struct omap_hwmod_ocp_if as the master and slave lists.
    
    As we are currently not using the master_ports either, let's remove it
    too. And let's add the struct omap_hwmod_ocp_if node directly to the
    slave_ports list.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 0da4f2ea76c4..7b7ba6d48e83 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -138,7 +138,6 @@
 #include <linux/mutex.h>
 #include <linux/spinlock.h>
 #include <linux/slab.h>
-#include <linux/bootmem.h>
 #include <linux/cpu.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
@@ -216,20 +215,6 @@ static LIST_HEAD(omap_hwmod_list);
 /* mpu_oh: used to add/remove MPU initiator from sleepdep list */
 static struct omap_hwmod *mpu_oh;
 
-/*
- * linkspace: ptr to a buffer that struct omap_hwmod_link records are
- * allocated from - used to reduce the number of small memory
- * allocations, which has a significant impact on performance
- */
-static struct omap_hwmod_link *linkspace;
-
-/*
- * free_ls, max_ls: array indexes into linkspace; representing the
- * next free struct omap_hwmod_link index, and the maximum number of
- * struct omap_hwmod_link records allocated (respectively)
- */
-static unsigned short free_ls, max_ls, ls_supp;
-
 /* inited: set to true once the hwmod code is initialized */
 static bool inited;
 
@@ -250,7 +235,7 @@ static struct omap_hwmod_ocp_if *_fetch_next_ocp_if(struct list_head **p,
 {
 	struct omap_hwmod_ocp_if *oi;
 
-	oi = list_entry(*p, struct omap_hwmod_link, node)->ocp_if;
+	oi = list_entry(*p, struct omap_hwmod_ocp_if, node);
 	*p = (*p)->next;
 
 	*i = *i + 1;
@@ -2657,7 +2642,6 @@ static int __init _register(struct omap_hwmod *oh)
 
 	list_add_tail(&oh->node, &omap_hwmod_list);
 
-	INIT_LIST_HEAD(&oh->master_ports);
 	INIT_LIST_HEAD(&oh->slave_ports);
 	spin_lock_init(&oh->_lock);
 	lockdep_set_class(&oh->_lock, &oh->hwmod_key);
@@ -2674,50 +2658,11 @@ static int __init _register(struct omap_hwmod *oh)
 	return 0;
 }
 
-/**
- * _alloc_links - return allocated memory for hwmod links
- * @ml: pointer to a struct omap_hwmod_link * for the master link
- * @sl: pointer to a struct omap_hwmod_link * for the slave link
- *
- * Return pointers to two struct omap_hwmod_link records, via the
- * addresses pointed to by @ml and @sl.  Will first attempt to return
- * memory allocated as part of a large initial block, but if that has
- * been exhausted, will allocate memory itself.  Since ideally this
- * second allocation path will never occur, the number of these
- * 'supplemental' allocations will be logged when debugging is
- * enabled.  Returns 0.
- */
-static int __init _alloc_links(struct omap_hwmod_link **ml,
-			       struct omap_hwmod_link **sl)
-{
-	unsigned int sz;
-
-	if ((free_ls + LINKS_PER_OCP_IF) <= max_ls) {
-		*ml = &linkspace[free_ls++];
-		*sl = &linkspace[free_ls++];
-		return 0;
-	}
-
-	sz = sizeof(struct omap_hwmod_link) * LINKS_PER_OCP_IF;
-
-	*sl = NULL;
-	*ml = memblock_virt_alloc(sz, 0);
-
-	*sl = (void *)(*ml) + sizeof(struct omap_hwmod_link);
-
-	ls_supp++;
-	pr_debug("omap_hwmod: supplemental link allocations needed: %d\n",
-		 ls_supp * LINKS_PER_OCP_IF);
-
-	return 0;
-};
-
 /**
  * _add_link - add an interconnect between two IP blocks
  * @oi: pointer to a struct omap_hwmod_ocp_if record
  *
- * Add struct omap_hwmod_link records connecting the master IP block
- * specified in @oi->master to @oi, and connecting the slave IP block
+ * Add struct omap_hwmod_link records connecting the slave IP block
  * specified in @oi->slave to @oi.  This code is assumed to run before
  * preemption or SMP has been enabled, thus avoiding the need for
  * locking in this code.  Changes to this assumption will require
@@ -2725,19 +2670,10 @@ static int __init _alloc_links(struct omap_hwmod_link **ml,
  */
 static int __init _add_link(struct omap_hwmod_ocp_if *oi)
 {
-	struct omap_hwmod_link *ml, *sl;
-
 	pr_debug("omap_hwmod: %s -> %s: adding link\n", oi->master->name,
 		 oi->slave->name);
 
-	_alloc_links(&ml, &sl);
-
-	ml->ocp_if = oi;
-	list_add(&ml->node, &oi->master->master_ports);
-	oi->master->masters_cnt++;
-
-	sl->ocp_if = oi;
-	list_add(&sl->node, &oi->slave->slave_ports);
+	list_add(&oi->node, &oi->slave->slave_ports);
 	oi->slave->slaves_cnt++;
 
 	return 0;
@@ -2784,45 +2720,6 @@ static int __init _register_link(struct omap_hwmod_ocp_if *oi)
 	return 0;
 }
 
-/**
- * _alloc_linkspace - allocate large block of hwmod links
- * @ois: pointer to an array of struct omap_hwmod_ocp_if records to count
- *
- * Allocate a large block of struct omap_hwmod_link records.  This
- * improves boot time significantly by avoiding the need to allocate
- * individual records one by one.  If the number of records to
- * allocate in the block hasn't been manually specified, this function
- * will count the number of struct omap_hwmod_ocp_if records in @ois
- * and use that to determine the allocation size.  For SoC families
- * that require multiple list registrations, such as OMAP3xxx, this
- * estimation process isn't optimal, so manual estimation is advised
- * in those cases.  Returns -EEXIST if the allocation has already occurred
- * or 0 upon success.
- */
-static int __init _alloc_linkspace(struct omap_hwmod_ocp_if **ois)
-{
-	unsigned int i = 0;
-	unsigned int sz;
-
-	if (linkspace) {
-		WARN(1, "linkspace already allocated\n");
-		return -EEXIST;
-	}
-
-	if (max_ls == 0)
-		while (ois[i++])
-			max_ls += LINKS_PER_OCP_IF;
-
-	sz = sizeof(struct omap_hwmod_link) * max_ls;
-
-	pr_debug("omap_hwmod: %s: allocating %d byte linkspace (%d links)\n",
-		 __func__, sz, max_ls);
-
-	linkspace = memblock_virt_alloc(sz, 0);
-
-	return 0;
-}
-
 /* Static functions intended only for use in soc_ops field function pointers */
 
 /**
@@ -3180,13 +3077,6 @@ int __init omap_hwmod_register_links(struct omap_hwmod_ocp_if **ois)
 	if (ois[0] == NULL) /* Empty list */
 		return 0;
 
-	if (!linkspace) {
-		if (_alloc_linkspace(ois)) {
-			pr_err("omap_hwmod: could not allocate link space\n");
-			return -ENOMEM;
-		}
-	}
-
 	i = 0;
 	do {
 		r = _register_link(ois[i]);

commit f0d0b8cb6bb361bd88f10900e9716eec73e262d9
Merge: 37b3785b1362 8c4bc910633d
Author: Olof Johansson <olof@lixom.net>
Date:   Sun Jan 29 17:15:36 2017 -0800

    Merge tag 'omap-for-v4.11/soc-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into next/soc
    
    SoC changes for omaps for v4.11 merge window. This adds support
    for keeping the interconnect target module active for uart if
    earlycon is specified. And we're adding Aaro Koskinen as a
    co-maintainer for omap1 to make sure things stay working for
    omap1. The other changes are mostly clean-up of old legacy code:
    
    - Remove unused omap_display_init()
    - Make omapdss_find_dss_of_node() function static
    - Add support for earlycon
    - Tidy up omap1 usb logging output with pr_cont
    - Make omap_otg_init() static
    - Delete redundant CPU class checks for omap1
    - Remove unused mpurate cmdline option that has not done
      anything for past 1.5 years at least
    
    * tag 'omap-for-v4.11/soc-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap:
      ARM: OMAP: clock: Remove unused mpurate cmdline option
      ARM: OMAP2+: omap_hwmod: Add support for earlycon
      MAINTAINERS: Add Aaro Koskinen as TI omap1 SoC co-maintainer
      ARM: OMAP1: USB: delete redundant CPU class checks
      ARM: OMAP1: USB: make omap_otg_init() static
      ARM: OMAP1: USB: tidy up logging output
      ARM: OMAP2+: Make the omapdss_find_dss_of_node() function static
      ARM: OMAP2+: Remove unused omap_display_init() function
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 8dd6666f4937d7cc94781771e1a8fc837fea84fb
Author: Lokesh Vutla <lokeshvutla@ti.com>
Date:   Fri Jan 20 10:39:10 2017 -0800

    ARM: OMAP2+: omap_hwmod: Add support for earlycon
    
    Hwmod core tries to reset and idles each IP that is registered with hwmod.
    In case of earlycon, that specific uart IP cannot be reset or keep it in
    idle state else earlycon hangs once hwmod resets that uart IP. So add support
    to not reset uart that is being used as earlycon only if CONFIG_SERIAL_EARLYCON
    is enabled.
    
    Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 759e1d45ba25..0ab29097a070 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3248,6 +3248,36 @@ int __init omap_hwmod_setup_one(const char *oh_name)
 	return 0;
 }
 
+/**
+ * omap_hwmod_setup_earlycon_flags - set up flags for early console
+ *
+ * Enable DEBUG_OMAPUART_FLAGS for uart hwmod that is being used as
+ * early concole so that hwmod core doesn't reset and keep it in idle
+ * that specific uart.
+ */
+#ifdef CONFIG_SERIAL_EARLYCON
+static void __init omap_hwmod_setup_earlycon_flags(void)
+{
+	struct device_node *np;
+	struct omap_hwmod *oh;
+	const char *uart;
+
+	np = of_find_node_by_path("/chosen");
+	if (np) {
+		uart = of_get_property(np, "stdout-path", NULL);
+		if (uart) {
+			np = of_find_node_by_path(uart);
+			if (np) {
+				uart = of_get_property(np, "ti,hwmods", NULL);
+				oh = omap_hwmod_lookup(uart);
+				if (oh)
+					oh->flags |= DEBUG_OMAPUART_FLAGS;
+			}
+		}
+	}
+}
+#endif
+
 /**
  * omap_hwmod_setup_all - set up all registered IP blocks
  *
@@ -3261,6 +3291,9 @@ static int __init omap_hwmod_setup_all(void)
 	_ensure_mpu_hwmod_is_setup(NULL);
 
 	omap_hwmod_for_each(_init, NULL);
+#ifdef CONFIG_SERIAL_EARLYCON
+	omap_hwmod_setup_earlycon_flags();
+#endif
 	omap_hwmod_for_each(_setup, NULL);
 
 	return 0;

commit 5066d5296ff2db20625e5f46e7338872c90c649f
Author: Maninder Singh <maninder1.s@samsung.com>
Date:   Thu Dec 8 09:40:30 2016 +0530

    ARM: omap2+: fixing wrong strcat for Non-NULL terminated string
    
    Issue caught with static analysis tool:
    "Dangerous usage of 'name' (strncpy doesn't always 0-terminate it)"
    
    Use strlcpy _includes_ the NUL terminator, and  strlcat() which ensures
    that it won't overflow the buffer.
    
    Reported-by: Maninder Singh <maninder1.s@samsung.com>
    Signed-off-by: Vaneet Narang <v.narang@samsung.com>
    CC: Russell King <linux@armlinux.org.uk>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 759e1d45ba25..e8b988714a09 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -741,14 +741,14 @@ static int _init_main_clk(struct omap_hwmod *oh)
 	int ret = 0;
 	char name[MOD_CLK_MAX_NAME_LEN];
 	struct clk *clk;
+	static const char modck[] = "_mod_ck";
 
-	/* +7 magic comes from '_mod_ck' suffix */
-	if (strlen(oh->name) + 7 > MOD_CLK_MAX_NAME_LEN)
+	if (strlen(oh->name) >= MOD_CLK_MAX_NAME_LEN - strlen(modck))
 		pr_warn("%s: warning: cropping name for %s\n", __func__,
 			oh->name);
 
-	strncpy(name, oh->name, MOD_CLK_MAX_NAME_LEN - 7);
-	strcat(name, "_mod_ck");
+	strlcpy(name, oh->name, MOD_CLK_MAX_NAME_LEN - strlen(modck));
+	strlcat(name, modck, MOD_CLK_MAX_NAME_LEN);
 
 	clk = clk_get(NULL, name);
 	if (!IS_ERR(clk)) {

commit b42814557fd5a9cc943dbe326b99dd104af23195
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Oct 20 06:35:21 2016 -0700

    ARM: OMAP2+: Remove legacy hwmod mux code
    
    This is no longer needed when booted with device tree.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 1052b29697b8..759e1d45ba25 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -160,7 +160,6 @@
 #include "prm44xx.h"
 #include "prm33xx.h"
 #include "prminst44xx.h"
-#include "mux.h"
 #include "pm.h"
 
 /* Name of the OMAP hwmod for the MPU */
@@ -217,9 +216,6 @@ static LIST_HEAD(omap_hwmod_list);
 /* mpu_oh: used to add/remove MPU initiator from sleepdep list */
 static struct omap_hwmod *mpu_oh;
 
-/* io_chain_lock: used to serialize reconfigurations of the I/O chain */
-static DEFINE_SPINLOCK(io_chain_lock);
-
 /*
  * linkspace: ptr to a buffer that struct omap_hwmod_link records are
  * allocated from - used to reduce the number of small memory
@@ -593,51 +589,6 @@ static int _set_module_autoidle(struct omap_hwmod *oh, u8 autoidle,
 	return 0;
 }
 
-/**
- * _set_idle_ioring_wakeup - enable/disable IO pad wakeup on hwmod idle for mux
- * @oh: struct omap_hwmod *
- * @set_wake: bool value indicating to set (true) or clear (false) wakeup enable
- *
- * Set or clear the I/O pad wakeup flag in the mux entries for the
- * hwmod @oh.  This function changes the @oh->mux->pads_dynamic array
- * in memory.  If the hwmod is currently idled, and the new idle
- * values don't match the previous ones, this function will also
- * update the SCM PADCTRL registers.  Otherwise, if the hwmod is not
- * currently idled, this function won't touch the hardware: the new
- * mux settings are written to the SCM PADCTRL registers when the
- * hwmod is idled.  No return value.
- */
-static void _set_idle_ioring_wakeup(struct omap_hwmod *oh, bool set_wake)
-{
-	struct omap_device_pad *pad;
-	bool change = false;
-	u16 prev_idle;
-	int j;
-
-	if (!oh->mux || !oh->mux->enabled)
-		return;
-
-	for (j = 0; j < oh->mux->nr_pads_dynamic; j++) {
-		pad = oh->mux->pads_dynamic[j];
-
-		if (!(pad->flags & OMAP_DEVICE_PAD_WAKEUP))
-			continue;
-
-		prev_idle = pad->idle;
-
-		if (set_wake)
-			pad->idle |= OMAP_WAKEUP_EN;
-		else
-			pad->idle &= ~OMAP_WAKEUP_EN;
-
-		if (prev_idle != pad->idle)
-			change = true;
-	}
-
-	if (change && oh->_state == _HWMOD_STATE_IDLE)
-		omap_hwmod_mux(oh->mux, _HWMOD_STATE_IDLE);
-}
-
 /**
  * _enable_wakeup: set OCP_SYSCONFIG.ENAWAKEUP bit in the hardware
  * @oh: struct omap_hwmod *
@@ -2017,29 +1968,6 @@ static int _reset(struct omap_hwmod *oh)
 	return r;
 }
 
-/**
- * _reconfigure_io_chain - clear any I/O chain wakeups and reconfigure chain
- *
- * Call the appropriate PRM function to clear any logged I/O chain
- * wakeups and to reconfigure the chain.  This apparently needs to be
- * done upon every mux change.  Since hwmods can be concurrently
- * enabled and idled, hold a spinlock around the I/O chain
- * reconfiguration sequence.  No return value.
- *
- * XXX When the PRM code is moved to drivers, this function can be removed,
- * as the PRM infrastructure should abstract this.
- */
-static void _reconfigure_io_chain(void)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&io_chain_lock, flags);
-
-	omap_prm_reconfigure_io_chain();
-
-	spin_unlock_irqrestore(&io_chain_lock, flags);
-}
-
 /**
  * _omap4_update_context_lost - increment hwmod context loss counter if
  * hwmod context was lost, and clear hardware context loss reg
@@ -2109,18 +2037,9 @@ static int _enable(struct omap_hwmod *oh)
 
 	/*
 	 * hwmods with HWMOD_INIT_NO_IDLE flag set are left in enabled
-	 * state at init.  Now that someone is really trying to enable
-	 * them, just ensure that the hwmod mux is set.
+	 * state at init.
 	 */
 	if (oh->_int_flags & _HWMOD_SKIP_ENABLE) {
-		/*
-		 * If the caller has mux data populated, do the mux'ing
-		 * which wouldn't have been done as part of the _enable()
-		 * done during setup.
-		 */
-		if (oh->mux)
-			omap_hwmod_mux(oh->mux, _HWMOD_STATE_ENABLED);
-
 		oh->_int_flags &= ~_HWMOD_SKIP_ENABLE;
 		return 0;
 	}
@@ -2145,16 +2064,6 @@ static int _enable(struct omap_hwmod *oh)
 	if (_are_all_hardreset_lines_asserted(oh))
 		return 0;
 
-	/* Mux pins for device runtime if populated */
-	if (oh->mux && (!oh->mux->enabled ||
-			((oh->_state == _HWMOD_STATE_IDLE) &&
-			 oh->mux->pads_dynamic))) {
-		omap_hwmod_mux(oh->mux, _HWMOD_STATE_ENABLED);
-		_reconfigure_io_chain();
-	} else if (oh->flags & HWMOD_RECONFIG_IO_CHAIN) {
-		_reconfigure_io_chain();
-	}
-
 	_add_initiator_dep(oh, mpu_oh);
 
 	if (oh->clkdm) {
@@ -2260,14 +2169,6 @@ static int _idle(struct omap_hwmod *oh)
 		clkdm_hwmod_disable(oh->clkdm, oh);
 	}
 
-	/* Mux pins for device idle if populated */
-	if (oh->mux && oh->mux->pads_dynamic) {
-		omap_hwmod_mux(oh->mux, _HWMOD_STATE_IDLE);
-		_reconfigure_io_chain();
-	} else if (oh->flags & HWMOD_RECONFIG_IO_CHAIN) {
-		_reconfigure_io_chain();
-	}
-
 	oh->_state = _HWMOD_STATE_IDLE;
 
 	return 0;
@@ -2334,10 +2235,6 @@ static int _shutdown(struct omap_hwmod *oh)
 	for (i = 0; i < oh->rst_lines_cnt; i++)
 		_assert_hardreset(oh, oh->rst_lines[i].name);
 
-	/* Mux pins to safe mode or use populated off mode values */
-	if (oh->mux)
-		omap_hwmod_mux(oh->mux, _HWMOD_STATE_DISABLED);
-
 	oh->_state = _HWMOD_STATE_DISABLED;
 
 	return 0;
@@ -3729,7 +3626,6 @@ int omap_hwmod_enable_wakeup(struct omap_hwmod *oh)
 		_write_sysconfig(v, oh);
 	}
 
-	_set_idle_ioring_wakeup(oh, true);
 	spin_unlock_irqrestore(&oh->_lock, flags);
 
 	return 0;
@@ -3762,7 +3658,6 @@ int omap_hwmod_disable_wakeup(struct omap_hwmod *oh)
 		_write_sysconfig(v, oh);
 	}
 
-	_set_idle_ioring_wakeup(oh, false);
 	spin_unlock_irqrestore(&oh->_lock, flags);
 
 	return 0;

commit 428929c79cc3de7f9fefd2184da6ed625676ad9e
Author: Dave Gerlach <d-gerlach@ti.com>
Date:   Tue Jul 12 12:50:33 2016 -0500

    ARM: OMAP4+: Have _omap4_wait_target_* check for valid clkctrl_offs
    
    Previously the low-level CM call internal to the
    _omap4_wait_target_ready/disable calls was responsible for checking for
    a valid clkctrl_offs. Now we must also consider the value of the
    prcm.omap4.flags because if HWMOD_OMAP4_ZERO_CLKCTRL_OFFSET is set in
    the flags then clkctrl_offs of 0 is valid.
    
    Let's add this check into the _omap4_wait_target_ready/disable where we
    have access to both the clkctrl_offs and the flags values and simply
    return 0 without calling the low level CM call at all, which would have
    returned 0 anyway if the clktrl_offs was zero.
    
    Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 5b709383381c..1052b29697b8 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1053,6 +1053,10 @@ static int _omap4_wait_target_disable(struct omap_hwmod *oh)
 	if (oh->flags & HWMOD_NO_IDLEST)
 		return 0;
 
+	if (!oh->prcm.omap4.clkctrl_offs &&
+	    !(oh->prcm.omap4.flags & HWMOD_OMAP4_ZERO_CLKCTRL_OFFSET))
+		return 0;
+
 	return omap_cm_wait_module_idle(oh->clkdm->prcm_partition,
 					oh->clkdm->cm_inst,
 					oh->prcm.omap4.clkctrl_offs, 0);
@@ -2971,6 +2975,10 @@ static int _omap4_wait_target_ready(struct omap_hwmod *oh)
 	if (!_find_mpu_rt_port(oh))
 		return 0;
 
+	if (!oh->prcm.omap4.clkctrl_offs &&
+	    !(oh->prcm.omap4.flags & HWMOD_OMAP4_ZERO_CLKCTRL_OFFSET))
+		return 0;
+
 	/* XXX check module SIDLEMODE, hardreset status */
 
 	return omap_cm_wait_module_ready(oh->clkdm->prcm_partition,

commit 1d9a5425654de6bb141c7ca1d5dde120ee8c5430
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Jun 30 16:15:02 2016 +0300

    ARM: OMAP2+: clockdomain: add usecounting support to autoidle APIs
    
    The previous implementation was racy in many locations, where the current
    status of the clockdomain was read out, some operations were executed,
    and the previous status info was used afterwards to decide next state
    for the clockdomain. Instead, fix the implementation of the allow_idle /
    deny_idle APIs to properly have usecounting support. This allows clean
    handling internally within the clockdomain core, and simplifies the
    usage also within hwmod.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 201da9158d7b..5b709383381c 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1702,7 +1702,6 @@ static int _deassert_hardreset(struct omap_hwmod *oh, const char *name)
 {
 	struct omap_hwmod_rst_info ohri;
 	int ret = -EINVAL;
-	int hwsup = 0;
 
 	if (!oh)
 		return -EINVAL;
@@ -1720,7 +1719,7 @@ static int _deassert_hardreset(struct omap_hwmod *oh, const char *name)
 		 * might not be completed. The clockdomain can be set
 		 * in HW_AUTO only when the module become ready.
 		 */
-		hwsup = clkdm_in_hwsup(oh->clkdm);
+		clkdm_deny_idle(oh->clkdm);
 		ret = clkdm_hwmod_enable(oh->clkdm, oh);
 		if (ret) {
 			WARN(1, "omap_hwmod: %s: could not enable clockdomain %s: %d\n",
@@ -1747,8 +1746,7 @@ static int _deassert_hardreset(struct omap_hwmod *oh, const char *name)
 		 * Set the clockdomain to HW_AUTO, assuming that the
 		 * previous state was HW_AUTO.
 		 */
-		if (hwsup)
-			clkdm_allow_idle(oh->clkdm);
+		clkdm_allow_idle(oh->clkdm);
 
 		clkdm_hwmod_disable(oh->clkdm, oh);
 	}
@@ -2102,7 +2100,6 @@ static int _enable_preprogram(struct omap_hwmod *oh)
 static int _enable(struct omap_hwmod *oh)
 {
 	int r;
-	int hwsup = 0;
 
 	pr_debug("omap_hwmod: %s: enabling\n", oh->name);
 
@@ -2162,8 +2159,7 @@ static int _enable(struct omap_hwmod *oh)
 		 * completely the module. The clockdomain can be set
 		 * in HW_AUTO only when the module become ready.
 		 */
-		hwsup = clkdm_in_hwsup(oh->clkdm) &&
-			!clkdm_missing_idle_reporting(oh->clkdm);
+		clkdm_deny_idle(oh->clkdm);
 		r = clkdm_hwmod_enable(oh->clkdm, oh);
 		if (r) {
 			WARN(1, "omap_hwmod: %s: could not enable clockdomain %s: %d\n",
@@ -2183,14 +2179,10 @@ static int _enable(struct omap_hwmod *oh)
 
 	r = (soc_ops.wait_target_ready) ? soc_ops.wait_target_ready(oh) :
 		-EINVAL;
-	if (!r) {
-		/*
-		 * Set the clockdomain to HW_AUTO only if the target is ready,
-		 * assuming that the previous state was HW_AUTO
-		 */
-		if (oh->clkdm && hwsup)
-			clkdm_allow_idle(oh->clkdm);
+	if (oh->clkdm)
+		clkdm_allow_idle(oh->clkdm);
 
+	if (!r) {
 		oh->_state = _HWMOD_STATE_ENABLED;
 
 		/* Access the sysconfig only if the target is ready */
@@ -2244,6 +2236,9 @@ static int _idle(struct omap_hwmod *oh)
 		_idle_sysc(oh);
 	_del_initiator_dep(oh, mpu_oh);
 
+	if (oh->clkdm)
+		clkdm_deny_idle(oh->clkdm);
+
 	if (oh->flags & HWMOD_BLOCK_WFI)
 		cpu_idle_poll_ctrl(false);
 	if (soc_ops.disable_module)
@@ -2256,8 +2251,10 @@ static int _idle(struct omap_hwmod *oh)
 	 * transition to complete properly.
 	 */
 	_disable_clocks(oh);
-	if (oh->clkdm)
+	if (oh->clkdm) {
+		clkdm_allow_idle(oh->clkdm);
 		clkdm_hwmod_disable(oh->clkdm, oh);
+	}
 
 	/* Mux pins for device idle if populated */
 	if (oh->mux && oh->mux->pads_dynamic) {

commit 9fabc1a26e37f88cb19d5def300970a26604d9a4
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Jul 4 14:11:48 2016 +0300

    ARM: OMAP2+: hwmod: fetch main_clk based on hwmod name
    
    With the transition to hwmod module clocks, all hwmods will have
    their main clocks named <hwmod_name>_mod_ck. Use this info to
    fetch main_clk, and use it if found.
    
    Also, if a main_clk is found based on the hwmod name, disable
    the direct PRCM modulemode access from hwmod.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 83cb527755a9..201da9158d7b 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -178,6 +178,11 @@
  */
 #define OMAP4_RST_CTRL_ST_OFFSET	4
 
+/*
+ * Maximum length for module clock handle names
+ */
+#define MOD_CLK_MAX_NAME_LEN		32
+
 /**
  * struct omap_hwmod_soc_ops - fn ptrs for some SoC-specific operations
  * @enable_module: function to enable a module (via MODULEMODE)
@@ -200,6 +205,7 @@ struct omap_hwmod_soc_ops {
 	int (*init_clkdm)(struct omap_hwmod *oh);
 	void (*update_context_lost)(struct omap_hwmod *oh);
 	int (*get_context_lost)(struct omap_hwmod *oh);
+	int (*disable_direct_prcm)(struct omap_hwmod *oh);
 };
 
 /* soc_ops: adapts the omap_hwmod code to the currently-booted SoC */
@@ -776,17 +782,35 @@ static int _del_initiator_dep(struct omap_hwmod *oh, struct omap_hwmod *init_oh)
  * @oh: struct omap_hwmod *
  *
  * Called from _init_clocks().  Populates the @oh _clk (main
- * functional clock pointer) if a main_clk is present.  Returns 0 on
- * success or -EINVAL on error.
+ * functional clock pointer) if a clock matching the hwmod name is found,
+ * or a main_clk is present.  Returns 0 on success or -EINVAL on error.
  */
 static int _init_main_clk(struct omap_hwmod *oh)
 {
 	int ret = 0;
+	char name[MOD_CLK_MAX_NAME_LEN];
+	struct clk *clk;
 
-	if (!oh->main_clk)
-		return 0;
+	/* +7 magic comes from '_mod_ck' suffix */
+	if (strlen(oh->name) + 7 > MOD_CLK_MAX_NAME_LEN)
+		pr_warn("%s: warning: cropping name for %s\n", __func__,
+			oh->name);
+
+	strncpy(name, oh->name, MOD_CLK_MAX_NAME_LEN - 7);
+	strcat(name, "_mod_ck");
+
+	clk = clk_get(NULL, name);
+	if (!IS_ERR(clk)) {
+		oh->_clk = clk;
+		soc_ops.disable_direct_prcm(oh);
+		oh->main_clk = kstrdup(name, GFP_KERNEL);
+	} else {
+		if (!oh->main_clk)
+			return 0;
+
+		oh->_clk = clk_get(NULL, oh->main_clk);
+	}
 
-	oh->_clk = clk_get(NULL, oh->main_clk);
 	if (IS_ERR(oh->_clk)) {
 		pr_warn("omap_hwmod: %s: cannot clk_get main_clk %s\n",
 			oh->name, oh->main_clk);
@@ -3090,6 +3114,25 @@ static int _omap4_is_hardreset_asserted(struct omap_hwmod *oh,
 					      oh->prcm.omap4.rstctrl_offs);
 }
 
+/**
+ * _omap4_disable_direct_prcm - disable direct PRCM control for hwmod
+ * @oh: struct omap_hwmod * to disable control for
+ *
+ * Disables direct PRCM clkctrl done by hwmod core. Instead, the hwmod
+ * will be using its main_clk to enable/disable the module. Returns
+ * 0 if successful.
+ */
+static int _omap4_disable_direct_prcm(struct omap_hwmod *oh)
+{
+	if (!oh)
+		return -EINVAL;
+
+	oh->prcm.omap4.clkctrl_offs = 0;
+	oh->prcm.omap4.modulemode = 0;
+
+	return 0;
+}
+
 /**
  * _am33xx_deassert_hardreset - call AM33XX PRM hardreset fn with hwmod args
  * @oh: struct omap_hwmod * to deassert hardreset
@@ -3913,6 +3956,7 @@ void __init omap_hwmod_init(void)
 		soc_ops.init_clkdm = _init_clkdm;
 		soc_ops.update_context_lost = _omap4_update_context_lost;
 		soc_ops.get_context_lost = _omap4_get_context_lost;
+		soc_ops.disable_direct_prcm = _omap4_disable_direct_prcm;
 	} else if (cpu_is_ti814x() || cpu_is_ti816x() || soc_is_am33xx() ||
 		   soc_is_am43xx()) {
 		soc_ops.enable_module = _omap4_enable_module;
@@ -3922,6 +3966,7 @@ void __init omap_hwmod_init(void)
 		soc_ops.deassert_hardreset = _am33xx_deassert_hardreset;
 		soc_ops.is_hardreset_asserted = _omap4_is_hardreset_asserted;
 		soc_ops.init_clkdm = _init_clkdm;
+		soc_ops.disable_direct_prcm = _omap4_disable_direct_prcm;
 	} else {
 		WARN(1, "omap_hwmod: unknown SoC type\n");
 	}

commit c20c8f750d9f8f8617f07ee2352d3ff560e66bc2
Author: Suman Anna <s-anna@ti.com>
Date:   Sun Apr 10 13:20:11 2016 -0600

    ARM: OMAP2+: hwmod: fix _idle() hwmod state sanity check sequence
    
    The omap_hwmod _enable() function can return success without setting
    the hwmod state to _HWMOD_STATE_ENABLED for IPs with reset lines when
    all of the reset lines are asserted. The omap_hwmod _idle() function
    also performs a similar check, but after checking for the hwmod state
    first. This triggers the WARN when pm_runtime_get and pm_runtime_put
    are invoked on IPs with all reset lines asserted. Reverse the checks
    for hwmod state and reset lines status to fix this.
    
    Issue found during a unbind operation on a device with reset lines
    still asserted, example backtrace below
    
     ------------[ cut here ]------------
     WARNING: CPU: 1 PID: 879 at arch/arm/mach-omap2/omap_hwmod.c:2207 _idle+0x1e4/0x240()
     omap_hwmod: mmu_dsp: idle state can only be entered from enabled state
     Modules linked in:
     CPU: 1 PID: 879 Comm: sh Not tainted 4.4.0-00008-ga989d951331a #3
     Hardware name: Generic OMAP5 (Flattened Device Tree)
     [<c0018e60>] (unwind_backtrace) from [<c0014dc4>] (show_stack+0x10/0x14)
     [<c0014dc4>] (show_stack) from [<c037ac28>] (dump_stack+0x90/0xc0)
     [<c037ac28>] (dump_stack) from [<c003f420>] (warn_slowpath_common+0x78/0xb4)
     [<c003f420>] (warn_slowpath_common) from [<c003f48c>] (warn_slowpath_fmt+0x30/0x40)
     [<c003f48c>] (warn_slowpath_fmt) from [<c0028c20>] (_idle+0x1e4/0x240)
     [<c0028c20>] (_idle) from [<c0029080>] (omap_hwmod_idle+0x28/0x48)
     [<c0029080>] (omap_hwmod_idle) from [<c002a5a4>] (omap_device_idle+0x3c/0x90)
     [<c002a5a4>] (omap_device_idle) from [<c0427a90>] (__rpm_callback+0x2c/0x60)
     [<c0427a90>] (__rpm_callback) from [<c0427ae4>] (rpm_callback+0x20/0x80)
     [<c0427ae4>] (rpm_callback) from [<c0427f84>] (rpm_suspend+0x138/0x74c)
     [<c0427f84>] (rpm_suspend) from [<c0428b78>] (__pm_runtime_idle+0x78/0xa8)
     [<c0428b78>] (__pm_runtime_idle) from [<c041f514>] (__device_release_driver+0x64/0x100)
     [<c041f514>] (__device_release_driver) from [<c041f5d0>] (device_release_driver+0x20/0x2c)
     [<c041f5d0>] (device_release_driver) from [<c041d85c>] (unbind_store+0x78/0xf8)
     [<c041d85c>] (unbind_store) from [<c0206df8>] (kernfs_fop_write+0xc0/0x1c4)
     [<c0206df8>] (kernfs_fop_write) from [<c018a120>] (__vfs_write+0x20/0xdc)
     [<c018a120>] (__vfs_write) from [<c018a9cc>] (vfs_write+0x90/0x164)
     [<c018a9cc>] (vfs_write) from [<c018b1f0>] (SyS_write+0x44/0x9c)
     [<c018b1f0>] (SyS_write) from [<c0010420>] (ret_fast_syscall+0x0/0x1c)
     ---[ end trace a4182013c75a9f50 ]---
    
    While at this, fix the sequence in _shutdown() as well, though there
    is no easy reproducible scenario.
    
    Fixes: 747834ab8347 ("ARM: OMAP2+: hwmod: revise hardreset behavior")
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 2af6ff63e3b4..83cb527755a9 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2207,15 +2207,15 @@ static int _idle(struct omap_hwmod *oh)
 
 	pr_debug("omap_hwmod: %s: idling\n", oh->name);
 
+	if (_are_all_hardreset_lines_asserted(oh))
+		return 0;
+
 	if (oh->_state != _HWMOD_STATE_ENABLED) {
 		WARN(1, "omap_hwmod: %s: idle state can only be entered from enabled state\n",
 			oh->name);
 		return -EINVAL;
 	}
 
-	if (_are_all_hardreset_lines_asserted(oh))
-		return 0;
-
 	if (oh->class->sysc)
 		_idle_sysc(oh);
 	_del_initiator_dep(oh, mpu_oh);
@@ -2262,6 +2262,9 @@ static int _shutdown(struct omap_hwmod *oh)
 	int ret, i;
 	u8 prev_state;
 
+	if (_are_all_hardreset_lines_asserted(oh))
+		return 0;
+
 	if (oh->_state != _HWMOD_STATE_IDLE &&
 	    oh->_state != _HWMOD_STATE_ENABLED) {
 		WARN(1, "omap_hwmod: %s: disabled state can only be entered from idle, or enabled state\n",
@@ -2269,9 +2272,6 @@ static int _shutdown(struct omap_hwmod *oh)
 		return -EINVAL;
 	}
 
-	if (_are_all_hardreset_lines_asserted(oh))
-		return 0;
-
 	pr_debug("omap_hwmod: %s: disabling\n", oh->name);
 
 	if (oh->class->pre_shutdown) {

commit 3ca4a238106dedc285193ee47f494a6584b6fd2f
Author: Lokesh Vutla <lokeshvutla@ti.com>
Date:   Sat Mar 26 23:08:55 2016 -0600

    ARM: OMAP2+: hwmod: Fix updating of sysconfig register
    
    Commit 127500ccb766f ("ARM: OMAP2+: Only write the sysconfig on idle
    when necessary") talks about verification of sysconfig cache value before
    updating it, only during idle path. But the patch is adding the
    verification in the enable path. So, adding the check in a proper place
    as per the commit description.
    
    Not keeping this check during enable path as there is a chance of losing
    context and it is safe to do on idle as the context of the register will
    never be lost while the device is active.
    
    Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Cc: Jon Hunter <jonathanh@nvidia.com>
    Cc: <stable@vger.kernel.org> # 3.12+
    Fixes: commit 127500ccb766 "ARM: OMAP2+: Only write the sysconfig on idle when necessary"
    [paul@pwsan.com: appears to have been caused by my own mismerge of the
     originally posted patch]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index b6d62e4cdfdd..2af6ff63e3b4 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1416,9 +1416,7 @@ static void _enable_sysc(struct omap_hwmod *oh)
 	    (sf & SYSC_HAS_CLOCKACTIVITY))
 		_set_clockactivity(oh, oh->class->sysc->clockact, &v);
 
-	/* If the cached value is the same as the new value, skip the write */
-	if (oh->_sysc_cache != v)
-		_write_sysconfig(v, oh);
+	_write_sysconfig(v, oh);
 
 	/*
 	 * Set the autoidle bit only after setting the smartidle bit
@@ -1481,7 +1479,9 @@ static void _idle_sysc(struct omap_hwmod *oh)
 		_set_master_standbymode(oh, idlemode, &v);
 	}
 
-	_write_sysconfig(v, oh);
+	/* If the cached value is the same as the new value, skip the write */
+	if (oh->_sysc_cache != v)
+		_write_sysconfig(v, oh);
 }
 
 /**

commit 2e18f5a1bc18e8af7031b3b26efde25307014837
Author: Lokesh Vutla <lokeshvutla@ti.com>
Date:   Mon Mar 7 01:41:21 2016 -0700

    ARM: OMAP2+: hwmod: Introduce ti,no-idle dt property
    
    Introduce a dt property, ti,no-idle, that prevents an IP to idle at any
    point. This is to handle Errata i877, which tells that GMAC clocks
    cannot be disabled.
    
    Acked-by: Roger Quadros <rogerq@ti.com>
    Tested-by: Mugunthan V N <mugunthanvnm@ti.com>
    Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
    Signed-off-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index e9f65fec55c0..b6d62e4cdfdd 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2200,6 +2200,11 @@ static int _enable(struct omap_hwmod *oh)
  */
 static int _idle(struct omap_hwmod *oh)
 {
+	if (oh->flags & HWMOD_NO_IDLE) {
+		oh->_int_flags |= _HWMOD_SKIP_ENABLE;
+		return 0;
+	}
+
 	pr_debug("omap_hwmod: %s: idling\n", oh->name);
 
 	if (oh->_state != _HWMOD_STATE_ENABLED) {
@@ -2504,6 +2509,8 @@ static int __init _init(struct omap_hwmod *oh, void *data)
 			oh->flags |= HWMOD_INIT_NO_RESET;
 		if (of_find_property(np, "ti,no-idle-on-init", NULL))
 			oh->flags |= HWMOD_INIT_NO_IDLE;
+		if (of_find_property(np, "ti,no-idle", NULL))
+			oh->flags |= HWMOD_NO_IDLE;
 	}
 
 	oh->_state = _HWMOD_STATE_INITIALIZED;
@@ -2630,7 +2637,7 @@ static void __init _setup_postsetup(struct omap_hwmod *oh)
 	 * XXX HWMOD_INIT_NO_IDLE does not belong in hwmod data -
 	 * it should be set by the core code as a runtime flag during startup
 	 */
-	if ((oh->flags & HWMOD_INIT_NO_IDLE) &&
+	if ((oh->flags & (HWMOD_INIT_NO_IDLE | HWMOD_NO_IDLE)) &&
 	    (postsetup_state == _HWMOD_STATE_IDLE)) {
 		oh->_int_flags |= _HWMOD_SKIP_ENABLE;
 		postsetup_state = _HWMOD_STATE_ENABLED;

commit 45e2916be242ccf50cdc6da7863245722a46ea9e
Merge: 8907dbaa363d f2e6a0a913b5
Author: Olof Johansson <olof@lixom.net>
Date:   Tue Dec 22 14:49:17 2015 -0800

    Merge tag 'omap-for-v4.5/soc-initcall' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into next/soc
    
    SoC changes for omaps for v4.5 merge window. The main change here is to
    change the omap initcall levels a bit to initialize things later to allow
    early device drivers at core_initcall level. This makes things easier
    for us as most clocks can be made into regular device drivers except for
    a few early clocks needed to initialize system timers. I wanted to have
    these changes sit in Linux next for a few weeks before sending out a pull
    request, and so far now issues have showed up.
    
    The other changes in this series are timer changes for making use of the
    new PWM driver, and timer changes to support more high security SoCs.
    Also few minor improvments for module autoidle settings for ti81xx spinbox
    and dra7 debug on uart4 in hwmod code. The rest is pretty much just removal
    of platform data for SoCs that are all device tree only nowadays.
    
    * tag 'omap-for-v4.5/soc-initcall' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap:
      ARM: OMAP2+: Remove device creation for omap-pcm-audio
      ARM: OMAP1: Remove device creation for omap-pcm-audio
      ARM: OMAP2+: Change core_initcall levels to postcore_initcall
      ARM: DRA7: hwmod: Enable DEBUG_LL for UART4
      ARM: OMAP: RX-51: fix a typo in log writing
      ARM: omap4: hwmod: Remove elm address space from hwmod data
      ARM: OMAP2+: timer: Remove secure timer for DRA7xx HS devices
      ARM: OMAP: dmtimer: check for fixed timers during config
      ARM: OMAP2+: Remove omap_mmu_dev_attr structure
      ARM: OMAP4: hwmod data: Remove legacy IOMMU attr and addrs
      ARM: OMAP3: hwmod data: Remove legacy IOMMU data
      ARM: OMAP2+: Remove legacy device instantiation of IOMMUs
      ARM: OMAP2+: Add hwmod spinbox support for dm816x
      ARM: OMAP: add DT support for ti,dm816-timer
      ARM: OMAP: dmtimer: Add clock source from DT
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 8dd5ea72b0c0dbcdb5d629247ac7ead49c6a9c58
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Dec 3 11:38:09 2015 -0800

    ARM: OMAP2+: Change core_initcall levels to postcore_initcall
    
    We want to be able to probe a few selected device drivers before hwmod
    code populates the clocks in omap_hwmod_setup_all(). This allows us to
    convert most of the clock drivers into regular device drivers.
    
    We only need a few minimal clock drivers early for the system timers to
    select between the 32KiHz clock and the high frequency oscillator.
    
    With these changes, initializing the clock drivers can be just done at
    core_initcall time with something like:
    
    np = of_find_node_by_name(NULL, "plls");
    if (np)
            of_platform_populate(np, NULL, NULL, NULL);
    
    And then these clocks will be available for the interconnect code to use.
    
    Having most of the clock drivers being regular device drivers allows
    us to use the nice things like devm_* functions and dev_err and dev_dbg.
    As an extra bonus, this also allows us to develop the clock drivers for
    new SoCs as loadable modules initially for cases where we can boot up
    the system based on the bootloader configured clocks.
    
    To do this, let's change the core_initcalls to postcore_initcall under
    mach-omap2.
    
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index cc8a987149e2..49d537641370 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3307,7 +3307,7 @@ static int __init omap_hwmod_setup_all(void)
 
 	return 0;
 }
-omap_core_initcall(omap_hwmod_setup_all);
+omap_postcore_initcall(omap_hwmod_setup_all);
 
 /**
  * omap_hwmod_enable - enable an omap_hwmod

commit c12ba8ce2335389ce5416f88391cd67c7325c963
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Nov 12 09:32:58 2015 +0200

    ARM: OMAP2+: hwmod: Add hwmod flag for HWMOD_OPT_CLKS_NEEDED
    
    Some module needs more than one functional clock in order to be accessible,
    like the McASPs found in DRA7xx family.
    This flag will indicate that the opt_clks need to be handled at the same
    time as the main_clk for the given hwmod, ensuring that all needed clocks
    are enabled before we try to access the module's address space.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index cc8a987149e2..48495ad82aba 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -890,6 +890,36 @@ static int _init_opt_clks(struct omap_hwmod *oh)
 	return ret;
 }
 
+static void _enable_optional_clocks(struct omap_hwmod *oh)
+{
+	struct omap_hwmod_opt_clk *oc;
+	int i;
+
+	pr_debug("omap_hwmod: %s: enabling optional clocks\n", oh->name);
+
+	for (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++)
+		if (oc->_clk) {
+			pr_debug("omap_hwmod: enable %s:%s\n", oc->role,
+				 __clk_get_name(oc->_clk));
+			clk_enable(oc->_clk);
+		}
+}
+
+static void _disable_optional_clocks(struct omap_hwmod *oh)
+{
+	struct omap_hwmod_opt_clk *oc;
+	int i;
+
+	pr_debug("omap_hwmod: %s: disabling optional clocks\n", oh->name);
+
+	for (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++)
+		if (oc->_clk) {
+			pr_debug("omap_hwmod: disable %s:%s\n", oc->role,
+				 __clk_get_name(oc->_clk));
+			clk_disable(oc->_clk);
+		}
+}
+
 /**
  * _enable_clocks - enable hwmod main clock and interface clocks
  * @oh: struct omap_hwmod *
@@ -917,6 +947,9 @@ static int _enable_clocks(struct omap_hwmod *oh)
 			clk_enable(os->_clk);
 	}
 
+	if (oh->flags & HWMOD_OPT_CLKS_NEEDED)
+		_enable_optional_clocks(oh);
+
 	/* The opt clocks are controlled by the device driver. */
 
 	return 0;
@@ -948,41 +981,14 @@ static int _disable_clocks(struct omap_hwmod *oh)
 			clk_disable(os->_clk);
 	}
 
+	if (oh->flags & HWMOD_OPT_CLKS_NEEDED)
+		_disable_optional_clocks(oh);
+
 	/* The opt clocks are controlled by the device driver. */
 
 	return 0;
 }
 
-static void _enable_optional_clocks(struct omap_hwmod *oh)
-{
-	struct omap_hwmod_opt_clk *oc;
-	int i;
-
-	pr_debug("omap_hwmod: %s: enabling optional clocks\n", oh->name);
-
-	for (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++)
-		if (oc->_clk) {
-			pr_debug("omap_hwmod: enable %s:%s\n", oc->role,
-				 __clk_get_name(oc->_clk));
-			clk_enable(oc->_clk);
-		}
-}
-
-static void _disable_optional_clocks(struct omap_hwmod *oh)
-{
-	struct omap_hwmod_opt_clk *oc;
-	int i;
-
-	pr_debug("omap_hwmod: %s: disabling optional clocks\n", oh->name);
-
-	for (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++)
-		if (oc->_clk) {
-			pr_debug("omap_hwmod: disable %s:%s\n", oc->role,
-				 __clk_get_name(oc->_clk));
-			clk_disable(oc->_clk);
-		}
-}
-
 /**
  * _omap4_enable_module - enable CLKCTRL modulemode on OMAP4
  * @oh: struct omap_hwmod *

commit 50686e8a3aed2f5d295e9d2e79ff43df461c7b76
Merge: c5fc249862af 1ec6f701707e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 1 12:18:40 2015 -0700

    Merge tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform updates from Olof Johansson:
     "New or improved SoC support:
    
       - add support for Atmel's SAMA5D2 SoC
       - add support for Freescale i.MX6UL
       - improved support for TI's DM814x platform
       - misc fixes and improvements for RockChip platforms
       - Marvell MVEBU suspend/resume support
    
      A few driver changes that ideally would belong in the drivers branch
      are also here (acked by appropriate maintainers):
    
       - power key input driver for Freescale platforms (svns)
       - RTC driver updates for Freescale platforms (svns/mxc)
       - clk fixes for TI DM814/816X
    
      + a bunch of other changes for various platforms"
    
    * tag 'armsoc-soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (83 commits)
      ARM: rockchip: pm: Fix PTR_ERR() argument
      ARM: imx: mach-imx6ul: Fix allmodconfig build
      clk: ti: fix for definition movement
      ARM: uniphier: drop v7_invalidate_l1 call at secondary entry
      memory: kill off set_irq_flags usage
      rtc: snvs: select option REGMAP_MMIO
      ARM: brcmstb: select ARCH_DMA_ADDR_T_64BIT for LPAE
      ARM: BCM: Enable ARM erratum 798181 for BRCMSTB
      ARM: OMAP2+: Fix power domain operations regression caused by 81xx
      ARM: rockchip: enable PMU_GPIOINT_WAKEUP_EN when entering shallow suspend
      ARM: rockchip: set correct stabilization thresholds in suspend
      ARM: rockchip: rename osc_switch_to_32k variable
      ARM: imx6ul: add fec MAC refrence clock and phy fixup init
      ARM: imx6ul: add fec bits to GPR syscon definition
      rtc: mxc: add support of device tree
      dt-binding: document the binding for mxc rtc
      rtc: mxc: use a second rtc clock
      ARM: davinci: cp_intc: use IRQCHIP_SKIP_SET_WAKE instead of irq_set_wake callback
      soc: mediatek: Fix SCPSYS compilation
      ARM: at91/soc: add basic support for new sama5d2 SoC
      ...

commit f36fc04e4cdda9e4c72ee504e7dc638f9a168863
Merge: 26f8b7edc9ea ba3001157733
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 31 17:26:48 2015 -0700

    Merge tag 'clk-for-linus-4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux
    
    Pull clk updates from Michael Turquette:
     "The clk framework changes for 4.3 are mostly updates to existing
      drivers and the addition of new clock drivers.  Stephen Boyd has also
      done a lot of subsystem-wide driver clean-ups (thanks!).  There are
      also fixes to the framework core and changes to better split clock
      provider drivers from clock consumer drivers"
    
    * tag 'clk-for-linus-4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/clk/linux: (227 commits)
      clk: s5pv210: add missing call to samsung_clk_of_add_provider()
      clk: pistachio: correct critical clock list
      clk: pistachio: Fix PLL rate calculation in integer mode
      clk: pistachio: Fix override of clk-pll settings from boot loader
      clk: pistachio: Fix 32bit integer overflows
      clk: tegra: Fix some static checker problems
      clk: qcom: Fix MSM8916 prng clock enable bit
      clk: Add missing header for 'bool' definition to clk-conf.h
      drivers/clk: appropriate __init annotation for const data
      clk: rockchip: register pll mux before pll itself
      clk: add bindings for the Ux500 clocks
      clk/ARM: move Ux500 PRCC bases to the device tree
      clk: remove duplicated code with __clk_set_parent_after
      clk: Convert __clk_get_name(hw->clk) to clk_hw_get_name(hw)
      clk: Constify clk_hw argument to provider APIs
      clk: Hi6220: add stub clock driver
      dt-bindings: clk: Hi6220: Document stub clock driver
      dt-bindings: arm: Hi6220: add doc for SRAM controller
      clk: atlas7: fix pll missed divide NR in fraction mode
      clk: atlas7: fix bit field and its root clk for coresight_tpiu
      ...

commit 24da741c678f865de3182194604dbddcc7fc7f3c
Merge: 97d9a3d0967f 0f3ccb24c034
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Jul 23 21:59:18 2015 -0700

    Merge branch 'dm814x-soc' into omap-for-v4.3/soc
    
    Update dm814x changes for sparse fixes to make data structures
    static.
    
    Conflicts:
            arch/arm/mach-omap2/omap_hwmod_81xx_data.c

commit 0f3ccb24c0347cd80160810df79bfa233749074e
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Jul 16 01:55:58 2015 -0700

    ARM: OMAP2: Add minimal dm814x hwmod support
    
    Let's add minimal set of dm814x hwmods to have a bootable system.
    
    Cc: Matthijs van Duin <matthijsvanduin@gmail.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index d78c12e7cb5e..33033ff80ee7 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3878,7 +3878,8 @@ void __init omap_hwmod_init(void)
 		soc_ops.init_clkdm = _init_clkdm;
 		soc_ops.update_context_lost = _omap4_update_context_lost;
 		soc_ops.get_context_lost = _omap4_get_context_lost;
-	} else if (cpu_is_ti816x() || soc_is_am33xx() || soc_is_am43xx()) {
+	} else if (cpu_is_ti814x() || cpu_is_ti816x() || soc_is_am33xx() ||
+		   soc_is_am43xx()) {
 		soc_ops.enable_module = _omap4_enable_module;
 		soc_ops.disable_module = _omap4_disable_module;
 		soc_ops.wait_target_ready = _omap4_wait_target_ready;

commit 9a258afa928b45e6dd2efcac46ccf7eea705d35a
Author: Roger Quadros <rogerq@ti.com>
Date:   Thu Jul 16 16:16:44 2015 +0300

    ARM: OMAP2+: hwmod: Fix _wait_target_ready() for hwmods without sysc
    
    For hwmods without sysc, _init_mpu_rt_base(oh) won't be called and so
    _find_mpu_rt_port(oh) will return NULL thus preventing ready state check
    on those modules after the module is enabled.
    
    This can potentially cause a bus access error if the module is accessed
    before the module is ready.
    
    Fix this by unconditionally calling _init_mpu_rt_base() during hwmod
    _init(). Do ioremap only if we need SYSC access.
    
    Eventhough _wait_target_ready() check doesn't really need MPU RT port but
    just the PRCM registers, we still mandate that the hwmod must have an
    MPU RT port if ready state check needs to be done. Else it would mean that
    the module is not accessible by MPU so there is no point in waiting
    for target to be ready.
    
    e.g. this fixes the below DCAN bus access error on AM437x-gp-evm.
    
    [   16.672978] ------------[ cut here ]------------
    [   16.677885] WARNING: CPU: 0 PID: 1580 at drivers/bus/omap_l3_noc.c:147 l3_interrupt_handler+0x234/0x35c()
    [   16.687946] 44000000.ocp:L3 Custom Error: MASTER M2 (64-bit) TARGET L4_PER_0 (Read): Data Access in User mode during Functional access
    [   16.700654] Modules linked in: xhci_hcd btwilink ti_vpfe dwc3 videobuf2_core ov2659 bluetooth v4l2_common videodev ti_am335x_adc kfifo_buf industrialio c_can_platform videobuf2_dma_contig media snd_soc_tlv320aic3x pixcir_i2c_ts c_can dc
    [   16.731144] CPU: 0 PID: 1580 Comm: rpc.statd Not tainted 3.14.26-02561-gf733aa036398 #180
    [   16.739747] Backtrace:
    [   16.742336] [<c0011108>] (dump_backtrace) from [<c00112a4>] (show_stack+0x18/0x1c)
    [   16.750285]  r6:00000093 r5:00000009 r4:eab5b8a8 r3:00000000
    [   16.756252] [<c001128c>] (show_stack) from [<c05a4418>] (dump_stack+0x20/0x28)
    [   16.763870] [<c05a43f8>] (dump_stack) from [<c0037120>] (warn_slowpath_common+0x6c/0x8c)
    [   16.772408] [<c00370b4>] (warn_slowpath_common) from [<c00371e4>] (warn_slowpath_fmt+0x38/0x40)
    [   16.781550]  r8:c05d1f90 r7:c0730844 r6:c0730448 r5:80080003 r4:ed0cd210
    [   16.788626] [<c00371b0>] (warn_slowpath_fmt) from [<c027fa94>] (l3_interrupt_handler+0x234/0x35c)
    [   16.797968]  r3:ed0cd480 r2:c0730508
    [   16.801747] [<c027f860>] (l3_interrupt_handler) from [<c0063758>] (handle_irq_event_percpu+0x54/0x1bc)
    [   16.811533]  r10:ed005600 r9:c084855b r8:0000002a r7:00000000 r6:00000000 r5:0000002a
    [   16.819780]  r4:ed0e6d80
    [   16.822453] [<c0063704>] (handle_irq_event_percpu) from [<c00638f0>] (handle_irq_event+0x30/0x40)
    [   16.831789]  r10:eb2b6938 r9:eb2b6960 r8:bf011420 r7:fa240100 r6:00000000 r5:0000002a
    [   16.840052]  r4:ed005600
    [   16.842744] [<c00638c0>] (handle_irq_event) from [<c00661d8>] (handle_fasteoi_irq+0x74/0x128)
    [   16.851702]  r4:ed005600 r3:00000000
    [   16.855479] [<c0066164>] (handle_fasteoi_irq) from [<c0063068>] (generic_handle_irq+0x28/0x38)
    [   16.864523]  r4:0000002a r3:c0066164
    [   16.868294] [<c0063040>] (generic_handle_irq) from [<c000ef60>] (handle_IRQ+0x38/0x8c)
    [   16.876612]  r4:c081c640 r3:00000202
    [   16.880380] [<c000ef28>] (handle_IRQ) from [<c00084f0>] (gic_handle_irq+0x30/0x5c)
    [   16.888328]  r6:eab5ba38 r5:c0804460 r4:fa24010c r3:00000100
    [   16.894303] [<c00084c0>] (gic_handle_irq) from [<c05a8d80>] (__irq_svc+0x40/0x50)
    [   16.902193] Exception stack(0xeab5ba38 to 0xeab5ba80)
    [   16.907499] ba20:                                                       00000000 00000006
    [   16.916108] ba40: fa1d0000 fa1d0008 ed3d3000 eab5bab4 ed3d3460 c0842af4 bf011420 eb2b6960
    [   16.924716] ba60: eb2b6938 eab5ba8c eab5ba90 eab5ba80 bf035220 bf07702c 600f0013 ffffffff
    [   16.933317]  r7:eab5ba6c r6:ffffffff r5:600f0013 r4:bf07702c
    [   16.939317] [<bf077000>] (c_can_plat_read_reg_aligned_to_16bit [c_can_platform]) from [<bf035220>] (c_can_get_berr_counter+0x38/0x64 [c_can])
    [   16.952696] [<bf0351e8>] (c_can_get_berr_counter [c_can]) from [<bf010294>] (can_fill_info+0x124/0x15c [can_dev])
    [   16.963480]  r5:ec8c9740 r4:ed3d3000
    [   16.967253] [<bf010170>] (can_fill_info [can_dev]) from [<c0502fa8>] (rtnl_fill_ifinfo+0x58c/0x8fc)
    [   16.976749]  r6:ec8c9740 r5:ed3d3000 r4:eb2b6780
    [   16.981613] [<c0502a1c>] (rtnl_fill_ifinfo) from [<c0503408>] (rtnl_dump_ifinfo+0xf0/0x1dc)
    [   16.990401]  r10:ec8c9740 r9:00000000 r8:00000000 r7:00000000 r6:ebd4d1b4 r5:ed3d3000
    [   16.998671]  r4:00000000
    [   17.001342] [<c0503318>] (rtnl_dump_ifinfo) from [<c050e6e4>] (netlink_dump+0xa8/0x1e0)
    [   17.009772]  r10:00000000 r9:00000000 r8:c0503318 r7:ebf3e6c0 r6:ebd4d1b4 r5:ec8c9740
    [   17.018050]  r4:ebd4d000
    [   17.020714] [<c050e63c>] (netlink_dump) from [<c050ec10>] (__netlink_dump_start+0x104/0x154)
    [   17.029591]  r6:eab5bd34 r5:ec8c9980 r4:ebd4d000
    [   17.034454] [<c050eb0c>] (__netlink_dump_start) from [<c0505604>] (rtnetlink_rcv_msg+0x110/0x1f4)
    [   17.043778]  r7:00000000 r6:ec8c9980 r5:00000f40 r4:ebf3e6c0
    [   17.049743] [<c05054f4>] (rtnetlink_rcv_msg) from [<c05108e8>] (netlink_rcv_skb+0xb4/0xc8)
    [   17.058449]  r8:eab5bdac r7:ec8c9980 r6:c05054f4 r5:ec8c9980 r4:ebf3e6c0
    [   17.065534] [<c0510834>] (netlink_rcv_skb) from [<c0504134>] (rtnetlink_rcv+0x24/0x2c)
    [   17.073854]  r6:ebd4d000 r5:00000014 r4:ec8c9980 r3:c0504110
    [   17.079846] [<c0504110>] (rtnetlink_rcv) from [<c05102ac>] (netlink_unicast+0x180/0x1ec)
    [   17.088363]  r4:ed0c6800 r3:c0504110
    [   17.092113] [<c051012c>] (netlink_unicast) from [<c0510670>] (netlink_sendmsg+0x2ac/0x380)
    [   17.100813]  r10:00000000 r8:00000008 r7:ec8c9980 r6:ebd4d000 r5:eab5be70 r4:eab5bee4
    [   17.109083] [<c05103c4>] (netlink_sendmsg) from [<c04dfdb4>] (sock_sendmsg+0x90/0xb0)
    [   17.117305]  r10:00000000 r9:eab5a000 r8:becdda3c r7:0000000c r6:ea978400 r5:eab5be70
    [   17.125563]  r4:c05103c4
    [   17.128225] [<c04dfd24>] (sock_sendmsg) from [<c04e1c28>] (SyS_sendto+0xb8/0xdc)
    [   17.136001]  r6:becdda5c r5:00000014 r4:ecd37040
    [   17.140876] [<c04e1b70>] (SyS_sendto) from [<c000e680>] (ret_fast_syscall+0x0/0x30)
    [   17.148923]  r10:00000000 r8:c000e804 r7:00000122 r6:becdda5c r5:0000000c r4:becdda5c
    [   17.157169] ---[ end trace 2b71e15b38f58bad ]---
    
    Fixes: 6423d6df1440 ("ARM: OMAP2+: hwmod: check for module address space during init")
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: <stable@vger.kernel.org>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index d78c12e7cb5e..486cc4ded190 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2373,6 +2373,9 @@ static int of_dev_hwmod_lookup(struct device_node *np,
  * registers.  This address is needed early so the OCP registers that
  * are part of the device's address space can be ioremapped properly.
  *
+ * If SYSC access is not needed, the registers will not be remapped
+ * and non-availability of MPU access is not treated as an error.
+ *
  * Returns 0 on success, -EINVAL if an invalid hwmod is passed, and
  * -ENXIO on absent or invalid register target address space.
  */
@@ -2387,6 +2390,11 @@ static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data,
 
 	_save_mpu_port_index(oh);
 
+	/* if we don't need sysc access we don't need to ioremap */
+	if (!oh->class->sysc)
+		return 0;
+
+	/* we can't continue without MPU PORT if we need sysc access */
 	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
 		return -ENXIO;
 
@@ -2396,8 +2404,10 @@ static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data,
 			 oh->name);
 
 		/* Extract the IO space from device tree blob */
-		if (!np)
+		if (!np) {
+			pr_err("omap_hwmod: %s: no dt node\n", oh->name);
 			return -ENXIO;
+		}
 
 		va_start = of_iomap(np, index + oh->mpu_rt_idx);
 	} else {
@@ -2456,13 +2466,11 @@ static int __init _init(struct omap_hwmod *oh, void *data)
 				oh->name, np->name);
 	}
 
-	if (oh->class->sysc) {
-		r = _init_mpu_rt_base(oh, NULL, index, np);
-		if (r < 0) {
-			WARN(1, "omap_hwmod: %s: doesn't have mpu register target base\n",
-			     oh->name);
-			return 0;
-		}
+	r = _init_mpu_rt_base(oh, NULL, index, np);
+	if (r < 0) {
+		WARN(1, "omap_hwmod: %s: doesn't have mpu register target base\n",
+		     oh->name);
+		return 0;
 	}
 
 	r = _init_clocks(oh, NULL);

commit f5b00f6f3a05d228479b7c7bb6ec814b07d713fe
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Jun 22 17:05:21 2015 -0700

    ARM: OMAP2+: Include clk.h
    
    These files use the consumer API, so include clk.h explicitly.
    
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index d78c12e7cb5e..de43e4c9a865 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -130,6 +130,7 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/io.h>
+#include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/delay.h>
 #include <linux/err.h>

commit aaf2c0fbbbb1ec56936e726eec6c253bc4bd469f
Author: Lokesh Vutla <lokeshvutla@ti.com>
Date:   Wed Jun 10 14:56:24 2015 +0530

    ARM: OMAP2+: hwmod: add support for lock and unlock hooks
    
    Some IP blocks like RTC, needs an additional setting for writing to its
    registers. This is to prevent any spurious writes from changing the
    register values.
    
    This patch adds optional lock and unlock function pointers to
    the IP block's hwmod data. These unlock and lock function pointers
    are called by hwmod code before and after writing sysconfig registers.
    
    Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
    [paul@pwsan.com: fixed indentation level to conform with the rest of the
     structure members]
    Reviewed-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index d78c12e7cb5e..2ceed3192f22 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -299,7 +299,20 @@ static void _write_sysconfig(u32 v, struct omap_hwmod *oh)
 
 	/* Module might have lost context, always update cache and register */
 	oh->_sysc_cache = v;
+
+	/*
+	 * Some IP blocks (such as RTC) require unlocking of IP before
+	 * accessing its registers. If a function pointer is present
+	 * to unlock, then call it before accessing sysconfig and
+	 * call lock after writing sysconfig.
+	 */
+	if (oh->class->unlock)
+		oh->class->unlock(oh);
+
 	omap_hwmod_write(v, oh, oh->class->sysc->sysc_offs);
+
+	if (oh->class->lock)
+		oh->class->lock(oh);
 }
 
 /**

commit 6da233589f26ebd891d507a5a134ab43267006f2
Author: Pali Rohr <pali.rohar@gmail.com>
Date:   Thu Feb 26 14:49:51 2015 +0100

    ARM: OMAP2+: Return correct error values from device and hwmod
    
    Without this patch function pm_runtime_get_sync() returns 0 even when
    some omap subfunction fails. This patch properly propagate error codes
    from omap functions back to caller.
    
    This patch fix problem, when loading omap-aes driver in qemu cause
    kernel oops.
    
    Signed-off-by: Pali Rohr <pali.rohar@gmail.com>
    [paul@pwsan.com: fix a checkpatch warning]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 752969ff9de0..d78c12e7cb5e 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3318,16 +3318,17 @@ int omap_hwmod_enable(struct omap_hwmod *oh)
  */
 int omap_hwmod_idle(struct omap_hwmod *oh)
 {
+	int r;
 	unsigned long flags;
 
 	if (!oh)
 		return -EINVAL;
 
 	spin_lock_irqsave(&oh->_lock, flags);
-	_idle(oh);
+	r = _idle(oh);
 	spin_unlock_irqrestore(&oh->_lock, flags);
 
-	return 0;
+	return r;
 }
 
 /**
@@ -3340,16 +3341,17 @@ int omap_hwmod_idle(struct omap_hwmod *oh)
  */
 int omap_hwmod_shutdown(struct omap_hwmod *oh)
 {
+	int r;
 	unsigned long flags;
 
 	if (!oh)
 		return -EINVAL;
 
 	spin_lock_irqsave(&oh->_lock, flags);
-	_shutdown(oh);
+	r = _shutdown(oh);
 	spin_unlock_irqrestore(&oh->_lock, flags);
 
-	return 0;
+	return r;
 }
 
 /*

commit a5bf00cd735fbc293da8a9bada589c02861c8132
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue May 5 16:33:05 2015 +0300

    ARM: AM33xx+: hwmod: re-use omap4 implementations for reset functionality
    
    The reset code functionality is mostly a copy paste between OMAP4+ and
    AM33xx+. Re-use the omap4 code where possible, and just keep the special
    implementation for de-asserting the hardreset lines for AM33xx, as
    AM33xx+ devices have slightly different register layouts compared to
    OMAP4+. This patch also fixes the hardreset issues faced on AM43xx.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Reported-by: Dave Gerlach <d-gerlach@ti.com>
    Reported-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index e482562075ef..752969ff9de0 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3055,27 +3055,6 @@ static int _omap4_is_hardreset_asserted(struct omap_hwmod *oh,
 					      oh->prcm.omap4.rstctrl_offs);
 }
 
-/**
- * _am33xx_assert_hardreset - call AM33XX PRM hardreset fn with hwmod args
- * @oh: struct omap_hwmod * to assert hardreset
- * @ohri: hardreset line data
- *
- * Call am33xx_prminst_assert_hardreset() with parameters extracted
- * from the hwmod @oh and the hardreset line data @ohri.  Only
- * intended for use as an soc_ops function pointer.  Passes along the
- * return value from am33xx_prminst_assert_hardreset().  XXX This
- * function is scheduled for removal when the PRM code is moved into
- * drivers/.
- */
-static int _am33xx_assert_hardreset(struct omap_hwmod *oh,
-				   struct omap_hwmod_rst_info *ohri)
-
-{
-	return omap_prm_assert_hardreset(ohri->rst_shift, 0,
-					 oh->clkdm->pwrdm.ptr->prcm_offs,
-					 oh->prcm.omap4.rstctrl_offs);
-}
-
 /**
  * _am33xx_deassert_hardreset - call AM33XX PRM hardreset fn with hwmod args
  * @oh: struct omap_hwmod * to deassert hardreset
@@ -3091,32 +3070,13 @@ static int _am33xx_assert_hardreset(struct omap_hwmod *oh,
 static int _am33xx_deassert_hardreset(struct omap_hwmod *oh,
 				     struct omap_hwmod_rst_info *ohri)
 {
-	return omap_prm_deassert_hardreset(ohri->rst_shift, ohri->st_shift, 0,
+	return omap_prm_deassert_hardreset(ohri->rst_shift, ohri->st_shift,
+					   oh->clkdm->pwrdm.ptr->prcm_partition,
 					   oh->clkdm->pwrdm.ptr->prcm_offs,
 					   oh->prcm.omap4.rstctrl_offs,
 					   oh->prcm.omap4.rstst_offs);
 }
 
-/**
- * _am33xx_is_hardreset_asserted - call AM33XX PRM hardreset fn with hwmod args
- * @oh: struct omap_hwmod * to test hardreset
- * @ohri: hardreset line data
- *
- * Call am33xx_prminst_is_hardreset_asserted() with parameters
- * extracted from the hwmod @oh and the hardreset line data @ohri.
- * Only intended for use as an soc_ops function pointer.  Passes along
- * the return value from am33xx_prminst_is_hardreset_asserted().  XXX
- * This function is scheduled for removal when the PRM code is moved
- * into drivers/.
- */
-static int _am33xx_is_hardreset_asserted(struct omap_hwmod *oh,
-					struct omap_hwmod_rst_info *ohri)
-{
-	return omap_prm_is_hardreset_asserted(ohri->rst_shift, 0,
-					      oh->clkdm->pwrdm.ptr->prcm_offs,
-					      oh->prcm.omap4.rstctrl_offs);
-}
-
 /* Public functions */
 
 u32 omap_hwmod_read(struct omap_hwmod *oh, u16 reg_offs)
@@ -3916,21 +3876,13 @@ void __init omap_hwmod_init(void)
 		soc_ops.init_clkdm = _init_clkdm;
 		soc_ops.update_context_lost = _omap4_update_context_lost;
 		soc_ops.get_context_lost = _omap4_get_context_lost;
-	} else if (soc_is_am43xx()) {
+	} else if (cpu_is_ti816x() || soc_is_am33xx() || soc_is_am43xx()) {
 		soc_ops.enable_module = _omap4_enable_module;
 		soc_ops.disable_module = _omap4_disable_module;
 		soc_ops.wait_target_ready = _omap4_wait_target_ready;
 		soc_ops.assert_hardreset = _omap4_assert_hardreset;
-		soc_ops.deassert_hardreset = _omap4_deassert_hardreset;
-		soc_ops.is_hardreset_asserted = _omap4_is_hardreset_asserted;
-		soc_ops.init_clkdm = _init_clkdm;
-	} else if (cpu_is_ti816x() || soc_is_am33xx()) {
-		soc_ops.enable_module = _omap4_enable_module;
-		soc_ops.disable_module = _omap4_disable_module;
-		soc_ops.wait_target_ready = _omap4_wait_target_ready;
-		soc_ops.assert_hardreset = _am33xx_assert_hardreset;
 		soc_ops.deassert_hardreset = _am33xx_deassert_hardreset;
-		soc_ops.is_hardreset_asserted = _am33xx_is_hardreset_asserted;
+		soc_ops.is_hardreset_asserted = _omap4_is_hardreset_asserted;
 		soc_ops.init_clkdm = _init_clkdm;
 	} else {
 		WARN(1, "omap_hwmod: unknown SoC type\n");

commit 4ebf5b288c57767ad62e63c5fc0e586f0210e36c
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue May 5 16:33:04 2015 +0300

    ARM: OMAP4+: PRM: add support for passing status register/bit info to reset
    
    AM43xx has slightly different reset register layout compared to OMAP4+,
    with varying status bit shifts and status register offsets. Current
    code assumes static offsets and identical status / reset control bit
    shifts, which is wrong. This patch adds PRM core support for passing
    the actual implementations from hwmod code. AM43xx mappings will be fixed
    in subsequent patch.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Reported-by: Dave Gerlach <d-gerlach@ti.com>
    Reported-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 355b08936871..e482562075ef 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -171,6 +171,12 @@
  */
 #define LINKS_PER_OCP_IF		2
 
+/*
+ * Address offset (in bytes) between the reset control and the reset
+ * status registers: 4 bytes on OMAP4
+ */
+#define OMAP4_RST_CTRL_ST_OFFSET	4
+
 /**
  * struct omap_hwmod_soc_ops - fn ptrs for some SoC-specific operations
  * @enable_module: function to enable a module (via MODULEMODE)
@@ -3016,10 +3022,12 @@ static int _omap4_deassert_hardreset(struct omap_hwmod *oh,
 	if (ohri->st_shift)
 		pr_err("omap_hwmod: %s: %s: hwmod data error: OMAP4 does not support st_shift\n",
 		       oh->name, ohri->name);
-	return omap_prm_deassert_hardreset(ohri->rst_shift, 0,
+	return omap_prm_deassert_hardreset(ohri->rst_shift, ohri->rst_shift,
 					   oh->clkdm->pwrdm.ptr->prcm_partition,
 					   oh->clkdm->pwrdm.ptr->prcm_offs,
-					   oh->prcm.omap4.rstctrl_offs, 0);
+					   oh->prcm.omap4.rstctrl_offs,
+					   oh->prcm.omap4.rstctrl_offs +
+					   OMAP4_RST_CTRL_ST_OFFSET);
 }
 
 /**

commit 80d2518dfd19e9750d0c1203851774bb9732268b
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Feb 26 18:06:00 2015 +0200

    ARM: OMAP2+: hwmod: fix deassert hardreset clkdm usecounting
    
    Deasserting hardreset increases the usecount for the hwmod parent clockdomain
    always, however usecount is only decreased at end in certain error cases.
    This causes software supervised clockdomains to remain always on, preventing
    idle. Fixed by always releasing the hwmods clockdomain parent when exiting
    the function.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Carlos Hernandez <ceh@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 2db380420b6f..355b08936871 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1692,16 +1692,15 @@ static int _deassert_hardreset(struct omap_hwmod *oh, const char *name)
 	if (ret == -EBUSY)
 		pr_warn("omap_hwmod: %s: failed to hardreset\n", oh->name);
 
-	if (!ret) {
+	if (oh->clkdm) {
 		/*
 		 * Set the clockdomain to HW_AUTO, assuming that the
 		 * previous state was HW_AUTO.
 		 */
-		if (oh->clkdm && hwsup)
+		if (hwsup)
 			clkdm_allow_idle(oh->clkdm);
-	} else {
-		if (oh->clkdm)
-			clkdm_hwmod_disable(oh->clkdm, oh);
+
+		clkdm_hwmod_disable(oh->clkdm, oh);
 	}
 
 	return ret;

commit 6931795238000c8eba52442f1e9822286ed01e29
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Thu Feb 26 00:00:51 2015 -0700

    ARM: omap2+: omap_hwmod: Set unique lock_class_key per hwmod
    
    Add struct lock_class_key to omap_hwmod struct and use it to set unique
    lockdep class per hwmod.
    This will ensure that lockdep will know that each omap_hwmod->_lock should
    be treated as separate class and will not give false warning about deadlock
    or other issues due to nested use of hwmods.
    DRA7x's ATL hwmod is one example for this since McASP can select ATL clock
    as functional clock, which will trigger nested oh->_lock usage. This will
    trigger false warning from lockdep validator as it is dealing with classes
    and for it all hwmod clocks are the same class.
    
    Suggested-by: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 92afb723dcfc..2db380420b6f 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2698,6 +2698,7 @@ static int __init _register(struct omap_hwmod *oh)
 	INIT_LIST_HEAD(&oh->master_ports);
 	INIT_LIST_HEAD(&oh->slave_ports);
 	spin_lock_init(&oh->_lock);
+	lockdep_set_class(&oh->_lock, &oh->hwmod_key);
 
 	oh->_state = _HWMOD_STATE_REGISTERED;
 

commit 878ba61aa98cbb97a513757800e77613f856a029
Merge: ea7531ac4a9d df1a66812535
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 17 09:27:54 2015 -0800

    Merge tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform changes from Olof Johansson:
     "New and updated SoC support.  Also included are some cleanups where
      the platform maintainers hadn't separated cleanups from new developent
      in separate branches.
    
      Some of the larger things worth pointing out:
    
       - A large set of changes from Alexandre Belloni and Nicolas Ferre
         preparing at91 platforms for multiplatform and cleaning up quite a
         bit in the process.
    
       - Removal of CSR's "Marco" SoC platform that never made it out to the
         market.  We love seeing these since it means the vendor published
         support before product was out, which is exactly what we want!
    
      New platforms this release are:
    
       - Conexant Digicolor (CX92755 SoC)
       - Hisilicon HiP01 SoC
       - CSR/sirf Atlas7 SoC
       - ST STiH418 SoC
       - Common code changes for Nvidia Tegra132 (64-bit SoC)
    
      We're seeing more and more platforms having a harder time labelling
      changes as cleanups vs new development -- which is a good sign that
      we've come quite far on the cleanup effort.  So over time we might
      start combining the cleanup and new-development branches more"
    
    * tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (124 commits)
      ARM: at91/trivial: unify functions and machine names
      ARM: at91: remove at91_dt_initialize and machine init_early()
      ARM: at91: change board files into SoC files
      ARM: at91: remove at91_boot_soc
      ARM: at91: move alternative initial mapping to board-dt-sama5.c
      ARM: at91: merge all SOC_AT91SAM9xxx
      ARM: at91: at91rm9200: set idle and restart from rm9200_dt_device_init()
      ARM: digicolor: select syscon and timer
      ARM: zynq: Simplify SLCR initialization
      ARM: zynq: PM: Fixed simple typo.
      ARM: zynq: Setup default gpio number for Xilinx Zynq
      ARM: digicolor: add low level debug support
      ARM: initial support for Conexant Digicolor CX92755 SoC
      ARM: OMAP2+: Add dm816x hwmod support
      ARM: OMAP2+: Add clock domain support for dm816x
      ARM: OMAP2+: Add board-generic.c entry for ti81xx
      ARM: at91: pm: remove warning to remove SOC_AT91SAM9263 usage
      ARM: at91: remove unused mach/system_rev.h
      ARM: at91: stop using HAVE_AT91_DBGUx
      ARM: at91: fix ordering of SRAM and PM initialization
      ...

commit ea7531ac4a9d0b39edce43472147dc41cc2b7a34
Merge: 4025fa97ff39 41e229a91207
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 17 09:17:33 2015 -0800

    Merge tag 'cleanup-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC cleanups from Olof Johansson:
     "This is a good healthy set of various code removals.  Total net delta
      is 8100 lines removed.
    
      Among the larger cleanups are:
    
       - Removal of old Samsung S3C DMA infrastructure by Arnd
       - Removal of the non-DT version of the 'lager' board by Magnus Damm
       - General stale code removal on OMAP and Davinci by Rickard Strandqvist
       - Removal of non-DT support on am3517 platforms by Tony Lindgren
    
      ... plus several other cleanups of various platforms across the board"
    
    * tag 'cleanup-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (47 commits)
      ARM: sirf: drop redundant function and marco declaration
      arm: omap: specify PMUs are for ARMv7 CPUs
      arm: shmobile: specify PMUs are for ARMv7 CPUs
      arm: iop: specify PMUs are for XScale CPUs
      arm: pxa: specify PMUs are for XScale CPUs
      arm: realview: specify PMU types
      ARM: SAMSUNG: remove unused DMA infrastructure
      ARM: OMAP3: Add back Kconfig option MACH_OMAP3517EVM for ASoC
      ARM: davinci: Remove CDCE949 driver
      ARM: at91: remove useless at91rm9200_set_type()
      ARM: at91: remove useless at91rm9200_dt_initialize()
      ARM: at91: move debug-macro.S into the common space
      ARM: at91: remove useless at91_sysirq_mask_rtx
      ARM: at91: remove useless config MACH_AT91SAM9_DT
      ARM: at91: remove useless config MACH_AT91RM9200_DT
      ARM: at91: remove unused mach/memory.h
      ARM: at91: remove useless header file includes
      ARM: at91: remove unneeded header file
      rtc: at91/Kconfig: remove useless options
      ARM: at91/Documentation: add a README for Atmel SoCs
      ...

commit 4025fa97ff39db054b47b9cdb9f3980480637668
Merge: c397f8fa4379 11fe05de8b73
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 17 09:15:46 2015 -0800

    Merge tag 'fixes-non-critical-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC non-critical fixes from Olof Johansson:
     "Here's a small collection of fixes accrued during the last release
      that weren't considered severe enough to merge during the -rc series.
    
      A few of these are around resurrecting TI81xx support that's been
      broken for quite a while, the rest are smaller fixes -- most for PXA
      but a few across the board.
    
      There are also some updates to MAINTAINERS here, in particular for
      Broadcom platforms"
    
    * tag 'fixes-non-critical-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (23 commits)
      MAINTAINERS: fix git repositories for Broadcom SoCs
      ARM: pxa: fix broken isa interrupts for zeus and viper
      ARM: DRA7: hwmod: Fix boot crash with DEBUG_LL enabled on UART3
      ARM: OMAP: DRA7: hwmod: Make gpmc software supervised as the smart idle is broken
      ARM: AM43xx: hwmod: set DSS submodule parent hwmods
      ARM: OMAP2+: hwmod: print error if wait_target_ready() failed
      MAINTAINERS: add maintainer for OMAP hwmod data
      ARM: OMAP2+: Disable omap3 PM init for ti81xx
      ARM: OMAP2+: Fix reboot for 81xx
      ARM: OMAP2+: Fix dm814 and dm816 for clocks and timer init
      ARM: OMAP2+: Fix ti81xx class type
      ARM: OMAP2+: Fix ti81xx devtype
      ARM: OMAP2+: Fix error handling for omap2_clk_enable_init_clocks
      MAINTAINERS: add a git entry for BMIPS-based BCM7xxx SoCs
      MAINTAINERS: add a git entry for BCM7xxx ARM-based SoCs
      MAINTAINERS: update Broadcom Cygnus SoC git tree
      MAINTAINERS: move BCM63xx ARM-based SoCs git tree
      hx4700: regulator: declare full constraints
      ARM: pxa: add regulator_has_full_constraints to spitz board file
      ARM: pxa: add regulator_has_full_constraints to poodle board file
      ...

commit 4d38bd1237f5bb67c3d5d183fc41db4bf4dbfb6b
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Jan 26 09:26:32 2015 -0800

    ARM: OMAP2+: Add dm816x hwmod support
    
    Add minimal hwmod support that works at least on dm8168. This
    is based on the code in the earlier TI CDP tree, and an earlier
    patch by Aida Mynzhasova <aida.mynzhasova@skitlab.ru>.
    
    I've set up things to work pretty much the same way as for
    am33xx. We are basically using cm33xx.c with a different set
    of clocks and clockdomains.
    
    This code is based on the TI81XX-LINUX-PSP-04.04.00.02 patches
    published at:
    
    http://downloads.ti.com/dsps/dsps_public_sw/psp/LinuxPSP/TI81XX_04_04/04_04_00_02/index_FDS.html
    
    Cc: Aida Mynzhasova <aida.mynzhasova@skitlab.ru>
    Cc: Brian Hutchinson <b.hutchman@gmail.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index cbb908dc5cf0..d7e6d5c8d171 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -4142,7 +4142,7 @@ void __init omap_hwmod_init(void)
 		soc_ops.deassert_hardreset = _omap4_deassert_hardreset;
 		soc_ops.is_hardreset_asserted = _omap4_is_hardreset_asserted;
 		soc_ops.init_clkdm = _init_clkdm;
-	} else if (soc_is_am33xx()) {
+	} else if (cpu_is_ti816x() || soc_is_am33xx()) {
 		soc_ops.enable_module = _omap4_enable_module;
 		soc_ops.disable_module = _omap4_disable_module;
 		soc_ops.wait_target_ready = _omap4_wait_target_ready;

commit 812ce9d2825d6a897458615b48f87ea5ba47e6a9
Author: Lokesh Vutla <lokeshvutla@ti.com>
Date:   Fri Dec 19 18:04:50 2014 +0530

    ARM: OMAP2+: hwmod: print error if wait_target_ready() failed
    
    Fixed pr_debug to pr_err when hwmod returns an error when enabling
    a module.
    
    Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
    Acked-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index cbb908dc5cf0..06157af892ce 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2155,8 +2155,8 @@ static int _enable(struct omap_hwmod *oh)
 		if (soc_ops.disable_module)
 			soc_ops.disable_module(oh);
 		_disable_clocks(oh);
-		pr_debug("omap_hwmod: %s: _wait_target_ready: %d\n",
-			 oh->name, r);
+		pr_err("omap_hwmod: %s: _wait_target_ready failed: %d\n",
+		       oh->name, r);
 
 		if (oh->clkdm)
 			clkdm_hwmod_disable(oh->clkdm, oh);

commit 0fb22a8fb7f3bc1b00a36d4a97ce4f93191f7559
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Sat Jan 17 10:21:08 2015 +0000

    ARM: OMAP: Work around hardcoded interrupts
    
    Commit 9a1091ef0017 ("irqchip: gic: Support hierarchy irq domain")
    changed the GIC driver to use a non-legacy IRQ domain on DT
    platforms. This patch assumes that DT-driven systems are getting
    all of their interrupts from device tree.
    
    Turns out that OMAP has quite a few hidden gems, and still uses
    hardcoded interrupts despite having fairly complete DTs.
    
    This patch attempts to work around these by offering a translation
    method that can be called directly from the hwmod code, if present.
    The same hack is sprinkled over PRCM and TWL.
    
    It isn't pretty, but it seems to do the job without having to add
    more hacks to the interrupt controller code.
    
    Tested on OMAP4 (Panda-ES) and OMAP5 (UEVM5432).
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Nishanth Menon <nm@ti.com>
    [tony@atomide.com: updated to fix make randconfig issue]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index cbb908dc5cf0..9025ffffd2dc 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3534,9 +3534,15 @@ int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 
 	mpu_irqs_cnt = _count_mpu_irqs(oh);
 	for (i = 0; i < mpu_irqs_cnt; i++) {
+		unsigned int irq;
+
+		if (oh->xlate_irq)
+			irq = oh->xlate_irq((oh->mpu_irqs + i)->irq);
+		else
+			irq = (oh->mpu_irqs + i)->irq;
 		(res + r)->name = (oh->mpu_irqs + i)->name;
-		(res + r)->start = (oh->mpu_irqs + i)->irq;
-		(res + r)->end = (oh->mpu_irqs + i)->irq;
+		(res + r)->start = irq;
+		(res + r)->end = irq;
 		(res + r)->flags = IORESOURCE_IRQ;
 		r++;
 	}

commit 1bbc360bb7eb7c40d074c9279b3cff20755131ef
Author: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
Date:   Sun Dec 7 18:24:07 2014 +0100

    ARM: OMAP2+: omap_hwmod.c: Remove some unused functions
    
    Removes some functions that are not used anywhere:
    omap_hwmod_pad_route_irq() omap_hwmod_no_setup_reset()
    omap_hwmod_read_hardreset() omap_hwmod_del_initiator_dep()
    omap_hwmod_enable_clocks() omap_hwmod_reset() omap_hwmod_ocp_barrier()
    omap_hwmod_disable_clocks() omap_hwmod_add_initiator_dep()
    
    This was partially found by using a static code analysis program called cppcheck.
    
    Signed-off-by: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index cbb908dc5cf0..e341e5dfff2d 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3384,91 +3384,6 @@ int omap_hwmod_shutdown(struct omap_hwmod *oh)
 	return 0;
 }
 
-/**
- * omap_hwmod_enable_clocks - enable main_clk, all interface clocks
- * @oh: struct omap_hwmod *oh
- *
- * Intended to be called by the omap_device code.
- */
-int omap_hwmod_enable_clocks(struct omap_hwmod *oh)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&oh->_lock, flags);
-	_enable_clocks(oh);
-	spin_unlock_irqrestore(&oh->_lock, flags);
-
-	return 0;
-}
-
-/**
- * omap_hwmod_disable_clocks - disable main_clk, all interface clocks
- * @oh: struct omap_hwmod *oh
- *
- * Intended to be called by the omap_device code.
- */
-int omap_hwmod_disable_clocks(struct omap_hwmod *oh)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&oh->_lock, flags);
-	_disable_clocks(oh);
-	spin_unlock_irqrestore(&oh->_lock, flags);
-
-	return 0;
-}
-
-/**
- * omap_hwmod_ocp_barrier - wait for posted writes against the hwmod to complete
- * @oh: struct omap_hwmod *oh
- *
- * Intended to be called by drivers and core code when all posted
- * writes to a device must complete before continuing further
- * execution (for example, after clearing some device IRQSTATUS
- * register bits)
- *
- * XXX what about targets with multiple OCP threads?
- */
-void omap_hwmod_ocp_barrier(struct omap_hwmod *oh)
-{
-	BUG_ON(!oh);
-
-	if (!oh->class->sysc || !oh->class->sysc->sysc_flags) {
-		WARN(1, "omap_device: %s: OCP barrier impossible due to device configuration\n",
-			oh->name);
-		return;
-	}
-
-	/*
-	 * Forces posted writes to complete on the OCP thread handling
-	 * register writes
-	 */
-	omap_hwmod_read(oh, oh->class->sysc->sysc_offs);
-}
-
-/**
- * omap_hwmod_reset - reset the hwmod
- * @oh: struct omap_hwmod *
- *
- * Under some conditions, a driver may wish to reset the entire device.
- * Called from omap_device code.  Returns -EINVAL on error or passes along
- * the return value from _reset().
- */
-int omap_hwmod_reset(struct omap_hwmod *oh)
-{
-	int r;
-	unsigned long flags;
-
-	if (!oh)
-		return -EINVAL;
-
-	spin_lock_irqsave(&oh->_lock, flags);
-	r = _reset(oh);
-	spin_unlock_irqrestore(&oh->_lock, flags);
-
-	return r;
-}
-
 /*
  * IP block data retrieval functions
  */
@@ -3723,51 +3638,11 @@ void __iomem *omap_hwmod_get_mpu_rt_va(struct omap_hwmod *oh)
 	return oh->_mpu_rt_va;
 }
 
-/**
- * omap_hwmod_add_initiator_dep - add sleepdep from @init_oh to @oh
- * @oh: struct omap_hwmod *
- * @init_oh: struct omap_hwmod * (initiator)
- *
- * Add a sleep dependency between the initiator @init_oh and @oh.
- * Intended to be called by DSP/Bridge code via platform_data for the
- * DSP case; and by the DMA code in the sDMA case.  DMA code, *Bridge
- * code needs to add/del initiator dependencies dynamically
- * before/after accessing a device.  Returns the return value from
- * _add_initiator_dep().
- *
- * XXX Keep a usecount in the clockdomain code
- */
-int omap_hwmod_add_initiator_dep(struct omap_hwmod *oh,
-				 struct omap_hwmod *init_oh)
-{
-	return _add_initiator_dep(oh, init_oh);
-}
-
 /*
  * XXX what about functions for drivers to save/restore ocp_sysconfig
  * for context save/restore operations?
  */
 
-/**
- * omap_hwmod_del_initiator_dep - remove sleepdep from @init_oh to @oh
- * @oh: struct omap_hwmod *
- * @init_oh: struct omap_hwmod * (initiator)
- *
- * Remove a sleep dependency between the initiator @init_oh and @oh.
- * Intended to be called by DSP/Bridge code via platform_data for the
- * DSP case; and by the DMA code in the sDMA case.  DMA code, *Bridge
- * code needs to add/del initiator dependencies dynamically
- * before/after accessing a device.  Returns the return value from
- * _del_initiator_dep().
- *
- * XXX Keep a usecount in the clockdomain code
- */
-int omap_hwmod_del_initiator_dep(struct omap_hwmod *oh,
-				 struct omap_hwmod *init_oh)
-{
-	return _del_initiator_dep(oh, init_oh);
-}
-
 /**
  * omap_hwmod_enable_wakeup - allow device to wake up the system
  * @oh: struct omap_hwmod *
@@ -3888,33 +3763,6 @@ int omap_hwmod_deassert_hardreset(struct omap_hwmod *oh, const char *name)
 	return ret;
 }
 
-/**
- * omap_hwmod_read_hardreset - read the HW reset line state of submodules
- * contained in the hwmod module
- * @oh: struct omap_hwmod *
- * @name: name of the reset line to look up and read
- *
- * Return the current state of the hwmod @oh's reset line named @name:
- * returns -EINVAL upon parameter error or if this operation
- * is unsupported on the current OMAP; otherwise, passes along the return
- * value from _read_hardreset().
- */
-int omap_hwmod_read_hardreset(struct omap_hwmod *oh, const char *name)
-{
-	int ret;
-	unsigned long flags;
-
-	if (!oh)
-		return -EINVAL;
-
-	spin_lock_irqsave(&oh->_lock, flags);
-	ret = _read_hardreset(oh, name);
-	spin_unlock_irqrestore(&oh->_lock, flags);
-
-	return ret;
-}
-
-
 /**
  * omap_hwmod_for_each_by_class - call @fn for each hwmod of class @classname
  * @classname: struct omap_hwmod_class name to search for
@@ -4024,86 +3872,6 @@ int omap_hwmod_get_context_loss_count(struct omap_hwmod *oh)
 	return ret;
 }
 
-/**
- * omap_hwmod_no_setup_reset - prevent a hwmod from being reset upon setup
- * @oh: struct omap_hwmod *
- *
- * Prevent the hwmod @oh from being reset during the setup process.
- * Intended for use by board-*.c files on boards with devices that
- * cannot tolerate being reset.  Must be called before the hwmod has
- * been set up.  Returns 0 upon success or negative error code upon
- * failure.
- */
-int omap_hwmod_no_setup_reset(struct omap_hwmod *oh)
-{
-	if (!oh)
-		return -EINVAL;
-
-	if (oh->_state != _HWMOD_STATE_REGISTERED) {
-		pr_err("omap_hwmod: %s: cannot prevent setup reset; in wrong state\n",
-			oh->name);
-		return -EINVAL;
-	}
-
-	oh->flags |= HWMOD_INIT_NO_RESET;
-
-	return 0;
-}
-
-/**
- * omap_hwmod_pad_route_irq - route an I/O pad wakeup to a particular MPU IRQ
- * @oh: struct omap_hwmod * containing hwmod mux entries
- * @pad_idx: array index in oh->mux of the hwmod mux entry to route wakeup
- * @irq_idx: the hwmod mpu_irqs array index of the IRQ to trigger on wakeup
- *
- * When an I/O pad wakeup arrives for the dynamic or wakeup hwmod mux
- * entry number @pad_idx for the hwmod @oh, trigger the interrupt
- * service routine for the hwmod's mpu_irqs array index @irq_idx.  If
- * this function is not called for a given pad_idx, then the ISR
- * associated with @oh's first MPU IRQ will be triggered when an I/O
- * pad wakeup occurs on that pad.  Note that @pad_idx is the index of
- * the _dynamic or wakeup_ entry: if there are other entries not
- * marked with OMAP_DEVICE_PAD_WAKEUP or OMAP_DEVICE_PAD_REMUX, these
- * entries are NOT COUNTED in the dynamic pad index.  This function
- * must be called separately for each pad that requires its interrupt
- * to be re-routed this way.  Returns -EINVAL if there is an argument
- * problem or if @oh does not have hwmod mux entries or MPU IRQs;
- * returns -ENOMEM if memory cannot be allocated; or 0 upon success.
- *
- * XXX This function interface is fragile.  Rather than using array
- * indexes, which are subject to unpredictable change, it should be
- * using hwmod IRQ names, and some other stable key for the hwmod mux
- * pad records.
- */
-int omap_hwmod_pad_route_irq(struct omap_hwmod *oh, int pad_idx, int irq_idx)
-{
-	int nr_irqs;
-
-	might_sleep();
-
-	if (!oh || !oh->mux || !oh->mpu_irqs || pad_idx < 0 ||
-	    pad_idx >= oh->mux->nr_pads_dynamic)
-		return -EINVAL;
-
-	/* Check the number of available mpu_irqs */
-	for (nr_irqs = 0; oh->mpu_irqs[nr_irqs].irq >= 0; nr_irqs++)
-		;
-
-	if (irq_idx >= nr_irqs)
-		return -EINVAL;
-
-	if (!oh->mux->irqs) {
-		/* XXX What frees this? */
-		oh->mux->irqs = kzalloc(sizeof(int) * oh->mux->nr_pads_dynamic,
-			GFP_KERNEL);
-		if (!oh->mux->irqs)
-			return -ENOMEM;
-	}
-	oh->mux->irqs[pad_idx] = irq_idx;
-
-	return 0;
-}
-
 /**
  * omap_hwmod_init - initialize the hwmod code
  *

commit df717a58a38c49cf7c6e761d35aa822344dbd1bd
Merge: 09ffd948a092 29c4ce17bcad
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Nov 28 14:50:13 2014 +0100

    Merge (part of) tag 'omap-for-v3.19/hwmod-and-defconfig' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into next/soc
    
    SoC related changes for omaps including hwmod clean-up for
    DSS, and hwmod data for more UARTs and ADC. Also few defconfig
    changes to enable devices found on am335x and am437x.
    
    [arnd: I removed the defconfig changes from the branch in order
     to cherry-pick them onto the next/defconfig branch, but I did
     not change the other commits]
    
    * commit '29c4ce17bcad':
      ARM: dts: cm-t3x30: add keypad support
      ARM: OMAP2+: hwmod: AM43x: add hwmod support for ADC on AM43xx
      ARM: DRA7: hwmod data: Add missing UART hwmod data
      ARM: dts: omap4.dtsi: remove dss_fck
      ARM: OMAP4: fix RFBI iclk
      ARM: OMAP4: hwmod: use MODULEMODE properly
      ARM: OMAP4: hwmod: set DSS submodule parent hwmods
      ARM: OMAP5: hwmod: set DSS submodule parent hwmods
      ARM: OMAP2+: hwmod: add parent_hwmod support
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 37f286e9085717c17a509fed977c0766244f80c9
Merge: 3cb0df93bce1 61c8621e2bd1
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Nov 20 12:06:19 2014 +0100

    Merge tag 'omap-for-v3.19/prcm-cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into next/soc
    
    Pull "omap prcm clean-up for v3.19" from Tony Lindgren:
    
    Clean-up series for omap PRCM (Power Reset Clock Module) from
    Tero Kristo to move things a bit closer to becoming a proper
    device driver.
    
    * tag 'omap-for-v3.19/prcm-cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap: (26 commits)
      ARM: OMAP2+: PRM: provide generic API for system reset
      ARM: OMAP3+: PRM: add generic API for reconfiguring I/O chain
      ARM: OMAP4: PRM: make PRCM interrupt handler related functions static
      ARM: OMAP3: PRM: make PRCM interrupt handler related functions static
      ARM: OMAP4: PRM: make omap4_prm_read/write_inst_reg calls static
      ARM: AM33xx: PRM: make direct register access functions static
      ARM: AM33xx: PRM: move global warm reset implementation to driver
      ARM: OMAP4+: CM: remove omap4_cm1/cm2_* functions
      ARM: OMAP4: CM: make cminst direct register access functions static
      ARM: OMAP4: CM: move public definitions from cminst44xx.h to cm44xx.h
      ARM: OMAP2+: PRM: add generic API for checking hardreset status
      ARM: OMAP2+: PRM: add generic API for deasserting hardware reset
      ARM: OMAP2+: PRM: add generic API for asserting hardware reset
      ARM: AM33xx: PRM: add support for prm_init
      ARM: AM43xx: hwmod: use OMAP4 hardreset ops instead of the AM33xx version
      ARM: AM33xx: hwmod: remove am33xx specific module SoC opts
      ARM: OMAP2/3: CM: make cm_split_idlest_reg SoC calls static
      ARM: OMAP2+: CM: add common APIs for cm_module_enable/disable
      ARM: OMAP2+: CM: make clkdm_hwsup operations static
      ARM: OMAP4+/AM33xx: CM: add common API for cm_wait_module_idle
      ...
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit f22d2545517a0ffb8da2879d3a0dbcae99848e6c
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Oct 9 17:03:14 2014 +0300

    ARM: OMAP2+: hwmod: add parent_hwmod support
    
    Add parent_hwmod pointer to omap_hwmod. This can be set to point to a
    "parent" hwmod that needs to be enabled for the "child" hwmod to work.
    
    This is used at hwmod setup time: when doing the initial setup and
    reset, first enable the parent hwmod, and after setup and reset is done,
    restore the parent hwmod to postsetup_state.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Reviewed-by: Archit Taneja <archit.taneja@gmail.com>
    [paul@pwsan.com: add kerneldoc documentation for parent_hwmod; note that it
     is a temporary workaround]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index acae6d5d1151..a2c7b300fe89 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2719,11 +2719,33 @@ static int __init _setup(struct omap_hwmod *oh, void *data)
 	if (oh->_state != _HWMOD_STATE_INITIALIZED)
 		return 0;
 
+	if (oh->parent_hwmod) {
+		int r;
+
+		r = _enable(oh->parent_hwmod);
+		WARN(r, "hwmod: %s: setup: failed to enable parent hwmod %s\n",
+		     oh->name, oh->parent_hwmod->name);
+	}
+
 	_setup_iclk_autoidle(oh);
 
 	if (!_setup_reset(oh))
 		_setup_postsetup(oh);
 
+	if (oh->parent_hwmod) {
+		u8 postsetup_state;
+
+		postsetup_state = oh->parent_hwmod->_postsetup_state;
+
+		if (postsetup_state == _HWMOD_STATE_IDLE)
+			_idle(oh->parent_hwmod);
+		else if (postsetup_state == _HWMOD_STATE_DISABLED)
+			_shutdown(oh->parent_hwmod);
+		else if (postsetup_state != _HWMOD_STATE_ENABLED)
+			WARN(1, "hwmod: %s: unknown postsetup state %d! defaulting to enabled\n",
+			     oh->parent_hwmod->name, postsetup_state);
+	}
+
 	return 0;
 }
 

commit 79005fbd3e1d671d08c45c9140ee9826efdc367c
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Nov 13 09:36:55 2014 -0700

    ARM: OMAP2+: hwmod: drop unnecessary list initialization
    
    ml->node and sl->node are currently initialized
    by means of INIT_LIST_HEAD(). That initialiation
    is followed by a list_add() call.
    
    Looking at what both these functions do we will have:
    
            ml->node.next = &ml->node;
            ml->node.prev = &ml->node;
            oi->master->master_ports.next.prev = &ml->node;
            ml->node.next = &oi->master->master_ports.next;
            ml->node.prev = &oi->master->master_ports;
            oi->master->master_ports.next = &ml->node;
    
    from this, it's clear that both INIT_LIST_HEAD() calls
    are unnecessary and can be safely removed.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 716247ed9e0c..acae6d5d1151 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2832,12 +2832,10 @@ static int __init _add_link(struct omap_hwmod_ocp_if *oi)
 	_alloc_links(&ml, &sl);
 
 	ml->ocp_if = oi;
-	INIT_LIST_HEAD(&ml->node);
 	list_add(&ml->node, &oi->master->master_ports);
 	oi->master->masters_cnt++;
 
 	sl->ocp_if = oi;
-	INIT_LIST_HEAD(&sl->node);
 	list_add(&sl->node, &oi->slave->slave_ports);
 	oi->slave->slaves_cnt++;
 

commit 4984eeaf71f033d1ca6b644e4fcdef4b3e6a97b4
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:26 2014 -0700

    ARM: OMAP3+: PRM: add generic API for reconfiguring I/O chain
    
    This adds a generic API for reconfiguring the I/O chain. The implementation
    will call the SoC specific function registered during init time. The SoC
    specific reconfigure functions are also made static, as they don't need
    to be accessed outside the PRM driver itself.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    [tony@atomide.com: updated for recent omap3 prcm fixes]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index e8098ca28dc5..cedbbb5d4825 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1984,10 +1984,7 @@ static void _reconfigure_io_chain(void)
 
 	spin_lock_irqsave(&io_chain_lock, flags);
 
-	if (cpu_is_omap34xx())
-		omap3xxx_prm_reconfigure_io_chain();
-	else if (cpu_is_omap44xx())
-		omap44xx_prm_reconfigure_io_chain();
+	omap_prm_reconfigure_io_chain();
 
 	spin_unlock_irqrestore(&io_chain_lock, flags);
 }

commit ab6c9bbf28e2b251a61261a95e99d588da73e9a6
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:25 2014 -0700

    ARM: OMAP4: CM: move public definitions from cminst44xx.h to cm44xx.h
    
    cminst44xx.h will be removed, thus move the public APIs to cm44xx.h header.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 48f0d4d29c1b..e8098ca28dc5 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -153,7 +153,6 @@
 #include "powerdomain.h"
 #include "cm2xxx.h"
 #include "cm3xxx.h"
-#include "cminst44xx.h"
 #include "cm33xx.h"
 #include "prm.h"
 #include "prm3xxx.h"

commit 1bc28b3472dc44e6282b464fdb851adcea859be7
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:25 2014 -0700

    ARM: OMAP2+: PRM: add generic API for checking hardreset status
    
    PRM driver now has a generic API for checking hardreset status. SoC
    specific support functions are registered through the prm_ll_data.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 4159368edfe7..48f0d4d29c1b 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2951,8 +2951,8 @@ static int _omap2_deassert_hardreset(struct omap_hwmod *oh,
 static int _omap2_is_hardreset_asserted(struct omap_hwmod *oh,
 					struct omap_hwmod_rst_info *ohri)
 {
-	return omap2_prm_is_hardreset_asserted(oh->prcm.omap2.module_offs,
-					       ohri->st_shift);
+	return omap_prm_is_hardreset_asserted(ohri->st_shift, 0,
+					      oh->prcm.omap2.module_offs, 0);
 }
 
 /**
@@ -3024,10 +3024,11 @@ static int _omap4_is_hardreset_asserted(struct omap_hwmod *oh,
 	if (!oh->clkdm)
 		return -EINVAL;
 
-	return omap4_prminst_is_hardreset_asserted(ohri->rst_shift,
-				oh->clkdm->pwrdm.ptr->prcm_partition,
-				oh->clkdm->pwrdm.ptr->prcm_offs,
-				oh->prcm.omap4.rstctrl_offs);
+	return omap_prm_is_hardreset_asserted(ohri->rst_shift,
+					      oh->clkdm->pwrdm.ptr->
+					      prcm_partition,
+					      oh->clkdm->pwrdm.ptr->prcm_offs,
+					      oh->prcm.omap4.rstctrl_offs);
 }
 
 /**
@@ -3087,9 +3088,9 @@ static int _am33xx_deassert_hardreset(struct omap_hwmod *oh,
 static int _am33xx_is_hardreset_asserted(struct omap_hwmod *oh,
 					struct omap_hwmod_rst_info *ohri)
 {
-	return am33xx_prm_is_hardreset_asserted(ohri->rst_shift,
-				oh->clkdm->pwrdm.ptr->prcm_offs,
-				oh->prcm.omap4.rstctrl_offs);
+	return omap_prm_is_hardreset_asserted(ohri->rst_shift, 0,
+					      oh->clkdm->pwrdm.ptr->prcm_offs,
+					      oh->prcm.omap4.rstctrl_offs);
 }
 
 /* Public functions */

commit 37fb59d7e0b471f3aacd26bfdbb64a4dc71f189b
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:25 2014 -0700

    ARM: OMAP2+: PRM: add generic API for deasserting hardware reset
    
    PRM driver now has a generic API for deasserting hardware resets. SoC
    specific support functions are registered through the prm_ll_data.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 66198e57708f..4159368edfe7 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2932,9 +2932,8 @@ static int _omap2_assert_hardreset(struct omap_hwmod *oh,
 static int _omap2_deassert_hardreset(struct omap_hwmod *oh,
 				     struct omap_hwmod_rst_info *ohri)
 {
-	return omap2_prm_deassert_hardreset(oh->prcm.omap2.module_offs,
-					    ohri->rst_shift,
-					    ohri->st_shift);
+	return omap_prm_deassert_hardreset(ohri->rst_shift, ohri->st_shift, 0,
+					   oh->prcm.omap2.module_offs, 0, 0);
 }
 
 /**
@@ -3001,10 +3000,10 @@ static int _omap4_deassert_hardreset(struct omap_hwmod *oh,
 	if (ohri->st_shift)
 		pr_err("omap_hwmod: %s: %s: hwmod data error: OMAP4 does not support st_shift\n",
 		       oh->name, ohri->name);
-	return omap4_prminst_deassert_hardreset(ohri->rst_shift,
-				oh->clkdm->pwrdm.ptr->prcm_partition,
-				oh->clkdm->pwrdm.ptr->prcm_offs,
-				oh->prcm.omap4.rstctrl_offs);
+	return omap_prm_deassert_hardreset(ohri->rst_shift, 0,
+					   oh->clkdm->pwrdm.ptr->prcm_partition,
+					   oh->clkdm->pwrdm.ptr->prcm_offs,
+					   oh->prcm.omap4.rstctrl_offs, 0);
 }
 
 /**
@@ -3067,11 +3066,10 @@ static int _am33xx_assert_hardreset(struct omap_hwmod *oh,
 static int _am33xx_deassert_hardreset(struct omap_hwmod *oh,
 				     struct omap_hwmod_rst_info *ohri)
 {
-	return am33xx_prm_deassert_hardreset(ohri->rst_shift,
-				ohri->st_shift,
-				oh->clkdm->pwrdm.ptr->prcm_offs,
-				oh->prcm.omap4.rstctrl_offs,
-				oh->prcm.omap4.rstst_offs);
+	return omap_prm_deassert_hardreset(ohri->rst_shift, ohri->st_shift, 0,
+					   oh->clkdm->pwrdm.ptr->prcm_offs,
+					   oh->prcm.omap4.rstctrl_offs,
+					   oh->prcm.omap4.rstst_offs);
 }
 
 /**

commit efd44dc35f550e0cedd983d13e180da5e0d368a9
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:24 2014 -0700

    ARM: OMAP2+: PRM: add generic API for asserting hardware reset
    
    PRM driver now has a generic API for asserting hardware resets. SoC
    specific support functions are registered through the prm_ll_data.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index af4482d3d308..66198e57708f 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2914,8 +2914,8 @@ static int _omap4_wait_target_ready(struct omap_hwmod *oh)
 static int _omap2_assert_hardreset(struct omap_hwmod *oh,
 				   struct omap_hwmod_rst_info *ohri)
 {
-	return omap2_prm_assert_hardreset(oh->prcm.omap2.module_offs,
-					  ohri->rst_shift);
+	return omap_prm_assert_hardreset(ohri->rst_shift, 0,
+					 oh->prcm.omap2.module_offs, 0);
 }
 
 /**
@@ -2974,10 +2974,10 @@ static int _omap4_assert_hardreset(struct omap_hwmod *oh,
 	if (!oh->clkdm)
 		return -EINVAL;
 
-	return omap4_prminst_assert_hardreset(ohri->rst_shift,
-				oh->clkdm->pwrdm.ptr->prcm_partition,
-				oh->clkdm->pwrdm.ptr->prcm_offs,
-				oh->prcm.omap4.rstctrl_offs);
+	return omap_prm_assert_hardreset(ohri->rst_shift,
+					 oh->clkdm->pwrdm.ptr->prcm_partition,
+					 oh->clkdm->pwrdm.ptr->prcm_offs,
+					 oh->prcm.omap4.rstctrl_offs);
 }
 
 /**
@@ -3047,9 +3047,9 @@ static int _am33xx_assert_hardreset(struct omap_hwmod *oh,
 				   struct omap_hwmod_rst_info *ohri)
 
 {
-	return am33xx_prm_assert_hardreset(ohri->rst_shift,
-				oh->clkdm->pwrdm.ptr->prcm_offs,
-				oh->prcm.omap4.rstctrl_offs);
+	return omap_prm_assert_hardreset(ohri->rst_shift, 0,
+					 oh->clkdm->pwrdm.ptr->prcm_offs,
+					 oh->prcm.omap4.rstctrl_offs);
 }
 
 /**

commit 409d70632357122fa89db298256a162bb563a08b
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:24 2014 -0700

    ARM: AM43xx: hwmod: use OMAP4 hardreset ops instead of the AM33xx version
    
    AM43xx is using OMAP4+ PRM driver, so it should be using the corresponding
    hardreset ops from the hwmod also.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 9fec604ee625..af4482d3d308 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -4123,9 +4123,9 @@ void __init omap_hwmod_init(void)
 		soc_ops.enable_module = _omap4_enable_module;
 		soc_ops.disable_module = _omap4_disable_module;
 		soc_ops.wait_target_ready = _omap4_wait_target_ready;
-		soc_ops.assert_hardreset = _am33xx_assert_hardreset;
-		soc_ops.deassert_hardreset = _am33xx_deassert_hardreset;
-		soc_ops.is_hardreset_asserted = _am33xx_is_hardreset_asserted;
+		soc_ops.assert_hardreset = _omap4_assert_hardreset;
+		soc_ops.deassert_hardreset = _omap4_deassert_hardreset;
+		soc_ops.is_hardreset_asserted = _omap4_is_hardreset_asserted;
 		soc_ops.init_clkdm = _init_clkdm;
 	} else if (soc_is_am33xx()) {
 		soc_ops.enable_module = _omap4_enable_module;

commit 05d2b09329ad34a9f8b5b9ac25ab11f4fc077bc7
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:24 2014 -0700

    ARM: AM33xx: hwmod: remove am33xx specific module SoC opts
    
    These are now identical with the OMAP4 implementations, so use the OMAP4
    versions and remove the AM33xx ones.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index a8f57ef1e1d4..9fec604ee625 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -984,25 +984,6 @@ static void _omap4_enable_module(struct omap_hwmod *oh)
 			      oh->clkdm->cm_inst, oh->prcm.omap4.clkctrl_offs);
 }
 
-/**
- * _am33xx_enable_module - enable CLKCTRL modulemode on AM33XX
- * @oh: struct omap_hwmod *
- *
- * Enables the PRCM module mode related to the hwmod @oh.
- * No return value.
- */
-static void _am33xx_enable_module(struct omap_hwmod *oh)
-{
-	if (!oh->clkdm || !oh->prcm.omap4.modulemode)
-		return;
-
-	pr_debug("omap_hwmod: %s: %s: %d\n",
-		 oh->name, __func__, oh->prcm.omap4.modulemode);
-
-	omap_cm_module_enable(oh->prcm.omap4.modulemode, 0, oh->clkdm->cm_inst,
-			      oh->prcm.omap4.clkctrl_offs);
-}
-
 /**
  * _omap4_wait_target_disable - wait for a module to be disabled on OMAP4
  * @oh: struct omap_hwmod *
@@ -1028,30 +1009,6 @@ static int _omap4_wait_target_disable(struct omap_hwmod *oh)
 					oh->prcm.omap4.clkctrl_offs, 0);
 }
 
-/**
- * _am33xx_wait_target_disable - wait for a module to be disabled on AM33XX
- * @oh: struct omap_hwmod *
- *
- * Wait for a module @oh to enter slave idle.  Returns 0 if the module
- * does not have an IDLEST bit or if the module successfully enters
- * slave idle; otherwise, pass along the return value of the
- * appropriate *_cm*_wait_module_idle() function.
- */
-static int _am33xx_wait_target_disable(struct omap_hwmod *oh)
-{
-	if (!oh)
-		return -EINVAL;
-
-	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
-		return 0;
-
-	if (oh->flags & HWMOD_NO_IDLEST)
-		return 0;
-
-	return omap_cm_wait_module_idle(0, oh->clkdm->cm_inst,
-					oh->prcm.omap4.clkctrl_offs, 0);
-}
-
 /**
  * _count_mpu_irqs - count the number of MPU IRQ lines associated with @oh
  * @oh: struct omap_hwmod *oh
@@ -1865,36 +1822,6 @@ static int _omap4_disable_module(struct omap_hwmod *oh)
 	return 0;
 }
 
-/**
- * _am33xx_disable_module - enable CLKCTRL modulemode on AM33XX
- * @oh: struct omap_hwmod *
- *
- * Disable the PRCM module mode related to the hwmod @oh.
- * Return EINVAL if the modulemode is not supported and 0 in case of success.
- */
-static int _am33xx_disable_module(struct omap_hwmod *oh)
-{
-	int v;
-
-	if (!oh->clkdm || !oh->prcm.omap4.modulemode)
-		return -EINVAL;
-
-	pr_debug("omap_hwmod: %s: %s\n", oh->name, __func__);
-
-	if (_are_any_hardreset_lines_asserted(oh))
-		return 0;
-
-	omap_cm_module_disable(0, oh->clkdm->cm_inst,
-			       oh->prcm.omap4.clkctrl_offs);
-
-	v = _am33xx_wait_target_disable(oh);
-	if (v)
-		pr_warn("omap_hwmod: %s: _wait_target_disable failed\n",
-			oh->name);
-
-	return 0;
-}
-
 /**
  * _ocp_softreset - reset an omap_hwmod via the OCP_SYSCONFIG bit
  * @oh: struct omap_hwmod *
@@ -2973,32 +2900,6 @@ static int _omap4_wait_target_ready(struct omap_hwmod *oh)
 					 oh->prcm.omap4.clkctrl_offs, 0);
 }
 
-/**
- * _am33xx_wait_target_ready - wait for a module to leave slave idle
- * @oh: struct omap_hwmod *
- *
- * Wait for a module @oh to leave slave idle.  Returns 0 if the module
- * does not have an IDLEST bit or if the module successfully leaves
- * slave idle; otherwise, pass along the return value of the
- * appropriate *_cm*_wait_module_ready() function.
- */
-static int _am33xx_wait_target_ready(struct omap_hwmod *oh)
-{
-	if (!oh || !oh->clkdm)
-		return -EINVAL;
-
-	if (oh->flags & HWMOD_NO_IDLEST)
-		return 0;
-
-	if (!_find_mpu_rt_port(oh))
-		return 0;
-
-	/* XXX check module SIDLEMODE, hardreset status */
-
-	return omap_cm_wait_module_ready(0, oh->clkdm->cm_inst,
-					 oh->prcm.omap4.clkctrl_offs, 0);
-}
-
 /**
  * _omap2_assert_hardreset - call OMAP2 PRM hardreset fn with hwmod args
  * @oh: struct omap_hwmod * to assert hardreset
@@ -4227,9 +4128,9 @@ void __init omap_hwmod_init(void)
 		soc_ops.is_hardreset_asserted = _am33xx_is_hardreset_asserted;
 		soc_ops.init_clkdm = _init_clkdm;
 	} else if (soc_is_am33xx()) {
-		soc_ops.enable_module = _am33xx_enable_module;
-		soc_ops.disable_module = _am33xx_disable_module;
-		soc_ops.wait_target_ready = _am33xx_wait_target_ready;
+		soc_ops.enable_module = _omap4_enable_module;
+		soc_ops.disable_module = _omap4_disable_module;
+		soc_ops.wait_target_ready = _omap4_wait_target_ready;
 		soc_ops.assert_hardreset = _am33xx_assert_hardreset;
 		soc_ops.deassert_hardreset = _am33xx_deassert_hardreset;
 		soc_ops.is_hardreset_asserted = _am33xx_is_hardreset_asserted;

commit 128603f05af371acc09e4cfd9124388f1b3e2966
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:24 2014 -0700

    ARM: OMAP2+: CM: add common APIs for cm_module_enable/disable
    
    Adds a generic CM driver API for enabling/disabling modules.
    The SoC specific implementations are registered through cm_ll_data.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 03a42b37ef18..a8f57ef1e1d4 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -979,11 +979,9 @@ static void _omap4_enable_module(struct omap_hwmod *oh)
 	pr_debug("omap_hwmod: %s: %s: %d\n",
 		 oh->name, __func__, oh->prcm.omap4.modulemode);
 
-	omap4_cminst_module_enable(oh->prcm.omap4.modulemode,
-				   oh->clkdm->prcm_partition,
-				   oh->clkdm->cm_inst,
-				   oh->clkdm->clkdm_offs,
-				   oh->prcm.omap4.clkctrl_offs);
+	omap_cm_module_enable(oh->prcm.omap4.modulemode,
+			      oh->clkdm->prcm_partition,
+			      oh->clkdm->cm_inst, oh->prcm.omap4.clkctrl_offs);
 }
 
 /**
@@ -1001,9 +999,8 @@ static void _am33xx_enable_module(struct omap_hwmod *oh)
 	pr_debug("omap_hwmod: %s: %s: %d\n",
 		 oh->name, __func__, oh->prcm.omap4.modulemode);
 
-	am33xx_cm_module_enable(oh->prcm.omap4.modulemode, oh->clkdm->cm_inst,
-				oh->clkdm->clkdm_offs,
-				oh->prcm.omap4.clkctrl_offs);
+	omap_cm_module_enable(oh->prcm.omap4.modulemode, 0, oh->clkdm->cm_inst,
+			      oh->prcm.omap4.clkctrl_offs);
 }
 
 /**
@@ -1857,10 +1854,8 @@ static int _omap4_disable_module(struct omap_hwmod *oh)
 
 	pr_debug("omap_hwmod: %s: %s\n", oh->name, __func__);
 
-	omap4_cminst_module_disable(oh->clkdm->prcm_partition,
-				    oh->clkdm->cm_inst,
-				    oh->clkdm->clkdm_offs,
-				    oh->prcm.omap4.clkctrl_offs);
+	omap_cm_module_disable(oh->clkdm->prcm_partition, oh->clkdm->cm_inst,
+			       oh->prcm.omap4.clkctrl_offs);
 
 	v = _omap4_wait_target_disable(oh);
 	if (v)
@@ -1889,8 +1884,8 @@ static int _am33xx_disable_module(struct omap_hwmod *oh)
 	if (_are_any_hardreset_lines_asserted(oh))
 		return 0;
 
-	am33xx_cm_module_disable(oh->clkdm->cm_inst, oh->clkdm->clkdm_offs,
-				 oh->prcm.omap4.clkctrl_offs);
+	omap_cm_module_disable(0, oh->clkdm->cm_inst,
+			       oh->prcm.omap4.clkctrl_offs);
 
 	v = _am33xx_wait_target_disable(oh);
 	if (v)

commit a8ae5afa5cb820afa251b9acfe3f0a938b6a6c0d
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:23 2014 -0700

    ARM: OMAP4+/AM33xx: CM: add common API for cm_wait_module_idle
    
    Adds a generic CM driver API for waiting module to enter idle / standby.
    The SoC specific implementations are registered through cm_ll_data.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 1f7dd7dca7bb..03a42b37ef18 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1026,9 +1026,9 @@ static int _omap4_wait_target_disable(struct omap_hwmod *oh)
 	if (oh->flags & HWMOD_NO_IDLEST)
 		return 0;
 
-	return omap4_cminst_wait_module_idle(oh->clkdm->prcm_partition,
-					     oh->clkdm->cm_inst,
-					     oh->prcm.omap4.clkctrl_offs);
+	return omap_cm_wait_module_idle(oh->clkdm->prcm_partition,
+					oh->clkdm->cm_inst,
+					oh->prcm.omap4.clkctrl_offs, 0);
 }
 
 /**
@@ -1051,8 +1051,8 @@ static int _am33xx_wait_target_disable(struct omap_hwmod *oh)
 	if (oh->flags & HWMOD_NO_IDLEST)
 		return 0;
 
-	return am33xx_cm_wait_module_idle(oh->clkdm->cm_inst,
-					     oh->prcm.omap4.clkctrl_offs);
+	return omap_cm_wait_module_idle(0, oh->clkdm->cm_inst,
+					oh->prcm.omap4.clkctrl_offs, 0);
 }
 
 /**

commit 021b6ff05c4a17cb20d71c05e251ea7f80b1c516
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:23 2014 -0700

    ARM: OMAP2+: CM: add common API for cm_wait_module_ready
    
    This patch consolidates the parameters provided for the SoC specific
    cm_*_wait_module_ready calls, adds the missing cm_ll_data function
    pointers and uses the now generic call from the mach-omap2 board code.
    SoC specific *_wait_module_ready calls are also made static so they
    can only be accessed through the generic CM driver API only.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 2dca1a896943..1f7dd7dca7bb 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2946,9 +2946,9 @@ static int _omap2xxx_3xxx_wait_target_ready(struct omap_hwmod *oh)
 
 	/* XXX check module SIDLEMODE, hardreset status, enabled clocks */
 
-	return omap2xxx_cm_wait_module_ready(oh->prcm.omap2.module_offs,
-					     oh->prcm.omap2.idlest_reg_id,
-					     oh->prcm.omap2.idlest_idle_bit);
+	return omap_cm_wait_module_ready(0, oh->prcm.omap2.module_offs,
+					 oh->prcm.omap2.idlest_reg_id,
+					 oh->prcm.omap2.idlest_idle_bit);
 }
 
 /**
@@ -2973,9 +2973,9 @@ static int _omap4_wait_target_ready(struct omap_hwmod *oh)
 
 	/* XXX check module SIDLEMODE, hardreset status */
 
-	return omap4_cminst_wait_module_ready(oh->clkdm->prcm_partition,
-					      oh->clkdm->cm_inst,
-					      oh->prcm.omap4.clkctrl_offs);
+	return omap_cm_wait_module_ready(oh->clkdm->prcm_partition,
+					 oh->clkdm->cm_inst,
+					 oh->prcm.omap4.clkctrl_offs, 0);
 }
 
 /**
@@ -3000,8 +3000,8 @@ static int _am33xx_wait_target_ready(struct omap_hwmod *oh)
 
 	/* XXX check module SIDLEMODE, hardreset status */
 
-	return am33xx_cm_wait_module_ready(oh->clkdm->cm_inst,
-					      oh->prcm.omap4.clkctrl_offs);
+	return omap_cm_wait_module_ready(0, oh->clkdm->cm_inst,
+					 oh->prcm.omap4.clkctrl_offs, 0);
 }
 
 /**

commit 9907f85eb27d98c2184a56f3b636cb82536807a0
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:23 2014 -0700

    ARM: AM33xx/OMAP4+: CM: remove cdoffs parameter from wait_module_idle/ready
    
    This is not needed for anything. This also eases the consolidation of
    the wait_module_ready / wait_module_idle calls behind a generic CM
    driver API by reducing the number of needed parameters.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 67bf7274ce89..2dca1a896943 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1028,7 +1028,6 @@ static int _omap4_wait_target_disable(struct omap_hwmod *oh)
 
 	return omap4_cminst_wait_module_idle(oh->clkdm->prcm_partition,
 					     oh->clkdm->cm_inst,
-					     oh->clkdm->clkdm_offs,
 					     oh->prcm.omap4.clkctrl_offs);
 }
 
@@ -1053,7 +1052,6 @@ static int _am33xx_wait_target_disable(struct omap_hwmod *oh)
 		return 0;
 
 	return am33xx_cm_wait_module_idle(oh->clkdm->cm_inst,
-					     oh->clkdm->clkdm_offs,
 					     oh->prcm.omap4.clkctrl_offs);
 }
 
@@ -2977,7 +2975,6 @@ static int _omap4_wait_target_ready(struct omap_hwmod *oh)
 
 	return omap4_cminst_wait_module_ready(oh->clkdm->prcm_partition,
 					      oh->clkdm->cm_inst,
-					      oh->clkdm->clkdm_offs,
 					      oh->prcm.omap4.clkctrl_offs);
 }
 
@@ -3004,7 +3001,6 @@ static int _am33xx_wait_target_ready(struct omap_hwmod *oh)
 	/* XXX check module SIDLEMODE, hardreset status */
 
 	return am33xx_cm_wait_module_ready(oh->clkdm->cm_inst,
-					      oh->clkdm->clkdm_offs,
 					      oh->prcm.omap4.clkctrl_offs);
 }
 

commit 9002e921aa9a97de9de86fad34917c573dfc822b
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 27 08:39:23 2014 -0700

    ARM: OMAP2/3: hwmod: merge wait_target_ready functions for omap2/3
    
    The implementation on these is identical, so no need to have them separate.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 716247ed9e0c..67bf7274ce89 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2927,7 +2927,7 @@ static int __init _alloc_linkspace(struct omap_hwmod_ocp_if **ois)
 /* Static functions intended only for use in soc_ops field function pointers */
 
 /**
- * _omap2xxx_wait_target_ready - wait for a module to leave slave idle
+ * _omap2xxx_3xxx_wait_target_ready - wait for a module to leave slave idle
  * @oh: struct omap_hwmod *
  *
  * Wait for a module @oh to leave slave idle.  Returns 0 if the module
@@ -2935,7 +2935,7 @@ static int __init _alloc_linkspace(struct omap_hwmod_ocp_if **ois)
  * slave idle; otherwise, pass along the return value of the
  * appropriate *_cm*_wait_module_ready() function.
  */
-static int _omap2xxx_wait_target_ready(struct omap_hwmod *oh)
+static int _omap2xxx_3xxx_wait_target_ready(struct omap_hwmod *oh)
 {
 	if (!oh)
 		return -EINVAL;
@@ -2953,33 +2953,6 @@ static int _omap2xxx_wait_target_ready(struct omap_hwmod *oh)
 					     oh->prcm.omap2.idlest_idle_bit);
 }
 
-/**
- * _omap3xxx_wait_target_ready - wait for a module to leave slave idle
- * @oh: struct omap_hwmod *
- *
- * Wait for a module @oh to leave slave idle.  Returns 0 if the module
- * does not have an IDLEST bit or if the module successfully leaves
- * slave idle; otherwise, pass along the return value of the
- * appropriate *_cm*_wait_module_ready() function.
- */
-static int _omap3xxx_wait_target_ready(struct omap_hwmod *oh)
-{
-	if (!oh)
-		return -EINVAL;
-
-	if (oh->flags & HWMOD_NO_IDLEST)
-		return 0;
-
-	if (!_find_mpu_rt_port(oh))
-		return 0;
-
-	/* XXX check module SIDLEMODE, hardreset status, enabled clocks */
-
-	return omap3xxx_cm_wait_module_ready(oh->prcm.omap2.module_offs,
-					     oh->prcm.omap2.idlest_reg_id,
-					     oh->prcm.omap2.idlest_idle_bit);
-}
-
 /**
  * _omap4_wait_target_ready - wait for a module to leave slave idle
  * @oh: struct omap_hwmod *
@@ -4234,12 +4207,12 @@ int omap_hwmod_pad_route_irq(struct omap_hwmod *oh, int pad_idx, int irq_idx)
 void __init omap_hwmod_init(void)
 {
 	if (cpu_is_omap24xx()) {
-		soc_ops.wait_target_ready = _omap2xxx_wait_target_ready;
+		soc_ops.wait_target_ready = _omap2xxx_3xxx_wait_target_ready;
 		soc_ops.assert_hardreset = _omap2_assert_hardreset;
 		soc_ops.deassert_hardreset = _omap2_deassert_hardreset;
 		soc_ops.is_hardreset_asserted = _omap2_is_hardreset_asserted;
 	} else if (cpu_is_omap34xx()) {
-		soc_ops.wait_target_ready = _omap3xxx_wait_target_ready;
+		soc_ops.wait_target_ready = _omap2xxx_3xxx_wait_target_ready;
 		soc_ops.assert_hardreset = _omap2_assert_hardreset;
 		soc_ops.deassert_hardreset = _omap2_deassert_hardreset;
 		soc_ops.is_hardreset_asserted = _omap2_is_hardreset_asserted;

commit cf377ad7d42c566356d79049536d9cb37499cb77
Merge: 212fe84a6f21 d8f0faa339b0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 8 17:13:04 2014 -0400

    Merge tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform changes from Arnd Bergmann:
     "New and updated SoC support.  Among the things new for this release
      are:
    
       - at91: Added support for the new SAMA5D4 SoC, following the earlier
         SAMA5D3
       - bcm: Added support for BCM63XX family of DSL SoCs
       - hisi: Added support for HiP04 server-class SoC
       - meson: Initial support for the Amlogic Meson6 (aka 8726MX) platform
       - shmobile: added support for new r8a7794 (R-Car E2) automotive SoC
    
      Noteworthy changes to existing SoC support are:
    
       - imx: convert i.MX1 to device tree
       - omap: lots of power management work
       - omap: base support to enable moving to standard UART driver
       - shmobile: lots of progress for multiplatform support, still
         ongoing"
    
    * tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (171 commits)
      ARM: hisi: depend on ARCH_MULTI_V7
      CNS3xxx: Fix debug UART.
      ARM: at91: fix nommu build regression
      ARM: meson: add basic support for MesonX SoCs
      ARM: meson: debug: add debug UART for earlyprintk support
      irq: Export handle_fasteoi_irq
      ARM: mediatek: Add earlyprintk support for mt6589
      ARM: hisi: Fix platmcpm compilation when ARMv6 is selected
      ARM: debug: fix alphanumerical order on debug uarts
      ARM: at91: document Atmel SMART compatibles
      ARM: at91: add sama5d4 support to sama5_defconfig
      ARM: at91: dt: add device tree file for SAMA5D4ek board
      ARM: at91: dt: add device tree file for SAMA5D4 SoC
      ARM: at91: SAMA5D4 SoC detection code and low level routines
      ARM: at91: introduce basic SAMA5D4 support
      clk: at91: add a driver for the h32mx clock
      ARM: pxa3xx: provide specific platform_devices for all ssp ports
      ARM: pxa: ssp: provide platform_device_id for PXA3xx
      ARM: OMAP4+: Remove static iotable mappings for SRAM
      ARM: OMAP4+: Move SRAM data to DT
      ...

commit 212fe84a6f215c39795a76517c1c02114d428681
Merge: 4a4743e840d0 05301fe7de11
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 8 17:06:53 2014 -0400

    Merge tag 'cleanup-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC cleanups from Arnd Bergmann:
     "This time around, the cleanup branch contains mostly code removal.  A
      number of board files for at91, imx and msm have become obsolete
      because of the DT conversion and are now ready to be removed.  The
      OMAP platform has traditionally had its own DMA engine abstraction and
      as this is being phased out, a lot of the original code is now unused
      and can be removed as well.
    
      S3C24xx can be simplified now that the restart code is a proper device
      driver.
    
      Finally, a number of cleanups in shmobile are done to prepare for the
      addition of new code in other branches"
    
    * tag 'cleanup-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (43 commits)
      ARM: at91: Remove the support for the RSI EWS board
      arm: mach-omap2: Convert pr_warning to pr_warn
      ARM: OMAP: Remove unused pieces of legacy DMA API
      ARM: at91: remove board file for Acme Systems Fox G20
      ARM: orion5x: Convert pr_warning to pr_warn
      ARM: S3C24XX: remove separate restart code
      ARM: EXYNOS: Do not calculate boot address twice
      ARM: sunxi: Remove sun4i reboot code from mach directory
      ARM: imx: Remove mach-mxt_td60 board file
      ARM: shmobile: armadillo800eva legacy: Use rmobile_add_devices_to_domains()
      ARM: shmobile: r8a7740: Clean up pm domain table
      ARM: shmobile: r8a7740: Use rmobile_add_devices_to_domains()
      ARM: shmobile: sh7372: Make domain_devices[] static __initdata
      ARM: shmobile: mackerel: Make domain_devices[] static __initdata
      clocksource: tcb_clksrc: sanitize IRQ request
      ARM: at91/tclib: mask interruptions at shutdown and probe
      ARM: at91/tclib: move initialization from alloc to probe
      ARM: at91/tclib: prefer using of devm_* functions
      ARM: clps711x: Switch CLPS711X subarch to use clk and clocksource driver
      ARM: shmobile: r8a7791 is now called "R-Car M2-W"
      ...

commit ddfe53d1cbfcb214f7ea58f13e811937dc74663e
Merge: 2b3a47d7a0cd 3d0cb73e9c85
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Sep 26 00:09:49 2014 +0200

    Merge tag 'cleanup-for-v3.18' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into next/cleanup
    
    Pull "Clean-up for omaps for v3.18 merge window" from Tony Lindgren:
    
    - Remove unused pieces of the legacy DMA API as we're moving to
      dmaengine API
    
    - Search and replace to standardize on pr_warn instead of pr_warning
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    
    * tag 'cleanup-for-v3.18' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap:
      arm: mach-omap2: Convert pr_warning to pr_warn
      ARM: OMAP: Remove unused pieces of legacy DMA API

commit 3d0cb73e9c85e60206ea9d5191bc0b9a0c4c8a99
Author: Joe Perches <joe@perches.com>
Date:   Sat Sep 13 11:31:16 2014 -0700

    arm: mach-omap2: Convert pr_warning to pr_warn
    
    Use the more common pr_warn.
    
    Other miscellanea:
    
    o Realign arguments
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 6c074f37cdd2..4fe3aadae732 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -769,8 +769,8 @@ static int _init_main_clk(struct omap_hwmod *oh)
 
 	oh->_clk = clk_get(NULL, oh->main_clk);
 	if (IS_ERR(oh->_clk)) {
-		pr_warning("omap_hwmod: %s: cannot clk_get main_clk %s\n",
-			   oh->name, oh->main_clk);
+		pr_warn("omap_hwmod: %s: cannot clk_get main_clk %s\n",
+			oh->name, oh->main_clk);
 		return -EINVAL;
 	}
 	/*
@@ -814,8 +814,8 @@ static int _init_interface_clks(struct omap_hwmod *oh)
 
 		c = clk_get(NULL, os->clk);
 		if (IS_ERR(c)) {
-			pr_warning("omap_hwmod: %s: cannot clk_get interface_clk %s\n",
-				   oh->name, os->clk);
+			pr_warn("omap_hwmod: %s: cannot clk_get interface_clk %s\n",
+				oh->name, os->clk);
 			ret = -EINVAL;
 			continue;
 		}
@@ -851,8 +851,8 @@ static int _init_opt_clks(struct omap_hwmod *oh)
 	for (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++) {
 		c = clk_get(NULL, oc->clk);
 		if (IS_ERR(c)) {
-			pr_warning("omap_hwmod: %s: cannot clk_get opt_clk %s\n",
-				   oh->name, oc->clk);
+			pr_warn("omap_hwmod: %s: cannot clk_get opt_clk %s\n",
+				oh->name, oc->clk);
 			ret = -EINVAL;
 			continue;
 		}
@@ -1576,7 +1576,7 @@ static int _init_clkdm(struct omap_hwmod *oh)
 
 	oh->clkdm = clkdm_lookup(oh->clkdm_name);
 	if (!oh->clkdm) {
-		pr_warning("omap_hwmod: %s: could not associate to clkdm %s\n",
+		pr_warn("omap_hwmod: %s: could not associate to clkdm %s\n",
 			oh->name, oh->clkdm_name);
 		return 0;
 	}
@@ -1616,7 +1616,7 @@ static int _init_clocks(struct omap_hwmod *oh, void *data)
 	if (!ret)
 		oh->_state = _HWMOD_STATE_CLKS_INITED;
 	else
-		pr_warning("omap_hwmod: %s: cannot _init_clocks\n", oh->name);
+		pr_warn("omap_hwmod: %s: cannot _init_clocks\n", oh->name);
 
 	return ret;
 }
@@ -1739,7 +1739,7 @@ static int _deassert_hardreset(struct omap_hwmod *oh, const char *name)
 	_disable_clocks(oh);
 
 	if (ret == -EBUSY)
-		pr_warning("omap_hwmod: %s: failed to hardreset\n", oh->name);
+		pr_warn("omap_hwmod: %s: failed to hardreset\n", oh->name);
 
 	if (!ret) {
 		/*
@@ -1953,8 +1953,8 @@ static int _ocp_softreset(struct omap_hwmod *oh)
 
 	c = _wait_softreset_complete(oh);
 	if (c == MAX_MODULE_SOFTRESET_WAIT) {
-		pr_warning("omap_hwmod: %s: softreset failed (waited %d usec)\n",
-			   oh->name, MAX_MODULE_SOFTRESET_WAIT);
+		pr_warn("omap_hwmod: %s: softreset failed (waited %d usec)\n",
+			oh->name, MAX_MODULE_SOFTRESET_WAIT);
 		ret = -ETIMEDOUT;
 		goto dis_opt_clks;
 	} else {
@@ -2614,8 +2614,8 @@ static int __init _setup_reset(struct omap_hwmod *oh)
 	if (oh->rst_lines_cnt == 0) {
 		r = _enable(oh);
 		if (r) {
-			pr_warning("omap_hwmod: %s: cannot be enabled for reset (%d)\n",
-				   oh->name, oh->_state);
+			pr_warn("omap_hwmod: %s: cannot be enabled for reset (%d)\n",
+				oh->name, oh->_state);
 			return -EINVAL;
 		}
 	}

commit 6a08b11adda53b89d32d4becac4d7f062a0e2d99
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Sep 18 08:58:28 2014 -0700

    ARM: OMAP2+: Add hwmod flag for HWMOD_RECONFIG_IO_CHAIN
    
    Commit cc824534d4fe ("ARM: OMAP2+: hwmod: Rearm wake-up interrupts
    for DT when MUSB is idled") fixed issues with hung UART wake-up
    events by calling _reconfigure_io_chain() when MUSB is connected
    or disconnected.
    
    As pointed out by Paul Walmsley, we may need to also call
    _reconfigure_io_chain() in other cases, so it should be a separate
    flag. Let's add HWMOD_RECONFIG_IO_CHAIN as suggested by Paul.
    
    Reviewed-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 8fd87a3055bf..e96808ef1adb 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2185,7 +2185,7 @@ static int _enable(struct omap_hwmod *oh)
 			 oh->mux->pads_dynamic))) {
 		omap_hwmod_mux(oh->mux, _HWMOD_STATE_ENABLED);
 		_reconfigure_io_chain();
-	} else if (oh->flags & HWMOD_FORCE_MSTANDBY) {
+	} else if (oh->flags & HWMOD_RECONFIG_IO_CHAIN) {
 		_reconfigure_io_chain();
 	}
 
@@ -2293,7 +2293,7 @@ static int _idle(struct omap_hwmod *oh)
 	if (oh->mux && oh->mux->pads_dynamic) {
 		omap_hwmod_mux(oh->mux, _HWMOD_STATE_IDLE);
 		_reconfigure_io_chain();
-	} else if (oh->flags & HWMOD_FORCE_MSTANDBY) {
+	} else if (oh->flags & HWMOD_RECONFIG_IO_CHAIN) {
 		_reconfigure_io_chain();
 	}
 

commit 7db143b89137de06ed289cf8b302f3bbbc5baa1f
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Sep 16 15:09:44 2014 -0700

    ARM: OMAP3: Fix I/O chain clock line assertion timed out error
    
    We are getting "PRM: I/O chain clock line assertion timed out" errors
    on early omaps for device tree based booting. This is because we are
    unconditionally calling reconfigure_io_chain while legacy booting
    has omap3_has_io_chain_ctrl() checks in place in omap_hwmod.c.
    
    For device tree based booting, we are calling reconfigure_io_chain
    unconditionally from pinctrl framework. So we need to add a check for
    omap3_has_io_chain_ctrl() to avoid the errors for trying to access
    a register that does not exist.
    
    For es3.0, the documentation in "4.11.2 Device Off-Mode Configuration"
    just mentions PM_WKEN_WKUP[8] bit. For es3.1, there's a new chapter in
    documentation for "4.11.2.2 I/O Wake-Up Mechanism" that describes the
    PM_WKEN_WKUP[16] ST_IO_CHAIN bit. So PM_WKEN_WKUP[16] bit did not get
    added until in es3.1 probaly to fix issues with flakey wake-up events.
    
    We are doing proper checks for ST_IO_CHAIN already in id.c and with
    omap3_has_io_chain_ctrl(). For more information, see also commit
    b02b917211d5 ("ARM: OMAP3: PM: fix I/O wakeup and I/O chain clock
    control detection").
    
    Let's fix the issue by selecting the right function during init for
    reconfigure_io_chain depending on the omap revision. For es3.0 and
    earlier we need to just toggle EN_IO. By doing this, we can move the
    check for omap3_has_io_chain_ctrl() from omap_hwmod.c to the init code
    in prm_3xxx.c. And then we can unconditionally call reconfigure_io_chain.
    
    Thanks to Paul Walmsley and Nishanth Menon for help with debugging the
    issue.
    
    Fixes: 30a69ef785e8 ("ARM: OMAP: Move DT wake-up event handling over to use pinctrl-single-omap")
    Cc: Kevin Hilman <khilman@kernel.org>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Reviewed-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 8fd87a3055bf..9e91a4e7519a 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2065,7 +2065,7 @@ static void _reconfigure_io_chain(void)
 
 	spin_lock_irqsave(&io_chain_lock, flags);
 
-	if (cpu_is_omap34xx() && omap3_has_io_chain_ctrl())
+	if (cpu_is_omap34xx())
 		omap3xxx_prm_reconfigure_io_chain();
 	else if (cpu_is_omap44xx())
 		omap44xx_prm_reconfigure_io_chain();

commit 98fd1508363a3e717f480795d8030430c298508a
Merge: 0dc0d9e18e7d f7f7a29bf0cf
Author: Olof Johansson <olof@lixom.net>
Date:   Sun Aug 31 10:19:09 2014 -0700

    Merge tag 'for-v3.17-rc/omap-dra72x-d74x-support-a' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into fixes
    
    Pull "ARM: OMAP2+: DRA72x/DRA74x basic support" from Tony Lindgren:
    
    Add basic subarchitecture support for the DRA72x and DRA74x.  These
    are OMAP2+ derivative SoCs.  This should be low-risk to existing OMAP
    platforms.
    
    Basic build, boot, and PM test logs are available here:
    
    http://www.pwsan.com/omap/testlogs/hwmod-a-early-v3.17-rc/20140827194314/
    
    * tag 'for-v3.17-rc/omap-dra72x-d74x-support-a' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending:
      ARM: DRA7: hwmod: Add dra74x and dra72x specific ocp interface lists
      ARM: DRA7: Add support for soc_is_dra74x() and soc_is_dra72x() variants
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit f7f7a29bf0cf25af23f37e5b5bf1368b85705286
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Wed Aug 27 19:38:23 2014 -0600

    ARM: DRA7: hwmod: Add dra74x and dra72x specific ocp interface lists
    
    To deal with IPs which are specific to dra74x and dra72x, maintain seperate
    ocp interface lists, while keeping the common list for all common IPs.
    
    Move USB OTG SS4 to dra74x only list since its unavailable in
    dra72x and is giving an abort during boot. The dra72x only list
    is empty for now and a placeholder for future hwmod additions which
    are specific to dra72x.
    
    Fixes: d904b38df0db13 ("ARM: DRA7: hwmod: Add SYSCONFIG for usb_otg_ss")
    Reported-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    [paul@pwsan.com: fixed comment style to conform with CodingStyle]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 6c074f37cdd2..bc2466cc33b9 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3345,6 +3345,9 @@ int __init omap_hwmod_register_links(struct omap_hwmod_ocp_if **ois)
 	if (!ois)
 		return 0;
 
+	if (ois[0] == NULL) /* Empty list */
+		return 0;
+
 	if (!linkspace) {
 		if (_alloc_linkspace(ois)) {
 			pr_err("omap_hwmod: could not allocate link space\n");

commit cc824534d4fef0e46e4486d5c1e10d3c6b1ebadc
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Aug 25 16:15:35 2014 -0700

    ARM: OMAP2+: hwmod: Rearm wake-up interrupts for DT when MUSB is idled
    
    Looks like MUSB cable removal can cause wake-up interrupts to
    stop working for device tree based booting at least for UART3
    even as nothing is dynamically remuxed. This can be fixed by
    calling reconfigure_io_chain() for device tree based booting
    in hwmod code. Note that we already do that for legacy booting
    if the legacy mux is configured.
    
    My guess is that this is related to UART3 and MUSB ULPI
    hsusb0_data0 and hsusb0_data1 support for Carkit mode that
    somehow affect the configured IO chain for UART3 and require
    rearming the wake-up interrupts.
    
    In general, for device tree based booting, pinctrl-single
    calls the rearm hook that in turn calls reconfigure_io_chain
    so calling reconfigure_io_chain should not be needed from the
    hwmod code for other events.
    
    So let's limit the hwmod rearming of iochain only to
    HWMOD_FORCE_MSTANDBY where MUSB is currently the only user
    of it. If we see other devices needing similar changes we can
    add more checks for it.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: stable@vger.kernel.org # v3.16
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 6c074f37cdd2..da1b256caccc 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2185,6 +2185,8 @@ static int _enable(struct omap_hwmod *oh)
 			 oh->mux->pads_dynamic))) {
 		omap_hwmod_mux(oh->mux, _HWMOD_STATE_ENABLED);
 		_reconfigure_io_chain();
+	} else if (oh->flags & HWMOD_FORCE_MSTANDBY) {
+		_reconfigure_io_chain();
 	}
 
 	_add_initiator_dep(oh, mpu_oh);
@@ -2291,6 +2293,8 @@ static int _idle(struct omap_hwmod *oh)
 	if (oh->mux && oh->mux->pads_dynamic) {
 		omap_hwmod_mux(oh->mux, _HWMOD_STATE_IDLE);
 		_reconfigure_io_chain();
+	} else if (oh->flags & HWMOD_FORCE_MSTANDBY) {
+		_reconfigure_io_chain();
 	}
 
 	oh->_state = _HWMOD_STATE_IDLE;

commit 98bbc114bfa0ea1da31e230050b437e19e49e2b3
Author: Dave Gerlach <d-gerlach@ti.com>
Date:   Sun Jun 15 16:02:17 2014 -0600

    ARM: OMAP2+: hwmod: Change hardreset soc_ops for AM43XX
    
    am43xx reset register layout is more similar to am33xx than omap4 so
    use the am33xx functions for hwmod hardreset soc_ops rather than the
    currently used omap4 functions. Without this, assert_hardreset and
    deassert_hardreset will not work on am43xx.
    
    Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
    [paul@pwsan.com: fixed build errors for an AM43xx-only Kconfig]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index f7bb435bb543..6c074f37cdd2 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -4251,9 +4251,9 @@ void __init omap_hwmod_init(void)
 		soc_ops.enable_module = _omap4_enable_module;
 		soc_ops.disable_module = _omap4_disable_module;
 		soc_ops.wait_target_ready = _omap4_wait_target_ready;
-		soc_ops.assert_hardreset = _omap4_assert_hardreset;
-		soc_ops.deassert_hardreset = _omap4_deassert_hardreset;
-		soc_ops.is_hardreset_asserted = _omap4_is_hardreset_asserted;
+		soc_ops.assert_hardreset = _am33xx_assert_hardreset;
+		soc_ops.deassert_hardreset = _am33xx_deassert_hardreset;
+		soc_ops.is_hardreset_asserted = _am33xx_is_hardreset_asserted;
 		soc_ops.init_clkdm = _init_clkdm;
 	} else if (soc_is_am33xx()) {
 		soc_ops.enable_module = _am33xx_enable_module;

commit edfaf05c2fcb853fcf35f12aeb9c340f5913337f
Author: Victor Kamensky <victor.kamensky@linaro.org>
Date:   Tue Apr 15 20:37:46 2014 +0300

    ARM: OMAP2+: raw read and write endian fix
    
    All OMAP IP blocks expect LE data, but CPU may operate in BE mode.
    Need to use endian neutral functions to read/write h/w registers.
    I.e instead of __raw_read[lw] and __raw_write[lw] functions code
    need to use read[lw]_relaxed and write[lw]_relaxed functions.
    If the first simply reads/writes register, the second will byteswap
    it if host operates in BE mode.
    
    Changes are trivial sed like replacement of __raw_xxx functions
    with xxx_relaxed variant.
    
    Signed-off-by: Victor Kamensky <victor.kamensky@linaro.org>
    Signed-off-by: Taras Kondratiuk <taras.kondratiuk@linaro.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 66c60fe1104c..f7bb435bb543 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -72,7 +72,7 @@
  *            | (../mach-omap2/omap_hwmod*)   |
  *            +-------------------------------+
  *            | OMAP clock/PRCM/register fns  |
- *            | (__raw_{read,write}l, clk*)   |
+ *            | ({read,write}l_relaxed, clk*) |
  *            +-------------------------------+
  *
  * Device drivers should not contain any OMAP-specific code or data in
@@ -3230,17 +3230,17 @@ static int _am33xx_is_hardreset_asserted(struct omap_hwmod *oh,
 u32 omap_hwmod_read(struct omap_hwmod *oh, u16 reg_offs)
 {
 	if (oh->flags & HWMOD_16BIT_REG)
-		return __raw_readw(oh->_mpu_rt_va + reg_offs);
+		return readw_relaxed(oh->_mpu_rt_va + reg_offs);
 	else
-		return __raw_readl(oh->_mpu_rt_va + reg_offs);
+		return readl_relaxed(oh->_mpu_rt_va + reg_offs);
 }
 
 void omap_hwmod_write(u32 v, struct omap_hwmod *oh, u16 reg_offs)
 {
 	if (oh->flags & HWMOD_16BIT_REG)
-		__raw_writew(v, oh->_mpu_rt_va + reg_offs);
+		writew_relaxed(v, oh->_mpu_rt_va + reg_offs);
 	else
-		__raw_writel(v, oh->_mpu_rt_va + reg_offs);
+		writel_relaxed(v, oh->_mpu_rt_va + reg_offs);
 }
 
 /**

commit 3d36ad7e7a9be0d130c862727a052ed279046437
Author: Suman Anna <s-anna@ti.com>
Date:   Fri Mar 14 14:45:17 2014 +0530

    ARM: OMAP2+: hwmod: fix missing braces in _init()
    
    Bug was introduced by commit 'f92d959: ARM: OMAP2+: hwmod:
    Extract no-idle and no-reset info from DT'
    
    There were 2 versions of the patch posted which resulted in the above
    commit. While v1 [1] had the bug, v2 [2] had it fixed.
    However v1 apparently seemed to have been pulled in by mistake
    introducing the bug.
    
    Given of_find_property() does return NULL when the node passed is
    NULL, it did not introduce any functional issues as such, just the
    fact that the second if check was executed unnecessarily.
    
    [1] https://www.mail-archive.com/linux-omap@vger.kernel.org/msg94220.html
    [2] http://www.spinics.net/lists/linux-omap/msg98490.html
    
    Cc: Nishanth Menon <nm@ti.com>
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
    Fixes: f92d9597f781f6a5a39c73dc71604bd8a21c5299 ("ARM: OMAP2+: hwmod: Extract no-idle and no-reset info from DT")
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 1f33f5db10d5..66c60fe1104c 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2546,11 +2546,12 @@ static int __init _init(struct omap_hwmod *oh, void *data)
 		return -EINVAL;
 	}
 
-	if (np)
+	if (np) {
 		if (of_find_property(np, "ti,no-reset-on-init", NULL))
 			oh->flags |= HWMOD_INIT_NO_RESET;
 		if (of_find_property(np, "ti,no-idle-on-init", NULL))
 			oh->flags |= HWMOD_INIT_NO_IDLE;
+	}
 
 	oh->_state = _HWMOD_STATE_INITIALIZED;
 

commit 01142519ffc0734436f26b01aeed37a915dece05
Author: Illia Smyrnov <illia.smyrnov@globallogic.com>
Date:   Wed Feb 5 17:06:09 2014 +0200

    ARM: OMAP4: hwmod: Fix SOFTRESET logic for OMAP4
    
    Commit 313a76e (ARM: OMAP2+: hwmod: Fix SOFTRESET logic) introduced
    softreset bit cleaning right after set one. It is caused L3 error for
    OMAP4 ISS because ISS register write occurs when ISS reset process is in
    progress. Avoid this situation by cleaning softreset bit later, when reset
    process is successfully finished.
    
    Signed-off-by: Illia Smyrnov <illia.smyrnov@globallogic.com>
    Reviewed-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Acked-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 42d81885c700..1f33f5db10d5 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1946,30 +1946,32 @@ static int _ocp_softreset(struct omap_hwmod *oh)
 	if (ret)
 		goto dis_opt_clks;
 
-	_write_sysconfig(v, oh);
-	ret = _clear_softreset(oh, &v);
-	if (ret)
-		goto dis_opt_clks;
-
 	_write_sysconfig(v, oh);
 
 	if (oh->class->sysc->srst_udelay)
 		udelay(oh->class->sysc->srst_udelay);
 
 	c = _wait_softreset_complete(oh);
-	if (c == MAX_MODULE_SOFTRESET_WAIT)
+	if (c == MAX_MODULE_SOFTRESET_WAIT) {
 		pr_warning("omap_hwmod: %s: softreset failed (waited %d usec)\n",
 			   oh->name, MAX_MODULE_SOFTRESET_WAIT);
-	else
+		ret = -ETIMEDOUT;
+		goto dis_opt_clks;
+	} else {
 		pr_debug("omap_hwmod: %s: softreset in %d usec\n", oh->name, c);
+	}
+
+	ret = _clear_softreset(oh, &v);
+	if (ret)
+		goto dis_opt_clks;
+
+	_write_sysconfig(v, oh);
 
 	/*
 	 * XXX add _HWMOD_STATE_WEDGED for modules that don't come back from
 	 * _wait_target_ready() or _reset()
 	 */
 
-	ret = (c == MAX_MODULE_SOFTRESET_WAIT) ? -ETIMEDOUT : 0;
-
 dis_opt_clks:
 	if (oh->flags & HWMOD_CONTROL_OPT_CLKS_IN_RESET)
 		_disable_optional_clocks(oh);

commit d30492adea3a82e7120bcf60893aaaab711f90a6
Merge: f1499382f114 fd3fdaf09f26
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 28 18:44:53 2014 -0800

    Merge tag 'clk-for-linus-3.14-part2' of git://git.linaro.org/people/mike.turquette/linux
    
    Pull more clock framework changes from Mike Turquette:
     "The second half of the clock framework pull requeust for 3.14 is
      dominated by platform support for Qualcomm's MSM SoCs, DT binding
      updates for TI's OMAP-ish processors and additional support for
      Samsung chips.
    
      Additionally there are other smaller clock driver changes and several
      last minute fixes.  This pull request also includes the HiSilicon
      support that depends on the already-merged arm-soc pull request"
    
    [ Fix up stupid compile error in the source tree with evil merge  - Grumpy Linus ]
    
    * tag 'clk-for-linus-3.14-part2' of git://git.linaro.org/people/mike.turquette/linux: (49 commits)
      clk: sort Makefile
      clk: sunxi: fix overflow when setting up divided factors
      clk: Export more clk-provider functions
      dt-bindings: qcom: Fix warning with duplicate dt define
      clk: si5351: remove variant from platform_data
      clk: samsung: Remove unneeded semicolon
      clk: qcom: Fix modular build
      ARM: OMAP3: use DT clock init if DT data is available
      ARM: AM33xx: remove old clock data and link in new clock init code
      ARM: AM43xx: Enable clock init
      ARM: OMAP: DRA7: Enable clock init
      ARM: OMAP4: remove old clock data and link in new clock init code
      ARM: OMAP2+: io: use new clock init API
      ARM: OMAP2+: PRM: add support for initializing PRCM clock modules from DT
      ARM: OMAP3: hwmod: initialize clkdm from clkdm_name
      ARM: OMAP: hwmod: fix an incorrect clk type cast with _get_clkdm
      ARM: OMAP2+: clock: use driver API instead of direct memory read/write
      ARM: OMAP2+: clock: add support for indexed memmaps
      ARM: dts: am43xx clock data
      ARM: dts: AM35xx: use DT clock data
      ...

commit b6cb5bab263791d09abe88f24df6c2da53415320
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Tue Jan 21 15:50:51 2014 -0800

    arch/arm/mach-omap2/omap_hwmod.c: use memblock apis for early memory allocations
    
    Switch to memblock interfaces for early memory allocator instead of
    bootmem allocator.  No functional change in beahvior than what it is in
    current code from bootmem users points of view.
    
    Archs already converted to NO_BOOTMEM now directly use memblock
    interfaces instead of bootmem wrappers build on top of memblock.  And
    the archs which still uses bootmem, these new apis just fallback to
    exiting bootmem APIs.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Christoph Lameter <cl@linux-foundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 8a1b5e0bad40..f7a6fd35b1e4 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2791,9 +2791,7 @@ static int __init _alloc_links(struct omap_hwmod_link **ml,
 	sz = sizeof(struct omap_hwmod_link) * LINKS_PER_OCP_IF;
 
 	*sl = NULL;
-	*ml = alloc_bootmem(sz);
-
-	memset(*ml, 0, sz);
+	*ml = memblock_virt_alloc(sz, 0);
 
 	*sl = (void *)(*ml) + sizeof(struct omap_hwmod_link);
 
@@ -2912,9 +2910,7 @@ static int __init _alloc_linkspace(struct omap_hwmod_ocp_if **ois)
 	pr_debug("omap_hwmod: %s: allocating %d byte linkspace (%d links)\n",
 		 __func__, sz, max_ls);
 
-	linkspace = alloc_bootmem(sz);
-
-	memset(linkspace, 0, sz);
+	linkspace = memblock_virt_alloc(sz, 0);
 
 	return 0;
 }

commit 0385c58207771efed179670549573fb779c15dc9
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Jul 17 18:03:25 2013 +0300

    ARM: OMAP3: hwmod: initialize clkdm from clkdm_name
    
    DT clocks are mostly missing clkdm info now, and this causes an issue with
    counter32k which makes its slave idlemode wrong and prevents core idle.
    
    Fixed by initializing the hwmod clkdm pointers for omap3 also which makes
    sure the clkdm flag matching logic works properly.
    
    This patch also changes the return value for _init_clkdm to 0 for
    incorrect clkdm_name, as this a warning, not a fatal error.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index cc24c95b77e5..433fe2f9278c 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1578,7 +1578,7 @@ static int _init_clkdm(struct omap_hwmod *oh)
 	if (!oh->clkdm) {
 		pr_warning("omap_hwmod: %s: could not associate to clkdm %s\n",
 			oh->name, oh->clkdm_name);
-		return -EINVAL;
+		return 0;
 	}
 
 	pr_debug("omap_hwmod: %s: associated to clkdm %s\n",
@@ -4237,6 +4237,7 @@ void __init omap_hwmod_init(void)
 		soc_ops.assert_hardreset = _omap2_assert_hardreset;
 		soc_ops.deassert_hardreset = _omap2_deassert_hardreset;
 		soc_ops.is_hardreset_asserted = _omap2_is_hardreset_asserted;
+		soc_ops.init_clkdm = _init_clkdm;
 	} else if (cpu_is_omap44xx() || soc_is_omap54xx() || soc_is_dra7xx()) {
 		soc_ops.enable_module = _omap4_enable_module;
 		soc_ops.disable_module = _omap4_disable_module;

commit 924f9498acb004d8cb704a008f1060fad604ccca
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Jul 12 12:26:41 2013 +0300

    ARM: OMAP: hwmod: fix an incorrect clk type cast with _get_clkdm
    
    If the main clock for a hwmod is of basic clock type, it is illegal to type
    cast this to clk_hw_omap and will result in bogus data. Fixed by checking
    the clock flags before attempting the type cast.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 8a1b5e0bad40..cc24c95b77e5 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -686,6 +686,8 @@ static struct clockdomain *_get_clkdm(struct omap_hwmod *oh)
 	if (oh->clkdm) {
 		return oh->clkdm;
 	} else if (oh->_clk) {
+		if (__clk_get_flags(oh->_clk) & CLK_IS_BASIC)
+			return NULL;
 		clk = to_clk_hw_omap(__clk_get_hw(oh->_clk));
 		return  clk->clkdm;
 	}

commit 3daf65c0ed7660f75da927c250163c26c9043f1b
Merge: ed16c8c50e26 0e7dc862cf68
Author: Kevin Hilman <khilman@linaro.org>
Date:   Tue Dec 10 07:44:32 2013 -0800

    Merge tag 'for-v3.13-rc/hwmod-fixes-a' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into fixes
    
    From Paul Walmsley:
    ARM: OMAP2+: hwmod code/data: fixes for v3.13-rc
    
    Fix a few hwmod code problems involving recovery with bad data and bad
    IP block OCP reset handling.  Also, fix the hwmod data to enable IP
    block OCP reset for the OMAP USBHOST devices on OMAP3+.
    
    Basic build, boot, and PM tests are available here:
    
    http://www.pwsan.com/omap/testlogs/prcm_fixes_a_v3.13-rc/20131209030611/
    
    * tag 'for-v3.13-rc/hwmod-fixes-a' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending:
      ARM: OMAP2+: hwmod: Fix usage of invalid iclk / oclk when clock node is not present
      ARM: OMAP3: hwmod data: Don't prevent RESET of USB Host module
      ARM: OMAP2+: hwmod: Fix SOFTRESET logic
      ARM: OMAP4+: hwmod data: Don't prevent RESET of USB Host module
    
    Signed-off-by: Kevin Hilman <khilman@linaro.org>

commit 0e7dc862cf687234ed1b01a6b2461b782ea0bca0
Author: Nishanth Menon <nm@ti.com>
Date:   Sun Dec 8 18:39:03 2013 -0700

    ARM: OMAP2+: hwmod: Fix usage of invalid iclk / oclk when clock node is not present
    
    commit dc75925d(OMAP: hwmod: Fix the missing braces) introduced
    missing braces, however, we just set return result if clk_get fail
    and we populate the error pointer in clk pointer and pass it along to
    clk_prepare. This is wrong. The intent seems to be retry remaining
    clocks if they are available and warn the ones we cant find clks for.
    
    With the current logic, we see the following crash:
    omap_hwmod: l3_main: cannot clk_get interface_clk emac_ick
    Unable to handle kernel NULL pointer dereference at virtual address 00000032
    pgd = c0004000
    [00000032] *pgd=00000000
    Internal error: Oops: 5 [#1] SMP ARM
    Modules linked in:
    CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.13.0-rc1-00044-gcc9fd5a-dirty #19
    task: ce0c3440 ti: ce0c4000 task.ti: ce0c4000
    PC is at __clk_prepare+0x10/0x74
    LR is at clk_prepare+0x14/0x24
      <snip>
    [<c044d59c>] (__clk_prepare+0x10/0x74) from [<c044d9b0>] (clk_prepare+0x14/0x24)
    [<c044d9b0>] (clk_prepare+0x14/0x24) from [<c077d8c4>] (_init+0x24c/0x3bc)
    [<c077d8c4>] (_init+0x24c/0x3bc) from [<c0027328>] (omap_hwmod_for_each+0x34/0x5c)
    [<c0027328>] (omap_hwmod_for_each+0x34/0x5c) from [<c077dfa0>] (__omap_hwmod_setup_all+0x24/0x40)
    [<c077dfa0>] (__omap_hwmod_setup_all+0x24/0x40) from [<c0008928>] (do_one_initcall+0x38/0x168)
    [<c0008928>] (do_one_initcall+0x38/0x168) from [<c0771be8>] (kernel_init_freeable+0xfc/0x1cc)
    [<c0771be8>] (kernel_init_freeable+0xfc/0x1cc) from [<c0521064>] (kernel_init+0x8/0x110)
    [<c0521064>] (kernel_init+0x8/0x110) from [<c000e568>] (ret_from_fork+0x14/0x2c)
    Code: e92d4038 e2504000 01a05004 0a000005 (e5943034)
    
    So, just warn and continue instead of proceeding and crashing, with
    missing clock nodes/bad data, we will eventually fail, however we
    should now have enough information to identify the culprit.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index cacc0c7e8634..461d59044f1b 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -815,6 +815,7 @@ static int _init_interface_clks(struct omap_hwmod *oh)
 			pr_warning("omap_hwmod: %s: cannot clk_get interface_clk %s\n",
 				   oh->name, os->clk);
 			ret = -EINVAL;
+			continue;
 		}
 		os->_clk = c;
 		/*
@@ -851,6 +852,7 @@ static int _init_opt_clks(struct omap_hwmod *oh)
 			pr_warning("omap_hwmod: %s: cannot clk_get opt_clk %s\n",
 				   oh->name, oc->clk);
 			ret = -EINVAL;
+			continue;
 		}
 		oc->_clk = c;
 		/*

commit 313a76ee11cda6700548afe68499ef174a240688
Author: Roger Quadros <rogerq@ti.com>
Date:   Sun Dec 8 18:39:02 2013 -0700

    ARM: OMAP2+: hwmod: Fix SOFTRESET logic
    
    In _ocp_softreset(), after _set_softreset() + write_sysconfig(),
    the hwmod's sysc_cache will always contain SOFTRESET bit set
    so all further writes to sysconfig using this cache will initiate
    a repeated SOFTRESET e.g. enable_sysc(). This is true for OMAP3 like
    platforms that have RESET_DONE status in the SYSSTATUS register and
    so the the SOFTRESET bit in SYSCONFIG is not automatically cleared.
    It is not a problem for OMAP4 like platforms that indicate RESET
    completion by clearing the SOFTRESET bit in the SYSCONFIG register.
    
    This repeated SOFTRESET is undesired and was the root cause of
    USB host issues on OMAP3 platforms when hwmod was allowed to do the
    SOFTRESET for the USB Host module.
    
    To fix this we clear the SOFTRESET bit and update the sysconfig
    register + sysc_cache using write_sysconfig().
    
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Tested-by: Tomi Valkeinen <tomi.valkeinen@ti.com> # Panda, BeagleXM
    [paul@pwsan.com: renamed _clr_softreset() to _clear_softreset()]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index e3f0ecaf87dd..cacc0c7e8634 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -399,7 +399,7 @@ static int _set_clockactivity(struct omap_hwmod *oh, u8 clockact, u32 *v)
 }
 
 /**
- * _set_softreset: set OCP_SYSCONFIG.CLOCKACTIVITY bits in @v
+ * _set_softreset: set OCP_SYSCONFIG.SOFTRESET bit in @v
  * @oh: struct omap_hwmod *
  * @v: pointer to register contents to modify
  *
@@ -426,6 +426,36 @@ static int _set_softreset(struct omap_hwmod *oh, u32 *v)
 	return 0;
 }
 
+/**
+ * _clear_softreset: clear OCP_SYSCONFIG.SOFTRESET bit in @v
+ * @oh: struct omap_hwmod *
+ * @v: pointer to register contents to modify
+ *
+ * Clear the SOFTRESET bit in @v for hwmod @oh.  Returns -EINVAL upon
+ * error or 0 upon success.
+ */
+static int _clear_softreset(struct omap_hwmod *oh, u32 *v)
+{
+	u32 softrst_mask;
+
+	if (!oh->class->sysc ||
+	    !(oh->class->sysc->sysc_flags & SYSC_HAS_SOFTRESET))
+		return -EINVAL;
+
+	if (!oh->class->sysc->sysc_fields) {
+		WARN(1,
+		     "omap_hwmod: %s: sysc_fields absent for sysconfig class\n",
+		     oh->name);
+		return -EINVAL;
+	}
+
+	softrst_mask = (0x1 << oh->class->sysc->sysc_fields->srst_shift);
+
+	*v &= ~softrst_mask;
+
+	return 0;
+}
+
 /**
  * _wait_softreset_complete - wait for an OCP softreset to complete
  * @oh: struct omap_hwmod * to wait on
@@ -1911,6 +1941,12 @@ static int _ocp_softreset(struct omap_hwmod *oh)
 	ret = _set_softreset(oh, &v);
 	if (ret)
 		goto dis_opt_clks;
+
+	_write_sysconfig(v, oh);
+	ret = _clear_softreset(oh, &v);
+	if (ret)
+		goto dis_opt_clks;
+
 	_write_sysconfig(v, oh);
 
 	if (oh->class->sysc->srst_udelay)
@@ -3169,6 +3205,11 @@ int omap_hwmod_softreset(struct omap_hwmod *oh)
 		goto error;
 	_write_sysconfig(v, oh);
 
+	ret = _clear_softreset(oh, &v);
+	if (ret)
+		goto error;
+	_write_sysconfig(v, oh);
+
 error:
 	return ret;
 }

commit 5e863c561048252bb230d2f9daeed9fbe2705b41
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Dec 6 14:20:16 2013 -0800

    ARM: OMAP2+: Fix overwriting hwmod data with data from device tree
    
    We have some device tree properties where the ti,hwmod have multiple
    values:
    
    am33xx.dtsi:    ti,hwmods = "tpcc", "tptc0", "tptc1", "tptc2";
    am4372.dtsi:    ti,hwmods = "tpcc", "tptc0", "tptc1", "tptc2";
    dra7.dtsi:      ti,hwmods = "l3_main_1", "l3_main_2";
    omap3.dtsi:     ti,hwmods = "mcbsp2", "mcbsp2_sidetone";
    omap3.dtsi:     ti,hwmods = "mcbsp3", "mcbsp3_sidetone";
    omap4.dtsi:     ti,hwmods = "l3_main_1", "l3_main_2", "l3_main_3";
    omap5.dtsi:     ti,hwmods = "l3_main_1", "l3_main_2", "l3_main_3";
    
    That's not correct way of doing things in this case because these are
    separate devices with their own address space, interrupts, SYSCONFIG
    registers and can set their PM states independently.
    
    So they should all be fixed up to be separate devices in the .dts files.
    
    We also have the related data removed for at least omap4 in commit
    3b9b10151c68 (ARM: OMAP4: hwmod data: Clean up the data file), so
    that data is wrongly initialized as null data.
    
    So we need to fix two bugs:
    
    1. We are only checking the first entry of the ti,hwmods property
    
       This means that we're only initializing the first hwmods entry
       instead of the ones listed in the ti,hwmods property.
    
    2. We are only checking the child nodes, not the nodes themselves
    
       This means that anything listed at OCP level is currently just
       ignored and unitialized and at least the omap4 case, with the
       legacy data missing from the hwmod.
    
    Fix both of the issues by using an index to the ti,hwmods property
    and changing the hwmod lookup function to also check the current node
    for ti,hwmods property instead of just the children.
    
    While at it, let's also add some warnings for the bad data so it's
    easier to fix.
    
    Cc: "Benot Cousson" <bcousson@baylibre.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index e3f0ecaf87dd..ee655dab672f 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2326,38 +2326,80 @@ static int _shutdown(struct omap_hwmod *oh)
 	return 0;
 }
 
+static int of_dev_find_hwmod(struct device_node *np,
+			     struct omap_hwmod *oh)
+{
+	int count, i, res;
+	const char *p;
+
+	count = of_property_count_strings(np, "ti,hwmods");
+	if (count < 1)
+		return -ENODEV;
+
+	for (i = 0; i < count; i++) {
+		res = of_property_read_string_index(np, "ti,hwmods",
+						    i, &p);
+		if (res)
+			continue;
+		if (!strcmp(p, oh->name)) {
+			pr_debug("omap_hwmod: dt %s[%i] uses hwmod %s\n",
+				 np->name, i, oh->name);
+			return i;
+		}
+	}
+
+	return -ENODEV;
+}
+
 /**
  * of_dev_hwmod_lookup - look up needed hwmod from dt blob
  * @np: struct device_node *
  * @oh: struct omap_hwmod *
+ * @index: index of the entry found
+ * @found: struct device_node * found or NULL
  *
  * Parse the dt blob and find out needed hwmod. Recursive function is
  * implemented to take care hierarchical dt blob parsing.
- * Return: The device node on success or NULL on failure.
+ * Return: Returns 0 on success, -ENODEV when not found.
  */
-static struct device_node *of_dev_hwmod_lookup(struct device_node *np,
-						struct omap_hwmod *oh)
+static int of_dev_hwmod_lookup(struct device_node *np,
+			       struct omap_hwmod *oh,
+			       int *index,
+			       struct device_node **found)
 {
-	struct device_node *np0 = NULL, *np1 = NULL;
-	const char *p;
+	struct device_node *np0 = NULL;
+	int res;
+
+	res = of_dev_find_hwmod(np, oh);
+	if (res >= 0) {
+		*found = np;
+		*index = res;
+		return 0;
+	}
 
 	for_each_child_of_node(np, np0) {
-		if (of_find_property(np0, "ti,hwmods", NULL)) {
-			p = of_get_property(np0, "ti,hwmods", NULL);
-			if (!strcmp(p, oh->name))
-				return np0;
-			np1 = of_dev_hwmod_lookup(np0, oh);
-			if (np1)
-				return np1;
+		struct device_node *fc;
+		int i;
+
+		res = of_dev_hwmod_lookup(np0, oh, &i, &fc);
+		if (res == 0) {
+			*found = fc;
+			*index = i;
+			return 0;
 		}
 	}
-	return NULL;
+
+	*found = NULL;
+	*index = 0;
+
+	return -ENODEV;
 }
 
 /**
  * _init_mpu_rt_base - populate the virtual address for a hwmod
  * @oh: struct omap_hwmod * to locate the virtual address
  * @data: (unused, caller should pass NULL)
+ * @index: index of the reg entry iospace in device tree
  * @np: struct device_node * of the IP block's device node in the DT data
  *
  * Cache the virtual address used by the MPU to access this IP block's
@@ -2368,7 +2410,7 @@ static struct device_node *of_dev_hwmod_lookup(struct device_node *np,
  * -ENXIO on absent or invalid register target address space.
  */
 static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data,
-				    struct device_node *np)
+				    int index, struct device_node *np)
 {
 	struct omap_hwmod_addr_space *mem;
 	void __iomem *va_start = NULL;
@@ -2390,13 +2432,17 @@ static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data,
 		if (!np)
 			return -ENXIO;
 
-		va_start = of_iomap(np, oh->mpu_rt_idx);
+		va_start = of_iomap(np, index + oh->mpu_rt_idx);
 	} else {
 		va_start = ioremap(mem->pa_start, mem->pa_end - mem->pa_start);
 	}
 
 	if (!va_start) {
-		pr_err("omap_hwmod: %s: Could not ioremap\n", oh->name);
+		if (mem)
+			pr_err("omap_hwmod: %s: Could not ioremap\n", oh->name);
+		else
+			pr_err("omap_hwmod: %s: Missing dt reg%i for %s\n",
+			       oh->name, index, np->full_name);
 		return -ENXIO;
 	}
 
@@ -2422,17 +2468,29 @@ static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data,
  */
 static int __init _init(struct omap_hwmod *oh, void *data)
 {
-	int r;
+	int r, index;
 	struct device_node *np = NULL;
 
 	if (oh->_state != _HWMOD_STATE_REGISTERED)
 		return 0;
 
-	if (of_have_populated_dt())
-		np = of_dev_hwmod_lookup(of_find_node_by_name(NULL, "ocp"), oh);
+	if (of_have_populated_dt()) {
+		struct device_node *bus;
+
+		bus = of_find_node_by_name(NULL, "ocp");
+		if (!bus)
+			return -ENODEV;
+
+		r = of_dev_hwmod_lookup(bus, oh, &index, &np);
+		if (r)
+			pr_debug("omap_hwmod: %s missing dt data\n", oh->name);
+		else if (np && index)
+			pr_warn("omap_hwmod: %s using broken dt data from %s\n",
+				oh->name, np->name);
+	}
 
 	if (oh->class->sysc) {
-		r = _init_mpu_rt_base(oh, NULL, np);
+		r = _init_mpu_rt_base(oh, NULL, index, np);
 		if (r < 0) {
 			WARN(1, "omap_hwmod: %s: doesn't have mpu register target base\n",
 			     oh->name);

commit c8b428a5b16bf02ae0290511466e0d15a9f65b35
Author: Afzal Mohammed <afzal@ti.com>
Date:   Sat Oct 12 15:46:20 2013 +0530

    ARM: OMAP2+: hwmod: AM43x operations
    
    Reuse OMAP4 operations on AM43x.
    
    Context related ops are not used on AM43x, as this would not add value
    when using DT and AM43x is DT only boot. This additionally helps not to
    add context register offset for each hwmod.
    
    Signed-off-by: Ambresh K <ambresh@ti.com>
    Signed-off-by: Afzal Mohammed <afzal@ti.com>
    Acked-by: Rajendra Nayak <rnayak@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 1c217e89deb9..e3f0ecaf87dd 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -4144,6 +4144,14 @@ void __init omap_hwmod_init(void)
 		soc_ops.init_clkdm = _init_clkdm;
 		soc_ops.update_context_lost = _omap4_update_context_lost;
 		soc_ops.get_context_lost = _omap4_get_context_lost;
+	} else if (soc_is_am43xx()) {
+		soc_ops.enable_module = _omap4_enable_module;
+		soc_ops.disable_module = _omap4_disable_module;
+		soc_ops.wait_target_ready = _omap4_wait_target_ready;
+		soc_ops.assert_hardreset = _omap4_assert_hardreset;
+		soc_ops.deassert_hardreset = _omap4_deassert_hardreset;
+		soc_ops.is_hardreset_asserted = _omap4_is_hardreset_asserted;
+		soc_ops.init_clkdm = _init_clkdm;
 	} else if (soc_is_am33xx()) {
 		soc_ops.enable_module = _am33xx_enable_module;
 		soc_ops.disable_module = _am33xx_disable_module;

commit f92d9597f781f6a5a39c73dc71604bd8a21c5299
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Wed Oct 9 01:26:55 2013 -0600

    ARM: OMAP2+: hwmod: Extract no-idle and no-reset info from DT
    
    Now that we have DT bindings to specify which devices should not
    be reset and idled during init, make hwmod extract the information
    (and store them in internal flags) from Device tree.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    [paul@pwsan.com: updated to apply]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 3d5db8c83b3c..1c217e89deb9 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2357,6 +2357,8 @@ static struct device_node *of_dev_hwmod_lookup(struct device_node *np,
 /**
  * _init_mpu_rt_base - populate the virtual address for a hwmod
  * @oh: struct omap_hwmod * to locate the virtual address
+ * @data: (unused, caller should pass NULL)
+ * @np: struct device_node * of the IP block's device node in the DT data
  *
  * Cache the virtual address used by the MPU to access this IP block's
  * registers.  This address is needed early so the OCP registers that
@@ -2365,11 +2367,11 @@ static struct device_node *of_dev_hwmod_lookup(struct device_node *np,
  * Returns 0 on success, -EINVAL if an invalid hwmod is passed, and
  * -ENXIO on absent or invalid register target address space.
  */
-static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data)
+static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data,
+				    struct device_node *np)
 {
 	struct omap_hwmod_addr_space *mem;
 	void __iomem *va_start = NULL;
-	struct device_node *np;
 
 	if (!oh)
 		return -EINVAL;
@@ -2385,12 +2387,10 @@ static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data)
 			 oh->name);
 
 		/* Extract the IO space from device tree blob */
-		if (!of_have_populated_dt())
+		if (!np)
 			return -ENXIO;
 
-		np = of_dev_hwmod_lookup(of_find_node_by_name(NULL, "ocp"), oh);
-		if (np)
-			va_start = of_iomap(np, oh->mpu_rt_idx);
+		va_start = of_iomap(np, oh->mpu_rt_idx);
 	} else {
 		va_start = ioremap(mem->pa_start, mem->pa_end - mem->pa_start);
 	}
@@ -2423,12 +2423,16 @@ static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data)
 static int __init _init(struct omap_hwmod *oh, void *data)
 {
 	int r;
+	struct device_node *np = NULL;
 
 	if (oh->_state != _HWMOD_STATE_REGISTERED)
 		return 0;
 
+	if (of_have_populated_dt())
+		np = of_dev_hwmod_lookup(of_find_node_by_name(NULL, "ocp"), oh);
+
 	if (oh->class->sysc) {
-		r = _init_mpu_rt_base(oh, NULL);
+		r = _init_mpu_rt_base(oh, NULL, np);
 		if (r < 0) {
 			WARN(1, "omap_hwmod: %s: doesn't have mpu register target base\n",
 			     oh->name);
@@ -2442,6 +2446,12 @@ static int __init _init(struct omap_hwmod *oh, void *data)
 		return -EINVAL;
 	}
 
+	if (np)
+		if (of_find_property(np, "ti,no-reset-on-init", NULL))
+			oh->flags |= HWMOD_INIT_NO_RESET;
+		if (of_find_property(np, "ti,no-idle-on-init", NULL))
+			oh->flags |= HWMOD_INIT_NO_IDLE;
+
 	oh->_state = _HWMOD_STATE_INITIALIZED;
 
 	return 0;

commit 6423d6df1440a8acfc2f375d7cbc4cd66c2e6910
Author: Suman Anna <s-anna@ti.com>
Date:   Tue Oct 8 23:46:49 2013 -0600

    ARM: OMAP2+: hwmod: check for module address space during init
    
    The hwmod init sequence involves initializing and idling all the
    hwmods during bootup. If a module class has sysconfig, the init
    sequence utilizes the module register base for performing any
    sysc configuration.
    
    The module address space is being removed from hwmod database and
    retrieved from the <reg> property of the corresponding DT node.
    If a hwmod does not have its corresponding DT node defined and the
    memory address space is not defined in the corresponding
    omap_hwmod_ocp_if, then the module register target address space
    would be NULL and any sysc programming would result in a NULL
    pointer dereference and a kernel boot hang.
    
    Handle this scenario by checking for a valid module address space
    during the _init of each hwmod, and leaving it in the registered
    state if no module register address base is defined in either of
    the hwmod data or the DT data.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    [paul@pwsan.com: use -ENXIO rather than -ENOMEM to indicate a missing address
     space error; fixed checkpatch.pl problem]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index d9ee0ff094d4..3d5db8c83b3c 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2361,21 +2361,23 @@ static struct device_node *of_dev_hwmod_lookup(struct device_node *np,
  * Cache the virtual address used by the MPU to access this IP block's
  * registers.  This address is needed early so the OCP registers that
  * are part of the device's address space can be ioremapped properly.
- * No return value.
+ *
+ * Returns 0 on success, -EINVAL if an invalid hwmod is passed, and
+ * -ENXIO on absent or invalid register target address space.
  */
-static void __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data)
+static int __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data)
 {
 	struct omap_hwmod_addr_space *mem;
 	void __iomem *va_start = NULL;
 	struct device_node *np;
 
 	if (!oh)
-		return;
+		return -EINVAL;
 
 	_save_mpu_port_index(oh);
 
 	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
-		return;
+		return -ENXIO;
 
 	mem = _find_mpu_rt_addr_space(oh);
 	if (!mem) {
@@ -2384,7 +2386,7 @@ static void __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data)
 
 		/* Extract the IO space from device tree blob */
 		if (!of_have_populated_dt())
-			return;
+			return -ENXIO;
 
 		np = of_dev_hwmod_lookup(of_find_node_by_name(NULL, "ocp"), oh);
 		if (np)
@@ -2395,13 +2397,14 @@ static void __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data)
 
 	if (!va_start) {
 		pr_err("omap_hwmod: %s: Could not ioremap\n", oh->name);
-		return;
+		return -ENXIO;
 	}
 
 	pr_debug("omap_hwmod: %s: MPU register target at va %p\n",
 		 oh->name, va_start);
 
 	oh->_mpu_rt_va = va_start;
+	return 0;
 }
 
 /**
@@ -2414,8 +2417,8 @@ static void __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data)
  * registered at this point.  This is the first of two phases for
  * hwmod initialization.  Code called here does not touch any hardware
  * registers, it simply prepares internal data structures.  Returns 0
- * upon success or if the hwmod isn't registered, or -EINVAL upon
- * failure.
+ * upon success or if the hwmod isn't registered or if the hwmod's
+ * address space is not defined, or -EINVAL upon failure.
  */
 static int __init _init(struct omap_hwmod *oh, void *data)
 {
@@ -2424,8 +2427,14 @@ static int __init _init(struct omap_hwmod *oh, void *data)
 	if (oh->_state != _HWMOD_STATE_REGISTERED)
 		return 0;
 
-	if (oh->class->sysc)
-		_init_mpu_rt_base(oh, NULL);
+	if (oh->class->sysc) {
+		r = _init_mpu_rt_base(oh, NULL);
+		if (r < 0) {
+			WARN(1, "omap_hwmod: %s: doesn't have mpu register target base\n",
+			     oh->name);
+			return 0;
+		}
+	}
 
 	r = _init_clocks(oh, NULL);
 	if (r < 0) {

commit d296ebe0e61be179e79d1929d5284619d1d667cf
Merge: 65cb771fdf4a e3e1970f892d
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Aug 29 16:46:14 2013 -0700

    Merge tag 'omap-for-v3.12/dra7xx-prcm' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into late/all
    
    From Tony Lindgren:
    Add basic support for devices on dra7xx by adding the PRCM and hwmod
    parts the same way as for other omaps. This is still needed in
    addition to device tree support for things like power management.
    
    Via Paul Walmsley <paul@pwsan.com>:
    
    This series adds basic TI DRA7xx PRCM and hwmod support.
    
    Basic test logs are available here:
    
    http://www.pwsan.com/omap/testlogs/dra7xx_prcm_devel_v3.12/20130823050445/
    
    Note that DRA7xx could not be tested locally, since I don't have a board.
    
    * tag 'omap-for-v3.12/dra7xx-prcm' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap:
      ARM: OMAP: DRA7: Enable PM framework initializations
      ARM: OMAP: DRA7: hwmod: Create initial DRA7XX SoC data
      ARM: OMAP: DRA7: Reuse the omap44xx_restart and fix the device instance
      ARM: OMAP: DRA7: powerdomain: Handle missing vc/vp
      ARM: OMAP: DRA7: powerdomain: Add DRA7XX data and update header
      ARM: OMAP: DRA7: clockdomain: Add DRA7XX data and update header
      ARM: OMAP: DRA7: PRCM: Add DRA7XX local MPU PRCM regsiters
      ARM: OMAP: DRA7: CM: Add minimal regbit shifts
      ARM: OMAP: DRA7: CM: Add DRA7XX register defines
      ARM: OMAP: DRA7: PRM: Add DRA7XX register definitions
      ARM: DRA7: Add the build support in omap2plus
      ARM: DRA7: hwmod: Reuse the soc_ops used for OMAP4/5
      ARM: DRA7: id: Add cpu detection support for DRA7xx based SoCs'
      ARM: DRA7: Kconfig: Make ARCH_NR_GPIO default to 512
      ARM: DRA7: board-generic: Add basic DT support
      ARM: DRA7: Resue the clocksource, clockevent support
      ARM: DRA7: Reuse io tables and add a new .init_early
      ARM: DRA7: Reuse all of PRCM and MPUSS SMP infra
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 127500ccb766f0e963436e25ddd57be8f1695498
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Fri Aug 23 04:40:23 2013 -0600

    ARM: OMAP2+: Only write the sysconfig on idle when necessary
    
    Currently, whenever we idle a device _idle_sysc() is called and writes to the
    devices SYSCONFIG register to set the idle mode. A lot devices are using the
    smart-idle mode and so the write to the SYSCONFIG register is programming the
    same value that is already stored in the register.
    
    Writes to the devices SYSCONFIG register can be slow, for example, writing to
    the DMTIMER SYSCONFIG register takes 3 interface clock cycles and 3 functional
    clock cycles. If the DMTIMER is using the slow 32kHz functional clock this can
    take ~100us.
    
    Furthermore, during boot on an OMAP4430 panda board, I see that there are 100
    calls to _idle_sysc(), however, only 3 out of the 100 calls actually write
    the SYSCONFIG register with a new value.
    
    Therefore, to avoid unnecessary writes to device SYSCONFIG registers when
    idling the device, only write the value if the value has changed. It should be
    safe to do this on idle as the context of the register will never be lost while
    the device is active.
    
    Verified that suspend, CORE off and retention states are working with this
    change on OMAP3430 Beagle board.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    [paul@pwsan.com: updated to apply]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 7f4db12b1459..03e9e2f5d9a7 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1405,7 +1405,9 @@ static void _enable_sysc(struct omap_hwmod *oh)
 	    (sf & SYSC_HAS_CLOCKACTIVITY))
 		_set_clockactivity(oh, oh->class->sysc->clockact, &v);
 
-	_write_sysconfig(v, oh);
+	/* If the cached value is the same as the new value, skip the write */
+	if (oh->_sysc_cache != v)
+		_write_sysconfig(v, oh);
 
 	/*
 	 * Set the autoidle bit only after setting the smartidle bit

commit debcd1f81f9ef632a24b7b7a9367363fa62fbceb
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Tue Jul 2 18:20:08 2013 +0530

    ARM: DRA7: hwmod: Reuse the soc_ops used for OMAP4/5
    
    The soc_ops for dra7xx devices can be completed reused
    from the ones used for omap4 and omap5 devices.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: R Sricharan <r.sricharan@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 7f4db12b1459..b4ecd2c7db8e 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -4113,7 +4113,7 @@ void __init omap_hwmod_init(void)
 		soc_ops.assert_hardreset = _omap2_assert_hardreset;
 		soc_ops.deassert_hardreset = _omap2_deassert_hardreset;
 		soc_ops.is_hardreset_asserted = _omap2_is_hardreset_asserted;
-	} else if (cpu_is_omap44xx() || soc_is_omap54xx()) {
+	} else if (cpu_is_omap44xx() || soc_is_omap54xx() || soc_is_dra7xx()) {
 		soc_ops.enable_module = _omap4_enable_module;
 		soc_ops.disable_module = _omap4_disable_module;
 		soc_ops.wait_target_ready = _omap4_wait_target_ready;

commit 130142d91467e8a07f3a863db369225a89e84d75
Author: Afzal Mohammed <afzal@ti.com>
Date:   Fri Jul 5 20:43:00 2013 +0530

    ARM: OMAP2+: hwmod: rt address space index for DT
    
    Address space is being removed from hwmod database and DT information
    in <reg> property is being used. Currently the 0th index of device
    address space is used to map for register target address. This is not
    always true, eg. cpgmac has it's sysconfig in second address space.
    
    Handle it by specifying index of device address space to be used for
    register target. As default value of this field would be zero with
    static initialization, existing behaviour of using first address space
    for register target while using DT would be kept as such.
    
    Signed-off-by: Afzal Mohammed <afzal@ti.com>
    Tested-by: Mugunthan V N <mugunthanvnm@ti.com>
    [paul@pwsan.com: use u8 rather than int to save memory]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 7341eff63f56..7f4db12b1459 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2386,7 +2386,7 @@ static void __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data)
 
 		np = of_dev_hwmod_lookup(of_find_node_by_name(NULL, "ocp"), oh);
 		if (np)
-			va_start = of_iomap(np, 0);
+			va_start = of_iomap(np, oh->mpu_rt_idx);
 	} else {
 		va_start = ioremap(mem->pa_start, mem->pa_end - mem->pa_start);
 	}

commit 25625c9334d3b6a9cd32d009b99b36f6a78616f3
Merge: 8d9849b05154 3260c76055af
Author: Olof Johansson <olof@lixom.net>
Date:   Wed May 22 13:09:20 2013 -0700

    Merge tag 'omap-fixes-a-for-3.10-rc' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into fixes
    
    From Paul Walmsley:
    Fix the OMAP serial driver to work correctly on OMAP4 when booting
    with DT.
    
    * tag 'omap-fixes-a-for-3.10-rc' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending:
      ARM: OMAP2+: hwmod: Remove sysc slave idle and auto idle apis
      SERIAL: OMAP: Remove the slave idle handling from the driver
      ARM: OMAP2+: serial: Remove the un-used slave idle hooks
      ARM: OMAP2+: hwmod-data: UART IP needs software control to manage sidle modes
      ARM: OMAP2+: hwmod: Add a new flag to handle SIDLE in SWSUP only in active
      ARM: OMAP2+: hwmod: Fix sidle programming in _enable_sysc()/_idle_sysc()
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 3260c76055afc6c9396e5ad9f9e599505ea8891f
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Wed May 15 20:18:42 2013 +0530

    ARM: OMAP2+: hwmod: Remove sysc slave idle and auto idle apis
    
    With the OMAP serial driver sysc cleanup patches in this series, we can
    now remove the hwmod external apis for sysc fiddling.
    
    While at this, also remove unused sysc auto idle api from hwmod code.
    
    Tested-by: Vaibhav Bedia <vaibhav.bedia@ti.com>
    Tested-by: Sourav Poddar <sourav.poddar@ti.com>
    Signed-off-by: Rajendra nayak <rnayak@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Tested-by: Kevin Hilman <khilman@linaro.org>  # OMAP4/Panda
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 5739429894b0..03931425029b 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2254,42 +2254,6 @@ static int _idle(struct omap_hwmod *oh)
 	return 0;
 }
 
-/**
- * omap_hwmod_set_ocp_autoidle - set the hwmod's OCP autoidle bit
- * @oh: struct omap_hwmod *
- * @autoidle: desired AUTOIDLE bitfield value (0 or 1)
- *
- * Sets the IP block's OCP autoidle bit in hardware, and updates our
- * local copy. Intended to be used by drivers that require
- * direct manipulation of the AUTOIDLE bits.
- * Returns -EINVAL if @oh is null or is not in the ENABLED state, or passes
- * along the return value from _set_module_autoidle().
- *
- * Any users of this function should be scrutinized carefully.
- */
-int omap_hwmod_set_ocp_autoidle(struct omap_hwmod *oh, u8 autoidle)
-{
-	u32 v;
-	int retval = 0;
-	unsigned long flags;
-
-	if (!oh || oh->_state != _HWMOD_STATE_ENABLED)
-		return -EINVAL;
-
-	spin_lock_irqsave(&oh->_lock, flags);
-
-	v = oh->_sysc_cache;
-
-	retval = _set_module_autoidle(oh, autoidle, &v);
-
-	if (!retval)
-		_write_sysconfig(v, oh);
-
-	spin_unlock_irqrestore(&oh->_lock, flags);
-
-	return retval;
-}
-
 /**
  * _shutdown - shutdown an omap_hwmod
  * @oh: struct omap_hwmod *
@@ -3188,38 +3152,6 @@ int omap_hwmod_softreset(struct omap_hwmod *oh)
 	return ret;
 }
 
-/**
- * omap_hwmod_set_slave_idlemode - set the hwmod's OCP slave idlemode
- * @oh: struct omap_hwmod *
- * @idlemode: SIDLEMODE field bits (shifted to bit 0)
- *
- * Sets the IP block's OCP slave idlemode in hardware, and updates our
- * local copy.  Intended to be used by drivers that have some erratum
- * that requires direct manipulation of the SIDLEMODE bits.  Returns
- * -EINVAL if @oh is null, or passes along the return value from
- * _set_slave_idlemode().
- *
- * XXX Does this function have any current users?  If not, we should
- * remove it; it is better to let the rest of the hwmod code handle this.
- * Any users of this function should be scrutinized carefully.
- */
-int omap_hwmod_set_slave_idlemode(struct omap_hwmod *oh, u8 idlemode)
-{
-	u32 v;
-	int retval = 0;
-
-	if (!oh)
-		return -EINVAL;
-
-	v = oh->_sysc_cache;
-
-	retval = _set_slave_idlemode(oh, idlemode, &v);
-	if (!retval)
-		_write_sysconfig(v, oh);
-
-	return retval;
-}
-
 /**
  * omap_hwmod_lookup - look up a registered omap_hwmod by name
  * @name: name of the omap_hwmod to look up

commit ca43ea345de96dc214be790b6cebedbdfe110b63
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Wed May 15 20:18:38 2013 +0530

    ARM: OMAP2+: hwmod: Add a new flag to handle SIDLE in SWSUP only in active
    
    Some IPs (like UART) need the sidle mode to be controlled in SW only
    while they are active. Once they go inactive, they need the IP to be
    put back in HW control so they are also wakeup capable.
    
    The flag HWMOD_SWSUP_SIDLE takes care of IPs which need the sidle
    mode to be *always* controlled in SWSUP. We now have a need to control
    IPs sidle mode in SWSUP only while its active.
    
    So define a new flag 'HWMOD_SWSUP_SIDLE_ACT' to help the framework
    know about these new IP requirements.
    
    Tested-by: Vaibhav Bedia <vaibhav.bedia@ti.com>
    Tested-by: Sourav Poddar <sourav.poddar@ti.com>
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Tested-by: Kevin Hilman <khilman@linaro.org>  # OMAP4/Panda
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index c28552bfeb8d..5739429894b0 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1356,7 +1356,8 @@ static void _enable_sysc(struct omap_hwmod *oh)
 
 	clkdm = _get_clkdm(oh);
 	if (sf & SYSC_HAS_SIDLEMODE) {
-		if (oh->flags & HWMOD_SWSUP_SIDLE) {
+		if (oh->flags & HWMOD_SWSUP_SIDLE ||
+		    oh->flags & HWMOD_SWSUP_SIDLE_ACT) {
 			idlemode = HWMOD_IDLEMODE_NO;
 		} else {
 			if (sf & SYSC_HAS_ENAWAKEUP)

commit 35513171eed4d7245e81d926d311e74f3dca06f3
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Wed May 15 20:18:37 2013 +0530

    ARM: OMAP2+: hwmod: Fix sidle programming in _enable_sysc()/_idle_sysc()
    
    _enable_sysc() and _idle_sysc() handle the midle mode programming correctly
    and program HWMOD_IDLEMODE_SMART or HWMOD_IDLEMODE_SMART_WKUP respectively
    for supported IPs (The ones which support hardware controlled midle modes)
    
    However the same programming logic is missing when it comes to sidle mode
    programming. Here they seem to just set HWMOD_IDLEMODE_SMART (Again for the
    ones which support hardware controlled sidle modes)
    
    This problem was hidden due to the fact that a call to _enable_wakeup()
    in those same functions would overwrite the idlemodes and program them
    correctly (to HWMOD_IDLEMODE_SMART_WKUP in the supported cases)
    
    So fix the sidlemode handling correctly in these functions and handle the
    _enable_wakeup() for SIDLEMODE supported IPs same as the way its handled
    for MIDLEMODE supported ones.
    
    Tested-by: Vaibhav Bedia <vaibhav.bedia@ti.com>
    Tested-by: Sourav Poddar <sourav.poddar@ti.com>
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Tested-by: Kevin Hilman <khilman@linaro.org>  # OMAP4/Panda
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index d25a95fe9921..c28552bfeb8d 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1356,13 +1356,26 @@ static void _enable_sysc(struct omap_hwmod *oh)
 
 	clkdm = _get_clkdm(oh);
 	if (sf & SYSC_HAS_SIDLEMODE) {
+		if (oh->flags & HWMOD_SWSUP_SIDLE) {
+			idlemode = HWMOD_IDLEMODE_NO;
+		} else {
+			if (sf & SYSC_HAS_ENAWAKEUP)
+				_enable_wakeup(oh, &v);
+			if (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP)
+				idlemode = HWMOD_IDLEMODE_SMART_WKUP;
+			else
+				idlemode = HWMOD_IDLEMODE_SMART;
+		}
+
+		/*
+		 * This is special handling for some IPs like
+		 * 32k sync timer. Force them to idle!
+		 */
 		clkdm_act = (clkdm && clkdm->flags & CLKDM_ACTIVE_WITH_MPU);
 		if (clkdm_act && !(oh->class->sysc->idlemodes &
 				   (SIDLE_SMART | SIDLE_SMART_WKUP)))
 			idlemode = HWMOD_IDLEMODE_FORCE;
-		else
-			idlemode = (oh->flags & HWMOD_SWSUP_SIDLE) ?
-				HWMOD_IDLEMODE_NO : HWMOD_IDLEMODE_SMART;
+
 		_set_slave_idlemode(oh, idlemode, &v);
 	}
 
@@ -1391,10 +1404,6 @@ static void _enable_sysc(struct omap_hwmod *oh)
 	    (sf & SYSC_HAS_CLOCKACTIVITY))
 		_set_clockactivity(oh, oh->class->sysc->clockact, &v);
 
-	/* If slave is in SMARTIDLE, also enable wakeup */
-	if ((sf & SYSC_HAS_SIDLEMODE) && !(oh->flags & HWMOD_SWSUP_SIDLE))
-		_enable_wakeup(oh, &v);
-
 	_write_sysconfig(v, oh);
 
 	/*
@@ -1430,13 +1439,16 @@ static void _idle_sysc(struct omap_hwmod *oh)
 	sf = oh->class->sysc->sysc_flags;
 
 	if (sf & SYSC_HAS_SIDLEMODE) {
-		/* XXX What about HWMOD_IDLEMODE_SMART_WKUP? */
-		if (oh->flags & HWMOD_SWSUP_SIDLE ||
-		    !(oh->class->sysc->idlemodes &
-		      (SIDLE_SMART | SIDLE_SMART_WKUP)))
+		if (oh->flags & HWMOD_SWSUP_SIDLE) {
 			idlemode = HWMOD_IDLEMODE_FORCE;
-		else
-			idlemode = HWMOD_IDLEMODE_SMART;
+		} else {
+			if (sf & SYSC_HAS_ENAWAKEUP)
+				_enable_wakeup(oh, &v);
+			if (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP)
+				idlemode = HWMOD_IDLEMODE_SMART_WKUP;
+			else
+				idlemode = HWMOD_IDLEMODE_SMART;
+		}
 		_set_slave_idlemode(oh, idlemode, &v);
 	}
 
@@ -1455,10 +1467,6 @@ static void _idle_sysc(struct omap_hwmod *oh)
 		_set_master_standbymode(oh, idlemode, &v);
 	}
 
-	/* If slave is in SMARTIDLE, also enable wakeup */
-	if ((sf & SYSC_HAS_SIDLEMODE) && !(oh->flags & HWMOD_SWSUP_SIDLE))
-		_enable_wakeup(oh, &v);
-
 	_write_sysconfig(v, oh);
 }
 

commit 0f497039276fa2ca2ca324236848bb15c8c775dc
Author: jean-philippe francois <jp.francois@cynove.com>
Date:   Thu May 16 11:25:07 2013 -0700

    ARM: OMAP: fix __init section mismatch for _enable_preprogram
    
    _enable_preprogram is marked as __init, but is called from _enable
    which is not. Without this patch, the board oopses after init. Tested
    on custom hardware and on beagle board xM. Otherwise we can get:
    
    Unable to handle kernel paging request at virtual address 000b0012
    pgd = cf968000
    *pgd=8fb06831, *pte=00000000, *ppte=00000000
    PREEMPT ARM
    Modules linked in:
    CPU: 0    Not tainted  (3.9.0 #2)
    PC is at _enable_preprogram+0x1c/0x24
    LR is at omap_hwmod_enable+0x34/0x60
       psr: 80000093
    sp : cf95de08  ip : 00002de5  fp : bec33d4c
    r10: 00000000  r9 : 00000002  r8 : b6dd2c78
    r7 : 00000004  r6 : 00000000  r5 : a0000013  r4 : cf95c000
    r3 : 00000000  r2 : b6dd2c7c  r1 : 00000000  r0 : 000b0012
    Flags: Nzcv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment user
    Control: 10c5387d  Table: 8f968019  DAC: 00000015
    Process otpcmd (pid: 607, stack limit = 0xcf95c230)
    Stack: (0xcf95de08 to 0xcf95e000)
    de00:                   00000001 cf91f840 00000000 c001d6fc 00000002 cf91f840
    de20: cf8f7e10 c001de54 cf8f7e10 c001de78 c001de68 c01d5e80 00000000 cf8f7e10
    de40: cf8f7e10 c01d5f28 cf8f7e10 c0530d30 00000000 c01d6f28 00000000 c0088664
    de60: b6ea1000 cfb05284 cf95c000 00000001 cf95c000 60000013 00000001 cf95dee4
    de80: cf870050 c01d7308 cf870010 cf870050 00000001 c0278b14 c0526f28 00000000
    dea0: cf870050 ffff8e18 00000001 cf95dee4 00000000 c0274f7c cf870050 00000001
    dec0: cf95dee4 cf1d8484 000000e0 c0276464 00000008 cf9c0000 00000007 c0276980
    dee0: cf9c0000 00000064 00000008 cf1d8404 cf1d8400 c01cc05c 0000270a cf1d8504
    df00: 00000023 cf1d8484 00000007 c01cc670 00000bdd 00000001 00000000 cf449e60
    df20: cf1dde70 cf1d8400 bec33d18 cf1d8504 c0246f00 00000003 cf95c000 00000000
    df40: bec33d4c c01cd078 00000003 cf1d8504 00000081 c01cbcb8 bec33d18 00000003
    df60: bec33d18 c00a9034 00002000 c00a9c68 cf92fe00 00000003 c0246f00 cf92fe00
    df80: 00000000 c00a9cb0 00000003 00000000 00008e70 00000000 b6f17000 00000036
    dfa0: c000e484 c000e300 00008e70 00000000 00000003 c0246f00 bec33d18 bec33d18
    dfc0: 00008e70 00000000 b6f17000 00000036 00000000 00000000 b6f6d000 bec33d4c
    dfe0: b6ea1bd0 bec33d0c 00008c9c b6ea1bdc 60000010 00000003 00000000 00000000
    (_omap_device_enable_hwmods+0x20/0x34)
    (omap_device_enable+0x3c/0x50)
    (_od_runtime_resume+0x10/0x1c)
    (__rpm_callback+0x54/0x98)
    (rpm_callback+0x64/0x7c)
    (rpm_resume+0x434/0x554)
    (__pm_runtime_resume+0x48/0x74)
    (omap_i2c_xfer+0x28/0xe8)
    (__i2c_transfer+0x3c/0x78)
    (i2c_transfer+0x6c/0xc0)
    (i2c_master_send+0x38/0x48)
    (sha204p_send_command+0x60/0x9c)
    (sha204c_send_and_receive+0x5c/0x1e0)
    (sha204m_read+0x94/0xa0)
    (otp_do_read+0x50/0xa4)
    (vfs_ioctl+0x24/0x40)
    (do_vfs_ioctl+0x1b0/0x1c0)
    (sys_ioctl+0x38/0x54)
    (ret_fast_syscall+0x0/0x30)
    Code: e1a08002 ea000009 e598003c e592c05c (e7904003)
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Jean-Philippe Fran=C3=A7ois <jp.francois@cynove.com>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    [tony@atomide.com: updated description with oops]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index d25a95fe9921..e3289888adfa 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2065,7 +2065,7 @@ static int _omap4_get_context_lost(struct omap_hwmod *oh)
  * do so is present in the hwmod data, then call it and pass along the
  * return value; otherwise, return 0.
  */
-static int __init _enable_preprogram(struct omap_hwmod *oh)
+static int _enable_preprogram(struct omap_hwmod *oh)
 {
 	if (!oh->class->enable_preprogram)
 		return 0;

commit 38f56f33ca381751f9b8910f67e7a805ec0b68cb
Merge: fcba91454208 4183bef2e093
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 11:06:17 2013 -0700

    Merge tag 'dt-for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC device tree updates (part 2) from Arnd Bergmann:
     "These are mostly new device tree bindings for existing drivers, as
      well as changes to the device tree source files to add support for
      those devices, and a couple of new boards, most notably Samsung's
      Exynos5 based Chromebook.
    
      The changes depend on earlier platform specific updates and touch the
      usual platforms: omap, exynos, tegra, mxs, mvebu and davinci."
    
    * tag 'dt-for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (169 commits)
      ARM: exynos: dts: cros5250: add EC device
      ARM: dts: Add sbs-battery for exynos5250-snow
      ARM: dts: Add i2c-arbitrator bus for exynos5250-snow
      ARM: dts: add mshc controller node for Exynos4x12 SoCs
      ARM: dts: Add chip-id controller node on Exynos4/5 SoC
      ARM: EXYNOS: Create virtual I/O mapping for Chip-ID controller using device tree
      ARM: davinci: da850-evm: add SPI flash support
      ARM: davinci: da850: override SPI DT node device name
      ARM: davinci: da850: add SPI1 DT node
      spi/davinci: add DT binding documentation
      spi/davinci: no wildcards in DT compatible property
      ARM: dts: mvebu: Convert mvebu device tree files to 64 bits
      ARM: dts: mvebu: introduce internal-regs node
      ARM: dts: mvebu: Convert all the mvebu files to use the range property
      ARM: dts: mvebu: move all peripherals inside soc
      ARM: dts: mvebu: fix cpus section indentation
      ARM: davinci: da850: add EHRPWM & ECAP DT node
      ARM/dts: OMAP3: fix pinctrl-single configuration
      ARM: dts: Add OMAP3430 SDP NOR flash memory binding
      ARM: dts: Add NOR flash bindings for OMAP2420 H4
      ...

commit 4183bef2e093a2f0aab45f2d5fed82b0e02aeacf
Merge: 662478d060a3 775c4f66fd85
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon May 6 23:38:00 2013 +0200

    Merge branch 'late/dt' into next/dt2
    
    This is support for the ARM Chromebook, originally scheduled
    as a "late" pull request. Since it's already late now, we
    can combine this into the existing next/dt2 branch.
    
    * late/dt:
      ARM: exynos: dts: cros5250: add EC device
      ARM: dts: Add sbs-battery for exynos5250-snow
      ARM: dts: Add i2c-arbitrator bus for exynos5250-snow
      ARM: dts: Add chip-id controller node on Exynos4/5 SoC
      ARM: EXYNOS: Create virtual I/O mapping for Chip-ID controller using device tree

commit 8546dc1d4b671480961c3eaf4c0c102ae6848340
Merge: 9992ba72327f 33b9f582c5c1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 3 09:13:19 2013 -0700

    Merge branch 'for-linus' of git://git.linaro.org/people/rmk/linux-arm
    
    Pull ARM updates from Russell King:
     "The major items included in here are:
    
       - MCPM, multi-cluster power management, part of the infrastructure
         required for ARMs big.LITTLE support.
    
       - A rework of the ARM KVM code to allow re-use by ARM64.
    
       - Error handling cleanups of the IS_ERR_OR_NULL() madness and fixes
         of that stuff for arch/arm
    
       - Preparatory patches for Cortex-M3 support from Uwe Kleine-Knig.
    
      There is also a set of three patches in here from Hugh/Catalin to
      address freeing of inappropriate page tables on LPAE.  You already
      have these from akpm, but they were already part of my tree at the
      time he sent them, so unfortunately they'll end up with duplicate
      commits"
    
    * 'for-linus' of git://git.linaro.org/people/rmk/linux-arm: (77 commits)
      ARM: EXYNOS: remove unnecessary use of IS_ERR_VALUE()
      ARM: IMX: remove unnecessary use of IS_ERR_VALUE()
      ARM: OMAP: use consistent error checking
      ARM: cleanup: OMAP hwmod error checking
      ARM: 7709/1: mcpm: Add explicit AFLAGS to support v6/v7 multiplatform kernels
      ARM: 7700/2: Make cpu_init() notrace
      ARM: 7702/1: Set the page table freeing ceiling to TASK_SIZE
      ARM: 7701/1: mm: Allow arch code to control the user page table ceiling
      ARM: 7703/1: Disable preemption in broadcast_tlb*_a15_erratum()
      ARM: mcpm: provide an interface to set the SMP ops at run time
      ARM: mcpm: generic SMP secondary bringup and hotplug support
      ARM: mcpm_head.S: vlock-based first man election
      ARM: mcpm: Add baremetal voting mutexes
      ARM: mcpm: introduce helpers for platform coherency exit/setup
      ARM: mcpm: introduce the CPU/cluster power API
      ARM: multi-cluster PM: secondary kernel entry code
      ARM: cacheflush: add synchronization helpers for mixed cache state accesses
      ARM: cpu hotplug: remove majority of cache flushing from platforms
      ARM: smp: flush L1 cache in cpu_die()
      ARM: tegra: remove tegra specific cpu_disable()
      ...

commit 33b9f582c5c1db515412cc7efff28f7d1779321f
Merge: 946342d03ec4 008ca431822f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu May 2 21:31:29 2013 +0100

    Merge branch 'cleanup' into for-linus
    
    Conflicts:
            arch/arm/plat-omap/dmtimer.c

commit c48cd659892962f79bba4b4e0eedea8e5aa54c44
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Mar 13 20:44:21 2013 +0000

    ARM: OMAP: use consistent error checking
    
    Consistently check errors using the usual method used in the kernel
    for much of its history.  For instance:
    
    int gpmc_cs_set_timings(int cs, const struct gpmc_timings *t)
    {
            int div;
            div = gpmc_calc_divider(t->sync_clk);
            if (div < 0)
                    return div;
    static int gpmc_set_async_mode(int cs, struct gpmc_timings *t)
    {
    ...
            return gpmc_cs_set_timings(cs, t);
    
    .....
            ret = gpmc_set_async_mode(gpmc_onenand_data->cs, &t);
            if (IS_ERR_VALUE(ret))
                    return ret;
    
    So, gpmc_cs_set_timings() thinks any negative return value is an error,
    but where we check that in higher levels, only a limited range are
    errors...
    
    There is only _one_ use of IS_ERR_VALUE() in arch/arm which is really
    appropriate, and that is in arch/arm/include/asm/syscall.h:
    
    static inline long syscall_get_error(struct task_struct *task,
                                         struct pt_regs *regs)
    {
            unsigned long error = regs->ARM_r0;
            return IS_ERR_VALUE(error) ? error : 0;
    }
    
    because this function really does have to differentiate between error
    return values and addresses which look like negative numbers (eg, from
    mmap()).
    
    So, here's a patch to remove them from OMAP, except for the above.
    
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 4653efb87a27..b7c0a2d3f2c7 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1661,7 +1661,7 @@ static int _deassert_hardreset(struct omap_hwmod *oh, const char *name)
 		return -ENOSYS;
 
 	ret = _lookup_hardreset(oh, name, &ohri);
-	if (IS_ERR_VALUE(ret))
+	if (ret < 0)
 		return ret;
 
 	if (oh->clkdm) {
@@ -2387,7 +2387,7 @@ static int __init _init(struct omap_hwmod *oh, void *data)
 	_init_mpu_rt_base(oh, NULL);
 
 	r = _init_clocks(oh, NULL);
-	if (IS_ERR_VALUE(r)) {
+	if (r < 0) {
 		WARN(1, "omap_hwmod: %s: couldn't init clocks\n", oh->name);
 		return -EINVAL;
 	}

commit 4d26aa305414dbb33b3c32fb205b68004cda8ffc
Merge: 600fe9751aeb e74fc973b6e5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 2 08:56:55 2013 -0700

    Merge tag 'fixes-nc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC non-critical fixes from Olof Johansson:
     "Here is a collection of fixes (and some intermixed cleanups) that were
      considered less important and thus not included in the later parts of
      the 3.9-rc cycle.
    
      It's a bit all over the map, contents wise.  A series of ux500 fixes
      and cleanups, a bunch of various fixes for OMAP and tegra, and some
      for Freescale i.MX and even Qualcomm MSM.
    
      Note that there's also a patch on this branch to globally turn off
      -Wmaybe-uninitialized when building with -Os.  It's been posted
      several times by Arnd and no dissent was raised, but nobody seemed
      interested to pick it up.  So here it is, as the topmost patch."
    
    * tag 'fixes-nc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (70 commits)
      Turn off -Wmaybe-uninitialized when building with -Os
      ARM: orion5x: include linux/cpu.h
      ARM: tegra: call cpu_do_idle from C code
      ARM: u300: fix ages old copy/paste bug
      ARM: OMAP2+: add dependencies on ARCH_MULTI_V6/V7
      ARM: tegra: solve adr range issue with THUMB2_KERNEL enabled
      ARM: tegra: fix relocation truncated error when THUMB2_KERNEL enabled
      ARM: tegra: fix build error when THUMB2_KERNEL enabled
      ARM: msm: Fix uncompess.h tx underrun check
      ARM: vexpress: Remove A9 PMU compatible values for non-A9 platforms
      ARM: cpuimx27 and mbimx27: prepend CONFIG_ to Kconfig macro
      ARM: OMAP2+: fix typo "CONFIG_BRIDGE_DVFS"
      ARM: OMAP1: remove "config MACH_OMAP_HTCWIZARD"
      ARM: mach-imx: mach-imx6q: Fix sparse warnings
      ARM: mach-imx: src: Include "common.h
      ARM: mach-imx: gpc: Include "common.h"
      ARM: mach-imx: avic: Staticize *avic_base
      ARM: mach-imx: tzic: Staticize *tzic_base
      ARM: mach-imx: clk: Include "clk.h"
      ARM: mach-imx: clk-busy: Staticize clk_busy_mux_ops
      ...

commit 97597b962529fef9c6976bab57f25ef5ce5e7383
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Tue Mar 19 17:00:31 2013 +0530

    ARM: OMAP2+: hwmod: Don't call _init_mpu_rt_base if no sysc
    
    OMAP hwmod layer does the reset of the IPs in early code so that
    we have SOC in sane state. To do the soft-reset, it needs to ioremap()
    the IP address space to be able to write to sysconfig registers.
    
    But there are few hwmod which doesn't have sysconfig registers and hence
    no need to ioremap() them in early init code.
    
    Prevent calling the _init_mpu_rt_base() conditional based on sysc
    availability.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Benoit Cousson <benoit.cousson@linaro.org>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index ff729706c5a1..63b774fb8089 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2445,7 +2445,8 @@ static int __init _init(struct omap_hwmod *oh, void *data)
 	if (oh->_state != _HWMOD_STATE_REGISTERED)
 		return 0;
 
-	_init_mpu_rt_base(oh, NULL);
+	if (oh->class->sysc)
+		_init_mpu_rt_base(oh, NULL);
 
 	r = _init_clocks(oh, NULL);
 	if (IS_ERR_VALUE(r)) {

commit 079abade857e7ba7877a84536fbf5da5fa665d70
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Mon Jan 21 18:40:57 2013 +0530

    ARM: OMAP2+: hwmod: extract module address space from DT blob
    
    Patch adds the code for extracting the module ocp address space
    from device tree blob in case the hwmod address space look up fails.
    
    The idea is to remove the address space data from hwmod and extract
    it from DT blob.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Benoit Cousson <benoit.cousson@linaro.org>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index e5cafed8ef25..ff729706c5a1 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -138,6 +138,8 @@
 #include <linux/spinlock.h>
 #include <linux/slab.h>
 #include <linux/bootmem.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
 
 #include <asm/system_misc.h>
 
@@ -2345,6 +2347,34 @@ static int _shutdown(struct omap_hwmod *oh)
 	return 0;
 }
 
+/**
+ * of_dev_hwmod_lookup - look up needed hwmod from dt blob
+ * @np: struct device_node *
+ * @oh: struct omap_hwmod *
+ *
+ * Parse the dt blob and find out needed hwmod. Recursive function is
+ * implemented to take care hierarchical dt blob parsing.
+ * Return: The device node on success or NULL on failure.
+ */
+static struct device_node *of_dev_hwmod_lookup(struct device_node *np,
+						struct omap_hwmod *oh)
+{
+	struct device_node *np0 = NULL, *np1 = NULL;
+	const char *p;
+
+	for_each_child_of_node(np, np0) {
+		if (of_find_property(np0, "ti,hwmods", NULL)) {
+			p = of_get_property(np0, "ti,hwmods", NULL);
+			if (!strcmp(p, oh->name))
+				return np0;
+			np1 = of_dev_hwmod_lookup(np0, oh);
+			if (np1)
+				return np1;
+		}
+	}
+	return NULL;
+}
+
 /**
  * _init_mpu_rt_base - populate the virtual address for a hwmod
  * @oh: struct omap_hwmod * to locate the virtual address
@@ -2357,7 +2387,8 @@ static int _shutdown(struct omap_hwmod *oh)
 static void __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data)
 {
 	struct omap_hwmod_addr_space *mem;
-	void __iomem *va_start;
+	void __iomem *va_start = NULL;
+	struct device_node *np;
 
 	if (!oh)
 		return;
@@ -2371,10 +2402,18 @@ static void __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data)
 	if (!mem) {
 		pr_debug("omap_hwmod: %s: no MPU register target found\n",
 			 oh->name);
-		return;
+
+		/* Extract the IO space from device tree blob */
+		if (!of_have_populated_dt())
+			return;
+
+		np = of_dev_hwmod_lookup(of_find_node_by_name(NULL, "ocp"), oh);
+		if (np)
+			va_start = of_iomap(np, 0);
+	} else {
+		va_start = ioremap(mem->pa_start, mem->pa_end - mem->pa_start);
 	}
 
-	va_start = ioremap(mem->pa_start, mem->pa_end - mem->pa_start);
 	if (!va_start) {
 		pr_err("omap_hwmod: %s: Could not ioremap\n", oh->name);
 		return;

commit f7b861b7a6d9d1838cbbb5f4053e61578b86d134
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 21 22:49:38 2013 +0100

    arm: Use generic idle loop
    
    Use the generic idle loop and replace enable/disable_hlt with the
    respective core functions.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Paul McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Reviewed-by: Cc: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Tested-by: Kevin Hilman <khilman@linaro.org> # OMAP
    Link: http://lkml.kernel.org/r/20130321215233.826238797@linutronix.de

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index a202a4785104..e512253601c8 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -138,6 +138,7 @@
 #include <linux/spinlock.h>
 #include <linux/slab.h>
 #include <linux/bootmem.h>
+#include <linux/cpu.h>
 
 #include <asm/system_misc.h>
 
@@ -2157,7 +2158,7 @@ static int _enable(struct omap_hwmod *oh)
 	if (soc_ops.enable_module)
 		soc_ops.enable_module(oh);
 	if (oh->flags & HWMOD_BLOCK_WFI)
-		disable_hlt();
+		cpu_idle_poll_ctrl(true);
 
 	if (soc_ops.update_context_lost)
 		soc_ops.update_context_lost(oh);
@@ -2221,7 +2222,7 @@ static int _idle(struct omap_hwmod *oh)
 	_del_initiator_dep(oh, mpu_oh);
 
 	if (oh->flags & HWMOD_BLOCK_WFI)
-		enable_hlt();
+		cpu_idle_poll_ctrl(false);
 	if (soc_ops.disable_module)
 		soc_ops.disable_module(oh);
 
@@ -2331,7 +2332,7 @@ static int _shutdown(struct omap_hwmod *oh)
 		_del_initiator_dep(oh, mpu_oh);
 		/* XXX what about the other system initiators here? dma, dsp */
 		if (oh->flags & HWMOD_BLOCK_WFI)
-			enable_hlt();
+			cpu_idle_poll_ctrl(false);
 		if (soc_ops.disable_module)
 			soc_ops.disable_module(oh);
 		_disable_clocks(oh);

commit 4280943b6bc81357eb61c3e1111d2d83ec2ef03d
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Sun Mar 31 20:22:22 2013 -0600

    ARM: OMAP2+: hwmod: Remove unused _HWMOD_WAKEUP_ENABLED flag
    
    _HWMOD_WAKEUP_ENABLED is currently unused across the hwmod
    framework. Just get rid of it, so we have one less flag to
    worry about.
    
    Tested-by: Vaibhav Bedia <vaibhav.bedia@ti.com>
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index c2c798c08c2b..e5cafed8ef25 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -610,8 +610,6 @@ static int _enable_wakeup(struct omap_hwmod *oh, u32 *v)
 
 	/* XXX test pwrdm_get_wken for this hwmod's subsystem */
 
-	oh->_int_flags |= _HWMOD_WAKEUP_ENABLED;
-
 	return 0;
 }
 
@@ -645,8 +643,6 @@ static int _disable_wakeup(struct omap_hwmod *oh, u32 *v)
 
 	/* XXX test pwrdm_get_wken for this hwmod's subsystem */
 
-	oh->_int_flags &= ~_HWMOD_WAKEUP_ENABLED;
-
 	return 0;
 }
 

commit 092bc089c249de0fa0f0c98b28dea6e5f1367b6e
Author: Grazvydas Ignotas <notasas@gmail.com>
Date:   Mon Mar 11 21:49:00 2013 +0200

    ARM: OMAP3: hwmod data: keep MIDLEMODE in force-standby for musb
    
    For some unknown reason, allowing hwmod to control MIDLEMODE causes
    core_pwrdm to not hit idle states for musb in DM3730 at least.
    I've verified that setting any MIDLEMODE value other than "force
    standby" before enabling the device causes subsequent suspend
    attempts to fail with core_pwrdm not entering idle states, even
    if the driver is unloaded and "force standby" is restored before
    suspend attempt. To recover from this, soft reset can be used, but
    that's not suitable solution for suspend.
    
    Keeping the register set at force standby (reset value) makes it work
    and device still functions properly, as musb has driver-controlled
    OTG_FORCESTDBY register that controls MSTANDBY signal.
    Note that TI PSP kernels also have similar workarounds.
    
    This patch also fixes HWMOD_SWSUP_MSTANDBY documentation to match the
    actual flag name.
    
    Signed-off-by: Grazvydas Ignotas <notasas@gmail.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index c2c798c08c2b..a202a4785104 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1368,7 +1368,9 @@ static void _enable_sysc(struct omap_hwmod *oh)
 	}
 
 	if (sf & SYSC_HAS_MIDLEMODE) {
-		if (oh->flags & HWMOD_SWSUP_MSTANDBY) {
+		if (oh->flags & HWMOD_FORCE_MSTANDBY) {
+			idlemode = HWMOD_IDLEMODE_FORCE;
+		} else if (oh->flags & HWMOD_SWSUP_MSTANDBY) {
 			idlemode = HWMOD_IDLEMODE_NO;
 		} else {
 			if (sf & SYSC_HAS_ENAWAKEUP)
@@ -1440,7 +1442,8 @@ static void _idle_sysc(struct omap_hwmod *oh)
 	}
 
 	if (sf & SYSC_HAS_MIDLEMODE) {
-		if (oh->flags & HWMOD_SWSUP_MSTANDBY) {
+		if ((oh->flags & HWMOD_SWSUP_MSTANDBY) ||
+		    (oh->flags & HWMOD_FORCE_MSTANDBY)) {
 			idlemode = HWMOD_IDLEMODE_FORCE;
 		} else {
 			if (sf & SYSC_HAS_ENAWAKEUP)

commit 7307c00f335a4e986586b12334696098d2fc2bcd
Merge: f8f466c81795 55ccb1a8b4c1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 28 20:00:40 2013 -0800

    Merge tag 'late-omap' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC late OMAP changes from Olof Johansson:
     "This branch contains changes for OMAP that came in late during the
      release staging, close to when the merge window opened.
    
      It contains, among other things:
    
       - OMAP PM fixes and some patches for audio device integration
       - OMAP clock fixes related to common clock conversion
       - A set of patches cleaning up WFI entry and blocking.
       - A set of fixes and IP block support for PM on TI AM33xx SoCs
         (Beaglebone, etc)
       - A set of smaller fixes and cleanups around AM33xx restart and
         revision detection, as well as removal of some dead code
         (CONFIG_32K_TIMER_HZ)"
    
    * tag 'late-omap' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (34 commits)
      ARM: omap2: include linux/errno.h in hwmod_reset
      ARM: OMAP2+: fix some omap_device_build() calls that aren't compiled by default
      ARM: OMAP4: hwmod data: Enable AESS hwmod device
      ARM: OMAP4: hwmod data: Update AESS data with memory bank area
      ARM: OMAP4+: AESS: enable internal auto-gating during initial setup
      ASoC: TI AESS: add autogating-enable function, callable from architecture code
      ARM: OMAP2+: hwmod: add enable_preprogram hook
      ARM: OMAP4: clock data: Add missing clkdm association for dpll_usb
      ARM: OMAP2+: PM: Fix the dt return condition in pm_late_init()
      ARM: OMAP2: am33xx-hwmod: Fix "register offset NULL check" bug
      ARM: OMAP2+: AM33xx: hwmod: add missing HWMOD_NO_IDLEST flags
      ARM: OMAP: AM33xx hwmod: Add parent-child relationship for PWM subsystem
      ARM: OMAP: AM33xx hwmod: Corrects PWM subsystem HWMOD entries
      ARM: DTS: AM33XX: Add nodes for OCMC RAM and WKUP-M3
      ARM: OMAP2+: AM33XX: Update the hardreset API
      ARM: OMAP2+: AM33XX: hwmod: Update the WKUP-M3 hwmod with reset status bit
      ARM: OMAP2+: AM33XX: hwmod: Fixup cpgmac0 hwmod entry
      ARM: OMAP2+: AM33XX: hwmod: Update TPTC0 hwmod with the right flags
      ARM: OMAP2+: AM33XX: hwmod: Register OCMC RAM hwmod
      ARM: OMAP2+: AM33XX: CM/PRM: Use __ASSEMBLER__ macros in header files
      ...

commit bab588fcfb6335c767d811a8955979f5440328e0
Merge: 3298a3511f1e 9cb0d1babfcb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 21 15:27:22 2013 -0800

    Merge tag 'soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC-specific updates from Arnd Bergmann:
     "This is a larger set of new functionality for the existing SoC
      families, including:
    
       - vt8500 gains support for new CPU cores, notably the Cortex-A9 based
         wm8850
    
       - prima2 gains support for the "marco" SoC family, its SMP based
         cousin
    
       - tegra gains support for the new Tegra4 (Tegra114) family
    
       - socfpga now supports a newer version of the hardware including SMP
    
       - i.mx31 and bcm2835 are now using DT probing for their clocks
    
       - lots of updates for sh-mobile
    
       - OMAP updates for clocks, power management and USB
    
       - i.mx6q and tegra now support cpuidle
    
       - kirkwood now supports PCIe hot plugging
    
       - tegra clock support is updated
    
       - tegra USB PHY probing gets implemented diffently"
    
    * tag 'soc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (148 commits)
      ARM: prima2: remove duplicate v7_invalidate_l1
      ARM: shmobile: r8a7779: Correct TMU clock support again
      ARM: prima2: fix __init section for cpu hotplug
      ARM: OMAP: Consolidate OMAP USB-HS platform data (part 3/3)
      ARM: OMAP: Consolidate OMAP USB-HS platform data (part 1/3)
      arm: socfpga: Add SMP support for actual socfpga harware
      arm: Add v7_invalidate_l1 to cache-v7.S
      arm: socfpga: Add entries to enable make dtbs socfpga
      arm: socfpga: Add new device tree source for actual socfpga HW
      ARM: tegra: sort Kconfig selects for Tegra114
      ARM: tegra: enable ARCH_REQUIRE_GPIOLIB for Tegra114
      ARM: tegra: Fix build error w/ ARCH_TEGRA_114_SOC w/o ARCH_TEGRA_3x_SOC
      ARM: tegra: Fix build error for gic update
      ARM: tegra: remove empty tegra_smp_init_cpus()
      ARM: shmobile: Register ARM architected timer
      ARM: MARCO: fix the build issue due to gic-vic-to-irqchip move
      ARM: shmobile: r8a7779: Correct TMU clock support
      ARM: mxs_defconfig: Select CONFIG_DEVTMPFS_MOUNT
      ARM: mxs: decrease mxs_clockevent_device.min_delta_ns to 2 clock cycles
      ARM: mxs: use apbx bus clock to drive the timers on timrotv2
      ...

commit ebcfe0faf969fe64060132a455db64bcc3517e5c
Merge: 488c77c961e6 93b23711b713
Author: Olof Johansson <olof@lixom.net>
Date:   Tue Feb 12 15:33:39 2013 -0800

    Merge tag 'omap-for-v3.9/pm-omap4-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into late/omap
    
    From Tony Lindgren:
    omap4 pm changes via Paul Walmsley <paul@pwsan.com>:
    
    Some OMAP4 power management fixes and audio device integration
    patches.  This pull request contains a fix for an issue discovered during
    branch integration.
    
    Basic test logs are available at:
    
        http://www.pwsan.com/omap/testlogs/omap4_prcm_devel_a_3.9/20130210112717/
    
    * tag 'omap-for-v3.9/pm-omap4-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap:
      ARM: OMAP4: hwmod data: Enable AESS hwmod device
      ARM: OMAP4: hwmod data: Update AESS data with memory bank area
      ARM: OMAP4+: AESS: enable internal auto-gating during initial setup
      ASoC: TI AESS: add autogating-enable function, callable from architecture code
      ARM: OMAP2+: hwmod: add enable_preprogram hook
      ARM: OMAP2+: PM: Fix the dt return condition in pm_late_init()
      ARM: OMAP4: PM: Warn users about usage of older bootloaders

commit 379095930b0383e48be6da308e041aca8860c72d
Merge: 0a0db4a1e4c6 25e4d0f6df35
Author: Olof Johansson <olof@lixom.net>
Date:   Tue Feb 12 15:32:50 2013 -0800

    Merge tag 'omap-for-v3.9/pm-wfi-take2-signed-v2' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into late/omap
    
    From Tony Lindgren:
    omap pm wfi changes via Paul Walmsley <paul@pwsan.com>:
    
    On OMAP2+ devices, standardize and clean up WFI entry and WFI blocking.
    
    Basic test logs are available here:
    
       http://www.pwsan.com/omap/testlogs/wfi_devel_a_3.9/20130208085027/
    
    Conflicts:
        arch/arm/mach-omap2/pm24xx.c
    
    Note that this is based on earlier omap-for-v3.9/pm-signed because
    of a non-trivial merge conflict. This branch also contains a fix
    for c1d1cd59 ("ARM: OMAP2+: omap_device: remove obsolete pm_lats
    and early_device code").
    
    * tag 'omap-for-v3.9/pm-wfi-take2-signed-v2' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap: (25 commits)
      ARM: OMAP2+: fix some omap_device_build() calls that aren't compiled by default
      ARM: OMAP AM3517/05: hwmod data: block WFI when EMAC active
      ARM: OMAP2420: hwmod data/PM: use hwmod to block WFI when I2C active
      ARM: OMAP2+: hwmod: add support for blocking WFI when a device is active
      ARM: OMAP2xxx: PM: enter WFI via inline asm if CORE stays active
      ARM: OMAP2+: powerdomain: fix whitespace, improve flag comments
      ARM: OMAP2+: clockdomain: convert existing atomic usecounts into spinlock-protected shorts/ints
      ARM: OMAP2+: clockdomain: work on wkdep/sleepdep functions
      ARM: OMAP2xxx: CM: remove autodep handling
      ARM: OMAP2+: powerdomain/clockdomain: add a per-powerdomain spinlock
      ARM: OMAP2+: PM/powerdomain: move omap_set_pwrdm_state() to powerdomain code
      ARM: OMAP2: PM/powerdomain: drop unnecessary pwrdm_wait_transition()
      ARM: OMAP2xxx: PM: clean up some crufty powerstate programming code
      ARM: OMAP2+: clockdomain: add pwrdm_state_switch() call to clkdm_sleep()
      ARM: OMAP2+: powerdomain: fix powerdomain trace integration
      ARM: OMAP4: MPUSS PM: remove unnecessary shim functions for powerdomain control
      ARM: OMAP3xxx: CPUIdle: optimize __omap3_enter_idle()
      ARM: OMAP2420: hwmod data/PM: use hwmod to block WFI when I2C active
      ARM: OMAP2+: hwmod: add support for blocking WFI when a device is active
      ARM: OMAP3xxx: CPUIdle: simplify the PER next-state code
      ...

commit 6d266f63a11bce427504d203834df3c0bb9be9a5
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Feb 10 11:22:22 2013 -0700

    ARM: OMAP2+: hwmod: add enable_preprogram hook
    
    After setup/enable, some IP blocks need some additional setting to
    indicate the PRCM that they are inactive until they are configured.
    Some examples on OMAP4 include the AESS and FSUSB IP blocks.
    
    To fix this cleanly, this patch adds another optional function
    pointer, enable_preprogram, to the IP block's hwmod data.  The function
    that is pointed to is called by the hwmod code immediately after the
    IP block is reset.
    
    This version of the patch includes a patch description fix from Felipe.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Sebastien Guiriec <s-guiriec@ti.com>
    Cc: Benot Cousson <b-cousson@ti.com>
    Cc: Pter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Felipe Balbi <balbi@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 4653efb87a27..f37d22c597f9 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2052,6 +2052,23 @@ static int _omap4_get_context_lost(struct omap_hwmod *oh)
 	return oh->prcm.omap4.context_lost_counter;
 }
 
+/**
+ * _enable_preprogram - Pre-program an IP block during the _enable() process
+ * @oh: struct omap_hwmod *
+ *
+ * Some IP blocks (such as AESS) require some additional programming
+ * after enable before they can enter idle.  If a function pointer to
+ * do so is present in the hwmod data, then call it and pass along the
+ * return value; otherwise, return 0.
+ */
+static int __init _enable_preprogram(struct omap_hwmod *oh)
+{
+	if (!oh->class->enable_preprogram)
+		return 0;
+
+	return oh->class->enable_preprogram(oh);
+}
+
 /**
  * _enable - enable an omap_hwmod
  * @oh: struct omap_hwmod *
@@ -2156,6 +2173,7 @@ static int _enable(struct omap_hwmod *oh)
 				_update_sysc_cache(oh);
 			_enable_sysc(oh);
 		}
+		r = _enable_preprogram(oh);
 	} else {
 		if (soc_ops.disable_module)
 			soc_ops.disable_module(oh);

commit 3c06f1b8c3ca74669b77c0aaee428b5c46d3e552
Author: Vaibhav Bedia <vaibhav.bedia@ti.com>
Date:   Tue Jan 29 16:45:06 2013 +0530

    ARM: OMAP2+: AM33XX: Update the hardreset API
    
    WKUP-M3 has a reset status bit (RM_WKUP_STST.WKUP_M3_LRST)
    Update the hardreset API to ensure that the reset line properly
    deasserted.
    
    Signed-off-by: Vaibhav Bedia <vaibhav.bedia@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Peter Korsgaard <jacmet@sunsite.dk>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 4653efb87a27..6549439d8d5f 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3041,11 +3041,8 @@ static int _am33xx_assert_hardreset(struct omap_hwmod *oh,
 static int _am33xx_deassert_hardreset(struct omap_hwmod *oh,
 				     struct omap_hwmod_rst_info *ohri)
 {
-	if (ohri->st_shift)
-		pr_err("omap_hwmod: %s: %s: hwmod data error: OMAP4 does not support st_shift\n",
-		       oh->name, ohri->name);
-
 	return am33xx_prm_deassert_hardreset(ohri->rst_shift,
+				ohri->st_shift,
 				oh->clkdm->pwrdm.ptr->prcm_offs,
 				oh->prcm.omap4.rstctrl_offs,
 				oh->prcm.omap4.rstst_offs);

commit fa2002223e12c6b1bc96381b70c376afe4e01d80
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Jan 26 00:48:56 2013 -0700

    ARM: OMAP2+: hwmod: add support for blocking WFI when a device is active
    
    Apparently, on some OMAPs, the MPU can't be allowed to enter WFI while
    certain peripherals are active.  It's not clear why, and it's likely
    that there is simply some other bug in the driver or integration code.
    But since the likelihood that anyone will have the time to track these
    problems down in the future seems quite small, we'll provide a
    flag, HWMOD_BLOCK_WFI, to mark these issues in the hwmod data.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 4653efb87a27..6804d474a47d 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -139,6 +139,8 @@
 #include <linux/slab.h>
 #include <linux/bootmem.h>
 
+#include <asm/system_misc.h>
+
 #include "clock.h"
 #include "omap_hwmod.h"
 
@@ -2134,6 +2136,8 @@ static int _enable(struct omap_hwmod *oh)
 	_enable_clocks(oh);
 	if (soc_ops.enable_module)
 		soc_ops.enable_module(oh);
+	if (oh->flags & HWMOD_BLOCK_WFI)
+		disable_hlt();
 
 	if (soc_ops.update_context_lost)
 		soc_ops.update_context_lost(oh);
@@ -2195,6 +2199,8 @@ static int _idle(struct omap_hwmod *oh)
 		_idle_sysc(oh);
 	_del_initiator_dep(oh, mpu_oh);
 
+	if (oh->flags & HWMOD_BLOCK_WFI)
+		enable_hlt();
 	if (soc_ops.disable_module)
 		soc_ops.disable_module(oh);
 
@@ -2303,6 +2309,8 @@ static int _shutdown(struct omap_hwmod *oh)
 	if (oh->_state == _HWMOD_STATE_ENABLED) {
 		_del_initiator_dep(oh, mpu_oh);
 		/* XXX what about the other system initiators here? dma, dsp */
+		if (oh->flags & HWMOD_BLOCK_WFI)
+			enable_hlt();
 		if (soc_ops.disable_module)
 			soc_ops.disable_module(oh);
 		_disable_clocks(oh);

commit b76c8b19b082c3fc84725de0d3ba5ee1f571c0ae
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Jan 11 11:24:18 2013 -0800

    ARM: OMAP2+: Use omap initcalls
    
    This way the initcalls don't run on other SoCs on multiplatform
    kernels. Otherwise we'll get something like this when booting
    on vexpress:
    
    omap_hwmod: _ensure_mpu_hwmod_is_setup: MPU initiator hwmod mpu not yet registered
    ...
    WARNING: at arch/arm/mach-omap2/pm.c:82 _init_omap_device+0x74/0x94()
    _init_omap_device: could not find omap_hwmod for mpu
    ...
    omap-dma-engine omap-dma-engine: OMAP DMA engine driver
    ...
    
    Tested-by: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 4653efb87a27..6e70707cbb34 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3303,7 +3303,7 @@ static int __init omap_hwmod_setup_all(void)
 
 	return 0;
 }
-core_initcall(omap_hwmod_setup_all);
+omap_core_initcall(omap_hwmod_setup_all);
 
 /**
  * omap_hwmod_enable - enable an omap_hwmod

commit 9121dfca73d81fa886f15610cac2bf372391f3eb
Merge: 77f9db89c928 8b9c1ac2e11a
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Nov 29 22:49:30 2012 -0800

    Merge tag 'omap-for-v3.8/devel-prcm-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into next/pm2
    
    From Tony Lindgren:
    
    omap prcm changes via Paul Walmsley <paul@pwsan.com>:
    
    Some miscellaneous OMAP hwmod changes for 3.8, along with a PRM
    change needed for one of the hwmod patches to function.
    
    Basic test logs for this branch on top of Tony's
    omap-for-v3.8/clock branch at commit
    558a0780b0a04862a678f7823215424b4e5501f9 are here:
    
    http://www.pwsan.com/omap/testlogs/hwmod_devel_a_3.8/20121121161522/
    
    However, omap-for-v3.8/clock at 558a0780 does not include some fixes
    that are needed for a successful test.  With several reverts,
    fixes, and workarounds applied, the following test logs were
    obtained:
    
    http://www.pwsan.com/omap/testlogs/TEST_hwmod_devel_a_3.8/20121121162719/
    
    which indicate that the series tests cleanly.
    
    * tag 'omap-for-v3.8/devel-prcm-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap: (49 commits)
      ARM: OMAP2+: omap_device: Correct resource handling for DT boot
      ARM: OMAP2+: hwmod: Add possibility to count hwmod resources based on type
      ARM: OMAP2+: hwmod: Add support for per hwmod/module context lost count
      ARM: OMAP2+: PRM: initialize some PRM functions early
      ARM: OMAP2+: clock: Cleanup !CONFIG_COMMON_CLK parts
      ARM: OMAP2xxx: clock: drop obsolete clock data
      ARM: OMAP2: clock: Cleanup !CONFIG_COMMON_CLK parts
      ARM: OMAP3+: DPLL: drop !CONFIG_COMMON_CLK sections
      ARM: AM33xx: clock: drop obsolete clock data
      ARM: OMAP3xxx: clk: drop obsolete clock data
      ARM: OMAP3: clock: Cleanup !CONFIG_COMMON_CLK parts
      ARM: OMAP44xx: clock: drop obsolete clock data
      ARM: OMAP4: clock: Cleanup !CONFIG_COMMON_CLK parts
      ARM: OMAP: hwmod: Cleanup !CONFIG_COMMON_CLK parts
      ARM: OMAP: clock: Switch to COMMON clk
      ARM: OMAP2: clock: Add 24xx data using common struct clk
      ARM: OMAP3: clock: Add 3xxx data using common struct clk
      ARM: AM33XX: clock: add clock data in common clock format
      ARM: OMAP4: clock: Add 44xx data using common struct clk
      ARM: OMAP2+: clock: add OMAP CCF convenience macros to mach-omap2/clock.h
      ...
    
    Some context conflicts due to nearby changes resolved in
    arch/arm/mach-omap2/io.c.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 0f9cb211ba5db93d488fe6b154138231fdd0e22d
Merge: 007108a22791 9489e9dcae71
Author: Olof Johansson <olof@lixom.net>
Date:   Sun Nov 25 21:34:34 2012 -0800

    Merge tag 'v3.7-rc7' into next/cleanup
    
    Merging in mainline back to next/cleanup since it has collected a few
    conflicts between fixes going upstream and some of the cleanup patches.
    Git doesn't auto-resolve some of them, and they're mostly noise so let's
    take care of it locally.
    
    Conflicts are in:
            arch/arm/mach-omap2/omap_hwmod_44xx_data.c
            arch/arm/plat-omap/i2c.c
            drivers/video/omap2/dss/dss.c
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit dad4191d79bded6674529084bcf842c00e4d874a
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Wed Nov 21 16:15:17 2012 -0700

    ARM: OMAP2+: hwmod: Add possibility to count hwmod resources based on type
    
    Add flags parameter for omap_hwmod_count_resources() so users can tell which
    type of resources they are interested when counting them in hwmod database.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Benot Cousson <b-cousson@ti.com>
    [paul@pwsan.com: updated to apply]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 083adbed0bfd..a8090907fe35 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3427,7 +3427,7 @@ int omap_hwmod_reset(struct omap_hwmod *oh)
 /**
  * omap_hwmod_count_resources - count number of struct resources needed by hwmod
  * @oh: struct omap_hwmod *
- * @res: pointer to the first element of an array of struct resource to fill
+ * @flags: Type of resources to include when counting (IRQ/DMA/MEM)
  *
  * Count the number of struct resource array elements necessary to
  * contain omap_hwmod @oh resources.  Intended to be called by code
@@ -3440,20 +3440,25 @@ int omap_hwmod_reset(struct omap_hwmod *oh)
  * resource IDs.
  *
  */
-int omap_hwmod_count_resources(struct omap_hwmod *oh)
+int omap_hwmod_count_resources(struct omap_hwmod *oh, unsigned long flags)
 {
-	struct omap_hwmod_ocp_if *os;
-	struct list_head *p;
-	int ret;
-	int i = 0;
+	int ret = 0;
 
-	ret = _count_mpu_irqs(oh) + _count_sdma_reqs(oh);
+	if (flags & IORESOURCE_IRQ)
+		ret += _count_mpu_irqs(oh);
 
-	p = oh->slave_ports.next;
+	if (flags & IORESOURCE_DMA)
+		ret += _count_sdma_reqs(oh);
 
-	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(&p, &i);
-		ret += _count_ocp_if_addr_spaces(os);
+	if (flags & IORESOURCE_MEM) {
+		int i = 0;
+		struct omap_hwmod_ocp_if *os;
+		struct list_head *p = oh->slave_ports.next;
+
+		while (i < oh->slaves_cnt) {
+			os = _fetch_next_ocp_if(&p, &i);
+			ret += _count_ocp_if_addr_spaces(os);
+		}
 	}
 
 	return ret;

commit e6d3a8b0bdcd8f323488a52927682190aee5488e
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Wed Nov 21 16:15:17 2012 -0700

    ARM: OMAP2+: hwmod: Add support for per hwmod/module context lost count
    
    OMAP4 has module specific context lost registers which makes it now
    possible to have module level context loss count, instead of relying
    on the powerdomain level context count.
    
    Add 2 private hwmod api's to update/clear the hwmod/module specific
    context lost counters/register.
    
    Update the module specific context_lost_counter and clear the hardware
    bits just after enabling the module.
    
    omap_hwmod_get_context_loss_count() now returns the hwmod context loss
    count them on platforms where they exist (OMAP4), else fall back on
    the pwrdm level counters for older platforms.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    [paul@pwsan.com: added function kerneldoc, fixed structure kerneldoc,
     rearranged structure to avoid memory waste, marked fns as OMAP4-specific,
     prevent fn entry on non-OMAP4 chips, reduced indentation, merged update
     and clear, merged patches]
    [t-kristo@ti.com: added support for arch specific hwmod ops, and changed
     the no context offset indicator to USHRT_MAX]
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    [paul@pwsan.com: use NO_CONTEXT_LOSS_BIT flag rather than USHRT_MAX;
     convert unsigned context lost counter to int to match the return type;
     get rid of hwmod_ops in favor of the existing soc_ops mechanism;
     move context loss low-level accesses to the PRM code]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 68616b2b5b96..083adbed0bfd 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -187,6 +187,8 @@ struct omap_hwmod_soc_ops {
 	int (*is_hardreset_asserted)(struct omap_hwmod *oh,
 				     struct omap_hwmod_rst_info *ohri);
 	int (*init_clkdm)(struct omap_hwmod *oh);
+	void (*update_context_lost)(struct omap_hwmod *oh);
+	int (*get_context_lost)(struct omap_hwmod *oh);
 };
 
 /* soc_ops: adapts the omap_hwmod code to the currently-booted SoC */
@@ -1982,6 +1984,42 @@ static void _reconfigure_io_chain(void)
 	spin_unlock_irqrestore(&io_chain_lock, flags);
 }
 
+/**
+ * _omap4_update_context_lost - increment hwmod context loss counter if
+ * hwmod context was lost, and clear hardware context loss reg
+ * @oh: hwmod to check for context loss
+ *
+ * If the PRCM indicates that the hwmod @oh lost context, increment
+ * our in-memory context loss counter, and clear the RM_*_CONTEXT
+ * bits. No return value.
+ */
+static void _omap4_update_context_lost(struct omap_hwmod *oh)
+{
+	if (oh->prcm.omap4.flags & HWMOD_OMAP4_NO_CONTEXT_LOSS_BIT)
+		return;
+
+	if (!prm_was_any_context_lost_old(oh->clkdm->pwrdm.ptr->prcm_partition,
+					  oh->clkdm->pwrdm.ptr->prcm_offs,
+					  oh->prcm.omap4.context_offs))
+		return;
+
+	oh->prcm.omap4.context_lost_counter++;
+	prm_clear_context_loss_flags_old(oh->clkdm->pwrdm.ptr->prcm_partition,
+					 oh->clkdm->pwrdm.ptr->prcm_offs,
+					 oh->prcm.omap4.context_offs);
+}
+
+/**
+ * _omap4_get_context_lost - get context loss counter for a hwmod
+ * @oh: hwmod to get context loss counter for
+ *
+ * Returns the in-memory context loss counter for a hwmod.
+ */
+static int _omap4_get_context_lost(struct omap_hwmod *oh)
+{
+	return oh->prcm.omap4.context_lost_counter;
+}
+
 /**
  * _enable - enable an omap_hwmod
  * @oh: struct omap_hwmod *
@@ -2065,6 +2103,9 @@ static int _enable(struct omap_hwmod *oh)
 	if (soc_ops.enable_module)
 		soc_ops.enable_module(oh);
 
+	if (soc_ops.update_context_lost)
+		soc_ops.update_context_lost(oh);
+
 	r = (soc_ops.wait_target_ready) ? soc_ops.wait_target_ready(oh) :
 		-EINVAL;
 	if (!r) {
@@ -3907,17 +3948,21 @@ int omap_hwmod_set_postsetup_state(struct omap_hwmod *oh, u8 state)
  * omap_hwmod_get_context_loss_count - get lost context count
  * @oh: struct omap_hwmod *
  *
- * Query the powerdomain of of @oh to get the context loss
- * count for this device.
+ * Returns the context loss count of associated @oh
+ * upon success, or zero if no context loss data is available.
  *
- * Returns the context loss count of the powerdomain assocated with @oh
- * upon success, or zero if no powerdomain exists for @oh.
+ * On OMAP4, this queries the per-hwmod context loss register,
+ * assuming one exists.  If not, or on OMAP2/3, this queries the
+ * enclosing powerdomain context loss count.
  */
 int omap_hwmod_get_context_loss_count(struct omap_hwmod *oh)
 {
 	struct powerdomain *pwrdm;
 	int ret = 0;
 
+	if (soc_ops.get_context_lost)
+		return soc_ops.get_context_lost(oh);
+
 	pwrdm = omap_hwmod_get_pwrdm(oh);
 	if (pwrdm)
 		ret = pwrdm_get_context_loss_count(pwrdm);
@@ -4032,6 +4077,8 @@ void __init omap_hwmod_init(void)
 		soc_ops.deassert_hardreset = _omap4_deassert_hardreset;
 		soc_ops.is_hardreset_asserted = _omap4_is_hardreset_asserted;
 		soc_ops.init_clkdm = _init_clkdm;
+		soc_ops.update_context_lost = _omap4_update_context_lost;
+		soc_ops.get_context_lost = _omap4_get_context_lost;
 	} else if (soc_is_am33xx()) {
 		soc_ops.enable_module = _am33xx_enable_module;
 		soc_ops.disable_module = _am33xx_disable_module;

commit c4a1ea2c6229b18c10c5a49a0f8f4ad2c3e2355d
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Apr 27 16:32:53 2012 +0530

    ARM: OMAP: hwmod: Cleanup !CONFIG_COMMON_CLK parts
    
    Clean all #ifdef's added as part of fixing the clkdm
    accesses from hwmod.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Mike Turquette <mturquette@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index c3d3e62a5ac2..68616b2b5b96 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -130,11 +130,7 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/io.h>
-#ifdef CONFIG_COMMON_CLK
 #include <linux/clk-provider.h>
-#else
-#include <linux/clk.h>
-#endif
 #include <linux/delay.h>
 #include <linux/err.h>
 #include <linux/list.h>
@@ -620,17 +616,13 @@ static int _disable_wakeup(struct omap_hwmod *oh, u32 *v)
 
 static struct clockdomain *_get_clkdm(struct omap_hwmod *oh)
 {
+	struct clk_hw_omap *clk;
+
 	if (oh->clkdm) {
 		return oh->clkdm;
 	} else if (oh->_clk) {
-#ifdef CONFIG_COMMON_CLK
-		struct clk_hw_omap *clk;
-
 		clk = to_clk_hw_omap(__clk_get_hw(oh->_clk));
 		return  clk->clkdm;
-#else
-		return oh->_clk->clkdm;
-#endif
 	}
 	return NULL;
 }
@@ -3588,9 +3580,7 @@ struct powerdomain *omap_hwmod_get_pwrdm(struct omap_hwmod *oh)
 	struct clk *c;
 	struct omap_hwmod_ocp_if *oi;
 	struct clockdomain *clkdm;
-#ifdef CONFIG_COMMON_CLK
 	struct clk_hw_omap *clk;
-#endif
 
 	if (!oh)
 		return NULL;
@@ -3607,12 +3597,8 @@ struct powerdomain *omap_hwmod_get_pwrdm(struct omap_hwmod *oh)
 		c = oi->_clk;
 	}
 
-#ifdef CONFIG_COMMON_CLK
 	clk = to_clk_hw_omap(__clk_get_hw(c));
 	clkdm = clk->clkdm;
-#else
-	clkdm = c->clkdm;
-#endif
 	if (!clkdm)
 		return NULL;
 

commit b797be1d4c079e78a3cb4e95f4a74274a4aef9f5
Author: Vaibhav Hiremath <hvaibhav@ti.com>
Date:   Mon Jul 9 18:24:30 2012 +0530

    ARM: OMAP2+: hwmod: Invoke init_clkdm before other init functions
    
    Without this kernel would crash, since clkdm inside omap_hwmod
    is accessed in some of the init functions like, _init_main_clk.
    
    So call init_clkdm before _init_main_clk().
    
    Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
    Signed-off-by: Mike Turquette <mturquette@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index f38e4cefa2a5..c3d3e62a5ac2 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1519,11 +1519,12 @@ static int _init_clocks(struct omap_hwmod *oh, void *data)
 
 	pr_debug("omap_hwmod: %s: looking up clocks\n", oh->name);
 
+	if (soc_ops.init_clkdm)
+		ret |= soc_ops.init_clkdm(oh);
+
 	ret |= _init_main_clk(oh);
 	ret |= _init_interface_clks(oh);
 	ret |= _init_opt_clks(oh);
-	if (soc_ops.init_clkdm)
-		ret |= soc_ops.init_clkdm(oh);
 
 	if (!ret)
 		oh->_state = _HWMOD_STATE_CLKS_INITED;

commit f5dd3bb53ca45f3b47c6889e5920c562f5a37359
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Sat Nov 10 16:58:41 2012 -0700

    ARM: OMAP: hwmod: Fix up hwmod based clkdm accesses
    
    hwmod uses deferencing the clk pointer to acccess the clkdm.
    With COMMON clk hwoever this will need to be deferenced through
    the clk_hw_omap pointer, so do the necessary changes.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Mike Turquette <mturquette@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 139adca3bda1..f38e4cefa2a5 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -130,7 +130,11 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/io.h>
+#ifdef CONFIG_COMMON_CLK
+#include <linux/clk-provider.h>
+#else
 #include <linux/clk.h>
+#endif
 #include <linux/delay.h>
 #include <linux/err.h>
 #include <linux/list.h>
@@ -614,6 +618,23 @@ static int _disable_wakeup(struct omap_hwmod *oh, u32 *v)
 	return 0;
 }
 
+static struct clockdomain *_get_clkdm(struct omap_hwmod *oh)
+{
+	if (oh->clkdm) {
+		return oh->clkdm;
+	} else if (oh->_clk) {
+#ifdef CONFIG_COMMON_CLK
+		struct clk_hw_omap *clk;
+
+		clk = to_clk_hw_omap(__clk_get_hw(oh->_clk));
+		return  clk->clkdm;
+#else
+		return oh->_clk->clkdm;
+#endif
+	}
+	return NULL;
+}
+
 /**
  * _add_initiator_dep: prevent @oh from smart-idling while @init_oh is active
  * @oh: struct omap_hwmod *
@@ -629,13 +650,18 @@ static int _disable_wakeup(struct omap_hwmod *oh, u32 *v)
  */
 static int _add_initiator_dep(struct omap_hwmod *oh, struct omap_hwmod *init_oh)
 {
-	if (!oh->_clk)
+	struct clockdomain *clkdm, *init_clkdm;
+
+	clkdm = _get_clkdm(oh);
+	init_clkdm = _get_clkdm(init_oh);
+
+	if (!clkdm || !init_clkdm)
 		return -EINVAL;
 
-	if (oh->_clk->clkdm && oh->_clk->clkdm->flags & CLKDM_NO_AUTODEPS)
+	if (clkdm && clkdm->flags & CLKDM_NO_AUTODEPS)
 		return 0;
 
-	return clkdm_add_sleepdep(oh->_clk->clkdm, init_oh->_clk->clkdm);
+	return clkdm_add_sleepdep(clkdm, init_clkdm);
 }
 
 /**
@@ -653,13 +679,18 @@ static int _add_initiator_dep(struct omap_hwmod *oh, struct omap_hwmod *init_oh)
  */
 static int _del_initiator_dep(struct omap_hwmod *oh, struct omap_hwmod *init_oh)
 {
-	if (!oh->_clk)
+	struct clockdomain *clkdm, *init_clkdm;
+
+	clkdm = _get_clkdm(oh);
+	init_clkdm = _get_clkdm(init_oh);
+
+	if (!clkdm || !init_clkdm)
 		return -EINVAL;
 
-	if (oh->_clk->clkdm && oh->_clk->clkdm->flags & CLKDM_NO_AUTODEPS)
+	if (clkdm && clkdm->flags & CLKDM_NO_AUTODEPS)
 		return 0;
 
-	return clkdm_del_sleepdep(oh->_clk->clkdm, init_oh->_clk->clkdm);
+	return clkdm_del_sleepdep(clkdm, init_clkdm);
 }
 
 /**
@@ -693,7 +724,7 @@ static int _init_main_clk(struct omap_hwmod *oh)
 	 */
 	clk_prepare(oh->_clk);
 
-	if (!oh->_clk->clkdm)
+	if (!_get_clkdm(oh))
 		pr_debug("omap_hwmod: %s: missing clockdomain for %s.\n",
 			   oh->name, oh->main_clk);
 
@@ -1276,6 +1307,7 @@ static void _enable_sysc(struct omap_hwmod *oh)
 	u8 idlemode, sf;
 	u32 v;
 	bool clkdm_act;
+	struct clockdomain *clkdm;
 
 	if (!oh->class->sysc)
 		return;
@@ -1283,11 +1315,9 @@ static void _enable_sysc(struct omap_hwmod *oh)
 	v = oh->_sysc_cache;
 	sf = oh->class->sysc->sysc_flags;
 
+	clkdm = _get_clkdm(oh);
 	if (sf & SYSC_HAS_SIDLEMODE) {
-		clkdm_act = ((oh->clkdm &&
-			      oh->clkdm->flags & CLKDM_ACTIVE_WITH_MPU) ||
-			     (oh->_clk && oh->_clk->clkdm &&
-			      oh->_clk->clkdm->flags & CLKDM_ACTIVE_WITH_MPU));
+		clkdm_act = (clkdm && clkdm->flags & CLKDM_ACTIVE_WITH_MPU);
 		if (clkdm_act && !(oh->class->sysc->idlemodes &
 				   (SIDLE_SMART | SIDLE_SMART_WKUP)))
 			idlemode = HWMOD_IDLEMODE_FORCE;
@@ -3556,10 +3586,17 @@ struct powerdomain *omap_hwmod_get_pwrdm(struct omap_hwmod *oh)
 {
 	struct clk *c;
 	struct omap_hwmod_ocp_if *oi;
+	struct clockdomain *clkdm;
+#ifdef CONFIG_COMMON_CLK
+	struct clk_hw_omap *clk;
+#endif
 
 	if (!oh)
 		return NULL;
 
+	if (oh->clkdm)
+		return oh->clkdm->pwrdm.ptr;
+
 	if (oh->_clk) {
 		c = oh->_clk;
 	} else {
@@ -3569,11 +3606,16 @@ struct powerdomain *omap_hwmod_get_pwrdm(struct omap_hwmod *oh)
 		c = oi->_clk;
 	}
 
-	if (!c->clkdm)
+#ifdef CONFIG_COMMON_CLK
+	clk = to_clk_hw_omap(__clk_get_hw(c));
+	clkdm = clk->clkdm;
+#else
+	clkdm = c->clkdm;
+#endif
+	if (!clkdm)
 		return NULL;
 
-	return c->clkdm->pwrdm.ptr;
-
+	return clkdm->pwrdm.ptr;
 }
 
 /**

commit b99db36cdf37decb1b5575c5f293d170cbbc53d6
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Oct 29 20:59:29 2012 -0600

    ARM: OMAP2+: PRCM: remove obsolete prcm.[ch]
    
    arch/arm/mach-omap2/prcm.c and arch/arm/plat-omap/include/plat/prcm.h
    are now completely unused and can be removed.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Vaibhav Hiremath <hvaibhav@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 9658e6b8ed84..139adca3bda1 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -141,7 +141,6 @@
 
 #include "clock.h"
 #include "omap_hwmod.h"
-#include <plat/prcm.h>
 
 #include "soc.h"
 #include "common.h"

commit 2577a4a6096017f3152339c562ada77e182c8976
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Oct 29 20:57:55 2012 -0600

    ARM: OMAP2+: hwmod: call to _omap4_disable_module() should use the SoC-specific call
    
    The hwmod code unconditionally calls _omap4_disable_module() on all
    SoCs when a module doesn't enable correctly.  This "worked" due to the
    weak function omap4_cminst_wait_module_idle() in
    arch/arm/mach-omap2/prcm.c, which was a no-op.  But now those weak
    functions are going away - they should not be used.  So this patch
    will now call the SoC-specific disable_module code, assuming it
    exists.
    
    Needs to be done before the weak function is removed, otherwise AM33xx
    will crash early in boot.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Vaibhav Hiremath <hvaibhav@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 54b68121734c..9658e6b8ed84 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2062,7 +2062,8 @@ static int _enable(struct omap_hwmod *oh)
 			_enable_sysc(oh);
 		}
 	} else {
-		_omap4_disable_module(oh);
+		if (soc_ops.disable_module)
+			soc_ops.disable_module(oh);
 		_disable_clocks(oh);
 		pr_debug("omap_hwmod: %s: _wait_target_ready: %d\n",
 			 oh->name, r);

commit b13159afb46f8a528fcf30bac26c07dbb40a784a
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Oct 29 20:57:44 2012 -0600

    ARM: OMAP2+: PRCM: consolidate PRCM-related timeout macros
    
    Consolidate all of the copies of MAX_MODULE_HARDRESET_WAIT and
    MAX_MODULE_SOFTRESET_WAIT into one place, arch/arm/mach-omap2/prm.h.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Vaibhav Hiremath <hvaibhav@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 37eeb45612f8..54b68121734c 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -151,6 +151,7 @@
 #include "cm3xxx.h"
 #include "cminst44xx.h"
 #include "cm33xx.h"
+#include "prm.h"
 #include "prm3xxx.h"
 #include "prm44xx.h"
 #include "prm33xx.h"
@@ -158,9 +159,6 @@
 #include "mux.h"
 #include "pm.h"
 
-/* Maximum microseconds to wait for OMAP module to softreset */
-#define MAX_MODULE_SOFTRESET_WAIT	10000
-
 /* Name of the OMAP hwmod for the MPU */
 #define MPU_INITIATOR_NAME		"mpu"
 

commit 5fb3d522efca4b3a369040d37d1380103411db74
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Oct 29 22:11:50 2012 -0600

    ARM: OMAP2+: hwmod: add flag to prevent hwmod code from touching IP block during init
    
    Add HWMOD_EXT_OPT_MAIN_CLK flag to indicate that this IP block is
    dependent on an off-chip functional clock that is not guaranteed to be
    present during initialization.  IP blocks marked with this flag are
    left in the INITIALIZED state during kernel init.
    
    This is a workaround for a hardware problem.  It should be possible to
    guarantee that at least one clock source will be present and active
    for any IP block's main functional clock.  This ensures that the hwmod
    code can enable and reset the IP block.  Resetting the IP block during
    kernel init prevents any bogus bootloader, ROM code, or previous OS
    configuration from affecting the kernel.  Hopefully a clock
    multiplexer can be added on future SoCs.
    
    N.B., at some point in the future, it should be possible to query the
    clock framework for this type of information.  Then this flag should
    no longer be needed.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 70267d2cf5e5..87cc6d058de2 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2384,6 +2384,9 @@ static int __init _setup_reset(struct omap_hwmod *oh)
 	if (oh->_state != _HWMOD_STATE_INITIALIZED)
 		return -EINVAL;
 
+	if (oh->flags & HWMOD_EXT_OPT_MAIN_CLK)
+		return -EPERM;
+
 	if (oh->rst_lines_cnt == 0) {
 		r = _enable(oh);
 		if (r) {

commit 613ad0e98c3596cd2524172fae2a795c3fc57e4a
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Oct 29 22:02:13 2012 -0600

    ARM: OMAP: hwmod: wait for sysreset complete after enabling hwmod
    
    When waking up from off-mode, some IP blocks are reset automatically by
    hardware. For this reason, software must wait until the reset has
    completed before attempting to access the IP block.
    
    This patch fixes for example the bug introduced by commit
    6c31b2150ff96755d24e0ab6d6fea08a7bf5c44c ("mmc: omap_hsmmc: remove access
    to SYSCONFIG register"), in which the MMC IP block is reset during
    off-mode entry, but the code expects the module to be already available
    during the execution of context restore.
    
    This version includes a fix from Kevin Hilman <khilman@ti.com> for
    GPIO problems on the 37xx EVM - thanks Kevin.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Venkatraman S <svenkatr@ti.com>
    Tested-by: Kevin Hilman <khilman@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    [paul@pwsan.com: moved softreset wait code into separate function; call
     from top of _enable_sysc() rather than the bottom; include fix from Kevin
     Hilman for GPIO sluggishness]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index b969ab1d258b..70267d2cf5e5 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -421,6 +421,38 @@ static int _set_softreset(struct omap_hwmod *oh, u32 *v)
 	return 0;
 }
 
+/**
+ * _wait_softreset_complete - wait for an OCP softreset to complete
+ * @oh: struct omap_hwmod * to wait on
+ *
+ * Wait until the IP block represented by @oh reports that its OCP
+ * softreset is complete.  This can be triggered by software (see
+ * _ocp_softreset()) or by hardware upon returning from off-mode (one
+ * example is HSMMC).  Waits for up to MAX_MODULE_SOFTRESET_WAIT
+ * microseconds.  Returns the number of microseconds waited.
+ */
+static int _wait_softreset_complete(struct omap_hwmod *oh)
+{
+	struct omap_hwmod_class_sysconfig *sysc;
+	u32 softrst_mask;
+	int c = 0;
+
+	sysc = oh->class->sysc;
+
+	if (sysc->sysc_flags & SYSS_HAS_RESET_STATUS)
+		omap_test_timeout((omap_hwmod_read(oh, sysc->syss_offs)
+				   & SYSS_RESETDONE_MASK),
+				  MAX_MODULE_SOFTRESET_WAIT, c);
+	else if (sysc->sysc_flags & SYSC_HAS_RESET_STATUS) {
+		softrst_mask = (0x1 << sysc->sysc_fields->srst_shift);
+		omap_test_timeout(!(omap_hwmod_read(oh, sysc->sysc_offs)
+				    & softrst_mask),
+				  MAX_MODULE_SOFTRESET_WAIT, c);
+	}
+
+	return c;
+}
+
 /**
  * _set_dmadisable: set OCP_SYSCONFIG.DMADISABLE bit in @v
  * @oh: struct omap_hwmod *
@@ -1282,6 +1314,18 @@ static void _enable_sysc(struct omap_hwmod *oh)
 	if (!oh->class->sysc)
 		return;
 
+	/*
+	 * Wait until reset has completed, this is needed as the IP
+	 * block is reset automatically by hardware in some cases
+	 * (off-mode for example), and the drivers require the
+	 * IP to be ready when they access it
+	 */
+	if (oh->flags & HWMOD_CONTROL_OPT_CLKS_IN_RESET)
+		_enable_optional_clocks(oh);
+	_wait_softreset_complete(oh);
+	if (oh->flags & HWMOD_CONTROL_OPT_CLKS_IN_RESET)
+		_disable_optional_clocks(oh);
+
 	v = oh->_sysc_cache;
 	sf = oh->class->sysc->sysc_flags;
 
@@ -1804,7 +1848,7 @@ static int _am33xx_disable_module(struct omap_hwmod *oh)
  */
 static int _ocp_softreset(struct omap_hwmod *oh)
 {
-	u32 v, softrst_mask;
+	u32 v;
 	int c = 0;
 	int ret = 0;
 
@@ -1834,19 +1878,7 @@ static int _ocp_softreset(struct omap_hwmod *oh)
 	if (oh->class->sysc->srst_udelay)
 		udelay(oh->class->sysc->srst_udelay);
 
-	if (oh->class->sysc->sysc_flags & SYSS_HAS_RESET_STATUS)
-		omap_test_timeout((omap_hwmod_read(oh,
-						    oh->class->sysc->syss_offs)
-				   & SYSS_RESETDONE_MASK),
-				  MAX_MODULE_SOFTRESET_WAIT, c);
-	else if (oh->class->sysc->sysc_flags & SYSC_HAS_RESET_STATUS) {
-		softrst_mask = (0x1 << oh->class->sysc->sysc_fields->srst_shift);
-		omap_test_timeout(!(omap_hwmod_read(oh,
-						     oh->class->sysc->sysc_offs)
-				   & softrst_mask),
-				  MAX_MODULE_SOFTRESET_WAIT, c);
-	}
-
+	c = _wait_softreset_complete(oh);
 	if (c == MAX_MODULE_SOFTRESET_WAIT)
 		pr_warning("omap_hwmod: %s: softreset failed (waited %d usec)\n",
 			   oh->name, MAX_MODULE_SOFTRESET_WAIT);

commit 8634155ef41d3a035f2ea0b6c5bed2806f2788bc
Merge: 6d02643d64b4 2bb2a5d30abb
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Oct 24 17:05:59 2012 -0700

    Merge tag 'omap-cleanup-a-for-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into omap-for-v3.8/cleanup-prcm
    
    The first set of OMAP PRM/CM-related cleanup patches for 3.8.
    Prepares for the future move of the PRM/CM code to drivers/.  Also
    includes some prcm.[ch] cleanup patches from the WDTIMER cleanup
    series that don't need external acks.
    
    Basic test logs for this branch on top of v3.7-rc2 are here:
    
    http://www.pwsan.com/omap/testlogs/prcm_cleanup_a_3.8/20121021123719/
    
    But due to the number of unrelated regressions present in v3.7-rc[12],
    it's not particularly usable as a testing base.  With reverts, fixes,
    and workarounds applied as documented in:
    
    http://www.pwsan.com/omap/testlogs/test_v3.7-rc2/20121020134755/README.txt
    
    the following test logs were obtained:
    
    http://www.pwsan.com/omap/testlogs/prcm_cleanup_a_3.8/20121020231757/
    
    which indicate that the series tests cleanly.
    
    Conflicts:
            arch/arm/mach-omap2/Makefile
            arch/arm/mach-omap2/clockdomain2xxx_3xxx.c
            arch/arm/mach-omap2/pm24xx.c

commit ff4ae5d9319b86f940e410e92659c50f9879ff46
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Oct 21 01:01:11 2012 -0600

    ARM: OMAP2+: CM/hwmod: split CM functions into OMAP2, OMAP3-specific files
    
    Move OMAP3xxx-specific CM functions & macros into cm3xxx.[ch] and
    OMAP2xxx-specific macros into cm2xxx.[ch].  Move basic CM register
    access functions into static inline functions in cm2xxx_3xxx.h,
    leaving only OMAP2/3 hardreset functions in cm2xxx_3xxx.c.
    
    As part of this, split the CM and hwmod code that waits for devices to
    become ready into SoC-specific functions.
    
    This is in preparation for the upcoming move of this code to drivers/.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Reviewed-by: Russ Dill <Russ.Dill@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 525c58d25730..504e0e0ecbbd 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -147,7 +147,8 @@
 #include "common.h"
 #include "clockdomain.h"
 #include "powerdomain.h"
-#include "cm2xxx_3xxx.h"
+#include "cm2xxx.h"
+#include "cm3xxx.h"
 #include "cminst44xx.h"
 #include "cm33xx.h"
 #include "prm3xxx.h"
@@ -2668,7 +2669,7 @@ static int __init _alloc_linkspace(struct omap_hwmod_ocp_if **ois)
 /* Static functions intended only for use in soc_ops field function pointers */
 
 /**
- * _omap2_wait_target_ready - wait for a module to leave slave idle
+ * _omap2xxx_wait_target_ready - wait for a module to leave slave idle
  * @oh: struct omap_hwmod *
  *
  * Wait for a module @oh to leave slave idle.  Returns 0 if the module
@@ -2676,7 +2677,7 @@ static int __init _alloc_linkspace(struct omap_hwmod_ocp_if **ois)
  * slave idle; otherwise, pass along the return value of the
  * appropriate *_cm*_wait_module_ready() function.
  */
-static int _omap2_wait_target_ready(struct omap_hwmod *oh)
+static int _omap2xxx_wait_target_ready(struct omap_hwmod *oh)
 {
 	if (!oh)
 		return -EINVAL;
@@ -2689,9 +2690,36 @@ static int _omap2_wait_target_ready(struct omap_hwmod *oh)
 
 	/* XXX check module SIDLEMODE, hardreset status, enabled clocks */
 
-	return omap2_cm_wait_module_ready(oh->prcm.omap2.module_offs,
-					  oh->prcm.omap2.idlest_reg_id,
-					  oh->prcm.omap2.idlest_idle_bit);
+	return omap2xxx_cm_wait_module_ready(oh->prcm.omap2.module_offs,
+					     oh->prcm.omap2.idlest_reg_id,
+					     oh->prcm.omap2.idlest_idle_bit);
+}
+
+/**
+ * _omap3xxx_wait_target_ready - wait for a module to leave slave idle
+ * @oh: struct omap_hwmod *
+ *
+ * Wait for a module @oh to leave slave idle.  Returns 0 if the module
+ * does not have an IDLEST bit or if the module successfully leaves
+ * slave idle; otherwise, pass along the return value of the
+ * appropriate *_cm*_wait_module_ready() function.
+ */
+static int _omap3xxx_wait_target_ready(struct omap_hwmod *oh)
+{
+	if (!oh)
+		return -EINVAL;
+
+	if (oh->flags & HWMOD_NO_IDLEST)
+		return 0;
+
+	if (!_find_mpu_rt_port(oh))
+		return 0;
+
+	/* XXX check module SIDLEMODE, hardreset status, enabled clocks */
+
+	return omap3xxx_cm_wait_module_ready(oh->prcm.omap2.module_offs,
+					     oh->prcm.omap2.idlest_reg_id,
+					     oh->prcm.omap2.idlest_idle_bit);
 }
 
 /**
@@ -3959,8 +3987,13 @@ int omap_hwmod_pad_route_irq(struct omap_hwmod *oh, int pad_idx, int irq_idx)
  */
 void __init omap_hwmod_init(void)
 {
-	if (cpu_is_omap24xx() || cpu_is_omap34xx()) {
-		soc_ops.wait_target_ready = _omap2_wait_target_ready;
+	if (cpu_is_omap24xx()) {
+		soc_ops.wait_target_ready = _omap2xxx_wait_target_ready;
+		soc_ops.assert_hardreset = _omap2_assert_hardreset;
+		soc_ops.deassert_hardreset = _omap2_deassert_hardreset;
+		soc_ops.is_hardreset_asserted = _omap2_is_hardreset_asserted;
+	} else if (cpu_is_omap34xx()) {
+		soc_ops.wait_target_ready = _omap3xxx_wait_target_ready;
 		soc_ops.assert_hardreset = _omap2_assert_hardreset;
 		soc_ops.deassert_hardreset = _omap2_deassert_hardreset;
 		soc_ops.is_hardreset_asserted = _omap2_is_hardreset_asserted;

commit 139563ad27e7baad7935b8113940f0d804cf513b
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Oct 21 01:01:10 2012 -0600

    ARM: OMAP2+: PRM: split PRM functions into OMAP2, OMAP3-specific files
    
    Move OMAP3xxx-specific PRM functions & macros into prm3xxx.[ch] and
    OMAP2xxx-specific macros into prm2xxx.h.  (prm2xxx.c will be created
    by a subsequent patch when it's needed.)  Move basic PRM register
    access functions into static inline functions in prm2xxx_3xxx.h, leaving
    only OMAP2/3 hardreset functions in prm2xxx_3xxx.c.
    
    Also clarify the initcall function naming to reinforce that this code
    is specifically for the PRM IP block.
    
    This is in preparation for the upcoming powerdomain series and the
    upcoming move of this code to drivers/.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Reviewed-by: Russ Dill <Russ.Dill@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index b969ab1d258b..525c58d25730 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -150,7 +150,7 @@
 #include "cm2xxx_3xxx.h"
 #include "cminst44xx.h"
 #include "cm33xx.h"
-#include "prm2xxx_3xxx.h"
+#include "prm3xxx.h"
 #include "prm44xx.h"
 #include "prm33xx.h"
 #include "prminst44xx.h"

commit a135eaae524acba1509a3b19c97fae556e4da7cd
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Sep 27 10:33:34 2012 -0600

    ARM: OMAP: remove plat/clock.h
    
    Remove arch/arm/plat-omap/include/plat/clock.h by merging it into
    arch/arm/mach-omap1/clock.h and arch/arm/mach-omap2/clock.h.
    The goal here is to facilitate ARM single image kernels by removing
    includes via the "plat/" symlink.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    [tony@atomide.com: fixed to remove duplicate clock.h includes]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 3dc482a1a75f..87eee3b62a3c 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -139,7 +139,7 @@
 #include <linux/slab.h>
 #include <linux/bootmem.h>
 
-#include <plat/clock.h>
+#include "clock.h"
 #include "omap_hwmod.h"
 #include <plat/prcm.h>
 

commit 2a296c8f89bc6aaf91b255c7d631fcbbfaf840ec
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 2 17:41:35 2012 -0700

    ARM: OMAP: Make plat/omap_hwmod.h local to mach-omap2
    
    Let's make omap_hwmod local to mach-omap2 for
    ARM common zImage support.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index b969ab1d258b..3dc482a1a75f 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -140,7 +140,7 @@
 #include <linux/bootmem.h>
 
 #include <plat/clock.h>
-#include <plat/omap_hwmod.h>
+#include "omap_hwmod.h"
 #include <plat/prcm.h>
 
 #include "soc.h"

commit e9332b6eed82973a8f75f1f3d57babaa331d703c
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Oct 8 23:08:15 2012 -0600

    ARM: OMAP4/AM335x: hwmod: fix disable_module regression in hardreset handling
    
    Commit eb05f691290e99ee0bd1672317d6add789523c1e ("ARM: OMAP: hwmod:
    partially un-reset hwmods might not be properly enabled") added code
    to skip the IP block disable sequence if all of the block's hardreset
    lines weren't asserted.  But this did not handle the case when no
    hardreset lines were associated with a module, which is the general
    case.  In that situation, the IP block disable would be skipped.  This
    is likely to cause PM regressions.
    
    So, modify _omap4_disable_module() and _am33xx_disable_module() to
    only bail out early if there are any hardreset lines asserted.  And
    move the AM33xx test above the actual module disable code to ensure
    that the behavior is consistent.
    
    Reported-by: Archit Taneja <a0393947@ti.com>
    Tested-by: Archit Taneja <a0393947@ti.com> # DSS
    Cc: Omar Ramirez Luna <omar.luna@linaro.org>
    Cc: Vaibhav Hiremath <hvaibhav@ti.com>
    Acked-by: Vaibhav Hiremath <hvaibhav@ti.com>
    Tested-by: Vaibhav Hiremath <hvaibhav@ti.com> # AM335x
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 299ca2821ad1..b969ab1d258b 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1697,6 +1697,29 @@ static bool _are_all_hardreset_lines_asserted(struct omap_hwmod *oh)
 	return false;
 }
 
+/**
+ * _are_any_hardreset_lines_asserted - return true if any part of @oh is
+ * hard-reset
+ * @oh: struct omap_hwmod *
+ *
+ * If any hardreset lines associated with @oh are asserted, then
+ * return true.  Otherwise, if no hardreset lines associated with @oh
+ * are asserted, or if @oh has no hardreset lines, then return false.
+ * This function is used to avoid executing some parts of the IP block
+ * enable/disable sequence if any hardreset line is set.
+ */
+static bool _are_any_hardreset_lines_asserted(struct omap_hwmod *oh)
+{
+	int rst_cnt = 0;
+	int i;
+
+	for (i = 0; i < oh->rst_lines_cnt && rst_cnt == 0; i++)
+		if (_read_hardreset(oh, oh->rst_lines[i].name) > 0)
+			rst_cnt++;
+
+	return (rst_cnt) ? true : false;
+}
+
 /**
  * _omap4_disable_module - enable CLKCTRL modulemode on OMAP4
  * @oh: struct omap_hwmod *
@@ -1715,7 +1738,7 @@ static int _omap4_disable_module(struct omap_hwmod *oh)
 	 * Since integration code might still be doing something, only
 	 * disable if all lines are under hardreset.
 	 */
-	if (!_are_all_hardreset_lines_asserted(oh))
+	if (_are_any_hardreset_lines_asserted(oh))
 		return 0;
 
 	pr_debug("omap_hwmod: %s: %s\n", oh->name, __func__);
@@ -1749,12 +1772,12 @@ static int _am33xx_disable_module(struct omap_hwmod *oh)
 
 	pr_debug("omap_hwmod: %s: %s\n", oh->name, __func__);
 
+	if (_are_any_hardreset_lines_asserted(oh))
+		return 0;
+
 	am33xx_cm_module_disable(oh->clkdm->cm_inst, oh->clkdm->clkdm_offs,
 				 oh->prcm.omap4.clkctrl_offs);
 
-	if (_are_all_hardreset_lines_asserted(oh))
-		return 0;
-
 	v = _am33xx_wait_target_disable(oh);
 	if (v)
 		pr_warn("omap_hwmod: %s: _wait_target_disable failed\n",

commit 54d69df5849ec2e660aa12ac75562618c10fb499
Merge: ad932bb6b549 46f2007c1efa
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Oct 4 20:17:25 2012 -0700

    Merge branch 'late/kirkwood' into late/soc
    
    Merge in the late Kirkwood branch with the OMAP late branch for upstream
    submission.
    
    Final contents described in shared tag.
    
    Fixup remove/change conflicts in arch/arm/mach-omap2/devices.c and
    drivers/spi/spi-omap2-mcspi.c.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit b71c72178e24118214f21567a15adcad61b4238a
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Sep 23 17:28:28 2012 -0600

    ARM: OMAP2+: clockdomain/hwmod: add workaround for EMU clockdomain idle problems
    
    The idle status of the IP blocks and clocks inside the EMU clockdomain
    isn't taken into account by the PRCM hardware when deciding whether
    the clockdomain is idle.  Add a workaround flag in the clockdomain
    code, CLKDM_MISSING_IDLE_REPORTING, to deal with this problem, and add
    the code necessary to support it.
    
    If CLKDM_MISSING_IDLE_REPORTING is set on a clockdomain, the
    clockdomain will be forced active whenever an IP block inside that
    clockdomain is in use, even if the clockdomain supports
    hardware-supervised idle.  When the kernel indicates that the last
    active IP block inside the clockdomain is no longer used, the
    clockdomain will be forced idle, or, if that mode is not supported in
    the hardware, it will be placed into hardware-supervised idle.
    
    This patch is an equal collaboration with Jon Hunter
    <jon-hunter@ti.com>.  Ming Lei <ming.lei@canonical.com>, Will Deacon
    <will.deacon@arm.com>, Madhav Vij <mvij@ti.com>, Kevin Hilman
    <khilman@ti.com>, Benot Cousson <b-cousson@ti.com>, and Santosh
    Shilimkar <santosh.shilimkar@ti.com> all made essential contributions
    to the understanding of EMU clockdomain power management on OMAP.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Jon Hunter <jon-hunter@ti.com>
    Cc: Ming Lei <ming.lei@canonical.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Madhav Vij <mvij@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: Benot Cousson <b-cousson@ti.com>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Jon Hunter <jon-hunter@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 21299879d2d5..6af64bbd9e1d 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2007,7 +2007,8 @@ static int _enable(struct omap_hwmod *oh)
 		 * completely the module. The clockdomain can be set
 		 * in HW_AUTO only when the module become ready.
 		 */
-		hwsup = clkdm_in_hwsup(oh->clkdm);
+		hwsup = clkdm_in_hwsup(oh->clkdm) &&
+			!clkdm_missing_idle_reporting(oh->clkdm);
 		r = clkdm_hwmod_enable(oh->clkdm, oh);
 		if (r) {
 			WARN(1, "omap_hwmod: %s: could not enable clockdomain %s: %d\n",

commit e8e96dff71efcf880d9fa446651b3c3db08957c4
Author: Omar Ramirez Luna <omar.luna@linaro.org>
Date:   Sun Sep 23 17:28:21 2012 -0600

    ARM: OMAP: hwmod: revise deassert sequence
    
    For a reset sequence to complete cleanly, a module needs its
    associated clocks to be enabled, otherwise the timeout check
    in prcm code can print a false failure (failed to hardreset)
    that occurs because the clocks aren't powered ON and the status
    bit checked can't transition without them.
    
    Signed-off-by: Omar Ramirez Luna <omar.luna@linaro.org>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 8d933528b708..21299879d2d5 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1585,6 +1585,7 @@ static int _deassert_hardreset(struct omap_hwmod *oh, const char *name)
 {
 	struct omap_hwmod_rst_info ohri;
 	int ret = -EINVAL;
+	int hwsup = 0;
 
 	if (!oh)
 		return -EINVAL;
@@ -1596,10 +1597,46 @@ static int _deassert_hardreset(struct omap_hwmod *oh, const char *name)
 	if (IS_ERR_VALUE(ret))
 		return ret;
 
+	if (oh->clkdm) {
+		/*
+		 * A clockdomain must be in SW_SUP otherwise reset
+		 * might not be completed. The clockdomain can be set
+		 * in HW_AUTO only when the module become ready.
+		 */
+		hwsup = clkdm_in_hwsup(oh->clkdm);
+		ret = clkdm_hwmod_enable(oh->clkdm, oh);
+		if (ret) {
+			WARN(1, "omap_hwmod: %s: could not enable clockdomain %s: %d\n",
+			     oh->name, oh->clkdm->name, ret);
+			return ret;
+		}
+	}
+
+	_enable_clocks(oh);
+	if (soc_ops.enable_module)
+		soc_ops.enable_module(oh);
+
 	ret = soc_ops.deassert_hardreset(oh, &ohri);
+
+	if (soc_ops.disable_module)
+		soc_ops.disable_module(oh);
+	_disable_clocks(oh);
+
 	if (ret == -EBUSY)
 		pr_warning("omap_hwmod: %s: failed to hardreset\n", oh->name);
 
+	if (!ret) {
+		/*
+		 * Set the clockdomain to HW_AUTO, assuming that the
+		 * previous state was HW_AUTO.
+		 */
+		if (oh->clkdm && hwsup)
+			clkdm_allow_idle(oh->clkdm);
+	} else {
+		if (oh->clkdm)
+			clkdm_hwmod_disable(oh->clkdm, oh);
+	}
+
 	return ret;
 }
 

commit eb05f691290e99ee0bd1672317d6add789523c1e
Author: Omar Ramirez Luna <omar.luna@linaro.org>
Date:   Sun Sep 23 17:28:20 2012 -0600

    ARM: OMAP: hwmod: partially un-reset hwmods might not be properly enabled
    
    Some IP blocks might not be using/controlling more than one
    reset line, this check loosens the restriction to fully use
    hwmod framework for those drivers.
    
    E.g.: ipu has reset lines: mmu_cache, cpu0 and cpu1.
    - As of now cpu1 is not used and hence (with previous check) the
      IP block isn't fully enabled by hwmod code.
    - Usually ipu and dsp processors configure their mmu module first
      and then enable the processors, this involves:
        * Deasserting mmu reset line, and enabling the module.
        * Deasserting cpu0 reset line, and enabling the processor.
      The ones portrayed in this example are controlled through
      rproc_fw_boot in drivers/remoteproc/remoteproc_core.c
    
    While at it, prevent _omap4_module_disable if all the hardreset
    lines on an IP block are not under reset.
    
    This will allow the driver to:
      a. Deassert the reset line.
      b. Enable the hwmod through runtime PM default callbacks.
      c. Do its usecase.
      d. Disable hwmod through runtime PM.
      e. Assert the reset line.
    
    Signed-off-by: Omar Ramirez Luna <omar.luna@linaro.org>
    [paul@pwsan.com: updated to apply]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 4f6b50f220c5..8d933528b708 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1634,25 +1634,28 @@ static int _read_hardreset(struct omap_hwmod *oh, const char *name)
 }
 
 /**
- * _are_any_hardreset_lines_asserted - return true if part of @oh is hard-reset
+ * _are_all_hardreset_lines_asserted - return true if the @oh is hard-reset
  * @oh: struct omap_hwmod *
  *
- * If any hardreset line associated with @oh is asserted, then return true.
- * Otherwise, if @oh has no hardreset lines associated with it, or if
- * no hardreset lines associated with @oh are asserted, then return false.
+ * If all hardreset lines associated with @oh are asserted, then return true.
+ * Otherwise, if part of @oh is out hardreset or if no hardreset lines
+ * associated with @oh are asserted, then return false.
  * This function is used to avoid executing some parts of the IP block
- * enable/disable sequence if a hardreset line is set.
+ * enable/disable sequence if its hardreset line is set.
  */
-static bool _are_any_hardreset_lines_asserted(struct omap_hwmod *oh)
+static bool _are_all_hardreset_lines_asserted(struct omap_hwmod *oh)
 {
-	int i;
+	int i, rst_cnt = 0;
 
 	if (oh->rst_lines_cnt == 0)
 		return false;
 
 	for (i = 0; i < oh->rst_lines_cnt; i++)
 		if (_read_hardreset(oh, oh->rst_lines[i].name) > 0)
-			return true;
+			rst_cnt++;
+
+	if (oh->rst_lines_cnt == rst_cnt)
+		return true;
 
 	return false;
 }
@@ -1671,6 +1674,13 @@ static int _omap4_disable_module(struct omap_hwmod *oh)
 	if (!oh->clkdm || !oh->prcm.omap4.modulemode)
 		return -EINVAL;
 
+	/*
+	 * Since integration code might still be doing something, only
+	 * disable if all lines are under hardreset.
+	 */
+	if (!_are_all_hardreset_lines_asserted(oh))
+		return 0;
+
 	pr_debug("omap_hwmod: %s: %s\n", oh->name, __func__);
 
 	omap4_cminst_module_disable(oh->clkdm->prcm_partition,
@@ -1678,9 +1688,6 @@ static int _omap4_disable_module(struct omap_hwmod *oh)
 				    oh->clkdm->clkdm_offs,
 				    oh->prcm.omap4.clkctrl_offs);
 
-	if (_are_any_hardreset_lines_asserted(oh))
-		return 0;
-
 	v = _omap4_wait_target_disable(oh);
 	if (v)
 		pr_warn("omap_hwmod: %s: _wait_target_disable failed\n",
@@ -1708,7 +1715,7 @@ static int _am33xx_disable_module(struct omap_hwmod *oh)
 	am33xx_cm_module_disable(oh->clkdm->cm_inst, oh->clkdm->clkdm_offs,
 				 oh->prcm.omap4.clkctrl_offs);
 
-	if (_are_any_hardreset_lines_asserted(oh))
+	if (_are_all_hardreset_lines_asserted(oh))
 		return 0;
 
 	v = _am33xx_wait_target_disable(oh);
@@ -1936,7 +1943,7 @@ static int _enable(struct omap_hwmod *oh)
 	}
 
 	/*
-	 * If an IP block contains HW reset lines and any of them are
+	 * If an IP block contains HW reset lines and all of them are
 	 * asserted, we let integration code associated with that
 	 * block handle the enable.  We've received very little
 	 * information on what those driver authors need, and until
@@ -1944,7 +1951,7 @@ static int _enable(struct omap_hwmod *oh)
 	 * posted to the public lists, this is probably the best we
 	 * can do.
 	 */
-	if (_are_any_hardreset_lines_asserted(oh))
+	if (_are_all_hardreset_lines_asserted(oh))
 		return 0;
 
 	/* Mux pins for device runtime if populated */
@@ -2025,7 +2032,7 @@ static int _idle(struct omap_hwmod *oh)
 		return -EINVAL;
 	}
 
-	if (_are_any_hardreset_lines_asserted(oh))
+	if (_are_all_hardreset_lines_asserted(oh))
 		return 0;
 
 	if (oh->class->sysc)
@@ -2113,7 +2120,7 @@ static int _shutdown(struct omap_hwmod *oh)
 		return -EINVAL;
 	}
 
-	if (_are_any_hardreset_lines_asserted(oh))
+	if (_are_all_hardreset_lines_asserted(oh))
 		return 0;
 
 	pr_debug("omap_hwmod: %s: disabling\n", oh->name);

commit 3bb05dbf69018177c06ee09011e2d8bd183dd2ba
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Sep 23 17:28:18 2012 -0600

    ARM: OMAP2+: hwmod code: convert missing clockdomain warnings to debug messages
    
    The decision was made a few months ago to allow struct omap_hwmod
    records and struct clk records to omit clockdomain information if the
    clockdomain is not software-controllable.  See for example commit
    868c157df9721675c19729eed2c96bac6c3f1d01 ("ARM: OMAP2+: hwmod: remove
    prm_clkdm, cm_clkdm; allow hwmods to have no clockdomain").
    
    So convert an existing pr_warning() to a pr_debug() (regarding missing
    clockdomains in clocks), and add a pr_debug() for missing hwmod
    clockdomains.  It's still useful to enable these messages for
    debugging, since missing clockdomains can cause hard-to-debug problems
    with power management; see for example commit
    6c4a057bffe9823221eab547e11fac181dc18a2b ("ARM: OMAP4: clock data:
    Force a DPLL clkdm/pwrdm ON before a relock").
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 18a2df38265d..4f6b50f220c5 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -696,7 +696,7 @@ static int _init_main_clk(struct omap_hwmod *oh)
 	clk_prepare(oh->_clk);
 
 	if (!oh->_clk->clkdm)
-		pr_warning("omap_hwmod: %s: missing clockdomain for %s.\n",
+		pr_debug("omap_hwmod: %s: missing clockdomain for %s.\n",
 			   oh->name, oh->main_clk);
 
 	return ret;
@@ -1454,8 +1454,10 @@ static struct omap_hwmod *_lookup(const char *name)
  */
 static int _init_clkdm(struct omap_hwmod *oh)
 {
-	if (!oh->clkdm_name)
+	if (!oh->clkdm_name) {
+		pr_debug("omap_hwmod: %s: missing clockdomain\n", oh->name);
 		return 0;
+	}
 
 	oh->clkdm = clkdm_lookup(oh->clkdm_name);
 	if (!oh->clkdm) {

commit 2b026d137b13047d01d426a61e2d50b5dcb58fd0
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Sep 23 17:28:18 2012 -0600

    ARM: OMAP4+: hwmod code: remove clkdm requirement in _omap4_wait_target_*()
    
    We're no longer requiring struct omap_hwmod records to contain a
    clockdomain.  So we shouldn't return -EINVAL any more from
    _omap4_wait_target_disable() or _omap4_wait_target_ready() if there's
    no clockdomain defined, since that just gets passed back to the
    caller.  This can result in pointless warnings under the relaxed data
    format.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 5c8c5e0449b6..18a2df38265d 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -927,10 +927,10 @@ static void _am33xx_enable_module(struct omap_hwmod *oh)
  */
 static int _omap4_wait_target_disable(struct omap_hwmod *oh)
 {
-	if (!oh || !oh->clkdm)
+	if (!oh)
 		return -EINVAL;
 
-	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
+	if (oh->_int_flags & _HWMOD_NO_MPU_PORT || !oh->clkdm)
 		return 0;
 
 	if (oh->flags & HWMOD_NO_IDLEST)
@@ -2635,10 +2635,10 @@ static int _omap2_wait_target_ready(struct omap_hwmod *oh)
  */
 static int _omap4_wait_target_ready(struct omap_hwmod *oh)
 {
-	if (!oh || !oh->clkdm)
+	if (!oh)
 		return -EINVAL;
 
-	if (oh->flags & HWMOD_NO_IDLEST)
+	if (oh->flags & HWMOD_NO_IDLEST || !oh->clkdm)
 		return 0;
 
 	if (!_find_mpu_rt_port(oh))

commit 4fb85d35bcec842e0f20437aea277157973aa45f
Merge: 1e2ee2a60df5 a86c0b986794
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Sep 23 17:27:43 2012 -0600

    Merge branch 'clock_devel_3.7' into hwmod_prcm_clock_a_3.7
    
    Conflicts:
            arch/arm/mach-omap2/clkt34xx_dpll3m2.c
            arch/arm/mach-omap2/clkt_clksel.c
            arch/arm/mach-omap2/clock.c

commit 1e2ee2a60df5c3ab74dd1c9155fb01b5bc6f807d
Merge: 291852e8791a 11964f53eb4d
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Sep 23 17:16:04 2012 -0600

    Merge tag 'omap-devel-am33xx-for-v3.7' into test_v3.6-rc6_ocb3.7_cff3.7_odaf3.7
    
    From Paul Walmsley <paul@pwsan.com>:
    
    AM33xx hwmod data and miscellaneous clock and hwmod fixes.  AM33xx
    should now boot on mainline after this is applied, according to
    Vaibhav.

commit 291852e8791a596195edc3ced96481bfd105f35b
Merge: 2910f14584ed de6ca33a96a6
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Sep 23 17:15:44 2012 -0600

    Merge tag 'cleanup-fixes-for-v3.7' into test_v3.6-rc6_ocb3.7_cff3.7_odaf3.7
    
    These fixes are needed to fix non-omap build breakage for
    twl-core driver and to fix omap1_defconfig compile when
    led driver changes and omap sparse IRQ changes are merged
    together. Also fix warnings for omaps not using pinctrl
    framework yet.

commit 2910f14584eddf2bc0db4baec3c6950ef357b52c
Merge: 5698bd757d55 7852ec0536ca
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Sep 23 17:15:11 2012 -0600

    Merge tag 'omap-cleanup-b-for-3.7' into test_v3.6-rc6_ocb3.7_cff3.7_odaf3.7
    
    smatch and string-wrapping cleanups for the OMAP subarch code.
    
    These changes fix some of the more meaningful warnings that smatch
    returns for the OMAP subarch code, and unwraps strings that are
    wrapped at the 80-column boundary, to conform with the current
    practice.
    
    Basic build, boot, and PM logs are available here:
    
    http://www.pwsan.com/omap/testlogs/warnings_a_cleanup_3.7/20120912025927/

commit 5dcc3b975e972989574c009457f0e333c342910d
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Sat Sep 22 02:24:17 2012 -0600

    ARM: OMAP2+: clock: Remove all direct dereferencing of struct clk
    
    While we move to Common Clk Framework (CCF), direct deferencing of struct
    clk wouldn't be possible anymore. Hence get rid of all such instances
    in the current clock code and use macros/helpers similar to the ones that
    are provided by CCF.
    
    While here also concatenate some strings split across multiple lines
    which seem to be needed anyway.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    [paul@pwsan.com: simplified some compound expressions; reformatted some
     messages]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Mike Turquette <mturquette@linaro.org>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 428dca631e12..acff6b7b79a2 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -697,7 +697,7 @@ static int _init_main_clk(struct omap_hwmod *oh)
 
 	if (!oh->_clk->clkdm)
 		pr_warning("omap_hwmod: %s: missing clockdomain for %s.\n",
-			   oh->main_clk, oh->_clk->name);
+			   oh->name, oh->main_clk);
 
 	return ret;
 }
@@ -854,7 +854,7 @@ static void _enable_optional_clocks(struct omap_hwmod *oh)
 	for (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++)
 		if (oc->_clk) {
 			pr_debug("omap_hwmod: enable %s:%s\n", oc->role,
-				 oc->_clk->name);
+				 __clk_get_name(oc->_clk));
 			clk_enable(oc->_clk);
 		}
 }
@@ -869,7 +869,7 @@ static void _disable_optional_clocks(struct omap_hwmod *oh)
 	for (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++)
 		if (oc->_clk) {
 			pr_debug("omap_hwmod: disable %s:%s\n", oc->role,
-				 oc->_clk->name);
+				 __clk_get_name(oc->_clk));
 			clk_disable(oc->_clk);
 		}
 }

commit 6ea74cb9853e923f8945586cd9ccdd42e6f00ba9
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Sat Sep 22 02:24:16 2012 -0600

    ARM: OMAP2+: hwmod: get rid of all omap_clk_get_by_name usage
    
    Moving to Common clk framework for OMAP would mean we no longer use
    internal lookup mechanism like omap_clk_get_by_name().
    get rid of all its usage mostly from hwmod and omap_device
    code.
    
    Moving to clk_get() also means the respective platforms
    need the clkdev tables updated with an entry for all clocks
    used by hwmod to have clock name same as the alias.
    
    Based on original changes from Mike Turquette.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Cc: Russell King - ARM Linux <linux@arm.linux.org.uk>
    [paul@pwsan.com: removed IS_ERR_OR_NULL() conversion (rmk comment);
     restricted omap_96m_alwon_fck_3630 to OMAP36xx; added missing AM35xx
     clock aliases for emac_fck, emac_ick, vpfe_ick, vpfe_fck; added
     aliases rng_ick and several emulation clocks]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 99fd3bb3c432..428dca631e12 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -679,8 +679,8 @@ static int _init_main_clk(struct omap_hwmod *oh)
 	if (!oh->main_clk)
 		return 0;
 
-	oh->_clk = omap_clk_get_by_name(oh->main_clk);
-	if (!oh->_clk) {
+	oh->_clk = clk_get(NULL, oh->main_clk);
+	if (IS_ERR(oh->_clk)) {
 		pr_warning("omap_hwmod: %s: cannot clk_get main_clk %s\n",
 			   oh->name, oh->main_clk);
 		return -EINVAL;
@@ -724,8 +724,8 @@ static int _init_interface_clks(struct omap_hwmod *oh)
 		if (!os->clk)
 			continue;
 
-		c = omap_clk_get_by_name(os->clk);
-		if (!c) {
+		c = clk_get(NULL, os->clk);
+		if (IS_ERR(c)) {
 			pr_warning("omap_hwmod: %s: cannot clk_get interface_clk %s\n",
 				   oh->name, os->clk);
 			ret = -EINVAL;
@@ -760,8 +760,8 @@ static int _init_opt_clks(struct omap_hwmod *oh)
 	int ret = 0;
 
 	for (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++) {
-		c = omap_clk_get_by_name(oc->clk);
-		if (!c) {
+		c = clk_get(NULL, oc->clk);
+		if (IS_ERR(c)) {
 			pr_warning("omap_hwmod: %s: cannot clk_get opt_clk %s\n",
 				   oh->name, oc->clk);
 			ret = -EINVAL;

commit 4d7cb45ee823541632a3d50f57031ce9fd60e13f
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Sat Sep 22 02:24:16 2012 -0600

    ARM: omap: clk: add clk_prepare and clk_unprepare
    
    As part of Common Clk Framework (CCF) the clk_enable() operation
    was split into a clk_prepare() which could sleep, and a clk_enable()
    which should never sleep. Similarly the clk_disable() was
    split into clk_disable() and clk_unprepare(). This was
    needed to handle complex cases where in a clk gate/ungate
    would require a slow and a fast part to be implemented.
    None of the clocks below seem to be in the 'complex' clocks
    category and are just simple clocks which are enabled/disabled
    through simple register writes.
    Most of the instances also seem to be called in non-atomic
    context which means its safe to move all of those from
    using a clk_enable() to clk_prepare_enable() and clk_disable() to
    clk_disable_unprepare().
    
    For some others, mainly the ones handled through the hwmod framework
    there is a possibility that they get called in either an atomic
    or a non-atomic context.
    
    The way these get handled below work only as long as clk_prepare
    is implemented as a no-op (which is the case today) since this gets
    called very early at boot while most subsystems are unavailable.
    Hence these are marked with a *HACK* comment, which says we need
    to re-visit these once we start doing something meaningful with
    clk_prepare/clk_unprepare like doing voltage scaling or something
    that involves i2c.
    
    This is in preparation of OMAP moving to CCF.
    
    Based on initial changes from Mike Turquette.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 6504f0e8d96e..99fd3bb3c432 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -685,6 +685,15 @@ static int _init_main_clk(struct omap_hwmod *oh)
 			   oh->name, oh->main_clk);
 		return -EINVAL;
 	}
+	/*
+	 * HACK: This needs a re-visit once clk_prepare() is implemented
+	 * to do something meaningful. Today its just a no-op.
+	 * If clk_prepare() is used at some point to do things like
+	 * voltage scaling etc, then this would have to be moved to
+	 * some point where subsystems like i2c and pmic become
+	 * available.
+	 */
+	clk_prepare(oh->_clk);
 
 	if (!oh->_clk->clkdm)
 		pr_warning("omap_hwmod: %s: missing clockdomain for %s.\n",
@@ -722,6 +731,15 @@ static int _init_interface_clks(struct omap_hwmod *oh)
 			ret = -EINVAL;
 		}
 		os->_clk = c;
+		/*
+		 * HACK: This needs a re-visit once clk_prepare() is implemented
+		 * to do something meaningful. Today its just a no-op.
+		 * If clk_prepare() is used at some point to do things like
+		 * voltage scaling etc, then this would have to be moved to
+		 * some point where subsystems like i2c and pmic become
+		 * available.
+		 */
+		clk_prepare(os->_clk);
 	}
 
 	return ret;
@@ -749,6 +767,15 @@ static int _init_opt_clks(struct omap_hwmod *oh)
 			ret = -EINVAL;
 		}
 		oc->_clk = c;
+		/*
+		 * HACK: This needs a re-visit once clk_prepare() is implemented
+		 * to do something meaningful. Today its just a no-op.
+		 * If clk_prepare() is used at some point to do things like
+		 * voltage scaling etc, then this would have to be moved to
+		 * some point where subsystems like i2c and pmic become
+		 * available.
+		 */
+		clk_prepare(oc->_clk);
 	}
 
 	return ret;

commit 9fe0624e1b9faa43d1f6136c70409c4716fb73c9
Merge: 5dbd6535d5bc 11964f53eb4d
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Sep 22 10:00:35 2012 -0600

    Merge tag 'omap-devel-am33xx-for-v3.7' into test_v3.6-rc6_cff3.7_odaf3.7
    
    From Paul Walmsley <paul@pwsan.com>:
    
    AM33xx hwmod data and miscellaneous clock and hwmod fixes.  AM33xx
    should now boot on mainline after this is applied, according to
    Vaibhav.

commit 5dbd6535d5bcb9d1899dd27d209ca651431df66b
Merge: 5698bd757d55 de6ca33a96a6
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Sep 22 10:00:11 2012 -0600

    Merge tag 'cleanup-fixes-for-v3.7' into test_v3.6-rc6_cff3.7_odaf3.7
    
    These fixes are needed to fix non-omap build breakage for
    twl-core driver and to fix omap1_defconfig compile when
    led driver changes and omap sparse IRQ changes are merged
    together. Also fix warnings for omaps not using pinctrl
    framework yet.

commit b612a85792192b70e6497619521772c38ace758e
Merge: ea832c41dacb 3aec092eed5d
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Sep 20 21:27:41 2012 -0700

    Merge branch 'next/soc' into next/multiplatform
    
    * next/soc: (50 commits)
      ARM: OMAP: AM33xx hwmod: fixup SPI after platform_data move
      MAINTAINERS: add an entry for the BCM2835 ARM sub-architecture
      ARM: bcm2835: instantiate console UART
      ARM: bcm2835: add stub clock driver
      ARM: bcm2835: add system timer
      ARM: bcm2835: add interrupt controller driver
      ARM: add infra-structure for BCM2835 and Raspberry Pi
      ARM: tegra20: add CPU hotplug support
      ARM: tegra30: add CPU hotplug support
      ARM: tegra: clean up the common assembly macros into sleep.h
      ARM: tegra: replace the CPU CAR access code by tegra_cpu_car_ops
      ARM: tegra: introduce tegra_cpu_car_ops structures
      ARM: Tegra: Add smp_twd clock for Tegra20
      ARM: AM33XX: clock: Add dcan clock aliases for device-tree
      ARM: OMAP2+: dpll: Add missing soc_is_am33xx() check for common functions
      ARM: OMAP: omap_device: idle devices with no driver bound
      ARM: OMAP: omap_device: don't attempt late suspend if no driver bound
      ARM: OMAP: omap_device: keep track of driver bound status
      ARM: OMAP3+: hwmod: Add AM33XX HWMOD data
      ARM: OMAP2+: hwmod: Hook-up am33xx support in omap_hwmod framework
      ...
    
    Change/remove conflict in arch/arm/mach-ux500/clock.c resolved.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit ea832c41dacbc4a5f3888d9ef7c38213914aba2a
Merge: b74aae9a2074 84bae6c379e3
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Sep 20 21:16:43 2012 -0700

    Merge branch 'next/dt' into next/multiplatform
    
    * next/dt: (182 commits)
      ARM: tegra: Add Avionic Design Tamonten Evaluation Carrier support
      ARM: tegra: Add Avionic Design Medcom-Wide support
      ARM: tegra: Add Avionic Design Plutux support
      ARM: tegra: Add Avionic Design Tamonten support
      ARM: tegra: dts: Add pwm label
      ARM: dt: tegra: whistler: configure power off
      ARM: mxs: m28evk: Disable OCOTP OUI loading
      ARM: imx6q: use pll2_pfd2_396m as the enfc_sel's parent
      ARM: dts: imx6q-sabrelite: add usbotg pinctrl support
      ARM: dts: imx23-olinuxino: Add USB host support
      ARM: dts: imx6q-sabrelite: add usbmisc device
      ARM: dts: mx23: Add USB resources
      ARM: dts: mxs: Add ethernetX to macX aliases
      ARM: msm: Remove non-DT targets from 8960
      ARM: msm: Add DT support for 8960
      ARM: msm: Move io mapping prototypes to common.h
      ARM: msm: Rename board-msm8x60 to signify its DT only status
      ARM: msm: Make 8660 a DT only target
      ARM: msm: Move 8660 to DT timer
      ARM: msm: Add DT support to msm_timer
      ...

commit 32dec75349da4e68b53f099ce3a96469cdc334d6
Merge: 740418ef19fd 9891e3240543
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Sep 20 19:57:38 2012 -0700

    Merge tag 'tegra-for-3.7-dmaengine' of git://git.kernel.org/pub/scm/linux/kernel/git/swarren/linux-tegra into next/cleanup
    
    ARM: tegra: switch to dmaengine
    
    The Tegra code-base has contained both a legacy DMA and a dmaengine
    driver since v3.6-rcX. This series flips Tegra's defconfig to enable
    dmaengine rather than the legacy driver, and removes the legacy driver
    and all client code.
    
    * tag 'tegra-for-3.7-dmaengine' of git://git.kernel.org/pub/scm/linux/kernel/git/swarren/linux-tegra:
      ASoC: tegra: remove support of legacy DMA driver based access
      spi: tegra: remove support of legacy DMA driver based access
      ARM: tegra: apbio: remove support of legacy DMA driver based access
      ARM: tegra: dma: remove legacy APB DMA driver
      ARM: tegra: config: enable dmaengine based APB DMA driver
      + sync to 3.6-rc6

commit 6bfc82ff589a00e5fbc12b958c649d703d273c86
Merge: 26638c667e64 68cb700c59fa
Author: Tony Lindgren <tony@atomide.com>
Date:   Sun Sep 16 15:35:06 2012 -0700

    Merge tag 'omap-cleanup-sparseirq-for-v3.7' into devel-dt
    
    This branch contains changes needed to make omap2+
    work properly with sparse IRQ. It also removes
    dependencies to mach/hardware.h. These help moving
    things towards ARM single zImage support.
    
    This branch is based on a commit in tty-next
    branch with omap-devel-gpmc-fixed-for-v3.7 and
    cleanup-omap-tags-for-v3.7 merged in to keep things
    compiling and sort out some merge conflicts.
    
    Conflicts:
            arch/arm/mach-omap2/omap4-common.c
            drivers/gpio/gpio-twl4030.c

commit 11964f53eb4d9ce59a058be9999d9cfcb1ced878
Merge: 68cb700c59fa 83c115426818
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Sep 12 21:29:07 2012 -0700

    Merge tag 'omap-devel-a2-for-3.7' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into devel-am33xx
    
    AM33xx hwmod data and miscellaneous clock and hwmod fixes.  AM33xx
    should now boot on mainline after this is applied, according to
    Vaibhav.
    
    This second version includes trailing commas at the end of structure
    records at Tony's request.  It also adds a OMAP_INTC_START macro
    expansion to each IRQ number to make the sparseirq conversion easier.
    
    Basic build, boot, and PM test transcripts are here:
    
    http://www.pwsan.com/omap/testlogs/am33xx_hwmod_clock_devel_3.7/20120912165952/

commit 3c101c41fbe5daf88afbbd575542aa1d047812bb
Merge: f191f40c1819 7852ec0536ca
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Sep 12 20:42:36 2012 -0700

    Merge tag 'omap-cleanup-b-for-3.7' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into cleanup-makefile-sparse
    
    smatch and string-wrapping cleanups for the OMAP subarch code.
    
    These changes fix some of the more meaningful warnings that smatch
    returns for the OMAP subarch code, and unwraps strings that are
    wrapped at the 80-column boundary, to conform with the current
    practice.
    
    Basic build, boot, and PM logs are available here:
    
    http://www.pwsan.com/omap/testlogs/warnings_a_cleanup_3.7/20120912025927/

commit dbc04161048dd5e5c3c58546688a0cc0854051e9
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Aug 31 10:59:07 2012 -0700

    ARM: OMAP: Split plat/hardware.h, use local soc.h for omap2+
    
    As the plat and mach includes need to disappear for single zImage work,
    we need to remove plat/hardware.h.
    
    Do this by splitting plat/hardware.h into omap1 and omap2+ specific files.
    
    The old plat/hardware.h already has omap1 only defines, so it gets moved
    to mach/hardware.h for omap1. For omap2+, we use the local soc.h
    that for now just includes the related SoC headers to keep this patch more
    readable.
    
    Note that the local soc.h still includes plat/cpu.h that can be dealt
    with in later patches. Let's also include plat/serial.h from common.h for
    all the board-*.c files. This allows making the include files local later
    on without patching these files again.
    
    Note that only minimal changes are done in this patch for the
    drivers/watchdog/omap_wdt.c driver to keep things compiling. Further
    patches are needed to eventually remove cpu_is_omap usage in the drivers.
    
    Also only minimal changes are done to sound/soc/omap/* to remove the
    unneeded includes and to define OMAP44XX_MCPDM_L3_BASE locally so there's
    no need to include omap44xx.h.
    
    While at it, also sort some of the includes in the standard way.
    
    Cc: linux-watchdog@vger.kernel.org
    Cc: alsa-devel@alsa-project.org
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Jarkko Nikula <jarkko.nikula@bitmer.com>
    Cc: Liam Girdwood <lrg@ti.com>
    Acked-by: Wim Van Sebroeck <wim@iguana.be>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 6ca8e519968d..9db1684df697 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -139,14 +139,14 @@
 #include <linux/slab.h>
 #include <linux/bootmem.h>
 
-#include "common.h"
-#include <plat/cpu.h>
-#include "clockdomain.h"
-#include "powerdomain.h"
 #include <plat/clock.h>
 #include <plat/omap_hwmod.h>
 #include <plat/prcm.h>
 
+#include "soc.h"
+#include "common.h"
+#include "clockdomain.h"
+#include "powerdomain.h"
 #include "cm2xxx_3xxx.h"
 #include "cminst44xx.h"
 #include "prm2xxx_3xxx.h"

commit 7852ec0536ca39cefffc6301dc77f8ae55592926
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Jul 26 00:54:26 2012 -0600

    ARM: OMAP: unwrap strings
    
    Find and unwrap wrapped strings in the style:
    
            pr_debug("clockdomain: hardware cannot set/clear wake up of "
                     "%s when %s wakes up\n", clkdm1->name, clkdm2->name);
    
    Keeping these strings contiguous seems to be the current Linux kernel
    policy.
    
    The offending lines were found with the following command:
    
        pcregrep -rnM '"\s*$\s*"' arch/arm/*omap*
    
    While here, some messages have been clarified, some pr_warning(
    ... calls have been converted to pr_warn( ..., and some printk(KERN_*
    ... have been converted to pr_*.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index bd69eaefcc97..ae0dd96f7795 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1641,8 +1641,8 @@ static int _ocp_softreset(struct omap_hwmod *oh)
 
 	/* clocks must be on for this operation */
 	if (oh->_state != _HWMOD_STATE_ENABLED) {
-		pr_warning("omap_hwmod: %s: reset can only be entered from "
-			   "enabled state\n", oh->name);
+		pr_warn("omap_hwmod: %s: reset can only be entered from enabled state\n",
+			oh->name);
 		return -EINVAL;
 	}
 

commit a032d33b65c89a781c871fd1def595fa6a69b52a
Author: Paul Walmsley <paul@pwsan.com>
Date:   Fri Aug 3 09:21:10 2012 -0600

    ARM: OMAP: clean up some smatch warnings, fix some printk(KERN_ERR ...
    
    Resolve the following warnings from smatch:
    
    arch/arm/mach-omap2/gpmc.c:282 gpmc_cs_set_timings() info: why not propagate 'div' from gpmc_cs_calc_divider() instead of -1?
    arch/arm/mach-omap2/serial.c:328 omap_serial_init_port() error: 'pdev' dereferencing possible ERR_PTR()
    arch/arm/mach-omap2/timer.c:213 omap2_gp_clockevent_init() Error invalid range 4096 to -1
    arch/arm/mach-omap2/gpio.c:63 omap2_gpio_dev_init() warn: possible memory leak of 'pdata'
    arch/arm/mach-omap2/omap_hwmod.c:1478 _assert_hardreset() warn: assigning -22 to unsigned variable 'ret'
    arch/arm/mach-omap2/omap_hwmod.c:1487 _assert_hardreset() warn: 4294963201 is more than 255 (max '(ret)' can be) so this is always the same.
    arch/arm/mach-omap2/omap_hwmod.c:1545 _read_hardreset() warn: assigning -22 to unsigned variable 'ret'
    arch/arm/mach-omap2/omap_hwmod.c:1554 _read_hardreset() warn: 4294963201 is more than 255 (max '(ret)' can be) so this is always the same.
    arch/arm/mach-omap2/dpll3xxx.c:629 omap3_clkoutx2_recalc() error: we previously assumed 'pclk' could be null (see line 627)
    arch/arm/mach-omap2/board-n8x0.c:422 n8x0_mmc_late_init() Error invalid range 14 to 13
    arch/arm/mach-omap1/leds-h2p2-debug.c:71 h2p2_dbg_leds_event() error: potentially derefencing uninitialized 'fpga'.
    arch/arm/plat-omap/mux.c:79 omap_cfg_reg() Error invalid range 4096 to -1
    
    Thanks to Tony Lindgren <tony@atomide.com> for pointing out that BUG()
    can be disabled.  The changes in the first version that removed the
    subsequent return() after BUG() states have been dropped.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 6ca8e519968d..bd69eaefcc97 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1438,8 +1438,8 @@ static int _init_clocks(struct omap_hwmod *oh, void *data)
  * Return the bit position of the reset line that match the
  * input name. Return -ENOENT if not found.
  */
-static u8 _lookup_hardreset(struct omap_hwmod *oh, const char *name,
-			    struct omap_hwmod_rst_info *ohri)
+static int _lookup_hardreset(struct omap_hwmod *oh, const char *name,
+			     struct omap_hwmod_rst_info *ohri)
 {
 	int i;
 
@@ -1475,7 +1475,7 @@ static u8 _lookup_hardreset(struct omap_hwmod *oh, const char *name,
 static int _assert_hardreset(struct omap_hwmod *oh, const char *name)
 {
 	struct omap_hwmod_rst_info ohri;
-	u8 ret = -EINVAL;
+	int ret = -EINVAL;
 
 	if (!oh)
 		return -EINVAL;
@@ -1484,7 +1484,7 @@ static int _assert_hardreset(struct omap_hwmod *oh, const char *name)
 		return -ENOSYS;
 
 	ret = _lookup_hardreset(oh, name, &ohri);
-	if (IS_ERR_VALUE(ret))
+	if (ret < 0)
 		return ret;
 
 	ret = soc_ops.assert_hardreset(oh, &ohri);
@@ -1542,7 +1542,7 @@ static int _deassert_hardreset(struct omap_hwmod *oh, const char *name)
 static int _read_hardreset(struct omap_hwmod *oh, const char *name)
 {
 	struct omap_hwmod_rst_info ohri;
-	u8 ret = -EINVAL;
+	int ret = -EINVAL;
 
 	if (!oh)
 		return -EINVAL;
@@ -1551,7 +1551,7 @@ static int _read_hardreset(struct omap_hwmod *oh, const char *name)
 		return -ENOSYS;
 
 	ret = _lookup_hardreset(oh, name, &ohri);
-	if (IS_ERR_VALUE(ret))
+	if (ret < 0)
 		return ret;
 
 	return soc_ops.is_hardreset_asserted(oh, &ohri);

commit 1688bf19b8daaa2eb4e861c33a6396ca85b890c3
Author: Vaibhav Hiremath <hvaibhav@ti.com>
Date:   Tue Sep 11 17:18:53 2012 -0600

    ARM: OMAP2+: hwmod: Hook-up am33xx support in omap_hwmod framework
    
    AM33XX PRCM architecture is different that any OMAP family
    of devices, so it is required to have separate implementation
    to handle AM33XX module enable/disable, reset assert/deassert
    functionality.
    This patch adds wrapper api's in omap_hwmod framework to
    access prm/cm for AM33XX family of devices.
    
    Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>
    [paul@pwsan.com: fixed checkpatch messages]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 6ca8e519968d..948143890539 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -149,8 +149,10 @@
 
 #include "cm2xxx_3xxx.h"
 #include "cminst44xx.h"
+#include "cm33xx.h"
 #include "prm2xxx_3xxx.h"
 #include "prm44xx.h"
+#include "prm33xx.h"
 #include "prminst44xx.h"
 #include "mux.h"
 #include "pm.h"
@@ -867,6 +869,26 @@ static void _omap4_enable_module(struct omap_hwmod *oh)
 				   oh->prcm.omap4.clkctrl_offs);
 }
 
+/**
+ * _am33xx_enable_module - enable CLKCTRL modulemode on AM33XX
+ * @oh: struct omap_hwmod *
+ *
+ * Enables the PRCM module mode related to the hwmod @oh.
+ * No return value.
+ */
+static void _am33xx_enable_module(struct omap_hwmod *oh)
+{
+	if (!oh->clkdm || !oh->prcm.omap4.modulemode)
+		return;
+
+	pr_debug("omap_hwmod: %s: %s: %d\n",
+		 oh->name, __func__, oh->prcm.omap4.modulemode);
+
+	am33xx_cm_module_enable(oh->prcm.omap4.modulemode, oh->clkdm->cm_inst,
+				oh->clkdm->clkdm_offs,
+				oh->prcm.omap4.clkctrl_offs);
+}
+
 /**
  * _omap4_wait_target_disable - wait for a module to be disabled on OMAP4
  * @oh: struct omap_hwmod *
@@ -893,6 +915,31 @@ static int _omap4_wait_target_disable(struct omap_hwmod *oh)
 					     oh->prcm.omap4.clkctrl_offs);
 }
 
+/**
+ * _am33xx_wait_target_disable - wait for a module to be disabled on AM33XX
+ * @oh: struct omap_hwmod *
+ *
+ * Wait for a module @oh to enter slave idle.  Returns 0 if the module
+ * does not have an IDLEST bit or if the module successfully enters
+ * slave idle; otherwise, pass along the return value of the
+ * appropriate *_cm*_wait_module_idle() function.
+ */
+static int _am33xx_wait_target_disable(struct omap_hwmod *oh)
+{
+	if (!oh)
+		return -EINVAL;
+
+	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
+		return 0;
+
+	if (oh->flags & HWMOD_NO_IDLEST)
+		return 0;
+
+	return am33xx_cm_wait_module_idle(oh->clkdm->cm_inst,
+					     oh->clkdm->clkdm_offs,
+					     oh->prcm.omap4.clkctrl_offs);
+}
+
 /**
  * _count_mpu_irqs - count the number of MPU IRQ lines associated with @oh
  * @oh: struct omap_hwmod *oh
@@ -1613,6 +1660,36 @@ static int _omap4_disable_module(struct omap_hwmod *oh)
 	return 0;
 }
 
+/**
+ * _am33xx_disable_module - enable CLKCTRL modulemode on AM33XX
+ * @oh: struct omap_hwmod *
+ *
+ * Disable the PRCM module mode related to the hwmod @oh.
+ * Return EINVAL if the modulemode is not supported and 0 in case of success.
+ */
+static int _am33xx_disable_module(struct omap_hwmod *oh)
+{
+	int v;
+
+	if (!oh->clkdm || !oh->prcm.omap4.modulemode)
+		return -EINVAL;
+
+	pr_debug("omap_hwmod: %s: %s\n", oh->name, __func__);
+
+	am33xx_cm_module_disable(oh->clkdm->cm_inst, oh->clkdm->clkdm_offs,
+				 oh->prcm.omap4.clkctrl_offs);
+
+	if (_are_any_hardreset_lines_asserted(oh))
+		return 0;
+
+	v = _am33xx_wait_target_disable(oh);
+	if (v)
+		pr_warn("omap_hwmod: %s: _wait_target_disable failed\n",
+			oh->name);
+
+	return 0;
+}
+
 /**
  * _ocp_softreset - reset an omap_hwmod via the OCP_SYSCONFIG bit
  * @oh: struct omap_hwmod *
@@ -2547,6 +2624,33 @@ static int _omap4_wait_target_ready(struct omap_hwmod *oh)
 					      oh->prcm.omap4.clkctrl_offs);
 }
 
+/**
+ * _am33xx_wait_target_ready - wait for a module to leave slave idle
+ * @oh: struct omap_hwmod *
+ *
+ * Wait for a module @oh to leave slave idle.  Returns 0 if the module
+ * does not have an IDLEST bit or if the module successfully leaves
+ * slave idle; otherwise, pass along the return value of the
+ * appropriate *_cm*_wait_module_ready() function.
+ */
+static int _am33xx_wait_target_ready(struct omap_hwmod *oh)
+{
+	if (!oh || !oh->clkdm)
+		return -EINVAL;
+
+	if (oh->flags & HWMOD_NO_IDLEST)
+		return 0;
+
+	if (!_find_mpu_rt_port(oh))
+		return 0;
+
+	/* XXX check module SIDLEMODE, hardreset status */
+
+	return am33xx_cm_wait_module_ready(oh->clkdm->cm_inst,
+					      oh->clkdm->clkdm_offs,
+					      oh->prcm.omap4.clkctrl_offs);
+}
+
 /**
  * _omap2_assert_hardreset - call OMAP2 PRM hardreset fn with hwmod args
  * @oh: struct omap_hwmod * to assert hardreset
@@ -2678,6 +2782,72 @@ static int _omap4_is_hardreset_asserted(struct omap_hwmod *oh,
 				oh->prcm.omap4.rstctrl_offs);
 }
 
+/**
+ * _am33xx_assert_hardreset - call AM33XX PRM hardreset fn with hwmod args
+ * @oh: struct omap_hwmod * to assert hardreset
+ * @ohri: hardreset line data
+ *
+ * Call am33xx_prminst_assert_hardreset() with parameters extracted
+ * from the hwmod @oh and the hardreset line data @ohri.  Only
+ * intended for use as an soc_ops function pointer.  Passes along the
+ * return value from am33xx_prminst_assert_hardreset().  XXX This
+ * function is scheduled for removal when the PRM code is moved into
+ * drivers/.
+ */
+static int _am33xx_assert_hardreset(struct omap_hwmod *oh,
+				   struct omap_hwmod_rst_info *ohri)
+
+{
+	return am33xx_prm_assert_hardreset(ohri->rst_shift,
+				oh->clkdm->pwrdm.ptr->prcm_offs,
+				oh->prcm.omap4.rstctrl_offs);
+}
+
+/**
+ * _am33xx_deassert_hardreset - call AM33XX PRM hardreset fn with hwmod args
+ * @oh: struct omap_hwmod * to deassert hardreset
+ * @ohri: hardreset line data
+ *
+ * Call am33xx_prminst_deassert_hardreset() with parameters extracted
+ * from the hwmod @oh and the hardreset line data @ohri.  Only
+ * intended for use as an soc_ops function pointer.  Passes along the
+ * return value from am33xx_prminst_deassert_hardreset().  XXX This
+ * function is scheduled for removal when the PRM code is moved into
+ * drivers/.
+ */
+static int _am33xx_deassert_hardreset(struct omap_hwmod *oh,
+				     struct omap_hwmod_rst_info *ohri)
+{
+	if (ohri->st_shift)
+		pr_err("omap_hwmod: %s: %s: hwmod data error: OMAP4 does not support st_shift\n",
+		       oh->name, ohri->name);
+
+	return am33xx_prm_deassert_hardreset(ohri->rst_shift,
+				oh->clkdm->pwrdm.ptr->prcm_offs,
+				oh->prcm.omap4.rstctrl_offs,
+				oh->prcm.omap4.rstst_offs);
+}
+
+/**
+ * _am33xx_is_hardreset_asserted - call AM33XX PRM hardreset fn with hwmod args
+ * @oh: struct omap_hwmod * to test hardreset
+ * @ohri: hardreset line data
+ *
+ * Call am33xx_prminst_is_hardreset_asserted() with parameters
+ * extracted from the hwmod @oh and the hardreset line data @ohri.
+ * Only intended for use as an soc_ops function pointer.  Passes along
+ * the return value from am33xx_prminst_is_hardreset_asserted().  XXX
+ * This function is scheduled for removal when the PRM code is moved
+ * into drivers/.
+ */
+static int _am33xx_is_hardreset_asserted(struct omap_hwmod *oh,
+					struct omap_hwmod_rst_info *ohri)
+{
+	return am33xx_prm_is_hardreset_asserted(ohri->rst_shift,
+				oh->clkdm->pwrdm.ptr->prcm_offs,
+				oh->prcm.omap4.rstctrl_offs);
+}
+
 /* Public functions */
 
 u32 omap_hwmod_read(struct omap_hwmod *oh, u16 reg_offs)
@@ -3677,6 +3847,14 @@ void __init omap_hwmod_init(void)
 		soc_ops.deassert_hardreset = _omap4_deassert_hardreset;
 		soc_ops.is_hardreset_asserted = _omap4_is_hardreset_asserted;
 		soc_ops.init_clkdm = _init_clkdm;
+	} else if (soc_is_am33xx()) {
+		soc_ops.enable_module = _am33xx_enable_module;
+		soc_ops.disable_module = _am33xx_disable_module;
+		soc_ops.wait_target_ready = _am33xx_wait_target_ready;
+		soc_ops.assert_hardreset = _am33xx_assert_hardreset;
+		soc_ops.deassert_hardreset = _am33xx_deassert_hardreset;
+		soc_ops.is_hardreset_asserted = _am33xx_is_hardreset_asserted;
+		soc_ops.init_clkdm = _init_clkdm;
 	} else {
 		WARN(1, "omap_hwmod: unknown SoC type\n");
 	}

commit b82b04e8eb27abe0cfe9cd7bf4fee8bb1bb9b013
Author: Vaibhav Hiremath <hvaibhav@ti.com>
Date:   Wed Aug 29 15:18:11 2012 +0530

    ARM: OMAP: omap_device: Do not overwrite resources allocated by OF layer
    
    With the new devices (like, AM33XX and OMAP5) we now only support
    DT boot mode of operation and now it is the time to start killing
    slowly the dependency on hwmod, so with this patch, we are starting
    with device resources.
    The idea here is implemented considering to both boot modes -
      - DT boot mode
        OF framework will construct the resource structure (currently
        does for MEM & IRQ resource) and we should respect/use these
        resources, killing hwmod dependency.
        If pdev->num_resources > 0, we assume that MEM & IRQ resources
        have been allocated by OF layer already (through DTB).
    
        Once DMA resource is available from OF layer, we should
        kill filling any resources from hwmod.
    
      - Non-DT boot mode
        Here, pdev->num_resources = 0, and we should get all the
        resources from hwmod (following existing steps)
    
    Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@ti.com>
    [b-cousson@ti.com: Fix some checkpatch CHECK issues]
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 6ca8e519968d..7768804457e3 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3157,6 +3157,33 @@ int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 	return r;
 }
 
+/**
+ * omap_hwmod_fill_dma_resources - fill struct resource array with dma data
+ * @oh: struct omap_hwmod *
+ * @res: pointer to the array of struct resource to fill
+ *
+ * Fill the struct resource array @res with dma resource data from the
+ * omap_hwmod @oh.  Intended to be called by code that registers
+ * omap_devices.  See also omap_hwmod_count_resources().  Returns the
+ * number of array elements filled.
+ */
+int omap_hwmod_fill_dma_resources(struct omap_hwmod *oh, struct resource *res)
+{
+	int i, sdma_reqs_cnt;
+	int r = 0;
+
+	sdma_reqs_cnt = _count_sdma_reqs(oh);
+	for (i = 0; i < sdma_reqs_cnt; i++) {
+		(res + r)->name = (oh->sdma_reqs + i)->name;
+		(res + r)->start = (oh->sdma_reqs + i)->dma_req;
+		(res + r)->end = (oh->sdma_reqs + i)->dma_req;
+		(res + r)->flags = IORESOURCE_DMA;
+		r++;
+	}
+
+	return r;
+}
+
 /**
  * omap_hwmod_get_resource_byname - fetch IP block integration data by name
  * @oh: struct omap_hwmod * to operate on

commit 471a009b6db7670299a8674cd7fb2557c8c2797f
Author: Misael Lopez Cruz <misael.lopez@ti.com>
Date:   Mon Sep 3 11:50:52 2012 -0600

    ARM: OMAP: hwmod code: Disable module when hwmod enable fails
    
    Clock and module mode are explictly enable when hwmod is enabled. But if
    the hwmod doesn't get ready on time, clocks are disabled but module is left
    enabled.
    
    Signed-off-by: Misael Lopez Cruz <misael.lopez@ti.com>
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 6ca8e519968d..37afbd173c2c 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1889,6 +1889,7 @@ static int _enable(struct omap_hwmod *oh)
 			_enable_sysc(oh);
 		}
 	} else {
+		_omap4_disable_module(oh);
 		_disable_clocks(oh);
 		pr_debug("omap_hwmod: %s: _wait_target_ready: %d\n",
 			 oh->name, r);

commit a5ebba6b54bc8038a38d3eacac3a79bbeaf3ee24
Merge: e81218f5f0fd 6b21a9ce0402
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 23 17:43:53 2012 -0700

    Merge tag 'pm' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull arm-soc power management changes from Arnd Bergmann:
     "These are various power management related changes, mainly concerning
      cpuidle on i.MX and OMAP, as well as a the move of the omap
      smartreflex driver to live in the power subsystem."
    
    Fix up conflicts in arch/arm/mach-{imx/mach-imx6q.c,omap2/prm2xxx_3xxx.h}
    
    * tag 'pm' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (37 commits)
      ARM: OMAP2+: PM: fix IRQ_NOAUTOEN removal by mis-merge
      ARM: OMAP2+: do not allow SmartReflex to be built as a module
      ARM: OMAP2: Use hwmod to initialize mmc for 2420
      ARM: OMAP3: PM: cpuidle: optimize the clkdm idle latency in C1 state
      ARM: OMAP3: PM: cpuidle: optimize the PER latency in C1 state
      ARM: OMAP3: PM: cpuidle: default to C1 in next_valid_state
      ARM: OMAP3: PM: cleanup cam_pwrdm leftovers
      ARM: OMAP3: PM: call pre/post transition per powerdomain
      ARM: OMAP2+: powerdomain: allow pre/post transtion to be per pwrdm
      ARM: OMAP3: PM: Remove IO Daisychain control from cpuidle
      ARM: OMAP3PLUS: hwmod: reconfigure IO Daisychain during hwmod mux
      ARM: OMAP3+: PRM: Enable IO wake up
      ARM: OMAP4: PRM: Add IO Daisychain support
      ARM: OMAP3: PM: Move IO Daisychain function to omap3 prm file
      ARM: OMAP3: PM: correct enable/disable of daisy io chain
      ARM: OMAP2+: PRM: fix compile for OMAP4-only build
      W1: OMAP HDQ1W: use runtime PM
      ARM: OMAP2+: HDQ1W: use omap_device
      W1: OMAP HDQ1W: use 32-bit register accesses
      W1: OMAP HDQ1W: allow driver to be built on all OMAP2+
      ...

commit f01b9b73f57f4f92d39bba0d9aa4a38f318212df
Merge: fde754302781 66314223aa5e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 23 16:31:31 2012 -0700

    Merge tag 'newsoc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull support for three new arm SoC types from Arnd Bergmann:
    
     - The mvebu platform includes Marvell's Armada XP and Armada 370 chips,
       made by the mvebu business unit inside of Marvell.  Since the same
       group also made the older but similar platforms we call "orion5x",
       "kirkwood", "mv78xx0" and "dove", we plan to move all of them into
       the mach-mvebu directory in the future.
    
     - socfpga is Altera's platform based on Cortex-A9 cores and a lot of
       FPGA space.  This is similar to the Xilinx zynq platform we already
       support.  The code is particularly clean, which is helped by the fact
       that the hardware doesn't do much besides the parts that are expected
       to get added in the FPGA.
    
     - The OMAP subarchitecture gains support for the latest generation, the
       OMAP5 based on the new Cortex-A15 core.  Support is rather
       rudimentary for now, but will be extended in the future.
    
    * tag 'newsoc' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (25 commits)
      ARM: socfpga: initial support for Altera's SOCFPGA platform
      arm: mvebu: generate DTBs for supported SoCs
      ARM: mvebu: MPIC: read number of interrupts from control register
      arm: mach-mvebu: add entry to MAINTAINERS
      arm: mach-mvebu: add compilation/configuration change
      arm: mach-mvebu: add defconfig
      arm: mach-mvebu: add documentation for new device tree bindings
      arm: mach-mvebu: add support for Armada 370 and Armada XP with DT
      arm: mach-mvebu: add source files
      arm: mach-mvebu: add header
      clocksource: time-armada-370-xp: Marvell Armada 370/XP SoC timer driver
      ARM: Kconfig update to support additional GPIOs in OMAP5
      ARM: OMAP5: Add the build support
      arm/dts: OMAP5: Add omap5 dts files
      ARM: OMAP5: board-generic: Add device tree support
      ARM: omap2+: board-generic: clean up the irq data from board file
      ARM: OMAP5: Add SMP support
      ARM: OMAP5: Add the WakeupGen IP updates
      ARM: OMAP5: l3: Add l3 error handler support for omap5
      ARM: OMAP5: gpmc: Update gpmc_init()
      ...
    
    Conflicts:
            Documentation/devicetree/bindings/arm/omap/omap.txt
            arch/arm/mach-omap2/Makefile
            drivers/clocksource/Kconfig
            drivers/clocksource/Makefile

commit fde75430278130505cac21997cd9f90b7bb2670a
Merge: 1a4120bc101b db3c47a3af96
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 23 16:22:12 2012 -0700

    Merge tag 'cleanup2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull arm-soc cleanups, part 2, from Arnd Bergmann:
     "These omap cleanups have dependencies on earlier omap branches that in
      turn depend on other cleanups, so they could not go into the same
      branch."
    
    * tag 'cleanup2' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      ARM: OMAP: sdrc: Fix the build break for OMAP4 only builds
      ARM: OMAP2+: dmtimer: cleanup fclk usage
      ARM: OMAP2+: Fix mismerge for omap_hwmod_get_main_clk() API
      ARM: OMAP2+: Remove unnecessary ifdef around __omap2_set_globals
      ARM: OMAP2+: am33xx: Change cpu_is_am33xx to soc_is_am33xx
      ARM: OMAP2+: am33xx: Make am33xx as a separate class
      ARM: OMAP2+: Move omap3 dpll ops to dpll3xxx.c
      ARM: OMAP2+: All OMAP2PLUS uses omap-device.o target so add one entry
      ARM: OMAP: dmtimer: use devm_ API and do some cleanup in probe()
      ARM: OMAP2+: hwmod code: add support to set dmadisable in hwmod framework
      ARM: OMAP2+: PRM/CM: Move the stubbed prm and cm functions to prcm.c file and make them __weak
      ARM: OMAP2+: hwmod: add omap_hwmod_get_main_clk() API
      ARM: OMAP3+: dpll: optimize noncore dpll locking logic
      ARM: OMAP3: control: add definition for CONTROL_CAMERA_PHY_CTRL
      ARM: OMAP2+: powerdomain code: Fix Wake-up power domain power status
      ARM: OMAP4: clockdomain/CM code: Update supported transition modes
      ARM: OMAP3/4: omap_hwmod: Add rstst_offs field to struct omap_hwmod_omap4_prcm
      ARM: OMAP2+: hwmod: Add new sysc_type3 into omap_hwmod required for am33xx

commit 451ce7f9cf2d17e34d5d64b76cac047a2a1a3b89
Merge: b85c14fb833e 1a33a4ebecce
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 23 16:04:15 2012 -0700

    Merge tag 'cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull general arm-soc cleanups from Arnd Bergmann:
     "These are all boring changes, moving stuff around or renaming things
      mostly, and also getting rid of stuff that is duplicate or should not
      be there to start with.  Platform-wise this is all over the place,
      mainly omap, samsung, at91, imx and tegra."
    
    Resolve trivial conflict in arch/arm/mach-omap2/clockdomains3xxx_data.c
    
    * tag 'cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (67 commits)
      ARM: clps711x: Remove the setting of the time
      ARM: clps711x: Removed superfluous transform virt_to_bus and related functions
      ARM: clps711x/p720t: Replace __initcall by .init_early call
      ARM: S3C24XX: Remove unused GPIO definitions for Openmoko GTA02 board
      ARM: S3C24XX: Remove unused GPIO definitions for port J
      ARM: S3C24XX: Remove unused GPA, GPE, GPH bank GPIO aliases
      ARM: S3C24XX: Convert the touchscreen setup code to common GPIO API
      ARM: S3C24XX: Convert the PM code to gpiolib API
      ARM: S3C24XX: Convert QT2410 board file to the gpiolib API
      ARM: S3C24XX: Convert SMDK board file to the gpiolib API
      ARM: S3C24XX: Free the backlight gpio requested in Mini2440 board code
      ARM: imx: remove unused pdata from device macros
      ARM: imx: Kconfig: Remove IMX_HAVE_PLATFORM_IMX_SSI from MACH_MX25_3DS
      ARM: at91: fix new build errors
      ARM: at91: add AIC5 support
      ARM: at91: remove mach/irqs.h
      ARM: at91: sparse irq support
      ARM: at91: at91 based machines specify their own irq handler at run time
      ARM: at91: remove static irq priorities for sam9x5
      ARM: at91: add of irq priorities support
      ...

commit 05e152c76a1efaa3165afecf5acf535c8283f386
Author: R Sricharan <r.sricharan@ti.com>
Date:   Tue Jun 5 16:21:32 2012 +0530

    ARM: OMAP5: Add minimal support for OMAP5430 SOC
    
    OMAP5430 is Texas Instrument's SOC based on ARM Cortex-A15 SMP
    architecture. It's a dual core SOC with GIC used for interrupt
    handling and with an integrated L2 cache controller.
    
    OMAP5432 is another variant of OMAP5430, with a
    memory controller supporting DDR3 and SATA.
    
    Patch includes:
     - The machine specific headers and sources updates.
     - Platform header updates.
     - Minimum initialisation support for serial.
     - IO table init
    
    Signed-off-by: R Sricharan <r.sricharan@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index ff76ef1d7232..2ada3642c671 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3619,7 +3619,7 @@ void __init omap_hwmod_init(void)
 		soc_ops.assert_hardreset = _omap2_assert_hardreset;
 		soc_ops.deassert_hardreset = _omap2_deassert_hardreset;
 		soc_ops.is_hardreset_asserted = _omap2_is_hardreset_asserted;
-	} else if (cpu_is_omap44xx()) {
+	} else if (cpu_is_omap44xx() || soc_is_omap54xx()) {
 		soc_ops.enable_module = _omap4_enable_module;
 		soc_ops.disable_module = _omap4_disable_module;
 		soc_ops.wait_target_ready = _omap4_wait_target_ready;

commit 68c9a95e9253ce1776bd21bf8d37ddf213cced66
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Jul 6 00:58:43 2012 -0700

    ARM: OMAP2+: Fix mismerge for omap_hwmod_get_main_clk() API
    
    Commit ac5b0ea3d (Merge tag 'omap-devel-f-for-3.6'...) had a merge
    conflict that somehow got incorrecly resolved in a lossy way for
    commit bed9d1bb (ARM: OMAP2+: hwmod: add omap_hwmod_get_main_clk() API).
    Fix the issue by applying the missing pieces.
    
    Reported-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index ebdf0016e536..ff76ef1d7232 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3633,3 +3633,18 @@ void __init omap_hwmod_init(void)
 
 	inited = true;
 }
+
+/**
+ * omap_hwmod_get_main_clk - get pointer to main clock name
+ * @oh: struct omap_hwmod *
+ *
+ * Returns the main clock name assocated with @oh upon success,
+ * or NULL if @oh is NULL.
+ */
+const char *omap_hwmod_get_main_clk(struct omap_hwmod *oh)
+{
+	if (!oh)
+		return NULL;
+
+	return oh->main_clk;
+}

commit 006c7f18449a06027b0165e938c67b3a029813c9
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Jul 4 05:22:53 2012 -0600

    ARM: OMAP2+: hwmod code/clockdomain data: fix 32K sync timer
    
    Kevin discovered that commit c8d82ff68fb6873691536cf33021977efbf5593c
    ("ARM: OMAP2/3: hwmod data: Add 32k-sync timer data to hwmod
    database") broke CORE idle on OMAP3.  This prevents device low power
    states.
    
    The root cause is that the 32K sync timer IP block does not support
    smart-idle mode[1], and so the hwmod code keeps the IP block in
    no-idle mode while it is active.  This in turn prevents the WKUP
    clockdomain from transitioning to idle.  There is a hardcoded sleep
    dependency that prevents the CORE_L3 and CORE_CM clockdomains from
    transitioning to idle when the WKUP clockdomain is active[2], so the
    chip cannot enter any device low power states.
    
    It turns out that there is no need to take the 32k sync timer out of
    idle.  The IP block itself probably does not have any native idle
    handling at all, due to its simplicity.  Furthermore, the PRCM will
    never request target idle for this IP block while the kernel is
    running, due to the sleep dependency that prevents the WKUP
    clockdomain from idling while the CORE_L3 clockdomain is active.  So
    we can safely leave the 32k sync timer in target-force-idle mode, even
    while we continue to access it.
    
    This workaround is implemented by defining a new clockdomain flag,
    CLKDM_ACTIVE_WITH_MPU, that indicates that the clockdomain is
    guaranteed to be active whenever the MPU is inactive.  If an IP
    block's main functional clock exists inside this clockdomain, and the
    IP block does not support smart-idle modes, then the hwmod code will
    place the IP block into target force-idle mode even when enabled.  The
    WKUP clockdomains on OMAP3/4 are marked with this flag.  (On OMAP2xxx,
    no OCP header existed on the 32k sync timer.)   Other clockdomains also
    should be marked with this flag, but those changes are deferred until
    a later merge window, to create a minimal fix.
    
    Another theoretically clean fix for this problem would be to implement
    PM runtime-based control for 32k sync timer accesses.  These PM
    runtime calls would need to located in a custom clocksource, since the
    32k sync timer is currently used as an MMIO clocksource.  But in
    practice, there would be little benefit to doing so; and there would
    be some cost, due to the addition of unnecessary lines of code and the
    additional CPU overhead of the PM runtime and hwmod code - unnecessary
    in this case.
    
    Another possible fix would have been to modify the pm34xx.c code to
    force the IP block idle before entering WFI.  But this would not have
    been an acceptable approach: we are trying to remove this type of
    centralized IP block idle control from the PM code.
    
    This patch is a collaboration between Kevin Hilman <khilman@ti.com>
    and Paul Walmsley <paul@pwsan.com>.
    
    Thanks to Vaibhav Hiremath <hvaibhav@ti.com> for providing comments on
    an earlier version of this patch.  Thanks to Tero Kristo
    <t-kristo@ti.com> for identifying a bug in an earlier version of this
    patch.  Thanks to Benot Cousson <b-cousson@ti.com> for identifying
    some bugs in several versions of this patch and for implementation
    comments.
    
    References:
    
    1. Table 16-96 "REG_32KSYNCNT_SYSCONFIG" of the OMAP34xx TRM Rev. ZU
       (SWPU223U), available from:
       http://www.ti.com/pdfs/wtbu/OMAP34x_ES3.1.x_PUBLIC_TRM_vzU.zip
    
    2. Table 4-72 "Sleep Dependencies" of the OMAP34xx TRM Rev. ZU
       (SWPU223U)
    
    3. ibid.
    
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Vaibhav Hiremath <hvaibhav@ti.com>
    Cc: Benot Cousson <b-cousson@ti.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Tested-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 773193670ea2..2d710f50fca2 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1124,15 +1124,18 @@ static struct omap_hwmod_addr_space * __init _find_mpu_rt_addr_space(struct omap
  * _enable_sysc - try to bring a module out of idle via OCP_SYSCONFIG
  * @oh: struct omap_hwmod *
  *
- * If module is marked as SWSUP_SIDLE, force the module out of slave
- * idle; otherwise, configure it for smart-idle.  If module is marked
- * as SWSUP_MSUSPEND, force the module out of master standby;
- * otherwise, configure it for smart-standby.  No return value.
+ * Ensure that the OCP_SYSCONFIG register for the IP block represented
+ * by @oh is set to indicate to the PRCM that the IP block is active.
+ * Usually this means placing the module into smart-idle mode and
+ * smart-standby, but if there is a bug in the automatic idle handling
+ * for the IP block, it may need to be placed into the force-idle or
+ * no-idle variants of these modes.  No return value.
  */
 static void _enable_sysc(struct omap_hwmod *oh)
 {
 	u8 idlemode, sf;
 	u32 v;
+	bool clkdm_act;
 
 	if (!oh->class->sysc)
 		return;
@@ -1141,8 +1144,16 @@ static void _enable_sysc(struct omap_hwmod *oh)
 	sf = oh->class->sysc->sysc_flags;
 
 	if (sf & SYSC_HAS_SIDLEMODE) {
-		idlemode = (oh->flags & HWMOD_SWSUP_SIDLE) ?
-			HWMOD_IDLEMODE_NO : HWMOD_IDLEMODE_SMART;
+		clkdm_act = ((oh->clkdm &&
+			      oh->clkdm->flags & CLKDM_ACTIVE_WITH_MPU) ||
+			     (oh->_clk && oh->_clk->clkdm &&
+			      oh->_clk->clkdm->flags & CLKDM_ACTIVE_WITH_MPU));
+		if (clkdm_act && !(oh->class->sysc->idlemodes &
+				   (SIDLE_SMART | SIDLE_SMART_WKUP)))
+			idlemode = HWMOD_IDLEMODE_FORCE;
+		else
+			idlemode = (oh->flags & HWMOD_SWSUP_SIDLE) ?
+				HWMOD_IDLEMODE_NO : HWMOD_IDLEMODE_SMART;
 		_set_slave_idlemode(oh, idlemode, &v);
 	}
 
@@ -1208,8 +1219,13 @@ static void _idle_sysc(struct omap_hwmod *oh)
 	sf = oh->class->sysc->sysc_flags;
 
 	if (sf & SYSC_HAS_SIDLEMODE) {
-		idlemode = (oh->flags & HWMOD_SWSUP_SIDLE) ?
-			HWMOD_IDLEMODE_FORCE : HWMOD_IDLEMODE_SMART;
+		/* XXX What about HWMOD_IDLEMODE_SMART_WKUP? */
+		if (oh->flags & HWMOD_SWSUP_SIDLE ||
+		    !(oh->class->sysc->idlemodes &
+		      (SIDLE_SMART | SIDLE_SMART_WKUP)))
+			idlemode = HWMOD_IDLEMODE_FORCE;
+		else
+			idlemode = HWMOD_IDLEMODE_SMART;
 		_set_slave_idlemode(oh, idlemode, &v);
 	}
 

commit ac5b0ea3d00d231dd9cedd45636b29defc368a4c
Merge: 3f96a2d90e69 8cb8de5d87b7
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Jul 5 02:13:04 2012 -0700

    Merge tag 'omap-devel-f-for-3.6' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into cleanup-part2
    
    Miscellaneous OMAP clock, hwmod, clockdomain, and powerdomain patches
    for 3.6.  Mostly small infrastructure improvements, and preparation
    for OMAP5 and AM33xx code.
    
    Conflicts:
            arch/arm/mach-omap2/omap_hwmod.c
            arch/arm/plat-omap/include/plat/omap_hwmod.h

commit 6668546f3bb4cc0dde75ac1ef1d436b67e4ef638
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Wed Jul 4 05:09:21 2012 -0600

    ARM: OMAP2+: hwmod code: add support to set dmadisable in hwmod framework
    
    The DMADISABLE bit is a semi-automatic bit present in sysconfig register
    of some modules. When the DMA must perform read/write accesses, the
    DMADISABLE bit is cleared by the hardware. But when the DMA must stop for power
    management, software must set the DMADISABLE bit back to 1.
    
    In cases where the ROMCODE/BOOTLOADER uses dma, the hardware clears the
    DMADISABLE bit (but the romcode/bootloader might not set it back to 1).
    In order for the kernel to start in a clean state, it is
    necessary for the kernel to set DMADISABLE bit back to 1 (irrespective
    of whether it's been set to 1 in romcode or bootloader).
    
    During _reset of the (hwmod)device, the DMADISABLE bit is set so that it
    does not prevent idling of the system. (NOTE: having DMADISABLE to 0,
    prevents the system to idle)
    
    DMADISABLE bit is present in usbotgss module of omap5.
    
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    [paul@pwsan.com: updated to apply; fixed checkpatch warnings]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index a89214ee4694..98cde62c0cac 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -387,6 +387,49 @@ static int _set_softreset(struct omap_hwmod *oh, u32 *v)
 	return 0;
 }
 
+/**
+ * _set_dmadisable: set OCP_SYSCONFIG.DMADISABLE bit in @v
+ * @oh: struct omap_hwmod *
+ *
+ * The DMADISABLE bit is a semi-automatic bit present in sysconfig register
+ * of some modules. When the DMA must perform read/write accesses, the
+ * DMADISABLE bit is cleared by the hardware. But when the DMA must stop
+ * for power management, software must set the DMADISABLE bit back to 1.
+ *
+ * Set the DMADISABLE bit in @v for hwmod @oh.  Returns -EINVAL upon
+ * error or 0 upon success.
+ */
+static int _set_dmadisable(struct omap_hwmod *oh)
+{
+	u32 v;
+	u32 dmadisable_mask;
+
+	if (!oh->class->sysc ||
+	    !(oh->class->sysc->sysc_flags & SYSC_HAS_DMADISABLE))
+		return -EINVAL;
+
+	if (!oh->class->sysc->sysc_fields) {
+		WARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);
+		return -EINVAL;
+	}
+
+	/* clocks must be on for this operation */
+	if (oh->_state != _HWMOD_STATE_ENABLED) {
+		pr_warn("omap_hwmod: %s: dma can be disabled only from enabled state\n", oh->name);
+		return -EINVAL;
+	}
+
+	pr_debug("omap_hwmod: %s: setting DMADISABLE\n", oh->name);
+
+	v = oh->_sysc_cache;
+	dmadisable_mask =
+		(0x1 << oh->class->sysc->sysc_fields->dmadisable_shift);
+	v |= dmadisable_mask;
+	_write_sysconfig(v, oh);
+
+	return 0;
+}
+
 /**
  * _set_module_autoidle: set the OCP_SYSCONFIG AUTOIDLE field in @v
  * @oh: struct omap_hwmod *
@@ -1698,11 +1741,17 @@ static int _ocp_softreset(struct omap_hwmod *oh)
  * therefore have no OCP header registers to access.  Others (like the
  * IVA) have idiosyncratic reset sequences.  So for these relatively
  * rare cases, custom reset code can be supplied in the struct
- * omap_hwmod_class .reset function pointer.  Passes along the return
- * value from either _ocp_softreset() or the custom reset function -
- * these must return -EINVAL if the hwmod cannot be reset this way or
- * if the hwmod is in the wrong state, -ETIMEDOUT if the module did
- * not reset in time, or 0 upon success.
+ * omap_hwmod_class .reset function pointer.
+ *
+ * _set_dmadisable() is called to set the DMADISABLE bit so that it
+ * does not prevent idling of the system. This is necessary for cases
+ * where ROMCODE/BOOTLOADER uses dma and transfers control to the
+ * kernel without disabling dma.
+ *
+ * Passes along the return value from either _ocp_softreset() or the
+ * custom reset function - these must return -EINVAL if the hwmod
+ * cannot be reset this way or if the hwmod is in the wrong state,
+ * -ETIMEDOUT if the module did not reset in time, or 0 upon success.
  */
 static int _reset(struct omap_hwmod *oh)
 {
@@ -1724,6 +1773,8 @@ static int _reset(struct omap_hwmod *oh)
 		}
 	}
 
+	_set_dmadisable(oh);
+
 	/*
 	 * OCP_SYSCONFIG bits need to be reprogrammed after a
 	 * softreset.  The _enable() function should be split to avoid

commit bed9d1bb4ed8c9bdaca77d31a2562c3a9dae43a7
Author: Tarun Kanti DebBarma <tarun.kanti@ti.com>
Date:   Wed Jul 4 05:00:48 2012 -0600

    ARM: OMAP2+: hwmod: add omap_hwmod_get_main_clk() API
    
    Add an API to get main clock name associated with a given @oh.
    This will avoid the need to construct fclk names during early
    initialization in order to get fclk handle using clk_get().
    
    Signed-off-by: Tarun Kanti DebBarma <tarun.kanti@ti.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 773193670ea2..a89214ee4694 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3401,3 +3401,18 @@ int omap_hwmod_pad_route_irq(struct omap_hwmod *oh, int pad_idx, int irq_idx)
 
 	return 0;
 }
+
+/**
+ * omap_hwmod_get_main_clk - get pointer to main clock name
+ * @oh: struct omap_hwmod *
+ *
+ * Returns the main clock name assocated with @oh upon success,
+ * or NULL if @oh is NULL.
+ */
+const char *omap_hwmod_get_main_clk(struct omap_hwmod *oh)
+{
+	if (!oh)
+		return NULL;
+
+	return oh->main_clk;
+}

commit 472fd5401561f94698f4c8f9dbbbfbf76ab55626
Merge: 5f6129675bf1 19f3a98d82ca
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Jun 28 05:47:01 2012 -0700

    Merge branch 'cleanup-hwmod' into cleanup
    
    Conflicts:
            arch/arm/mach-omap2/dsp.c

commit 9a17d88e0586bb7189655f8f99484a872a474626
Merge: 6b16351acbd4 fafcdd53220f
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Jun 25 07:41:17 2012 -0700

    Merge tag 'omap-devel-c-for-3.6' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into devel-pm
    
    Reimplement the OMAP PRCM I/O chain code.  Needed for I/O wakeups to
    work correctly.
    
    Conflicts:
            arch/arm/mach-omap2/prm2xxx_3xxx.c

commit 5165882a387325ac0df2f30c62ea710cfa328b54
Author: Vishwanath BS <vishwanath.bs@ti.com>
Date:   Fri Jun 22 08:40:04 2012 -0600

    ARM: OMAP3PLUS: hwmod: reconfigure IO Daisychain during hwmod mux
    
    IO Daisychain feature has to be triggered whenever there is a change in
    device's mux configuration (See section 3.9.4 in OMAP4 Public TRM vP).
    
    Now devices can idle independent of the powerdomain, there can be a
    window where device is idled and corresponding powerdomain can be
    ON/INACTIVE state. In such situations, since both module wake up is
    enabled at padlevel as well as io daisychain sequence is triggered,
    there will be 2 PRCM interrupts (Module async wake up via swakeup and
    IO Pad interrupt). But as PRCM Interrupt handler clears the Module
    Padlevel WKST bit in the first interrupt, module specific interrupt
    handler will not triggered for the second time
    
    Also look at detailed explanation given by Rajendra at
    http://www.spinics.net/lists/linux-serial/msg04480.html
    
    Signed-off-by: Vishwanath BS <vishwanath.bs@ti.com>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Reviewed-by: Rajendra Nayak <rnayak@ti.com>
    [paul@pwsan.com: remove dependency on pm.c & pm.h; add kerneldoc]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index bf86f7e8f91f..6d6c31a10a1b 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -153,6 +153,7 @@
 #include "prm44xx.h"
 #include "prminst44xx.h"
 #include "mux.h"
+#include "pm.h"
 
 /* Maximum microseconds to wait for OMAP module to softreset */
 #define MAX_MODULE_SOFTRESET_WAIT	10000
@@ -172,6 +173,9 @@ static LIST_HEAD(omap_hwmod_list);
 /* mpu_oh: used to add/remove MPU initiator from sleepdep list */
 static struct omap_hwmod *mpu_oh;
 
+/* io_chain_lock: used to serialize reconfigurations of the I/O chain */
+static DEFINE_SPINLOCK(io_chain_lock);
+
 /*
  * linkspace: ptr to a buffer that struct omap_hwmod_link records are
  * allocated from - used to reduce the number of small memory
@@ -1737,6 +1741,32 @@ static int _reset(struct omap_hwmod *oh)
 	return r;
 }
 
+/**
+ * _reconfigure_io_chain - clear any I/O chain wakeups and reconfigure chain
+ *
+ * Call the appropriate PRM function to clear any logged I/O chain
+ * wakeups and to reconfigure the chain.  This apparently needs to be
+ * done upon every mux change.  Since hwmods can be concurrently
+ * enabled and idled, hold a spinlock around the I/O chain
+ * reconfiguration sequence.  No return value.
+ *
+ * XXX When the PRM code is moved to drivers, this function can be removed,
+ * as the PRM infrastructure should abstract this.
+ */
+static void _reconfigure_io_chain(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&io_chain_lock, flags);
+
+	if (cpu_is_omap34xx() && omap3_has_io_chain_ctrl())
+		omap3xxx_prm_reconfigure_io_chain();
+	else if (cpu_is_omap44xx())
+		omap44xx_prm_reconfigure_io_chain();
+
+	spin_unlock_irqrestore(&io_chain_lock, flags);
+}
+
 /**
  * _enable - enable an omap_hwmod
  * @oh: struct omap_hwmod *
@@ -1793,8 +1823,10 @@ static int _enable(struct omap_hwmod *oh)
 	/* Mux pins for device runtime if populated */
 	if (oh->mux && (!oh->mux->enabled ||
 			((oh->_state == _HWMOD_STATE_IDLE) &&
-			 oh->mux->pads_dynamic)))
+			 oh->mux->pads_dynamic))) {
 		omap_hwmod_mux(oh->mux, _HWMOD_STATE_ENABLED);
+		_reconfigure_io_chain();
+	}
 
 	_add_initiator_dep(oh, mpu_oh);
 
@@ -1883,8 +1915,10 @@ static int _idle(struct omap_hwmod *oh)
 		clkdm_hwmod_disable(oh->clkdm, oh);
 
 	/* Mux pins for device idle if populated */
-	if (oh->mux && oh->mux->pads_dynamic)
+	if (oh->mux && oh->mux->pads_dynamic) {
 		omap_hwmod_mux(oh->mux, _HWMOD_STATE_IDLE);
+		_reconfigure_io_chain();
+	}
 
 	oh->_state = _HWMOD_STATE_IDLE;
 

commit 561038f0a8aa1de272a2ac5dad24cc8246d9f496
Author: Djamil Elaidi <d-elaidi@ti.com>
Date:   Sun Jun 17 11:57:51 2012 -0600

    ARM: OMAP4+: hwmod: fix issue causing IPs not going back to Smart-Standby
    
    If an IP is configured in Smart-Standby-Wakeup, when disabling wakeup feature the
    IP will not go back to Smart-Standby, but will remain in Smart-Standby-Wakeup.
    
    Signed-off-by: Djamil Elaidi <d-elaidi@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index bf86f7e8f91f..773193670ea2 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -530,7 +530,7 @@ static int _disable_wakeup(struct omap_hwmod *oh, u32 *v)
 	if (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP)
 		_set_slave_idlemode(oh, HWMOD_IDLEMODE_SMART, v);
 	if (oh->class->sysc->idlemodes & MSTANDBY_SMART_WKUP)
-		_set_master_standbymode(oh, HWMOD_IDLEMODE_SMART_WKUP, v);
+		_set_master_standbymode(oh, HWMOD_IDLEMODE_SMART, v);
 
 	/* XXX test pwrdm_get_wken for this hwmod's subsystem */
 

commit 07b3a13957aa250ff5b5409b8ed756b113544112
Merge: d44f42e6af48 3d3635c4d77a 0a179eaa436e 7039154bb218 868c157df972
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Jun 20 20:11:36 2012 -0600

    Merge branches 'clock_cleanup_misc_3.6', 'control_clean_dspbridge_writes_cleanup_3.6', 'hwmod_soc_conditional_cleanup_3.6', 'mcbsp_clock_aliases_cleanup_3.6' and 'remove_clkdm_requirement_from_hwmod_3.6' into omap_cleanup_a_3.6
    
    Conflicts:
            arch/arm/mach-omap2/omap_hwmod.c

commit 868c157df9721675c19729eed2c96bac6c3f1d01
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Jun 19 15:01:02 2012 -0600

    ARM: OMAP2+: hwmod: remove prm_clkdm, cm_clkdm; allow hwmods to have no clockdomain
    
    Remove prm_clkdm and cm_clkdm and allow hwmods to have no clockdomain.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index bf86f7e8f91f..32a5e08ffb9b 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -810,7 +810,7 @@ static int _omap4_wait_target_disable(struct omap_hwmod *oh)
 	if (!cpu_is_omap44xx())
 		return 0;
 
-	if (!oh)
+	if (!oh || !oh->clkdm)
 		return -EINVAL;
 
 	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
@@ -1285,23 +1285,22 @@ static struct omap_hwmod *_lookup(const char *name)
 
 	return oh;
 }
+
 /**
  * _init_clkdm - look up a clockdomain name, store pointer in omap_hwmod
  * @oh: struct omap_hwmod *
  *
  * Convert a clockdomain name stored in a struct omap_hwmod into a
  * clockdomain pointer, and save it into the struct omap_hwmod.
- * return -EINVAL if clkdm_name does not exist or if the lookup failed.
+ * Return -EINVAL if the clkdm_name lookup failed.
  */
 static int _init_clkdm(struct omap_hwmod *oh)
 {
 	if (cpu_is_omap24xx() || cpu_is_omap34xx())
 		return 0;
 
-	if (!oh->clkdm_name) {
-		pr_warning("omap_hwmod: %s: no clkdm_name\n", oh->name);
-		return -EINVAL;
-	}
+	if (!oh->clkdm_name)
+		return 0;
 
 	oh->clkdm = clkdm_lookup(oh->clkdm_name);
 	if (!oh->clkdm) {
@@ -1447,16 +1446,20 @@ static int _assert_hardreset(struct omap_hwmod *oh, const char *name)
 	if (IS_ERR_VALUE(ret))
 		return ret;
 
-	if (cpu_is_omap24xx() || cpu_is_omap34xx())
+	if (cpu_is_omap24xx() || cpu_is_omap34xx()) {
 		return omap2_prm_assert_hardreset(oh->prcm.omap2.module_offs,
 						  ohri.rst_shift);
-	else if (cpu_is_omap44xx())
+	} else if (cpu_is_omap44xx()) {
+		if (!oh->clkdm)
+			return -EINVAL;
+
 		return omap4_prminst_assert_hardreset(ohri.rst_shift,
 				  oh->clkdm->pwrdm.ptr->prcm_partition,
 				  oh->clkdm->pwrdm.ptr->prcm_offs,
 				  oh->prcm.omap4.rstctrl_offs);
-	else
+	} else {
 		return -EINVAL;
+	}
 }
 
 /**
@@ -1489,6 +1492,10 @@ static int _deassert_hardreset(struct omap_hwmod *oh, const char *name)
 		if (ohri.st_shift)
 			pr_err("omap_hwmod: %s: %s: hwmod data error: OMAP4 does not support st_shift\n",
 			       oh->name, name);
+
+		if (!oh->clkdm)
+			return -EINVAL;
+
 		ret = omap4_prminst_deassert_hardreset(ohri.rst_shift,
 				  oh->clkdm->pwrdm.ptr->prcm_partition,
 				  oh->clkdm->pwrdm.ptr->prcm_offs,
@@ -1527,6 +1534,9 @@ static int _read_hardreset(struct omap_hwmod *oh, const char *name)
 		return omap2_prm_is_hardreset_asserted(oh->prcm.omap2.module_offs,
 						       ohri.st_shift);
 	} else if (cpu_is_omap44xx()) {
+		if (!oh->clkdm)
+			return -EINVAL;
+
 		return omap4_prminst_is_hardreset_asserted(ohri.rst_shift,
 				  oh->clkdm->pwrdm.ptr->prcm_partition,
 				  oh->clkdm->pwrdm.ptr->prcm_offs,

commit 0a179eaa436e58ed9fd00e09cdf01f1b3604d9a1
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Jun 18 12:12:25 2012 -0600

    ARM: OMAP2+: hwmod: use init-time function pointer for _init_clkdm
    
    Rather than use runtime cpu_is* checking inside _init_clkdm, initialize
    SoC specific function pointer at init time.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>
    [paul@pwsan.com: convert to use soc_ops function pointers; remove second para
     from commit message since soc_ops function pointers are now set during hwmod
     layer init]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 93cb96dbb543..acc616c02e14 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -185,6 +185,7 @@ struct omap_hwmod_soc_ops {
 				  struct omap_hwmod_rst_info *ohri);
 	int (*is_hardreset_asserted)(struct omap_hwmod *oh,
 				     struct omap_hwmod_rst_info *ohri);
+	int (*init_clkdm)(struct omap_hwmod *oh);
 };
 
 /* soc_ops: adapts the omap_hwmod code to the currently-booted SoC */
@@ -1315,9 +1316,6 @@ static struct omap_hwmod *_lookup(const char *name)
  */
 static int _init_clkdm(struct omap_hwmod *oh)
 {
-	if (cpu_is_omap24xx() || cpu_is_omap34xx())
-		return 0;
-
 	if (!oh->clkdm_name) {
 		pr_warning("omap_hwmod: %s: no clkdm_name\n", oh->name);
 		return -EINVAL;
@@ -1358,7 +1356,8 @@ static int _init_clocks(struct omap_hwmod *oh, void *data)
 	ret |= _init_main_clk(oh);
 	ret |= _init_interface_clks(oh);
 	ret |= _init_opt_clks(oh);
-	ret |= _init_clkdm(oh);
+	if (soc_ops.init_clkdm)
+		ret |= soc_ops.init_clkdm(oh);
 
 	if (!ret)
 		oh->_state = _HWMOD_STATE_CLKS_INITED;
@@ -3569,6 +3568,7 @@ void __init omap_hwmod_init(void)
 		soc_ops.assert_hardreset = _omap4_assert_hardreset;
 		soc_ops.deassert_hardreset = _omap4_deassert_hardreset;
 		soc_ops.is_hardreset_asserted = _omap4_is_hardreset_asserted;
+		soc_ops.init_clkdm = _init_clkdm;
 	} else {
 		WARN(1, "omap_hwmod: unknown SoC type\n");
 	}

commit b8249cf2d2b16de9582d3cbaa98c16c32c624d8a
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Jun 18 12:12:24 2012 -0600

    ARM: OMAP2+: hwmod: use init-time function pointer for hardreset
    
    Rather than using cpu_is* checking at runtime, initialize SoC specific
    function pointers for the various hard reset functions at init time.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>
    [paul@pwsan.com: convert to use soc_ops function pointers; add kerneldoc]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index d1f784cd5f0f..93cb96dbb543 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -179,6 +179,12 @@ struct omap_hwmod_soc_ops {
 	void (*enable_module)(struct omap_hwmod *oh);
 	int (*disable_module)(struct omap_hwmod *oh);
 	int (*wait_target_ready)(struct omap_hwmod *oh);
+	int (*assert_hardreset)(struct omap_hwmod *oh,
+				struct omap_hwmod_rst_info *ohri);
+	int (*deassert_hardreset)(struct omap_hwmod *oh,
+				  struct omap_hwmod_rst_info *ohri);
+	int (*is_hardreset_asserted)(struct omap_hwmod *oh,
+				     struct omap_hwmod_rst_info *ohri);
 };
 
 /* soc_ops: adapts the omap_hwmod code to the currently-booted SoC */
@@ -1398,32 +1404,31 @@ static u8 _lookup_hardreset(struct omap_hwmod *oh, const char *name,
  * @oh: struct omap_hwmod *
  * @name: name of the reset line to lookup and assert
  *
- * Some IP like dsp, ipu or iva contain processor that require
- * an HW reset line to be assert / deassert in order to enable fully
- * the IP.
+ * Some IP like dsp, ipu or iva contain processor that require an HW
+ * reset line to be assert / deassert in order to enable fully the IP.
+ * Returns -EINVAL if @oh is null, -ENOSYS if we have no way of
+ * asserting the hardreset line on the currently-booted SoC, or passes
+ * along the return value from _lookup_hardreset() or the SoC's
+ * assert_hardreset code.
  */
 static int _assert_hardreset(struct omap_hwmod *oh, const char *name)
 {
 	struct omap_hwmod_rst_info ohri;
-	u8 ret;
+	u8 ret = -EINVAL;
 
 	if (!oh)
 		return -EINVAL;
 
+	if (!soc_ops.assert_hardreset)
+		return -ENOSYS;
+
 	ret = _lookup_hardreset(oh, name, &ohri);
 	if (IS_ERR_VALUE(ret))
 		return ret;
 
-	if (cpu_is_omap24xx() || cpu_is_omap34xx())
-		return omap2_prm_assert_hardreset(oh->prcm.omap2.module_offs,
-						  ohri.rst_shift);
-	else if (cpu_is_omap44xx())
-		return omap4_prminst_assert_hardreset(ohri.rst_shift,
-				  oh->clkdm->pwrdm.ptr->prcm_partition,
-				  oh->clkdm->pwrdm.ptr->prcm_offs,
-				  oh->prcm.omap4.rstctrl_offs);
-	else
-		return -EINVAL;
+	ret = soc_ops.assert_hardreset(oh, &ohri);
+
+	return ret;
 }
 
 /**
@@ -1432,38 +1437,29 @@ static int _assert_hardreset(struct omap_hwmod *oh, const char *name)
  * @oh: struct omap_hwmod *
  * @name: name of the reset line to look up and deassert
  *
- * Some IP like dsp, ipu or iva contain processor that require
- * an HW reset line to be assert / deassert in order to enable fully
- * the IP.
+ * Some IP like dsp, ipu or iva contain processor that require an HW
+ * reset line to be assert / deassert in order to enable fully the IP.
+ * Returns -EINVAL if @oh is null, -ENOSYS if we have no way of
+ * deasserting the hardreset line on the currently-booted SoC, or passes
+ * along the return value from _lookup_hardreset() or the SoC's
+ * deassert_hardreset code.
  */
 static int _deassert_hardreset(struct omap_hwmod *oh, const char *name)
 {
 	struct omap_hwmod_rst_info ohri;
-	int ret;
+	int ret = -EINVAL;
 
 	if (!oh)
 		return -EINVAL;
 
+	if (!soc_ops.deassert_hardreset)
+		return -ENOSYS;
+
 	ret = _lookup_hardreset(oh, name, &ohri);
 	if (IS_ERR_VALUE(ret))
 		return ret;
 
-	if (cpu_is_omap24xx() || cpu_is_omap34xx()) {
-		ret = omap2_prm_deassert_hardreset(oh->prcm.omap2.module_offs,
-						   ohri.rst_shift,
-						   ohri.st_shift);
-	} else if (cpu_is_omap44xx()) {
-		if (ohri.st_shift)
-			pr_err("omap_hwmod: %s: %s: hwmod data error: OMAP4 does not support st_shift\n",
-			       oh->name, name);
-		ret = omap4_prminst_deassert_hardreset(ohri.rst_shift,
-				  oh->clkdm->pwrdm.ptr->prcm_partition,
-				  oh->clkdm->pwrdm.ptr->prcm_offs,
-				  oh->prcm.omap4.rstctrl_offs);
-	} else {
-		return -EINVAL;
-	}
-
+	ret = soc_ops.deassert_hardreset(oh, &ohri);
 	if (ret == -EBUSY)
 		pr_warning("omap_hwmod: %s: failed to hardreset\n", oh->name);
 
@@ -1476,31 +1472,28 @@ static int _deassert_hardreset(struct omap_hwmod *oh, const char *name)
  * @oh: struct omap_hwmod *
  * @name: name of the reset line to look up and read
  *
- * Return the state of the reset line.
+ * Return the state of the reset line.  Returns -EINVAL if @oh is
+ * null, -ENOSYS if we have no way of reading the hardreset line
+ * status on the currently-booted SoC, or passes along the return
+ * value from _lookup_hardreset() or the SoC's is_hardreset_asserted
+ * code.
  */
 static int _read_hardreset(struct omap_hwmod *oh, const char *name)
 {
 	struct omap_hwmod_rst_info ohri;
-	u8 ret;
+	u8 ret = -EINVAL;
 
 	if (!oh)
 		return -EINVAL;
 
+	if (!soc_ops.is_hardreset_asserted)
+		return -ENOSYS;
+
 	ret = _lookup_hardreset(oh, name, &ohri);
 	if (IS_ERR_VALUE(ret))
 		return ret;
 
-	if (cpu_is_omap24xx() || cpu_is_omap34xx()) {
-		return omap2_prm_is_hardreset_asserted(oh->prcm.omap2.module_offs,
-						       ohri.st_shift);
-	} else if (cpu_is_omap44xx()) {
-		return omap4_prminst_is_hardreset_asserted(ohri.rst_shift,
-				  oh->clkdm->pwrdm.ptr->prcm_partition,
-				  oh->clkdm->pwrdm.ptr->prcm_offs,
-				  oh->prcm.omap4.rstctrl_offs);
-	} else {
-		return -EINVAL;
-	}
+	return soc_ops.is_hardreset_asserted(oh, &ohri);
 }
 
 /**
@@ -2455,6 +2448,129 @@ static int _omap4_wait_target_ready(struct omap_hwmod *oh)
 					      oh->prcm.omap4.clkctrl_offs);
 }
 
+/**
+ * _omap2_assert_hardreset - call OMAP2 PRM hardreset fn with hwmod args
+ * @oh: struct omap_hwmod * to assert hardreset
+ * @ohri: hardreset line data
+ *
+ * Call omap2_prm_assert_hardreset() with parameters extracted from
+ * the hwmod @oh and the hardreset line data @ohri.  Only intended for
+ * use as an soc_ops function pointer.  Passes along the return value
+ * from omap2_prm_assert_hardreset().  XXX This function is scheduled
+ * for removal when the PRM code is moved into drivers/.
+ */
+static int _omap2_assert_hardreset(struct omap_hwmod *oh,
+				   struct omap_hwmod_rst_info *ohri)
+{
+	return omap2_prm_assert_hardreset(oh->prcm.omap2.module_offs,
+					  ohri->rst_shift);
+}
+
+/**
+ * _omap2_deassert_hardreset - call OMAP2 PRM hardreset fn with hwmod args
+ * @oh: struct omap_hwmod * to deassert hardreset
+ * @ohri: hardreset line data
+ *
+ * Call omap2_prm_deassert_hardreset() with parameters extracted from
+ * the hwmod @oh and the hardreset line data @ohri.  Only intended for
+ * use as an soc_ops function pointer.  Passes along the return value
+ * from omap2_prm_deassert_hardreset().  XXX This function is
+ * scheduled for removal when the PRM code is moved into drivers/.
+ */
+static int _omap2_deassert_hardreset(struct omap_hwmod *oh,
+				     struct omap_hwmod_rst_info *ohri)
+{
+	return omap2_prm_deassert_hardreset(oh->prcm.omap2.module_offs,
+					    ohri->rst_shift,
+					    ohri->st_shift);
+}
+
+/**
+ * _omap2_is_hardreset_asserted - call OMAP2 PRM hardreset fn with hwmod args
+ * @oh: struct omap_hwmod * to test hardreset
+ * @ohri: hardreset line data
+ *
+ * Call omap2_prm_is_hardreset_asserted() with parameters extracted
+ * from the hwmod @oh and the hardreset line data @ohri.  Only
+ * intended for use as an soc_ops function pointer.  Passes along the
+ * return value from omap2_prm_is_hardreset_asserted().  XXX This
+ * function is scheduled for removal when the PRM code is moved into
+ * drivers/.
+ */
+static int _omap2_is_hardreset_asserted(struct omap_hwmod *oh,
+					struct omap_hwmod_rst_info *ohri)
+{
+	return omap2_prm_is_hardreset_asserted(oh->prcm.omap2.module_offs,
+					       ohri->st_shift);
+}
+
+/**
+ * _omap4_assert_hardreset - call OMAP4 PRM hardreset fn with hwmod args
+ * @oh: struct omap_hwmod * to assert hardreset
+ * @ohri: hardreset line data
+ *
+ * Call omap4_prminst_assert_hardreset() with parameters extracted
+ * from the hwmod @oh and the hardreset line data @ohri.  Only
+ * intended for use as an soc_ops function pointer.  Passes along the
+ * return value from omap4_prminst_assert_hardreset().  XXX This
+ * function is scheduled for removal when the PRM code is moved into
+ * drivers/.
+ */
+static int _omap4_assert_hardreset(struct omap_hwmod *oh,
+				   struct omap_hwmod_rst_info *ohri)
+
+{
+	return omap4_prminst_assert_hardreset(ohri->rst_shift,
+				oh->clkdm->pwrdm.ptr->prcm_partition,
+				oh->clkdm->pwrdm.ptr->prcm_offs,
+				oh->prcm.omap4.rstctrl_offs);
+}
+
+/**
+ * _omap4_deassert_hardreset - call OMAP4 PRM hardreset fn with hwmod args
+ * @oh: struct omap_hwmod * to deassert hardreset
+ * @ohri: hardreset line data
+ *
+ * Call omap4_prminst_deassert_hardreset() with parameters extracted
+ * from the hwmod @oh and the hardreset line data @ohri.  Only
+ * intended for use as an soc_ops function pointer.  Passes along the
+ * return value from omap4_prminst_deassert_hardreset().  XXX This
+ * function is scheduled for removal when the PRM code is moved into
+ * drivers/.
+ */
+static int _omap4_deassert_hardreset(struct omap_hwmod *oh,
+				     struct omap_hwmod_rst_info *ohri)
+{
+	if (ohri->st_shift)
+		pr_err("omap_hwmod: %s: %s: hwmod data error: OMAP4 does not support st_shift\n",
+		       oh->name, ohri->name);
+	return omap4_prminst_deassert_hardreset(ohri->rst_shift,
+				oh->clkdm->pwrdm.ptr->prcm_partition,
+				oh->clkdm->pwrdm.ptr->prcm_offs,
+				oh->prcm.omap4.rstctrl_offs);
+}
+
+/**
+ * _omap4_is_hardreset_asserted - call OMAP4 PRM hardreset fn with hwmod args
+ * @oh: struct omap_hwmod * to test hardreset
+ * @ohri: hardreset line data
+ *
+ * Call omap4_prminst_is_hardreset_asserted() with parameters
+ * extracted from the hwmod @oh and the hardreset line data @ohri.
+ * Only intended for use as an soc_ops function pointer.  Passes along
+ * the return value from omap4_prminst_is_hardreset_asserted().  XXX
+ * This function is scheduled for removal when the PRM code is moved
+ * into drivers/.
+ */
+static int _omap4_is_hardreset_asserted(struct omap_hwmod *oh,
+					struct omap_hwmod_rst_info *ohri)
+{
+	return omap4_prminst_is_hardreset_asserted(ohri->rst_shift,
+				oh->clkdm->pwrdm.ptr->prcm_partition,
+				oh->clkdm->pwrdm.ptr->prcm_offs,
+				oh->prcm.omap4.rstctrl_offs);
+}
+
 /* Public functions */
 
 u32 omap_hwmod_read(struct omap_hwmod *oh, u16 reg_offs)
@@ -3443,10 +3559,16 @@ void __init omap_hwmod_init(void)
 {
 	if (cpu_is_omap24xx() || cpu_is_omap34xx()) {
 		soc_ops.wait_target_ready = _omap2_wait_target_ready;
+		soc_ops.assert_hardreset = _omap2_assert_hardreset;
+		soc_ops.deassert_hardreset = _omap2_deassert_hardreset;
+		soc_ops.is_hardreset_asserted = _omap2_is_hardreset_asserted;
 	} else if (cpu_is_omap44xx()) {
 		soc_ops.enable_module = _omap4_enable_module;
 		soc_ops.disable_module = _omap4_disable_module;
 		soc_ops.wait_target_ready = _omap4_wait_target_ready;
+		soc_ops.assert_hardreset = _omap4_assert_hardreset;
+		soc_ops.deassert_hardreset = _omap4_deassert_hardreset;
+		soc_ops.is_hardreset_asserted = _omap4_is_hardreset_asserted;
 	} else {
 		WARN(1, "omap_hwmod: unknown SoC type\n");
 	}

commit 8f6aa8ee114fb52a425e247e27e271ee35d7d3b3
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Jun 18 12:12:24 2012 -0600

    ARM: OMAP2+: hwmod: use init-time function pointer for wait_target_ready
    
    Rather than using cpu_is* checking at runtime, initialize an SoC specific
    function pointer for wait_target_ready().
    
    While here, downgrade the BUG() to a WARN_ON() so it gives a noisy
    warning instead of causing a kernel panic.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>
    [paul@pwsan.com: convert to use soc_ops function pointers; add kerneldoc;
     move soc_ops functions to their own section in the code; integrated
     the _wait_target_ready() function with the OMAP2/OMAP4 variants;
     renamed the wait_module_ready field to wait_target_ready]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 2b845836f7dc..d1f784cd5f0f 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -178,6 +178,7 @@
 struct omap_hwmod_soc_ops {
 	void (*enable_module)(struct omap_hwmod *oh);
 	int (*disable_module)(struct omap_hwmod *oh);
+	int (*wait_target_ready)(struct omap_hwmod *oh);
 };
 
 /* soc_ops: adapts the omap_hwmod code to the currently-booted SoC */
@@ -1361,53 +1362,6 @@ static int _init_clocks(struct omap_hwmod *oh, void *data)
 	return ret;
 }
 
-/**
- * _wait_target_ready - wait for a module to leave slave idle
- * @oh: struct omap_hwmod *
- *
- * Wait for a module @oh to leave slave idle.  Returns 0 if the module
- * does not have an IDLEST bit or if the module successfully leaves
- * slave idle; otherwise, pass along the return value of the
- * appropriate *_cm*_wait_module_ready() function.
- */
-static int _wait_target_ready(struct omap_hwmod *oh)
-{
-	struct omap_hwmod_ocp_if *os;
-	int ret;
-
-	if (!oh)
-		return -EINVAL;
-
-	if (oh->flags & HWMOD_NO_IDLEST)
-		return 0;
-
-	os = _find_mpu_rt_port(oh);
-	if (!os)
-		return 0;
-
-	/* XXX check module SIDLEMODE */
-
-	/* XXX check clock enable states */
-
-	if (cpu_is_omap24xx() || cpu_is_omap34xx()) {
-		ret = omap2_cm_wait_module_ready(oh->prcm.omap2.module_offs,
-						 oh->prcm.omap2.idlest_reg_id,
-						 oh->prcm.omap2.idlest_idle_bit);
-	} else if (cpu_is_omap44xx()) {
-		if (!oh->clkdm)
-			return -EINVAL;
-
-		ret = omap4_cminst_wait_module_ready(oh->clkdm->prcm_partition,
-						     oh->clkdm->cm_inst,
-						     oh->clkdm->clkdm_offs,
-						     oh->prcm.omap4.clkctrl_offs);
-	} else {
-		BUG();
-	};
-
-	return ret;
-}
-
 /**
  * _lookup_hardreset - fill register bit info for this hwmod/reset line
  * @oh: struct omap_hwmod *
@@ -1826,7 +1780,8 @@ static int _enable(struct omap_hwmod *oh)
 	if (soc_ops.enable_module)
 		soc_ops.enable_module(oh);
 
-	r = _wait_target_ready(oh);
+	r = (soc_ops.wait_target_ready) ? soc_ops.wait_target_ready(oh) :
+		-EINVAL;
 	if (!r) {
 		/*
 		 * Set the clockdomain to HW_AUTO only if the target is ready,
@@ -2443,6 +2398,63 @@ static int __init _alloc_linkspace(struct omap_hwmod_ocp_if **ois)
 	return 0;
 }
 
+/* Static functions intended only for use in soc_ops field function pointers */
+
+/**
+ * _omap2_wait_target_ready - wait for a module to leave slave idle
+ * @oh: struct omap_hwmod *
+ *
+ * Wait for a module @oh to leave slave idle.  Returns 0 if the module
+ * does not have an IDLEST bit or if the module successfully leaves
+ * slave idle; otherwise, pass along the return value of the
+ * appropriate *_cm*_wait_module_ready() function.
+ */
+static int _omap2_wait_target_ready(struct omap_hwmod *oh)
+{
+	if (!oh)
+		return -EINVAL;
+
+	if (oh->flags & HWMOD_NO_IDLEST)
+		return 0;
+
+	if (!_find_mpu_rt_port(oh))
+		return 0;
+
+	/* XXX check module SIDLEMODE, hardreset status, enabled clocks */
+
+	return omap2_cm_wait_module_ready(oh->prcm.omap2.module_offs,
+					  oh->prcm.omap2.idlest_reg_id,
+					  oh->prcm.omap2.idlest_idle_bit);
+}
+
+/**
+ * _omap4_wait_target_ready - wait for a module to leave slave idle
+ * @oh: struct omap_hwmod *
+ *
+ * Wait for a module @oh to leave slave idle.  Returns 0 if the module
+ * does not have an IDLEST bit or if the module successfully leaves
+ * slave idle; otherwise, pass along the return value of the
+ * appropriate *_cm*_wait_module_ready() function.
+ */
+static int _omap4_wait_target_ready(struct omap_hwmod *oh)
+{
+	if (!oh || !oh->clkdm)
+		return -EINVAL;
+
+	if (oh->flags & HWMOD_NO_IDLEST)
+		return 0;
+
+	if (!_find_mpu_rt_port(oh))
+		return 0;
+
+	/* XXX check module SIDLEMODE, hardreset status */
+
+	return omap4_cminst_wait_module_ready(oh->clkdm->prcm_partition,
+					      oh->clkdm->cm_inst,
+					      oh->clkdm->clkdm_offs,
+					      oh->prcm.omap4.clkctrl_offs);
+}
+
 /* Public functions */
 
 u32 omap_hwmod_read(struct omap_hwmod *oh, u16 reg_offs)
@@ -3429,9 +3441,14 @@ int omap_hwmod_pad_route_irq(struct omap_hwmod *oh, int pad_idx, int irq_idx)
  */
 void __init omap_hwmod_init(void)
 {
-	if (cpu_is_omap44xx()) {
+	if (cpu_is_omap24xx() || cpu_is_omap34xx()) {
+		soc_ops.wait_target_ready = _omap2_wait_target_ready;
+	} else if (cpu_is_omap44xx()) {
 		soc_ops.enable_module = _omap4_enable_module;
 		soc_ops.disable_module = _omap4_disable_module;
+		soc_ops.wait_target_ready = _omap4_wait_target_ready;
+	} else {
+		WARN(1, "omap_hwmod: unknown SoC type\n");
 	}
 
 	inited = true;

commit baa2607f56f1589eb21c01fe16aa5f5c3f9dad31
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Jun 18 12:12:24 2012 -0600

    ARM: OMAP4: hwmod: drop extra cpu_is check from _wait_target_disable()
    
    _omap4_wait_target_disable() is called only from inside _omap4_disable_module()
    which is already protected by SoC specific checks.  Remove the cpu_is check
    here.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 634a79836c64..2b845836f7dc 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -823,9 +823,6 @@ static void _omap4_enable_module(struct omap_hwmod *oh)
  */
 static int _omap4_wait_target_disable(struct omap_hwmod *oh)
 {
-	if (!cpu_is_omap44xx())
-		return 0;
-
 	if (!oh)
 		return -EINVAL;
 

commit 9ebfd285371835b1c0243d15aaacd72d5def76f8
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Jun 18 12:12:23 2012 -0600

    ARM: OMAP2+: hwmod: use init-time function ptrs for enable/disable module
    
    The enable/disable module functions are specific to SoCs with
    OMAP4-class PRCM.  Rather than use cpu_is* checks at runtime inside
    the enable/disable module functions, use cpu_is at init time to
    initialize function pointers only for SoCs that need them.
    
    NOTE: the cpu_is* check for _enable_module was different than
          the one for _disable_module, and this patch uses
          cpu_is_omap44xx() for both.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>
    [paul@pwsan.com: moved soc_ops function pointers to be per-kernel rather than
     per-hwmod since they do not vary by hwmod; added kerneldoc]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 939032a427fd..634a79836c64 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -166,6 +166,23 @@
  */
 #define LINKS_PER_OCP_IF		2
 
+/**
+ * struct omap_hwmod_soc_ops - fn ptrs for some SoC-specific operations
+ * @enable_module: function to enable a module (via MODULEMODE)
+ * @disable_module: function to disable a module (via MODULEMODE)
+ *
+ * XXX Eventually this functionality will be hidden inside the PRM/CM
+ * device drivers.  Until then, this should avoid huge blocks of cpu_is_*()
+ * conditionals in this code.
+ */
+struct omap_hwmod_soc_ops {
+	void (*enable_module)(struct omap_hwmod *oh);
+	int (*disable_module)(struct omap_hwmod *oh);
+};
+
+/* soc_ops: adapts the omap_hwmod code to the currently-booted SoC */
+static struct omap_hwmod_soc_ops soc_ops;
+
 /* omap_hwmod_list contains all registered struct omap_hwmods */
 static LIST_HEAD(omap_hwmod_list);
 
@@ -186,6 +203,9 @@ static struct omap_hwmod_link *linkspace;
  */
 static unsigned short free_ls, max_ls, ls_supp;
 
+/* inited: set to true once the hwmod code is initialized */
+static bool inited;
+
 /* Private functions */
 
 /**
@@ -779,10 +799,6 @@ static void _disable_optional_clocks(struct omap_hwmod *oh)
  */
 static void _omap4_enable_module(struct omap_hwmod *oh)
 {
-	/* The module mode does not exist prior OMAP4 */
-	if (cpu_is_omap24xx() || cpu_is_omap34xx())
-		return;
-
 	if (!oh->clkdm || !oh->prcm.omap4.modulemode)
 		return;
 
@@ -1571,10 +1587,6 @@ static int _omap4_disable_module(struct omap_hwmod *oh)
 {
 	int v;
 
-	/* The module mode does not exist prior OMAP4 */
-	if (!cpu_is_omap44xx())
-		return -EINVAL;
-
 	if (!oh->clkdm || !oh->prcm.omap4.modulemode)
 		return -EINVAL;
 
@@ -1814,7 +1826,8 @@ static int _enable(struct omap_hwmod *oh)
 	}
 
 	_enable_clocks(oh);
-	_omap4_enable_module(oh);
+	if (soc_ops.enable_module)
+		soc_ops.enable_module(oh);
 
 	r = _wait_target_ready(oh);
 	if (!r) {
@@ -1870,7 +1883,8 @@ static int _idle(struct omap_hwmod *oh)
 		_idle_sysc(oh);
 	_del_initiator_dep(oh, mpu_oh);
 
-	_omap4_disable_module(oh);
+	if (soc_ops.disable_module)
+		soc_ops.disable_module(oh);
 
 	/*
 	 * The module must be in idle mode before disabling any parents
@@ -1975,7 +1989,8 @@ static int _shutdown(struct omap_hwmod *oh)
 	if (oh->_state == _HWMOD_STATE_ENABLED) {
 		_del_initiator_dep(oh, mpu_oh);
 		/* XXX what about the other system initiators here? dma, dsp */
-		_omap4_disable_module(oh);
+		if (soc_ops.disable_module)
+			soc_ops.disable_module(oh);
 		_disable_clocks(oh);
 		if (oh->clkdm)
 			clkdm_hwmod_disable(oh->clkdm, oh);
@@ -2563,12 +2578,18 @@ int omap_hwmod_for_each(int (*fn)(struct omap_hwmod *oh, void *data),
  *
  * Intended to be called early in boot before the clock framework is
  * initialized.  If @ois is not null, will register all omap_hwmods
- * listed in @ois that are valid for this chip.  Returns 0.
+ * listed in @ois that are valid for this chip.  Returns -EINVAL if
+ * omap_hwmod_init() hasn't been called before calling this function,
+ * -ENOMEM if the link memory area can't be allocated, or 0 upon
+ * success.
  */
 int __init omap_hwmod_register_links(struct omap_hwmod_ocp_if **ois)
 {
 	int r, i;
 
+	if (!inited)
+		return -EINVAL;
+
 	if (!ois)
 		return 0;
 
@@ -3401,3 +3422,20 @@ int omap_hwmod_pad_route_irq(struct omap_hwmod *oh, int pad_idx, int irq_idx)
 
 	return 0;
 }
+
+/**
+ * omap_hwmod_init - initialize the hwmod code
+ *
+ * Sets up some function pointers needed by the hwmod code to operate on the
+ * currently-booted SoC.  Intended to be called once during kernel init
+ * before any hwmods are registered.  No return value.
+ */
+void __init omap_hwmod_init(void)
+{
+	if (cpu_is_omap44xx()) {
+		soc_ops.enable_module = _omap4_enable_module;
+		soc_ops.disable_module = _omap4_disable_module;
+	}
+
+	inited = true;
+}

commit 3d9f032724e72851c6de38d026b2417501a2f240
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Jun 18 12:12:23 2012 -0600

    ARM: OMAP4: hwmod: rename _enable_module to _omap4_enable_module()
    
    _enable_module is specific to SoCs with PRCM interfaces similar to
    that of the OMAP4, so rename it to be consistent with the
    corresponding _omap4_disable_module.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>
    [paul@pwsan.com: tweaked commit message]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index bf86f7e8f91f..939032a427fd 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -771,13 +771,13 @@ static void _disable_optional_clocks(struct omap_hwmod *oh)
 }
 
 /**
- * _enable_module - enable CLKCTRL modulemode on OMAP4
+ * _omap4_enable_module - enable CLKCTRL modulemode on OMAP4
  * @oh: struct omap_hwmod *
  *
  * Enables the PRCM module mode related to the hwmod @oh.
  * No return value.
  */
-static void _enable_module(struct omap_hwmod *oh)
+static void _omap4_enable_module(struct omap_hwmod *oh)
 {
 	/* The module mode does not exist prior OMAP4 */
 	if (cpu_is_omap24xx() || cpu_is_omap34xx())
@@ -786,8 +786,8 @@ static void _enable_module(struct omap_hwmod *oh)
 	if (!oh->clkdm || !oh->prcm.omap4.modulemode)
 		return;
 
-	pr_debug("omap_hwmod: %s: _enable_module: %d\n",
-		 oh->name, oh->prcm.omap4.modulemode);
+	pr_debug("omap_hwmod: %s: %s: %d\n",
+		 oh->name, __func__, oh->prcm.omap4.modulemode);
 
 	omap4_cminst_module_enable(oh->prcm.omap4.modulemode,
 				   oh->clkdm->prcm_partition,
@@ -1814,7 +1814,7 @@ static int _enable(struct omap_hwmod *oh)
 	}
 
 	_enable_clocks(oh);
-	_enable_module(oh);
+	_omap4_enable_module(oh);
 
 	r = _wait_target_ready(oh);
 	if (!r) {

commit 11cd4b94cb491894b8a192635abf159fc1917f4d
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Apr 19 04:04:32 2012 -0600

    ARM: OMAP: hwmod: remove code support for direct hwmod registration
    
    Now that the data has been converted to use interface registration, we
    can remove the (now unused) direct hwmod registration code.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 99b913aa0cb9..bf86f7e8f91f 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -172,12 +172,6 @@ static LIST_HEAD(omap_hwmod_list);
 /* mpu_oh: used to add/remove MPU initiator from sleepdep list */
 static struct omap_hwmod *mpu_oh;
 
-/*
- * link_registration: set to true if hwmod interfaces are being registered
- * directly; set to false if hwmods are being registered directly
- */
-static bool link_registration;
-
 /*
  * linkspace: ptr to a buffer that struct omap_hwmod_link records are
  * allocated from - used to reduce the number of small memory
@@ -195,32 +189,22 @@ static unsigned short free_ls, max_ls, ls_supp;
 /* Private functions */
 
 /**
- * _fetch_next_ocp_if - return next OCP interface in an array or list
+ * _fetch_next_ocp_if - return the next OCP interface in a list
  * @p: ptr to a ptr to the list_head inside the ocp_if to return
- * @old: ptr to an array of struct omap_hwmod_ocp_if records
- * @i: pointer to the index into the @old array
- *
- * Return a pointer to the next struct omap_hwmod_ocp_if record in a
- * sequence.  If hwmods are being registered directly, then return a
- * struct omap_hwmod_ocp_if record corresponding to the element index
- * pointed to by @i in the
- * @old array.  Otherwise, return a pointer to the struct
- * omap_hwmod_ocp_if record containing the struct list_head record pointed
- * to by @p, and set the pointer pointed to by @p to point to the next
- * struct list_head record in the list.
+ * @i: pointer to the index of the element pointed to by @p in the list
+ *
+ * Return a pointer to the struct omap_hwmod_ocp_if record
+ * containing the struct list_head pointed to by @p, and increment
+ * @p such that a future call to this routine will return the next
+ * record.
  */
 static struct omap_hwmod_ocp_if *_fetch_next_ocp_if(struct list_head **p,
-						    struct omap_hwmod_ocp_if **old,
 						    int *i)
 {
 	struct omap_hwmod_ocp_if *oi;
 
-	if (!link_registration) {
-		oi = old[*i];
-	} else {
-		oi = list_entry(*p, struct omap_hwmod_link, node)->ocp_if;
-		*p = (*p)->next;
-	}
+	oi = list_entry(*p, struct omap_hwmod_link, node)->ocp_if;
+	*p = (*p)->next;
 
 	*i = *i + 1;
 
@@ -642,16 +626,15 @@ static int _init_main_clk(struct omap_hwmod *oh)
 static int _init_interface_clks(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_ocp_if *os;
-	struct list_head *p = NULL;
+	struct list_head *p;
 	struct clk *c;
 	int i = 0;
 	int ret = 0;
 
-	if (link_registration)
-		p = oh->slave_ports.next;
+	p = oh->slave_ports.next;
 
 	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(&p, oh->slaves, &i);
+		os = _fetch_next_ocp_if(&p, &i);
 		if (!os->clk)
 			continue;
 
@@ -704,7 +687,7 @@ static int _init_opt_clks(struct omap_hwmod *oh)
 static int _enable_clocks(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_ocp_if *os;
-	struct list_head *p = NULL;
+	struct list_head *p;
 	int i = 0;
 
 	pr_debug("omap_hwmod: %s: enabling clocks\n", oh->name);
@@ -712,11 +695,10 @@ static int _enable_clocks(struct omap_hwmod *oh)
 	if (oh->_clk)
 		clk_enable(oh->_clk);
 
-	if (link_registration)
-		p = oh->slave_ports.next;
+	p = oh->slave_ports.next;
 
 	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(&p, oh->slaves, &i);
+		os = _fetch_next_ocp_if(&p, &i);
 
 		if (os->_clk && (os->flags & OCPIF_SWSUP_IDLE))
 			clk_enable(os->_clk);
@@ -736,7 +718,7 @@ static int _enable_clocks(struct omap_hwmod *oh)
 static int _disable_clocks(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_ocp_if *os;
-	struct list_head *p = NULL;
+	struct list_head *p;
 	int i = 0;
 
 	pr_debug("omap_hwmod: %s: disabling clocks\n", oh->name);
@@ -744,11 +726,10 @@ static int _disable_clocks(struct omap_hwmod *oh)
 	if (oh->_clk)
 		clk_disable(oh->_clk);
 
-	if (link_registration)
-		p = oh->slave_ports.next;
+	p = oh->slave_ports.next;
 
 	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(&p, oh->slaves, &i);
+		os = _fetch_next_ocp_if(&p, &i);
 
 		if (os->_clk && (os->flags & OCPIF_SWSUP_IDLE))
 			clk_disable(os->_clk);
@@ -1026,12 +1007,11 @@ static int _get_addr_space_by_name(struct omap_hwmod *oh, const char *name,
 	struct list_head *p = NULL;
 	bool found = false;
 
-	if (link_registration)
-		p = oh->slave_ports.next;
+	p = oh->slave_ports.next;
 
 	i = 0;
 	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(NULL, oh->slaves, &i);
+		os = _fetch_next_ocp_if(&p, &i);
 
 		if (!os->addr)
 			return -ENOENT;
@@ -1071,7 +1051,7 @@ static int _get_addr_space_by_name(struct omap_hwmod *oh, const char *name,
 static void __init _save_mpu_port_index(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_ocp_if *os = NULL;
-	struct list_head *p = NULL;
+	struct list_head *p;
 	int i = 0;
 
 	if (!oh)
@@ -1079,14 +1059,12 @@ static void __init _save_mpu_port_index(struct omap_hwmod *oh)
 
 	oh->_int_flags |= _HWMOD_NO_MPU_PORT;
 
-	if (link_registration)
-		p = oh->slave_ports.next;
+	p = oh->slave_ports.next;
 
 	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(&p, oh->slaves, &i);
+		os = _fetch_next_ocp_if(&p, &i);
 		if (os->user & OCP_USER_MPU) {
 			oh->_mpu_port = os;
-			oh->_mpu_port_index = i - 1;
 			oh->_int_flags &= ~_HWMOD_NO_MPU_PORT;
 			break;
 		}
@@ -1113,10 +1091,7 @@ static struct omap_hwmod_ocp_if *_find_mpu_rt_port(struct omap_hwmod *oh)
 	if (!oh || oh->_int_flags & _HWMOD_NO_MPU_PORT || oh->slaves_cnt == 0)
 		return NULL;
 
-	if (!link_registration)
-		return oh->slaves[oh->_mpu_port_index];
-	else
-		return oh->_mpu_port;
+	return oh->_mpu_port;
 };
 
 /**
@@ -2104,16 +2079,15 @@ static int __init _init(struct omap_hwmod *oh, void *data)
 static void __init _setup_iclk_autoidle(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_ocp_if *os;
-	struct list_head *p = NULL;
+	struct list_head *p;
 	int i = 0;
 	if (oh->_state != _HWMOD_STATE_INITIALIZED)
 		return;
 
-	if (link_registration)
-		p = oh->slave_ports.next;
+	p = oh->slave_ports.next;
 
 	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(&p, oh->slaves, &i);
+		os = _fetch_next_ocp_if(&p, &i);
 		if (!os->_clk)
 			continue;
 
@@ -2583,34 +2557,6 @@ int omap_hwmod_for_each(int (*fn)(struct omap_hwmod *oh, void *data),
 	return ret;
 }
 
-/**
- * omap_hwmod_register - register an array of hwmods
- * @ohs: pointer to an array of omap_hwmods to register
- *
- * Intended to be called early in boot before the clock framework is
- * initialized.  If @ohs is not null, will register all omap_hwmods
- * listed in @ohs that are valid for this chip.  Returns 0.
- */
-int __init omap_hwmod_register(struct omap_hwmod **ohs)
-{
-	int r, i;
-
-	if (link_registration)
-		return -EINVAL;
-
-	if (!ohs)
-		return 0;
-
-	i = 0;
-	do {
-		r = _register(ohs[i]);
-		WARN(r, "omap_hwmod: %s: _register returned %d\n", ohs[i]->name,
-		     r);
-	} while (ohs[++i]);
-
-	return 0;
-}
-
 /**
  * omap_hwmod_register_links - register an array of hwmod links
  * @ois: pointer to an array of omap_hwmod_ocp_if to register
@@ -2626,8 +2572,6 @@ int __init omap_hwmod_register_links(struct omap_hwmod_ocp_if **ois)
 	if (!ois)
 		return 0;
 
-	link_registration = true;
-
 	if (!linkspace) {
 		if (_alloc_linkspace(ois)) {
 			pr_err("omap_hwmod: could not allocate link space\n");
@@ -2888,17 +2832,16 @@ int omap_hwmod_reset(struct omap_hwmod *oh)
 int omap_hwmod_count_resources(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_ocp_if *os;
-	struct list_head *p = NULL;
+	struct list_head *p;
 	int ret;
 	int i = 0;
 
 	ret = _count_mpu_irqs(oh) + _count_sdma_reqs(oh);
 
-	if (link_registration)
-		p = oh->slave_ports.next;
+	p = oh->slave_ports.next;
 
 	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(&p, oh->slaves, &i);
+		os = _fetch_next_ocp_if(&p, &i);
 		ret += _count_ocp_if_addr_spaces(os);
 	}
 
@@ -2918,7 +2861,7 @@ int omap_hwmod_count_resources(struct omap_hwmod *oh)
 int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 {
 	struct omap_hwmod_ocp_if *os;
-	struct list_head *p = NULL;
+	struct list_head *p;
 	int i, j, mpu_irqs_cnt, sdma_reqs_cnt, addr_cnt;
 	int r = 0;
 
@@ -2942,12 +2885,11 @@ int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 		r++;
 	}
 
-	if (link_registration)
-		p = oh->slave_ports.next;
+	p = oh->slave_ports.next;
 
 	i = 0;
 	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(&p, oh->slaves, &i);
+		os = _fetch_next_ocp_if(&p, &i);
 		addr_cnt = _count_ocp_if_addr_spaces(os);
 
 		for (j = 0; j < addr_cnt; j++) {

commit 2221b5cddc2ebcfa4b0217266d2edc98e7eec93b
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Apr 19 04:04:30 2012 -0600

    ARM: OMAP2+: hwmod: add support for link registration
    
    Add support for direct IP block interconnect ("link") registration to
    the hwmod code via a new function, omap_hwmod_register_links().  This
    will replace direct registration of hwmods, and a subsequent patch
    will remove omap_hwmod_register().
    
    This change will allow a subsequent patch to remove the hwmod data
    link arrays.  This will reduce the size of the hwmod static data and
    also make it easier to generate the data files.  It will also make it
    possible to share some of the struct omap_hwmod records across
    multiple SoCs, since the link array pointers will be removed from the
    struct omap_hwmod.
    
    The downside is that boot time will increase.  Minimizing boot time
    was the reason why the link arrays were originally introduced.
    Removing them will require extra computation during boot to allocate
    memory and associate IP blocks with their interconnects.  However,
    since the current kernel development focus is on reducing the number
    of lines in arch/arm/mach-omap2/, boot time impact is now seemingly
    considered a lower priority.
    
    This patch contains additional complexity to reduce the number of
    memory allocations required for this change.  This reduces the boot
    time impact: total hwmod link registration time was ~ 2655
    microseconds with a simple allocation strategy, but is now ~ 549
    microseconds[1] with the approach taken by this patch.
    
    1. Measured on a BeagleBoard 35xx @ 500MHz MPU/333 MHz CORE, average
       of 7 samples.  Total uncertainty is +/- 61 microseconds.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 8cf837d2332a..99b913aa0cb9 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -137,6 +137,7 @@
 #include <linux/mutex.h>
 #include <linux/spinlock.h>
 #include <linux/slab.h>
+#include <linux/bootmem.h>
 
 #include "common.h"
 #include <plat/cpu.h>
@@ -159,25 +160,54 @@
 /* Name of the OMAP hwmod for the MPU */
 #define MPU_INITIATOR_NAME		"mpu"
 
+/*
+ * Number of struct omap_hwmod_link records per struct
+ * omap_hwmod_ocp_if record (master->slave and slave->master)
+ */
+#define LINKS_PER_OCP_IF		2
+
 /* omap_hwmod_list contains all registered struct omap_hwmods */
 static LIST_HEAD(omap_hwmod_list);
 
 /* mpu_oh: used to add/remove MPU initiator from sleepdep list */
 static struct omap_hwmod *mpu_oh;
 
+/*
+ * link_registration: set to true if hwmod interfaces are being registered
+ * directly; set to false if hwmods are being registered directly
+ */
+static bool link_registration;
+
+/*
+ * linkspace: ptr to a buffer that struct omap_hwmod_link records are
+ * allocated from - used to reduce the number of small memory
+ * allocations, which has a significant impact on performance
+ */
+static struct omap_hwmod_link *linkspace;
+
+/*
+ * free_ls, max_ls: array indexes into linkspace; representing the
+ * next free struct omap_hwmod_link index, and the maximum number of
+ * struct omap_hwmod_link records allocated (respectively)
+ */
+static unsigned short free_ls, max_ls, ls_supp;
 
 /* Private functions */
 
 /**
- * _fetch_next_ocp_if - return @i'th OCP interface in an array
- * @p: ptr to a ptr to the list_head inside the ocp_if to return (not yet used)
+ * _fetch_next_ocp_if - return next OCP interface in an array or list
+ * @p: ptr to a ptr to the list_head inside the ocp_if to return
  * @old: ptr to an array of struct omap_hwmod_ocp_if records
  * @i: pointer to the index into the @old array
  *
  * Return a pointer to the next struct omap_hwmod_ocp_if record in a
- * sequence.  Currently returns a struct omap_hwmod_ocp_if record
- * corresponding to the element index pointed to by @i in the @old
- * array, and increments the index pointed to by @i.
+ * sequence.  If hwmods are being registered directly, then return a
+ * struct omap_hwmod_ocp_if record corresponding to the element index
+ * pointed to by @i in the
+ * @old array.  Otherwise, return a pointer to the struct
+ * omap_hwmod_ocp_if record containing the struct list_head record pointed
+ * to by @p, and set the pointer pointed to by @p to point to the next
+ * struct list_head record in the list.
  */
 static struct omap_hwmod_ocp_if *_fetch_next_ocp_if(struct list_head **p,
 						    struct omap_hwmod_ocp_if **old,
@@ -185,7 +215,13 @@ static struct omap_hwmod_ocp_if *_fetch_next_ocp_if(struct list_head **p,
 {
 	struct omap_hwmod_ocp_if *oi;
 
-	oi = old[*i];
+	if (!link_registration) {
+		oi = old[*i];
+	} else {
+		oi = list_entry(*p, struct omap_hwmod_link, node)->ocp_if;
+		*p = (*p)->next;
+	}
+
 	*i = *i + 1;
 
 	return oi;
@@ -606,12 +642,16 @@ static int _init_main_clk(struct omap_hwmod *oh)
 static int _init_interface_clks(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_ocp_if *os;
+	struct list_head *p = NULL;
 	struct clk *c;
 	int i = 0;
 	int ret = 0;
 
+	if (link_registration)
+		p = oh->slave_ports.next;
+
 	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(NULL, oh->slaves, &i);
+		os = _fetch_next_ocp_if(&p, oh->slaves, &i);
 		if (!os->clk)
 			continue;
 
@@ -664,6 +704,7 @@ static int _init_opt_clks(struct omap_hwmod *oh)
 static int _enable_clocks(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_ocp_if *os;
+	struct list_head *p = NULL;
 	int i = 0;
 
 	pr_debug("omap_hwmod: %s: enabling clocks\n", oh->name);
@@ -671,8 +712,11 @@ static int _enable_clocks(struct omap_hwmod *oh)
 	if (oh->_clk)
 		clk_enable(oh->_clk);
 
+	if (link_registration)
+		p = oh->slave_ports.next;
+
 	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(NULL, oh->slaves, &i);
+		os = _fetch_next_ocp_if(&p, oh->slaves, &i);
 
 		if (os->_clk && (os->flags & OCPIF_SWSUP_IDLE))
 			clk_enable(os->_clk);
@@ -692,6 +736,7 @@ static int _enable_clocks(struct omap_hwmod *oh)
 static int _disable_clocks(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_ocp_if *os;
+	struct list_head *p = NULL;
 	int i = 0;
 
 	pr_debug("omap_hwmod: %s: disabling clocks\n", oh->name);
@@ -699,8 +744,11 @@ static int _disable_clocks(struct omap_hwmod *oh)
 	if (oh->_clk)
 		clk_disable(oh->_clk);
 
+	if (link_registration)
+		p = oh->slave_ports.next;
+
 	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(NULL, oh->slaves, &i);
+		os = _fetch_next_ocp_if(&p, oh->slaves, &i);
 
 		if (os->_clk && (os->flags & OCPIF_SWSUP_IDLE))
 			clk_disable(os->_clk);
@@ -975,8 +1023,12 @@ static int _get_addr_space_by_name(struct omap_hwmod *oh, const char *name,
 {
 	int i, j;
 	struct omap_hwmod_ocp_if *os;
+	struct list_head *p = NULL;
 	bool found = false;
 
+	if (link_registration)
+		p = oh->slave_ports.next;
+
 	i = 0;
 	while (i < oh->slaves_cnt) {
 		os = _fetch_next_ocp_if(NULL, oh->slaves, &i);
@@ -1019,6 +1071,7 @@ static int _get_addr_space_by_name(struct omap_hwmod *oh, const char *name,
 static void __init _save_mpu_port_index(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_ocp_if *os = NULL;
+	struct list_head *p = NULL;
 	int i = 0;
 
 	if (!oh)
@@ -1026,9 +1079,13 @@ static void __init _save_mpu_port_index(struct omap_hwmod *oh)
 
 	oh->_int_flags |= _HWMOD_NO_MPU_PORT;
 
+	if (link_registration)
+		p = oh->slave_ports.next;
+
 	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(NULL, oh->slaves, &i);
+		os = _fetch_next_ocp_if(&p, oh->slaves, &i);
 		if (os->user & OCP_USER_MPU) {
+			oh->_mpu_port = os;
 			oh->_mpu_port_index = i - 1;
 			oh->_int_flags &= ~_HWMOD_NO_MPU_PORT;
 			break;
@@ -1056,7 +1113,10 @@ static struct omap_hwmod_ocp_if *_find_mpu_rt_port(struct omap_hwmod *oh)
 	if (!oh || oh->_int_flags & _HWMOD_NO_MPU_PORT || oh->slaves_cnt == 0)
 		return NULL;
 
-	return oh->slaves[oh->_mpu_port_index];
+	if (!link_registration)
+		return oh->slaves[oh->_mpu_port_index];
+	else
+		return oh->_mpu_port;
 };
 
 /**
@@ -1976,6 +2036,8 @@ static void __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data)
 	if (!oh)
 		return;
 
+	_save_mpu_port_index(oh);
+
 	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
 		return;
 
@@ -2042,13 +2104,16 @@ static int __init _init(struct omap_hwmod *oh, void *data)
 static void __init _setup_iclk_autoidle(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_ocp_if *os;
+	struct list_head *p = NULL;
 	int i = 0;
 	if (oh->_state != _HWMOD_STATE_INITIALIZED)
 		return;
 
+	if (link_registration)
+		p = oh->slave_ports.next;
 
 	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(NULL, oh->slaves, &i);
+		os = _fetch_next_ocp_if(&p, oh->slaves, &i);
 		if (!os->_clk)
 			continue;
 
@@ -2219,10 +2284,10 @@ static int __init _register(struct omap_hwmod *oh)
 	if (_lookup(oh->name))
 		return -EEXIST;
 
-	_save_mpu_port_index(oh);
-
 	list_add_tail(&oh->node, &omap_hwmod_list);
 
+	INIT_LIST_HEAD(&oh->master_ports);
+	INIT_LIST_HEAD(&oh->slave_ports);
 	spin_lock_init(&oh->_lock);
 
 	oh->_state = _HWMOD_STATE_REGISTERED;
@@ -2237,6 +2302,160 @@ static int __init _register(struct omap_hwmod *oh)
 	return 0;
 }
 
+/**
+ * _alloc_links - return allocated memory for hwmod links
+ * @ml: pointer to a struct omap_hwmod_link * for the master link
+ * @sl: pointer to a struct omap_hwmod_link * for the slave link
+ *
+ * Return pointers to two struct omap_hwmod_link records, via the
+ * addresses pointed to by @ml and @sl.  Will first attempt to return
+ * memory allocated as part of a large initial block, but if that has
+ * been exhausted, will allocate memory itself.  Since ideally this
+ * second allocation path will never occur, the number of these
+ * 'supplemental' allocations will be logged when debugging is
+ * enabled.  Returns 0.
+ */
+static int __init _alloc_links(struct omap_hwmod_link **ml,
+			       struct omap_hwmod_link **sl)
+{
+	unsigned int sz;
+
+	if ((free_ls + LINKS_PER_OCP_IF) <= max_ls) {
+		*ml = &linkspace[free_ls++];
+		*sl = &linkspace[free_ls++];
+		return 0;
+	}
+
+	sz = sizeof(struct omap_hwmod_link) * LINKS_PER_OCP_IF;
+
+	*sl = NULL;
+	*ml = alloc_bootmem(sz);
+
+	memset(*ml, 0, sz);
+
+	*sl = (void *)(*ml) + sizeof(struct omap_hwmod_link);
+
+	ls_supp++;
+	pr_debug("omap_hwmod: supplemental link allocations needed: %d\n",
+		 ls_supp * LINKS_PER_OCP_IF);
+
+	return 0;
+};
+
+/**
+ * _add_link - add an interconnect between two IP blocks
+ * @oi: pointer to a struct omap_hwmod_ocp_if record
+ *
+ * Add struct omap_hwmod_link records connecting the master IP block
+ * specified in @oi->master to @oi, and connecting the slave IP block
+ * specified in @oi->slave to @oi.  This code is assumed to run before
+ * preemption or SMP has been enabled, thus avoiding the need for
+ * locking in this code.  Changes to this assumption will require
+ * additional locking.  Returns 0.
+ */
+static int __init _add_link(struct omap_hwmod_ocp_if *oi)
+{
+	struct omap_hwmod_link *ml, *sl;
+
+	pr_debug("omap_hwmod: %s -> %s: adding link\n", oi->master->name,
+		 oi->slave->name);
+
+	_alloc_links(&ml, &sl);
+
+	ml->ocp_if = oi;
+	INIT_LIST_HEAD(&ml->node);
+	list_add(&ml->node, &oi->master->master_ports);
+	oi->master->masters_cnt++;
+
+	sl->ocp_if = oi;
+	INIT_LIST_HEAD(&sl->node);
+	list_add(&sl->node, &oi->slave->slave_ports);
+	oi->slave->slaves_cnt++;
+
+	return 0;
+}
+
+/**
+ * _register_link - register a struct omap_hwmod_ocp_if
+ * @oi: struct omap_hwmod_ocp_if *
+ *
+ * Registers the omap_hwmod_ocp_if record @oi.  Returns -EEXIST if it
+ * has already been registered; -EINVAL if @oi is NULL or if the
+ * record pointed to by @oi is missing required fields; or 0 upon
+ * success.
+ *
+ * XXX The data should be copied into bootmem, so the original data
+ * should be marked __initdata and freed after init.  This would allow
+ * unneeded omap_hwmods to be freed on multi-OMAP configurations.
+ */
+static int __init _register_link(struct omap_hwmod_ocp_if *oi)
+{
+	if (!oi || !oi->master || !oi->slave || !oi->user)
+		return -EINVAL;
+
+	if (oi->_int_flags & _OCPIF_INT_FLAGS_REGISTERED)
+		return -EEXIST;
+
+	pr_debug("omap_hwmod: registering link from %s to %s\n",
+		 oi->master->name, oi->slave->name);
+
+	/*
+	 * Register the connected hwmods, if they haven't been
+	 * registered already
+	 */
+	if (oi->master->_state != _HWMOD_STATE_REGISTERED)
+		_register(oi->master);
+
+	if (oi->slave->_state != _HWMOD_STATE_REGISTERED)
+		_register(oi->slave);
+
+	_add_link(oi);
+
+	oi->_int_flags |= _OCPIF_INT_FLAGS_REGISTERED;
+
+	return 0;
+}
+
+/**
+ * _alloc_linkspace - allocate large block of hwmod links
+ * @ois: pointer to an array of struct omap_hwmod_ocp_if records to count
+ *
+ * Allocate a large block of struct omap_hwmod_link records.  This
+ * improves boot time significantly by avoiding the need to allocate
+ * individual records one by one.  If the number of records to
+ * allocate in the block hasn't been manually specified, this function
+ * will count the number of struct omap_hwmod_ocp_if records in @ois
+ * and use that to determine the allocation size.  For SoC families
+ * that require multiple list registrations, such as OMAP3xxx, this
+ * estimation process isn't optimal, so manual estimation is advised
+ * in those cases.  Returns -EEXIST if the allocation has already occurred
+ * or 0 upon success.
+ */
+static int __init _alloc_linkspace(struct omap_hwmod_ocp_if **ois)
+{
+	unsigned int i = 0;
+	unsigned int sz;
+
+	if (linkspace) {
+		WARN(1, "linkspace already allocated\n");
+		return -EEXIST;
+	}
+
+	if (max_ls == 0)
+		while (ois[i++])
+			max_ls += LINKS_PER_OCP_IF;
+
+	sz = sizeof(struct omap_hwmod_link) * max_ls;
+
+	pr_debug("omap_hwmod: %s: allocating %d byte linkspace (%d links)\n",
+		 __func__, sz, max_ls);
+
+	linkspace = alloc_bootmem(sz);
+
+	memset(linkspace, 0, sz);
+
+	return 0;
+}
 
 /* Public functions */
 
@@ -2376,6 +2595,9 @@ int __init omap_hwmod_register(struct omap_hwmod **ohs)
 {
 	int r, i;
 
+	if (link_registration)
+		return -EINVAL;
+
 	if (!ohs)
 		return 0;
 
@@ -2389,6 +2611,41 @@ int __init omap_hwmod_register(struct omap_hwmod **ohs)
 	return 0;
 }
 
+/**
+ * omap_hwmod_register_links - register an array of hwmod links
+ * @ois: pointer to an array of omap_hwmod_ocp_if to register
+ *
+ * Intended to be called early in boot before the clock framework is
+ * initialized.  If @ois is not null, will register all omap_hwmods
+ * listed in @ois that are valid for this chip.  Returns 0.
+ */
+int __init omap_hwmod_register_links(struct omap_hwmod_ocp_if **ois)
+{
+	int r, i;
+
+	if (!ois)
+		return 0;
+
+	link_registration = true;
+
+	if (!linkspace) {
+		if (_alloc_linkspace(ois)) {
+			pr_err("omap_hwmod: could not allocate link space\n");
+			return -ENOMEM;
+		}
+	}
+
+	i = 0;
+	do {
+		r = _register_link(ois[i]);
+		WARN(r && r != -EEXIST,
+		     "omap_hwmod: _register_link(%s -> %s) returned %d\n",
+		     ois[i]->master->name, ois[i]->slave->name, r);
+	} while (ois[++i]);
+
+	return 0;
+}
+
 /**
  * _ensure_mpu_hwmod_is_setup - ensure the MPU SS hwmod is init'ed and set up
  * @oh: pointer to the hwmod currently being set up (usually not the MPU)
@@ -2631,13 +2888,17 @@ int omap_hwmod_reset(struct omap_hwmod *oh)
 int omap_hwmod_count_resources(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_ocp_if *os;
+	struct list_head *p = NULL;
 	int ret;
 	int i = 0;
 
 	ret = _count_mpu_irqs(oh) + _count_sdma_reqs(oh);
 
+	if (link_registration)
+		p = oh->slave_ports.next;
+
 	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(NULL, oh->slaves, &i);
+		os = _fetch_next_ocp_if(&p, oh->slaves, &i);
 		ret += _count_ocp_if_addr_spaces(os);
 	}
 
@@ -2657,6 +2918,7 @@ int omap_hwmod_count_resources(struct omap_hwmod *oh)
 int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 {
 	struct omap_hwmod_ocp_if *os;
+	struct list_head *p = NULL;
 	int i, j, mpu_irqs_cnt, sdma_reqs_cnt, addr_cnt;
 	int r = 0;
 
@@ -2680,9 +2942,12 @@ int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 		r++;
 	}
 
+	if (link_registration)
+		p = oh->slave_ports.next;
+
 	i = 0;
 	while (i < oh->slaves_cnt) {
-		os = _fetch_next_ocp_if(NULL, oh->slaves, &i);
+		os = _fetch_next_ocp_if(&p, oh->slaves, &i);
 		addr_cnt = _count_ocp_if_addr_spaces(os);
 
 		for (j = 0; j < addr_cnt; j++) {

commit 24dbc2130179ebd493a241f6f5972cf6524b933a
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Apr 19 04:04:29 2012 -0600

    ARM: OMAP2+: hwmod: consolidate finding the MPU port index and storing it
    
    An IP block's MPU interface port only needs to be found once.  The result
    can be cached to speed further lookups.  This patch consolidates these
    two steps into a single function.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index f74f3af95cae..8cf837d2332a 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1008,37 +1008,34 @@ static int _get_addr_space_by_name(struct omap_hwmod *oh, const char *name,
 }
 
 /**
- * _find_mpu_port_index - find hwmod OCP slave port ID intended for MPU use
+ * _save_mpu_port_index - find and save the index to @oh's MPU port
  * @oh: struct omap_hwmod *
  *
- * Returns the array index of the OCP slave port that the MPU
- * addresses the device on, or -EINVAL upon error or not found.
+ * Determines the array index of the OCP slave port that the MPU uses
+ * to address the device, and saves it into the struct omap_hwmod.
+ * Intended to be called during hwmod registration only. No return
+ * value.
  */
-static int __init _find_mpu_port_index(struct omap_hwmod *oh)
+static void __init _save_mpu_port_index(struct omap_hwmod *oh)
 {
-	struct omap_hwmod_ocp_if *os;
+	struct omap_hwmod_ocp_if *os = NULL;
 	int i = 0;
-	int found = 0;
 
 	if (!oh)
-		return -EINVAL;
+		return;
+
+	oh->_int_flags |= _HWMOD_NO_MPU_PORT;
 
 	while (i < oh->slaves_cnt) {
 		os = _fetch_next_ocp_if(NULL, oh->slaves, &i);
 		if (os->user & OCP_USER_MPU) {
-			found = 1;
+			oh->_mpu_port_index = i - 1;
+			oh->_int_flags &= ~_HWMOD_NO_MPU_PORT;
 			break;
 		}
 	}
 
-	if (found)
-		pr_debug("omap_hwmod: %s: MPU OCP slave port ID  %d\n",
-			 oh->name, i - 1);
-	else
-		pr_debug("omap_hwmod: %s: no MPU OCP slave port found\n",
-			 oh->name);
-
-	return (found) ? (i - 1) : -EINVAL;
+	return;
 }
 
 /**
@@ -1076,7 +1073,7 @@ static struct omap_hwmod_addr_space * __init _find_mpu_rt_addr_space(struct omap
 	int found = 0, i = 0;
 
 	os = _find_mpu_rt_port(oh);
-	if (!os->addr)
+	if (!os || !os->addr)
 		return NULL;
 
 	do {
@@ -2213,8 +2210,6 @@ static int __init _setup(struct omap_hwmod *oh, void *data)
  */
 static int __init _register(struct omap_hwmod *oh)
 {
-	int ms_id;
-
 	if (!oh || !oh->name || !oh->class || !oh->class->name ||
 	    (oh->_state != _HWMOD_STATE_UNKNOWN))
 		return -EINVAL;
@@ -2224,11 +2219,7 @@ static int __init _register(struct omap_hwmod *oh)
 	if (_lookup(oh->name))
 		return -EEXIST;
 
-	ms_id = _find_mpu_port_index(oh);
-	if (!IS_ERR_VALUE(ms_id))
-		oh->_mpu_port_index = ms_id;
-	else
-		oh->_int_flags |= _HWMOD_NO_MPU_PORT;
+	_save_mpu_port_index(oh);
 
 	list_add_tail(&oh->node, &omap_hwmod_list);
 

commit 5d95dde7316101656102cb585b73381e4eaadaa7
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Apr 19 04:04:28 2012 -0600

    ARM: OMAP2+: hwmod: add function to iterate over struct omap_hwmod_ocp_if
    
    To reduce the number of lines of data in the OMAP portion of the Linux
    code base, subsequent patches will remove the lists of hwmod
    interconnect links from the static hwmod data.  These lists will be
    built dynamically during boot.  To ease this transition, this patch
    centralizes the way that interconnect links are iterated into a single
    function, _fetch_next_ocp_if().
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 241c663a8f62..f74f3af95cae 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -168,6 +168,29 @@ static struct omap_hwmod *mpu_oh;
 
 /* Private functions */
 
+/**
+ * _fetch_next_ocp_if - return @i'th OCP interface in an array
+ * @p: ptr to a ptr to the list_head inside the ocp_if to return (not yet used)
+ * @old: ptr to an array of struct omap_hwmod_ocp_if records
+ * @i: pointer to the index into the @old array
+ *
+ * Return a pointer to the next struct omap_hwmod_ocp_if record in a
+ * sequence.  Currently returns a struct omap_hwmod_ocp_if record
+ * corresponding to the element index pointed to by @i in the @old
+ * array, and increments the index pointed to by @i.
+ */
+static struct omap_hwmod_ocp_if *_fetch_next_ocp_if(struct list_head **p,
+						    struct omap_hwmod_ocp_if **old,
+						    int *i)
+{
+	struct omap_hwmod_ocp_if *oi;
+
+	oi = old[*i];
+	*i = *i + 1;
+
+	return oi;
+}
+
 /**
  * _update_sysc_cache - return the module OCP_SYSCONFIG register, keep copy
  * @oh: struct omap_hwmod *
@@ -582,16 +605,13 @@ static int _init_main_clk(struct omap_hwmod *oh)
  */
 static int _init_interface_clks(struct omap_hwmod *oh)
 {
+	struct omap_hwmod_ocp_if *os;
 	struct clk *c;
-	int i;
+	int i = 0;
 	int ret = 0;
 
-	if (oh->slaves_cnt == 0)
-		return 0;
-
-	for (i = 0; i < oh->slaves_cnt; i++) {
-		struct omap_hwmod_ocp_if *os = oh->slaves[i];
-
+	while (i < oh->slaves_cnt) {
+		os = _fetch_next_ocp_if(NULL, oh->slaves, &i);
 		if (!os->clk)
 			continue;
 
@@ -643,21 +663,19 @@ static int _init_opt_clks(struct omap_hwmod *oh)
  */
 static int _enable_clocks(struct omap_hwmod *oh)
 {
-	int i;
+	struct omap_hwmod_ocp_if *os;
+	int i = 0;
 
 	pr_debug("omap_hwmod: %s: enabling clocks\n", oh->name);
 
 	if (oh->_clk)
 		clk_enable(oh->_clk);
 
-	if (oh->slaves_cnt > 0) {
-		for (i = 0; i < oh->slaves_cnt; i++) {
-			struct omap_hwmod_ocp_if *os = oh->slaves[i];
-			struct clk *c = os->_clk;
+	while (i < oh->slaves_cnt) {
+		os = _fetch_next_ocp_if(NULL, oh->slaves, &i);
 
-			if (c && (os->flags & OCPIF_SWSUP_IDLE))
-				clk_enable(c);
-		}
+		if (os->_clk && (os->flags & OCPIF_SWSUP_IDLE))
+			clk_enable(os->_clk);
 	}
 
 	/* The opt clocks are controlled by the device driver. */
@@ -673,21 +691,19 @@ static int _enable_clocks(struct omap_hwmod *oh)
  */
 static int _disable_clocks(struct omap_hwmod *oh)
 {
-	int i;
+	struct omap_hwmod_ocp_if *os;
+	int i = 0;
 
 	pr_debug("omap_hwmod: %s: disabling clocks\n", oh->name);
 
 	if (oh->_clk)
 		clk_disable(oh->_clk);
 
-	if (oh->slaves_cnt > 0) {
-		for (i = 0; i < oh->slaves_cnt; i++) {
-			struct omap_hwmod_ocp_if *os = oh->slaves[i];
-			struct clk *c = os->_clk;
+	while (i < oh->slaves_cnt) {
+		os = _fetch_next_ocp_if(NULL, oh->slaves, &i);
 
-			if (c && (os->flags & OCPIF_SWSUP_IDLE))
-				clk_disable(c);
-		}
+		if (os->_clk && (os->flags & OCPIF_SWSUP_IDLE))
+			clk_disable(os->_clk);
 	}
 
 	/* The opt clocks are controlled by the device driver. */
@@ -961,8 +977,9 @@ static int _get_addr_space_by_name(struct omap_hwmod *oh, const char *name,
 	struct omap_hwmod_ocp_if *os;
 	bool found = false;
 
-	for (i = 0; i < oh->slaves_cnt; i++) {
-		os = oh->slaves[i];
+	i = 0;
+	while (i < oh->slaves_cnt) {
+		os = _fetch_next_ocp_if(NULL, oh->slaves, &i);
 
 		if (!os->addr)
 			return -ENOENT;
@@ -999,15 +1016,15 @@ static int _get_addr_space_by_name(struct omap_hwmod *oh, const char *name,
  */
 static int __init _find_mpu_port_index(struct omap_hwmod *oh)
 {
-	int i;
+	struct omap_hwmod_ocp_if *os;
+	int i = 0;
 	int found = 0;
 
-	if (!oh || oh->slaves_cnt == 0)
+	if (!oh)
 		return -EINVAL;
 
-	for (i = 0; i < oh->slaves_cnt; i++) {
-		struct omap_hwmod_ocp_if *os = oh->slaves[i];
-
+	while (i < oh->slaves_cnt) {
+		os = _fetch_next_ocp_if(NULL, oh->slaves, &i);
 		if (os->user & OCP_USER_MPU) {
 			found = 1;
 			break;
@@ -1016,12 +1033,12 @@ static int __init _find_mpu_port_index(struct omap_hwmod *oh)
 
 	if (found)
 		pr_debug("omap_hwmod: %s: MPU OCP slave port ID  %d\n",
-			 oh->name, i);
+			 oh->name, i - 1);
 	else
 		pr_debug("omap_hwmod: %s: no MPU OCP slave port found\n",
 			 oh->name);
 
-	return (found) ? i : -EINVAL;
+	return (found) ? (i - 1) : -EINVAL;
 }
 
 /**
@@ -2027,23 +2044,22 @@ static int __init _init(struct omap_hwmod *oh, void *data)
  */
 static void __init _setup_iclk_autoidle(struct omap_hwmod *oh)
 {
-	int i;
-
+	struct omap_hwmod_ocp_if *os;
+	int i = 0;
 	if (oh->_state != _HWMOD_STATE_INITIALIZED)
 		return;
 
-	for (i = 0; i < oh->slaves_cnt; i++) {
-		struct omap_hwmod_ocp_if *os = oh->slaves[i];
-		struct clk *c = os->_clk;
 
-		if (!c)
+	while (i < oh->slaves_cnt) {
+		os = _fetch_next_ocp_if(NULL, oh->slaves, &i);
+		if (!os->_clk)
 			continue;
 
 		if (os->flags & OCPIF_SWSUP_IDLE) {
 			/* XXX omap_iclk_deny_idle(c); */
 		} else {
 			/* XXX omap_iclk_allow_idle(c); */
-			clk_enable(c);
+			clk_enable(os->_clk);
 		}
 	}
 
@@ -2623,12 +2639,16 @@ int omap_hwmod_reset(struct omap_hwmod *oh)
  */
 int omap_hwmod_count_resources(struct omap_hwmod *oh)
 {
-	int ret, i;
+	struct omap_hwmod_ocp_if *os;
+	int ret;
+	int i = 0;
 
 	ret = _count_mpu_irqs(oh) + _count_sdma_reqs(oh);
 
-	for (i = 0; i < oh->slaves_cnt; i++)
-		ret += _count_ocp_if_addr_spaces(oh->slaves[i]);
+	while (i < oh->slaves_cnt) {
+		os = _fetch_next_ocp_if(NULL, oh->slaves, &i);
+		ret += _count_ocp_if_addr_spaces(os);
+	}
 
 	return ret;
 }
@@ -2645,7 +2665,8 @@ int omap_hwmod_count_resources(struct omap_hwmod *oh)
  */
 int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 {
-	int i, j, mpu_irqs_cnt, sdma_reqs_cnt;
+	struct omap_hwmod_ocp_if *os;
+	int i, j, mpu_irqs_cnt, sdma_reqs_cnt, addr_cnt;
 	int r = 0;
 
 	/* For each IRQ, DMA, memory area, fill in array.*/
@@ -2668,11 +2689,9 @@ int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 		r++;
 	}
 
-	for (i = 0; i < oh->slaves_cnt; i++) {
-		struct omap_hwmod_ocp_if *os;
-		int addr_cnt;
-
-		os = oh->slaves[i];
+	i = 0;
+	while (i < oh->slaves_cnt) {
+		os = _fetch_next_ocp_if(NULL, oh->slaves, &i);
 		addr_cnt = _count_ocp_if_addr_spaces(os);
 
 		for (j = 0; j < addr_cnt; j++) {

commit 2d6141baf15df188283ada7c0fa04679c4fcf1c7
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Apr 19 04:04:27 2012 -0600

    ARM: OMAP2+: hwmod: add _find_mpu_rt_port()
    
    Most IP blocks on the OMAP SoC have an interconnect link that is
    intended to be used by the MPU to communicate with the IP block.
    Several parts of the hwmod code need to be able to identify this link.
    Currently, this is open-coded.  However, future patches will change
    the way that interconnect links are represented and will make
    identifying the link more complex.  So to avoid code duplication, this
    patch centralizes the MPU port link identification code into a new
    function, _find_mpu_rt_port().
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 230119756504..241c663a8f62 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1024,6 +1024,27 @@ static int __init _find_mpu_port_index(struct omap_hwmod *oh)
 	return (found) ? i : -EINVAL;
 }
 
+/**
+ * _find_mpu_rt_port - return omap_hwmod_ocp_if accessible by the MPU
+ * @oh: struct omap_hwmod *
+ *
+ * Given a pointer to a struct omap_hwmod record @oh, return a pointer
+ * to the struct omap_hwmod_ocp_if record that is used by the MPU to
+ * communicate with the IP block.  This interface need not be directly
+ * connected to the MPU (and almost certainly is not), but is directly
+ * connected to the IP block represented by @oh.  Returns a pointer
+ * to the struct omap_hwmod_ocp_if * upon success, or returns NULL upon
+ * error or if there does not appear to be a path from the MPU to this
+ * IP block.
+ */
+static struct omap_hwmod_ocp_if *_find_mpu_rt_port(struct omap_hwmod *oh)
+{
+	if (!oh || oh->_int_flags & _HWMOD_NO_MPU_PORT || oh->slaves_cnt == 0)
+		return NULL;
+
+	return oh->slaves[oh->_mpu_port_index];
+};
+
 /**
  * _find_mpu_rt_addr_space - return MPU register target address space for @oh
  * @oh: struct omap_hwmod *
@@ -1037,10 +1058,7 @@ static struct omap_hwmod_addr_space * __init _find_mpu_rt_addr_space(struct omap
 	struct omap_hwmod_addr_space *mem;
 	int found = 0, i = 0;
 
-	if (!oh || oh->_int_flags & _HWMOD_NO_MPU_PORT || oh->slaves_cnt == 0)
-		return NULL;
-
-	os = oh->slaves[oh->_mpu_port_index];
+	os = _find_mpu_rt_port(oh);
 	if (!os->addr)
 		return NULL;
 
@@ -1298,12 +1316,11 @@ static int _wait_target_ready(struct omap_hwmod *oh)
 	if (!oh)
 		return -EINVAL;
 
-	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
+	if (oh->flags & HWMOD_NO_IDLEST)
 		return 0;
 
-	os = oh->slaves[oh->_mpu_port_index];
-
-	if (oh->flags & HWMOD_NO_IDLEST)
+	os = _find_mpu_rt_port(oh);
+	if (!os)
 		return 0;
 
 	/* XXX check module SIDLEMODE */
@@ -2747,6 +2764,7 @@ int omap_hwmod_get_resource_byname(struct omap_hwmod *oh, unsigned int type,
 struct powerdomain *omap_hwmod_get_pwrdm(struct omap_hwmod *oh)
 {
 	struct clk *c;
+	struct omap_hwmod_ocp_if *oi;
 
 	if (!oh)
 		return NULL;
@@ -2754,9 +2772,10 @@ struct powerdomain *omap_hwmod_get_pwrdm(struct omap_hwmod *oh)
 	if (oh->_clk) {
 		c = oh->_clk;
 	} else {
-		if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
+		oi = _find_mpu_rt_port(oh);
+		if (!oi)
 			return NULL;
-		c = oh->slaves[oh->_mpu_port_index]->_clk;
+		c = oi->_clk;
 	}
 
 	if (!c->clkdm)

commit 5e8370f1fa01bf232ca4770c6d81bbf42437d2a3
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Apr 18 19:10:06 2012 -0600

    ARM: OMAP2+: hwmod: add omap_hwmod_get_resource_byname()
    
    The timer integration code pokes around in hwmod data structures.
    Those data structures are about to change.  Define a function,
    omap_hwmod_get_resource_byname(), for the timer integration code to
    use instead.
    
    The original patch has been changed to use struct resource by Tony's
    request, although the caller of this function should not be a driver._
    Platform drivers should get their data through the regular platform_*
    functions; DT drivers through the appropriate of_* functions.  This a
    function is only for use by OMAP core code in arch/arm/*omap*.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 52c69d265f7c..230119756504 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -849,6 +849,147 @@ static int _count_ocp_if_addr_spaces(struct omap_hwmod_ocp_if *os)
 	return i-1;
 }
 
+/**
+ * _get_mpu_irq_by_name - fetch MPU interrupt line number by name
+ * @oh: struct omap_hwmod * to operate on
+ * @name: pointer to the name of the MPU interrupt number to fetch (optional)
+ * @irq: pointer to an unsigned int to store the MPU IRQ number to
+ *
+ * Retrieve a MPU hardware IRQ line number named by @name associated
+ * with the IP block pointed to by @oh.  The IRQ number will be filled
+ * into the address pointed to by @dma.  When @name is non-null, the
+ * IRQ line number associated with the named entry will be returned.
+ * If @name is null, the first matching entry will be returned.  Data
+ * order is not meaningful in hwmod data, so callers are strongly
+ * encouraged to use a non-null @name whenever possible to avoid
+ * unpredictable effects if hwmod data is later added that causes data
+ * ordering to change.  Returns 0 upon success or a negative error
+ * code upon error.
+ */
+static int _get_mpu_irq_by_name(struct omap_hwmod *oh, const char *name,
+				unsigned int *irq)
+{
+	int i;
+	bool found = false;
+
+	if (!oh->mpu_irqs)
+		return -ENOENT;
+
+	i = 0;
+	while (oh->mpu_irqs[i].irq != -1) {
+		if (name == oh->mpu_irqs[i].name ||
+		    !strcmp(name, oh->mpu_irqs[i].name)) {
+			found = true;
+			break;
+		}
+		i++;
+	}
+
+	if (!found)
+		return -ENOENT;
+
+	*irq = oh->mpu_irqs[i].irq;
+
+	return 0;
+}
+
+/**
+ * _get_sdma_req_by_name - fetch SDMA request line ID by name
+ * @oh: struct omap_hwmod * to operate on
+ * @name: pointer to the name of the SDMA request line to fetch (optional)
+ * @dma: pointer to an unsigned int to store the request line ID to
+ *
+ * Retrieve an SDMA request line ID named by @name on the IP block
+ * pointed to by @oh.  The ID will be filled into the address pointed
+ * to by @dma.  When @name is non-null, the request line ID associated
+ * with the named entry will be returned.  If @name is null, the first
+ * matching entry will be returned.  Data order is not meaningful in
+ * hwmod data, so callers are strongly encouraged to use a non-null
+ * @name whenever possible to avoid unpredictable effects if hwmod
+ * data is later added that causes data ordering to change.  Returns 0
+ * upon success or a negative error code upon error.
+ */
+static int _get_sdma_req_by_name(struct omap_hwmod *oh, const char *name,
+				 unsigned int *dma)
+{
+	int i;
+	bool found = false;
+
+	if (!oh->sdma_reqs)
+		return -ENOENT;
+
+	i = 0;
+	while (oh->sdma_reqs[i].dma_req != -1) {
+		if (name == oh->sdma_reqs[i].name ||
+		    !strcmp(name, oh->sdma_reqs[i].name)) {
+			found = true;
+			break;
+		}
+		i++;
+	}
+
+	if (!found)
+		return -ENOENT;
+
+	*dma = oh->sdma_reqs[i].dma_req;
+
+	return 0;
+}
+
+/**
+ * _get_addr_space_by_name - fetch address space start & end by name
+ * @oh: struct omap_hwmod * to operate on
+ * @name: pointer to the name of the address space to fetch (optional)
+ * @pa_start: pointer to a u32 to store the starting address to
+ * @pa_end: pointer to a u32 to store the ending address to
+ *
+ * Retrieve address space start and end addresses for the IP block
+ * pointed to by @oh.  The data will be filled into the addresses
+ * pointed to by @pa_start and @pa_end.  When @name is non-null, the
+ * address space data associated with the named entry will be
+ * returned.  If @name is null, the first matching entry will be
+ * returned.  Data order is not meaningful in hwmod data, so callers
+ * are strongly encouraged to use a non-null @name whenever possible
+ * to avoid unpredictable effects if hwmod data is later added that
+ * causes data ordering to change.  Returns 0 upon success or a
+ * negative error code upon error.
+ */
+static int _get_addr_space_by_name(struct omap_hwmod *oh, const char *name,
+				   u32 *pa_start, u32 *pa_end)
+{
+	int i, j;
+	struct omap_hwmod_ocp_if *os;
+	bool found = false;
+
+	for (i = 0; i < oh->slaves_cnt; i++) {
+		os = oh->slaves[i];
+
+		if (!os->addr)
+			return -ENOENT;
+
+		j = 0;
+		while (os->addr[j].pa_start != os->addr[j].pa_end) {
+			if (name == os->addr[j].name ||
+			    !strcmp(name, os->addr[j].name)) {
+				found = true;
+				break;
+			}
+			j++;
+		}
+
+		if (found)
+			break;
+	}
+
+	if (!found)
+		return -ENOENT;
+
+	*pa_start = os->addr[j].pa_start;
+	*pa_end = os->addr[j].pa_end;
+
+	return 0;
+}
+
 /**
  * _find_mpu_port_index - find hwmod OCP slave port ID intended for MPU use
  * @oh: struct omap_hwmod *
@@ -2443,6 +2584,10 @@ int omap_hwmod_reset(struct omap_hwmod *oh)
 	return r;
 }
 
+/*
+ * IP block data retrieval functions
+ */
+
 /**
  * omap_hwmod_count_resources - count number of struct resources needed by hwmod
  * @oh: struct omap_hwmod *
@@ -2525,6 +2670,69 @@ int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 	return r;
 }
 
+/**
+ * omap_hwmod_get_resource_byname - fetch IP block integration data by name
+ * @oh: struct omap_hwmod * to operate on
+ * @type: one of the IORESOURCE_* constants from include/linux/ioport.h
+ * @name: pointer to the name of the data to fetch (optional)
+ * @rsrc: pointer to a struct resource, allocated by the caller
+ *
+ * Retrieve MPU IRQ, SDMA request line, or address space start/end
+ * data for the IP block pointed to by @oh.  The data will be filled
+ * into a struct resource record pointed to by @rsrc.  The struct
+ * resource must be allocated by the caller.  When @name is non-null,
+ * the data associated with the matching entry in the IRQ/SDMA/address
+ * space hwmod data arrays will be returned.  If @name is null, the
+ * first array entry will be returned.  Data order is not meaningful
+ * in hwmod data, so callers are strongly encouraged to use a non-null
+ * @name whenever possible to avoid unpredictable effects if hwmod
+ * data is later added that causes data ordering to change.  This
+ * function is only intended for use by OMAP core code.  Device
+ * drivers should not call this function - the appropriate bus-related
+ * data accessor functions should be used instead.  Returns 0 upon
+ * success or a negative error code upon error.
+ */
+int omap_hwmod_get_resource_byname(struct omap_hwmod *oh, unsigned int type,
+				   const char *name, struct resource *rsrc)
+{
+	int r;
+	unsigned int irq, dma;
+	u32 pa_start, pa_end;
+
+	if (!oh || !rsrc)
+		return -EINVAL;
+
+	if (type == IORESOURCE_IRQ) {
+		r = _get_mpu_irq_by_name(oh, name, &irq);
+		if (r)
+			return r;
+
+		rsrc->start = irq;
+		rsrc->end = irq;
+	} else if (type == IORESOURCE_DMA) {
+		r = _get_sdma_req_by_name(oh, name, &dma);
+		if (r)
+			return r;
+
+		rsrc->start = dma;
+		rsrc->end = dma;
+	} else if (type == IORESOURCE_MEM) {
+		r = _get_addr_space_by_name(oh, name, &pa_start, &pa_end);
+		if (r)
+			return r;
+
+		rsrc->start = pa_start;
+		rsrc->end = pa_end;
+	} else {
+		return -EINVAL;
+	}
+
+	rsrc->flags = type;
+	rsrc->name = name;
+
+	return 0;
+}
+
 /**
  * omap_hwmod_get_pwrdm - return pointer to this module's main powerdomain
  * @oh: struct omap_hwmod *

commit c9aafd23d6c1b466f37f554e9916886e7d4645d0
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Apr 18 19:10:05 2012 -0600

    ARM: OMAP2+: hwmod: provide a function to return the address space of the MPU RT
    
    A subsequent patch will need to know the struct omap_hwmod_addr_space
    record corresponding to the module's register target, used by the MPU.
    So, convert _find_mpu_rt_base() into _find_mpu_rt_addr_space().  Then
    modify its sole current user, _populate_mpu_rt_base(), to extract the
    MPU RT base address itself from the struct omap_hwmod_addr_space record.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index bd9fc10ea737..52c69d265f7c 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -884,24 +884,22 @@ static int __init _find_mpu_port_index(struct omap_hwmod *oh)
 }
 
 /**
- * _find_mpu_rt_base - find hwmod register target base addr accessible by MPU
+ * _find_mpu_rt_addr_space - return MPU register target address space for @oh
  * @oh: struct omap_hwmod *
  *
- * Return the virtual address of the base of the register target of
- * device @oh, or NULL on error.
+ * Returns a pointer to the struct omap_hwmod_addr_space record representing
+ * the register target MPU address space; or returns NULL upon error.
  */
-static void __iomem * __init _find_mpu_rt_base(struct omap_hwmod *oh, u8 index)
+static struct omap_hwmod_addr_space * __init _find_mpu_rt_addr_space(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_ocp_if *os;
 	struct omap_hwmod_addr_space *mem;
-	int i = 0, found = 0;
-	void __iomem *va_start;
+	int found = 0, i = 0;
 
-	if (!oh || oh->slaves_cnt == 0)
+	if (!oh || oh->_int_flags & _HWMOD_NO_MPU_PORT || oh->slaves_cnt == 0)
 		return NULL;
 
-	os = oh->slaves[index];
-
+	os = oh->slaves[oh->_mpu_port_index];
 	if (!os->addr)
 		return NULL;
 
@@ -911,20 +909,7 @@ static void __iomem * __init _find_mpu_rt_base(struct omap_hwmod *oh, u8 index)
 			found = 1;
 	} while (!found && mem->pa_start != mem->pa_end);
 
-	if (found) {
-		va_start = ioremap(mem->pa_start, mem->pa_end - mem->pa_start);
-		if (!va_start) {
-			pr_err("omap_hwmod: %s: Could not ioremap\n", oh->name);
-			return NULL;
-		}
-		pr_debug("omap_hwmod: %s: MPU register target at va %p\n",
-			 oh->name, va_start);
-	} else {
-		pr_debug("omap_hwmod: %s: no MPU register target found\n",
-			 oh->name);
-	}
-
-	return (found) ? va_start : NULL;
+	return (found) ? mem : NULL;
 }
 
 /**
@@ -1813,10 +1798,32 @@ static int _shutdown(struct omap_hwmod *oh)
  */
 static void __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data)
 {
+	struct omap_hwmod_addr_space *mem;
+	void __iomem *va_start;
+
+	if (!oh)
+		return;
+
 	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
 		return;
 
-	oh->_mpu_rt_va = _find_mpu_rt_base(oh, oh->_mpu_port_index);
+	mem = _find_mpu_rt_addr_space(oh);
+	if (!mem) {
+		pr_debug("omap_hwmod: %s: no MPU register target found\n",
+			 oh->name);
+		return;
+	}
+
+	va_start = ioremap(mem->pa_start, mem->pa_end - mem->pa_start);
+	if (!va_start) {
+		pr_err("omap_hwmod: %s: Could not ioremap\n", oh->name);
+		return;
+	}
+
+	pr_debug("omap_hwmod: %s: MPU register target at va %p\n",
+		 oh->name, va_start);
+
+	oh->_mpu_rt_va = va_start;
 }
 
 /**

commit 747834ab83475f47878c68954d913e27124e4391
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Apr 18 19:10:04 2012 -0600

    ARM: OMAP2+: hwmod: revise hardreset behavior
    
    Change the way that hardreset lines are handled by the hwmod code.
    Hardreset lines are generally associated with initiator IP blocks.
    Prior to this change, the hwmod code expected to control hardreset
    lines itself, asserting them on shutdown and deasserting them upon
    enable.  But driver authors inside TI have commented to us that their
    drivers require direct control over these lines.  Unfortunately, these
    drivers haven't been posted publicly yet, so it's hard to determine
    exactly what is needed, a priori.  This change attempts to set forth
    some reasonable semantics that should be an improvement over the
    current code.
    
    The semantics implemented by this patch are as follows:
    
    - If the hwmod is not marked with HWMOD_INIT_NO_RESET, then assert all
      associated hardreset lines during IP block setup.  This is intended
      to place the IP blocks into a known state that will not interfere
      with other devices during kernel boot.
    
    - IP blocks with hardreset lines will not be automatically enabled or
      idled during setup.  Instead, they will be left in the INITIALIZED
      state.
    
    - When the hwmod code is asked to enable, idle, or shutdown an IP
      block with asserted hardreset lines, the hwmod code will do nothing.
      The driver integration code must do the remaining work needed to
      control these IP blocks.  Once this driver integration code is posted
      to the lists, hopefully we can consolidate it and move it inside the
      hwmod code.
    
    Custom reset functions for IP blocks with hardreset lines still should
    be supported and are strongly endorsed.  It is intended that every
    subsystem with hardreset lines should have a custom reset function
    that can place their subsystem into quiescent idle with the hardreset
    lines deasserted.
    
    This reverts most of commit 5365efbe29250a227502256cc912351fe2157b42
    ("OMAP: hwmod: Add hardreset management support").  Later code
    reorganizations caused the sequencing of the code from this patch to
    be changed, anyway.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 6c6d31b432d2..bd9fc10ea737 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -780,39 +780,6 @@ static int _omap4_wait_target_disable(struct omap_hwmod *oh)
 					     oh->prcm.omap4.clkctrl_offs);
 }
 
-/**
- * _omap4_disable_module - enable CLKCTRL modulemode on OMAP4
- * @oh: struct omap_hwmod *
- *
- * Disable the PRCM module mode related to the hwmod @oh.
- * Return EINVAL if the modulemode is not supported and 0 in case of success.
- */
-static int _omap4_disable_module(struct omap_hwmod *oh)
-{
-	int v;
-
-	/* The module mode does not exist prior OMAP4 */
-	if (!cpu_is_omap44xx())
-		return -EINVAL;
-
-	if (!oh->clkdm || !oh->prcm.omap4.modulemode)
-		return -EINVAL;
-
-	pr_debug("omap_hwmod: %s: %s\n", oh->name, __func__);
-
-	omap4_cminst_module_disable(oh->clkdm->prcm_partition,
-				    oh->clkdm->cm_inst,
-				    oh->clkdm->clkdm_offs,
-				    oh->prcm.omap4.clkctrl_offs);
-
-	v = _omap4_wait_target_disable(oh);
-	if (v)
-		pr_warn("omap_hwmod: %s: _wait_target_disable failed\n",
-			oh->name);
-
-	return 0;
-}
-
 /**
  * _count_mpu_irqs - count the number of MPU IRQ lines associated with @oh
  * @oh: struct omap_hwmod *oh
@@ -1377,6 +1344,66 @@ static int _read_hardreset(struct omap_hwmod *oh, const char *name)
 	}
 }
 
+/**
+ * _are_any_hardreset_lines_asserted - return true if part of @oh is hard-reset
+ * @oh: struct omap_hwmod *
+ *
+ * If any hardreset line associated with @oh is asserted, then return true.
+ * Otherwise, if @oh has no hardreset lines associated with it, or if
+ * no hardreset lines associated with @oh are asserted, then return false.
+ * This function is used to avoid executing some parts of the IP block
+ * enable/disable sequence if a hardreset line is set.
+ */
+static bool _are_any_hardreset_lines_asserted(struct omap_hwmod *oh)
+{
+	int i;
+
+	if (oh->rst_lines_cnt == 0)
+		return false;
+
+	for (i = 0; i < oh->rst_lines_cnt; i++)
+		if (_read_hardreset(oh, oh->rst_lines[i].name) > 0)
+			return true;
+
+	return false;
+}
+
+/**
+ * _omap4_disable_module - enable CLKCTRL modulemode on OMAP4
+ * @oh: struct omap_hwmod *
+ *
+ * Disable the PRCM module mode related to the hwmod @oh.
+ * Return EINVAL if the modulemode is not supported and 0 in case of success.
+ */
+static int _omap4_disable_module(struct omap_hwmod *oh)
+{
+	int v;
+
+	/* The module mode does not exist prior OMAP4 */
+	if (!cpu_is_omap44xx())
+		return -EINVAL;
+
+	if (!oh->clkdm || !oh->prcm.omap4.modulemode)
+		return -EINVAL;
+
+	pr_debug("omap_hwmod: %s: %s\n", oh->name, __func__);
+
+	omap4_cminst_module_disable(oh->clkdm->prcm_partition,
+				    oh->clkdm->cm_inst,
+				    oh->clkdm->clkdm_offs,
+				    oh->prcm.omap4.clkctrl_offs);
+
+	if (_are_any_hardreset_lines_asserted(oh))
+		return 0;
+
+	v = _omap4_wait_target_disable(oh);
+	if (v)
+		pr_warn("omap_hwmod: %s: _wait_target_disable failed\n",
+			oh->name);
+
+	return 0;
+}
+
 /**
  * _ocp_softreset - reset an omap_hwmod via the OCP_SYSCONFIG bit
  * @oh: struct omap_hwmod *
@@ -1528,7 +1555,7 @@ static int _reset(struct omap_hwmod *oh)
  */
 static int _enable(struct omap_hwmod *oh)
 {
-	int r, i;
+	int r;
 	int hwsup = 0;
 
 	pr_debug("omap_hwmod: %s: enabling\n", oh->name);
@@ -1560,14 +1587,16 @@ static int _enable(struct omap_hwmod *oh)
 	}
 
 	/*
-	 * If an IP contains HW reset lines, then de-assert them in order
-	 * to allow the module state transition. Otherwise the PRCM will return
-	 * Intransition status, and the init will failed.
+	 * If an IP block contains HW reset lines and any of them are
+	 * asserted, we let integration code associated with that
+	 * block handle the enable.  We've received very little
+	 * information on what those driver authors need, and until
+	 * detailed information is provided and the driver code is
+	 * posted to the public lists, this is probably the best we
+	 * can do.
 	 */
-	if (oh->_state == _HWMOD_STATE_INITIALIZED ||
-	    oh->_state == _HWMOD_STATE_DISABLED)
-		for (i = 0; i < oh->rst_lines_cnt; i++)
-			_deassert_hardreset(oh, oh->rst_lines[i].name);
+	if (_are_any_hardreset_lines_asserted(oh))
+		return 0;
 
 	/* Mux pins for device runtime if populated */
 	if (oh->mux && (!oh->mux->enabled ||
@@ -1642,6 +1671,9 @@ static int _idle(struct omap_hwmod *oh)
 		return -EINVAL;
 	}
 
+	if (_are_any_hardreset_lines_asserted(oh))
+		return 0;
+
 	if (oh->class->sysc)
 		_idle_sysc(oh);
 	_del_initiator_dep(oh, mpu_oh);
@@ -1724,6 +1756,9 @@ static int _shutdown(struct omap_hwmod *oh)
 		return -EINVAL;
 	}
 
+	if (_are_any_hardreset_lines_asserted(oh))
+		return 0;
+
 	pr_debug("omap_hwmod: %s: disabling\n", oh->name);
 
 	if (oh->class->pre_shutdown) {
@@ -1866,21 +1901,13 @@ static int __init _setup_reset(struct omap_hwmod *oh)
 	if (oh->_state != _HWMOD_STATE_INITIALIZED)
 		return -EINVAL;
 
-	/*
-	 * In the case of hwmod with hardreset that should not be
-	 * de-assert at boot time, we have to keep the module
-	 * initialized, because we cannot enable it properly with the
-	 * reset asserted. Exit without warning because that behavior
-	 * is expected.
-	 */
-	if ((oh->flags & HWMOD_INIT_NO_RESET) && oh->rst_lines_cnt > 0)
-		return 0;
-
-	r = _enable(oh);
-	if (r) {
-		pr_warning("omap_hwmod: %s: cannot be enabled (%d)\n",
-			   oh->name, oh->_state);
-		return 0;
+	if (oh->rst_lines_cnt == 0) {
+		r = _enable(oh);
+		if (r) {
+			pr_warning("omap_hwmod: %s: cannot be enabled for reset (%d)\n",
+				   oh->name, oh->_state);
+			return -EINVAL;
+		}
 	}
 
 	if (!(oh->flags & HWMOD_INIT_NO_RESET))

commit 64813c3fa68fc3e93e99187d313126710d7c4b0d
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Apr 18 19:10:03 2012 -0600

    ARM: OMAP2+: hwmod: reorganize and document the reset and configuration process
    
    Reorganize the code involved in resetting and configuring an IP block
    to make it easier to read and maintain.  This involves improving
    documentation, splitting some large functions up into smaller ones to
    better conform with Documentation/CodingStyle, and removing some
    unnecessary code.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 503832e20d56..6c6d31b432d2 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1534,10 +1534,9 @@ static int _enable(struct omap_hwmod *oh)
 	pr_debug("omap_hwmod: %s: enabling\n", oh->name);
 
 	/*
-	 * hwmods with HWMOD_INIT_NO_IDLE flag set are left
-	 * in enabled state at init.
-	 * Now that someone is really trying to enable them,
-	 * just ensure that the hwmod mux is set.
+	 * hwmods with HWMOD_INIT_NO_IDLE flag set are left in enabled
+	 * state at init.  Now that someone is really trying to enable
+	 * them, just ensure that the hwmod mux is set.
 	 */
 	if (oh->_int_flags & _HWMOD_SKIP_ENABLE) {
 		/*
@@ -1819,46 +1818,60 @@ static int __init _init(struct omap_hwmod *oh, void *data)
 }
 
 /**
- * _setup - do initial configuration of omap_hwmod
+ * _setup_iclk_autoidle - configure an IP block's interface clocks
  * @oh: struct omap_hwmod *
  *
- * Writes the CLOCKACTIVITY bits @clockact to the hwmod @oh
- * OCP_SYSCONFIG register.  Returns 0.
+ * Set up the module's interface clocks.  XXX This function is still mostly
+ * a stub; implementing this properly requires iclk autoidle usecounting in
+ * the clock code.   No return value.
  */
-static int _setup(struct omap_hwmod *oh, void *data)
+static void __init _setup_iclk_autoidle(struct omap_hwmod *oh)
 {
-	int i, r;
-	u8 postsetup_state;
+	int i;
 
 	if (oh->_state != _HWMOD_STATE_INITIALIZED)
-		return 0;
+		return;
 
-	/* Set iclk autoidle mode */
-	if (oh->slaves_cnt > 0) {
-		for (i = 0; i < oh->slaves_cnt; i++) {
-			struct omap_hwmod_ocp_if *os = oh->slaves[i];
-			struct clk *c = os->_clk;
+	for (i = 0; i < oh->slaves_cnt; i++) {
+		struct omap_hwmod_ocp_if *os = oh->slaves[i];
+		struct clk *c = os->_clk;
 
-			if (!c)
-				continue;
+		if (!c)
+			continue;
 
-			if (os->flags & OCPIF_SWSUP_IDLE) {
-				/* XXX omap_iclk_deny_idle(c); */
-			} else {
-				/* XXX omap_iclk_allow_idle(c); */
-				clk_enable(c);
-			}
+		if (os->flags & OCPIF_SWSUP_IDLE) {
+			/* XXX omap_iclk_deny_idle(c); */
+		} else {
+			/* XXX omap_iclk_allow_idle(c); */
+			clk_enable(c);
 		}
 	}
 
-	oh->_state = _HWMOD_STATE_INITIALIZED;
+	return;
+}
+
+/**
+ * _setup_reset - reset an IP block during the setup process
+ * @oh: struct omap_hwmod *
+ *
+ * Reset the IP block corresponding to the hwmod @oh during the setup
+ * process.  The IP block is first enabled so it can be successfully
+ * reset.  Returns 0 upon success or a negative error code upon
+ * failure.
+ */
+static int __init _setup_reset(struct omap_hwmod *oh)
+{
+	int r;
+
+	if (oh->_state != _HWMOD_STATE_INITIALIZED)
+		return -EINVAL;
 
 	/*
 	 * In the case of hwmod with hardreset that should not be
 	 * de-assert at boot time, we have to keep the module
 	 * initialized, because we cannot enable it properly with the
-	 * reset asserted. Exit without warning because that behavior is
-	 * expected.
+	 * reset asserted. Exit without warning because that behavior
+	 * is expected.
 	 */
 	if ((oh->flags & HWMOD_INIT_NO_RESET) && oh->rst_lines_cnt > 0)
 		return 0;
@@ -1871,7 +1884,53 @@ static int _setup(struct omap_hwmod *oh, void *data)
 	}
 
 	if (!(oh->flags & HWMOD_INIT_NO_RESET))
-		_reset(oh);
+		r = _reset(oh);
+
+	return r;
+}
+
+/**
+ * _setup_postsetup - transition to the appropriate state after _setup
+ * @oh: struct omap_hwmod *
+ *
+ * Place an IP block represented by @oh into a "post-setup" state --
+ * either IDLE, ENABLED, or DISABLED.  ("post-setup" simply means that
+ * this function is called at the end of _setup().)  The postsetup
+ * state for an IP block can be changed by calling
+ * omap_hwmod_enter_postsetup_state() early in the boot process,
+ * before one of the omap_hwmod_setup*() functions are called for the
+ * IP block.
+ *
+ * The IP block stays in this state until a PM runtime-based driver is
+ * loaded for that IP block.  A post-setup state of IDLE is
+ * appropriate for almost all IP blocks with runtime PM-enabled
+ * drivers, since those drivers are able to enable the IP block.  A
+ * post-setup state of ENABLED is appropriate for kernels with PM
+ * runtime disabled.  The DISABLED state is appropriate for unusual IP
+ * blocks such as the MPU WDTIMER on kernels without WDTIMER drivers
+ * included, since the WDTIMER starts running on reset and will reset
+ * the MPU if left active.
+ *
+ * This post-setup mechanism is deprecated.  Once all of the OMAP
+ * drivers have been converted to use PM runtime, and all of the IP
+ * block data and interconnect data is available to the hwmod code, it
+ * should be possible to replace this mechanism with a "lazy reset"
+ * arrangement.  In a "lazy reset" setup, each IP block is enabled
+ * when the driver first probes, then all remaining IP blocks without
+ * drivers are either shut down or enabled after the drivers have
+ * loaded.  However, this cannot take place until the above
+ * preconditions have been met, since otherwise the late reset code
+ * has no way of knowing which IP blocks are in use by drivers, and
+ * which ones are unused.
+ *
+ * No return value.
+ */
+static void __init _setup_postsetup(struct omap_hwmod *oh)
+{
+	u8 postsetup_state;
+
+	if (oh->rst_lines_cnt > 0)
+		return;
 
 	postsetup_state = oh->_postsetup_state;
 	if (postsetup_state == _HWMOD_STATE_UNKNOWN)
@@ -1895,6 +1954,35 @@ static int _setup(struct omap_hwmod *oh, void *data)
 		WARN(1, "hwmod: %s: unknown postsetup state %d! defaulting to enabled\n",
 		     oh->name, postsetup_state);
 
+	return;
+}
+
+/**
+ * _setup - prepare IP block hardware for use
+ * @oh: struct omap_hwmod *
+ * @n: (unused, pass NULL)
+ *
+ * Configure the IP block represented by @oh.  This may include
+ * enabling the IP block, resetting it, and placing it into a
+ * post-setup state, depending on the type of IP block and applicable
+ * flags.  IP blocks are reset to prevent any previous configuration
+ * by the bootloader or previous operating system from interfering
+ * with power management or other parts of the system.  The reset can
+ * be avoided; see omap_hwmod_no_setup_reset().  This is the second of
+ * two phases for hwmod initialization.  Code called here generally
+ * affects the IP block hardware, or system integration hardware
+ * associated with the IP block.  Returns 0.
+ */
+static int __init _setup(struct omap_hwmod *oh, void *data)
+{
+	if (oh->_state != _HWMOD_STATE_INITIALIZED)
+		return 0;
+
+	_setup_iclk_autoidle(oh);
+
+	if (!_setup_reset(oh))
+		_setup_postsetup(oh);
+
 	return 0;
 }
 
@@ -2700,10 +2788,10 @@ int omap_hwmod_for_each_by_class(const char *classname,
  * @state: state that _setup() should leave the hwmod in
  *
  * Sets the hwmod state that @oh will enter at the end of _setup()
- * (called by omap_hwmod_setup_*()).  Only valid to call between
- * calling omap_hwmod_register() and omap_hwmod_setup_*().  Returns
- * 0 upon success or -EINVAL if there is a problem with the arguments
- * or if the hwmod is in the wrong state.
+ * (called by omap_hwmod_setup_*()).  See also the documentation
+ * for _setup_postsetup(), above.  Returns 0 upon success or
+ * -EINVAL if there is a problem with the arguments or if the hwmod is
+ * in the wrong state.
  */
 int omap_hwmod_set_postsetup_state(struct omap_hwmod *oh, u8 state)
 {

commit 381d033a0164afaaac2a1c35bc8bc379052595b2
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Apr 19 00:58:22 2012 -0600

    ARM: OMAP2+: hwmod: reorganize and document the initialization process
    
    Reorganize the code involved in initializing the internal data for
    each hwmod to make it easier to read and maintain.  This involves
    improving documentation and removing some duplicated and unnecessary
    code.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 5b07ad0251d7..503832e20d56 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1768,6 +1768,56 @@ static int _shutdown(struct omap_hwmod *oh)
 	return 0;
 }
 
+/**
+ * _init_mpu_rt_base - populate the virtual address for a hwmod
+ * @oh: struct omap_hwmod * to locate the virtual address
+ *
+ * Cache the virtual address used by the MPU to access this IP block's
+ * registers.  This address is needed early so the OCP registers that
+ * are part of the device's address space can be ioremapped properly.
+ * No return value.
+ */
+static void __init _init_mpu_rt_base(struct omap_hwmod *oh, void *data)
+{
+	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
+		return;
+
+	oh->_mpu_rt_va = _find_mpu_rt_base(oh, oh->_mpu_port_index);
+}
+
+/**
+ * _init - initialize internal data for the hwmod @oh
+ * @oh: struct omap_hwmod *
+ * @n: (unused)
+ *
+ * Look up the clocks and the address space used by the MPU to access
+ * registers belonging to the hwmod @oh.  @oh must already be
+ * registered at this point.  This is the first of two phases for
+ * hwmod initialization.  Code called here does not touch any hardware
+ * registers, it simply prepares internal data structures.  Returns 0
+ * upon success or if the hwmod isn't registered, or -EINVAL upon
+ * failure.
+ */
+static int __init _init(struct omap_hwmod *oh, void *data)
+{
+	int r;
+
+	if (oh->_state != _HWMOD_STATE_REGISTERED)
+		return 0;
+
+	_init_mpu_rt_base(oh, NULL);
+
+	r = _init_clocks(oh, NULL);
+	if (IS_ERR_VALUE(r)) {
+		WARN(1, "omap_hwmod: %s: couldn't init clocks\n", oh->name);
+		return -EINVAL;
+	}
+
+	oh->_state = _HWMOD_STATE_INITIALIZED;
+
+	return 0;
+}
+
 /**
  * _setup - do initial configuration of omap_hwmod
  * @oh: struct omap_hwmod *
@@ -1780,7 +1830,7 @@ static int _setup(struct omap_hwmod *oh, void *data)
 	int i, r;
 	u8 postsetup_state;
 
-	if (oh->_state != _HWMOD_STATE_CLKS_INITED)
+	if (oh->_state != _HWMOD_STATE_INITIALIZED)
 		return 0;
 
 	/* Set iclk autoidle mode */
@@ -2052,96 +2102,69 @@ int __init omap_hwmod_register(struct omap_hwmod **ohs)
 	return 0;
 }
 
-/*
- * _populate_mpu_rt_base - populate the virtual address for a hwmod
+/**
+ * _ensure_mpu_hwmod_is_setup - ensure the MPU SS hwmod is init'ed and set up
+ * @oh: pointer to the hwmod currently being set up (usually not the MPU)
  *
- * Must be called only from omap_hwmod_setup_*() so ioremap works properly.
- * Assumes the caller takes care of locking if needed.
+ * If the hwmod data corresponding to the MPU subsystem IP block
+ * hasn't been initialized and set up yet, do so now.  This must be
+ * done first since sleep dependencies may be added from other hwmods
+ * to the MPU.  Intended to be called only by omap_hwmod_setup*().  No
+ * return value.
  */
-static int __init _populate_mpu_rt_base(struct omap_hwmod *oh, void *data)
+static void __init _ensure_mpu_hwmod_is_setup(struct omap_hwmod *oh)
 {
-	if (oh->_state != _HWMOD_STATE_REGISTERED)
-		return 0;
-
-	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
-		return 0;
-
-	oh->_mpu_rt_va = _find_mpu_rt_base(oh, oh->_mpu_port_index);
-
-	return 0;
+	if (!mpu_oh || mpu_oh->_state == _HWMOD_STATE_UNKNOWN)
+		pr_err("omap_hwmod: %s: MPU initiator hwmod %s not yet registered\n",
+		       __func__, MPU_INITIATOR_NAME);
+	else if (mpu_oh->_state == _HWMOD_STATE_REGISTERED && oh != mpu_oh)
+		omap_hwmod_setup_one(MPU_INITIATOR_NAME);
 }
 
 /**
  * omap_hwmod_setup_one - set up a single hwmod
  * @oh_name: const char * name of the already-registered hwmod to set up
  *
- * Must be called after omap2_clk_init().  Resolves the struct clk
- * names to struct clk pointers for each registered omap_hwmod.  Also
- * calls _setup() on each hwmod.  Returns -EINVAL upon error or 0 upon
- * success.
+ * Initialize and set up a single hwmod.  Intended to be used for a
+ * small number of early devices, such as the timer IP blocks used for
+ * the scheduler clock.  Must be called after omap2_clk_init().
+ * Resolves the struct clk names to struct clk pointers for each
+ * registered omap_hwmod.  Also calls _setup() on each hwmod.  Returns
+ * -EINVAL upon error or 0 upon success.
  */
 int __init omap_hwmod_setup_one(const char *oh_name)
 {
 	struct omap_hwmod *oh;
-	int r;
 
 	pr_debug("omap_hwmod: %s: %s\n", oh_name, __func__);
 
-	if (!mpu_oh) {
-		pr_err("omap_hwmod: %s: cannot setup_one: MPU initiator hwmod %s not yet registered\n",
-		       oh_name, MPU_INITIATOR_NAME);
-		return -EINVAL;
-	}
-
 	oh = _lookup(oh_name);
 	if (!oh) {
 		WARN(1, "omap_hwmod: %s: hwmod not yet registered\n", oh_name);
 		return -EINVAL;
 	}
 
-	if (mpu_oh->_state == _HWMOD_STATE_REGISTERED && oh != mpu_oh)
-		omap_hwmod_setup_one(MPU_INITIATOR_NAME);
-
-	r = _populate_mpu_rt_base(oh, NULL);
-	if (IS_ERR_VALUE(r)) {
-		WARN(1, "omap_hwmod: %s: couldn't set mpu_rt_base\n", oh_name);
-		return -EINVAL;
-	}
-
-	r = _init_clocks(oh, NULL);
-	if (IS_ERR_VALUE(r)) {
-		WARN(1, "omap_hwmod: %s: couldn't init clocks\n", oh_name);
-		return -EINVAL;
-	}
+	_ensure_mpu_hwmod_is_setup(oh);
 
+	_init(oh, NULL);
 	_setup(oh, NULL);
 
 	return 0;
 }
 
 /**
- * omap_hwmod_setup - do some post-clock framework initialization
+ * omap_hwmod_setup_all - set up all registered IP blocks
  *
- * Must be called after omap2_clk_init().  Resolves the struct clk names
- * to struct clk pointers for each registered omap_hwmod.  Also calls
- * _setup() on each hwmod.  Returns 0 upon success.
+ * Initialize and set up all IP blocks registered with the hwmod code.
+ * Must be called after omap2_clk_init().  Resolves the struct clk
+ * names to struct clk pointers for each registered omap_hwmod.  Also
+ * calls _setup() on each hwmod.  Returns 0 upon success.
  */
 static int __init omap_hwmod_setup_all(void)
 {
-	int r;
-
-	if (!mpu_oh) {
-		pr_err("omap_hwmod: %s: MPU initiator hwmod %s not yet registered\n",
-		       __func__, MPU_INITIATOR_NAME);
-		return -EINVAL;
-	}
-
-	r = omap_hwmod_for_each(_populate_mpu_rt_base, NULL);
-
-	r = omap_hwmod_for_each(_init_clocks, NULL);
-	WARN(IS_ERR_VALUE(r),
-	     "omap_hwmod: %s: _init_clocks failed\n", __func__);
+	_ensure_mpu_hwmod_is_setup(NULL);
 
+	omap_hwmod_for_each(_init, NULL);
 	omap_hwmod_for_each(_setup, NULL);
 
 	return 0;

commit 30e105c000abbac55602b37f4831437bca5487b0
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Apr 19 00:49:09 2012 -0600

    ARM: OMAP2+: hwmod: revise the IP block reset process
    
    Revise the IP block reset process.  This patch ensures that the
    OCP_SYSCONFIG registers are reloaded after a custom reset.  Since
    OCP_SYSCONFIG bits are cleared during reset, they should be
    reprogrammed unless the IP block is being left in reset.  (The only IP
    blocks that are left in reset are IP blocks with hardreset lines and
    no custom reset function.)  If the IP block is left in reset, then it
    is inaccessible to the MPU, and an access to the OCP_SYSCONFIG
    register will cause an abort.
    
    This version incorporates comments from Omar Ramirez Luna
    <omar.ramirez@ti.com> to skip the OCP_SYSCONFIG access after asserting
    hardreset lines.  This allows the MMU (IOMMU) IP block, which has
    both hardreset lines and an OCP_SYSCONFIG register.
    
    Also, ignore _ocp_softreset() errors if the IP block doesn't include a
    softreset bit.  This is needed since a subsequent patch will start
    taking the return value of the _reset() function seriously.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>
    Cc: Omar Ramirez Luna <omar.ramirez@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 4997c1a8b59d..5b07ad0251d7 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2,7 +2,7 @@
  * omap_hwmod implementation for OMAP2/3/4
  *
  * Copyright (C) 2009-2011 Nokia Corporation
- * Copyright (C) 2011 Texas Instruments, Inc.
+ * Copyright (C) 2011-2012 Texas Instruments, Inc.
  *
  * Paul Walmsley, Benot Cousson, Kevin Hilman
  *
@@ -1382,9 +1382,9 @@ static int _read_hardreset(struct omap_hwmod *oh, const char *name)
  * @oh: struct omap_hwmod *
  *
  * Resets an omap_hwmod @oh via the OCP_SYSCONFIG bit.  hwmod must be
- * enabled for this to work.  Returns -EINVAL if the hwmod cannot be
- * reset this way or if the hwmod is in the wrong state, -ETIMEDOUT if
- * the module did not reset in time, or 0 upon success.
+ * enabled for this to work.  Returns -ENOENT if the hwmod cannot be
+ * reset this way, -EINVAL if the hwmod is in the wrong state,
+ * -ETIMEDOUT if the module did not reset in time, or 0 upon success.
  *
  * In OMAP3 a specific SYSSTATUS register is used to get the reset status.
  * Starting in OMAP4, some IPs do not have SYSSTATUS registers and instead
@@ -1401,7 +1401,7 @@ static int _ocp_softreset(struct omap_hwmod *oh)
 
 	if (!oh->class->sysc ||
 	    !(oh->class->sysc->sysc_flags & SYSC_HAS_SOFTRESET))
-		return -EINVAL;
+		return -ENOENT;
 
 	/* clocks must be on for this operation */
 	if (oh->_state != _HWMOD_STATE_ENABLED) {
@@ -1462,37 +1462,60 @@ static int _ocp_softreset(struct omap_hwmod *oh)
  * _reset - reset an omap_hwmod
  * @oh: struct omap_hwmod *
  *
- * Resets an omap_hwmod @oh.  The default software reset mechanism for
- * most OMAP IP blocks is triggered via the OCP_SYSCONFIG.SOFTRESET
- * bit.  However, some hwmods cannot be reset via this method: some
- * are not targets and therefore have no OCP header registers to
- * access; others (like the IVA) have idiosyncratic reset sequences.
- * So for these relatively rare cases, custom reset code can be
- * supplied in the struct omap_hwmod_class .reset function pointer.
- * Passes along the return value from either _reset() or the custom
- * reset function - these must return -EINVAL if the hwmod cannot be
- * reset this way or if the hwmod is in the wrong state, -ETIMEDOUT if
- * the module did not reset in time, or 0 upon success.
+ * Resets an omap_hwmod @oh.  If the module has a custom reset
+ * function pointer defined, then call it to reset the IP block, and
+ * pass along its return value to the caller.  Otherwise, if the IP
+ * block has an OCP_SYSCONFIG register with a SOFTRESET bitfield
+ * associated with it, call a function to reset the IP block via that
+ * method, and pass along the return value to the caller.  Finally, if
+ * the IP block has some hardreset lines associated with it, assert
+ * all of those, but do _not_ deassert them. (This is because driver
+ * authors have expressed an apparent requirement to control the
+ * deassertion of the hardreset lines themselves.)
+ *
+ * The default software reset mechanism for most OMAP IP blocks is
+ * triggered via the OCP_SYSCONFIG.SOFTRESET bit.  However, some
+ * hwmods cannot be reset via this method.  Some are not targets and
+ * therefore have no OCP header registers to access.  Others (like the
+ * IVA) have idiosyncratic reset sequences.  So for these relatively
+ * rare cases, custom reset code can be supplied in the struct
+ * omap_hwmod_class .reset function pointer.  Passes along the return
+ * value from either _ocp_softreset() or the custom reset function -
+ * these must return -EINVAL if the hwmod cannot be reset this way or
+ * if the hwmod is in the wrong state, -ETIMEDOUT if the module did
+ * not reset in time, or 0 upon success.
  */
 static int _reset(struct omap_hwmod *oh)
 {
-	int ret;
+	int i, r;
 
 	pr_debug("omap_hwmod: %s: resetting\n", oh->name);
 
+	if (oh->class->reset) {
+		r = oh->class->reset(oh);
+	} else {
+		if (oh->rst_lines_cnt > 0) {
+			for (i = 0; i < oh->rst_lines_cnt; i++)
+				_assert_hardreset(oh, oh->rst_lines[i].name);
+			return 0;
+		} else {
+			r = _ocp_softreset(oh);
+			if (r == -ENOENT)
+				r = 0;
+		}
+	}
+
 	/*
-	 * XXX We're not resetting modules with hardreset lines
-	 * automatically here.  Should we do this also, or just expect
-	 * those modules to define custom reset functions?
+	 * OCP_SYSCONFIG bits need to be reprogrammed after a
+	 * softreset.  The _enable() function should be split to avoid
+	 * the rewrite of the OCP_SYSCONFIG register.
 	 */
-	ret = (oh->class->reset) ? oh->class->reset(oh) : _ocp_softreset(oh);
-
 	if (oh->class->sysc) {
 		_update_sysc_cache(oh);
 		_enable_sysc(oh);
 	}
 
-	return ret;
+	return r;
 }
 
 /**

commit 9c8b0ec7a46c5840fddaa570933335f4ccbbd078
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Apr 18 19:10:02 2012 -0600

    ARM: OMAP2+: hwmod: control all hardreset lines attached to a hwmod
    
    Parts of the hwmod code test to see if a module has one and only one
    hardreset line before taking an action.  It seems more appropriate
    to control all hardreset lines associated with a hwmod, not just one.
    
    It so happens that with the current hwmod data, this patch will not
    change any behavior, since hwmods with hardreset lines have only one
    hardreset line associated with them, and 'pseudo-hwmods' are used to
    handle the other hardreset lines.  But future hwmod data patches to
    remove the pseudo-hwmods will change this.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 7144ae651d3d..4997c1a8b59d 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1480,6 +1480,11 @@ static int _reset(struct omap_hwmod *oh)
 
 	pr_debug("omap_hwmod: %s: resetting\n", oh->name);
 
+	/*
+	 * XXX We're not resetting modules with hardreset lines
+	 * automatically here.  Should we do this also, or just expect
+	 * those modules to define custom reset functions?
+	 */
 	ret = (oh->class->reset) ? oh->class->reset(oh) : _ocp_softreset(oh);
 
 	if (oh->class->sysc) {
@@ -1500,7 +1505,7 @@ static int _reset(struct omap_hwmod *oh)
  */
 static int _enable(struct omap_hwmod *oh)
 {
-	int r;
+	int r, i;
 	int hwsup = 0;
 
 	pr_debug("omap_hwmod: %s: enabling\n", oh->name);
@@ -1532,15 +1537,15 @@ static int _enable(struct omap_hwmod *oh)
 		return -EINVAL;
 	}
 
-
 	/*
-	 * If an IP contains only one HW reset line, then de-assert it in order
+	 * If an IP contains HW reset lines, then de-assert them in order
 	 * to allow the module state transition. Otherwise the PRCM will return
 	 * Intransition status, and the init will failed.
 	 */
-	if ((oh->_state == _HWMOD_STATE_INITIALIZED ||
-	     oh->_state == _HWMOD_STATE_DISABLED) && oh->rst_lines_cnt == 1)
-		_deassert_hardreset(oh, oh->rst_lines[0].name);
+	if (oh->_state == _HWMOD_STATE_INITIALIZED ||
+	    oh->_state == _HWMOD_STATE_DISABLED)
+		for (i = 0; i < oh->rst_lines_cnt; i++)
+			_deassert_hardreset(oh, oh->rst_lines[i].name);
 
 	/* Mux pins for device runtime if populated */
 	if (oh->mux && (!oh->mux->enabled ||
@@ -1687,7 +1692,7 @@ int omap_hwmod_set_ocp_autoidle(struct omap_hwmod *oh, u8 autoidle)
  */
 static int _shutdown(struct omap_hwmod *oh)
 {
-	int ret;
+	int ret, i;
 	u8 prev_state;
 
 	if (oh->_state != _HWMOD_STATE_IDLE &&
@@ -1728,12 +1733,8 @@ static int _shutdown(struct omap_hwmod *oh)
 	}
 	/* XXX Should this code also force-disable the optional clocks? */
 
-	/*
-	 * If an IP contains only one HW reset line, then assert it
-	 * after disabling the clocks and before shutting down the IP.
-	 */
-	if (oh->rst_lines_cnt == 1)
-		_assert_hardreset(oh, oh->rst_lines[0].name);
+	for (i = 0; i < oh->rst_lines_cnt; i++)
+		_assert_hardreset(oh, oh->rst_lines[i].name);
 
 	/* Mux pins to safe mode or use populated off mode values */
 	if (oh->mux)
@@ -1786,7 +1787,7 @@ static int _setup(struct omap_hwmod *oh, void *data)
 	 * reset asserted. Exit without warning because that behavior is
 	 * expected.
 	 */
-	if ((oh->flags & HWMOD_INIT_NO_RESET) && oh->rst_lines_cnt == 1)
+	if ((oh->flags & HWMOD_INIT_NO_RESET) && oh->rst_lines_cnt > 0)
 		return 0;
 
 	r = _enable(oh);

commit 3c55c1baffa5f719eb2ae9729088bc867f972f53
Author: Paul Walmsley <paul@pwsan.com>
Date:   Fri Apr 13 05:08:43 2012 -0600

    ARM: OMAP2+: hwmod: Revert "ARM: OMAP2+: hwmod: Make omap_hwmod_softreset wait for reset status"
    
    This reverts commit f9a2f9c3fa76eec55928e8e06f3094c8f01df7cb.  This
    commit caused a regression in the I2C hwmod reset on OMAP2/3/4,
    logging messages similar to these during boot:
    
    [    0.200378] omap_hwmod: i2c1: softreset failed (waited 10000 usec)
    [    0.222076] omap_hwmod: i2c2: softreset failed (waited 10000 usec)
    
    While the original patch was intended to fix some reset-related timing
    issues, it's believed that these problems were actually fixed by
    commit 2800852a079504f35f88e44faf5c9c96318c0cca ("ARM: OMAP2+: hwmod:
    Restore sysc after a reset"):
    
        http://marc.info/?l=linux-arm-kernel&m=133410322617245&w=2
    
    Cc: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 45f1d9c44e94..7144ae651d3d 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1906,10 +1906,20 @@ void omap_hwmod_write(u32 v, struct omap_hwmod *oh, u16 reg_offs)
  */
 int omap_hwmod_softreset(struct omap_hwmod *oh)
 {
-	if (!oh)
+	u32 v;
+	int ret;
+
+	if (!oh || !(oh->_sysc_cache))
 		return -EINVAL;
 
-	return _ocp_softreset(oh);
+	v = oh->_sysc_cache;
+	ret = _set_softreset(oh, &v);
+	if (ret)
+		goto error;
+	_write_sysconfig(v, oh);
+
+error:
+	return ret;
 }
 
 /**

commit d99de7f552fac43e24fd4fb8048d8f21abaea691
Author: Fernando Guzman Lugo <fernando.lugo@ti.com>
Date:   Fri Apr 13 05:08:03 2012 -0600

    ARM: OMAP2+: hwmod: add softreset delay field and OMAP4 data
    
    Due to HW limitation, some IPs should not be accessed just after a
    softreset. Since the current hwmod sequence is accessing the sysconfig
    register just after the reset, it might lead to OCP bus error in
    that case.
    
    Add a new field in the sysconfig structure to specify a delay in usecs
    needed after doing a softreset.
    
    In the case of the ISS and FDIF modules, the L3 OCP port will be
    disconnected upon a SW reset. That issue was confirmed with HW simulation
    and an errata should be available soon. The HW recommendation to avoid
    that is to wait for 100 OCP clk cycles, before accessing the IP.
    
    Considering the worse case (OPP50), the L3 bus will run at 100 MHz,
    so a 1 usec delay is needed. Add an x2 margin to be safe.
    
    Acked-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Fernando Guzman Lugo <fernando.lugo@ti.com>
    [paul@pwsan.com: dropped FDIF change for now since the hwmod data is not
     yet upstream; the FDIF change will need to be added later once the FDIF
     data is merged]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 2c27fdb61e66..45f1d9c44e94 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1422,6 +1422,9 @@ static int _ocp_softreset(struct omap_hwmod *oh)
 		goto dis_opt_clks;
 	_write_sysconfig(v, oh);
 
+	if (oh->class->sysc->srst_udelay)
+		udelay(oh->class->sysc->srst_udelay);
+
 	if (oh->class->sysc->sysc_flags & SYSS_HAS_RESET_STATUS)
 		omap_test_timeout((omap_hwmod_read(oh,
 						    oh->class->sysc->syss_offs)

commit a8f5b6e5ef0faf64997bfa87698aaabc989e64c4
Merge: 1ac02d795889 a9dd31b744a0
Author: Olof Johansson <olof@lixom.net>
Date:   Thu Apr 5 17:09:45 2012 -0700

    Merge tag 'omap-fixes-a2-for-3.4rc' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into fixes
    
    From Paul Walmsley:
    
    OMAP clock, powerdomain, clockdomain, and hwmod fixes intended for the
    early v3.4-rc series.  Also contains an HSMMC integration refinement
    of an earlier hardware bug workaround.
    
    * tag 'omap-fixes-a2-for-3.4rc' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending:
      ARM: OMAP2+: hwmod: Fix wrong SYSC_TYPE1_XXX_MASK bit definitions
      ARM: OMAP2+: hwmod: Make omap_hwmod_softreset wait for reset status
      ARM: OMAP2+: hwmod: Restore sysc after a reset
      ARM: OMAP2+: omap_hwmod: Allow io_ring wakeup configuration for all modules
      ARM: OMAP3: clock data: fill in some missing clockdomains
      ARM: OMAP4: clock data: Force a DPLL clkdm/pwrdm ON before a relock
      ARM: OMAP4: clock data: fix mult and div mask for USB_DPLL
      ARM: OMAP2+: powerdomain: Wait for powerdomain transition in pwrdm_state_switch()
      ARM: OMAP AM3517/3505: clock data: change EMAC clocks aliases
      ARM: OMAP: clock: fix race in disable all clocks
      ARM: OMAP4: hwmod data: Add aliases for McBSP fclk clocks
      ARM: OMAP3xxx: clock data: fix DPLL4 CLKSEL masks
      ARM: OMAP3xxx: HSMMC: avoid erratum workaround when transceiver is attached
      ARM: OMAP44xx: clockdomain data: correct the emu_sys_clkdm CLKTRCTRL data

commit f9a2f9c3fa76eec55928e8e06f3094c8f01df7cb
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Tue Mar 13 22:55:24 2012 +0530

    ARM: OMAP2+: hwmod: Make omap_hwmod_softreset wait for reset status
    
    omap_hwmod_softreset() does not seem to wait for reset status
    after doing a softreset. Make it use _ocp_softreset() instead
    which does this correctly.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Anand Gadiyar <gadiyar@ti.com>
    Cc: Shubhrajyoti D <shubhrajyoti@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index d32c1ce4f3ab..72903d42ab0d 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1901,20 +1901,10 @@ void omap_hwmod_write(u32 v, struct omap_hwmod *oh, u16 reg_offs)
  */
 int omap_hwmod_softreset(struct omap_hwmod *oh)
 {
-	u32 v;
-	int ret;
-
-	if (!oh || !(oh->_sysc_cache))
+	if (!oh)
 		return -EINVAL;
 
-	v = oh->_sysc_cache;
-	ret = _set_softreset(oh, &v);
-	if (ret)
-		goto error;
-	_write_sysconfig(v, oh);
-
-error:
-	return ret;
+	return _ocp_softreset(oh);
 }
 
 /**

commit 2800852a079504f35f88e44faf5c9c96318c0cca
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Tue Mar 13 22:55:23 2012 +0530

    ARM: OMAP2+: hwmod: Restore sysc after a reset
    
    After a softreset, make sure the sysc settings are correctly
    restored.
    
    Reported-by: Anand Gadiyar <gadiyar@ti.com>
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Shubhrajyoti D <shubhrajyoti@ti.com>
    [paul@pwsan.com: combined post-reset SYSCONFIG reload code into the
     _reset() function to avoid duplication and future mistakes]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 5a680108195b..d32c1ce4f3ab 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1477,6 +1477,11 @@ static int _reset(struct omap_hwmod *oh)
 
 	ret = (oh->class->reset) ? oh->class->reset(oh) : _ocp_softreset(oh);
 
+	if (oh->class->sysc) {
+		_update_sysc_cache(oh);
+		_enable_sysc(oh);
+	}
+
 	return ret;
 }
 
@@ -1786,20 +1791,9 @@ static int _setup(struct omap_hwmod *oh, void *data)
 		return 0;
 	}
 
-	if (!(oh->flags & HWMOD_INIT_NO_RESET)) {
+	if (!(oh->flags & HWMOD_INIT_NO_RESET))
 		_reset(oh);
 
-		/*
-		 * OCP_SYSCONFIG bits need to be reprogrammed after a softreset.
-		 * The _enable() function should be split to
-		 * avoid the rewrite of the OCP_SYSCONFIG register.
-		 */
-		if (oh->class->sysc) {
-			_update_sysc_cache(oh);
-			_enable_sysc(oh);
-		}
-	}
-
 	postsetup_state = oh->_postsetup_state;
 	if (postsetup_state == _HWMOD_STATE_UNKNOWN)
 		postsetup_state = _HWMOD_STATE_ENABLED;

commit 2a1cc1445a51e3a81c10d294586756cdb9174469
Author: Govindraj.R <govindraj.raja@ti.com>
Date:   Thu Apr 5 02:59:32 2012 -0600

    ARM: OMAP2+: omap_hwmod: Allow io_ring wakeup configuration for all modules
    
    Some modules doesn't have SYSC_HAS_ENAWAKEUP bit available (ex: usb
    host uhh module) in absence of this flag
    omap_hwmod_enable/disable_wakeup avoids configuring pad mux wakeup
    capability.
    
    Configure sysc if SYSC_HAS_ENAWAKEUP is available and for other cases
    try enabling/disabling wakeup from mux_pad pins.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Govindraj.R <govindraj.raja@ti.com>
    [paul@pwsan.com: updated function kerneldoc documentation]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index eba6cd3816f5..5a680108195b 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2463,26 +2463,28 @@ int omap_hwmod_del_initiator_dep(struct omap_hwmod *oh,
  * @oh: struct omap_hwmod *
  *
  * Sets the module OCP socket ENAWAKEUP bit to allow the module to
- * send wakeups to the PRCM.  Eventually this should sets PRCM wakeup
- * registers to cause the PRCM to receive wakeup events from the
- * module.  Does not set any wakeup routing registers beyond this
- * point - if the module is to wake up any other module or subsystem,
- * that must be set separately.  Called by omap_device code.  Returns
- * -EINVAL on error or 0 upon success.
+ * send wakeups to the PRCM, and enable I/O ring wakeup events for
+ * this IP block if it has dynamic mux entries.  Eventually this
+ * should set PRCM wakeup registers to cause the PRCM to receive
+ * wakeup events from the module.  Does not set any wakeup routing
+ * registers beyond this point - if the module is to wake up any other
+ * module or subsystem, that must be set separately.  Called by
+ * omap_device code.  Returns -EINVAL on error or 0 upon success.
  */
 int omap_hwmod_enable_wakeup(struct omap_hwmod *oh)
 {
 	unsigned long flags;
 	u32 v;
 
-	if (!oh->class->sysc ||
-	    !(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP))
-		return -EINVAL;
-
 	spin_lock_irqsave(&oh->_lock, flags);
-	v = oh->_sysc_cache;
-	_enable_wakeup(oh, &v);
-	_write_sysconfig(v, oh);
+
+	if (oh->class->sysc &&
+	    (oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP)) {
+		v = oh->_sysc_cache;
+		_enable_wakeup(oh, &v);
+		_write_sysconfig(v, oh);
+	}
+
 	_set_idle_ioring_wakeup(oh, true);
 	spin_unlock_irqrestore(&oh->_lock, flags);
 
@@ -2494,26 +2496,28 @@ int omap_hwmod_enable_wakeup(struct omap_hwmod *oh)
  * @oh: struct omap_hwmod *
  *
  * Clears the module OCP socket ENAWAKEUP bit to prevent the module
- * from sending wakeups to the PRCM.  Eventually this should clear
- * PRCM wakeup registers to cause the PRCM to ignore wakeup events
- * from the module.  Does not set any wakeup routing registers beyond
- * this point - if the module is to wake up any other module or
- * subsystem, that must be set separately.  Called by omap_device
- * code.  Returns -EINVAL on error or 0 upon success.
+ * from sending wakeups to the PRCM, and disable I/O ring wakeup
+ * events for this IP block if it has dynamic mux entries.  Eventually
+ * this should clear PRCM wakeup registers to cause the PRCM to ignore
+ * wakeup events from the module.  Does not set any wakeup routing
+ * registers beyond this point - if the module is to wake up any other
+ * module or subsystem, that must be set separately.  Called by
+ * omap_device code.  Returns -EINVAL on error or 0 upon success.
  */
 int omap_hwmod_disable_wakeup(struct omap_hwmod *oh)
 {
 	unsigned long flags;
 	u32 v;
 
-	if (!oh->class->sysc ||
-	    !(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP))
-		return -EINVAL;
-
 	spin_lock_irqsave(&oh->_lock, flags);
-	v = oh->_sysc_cache;
-	_disable_wakeup(oh, &v);
-	_write_sysconfig(v, oh);
+
+	if (oh->class->sysc &&
+	    (oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP)) {
+		v = oh->_sysc_cache;
+		_disable_wakeup(oh, &v);
+		_write_sysconfig(v, oh);
+	}
+
 	_set_idle_ioring_wakeup(oh, false);
 	spin_unlock_irqrestore(&oh->_lock, flags);
 

commit 387ca5bf4fe2297c93869b6f639afa8d849fb877
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Mon Mar 12 04:29:58 2012 -0600

    ARM: OMAP: hwmod: Use sysc_fields->srst_shift and get rid of hardcoded SYSC_TYPE2_SOFTRESET_MASK
    
    This is useful when we have broken type2 compliant IPs' where
    the softreset shift is not the same as SYSC_TYPE2_SOFTRESET_SHIFT
    and hence is overridden using sysc_fields->srst_shift.
    
    We have at least one such instance now with onchip keypad on OMAP5
    which has a different softreset shift as compared to other type2
    IPs'.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Balaji TK  <balajitk@ti.com>
    Tested-by: Sourav Poddar <sourav.poddar@ti.com>
    Acked-by: Benot Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index eba6cd3816f5..f9b9bb9c3e32 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1395,7 +1395,7 @@ static int _read_hardreset(struct omap_hwmod *oh, const char *name)
  */
 static int _ocp_softreset(struct omap_hwmod *oh)
 {
-	u32 v;
+	u32 v, softrst_mask;
 	int c = 0;
 	int ret = 0;
 
@@ -1427,11 +1427,13 @@ static int _ocp_softreset(struct omap_hwmod *oh)
 						    oh->class->sysc->syss_offs)
 				   & SYSS_RESETDONE_MASK),
 				  MAX_MODULE_SOFTRESET_WAIT, c);
-	else if (oh->class->sysc->sysc_flags & SYSC_HAS_RESET_STATUS)
+	else if (oh->class->sysc->sysc_flags & SYSC_HAS_RESET_STATUS) {
+		softrst_mask = (0x1 << oh->class->sysc->sysc_fields->srst_shift);
 		omap_test_timeout(!(omap_hwmod_read(oh,
 						     oh->class->sysc->sysc_offs)
-				   & SYSC_TYPE2_SOFTRESET_MASK),
+				   & softrst_mask),
 				  MAX_MODULE_SOFTRESET_WAIT, c);
+	}
 
 	if (c == MAX_MODULE_SOFTRESET_WAIT)
 		pr_warning("omap_hwmod: %s: softreset failed (waited %d usec)\n",

commit 4f8a428dac431e7bd09673b404769d87df948eef
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Feb 7 10:59:37 2012 +0000

    ARM: omap: fix wrapped error messages in omap_hwmod.c
    
    While trying to debug my OMAP platforms, they emitted this message:
    
    omap_hwmod: %s: enabled state can only be entered from initialized, idle, or disabled state
    
    The following backtrace said it was from a function called '_enable',
    which didn't provide much clue.  Grepping didn't find it either.
    
    The message is wrapped, so unwrap the message so grep can find it.  Do
    the same for three other messages in this file.
    
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 5192cabb40ed..eba6cd3816f5 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1517,8 +1517,8 @@ static int _enable(struct omap_hwmod *oh)
 	if (oh->_state != _HWMOD_STATE_INITIALIZED &&
 	    oh->_state != _HWMOD_STATE_IDLE &&
 	    oh->_state != _HWMOD_STATE_DISABLED) {
-		WARN(1, "omap_hwmod: %s: enabled state can only be entered "
-		     "from initialized, idle, or disabled state\n", oh->name);
+		WARN(1, "omap_hwmod: %s: enabled state can only be entered from initialized, idle, or disabled state\n",
+			oh->name);
 		return -EINVAL;
 	}
 
@@ -1600,8 +1600,8 @@ static int _idle(struct omap_hwmod *oh)
 	pr_debug("omap_hwmod: %s: idling\n", oh->name);
 
 	if (oh->_state != _HWMOD_STATE_ENABLED) {
-		WARN(1, "omap_hwmod: %s: idle state can only be entered from "
-		     "enabled state\n", oh->name);
+		WARN(1, "omap_hwmod: %s: idle state can only be entered from enabled state\n",
+			oh->name);
 		return -EINVAL;
 	}
 
@@ -1682,8 +1682,8 @@ static int _shutdown(struct omap_hwmod *oh)
 
 	if (oh->_state != _HWMOD_STATE_IDLE &&
 	    oh->_state != _HWMOD_STATE_ENABLED) {
-		WARN(1, "omap_hwmod: %s: disabled state can only be entered "
-		     "from idle, or enabled state\n", oh->name);
+		WARN(1, "omap_hwmod: %s: disabled state can only be entered from idle, or enabled state\n",
+			oh->name);
 		return -EINVAL;
 	}
 
@@ -2240,8 +2240,8 @@ void omap_hwmod_ocp_barrier(struct omap_hwmod *oh)
 	BUG_ON(!oh);
 
 	if (!oh->class->sysc || !oh->class->sysc->sysc_flags) {
-		WARN(1, "omap_device: %s: OCP barrier impossible due to "
-		      "device configuration\n", oh->name);
+		WARN(1, "omap_device: %s: OCP barrier impossible due to device configuration\n",
+			oh->name);
 		return;
 	}
 

commit b3c37522928b5452588fc202eaa0f11f6e339256
Merge: 2ac9d7aaccbd 6d0a5636fba5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 9 14:39:59 2012 -0800

    Merge tag 'pm' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    power management changes for omap and imx
    
    A significant part of the changes for these two platforms went into
    power management, so they are split out into a separate branch.
    
    * tag 'pm' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (65 commits)
      ARM: imx6: remove __CPUINIT annotation from v7_invalidate_l1
      ARM: imx6: fix v7_invalidate_l1 by adding I-Cache invalidation
      ARM: imx6q: resume PL310 only when CACHE_L2X0 defined
      ARM: imx6q: build pm code only when CONFIG_PM selected
      ARM: mx5: use generic irq chip pm interface for pm functions on
      ARM: omap: pass minimal SoC/board data for UART from dt
      arm/dts: Add minimal device tree support for omap2420 and omap2430
      omap-serial: Add minimal device tree support
      omap-serial: Use default clock speed (48Mhz) if not specified
      omap-serial: Get rid of all pdev->id usage
      ARM: OMAP2+: hwmod: Add a new flag to handle hwmods left enabled at init
      ARM: OMAP4: PRM: use PRCM interrupt handler
      ARM: OMAP3: pm: use prcm chain handler
      ARM: OMAP: hwmod: add support for selecting mpu_irq for each wakeup pad
      ARM: OMAP2+: mux: add support for PAD wakeup interrupts
      ARM: OMAP: PRCM: add suspend prepare / finish support
      ARM: OMAP: PRCM: add support for chain interrupt handler
      ARM: OMAP3/4: PRM: add functions to read pending IRQs, PRM barrier
      ARM: OMAP2+: hwmod: Add API to enable IO ring wakeup
      ARM: OMAP2+: mux: add wakeup-capable hwmod mux entries to dynamic list
      ...

commit 57e964e1ae9bd4f699ae1074430bcf81a9a11377
Merge: 4dee6b64ee7c 39fbc7627222
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 9 14:20:39 2012 -0800

    Merge tag 'fixes-non-critical' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Non-critical bug fixes
    
    Simple bug fixes that were not considered important enough for inclusion
    into 3.2.
    
    * tag 'fixes-non-critical' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      MAINTAINERS: update pxa and mmp
      ARM: pxa: Include linux/export.h in balloon3.c
      ARM: OMAP4: clock: Add CPU local timer clock node
      ARM: OMAP4: hwmod: Don't wait for the idle status if modulemode is not supported
      ARM: OMAP: AM3517/3505: fix crash on boot due to incorrect voltagedomain data
      ARM: OMAP: hwmod data: fix the panic on Nokia RM-680 during boot
      ARM: OMAP2+: DMA: Workaround for invalid destination position
      ARM: OMAP2+: DMA: Workaround for invalid source position

commit bfc141e3a515008d85e57af39c9faa4d2bbc65e0
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Fri Dec 16 16:09:11 2011 -0800

    ARM: OMAP4: hwmod: Don't wait for the idle status if modulemode is not supported
    
    If the module does not have any modulemode, the _disable_module function
    will do nothing. There is then no point waiting for a idle status change.
    
    It will remove the following warnings.
    
    [    0.331848] omap_hwmod: dmm: _wait_target_disable failed
    [    0.339935] omap_hwmod: emif_fw: _wait_target_disable failed
    [    0.348358] omap_hwmod: l3_main_1: _wait_target_disable failed
    [    0.356964] omap_hwmod: l3_main_2: _wait_target_disable failed
    [    0.365600] omap_hwmod: l4_abe: _wait_target_disable failed
    [    0.373931] omap_hwmod: l4_cfg: _wait_target_disable failed
    [    0.382263] omap_hwmod: l4_per: _wait_target_disable failed
    [    0.391113] omap_hwmod: l4_wkup: _wait_target_disable failed
    [    0.399536] omap_hwmod: dma_system: _wait_target_disable failed
    [    0.408325] omap_hwmod: dss_core: _wait_target_disable failed
    [    0.416839] omap_hwmod: dss_dispc: _wait_target_disable failed
    [    0.425445] omap_hwmod: dss_dsi1: _wait_target_disable failed
    [    0.433990] omap_hwmod: dss_dsi2: _wait_target_disable failed
    [    0.442504] omap_hwmod: dss_hdmi: _wait_target_disable failed
    [    0.451019] omap_hwmod: dss_rfbi: _wait_target_disable failed
    [    0.459564] omap_hwmod: dss_venc: _wait_target_disable failed
    [    0.489471] omap_hwmod: mailbox: _wait_target_disable failed
    [    0.505920] omap_hwmod: spinlock: _wait_target_disable failed
    
    Note: For such module, the state is managed automatically by HW according
    to clock domain transition. It is then not possible to wait for idle even
    later in the _idle function since the status will change at clock domain
    boundary.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    [paul@pwsan.com: renamed fns to indicate that they are OMAP4-only; moved
     _wait_target_disable() into _disable_module(), removing duplicate code]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 207a2ff9a8c4..ebace0f6069c 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -706,27 +706,65 @@ static void _enable_module(struct omap_hwmod *oh)
 }
 
 /**
- * _disable_module - enable CLKCTRL modulemode on OMAP4
+ * _omap4_wait_target_disable - wait for a module to be disabled on OMAP4
+ * @oh: struct omap_hwmod *
+ *
+ * Wait for a module @oh to enter slave idle.  Returns 0 if the module
+ * does not have an IDLEST bit or if the module successfully enters
+ * slave idle; otherwise, pass along the return value of the
+ * appropriate *_cm*_wait_module_idle() function.
+ */
+static int _omap4_wait_target_disable(struct omap_hwmod *oh)
+{
+	if (!cpu_is_omap44xx())
+		return 0;
+
+	if (!oh)
+		return -EINVAL;
+
+	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
+		return 0;
+
+	if (oh->flags & HWMOD_NO_IDLEST)
+		return 0;
+
+	return omap4_cminst_wait_module_idle(oh->clkdm->prcm_partition,
+					     oh->clkdm->cm_inst,
+					     oh->clkdm->clkdm_offs,
+					     oh->prcm.omap4.clkctrl_offs);
+}
+
+/**
+ * _omap4_disable_module - enable CLKCTRL modulemode on OMAP4
  * @oh: struct omap_hwmod *
  *
  * Disable the PRCM module mode related to the hwmod @oh.
- * No return value.
+ * Return EINVAL if the modulemode is not supported and 0 in case of success.
  */
-static void _disable_module(struct omap_hwmod *oh)
+static int _omap4_disable_module(struct omap_hwmod *oh)
 {
+	int v;
+
 	/* The module mode does not exist prior OMAP4 */
-	if (cpu_is_omap24xx() || cpu_is_omap34xx())
-		return;
+	if (!cpu_is_omap44xx())
+		return -EINVAL;
 
 	if (!oh->clkdm || !oh->prcm.omap4.modulemode)
-		return;
+		return -EINVAL;
 
-	pr_debug("omap_hwmod: %s: _disable_module\n", oh->name);
+	pr_debug("omap_hwmod: %s: %s\n", oh->name, __func__);
 
 	omap4_cminst_module_disable(oh->clkdm->prcm_partition,
 				    oh->clkdm->cm_inst,
 				    oh->clkdm->clkdm_offs,
 				    oh->prcm.omap4.clkctrl_offs);
+
+	v = _omap4_wait_target_disable(oh);
+	if (v)
+		pr_warn("omap_hwmod: %s: _wait_target_disable failed\n",
+			oh->name);
+
+	return 0;
 }
 
 /**
@@ -1152,36 +1190,6 @@ static int _wait_target_ready(struct omap_hwmod *oh)
 	return ret;
 }
 
-/**
- * _wait_target_disable - wait for a module to be disabled
- * @oh: struct omap_hwmod *
- *
- * Wait for a module @oh to enter slave idle.  Returns 0 if the module
- * does not have an IDLEST bit or if the module successfully enters
- * slave idle; otherwise, pass along the return value of the
- * appropriate *_cm*_wait_module_idle() function.
- */
-static int _wait_target_disable(struct omap_hwmod *oh)
-{
-	/* TODO: For now just handle OMAP4+ */
-	if (cpu_is_omap24xx() || cpu_is_omap34xx())
-		return 0;
-
-	if (!oh)
-		return -EINVAL;
-
-	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
-		return 0;
-
-	if (oh->flags & HWMOD_NO_IDLEST)
-		return 0;
-
-	return omap4_cminst_wait_module_idle(oh->clkdm->prcm_partition,
-					     oh->clkdm->cm_inst,
-					     oh->clkdm->clkdm_offs,
-					     oh->prcm.omap4.clkctrl_offs);
-}
-
 /**
  * _lookup_hardreset - fill register bit info for this hwmod/reset line
  * @oh: struct omap_hwmod *
@@ -1524,8 +1532,6 @@ static int _enable(struct omap_hwmod *oh)
  */
 static int _idle(struct omap_hwmod *oh)
 {
-	int ret;
-
 	pr_debug("omap_hwmod: %s: idling\n", oh->name);
 
 	if (oh->_state != _HWMOD_STATE_ENABLED) {
@@ -1537,11 +1543,9 @@ static int _idle(struct omap_hwmod *oh)
 	if (oh->class->sysc)
 		_idle_sysc(oh);
 	_del_initiator_dep(oh, mpu_oh);
-	_disable_module(oh);
-	ret = _wait_target_disable(oh);
-	if (ret)
-		pr_warn("omap_hwmod: %s: _wait_target_disable failed\n",
-			oh->name);
+
+	_omap4_disable_module(oh);
+
 	/*
 	 * The module must be in idle mode before disabling any parents
 	 * clocks. Otherwise, the parent clock might be disabled before
@@ -1642,11 +1646,7 @@ static int _shutdown(struct omap_hwmod *oh)
 	if (oh->_state == _HWMOD_STATE_ENABLED) {
 		_del_initiator_dep(oh, mpu_oh);
 		/* XXX what about the other system initiators here? dma, dsp */
-		_disable_module(oh);
-		ret = _wait_target_disable(oh);
-		if (ret)
-			pr_warn("omap_hwmod: %s: _wait_target_disable failed\n",
-				oh->name);
+		_omap4_disable_module(oh);
 		_disable_clocks(oh);
 		if (oh->clkdm)
 			clkdm_hwmod_disable(oh->clkdm, oh);

commit 9d297f5ee1b92a84e2cd6c547c3ac1f893128359
Merge: aacf09412875 2f31b51659c2
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Dec 16 14:00:23 2011 -0800

    Merge branch 'tk_prm_chain_handler_devel_3.3' of git://git.pwsan.com/linux-2.6 into prcm
    
    Conflicts:
            arch/arm/mach-omap2/Makefile

commit aacf094128759cfb29a3ce88f92d08b79b74a4e8
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Dec 16 05:50:12 2011 -0700

    ARM: OMAP2+: hwmod: Add a new flag to handle hwmods left enabled at init
    
    An hwmod with a 'HWMOD_INIT_NO_IDLE' flag set, is left in
    enabled state by the hwmod framework post the initial setup.
    Once a real user of the device (a driver) tries to enable it
    at a later point, the hwmod framework throws a WARN() about
    the device being already in enabled state.
    
    Fix this by introducing a new internal flag '_HWMOD_SKIP_ENABLE' to
    identify such devices/hwmods. When the device/hwmod is requested to be
    enabled (the first time) by its driver/user, nothing except the
    mux-enable is needed. The mux data is board specific and is
    unavailable during initial enable() of the device, done by the
    framework as part of setup().
    
    A good example of a such a device is an UART used as debug console.
    The UART module needs to be kept enabled through the boot, until the
    UART driver takes control of it, for debug prints to appear on
    the console.
    
    Acked-by: Kevin Hilman <khilman@ti.com>
    Acked-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    [paul@pwsan.com: use a flag rather than a state; updated commit message;
     edited some documentation]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 529142aff766..f673f808725f 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1441,6 +1441,25 @@ static int _enable(struct omap_hwmod *oh)
 
 	pr_debug("omap_hwmod: %s: enabling\n", oh->name);
 
+	/*
+	 * hwmods with HWMOD_INIT_NO_IDLE flag set are left
+	 * in enabled state at init.
+	 * Now that someone is really trying to enable them,
+	 * just ensure that the hwmod mux is set.
+	 */
+	if (oh->_int_flags & _HWMOD_SKIP_ENABLE) {
+		/*
+		 * If the caller has mux data populated, do the mux'ing
+		 * which wouldn't have been done as part of the _enable()
+		 * done during setup.
+		 */
+		if (oh->mux)
+			omap_hwmod_mux(oh->mux, _HWMOD_STATE_ENABLED);
+
+		oh->_int_flags &= ~_HWMOD_SKIP_ENABLE;
+		return 0;
+	}
+
 	if (oh->_state != _HWMOD_STATE_INITIALIZED &&
 	    oh->_state != _HWMOD_STATE_IDLE &&
 	    oh->_state != _HWMOD_STATE_DISABLED) {
@@ -1744,8 +1763,10 @@ static int _setup(struct omap_hwmod *oh, void *data)
 	 * it should be set by the core code as a runtime flag during startup
 	 */
 	if ((oh->flags & HWMOD_INIT_NO_IDLE) &&
-	    (postsetup_state == _HWMOD_STATE_IDLE))
+	    (postsetup_state == _HWMOD_STATE_IDLE)) {
+		oh->_int_flags |= _HWMOD_SKIP_ENABLE;
 		postsetup_state = _HWMOD_STATE_ENABLED;
+	}
 
 	if (postsetup_state == _HWMOD_STATE_IDLE)
 		_idle(oh);

commit abc2d5456334d548328978d0b0d22c0e5d44cdcd
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Dec 16 14:36:59 2011 -0700

    ARM: OMAP: hwmod: add support for selecting mpu_irq for each wakeup pad
    
    By default all registered pads will trigger mpu_irqs[0]. Now there is
    an API for selecting used mpu_irq on pad basis, which can be used to
    trigger different irq handlers for different pads in the same hwmod.
    Each pad that requires its interrupt to be re-routed this way must
    have a separate call to omap_hwmod_pad_route_irq(hwmod, pad, irq).
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Kevin Hilman <khilman@ti.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    [paul@pwsan.com: moved fn to omap_hwmod.c; separated fn from mux scan_wakeups
     changes; added kerneldoc]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 21ffd8a831c3..7ea3df517d2b 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -136,6 +136,7 @@
 #include <linux/list.h>
 #include <linux/mutex.h>
 #include <linux/spinlock.h>
+#include <linux/slab.h>
 
 #include <plat/common.h>
 #include <plat/cpu.h>
@@ -2709,3 +2710,57 @@ int omap_hwmod_no_setup_reset(struct omap_hwmod *oh)
 
 	return 0;
 }
+
+/**
+ * omap_hwmod_pad_route_irq - route an I/O pad wakeup to a particular MPU IRQ
+ * @oh: struct omap_hwmod * containing hwmod mux entries
+ * @pad_idx: array index in oh->mux of the hwmod mux entry to route wakeup
+ * @irq_idx: the hwmod mpu_irqs array index of the IRQ to trigger on wakeup
+ *
+ * When an I/O pad wakeup arrives for the dynamic or wakeup hwmod mux
+ * entry number @pad_idx for the hwmod @oh, trigger the interrupt
+ * service routine for the hwmod's mpu_irqs array index @irq_idx.  If
+ * this function is not called for a given pad_idx, then the ISR
+ * associated with @oh's first MPU IRQ will be triggered when an I/O
+ * pad wakeup occurs on that pad.  Note that @pad_idx is the index of
+ * the _dynamic or wakeup_ entry: if there are other entries not
+ * marked with OMAP_DEVICE_PAD_WAKEUP or OMAP_DEVICE_PAD_REMUX, these
+ * entries are NOT COUNTED in the dynamic pad index.  This function
+ * must be called separately for each pad that requires its interrupt
+ * to be re-routed this way.  Returns -EINVAL if there is an argument
+ * problem or if @oh does not have hwmod mux entries or MPU IRQs;
+ * returns -ENOMEM if memory cannot be allocated; or 0 upon success.
+ *
+ * XXX This function interface is fragile.  Rather than using array
+ * indexes, which are subject to unpredictable change, it should be
+ * using hwmod IRQ names, and some other stable key for the hwmod mux
+ * pad records.
+ */
+int omap_hwmod_pad_route_irq(struct omap_hwmod *oh, int pad_idx, int irq_idx)
+{
+	int nr_irqs;
+
+	might_sleep();
+
+	if (!oh || !oh->mux || !oh->mpu_irqs || pad_idx < 0 ||
+	    pad_idx >= oh->mux->nr_pads_dynamic)
+		return -EINVAL;
+
+	/* Check the number of available mpu_irqs */
+	for (nr_irqs = 0; oh->mpu_irqs[nr_irqs].irq >= 0; nr_irqs++)
+		;
+
+	if (irq_idx >= nr_irqs)
+		return -EINVAL;
+
+	if (!oh->mux->irqs) {
+		/* XXX What frees this? */
+		oh->mux->irqs = kzalloc(sizeof(int) * oh->mux->nr_pads_dynamic,
+			GFP_KERNEL);
+		if (!oh->mux->irqs)
+			return -ENOMEM;
+	}
+	oh->mux->irqs[pad_idx] = irq_idx;
+
+	return 0;
+}

commit eceec00914e3a74b94eea832f9e829c3efcea9bc
Author: Govindraj R <govindraj.raja@ti.com>
Date:   Fri Dec 16 14:36:58 2011 -0700

    ARM: OMAP2+: hwmod: Add API to enable IO ring wakeup
    
    Add API to enable IO pad wakeup capability based on mux pad and
    wake_up enable flag available from hwmod_mux initialization.
    
    Use the wakeup_enable flag and enable wakeup capability for the given
    pads. Wakeup capability will be enabled/disabled during hwmod idle
    transition based on whether wakeup_flag is set or cleared.  If the
    hwmod is currently idled, and any mux values were changed by
    _set_idle_ioring_wakeup(), the SCM PADCTRL registers will be updated.
    
    Signed-off-by: Govindraj.R <govindraj.raja@ti.com>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Kevin Hilman <khilman@ti.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    [paul@pwsan.com: rearranged code to limit indentation; cleaned up
     function documentation; removed unused non-static functions; modified
     to search all hwmod pads, not just dynamic remuxing ones; modified to
     update SCM regs if hwmod is currently idle and any pads have changed]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 207a2ff9a8c4..21ffd8a831c3 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -380,6 +380,51 @@ static int _set_module_autoidle(struct omap_hwmod *oh, u8 autoidle,
 	return 0;
 }
 
+/**
+ * _set_idle_ioring_wakeup - enable/disable IO pad wakeup on hwmod idle for mux
+ * @oh: struct omap_hwmod *
+ * @set_wake: bool value indicating to set (true) or clear (false) wakeup enable
+ *
+ * Set or clear the I/O pad wakeup flag in the mux entries for the
+ * hwmod @oh.  This function changes the @oh->mux->pads_dynamic array
+ * in memory.  If the hwmod is currently idled, and the new idle
+ * values don't match the previous ones, this function will also
+ * update the SCM PADCTRL registers.  Otherwise, if the hwmod is not
+ * currently idled, this function won't touch the hardware: the new
+ * mux settings are written to the SCM PADCTRL registers when the
+ * hwmod is idled.  No return value.
+ */
+static void _set_idle_ioring_wakeup(struct omap_hwmod *oh, bool set_wake)
+{
+	struct omap_device_pad *pad;
+	bool change = false;
+	u16 prev_idle;
+	int j;
+
+	if (!oh->mux || !oh->mux->enabled)
+		return;
+
+	for (j = 0; j < oh->mux->nr_pads_dynamic; j++) {
+		pad = oh->mux->pads_dynamic[j];
+
+		if (!(pad->flags & OMAP_DEVICE_PAD_WAKEUP))
+			continue;
+
+		prev_idle = pad->idle;
+
+		if (set_wake)
+			pad->idle |= OMAP_WAKEUP_EN;
+		else
+			pad->idle &= ~OMAP_WAKEUP_EN;
+
+		if (prev_idle != pad->idle)
+			change = true;
+	}
+
+	if (change && oh->_state == _HWMOD_STATE_IDLE)
+		omap_hwmod_mux(oh->mux, _HWMOD_STATE_IDLE);
+}
+
 /**
  * _enable_wakeup: set OCP_SYSCONFIG.ENAWAKEUP bit in the hardware
  * @oh: struct omap_hwmod *
@@ -2416,6 +2461,7 @@ int omap_hwmod_enable_wakeup(struct omap_hwmod *oh)
 	v = oh->_sysc_cache;
 	_enable_wakeup(oh, &v);
 	_write_sysconfig(v, oh);
+	_set_idle_ioring_wakeup(oh, true);
 	spin_unlock_irqrestore(&oh->_lock, flags);
 
 	return 0;
@@ -2446,6 +2492,7 @@ int omap_hwmod_disable_wakeup(struct omap_hwmod *oh)
 	v = oh->_sysc_cache;
 	_disable_wakeup(oh, &v);
 	_write_sysconfig(v, oh);
+	_set_idle_ioring_wakeup(oh, false);
 	spin_unlock_irqrestore(&oh->_lock, flags);
 
 	return 0;

commit 742eaa6a6e356a16788ce6530271de89bc4f8fb5
Merge: ba8bb18a03f8 ae72fd588a2b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Dec 5 23:20:17 2011 +0000

    Merge branch 'for-rmk' of git://git.kernel.org/pub/scm/linux/kernel/git/will/linux into devel-stable
    
    Conflicts:
            arch/arm/common/gic.c
            arch/arm/plat-omap/include/plat/common.h

commit cc1b0765da6078b906772b79ff211b88cc0ae958
Author: sricharan <r.sricharan@ti.com>
Date:   Wed Nov 23 14:35:07 2011 -0800

    ARM: OMAP: hwmod: Fix the addr space, irq, dma count APIs
    
    The address spaces, irqs and dma reqs count APIs return the
    number of corresponding entries in a hwmod including a additional
    null value or a -1 terminator in the structure introduced recently.
    More information here:
    
    - 212738a4: omap_hwmod: use a terminator record with omap_hwmod_mpu_irqs
      arrays
    
    - 78183f3f: omap_hwmod: use a null structure record to terminate
      omap_hwmod_addr_space arrays
    
    - bc614958: omap_hwmod: use a terminator record with omap_hwmod_dma_info
      arrays
    
    The issue with irqs and dma info was originally reported by Benoit Cousson.
    
    The devices which have multiple hwmods and use device_build_ss are
    broken with this, as their resources are populated with a extra null
    value, subsequently the probe fails. So fix the API not to include
    the array terminator in the count.
    
    Reported-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimar@ti.com>
    Signed-off-by: sricharan <r.sricharan@ti.com>
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 6b3088db83b7..207a2ff9a8c4 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -749,7 +749,7 @@ static int _count_mpu_irqs(struct omap_hwmod *oh)
 		ohii = &oh->mpu_irqs[i++];
 	} while (ohii->irq != -1);
 
-	return i;
+	return i-1;
 }
 
 /**
@@ -772,7 +772,7 @@ static int _count_sdma_reqs(struct omap_hwmod *oh)
 		ohdi = &oh->sdma_reqs[i++];
 	} while (ohdi->dma_req != -1);
 
-	return i;
+	return i-1;
 }
 
 /**
@@ -795,7 +795,7 @@ static int _count_ocp_if_addr_spaces(struct omap_hwmod_ocp_if *os)
 		mem = &os->addr[i++];
 	} while (mem->pa_start != mem->pa_end);
 
-	return i;
+	return i-1;
 }
 
 /**

commit 4e65331c6bb4a777bd61a4dac0daa9fc47777b63
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Nov 10 22:45:17 2011 +0100

    ARM: 7159/1: OMAP: Introduce local common.h files
    
    As suggested by Russell King - ARM Linux <linux@arm.linux.org.uk>,
    there's no need to keep local prototypes in non-local headers.
    
    Add mach-omap1/common.h and mach-omap2/common.h and move the
    local prototypes there from plat/common.h and mach/omap4-common.h.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 6b3088db83b7..00fcd2c311ea 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -137,7 +137,7 @@
 #include <linux/mutex.h>
 #include <linux/spinlock.h>
 
-#include <plat/common.h>
+#include "common.h"
 #include <plat/cpu.h>
 #include "clockdomain.h"
 #include "powerdomain.h"

commit fc01387302c01899e3cc67d3c81fd4287db9bab9
Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
Date:   Thu Jun 9 16:56:23 2011 +0300

    ARM: OMAP: change get_context_loss_count ret value to int
    
    get_context_loss_count functions return context loss count as u32, and
    zero means an error. However, zero is also returned when context has
    never been lost and could also be returned when the context loss count
    has wrapped and goes to zero.
    
    Change the functions to return an int, with negative value meaning an
    error.
    
    OMAP HSMMC code uses omap_pm_get_dev_context_loss_count(), but as the
    hsmmc code handles the returned value as an int, with negative value
    meaning an error, this patch actually fixes hsmmc code also.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Acked-by: Kevin Hilman <khilman@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    [tony@atomide.com: updated to fix a warning with recent dmtimer changes]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index d71380705080..6b3088db83b7 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2625,7 +2625,7 @@ int omap_hwmod_set_postsetup_state(struct omap_hwmod *oh, u8 state)
  * Returns the context loss count of the powerdomain assocated with @oh
  * upon success, or zero if no powerdomain exists for @oh.
  */
-u32 omap_hwmod_get_context_loss_count(struct omap_hwmod *oh)
+int omap_hwmod_get_context_loss_count(struct omap_hwmod *oh)
 {
 	struct powerdomain *pwrdm;
 	int ret = 0;

commit d6504acd2125984c61dce24727dd3842d0144015
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Sep 14 17:23:19 2011 -0600

    OMAP2+: hwmod: remove OMAP_CHIP*
    
    At Tony's request, remove the OMAP_CHIP* flags from the hwmod data, and
    replace it instead with chip family, variant, and ES level-specific lists
    of hwmods to register.
    
    Thanks to Gravydas Ignotas <notasas@gmail.com> for finding a bug in the
    AM3517/3505 support, and for other review comments.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Gravydas Ignotas <notasas@gmail.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 84cc0bdda3ae..d71380705080 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1954,9 +1954,6 @@ int __init omap_hwmod_register(struct omap_hwmod **ohs)
 
 	i = 0;
 	do {
-		if (!omap_chip_is(ohs[i]->omap_chip))
-			continue;
-
 		r = _register(ohs[i]);
 		WARN(r, "omap_hwmod: %s: _register returned %d\n", ohs[i]->name,
 		     r);

commit 665d001338b494d6d62810aa99b4c0fa1a0884b9
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Sun Jul 10 05:57:07 2011 -0600

    OMAP2+: hwmod: Follow the recommended PRCM module enable sequence
    
    On OMAP4, the PRCM recommended sequence for enabling
    a module after power-on-reset is:
    -1- Force clkdm to SW_WKUP
    -2- Enabling the clocks
    -3- Configure desired module mode to "enable" or "auto"
    -4- Wait for the desired module idle status to be FUNC
    -5- Program clkdm in HW_AUTO(if supported)
    
    This sequence applies to all older OMAPs' as well,
    however since they use autodeps, it makes sure that
    no clkdm is in IDLE, and hence not requiring a force
    SW_WKUP when a module is being enabled.
    
    OMAP4 does not need to support autodeps, because
    of the dyanamic dependency feature, wherein
    the HW takes care of waking up a clockdomain from
    idle and hence the module, whenever an interconnect
    access happens to the given module.
    
    Implementing the sequence for OMAP4 requires
    the clockdomain handling that is currently done in
    clock framework to be done as part of hwmod framework
    since the step -4- above to "Wait for the desired
    module idle status to be FUNC" is done as part of
    hwmod framework.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    [b-cousson@ti.com: Adapt it to the new clkdm hwmod attribute and API]
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    [paul@pwsan.com: dropped mach-omap2/clock.c changes; modified to only
     call the clockdomain code if oh->clkdm is set; disable clock->clockdomain
     interaction on OMAP4]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 4424fee5cd5a..84cc0bdda3ae 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1437,6 +1437,7 @@ static int _reset(struct omap_hwmod *oh)
 static int _enable(struct omap_hwmod *oh)
 {
 	int r;
+	int hwsup = 0;
 
 	pr_debug("omap_hwmod: %s: enabling\n", oh->name);
 
@@ -1448,14 +1449,6 @@ static int _enable(struct omap_hwmod *oh)
 		return -EINVAL;
 	}
 
-	/* Mux pins for device runtime if populated */
-	if (oh->mux && (!oh->mux->enabled ||
-			((oh->_state == _HWMOD_STATE_IDLE) &&
-			 oh->mux->pads_dynamic)))
-		omap_hwmod_mux(oh->mux, _HWMOD_STATE_ENABLED);
-
-	_add_initiator_dep(oh, mpu_oh);
-	_enable_clocks(oh);
 
 	/*
 	 * If an IP contains only one HW reset line, then de-assert it in order
@@ -1466,23 +1459,56 @@ static int _enable(struct omap_hwmod *oh)
 	     oh->_state == _HWMOD_STATE_DISABLED) && oh->rst_lines_cnt == 1)
 		_deassert_hardreset(oh, oh->rst_lines[0].name);
 
-	r = _wait_target_ready(oh);
-	if (r) {
-		pr_debug("omap_hwmod: %s: _wait_target_ready: %d\n",
-			 oh->name, r);
-		_disable_clocks(oh);
+	/* Mux pins for device runtime if populated */
+	if (oh->mux && (!oh->mux->enabled ||
+			((oh->_state == _HWMOD_STATE_IDLE) &&
+			 oh->mux->pads_dynamic)))
+		omap_hwmod_mux(oh->mux, _HWMOD_STATE_ENABLED);
+
+	_add_initiator_dep(oh, mpu_oh);
 
-		return r;
+	if (oh->clkdm) {
+		/*
+		 * A clockdomain must be in SW_SUP before enabling
+		 * completely the module. The clockdomain can be set
+		 * in HW_AUTO only when the module become ready.
+		 */
+		hwsup = clkdm_in_hwsup(oh->clkdm);
+		r = clkdm_hwmod_enable(oh->clkdm, oh);
+		if (r) {
+			WARN(1, "omap_hwmod: %s: could not enable clockdomain %s: %d\n",
+			     oh->name, oh->clkdm->name, r);
+			return r;
+		}
 	}
+
+	_enable_clocks(oh);
 	_enable_module(oh);
 
-	oh->_state = _HWMOD_STATE_ENABLED;
+	r = _wait_target_ready(oh);
+	if (!r) {
+		/*
+		 * Set the clockdomain to HW_AUTO only if the target is ready,
+		 * assuming that the previous state was HW_AUTO
+		 */
+		if (oh->clkdm && hwsup)
+			clkdm_allow_idle(oh->clkdm);
 
-	/* Access the sysconfig only if the target is ready */
-	if (oh->class->sysc) {
-		if (!(oh->_int_flags & _HWMOD_SYSCONFIG_LOADED))
-			_update_sysc_cache(oh);
-		_enable_sysc(oh);
+		oh->_state = _HWMOD_STATE_ENABLED;
+
+		/* Access the sysconfig only if the target is ready */
+		if (oh->class->sysc) {
+			if (!(oh->_int_flags & _HWMOD_SYSCONFIG_LOADED))
+				_update_sysc_cache(oh);
+			_enable_sysc(oh);
+		}
+	} else {
+		_disable_clocks(oh);
+		pr_debug("omap_hwmod: %s: _wait_target_ready: %d\n",
+			 oh->name, r);
+
+		if (oh->clkdm)
+			clkdm_hwmod_disable(oh->clkdm, oh);
 	}
 
 	return r;
@@ -1523,6 +1549,8 @@ static int _idle(struct omap_hwmod *oh)
 	 * transition to complete properly.
 	 */
 	_disable_clocks(oh);
+	if (oh->clkdm)
+		clkdm_hwmod_disable(oh->clkdm, oh);
 
 	/* Mux pins for device idle if populated */
 	if (oh->mux && oh->mux->pads_dynamic)
@@ -1620,6 +1648,8 @@ static int _shutdown(struct omap_hwmod *oh)
 			pr_warn("omap_hwmod: %s: _wait_target_disable failed\n",
 				oh->name);
 		_disable_clocks(oh);
+		if (oh->clkdm)
+			clkdm_hwmod_disable(oh->clkdm, oh);
 	}
 	/* XXX Should this code also force-disable the optional clocks? */
 

commit 45c38252d76a96e6e0e05f982ca44096191a8eea
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Sun Jul 10 05:56:33 2011 -0600

    OMAP4: hwmod: Introduce the module control in hwmod control
    
    Take advantage of the explicit modulemode control to fix
    the way parents clocks are managed.
    A module must be disabled before any parents are disabled.
    That programming model was not possible with the previous
    implementation that was considering a modulemode as a leaf
    clock node managed by the clock fmwk.
    This was leading to bad crash upon disable when the parent
    clock was gated before the module completed its transition
    to idle.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index a0f7d313e69f..4424fee5cd5a 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -679,6 +679,56 @@ static void _disable_optional_clocks(struct omap_hwmod *oh)
 		}
 }
 
+/**
+ * _enable_module - enable CLKCTRL modulemode on OMAP4
+ * @oh: struct omap_hwmod *
+ *
+ * Enables the PRCM module mode related to the hwmod @oh.
+ * No return value.
+ */
+static void _enable_module(struct omap_hwmod *oh)
+{
+	/* The module mode does not exist prior OMAP4 */
+	if (cpu_is_omap24xx() || cpu_is_omap34xx())
+		return;
+
+	if (!oh->clkdm || !oh->prcm.omap4.modulemode)
+		return;
+
+	pr_debug("omap_hwmod: %s: _enable_module: %d\n",
+		 oh->name, oh->prcm.omap4.modulemode);
+
+	omap4_cminst_module_enable(oh->prcm.omap4.modulemode,
+				   oh->clkdm->prcm_partition,
+				   oh->clkdm->cm_inst,
+				   oh->clkdm->clkdm_offs,
+				   oh->prcm.omap4.clkctrl_offs);
+}
+
+/**
+ * _disable_module - enable CLKCTRL modulemode on OMAP4
+ * @oh: struct omap_hwmod *
+ *
+ * Disable the PRCM module mode related to the hwmod @oh.
+ * No return value.
+ */
+static void _disable_module(struct omap_hwmod *oh)
+{
+	/* The module mode does not exist prior OMAP4 */
+	if (cpu_is_omap24xx() || cpu_is_omap34xx())
+		return;
+
+	if (!oh->clkdm || !oh->prcm.omap4.modulemode)
+		return;
+
+	pr_debug("omap_hwmod: %s: _disable_module\n", oh->name);
+
+	omap4_cminst_module_disable(oh->clkdm->prcm_partition,
+				    oh->clkdm->cm_inst,
+				    oh->clkdm->clkdm_offs,
+				    oh->prcm.omap4.clkctrl_offs);
+}
+
 /**
  * _count_mpu_irqs - count the number of MPU IRQ lines associated with @oh
  * @oh: struct omap_hwmod *oh
@@ -1424,6 +1474,7 @@ static int _enable(struct omap_hwmod *oh)
 
 		return r;
 	}
+	_enable_module(oh);
 
 	oh->_state = _HWMOD_STATE_ENABLED;
 
@@ -1460,11 +1511,18 @@ static int _idle(struct omap_hwmod *oh)
 	if (oh->class->sysc)
 		_idle_sysc(oh);
 	_del_initiator_dep(oh, mpu_oh);
-	_disable_clocks(oh);
+	_disable_module(oh);
 	ret = _wait_target_disable(oh);
 	if (ret)
 		pr_warn("omap_hwmod: %s: _wait_target_disable failed\n",
 			oh->name);
+	/*
+	 * The module must be in idle mode before disabling any parents
+	 * clocks. Otherwise, the parent clock might be disabled before
+	 * the module transition is done, and thus will prevent the
+	 * transition to complete properly.
+	 */
+	_disable_clocks(oh);
 
 	/* Mux pins for device idle if populated */
 	if (oh->mux && oh->mux->pads_dynamic)
@@ -1556,11 +1614,12 @@ static int _shutdown(struct omap_hwmod *oh)
 	if (oh->_state == _HWMOD_STATE_ENABLED) {
 		_del_initiator_dep(oh, mpu_oh);
 		/* XXX what about the other system initiators here? dma, dsp */
-		_disable_clocks(oh);
+		_disable_module(oh);
 		ret = _wait_target_disable(oh);
 		if (ret)
 			pr_warn("omap_hwmod: %s: _wait_target_disable failed\n",
 				oh->name);
+		_disable_clocks(oh);
 	}
 	/* XXX Should this code also force-disable the optional clocks? */
 

commit eaac329dfa6d3a4025242bf34d33aa3cb9df9f9f
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Sun Jul 10 05:56:31 2011 -0600

    OMAP4: hwmod: Replace RSTCTRL absolute address with offset macros
    
    The RSTCTRL register was accessed using an absolute address.
    The usage of hardcoded macros to calculate virtual address from physical
    one should be avoided as much as possible.
    The usage of an offset will allow future improvement like migration from
    the current architecture code toward a module driver.
    
    Update prm_xxx accessors, move definition to the proper header file and
    update copyrights.
    Change the s16 register offset parameter to u16.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    [paul@pwsan.com: use '_prminst_' in function names that are part of the
     prminst44xx.c file]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index d21f49b87646..a0f7d313e69f 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -149,6 +149,7 @@
 #include "cminst44xx.h"
 #include "prm2xxx_3xxx.h"
 #include "prm44xx.h"
+#include "prminst44xx.h"
 #include "mux.h"
 
 /* Maximum microseconds to wait for OMAP module to softreset */
@@ -1187,8 +1188,10 @@ static int _assert_hardreset(struct omap_hwmod *oh, const char *name)
 		return omap2_prm_assert_hardreset(oh->prcm.omap2.module_offs,
 						  ohri.rst_shift);
 	else if (cpu_is_omap44xx())
-		return omap4_prm_assert_hardreset(oh->prcm.omap4.rstctrl_reg,
-						  ohri.rst_shift);
+		return omap4_prminst_assert_hardreset(ohri.rst_shift,
+				  oh->clkdm->pwrdm.ptr->prcm_partition,
+				  oh->clkdm->pwrdm.ptr->prcm_offs,
+				  oh->prcm.omap4.rstctrl_offs);
 	else
 		return -EINVAL;
 }
@@ -1223,8 +1226,10 @@ static int _deassert_hardreset(struct omap_hwmod *oh, const char *name)
 		if (ohri.st_shift)
 			pr_err("omap_hwmod: %s: %s: hwmod data error: OMAP4 does not support st_shift\n",
 			       oh->name, name);
-		ret = omap4_prm_deassert_hardreset(oh->prcm.omap4.rstctrl_reg,
-						   ohri.rst_shift);
+		ret = omap4_prminst_deassert_hardreset(ohri.rst_shift,
+				  oh->clkdm->pwrdm.ptr->prcm_partition,
+				  oh->clkdm->pwrdm.ptr->prcm_offs,
+				  oh->prcm.omap4.rstctrl_offs);
 	} else {
 		return -EINVAL;
 	}
@@ -1259,8 +1264,10 @@ static int _read_hardreset(struct omap_hwmod *oh, const char *name)
 		return omap2_prm_is_hardreset_asserted(oh->prcm.omap2.module_offs,
 						       ohri.st_shift);
 	} else if (cpu_is_omap44xx()) {
-		return omap4_prm_is_hardreset_asserted(oh->prcm.omap4.rstctrl_reg,
-						       ohri.rst_shift);
+		return omap4_prminst_is_hardreset_asserted(ohri.rst_shift,
+				  oh->clkdm->pwrdm.ptr->prcm_partition,
+				  oh->clkdm->pwrdm.ptr->prcm_offs,
+				  oh->prcm.omap4.rstctrl_offs);
 	} else {
 		return -EINVAL;
 	}

commit 11b10341bd12c87a8409c69cdcd7ee898400842f
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Sun Jul 10 05:56:30 2011 -0600

    OMAP: hwmod: Wait the idle status to be disabled
    
    It is mandatory to wait for a module to be in disabled state before
    potentially disabling source clock or re-asserting a reset.
    
    omap_hwmod_idle and omap_hwmod_shutdown does not wait for
    the module to be fully idle.
    
    Add a cm_xxx accessor to wait the clkctrl idle status to be disabled.
    Fix hwmod_[idle|shutdown] to use this API.
    
    Based on Rajendra's initial patch.
    
    Please note that most interconnects hwmod will return one timeout because
    it is impossible for them to be in idle since the processor is accessing
    the registers though the interconnect.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Todd Poynor <toddpoynor@google.com>
    [paul@pwsan.com: move cpu_is_*() tests to the top of _wait_target_disable();
     incorporate some feedback from Todd]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 00241ea5bf09..d21f49b87646 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1101,6 +1101,36 @@ static int _wait_target_ready(struct omap_hwmod *oh)
 	return ret;
 }
 
+/**
+ * _wait_target_disable - wait for a module to be disabled
+ * @oh: struct omap_hwmod *
+ *
+ * Wait for a module @oh to enter slave idle.  Returns 0 if the module
+ * does not have an IDLEST bit or if the module successfully enters
+ * slave idle; otherwise, pass along the return value of the
+ * appropriate *_cm*_wait_module_idle() function.
+ */
+static int _wait_target_disable(struct omap_hwmod *oh)
+{
+	/* TODO: For now just handle OMAP4+ */
+	if (cpu_is_omap24xx() || cpu_is_omap34xx())
+		return 0;
+
+	if (!oh)
+		return -EINVAL;
+
+	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
+		return 0;
+
+	if (oh->flags & HWMOD_NO_IDLEST)
+		return 0;
+
+	return omap4_cminst_wait_module_idle(oh->clkdm->prcm_partition,
+					     oh->clkdm->cm_inst,
+					     oh->clkdm->clkdm_offs,
+					     oh->prcm.omap4.clkctrl_offs);
+}
+
 /**
  * _lookup_hardreset - fill register bit info for this hwmod/reset line
  * @oh: struct omap_hwmod *
@@ -1410,6 +1440,8 @@ static int _enable(struct omap_hwmod *oh)
  */
 static int _idle(struct omap_hwmod *oh)
 {
+	int ret;
+
 	pr_debug("omap_hwmod: %s: idling\n", oh->name);
 
 	if (oh->_state != _HWMOD_STATE_ENABLED) {
@@ -1422,6 +1454,10 @@ static int _idle(struct omap_hwmod *oh)
 		_idle_sysc(oh);
 	_del_initiator_dep(oh, mpu_oh);
 	_disable_clocks(oh);
+	ret = _wait_target_disable(oh);
+	if (ret)
+		pr_warn("omap_hwmod: %s: _wait_target_disable failed\n",
+			oh->name);
 
 	/* Mux pins for device idle if populated */
 	if (oh->mux && oh->mux->pads_dynamic)
@@ -1514,6 +1550,10 @@ static int _shutdown(struct omap_hwmod *oh)
 		_del_initiator_dep(oh, mpu_oh);
 		/* XXX what about the other system initiators here? dma, dsp */
 		_disable_clocks(oh);
+		ret = _wait_target_disable(oh);
+		if (ret)
+			pr_warn("omap_hwmod: %s: _wait_target_disable failed\n",
+				oh->name);
 	}
 	/* XXX Should this code also force-disable the optional clocks? */
 

commit d0f0631ddc61026dca71b5b679803000d70fde50
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Sun Jul 10 05:56:30 2011 -0600

    OMAP4: hwmod: Replace CLKCTRL absolute address with offset macros
    
    The CLKCTRL register was accessed using an absolute address.
    The usage of hardcoded macros to calculate virtual address from physical
    one should be avoided as much as possible.
    The usage of a offset will allow future improvement like migration from
    the current architecture code toward a module driver.
    
    Update cm_xxx accessor, move definition to the proper header file and
    update copyrights.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Cc: Todd Poynor <toddpoynor@google.com>
    [paul@pwsan.com: renamed 'omap4_cm_' fns to 'omap4_cminst_'; removed empty
     fn prototype section from cm44xx.h; incorporated comments from Todd;
     documented some functions]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 1f6f47f1d82a..00241ea5bf09 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -146,7 +146,7 @@
 #include <plat/prcm.h>
 
 #include "cm2xxx_3xxx.h"
-#include "cm44xx.h"
+#include "cminst44xx.h"
 #include "prm2xxx_3xxx.h"
 #include "prm44xx.h"
 #include "mux.h"
@@ -1060,7 +1060,7 @@ static int _init_clocks(struct omap_hwmod *oh, void *data)
  * Wait for a module @oh to leave slave idle.  Returns 0 if the module
  * does not have an IDLEST bit or if the module successfully leaves
  * slave idle; otherwise, pass along the return value of the
- * appropriate *_cm_wait_module_ready() function.
+ * appropriate *_cm*_wait_module_ready() function.
  */
 static int _wait_target_ready(struct omap_hwmod *oh)
 {
@@ -1087,7 +1087,13 @@ static int _wait_target_ready(struct omap_hwmod *oh)
 						 oh->prcm.omap2.idlest_reg_id,
 						 oh->prcm.omap2.idlest_idle_bit);
 	} else if (cpu_is_omap44xx()) {
-		ret = omap4_cm_wait_module_ready(oh->prcm.omap4.clkctrl_reg);
+		if (!oh->clkdm)
+			return -EINVAL;
+
+		ret = omap4_cminst_wait_module_ready(oh->clkdm->prcm_partition,
+						     oh->clkdm->cm_inst,
+						     oh->clkdm->clkdm_offs,
+						     oh->prcm.omap4.clkctrl_offs);
 	} else {
 		BUG();
 	};

commit 6ae769973adf1325115d0dfe3fec17e26cbacd81
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Sun Jul 10 05:56:30 2011 -0600

    OMAP2+: hwmod: Init clkdm field at boot time
    
    At boot time, lookup the clkdm_name to get the clkdm
    structure pointer for further usage.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 02b6016393a8..1f6f47f1d82a 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -990,9 +990,40 @@ static struct omap_hwmod *_lookup(const char *name)
 
 	return oh;
 }
+/**
+ * _init_clkdm - look up a clockdomain name, store pointer in omap_hwmod
+ * @oh: struct omap_hwmod *
+ *
+ * Convert a clockdomain name stored in a struct omap_hwmod into a
+ * clockdomain pointer, and save it into the struct omap_hwmod.
+ * return -EINVAL if clkdm_name does not exist or if the lookup failed.
+ */
+static int _init_clkdm(struct omap_hwmod *oh)
+{
+	if (cpu_is_omap24xx() || cpu_is_omap34xx())
+		return 0;
+
+	if (!oh->clkdm_name) {
+		pr_warning("omap_hwmod: %s: no clkdm_name\n", oh->name);
+		return -EINVAL;
+	}
+
+	oh->clkdm = clkdm_lookup(oh->clkdm_name);
+	if (!oh->clkdm) {
+		pr_warning("omap_hwmod: %s: could not associate to clkdm %s\n",
+			oh->name, oh->clkdm_name);
+		return -EINVAL;
+	}
+
+	pr_debug("omap_hwmod: %s: associated to clkdm %s\n",
+		oh->name, oh->clkdm_name);
+
+	return 0;
+}
 
 /**
- * _init_clocks - clk_get() all clocks associated with this hwmod
+ * _init_clocks - clk_get() all clocks associated with this hwmod. Retrieve as
+ * well the clockdomain.
  * @oh: struct omap_hwmod *
  * @data: not used; pass NULL
  *
@@ -1012,6 +1043,7 @@ static int _init_clocks(struct omap_hwmod *oh, void *data)
 	ret |= _init_main_clk(oh);
 	ret |= _init_interface_clks(oh);
 	ret |= _init_opt_clks(oh);
+	ret |= _init_clkdm(oh);
 
 	if (!ret)
 		oh->_state = _HWMOD_STATE_CLKS_INITED;

commit 6d3c55fd4f0f94a9455d30df9414ddb0f755f402
Author: Avinash.H.M <avinashhm@ti.com>
Date:   Sun Jul 10 05:27:16 2011 -0600

    OMAP: hwmod: fix the i2c-reset timeout during bootup
    
    The sequence of _ocp_softreset doesn't work for i2c. The i2c module has a
    special sequence to reset the module. The sequence is
     - Disable the I2C.
     - Write to SOFTRESET bit.
     - Enable the I2C.
     - Poll on the RESETDONE bit.
    The sequence is implemented as a function and the i2c_class is updated with
    the correct 'reset' pointer.  omap_hwmod_softreset function is implemented
    which triggers the softreset by writing into sysconfig register. On following
    this sequence, i2c module resets properly and timeouts are not seen.
    
    Cc: Rajendra Nayak <rnayak@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Avinash.H.M <avinashhm@ti.com>
    [paul@pwsan.com: combined this patch with a patch to remove
     HWMOD_INIT_NO_RESET from the 44xx hwmod flags; change register
     offset conditional code to use the IP block revision; minor code
     cleanup]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 7d242c9e2a2c..02b6016393a8 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1655,6 +1655,33 @@ void omap_hwmod_write(u32 v, struct omap_hwmod *oh, u16 reg_offs)
 		__raw_writel(v, oh->_mpu_rt_va + reg_offs);
 }
 
+/**
+ * omap_hwmod_softreset - reset a module via SYSCONFIG.SOFTRESET bit
+ * @oh: struct omap_hwmod *
+ *
+ * This is a public function exposed to drivers. Some drivers may need to do
+ * some settings before and after resetting the device.  Those drivers after
+ * doing the necessary settings could use this function to start a reset by
+ * setting the SYSCONFIG.SOFTRESET bit.
+ */
+int omap_hwmod_softreset(struct omap_hwmod *oh)
+{
+	u32 v;
+	int ret;
+
+	if (!oh || !(oh->_sysc_cache))
+		return -EINVAL;
+
+	v = oh->_sysc_cache;
+	ret = _set_softreset(oh, &v);
+	if (ret)
+		goto error;
+	_write_sysconfig(v, oh);
+
+error:
+	return ret;
+}
+
 /**
  * omap_hwmod_set_slave_idlemode - set the hwmod's OCP slave idlemode
  * @oh: struct omap_hwmod *

commit c402c0d9dfa8d4fb54dd98fc12525f39d0f29bfe
Merge: a7cd4b08d985 34617e2a4d33 7e69ed974259 571078aa3485 476e5be710be 8f0d69dedcf1
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Jul 9 20:24:07 2011 -0600

    Merge branches 'dmtimer_precleanup_3.1', 'hwmod_core_cleanup_a_3.1', 'combine_common_hwmod_3.1', 'omap4_hwmod_data_cleanup_a_3.1', 'clock_cleanup_a_3.1', 'prcm_cleanup_a_3.1', 'omap_pm_cleanup_3.1' and 'omap_device_cleanup_3.1' into prcm-cleanup-3.1

commit bc6149587b309e3231e5ac7138b84197813e17ec
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Jul 9 19:14:07 2011 -0600

    omap_hwmod: use a terminator record with omap_hwmod_dma_info arrays
    
    Previously, struct omap_hwmod_dma_info arrays were unterminated; and
    users of these arrays used the ARRAY_SIZE() macro to determine the
    length of the array.  However, ARRAY_SIZE() only works when the array
    is in the same scope as the macro user.
    
    So far this hasn't been a problem.  However, to reduce duplicated
    data, a subsequent patch will move common data to a separate, shared
    file.  When this is done, ARRAY_SIZE() will no longer be usable.
    
    This patch removes ARRAY_SIZE() usage for struct omap_hwmod_dma_info
    arrays and uses a sentinel value (irq == -1) as the array terminator
    instead.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 21e3eb8e83c1..d1a8bdefea3f 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -701,6 +701,29 @@ static int _count_mpu_irqs(struct omap_hwmod *oh)
 	return i;
 }
 
+/**
+ * _count_sdma_reqs - count the number of SDMA request lines associated with @oh
+ * @oh: struct omap_hwmod *oh
+ *
+ * Count and return the number of SDMA request lines associated with
+ * the hwmod @oh.  Used to allocate struct resource data.  Returns 0
+ * if @oh is NULL.
+ */
+static int _count_sdma_reqs(struct omap_hwmod *oh)
+{
+	struct omap_hwmod_dma_info *ohdi;
+	int i = 0;
+
+	if (!oh || !oh->sdma_reqs)
+		return 0;
+
+	do {
+		ohdi = &oh->sdma_reqs[i++];
+	} while (ohdi->dma_req != -1);
+
+	return i;
+}
+
 /**
  * _count_ocp_if_addr_spaces - count the number of address space entries for @oh
  * @oh: struct omap_hwmod *oh
@@ -1987,7 +2010,7 @@ int omap_hwmod_count_resources(struct omap_hwmod *oh)
 {
 	int ret, i;
 
-	ret = _count_mpu_irqs(oh) + oh->sdma_reqs_cnt;
+	ret = _count_mpu_irqs(oh) + _count_sdma_reqs(oh);
 
 	for (i = 0; i < oh->slaves_cnt; i++)
 		ret += _count_ocp_if_addr_spaces(oh->slaves[i]);
@@ -2007,7 +2030,7 @@ int omap_hwmod_count_resources(struct omap_hwmod *oh)
  */
 int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 {
-	int i, j, mpu_irqs_cnt;
+	int i, j, mpu_irqs_cnt, sdma_reqs_cnt;
 	int r = 0;
 
 	/* For each IRQ, DMA, memory area, fill in array.*/
@@ -2021,7 +2044,8 @@ int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 		r++;
 	}
 
-	for (i = 0; i < oh->sdma_reqs_cnt; i++) {
+	sdma_reqs_cnt = _count_sdma_reqs(oh);
+	for (i = 0; i < sdma_reqs_cnt; i++) {
 		(res + r)->name = (oh->sdma_reqs + i)->name;
 		(res + r)->start = (oh->sdma_reqs + i)->dma_req;
 		(res + r)->end = (oh->sdma_reqs + i)->dma_req;

commit 212738a4499d278254ed6fdb400e3b4be4cb1de2
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Jul 9 19:14:06 2011 -0600

    omap_hwmod: use a terminator record with omap_hwmod_mpu_irqs arrays
    
    Previously, struct omap_hwmod_mpu_irqs arrays were unterminated; and
    users of these arrays used the ARRAY_SIZE() macro to determine the
    length of the array.  However, ARRAY_SIZE() only works when the array
    is in the same scope as the macro user.
    
    So far this hasn't been a problem.  However, to reduce duplicated
    data, a subsequent patch will move common data to a separate, shared
    file.  When this is done, ARRAY_SIZE() will no longer be usable.
    
    This patch removes ARRAY_SIZE() usage for struct omap_hwmod_mpu_irqs
    arrays and uses a sentinel value (irq == -1) as the array terminator
    instead.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 77094d75367f..21e3eb8e83c1 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -678,6 +678,29 @@ static void _disable_optional_clocks(struct omap_hwmod *oh)
 		}
 }
 
+/**
+ * _count_mpu_irqs - count the number of MPU IRQ lines associated with @oh
+ * @oh: struct omap_hwmod *oh
+ *
+ * Count and return the number of MPU IRQs associated with the hwmod
+ * @oh.  Used to allocate struct resource data.  Returns 0 if @oh is
+ * NULL.
+ */
+static int _count_mpu_irqs(struct omap_hwmod *oh)
+{
+	struct omap_hwmod_irq_info *ohii;
+	int i = 0;
+
+	if (!oh || !oh->mpu_irqs)
+		return 0;
+
+	do {
+		ohii = &oh->mpu_irqs[i++];
+	} while (ohii->irq != -1);
+
+	return i;
+}
+
 /**
  * _count_ocp_if_addr_spaces - count the number of address space entries for @oh
  * @oh: struct omap_hwmod *oh
@@ -1964,7 +1987,7 @@ int omap_hwmod_count_resources(struct omap_hwmod *oh)
 {
 	int ret, i;
 
-	ret = oh->mpu_irqs_cnt + oh->sdma_reqs_cnt;
+	ret = _count_mpu_irqs(oh) + oh->sdma_reqs_cnt;
 
 	for (i = 0; i < oh->slaves_cnt; i++)
 		ret += _count_ocp_if_addr_spaces(oh->slaves[i]);
@@ -1984,12 +2007,13 @@ int omap_hwmod_count_resources(struct omap_hwmod *oh)
  */
 int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 {
-	int i, j;
+	int i, j, mpu_irqs_cnt;
 	int r = 0;
 
 	/* For each IRQ, DMA, memory area, fill in array.*/
 
-	for (i = 0; i < oh->mpu_irqs_cnt; i++) {
+	mpu_irqs_cnt = _count_mpu_irqs(oh);
+	for (i = 0; i < mpu_irqs_cnt; i++) {
 		(res + r)->name = (oh->mpu_irqs + i)->name;
 		(res + r)->start = (oh->mpu_irqs + i)->irq;
 		(res + r)->end = (oh->mpu_irqs + i)->irq;

commit 78183f3fdf76f422431a81852468be01b36db325
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Jul 9 19:14:05 2011 -0600

    omap_hwmod: use a null structure record to terminate omap_hwmod_addr_space arrays
    
    Previously, struct omap_hwmod_addr_space arrays were unterminated; and
    users of these arrays used the ARRAY_SIZE() macro to determine the
    length of the array.  However, ARRAY_SIZE() only works when the array
    is in the same scope as the macro user.
    
    So far this hasn't been a problem.  However, to reduce duplicated
    data, a subsequent patch will move common data to a separate, shared
    file.  When this is done, ARRAY_SIZE() will no longer be usable.
    
    This patch removes ARRAY_SIZE() usage for struct omap_hwmod_addr_space
    arrays and uses a null structure member as the array terminator
    instead.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 293fa6cd50e1..77094d75367f 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2,6 +2,7 @@
  * omap_hwmod implementation for OMAP2/3/4
  *
  * Copyright (C) 2009-2011 Nokia Corporation
+ * Copyright (C) 2011 Texas Instruments, Inc.
  *
  * Paul Walmsley, Benot Cousson, Kevin Hilman
  *
@@ -677,6 +678,29 @@ static void _disable_optional_clocks(struct omap_hwmod *oh)
 		}
 }
 
+/**
+ * _count_ocp_if_addr_spaces - count the number of address space entries for @oh
+ * @oh: struct omap_hwmod *oh
+ *
+ * Count and return the number of address space ranges associated with
+ * the hwmod @oh.  Used to allocate struct resource data.  Returns 0
+ * if @oh is NULL.
+ */
+static int _count_ocp_if_addr_spaces(struct omap_hwmod_ocp_if *os)
+{
+	struct omap_hwmod_addr_space *mem;
+	int i = 0;
+
+	if (!os || !os->addr)
+		return 0;
+
+	do {
+		mem = &os->addr[i++];
+	} while (mem->pa_start != mem->pa_end);
+
+	return i;
+}
+
 /**
  * _find_mpu_port_index - find hwmod OCP slave port ID intended for MPU use
  * @oh: struct omap_hwmod *
@@ -722,8 +746,7 @@ static void __iomem * __init _find_mpu_rt_base(struct omap_hwmod *oh, u8 index)
 {
 	struct omap_hwmod_ocp_if *os;
 	struct omap_hwmod_addr_space *mem;
-	int i;
-	int found = 0;
+	int i = 0, found = 0;
 	void __iomem *va_start;
 
 	if (!oh || oh->slaves_cnt == 0)
@@ -731,12 +754,14 @@ static void __iomem * __init _find_mpu_rt_base(struct omap_hwmod *oh, u8 index)
 
 	os = oh->slaves[index];
 
-	for (i = 0, mem = os->addr; i < os->addr_cnt; i++, mem++) {
-		if (mem->flags & ADDR_TYPE_RT) {
+	if (!os->addr)
+		return NULL;
+
+	do {
+		mem = &os->addr[i++];
+		if (mem->flags & ADDR_TYPE_RT)
 			found = 1;
-			break;
-		}
-	}
+	} while (!found && mem->pa_start != mem->pa_end);
 
 	if (found) {
 		va_start = ioremap(mem->pa_start, mem->pa_end - mem->pa_start);
@@ -1942,7 +1967,7 @@ int omap_hwmod_count_resources(struct omap_hwmod *oh)
 	ret = oh->mpu_irqs_cnt + oh->sdma_reqs_cnt;
 
 	for (i = 0; i < oh->slaves_cnt; i++)
-		ret += oh->slaves[i]->addr_cnt;
+		ret += _count_ocp_if_addr_spaces(oh->slaves[i]);
 
 	return ret;
 }
@@ -1982,10 +2007,12 @@ int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 
 	for (i = 0; i < oh->slaves_cnt; i++) {
 		struct omap_hwmod_ocp_if *os;
+		int addr_cnt;
 
 		os = oh->slaves[i];
+		addr_cnt = _count_ocp_if_addr_spaces(os);
 
-		for (j = 0; j < os->addr_cnt; j++) {
+		for (j = 0; j < addr_cnt; j++) {
 			(res + r)->name = (os->addr + j)->name;
 			(res + r)->start = (os->addr + j)->pa_start;
 			(res + r)->end = (os->addr + j)->pa_end;

commit 34617e2a4d331fdd8172077d8c70a0421fc136e6
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Fri Jul 1 22:54:07 2011 +0200

    OMAP: hwmod: Move pr_debug to improve the readability
    
    Move the pr_debug at the top of the function
    to trace the entry even if the first test is failing.
    That help understanding that we entered the function
    but failed in it.
    
    Move the _enable last part out of the test to reduce
    indentation and improve readability.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 64e983046217..e530bcbdebf4 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1242,6 +1242,8 @@ static int _enable(struct omap_hwmod *oh)
 {
 	int r;
 
+	pr_debug("omap_hwmod: %s: enabling\n", oh->name);
+
 	if (oh->_state != _HWMOD_STATE_INITIALIZED &&
 	    oh->_state != _HWMOD_STATE_IDLE &&
 	    oh->_state != _HWMOD_STATE_DISABLED) {
@@ -1250,8 +1252,6 @@ static int _enable(struct omap_hwmod *oh)
 		return -EINVAL;
 	}
 
-	pr_debug("omap_hwmod: %s: enabling\n", oh->name);
-
 	/* Mux pins for device runtime if populated */
 	if (oh->mux && (!oh->mux->enabled ||
 			((oh->_state == _HWMOD_STATE_IDLE) &&
@@ -1271,19 +1271,21 @@ static int _enable(struct omap_hwmod *oh)
 		_deassert_hardreset(oh, oh->rst_lines[0].name);
 
 	r = _wait_target_ready(oh);
-	if (!r) {
-		oh->_state = _HWMOD_STATE_ENABLED;
-
-		/* Access the sysconfig only if the target is ready */
-		if (oh->class->sysc) {
-			if (!(oh->_int_flags & _HWMOD_SYSCONFIG_LOADED))
-				_update_sysc_cache(oh);
-			_enable_sysc(oh);
-		}
-	} else {
-		_disable_clocks(oh);
+	if (r) {
 		pr_debug("omap_hwmod: %s: _wait_target_ready: %d\n",
 			 oh->name, r);
+		_disable_clocks(oh);
+
+		return r;
+	}
+
+	oh->_state = _HWMOD_STATE_ENABLED;
+
+	/* Access the sysconfig only if the target is ready */
+	if (oh->class->sysc) {
+		if (!(oh->_int_flags & _HWMOD_SYSCONFIG_LOADED))
+			_update_sysc_cache(oh);
+		_enable_sysc(oh);
 	}
 
 	return r;
@@ -1299,14 +1301,14 @@ static int _enable(struct omap_hwmod *oh)
  */
 static int _idle(struct omap_hwmod *oh)
 {
+	pr_debug("omap_hwmod: %s: idling\n", oh->name);
+
 	if (oh->_state != _HWMOD_STATE_ENABLED) {
 		WARN(1, "omap_hwmod: %s: idle state can only be entered from "
 		     "enabled state\n", oh->name);
 		return -EINVAL;
 	}
 
-	pr_debug("omap_hwmod: %s: idling\n", oh->name);
-
 	if (oh->class->sysc)
 		_idle_sysc(oh);
 	_del_initiator_dep(oh, mpu_oh);

commit 6652271a2556c086c04658dce16de2947e849ffd
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Fri Jul 1 22:54:06 2011 +0200

    OMAP: hwmod: Add warnings if enable failed
    
    Change the debug into warning to check what IPs are failing.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index df91bb1dc972..64e983046217 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -944,6 +944,8 @@ static int _init_clocks(struct omap_hwmod *oh, void *data)
 
 	if (!ret)
 		oh->_state = _HWMOD_STATE_CLKS_INITED;
+	else
+		pr_warning("omap_hwmod: %s: cannot _init_clocks\n", oh->name);
 
 	return ret;
 }

commit 31f62866c578b3d47ef7810b336e9e193b90167f
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Fri Jul 1 22:54:05 2011 +0200

    OMAP2+: hwmod: Fix the HW reset management
    
    The HW reset must be de-assert after the clocks are enabled
    but before waiting for the target to be ready. Otherwise the
    reset might not work properly since the clock is not running
    to proceed the reset.
    
    De-assert the reset after _enable_clocks and before
    _wait_target_ready.
    Re-assert it only when the clocks are disabled.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index f4014179d601..df91bb1dc972 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1250,15 +1250,6 @@ static int _enable(struct omap_hwmod *oh)
 
 	pr_debug("omap_hwmod: %s: enabling\n", oh->name);
 
-	/*
-	 * If an IP contains only one HW reset line, then de-assert it in order
-	 * to allow to enable the clocks. Otherwise the PRCM will return
-	 * Intransition status, and the init will failed.
-	 */
-	if ((oh->_state == _HWMOD_STATE_INITIALIZED ||
-	     oh->_state == _HWMOD_STATE_DISABLED) && oh->rst_lines_cnt == 1)
-		_deassert_hardreset(oh, oh->rst_lines[0].name);
-
 	/* Mux pins for device runtime if populated */
 	if (oh->mux && (!oh->mux->enabled ||
 			((oh->_state == _HWMOD_STATE_IDLE) &&
@@ -1268,6 +1259,15 @@ static int _enable(struct omap_hwmod *oh)
 	_add_initiator_dep(oh, mpu_oh);
 	_enable_clocks(oh);
 
+	/*
+	 * If an IP contains only one HW reset line, then de-assert it in order
+	 * to allow the module state transition. Otherwise the PRCM will return
+	 * Intransition status, and the init will failed.
+	 */
+	if ((oh->_state == _HWMOD_STATE_INITIALIZED ||
+	     oh->_state == _HWMOD_STATE_DISABLED) && oh->rst_lines_cnt == 1)
+		_deassert_hardreset(oh, oh->rst_lines[0].name);
+
 	r = _wait_target_ready(oh);
 	if (!r) {
 		oh->_state = _HWMOD_STATE_ENABLED;
@@ -1396,13 +1396,6 @@ static int _shutdown(struct omap_hwmod *oh)
 		_shutdown_sysc(oh);
 	}
 
-	/*
-	 * If an IP contains only one HW reset line, then assert it
-	 * before disabling the clocks and shutting down the IP.
-	 */
-	if (oh->rst_lines_cnt == 1)
-		_assert_hardreset(oh, oh->rst_lines[0].name);
-
 	/* clocks and deps are already disabled in idle */
 	if (oh->_state == _HWMOD_STATE_ENABLED) {
 		_del_initiator_dep(oh, mpu_oh);
@@ -1411,6 +1404,13 @@ static int _shutdown(struct omap_hwmod *oh)
 	}
 	/* XXX Should this code also force-disable the optional clocks? */
 
+	/*
+	 * If an IP contains only one HW reset line, then assert it
+	 * after disabling the clocks and before shutting down the IP.
+	 */
+	if (oh->rst_lines_cnt == 1)
+		_assert_hardreset(oh, oh->rst_lines[0].name);
+
 	/* Mux pins to safe mode or use populated off mode values */
 	if (oh->mux)
 		omap_hwmod_mux(oh->mux, _HWMOD_STATE_DISABLED);

commit d24bcaa3fa711f7dd9c4aacf3c58083cf666418f
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Fri Jul 1 22:54:04 2011 +0200

    OMAP2+: hwmod: Remove _populate_mpu_rt_base warning
    
    It is perfectly valid for some hwmod to not have any
    register target address for sysconfig. This is especially
    true for interconnect hwmods.
    Remove the warning.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 3800084a1e7a..f4014179d601 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1704,9 +1704,6 @@ static int __init _populate_mpu_rt_base(struct omap_hwmod *oh, void *data)
 		return 0;
 
 	oh->_mpu_rt_va = _find_mpu_rt_base(oh, oh->_mpu_port_index);
-	if (!oh->_mpu_rt_va)
-		pr_warning("omap_hwmod: %s found no _mpu_rt_va for %s\n",
-				__func__, oh->name);
 
 	return 0;
 }

commit 1fe741139be5acfe3758b53cdbf0b5e3d26db3fe
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Fri Jul 1 22:54:03 2011 +0200

    OMAP2+: hwmod: Do not write the enawakeup bit if SYSC_HAS_ENAWAKEUP is not set
    
    The Type 2 type of IPs will not have any enawakeup bit in their sysconfig.
    Writing to that bit will instead trigger a softreset.
    Check the flag to write this bit only if the module supports it.
    
    Reported-by: Miguel Vadillo <vadillo@ti.com>
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index cbc2a8a4ce39..3800084a1e7a 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -387,8 +387,6 @@ static int _set_module_autoidle(struct omap_hwmod *oh, u8 autoidle,
  */
 static int _enable_wakeup(struct omap_hwmod *oh, u32 *v)
 {
-	u32 wakeup_mask;
-
 	if (!oh->class->sysc ||
 	    !((oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP) ||
 	      (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP) ||
@@ -400,9 +398,8 @@ static int _enable_wakeup(struct omap_hwmod *oh, u32 *v)
 		return -EINVAL;
 	}
 
-	wakeup_mask = (0x1 << oh->class->sysc->sysc_fields->enwkup_shift);
-
-	*v |= wakeup_mask;
+	if (oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP)
+		*v |= 0x1 << oh->class->sysc->sysc_fields->enwkup_shift;
 
 	if (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP)
 		_set_slave_idlemode(oh, HWMOD_IDLEMODE_SMART_WKUP, v);
@@ -425,8 +422,6 @@ static int _enable_wakeup(struct omap_hwmod *oh, u32 *v)
  */
 static int _disable_wakeup(struct omap_hwmod *oh, u32 *v)
 {
-	u32 wakeup_mask;
-
 	if (!oh->class->sysc ||
 	    !((oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP) ||
 	      (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP) ||
@@ -438,9 +433,8 @@ static int _disable_wakeup(struct omap_hwmod *oh, u32 *v)
 		return -EINVAL;
 	}
 
-	wakeup_mask = (0x1 << oh->class->sysc->sysc_fields->enwkup_shift);
-
-	*v &= ~wakeup_mask;
+	if (oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP)
+		*v &= ~(0x1 << oh->class->sysc->sysc_fields->enwkup_shift);
 
 	if (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP)
 		_set_slave_idlemode(oh, HWMOD_IDLEMODE_SMART, v);

commit 6481c73c22613660a5b791d2b4d0faf60508d731
Author: Miguel Vadillo <vadillo@ti.com>
Date:   Fri Jul 1 22:54:02 2011 +0200

    OMAP2+: hwmod: Enable module in shutdown to access sysconfig
    
    When calling the shutdown, the module may be already in idle.
    Accessing the sysconfig register will then lead to a crash.
    In that case, re-enable the module in order to allow the access
    to the sysconfig register.
    
    Signed-off-by: Miguel Vadillo <vadillo@ti.com>
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 384d3c3ec36d..cbc2a8a4ce39 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1396,8 +1396,11 @@ static int _shutdown(struct omap_hwmod *oh)
 		}
 	}
 
-	if (oh->class->sysc)
+	if (oh->class->sysc) {
+		if (oh->_state == _HWMOD_STATE_IDLE)
+			_enable(oh);
 		_shutdown_sysc(oh);
+	}
 
 	/*
 	 * If an IP contains only one HW reset line, then assert it

commit 724019b0137acf2ea43e5ca854798851f5ebf51f
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Fri Jul 1 22:54:00 2011 +0200

    OMAP2+: hwmod: Fix smart-standby + wakeup support
    
    The commit 86009eb326afde34ffdc5648cd344aa86b8d58d4 was adding
    the wakeup support for new OMAP4 IPs. This support is incomplete for
    busmaster IPs that need as well to use smart-standby with wakeup.
    
    This new standbymode is suported on HSI and USB_HOST_FS for the moment.
    
    Add the new MSTANDBY_SMART_WKUP flag to mark the IPs that support this
    capability.
    
    Enable this new mode when applicable in _enable_wakeup, _disable_wakeup,
    _enable_sysc and _idle_sysc.
    
    The omap_hwmod_44xx_data.c will have to be updated to add this new flag.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Djamil Elaidi <d-elaidi@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 293fa6cd50e1..384d3c3ec36d 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -391,7 +391,8 @@ static int _enable_wakeup(struct omap_hwmod *oh, u32 *v)
 
 	if (!oh->class->sysc ||
 	    !((oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP) ||
-	      (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP)))
+	      (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP) ||
+	      (oh->class->sysc->idlemodes & MSTANDBY_SMART_WKUP)))
 		return -EINVAL;
 
 	if (!oh->class->sysc->sysc_fields) {
@@ -405,6 +406,8 @@ static int _enable_wakeup(struct omap_hwmod *oh, u32 *v)
 
 	if (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP)
 		_set_slave_idlemode(oh, HWMOD_IDLEMODE_SMART_WKUP, v);
+	if (oh->class->sysc->idlemodes & MSTANDBY_SMART_WKUP)
+		_set_master_standbymode(oh, HWMOD_IDLEMODE_SMART_WKUP, v);
 
 	/* XXX test pwrdm_get_wken for this hwmod's subsystem */
 
@@ -426,7 +429,8 @@ static int _disable_wakeup(struct omap_hwmod *oh, u32 *v)
 
 	if (!oh->class->sysc ||
 	    !((oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP) ||
-	      (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP)))
+	      (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP) ||
+	      (oh->class->sysc->idlemodes & MSTANDBY_SMART_WKUP)))
 		return -EINVAL;
 
 	if (!oh->class->sysc->sysc_fields) {
@@ -440,6 +444,8 @@ static int _disable_wakeup(struct omap_hwmod *oh, u32 *v)
 
 	if (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP)
 		_set_slave_idlemode(oh, HWMOD_IDLEMODE_SMART, v);
+	if (oh->class->sysc->idlemodes & MSTANDBY_SMART_WKUP)
+		_set_master_standbymode(oh, HWMOD_IDLEMODE_SMART_WKUP, v);
 
 	/* XXX test pwrdm_get_wken for this hwmod's subsystem */
 
@@ -781,8 +787,16 @@ static void _enable_sysc(struct omap_hwmod *oh)
 	}
 
 	if (sf & SYSC_HAS_MIDLEMODE) {
-		idlemode = (oh->flags & HWMOD_SWSUP_MSTANDBY) ?
-			HWMOD_IDLEMODE_NO : HWMOD_IDLEMODE_SMART;
+		if (oh->flags & HWMOD_SWSUP_MSTANDBY) {
+			idlemode = HWMOD_IDLEMODE_NO;
+		} else {
+			if (sf & SYSC_HAS_ENAWAKEUP)
+				_enable_wakeup(oh, &v);
+			if (oh->class->sysc->idlemodes & MSTANDBY_SMART_WKUP)
+				idlemode = HWMOD_IDLEMODE_SMART_WKUP;
+			else
+				idlemode = HWMOD_IDLEMODE_SMART;
+		}
 		_set_master_standbymode(oh, idlemode, &v);
 	}
 
@@ -840,8 +854,16 @@ static void _idle_sysc(struct omap_hwmod *oh)
 	}
 
 	if (sf & SYSC_HAS_MIDLEMODE) {
-		idlemode = (oh->flags & HWMOD_SWSUP_MSTANDBY) ?
-			HWMOD_IDLEMODE_FORCE : HWMOD_IDLEMODE_SMART;
+		if (oh->flags & HWMOD_SWSUP_MSTANDBY) {
+			idlemode = HWMOD_IDLEMODE_FORCE;
+		} else {
+			if (sf & SYSC_HAS_ENAWAKEUP)
+				_enable_wakeup(oh, &v);
+			if (oh->class->sysc->idlemodes & MSTANDBY_SMART_WKUP)
+				idlemode = HWMOD_IDLEMODE_SMART_WKUP;
+			else
+				idlemode = HWMOD_IDLEMODE_SMART;
+		}
 		_set_master_standbymode(oh, idlemode, &v);
 	}
 

commit 30ebad9d756a0b2c97c6c4ca6c5e6b799e3b64da
Author: Govindraj.R <govindraj.raja@ti.com>
Date:   Wed Jun 1 11:28:56 2011 +0530

    OMAP2+: mux: fix compilation warnings
    
    Fix below compilation warnings.
    
    arch/arm/mach-omap2/omap_hwmod.c: In function 'omap_hwmod_for_each':
    arch/arm/mach-omap2/omap_hwmod.c:1631: warning: 'ret' may be used uninitialized in this function
    
    arch/arm/mach-omap2/mux.c: In function 'omap_mux_get_gpio':
    arch/arm/mach-omap2/mux.c:917: warning: 'm' may be used uninitialized in this function
    
    Signed-off-by: Govindraj.R <govindraj.raja@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index e03429453ce7..293fa6cd50e1 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1628,7 +1628,7 @@ int omap_hwmod_for_each(int (*fn)(struct omap_hwmod *oh, void *data),
 			void *data)
 {
 	struct omap_hwmod *temp_oh;
-	int ret;
+	int ret = 0;
 
 	if (!fn)
 		return -EINVAL;

commit 029268e4c124a38b11ae965849ea2dfef724a568
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Mar 11 11:32:25 2011 -0800

    omap2+: Add separate list for dynamic pads to mux
    
    This avoids going through the list unnecessarily when
    idling devices for runtime PM.
    
    Based on an earlier patch by sricharan <r.sricharan@ti.com>.
    
    Signed-off-by: sricharan <r.sricharan@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 4c8329e4e6e1..e03429453ce7 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1244,7 +1244,9 @@ static int _enable(struct omap_hwmod *oh)
 		_deassert_hardreset(oh, oh->rst_lines[0].name);
 
 	/* Mux pins for device runtime if populated */
-	if (oh->mux)
+	if (oh->mux && (!oh->mux->enabled ||
+			((oh->_state == _HWMOD_STATE_IDLE) &&
+			 oh->mux->pads_dynamic)))
 		omap_hwmod_mux(oh->mux, _HWMOD_STATE_ENABLED);
 
 	_add_initiator_dep(oh, mpu_oh);
@@ -1293,7 +1295,7 @@ static int _idle(struct omap_hwmod *oh)
 	_disable_clocks(oh);
 
 	/* Mux pins for device idle if populated */
-	if (oh->mux)
+	if (oh->mux && oh->mux->pads_dynamic)
 		omap_hwmod_mux(oh->mux, _HWMOD_STATE_IDLE);
 
 	oh->_state = _HWMOD_STATE_IDLE;

commit 2d403fe03070b541cc93cfa915f6e6c592cf231c
Merge: 21ace5452ce3 cc1226e76350
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Mar 10 22:43:05 2011 -0700

    Merge remote branch 'remotes/origin/hwmod_a_2.6.39' into tmp-integration-2.6.39-20110310-024
    
    Conflicts:
            arch/arm/mach-omap2/omap_hwmod_2430_data.c
            arch/arm/mach-omap2/omap_hwmod_3xxx_data.c
            arch/arm/plat-omap/include/plat/omap_hwmod.h

commit 21ace5452ce3327f0d11f85b0c33dfcd0d20fdb2
Merge: 694606c4ef54 da0653fe01cd a05dcdb98011 570b54c7fae6 4ce1e5e14c4e 5f8662ba3da6 8c810e7e1445 692ab1f36b71 478f478bc1a5 2f4dd595f6d6
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Mar 10 22:41:28 2011 -0700

    Merge remote branches 'remotes/origin/pwrdm_clkdm_b_2.6.39', 'remotes/origin/pwrdm_add_can_lose_context_fns_2.6.39', 'remotes/origin/omap_device_a_2.6.39', 'remotes/origin/mmc_a_2.6.39', 'remotes/origin/hwmod_b_2.6.39', 'remotes/origin/dmtimer_a_2.6.39', 'remotes/origin/pwrdm_clkdm_a_2.6.39', 'remotes/origin/clkdm_statdep_omap4_2.6.39', 'remotes/origin/clk_a_2.6.39', 'remotes/origin/clk_autoidle_a_2.6.39', 'remotes/origin/clk_autoidle_b_2.6.39', 'remotes/origin/clk_b_2.6.39', 'remotes/origin/clk_clkdm_a_2.6.39', 'remotes/origin/misc_a_2.6.39', 'remotes/origin/for_2.6.39/omap3_hwmod_data' and 'remotes/origin/wdtimer_a_2.6.39' into tmp-integration-2.6.39-20110310-024

commit 570b54c7fae65b65320d5a7d4b2249c86eeaa497
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Mar 10 03:50:09 2011 -0700

    OMAP2+: clockdomain: add flag that will block autodeps from being added for a clockdomain
    
    Add a new clockdomain flag, CLKDM_NO_AUTODEPS, which, when marked on a
    clockdomain, will prevent "autodeps" from being associated with the
    clockdomain.  ("Autodeps" are sleep dependencies and wakeup
    dependencies from/to processor modules that are automatically added to
    a clockdomain when it is in hardware-supervised idle mode.  They are
    deprecated -- a relic from the old CDP trees -- but are still in use
    for OMAP3.)
    
    Also, prevent the hwmod code from adding or removing initiator
    dependencies for clockdomains with this flag set.
    
    This patch should allow others to test which clockdomains actually
    still need autodeps.
    
    Thanks to Kevin Hilman <khilman@ti.com> for noting that the original
    version should also modify the hwmod code.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index a68a2cf1be34..2dd1ea9859bc 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -460,14 +460,18 @@ static int _disable_wakeup(struct omap_hwmod *oh, u32 *v)
  * will be accessed by a particular initiator (e.g., if a module will
  * be accessed by the IVA, there should be a sleepdep between the IVA
  * initiator and the module).  Only applies to modules in smart-idle
- * mode.  Returns -EINVAL upon error or passes along
- * clkdm_add_sleepdep() value upon success.
+ * mode.  If the clockdomain is marked as not needing autodeps, return
+ * 0 without doing anything.  Otherwise, returns -EINVAL upon error or
+ * passes along clkdm_add_sleepdep() value upon success.
  */
 static int _add_initiator_dep(struct omap_hwmod *oh, struct omap_hwmod *init_oh)
 {
 	if (!oh->_clk)
 		return -EINVAL;
 
+	if (oh->_clk->clkdm && oh->_clk->clkdm->flags & CLKDM_NO_AUTODEPS)
+		return 0;
+
 	return clkdm_add_sleepdep(oh->_clk->clkdm, init_oh->_clk->clkdm);
 }
 
@@ -480,14 +484,18 @@ static int _add_initiator_dep(struct omap_hwmod *oh, struct omap_hwmod *init_oh)
  * be accessed by a particular initiator (e.g., if a module will not
  * be accessed by the IVA, there should be no sleepdep between the IVA
  * initiator and the module).  Only applies to modules in smart-idle
- * mode.  Returns -EINVAL upon error or passes along
- * clkdm_del_sleepdep() value upon success.
+ * mode.  If the clockdomain is marked as not needing autodeps, return
+ * 0 without doing anything.  Returns -EINVAL upon error or passes
+ * along clkdm_del_sleepdep() value upon success.
  */
 static int _del_initiator_dep(struct omap_hwmod *oh, struct omap_hwmod *init_oh)
 {
 	if (!oh->_clk)
 		return -EINVAL;
 
+	if (oh->_clk->clkdm && oh->_clk->clkdm->flags & CLKDM_NO_AUTODEPS)
+		return 0;
+
 	return clkdm_del_sleepdep(oh->_clk->clkdm, init_oh->_clk->clkdm);
 }
 

commit 9599217a06da5f5a95794ca9192c14317d441187
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Thu Mar 10 03:50:08 2011 -0700

    OMAP2+: hwmod: add API to handle autoidle mode
    
    Create a new API that forms a wrapper to _set_module_autoidle()
    to modify the AUTOIDLE bit.
    
    This API is intended to be used by drivers that requires direct
    manipulation of the AUTOIDLE bits in SYSCONFIG register.
    McBSP driver requires autoidle bit to be enabled/disabled while
    using sidetone feature.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    [paul@pwsan.com: restrict the hwmod states that the autoidle bit can be changed
     in; changed function name; dropped "int" from "unsigned int long"]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 816aeb97ba28..a68a2cf1be34 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1287,6 +1287,42 @@ static int _idle(struct omap_hwmod *oh)
 	return 0;
 }
 
+/**
+ * omap_hwmod_set_ocp_autoidle - set the hwmod's OCP autoidle bit
+ * @oh: struct omap_hwmod *
+ * @autoidle: desired AUTOIDLE bitfield value (0 or 1)
+ *
+ * Sets the IP block's OCP autoidle bit in hardware, and updates our
+ * local copy. Intended to be used by drivers that require
+ * direct manipulation of the AUTOIDLE bits.
+ * Returns -EINVAL if @oh is null or is not in the ENABLED state, or passes
+ * along the return value from _set_module_autoidle().
+ *
+ * Any users of this function should be scrutinized carefully.
+ */
+int omap_hwmod_set_ocp_autoidle(struct omap_hwmod *oh, u8 autoidle)
+{
+	u32 v;
+	int retval = 0;
+	unsigned long flags;
+
+	if (!oh || oh->_state != _HWMOD_STATE_ENABLED)
+		return -EINVAL;
+
+	spin_lock_irqsave(&oh->_lock, flags);
+
+	v = oh->_sysc_cache;
+
+	retval = _set_module_autoidle(oh, autoidle, &v);
+
+	if (!retval)
+		_write_sysconfig(v, oh);
+
+	spin_unlock_irqrestore(&oh->_lock, flags);
+
+	return retval;
+}
+
 /**
  * _shutdown - shutdown an omap_hwmod
  * @oh: struct omap_hwmod *

commit 43b01643355672a266b95c4719f47cd1abac4680
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Mar 10 03:50:07 2011 -0700

    OMAP2+: hwmod: allow board files to prevent devices from being reset upon init
    
    Some boards can't tolerate IP blocks being reset when they are initialized.
    Michael Bsch cites a case with the Nokia N810:
    
        http://www.spinics.net/lists/linux-omap/msg47277.html
    
    To allow such boards to continue working normally, allow board file
    maintainers to mark IP blocks to prevent them from being reset upon
    init.  This is done via a hwmod function, omap_hwmod_no_setup_reset().
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Michael Buesch <mb@bu3sch.de>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index e282e35769fd..816aeb97ba28 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2218,3 +2218,29 @@ u32 omap_hwmod_get_context_loss_count(struct omap_hwmod *oh)
 
 	return ret;
 }
+
+/**
+ * omap_hwmod_no_setup_reset - prevent a hwmod from being reset upon setup
+ * @oh: struct omap_hwmod *
+ *
+ * Prevent the hwmod @oh from being reset during the setup process.
+ * Intended for use by board-*.c files on boards with devices that
+ * cannot tolerate being reset.  Must be called before the hwmod has
+ * been set up.  Returns 0 upon success or negative error code upon
+ * failure.
+ */
+int omap_hwmod_no_setup_reset(struct omap_hwmod *oh)
+{
+	if (!oh)
+		return -EINVAL;
+
+	if (oh->_state != _HWMOD_STATE_REGISTERED) {
+		pr_err("omap_hwmod: %s: cannot prevent setup reset; in wrong state\n",
+			oh->name);
+		return -EINVAL;
+	}
+
+	oh->flags |= HWMOD_INIT_NO_RESET;
+
+	return 0;
+}

commit cc1226e7635011c7dd1e786770ed51ee751800f2
Author: omar ramirez <omar.ramirez@ti.com>
Date:   Fri Mar 4 13:32:44 2011 -0700

    OMAP2+: hwmod: use status bit info for reset line
    
    On OMAP2 and OMAP3 the reset ctrl shift doesn't match the
    status bit, as it does on OMAP4, when handling the reset lines.
    
    This patch adds a new member in the reset info structure, so now it
    can be added as part of hwmod data, and checked accordingly for
    OMAP2 or 3; otherwise, there could be cases when the shift masks
    doesn't match both of the registers, and a successful reset might
    throw an error message or vice versa.
    
    Signed-off-by: Omar Ramirez Luna <omar.ramirez@ti.com>
    [paul@pwsan.com: added a warning if st_shift used on OMAP4; renamed 'r'
     variable; improved some documentation]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 2146d9aa507a..005264779f8d 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -972,25 +972,29 @@ static int _wait_target_ready(struct omap_hwmod *oh)
 }
 
 /**
- * _lookup_hardreset - return the register bit shift for this hwmod/reset line
+ * _lookup_hardreset - fill register bit info for this hwmod/reset line
  * @oh: struct omap_hwmod *
  * @name: name of the reset line in the context of this hwmod
+ * @ohri: struct omap_hwmod_rst_info * that this function will fill in
  *
  * Return the bit position of the reset line that match the
  * input name. Return -ENOENT if not found.
  */
-static u8 _lookup_hardreset(struct omap_hwmod *oh, const char *name)
+static u8 _lookup_hardreset(struct omap_hwmod *oh, const char *name,
+			    struct omap_hwmod_rst_info *ohri)
 {
 	int i;
 
 	for (i = 0; i < oh->rst_lines_cnt; i++) {
 		const char *rst_line = oh->rst_lines[i].name;
 		if (!strcmp(rst_line, name)) {
-			u8 shift = oh->rst_lines[i].rst_shift;
-			pr_debug("omap_hwmod: %s: _lookup_hardreset: %s: %d\n",
-				 oh->name, rst_line, shift);
+			ohri->rst_shift = oh->rst_lines[i].rst_shift;
+			ohri->st_shift = oh->rst_lines[i].st_shift;
+			pr_debug("omap_hwmod: %s: %s: %s: rst %d st %d\n",
+				 oh->name, __func__, rst_line, ohri->rst_shift,
+				 ohri->st_shift);
 
-			return shift;
+			return 0;
 		}
 	}
 
@@ -1009,21 +1013,22 @@ static u8 _lookup_hardreset(struct omap_hwmod *oh, const char *name)
  */
 static int _assert_hardreset(struct omap_hwmod *oh, const char *name)
 {
-	u8 shift;
+	struct omap_hwmod_rst_info ohri;
+	u8 ret;
 
 	if (!oh)
 		return -EINVAL;
 
-	shift = _lookup_hardreset(oh, name);
-	if (IS_ERR_VALUE(shift))
-		return shift;
+	ret = _lookup_hardreset(oh, name, &ohri);
+	if (IS_ERR_VALUE(ret))
+		return ret;
 
 	if (cpu_is_omap24xx() || cpu_is_omap34xx())
 		return omap2_prm_assert_hardreset(oh->prcm.omap2.module_offs,
-						  shift);
+						  ohri.rst_shift);
 	else if (cpu_is_omap44xx())
 		return omap4_prm_assert_hardreset(oh->prcm.omap4.rstctrl_reg,
-						  shift);
+						  ohri.rst_shift);
 	else
 		return -EINVAL;
 }
@@ -1040,29 +1045,34 @@ static int _assert_hardreset(struct omap_hwmod *oh, const char *name)
  */
 static int _deassert_hardreset(struct omap_hwmod *oh, const char *name)
 {
-	u8 shift;
-	int r;
+	struct omap_hwmod_rst_info ohri;
+	int ret;
 
 	if (!oh)
 		return -EINVAL;
 
-	shift = _lookup_hardreset(oh, name);
-	if (IS_ERR_VALUE(shift))
-		return shift;
+	ret = _lookup_hardreset(oh, name, &ohri);
+	if (IS_ERR_VALUE(ret))
+		return ret;
 
-	if (cpu_is_omap24xx() || cpu_is_omap34xx())
-		r = omap2_prm_deassert_hardreset(oh->prcm.omap2.module_offs,
-						 shift);
-	else if (cpu_is_omap44xx())
-		r = omap4_prm_deassert_hardreset(oh->prcm.omap4.rstctrl_reg,
-						 shift);
-	else
+	if (cpu_is_omap24xx() || cpu_is_omap34xx()) {
+		ret = omap2_prm_deassert_hardreset(oh->prcm.omap2.module_offs,
+						   ohri.rst_shift,
+						   ohri.st_shift);
+	} else if (cpu_is_omap44xx()) {
+		if (ohri.st_shift)
+			pr_err("omap_hwmod: %s: %s: hwmod data error: OMAP4 does not support st_shift\n",
+			       oh->name, name);
+		ret = omap4_prm_deassert_hardreset(oh->prcm.omap4.rstctrl_reg,
+						   ohri.rst_shift);
+	} else {
 		return -EINVAL;
+	}
 
-	if (r == -EBUSY)
+	if (ret == -EBUSY)
 		pr_warning("omap_hwmod: %s: failed to hardreset\n", oh->name);
 
-	return r;
+	return ret;
 }
 
 /**
@@ -1075,21 +1085,22 @@ static int _deassert_hardreset(struct omap_hwmod *oh, const char *name)
  */
 static int _read_hardreset(struct omap_hwmod *oh, const char *name)
 {
-	u8 shift;
+	struct omap_hwmod_rst_info ohri;
+	u8 ret;
 
 	if (!oh)
 		return -EINVAL;
 
-	shift = _lookup_hardreset(oh, name);
-	if (IS_ERR_VALUE(shift))
-		return shift;
+	ret = _lookup_hardreset(oh, name, &ohri);
+	if (IS_ERR_VALUE(ret))
+		return ret;
 
 	if (cpu_is_omap24xx() || cpu_is_omap34xx()) {
 		return omap2_prm_is_hardreset_asserted(oh->prcm.omap2.module_offs,
-						       shift);
+						       ohri.st_shift);
 	} else if (cpu_is_omap44xx()) {
 		return omap4_prm_is_hardreset_asserted(oh->prcm.omap4.rstctrl_reg,
-						       shift);
+						       ohri.rst_shift);
 	} else {
 		return -EINVAL;
 	}

commit 09c35f2fee8a8633dde7b8b588b1cb496eb220a1
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Wed Feb 16 12:11:24 2011 +0000

    OMAP2+: hwmod: Fix what _init_clock returns
    
    _init_clock always returns 0 and does
    not propogate the error (in case of failure)
    back to the caller, causing _init_clocks to
    fail silently.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Acked-by: Benot Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index b18c36b1060f..2146d9aa507a 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -926,7 +926,7 @@ static int _init_clocks(struct omap_hwmod *oh, void *data)
 	if (!ret)
 		oh->_state = _HWMOD_STATE_CLKS_INITED;
 
-	return 0;
+	return ret;
 }
 
 /**

commit 8985b63d072413f0446fd2d0d654795f2d683323
Author: Tarun Kanti DebBarma <tarun.kanti@ti.com>
Date:   Thu Mar 3 14:22:46 2011 -0700

    OMAP2+: hwmod: fix incorrect computation of autoidle_mask
    
    Autoidle is a single bit, TIOCP_CFG[0], setting on OMAP1/2/3/4 platforms.
    In _set_module_autoidle() I am seeing 0x3 value where the mask is computed.
    This should be 0x1.
    
    v2:
    (1) Modified the subject.
    (2) Modified the description with further specific information.
    
    Baseline:
    git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git
    
    Tested Info:
    Boot tested on OMAP 1/2/3/4.
    
    Signed-off-by: Tarun Kanti DebBarma <tarun.kanti@ti.com>
    Acked-by: Rajendra Nayak <rnayak@ti.com>
    Acked-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index e282e35769fd..b18c36b1060f 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -373,7 +373,7 @@ static int _set_module_autoidle(struct omap_hwmod *oh, u8 autoidle,
 	}
 
 	autoidle_shift = oh->class->sysc->sysc_fields->autoidle_shift;
-	autoidle_mask = (0x3 << autoidle_shift);
+	autoidle_mask = (0x1 << autoidle_shift);
 
 	*v &= ~autoidle_mask;
 	*v |= autoidle << autoidle_shift;

commit b2833a0578453449dce1b8b8e54f67a544c5e37f
Merge: 12d7d4e0ed8f d594f1f31afe b176654e7796 0a0d128d023a 0005ae73cfe4
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Mar 2 17:11:18 2011 -0800

    Merge branches 'devel-iommu-mailbox', 'devel-mcbsp', 'devel-board' and 'devel-hsmmc' into omap-for-linus
    
    Conflicts:
            arch/arm/mach-omap2/omap_hwmod_44xx_data.c

commit a2debdbd1ad896a410019c9cf30785cad15930fc
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Feb 23 00:14:07 2011 -0700

    OMAP2+: hwmod: add ability to setup individual hwmods
    
    Add omap_hwmod_setup_one(), which is intended for use early in boot to
    selectively setup the hwmods needed for system clocksources and
    clockevents, and any other hwmod that is needed in early boot.
    omap_hwmod_setup_all() can then be called later in the boot process.
    The point is to minimize the amount of code that needs to be run
    early.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 43aa894174fa..f76f133780c8 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -901,7 +901,7 @@ static struct omap_hwmod *_lookup(const char *name)
  * @oh: struct omap_hwmod *
  * @data: not used; pass NULL
  *
- * Called by omap_hwmod_setup_all() (after omap2_clk_init()).
+ * Called by omap_hwmod_setup_*() (after omap2_clk_init()).
  * Resolves all clock names embedded in the hwmod.  Returns 0 on
  * success, or a negative error code on failure.
  */
@@ -1616,7 +1616,7 @@ int __init omap_hwmod_register(struct omap_hwmod **ohs)
 /*
  * _populate_mpu_rt_base - populate the virtual address for a hwmod
  *
- * Must be called only from omap_hwmod_setup_all() so ioremap works properly.
+ * Must be called only from omap_hwmod_setup_*() so ioremap works properly.
  * Assumes the caller takes care of locking if needed.
  */
 static int __init _populate_mpu_rt_base(struct omap_hwmod *oh, void *data)
@@ -1635,12 +1635,60 @@ static int __init _populate_mpu_rt_base(struct omap_hwmod *oh, void *data)
 	return 0;
 }
 
+/**
+ * omap_hwmod_setup_one - set up a single hwmod
+ * @oh_name: const char * name of the already-registered hwmod to set up
+ *
+ * Must be called after omap2_clk_init().  Resolves the struct clk
+ * names to struct clk pointers for each registered omap_hwmod.  Also
+ * calls _setup() on each hwmod.  Returns -EINVAL upon error or 0 upon
+ * success.
+ */
+int __init omap_hwmod_setup_one(const char *oh_name)
+{
+	struct omap_hwmod *oh;
+	int r;
+
+	pr_debug("omap_hwmod: %s: %s\n", oh_name, __func__);
+
+	if (!mpu_oh) {
+		pr_err("omap_hwmod: %s: cannot setup_one: MPU initiator hwmod %s not yet registered\n",
+		       oh_name, MPU_INITIATOR_NAME);
+		return -EINVAL;
+	}
+
+	oh = _lookup(oh_name);
+	if (!oh) {
+		WARN(1, "omap_hwmod: %s: hwmod not yet registered\n", oh_name);
+		return -EINVAL;
+	}
+
+	if (mpu_oh->_state == _HWMOD_STATE_REGISTERED && oh != mpu_oh)
+		omap_hwmod_setup_one(MPU_INITIATOR_NAME);
+
+	r = _populate_mpu_rt_base(oh, NULL);
+	if (IS_ERR_VALUE(r)) {
+		WARN(1, "omap_hwmod: %s: couldn't set mpu_rt_base\n", oh_name);
+		return -EINVAL;
+	}
+
+	r = _init_clocks(oh, NULL);
+	if (IS_ERR_VALUE(r)) {
+		WARN(1, "omap_hwmod: %s: couldn't init clocks\n", oh_name);
+		return -EINVAL;
+	}
+
+	_setup(oh, NULL);
+
+	return 0;
+}
+
 /**
  * omap_hwmod_setup - do some post-clock framework initialization
  *
  * Must be called after omap2_clk_init().  Resolves the struct clk names
  * to struct clk pointers for each registered omap_hwmod.  Also calls
- * _setup() on each hwmod.  Returns 0 upon success or -EINVAL upon error.
+ * _setup() on each hwmod.  Returns 0 upon success.
  */
 static int __init omap_hwmod_setup_all(void)
 {
@@ -1654,9 +1702,9 @@ static int __init omap_hwmod_setup_all(void)
 
 	r = omap_hwmod_for_each(_populate_mpu_rt_base, NULL);
 
-	/* XXX check return value */
 	r = omap_hwmod_for_each(_init_clocks, NULL);
-	WARN(r, "omap_hwmod: %s: _init_clocks failed\n", __func__);
+	WARN(IS_ERR_VALUE(r),
+	     "omap_hwmod: %s: _init_clocks failed\n", __func__);
 
 	omap_hwmod_for_each(_setup, NULL);
 
@@ -2182,8 +2230,8 @@ int omap_hwmod_for_each_by_class(const char *classname,
  * @state: state that _setup() should leave the hwmod in
  *
  * Sets the hwmod state that @oh will enter at the end of _setup()
- * (called by omap_hwmod_setup_all()).  Only valid to call between
- * calling omap_hwmod_register() and omap_hwmod_setup_all().  Returns
+ * (called by omap_hwmod_setup_*()).  Only valid to call between
+ * calling omap_hwmod_register() and omap_hwmod_setup_*().  Returns
  * 0 upon success or -EINVAL if there is a problem with the arguments
  * or if the hwmod is in the wrong state.
  */

commit 48d54f3fd20b435311f295b3bca3570096a2ac83
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Feb 23 00:14:07 2011 -0700

    OMAP2+: hwmod: ignore attempts to re-setup a hwmod
    
    Previously, if a hwmod had already been set up, and the code attempted
    to set up the hwmod again, an error would be returned.  This is not
    really useful behavior if we wish to allow the OMAP core code to setup
    the hwmods needed for the Linux clocksources and clockevents before
    the rest of the hwmods are setup.  So, instead of generating errors,
    just ignore the attempt to re-setup the hwmod.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index e4c934bd25b3..43aa894174fa 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -902,17 +902,15 @@ static struct omap_hwmod *_lookup(const char *name)
  * @data: not used; pass NULL
  *
  * Called by omap_hwmod_setup_all() (after omap2_clk_init()).
- * Resolves all clock names embedded in the hwmod.  Returns -EINVAL if
- * the omap_hwmod has not yet been registered or if the clocks have
- * already been initialized, 0 on success, or a non-zero error on
- * failure.
+ * Resolves all clock names embedded in the hwmod.  Returns 0 on
+ * success, or a negative error code on failure.
  */
 static int _init_clocks(struct omap_hwmod *oh, void *data)
 {
 	int ret = 0;
 
-	if (!oh || (oh->_state != _HWMOD_STATE_REGISTERED))
-		return -EINVAL;
+	if (oh->_state != _HWMOD_STATE_REGISTERED)
+		return 0;
 
 	pr_debug("omap_hwmod: %s: looking up clocks\n", oh->name);
 
@@ -1351,14 +1349,16 @@ static int _shutdown(struct omap_hwmod *oh)
  * @oh: struct omap_hwmod *
  *
  * Writes the CLOCKACTIVITY bits @clockact to the hwmod @oh
- * OCP_SYSCONFIG register.  Returns -EINVAL if the hwmod is in the
- * wrong state or returns 0.
+ * OCP_SYSCONFIG register.  Returns 0.
  */
 static int _setup(struct omap_hwmod *oh, void *data)
 {
 	int i, r;
 	u8 postsetup_state;
 
+	if (oh->_state != _HWMOD_STATE_CLKS_INITED)
+		return 0;
+
 	/* Set iclk autoidle mode */
 	if (oh->slaves_cnt > 0) {
 		for (i = 0; i < oh->slaves_cnt; i++) {
@@ -1621,6 +1621,9 @@ int __init omap_hwmod_register(struct omap_hwmod **ohs)
  */
 static int __init _populate_mpu_rt_base(struct omap_hwmod *oh, void *data)
 {
+	if (oh->_state != _HWMOD_STATE_REGISTERED)
+		return 0;
+
 	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
 		return 0;
 

commit 569edd705cc4e81a9129b5557f1fb259e21418a9
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Feb 23 00:14:06 2011 -0700

    OMAP2+: hwmod: find MPU initiator hwmod during in _register()
    
    Move the code that looks for the MPU initiator hwmod to run during
    the individual hwmod _register() function.  (Previously, it ran after
    all hwmods were registered in the omap_hwmod_late_init() function.)
    
    This is done so code can late-initialize a few individual hwmods --
    for example, for the system timer -- before the entire set of hwmods is
    initialized later in boot via omap_hwmod_late_init().
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 557d9eb609a6..e4c934bd25b3 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1452,7 +1452,7 @@ static int _setup(struct omap_hwmod *oh, void *data)
  */
 static int __init _register(struct omap_hwmod *oh)
 {
-	int ret, ms_id;
+	int ms_id;
 
 	if (!oh || !oh->name || !oh->class || !oh->class->name ||
 	    (oh->_state != _HWMOD_STATE_UNKNOWN))
@@ -1475,9 +1475,14 @@ static int __init _register(struct omap_hwmod *oh)
 
 	oh->_state = _HWMOD_STATE_REGISTERED;
 
-	ret = 0;
+	/*
+	 * XXX Rather than doing a strcmp(), this should test a flag
+	 * set in the hwmod data, inserted by the autogenerator code.
+	 */
+	if (!strcmp(oh->name, MPU_INITIATOR_NAME))
+		mpu_oh = oh;
 
-	return ret;
+	return 0;
 }
 
 
@@ -1632,22 +1637,24 @@ static int __init _populate_mpu_rt_base(struct omap_hwmod *oh, void *data)
  *
  * Must be called after omap2_clk_init().  Resolves the struct clk names
  * to struct clk pointers for each registered omap_hwmod.  Also calls
- * _setup() on each hwmod.  Returns 0.
+ * _setup() on each hwmod.  Returns 0 upon success or -EINVAL upon error.
  */
 static int __init omap_hwmod_setup_all(void)
 {
 	int r;
 
+	if (!mpu_oh) {
+		pr_err("omap_hwmod: %s: MPU initiator hwmod %s not yet registered\n",
+		       __func__, MPU_INITIATOR_NAME);
+		return -EINVAL;
+	}
+
 	r = omap_hwmod_for_each(_populate_mpu_rt_base, NULL);
 
 	/* XXX check return value */
 	r = omap_hwmod_for_each(_init_clocks, NULL);
 	WARN(r, "omap_hwmod: %s: _init_clocks failed\n", __func__);
 
-	mpu_oh = omap_hwmod_lookup(MPU_INITIATOR_NAME);
-	WARN(!mpu_oh, "omap_hwmod: could not find MPU initiator hwmod %s\n",
-	     MPU_INITIATOR_NAME);
-
 	omap_hwmod_for_each(_setup, NULL);
 
 	return 0;

commit 550c8092c55c22db8f843bad070fd1731292a75e
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Feb 28 11:58:14 2011 -0700

    OMAP2+: hwmod: rename some init functions
    
    Rename omap_hwmod_init() to omap_hwmod_register().  Rename
    omap_hwmod_late_init() to omap_hwmod_setup_all().  Also change all of
    the callers to reflect the new names.  While here, update some
    copyrights.
    
    Suggested by Tony Lindgren <tony@atomide.com>.
    
    N.B. The comment in mach-omap2/serial.c may no longer be correct, given
         recent changes in init order.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 2a7ab6adee82..557d9eb609a6 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1,7 +1,7 @@
 /*
  * omap_hwmod implementation for OMAP2/3/4
  *
- * Copyright (C) 2009-2010 Nokia Corporation
+ * Copyright (C) 2009-2011 Nokia Corporation
  *
  * Paul Walmsley, Benot Cousson, Kevin Hilman
  *
@@ -901,7 +901,7 @@ static struct omap_hwmod *_lookup(const char *name)
  * @oh: struct omap_hwmod *
  * @data: not used; pass NULL
  *
- * Called by omap_hwmod_late_init() (after omap2_clk_init()).
+ * Called by omap_hwmod_setup_all() (after omap2_clk_init()).
  * Resolves all clock names embedded in the hwmod.  Returns -EINVAL if
  * the omap_hwmod has not yet been registered or if the clocks have
  * already been initialized, 0 on success, or a non-zero error on
@@ -1580,17 +1580,15 @@ int omap_hwmod_for_each(int (*fn)(struct omap_hwmod *oh, void *data),
 	return ret;
 }
 
-
 /**
- * omap_hwmod_init - init omap_hwmod code and register hwmods
+ * omap_hwmod_register - register an array of hwmods
  * @ohs: pointer to an array of omap_hwmods to register
  *
  * Intended to be called early in boot before the clock framework is
  * initialized.  If @ohs is not null, will register all omap_hwmods
- * listed in @ohs that are valid for this chip.  Returns -EINVAL if
- * omap_hwmod_init() has already been called or 0 otherwise.
+ * listed in @ohs that are valid for this chip.  Returns 0.
  */
-int __init omap_hwmod_init(struct omap_hwmod **ohs)
+int __init omap_hwmod_register(struct omap_hwmod **ohs)
 {
 	int r, i;
 
@@ -1613,9 +1611,8 @@ int __init omap_hwmod_init(struct omap_hwmod **ohs)
 /*
  * _populate_mpu_rt_base - populate the virtual address for a hwmod
  *
- * Must be called only from omap_hwmod_late_init so ioremap works properly.
+ * Must be called only from omap_hwmod_setup_all() so ioremap works properly.
  * Assumes the caller takes care of locking if needed.
- *
  */
 static int __init _populate_mpu_rt_base(struct omap_hwmod *oh, void *data)
 {
@@ -1631,13 +1628,13 @@ static int __init _populate_mpu_rt_base(struct omap_hwmod *oh, void *data)
 }
 
 /**
- * omap_hwmod_late_init - do some post-clock framework initialization
+ * omap_hwmod_setup - do some post-clock framework initialization
  *
  * Must be called after omap2_clk_init().  Resolves the struct clk names
  * to struct clk pointers for each registered omap_hwmod.  Also calls
  * _setup() on each hwmod.  Returns 0.
  */
-static int __init omap_hwmod_late_init(void)
+static int __init omap_hwmod_setup_all(void)
 {
 	int r;
 
@@ -1645,7 +1642,7 @@ static int __init omap_hwmod_late_init(void)
 
 	/* XXX check return value */
 	r = omap_hwmod_for_each(_init_clocks, NULL);
-	WARN(r, "omap_hwmod: omap_hwmod_late_init(): _init_clocks failed\n");
+	WARN(r, "omap_hwmod: %s: _init_clocks failed\n", __func__);
 
 	mpu_oh = omap_hwmod_lookup(MPU_INITIATOR_NAME);
 	WARN(!mpu_oh, "omap_hwmod: could not find MPU initiator hwmod %s\n",
@@ -1655,7 +1652,7 @@ static int __init omap_hwmod_late_init(void)
 
 	return 0;
 }
-core_initcall(omap_hwmod_late_init);
+core_initcall(omap_hwmod_setup_all);
 
 /**
  * omap_hwmod_enable - enable an omap_hwmod
@@ -2174,11 +2171,11 @@ int omap_hwmod_for_each_by_class(const char *classname,
  * @oh: struct omap_hwmod *
  * @state: state that _setup() should leave the hwmod in
  *
- * Sets the hwmod state that @oh will enter at the end of _setup() (called by
- * omap_hwmod_late_init()).  Only valid to call between calls to
- * omap_hwmod_init() and omap_hwmod_late_init().  Returns 0 upon success or
- * -EINVAL if there is a problem with the arguments or if the hwmod is
- * in the wrong state.
+ * Sets the hwmod state that @oh will enter at the end of _setup()
+ * (called by omap_hwmod_setup_all()).  Only valid to call between
+ * calling omap_hwmod_register() and omap_hwmod_setup_all().  Returns
+ * 0 upon success or -EINVAL if there is a problem with the arguments
+ * or if the hwmod is in the wrong state.
  */
 int omap_hwmod_set_postsetup_state(struct omap_hwmod *oh, u8 state)
 {

commit bac1a0f0bbf0b11b23fe714826f29fc9aeb35855
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Feb 23 00:14:06 2011 -0700

    OMAP2+: hwmod: allow multiple calls to omap_hwmod_init()
    
    There's no longer any reason why we should prevent multiple
    calls to omap_hwmod_init().  It is now simply used to register an
    array of hwmods.
    
    This should allow a subset of hwmods (e.g., hwmods
    handling the system clocksource and clockevents) to be registered
    earlier than the remaining mass of hwmods.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 9e89a58711b7..2a7ab6adee82 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -162,9 +162,6 @@ static LIST_HEAD(omap_hwmod_list);
 /* mpu_oh: used to add/remove MPU initiator from sleepdep list */
 static struct omap_hwmod *mpu_oh;
 
-/* inited: 0 if omap_hwmod_init() has not yet been called; 1 otherwise */
-static u8 inited;
-
 
 /* Private functions */
 
@@ -1595,26 +1592,20 @@ int omap_hwmod_for_each(int (*fn)(struct omap_hwmod *oh, void *data),
  */
 int __init omap_hwmod_init(struct omap_hwmod **ohs)
 {
-	struct omap_hwmod *oh;
-	int r;
-
-	if (inited)
-		return -EINVAL;
-
-	inited = 1;
+	int r, i;
 
 	if (!ohs)
 		return 0;
 
-	oh = *ohs;
-	while (oh) {
-		if (omap_chip_is(oh->omap_chip)) {
-			r = _register(oh);
-			WARN(r, "omap_hwmod: %s: _register returned "
-			     "%d\n", oh->name, r);
-		}
-		oh = *++ohs;
-	}
+	i = 0;
+	do {
+		if (!omap_chip_is(ohs[i]->omap_chip))
+			continue;
+
+		r = _register(ohs[i]);
+		WARN(r, "omap_hwmod: %s: _register returned %d\n", ohs[i]->name,
+		     r);
+	} while (ohs[++i]);
 
 	return 0;
 }

commit cd5038024d6c92fbe4bf67af91eea5c6fb24a192
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Thu Feb 24 12:51:45 2011 -0800

    OMAP: hwmod: allow hwmod to provide address space accessible from SDMA
    
    Adds support for resource API to get address space info other than just MPU.
    The drivers can now use platform_get_resource_byname() to get resource of
    type 'IORESOURCE_MEM' by name.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 9e89a58711b7..c7762ab0dc8c 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1883,6 +1883,7 @@ int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 		os = oh->slaves[i];
 
 		for (j = 0; j < os->addr_cnt; j++) {
+			(res + r)->name = (os->addr + j)->name;
 			(res + r)->start = (os->addr + j)->pa_start;
 			(res + r)->end = (os->addr + j)->pa_end;
 			(res + r)->flags = IORESOURCE_MEM;

commit e7c7d760859e78a4f47e7be647df683491e420fb
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Feb 14 15:40:21 2011 -0800

    omap: hwmod: Populate _mpu_rt_va later on in omap_hwmod_late_init
    
    Otherwise ioremap can fail with early_init patch unless we have
    a static mapping for everything.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index eacdfd3a14d6..9e89a58711b7 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1467,12 +1467,10 @@ static int __init _register(struct omap_hwmod *oh)
 		return -EEXIST;
 
 	ms_id = _find_mpu_port_index(oh);
-	if (!IS_ERR_VALUE(ms_id)) {
+	if (!IS_ERR_VALUE(ms_id))
 		oh->_mpu_port_index = ms_id;
-		oh->_mpu_rt_va = _find_mpu_rt_base(oh, oh->_mpu_port_index);
-	} else {
+	else
 		oh->_int_flags |= _HWMOD_NO_MPU_PORT;
-	}
 
 	list_add_tail(&oh->node, &omap_hwmod_list);
 
@@ -1621,6 +1619,26 @@ int __init omap_hwmod_init(struct omap_hwmod **ohs)
 	return 0;
 }
 
+/*
+ * _populate_mpu_rt_base - populate the virtual address for a hwmod
+ *
+ * Must be called only from omap_hwmod_late_init so ioremap works properly.
+ * Assumes the caller takes care of locking if needed.
+ *
+ */
+static int __init _populate_mpu_rt_base(struct omap_hwmod *oh, void *data)
+{
+	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
+		return 0;
+
+	oh->_mpu_rt_va = _find_mpu_rt_base(oh, oh->_mpu_port_index);
+	if (!oh->_mpu_rt_va)
+		pr_warning("omap_hwmod: %s found no _mpu_rt_va for %s\n",
+				__func__, oh->name);
+
+	return 0;
+}
+
 /**
  * omap_hwmod_late_init - do some post-clock framework initialization
  *
@@ -1632,6 +1650,8 @@ static int __init omap_hwmod_late_init(void)
 {
 	int r;
 
+	r = omap_hwmod_for_each(_populate_mpu_rt_base, NULL);
+
 	/* XXX check return value */
 	r = omap_hwmod_for_each(_init_clocks, NULL);
 	WARN(r, "omap_hwmod: omap_hwmod_late_init(): _init_clocks failed\n");

commit 44dc046e93eb98d41048954f700b1927f7e288ed
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Feb 14 15:40:20 2011 -0800

    omap2+: Make omap_hwmod_late_init into core_initcall
    
    Otherwise things will fail with early_init changes.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index e282e35769fd..eacdfd3a14d6 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1628,7 +1628,7 @@ int __init omap_hwmod_init(struct omap_hwmod **ohs)
  * to struct clk pointers for each registered omap_hwmod.  Also calls
  * _setup() on each hwmod.  Returns 0.
  */
-int omap_hwmod_late_init(void)
+static int __init omap_hwmod_late_init(void)
 {
 	int r;
 
@@ -1644,6 +1644,7 @@ int omap_hwmod_late_init(void)
 
 	return 0;
 }
+core_initcall(omap_hwmod_late_init);
 
 /**
  * omap_hwmod_enable - enable an omap_hwmod

commit 8d9af88f55be89fa4c897ded3204ef12c947731e
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Dec 22 18:42:35 2010 -0800

    omap2+: Allow hwmod state changes to mux pads based on the state changes
    
    Allow hwmod state changes to mux pads based on the state changes.
    
    By default, only enable and disable the pads. In some rare cases
    dynamic remuxing for the idles states is needed, this can be done
    by passing the enable, idle, and off pads from board-*.c file along
    with OMAP_DEVICE_PAD_REMUX flag.
    
    Thanks to Paul Walmsley <paul@booyaka.com> for the comments on the
    hwmod related changes.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 77a8be64cfae..e282e35769fd 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -116,7 +116,6 @@
  * - Open Core Protocol Specification 2.2
  *
  * To do:
- * - pin mux handling
  * - handle IO mapping
  * - bus throughput & module latency measurement code
  *
@@ -149,6 +148,7 @@
 #include "cm44xx.h"
 #include "prm2xxx_3xxx.h"
 #include "prm44xx.h"
+#include "mux.h"
 
 /* Maximum microseconds to wait for OMAP module to softreset */
 #define MAX_MODULE_SOFTRESET_WAIT	10000
@@ -1229,7 +1229,9 @@ static int _enable(struct omap_hwmod *oh)
 	     oh->_state == _HWMOD_STATE_DISABLED) && oh->rst_lines_cnt == 1)
 		_deassert_hardreset(oh, oh->rst_lines[0].name);
 
-	/* XXX mux balls */
+	/* Mux pins for device runtime if populated */
+	if (oh->mux)
+		omap_hwmod_mux(oh->mux, _HWMOD_STATE_ENABLED);
 
 	_add_initiator_dep(oh, mpu_oh);
 	_enable_clocks(oh);
@@ -1276,6 +1278,10 @@ static int _idle(struct omap_hwmod *oh)
 	_del_initiator_dep(oh, mpu_oh);
 	_disable_clocks(oh);
 
+	/* Mux pins for device idle if populated */
+	if (oh->mux)
+		omap_hwmod_mux(oh->mux, _HWMOD_STATE_IDLE);
+
 	oh->_state = _HWMOD_STATE_IDLE;
 
 	return 0;
@@ -1334,7 +1340,9 @@ static int _shutdown(struct omap_hwmod *oh)
 	}
 	/* XXX Should this code also force-disable the optional clocks? */
 
-	/* XXX mux any associated balls to safe mode */
+	/* Mux pins to safe mode or use populated off mode values */
+	if (oh->mux)
+		omap_hwmod_mux(oh->mux, _HWMOD_STATE_DISABLED);
 
 	oh->_state = _HWMOD_STATE_DISABLED;
 

commit c80705aa7074045e7431ed2ebeb0f7d5773615ab
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Tue Dec 21 21:31:55 2010 -0700

    OMAP: PM: implement context loss count APIs
    
    Implement OMAP PM layer omap_pm_get_dev_context_loss_count() API by
    creating similar APIs at the omap_device and omap_hwmod levels.  The
    omap_hwmod level call is the layer with access to the powerdomain
    core, so it is the place where the powerdomain is queried to get the
    context loss count.
    
    The new APIs return an unsigned value that can wrap as the
    context-loss count grows.  However, the wrapping is not important as
    the role of this function is to determine context loss by checking for
    any difference in subsequent calls to this function.
    
    Note that these APIs at each level can return zero when no context
    loss is detected, or on errors.  This is to avoid returning error
    codes which could potentially be mistaken for large context loss
    counters.
    
    NOTE: only works for devices which have been converted to use
          omap_device/omap_hwmod.
    
    Longer term, we could possibly remove this API from the OMAP PM layer,
    and instead directly use the omap_device level API.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 03ffa3b282b1..77a8be64cfae 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2188,3 +2188,25 @@ int omap_hwmod_set_postsetup_state(struct omap_hwmod *oh, u8 state)
 
 	return ret;
 }
+
+/**
+ * omap_hwmod_get_context_loss_count - get lost context count
+ * @oh: struct omap_hwmod *
+ *
+ * Query the powerdomain of of @oh to get the context loss
+ * count for this device.
+ *
+ * Returns the context loss count of the powerdomain assocated with @oh
+ * upon success, or zero if no powerdomain exists for @oh.
+ */
+u32 omap_hwmod_get_context_loss_count(struct omap_hwmod *oh)
+{
+	struct powerdomain *pwrdm;
+	int ret = 0;
+
+	pwrdm = omap_hwmod_get_pwrdm(oh);
+	if (pwrdm)
+		ret = pwrdm_get_context_loss_count(pwrdm);
+
+	return ret;
+}

commit 86009eb326afde34ffdc5648cd344aa86b8d58d4
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Tue Dec 21 21:31:28 2010 -0700

    OMAP2+: hwmod: Add wakeup support for new OMAP4 IPs
    
    The new OMAP4 IPs introduced a new idle mode named smart-idle with wakeup.
    
    This new idlemode replaces the enawakeup for the new IPs but seems to
    coexist as well for some legacy IPs (UART, GPIO, MCSPI...)
    
    Add the new SIDLE_SMART_WKUP flag to mark the IPs that support this
    capability.
    The omap_hwmod_44xx_data.c will have to be updated to add this new flag.
    
    Enable this new mode when applicable in _enable_wakeup, _enable_sysc and
    _idle_sysc.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Tested-by: Sebastien Guiriec <s-guiriec@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Rajendra Nayak <rnayak@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index c576121b58a9..03ffa3b282b1 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -393,7 +393,8 @@ static int _enable_wakeup(struct omap_hwmod *oh, u32 *v)
 	u32 wakeup_mask;
 
 	if (!oh->class->sysc ||
-	    !(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP))
+	    !((oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP) ||
+	      (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP)))
 		return -EINVAL;
 
 	if (!oh->class->sysc->sysc_fields) {
@@ -405,6 +406,9 @@ static int _enable_wakeup(struct omap_hwmod *oh, u32 *v)
 
 	*v |= wakeup_mask;
 
+	if (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP)
+		_set_slave_idlemode(oh, HWMOD_IDLEMODE_SMART_WKUP, v);
+
 	/* XXX test pwrdm_get_wken for this hwmod's subsystem */
 
 	oh->_int_flags |= _HWMOD_WAKEUP_ENABLED;
@@ -424,7 +428,8 @@ static int _disable_wakeup(struct omap_hwmod *oh, u32 *v)
 	u32 wakeup_mask;
 
 	if (!oh->class->sysc ||
-	    !(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP))
+	    !((oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP) ||
+	      (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP)))
 		return -EINVAL;
 
 	if (!oh->class->sysc->sysc_fields) {
@@ -436,6 +441,9 @@ static int _disable_wakeup(struct omap_hwmod *oh, u32 *v)
 
 	*v &= ~wakeup_mask;
 
+	if (oh->class->sysc->idlemodes & SIDLE_SMART_WKUP)
+		_set_slave_idlemode(oh, HWMOD_IDLEMODE_SMART, v);
+
 	/* XXX test pwrdm_get_wken for this hwmod's subsystem */
 
 	oh->_int_flags &= ~_HWMOD_WAKEUP_ENABLED;
@@ -832,6 +840,10 @@ static void _idle_sysc(struct omap_hwmod *oh)
 		_set_master_standbymode(oh, idlemode, &v);
 	}
 
+	/* If slave is in SMARTIDLE, also enable wakeup */
+	if ((sf & SYSC_HAS_SIDLEMODE) && !(oh->flags & HWMOD_SWSUP_SIDLE))
+		_enable_wakeup(oh, &v);
+
 	_write_sysconfig(v, oh);
 }
 

commit f2dd7e09db3e18e4c053810b72fe026685d9bf0c
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Tue Dec 21 21:31:28 2010 -0700

    OMAP2+: hwmod: Disable clocks when hwmod enable fails
    
    In cases where a module (hwmod) does not become accesible on enabling
    the main clocks (can happen if there are external clocks needed
    for the module to become accesible), make sure the clocks are not
    left enabled.
    This ensures that when the requisite external dependencies are met
    a omap_hwmod_enable and omap_hwmod_idle/shutdown would rightly enable
    and disable clocks using clk framework. Leaving the clocks enabled in
    the error case causes additional usecounting at the clock framework
    level leaving the clock enabled forever.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 91b011e3a7cb..c576121b58a9 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1233,6 +1233,7 @@ static int _enable(struct omap_hwmod *oh)
 			_enable_sysc(oh);
 		}
 	} else {
+		_disable_clocks(oh);
 		pr_debug("omap_hwmod: %s: _wait_target_ready: %d\n",
 			 oh->name, r);
 	}

commit ce35b2446945c506cb02960eab2072f56efdf1c0
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Tue Dec 21 21:31:28 2010 -0700

    OMAP2+: hwmod: Remove omap_hwmod_mutex
    
    The hwmod list will be built are init time and never
    be modified at runtime. There is no need anymore to protect
    the list from concurrent accesses using a mutex.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 1a0dd5647cf6..91b011e3a7cb 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -159,8 +159,6 @@
 /* omap_hwmod_list contains all registered struct omap_hwmods */
 static LIST_HEAD(omap_hwmod_list);
 
-static DEFINE_MUTEX(omap_hwmod_mutex);
-
 /* mpu_oh: used to add/remove MPU initiator from sleepdep list */
 static struct omap_hwmod *mpu_oh;
 
@@ -872,7 +870,6 @@ static void _shutdown_sysc(struct omap_hwmod *oh)
  * @name: find an omap_hwmod by name
  *
  * Return a pointer to an omap_hwmod by name, or NULL if not found.
- * Caller must hold omap_hwmod_mutex.
  */
 static struct omap_hwmod *_lookup(const char *name)
 {
@@ -1443,14 +1440,10 @@ static int __init _register(struct omap_hwmod *oh)
 	    (oh->_state != _HWMOD_STATE_UNKNOWN))
 		return -EINVAL;
 
-	mutex_lock(&omap_hwmod_mutex);
-
 	pr_debug("omap_hwmod: %s: registering\n", oh->name);
 
-	if (_lookup(oh->name)) {
-		ret = -EEXIST;
-		goto ohr_unlock;
-	}
+	if (_lookup(oh->name))
+		return -EEXIST;
 
 	ms_id = _find_mpu_port_index(oh);
 	if (!IS_ERR_VALUE(ms_id)) {
@@ -1468,8 +1461,6 @@ static int __init _register(struct omap_hwmod *oh)
 
 	ret = 0;
 
-ohr_unlock:
-	mutex_unlock(&omap_hwmod_mutex);
 	return ret;
 }
 
@@ -1538,9 +1529,7 @@ struct omap_hwmod *omap_hwmod_lookup(const char *name)
 	if (!name)
 		return NULL;
 
-	mutex_lock(&omap_hwmod_mutex);
 	oh = _lookup(name);
-	mutex_unlock(&omap_hwmod_mutex);
 
 	return oh;
 }
@@ -1566,13 +1555,11 @@ int omap_hwmod_for_each(int (*fn)(struct omap_hwmod *oh, void *data),
 	if (!fn)
 		return -EINVAL;
 
-	mutex_lock(&omap_hwmod_mutex);
 	list_for_each_entry(temp_oh, &omap_hwmod_list, node) {
 		ret = (*fn)(temp_oh, data);
 		if (ret)
 			break;
 	}
-	mutex_unlock(&omap_hwmod_mutex);
 
 	return ret;
 }
@@ -2112,9 +2099,8 @@ int omap_hwmod_read_hardreset(struct omap_hwmod *oh, const char *name)
  * @fn: callback function pointer to call for each hwmod in class @classname
  * @user: arbitrary context data to pass to the callback function
  *
- * For each omap_hwmod of class @classname, call @fn.  Takes
- * omap_hwmod_mutex to prevent the hwmod list from changing during the
- * iteration.  If the callback function returns something other than
+ * For each omap_hwmod of class @classname, call @fn.
+ * If the callback function returns something other than
  * zero, the iterator is terminated, and the callback function's return
  * value is passed back to the caller.  Returns 0 upon success, -EINVAL
  * if @classname or @fn are NULL, or passes back the error code from @fn.
@@ -2133,8 +2119,6 @@ int omap_hwmod_for_each_by_class(const char *classname,
 	pr_debug("omap_hwmod: %s: looking for modules of class %s\n",
 		 __func__, classname);
 
-	mutex_lock(&omap_hwmod_mutex);
-
 	list_for_each_entry(temp_oh, &omap_hwmod_list, node) {
 		if (!strcmp(temp_oh->class->name, classname)) {
 			pr_debug("omap_hwmod: %s: %s: calling callback fn\n",
@@ -2145,8 +2129,6 @@ int omap_hwmod_for_each_by_class(const char *classname,
 		}
 	}
 
-	mutex_unlock(&omap_hwmod_mutex);
-
 	if (ret)
 		pr_debug("omap_hwmod: %s: iterator terminated early: %d\n",
 			 __func__, ret);

commit 01592df95049a6f3d4abb0571ae1c7cb6e9d1cd7
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Tue Dec 21 21:31:28 2010 -0700

    OMAP2+: hwmod: Mark functions used only during initialization with __init
    
    _register, _find_mpu_port_index and _find_mpu_rt_base are static APIs
    that will be used only during the omap_hwmod initialization phase.
    There is no need to keep them for runtime.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 298fc3b779ec..1a0dd5647cf6 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -673,7 +673,7 @@ static void _disable_optional_clocks(struct omap_hwmod *oh)
  * Returns the array index of the OCP slave port that the MPU
  * addresses the device on, or -EINVAL upon error or not found.
  */
-static int _find_mpu_port_index(struct omap_hwmod *oh)
+static int __init _find_mpu_port_index(struct omap_hwmod *oh)
 {
 	int i;
 	int found = 0;
@@ -707,7 +707,7 @@ static int _find_mpu_port_index(struct omap_hwmod *oh)
  * Return the virtual address of the base of the register target of
  * device @oh, or NULL on error.
  */
-static void __iomem *_find_mpu_rt_base(struct omap_hwmod *oh, u8 index)
+static void __iomem * __init _find_mpu_rt_base(struct omap_hwmod *oh, u8 index)
 {
 	struct omap_hwmod_ocp_if *os;
 	struct omap_hwmod_addr_space *mem;
@@ -1435,7 +1435,7 @@ static int _setup(struct omap_hwmod *oh, void *data)
  * that the copy process would be relatively complex due to the large number
  * of substructures.
  */
-static int _register(struct omap_hwmod *oh)
+static int __init _register(struct omap_hwmod *oh)
 {
 	int ret, ms_id;
 
@@ -1587,7 +1587,7 @@ int omap_hwmod_for_each(int (*fn)(struct omap_hwmod *oh, void *data),
  * listed in @ohs that are valid for this chip.  Returns -EINVAL if
  * omap_hwmod_init() has already been called or 0 otherwise.
  */
-int omap_hwmod_init(struct omap_hwmod **ohs)
+int __init omap_hwmod_init(struct omap_hwmod **ohs)
 {
 	struct omap_hwmod *oh;
 	int r;

commit 0102b62789af5aed92cea4cf7f36afaa1ab12c72
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Tue Dec 21 21:31:27 2010 -0700

    OMAP2+: hwmod: Make omap_hwmod_register private and remove omap_hwmod_unregister
    
    Do not allow omap_hwmod_register to be used outside the core
    hwmod code. An omap_hwmod should be registered only at init time.
    Remove the omap_hwmod_unregister that is not used today since the
    hwmod list will be built once at init time and never be modified
    at runtime.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 81c109774b31..298fc3b779ec 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1418,60 +1418,8 @@ static int _setup(struct omap_hwmod *oh, void *data)
 	return 0;
 }
 
-
-
-/* Public functions */
-
-u32 omap_hwmod_read(struct omap_hwmod *oh, u16 reg_offs)
-{
-	if (oh->flags & HWMOD_16BIT_REG)
-		return __raw_readw(oh->_mpu_rt_va + reg_offs);
-	else
-		return __raw_readl(oh->_mpu_rt_va + reg_offs);
-}
-
-void omap_hwmod_write(u32 v, struct omap_hwmod *oh, u16 reg_offs)
-{
-	if (oh->flags & HWMOD_16BIT_REG)
-		__raw_writew(v, oh->_mpu_rt_va + reg_offs);
-	else
-		__raw_writel(v, oh->_mpu_rt_va + reg_offs);
-}
-
-/**
- * omap_hwmod_set_slave_idlemode - set the hwmod's OCP slave idlemode
- * @oh: struct omap_hwmod *
- * @idlemode: SIDLEMODE field bits (shifted to bit 0)
- *
- * Sets the IP block's OCP slave idlemode in hardware, and updates our
- * local copy.  Intended to be used by drivers that have some erratum
- * that requires direct manipulation of the SIDLEMODE bits.  Returns
- * -EINVAL if @oh is null, or passes along the return value from
- * _set_slave_idlemode().
- *
- * XXX Does this function have any current users?  If not, we should
- * remove it; it is better to let the rest of the hwmod code handle this.
- * Any users of this function should be scrutinized carefully.
- */
-int omap_hwmod_set_slave_idlemode(struct omap_hwmod *oh, u8 idlemode)
-{
-	u32 v;
-	int retval = 0;
-
-	if (!oh)
-		return -EINVAL;
-
-	v = oh->_sysc_cache;
-
-	retval = _set_slave_idlemode(oh, idlemode, &v);
-	if (!retval)
-		_write_sysconfig(v, oh);
-
-	return retval;
-}
-
 /**
- * omap_hwmod_register - register a struct omap_hwmod
+ * _register - register a struct omap_hwmod
  * @oh: struct omap_hwmod *
  *
  * Registers the omap_hwmod @oh.  Returns -EEXIST if an omap_hwmod
@@ -1487,7 +1435,7 @@ int omap_hwmod_set_slave_idlemode(struct omap_hwmod *oh, u8 idlemode)
  * that the copy process would be relatively complex due to the large number
  * of substructures.
  */
-int omap_hwmod_register(struct omap_hwmod *oh)
+static int _register(struct omap_hwmod *oh)
 {
 	int ret, ms_id;
 
@@ -1525,6 +1473,57 @@ int omap_hwmod_register(struct omap_hwmod *oh)
 	return ret;
 }
 
+
+/* Public functions */
+
+u32 omap_hwmod_read(struct omap_hwmod *oh, u16 reg_offs)
+{
+	if (oh->flags & HWMOD_16BIT_REG)
+		return __raw_readw(oh->_mpu_rt_va + reg_offs);
+	else
+		return __raw_readl(oh->_mpu_rt_va + reg_offs);
+}
+
+void omap_hwmod_write(u32 v, struct omap_hwmod *oh, u16 reg_offs)
+{
+	if (oh->flags & HWMOD_16BIT_REG)
+		__raw_writew(v, oh->_mpu_rt_va + reg_offs);
+	else
+		__raw_writel(v, oh->_mpu_rt_va + reg_offs);
+}
+
+/**
+ * omap_hwmod_set_slave_idlemode - set the hwmod's OCP slave idlemode
+ * @oh: struct omap_hwmod *
+ * @idlemode: SIDLEMODE field bits (shifted to bit 0)
+ *
+ * Sets the IP block's OCP slave idlemode in hardware, and updates our
+ * local copy.  Intended to be used by drivers that have some erratum
+ * that requires direct manipulation of the SIDLEMODE bits.  Returns
+ * -EINVAL if @oh is null, or passes along the return value from
+ * _set_slave_idlemode().
+ *
+ * XXX Does this function have any current users?  If not, we should
+ * remove it; it is better to let the rest of the hwmod code handle this.
+ * Any users of this function should be scrutinized carefully.
+ */
+int omap_hwmod_set_slave_idlemode(struct omap_hwmod *oh, u8 idlemode)
+{
+	u32 v;
+	int retval = 0;
+
+	if (!oh)
+		return -EINVAL;
+
+	v = oh->_sysc_cache;
+
+	retval = _set_slave_idlemode(oh, idlemode, &v);
+	if (!retval)
+		_write_sysconfig(v, oh);
+
+	return retval;
+}
+
 /**
  * omap_hwmod_lookup - look up a registered omap_hwmod by name
  * @name: name of the omap_hwmod to look up
@@ -1604,8 +1603,8 @@ int omap_hwmod_init(struct omap_hwmod **ohs)
 	oh = *ohs;
 	while (oh) {
 		if (omap_chip_is(oh->omap_chip)) {
-			r = omap_hwmod_register(oh);
-			WARN(r, "omap_hwmod: %s: omap_hwmod_register returned "
+			r = _register(oh);
+			WARN(r, "omap_hwmod: %s: _register returned "
 			     "%d\n", oh->name, r);
 		}
 		oh = *++ohs;
@@ -1638,32 +1637,6 @@ int omap_hwmod_late_init(void)
 	return 0;
 }
 
-/**
- * omap_hwmod_unregister - unregister an omap_hwmod
- * @oh: struct omap_hwmod *
- *
- * Unregisters a previously-registered omap_hwmod @oh.  There's probably
- * no use case for this, so it is likely to be removed in a later version.
- *
- * XXX Free all of the bootmem-allocated structures here when that is
- * implemented.  Make it clear that core code is the only code that is
- * expected to unregister modules.
- */
-int omap_hwmod_unregister(struct omap_hwmod *oh)
-{
-	if (!oh)
-		return -EINVAL;
-
-	pr_debug("omap_hwmod: %s: unregistering\n", oh->name);
-
-	mutex_lock(&omap_hwmod_mutex);
-	iounmap(oh->_mpu_rt_va);
-	list_del(&oh->node);
-	mutex_unlock(&omap_hwmod_mutex);
-
-	return 0;
-}
-
 /**
  * omap_hwmod_enable - enable an omap_hwmod
  * @oh: struct omap_hwmod *

commit 5a7ddcbdaf1bb7603422fb6188156ccc39711b0f
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Tue Dec 21 21:08:34 2010 -0700

    OMAP2+: omap_hwmod: fix wakeup enable/disable for consistency
    
    In the omap_hwmod core, most of the SYSCONFIG register helper
    functions do not directly write the register, but instead just modify
    a value passed in.
    
    This patch converts the _enable_wakeup() and _disable_wakeup() helper
    functions to take a value argument and only modify it instead of
    actually writing the register.  This makes the wakeup helpers
    consistent with the other helper functions and avoids unintentional
    problems like the following.
    
    This problem was found after discovering that GPIO wakeups were no
    longer functional.  The root cause was that the ENAWAKEUP bit of the
    SYSCONFIG register was being unintentionaly overwritten, leaving
    wakeups disabled after the following two commits were combined:
    
    commit: 9980ce53c97392a3dbdc9d1ac3e455d79b4167ed
            OMAP: hwmod: Enable module wakeup if in smartidle
    
    commit: 78f26e872f77b6312273216de1a8f836c6f2e143
            OMAP: hwmod: Set autoidle after smartidle during _sysc_enable
    
    There resulting in code in _enable_sysc() was this:
    
            /*
             * XXX The clock framework should handle this, by
             * calling into this code.  But this must wait until the
             * clock structures are tagged with omap_hwmod entries
             */
            if ((oh->flags & HWMOD_SET_DEFAULT_CLOCKACT) &&
                (sf & SYSC_HAS_CLOCKACTIVITY))
                    _set_clockactivity(oh, oh->class->sysc->clockact, &v);
    
            _write_sysconfig(v, oh);
    
    so here, 'v' has wakeups disabled.
    
            /* If slave is in SMARTIDLE, also enable wakeup */
            if ((sf & SYSC_HAS_SIDLEMODE) && !(oh->flags & HWMOD_SWSUP_SIDLE))
                    _enable_wakeup(oh);
    
    Here wakeup is enabled in the SYSCONFIG register (but 'v' is not updated)
    
            /*
             * Set the autoidle bit only after setting the smartidle bit
             * Setting this will not have any impact on the other modules.
             */
            if (sf & SYSC_HAS_AUTOIDLE) {
                    idlemode = (oh->flags & HWMOD_NO_OCP_AUTOIDLE) ?
                            0 : 1;
                    _set_module_autoidle(oh, idlemode, &v);
                    _write_sysconfig(v, oh);
            }
    
    And here, SYSCONFIG is updated again using 'v', which does not have
    wakeups enabled, resulting in ENAWAKEUP being cleared.
    
    Special thanks to Benoit Cousson for pointing out that wakeups were
    supposed to be automatically enabled when a hwmod is enabled, and thus
    helping target the root cause of this problem.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 12856eb7b179..81c109774b31 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -390,9 +390,9 @@ static int _set_module_autoidle(struct omap_hwmod *oh, u8 autoidle,
  * Allow the hardware module @oh to send wakeups.  Returns -EINVAL
  * upon error or 0 upon success.
  */
-static int _enable_wakeup(struct omap_hwmod *oh)
+static int _enable_wakeup(struct omap_hwmod *oh, u32 *v)
 {
-	u32 v, wakeup_mask;
+	u32 wakeup_mask;
 
 	if (!oh->class->sysc ||
 	    !(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP))
@@ -405,9 +405,7 @@ static int _enable_wakeup(struct omap_hwmod *oh)
 
 	wakeup_mask = (0x1 << oh->class->sysc->sysc_fields->enwkup_shift);
 
-	v = oh->_sysc_cache;
-	v |= wakeup_mask;
-	_write_sysconfig(v, oh);
+	*v |= wakeup_mask;
 
 	/* XXX test pwrdm_get_wken for this hwmod's subsystem */
 
@@ -423,9 +421,9 @@ static int _enable_wakeup(struct omap_hwmod *oh)
  * Prevent the hardware module @oh to send wakeups.  Returns -EINVAL
  * upon error or 0 upon success.
  */
-static int _disable_wakeup(struct omap_hwmod *oh)
+static int _disable_wakeup(struct omap_hwmod *oh, u32 *v)
 {
-	u32 v, wakeup_mask;
+	u32 wakeup_mask;
 
 	if (!oh->class->sysc ||
 	    !(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP))
@@ -438,9 +436,7 @@ static int _disable_wakeup(struct omap_hwmod *oh)
 
 	wakeup_mask = (0x1 << oh->class->sysc->sysc_fields->enwkup_shift);
 
-	v = oh->_sysc_cache;
-	v &= ~wakeup_mask;
-	_write_sysconfig(v, oh);
+	*v &= ~wakeup_mask;
 
 	/* XXX test pwrdm_get_wken for this hwmod's subsystem */
 
@@ -788,11 +784,11 @@ static void _enable_sysc(struct omap_hwmod *oh)
 	    (sf & SYSC_HAS_CLOCKACTIVITY))
 		_set_clockactivity(oh, oh->class->sysc->clockact, &v);
 
-	_write_sysconfig(v, oh);
-
 	/* If slave is in SMARTIDLE, also enable wakeup */
 	if ((sf & SYSC_HAS_SIDLEMODE) && !(oh->flags & HWMOD_SWSUP_SIDLE))
-		_enable_wakeup(oh);
+		_enable_wakeup(oh, &v);
+
+	_write_sysconfig(v, oh);
 
 	/*
 	 * Set the autoidle bit only after setting the smartidle bit
@@ -2011,13 +2007,16 @@ int omap_hwmod_del_initiator_dep(struct omap_hwmod *oh,
 int omap_hwmod_enable_wakeup(struct omap_hwmod *oh)
 {
 	unsigned long flags;
+	u32 v;
 
 	if (!oh->class->sysc ||
 	    !(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP))
 		return -EINVAL;
 
 	spin_lock_irqsave(&oh->_lock, flags);
-	_enable_wakeup(oh);
+	v = oh->_sysc_cache;
+	_enable_wakeup(oh, &v);
+	_write_sysconfig(v, oh);
 	spin_unlock_irqrestore(&oh->_lock, flags);
 
 	return 0;
@@ -2038,13 +2037,16 @@ int omap_hwmod_enable_wakeup(struct omap_hwmod *oh)
 int omap_hwmod_disable_wakeup(struct omap_hwmod *oh)
 {
 	unsigned long flags;
+	u32 v;
 
 	if (!oh->class->sysc ||
 	    !(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP))
 		return -EINVAL;
 
 	spin_lock_irqsave(&oh->_lock, flags);
-	_disable_wakeup(oh);
+	v = oh->_sysc_cache;
+	_disable_wakeup(oh, &v);
+	_write_sysconfig(v, oh);
 	spin_unlock_irqrestore(&oh->_lock, flags);
 
 	return 0;

commit 72e06d087204f3bc9acf281717b90ebf0b9731f7
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 21 21:05:16 2010 -0700

    OMAP2+: powerdomain: move header file from plat-omap to mach-omap2
    
    The OMAP powerdomain code and data is all OMAP2+-specific.  This seems
    unlikely to change any time soon.  Move plat-omap/include/plat/powerdomain.h
    to mach-omap2/powerdomain.h.  The primary point of doing this is to remove
    the temptation for unrelated upper-layer code to access powerdomain code
    and data directly.
    
    As part of this process, remove the references to powerdomain data
    from the GPIO "driver" and the OMAP PM no-op layer, both in plat-omap.
    Change the DSPBridge code to point to the new location for the
    powerdomain headers.  The DSPBridge code should not be including the
    powerdomain headers; these should be removed.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Omar Ramirez Luna <omar.ramirez@ti.com>
    Cc: Felipe Contreras <felipe.contreras@gmail.com>
    Cc: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index e1358ba51395..12856eb7b179 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -140,7 +140,7 @@
 #include <plat/common.h>
 #include <plat/cpu.h>
 #include "clockdomain.h"
-#include <plat/powerdomain.h>
+#include "powerdomain.h"
 #include <plat/clock.h>
 #include <plat/omap_hwmod.h>
 #include <plat/prcm.h>

commit 1540f214065982e6cbc6b8da1fe65a15e358f7c5
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 21 21:05:15 2010 -0700

    OMAP2+: clockdomain: move header file from plat-omap to mach-omap2
    
    The OMAP clockdomain code and data is all OMAP2+-specific.  This seems
    unlikely to change any time soon.  Move plat-omap/include/plat/clockdomain.h
    to mach-omap2/clockdomain.h.  The primary point of doing this is to remove
    the temptation for unrelated upper-layer code to access clockdomain code
    and data directly.
    
    DSPBridge also uses the clockdomain headers for some reason, so,
    modify it also. The DSPBridge code should not be including the
    clockdomain headers; these should be removed.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Omar Ramirez Luna <omar.ramirez@ti.com>
    Cc: Felipe Contreras <felipe.contreras@gmail.com>
    Cc: Greg Kroah-Hartman <greg@kroah.com>
    Tested-by: Rajendra Nayak <rnayak@ti.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 1312ce2913a5..e1358ba51395 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -139,7 +139,7 @@
 
 #include <plat/common.h>
 #include <plat/cpu.h>
-#include <plat/clockdomain.h>
+#include "clockdomain.h"
 #include <plat/powerdomain.h>
 #include <plat/clock.h>
 #include <plat/omap_hwmod.h>

commit 59fb659b065f52fcc2deed293cfbfc58f890376c
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 21 15:30:55 2010 -0700

    OMAP2/3: PRCM: split OMAP2/3-specific PRCM code into OMAP2/3-specific files
    
    In preparation for adding OMAP4-specific PRCM accessor/mutator
    functions, split the existing OMAP2/3 PRCM code into OMAP2/3-specific
    files.  Most of what was in mach-omap2/{cm,prm}.{c,h} has now been
    moved into mach-omap2/{cm,prm}2xxx_3xxx.{c,h}, since it was
    OMAP2xxx/3xxx-specific.
    
    This process also requires the #includes in each of these files to be
    changed to reference the new file name.  As part of doing so, add some
    comments into plat-omap/sram.c and plat-omap/mcbsp.c, which use
    "sideways includes", to indicate that these users of the PRM/CM includes
    should not be doing so.
    
    Thanks to Felipe Contreras <felipe.contreras@gmail.com> for comments on this
    patch.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Jarkko Nikula <jhnikula@gmail.com>
    Cc: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Cc: Liam Girdwood <lrg@slimlogic.co.uk>
    Cc: Omar Ramirez Luna <omar.ramirez@ti.com>
    Acked-by: Omar Ramirez Luna <omar.ramirez@ti.com>
    Cc: Felipe Contreras <felipe.contreras@gmail.com>
    Acked-by: Felipe Contreras <felipe.contreras@gmail.com>
    Cc: Greg Kroah-Hartman <greg@kroah.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Kevin Hilman <khilman@deeprootsystems.com>
    Tested-by: Kevin Hilman <khilman@deeprootsystems.com>
    Tested-by: Rajendra Nayak <rnayak@ti.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 2b660e57a302..1312ce2913a5 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -145,8 +145,9 @@
 #include <plat/omap_hwmod.h>
 #include <plat/prcm.h>
 
-#include "cm.h"
-#include "prm.h"
+#include "cm2xxx_3xxx.h"
+#include "cm44xx.h"
+#include "prm2xxx_3xxx.h"
 #include "prm44xx.h"
 
 /* Maximum microseconds to wait for OMAP module to softreset */

commit d198b514bd9e94930ee0b9ca1cad0a51f5e29608
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 21 15:30:54 2010 -0700

    OMAP4: PRCM: reorganize existing OMAP4 PRCM header files
    
    Split the existing cm44xx.h file into cm1_44xx.h and cm2_44xx.h files
    so they match their underlying OMAP hardware modules.  Add clockdomain
    offset information.
    
    Add header files for the MPU local PRCM, prcm_mpu44xx.h, and for the
    SCRM, scrm44xx.h.  SCRM register offsets still need to be added; TI
    should do this.
    
    Move the "_MOD" macros out of the prcm-common.h header file, into the
    header file of the hardware module that they belong to.  For example,
    OMAP4430_PRM_*_MOD macros have been moved into the prm44xx.h header.
    
    Adjust #includes of all files that used the old PRCM header file names
    to point to the new filenames.
    
    The autogeneration scripts have been updated accordingly.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Reviewed-by: Kevin Hilman <khilman@deeprootsystems.com>
    Tested-by: Kevin Hilman <khilman@deeprootsystems.com>
    Tested-by: Rajendra Nayak <rnayak@ti.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index a039b37b8e0c..2b660e57a302 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -147,6 +147,7 @@
 
 #include "cm.h"
 #include "prm.h"
+#include "prm44xx.h"
 
 /* Maximum microseconds to wait for OMAP module to softreset */
 #define MAX_MODULE_SOFTRESET_WAIT	10000

commit 233cbe5b94096f95ba7bca2162d63275b0b90b5b
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Tue Dec 14 12:42:36 2010 -0700

    OMAP2+: hwmod: Update the sysc_cache in case module context is lost
    
    Do not skip the sysc programming in the hmwod framework based
    on the cached value alone, since at times the module might have lost
    context (due to the Powerdomain in which the module belongs
    transitions to either Open Switch RET or OFF).
    
    Identifying if a module has lost context requires atleast one
    register read, and since a register read has more latency than
    a write, it makes sense to do a blind write always.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Acked-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 31990e92c573..a039b37b8e0c 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -210,10 +210,9 @@ static void _write_sysconfig(u32 v, struct omap_hwmod *oh)
 
 	/* XXX ensure module interface clock is up */
 
-	if (oh->_sysc_cache != v) {
-		oh->_sysc_cache = v;
-		omap_hwmod_write(v, oh, oh->class->sysc->sysc_offs);
-	}
+	/* Module might have lost context, always update cache and register */
+	oh->_sysc_cache = v;
+	omap_hwmod_write(v, oh, oh->class->sysc->sysc_offs);
 }
 
 /**

commit dc6d1cda044b24c3d9f8e4af0431887ebe3488ef
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 14 12:42:35 2010 -0700

    OMAP2+: hwmod: upgrade per-hwmod mutex to a spinlock
    
    Change the per-hwmod mutex to a spinlock.  (The per-hwmod lock
    serializes most post-initialization hwmod operations such as enable,
    idle, and shutdown.)  Spinlocks are needed, because in some cases,
    hwmods must be enabled from timer interrupt disabled-context, such as
    an ISR.  The current use-case that is driving this is the OMAP GPIO
    block ISR: it can trigger interrupts even with its clocks disabled,
    but these clocks are needed for register accesses in the ISR to succeed.
    
    This patch also effectively reverts commit
    848240223c35fcc71c424ad51a8e8aef42d3879c - this patch makes
    _omap_hwmod_enable() and _omap_hwmod_init() static, renames them back
    to _enable() and _idle(), and changes their callers to call the
    spinlocking versions.  Previously, since omap_hwmod_{enable,init}()
    attempted to take mutexes, these functions could not be called while
    the timer interrupt was disabled; but now that the functions use
    spinlocks and save and restore the IRQ state, it is appropriate to
    call them directly.
    
    Kevin Hilman <khilman@deeprootsystems.com> originally proposed this
    patch - thanks Kevin.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 12a0b9a30a30..31990e92c573 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -135,6 +135,7 @@
 #include <linux/err.h>
 #include <linux/list.h>
 #include <linux/mutex.h>
+#include <linux/spinlock.h>
 
 #include <plat/common.h>
 #include <plat/cpu.h>
@@ -1192,17 +1193,14 @@ static int _reset(struct omap_hwmod *oh)
 }
 
 /**
- * _omap_hwmod_enable - enable an omap_hwmod
+ * _enable - enable an omap_hwmod
  * @oh: struct omap_hwmod *
  *
  * Enables an omap_hwmod @oh such that the MPU can access the hwmod's
- * register target.  (This function has a full name --
- * _omap_hwmod_enable() rather than simply _enable() -- because it is
- * currently required by the pm34xx.c idle loop.)  Returns -EINVAL if
- * the hwmod is in the wrong state or passes along the return value of
- * _wait_target_ready().
+ * register target.  Returns -EINVAL if the hwmod is in the wrong
+ * state or passes along the return value of _wait_target_ready().
  */
-int _omap_hwmod_enable(struct omap_hwmod *oh)
+static int _enable(struct omap_hwmod *oh)
 {
 	int r;
 
@@ -1249,16 +1247,14 @@ int _omap_hwmod_enable(struct omap_hwmod *oh)
 }
 
 /**
- * _omap_hwmod_idle - idle an omap_hwmod
+ * _idle - idle an omap_hwmod
  * @oh: struct omap_hwmod *
  *
  * Idles an omap_hwmod @oh.  This should be called once the hwmod has
- * no further work.  (This function has a full name --
- * _omap_hwmod_idle() rather than simply _idle() -- because it is
- * currently required by the pm34xx.c idle loop.)  Returns -EINVAL if
- * the hwmod is in the wrong state or returns 0.
+ * no further work.  Returns -EINVAL if the hwmod is in the wrong
+ * state or returns 0.
  */
-int _omap_hwmod_idle(struct omap_hwmod *oh)
+static int _idle(struct omap_hwmod *oh)
 {
 	if (oh->_state != _HWMOD_STATE_ENABLED) {
 		WARN(1, "omap_hwmod: %s: idle state can only be entered from "
@@ -1304,11 +1300,11 @@ static int _shutdown(struct omap_hwmod *oh)
 	if (oh->class->pre_shutdown) {
 		prev_state = oh->_state;
 		if (oh->_state == _HWMOD_STATE_IDLE)
-			_omap_hwmod_enable(oh);
+			_enable(oh);
 		ret = oh->class->pre_shutdown(oh);
 		if (ret) {
 			if (prev_state == _HWMOD_STATE_IDLE)
-				_omap_hwmod_idle(oh);
+				_idle(oh);
 			return ret;
 		}
 	}
@@ -1381,7 +1377,7 @@ static int _setup(struct omap_hwmod *oh, void *data)
 	if ((oh->flags & HWMOD_INIT_NO_RESET) && oh->rst_lines_cnt == 1)
 		return 0;
 
-	r = _omap_hwmod_enable(oh);
+	r = _enable(oh);
 	if (r) {
 		pr_warning("omap_hwmod: %s: cannot be enabled (%d)\n",
 			   oh->name, oh->_state);
@@ -1393,7 +1389,7 @@ static int _setup(struct omap_hwmod *oh, void *data)
 
 		/*
 		 * OCP_SYSCONFIG bits need to be reprogrammed after a softreset.
-		 * The _omap_hwmod_enable() function should be split to
+		 * The _enable() function should be split to
 		 * avoid the rewrite of the OCP_SYSCONFIG register.
 		 */
 		if (oh->class->sysc) {
@@ -1415,7 +1411,7 @@ static int _setup(struct omap_hwmod *oh, void *data)
 		postsetup_state = _HWMOD_STATE_ENABLED;
 
 	if (postsetup_state == _HWMOD_STATE_IDLE)
-		_omap_hwmod_idle(oh);
+		_idle(oh);
 	else if (postsetup_state == _HWMOD_STATE_DISABLED)
 		_shutdown(oh);
 	else if (postsetup_state != _HWMOD_STATE_ENABLED)
@@ -1521,7 +1517,7 @@ int omap_hwmod_register(struct omap_hwmod *oh)
 
 	list_add_tail(&oh->node, &omap_hwmod_list);
 
-	mutex_init(&oh->_mutex);
+	spin_lock_init(&oh->_lock);
 
 	oh->_state = _HWMOD_STATE_REGISTERED;
 
@@ -1681,18 +1677,18 @@ int omap_hwmod_unregister(struct omap_hwmod *oh)
 int omap_hwmod_enable(struct omap_hwmod *oh)
 {
 	int r;
+	unsigned long flags;
 
 	if (!oh)
 		return -EINVAL;
 
-	mutex_lock(&oh->_mutex);
-	r = _omap_hwmod_enable(oh);
-	mutex_unlock(&oh->_mutex);
+	spin_lock_irqsave(&oh->_lock, flags);
+	r = _enable(oh);
+	spin_unlock_irqrestore(&oh->_lock, flags);
 
 	return r;
 }
 
-
 /**
  * omap_hwmod_idle - idle an omap_hwmod
  * @oh: struct omap_hwmod *
@@ -1702,12 +1698,14 @@ int omap_hwmod_enable(struct omap_hwmod *oh)
  */
 int omap_hwmod_idle(struct omap_hwmod *oh)
 {
+	unsigned long flags;
+
 	if (!oh)
 		return -EINVAL;
 
-	mutex_lock(&oh->_mutex);
-	_omap_hwmod_idle(oh);
-	mutex_unlock(&oh->_mutex);
+	spin_lock_irqsave(&oh->_lock, flags);
+	_idle(oh);
+	spin_unlock_irqrestore(&oh->_lock, flags);
 
 	return 0;
 }
@@ -1722,12 +1720,14 @@ int omap_hwmod_idle(struct omap_hwmod *oh)
  */
 int omap_hwmod_shutdown(struct omap_hwmod *oh)
 {
+	unsigned long flags;
+
 	if (!oh)
 		return -EINVAL;
 
-	mutex_lock(&oh->_mutex);
+	spin_lock_irqsave(&oh->_lock, flags);
 	_shutdown(oh);
-	mutex_unlock(&oh->_mutex);
+	spin_unlock_irqrestore(&oh->_lock, flags);
 
 	return 0;
 }
@@ -1740,9 +1740,11 @@ int omap_hwmod_shutdown(struct omap_hwmod *oh)
  */
 int omap_hwmod_enable_clocks(struct omap_hwmod *oh)
 {
-	mutex_lock(&oh->_mutex);
+	unsigned long flags;
+
+	spin_lock_irqsave(&oh->_lock, flags);
 	_enable_clocks(oh);
-	mutex_unlock(&oh->_mutex);
+	spin_unlock_irqrestore(&oh->_lock, flags);
 
 	return 0;
 }
@@ -1755,9 +1757,11 @@ int omap_hwmod_enable_clocks(struct omap_hwmod *oh)
  */
 int omap_hwmod_disable_clocks(struct omap_hwmod *oh)
 {
-	mutex_lock(&oh->_mutex);
+	unsigned long flags;
+
+	spin_lock_irqsave(&oh->_lock, flags);
 	_disable_clocks(oh);
-	mutex_unlock(&oh->_mutex);
+	spin_unlock_irqrestore(&oh->_lock, flags);
 
 	return 0;
 }
@@ -1801,13 +1805,14 @@ void omap_hwmod_ocp_barrier(struct omap_hwmod *oh)
 int omap_hwmod_reset(struct omap_hwmod *oh)
 {
 	int r;
+	unsigned long flags;
 
 	if (!oh)
 		return -EINVAL;
 
-	mutex_lock(&oh->_mutex);
+	spin_lock_irqsave(&oh->_lock, flags);
 	r = _reset(oh);
-	mutex_unlock(&oh->_mutex);
+	spin_unlock_irqrestore(&oh->_lock, flags);
 
 	return r;
 }
@@ -2004,13 +2009,15 @@ int omap_hwmod_del_initiator_dep(struct omap_hwmod *oh,
  */
 int omap_hwmod_enable_wakeup(struct omap_hwmod *oh)
 {
+	unsigned long flags;
+
 	if (!oh->class->sysc ||
 	    !(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP))
 		return -EINVAL;
 
-	mutex_lock(&oh->_mutex);
+	spin_lock_irqsave(&oh->_lock, flags);
 	_enable_wakeup(oh);
-	mutex_unlock(&oh->_mutex);
+	spin_unlock_irqrestore(&oh->_lock, flags);
 
 	return 0;
 }
@@ -2029,13 +2036,15 @@ int omap_hwmod_enable_wakeup(struct omap_hwmod *oh)
  */
 int omap_hwmod_disable_wakeup(struct omap_hwmod *oh)
 {
+	unsigned long flags;
+
 	if (!oh->class->sysc ||
 	    !(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP))
 		return -EINVAL;
 
-	mutex_lock(&oh->_mutex);
+	spin_lock_irqsave(&oh->_lock, flags);
 	_disable_wakeup(oh);
-	mutex_unlock(&oh->_mutex);
+	spin_unlock_irqrestore(&oh->_lock, flags);
 
 	return 0;
 }
@@ -2055,13 +2064,14 @@ int omap_hwmod_disable_wakeup(struct omap_hwmod *oh)
 int omap_hwmod_assert_hardreset(struct omap_hwmod *oh, const char *name)
 {
 	int ret;
+	unsigned long flags;
 
 	if (!oh)
 		return -EINVAL;
 
-	mutex_lock(&oh->_mutex);
+	spin_lock_irqsave(&oh->_lock, flags);
 	ret = _assert_hardreset(oh, name);
-	mutex_unlock(&oh->_mutex);
+	spin_unlock_irqrestore(&oh->_lock, flags);
 
 	return ret;
 }
@@ -2081,13 +2091,14 @@ int omap_hwmod_assert_hardreset(struct omap_hwmod *oh, const char *name)
 int omap_hwmod_deassert_hardreset(struct omap_hwmod *oh, const char *name)
 {
 	int ret;
+	unsigned long flags;
 
 	if (!oh)
 		return -EINVAL;
 
-	mutex_lock(&oh->_mutex);
+	spin_lock_irqsave(&oh->_lock, flags);
 	ret = _deassert_hardreset(oh, name);
-	mutex_unlock(&oh->_mutex);
+	spin_unlock_irqrestore(&oh->_lock, flags);
 
 	return ret;
 }
@@ -2106,13 +2117,14 @@ int omap_hwmod_deassert_hardreset(struct omap_hwmod *oh, const char *name)
 int omap_hwmod_read_hardreset(struct omap_hwmod *oh, const char *name)
 {
 	int ret;
+	unsigned long flags;
 
 	if (!oh)
 		return -EINVAL;
 
-	mutex_lock(&oh->_mutex);
+	spin_lock_irqsave(&oh->_lock, flags);
 	ret = _read_hardreset(oh, name);
-	mutex_unlock(&oh->_mutex);
+	spin_unlock_irqrestore(&oh->_lock, flags);
 
 	return ret;
 }
@@ -2180,6 +2192,7 @@ int omap_hwmod_for_each_by_class(const char *classname,
 int omap_hwmod_set_postsetup_state(struct omap_hwmod *oh, u8 state)
 {
 	int ret;
+	unsigned long flags;
 
 	if (!oh)
 		return -EINVAL;
@@ -2189,7 +2202,7 @@ int omap_hwmod_set_postsetup_state(struct omap_hwmod *oh, u8 state)
 	    state != _HWMOD_STATE_IDLE)
 		return -EINVAL;
 
-	mutex_lock(&oh->_mutex);
+	spin_lock_irqsave(&oh->_lock, flags);
 
 	if (oh->_state != _HWMOD_STATE_REGISTERED) {
 		ret = -EINVAL;
@@ -2200,7 +2213,7 @@ int omap_hwmod_set_postsetup_state(struct omap_hwmod *oh, u8 state)
 	ret = 0;
 
 ohsps_unlock:
-	mutex_unlock(&oh->_mutex);
+	spin_unlock_irqrestore(&oh->_lock, flags);
 
 	return ret;
 }

commit bd36179eec2827cd60b4a8c6e180cc030c74a4ec
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 14 12:42:35 2010 -0700

    OMAP2+: hwmod: add support for per-class custom device reset functions
    
    The standard omap_hwmod.c _reset() code relies on an IP block's
    OCP_SYSCONFIG.SOFTRESET register bit to reset the IP block.  This
    works for most IP blocks on the chip, but unfortunately not all.  For
    example, initiator-only IP blocks often don't have any MPU-accessible
    OCP-header registers, and therefore the MPU can't write to any
    OCP_SYSCONFIG registers in that block.  Other IP blocks, such as the
    IVA and I2C, require a specialized reset sequence.
    
    Since we need to be able to reset these IP blocks as well, allow
    custom IP block reset functions to be passed into the hwmod code via a
    per-hwmod-class reset function pointer, struct omap_hwmod_class.reset.
    If .reset is non-null, then the hwmod _reset() code will call the custom
    function instead of the standard OCP SOFTRESET-based code.
    
    As part of this change, rename most of the existing _reset() function
    code to _ocp_softreset(), to indicate more clearly that it does not work
    for all cases.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>
    Cc: Paul Hunt <hunt@ti.com>
    Cc: Stanley Liu <stanley_liu@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 683428fa91f4..12a0b9a30a30 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1089,7 +1089,7 @@ static int _read_hardreset(struct omap_hwmod *oh, const char *name)
 }
 
 /**
- * _reset - reset an omap_hwmod
+ * _ocp_softreset - reset an omap_hwmod via the OCP_SYSCONFIG bit
  * @oh: struct omap_hwmod *
  *
  * Resets an omap_hwmod @oh via the OCP_SYSCONFIG bit.  hwmod must be
@@ -1098,12 +1098,13 @@ static int _read_hardreset(struct omap_hwmod *oh, const char *name)
  * the module did not reset in time, or 0 upon success.
  *
  * In OMAP3 a specific SYSSTATUS register is used to get the reset status.
- * Starting in OMAP4, some IPs does not have SYSSTATUS register and instead
+ * Starting in OMAP4, some IPs do not have SYSSTATUS registers and instead
  * use the SYSCONFIG softreset bit to provide the status.
  *
- * Note that some IP like McBSP does have a reset control but no reset status.
+ * Note that some IP like McBSP do have reset control but don't have
+ * reset status.
  */
-static int _reset(struct omap_hwmod *oh)
+static int _ocp_softreset(struct omap_hwmod *oh)
 {
 	u32 v;
 	int c = 0;
@@ -1124,7 +1125,7 @@ static int _reset(struct omap_hwmod *oh)
 	if (oh->flags & HWMOD_CONTROL_OPT_CLKS_IN_RESET)
 		_enable_optional_clocks(oh);
 
-	pr_debug("omap_hwmod: %s: resetting\n", oh->name);
+	pr_debug("omap_hwmod: %s: resetting via OCP SOFTRESET\n", oh->name);
 
 	v = oh->_sysc_cache;
 	ret = _set_softreset(oh, &v);
@@ -1163,6 +1164,33 @@ static int _reset(struct omap_hwmod *oh)
 	return ret;
 }
 
+/**
+ * _reset - reset an omap_hwmod
+ * @oh: struct omap_hwmod *
+ *
+ * Resets an omap_hwmod @oh.  The default software reset mechanism for
+ * most OMAP IP blocks is triggered via the OCP_SYSCONFIG.SOFTRESET
+ * bit.  However, some hwmods cannot be reset via this method: some
+ * are not targets and therefore have no OCP header registers to
+ * access; others (like the IVA) have idiosyncratic reset sequences.
+ * So for these relatively rare cases, custom reset code can be
+ * supplied in the struct omap_hwmod_class .reset function pointer.
+ * Passes along the return value from either _reset() or the custom
+ * reset function - these must return -EINVAL if the hwmod cannot be
+ * reset this way or if the hwmod is in the wrong state, -ETIMEDOUT if
+ * the module did not reset in time, or 0 upon success.
+ */
+static int _reset(struct omap_hwmod *oh)
+{
+	int ret;
+
+	pr_debug("omap_hwmod: %s: resetting\n", oh->name);
+
+	ret = (oh->class->reset) ? oh->class->reset(oh) : _ocp_softreset(oh);
+
+	return ret;
+}
+
 /**
  * _omap_hwmod_enable - enable an omap_hwmod
  * @oh: struct omap_hwmod *

commit 2092e5ccf89db09ebde94e9aabd3c86d5fa05c6c
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 14 12:42:35 2010 -0700

    OMAP2+: hwmod: add postsetup state
    
    Allow board files and OMAP core code to control the state that some or
    all of the hwmods end up in at the end of _setup() (called by
    omap_hwmod_late_init() ).  Reimplement the old skip_setup_idle code in
    terms of this new postsetup state code.
    
    There are two use-cases for this patch: the !CONFIG_PM_RUNTIME case,
    in which all IP blocks should stay enabled after _setup() finishes;
    and the MPU watchdog case, in which the watchdog IP block should enter
    idle if watchdog coverage of kernel initialization is desired, and
    should be disabled otherwise.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Charulatha Varadarajan <charu@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index c051fa493594..683428fa91f4 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1313,23 +1313,15 @@ static int _shutdown(struct omap_hwmod *oh)
 /**
  * _setup - do initial configuration of omap_hwmod
  * @oh: struct omap_hwmod *
- * @skip_setup_idle_p: do not idle hwmods at the end of the fn if 1
  *
  * Writes the CLOCKACTIVITY bits @clockact to the hwmod @oh
- * OCP_SYSCONFIG register.  @skip_setup_idle is intended to be used on
- * a system that will not call omap_hwmod_enable() to enable devices
- * (e.g., a system without PM runtime).  Returns -EINVAL if the hwmod
- * is in the wrong state or returns 0.
+ * OCP_SYSCONFIG register.  Returns -EINVAL if the hwmod is in the
+ * wrong state or returns 0.
  */
 static int _setup(struct omap_hwmod *oh, void *data)
 {
 	int i, r;
-	u8 skip_setup_idle;
-
-	if (!oh || !data)
-		return -EINVAL;
-
-	skip_setup_idle = *(u8 *)data;
+	u8 postsetup_state;
 
 	/* Set iclk autoidle mode */
 	if (oh->slaves_cnt > 0) {
@@ -1349,7 +1341,6 @@ static int _setup(struct omap_hwmod *oh, void *data)
 		}
 	}
 
-	mutex_init(&oh->_mutex);
 	oh->_state = _HWMOD_STATE_INITIALIZED;
 
 	/*
@@ -1383,8 +1374,25 @@ static int _setup(struct omap_hwmod *oh, void *data)
 		}
 	}
 
-	if (!(oh->flags & HWMOD_INIT_NO_IDLE) && !skip_setup_idle)
+	postsetup_state = oh->_postsetup_state;
+	if (postsetup_state == _HWMOD_STATE_UNKNOWN)
+		postsetup_state = _HWMOD_STATE_ENABLED;
+
+	/*
+	 * XXX HWMOD_INIT_NO_IDLE does not belong in hwmod data -
+	 * it should be set by the core code as a runtime flag during startup
+	 */
+	if ((oh->flags & HWMOD_INIT_NO_IDLE) &&
+	    (postsetup_state == _HWMOD_STATE_IDLE))
+		postsetup_state = _HWMOD_STATE_ENABLED;
+
+	if (postsetup_state == _HWMOD_STATE_IDLE)
 		_omap_hwmod_idle(oh);
+	else if (postsetup_state == _HWMOD_STATE_DISABLED)
+		_shutdown(oh);
+	else if (postsetup_state != _HWMOD_STATE_ENABLED)
+		WARN(1, "hwmod: %s: unknown postsetup state %d! defaulting to enabled\n",
+		     oh->name, postsetup_state);
 
 	return 0;
 }
@@ -1485,6 +1493,8 @@ int omap_hwmod_register(struct omap_hwmod *oh)
 
 	list_add_tail(&oh->node, &omap_hwmod_list);
 
+	mutex_init(&oh->_mutex);
+
 	oh->_state = _HWMOD_STATE_REGISTERED;
 
 	ret = 0;
@@ -1585,13 +1595,12 @@ int omap_hwmod_init(struct omap_hwmod **ohs)
 
 /**
  * omap_hwmod_late_init - do some post-clock framework initialization
- * @skip_setup_idle: if 1, do not idle hwmods in _setup()
  *
  * Must be called after omap2_clk_init().  Resolves the struct clk names
  * to struct clk pointers for each registered omap_hwmod.  Also calls
  * _setup() on each hwmod.  Returns 0.
  */
-int omap_hwmod_late_init(u8 skip_setup_idle)
+int omap_hwmod_late_init(void)
 {
 	int r;
 
@@ -1603,10 +1612,7 @@ int omap_hwmod_late_init(u8 skip_setup_idle)
 	WARN(!mpu_oh, "omap_hwmod: could not find MPU initiator hwmod %s\n",
 	     MPU_INITIATOR_NAME);
 
-	if (skip_setup_idle)
-		pr_debug("omap_hwmod: will leave hwmods enabled during setup\n");
-
-	omap_hwmod_for_each(_setup, &skip_setup_idle);
+	omap_hwmod_for_each(_setup, NULL);
 
 	return 0;
 }
@@ -2132,3 +2138,41 @@ int omap_hwmod_for_each_by_class(const char *classname,
 	return ret;
 }
 
+/**
+ * omap_hwmod_set_postsetup_state - set the post-_setup() state for this hwmod
+ * @oh: struct omap_hwmod *
+ * @state: state that _setup() should leave the hwmod in
+ *
+ * Sets the hwmod state that @oh will enter at the end of _setup() (called by
+ * omap_hwmod_late_init()).  Only valid to call between calls to
+ * omap_hwmod_init() and omap_hwmod_late_init().  Returns 0 upon success or
+ * -EINVAL if there is a problem with the arguments or if the hwmod is
+ * in the wrong state.
+ */
+int omap_hwmod_set_postsetup_state(struct omap_hwmod *oh, u8 state)
+{
+	int ret;
+
+	if (!oh)
+		return -EINVAL;
+
+	if (state != _HWMOD_STATE_DISABLED &&
+	    state != _HWMOD_STATE_ENABLED &&
+	    state != _HWMOD_STATE_IDLE)
+		return -EINVAL;
+
+	mutex_lock(&oh->_mutex);
+
+	if (oh->_state != _HWMOD_STATE_REGISTERED) {
+		ret = -EINVAL;
+		goto ohsps_unlock;
+	}
+
+	oh->_postsetup_state = state;
+	ret = 0;
+
+ohsps_unlock:
+	mutex_unlock(&oh->_mutex);
+
+	return ret;
+}

commit e4dc8f507c3066d6fcece988d99b6d766c46af85
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 14 12:42:34 2010 -0700

    OMAP2+: hwmod: allow custom pre-shutdown functions
    
    Some OMAP IP blocks, such as the watchdog timers, cannot be completely
    shut down via the standard hwmod shutdown mechanism.  This patch
    enables the hwmod data files to supply a pointer to a custom
    pre-shutdown function via the struct omap_hwmod_class.pre_shutdown
    function pointer.  If the struct omap_hwmod_class.pre_shutdown
    function pointer is non-null, the function will be executed before the
    existing hwmod shutdown code runs.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 5a30658444d0..c051fa493594 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1261,6 +1261,9 @@ int _omap_hwmod_idle(struct omap_hwmod *oh)
  */
 static int _shutdown(struct omap_hwmod *oh)
 {
+	int ret;
+	u8 prev_state;
+
 	if (oh->_state != _HWMOD_STATE_IDLE &&
 	    oh->_state != _HWMOD_STATE_ENABLED) {
 		WARN(1, "omap_hwmod: %s: disabled state can only be entered "
@@ -1270,6 +1273,18 @@ static int _shutdown(struct omap_hwmod *oh)
 
 	pr_debug("omap_hwmod: %s: disabling\n", oh->name);
 
+	if (oh->class->pre_shutdown) {
+		prev_state = oh->_state;
+		if (oh->_state == _HWMOD_STATE_IDLE)
+			_omap_hwmod_enable(oh);
+		ret = oh->class->pre_shutdown(oh);
+		if (ret) {
+			if (prev_state == _HWMOD_STATE_IDLE)
+				_omap_hwmod_idle(oh);
+			return ret;
+		}
+	}
+
 	if (oh->class->sysc)
 		_shutdown_sysc(oh);
 

commit cc7a1d2a540a780066aa562c651a88dd28b6fc8a
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Oct 8 10:23:22 2010 -0700

    omap: hwmod: Handle modules with 16bit registers
    
    Some modules which have 16bit registers can cause imprecise
    aborts if a __raw_readl/writel is used to read/write 32 bits.
    
    Add an additional flag to identify modules which have such
    hard requirement, and handle it in the hwmod framework.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 955861acc0c4..5a30658444d0 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -184,7 +184,7 @@ static int _update_sysc_cache(struct omap_hwmod *oh)
 
 	/* XXX ensure module interface clock is up */
 
-	oh->_sysc_cache = omap_hwmod_readl(oh, oh->class->sysc->sysc_offs);
+	oh->_sysc_cache = omap_hwmod_read(oh, oh->class->sysc->sysc_offs);
 
 	if (!(oh->class->sysc->sysc_flags & SYSC_NO_CACHE))
 		oh->_int_flags |= _HWMOD_SYSCONFIG_LOADED;
@@ -211,7 +211,7 @@ static void _write_sysconfig(u32 v, struct omap_hwmod *oh)
 
 	if (oh->_sysc_cache != v) {
 		oh->_sysc_cache = v;
-		omap_hwmod_writel(v, oh, oh->class->sysc->sysc_offs);
+		omap_hwmod_write(v, oh, oh->class->sysc->sysc_offs);
 	}
 }
 
@@ -1133,12 +1133,12 @@ static int _reset(struct omap_hwmod *oh)
 	_write_sysconfig(v, oh);
 
 	if (oh->class->sysc->sysc_flags & SYSS_HAS_RESET_STATUS)
-		omap_test_timeout((omap_hwmod_readl(oh,
+		omap_test_timeout((omap_hwmod_read(oh,
 						    oh->class->sysc->syss_offs)
 				   & SYSS_RESETDONE_MASK),
 				  MAX_MODULE_SOFTRESET_WAIT, c);
 	else if (oh->class->sysc->sysc_flags & SYSC_HAS_RESET_STATUS)
-		omap_test_timeout(!(omap_hwmod_readl(oh,
+		omap_test_timeout(!(omap_hwmod_read(oh,
 						     oh->class->sysc->sysc_offs)
 				   & SYSC_TYPE2_SOFTRESET_MASK),
 				  MAX_MODULE_SOFTRESET_WAIT, c);
@@ -1378,14 +1378,20 @@ static int _setup(struct omap_hwmod *oh, void *data)
 
 /* Public functions */
 
-u32 omap_hwmod_readl(struct omap_hwmod *oh, u16 reg_offs)
+u32 omap_hwmod_read(struct omap_hwmod *oh, u16 reg_offs)
 {
-	return __raw_readl(oh->_mpu_rt_va + reg_offs);
+	if (oh->flags & HWMOD_16BIT_REG)
+		return __raw_readw(oh->_mpu_rt_va + reg_offs);
+	else
+		return __raw_readl(oh->_mpu_rt_va + reg_offs);
 }
 
-void omap_hwmod_writel(u32 v, struct omap_hwmod *oh, u16 reg_offs)
+void omap_hwmod_write(u32 v, struct omap_hwmod *oh, u16 reg_offs)
 {
-	__raw_writel(v, oh->_mpu_rt_va + reg_offs);
+	if (oh->flags & HWMOD_16BIT_REG)
+		__raw_writew(v, oh->_mpu_rt_va + reg_offs);
+	else
+		__raw_writel(v, oh->_mpu_rt_va + reg_offs);
 }
 
 /**
@@ -1732,7 +1738,7 @@ void omap_hwmod_ocp_barrier(struct omap_hwmod *oh)
 	 * Forces posted writes to complete on the OCP thread handling
 	 * register writes
 	 */
-	omap_hwmod_readl(oh, oh->class->sysc->sysc_offs);
+	omap_hwmod_read(oh, oh->class->sysc->sysc_offs);
 }
 
 /**

commit 78f26e872f77b6312273216de1a8f836c6f2e143
Author: Hema HK <hemahk@ti.com>
Date:   Fri Sep 24 10:23:19 2010 -0600

    OMAP: hwmod: Set autoidle after smartidle during _sysc_enable
    
    OMAP USBOTG module has a requirement to set the autoidle bit only after
    setting smartidle bit. Modified the _sys_enable api to set the smartidle
    first and then the autoidle bit. Setting this will not have any impact on the
    other modules.
    
    Signed-off-by: Hema HK <hemahk@ti.com>
    Signed-off-by: Partha Basak <p-basak2@ti.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Acked-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index c3a5889d8add..955861acc0c4 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -777,12 +777,6 @@ static void _enable_sysc(struct omap_hwmod *oh)
 		_set_master_standbymode(oh, idlemode, &v);
 	}
 
-	if (sf & SYSC_HAS_AUTOIDLE) {
-		idlemode = (oh->flags & HWMOD_NO_OCP_AUTOIDLE) ?
-			0 : 1;
-		_set_module_autoidle(oh, idlemode, &v);
-	}
-
 	/*
 	 * XXX The clock framework should handle this, by
 	 * calling into this code.  But this must wait until the
@@ -797,6 +791,17 @@ static void _enable_sysc(struct omap_hwmod *oh)
 	/* If slave is in SMARTIDLE, also enable wakeup */
 	if ((sf & SYSC_HAS_SIDLEMODE) && !(oh->flags & HWMOD_SWSUP_SIDLE))
 		_enable_wakeup(oh);
+
+	/*
+	 * Set the autoidle bit only after setting the smartidle bit
+	 * Setting this will not have any impact on the other modules.
+	 */
+	if (sf & SYSC_HAS_AUTOIDLE) {
+		idlemode = (oh->flags & HWMOD_NO_OCP_AUTOIDLE) ?
+			0 : 1;
+		_set_module_autoidle(oh, idlemode, &v);
+		_write_sysconfig(v, oh);
+	}
 }
 
 /**

commit 74ff3a68ed11f1e9eede4fe301f42cc3cdf7396a
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Sep 21 15:02:23 2010 -0600

    OMAP: hwmod: improve documentation, clean up function names
    
    This patch:
    
    - adds more documentation to the hwmod code
    
    - fixes some documentation typos elsewhere in the file
    
    - changes the _sysc_*() function names to appear in (verb, noun) order,
      to match the rest of the function names.
    
    This patch should not result in any functional change.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index d694067e6e9a..c3a5889d8add 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -13,10 +13,102 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
- * This code manages "OMAP modules" (on-chip devices) and their
- * integration with Linux device driver and bus code.
- *
- * References:
+ * Introduction
+ * ------------
+ * One way to view an OMAP SoC is as a collection of largely unrelated
+ * IP blocks connected by interconnects.  The IP blocks include
+ * devices such as ARM processors, audio serial interfaces, UARTs,
+ * etc.  Some of these devices, like the DSP, are created by TI;
+ * others, like the SGX, largely originate from external vendors.  In
+ * TI's documentation, on-chip devices are referred to as "OMAP
+ * modules."  Some of these IP blocks are identical across several
+ * OMAP versions.  Others are revised frequently.
+ *
+ * These OMAP modules are tied together by various interconnects.
+ * Most of the address and data flow between modules is via OCP-based
+ * interconnects such as the L3 and L4 buses; but there are other
+ * interconnects that distribute the hardware clock tree, handle idle
+ * and reset signaling, supply power, and connect the modules to
+ * various pads or balls on the OMAP package.
+ *
+ * OMAP hwmod provides a consistent way to describe the on-chip
+ * hardware blocks and their integration into the rest of the chip.
+ * This description can be automatically generated from the TI
+ * hardware database.  OMAP hwmod provides a standard, consistent API
+ * to reset, enable, idle, and disable these hardware blocks.  And
+ * hwmod provides a way for other core code, such as the Linux device
+ * code or the OMAP power management and address space mapping code,
+ * to query the hardware database.
+ *
+ * Using hwmod
+ * -----------
+ * Drivers won't call hwmod functions directly.  That is done by the
+ * omap_device code, and in rare occasions, by custom integration code
+ * in arch/arm/ *omap*.  The omap_device code includes functions to
+ * build a struct platform_device using omap_hwmod data, and that is
+ * currently how hwmod data is communicated to drivers and to the
+ * Linux driver model.  Most drivers will call omap_hwmod functions only
+ * indirectly, via pm_runtime*() functions.
+ *
+ * From a layering perspective, here is where the OMAP hwmod code
+ * fits into the kernel software stack:
+ *
+ *            +-------------------------------+
+ *            |      Device driver code       |
+ *            |      (e.g., drivers/)         |
+ *            +-------------------------------+
+ *            |      Linux driver model       |
+ *            |     (platform_device /        |
+ *            |  platform_driver data/code)   |
+ *            +-------------------------------+
+ *            | OMAP core-driver integration  |
+ *            |(arch/arm/mach-omap2/devices.c)|
+ *            +-------------------------------+
+ *            |      omap_device code         |
+ *            | (../plat-omap/omap_device.c)  |
+ *            +-------------------------------+
+ *   ---->    |    omap_hwmod code/data       |    <-----
+ *            | (../mach-omap2/omap_hwmod*)   |
+ *            +-------------------------------+
+ *            | OMAP clock/PRCM/register fns  |
+ *            | (__raw_{read,write}l, clk*)   |
+ *            +-------------------------------+
+ *
+ * Device drivers should not contain any OMAP-specific code or data in
+ * them.  They should only contain code to operate the IP block that
+ * the driver is responsible for.  This is because these IP blocks can
+ * also appear in other SoCs, either from TI (such as DaVinci) or from
+ * other manufacturers; and drivers should be reusable across other
+ * platforms.
+ *
+ * The OMAP hwmod code also will attempt to reset and idle all on-chip
+ * devices upon boot.  The goal here is for the kernel to be
+ * completely self-reliant and independent from bootloaders.  This is
+ * to ensure a repeatable configuration, both to ensure consistent
+ * runtime behavior, and to make it easier for others to reproduce
+ * bugs.
+ *
+ * OMAP module activity states
+ * ---------------------------
+ * The hwmod code considers modules to be in one of several activity
+ * states.  IP blocks start out in an UNKNOWN state, then once they
+ * are registered via the hwmod code, proceed to the REGISTERED state.
+ * Once their clock names are resolved to clock pointers, the module
+ * enters the CLKS_INITED state; and finally, once the module has been
+ * reset and the integration registers programmed, the INITIALIZED state
+ * is entered.  The hwmod code will then place the module into either
+ * the IDLE state to save power, or in the case of a critical system
+ * module, the ENABLED state.
+ *
+ * OMAP core integration code can then call omap_hwmod*() functions
+ * directly to move the module between the IDLE, ENABLED, and DISABLED
+ * states, as needed.  This is done during both the PM idle loop, and
+ * in the OMAP core integration code's implementation of the PM runtime
+ * functions.
+ *
+ * References
+ * ----------
+ * This is a partial list.
  * - OMAP2420 Multimedia Processor Silicon Revision 2.1.1, 2.2 (SWPU064)
  * - OMAP2430 Multimedia Device POP Silicon Revision 2.1 (SWPU090)
  * - OMAP34xx Multimedia Device Silicon Revision 3.1 (SWPU108)
@@ -654,7 +746,7 @@ static void __iomem *_find_mpu_rt_base(struct omap_hwmod *oh, u8 index)
 }
 
 /**
- * _sysc_enable - try to bring a module out of idle via OCP_SYSCONFIG
+ * _enable_sysc - try to bring a module out of idle via OCP_SYSCONFIG
  * @oh: struct omap_hwmod *
  *
  * If module is marked as SWSUP_SIDLE, force the module out of slave
@@ -662,7 +754,7 @@ static void __iomem *_find_mpu_rt_base(struct omap_hwmod *oh, u8 index)
  * as SWSUP_MSUSPEND, force the module out of master standby;
  * otherwise, configure it for smart-standby.  No return value.
  */
-static void _sysc_enable(struct omap_hwmod *oh)
+static void _enable_sysc(struct omap_hwmod *oh)
 {
 	u8 idlemode, sf;
 	u32 v;
@@ -708,7 +800,7 @@ static void _sysc_enable(struct omap_hwmod *oh)
 }
 
 /**
- * _sysc_idle - try to put a module into idle via OCP_SYSCONFIG
+ * _idle_sysc - try to put a module into idle via OCP_SYSCONFIG
  * @oh: struct omap_hwmod *
  *
  * If module is marked as SWSUP_SIDLE, force the module into slave
@@ -716,7 +808,7 @@ static void _sysc_enable(struct omap_hwmod *oh)
  * as SWSUP_MSUSPEND, force the module into master standby; otherwise,
  * configure it for smart-standby.  No return value.
  */
-static void _sysc_idle(struct omap_hwmod *oh)
+static void _idle_sysc(struct omap_hwmod *oh)
 {
 	u8 idlemode, sf;
 	u32 v;
@@ -743,13 +835,13 @@ static void _sysc_idle(struct omap_hwmod *oh)
 }
 
 /**
- * _sysc_shutdown - force a module into idle via OCP_SYSCONFIG
+ * _shutdown_sysc - force a module into idle via OCP_SYSCONFIG
  * @oh: struct omap_hwmod *
  *
  * Force the module into slave idle and master suspend. No return
  * value.
  */
-static void _sysc_shutdown(struct omap_hwmod *oh)
+static void _shutdown_sysc(struct omap_hwmod *oh)
 {
 	u32 v;
 	u8 sf;
@@ -1071,8 +1163,11 @@ static int _reset(struct omap_hwmod *oh)
  * @oh: struct omap_hwmod *
  *
  * Enables an omap_hwmod @oh such that the MPU can access the hwmod's
- * register target.  Returns -EINVAL if the hwmod is in the wrong
- * state or passes along the return value of _wait_target_ready().
+ * register target.  (This function has a full name --
+ * _omap_hwmod_enable() rather than simply _enable() -- because it is
+ * currently required by the pm34xx.c idle loop.)  Returns -EINVAL if
+ * the hwmod is in the wrong state or passes along the return value of
+ * _wait_target_ready().
  */
 int _omap_hwmod_enable(struct omap_hwmod *oh)
 {
@@ -1110,7 +1205,7 @@ int _omap_hwmod_enable(struct omap_hwmod *oh)
 		if (oh->class->sysc) {
 			if (!(oh->_int_flags & _HWMOD_SYSCONFIG_LOADED))
 				_update_sysc_cache(oh);
-			_sysc_enable(oh);
+			_enable_sysc(oh);
 		}
 	} else {
 		pr_debug("omap_hwmod: %s: _wait_target_ready: %d\n",
@@ -1121,12 +1216,14 @@ int _omap_hwmod_enable(struct omap_hwmod *oh)
 }
 
 /**
- * _idle - idle an omap_hwmod
+ * _omap_hwmod_idle - idle an omap_hwmod
  * @oh: struct omap_hwmod *
  *
  * Idles an omap_hwmod @oh.  This should be called once the hwmod has
- * no further work.  Returns -EINVAL if the hwmod is in the wrong
- * state or returns 0.
+ * no further work.  (This function has a full name --
+ * _omap_hwmod_idle() rather than simply _idle() -- because it is
+ * currently required by the pm34xx.c idle loop.)  Returns -EINVAL if
+ * the hwmod is in the wrong state or returns 0.
  */
 int _omap_hwmod_idle(struct omap_hwmod *oh)
 {
@@ -1139,7 +1236,7 @@ int _omap_hwmod_idle(struct omap_hwmod *oh)
 	pr_debug("omap_hwmod: %s: idling\n", oh->name);
 
 	if (oh->class->sysc)
-		_sysc_idle(oh);
+		_idle_sysc(oh);
 	_del_initiator_dep(oh, mpu_oh);
 	_disable_clocks(oh);
 
@@ -1169,7 +1266,7 @@ static int _shutdown(struct omap_hwmod *oh)
 	pr_debug("omap_hwmod: %s: disabling\n", oh->name);
 
 	if (oh->class->sysc)
-		_sysc_shutdown(oh);
+		_shutdown_sysc(oh);
 
 	/*
 	 * If an IP contains only one HW reset line, then assert it
@@ -1262,7 +1359,7 @@ static int _setup(struct omap_hwmod *oh, void *data)
 		 */
 		if (oh->class->sysc) {
 			_update_sysc_cache(oh);
-			_sysc_enable(oh);
+			_enable_sysc(oh);
 		}
 	}
 
@@ -1518,7 +1615,7 @@ int omap_hwmod_unregister(struct omap_hwmod *oh)
  * omap_hwmod_enable - enable an omap_hwmod
  * @oh: struct omap_hwmod *
  *
- * Enable an omap_hwomd @oh.  Intended to be called by omap_device_enable().
+ * Enable an omap_hwmod @oh.  Intended to be called by omap_device_enable().
  * Returns -EINVAL on error or passes along the return value from _enable().
  */
 int omap_hwmod_enable(struct omap_hwmod *oh)
@@ -1540,7 +1637,7 @@ int omap_hwmod_enable(struct omap_hwmod *oh)
  * omap_hwmod_idle - idle an omap_hwmod
  * @oh: struct omap_hwmod *
  *
- * Idle an omap_hwomd @oh.  Intended to be called by omap_device_idle().
+ * Idle an omap_hwmod @oh.  Intended to be called by omap_device_idle().
  * Returns -EINVAL on error or passes along the return value from _idle().
  */
 int omap_hwmod_idle(struct omap_hwmod *oh)
@@ -1559,7 +1656,7 @@ int omap_hwmod_idle(struct omap_hwmod *oh)
  * omap_hwmod_shutdown - shutdown an omap_hwmod
  * @oh: struct omap_hwmod *
  *
- * Shutdown an omap_hwomd @oh.  Intended to be called by
+ * Shutdown an omap_hwmod @oh.  Intended to be called by
  * omap_device_shutdown().  Returns -EINVAL on error or passes along
  * the return value from _shutdown().
  */

commit 9980ce53c97392a3dbdc9d1ac3e455d79b4167ed
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Tue Sep 21 19:58:30 2010 +0530

    OMAP: hwmod: Enable module wakeup if in smartidle
    
    If a module's OCP slave port is programmed to be in smartidle,
    its also necessary that they have module level wakeup enabled.
    Update _sysc_enable in hwmod framework to do this.
    
    The thread "[PATCH 7/8] : Hwmod api changes" archived here:
    
    http://www.mail-archive.com/linux-omap@vger.kernel.org/msg34212.html
    
    has additional technical information on the rationale of this patch.
    
    Sergei Shtylyov <sshtylyov@mvista.com> identified an indentation
    problem with this patch - thanks, Sergei.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Partha Basak <p-basak2@ti.com>
    Signed-off-by: Benot Cousson <b-cousson@ti.com>
    [paul@pwsan.com: revised patch description]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Sergei Shtylyov <sshtylyov@mvista.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index f320cfb911d5..d694067e6e9a 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -691,8 +691,6 @@ static void _sysc_enable(struct omap_hwmod *oh)
 		_set_module_autoidle(oh, idlemode, &v);
 	}
 
-	/* XXX OCP ENAWAKEUP bit? */
-
 	/*
 	 * XXX The clock framework should handle this, by
 	 * calling into this code.  But this must wait until the
@@ -703,6 +701,10 @@ static void _sysc_enable(struct omap_hwmod *oh)
 		_set_clockactivity(oh, oh->class->sysc->clockact, &v);
 
 	_write_sysconfig(v, oh);
+
+	/* If slave is in SMARTIDLE, also enable wakeup */
+	if ((sf & SYSC_HAS_SIDLEMODE) && !(oh->flags & HWMOD_SWSUP_SIDLE))
+		_enable_wakeup(oh);
 }
 
 /**

commit 96835af970e5d6aeedf868e53590a947be5e4a7a
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Tue Sep 21 18:57:58 2010 +0200

    OMAP: hwmod: Fix softreset for modules with optional clocks
    
    Some modules (like GPIO, DSS...) require optionals clock to be enabled
    in order to complete the sofreset properly.
    Add a HWMOD_CONTROL_OPT_CLKS_IN_RESET flag to force all optional clocks
    to be enabled before reset. Disabled them once the reset is done.
    
    TODO:
    For the moment it is very hard to understand from the HW spec, which
    optional clock is needed and which one is not. So the current approach
    will enable all the optional clocks.
    Paul proposed a much finer approach that will allow to tag only the needed
    clock in the optional clock table. This might be doable as soon as we have
    a clear understanding of these dependencies.
    
    Reported-by: Partha Basak <p-basak2@ti.com>
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 5027879b062f..f320cfb911d5 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -546,6 +546,36 @@ static int _disable_clocks(struct omap_hwmod *oh)
 	return 0;
 }
 
+static void _enable_optional_clocks(struct omap_hwmod *oh)
+{
+	struct omap_hwmod_opt_clk *oc;
+	int i;
+
+	pr_debug("omap_hwmod: %s: enabling optional clocks\n", oh->name);
+
+	for (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++)
+		if (oc->_clk) {
+			pr_debug("omap_hwmod: enable %s:%s\n", oc->role,
+				 oc->_clk->name);
+			clk_enable(oc->_clk);
+		}
+}
+
+static void _disable_optional_clocks(struct omap_hwmod *oh)
+{
+	struct omap_hwmod_opt_clk *oc;
+	int i;
+
+	pr_debug("omap_hwmod: %s: disabling optional clocks\n", oh->name);
+
+	for (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++)
+		if (oc->_clk) {
+			pr_debug("omap_hwmod: disable %s:%s\n", oc->role,
+				 oc->_clk->name);
+			clk_disable(oc->_clk);
+		}
+}
+
 /**
  * _find_mpu_port_index - find hwmod OCP slave port ID intended for MPU use
  * @oh: struct omap_hwmod *
@@ -976,8 +1006,9 @@ static int _read_hardreset(struct omap_hwmod *oh, const char *name)
  */
 static int _reset(struct omap_hwmod *oh)
 {
-	u32 r, v;
+	u32 v;
 	int c = 0;
+	int ret = 0;
 
 	if (!oh->class->sysc ||
 	    !(oh->class->sysc->sysc_flags & SYSC_HAS_SOFTRESET))
@@ -990,12 +1021,16 @@ static int _reset(struct omap_hwmod *oh)
 		return -EINVAL;
 	}
 
+	/* For some modules, all optionnal clocks need to be enabled as well */
+	if (oh->flags & HWMOD_CONTROL_OPT_CLKS_IN_RESET)
+		_enable_optional_clocks(oh);
+
 	pr_debug("omap_hwmod: %s: resetting\n", oh->name);
 
 	v = oh->_sysc_cache;
-	r = _set_softreset(oh, &v);
-	if (r)
-		return r;
+	ret = _set_softreset(oh, &v);
+	if (ret)
+		goto dis_opt_clks;
 	_write_sysconfig(v, oh);
 
 	if (oh->class->sysc->sysc_flags & SYSS_HAS_RESET_STATUS)
@@ -1020,7 +1055,13 @@ static int _reset(struct omap_hwmod *oh)
 	 * _wait_target_ready() or _reset()
 	 */
 
-	return (c == MAX_MODULE_SOFTRESET_WAIT) ? -ETIMEDOUT : 0;
+	ret = (c == MAX_MODULE_SOFTRESET_WAIT) ? -ETIMEDOUT : 0;
+
+dis_opt_clks:
+	if (oh->flags & HWMOD_CONTROL_OPT_CLKS_IN_RESET)
+		_disable_optional_clocks(oh);
+
+	return ret;
 }
 
 /**

commit 2cb068149c365f1c2b10f2ece6786139527dcc16
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Tue Sep 21 18:57:59 2010 +0200

    OMAP: hwmod: Fix softreset status check for some new OMAP4 IPs
    
    In OMAP3 a specific SYSSTATUS register was used to get the softreset status.
    Starting in OMAP4, some IPs does not have SYSSTATUS register and instead
    use the SYSC softreset bit to provide the status.
    
    Other cases might exist:
    - Some IPs like McBSP does have a softreset control but no reset status.
    - Some IPs that represent subsystem, like the DSS, can contains
    a reset status without softreset control. The status is the aggregation
    of all the sub modules reset status.
    
    - Add a new flag (SYSC_HAS_RESET_STATUS) to identify the new programming model
    and replace the previous SYSS_MISSING, that was used to flag IP with
    softreset control but without the SYSSTATUS register, with a specific
    SYSS_HAS_RESET_STATUS flag.
    
    - MCSPI and MMC contains both programming models, so the legacy one
    will be prevented by removing the syss offset field that become useless.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Rajendra Nayak <rnayak@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 8c279235ea87..5027879b062f 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -967,6 +967,12 @@ static int _read_hardreset(struct omap_hwmod *oh, const char *name)
  * enabled for this to work.  Returns -EINVAL if the hwmod cannot be
  * reset this way or if the hwmod is in the wrong state, -ETIMEDOUT if
  * the module did not reset in time, or 0 upon success.
+ *
+ * In OMAP3 a specific SYSSTATUS register is used to get the reset status.
+ * Starting in OMAP4, some IPs does not have SYSSTATUS register and instead
+ * use the SYSCONFIG softreset bit to provide the status.
+ *
+ * Note that some IP like McBSP does have a reset control but no reset status.
  */
 static int _reset(struct omap_hwmod *oh)
 {
@@ -974,8 +980,7 @@ static int _reset(struct omap_hwmod *oh)
 	int c = 0;
 
 	if (!oh->class->sysc ||
-	    !(oh->class->sysc->sysc_flags & SYSC_HAS_SOFTRESET) ||
-	    (oh->class->sysc->sysc_flags & SYSS_MISSING))
+	    !(oh->class->sysc->sysc_flags & SYSC_HAS_SOFTRESET))
 		return -EINVAL;
 
 	/* clocks must be on for this operation */
@@ -993,9 +998,16 @@ static int _reset(struct omap_hwmod *oh)
 		return r;
 	_write_sysconfig(v, oh);
 
-	omap_test_timeout((omap_hwmod_readl(oh, oh->class->sysc->syss_offs) &
-			   SYSS_RESETDONE_MASK),
-			  MAX_MODULE_SOFTRESET_WAIT, c);
+	if (oh->class->sysc->sysc_flags & SYSS_HAS_RESET_STATUS)
+		omap_test_timeout((omap_hwmod_readl(oh,
+						    oh->class->sysc->syss_offs)
+				   & SYSS_RESETDONE_MASK),
+				  MAX_MODULE_SOFTRESET_WAIT, c);
+	else if (oh->class->sysc->sysc_flags & SYSC_HAS_RESET_STATUS)
+		omap_test_timeout(!(omap_hwmod_readl(oh,
+						     oh->class->sysc->sysc_offs)
+				   & SYSC_TYPE2_SOFTRESET_MASK),
+				  MAX_MODULE_SOFTRESET_WAIT, c);
 
 	if (c == MAX_MODULE_SOFTRESET_WAIT)
 		pr_warning("omap_hwmod: %s: softreset failed (waited %d usec)\n",

commit aee48e3c9cee3698d17b4cf4203551de0a804760
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Sep 21 10:34:11 2010 -0600

    OMAP: hwmod: add an hardreset API for use by other core code
    
    Expose an hardreset API from hwmod in order to assert / deassert all the
    individual reset lines that belong to an hwmod.  This API is needed by
    some of the more complicated processor drivers, e.g., DSP/Bridge,
    Syslink, etc.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 3e90984faca0..8c279235ea87 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1828,6 +1828,84 @@ int omap_hwmod_disable_wakeup(struct omap_hwmod *oh)
 	return 0;
 }
 
+/**
+ * omap_hwmod_assert_hardreset - assert the HW reset line of submodules
+ * contained in the hwmod module.
+ * @oh: struct omap_hwmod *
+ * @name: name of the reset line to lookup and assert
+ *
+ * Some IP like dsp, ipu or iva contain processor that require
+ * an HW reset line to be assert / deassert in order to enable fully
+ * the IP.  Returns -EINVAL if @oh is null or if the operation is not
+ * yet supported on this OMAP; otherwise, passes along the return value
+ * from _assert_hardreset().
+ */
+int omap_hwmod_assert_hardreset(struct omap_hwmod *oh, const char *name)
+{
+	int ret;
+
+	if (!oh)
+		return -EINVAL;
+
+	mutex_lock(&oh->_mutex);
+	ret = _assert_hardreset(oh, name);
+	mutex_unlock(&oh->_mutex);
+
+	return ret;
+}
+
+/**
+ * omap_hwmod_deassert_hardreset - deassert the HW reset line of submodules
+ * contained in the hwmod module.
+ * @oh: struct omap_hwmod *
+ * @name: name of the reset line to look up and deassert
+ *
+ * Some IP like dsp, ipu or iva contain processor that require
+ * an HW reset line to be assert / deassert in order to enable fully
+ * the IP.  Returns -EINVAL if @oh is null or if the operation is not
+ * yet supported on this OMAP; otherwise, passes along the return value
+ * from _deassert_hardreset().
+ */
+int omap_hwmod_deassert_hardreset(struct omap_hwmod *oh, const char *name)
+{
+	int ret;
+
+	if (!oh)
+		return -EINVAL;
+
+	mutex_lock(&oh->_mutex);
+	ret = _deassert_hardreset(oh, name);
+	mutex_unlock(&oh->_mutex);
+
+	return ret;
+}
+
+/**
+ * omap_hwmod_read_hardreset - read the HW reset line state of submodules
+ * contained in the hwmod module
+ * @oh: struct omap_hwmod *
+ * @name: name of the reset line to look up and read
+ *
+ * Return the current state of the hwmod @oh's reset line named @name:
+ * returns -EINVAL upon parameter error or if this operation
+ * is unsupported on the current OMAP; otherwise, passes along the return
+ * value from _read_hardreset().
+ */
+int omap_hwmod_read_hardreset(struct omap_hwmod *oh, const char *name)
+{
+	int ret;
+
+	if (!oh)
+		return -EINVAL;
+
+	mutex_lock(&oh->_mutex);
+	ret = _read_hardreset(oh, name);
+	mutex_unlock(&oh->_mutex);
+
+	return ret;
+}
+
+
 /**
  * omap_hwmod_for_each_by_class - call @fn for each hwmod of class @classname
  * @classname: struct omap_hwmod_class name to search for

commit 76e5589e5b7cd0fd589264ab193f10550e1d8ab6
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Tue Sep 21 10:34:11 2010 -0600

    OMAP: hwmod: Force a softreset during _setup
    
    Force the softreset of every IPs during the _setup phase.
    IPs that cannot support softreset or that should not
    be reset must set the HWMOD_INIT_NO_RESET flag in the
    hwmod struct.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index f4a569c74700..3e90984faca0 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -980,8 +980,8 @@ static int _reset(struct omap_hwmod *oh)
 
 	/* clocks must be on for this operation */
 	if (oh->_state != _HWMOD_STATE_ENABLED) {
-		WARN(1, "omap_hwmod: %s: reset can only be entered from "
-		     "enabled state\n", oh->name);
+		pr_warning("omap_hwmod: %s: reset can only be entered from "
+			   "enabled state\n", oh->name);
 		return -EINVAL;
 	}
 
@@ -998,8 +998,8 @@ static int _reset(struct omap_hwmod *oh)
 			  MAX_MODULE_SOFTRESET_WAIT, c);
 
 	if (c == MAX_MODULE_SOFTRESET_WAIT)
-		WARN(1, "omap_hwmod: %s: softreset failed (waited %d usec)\n",
-		     oh->name, MAX_MODULE_SOFTRESET_WAIT);
+		pr_warning("omap_hwmod: %s: softreset failed (waited %d usec)\n",
+			   oh->name, MAX_MODULE_SOFTRESET_WAIT);
 	else
 		pr_debug("omap_hwmod: %s: softreset in %d usec\n", oh->name, c);
 
@@ -1198,12 +1198,12 @@ static int _setup(struct omap_hwmod *oh, void *data)
 	}
 
 	if (!(oh->flags & HWMOD_INIT_NO_RESET)) {
+		_reset(oh);
+
 		/*
-		 * XXX Do the OCP_SYSCONFIG bits need to be
-		 * reprogrammed after a reset?  If not, then this can
-		 * be removed.  If they do, then probably the
-		 * _omap_hwmod_enable() function should be split to avoid the
-		 * rewrite of the OCP_SYSCONFIG register.
+		 * OCP_SYSCONFIG bits need to be reprogrammed after a softreset.
+		 * The _omap_hwmod_enable() function should be split to
+		 * avoid the rewrite of the OCP_SYSCONFIG register.
 		 */
 		if (oh->class->sysc) {
 			_update_sysc_cache(oh);

commit 5365efbe29250a227502256cc912351fe2157b42
Author: Benot Cousson <b-cousson@ti.com>
Date:   Tue Sep 21 10:34:11 2010 -0600

    OMAP: hwmod: Add hardreset management support
    
    Most processor IPs does have a hardreset signal controlled by the PRM.
    This is different of the softreset used for local IP reset from the
    SYSCONFIG register.
    The granularity can be much finer than orginal HWMOD, for ex, the IVA
    hwmod contains 3 reset lines, the IPU 3 as well, the DSP 2...
    Since this granularity is needed by the driver, we have to ensure
    than one hwmod exist for each hardreset line.
    
    - Store reset lines as hwmod resources that a driver can query by name like
      an irq or sdma line.
    
    - Add two functions for asserting / deasserting reset lines in hwmods
      processor that require manual reset control.
    - Add one functions to get the current reset state.
    - If an hwmod contains only one line, an automatic assertion / de-assertion
      is done.
      -> de-assert the hardreset line only during enable from disable transition
      -> assert the hardreset line only during shutdown
    
    Note: The hwmods with hardreset line and HWMOD_INIT_NO_RESET flag must be
    kept in INITIALIZED state.
    They can be properly enabled only if the hardreset line is de-asserted
    before.
    
    For information here is the list of IPs with HW reset control
    on an OMAP4430 device:
    
    RM_DSP_RSTCTRL
      1,1,'RST2','RW','1','DSP - MMU, cache and slave interface reset control'
      0,0,'RST1','RW','1','DSP - DSP reset control'
    
    RM_IVA_RSTCTRL
      2,2,'RST3','RW','1','IVA logic and SL2 reset control'
      1,1,'RST2','RW','1','IVA Sequencer2 reset control'
      0,0,'RST1','RW','1','IVA sequencer1 reset control'
    
    RM_IPU_RSTCTRL
      2,2,'RST3','RW','1','IPU MMU and CACHE interface reset control.'
      1,1,'RST2','RW','1','IPU Cortex M3 CPU2  reset control.'
      0,0,'RST1','RW','1','IPU Cortex M3 CPU1  reset control.'
    
    PRM_RSTCTRL
      1,1,'RST_GLOBAL_COLD_SW','RW','0','Global COLD software reset control.'
      0,0,'RST_GLOBAL_WARM_SW','RW','0','Global WARM software reset control.'
    
    RM_CPU0_CPU0_RSTCTRL
    RM_CPU1_CPU1_RSTCTRL
      0,0,'RST','RW','0','Cortex A9 CPU0&1 warm local reset control'
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    [paul@pwsan.com: made the hardreset functions static; moved the register
     twiddling into prm*.c functions in previous patches; changed the
     function names to conform with hwmod practice]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Rajendra Nayak <rnayak@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 3084409ad1dc..f4a569c74700 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -50,11 +50,13 @@
 #include <plat/powerdomain.h>
 #include <plat/clock.h>
 #include <plat/omap_hwmod.h>
+#include <plat/prcm.h>
 
 #include "cm.h"
+#include "prm.h"
 
-/* Maximum microseconds to wait for OMAP module to reset */
-#define MAX_MODULE_RESET_WAIT		10000
+/* Maximum microseconds to wait for OMAP module to softreset */
+#define MAX_MODULE_SOFTRESET_WAIT	10000
 
 /* Name of the OMAP hwmod for the MPU */
 #define MPU_INITIATOR_NAME		"mpu"
@@ -833,6 +835,130 @@ static int _wait_target_ready(struct omap_hwmod *oh)
 	return ret;
 }
 
+/**
+ * _lookup_hardreset - return the register bit shift for this hwmod/reset line
+ * @oh: struct omap_hwmod *
+ * @name: name of the reset line in the context of this hwmod
+ *
+ * Return the bit position of the reset line that match the
+ * input name. Return -ENOENT if not found.
+ */
+static u8 _lookup_hardreset(struct omap_hwmod *oh, const char *name)
+{
+	int i;
+
+	for (i = 0; i < oh->rst_lines_cnt; i++) {
+		const char *rst_line = oh->rst_lines[i].name;
+		if (!strcmp(rst_line, name)) {
+			u8 shift = oh->rst_lines[i].rst_shift;
+			pr_debug("omap_hwmod: %s: _lookup_hardreset: %s: %d\n",
+				 oh->name, rst_line, shift);
+
+			return shift;
+		}
+	}
+
+	return -ENOENT;
+}
+
+/**
+ * _assert_hardreset - assert the HW reset line of submodules
+ * contained in the hwmod module.
+ * @oh: struct omap_hwmod *
+ * @name: name of the reset line to lookup and assert
+ *
+ * Some IP like dsp, ipu or iva contain processor that require
+ * an HW reset line to be assert / deassert in order to enable fully
+ * the IP.
+ */
+static int _assert_hardreset(struct omap_hwmod *oh, const char *name)
+{
+	u8 shift;
+
+	if (!oh)
+		return -EINVAL;
+
+	shift = _lookup_hardreset(oh, name);
+	if (IS_ERR_VALUE(shift))
+		return shift;
+
+	if (cpu_is_omap24xx() || cpu_is_omap34xx())
+		return omap2_prm_assert_hardreset(oh->prcm.omap2.module_offs,
+						  shift);
+	else if (cpu_is_omap44xx())
+		return omap4_prm_assert_hardreset(oh->prcm.omap4.rstctrl_reg,
+						  shift);
+	else
+		return -EINVAL;
+}
+
+/**
+ * _deassert_hardreset - deassert the HW reset line of submodules contained
+ * in the hwmod module.
+ * @oh: struct omap_hwmod *
+ * @name: name of the reset line to look up and deassert
+ *
+ * Some IP like dsp, ipu or iva contain processor that require
+ * an HW reset line to be assert / deassert in order to enable fully
+ * the IP.
+ */
+static int _deassert_hardreset(struct omap_hwmod *oh, const char *name)
+{
+	u8 shift;
+	int r;
+
+	if (!oh)
+		return -EINVAL;
+
+	shift = _lookup_hardreset(oh, name);
+	if (IS_ERR_VALUE(shift))
+		return shift;
+
+	if (cpu_is_omap24xx() || cpu_is_omap34xx())
+		r = omap2_prm_deassert_hardreset(oh->prcm.omap2.module_offs,
+						 shift);
+	else if (cpu_is_omap44xx())
+		r = omap4_prm_deassert_hardreset(oh->prcm.omap4.rstctrl_reg,
+						 shift);
+	else
+		return -EINVAL;
+
+	if (r == -EBUSY)
+		pr_warning("omap_hwmod: %s: failed to hardreset\n", oh->name);
+
+	return r;
+}
+
+/**
+ * _read_hardreset - read the HW reset line state of submodules
+ * contained in the hwmod module
+ * @oh: struct omap_hwmod *
+ * @name: name of the reset line to look up and read
+ *
+ * Return the state of the reset line.
+ */
+static int _read_hardreset(struct omap_hwmod *oh, const char *name)
+{
+	u8 shift;
+
+	if (!oh)
+		return -EINVAL;
+
+	shift = _lookup_hardreset(oh, name);
+	if (IS_ERR_VALUE(shift))
+		return shift;
+
+	if (cpu_is_omap24xx() || cpu_is_omap34xx()) {
+		return omap2_prm_is_hardreset_asserted(oh->prcm.omap2.module_offs,
+						       shift);
+	} else if (cpu_is_omap44xx()) {
+		return omap4_prm_is_hardreset_asserted(oh->prcm.omap4.rstctrl_reg,
+						       shift);
+	} else {
+		return -EINVAL;
+	}
+}
+
 /**
  * _reset - reset an omap_hwmod
  * @oh: struct omap_hwmod *
@@ -869,20 +995,20 @@ static int _reset(struct omap_hwmod *oh)
 
 	omap_test_timeout((omap_hwmod_readl(oh, oh->class->sysc->syss_offs) &
 			   SYSS_RESETDONE_MASK),
-			  MAX_MODULE_RESET_WAIT, c);
+			  MAX_MODULE_SOFTRESET_WAIT, c);
 
-	if (c == MAX_MODULE_RESET_WAIT)
-		WARN(1, "omap_hwmod: %s: failed to reset in %d usec\n",
-		     oh->name, MAX_MODULE_RESET_WAIT);
+	if (c == MAX_MODULE_SOFTRESET_WAIT)
+		WARN(1, "omap_hwmod: %s: softreset failed (waited %d usec)\n",
+		     oh->name, MAX_MODULE_SOFTRESET_WAIT);
 	else
-		pr_debug("omap_hwmod: %s: reset in %d usec\n", oh->name, c);
+		pr_debug("omap_hwmod: %s: softreset in %d usec\n", oh->name, c);
 
 	/*
 	 * XXX add _HWMOD_STATE_WEDGED for modules that don't come back from
 	 * _wait_target_ready() or _reset()
 	 */
 
-	return (c == MAX_MODULE_RESET_WAIT) ? -ETIMEDOUT : 0;
+	return (c == MAX_MODULE_SOFTRESET_WAIT) ? -ETIMEDOUT : 0;
 }
 
 /**
@@ -907,6 +1033,15 @@ int _omap_hwmod_enable(struct omap_hwmod *oh)
 
 	pr_debug("omap_hwmod: %s: enabling\n", oh->name);
 
+	/*
+	 * If an IP contains only one HW reset line, then de-assert it in order
+	 * to allow to enable the clocks. Otherwise the PRCM will return
+	 * Intransition status, and the init will failed.
+	 */
+	if ((oh->_state == _HWMOD_STATE_INITIALIZED ||
+	     oh->_state == _HWMOD_STATE_DISABLED) && oh->rst_lines_cnt == 1)
+		_deassert_hardreset(oh, oh->rst_lines[0].name);
+
 	/* XXX mux balls */
 
 	_add_initiator_dep(oh, mpu_oh);
@@ -981,6 +1116,13 @@ static int _shutdown(struct omap_hwmod *oh)
 	if (oh->class->sysc)
 		_sysc_shutdown(oh);
 
+	/*
+	 * If an IP contains only one HW reset line, then assert it
+	 * before disabling the clocks and shutting down the IP.
+	 */
+	if (oh->rst_lines_cnt == 1)
+		_assert_hardreset(oh, oh->rst_lines[0].name);
+
 	/* clocks and deps are already disabled in idle */
 	if (oh->_state == _HWMOD_STATE_ENABLED) {
 		_del_initiator_dep(oh, mpu_oh);
@@ -1038,6 +1180,16 @@ static int _setup(struct omap_hwmod *oh, void *data)
 	mutex_init(&oh->_mutex);
 	oh->_state = _HWMOD_STATE_INITIALIZED;
 
+	/*
+	 * In the case of hwmod with hardreset that should not be
+	 * de-assert at boot time, we have to keep the module
+	 * initialized, because we cannot enable it properly with the
+	 * reset asserted. Exit without warning because that behavior is
+	 * expected.
+	 */
+	if ((oh->flags & HWMOD_INIT_NO_RESET) && oh->rst_lines_cnt == 1)
+		return 0;
+
 	r = _omap_hwmod_enable(oh);
 	if (r) {
 		pr_warning("omap_hwmod: %s: cannot be enabled (%d)\n",

commit 12b1fdb45c2594070bb36e39cd89a33547aad8fb
Author: Kevin Hilman <khilman@ti.com>
Date:   Tue Sep 21 10:34:09 2010 -0600

    OMAP: hwmod: separate list locking and hwmod hardware locking
    
    Currently omap_hwmod_mutex is being used to protect both the list
    access/modification and concurrent access to hwmod functions.  This
    patch separates these two types of locking.
    
    First, omap_hwmod_mutex is used only to protect access and
    modification of omap_hwmod_list.  Also cleaned up some comments
    referring to this mutex that are no longer needed.
    
    Then, for protecting concurrent access to hwmod functions, use a
    per-hwmod mutex.  This protects concurrent access to a single hwmod,
    but would allow concurrent access to different hwmods.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    [paul@pwsan.com: added structure documentation; changed mutex variable
     name]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 100115ff1d96..3084409ad1dc 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -767,10 +767,10 @@ static struct omap_hwmod *_lookup(const char *name)
  * @data: not used; pass NULL
  *
  * Called by omap_hwmod_late_init() (after omap2_clk_init()).
- * Resolves all clock names embedded in the hwmod.  Must be called
- * with omap_hwmod_mutex held.  Returns -EINVAL if the omap_hwmod
- * has not yet been registered or if the clocks have already been
- * initialized, 0 on success, or a non-zero error on failure.
+ * Resolves all clock names embedded in the hwmod.  Returns -EINVAL if
+ * the omap_hwmod has not yet been registered or if the clocks have
+ * already been initialized, 0 on success, or a non-zero error on
+ * failure.
  */
 static int _init_clocks(struct omap_hwmod *oh, void *data)
 {
@@ -838,10 +838,9 @@ static int _wait_target_ready(struct omap_hwmod *oh)
  * @oh: struct omap_hwmod *
  *
  * Resets an omap_hwmod @oh via the OCP_SYSCONFIG bit.  hwmod must be
- * enabled for this to work.  Must be called with omap_hwmod_mutex
- * held.  Returns -EINVAL if the hwmod cannot be reset this way or if
- * the hwmod is in the wrong state, -ETIMEDOUT if the module did not
- * reset in time, or 0 upon success.
+ * enabled for this to work.  Returns -EINVAL if the hwmod cannot be
+ * reset this way or if the hwmod is in the wrong state, -ETIMEDOUT if
+ * the module did not reset in time, or 0 upon success.
  */
 static int _reset(struct omap_hwmod *oh)
 {
@@ -891,9 +890,8 @@ static int _reset(struct omap_hwmod *oh)
  * @oh: struct omap_hwmod *
  *
  * Enables an omap_hwmod @oh such that the MPU can access the hwmod's
- * register target.  Must be called with omap_hwmod_mutex held.
- * Returns -EINVAL if the hwmod is in the wrong state or passes along
- * the return value of _wait_target_ready().
+ * register target.  Returns -EINVAL if the hwmod is in the wrong
+ * state or passes along the return value of _wait_target_ready().
  */
 int _omap_hwmod_enable(struct omap_hwmod *oh)
 {
@@ -1004,11 +1002,10 @@ static int _shutdown(struct omap_hwmod *oh)
  * @skip_setup_idle_p: do not idle hwmods at the end of the fn if 1
  *
  * Writes the CLOCKACTIVITY bits @clockact to the hwmod @oh
- * OCP_SYSCONFIG register.  Must be called with omap_hwmod_mutex held.
- * @skip_setup_idle is intended to be used on a system that will not
- * call omap_hwmod_enable() to enable devices (e.g., a system without
- * PM runtime).  Returns -EINVAL if the hwmod is in the wrong state or
- * returns 0.
+ * OCP_SYSCONFIG register.  @skip_setup_idle is intended to be used on
+ * a system that will not call omap_hwmod_enable() to enable devices
+ * (e.g., a system without PM runtime).  Returns -EINVAL if the hwmod
+ * is in the wrong state or returns 0.
  */
 static int _setup(struct omap_hwmod *oh, void *data)
 {
@@ -1038,6 +1035,7 @@ static int _setup(struct omap_hwmod *oh, void *data)
 		}
 	}
 
+	mutex_init(&oh->_mutex);
 	oh->_state = _HWMOD_STATE_INITIALIZED;
 
 	r = _omap_hwmod_enable(oh);
@@ -1323,9 +1321,9 @@ int omap_hwmod_enable(struct omap_hwmod *oh)
 	if (!oh)
 		return -EINVAL;
 
-	mutex_lock(&omap_hwmod_mutex);
+	mutex_lock(&oh->_mutex);
 	r = _omap_hwmod_enable(oh);
-	mutex_unlock(&omap_hwmod_mutex);
+	mutex_unlock(&oh->_mutex);
 
 	return r;
 }
@@ -1343,9 +1341,9 @@ int omap_hwmod_idle(struct omap_hwmod *oh)
 	if (!oh)
 		return -EINVAL;
 
-	mutex_lock(&omap_hwmod_mutex);
+	mutex_lock(&oh->_mutex);
 	_omap_hwmod_idle(oh);
-	mutex_unlock(&omap_hwmod_mutex);
+	mutex_unlock(&oh->_mutex);
 
 	return 0;
 }
@@ -1363,9 +1361,9 @@ int omap_hwmod_shutdown(struct omap_hwmod *oh)
 	if (!oh)
 		return -EINVAL;
 
-	mutex_lock(&omap_hwmod_mutex);
+	mutex_lock(&oh->_mutex);
 	_shutdown(oh);
-	mutex_unlock(&omap_hwmod_mutex);
+	mutex_unlock(&oh->_mutex);
 
 	return 0;
 }
@@ -1378,9 +1376,9 @@ int omap_hwmod_shutdown(struct omap_hwmod *oh)
  */
 int omap_hwmod_enable_clocks(struct omap_hwmod *oh)
 {
-	mutex_lock(&omap_hwmod_mutex);
+	mutex_lock(&oh->_mutex);
 	_enable_clocks(oh);
-	mutex_unlock(&omap_hwmod_mutex);
+	mutex_unlock(&oh->_mutex);
 
 	return 0;
 }
@@ -1393,9 +1391,9 @@ int omap_hwmod_enable_clocks(struct omap_hwmod *oh)
  */
 int omap_hwmod_disable_clocks(struct omap_hwmod *oh)
 {
-	mutex_lock(&omap_hwmod_mutex);
+	mutex_lock(&oh->_mutex);
 	_disable_clocks(oh);
-	mutex_unlock(&omap_hwmod_mutex);
+	mutex_unlock(&oh->_mutex);
 
 	return 0;
 }
@@ -1443,9 +1441,9 @@ int omap_hwmod_reset(struct omap_hwmod *oh)
 	if (!oh)
 		return -EINVAL;
 
-	mutex_lock(&omap_hwmod_mutex);
+	mutex_lock(&oh->_mutex);
 	r = _reset(oh);
-	mutex_unlock(&omap_hwmod_mutex);
+	mutex_unlock(&oh->_mutex);
 
 	return r;
 }
@@ -1646,9 +1644,9 @@ int omap_hwmod_enable_wakeup(struct omap_hwmod *oh)
 	    !(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP))
 		return -EINVAL;
 
-	mutex_lock(&omap_hwmod_mutex);
+	mutex_lock(&oh->_mutex);
 	_enable_wakeup(oh);
-	mutex_unlock(&omap_hwmod_mutex);
+	mutex_unlock(&oh->_mutex);
 
 	return 0;
 }
@@ -1671,9 +1669,9 @@ int omap_hwmod_disable_wakeup(struct omap_hwmod *oh)
 	    !(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP))
 		return -EINVAL;
 
-	mutex_lock(&omap_hwmod_mutex);
+	mutex_lock(&oh->_mutex);
 	_disable_wakeup(oh);
-	mutex_unlock(&omap_hwmod_mutex);
+	mutex_unlock(&oh->_mutex);
 
 	return 0;
 }

commit 9b579114efc4bd00532de33c783b4cb4638910ff
Author: Liam Girdwood <lrg@slimlogic.co.uk>
Date:   Tue Sep 21 10:34:09 2010 -0600

    OMAP: hwmod: Fix omap_hwmod_reset wrong state test
    
    The reset function wrongly used the state flag as a bit mask and was trying
    to re-enable after a reset.
    
    hwmod is still enabled for the PRCM point of view after a softreset
    so there is no need to re-enable.
    
    Remove the state check from omap_hwmod_reset since the _reset
    function is checking that as well and in addition can generate
    a warning
    
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>
    [b-cousson@ti.com: remove the wrong test, remove the re-enable]
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Rajendra Nayak <rnayak@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 5bb25e319b76..100115ff1d96 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1434,19 +1434,17 @@ void omap_hwmod_ocp_barrier(struct omap_hwmod *oh)
  *
  * Under some conditions, a driver may wish to reset the entire device.
  * Called from omap_device code.  Returns -EINVAL on error or passes along
- * the return value from _reset()/_enable().
+ * the return value from _reset().
  */
 int omap_hwmod_reset(struct omap_hwmod *oh)
 {
 	int r;
 
-	if (!oh || !(oh->_state & _HWMOD_STATE_ENABLED))
+	if (!oh)
 		return -EINVAL;
 
 	mutex_lock(&omap_hwmod_mutex);
 	r = _reset(oh);
-	if (!r)
-		r = _omap_hwmod_enable(oh);
 	mutex_unlock(&omap_hwmod_mutex);
 
 	return r;

commit 3827f9492bdff045ae57fe67e65ce7e259ed4219
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Tue Sep 21 10:34:08 2010 -0600

    OMAP: hwmod: Do not disable clocks if hwmod already in idle
    
    The disable function was disabling clocks and dependencies
    from both enable and idle state. Since idle function is already
    disabling both, an enable -> idle -> disable sequence will
    try to disable twice the clocks and thus generate a
    "Trying disable clock XXX with 0 usecount" warning.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 8bf19a7efb5c..5bb25e319b76 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -982,9 +982,13 @@ static int _shutdown(struct omap_hwmod *oh)
 
 	if (oh->class->sysc)
 		_sysc_shutdown(oh);
-	_del_initiator_dep(oh, mpu_oh);
-	/* XXX what about the other system initiators here? DMA, tesla, d2d */
-	_disable_clocks(oh);
+
+	/* clocks and deps are already disabled in idle */
+	if (oh->_state == _HWMOD_STATE_ENABLED) {
+		_del_initiator_dep(oh, mpu_oh);
+		/* XXX what about the other system initiators here? dma, dsp */
+		_disable_clocks(oh);
+	}
 	/* XXX Should this code also force-disable the optional clocks? */
 
 	/* XXX mux any associated balls to safe mode */

commit 9ee9fff92e02e8c5f84794b3a5ce47646c2dfc39
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Tue Sep 21 10:34:08 2010 -0600

    OMAP: hwmod: Rename dma_ch to dma_req
    
    The dma request line attribute was named dma channel, which leads
    to confusion with the real dma channel definition.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index cb911d7d1a3c..8bf19a7efb5c 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1468,7 +1468,7 @@ int omap_hwmod_count_resources(struct omap_hwmod *oh)
 {
 	int ret, i;
 
-	ret = oh->mpu_irqs_cnt + oh->sdma_chs_cnt;
+	ret = oh->mpu_irqs_cnt + oh->sdma_reqs_cnt;
 
 	for (i = 0; i < oh->slaves_cnt; i++)
 		ret += oh->slaves[i]->addr_cnt;
@@ -1501,10 +1501,10 @@ int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 		r++;
 	}
 
-	for (i = 0; i < oh->sdma_chs_cnt; i++) {
-		(res + r)->name = (oh->sdma_chs + i)->name;
-		(res + r)->start = (oh->sdma_chs + i)->dma_ch;
-		(res + r)->end = (oh->sdma_chs + i)->dma_ch;
+	for (i = 0; i < oh->sdma_reqs_cnt; i++) {
+		(res + r)->name = (oh->sdma_reqs + i)->name;
+		(res + r)->start = (oh->sdma_reqs + i)->dma_req;
+		(res + r)->end = (oh->sdma_reqs + i)->dma_req;
 		(res + r)->flags = IORESOURCE_DMA;
 		r++;
 	}

commit 887adeac28a3e354ebb3f9aeca6fc2296c105267
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Jul 26 16:34:33 2010 -0600

    OMAP2+: hwmod/device: update documentation and copyright
    
    Update some minor documentation issues and update copyright for
    omap_device/omap_hwmod code.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index ec0be6d32232..cb911d7d1a3c 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -423,7 +423,7 @@ static int _init_main_clk(struct omap_hwmod *oh)
 }
 
 /**
- * _init_interface_clk - get a struct clk * for the the hwmod's interface clks
+ * _init_interface_clks - get a struct clk * for the the hwmod's interface clks
  * @oh: struct omap_hwmod *
  *
  * Called from _init_clocks().  Populates the @oh OCP slave interface
@@ -1077,6 +1077,21 @@ void omap_hwmod_writel(u32 v, struct omap_hwmod *oh, u16 reg_offs)
 	__raw_writel(v, oh->_mpu_rt_va + reg_offs);
 }
 
+/**
+ * omap_hwmod_set_slave_idlemode - set the hwmod's OCP slave idlemode
+ * @oh: struct omap_hwmod *
+ * @idlemode: SIDLEMODE field bits (shifted to bit 0)
+ *
+ * Sets the IP block's OCP slave idlemode in hardware, and updates our
+ * local copy.  Intended to be used by drivers that have some erratum
+ * that requires direct manipulation of the SIDLEMODE bits.  Returns
+ * -EINVAL if @oh is null, or passes along the return value from
+ * _set_slave_idlemode().
+ *
+ * XXX Does this function have any current users?  If not, we should
+ * remove it; it is better to let the rest of the hwmod code handle this.
+ * Any users of this function should be scrutinized carefully.
+ */
 int omap_hwmod_set_slave_idlemode(struct omap_hwmod *oh, u8 idlemode)
 {
 	u32 v;

commit db2a60bf2527209b42e6f512d5892089a835ceaa
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Jul 26 16:34:33 2010 -0600

    OMAP: hwmod/device: add omap_{device,hwmod}_get_mpu_rt_va
    
    Add omap_device_get_mpu_rt_va().  This is intended to be used by
    device drivers (currently, via a struct platform_data function
    pointer) to retrieve their corresponding device's virtual base address
    that the MPU should use to access the device.  This is needed because
    the omap_hwmod code does its own ioremap(), in order to gain access to
    the module's OCP_SYSCONFIG register.
    
    Add omap_hwmod_get_mpu_rt_va().  omap_device_get_mpu_rt_va() calls this
    function to do the real work.
    
    While here, rename struct omap_hwmod._rt_va to struct
    omap_hwmod._mpu_rt_va, to reinforce that it refers to the MPU's
    register target virtual address base (as opposed to, for example, the
    L3's).
    
    In the future, this belongs as a function in an omap_bus, so it is not
    necessary to call this through a platform_data function pointer.
    
    The use-case for this function was originally presented by Santosh
    Shilimkar <santosh.shilimkar@ti.com>.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index b2c8e8760c80..ec0be6d32232 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1,7 +1,7 @@
 /*
  * omap_hwmod implementation for OMAP2/3/4
  *
- * Copyright (C) 2009 Nokia Corporation
+ * Copyright (C) 2009-2010 Nokia Corporation
  *
  * Paul Walmsley, Benot Cousson, Kevin Hilman
  *
@@ -1069,12 +1069,12 @@ static int _setup(struct omap_hwmod *oh, void *data)
 
 u32 omap_hwmod_readl(struct omap_hwmod *oh, u16 reg_offs)
 {
-	return __raw_readl(oh->_rt_va + reg_offs);
+	return __raw_readl(oh->_mpu_rt_va + reg_offs);
 }
 
 void omap_hwmod_writel(u32 v, struct omap_hwmod *oh, u16 reg_offs)
 {
-	__raw_writel(v, oh->_rt_va + reg_offs);
+	__raw_writel(v, oh->_mpu_rt_va + reg_offs);
 }
 
 int omap_hwmod_set_slave_idlemode(struct omap_hwmod *oh, u8 idlemode)
@@ -1131,7 +1131,7 @@ int omap_hwmod_register(struct omap_hwmod *oh)
 	ms_id = _find_mpu_port_index(oh);
 	if (!IS_ERR_VALUE(ms_id)) {
 		oh->_mpu_port_index = ms_id;
-		oh->_rt_va = _find_mpu_rt_base(oh, oh->_mpu_port_index);
+		oh->_mpu_rt_va = _find_mpu_rt_base(oh, oh->_mpu_port_index);
 	} else {
 		oh->_int_flags |= _HWMOD_NO_MPU_PORT;
 	}
@@ -1283,7 +1283,7 @@ int omap_hwmod_unregister(struct omap_hwmod *oh)
 	pr_debug("omap_hwmod: %s: unregistering\n", oh->name);
 
 	mutex_lock(&omap_hwmod_mutex);
-	iounmap(oh->_rt_va);
+	iounmap(oh->_mpu_rt_va);
 	list_del(&oh->node);
 	mutex_unlock(&omap_hwmod_mutex);
 
@@ -1543,6 +1543,29 @@ struct powerdomain *omap_hwmod_get_pwrdm(struct omap_hwmod *oh)
 
 }
 
+/**
+ * omap_hwmod_get_mpu_rt_va - return the module's base address (for the MPU)
+ * @oh: struct omap_hwmod *
+ *
+ * Returns the virtual address corresponding to the beginning of the
+ * module's register target, in the address range that is intended to
+ * be used by the MPU.  Returns the virtual address upon success or NULL
+ * upon error.
+ */
+void __iomem *omap_hwmod_get_mpu_rt_va(struct omap_hwmod *oh)
+{
+	if (!oh)
+		return NULL;
+
+	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
+		return NULL;
+
+	if (oh->_state == _HWMOD_STATE_UNKNOWN)
+		return NULL;
+
+	return oh->_mpu_rt_va;
+}
+
 /**
  * omap_hwmod_add_initiator_dep - add sleepdep from @init_oh to @oh
  * @oh: struct omap_hwmod *

commit 97d60162f64ef068b639d8a77ef3bc148baa53ad
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Jul 26 16:34:30 2010 -0600

    OMAP: hwmod: allow omap_hwmod_late_init() caller to skip module idle in _setup()
    
    On kernels that don't use the omap_device_enable() calls to enable
    devices, leave all on-chip devices enabled in hwmod _setup().
    Otherwise, accesses to those devices are likely to fail, crashing the
    system.  It's expected that kernels built without CONFIG_PM_RUNTIME
    will be the primary use-case for this.  This functionality is
    controlled by adding an extra parameter to omap_hwmod_late_init().
    
    This patch is based on the patch "OMAP: hwmod: don't auto-disable
    hwmod when !CONFIG_PM_RUNTIME" by Kevin Hilman
    <khilman@deeprootsystems.com>.
    
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index a23a60ad4059..b2c8e8760c80 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -764,6 +764,7 @@ static struct omap_hwmod *_lookup(const char *name)
 /**
  * _init_clocks - clk_get() all clocks associated with this hwmod
  * @oh: struct omap_hwmod *
+ * @data: not used; pass NULL
  *
  * Called by omap_hwmod_late_init() (after omap2_clk_init()).
  * Resolves all clock names embedded in the hwmod.  Must be called
@@ -771,7 +772,7 @@ static struct omap_hwmod *_lookup(const char *name)
  * has not yet been registered or if the clocks have already been
  * initialized, 0 on success, or a non-zero error on failure.
  */
-static int _init_clocks(struct omap_hwmod *oh)
+static int _init_clocks(struct omap_hwmod *oh, void *data)
 {
 	int ret = 0;
 
@@ -996,19 +997,25 @@ static int _shutdown(struct omap_hwmod *oh)
 /**
  * _setup - do initial configuration of omap_hwmod
  * @oh: struct omap_hwmod *
+ * @skip_setup_idle_p: do not idle hwmods at the end of the fn if 1
  *
  * Writes the CLOCKACTIVITY bits @clockact to the hwmod @oh
- * OCP_SYSCONFIG register.  Must be called with omap_hwmod_mutex
- * held.  Returns -EINVAL if the hwmod is in the wrong state or returns
- * 0.
+ * OCP_SYSCONFIG register.  Must be called with omap_hwmod_mutex held.
+ * @skip_setup_idle is intended to be used on a system that will not
+ * call omap_hwmod_enable() to enable devices (e.g., a system without
+ * PM runtime).  Returns -EINVAL if the hwmod is in the wrong state or
+ * returns 0.
  */
-static int _setup(struct omap_hwmod *oh)
+static int _setup(struct omap_hwmod *oh, void *data)
 {
 	int i, r;
+	u8 skip_setup_idle;
 
-	if (!oh)
+	if (!oh || !data)
 		return -EINVAL;
 
+	skip_setup_idle = *(u8 *)data;
+
 	/* Set iclk autoidle mode */
 	if (oh->slaves_cnt > 0) {
 		for (i = 0; i < oh->slaves_cnt; i++) {
@@ -1050,7 +1057,7 @@ static int _setup(struct omap_hwmod *oh)
 		}
 	}
 
-	if (!(oh->flags & HWMOD_INIT_NO_IDLE))
+	if (!(oh->flags & HWMOD_INIT_NO_IDLE) && !skip_setup_idle)
 		_omap_hwmod_idle(oh);
 
 	return 0;
@@ -1164,6 +1171,7 @@ struct omap_hwmod *omap_hwmod_lookup(const char *name)
 /**
  * omap_hwmod_for_each - call function for each registered omap_hwmod
  * @fn: pointer to a callback function
+ * @data: void * data to pass to callback function
  *
  * Call @fn for each registered omap_hwmod, passing @data to each
  * function.  @fn must return 0 for success or any other value for
@@ -1172,7 +1180,8 @@ struct omap_hwmod *omap_hwmod_lookup(const char *name)
  * caller of omap_hwmod_for_each().  @fn is called with
  * omap_hwmod_for_each() held.
  */
-int omap_hwmod_for_each(int (*fn)(struct omap_hwmod *oh))
+int omap_hwmod_for_each(int (*fn)(struct omap_hwmod *oh, void *data),
+			void *data)
 {
 	struct omap_hwmod *temp_oh;
 	int ret;
@@ -1182,7 +1191,7 @@ int omap_hwmod_for_each(int (*fn)(struct omap_hwmod *oh))
 
 	mutex_lock(&omap_hwmod_mutex);
 	list_for_each_entry(temp_oh, &omap_hwmod_list, node) {
-		ret = (*fn)(temp_oh);
+		ret = (*fn)(temp_oh, data);
 		if (ret)
 			break;
 	}
@@ -1229,24 +1238,28 @@ int omap_hwmod_init(struct omap_hwmod **ohs)
 
 /**
  * omap_hwmod_late_init - do some post-clock framework initialization
+ * @skip_setup_idle: if 1, do not idle hwmods in _setup()
  *
  * Must be called after omap2_clk_init().  Resolves the struct clk names
  * to struct clk pointers for each registered omap_hwmod.  Also calls
  * _setup() on each hwmod.  Returns 0.
  */
-int omap_hwmod_late_init(void)
+int omap_hwmod_late_init(u8 skip_setup_idle)
 {
 	int r;
 
 	/* XXX check return value */
-	r = omap_hwmod_for_each(_init_clocks);
+	r = omap_hwmod_for_each(_init_clocks, NULL);
 	WARN(r, "omap_hwmod: omap_hwmod_late_init(): _init_clocks failed\n");
 
 	mpu_oh = omap_hwmod_lookup(MPU_INITIATOR_NAME);
 	WARN(!mpu_oh, "omap_hwmod: could not find MPU initiator hwmod %s\n",
 	     MPU_INITIATOR_NAME);
 
-	omap_hwmod_for_each(_setup);
+	if (skip_setup_idle)
+		pr_debug("omap_hwmod: will leave hwmods enabled during setup\n");
+
+	omap_hwmod_for_each(_setup, &skip_setup_idle);
 
 	return 0;
 }

commit 848240223c35fcc71c424ad51a8e8aef42d3879c
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Mon Jul 26 16:34:29 2010 -0600

    OMAP: hwmod: add non-locking versions of enable and idle functions
    
    Some hwmods may need to be idled/enabled in atomic context, so
    non-locking versions of these functions are required.
    
    Most users should not need these and usage of theses should be
    controlled to understand why access is being done in atomic context.
    For this reason, the non-locking functions are only exposed at the
    hwmod level and not at the omap-device level.
    
    The use-case that led to the need for the non-locking versions is
    hwmods that are enabled/idled from within the core idle/suspend path.
    Since interrupts are already disabled here, the mutex-based locking in
    hwmod can sleep and will cause potential deadlocks.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index b7a4133267d8..a23a60ad4059 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -886,7 +886,7 @@ static int _reset(struct omap_hwmod *oh)
 }
 
 /**
- * _enable - enable an omap_hwmod
+ * _omap_hwmod_enable - enable an omap_hwmod
  * @oh: struct omap_hwmod *
  *
  * Enables an omap_hwmod @oh such that the MPU can access the hwmod's
@@ -894,7 +894,7 @@ static int _reset(struct omap_hwmod *oh)
  * Returns -EINVAL if the hwmod is in the wrong state or passes along
  * the return value of _wait_target_ready().
  */
-static int _enable(struct omap_hwmod *oh)
+int _omap_hwmod_enable(struct omap_hwmod *oh)
 {
 	int r;
 
@@ -939,7 +939,7 @@ static int _enable(struct omap_hwmod *oh)
  * no further work.  Returns -EINVAL if the hwmod is in the wrong
  * state or returns 0.
  */
-static int _idle(struct omap_hwmod *oh)
+int _omap_hwmod_idle(struct omap_hwmod *oh)
 {
 	if (oh->_state != _HWMOD_STATE_ENABLED) {
 		WARN(1, "omap_hwmod: %s: idle state can only be entered from "
@@ -1029,7 +1029,7 @@ static int _setup(struct omap_hwmod *oh)
 
 	oh->_state = _HWMOD_STATE_INITIALIZED;
 
-	r = _enable(oh);
+	r = _omap_hwmod_enable(oh);
 	if (r) {
 		pr_warning("omap_hwmod: %s: cannot be enabled (%d)\n",
 			   oh->name, oh->_state);
@@ -1041,7 +1041,7 @@ static int _setup(struct omap_hwmod *oh)
 		 * XXX Do the OCP_SYSCONFIG bits need to be
 		 * reprogrammed after a reset?  If not, then this can
 		 * be removed.  If they do, then probably the
-		 * _enable() function should be split to avoid the
+		 * _omap_hwmod_enable() function should be split to avoid the
 		 * rewrite of the OCP_SYSCONFIG register.
 		 */
 		if (oh->class->sysc) {
@@ -1051,7 +1051,7 @@ static int _setup(struct omap_hwmod *oh)
 	}
 
 	if (!(oh->flags & HWMOD_INIT_NO_IDLE))
-		_idle(oh);
+		_omap_hwmod_idle(oh);
 
 	return 0;
 }
@@ -1292,12 +1292,13 @@ int omap_hwmod_enable(struct omap_hwmod *oh)
 		return -EINVAL;
 
 	mutex_lock(&omap_hwmod_mutex);
-	r = _enable(oh);
+	r = _omap_hwmod_enable(oh);
 	mutex_unlock(&omap_hwmod_mutex);
 
 	return r;
 }
 
+
 /**
  * omap_hwmod_idle - idle an omap_hwmod
  * @oh: struct omap_hwmod *
@@ -1311,7 +1312,7 @@ int omap_hwmod_idle(struct omap_hwmod *oh)
 		return -EINVAL;
 
 	mutex_lock(&omap_hwmod_mutex);
-	_idle(oh);
+	_omap_hwmod_idle(oh);
 	mutex_unlock(&omap_hwmod_mutex);
 
 	return 0;
@@ -1413,7 +1414,7 @@ int omap_hwmod_reset(struct omap_hwmod *oh)
 	mutex_lock(&omap_hwmod_mutex);
 	r = _reset(oh);
 	if (!r)
-		r = _enable(oh);
+		r = _omap_hwmod_enable(oh);
 	mutex_unlock(&omap_hwmod_mutex);
 
 	return r;

commit dc75925d67950889b79df1cc1518c21ec678df6c
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Wed Jun 23 18:15:12 2010 -0600

    OMAP: hwmod: Fix the missing braces
    
    As reported by Sergei, a couple of braces were missing after
    the WARN removal patch.
    
    [07/22] OMAP: hwmod: Replace WARN by pr_warning if clock lookup failed
    
    https://patchwork.kernel.org/patch/100756/
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    [paul@pwsan.com: fixed patch description per Anand's E-mail]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Sergei Shtylyov <sshtylyov@mvista.com>
    Cc: Anand Gadiyar <gadiyar@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 95c9a5f774e1..b7a4133267d8 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -409,10 +409,11 @@ static int _init_main_clk(struct omap_hwmod *oh)
 		return 0;
 
 	oh->_clk = omap_clk_get_by_name(oh->main_clk);
-	if (!oh->_clk)
+	if (!oh->_clk) {
 		pr_warning("omap_hwmod: %s: cannot clk_get main_clk %s\n",
 			   oh->name, oh->main_clk);
 		return -EINVAL;
+	}
 
 	if (!oh->_clk->clkdm)
 		pr_warning("omap_hwmod: %s: missing clockdomain for %s.\n",
@@ -444,10 +445,11 @@ static int _init_interface_clks(struct omap_hwmod *oh)
 			continue;
 
 		c = omap_clk_get_by_name(os->clk);
-		if (!c)
+		if (!c) {
 			pr_warning("omap_hwmod: %s: cannot clk_get interface_clk %s\n",
 				   oh->name, os->clk);
 			ret = -EINVAL;
+		}
 		os->_clk = c;
 	}
 
@@ -470,10 +472,11 @@ static int _init_opt_clks(struct omap_hwmod *oh)
 
 	for (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++) {
 		c = omap_clk_get_by_name(oc->clk);
-		if (!c)
+		if (!c) {
 			pr_warning("omap_hwmod: %s: cannot clk_get opt_clk %s\n",
 				   oh->name, oc->clk);
 			ret = -EINVAL;
+		}
 		oc->_clk = c;
 	}
 

commit f6304f5804f228b6c2fea9e3dfac25c5b2db9b38
Merge: 4fa73a1bf89e 6daa642d9b8e
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu May 20 11:37:23 2010 -0700

    Merge branch 'omap4-i2c-init' into omap-for-linus

commit 4788da268f83dedc58b79dc7b2f6072687f63a19
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue May 18 20:24:05 2010 -0600

    OMAP powerdomain, hwmod, omap_device: add some credits
    
    Add some missing credits for people who have contributed significant features
    or fixes.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>
    Cc: Tero Kristo <tero.kristo@nokia.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Thara Gopinath <thara@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 2fff39ff4080..0a563a671dde 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2,12 +2,12 @@
  * omap_hwmod implementation for OMAP2/3/4
  *
  * Copyright (C) 2009 Nokia Corporation
- * Paul Walmsley
- * With fixes and testing from Kevin Hilman
  *
- * Created in collaboration with (alphabetical order): Benoit Cousson,
- * Kevin Hilman, Tony Lindgren, Rajendra Nayak, Vikram Pandita, Sakari
- * Poussa, Anand Sawant, Santosh Shilimkar, Richard Woodruff
+ * Paul Walmsley, Benot Cousson, Kevin Hilman
+ *
+ * Created in collaboration with (alphabetical order): Thara Gopinath,
+ * Tony Lindgren, Rajendra Nayak, Vikram Pandita, Sakari Poussa, Anand
+ * Sawant, Santosh Shilimkar, Richard Woodruff
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as

commit 63403384233e3f58514eea891003458dedd43c12
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Thu May 20 12:31:10 2010 -0600

    OMAP: hwmod: Replace WARN by pr_warning for clockdomain check
    
    Most of the clock nodes belong to a clock domain, but it is perfectly valid
    to have clock without clock domain.
    Root clocks for example does not belong to any clock domain.
    Keep the warning but reduce the verbosity.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index b6031e468def..2fff39ff4080 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -404,21 +404,20 @@ static int _del_initiator_dep(struct omap_hwmod *oh, struct omap_hwmod *init_oh)
  */
 static int _init_main_clk(struct omap_hwmod *oh)
 {
-	struct clk *c;
 	int ret = 0;
 
 	if (!oh->main_clk)
 		return 0;
 
-	c = omap_clk_get_by_name(oh->main_clk);
-	if (!c)
+	oh->_clk = omap_clk_get_by_name(oh->main_clk);
+	if (!oh->_clk)
 		pr_warning("omap_hwmod: %s: cannot clk_get main_clk %s\n",
 			   oh->name, oh->main_clk);
-		ret = -EINVAL;
-	oh->_clk = c;
+		return -EINVAL;
 
-	WARN(!c->clkdm, "omap_hwmod: %s: missing clockdomain for %s.\n",
-	     oh->main_clk, c->name);
+	if (!oh->_clk->clkdm)
+		pr_warning("omap_hwmod: %s: missing clockdomain for %s.\n",
+			   oh->main_clk, oh->_clk->name);
 
 	return ret;
 }

commit 5c2c02961ea39d7bbe4d87f362ab3173a424794b
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Thu May 20 12:31:10 2010 -0600

    OMAP: hwmod: Rename hwmod name for the MPU
    
    In the lastest OMAP4 hwmod data file, the _hwmod was removed
    in order to save some memory space and because it does not
    bring a lot.
    
    The same cleanup will be have to done for other hwmods in
    OMAP2 & 3 data files.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Rajendra Nayak <rnayak@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index b624ad648212..b6031e468def 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -58,7 +58,7 @@
 #define MAX_MODULE_RESET_WAIT		10000
 
 /* Name of the OMAP hwmod for the MPU */
-#define MPU_INITIATOR_NAME		"mpu_hwmod"
+#define MPU_INITIATOR_NAME		"mpu"
 
 /* omap_hwmod_list contains all registered struct omap_hwmods */
 static LIST_HEAD(omap_hwmod_list);

commit f5c1f84bcc9c5b7a664886d0a5e7143d0bc3251f
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Thu May 20 12:31:10 2010 -0600

    OMAP: hwmod: Do not exit the iteration if one clock init failed
    
    During the _init_clocks phase, the iteration is stopped but the
    status is still change from _HWMOD_STATE_REGISTERED to
    _HWMOD_STATE_CLKS_INITED.
    Since the _setup phase will be done nevertheless, it might be
    better to keep initializing the others clocks nodes and just
    keep the warning.
    It is much easier to debug when a important number of clocks
    name are wrong during the early debug phase of a new platform.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 5d3a3ea37422..b624ad648212 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -783,9 +783,10 @@ static int _init_clocks(struct omap_hwmod *oh)
 	ret |= _init_interface_clks(oh);
 	ret |= _init_opt_clks(oh);
 
-	oh->_state = _HWMOD_STATE_CLKS_INITED;
+	if (!ret)
+		oh->_state = _HWMOD_STATE_CLKS_INITED;
 
-	return ret;
+	return 0;
 }
 
 /**

commit 20383d82160d918047bb10a4f6e170f4bac195a7
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Thu May 20 12:31:09 2010 -0600

    OMAP: hwmod: Replace WARN by pr_warning if clock lookup failed
    
    The WARN is a little bit too verbose and is not providing
    usefull information in that case.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index a62920beebc6..5d3a3ea37422 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -411,9 +411,9 @@ static int _init_main_clk(struct omap_hwmod *oh)
 		return 0;
 
 	c = omap_clk_get_by_name(oh->main_clk);
-	WARN(!c, "omap_hwmod: %s: cannot clk_get main_clk %s\n",
-	     oh->name, oh->main_clk);
 	if (!c)
+		pr_warning("omap_hwmod: %s: cannot clk_get main_clk %s\n",
+			   oh->name, oh->main_clk);
 		ret = -EINVAL;
 	oh->_clk = c;
 
@@ -446,9 +446,9 @@ static int _init_interface_clks(struct omap_hwmod *oh)
 			continue;
 
 		c = omap_clk_get_by_name(os->clk);
-		WARN(!c, "omap_hwmod: %s: cannot clk_get interface_clk %s\n",
-		     oh->name, os->clk);
 		if (!c)
+			pr_warning("omap_hwmod: %s: cannot clk_get interface_clk %s\n",
+				   oh->name, os->clk);
 			ret = -EINVAL;
 		os->_clk = c;
 	}
@@ -472,9 +472,9 @@ static int _init_opt_clks(struct omap_hwmod *oh)
 
 	for (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++) {
 		c = omap_clk_get_by_name(oc->clk);
-		WARN(!c, "omap_hwmod: %s: cannot clk_get opt_clk %s\n",
-		     oh->name, oc->clk);
 		if (!c)
+			pr_warning("omap_hwmod: %s: cannot clk_get opt_clk %s\n",
+				   oh->name, oc->clk);
 			ret = -EINVAL;
 		oc->_clk = c;
 	}

commit 4d3ae5a9a7b3685c6d260a82f4098145862b2cd3
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Thu May 20 12:31:09 2010 -0600

    OMAP: hwmod: Remove IS_ERR check with omap_clk_get_by_name return value
    
    The previous clock API was returning a standard linux error code in
    case of failure. This is not the case anymore with the new
    omap_clk_get_by_name API. A NULL value means that the clock node
    does not exist.
    Replace all the IS_ERR check by a !clk check.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index a280ccc31a7f..a62920beebc6 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -411,9 +411,9 @@ static int _init_main_clk(struct omap_hwmod *oh)
 		return 0;
 
 	c = omap_clk_get_by_name(oh->main_clk);
-	WARN(IS_ERR(c), "omap_hwmod: %s: cannot clk_get main_clk %s\n",
+	WARN(!c, "omap_hwmod: %s: cannot clk_get main_clk %s\n",
 	     oh->name, oh->main_clk);
-	if (IS_ERR(c))
+	if (!c)
 		ret = -EINVAL;
 	oh->_clk = c;
 
@@ -446,9 +446,9 @@ static int _init_interface_clks(struct omap_hwmod *oh)
 			continue;
 
 		c = omap_clk_get_by_name(os->clk);
-		WARN(IS_ERR(c), "omap_hwmod: %s: cannot clk_get "
-		     "interface_clk %s\n", oh->name, os->clk);
-		if (IS_ERR(c))
+		WARN(!c, "omap_hwmod: %s: cannot clk_get interface_clk %s\n",
+		     oh->name, os->clk);
+		if (!c)
 			ret = -EINVAL;
 		os->_clk = c;
 	}
@@ -472,9 +472,9 @@ static int _init_opt_clks(struct omap_hwmod *oh)
 
 	for (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++) {
 		c = omap_clk_get_by_name(oc->clk);
-		WARN(IS_ERR(c), "omap_hwmod: %s: cannot clk_get opt_clk "
-		     "%s\n", oh->name, oc->clk);
-		if (IS_ERR(c))
+		WARN(!c, "omap_hwmod: %s: cannot clk_get opt_clk %s\n",
+		     oh->name, oc->clk);
+		if (!c)
 			ret = -EINVAL;
 		oc->_clk = c;
 	}
@@ -495,7 +495,7 @@ static int _enable_clocks(struct omap_hwmod *oh)
 
 	pr_debug("omap_hwmod: %s: enabling clocks\n", oh->name);
 
-	if (oh->_clk && !IS_ERR(oh->_clk))
+	if (oh->_clk)
 		clk_enable(oh->_clk);
 
 	if (oh->slaves_cnt > 0) {
@@ -503,7 +503,7 @@ static int _enable_clocks(struct omap_hwmod *oh)
 			struct omap_hwmod_ocp_if *os = oh->slaves[i];
 			struct clk *c = os->_clk;
 
-			if (c && !IS_ERR(c) && (os->flags & OCPIF_SWSUP_IDLE))
+			if (c && (os->flags & OCPIF_SWSUP_IDLE))
 				clk_enable(c);
 		}
 	}
@@ -525,7 +525,7 @@ static int _disable_clocks(struct omap_hwmod *oh)
 
 	pr_debug("omap_hwmod: %s: disabling clocks\n", oh->name);
 
-	if (oh->_clk && !IS_ERR(oh->_clk))
+	if (oh->_clk)
 		clk_disable(oh->_clk);
 
 	if (oh->slaves_cnt > 0) {
@@ -533,7 +533,7 @@ static int _disable_clocks(struct omap_hwmod *oh)
 			struct omap_hwmod_ocp_if *os = oh->slaves[i];
 			struct clk *c = os->_clk;
 
-			if (c && !IS_ERR(c) && (os->flags & OCPIF_SWSUP_IDLE))
+			if (c && (os->flags & OCPIF_SWSUP_IDLE))
 				clk_disable(c);
 		}
 	}
@@ -1013,7 +1013,7 @@ static int _setup(struct omap_hwmod *oh)
 			struct omap_hwmod_ocp_if *os = oh->slaves[i];
 			struct clk *c = os->_clk;
 
-			if (!c || IS_ERR(c))
+			if (!c)
 				continue;
 
 			if (os->flags & OCPIF_SWSUP_IDLE) {

commit 682fdc96f3afb5ec34e4893fae41d09346d656ed
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Thu May 20 12:31:09 2010 -0600

    OMAP: hwmod: Fix wrong pointer iteration in oh->slaves
    
    The iteration is currently done on the omap_hwmod_ocp_if pointer
    and not on the table pointer that reference them.
    It worked most of the time because the structure are contiguous in
    memory.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 6459d07785b7..a280ccc31a7f 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -432,7 +432,6 @@ static int _init_main_clk(struct omap_hwmod *oh)
  */
 static int _init_interface_clks(struct omap_hwmod *oh)
 {
-	struct omap_hwmod_ocp_if *os;
 	struct clk *c;
 	int i;
 	int ret = 0;
@@ -440,7 +439,9 @@ static int _init_interface_clks(struct omap_hwmod *oh)
 	if (oh->slaves_cnt == 0)
 		return 0;
 
-	for (i = 0, os = *oh->slaves; i < oh->slaves_cnt; i++, os++) {
+	for (i = 0; i < oh->slaves_cnt; i++) {
+		struct omap_hwmod_ocp_if *os = oh->slaves[i];
+
 		if (!os->clk)
 			continue;
 
@@ -490,7 +491,6 @@ static int _init_opt_clks(struct omap_hwmod *oh)
  */
 static int _enable_clocks(struct omap_hwmod *oh)
 {
-	struct omap_hwmod_ocp_if *os;
 	int i;
 
 	pr_debug("omap_hwmod: %s: enabling clocks\n", oh->name);
@@ -499,7 +499,8 @@ static int _enable_clocks(struct omap_hwmod *oh)
 		clk_enable(oh->_clk);
 
 	if (oh->slaves_cnt > 0) {
-		for (i = 0, os = *oh->slaves; i < oh->slaves_cnt; i++, os++) {
+		for (i = 0; i < oh->slaves_cnt; i++) {
+			struct omap_hwmod_ocp_if *os = oh->slaves[i];
 			struct clk *c = os->_clk;
 
 			if (c && !IS_ERR(c) && (os->flags & OCPIF_SWSUP_IDLE))
@@ -520,7 +521,6 @@ static int _enable_clocks(struct omap_hwmod *oh)
  */
 static int _disable_clocks(struct omap_hwmod *oh)
 {
-	struct omap_hwmod_ocp_if *os;
 	int i;
 
 	pr_debug("omap_hwmod: %s: disabling clocks\n", oh->name);
@@ -529,7 +529,8 @@ static int _disable_clocks(struct omap_hwmod *oh)
 		clk_disable(oh->_clk);
 
 	if (oh->slaves_cnt > 0) {
-		for (i = 0, os = *oh->slaves; i < oh->slaves_cnt; i++, os++) {
+		for (i = 0; i < oh->slaves_cnt; i++) {
+			struct omap_hwmod_ocp_if *os = oh->slaves[i];
 			struct clk *c = os->_clk;
 
 			if (c && !IS_ERR(c) && (os->flags & OCPIF_SWSUP_IDLE))
@@ -551,14 +552,15 @@ static int _disable_clocks(struct omap_hwmod *oh)
  */
 static int _find_mpu_port_index(struct omap_hwmod *oh)
 {
-	struct omap_hwmod_ocp_if *os;
 	int i;
 	int found = 0;
 
 	if (!oh || oh->slaves_cnt == 0)
 		return -EINVAL;
 
-	for (i = 0, os = *oh->slaves; i < oh->slaves_cnt; i++, os++) {
+	for (i = 0; i < oh->slaves_cnt; i++) {
+		struct omap_hwmod_ocp_if *os = oh->slaves[i];
+
 		if (os->user & OCP_USER_MPU) {
 			found = 1;
 			break;
@@ -593,7 +595,7 @@ static void __iomem *_find_mpu_rt_base(struct omap_hwmod *oh, u8 index)
 	if (!oh || oh->slaves_cnt == 0)
 		return NULL;
 
-	os = *oh->slaves + index;
+	os = oh->slaves[index];
 
 	for (i = 0, mem = os->addr; i < os->addr_cnt; i++, mem++) {
 		if (mem->flags & ADDR_TYPE_RT) {
@@ -806,7 +808,7 @@ static int _wait_target_ready(struct omap_hwmod *oh)
 	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
 		return 0;
 
-	os = *oh->slaves + oh->_mpu_port_index;
+	os = oh->slaves[oh->_mpu_port_index];
 
 	if (oh->flags & HWMOD_NO_IDLEST)
 		return 0;
@@ -1000,7 +1002,6 @@ static int _shutdown(struct omap_hwmod *oh)
  */
 static int _setup(struct omap_hwmod *oh)
 {
-	struct omap_hwmod_ocp_if *os;
 	int i, r;
 
 	if (!oh)
@@ -1008,7 +1009,8 @@ static int _setup(struct omap_hwmod *oh)
 
 	/* Set iclk autoidle mode */
 	if (oh->slaves_cnt > 0) {
-		for (i = 0, os = *oh->slaves; i < oh->slaves_cnt; i++, os++) {
+		for (i = 0; i < oh->slaves_cnt; i++) {
+			struct omap_hwmod_ocp_if *os = oh->slaves[i];
 			struct clk *c = os->_clk;
 
 			if (!c || IS_ERR(c))
@@ -1438,7 +1440,7 @@ int omap_hwmod_count_resources(struct omap_hwmod *oh)
 	ret = oh->mpu_irqs_cnt + oh->sdma_chs_cnt;
 
 	for (i = 0; i < oh->slaves_cnt; i++)
-		ret += (*oh->slaves + i)->addr_cnt;
+		ret += oh->slaves[i]->addr_cnt;
 
 	return ret;
 }
@@ -1479,7 +1481,7 @@ int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 	for (i = 0; i < oh->slaves_cnt; i++) {
 		struct omap_hwmod_ocp_if *os;
 
-		os = *oh->slaves + i;
+		os = oh->slaves[i];
 
 		for (j = 0; j < os->addr_cnt; j++) {
 			(res + r)->start = (os->addr + j)->pa_start;

commit 33f7ec81fb3e525eec0575f33dbab02240eda6d4
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Thu May 20 12:31:09 2010 -0600

    OMAP4: hwmod: Replace OCPIF_HAS_IDLEST by HWMOD_NO_IDLEST
    
    Some initiator modules in OMAP2 & 3 does not have IDLEST bit,
    in that case we cannot detect the module readiness by
    polling that bit and must exist the function immediately
    assuming that the module is ready.
    
    The previous flag was affected to the OCP interface. While it is
    technically true that the idlest is related to the L4 slave
    interface of the module, the PRCM status belong to the module.
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 4a134c4d2271..6459d07785b7 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -808,7 +808,7 @@ static int _wait_target_ready(struct omap_hwmod *oh)
 
 	os = *oh->slaves + oh->_mpu_port_index;
 
-	if (!(os->flags & OCPIF_HAS_IDLEST))
+	if (oh->flags & HWMOD_NO_IDLEST)
 		return 0;
 
 	/* XXX check module SIDLEMODE */

commit 9a23dfe12806920a8dfadec5ea5b83e5ca5378c9
Author: Benoit Cousson <b-cousson@ti.com>
Date:   Thu May 20 12:31:08 2010 -0600

    OMAP4: hwmod & CM: Implement the omap4_cm_wait_module_ready function
    
    The return of the omap4_cm_wait_module_ready function is checked
    in order to avoid accessing the sysconfig register if the module is
    not in the correct state.
    In that case the _setup will exit without trying to reset
    using sysconfig.
    For the moment a warning is printed. A proper management of fclk
    and module reset will have to be done in order to init correctly
    the problematic IPs listed below.
    
      <4>omap_hwmod: ivahd: cannot be enabled (3)
      <4>omap_hwmod: iss: cannot be enabled (3)
      <4>omap_hwmod: tesla: cannot be enabled (3)
      <4>omap_hwmod: sdma: cannot be enabled (3)
      <4>omap_hwmod: sl2: cannot be enabled (3)
      <4>omap_hwmod: sad2d: cannot be enabled (3)
      <4>omap_hwmod: ducati: cannot be enabled (3)
    
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index e436dcb19795..4a134c4d2271 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -819,11 +819,8 @@ static int _wait_target_ready(struct omap_hwmod *oh)
 		ret = omap2_cm_wait_module_ready(oh->prcm.omap2.module_offs,
 						 oh->prcm.omap2.idlest_reg_id,
 						 oh->prcm.omap2.idlest_idle_bit);
-#if 0
 	} else if (cpu_is_omap44xx()) {
-		ret = omap4_cm_wait_module_ready(oh->prcm.omap4.module_offs,
-						 oh->prcm.omap4.device_offs);
-#endif
+		ret = omap4_cm_wait_module_ready(oh->prcm.omap4.clkctrl_reg);
 	} else {
 		BUG();
 	};
@@ -912,16 +909,21 @@ static int _enable(struct omap_hwmod *oh)
 	_add_initiator_dep(oh, mpu_oh);
 	_enable_clocks(oh);
 
-	if (oh->class->sysc) {
-		if (!(oh->_int_flags & _HWMOD_SYSCONFIG_LOADED))
-			_update_sysc_cache(oh);
-		_sysc_enable(oh);
-	}
-
 	r = _wait_target_ready(oh);
-	if (!r)
+	if (!r) {
 		oh->_state = _HWMOD_STATE_ENABLED;
 
+		/* Access the sysconfig only if the target is ready */
+		if (oh->class->sysc) {
+			if (!(oh->_int_flags & _HWMOD_SYSCONFIG_LOADED))
+				_update_sysc_cache(oh);
+			_sysc_enable(oh);
+		}
+	} else {
+		pr_debug("omap_hwmod: %s: _wait_target_ready: %d\n",
+			 oh->name, r);
+	}
+
 	return r;
 }
 
@@ -999,7 +1001,7 @@ static int _shutdown(struct omap_hwmod *oh)
 static int _setup(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_ocp_if *os;
-	int i;
+	int i, r;
 
 	if (!oh)
 		return -EINVAL;
@@ -1023,7 +1025,12 @@ static int _setup(struct omap_hwmod *oh)
 
 	oh->_state = _HWMOD_STATE_INITIALIZED;
 
-	_enable(oh);
+	r = _enable(oh);
+	if (r) {
+		pr_warning("omap_hwmod: %s: cannot be enabled (%d)\n",
+			   oh->name, oh->_state);
+		return 0;
+	}
 
 	if (!(oh->flags & HWMOD_INIT_NO_RESET)) {
 		/*

commit ac1d426e825ab5778995f2f6f053ca2e6b45c622
Merge: fda0e18c8a7a a3685f00652a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon May 17 17:24:04 2010 +0100

    Merge branch 'devel-stable' into devel
    
    Conflicts:
            arch/arm/Kconfig
            arch/arm/include/asm/system.h
            arch/arm/mm/Kconfig

commit 6262c92f51ffb074800d5a340ee16bc06758e037
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Mar 25 17:06:19 2010 +0000

    ARM: Remove useless linux/bootmem.h includes
    
    These files include linux/bootmem.h without using anything from this
    file; remove the unnecessary include.
    
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index c6649472ce0d..aa3e20915d72 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -43,7 +43,6 @@
 #include <linux/err.h>
 #include <linux/list.h>
 #include <linux/mutex.h>
-#include <linux/bootmem.h>
 
 #include <plat/common.h>
 #include <plat/cpu.h>

commit d5647c18eac9a313a89a3049a9fff51b20021a44
Author: Thara Gopinath <thara@ti.com>
Date:   Wed Mar 31 04:16:29 2010 -0600

    OMAP: HWMOD: Adding clockdomain check
    
    This patch adds check for presence of clockdomain structure in the API
    omap_hwmod_get_pwrdm before trying to access the powerdomain structure.
    This will prevent unnecessary crashing of the system in case of a
    clock node with out an associated clockdomain.
    
    Signed-off-by: Thara Gopinath <thara@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index c6649472ce0d..e436dcb19795 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1511,6 +1511,9 @@ struct powerdomain *omap_hwmod_get_pwrdm(struct omap_hwmod *oh)
 		c = oh->slaves[oh->_mpu_port_index]->_clk;
 	}
 
+	if (!c->clkdm)
+		return NULL;
+
 	return c->clkdm->pwrdm.ptr;
 
 }

commit 43b40992ce21def8d5957f32d7ddb728af89bfce
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Feb 22 22:09:34 2010 -0700

    OMAP hwmod: add hwmod class support
    
    Add support for categorizing and iterating over hardware IP blocks by
    the "class" of the IP block.  The class is the type of the IP block:
    e.g., "timer", "timer1ms", etc.  Move the OCP_SYSCONFIG/SYSSTATUS data
    from the struct omap_hwmod into the struct omap_hwmod_class, since
    it's expected to stay consistent for each class.  While here, fix some
    comments.
    
    The hwmod_class structures in this patch were designed and proposed by
    Benot Cousson <b-cousson@ti.com> and were refined in a discussion
    between Thara Gopinath <thara@ti.com>, Kevin Hilman
    <khilman@deeprootsystems.com>, and myself.
    
    This patch uses WARN() lines that are longer than 80 characters, as
    Kevin noted a broader lkml consensus to increase greppability by
    keeping the messages all on one line.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Benot Cousson <b-cousson@ti.com>
    Cc: Thara Gopinath <thara@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 501660aae962..c6649472ce0d 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -84,17 +84,16 @@ static u8 inited;
  */
 static int _update_sysc_cache(struct omap_hwmod *oh)
 {
-	if (!oh->sysconfig) {
-		WARN(!oh->sysconfig, "omap_hwmod: %s: cannot read "
-		     "OCP_SYSCONFIG: not defined on hwmod\n", oh->name);
+	if (!oh->class->sysc) {
+		WARN(1, "omap_hwmod: %s: cannot read OCP_SYSCONFIG: not defined on hwmod's class\n", oh->name);
 		return -EINVAL;
 	}
 
 	/* XXX ensure module interface clock is up */
 
-	oh->_sysc_cache = omap_hwmod_readl(oh, oh->sysconfig->sysc_offs);
+	oh->_sysc_cache = omap_hwmod_readl(oh, oh->class->sysc->sysc_offs);
 
-	if (!(oh->sysconfig->sysc_flags & SYSC_NO_CACHE))
+	if (!(oh->class->sysc->sysc_flags & SYSC_NO_CACHE))
 		oh->_int_flags |= _HWMOD_SYSCONFIG_LOADED;
 
 	return 0;
@@ -105,14 +104,13 @@ static int _update_sysc_cache(struct omap_hwmod *oh)
  * @v: OCP_SYSCONFIG value to write
  * @oh: struct omap_hwmod *
  *
- * Write @v into the module OCP_SYSCONFIG register, if it has one.  No
- * return value.
+ * Write @v into the module class' OCP_SYSCONFIG register, if it has
+ * one.  No return value.
  */
 static void _write_sysconfig(u32 v, struct omap_hwmod *oh)
 {
-	if (!oh->sysconfig) {
-		WARN(!oh->sysconfig, "omap_hwmod: %s: cannot write "
-		     "OCP_SYSCONFIG: not defined on hwmod\n", oh->name);
+	if (!oh->class->sysc) {
+		WARN(1, "omap_hwmod: %s: cannot write OCP_SYSCONFIG: not defined on hwmod's class\n", oh->name);
 		return;
 	}
 
@@ -120,7 +118,7 @@ static void _write_sysconfig(u32 v, struct omap_hwmod *oh)
 
 	if (oh->_sysc_cache != v) {
 		oh->_sysc_cache = v;
-		omap_hwmod_writel(v, oh, oh->sysconfig->sysc_offs);
+		omap_hwmod_writel(v, oh, oh->class->sysc->sysc_offs);
 	}
 }
 
@@ -140,17 +138,16 @@ static int _set_master_standbymode(struct omap_hwmod *oh, u8 standbymode,
 	u32 mstandby_mask;
 	u8 mstandby_shift;
 
-	if (!oh->sysconfig ||
-	    !(oh->sysconfig->sysc_flags & SYSC_HAS_MIDLEMODE))
+	if (!oh->class->sysc ||
+	    !(oh->class->sysc->sysc_flags & SYSC_HAS_MIDLEMODE))
 		return -EINVAL;
 
-	if (!oh->sysconfig->sysc_fields) {
-		WARN(!oh->sysconfig->sysc_fields, "offset struct for "
-			"sysconfig not provided!\n");
+	if (!oh->class->sysc->sysc_fields) {
+		WARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);
 		return -EINVAL;
 	}
 
-	mstandby_shift = oh->sysconfig->sysc_fields->midle_shift;
+	mstandby_shift = oh->class->sysc->sysc_fields->midle_shift;
 	mstandby_mask = (0x3 << mstandby_shift);
 
 	*v &= ~mstandby_mask;
@@ -174,17 +171,16 @@ static int _set_slave_idlemode(struct omap_hwmod *oh, u8 idlemode, u32 *v)
 	u32 sidle_mask;
 	u8 sidle_shift;
 
-	if (!oh->sysconfig ||
-	    !(oh->sysconfig->sysc_flags & SYSC_HAS_SIDLEMODE))
+	if (!oh->class->sysc ||
+	    !(oh->class->sysc->sysc_flags & SYSC_HAS_SIDLEMODE))
 		return -EINVAL;
 
-	if (!oh->sysconfig->sysc_fields) {
-		WARN(!oh->sysconfig->sysc_fields, "offset struct for "
-			"sysconfig not provided!\n");
+	if (!oh->class->sysc->sysc_fields) {
+		WARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);
 		return -EINVAL;
 	}
 
-	sidle_shift = oh->sysconfig->sysc_fields->sidle_shift;
+	sidle_shift = oh->class->sysc->sysc_fields->sidle_shift;
 	sidle_mask = (0x3 << sidle_shift);
 
 	*v &= ~sidle_mask;
@@ -209,17 +205,16 @@ static int _set_clockactivity(struct omap_hwmod *oh, u8 clockact, u32 *v)
 	u32 clkact_mask;
 	u8  clkact_shift;
 
-	if (!oh->sysconfig ||
-	    !(oh->sysconfig->sysc_flags & SYSC_HAS_CLOCKACTIVITY))
+	if (!oh->class->sysc ||
+	    !(oh->class->sysc->sysc_flags & SYSC_HAS_CLOCKACTIVITY))
 		return -EINVAL;
 
-	if (!oh->sysconfig->sysc_fields) {
-		WARN(!oh->sysconfig->sysc_fields, "offset struct for "
-			"sysconfig not provided!\n");
+	if (!oh->class->sysc->sysc_fields) {
+		WARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);
 		return -EINVAL;
 	}
 
-	clkact_shift = oh->sysconfig->sysc_fields->clkact_shift;
+	clkact_shift = oh->class->sysc->sysc_fields->clkact_shift;
 	clkact_mask = (0x3 << clkact_shift);
 
 	*v &= ~clkact_mask;
@@ -240,17 +235,16 @@ static int _set_softreset(struct omap_hwmod *oh, u32 *v)
 {
 	u32 softrst_mask;
 
-	if (!oh->sysconfig ||
-	    !(oh->sysconfig->sysc_flags & SYSC_HAS_SOFTRESET))
+	if (!oh->class->sysc ||
+	    !(oh->class->sysc->sysc_flags & SYSC_HAS_SOFTRESET))
 		return -EINVAL;
 
-	if (!oh->sysconfig->sysc_fields) {
-		WARN(!oh->sysconfig->sysc_fields, "offset struct for "
-			"sysconfig not provided!\n");
+	if (!oh->class->sysc->sysc_fields) {
+		WARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);
 		return -EINVAL;
 	}
 
-	softrst_mask = (0x1 << oh->sysconfig->sysc_fields->srst_shift);
+	softrst_mask = (0x1 << oh->class->sysc->sysc_fields->srst_shift);
 
 	*v |= softrst_mask;
 
@@ -276,17 +270,16 @@ static int _set_module_autoidle(struct omap_hwmod *oh, u8 autoidle,
 	u32 autoidle_mask;
 	u8 autoidle_shift;
 
-	if (!oh->sysconfig ||
-	    !(oh->sysconfig->sysc_flags & SYSC_HAS_AUTOIDLE))
+	if (!oh->class->sysc ||
+	    !(oh->class->sysc->sysc_flags & SYSC_HAS_AUTOIDLE))
 		return -EINVAL;
 
-	if (!oh->sysconfig->sysc_fields) {
-		WARN(oh->sysconfig->sysc_fields, "offset struct for "
-			"sysconfig not provided!\n");
+	if (!oh->class->sysc->sysc_fields) {
+		WARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);
 		return -EINVAL;
 	}
 
-	autoidle_shift = oh->sysconfig->sysc_fields->autoidle_shift;
+	autoidle_shift = oh->class->sysc->sysc_fields->autoidle_shift;
 	autoidle_mask = (0x3 << autoidle_shift);
 
 	*v &= ~autoidle_mask;
@@ -306,17 +299,16 @@ static int _enable_wakeup(struct omap_hwmod *oh)
 {
 	u32 v, wakeup_mask;
 
-	if (!oh->sysconfig ||
-	    !(oh->sysconfig->sysc_flags & SYSC_HAS_ENAWAKEUP))
+	if (!oh->class->sysc ||
+	    !(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP))
 		return -EINVAL;
 
-	if (!oh->sysconfig->sysc_fields) {
-		WARN(!oh->sysconfig->sysc_fields, "offset struct for "
-			"sysconfig not provided!\n");
+	if (!oh->class->sysc->sysc_fields) {
+		WARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);
 		return -EINVAL;
 	}
 
-	wakeup_mask = (0x1 << oh->sysconfig->sysc_fields->enwkup_shift);
+	wakeup_mask = (0x1 << oh->class->sysc->sysc_fields->enwkup_shift);
 
 	v = oh->_sysc_cache;
 	v |= wakeup_mask;
@@ -340,17 +332,16 @@ static int _disable_wakeup(struct omap_hwmod *oh)
 {
 	u32 v, wakeup_mask;
 
-	if (!oh->sysconfig ||
-	    !(oh->sysconfig->sysc_flags & SYSC_HAS_ENAWAKEUP))
+	if (!oh->class->sysc ||
+	    !(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP))
 		return -EINVAL;
 
-	if (!oh->sysconfig->sysc_fields) {
-		WARN(!oh->sysconfig->sysc_fields, "offset struct for "
-			"sysconfig not provided!\n");
+	if (!oh->class->sysc->sysc_fields) {
+		WARN(1, "omap_hwmod: %s: offset struct for sysconfig not provided in class\n", oh->name);
 		return -EINVAL;
 	}
 
-	wakeup_mask = (0x1 << oh->sysconfig->sysc_fields->enwkup_shift);
+	wakeup_mask = (0x1 << oh->class->sysc->sysc_fields->enwkup_shift);
 
 	v = oh->_sysc_cache;
 	v &= ~wakeup_mask;
@@ -638,27 +629,28 @@ static void __iomem *_find_mpu_rt_base(struct omap_hwmod *oh, u8 index)
  */
 static void _sysc_enable(struct omap_hwmod *oh)
 {
-	u8 idlemode;
+	u8 idlemode, sf;
 	u32 v;
 
-	if (!oh->sysconfig)
+	if (!oh->class->sysc)
 		return;
 
 	v = oh->_sysc_cache;
+	sf = oh->class->sysc->sysc_flags;
 
-	if (oh->sysconfig->sysc_flags & SYSC_HAS_SIDLEMODE) {
+	if (sf & SYSC_HAS_SIDLEMODE) {
 		idlemode = (oh->flags & HWMOD_SWSUP_SIDLE) ?
 			HWMOD_IDLEMODE_NO : HWMOD_IDLEMODE_SMART;
 		_set_slave_idlemode(oh, idlemode, &v);
 	}
 
-	if (oh->sysconfig->sysc_flags & SYSC_HAS_MIDLEMODE) {
+	if (sf & SYSC_HAS_MIDLEMODE) {
 		idlemode = (oh->flags & HWMOD_SWSUP_MSTANDBY) ?
 			HWMOD_IDLEMODE_NO : HWMOD_IDLEMODE_SMART;
 		_set_master_standbymode(oh, idlemode, &v);
 	}
 
-	if (oh->sysconfig->sysc_flags & SYSC_HAS_AUTOIDLE) {
+	if (sf & SYSC_HAS_AUTOIDLE) {
 		idlemode = (oh->flags & HWMOD_NO_OCP_AUTOIDLE) ?
 			0 : 1;
 		_set_module_autoidle(oh, idlemode, &v);
@@ -671,9 +663,9 @@ static void _sysc_enable(struct omap_hwmod *oh)
 	 * calling into this code.  But this must wait until the
 	 * clock structures are tagged with omap_hwmod entries
 	 */
-	if (oh->flags & HWMOD_SET_DEFAULT_CLOCKACT &&
-	    oh->sysconfig->sysc_flags & SYSC_HAS_CLOCKACTIVITY)
-		_set_clockactivity(oh, oh->sysconfig->clockact, &v);
+	if ((oh->flags & HWMOD_SET_DEFAULT_CLOCKACT) &&
+	    (sf & SYSC_HAS_CLOCKACTIVITY))
+		_set_clockactivity(oh, oh->class->sysc->clockact, &v);
 
 	_write_sysconfig(v, oh);
 }
@@ -689,21 +681,22 @@ static void _sysc_enable(struct omap_hwmod *oh)
  */
 static void _sysc_idle(struct omap_hwmod *oh)
 {
-	u8 idlemode;
+	u8 idlemode, sf;
 	u32 v;
 
-	if (!oh->sysconfig)
+	if (!oh->class->sysc)
 		return;
 
 	v = oh->_sysc_cache;
+	sf = oh->class->sysc->sysc_flags;
 
-	if (oh->sysconfig->sysc_flags & SYSC_HAS_SIDLEMODE) {
+	if (sf & SYSC_HAS_SIDLEMODE) {
 		idlemode = (oh->flags & HWMOD_SWSUP_SIDLE) ?
 			HWMOD_IDLEMODE_FORCE : HWMOD_IDLEMODE_SMART;
 		_set_slave_idlemode(oh, idlemode, &v);
 	}
 
-	if (oh->sysconfig->sysc_flags & SYSC_HAS_MIDLEMODE) {
+	if (sf & SYSC_HAS_MIDLEMODE) {
 		idlemode = (oh->flags & HWMOD_SWSUP_MSTANDBY) ?
 			HWMOD_IDLEMODE_FORCE : HWMOD_IDLEMODE_SMART;
 		_set_master_standbymode(oh, idlemode, &v);
@@ -722,19 +715,21 @@ static void _sysc_idle(struct omap_hwmod *oh)
 static void _sysc_shutdown(struct omap_hwmod *oh)
 {
 	u32 v;
+	u8 sf;
 
-	if (!oh->sysconfig)
+	if (!oh->class->sysc)
 		return;
 
 	v = oh->_sysc_cache;
+	sf = oh->class->sysc->sysc_flags;
 
-	if (oh->sysconfig->sysc_flags & SYSC_HAS_SIDLEMODE)
+	if (sf & SYSC_HAS_SIDLEMODE)
 		_set_slave_idlemode(oh, HWMOD_IDLEMODE_FORCE, &v);
 
-	if (oh->sysconfig->sysc_flags & SYSC_HAS_MIDLEMODE)
+	if (sf & SYSC_HAS_MIDLEMODE)
 		_set_master_standbymode(oh, HWMOD_IDLEMODE_FORCE, &v);
 
-	if (oh->sysconfig->sysc_flags & SYSC_HAS_AUTOIDLE)
+	if (sf & SYSC_HAS_AUTOIDLE)
 		_set_module_autoidle(oh, 1, &v);
 
 	_write_sysconfig(v, oh);
@@ -851,9 +846,9 @@ static int _reset(struct omap_hwmod *oh)
 	u32 r, v;
 	int c = 0;
 
-	if (!oh->sysconfig ||
-	    !(oh->sysconfig->sysc_flags & SYSC_HAS_SOFTRESET) ||
-	    (oh->sysconfig->sysc_flags & SYSS_MISSING))
+	if (!oh->class->sysc ||
+	    !(oh->class->sysc->sysc_flags & SYSC_HAS_SOFTRESET) ||
+	    (oh->class->sysc->sysc_flags & SYSS_MISSING))
 		return -EINVAL;
 
 	/* clocks must be on for this operation */
@@ -871,7 +866,7 @@ static int _reset(struct omap_hwmod *oh)
 		return r;
 	_write_sysconfig(v, oh);
 
-	omap_test_timeout((omap_hwmod_readl(oh, oh->sysconfig->syss_offs) &
+	omap_test_timeout((omap_hwmod_readl(oh, oh->class->sysc->syss_offs) &
 			   SYSS_RESETDONE_MASK),
 			  MAX_MODULE_RESET_WAIT, c);
 
@@ -917,7 +912,7 @@ static int _enable(struct omap_hwmod *oh)
 	_add_initiator_dep(oh, mpu_oh);
 	_enable_clocks(oh);
 
-	if (oh->sysconfig) {
+	if (oh->class->sysc) {
 		if (!(oh->_int_flags & _HWMOD_SYSCONFIG_LOADED))
 			_update_sysc_cache(oh);
 		_sysc_enable(oh);
@@ -948,7 +943,7 @@ static int _idle(struct omap_hwmod *oh)
 
 	pr_debug("omap_hwmod: %s: idling\n", oh->name);
 
-	if (oh->sysconfig)
+	if (oh->class->sysc)
 		_sysc_idle(oh);
 	_del_initiator_dep(oh, mpu_oh);
 	_disable_clocks(oh);
@@ -978,7 +973,7 @@ static int _shutdown(struct omap_hwmod *oh)
 
 	pr_debug("omap_hwmod: %s: disabling\n", oh->name);
 
-	if (oh->sysconfig)
+	if (oh->class->sysc)
 		_sysc_shutdown(oh);
 	_del_initiator_dep(oh, mpu_oh);
 	/* XXX what about the other system initiators here? DMA, tesla, d2d */
@@ -1038,7 +1033,7 @@ static int _setup(struct omap_hwmod *oh)
 		 * _enable() function should be split to avoid the
 		 * rewrite of the OCP_SYSCONFIG register.
 		 */
-		if (oh->sysconfig) {
+		if (oh->class->sysc) {
 			_update_sysc_cache(oh);
 			_sysc_enable(oh);
 		}
@@ -1085,9 +1080,12 @@ int omap_hwmod_set_slave_idlemode(struct omap_hwmod *oh, u8 idlemode)
  * omap_hwmod_register - register a struct omap_hwmod
  * @oh: struct omap_hwmod *
  *
- * Registers the omap_hwmod @oh.  Returns -EEXIST if an omap_hwmod already
- * has been registered by the same name; -EINVAL if the omap_hwmod is in the
- * wrong state, or 0 on success.
+ * Registers the omap_hwmod @oh.  Returns -EEXIST if an omap_hwmod
+ * already has been registered by the same name; -EINVAL if the
+ * omap_hwmod is in the wrong state, if @oh is NULL, if the
+ * omap_hwmod's class field is NULL; if the omap_hwmod is missing a
+ * name, or if the omap_hwmod's class is missing a name; or 0 upon
+ * success.
  *
  * XXX The data should be copied into bootmem, so the original data
  * should be marked __initdata and freed after init.  This would allow
@@ -1099,7 +1097,8 @@ int omap_hwmod_register(struct omap_hwmod *oh)
 {
 	int ret, ms_id;
 
-	if (!oh || (oh->_state != _HWMOD_STATE_UNKNOWN))
+	if (!oh || !oh->name || !oh->class || !oh->class->name ||
+	    (oh->_state != _HWMOD_STATE_UNKNOWN))
 		return -EINVAL;
 
 	mutex_lock(&omap_hwmod_mutex);
@@ -1372,7 +1371,7 @@ void omap_hwmod_ocp_barrier(struct omap_hwmod *oh)
 {
 	BUG_ON(!oh);
 
-	if (!oh->sysconfig || !oh->sysconfig->sysc_flags) {
+	if (!oh->class->sysc || !oh->class->sysc->sysc_flags) {
 		WARN(1, "omap_device: %s: OCP barrier impossible due to "
 		      "device configuration\n", oh->name);
 		return;
@@ -1382,7 +1381,7 @@ void omap_hwmod_ocp_barrier(struct omap_hwmod *oh)
 	 * Forces posted writes to complete on the OCP thread handling
 	 * register writes
 	 */
-	omap_hwmod_readl(oh, oh->sysconfig->sysc_offs);
+	omap_hwmod_readl(oh, oh->class->sysc->sysc_offs);
 }
 
 /**
@@ -1575,8 +1574,8 @@ int omap_hwmod_del_initiator_dep(struct omap_hwmod *oh,
  */
 int omap_hwmod_enable_wakeup(struct omap_hwmod *oh)
 {
-	if (!oh->sysconfig ||
-	    !(oh->sysconfig->sysc_flags & SYSC_HAS_ENAWAKEUP))
+	if (!oh->class->sysc ||
+	    !(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP))
 		return -EINVAL;
 
 	mutex_lock(&omap_hwmod_mutex);
@@ -1600,8 +1599,8 @@ int omap_hwmod_enable_wakeup(struct omap_hwmod *oh)
  */
 int omap_hwmod_disable_wakeup(struct omap_hwmod *oh)
 {
-	if (!oh->sysconfig ||
-	    !(oh->sysconfig->sysc_flags & SYSC_HAS_ENAWAKEUP))
+	if (!oh->class->sysc ||
+	    !(oh->class->sysc->sysc_flags & SYSC_HAS_ENAWAKEUP))
 		return -EINVAL;
 
 	mutex_lock(&omap_hwmod_mutex);
@@ -1610,3 +1609,52 @@ int omap_hwmod_disable_wakeup(struct omap_hwmod *oh)
 
 	return 0;
 }
+
+/**
+ * omap_hwmod_for_each_by_class - call @fn for each hwmod of class @classname
+ * @classname: struct omap_hwmod_class name to search for
+ * @fn: callback function pointer to call for each hwmod in class @classname
+ * @user: arbitrary context data to pass to the callback function
+ *
+ * For each omap_hwmod of class @classname, call @fn.  Takes
+ * omap_hwmod_mutex to prevent the hwmod list from changing during the
+ * iteration.  If the callback function returns something other than
+ * zero, the iterator is terminated, and the callback function's return
+ * value is passed back to the caller.  Returns 0 upon success, -EINVAL
+ * if @classname or @fn are NULL, or passes back the error code from @fn.
+ */
+int omap_hwmod_for_each_by_class(const char *classname,
+				 int (*fn)(struct omap_hwmod *oh,
+					   void *user),
+				 void *user)
+{
+	struct omap_hwmod *temp_oh;
+	int ret = 0;
+
+	if (!classname || !fn)
+		return -EINVAL;
+
+	pr_debug("omap_hwmod: %s: looking for modules of class %s\n",
+		 __func__, classname);
+
+	mutex_lock(&omap_hwmod_mutex);
+
+	list_for_each_entry(temp_oh, &omap_hwmod_list, node) {
+		if (!strcmp(temp_oh->class->name, classname)) {
+			pr_debug("omap_hwmod: %s: %s: calling callback fn\n",
+				 __func__, temp_oh->name);
+			ret = (*fn)(temp_oh, user);
+			if (ret)
+				break;
+		}
+	}
+
+	mutex_unlock(&omap_hwmod_mutex);
+
+	if (ret)
+		pr_debug("omap_hwmod: %s: iterator terminated early: %d\n",
+			 __func__, ret);
+
+	return ret;
+}
+

commit 50ebdac2ec9fb2de9c271cb2e0e13aae3b454166
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Feb 22 22:09:31 2010 -0700

    OMAP hwmod: convert hwmod to use hardware clock names rather than clkdev dev+con
    
    The OMAP hwmod core code is intended to use SoC IP block description
    structures that are autogenerated from TI's OMAP hardware database.
    Currently the hwmod code uses clkdev device + connection addressing to
    identify clocks.  This causes problems in the hwmod autogeneration
    process, since the TI hardware database doesn't use platform_device or
    clkdev addressing; it uses a single clock signal name string, which
    tends to bear some resemblance to what is used in the OMAP TRMs.  This
    patch converts the hwmod code and existing data to use omap_clk_get_by_name(),
    introduced in the previous patch.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index fb11ec176d55..501660aae962 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -416,18 +416,18 @@ static int _init_main_clk(struct omap_hwmod *oh)
 	struct clk *c;
 	int ret = 0;
 
-	if (!oh->clkdev_con_id)
+	if (!oh->main_clk)
 		return 0;
 
-	c = clk_get_sys(oh->clkdev_dev_id, oh->clkdev_con_id);
-	WARN(IS_ERR(c), "omap_hwmod: %s: cannot clk_get main_clk %s.%s\n",
-	     oh->name, oh->clkdev_dev_id, oh->clkdev_con_id);
+	c = omap_clk_get_by_name(oh->main_clk);
+	WARN(IS_ERR(c), "omap_hwmod: %s: cannot clk_get main_clk %s\n",
+	     oh->name, oh->main_clk);
 	if (IS_ERR(c))
 		ret = -EINVAL;
 	oh->_clk = c;
 
 	WARN(!c->clkdm, "omap_hwmod: %s: missing clockdomain for %s.\n",
-	     oh->clkdev_con_id, c->name);
+	     oh->main_clk, c->name);
 
 	return ret;
 }
@@ -450,13 +450,12 @@ static int _init_interface_clks(struct omap_hwmod *oh)
 		return 0;
 
 	for (i = 0, os = *oh->slaves; i < oh->slaves_cnt; i++, os++) {
-		if (!os->clkdev_con_id)
+		if (!os->clk)
 			continue;
 
-		c = clk_get_sys(os->clkdev_dev_id, os->clkdev_con_id);
+		c = omap_clk_get_by_name(os->clk);
 		WARN(IS_ERR(c), "omap_hwmod: %s: cannot clk_get "
-		     "interface_clk %s.%s\n", oh->name,
-		     os->clkdev_dev_id, os->clkdev_con_id);
+		     "interface_clk %s\n", oh->name, os->clk);
 		if (IS_ERR(c))
 			ret = -EINVAL;
 		os->_clk = c;
@@ -480,10 +479,9 @@ static int _init_opt_clks(struct omap_hwmod *oh)
 	int ret = 0;
 
 	for (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++) {
-		c = clk_get_sys(oc->clkdev_dev_id, oc->clkdev_con_id);
+		c = omap_clk_get_by_name(oc->clk);
 		WARN(IS_ERR(c), "omap_hwmod: %s: cannot clk_get opt_clk "
-		     "%s.%s\n", oh->name, oc->clkdev_dev_id,
-		     oc->clkdev_con_id);
+		     "%s\n", oh->name, oc->clk);
 		if (IS_ERR(c))
 			ret = -EINVAL;
 		oc->_clk = c;

commit 358f0e630d5409ab3837b86db3595560eae773b6
Author: Thara Gopinath <thara@ti.com>
Date:   Wed Feb 24 12:05:58 2010 -0700

    OMAP3: hwmod: support to specify the offset position of various SYSCONFIG register bits.
    
    In OMAP3 Some modules like Smartreflex do not have the regular sysconfig
    register.Instead clockactivity bits are part of another register at a
    different bit position than the usual bit positions 8 and 9.
    
    In OMAP4, a new scheme is available  due to the new protocol
    between the PRCM and the IPs. Depending of the scheme, the SYSCONFIG
    bitfields position will be different.
    The IP_REVISION register should be at offset 0x00.
    It should contain a SCHEME field. From this we can determine whether
    the IP follows legacy scheme or the new scheme.
    
    31:30 SCHEME  Used to distinguish between old scheme and current.
     Read 0x0:  Legacy protocol.
     Read 0x1:  New PRCM protocol defined for new OMAP4 IPs
    
    For legacy IP
     13:12 MIDLEMODE
     11:8  CLOCKACTIVITY
     6     EMUSOFT
     5     EMUFREE
     4:3   SIDLEMODE
     2     ENAWAKEUP
     1     SOFTRESET
     0     AUTOIDLE
    
    For new OMAP4 IP's, the bit position in SYSCONFIG is (for simple target):
     5:4   STANDBYMODE (Ex MIDLEMODE)
     3:2   IDLEMODE (Ex SIDLEMODE)
     1     FREEEMU (Ex EMUFREE)
     0     SOFTRESET
    
    Unfortunately In OMAP4 also some IPs will not follow any of these
    two schemes. This is the case at least for McASP, SmartReflex
    and some security IPs.
    
    This patch introduces a new field sysc_fields in omap_hwmod_sysconfig which
    can be used by the hwmod structures to specify the offsets for the
    sysconfig register of the IP.Also two static structures
    omap_hwmod_sysc_type1 and omap_hwmod_sysc_type2 are defined
    which can be used directly to populate the sysc_fields if the IP follows
    legacy or new OMAP4 scheme. If the IP follows none of these two schemes
    a new omap_hwmod_sysc_fields structure has to be defined and
    passed as part of omap_hwmod_sysconfig.
    
    Signed-off-by: Thara Gopinath <thara@ti.com>
    Signed-off-by: Benoit Cousson <b-cousson@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 70912d1c71e0..fb11ec176d55 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -137,12 +137,24 @@ static void _write_sysconfig(u32 v, struct omap_hwmod *oh)
 static int _set_master_standbymode(struct omap_hwmod *oh, u8 standbymode,
 				   u32 *v)
 {
+	u32 mstandby_mask;
+	u8 mstandby_shift;
+
 	if (!oh->sysconfig ||
 	    !(oh->sysconfig->sysc_flags & SYSC_HAS_MIDLEMODE))
 		return -EINVAL;
 
-	*v &= ~SYSC_MIDLEMODE_MASK;
-	*v |= __ffs(standbymode) << SYSC_MIDLEMODE_SHIFT;
+	if (!oh->sysconfig->sysc_fields) {
+		WARN(!oh->sysconfig->sysc_fields, "offset struct for "
+			"sysconfig not provided!\n");
+		return -EINVAL;
+	}
+
+	mstandby_shift = oh->sysconfig->sysc_fields->midle_shift;
+	mstandby_mask = (0x3 << mstandby_shift);
+
+	*v &= ~mstandby_mask;
+	*v |= __ffs(standbymode) << mstandby_shift;
 
 	return 0;
 }
@@ -159,12 +171,24 @@ static int _set_master_standbymode(struct omap_hwmod *oh, u8 standbymode,
  */
 static int _set_slave_idlemode(struct omap_hwmod *oh, u8 idlemode, u32 *v)
 {
+	u32 sidle_mask;
+	u8 sidle_shift;
+
 	if (!oh->sysconfig ||
 	    !(oh->sysconfig->sysc_flags & SYSC_HAS_SIDLEMODE))
 		return -EINVAL;
 
-	*v &= ~SYSC_SIDLEMODE_MASK;
-	*v |= __ffs(idlemode) << SYSC_SIDLEMODE_SHIFT;
+	if (!oh->sysconfig->sysc_fields) {
+		WARN(!oh->sysconfig->sysc_fields, "offset struct for "
+			"sysconfig not provided!\n");
+		return -EINVAL;
+	}
+
+	sidle_shift = oh->sysconfig->sysc_fields->sidle_shift;
+	sidle_mask = (0x3 << sidle_shift);
+
+	*v &= ~sidle_mask;
+	*v |= __ffs(idlemode) << sidle_shift;
 
 	return 0;
 }
@@ -182,12 +206,24 @@ static int _set_slave_idlemode(struct omap_hwmod *oh, u8 idlemode, u32 *v)
  */
 static int _set_clockactivity(struct omap_hwmod *oh, u8 clockact, u32 *v)
 {
+	u32 clkact_mask;
+	u8  clkact_shift;
+
 	if (!oh->sysconfig ||
 	    !(oh->sysconfig->sysc_flags & SYSC_HAS_CLOCKACTIVITY))
 		return -EINVAL;
 
-	*v &= ~SYSC_CLOCKACTIVITY_MASK;
-	*v |= clockact << SYSC_CLOCKACTIVITY_SHIFT;
+	if (!oh->sysconfig->sysc_fields) {
+		WARN(!oh->sysconfig->sysc_fields, "offset struct for "
+			"sysconfig not provided!\n");
+		return -EINVAL;
+	}
+
+	clkact_shift = oh->sysconfig->sysc_fields->clkact_shift;
+	clkact_mask = (0x3 << clkact_shift);
+
+	*v &= ~clkact_mask;
+	*v |= clockact << clkact_shift;
 
 	return 0;
 }
@@ -202,11 +238,21 @@ static int _set_clockactivity(struct omap_hwmod *oh, u8 clockact, u32 *v)
  */
 static int _set_softreset(struct omap_hwmod *oh, u32 *v)
 {
+	u32 softrst_mask;
+
 	if (!oh->sysconfig ||
 	    !(oh->sysconfig->sysc_flags & SYSC_HAS_SOFTRESET))
 		return -EINVAL;
 
-	*v |= SYSC_SOFTRESET_MASK;
+	if (!oh->sysconfig->sysc_fields) {
+		WARN(!oh->sysconfig->sysc_fields, "offset struct for "
+			"sysconfig not provided!\n");
+		return -EINVAL;
+	}
+
+	softrst_mask = (0x1 << oh->sysconfig->sysc_fields->srst_shift);
+
+	*v |= softrst_mask;
 
 	return 0;
 }
@@ -227,12 +273,24 @@ static int _set_softreset(struct omap_hwmod *oh, u32 *v)
 static int _set_module_autoidle(struct omap_hwmod *oh, u8 autoidle,
 				u32 *v)
 {
+	u32 autoidle_mask;
+	u8 autoidle_shift;
+
 	if (!oh->sysconfig ||
 	    !(oh->sysconfig->sysc_flags & SYSC_HAS_AUTOIDLE))
 		return -EINVAL;
 
-	*v &= ~SYSC_AUTOIDLE_MASK;
-	*v |= autoidle << SYSC_AUTOIDLE_SHIFT;
+	if (!oh->sysconfig->sysc_fields) {
+		WARN(oh->sysconfig->sysc_fields, "offset struct for "
+			"sysconfig not provided!\n");
+		return -EINVAL;
+	}
+
+	autoidle_shift = oh->sysconfig->sysc_fields->autoidle_shift;
+	autoidle_mask = (0x3 << autoidle_shift);
+
+	*v &= ~autoidle_mask;
+	*v |= autoidle << autoidle_shift;
 
 	return 0;
 }
@@ -246,14 +304,22 @@ static int _set_module_autoidle(struct omap_hwmod *oh, u8 autoidle,
  */
 static int _enable_wakeup(struct omap_hwmod *oh)
 {
-	u32 v;
+	u32 v, wakeup_mask;
 
 	if (!oh->sysconfig ||
 	    !(oh->sysconfig->sysc_flags & SYSC_HAS_ENAWAKEUP))
 		return -EINVAL;
 
+	if (!oh->sysconfig->sysc_fields) {
+		WARN(!oh->sysconfig->sysc_fields, "offset struct for "
+			"sysconfig not provided!\n");
+		return -EINVAL;
+	}
+
+	wakeup_mask = (0x1 << oh->sysconfig->sysc_fields->enwkup_shift);
+
 	v = oh->_sysc_cache;
-	v |= SYSC_ENAWAKEUP_MASK;
+	v |= wakeup_mask;
 	_write_sysconfig(v, oh);
 
 	/* XXX test pwrdm_get_wken for this hwmod's subsystem */
@@ -272,14 +338,22 @@ static int _enable_wakeup(struct omap_hwmod *oh)
  */
 static int _disable_wakeup(struct omap_hwmod *oh)
 {
-	u32 v;
+	u32 v, wakeup_mask;
 
 	if (!oh->sysconfig ||
 	    !(oh->sysconfig->sysc_flags & SYSC_HAS_ENAWAKEUP))
 		return -EINVAL;
 
+	if (!oh->sysconfig->sysc_fields) {
+		WARN(!oh->sysconfig->sysc_fields, "offset struct for "
+			"sysconfig not provided!\n");
+		return -EINVAL;
+	}
+
+	wakeup_mask = (0x1 << oh->sysconfig->sysc_fields->enwkup_shift);
+
 	v = oh->_sysc_cache;
-	v &= ~SYSC_ENAWAKEUP_MASK;
+	v &= ~wakeup_mask;
 	_write_sysconfig(v, oh);
 
 	/* XXX test pwrdm_get_wken for this hwmod's subsystem */

commit 46273e6f37bdf3801363986e2228350ecad19059
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Tue Jan 26 20:13:03 2010 -0700

    OMAP: hwmod: add API for slave idlemode setting
    
    Some HW blocks have errata which requires specific slave idle mode
    under certain conditions.
    
    This patch adds an hwmod API to allow setting slave idlemode
    ensuring that any SYSCONFIG register updates go through hwmod.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index ad884c0aaa42..70912d1c71e0 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -992,6 +992,23 @@ void omap_hwmod_writel(u32 v, struct omap_hwmod *oh, u16 reg_offs)
 	__raw_writel(v, oh->_rt_va + reg_offs);
 }
 
+int omap_hwmod_set_slave_idlemode(struct omap_hwmod *oh, u8 idlemode)
+{
+	u32 v;
+	int retval = 0;
+
+	if (!oh)
+		return -EINVAL;
+
+	v = oh->_sysc_cache;
+
+	retval = _set_slave_idlemode(oh, idlemode, &v);
+	if (!retval)
+		_write_sysconfig(v, oh);
+
+	return retval;
+}
+
 /**
  * omap_hwmod_register - register a struct omap_hwmod
  * @oh: struct omap_hwmod *

commit 55ed96945b1f3d0f4ad21a27b32ce4bd99d8c268
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Jan 26 20:12:59 2010 -0700

    OMAP2/3 clkdm/pwrdm: move wkdep/sleepdep handling from pwrdm to clkdm
    
    Move clockdomain wakeup dependency and sleep dependency data
    structures from the powerdomain layer to the clockdomain layer, where
    they belong.  These dependencies were originally placed in the
    powerdomain layer due to unclear documentation; however, it is clear
    now that these dependencies are between clockdomains.  For OMAP2/3,
    this is not such a big problem, but for OMAP4 this needs to be fixed.
    
    Thanks to Benot Cousson <b-cousson@ti.com> for his advice on this
    patch.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 478ae585ca39..ad884c0aaa42 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -299,15 +299,14 @@ static int _disable_wakeup(struct omap_hwmod *oh)
  * be accessed by the IVA, there should be a sleepdep between the IVA
  * initiator and the module).  Only applies to modules in smart-idle
  * mode.  Returns -EINVAL upon error or passes along
- * pwrdm_add_sleepdep() value upon success.
+ * clkdm_add_sleepdep() value upon success.
  */
 static int _add_initiator_dep(struct omap_hwmod *oh, struct omap_hwmod *init_oh)
 {
 	if (!oh->_clk)
 		return -EINVAL;
 
-	return pwrdm_add_sleepdep(oh->_clk->clkdm->pwrdm.ptr,
-				  init_oh->_clk->clkdm->pwrdm.ptr);
+	return clkdm_add_sleepdep(oh->_clk->clkdm, init_oh->_clk->clkdm);
 }
 
 /**
@@ -320,15 +319,14 @@ static int _add_initiator_dep(struct omap_hwmod *oh, struct omap_hwmod *init_oh)
  * be accessed by the IVA, there should be no sleepdep between the IVA
  * initiator and the module).  Only applies to modules in smart-idle
  * mode.  Returns -EINVAL upon error or passes along
- * pwrdm_add_sleepdep() value upon success.
+ * clkdm_del_sleepdep() value upon success.
  */
 static int _del_initiator_dep(struct omap_hwmod *oh, struct omap_hwmod *init_oh)
 {
 	if (!oh->_clk)
 		return -EINVAL;
 
-	return pwrdm_del_sleepdep(oh->_clk->clkdm->pwrdm.ptr,
-				  init_oh->_clk->clkdm->pwrdm.ptr);
+	return clkdm_del_sleepdep(oh->_clk->clkdm, init_oh->_clk->clkdm);
 }
 
 /**

commit 883edfdd58419b0cc298db14ba25c26d55c6d1af
Author: Thara Gopinath <thara@ti.com>
Date:   Tue Jan 19 17:30:51 2010 -0700

    OMAP3: hwmod: Adding flag to prevent caching of sysconfig register.
    
    In the current implementation the sysconfig value is read into
     _sysc_cache once and an actual update to the sysconfig register
    happens only if the new value paased is differnt from the one in _sysc_cache.
    _sysc_cache is updated only if _HWMOD_SYSCONFIG_LOADED is not set.
    This can lead to the follwing issue if off mode is enabled in modules
    which employs "always-retore" mechanism of context save and restore.
    
            a. The module sets the sysconfig register through omap_device_enable.
               Here _sysc_cache is updated with the value written to the sysconfig
               register and left.
            b. The power domain containig the module enters off mode and the
               module context is lost.
            c. The module in use becomes active and calls omap_device_enable to
               enable itself. Here a read of sysconfig register does not happen
               as _HWMOD_SYSCONFIG_LOADED flag is set. The value to be written
               to the sysconfig register will be same as the one written in step a.
               Since _sysc_cache reflects the previous written value an update
               of the sysconfig register does not happen.
    This means in modules which employs "always-restore" mechanism
    after off , the sysconfig regsiters will never get updated.
    
    This patch introduces a flag SYSC_NO_CACHE which if set ensures that the
    sysconfig register is always read into _sysc_cache before an update is
    attempted.
    
    This flags need to be set only by modules which does not do a context save
    but re-initializes the registers every time the module is accessed. This
    includes modules like i2c, smartreflex etc.
    
    Signed-off-by: Thara Gopinath <thara@ti.com>
    [paul@pwsan.com: tweaked to apply on a different head, added flag comment]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index d8c8545875b1..478ae585ca39 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -94,7 +94,8 @@ static int _update_sysc_cache(struct omap_hwmod *oh)
 
 	oh->_sysc_cache = omap_hwmod_readl(oh, oh->sysconfig->sysc_offs);
 
-	oh->_int_flags |= _HWMOD_SYSCONFIG_LOADED;
+	if (!(oh->sysconfig->sysc_flags & SYSC_NO_CACHE))
+		oh->_int_flags |= _HWMOD_SYSCONFIG_LOADED;
 
 	return 0;
 }

commit 81d7c6ffccd1d5369942c428faa9ee25a3d59db8
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Tue Dec 8 16:34:24 2009 -0700

    OMAP: hwmod: warn on missing clockdomain
    
    WARN if a clock/hwmod is missing a clockdomain association since
    resulting hwmod will not be able to correctly enable/disable clocks.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index bfbd34142b37..d8c8545875b1 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -353,6 +353,9 @@ static int _init_main_clk(struct omap_hwmod *oh)
 		ret = -EINVAL;
 	oh->_clk = c;
 
+	WARN(!c->clkdm, "omap_hwmod: %s: missing clockdomain for %s.\n",
+	     oh->clkdev_con_id, c->name);
+
 	return ret;
 }
 

commit a16b1f7f8692163e0c6b4741d8980837dfca75f1
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 8 16:34:17 2009 -0700

    OMAP3 hwmod: drop most of the OCP_SYSCONFIG.CLOCKACTIVITY code
    
    Earlier, the hwmod code had considered the OCP_SYSCONFIG.CLOCKACTIVITY
    bits to be incremental power saving bits, controlling internal IP
    block clock gates.  This was a misapprehension.  The CLOCKACTIVITY
    bits are used to indicate, in advance, which clocks will be cut when
    the module acknowledges an idle request.  This enables the IP block to
    take whatever action is necessary to complete any in-progress work
    before asserting its IdleAck.
    
    In the current Linux-OMAP code, this implies that the clock framework
    should be changing module CLOCKACTIVITY bits as module clocks are enabled
    and disabled.  We don't do that yet, but in the future, we should.
    This must wait until the clock tree is annotated with omap_hwmod pointers
    (or vice-versa).  In the meantime, drop most of the hwmod code that
    controls CLOCKACTIVITY bits to avoid confusion.
    
    This patch has benefited from many illuminating discussions with (in
    alphabetical order) Benot Cousson <b-cousson@ti.com>, Rajendra Nayak
    <rnayak@ti.com>, and Sebastien Sabatier <s-sabatier1@ti.com>.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Cc: Sebastien Sabatier <s-sabatier1@ti.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 61d220c5d488..bfbd34142b37 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -592,6 +592,11 @@ static void _sysc_enable(struct omap_hwmod *oh)
 
 	/* XXX OCP ENAWAKEUP bit? */
 
+	/*
+	 * XXX The clock framework should handle this, by
+	 * calling into this code.  But this must wait until the
+	 * clock structures are tagged with omap_hwmod entries
+	 */
 	if (oh->flags & HWMOD_SET_DEFAULT_CLOCKACT &&
 	    oh->sysconfig->sysc_flags & SYSC_HAS_CLOCKACTIVITY)
 		_set_clockactivity(oh, oh->sysconfig->clockact, &v);
@@ -913,33 +918,6 @@ static int _shutdown(struct omap_hwmod *oh)
 	return 0;
 }
 
-/**
- * _write_clockact_lock - set the module's clockactivity bits
- * @oh: struct omap_hwmod *
- * @clockact: CLOCKACTIVITY field bits
- *
- * Writes the CLOCKACTIVITY bits @clockact to the hwmod @oh
- * OCP_SYSCONFIG register.  Returns -EINVAL if the hwmod is in the
- * wrong state or returns 0.
- */
-static int _write_clockact_lock(struct omap_hwmod *oh, u8 clockact)
-{
-	u32 v;
-
-	if (!oh->sysconfig ||
-	    !(oh->sysconfig->sysc_flags & SYSC_HAS_CLOCKACTIVITY))
-		return -EINVAL;
-
-	mutex_lock(&omap_hwmod_mutex);
-	v = oh->_sysc_cache;
-	_set_clockactivity(oh, clockact, &v);
-	_write_sysconfig(v, oh);
-	mutex_unlock(&omap_hwmod_mutex);
-
-	return 0;
-}
-
-
 /**
  * _setup - do initial configuration of omap_hwmod
  * @oh: struct omap_hwmod *
@@ -1492,62 +1470,6 @@ int omap_hwmod_del_initiator_dep(struct omap_hwmod *oh,
 	return _del_initiator_dep(oh, init_oh);
 }
 
-/**
- * omap_hwmod_set_clockact_none - set clockactivity test to BOTH
- * @oh: struct omap_hwmod *
- *
- * On some modules, this function can affect the wakeup latency vs.
- * power consumption balance.  Intended to be called by the
- * omap_device layer.  Passes along the return value from
- * _write_clockact_lock().
- */
-int omap_hwmod_set_clockact_both(struct omap_hwmod *oh)
-{
-	return _write_clockact_lock(oh, CLOCKACT_TEST_BOTH);
-}
-
-/**
- * omap_hwmod_set_clockact_none - set clockactivity test to MAIN
- * @oh: struct omap_hwmod *
- *
- * On some modules, this function can affect the wakeup latency vs.
- * power consumption balance.  Intended to be called by the
- * omap_device layer.  Passes along the return value from
- * _write_clockact_lock().
- */
-int omap_hwmod_set_clockact_main(struct omap_hwmod *oh)
-{
-	return _write_clockact_lock(oh, CLOCKACT_TEST_MAIN);
-}
-
-/**
- * omap_hwmod_set_clockact_none - set clockactivity test to ICLK
- * @oh: struct omap_hwmod *
- *
- * On some modules, this function can affect the wakeup latency vs.
- * power consumption balance.  Intended to be called by the
- * omap_device layer.  Passes along the return value from
- * _write_clockact_lock().
- */
-int omap_hwmod_set_clockact_iclk(struct omap_hwmod *oh)
-{
-	return _write_clockact_lock(oh, CLOCKACT_TEST_ICLK);
-}
-
-/**
- * omap_hwmod_set_clockact_none - set clockactivity test to NONE
- * @oh: struct omap_hwmod *
- *
- * On some modules, this function can affect the wakeup latency vs.
- * power consumption balance.  Intended to be called by the
- * omap_device layer.  Passes along the return value from
- * _write_clockact_lock().
- */
-int omap_hwmod_set_clockact_none(struct omap_hwmod *oh)
-{
-	return _write_clockact_lock(oh, CLOCKACT_TEST_NONE);
-}
-
 /**
  * omap_hwmod_enable_wakeup - allow device to wake up the system
  * @oh: struct omap_hwmod *

commit 718bfd76932c566f79eb55083693ef0b68071bf8
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 8 16:34:16 2009 -0700

    OMAP hwmod: add names to module MPU IRQ lines
    
    Replace the existing u8 array of module MPU IRQ lines with a struct
    that includes a name - similar to the existing struct
    omap_hwmod_dma_info.  Device drivers can then use
    platform_get_resource_byname() to retrieve specific IRQs without nasty
    dependencies on array ordering.
    
    Thanks to Benot Cousson <b-cousson@ti.com> and Kevin Hilman
    <khilman@deeprootsystems.com> for feedback on this approach.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index b01da1ed822d..61d220c5d488 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1386,8 +1386,9 @@ int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
 	/* For each IRQ, DMA, memory area, fill in array.*/
 
 	for (i = 0; i < oh->mpu_irqs_cnt; i++) {
-		(res + r)->start = *(oh->mpu_irqs + i);
-		(res + r)->end = *(oh->mpu_irqs + i);
+		(res + r)->name = (oh->mpu_irqs + i)->name;
+		(res + r)->start = (oh->mpu_irqs + i)->irq;
+		(res + r)->end = (oh->mpu_irqs + i)->irq;
 		(res + r)->flags = IORESOURCE_IRQ;
 		r++;
 	}

commit 726072e5dd459e3831d1dd4308ba469ff3ded419
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 8 16:34:15 2009 -0700

    OMAP3 hwmod: Add automatic OCP_SYSCONFIG AUTOIDLE handling
    
    This patch fills in the OCP_SYSCONFIG.AUTOIDLE handling in the OMAP
    hwmod code.
    
    After this patch, the hwmod code will set the module AUTOIDLE bit
    (generally <module>.OCP_SYSCONFIG.AUTOIDLE) to 1 by default upon
    enable.  If the hwmod flag HWMOD_NO_OCP_AUTOIDLE is set, AUTOIDLE will
    be set to 0 upon enable.  Upon module disable, AUTOIDLE will be set to
    1.
    
    Enabling module autoidle should save some power.  The only reason to
    not set the OCP_SYSCONFIG.AUTOIDLE bit is if there is a bug in the
    module RTL, e.g., the MPUINTC block on OMAP3.
    
    Comments from Kevin Hilman <khilman@deeprootsystems.com> inspired this patch,
    and Kevin tested an earlier version of this patch.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 65a8e0ae394f..b01da1ed822d 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -210,6 +210,32 @@ static int _set_softreset(struct omap_hwmod *oh, u32 *v)
 	return 0;
 }
 
+/**
+ * _set_module_autoidle: set the OCP_SYSCONFIG AUTOIDLE field in @v
+ * @oh: struct omap_hwmod *
+ * @autoidle: desired AUTOIDLE bitfield value (0 or 1)
+ * @v: pointer to register contents to modify
+ *
+ * Update the module autoidle bit in @v to be @autoidle for the @oh
+ * hwmod.  The autoidle bit controls whether the module can gate
+ * internal clocks automatically when it isn't doing anything; the
+ * exact function of this bit varies on a per-module basis.  This
+ * function does not write to the hardware.  Returns -EINVAL upon
+ * error or 0 upon success.
+ */
+static int _set_module_autoidle(struct omap_hwmod *oh, u8 autoidle,
+				u32 *v)
+{
+	if (!oh->sysconfig ||
+	    !(oh->sysconfig->sysc_flags & SYSC_HAS_AUTOIDLE))
+		return -EINVAL;
+
+	*v &= ~SYSC_AUTOIDLE_MASK;
+	*v |= autoidle << SYSC_AUTOIDLE_SHIFT;
+
+	return 0;
+}
+
 /**
  * _enable_wakeup: set OCP_SYSCONFIG.ENAWAKEUP bit in the hardware
  * @oh: struct omap_hwmod *
@@ -558,7 +584,13 @@ static void _sysc_enable(struct omap_hwmod *oh)
 		_set_master_standbymode(oh, idlemode, &v);
 	}
 
-	/* XXX OCP AUTOIDLE bit? */
+	if (oh->sysconfig->sysc_flags & SYSC_HAS_AUTOIDLE) {
+		idlemode = (oh->flags & HWMOD_NO_OCP_AUTOIDLE) ?
+			0 : 1;
+		_set_module_autoidle(oh, idlemode, &v);
+	}
+
+	/* XXX OCP ENAWAKEUP bit? */
 
 	if (oh->flags & HWMOD_SET_DEFAULT_CLOCKACT &&
 	    oh->sysconfig->sysc_flags & SYSC_HAS_CLOCKACTIVITY)
@@ -623,7 +655,8 @@ static void _sysc_shutdown(struct omap_hwmod *oh)
 	if (oh->sysconfig->sysc_flags & SYSC_HAS_MIDLEMODE)
 		_set_master_standbymode(oh, HWMOD_IDLEMODE_FORCE, &v);
 
-	/* XXX clear OCP AUTOIDLE bit? */
+	if (oh->sysconfig->sysc_flags & SYSC_HAS_AUTOIDLE)
+		_set_module_autoidle(oh, 1, &v);
 
 	_write_sysconfig(v, oh);
 }

commit b835d0142196466c5ff3695b90cff1e3ea635c8e
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 8 16:34:14 2009 -0700

    OMAP3 hwmod: reprogram OCP_SYSCONFIG register after setting SOFTRESET
    
    Reprogram the module's OCP_SYSCONFIG register after module reset (SOFTRESET
    = 1).  This may not be needed, but the definition of the reset performed by
    the SOFTRESET bit is unclear.
    
    Kevin Hilman <khilman@deeprootsystems.com> tested an earlier version of
    this patch.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 7aaf5f1eea7a..65a8e0ae394f 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -945,11 +945,19 @@ static int _setup(struct omap_hwmod *oh)
 
 	_enable(oh);
 
-	if (!(oh->flags & HWMOD_INIT_NO_RESET))
-		_reset(oh);
-
-	/* XXX OCP AUTOIDLE bit? */
-	/* XXX OCP ENAWAKEUP bit? */
+	if (!(oh->flags & HWMOD_INIT_NO_RESET)) {
+		/*
+		 * XXX Do the OCP_SYSCONFIG bits need to be
+		 * reprogrammed after a reset?  If not, then this can
+		 * be removed.  If they do, then probably the
+		 * _enable() function should be split to avoid the
+		 * rewrite of the OCP_SYSCONFIG register.
+		 */
+		if (oh->sysconfig) {
+			_update_sysc_cache(oh);
+			_sysc_enable(oh);
+		}
+	}
 
 	if (!(oh->flags & HWMOD_INIT_NO_IDLE))
 		_idle(oh);

commit 6f8b7ff5b01e16a65c3b17865ce047faeca40907
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 8 16:33:16 2009 -0700

    OMAP clock/hwmod: fix off-by-one errors
    
    Fix loop bailout off-by-one bugs reported by Juha Leppnen
    <juha_motorsportcom@luukku.com>.
    
    This second version incorporates comments from Russell King
    <linux@arm.linux.org.uk>.  A new macro, 'omap_test_timeout', has
    been created, with cleaner code, and existing code has been converted
    to use it.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Juha Leppnen <juha_motorsportcom@luukku.com>
    Cc: Russell King <linux@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 633b216a8b26..7aaf5f1eea7a 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -45,6 +45,7 @@
 #include <linux/mutex.h>
 #include <linux/bootmem.h>
 
+#include <plat/common.h>
 #include <plat/cpu.h>
 #include <plat/clockdomain.h>
 #include <plat/powerdomain.h>
@@ -736,7 +737,7 @@ static int _wait_target_ready(struct omap_hwmod *oh)
 static int _reset(struct omap_hwmod *oh)
 {
 	u32 r, v;
-	int c;
+	int c = 0;
 
 	if (!oh->sysconfig ||
 	    !(oh->sysconfig->sysc_flags & SYSC_HAS_SOFTRESET) ||
@@ -758,13 +759,9 @@ static int _reset(struct omap_hwmod *oh)
 		return r;
 	_write_sysconfig(v, oh);
 
-	c = 0;
-	while (c < MAX_MODULE_RESET_WAIT &&
-	       !(omap_hwmod_readl(oh, oh->sysconfig->syss_offs) &
-		 SYSS_RESETDONE_MASK)) {
-		udelay(1);
-		c++;
-	}
+	omap_test_timeout((omap_hwmod_readl(oh, oh->sysconfig->syss_offs) &
+			   SYSS_RESETDONE_MASK),
+			  MAX_MODULE_RESET_WAIT, c);
 
 	if (c == MAX_MODULE_RESET_WAIT)
 		WARN(1, "omap_hwmod: %s: failed to reset in %d usec\n",

commit ce491cf85466c3377228c5a852ea627ec5136956
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 20 09:40:47 2009 -0700

    omap: headers: Move remaining headers from include/mach to include/plat
    
    Move the remaining headers under plat-omap/include/mach
    to plat-omap/include/plat. Also search and replace the
    files using these headers to include using the right path.
    
    This was done with:
    
    #!/bin/bash
    mach_dir_old="arch/arm/plat-omap/include/mach"
    plat_dir_new="arch/arm/plat-omap/include/plat"
    headers=$(cd $mach_dir_old && ls *.h)
    omap_dirs="arch/arm/*omap*/ \
    drivers/video/omap \
    sound/soc/omap"
    other_files="drivers/leds/leds-ams-delta.c \
    drivers/mfd/menelaus.c \
    drivers/mfd/twl4030-core.c \
    drivers/mtd/nand/ams-delta.c"
    
    for header in $headers; do
            old="#include <mach\/$header"
            new="#include <plat\/$header"
            for dir in $omap_dirs; do
                    find $dir -type f -name \*.[chS] | \
                            xargs sed -i "s/$old/$new/"
            done
            find drivers/ -type f -name \*omap*.[chS] | \
                    xargs sed -i "s/$old/$new/"
            for file in $other_files; do
                    sed -i "s/$old/$new/" $file
            done
    done
    
    for header in $(ls $mach_dir_old/*.h); do
            git mv $header $plat_dir_new/
    done
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 8ac8798feb92..633b216a8b26 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -45,11 +45,11 @@
 #include <linux/mutex.h>
 #include <linux/bootmem.h>
 
-#include <mach/cpu.h>
-#include <mach/clockdomain.h>
-#include <mach/powerdomain.h>
-#include <mach/clock.h>
-#include <mach/omap_hwmod.h>
+#include <plat/cpu.h>
+#include <plat/clockdomain.h>
+#include <plat/powerdomain.h>
+#include <plat/clock.h>
+#include <plat/omap_hwmod.h>
 
 #include "cm.h"
 

commit 986a13f508156e1d041d59166beb2a3dec2ddfad
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Oct 19 15:25:22 2009 -0700

    omap: Use ioremap in omap_hwmod.c
    
    Use ioremap in omap_hwmod.c
    
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index d2e0f1c95961..8ac8798feb92 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -496,6 +496,7 @@ static void __iomem *_find_mpu_rt_base(struct omap_hwmod *oh, u8 index)
 	struct omap_hwmod_addr_space *mem;
 	int i;
 	int found = 0;
+	void __iomem *va_start;
 
 	if (!oh || oh->slaves_cnt == 0)
 		return NULL;
@@ -509,16 +510,20 @@ static void __iomem *_find_mpu_rt_base(struct omap_hwmod *oh, u8 index)
 		}
 	}
 
-	/* XXX use ioremap() instead? */
-
-	if (found)
+	if (found) {
+		va_start = ioremap(mem->pa_start, mem->pa_end - mem->pa_start);
+		if (!va_start) {
+			pr_err("omap_hwmod: %s: Could not ioremap\n", oh->name);
+			return NULL;
+		}
 		pr_debug("omap_hwmod: %s: MPU register target at va %p\n",
-			 oh->name, OMAP2_IO_ADDRESS(mem->pa_start));
-	else
+			 oh->name, va_start);
+	} else {
 		pr_debug("omap_hwmod: %s: no MPU register target found\n",
 			 oh->name);
+	}
 
-	return (found) ? OMAP2_IO_ADDRESS(mem->pa_start) : NULL;
+	return (found) ? va_start : NULL;
 }
 
 /**
@@ -1148,6 +1153,7 @@ int omap_hwmod_unregister(struct omap_hwmod *oh)
 	pr_debug("omap_hwmod: %s: unregistering\n", oh->name);
 
 	mutex_lock(&omap_hwmod_mutex);
+	iounmap(oh->_rt_va);
 	list_del(&oh->node);
 	mutex_unlock(&omap_hwmod_mutex);
 

commit 02bfc030e4417003b7a94393102c92e39b2dfa65
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Sep 3 20:14:05 2009 +0300

    OMAP: omap_hwmod: call omap_hwmod init at boot; create interconnects
    
    Connect the omap_hwmod code to the kernel boot.  Create some basic
    interconnect and device structures for OMAP2/3 chips.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 3b10ad6c47d3..d2e0f1c95961 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -765,8 +765,7 @@ static int _reset(struct omap_hwmod *oh)
 		WARN(1, "omap_hwmod: %s: failed to reset in %d usec\n",
 		     oh->name, MAX_MODULE_RESET_WAIT);
 	else
-		pr_debug("omap_hwmod: %s: reset in %d usec\n", oh->name,
-			 MAX_MODULE_RESET_WAIT);
+		pr_debug("omap_hwmod: %s: reset in %d usec\n", oh->name, c);
 
 	/*
 	 * XXX add _HWMOD_STATE_WEDGED for modules that don't come back from

commit 63c852384125ca0eff0e695f92cbbd439bed4aa3
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Sep 3 20:14:03 2009 +0300

    OMAP2/3/4: create omap_hwmod layer
    
    OMAP SoCs can be considered a collection of hardware IP blocks
    connected by various interconnects.  The bus topology and device
    integration data is somewhat more complex than platform_device can
    encode.  This patch creates code and structures to manage information
    about OMAP on-chip devices ("hardware modules") and their integration
    to the rest of the chip.  Hardware module data is intended to be
    generated dynamically from the TI hardware database for the OMAP4
    chips and beyond, easing Linux support for new chip variants.
    
    This code currently:
    
    - resets and configures all hardware modules upon startup, reducing bootloader
      dependencies;
    
    - provides hooks for Linux driver model code to enable, idle, and shutdown
      hardware modules (forthcoming patch);
    
    - waits for hardware modules to leave idle once their clocks
      are enabled and OCP_SYSCONFIG bits are set appropriately.
    
    - provides a means to pass arbitrary IP block configuration data (e.g.,
      FIFO size) to the device driver (via the dev_attr void pointer)
    
    In the future this code is intended to:
    
    - estimate interconnect bandwidth and latency characteristics to
      ensure constraints are satisfied during DVFS
    
    - provide *GRPSEL bit data to the powerdomain code
    
    - handle pin/ball muxing for devices
    
    - generate IO mapping information dynamically
    
    - supply device firewall configuration data
    
    - provide hardware module data to other on-chip coprocessor software
    
    - allow the removal of the "disable unused clocks" code in the OMAP2/3
      clock code
    
    This patch represents a collaborative effort involving many people from TI,
    Nokia, and the Linux-OMAP community.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Cc: Vikram Pandita <vikram.pandita@ti.com>
    Cc: Sakari Poussa <sakari.poussa@nokia.com>
    Cc: Anand Sawant <sawant@ti.com>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Eric Thomas <ethomas@ti.com>
    Cc: Richard Woodruff <r-woodruff2@ti.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
new file mode 100644
index 000000000000..3b10ad6c47d3
--- /dev/null
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -0,0 +1,1555 @@
+/*
+ * omap_hwmod implementation for OMAP2/3/4
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ * Paul Walmsley
+ * With fixes and testing from Kevin Hilman
+ *
+ * Created in collaboration with (alphabetical order): Benoit Cousson,
+ * Kevin Hilman, Tony Lindgren, Rajendra Nayak, Vikram Pandita, Sakari
+ * Poussa, Anand Sawant, Santosh Shilimkar, Richard Woodruff
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This code manages "OMAP modules" (on-chip devices) and their
+ * integration with Linux device driver and bus code.
+ *
+ * References:
+ * - OMAP2420 Multimedia Processor Silicon Revision 2.1.1, 2.2 (SWPU064)
+ * - OMAP2430 Multimedia Device POP Silicon Revision 2.1 (SWPU090)
+ * - OMAP34xx Multimedia Device Silicon Revision 3.1 (SWPU108)
+ * - OMAP4430 Multimedia Device Silicon Revision 1.0 (SWPU140)
+ * - Open Core Protocol Specification 2.2
+ *
+ * To do:
+ * - pin mux handling
+ * - handle IO mapping
+ * - bus throughput & module latency measurement code
+ *
+ * XXX add tests at the beginning of each function to ensure the hwmod is
+ * in the appropriate state
+ * XXX error return values should be checked to ensure that they are
+ * appropriate
+ */
+#undef DEBUG
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/bootmem.h>
+
+#include <mach/cpu.h>
+#include <mach/clockdomain.h>
+#include <mach/powerdomain.h>
+#include <mach/clock.h>
+#include <mach/omap_hwmod.h>
+
+#include "cm.h"
+
+/* Maximum microseconds to wait for OMAP module to reset */
+#define MAX_MODULE_RESET_WAIT		10000
+
+/* Name of the OMAP hwmod for the MPU */
+#define MPU_INITIATOR_NAME		"mpu_hwmod"
+
+/* omap_hwmod_list contains all registered struct omap_hwmods */
+static LIST_HEAD(omap_hwmod_list);
+
+static DEFINE_MUTEX(omap_hwmod_mutex);
+
+/* mpu_oh: used to add/remove MPU initiator from sleepdep list */
+static struct omap_hwmod *mpu_oh;
+
+/* inited: 0 if omap_hwmod_init() has not yet been called; 1 otherwise */
+static u8 inited;
+
+
+/* Private functions */
+
+/**
+ * _update_sysc_cache - return the module OCP_SYSCONFIG register, keep copy
+ * @oh: struct omap_hwmod *
+ *
+ * Load the current value of the hwmod OCP_SYSCONFIG register into the
+ * struct omap_hwmod for later use.  Returns -EINVAL if the hwmod has no
+ * OCP_SYSCONFIG register or 0 upon success.
+ */
+static int _update_sysc_cache(struct omap_hwmod *oh)
+{
+	if (!oh->sysconfig) {
+		WARN(!oh->sysconfig, "omap_hwmod: %s: cannot read "
+		     "OCP_SYSCONFIG: not defined on hwmod\n", oh->name);
+		return -EINVAL;
+	}
+
+	/* XXX ensure module interface clock is up */
+
+	oh->_sysc_cache = omap_hwmod_readl(oh, oh->sysconfig->sysc_offs);
+
+	oh->_int_flags |= _HWMOD_SYSCONFIG_LOADED;
+
+	return 0;
+}
+
+/**
+ * _write_sysconfig - write a value to the module's OCP_SYSCONFIG register
+ * @v: OCP_SYSCONFIG value to write
+ * @oh: struct omap_hwmod *
+ *
+ * Write @v into the module OCP_SYSCONFIG register, if it has one.  No
+ * return value.
+ */
+static void _write_sysconfig(u32 v, struct omap_hwmod *oh)
+{
+	if (!oh->sysconfig) {
+		WARN(!oh->sysconfig, "omap_hwmod: %s: cannot write "
+		     "OCP_SYSCONFIG: not defined on hwmod\n", oh->name);
+		return;
+	}
+
+	/* XXX ensure module interface clock is up */
+
+	if (oh->_sysc_cache != v) {
+		oh->_sysc_cache = v;
+		omap_hwmod_writel(v, oh, oh->sysconfig->sysc_offs);
+	}
+}
+
+/**
+ * _set_master_standbymode: set the OCP_SYSCONFIG MIDLEMODE field in @v
+ * @oh: struct omap_hwmod *
+ * @standbymode: MIDLEMODE field bits
+ * @v: pointer to register contents to modify
+ *
+ * Update the master standby mode bits in @v to be @standbymode for
+ * the @oh hwmod.  Does not write to the hardware.  Returns -EINVAL
+ * upon error or 0 upon success.
+ */
+static int _set_master_standbymode(struct omap_hwmod *oh, u8 standbymode,
+				   u32 *v)
+{
+	if (!oh->sysconfig ||
+	    !(oh->sysconfig->sysc_flags & SYSC_HAS_MIDLEMODE))
+		return -EINVAL;
+
+	*v &= ~SYSC_MIDLEMODE_MASK;
+	*v |= __ffs(standbymode) << SYSC_MIDLEMODE_SHIFT;
+
+	return 0;
+}
+
+/**
+ * _set_slave_idlemode: set the OCP_SYSCONFIG SIDLEMODE field in @v
+ * @oh: struct omap_hwmod *
+ * @idlemode: SIDLEMODE field bits
+ * @v: pointer to register contents to modify
+ *
+ * Update the slave idle mode bits in @v to be @idlemode for the @oh
+ * hwmod.  Does not write to the hardware.  Returns -EINVAL upon error
+ * or 0 upon success.
+ */
+static int _set_slave_idlemode(struct omap_hwmod *oh, u8 idlemode, u32 *v)
+{
+	if (!oh->sysconfig ||
+	    !(oh->sysconfig->sysc_flags & SYSC_HAS_SIDLEMODE))
+		return -EINVAL;
+
+	*v &= ~SYSC_SIDLEMODE_MASK;
+	*v |= __ffs(idlemode) << SYSC_SIDLEMODE_SHIFT;
+
+	return 0;
+}
+
+/**
+ * _set_clockactivity: set OCP_SYSCONFIG.CLOCKACTIVITY bits in @v
+ * @oh: struct omap_hwmod *
+ * @clockact: CLOCKACTIVITY field bits
+ * @v: pointer to register contents to modify
+ *
+ * Update the clockactivity mode bits in @v to be @clockact for the
+ * @oh hwmod.  Used for additional powersaving on some modules.  Does
+ * not write to the hardware.  Returns -EINVAL upon error or 0 upon
+ * success.
+ */
+static int _set_clockactivity(struct omap_hwmod *oh, u8 clockact, u32 *v)
+{
+	if (!oh->sysconfig ||
+	    !(oh->sysconfig->sysc_flags & SYSC_HAS_CLOCKACTIVITY))
+		return -EINVAL;
+
+	*v &= ~SYSC_CLOCKACTIVITY_MASK;
+	*v |= clockact << SYSC_CLOCKACTIVITY_SHIFT;
+
+	return 0;
+}
+
+/**
+ * _set_softreset: set OCP_SYSCONFIG.CLOCKACTIVITY bits in @v
+ * @oh: struct omap_hwmod *
+ * @v: pointer to register contents to modify
+ *
+ * Set the SOFTRESET bit in @v for hwmod @oh.  Returns -EINVAL upon
+ * error or 0 upon success.
+ */
+static int _set_softreset(struct omap_hwmod *oh, u32 *v)
+{
+	if (!oh->sysconfig ||
+	    !(oh->sysconfig->sysc_flags & SYSC_HAS_SOFTRESET))
+		return -EINVAL;
+
+	*v |= SYSC_SOFTRESET_MASK;
+
+	return 0;
+}
+
+/**
+ * _enable_wakeup: set OCP_SYSCONFIG.ENAWAKEUP bit in the hardware
+ * @oh: struct omap_hwmod *
+ *
+ * Allow the hardware module @oh to send wakeups.  Returns -EINVAL
+ * upon error or 0 upon success.
+ */
+static int _enable_wakeup(struct omap_hwmod *oh)
+{
+	u32 v;
+
+	if (!oh->sysconfig ||
+	    !(oh->sysconfig->sysc_flags & SYSC_HAS_ENAWAKEUP))
+		return -EINVAL;
+
+	v = oh->_sysc_cache;
+	v |= SYSC_ENAWAKEUP_MASK;
+	_write_sysconfig(v, oh);
+
+	/* XXX test pwrdm_get_wken for this hwmod's subsystem */
+
+	oh->_int_flags |= _HWMOD_WAKEUP_ENABLED;
+
+	return 0;
+}
+
+/**
+ * _disable_wakeup: clear OCP_SYSCONFIG.ENAWAKEUP bit in the hardware
+ * @oh: struct omap_hwmod *
+ *
+ * Prevent the hardware module @oh to send wakeups.  Returns -EINVAL
+ * upon error or 0 upon success.
+ */
+static int _disable_wakeup(struct omap_hwmod *oh)
+{
+	u32 v;
+
+	if (!oh->sysconfig ||
+	    !(oh->sysconfig->sysc_flags & SYSC_HAS_ENAWAKEUP))
+		return -EINVAL;
+
+	v = oh->_sysc_cache;
+	v &= ~SYSC_ENAWAKEUP_MASK;
+	_write_sysconfig(v, oh);
+
+	/* XXX test pwrdm_get_wken for this hwmod's subsystem */
+
+	oh->_int_flags &= ~_HWMOD_WAKEUP_ENABLED;
+
+	return 0;
+}
+
+/**
+ * _add_initiator_dep: prevent @oh from smart-idling while @init_oh is active
+ * @oh: struct omap_hwmod *
+ *
+ * Prevent the hardware module @oh from entering idle while the
+ * hardare module initiator @init_oh is active.  Useful when a module
+ * will be accessed by a particular initiator (e.g., if a module will
+ * be accessed by the IVA, there should be a sleepdep between the IVA
+ * initiator and the module).  Only applies to modules in smart-idle
+ * mode.  Returns -EINVAL upon error or passes along
+ * pwrdm_add_sleepdep() value upon success.
+ */
+static int _add_initiator_dep(struct omap_hwmod *oh, struct omap_hwmod *init_oh)
+{
+	if (!oh->_clk)
+		return -EINVAL;
+
+	return pwrdm_add_sleepdep(oh->_clk->clkdm->pwrdm.ptr,
+				  init_oh->_clk->clkdm->pwrdm.ptr);
+}
+
+/**
+ * _del_initiator_dep: allow @oh to smart-idle even if @init_oh is active
+ * @oh: struct omap_hwmod *
+ *
+ * Allow the hardware module @oh to enter idle while the hardare
+ * module initiator @init_oh is active.  Useful when a module will not
+ * be accessed by a particular initiator (e.g., if a module will not
+ * be accessed by the IVA, there should be no sleepdep between the IVA
+ * initiator and the module).  Only applies to modules in smart-idle
+ * mode.  Returns -EINVAL upon error or passes along
+ * pwrdm_add_sleepdep() value upon success.
+ */
+static int _del_initiator_dep(struct omap_hwmod *oh, struct omap_hwmod *init_oh)
+{
+	if (!oh->_clk)
+		return -EINVAL;
+
+	return pwrdm_del_sleepdep(oh->_clk->clkdm->pwrdm.ptr,
+				  init_oh->_clk->clkdm->pwrdm.ptr);
+}
+
+/**
+ * _init_main_clk - get a struct clk * for the the hwmod's main functional clk
+ * @oh: struct omap_hwmod *
+ *
+ * Called from _init_clocks().  Populates the @oh _clk (main
+ * functional clock pointer) if a main_clk is present.  Returns 0 on
+ * success or -EINVAL on error.
+ */
+static int _init_main_clk(struct omap_hwmod *oh)
+{
+	struct clk *c;
+	int ret = 0;
+
+	if (!oh->clkdev_con_id)
+		return 0;
+
+	c = clk_get_sys(oh->clkdev_dev_id, oh->clkdev_con_id);
+	WARN(IS_ERR(c), "omap_hwmod: %s: cannot clk_get main_clk %s.%s\n",
+	     oh->name, oh->clkdev_dev_id, oh->clkdev_con_id);
+	if (IS_ERR(c))
+		ret = -EINVAL;
+	oh->_clk = c;
+
+	return ret;
+}
+
+/**
+ * _init_interface_clk - get a struct clk * for the the hwmod's interface clks
+ * @oh: struct omap_hwmod *
+ *
+ * Called from _init_clocks().  Populates the @oh OCP slave interface
+ * clock pointers.  Returns 0 on success or -EINVAL on error.
+ */
+static int _init_interface_clks(struct omap_hwmod *oh)
+{
+	struct omap_hwmod_ocp_if *os;
+	struct clk *c;
+	int i;
+	int ret = 0;
+
+	if (oh->slaves_cnt == 0)
+		return 0;
+
+	for (i = 0, os = *oh->slaves; i < oh->slaves_cnt; i++, os++) {
+		if (!os->clkdev_con_id)
+			continue;
+
+		c = clk_get_sys(os->clkdev_dev_id, os->clkdev_con_id);
+		WARN(IS_ERR(c), "omap_hwmod: %s: cannot clk_get "
+		     "interface_clk %s.%s\n", oh->name,
+		     os->clkdev_dev_id, os->clkdev_con_id);
+		if (IS_ERR(c))
+			ret = -EINVAL;
+		os->_clk = c;
+	}
+
+	return ret;
+}
+
+/**
+ * _init_opt_clk - get a struct clk * for the the hwmod's optional clocks
+ * @oh: struct omap_hwmod *
+ *
+ * Called from _init_clocks().  Populates the @oh omap_hwmod_opt_clk
+ * clock pointers.  Returns 0 on success or -EINVAL on error.
+ */
+static int _init_opt_clks(struct omap_hwmod *oh)
+{
+	struct omap_hwmod_opt_clk *oc;
+	struct clk *c;
+	int i;
+	int ret = 0;
+
+	for (i = oh->opt_clks_cnt, oc = oh->opt_clks; i > 0; i--, oc++) {
+		c = clk_get_sys(oc->clkdev_dev_id, oc->clkdev_con_id);
+		WARN(IS_ERR(c), "omap_hwmod: %s: cannot clk_get opt_clk "
+		     "%s.%s\n", oh->name, oc->clkdev_dev_id,
+		     oc->clkdev_con_id);
+		if (IS_ERR(c))
+			ret = -EINVAL;
+		oc->_clk = c;
+	}
+
+	return ret;
+}
+
+/**
+ * _enable_clocks - enable hwmod main clock and interface clocks
+ * @oh: struct omap_hwmod *
+ *
+ * Enables all clocks necessary for register reads and writes to succeed
+ * on the hwmod @oh.  Returns 0.
+ */
+static int _enable_clocks(struct omap_hwmod *oh)
+{
+	struct omap_hwmod_ocp_if *os;
+	int i;
+
+	pr_debug("omap_hwmod: %s: enabling clocks\n", oh->name);
+
+	if (oh->_clk && !IS_ERR(oh->_clk))
+		clk_enable(oh->_clk);
+
+	if (oh->slaves_cnt > 0) {
+		for (i = 0, os = *oh->slaves; i < oh->slaves_cnt; i++, os++) {
+			struct clk *c = os->_clk;
+
+			if (c && !IS_ERR(c) && (os->flags & OCPIF_SWSUP_IDLE))
+				clk_enable(c);
+		}
+	}
+
+	/* The opt clocks are controlled by the device driver. */
+
+	return 0;
+}
+
+/**
+ * _disable_clocks - disable hwmod main clock and interface clocks
+ * @oh: struct omap_hwmod *
+ *
+ * Disables the hwmod @oh main functional and interface clocks.  Returns 0.
+ */
+static int _disable_clocks(struct omap_hwmod *oh)
+{
+	struct omap_hwmod_ocp_if *os;
+	int i;
+
+	pr_debug("omap_hwmod: %s: disabling clocks\n", oh->name);
+
+	if (oh->_clk && !IS_ERR(oh->_clk))
+		clk_disable(oh->_clk);
+
+	if (oh->slaves_cnt > 0) {
+		for (i = 0, os = *oh->slaves; i < oh->slaves_cnt; i++, os++) {
+			struct clk *c = os->_clk;
+
+			if (c && !IS_ERR(c) && (os->flags & OCPIF_SWSUP_IDLE))
+				clk_disable(c);
+		}
+	}
+
+	/* The opt clocks are controlled by the device driver. */
+
+	return 0;
+}
+
+/**
+ * _find_mpu_port_index - find hwmod OCP slave port ID intended for MPU use
+ * @oh: struct omap_hwmod *
+ *
+ * Returns the array index of the OCP slave port that the MPU
+ * addresses the device on, or -EINVAL upon error or not found.
+ */
+static int _find_mpu_port_index(struct omap_hwmod *oh)
+{
+	struct omap_hwmod_ocp_if *os;
+	int i;
+	int found = 0;
+
+	if (!oh || oh->slaves_cnt == 0)
+		return -EINVAL;
+
+	for (i = 0, os = *oh->slaves; i < oh->slaves_cnt; i++, os++) {
+		if (os->user & OCP_USER_MPU) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (found)
+		pr_debug("omap_hwmod: %s: MPU OCP slave port ID  %d\n",
+			 oh->name, i);
+	else
+		pr_debug("omap_hwmod: %s: no MPU OCP slave port found\n",
+			 oh->name);
+
+	return (found) ? i : -EINVAL;
+}
+
+/**
+ * _find_mpu_rt_base - find hwmod register target base addr accessible by MPU
+ * @oh: struct omap_hwmod *
+ *
+ * Return the virtual address of the base of the register target of
+ * device @oh, or NULL on error.
+ */
+static void __iomem *_find_mpu_rt_base(struct omap_hwmod *oh, u8 index)
+{
+	struct omap_hwmod_ocp_if *os;
+	struct omap_hwmod_addr_space *mem;
+	int i;
+	int found = 0;
+
+	if (!oh || oh->slaves_cnt == 0)
+		return NULL;
+
+	os = *oh->slaves + index;
+
+	for (i = 0, mem = os->addr; i < os->addr_cnt; i++, mem++) {
+		if (mem->flags & ADDR_TYPE_RT) {
+			found = 1;
+			break;
+		}
+	}
+
+	/* XXX use ioremap() instead? */
+
+	if (found)
+		pr_debug("omap_hwmod: %s: MPU register target at va %p\n",
+			 oh->name, OMAP2_IO_ADDRESS(mem->pa_start));
+	else
+		pr_debug("omap_hwmod: %s: no MPU register target found\n",
+			 oh->name);
+
+	return (found) ? OMAP2_IO_ADDRESS(mem->pa_start) : NULL;
+}
+
+/**
+ * _sysc_enable - try to bring a module out of idle via OCP_SYSCONFIG
+ * @oh: struct omap_hwmod *
+ *
+ * If module is marked as SWSUP_SIDLE, force the module out of slave
+ * idle; otherwise, configure it for smart-idle.  If module is marked
+ * as SWSUP_MSUSPEND, force the module out of master standby;
+ * otherwise, configure it for smart-standby.  No return value.
+ */
+static void _sysc_enable(struct omap_hwmod *oh)
+{
+	u8 idlemode;
+	u32 v;
+
+	if (!oh->sysconfig)
+		return;
+
+	v = oh->_sysc_cache;
+
+	if (oh->sysconfig->sysc_flags & SYSC_HAS_SIDLEMODE) {
+		idlemode = (oh->flags & HWMOD_SWSUP_SIDLE) ?
+			HWMOD_IDLEMODE_NO : HWMOD_IDLEMODE_SMART;
+		_set_slave_idlemode(oh, idlemode, &v);
+	}
+
+	if (oh->sysconfig->sysc_flags & SYSC_HAS_MIDLEMODE) {
+		idlemode = (oh->flags & HWMOD_SWSUP_MSTANDBY) ?
+			HWMOD_IDLEMODE_NO : HWMOD_IDLEMODE_SMART;
+		_set_master_standbymode(oh, idlemode, &v);
+	}
+
+	/* XXX OCP AUTOIDLE bit? */
+
+	if (oh->flags & HWMOD_SET_DEFAULT_CLOCKACT &&
+	    oh->sysconfig->sysc_flags & SYSC_HAS_CLOCKACTIVITY)
+		_set_clockactivity(oh, oh->sysconfig->clockact, &v);
+
+	_write_sysconfig(v, oh);
+}
+
+/**
+ * _sysc_idle - try to put a module into idle via OCP_SYSCONFIG
+ * @oh: struct omap_hwmod *
+ *
+ * If module is marked as SWSUP_SIDLE, force the module into slave
+ * idle; otherwise, configure it for smart-idle.  If module is marked
+ * as SWSUP_MSUSPEND, force the module into master standby; otherwise,
+ * configure it for smart-standby.  No return value.
+ */
+static void _sysc_idle(struct omap_hwmod *oh)
+{
+	u8 idlemode;
+	u32 v;
+
+	if (!oh->sysconfig)
+		return;
+
+	v = oh->_sysc_cache;
+
+	if (oh->sysconfig->sysc_flags & SYSC_HAS_SIDLEMODE) {
+		idlemode = (oh->flags & HWMOD_SWSUP_SIDLE) ?
+			HWMOD_IDLEMODE_FORCE : HWMOD_IDLEMODE_SMART;
+		_set_slave_idlemode(oh, idlemode, &v);
+	}
+
+	if (oh->sysconfig->sysc_flags & SYSC_HAS_MIDLEMODE) {
+		idlemode = (oh->flags & HWMOD_SWSUP_MSTANDBY) ?
+			HWMOD_IDLEMODE_FORCE : HWMOD_IDLEMODE_SMART;
+		_set_master_standbymode(oh, idlemode, &v);
+	}
+
+	_write_sysconfig(v, oh);
+}
+
+/**
+ * _sysc_shutdown - force a module into idle via OCP_SYSCONFIG
+ * @oh: struct omap_hwmod *
+ *
+ * Force the module into slave idle and master suspend. No return
+ * value.
+ */
+static void _sysc_shutdown(struct omap_hwmod *oh)
+{
+	u32 v;
+
+	if (!oh->sysconfig)
+		return;
+
+	v = oh->_sysc_cache;
+
+	if (oh->sysconfig->sysc_flags & SYSC_HAS_SIDLEMODE)
+		_set_slave_idlemode(oh, HWMOD_IDLEMODE_FORCE, &v);
+
+	if (oh->sysconfig->sysc_flags & SYSC_HAS_MIDLEMODE)
+		_set_master_standbymode(oh, HWMOD_IDLEMODE_FORCE, &v);
+
+	/* XXX clear OCP AUTOIDLE bit? */
+
+	_write_sysconfig(v, oh);
+}
+
+/**
+ * _lookup - find an omap_hwmod by name
+ * @name: find an omap_hwmod by name
+ *
+ * Return a pointer to an omap_hwmod by name, or NULL if not found.
+ * Caller must hold omap_hwmod_mutex.
+ */
+static struct omap_hwmod *_lookup(const char *name)
+{
+	struct omap_hwmod *oh, *temp_oh;
+
+	oh = NULL;
+
+	list_for_each_entry(temp_oh, &omap_hwmod_list, node) {
+		if (!strcmp(name, temp_oh->name)) {
+			oh = temp_oh;
+			break;
+		}
+	}
+
+	return oh;
+}
+
+/**
+ * _init_clocks - clk_get() all clocks associated with this hwmod
+ * @oh: struct omap_hwmod *
+ *
+ * Called by omap_hwmod_late_init() (after omap2_clk_init()).
+ * Resolves all clock names embedded in the hwmod.  Must be called
+ * with omap_hwmod_mutex held.  Returns -EINVAL if the omap_hwmod
+ * has not yet been registered or if the clocks have already been
+ * initialized, 0 on success, or a non-zero error on failure.
+ */
+static int _init_clocks(struct omap_hwmod *oh)
+{
+	int ret = 0;
+
+	if (!oh || (oh->_state != _HWMOD_STATE_REGISTERED))
+		return -EINVAL;
+
+	pr_debug("omap_hwmod: %s: looking up clocks\n", oh->name);
+
+	ret |= _init_main_clk(oh);
+	ret |= _init_interface_clks(oh);
+	ret |= _init_opt_clks(oh);
+
+	oh->_state = _HWMOD_STATE_CLKS_INITED;
+
+	return ret;
+}
+
+/**
+ * _wait_target_ready - wait for a module to leave slave idle
+ * @oh: struct omap_hwmod *
+ *
+ * Wait for a module @oh to leave slave idle.  Returns 0 if the module
+ * does not have an IDLEST bit or if the module successfully leaves
+ * slave idle; otherwise, pass along the return value of the
+ * appropriate *_cm_wait_module_ready() function.
+ */
+static int _wait_target_ready(struct omap_hwmod *oh)
+{
+	struct omap_hwmod_ocp_if *os;
+	int ret;
+
+	if (!oh)
+		return -EINVAL;
+
+	if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
+		return 0;
+
+	os = *oh->slaves + oh->_mpu_port_index;
+
+	if (!(os->flags & OCPIF_HAS_IDLEST))
+		return 0;
+
+	/* XXX check module SIDLEMODE */
+
+	/* XXX check clock enable states */
+
+	if (cpu_is_omap24xx() || cpu_is_omap34xx()) {
+		ret = omap2_cm_wait_module_ready(oh->prcm.omap2.module_offs,
+						 oh->prcm.omap2.idlest_reg_id,
+						 oh->prcm.omap2.idlest_idle_bit);
+#if 0
+	} else if (cpu_is_omap44xx()) {
+		ret = omap4_cm_wait_module_ready(oh->prcm.omap4.module_offs,
+						 oh->prcm.omap4.device_offs);
+#endif
+	} else {
+		BUG();
+	};
+
+	return ret;
+}
+
+/**
+ * _reset - reset an omap_hwmod
+ * @oh: struct omap_hwmod *
+ *
+ * Resets an omap_hwmod @oh via the OCP_SYSCONFIG bit.  hwmod must be
+ * enabled for this to work.  Must be called with omap_hwmod_mutex
+ * held.  Returns -EINVAL if the hwmod cannot be reset this way or if
+ * the hwmod is in the wrong state, -ETIMEDOUT if the module did not
+ * reset in time, or 0 upon success.
+ */
+static int _reset(struct omap_hwmod *oh)
+{
+	u32 r, v;
+	int c;
+
+	if (!oh->sysconfig ||
+	    !(oh->sysconfig->sysc_flags & SYSC_HAS_SOFTRESET) ||
+	    (oh->sysconfig->sysc_flags & SYSS_MISSING))
+		return -EINVAL;
+
+	/* clocks must be on for this operation */
+	if (oh->_state != _HWMOD_STATE_ENABLED) {
+		WARN(1, "omap_hwmod: %s: reset can only be entered from "
+		     "enabled state\n", oh->name);
+		return -EINVAL;
+	}
+
+	pr_debug("omap_hwmod: %s: resetting\n", oh->name);
+
+	v = oh->_sysc_cache;
+	r = _set_softreset(oh, &v);
+	if (r)
+		return r;
+	_write_sysconfig(v, oh);
+
+	c = 0;
+	while (c < MAX_MODULE_RESET_WAIT &&
+	       !(omap_hwmod_readl(oh, oh->sysconfig->syss_offs) &
+		 SYSS_RESETDONE_MASK)) {
+		udelay(1);
+		c++;
+	}
+
+	if (c == MAX_MODULE_RESET_WAIT)
+		WARN(1, "omap_hwmod: %s: failed to reset in %d usec\n",
+		     oh->name, MAX_MODULE_RESET_WAIT);
+	else
+		pr_debug("omap_hwmod: %s: reset in %d usec\n", oh->name,
+			 MAX_MODULE_RESET_WAIT);
+
+	/*
+	 * XXX add _HWMOD_STATE_WEDGED for modules that don't come back from
+	 * _wait_target_ready() or _reset()
+	 */
+
+	return (c == MAX_MODULE_RESET_WAIT) ? -ETIMEDOUT : 0;
+}
+
+/**
+ * _enable - enable an omap_hwmod
+ * @oh: struct omap_hwmod *
+ *
+ * Enables an omap_hwmod @oh such that the MPU can access the hwmod's
+ * register target.  Must be called with omap_hwmod_mutex held.
+ * Returns -EINVAL if the hwmod is in the wrong state or passes along
+ * the return value of _wait_target_ready().
+ */
+static int _enable(struct omap_hwmod *oh)
+{
+	int r;
+
+	if (oh->_state != _HWMOD_STATE_INITIALIZED &&
+	    oh->_state != _HWMOD_STATE_IDLE &&
+	    oh->_state != _HWMOD_STATE_DISABLED) {
+		WARN(1, "omap_hwmod: %s: enabled state can only be entered "
+		     "from initialized, idle, or disabled state\n", oh->name);
+		return -EINVAL;
+	}
+
+	pr_debug("omap_hwmod: %s: enabling\n", oh->name);
+
+	/* XXX mux balls */
+
+	_add_initiator_dep(oh, mpu_oh);
+	_enable_clocks(oh);
+
+	if (oh->sysconfig) {
+		if (!(oh->_int_flags & _HWMOD_SYSCONFIG_LOADED))
+			_update_sysc_cache(oh);
+		_sysc_enable(oh);
+	}
+
+	r = _wait_target_ready(oh);
+	if (!r)
+		oh->_state = _HWMOD_STATE_ENABLED;
+
+	return r;
+}
+
+/**
+ * _idle - idle an omap_hwmod
+ * @oh: struct omap_hwmod *
+ *
+ * Idles an omap_hwmod @oh.  This should be called once the hwmod has
+ * no further work.  Returns -EINVAL if the hwmod is in the wrong
+ * state or returns 0.
+ */
+static int _idle(struct omap_hwmod *oh)
+{
+	if (oh->_state != _HWMOD_STATE_ENABLED) {
+		WARN(1, "omap_hwmod: %s: idle state can only be entered from "
+		     "enabled state\n", oh->name);
+		return -EINVAL;
+	}
+
+	pr_debug("omap_hwmod: %s: idling\n", oh->name);
+
+	if (oh->sysconfig)
+		_sysc_idle(oh);
+	_del_initiator_dep(oh, mpu_oh);
+	_disable_clocks(oh);
+
+	oh->_state = _HWMOD_STATE_IDLE;
+
+	return 0;
+}
+
+/**
+ * _shutdown - shutdown an omap_hwmod
+ * @oh: struct omap_hwmod *
+ *
+ * Shut down an omap_hwmod @oh.  This should be called when the driver
+ * used for the hwmod is removed or unloaded or if the driver is not
+ * used by the system.  Returns -EINVAL if the hwmod is in the wrong
+ * state or returns 0.
+ */
+static int _shutdown(struct omap_hwmod *oh)
+{
+	if (oh->_state != _HWMOD_STATE_IDLE &&
+	    oh->_state != _HWMOD_STATE_ENABLED) {
+		WARN(1, "omap_hwmod: %s: disabled state can only be entered "
+		     "from idle, or enabled state\n", oh->name);
+		return -EINVAL;
+	}
+
+	pr_debug("omap_hwmod: %s: disabling\n", oh->name);
+
+	if (oh->sysconfig)
+		_sysc_shutdown(oh);
+	_del_initiator_dep(oh, mpu_oh);
+	/* XXX what about the other system initiators here? DMA, tesla, d2d */
+	_disable_clocks(oh);
+	/* XXX Should this code also force-disable the optional clocks? */
+
+	/* XXX mux any associated balls to safe mode */
+
+	oh->_state = _HWMOD_STATE_DISABLED;
+
+	return 0;
+}
+
+/**
+ * _write_clockact_lock - set the module's clockactivity bits
+ * @oh: struct omap_hwmod *
+ * @clockact: CLOCKACTIVITY field bits
+ *
+ * Writes the CLOCKACTIVITY bits @clockact to the hwmod @oh
+ * OCP_SYSCONFIG register.  Returns -EINVAL if the hwmod is in the
+ * wrong state or returns 0.
+ */
+static int _write_clockact_lock(struct omap_hwmod *oh, u8 clockact)
+{
+	u32 v;
+
+	if (!oh->sysconfig ||
+	    !(oh->sysconfig->sysc_flags & SYSC_HAS_CLOCKACTIVITY))
+		return -EINVAL;
+
+	mutex_lock(&omap_hwmod_mutex);
+	v = oh->_sysc_cache;
+	_set_clockactivity(oh, clockact, &v);
+	_write_sysconfig(v, oh);
+	mutex_unlock(&omap_hwmod_mutex);
+
+	return 0;
+}
+
+
+/**
+ * _setup - do initial configuration of omap_hwmod
+ * @oh: struct omap_hwmod *
+ *
+ * Writes the CLOCKACTIVITY bits @clockact to the hwmod @oh
+ * OCP_SYSCONFIG register.  Must be called with omap_hwmod_mutex
+ * held.  Returns -EINVAL if the hwmod is in the wrong state or returns
+ * 0.
+ */
+static int _setup(struct omap_hwmod *oh)
+{
+	struct omap_hwmod_ocp_if *os;
+	int i;
+
+	if (!oh)
+		return -EINVAL;
+
+	/* Set iclk autoidle mode */
+	if (oh->slaves_cnt > 0) {
+		for (i = 0, os = *oh->slaves; i < oh->slaves_cnt; i++, os++) {
+			struct clk *c = os->_clk;
+
+			if (!c || IS_ERR(c))
+				continue;
+
+			if (os->flags & OCPIF_SWSUP_IDLE) {
+				/* XXX omap_iclk_deny_idle(c); */
+			} else {
+				/* XXX omap_iclk_allow_idle(c); */
+				clk_enable(c);
+			}
+		}
+	}
+
+	oh->_state = _HWMOD_STATE_INITIALIZED;
+
+	_enable(oh);
+
+	if (!(oh->flags & HWMOD_INIT_NO_RESET))
+		_reset(oh);
+
+	/* XXX OCP AUTOIDLE bit? */
+	/* XXX OCP ENAWAKEUP bit? */
+
+	if (!(oh->flags & HWMOD_INIT_NO_IDLE))
+		_idle(oh);
+
+	return 0;
+}
+
+
+
+/* Public functions */
+
+u32 omap_hwmod_readl(struct omap_hwmod *oh, u16 reg_offs)
+{
+	return __raw_readl(oh->_rt_va + reg_offs);
+}
+
+void omap_hwmod_writel(u32 v, struct omap_hwmod *oh, u16 reg_offs)
+{
+	__raw_writel(v, oh->_rt_va + reg_offs);
+}
+
+/**
+ * omap_hwmod_register - register a struct omap_hwmod
+ * @oh: struct omap_hwmod *
+ *
+ * Registers the omap_hwmod @oh.  Returns -EEXIST if an omap_hwmod already
+ * has been registered by the same name; -EINVAL if the omap_hwmod is in the
+ * wrong state, or 0 on success.
+ *
+ * XXX The data should be copied into bootmem, so the original data
+ * should be marked __initdata and freed after init.  This would allow
+ * unneeded omap_hwmods to be freed on multi-OMAP configurations.  Note
+ * that the copy process would be relatively complex due to the large number
+ * of substructures.
+ */
+int omap_hwmod_register(struct omap_hwmod *oh)
+{
+	int ret, ms_id;
+
+	if (!oh || (oh->_state != _HWMOD_STATE_UNKNOWN))
+		return -EINVAL;
+
+	mutex_lock(&omap_hwmod_mutex);
+
+	pr_debug("omap_hwmod: %s: registering\n", oh->name);
+
+	if (_lookup(oh->name)) {
+		ret = -EEXIST;
+		goto ohr_unlock;
+	}
+
+	ms_id = _find_mpu_port_index(oh);
+	if (!IS_ERR_VALUE(ms_id)) {
+		oh->_mpu_port_index = ms_id;
+		oh->_rt_va = _find_mpu_rt_base(oh, oh->_mpu_port_index);
+	} else {
+		oh->_int_flags |= _HWMOD_NO_MPU_PORT;
+	}
+
+	list_add_tail(&oh->node, &omap_hwmod_list);
+
+	oh->_state = _HWMOD_STATE_REGISTERED;
+
+	ret = 0;
+
+ohr_unlock:
+	mutex_unlock(&omap_hwmod_mutex);
+	return ret;
+}
+
+/**
+ * omap_hwmod_lookup - look up a registered omap_hwmod by name
+ * @name: name of the omap_hwmod to look up
+ *
+ * Given a @name of an omap_hwmod, return a pointer to the registered
+ * struct omap_hwmod *, or NULL upon error.
+ */
+struct omap_hwmod *omap_hwmod_lookup(const char *name)
+{
+	struct omap_hwmod *oh;
+
+	if (!name)
+		return NULL;
+
+	mutex_lock(&omap_hwmod_mutex);
+	oh = _lookup(name);
+	mutex_unlock(&omap_hwmod_mutex);
+
+	return oh;
+}
+
+/**
+ * omap_hwmod_for_each - call function for each registered omap_hwmod
+ * @fn: pointer to a callback function
+ *
+ * Call @fn for each registered omap_hwmod, passing @data to each
+ * function.  @fn must return 0 for success or any other value for
+ * failure.  If @fn returns non-zero, the iteration across omap_hwmods
+ * will stop and the non-zero return value will be passed to the
+ * caller of omap_hwmod_for_each().  @fn is called with
+ * omap_hwmod_for_each() held.
+ */
+int omap_hwmod_for_each(int (*fn)(struct omap_hwmod *oh))
+{
+	struct omap_hwmod *temp_oh;
+	int ret;
+
+	if (!fn)
+		return -EINVAL;
+
+	mutex_lock(&omap_hwmod_mutex);
+	list_for_each_entry(temp_oh, &omap_hwmod_list, node) {
+		ret = (*fn)(temp_oh);
+		if (ret)
+			break;
+	}
+	mutex_unlock(&omap_hwmod_mutex);
+
+	return ret;
+}
+
+
+/**
+ * omap_hwmod_init - init omap_hwmod code and register hwmods
+ * @ohs: pointer to an array of omap_hwmods to register
+ *
+ * Intended to be called early in boot before the clock framework is
+ * initialized.  If @ohs is not null, will register all omap_hwmods
+ * listed in @ohs that are valid for this chip.  Returns -EINVAL if
+ * omap_hwmod_init() has already been called or 0 otherwise.
+ */
+int omap_hwmod_init(struct omap_hwmod **ohs)
+{
+	struct omap_hwmod *oh;
+	int r;
+
+	if (inited)
+		return -EINVAL;
+
+	inited = 1;
+
+	if (!ohs)
+		return 0;
+
+	oh = *ohs;
+	while (oh) {
+		if (omap_chip_is(oh->omap_chip)) {
+			r = omap_hwmod_register(oh);
+			WARN(r, "omap_hwmod: %s: omap_hwmod_register returned "
+			     "%d\n", oh->name, r);
+		}
+		oh = *++ohs;
+	}
+
+	return 0;
+}
+
+/**
+ * omap_hwmod_late_init - do some post-clock framework initialization
+ *
+ * Must be called after omap2_clk_init().  Resolves the struct clk names
+ * to struct clk pointers for each registered omap_hwmod.  Also calls
+ * _setup() on each hwmod.  Returns 0.
+ */
+int omap_hwmod_late_init(void)
+{
+	int r;
+
+	/* XXX check return value */
+	r = omap_hwmod_for_each(_init_clocks);
+	WARN(r, "omap_hwmod: omap_hwmod_late_init(): _init_clocks failed\n");
+
+	mpu_oh = omap_hwmod_lookup(MPU_INITIATOR_NAME);
+	WARN(!mpu_oh, "omap_hwmod: could not find MPU initiator hwmod %s\n",
+	     MPU_INITIATOR_NAME);
+
+	omap_hwmod_for_each(_setup);
+
+	return 0;
+}
+
+/**
+ * omap_hwmod_unregister - unregister an omap_hwmod
+ * @oh: struct omap_hwmod *
+ *
+ * Unregisters a previously-registered omap_hwmod @oh.  There's probably
+ * no use case for this, so it is likely to be removed in a later version.
+ *
+ * XXX Free all of the bootmem-allocated structures here when that is
+ * implemented.  Make it clear that core code is the only code that is
+ * expected to unregister modules.
+ */
+int omap_hwmod_unregister(struct omap_hwmod *oh)
+{
+	if (!oh)
+		return -EINVAL;
+
+	pr_debug("omap_hwmod: %s: unregistering\n", oh->name);
+
+	mutex_lock(&omap_hwmod_mutex);
+	list_del(&oh->node);
+	mutex_unlock(&omap_hwmod_mutex);
+
+	return 0;
+}
+
+/**
+ * omap_hwmod_enable - enable an omap_hwmod
+ * @oh: struct omap_hwmod *
+ *
+ * Enable an omap_hwomd @oh.  Intended to be called by omap_device_enable().
+ * Returns -EINVAL on error or passes along the return value from _enable().
+ */
+int omap_hwmod_enable(struct omap_hwmod *oh)
+{
+	int r;
+
+	if (!oh)
+		return -EINVAL;
+
+	mutex_lock(&omap_hwmod_mutex);
+	r = _enable(oh);
+	mutex_unlock(&omap_hwmod_mutex);
+
+	return r;
+}
+
+/**
+ * omap_hwmod_idle - idle an omap_hwmod
+ * @oh: struct omap_hwmod *
+ *
+ * Idle an omap_hwomd @oh.  Intended to be called by omap_device_idle().
+ * Returns -EINVAL on error or passes along the return value from _idle().
+ */
+int omap_hwmod_idle(struct omap_hwmod *oh)
+{
+	if (!oh)
+		return -EINVAL;
+
+	mutex_lock(&omap_hwmod_mutex);
+	_idle(oh);
+	mutex_unlock(&omap_hwmod_mutex);
+
+	return 0;
+}
+
+/**
+ * omap_hwmod_shutdown - shutdown an omap_hwmod
+ * @oh: struct omap_hwmod *
+ *
+ * Shutdown an omap_hwomd @oh.  Intended to be called by
+ * omap_device_shutdown().  Returns -EINVAL on error or passes along
+ * the return value from _shutdown().
+ */
+int omap_hwmod_shutdown(struct omap_hwmod *oh)
+{
+	if (!oh)
+		return -EINVAL;
+
+	mutex_lock(&omap_hwmod_mutex);
+	_shutdown(oh);
+	mutex_unlock(&omap_hwmod_mutex);
+
+	return 0;
+}
+
+/**
+ * omap_hwmod_enable_clocks - enable main_clk, all interface clocks
+ * @oh: struct omap_hwmod *oh
+ *
+ * Intended to be called by the omap_device code.
+ */
+int omap_hwmod_enable_clocks(struct omap_hwmod *oh)
+{
+	mutex_lock(&omap_hwmod_mutex);
+	_enable_clocks(oh);
+	mutex_unlock(&omap_hwmod_mutex);
+
+	return 0;
+}
+
+/**
+ * omap_hwmod_disable_clocks - disable main_clk, all interface clocks
+ * @oh: struct omap_hwmod *oh
+ *
+ * Intended to be called by the omap_device code.
+ */
+int omap_hwmod_disable_clocks(struct omap_hwmod *oh)
+{
+	mutex_lock(&omap_hwmod_mutex);
+	_disable_clocks(oh);
+	mutex_unlock(&omap_hwmod_mutex);
+
+	return 0;
+}
+
+/**
+ * omap_hwmod_ocp_barrier - wait for posted writes against the hwmod to complete
+ * @oh: struct omap_hwmod *oh
+ *
+ * Intended to be called by drivers and core code when all posted
+ * writes to a device must complete before continuing further
+ * execution (for example, after clearing some device IRQSTATUS
+ * register bits)
+ *
+ * XXX what about targets with multiple OCP threads?
+ */
+void omap_hwmod_ocp_barrier(struct omap_hwmod *oh)
+{
+	BUG_ON(!oh);
+
+	if (!oh->sysconfig || !oh->sysconfig->sysc_flags) {
+		WARN(1, "omap_device: %s: OCP barrier impossible due to "
+		      "device configuration\n", oh->name);
+		return;
+	}
+
+	/*
+	 * Forces posted writes to complete on the OCP thread handling
+	 * register writes
+	 */
+	omap_hwmod_readl(oh, oh->sysconfig->sysc_offs);
+}
+
+/**
+ * omap_hwmod_reset - reset the hwmod
+ * @oh: struct omap_hwmod *
+ *
+ * Under some conditions, a driver may wish to reset the entire device.
+ * Called from omap_device code.  Returns -EINVAL on error or passes along
+ * the return value from _reset()/_enable().
+ */
+int omap_hwmod_reset(struct omap_hwmod *oh)
+{
+	int r;
+
+	if (!oh || !(oh->_state & _HWMOD_STATE_ENABLED))
+		return -EINVAL;
+
+	mutex_lock(&omap_hwmod_mutex);
+	r = _reset(oh);
+	if (!r)
+		r = _enable(oh);
+	mutex_unlock(&omap_hwmod_mutex);
+
+	return r;
+}
+
+/**
+ * omap_hwmod_count_resources - count number of struct resources needed by hwmod
+ * @oh: struct omap_hwmod *
+ * @res: pointer to the first element of an array of struct resource to fill
+ *
+ * Count the number of struct resource array elements necessary to
+ * contain omap_hwmod @oh resources.  Intended to be called by code
+ * that registers omap_devices.  Intended to be used to determine the
+ * size of a dynamically-allocated struct resource array, before
+ * calling omap_hwmod_fill_resources().  Returns the number of struct
+ * resource array elements needed.
+ *
+ * XXX This code is not optimized.  It could attempt to merge adjacent
+ * resource IDs.
+ *
+ */
+int omap_hwmod_count_resources(struct omap_hwmod *oh)
+{
+	int ret, i;
+
+	ret = oh->mpu_irqs_cnt + oh->sdma_chs_cnt;
+
+	for (i = 0; i < oh->slaves_cnt; i++)
+		ret += (*oh->slaves + i)->addr_cnt;
+
+	return ret;
+}
+
+/**
+ * omap_hwmod_fill_resources - fill struct resource array with hwmod data
+ * @oh: struct omap_hwmod *
+ * @res: pointer to the first element of an array of struct resource to fill
+ *
+ * Fill the struct resource array @res with resource data from the
+ * omap_hwmod @oh.  Intended to be called by code that registers
+ * omap_devices.  See also omap_hwmod_count_resources().  Returns the
+ * number of array elements filled.
+ */
+int omap_hwmod_fill_resources(struct omap_hwmod *oh, struct resource *res)
+{
+	int i, j;
+	int r = 0;
+
+	/* For each IRQ, DMA, memory area, fill in array.*/
+
+	for (i = 0; i < oh->mpu_irqs_cnt; i++) {
+		(res + r)->start = *(oh->mpu_irqs + i);
+		(res + r)->end = *(oh->mpu_irqs + i);
+		(res + r)->flags = IORESOURCE_IRQ;
+		r++;
+	}
+
+	for (i = 0; i < oh->sdma_chs_cnt; i++) {
+		(res + r)->name = (oh->sdma_chs + i)->name;
+		(res + r)->start = (oh->sdma_chs + i)->dma_ch;
+		(res + r)->end = (oh->sdma_chs + i)->dma_ch;
+		(res + r)->flags = IORESOURCE_DMA;
+		r++;
+	}
+
+	for (i = 0; i < oh->slaves_cnt; i++) {
+		struct omap_hwmod_ocp_if *os;
+
+		os = *oh->slaves + i;
+
+		for (j = 0; j < os->addr_cnt; j++) {
+			(res + r)->start = (os->addr + j)->pa_start;
+			(res + r)->end = (os->addr + j)->pa_end;
+			(res + r)->flags = IORESOURCE_MEM;
+			r++;
+		}
+	}
+
+	return r;
+}
+
+/**
+ * omap_hwmod_get_pwrdm - return pointer to this module's main powerdomain
+ * @oh: struct omap_hwmod *
+ *
+ * Return the powerdomain pointer associated with the OMAP module
+ * @oh's main clock.  If @oh does not have a main clk, return the
+ * powerdomain associated with the interface clock associated with the
+ * module's MPU port. (XXX Perhaps this should use the SDMA port
+ * instead?)  Returns NULL on error, or a struct powerdomain * on
+ * success.
+ */
+struct powerdomain *omap_hwmod_get_pwrdm(struct omap_hwmod *oh)
+{
+	struct clk *c;
+
+	if (!oh)
+		return NULL;
+
+	if (oh->_clk) {
+		c = oh->_clk;
+	} else {
+		if (oh->_int_flags & _HWMOD_NO_MPU_PORT)
+			return NULL;
+		c = oh->slaves[oh->_mpu_port_index]->_clk;
+	}
+
+	return c->clkdm->pwrdm.ptr;
+
+}
+
+/**
+ * omap_hwmod_add_initiator_dep - add sleepdep from @init_oh to @oh
+ * @oh: struct omap_hwmod *
+ * @init_oh: struct omap_hwmod * (initiator)
+ *
+ * Add a sleep dependency between the initiator @init_oh and @oh.
+ * Intended to be called by DSP/Bridge code via platform_data for the
+ * DSP case; and by the DMA code in the sDMA case.  DMA code, *Bridge
+ * code needs to add/del initiator dependencies dynamically
+ * before/after accessing a device.  Returns the return value from
+ * _add_initiator_dep().
+ *
+ * XXX Keep a usecount in the clockdomain code
+ */
+int omap_hwmod_add_initiator_dep(struct omap_hwmod *oh,
+				 struct omap_hwmod *init_oh)
+{
+	return _add_initiator_dep(oh, init_oh);
+}
+
+/*
+ * XXX what about functions for drivers to save/restore ocp_sysconfig
+ * for context save/restore operations?
+ */
+
+/**
+ * omap_hwmod_del_initiator_dep - remove sleepdep from @init_oh to @oh
+ * @oh: struct omap_hwmod *
+ * @init_oh: struct omap_hwmod * (initiator)
+ *
+ * Remove a sleep dependency between the initiator @init_oh and @oh.
+ * Intended to be called by DSP/Bridge code via platform_data for the
+ * DSP case; and by the DMA code in the sDMA case.  DMA code, *Bridge
+ * code needs to add/del initiator dependencies dynamically
+ * before/after accessing a device.  Returns the return value from
+ * _del_initiator_dep().
+ *
+ * XXX Keep a usecount in the clockdomain code
+ */
+int omap_hwmod_del_initiator_dep(struct omap_hwmod *oh,
+				 struct omap_hwmod *init_oh)
+{
+	return _del_initiator_dep(oh, init_oh);
+}
+
+/**
+ * omap_hwmod_set_clockact_none - set clockactivity test to BOTH
+ * @oh: struct omap_hwmod *
+ *
+ * On some modules, this function can affect the wakeup latency vs.
+ * power consumption balance.  Intended to be called by the
+ * omap_device layer.  Passes along the return value from
+ * _write_clockact_lock().
+ */
+int omap_hwmod_set_clockact_both(struct omap_hwmod *oh)
+{
+	return _write_clockact_lock(oh, CLOCKACT_TEST_BOTH);
+}
+
+/**
+ * omap_hwmod_set_clockact_none - set clockactivity test to MAIN
+ * @oh: struct omap_hwmod *
+ *
+ * On some modules, this function can affect the wakeup latency vs.
+ * power consumption balance.  Intended to be called by the
+ * omap_device layer.  Passes along the return value from
+ * _write_clockact_lock().
+ */
+int omap_hwmod_set_clockact_main(struct omap_hwmod *oh)
+{
+	return _write_clockact_lock(oh, CLOCKACT_TEST_MAIN);
+}
+
+/**
+ * omap_hwmod_set_clockact_none - set clockactivity test to ICLK
+ * @oh: struct omap_hwmod *
+ *
+ * On some modules, this function can affect the wakeup latency vs.
+ * power consumption balance.  Intended to be called by the
+ * omap_device layer.  Passes along the return value from
+ * _write_clockact_lock().
+ */
+int omap_hwmod_set_clockact_iclk(struct omap_hwmod *oh)
+{
+	return _write_clockact_lock(oh, CLOCKACT_TEST_ICLK);
+}
+
+/**
+ * omap_hwmod_set_clockact_none - set clockactivity test to NONE
+ * @oh: struct omap_hwmod *
+ *
+ * On some modules, this function can affect the wakeup latency vs.
+ * power consumption balance.  Intended to be called by the
+ * omap_device layer.  Passes along the return value from
+ * _write_clockact_lock().
+ */
+int omap_hwmod_set_clockact_none(struct omap_hwmod *oh)
+{
+	return _write_clockact_lock(oh, CLOCKACT_TEST_NONE);
+}
+
+/**
+ * omap_hwmod_enable_wakeup - allow device to wake up the system
+ * @oh: struct omap_hwmod *
+ *
+ * Sets the module OCP socket ENAWAKEUP bit to allow the module to
+ * send wakeups to the PRCM.  Eventually this should sets PRCM wakeup
+ * registers to cause the PRCM to receive wakeup events from the
+ * module.  Does not set any wakeup routing registers beyond this
+ * point - if the module is to wake up any other module or subsystem,
+ * that must be set separately.  Called by omap_device code.  Returns
+ * -EINVAL on error or 0 upon success.
+ */
+int omap_hwmod_enable_wakeup(struct omap_hwmod *oh)
+{
+	if (!oh->sysconfig ||
+	    !(oh->sysconfig->sysc_flags & SYSC_HAS_ENAWAKEUP))
+		return -EINVAL;
+
+	mutex_lock(&omap_hwmod_mutex);
+	_enable_wakeup(oh);
+	mutex_unlock(&omap_hwmod_mutex);
+
+	return 0;
+}
+
+/**
+ * omap_hwmod_disable_wakeup - prevent device from waking the system
+ * @oh: struct omap_hwmod *
+ *
+ * Clears the module OCP socket ENAWAKEUP bit to prevent the module
+ * from sending wakeups to the PRCM.  Eventually this should clear
+ * PRCM wakeup registers to cause the PRCM to ignore wakeup events
+ * from the module.  Does not set any wakeup routing registers beyond
+ * this point - if the module is to wake up any other module or
+ * subsystem, that must be set separately.  Called by omap_device
+ * code.  Returns -EINVAL on error or 0 upon success.
+ */
+int omap_hwmod_disable_wakeup(struct omap_hwmod *oh)
+{
+	if (!oh->sysconfig ||
+	    !(oh->sysconfig->sysc_flags & SYSC_HAS_ENAWAKEUP))
+		return -EINVAL;
+
+	mutex_lock(&omap_hwmod_mutex);
+	_disable_wakeup(oh);
+	mutex_unlock(&omap_hwmod_mutex);
+
+	return 0;
+}
