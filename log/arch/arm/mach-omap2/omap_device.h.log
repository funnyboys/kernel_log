commit 82f12e64a019c1ce240c35a67d8e9ee8f70ad29b
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Dec 16 14:41:53 2019 -0800

    ARM: OMAP2+: Drop legacy init for sdma
    
    We can now drop legacy init for sdma as we pass the quirks in auxdata to
    the dmaengine driver.
    
    Cc: Aaro Koskinen <aaro.koskinen@iki.fi>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Russell King <rmk+kernel@armlinux.org.uk>
    Cc: Vinod Koul <vkoul@kernel.org>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.h b/arch/arm/mach-omap2/omap_device.h
index ced775e401cf..f77e76a7841a 100644
--- a/arch/arm/mach-omap2/omap_device.h
+++ b/arch/arm/mach-omap2/omap_device.h
@@ -68,10 +68,6 @@ int omap_device_idle(struct platform_device *pdev);
 
 /* Core code interface */
 
-struct platform_device *omap_device_build(const char *pdev_name, int pdev_id,
-					  struct omap_hwmod *oh, void *pdata,
-					  int pdata_len);
-
 struct omap_device *omap_device_alloc(struct platform_device *pdev,
 				      struct omap_hwmod **ohs, int oh_cnt);
 void omap_device_delete(struct omap_device *od);

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-omap2/omap_device.h b/arch/arm/mach-omap2/omap_device.h
index 786b9c00fdb9..ced775e401cf 100644
--- a/arch/arm/mach-omap2/omap_device.h
+++ b/arch/arm/mach-omap2/omap_device.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * omap_device headers
  *
@@ -9,10 +10,6 @@
  * Pandita, Sakari Poussa, Anand Sawant, Santosh Shilimkar, Richard
  * Woodruff
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  * This type of functionality should be implemented as a proper
  * omap_bus/omap_device in Linux.
  *

commit d85a2d61432aed6a4c2e5f90109a37562f9a8092
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 10 14:23:35 2017 -0700

    ARM: OMAP2+: Populate legacy resources for dma and smartreflex
    
    We can populate the legacy resources needed by dma and smartreflex
    from device tree in omap_device_build().
    
    There should be no need to do this for other devices, and eventually
    these two remaining users will be gone too. The legacy dma will be
    dropped when the remaining users have been converted to use the
    dmaengine driver, and smartreflex can now become just a regular
    device driver with a few pdata callbacks.
    
    This is needed in order to remove remaining device dma, irq and io
    resources from the interconnect code.
    
    And while at it, let's simplify things by removing otherwise
    unused omap_device_build_ss() as we will never call it for more
    than one hwmod.
    
    Cc: "Beno√Æt Cousson" <bcousson@baylibre.com>
    Cc: Lokesh Vutla <lokeshvutla@ti.com>
    Cc: Nishanth Menon <nm@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.h b/arch/arm/mach-omap2/omap_device.h
index 78c02b355179..786b9c00fdb9 100644
--- a/arch/arm/mach-omap2/omap_device.h
+++ b/arch/arm/mach-omap2/omap_device.h
@@ -75,10 +75,6 @@ struct platform_device *omap_device_build(const char *pdev_name, int pdev_id,
 					  struct omap_hwmod *oh, void *pdata,
 					  int pdata_len);
 
-struct platform_device *omap_device_build_ss(const char *pdev_name, int pdev_id,
-					 struct omap_hwmod **oh, int oh_cnt,
-					 void *pdata, int pdata_len);
-
 struct omap_device *omap_device_alloc(struct platform_device *pdev,
 				      struct omap_hwmod **ohs, int oh_cnt);
 void omap_device_delete(struct omap_device *od);

commit f5c33b070de3fdb8ad995b767ad0e3487cf0d242
Author: Nishanth Menon <nm@ti.com>
Date:   Tue Dec 3 19:39:13 2013 -0600

    ARM: OMAP2+: omap_device: add fail hook for runtime_pm when bad data is detected
    
    Due to the cross dependencies between hwmod for automanaged device
    information for OMAP and dts node definitions, we can run into scenarios
    where the dts node is defined, however it's hwmod entry is yet to be
    added. In these cases:
    a) omap_device does not register a pm_domain (since it cannot find
       hwmod entry).
    b) driver does not know about (a), does a pm_runtime_get_sync which
       never fails
    c) It then tries to do some operation on the device (such as read the
      revision register (as part of probe) without clock or adequate OMAP
      generic PM operation performed for enabling the module.
    
    This causes a crash such as that reported in:
    https://bugzilla.kernel.org/show_bug.cgi?id=66441
    
    When 'ti,hwmod' is provided in dt node, it is expected that the device
    will not function without the OMAP's power automanagement. Hence, when
    we hit a fail condition (due to hwmod entries not present or other
    similar scenario), fail at pm_domain level due to lack of data, provide
    enough information for it to be fixed, however, it allows for the driver
    to take appropriate measures to prevent crash.
    
    Reported-by: Tobias Jakobi <tjakobi@math.uni-bielefeld.de>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Kevin Hilman <khilman@linaro.org>

diff --git a/arch/arm/mach-omap2/omap_device.h b/arch/arm/mach-omap2/omap_device.h
index 17ca1aec2710..78c02b355179 100644
--- a/arch/arm/mach-omap2/omap_device.h
+++ b/arch/arm/mach-omap2/omap_device.h
@@ -29,6 +29,7 @@
 #include "omap_hwmod.h"
 
 extern struct dev_pm_domain omap_device_pm_domain;
+extern struct dev_pm_domain omap_device_fail_pm_domain;
 
 /* omap_device._state values */
 #define OMAP_DEVICE_STATE_UNKNOWN	0

commit 4b7ec5accecdb136c7afaf8739a06d5335cc05aa
Author: Sourav Poddar <sourav.poddar@ti.com>
Date:   Sat Apr 27 01:55:34 2013 +0530

    arm: omap2+: omap_device: remove no_idle_on_suspend
    
    Remove "no_idle_on_suspend" check, since respective
    driver should be able to prevent idling of an
    omap device whenever required.
    
    Driver's can get same behavior by just returning -EBUSY
    from their ->runtime_suspend only during suspend.
    
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Rajendra nayak <rnayak@ti.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Sourav Poddar <sourav.poddar@ti.com>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Kevin Hilman <khilman@linaro.org>

diff --git a/arch/arm/mach-omap2/omap_device.h b/arch/arm/mach-omap2/omap_device.h
index 044c31d50e5b..17ca1aec2710 100644
--- a/arch/arm/mach-omap2/omap_device.h
+++ b/arch/arm/mach-omap2/omap_device.h
@@ -38,7 +38,6 @@ extern struct dev_pm_domain omap_device_pm_domain;
 
 /* omap_device.flags values */
 #define OMAP_DEVICE_SUSPENDED		BIT(0)
-#define OMAP_DEVICE_NO_IDLE_ON_SUSPEND	BIT(1)
 
 /**
  * struct omap_device - omap_device wrapper for platform_devices
@@ -101,13 +100,4 @@ static inline struct omap_device *to_omap_device(struct platform_device *pdev)
 {
 	return pdev ? pdev->archdata.od : NULL;
 }
-
-static inline
-void omap_device_disable_idle_on_suspend(struct platform_device *pdev)
-{
-	struct omap_device *od = to_omap_device(pdev);
-
-	od->flags |= OMAP_DEVICE_NO_IDLE_ON_SUSPEND;
-}
-
 #endif

commit c1d1cd597fc77af3086470f8627d77f52f7f8b6c
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Jan 26 00:48:53 2013 -0700

    ARM: OMAP2+: omap_device: remove obsolete pm_lats and early_device code
    
    Remove now-obsolete code from arch/arm/mach-omap2/omap_device.c.  This
    mostly consists of removing the first attempt at device PM latency
    handling.  This was never really used, has been replaced by the common
    dev_pm_qos code, and needs to go away as part of the DT conversion.
    Also, the early platform_device creation code has been removed, as it
    appears to be unused.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/omap_device.h b/arch/arm/mach-omap2/omap_device.h
index 0933c599bf89..044c31d50e5b 100644
--- a/arch/arm/mach-omap2/omap_device.h
+++ b/arch/arm/mach-omap2/omap_device.h
@@ -13,20 +13,12 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
- * Eventually this type of functionality should either be
- * a) implemented via arch-specific pointers in platform_device
- * or
- * b) implemented as a proper omap_bus/omap_device in Linux, no more
- *    platform_device
+ * This type of functionality should be implemented as a proper
+ * omap_bus/omap_device in Linux.
  *
  * omap_device differs from omap_hwmod in that it includes external
  * (e.g., board- and system-level) integration details.  omap_hwmod
  * stores hardware data that is invariant for a given OMAP chip.
- *
- * To do:
- * - GPIO integration
- * - regulator integration
- *
  */
 #ifndef __ARCH_ARM_PLAT_OMAP_INCLUDE_MACH_OMAP_DEVICE_H
 #define __ARCH_ARM_PLAT_OMAP_INCLUDE_MACH_OMAP_DEVICE_H
@@ -45,19 +37,14 @@ extern struct dev_pm_domain omap_device_pm_domain;
 #define OMAP_DEVICE_STATE_SHUTDOWN	3
 
 /* omap_device.flags values */
-#define OMAP_DEVICE_SUSPENDED BIT(0)
-#define OMAP_DEVICE_NO_IDLE_ON_SUSPEND BIT(1)
+#define OMAP_DEVICE_SUSPENDED		BIT(0)
+#define OMAP_DEVICE_NO_IDLE_ON_SUSPEND	BIT(1)
 
 /**
  * struct omap_device - omap_device wrapper for platform_devices
  * @pdev: platform_device
  * @hwmods: (one .. many per omap_device)
  * @hwmods_cnt: ARRAY_SIZE() of @hwmods
- * @pm_lats: ptr to an omap_device_pm_latency table
- * @pm_lats_cnt: ARRAY_SIZE() of what is passed to @pm_lats
- * @pm_lat_level: array index of the last odpl entry executed - -1 if never
- * @dev_wakeup_lat: dev wakeup latency in nanoseconds
- * @_dev_wakeup_lat_limit: dev wakeup latency limit in nsec - set by OMAP PM
  * @_state: one of OMAP_DEVICE_STATE_* (see above)
  * @flags: device flags
  * @_driver_status: one of BUS_NOTIFY_*_DRIVER from <linux/device.h>
@@ -71,12 +58,7 @@ extern struct dev_pm_domain omap_device_pm_domain;
 struct omap_device {
 	struct platform_device		*pdev;
 	struct omap_hwmod		**hwmods;
-	struct omap_device_pm_latency	*pm_lats;
-	u32				dev_wakeup_lat;
-	u32				_dev_wakeup_lat_limit;
 	unsigned long			_driver_status;
-	u8				pm_lats_cnt;
-	s8				pm_lat_level;
 	u8				hwmods_cnt;
 	u8				_state;
 	u8                              flags;
@@ -86,36 +68,25 @@ struct omap_device {
 
 int omap_device_enable(struct platform_device *pdev);
 int omap_device_idle(struct platform_device *pdev);
-int omap_device_shutdown(struct platform_device *pdev);
 
 /* Core code interface */
 
 struct platform_device *omap_device_build(const char *pdev_name, int pdev_id,
-				      struct omap_hwmod *oh, void *pdata,
-				      int pdata_len,
-				      struct omap_device_pm_latency *pm_lats,
-				      int pm_lats_cnt, int is_early_device);
+					  struct omap_hwmod *oh, void *pdata,
+					  int pdata_len);
 
 struct platform_device *omap_device_build_ss(const char *pdev_name, int pdev_id,
 					 struct omap_hwmod **oh, int oh_cnt,
-					 void *pdata, int pdata_len,
-					 struct omap_device_pm_latency *pm_lats,
-					 int pm_lats_cnt, int is_early_device);
+					 void *pdata, int pdata_len);
 
 struct omap_device *omap_device_alloc(struct platform_device *pdev,
-				      struct omap_hwmod **ohs, int oh_cnt,
-				      struct omap_device_pm_latency *pm_lats,
-				      int pm_lats_cnt);
+				      struct omap_hwmod **ohs, int oh_cnt);
 void omap_device_delete(struct omap_device *od);
 int omap_device_register(struct platform_device *pdev);
 
-void __iomem *omap_device_get_rt_va(struct omap_device *od);
 struct device *omap_device_get_by_hwmod_name(const char *oh_name);
 
 /* OMAP PM interface */
-int omap_device_align_pm_lat(struct platform_device *pdev,
-			     u32 new_wakeup_lat_limit);
-struct powerdomain *omap_device_get_pwrdm(struct omap_device *od);
 int omap_device_get_context_loss_count(struct platform_device *pdev);
 
 /* Other */
@@ -124,40 +95,6 @@ int omap_device_assert_hardreset(struct platform_device *pdev,
 				 const char *name);
 int omap_device_deassert_hardreset(struct platform_device *pdev,
 				 const char *name);
-int omap_device_idle_hwmods(struct omap_device *od);
-int omap_device_enable_hwmods(struct omap_device *od);
-
-int omap_device_disable_clocks(struct omap_device *od);
-int omap_device_enable_clocks(struct omap_device *od);
-
-/*
- * Entries should be kept in latency order ascending
- *
- * deact_lat is the maximum number of microseconds required to complete
- * deactivate_func() at the device's slowest OPP.
- *
- * act_lat is the maximum number of microseconds required to complete
- * activate_func() at the device's slowest OPP.
- *
- * This will result in some suboptimal power management decisions at fast
- * OPPs, but avoids having to recompute all device power management decisions
- * if the system shifts from a fast OPP to a slow OPP (in order to meet
- * latency requirements).
- *
- * XXX should deactivate_func/activate_func() take platform_device pointers
- * rather than omap_device pointers?
- */
-struct omap_device_pm_latency {
-	u32 deactivate_lat;
-	u32 deactivate_lat_worst;
-	int (*deactivate_func)(struct omap_device *od);
-	u32 activate_lat;
-	u32 activate_lat_worst;
-	int (*activate_func)(struct omap_device *od);
-	u32 flags;
-};
-
-#define OMAP_DEVICE_LATENCY_AUTO_ADJUST BIT(1)
 
 /* Get omap_device pointer from platform_device pointer */
 static inline struct omap_device *to_omap_device(struct platform_device *pdev)

commit 2a296c8f89bc6aaf91b255c7d631fcbbfaf840ec
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 2 17:41:35 2012 -0700

    ARM: OMAP: Make plat/omap_hwmod.h local to mach-omap2
    
    Let's make omap_hwmod local to mach-omap2 for
    ARM common zImage support.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.h b/arch/arm/mach-omap2/omap_device.h
index 106f50665804..0933c599bf89 100644
--- a/arch/arm/mach-omap2/omap_device.h
+++ b/arch/arm/mach-omap2/omap_device.h
@@ -34,7 +34,7 @@
 #include <linux/kernel.h>
 #include <linux/platform_device.h>
 
-#include <plat/omap_hwmod.h>
+#include "omap_hwmod.h"
 
 extern struct dev_pm_domain omap_device_pm_domain;
 

commit 25c7d49ed48b4843da7dea56a81ae7f620211ee0
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 2 17:25:48 2012 -0700

    ARM: OMAP: Make omap_device local to mach-omap2
    
    Let's make omap_device local to mach-omap2 for
    ARM common zImage support.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_device.h b/arch/arm/mach-omap2/omap_device.h
new file mode 100644
index 000000000000..106f50665804
--- /dev/null
+++ b/arch/arm/mach-omap2/omap_device.h
@@ -0,0 +1,176 @@
+/*
+ * omap_device headers
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ * Paul Walmsley
+ *
+ * Developed in collaboration with (alphabetical order): Benoit
+ * Cousson, Kevin Hilman, Tony Lindgren, Rajendra Nayak, Vikram
+ * Pandita, Sakari Poussa, Anand Sawant, Santosh Shilimkar, Richard
+ * Woodruff
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Eventually this type of functionality should either be
+ * a) implemented via arch-specific pointers in platform_device
+ * or
+ * b) implemented as a proper omap_bus/omap_device in Linux, no more
+ *    platform_device
+ *
+ * omap_device differs from omap_hwmod in that it includes external
+ * (e.g., board- and system-level) integration details.  omap_hwmod
+ * stores hardware data that is invariant for a given OMAP chip.
+ *
+ * To do:
+ * - GPIO integration
+ * - regulator integration
+ *
+ */
+#ifndef __ARCH_ARM_PLAT_OMAP_INCLUDE_MACH_OMAP_DEVICE_H
+#define __ARCH_ARM_PLAT_OMAP_INCLUDE_MACH_OMAP_DEVICE_H
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+#include <plat/omap_hwmod.h>
+
+extern struct dev_pm_domain omap_device_pm_domain;
+
+/* omap_device._state values */
+#define OMAP_DEVICE_STATE_UNKNOWN	0
+#define OMAP_DEVICE_STATE_ENABLED	1
+#define OMAP_DEVICE_STATE_IDLE		2
+#define OMAP_DEVICE_STATE_SHUTDOWN	3
+
+/* omap_device.flags values */
+#define OMAP_DEVICE_SUSPENDED BIT(0)
+#define OMAP_DEVICE_NO_IDLE_ON_SUSPEND BIT(1)
+
+/**
+ * struct omap_device - omap_device wrapper for platform_devices
+ * @pdev: platform_device
+ * @hwmods: (one .. many per omap_device)
+ * @hwmods_cnt: ARRAY_SIZE() of @hwmods
+ * @pm_lats: ptr to an omap_device_pm_latency table
+ * @pm_lats_cnt: ARRAY_SIZE() of what is passed to @pm_lats
+ * @pm_lat_level: array index of the last odpl entry executed - -1 if never
+ * @dev_wakeup_lat: dev wakeup latency in nanoseconds
+ * @_dev_wakeup_lat_limit: dev wakeup latency limit in nsec - set by OMAP PM
+ * @_state: one of OMAP_DEVICE_STATE_* (see above)
+ * @flags: device flags
+ * @_driver_status: one of BUS_NOTIFY_*_DRIVER from <linux/device.h>
+ *
+ * Integrates omap_hwmod data into Linux platform_device.
+ *
+ * Field names beginning with underscores are for the internal use of
+ * the omap_device code.
+ *
+ */
+struct omap_device {
+	struct platform_device		*pdev;
+	struct omap_hwmod		**hwmods;
+	struct omap_device_pm_latency	*pm_lats;
+	u32				dev_wakeup_lat;
+	u32				_dev_wakeup_lat_limit;
+	unsigned long			_driver_status;
+	u8				pm_lats_cnt;
+	s8				pm_lat_level;
+	u8				hwmods_cnt;
+	u8				_state;
+	u8                              flags;
+};
+
+/* Device driver interface (call via platform_data fn ptrs) */
+
+int omap_device_enable(struct platform_device *pdev);
+int omap_device_idle(struct platform_device *pdev);
+int omap_device_shutdown(struct platform_device *pdev);
+
+/* Core code interface */
+
+struct platform_device *omap_device_build(const char *pdev_name, int pdev_id,
+				      struct omap_hwmod *oh, void *pdata,
+				      int pdata_len,
+				      struct omap_device_pm_latency *pm_lats,
+				      int pm_lats_cnt, int is_early_device);
+
+struct platform_device *omap_device_build_ss(const char *pdev_name, int pdev_id,
+					 struct omap_hwmod **oh, int oh_cnt,
+					 void *pdata, int pdata_len,
+					 struct omap_device_pm_latency *pm_lats,
+					 int pm_lats_cnt, int is_early_device);
+
+struct omap_device *omap_device_alloc(struct platform_device *pdev,
+				      struct omap_hwmod **ohs, int oh_cnt,
+				      struct omap_device_pm_latency *pm_lats,
+				      int pm_lats_cnt);
+void omap_device_delete(struct omap_device *od);
+int omap_device_register(struct platform_device *pdev);
+
+void __iomem *omap_device_get_rt_va(struct omap_device *od);
+struct device *omap_device_get_by_hwmod_name(const char *oh_name);
+
+/* OMAP PM interface */
+int omap_device_align_pm_lat(struct platform_device *pdev,
+			     u32 new_wakeup_lat_limit);
+struct powerdomain *omap_device_get_pwrdm(struct omap_device *od);
+int omap_device_get_context_loss_count(struct platform_device *pdev);
+
+/* Other */
+
+int omap_device_assert_hardreset(struct platform_device *pdev,
+				 const char *name);
+int omap_device_deassert_hardreset(struct platform_device *pdev,
+				 const char *name);
+int omap_device_idle_hwmods(struct omap_device *od);
+int omap_device_enable_hwmods(struct omap_device *od);
+
+int omap_device_disable_clocks(struct omap_device *od);
+int omap_device_enable_clocks(struct omap_device *od);
+
+/*
+ * Entries should be kept in latency order ascending
+ *
+ * deact_lat is the maximum number of microseconds required to complete
+ * deactivate_func() at the device's slowest OPP.
+ *
+ * act_lat is the maximum number of microseconds required to complete
+ * activate_func() at the device's slowest OPP.
+ *
+ * This will result in some suboptimal power management decisions at fast
+ * OPPs, but avoids having to recompute all device power management decisions
+ * if the system shifts from a fast OPP to a slow OPP (in order to meet
+ * latency requirements).
+ *
+ * XXX should deactivate_func/activate_func() take platform_device pointers
+ * rather than omap_device pointers?
+ */
+struct omap_device_pm_latency {
+	u32 deactivate_lat;
+	u32 deactivate_lat_worst;
+	int (*deactivate_func)(struct omap_device *od);
+	u32 activate_lat;
+	u32 activate_lat_worst;
+	int (*activate_func)(struct omap_device *od);
+	u32 flags;
+};
+
+#define OMAP_DEVICE_LATENCY_AUTO_ADJUST BIT(1)
+
+/* Get omap_device pointer from platform_device pointer */
+static inline struct omap_device *to_omap_device(struct platform_device *pdev)
+{
+	return pdev ? pdev->archdata.od : NULL;
+}
+
+static inline
+void omap_device_disable_idle_on_suspend(struct platform_device *pdev)
+{
+	struct omap_device *od = to_omap_device(pdev);
+
+	od->flags |= OMAP_DEVICE_NO_IDLE_ON_SUSPEND;
+}
+
+#endif
