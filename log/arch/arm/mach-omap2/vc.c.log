commit c145649bf262a0614fbe5955bdffdfaba9023fce
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Oct 17 06:34:34 2019 -0700

    ARM: OMAP2+: Configure voltage controller for cpcap to low-speed
    
    Looks like the i2c timings in high-speed mode do not work properly to
    allow us to clear I2C_DISABLE bits for PRM_VOLTCTRL register and the
    device reboots if I2C_DISABLE bits are cleared.
    
    Let's configure the voltage controller i2c for low-speed mode as done in
    the Motorola Mapphone Android Linux kernel. This saves us about 7mW of
    power during retention compared to the high-speed values.
    
    Let's also change the low-speed warning to pr_info about relying on the
    bootloader configured low-speed values like we currently do.
    
    Cc: Merlijn Wajer <merlijn@wizzup.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Sebastian Reichel <sre@kernel.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 888b8eecaf4d..86f1ac4c2412 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -670,7 +670,7 @@ static void __init omap4_vc_i2c_timing_init(struct voltagedomain *voltdm)
 	const struct i2c_init_data *i2c_data;
 
 	if (!voltdm->pmic->i2c_high_speed) {
-		pr_warn("%s: only high speed supported!\n", __func__);
+		pr_info("%s: using bootloader low-speed timings\n", __func__);
 		return;
 	}
 

commit 71065d3fe82dbb2a827a081ceeca272ab7fa0905
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Oct 18 15:09:53 2019 -0700

    ARM: OMAP2+: Configure voltage controller for retention
    
    Similar to existing omap3_vc_set_pmic_signaling(), let's add omap4
    specific omap4_vc_set_pmic_signaling(). This allows the configured
    devices to enable voltage controller for retention later on during
    init.
    
    Cc: Merlijn Wajer <merlijn@wizzup.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Sebastian Reichel <sre@kernel.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 3c94d1da4c84..888b8eecaf4d 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -36,15 +36,21 @@
 #define OMAP4430_AUTO_CTRL_VDD_CORE(x)		((x) << 0)
 #define OMAP4430_AUTO_CTRL_VDD_RET		2
 
-#define OMAP4_VDD_DEFAULT_VAL	\
+#define OMAP4430_VDD_I2C_DISABLE_MASK	\
 	(OMAP4430_VDD_IVA_I2C_DISABLE | \
-	 OMAP4430_VDD_MPU_I2C_DISABLE |	 \
-	 OMAP4430_VDD_CORE_I2C_DISABLE | \
+	 OMAP4430_VDD_MPU_I2C_DISABLE | \
+	 OMAP4430_VDD_CORE_I2C_DISABLE)
+
+#define OMAP4_VDD_DEFAULT_VAL	\
+	(OMAP4430_VDD_I2C_DISABLE_MASK | \
 	 OMAP4430_VDD_IVA_PRESENCE | OMAP4430_VDD_MPU_PRESENCE | \
 	 OMAP4430_AUTO_CTRL_VDD_IVA(OMAP4430_AUTO_CTRL_VDD_RET) | \
 	 OMAP4430_AUTO_CTRL_VDD_MPU(OMAP4430_AUTO_CTRL_VDD_RET) | \
 	 OMAP4430_AUTO_CTRL_VDD_CORE(OMAP4430_AUTO_CTRL_VDD_RET))
 
+#define OMAP4_VDD_RET_VAL	\
+	(OMAP4_VDD_DEFAULT_VAL & ~OMAP4430_VDD_I2C_DISABLE_MASK)
+
 /**
  * struct omap_vc_channel_cfg - describe the cfg_channel bitfield
  * @sa: bit for slave address
@@ -299,6 +305,26 @@ void omap3_vc_set_pmic_signaling(int core_next_state)
 	}
 }
 
+void omap4_vc_set_pmic_signaling(int core_next_state)
+{
+	struct voltagedomain *vd = vc.vd;
+	u32 val;
+
+	if (!vd)
+		return;
+
+	switch (core_next_state) {
+	case PWRDM_POWER_RET:
+		val = OMAP4_VDD_RET_VAL;
+		break;
+	default:
+		val = OMAP4_VDD_DEFAULT_VAL;
+		break;
+	}
+
+	vd->write(val, OMAP4_PRM_VOLTCTRL_OFFSET);
+}
+
 /*
  * Configure signal polarity for sys_clkreq and sys_off_mode pins
  * as the default values are wrong and can cause the system to hang

commit 4873843718f903de74b496e39367dc7aaf267c37
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Oct 16 07:37:07 2019 -0700

    ARM: OMAP2+: Initialize voltage controller for omap4
    
    We're missing initializing the PRM_VOLTCTRL register for voltage
    controller. Let's add omap4_vc_init_pmic_signaling() similar to what we
    have for omap3 and enable voltage control for retention.
    
    This brings down droid4 power consumption with mainline kernel to somewhere
    between 40 and 50mW from about 70 to 80 mW for the whole device when
    running idle with LCD and backlight off, WLAN connected, and USB and modem
    modules unloaded.
    
    Mostly just rmmod of omap2430, ohci-platform and phy-mapphone-mdm6600 are
    needed to idle USB and shut down the modem. And after that measuring idle
    power consumption can be done with reading sysfs entry periodically
    for /sys/class/power_supply/battery/power_avg. Then rmmod of phy-cpcap-usb
    will save few more mW, but will disable the debug UART.
    
    Note that sometimes CM_L4PER_UART1_CLKCTRL at 0x4a009540 does not idle
    properly after unloading of phy-mapphone-mdm6600.
    
    Cc: Merlijn Wajer <merlijn@wizzup.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Sebastian Reichel <sre@kernel.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index d76b1e5eb8ba..3c94d1da4c84 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -26,6 +26,25 @@
 #include "scrm44xx.h"
 #include "control.h"
 
+#define OMAP4430_VDD_IVA_I2C_DISABLE		BIT(14)
+#define OMAP4430_VDD_MPU_I2C_DISABLE		BIT(13)
+#define OMAP4430_VDD_CORE_I2C_DISABLE		BIT(12)
+#define OMAP4430_VDD_IVA_PRESENCE		BIT(9)
+#define OMAP4430_VDD_MPU_PRESENCE		BIT(8)
+#define OMAP4430_AUTO_CTRL_VDD_IVA(x)		((x) << 4)
+#define OMAP4430_AUTO_CTRL_VDD_MPU(x)		((x) << 2)
+#define OMAP4430_AUTO_CTRL_VDD_CORE(x)		((x) << 0)
+#define OMAP4430_AUTO_CTRL_VDD_RET		2
+
+#define OMAP4_VDD_DEFAULT_VAL	\
+	(OMAP4430_VDD_IVA_I2C_DISABLE | \
+	 OMAP4430_VDD_MPU_I2C_DISABLE |	 \
+	 OMAP4430_VDD_CORE_I2C_DISABLE | \
+	 OMAP4430_VDD_IVA_PRESENCE | OMAP4430_VDD_MPU_PRESENCE | \
+	 OMAP4430_AUTO_CTRL_VDD_IVA(OMAP4430_AUTO_CTRL_VDD_RET) | \
+	 OMAP4430_AUTO_CTRL_VDD_MPU(OMAP4430_AUTO_CTRL_VDD_RET) | \
+	 OMAP4430_AUTO_CTRL_VDD_CORE(OMAP4430_AUTO_CTRL_VDD_RET))
+
 /**
  * struct omap_vc_channel_cfg - describe the cfg_channel bitfield
  * @sa: bit for slave address
@@ -542,9 +561,19 @@ static void omap4_set_timings(struct voltagedomain *voltdm, bool off_mode)
 	writel_relaxed(val, OMAP4_SCRM_CLKSETUPTIME);
 }
 
+static void __init omap4_vc_init_pmic_signaling(struct voltagedomain *voltdm)
+{
+	if (vc.vd)
+		return;
+
+	vc.vd = voltdm;
+	voltdm->write(OMAP4_VDD_DEFAULT_VAL, OMAP4_PRM_VOLTCTRL_OFFSET);
+}
+
 /* OMAP4 specific voltage init functions */
 static void __init omap4_vc_init_channel(struct voltagedomain *voltdm)
 {
+	omap4_vc_init_pmic_signaling(voltdm);
 	omap4_set_timings(voltdm, true);
 	omap4_set_timings(voltdm, false);
 }

commit 0527873b29b077fc8e656acd63e1866b429fef55
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu May 11 13:50:16 2017 +0200

    ARM: remove duplicate 'const' annotations'
    
    gcc-7 warns about some declarations that are more 'const' than necessary:
    
    arch/arm/mach-at91/pm.c:338:34: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct of_device_id const ramc_ids[] __initconst = {
    arch/arm/mach-bcm/bcm_kona_smc.c:36:34: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct of_device_id const bcm_kona_smc_ids[] __initconst = {
    arch/arm/mach-spear/time.c:207:34: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct of_device_id const timer_of_match[] __initconst = {
    arch/arm/mach-omap2/prm_common.c:714:34: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct of_device_id const omap_prcm_dt_match_table[] __initconst = {
    arch/arm/mach-omap2/vc.c:562:35: error: duplicate 'const' declaration specifier [-Werror=duplicate-decl-specifier]
     static const struct i2c_init_data const omap4_i2c_timing_data[] __initconst = {
    
    The ones in arch/arm were apparently all introduced accidentally by one
    commit that correctly marked a lot of variables as __initconst.
    
    Fixes: 19c233b79d1a ("ARM: appropriate __init annotation for const data")
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Krzysztof Hałasa <khalasa@piap.pl>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 2028167fff31..d76b1e5eb8ba 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -559,7 +559,7 @@ struct i2c_init_data {
 	u8 hsscll_12;
 };
 
-static const struct i2c_init_data const omap4_i2c_timing_data[] __initconst = {
+static const struct i2c_init_data omap4_i2c_timing_data[] __initconst = {
 	{
 		.load = 50,
 		.loadbits = 0x3,

commit bf0584959a5bbefbb97efcd4bc8617034bba8906
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Thu Sep 17 15:24:14 2015 +0200

    ARM: OMAP3: vc: Remove unused macros
    
    The PRM_POLCTRL_TWL_MASK and PRM_POLCTRL_TWL_MASK
    macros are not used so they can be deleted.
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index d44d311704ba..2028167fff31 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -280,10 +280,6 @@ void omap3_vc_set_pmic_signaling(int core_next_state)
 	}
 }
 
-#define PRM_POLCTRL_TWL_MASK	(OMAP3430_PRM_POLCTRL_CLKREQ_POL | \
-					OMAP3430_PRM_POLCTRL_CLKREQ_POL)
-#define PRM_POLCTRL_TWL_VAL	OMAP3430_PRM_POLCTRL_CLKREQ_POL
-
 /*
  * Configure signal polarity for sys_clkreq and sys_off_mode pins
  * as the default values are wrong and can cause the system to hang

commit 05f4f1abc274ac7e8e83424d0cef2d842db91815
Author: Frans Klaver <fransklaver@gmail.com>
Date:   Tue Sep 1 13:59:25 2015 -0700

    ARM: OMAP3: vc: fix 'or' always true warning
    
    Fix the warning:
    arch/arm/mach-omap2/vc.c:302:47: warning: logical ‘or’ of collectively exhaustive tests is always true [-Wlogical-op]
    
    As we're toggling both CLKREQ and OFFMODE, we should also be checking
    OFFMODE.
    
    Signed-off-by: Frans Klaver <fransklaver@gmail.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index e5a35f6b83a7..d44d311704ba 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -300,7 +300,7 @@ static void __init omap3_vc_init_pmic_signaling(struct voltagedomain *voltdm)
 
 	val = voltdm->read(OMAP3_PRM_POLCTRL_OFFSET);
 	if (!(val & OMAP3430_PRM_POLCTRL_CLKREQ_POL) ||
-	    (val & OMAP3430_PRM_POLCTRL_CLKREQ_POL)) {
+	    (val & OMAP3430_PRM_POLCTRL_OFFMODE_POL)) {
 		val |= OMAP3430_PRM_POLCTRL_CLKREQ_POL;
 		val &= ~OMAP3430_PRM_POLCTRL_OFFMODE_POL;
 		pr_debug("PM: fixing sys_clkreq and sys_off_mode polarity to 0x%x\n",

commit 19c233b79d1af7b5af1ec68c1172848648184449
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Mon Jul 27 18:27:52 2015 -0400

    ARM: appropriate __init annotation for const data
    
    Init data marked const should be annotated with __initconst for
    correctness and not __initdata.  In some cases the array gathering
    references to that data has to be marked const as well. This fixes
    LTO builds that otherwise fail with section mismatch errors.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 076fd20d7e5a..e5a35f6b83a7 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -563,7 +563,7 @@ struct i2c_init_data {
 	u8 hsscll_12;
 };
 
-static const __initdata struct i2c_init_data omap4_i2c_timing_data[] = {
+static const struct i2c_init_data const omap4_i2c_timing_data[] __initconst = {
 	{
 		.load = 50,
 		.loadbits = 0x3,

commit 102bcb6ed2d1c3ffcc7269afc957c2df11942085
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon May 4 08:54:41 2015 -0700

    ARM: OMAP2+: Fix omap off idle power consumption creeping up
    
    If we use a combination of VMODE and I2C4 for retention modes,
    eventually the off idle power consumption will creep up by about
    23mW, even during off mode with I2C4 always staying enabled.
    
    Turns out this is because of erratum i531 "Extra Power Consumed
    When Repeated Start Operation Mode Is Enabled on I2C Interface
    Dedicated for Smart Reflex (I2C4)" as pointed out by Nishanth
    Menon <nm@ti.com>.
    
    Let's fix the issue by adding i2c_cfg_clear_mask for the bits
    to clear when initializing the I2C4 adapter so we can clear
    SREN bit that drives the I2C4 lines low otherwise when there
    is no traffic.
    
    Fixes: 3b8c4ebb7630 ("ARM: OMAP3: Fix idle mode signaling for
    Cc: stable@vger.kernel.org # v3.16+
    sys_clkreq and sys_off_mode")
    Cc: Kevin Hilman <khilman@kernel.org>
    Cc: Tero Kristo <t-kristo@ti.com>
    Reviewed-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index be9ef834fa81..076fd20d7e5a 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -316,7 +316,8 @@ static void __init omap3_vc_init_pmic_signaling(struct voltagedomain *voltdm)
 	 * idle. And we can also scale voltages to zero for off-idle.
 	 * Note that no actual voltage scaling during off-idle will
 	 * happen unless the board specific twl4030 PMIC scripts are
-	 * loaded.
+	 * loaded. See also omap_vc_i2c_init for comments regarding
+	 * erratum i531.
 	 */
 	val = voltdm->read(OMAP3_PRM_VOLTCTRL_OFFSET);
 	if (!(val & OMAP3430_PRM_VOLTCTRL_SEL_OFF)) {
@@ -704,9 +705,16 @@ static void __init omap_vc_i2c_init(struct voltagedomain *voltdm)
 		return;
 	}
 
+	/*
+	 * Note that for omap3 OMAP3430_SREN_MASK clears SREN to work around
+	 * erratum i531 "Extra Power Consumed When Repeated Start Operation
+	 * Mode Is Enabled on I2C Interface Dedicated for Smart Reflex (I2C4)".
+	 * Otherwise I2C4 eventually leads into about 23mW extra power being
+	 * consumed even during off idle using VMODE.
+	 */
 	i2c_high_speed = voltdm->pmic->i2c_high_speed;
 	if (i2c_high_speed)
-		voltdm->rmw(vc->common->i2c_cfg_hsen_mask,
+		voltdm->rmw(vc->common->i2c_cfg_clear_mask,
 			    vc->common->i2c_cfg_hsen_mask,
 			    vc->common->i2c_cfg_reg);
 

commit 3d0cb73e9c85e60206ea9d5191bc0b9a0c4c8a99
Author: Joe Perches <joe@perches.com>
Date:   Sat Sep 13 11:31:16 2014 -0700

    arm: mach-omap2: Convert pr_warning to pr_warn
    
    Use the more common pr_warn.
    
    Other miscellanea:
    
    o Realign arguments
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index a4628a9e760c..be9ef834fa81 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -198,7 +198,7 @@ int omap_vc_bypass_scale(struct voltagedomain *voltdm,
 		loop_cnt++;
 
 		if (retries_cnt > 10) {
-			pr_warning("%s: Retry count exceeded\n", __func__);
+			pr_warn("%s: Retry count exceeded\n", __func__);
 			return -ETIMEDOUT;
 		}
 

commit 825f4e0271b0de3f7f31d963dcdaa0056fe9b73a
Merge: 0a58471541cc b5b9324a6296
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 2 16:15:12 2014 -0700

    Merge tag 'soc-for-3.16' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc into next
    
    Pull part one of ARM SoC updates from Olof Johansson:
     "A quite large set of SoC updates this cycle.  In no particular order:
    
       - Multi-cluster power management for Samsung Exynos, adding support
         for big.LITTLE CPU switching on EXYNOS5
    
       - SMP support for Marvell Armada 375 and 38x
    
       - SMP rework on Allwinner A31
    
       - Xilinx Zynq support for SOC_BUS, big endian
    
       - Marvell orion5x platform cleanup, modernizing the implementation
         and moving to DT.
    
       - _Finally_ moving Samsung Exynos over to support MULTIPLATFORM, so
         that their platform can be enabled in the same kernel binary as
         most of the other v7 platforms in the tree.  \o/
    
         The work isn't quite complete, there's some driver fixes still
         needed, but the basics now work.
    
      New SoC support added:
    
       - Freescale i.MX6SX
    
       - LSI Axxia AXM55xx SoCs
    
       - Samsung EXYNOS 3250, 5260, 5410, 5420 and 5800
    
       - STi STIH407
    
      plus a large set of various smaller updates for different platforms.
      I'm probably missing some important one here"
    
    * tag 'soc-for-3.16' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (281 commits)
      ARM: exynos: don't run exynos4 l2x0 setup on other platforms
      ARM: exynos: Fix "allmodconfig" build errors in mcpm and hotplug
      ARM: EXYNOS: mcpm rename the power_down_finish
      ARM: EXYNOS: Enable mcpm for dual-cluster exynos5800 SoC
      ARM: EXYNOS: Enable multi-platform build support
      ARM: EXYNOS: Consolidate Kconfig entries
      ARM: EXYNOS: Add support for EXYNOS5410 SoC
      ARM: EXYNOS: Support secondary CPU boot of Exynos3250
      ARM: EXYNOS: Add Exynos3250 SoC ID
      ARM: EXYNOS: Add 5800 SoC support
      ARM: EXYNOS: initial board support for exynos5260 SoC
      clk: exynos5410: register clocks using common clock framework
      ARM: debug: qcom: add UART addresses to Kconfig help for APQ8084
      ARM: sunxi: allow building without reset controller
      Documentation: devicetree: arm: sort enable-method entries
      ARM: rockchip: convert smp bringup to CPU_METHOD_OF_DECLARE
      clk: exynos5250: Add missing sysmmu clocks for DISP and ISP blocks
      ARM: dts: axxia: Add reset controller
      power: reset: Add Axxia system reset driver
      ARM: axxia: Adding defconfig for AXM55xx
      ...

commit edfaf05c2fcb853fcf35f12aeb9c340f5913337f
Author: Victor Kamensky <victor.kamensky@linaro.org>
Date:   Tue Apr 15 20:37:46 2014 +0300

    ARM: OMAP2+: raw read and write endian fix
    
    All OMAP IP blocks expect LE data, but CPU may operate in BE mode.
    Need to use endian neutral functions to read/write h/w registers.
    I.e instead of __raw_read[lw] and __raw_write[lw] functions code
    need to use read[lw]_relaxed and write[lw]_relaxed functions.
    If the first simply reads/writes register, the second will byteswap
    it if host operates in BE mode.
    
    Changes are trivial sed like replacement of __raw_xxx functions
    with xxx_relaxed variant.
    
    Signed-off-by: Victor Kamensky <victor.kamensky@linaro.org>
    Signed-off-by: Taras Kondratiuk <taras.kondratiuk@linaro.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 49ac7977e03e..267f204559c3 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -462,7 +462,7 @@ static void omap4_set_timings(struct voltagedomain *voltdm, bool off_mode)
 	val |= omap4_usec_to_val_scrm(tshut, OMAP4_DOWNTIME_SHIFT,
 		OMAP4_DOWNTIME_MASK);
 
-	__raw_writel(val, OMAP4_SCRM_CLKSETUPTIME);
+	writel_relaxed(val, OMAP4_SCRM_CLKSETUPTIME);
 }
 
 /* OMAP4 specific voltage init functions */
@@ -584,7 +584,7 @@ static void __init omap4_vc_i2c_timing_init(struct voltagedomain *voltdm)
 	val = i2c_data->loadbits << 25 | i2c_data->loadbits << 29;
 
 	/* Write to SYSCTRL_PADCONF_WKUP_CTRL_I2C_2 to setup I2C pull */
-	__raw_writel(val, OMAP2_L4_IO_ADDRESS(OMAP4_CTRL_MODULE_PAD_WKUP +
+	writel_relaxed(val, OMAP2_L4_IO_ADDRESS(OMAP4_CTRL_MODULE_PAD_WKUP +
 				OMAP4_CTRL_MODULE_PAD_WKUP_CONTROL_I2C_2));
 
 	/* HSSCLH can always be zero */

commit c46f601cc2a0e8edc97953c0b5d2acb709be71ba
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon May 5 17:27:36 2014 -0700

    ARM: OMAP3: Fix voltage control for deeper idle states
    
    Currently we're attempting to use a static value for the
    voltctrl register that only works for controlling the PMIC
    over I2C4. For using sys_off_mode signaling, we need to update
    update clksetup, voltsetup1, voltsetup2 and voltctrl registers
    dynamically depending on the idle state.
    
    So let's fix this by configuring things for I2C4 controlled idle
    and sys_off_mode pin controlled idle, and then write the
    configured register values depending on the idle state. This
    is similar what N900 kernel is doing too.
    
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Nishanth Menon <nm@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 728d64daab25..0d1629c5f84e 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -220,35 +220,64 @@ static inline u32 omap_usec_to_32k(u32 usec)
 	return DIV_ROUND_UP_ULL(32768ULL * (u64)usec, 1000000ULL);
 }
 
+struct omap3_vc_timings {
+	u32 voltsetup1;
+	u32 voltsetup2;
+};
+
 struct omap3_vc {
 	struct voltagedomain *vd;
 	u32 voltctrl;
+	u32 voltsetup1;
+	u32 voltsetup2;
+	struct omap3_vc_timings timings[2];
 };
 static struct omap3_vc vc;
 
 void omap3_vc_set_pmic_signaling(int core_next_state)
 {
 	struct voltagedomain *vd = vc.vd;
-	u32 voltctrl;
+	struct omap3_vc_timings *c = vc.timings;
+	u32 voltctrl, voltsetup1, voltsetup2;
 
 	voltctrl = vc.voltctrl;
+	voltsetup1 = vc.voltsetup1;
+	voltsetup2 = vc.voltsetup2;
+
 	switch (core_next_state) {
 	case PWRDM_POWER_OFF:
 		voltctrl &= ~(OMAP3430_PRM_VOLTCTRL_AUTO_RET |
 			      OMAP3430_PRM_VOLTCTRL_AUTO_SLEEP);
 		voltctrl |= OMAP3430_PRM_VOLTCTRL_AUTO_OFF;
+		if (voltctrl & OMAP3430_PRM_VOLTCTRL_SEL_OFF)
+			voltsetup2 = c->voltsetup2;
+		else
+			voltsetup1 = c->voltsetup1;
 		break;
 	case PWRDM_POWER_RET:
 	default:
+		c++;
 		voltctrl &= ~(OMAP3430_PRM_VOLTCTRL_AUTO_OFF |
 			      OMAP3430_PRM_VOLTCTRL_AUTO_SLEEP);
 		voltctrl |= OMAP3430_PRM_VOLTCTRL_AUTO_RET;
+		voltsetup1 = c->voltsetup1;
 		break;
 	}
+
 	if (voltctrl != vc.voltctrl) {
 		vd->write(voltctrl, OMAP3_PRM_VOLTCTRL_OFFSET);
 		vc.voltctrl = voltctrl;
 	}
+	if (voltsetup1 != vc.voltsetup1) {
+		vd->write(c->voltsetup1,
+			  OMAP3_PRM_VOLTSETUP1_OFFSET);
+		vc.voltsetup1 = voltsetup1;
+	}
+	if (voltsetup2 != vc.voltsetup2) {
+		vd->write(c->voltsetup2,
+			  OMAP3_PRM_VOLTSETUP2_OFFSET);
+		vc.voltsetup2 = voltsetup2;
+	}
 }
 
 #define PRM_POLCTRL_TWL_MASK	(OMAP3430_PRM_POLCTRL_CLKREQ_POL | \
@@ -301,6 +330,18 @@ static void __init omap3_vc_init_pmic_signaling(struct voltagedomain *voltdm)
 	omap3_vc_set_pmic_signaling(PWRDM_POWER_ON);
 }
 
+static void omap3_init_voltsetup1(struct voltagedomain *voltdm,
+				  struct omap3_vc_timings *c, u32 idle)
+{
+	unsigned long val;
+
+	val = (voltdm->vc_param->on - idle) / voltdm->pmic->slew_rate;
+	val *= voltdm->sys_clk.rate / 8 / 1000000 + 1;
+	val <<= __ffs(voltdm->vfsm->voltsetup_mask);
+	c->voltsetup1 &= ~voltdm->vfsm->voltsetup_mask;
+	c->voltsetup1 |= val;
+}
+
 /**
  * omap3_set_i2c_timings - sets i2c sleep timings for a channel
  * @voltdm: channel to configure
@@ -311,31 +352,21 @@ static void __init omap3_vc_init_pmic_signaling(struct voltagedomain *voltdm)
  * or retention. Off mode has additionally an option to use sys_off_mode
  * pad, which uses a global signal to program the whole power IC to
  * off-mode.
+ *
+ * Note that pmic is not controlling the voltage scaling during
+ * retention signaled over I2C4, so we can keep voltsetup2 as 0.
+ * And the oscillator is not shut off over I2C4, so no need to
+ * set clksetup.
  */
-static void omap3_set_i2c_timings(struct voltagedomain *voltdm, bool off_mode)
+static void omap3_set_i2c_timings(struct voltagedomain *voltdm)
 {
-	unsigned long voltsetup1;
-	u32 tgt_volt;
-
-	if (off_mode)
-		tgt_volt = voltdm->vc_param->off;
-	else
-		tgt_volt = voltdm->vc_param->ret;
-
-	voltsetup1 = (voltdm->vc_param->on - tgt_volt) /
-			voltdm->pmic->slew_rate;
+	struct omap3_vc_timings *c = vc.timings;
 
-	voltsetup1 = voltsetup1 * voltdm->sys_clk.rate / 8 / 1000000 + 1;
-
-	voltdm->rmw(voltdm->vfsm->voltsetup_mask,
-		voltsetup1 << __ffs(voltdm->vfsm->voltsetup_mask),
-		voltdm->vfsm->voltsetup_reg);
-
-	/*
-	 * pmic is not controlling the voltage scaling during retention,
-	 * thus set voltsetup2 to 0
-	 */
-	voltdm->write(0, OMAP3_PRM_VOLTSETUP2_OFFSET);
+	/* Configure PRWDM_POWER_OFF over I2C4 */
+	omap3_init_voltsetup1(voltdm, c, voltdm->vc_param->off);
+	c++;
+	/* Configure PRWDM_POWER_RET over I2C4 */
+	omap3_init_voltsetup1(voltdm, c, voltdm->vc_param->ret);
 }
 
 /**
@@ -344,22 +375,49 @@ static void omap3_set_i2c_timings(struct voltagedomain *voltdm, bool off_mode)
  *
  * Calculates and sets up off-mode timings for a channel. Off-mode
  * can use either I2C based voltage scaling, or alternatively
- * sys_off_mode pad can be used to send a global command to power IC.
- * This function first checks which mode is being used, and calls
- * omap3_set_i2c_timings() if the system is using I2C control mode.
+ * sys_off_mode pad can be used to send a global command to power IC.n,
  * sys_off_mode has the additional benefit that voltages can be
  * scaled to zero volt level with TWL4030 / TWL5030, I2C can only
  * scale to 600mV.
+ *
+ * Note that omap is not controlling the voltage scaling during
+ * off idle signaled by sys_off_mode, so we can keep voltsetup1
+ * as 0.
  */
 static void omap3_set_off_timings(struct voltagedomain *voltdm)
 {
+	struct omap3_vc_timings *c = vc.timings;
+	u32 tstart, tshut, clksetup, voltoffset;
+
+	if (c->voltsetup2)
+		return;
+
+	omap_pm_get_oscillator(&tstart, &tshut);
+	if (tstart == ULONG_MAX) {
+		pr_debug("PM: oscillator start-up time not initialized, using 10ms\n");
+		clksetup = omap_usec_to_32k(10000);
+	} else {
+		clksetup = omap_usec_to_32k(tstart);
+	}
+
+	/*
+	 * For twl4030 errata 27, we need to allow minimum ~488.32 us wait to
+	 * switch from HFCLKIN to internal oscillator. That means timings
+	 * have voltoffset fixed to 0xa in rounded up 32 KiHz cycles. And
+	 * that means we can calculate the value based on the oscillator
+	 * start-up time since voltoffset2 = clksetup - voltoffset.
+	 */
+	voltoffset = omap_usec_to_32k(488);
+	c->voltsetup2 = clksetup - voltoffset;
+	voltdm->write(clksetup, OMAP3_PRM_CLKSETUP_OFFSET);
+	voltdm->write(voltoffset, OMAP3_PRM_VOLTOFFSET_OFFSET);
 }
 
 static void __init omap3_vc_init_channel(struct voltagedomain *voltdm)
 {
 	omap3_vc_init_pmic_signaling(voltdm);
 	omap3_set_off_timings(voltdm);
-	omap3_set_i2c_timings(voltdm, true);
+	omap3_set_i2c_timings(voltdm);
 }
 
 /**

commit 9eca2837dd69eeae0dd36ed0853d04b4de6c23bd
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon May 5 17:27:35 2014 -0700

    ARM: OMAP3: Disable broken omap3_set_off_timings function
    
    Commit c589eb3869a8 (ARM: OMAP3: VC: calculate ramp times)
    started using regulator slew rates for calculating the idle
    mode start-up times. This works fine for I2C4 controlled
    regulator scaling as the regulators are never completely
    turned off.
    
    For sys_off_mode pin controlled PMIC scripts, the slew rate
    based calculations won't work at all as the regulators are
    completely turned off and the start-up time is much longer.
    
    This means currently omap3_set_off_timings currently has
    zero chance of working on any real hardare. The current code
    is broken in at least the following ways:
    
    1. It attempts to use the default ULONG_MAX value for the
       oscillator start-up value as we're currently never
       initializing the start-up value.
    
    2. It relies on a magic number potentially set by the
       bootloader for volsetup2 register.
    
    3. If no magic value is passed, it attempts to calculate
       voltsetup2 register based on the regulator slew rate.
       This won't work as there is roughly at least five
       times the delay needed for turning on vdd1 and vdd2
       regulators.
    
    4. It does duplicate register write to OMAP3_PRM_VOLTOFFSET
    
    5. It duplicates the code for omap_usec_to_32k unnecessarily
    
    6. It initialized global registers twice, once for each channel
    
    Let's just remove the broken code and call omap3_set_i2c_timings
    directly, we're better off with this function doing nothing until
    it's fixed. And otherwise further fixes to omap3_set_off_timings
    will be unreadable.
    
    And let's get rid of omap3_set_clksetup as that's not needed
    for off-idle controlled by I2C4 as in that case the oscillator
    is never shut down.
    
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Nishanth Menon <nm@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 705eb35d7b35..728d64daab25 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -301,12 +301,6 @@ static void __init omap3_vc_init_pmic_signaling(struct voltagedomain *voltdm)
 	omap3_vc_set_pmic_signaling(PWRDM_POWER_ON);
 }
 
-/* Set oscillator setup time for omap3 */
-static void omap3_set_clksetup(u32 usec, struct voltagedomain *voltdm)
-{
-	voltdm->write(omap_usec_to_32k(usec), OMAP3_PRM_CLKSETUP_OFFSET);
-}
-
 /**
  * omap3_set_i2c_timings - sets i2c sleep timings for a channel
  * @voltdm: channel to configure
@@ -323,12 +317,6 @@ static void omap3_set_i2c_timings(struct voltagedomain *voltdm, bool off_mode)
 	unsigned long voltsetup1;
 	u32 tgt_volt;
 
-	/*
-	 * Oscillator is shut down only if we are using sys_off_mode pad,
-	 * thus we set a minimal setup time here
-	 */
-	omap3_set_clksetup(1, voltdm);
-
 	if (off_mode)
 		tgt_volt = voltdm->vc_param->off;
 	else
@@ -365,61 +353,13 @@ static void omap3_set_i2c_timings(struct voltagedomain *voltdm, bool off_mode)
  */
 static void omap3_set_off_timings(struct voltagedomain *voltdm)
 {
-	unsigned long clksetup;
-	unsigned long voltsetup2;
-	unsigned long voltsetup2_old;
-	u32 val;
-	u32 tstart, tshut;
-
-	/* check if sys_off_mode is used to control off-mode voltages */
-	val = voltdm->read(OMAP3_PRM_VOLTCTRL_OFFSET);
-	if (!(val & OMAP3430_PRM_VOLTCTRL_SEL_OFF)) {
-		/* No, omap is controlling them over I2C */
-		omap3_set_i2c_timings(voltdm, true);
-		return;
-	}
-
-	omap_pm_get_oscillator(&tstart, &tshut);
-	omap3_set_clksetup(tstart, voltdm);
-
-	clksetup = voltdm->read(OMAP3_PRM_CLKSETUP_OFFSET);
-
-	/* voltsetup 2 in us */
-	voltsetup2 = voltdm->vc_param->on / voltdm->pmic->slew_rate;
-
-	/* convert to 32k clk cycles */
-	voltsetup2 = DIV_ROUND_UP(voltsetup2 * 32768, 1000000);
-
-	voltsetup2_old = voltdm->read(OMAP3_PRM_VOLTSETUP2_OFFSET);
-
-	/*
-	 * Update voltsetup2 if higher than current value (needed because
-	 * we have multiple channels with different ramp times), also
-	 * update voltoffset always to value recommended by TRM
-	 */
-	if (voltsetup2 > voltsetup2_old) {
-		voltdm->write(voltsetup2, OMAP3_PRM_VOLTSETUP2_OFFSET);
-		voltdm->write(clksetup - voltsetup2,
-			OMAP3_PRM_VOLTOFFSET_OFFSET);
-	} else
-		voltdm->write(clksetup - voltsetup2_old,
-			OMAP3_PRM_VOLTOFFSET_OFFSET);
-
-	/*
-	 * omap is not controlling voltage scaling during off-mode,
-	 * thus set voltsetup1 to 0
-	 */
-	voltdm->rmw(voltdm->vfsm->voltsetup_mask, 0,
-		voltdm->vfsm->voltsetup_reg);
-
-	/* voltoffset must be clksetup minus voltsetup2 according to TRM */
-	voltdm->write(clksetup - voltsetup2, OMAP3_PRM_VOLTOFFSET_OFFSET);
 }
 
 static void __init omap3_vc_init_channel(struct voltagedomain *voltdm)
 {
 	omap3_vc_init_pmic_signaling(voltdm);
 	omap3_set_off_timings(voltdm);
+	omap3_set_i2c_timings(voltdm, true);
 }
 
 /**

commit 3b8c4ebb76302af86873158d192d76ba3b260ca8
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon May 5 17:27:35 2014 -0700

    ARM: OMAP3: Fix idle mode signaling for sys_clkreq and sys_off_mode
    
    While debugging legacy mode vs device tree booted PM regressions,
    I noticed that omap3 is not toggling sys_clkreq and sys_off_mode
    pins like it should.
    
    The sys_clkreq and sys_off_mode pins are not toggling because of
    the following issues:
    
    1. The default polarity for the sys_off_mode pin is wrong.
       OFFMODE_POL needs to be cleared for sys_off_mode to go down when
       hitting off-idle, while CLKREQ_POL needs to be set so sys_clkreq
       goes down when hitting retention.
    
    2. The values for voltctrl register need to be updated dynamically.
       We need to set either the retention idle bits, or off idle bits
       in the voltctrl register depending the idle mode we're targeting
       to hit.
    
    Let's fix these two issues as otherwise the system will just
    hang if any twl4030 PMIC idle scripts are loaded. The only case
    where the system does not hang is if only retention idle over I2C4
    is configured by the bootloader.
    
    Note that even without the twl4030 PMIC scripts, these fixes will
    do the proper signaling of sys_clkreq and sys_off_mode pins, so
    the fixes are needed to fix monitoring of PM states with LEDs or
    an oscilloscope.
    
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Nishanth Menon <nm@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 49ac7977e03e..705eb35d7b35 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -220,6 +220,87 @@ static inline u32 omap_usec_to_32k(u32 usec)
 	return DIV_ROUND_UP_ULL(32768ULL * (u64)usec, 1000000ULL);
 }
 
+struct omap3_vc {
+	struct voltagedomain *vd;
+	u32 voltctrl;
+};
+static struct omap3_vc vc;
+
+void omap3_vc_set_pmic_signaling(int core_next_state)
+{
+	struct voltagedomain *vd = vc.vd;
+	u32 voltctrl;
+
+	voltctrl = vc.voltctrl;
+	switch (core_next_state) {
+	case PWRDM_POWER_OFF:
+		voltctrl &= ~(OMAP3430_PRM_VOLTCTRL_AUTO_RET |
+			      OMAP3430_PRM_VOLTCTRL_AUTO_SLEEP);
+		voltctrl |= OMAP3430_PRM_VOLTCTRL_AUTO_OFF;
+		break;
+	case PWRDM_POWER_RET:
+	default:
+		voltctrl &= ~(OMAP3430_PRM_VOLTCTRL_AUTO_OFF |
+			      OMAP3430_PRM_VOLTCTRL_AUTO_SLEEP);
+		voltctrl |= OMAP3430_PRM_VOLTCTRL_AUTO_RET;
+		break;
+	}
+	if (voltctrl != vc.voltctrl) {
+		vd->write(voltctrl, OMAP3_PRM_VOLTCTRL_OFFSET);
+		vc.voltctrl = voltctrl;
+	}
+}
+
+#define PRM_POLCTRL_TWL_MASK	(OMAP3430_PRM_POLCTRL_CLKREQ_POL | \
+					OMAP3430_PRM_POLCTRL_CLKREQ_POL)
+#define PRM_POLCTRL_TWL_VAL	OMAP3430_PRM_POLCTRL_CLKREQ_POL
+
+/*
+ * Configure signal polarity for sys_clkreq and sys_off_mode pins
+ * as the default values are wrong and can cause the system to hang
+ * if any twl4030 scripts are loaded.
+ */
+static void __init omap3_vc_init_pmic_signaling(struct voltagedomain *voltdm)
+{
+	u32 val;
+
+	if (vc.vd)
+		return;
+
+	vc.vd = voltdm;
+
+	val = voltdm->read(OMAP3_PRM_POLCTRL_OFFSET);
+	if (!(val & OMAP3430_PRM_POLCTRL_CLKREQ_POL) ||
+	    (val & OMAP3430_PRM_POLCTRL_CLKREQ_POL)) {
+		val |= OMAP3430_PRM_POLCTRL_CLKREQ_POL;
+		val &= ~OMAP3430_PRM_POLCTRL_OFFMODE_POL;
+		pr_debug("PM: fixing sys_clkreq and sys_off_mode polarity to 0x%x\n",
+			 val);
+		voltdm->write(val, OMAP3_PRM_POLCTRL_OFFSET);
+	}
+
+	/*
+	 * By default let's use I2C4 signaling for retention idle
+	 * and sys_off_mode pin signaling for off idle. This way we
+	 * have sys_clk_req pin go down for retention and both
+	 * sys_clk_req and sys_off_mode pins will go down for off
+	 * idle. And we can also scale voltages to zero for off-idle.
+	 * Note that no actual voltage scaling during off-idle will
+	 * happen unless the board specific twl4030 PMIC scripts are
+	 * loaded.
+	 */
+	val = voltdm->read(OMAP3_PRM_VOLTCTRL_OFFSET);
+	if (!(val & OMAP3430_PRM_VOLTCTRL_SEL_OFF)) {
+		val |= OMAP3430_PRM_VOLTCTRL_SEL_OFF;
+		pr_debug("PM: setting voltctrl sys_off_mode signaling to 0x%x\n",
+			 val);
+		voltdm->write(val, OMAP3_PRM_VOLTCTRL_OFFSET);
+	}
+	vc.voltctrl = val;
+
+	omap3_vc_set_pmic_signaling(PWRDM_POWER_ON);
+}
+
 /* Set oscillator setup time for omap3 */
 static void omap3_set_clksetup(u32 usec, struct voltagedomain *voltdm)
 {
@@ -292,7 +373,7 @@ static void omap3_set_off_timings(struct voltagedomain *voltdm)
 
 	/* check if sys_off_mode is used to control off-mode voltages */
 	val = voltdm->read(OMAP3_PRM_VOLTCTRL_OFFSET);
-	if (!(val & OMAP3430_SEL_OFF_MASK)) {
+	if (!(val & OMAP3430_PRM_VOLTCTRL_SEL_OFF)) {
 		/* No, omap is controlling them over I2C */
 		omap3_set_i2c_timings(voltdm, true);
 		return;
@@ -337,6 +418,7 @@ static void omap3_set_off_timings(struct voltagedomain *voltdm)
 
 static void __init omap3_vc_init_channel(struct voltagedomain *voltdm)
 {
+	omap3_vc_init_pmic_signaling(voltdm);
 	omap3_set_off_timings(voltdm);
 }
 

commit 5c1af2a7011bf719807de360cb64c2f610269a38
Merge: ef7848683f4d 573e5bbe653d
Author: Olof Johansson <olof@lixom.net>
Date:   Fri Nov 30 09:12:33 2012 -0800

    Merge branch 'next/pm-samsung' of git://git.kernel.org/pub/scm/linux/kernel/git/kgene/linux-samsung into next/pm
    
    From Kukjin Kim:
    
    * 'next/pm-samsung' of git://git.kernel.org/pub/scm/linux/kernel/git/kgene/linux-samsung:
      ARM: EXYNOS: Add flush_cache_all in suspend finisher
      ARM: EXYNOS: Remove scu_enable from cpuidle
      ARM: EXYNOS: Fix soft reboot hang after suspend/resume
      ARM: EXYNOS: Add support for rtc wakeup
      ARM: EXYNOS: fix the hotplug for Cortex-A15
      + Linux 3.7-rc6

commit 74d29168e9af59c9db1885e27493fbed4d24ef18
Author: Kevin Hilman <khilman@ti.com>
Date:   Wed Nov 14 17:13:04 2012 -0800

    ARM: OMAP2+: voltage: fixup oscillator handling when CONFIG_PM=n
    
    commit 908b75e8 (ARM: OMAP: add support for oscillator setup) added a new
    API for oscillator setup, but is broken when CONFIG_PM=n.
    
    The new functions have dummy definitions when CONFIG_PM=n, but also have
    full implementations available, which conflict.
    
    To fix, wrap the PM implmentations in #ifdef CONFIG_PM.
    
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 687aa86c0d5e..a89ec8affed4 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -666,6 +666,7 @@ static u8 omap_vc_calc_vsel(struct voltagedomain *voltdm, u32 uvolt)
 	return voltdm->pmic->uv_to_vsel(uvolt);
 }
 
+#ifdef CONFIG_PM
 /**
  * omap_pm_setup_sr_i2c_pcb_length - set length of SR I2C traces on PCB
  * @mm: length of the PCB trace in millimetres
@@ -678,6 +679,7 @@ void __init omap_pm_setup_sr_i2c_pcb_length(u32 mm)
 {
 	sr_i2c_pcb_length = mm;
 }
+#endif
 
 void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 {

commit 00bd228ea9f7aad23f7933fa62a13d975d4b213a
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Sep 25 19:33:48 2012 +0300

    ARM: OMAP4: VC: setup I2C parameters based on board data
    
    VC code now provides a table of pre-calculated I2C setup parameters,
    which will be used based on the capacitance value calculated for the I2C
    trace on the PCB. A default trace length of 6.3cm is used unless board
    defines its own value during init. The parameters set will be the I2C
    internal pull setup and the I2C timing parameters for high speed use
    mode. Full speed mode is not supported as of now.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index d72b787a0d83..687aa86c0d5e 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -24,6 +24,7 @@
 #include "prm44xx.h"
 #include "pm.h"
 #include "scrm44xx.h"
+#include "control.h"
 
 /**
  * struct omap_vc_channel_cfg - describe the cfg_channel bitfield
@@ -69,6 +70,9 @@ static struct omap_vc_channel_cfg vc_mutant_channel_cfg = {
 };
 
 static struct omap_vc_channel_cfg *vc_cfg_bits;
+
+/* Default I2C trace length on pcb, 6.3cm. Used for capacitance calculations. */
+static u32 sr_i2c_pcb_length = 63;
 #define CFG_CHANNEL_MASK 0x1f
 
 /**
@@ -464,22 +468,135 @@ static void omap4_set_timings(struct voltagedomain *voltdm, bool off_mode)
 /* OMAP4 specific voltage init functions */
 static void __init omap4_vc_init_channel(struct voltagedomain *voltdm)
 {
-	static bool is_initialized;
-	u32 vc_val;
-
 	omap4_set_timings(voltdm, true);
 	omap4_set_timings(voltdm, false);
+}
+
+struct i2c_init_data {
+	u8 loadbits;
+	u8 load;
+	u8 hsscll_38_4;
+	u8 hsscll_26;
+	u8 hsscll_19_2;
+	u8 hsscll_16_8;
+	u8 hsscll_12;
+};
+
+static const __initdata struct i2c_init_data omap4_i2c_timing_data[] = {
+	{
+		.load = 50,
+		.loadbits = 0x3,
+		.hsscll_38_4 = 13,
+		.hsscll_26 = 11,
+		.hsscll_19_2 = 9,
+		.hsscll_16_8 = 9,
+		.hsscll_12 = 8,
+	},
+	{
+		.load = 25,
+		.loadbits = 0x2,
+		.hsscll_38_4 = 13,
+		.hsscll_26 = 11,
+		.hsscll_19_2 = 9,
+		.hsscll_16_8 = 9,
+		.hsscll_12 = 8,
+	},
+	{
+		.load = 12,
+		.loadbits = 0x1,
+		.hsscll_38_4 = 11,
+		.hsscll_26 = 10,
+		.hsscll_19_2 = 9,
+		.hsscll_16_8 = 9,
+		.hsscll_12 = 8,
+	},
+	{
+		.load = 0,
+		.loadbits = 0x0,
+		.hsscll_38_4 = 12,
+		.hsscll_26 = 10,
+		.hsscll_19_2 = 9,
+		.hsscll_16_8 = 8,
+		.hsscll_12 = 8,
+	},
+};
+
+/**
+ * omap4_vc_i2c_timing_init - sets up board I2C timing parameters
+ * @voltdm: voltagedomain pointer to get data from
+ *
+ * Use PMIC + board supplied settings for calculating the total I2C
+ * channel capacitance and set the timing parameters based on this.
+ * Pre-calculated values are provided in data tables, as it is not
+ * too straightforward to calculate these runtime.
+ */
+static void __init omap4_vc_i2c_timing_init(struct voltagedomain *voltdm)
+{
+	u32 capacitance;
+	u32 val;
+	u16 hsscll;
+	const struct i2c_init_data *i2c_data;
+
+	if (!voltdm->pmic->i2c_high_speed) {
+		pr_warn("%s: only high speed supported!\n", __func__);
+		return;
+	}
 
-	if (is_initialized)
+	/* PCB trace capacitance, 0.125pF / mm => mm / 8 */
+	capacitance = DIV_ROUND_UP(sr_i2c_pcb_length, 8);
+
+	/* OMAP pad capacitance */
+	capacitance += 4;
+
+	/* PMIC pad capacitance */
+	capacitance += voltdm->pmic->i2c_pad_load;
+
+	/* Search for capacitance match in the table */
+	i2c_data = omap4_i2c_timing_data;
+
+	while (i2c_data->load > capacitance)
+		i2c_data++;
+
+	/* Select proper values based on sysclk frequency */
+	switch (voltdm->sys_clk.rate) {
+	case 38400000:
+		hsscll = i2c_data->hsscll_38_4;
+		break;
+	case 26000000:
+		hsscll = i2c_data->hsscll_26;
+		break;
+	case 19200000:
+		hsscll = i2c_data->hsscll_19_2;
+		break;
+	case 16800000:
+		hsscll = i2c_data->hsscll_16_8;
+		break;
+	case 12000000:
+		hsscll = i2c_data->hsscll_12;
+		break;
+	default:
+		pr_warn("%s: unsupported sysclk rate: %d!\n", __func__,
+			voltdm->sys_clk.rate);
 		return;
+	}
+
+	/* Loadbits define pull setup for the I2C channels */
+	val = i2c_data->loadbits << 25 | i2c_data->loadbits << 29;
 
-	/* XXX These are magic numbers and do not belong! */
-	vc_val = (0x60 << OMAP4430_SCLL_SHIFT | 0x26 << OMAP4430_SCLH_SHIFT);
-	voltdm->write(vc_val, OMAP4_PRM_VC_CFG_I2C_CLK_OFFSET);
+	/* Write to SYSCTRL_PADCONF_WKUP_CTRL_I2C_2 to setup I2C pull */
+	__raw_writel(val, OMAP2_L4_IO_ADDRESS(OMAP4_CTRL_MODULE_PAD_WKUP +
+				OMAP4_CTRL_MODULE_PAD_WKUP_CONTROL_I2C_2));
 
-	is_initialized = true;
+	/* HSSCLH can always be zero */
+	val = hsscll << OMAP4430_HSSCLL_SHIFT;
+	val |= (0x28 << OMAP4430_SCLL_SHIFT | 0x2c << OMAP4430_SCLH_SHIFT);
+
+	/* Write setup times to I2C config register */
+	voltdm->write(val, OMAP4_PRM_VC_CFG_I2C_CLK_OFFSET);
 }
 
+
+
 /**
  * omap_vc_i2c_init - initialize I2C interface to PMIC
  * @voltdm: voltage domain containing VC data
@@ -519,6 +636,9 @@ static void __init omap_vc_i2c_init(struct voltagedomain *voltdm)
 			    mcode << __ffs(vc->common->i2c_mcode_mask),
 			    vc->common->i2c_cfg_reg);
 
+	if (cpu_is_omap44xx())
+		omap4_vc_i2c_timing_init(voltdm);
+
 	initialized = true;
 }
 
@@ -546,6 +666,19 @@ static u8 omap_vc_calc_vsel(struct voltagedomain *voltdm, u32 uvolt)
 	return voltdm->pmic->uv_to_vsel(uvolt);
 }
 
+/**
+ * omap_pm_setup_sr_i2c_pcb_length - set length of SR I2C traces on PCB
+ * @mm: length of the PCB trace in millimetres
+ *
+ * Sets the PCB trace length for the I2C channel. By default uses 63mm.
+ * This is needed for properly calculating the capacitance value for
+ * the PCB trace, and for setting the SR I2C channel timing parameters.
+ */
+void __init omap_pm_setup_sr_i2c_pcb_length(u32 mm)
+{
+	sr_i2c_pcb_length = mm;
+}
+
 void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 {
 	struct omap_vc_channel *vc = voltdm->vc;

commit 2ceec7b25c3cde53c68e49d64950f2ad1cab307d
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Sep 25 19:33:47 2012 +0300

    ARM: OMAP4: vc: fix channel configuration
    
    RACEN bit should only be set if the voltage and command register addresses
    are the same.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 5d5f9e52f89f..d72b787a0d83 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -592,9 +592,12 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 		voltdm->rmw(vc->smps_cmdra_mask,
 			    vc->cmd_reg_addr << __ffs(vc->smps_cmdra_mask),
 			    vc->smps_cmdra_reg);
-		vc->cfg_channel |= vc_cfg_bits->rac | vc_cfg_bits->racen;
+		vc->cfg_channel |= vc_cfg_bits->rac;
 	}
 
+	if (vc->cmd_reg_addr == vc->volt_reg_addr)
+		vc->cfg_channel |= vc_cfg_bits->racen;
+
 	/* Set up the on, inactive, retention and off voltage */
 	on_vsel = omap_vc_calc_vsel(voltdm, voltdm->vc_param->on);
 	onlp_vsel = omap_vc_calc_vsel(voltdm, voltdm->vc_param->onlp);

commit d68ff977b82954fed8e3f4bde8431517455c2003
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Sep 25 19:33:41 2012 +0300

    ARM: OMAP3+: voltage: use oscillator data to calculate setup times
    
    We now use the previously defined oscillator setup / shutdown times
    to calculate the register values for CLKSETUP.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 07e2090d7119..5d5f9e52f89f 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -11,13 +11,19 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/bug.h>
+#include <linux/io.h>
 
+#include <asm/div64.h>
+
+#include "iomap.h"
 #include "soc.h"
 #include "voltage.h"
 #include "vc.h"
 #include "prm-regbits-34xx.h"
 #include "prm-regbits-44xx.h"
 #include "prm44xx.h"
+#include "pm.h"
+#include "scrm44xx.h"
 
 /**
  * struct omap_vc_channel_cfg - describe the cfg_channel bitfield
@@ -204,6 +210,18 @@ int omap_vc_bypass_scale(struct voltagedomain *voltdm,
 	return 0;
 }
 
+/* Convert microsecond value to number of 32kHz clock cycles */
+static inline u32 omap_usec_to_32k(u32 usec)
+{
+	return DIV_ROUND_UP_ULL(32768ULL * (u64)usec, 1000000ULL);
+}
+
+/* Set oscillator setup time for omap3 */
+static void omap3_set_clksetup(u32 usec, struct voltagedomain *voltdm)
+{
+	voltdm->write(omap_usec_to_32k(usec), OMAP3_PRM_CLKSETUP_OFFSET);
+}
+
 /**
  * omap3_set_i2c_timings - sets i2c sleep timings for a channel
  * @voltdm: channel to configure
@@ -220,6 +238,12 @@ static void omap3_set_i2c_timings(struct voltagedomain *voltdm, bool off_mode)
 	unsigned long voltsetup1;
 	u32 tgt_volt;
 
+	/*
+	 * Oscillator is shut down only if we are using sys_off_mode pad,
+	 * thus we set a minimal setup time here
+	 */
+	omap3_set_clksetup(1, voltdm);
+
 	if (off_mode)
 		tgt_volt = voltdm->vc_param->off;
 	else
@@ -260,6 +284,7 @@ static void omap3_set_off_timings(struct voltagedomain *voltdm)
 	unsigned long voltsetup2;
 	unsigned long voltsetup2_old;
 	u32 val;
+	u32 tstart, tshut;
 
 	/* check if sys_off_mode is used to control off-mode voltages */
 	val = voltdm->read(OMAP3_PRM_VOLTCTRL_OFFSET);
@@ -269,6 +294,9 @@ static void omap3_set_off_timings(struct voltagedomain *voltdm)
 		return;
 	}
 
+	omap_pm_get_oscillator(&tstart, &tshut);
+	omap3_set_clksetup(tstart, voltdm);
+
 	clksetup = voltdm->read(OMAP3_PRM_CLKSETUP_OFFSET);
 
 	/* voltsetup 2 in us */
@@ -364,6 +392,30 @@ static u32 omap4_calc_volt_ramp(struct voltagedomain *voltdm, u32 voltage_diff)
 		(cycles << OMAP4430_RAMP_UP_COUNT_SHIFT);
 }
 
+/**
+ * omap4_usec_to_val_scrm - convert microsecond value to SCRM module bitfield
+ * @usec: microseconds
+ * @shift: number of bits to shift left
+ * @mask: bitfield mask
+ *
+ * Converts microsecond value to OMAP4 SCRM bitfield. Bitfield is
+ * shifted to requested position, and checked agains the mask value.
+ * If larger, forced to the max value of the field (i.e. the mask itself.)
+ * Returns the SCRM bitfield value.
+ */
+static u32 omap4_usec_to_val_scrm(u32 usec, int shift, u32 mask)
+{
+	u32 val;
+
+	val = omap_usec_to_32k(usec) << shift;
+
+	/* Check for overflow, if yes, force to max value */
+	if (val > mask)
+		val = mask;
+
+	return val;
+}
+
 /**
  * omap4_set_timings - set voltage ramp timings for a channel
  * @voltdm: channel to configure
@@ -376,6 +428,7 @@ static void omap4_set_timings(struct voltagedomain *voltdm, bool off_mode)
 	u32 val;
 	u32 ramp;
 	int offset;
+	u32 tstart, tshut;
 
 	if (off_mode) {
 		ramp = omap4_calc_volt_ramp(voltdm,
@@ -397,6 +450,15 @@ static void omap4_set_timings(struct voltagedomain *voltdm, bool off_mode)
 	val |= ramp << OMAP4430_RAMP_UP_COUNT_SHIFT;
 
 	voltdm->write(val, offset);
+
+	omap_pm_get_oscillator(&tstart, &tshut);
+
+	val = omap4_usec_to_val_scrm(tstart, OMAP4_SETUPTIME_SHIFT,
+		OMAP4_SETUPTIME_MASK);
+	val |= omap4_usec_to_val_scrm(tshut, OMAP4_DOWNTIME_SHIFT,
+		OMAP4_DOWNTIME_MASK);
+
+	__raw_writel(val, OMAP4_SCRM_CLKSETUPTIME);
 }
 
 /* OMAP4 specific voltage init functions */

commit 9a1729cbaaf1a9d1fd27f80cd488ef182fe033a0
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Sep 25 19:33:38 2012 +0300

    ARM: OMAP4: VC: calculate ramp times
    
    OMAP4 VC code now uses voltage deltas + slew rates for calculating
    actual ramp times for voltage changes. Both retention / sleep +
    off mode voltage ramp times are setup at the same time during
    initialization.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 73b4bcd67023..07e2090d7119 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -308,12 +308,106 @@ static void __init omap3_vc_init_channel(struct voltagedomain *voltdm)
 	omap3_set_off_timings(voltdm);
 }
 
+/**
+ * omap4_calc_volt_ramp - calculates voltage ramping delays on omap4
+ * @voltdm: channel to calculate values for
+ * @voltage_diff: voltage difference in microvolts
+ *
+ * Calculates voltage ramp prescaler + counter values for a voltage
+ * difference on omap4. Returns a field value suitable for writing to
+ * VOLTSETUP register for a channel in following format:
+ * bits[8:9] prescaler ... bits[0:5] counter. See OMAP4 TRM for reference.
+ */
+static u32 omap4_calc_volt_ramp(struct voltagedomain *voltdm, u32 voltage_diff)
+{
+	u32 prescaler;
+	u32 cycles;
+	u32 time;
+
+	time = voltage_diff / voltdm->pmic->slew_rate;
+
+	cycles = voltdm->sys_clk.rate / 1000 * time / 1000;
+
+	cycles /= 64;
+	prescaler = 0;
+
+	/* shift to next prescaler until no overflow */
+
+	/* scale for div 256 = 64 * 4 */
+	if (cycles > 63) {
+		cycles /= 4;
+		prescaler++;
+	}
+
+	/* scale for div 512 = 256 * 2 */
+	if (cycles > 63) {
+		cycles /= 2;
+		prescaler++;
+	}
+
+	/* scale for div 2048 = 512 * 4 */
+	if (cycles > 63) {
+		cycles /= 4;
+		prescaler++;
+	}
+
+	/* check for overflow => invalid ramp time */
+	if (cycles > 63) {
+		pr_warn("%s: invalid setuptime for vdd_%s\n", __func__,
+			voltdm->name);
+		return 0;
+	}
+
+	cycles++;
+
+	return (prescaler << OMAP4430_RAMP_UP_PRESCAL_SHIFT) |
+		(cycles << OMAP4430_RAMP_UP_COUNT_SHIFT);
+}
+
+/**
+ * omap4_set_timings - set voltage ramp timings for a channel
+ * @voltdm: channel to configure
+ * @off_mode: whether off-mode values are used
+ *
+ * Calculates and sets the voltage ramp up / down values for a channel.
+ */
+static void omap4_set_timings(struct voltagedomain *voltdm, bool off_mode)
+{
+	u32 val;
+	u32 ramp;
+	int offset;
+
+	if (off_mode) {
+		ramp = omap4_calc_volt_ramp(voltdm,
+			voltdm->vc_param->on - voltdm->vc_param->off);
+		offset = voltdm->vfsm->voltsetup_off_reg;
+	} else {
+		ramp = omap4_calc_volt_ramp(voltdm,
+			voltdm->vc_param->on - voltdm->vc_param->ret);
+		offset = voltdm->vfsm->voltsetup_reg;
+	}
+
+	if (!ramp)
+		return;
+
+	val = voltdm->read(offset);
+
+	val |= ramp << OMAP4430_RAMP_DOWN_COUNT_SHIFT;
+
+	val |= ramp << OMAP4430_RAMP_UP_COUNT_SHIFT;
+
+	voltdm->write(val, offset);
+}
+
 /* OMAP4 specific voltage init functions */
 static void __init omap4_vc_init_channel(struct voltagedomain *voltdm)
 {
 	static bool is_initialized;
 	u32 vc_val;
 
+	omap4_set_timings(voltdm, true);
+	omap4_set_timings(voltdm, false);
+
 	if (is_initialized)
 		return;
 

commit c589eb3869a8ad6185669f5477bf72d6d46068de
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Sep 25 19:33:36 2012 +0300

    ARM: OMAP3: VC: calculate ramp times
    
    OMAP3 VC code now uses voltage deltas + slew rates for calculating actual
    ramp times for voltage changes. Previously a static value was used.
    Two calculation methods are provided: i2c_timings and off_timings.
    I2C timings are used during retention or off mode transition which
    is initiated over I2C, and OFF timings are used if PMIC signal
    (nsleep) is used to control all the off mode voltages at the same time.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 4c3c41fd2637..73b4bcd67023 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -204,29 +204,109 @@ int omap_vc_bypass_scale(struct voltagedomain *voltdm,
 	return 0;
 }
 
-static void __init omap3_vfsm_init(struct voltagedomain *voltdm)
+/**
+ * omap3_set_i2c_timings - sets i2c sleep timings for a channel
+ * @voltdm: channel to configure
+ * @off_mode: select whether retention or off mode values used
+ *
+ * Calculates and sets up voltage controller to use I2C based
+ * voltage scaling for sleep modes. This can be used for either off mode
+ * or retention. Off mode has additionally an option to use sys_off_mode
+ * pad, which uses a global signal to program the whole power IC to
+ * off-mode.
+ */
+static void omap3_set_i2c_timings(struct voltagedomain *voltdm, bool off_mode)
 {
+	unsigned long voltsetup1;
+	u32 tgt_volt;
+
+	if (off_mode)
+		tgt_volt = voltdm->vc_param->off;
+	else
+		tgt_volt = voltdm->vc_param->ret;
+
+	voltsetup1 = (voltdm->vc_param->on - tgt_volt) /
+			voltdm->pmic->slew_rate;
+
+	voltsetup1 = voltsetup1 * voltdm->sys_clk.rate / 8 / 1000000 + 1;
+
+	voltdm->rmw(voltdm->vfsm->voltsetup_mask,
+		voltsetup1 << __ffs(voltdm->vfsm->voltsetup_mask),
+		voltdm->vfsm->voltsetup_reg);
+
 	/*
-	 * Voltage Manager FSM parameters init
-	 * XXX This data should be passed in from the board file
+	 * pmic is not controlling the voltage scaling during retention,
+	 * thus set voltsetup2 to 0
 	 */
-	voltdm->write(OMAP3_CLKSETUP, OMAP3_PRM_CLKSETUP_OFFSET);
-	voltdm->write(OMAP3_VOLTOFFSET, OMAP3_PRM_VOLTOFFSET_OFFSET);
-	voltdm->write(OMAP3_VOLTSETUP2, OMAP3_PRM_VOLTSETUP2_OFFSET);
+	voltdm->write(0, OMAP3_PRM_VOLTSETUP2_OFFSET);
 }
 
-static void __init omap3_vc_init_channel(struct voltagedomain *voltdm)
+/**
+ * omap3_set_off_timings - sets off-mode timings for a channel
+ * @voltdm: channel to configure
+ *
+ * Calculates and sets up off-mode timings for a channel. Off-mode
+ * can use either I2C based voltage scaling, or alternatively
+ * sys_off_mode pad can be used to send a global command to power IC.
+ * This function first checks which mode is being used, and calls
+ * omap3_set_i2c_timings() if the system is using I2C control mode.
+ * sys_off_mode has the additional benefit that voltages can be
+ * scaled to zero volt level with TWL4030 / TWL5030, I2C can only
+ * scale to 600mV.
+ */
+static void omap3_set_off_timings(struct voltagedomain *voltdm)
 {
-	static bool is_initialized;
+	unsigned long clksetup;
+	unsigned long voltsetup2;
+	unsigned long voltsetup2_old;
+	u32 val;
 
-	if (is_initialized)
+	/* check if sys_off_mode is used to control off-mode voltages */
+	val = voltdm->read(OMAP3_PRM_VOLTCTRL_OFFSET);
+	if (!(val & OMAP3430_SEL_OFF_MASK)) {
+		/* No, omap is controlling them over I2C */
+		omap3_set_i2c_timings(voltdm, true);
 		return;
+	}
 
-	omap3_vfsm_init(voltdm);
+	clksetup = voltdm->read(OMAP3_PRM_CLKSETUP_OFFSET);
 
-	is_initialized = true;
+	/* voltsetup 2 in us */
+	voltsetup2 = voltdm->vc_param->on / voltdm->pmic->slew_rate;
+
+	/* convert to 32k clk cycles */
+	voltsetup2 = DIV_ROUND_UP(voltsetup2 * 32768, 1000000);
+
+	voltsetup2_old = voltdm->read(OMAP3_PRM_VOLTSETUP2_OFFSET);
+
+	/*
+	 * Update voltsetup2 if higher than current value (needed because
+	 * we have multiple channels with different ramp times), also
+	 * update voltoffset always to value recommended by TRM
+	 */
+	if (voltsetup2 > voltsetup2_old) {
+		voltdm->write(voltsetup2, OMAP3_PRM_VOLTSETUP2_OFFSET);
+		voltdm->write(clksetup - voltsetup2,
+			OMAP3_PRM_VOLTOFFSET_OFFSET);
+	} else
+		voltdm->write(clksetup - voltsetup2_old,
+			OMAP3_PRM_VOLTOFFSET_OFFSET);
+
+	/*
+	 * omap is not controlling voltage scaling during off-mode,
+	 * thus set voltsetup1 to 0
+	 */
+	voltdm->rmw(voltdm->vfsm->voltsetup_mask, 0,
+		voltdm->vfsm->voltsetup_reg);
+
+	/* voltoffset must be clksetup minus voltsetup2 according to TRM */
+	voltdm->write(clksetup - voltsetup2, OMAP3_PRM_VOLTOFFSET_OFFSET);
 }
 
+static void __init omap3_vc_init_channel(struct voltagedomain *voltdm)
+{
+	omap3_set_off_timings(voltdm);
+}
 
 /* OMAP4 specific voltage init functions */
 static void __init omap4_vc_init_channel(struct voltagedomain *voltdm)
@@ -337,7 +417,6 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 	vc->i2c_slave_addr = voltdm->pmic->i2c_slave_addr;
 	vc->volt_reg_addr = voltdm->pmic->volt_reg_addr;
 	vc->cmd_reg_addr = voltdm->pmic->cmd_reg_addr;
-	vc->setup_time = voltdm->pmic->volt_setup_time;
 
 	/* Configure the i2c slave address for this VC */
 	voltdm->rmw(vc->smps_sa_mask,
@@ -376,11 +455,6 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 	/* Channel configuration */
 	omap_vc_config_channel(voltdm);
 
-	/* Configure the setup times */
-	voltdm->rmw(voltdm->vfsm->voltsetup_mask,
-		    vc->setup_time << __ffs(voltdm->vfsm->voltsetup_mask),
-		    voltdm->vfsm->voltsetup_reg);
-
 	omap_vc_i2c_init(voltdm);
 
 	if (cpu_is_omap34xx())

commit 8b5d8c0d718379ce29dad74b4bda8b669fc1f1c2
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Sep 25 19:33:35 2012 +0300

    ARM: OMAP3+: voltage: introduce omap vc / vp params for voltagedomains
    
    These new structs will hold the sleep voltage levels (omap_vc_params)
    and voltage processor min / max voltages (omap_vp_params.) Previously
    these were part of the PMIC struct, but they do not really belong there,
    as they are OMAP chip specific, not PMIC specific parameters. voltdm
    code is also changed to use the new structs.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 880249b17012..4c3c41fd2637 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -135,6 +135,8 @@ int omap_vc_pre_scale(struct voltagedomain *voltdm,
 	vc_cmdval |= (*target_vsel << vc->common->cmd_on_shift);
 	voltdm->write(vc_cmdval, vc->cmdval_reg);
 
+	voltdm->vc_param->on = target_volt;
+
 	omap_vp_update_errorgain(voltdm, target_volt);
 
 	return 0;
@@ -284,6 +286,30 @@ static void __init omap_vc_i2c_init(struct voltagedomain *voltdm)
 	initialized = true;
 }
 
+/**
+ * omap_vc_calc_vsel - calculate vsel value for a channel
+ * @voltdm: channel to calculate value for
+ * @uvolt: microvolt value to convert to vsel
+ *
+ * Converts a microvolt value to vsel value for the used PMIC.
+ * This checks whether the microvolt value is out of bounds, and
+ * adjusts the value accordingly. If unsupported value detected,
+ * warning is thrown.
+ */
+static u8 omap_vc_calc_vsel(struct voltagedomain *voltdm, u32 uvolt)
+{
+	if (voltdm->pmic->vddmin > uvolt)
+		uvolt = voltdm->pmic->vddmin;
+	if (voltdm->pmic->vddmax < uvolt) {
+		WARN(1, "%s: voltage not supported by pmic: %u vs max %u\n",
+			__func__, uvolt, voltdm->pmic->vddmax);
+		/* Lets try maximum value anyway */
+		uvolt = voltdm->pmic->vddmax;
+	}
+
+	return voltdm->pmic->uv_to_vsel(uvolt);
+}
+
 void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 {
 	struct omap_vc_channel *vc = voltdm->vc;
@@ -335,10 +361,11 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 	}
 
 	/* Set up the on, inactive, retention and off voltage */
-	on_vsel = voltdm->pmic->uv_to_vsel(voltdm->pmic->on_volt);
-	onlp_vsel = voltdm->pmic->uv_to_vsel(voltdm->pmic->onlp_volt);
-	ret_vsel = voltdm->pmic->uv_to_vsel(voltdm->pmic->ret_volt);
-	off_vsel = voltdm->pmic->uv_to_vsel(voltdm->pmic->off_volt);
+	on_vsel = omap_vc_calc_vsel(voltdm, voltdm->vc_param->on);
+	onlp_vsel = omap_vc_calc_vsel(voltdm, voltdm->vc_param->onlp);
+	ret_vsel = omap_vc_calc_vsel(voltdm, voltdm->vc_param->ret);
+	off_vsel = omap_vc_calc_vsel(voltdm, voltdm->vc_param->off);
+
 	val = ((on_vsel << vc->common->cmd_on_shift) |
 	       (onlp_vsel << vc->common->cmd_onlp_shift) |
 	       (ret_vsel << vc->common->cmd_ret_shift) |

commit 43993e4af02ec99908d6d99176773fc2a3ee4c57
Author: Kevin Hilman <khilman@ti.com>
Date:   Thu Oct 25 10:30:34 2012 -0700

    ARM: OMAP2+: PM: add missing newline to VC warning message
    
    Add missing newline to warning message to avoid annoying
    wrapping problems during kernel boot like this one:
    
       omap_vc_i2c_init: I2C config for vdd_iva does not match other channels (0).
       omap_vc_i2c_init: I2C config for vdd_mpu does not match other channels (0).Power Management for TI OMAP4.
    
    Reported-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 880249b17012..75878c37959b 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -264,7 +264,7 @@ static void __init omap_vc_i2c_init(struct voltagedomain *voltdm)
 
 	if (initialized) {
 		if (voltdm->pmic->i2c_high_speed != i2c_high_speed)
-			pr_warn("%s: I2C config for vdd_%s does not match other channels (%u).",
+			pr_warn("%s: I2C config for vdd_%s does not match other channels (%u).\n",
 				__func__, voltdm->name, i2c_high_speed);
 		return;
 	}

commit 3c101c41fbe5daf88afbbd575542aa1d047812bb
Merge: f191f40c1819 7852ec0536ca
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Sep 12 20:42:36 2012 -0700

    Merge tag 'omap-cleanup-b-for-3.7' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into cleanup-makefile-sparse
    
    smatch and string-wrapping cleanups for the OMAP subarch code.
    
    These changes fix some of the more meaningful warnings that smatch
    returns for the OMAP subarch code, and unwraps strings that are
    wrapped at the 80-column boundary, to conform with the current
    practice.
    
    Basic build, boot, and PM logs are available here:
    
    http://www.pwsan.com/omap/testlogs/warnings_a_cleanup_3.7/20120912025927/

commit dbc04161048dd5e5c3c58546688a0cc0854051e9
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Aug 31 10:59:07 2012 -0700

    ARM: OMAP: Split plat/hardware.h, use local soc.h for omap2+
    
    As the plat and mach includes need to disappear for single zImage work,
    we need to remove plat/hardware.h.
    
    Do this by splitting plat/hardware.h into omap1 and omap2+ specific files.
    
    The old plat/hardware.h already has omap1 only defines, so it gets moved
    to mach/hardware.h for omap1. For omap2+, we use the local soc.h
    that for now just includes the related SoC headers to keep this patch more
    readable.
    
    Note that the local soc.h still includes plat/cpu.h that can be dealt
    with in later patches. Let's also include plat/serial.h from common.h for
    all the board-*.c files. This allows making the include files local later
    on without patching these files again.
    
    Note that only minimal changes are done in this patch for the
    drivers/watchdog/omap_wdt.c driver to keep things compiling. Further
    patches are needed to eventually remove cpu_is_omap usage in the drivers.
    
    Also only minimal changes are done to sound/soc/omap/* to remove the
    unneeded includes and to define OMAP44XX_MCPDM_L3_BASE locally so there's
    no need to include omap44xx.h.
    
    While at it, also sort some of the includes in the standard way.
    
    Cc: linux-watchdog@vger.kernel.org
    Cc: alsa-devel@alsa-project.org
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Jarkko Nikula <jarkko.nikula@bitmer.com>
    Cc: Liam Girdwood <lrg@ti.com>
    Acked-by: Wim Van Sebroeck <wim@iguana.be>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 84da34f9a7cf..b451f3c13292 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -12,8 +12,7 @@
 #include <linux/init.h>
 #include <linux/bug.h>
 
-#include <plat/cpu.h>
-
+#include "soc.h"
 #include "voltage.h"
 #include "vc.h"
 #include "prm-regbits-34xx.h"

commit 7852ec0536ca39cefffc6301dc77f8ae55592926
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Jul 26 00:54:26 2012 -0600

    ARM: OMAP: unwrap strings
    
    Find and unwrap wrapped strings in the style:
    
            pr_debug("clockdomain: hardware cannot set/clear wake up of "
                     "%s when %s wakes up\n", clkdm1->name, clkdm2->name);
    
    Keeping these strings contiguous seems to be the current Linux kernel
    policy.
    
    The offending lines were found with the following command:
    
        pcregrep -rnM '"\s*$\s*"' arch/arm/*omap*
    
    While here, some messages have been clarified, some pr_warning(
    ... calls have been converted to pr_warn( ..., and some printk(KERN_*
    ... have been converted to pr_*.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 84da34f9a7cf..4577764044b9 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -116,9 +116,8 @@ int omap_vc_pre_scale(struct voltagedomain *voltdm,
 	}
 
 	if (!voltdm->pmic->uv_to_vsel) {
-		pr_err("%s: PMIC function to convert voltage in uV to"
-			"vsel not registered. Hence unable to scale voltage"
-			"for vdd_%s\n", __func__, voltdm->name);
+		pr_err("%s: PMIC function to convert voltage in uV to vsel not registered. Hence unable to scale voltage for vdd_%s\n",
+		       __func__, voltdm->name);
 		return -ENODATA;
 	}
 

commit 4647ca5761f5534470e98d06494403a2fd0d7b32
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Mar 8 10:20:14 2012 -0800

    ARM: OMAP2+: Fix build for omap4 only builds with missing include of linux/bug.h
    
    Found few more with randconfig generated .configs:
    
    In file included from arch/arm/mach-omap2/prm-regbits-34xx.h:17,
                     from arch/arm/mach-omap2/vc.c:18:
    arch/arm/mach-omap2/prm2xxx_3xxx.h: In function ‘omap2_prm_read_mod_reg’:
    arch/arm/mach-omap2/prm2xxx_3xxx.h:239: error: implicit declaration of function ‘WARN’
    
    In file included from arch/arm/mach-omap2/powerdomain44xx.c:22:
    arch/arm/mach-omap2/prm2xxx_3xxx.h: In function ‘omap2_prm_read_mod_reg’:
    arch/arm/mach-omap2/prm2xxx_3xxx.h:239: error: implicit declaration of function ‘WARN’
    
    This is because omap2_prm functions are currently just stubs for
    omap4 only builds.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 175b7d86d86a..84da34f9a7cf 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -10,6 +10,7 @@
 #include <linux/kernel.h>
 #include <linux/delay.h>
 #include <linux/init.h>
+#include <linux/bug.h>
 
 #include <plat/cpu.h>
 

commit 0bf68f53f164e169c2bc77f707338fc595b6ccfc
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Feb 7 10:23:43 2012 +0000

    ARM: omap: fix uninformative vc/i2c configuration error message
    
    On my OMAP4 platform, I'm getting this error message repeated several
    times at boot:
    
    omap_vc_i2c_init: I2C config for all channels must match.
    omap_vc_i2c_init: I2C config for all channels must match.
    
    This doesn't help identify what the problem is.  Fix this message to
    be more informative:
    
    omap_vc_i2c_init: I2C config for vdd_iva does not match other channels (0).
    omap_vc_i2c_init: I2C config for vdd_mpu does not match other channels (0).
    
    This allows us to identify which voltage domains have a problem, and
    what the I2C configuration state (a boolean, i2c_high_speed) setting
    being used actually is.
    
    From this we find that omap4_core_pmic has i2c_high_speed false, but
    omap4_iva_pmic and omap4_mpu_pmic both have it set true.
    
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index a7da3da963e3..175b7d86d86a 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -265,8 +265,8 @@ static void __init omap_vc_i2c_init(struct voltagedomain *voltdm)
 
 	if (initialized) {
 		if (voltdm->pmic->i2c_high_speed != i2c_high_speed)
-			pr_warn("%s: I2C config for all channels must match.",
-				__func__);
+			pr_warn("%s: I2C config for vdd_%s does not match other channels (%u).",
+				__func__, voltdm->name, i2c_high_speed);
 		return;
 	}
 

commit 2d5b4790b1e7cffb8987e535d4969d10b62f3163
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Feb 7 10:13:02 2012 +0000

    ARM: omap: fix vc.c PMIC error message
    
    While testing on my OMAP3430 platform, this error message was emitted:
    
    omap_vc_init_channel: PMIC info requried to configure vc forvdd_core not populated.Hence cannot initialize vc
    
    Trying to find this message was difficult because it was wrapped across
    several lines.  It also mis-spells "required", doesn't read very well,
    and has spaces lacking.  Let's replace it with a more concise:
    
    omap_vc_init_channel: No PMIC info for vdd_core
    
    While we're here, fix a simple spelling error in a comment.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 031d116fbf10..a7da3da963e3 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -247,7 +247,7 @@ static void __init omap4_vc_init_channel(struct voltagedomain *voltdm)
  * omap_vc_i2c_init - initialize I2C interface to PMIC
  * @voltdm: voltage domain containing VC data
  *
- * Use PMIC supplied seetings for I2C high-speed mode and
+ * Use PMIC supplied settings for I2C high-speed mode and
  * master code (if set) and program the VC I2C configuration
  * register.
  *
@@ -292,9 +292,7 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 	u32 val;
 
 	if (!voltdm->pmic || !voltdm->pmic->uv_to_vsel) {
-		pr_err("%s: PMIC info requried to configure vc for"
-			"vdd_%s not populated.Hence cannot initialize vc\n",
-			__func__, voltdm->name);
+		pr_err("%s: No PMIC info for vdd_%s\n", __func__, voltdm->name);
 		return;
 	}
 

commit 5876c940c0dee298e38fbf47ce67c9e220b0572c
Author: Kevin Hilman <khilman@ti.com>
Date:   Wed Jul 20 16:35:46 2011 -0700

    OMAP2+: VC: more registers are per-channel starting with OMAP5
    
    Starting with OMAP5, the following registers are per-channel and not
    common to a all VC channels:
    
     - SMPS I2C slave address
     - SMPS voltage register address offset
     - SMPS cmd/value register address offset
     - VC channel configuration register
    
    Move these from the channel-common struct into the per-channel struct
    to support OMAP5.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 6e586767a904..031d116fbf10 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -94,7 +94,7 @@ static int omap_vc_config_channel(struct voltagedomain *voltdm)
 
 	voltdm->rmw(CFG_CHANNEL_MASK << vc->cfg_channel_sa_shift,
 		    vc->cfg_channel << vc->cfg_channel_sa_shift,
-		    vc->common->cfg_channel_reg);
+		    vc->cfg_channel_reg);
 
 	return 0;
 }
@@ -319,7 +319,7 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 	/* Configure the i2c slave address for this VC */
 	voltdm->rmw(vc->smps_sa_mask,
 		    vc->i2c_slave_addr << __ffs(vc->smps_sa_mask),
-		    vc->common->smps_sa_reg);
+		    vc->smps_sa_reg);
 	vc->cfg_channel |= vc_cfg_bits->sa;
 
 	/*
@@ -327,13 +327,13 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 	 */
 	voltdm->rmw(vc->smps_volra_mask,
 		    vc->volt_reg_addr << __ffs(vc->smps_volra_mask),
-		    vc->common->smps_volra_reg);
+		    vc->smps_volra_reg);
 	vc->cfg_channel |= vc_cfg_bits->rav;
 
 	if (vc->cmd_reg_addr) {
 		voltdm->rmw(vc->smps_cmdra_mask,
 			    vc->cmd_reg_addr << __ffs(vc->smps_cmdra_mask),
-			    vc->common->smps_cmdra_reg);
+			    vc->smps_cmdra_reg);
 		vc->cfg_channel |= vc_cfg_bits->rac | vc_cfg_bits->racen;
 	}
 

commit 6a62b78d9aa6661cae1a7d30b574daf435a14c47
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Jul 18 16:24:17 2011 -0700

    OMAP3+: voltage: update nominal voltage in voltdm_scale() not VC post-scale
    
    Currently, the nominal voltage is updated in the VC post-scale function
    which is common to both scaling methods.  However, this has readabiliy
    problems as this update is not where it might be expected.  Instead, move
    the updated into voltdm_scale() upon a successful return of voltdm->scale()
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index d9e69944f0c9..6e586767a904 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -152,8 +152,6 @@ void omap_vc_post_scale(struct voltagedomain *voltdm,
 	smps_delay = ((smps_steps * voltdm->pmic->step_size) /
 			voltdm->pmic->slew_rate) + 2;
 	udelay(smps_delay);
-
-	voltdm->nominal_volt = target_volt;
 }
 
 /* vc_bypass_scale - VC bypass method of voltage scaling */

commit 7590f608aacba64c42edd5a8d9560264b049f403
Author: Kevin Hilman <khilman@ti.com>
Date:   Tue Apr 5 16:55:22 2011 -0700

    OMAP3+: voltage: move/rename curr_volt from vdd_info into struct voltagedomain
    
    Track current nominal voltage as part of struct voltagedomain instead
    of omap_vdd_info, which will soon be removed.
    
    Also renames field from curr_volt to nominal_volt.
    
    No functional changes.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index f8bdd5183e2f..d9e69944f0c9 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -128,7 +128,7 @@ int omap_vc_pre_scale(struct voltagedomain *voltdm,
 	}
 
 	*target_vsel = voltdm->pmic->uv_to_vsel(target_volt);
-	*current_vsel = voltdm->pmic->uv_to_vsel(vdd->curr_volt);
+	*current_vsel = voltdm->pmic->uv_to_vsel(voltdm->nominal_volt);
 
 	/* Setting the ON voltage to the new target voltage */
 	vc_cmdval = voltdm->read(vc->cmdval_reg);
@@ -145,7 +145,6 @@ void omap_vc_post_scale(struct voltagedomain *voltdm,
 			unsigned long target_volt,
 			u8 target_vsel, u8 current_vsel)
 {
-	struct omap_vdd_info *vdd = voltdm->vdd;
 	u32 smps_steps = 0, smps_delay = 0;
 
 	smps_steps = abs(target_vsel - current_vsel);
@@ -154,7 +153,7 @@ void omap_vc_post_scale(struct voltagedomain *voltdm,
 			voltdm->pmic->slew_rate) + 2;
 	udelay(smps_delay);
 
-	vdd->curr_volt = target_volt;
+	voltdm->nominal_volt = target_volt;
 }
 
 /* vc_bypass_scale - VC bypass method of voltage scaling */

commit 76ea7424f80350884b4d70ae54cfa51f7f9b2a48
Author: Kevin Hilman <khilman@ti.com>
Date:   Tue Apr 5 15:15:31 2011 -0700

    OMAP3+: VP: create VP helper function for updating error gain
    
    Create new helper function in VP layer for updating VP error gain.
    Currently used during pre-scale for VP force update and VC bypass.
    
    TODO: determine if this can be removed from the pre-scale path and
    moved to VP enable path.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 7b87ea16ce43..f8bdd5183e2f 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -105,9 +105,7 @@ int omap_vc_pre_scale(struct voltagedomain *voltdm,
 		      u8 *target_vsel, u8 *current_vsel)
 {
 	struct omap_vc_channel *vc = voltdm->vc;
-	struct omap_vdd_info *vdd = voltdm->vdd;
-	struct omap_volt_data *volt_data;
-	u32 vc_cmdval, vp_errgain_val;
+	u32 vc_cmdval;
 
 	/* Check if sufficient pmic info is available for this vdd */
 	if (!voltdm->pmic) {
@@ -129,11 +127,6 @@ int omap_vc_pre_scale(struct voltagedomain *voltdm,
 		return -EINVAL;
 	}
 
-	/* Get volt_data corresponding to target_volt */
-	volt_data = omap_voltage_get_voltdata(voltdm, target_volt);
-	if (IS_ERR(volt_data))
-		volt_data = NULL;
-
 	*target_vsel = voltdm->pmic->uv_to_vsel(target_volt);
 	*current_vsel = voltdm->pmic->uv_to_vsel(vdd->curr_volt);
 
@@ -143,15 +136,7 @@ int omap_vc_pre_scale(struct voltagedomain *voltdm,
 	vc_cmdval |= (*target_vsel << vc->common->cmd_on_shift);
 	voltdm->write(vc_cmdval, vc->cmdval_reg);
 
-	/* Setting vp errorgain based on the voltage */
-	if (volt_data) {
-		vp_errgain_val = voltdm->read(voltdm->vp->vpconfig);
-		vdd->vp_rt_data.vpconfig_errorgain = volt_data->vp_errgain;
-		vp_errgain_val &= voltdm->vp->common->vpconfig_errorgain_mask;
-		vp_errgain_val |= vdd->vp_rt_data.vpconfig_errorgain <<
-			__ffs(voltdm->vp->common->vpconfig_errorgain_mask);
-		voltdm->write(vp_errgain_val, voltdm->vp->vpconfig);
-	}
+	omap_vp_update_errorgain(voltdm, target_volt);
 
 	return 0;
 }

commit 0ec3041e91cf365a76c81b224e85d3c2574fec23
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Apr 4 16:02:28 2011 -0700

    OMAP3+: VP: struct omap_vp_common: replace shift with __ffs(mask)
    
    In struct omap_vp_common, the shift value can be derived from the mask
    value by using __ffs(), so remove the shift value for the various
    VPCONFIG bitfields, and use __ffs() in the code for the shift value.
    
    While here, rename field names in kerneldoc comment to match actual
    field names in structure.  Also, cleanup indendentaion for other VP
    register accesses in omap_vp_init().
    
    No functional changes.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index e872a0369afb..7b87ea16ce43 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -149,7 +149,7 @@ int omap_vc_pre_scale(struct voltagedomain *voltdm,
 		vdd->vp_rt_data.vpconfig_errorgain = volt_data->vp_errgain;
 		vp_errgain_val &= voltdm->vp->common->vpconfig_errorgain_mask;
 		vp_errgain_val |= vdd->vp_rt_data.vpconfig_errorgain <<
-			voltdm->vp->common->vpconfig_errorgain_shift;
+			__ffs(voltdm->vp->common->vpconfig_errorgain_mask);
 		voltdm->write(vp_errgain_val, voltdm->vp->vpconfig);
 	}
 

commit b7ea803e55769768d1eff3b32e4f99837fa6ddb5
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Apr 4 15:25:07 2011 -0700

    OMAP3+: VP: cleanup: move VP instance into voltdm, misc. renames
    
    - move VP instance struct from vdd_info into struct voltage domain
    - remove _data suffix from structure name
    - rename vp_ prefix from vp_common field: accesses are now vp->common
    - move vp_enabled bool from vdd_info into VP instance
    - remove remaining references to omap_vdd_info
    
    No functional changes.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 21ffde86ad83..e872a0369afb 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -107,11 +107,8 @@ int omap_vc_pre_scale(struct voltagedomain *voltdm,
 	struct omap_vc_channel *vc = voltdm->vc;
 	struct omap_vdd_info *vdd = voltdm->vdd;
 	struct omap_volt_data *volt_data;
-	const struct omap_vp_common_data *vp_common;
 	u32 vc_cmdval, vp_errgain_val;
 
-	vp_common = vdd->vp_data->vp_common;
-
 	/* Check if sufficient pmic info is available for this vdd */
 	if (!voltdm->pmic) {
 		pr_err("%s: Insufficient pmic info to scale the vdd_%s\n",
@@ -148,12 +145,12 @@ int omap_vc_pre_scale(struct voltagedomain *voltdm,
 
 	/* Setting vp errorgain based on the voltage */
 	if (volt_data) {
-		vp_errgain_val = voltdm->read(vdd->vp_data->vpconfig);
+		vp_errgain_val = voltdm->read(voltdm->vp->vpconfig);
 		vdd->vp_rt_data.vpconfig_errorgain = volt_data->vp_errgain;
-		vp_errgain_val &= ~vp_common->vpconfig_errorgain_mask;
+		vp_errgain_val &= voltdm->vp->common->vpconfig_errorgain_mask;
 		vp_errgain_val |= vdd->vp_rt_data.vpconfig_errorgain <<
-			vp_common->vpconfig_errorgain_shift;
-		voltdm->write(vp_errgain_val, vdd->vp_data->vpconfig);
+			voltdm->vp->common->vpconfig_errorgain_shift;
+		voltdm->write(vp_errgain_val, voltdm->vp->vpconfig);
 	}
 
 	return 0;

commit d7b0de2b46803062148345ae6a976c1e44a457b6
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Jul 18 15:31:00 2011 -0700

    OMAP3+: VC: use last nominal voltage setting to get current_vsel
    
    Instead of reading current vsel value from the VP's voltage register,
    just use current nominal voltage translated into vsel via the PMIC.
    
    Doing this allows VC bypass scaling to work even without a VP configured.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index f53d1f5acce1..21ffde86ad83 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -138,7 +138,7 @@ int omap_vc_pre_scale(struct voltagedomain *voltdm,
 		volt_data = NULL;
 
 	*target_vsel = voltdm->pmic->uv_to_vsel(target_volt);
-	*current_vsel = voltdm->read(vdd->vp_data->voltage);
+	*current_vsel = voltdm->pmic->uv_to_vsel(vdd->curr_volt);
 
 	/* Setting the ON voltage to the new target voltage */
 	vc_cmdval = voltdm->read(vc->cmdval_reg);

commit 8abc0b58fdb89124d8278f110f523b27c666d36c
Author: Kevin Hilman <khilman@ti.com>
Date:   Thu Jun 2 17:28:13 2011 -0700

    OMAP3+: PM: VC: handle mutant channel config for OMAP4 MPU channel
    
    On OMAP3+, all VC channels have the the same bitfield ordering for all
    VC channels, except the OMAP4 MPU channel.  This appears to be a freak
    accident as all other VC channel (including OMAP5) have the standard
    configuration.  Handle the mutant case by adding a per-channel flag
    to signal the deformity and handle it during VC init.
    
    Special thanks to Nishanth Menon <nm@ti.com> for finding this problem
    and for proposing the initial solution.
    
    Cc: Nishanth Menon <nm@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 5d545632388d..f53d1f5acce1 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -19,17 +19,51 @@
 #include "prm-regbits-44xx.h"
 #include "prm44xx.h"
 
-/*
- * Channel configuration bits, common for OMAP3 & 4
+/**
+ * struct omap_vc_channel_cfg - describe the cfg_channel bitfield
+ * @sa: bit for slave address
+ * @rav: bit for voltage configuration register
+ * @rac: bit for command configuration register
+ * @racen: enable bit for RAC
+ * @cmd: bit for command value set selection
+ *
+ * Channel configuration bits, common for OMAP3+
  * OMAP3 register: PRM_VC_CH_CONF
  * OMAP4 register: PRM_VC_CFG_CHANNEL
+ * OMAP5 register: PRM_VC_SMPS_<voltdm>_CONFIG
  */
-#define CFG_CHANNEL_SA    BIT(0)
-#define CFG_CHANNEL_RAV   BIT(1)
-#define CFG_CHANNEL_RAC   BIT(2)
-#define CFG_CHANNEL_RACEN BIT(3)
-#define CFG_CHANNEL_CMD   BIT(4)
-#define CFG_CHANNEL_MASK 0x3f
+struct omap_vc_channel_cfg {
+	u8 sa;
+	u8 rav;
+	u8 rac;
+	u8 racen;
+	u8 cmd;
+};
+
+static struct omap_vc_channel_cfg vc_default_channel_cfg = {
+	.sa    = BIT(0),
+	.rav   = BIT(1),
+	.rac   = BIT(2),
+	.racen = BIT(3),
+	.cmd   = BIT(4),
+};
+
+/*
+ * On OMAP3+, all VC channels have the above default bitfield
+ * configuration, except the OMAP4 MPU channel.  This appears
+ * to be a freak accident as every other VC channel has the
+ * default configuration, thus creating a mutant channel config.
+ */
+static struct omap_vc_channel_cfg vc_mutant_channel_cfg = {
+	.sa    = BIT(0),
+	.rav   = BIT(2),
+	.rac   = BIT(3),
+	.racen = BIT(4),
+	.cmd   = BIT(1),
+};
+
+static struct omap_vc_channel_cfg *vc_cfg_bits;
+#define CFG_CHANNEL_MASK 0x1f
 
 /**
  * omap_vc_config_channel - configure VC channel to PMIC mappings
@@ -56,7 +90,7 @@ static int omap_vc_config_channel(struct voltagedomain *voltdm)
 	 * All others must stay at zero (see function comment above.)
 	 */
 	if (vc->flags & OMAP_VC_CHANNEL_DEFAULT)
-		vc->cfg_channel &= CFG_CHANNEL_RACEN;
+		vc->cfg_channel &= vc_cfg_bits->racen;
 
 	voltdm->rmw(CFG_CHANNEL_MASK << vc->cfg_channel_sa_shift,
 		    vc->cfg_channel << vc->cfg_channel_sa_shift,
@@ -292,6 +326,10 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 	}
 
 	vc->cfg_channel = 0;
+	if (vc->flags & OMAP_VC_CHANNEL_CFG_MUTANT)
+		vc_cfg_bits = &vc_mutant_channel_cfg;
+	else
+		vc_cfg_bits = &vc_default_channel_cfg;
 
 	/* get PMIC/board specific settings */
 	vc->i2c_slave_addr = voltdm->pmic->i2c_slave_addr;
@@ -303,7 +341,7 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 	voltdm->rmw(vc->smps_sa_mask,
 		    vc->i2c_slave_addr << __ffs(vc->smps_sa_mask),
 		    vc->common->smps_sa_reg);
-	vc->cfg_channel |= CFG_CHANNEL_SA;
+	vc->cfg_channel |= vc_cfg_bits->sa;
 
 	/*
 	 * Configure the PMIC register addresses.
@@ -311,13 +349,13 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 	voltdm->rmw(vc->smps_volra_mask,
 		    vc->volt_reg_addr << __ffs(vc->smps_volra_mask),
 		    vc->common->smps_volra_reg);
-	vc->cfg_channel |= CFG_CHANNEL_RAV;
+	vc->cfg_channel |= vc_cfg_bits->rav;
 
 	if (vc->cmd_reg_addr) {
 		voltdm->rmw(vc->smps_cmdra_mask,
 			    vc->cmd_reg_addr << __ffs(vc->smps_cmdra_mask),
 			    vc->common->smps_cmdra_reg);
-		vc->cfg_channel |= CFG_CHANNEL_RAC | CFG_CHANNEL_RACEN;
+		vc->cfg_channel |= vc_cfg_bits->rac | vc_cfg_bits->racen;
 	}
 
 	/* Set up the on, inactive, retention and off voltage */
@@ -330,7 +368,7 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 	       (ret_vsel << vc->common->cmd_ret_shift) |
 	       (off_vsel << vc->common->cmd_off_shift));
 	voltdm->write(val, vc->cmdval_reg);
-	vc->cfg_channel |= CFG_CHANNEL_CMD;
+	vc->cfg_channel |= vc_cfg_bits->cmd;
 
 	/* Channel configuration */
 	omap_vc_config_channel(voltdm);

commit f5395480f5088a86cc8594d29b5c2f07f6995c3d
Author: Kevin Hilman <khilman@ti.com>
Date:   Wed Mar 30 16:36:30 2011 -0700

    OMAP3+: VC: make I2C config programmable with PMIC-specific settings
    
    Remove hard-coded I2C configuration in favor of settings that can be
    configured from PMIC-specific values.  Currently only high-speed mode
    and the master-code value are supported, since they were the only
    fields currently used, but extending this is now trivial.
    
    Thanks to Nishanth Menon <nm@ti.com> for reporting/fixing a sparse
    problem and making omap_vc_i2c_init() static, as well as finding and
    fixing a problem with the shift/mask of mcode.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 4ac761440d62..5d545632388d 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -208,13 +208,6 @@ static void __init omap3_vc_init_channel(struct voltagedomain *voltdm)
 	if (is_initialized)
 		return;
 
-	/*
-	 * Generic VC parameters init
-	 * XXX This data should be abstracted out
-	 */
-	voltdm->write(OMAP3430_MCODE_SHIFT | OMAP3430_HSEN_MASK,
-		       OMAP3_PRM_VC_I2C_CFG_OFFSET);
-
 	omap3_vfsm_init(voltdm);
 
 	is_initialized = true;
@@ -237,6 +230,48 @@ static void __init omap4_vc_init_channel(struct voltagedomain *voltdm)
 	is_initialized = true;
 }
 
+/**
+ * omap_vc_i2c_init - initialize I2C interface to PMIC
+ * @voltdm: voltage domain containing VC data
+ *
+ * Use PMIC supplied seetings for I2C high-speed mode and
+ * master code (if set) and program the VC I2C configuration
+ * register.
+ *
+ * The VC I2C configuration is common to all VC channels,
+ * so this function only configures I2C for the first VC
+ * channel registers.  All other VC channels will use the
+ * same configuration.
+ */
+static void __init omap_vc_i2c_init(struct voltagedomain *voltdm)
+{
+	struct omap_vc_channel *vc = voltdm->vc;
+	static bool initialized;
+	static bool i2c_high_speed;
+	u8 mcode;
+
+	if (initialized) {
+		if (voltdm->pmic->i2c_high_speed != i2c_high_speed)
+			pr_warn("%s: I2C config for all channels must match.",
+				__func__);
+		return;
+	}
+
+	i2c_high_speed = voltdm->pmic->i2c_high_speed;
+	if (i2c_high_speed)
+		voltdm->rmw(vc->common->i2c_cfg_hsen_mask,
+			    vc->common->i2c_cfg_hsen_mask,
+			    vc->common->i2c_cfg_reg);
+
+	mcode = voltdm->pmic->i2c_mcode;
+	if (mcode)
+		voltdm->rmw(vc->common->i2c_mcode_mask,
+			    mcode << __ffs(vc->common->i2c_mcode_mask),
+			    vc->common->i2c_cfg_reg);
+
+	initialized = true;
+}
+
 void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 {
 	struct omap_vc_channel *vc = voltdm->vc;
@@ -305,6 +340,8 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 		    vc->setup_time << __ffs(voltdm->vfsm->voltsetup_mask),
 		    voltdm->vfsm->voltsetup_reg);
 
+	omap_vc_i2c_init(voltdm);
+
 	if (cpu_is_omap34xx())
 		omap3_vc_init_channel(voltdm);
 	else if (cpu_is_omap44xx())

commit ce8ebe0dfb1f8713337cebf82499d3dced288328
Author: Kevin Hilman <khilman@ti.com>
Date:   Wed Mar 30 11:01:10 2011 -0700

    OMAP3+: voltage domain: move PMIC struct from vdd_info into struct voltagedomain
    
    Move structure containing PMIC configurable settings into struct
    voltagedomain.  In the process, rename from omap_volt_pmic_info to
    omap_voltdm_pmic (_info suffix is not helpful.)
    
    No functional changes.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 1791f79112bf..4ac761440d62 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -79,13 +79,13 @@ int omap_vc_pre_scale(struct voltagedomain *voltdm,
 	vp_common = vdd->vp_data->vp_common;
 
 	/* Check if sufficient pmic info is available for this vdd */
-	if (!vdd->pmic_info) {
+	if (!voltdm->pmic) {
 		pr_err("%s: Insufficient pmic info to scale the vdd_%s\n",
 			__func__, voltdm->name);
 		return -EINVAL;
 	}
 
-	if (!vdd->pmic_info->uv_to_vsel) {
+	if (!voltdm->pmic->uv_to_vsel) {
 		pr_err("%s: PMIC function to convert voltage in uV to"
 			"vsel not registered. Hence unable to scale voltage"
 			"for vdd_%s\n", __func__, voltdm->name);
@@ -103,7 +103,7 @@ int omap_vc_pre_scale(struct voltagedomain *voltdm,
 	if (IS_ERR(volt_data))
 		volt_data = NULL;
 
-	*target_vsel = vdd->pmic_info->uv_to_vsel(target_volt);
+	*target_vsel = voltdm->pmic->uv_to_vsel(target_volt);
 	*current_vsel = voltdm->read(vdd->vp_data->voltage);
 
 	/* Setting the ON voltage to the new target voltage */
@@ -134,8 +134,8 @@ void omap_vc_post_scale(struct voltagedomain *voltdm,
 
 	smps_steps = abs(target_vsel - current_vsel);
 	/* SMPS slew rate / step size. 2us added as buffer. */
-	smps_delay = ((smps_steps * vdd->pmic_info->step_size) /
-			vdd->pmic_info->slew_rate) + 2;
+	smps_delay = ((smps_steps * voltdm->pmic->step_size) /
+			voltdm->pmic->slew_rate) + 2;
 	udelay(smps_delay);
 
 	vdd->curr_volt = target_volt;
@@ -240,11 +240,10 @@ static void __init omap4_vc_init_channel(struct voltagedomain *voltdm)
 void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 {
 	struct omap_vc_channel *vc = voltdm->vc;
-	struct omap_vdd_info *vdd = voltdm->vdd;
 	u8 on_vsel, onlp_vsel, ret_vsel, off_vsel;
 	u32 val;
 
-	if (!vdd->pmic_info || !vdd->pmic_info->uv_to_vsel) {
+	if (!voltdm->pmic || !voltdm->pmic->uv_to_vsel) {
 		pr_err("%s: PMIC info requried to configure vc for"
 			"vdd_%s not populated.Hence cannot initialize vc\n",
 			__func__, voltdm->name);
@@ -260,10 +259,10 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 	vc->cfg_channel = 0;
 
 	/* get PMIC/board specific settings */
-	vc->i2c_slave_addr = vdd->pmic_info->i2c_slave_addr;
-	vc->volt_reg_addr = vdd->pmic_info->volt_reg_addr;
-	vc->cmd_reg_addr = vdd->pmic_info->cmd_reg_addr;
-	vc->setup_time = vdd->pmic_info->volt_setup_time;
+	vc->i2c_slave_addr = voltdm->pmic->i2c_slave_addr;
+	vc->volt_reg_addr = voltdm->pmic->volt_reg_addr;
+	vc->cmd_reg_addr = voltdm->pmic->cmd_reg_addr;
+	vc->setup_time = voltdm->pmic->volt_setup_time;
 
 	/* Configure the i2c slave address for this VC */
 	voltdm->rmw(vc->smps_sa_mask,
@@ -287,10 +286,10 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 	}
 
 	/* Set up the on, inactive, retention and off voltage */
-	on_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->on_volt);
-	onlp_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->onlp_volt);
-	ret_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->ret_volt);
-	off_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->off_volt);
+	on_vsel = voltdm->pmic->uv_to_vsel(voltdm->pmic->on_volt);
+	onlp_vsel = voltdm->pmic->uv_to_vsel(voltdm->pmic->onlp_volt);
+	ret_vsel = voltdm->pmic->uv_to_vsel(voltdm->pmic->ret_volt);
+	off_vsel = voltdm->pmic->uv_to_vsel(voltdm->pmic->off_volt);
 	val = ((on_vsel << vc->common->cmd_on_shift) |
 	       (onlp_vsel << vc->common->cmd_onlp_shift) |
 	       (ret_vsel << vc->common->cmd_ret_shift) |

commit 24d3194a2c9bc4d2315117915d4d22c395c07fd5
Author: Kevin Hilman <khilman@ti.com>
Date:   Tue Mar 29 15:57:16 2011 -0700

    OMAP3+: VC: abstract out channel configuration
    
    VC channel configuration is programmed based on settings coming from
    the PMIC configuration.
    
    Currently, the VC channel to PMIC mapping is a simple one-to-one
    mapping.  Whenever a VC channel parameter is configured (i2c slave
    addres, PMIC register address, on/ret/off command), the corresponding
    bits are enabled in the VC channel configuration register.
    
    If necessary, the programmability of channel configuration settings
    could be extended to board/PMIC files, however, because this patch
    changes the channel configuration to be programmed based on existing
    values from the PMIC settings, it may not be required.
    
    Also note that starting with OMAP4, where there are more than 2
    channels, one channel is identified as the "default" channel.  When
    any of the bits in the channel config for the other channels are zero,
    it means to use the default channel.  The OMAP4 TRM (at least through
    NDA version Q) is wrong in describing which is the default channel.
    The default channel on OMAP4 is MPU, not CORE as decribed in the TRM.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 72c9cb64a42b..1791f79112bf 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -19,6 +19,52 @@
 #include "prm-regbits-44xx.h"
 #include "prm44xx.h"
 
+/*
+ * Channel configuration bits, common for OMAP3 & 4
+ * OMAP3 register: PRM_VC_CH_CONF
+ * OMAP4 register: PRM_VC_CFG_CHANNEL
+ */
+#define CFG_CHANNEL_SA    BIT(0)
+#define CFG_CHANNEL_RAV   BIT(1)
+#define CFG_CHANNEL_RAC   BIT(2)
+#define CFG_CHANNEL_RACEN BIT(3)
+#define CFG_CHANNEL_CMD   BIT(4)
+#define CFG_CHANNEL_MASK 0x3f
+
+/**
+ * omap_vc_config_channel - configure VC channel to PMIC mappings
+ * @voltdm: pointer to voltagdomain defining the desired VC channel
+ *
+ * Configures the VC channel to PMIC mappings for the following
+ * PMIC settings
+ * - i2c slave address (SA)
+ * - voltage configuration address (RAV)
+ * - command configuration address (RAC) and enable bit (RACEN)
+ * - command values for ON, ONLP, RET and OFF (CMD)
+ *
+ * This function currently only allows flexible configuration of the
+ * non-default channel.  Starting with OMAP4, there are more than 2
+ * channels, with one defined as the default (on OMAP4, it's MPU.)
+ * Only the non-default channel can be configured.
+ */
+static int omap_vc_config_channel(struct voltagedomain *voltdm)
+{
+	struct omap_vc_channel *vc = voltdm->vc;
+
+	/*
+	 * For default channel, the only configurable bit is RACEN.
+	 * All others must stay at zero (see function comment above.)
+	 */
+	if (vc->flags & OMAP_VC_CHANNEL_DEFAULT)
+		vc->cfg_channel &= CFG_CHANNEL_RACEN;
+
+	voltdm->rmw(CFG_CHANNEL_MASK << vc->cfg_channel_sa_shift,
+		    vc->cfg_channel << vc->cfg_channel_sa_shift,
+		    vc->common->cfg_channel_reg);
+
+	return 0;
+}
+
 /* Voltage scale and accessory APIs */
 int omap_vc_pre_scale(struct voltagedomain *voltdm,
 		      unsigned long target_volt,
@@ -166,8 +212,6 @@ static void __init omap3_vc_init_channel(struct voltagedomain *voltdm)
 	 * Generic VC parameters init
 	 * XXX This data should be abstracted out
 	 */
-	voltdm->write(OMAP3430_CMD1_MASK | OMAP3430_RAV1_MASK,
-		       OMAP3_PRM_VC_CH_CONF_OFFSET);
 	voltdm->write(OMAP3430_MCODE_SHIFT | OMAP3430_HSEN_MASK,
 		       OMAP3_PRM_VC_I2C_CFG_OFFSET);
 
@@ -186,15 +230,6 @@ static void __init omap4_vc_init_channel(struct voltagedomain *voltdm)
 	if (is_initialized)
 		return;
 
-	/*
-	 * Generic VC parameters init
-	 * XXX This data should be abstracted out
-	 */
-	vc_val = (OMAP4430_RAV_VDD_MPU_L_MASK | OMAP4430_CMD_VDD_MPU_L_MASK |
-		  OMAP4430_RAV_VDD_IVA_L_MASK | OMAP4430_CMD_VDD_IVA_L_MASK |
-		  OMAP4430_RAV_VDD_CORE_L_MASK | OMAP4430_CMD_VDD_CORE_L_MASK);
-	voltdm->write(vc_val, OMAP4_PRM_VC_CFG_CHANNEL_OFFSET);
-
 	/* XXX These are magic numbers and do not belong! */
 	vc_val = (0x60 << OMAP4430_SCLL_SHIFT | 0x26 << OMAP4430_SCLH_SHIFT);
 	voltdm->write(vc_val, OMAP4_PRM_VC_CFG_I2C_CLK_OFFSET);
@@ -222,6 +257,8 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 		return;
 	}
 
+	vc->cfg_channel = 0;
+
 	/* get PMIC/board specific settings */
 	vc->i2c_slave_addr = vdd->pmic_info->i2c_slave_addr;
 	vc->volt_reg_addr = vdd->pmic_info->volt_reg_addr;
@@ -232,6 +269,7 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 	voltdm->rmw(vc->smps_sa_mask,
 		    vc->i2c_slave_addr << __ffs(vc->smps_sa_mask),
 		    vc->common->smps_sa_reg);
+	vc->cfg_channel |= CFG_CHANNEL_SA;
 
 	/*
 	 * Configure the PMIC register addresses.
@@ -239,10 +277,14 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 	voltdm->rmw(vc->smps_volra_mask,
 		    vc->volt_reg_addr << __ffs(vc->smps_volra_mask),
 		    vc->common->smps_volra_reg);
-	if (vc->cmd_reg_addr)
+	vc->cfg_channel |= CFG_CHANNEL_RAV;
+
+	if (vc->cmd_reg_addr) {
 		voltdm->rmw(vc->smps_cmdra_mask,
 			    vc->cmd_reg_addr << __ffs(vc->smps_cmdra_mask),
 			    vc->common->smps_cmdra_reg);
+		vc->cfg_channel |= CFG_CHANNEL_RAC | CFG_CHANNEL_RACEN;
+	}
 
 	/* Set up the on, inactive, retention and off voltage */
 	on_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->on_volt);
@@ -254,6 +296,10 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 	       (ret_vsel << vc->common->cmd_ret_shift) |
 	       (off_vsel << vc->common->cmd_off_shift));
 	voltdm->write(val, vc->cmdval_reg);
+	vc->cfg_channel |= CFG_CHANNEL_CMD;
+
+	/* Channel configuration */
+	omap_vc_config_channel(voltdm);
 
 	/* Configure the setup times */
 	voltdm->rmw(voltdm->vfsm->voltsetup_mask,

commit 08d1c9a3e2dc7a285db7c689c42963d0f5271c1f
Author: Kevin Hilman <khilman@ti.com>
Date:   Tue Mar 29 15:14:38 2011 -0700

    OMAP3+: VC: move on/onlp/ret/off command configuration into common init
    
    Configuring the on/onlp/ret/off command values is common to OMAP3 & 4.
    Move from OMAP3-only init into common VC init.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index f78e62abe720..72c9cb64a42b 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -157,26 +157,11 @@ static void __init omap3_vfsm_init(struct voltagedomain *voltdm)
 
 static void __init omap3_vc_init_channel(struct voltagedomain *voltdm)
 {
-	struct omap_vc_channel *vc = voltdm->vc;
-	struct omap_vdd_info *vdd = voltdm->vdd;
 	static bool is_initialized;
-	u8 on_vsel, onlp_vsel, ret_vsel, off_vsel;
-	u32 vc_val;
 
 	if (is_initialized)
 		return;
 
-	/* Set up the on, inactive, retention and off voltage */
-	on_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->on_volt);
-	onlp_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->onlp_volt);
-	ret_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->ret_volt);
-	off_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->off_volt);
-	vc_val	= ((on_vsel << vc->common->cmd_on_shift) |
-		(onlp_vsel << vc->common->cmd_onlp_shift) |
-		(ret_vsel << vc->common->cmd_ret_shift) |
-		(off_vsel << vc->common->cmd_off_shift));
-	voltdm->write(vc_val, vc->cmdval_reg);
-
 	/*
 	 * Generic VC parameters init
 	 * XXX This data should be abstracted out
@@ -201,8 +186,6 @@ static void __init omap4_vc_init_channel(struct voltagedomain *voltdm)
 	if (is_initialized)
 		return;
 
-	/* TODO: Configure setup times and CMD_VAL values*/
-
 	/*
 	 * Generic VC parameters init
 	 * XXX This data should be abstracted out
@@ -223,6 +206,8 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 {
 	struct omap_vc_channel *vc = voltdm->vc;
 	struct omap_vdd_info *vdd = voltdm->vdd;
+	u8 on_vsel, onlp_vsel, ret_vsel, off_vsel;
+	u32 val;
 
 	if (!vdd->pmic_info || !vdd->pmic_info->uv_to_vsel) {
 		pr_err("%s: PMIC info requried to configure vc for"
@@ -259,6 +244,17 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 			    vc->cmd_reg_addr << __ffs(vc->smps_cmdra_mask),
 			    vc->common->smps_cmdra_reg);
 
+	/* Set up the on, inactive, retention and off voltage */
+	on_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->on_volt);
+	onlp_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->onlp_volt);
+	ret_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->ret_volt);
+	off_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->off_volt);
+	val = ((on_vsel << vc->common->cmd_on_shift) |
+	       (onlp_vsel << vc->common->cmd_onlp_shift) |
+	       (ret_vsel << vc->common->cmd_ret_shift) |
+	       (off_vsel << vc->common->cmd_off_shift));
+	voltdm->write(val, vc->cmdval_reg);
+
 	/* Configure the setup times */
 	voltdm->rmw(voltdm->vfsm->voltsetup_mask,
 		    vc->setup_time << __ffs(voltdm->vfsm->voltsetup_mask),

commit 5892bb1fc6430d086f5c2a4216f9ed00070e31ad
Author: Kevin Hilman <khilman@ti.com>
Date:   Tue Mar 29 14:36:04 2011 -0700

    OMAP3+: VC: cleanup voltage setup time configuration
    
    - add setup_time field to struct omap_vc_channel (init'd from PMIC data)
    - use VC/VP register access helper for read/modify/write
    - move VFSM structure from omap_vdd_info into struct voltagedomain
    - remove redunant _data suffix from VFSM structures and variables
    - remove voltsetup_shift, use ffs() on the mask value to find the shift
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 8f0105a7bb4b..f78e62abe720 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -223,7 +223,6 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 {
 	struct omap_vc_channel *vc = voltdm->vc;
 	struct omap_vdd_info *vdd = voltdm->vdd;
-	u32 vc_val;
 
 	if (!vdd->pmic_info || !vdd->pmic_info->uv_to_vsel) {
 		pr_err("%s: PMIC info requried to configure vc for"
@@ -242,6 +241,7 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 	vc->i2c_slave_addr = vdd->pmic_info->i2c_slave_addr;
 	vc->volt_reg_addr = vdd->pmic_info->volt_reg_addr;
 	vc->cmd_reg_addr = vdd->pmic_info->cmd_reg_addr;
+	vc->setup_time = vdd->pmic_info->volt_setup_time;
 
 	/* Configure the i2c slave address for this VC */
 	voltdm->rmw(vc->smps_sa_mask,
@@ -260,11 +260,9 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 			    vc->common->smps_cmdra_reg);
 
 	/* Configure the setup times */
-	vc_val = voltdm->read(vdd->vfsm->voltsetup_reg);
-	vc_val &= ~vdd->vfsm->voltsetup_mask;
-	vc_val |= vdd->pmic_info->volt_setup_time <<
-			vdd->vfsm->voltsetup_shift;
-	voltdm->write(vc_val, vdd->vfsm->voltsetup_reg);
+	voltdm->rmw(voltdm->vfsm->voltsetup_mask,
+		    vc->setup_time << __ffs(voltdm->vfsm->voltsetup_mask),
+		    voltdm->vfsm->voltsetup_reg);
 
 	if (cpu_is_omap34xx())
 		omap3_vc_init_channel(voltdm);

commit 78614e0f8f32dca52beebaadfb53c2a3acf1604a
Author: Kevin Hilman <khilman@ti.com>
Date:   Tue Mar 29 14:24:47 2011 -0700

    OMAP3+: VC bypass: use fields from VC struct instead of PMIC info
    
    The PMIC configurable variables should be isolated to VC initialization.
    The rest of the VC functions (like VC bypass) should use the i2c slave address
    and voltage register address fields from struct omap_vc_channel.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 22db6e6764d7..8f0105a7bb4b 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -100,7 +100,6 @@ int omap_vc_bypass_scale(struct voltagedomain *voltdm,
 			 unsigned long target_volt)
 {
 	struct omap_vc_channel *vc = voltdm->vc;
-	struct omap_vdd_info *vdd = voltdm->vdd;
 	u32 loop_cnt = 0, retries_cnt = 0;
 	u32 vc_valid, vc_bypass_val_reg, vc_bypass_value;
 	u8 target_vsel, current_vsel;
@@ -113,10 +112,8 @@ int omap_vc_bypass_scale(struct voltagedomain *voltdm,
 	vc_valid = vc->common->valid;
 	vc_bypass_val_reg = vc->common->bypass_val_reg;
 	vc_bypass_value = (target_vsel << vc->common->data_shift) |
-			(vdd->pmic_info->volt_reg_addr <<
-			vc->common->regaddr_shift) |
-			(vdd->pmic_info->i2c_slave_addr <<
-			vc->common->slaveaddr_shift);
+		(vc->volt_reg_addr << vc->common->regaddr_shift) |
+		(vc->i2c_slave_addr << vc->common->slaveaddr_shift);
 
 	voltdm->write(vc_bypass_value, vc_bypass_val_reg);
 	voltdm->write(vc_bypass_value | vc_valid, vc_bypass_val_reg);

commit e4e021c5491537783f5f65a6defa92e6098a3658
Author: Kevin Hilman <khilman@ti.com>
Date:   Thu Jun 9 11:01:55 2011 -0700

    OMAP3+: VC: cleanup PMIC register address configuration
    
    - support both voltage register address and command register address
      for each VC channel
    - add fields for voltage register address (volra) and command register
      address (cmdra) to struct omap_vc_channel
    - use VC/VP register access read/modify/write helper
    - remove volra_shift field (use __ffs(mask) for shift value)
    - I2C addresses 10-bit, change size to u16
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index d5e792f20f16..22db6e6764d7 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -243,17 +243,24 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 
 	/* get PMIC/board specific settings */
 	vc->i2c_slave_addr = vdd->pmic_info->i2c_slave_addr;
+	vc->volt_reg_addr = vdd->pmic_info->volt_reg_addr;
+	vc->cmd_reg_addr = vdd->pmic_info->cmd_reg_addr;
 
 	/* Configure the i2c slave address for this VC */
 	voltdm->rmw(vc->smps_sa_mask,
 		    vc->i2c_slave_addr << __ffs(vc->smps_sa_mask),
 		    vc->common->smps_sa_reg);
 
-	/* Setup the VOLRA(pmic reg addr) in VC */
-	vc_val = voltdm->read(vc->common->smps_volra_reg);
-	vc_val &= ~vc->smps_volra_mask;
-	vc_val |= vdd->pmic_info->volt_reg_addr << vc->smps_volra_shift;
-	voltdm->write(vc_val, vc->common->smps_volra_reg);
+	/*
+	 * Configure the PMIC register addresses.
+	 */
+	voltdm->rmw(vc->smps_volra_mask,
+		    vc->volt_reg_addr << __ffs(vc->smps_volra_mask),
+		    vc->common->smps_volra_reg);
+	if (vc->cmd_reg_addr)
+		voltdm->rmw(vc->smps_cmdra_mask,
+			    vc->cmd_reg_addr << __ffs(vc->smps_cmdra_mask),
+			    vc->common->smps_cmdra_reg);
 
 	/* Configure the setup times */
 	vc_val = voltdm->read(vdd->vfsm->voltsetup_reg);

commit ba112a4e86ba8f0f9546bd953374cde064b507ca
Author: Kevin Hilman <khilman@ti.com>
Date:   Tue Mar 29 14:02:36 2011 -0700

    OMAP3+: VC: cleanup i2c slave address configuration
    
    - Add an i2c_slave_address field to the omap_vc_channel
    - use VC/VP read/modify/write helper instead of open-coding
    - remove smps_sa_shift, use __ffs(mask) for shift value
    - I2C addresses 10-bit, change size to u16
    
    Special thanks to Shweta Gulati <shweta.gulati@ti.com> for suggesting
    the use of __ffs(x) instead of ffs(x) - 1.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index f1c73cbe3cb4..d5e792f20f16 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -241,11 +241,13 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 		return;
 	}
 
-	/* Set up the SMPS_SA(i2c slave address in VC */
-	vc_val = voltdm->read(vc->common->smps_sa_reg);
-	vc_val &= ~vc->smps_sa_mask;
-	vc_val |= vdd->pmic_info->i2c_slave_addr << vc->smps_sa_shift;
-	voltdm->write(vc_val, vc->common->smps_sa_reg);
+	/* get PMIC/board specific settings */
+	vc->i2c_slave_addr = vdd->pmic_info->i2c_slave_addr;
+
+	/* Configure the i2c slave address for this VC */
+	voltdm->rmw(vc->smps_sa_mask,
+		    vc->i2c_slave_addr << __ffs(vc->smps_sa_mask),
+		    vc->common->smps_sa_reg);
 
 	/* Setup the VOLRA(pmic reg addr) in VC */
 	vc_val = voltdm->read(vc->common->smps_volra_reg);

commit 4bcc475ebd06a04e1531254c27c6cf508ef8ebf9
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Mar 28 10:40:15 2011 -0700

    OMAP3+: voltage: convert to PRM register access functions
    
    Convert VC/VP register access to use PRM VC/VP accessor functions.  In
    the process, move the read/write function pointers from vdd_info into
    struct voltagedomain.
    
    No functional changes.
    
    Additional cleanup:
    - remove prm_mod field from  VC/VP data structures, the PRM register
      access functions know which PRM module to use.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 1bdbe7c15612..f1c73cbe3cb4 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -46,7 +46,7 @@ int omap_vc_pre_scale(struct voltagedomain *voltdm,
 		return -ENODATA;
 	}
 
-	if (!vdd->read_reg || !vdd->write_reg) {
+	if (!voltdm->read || !voltdm->write) {
 		pr_err("%s: No read/write API for accessing vdd_%s regs\n",
 			__func__, voltdm->name);
 		return -EINVAL;
@@ -58,24 +58,22 @@ int omap_vc_pre_scale(struct voltagedomain *voltdm,
 		volt_data = NULL;
 
 	*target_vsel = vdd->pmic_info->uv_to_vsel(target_volt);
-	*current_vsel = vdd->read_reg(vdd->vp_data->vp_common->prm_mod, vdd->vp_data->voltage);
+	*current_vsel = voltdm->read(vdd->vp_data->voltage);
 
 	/* Setting the ON voltage to the new target voltage */
-	vc_cmdval = vdd->read_reg(vc->common->prm_mod, vc->cmdval_reg);
+	vc_cmdval = voltdm->read(vc->cmdval_reg);
 	vc_cmdval &= ~vc->common->cmd_on_mask;
 	vc_cmdval |= (*target_vsel << vc->common->cmd_on_shift);
-	vdd->write_reg(vc_cmdval, vc->common->prm_mod, vc->cmdval_reg);
+	voltdm->write(vc_cmdval, vc->cmdval_reg);
 
 	/* Setting vp errorgain based on the voltage */
 	if (volt_data) {
-		vp_errgain_val = vdd->read_reg(vdd->vp_data->vp_common->prm_mod,
-					       vdd->vp_data->vpconfig);
+		vp_errgain_val = voltdm->read(vdd->vp_data->vpconfig);
 		vdd->vp_rt_data.vpconfig_errorgain = volt_data->vp_errgain;
 		vp_errgain_val &= ~vp_common->vpconfig_errorgain_mask;
 		vp_errgain_val |= vdd->vp_rt_data.vpconfig_errorgain <<
 			vp_common->vpconfig_errorgain_shift;
-		vdd->write_reg(vp_errgain_val, vdd->vp_data->vp_common->prm_mod,
-			       vdd->vp_data->vpconfig);
+		voltdm->write(vp_errgain_val, vdd->vp_data->vpconfig);
 	}
 
 	return 0;
@@ -120,11 +118,10 @@ int omap_vc_bypass_scale(struct voltagedomain *voltdm,
 			(vdd->pmic_info->i2c_slave_addr <<
 			vc->common->slaveaddr_shift);
 
-	vdd->write_reg(vc_bypass_value, vc->common->prm_mod, vc_bypass_val_reg);
-	vdd->write_reg(vc_bypass_value | vc_valid, vc->common->prm_mod,
-		       vc_bypass_val_reg);
+	voltdm->write(vc_bypass_value, vc_bypass_val_reg);
+	voltdm->write(vc_bypass_value | vc_valid, vc_bypass_val_reg);
 
-	vc_bypass_value = vdd->read_reg(vc->common->prm_mod, vc_bypass_val_reg);
+	vc_bypass_value = voltdm->read(vc_bypass_val_reg);
 	/*
 	 * Loop till the bypass command is acknowledged from the SMPS.
 	 * NOTE: This is legacy code. The loop count and retry count needs
@@ -143,8 +140,7 @@ int omap_vc_bypass_scale(struct voltagedomain *voltdm,
 			loop_cnt = 0;
 			udelay(10);
 		}
-		vc_bypass_value = vdd->read_reg(vc->common->prm_mod,
-						vc_bypass_val_reg);
+		vc_bypass_value = voltdm->read(vc_bypass_val_reg);
 	}
 
 	omap_vc_post_scale(voltdm, target_volt, target_vsel, current_vsel);
@@ -153,18 +149,13 @@ int omap_vc_bypass_scale(struct voltagedomain *voltdm,
 
 static void __init omap3_vfsm_init(struct voltagedomain *voltdm)
 {
-	struct omap_vc_channel *vc = voltdm->vc;
-	struct omap_vdd_info *vdd = voltdm->vdd;
-
 	/*
 	 * Voltage Manager FSM parameters init
 	 * XXX This data should be passed in from the board file
 	 */
-	vdd->write_reg(OMAP3_CLKSETUP, vc->common->prm_mod, OMAP3_PRM_CLKSETUP_OFFSET);
-	vdd->write_reg(OMAP3_VOLTOFFSET, vc->common->prm_mod,
-		       OMAP3_PRM_VOLTOFFSET_OFFSET);
-	vdd->write_reg(OMAP3_VOLTSETUP2, vc->common->prm_mod,
-		       OMAP3_PRM_VOLTSETUP2_OFFSET);
+	voltdm->write(OMAP3_CLKSETUP, OMAP3_PRM_CLKSETUP_OFFSET);
+	voltdm->write(OMAP3_VOLTOFFSET, OMAP3_PRM_VOLTOFFSET_OFFSET);
+	voltdm->write(OMAP3_VOLTSETUP2, OMAP3_PRM_VOLTSETUP2_OFFSET);
 }
 
 static void __init omap3_vc_init_channel(struct voltagedomain *voltdm)
@@ -187,16 +178,16 @@ static void __init omap3_vc_init_channel(struct voltagedomain *voltdm)
 		(onlp_vsel << vc->common->cmd_onlp_shift) |
 		(ret_vsel << vc->common->cmd_ret_shift) |
 		(off_vsel << vc->common->cmd_off_shift));
-	vdd->write_reg(vc_val, vc->common->prm_mod, vc->cmdval_reg);
+	voltdm->write(vc_val, vc->cmdval_reg);
 
 	/*
 	 * Generic VC parameters init
 	 * XXX This data should be abstracted out
 	 */
-	vdd->write_reg(OMAP3430_CMD1_MASK | OMAP3430_RAV1_MASK, vc->common->prm_mod,
-			OMAP3_PRM_VC_CH_CONF_OFFSET);
-	vdd->write_reg(OMAP3430_MCODE_SHIFT | OMAP3430_HSEN_MASK, vc->common->prm_mod,
-			OMAP3_PRM_VC_I2C_CFG_OFFSET);
+	voltdm->write(OMAP3430_CMD1_MASK | OMAP3430_RAV1_MASK,
+		       OMAP3_PRM_VC_CH_CONF_OFFSET);
+	voltdm->write(OMAP3430_MCODE_SHIFT | OMAP3430_HSEN_MASK,
+		       OMAP3_PRM_VC_I2C_CFG_OFFSET);
 
 	omap3_vfsm_init(voltdm);
 
@@ -207,8 +198,6 @@ static void __init omap3_vc_init_channel(struct voltagedomain *voltdm)
 /* OMAP4 specific voltage init functions */
 static void __init omap4_vc_init_channel(struct voltagedomain *voltdm)
 {
-	struct omap_vc_channel *vc = voltdm->vc;
-	struct omap_vdd_info *vdd = voltdm->vdd;
 	static bool is_initialized;
 	u32 vc_val;
 
@@ -224,11 +213,11 @@ static void __init omap4_vc_init_channel(struct voltagedomain *voltdm)
 	vc_val = (OMAP4430_RAV_VDD_MPU_L_MASK | OMAP4430_CMD_VDD_MPU_L_MASK |
 		  OMAP4430_RAV_VDD_IVA_L_MASK | OMAP4430_CMD_VDD_IVA_L_MASK |
 		  OMAP4430_RAV_VDD_CORE_L_MASK | OMAP4430_CMD_VDD_CORE_L_MASK);
-	vdd->write_reg(vc_val, vc->common->prm_mod, OMAP4_PRM_VC_CFG_CHANNEL_OFFSET);
+	voltdm->write(vc_val, OMAP4_PRM_VC_CFG_CHANNEL_OFFSET);
 
 	/* XXX These are magic numbers and do not belong! */
 	vc_val = (0x60 << OMAP4430_SCLL_SHIFT | 0x26 << OMAP4430_SCLH_SHIFT);
-	vdd->write_reg(vc_val, vc->common->prm_mod, OMAP4_PRM_VC_CFG_I2C_CLK_OFFSET);
+	voltdm->write(vc_val, OMAP4_PRM_VC_CFG_I2C_CLK_OFFSET);
 
 	is_initialized = true;
 }
@@ -246,34 +235,30 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 		return;
 	}
 
-	if (!vdd->read_reg || !vdd->write_reg) {
+	if (!voltdm->read || !voltdm->write) {
 		pr_err("%s: No read/write API for accessing vdd_%s regs\n",
 			__func__, voltdm->name);
 		return;
 	}
 
 	/* Set up the SMPS_SA(i2c slave address in VC */
-	vc_val = vdd->read_reg(vc->common->prm_mod,
-			       vc->common->smps_sa_reg);
+	vc_val = voltdm->read(vc->common->smps_sa_reg);
 	vc_val &= ~vc->smps_sa_mask;
 	vc_val |= vdd->pmic_info->i2c_slave_addr << vc->smps_sa_shift;
-	vdd->write_reg(vc_val, vc->common->prm_mod,
-		       vc->common->smps_sa_reg);
+	voltdm->write(vc_val, vc->common->smps_sa_reg);
 
 	/* Setup the VOLRA(pmic reg addr) in VC */
-	vc_val = vdd->read_reg(vc->common->prm_mod,
-			       vc->common->smps_volra_reg);
+	vc_val = voltdm->read(vc->common->smps_volra_reg);
 	vc_val &= ~vc->smps_volra_mask;
 	vc_val |= vdd->pmic_info->volt_reg_addr << vc->smps_volra_shift;
-	vdd->write_reg(vc_val, vc->common->prm_mod,
-		       vc->common->smps_volra_reg);
+	voltdm->write(vc_val, vc->common->smps_volra_reg);
 
 	/* Configure the setup times */
-	vc_val = vdd->read_reg(vc->common->prm_mod, vdd->vfsm->voltsetup_reg);
+	vc_val = voltdm->read(vdd->vfsm->voltsetup_reg);
 	vc_val &= ~vdd->vfsm->voltsetup_mask;
 	vc_val |= vdd->pmic_info->volt_setup_time <<
 			vdd->vfsm->voltsetup_shift;
-	vdd->write_reg(vc_val, vc->common->prm_mod, vdd->vfsm->voltsetup_reg);
+	voltdm->write(vc_val, vdd->vfsm->voltsetup_reg);
 
 	if (cpu_is_omap34xx())
 		omap3_vc_init_channel(voltdm);

commit e74e44054f8297d60fbd2ed1d412d84055afee8c
Author: Kevin Hilman <khilman@ti.com>
Date:   Tue Mar 22 14:12:37 2011 -0700

    OMAP2+: VC: support PMICs with separate voltage and command registers
    
    The VC layer can support PMICs with separate voltage and command
    registers by putting the different registers in the PRM_VC_SMPS_VOL_RA
    and PRCM_VC_SMPS_CMD_RA registers respectively.
    
    The PMIC data must supply at least a voltage register address
    (volt_reg_addr).  The command register address (cmd_reg_addr) is
    optional.  If the PMIC data does not supply a separate command
    register address, the VC will use the voltage register address for both.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index b62363d9d2b7..1bdbe7c15612 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -115,7 +115,7 @@ int omap_vc_bypass_scale(struct voltagedomain *voltdm,
 	vc_valid = vc->common->valid;
 	vc_bypass_val_reg = vc->common->bypass_val_reg;
 	vc_bypass_value = (target_vsel << vc->common->data_shift) |
-			(vdd->pmic_info->pmic_reg <<
+			(vdd->pmic_info->volt_reg_addr <<
 			vc->common->regaddr_shift) |
 			(vdd->pmic_info->i2c_slave_addr <<
 			vc->common->slaveaddr_shift);
@@ -264,7 +264,7 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 	vc_val = vdd->read_reg(vc->common->prm_mod,
 			       vc->common->smps_volra_reg);
 	vc_val &= ~vc->smps_volra_mask;
-	vc_val |= vdd->pmic_info->pmic_reg << vc->smps_volra_shift;
+	vc_val |= vdd->pmic_info->volt_reg_addr << vc->smps_volra_shift;
 	vdd->write_reg(vc_val, vc->common->prm_mod,
 		       vc->common->smps_volra_reg);
 

commit d84adcf46b9c235d1f4975b72a8c2763dbfb0081
Author: Kevin Hilman <khilman@ti.com>
Date:   Tue Mar 22 16:14:57 2011 -0700

    OMAP2+: voltage: move VC into struct voltagedomain, misc. renames
    
    Move the VC instance struct from omap_vdd_info into struct voltagedomain.
    While moving, perform some misc. renames for readability.
    
    No functional changes.
    
    Summary of renames:
    - rename omap_vc_instance to omap_vc_channel, since there is only
      one instance of the VC IP and this actually represents channels
      using TRM terminology.
    - rename 'vc_common' field of VC channel which led to:
      s/vc->vc_common/vc->common/
    - remove redundant '_data' suffix
    - OMAP3: vc1 --> vc_mpu, vc2 --> vc_core
    - omap_vc_bypass_scale_voltage() -> omap_vc_bypass_scale()
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>
    
    merge

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
index 098af2f3a63e..b62363d9d2b7 100644
--- a/arch/arm/mach-omap2/vc.c
+++ b/arch/arm/mach-omap2/vc.c
@@ -24,14 +24,12 @@ int omap_vc_pre_scale(struct voltagedomain *voltdm,
 		      unsigned long target_volt,
 		      u8 *target_vsel, u8 *current_vsel)
 {
-	struct omap_vc_instance_data *vc = voltdm->vdd->vc_data;
+	struct omap_vc_channel *vc = voltdm->vc;
 	struct omap_vdd_info *vdd = voltdm->vdd;
 	struct omap_volt_data *volt_data;
-	const struct omap_vc_common_data *vc_common;
 	const struct omap_vp_common_data *vp_common;
 	u32 vc_cmdval, vp_errgain_val;
 
-	vc_common = vc->vc_common;
 	vp_common = vdd->vp_data->vp_common;
 
 	/* Check if sufficient pmic info is available for this vdd */
@@ -63,10 +61,10 @@ int omap_vc_pre_scale(struct voltagedomain *voltdm,
 	*current_vsel = vdd->read_reg(vdd->vp_data->vp_common->prm_mod, vdd->vp_data->voltage);
 
 	/* Setting the ON voltage to the new target voltage */
-	vc_cmdval = vdd->read_reg(vc->vc_common->prm_mod, vc->cmdval_reg);
-	vc_cmdval &= ~vc_common->cmd_on_mask;
-	vc_cmdval |= (*target_vsel << vc_common->cmd_on_shift);
-	vdd->write_reg(vc_cmdval, vc->vc_common->prm_mod, vc->cmdval_reg);
+	vc_cmdval = vdd->read_reg(vc->common->prm_mod, vc->cmdval_reg);
+	vc_cmdval &= ~vc->common->cmd_on_mask;
+	vc_cmdval |= (*target_vsel << vc->common->cmd_on_shift);
+	vdd->write_reg(vc_cmdval, vc->common->prm_mod, vc->cmdval_reg);
 
 	/* Setting vp errorgain based on the voltage */
 	if (volt_data) {
@@ -99,11 +97,11 @@ void omap_vc_post_scale(struct voltagedomain *voltdm,
 	vdd->curr_volt = target_volt;
 }
 
-/* vc_bypass_scale_voltage - VC bypass method of voltage scaling */
-int omap_vc_bypass_scale_voltage(struct voltagedomain *voltdm,
-				 unsigned long target_volt)
+/* vc_bypass_scale - VC bypass method of voltage scaling */
+int omap_vc_bypass_scale(struct voltagedomain *voltdm,
+			 unsigned long target_volt)
 {
-	struct omap_vc_instance_data *vc = voltdm->vdd->vc_data;
+	struct omap_vc_channel *vc = voltdm->vc;
 	struct omap_vdd_info *vdd = voltdm->vdd;
 	u32 loop_cnt = 0, retries_cnt = 0;
 	u32 vc_valid, vc_bypass_val_reg, vc_bypass_value;
@@ -114,19 +112,19 @@ int omap_vc_bypass_scale_voltage(struct voltagedomain *voltdm,
 	if (ret)
 		return ret;
 
-	vc_valid = vc->vc_common->valid;
-	vc_bypass_val_reg = vc->vc_common->bypass_val_reg;
-	vc_bypass_value = (target_vsel << vc->vc_common->data_shift) |
+	vc_valid = vc->common->valid;
+	vc_bypass_val_reg = vc->common->bypass_val_reg;
+	vc_bypass_value = (target_vsel << vc->common->data_shift) |
 			(vdd->pmic_info->pmic_reg <<
-			vc->vc_common->regaddr_shift) |
+			vc->common->regaddr_shift) |
 			(vdd->pmic_info->i2c_slave_addr <<
-			vc->vc_common->slaveaddr_shift);
+			vc->common->slaveaddr_shift);
 
-	vdd->write_reg(vc_bypass_value, vc->vc_common->prm_mod, vc_bypass_val_reg);
-	vdd->write_reg(vc_bypass_value | vc_valid, vc->vc_common->prm_mod,
+	vdd->write_reg(vc_bypass_value, vc->common->prm_mod, vc_bypass_val_reg);
+	vdd->write_reg(vc_bypass_value | vc_valid, vc->common->prm_mod,
 		       vc_bypass_val_reg);
 
-	vc_bypass_value = vdd->read_reg(vc->vc_common->prm_mod, vc_bypass_val_reg);
+	vc_bypass_value = vdd->read_reg(vc->common->prm_mod, vc_bypass_val_reg);
 	/*
 	 * Loop till the bypass command is acknowledged from the SMPS.
 	 * NOTE: This is legacy code. The loop count and retry count needs
@@ -145,7 +143,7 @@ int omap_vc_bypass_scale_voltage(struct voltagedomain *voltdm,
 			loop_cnt = 0;
 			udelay(10);
 		}
-		vc_bypass_value = vdd->read_reg(vc->vc_common->prm_mod,
+		vc_bypass_value = vdd->read_reg(vc->common->prm_mod,
 						vc_bypass_val_reg);
 	}
 
@@ -155,23 +153,23 @@ int omap_vc_bypass_scale_voltage(struct voltagedomain *voltdm,
 
 static void __init omap3_vfsm_init(struct voltagedomain *voltdm)
 {
-	struct omap_vc_instance_data *vc = voltdm->vdd->vc_data;
+	struct omap_vc_channel *vc = voltdm->vc;
 	struct omap_vdd_info *vdd = voltdm->vdd;
 
 	/*
 	 * Voltage Manager FSM parameters init
 	 * XXX This data should be passed in from the board file
 	 */
-	vdd->write_reg(OMAP3_CLKSETUP, vc->vc_common->prm_mod, OMAP3_PRM_CLKSETUP_OFFSET);
-	vdd->write_reg(OMAP3_VOLTOFFSET, vc->vc_common->prm_mod,
+	vdd->write_reg(OMAP3_CLKSETUP, vc->common->prm_mod, OMAP3_PRM_CLKSETUP_OFFSET);
+	vdd->write_reg(OMAP3_VOLTOFFSET, vc->common->prm_mod,
 		       OMAP3_PRM_VOLTOFFSET_OFFSET);
-	vdd->write_reg(OMAP3_VOLTSETUP2, vc->vc_common->prm_mod,
+	vdd->write_reg(OMAP3_VOLTSETUP2, vc->common->prm_mod,
 		       OMAP3_PRM_VOLTSETUP2_OFFSET);
 }
 
 static void __init omap3_vc_init_channel(struct voltagedomain *voltdm)
 {
-	struct omap_vc_instance_data *vc = voltdm->vdd->vc_data;
+	struct omap_vc_channel *vc = voltdm->vc;
 	struct omap_vdd_info *vdd = voltdm->vdd;
 	static bool is_initialized;
 	u8 on_vsel, onlp_vsel, ret_vsel, off_vsel;
@@ -185,19 +183,19 @@ static void __init omap3_vc_init_channel(struct voltagedomain *voltdm)
 	onlp_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->onlp_volt);
 	ret_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->ret_volt);
 	off_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->off_volt);
-	vc_val	= ((on_vsel << vc->vc_common->cmd_on_shift) |
-		(onlp_vsel << vc->vc_common->cmd_onlp_shift) |
-		(ret_vsel << vc->vc_common->cmd_ret_shift) |
-		(off_vsel << vc->vc_common->cmd_off_shift));
-	vdd->write_reg(vc_val, vc->vc_common->prm_mod, vc->cmdval_reg);
+	vc_val	= ((on_vsel << vc->common->cmd_on_shift) |
+		(onlp_vsel << vc->common->cmd_onlp_shift) |
+		(ret_vsel << vc->common->cmd_ret_shift) |
+		(off_vsel << vc->common->cmd_off_shift));
+	vdd->write_reg(vc_val, vc->common->prm_mod, vc->cmdval_reg);
 
 	/*
 	 * Generic VC parameters init
 	 * XXX This data should be abstracted out
 	 */
-	vdd->write_reg(OMAP3430_CMD1_MASK | OMAP3430_RAV1_MASK, vc->vc_common->prm_mod,
+	vdd->write_reg(OMAP3430_CMD1_MASK | OMAP3430_RAV1_MASK, vc->common->prm_mod,
 			OMAP3_PRM_VC_CH_CONF_OFFSET);
-	vdd->write_reg(OMAP3430_MCODE_SHIFT | OMAP3430_HSEN_MASK, vc->vc_common->prm_mod,
+	vdd->write_reg(OMAP3430_MCODE_SHIFT | OMAP3430_HSEN_MASK, vc->common->prm_mod,
 			OMAP3_PRM_VC_I2C_CFG_OFFSET);
 
 	omap3_vfsm_init(voltdm);
@@ -209,7 +207,7 @@ static void __init omap3_vc_init_channel(struct voltagedomain *voltdm)
 /* OMAP4 specific voltage init functions */
 static void __init omap4_vc_init_channel(struct voltagedomain *voltdm)
 {
-	struct omap_vc_instance_data *vc = voltdm->vdd->vc_data;
+	struct omap_vc_channel *vc = voltdm->vc;
 	struct omap_vdd_info *vdd = voltdm->vdd;
 	static bool is_initialized;
 	u32 vc_val;
@@ -226,18 +224,18 @@ static void __init omap4_vc_init_channel(struct voltagedomain *voltdm)
 	vc_val = (OMAP4430_RAV_VDD_MPU_L_MASK | OMAP4430_CMD_VDD_MPU_L_MASK |
 		  OMAP4430_RAV_VDD_IVA_L_MASK | OMAP4430_CMD_VDD_IVA_L_MASK |
 		  OMAP4430_RAV_VDD_CORE_L_MASK | OMAP4430_CMD_VDD_CORE_L_MASK);
-	vdd->write_reg(vc_val, vc->vc_common->prm_mod, OMAP4_PRM_VC_CFG_CHANNEL_OFFSET);
+	vdd->write_reg(vc_val, vc->common->prm_mod, OMAP4_PRM_VC_CFG_CHANNEL_OFFSET);
 
 	/* XXX These are magic numbers and do not belong! */
 	vc_val = (0x60 << OMAP4430_SCLL_SHIFT | 0x26 << OMAP4430_SCLH_SHIFT);
-	vdd->write_reg(vc_val, vc->vc_common->prm_mod, OMAP4_PRM_VC_CFG_I2C_CLK_OFFSET);
+	vdd->write_reg(vc_val, vc->common->prm_mod, OMAP4_PRM_VC_CFG_I2C_CLK_OFFSET);
 
 	is_initialized = true;
 }
 
 void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 {
-	struct omap_vc_instance_data *vc = voltdm->vdd->vc_data;
+	struct omap_vc_channel *vc = voltdm->vc;
 	struct omap_vdd_info *vdd = voltdm->vdd;
 	u32 vc_val;
 
@@ -255,27 +253,27 @@ void __init omap_vc_init_channel(struct voltagedomain *voltdm)
 	}
 
 	/* Set up the SMPS_SA(i2c slave address in VC */
-	vc_val = vdd->read_reg(vc->vc_common->prm_mod,
-			       vc->vc_common->smps_sa_reg);
+	vc_val = vdd->read_reg(vc->common->prm_mod,
+			       vc->common->smps_sa_reg);
 	vc_val &= ~vc->smps_sa_mask;
 	vc_val |= vdd->pmic_info->i2c_slave_addr << vc->smps_sa_shift;
-	vdd->write_reg(vc_val, vc->vc_common->prm_mod,
-		       vc->vc_common->smps_sa_reg);
+	vdd->write_reg(vc_val, vc->common->prm_mod,
+		       vc->common->smps_sa_reg);
 
 	/* Setup the VOLRA(pmic reg addr) in VC */
-	vc_val = vdd->read_reg(vc->vc_common->prm_mod,
-			       vc->vc_common->smps_volra_reg);
+	vc_val = vdd->read_reg(vc->common->prm_mod,
+			       vc->common->smps_volra_reg);
 	vc_val &= ~vc->smps_volra_mask;
 	vc_val |= vdd->pmic_info->pmic_reg << vc->smps_volra_shift;
-	vdd->write_reg(vc_val, vc->vc_common->prm_mod,
-		       vc->vc_common->smps_volra_reg);
+	vdd->write_reg(vc_val, vc->common->prm_mod,
+		       vc->common->smps_volra_reg);
 
 	/* Configure the setup times */
-	vc_val = vdd->read_reg(vc->vc_common->prm_mod, vdd->vfsm->voltsetup_reg);
+	vc_val = vdd->read_reg(vc->common->prm_mod, vdd->vfsm->voltsetup_reg);
 	vc_val &= ~vdd->vfsm->voltsetup_mask;
 	vc_val |= vdd->pmic_info->volt_setup_time <<
 			vdd->vfsm->voltsetup_shift;
-	vdd->write_reg(vc_val, vc->vc_common->prm_mod, vdd->vfsm->voltsetup_reg);
+	vdd->write_reg(vc_val, vc->common->prm_mod, vdd->vfsm->voltsetup_reg);
 
 	if (cpu_is_omap34xx())
 		omap3_vc_init_channel(voltdm);

commit ccd5ca7787df8f1bd267b90f03a09c31c160ffe2
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Mar 21 14:08:55 2011 -0700

    OMAP2+: voltage: split voltage controller (VC) code into dedicated layer
    
    As part of the voltage layer cleanup, split out VC specific code into
    a dedicated VC layer.  This patch primarily just moves VC code from
    voltage.c into vc.c, and adds prototypes to vc.h.
    
    No functional changes.
    
    For readability, each function was given a local 'vc' pointer:
    
        struct omap_vc_instance_data *vc = voltdm->vdd->vc_data;
    
    and a global replace of s/vdd->vc_data/vc/ was done.
    
    Also vc_init was renamed to vc_init_channel to reflect that this is
    per-VC channel initializtion.
    
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c
new file mode 100644
index 000000000000..098af2f3a63e
--- /dev/null
+++ b/arch/arm/mach-omap2/vc.c
@@ -0,0 +1,285 @@
+/*
+ * OMAP Voltage Controller (VC) interface
+ *
+ * Copyright (C) 2011 Texas Instruments, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+
+#include <plat/cpu.h>
+
+#include "voltage.h"
+#include "vc.h"
+#include "prm-regbits-34xx.h"
+#include "prm-regbits-44xx.h"
+#include "prm44xx.h"
+
+/* Voltage scale and accessory APIs */
+int omap_vc_pre_scale(struct voltagedomain *voltdm,
+		      unsigned long target_volt,
+		      u8 *target_vsel, u8 *current_vsel)
+{
+	struct omap_vc_instance_data *vc = voltdm->vdd->vc_data;
+	struct omap_vdd_info *vdd = voltdm->vdd;
+	struct omap_volt_data *volt_data;
+	const struct omap_vc_common_data *vc_common;
+	const struct omap_vp_common_data *vp_common;
+	u32 vc_cmdval, vp_errgain_val;
+
+	vc_common = vc->vc_common;
+	vp_common = vdd->vp_data->vp_common;
+
+	/* Check if sufficient pmic info is available for this vdd */
+	if (!vdd->pmic_info) {
+		pr_err("%s: Insufficient pmic info to scale the vdd_%s\n",
+			__func__, voltdm->name);
+		return -EINVAL;
+	}
+
+	if (!vdd->pmic_info->uv_to_vsel) {
+		pr_err("%s: PMIC function to convert voltage in uV to"
+			"vsel not registered. Hence unable to scale voltage"
+			"for vdd_%s\n", __func__, voltdm->name);
+		return -ENODATA;
+	}
+
+	if (!vdd->read_reg || !vdd->write_reg) {
+		pr_err("%s: No read/write API for accessing vdd_%s regs\n",
+			__func__, voltdm->name);
+		return -EINVAL;
+	}
+
+	/* Get volt_data corresponding to target_volt */
+	volt_data = omap_voltage_get_voltdata(voltdm, target_volt);
+	if (IS_ERR(volt_data))
+		volt_data = NULL;
+
+	*target_vsel = vdd->pmic_info->uv_to_vsel(target_volt);
+	*current_vsel = vdd->read_reg(vdd->vp_data->vp_common->prm_mod, vdd->vp_data->voltage);
+
+	/* Setting the ON voltage to the new target voltage */
+	vc_cmdval = vdd->read_reg(vc->vc_common->prm_mod, vc->cmdval_reg);
+	vc_cmdval &= ~vc_common->cmd_on_mask;
+	vc_cmdval |= (*target_vsel << vc_common->cmd_on_shift);
+	vdd->write_reg(vc_cmdval, vc->vc_common->prm_mod, vc->cmdval_reg);
+
+	/* Setting vp errorgain based on the voltage */
+	if (volt_data) {
+		vp_errgain_val = vdd->read_reg(vdd->vp_data->vp_common->prm_mod,
+					       vdd->vp_data->vpconfig);
+		vdd->vp_rt_data.vpconfig_errorgain = volt_data->vp_errgain;
+		vp_errgain_val &= ~vp_common->vpconfig_errorgain_mask;
+		vp_errgain_val |= vdd->vp_rt_data.vpconfig_errorgain <<
+			vp_common->vpconfig_errorgain_shift;
+		vdd->write_reg(vp_errgain_val, vdd->vp_data->vp_common->prm_mod,
+			       vdd->vp_data->vpconfig);
+	}
+
+	return 0;
+}
+
+void omap_vc_post_scale(struct voltagedomain *voltdm,
+			unsigned long target_volt,
+			u8 target_vsel, u8 current_vsel)
+{
+	struct omap_vdd_info *vdd = voltdm->vdd;
+	u32 smps_steps = 0, smps_delay = 0;
+
+	smps_steps = abs(target_vsel - current_vsel);
+	/* SMPS slew rate / step size. 2us added as buffer. */
+	smps_delay = ((smps_steps * vdd->pmic_info->step_size) /
+			vdd->pmic_info->slew_rate) + 2;
+	udelay(smps_delay);
+
+	vdd->curr_volt = target_volt;
+}
+
+/* vc_bypass_scale_voltage - VC bypass method of voltage scaling */
+int omap_vc_bypass_scale_voltage(struct voltagedomain *voltdm,
+				 unsigned long target_volt)
+{
+	struct omap_vc_instance_data *vc = voltdm->vdd->vc_data;
+	struct omap_vdd_info *vdd = voltdm->vdd;
+	u32 loop_cnt = 0, retries_cnt = 0;
+	u32 vc_valid, vc_bypass_val_reg, vc_bypass_value;
+	u8 target_vsel, current_vsel;
+	int ret;
+
+	ret = omap_vc_pre_scale(voltdm, target_volt, &target_vsel, &current_vsel);
+	if (ret)
+		return ret;
+
+	vc_valid = vc->vc_common->valid;
+	vc_bypass_val_reg = vc->vc_common->bypass_val_reg;
+	vc_bypass_value = (target_vsel << vc->vc_common->data_shift) |
+			(vdd->pmic_info->pmic_reg <<
+			vc->vc_common->regaddr_shift) |
+			(vdd->pmic_info->i2c_slave_addr <<
+			vc->vc_common->slaveaddr_shift);
+
+	vdd->write_reg(vc_bypass_value, vc->vc_common->prm_mod, vc_bypass_val_reg);
+	vdd->write_reg(vc_bypass_value | vc_valid, vc->vc_common->prm_mod,
+		       vc_bypass_val_reg);
+
+	vc_bypass_value = vdd->read_reg(vc->vc_common->prm_mod, vc_bypass_val_reg);
+	/*
+	 * Loop till the bypass command is acknowledged from the SMPS.
+	 * NOTE: This is legacy code. The loop count and retry count needs
+	 * to be revisited.
+	 */
+	while (!(vc_bypass_value & vc_valid)) {
+		loop_cnt++;
+
+		if (retries_cnt > 10) {
+			pr_warning("%s: Retry count exceeded\n", __func__);
+			return -ETIMEDOUT;
+		}
+
+		if (loop_cnt > 50) {
+			retries_cnt++;
+			loop_cnt = 0;
+			udelay(10);
+		}
+		vc_bypass_value = vdd->read_reg(vc->vc_common->prm_mod,
+						vc_bypass_val_reg);
+	}
+
+	omap_vc_post_scale(voltdm, target_volt, target_vsel, current_vsel);
+	return 0;
+}
+
+static void __init omap3_vfsm_init(struct voltagedomain *voltdm)
+{
+	struct omap_vc_instance_data *vc = voltdm->vdd->vc_data;
+	struct omap_vdd_info *vdd = voltdm->vdd;
+
+	/*
+	 * Voltage Manager FSM parameters init
+	 * XXX This data should be passed in from the board file
+	 */
+	vdd->write_reg(OMAP3_CLKSETUP, vc->vc_common->prm_mod, OMAP3_PRM_CLKSETUP_OFFSET);
+	vdd->write_reg(OMAP3_VOLTOFFSET, vc->vc_common->prm_mod,
+		       OMAP3_PRM_VOLTOFFSET_OFFSET);
+	vdd->write_reg(OMAP3_VOLTSETUP2, vc->vc_common->prm_mod,
+		       OMAP3_PRM_VOLTSETUP2_OFFSET);
+}
+
+static void __init omap3_vc_init_channel(struct voltagedomain *voltdm)
+{
+	struct omap_vc_instance_data *vc = voltdm->vdd->vc_data;
+	struct omap_vdd_info *vdd = voltdm->vdd;
+	static bool is_initialized;
+	u8 on_vsel, onlp_vsel, ret_vsel, off_vsel;
+	u32 vc_val;
+
+	if (is_initialized)
+		return;
+
+	/* Set up the on, inactive, retention and off voltage */
+	on_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->on_volt);
+	onlp_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->onlp_volt);
+	ret_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->ret_volt);
+	off_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->off_volt);
+	vc_val	= ((on_vsel << vc->vc_common->cmd_on_shift) |
+		(onlp_vsel << vc->vc_common->cmd_onlp_shift) |
+		(ret_vsel << vc->vc_common->cmd_ret_shift) |
+		(off_vsel << vc->vc_common->cmd_off_shift));
+	vdd->write_reg(vc_val, vc->vc_common->prm_mod, vc->cmdval_reg);
+
+	/*
+	 * Generic VC parameters init
+	 * XXX This data should be abstracted out
+	 */
+	vdd->write_reg(OMAP3430_CMD1_MASK | OMAP3430_RAV1_MASK, vc->vc_common->prm_mod,
+			OMAP3_PRM_VC_CH_CONF_OFFSET);
+	vdd->write_reg(OMAP3430_MCODE_SHIFT | OMAP3430_HSEN_MASK, vc->vc_common->prm_mod,
+			OMAP3_PRM_VC_I2C_CFG_OFFSET);
+
+	omap3_vfsm_init(voltdm);
+
+	is_initialized = true;
+}
+
+
+/* OMAP4 specific voltage init functions */
+static void __init omap4_vc_init_channel(struct voltagedomain *voltdm)
+{
+	struct omap_vc_instance_data *vc = voltdm->vdd->vc_data;
+	struct omap_vdd_info *vdd = voltdm->vdd;
+	static bool is_initialized;
+	u32 vc_val;
+
+	if (is_initialized)
+		return;
+
+	/* TODO: Configure setup times and CMD_VAL values*/
+
+	/*
+	 * Generic VC parameters init
+	 * XXX This data should be abstracted out
+	 */
+	vc_val = (OMAP4430_RAV_VDD_MPU_L_MASK | OMAP4430_CMD_VDD_MPU_L_MASK |
+		  OMAP4430_RAV_VDD_IVA_L_MASK | OMAP4430_CMD_VDD_IVA_L_MASK |
+		  OMAP4430_RAV_VDD_CORE_L_MASK | OMAP4430_CMD_VDD_CORE_L_MASK);
+	vdd->write_reg(vc_val, vc->vc_common->prm_mod, OMAP4_PRM_VC_CFG_CHANNEL_OFFSET);
+
+	/* XXX These are magic numbers and do not belong! */
+	vc_val = (0x60 << OMAP4430_SCLL_SHIFT | 0x26 << OMAP4430_SCLH_SHIFT);
+	vdd->write_reg(vc_val, vc->vc_common->prm_mod, OMAP4_PRM_VC_CFG_I2C_CLK_OFFSET);
+
+	is_initialized = true;
+}
+
+void __init omap_vc_init_channel(struct voltagedomain *voltdm)
+{
+	struct omap_vc_instance_data *vc = voltdm->vdd->vc_data;
+	struct omap_vdd_info *vdd = voltdm->vdd;
+	u32 vc_val;
+
+	if (!vdd->pmic_info || !vdd->pmic_info->uv_to_vsel) {
+		pr_err("%s: PMIC info requried to configure vc for"
+			"vdd_%s not populated.Hence cannot initialize vc\n",
+			__func__, voltdm->name);
+		return;
+	}
+
+	if (!vdd->read_reg || !vdd->write_reg) {
+		pr_err("%s: No read/write API for accessing vdd_%s regs\n",
+			__func__, voltdm->name);
+		return;
+	}
+
+	/* Set up the SMPS_SA(i2c slave address in VC */
+	vc_val = vdd->read_reg(vc->vc_common->prm_mod,
+			       vc->vc_common->smps_sa_reg);
+	vc_val &= ~vc->smps_sa_mask;
+	vc_val |= vdd->pmic_info->i2c_slave_addr << vc->smps_sa_shift;
+	vdd->write_reg(vc_val, vc->vc_common->prm_mod,
+		       vc->vc_common->smps_sa_reg);
+
+	/* Setup the VOLRA(pmic reg addr) in VC */
+	vc_val = vdd->read_reg(vc->vc_common->prm_mod,
+			       vc->vc_common->smps_volra_reg);
+	vc_val &= ~vc->smps_volra_mask;
+	vc_val |= vdd->pmic_info->pmic_reg << vc->smps_volra_shift;
+	vdd->write_reg(vc_val, vc->vc_common->prm_mod,
+		       vc->vc_common->smps_volra_reg);
+
+	/* Configure the setup times */
+	vc_val = vdd->read_reg(vc->vc_common->prm_mod, vdd->vfsm->voltsetup_reg);
+	vc_val &= ~vdd->vfsm->voltsetup_mask;
+	vc_val |= vdd->pmic_info->volt_setup_time <<
+			vdd->vfsm->voltsetup_shift;
+	vdd->write_reg(vc_val, vc->vc_common->prm_mod, vdd->vfsm->voltsetup_reg);
+
+	if (cpu_is_omap34xx())
+		omap3_vc_init_channel(voltdm);
+	else if (cpu_is_omap44xx())
+		omap4_vc_init_channel(voltdm);
+}
+
