commit 55be2f50336f67800513b46c5ba6270e4ed0e784
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Mar 4 14:54:30 2020 -0800

    ARM: OMAP2+: Handle errors for cpu_pm
    
    We need to check for errors when calling cpu_pm_enter() and
    cpu_cluster_pm_enter(). And we need to bail out on errors as
    otherwise we can enter a deeper idle state when not desired.
    
    I'm not aware of the lack of error handling causing issues yet,
    but we need this at least for blocking deeper idle states when
    a GPIO instance has pending interrupts.
    
    Cc: Dave Gerlach <d-gerlach@ti.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Keerthy <j-keerthy@ti.com>
    Cc: Ladislav Michl <ladis@linux-mips.org>
    Cc: Russell King <rmk+kernel@armlinux.org.uk>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Link: https://lore.kernel.org/r/20200304225433.37336-2-tony@atomide.com
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index e66e9948636c..6df395fff971 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -191,6 +191,7 @@ void omap_sram_idle(void)
 	int per_next_state = PWRDM_POWER_ON;
 	int core_next_state = PWRDM_POWER_ON;
 	u32 sdrc_pwr = 0;
+	int error;
 
 	mpu_next_state = pwrdm_read_next_pwrst(mpu_pwrdm);
 	switch (mpu_next_state) {
@@ -219,8 +220,11 @@ void omap_sram_idle(void)
 	pwrdm_pre_transition(NULL);
 
 	/* PER */
-	if (per_next_state == PWRDM_POWER_OFF)
-		cpu_cluster_pm_enter();
+	if (per_next_state == PWRDM_POWER_OFF) {
+		error = cpu_cluster_pm_enter();
+		if (error)
+			return;
+	}
 
 	/* CORE */
 	if (core_next_state < PWRDM_POWER_ON) {

commit 4c74ecf79227228f31d05d6d4766ccb5f8607b83
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Dec 16 14:41:53 2019 -0800

    dmaengine: ti: omap-dma: Add device tree match data and use it for cpu_pm
    
    With old DMA code disabled for handling DMA requests for device tree based
    SoCs, we can move omap3 specific context save and restore to the dmaengine
    driver.
    
    Let's do this by adding cpu_pm notifier handling to save and restore context,
    and enable it based on device tree match data. This way we can use the match
    data later to configure more SoC specific features later on too.
    
    Note that we only clear the channels in use while the platform code also
    clears reserved channels 0 and 1 on high-security SoCs. Based on testing
    on n900, this is not needed though and the system idles just fine.
    
    With the dmaengine driver handling context save and restore, we must now
    remove the old custom calls for context save and restore.
    
    Cc: Aaro Koskinen <aaro.koskinen@iki.fi>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Russell King <rmk+kernel@armlinux.org.uk>
    Cc: Vinod Koul <vkoul@kernel.org>
    Acked-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Tested-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 54254fc92c2e..e66e9948636c 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -25,7 +25,6 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
-#include <linux/omap-dma.h>
 #include <linux/omap-gpmc.h>
 
 #include <trace/events/power.h>
@@ -85,7 +84,6 @@ static void omap3_core_save_context(void)
 	omap3_gpmc_save_context();
 	/* Save the system control module context, padconf already save above*/
 	omap3_control_save_context();
-	omap_dma_global_context_save();
 }
 
 static void omap3_core_restore_context(void)
@@ -96,7 +94,6 @@ static void omap3_core_restore_context(void)
 	omap3_gpmc_restore_context();
 	/* Restore the interrupt controller context */
 	omap_intc_restore_context();
-	omap_dma_global_context_restore();
 }
 
 /*
@@ -547,9 +544,7 @@ int __init omap3_pm_init(void)
 
 		local_irq_disable();
 
-		omap_dma_global_context_save();
 		omap3_save_secure_ram_context();
-		omap_dma_global_context_restore();
 
 		local_irq_enable();
 	}

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 1a90050361f1..54254fc92c2e 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * OMAP3 Power Management Routines
  *
@@ -12,10 +13,6 @@
  * Richard Woodruff <r-woodruff2@ti.com>
  *
  * Based on pm.c for omap1
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/cpu_pm.h>

commit b764a5863fd834836e65e258303e3a4a81c20f38
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Sep 20 12:35:31 2018 -0700

    gpio: omap: Remove custom PM calls and use cpu_pm instead
    
    For a long time the gpio-omap custom PM calls have been annoying me so
    let's replace them with cpu_pm instead. This will enable GPIO PM for
    deeper idle states on omap4. And we can handle GPIO PM for omap2/3/4
    in the same way.
    
    Note that with this patch we are also slightly changing GPIO PM to be
    less aggressive for omap3 and only will idle GPIO when PER context
    may be lost.
    
    For omap2, we don't need to save context and don't want to remove any
    triggering so let's add a quirk flag for that.
    
    Let's do this all in a single patch to avoid a situation where old
    custom calls still are used with new code.
    
    Cc: Aaro Koskinen <aaro.koskinen@iki.fi>
    Cc: Keerthy <j-keerthy@ti.com>
    Cc: Ladislav Michl <ladis@linux-mips.org>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 36c55547137c..1a90050361f1 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -18,19 +18,18 @@
  * published by the Free Software Foundation.
  */
 
+#include <linux/cpu_pm.h>
 #include <linux/pm.h>
 #include <linux/suspend.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
 #include <linux/list.h>
 #include <linux/err.h>
-#include <linux/gpio.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/omap-dma.h>
 #include <linux/omap-gpmc.h>
-#include <linux/platform_data/gpio-omap.h>
 
 #include <trace/events/power.h>
 
@@ -197,7 +196,6 @@ void omap_sram_idle(void)
 	int mpu_next_state = PWRDM_POWER_ON;
 	int per_next_state = PWRDM_POWER_ON;
 	int core_next_state = PWRDM_POWER_ON;
-	int per_going_off;
 	u32 sdrc_pwr = 0;
 
 	mpu_next_state = pwrdm_read_next_pwrst(mpu_pwrdm);
@@ -227,10 +225,8 @@ void omap_sram_idle(void)
 	pwrdm_pre_transition(NULL);
 
 	/* PER */
-	if (per_next_state < PWRDM_POWER_ON) {
-		per_going_off = (per_next_state == PWRDM_POWER_OFF) ? 1 : 0;
-		omap2_gpio_prepare_for_idle(per_going_off);
-	}
+	if (per_next_state == PWRDM_POWER_OFF)
+		cpu_cluster_pm_enter();
 
 	/* CORE */
 	if (core_next_state < PWRDM_POWER_ON) {
@@ -295,8 +291,8 @@ void omap_sram_idle(void)
 	pwrdm_post_transition(NULL);
 
 	/* PER */
-	if (per_next_state < PWRDM_POWER_ON)
-		omap2_gpio_resume_after_idle();
+	if (per_next_state == PWRDM_POWER_OFF)
+		cpu_cluster_pm_exit();
 }
 
 static void omap3_pm_idle(void)

commit d09220a887f70368afa79e850c95e74890c0a32d
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Nov 27 08:57:26 2017 -0800

    ARM: OMAP2+: Fix SRAM virt to phys translation for save_secure_ram_context
    
    With the CMA changes from Joonsoo Kim <iamjoonsoo.kim@lge.com>, it
    was noticed that n900 stopped booting. After investigating it turned
    out that n900 save_secure_ram_context does some whacky virtual to
    physical address translation for the SRAM data address.
    
    As we now only have minimal parts of omap3 idle code copied to SRAM,
    running save_secure_ram_context() in SRAM is not needed. It only gets
    called on PM init. And it seems there's no need to ever call this from
    SRAM idle code.
    
    So let's just keep save_secure_ram_context() in DDR, and pass it the
    physical address of the parameters. We can do everything else in
    omap-secure.c like we already do for other secure code.
    
    And since we don't have any documentation, I still have no clue what
    the values for 0, 1 and 1 for the parameters might be. If somebody has
    figured it out, please do send a patch to add some comments.
    
    Debugged-by: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 841ba19d64a6..36c55547137c 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -48,6 +48,7 @@
 #include "prm3xxx.h"
 #include "pm.h"
 #include "sdrc.h"
+#include "omap-secure.h"
 #include "sram.h"
 #include "control.h"
 #include "vc.h"
@@ -66,7 +67,6 @@ struct power_state {
 
 static LIST_HEAD(pwrst_list);
 
-static int (*_omap_save_secure_sram)(u32 *addr);
 void (*omap3_do_wfi_sram)(void);
 
 static struct powerdomain *mpu_pwrdm, *neon_pwrdm;
@@ -121,8 +121,8 @@ static void omap3_save_secure_ram_context(void)
 		 * will hang the system.
 		 */
 		pwrdm_set_next_pwrst(mpu_pwrdm, PWRDM_POWER_ON);
-		ret = _omap_save_secure_sram((u32 *)(unsigned long)
-				__pa(omap3_secure_ram_storage));
+		ret = omap3_save_secure_ram(omap3_secure_ram_storage,
+					    OMAP3_SAVE_SECURE_RAM_SZ);
 		pwrdm_set_next_pwrst(mpu_pwrdm, mpu_next_state);
 		/* Following is for error tracking, it should not happen */
 		if (ret) {
@@ -434,15 +434,10 @@ static int __init pwrdms_setup(struct powerdomain *pwrdm, void *unused)
  *
  * The minimum set of functions is pushed to SRAM for execution:
  * - omap3_do_wfi for erratum i581 WA,
- * - save_secure_ram_context for security extensions.
  */
 void omap_push_sram_idle(void)
 {
 	omap3_do_wfi_sram = omap_sram_push(omap3_do_wfi, omap3_do_wfi_sz);
-
-	if (omap_type() != OMAP2_DEVICE_TYPE_GP)
-		_omap_save_secure_sram = omap_sram_push(save_secure_ram_context,
-				save_secure_ram_context_sz);
 }
 
 static void __init pm_errata_configure(void)
@@ -553,7 +548,7 @@ int __init omap3_pm_init(void)
 	clkdm_add_wkdep(neon_clkdm, mpu_clkdm);
 	if (omap_type() != OMAP2_DEVICE_TYPE_GP) {
 		omap3_secure_ram_storage =
-			kmalloc(0x803F, GFP_KERNEL);
+			kmalloc(OMAP3_SAVE_SECURE_RAM_SZ, GFP_KERNEL);
 		if (!omap3_secure_ram_storage)
 			pr_err("Memory allocation failed when allocating for secure sram context\n");
 

commit 324dd7a6ac27b388e605ef136f23c88a5e49edbe
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Jun 27 01:48:38 2017 -0700

    ARM: OMAP2+: Fix omap3 prm shared irq
    
    Shared interrupts with IRQ_NOAUTOEN got a warning added with commit
    04c848d39879 ("genirq: Warn when IRQ_NOAUTOEN is used with shared
    interrupts").
    
    Let's just drop the IRQ_NOAUTOEN use for omap3 PRM shared interrupt as
    it does not seem to cause any other issues based on my testing. We have
    moved a lot of the code to initialize later, and whatever problems the
    legacy booting had seem to be gone now with pinctrl driver and device
    tree based booting.
    
    Otherwise we will get:
    
    WARNING: CPU: 0 PID: 1 at kernel/irq/manage.c:1348 __setup_irq+0x5d0/0x64c
    [<c01b0260>] (__setup_irq) from [<c01b0480>]
    (request_threaded_irq+0xdc/0x188)
    [<c01b0480>] (request_threaded_irq) from [<c051c780>]
    (pcs_probe+0x6ec/0x8a4)
    [<c051c780>] (pcs_probe) from [<c05a84b8>] (platform_drv_probe+0x50/0xb0)
    [<c05a84b8>] (platform_drv_probe) from [<c05a6288>]
    (driver_probe_device+0x33c/0x478)
    
    Note that we also need to remove the related enable_irq() to avoid
    getting the following:
    
    WARNING: CPU: 0 PID: 1 at kernel/irq/manage.c:529 enable_irq+0x34/0x70
    [<c01afa04>] (enable_irq) from [<c0c0f1fc>] (omap3_pm_init+0x118/0x3f8)
    [<c0c0f1fc>] (omap3_pm_init) from [<c0c0ae7c>] (am35xx_init_late+0x10/0x18)
    
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index d44e0e2f1106..841ba19d64a6 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -486,7 +486,6 @@ int __init omap3_pm_init(void)
 	ret = request_irq(omap_prcm_event_to_irq("io"),
 		_prcm_int_handle_io, IRQF_SHARED | IRQF_NO_SUSPEND, "pm_io",
 		omap3_pm_init);
-	enable_irq(omap_prcm_event_to_irq("io"));
 
 	if (ret) {
 		pr_err("pm: Failed to request pm_io irq\n");

commit 1560d15861769c23fd981e2d60dc7fd790b21e1e
Author: Dave Gerlach <d-gerlach@ti.com>
Date:   Wed Apr 13 20:49:48 2016 -0500

    ARM: OMAP3: Fix external abort on 36xx waking from off mode idle
    
    Depending on timing during the resume path from off mode on 36xx, we may
    see external aborts. These seem to be caused by the following:
    
    - OMAP3 Advisory 1.62 "MPU Cannot Exit from Standby" says we need to
      disable intc autoidle before WFI
    
    - DM3730 Advisory 1.106 "MPU Leaves MSTANDBY State Before IDLEREQ of
      Interrupt Controller is Released" says we need to wait before
      accessing intc
    
    omap3_intc_resume_idle restores the intc autoidle for all resume paths,
    however in the resume path from off mode only it is also being restored
    by omap_intc_restore_context before this call to omap3_intc_resume_idle
    happens. The second restore of the intc autoidle in this path is what
    appears to be causing the external abort so for the off mode resume path
    let's rely on omap_intc_restore_context to restore intc autoidle, and
    for all other paths let omap3_intc_resume_idle handle it as it is now.
    
    Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 2dbd3785ee6f..d44e0e2f1106 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -198,7 +198,6 @@ void omap_sram_idle(void)
 	int per_next_state = PWRDM_POWER_ON;
 	int core_next_state = PWRDM_POWER_ON;
 	int per_going_off;
-	int core_prev_state;
 	u32 sdrc_pwr = 0;
 
 	mpu_next_state = pwrdm_read_next_pwrst(mpu_pwrdm);
@@ -278,16 +277,20 @@ void omap_sram_idle(void)
 		sdrc_write_reg(sdrc_pwr, SDRC_POWER);
 
 	/* CORE */
-	if (core_next_state < PWRDM_POWER_ON) {
-		core_prev_state = pwrdm_read_prev_pwrst(core_pwrdm);
-		if (core_prev_state == PWRDM_POWER_OFF) {
-			omap3_core_restore_context();
-			omap3_cm_restore_context();
-			omap3_sram_restore_context();
-			omap2_sms_restore_context();
-		}
+	if (core_next_state < PWRDM_POWER_ON &&
+	    pwrdm_read_prev_pwrst(core_pwrdm) == PWRDM_POWER_OFF) {
+		omap3_core_restore_context();
+		omap3_cm_restore_context();
+		omap3_sram_restore_context();
+		omap2_sms_restore_context();
+	} else {
+		/*
+		 * In off-mode resume path above, omap3_core_restore_context
+		 * also handles the INTC autoidle restore done here so limit
+		 * this to non-off mode resume paths so we don't do it twice.
+		 */
+		omap3_intc_resume_idle();
 	}
-	omap3_intc_resume_idle();
 
 	pwrdm_post_transition(NULL);
 

commit 6ca22700eb45397c16fd4c962333963b2d6b0923
Author: Jisheng Zhang <jszhang@marvell.com>
Date:   Fri Sep 18 13:41:21 2015 +0800

    ARM: OMAP2+: PM: Denote the cpuidle tracepoints as _rcuidle()
    
    The cpuidle tracepoints are called within a rcu_idle_exit() section, and
    must be denoted with the _rcuidle() version of the tracepoint.
    
    Signed-off-by: Jisheng Zhang <jszhang@marvell.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 87b98bf92366..2dbd3785ee6f 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -301,11 +301,11 @@ static void omap3_pm_idle(void)
 	if (omap_irq_pending())
 		return;
 
-	trace_cpu_idle(1, smp_processor_id());
+	trace_cpu_idle_rcuidle(1, smp_processor_id());
 
 	omap_sram_idle();
 
-	trace_cpu_idle(PWR_EVENT_EXIT, smp_processor_id());
+	trace_cpu_idle_rcuidle(PWR_EVENT_EXIT, smp_processor_id());
 }
 
 #ifdef CONFIG_SUSPEND

commit 9cb6d36371b0a9935de92bf250c7152f5b50fdc1
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Apr 4 12:31:51 2014 +0300

    ARM: OMAP2+: PRM: add generic API for clear_mod_irqs
    
    OMAP2/3 now use generic API for the prm_clear_mod_irqs, the SoC specific
    implementation details are provided through prm_ll_data.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 25813293eaa6..87b98bf92366 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -137,8 +137,8 @@ static irqreturn_t _prcm_int_handle_io(int irq, void *unused)
 {
 	int c;
 
-	c = omap3xxx_prm_clear_mod_irqs(WKUP_MOD, 1, OMAP3430_ST_IO_MASK |
-					OMAP3430_ST_IO_CHAIN_MASK);
+	c = omap_prm_clear_mod_irqs(WKUP_MOD, 1, OMAP3430_ST_IO_MASK |
+				    OMAP3430_ST_IO_CHAIN_MASK);
 
 	return c ? IRQ_HANDLED : IRQ_NONE;
 }
@@ -152,15 +152,13 @@ static irqreturn_t _prcm_int_handle_wakeup(int irq, void *unused)
 	 * these are handled in a separate handler to avoid acking
 	 * IO events before parsing in mux code
 	 */
-	c = omap3xxx_prm_clear_mod_irqs(WKUP_MOD, 1,
-					~(OMAP3430_ST_IO_MASK |
-					  OMAP3430_ST_IO_CHAIN_MASK));
-	c += omap3xxx_prm_clear_mod_irqs(CORE_MOD, 1, ~0);
-	c += omap3xxx_prm_clear_mod_irqs(OMAP3430_PER_MOD, 1, ~0);
+	c = omap_prm_clear_mod_irqs(WKUP_MOD, 1, ~(OMAP3430_ST_IO_MASK |
+						   OMAP3430_ST_IO_CHAIN_MASK));
+	c += omap_prm_clear_mod_irqs(CORE_MOD, 1, ~0);
+	c += omap_prm_clear_mod_irqs(OMAP3430_PER_MOD, 1, ~0);
 	if (omap_rev() > OMAP3430_REV_ES1_0) {
-		c += omap3xxx_prm_clear_mod_irqs(CORE_MOD, 3, ~0);
-		c += omap3xxx_prm_clear_mod_irqs(OMAP3430ES2_USBHOST_MOD, 1,
-						 ~0);
+		c += omap_prm_clear_mod_irqs(CORE_MOD, 3, ~0);
+		c += omap_prm_clear_mod_irqs(OMAP3430ES2_USBHOST_MOD, 1, ~0);
 	}
 
 	return c ? IRQ_HANDLED : IRQ_NONE;

commit f0caa5270bcf97c6a51c89d44747da00c0d67bb8
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Apr 4 12:14:27 2014 +0300

    ARM: OMAP3: PRM: invert the wkst_mask for the prm_clear_mod_irqs
    
    This makes the API the same as used with OMAP2, and makes it possible
    to implement a generic driver API for the functionality.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 88721df6001d..25813293eaa6 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -137,9 +137,8 @@ static irqreturn_t _prcm_int_handle_io(int irq, void *unused)
 {
 	int c;
 
-	c = omap3xxx_prm_clear_mod_irqs(WKUP_MOD, 1,
-					~(OMAP3430_ST_IO_MASK |
-					  OMAP3430_ST_IO_CHAIN_MASK));
+	c = omap3xxx_prm_clear_mod_irqs(WKUP_MOD, 1, OMAP3430_ST_IO_MASK |
+					OMAP3430_ST_IO_CHAIN_MASK);
 
 	return c ? IRQ_HANDLED : IRQ_NONE;
 }
@@ -154,13 +153,14 @@ static irqreturn_t _prcm_int_handle_wakeup(int irq, void *unused)
 	 * IO events before parsing in mux code
 	 */
 	c = omap3xxx_prm_clear_mod_irqs(WKUP_MOD, 1,
-					OMAP3430_ST_IO_MASK |
-					OMAP3430_ST_IO_CHAIN_MASK);
-	c += omap3xxx_prm_clear_mod_irqs(CORE_MOD, 1, 0);
-	c += omap3xxx_prm_clear_mod_irqs(OMAP3430_PER_MOD, 1, 0);
+					~(OMAP3430_ST_IO_MASK |
+					  OMAP3430_ST_IO_CHAIN_MASK));
+	c += omap3xxx_prm_clear_mod_irqs(CORE_MOD, 1, ~0);
+	c += omap3xxx_prm_clear_mod_irqs(OMAP3430_PER_MOD, 1, ~0);
 	if (omap_rev() > OMAP3430_REV_ES1_0) {
-		c += omap3xxx_prm_clear_mod_irqs(CORE_MOD, 3, 0);
-		c += omap3xxx_prm_clear_mod_irqs(OMAP3430ES2_USBHOST_MOD, 1, 0);
+		c += omap3xxx_prm_clear_mod_irqs(CORE_MOD, 3, ~0);
+		c += omap3xxx_prm_clear_mod_irqs(OMAP3430ES2_USBHOST_MOD, 1,
+						 ~0);
 	}
 
 	return c ? IRQ_HANDLED : IRQ_NONE;

commit e639cd5bfc03de7ba642d7e8570b9e533f10e54b
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Nov 20 12:11:25 2014 -0800

    ARM: OMAP2+: Prepare to move GPMC to drivers by platform data header
    
    We still need to support platform data for omap3 until it's booting
    in device tree only mode. So let's add platform_data/omap-gpmc.h for
    that, and a minimal linux/omap-gpmc.h for the save and restore used
    by the PM code.
    
    Let's also keep a minimal mach-omap2/gpmc.h still around to avoid
    churn on the board-*.c files. Once omap3 boots in device tree only
    mode, we can drop mach-omap2/gpmc.h and we can make the data
    structures in platform_data/omap-gpmc.h private to the GPMC driver.
    
    Note that we can now also remove gpmc-nand.h and gpmc-onenand.h.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 175564c88a30..88721df6001d 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -29,6 +29,7 @@
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/omap-dma.h>
+#include <linux/omap-gpmc.h>
 #include <linux/platform_data/gpio-omap.h>
 
 #include <trace/events/power.h>
@@ -43,7 +44,6 @@
 #include "common.h"
 #include "cm3xxx.h"
 #include "cm-regbits-34xx.h"
-#include "gpmc.h"
 #include "prm-regbits-34xx.h"
 #include "prm3xxx.h"
 #include "pm.h"

commit 3d0cb73e9c85e60206ea9d5191bc0b9a0c4c8a99
Author: Joe Perches <joe@perches.com>
Date:   Sat Sep 13 11:31:16 2014 -0700

    arm: mach-omap2: Convert pr_warning to pr_warn
    
    Use the more common pr_warn.
    
    Other miscellanea:
    
    o Realign arguments
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 3f80929a5f7e..175564c88a30 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -465,7 +465,7 @@ int __init omap3_pm_init(void)
 	int ret;
 
 	if (!omap3_has_io_chain_ctrl())
-		pr_warning("PM: no software I/O chain control; some wakeups may be lost\n");
+		pr_warn("PM: no software I/O chain control; some wakeups may be lost\n");
 
 	pm_errata_configure();
 

commit ba12c24286296159a1271eb19f2fc5c2ef59fbde
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Mar 4 17:43:04 2014 +0200

    ARM: OMAP3: control: isolate control module init to its own function
    
    Control module related PM initializations are now moved within control
    module driver. Done in preparation to isolate the code to its own driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 9410b4a5c252..3f80929a5f7e 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -355,8 +355,7 @@ static int omap3_pm_suspend(void)
 
 static void __init prcm_setup_regs(void)
 {
-	/* XXX This should be handled by hwmod code or SCM init code */
-	omap_ctrl_writel(OMAP3430_AUTOIDLE_MASK, OMAP2_CONTROL_SYSCONFIG);
+	omap3_ctrl_init();
 
 	omap3_prm_init_pm(cpu_is_omap3630(), omap3_has_iva());
 }

commit c2148e5930cdd2dd964e18fb7057c1e07f63c363
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Mar 4 17:24:21 2014 +0200

    ARM: OMAP3: PRM: move modem reset and iva2 idle to PRM driver
    
    Done in preparation to move PRM into its own driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 126f3ec2d174..9410b4a5c252 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -353,27 +353,12 @@ static int omap3_pm_suspend(void)
 #define omap3_pm_suspend NULL
 #endif /* CONFIG_SUSPEND */
 
-static void __init omap3_d2d_idle(void)
-{
-	omap3_ctrl_setup_d2d_padconf();
-
-	/* reset modem */
-	omap3_prm_reset_modem();
-}
-
 static void __init prcm_setup_regs(void)
 {
 	/* XXX This should be handled by hwmod code or SCM init code */
 	omap_ctrl_writel(OMAP3430_AUTOIDLE_MASK, OMAP2_CONTROL_SYSCONFIG);
 
 	omap3_prm_init_pm(cpu_is_omap3630(), omap3_has_iva());
-
-	/*
-	 * We need to idle iva2_pwrdm even on am3703 with no iva2.
-	 */
-	omap3xxx_prm_iva_idle();
-
-	omap3_d2d_idle();
 }
 
 void omap3_pm_off_mode_enable(int enable)

commit bbd36f9f03eceee5c208db83049142171e6338f6
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Mar 4 17:17:06 2014 +0200

    ARM: OMAP3: control: add API for setting up the modem pads
    
    This patch moves the functionality from PM core to control driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 3ea04ac10d16..126f3ec2d174 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -355,20 +355,7 @@ static int omap3_pm_suspend(void)
 
 static void __init omap3_d2d_idle(void)
 {
-	u16 mask, padconf;
-
-	/* In a stand alone OMAP3430 where there is not a stacked
-	 * modem for the D2D Idle Ack and D2D MStandby must be pulled
-	 * high. S CONTROL_PADCONF_SAD2D_IDLEACK and
-	 * CONTROL_PADCONF_SAD2D_MSTDBY to have a pull up. */
-	mask = (1 << 4) | (1 << 3); /* pull-up, enabled */
-	padconf = omap_ctrl_readw(OMAP3_PADCONF_SAD2D_MSTANDBY);
-	padconf |= mask;
-	omap_ctrl_writew(padconf, OMAP3_PADCONF_SAD2D_MSTANDBY);
-
-	padconf = omap_ctrl_readw(OMAP3_PADCONF_SAD2D_IDLEACK);
-	padconf |= mask;
-	omap_ctrl_writew(padconf, OMAP3_PADCONF_SAD2D_IDLEACK);
+	omap3_ctrl_setup_d2d_padconf();
 
 	/* reset modem */
 	omap3_prm_reset_modem();

commit c5180a2b3e26d9b82277986f830c89a50103e65a
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Feb 26 17:30:43 2014 +0200

    ARM: OMAP3: PRM: move PRM init code from PM core to the driver
    
    Helps to isolate the PRM driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index acb895deb3cc..3ea04ac10d16 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -376,79 +376,10 @@ static void __init omap3_d2d_idle(void)
 
 static void __init prcm_setup_regs(void)
 {
-	u32 omap3630_en_uart4_mask = cpu_is_omap3630() ?
-					OMAP3630_EN_UART4_MASK : 0;
-	u32 omap3630_grpsel_uart4_mask = cpu_is_omap3630() ?
-					OMAP3630_GRPSEL_UART4_MASK : 0;
-
 	/* XXX This should be handled by hwmod code or SCM init code */
 	omap_ctrl_writel(OMAP3430_AUTOIDLE_MASK, OMAP2_CONTROL_SYSCONFIG);
 
-	/*
-	 * Enable control of expternal oscillator through
-	 * sys_clkreq. In the long run clock framework should
-	 * take care of this.
-	 */
-	omap2_prm_rmw_mod_reg_bits(OMAP_AUTOEXTCLKMODE_MASK,
-			     1 << OMAP_AUTOEXTCLKMODE_SHIFT,
-			     OMAP3430_GR_MOD,
-			     OMAP3_PRM_CLKSRC_CTRL_OFFSET);
-
-	/* setup wakup source */
-	omap2_prm_write_mod_reg(OMAP3430_EN_IO_MASK | OMAP3430_EN_GPIO1_MASK |
-			  OMAP3430_EN_GPT1_MASK | OMAP3430_EN_GPT12_MASK,
-			  WKUP_MOD, PM_WKEN);
-	/* No need to write EN_IO, that is always enabled */
-	omap2_prm_write_mod_reg(OMAP3430_GRPSEL_GPIO1_MASK |
-			  OMAP3430_GRPSEL_GPT1_MASK |
-			  OMAP3430_GRPSEL_GPT12_MASK,
-			  WKUP_MOD, OMAP3430_PM_MPUGRPSEL);
-
-	/* Enable PM_WKEN to support DSS LPR */
-	omap2_prm_write_mod_reg(OMAP3430_PM_WKEN_DSS_EN_DSS_MASK,
-				OMAP3430_DSS_MOD, PM_WKEN);
-
-	/* Enable wakeups in PER */
-	omap2_prm_write_mod_reg(omap3630_en_uart4_mask |
-			  OMAP3430_EN_GPIO2_MASK | OMAP3430_EN_GPIO3_MASK |
-			  OMAP3430_EN_GPIO4_MASK | OMAP3430_EN_GPIO5_MASK |
-			  OMAP3430_EN_GPIO6_MASK | OMAP3430_EN_UART3_MASK |
-			  OMAP3430_EN_MCBSP2_MASK | OMAP3430_EN_MCBSP3_MASK |
-			  OMAP3430_EN_MCBSP4_MASK,
-			  OMAP3430_PER_MOD, PM_WKEN);
-	/* and allow them to wake up MPU */
-	omap2_prm_write_mod_reg(omap3630_grpsel_uart4_mask |
-			  OMAP3430_GRPSEL_GPIO2_MASK |
-			  OMAP3430_GRPSEL_GPIO3_MASK |
-			  OMAP3430_GRPSEL_GPIO4_MASK |
-			  OMAP3430_GRPSEL_GPIO5_MASK |
-			  OMAP3430_GRPSEL_GPIO6_MASK |
-			  OMAP3430_GRPSEL_UART3_MASK |
-			  OMAP3430_GRPSEL_MCBSP2_MASK |
-			  OMAP3430_GRPSEL_MCBSP3_MASK |
-			  OMAP3430_GRPSEL_MCBSP4_MASK,
-			  OMAP3430_PER_MOD, OMAP3430_PM_MPUGRPSEL);
-
-	/* Don't attach IVA interrupts */
-	if (omap3_has_iva()) {
-		omap2_prm_write_mod_reg(0, WKUP_MOD, OMAP3430_PM_IVAGRPSEL);
-		omap2_prm_write_mod_reg(0, CORE_MOD, OMAP3430_PM_IVAGRPSEL1);
-		omap2_prm_write_mod_reg(0, CORE_MOD, OMAP3430ES2_PM_IVAGRPSEL3);
-		omap2_prm_write_mod_reg(0, OMAP3430_PER_MOD,
-					OMAP3430_PM_IVAGRPSEL);
-	}
-
-	/* Clear any pending 'reset' flags */
-	omap2_prm_write_mod_reg(0xffffffff, MPU_MOD, OMAP2_RM_RSTST);
-	omap2_prm_write_mod_reg(0xffffffff, CORE_MOD, OMAP2_RM_RSTST);
-	omap2_prm_write_mod_reg(0xffffffff, OMAP3430_PER_MOD, OMAP2_RM_RSTST);
-	omap2_prm_write_mod_reg(0xffffffff, OMAP3430_EMU_MOD, OMAP2_RM_RSTST);
-	omap2_prm_write_mod_reg(0xffffffff, OMAP3430_NEON_MOD, OMAP2_RM_RSTST);
-	omap2_prm_write_mod_reg(0xffffffff, OMAP3430_DSS_MOD, OMAP2_RM_RSTST);
-	omap2_prm_write_mod_reg(0xffffffff, OMAP3430ES2_USBHOST_MOD, OMAP2_RM_RSTST);
-
-	/* Clear any pending PRCM interrupts */
-	omap2_prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
+	omap3_prm_init_pm(cpu_is_omap3630(), omap3_has_iva());
 
 	/*
 	 * We need to idle iva2_pwrdm even on am3703 with no iva2.

commit 55c6c3ad90f606d458d798b36f8ffca98c1894e0
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Mar 4 15:48:33 2014 +0200

    ARM: OMAP3: PRM: move modem reset to PRM driver
    
    This is a more proper isolation of the code. Done in preparation of making
    PRM an individual driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 6d02573ac4c0..acb895deb3cc 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -371,10 +371,7 @@ static void __init omap3_d2d_idle(void)
 	omap_ctrl_writew(padconf, OMAP3_PADCONF_SAD2D_IDLEACK);
 
 	/* reset modem */
-	omap2_prm_write_mod_reg(OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RSTPWRON_MASK |
-			  OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RST_MASK,
-			  CORE_MOD, OMAP2_RM_RSTCTRL);
-	omap2_prm_write_mod_reg(0, CORE_MOD, OMAP2_RM_RSTCTRL);
+	omap3_prm_reset_modem();
 }
 
 static void __init prcm_setup_regs(void)

commit 9de367fae0d9907e19d065e0381ecd3f4003e08f
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Feb 25 18:04:56 2014 +0200

    ARM: OMAP3: PRM: move iva reset to PRM driver
    
    This is a more proper isolation of the code. Done in preparation of making
    PRM an individual driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 74d03f26d962..6d02573ac4c0 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -353,53 +353,6 @@ static int omap3_pm_suspend(void)
 #define omap3_pm_suspend NULL
 #endif /* CONFIG_SUSPEND */
 
-
-/**
- * omap3_iva_idle(): ensure IVA is in idle so it can be put into
- *                   retention
- *
- * In cases where IVA2 is activated by bootcode, it may prevent
- * full-chip retention or off-mode because it is not idle.  This
- * function forces the IVA2 into idle state so it can go
- * into retention/off and thus allow full-chip retention/off.
- *
- **/
-static void __init omap3_iva_idle(void)
-{
-	/* ensure IVA2 clock is disabled */
-	omap2_cm_write_mod_reg(0, OMAP3430_IVA2_MOD, CM_FCLKEN);
-
-	/* if no clock activity, nothing else to do */
-	if (!(omap2_cm_read_mod_reg(OMAP3430_IVA2_MOD, OMAP3430_CM_CLKSTST) &
-	      OMAP3430_CLKACTIVITY_IVA2_MASK))
-		return;
-
-	/* Reset IVA2 */
-	omap2_prm_write_mod_reg(OMAP3430_RST1_IVA2_MASK |
-			  OMAP3430_RST2_IVA2_MASK |
-			  OMAP3430_RST3_IVA2_MASK,
-			  OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);
-
-	/* Enable IVA2 clock */
-	omap2_cm_write_mod_reg(OMAP3430_CM_FCLKEN_IVA2_EN_IVA2_MASK,
-			 OMAP3430_IVA2_MOD, CM_FCLKEN);
-
-	/* Set IVA2 boot mode to 'idle' */
-	omap3_ctrl_set_iva_bootmode_idle();
-
-	/* Un-reset IVA2 */
-	omap2_prm_write_mod_reg(0, OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);
-
-	/* Disable IVA2 clock */
-	omap2_cm_write_mod_reg(0, OMAP3430_IVA2_MOD, CM_FCLKEN);
-
-	/* Reset IVA2 */
-	omap2_prm_write_mod_reg(OMAP3430_RST1_IVA2_MASK |
-			  OMAP3430_RST2_IVA2_MASK |
-			  OMAP3430_RST3_IVA2_MASK,
-			  OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);
-}
-
 static void __init omap3_d2d_idle(void)
 {
 	u16 mask, padconf;
@@ -503,7 +456,7 @@ static void __init prcm_setup_regs(void)
 	/*
 	 * We need to idle iva2_pwrdm even on am3703 with no iva2.
 	 */
-	omap3_iva_idle();
+	omap3xxx_prm_iva_idle();
 
 	omap3_d2d_idle();
 }

commit 0efc0f6ec2d6c6497e401df171705c5762f5a061
Author: Tero Kristo <t-kristo@ti.com>
Date:   Tue Feb 25 15:40:30 2014 +0200

    ARM: OMAP3: PRM: move prcm wakeup helper to prm driver
    
    Done in preparation to make the prm an individual driver.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 507d8eeaab95..74d03f26d962 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -133,60 +133,13 @@ static void omap3_save_secure_ram_context(void)
 	}
 }
 
-/*
- * PRCM Interrupt Handler Helper Function
- *
- * The purpose of this function is to clear any wake-up events latched
- * in the PRCM PM_WKST_x registers. It is possible that a wake-up event
- * may occur whilst attempting to clear a PM_WKST_x register and thus
- * set another bit in this register. A while loop is used to ensure
- * that any peripheral wake-up events occurring while attempting to
- * clear the PM_WKST_x are detected and cleared.
- */
-static int prcm_clear_mod_irqs(s16 module, u8 regs, u32 ignore_bits)
-{
-	u32 wkst, fclk, iclk, clken;
-	u16 wkst_off = (regs == 3) ? OMAP3430ES2_PM_WKST3 : PM_WKST1;
-	u16 fclk_off = (regs == 3) ? OMAP3430ES2_CM_FCLKEN3 : CM_FCLKEN1;
-	u16 iclk_off = (regs == 3) ? CM_ICLKEN3 : CM_ICLKEN1;
-	u16 grpsel_off = (regs == 3) ?
-		OMAP3430ES2_PM_MPUGRPSEL3 : OMAP3430_PM_MPUGRPSEL;
-	int c = 0;
-
-	wkst = omap2_prm_read_mod_reg(module, wkst_off);
-	wkst &= omap2_prm_read_mod_reg(module, grpsel_off);
-	wkst &= ~ignore_bits;
-	if (wkst) {
-		iclk = omap2_cm_read_mod_reg(module, iclk_off);
-		fclk = omap2_cm_read_mod_reg(module, fclk_off);
-		while (wkst) {
-			clken = wkst;
-			omap2_cm_set_mod_reg_bits(clken, module, iclk_off);
-			/*
-			 * For USBHOST, we don't know whether HOST1 or
-			 * HOST2 woke us up, so enable both f-clocks
-			 */
-			if (module == OMAP3430ES2_USBHOST_MOD)
-				clken |= 1 << OMAP3430ES2_EN_USBHOST2_SHIFT;
-			omap2_cm_set_mod_reg_bits(clken, module, fclk_off);
-			omap2_prm_write_mod_reg(wkst, module, wkst_off);
-			wkst = omap2_prm_read_mod_reg(module, wkst_off);
-			wkst &= ~ignore_bits;
-			c++;
-		}
-		omap2_cm_write_mod_reg(iclk, module, iclk_off);
-		omap2_cm_write_mod_reg(fclk, module, fclk_off);
-	}
-
-	return c;
-}
-
 static irqreturn_t _prcm_int_handle_io(int irq, void *unused)
 {
 	int c;
 
-	c = prcm_clear_mod_irqs(WKUP_MOD, 1,
-		~(OMAP3430_ST_IO_MASK | OMAP3430_ST_IO_CHAIN_MASK));
+	c = omap3xxx_prm_clear_mod_irqs(WKUP_MOD, 1,
+					~(OMAP3430_ST_IO_MASK |
+					  OMAP3430_ST_IO_CHAIN_MASK));
 
 	return c ? IRQ_HANDLED : IRQ_NONE;
 }
@@ -200,13 +153,14 @@ static irqreturn_t _prcm_int_handle_wakeup(int irq, void *unused)
 	 * these are handled in a separate handler to avoid acking
 	 * IO events before parsing in mux code
 	 */
-	c = prcm_clear_mod_irqs(WKUP_MOD, 1,
-		OMAP3430_ST_IO_MASK | OMAP3430_ST_IO_CHAIN_MASK);
-	c += prcm_clear_mod_irqs(CORE_MOD, 1, 0);
-	c += prcm_clear_mod_irqs(OMAP3430_PER_MOD, 1, 0);
+	c = omap3xxx_prm_clear_mod_irqs(WKUP_MOD, 1,
+					OMAP3430_ST_IO_MASK |
+					OMAP3430_ST_IO_CHAIN_MASK);
+	c += omap3xxx_prm_clear_mod_irqs(CORE_MOD, 1, 0);
+	c += omap3xxx_prm_clear_mod_irqs(OMAP3430_PER_MOD, 1, 0);
 	if (omap_rev() > OMAP3430_REV_ES1_0) {
-		c += prcm_clear_mod_irqs(CORE_MOD, 3, 0);
-		c += prcm_clear_mod_irqs(OMAP3430ES2_USBHOST_MOD, 1, 0);
+		c += omap3xxx_prm_clear_mod_irqs(CORE_MOD, 3, 0);
+		c += omap3xxx_prm_clear_mod_irqs(OMAP3430ES2_USBHOST_MOD, 1, 0);
 	}
 
 	return c ? IRQ_HANDLED : IRQ_NONE;

commit 2ca602de42863436cce275dde35c22496344d539
Merge: 98954f4b122c 57b055722675
Author: Olof Johansson <olof@lixom.net>
Date:   Mon May 26 13:24:56 2014 -0700

    Merge tag 'omap-for-v3.16/pm-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into next/soc
    
    Merge "ARM: omap pm changes for v3.16 merge window, resend" from Tony Lindgren:
    
    PM related fixes for omap3 that were discovered during omap3
    conversion to device tree. This series sets up the PMIC signaling
    in a way where we can test for PM regressions easily by
    looking at state of the the sys_clkreq and sys_off_mode pins.
    
    Note that this series alone does not make omap3 PM to cut
    off core voltage during off-idle, changes to twl4030-power.c
    configurations are still needed. Those will be posted
    separately.
    
    * tag 'omap-for-v3.16/pm-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap:
      ARM: OMAP2+: Enable CPUidle in omap2plus_defconfig
      ARM: dts: Enable N900 keyboard sleep leds by default
      ARM: OMAP2+: Fix voltage scaling init for device tree
      ARM: dts: Configure omap3 twl4030 I2C4 pins by default
      ARM: OMAP3: Fix voltage control for deeper idle states
      ARM: OMAP3: Disable broken omap3_set_off_timings function
      ARM: OMAP3: Fix idle mode signaling for sys_clkreq and sys_off_mode
      ARM: dts: Fix omap serial wake-up when booted with device tree
      mfd: twl-core: Fix idle mode signaling for omaps when booted with device tree
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 2e4b62dc5e6e2011dbd03ae1a654d990d18d0a14
Author: Dave Gerlach <d-gerlach@ti.com>
Date:   Mon May 12 13:33:21 2014 -0500

    ARM: OMAP2+: Remove suspend_set_ops from common pm late init
    
    In omap2_common_pm_late_init suspend_set_ops was called to set common
    suspend handling functions for all omap platforms. This created two
    problems. First, these suspend ops were being set for all platforms,
    regardless of whether or not suspend support has been integrated so in
    the case of AM33XX, suspend to mem was presented as available but
    failed every time. Second, some platforms will need to define a
    completely separate set of suspend ops, such as AM33XX, due to
    differences from previous omap platforms so there is no need to
    always set the common omap ops.
    
    This patch moves the suspend_set_ops call from omap2_common_pm_late_init
    into a separate function that then gets called in the omap*_pm_init
    functions for each platform.
    
    Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 87099bb6de69..90ea2d3ab405 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -391,7 +391,8 @@ static int omap3_pm_suspend(void)
 
 	return ret;
 }
-
+#else
+#define omap3_pm_suspend NULL
 #endif /* CONFIG_SUSPEND */
 
 
@@ -705,9 +706,7 @@ int __init omap3_pm_init(void)
 	per_clkdm = clkdm_lookup("per_clkdm");
 	wkup_clkdm = clkdm_lookup("wkup_clkdm");
 
-#ifdef CONFIG_SUSPEND
-	omap_pm_suspend = omap3_pm_suspend;
-#endif
+	omap_common_suspend_init(omap3_pm_suspend);
 
 	arm_pm_idle = omap3_pm_idle;
 	omap3_idle_init();

commit 3b8c4ebb76302af86873158d192d76ba3b260ca8
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon May 5 17:27:35 2014 -0700

    ARM: OMAP3: Fix idle mode signaling for sys_clkreq and sys_off_mode
    
    While debugging legacy mode vs device tree booted PM regressions,
    I noticed that omap3 is not toggling sys_clkreq and sys_off_mode
    pins like it should.
    
    The sys_clkreq and sys_off_mode pins are not toggling because of
    the following issues:
    
    1. The default polarity for the sys_off_mode pin is wrong.
       OFFMODE_POL needs to be cleared for sys_off_mode to go down when
       hitting off-idle, while CLKREQ_POL needs to be set so sys_clkreq
       goes down when hitting retention.
    
    2. The values for voltctrl register need to be updated dynamically.
       We need to set either the retention idle bits, or off idle bits
       in the voltctrl register depending the idle mode we're targeting
       to hit.
    
    Let's fix these two issues as otherwise the system will just
    hang if any twl4030 PMIC idle scripts are loaded. The only case
    where the system does not hang is if only retention idle over I2C4
    is configured by the bootloader.
    
    Note that even without the twl4030 PMIC scripts, these fixes will
    do the proper signaling of sys_clkreq and sys_off_mode pins, so
    the fixes are needed to fix monitoring of PM states with LEDs or
    an oscilloscope.
    
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Nishanth Menon <nm@ti.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 87099bb6de69..3c8bb8f0304d 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -50,6 +50,7 @@
 #include "sdrc.h"
 #include "sram.h"
 #include "control.h"
+#include "vc.h"
 
 /* pm34xx errata defined in pm.h */
 u16 pm34xx_errata;
@@ -288,6 +289,9 @@ void omap_sram_idle(void)
 		}
 	}
 
+	/* Configure PMIC signaling for I2C4 or sys_off_mode */
+	omap3_vc_set_pmic_signaling(core_next_state);
+
 	omap3_intc_prepare_idle();
 
 	/*

commit 390403fd79821bbd0c3a0d83307df2be87047b36
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Apr 10 11:01:09 2014 -0700

    ARM: OMAP3: PM: remove access to PRM_VOLTCTRL register
    
    There is a solitary write to this register every wakeup from off-mode,
    which isn't doing anything, so remove it.
    
    Also note that modifying this register trashes any attempted
    voltage scaling configuration and the change probably should
    never have gotten merged in the first place.
    
    Cc: Nishanth Menon <nm@ti.com>
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    [tony@atomide.com: updated comments to describe regression]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 1f3770a8a728..87099bb6de69 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -330,10 +330,6 @@ void omap_sram_idle(void)
 			omap3_sram_restore_context();
 			omap2_sms_restore_context();
 		}
-		if (core_next_state == PWRDM_POWER_OFF)
-			omap2_prm_clear_mod_reg_bits(OMAP3430_AUTO_OFF_MASK,
-					       OMAP3430_GR_MOD,
-					       OMAP3_PRM_VOLTCTRL_OFFSET);
 	}
 	omap3_intc_resume_idle();
 

commit 6dd1e357372c21ec37b6902380bd47b278d168f1
Author: Olof Johansson <olof@lixom.net>
Date:   Tue Nov 12 22:51:28 2013 -0800

    ARM: omap: fix warning with LPAE build
    
    Some omap3 code is throwing a warning:
    arch/arm/mach-omap2/pm34xx.c: In function 'omap3_save_secure_ram_context':
    arch/arm/mach-omap2/pm34xx.c:123:32: warning: cast to pointer from
      integer of different size [-Wint-to-pointer-cast]
    
    In reality this code will never actually execute with LPAE=y, since
    Cortex-A8 doesn't support it. So downcasting the __pa() is safe in
    this case.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 93b80e5da8d4..1f3770a8a728 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -120,7 +120,7 @@ static void omap3_save_secure_ram_context(void)
 		 * will hang the system.
 		 */
 		pwrdm_set_next_pwrst(mpu_pwrdm, PWRDM_POWER_ON);
-		ret = _omap_save_secure_sram((u32 *)
+		ret = _omap_save_secure_sram((u32 *)(unsigned long)
 				__pa(omap3_secure_ram_storage));
 		pwrdm_set_next_pwrst(mpu_pwrdm, mpu_next_state);
 		/* Following is for error tracking, it should not happen */

commit 49e03402327ab69a26f604398982ef14123900a2
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Oct 11 19:15:38 2013 +0300

    ARM: OMAP3: control: add API for setting IVA bootmode
    
    OMAP3 PM core requires IVA2 bootmode to be set to idle during init. Currently,
    a direct register write is used for this. Add a new ctrl API for this purpose
    instead.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 5a2d8034c8de..93b80e5da8d4 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -430,8 +430,7 @@ static void __init omap3_iva_idle(void)
 			 OMAP3430_IVA2_MOD, CM_FCLKEN);
 
 	/* Set IVA2 boot mode to 'idle' */
-	omap_ctrl_writel(OMAP3_IVA2_BOOTMOD_IDLE,
-			 OMAP343X_CONTROL_IVA2_BOOTMOD);
+	omap3_ctrl_set_iva_bootmode_idle();
 
 	/* Un-reset IVA2 */
 	omap2_prm_write_mod_reg(0, OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);

commit 2d403f7b198163d14a37ab79de33e27e390bb3b1
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu May 30 12:44:47 2013 -0700

    ARM: OMAP3: Fix iva2_pwrdm settings for 3703
    
    Commit a819c4f1 (ARM: OMAP3: PM: Only access IVA if one exists)
    changed PM to not access IVA registers on omaps that don't have
    them. Turns out we still need to idle iva2 as otherwise
    iva2_pwrdm will stay on and block deeper idle states.
    
    It seems that the only part of the reset that may not be needed
    is the setting of the iva2 boot mode to idle. But as that register
    seems to be there and is harmless if no iva2 is on the SoC, it's
    probably safest to do the complete reset.
    
    Acked-by: Mark A. Greer <mgreer@animalcreek.com>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Tested-by: Yegor Yefremov <yegorslists@googlemail.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index c01859398b54..5a2d8034c8de 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -546,8 +546,10 @@ static void __init prcm_setup_regs(void)
 	/* Clear any pending PRCM interrupts */
 	omap2_prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
 
-	if (omap3_has_iva())
-		omap3_iva_idle();
+	/*
+	 * We need to idle iva2_pwrdm even on am3703 with no iva2.
+	 */
+	omap3_iva_idle();
 
 	omap3_d2d_idle();
 }

commit 6b85638b83caac7bae9ffa202391882a9ad4388f
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Mon Feb 11 19:29:45 2013 +0530

    ARM: OMAP2+: PM: Remove bogus fiq_[enable/disable] tuple
    
    On OMAP platform, FIQ is reserved for secure environment only. If at all
    the FIQ needs to be disabled, it involves going through security
    API call. Hence the local_fiq_[enable/disable]() in the OMAP code is bogus.
    On GP devices too, the fiq is disabled for non-secure software.
    
    So just get rid of it.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 2d93d8b23835..c01859398b54 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -346,19 +346,14 @@ void omap_sram_idle(void)
 
 static void omap3_pm_idle(void)
 {
-	local_fiq_disable();
-
 	if (omap_irq_pending())
-		goto out;
+		return;
 
 	trace_cpu_idle(1, smp_processor_id());
 
 	omap_sram_idle();
 
 	trace_cpu_idle(PWR_EVENT_EXIT, smp_processor_id());
-
-out:
-	local_fiq_enable();
 }
 
 #ifdef CONFIG_SUSPEND
@@ -757,14 +752,12 @@ int __init omap3_pm_init(void)
 			pr_err("Memory allocation failed when allocating for secure sram context\n");
 
 		local_irq_disable();
-		local_fiq_disable();
 
 		omap_dma_global_context_save();
 		omap3_save_secure_ram_context();
 		omap_dma_global_context_restore();
 
 		local_irq_enable();
-		local_fiq_enable();
 	}
 
 	omap3_save_scratchpad_contents();

commit 43720bd6014327ac454434496cb953edcdb9f8d6
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jan 11 13:43:45 2013 +0100

    PM / tracing: remove deprecated power trace API
    
    The text in Documentation said it would be removed in 2.6.41;
    the text in the Kconfig said removal in the 3.1 release.  Either
    way you look at it, we are well past both, so push it off a cliff.
    
    Note that the POWER_CSTATE and the POWER_PSTATE are part of the
    legacy tracing API.  Remove all tracepoints which use these flags.
    As can be seen from context, most already have a trace entry via
    trace_cpu_idle anyways.
    
    Also, the cpufreq/cpufreq.c PSTATE one is actually unpaired, as
    compared to the CSTATE ones which all have a clear start/stop.
    As part of this, the trace_power_frequency also becomes orphaned,
    so it too is deleted.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Acked-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 7be3622cfc85..2d93d8b23835 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -351,12 +351,10 @@ static void omap3_pm_idle(void)
 	if (omap_irq_pending())
 		goto out;
 
-	trace_power_start(POWER_CSTATE, 1, smp_processor_id());
 	trace_cpu_idle(1, smp_processor_id());
 
 	omap_sram_idle();
 
-	trace_power_end(smp_processor_id());
 	trace_cpu_idle(PWR_EVENT_EXIT, smp_processor_id());
 
 out:

commit 45c3eb7d3a07eb08d1b5b0f5983a996d41610b84
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Nov 30 08:41:50 2012 -0800

    ARM: OMAP: Move plat-omap/dma-omap.h to include/linux/omap-dma.h
    
    Based on earlier discussions[1] we attempted to find a suitable
    location for the omap DMA header in commit 2b6c4e73 (ARM: OMAP:
    DMA: Move plat/dma.h to plat-omap/dma-omap.h) until the conversion
    to dmaengine is complete.
    
    Unfortunately that was before I was able to try to test compile
    of the ARM multiplatform builds for omap2+, and the end result
    was not very good.
    
    So I'm creating yet another all over the place patch to cut the
    last dependency for building omap2+ for ARM multiplatform. After
    this, we have finally removed the driver dependencies to the
    arch/arm code, except for few drivers that are being worked on.
    
    The other option was to make the <plat-omap/dma-omap.h> path
    to work, but we'd have to add some new header directory to for
    multiplatform builds.
    
    Or we would have to manually include arch/arm/plat-omap/include
    again from arch/arm/Makefile for omap2+.
    
    Neither of these alternatives sound appealing as they will
    likely lead addition of various other headers exposed to the
    drivers, which we want to avoid for the multiplatform kernels.
    
    Since we already have a minimal include/linux/omap-dma.h,
    let's just use that instead and add a note to it to not
    use the custom omap DMA functions any longer where possible.
    
    Note that converting omap DMA to dmaengine depends on
    dmaengine supporting automatically incrementing the FIFO
    address at the device end, and converting all the remaining
    legacy drivers. So it's going to be few more merge windows.
    
    [1] https://patchwork.kernel.org/patch/1519591/#
    
    cc: Russell King <linux@arm.linux.org.uk>
    cc: Kevin Hilman <khilman@ti.com>
    cc: "Benot Cousson" <b-cousson@ti.com>
    cc: Herbert Xu <herbert@gondor.apana.org.au>
    cc: "David S. Miller" <davem@davemloft.net>
    cc: Vinod Koul <vinod.koul@intel.com>
    cc: Dan Williams <djbw@fb.com>
    cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    cc: David Woodhouse <dwmw2@infradead.org>
    cc: Kyungmin Park <kyungmin.park@samsung.com>
    cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    cc: Florian Tobias Schandinat <FlorianSchandinat@gmx.de>
    cc: Hans Verkuil <hans.verkuil@cisco.com>
    cc: Vaibhav Hiremath <hvaibhav@ti.com>
    cc: Lokesh Vutla <lokeshvutla@ti.com>
    cc: Rusty Russell <rusty@rustcorp.com.au>
    cc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    cc: Afzal Mohammed <afzal@ti.com>
    cc: linux-crypto@vger.kernel.org
    cc: linux-media@vger.kernel.org
    cc: linux-mtd@lists.infradead.org
    cc: linux-usb@vger.kernel.org
    cc: linux-fbdev@vger.kernel.org
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 770320061422..7be3622cfc85 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -28,6 +28,7 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
+#include <linux/omap-dma.h>
 #include <linux/platform_data/gpio-omap.h>
 
 #include <trace/events/power.h>
@@ -38,8 +39,6 @@
 
 #include "clockdomain.h"
 #include "powerdomain.h"
-#include <plat-omap/dma-omap.h>
-
 #include "soc.h"
 #include "common.h"
 #include "cm3xxx.h"

commit 2589d056122f6dcb405d411eae872aac8cf9da1b
Merge: 42a1cc9c0ec2 8b9c1ac2e11a
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Nov 30 08:40:31 2012 -0800

    Merge tag 'tags/omap-for-v3.8/devel-prcm-signed' into omap-for-v3.8/cleanup-headers-prepare-multiplatform-v3
    
    omap prcm changes via Paul Walmsley <paul@pwsan.com>:
    
    Some miscellaneous OMAP hwmod changes for 3.8, along with a PRM
    change needed for one of the hwmod patches to function.
    
    Basic test logs for this branch on top of Tony's
    omap-for-v3.8/clock branch at commit
    558a0780b0a04862a678f7823215424b4e5501f9 are here:
    
    http://www.pwsan.com/omap/testlogs/hwmod_devel_a_3.8/20121121161522/
    
    However, omap-for-v3.8/clock at 558a0780 does not include some fixes
    that are needed for a successful test.  With several reverts,
    fixes, and workarounds applied, the following test logs were
    obtained:
    
    http://www.pwsan.com/omap/testlogs/TEST_hwmod_devel_a_3.8/20121121162719/
    
    which indicate that the series tests cleanly.
    
    Conflicts:
            arch/arm/mach-omap2/cm33xx.c
            arch/arm/mach-omap2/io.c
            arch/arm/mach-omap2/prm_common.c

commit 89ab216b33ba9405880fd3d89531305a931bc70f
Merge: c9d501e5cb02 46bf4a562207
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Nov 13 13:25:38 2012 -0800

    Merge branch 'omap-for-v3.8/pm' into omap-for-v3.8/clock

commit edf8dde393f879fc2d8c22d4bc01ff8d37b80e1a
Merge: 6ba54ab4a49b 3d70f8c617a4
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Nov 9 14:58:01 2012 -0800

    Merge branch 'linus' into omap-for-v3.8/cleanup-headers-prepare-multiplatform-v3

commit b99db36cdf37decb1b5575c5f293d170cbbc53d6
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Oct 29 20:59:29 2012 -0600

    ARM: OMAP2+: PRCM: remove obsolete prcm.[ch]
    
    arch/arm/mach-omap2/prcm.c and arch/arm/plat-omap/include/plat/prcm.h
    are now completely unused and can be removed.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Vaibhav Hiremath <hvaibhav@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 2f1ad87c1bb0..aa701d76efda 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -37,7 +37,6 @@
 
 #include "clockdomain.h"
 #include "powerdomain.h"
-#include <plat/prcm.h>
 #include <plat-omap/dma-omap.h>
 
 #include "../plat-omap/sram.h"

commit bf027ca13738b1548910351952c3fe9b63263a9a
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Oct 29 13:54:06 2012 -0700

    ARM: OMAP: Split sram.h to local headers and minimal shared header
    
    Most of the defines are specific to omap1 and omap2+,
    and should be in the local headers. Only minimal function
    prototypes need to be shared.
    
    As discussed on linux-arm-kernel, we want to avoid
    relative includes for the arch/arm/*omap* shared code:
    
    http://www.spinics.net/lists/linux-omap/msg80520.html
    
    So this patch re-adds a minimal plat/sram.h.
    
    The new plat/sram.h must not be included from drivers,
    that will break build for omap2+ CONFIG_MULTIPLATFORM.
    
    Note that this patch temporarily adds two more
    relative includes; Those will be removed in the
    following patch.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 160fa250c41e..4c85762107bd 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -32,6 +32,7 @@
 
 #include <trace/events/power.h>
 
+#include <asm/fncpy.h>
 #include <asm/suspend.h>
 #include <asm/system_misc.h>
 
@@ -40,8 +41,6 @@
 #include <plat/prcm.h>
 #include <plat-omap/dma-omap.h>
 
-#include "../plat-omap/sram.h"
-
 #include "soc.h"
 #include "common.h"
 #include "cm2xxx_3xxx.h"
@@ -52,6 +51,7 @@
 #include "prm2xxx_3xxx.h"
 #include "pm.h"
 #include "sdrc.h"
+#include "sram.h"
 #include "control.h"
 
 /* pm34xx errata defined in pm.h */

commit 8634155ef41d3a035f2ea0b6c5bed2806f2788bc
Merge: 6d02643d64b4 2bb2a5d30abb
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Oct 24 17:05:59 2012 -0700

    Merge tag 'omap-cleanup-a-for-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into omap-for-v3.8/cleanup-prcm
    
    The first set of OMAP PRM/CM-related cleanup patches for 3.8.
    Prepares for the future move of the PRM/CM code to drivers/.  Also
    includes some prcm.[ch] cleanup patches from the WDTIMER cleanup
    series that don't need external acks.
    
    Basic test logs for this branch on top of v3.7-rc2 are here:
    
    http://www.pwsan.com/omap/testlogs/prcm_cleanup_a_3.8/20121021123719/
    
    But due to the number of unrelated regressions present in v3.7-rc[12],
    it's not particularly usable as a testing base.  With reverts, fixes,
    and workarounds applied as documented in:
    
    http://www.pwsan.com/omap/testlogs/test_v3.7-rc2/20121020134755/README.txt
    
    the following test logs were obtained:
    
    http://www.pwsan.com/omap/testlogs/prcm_cleanup_a_3.8/20121020231757/
    
    which indicate that the series tests cleanly.
    
    Conflicts:
            arch/arm/mach-omap2/Makefile
            arch/arm/mach-omap2/clockdomain2xxx_3xxx.c
            arch/arm/mach-omap2/pm24xx.c

commit 856c3c5b28597f70068984d036bcee1d342ddb69
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Oct 16 00:08:53 2012 -0600

    ARM: OMAP3: PM: apply part of the erratum i582 workaround
    
    On OMAP34xx/35xx, and OMAP36xx chips with ES < 1.2, if the PER
    powerdomain goes to OSWR or OFF while CORE stays at CSWR or ON, or if,
    upon chip wakeup from OSWR or OFF, the CORE powerdomain goes ON before
    PER, the UART3/4 FIFOs and McBSP2/3 SIDETONE memories will be
    unusable.  This is erratum i582 in the OMAP36xx Silicon Errata
    document.
    
    This patch implements one of several parts of the workaround: the
    addition of the wakeup dependency between the PER and WKUP
    clockdomains, such that PER will wake up at the same time CORE_L3
    does.
    
    This is not a complete workaround.  For it to be complete:
    
    1. the PER powerdomain's next power state must not be set to OSWR or
       OFF if the CORE powerdomain's next power state is set to CSWR or
       ON;
    
    2. the UART3/4 FIFO and McBSP2/3 SIDETONE loopback tests should be run
       if the LASTPOWERSTATEENTERED bits for PER and CORE indicate that
       PER went OFF while CORE stayed on.  If loopback tests fail, then
       those devices will be unusable until PER and CORE can undergo a
       transition from ON to OSWR/OFF and back ON.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index ba670db1fd37..3a904de4313e 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -652,14 +652,17 @@ static void __init pm_errata_configure(void)
 		/* Enable the l2 cache toggling in sleep logic */
 		enable_omap3630_toggle_l2_on_restore();
 		if (omap_rev() < OMAP3630_REV_ES1_2)
-			pm34xx_errata |= PM_SDRC_WAKEUP_ERRATUM_i583;
+			pm34xx_errata |= (PM_SDRC_WAKEUP_ERRATUM_i583 |
+					  PM_PER_MEMORIES_ERRATUM_i582);
+	} else if (cpu_is_omap34xx()) {
+		pm34xx_errata |= PM_PER_MEMORIES_ERRATUM_i582;
 	}
 }
 
 int __init omap3_pm_init(void)
 {
 	struct power_state *pwrst, *tmp;
-	struct clockdomain *neon_clkdm, *mpu_clkdm;
+	struct clockdomain *neon_clkdm, *mpu_clkdm, *per_clkdm, *wkup_clkdm;
 	int ret;
 
 	if (!omap3_has_io_chain_ctrl())
@@ -711,6 +714,8 @@ int __init omap3_pm_init(void)
 
 	neon_clkdm = clkdm_lookup("neon_clkdm");
 	mpu_clkdm = clkdm_lookup("mpu_clkdm");
+	per_clkdm = clkdm_lookup("per_clkdm");
+	wkup_clkdm = clkdm_lookup("wkup_clkdm");
 
 #ifdef CONFIG_SUSPEND
 	omap_pm_suspend = omap3_pm_suspend;
@@ -727,6 +732,27 @@ int __init omap3_pm_init(void)
 	if (IS_PM34XX_ERRATUM(PM_RTA_ERRATUM_i608))
 		omap3630_ctrl_disable_rta();
 
+	/*
+	 * The UART3/4 FIFO and the sidetone memory in McBSP2/3 are
+	 * not correctly reset when the PER powerdomain comes back
+	 * from OFF or OSWR when the CORE powerdomain is kept active.
+	 * See OMAP36xx Erratum i582 "PER Domain reset issue after
+	 * Domain-OFF/OSWR Wakeup".  This wakeup dependency is not a
+	 * complete workaround.  The kernel must also prevent the PER
+	 * powerdomain from going to OSWR/OFF while the CORE
+	 * powerdomain is not going to OSWR/OFF.  And if PER last
+	 * power state was off while CORE last power state was ON, the
+	 * UART3/4 and McBSP2/3 SIDETONE devices need to run a
+	 * self-test using their loopback tests; if that fails, those
+	 * devices are unusable until the PER/CORE can complete a transition
+	 * from ON to OSWR/OFF and then back to ON.
+	 *
+	 * XXX Technically this workaround is only needed if off-mode
+	 * or OSWR is enabled.
+	 */
+	if (IS_PM34XX_ERRATUM(PM_PER_MEMORIES_ERRATUM_i582))
+		clkdm_add_wkdep(per_clkdm, wkup_clkdm);
+
 	clkdm_add_wkdep(neon_clkdm, mpu_clkdm);
 	if (omap_type() != OMAP2_DEVICE_TYPE_GP) {
 		omap3_secure_ram_storage =

commit ff4ae5d9319b86f940e410e92659c50f9879ff46
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Oct 21 01:01:11 2012 -0600

    ARM: OMAP2+: CM/hwmod: split CM functions into OMAP2, OMAP3-specific files
    
    Move OMAP3xxx-specific CM functions & macros into cm3xxx.[ch] and
    OMAP2xxx-specific macros into cm2xxx.[ch].  Move basic CM register
    access functions into static inline functions in cm2xxx_3xxx.h,
    leaving only OMAP2/3 hardreset functions in cm2xxx_3xxx.c.
    
    As part of this, split the CM and hwmod code that waits for devices to
    become ready into SoC-specific functions.
    
    This is in preparation for the upcoming move of this code to drivers/.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Reviewed-by: Russ Dill <Russ.Dill@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index c02c9ca9ef05..c0f8a7804bf7 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -44,10 +44,9 @@
 #include <plat/dma.h>
 
 #include "common.h"
-#include "cm2xxx_3xxx.h"
+#include "cm3xxx.h"
 #include "cm-regbits-34xx.h"
 #include "prm-regbits-34xx.h"
-
 #include "prm3xxx.h"
 #include "pm.h"
 #include "sdrc.h"

commit 139563ad27e7baad7935b8113940f0d804cf513b
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sun Oct 21 01:01:10 2012 -0600

    ARM: OMAP2+: PRM: split PRM functions into OMAP2, OMAP3-specific files
    
    Move OMAP3xxx-specific PRM functions & macros into prm3xxx.[ch] and
    OMAP2xxx-specific macros into prm2xxx.h.  (prm2xxx.c will be created
    by a subsequent patch when it's needed.)  Move basic PRM register
    access functions into static inline functions in prm2xxx_3xxx.h, leaving
    only OMAP2/3 hardreset functions in prm2xxx_3xxx.c.
    
    Also clarify the initcall function naming to reinforce that this code
    is specifically for the PRM IP block.
    
    This is in preparation for the upcoming powerdomain series and the
    upcoming move of this code to drivers/.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Reviewed-by: Russ Dill <Russ.Dill@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index ba670db1fd37..c02c9ca9ef05 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -48,7 +48,7 @@
 #include "cm-regbits-34xx.h"
 #include "prm-regbits-34xx.h"
 
-#include "prm2xxx_3xxx.h"
+#include "prm3xxx.h"
 #include "pm.h"
 #include "sdrc.h"
 #include "control.h"

commit e4c060db2c13f10de09101afc564763f9fd0019a
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Oct 5 13:25:59 2012 -0700

    ARM: OMAP: Split plat/cpu.h into local soc.h for mach-omap1 and mach-omap2
    
    We want to remove plat/cpu.h. To do this, let's first split
    it to private soc.h to mach-omap1 and mach-omap2. We have to
    keep plat/cpu.h around until the remaining drivers are fixed,
    so let's include the local soc.h in plat/cpu.h and for drivers
    still including plat/cpu.h.
    
    Once the drivers are fixed not to include plat/cpu.h, we
    can remove the file.
    
    This is needed for the ARM common zImage support.
    
    [tony@atomide.com: updated to not print a warning]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index a08e87eafbeb..160fa250c41e 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -42,6 +42,7 @@
 
 #include "../plat-omap/sram.h"
 
+#include "soc.h"
 #include "common.h"
 #include "cm2xxx_3xxx.h"
 #include "cm-regbits-34xx.h"

commit 622297fdec22310d57cc3222a8fc337993c7cd23
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 2 14:19:52 2012 -0700

    ARM: OMAP: Make plat/sram.h local to plat-omap
    
    We can move this from plat to be local to plat-omap
    for common ARM zImage support.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index bbe15cb1b874..a08e87eafbeb 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -35,12 +35,13 @@
 #include <asm/suspend.h>
 #include <asm/system_misc.h>
 
-#include <plat/sram.h>
 #include "clockdomain.h"
 #include "powerdomain.h"
 #include <plat/prcm.h>
 #include <plat-omap/dma-omap.h>
 
+#include "../plat-omap/sram.h"
+
 #include "common.h"
 #include "cm2xxx_3xxx.h"
 #include "cm-regbits-34xx.h"

commit 6832c95599e1a04f4b56b533718d1cda4689aec2
Merge: 46cddc01aa6a 3e6ece13d966
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Oct 17 11:21:34 2012 -0700

    Merge branch 'omap-for-v3.8/cleanup-headers-dss' into omap-for-v3.8/cleanup-headers
    
    Conflicts:
            arch/arm/mach-omap2/board-omap3logic.c
            arch/arm/mach-omap2/gpmc.c
            drivers/media/platform/omap/omap_vout.c
            drivers/media/platform/omap/omap_vout_vrfb.c

commit 99f0b8d6b09b0db6452d0d6e252bfa28049bbea9
Merge: 94c657853bd2 94709014ea8d
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Oct 17 11:07:18 2012 -0700

    Merge branch 'omap-for-v3.8/cleanup-headers-gpmc' into omap-for-v3.8/cleanup-headers
    
    Conflicts:
            arch/arm/mach-omap2/board-3430sdp.c
            arch/arm/mach-omap2/board-h4.c
            arch/arm/mach-omap2/board-rx51-peripherals.c
            arch/arm/mach-omap2/board-rx51.c
            arch/arm/mach-omap2/pm34xx.c
            drivers/mtd/nand/omap2.c
            drivers/mtd/onenand/omap2.c

commit 3e6ece13d966a20a38ee7adfac452a47455ccd7a
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Oct 17 00:46:45 2012 +0000

    ARM: OMAP: move plat-omap/include/plat/sdrc.h into mach-omap2/sdrc.h
    
    Remove arch/arm/plat-omap/include/plat/sdrc.h by folding its contents
    into arch/arm/mach-omap2/sdrc.h.  The objective is to assist Tony in
    cleaning out arch/arm/plat-omap/, as his upstreams request.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Tony Lindgren <tony@atomide.com>
    [tony@atomide.com: updated to remove rotate macros]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index ba670db1fd37..ee0bffc614be 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -38,7 +38,6 @@
 #include <plat/sram.h>
 #include "clockdomain.h"
 #include "powerdomain.h"
-#include <plat/sdrc.h>
 #include <plat/prcm.h>
 #include <plat/gpmc.h>
 #include <plat/dma.h>

commit 2b6c4e73248758bac8e1ed81b0d0664da0fff6f8
Author: Lokesh Vutla <lokeshvutla@ti.com>
Date:   Mon Oct 15 14:04:53 2012 -0700

    ARM: OMAP: DMA: Move plat/dma.h to plat-omap/dma-omap.h
    
    Move plat/dma.h to plat-omap/dma-omap.h as part of single
    zImage work
    
    Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index ba670db1fd37..baee8722b477 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -41,7 +41,7 @@
 #include <plat/sdrc.h>
 #include <plat/prcm.h>
 #include <plat/gpmc.h>
-#include <plat/dma.h>
+#include <plat-omap/dma-omap.h>
 
 #include "common.h"
 #include "cm2xxx_3xxx.h"

commit 3ef5d0071cf6c8b9a00b559232bb700ad59999d7
Author: Afzal Mohammed <afzal@ti.com>
Date:   Fri Oct 5 10:37:27 2012 +0530

    ARM: OMAP2+: gpmc: localize gpmc header
    
    Requirement of gpmc header outside of mach-omap2 has been
    cutoff, move gpmc header file in plat-omap folder to local
    mach-omap2 folder
    
    Objective - common zImage participation of omap
    
    Signed-off-by: Afzal Mohammed <afzal@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index ba670db1fd37..ed98f4f9e667 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -40,7 +40,7 @@
 #include "powerdomain.h"
 #include <plat/sdrc.h>
 #include <plat/prcm.h>
-#include <plat/gpmc.h>
+#include "gpmc.h"
 #include <plat/dma.h>
 
 #include "common.h"

commit 3c101c41fbe5daf88afbbd575542aa1d047812bb
Merge: f191f40c1819 7852ec0536ca
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Sep 12 20:42:36 2012 -0700

    Merge tag 'omap-cleanup-b-for-3.7' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into cleanup-makefile-sparse
    
    smatch and string-wrapping cleanups for the OMAP subarch code.
    
    These changes fix some of the more meaningful warnings that smatch
    returns for the OMAP subarch code, and unwraps strings that are
    wrapped at the 80-column boundary, to conform with the current
    practice.
    
    Basic build, boot, and PM logs are available here:
    
    http://www.pwsan.com/omap/testlogs/warnings_a_cleanup_3.7/20120912025927/

commit 4b25408f1f61c35b70a19a41053b5e5e3224e97f
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Aug 30 15:37:24 2012 -0700

    ARM: OMAP: Move gpio.h to include/linux/platform_data
    
    This way we can remove includes of plat/gpio.h which won't work
    with the single zImage support.
    
    Note that we also remove the cpu_class_is_omap2() check
    in gpio-omap.c as the drivers should not call it as we need to
    make it local to arch/arm/mach-omap2 for single zImage support.
    
    While at it, arrange the related includes in the standard way.
    
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: linux-mtd@lists.infradead.org
    Cc: alsa-devel@alsa-project.org
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 05bd8f02723f..90480f759974 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -28,6 +28,8 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
+#include <linux/platform_data/gpio-omap.h>
+
 #include <trace/events/power.h>
 
 #include <asm/suspend.h>

commit 7852ec0536ca39cefffc6301dc77f8ae55592926
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Jul 26 00:54:26 2012 -0600

    ARM: OMAP: unwrap strings
    
    Find and unwrap wrapped strings in the style:
    
            pr_debug("clockdomain: hardware cannot set/clear wake up of "
                     "%s when %s wakes up\n", clkdm1->name, clkdm2->name);
    
    Keeping these strings contiguous seems to be the current Linux kernel
    policy.
    
    The offending lines were found with the following command:
    
        pcregrep -rnM '"\s*$\s*"' arch/arm/*omap*
    
    While here, some messages have been clarified, some pr_warning(
    ... calls have been converted to pr_warn( ..., and some printk(KERN_*
    ... have been converted to pr_*.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 05bd8f02723f..0e8872e1b3ee 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -389,9 +389,8 @@ static int omap3_pm_suspend(void)
 	list_for_each_entry(pwrst, &pwrst_list, node) {
 		state = pwrdm_read_prev_pwrst(pwrst->pwrdm);
 		if (state > pwrst->next_state) {
-			pr_info("Powerdomain (%s) didn't enter "
-				"target state %d\n",
-			       pwrst->pwrdm->name, pwrst->next_state);
+			pr_info("Powerdomain (%s) didn't enter target state %d\n",
+				pwrst->pwrdm->name, pwrst->next_state);
 			ret = -1;
 		}
 		omap_set_pwrdm_state(pwrst->pwrdm, pwrst->saved_state);
@@ -731,8 +730,7 @@ int __init omap3_pm_init(void)
 		omap3_secure_ram_storage =
 			kmalloc(0x803F, GFP_KERNEL);
 		if (!omap3_secure_ram_storage)
-			pr_err("Memory allocation failed when "
-			       "allocating for secure sram context\n");
+			pr_err("Memory allocation failed when allocating for secure sram context\n");
 
 		local_irq_disable();
 		local_fiq_disable();

commit e0e29fd74c3c8bd2ef83bbaa73d528d58a944610
Author: Kevin Hilman <khilman@ti.com>
Date:   Tue Aug 7 11:28:06 2012 -0700

    Revert "ARM: OMAP3: PM: call pre/post transition per powerdomain"
    
    This reverts commit 58f0829b7186150318c79515f0e0850c5e7a9c89.
    
    Converstion to per-pwrdm per/post transition calls was a bit
    premature.  Only tracking MPU, PER & CORE in the idle path means we
    lose the accounting for all the other powerdomains which may also
    transition in idle.  On OMAP3, due to autodeps, several powerdomains
    transition along with MPU (e.g. DSS, USBHOST), and the accounting for
    these was lost with this patch.  Since the accounting includes the
    context loss counters, drivers for devices in those power domains
    would never notice context lost, so would likely hang after any
    off-mode transitions.
    
    This patch should be revisited when the upcoming clkdm/pwrmdm/voltdm
    use-counting seires is merged since then we can properly do accounting
    without relying on a call in the idle path.
    
    In addition, the original patch had another bug because the PER
    powerdomain accounting was not updated until after the GPIO resume
    hook is called.  Since gpio_resume_after_idle() checks the context
    loss count (which is not yet updated) it would not properly restore
    context, leaving the GPIO banks in an undefined state.
    
    Cc: Jean Pihet <jean.pihet@newoldbits.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Reported-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index e4fc88c65dbd..05bd8f02723f 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -272,21 +272,16 @@ void omap_sram_idle(void)
 	per_next_state = pwrdm_read_next_pwrst(per_pwrdm);
 	core_next_state = pwrdm_read_next_pwrst(core_pwrdm);
 
-	if (mpu_next_state < PWRDM_POWER_ON) {
-		pwrdm_pre_transition(mpu_pwrdm);
-		pwrdm_pre_transition(neon_pwrdm);
-	}
+	pwrdm_pre_transition(NULL);
 
 	/* PER */
 	if (per_next_state < PWRDM_POWER_ON) {
-		pwrdm_pre_transition(per_pwrdm);
 		per_going_off = (per_next_state == PWRDM_POWER_OFF) ? 1 : 0;
 		omap2_gpio_prepare_for_idle(per_going_off);
 	}
 
 	/* CORE */
 	if (core_next_state < PWRDM_POWER_ON) {
-		pwrdm_pre_transition(core_pwrdm);
 		if (core_next_state == PWRDM_POWER_OFF) {
 			omap3_core_save_context();
 			omap3_cm_save_context();
@@ -339,20 +334,14 @@ void omap_sram_idle(void)
 			omap2_prm_clear_mod_reg_bits(OMAP3430_AUTO_OFF_MASK,
 					       OMAP3430_GR_MOD,
 					       OMAP3_PRM_VOLTCTRL_OFFSET);
-		pwrdm_post_transition(core_pwrdm);
 	}
 	omap3_intc_resume_idle();
 
+	pwrdm_post_transition(NULL);
+
 	/* PER */
-	if (per_next_state < PWRDM_POWER_ON) {
+	if (per_next_state < PWRDM_POWER_ON)
 		omap2_gpio_resume_after_idle();
-		pwrdm_post_transition(per_pwrdm);
-	}
-
-	if (mpu_next_state < PWRDM_POWER_ON) {
-		pwrdm_post_transition(mpu_pwrdm);
-		pwrdm_post_transition(neon_pwrdm);
-	}
 }
 
 static void omap3_pm_idle(void)

commit a5ebba6b54bc8038a38d3eacac3a79bbeaf3ee24
Merge: e81218f5f0fd 6b21a9ce0402
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 23 17:43:53 2012 -0700

    Merge tag 'pm' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull arm-soc power management changes from Arnd Bergmann:
     "These are various power management related changes, mainly concerning
      cpuidle on i.MX and OMAP, as well as a the move of the omap
      smartreflex driver to live in the power subsystem."
    
    Fix up conflicts in arch/arm/mach-{imx/mach-imx6q.c,omap2/prm2xxx_3xxx.h}
    
    * tag 'pm' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (37 commits)
      ARM: OMAP2+: PM: fix IRQ_NOAUTOEN removal by mis-merge
      ARM: OMAP2+: do not allow SmartReflex to be built as a module
      ARM: OMAP2: Use hwmod to initialize mmc for 2420
      ARM: OMAP3: PM: cpuidle: optimize the clkdm idle latency in C1 state
      ARM: OMAP3: PM: cpuidle: optimize the PER latency in C1 state
      ARM: OMAP3: PM: cpuidle: default to C1 in next_valid_state
      ARM: OMAP3: PM: cleanup cam_pwrdm leftovers
      ARM: OMAP3: PM: call pre/post transition per powerdomain
      ARM: OMAP2+: powerdomain: allow pre/post transtion to be per pwrdm
      ARM: OMAP3: PM: Remove IO Daisychain control from cpuidle
      ARM: OMAP3PLUS: hwmod: reconfigure IO Daisychain during hwmod mux
      ARM: OMAP3+: PRM: Enable IO wake up
      ARM: OMAP4: PRM: Add IO Daisychain support
      ARM: OMAP3: PM: Move IO Daisychain function to omap3 prm file
      ARM: OMAP3: PM: correct enable/disable of daisy io chain
      ARM: OMAP2+: PRM: fix compile for OMAP4-only build
      W1: OMAP HDQ1W: use runtime PM
      ARM: OMAP2+: HDQ1W: use omap_device
      W1: OMAP HDQ1W: use 32-bit register accesses
      W1: OMAP HDQ1W: allow driver to be built on all OMAP2+
      ...

commit f6f1f12f6d4e9e4a44587e58ec96db25673083ec
Merge: e0246e8ecad1 a77e1c4d09c8
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Jun 29 06:07:08 2012 -0700

    Merge tag 'omap-devel-d-for-3.6' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into fixes-non-critical
    
    Some OMAP AM35xx fixes.
    
    The powerdomain and clockdomain data for the AM35xx are finally fixed.
    The AM35xx EMAC/MDIO Ethernet controller integration code has been
    converted to use the OMAP device and hwmod framework.  Also the UART4
    and HSOTGUSB warnings have been fixed.

commit 34059a878f5cb20652cbc937f35c925f2b378831
Author: Kevin Hilman <khilman@ti.com>
Date:   Tue Jun 19 09:54:38 2012 -0700

    ARM: OMAP3: PM: cleanup cam_pwrdm leftovers
    
    commit e7410cf7 (OMAP3: PM: move device-specific special cases from PM
    core into CPUidle) moved mangement of cam_pwrdm to CPUidle but left
    some remnants behind, namely the call to clkcm_allo_idle() for the
    clockdomains in the MPU pwrdm.  Remove these since they are not
    necessary and cause unwanted latency in the idle path.
    
    Acked-by: Tero Kristo <Tero Kristo <t-kristo@ti.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Grazvydas Ignotas <notasas@gmail.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index dec2d55d7182..e63fdd02c6f5 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -70,7 +70,6 @@ void (*omap3_do_wfi_sram)(void);
 
 static struct powerdomain *mpu_pwrdm, *neon_pwrdm;
 static struct powerdomain *core_pwrdm, *per_pwrdm;
-static struct powerdomain *cam_pwrdm;
 
 static void omap3_core_save_context(void)
 {
@@ -354,8 +353,6 @@ void omap_sram_idle(void)
 		pwrdm_post_transition(mpu_pwrdm);
 		pwrdm_post_transition(neon_pwrdm);
 	}
-
-	clkdm_allow_idle(mpu_pwrdm->pwrdm_clkdms[0]);
 }
 
 static void omap3_pm_idle(void)
@@ -716,7 +713,6 @@ int __init omap3_pm_init(void)
 	neon_pwrdm = pwrdm_lookup("neon_pwrdm");
 	per_pwrdm = pwrdm_lookup("per_pwrdm");
 	core_pwrdm = pwrdm_lookup("core_pwrdm");
-	cam_pwrdm = pwrdm_lookup("cam_pwrdm");
 
 	neon_clkdm = clkdm_lookup("neon_clkdm");
 	mpu_clkdm = clkdm_lookup("mpu_clkdm");

commit 58f0829b7186150318c79515f0e0850c5e7a9c89
Author: Kevin Hilman <khilman@ti.com>
Date:   Fri May 11 15:47:17 2012 -0700

    ARM: OMAP3: PM: call pre/post transition per powerdomain
    
    We only need to call the pre/post transtion methods when we know the
    power state is changing.  First, split up the pre/post transition
    calls to be per-powerdomain, and then make them conditional on whether
    the power domain is actually changing states.
    
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Grazvydas Ignotas <notasas@gmail.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 0bbbc8c82fd8..dec2d55d7182 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -273,16 +273,21 @@ void omap_sram_idle(void)
 	per_next_state = pwrdm_read_next_pwrst(per_pwrdm);
 	core_next_state = pwrdm_read_next_pwrst(core_pwrdm);
 
-	pwrdm_pre_transition(NULL);
+	if (mpu_next_state < PWRDM_POWER_ON) {
+		pwrdm_pre_transition(mpu_pwrdm);
+		pwrdm_pre_transition(neon_pwrdm);
+	}
 
 	/* PER */
 	if (per_next_state < PWRDM_POWER_ON) {
+		pwrdm_pre_transition(per_pwrdm);
 		per_going_off = (per_next_state == PWRDM_POWER_OFF) ? 1 : 0;
 		omap2_gpio_prepare_for_idle(per_going_off);
 	}
 
 	/* CORE */
 	if (core_next_state < PWRDM_POWER_ON) {
+		pwrdm_pre_transition(core_pwrdm);
 		if (core_next_state == PWRDM_POWER_OFF) {
 			omap3_core_save_context();
 			omap3_cm_save_context();
@@ -335,14 +340,20 @@ void omap_sram_idle(void)
 			omap2_prm_clear_mod_reg_bits(OMAP3430_AUTO_OFF_MASK,
 					       OMAP3430_GR_MOD,
 					       OMAP3_PRM_VOLTCTRL_OFFSET);
+		pwrdm_post_transition(core_pwrdm);
 	}
 	omap3_intc_resume_idle();
 
-	pwrdm_post_transition(NULL);
-
 	/* PER */
-	if (per_next_state < PWRDM_POWER_ON)
+	if (per_next_state < PWRDM_POWER_ON) {
 		omap2_gpio_resume_after_idle();
+		pwrdm_post_transition(per_pwrdm);
+	}
+
+	if (mpu_next_state < PWRDM_POWER_ON) {
+		pwrdm_post_transition(mpu_pwrdm);
+		pwrdm_post_transition(neon_pwrdm);
+	}
 
 	clkdm_allow_idle(mpu_pwrdm->pwrdm_clkdms[0]);
 }

commit e055548953355b6e69c56f9e54388845b29b4e97
Author: Kevin Hilman <khilman@ti.com>
Date:   Fri May 11 16:00:24 2012 -0700

    ARM: OMAP2+: powerdomain: allow pre/post transtion to be per pwrdm
    
    Iteration over all power domains in the idle path is unnecessary since
    only power domains that are transitioning need to be accounted for.
    Also PRCM register accesses are known to be expensive, so the
    additional latency added to the idle path is signficiant.
    
    In order allow the pre/post transitions to be isolated and called
    per-pwrdm, change the API so passing in a specific power domain will
    trigger the pre/post transtion accounting for only that specific power
    domain.  Passing NULL means iterating over all power domains as is
    current behavior.
    
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Grazvydas Ignotas <notasas@gmail.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index e67d898433fb..0bbbc8c82fd8 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -273,7 +273,7 @@ void omap_sram_idle(void)
 	per_next_state = pwrdm_read_next_pwrst(per_pwrdm);
 	core_next_state = pwrdm_read_next_pwrst(core_pwrdm);
 
-	pwrdm_pre_transition();
+	pwrdm_pre_transition(NULL);
 
 	/* PER */
 	if (per_next_state < PWRDM_POWER_ON) {
@@ -338,7 +338,7 @@ void omap_sram_idle(void)
 	}
 	omap3_intc_resume_idle();
 
-	pwrdm_post_transition();
+	pwrdm_post_transition(NULL);
 
 	/* PER */
 	if (per_next_state < PWRDM_POWER_ON)

commit 9a17d88e0586bb7189655f8f99484a872a474626
Merge: 6b16351acbd4 fafcdd53220f
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Jun 25 07:41:17 2012 -0700

    Merge tag 'omap-devel-c-for-3.6' of git://git.kernel.org/pub/scm/linux/kernel/git/pjw/omap-pending into devel-pm
    
    Reimplement the OMAP PRCM I/O chain code.  Needed for I/O wakeups to
    work correctly.
    
    Conflicts:
            arch/arm/mach-omap2/prm2xxx_3xxx.c

commit fafcdd53220f44d7ae2f06a9ce20c8d550df2d9b
Author: Vishwanath BS <vishwanath.bs@ti.com>
Date:   Wed May 2 02:44:40 2012 -0600

    ARM: OMAP3: PM: Remove IO Daisychain control from cpuidle
    
    As IO Daisy chain sequence is triggered via hwmod mux, there is no need to
    control it from cpuidle path for OMAP3.
    
    Also as omap3_disable_io_chain is no longer being used, just remove the
    function.
    
    Signed-off-by: Vishwanath BS <vishwanath.bs@ti.com>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Reviewed-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 9d6cb7cc94ab..9d8258f16666 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -272,13 +272,6 @@ void omap_sram_idle(void)
 	/* Enable IO-PAD and IO-CHAIN wakeups */
 	per_next_state = pwrdm_read_next_pwrst(per_pwrdm);
 	core_next_state = pwrdm_read_next_pwrst(core_pwrdm);
-	if (omap3_has_io_wakeup() &&
-	    (per_next_state < PWRDM_POWER_ON ||
-	     core_next_state < PWRDM_POWER_ON)) {
-		omap2_prm_set_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD, PM_WKEN);
-		if (omap3_has_io_chain_ctrl())
-			omap3xxx_prm_reconfigure_io_chain();
-	}
 
 	pwrdm_pre_transition();
 
@@ -351,13 +344,6 @@ void omap_sram_idle(void)
 	if (per_next_state < PWRDM_POWER_ON)
 		omap2_gpio_resume_after_idle();
 
-	/* Disable IO-PAD and IO-CHAIN wakeup */
-	if (omap3_has_io_wakeup() &&
-	    (per_next_state < PWRDM_POWER_ON ||
-	     core_next_state < PWRDM_POWER_ON))
-		omap2_prm_clear_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD,
-					     PM_WKEN);
-
 	clkdm_allow_idle(mpu_pwrdm->pwrdm_clkdms[0]);
 }
 

commit 09659fa72bf638ae986b8b80cf99309768dd0b32
Author: Vishwanath BS <vishwanath.bs@ti.com>
Date:   Fri Jun 22 08:40:02 2012 -0600

    ARM: OMAP3: PM: Move IO Daisychain function to omap3 prm file
    
    Since IO Daisychain modifies only PRM registers, it makes sense to move
    it to PRM File. Also changed the timeout value for IO chain enable to
    100us and added a wait for status disable at the end.
    
    Thanks to Nishanth Menon <nm@ti.com> for contributing a fix to the
    timeout code waiting for WUCLKOUT to go high.
    
    Signed-off-by: Vishwanath BS <vishwanath.bs@ti.com>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Cc: Nishanth Menon <nm@ti.com>
    Reviewed-by: Rajendra Nayak <rnayak@ti.com>
    [paul@pwsan.com: renamed omap3_trigger_io_chain() to better describe the
     end result and to match other PRM functions; removed
     omap3_disable_io_chain(); moved MAX_IOPAD_LATCH_TIME to prcm-common as it
     will also be used by the OMAP4 code; removed unnecessary barrier;
     added kerneldoc; added credit for fix from Nishanth]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 6d7f0d8a3103..9d6cb7cc94ab 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -72,34 +72,6 @@ static struct powerdomain *mpu_pwrdm, *neon_pwrdm;
 static struct powerdomain *core_pwrdm, *per_pwrdm;
 static struct powerdomain *cam_pwrdm;
 
-static void omap3_enable_io_chain(void)
-{
-	int timeout = 0;
-
-	omap2_prm_set_mod_reg_bits(OMAP3430_EN_IO_CHAIN_MASK, WKUP_MOD,
-				   PM_WKEN);
-	/* Do a readback to assure write has been done */
-	omap2_prm_read_mod_reg(WKUP_MOD, PM_WKEN);
-
-	while (!(omap2_prm_read_mod_reg(WKUP_MOD, PM_WKST) &
-		 OMAP3430_ST_IO_CHAIN_MASK)) {
-		timeout++;
-		if (timeout > 1000) {
-			pr_err("Wake up daisy chain activation failed.\n");
-			return;
-		}
-	}
-	omap2_prm_clear_mod_reg_bits(OMAP3430_EN_IO_CHAIN_MASK, WKUP_MOD,
-				     PM_WKEN);
-
-}
-
-static void omap3_disable_io_chain(void)
-{
-	omap2_prm_clear_mod_reg_bits(OMAP3430_EN_IO_CHAIN_MASK, WKUP_MOD,
-				     PM_WKEN);
-}
-
 static void omap3_core_save_context(void)
 {
 	omap3_ctrl_save_padconf();
@@ -305,7 +277,7 @@ void omap_sram_idle(void)
 	     core_next_state < PWRDM_POWER_ON)) {
 		omap2_prm_set_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD, PM_WKEN);
 		if (omap3_has_io_chain_ctrl())
-			omap3_enable_io_chain();
+			omap3xxx_prm_reconfigure_io_chain();
 	}
 
 	pwrdm_pre_transition();
@@ -382,12 +354,9 @@ void omap_sram_idle(void)
 	/* Disable IO-PAD and IO-CHAIN wakeup */
 	if (omap3_has_io_wakeup() &&
 	    (per_next_state < PWRDM_POWER_ON ||
-	     core_next_state < PWRDM_POWER_ON)) {
+	     core_next_state < PWRDM_POWER_ON))
 		omap2_prm_clear_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD,
 					     PM_WKEN);
-		if (omap3_has_io_chain_ctrl())
-			omap3_disable_io_chain();
-	}
 
 	clkdm_allow_idle(mpu_pwrdm->pwrdm_clkdms[0]);
 }

commit fe7ea0062f2f846bb68447c7b813b9230285dbeb
Author: Mohan V <mohanv@ti.com>
Date:   Fri Jun 22 08:40:02 2012 -0600

    ARM: OMAP3: PM: correct enable/disable of daisy io chain
    
    Currently the enabling and disabling of IO Daisy chain is not
    according to the TRM. The below steps are followed to enable/
    disable the IO chain, based loosely on the "Sec 3.5.7.2.2
    I/O Wake-Up Mechanism" section in OMAP3630 Public TRM[1].
    
    Steps to enable IO chain:
    [a] Set PM_WKEN_WKUP.EN_IO bit
    [b] Set the PM_WKEN_WKUP.EN_IO_CHAIN bit
    [c] Poll for PM_WKST_WKUP.ST_IO_CHAIN.
    [d] When ST_IO_CHAIN bit set to 1, clear PM_WKEN_WKUP.EN_IO_CHAIN
    [e] Clear ST_IO_CHAIN bit.
    
    Steps to disable IO chain:
    [a] Clear PM_WKEN_WKUP.EN_IO_CHAIN bit
    [b] Clear PM_WKEN_WKUP.EN_IO bit
    [c] Clear PM_WKST_WKUP.ST_IO bit by writing 1 to it.
    
    Step [e] & [c] in each case can be skipped, as these are handled
    by the PRCM interrupt handler later.
    
    [1] http://focus.ti.com/pdfs/wtbu/OMAP36xx_ES1.x_PUBLIC_TRM_vV.zip
    
    Signed-off-by: Mohan V <mohanv@ti.com>
    Signed-off-by: Vishwanath BS <vishwanath.bs@ti.com>
    [paul@pwsan.com: modified commit message to clarify that these steps are
     based loosely on the TRM section, rather than documented exactly]
    Reviewed-by: Rajendra Nayak <rnayak@ti.com>
    [paul@pwsan.com: resolved new warnings from checkpatch]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index a34023d0ca7c..6d7f0d8a3103 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -81,16 +81,17 @@ static void omap3_enable_io_chain(void)
 	/* Do a readback to assure write has been done */
 	omap2_prm_read_mod_reg(WKUP_MOD, PM_WKEN);
 
-	while (!(omap2_prm_read_mod_reg(WKUP_MOD, PM_WKEN) &
+	while (!(omap2_prm_read_mod_reg(WKUP_MOD, PM_WKST) &
 		 OMAP3430_ST_IO_CHAIN_MASK)) {
 		timeout++;
 		if (timeout > 1000) {
 			pr_err("Wake up daisy chain activation failed.\n");
 			return;
 		}
-		omap2_prm_set_mod_reg_bits(OMAP3430_ST_IO_CHAIN_MASK,
-					   WKUP_MOD, PM_WKEN);
 	}
+	omap2_prm_clear_mod_reg_bits(OMAP3430_EN_IO_CHAIN_MASK, WKUP_MOD,
+				     PM_WKEN);
+
 }
 
 static void omap3_disable_io_chain(void)

commit a819c4f16d5a2708c11e708fd59a96565c5384a8
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Thu Apr 19 11:17:45 2012 -0700

    ARM: OMAP3: PM: Only access IVA if one exists
    
    prcm_setup_regs() blindly accesses IVA bits
    in the PRM and calls omap3_iva_idle() which
    does more IVA related register accesses.
    Only do this if the IVA hardware actually
    exists.
    
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index a34023d0ca7c..7eb8c5e4183e 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -581,10 +581,13 @@ static void __init prcm_setup_regs(void)
 			  OMAP3430_PER_MOD, OMAP3430_PM_MPUGRPSEL);
 
 	/* Don't attach IVA interrupts */
-	omap2_prm_write_mod_reg(0, WKUP_MOD, OMAP3430_PM_IVAGRPSEL);
-	omap2_prm_write_mod_reg(0, CORE_MOD, OMAP3430_PM_IVAGRPSEL1);
-	omap2_prm_write_mod_reg(0, CORE_MOD, OMAP3430ES2_PM_IVAGRPSEL3);
-	omap2_prm_write_mod_reg(0, OMAP3430_PER_MOD, OMAP3430_PM_IVAGRPSEL);
+	if (omap3_has_iva()) {
+		omap2_prm_write_mod_reg(0, WKUP_MOD, OMAP3430_PM_IVAGRPSEL);
+		omap2_prm_write_mod_reg(0, CORE_MOD, OMAP3430_PM_IVAGRPSEL1);
+		omap2_prm_write_mod_reg(0, CORE_MOD, OMAP3430ES2_PM_IVAGRPSEL3);
+		omap2_prm_write_mod_reg(0, OMAP3430_PER_MOD,
+					OMAP3430_PM_IVAGRPSEL);
+	}
 
 	/* Clear any pending 'reset' flags */
 	omap2_prm_write_mod_reg(0xffffffff, MPU_MOD, OMAP2_RM_RSTST);
@@ -598,7 +601,9 @@ static void __init prcm_setup_regs(void)
 	/* Clear any pending PRCM interrupts */
 	omap2_prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
 
-	omap3_iva_idle();
+	if (omap3_has_iva())
+		omap3_iva_idle();
+
 	omap3_d2d_idle();
 }
 

commit 4564747649db987722aa781280eb8325c6a5a1a8
Merge: f8f5701bdaf9 1ce029968718
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Jun 4 02:09:45 2012 -0700

    Merge branch 'for_3.5/fixes/pm' of git://git.kernel.org/pub/scm/linux/kernel/git/khilman/linux-omap-pm into fixes

commit f465d145d76803fe6332092775d891c8c509aa44
Merge: 30b842889eea 80b9abf97346
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat May 26 13:14:01 2012 -0700

    Merge tag 'cleanup-initcall' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull sweeping late_initcall cleanup for arm-soc from Olof Johansson:
     "This is a patch series from Shawn Guo that moves from individual
      late_initcalls() to using a member in the machine structure to invoke
      a platform's late initcalls.
    
      This cleanup is a step in the move towards multiplatform kernels since
      it would reduce the need to check for compatible platforms in each and
      every initcall."
    
    Fix up trivial conflicts in arch/arm/mach-{exynos/mach-universal_c210.c,
    imx/mach-cpuimx51.c, omap2/board-generic.c} due to changes nearby (and,
    in the case of cpuimx51.c the board support being deleted)
    
    * tag 'cleanup-initcall' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc:
      ARM: ux500: use machine specific hook for late init
      ARM: tegra: use machine specific hook for late init
      ARM: shmobile: use machine specific hook for late init
      ARM: sa1100: use machine specific hook for late init
      ARM: s3c64xx: use machine specific hook for late init
      ARM: prima2: use machine specific hook for late init
      ARM: pnx4008: use machine specific hook for late init
      ARM: omap2: use machine specific hook for late init
      ARM: omap1: use machine specific hook for late init
      ARM: msm: use machine specific hook for late init
      ARM: imx: use machine specific hook for late init
      ARM: exynos: use machine specific hook for late init
      ARM: ep93xx: use machine specific hook for late init
      ARM: davinci: use machine specific hook for late init
      ARM: provide a late_initcall hook for platform initialization

commit 99b59df04899a048d1a3ed8bc2b1263779816868
Author: Kevin Hilman <khilman@ti.com>
Date:   Fri Apr 27 16:05:51 2012 -0700

    ARM: OMAP3: PM: fix shared PRCM interrupts: leave disabled at boot
    
    By default, request_irq() will auto-enable the requested IRQ.
    
    For PRCM interrupts, we may want to avoid that until the PM core code
    is fully ready to handle the interrupts.  This is particularily true
    for IO pad interrupts on OMAP3, which are shared between the hwmod
    core and the PRM core.
    
    In order to avoid PRCM IO-chain interrupts until the PM core is ready
    to handle them, ready, set the IRQ_NOAUTOEN flag for the PRCM IO-chain
    interrupt,  which means it will remain disabled after request_irq().
    
    Then, explicitly enable the PRCM interrupts after the request_irq() in
    the PM core (but not in the hwmod core.)
    
    Special thanks to Tero Kristo for suggesting to isolate the fix to
    only the IO-chain interrupt on OMAP3 instead of all PRCM interrupts.
    
    Cc: Tero Kristo <t-kristo@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 703bd1099259..4f44ee517f78 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -729,6 +729,7 @@ static int __init omap3_pm_init(void)
 	ret = request_irq(omap_prcm_event_to_irq("io"),
 		_prcm_int_handle_io, IRQF_SHARED | IRQF_NO_SUSPEND, "pm_io",
 		omap3_pm_init);
+	enable_irq(omap_prcm_event_to_irq("io"));
 
 	if (ret) {
 		pr_err("pm: Failed to request pm_io irq\n");

commit bbd707acee279a61177a604822db92e8164d00db
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Thu Apr 26 16:06:50 2012 +0800

    ARM: omap2: use machine specific hook for late init
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 703bd1099259..c769b888e2c8 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -699,15 +699,12 @@ static void __init pm_errata_configure(void)
 	}
 }
 
-static int __init omap3_pm_init(void)
+int __init omap3_pm_init(void)
 {
 	struct power_state *pwrst, *tmp;
 	struct clockdomain *neon_clkdm, *per_clkdm, *mpu_clkdm, *core_clkdm;
 	int ret;
 
-	if (!cpu_is_omap34xx())
-		return -ENODEV;
-
 	if (!omap3_has_io_chain_ctrl())
 		pr_warning("PM: no software I/O chain control; some wakeups may be lost\n");
 
@@ -808,5 +805,3 @@ static int __init omap3_pm_init(void)
 err1:
 	return ret;
 }
-
-late_initcall(omap3_pm_init);

commit eeb3711b89d68e147e05e7b43a49ecc5009dc157
Author: Paul Walmsley <paul@pwsan.com>
Date:   Fri Apr 13 06:34:32 2012 -0600

    ARM: OMAP2+: clean up some cppcheck warnings
    
    Resolve some warnings identified by cppcheck in arch/arm/mach-omap2:
    
        [arch/arm/mach-omap2/usb-tusb6010.c:129]: (style) Checking if unsigned variable 'tmp' is less than zero.
        [arch/arm/mach-omap2/prm_common.c:241]: (error) Possible null pointer dereference: irq_setup - otherwise it is redundant to check if irq_setup is null at line 247
        [arch/arm/mach-omap2/pm34xx.c:790]: (style) Variable 'per_clkdm' is assigned a value that is never used
        [arch/arm/mach-omap2/pm34xx.c:790]: (style) Variable 'core_clkdm' is assigned a value that is never used
        [arch/arm/mach-omap2/pm24xx.c:185]: (style) Variable 'only_idle' is assigned a value that is never used
        [arch/arm/mach-omap2/mux.c:254]: (error) Possible null pointer dereference: mux
        [arch/arm/mach-omap2/mux.c:258]: (error) Possible null pointer dereference: mux
        [arch/arm/mach-omap2/gpmc-onenand.c:178]: (style) Variable 'tick_ns' is assigned a value that is never used
        [arch/arm/mach-omap2/gpio.c:56]: (error) Possible null pointer dereference: pdata - otherwise it is redundant to check if pdata is null at line 57
        [arch/arm/mach-omap2/devices.c:45]: (style) Variable 'l' is assigned a value that is never used
        [arch/arm/mach-omap2/board-omap3evm.c:641] -> [arch/arm/mach-omap2/board-omap3evm.c:639]: (style) Found duplicate branches for if and else.
        [arch/arm/mach-omap2/am35xx-emac.c:95]: (style) Variable 'regval' is assigned a value that is never used
        [arch/arm/mach-omap2/devices.c:74]: (style) Variable 'l' is assigned a value that is never used
        [arch/arm/mach-omap2/pm34xx.c:277]: (style) Variable 'per_prev_state' is assigned a value that is never used
        [arch/arm/plat-omap/dmtimer.c:352]: (error) Possible null pointer dereference: timer - otherwise it is redundant to check if timer is null at line 354
        [arch/arm/plat-omap/omap_device.c:478]: (style) Variable 'c' is assigned a value that is never used
        [arch/arm/plat-omap/usb.c:42]: (style) Variable 'status' is assigned a value that is never used
        [arch/arm/mach-omap1/clock.c:197]: (style) Variable 'dpll1_rate' is assigned a value that is never used
        [arch/arm/mach-omap1/lcd_dma.c:60]: (style) struct or union member 'lcd_dma_info::size' is never used
        [arch/arm/mach-omap1/pm.c:572]: (style) Variable 'entry' is assigned a value that is never used
    
    Some of them are pretty good catches, such as gpio.c:56 and
    usb-tusb6010.c:129.
    
    Thanks to Jarkko Nikula for some comments on the sscanf() warnings.
    It seems that the kernel sscanf() ignores the field width anyway for the
    %d format, so those changes have been dropped from this second version.
    
    Thanks to Daniel Marjamki <daniel.marjamaki@gmail.com> for pointing
    out that a variable was unnecessarily marked static in the
    board-omap3evm.c change.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Jarkko Nikula <jarkko.nikula@bitmer.com>
    Cc: Charulatha Varadarajan <charu@ti.com>
    Cc: Daniel Marjamki <daniel.marjamaki@gmail.com>
    Cc: Tarun Kanti DebBarma <tarun.kanti@ti.com>
    Reviewed-by: Charulatha Varadarajan <charu@ti.com> # for gpio.c

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 703bd1099259..8b43aefba0ea 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -273,7 +273,7 @@ void omap_sram_idle(void)
 	int per_next_state = PWRDM_POWER_ON;
 	int core_next_state = PWRDM_POWER_ON;
 	int per_going_off;
-	int core_prev_state, per_prev_state;
+	int core_prev_state;
 	u32 sdrc_pwr = 0;
 
 	mpu_next_state = pwrdm_read_next_pwrst(mpu_pwrdm);
@@ -375,10 +375,8 @@ void omap_sram_idle(void)
 	pwrdm_post_transition();
 
 	/* PER */
-	if (per_next_state < PWRDM_POWER_ON) {
-		per_prev_state = pwrdm_read_prev_pwrst(per_pwrdm);
+	if (per_next_state < PWRDM_POWER_ON)
 		omap2_gpio_resume_after_idle();
-	}
 
 	/* Disable IO-PAD and IO-CHAIN wakeup */
 	if (omap3_has_io_wakeup() &&
@@ -702,7 +700,7 @@ static void __init pm_errata_configure(void)
 static int __init omap3_pm_init(void)
 {
 	struct power_state *pwrst, *tmp;
-	struct clockdomain *neon_clkdm, *per_clkdm, *mpu_clkdm, *core_clkdm;
+	struct clockdomain *neon_clkdm, *mpu_clkdm;
 	int ret;
 
 	if (!cpu_is_omap34xx())
@@ -757,8 +755,6 @@ static int __init omap3_pm_init(void)
 
 	neon_clkdm = clkdm_lookup("neon_clkdm");
 	mpu_clkdm = clkdm_lookup("mpu_clkdm");
-	per_clkdm = clkdm_lookup("per_clkdm");
-	core_clkdm = clkdm_lookup("core_clkdm");
 
 #ifdef CONFIG_SUSPEND
 	omap_pm_suspend = omap3_pm_suspend;

commit 08956f1c5883f66c2e547f8137061c6b58ccbb53
Merge: 3916043576ec 4ba7c3c3c656
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Apr 3 11:31:38 2012 -0700

    Merge branch 'for_3.4/fixes/pm' of git://git.kernel.org/pub/scm/linux/kernel/git/khilman/linux-omap-pm into fixes

commit 0195c00244dc2e9f522475868fa278c473ba7339
Merge: f21ce8f8447c 141124c02059
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 28 15:58:21 2012 -0700

    Merge tag 'split-asm_system_h-for-linus-20120328' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-asm_system
    
    Pull "Disintegrate and delete asm/system.h" from David Howells:
     "Here are a bunch of patches to disintegrate asm/system.h into a set of
      separate bits to relieve the problem of circular inclusion
      dependencies.
    
      I've built all the working defconfigs from all the arches that I can
      and made sure that they don't break.
    
      The reason for these patches is that I recently encountered a circular
      dependency problem that came about when I produced some patches to
      optimise get_order() by rewriting it to use ilog2().
    
      This uses bitops - and on the SH arch asm/bitops.h drags in
      asm-generic/get_order.h by a circuituous route involving asm/system.h.
    
      The main difficulty seems to be asm/system.h.  It holds a number of
      low level bits with no/few dependencies that are commonly used (eg.
      memory barriers) and a number of bits with more dependencies that
      aren't used in many places (eg.  switch_to()).
    
      These patches break asm/system.h up into the following core pieces:
    
        (1) asm/barrier.h
    
            Move memory barriers here.  This already done for MIPS and Alpha.
    
        (2) asm/switch_to.h
    
            Move switch_to() and related stuff here.
    
        (3) asm/exec.h
    
            Move arch_align_stack() here.  Other process execution related bits
            could perhaps go here from asm/processor.h.
    
        (4) asm/cmpxchg.h
    
            Move xchg() and cmpxchg() here as they're full word atomic ops and
            frequently used by atomic_xchg() and atomic_cmpxchg().
    
        (5) asm/bug.h
    
            Move die() and related bits.
    
        (6) asm/auxvec.h
    
            Move AT_VECTOR_SIZE_ARCH here.
    
      Other arch headers are created as needed on a per-arch basis."
    
    Fixed up some conflicts from other header file cleanups and moving code
    around that has happened in the meantime, so David's testing is somewhat
    weakened by that.  We'll find out anything that got broken and fix it..
    
    * tag 'split-asm_system_h-for-linus-20120328' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-asm_system: (38 commits)
      Delete all instances of asm/system.h
      Remove all #inclusions of asm/system.h
      Add #includes needed to permit the removal of asm/system.h
      Move all declarations of free_initmem() to linux/mm.h
      Disintegrate asm/system.h for OpenRISC
      Split arch_align_stack() out from asm-generic/system.h
      Split the switch_to() wrapper out of asm-generic/system.h
      Move the asm-generic/system.h xchg() implementation to asm-generic/cmpxchg.h
      Create asm-generic/barrier.h
      Make asm-generic/cmpxchg.h #include asm-generic/cmpxchg-local.h
      Disintegrate asm/system.h for Xtensa
      Disintegrate asm/system.h for Unicore32 [based on ver #3, changed by gxt]
      Disintegrate asm/system.h for Tile
      Disintegrate asm/system.h for Sparc
      Disintegrate asm/system.h for SH
      Disintegrate asm/system.h for Score
      Disintegrate asm/system.h for S390
      Disintegrate asm/system.h for PowerPC
      Disintegrate asm/system.h for PA-RISC
      Disintegrate asm/system.h for MN10300
      ...

commit 9f97da78bf018206fb623cd351d454af2f105fe0
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:01 2012 +0100

    Disintegrate asm/system.h for ARM
    
    Disintegrate asm/system.h for ARM.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Russell King <linux@arm.linux.org.uk>
    cc: linux-arm-kernel@lists.infradead.org

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index fc6987578920..64d95e69bc50 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -31,6 +31,7 @@
 #include <trace/events/power.h>
 
 #include <asm/suspend.h>
+#include <asm/system_misc.h>
 
 #include <plat/sram.h>
 #include "clockdomain.h"

commit 981798569b090543453baccbc0657fbcea311668
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Sat Mar 17 18:22:48 2012 -0700

    arm: omap3: pm34xx.c: Replace printk() with appropriate pr_*()
    
    Currently, pm34xx.c has a mix of printk() and pr_*() statements
    so replace the printk() statements with the equivalent pr_*()
    statements.
    
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index c598d26f3317..6aeacf660790 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -166,8 +166,7 @@ static void omap3_save_secure_ram_context(void)
 		pwrdm_set_next_pwrst(mpu_pwrdm, mpu_next_state);
 		/* Following is for error tracking, it should not happen */
 		if (ret) {
-			printk(KERN_ERR "save_secure_sram() returns %08x\n",
-				ret);
+			pr_err("save_secure_sram() returns %08x\n", ret);
 			while (1)
 				;
 		}
@@ -307,7 +306,7 @@ void omap_sram_idle(void)
 		break;
 	default:
 		/* Invalid state */
-		printk(KERN_ERR "Invalid mpu state in sram_idle\n");
+		pr_err("Invalid mpu state in sram_idle\n");
 		return;
 	}
 
@@ -463,18 +462,17 @@ static int omap3_pm_suspend(void)
 	list_for_each_entry(pwrst, &pwrst_list, node) {
 		state = pwrdm_read_prev_pwrst(pwrst->pwrdm);
 		if (state > pwrst->next_state) {
-			printk(KERN_INFO "Powerdomain (%s) didn't enter "
-			       "target state %d\n",
+			pr_info("Powerdomain (%s) didn't enter "
+				"target state %d\n",
 			       pwrst->pwrdm->name, pwrst->next_state);
 			ret = -1;
 		}
 		omap_set_pwrdm_state(pwrst->pwrdm, pwrst->saved_state);
 	}
 	if (ret)
-		printk(KERN_ERR "Could not enter target state in pm_suspend\n");
+		pr_err("Could not enter target state in pm_suspend\n");
 	else
-		printk(KERN_INFO "Successfully put all powerdomains "
-		       "to target state\n");
+		pr_info("Successfully put all powerdomains to target state\n");
 
 	return ret;
 }
@@ -822,7 +820,7 @@ static int __init omap3_pm_init(void)
 
 	ret = pwrdm_for_each(pwrdms_setup, NULL);
 	if (ret) {
-		printk(KERN_ERR "Failed to setup powerdomains\n");
+		pr_err("Failed to setup powerdomains\n");
 		goto err3;
 	}
 
@@ -830,7 +828,7 @@ static int __init omap3_pm_init(void)
 
 	mpu_pwrdm = pwrdm_lookup("mpu_pwrdm");
 	if (mpu_pwrdm == NULL) {
-		printk(KERN_ERR "Failed to get mpu_pwrdm\n");
+		pr_err("Failed to get mpu_pwrdm\n");
 		ret = -EINVAL;
 		goto err3;
 	}
@@ -865,8 +863,8 @@ static int __init omap3_pm_init(void)
 		omap3_secure_ram_storage =
 			kmalloc(0x803F, GFP_KERNEL);
 		if (!omap3_secure_ram_storage)
-			printk(KERN_ERR "Memory allocation failed when"
-					"allocating for secure sram context\n");
+			pr_err("Memory allocation failed when "
+			       "allocating for secure sram context\n");
 
 		local_irq_disable();
 		local_fiq_disable();

commit ce229c5d79c03f09d4612dd2bcbff532fdc24e80
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Sat Mar 17 18:22:47 2012 -0700

    arm: omap3: pm34xx.c: Fix omap3_pm_init() error out paths
    
    It appears that the error paths were overlooked when the
    omap3_pm_init() routine had the prcm chain handler code
    added.  Fix this by adding a goto target and reordering
    the error handling code.  Also fix how the irq argument
    for free_irq() is determined.
    
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Acked-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index fc6987578920..c598d26f3317 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -817,13 +817,13 @@ static int __init omap3_pm_init(void)
 
 	if (ret) {
 		pr_err("pm: Failed to request pm_io irq\n");
-		goto err1;
+		goto err2;
 	}
 
 	ret = pwrdm_for_each(pwrdms_setup, NULL);
 	if (ret) {
 		printk(KERN_ERR "Failed to setup powerdomains\n");
-		goto err2;
+		goto err3;
 	}
 
 	(void) clkdm_for_each(clkdms_setup, NULL);
@@ -831,7 +831,8 @@ static int __init omap3_pm_init(void)
 	mpu_pwrdm = pwrdm_lookup("mpu_pwrdm");
 	if (mpu_pwrdm == NULL) {
 		printk(KERN_ERR "Failed to get mpu_pwrdm\n");
-		goto err2;
+		ret = -EINVAL;
+		goto err3;
 	}
 
 	neon_pwrdm = pwrdm_lookup("neon_pwrdm");
@@ -879,14 +880,17 @@ static int __init omap3_pm_init(void)
 	}
 
 	omap3_save_scratchpad_contents();
-err1:
 	return ret;
-err2:
-	free_irq(INT_34XX_PRCM_MPU_IRQ, NULL);
+
+err3:
 	list_for_each_entry_safe(pwrst, tmp, &pwrst_list, node) {
 		list_del(&pwrst->node);
 		kfree(pwrst);
 	}
+	free_irq(omap_prcm_event_to_irq("io"), omap3_pm_init);
+err2:
+	free_irq(omap_prcm_event_to_irq("wkup"), NULL);
+err1:
 	return ret;
 }
 

commit e65bc8918f75620f1668d321b048bfa336ccc0fa
Merge: d60d506e6baa 00fd72ccc928
Author: Olof Johansson <olof@lixom.net>
Date:   Sat Mar 10 09:08:09 2012 -0800

    Merge branch 'cleanup-pm' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into next/cleanup
    
    * 'cleanup-pm' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap:
      ARM: OMAP2+: PM: share some suspend-related functions across OMAP2, 3, 4
      ARM: OMAP2+: omap_device: call all suspend, resume callbacks when OMAP_DEVICE_NO_IDLE_ON_SUSPEND is set
      ARM: OMAP: omap_device: remove omap_device_parent
      ARM: OMAP2+: PM debug: fix the use of debugfs_create_* API
      ARM: OMAP2+: PM: share clkdms_setup() across OMAP2, 3, 4
      ARM: OMAP2+: PM: clean up omap_set_pwrdm_state()
      ARM: OMAP3: PM: remove superfluous calls to pwrdm_clear_all_prev_pwrst()
      ARM: OMAP: convert omap_device_build() and callers to __init
      ARM: OMAP2+: Mark omap_hsmmc_init and omap_mux related functions as __init
      ARM: OMAP2+: Split omap2_hsmmc_init() to properly support I2C GPIO pins
      ARM: OMAP: omap_device: Expose omap_device_{alloc, delete, register}
      ARM: OMAP: Fix build error when mmc_omap is built as module
      ARM: OMAP: Fix kernel panic with HSMMC when twl4030_gpio is a module

commit 1416408d31236dc2a80d269aa23ffa93aa01e833
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Feb 2 02:30:50 2012 -0700

    ARM: OMAP2+: PM: share some suspend-related functions across OMAP2, 3, 4
    
    The platform_suspend_ops can be shared across OMAP2, 3, and 4, along
    with all of the functions referenced in that structure.  This patch
    shares them.  It also removes the suspend_state file-scoped variable
    in the OMAP2 and 3 PM code; it does not appear to be actually needed
    by anything.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    [khilman@ti.com: minor rework needed due to rebase/merge with conflicting changes]
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 5fc1a987fccc..da054370f837 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -50,10 +50,6 @@
 #include "sdrc.h"
 #include "control.h"
 
-#ifdef CONFIG_SUSPEND
-static suspend_state_t suspend_state = PM_SUSPEND_ON;
-#endif
-
 /* pm34xx errata defined in pm.h */
 u16 pm34xx_errata;
 
@@ -472,50 +468,6 @@ static int omap3_pm_suspend(void)
 	return ret;
 }
 
-static int omap3_pm_enter(suspend_state_t unused)
-{
-	int ret = 0;
-
-	switch (suspend_state) {
-	case PM_SUSPEND_STANDBY:
-	case PM_SUSPEND_MEM:
-		ret = omap3_pm_suspend();
-		break;
-	default:
-		ret = -EINVAL;
-	}
-
-	return ret;
-}
-
-/* Hooks to enable / disable UART interrupts during suspend */
-static int omap3_pm_begin(suspend_state_t state)
-{
-	disable_hlt();
-	suspend_state = state;
-	omap_prcm_irq_prepare();
-	return 0;
-}
-
-static void omap3_pm_end(void)
-{
-	suspend_state = PM_SUSPEND_ON;
-	enable_hlt();
-	return;
-}
-
-static void omap3_pm_finish(void)
-{
-	omap_prcm_irq_complete();
-}
-
-static const struct platform_suspend_ops omap_pm_ops = {
-	.begin		= omap3_pm_begin,
-	.end		= omap3_pm_end,
-	.enter		= omap3_pm_enter,
-	.finish		= omap3_pm_finish,
-	.valid		= suspend_valid_only_mem,
-};
 #endif /* CONFIG_SUSPEND */
 
 
@@ -823,8 +775,8 @@ static int __init omap3_pm_init(void)
 	core_clkdm = clkdm_lookup("core_clkdm");
 
 #ifdef CONFIG_SUSPEND
-	suspend_set_ops(&omap_pm_ops);
-#endif /* CONFIG_SUSPEND */
+	omap_pm_suspend = omap3_pm_suspend;
+#endif
 
 	arm_pm_idle = omap3_pm_idle;
 	omap3_idle_init();

commit 92206fd292da7632c039f6c4054bdaac08b030c0
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Feb 2 02:38:50 2012 -0700

    ARM: OMAP2+: PM: share clkdms_setup() across OMAP2, 3, 4
    
    clkdms_setup() is identical across OMAP2, 3, and 4, so share it.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Tested-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 60279b3502d9..5fc1a987fccc 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -735,21 +735,6 @@ static int __init pwrdms_setup(struct powerdomain *pwrdm, void *unused)
 	return omap_set_pwrdm_state(pwrst->pwrdm, pwrst->next_state);
 }
 
-/*
- * Enable hw supervised mode for all clockdomains if it's
- * supported. Initiate sleep transition for other clockdomains, if
- * they are not used
- */
-static int __init clkdms_setup(struct clockdomain *clkdm, void *unused)
-{
-	if (clkdm->flags & CLKDM_CAN_ENABLE_AUTO)
-		clkdm_allow_idle(clkdm);
-	else if (clkdm->flags & CLKDM_CAN_FORCE_SLEEP &&
-		 atomic_read(&clkdm->usecount) == 0)
-		clkdm_sleep(clkdm);
-	return 0;
-}
-
 /*
  * Push functions to SRAM
  *
@@ -819,7 +804,7 @@ static int __init omap3_pm_init(void)
 		goto err2;
 	}
 
-	(void) clkdm_for_each(clkdms_setup, NULL);
+	(void) clkdm_for_each(omap_pm_clkdms_setup, NULL);
 
 	mpu_pwrdm = pwrdm_lookup("mpu_pwrdm");
 	if (mpu_pwrdm == NULL) {

commit 506c7d7931317813b3142f57d44bf113102a2a8f
Author: Paul Walmsley <paul@pwsan.com>
Date:   Mon Jan 30 02:47:24 2012 -0700

    ARM: OMAP3: PM: remove superfluous calls to pwrdm_clear_all_prev_pwrst()
    
    Remove some superfluous calls to pwrdm_clear_all_prev_pwrst().
    pwrdm_pre_transition(), which appears a few lines after these calls,
    invokes pwrdm_clear_all_prev_pwrst() on each powerdomain -- there's no
    need to do it twice.
    
    N.B.: some of us have observed that accesses to the previous
    powerstate registers seem to be quite slow.  Although the writes
    removed by this patch should be buffered by the write buffer, there is
    a read to a PRM register immediately afterwards.  That will block the
    OMAP3 MPU until all of those writes complete.  So this patch should
    result in a minor performance improvement during idle entry.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Tero Kristo <t-kristo@ti.com>
    [khilman@ti.com: removed a couple more for OMAP4]
    Tested-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index b77df735fa6c..60279b3502d9 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -290,11 +290,6 @@ void omap_sram_idle(void)
 	int core_prev_state, per_prev_state;
 	u32 sdrc_pwr = 0;
 
-	pwrdm_clear_all_prev_pwrst(mpu_pwrdm);
-	pwrdm_clear_all_prev_pwrst(neon_pwrdm);
-	pwrdm_clear_all_prev_pwrst(core_pwrdm);
-	pwrdm_clear_all_prev_pwrst(per_pwrdm);
-
 	mpu_next_state = pwrdm_read_next_pwrst(mpu_pwrdm);
 	switch (mpu_next_state) {
 	case PWRDM_POWER_ON:

commit 1220547bfd7f7dd97f770a04b533323e5404b8e9
Merge: a26d3c4fcd4b f86bcc302a8c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Mar 2 13:05:00 2012 +0000

    Merge branch 'depends/omap/gpio/runtime-pm-cleanup' into next/cleanup
    
    Conflicts:
            arch/arm/mach-omap1/gpio16xx.c
            drivers/gpio/gpio-omap.c
    
    Merge in the runtime-pm-cleanup branch from the gpio tree into
    next/cleanup, this resolves a nonobvious merge conflict between
    the two branches. Both branches move parts of the gpio-omap
    driver into platform code, this takes the superset of both
    changes.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit 60a3437dc9a61c7f4b199c2bac3dcc7b611b1178
Author: Tarun Kanti DebBarma <tarun.kanti@ti.com>
Date:   Thu Sep 29 04:47:25 2011 +0530

    gpio/omap: handle save/restore context in GPIO driver
    
    Modify omap_gpio_prepare_for_idle() & omap_gpio_resume_after_idle() functions
    to handle save context & restore context respectively in the OMAP GPIO driver
    itself instead of calling these functions from pm specific files.
    For this, in gpio_prepare_for_idle(), call *_get_context_loss_count() and in
    gpio_resume_after_idle() call it again. If the count is different, do restore
    context.
    
    Signed-off-by: Charulatha V <charu@ti.com>
    Signed-off-by: Tarun Kanti DebBarma <tarun.kanti@ti.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index fc6987578920..59c6dc16dd1d 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -75,16 +75,6 @@ static struct powerdomain *mpu_pwrdm, *neon_pwrdm;
 static struct powerdomain *core_pwrdm, *per_pwrdm;
 static struct powerdomain *cam_pwrdm;
 
-static inline void omap3_per_save_context(void)
-{
-	omap_gpio_save_context();
-}
-
-static inline void omap3_per_restore_context(void)
-{
-	omap_gpio_restore_context();
-}
-
 static void omap3_enable_io_chain(void)
 {
 	int timeout = 0;
@@ -332,8 +322,6 @@ void omap_sram_idle(void)
 	if (per_next_state < PWRDM_POWER_ON) {
 		per_going_off = (per_next_state == PWRDM_POWER_OFF) ? 1 : 0;
 		omap2_gpio_prepare_for_idle(per_going_off);
-		if (per_next_state == PWRDM_POWER_OFF)
-				omap3_per_save_context();
 	}
 
 	/* CORE */
@@ -399,8 +387,6 @@ void omap_sram_idle(void)
 	if (per_next_state < PWRDM_POWER_ON) {
 		per_prev_state = pwrdm_read_prev_pwrst(per_pwrdm);
 		omap2_gpio_resume_after_idle();
-		if (per_prev_state == PWRDM_POWER_OFF)
-			omap3_per_restore_context();
 	}
 
 	/* Disable IO-PAD and IO-CHAIN wakeup */

commit 0bcd24b0f414003c695e2ecf16b9ffa14d184f48
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Wed Jan 4 16:27:48 2012 -0500

    ARM: OMAP: convert idle handlers from pm_idle to arm_pm_idle
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Tested-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index fc6987578920..b77df735fa6c 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -418,10 +418,9 @@ void omap_sram_idle(void)
 
 static void omap3_pm_idle(void)
 {
-	local_irq_disable();
 	local_fiq_disable();
 
-	if (omap_irq_pending() || need_resched())
+	if (omap_irq_pending())
 		goto out;
 
 	trace_power_start(POWER_CSTATE, 1, smp_processor_id());
@@ -434,7 +433,6 @@ static void omap3_pm_idle(void)
 
 out:
 	local_fiq_enable();
-	local_irq_enable();
 }
 
 #ifdef CONFIG_SUSPEND
@@ -848,7 +846,7 @@ static int __init omap3_pm_init(void)
 	suspend_set_ops(&omap_pm_ops);
 #endif /* CONFIG_SUSPEND */
 
-	pm_idle = omap3_pm_idle;
+	arm_pm_idle = omap3_pm_idle;
 	omap3_idle_init();
 
 	/*

commit 7f760f1abcd1a36b52776c90f6a601dd90f06ecb
Merge: 9d297f5ee1b9 da2746865554
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Dec 16 14:01:03 2011 -0800

    Merge branch 'for_3.3/uart/runtime-pm' of git://git.kernel.org/pub/scm/linux/kernel/git/khilman/linux-omap-pm into uart
    
    Conflicts:
            arch/arm/mach-omap2/pm34xx.c

commit 9d297f5ee1b92a84e2cd6c547c3ac1f893128359
Merge: aacf09412875 2f31b51659c2
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Dec 16 14:00:23 2011 -0800

    Merge branch 'tk_prm_chain_handler_devel_3.3' of git://git.pwsan.com/linux-2.6 into prcm
    
    Conflicts:
            arch/arm/mach-omap2/Makefile

commit 22f51371f8c35869ed850f46aa76b6cc2b502110
Author: Tero Kristo <t-kristo@ti.com>
Date:   Fri Dec 16 14:36:59 2011 -0700

    ARM: OMAP3: pm: use prcm chain handler
    
    PM interrupt handling is now done through the PRCM chain handler. The
    interrupt handling logic is also split in two parts, to serve IO and
    WKUP events separately. This allows us to handle IO chain events in a
    clean way.
    
    Core event code is also changed in accordance to this, as PRCM
    interrupt handling is done by independent handlers, and the core
    handler should not clear the IO events anymore.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Tested-by: Kevin Hilman <khilman@ti.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    [paul@pwsan.com: use pr_err(); combined with portions of earlier patches and
     the "do not enable PRCM MPU interrupts manually" patch]
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index efa66494c1e3..ba1692e0a5f4 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -194,7 +194,7 @@ static void omap3_save_secure_ram_context(void)
  * that any peripheral wake-up events occurring while attempting to
  * clear the PM_WKST_x are detected and cleared.
  */
-static int prcm_clear_mod_irqs(s16 module, u8 regs)
+static int prcm_clear_mod_irqs(s16 module, u8 regs, u32 ignore_bits)
 {
 	u32 wkst, fclk, iclk, clken;
 	u16 wkst_off = (regs == 3) ? OMAP3430ES2_PM_WKST3 : PM_WKST1;
@@ -206,6 +206,7 @@ static int prcm_clear_mod_irqs(s16 module, u8 regs)
 
 	wkst = omap2_prm_read_mod_reg(module, wkst_off);
 	wkst &= omap2_prm_read_mod_reg(module, grpsel_off);
+	wkst &= ~ignore_bits;
 	if (wkst) {
 		iclk = omap2_cm_read_mod_reg(module, iclk_off);
 		fclk = omap2_cm_read_mod_reg(module, fclk_off);
@@ -221,6 +222,7 @@ static int prcm_clear_mod_irqs(s16 module, u8 regs)
 			omap2_cm_set_mod_reg_bits(clken, module, fclk_off);
 			omap2_prm_write_mod_reg(wkst, module, wkst_off);
 			wkst = omap2_prm_read_mod_reg(module, wkst_off);
+			wkst &= ~ignore_bits;
 			c++;
 		}
 		omap2_cm_write_mod_reg(iclk, module, iclk_off);
@@ -230,76 +232,35 @@ static int prcm_clear_mod_irqs(s16 module, u8 regs)
 	return c;
 }
 
-static int _prcm_int_handle_wakeup(void)
+static irqreturn_t _prcm_int_handle_io(int irq, void *unused)
 {
 	int c;
 
-	c = prcm_clear_mod_irqs(WKUP_MOD, 1);
-	c += prcm_clear_mod_irqs(CORE_MOD, 1);
-	c += prcm_clear_mod_irqs(OMAP3430_PER_MOD, 1);
-	if (omap_rev() > OMAP3430_REV_ES1_0) {
-		c += prcm_clear_mod_irqs(CORE_MOD, 3);
-		c += prcm_clear_mod_irqs(OMAP3430ES2_USBHOST_MOD, 1);
-	}
+	c = prcm_clear_mod_irqs(WKUP_MOD, 1,
+		~(OMAP3430_ST_IO_MASK | OMAP3430_ST_IO_CHAIN_MASK));
 
-	return c;
+	return c ? IRQ_HANDLED : IRQ_NONE;
 }
 
-/*
- * PRCM Interrupt Handler
- *
- * The PRM_IRQSTATUS_MPU register indicates if there are any pending
- * interrupts from the PRCM for the MPU. These bits must be cleared in
- * order to clear the PRCM interrupt. The PRCM interrupt handler is
- * implemented to simply clear the PRM_IRQSTATUS_MPU in order to clear
- * the PRCM interrupt. Please note that bit 0 of the PRM_IRQSTATUS_MPU
- * register indicates that a wake-up event is pending for the MPU and
- * this bit can only be cleared if the all the wake-up events latched
- * in the various PM_WKST_x registers have been cleared. The interrupt
- * handler is implemented using a do-while loop so that if a wake-up
- * event occurred during the processing of the prcm interrupt handler
- * (setting a bit in the corresponding PM_WKST_x register and thus
- * preventing us from clearing bit 0 of the PRM_IRQSTATUS_MPU register)
- * this would be handled.
- */
-static irqreturn_t prcm_interrupt_handler (int irq, void *dev_id)
+static irqreturn_t _prcm_int_handle_wakeup(int irq, void *unused)
 {
-	u32 irqenable_mpu, irqstatus_mpu;
-	int c = 0;
-
-	irqenable_mpu = omap2_prm_read_mod_reg(OCP_MOD,
-					 OMAP3_PRM_IRQENABLE_MPU_OFFSET);
-	irqstatus_mpu = omap2_prm_read_mod_reg(OCP_MOD,
-					 OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
-	irqstatus_mpu &= irqenable_mpu;
-
-	do {
-		if (irqstatus_mpu & (OMAP3430_WKUP_ST_MASK |
-				     OMAP3430_IO_ST_MASK)) {
-			c = _prcm_int_handle_wakeup();
-
-			/*
-			 * Is the MPU PRCM interrupt handler racing with the
-			 * IVA2 PRCM interrupt handler ?
-			 */
-			WARN(c == 0, "prcm: WARNING: PRCM indicated MPU wakeup "
-			     "but no wakeup sources are marked\n");
-		} else {
-			/* XXX we need to expand our PRCM interrupt handler */
-			WARN(1, "prcm: WARNING: PRCM interrupt received, but "
-			     "no code to handle it (%08x)\n", irqstatus_mpu);
-		}
-
-		omap2_prm_write_mod_reg(irqstatus_mpu, OCP_MOD,
-					OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
-
-		irqstatus_mpu = omap2_prm_read_mod_reg(OCP_MOD,
-					OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
-		irqstatus_mpu &= irqenable_mpu;
+	int c;
 
-	} while (irqstatus_mpu);
+	/*
+	 * Clear all except ST_IO and ST_IO_CHAIN for wkup module,
+	 * these are handled in a separate handler to avoid acking
+	 * IO events before parsing in mux code
+	 */
+	c = prcm_clear_mod_irqs(WKUP_MOD, 1,
+		OMAP3430_ST_IO_MASK | OMAP3430_ST_IO_CHAIN_MASK);
+	c += prcm_clear_mod_irqs(CORE_MOD, 1, 0);
+	c += prcm_clear_mod_irqs(OMAP3430_PER_MOD, 1, 0);
+	if (omap_rev() > OMAP3430_REV_ES1_0) {
+		c += prcm_clear_mod_irqs(CORE_MOD, 3, 0);
+		c += prcm_clear_mod_irqs(OMAP3430ES2_USBHOST_MOD, 1, 0);
+	}
 
-	return IRQ_HANDLED;
+	return c ? IRQ_HANDLED : IRQ_NONE;
 }
 
 static void omap34xx_save_context(u32 *save)
@@ -580,6 +541,7 @@ static int omap3_pm_begin(suspend_state_t state)
 	disable_hlt();
 	suspend_state = state;
 	omap_uart_enable_irqs(0);
+	omap_prcm_irq_prepare();
 	return 0;
 }
 
@@ -591,10 +553,16 @@ static void omap3_pm_end(void)
 	return;
 }
 
+static void omap3_pm_finish(void)
+{
+	omap_prcm_irq_complete();
+}
+
 static const struct platform_suspend_ops omap_pm_ops = {
 	.begin		= omap3_pm_begin,
 	.end		= omap3_pm_end,
 	.enter		= omap3_pm_enter,
+	.finish		= omap3_pm_finish,
 	.valid		= suspend_valid_only_mem,
 };
 #endif /* CONFIG_SUSPEND */
@@ -700,10 +668,6 @@ static void __init prcm_setup_regs(void)
 			  OMAP3430_GRPSEL_GPT1_MASK |
 			  OMAP3430_GRPSEL_GPT12_MASK,
 			  WKUP_MOD, OMAP3430_PM_MPUGRPSEL);
-	/* For some reason IO doesn't generate wakeup event even if
-	 * it is selected to mpu wakeup goup */
-	omap2_prm_write_mod_reg(OMAP3430_IO_EN_MASK | OMAP3430_WKUP_EN_MASK,
-			  OCP_MOD, OMAP3_PRM_IRQENABLE_MPU_OFFSET);
 
 	/* Enable PM_WKEN to support DSS LPR */
 	omap2_prm_write_mod_reg(OMAP3430_PM_WKEN_DSS_EN_DSS_MASK,
@@ -880,12 +844,21 @@ static int __init omap3_pm_init(void)
 	 * supervised mode for powerdomains */
 	prcm_setup_regs();
 
-	ret = request_irq(INT_34XX_PRCM_MPU_IRQ,
-			  (irq_handler_t)prcm_interrupt_handler,
-			  IRQF_DISABLED, "prcm", NULL);
+	ret = request_irq(omap_prcm_event_to_irq("wkup"),
+		_prcm_int_handle_wakeup, IRQF_NO_SUSPEND, "pm_wkup", NULL);
+
+	if (ret) {
+		pr_err("pm: Failed to request pm_wkup irq\n");
+		goto err1;
+	}
+
+	/* IO interrupt is shared with mux code */
+	ret = request_irq(omap_prcm_event_to_irq("io"),
+		_prcm_int_handle_io, IRQF_SHARED | IRQF_NO_SUSPEND, "pm_io",
+		omap3_pm_init);
+
 	if (ret) {
-		printk(KERN_ERR "request_irq failed to register for 0x%x\n",
-		       INT_34XX_PRCM_MPU_IRQ);
+		pr_err("pm: Failed to request pm_io irq\n");
 		goto err1;
 	}
 

commit 2fd149645eb46d26130d7070c6de037dddf34880
Author: Govindraj.R <govindraj.raja@ti.com>
Date:   Wed Nov 9 17:41:21 2011 +0530

    ARM: OMAP2+: UART: Remove omap_uart_can_sleep and add pm_qos
    
    Omap_uart_can_sleep function blocks system wide low power state until
    uart is active remove this func and add qos requests to prevent
    MPU from transitioning.
    
    Keep qos request to default value which will allow MPU to transition
    and while uart baud rate is available calculate the latency value
    from the baudrate and use the same to hold constraint while uart clocks
    are enabled, and if uart is auto-idled the constraint is updated with
    default constraint value allowing MPU to transition.
    
    Qos requests are blocking notifier calls so put these requests to
    work queue, also the driver uses irq_safe version of runtime API's
    and callbacks can be called in interrupt disabled context.
    So to avoid warn on slow path warning while using qos update
    API's from runtime callbacks use the qos_work_queue.
    
    During bootup the runtime_resume call backs might not be called and runtime
    callback gets called only after uart is idled by setting the autosuspend
    timeout. So qos_request from runtime resume callback might not activated during
    boot if uart baudrate is calculated during bootup for console uart, so schedule
    the qos_work queue once we calc_latency while configuring the uart port.
    
    Flush and complete any pending qos jobs in work queue while suspending.
    
    Signed-off-by: Govindraj.R <govindraj.raja@ti.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de> (for drivers/tty changes)
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 4feee45ef069..4ee5f4eb04e4 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -35,7 +35,6 @@
 #include <plat/sram.h>
 #include "clockdomain.h"
 #include "powerdomain.h"
-#include <plat/serial.h>
 #include <plat/sdrc.h>
 #include <plat/prcm.h>
 #include <plat/gpmc.h>
@@ -456,21 +455,11 @@ void omap_sram_idle(void)
 	clkdm_allow_idle(mpu_pwrdm->pwrdm_clkdms[0]);
 }
 
-int omap3_can_sleep(void)
-{
-	if (!omap_uart_can_sleep())
-		return 0;
-	return 1;
-}
-
 static void omap3_pm_idle(void)
 {
 	local_irq_disable();
 	local_fiq_disable();
 
-	if (!omap3_can_sleep())
-		goto out;
-
 	if (omap_irq_pending() || need_resched())
 		goto out;
 

commit 8384c9749f8c31c6e1e64a63c8d50af7863ce657
Author: Govindraj.R <govindraj.raja@ti.com>
Date:   Wed Nov 9 17:22:30 2011 +0530

    ARM: OMAP2+: UART: cleanup + remove uart pm specific API
    
    In preparation to UART runtime conversion remove uart specific calls
    from pm24xx/34xx files and their definition from serial.c
    These func calls will no more be used with upcoming uart runtime design.
    
    1.) omap_uart_prepare_suspend :- can be taken care with driver suspend hooks.
    2.) omap_uart_enable_irqs :- Used to enable/disable uart irq's in suspend
        path from PM code, this is removed as same is handled by
        uart_suspend_port/uart_resume_port in omap-serial driver which will
        do an port_shutdown on suspend freeing irq and port_startup on resume
        enabling back irq.
    3.) Remove prepare_idle/resume_idle calls used to gate uart clocks.
        UART clocks can be gated within driver using runtime funcs
        and be woken up using irq_chaining from omap_prm driver.
    4.) Remove console_locking from idle path as clock gating is done withing
        driver itself with runtime API. Remove is_suspending check used to acquire
        console_lock.
    
    Signed-off-by: Govindraj.R <govindraj.raja@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index fa637dfdda53..4feee45ef069 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -28,7 +28,6 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
-#include <linux/console.h>
 #include <trace/events/power.h>
 
 #include <asm/suspend.h>
@@ -54,15 +53,6 @@
 
 #ifdef CONFIG_SUSPEND
 static suspend_state_t suspend_state = PM_SUSPEND_ON;
-static inline bool is_suspending(void)
-{
-	return (suspend_state != PM_SUSPEND_ON) && console_suspend_enabled;
-}
-#else
-static inline bool is_suspending(void)
-{
-	return false;
-}
 #endif
 
 /* pm34xx errata defined in pm.h */
@@ -376,20 +366,11 @@ void omap_sram_idle(void)
 			omap3_enable_io_chain();
 	}
 
-	/* Block console output in case it is on one of the OMAP UARTs */
-	if (!is_suspending())
-		if (per_next_state < PWRDM_POWER_ON ||
-		    core_next_state < PWRDM_POWER_ON)
-			if (!console_trylock())
-				goto console_still_active;
-
 	pwrdm_pre_transition();
 
 	/* PER */
 	if (per_next_state < PWRDM_POWER_ON) {
 		per_going_off = (per_next_state == PWRDM_POWER_OFF) ? 1 : 0;
-		omap_uart_prepare_idle(2);
-		omap_uart_prepare_idle(3);
 		omap2_gpio_prepare_for_idle(per_going_off);
 		if (per_next_state == PWRDM_POWER_OFF)
 				omap3_per_save_context();
@@ -397,8 +378,6 @@ void omap_sram_idle(void)
 
 	/* CORE */
 	if (core_next_state < PWRDM_POWER_ON) {
-		omap_uart_prepare_idle(0);
-		omap_uart_prepare_idle(1);
 		if (core_next_state == PWRDM_POWER_OFF) {
 			omap3_core_save_context();
 			omap3_cm_save_context();
@@ -447,8 +426,6 @@ void omap_sram_idle(void)
 			omap3_sram_restore_context();
 			omap2_sms_restore_context();
 		}
-		omap_uart_resume_idle(0);
-		omap_uart_resume_idle(1);
 		if (core_next_state == PWRDM_POWER_OFF)
 			omap2_prm_clear_mod_reg_bits(OMAP3430_AUTO_OFF_MASK,
 					       OMAP3430_GR_MOD,
@@ -464,14 +441,8 @@ void omap_sram_idle(void)
 		omap2_gpio_resume_after_idle();
 		if (per_prev_state == PWRDM_POWER_OFF)
 			omap3_per_restore_context();
-		omap_uart_resume_idle(2);
-		omap_uart_resume_idle(3);
 	}
 
-	if (!is_suspending())
-		console_unlock();
-
-console_still_active:
 	/* Disable IO-PAD and IO-CHAIN wakeup */
 	if (omap3_has_io_wakeup() &&
 	    (per_next_state < PWRDM_POWER_ON ||
@@ -533,7 +504,6 @@ static int omap3_pm_suspend(void)
 			goto restore;
 	}
 
-	omap_uart_prepare_suspend();
 	omap3_intc_suspend();
 
 	omap_sram_idle();
@@ -580,14 +550,12 @@ static int omap3_pm_begin(suspend_state_t state)
 {
 	disable_hlt();
 	suspend_state = state;
-	omap_uart_enable_irqs(0);
 	return 0;
 }
 
 static void omap3_pm_end(void)
 {
 	suspend_state = PM_SUSPEND_ON;
-	omap_uart_enable_irqs(1);
 	enable_hlt();
 	return;
 }

commit 4e65331c6bb4a777bd61a4dac0daa9fc47777b63
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Nov 10 22:45:17 2011 +0100

    ARM: 7159/1: OMAP: Introduce local common.h files
    
    As suggested by Russell King - ARM Linux <linux@arm.linux.org.uk>,
    there's no need to keep local prototypes in non-local headers.
    
    Add mach-omap1/common.h and mach-omap2/common.h and move the
    local prototypes there from plat/common.h and mach/omap4-common.h.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index efa66494c1e3..fa637dfdda53 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -42,6 +42,7 @@
 #include <plat/gpmc.h>
 #include <plat/dma.h>
 
+#include "common.h"
 #include "cm2xxx_3xxx.h"
 #include "cm-regbits-34xx.h"
 #include "prm-regbits-34xx.h"

commit 7fd92b56e5508fc3453ac9a65e11561178e86330
Merge: 2cbb6160b560 3047454475ad
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Nov 4 17:40:52 2011 -0700

    Merge branch 'for_3.2/pm-cleanup-2' of git://github.com/khilman/linux-omap-pm into fixes

commit 3047454475adca98e30e00dfca21021a0de99d78
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Oct 6 13:43:23 2011 -0600

    ARM: OMAP3: PM: restrict erratum i443 handling to OMAP3430 only
    
    Based on the documents that I have here, there doesn't appear to be an
    equivalent to erratum i443 for OMAP3630, so restrict this one to OMAP34xx
    chips.
    
    Also, explicitly restrict this erratum to EMU and HS devices.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index bfa8b8c8171a..b2740c5e0504 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -407,13 +407,14 @@ void omap_sram_idle(void)
 	omap3_intc_prepare_idle();
 
 	/*
-	* On EMU/HS devices ROM code restores a SRDC value
-	* from scratchpad which has automatic self refresh on timeout
-	* of AUTO_CNT = 1 enabled. This takes care of erratum ID i443.
-	* Hence store/restore the SDRC_POWER register here.
-	*/
-	if (omap_rev() >= OMAP3430_REV_ES3_0 &&
-	    omap_type() != OMAP2_DEVICE_TYPE_GP &&
+	 * On EMU/HS devices ROM code restores a SRDC value
+	 * from scratchpad which has automatic self refresh on timeout
+	 * of AUTO_CNT = 1 enabled. This takes care of erratum ID i443.
+	 * Hence store/restore the SDRC_POWER register here.
+	 */
+	if (cpu_is_omap3430() && omap_rev() >= OMAP3430_REV_ES3_0 &&
+	    (omap_type() == OMAP2_DEVICE_TYPE_EMU ||
+	     omap_type() == OMAP2_DEVICE_TYPE_SEC) &&
 	    core_next_state == PWRDM_POWER_OFF)
 		sdrc_pwr = sdrc_read_reg(SDRC_POWER);
 
@@ -430,8 +431,9 @@ void omap_sram_idle(void)
 		omap34xx_do_sram_idle(save_state);
 
 	/* Restore normal SDRC POWER settings */
-	if (omap_rev() >= OMAP3430_REV_ES3_0 &&
-	    omap_type() != OMAP2_DEVICE_TYPE_GP &&
+	if (cpu_is_omap3430() && omap_rev() >= OMAP3430_REV_ES3_0 &&
+	    (omap_type() == OMAP2_DEVICE_TYPE_EMU ||
+	     omap_type() == OMAP2_DEVICE_TYPE_SEC) &&
 	    core_next_state == PWRDM_POWER_OFF)
 		sdrc_write_reg(sdrc_pwr, SDRC_POWER);
 

commit b02b917211d50ad5dc13e49c933ef916b10e0d00
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Oct 6 17:18:45 2011 -0600

    ARM: OMAP3: PM: fix I/O wakeup and I/O chain clock control detection
    
    The way that we detect which OMAP3 chips support I/O wakeup and
    software I/O chain clock control is broken.
    
    Currently, I/O wakeup is marked as present for all OMAP3 SoCs other
    than the AM3505/3517.  The TI81xx family of SoCs are at present
    considered to be OMAP3 SoCs, but don't support I/O wakeup.  To resolve
    this, convert the existing blacklist approach to an explicit,
    whitelist support, in which only SoCs which are known to support I/O
    wakeup are listed.  (At present, this only includes OMAP34xx,
    OMAP3503, OMAP3515, OMAP3525, OMAP3530, and OMAP36xx.)
    
    Also, the current code incorrectly detects the presence of a
    software-controllable I/O chain clock on several chips that don't
    support it.  This results in writes to reserved bitfields, unnecessary
    delays, and console messages on kernels running on those chips:
    
        http://www.spinics.net/lists/linux-omap/msg58735.html
    
    Convert this test to a feature test with a chip-by-chip whitelist.
    
    Thanks to Dave Hylands <dhylands@gmail.com> for reporting this problem
    and doing some testing to help isolate the cause.  Thanks to Steve
    Sakoman <sakoman@gmail.com> for catching a bug in the first version of
    this patch.  Thanks to Russell King <linux@arm.linux.org.uk> for
    comments.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Dave Hylands <dhylands@gmail.com>
    Cc: Steve Sakoman <sakoman@gmail.com>
    Tested-by: Steve Sakoman <sakoman@gmail.com>
    Cc: Russell King - ARM Linux <linux@arm.linux.org.uk>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 1915050e9401..bfa8b8c8171a 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -99,31 +99,27 @@ static void omap3_enable_io_chain(void)
 {
 	int timeout = 0;
 
-	if (omap_rev() >= OMAP3430_REV_ES3_1) {
-		omap2_prm_set_mod_reg_bits(OMAP3430_EN_IO_CHAIN_MASK, WKUP_MOD,
-				     PM_WKEN);
-		/* Do a readback to assure write has been done */
-		omap2_prm_read_mod_reg(WKUP_MOD, PM_WKEN);
-
-		while (!(omap2_prm_read_mod_reg(WKUP_MOD, PM_WKEN) &
-			 OMAP3430_ST_IO_CHAIN_MASK)) {
-			timeout++;
-			if (timeout > 1000) {
-				printk(KERN_ERR "Wake up daisy chain "
-				       "activation failed.\n");
-				return;
-			}
-			omap2_prm_set_mod_reg_bits(OMAP3430_ST_IO_CHAIN_MASK,
-					     WKUP_MOD, PM_WKEN);
+	omap2_prm_set_mod_reg_bits(OMAP3430_EN_IO_CHAIN_MASK, WKUP_MOD,
+				   PM_WKEN);
+	/* Do a readback to assure write has been done */
+	omap2_prm_read_mod_reg(WKUP_MOD, PM_WKEN);
+
+	while (!(omap2_prm_read_mod_reg(WKUP_MOD, PM_WKEN) &
+		 OMAP3430_ST_IO_CHAIN_MASK)) {
+		timeout++;
+		if (timeout > 1000) {
+			pr_err("Wake up daisy chain activation failed.\n");
+			return;
 		}
+		omap2_prm_set_mod_reg_bits(OMAP3430_ST_IO_CHAIN_MASK,
+					   WKUP_MOD, PM_WKEN);
 	}
 }
 
 static void omap3_disable_io_chain(void)
 {
-	if (omap_rev() >= OMAP3430_REV_ES3_1)
-		omap2_prm_clear_mod_reg_bits(OMAP3430_EN_IO_CHAIN_MASK, WKUP_MOD,
-				       PM_WKEN);
+	omap2_prm_clear_mod_reg_bits(OMAP3430_EN_IO_CHAIN_MASK, WKUP_MOD,
+				     PM_WKEN);
 }
 
 static void omap3_core_save_context(void)
@@ -375,7 +371,8 @@ void omap_sram_idle(void)
 	    (per_next_state < PWRDM_POWER_ON ||
 	     core_next_state < PWRDM_POWER_ON)) {
 		omap2_prm_set_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD, PM_WKEN);
-		omap3_enable_io_chain();
+		if (omap3_has_io_chain_ctrl())
+			omap3_enable_io_chain();
 	}
 
 	/* Block console output in case it is on one of the OMAP UARTs */
@@ -478,7 +475,8 @@ void omap_sram_idle(void)
 	     core_next_state < PWRDM_POWER_ON)) {
 		omap2_prm_clear_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD,
 					     PM_WKEN);
-		omap3_disable_io_chain();
+		if (omap3_has_io_chain_ctrl())
+			omap3_disable_io_chain();
 	}
 
 	clkdm_allow_idle(mpu_pwrdm->pwrdm_clkdms[0]);
@@ -871,6 +869,9 @@ static int __init omap3_pm_init(void)
 	if (!cpu_is_omap34xx())
 		return -ENODEV;
 
+	if (!omap3_has_io_chain_ctrl())
+		pr_warning("PM: no software I/O chain control; some wakeups may be lost\n");
+
 	pm_errata_configure();
 
 	/* XXX prcm_setup_regs needs to be before enabling hw

commit ff2f8e5ffb23de6e2284f31651447cb80a4c9d1b
Author: Charulatha V <charu@ti.com>
Date:   Tue Sep 13 18:32:37 2011 +0530

    ARM: OMAP3: PM: fix pwrdm_post_transition call sequence
    
    The context lost count is modified in omap_sram_idle() path when
    pwrdm_post_transition() is called. But pwrdm_post_transition() is called
    only after omap_gpio_resume_after_idle() is called. Correct this so that
    context lost count is modified before calling omap_gpio_resume_after_idle().
    
    This would be useful when OMAP GPIO save/restore context is called by
    the OMAP GPIO driver itself.
    
    Signed-off-by: Charulatha V <charu@ti.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 7255d9bce868..1915050e9401 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -363,7 +363,6 @@ void omap_sram_idle(void)
 		printk(KERN_ERR "Invalid mpu state in sram_idle\n");
 		return;
 	}
-	pwrdm_pre_transition();
 
 	/* NEON control */
 	if (pwrdm_read_pwrst(neon_pwrdm) == PWRDM_POWER_ON)
@@ -386,6 +385,8 @@ void omap_sram_idle(void)
 			if (!console_trylock())
 				goto console_still_active;
 
+	pwrdm_pre_transition();
+
 	/* PER */
 	if (per_next_state < PWRDM_POWER_ON) {
 		per_going_off = (per_next_state == PWRDM_POWER_OFF) ? 1 : 0;
@@ -455,6 +456,8 @@ void omap_sram_idle(void)
 	}
 	omap3_intc_resume_idle();
 
+	pwrdm_post_transition();
+
 	/* PER */
 	if (per_next_state < PWRDM_POWER_ON) {
 		per_prev_state = pwrdm_read_prev_pwrst(per_pwrdm);
@@ -478,8 +481,6 @@ void omap_sram_idle(void)
 		omap3_disable_io_chain();
 	}
 
-	pwrdm_post_transition();
-
 	clkdm_allow_idle(mpu_pwrdm->pwrdm_clkdms[0]);
 }
 

commit dca2d0eb5917ff132d9be13f0afa9ae5d4e80580
Author: Kevin Hilman <khilman@ti.com>
Date:   Tue Sep 13 11:18:44 2011 -0700

    OMAP3: PM: fix UART handling when using no_console_suspend
    
    During the idle/suspend path, we expect the console lock to be held so
    that no console output is done during/after the UARTs are idled.
    
    However, when using the no_console_suspend argument on the
    command-line, the console driver does not take the console lock.  This
    allows the possibility of console activity after UARTs have been
    disabled.
    
    To fix, update the current is_suspending() to also check the
    console_suspend_enabled flag.
    
    Reported-by: Abhilash Koyamangalath <abhilash.kv@ti.com>
    Tested-by: Abhilash Koyamangalath <abhilash.kv@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 7255d9bce868..c8cbd00a41af 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -55,7 +55,7 @@
 static suspend_state_t suspend_state = PM_SUSPEND_ON;
 static inline bool is_suspending(void)
 {
-	return (suspend_state != PM_SUSPEND_ON);
+	return (suspend_state != PM_SUSPEND_ON) && console_suspend_enabled;
 }
 #else
 static inline bool is_suspending(void)

commit ae4c42e4e4d76d003f8ca551fe1aef93ff9a4b21
Merge: dd58ecba48ed ab2a0e0d1354
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 25 12:38:42 2011 -0700

    Merge branch 'next/cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/linux-arm-soc
    
    * 'next/cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/linux-arm-soc: (133 commits)
      ARM: EXYNOS4: Change devname for FIMD clkdev
      ARM: S3C64XX: Cleanup mach/regs-fb.h from mach-s3c64xx
      ARM: S5PV210: Cleanup mach/regs-fb.h from mach-s5pv210
      ARM: S5PC100: Cleanup mach/regs-fb.h from mach-s5pc100
      ARM: S3C24XX: Use generic s3c_set_platdata for devices
      ARM: S3C64XX: Use generic s3c_set_platdata for OneNAND
      ARM: SAMSUNG: Use generic s3c_set_platdata for NAND
      ARM: SAMSUNG: Use generic s3c_set_platdata for USB OHCI
      ARM: SAMSUNG: Use generic s3c_set_platdata for HWMON
      ARM: SAMSUNG: Use generic s3c_set_platdata for FB
      ARM: SAMSUNG: Use generic s3c_set_platdata for TS
      ARM: S3C64XX: Add PWM backlight support on SMDK6410
      ARM: S5P64X0: Add PWM backlight support on SMDK6450
      ARM: S5P64X0: Add PWM backlight support on SMDK6440
      ARM: S5PC100: Add PWM backlight support on SMDKC100
      ARM: S5PV210: Add PWM backlight support on SMDKV210
      ARM: EXYNOS4: Add PWM backlight support on SMDKC210
      ARM: EXYNOS4: Add PWM backlight support on SMDKV310
      ARM: SAMSUNG: Create a common infrastructure for PWM backlight support
      clocksource: convert 32-bit down counting clocksource on S5PV210/S5P64X0
      ...
    
    Fix up trivial conflict in arch/arm/mach-imx/mach-scb9328.c

commit 29cb3cd208dd0e4471bb80bec4facc49ceb199fa
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jul 2 09:54:01 2011 +0100

    ARM: pm: allow suspend finisher to return error codes
    
    There are SoCs where attempting to enter a low power state is ignored,
    and the CPU continues executing instructions with all state preserved.
    It is over-complex at that point to disable the MMU just to call the
    resume path.
    
    Instead, allow the suspend finisher to return error codes to abort
    suspend in this circumstance, where the cpu_suspend internals will then
    unwind the saved state on the stack.  Also omit the tlb flush as no
    changes to the page tables will have happened.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 7238a63e24e2..b77d82665abb 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -321,9 +321,10 @@ static void omap34xx_save_context(u32 *save)
 	*save++ = val;
 }
 
-static void omap34xx_do_sram_idle(unsigned long save_state)
+static int omap34xx_do_sram_idle(unsigned long save_state)
 {
 	omap34xx_cpu_suspend(save_state);
+	return 0;
 }
 
 void omap_sram_idle(void)

commit cbe263497def23befb6f475977661bae5d1f82e4
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jun 30 08:45:49 2011 +0100

    ARM: pm: omap3: move saving of the auxiliary control registers to C
    
    Move the saving of the auxiliary control registers into C; there's
    no need for this to be in assembly code.  This results in less
    assembly code to deal with in OMAP.
    
    Kevin tested full-chip retention and off on 3430/n900, 3530/Overo and
    3630/Zoom3.
    
    Tested-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index e1c79bae7670..7238a63e24e2 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -306,9 +306,24 @@ static irqreturn_t prcm_interrupt_handler (int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+static void omap34xx_save_context(u32 *save)
+{
+	u32 val;
+
+	/* Read Auxiliary Control Register */
+	asm("mrc p15, 0, %0, c1, c0, 1" : "=r" (val));
+	*save++ = 1;
+	*save++ = val;
+
+	/* Read L2 AUX ctrl register */
+	asm("mrc p15, 1, %0, c9, c0, 2" : "=r" (val));
+	*save++ = 1;
+	*save++ = val;
+}
+
 static void omap34xx_do_sram_idle(unsigned long save_state)
 {
-	omap34xx_cpu_suspend(omap3_arm_context, save_state);
+	omap34xx_cpu_suspend(save_state);
 }
 
 void omap_sram_idle(void)
@@ -408,6 +423,8 @@ void omap_sram_idle(void)
 	 * get saved. The rest is placed on the stack, and restored
 	 * from there before resuming.
 	 */
+	if (save_state)
+		omap34xx_save_context(omap3_arm_context);
 	if (save_state == 1 || save_state == 3)
 		cpu_suspend(save_state, omap34xx_do_sram_idle);
 	else

commit 46e130d298a384b677426e19faec311749ff2677
Author: Jean Pihet <j-pihet@ti.com>
Date:   Wed Jun 29 18:40:23 2011 +0200

    ARM: pm: omap3: run the ASM sleep code from DDR
    
    Most of the ASM sleep code (in arch/arm/mach-omap2/sleep34xx.S)
    is copied to internal SRAM at boot and after wake-up from CORE OFF
    mode.  However only a small part of the code really needs to run from
    internal SRAM.
    
    This fix lets most of the ASM idle code run from the DDR in order to
    minimize the SRAM usage and the overhead in the code copy.
    
    The only pieces of code that are mandatory in SRAM are:
    - the i443 erratum WA,
    - the i581 erratum WA,
    - the security extension code.
    
    SRAM usage:
    - original code:
      . 560 bytes for omap3_sram_configure_core_dpll (used by DVFS),
      . 852 bytes for omap_sram_idle (used by suspend/resume in RETention),
      . 124 bytes for es3_sdrc_fix (used by suspend/resume in OFF mode on ES3.x),
      . 108 bytes for save_secure_ram_context (used on HS parts only).
    
    With this fix the usage for suspend/resume in RETention goes down 288
    bytes, so the gain in SRAM usage for suspend/resume is 564 bytes.
    
    Also fixed the SRAM initialization sequence to avoid an unnecessary
    copy to SRAM at boot time and for readability.
    
    Tested on Beagleboard (ES2.x) in idle with full RET and OFF modes.
    
    Kevin Hilman tested retention and off on 3430/n900, 3530/Overo and
    3630/Zoom3
    
    Signed-off-by: Jean Pihet <j-pihet@ti.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Tested-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 3e9a13e1ac57..e1c79bae7670 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -78,9 +78,8 @@ struct power_state {
 
 static LIST_HEAD(pwrst_list);
 
-static void (*_omap_sram_idle)(u32 *addr, int save_state);
-
 static int (*_omap_save_secure_sram)(u32 *addr);
+void (*omap3_do_wfi_sram)(void);
 
 static struct powerdomain *mpu_pwrdm, *neon_pwrdm;
 static struct powerdomain *core_pwrdm, *per_pwrdm;
@@ -309,7 +308,7 @@ static irqreturn_t prcm_interrupt_handler (int irq, void *dev_id)
 
 static void omap34xx_do_sram_idle(unsigned long save_state)
 {
-	_omap_sram_idle(omap3_arm_context, save_state);
+	omap34xx_cpu_suspend(omap3_arm_context, save_state);
 }
 
 void omap_sram_idle(void)
@@ -328,9 +327,6 @@ void omap_sram_idle(void)
 	int core_prev_state, per_prev_state;
 	u32 sdrc_pwr = 0;
 
-	if (!_omap_sram_idle)
-		return;
-
 	pwrdm_clear_all_prev_pwrst(mpu_pwrdm);
 	pwrdm_clear_all_prev_pwrst(neon_pwrdm);
 	pwrdm_clear_all_prev_pwrst(core_pwrdm);
@@ -826,10 +822,17 @@ static int __init clkdms_setup(struct clockdomain *clkdm, void *unused)
 	return 0;
 }
 
+/*
+ * Push functions to SRAM
+ *
+ * The minimum set of functions is pushed to SRAM for execution:
+ * - omap3_do_wfi for erratum i581 WA,
+ * - save_secure_ram_context for security extensions.
+ */
 void omap_push_sram_idle(void)
 {
-	_omap_sram_idle = omap_sram_push(omap34xx_cpu_suspend,
-					omap34xx_cpu_suspend_sz);
+	omap3_do_wfi_sram = omap_sram_push(omap3_do_wfi, omap3_do_wfi_sz);
+
 	if (omap_type() != OMAP2_DEVICE_TYPE_GP)
 		_omap_save_secure_sram = omap_sram_push(save_secure_ram_context,
 				save_secure_ram_context_sz);
@@ -894,7 +897,6 @@ static int __init omap3_pm_init(void)
 	per_clkdm = clkdm_lookup("per_clkdm");
 	core_clkdm = clkdm_lookup("core_clkdm");
 
-	omap_push_sram_idle();
 #ifdef CONFIG_SUSPEND
 	suspend_set_ops(&omap_pm_ops);
 #endif /* CONFIG_SUSPEND */

commit 48cb1258e8b0f8c81cfb699b42326c5b2147b3f8
Merge: 332acd9e534e ec3cdb5baedf
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Jun 29 04:45:16 2011 -0700

    Merge branch 'for_3.1/pm-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/khilman/linux-omap-pm into devel-cleanup
    
    Conflicts:
            arch/arm/mach-omap2/pm-debug.c
            arch/arm/mach-omap2/pm.h

commit 2c74a0cefa463a7a483b07ba4d2ea8e4ec7b996c
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Jun 22 17:41:48 2011 +0100

    ARM: pm: hide 1st and 2nd arguments to cpu_suspend from platform code
    
    The first and second arguments shouldn't concern platform code, so
    hide them from each platforms caller.
    
    Tested-by: Kevin Hilman <khilman@ti.com>
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index ae4017750bbe..3e9a13e1ac57 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -31,6 +31,8 @@
 #include <linux/console.h>
 #include <trace/events/power.h>
 
+#include <asm/suspend.h>
+
 #include <plat/sram.h>
 #include "clockdomain.h"
 #include "powerdomain.h"
@@ -411,8 +413,7 @@ void omap_sram_idle(void)
 	 * from there before resuming.
 	 */
 	if (save_state == 1 || save_state == 3)
-		cpu_suspend(0, PHYS_OFFSET - PAGE_OFFSET, save_state,
-			    omap34xx_do_sram_idle);
+		cpu_suspend(save_state, omap34xx_do_sram_idle);
 	else
 		omap34xx_do_sram_idle(save_state);
 

commit 076f2cc449188b7d3d4866730afa3ac7be3e6640
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Wed Jun 22 15:42:54 2011 +0100

    ARM: pm: omap34xx: convert to generic suspend/resume support
    
    Convert omap34xx to use the generic CPU suspend/resume support, rather
    than implementing its own version.  Tested on 3430 LDP.
    
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Tested-by: Kevin Hilman <khilman@ti.com>
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index c155c9d1c82c..ae4017750bbe 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -40,8 +40,6 @@
 #include <plat/gpmc.h>
 #include <plat/dma.h>
 
-#include <asm/tlbflush.h>
-
 #include "cm2xxx_3xxx.h"
 #include "cm-regbits-34xx.h"
 #include "prm-regbits-34xx.h"
@@ -64,11 +62,6 @@ static inline bool is_suspending(void)
 }
 #endif
 
-/* Scratchpad offsets */
-#define OMAP343X_TABLE_ADDRESS_OFFSET	   0xc4
-#define OMAP343X_TABLE_VALUE_OFFSET	   0xc0
-#define OMAP343X_CONTROL_REG_VALUE_OFFSET  0xc8
-
 /* pm34xx errata defined in pm.h */
 u16 pm34xx_errata;
 
@@ -312,28 +305,9 @@ static irqreturn_t prcm_interrupt_handler (int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-/* Function to restore the table entry that was modified for enabling MMU */
-static void restore_table_entry(void)
+static void omap34xx_do_sram_idle(unsigned long save_state)
 {
-	void __iomem *scratchpad_address;
-	u32 previous_value, control_reg_value;
-	u32 *address;
-
-	scratchpad_address = OMAP2_L4_IO_ADDRESS(OMAP343X_SCRATCHPAD);
-
-	/* Get address of entry that was modified */
-	address = (u32 *)__raw_readl(scratchpad_address +
-				     OMAP343X_TABLE_ADDRESS_OFFSET);
-	/* Get the previous value which needs to be restored */
-	previous_value = __raw_readl(scratchpad_address +
-				     OMAP343X_TABLE_VALUE_OFFSET);
-	address = __va(address);
-	*address = previous_value;
-	flush_tlb_all();
-	control_reg_value = __raw_readl(scratchpad_address
-					+ OMAP343X_CONTROL_REG_VALUE_OFFSET);
-	/* This will enable caches and prediction */
-	set_cr(control_reg_value);
+	_omap_sram_idle(omap3_arm_context, save_state);
 }
 
 void omap_sram_idle(void)
@@ -432,12 +406,15 @@ void omap_sram_idle(void)
 		sdrc_pwr = sdrc_read_reg(SDRC_POWER);
 
 	/*
-	 * omap3_arm_context is the location where ARM registers
-	 * get saved. The restore path then reads from this
-	 * location and restores them back.
+	 * omap3_arm_context is the location where some ARM context
+	 * get saved. The rest is placed on the stack, and restored
+	 * from there before resuming.
 	 */
-	_omap_sram_idle(omap3_arm_context, save_state);
-	cpu_init();
+	if (save_state == 1 || save_state == 3)
+		cpu_suspend(0, PHYS_OFFSET - PAGE_OFFSET, save_state,
+			    omap34xx_do_sram_idle);
+	else
+		omap34xx_do_sram_idle(save_state);
 
 	/* Restore normal SDRC POWER settings */
 	if (omap_rev() >= OMAP3430_REV_ES3_0 &&
@@ -445,10 +422,6 @@ void omap_sram_idle(void)
 	    core_next_state == PWRDM_POWER_OFF)
 		sdrc_write_reg(sdrc_pwr, SDRC_POWER);
 
-	/* Restore table entry modified during MMU restoration */
-	if (pwrdm_read_prev_pwrst(mpu_pwrdm) == PWRDM_POWER_OFF)
-		restore_table_entry();
-
 	/* CORE */
 	if (core_next_state < PWRDM_POWER_ON) {
 		core_prev_state = pwrdm_read_prev_pwrst(core_pwrdm);

commit 3a7b7bdd24286a9cfce9dda5d2b7324dfc2e3b31
Author: Kevin Hilman <khilman@ti.com>
Date:   Thu May 26 14:48:19 2011 -0700

    OMAP3: PM debug: remove sleep_while_idle feature
    
    Remove the OMAP-specific PM debug 'sleep_while_idle' feature which is
    currently available as an OMAP-specific debugfs entry.
    
    This duplicates existing ARM-generic functionality available as a
    boot-time option using the boot cmdline option 'hohlt'.
    
    If runtime configuration of this is needed, then adding a debugfs
    entry for the ARM-generic hlt/nohlt interface should be added.
    
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index c155c9d1c82c..cb342447544c 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -497,8 +497,6 @@ void omap_sram_idle(void)
 
 int omap3_can_sleep(void)
 {
-	if (!sleep_while_idle)
-		return 0;
 	if (!omap_uart_can_sleep())
 		return 0;
 	return 1;

commit 98e182a26bbbf5575457622337684ef61493e864
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Mar 29 15:54:49 2011 -0700

    omap2+: Remove gptimer_wakeup for now
    
    This removes the support for setting the wake-up timer for debugging.
    
    Later on we can reserve gptimer1 for PM code only and have similar
    functionality.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index c155c9d1c82c..4cb636af7045 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -534,10 +534,6 @@ static int omap3_pm_suspend(void)
 	struct power_state *pwrst;
 	int state, ret = 0;
 
-	if (wakeup_timer_seconds || wakeup_timer_milliseconds)
-		omap2_pm_wakeup_on_timer(wakeup_timer_seconds,
-					 wakeup_timer_milliseconds);
-
 	/* Read current next_pwrsts */
 	list_for_each_entry(pwrst, &pwrst_list, node)
 		pwrst->saved_state = pwrdm_read_next_pwrst(pwrst->pwrdm);

commit 99aa18278e867574d72201b806f82ace07d4804b
Author: Sanjeev Premi <premi@ti.com>
Date:   Wed May 18 14:44:40 2011 +0530

    OMAP3: PM: Boot message is not an error, and not helpful, remove it
    
    It shows up on the console despite using "silent" in the bootargs, and
    it's really just noise in the boot log since PM init is always called.
    
    Signed-off-by: Sanjeev Premi <premi@ti.com>
    Cc: jhnikula@gmail.com
    [khilman@ti.com: minor changelog edits]
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index caf9f6cb3908..c155c9d1c82c 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -883,8 +883,6 @@ static int __init omap3_pm_init(void)
 
 	pm_errata_configure();
 
-	printk(KERN_ERR "Power Management for TI OMAP3.\n");
-
 	/* XXX prcm_setup_regs needs to be before enabling hw
 	 * supervised mode for powerdomains */
 	prcm_setup_regs();

commit 04908918191f7926ec7af99890fb4ddb3b769c13
Author: Jean Pihet <j-pihet@ti.com>
Date:   Mon May 9 12:02:16 2011 +0200

    OMAP3: cpuidle: change the power domains modes determination logic
    
    The achievable power modes of the power domains in cpuidle
    depends on the system wide 'enable_off_mode' knob in debugfs.
    Upon changing enable_off_mode, do not change the C-states
    'valid' field but instead dynamically restrict the power modes
    when entering idle.
    
    The C-states 'valid' field is just used to enable/disable some
    C-states at init and shall not be changed later on.
    
    Signed-off-by: Jean Pihet <j-pihet@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 0c5e3a46a3ad..caf9f6cb3908 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -779,18 +779,6 @@ void omap3_pm_off_mode_enable(int enable)
 	else
 		state = PWRDM_POWER_RET;
 
-#ifdef CONFIG_CPU_IDLE
-	/*
-	 * Erratum i583: implementation for ES rev < Es1.2 on 3630. We cannot
-	 * enable OFF mode in a stable form for previous revisions, restrict
-	 * instead to RET
-	 */
-	if (IS_PM34XX_ERRATUM(PM_SDRC_WAKEUP_ERRATUM_i583))
-		omap3_cpuidle_update_states(state, PWRDM_POWER_RET);
-	else
-		omap3_cpuidle_update_states(state, state);
-#endif
-
 	list_for_each_entry(pwrst, &pwrst_list, node) {
 		if (IS_PM34XX_ERRATUM(PM_SDRC_WAKEUP_ERRATUM_i583) &&
 				pwrst->pwrdm == core_pwrdm &&

commit 0d9596958d0be59e6bb373b5e6bc0729cbba5110
Merge: a2358a7bc35e 5e7c58dc8d9b
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Mar 11 09:39:58 2011 -0800

    Merge branch 'for_2.6.39/pm-integration' of ssh://master.kernel.org/pub/scm/linux/kernel/git/khilman/linux-omap-pm into omap-for-linus

commit a2358a7bc35e388978fc2f7f6b071a0fd27d78c1
Merge: 94a06b74e724 a08572ae529b
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Mar 11 09:20:03 2011 -0800

    Merge branch 'integration-2.6.39-for-tony' of git://git.pwsan.com/linux-integration into omap-for-linus
    
    Conflicts:
            arch/arm/mach-omap2/pm34xx.c

commit 5e7c58dc8d9b7f31d418cf98c6a8cad84b86f510
Author: Jean Pihet <jean.pihet@newoldbits.com>
Date:   Thu Mar 3 11:25:43 2011 +0100

    perf: add OMAP support for the new power events
    
    The patch adds the new power management trace points for
    the OMAP architecture.
    
    The trace points are for:
    - default idle handler. Since the cpuidle framework is
      instrumented in the generic way there is no need to
      add trace points in the OMAP specific cpuidle handler;
    - SoC clocks changes (enable, disable, set_rate),
    - power domain states: the desired target state and -if different-
      the actually hit state.
    
    Because of the generic nature of the changes, OMAP3 and OMAP4 are supported.
    
    Tested on OMAP3 with suspend/resume, cpuidle, basic DVFS.
    
    Signed-off-by: Jean Pihet <j-pihet@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 3d6a00e07a5b..93e78a3dbc17 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -29,6 +29,7 @@
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/console.h>
+#include <trace/events/power.h>
 
 #include <plat/sram.h>
 #include "clockdomain.h"
@@ -519,8 +520,14 @@ static void omap3_pm_idle(void)
 	if (omap_irq_pending() || need_resched())
 		goto out;
 
+	trace_power_start(POWER_CSTATE, 1, smp_processor_id());
+	trace_cpu_idle(1, smp_processor_id());
+
 	omap_sram_idle();
 
+	trace_power_end(smp_processor_id());
+	trace_cpu_idle(PWR_EVENT_EXIT, smp_processor_id());
+
 out:
 	local_fiq_enable();
 	local_irq_enable();

commit 261bfb286eab32aa6129f48d2b2d24f20825757b
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Fri Feb 11 20:42:11 2011 +0530

    omap3: pm: Use exported set_cr() instead of a custom one.
    
    Remove the custom restore_control_register() and use the exported
    set_cr() instead to set the system control register(SCTRL) value.
    
    No functional change.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index b9427c75f427..1883a464aace 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -311,11 +311,6 @@ static irqreturn_t prcm_interrupt_handler (int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static void restore_control_register(u32 val)
-{
-	__asm__ __volatile__ ("mcr p15, 0, %0, c1, c0, 0" : : "r" (val));
-}
-
 /* Function to restore the table entry that was modified for enabling MMU */
 static void restore_table_entry(void)
 {
@@ -337,7 +332,7 @@ static void restore_table_entry(void)
 	control_reg_value = __raw_readl(scratchpad_address
 					+ OMAP343X_CONTROL_REG_VALUE_OFFSET);
 	/* This will enable caches and prediction */
-	restore_control_register(control_reg_value);
+	set_cr(control_reg_value);
 }
 
 void omap_sram_idle(void)

commit 51d070afd6f927752c76a0cc537c73737578bb93
Author: Paul Walmsley <paul@pwsan.com>
Date:   Thu Jan 27 02:52:55 2011 -0700

    OMAP2/3: PM: remove unnecessary wakeup/sleep dependency clear
    
    The OMAP2 and OMAP3 PM code clears clockdomain wakeup and sleep
    dependencies.  This is unnecessary after commit
    6f7f63cc9adf3192e6fcac4e8bed5cc10fd924aa ("OMAP clockdomain:
    initialize clockdomain registers when the clockdomain layer starts")
    which clears these dependencies during clockdomain init.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 6ade4eaca922..b9427c75f427 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -695,21 +695,6 @@ static void __init prcm_setup_regs(void)
 	u32 omap3630_grpsel_uart4_mask = cpu_is_omap3630() ?
 					OMAP3630_GRPSEL_UART4_MASK : 0;
 
-
-	/* XXX Reset all wkdeps. This should be done when initializing
-	 * powerdomains */
-	omap2_prm_write_mod_reg(0, OMAP3430_IVA2_MOD, PM_WKDEP);
-	omap2_prm_write_mod_reg(0, MPU_MOD, PM_WKDEP);
-	omap2_prm_write_mod_reg(0, OMAP3430_DSS_MOD, PM_WKDEP);
-	omap2_prm_write_mod_reg(0, OMAP3430_NEON_MOD, PM_WKDEP);
-	omap2_prm_write_mod_reg(0, OMAP3430_CAM_MOD, PM_WKDEP);
-	omap2_prm_write_mod_reg(0, OMAP3430_PER_MOD, PM_WKDEP);
-	if (omap_rev() > OMAP3430_REV_ES1_0) {
-		omap2_prm_write_mod_reg(0, OMAP3430ES2_SGX_MOD, PM_WKDEP);
-		omap2_prm_write_mod_reg(0, OMAP3430ES2_USBHOST_MOD, PM_WKDEP);
-	} else
-		omap2_prm_write_mod_reg(0, GFX_MOD, PM_WKDEP);
-
 	/*
 	 * Enable interface clock autoidle for all modules.
 	 * Note that in the long run this should be done by clockfw

commit e16b41bfd5efaa1f9521449f1f0e341ebec73398
Author: Ricardo Salveti de Araujo <ricardo.salveti@canonical.com>
Date:   Mon Jan 31 11:35:25 2011 -0200

    OMAP3630: PM: don't warn the user with a trace in case of PM34XX_ERRATUM
    
    In case in user has a OMAP3630 < ES1.2 the kernel should warn the user
    about the ERRATUM, but using pr_warn instead of WARN_ON is already
    enough, as there is nothing else the user can do besides changing the
    board.
    
    Signed-off-by: Ricardo Salveti de Araujo <ricardo.salveti@canonical.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 2f864e4b085d..6ade4eaca922 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -928,8 +928,7 @@ void omap3_pm_off_mode_enable(int enable)
 				pwrst->pwrdm == core_pwrdm &&
 				state == PWRDM_POWER_OFF) {
 			pwrst->next_state = PWRDM_POWER_RET;
-			WARN_ONCE(1,
-				"%s: Core OFF disabled due to errata i583\n",
+			pr_warn("%s: Core OFF disabled due to errata i583\n",
 				__func__);
 		} else {
 			pwrst->next_state = state;

commit 4ef70c0694bf428d9f1d4722edaffa1dc5fa39e1
Author: Paul Walmsley <paul@pwsan.com>
Date:   Fri Feb 25 15:39:30 2011 -0700

    OMAP2/3: PM: remove manual CM_AUTOIDLE bit setting in mach-omap2/pm*xx.c
    
    These CM_AUTOIDLE bits are now set by the clock code via the common PM
    code in mach-omap2/pm.c.
    
    N.B.: The pm24xx.c code that this patch removes didn't ensure that the
    CM_AUTOIDLE bits were set for several 2430-only modules, such as
    GPIO5, MDM_INTC, MMCHS1/2, the modem oscillator clock, and USBHS.
    Similarly, the pm34xx.c code that this patch removes didn't ensure
    that the CM_AUTOIDLE bits were set for USIM and the AM3517 UART4.
    Those cases should now be handled.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@ti.com>
    Tested-by: Rajendra Nayak <rnayak@ti.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index a99f296bdbfd..3d6a00e07a5b 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -688,14 +688,11 @@ static void __init omap3_d2d_idle(void)
 
 static void __init prcm_setup_regs(void)
 {
-	u32 omap3630_auto_uart4_mask = cpu_is_omap3630() ?
-					OMAP3630_AUTO_UART4_MASK : 0;
 	u32 omap3630_en_uart4_mask = cpu_is_omap3630() ?
 					OMAP3630_EN_UART4_MASK : 0;
 	u32 omap3630_grpsel_uart4_mask = cpu_is_omap3630() ?
 					OMAP3630_GRPSEL_UART4_MASK : 0;
 
-
 	/* XXX Reset all wkdeps. This should be done when initializing
 	 * powerdomains */
 	omap2_prm_write_mod_reg(0, OMAP3430_IVA2_MOD, PM_WKDEP);
@@ -710,107 +707,7 @@ static void __init prcm_setup_regs(void)
 	} else
 		omap2_prm_write_mod_reg(0, GFX_MOD, PM_WKDEP);
 
-	/*
-	 * Enable interface clock autoidle for all modules.
-	 * Note that in the long run this should be done by clockfw
-	 */
-	omap2_cm_write_mod_reg(
-		OMAP3430_AUTO_MODEM_MASK |
-		OMAP3430ES2_AUTO_MMC3_MASK |
-		OMAP3430ES2_AUTO_ICR_MASK |
-		OMAP3430_AUTO_AES2_MASK |
-		OMAP3430_AUTO_SHA12_MASK |
-		OMAP3430_AUTO_DES2_MASK |
-		OMAP3430_AUTO_MMC2_MASK |
-		OMAP3430_AUTO_MMC1_MASK |
-		OMAP3430_AUTO_MSPRO_MASK |
-		OMAP3430_AUTO_HDQ_MASK |
-		OMAP3430_AUTO_MCSPI4_MASK |
-		OMAP3430_AUTO_MCSPI3_MASK |
-		OMAP3430_AUTO_MCSPI2_MASK |
-		OMAP3430_AUTO_MCSPI1_MASK |
-		OMAP3430_AUTO_I2C3_MASK |
-		OMAP3430_AUTO_I2C2_MASK |
-		OMAP3430_AUTO_I2C1_MASK |
-		OMAP3430_AUTO_UART2_MASK |
-		OMAP3430_AUTO_UART1_MASK |
-		OMAP3430_AUTO_GPT11_MASK |
-		OMAP3430_AUTO_GPT10_MASK |
-		OMAP3430_AUTO_MCBSP5_MASK |
-		OMAP3430_AUTO_MCBSP1_MASK |
-		OMAP3430ES1_AUTO_FAC_MASK | /* This is es1 only */
-		OMAP3430_AUTO_MAILBOXES_MASK |
-		OMAP3430_AUTO_OMAPCTRL_MASK |
-		OMAP3430ES1_AUTO_FSHOSTUSB_MASK |
-		OMAP3430_AUTO_HSOTGUSB_MASK |
-		OMAP3430_AUTO_SAD2D_MASK |
-		OMAP3430_AUTO_SSI_MASK,
-		CORE_MOD, CM_AUTOIDLE1);
-
-	omap2_cm_write_mod_reg(
-		OMAP3430_AUTO_PKA_MASK |
-		OMAP3430_AUTO_AES1_MASK |
-		OMAP3430_AUTO_RNG_MASK |
-		OMAP3430_AUTO_SHA11_MASK |
-		OMAP3430_AUTO_DES1_MASK,
-		CORE_MOD, CM_AUTOIDLE2);
-
-	if (omap_rev() > OMAP3430_REV_ES1_0) {
-		omap2_cm_write_mod_reg(
-			OMAP3430_AUTO_MAD2D_MASK |
-			OMAP3430ES2_AUTO_USBTLL_MASK,
-			CORE_MOD, CM_AUTOIDLE3);
-	}
-
-	omap2_cm_write_mod_reg(
-		OMAP3430_AUTO_WDT2_MASK |
-		OMAP3430_AUTO_WDT1_MASK |
-		OMAP3430_AUTO_GPIO1_MASK |
-		OMAP3430_AUTO_32KSYNC_MASK |
-		OMAP3430_AUTO_GPT12_MASK |
-		OMAP3430_AUTO_GPT1_MASK,
-		WKUP_MOD, CM_AUTOIDLE);
-
-	omap2_cm_write_mod_reg(
-		OMAP3430_AUTO_DSS_MASK,
-		OMAP3430_DSS_MOD,
-		CM_AUTOIDLE);
-
-	omap2_cm_write_mod_reg(
-		OMAP3430_AUTO_CAM_MASK,
-		OMAP3430_CAM_MOD,
-		CM_AUTOIDLE);
-
-	omap2_cm_write_mod_reg(
-		omap3630_auto_uart4_mask |
-		OMAP3430_AUTO_GPIO6_MASK |
-		OMAP3430_AUTO_GPIO5_MASK |
-		OMAP3430_AUTO_GPIO4_MASK |
-		OMAP3430_AUTO_GPIO3_MASK |
-		OMAP3430_AUTO_GPIO2_MASK |
-		OMAP3430_AUTO_WDT3_MASK |
-		OMAP3430_AUTO_UART3_MASK |
-		OMAP3430_AUTO_GPT9_MASK |
-		OMAP3430_AUTO_GPT8_MASK |
-		OMAP3430_AUTO_GPT7_MASK |
-		OMAP3430_AUTO_GPT6_MASK |
-		OMAP3430_AUTO_GPT5_MASK |
-		OMAP3430_AUTO_GPT4_MASK |
-		OMAP3430_AUTO_GPT3_MASK |
-		OMAP3430_AUTO_GPT2_MASK |
-		OMAP3430_AUTO_MCBSP4_MASK |
-		OMAP3430_AUTO_MCBSP3_MASK |
-		OMAP3430_AUTO_MCBSP2_MASK,
-		OMAP3430_PER_MOD,
-		CM_AUTOIDLE);
-
-	if (omap_rev() > OMAP3430_REV_ES1_0) {
-		omap2_cm_write_mod_reg(
-			OMAP3430ES2_AUTO_USBHOST_MASK,
-			OMAP3430ES2_USBHOST_MOD,
-			CM_AUTOIDLE);
-	}
-
+	/* XXX This should be handled by hwmod code or SCM init code */
 	omap_ctrl_writel(OMAP3430_AUTOIDLE_MASK, OMAP2_CONTROL_SYSCONFIG);
 
 	/*

commit b80b956dc56c6a3cb77b97e2abff48fb7ebc2119
Author: Paul Walmsley <paul@pwsan.com>
Date:   Fri Feb 25 15:49:01 2011 -0700

    OMAP2+: clock: autoidle as many clocks as possible if CONFIG_OMAP_RESET_CLOCKS
    
    Attempt to enable autoidle for as many clocks as possible in the
    OMAP2+-common CONFIG_OMAP_RESET_CLOCKS code.  Currently, this only
    enables DPLL autoidle for OMAP3/4 DPLLs; but future patches will
    enable autoidle for other clocks and the OMAP2 DPLL/APLLs.
    
    In the long run, we should probably get rid of
    CONFIG_OMAP_RESET_CLOCKS, and unconditionally run the code that it
    selects.  Otherwise, the state of the clock tree won't match the
    hardware state - this could result in clocks being enabled or disabled
    unpredictably.
    
    Based on a patch by Rajendra Nayak <rnayak@ti.com> that did this in
    the pm34xx.c/pm44xx.c code.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Rajendra Nayak <rnayak@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index eda9a4e99a89..a99f296bdbfd 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -813,23 +813,6 @@ static void __init prcm_setup_regs(void)
 
 	omap_ctrl_writel(OMAP3430_AUTOIDLE_MASK, OMAP2_CONTROL_SYSCONFIG);
 
-	/*
-	 * Set all plls to autoidle. This is needed until autoidle is
-	 * enabled by clockfw
-	 */
-	omap2_cm_write_mod_reg(1 << OMAP3430_AUTO_IVA2_DPLL_SHIFT,
-			 OMAP3430_IVA2_MOD, CM_AUTOIDLE2);
-	omap2_cm_write_mod_reg(1 << OMAP3430_AUTO_MPU_DPLL_SHIFT,
-			 MPU_MOD,
-			 CM_AUTOIDLE2);
-	omap2_cm_write_mod_reg((1 << OMAP3430_AUTO_PERIPH_DPLL_SHIFT) |
-			 (1 << OMAP3430_AUTO_CORE_DPLL_SHIFT),
-			 PLL_MOD,
-			 CM_AUTOIDLE);
-	omap2_cm_write_mod_reg(1 << OMAP3430ES2_AUTO_PERIPH2_DPLL_SHIFT,
-			 PLL_MOD,
-			 CM_AUTOIDLE2);
-
 	/*
 	 * Enable control of expternal oscillator through
 	 * sys_clkreq. In the long run clock framework should

commit 5cd1937b6d5990fe5d5287d925f05afd38e9fb02
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Feb 25 16:06:48 2011 -0700

    OMAP: clockdomain: Arch specific funcs for hwsup control of clkdm
    
    Define the following architecture specific funtions for omap2/3/4
    .clkdm_allow_idle
    .clkdm_deny_idle
    
    Convert the platform-independent framework to call these functions.
    Also rename the api's by removing the omap2_ preamble.
    Hence call omap2_clkdm_allow_idle as clkdm_allow_idle and
    omap2_clkdm_deny_idle as clkdm_deny_idle.
    
    Make the _clkdm_add_autodeps and _clkdm_del_autodeps as non-static
    so they can be accessed from OMAP2/3 platform specific code.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 81df2b169a56..eda9a4e99a89 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -496,7 +496,7 @@ void omap_sram_idle(void)
 
 	pwrdm_post_transition();
 
-	omap2_clkdm_allow_idle(mpu_pwrdm->pwrdm_clkdms[0]);
+	clkdm_allow_idle(mpu_pwrdm->pwrdm_clkdms[0]);
 }
 
 int omap3_can_sleep(void)
@@ -990,7 +990,7 @@ static int __init pwrdms_setup(struct powerdomain *pwrdm, void *unused)
 static int __init clkdms_setup(struct clockdomain *clkdm, void *unused)
 {
 	if (clkdm->flags & CLKDM_CAN_ENABLE_AUTO)
-		omap2_clkdm_allow_idle(clkdm);
+		clkdm_allow_idle(clkdm);
 	else if (clkdm->flags & CLKDM_CAN_FORCE_SLEEP &&
 		 atomic_read(&clkdm->usecount) == 0)
 		clkdm_sleep(clkdm);

commit 68b921ad7f35e0323ce0d9fe94e5701a112f257c
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Feb 25 16:06:47 2011 -0700

    OMAP: clockdomain: Arch specific funcs for sleep/wakeup of clkdm
    
    Define the following architecture specific funtions for omap2/3/4
    .clkdm_sleep
    .clkdm_wakeup
    
    Convert the platform-independent framework to call these functions.
    Also rename the api's by removing the omap2_ preamble.
    Hence call omap2_clkdm_wakeup as clkdm_wakeup and
    omap2_clkdm_sleep as clkdm_sleep.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    [paul@pwsan.com: fixed omap3_clkdm_clear_all_sleepdeps() and
     omap2_clkdm_clear_all_wkdeps() to test against the correct
     loop termination condition; thanks to Kevin Hilman for finding and
     helping fix]
    Cc: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 2f864e4b085d..81df2b169a56 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -993,7 +993,7 @@ static int __init clkdms_setup(struct clockdomain *clkdm, void *unused)
 		omap2_clkdm_allow_idle(clkdm);
 	else if (clkdm->flags & CLKDM_CAN_FORCE_SLEEP &&
 		 atomic_read(&clkdm->usecount) == 0)
-		omap2_clkdm_sleep(clkdm);
+		clkdm_sleep(clkdm);
 	return 0;
 }
 

commit 112258b1d215a16d575dc6ace344a0bb7196c19c
Merge: 0e6d8cad448b 8353584eae4a
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Jan 31 13:20:26 2011 -0800

    Merge branch 'for_2.6.38/pm-fixes' of ssh://master.kernel.org/pub/scm/linux/kernel/git/khilman/linux-omap-pm into devel-fixes

commit 617fcc98020bbc9492cacdef40423b758c02a9df
Author: Kevin Hilman <khilman@ti.com>
Date:   Tue Jan 25 16:40:01 2011 -0800

    OMAP3: PM: fix save secure RAM to restore MPU power state
    
    Currently, on HS/EMU devices, MPU power state forced to on during PM
    init by the save secure RAM code.  Rather than forcing the state of
    MPU powerdomain to on, simply read the current value and restore it
    after the ROM code has run.
    
    This only affects the !CPUidle case since when CPUidle is enabled, the
    MPU power state is dynamically changed by CPUidle.  In the !CPUidle
    case, MPU power state is initialized once at init and never touched.
    
    Acked-by: Tero Kristo <tero.kristo@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 8cbbeade4b8a..1916038b267d 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -168,9 +168,10 @@ static void omap3_core_restore_context(void)
  * once during boot sequence, but this works as we are not using secure
  * services.
  */
-static void omap3_save_secure_ram_context(u32 target_mpu_state)
+static void omap3_save_secure_ram_context(void)
 {
 	u32 ret;
+	int mpu_next_state = pwrdm_read_next_pwrst(mpu_pwrdm);
 
 	if (omap_type() != OMAP2_DEVICE_TYPE_GP) {
 		/*
@@ -181,7 +182,7 @@ static void omap3_save_secure_ram_context(u32 target_mpu_state)
 		pwrdm_set_next_pwrst(mpu_pwrdm, PWRDM_POWER_ON);
 		ret = _omap_save_secure_sram((u32 *)
 				__pa(omap3_secure_ram_storage));
-		pwrdm_set_next_pwrst(mpu_pwrdm, target_mpu_state);
+		pwrdm_set_next_pwrst(mpu_pwrdm, mpu_next_state);
 		/* Following is for error tracking, it should not happen */
 		if (ret) {
 			printk(KERN_ERR "save_secure_sram() returns %08x\n",
@@ -1094,7 +1095,7 @@ static int __init omap3_pm_init(void)
 		local_fiq_disable();
 
 		omap_dma_global_context_save();
-		omap3_save_secure_ram_context(PWRDM_POWER_ON);
+		omap3_save_secure_ram_context();
 		omap_dma_global_context_restore();
 
 		local_irq_enable();

commit ac751efa6a0d70f2c9daef5c7e3a92270f5c2dff
Author: Torben Hohn <torbenh@gmx.de>
Date:   Tue Jan 25 15:07:35 2011 -0800

    console: rename acquire/release_console_sem() to console_lock/unlock()
    
    The -rt patches change the console_semaphore to console_mutex.  As a
    result, a quite large chunk of the patches changes all
    acquire/release_console_sem() to acquire/release_console_mutex()
    
    This commit makes things use more neutral function names which dont make
    implications about the underlying lock.
    
    The only real change is the return value of console_trylock which is
    inverted from try_acquire_console_sem()
    
    This patch also paves the way to switching console_sem from a semaphore to
    a mutex.
    
    [akpm@linux-foundation.org: coding-style fixes]
    [akpm@linux-foundation.org: make console_trylock return 1 on success, per Geert]
    Signed-off-by: Torben Hohn <torbenh@gmx.de>
    Cc: Thomas Gleixner <tglx@tglx.de>
    Cc: Greg KH <gregkh@suse.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 8cbbeade4b8a..a4aa1920a75c 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -398,7 +398,7 @@ void omap_sram_idle(void)
 	if (!is_suspending())
 		if (per_next_state < PWRDM_POWER_ON ||
 		    core_next_state < PWRDM_POWER_ON)
-			if (try_acquire_console_sem())
+			if (!console_trylock())
 				goto console_still_active;
 
 	/* PER */
@@ -481,7 +481,7 @@ void omap_sram_idle(void)
 	}
 
 	if (!is_suspending())
-		release_console_sem();
+		console_unlock();
 
 console_still_active:
 	/* Disable IO-PAD and IO-CHAIN wakeup */

commit 008d23e4852d78bb2618f2035f8b2110b6a6b968
Merge: 8f685fbda43d bfc672dcf323
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 13 10:05:56 2011 -0800

    Merge branch 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    * 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (43 commits)
      Documentation/trace/events.txt: Remove obsolete sched_signal_send.
      writeback: fix global_dirty_limits comment runtime -> real-time
      ppc: fix comment typo singal -> signal
      drivers: fix comment typo diable -> disable.
      m68k: fix comment typo diable -> disable.
      wireless: comment typo fix diable -> disable.
      media: comment typo fix diable -> disable.
      remove doc for obsolete dynamic-printk kernel-parameter
      remove extraneous 'is' from Documentation/iostats.txt
      Fix spelling milisec -> ms in snd_ps3 module parameter description
      Fix spelling mistakes in comments
      Revert conflicting V4L changes
      i7core_edac: fix typos in comments
      mm/rmap.c: fix comment
      sound, ca0106: Fix assignment to 'channel'.
      hrtimer: fix a typo in comment
      init/Kconfig: fix typo
      anon_inodes: fix wrong function name in comment
      fix comment typos concerning "consistent"
      poll: fix a typo in comment
      ...
    
    Fix up trivial conflicts in:
     - drivers/net/wireless/iwlwifi/iwl-core.c (moved to iwl-legacy.c)
     - fs/ext4/ext4.h
    
    Also fix missed 'diabled' typo in drivers/net/bnx2x/bnx2x.h while at it.

commit 4b7bd364700d9ac8372eff48832062b936d0793b
Merge: c0d8768af260 90a8a73c06cc
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Dec 22 18:57:02 2010 +0100

    Merge branch 'master' into for-next
    
    Conflicts:
            MAINTAINERS
            arch/arm/mach-omap2/pm24xx.c
            drivers/scsi/bfa/bfa_fcpim.c
    
    Needed to update to apply fixes for which the old branch was too
    outdated.

commit 596efe4792c50163578578bd4fe470f97652aad7
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 21 21:05:16 2010 -0700

    OMAP3: control/PM: move padconf save code to mach-omap2/control.c
    
    Move the padconf save code from pm34xx.c to the System Control Module
    code in mach-omap2/control.c.  This is part of the general push to
    move direct register access from middle-layer core code to low-level
    core code, so the middle-layer code can be abstracted to work on
    multiple platforms and cleaned up.
    
    In the medium-to-long term, this code should be called by the mux
    layer code, not the PM idle code.  This is because, according to the
    TRM, saving the padconf only needs to be done when the padconf
    changes[1].
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Tested-by: Rajendra Nayak <rnayak@ti.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    
    1. OMAP34xx Multimedia Device Silicon Revision 3.1.x [Rev. ZH] [SWPU222H]
       Section 4.11.4 "Device Off-Mode Sequences"

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 5efd1fb8c640..5b323f28da2d 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -133,16 +133,7 @@ static void omap3_disable_io_chain(void)
 
 static void omap3_core_save_context(void)
 {
-	u32 control_padconf_off;
-
-	/* Save the padconf registers */
-	control_padconf_off = omap_ctrl_readl(OMAP343X_CONTROL_PADCONF_OFF);
-	control_padconf_off |= START_PADCONF_SAVE;
-	omap_ctrl_writel(control_padconf_off, OMAP343X_CONTROL_PADCONF_OFF);
-	/* wait for the save to complete */
-	while (!(omap_ctrl_readl(OMAP343X_CONTROL_GENERAL_PURPOSE_STATUS)
-			& PADCONF_SAVE_DONE))
-		udelay(1);
+	omap3_ctrl_save_padconf();
 
 	/*
 	 * Force write last pad into memory, as this can fail in some

commit 72e06d087204f3bc9acf281717b90ebf0b9731f7
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 21 21:05:16 2010 -0700

    OMAP2+: powerdomain: move header file from plat-omap to mach-omap2
    
    The OMAP powerdomain code and data is all OMAP2+-specific.  This seems
    unlikely to change any time soon.  Move plat-omap/include/plat/powerdomain.h
    to mach-omap2/powerdomain.h.  The primary point of doing this is to remove
    the temptation for unrelated upper-layer code to access powerdomain code
    and data directly.
    
    As part of this process, remove the references to powerdomain data
    from the GPIO "driver" and the OMAP PM no-op layer, both in plat-omap.
    Change the DSPBridge code to point to the new location for the
    powerdomain headers.  The DSPBridge code should not be including the
    powerdomain headers; these should be removed.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Omar Ramirez Luna <omar.ramirez@ti.com>
    Cc: Felipe Contreras <felipe.contreras@gmail.com>
    Cc: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 0fae3d6b76e8..5efd1fb8c640 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -32,7 +32,7 @@
 
 #include <plat/sram.h>
 #include "clockdomain.h"
-#include <plat/powerdomain.h>
+#include "powerdomain.h"
 #include <plat/serial.h>
 #include <plat/sdrc.h>
 #include <plat/prcm.h>
@@ -360,6 +360,7 @@ void omap_sram_idle(void)
 	int mpu_next_state = PWRDM_POWER_ON;
 	int per_next_state = PWRDM_POWER_ON;
 	int core_next_state = PWRDM_POWER_ON;
+	int per_going_off;
 	int core_prev_state, per_prev_state;
 	u32 sdrc_pwr = 0;
 
@@ -411,9 +412,10 @@ void omap_sram_idle(void)
 
 	/* PER */
 	if (per_next_state < PWRDM_POWER_ON) {
+		per_going_off = (per_next_state == PWRDM_POWER_OFF) ? 1 : 0;
 		omap_uart_prepare_idle(2);
 		omap_uart_prepare_idle(3);
-		omap2_gpio_prepare_for_idle(per_next_state);
+		omap2_gpio_prepare_for_idle(per_going_off);
 		if (per_next_state == PWRDM_POWER_OFF)
 				omap3_per_save_context();
 	}

commit 1540f214065982e6cbc6b8da1fe65a15e358f7c5
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 21 21:05:15 2010 -0700

    OMAP2+: clockdomain: move header file from plat-omap to mach-omap2
    
    The OMAP clockdomain code and data is all OMAP2+-specific.  This seems
    unlikely to change any time soon.  Move plat-omap/include/plat/clockdomain.h
    to mach-omap2/clockdomain.h.  The primary point of doing this is to remove
    the temptation for unrelated upper-layer code to access clockdomain code
    and data directly.
    
    DSPBridge also uses the clockdomain headers for some reason, so,
    modify it also. The DSPBridge code should not be including the
    clockdomain headers; these should be removed.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Omar Ramirez Luna <omar.ramirez@ti.com>
    Cc: Felipe Contreras <felipe.contreras@gmail.com>
    Cc: Greg Kroah-Hartman <greg@kroah.com>
    Tested-by: Rajendra Nayak <rnayak@ti.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 1ca6ef4c25b3..0fae3d6b76e8 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -31,7 +31,7 @@
 #include <linux/console.h>
 
 #include <plat/sram.h>
-#include <plat/clockdomain.h>
+#include "clockdomain.h"
 #include <plat/powerdomain.h>
 #include <plat/serial.h>
 #include <plat/sdrc.h>

commit c4d7e58fb52c632d8e33cd23a4917d7a7f8302ac
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 21 21:05:14 2010 -0700

    OMAP2/3: PRM/CM: prefix OMAP2 PRM/CM functions with "omap2_"
    
    Now that OMAP4-specific PRCM functions have been added, distinguish the
    existing OMAP2/3-specific PRCM functions by prefixing them with "omap2_".
    
    This patch should not result in any functional change.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Jarkko Nikula <jhnikula@gmail.com>
    Cc: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Cc: Liam Girdwood <lrg@slimlogic.co.uk>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Rajendra Nayak <rnayak@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index cfff321c747e..1ca6ef4c25b3 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -105,12 +105,12 @@ static void omap3_enable_io_chain(void)
 	int timeout = 0;
 
 	if (omap_rev() >= OMAP3430_REV_ES3_1) {
-		prm_set_mod_reg_bits(OMAP3430_EN_IO_CHAIN_MASK, WKUP_MOD,
+		omap2_prm_set_mod_reg_bits(OMAP3430_EN_IO_CHAIN_MASK, WKUP_MOD,
 				     PM_WKEN);
 		/* Do a readback to assure write has been done */
-		prm_read_mod_reg(WKUP_MOD, PM_WKEN);
+		omap2_prm_read_mod_reg(WKUP_MOD, PM_WKEN);
 
-		while (!(prm_read_mod_reg(WKUP_MOD, PM_WKEN) &
+		while (!(omap2_prm_read_mod_reg(WKUP_MOD, PM_WKEN) &
 			 OMAP3430_ST_IO_CHAIN_MASK)) {
 			timeout++;
 			if (timeout > 1000) {
@@ -118,7 +118,7 @@ static void omap3_enable_io_chain(void)
 				       "activation failed.\n");
 				return;
 			}
-			prm_set_mod_reg_bits(OMAP3430_ST_IO_CHAIN_MASK,
+			omap2_prm_set_mod_reg_bits(OMAP3430_ST_IO_CHAIN_MASK,
 					     WKUP_MOD, PM_WKEN);
 		}
 	}
@@ -127,7 +127,7 @@ static void omap3_enable_io_chain(void)
 static void omap3_disable_io_chain(void)
 {
 	if (omap_rev() >= OMAP3430_REV_ES3_1)
-		prm_clear_mod_reg_bits(OMAP3430_EN_IO_CHAIN_MASK, WKUP_MOD,
+		omap2_prm_clear_mod_reg_bits(OMAP3430_EN_IO_CHAIN_MASK, WKUP_MOD,
 				       PM_WKEN);
 }
 
@@ -221,27 +221,27 @@ static int prcm_clear_mod_irqs(s16 module, u8 regs)
 		OMAP3430ES2_PM_MPUGRPSEL3 : OMAP3430_PM_MPUGRPSEL;
 	int c = 0;
 
-	wkst = prm_read_mod_reg(module, wkst_off);
-	wkst &= prm_read_mod_reg(module, grpsel_off);
+	wkst = omap2_prm_read_mod_reg(module, wkst_off);
+	wkst &= omap2_prm_read_mod_reg(module, grpsel_off);
 	if (wkst) {
-		iclk = cm_read_mod_reg(module, iclk_off);
-		fclk = cm_read_mod_reg(module, fclk_off);
+		iclk = omap2_cm_read_mod_reg(module, iclk_off);
+		fclk = omap2_cm_read_mod_reg(module, fclk_off);
 		while (wkst) {
 			clken = wkst;
-			cm_set_mod_reg_bits(clken, module, iclk_off);
+			omap2_cm_set_mod_reg_bits(clken, module, iclk_off);
 			/*
 			 * For USBHOST, we don't know whether HOST1 or
 			 * HOST2 woke us up, so enable both f-clocks
 			 */
 			if (module == OMAP3430ES2_USBHOST_MOD)
 				clken |= 1 << OMAP3430ES2_EN_USBHOST2_SHIFT;
-			cm_set_mod_reg_bits(clken, module, fclk_off);
-			prm_write_mod_reg(wkst, module, wkst_off);
-			wkst = prm_read_mod_reg(module, wkst_off);
+			omap2_cm_set_mod_reg_bits(clken, module, fclk_off);
+			omap2_prm_write_mod_reg(wkst, module, wkst_off);
+			wkst = omap2_prm_read_mod_reg(module, wkst_off);
 			c++;
 		}
-		cm_write_mod_reg(iclk, module, iclk_off);
-		cm_write_mod_reg(fclk, module, fclk_off);
+		omap2_cm_write_mod_reg(iclk, module, iclk_off);
+		omap2_cm_write_mod_reg(fclk, module, fclk_off);
 	}
 
 	return c;
@@ -284,9 +284,9 @@ static irqreturn_t prcm_interrupt_handler (int irq, void *dev_id)
 	u32 irqenable_mpu, irqstatus_mpu;
 	int c = 0;
 
-	irqenable_mpu = prm_read_mod_reg(OCP_MOD,
+	irqenable_mpu = omap2_prm_read_mod_reg(OCP_MOD,
 					 OMAP3_PRM_IRQENABLE_MPU_OFFSET);
-	irqstatus_mpu = prm_read_mod_reg(OCP_MOD,
+	irqstatus_mpu = omap2_prm_read_mod_reg(OCP_MOD,
 					 OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
 	irqstatus_mpu &= irqenable_mpu;
 
@@ -307,10 +307,10 @@ static irqreturn_t prcm_interrupt_handler (int irq, void *dev_id)
 			     "no code to handle it (%08x)\n", irqstatus_mpu);
 		}
 
-		prm_write_mod_reg(irqstatus_mpu, OCP_MOD,
+		omap2_prm_write_mod_reg(irqstatus_mpu, OCP_MOD,
 					OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
 
-		irqstatus_mpu = prm_read_mod_reg(OCP_MOD,
+		irqstatus_mpu = omap2_prm_read_mod_reg(OCP_MOD,
 					OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
 		irqstatus_mpu &= irqenable_mpu;
 
@@ -398,7 +398,7 @@ void omap_sram_idle(void)
 	if (omap3_has_io_wakeup() &&
 	    (per_next_state < PWRDM_POWER_ON ||
 	     core_next_state < PWRDM_POWER_ON)) {
-		prm_set_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD, PM_WKEN);
+		omap2_prm_set_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD, PM_WKEN);
 		omap3_enable_io_chain();
 	}
 
@@ -471,7 +471,7 @@ void omap_sram_idle(void)
 		omap_uart_resume_idle(0);
 		omap_uart_resume_idle(1);
 		if (core_next_state == PWRDM_POWER_OFF)
-			prm_clear_mod_reg_bits(OMAP3430_AUTO_OFF_MASK,
+			omap2_prm_clear_mod_reg_bits(OMAP3430_AUTO_OFF_MASK,
 					       OMAP3430_GR_MOD,
 					       OMAP3_PRM_VOLTCTRL_OFFSET);
 	}
@@ -495,7 +495,8 @@ void omap_sram_idle(void)
 	if (omap3_has_io_wakeup() &&
 	    (per_next_state < PWRDM_POWER_ON ||
 	     core_next_state < PWRDM_POWER_ON)) {
-		prm_clear_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD, PM_WKEN);
+		omap2_prm_clear_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD,
+					     PM_WKEN);
 		omap3_disable_io_chain();
 	}
 
@@ -633,21 +634,21 @@ static struct platform_suspend_ops omap_pm_ops = {
 static void __init omap3_iva_idle(void)
 {
 	/* ensure IVA2 clock is disabled */
-	cm_write_mod_reg(0, OMAP3430_IVA2_MOD, CM_FCLKEN);
+	omap2_cm_write_mod_reg(0, OMAP3430_IVA2_MOD, CM_FCLKEN);
 
 	/* if no clock activity, nothing else to do */
-	if (!(cm_read_mod_reg(OMAP3430_IVA2_MOD, OMAP3430_CM_CLKSTST) &
+	if (!(omap2_cm_read_mod_reg(OMAP3430_IVA2_MOD, OMAP3430_CM_CLKSTST) &
 	      OMAP3430_CLKACTIVITY_IVA2_MASK))
 		return;
 
 	/* Reset IVA2 */
-	prm_write_mod_reg(OMAP3430_RST1_IVA2_MASK |
+	omap2_prm_write_mod_reg(OMAP3430_RST1_IVA2_MASK |
 			  OMAP3430_RST2_IVA2_MASK |
 			  OMAP3430_RST3_IVA2_MASK,
 			  OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);
 
 	/* Enable IVA2 clock */
-	cm_write_mod_reg(OMAP3430_CM_FCLKEN_IVA2_EN_IVA2_MASK,
+	omap2_cm_write_mod_reg(OMAP3430_CM_FCLKEN_IVA2_EN_IVA2_MASK,
 			 OMAP3430_IVA2_MOD, CM_FCLKEN);
 
 	/* Set IVA2 boot mode to 'idle' */
@@ -655,13 +656,13 @@ static void __init omap3_iva_idle(void)
 			 OMAP343X_CONTROL_IVA2_BOOTMOD);
 
 	/* Un-reset IVA2 */
-	prm_write_mod_reg(0, OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);
+	omap2_prm_write_mod_reg(0, OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);
 
 	/* Disable IVA2 clock */
-	cm_write_mod_reg(0, OMAP3430_IVA2_MOD, CM_FCLKEN);
+	omap2_cm_write_mod_reg(0, OMAP3430_IVA2_MOD, CM_FCLKEN);
 
 	/* Reset IVA2 */
-	prm_write_mod_reg(OMAP3430_RST1_IVA2_MASK |
+	omap2_prm_write_mod_reg(OMAP3430_RST1_IVA2_MASK |
 			  OMAP3430_RST2_IVA2_MASK |
 			  OMAP3430_RST3_IVA2_MASK,
 			  OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);
@@ -685,10 +686,10 @@ static void __init omap3_d2d_idle(void)
 	omap_ctrl_writew(padconf, OMAP3_PADCONF_SAD2D_IDLEACK);
 
 	/* reset modem */
-	prm_write_mod_reg(OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RSTPWRON_MASK |
+	omap2_prm_write_mod_reg(OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RSTPWRON_MASK |
 			  OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RST_MASK,
 			  CORE_MOD, OMAP2_RM_RSTCTRL);
-	prm_write_mod_reg(0, CORE_MOD, OMAP2_RM_RSTCTRL);
+	omap2_prm_write_mod_reg(0, CORE_MOD, OMAP2_RM_RSTCTRL);
 }
 
 static void __init prcm_setup_regs(void)
@@ -703,23 +704,23 @@ static void __init prcm_setup_regs(void)
 
 	/* XXX Reset all wkdeps. This should be done when initializing
 	 * powerdomains */
-	prm_write_mod_reg(0, OMAP3430_IVA2_MOD, PM_WKDEP);
-	prm_write_mod_reg(0, MPU_MOD, PM_WKDEP);
-	prm_write_mod_reg(0, OMAP3430_DSS_MOD, PM_WKDEP);
-	prm_write_mod_reg(0, OMAP3430_NEON_MOD, PM_WKDEP);
-	prm_write_mod_reg(0, OMAP3430_CAM_MOD, PM_WKDEP);
-	prm_write_mod_reg(0, OMAP3430_PER_MOD, PM_WKDEP);
+	omap2_prm_write_mod_reg(0, OMAP3430_IVA2_MOD, PM_WKDEP);
+	omap2_prm_write_mod_reg(0, MPU_MOD, PM_WKDEP);
+	omap2_prm_write_mod_reg(0, OMAP3430_DSS_MOD, PM_WKDEP);
+	omap2_prm_write_mod_reg(0, OMAP3430_NEON_MOD, PM_WKDEP);
+	omap2_prm_write_mod_reg(0, OMAP3430_CAM_MOD, PM_WKDEP);
+	omap2_prm_write_mod_reg(0, OMAP3430_PER_MOD, PM_WKDEP);
 	if (omap_rev() > OMAP3430_REV_ES1_0) {
-		prm_write_mod_reg(0, OMAP3430ES2_SGX_MOD, PM_WKDEP);
-		prm_write_mod_reg(0, OMAP3430ES2_USBHOST_MOD, PM_WKDEP);
+		omap2_prm_write_mod_reg(0, OMAP3430ES2_SGX_MOD, PM_WKDEP);
+		omap2_prm_write_mod_reg(0, OMAP3430ES2_USBHOST_MOD, PM_WKDEP);
 	} else
-		prm_write_mod_reg(0, GFX_MOD, PM_WKDEP);
+		omap2_prm_write_mod_reg(0, GFX_MOD, PM_WKDEP);
 
 	/*
 	 * Enable interface clock autoidle for all modules.
 	 * Note that in the long run this should be done by clockfw
 	 */
-	cm_write_mod_reg(
+	omap2_cm_write_mod_reg(
 		OMAP3430_AUTO_MODEM_MASK |
 		OMAP3430ES2_AUTO_MMC3_MASK |
 		OMAP3430ES2_AUTO_ICR_MASK |
@@ -752,7 +753,7 @@ static void __init prcm_setup_regs(void)
 		OMAP3430_AUTO_SSI_MASK,
 		CORE_MOD, CM_AUTOIDLE1);
 
-	cm_write_mod_reg(
+	omap2_cm_write_mod_reg(
 		OMAP3430_AUTO_PKA_MASK |
 		OMAP3430_AUTO_AES1_MASK |
 		OMAP3430_AUTO_RNG_MASK |
@@ -761,13 +762,13 @@ static void __init prcm_setup_regs(void)
 		CORE_MOD, CM_AUTOIDLE2);
 
 	if (omap_rev() > OMAP3430_REV_ES1_0) {
-		cm_write_mod_reg(
+		omap2_cm_write_mod_reg(
 			OMAP3430_AUTO_MAD2D_MASK |
 			OMAP3430ES2_AUTO_USBTLL_MASK,
 			CORE_MOD, CM_AUTOIDLE3);
 	}
 
-	cm_write_mod_reg(
+	omap2_cm_write_mod_reg(
 		OMAP3430_AUTO_WDT2_MASK |
 		OMAP3430_AUTO_WDT1_MASK |
 		OMAP3430_AUTO_GPIO1_MASK |
@@ -776,17 +777,17 @@ static void __init prcm_setup_regs(void)
 		OMAP3430_AUTO_GPT1_MASK,
 		WKUP_MOD, CM_AUTOIDLE);
 
-	cm_write_mod_reg(
+	omap2_cm_write_mod_reg(
 		OMAP3430_AUTO_DSS_MASK,
 		OMAP3430_DSS_MOD,
 		CM_AUTOIDLE);
 
-	cm_write_mod_reg(
+	omap2_cm_write_mod_reg(
 		OMAP3430_AUTO_CAM_MASK,
 		OMAP3430_CAM_MOD,
 		CM_AUTOIDLE);
 
-	cm_write_mod_reg(
+	omap2_cm_write_mod_reg(
 		omap3630_auto_uart4_mask |
 		OMAP3430_AUTO_GPIO6_MASK |
 		OMAP3430_AUTO_GPIO5_MASK |
@@ -810,7 +811,7 @@ static void __init prcm_setup_regs(void)
 		CM_AUTOIDLE);
 
 	if (omap_rev() > OMAP3430_REV_ES1_0) {
-		cm_write_mod_reg(
+		omap2_cm_write_mod_reg(
 			OMAP3430ES2_AUTO_USBHOST_MASK,
 			OMAP3430ES2_USBHOST_MOD,
 			CM_AUTOIDLE);
@@ -822,16 +823,16 @@ static void __init prcm_setup_regs(void)
 	 * Set all plls to autoidle. This is needed until autoidle is
 	 * enabled by clockfw
 	 */
-	cm_write_mod_reg(1 << OMAP3430_AUTO_IVA2_DPLL_SHIFT,
+	omap2_cm_write_mod_reg(1 << OMAP3430_AUTO_IVA2_DPLL_SHIFT,
 			 OMAP3430_IVA2_MOD, CM_AUTOIDLE2);
-	cm_write_mod_reg(1 << OMAP3430_AUTO_MPU_DPLL_SHIFT,
+	omap2_cm_write_mod_reg(1 << OMAP3430_AUTO_MPU_DPLL_SHIFT,
 			 MPU_MOD,
 			 CM_AUTOIDLE2);
-	cm_write_mod_reg((1 << OMAP3430_AUTO_PERIPH_DPLL_SHIFT) |
+	omap2_cm_write_mod_reg((1 << OMAP3430_AUTO_PERIPH_DPLL_SHIFT) |
 			 (1 << OMAP3430_AUTO_CORE_DPLL_SHIFT),
 			 PLL_MOD,
 			 CM_AUTOIDLE);
-	cm_write_mod_reg(1 << OMAP3430ES2_AUTO_PERIPH2_DPLL_SHIFT,
+	omap2_cm_write_mod_reg(1 << OMAP3430ES2_AUTO_PERIPH2_DPLL_SHIFT,
 			 PLL_MOD,
 			 CM_AUTOIDLE2);
 
@@ -840,31 +841,31 @@ static void __init prcm_setup_regs(void)
 	 * sys_clkreq. In the long run clock framework should
 	 * take care of this.
 	 */
-	prm_rmw_mod_reg_bits(OMAP_AUTOEXTCLKMODE_MASK,
+	omap2_prm_rmw_mod_reg_bits(OMAP_AUTOEXTCLKMODE_MASK,
 			     1 << OMAP_AUTOEXTCLKMODE_SHIFT,
 			     OMAP3430_GR_MOD,
 			     OMAP3_PRM_CLKSRC_CTRL_OFFSET);
 
 	/* setup wakup source */
-	prm_write_mod_reg(OMAP3430_EN_IO_MASK | OMAP3430_EN_GPIO1_MASK |
+	omap2_prm_write_mod_reg(OMAP3430_EN_IO_MASK | OMAP3430_EN_GPIO1_MASK |
 			  OMAP3430_EN_GPT1_MASK | OMAP3430_EN_GPT12_MASK,
 			  WKUP_MOD, PM_WKEN);
 	/* No need to write EN_IO, that is always enabled */
-	prm_write_mod_reg(OMAP3430_GRPSEL_GPIO1_MASK |
+	omap2_prm_write_mod_reg(OMAP3430_GRPSEL_GPIO1_MASK |
 			  OMAP3430_GRPSEL_GPT1_MASK |
 			  OMAP3430_GRPSEL_GPT12_MASK,
 			  WKUP_MOD, OMAP3430_PM_MPUGRPSEL);
 	/* For some reason IO doesn't generate wakeup event even if
 	 * it is selected to mpu wakeup goup */
-	prm_write_mod_reg(OMAP3430_IO_EN_MASK | OMAP3430_WKUP_EN_MASK,
+	omap2_prm_write_mod_reg(OMAP3430_IO_EN_MASK | OMAP3430_WKUP_EN_MASK,
 			  OCP_MOD, OMAP3_PRM_IRQENABLE_MPU_OFFSET);
 
 	/* Enable PM_WKEN to support DSS LPR */
-	prm_write_mod_reg(OMAP3430_PM_WKEN_DSS_EN_DSS_MASK,
+	omap2_prm_write_mod_reg(OMAP3430_PM_WKEN_DSS_EN_DSS_MASK,
 				OMAP3430_DSS_MOD, PM_WKEN);
 
 	/* Enable wakeups in PER */
-	prm_write_mod_reg(omap3630_en_uart4_mask |
+	omap2_prm_write_mod_reg(omap3630_en_uart4_mask |
 			  OMAP3430_EN_GPIO2_MASK | OMAP3430_EN_GPIO3_MASK |
 			  OMAP3430_EN_GPIO4_MASK | OMAP3430_EN_GPIO5_MASK |
 			  OMAP3430_EN_GPIO6_MASK | OMAP3430_EN_UART3_MASK |
@@ -872,7 +873,7 @@ static void __init prcm_setup_regs(void)
 			  OMAP3430_EN_MCBSP4_MASK,
 			  OMAP3430_PER_MOD, PM_WKEN);
 	/* and allow them to wake up MPU */
-	prm_write_mod_reg(omap3630_grpsel_uart4_mask |
+	omap2_prm_write_mod_reg(omap3630_grpsel_uart4_mask |
 			  OMAP3430_GRPSEL_GPIO2_MASK |
 			  OMAP3430_GRPSEL_GPIO3_MASK |
 			  OMAP3430_GRPSEL_GPIO4_MASK |
@@ -885,22 +886,22 @@ static void __init prcm_setup_regs(void)
 			  OMAP3430_PER_MOD, OMAP3430_PM_MPUGRPSEL);
 
 	/* Don't attach IVA interrupts */
-	prm_write_mod_reg(0, WKUP_MOD, OMAP3430_PM_IVAGRPSEL);
-	prm_write_mod_reg(0, CORE_MOD, OMAP3430_PM_IVAGRPSEL1);
-	prm_write_mod_reg(0, CORE_MOD, OMAP3430ES2_PM_IVAGRPSEL3);
-	prm_write_mod_reg(0, OMAP3430_PER_MOD, OMAP3430_PM_IVAGRPSEL);
+	omap2_prm_write_mod_reg(0, WKUP_MOD, OMAP3430_PM_IVAGRPSEL);
+	omap2_prm_write_mod_reg(0, CORE_MOD, OMAP3430_PM_IVAGRPSEL1);
+	omap2_prm_write_mod_reg(0, CORE_MOD, OMAP3430ES2_PM_IVAGRPSEL3);
+	omap2_prm_write_mod_reg(0, OMAP3430_PER_MOD, OMAP3430_PM_IVAGRPSEL);
 
 	/* Clear any pending 'reset' flags */
-	prm_write_mod_reg(0xffffffff, MPU_MOD, OMAP2_RM_RSTST);
-	prm_write_mod_reg(0xffffffff, CORE_MOD, OMAP2_RM_RSTST);
-	prm_write_mod_reg(0xffffffff, OMAP3430_PER_MOD, OMAP2_RM_RSTST);
-	prm_write_mod_reg(0xffffffff, OMAP3430_EMU_MOD, OMAP2_RM_RSTST);
-	prm_write_mod_reg(0xffffffff, OMAP3430_NEON_MOD, OMAP2_RM_RSTST);
-	prm_write_mod_reg(0xffffffff, OMAP3430_DSS_MOD, OMAP2_RM_RSTST);
-	prm_write_mod_reg(0xffffffff, OMAP3430ES2_USBHOST_MOD, OMAP2_RM_RSTST);
+	omap2_prm_write_mod_reg(0xffffffff, MPU_MOD, OMAP2_RM_RSTST);
+	omap2_prm_write_mod_reg(0xffffffff, CORE_MOD, OMAP2_RM_RSTST);
+	omap2_prm_write_mod_reg(0xffffffff, OMAP3430_PER_MOD, OMAP2_RM_RSTST);
+	omap2_prm_write_mod_reg(0xffffffff, OMAP3430_EMU_MOD, OMAP2_RM_RSTST);
+	omap2_prm_write_mod_reg(0xffffffff, OMAP3430_NEON_MOD, OMAP2_RM_RSTST);
+	omap2_prm_write_mod_reg(0xffffffff, OMAP3430_DSS_MOD, OMAP2_RM_RSTST);
+	omap2_prm_write_mod_reg(0xffffffff, OMAP3430ES2_USBHOST_MOD, OMAP2_RM_RSTST);
 
 	/* Clear any pending PRCM interrupts */
-	prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
+	omap2_prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
 
 	omap3_iva_idle();
 	omap3_d2d_idle();

commit f0611a5c220e50dec65041b10bd2fe9484f061a6
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 21 15:30:56 2010 -0700

    OMAP3: PRM/CM: separate CM context save/restore; remove PRM context save/restore
    
    The OMAP3 PRM module is in the WKUP powerdomain, which is always
    powered when the chip is powered, so it shouldn't be necessary to save
    and restore those PRM registers.  Remove the PRM register save/restore
    code, which should save several microseconds during off-mode
    entry/exit, since PRM register accesses are relatively slow.
    
    While doing so, move the CM register save/restore code into
    CM-specific code.  The CM module has been distinct from the PRM module
    since 2430.
    
    This patch includes some minor changes to pm34xx.c.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Cc: Tero Kristo <tero.kristo@nokia.com>
    Cc: Kalle Jokiniemi <kalle.jokiniemi@digia.com>
    Reviewed-by: Kevin Hilman <khilman@deeprootsystems.com>
    Tested-by: Kevin Hilman <khilman@deeprootsystems.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Rajendra Nayak <rnayak@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 7e500d892804..cfff321c747e 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -424,7 +424,7 @@ void omap_sram_idle(void)
 		omap_uart_prepare_idle(1);
 		if (core_next_state == PWRDM_POWER_OFF) {
 			omap3_core_save_context();
-			omap3_prcm_save_context();
+			omap3_cm_save_context();
 		}
 	}
 
@@ -464,7 +464,7 @@ void omap_sram_idle(void)
 		core_prev_state = pwrdm_read_prev_pwrst(core_pwrdm);
 		if (core_prev_state == PWRDM_POWER_OFF) {
 			omap3_core_restore_context();
-			omap3_prcm_restore_context();
+			omap3_cm_restore_context();
 			omap3_sram_restore_context();
 			omap2_sms_restore_context();
 		}

commit 59fb659b065f52fcc2deed293cfbfc58f890376c
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Dec 21 15:30:55 2010 -0700

    OMAP2/3: PRCM: split OMAP2/3-specific PRCM code into OMAP2/3-specific files
    
    In preparation for adding OMAP4-specific PRCM accessor/mutator
    functions, split the existing OMAP2/3 PRCM code into OMAP2/3-specific
    files.  Most of what was in mach-omap2/{cm,prm}.{c,h} has now been
    moved into mach-omap2/{cm,prm}2xxx_3xxx.{c,h}, since it was
    OMAP2xxx/3xxx-specific.
    
    This process also requires the #includes in each of these files to be
    changed to reference the new file name.  As part of doing so, add some
    comments into plat-omap/sram.c and plat-omap/mcbsp.c, which use
    "sideways includes", to indicate that these users of the PRM/CM includes
    should not be doing so.
    
    Thanks to Felipe Contreras <felipe.contreras@gmail.com> for comments on this
    patch.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Jarkko Nikula <jhnikula@gmail.com>
    Cc: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Cc: Liam Girdwood <lrg@slimlogic.co.uk>
    Cc: Omar Ramirez Luna <omar.ramirez@ti.com>
    Acked-by: Omar Ramirez Luna <omar.ramirez@ti.com>
    Cc: Felipe Contreras <felipe.contreras@gmail.com>
    Acked-by: Felipe Contreras <felipe.contreras@gmail.com>
    Cc: Greg Kroah-Hartman <greg@kroah.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Kevin Hilman <khilman@deeprootsystems.com>
    Tested-by: Kevin Hilman <khilman@deeprootsystems.com>
    Tested-by: Rajendra Nayak <rnayak@ti.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index c45b4fa1deeb..7e500d892804 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -41,11 +41,11 @@
 
 #include <asm/tlbflush.h>
 
-#include "cm.h"
+#include "cm2xxx_3xxx.h"
 #include "cm-regbits-34xx.h"
 #include "prm-regbits-34xx.h"
 
-#include "prm.h"
+#include "prm2xxx_3xxx.h"
 #include "pm.h"
 #include "sdrc.h"
 #include "control.h"

commit 8352129166b8270253a746f336a4429b349b023d
Author: Jean Pihet <j-pihet@ti.com>
Date:   Sat Dec 18 16:44:46 2010 +0100

    OMAP3: add comments for low power code errata
    
    Errata covered:
    - 1.157 & 1.185
    - i443
    - i581
    
    Tested on N900 and Beagleboard with full RET and OFF modes,
    using cpuidle and suspend.
    
    Signed-off-by: Jean Pihet <j-pihet@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index a81ed251e667..c45b4fa1deeb 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -146,7 +146,7 @@ static void omap3_core_save_context(void)
 
 	/*
 	 * Force write last pad into memory, as this can fail in some
-	 * cases according to erratas 1.157, 1.185
+	 * cases according to errata 1.157, 1.185
 	 */
 	omap_ctrl_writel(omap_ctrl_readl(OMAP343X_PADCONF_ETK_D14),
 		OMAP343X_CONTROL_MEM_WKUP + 0x2a0);
@@ -433,7 +433,7 @@ void omap_sram_idle(void)
 	/*
 	* On EMU/HS devices ROM code restores a SRDC value
 	* from scratchpad which has automatic self refresh on timeout
-	* of AUTO_CNT = 1 enabled. This takes care of errata 1.142.
+	* of AUTO_CNT = 1 enabled. This takes care of erratum ID i443.
 	* Hence store/restore the SDRC_POWER register here.
 	*/
 	if (omap_rev() >= OMAP3430_REV_ES3_0 &&

commit cc1b6028878646a2419b27e5f590b5e9fe01dc3d
Author: Eduardo Valentin <eduardo.valentin@nokia.com>
Date:   Mon Dec 20 14:05:09 2010 -0600

    OMAP3630: PM: Erratum i583: disable coreoff if < ES1.2
    
    Limitation i583: Self_Refresh Exit issue after OFF mode
    
    Issue:
    When device is waking up from OFF mode, then SDRC state machine sends
    inappropriate sequence violating JEDEC standards.
    
    Impact:
    OMAP3630 < ES1.2 is impacted as follows depending on the platform:
    CS0: for 38.4MHz as internal sysclk, DDR content seen to be stable, while
            for all other sysclk frequencies, varied levels of instability
            seen based on varied parameters.
    CS1: impacted
    
    This patch takes option #3 as recommended by the Silicon erratum:
    Avoid core power domain transitioning to OFF mode. Power consumption
    impact is expected in this case.
    To do this, we route core OFF requests to RET request on the impacted
    revisions of silicon.
    
    Acked-by: Jean Pihet <j-pihet@ti.com>
    
    [nm@ti.com: rebased the code to 2.6.37-rc2- short circuit code changed a bit]
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Eduardo Valentin <eduardo.valentin@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 74bc15e71e9f..a81ed251e667 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -917,12 +917,29 @@ void omap3_pm_off_mode_enable(int enable)
 		state = PWRDM_POWER_RET;
 
 #ifdef CONFIG_CPU_IDLE
-	omap3_cpuidle_update_states(state, state);
+	/*
+	 * Erratum i583: implementation for ES rev < Es1.2 on 3630. We cannot
+	 * enable OFF mode in a stable form for previous revisions, restrict
+	 * instead to RET
+	 */
+	if (IS_PM34XX_ERRATUM(PM_SDRC_WAKEUP_ERRATUM_i583))
+		omap3_cpuidle_update_states(state, PWRDM_POWER_RET);
+	else
+		omap3_cpuidle_update_states(state, state);
 #endif
 
 	list_for_each_entry(pwrst, &pwrst_list, node) {
-		pwrst->next_state = state;
-		omap_set_pwrdm_state(pwrst->pwrdm, state);
+		if (IS_PM34XX_ERRATUM(PM_SDRC_WAKEUP_ERRATUM_i583) &&
+				pwrst->pwrdm == core_pwrdm &&
+				state == PWRDM_POWER_OFF) {
+			pwrst->next_state = PWRDM_POWER_RET;
+			WARN_ONCE(1,
+				"%s: Core OFF disabled due to errata i583\n",
+				__func__);
+		} else {
+			pwrst->next_state = state;
+		}
+		omap_set_pwrdm_state(pwrst->pwrdm, pwrst->next_state);
 	}
 }
 
@@ -1000,6 +1017,8 @@ static void __init pm_errata_configure(void)
 		pm34xx_errata |= PM_RTA_ERRATUM_i608;
 		/* Enable the l2 cache toggling in sleep logic */
 		enable_omap3630_toggle_l2_on_restore();
+		if (omap_rev() < OMAP3630_REV_ES1_2)
+			pm34xx_errata |= PM_SDRC_WAKEUP_ERRATUM_i583;
 	}
 }
 

commit 80723c3fe457a5d29c178da4ac72983f47b37ed7
Author: Nishanth Menon <nm@ti.com>
Date:   Mon Dec 20 14:05:08 2010 -0600

    OMAP3: PM: make omap3_cpuidle_update_states independent of enable_off_mode
    
    Currently omap3_cpuidle_update_states makes whole sale decision
    on which C states to update based on enable_off_mode variable
    Instead, achieve the same functionality by independently providing
    mpu and core deepest states the system is allowed to achieve and
    update the idle states accordingly.
    
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    [khilman: fixed additional user of this API in OMAP CPUidle driver]
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 96e309d44e14..74bc15e71e9f 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -917,7 +917,7 @@ void omap3_pm_off_mode_enable(int enable)
 		state = PWRDM_POWER_RET;
 
 #ifdef CONFIG_CPU_IDLE
-	omap3_cpuidle_update_states();
+	omap3_cpuidle_update_states(state, state);
 #endif
 
 	list_for_each_entry(pwrst, &pwrst_list, node) {

commit c4236d2e7913d18d058a018f0d19473eb6a11a3c
Author: Peter 'p2' De Schrijver <peter.de-schrijver@nokia.com>
Date:   Mon Dec 20 14:05:07 2010 -0600

    OMAP3630: PM: Disable L2 cache while invalidating L2 cache
    
    While coming out of MPU OSWR/OFF states, L2 controller is reseted.
    The reset behavior is implementation specific as per ARMv7 TRM and
    hence $L2 needs to be invalidated before it's use. Since the
    AUXCTRL register is also reconfigured, disable L2 cache before
    invalidating it and re-enables it afterwards. This is as per
    Cortex-A8 ARM documentation.
    Currently this is identified as being needed on OMAP3630 as the
    disable/enable is done from "public side" while, on OMAP3430, this
    is done in the "secure side".
    
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Tony Lindgren <tony@atomide.com>
    
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    
    [nm@ti.com: ported to 2.6.37-rc2, added hooks to enable the logic only on 3630]
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Eduardo Valentin <eduardo.valentin@nokia.com>
    Signed-off-by: Peter 'p2' De Schrijver <peter.de-schrijver@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 7dbc00005464..96e309d44e14 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -996,8 +996,11 @@ void omap_push_sram_idle(void)
 
 static void __init pm_errata_configure(void)
 {
-	if (cpu_is_omap3630())
+	if (cpu_is_omap3630()) {
 		pm34xx_errata |= PM_RTA_ERRATUM_i608;
+		/* Enable the l2 cache toggling in sleep logic */
+		enable_omap3630_toggle_l2_on_restore();
+	}
 }
 
 static int __init omap3_pm_init(void)

commit 458e999eb14a301d4176783c8fcb277f5d009b4e
Author: Nishanth Menon <nm@ti.com>
Date:   Mon Dec 20 14:05:06 2010 -0600

    OMAP3630: PM: Erratum i608: disable RTA
    
    Erratum id: i608
    RTA (Retention Till Access) feature is not supported and leads to device
    stability issues when enabled. This impacts modules with embedded memories
    on OMAP3630
    
    Workaround is to disable RTA on boot and coming out of core off.
    For disabling RTA coming out of off mode, we do this by overriding the
    restore pointer for 3630 as the first point of entry before caches are
    touched and is common for GP and HS devices. To disable earlier than
    this could be possible by modifying the PPA for HS devices, but not for
    GP devices.
    
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Tony Lindgren <tony@atomide.com>
    
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    
    [ambresh@ti.com: co-developer]
    Signed-off-by: Ambresh K <ambresh@ti.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 288bee32e2b2..7dbc00005464 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -996,6 +996,8 @@ void omap_push_sram_idle(void)
 
 static void __init pm_errata_configure(void)
 {
+	if (cpu_is_omap3630())
+		pm34xx_errata |= PM_RTA_ERRATUM_i608;
 }
 
 static int __init omap3_pm_init(void)
@@ -1056,6 +1058,14 @@ static int __init omap3_pm_init(void)
 	pm_idle = omap3_pm_idle;
 	omap3_idle_init();
 
+	/*
+	 * RTA is disabled during initialization as per erratum i608
+	 * it is safer to disable RTA by the bootloader, but we would like
+	 * to be doubly sure here and prevent any mishaps.
+	 */
+	if (IS_PM34XX_ERRATUM(PM_RTA_ERRATUM_i608))
+		omap3630_ctrl_disable_rta();
+
 	clkdm_add_wkdep(neon_clkdm, mpu_clkdm);
 	if (omap_type() != OMAP2_DEVICE_TYPE_GP) {
 		omap3_secure_ram_storage =

commit 8cdfd83473d9b408b924b5d32777ac3fddd251ff
Author: Nishanth Menon <nm@ti.com>
Date:   Mon Dec 20 14:05:05 2010 -0600

    OMAP3: pm: introduce errata handling
    
    Introduce errata handling for OMAP3. This patch introduces
    errata variable and stub for initialization which will be
    filled up by follow-on patches.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 5bf344a3fcf5..288bee32e2b2 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -68,6 +68,9 @@ static inline bool is_suspending(void)
 #define OMAP343X_TABLE_VALUE_OFFSET	   0xc0
 #define OMAP343X_CONTROL_REG_VALUE_OFFSET  0xc8
 
+/* pm34xx errata defined in pm.h */
+u16 pm34xx_errata;
+
 struct power_state {
 	struct powerdomain *pwrdm;
 	u32 next_state;
@@ -991,6 +994,10 @@ void omap_push_sram_idle(void)
 				save_secure_ram_context_sz);
 }
 
+static void __init pm_errata_configure(void)
+{
+}
+
 static int __init omap3_pm_init(void)
 {
 	struct power_state *pwrst, *tmp;
@@ -1000,6 +1007,8 @@ static int __init omap3_pm_init(void)
 	if (!cpu_is_omap34xx())
 		return -ENODEV;
 
+	pm_errata_configure();
+
 	printk(KERN_ERR "Power Management for TI OMAP3.\n");
 
 	/* XXX prcm_setup_regs needs to be before enabling hw

commit c166381d4013fd32512f124c237f4213ae9888e9
Author: Jean Pihet <j-pihet@ti.com>
Date:   Thu Dec 9 18:39:58 2010 +0100

    OMAP2+: disable idle early in the suspend sequence
    
    Some bad interaction between the idle and the suspend paths has been
    identified: the idle code is called during the suspend enter and exit
    sequences. This could cause corruption or lock-up of resources.
    
    The solution is to move the calls to disable_hlt at the very beginning
    of the suspend sequence (ex. in omap3_pm_begin instead of
    omap3_pm_prepare), and the call to enable_hlt at the very end of
    the suspend sequence (ex. in omap3_pm_end instead of omap3_pm_finish).
    
    Tested with RET and OFF on Beagle and OMAP3EVM.
    
    Signed-off-by: Jean Pihet <j-pihet@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 648b8c50d024..5bf344a3fcf5 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -529,12 +529,6 @@ static void omap3_pm_idle(void)
 }
 
 #ifdef CONFIG_SUSPEND
-static int omap3_pm_prepare(void)
-{
-	disable_hlt();
-	return 0;
-}
-
 static int omap3_pm_suspend(void)
 {
 	struct power_state *pwrst;
@@ -597,14 +591,10 @@ static int omap3_pm_enter(suspend_state_t unused)
 	return ret;
 }
 
-static void omap3_pm_finish(void)
-{
-	enable_hlt();
-}
-
 /* Hooks to enable / disable UART interrupts during suspend */
 static int omap3_pm_begin(suspend_state_t state)
 {
+	disable_hlt();
 	suspend_state = state;
 	omap_uart_enable_irqs(0);
 	return 0;
@@ -614,15 +604,14 @@ static void omap3_pm_end(void)
 {
 	suspend_state = PM_SUSPEND_ON;
 	omap_uart_enable_irqs(1);
+	enable_hlt();
 	return;
 }
 
 static struct platform_suspend_ops omap_pm_ops = {
 	.begin		= omap3_pm_begin,
 	.end		= omap3_pm_end,
-	.prepare	= omap3_pm_prepare,
 	.enter		= omap3_pm_enter,
-	.finish		= omap3_pm_finish,
 	.valid		= suspend_valid_only_mem,
 };
 #endif /* CONFIG_SUSPEND */

commit e83df17f178360a8e7874441bca04a710c869e42
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Wed Dec 8 22:40:40 2010 +0000

    OMAP2+: PM/serial: fix console semaphore acquire during suspend
    
    commit 0d8e2d0dad98a693bad88aea6876ac8b94ad95c6 (OMAP2+: PM/serial:
    hold console semaphore while OMAP UARTs are disabled) added use of the
    console semaphore to protect UARTs from being accessed after disabled
    during idle, but this causes problems in suspend.
    
    During suspend, the console semaphore is acquired by the console
    suspend method (console_suspend()) so the try_acquire_console_sem()
    will always fail and suspend will be aborted.
    
    To fix, introduce a check so the console semaphore is only attempted
    during idle, and not during suspend.  Also use the same check so that
    the console semaphore is not prematurely released during resume.
    
    Thanks to Paul Walmsley for suggesting adding the same check during
    resume.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Tested-by: Jean Pihet <j-pihet@ti.com>
    Tested-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 0ec8a04b7473..648b8c50d024 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -50,6 +50,19 @@
 #include "sdrc.h"
 #include "control.h"
 
+#ifdef CONFIG_SUSPEND
+static suspend_state_t suspend_state = PM_SUSPEND_ON;
+static inline bool is_suspending(void)
+{
+	return (suspend_state != PM_SUSPEND_ON);
+}
+#else
+static inline bool is_suspending(void)
+{
+	return false;
+}
+#endif
+
 /* Scratchpad offsets */
 #define OMAP343X_TABLE_ADDRESS_OFFSET	   0xc4
 #define OMAP343X_TABLE_VALUE_OFFSET	   0xc0
@@ -387,10 +400,11 @@ void omap_sram_idle(void)
 	}
 
 	/* Block console output in case it is on one of the OMAP UARTs */
-	if (per_next_state < PWRDM_POWER_ON ||
-	    core_next_state < PWRDM_POWER_ON)
-		if (try_acquire_console_sem())
-			goto console_still_active;
+	if (!is_suspending())
+		if (per_next_state < PWRDM_POWER_ON ||
+		    core_next_state < PWRDM_POWER_ON)
+			if (try_acquire_console_sem())
+				goto console_still_active;
 
 	/* PER */
 	if (per_next_state < PWRDM_POWER_ON) {
@@ -470,7 +484,8 @@ void omap_sram_idle(void)
 		omap_uart_resume_idle(3);
 	}
 
-	release_console_sem();
+	if (!is_suspending())
+		release_console_sem();
 
 console_still_active:
 	/* Disable IO-PAD and IO-CHAIN wakeup */
@@ -514,8 +529,6 @@ static void omap3_pm_idle(void)
 }
 
 #ifdef CONFIG_SUSPEND
-static suspend_state_t suspend_state;
-
 static int omap3_pm_prepare(void)
 {
 	disable_hlt();

commit 0d8e2d0dad98a693bad88aea6876ac8b94ad95c6
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Nov 24 16:49:05 2010 -0700

    OMAP2+: PM/serial: hold console semaphore while OMAP UARTs are disabled
    
    The console semaphore must be held while the OMAP UART devices are
    disabled, lest a console write cause an ARM abort (and a kernel crash)
    when the underlying console device is inaccessible.  These crashes
    only occur when the console is on one of the OMAP internal serial
    ports.
    
    While this problem has been latent in the PM idle loop for some time,
    the crash was not triggerable with an unmodified kernel until commit
    6f251e9db1093c187addc309b5f2f7fe3efd2995 ("OMAP: UART: omap_device
    conversions, remove implicit 8520 assumptions").  After this patch, a
    console write often occurs after the console UART has been disabled in
    the idle loop, crashing the system.  Several users have encountered
    this bug:
    
        http://www.mail-archive.com/linux-omap@vger.kernel.org/msg38396.html
    
        http://www.mail-archive.com/linux-omap@vger.kernel.org/msg36602.html
    
    The same commit also introduced new code that disabled the UARTs
    during init, in omap_serial_init_port().  The kernel will also crash
    in this code when earlyconsole and extra debugging is enabled:
    
        http://www.mail-archive.com/linux-omap@vger.kernel.org/msg36411.html
    
    The minimal fix for the -rc series is to hold the console semaphore
    while the OMAP UARTs are disabled.  This is a somewhat overbroad fix,
    since the console may not be located on an OMAP UART, as is the case
    with the GPMC UART on Zoom3.  While it is technically possible to
    determine which devices the console or earlyconsole is actually
    running on, it is not a trivial problem to solve, and the code to do
    so is not really appropriate for the -rc series.
    
    The right long-term fix is to ensure that no code outside of the OMAP
    serial driver can disable an OMAP UART.  As I understand it, code to
    implement this is under development by TI.
    
    This patch is a collaboration between Paul Walmsley <paul@pwsan.com>
    and Tony Lindgren <tony@atomide.com>.  Thanks to Ming Lei
    <tom.leiming@gmail.com> and Pramod <pramod.gurav@ti.com> for their
    feedback on earlier versions of this patch.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Ming Lei <tom.leiming@gmail.com>
    Cc: Pramod <pramod.gurav@ti.com>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Jean Pihet <jean.pihet@newoldbits.com>
    Cc: Govindraj.R <govindraj.raja@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 75c0cd13ad8e..0ec8a04b7473 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -28,6 +28,7 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
+#include <linux/console.h>
 
 #include <plat/sram.h>
 #include <plat/clockdomain.h>
@@ -385,6 +386,12 @@ void omap_sram_idle(void)
 		omap3_enable_io_chain();
 	}
 
+	/* Block console output in case it is on one of the OMAP UARTs */
+	if (per_next_state < PWRDM_POWER_ON ||
+	    core_next_state < PWRDM_POWER_ON)
+		if (try_acquire_console_sem())
+			goto console_still_active;
+
 	/* PER */
 	if (per_next_state < PWRDM_POWER_ON) {
 		omap_uart_prepare_idle(2);
@@ -463,6 +470,9 @@ void omap_sram_idle(void)
 		omap_uart_resume_idle(3);
 	}
 
+	release_console_sem();
+
+console_still_active:
 	/* Disable IO-PAD and IO-CHAIN wakeup */
 	if (omap3_has_io_wakeup() &&
 	    (per_next_state < PWRDM_POWER_ON ||

commit 2f55ac072f5344519348c0c94b3d2f4cca46847b
Author: Lionel Debroux <lionel_debroux@yahoo.fr>
Date:   Tue Nov 16 14:14:02 2010 +0100

    suspend: constify platform_suspend_ops
    
    While at it, fix two checkpatch errors.
    Several non-const struct instances constified by this patch were added after
    the introduction of platform_suspend_ops in checkpatch.pl's list of "should
    be const" structs (79404849e90a41ea2109bd0e2f7c7164b0c4ce73).
    
    Patch against mainline.
    Inspired by hunks of the grsecurity patch, updated for newer kernels.
    
    Signed-off-by: Lionel Debroux <lionel_debroux@yahoo.fr>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 75c0cd13ad8e..4000c3c8bbd5 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -594,7 +594,7 @@ static void omap3_pm_end(void)
 	return;
 }
 
-static struct platform_suspend_ops omap_pm_ops = {
+static const struct platform_suspend_ops omap_pm_ops = {
 	.begin		= omap3_pm_begin,
 	.end		= omap3_pm_end,
 	.prepare	= omap3_pm_prepare,

commit de65815860f187cb43551bc833bf9d72720faa01
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Fri Oct 8 22:43:45 2010 +0000

    OMAP3: PM: fix scratchpad memory accesses for off-mode
    
    Commit 914bab936fe0388a529079679e2f137aa4ff548d (OMAP: mach-omap2: Fix
    incorrect assignment warnings) changed a pointer from 'u32 *' to
    'void *' without also fixing up the pointer arithmetic.
    
    Fix the scratchpad offsets so they are byte offsets instead of
    word offsets and thus work correctly with a void pointer base.
    
    Special thanks to Jean Pihet for taking the time track down this
    problem and propose an initial solution.
    
    Tested with off-idle and off-suspend on 36xx/Zoom3 and 34xx/omap3evm.
    
    Cc: Manjunath Kondaiah G <manjugk@ti.com>
    Reported-by: Jean Pihet <jean.pihet@newoldbits.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Tested-by: Jean Pihet <jean.pihet@newoldbits.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 8c8f1acd3526..75c0cd13ad8e 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -50,9 +50,9 @@
 #include "control.h"
 
 /* Scratchpad offsets */
-#define OMAP343X_TABLE_ADDRESS_OFFSET	   0x31
-#define OMAP343X_TABLE_VALUE_OFFSET	   0x30
-#define OMAP343X_CONTROL_REG_VALUE_OFFSET  0x32
+#define OMAP343X_TABLE_ADDRESS_OFFSET	   0xc4
+#define OMAP343X_TABLE_VALUE_OFFSET	   0xc0
+#define OMAP343X_CONTROL_REG_VALUE_OFFSET  0xc8
 
 struct power_state {
 	struct powerdomain *pwrdm;

commit 4814ced5116e3b73dc4f63eec84999739fc8ed11
Author: Paul Walmsley <paul@pwsan.com>
Date:   Fri Oct 8 11:40:20 2010 -0600

    OMAP: control: move plat-omap/control.h to mach-omap2/control.h
    
    Only OMAP2+ platforms have the System Control Module (SCM) IP block.
    In the past, we've kept the SCM header file in plat-omap.  This has
    led to abuse - device drivers including it; includes being added that
    create implicit dependencies on OMAP2+ builds; etc.
    
    In response, move the SCM headers into mach-omap2/.
    
    As part of this, remove the direct SCM access from the OMAP UDC
    driver.  It was clearly broken.  The UDC code needs an indepth review for
    use on OMAP2+ chips.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Cory Maccarrone <darkstar6262@gmail.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index e57c9aeeefe0..8c8f1acd3526 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -32,7 +32,6 @@
 #include <plat/sram.h>
 #include <plat/clockdomain.h>
 #include <plat/powerdomain.h>
-#include <plat/control.h>
 #include <plat/serial.h>
 #include <plat/sdrc.h>
 #include <plat/prcm.h>
@@ -48,6 +47,7 @@
 #include "prm.h"
 #include "pm.h"
 #include "sdrc.h"
+#include "control.h"
 
 /* Scratchpad offsets */
 #define OMAP343X_TABLE_ADDRESS_OFFSET	   0x31

commit bc3caae8a191c712d8ae666d0b8d18807bfe2b14
Merge: 73c5ef126f40 69758ab7a1e2
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Oct 8 10:20:40 2010 -0700

    Merge branch 'pm-hwmods' of ssh://master.kernel.org/pub/scm/linux/kernel/git/khilman/linux-omap-pm into omap-for-linus

commit 4d63bc1de704c6f413979261bf42781cf364eb14
Author: Manjunath Kondaiah G <manjugk@ti.com>
Date:   Fri Oct 8 09:56:11 2010 -0700

    OMAP: mach-omap2: Fix incorrect assignment warnings
    
    This patch fixes below sparse warnings for incorrect assignments.
    
    arch/arm/mach-omap2/control.c:195:16: warning: incorrect type in assignment (different address spaces)
    arch/arm/mach-omap2/control.c:195:16:    expected unsigned int [usertype] *v_addr
    arch/arm/mach-omap2/control.c:195:16:    got void [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/control.c:199:25: warning: incorrect type in argument 1 (different address spaces)
    arch/arm/mach-omap2/control.c:199:25:    expected void const volatile [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/control.c:199:25:    got unsigned int [usertype] *
    arch/arm/mach-omap2/control.c:320:28: warning: incorrect type in assignment (different address spaces)
    arch/arm/mach-omap2/control.c:320:28:    expected void *[noderef] <asn:2>scratchpad_address
    arch/arm/mach-omap2/control.c:320:28:    got void [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/control.c:321:9: warning: incorrect type in argument 1 (different address spaces)
    arch/arm/mach-omap2/control.c:321:9:    expected void volatile [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/control.c:321:9:    got void *[noderef] <asn:2>scratchpad_address
    arch/arm/mach-omap2/control.c:324:9: warning: incorrect type in argument 1 (different address spaces)
    arch/arm/mach-omap2/control.c:324:9:    expected void volatile [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/control.c:324:9:    got void *
    arch/arm/mach-omap2/control.c:327:9: warning: incorrect type in argument 1 (different address spaces)
    arch/arm/mach-omap2/control.c:327:9:    expected void volatile [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/control.c:327:9:    got void *
    arch/arm/mach-omap2/control.c:334:9: warning: incorrect type in argument 1 (different address spaces)
    arch/arm/mach-omap2/control.c:334:9:    expected void volatile [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/control.c:334:9:    got void *
    arch/arm/mach-omap2/control.c:321:9: warning: dereference of noderef expression
    arch/arm/mach-omap2/control.c:324:9: warning: dereference of noderef expression
    arch/arm/mach-omap2/control.c:327:9: warning: dereference of noderef expression
    arch/arm/mach-omap2/control.c:334:9: warning: dereference of noderef expression
    
    arch/arm/mach-omap2/pm34xx.c:323:28: warning: incorrect type in assignment (different address spaces)
    arch/arm/mach-omap2/pm34xx.c:323:28:    expected unsigned int [usertype] *scratchpad_address
    arch/arm/mach-omap2/pm34xx.c:323:28:    got void [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/pm34xx.c:326:26: warning: incorrect type in argument 1 (different address spaces)
    arch/arm/mach-omap2/pm34xx.c:326:26:    expected void const volatile [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/pm34xx.c:326:26:    got unsigned int [usertype] *
    arch/arm/mach-omap2/pm34xx.c:329:26: warning: incorrect type in argument 1 (different address spaces)
    arch/arm/mach-omap2/pm34xx.c:329:26:    expected void const volatile [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/pm34xx.c:329:26:    got unsigned int [usertype] *
    arch/arm/mach-omap2/pm34xx.c:334:29: warning: incorrect type in argument 1 (different address spaces)
    arch/arm/mach-omap2/pm34xx.c:334:29:    expected void const volatile [noderef] <asn:2>*<noident>
    arch/arm/mach-omap2/pm34xx.c:334:29:    got unsigned int [usertype] *
    
    Signed-off-by: Manjunath Kondaiah G <manjugk@ti.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index d2b940c7215d..ac572aaebb0f 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -310,7 +310,7 @@ static void restore_control_register(u32 val)
 /* Function to restore the table entry that was modified for enabling MMU */
 static void restore_table_entry(void)
 {
-	u32 *scratchpad_address;
+	void __iomem *scratchpad_address;
 	u32 previous_value, control_reg_value;
 	u32 *address;
 

commit cd4f1faee029593fc10039aeb592dc2986d55f61
Author: Govindraj.R <govindraj.raja@ti.com>
Date:   Mon Sep 27 20:20:32 2010 +0530

    OMAP3: PM: Add prepare idle and resume idle call for uart4
    
    Add prepare idle and resume idle call for uart4 used by 3630.
    
    Signed-off-by: Govindraj.R <govindraj.raja@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 043faaa3f3dc..60baffa27cb3 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -388,6 +388,7 @@ void omap_sram_idle(void)
 	/* PER */
 	if (per_next_state < PWRDM_POWER_ON) {
 		omap_uart_prepare_idle(2);
+		omap_uart_prepare_idle(3);
 		omap2_gpio_prepare_for_idle(per_next_state);
 		if (per_next_state == PWRDM_POWER_OFF)
 				omap3_per_save_context();
@@ -459,6 +460,7 @@ void omap_sram_idle(void)
 		if (per_prev_state == PWRDM_POWER_OFF)
 			omap3_per_restore_context();
 		omap_uart_resume_idle(2);
+		omap_uart_resume_idle(3);
 	}
 
 	/* Disable IO-PAD and IO-CHAIN wakeup */

commit e586368904b737b4888927e4c869a25966e5cd05
Author: Govindraj.R <govindraj.raja@ti.com>
Date:   Mon Sep 27 20:20:25 2010 +0530

    OMAP3: PRCM: Consider UART4 for 3630 chip in prcm_setup_regs
    
    To standarize among other uarts (1 to 3), we shall now:
    
     - Enable uart4 autodile bit.
     - Enable uart4 wakeup in PER.
     - Allow uart4 to wakeup the MPU.
    
    Signed-off-by: Sergio Aguirre <saaguirre@ti.com>
    Signed-off-by: Govindraj.R <govindraj.raja@ti.com>
    Acked-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index d2b940c7215d..043faaa3f3dc 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -676,6 +676,14 @@ static void __init omap3_d2d_idle(void)
 
 static void __init prcm_setup_regs(void)
 {
+	u32 omap3630_auto_uart4_mask = cpu_is_omap3630() ?
+					OMAP3630_AUTO_UART4_MASK : 0;
+	u32 omap3630_en_uart4_mask = cpu_is_omap3630() ?
+					OMAP3630_EN_UART4_MASK : 0;
+	u32 omap3630_grpsel_uart4_mask = cpu_is_omap3630() ?
+					OMAP3630_GRPSEL_UART4_MASK : 0;
+
+
 	/* XXX Reset all wkdeps. This should be done when initializing
 	 * powerdomains */
 	prm_write_mod_reg(0, OMAP3430_IVA2_MOD, PM_WKDEP);
@@ -762,6 +770,7 @@ static void __init prcm_setup_regs(void)
 		CM_AUTOIDLE);
 
 	cm_write_mod_reg(
+		omap3630_auto_uart4_mask |
 		OMAP3430_AUTO_GPIO6_MASK |
 		OMAP3430_AUTO_GPIO5_MASK |
 		OMAP3430_AUTO_GPIO4_MASK |
@@ -838,14 +847,16 @@ static void __init prcm_setup_regs(void)
 				OMAP3430_DSS_MOD, PM_WKEN);
 
 	/* Enable wakeups in PER */
-	prm_write_mod_reg(OMAP3430_EN_GPIO2_MASK | OMAP3430_EN_GPIO3_MASK |
+	prm_write_mod_reg(omap3630_en_uart4_mask |
+			  OMAP3430_EN_GPIO2_MASK | OMAP3430_EN_GPIO3_MASK |
 			  OMAP3430_EN_GPIO4_MASK | OMAP3430_EN_GPIO5_MASK |
 			  OMAP3430_EN_GPIO6_MASK | OMAP3430_EN_UART3_MASK |
 			  OMAP3430_EN_MCBSP2_MASK | OMAP3430_EN_MCBSP3_MASK |
 			  OMAP3430_EN_MCBSP4_MASK,
 			  OMAP3430_PER_MOD, PM_WKEN);
 	/* and allow them to wake up MPU */
-	prm_write_mod_reg(OMAP3430_GRPSEL_GPIO2_MASK |
+	prm_write_mod_reg(omap3630_grpsel_uart4_mask |
+			  OMAP3430_GRPSEL_GPIO2_MASK |
 			  OMAP3430_GRPSEL_GPIO3_MASK |
 			  OMAP3430_GRPSEL_GPIO4_MASK |
 			  OMAP3430_GRPSEL_GPIO5_MASK |

commit 6f7f63cc9adf3192e6fcac4e8bed5cc10fd924aa
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Sep 14 15:56:53 2010 -0600

    OMAP clockdomain: initialize clockdomain registers when the clockdomain layer starts
    
    When the clockdomain layer initializes, place all clockdomains into
    software-supervised mode, and clear all wakeup and sleep dependencies
    immediately, rather than waiting for the PM code to do this later.
    This fixes a major bug where critical sleep dependencies added by the
    hwmod code are cleared during late PM init.
    
    As a side benefit, the _init_{wk,sleep}dep_usecount() functions are no
    longer needed, so remove them.
    
    Kevin Hilman <khilman@deeprootsystems.com> did all the really hard work on
    this, identifying the problem and finding the bug.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index f5f1dbd3c17a..d2b940c7215d 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -949,9 +949,6 @@ static int __init pwrdms_setup(struct powerdomain *pwrdm, void *unused)
  */
 static int __init clkdms_setup(struct clockdomain *clkdm, void *unused)
 {
-	clkdm_clear_all_wkdeps(clkdm);
-	clkdm_clear_all_sleepdeps(clkdm);
-
 	if (clkdm->flags & CLKDM_CAN_ENABLE_AUTO)
 		omap2_clkdm_allow_idle(clkdm);
 	else if (clkdm->flags & CLKDM_CAN_FORCE_SLEEP &&

commit eb6a2c7550560e6619eadb912ea8384ce27964b8
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Wed Sep 15 01:04:01 2010 +0530

    omap: pm: Move set_pwrdm_state routine to common pm.c
    
    The set_pwrdm_state() is needed on omap4 as well so move
    this routine to common pm.c file so that it's available for omap3/4
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index bc24fbd2e983..f5f1dbd3c17a 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -483,51 +483,6 @@ int omap3_can_sleep(void)
 	return 1;
 }
 
-/* This sets pwrdm state (other than mpu & core. Currently only ON &
- * RET are supported. Function is assuming that clkdm doesn't have
- * hw_sup mode enabled. */
-int set_pwrdm_state(struct powerdomain *pwrdm, u32 state)
-{
-	u32 cur_state;
-	int sleep_switch = 0;
-	int ret = 0;
-
-	if (pwrdm == NULL || IS_ERR(pwrdm))
-		return -EINVAL;
-
-	while (!(pwrdm->pwrsts & (1 << state))) {
-		if (state == PWRDM_POWER_OFF)
-			return ret;
-		state--;
-	}
-
-	cur_state = pwrdm_read_next_pwrst(pwrdm);
-	if (cur_state == state)
-		return ret;
-
-	if (pwrdm_read_pwrst(pwrdm) < PWRDM_POWER_ON) {
-		omap2_clkdm_wakeup(pwrdm->pwrdm_clkdms[0]);
-		sleep_switch = 1;
-		pwrdm_wait_transition(pwrdm);
-	}
-
-	ret = pwrdm_set_next_pwrst(pwrdm, state);
-	if (ret) {
-		printk(KERN_ERR "Unable to set state of powerdomain: %s\n",
-		       pwrdm->name);
-		goto err;
-	}
-
-	if (sleep_switch) {
-		omap2_clkdm_allow_idle(pwrdm->pwrdm_clkdms[0]);
-		pwrdm_wait_transition(pwrdm);
-		pwrdm_state_switch(pwrdm);
-	}
-
-err:
-	return ret;
-}
-
 static void omap3_pm_idle(void)
 {
 	local_irq_disable();
@@ -569,7 +524,7 @@ static int omap3_pm_suspend(void)
 		pwrst->saved_state = pwrdm_read_next_pwrst(pwrst->pwrdm);
 	/* Set ones wanted by suspend */
 	list_for_each_entry(pwrst, &pwrst_list, node) {
-		if (set_pwrdm_state(pwrst->pwrdm, pwrst->next_state))
+		if (omap_set_pwrdm_state(pwrst->pwrdm, pwrst->next_state))
 			goto restore;
 		if (pwrdm_clear_all_prev_pwrst(pwrst->pwrdm))
 			goto restore;
@@ -590,7 +545,7 @@ static int omap3_pm_suspend(void)
 			       pwrst->pwrdm->name, pwrst->next_state);
 			ret = -1;
 		}
-		set_pwrdm_state(pwrst->pwrdm, pwrst->saved_state);
+		omap_set_pwrdm_state(pwrst->pwrdm, pwrst->saved_state);
 	}
 	if (ret)
 		printk(KERN_ERR "Could not enter target state in pm_suspend\n");
@@ -939,7 +894,7 @@ void omap3_pm_off_mode_enable(int enable)
 
 	list_for_each_entry(pwrst, &pwrst_list, node) {
 		pwrst->next_state = state;
-		set_pwrdm_state(pwrst->pwrdm, state);
+		omap_set_pwrdm_state(pwrst->pwrdm, state);
 	}
 }
 
@@ -984,7 +939,7 @@ static int __init pwrdms_setup(struct powerdomain *pwrdm, void *unused)
 	if (pwrdm_has_hdwr_sar(pwrdm))
 		pwrdm_enable_hdwr_sar(pwrdm);
 
-	return set_pwrdm_state(pwrst->pwrdm, pwrst->next_state);
+	return omap_set_pwrdm_state(pwrst->pwrdm, pwrst->next_state);
 }
 
 /*

commit 86b0c1e3c07f7fc3a8197a934d9a04476061bed9
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Wed Sep 15 01:03:59 2010 +0530

    omap: pm-debug: Move common debug code to pm-debug.c
    
    This patch moves omap2_pm_wakeup_on_timer() and pm debug entries
    form pm34xx.c to pm-debug.c and export it, so that it is available
    to other OMAPs
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index bb2ba1e03d09..bc24fbd2e983 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -38,7 +38,6 @@
 #include <plat/prcm.h>
 #include <plat/gpmc.h>
 #include <plat/dma.h>
-#include <plat/dmtimer.h>
 
 #include <asm/tlbflush.h>
 
@@ -550,23 +549,6 @@ static void omap3_pm_idle(void)
 #ifdef CONFIG_SUSPEND
 static suspend_state_t suspend_state;
 
-static void omap2_pm_wakeup_on_timer(u32 seconds, u32 milliseconds)
-{
-	u32 tick_rate, cycles;
-
-	if (!seconds && !milliseconds)
-		return;
-
-	tick_rate = clk_get_rate(omap_dm_timer_get_fclk(gptimer_wakeup));
-	cycles = tick_rate * seconds + tick_rate * milliseconds / 1000;
-	omap_dm_timer_stop(gptimer_wakeup);
-	omap_dm_timer_set_load_start(gptimer_wakeup, 0, 0xffffffff - cycles);
-
-	pr_info("PM: Resume timer in %u.%03u secs"
-		" (%d ticks at %d ticks/sec.)\n",
-		seconds, milliseconds, cycles, tick_rate);
-}
-
 static int omap3_pm_prepare(void)
 {
 	disable_hlt();

commit e7410cf7831c2e5106a90dac6179df5d2c9bd60e
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Wed Sep 8 16:37:42 2010 -0700

    OMAP3: PM: move device-specific special cases from PM core into CPUidle
    
    In an effort to simplify the core idle path, move any device-specific
    special case handling from the core PM idle path into the CPUidle
    pre-idle checking path.
    
    This keeps the core, interrupts-disabled idle path streamlined and
    independent of any device-specific handling, and also allows CPUidle
    to do the checking only for certain C-states as needed.  This patch
    has the device checks in place for all states with the CHECK_BM flag,
    namely all states >= C2.
    
    This patch was inspired by a similar patch written by Tero Kristo as
    part of a larger series to add INACTIVE state support.
    
    NOTE: This is a baby-step towards decoupling device idle (or system
    idle) from CPU idle.  Eventually, CPUidle should only manage the CPU,
    and device/system idle should be managed elsewhere.
    
    Cc: Tero Kristo <tero.kristo@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 429268eaf8b3..bb2ba1e03d09 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -346,7 +346,6 @@ void omap_sram_idle(void)
 	int core_next_state = PWRDM_POWER_ON;
 	int core_prev_state, per_prev_state;
 	u32 sdrc_pwr = 0;
-	int per_state_modified = 0;
 
 	if (!_omap_sram_idle)
 		return;
@@ -391,19 +390,10 @@ void omap_sram_idle(void)
 	if (per_next_state < PWRDM_POWER_ON) {
 		omap_uart_prepare_idle(2);
 		omap2_gpio_prepare_for_idle(per_next_state);
-		if (per_next_state == PWRDM_POWER_OFF) {
-			if (core_next_state == PWRDM_POWER_ON) {
-				per_next_state = PWRDM_POWER_RET;
-				pwrdm_set_next_pwrst(per_pwrdm, per_next_state);
-				per_state_modified = 1;
-			} else
+		if (per_next_state == PWRDM_POWER_OFF)
 				omap3_per_save_context();
-		}
 	}
 
-	if (pwrdm_read_pwrst(cam_pwrdm) == PWRDM_POWER_ON)
-		omap2_clkdm_deny_idle(mpu_pwrdm->pwrdm_clkdms[0]);
-
 	/* CORE */
 	if (core_next_state < PWRDM_POWER_ON) {
 		omap_uart_prepare_idle(0);
@@ -470,8 +460,6 @@ void omap_sram_idle(void)
 		if (per_prev_state == PWRDM_POWER_OFF)
 			omap3_per_restore_context();
 		omap_uart_resume_idle(2);
-		if (per_state_modified)
-			pwrdm_set_next_pwrst(per_pwrdm, PWRDM_POWER_OFF);
 	}
 
 	/* Disable IO-PAD and IO-CHAIN wakeup */

commit 6cdee91257bee23a46dc869ca62469b67cba2c7e
Author: Thara Gopinath <thara@ti.com>
Date:   Thu Aug 12 13:52:25 2010 +0530

    OMAP: PM debugfs removing OMAP3 hardcodings.
    
    This patch removes omap3 hardcodings from pm-debug.c
    so that enabling PM debugfs support does break compilation
    for other OMAP's. This is a preparatory patch for supporting
    OMAP4 pm entries through PM debugfs.
    
    Signed-off-by: Thara Gopinath <thara@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index b5e5bcbb4964..429268eaf8b3 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -55,11 +55,6 @@
 #define OMAP343X_TABLE_VALUE_OFFSET	   0x30
 #define OMAP343X_CONTROL_REG_VALUE_OFFSET  0x32
 
-u32 enable_off_mode;
-u32 sleep_while_idle;
-u32 wakeup_timer_seconds;
-u32 wakeup_timer_milliseconds;
-
 struct power_state {
 	struct powerdomain *pwrdm;
 	u32 next_state;

commit d5c47d7e97c141edb620b3932e1e1cb39e70c654
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Tue Aug 10 16:04:35 2010 -0700

    OMAP3: PM: whitespace cleanup around IO wakeup enable
    
    Cleanup indentation around IO wakeup enable, the '\' terminator is
    not required in C when wrapping an expression past end-of-line.
    
    Whitespace change only.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 7b03426c72a3..b5e5bcbb4964 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -385,9 +385,9 @@ void omap_sram_idle(void)
 	/* Enable IO-PAD and IO-CHAIN wakeups */
 	per_next_state = pwrdm_read_next_pwrst(per_pwrdm);
 	core_next_state = pwrdm_read_next_pwrst(core_pwrdm);
-	if (omap3_has_io_wakeup() && \
-			(per_next_state < PWRDM_POWER_ON ||
-			core_next_state < PWRDM_POWER_ON)) {
+	if (omap3_has_io_wakeup() &&
+	    (per_next_state < PWRDM_POWER_ON ||
+	     core_next_state < PWRDM_POWER_ON)) {
 		prm_set_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD, PM_WKEN);
 		omap3_enable_io_chain();
 	}

commit 58a5559e461a4ab945286dacef611d3c542c5fee
Author: Kevin Hilman <khilman@ti.com>
Date:   Mon Aug 16 09:21:19 2010 +0300

    OMAP3: PM: ensure IO wakeups are properly disabled
    
    Commit 5a5f561 (convert OMAP3 PRCM macros to the _SHIFT/_MASK suffixes)
    mistakenly removed the check for PER when disabling the IO chain.
    
    During idle, if the PER powerdomain transitions into a lower state
    and CORE does not, the IO pad wakeups are not being disabled in
    the idle path after they are enabled. This can happen with the
    lower C-states when using CPUidle for example.
    
    This patch ensures that the check for disabling IO wakeups also checks
    for PER transitions, matching the check done to enable IO wakeups.
    
    Found when debugging PM/CPUidle related problems reported by Ameya
    Palande <ameya.palande@nokia.com>.  Problems were triggered
    particularily on boards with UART2 consoles (n900, Overo) since UART2
    is in the PER powerdomain.
    
    Tested on l-o master (omap3_defonfig + CONFIG_CPU_IDLE=y) as well
    as with current PM branch.  Boards tested: n900, Overo, omap3evm.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: Ameya Palande <ameya.palande@nokia.com>
    Tested-by: Jarkko Nikula <jhnikula@gmail.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    [tony@atomide.com: updated description to clarify the transistion]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index fb4994ad622e..7b03426c72a3 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -480,7 +480,9 @@ void omap_sram_idle(void)
 	}
 
 	/* Disable IO-PAD and IO-CHAIN wakeup */
-	if (omap3_has_io_wakeup() && core_next_state < PWRDM_POWER_ON) {
+	if (omap3_has_io_wakeup() &&
+	    (per_next_state < PWRDM_POWER_ON ||
+	     core_next_state < PWRDM_POWER_ON)) {
 		prm_clear_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD, PM_WKEN);
 		omap3_disable_io_chain();
 	}

commit ad0c63f1d623ea9d3e0c0521d5ce9cd522c4e1f0
Author: stanley.miao <stanley.miao@windriver.com>
Date:   Mon Aug 2 14:21:40 2010 +0300

    OMAP3: AM3505/3517 do not have IO wakeup capability
    
    AM3505/3517 doesn't have IO wakeup capability, so we do not need to set
    the bit OMAP3430_EN_IO and the bit OMAP3430_EN_IO_CHAIN in the register
    PM_WKEN_WKUP when the system enters suspend state.
    
    Tested on AM3517EVM and OMAP3530EVM.
    
    Signed-off-by: Stanley.Miao <stanley.miao@windriver.com>
    Acked-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index b88737fd6cfe..fb4994ad622e 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -385,8 +385,9 @@ void omap_sram_idle(void)
 	/* Enable IO-PAD and IO-CHAIN wakeups */
 	per_next_state = pwrdm_read_next_pwrst(per_pwrdm);
 	core_next_state = pwrdm_read_next_pwrst(core_pwrdm);
-	if (per_next_state < PWRDM_POWER_ON ||
-			core_next_state < PWRDM_POWER_ON) {
+	if (omap3_has_io_wakeup() && \
+			(per_next_state < PWRDM_POWER_ON ||
+			core_next_state < PWRDM_POWER_ON)) {
 		prm_set_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD, PM_WKEN);
 		omap3_enable_io_chain();
 	}
@@ -479,7 +480,7 @@ void omap_sram_idle(void)
 	}
 
 	/* Disable IO-PAD and IO-CHAIN wakeup */
-	if (core_next_state < PWRDM_POWER_ON) {
+	if (omap3_has_io_wakeup() && core_next_state < PWRDM_POWER_ON) {
 		prm_clear_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD, PM_WKEN);
 		omap3_disable_io_chain();
 	}

commit 0b96a3a3c5c5e6e1b79a05c23d110d59518f4fc8
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Wed Jun 9 13:53:09 2010 +0300

    OMAP3: PM: fix IO daisy chain enable to use PM_WKEN reg
    
    Checking to se if the IO daisy chain is enabled should be checking the
    PM_WKEN register, not the PM_WKST register.  Reading PM_WKST tells us
    if an event occurred, not whether or not it is enabled.
    
    Apparently, we've been lucky until now in that a pending event has not
    been there during enable.  However, on 3630/Zoom3, I noticed because
    of the WARN that this timeout was always happening.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 2e967716cc3f..b88737fd6cfe 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -99,7 +99,7 @@ static void omap3_enable_io_chain(void)
 		/* Do a readback to assure write has been done */
 		prm_read_mod_reg(WKUP_MOD, PM_WKEN);
 
-		while (!(prm_read_mod_reg(WKUP_MOD, PM_WKST) &
+		while (!(prm_read_mod_reg(WKUP_MOD, PM_WKEN) &
 			 OMAP3430_ST_IO_CHAIN_MASK)) {
 			timeout++;
 			if (timeout > 1000) {
@@ -108,7 +108,7 @@ static void omap3_enable_io_chain(void)
 				return;
 			}
 			prm_set_mod_reg_bits(OMAP3430_ST_IO_CHAIN_MASK,
-					     WKUP_MOD, PM_WKST);
+					     WKUP_MOD, PM_WKEN);
 		}
 	}
 }

commit 275f675c24a16ea45cc78bc03ff73fd06be8bffb
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue May 18 18:40:23 2010 -0600

    OMAP3: PM: PM_MPUGRPSEL writes should use GRPSEL macros, not EN macros
    
    Writes to the PM_*GRPSEL registers should use _GRPSEL_ macros, not _EN_ macros,
    to match the TRM and guard against inadvertent error.  This patch should
    not cause any functional change.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Jouni Hgander <jouni.hogander@nokia.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index b2c299d9f428..2e967716cc3f 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -901,8 +901,9 @@ static void __init prcm_setup_regs(void)
 			  OMAP3430_EN_GPT1_MASK | OMAP3430_EN_GPT12_MASK,
 			  WKUP_MOD, PM_WKEN);
 	/* No need to write EN_IO, that is always enabled */
-	prm_write_mod_reg(OMAP3430_EN_GPIO1_MASK | OMAP3430_EN_GPT1_MASK |
-			  OMAP3430_EN_GPT12_MASK,
+	prm_write_mod_reg(OMAP3430_GRPSEL_GPIO1_MASK |
+			  OMAP3430_GRPSEL_GPT1_MASK |
+			  OMAP3430_GRPSEL_GPT12_MASK,
 			  WKUP_MOD, OMAP3430_PM_MPUGRPSEL);
 	/* For some reason IO doesn't generate wakeup event even if
 	 * it is selected to mpu wakeup goup */
@@ -921,11 +922,15 @@ static void __init prcm_setup_regs(void)
 			  OMAP3430_EN_MCBSP4_MASK,
 			  OMAP3430_PER_MOD, PM_WKEN);
 	/* and allow them to wake up MPU */
-	prm_write_mod_reg(OMAP3430_GRPSEL_GPIO2_MASK | OMAP3430_EN_GPIO3_MASK |
-			  OMAP3430_GRPSEL_GPIO4_MASK | OMAP3430_EN_GPIO5_MASK |
-			  OMAP3430_GRPSEL_GPIO6_MASK | OMAP3430_EN_UART3_MASK |
-			  OMAP3430_EN_MCBSP2_MASK | OMAP3430_EN_MCBSP3_MASK |
-			  OMAP3430_EN_MCBSP4_MASK,
+	prm_write_mod_reg(OMAP3430_GRPSEL_GPIO2_MASK |
+			  OMAP3430_GRPSEL_GPIO3_MASK |
+			  OMAP3430_GRPSEL_GPIO4_MASK |
+			  OMAP3430_GRPSEL_GPIO5_MASK |
+			  OMAP3430_GRPSEL_GPIO6_MASK |
+			  OMAP3430_GRPSEL_UART3_MASK |
+			  OMAP3430_GRPSEL_MCBSP2_MASK |
+			  OMAP3430_GRPSEL_MCBSP3_MASK |
+			  OMAP3430_GRPSEL_MCBSP4_MASK,
 			  OMAP3430_PER_MOD, OMAP3430_PM_MPUGRPSEL);
 
 	/* Don't attach IVA interrupts */

commit 2fd0f75cb3413105ed10041c719346ccb710fbc6
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue May 18 18:40:23 2010 -0600

    OMAP2+ PRCM: convert remaining PRCM macros to the _SHIFT/_MASK suffixes
    
    Fix all of the remaining PRCM register shift/bitmask macros that did not
    use the _SHIFT/_MASK suffixes to use them.  This makes the use of these
    macros consistent.  It is intended to reduce error, as code can be inspected
    visually by reviewers to ensure that bitshifts and bitmasks are used in
    the appropriate places.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index dd09d80ea3eb..b2c299d9f428 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -867,7 +867,7 @@ static void __init prcm_setup_regs(void)
 			CM_AUTOIDLE);
 	}
 
-	omap_ctrl_writel(OMAP3430_AUTOIDLE, OMAP2_CONTROL_SYSCONFIG);
+	omap_ctrl_writel(OMAP3430_AUTOIDLE_MASK, OMAP2_CONTROL_SYSCONFIG);
 
 	/*
 	 * Set all plls to autoidle. This is needed until autoidle is
@@ -897,12 +897,12 @@ static void __init prcm_setup_regs(void)
 			     OMAP3_PRM_CLKSRC_CTRL_OFFSET);
 
 	/* setup wakup source */
-	prm_write_mod_reg(OMAP3430_EN_IO_MASK | OMAP3430_EN_GPIO1 |
-			  OMAP3430_EN_GPT1 | OMAP3430_EN_GPT12,
+	prm_write_mod_reg(OMAP3430_EN_IO_MASK | OMAP3430_EN_GPIO1_MASK |
+			  OMAP3430_EN_GPT1_MASK | OMAP3430_EN_GPT12_MASK,
 			  WKUP_MOD, PM_WKEN);
 	/* No need to write EN_IO, that is always enabled */
-	prm_write_mod_reg(OMAP3430_EN_GPIO1 | OMAP3430_EN_GPT1 |
-			  OMAP3430_EN_GPT12,
+	prm_write_mod_reg(OMAP3430_EN_GPIO1_MASK | OMAP3430_EN_GPT1_MASK |
+			  OMAP3430_EN_GPT12_MASK,
 			  WKUP_MOD, OMAP3430_PM_MPUGRPSEL);
 	/* For some reason IO doesn't generate wakeup event even if
 	 * it is selected to mpu wakeup goup */
@@ -914,18 +914,18 @@ static void __init prcm_setup_regs(void)
 				OMAP3430_DSS_MOD, PM_WKEN);
 
 	/* Enable wakeups in PER */
-	prm_write_mod_reg(OMAP3430_EN_GPIO2 | OMAP3430_EN_GPIO3 |
-			  OMAP3430_EN_GPIO4 | OMAP3430_EN_GPIO5 |
-			  OMAP3430_EN_GPIO6 | OMAP3430_EN_UART3 |
-			  OMAP3430_EN_MCBSP2 | OMAP3430_EN_MCBSP3 |
-			  OMAP3430_EN_MCBSP4,
+	prm_write_mod_reg(OMAP3430_EN_GPIO2_MASK | OMAP3430_EN_GPIO3_MASK |
+			  OMAP3430_EN_GPIO4_MASK | OMAP3430_EN_GPIO5_MASK |
+			  OMAP3430_EN_GPIO6_MASK | OMAP3430_EN_UART3_MASK |
+			  OMAP3430_EN_MCBSP2_MASK | OMAP3430_EN_MCBSP3_MASK |
+			  OMAP3430_EN_MCBSP4_MASK,
 			  OMAP3430_PER_MOD, PM_WKEN);
 	/* and allow them to wake up MPU */
-	prm_write_mod_reg(OMAP3430_GRPSEL_GPIO2_MASK | OMAP3430_EN_GPIO3 |
-			  OMAP3430_GRPSEL_GPIO4_MASK | OMAP3430_EN_GPIO5 |
-			  OMAP3430_GRPSEL_GPIO6_MASK | OMAP3430_EN_UART3 |
-			  OMAP3430_EN_MCBSP2 | OMAP3430_EN_MCBSP3 |
-			  OMAP3430_EN_MCBSP4,
+	prm_write_mod_reg(OMAP3430_GRPSEL_GPIO2_MASK | OMAP3430_EN_GPIO3_MASK |
+			  OMAP3430_GRPSEL_GPIO4_MASK | OMAP3430_EN_GPIO5_MASK |
+			  OMAP3430_GRPSEL_GPIO6_MASK | OMAP3430_EN_UART3_MASK |
+			  OMAP3430_EN_MCBSP2_MASK | OMAP3430_EN_MCBSP3_MASK |
+			  OMAP3430_EN_MCBSP4_MASK,
 			  OMAP3430_PER_MOD, OMAP3430_PM_MPUGRPSEL);
 
 	/* Don't attach IVA interrupts */

commit 2bc4ef71c5a3b6986b452d6c530777974d11ef4a
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue May 18 18:47:24 2010 -0600

    OMAP3 PRCM: convert OMAP3 PRCM macros to the _SHIFT/_MASK suffixes
    
    Fix all of the remaining OMAP3 PRCM register shift/bitmask macros that
    did not use the _SHIFT/_MASK suffixes to use them.  This makes the use
    of these macros consistent.  It is intended to reduce error, as code
    can be inspected visually by reviewers to ensure that bitshifts and
    bitmasks are used in the appropriate places.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 24c1966f935e..dd09d80ea3eb 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -94,19 +94,20 @@ static void omap3_enable_io_chain(void)
 	int timeout = 0;
 
 	if (omap_rev() >= OMAP3430_REV_ES3_1) {
-		prm_set_mod_reg_bits(OMAP3430_EN_IO_CHAIN, WKUP_MOD, PM_WKEN);
+		prm_set_mod_reg_bits(OMAP3430_EN_IO_CHAIN_MASK, WKUP_MOD,
+				     PM_WKEN);
 		/* Do a readback to assure write has been done */
 		prm_read_mod_reg(WKUP_MOD, PM_WKEN);
 
 		while (!(prm_read_mod_reg(WKUP_MOD, PM_WKST) &
-			 OMAP3430_ST_IO_CHAIN)) {
+			 OMAP3430_ST_IO_CHAIN_MASK)) {
 			timeout++;
 			if (timeout > 1000) {
 				printk(KERN_ERR "Wake up daisy chain "
 				       "activation failed.\n");
 				return;
 			}
-			prm_set_mod_reg_bits(OMAP3430_ST_IO_CHAIN,
+			prm_set_mod_reg_bits(OMAP3430_ST_IO_CHAIN_MASK,
 					     WKUP_MOD, PM_WKST);
 		}
 	}
@@ -115,7 +116,8 @@ static void omap3_enable_io_chain(void)
 static void omap3_disable_io_chain(void)
 {
 	if (omap_rev() >= OMAP3430_REV_ES3_1)
-		prm_clear_mod_reg_bits(OMAP3430_EN_IO_CHAIN, WKUP_MOD, PM_WKEN);
+		prm_clear_mod_reg_bits(OMAP3430_EN_IO_CHAIN_MASK, WKUP_MOD,
+				       PM_WKEN);
 }
 
 static void omap3_core_save_context(void)
@@ -278,7 +280,8 @@ static irqreturn_t prcm_interrupt_handler (int irq, void *dev_id)
 	irqstatus_mpu &= irqenable_mpu;
 
 	do {
-		if (irqstatus_mpu & (OMAP3430_WKUP_ST | OMAP3430_IO_ST)) {
+		if (irqstatus_mpu & (OMAP3430_WKUP_ST_MASK |
+				     OMAP3430_IO_ST_MASK)) {
 			c = _prcm_int_handle_wakeup();
 
 			/*
@@ -384,7 +387,7 @@ void omap_sram_idle(void)
 	core_next_state = pwrdm_read_next_pwrst(core_pwrdm);
 	if (per_next_state < PWRDM_POWER_ON ||
 			core_next_state < PWRDM_POWER_ON) {
-		prm_set_mod_reg_bits(OMAP3430_EN_IO, WKUP_MOD, PM_WKEN);
+		prm_set_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD, PM_WKEN);
 		omap3_enable_io_chain();
 	}
 
@@ -458,7 +461,7 @@ void omap_sram_idle(void)
 		omap_uart_resume_idle(0);
 		omap_uart_resume_idle(1);
 		if (core_next_state == PWRDM_POWER_OFF)
-			prm_clear_mod_reg_bits(OMAP3430_AUTO_OFF,
+			prm_clear_mod_reg_bits(OMAP3430_AUTO_OFF_MASK,
 					       OMAP3430_GR_MOD,
 					       OMAP3_PRM_VOLTCTRL_OFFSET);
 	}
@@ -476,9 +479,8 @@ void omap_sram_idle(void)
 	}
 
 	/* Disable IO-PAD and IO-CHAIN wakeup */
-	if (per_next_state < PWRDM_POWER_ON ||
-			core_next_state < PWRDM_POWER_ON) {
-		prm_clear_mod_reg_bits(OMAP3430_EN_IO, WKUP_MOD, PM_WKEN);
+	if (core_next_state < PWRDM_POWER_ON) {
+		prm_clear_mod_reg_bits(OMAP3430_EN_IO_MASK, WKUP_MOD, PM_WKEN);
 		omap3_disable_io_chain();
 	}
 
@@ -699,9 +701,9 @@ static void __init omap3_iva_idle(void)
 		return;
 
 	/* Reset IVA2 */
-	prm_write_mod_reg(OMAP3430_RST1_IVA2 |
-			  OMAP3430_RST2_IVA2 |
-			  OMAP3430_RST3_IVA2,
+	prm_write_mod_reg(OMAP3430_RST1_IVA2_MASK |
+			  OMAP3430_RST2_IVA2_MASK |
+			  OMAP3430_RST3_IVA2_MASK,
 			  OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);
 
 	/* Enable IVA2 clock */
@@ -719,9 +721,9 @@ static void __init omap3_iva_idle(void)
 	cm_write_mod_reg(0, OMAP3430_IVA2_MOD, CM_FCLKEN);
 
 	/* Reset IVA2 */
-	prm_write_mod_reg(OMAP3430_RST1_IVA2 |
-			  OMAP3430_RST2_IVA2 |
-			  OMAP3430_RST3_IVA2,
+	prm_write_mod_reg(OMAP3430_RST1_IVA2_MASK |
+			  OMAP3430_RST2_IVA2_MASK |
+			  OMAP3430_RST3_IVA2_MASK,
 			  OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);
 }
 
@@ -743,8 +745,8 @@ static void __init omap3_d2d_idle(void)
 	omap_ctrl_writew(padconf, OMAP3_PADCONF_SAD2D_IDLEACK);
 
 	/* reset modem */
-	prm_write_mod_reg(OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RSTPWRON |
-			  OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RST,
+	prm_write_mod_reg(OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RSTPWRON_MASK |
+			  OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RST_MASK,
 			  CORE_MOD, OMAP2_RM_RSTCTRL);
 	prm_write_mod_reg(0, CORE_MOD, OMAP2_RM_RSTCTRL);
 }
@@ -770,97 +772,97 @@ static void __init prcm_setup_regs(void)
 	 * Note that in the long run this should be done by clockfw
 	 */
 	cm_write_mod_reg(
-		OMAP3430_AUTO_MODEM |
-		OMAP3430ES2_AUTO_MMC3 |
-		OMAP3430ES2_AUTO_ICR |
-		OMAP3430_AUTO_AES2 |
-		OMAP3430_AUTO_SHA12 |
-		OMAP3430_AUTO_DES2 |
-		OMAP3430_AUTO_MMC2 |
-		OMAP3430_AUTO_MMC1 |
-		OMAP3430_AUTO_MSPRO |
-		OMAP3430_AUTO_HDQ |
-		OMAP3430_AUTO_MCSPI4 |
-		OMAP3430_AUTO_MCSPI3 |
-		OMAP3430_AUTO_MCSPI2 |
-		OMAP3430_AUTO_MCSPI1 |
-		OMAP3430_AUTO_I2C3 |
-		OMAP3430_AUTO_I2C2 |
-		OMAP3430_AUTO_I2C1 |
-		OMAP3430_AUTO_UART2 |
-		OMAP3430_AUTO_UART1 |
-		OMAP3430_AUTO_GPT11 |
-		OMAP3430_AUTO_GPT10 |
-		OMAP3430_AUTO_MCBSP5 |
-		OMAP3430_AUTO_MCBSP1 |
-		OMAP3430ES1_AUTO_FAC | /* This is es1 only */
-		OMAP3430_AUTO_MAILBOXES |
-		OMAP3430_AUTO_OMAPCTRL |
-		OMAP3430ES1_AUTO_FSHOSTUSB |
-		OMAP3430_AUTO_HSOTGUSB |
-		OMAP3430_AUTO_SAD2D |
-		OMAP3430_AUTO_SSI,
+		OMAP3430_AUTO_MODEM_MASK |
+		OMAP3430ES2_AUTO_MMC3_MASK |
+		OMAP3430ES2_AUTO_ICR_MASK |
+		OMAP3430_AUTO_AES2_MASK |
+		OMAP3430_AUTO_SHA12_MASK |
+		OMAP3430_AUTO_DES2_MASK |
+		OMAP3430_AUTO_MMC2_MASK |
+		OMAP3430_AUTO_MMC1_MASK |
+		OMAP3430_AUTO_MSPRO_MASK |
+		OMAP3430_AUTO_HDQ_MASK |
+		OMAP3430_AUTO_MCSPI4_MASK |
+		OMAP3430_AUTO_MCSPI3_MASK |
+		OMAP3430_AUTO_MCSPI2_MASK |
+		OMAP3430_AUTO_MCSPI1_MASK |
+		OMAP3430_AUTO_I2C3_MASK |
+		OMAP3430_AUTO_I2C2_MASK |
+		OMAP3430_AUTO_I2C1_MASK |
+		OMAP3430_AUTO_UART2_MASK |
+		OMAP3430_AUTO_UART1_MASK |
+		OMAP3430_AUTO_GPT11_MASK |
+		OMAP3430_AUTO_GPT10_MASK |
+		OMAP3430_AUTO_MCBSP5_MASK |
+		OMAP3430_AUTO_MCBSP1_MASK |
+		OMAP3430ES1_AUTO_FAC_MASK | /* This is es1 only */
+		OMAP3430_AUTO_MAILBOXES_MASK |
+		OMAP3430_AUTO_OMAPCTRL_MASK |
+		OMAP3430ES1_AUTO_FSHOSTUSB_MASK |
+		OMAP3430_AUTO_HSOTGUSB_MASK |
+		OMAP3430_AUTO_SAD2D_MASK |
+		OMAP3430_AUTO_SSI_MASK,
 		CORE_MOD, CM_AUTOIDLE1);
 
 	cm_write_mod_reg(
-		OMAP3430_AUTO_PKA |
-		OMAP3430_AUTO_AES1 |
-		OMAP3430_AUTO_RNG |
-		OMAP3430_AUTO_SHA11 |
-		OMAP3430_AUTO_DES1,
+		OMAP3430_AUTO_PKA_MASK |
+		OMAP3430_AUTO_AES1_MASK |
+		OMAP3430_AUTO_RNG_MASK |
+		OMAP3430_AUTO_SHA11_MASK |
+		OMAP3430_AUTO_DES1_MASK,
 		CORE_MOD, CM_AUTOIDLE2);
 
 	if (omap_rev() > OMAP3430_REV_ES1_0) {
 		cm_write_mod_reg(
-			OMAP3430_AUTO_MAD2D |
-			OMAP3430ES2_AUTO_USBTLL,
+			OMAP3430_AUTO_MAD2D_MASK |
+			OMAP3430ES2_AUTO_USBTLL_MASK,
 			CORE_MOD, CM_AUTOIDLE3);
 	}
 
 	cm_write_mod_reg(
-		OMAP3430_AUTO_WDT2 |
-		OMAP3430_AUTO_WDT1 |
-		OMAP3430_AUTO_GPIO1 |
-		OMAP3430_AUTO_32KSYNC |
-		OMAP3430_AUTO_GPT12 |
-		OMAP3430_AUTO_GPT1 ,
+		OMAP3430_AUTO_WDT2_MASK |
+		OMAP3430_AUTO_WDT1_MASK |
+		OMAP3430_AUTO_GPIO1_MASK |
+		OMAP3430_AUTO_32KSYNC_MASK |
+		OMAP3430_AUTO_GPT12_MASK |
+		OMAP3430_AUTO_GPT1_MASK,
 		WKUP_MOD, CM_AUTOIDLE);
 
 	cm_write_mod_reg(
-		OMAP3430_AUTO_DSS,
+		OMAP3430_AUTO_DSS_MASK,
 		OMAP3430_DSS_MOD,
 		CM_AUTOIDLE);
 
 	cm_write_mod_reg(
-		OMAP3430_AUTO_CAM,
+		OMAP3430_AUTO_CAM_MASK,
 		OMAP3430_CAM_MOD,
 		CM_AUTOIDLE);
 
 	cm_write_mod_reg(
-		OMAP3430_AUTO_GPIO6 |
-		OMAP3430_AUTO_GPIO5 |
-		OMAP3430_AUTO_GPIO4 |
-		OMAP3430_AUTO_GPIO3 |
-		OMAP3430_AUTO_GPIO2 |
-		OMAP3430_AUTO_WDT3 |
-		OMAP3430_AUTO_UART3 |
-		OMAP3430_AUTO_GPT9 |
-		OMAP3430_AUTO_GPT8 |
-		OMAP3430_AUTO_GPT7 |
-		OMAP3430_AUTO_GPT6 |
-		OMAP3430_AUTO_GPT5 |
-		OMAP3430_AUTO_GPT4 |
-		OMAP3430_AUTO_GPT3 |
-		OMAP3430_AUTO_GPT2 |
-		OMAP3430_AUTO_MCBSP4 |
-		OMAP3430_AUTO_MCBSP3 |
-		OMAP3430_AUTO_MCBSP2,
+		OMAP3430_AUTO_GPIO6_MASK |
+		OMAP3430_AUTO_GPIO5_MASK |
+		OMAP3430_AUTO_GPIO4_MASK |
+		OMAP3430_AUTO_GPIO3_MASK |
+		OMAP3430_AUTO_GPIO2_MASK |
+		OMAP3430_AUTO_WDT3_MASK |
+		OMAP3430_AUTO_UART3_MASK |
+		OMAP3430_AUTO_GPT9_MASK |
+		OMAP3430_AUTO_GPT8_MASK |
+		OMAP3430_AUTO_GPT7_MASK |
+		OMAP3430_AUTO_GPT6_MASK |
+		OMAP3430_AUTO_GPT5_MASK |
+		OMAP3430_AUTO_GPT4_MASK |
+		OMAP3430_AUTO_GPT3_MASK |
+		OMAP3430_AUTO_GPT2_MASK |
+		OMAP3430_AUTO_MCBSP4_MASK |
+		OMAP3430_AUTO_MCBSP3_MASK |
+		OMAP3430_AUTO_MCBSP2_MASK,
 		OMAP3430_PER_MOD,
 		CM_AUTOIDLE);
 
 	if (omap_rev() > OMAP3430_REV_ES1_0) {
 		cm_write_mod_reg(
-			OMAP3430ES2_AUTO_USBHOST,
+			OMAP3430ES2_AUTO_USBHOST_MASK,
 			OMAP3430ES2_USBHOST_MOD,
 			CM_AUTOIDLE);
 	}
@@ -895,7 +897,7 @@ static void __init prcm_setup_regs(void)
 			     OMAP3_PRM_CLKSRC_CTRL_OFFSET);
 
 	/* setup wakup source */
-	prm_write_mod_reg(OMAP3430_EN_IO | OMAP3430_EN_GPIO1 |
+	prm_write_mod_reg(OMAP3430_EN_IO_MASK | OMAP3430_EN_GPIO1 |
 			  OMAP3430_EN_GPT1 | OMAP3430_EN_GPT12,
 			  WKUP_MOD, PM_WKEN);
 	/* No need to write EN_IO, that is always enabled */
@@ -904,11 +906,11 @@ static void __init prcm_setup_regs(void)
 			  WKUP_MOD, OMAP3430_PM_MPUGRPSEL);
 	/* For some reason IO doesn't generate wakeup event even if
 	 * it is selected to mpu wakeup goup */
-	prm_write_mod_reg(OMAP3430_IO_EN | OMAP3430_WKUP_EN,
+	prm_write_mod_reg(OMAP3430_IO_EN_MASK | OMAP3430_WKUP_EN_MASK,
 			  OCP_MOD, OMAP3_PRM_IRQENABLE_MPU_OFFSET);
 
 	/* Enable PM_WKEN to support DSS LPR */
-	prm_write_mod_reg(OMAP3430_PM_WKEN_DSS_EN_DSS,
+	prm_write_mod_reg(OMAP3430_PM_WKEN_DSS_EN_DSS_MASK,
 				OMAP3430_DSS_MOD, PM_WKEN);
 
 	/* Enable wakeups in PER */
@@ -919,9 +921,9 @@ static void __init prcm_setup_regs(void)
 			  OMAP3430_EN_MCBSP4,
 			  OMAP3430_PER_MOD, PM_WKEN);
 	/* and allow them to wake up MPU */
-	prm_write_mod_reg(OMAP3430_GRPSEL_GPIO2 | OMAP3430_EN_GPIO3 |
-			  OMAP3430_GRPSEL_GPIO4 | OMAP3430_EN_GPIO5 |
-			  OMAP3430_GRPSEL_GPIO6 | OMAP3430_EN_UART3 |
+	prm_write_mod_reg(OMAP3430_GRPSEL_GPIO2_MASK | OMAP3430_EN_GPIO3 |
+			  OMAP3430_GRPSEL_GPIO4_MASK | OMAP3430_EN_GPIO5 |
+			  OMAP3430_GRPSEL_GPIO6_MASK | OMAP3430_EN_UART3 |
 			  OMAP3430_EN_MCBSP2 | OMAP3430_EN_MCBSP3 |
 			  OMAP3430_EN_MCBSP4,
 			  OMAP3430_PER_MOD, OMAP3430_PM_MPUGRPSEL);

commit 5a5f561e4060844a37d8fe81dce2352c406aac97
Merge: 935d918046d4 331b9e3d61cb
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu May 20 11:11:44 2010 -0700

    Merge branch 'pm-next' of git://git.kernel.org/pub/scm/linux/kernel/git/khilman/linux-omap-pm into omap-for-linus

commit 43ffcd9a042858a9e9f9fe014bb073e55db34c67
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Tue Jan 27 11:09:24 2009 -0800

    OMAP2/3: GPIO: generalize prepare for idle
    
    Currently, the GPIO 'prepare' hook is only called when going to
    off-mode, while the function is called 'prepare_for_retention.'  This
    patch renames the function to 'prepare_for_idle' and calls it for any
    powersate != PWRDM_POWER_ON passing in the powerstate.
    
    The hook itself is then responsible for doing various preparation
    based on the powerstate.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 5de07db636bd..468e1e3321e0 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -376,15 +376,14 @@ void omap_sram_idle(void)
 	core_next_state = pwrdm_read_next_pwrst(core_pwrdm);
 	if (per_next_state < PWRDM_POWER_ON) {
 		omap_uart_prepare_idle(2);
+		omap2_gpio_prepare_for_idle(per_next_state);
 		if (per_next_state == PWRDM_POWER_OFF) {
 			if (core_next_state == PWRDM_POWER_ON) {
 				per_next_state = PWRDM_POWER_RET;
 				pwrdm_set_next_pwrst(per_pwrdm, per_next_state);
 				per_state_modified = 1;
-			} else {
-				omap2_gpio_prepare_for_retention();
+			} else
 				omap3_per_save_context();
-			}
 		}
 	}
 
@@ -455,10 +454,9 @@ void omap_sram_idle(void)
 	/* PER */
 	if (per_next_state < PWRDM_POWER_ON) {
 		per_prev_state = pwrdm_read_prev_pwrst(per_pwrdm);
-		if (per_prev_state == PWRDM_POWER_OFF) {
+		omap2_gpio_resume_after_idle();
+		if (per_prev_state == PWRDM_POWER_OFF)
 			omap3_per_restore_context();
-			omap2_gpio_resume_after_retention();
-		}
 		omap_uart_resume_idle(2);
 		if (per_state_modified)
 			pwrdm_set_next_pwrst(per_pwrdm, PWRDM_POWER_OFF);

commit a118b5f3391fc60e1619a79f8ceb070bb7b39b2d
Author: Tero Kristo <tero.kristo@nokia.com>
Date:   Mon Dec 22 14:27:12 2008 +0200

    OMAP3: GPIO fixes for off-mode
    
    Off mode is now using the omap2 retention fix code for scanning GPIOs
    during off-mode transitions. All the *non_wakeup_gpios variables
    are now used for off-mode transition tracking on OMAP3. This patch fixes
    cases where GPIO state changes are missed during off-mode.
    
    Signed-off-by: Tero Kristo <tero.kristo@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index ea0000bc5358..5de07db636bd 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -376,14 +376,15 @@ void omap_sram_idle(void)
 	core_next_state = pwrdm_read_next_pwrst(core_pwrdm);
 	if (per_next_state < PWRDM_POWER_ON) {
 		omap_uart_prepare_idle(2);
-		omap2_gpio_prepare_for_retention();
 		if (per_next_state == PWRDM_POWER_OFF) {
 			if (core_next_state == PWRDM_POWER_ON) {
 				per_next_state = PWRDM_POWER_RET;
 				pwrdm_set_next_pwrst(per_pwrdm, per_next_state);
 				per_state_modified = 1;
-			} else
+			} else {
+				omap2_gpio_prepare_for_retention();
 				omap3_per_save_context();
+			}
 		}
 	}
 
@@ -454,9 +455,10 @@ void omap_sram_idle(void)
 	/* PER */
 	if (per_next_state < PWRDM_POWER_ON) {
 		per_prev_state = pwrdm_read_prev_pwrst(per_pwrdm);
-		if (per_prev_state == PWRDM_POWER_OFF)
+		if (per_prev_state == PWRDM_POWER_OFF) {
 			omap3_per_restore_context();
-		omap2_gpio_resume_after_retention();
+			omap2_gpio_resume_after_retention();
+		}
 		omap_uart_resume_idle(2);
 		if (per_state_modified)
 			pwrdm_set_next_pwrst(per_pwrdm, PWRDM_POWER_OFF);

commit 331b9e3d61cba2ad089f3f1fe2ef0122679337a1
Author: Mike Chan <mike@android.com>
Date:   Mon May 3 16:04:07 2010 -0700

    OMAP3: PM: Remove PER wakeup dependency on CORE.
    
    We can remove this wakeup dependency since now, when
    GPIO2-6 are enabled for IO-pad wakeup, PER domain is gauranteed
    to be awake or be woken up to service.
    
    The previous dependency did not handle all corner cases. Since there
    was no sleep dependency between CORE and PER domains, if PER enters
    RET and CORE is ON, PER will not be active for GPIO handling.
    
    Signed-off-by: Mike Chan <mike@android.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index eec0916de819..1d7169855ac5 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -1096,14 +1096,6 @@ static int __init omap3_pm_init(void)
 	omap3_idle_init();
 
 	clkdm_add_wkdep(neon_clkdm, mpu_clkdm);
-	/*
-	 * REVISIT: This wkdep is only necessary when GPIO2-6 are enabled for
-	 * IO-pad wakeup.  Otherwise it will unnecessarily waste power
-	 * waking up PER with every CORE wakeup - see
-	 * http://marc.info/?l=linux-omap&m=121852150710062&w=2
-	*/
-	clkdm_add_wkdep(per_clkdm, core_clkdm);
-
 	if (omap_type() != OMAP2_DEVICE_TYPE_GP) {
 		omap3_secure_ram_storage =
 			kmalloc(0x803F, GFP_KERNEL);

commit 40742fa82ebf53c9367f5807cf1012d518516e74
Author: Mike Chan <mike@android.com>
Date:   Mon May 3 16:04:06 2010 -0700

    OMAP3: PM: Enable IO / IO-CHAIN wakeups for PER
    
    IO events can also come from GPIO modules, which reside in the PER domain.
    It is possible for the PER to enter RET while CORE is still in ON.
    If GPIO 2-6 are enabled for IO-pad wakeups, the PER domain will not
    wakeup in this case, unless we enable it.
    
    Signed-off-by: Mike Chan <mike@android.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index e76af5b532a0..eec0916de819 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -379,9 +379,16 @@ void omap_sram_idle(void)
 	if (pwrdm_read_pwrst(neon_pwrdm) == PWRDM_POWER_ON)
 		pwrdm_set_next_pwrst(neon_pwrdm, mpu_next_state);
 
-	/* PER */
+	/* Enable IO-PAD and IO-CHAIN wakeups */
 	per_next_state = pwrdm_read_next_pwrst(per_pwrdm);
 	core_next_state = pwrdm_read_next_pwrst(core_pwrdm);
+	if (per_next_state < PWRDM_POWER_ON ||
+			core_next_state < PWRDM_POWER_ON) {
+		prm_set_mod_reg_bits(OMAP3430_EN_IO, WKUP_MOD, PM_WKEN);
+		omap3_enable_io_chain();
+	}
+
+	/* PER */
 	if (per_next_state < PWRDM_POWER_ON) {
 		omap_uart_prepare_idle(2);
 		omap2_gpio_prepare_for_retention();
@@ -406,10 +413,8 @@ void omap_sram_idle(void)
 			omap3_core_save_context();
 			omap3_prcm_save_context();
 		}
-		/* Enable IO-PAD and IO-CHAIN wakeups */
-		prm_set_mod_reg_bits(OMAP3430_EN_IO, WKUP_MOD, PM_WKEN);
-		omap3_enable_io_chain();
 	}
+
 	omap3_intc_prepare_idle();
 
 	/*
@@ -471,7 +476,8 @@ void omap_sram_idle(void)
 	}
 
 	/* Disable IO-PAD and IO-CHAIN wakeup */
-	if (core_next_state < PWRDM_POWER_ON) {
+	if (per_next_state < PWRDM_POWER_ON ||
+			core_next_state < PWRDM_POWER_ON) {
 		prm_clear_mod_reg_bits(OMAP3430_EN_IO, WKUP_MOD, PM_WKEN);
 		omap3_disable_io_chain();
 	}

commit 8e2efde9f1ba2fb918245f9419246e4e59b42a11
Author: Ari Kauppi <Ext-Ari.Kauppi@nokia.com>
Date:   Tue Mar 23 09:04:59 2010 +0200

    OMAP3: PM: Add milliseconds interface to suspend wakeup timer
    
    Millisecond resolution is possible and there are use cases for it
    (automatic testing).
    
    Seconds-based interface is preserved for compatibility.
    
    Signed-off-by: Ari Kauppi <Ext-Ari.Kauppi@nokia.com>
    Reviewed-by: Phil Carmody <ext-phil.2.carmody@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index a15aa92d384e..e76af5b532a0 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -58,6 +58,7 @@
 u32 enable_off_mode;
 u32 sleep_while_idle;
 u32 wakeup_timer_seconds;
+u32 wakeup_timer_milliseconds;
 
 struct power_state {
 	struct powerdomain *pwrdm;
@@ -555,20 +556,21 @@ static void omap3_pm_idle(void)
 #ifdef CONFIG_SUSPEND
 static suspend_state_t suspend_state;
 
-static void omap2_pm_wakeup_on_timer(u32 seconds)
+static void omap2_pm_wakeup_on_timer(u32 seconds, u32 milliseconds)
 {
 	u32 tick_rate, cycles;
 
-	if (!seconds)
+	if (!seconds && !milliseconds)
 		return;
 
 	tick_rate = clk_get_rate(omap_dm_timer_get_fclk(gptimer_wakeup));
-	cycles = tick_rate * seconds;
+	cycles = tick_rate * seconds + tick_rate * milliseconds / 1000;
 	omap_dm_timer_stop(gptimer_wakeup);
 	omap_dm_timer_set_load_start(gptimer_wakeup, 0, 0xffffffff - cycles);
 
-	pr_info("PM: Resume timer in %d secs (%d ticks at %d ticks/sec.)\n",
-		seconds, cycles, tick_rate);
+	pr_info("PM: Resume timer in %u.%03u secs"
+		" (%d ticks at %d ticks/sec.)\n",
+		seconds, milliseconds, cycles, tick_rate);
 }
 
 static int omap3_pm_prepare(void)
@@ -582,8 +584,9 @@ static int omap3_pm_suspend(void)
 	struct power_state *pwrst;
 	int state, ret = 0;
 
-	if (wakeup_timer_seconds)
-		omap2_pm_wakeup_on_timer(wakeup_timer_seconds);
+	if (wakeup_timer_seconds || wakeup_timer_milliseconds)
+		omap2_pm_wakeup_on_timer(wakeup_timer_seconds,
+					 wakeup_timer_milliseconds);
 
 	/* Read current next_pwrsts */
 	list_for_each_entry(pwrst, &pwrst_list, node)

commit d6290a3ead555c0b092d48288b4dc0566580e17f
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Mon Apr 26 14:59:09 2010 -0700

    OMAP3: PRCM interrupt: only check and clear enabled PRCM IRQs
    
    While handling PRCM IRQs, mask out interrupts that are not enabled in
    PRM_IRQENABLE_MPU.  If these are not masked out, non-enabled
    interrupts are caught, a WARN() is printed due to no 'handler' and the
    events are cleared.  In addition to being noisy, this can also
    interfere with independent polling of this register by SR/VP code.
    
    This was noticed using SmartReflex transitions which cause the VPx_*
    interrupts to be handled since they are set in PRM_IRQSTATUS_MPU even
    but not enabled in PRM_IRQENABLE_MPU.
    
    Acked-by: Mike Turquette <mturquette@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index ea0000bc5358..a15aa92d384e 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -267,13 +267,16 @@ static int _prcm_int_handle_wakeup(void)
  */
 static irqreturn_t prcm_interrupt_handler (int irq, void *dev_id)
 {
-	u32 irqstatus_mpu;
+	u32 irqenable_mpu, irqstatus_mpu;
 	int c = 0;
 
-	do {
-		irqstatus_mpu = prm_read_mod_reg(OCP_MOD,
-					OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
+	irqenable_mpu = prm_read_mod_reg(OCP_MOD,
+					 OMAP3_PRM_IRQENABLE_MPU_OFFSET);
+	irqstatus_mpu = prm_read_mod_reg(OCP_MOD,
+					 OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
+	irqstatus_mpu &= irqenable_mpu;
 
+	do {
 		if (irqstatus_mpu & (OMAP3430_WKUP_ST | OMAP3430_IO_ST)) {
 			c = _prcm_int_handle_wakeup();
 
@@ -292,7 +295,11 @@ static irqreturn_t prcm_interrupt_handler (int irq, void *dev_id)
 		prm_write_mod_reg(irqstatus_mpu, OCP_MOD,
 					OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
 
-	} while (prm_read_mod_reg(OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET));
+		irqstatus_mpu = prm_read_mod_reg(OCP_MOD,
+					OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
+		irqstatus_mpu &= irqenable_mpu;
+
+	} while (irqstatus_mpu);
 
 	return IRQ_HANDLED;
 }

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index fee2efb172e7..ea0000bc5358 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -27,6 +27,7 @@
 #include <linux/gpio.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
+#include <linux/slab.h>
 
 #include <plat/sram.h>
 #include <plat/clockdomain.h>

commit b610ec502376d915b76a62e22576c5d0462cc9c9
Merge: 0fdc54b20197 ad001f145dcf
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Feb 24 20:53:03 2010 -0800

    Merge branch 'for_2.6.34_b' of git://git.pwsan.com/linux-2.6 into omap-for-linus

commit dfa6d6f892bef0afa2a39d27e4bd1763b972d206
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Wed Feb 24 12:05:48 2010 -0700

    OMAP3: clock: use std _MASK suffix for CM_FCLKEN_IVA2 defines
    
    Add _MASK suffix to CM_FCLKEN_IVA2 bitfieds to conform with the rest
    of the usage in cm-regbits-34xx.h of using _SHIFT and _MASK suffixes.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 5087b153b093..62e27aaf9fd6 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -688,7 +688,7 @@ static void __init omap3_iva_idle(void)
 			  OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);
 
 	/* Enable IVA2 clock */
-	cm_write_mod_reg(OMAP3430_CM_FCLKEN_IVA2_EN_IVA2,
+	cm_write_mod_reg(OMAP3430_CM_FCLKEN_IVA2_EN_IVA2_MASK,
 			 OMAP3430_IVA2_MOD, CM_FCLKEN);
 
 	/* Set IVA2 boot mode to 'idle' */

commit 6af83b38613da58a221e56af676097575ce2c763
Author: Sanjeev Premi <premi@ti.com>
Date:   Thu Jan 28 23:16:43 2010 +0530

    OMAP3: cpuidle: Update statistics for correct state
    
    When 'enable_off_mode' is 0, the target power state for MPU
    and CORE was locally changed to PWRDM_POWER_RET but, the
    statistics are updated for idle state originally selected
    by the governor.
    
    This patch 'invalidates' the idle states that lead either of
    MPU or Core to PWRDM_POWER_OFF state when 'enable_off_mode'
    is '0'. The states are valid once 'enable_off_mode' is set
    to '1'.
    
    Added function next_valid_state() to check if current state
    is valid; else get the next valid state. It is called from
    omap3_enter_idle_bm().
    
    Signed-off-by: Sanjeev Premi <premi@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 5087b153b093..5320229926e4 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -941,6 +941,10 @@ void omap3_pm_off_mode_enable(int enable)
 	else
 		state = PWRDM_POWER_RET;
 
+#ifdef CONFIG_CPU_IDLE
+	omap3_cpuidle_update_states();
+#endif
+
 	list_for_each_entry(pwrst, &pwrst_list, node) {
 		pwrst->next_state = state;
 		set_pwrdm_state(pwrst->pwrdm, state);

commit 369d5614457384edcf62c5f39b03dd20be6ea1df
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Jan 26 20:13:01 2010 -0700

    OMAP clockdomains: add usecounting for wakeup and sleep dependencies
    
    Add usecounting for wakeup and sleep dependencies.  In the current
    situation, if several functions add dependencies on the same
    clockdomains, when the first dependency removal function is called,
    the dependency will be incorrectly removed from the hardware.
    
    Add clkdm_clear_all_wkdeps() and clkdm_clear_all_sleepdeps(), which
    provide a fast and usecounting-consistent way to clear all hardware
    clockdomain dependencies, since accesses to these registers can be
    quite slow.  pm{2,3}4xx.c has been updated to use these new functions.
    The original version of this patch did not touch these files, which
    previously wrote directly to the wkdep registers, and thus confused
    the usecounting code.  This problem was found by Kevin Hilman
    <khilman@deeprootsystems.com>.
    
    N.B.: This patch introduces one significant functional difference over
    the previous pm34xx.c code: sleepdeps are now cleared during
    clockdomain initialization, whereas previously they were left
    untouched.  This has been tested by Kevin and confirmed to work.
    
    The original version of this patch also did not take into
    consideration that some clockdomains do not have sleep or wakeup
    dependency sources, which caused NULL pointer dereferences.  This
    problem was debugged and fixed by Kevin Hilman
    <khilman@deeprootsystems.com>.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Jouni Hgander <jouni.hogander@nokia.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 5f59df87abf7..5087b153b093 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -998,6 +998,9 @@ static int __init pwrdms_setup(struct powerdomain *pwrdm, void *unused)
  */
 static int __init clkdms_setup(struct clockdomain *clkdm, void *unused)
 {
+	clkdm_clear_all_wkdeps(clkdm);
+	clkdm_clear_all_sleepdeps(clkdm);
+
 	if (clkdm->flags & CLKDM_CAN_ENABLE_AUTO)
 		omap2_clkdm_allow_idle(clkdm);
 	else if (clkdm->flags & CLKDM_CAN_FORCE_SLEEP &&

commit 55ed96945b1f3d0f4ad21a27b32ce4bd99d8c268
Author: Paul Walmsley <paul@pwsan.com>
Date:   Tue Jan 26 20:12:59 2010 -0700

    OMAP2/3 clkdm/pwrdm: move wkdep/sleepdep handling from pwrdm to clkdm
    
    Move clockdomain wakeup dependency and sleep dependency data
    structures from the powerdomain layer to the clockdomain layer, where
    they belong.  These dependencies were originally placed in the
    powerdomain layer due to unclear documentation; however, it is clear
    now that these dependencies are between clockdomains.  For OMAP2/3,
    this is not such a big problem, but for OMAP4 this needs to be fixed.
    
    Thanks to Benot Cousson <b-cousson@ti.com> for his advice on this
    patch.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benot Cousson <b-cousson@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index f841a6e33611..5f59df87abf7 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -1018,6 +1018,7 @@ void omap_push_sram_idle(void)
 static int __init omap3_pm_init(void)
 {
 	struct power_state *pwrst, *tmp;
+	struct clockdomain *neon_clkdm, *per_clkdm, *mpu_clkdm, *core_clkdm;
 	int ret;
 
 	if (!cpu_is_omap34xx())
@@ -1057,6 +1058,11 @@ static int __init omap3_pm_init(void)
 	core_pwrdm = pwrdm_lookup("core_pwrdm");
 	cam_pwrdm = pwrdm_lookup("cam_pwrdm");
 
+	neon_clkdm = clkdm_lookup("neon_clkdm");
+	mpu_clkdm = clkdm_lookup("mpu_clkdm");
+	per_clkdm = clkdm_lookup("per_clkdm");
+	core_clkdm = clkdm_lookup("core_clkdm");
+
 	omap_push_sram_idle();
 #ifdef CONFIG_SUSPEND
 	suspend_set_ops(&omap_pm_ops);
@@ -1065,14 +1071,14 @@ static int __init omap3_pm_init(void)
 	pm_idle = omap3_pm_idle;
 	omap3_idle_init();
 
-	pwrdm_add_wkdep(neon_pwrdm, mpu_pwrdm);
+	clkdm_add_wkdep(neon_clkdm, mpu_clkdm);
 	/*
 	 * REVISIT: This wkdep is only necessary when GPIO2-6 are enabled for
 	 * IO-pad wakeup.  Otherwise it will unnecessarily waste power
 	 * waking up PER with every CORE wakeup - see
 	 * http://marc.info/?l=linux-omap&m=121852150710062&w=2
 	*/
-	pwrdm_add_wkdep(per_pwrdm, core_pwrdm);
+	clkdm_add_wkdep(per_clkdm, core_clkdm);
 
 	if (omap_type() != OMAP2_DEVICE_TYPE_GP) {
 		omap3_secure_ram_storage =

commit 3790300903e6a98ce5f5391f4d435959266f79e7
Author: Abhijit Pagare <abhijitpagare@ti.com>
Date:   Tue Jan 26 20:12:51 2010 -0700

    ARM: OMAP4: PM: OMAP4 Power Domain Porting Related Clean-up.
    
    Module offsets were same for OMAP2 and OMAP3 while they differ for OMAP4.
    Hence we need different macros for identifying platform specific offsets.
    
    Signed-off-by: Abhijit Pagare <abhijitpagare@ti.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Rajendra Nayak <rnayak@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 910a7acf542d..f841a6e33611 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -685,7 +685,7 @@ static void __init omap3_iva_idle(void)
 	prm_write_mod_reg(OMAP3430_RST1_IVA2 |
 			  OMAP3430_RST2_IVA2 |
 			  OMAP3430_RST3_IVA2,
-			  OMAP3430_IVA2_MOD, RM_RSTCTRL);
+			  OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);
 
 	/* Enable IVA2 clock */
 	cm_write_mod_reg(OMAP3430_CM_FCLKEN_IVA2_EN_IVA2,
@@ -696,7 +696,7 @@ static void __init omap3_iva_idle(void)
 			 OMAP343X_CONTROL_IVA2_BOOTMOD);
 
 	/* Un-reset IVA2 */
-	prm_write_mod_reg(0, OMAP3430_IVA2_MOD, RM_RSTCTRL);
+	prm_write_mod_reg(0, OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);
 
 	/* Disable IVA2 clock */
 	cm_write_mod_reg(0, OMAP3430_IVA2_MOD, CM_FCLKEN);
@@ -705,7 +705,7 @@ static void __init omap3_iva_idle(void)
 	prm_write_mod_reg(OMAP3430_RST1_IVA2 |
 			  OMAP3430_RST2_IVA2 |
 			  OMAP3430_RST3_IVA2,
-			  OMAP3430_IVA2_MOD, RM_RSTCTRL);
+			  OMAP3430_IVA2_MOD, OMAP2_RM_RSTCTRL);
 }
 
 static void __init omap3_d2d_idle(void)
@@ -728,8 +728,8 @@ static void __init omap3_d2d_idle(void)
 	/* reset modem */
 	prm_write_mod_reg(OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RSTPWRON |
 			  OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RST,
-			  CORE_MOD, RM_RSTCTRL);
-	prm_write_mod_reg(0, CORE_MOD, RM_RSTCTRL);
+			  CORE_MOD, OMAP2_RM_RSTCTRL);
+	prm_write_mod_reg(0, CORE_MOD, OMAP2_RM_RSTCTRL);
 }
 
 static void __init prcm_setup_regs(void)
@@ -916,13 +916,13 @@ static void __init prcm_setup_regs(void)
 	prm_write_mod_reg(0, OMAP3430_PER_MOD, OMAP3430_PM_IVAGRPSEL);
 
 	/* Clear any pending 'reset' flags */
-	prm_write_mod_reg(0xffffffff, MPU_MOD, RM_RSTST);
-	prm_write_mod_reg(0xffffffff, CORE_MOD, RM_RSTST);
-	prm_write_mod_reg(0xffffffff, OMAP3430_PER_MOD, RM_RSTST);
-	prm_write_mod_reg(0xffffffff, OMAP3430_EMU_MOD, RM_RSTST);
-	prm_write_mod_reg(0xffffffff, OMAP3430_NEON_MOD, RM_RSTST);
-	prm_write_mod_reg(0xffffffff, OMAP3430_DSS_MOD, RM_RSTST);
-	prm_write_mod_reg(0xffffffff, OMAP3430ES2_USBHOST_MOD, RM_RSTST);
+	prm_write_mod_reg(0xffffffff, MPU_MOD, OMAP2_RM_RSTST);
+	prm_write_mod_reg(0xffffffff, CORE_MOD, OMAP2_RM_RSTST);
+	prm_write_mod_reg(0xffffffff, OMAP3430_PER_MOD, OMAP2_RM_RSTST);
+	prm_write_mod_reg(0xffffffff, OMAP3430_EMU_MOD, OMAP2_RM_RSTST);
+	prm_write_mod_reg(0xffffffff, OMAP3430_NEON_MOD, OMAP2_RM_RSTST);
+	prm_write_mod_reg(0xffffffff, OMAP3430_DSS_MOD, OMAP2_RM_RSTST);
+	prm_write_mod_reg(0xffffffff, OMAP3430ES2_USBHOST_MOD, OMAP2_RM_RSTST);
 
 	/* Clear any pending PRCM interrupts */
 	prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);

commit b92c5721d28507738d294e9a582eb6232ec6abad
Author: Subramani Venkatesh <subramani.venkatesh@windriver.com>
Date:   Tue Dec 22 15:07:50 2009 +0530

    OMAP3: PM: DSS PM_WKEN to refill DMA
    
    Currently, DSS does not wakeup when there is a DMA request.  DSS wake
    up event must be enabled so that the DMA request to refill the FIFO
    will wake up the CORE domain.
    
    Signed-off-by: Subramani Venkatesh <subramani.venkatesh@windriver.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 31762ca9f117..910a7acf542d 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -890,6 +890,10 @@ static void __init prcm_setup_regs(void)
 	prm_write_mod_reg(OMAP3430_IO_EN | OMAP3430_WKUP_EN,
 			  OCP_MOD, OMAP3_PRM_IRQENABLE_MPU_OFFSET);
 
+	/* Enable PM_WKEN to support DSS LPR */
+	prm_write_mod_reg(OMAP3430_PM_WKEN_DSS_EN_DSS,
+				OMAP3430_DSS_MOD, PM_WKEN);
+
 	/* Enable wakeups in PER */
 	prm_write_mod_reg(OMAP3430_EN_GPIO2 | OMAP3430_EN_GPIO3 |
 			  OMAP3430_EN_GPIO4 | OMAP3430_EN_GPIO5 |

commit dccaad895094a699c37c065bff3fa9bb997daeb9
Author: Tero Kristo <tero.kristo@nokia.com>
Date:   Tue Nov 17 18:34:53 2009 +0200

    OMAP3: PM: Force write last pad config register into save area
    
    Due to OMAP3 erratas 1.157, 1.185 the save of the last pad register
    (ETK_D14 and ETK_D15) can fail sometimes when there is simultaneous
    OCP access to the SCM register area. Fixed by writing the last
    register to the save area.
    
    Also, optimized the delay loop for the HW save to include an udelay(1),
    which limits the number of unnecessary HW accesses to SCM register area
    during the save.
    
    Signed-off-by: Tero Kristo <tero.kristo@nokia.com>
    Acked-by: Nishanth Menon <nm@ti.com>
    Reviewed-by: Anand Gadiyar <gadiyar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 96075bf5e086..31762ca9f117 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -26,6 +26,7 @@
 #include <linux/err.h>
 #include <linux/gpio.h>
 #include <linux/clk.h>
+#include <linux/delay.h>
 
 #include <plat/sram.h>
 #include <plat/clockdomain.h>
@@ -126,7 +127,15 @@ static void omap3_core_save_context(void)
 	/* wait for the save to complete */
 	while (!(omap_ctrl_readl(OMAP343X_CONTROL_GENERAL_PURPOSE_STATUS)
 			& PADCONF_SAVE_DONE))
-		;
+		udelay(1);
+
+	/*
+	 * Force write last pad into memory, as this can fail in some
+	 * cases according to erratas 1.157, 1.185
+	 */
+	omap_ctrl_writel(omap_ctrl_readl(OMAP343X_PADCONF_ETK_D14),
+		OMAP343X_CONTROL_MEM_WKUP + 0x2a0);
+
 	/* Save the Interrupt controller context */
 	omap_intc_save_context();
 	/* Save the GPMC context */

commit e3d9329640e4b291cdd2c6d178774c28bba47d59
Author: Peter Ujfalusi <peter.ujfalusi@nokia.com>
Date:   Thu Nov 26 15:18:50 2009 +0200

    OMAP3: PM: Enable wake-up from McBSP2, 3 and 4 modules
    
    Wake-up from McBSP ports are needed, especially when the THRESHOLD
    dma mode is in use for audio playback.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index d6cab338cad1..96075bf5e086 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -884,12 +884,16 @@ static void __init prcm_setup_regs(void)
 	/* Enable wakeups in PER */
 	prm_write_mod_reg(OMAP3430_EN_GPIO2 | OMAP3430_EN_GPIO3 |
 			  OMAP3430_EN_GPIO4 | OMAP3430_EN_GPIO5 |
-			  OMAP3430_EN_GPIO6 | OMAP3430_EN_UART3,
+			  OMAP3430_EN_GPIO6 | OMAP3430_EN_UART3 |
+			  OMAP3430_EN_MCBSP2 | OMAP3430_EN_MCBSP3 |
+			  OMAP3430_EN_MCBSP4,
 			  OMAP3430_PER_MOD, PM_WKEN);
 	/* and allow them to wake up MPU */
 	prm_write_mod_reg(OMAP3430_GRPSEL_GPIO2 | OMAP3430_EN_GPIO3 |
 			  OMAP3430_GRPSEL_GPIO4 | OMAP3430_EN_GPIO5 |
-			  OMAP3430_GRPSEL_GPIO6 | OMAP3430_EN_UART3,
+			  OMAP3430_GRPSEL_GPIO6 | OMAP3430_EN_UART3 |
+			  OMAP3430_EN_MCBSP2 | OMAP3430_EN_MCBSP3 |
+			  OMAP3430_EN_MCBSP4,
 			  OMAP3430_PER_MOD, OMAP3430_PM_MPUGRPSEL);
 
 	/* Don't attach IVA interrupts */

commit a174e609b5b9b3bc1c5859402be8d8d88f6e098c
Author: Sanjeev Premi <premi@ti.com>
Date:   Mon Nov 2 20:23:38 2009 +0530

    OMAP3: PM: Remove duplicate code blocks
    
    This patch removes code blocks that are repeated
    in function prcm_setup_regs().
    
    Signed-off-by: Sanjeev Premi <premi@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index af83555795ff..d6cab338cad1 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -910,24 +910,6 @@ static void __init prcm_setup_regs(void)
 	/* Clear any pending PRCM interrupts */
 	prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
 
-	/* Don't attach IVA interrupts */
-	prm_write_mod_reg(0, WKUP_MOD, OMAP3430_PM_IVAGRPSEL);
-	prm_write_mod_reg(0, CORE_MOD, OMAP3430_PM_IVAGRPSEL1);
-	prm_write_mod_reg(0, CORE_MOD, OMAP3430ES2_PM_IVAGRPSEL3);
-	prm_write_mod_reg(0, OMAP3430_PER_MOD, OMAP3430_PM_IVAGRPSEL);
-
-	/* Clear any pending 'reset' flags */
-	prm_write_mod_reg(0xffffffff, MPU_MOD, RM_RSTST);
-	prm_write_mod_reg(0xffffffff, CORE_MOD, RM_RSTST);
-	prm_write_mod_reg(0xffffffff, OMAP3430_PER_MOD, RM_RSTST);
-	prm_write_mod_reg(0xffffffff, OMAP3430_EMU_MOD, RM_RSTST);
-	prm_write_mod_reg(0xffffffff, OMAP3430_NEON_MOD, RM_RSTST);
-	prm_write_mod_reg(0xffffffff, OMAP3430_DSS_MOD, RM_RSTST);
-	prm_write_mod_reg(0xffffffff, OMAP3430ES2_USBHOST_MOD, RM_RSTST);
-
-	/* Clear any pending PRCM interrupts */
-	prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
-
 	omap3_iva_idle();
 	omap3_d2d_idle();
 }

commit f18cc2ff5e18e8eb6df5284866331ef4a2db58d6
Author: Tero Kristo <tero.kristo@nokia.com>
Date:   Fri Oct 23 19:03:50 2009 +0300

    OMAP3: PM: Disable interrupt controller AUTOIDLE before WFI
    
    OMAP interrupt controller goes to unknown state when there is right
    combination of l3,l4 sleep/wake-up transitions, l4 autoidle in
    interrupt controller and some interrupt. When this happens, interrupts
    are not delivered to ARM anymore and ARM will remain in WFI (wait for
    interrupt) until interrupt controller is forced to wake-up
    (i.e. lauterbach).
    
    Signed-off-by: Tero Kristo <tero.kristo@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 8a148fbbab43..af83555795ff 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -392,6 +392,7 @@ void omap_sram_idle(void)
 		prm_set_mod_reg_bits(OMAP3430_EN_IO, WKUP_MOD, PM_WKEN);
 		omap3_enable_io_chain();
 	}
+	omap3_intc_prepare_idle();
 
 	/*
 	* On EMU/HS devices ROM code restores a SRDC value
@@ -438,6 +439,7 @@ void omap_sram_idle(void)
 					       OMAP3430_GR_MOD,
 					       OMAP3_PRM_VOLTCTRL_OFFSET);
 	}
+	omap3_intc_resume_idle();
 
 	/* PER */
 	if (per_next_state < PWRDM_POWER_ON) {

commit b296c8118b26a359b027b8c9bb9f5f41dc7693fa
Author: Tero Kristo <tero.kristo@nokia.com>
Date:   Fri Oct 23 19:03:49 2009 +0300

    OMAP3: PM: Enable system control module autoidle
    
    Enable the auto-idle feature of the SCM block to save some additional
    power.
    
    Signed-off-by: Mika Westerberg <ext-mika.1.westerberg@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index b26418d55076..8a148fbbab43 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -837,6 +837,8 @@ static void __init prcm_setup_regs(void)
 			CM_AUTOIDLE);
 	}
 
+	omap_ctrl_writel(OMAP3430_AUTOIDLE, OMAP2_CONTROL_SYSCONFIG);
+
 	/*
 	 * Set all plls to autoidle. This is needed until autoidle is
 	 * enabled by clockfw

commit 2bbe3af3f1e1c1d0992c984e05d061ef5469edb4
Author: Tero Kristo <tero.kristo@nokia.com>
Date:   Fri Oct 23 19:03:48 2009 +0300

    OMAP3: PM: Ack pending interrupts before entering suspend
    
    Suspending drivers may still generate interrupts just before their suspend is
    completed. Any pending interrupts here will prevent sleep.
    
    Signed-off-by: Tero Kristo <tero.kristo@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index c6cc809afb79..b26418d55076 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -578,6 +578,8 @@ static int omap3_pm_suspend(void)
 	}
 
 	omap_uart_prepare_suspend();
+	omap3_intc_suspend();
+
 	omap_sram_idle();
 
 restore:

commit 1b6e821f234f9e22ad1ef4919e140625af251935
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Fri Jan 8 10:29:07 2010 -0800

    omap3: add missing parentheses
    
    `!' has a higher precedence than `&' so parentheses are required.
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 81ed252a0f8a..c6cc809afb79 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -124,8 +124,8 @@ static void omap3_core_save_context(void)
 	control_padconf_off |= START_PADCONF_SAVE;
 	omap_ctrl_writel(control_padconf_off, OMAP343X_CONTROL_PADCONF_OFF);
 	/* wait for the save to complete */
-	while (!omap_ctrl_readl(OMAP343X_CONTROL_GENERAL_PURPOSE_STATUS)
-			& PADCONF_SAVE_DONE)
+	while (!(omap_ctrl_readl(OMAP343X_CONTROL_GENERAL_PURPOSE_STATUS)
+			& PADCONF_SAVE_DONE))
 		;
 	/* Save the Interrupt controller context */
 	omap_intc_save_context();

commit cf22854cee10e16e28b1dde136c37e82b7d503ee
Author: Tero Kristo <tero.kristo@nokia.com>
Date:   Fri Mar 20 15:21:02 2009 +0200

    OMAP3: PM: Added resched check into idle calls
    
    Fixes a bug where scheduling is delayed until next wakeup due to race
    condition (e.g. interrupt requests scheduling just before omap_sram_idle
    is entered.)
    
    Signed-off-by: Tero Kristo <tero.kristo@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 4e87b61ca040..81ed252a0f8a 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -523,7 +523,7 @@ static void omap3_pm_idle(void)
 	if (!omap3_can_sleep())
 		goto out;
 
-	if (omap_irq_pending())
+	if (omap_irq_pending() || need_resched())
 		goto out;
 
 	omap_sram_idle();

commit da869621c3cd93d5a8361f243b50e5d48d12bd14
Author: Peter 'p2' De Schrijver <peter.de-schrijver@nokia.com>
Date:   Tue Mar 10 18:05:19 2009 +0200

    OMAP3: PM: idle: Remove fclk check for idle loop
    
    This patch removes the check to see if some functional clocks are
    still enabled before entering sleep.  This is no longer needed when
    using safe state (C1) that keeps CORE active.
    
    Signed-off-by: Peter 'p2' De Schrijver <peter.de-schrijver@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index c77f6db8a63d..4e87b61ca040 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -461,54 +461,12 @@ void omap_sram_idle(void)
 	omap2_clkdm_allow_idle(mpu_pwrdm->pwrdm_clkdms[0]);
 }
 
-/*
- * Check if functional clocks are enabled before entering
- * sleep. This function could be behind CONFIG_PM_DEBUG
- * when all drivers are configuring their sysconfig registers
- * properly and using their clocks properly.
- */
-static int omap3_fclks_active(void)
-{
-	u32 fck_core1 = 0, fck_core3 = 0, fck_sgx = 0, fck_dss = 0,
-		fck_cam = 0, fck_per = 0, fck_usbhost = 0;
-
-	fck_core1 = cm_read_mod_reg(CORE_MOD,
-				    CM_FCLKEN1);
-	if (omap_rev() > OMAP3430_REV_ES1_0) {
-		fck_core3 = cm_read_mod_reg(CORE_MOD,
-					    OMAP3430ES2_CM_FCLKEN3);
-		fck_sgx = cm_read_mod_reg(OMAP3430ES2_SGX_MOD,
-					  CM_FCLKEN);
-		fck_usbhost = cm_read_mod_reg(OMAP3430ES2_USBHOST_MOD,
-					      CM_FCLKEN);
-	} else
-		fck_sgx = cm_read_mod_reg(GFX_MOD,
-					  OMAP3430ES2_CM_FCLKEN3);
-	fck_dss = cm_read_mod_reg(OMAP3430_DSS_MOD,
-				  CM_FCLKEN);
-	fck_cam = cm_read_mod_reg(OMAP3430_CAM_MOD,
-				  CM_FCLKEN);
-	fck_per = cm_read_mod_reg(OMAP3430_PER_MOD,
-				  CM_FCLKEN);
-
-	/* Ignore UART clocks.  These are handled by UART core (serial.c) */
-	fck_core1 &= ~(OMAP3430_EN_UART1 | OMAP3430_EN_UART2);
-	fck_per &= ~OMAP3430_EN_UART3;
-
-	if (fck_core1 | fck_core3 | fck_sgx | fck_dss |
-	    fck_cam | fck_per | fck_usbhost)
-		return 1;
-	return 0;
-}
-
 int omap3_can_sleep(void)
 {
 	if (!sleep_while_idle)
 		return 0;
 	if (!omap_uart_can_sleep())
 		return 0;
-	if (omap3_fclks_active())
-		return 0;
 	return 1;
 }
 

commit 7139178e9baf44dab454b757ed91a9ee149ad0f2
Author: Jouni Hogander <jouni.hogander@nokia.com>
Date:   Tue Oct 28 10:59:05 2008 +0200

    OMAP3: PM: Use pwrdm_set_next_pwrst instead of set_pwrdm_state in idle loop
    
    It is more efficient to use pwrdm_set_next_pwrst for mpu, core and neon
    instead of set_pwrdm_state in idle loop. It is anyway known that those are
    active in idle loop. So no need to use set_pwrdm_state.
    
    Signed-off-by: Jouni Hogander <jouni.hogander@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 501b00100d59..c77f6db8a63d 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -359,7 +359,7 @@ void omap_sram_idle(void)
 
 	/* NEON control */
 	if (pwrdm_read_pwrst(neon_pwrdm) == PWRDM_POWER_ON)
-		set_pwrdm_state(neon_pwrdm, mpu_next_state);
+		pwrdm_set_next_pwrst(neon_pwrdm, mpu_next_state);
 
 	/* PER */
 	per_next_state = pwrdm_read_next_pwrst(per_pwrdm);

commit 0343371e22dcfec9291193ad3e771dbce3a93670
Author: Kalle Jokiniemi <ext-kalle.jokiniemi@nokia.com>
Date:   Fri Sep 26 11:04:20 2008 +0300

    OMAP3: PM: CPUidle: fix init sequencing
    
    Previously omap3_idle_init() was called in device_init, while
    omap_pm_init() is called at late_initcall. This causes the cpu idle
    driver to call omap_sram_idle before it is properly initialized. This
    patch fixes the issue by moving omap3_idle_init into omap3_pm_init.
    
    Signed-off-by: Kalle Jokiniemi <ext-kalle.jokiniemi@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 69c47edcc0f2..501b00100d59 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -1099,9 +1099,8 @@ static int __init omap3_pm_init(void)
 	suspend_set_ops(&omap_pm_ops);
 #endif /* CONFIG_SUSPEND */
 
-#ifndef CONFIG_CPU_IDLE
 	pm_idle = omap3_pm_idle;
-#endif
+	omap3_idle_init();
 
 	pwrdm_add_wkdep(neon_pwrdm, mpu_pwrdm);
 	/*

commit 20b01669885483ba2102d5a71c662bb6ae1bed0b
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Wed Oct 8 17:31:22 2008 +0530

    OMAP3: PM: CPUidle: support retention and off-mode C-states
    
    This patch adds support and enables state C4(MPU RET + CORE RET)
    and MPU OFF states (C3 and C5.)
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 0c49db8afa99..69c47edcc0f2 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -76,8 +76,6 @@ static struct powerdomain *mpu_pwrdm, *neon_pwrdm;
 static struct powerdomain *core_pwrdm, *per_pwrdm;
 static struct powerdomain *cam_pwrdm;
 
-static int set_pwrdm_state(struct powerdomain *pwrdm, u32 state);
-
 static inline void omap3_per_save_context(void)
 {
 	omap_gpio_save_context();
@@ -503,7 +501,7 @@ static int omap3_fclks_active(void)
 	return 0;
 }
 
-static int omap3_can_sleep(void)
+int omap3_can_sleep(void)
 {
 	if (!sleep_while_idle)
 		return 0;
@@ -517,7 +515,7 @@ static int omap3_can_sleep(void)
 /* This sets pwrdm state (other than mpu & core. Currently only ON &
  * RET are supported. Function is assuming that clkdm doesn't have
  * hw_sup mode enabled. */
-static int set_pwrdm_state(struct powerdomain *pwrdm, u32 state)
+int set_pwrdm_state(struct powerdomain *pwrdm, u32 state)
 {
 	u32 cur_state;
 	int sleep_switch = 0;

commit 99e6a4d22f7c7bda0cd8978333c2e85fba02f181
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Wed Oct 8 17:30:58 2008 +0530

    OMAP3: PM: CPUidle: base driver and support for C1-C2
    
    Basic CPUidle driver for OMAP3 with deepest sleep state supported
    being MPU CSWR.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 01b95eaae75a..0c49db8afa99 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -318,7 +318,7 @@ static void restore_table_entry(void)
 	restore_control_register(control_reg_value);
 }
 
-static void omap_sram_idle(void)
+void omap_sram_idle(void)
 {
 	/* Variable to tell what needs to be saved and restored
 	 * in omap_sram_idle*/
@@ -1101,7 +1101,9 @@ static int __init omap3_pm_init(void)
 	suspend_set_ops(&omap_pm_ops);
 #endif /* CONFIG_SUSPEND */
 
+#ifndef CONFIG_CPU_IDLE
 	pm_idle = omap3_pm_idle;
+#endif
 
 	pwrdm_add_wkdep(neon_pwrdm, mpu_pwrdm);
 	/*

commit f265dc4c5d39f2bd369d97c87a7bd89061b159d4
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Tue Jun 9 22:30:41 2009 +0530

    OMAP3: PM: Program SDRC to send self refresh on timeout of AUTO_CNT
    
    Due to an OMAP3 errata (1.142), on HS/EMU devices SDRC should be
    programed to issue automatic self refresh on timeout
    of AUTO_CNT = 1 prior to any transition to OFF mode.
    This is needed only on sil rev's ES3.0 and above.
    
    This patch enables the above needed WA in the SDRC power register
    value stored in scratchpad, so that ROM code restores this value
    in SDRC POWER on the wakeup path.
    The original SDRC POWER register value is stored and restored back
    in omap_sram_idle() function.
    
    This fixes some random crashes observed while stressing suspend
    on HS/EMU devices.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Kalle Jokiniemi <kalle.jokiniemi@digia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 511a57dc7015..01b95eaae75a 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -48,12 +48,6 @@
 #include "pm.h"
 #include "sdrc.h"
 
-#define SDRC_POWER_AUTOCOUNT_SHIFT 8
-#define SDRC_POWER_AUTOCOUNT_MASK (0xffff << SDRC_POWER_AUTOCOUNT_SHIFT)
-#define SDRC_POWER_CLKCTRL_SHIFT 4
-#define SDRC_POWER_CLKCTRL_MASK (0x3 << SDRC_POWER_CLKCTRL_SHIFT)
-#define SDRC_SELF_REFRESH_ON_AUTOCOUNT (0x2 << SDRC_POWER_CLKCTRL_SHIFT)
-
 /* Scratchpad offsets */
 #define OMAP343X_TABLE_ADDRESS_OFFSET	   0x31
 #define OMAP343X_TABLE_VALUE_OFFSET	   0x30
@@ -402,19 +396,15 @@ static void omap_sram_idle(void)
 	}
 
 	/*
-	 * Force SDRAM controller to self-refresh mode after timeout on
-	 * autocount. This is needed on ES3.0 to avoid SDRAM controller
-	 * hang-ups.
-	 */
+	* On EMU/HS devices ROM code restores a SRDC value
+	* from scratchpad which has automatic self refresh on timeout
+	* of AUTO_CNT = 1 enabled. This takes care of errata 1.142.
+	* Hence store/restore the SDRC_POWER register here.
+	*/
 	if (omap_rev() >= OMAP3430_REV_ES3_0 &&
 	    omap_type() != OMAP2_DEVICE_TYPE_GP &&
-	    core_next_state == PWRDM_POWER_OFF) {
+	    core_next_state == PWRDM_POWER_OFF)
 		sdrc_pwr = sdrc_read_reg(SDRC_POWER);
-		sdrc_write_reg((sdrc_pwr &
-			~(SDRC_POWER_AUTOCOUNT_MASK|SDRC_POWER_CLKCTRL_MASK)) |
-			(1 << SDRC_POWER_AUTOCOUNT_SHIFT) |
-			SDRC_SELF_REFRESH_ON_AUTOCOUNT, SDRC_POWER);
-	}
 
 	/*
 	 * omap3_arm_context is the location where ARM registers
@@ -424,7 +414,7 @@ static void omap_sram_idle(void)
 	_omap_sram_idle(omap3_arm_context, save_state);
 	cpu_init();
 
-	/* Restore normal SDRAM settings */
+	/* Restore normal SDRC POWER settings */
 	if (omap_rev() >= OMAP3430_REV_ES3_0 &&
 	    omap_type() != OMAP2_DEVICE_TYPE_GP &&
 	    core_next_state == PWRDM_POWER_OFF)

commit 3a7ec26bb44988051d97479f6dfcfd4942a99049
Author: Kalle Jokiniemi <kalle.jokiniemi@digia.com>
Date:   Thu Mar 26 15:59:01 2009 +0200

    OMAP3: PM: Enable IO-CHAIN wakeup
    
    OMAP 3430 ES3.1 chips have a separate bit for IO daisy-chain
    wake up enabling. It needs to be enabled when entering
    retention or off state, otherwise waking up might not work
    in all situations.
    
    Signed-off-by: Kalle Jokiniemi <kalle.jokiniemi@digia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 7623edabc419..511a57dc7015 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -94,6 +94,35 @@ static inline void omap3_per_restore_context(void)
 	omap_gpio_restore_context();
 }
 
+static void omap3_enable_io_chain(void)
+{
+	int timeout = 0;
+
+	if (omap_rev() >= OMAP3430_REV_ES3_1) {
+		prm_set_mod_reg_bits(OMAP3430_EN_IO_CHAIN, WKUP_MOD, PM_WKEN);
+		/* Do a readback to assure write has been done */
+		prm_read_mod_reg(WKUP_MOD, PM_WKEN);
+
+		while (!(prm_read_mod_reg(WKUP_MOD, PM_WKST) &
+			 OMAP3430_ST_IO_CHAIN)) {
+			timeout++;
+			if (timeout > 1000) {
+				printk(KERN_ERR "Wake up daisy chain "
+				       "activation failed.\n");
+				return;
+			}
+			prm_set_mod_reg_bits(OMAP3430_ST_IO_CHAIN,
+					     WKUP_MOD, PM_WKST);
+		}
+	}
+}
+
+static void omap3_disable_io_chain(void)
+{
+	if (omap_rev() >= OMAP3430_REV_ES3_1)
+		prm_clear_mod_reg_bits(OMAP3430_EN_IO_CHAIN, WKUP_MOD, PM_WKEN);
+}
+
 static void omap3_core_save_context(void)
 {
 	u32 control_padconf_off;
@@ -367,8 +396,9 @@ static void omap_sram_idle(void)
 			omap3_core_save_context();
 			omap3_prcm_save_context();
 		}
-		/* Enable IO-PAD wakeup */
+		/* Enable IO-PAD and IO-CHAIN wakeups */
 		prm_set_mod_reg_bits(OMAP3430_EN_IO, WKUP_MOD, PM_WKEN);
+		omap3_enable_io_chain();
 	}
 
 	/*
@@ -432,9 +462,11 @@ static void omap_sram_idle(void)
 			pwrdm_set_next_pwrst(per_pwrdm, PWRDM_POWER_OFF);
 	}
 
-	/* Disable IO-PAD wakeup */
-	if (core_next_state < PWRDM_POWER_ON)
+	/* Disable IO-PAD and IO-CHAIN wakeup */
+	if (core_next_state < PWRDM_POWER_ON) {
 		prm_clear_mod_reg_bits(OMAP3430_EN_IO, WKUP_MOD, PM_WKEN);
+		omap3_disable_io_chain();
+	}
 
 	pwrdm_post_transition();
 

commit c16c3f672defb7aca1276065375fe1ee5ca003dc
Author: Tero Kristo <tero.kristo@nokia.com>
Date:   Thu Dec 11 16:46:57 2008 +0200

    OMAP3: PM: MPU and CORE should stay awake if there is CAM domain ACTIVE
    
    MPU and CORE should stay awake if there is CAM domain ACTIVE. This is
    because that module doesn't have wake-up capability.
    
    This should replace the patch that is currently in the PM branch.
    
    Signed-off-by: Jouni Hogander <jouni.hogander@nokia.com>
    Signed-off-by: Tero Kristo <tero.kristo@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 55567bf5ccbf..7623edabc419 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -80,6 +80,7 @@ static int (*_omap_save_secure_sram)(u32 *addr);
 
 static struct powerdomain *mpu_pwrdm, *neon_pwrdm;
 static struct powerdomain *core_pwrdm, *per_pwrdm;
+static struct powerdomain *cam_pwrdm;
 
 static int set_pwrdm_state(struct powerdomain *pwrdm, u32 state);
 
@@ -355,6 +356,9 @@ static void omap_sram_idle(void)
 		}
 	}
 
+	if (pwrdm_read_pwrst(cam_pwrdm) == PWRDM_POWER_ON)
+		omap2_clkdm_deny_idle(mpu_pwrdm->pwrdm_clkdms[0]);
+
 	/* CORE */
 	if (core_next_state < PWRDM_POWER_ON) {
 		omap_uart_prepare_idle(0);
@@ -434,6 +438,7 @@ static void omap_sram_idle(void)
 
 	pwrdm_post_transition();
 
+	omap2_clkdm_allow_idle(mpu_pwrdm->pwrdm_clkdms[0]);
 }
 
 /*
@@ -1067,6 +1072,7 @@ static int __init omap3_pm_init(void)
 	neon_pwrdm = pwrdm_lookup("neon_pwrdm");
 	per_pwrdm = pwrdm_lookup("per_pwrdm");
 	core_pwrdm = pwrdm_lookup("core_pwrdm");
+	cam_pwrdm = pwrdm_lookup("cam_pwrdm");
 
 	omap_push_sram_idle();
 #ifdef CONFIG_SUSPEND

commit ecf157d0b38953cdefa2c8fb7ccb5a62db242aef
Author: Tero Kristo <tero.kristo@nokia.com>
Date:   Mon Dec 1 13:17:29 2008 +0200

    OMAP3: PM: Prevent PER from going OFF when CORE is going INA
    
    OMAP3 can't generate wakeups in this state, thus it is not permitted.
    
    Signed-off-by: Tero Kristo <tero.kristo@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index d8a6e10ac315..55567bf5ccbf 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -308,6 +308,7 @@ static void omap_sram_idle(void)
 	int core_next_state = PWRDM_POWER_ON;
 	int core_prev_state, per_prev_state;
 	u32 sdrc_pwr = 0;
+	int per_state_modified = 0;
 
 	if (!_omap_sram_idle)
 		return;
@@ -340,15 +341,21 @@ static void omap_sram_idle(void)
 
 	/* PER */
 	per_next_state = pwrdm_read_next_pwrst(per_pwrdm);
+	core_next_state = pwrdm_read_next_pwrst(core_pwrdm);
 	if (per_next_state < PWRDM_POWER_ON) {
-		omap2_gpio_prepare_for_retention();
 		omap_uart_prepare_idle(2);
-		if (per_next_state == PWRDM_POWER_OFF)
-			omap3_per_save_context();
+		omap2_gpio_prepare_for_retention();
+		if (per_next_state == PWRDM_POWER_OFF) {
+			if (core_next_state == PWRDM_POWER_ON) {
+				per_next_state = PWRDM_POWER_RET;
+				pwrdm_set_next_pwrst(per_pwrdm, per_next_state);
+				per_state_modified = 1;
+			} else
+				omap3_per_save_context();
+		}
 	}
 
 	/* CORE */
-	core_next_state = pwrdm_read_next_pwrst(core_pwrdm);
 	if (core_next_state < PWRDM_POWER_ON) {
 		omap_uart_prepare_idle(0);
 		omap_uart_prepare_idle(1);
@@ -413,10 +420,12 @@ static void omap_sram_idle(void)
 	/* PER */
 	if (per_next_state < PWRDM_POWER_ON) {
 		per_prev_state = pwrdm_read_prev_pwrst(per_pwrdm);
-		omap_uart_resume_idle(2);
 		if (per_prev_state == PWRDM_POWER_OFF)
 			omap3_per_restore_context();
 		omap2_gpio_resume_after_retention();
+		omap_uart_resume_idle(2);
+		if (per_state_modified)
+			pwrdm_set_next_pwrst(per_pwrdm, PWRDM_POWER_OFF);
 	}
 
 	/* Disable IO-PAD wakeup */

commit 658ce97ef57f4c0737bfcb76050400b53389ed6b
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Tue Nov 4 20:50:52 2008 -0800

    OMAP3: PM: decouple PER and CORE context save and restore
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index ff818aaec6c5..d8a6e10ac315 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -338,19 +338,20 @@ static void omap_sram_idle(void)
 	if (pwrdm_read_pwrst(neon_pwrdm) == PWRDM_POWER_ON)
 		set_pwrdm_state(neon_pwrdm, mpu_next_state);
 
-	/* CORE & PER */
+	/* PER */
+	per_next_state = pwrdm_read_next_pwrst(per_pwrdm);
+	if (per_next_state < PWRDM_POWER_ON) {
+		omap2_gpio_prepare_for_retention();
+		omap_uart_prepare_idle(2);
+		if (per_next_state == PWRDM_POWER_OFF)
+			omap3_per_save_context();
+	}
+
+	/* CORE */
 	core_next_state = pwrdm_read_next_pwrst(core_pwrdm);
 	if (core_next_state < PWRDM_POWER_ON) {
-		omap2_gpio_prepare_for_retention();
 		omap_uart_prepare_idle(0);
 		omap_uart_prepare_idle(1);
-		/* PER changes only with core */
-		per_next_state = pwrdm_read_next_pwrst(per_pwrdm);
-		if (per_next_state < PWRDM_POWER_ON) {
-			omap_uart_prepare_idle(2);
-			if (per_next_state == PWRDM_POWER_OFF)
-				omap3_per_save_context();
-		}
 		if (core_next_state == PWRDM_POWER_OFF) {
 			omap3_core_save_context();
 			omap3_prcm_save_context();
@@ -392,14 +393,8 @@ static void omap_sram_idle(void)
 	if (pwrdm_read_prev_pwrst(mpu_pwrdm) == PWRDM_POWER_OFF)
 		restore_table_entry();
 
+	/* CORE */
 	if (core_next_state < PWRDM_POWER_ON) {
-		if (per_next_state < PWRDM_POWER_ON)
-			omap_uart_resume_idle(2);
-		omap_uart_resume_idle(1);
-		omap_uart_resume_idle(0);
-
-		/* Disable IO-PAD wakeup */
-		prm_clear_mod_reg_bits(OMAP3430_EN_IO, WKUP_MOD, PM_WKEN);
 		core_prev_state = pwrdm_read_prev_pwrst(core_pwrdm);
 		if (core_prev_state == PWRDM_POWER_OFF) {
 			omap3_core_restore_context();
@@ -407,15 +402,27 @@ static void omap_sram_idle(void)
 			omap3_sram_restore_context();
 			omap2_sms_restore_context();
 		}
-		if (per_next_state < PWRDM_POWER_ON) {
-			per_prev_state =
-				pwrdm_read_prev_pwrst(per_pwrdm);
-			if (per_prev_state == PWRDM_POWER_OFF)
-				omap3_per_restore_context();
-		}
+		omap_uart_resume_idle(0);
+		omap_uart_resume_idle(1);
+		if (core_next_state == PWRDM_POWER_OFF)
+			prm_clear_mod_reg_bits(OMAP3430_AUTO_OFF,
+					       OMAP3430_GR_MOD,
+					       OMAP3_PRM_VOLTCTRL_OFFSET);
+	}
+
+	/* PER */
+	if (per_next_state < PWRDM_POWER_ON) {
+		per_prev_state = pwrdm_read_prev_pwrst(per_pwrdm);
+		omap_uart_resume_idle(2);
+		if (per_prev_state == PWRDM_POWER_OFF)
+			omap3_per_restore_context();
 		omap2_gpio_resume_after_retention();
 	}
 
+	/* Disable IO-PAD wakeup */
+	if (core_next_state < PWRDM_POWER_ON)
+		prm_clear_mod_reg_bits(OMAP3430_EN_IO, WKUP_MOD, PM_WKEN);
+
 	pwrdm_post_transition();
 
 }

commit d7814e4df6e9c54680a30de3f439c66a2a55ce94
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Tue Oct 6 14:30:23 2009 -0700

    PM debug: allow configurable wakeup from suspend on OMAP GPtimer
    
    Using debugfs, export a configurable wakeup timer to be used to
    wakeup system from suspend.
    
    If a non-zero value is written to
    /debug/pm_debug/wakeup_timer_seconds, A timer wakeup event will wake
    the system and resume after the configured number of seconds.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index ade2e4a6bb7d..ff818aaec6c5 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -36,6 +36,7 @@
 #include <plat/prcm.h>
 #include <plat/gpmc.h>
 #include <plat/dma.h>
+#include <plat/dmtimer.h>
 
 #include <asm/tlbflush.h>
 
@@ -60,6 +61,7 @@
 
 u32 enable_off_mode;
 u32 sleep_while_idle;
+u32 wakeup_timer_seconds;
 
 struct power_state {
 	struct powerdomain *pwrdm;
@@ -535,6 +537,22 @@ static void omap3_pm_idle(void)
 #ifdef CONFIG_SUSPEND
 static suspend_state_t suspend_state;
 
+static void omap2_pm_wakeup_on_timer(u32 seconds)
+{
+	u32 tick_rate, cycles;
+
+	if (!seconds)
+		return;
+
+	tick_rate = clk_get_rate(omap_dm_timer_get_fclk(gptimer_wakeup));
+	cycles = tick_rate * seconds;
+	omap_dm_timer_stop(gptimer_wakeup);
+	omap_dm_timer_set_load_start(gptimer_wakeup, 0, 0xffffffff - cycles);
+
+	pr_info("PM: Resume timer in %d secs (%d ticks at %d ticks/sec.)\n",
+		seconds, cycles, tick_rate);
+}
+
 static int omap3_pm_prepare(void)
 {
 	disable_hlt();
@@ -546,6 +564,9 @@ static int omap3_pm_suspend(void)
 	struct power_state *pwrst;
 	int state, ret = 0;
 
+	if (wakeup_timer_seconds)
+		omap2_pm_wakeup_on_timer(wakeup_timer_seconds);
+
 	/* Read current next_pwrsts */
 	list_for_each_entry(pwrst, &pwrst_list, node)
 		pwrst->saved_state = pwrdm_read_next_pwrst(pwrst->pwrdm);

commit c40552bc82166adb21a1a7fcb1dc4e76352b1b79
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Tue Oct 6 14:25:09 2009 -0700

    OMAP3: PM debug: allow runtime toggle of PM features
    
    Allow enable/disable of low-power states during idle.  To
    enable low-power idle:
    
       echo 1 > /debug/pm_debug/sleep_while_idle
    
     to disable:
    
       echo 0 > /debug/pm_debug/sleep_while_idle
    
    Also allow enable/disable of OFF-mode.  To enable:
    
       echo 1 > /debug/pm_debug/enable_off_mode
    
     to disable:
    
       echo 0 > /debug/pm_debug/enable_off_mode
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 90d1dc5884ef..ade2e4a6bb7d 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -25,6 +25,7 @@
 #include <linux/list.h>
 #include <linux/err.h>
 #include <linux/gpio.h>
+#include <linux/clk.h>
 
 #include <plat/sram.h>
 #include <plat/clockdomain.h>
@@ -57,6 +58,9 @@
 #define OMAP343X_TABLE_VALUE_OFFSET	   0x30
 #define OMAP343X_CONTROL_REG_VALUE_OFFSET  0x32
 
+u32 enable_off_mode;
+u32 sleep_while_idle;
+
 struct power_state {
 	struct powerdomain *pwrdm;
 	u32 next_state;
@@ -456,6 +460,8 @@ static int omap3_fclks_active(void)
 
 static int omap3_can_sleep(void)
 {
+	if (!sleep_while_idle)
+		return 0;
 	if (!omap_uart_can_sleep())
 		return 0;
 	if (omap3_fclks_active())
@@ -900,6 +906,22 @@ static void __init prcm_setup_regs(void)
 	omap3_d2d_idle();
 }
 
+void omap3_pm_off_mode_enable(int enable)
+{
+	struct power_state *pwrst;
+	u32 state;
+
+	if (enable)
+		state = PWRDM_POWER_OFF;
+	else
+		state = PWRDM_POWER_RET;
+
+	list_for_each_entry(pwrst, &pwrst_list, node) {
+		pwrst->next_state = state;
+		set_pwrdm_state(pwrst->pwrdm, state);
+	}
+}
+
 int omap3_pm_get_suspend_state(struct powerdomain *pwrdm)
 {
 	struct power_state *pwrst;

commit 8a917d2fc80b7c45ce0146ff134168646274a9bd
Author: Kalle Jokiniemi <kalle.jokiniemi@digia.com>
Date:   Wed May 13 13:32:11 2009 +0300

    ARM: OMAP: SMS: save/restore of SMS_SYSCONFIG for off-mode
    
    The SMS_SYSCONFIG register gets reset in off mode, added a
    save/restore mechanism for that.
    
    Signed-off-by: Kalle Jokiniemi <kalle.jokiniemi@digia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index a9f4034aa70a..90d1dc5884ef 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -399,6 +399,7 @@ static void omap_sram_idle(void)
 			omap3_core_restore_context();
 			omap3_prcm_restore_context();
 			omap3_sram_restore_context();
+			omap2_sms_restore_context();
 		}
 		if (per_next_state < PWRDM_POWER_ON) {
 			per_prev_state =

commit ba50ea7eb9ce663511013b35608cf0753c9ab674
Author: Kalle Jokiniemi <kalle.jokiniemi@digia.com>
Date:   Thu Mar 26 15:59:00 2009 +0200

    OMAP3: PM: Fix secure SRAM context save/restore
    
    The secure sram context save uses dma channels 0 and 1.
    In order to avoid collision between kernel DMA transfers and
    ROM code dma transfers, we need to reserve DMA channels 0
    1 on high security devices.
    
    A bug in ROM code leaves dma irq status bits uncleared.
    Hence those irq status bits need to be cleared when restoring
    DMA context after off mode.
    
    There was also a faulty parameter given to PPA in the secure
    ram context save assembly code, which caused interrupts to
    be enabled during secure ram context save. This caused the
    save to fail sometimes, which resulted the saved context
    to be corrupted, but also left DMA channels in secure mode.
    The secure mode DMA channels caused "DMA secure error with
    device 0" errors to be displayed.
    
    Signed-off-by: Kalle Jokiniemi <kalle.jokiniemi@digia.com>
    Signed-off-by: Jouni Hogander <jouni.hogander@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 3f1f656348fc..a9f4034aa70a 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -130,9 +130,6 @@ static void omap3_save_secure_ram_context(u32 target_mpu_state)
 	u32 ret;
 
 	if (omap_type() != OMAP2_DEVICE_TYPE_GP) {
-		/* Disable dma irq before calling secure rom code API */
-		omap_dma_disable_irq(0);
-		omap_dma_disable_irq(1);
 		/*
 		 * MPU next state must be set to POWER_ON temporarily,
 		 * otherwise the WFI executed inside the ROM code

commit 13a6fe0f6adf62bf73be055322197507761d160a
Author: Tero Kristo <tero.kristo@nokia.com>
Date:   Mon Oct 13 13:17:06 2008 +0300

    OMAP3: PM: Enable SDRAM auto-refresh during sleep
    
    Fix for ES3.0 bug: SDRC not sending auto-refresh when OMAP wakes-up
    from OFF mode (warning for HS devices.)
    
    Signed-off-by: Tero Kristo <tero.kristo@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 310c189efb5d..3f1f656348fc 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -44,6 +44,13 @@
 
 #include "prm.h"
 #include "pm.h"
+#include "sdrc.h"
+
+#define SDRC_POWER_AUTOCOUNT_SHIFT 8
+#define SDRC_POWER_AUTOCOUNT_MASK (0xffff << SDRC_POWER_AUTOCOUNT_SHIFT)
+#define SDRC_POWER_CLKCTRL_SHIFT 4
+#define SDRC_POWER_CLKCTRL_MASK (0x3 << SDRC_POWER_CLKCTRL_SHIFT)
+#define SDRC_SELF_REFRESH_ON_AUTOCOUNT (0x2 << SDRC_POWER_CLKCTRL_SHIFT)
 
 /* Scratchpad offsets */
 #define OMAP343X_TABLE_ADDRESS_OFFSET	   0x31
@@ -297,6 +304,7 @@ static void omap_sram_idle(void)
 	int per_next_state = PWRDM_POWER_ON;
 	int core_next_state = PWRDM_POWER_ON;
 	int core_prev_state, per_prev_state;
+	u32 sdrc_pwr = 0;
 
 	if (!_omap_sram_idle)
 		return;
@@ -348,6 +356,21 @@ static void omap_sram_idle(void)
 		prm_set_mod_reg_bits(OMAP3430_EN_IO, WKUP_MOD, PM_WKEN);
 	}
 
+	/*
+	 * Force SDRAM controller to self-refresh mode after timeout on
+	 * autocount. This is needed on ES3.0 to avoid SDRAM controller
+	 * hang-ups.
+	 */
+	if (omap_rev() >= OMAP3430_REV_ES3_0 &&
+	    omap_type() != OMAP2_DEVICE_TYPE_GP &&
+	    core_next_state == PWRDM_POWER_OFF) {
+		sdrc_pwr = sdrc_read_reg(SDRC_POWER);
+		sdrc_write_reg((sdrc_pwr &
+			~(SDRC_POWER_AUTOCOUNT_MASK|SDRC_POWER_CLKCTRL_MASK)) |
+			(1 << SDRC_POWER_AUTOCOUNT_SHIFT) |
+			SDRC_SELF_REFRESH_ON_AUTOCOUNT, SDRC_POWER);
+	}
+
 	/*
 	 * omap3_arm_context is the location where ARM registers
 	 * get saved. The restore path then reads from this
@@ -356,6 +379,12 @@ static void omap_sram_idle(void)
 	_omap_sram_idle(omap3_arm_context, save_state);
 	cpu_init();
 
+	/* Restore normal SDRAM settings */
+	if (omap_rev() >= OMAP3430_REV_ES3_0 &&
+	    omap_type() != OMAP2_DEVICE_TYPE_GP &&
+	    core_next_state == PWRDM_POWER_OFF)
+		sdrc_write_reg(sdrc_pwr, SDRC_POWER);
+
 	/* Restore table entry modified during MMU restoration */
 	if (pwrdm_read_prev_pwrst(mpu_pwrdm) == PWRDM_POWER_OFF)
 		restore_table_entry();

commit 9d97140bd0c5da55f174a81dafd2bbef135f5748
Author: Tero Kristo <tero.kristo@nokia.com>
Date:   Fri Dec 12 11:20:05 2008 +0200

    OMAP3: PM: save secure RAM only during init
    
    The function omap3_save_secure_ram() is now called only once during
    the initialization of the device and consequent sleep cycles will
    re-use the same saved contents for secure RAM. Users who need secure
    services should do secure RAM saving before entering off-mode, if a
    secure service has been accessed after last save.
    
    There are both latency and reliability issues with saving secure RAM
    context in the idle path. The context save uses a hardware resource
    which takes an order of hundreds of milliseconds to initialize after a
    wake up from off-mode, and also there is no way of checking whether it
    is ready from kernel side or not. It just crashes if you use it too
    quickly
    
    Additional fix to ensure scratchpad save is done after secure
    RAM by Roger Quadros.
    
    Signed-off-by: Tero Kristo <tero.kristo@nokia.com>
    Signed-off-by: Roger Quadros <ext-roger.quadros@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index ebb88f3aae31..310c189efb5d 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -112,6 +112,12 @@ static void omap3_core_restore_context(void)
 	omap_dma_global_context_restore();
 }
 
+/*
+ * FIXME: This function should be called before entering off-mode after
+ * OMAP3 secure services have been accessed. Currently it is only called
+ * once during boot sequence, but this works as we are not using secure
+ * services.
+ */
 static void omap3_save_secure_ram_context(u32 target_mpu_state)
 {
 	u32 ret;
@@ -337,7 +343,6 @@ static void omap_sram_idle(void)
 		if (core_next_state == PWRDM_POWER_OFF) {
 			omap3_core_save_context();
 			omap3_prcm_save_context();
-			omap3_save_secure_ram_context(mpu_next_state);
 		}
 		/* Enable IO-PAD wakeup */
 		prm_set_mod_reg_bits(OMAP3430_EN_IO, WKUP_MOD, PM_WKEN);
@@ -999,9 +1004,19 @@ static int __init omap3_pm_init(void)
 		if (!omap3_secure_ram_storage)
 			printk(KERN_ERR "Memory allocation failed when"
 					"allocating for secure sram context\n");
+
+		local_irq_disable();
+		local_fiq_disable();
+
+		omap_dma_global_context_save();
+		omap3_save_secure_ram_context(PWRDM_POWER_ON);
+		omap_dma_global_context_restore();
+
+		local_irq_enable();
+		local_fiq_enable();
 	}
-	omap3_save_scratchpad_contents();
 
+	omap3_save_scratchpad_contents();
 err1:
 	return ret;
 err2:

commit 27d59a4a2def42307349079f2e3538d96934c379
Author: Tero Kristo <tero.kristo@nokia.com>
Date:   Mon Oct 13 13:15:00 2008 +0300

    OMAP3 PM: off-mode support for HS/EMU devices
    
    For HS/EMU devices, some additional resources need to be
    saved/restored for off-mode support.  Namely, saving the secure RAM
    and a pointer to it in the scratchpad.
    
    Signed-off-by: Tero Kristo <tero.kristo@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 54fea79b1720..ebb88f3aae31 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -63,6 +63,8 @@ static LIST_HEAD(pwrst_list);
 
 static void (*_omap_sram_idle)(u32 *addr, int save_state);
 
+static int (*_omap_save_secure_sram)(u32 *addr);
+
 static struct powerdomain *mpu_pwrdm, *neon_pwrdm;
 static struct powerdomain *core_pwrdm, *per_pwrdm;
 
@@ -110,6 +112,33 @@ static void omap3_core_restore_context(void)
 	omap_dma_global_context_restore();
 }
 
+static void omap3_save_secure_ram_context(u32 target_mpu_state)
+{
+	u32 ret;
+
+	if (omap_type() != OMAP2_DEVICE_TYPE_GP) {
+		/* Disable dma irq before calling secure rom code API */
+		omap_dma_disable_irq(0);
+		omap_dma_disable_irq(1);
+		/*
+		 * MPU next state must be set to POWER_ON temporarily,
+		 * otherwise the WFI executed inside the ROM code
+		 * will hang the system.
+		 */
+		pwrdm_set_next_pwrst(mpu_pwrdm, PWRDM_POWER_ON);
+		ret = _omap_save_secure_sram((u32 *)
+				__pa(omap3_secure_ram_storage));
+		pwrdm_set_next_pwrst(mpu_pwrdm, target_mpu_state);
+		/* Following is for error tracking, it should not happen */
+		if (ret) {
+			printk(KERN_ERR "save_secure_sram() returns %08x\n",
+				ret);
+			while (1)
+				;
+		}
+	}
+}
+
 /*
  * PRCM Interrupt Handler Helper Function
  *
@@ -308,6 +337,7 @@ static void omap_sram_idle(void)
 		if (core_next_state == PWRDM_POWER_OFF) {
 			omap3_core_save_context();
 			omap3_prcm_save_context();
+			omap3_save_secure_ram_context(mpu_next_state);
 		}
 		/* Enable IO-PAD wakeup */
 		prm_set_mod_reg_bits(OMAP3430_EN_IO, WKUP_MOD, PM_WKEN);
@@ -901,6 +931,9 @@ void omap_push_sram_idle(void)
 {
 	_omap_sram_idle = omap_sram_push(omap34xx_cpu_suspend,
 					omap34xx_cpu_suspend_sz);
+	if (omap_type() != OMAP2_DEVICE_TYPE_GP)
+		_omap_save_secure_sram = omap_sram_push(save_secure_ram_context,
+				save_secure_ram_context_sz);
 }
 
 static int __init omap3_pm_init(void)
@@ -916,7 +949,6 @@ static int __init omap3_pm_init(void)
 	/* XXX prcm_setup_regs needs to be before enabling hw
 	 * supervised mode for powerdomains */
 	prcm_setup_regs();
-	omap3_save_scratchpad_contents();
 
 	ret = request_irq(INT_34XX_PRCM_MPU_IRQ,
 			  (irq_handler_t)prcm_interrupt_handler,
@@ -961,6 +993,15 @@ static int __init omap3_pm_init(void)
 	*/
 	pwrdm_add_wkdep(per_pwrdm, core_pwrdm);
 
+	if (omap_type() != OMAP2_DEVICE_TYPE_GP) {
+		omap3_secure_ram_storage =
+			kmalloc(0x803F, GFP_KERNEL);
+		if (!omap3_secure_ram_storage)
+			printk(KERN_ERR "Memory allocation failed when"
+					"allocating for secure sram context\n");
+	}
+	omap3_save_scratchpad_contents();
+
 err1:
 	return ret;
 err2:

commit f2d1185824fd3ed631f3164daeff59d0b4e55d79
Author: Tero Kristo <tero.kristo@nokia.com>
Date:   Thu Aug 28 13:13:31 2008 +0000

    OMAP: PM: DMA context save/restore for off-mode support
    
    For HS/EMU devices, these additional features are also used:
    
    - DMA interrupt disable routine added
    - Added DMA controller reset to DMA context restore
    
    Signed-off-by: Tero Kristo <tero.kristo@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index bab9b480a089..54fea79b1720 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -34,6 +34,7 @@
 #include <plat/sdrc.h>
 #include <plat/prcm.h>
 #include <plat/gpmc.h>
+#include <plat/dma.h>
 
 #include <asm/tlbflush.h>
 
@@ -95,6 +96,7 @@ static void omap3_core_save_context(void)
 	omap3_gpmc_save_context();
 	/* Save the system control module context, padconf already save above*/
 	omap3_control_save_context();
+	omap_dma_global_context_save();
 }
 
 static void omap3_core_restore_context(void)
@@ -105,6 +107,7 @@ static void omap3_core_restore_context(void)
 	omap3_gpmc_restore_context();
 	/* Restore the interrupt controller context */
 	omap_intc_restore_context();
+	omap_dma_global_context_restore();
 }
 
 /*

commit 2f5939c3ec9440a9c3a0baf4d0e1b2cc043aad46
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Sep 26 17:50:07 2008 +0530

    OMAP3: PM: CORE domain off-mode support
    
    Add context save and restore for CORE powerdomain resources in order
    to support off-mode.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 9fb087607e76..bab9b480a089 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -5,6 +5,9 @@
  * Tony Lindgren <tony@atomide.com>
  * Jouni Hogander
  *
+ * Copyright (C) 2007 Texas Instruments, Inc.
+ * Rajendra Nayak <rnayak@ti.com>
+ *
  * Copyright (C) 2005 Texas Instruments, Inc.
  * Richard Woodruff <r-woodruff2@ti.com>
  *
@@ -29,6 +32,8 @@
 #include <plat/control.h>
 #include <plat/serial.h>
 #include <plat/sdrc.h>
+#include <plat/prcm.h>
+#include <plat/gpmc.h>
 
 #include <asm/tlbflush.h>
 
@@ -39,6 +44,11 @@
 #include "prm.h"
 #include "pm.h"
 
+/* Scratchpad offsets */
+#define OMAP343X_TABLE_ADDRESS_OFFSET	   0x31
+#define OMAP343X_TABLE_VALUE_OFFSET	   0x30
+#define OMAP343X_CONTROL_REG_VALUE_OFFSET  0x32
+
 struct power_state {
 	struct powerdomain *pwrdm;
 	u32 next_state;
@@ -57,6 +67,46 @@ static struct powerdomain *core_pwrdm, *per_pwrdm;
 
 static int set_pwrdm_state(struct powerdomain *pwrdm, u32 state);
 
+static inline void omap3_per_save_context(void)
+{
+	omap_gpio_save_context();
+}
+
+static inline void omap3_per_restore_context(void)
+{
+	omap_gpio_restore_context();
+}
+
+static void omap3_core_save_context(void)
+{
+	u32 control_padconf_off;
+
+	/* Save the padconf registers */
+	control_padconf_off = omap_ctrl_readl(OMAP343X_CONTROL_PADCONF_OFF);
+	control_padconf_off |= START_PADCONF_SAVE;
+	omap_ctrl_writel(control_padconf_off, OMAP343X_CONTROL_PADCONF_OFF);
+	/* wait for the save to complete */
+	while (!omap_ctrl_readl(OMAP343X_CONTROL_GENERAL_PURPOSE_STATUS)
+			& PADCONF_SAVE_DONE)
+		;
+	/* Save the Interrupt controller context */
+	omap_intc_save_context();
+	/* Save the GPMC context */
+	omap3_gpmc_save_context();
+	/* Save the system control module context, padconf already save above*/
+	omap3_control_save_context();
+}
+
+static void omap3_core_restore_context(void)
+{
+	/* Restore the control module context, padconf restored by h/w */
+	omap3_control_restore_context();
+	/* Restore the GPMC context */
+	omap3_gpmc_restore_context();
+	/* Restore the interrupt controller context */
+	omap_intc_restore_context();
+}
+
 /*
  * PRCM Interrupt Handler Helper Function
  *
@@ -208,6 +258,7 @@ static void omap_sram_idle(void)
 	int mpu_next_state = PWRDM_POWER_ON;
 	int per_next_state = PWRDM_POWER_ON;
 	int core_next_state = PWRDM_POWER_ON;
+	int core_prev_state, per_prev_state;
 
 	if (!_omap_sram_idle)
 		return;
@@ -246,8 +297,15 @@ static void omap_sram_idle(void)
 		omap_uart_prepare_idle(1);
 		/* PER changes only with core */
 		per_next_state = pwrdm_read_next_pwrst(per_pwrdm);
-		if (per_next_state < PWRDM_POWER_ON)
+		if (per_next_state < PWRDM_POWER_ON) {
 			omap_uart_prepare_idle(2);
+			if (per_next_state == PWRDM_POWER_OFF)
+				omap3_per_save_context();
+		}
+		if (core_next_state == PWRDM_POWER_OFF) {
+			omap3_core_save_context();
+			omap3_prcm_save_context();
+		}
 		/* Enable IO-PAD wakeup */
 		prm_set_mod_reg_bits(OMAP3430_EN_IO, WKUP_MOD, PM_WKEN);
 	}
@@ -272,6 +330,18 @@ static void omap_sram_idle(void)
 
 		/* Disable IO-PAD wakeup */
 		prm_clear_mod_reg_bits(OMAP3430_EN_IO, WKUP_MOD, PM_WKEN);
+		core_prev_state = pwrdm_read_prev_pwrst(core_pwrdm);
+		if (core_prev_state == PWRDM_POWER_OFF) {
+			omap3_core_restore_context();
+			omap3_prcm_restore_context();
+			omap3_sram_restore_context();
+		}
+		if (per_next_state < PWRDM_POWER_ON) {
+			per_prev_state =
+				pwrdm_read_prev_pwrst(per_pwrdm);
+			if (per_prev_state == PWRDM_POWER_OFF)
+				omap3_per_restore_context();
+		}
 		omap2_gpio_resume_after_retention();
 	}
 
@@ -843,6 +913,7 @@ static int __init omap3_pm_init(void)
 	/* XXX prcm_setup_regs needs to be before enabling hw
 	 * supervised mode for powerdomains */
 	prcm_setup_regs();
+	omap3_save_scratchpad_contents();
 
 	ret = request_irq(INT_34XX_PRCM_MPU_IRQ,
 			  (irq_handler_t)prcm_interrupt_handler,

commit 61255ab9e853ddbbe092328c30921d2ba9434134
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Sep 26 17:49:56 2008 +0530

    OMAP3: PM: MPU off-mode support
    
    Adds a 'save_state' option when calling into SRAM idle function
    and adds some minor cleanups of SRAM asm code.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 8b5bf91dc070..9fb087607e76 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -28,6 +28,7 @@
 #include <plat/powerdomain.h>
 #include <plat/control.h>
 #include <plat/serial.h>
+#include <plat/sdrc.h>
 
 #include <asm/tlbflush.h>
 
@@ -223,6 +224,9 @@ static void omap_sram_idle(void)
 		/* No need to save context */
 		save_state = 0;
 		break;
+	case PWRDM_POWER_OFF:
+		save_state = 3;
+		break;
 	default:
 		/* Invalid state */
 		printk(KERN_ERR "Invalid mpu state in sram_idle\n");
@@ -248,7 +252,12 @@ static void omap_sram_idle(void)
 		prm_set_mod_reg_bits(OMAP3430_EN_IO, WKUP_MOD, PM_WKEN);
 	}
 
-	_omap_sram_idle(NULL, save_state);
+	/*
+	 * omap3_arm_context is the location where ARM registers
+	 * get saved. The restore path then reads from this
+	 * location and restores them back.
+	 */
+	_omap_sram_idle(omap3_arm_context, save_state);
 	cpu_init();
 
 	/* Restore table entry modified during MMU restoration */

commit 57f277b0122722ffa1de1b53aceb70646ce9a8e1
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Sep 26 17:49:34 2008 +0530

    OMAP3: PM: Restore MMU table entry
    
    During the MMU restoration on the restore path from MPU OFF, the page
    table entry for the page consisting of the code being executed is
    modified to make MMU return VA=PA.
    
    The MMU is then enabled and the original entry is being stored in
    scratchpad.  This patch reads the original values stored in
    scratchpad, and restores them back.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 05ee05f012ad..8b5bf91dc070 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -29,6 +29,8 @@
 #include <plat/control.h>
 #include <plat/serial.h>
 
+#include <asm/tlbflush.h>
+
 #include "cm.h"
 #include "cm-regbits-34xx.h"
 #include "prm-regbits-34xx.h"
@@ -164,6 +166,35 @@ static irqreturn_t prcm_interrupt_handler (int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+static void restore_control_register(u32 val)
+{
+	__asm__ __volatile__ ("mcr p15, 0, %0, c1, c0, 0" : : "r" (val));
+}
+
+/* Function to restore the table entry that was modified for enabling MMU */
+static void restore_table_entry(void)
+{
+	u32 *scratchpad_address;
+	u32 previous_value, control_reg_value;
+	u32 *address;
+
+	scratchpad_address = OMAP2_L4_IO_ADDRESS(OMAP343X_SCRATCHPAD);
+
+	/* Get address of entry that was modified */
+	address = (u32 *)__raw_readl(scratchpad_address +
+				     OMAP343X_TABLE_ADDRESS_OFFSET);
+	/* Get the previous value which needs to be restored */
+	previous_value = __raw_readl(scratchpad_address +
+				     OMAP343X_TABLE_VALUE_OFFSET);
+	address = __va(address);
+	*address = previous_value;
+	flush_tlb_all();
+	control_reg_value = __raw_readl(scratchpad_address
+					+ OMAP343X_CONTROL_REG_VALUE_OFFSET);
+	/* This will enable caches and prediction */
+	restore_control_register(control_reg_value);
+}
+
 static void omap_sram_idle(void)
 {
 	/* Variable to tell what needs to be saved and restored
@@ -220,6 +251,10 @@ static void omap_sram_idle(void)
 	_omap_sram_idle(NULL, save_state);
 	cpu_init();
 
+	/* Restore table entry modified during MMU restoration */
+	if (pwrdm_read_prev_pwrst(mpu_pwrdm) == PWRDM_POWER_OFF)
+		restore_table_entry();
+
 	if (core_next_state < PWRDM_POWER_ON) {
 		if (per_next_state < PWRDM_POWER_ON)
 			omap_uart_resume_idle(2);

commit fa3c2a4fc99fd7f8c245020303d7e11feadbbac9
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Sep 26 17:49:22 2008 +0530

    OMAP3: PM: handle PER/NEON/CORE in idle
    
    Expand the powerdomains handled in the idle path to include PER, NEON
    and CORE.  This includes properly clearing the previous powerstates,
    linking NEON state to MPU state and calling the UART prepare functions
    for only the appropraite powerdomain transitions (CORE for UART1,2,
    PER for UART3.)
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index b88da1bcb66c..05ee05f012ad 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -49,7 +49,10 @@ static LIST_HEAD(pwrst_list);
 
 static void (*_omap_sram_idle)(u32 *addr, int save_state);
 
-static struct powerdomain *mpu_pwrdm;
+static struct powerdomain *mpu_pwrdm, *neon_pwrdm;
+static struct powerdomain *core_pwrdm, *per_pwrdm;
+
+static int set_pwrdm_state(struct powerdomain *pwrdm, u32 state);
 
 /*
  * PRCM Interrupt Handler Helper Function
@@ -169,13 +172,22 @@ static void omap_sram_idle(void)
 	/* save_state = 1 => Only L1 and logic lost */
 	/* save_state = 2 => Only L2 lost */
 	/* save_state = 3 => L1, L2 and logic lost */
-	int save_state = 0, mpu_next_state;
+	int save_state = 0;
+	int mpu_next_state = PWRDM_POWER_ON;
+	int per_next_state = PWRDM_POWER_ON;
+	int core_next_state = PWRDM_POWER_ON;
 
 	if (!_omap_sram_idle)
 		return;
 
+	pwrdm_clear_all_prev_pwrst(mpu_pwrdm);
+	pwrdm_clear_all_prev_pwrst(neon_pwrdm);
+	pwrdm_clear_all_prev_pwrst(core_pwrdm);
+	pwrdm_clear_all_prev_pwrst(per_pwrdm);
+
 	mpu_next_state = pwrdm_read_next_pwrst(mpu_pwrdm);
 	switch (mpu_next_state) {
+	case PWRDM_POWER_ON:
 	case PWRDM_POWER_RET:
 		/* No need to save context */
 		save_state = 0;
@@ -187,18 +199,37 @@ static void omap_sram_idle(void)
 	}
 	pwrdm_pre_transition();
 
-	omap2_gpio_prepare_for_retention();
-	omap_uart_prepare_idle(0);
-	omap_uart_prepare_idle(1);
-	omap_uart_prepare_idle(2);
+	/* NEON control */
+	if (pwrdm_read_pwrst(neon_pwrdm) == PWRDM_POWER_ON)
+		set_pwrdm_state(neon_pwrdm, mpu_next_state);
+
+	/* CORE & PER */
+	core_next_state = pwrdm_read_next_pwrst(core_pwrdm);
+	if (core_next_state < PWRDM_POWER_ON) {
+		omap2_gpio_prepare_for_retention();
+		omap_uart_prepare_idle(0);
+		omap_uart_prepare_idle(1);
+		/* PER changes only with core */
+		per_next_state = pwrdm_read_next_pwrst(per_pwrdm);
+		if (per_next_state < PWRDM_POWER_ON)
+			omap_uart_prepare_idle(2);
+		/* Enable IO-PAD wakeup */
+		prm_set_mod_reg_bits(OMAP3430_EN_IO, WKUP_MOD, PM_WKEN);
+	}
 
 	_omap_sram_idle(NULL, save_state);
 	cpu_init();
 
-	omap_uart_resume_idle(2);
-	omap_uart_resume_idle(1);
-	omap_uart_resume_idle(0);
-	omap2_gpio_resume_after_retention();
+	if (core_next_state < PWRDM_POWER_ON) {
+		if (per_next_state < PWRDM_POWER_ON)
+			omap_uart_resume_idle(2);
+		omap_uart_resume_idle(1);
+		omap_uart_resume_idle(0);
+
+		/* Disable IO-PAD wakeup */
+		prm_clear_mod_reg_bits(OMAP3430_EN_IO, WKUP_MOD, PM_WKEN);
+		omap2_gpio_resume_after_retention();
+	}
 
 	pwrdm_post_transition();
 
@@ -792,6 +823,10 @@ static int __init omap3_pm_init(void)
 		goto err2;
 	}
 
+	neon_pwrdm = pwrdm_lookup("neon_pwrdm");
+	per_pwrdm = pwrdm_lookup("per_pwrdm");
+	core_pwrdm = pwrdm_lookup("core_pwrdm");
+
 	omap_push_sram_idle();
 #ifdef CONFIG_SUSPEND
 	suspend_set_ops(&omap_pm_ops);
@@ -799,6 +834,15 @@ static int __init omap3_pm_init(void)
 
 	pm_idle = omap3_pm_idle;
 
+	pwrdm_add_wkdep(neon_pwrdm, mpu_pwrdm);
+	/*
+	 * REVISIT: This wkdep is only necessary when GPIO2-6 are enabled for
+	 * IO-pad wakeup.  Otherwise it will unnecessarily waste power
+	 * waking up PER with every CORE wakeup - see
+	 * http://marc.info/?l=linux-omap&m=121852150710062&w=2
+	*/
+	pwrdm_add_wkdep(per_pwrdm, core_pwrdm);
+
 err1:
 	return ret;
 err2:

commit 3231fc889c114870ca830041fcdeb5d4745304cf
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Sep 26 17:49:14 2008 +0530

    OMAP3: PM: restore SRAM functions after off-mode.
    
    Generalize the copy of SRAM functions into omap_push_sram_idle()
    so it can be used on init but also after off-mode transitions.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 391054900a6a..b88da1bcb66c 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -749,6 +749,12 @@ static int __init clkdms_setup(struct clockdomain *clkdm, void *unused)
 	return 0;
 }
 
+void omap_push_sram_idle(void)
+{
+	_omap_sram_idle = omap_sram_push(omap34xx_cpu_suspend,
+					omap34xx_cpu_suspend_sz);
+}
+
 static int __init omap3_pm_init(void)
 {
 	struct power_state *pwrst, *tmp;
@@ -786,9 +792,7 @@ static int __init omap3_pm_init(void)
 		goto err2;
 	}
 
-	_omap_sram_idle = omap_sram_push(omap34xx_cpu_suspend,
-					 omap34xx_cpu_suspend_sz);
-
+	omap_push_sram_idle();
 #ifdef CONFIG_SUSPEND
 	suspend_set_ops(&omap_pm_ops);
 #endif /* CONFIG_SUSPEND */

commit 774facda20d2f8f0f61fa312d8028dad18ac5ee4
Merge: b419148e5677 ce491cf85466
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Nov 10 18:10:34 2009 -0800

    Merge branch '7xx-iosplit-plat' with omap-fixes

commit b427f92f8cfca2787c18a77bef15cc8b13341774
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Thu Oct 22 14:48:13 2009 -0700

    omap3: PM: enable UART3 module wakeups
    
    UART3 is in the PER powerdomain.  If PER goes idle/inactive
    independently of CORE, for UART3 to wakeup it must have its wakeup
    enable bits setup in PM_WKEN_PER.  This patch enables these bits.
    
    The reason it works when PER and CORE work together is because when
    CORE goes inactive/retention, the IOPAD wakeups are enabled and
    trigger UART3 wakeup.
    
    Without this patch, when the UART inactivity timer fires for UART3,
    its clocks are disabled and it's unable to wakeup so will be unusable
    until PER is awoken by another source.
    
    Another way of testing is by keeping CORE on during suspend but
    allowing PER to hit retention
    
      # echo 3 > /debug/pm_debug/core_pwrdm/suspend
    
    then enter suspend
    
      # echo mem > /sys/power/state
    
    Without this patch, UART3 will be unable to wakeup the system.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 378c2f618358..89463190923a 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -639,14 +639,15 @@ static void __init prcm_setup_regs(void)
 	prm_write_mod_reg(OMAP3430_IO_EN | OMAP3430_WKUP_EN,
 			  OCP_MOD, OMAP3_PRM_IRQENABLE_MPU_OFFSET);
 
-	/* Enable GPIO wakeups in PER */
+	/* Enable wakeups in PER */
 	prm_write_mod_reg(OMAP3430_EN_GPIO2 | OMAP3430_EN_GPIO3 |
 			  OMAP3430_EN_GPIO4 | OMAP3430_EN_GPIO5 |
-			  OMAP3430_EN_GPIO6, OMAP3430_PER_MOD, PM_WKEN);
+			  OMAP3430_EN_GPIO6 | OMAP3430_EN_UART3,
+			  OMAP3430_PER_MOD, PM_WKEN);
 	/* and allow them to wake up MPU */
 	prm_write_mod_reg(OMAP3430_GRPSEL_GPIO2 | OMAP3430_EN_GPIO3 |
 			  OMAP3430_GRPSEL_GPIO4 | OMAP3430_EN_GPIO5 |
-			  OMAP3430_GRPSEL_GPIO6,
+			  OMAP3430_GRPSEL_GPIO6 | OMAP3430_EN_UART3,
 			  OMAP3430_PER_MOD, OMAP3430_PM_MPUGRPSEL);
 
 	/* Don't attach IVA interrupts */

commit ce491cf85466c3377228c5a852ea627ec5136956
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 20 09:40:47 2009 -0700

    omap: headers: Move remaining headers from include/mach to include/plat
    
    Move the remaining headers under plat-omap/include/mach
    to plat-omap/include/plat. Also search and replace the
    files using these headers to include using the right path.
    
    This was done with:
    
    #!/bin/bash
    mach_dir_old="arch/arm/plat-omap/include/mach"
    plat_dir_new="arch/arm/plat-omap/include/plat"
    headers=$(cd $mach_dir_old && ls *.h)
    omap_dirs="arch/arm/*omap*/ \
    drivers/video/omap \
    sound/soc/omap"
    other_files="drivers/leds/leds-ams-delta.c \
    drivers/mfd/menelaus.c \
    drivers/mfd/twl4030-core.c \
    drivers/mtd/nand/ams-delta.c"
    
    for header in $headers; do
            old="#include <mach\/$header"
            new="#include <plat\/$header"
            for dir in $omap_dirs; do
                    find $dir -type f -name \*.[chS] | \
                            xargs sed -i "s/$old/$new/"
            done
            find drivers/ -type f -name \*omap*.[chS] | \
                    xargs sed -i "s/$old/$new/"
            for file in $other_files; do
                    sed -i "s/$old/$new/" $file
            done
    done
    
    for header in $(ls $mach_dir_old/*.h); do
            git mv $header $plat_dir_new/
    done
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 378c2f618358..10aa923ea484 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -23,11 +23,11 @@
 #include <linux/err.h>
 #include <linux/gpio.h>
 
-#include <mach/sram.h>
-#include <mach/clockdomain.h>
-#include <mach/powerdomain.h>
-#include <mach/control.h>
-#include <mach/serial.h>
+#include <plat/sram.h>
+#include <plat/clockdomain.h>
+#include <plat/powerdomain.h>
+#include <plat/control.h>
+#include <plat/serial.h>
 
 #include "cm.h"
 #include "cm-regbits-34xx.h"

commit eb350f74ebff9573641c5fb689fb071b695ef35b
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Thu Sep 10 15:53:08 2009 +0000

    OMAP3: PM: Enable GPIO module-level wakeups
    
    Currently, only GPIOs in the wakeup domain (GPIOs in bank 0) are
    enabled as wakups.  This patch also enables GPIOs in the PER
    powerdomain (banks 2-6) to be used as possible wakeup sources.
    
    In addition, this patch ensures that all GPIO wakeups can wakeup
    the MPU using the PM_MPUGRPSEL_<pwrdm> registers.
    
    NOTE: this doesn't enable the individual GPIOs as wakeups, this simply
    enables the per-bank wakeups at the powerdomain level.
    
    This problem was discovered by Mike Chan when preventing the CORE
    powerdomain from going into retention/off.  When CORE was allowed to
    hit retention, GPIO wakeups via IO pad were working fine, but when
    CORE remained on, GPIO module-level wakeups were not working properly.
    
    To test, prevent CORE from going inactive/retention/off, thus
    preventing the IO chain from being armed:
    
      # echo 3 > /debug/pm_debug/core_pwrdm/suspend
    
    This ensures that GPIO wakeups happen via module-level wakeups and
    not via IO pad.
    
    Tested on 3430SDP using the touchscreen GPIO (gpio 2, in WKUP)
    Tested on Zoom2 using the QUART interrup GPIO  (gpio 102, in PER)
    
    Also, c.f. OMAP PM wiki for troubleshooting GPIO wakeup issues:
    http://elinux.org/OMAP_Power_Management
    
    Reported-by: Mike Chan <mikechan@google.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index cf6ea9f318fb..378c2f618358 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -639,6 +639,16 @@ static void __init prcm_setup_regs(void)
 	prm_write_mod_reg(OMAP3430_IO_EN | OMAP3430_WKUP_EN,
 			  OCP_MOD, OMAP3_PRM_IRQENABLE_MPU_OFFSET);
 
+	/* Enable GPIO wakeups in PER */
+	prm_write_mod_reg(OMAP3430_EN_GPIO2 | OMAP3430_EN_GPIO3 |
+			  OMAP3430_EN_GPIO4 | OMAP3430_EN_GPIO5 |
+			  OMAP3430_EN_GPIO6, OMAP3430_PER_MOD, PM_WKEN);
+	/* and allow them to wake up MPU */
+	prm_write_mod_reg(OMAP3430_GRPSEL_GPIO2 | OMAP3430_EN_GPIO3 |
+			  OMAP3430_GRPSEL_GPIO4 | OMAP3430_EN_GPIO5 |
+			  OMAP3430_GRPSEL_GPIO6,
+			  OMAP3430_PER_MOD, OMAP3430_PM_MPUGRPSEL);
+
 	/* Don't attach IVA interrupts */
 	prm_write_mod_reg(0, WKUP_MOD, OMAP3430_PM_IVAGRPSEL);
 	prm_write_mod_reg(0, CORE_MOD, OMAP3430_PM_IVAGRPSEL1);

commit 71a807757394205cdb1465d68a4f0be50fd6f04b
Author: Vikram Pandita <vikram.pandita@ti.com>
Date:   Fri Jul 17 19:33:09 2009 -0500

    OMAP3: PM: USBHOST: clear wakeup events on both hosts
    
    USBHOST module has 2 fclocks (for HOST1 and HOST2), only one iclock
    and only a single bit in the WKST register to indicate a wakeup event.
    
    Because of the single WKST bit, we cannot know whether a wakeup event
    was on HOST1 or HOST2, so enable both fclocks before clearing the
    wakeup event to ensure both hosts can properly clear the event.
    
    Signed-off-by: Vikram Pandita <vikram.pandita@ti.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index d9440a18bd00..cf6ea9f318fb 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -63,7 +63,7 @@ static struct powerdomain *mpu_pwrdm;
  */
 static int prcm_clear_mod_irqs(s16 module, u8 regs)
 {
-	u32 wkst, fclk, iclk;
+	u32 wkst, fclk, iclk, clken;
 	u16 wkst_off = (regs == 3) ? OMAP3430ES2_PM_WKST3 : PM_WKST1;
 	u16 fclk_off = (regs == 3) ? OMAP3430ES2_CM_FCLKEN3 : CM_FCLKEN1;
 	u16 iclk_off = (regs == 3) ? CM_ICLKEN3 : CM_ICLKEN1;
@@ -77,8 +77,15 @@ static int prcm_clear_mod_irqs(s16 module, u8 regs)
 		iclk = cm_read_mod_reg(module, iclk_off);
 		fclk = cm_read_mod_reg(module, fclk_off);
 		while (wkst) {
-			cm_set_mod_reg_bits(wkst, module, iclk_off);
-			cm_set_mod_reg_bits(wkst, module, fclk_off);
+			clken = wkst;
+			cm_set_mod_reg_bits(clken, module, iclk_off);
+			/*
+			 * For USBHOST, we don't know whether HOST1 or
+			 * HOST2 woke us up, so enable both f-clocks
+			 */
+			if (module == OMAP3430ES2_USBHOST_MOD)
+				clken |= 1 << OMAP3430ES2_EN_USBHOST2_SHIFT;
+			cm_set_mod_reg_bits(clken, module, fclk_off);
 			prm_write_mod_reg(wkst, module, wkst_off);
 			wkst = prm_read_mod_reg(module, wkst_off);
 			c++;

commit 8cb0ac999f253212bb01cd3c0d686489ec5911ad
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Jul 22 10:29:02 2009 -0700

    OMAP3: PM: PRCM interrupt: only handle selected PRCM interrupts
    
    Clearing wakeup sources is now only done when the PRM indicates a
    wakeup source interrupt.  Since we don't handle any other types of
    PRCM interrupts right now, warn if we get any other type of PRCM
    interrupt.  Either code needs to be added to the PRCM interrupt
    handler to react to these, or these other interrupts should be masked
    off at init.
    
    Updated after Jon Hunter's PRCM IRQ rework by Kevin Hilman.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 0e7bd8e55f76..d9440a18bd00 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -61,7 +61,7 @@ static struct powerdomain *mpu_pwrdm;
  * that any peripheral wake-up events occurring while attempting to
  * clear the PM_WKST_x are detected and cleared.
  */
-static void prcm_clear_mod_irqs(s16 module, u8 regs)
+static int prcm_clear_mod_irqs(s16 module, u8 regs)
 {
 	u32 wkst, fclk, iclk;
 	u16 wkst_off = (regs == 3) ? OMAP3430ES2_PM_WKST3 : PM_WKST1;
@@ -69,6 +69,7 @@ static void prcm_clear_mod_irqs(s16 module, u8 regs)
 	u16 iclk_off = (regs == 3) ? CM_ICLKEN3 : CM_ICLKEN1;
 	u16 grpsel_off = (regs == 3) ?
 		OMAP3430ES2_PM_MPUGRPSEL3 : OMAP3430_PM_MPUGRPSEL;
+	int c = 0;
 
 	wkst = prm_read_mod_reg(module, wkst_off);
 	wkst &= prm_read_mod_reg(module, grpsel_off);
@@ -80,10 +81,28 @@ static void prcm_clear_mod_irqs(s16 module, u8 regs)
 			cm_set_mod_reg_bits(wkst, module, fclk_off);
 			prm_write_mod_reg(wkst, module, wkst_off);
 			wkst = prm_read_mod_reg(module, wkst_off);
+			c++;
 		}
 		cm_write_mod_reg(iclk, module, iclk_off);
 		cm_write_mod_reg(fclk, module, fclk_off);
 	}
+
+	return c;
+}
+
+static int _prcm_int_handle_wakeup(void)
+{
+	int c;
+
+	c = prcm_clear_mod_irqs(WKUP_MOD, 1);
+	c += prcm_clear_mod_irqs(CORE_MOD, 1);
+	c += prcm_clear_mod_irqs(OMAP3430_PER_MOD, 1);
+	if (omap_rev() > OMAP3430_REV_ES1_0) {
+		c += prcm_clear_mod_irqs(CORE_MOD, 3);
+		c += prcm_clear_mod_irqs(OMAP3430ES2_USBHOST_MOD, 1);
+	}
+
+	return c;
 }
 
 /*
@@ -106,18 +125,27 @@ static void prcm_clear_mod_irqs(s16 module, u8 regs)
 static irqreturn_t prcm_interrupt_handler (int irq, void *dev_id)
 {
 	u32 irqstatus_mpu;
+	int c = 0;
 
 	do {
-		prcm_clear_mod_irqs(WKUP_MOD, 1);
-		prcm_clear_mod_irqs(CORE_MOD, 1);
-		prcm_clear_mod_irqs(OMAP3430_PER_MOD, 1);
-		if (omap_rev() > OMAP3430_REV_ES1_0) {
-			prcm_clear_mod_irqs(CORE_MOD, 3);
-			prcm_clear_mod_irqs(OMAP3430ES2_USBHOST_MOD, 1);
-		}
-
 		irqstatus_mpu = prm_read_mod_reg(OCP_MOD,
 					OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
+
+		if (irqstatus_mpu & (OMAP3430_WKUP_ST | OMAP3430_IO_ST)) {
+			c = _prcm_int_handle_wakeup();
+
+			/*
+			 * Is the MPU PRCM interrupt handler racing with the
+			 * IVA2 PRCM interrupt handler ?
+			 */
+			WARN(c == 0, "prcm: WARNING: PRCM indicated MPU wakeup "
+			     "but no wakeup sources are marked\n");
+		} else {
+			/* XXX we need to expand our PRCM interrupt handler */
+			WARN(1, "prcm: WARNING: PRCM interrupt received, but "
+			     "no code to handle it (%08x)\n", irqstatus_mpu);
+		}
+
 		prm_write_mod_reg(irqstatus_mpu, OCP_MOD,
 					OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
 

commit 5d80597801ff0d7e6b184504c04e9c1b3b61d16d
Author: Paul Walmsley <paul@pwsan.com>
Date:   Wed Jul 22 10:18:07 2009 -0700

    OMAP3: PM: PRCM interrupt: check MPUGRPSEL register
    
    PM_WKST register contents should be ANDed with the contents of the
    MPUGRPSEL registers.  Otherwise the MPU PRCM interrupt handler could
    wind up clearing wakeup events meant for the IVA PRCM interrupt
    handler. A future revision to this code should be to read a cached
    version of MPUGRPSEL from the powerdomain code, since PRM reads are
    relatively slow.
    
    Updated after Jon Hunter's PRCM IRQ change by Kevin Hilman
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 1e7aae2ce5ed..0e7bd8e55f76 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -67,8 +67,11 @@ static void prcm_clear_mod_irqs(s16 module, u8 regs)
 	u16 wkst_off = (regs == 3) ? OMAP3430ES2_PM_WKST3 : PM_WKST1;
 	u16 fclk_off = (regs == 3) ? OMAP3430ES2_CM_FCLKEN3 : CM_FCLKEN1;
 	u16 iclk_off = (regs == 3) ? CM_ICLKEN3 : CM_ICLKEN1;
+	u16 grpsel_off = (regs == 3) ?
+		OMAP3430ES2_PM_MPUGRPSEL3 : OMAP3430_PM_MPUGRPSEL;
 
 	wkst = prm_read_mod_reg(module, wkst_off);
+	wkst &= prm_read_mod_reg(module, grpsel_off);
 	if (wkst) {
 		iclk = cm_read_mod_reg(module, iclk_off);
 		fclk = cm_read_mod_reg(module, fclk_off);

commit 77da2d910a17e1e6a7e949578723d5aab58568d5
Author: Jon Hunter <jon-hunter@ti.com>
Date:   Sat Jun 27 00:07:25 2009 -0500

    OMAP3: PM: Prevent hang in prcm_interrupt_handler
    
    There are two scenarios where a race condition could result in a hang
    in the prcm_interrupt handler. These are:
    
    1). Waiting for PRM_IRQSTATUS_MPU register to clear.
    Bit 0 of the PRM_IRQSTATUS_MPU register indicates that a wake-up event
    is pending for the MPU. This bit can only be cleared if the all the
    wake-up events latched in the various PM_WKST_x registers have been
    cleared. If a wake-up event occurred during the processing of the prcm
    interrupt handler, after the corresponding PM_WKST_x register was
    checked but before the PRM_IRQSTATUS_MPU was cleared, then the CPU
    would be stuck forever waiting for bit 0 in PRM_IRQSTATUS_MPU to be
    cleared.
    
    2). Waiting for the PM_WKST_x register to clear.
    Some power domains have more than one wake-up source. The PM_WKST_x
    registers indicate the source of a wake-up event and need to be cleared
    after a wake-up event occurs. When the PM_WKST_x registers are read and
    before they are cleared, it is possible that another wake-up event
    could occur causing another bit to be set in one of the PM_WKST_x
    registers. If this did occur after reading a PM_WKST_x register then
    the CPU would miss this event and get stuck forever in a loop waiting
    for that PM_WKST_x register to clear.
    
    This patch address the above race conditions that would result in a
    hang.
    
    Signed-off-by: Jon Hunter <jon-hunter@ti.com>
    Reviewed-by: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 0ff5a6c53aa0..1e7aae2ce5ed 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -51,97 +51,74 @@ static void (*_omap_sram_idle)(u32 *addr, int save_state);
 
 static struct powerdomain *mpu_pwrdm;
 
-/* PRCM Interrupt Handler for wakeups */
-static irqreturn_t prcm_interrupt_handler (int irq, void *dev_id)
+/*
+ * PRCM Interrupt Handler Helper Function
+ *
+ * The purpose of this function is to clear any wake-up events latched
+ * in the PRCM PM_WKST_x registers. It is possible that a wake-up event
+ * may occur whilst attempting to clear a PM_WKST_x register and thus
+ * set another bit in this register. A while loop is used to ensure
+ * that any peripheral wake-up events occurring while attempting to
+ * clear the PM_WKST_x are detected and cleared.
+ */
+static void prcm_clear_mod_irqs(s16 module, u8 regs)
 {
-	u32 wkst, irqstatus_mpu;
-	u32 fclk, iclk;
+	u32 wkst, fclk, iclk;
+	u16 wkst_off = (regs == 3) ? OMAP3430ES2_PM_WKST3 : PM_WKST1;
+	u16 fclk_off = (regs == 3) ? OMAP3430ES2_CM_FCLKEN3 : CM_FCLKEN1;
+	u16 iclk_off = (regs == 3) ? CM_ICLKEN3 : CM_ICLKEN1;
 
-	/* WKUP */
-	wkst = prm_read_mod_reg(WKUP_MOD, PM_WKST);
+	wkst = prm_read_mod_reg(module, wkst_off);
 	if (wkst) {
-		iclk = cm_read_mod_reg(WKUP_MOD, CM_ICLKEN);
-		fclk = cm_read_mod_reg(WKUP_MOD, CM_FCLKEN);
-		cm_set_mod_reg_bits(wkst, WKUP_MOD, CM_ICLKEN);
-		cm_set_mod_reg_bits(wkst, WKUP_MOD, CM_FCLKEN);
-		prm_write_mod_reg(wkst, WKUP_MOD, PM_WKST);
-		while (prm_read_mod_reg(WKUP_MOD, PM_WKST))
-			cpu_relax();
-		cm_write_mod_reg(iclk, WKUP_MOD, CM_ICLKEN);
-		cm_write_mod_reg(fclk, WKUP_MOD, CM_FCLKEN);
-	}
-
-	/* CORE */
-	wkst = prm_read_mod_reg(CORE_MOD, PM_WKST1);
-	if (wkst) {
-		iclk = cm_read_mod_reg(CORE_MOD, CM_ICLKEN1);
-		fclk = cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
-		cm_set_mod_reg_bits(wkst, CORE_MOD, CM_ICLKEN1);
-		cm_set_mod_reg_bits(wkst, CORE_MOD, CM_FCLKEN1);
-		prm_write_mod_reg(wkst, CORE_MOD, PM_WKST1);
-		while (prm_read_mod_reg(CORE_MOD, PM_WKST1))
-			cpu_relax();
-		cm_write_mod_reg(iclk, CORE_MOD, CM_ICLKEN1);
-		cm_write_mod_reg(fclk, CORE_MOD, CM_FCLKEN1);
-	}
-	wkst = prm_read_mod_reg(CORE_MOD, OMAP3430ES2_PM_WKST3);
-	if (wkst) {
-		iclk = cm_read_mod_reg(CORE_MOD, CM_ICLKEN3);
-		fclk = cm_read_mod_reg(CORE_MOD, OMAP3430ES2_CM_FCLKEN3);
-		cm_set_mod_reg_bits(wkst, CORE_MOD, CM_ICLKEN3);
-		cm_set_mod_reg_bits(wkst, CORE_MOD, OMAP3430ES2_CM_FCLKEN3);
-		prm_write_mod_reg(wkst, CORE_MOD, OMAP3430ES2_PM_WKST3);
-		while (prm_read_mod_reg(CORE_MOD, OMAP3430ES2_PM_WKST3))
-			cpu_relax();
-		cm_write_mod_reg(iclk, CORE_MOD, CM_ICLKEN3);
-		cm_write_mod_reg(fclk, CORE_MOD, OMAP3430ES2_CM_FCLKEN3);
-	}
-
-	/* PER */
-	wkst = prm_read_mod_reg(OMAP3430_PER_MOD, PM_WKST);
-	if (wkst) {
-		iclk = cm_read_mod_reg(OMAP3430_PER_MOD, CM_ICLKEN);
-		fclk = cm_read_mod_reg(OMAP3430_PER_MOD, CM_FCLKEN);
-		cm_set_mod_reg_bits(wkst, OMAP3430_PER_MOD, CM_ICLKEN);
-		cm_set_mod_reg_bits(wkst, OMAP3430_PER_MOD, CM_FCLKEN);
-		prm_write_mod_reg(wkst, OMAP3430_PER_MOD, PM_WKST);
-		while (prm_read_mod_reg(OMAP3430_PER_MOD, PM_WKST))
-			cpu_relax();
-		cm_write_mod_reg(iclk, OMAP3430_PER_MOD, CM_ICLKEN);
-		cm_write_mod_reg(fclk, OMAP3430_PER_MOD, CM_FCLKEN);
+		iclk = cm_read_mod_reg(module, iclk_off);
+		fclk = cm_read_mod_reg(module, fclk_off);
+		while (wkst) {
+			cm_set_mod_reg_bits(wkst, module, iclk_off);
+			cm_set_mod_reg_bits(wkst, module, fclk_off);
+			prm_write_mod_reg(wkst, module, wkst_off);
+			wkst = prm_read_mod_reg(module, wkst_off);
+		}
+		cm_write_mod_reg(iclk, module, iclk_off);
+		cm_write_mod_reg(fclk, module, fclk_off);
 	}
+}
 
-	if (omap_rev() > OMAP3430_REV_ES1_0) {
-		/* USBHOST */
-		wkst = prm_read_mod_reg(OMAP3430ES2_USBHOST_MOD, PM_WKST);
-		if (wkst) {
-			iclk = cm_read_mod_reg(OMAP3430ES2_USBHOST_MOD,
-					       CM_ICLKEN);
-			fclk = cm_read_mod_reg(OMAP3430ES2_USBHOST_MOD,
-					       CM_FCLKEN);
-			cm_set_mod_reg_bits(wkst, OMAP3430ES2_USBHOST_MOD,
-					    CM_ICLKEN);
-			cm_set_mod_reg_bits(wkst, OMAP3430ES2_USBHOST_MOD,
-					    CM_FCLKEN);
-			prm_write_mod_reg(wkst, OMAP3430ES2_USBHOST_MOD,
-					  PM_WKST);
-			while (prm_read_mod_reg(OMAP3430ES2_USBHOST_MOD,
-						PM_WKST))
-				cpu_relax();
-			cm_write_mod_reg(iclk, OMAP3430ES2_USBHOST_MOD,
-					 CM_ICLKEN);
-			cm_write_mod_reg(fclk, OMAP3430ES2_USBHOST_MOD,
-					 CM_FCLKEN);
+/*
+ * PRCM Interrupt Handler
+ *
+ * The PRM_IRQSTATUS_MPU register indicates if there are any pending
+ * interrupts from the PRCM for the MPU. These bits must be cleared in
+ * order to clear the PRCM interrupt. The PRCM interrupt handler is
+ * implemented to simply clear the PRM_IRQSTATUS_MPU in order to clear
+ * the PRCM interrupt. Please note that bit 0 of the PRM_IRQSTATUS_MPU
+ * register indicates that a wake-up event is pending for the MPU and
+ * this bit can only be cleared if the all the wake-up events latched
+ * in the various PM_WKST_x registers have been cleared. The interrupt
+ * handler is implemented using a do-while loop so that if a wake-up
+ * event occurred during the processing of the prcm interrupt handler
+ * (setting a bit in the corresponding PM_WKST_x register and thus
+ * preventing us from clearing bit 0 of the PRM_IRQSTATUS_MPU register)
+ * this would be handled.
+ */
+static irqreturn_t prcm_interrupt_handler (int irq, void *dev_id)
+{
+	u32 irqstatus_mpu;
+
+	do {
+		prcm_clear_mod_irqs(WKUP_MOD, 1);
+		prcm_clear_mod_irqs(CORE_MOD, 1);
+		prcm_clear_mod_irqs(OMAP3430_PER_MOD, 1);
+		if (omap_rev() > OMAP3430_REV_ES1_0) {
+			prcm_clear_mod_irqs(CORE_MOD, 3);
+			prcm_clear_mod_irqs(OMAP3430ES2_USBHOST_MOD, 1);
 		}
-	}
 
-	irqstatus_mpu = prm_read_mod_reg(OCP_MOD,
-					 OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
-	prm_write_mod_reg(irqstatus_mpu, OCP_MOD,
-			  OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
+		irqstatus_mpu = prm_read_mod_reg(OCP_MOD,
+					OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
+		prm_write_mod_reg(irqstatus_mpu, OCP_MOD,
+					OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
 
-	while (prm_read_mod_reg(OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET))
-		cpu_relax();
+	} while (prm_read_mod_reg(OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET));
 
 	return IRQ_HANDLED;
 }

commit 5567fa1f543dde3c42f8e52bf4f7005135b24896
Merge: d3d381c6365e 68d4778c701b
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Sep 2 15:23:05 2009 -0700

    Merge branch 'pm-upstream/debug' of git://git.kernel.org/pub/scm/linux/kernel/git/khilman/linux-omap-pm into for-next

commit 68d4778c701b7e22ddfd64e3afb6628c92718ad2
Author: Tero Kristo <tero.kristo@nokia.com>
Date:   Wed Nov 26 12:26:24 2008 +0200

    OMAP: PM: Added suspend target state control to debugfs for OMAP3
    
    Target state can be read / programmed via files under:
      [debugfs]/pm_debug/[pwrdm]/suspend
    
    Signed-off-by: Tero Kristo <tero.kristo@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 331dfca93ed5..26f2aca9abe8 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -664,6 +664,30 @@ static void __init prcm_setup_regs(void)
 	omap3_d2d_idle();
 }
 
+int omap3_pm_get_suspend_state(struct powerdomain *pwrdm)
+{
+	struct power_state *pwrst;
+
+	list_for_each_entry(pwrst, &pwrst_list, node) {
+		if (pwrst->pwrdm == pwrdm)
+			return pwrst->next_state;
+	}
+	return -EINVAL;
+}
+
+int omap3_pm_set_suspend_state(struct powerdomain *pwrdm, int state)
+{
+	struct power_state *pwrst;
+
+	list_for_each_entry(pwrst, &pwrst_list, node) {
+		if (pwrst->pwrdm == pwrdm) {
+			pwrst->next_state = state;
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
 static int __init pwrdms_setup(struct powerdomain *pwrdm, void *unused)
 {
 	struct power_state *pwrst;

commit a23456e9b02b3fae0fc78cb33fad69803a50e5bc
Author: Peter 'p2' De Schrijver <peter.de-schrijver@nokia.com>
Date:   Wed Oct 15 18:13:47 2008 +0300

    OMAP: PM: Add closures to clkdm_for_each and pwrdm_for_each.
    
    Add some infrastructure to easily iterate over clock and power
    domains.
    
    Signed-off-by: Peter 'p2' De Schrijver <peter.de-schrijver@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index f1976242f997..331dfca93ed5 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -664,7 +664,7 @@ static void __init prcm_setup_regs(void)
 	omap3_d2d_idle();
 }
 
-static int __init pwrdms_setup(struct powerdomain *pwrdm)
+static int __init pwrdms_setup(struct powerdomain *pwrdm, void *unused)
 {
 	struct power_state *pwrst;
 
@@ -689,7 +689,7 @@ static int __init pwrdms_setup(struct powerdomain *pwrdm)
  * supported. Initiate sleep transition for other clockdomains, if
  * they are not used
  */
-static int __init clkdms_setup(struct clockdomain *clkdm)
+static int __init clkdms_setup(struct clockdomain *clkdm, void *unused)
 {
 	if (clkdm->flags & CLKDM_CAN_ENABLE_AUTO)
 		omap2_clkdm_allow_idle(clkdm);
@@ -722,13 +722,13 @@ static int __init omap3_pm_init(void)
 		goto err1;
 	}
 
-	ret = pwrdm_for_each(pwrdms_setup);
+	ret = pwrdm_for_each(pwrdms_setup, NULL);
 	if (ret) {
 		printk(KERN_ERR "Failed to setup powerdomains\n");
 		goto err2;
 	}
 
-	(void) clkdm_for_each(clkdms_setup);
+	(void) clkdm_for_each(clkdms_setup, NULL);
 
 	mpu_pwrdm = pwrdm_lookup("mpu_pwrdm");
 	if (mpu_pwrdm == NULL) {

commit fe617af716bc09cbbdd11ad820d5818017a9f481
Author: Peter 'p2' De Schrijver <peter.de-schrijver@nokia.com>
Date:   Wed Oct 15 17:48:44 2008 +0300

    OMAP: PM: Hook into PM counters
    
    This patch modifies the clock, clockdomain and OMAP3 specific
    powerdomain code to call the PM counter infrastructure whenever one or
    more powerdomains might have changed state.
    
    Signed-off-by: Peter 'p2' De Schrijver <peter.de-schrijver@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 488d595d8e4b..f1976242f997 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -170,6 +170,8 @@ static void omap_sram_idle(void)
 		printk(KERN_ERR "Invalid mpu state in sram_idle\n");
 		return;
 	}
+	pwrdm_pre_transition();
+
 	omap2_gpio_prepare_for_retention();
 	omap_uart_prepare_idle(0);
 	omap_uart_prepare_idle(1);
@@ -182,6 +184,9 @@ static void omap_sram_idle(void)
 	omap_uart_resume_idle(1);
 	omap_uart_resume_idle(0);
 	omap2_gpio_resume_after_retention();
+
+	pwrdm_post_transition();
+
 }
 
 /*
@@ -271,6 +276,7 @@ static int set_pwrdm_state(struct powerdomain *pwrdm, u32 state)
 	if (sleep_switch) {
 		omap2_clkdm_allow_idle(pwrdm->pwrdm_clkdms[0]);
 		pwrdm_wait_transition(pwrdm);
+		pwrdm_state_switch(pwrdm);
 	}
 
 err:

commit d3d381c6365ef5b06c4184a3fe047cf027533970
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Sat Aug 22 21:20:26 2009 +0800

    OMAP3: PM: fix lockdep warning caused by omap3_pm_init
    
    This patch uses kmalloc(size,GFP_ATOMIC) instead of kmalloc(size,GFP_KERNEL)
    to allocate memory for instance of struct power_state in pwrdms_setup(),
    since it may be called by pwrdm_for_each() with irq disabled.
    
    It is a easy fix for the following lockdep warning caused by
    kmalloc(size,GFP_KERNEL) in pwrdms_setup():
    
    Power Management for TI OMAP3.
    ------------[ cut here ]------------
    WARNING: at kernel/lockdep.c:2282 lockdep_trace_alloc+0xe8/0xfc()
    Modules linked in:
    [<c0032ccc>] (unwind_backtrace+0x0/0xec) from [<c0056934>] (warn_slowpath_common+0x48/0x60)
    [<c0056934>] (warn_slowpath_common+0x48/0x60) from [<c007da10>] (lockdep_trace_alloc+0xe8/0xfc)
    [<c007da10>] (lockdep_trace_alloc+0xe8/0xfc) from [<c00cd9bc>] (kmem_cache_alloc+0x28/0x178)
    [<c00cd9bc>] (kmem_cache_alloc+0x28/0x178) from [<c000f184>] (pwrdms_setup+0x30/0xf8)
    [<c000f184>] (pwrdms_setup+0x30/0xf8) from [<c00381c4>] (pwrdm_for_each+0x64/0x84)
    [<c00381c4>] (pwrdm_for_each+0x64/0x84) from [<c000ef60>] (omap3_pm_init+0x3f4/0x5ac)
    [<c000ef60>] (omap3_pm_init+0x3f4/0x5ac) from [<c002c2c0>] (do_one_initcall+0x30/0x1d4)
    [<c002c2c0>] (do_one_initcall+0x30/0x1d4) from [<c00088d8>] (kernel_init+0xa4/0x118)
    [<c00088d8>] (kernel_init+0xa4/0x118) from [<c002ddf8>] (kernel_thread_exit+0x0/0x8)
    ---[ end trace 1e06f8d97dc5a19b ]---
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 488d595d8e4b..d67b781045b7 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -665,7 +665,7 @@ static int __init pwrdms_setup(struct powerdomain *pwrdm)
 	if (!pwrdm->pwrsts)
 		return 0;
 
-	pwrst = kmalloc(sizeof(struct power_state), GFP_KERNEL);
+	pwrst = kmalloc(sizeof(struct power_state), GFP_ATOMIC);
 	if (!pwrst)
 		return -ENOMEM;
 	pwrst->pwrdm = pwrdm;

commit 6c5f80393b107b0c9e2a54b03b65d1880e706655
Author: Jouni Hogander <jouni.hogander@nokia.com>
Date:   Wed Oct 29 12:06:04 2008 +0200

    OMAP3: PM: Fix wrong sequence in suspend.
    
    Powerdomain previous state is checked after restoring new states in
    suspend. This patch fixes this problem.
    
    Signed-off-by: Jouni Hogander <jouni.hogander@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index b07efb26de18..488d595d8e4b 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -326,7 +326,6 @@ static int omap3_pm_suspend(void)
 restore:
 	/* Restore next_pwrsts */
 	list_for_each_entry(pwrst, &pwrst_list, node) {
-		set_pwrdm_state(pwrst->pwrdm, pwrst->saved_state);
 		state = pwrdm_read_prev_pwrst(pwrst->pwrdm);
 		if (state > pwrst->next_state) {
 			printk(KERN_INFO "Powerdomain (%s) didn't enter "
@@ -334,6 +333,7 @@ static int omap3_pm_suspend(void)
 			       pwrst->pwrdm->name, pwrst->next_state);
 			ret = -1;
 		}
+		set_pwrdm_state(pwrst->pwrdm, pwrst->saved_state);
 	}
 	if (ret)
 		printk(KERN_ERR "Could not enter target state in pm_suspend\n");

commit 2466211e5debd205fc550d871fe0ab9b9a6d02ed
Author: Tero Kristo <tero.kristo@nokia.com>
Date:   Thu Mar 5 16:32:23 2009 +0200

    OMAP3: Fixed crash bug with serial + suspend
    
    It was possible for an unhandled interrupt to occur if there was incoming
    serial traffic during wakeup from suspend. This was caused by the code
    in arch-arm/mach-omap2/serial.c keeping interrupt enabled all the time,
    but not acking its interrupts. Applies on top of PM branch.
    
    Use the PM begin/end hooks to ensure that the "serial idle" interrupts
    are disabled during the suspend path.  Also, since begin/end hooks are
    now used, use the suspend_state that is passed in the begin hook instead
    of the enter hook as per the platform_suspend_ops docs.
    
    Signed-off-by: Tero Kristo <tero.kristo@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 528f725722a2..b07efb26de18 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -296,6 +296,8 @@ static void omap3_pm_idle(void)
 }
 
 #ifdef CONFIG_SUSPEND
+static suspend_state_t suspend_state;
+
 static int omap3_pm_prepare(void)
 {
 	disable_hlt();
@@ -342,11 +344,11 @@ static int omap3_pm_suspend(void)
 	return ret;
 }
 
-static int omap3_pm_enter(suspend_state_t state)
+static int omap3_pm_enter(suspend_state_t unused)
 {
 	int ret = 0;
 
-	switch (state) {
+	switch (suspend_state) {
 	case PM_SUSPEND_STANDBY:
 	case PM_SUSPEND_MEM:
 		ret = omap3_pm_suspend();
@@ -363,7 +365,24 @@ static void omap3_pm_finish(void)
 	enable_hlt();
 }
 
+/* Hooks to enable / disable UART interrupts during suspend */
+static int omap3_pm_begin(suspend_state_t state)
+{
+	suspend_state = state;
+	omap_uart_enable_irqs(0);
+	return 0;
+}
+
+static void omap3_pm_end(void)
+{
+	suspend_state = PM_SUSPEND_ON;
+	omap_uart_enable_irqs(1);
+	return;
+}
+
 static struct platform_suspend_ops omap_pm_ops = {
+	.begin		= omap3_pm_begin,
+	.end		= omap3_pm_end,
 	.prepare	= omap3_pm_prepare,
 	.enter		= omap3_pm_enter,
 	.finish		= omap3_pm_finish,

commit 10f90ed2d727c0f344d910c02c9726d0481d9b00
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Wed Jun 24 11:39:18 2009 -0700

    OMAP3: PM: Do not build suspend code if SUSPEND is not enabled
    
    Signed-off-by: Jouni Hogander <jouni.hogander@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index c813a081c3c8..528f725722a2 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -39,7 +39,9 @@
 struct power_state {
 	struct powerdomain *pwrdm;
 	u32 next_state;
+#ifdef CONFIG_SUSPEND
 	u32 saved_state;
+#endif
 	struct list_head node;
 };
 
@@ -293,6 +295,7 @@ static void omap3_pm_idle(void)
 	local_irq_enable();
 }
 
+#ifdef CONFIG_SUSPEND
 static int omap3_pm_prepare(void)
 {
 	disable_hlt();
@@ -366,6 +369,7 @@ static struct platform_suspend_ops omap_pm_ops = {
 	.finish		= omap3_pm_finish,
 	.valid		= suspend_valid_only_mem,
 };
+#endif /* CONFIG_SUSPEND */
 
 
 /**
@@ -710,7 +714,9 @@ static int __init omap3_pm_init(void)
 	_omap_sram_idle = omap_sram_push(omap34xx_cpu_suspend,
 					 omap34xx_cpu_suspend_sz);
 
+#ifdef CONFIG_SUSPEND
 	suspend_set_ops(&omap_pm_ops);
+#endif /* CONFIG_SUSPEND */
 
 	pm_idle = omap3_pm_idle;
 

commit 040fed059c34da5115790609f1a038fc9aec88d1
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Tue May 5 16:34:25 2009 -0700

    OMAP3: PM: prevent module wakeups from waking IVA2
    
    By default, prevent functional wakeups from inside a module from
    waking up the IVA2.  Let DSP Bridge code handle this when loaded.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 1422e931f57f..c813a081c3c8 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -613,6 +613,12 @@ static void __init prcm_setup_regs(void)
 	/* Clear any pending PRCM interrupts */
 	prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
 
+	/* Don't attach IVA interrupts */
+	prm_write_mod_reg(0, WKUP_MOD, OMAP3430_PM_IVAGRPSEL);
+	prm_write_mod_reg(0, CORE_MOD, OMAP3430_PM_IVAGRPSEL1);
+	prm_write_mod_reg(0, CORE_MOD, OMAP3430ES2_PM_IVAGRPSEL3);
+	prm_write_mod_reg(0, OMAP3430_PER_MOD, OMAP3430_PM_IVAGRPSEL);
+
 	/* Clear any pending 'reset' flags */
 	prm_write_mod_reg(0xffffffff, MPU_MOD, RM_RSTST);
 	prm_write_mod_reg(0xffffffff, CORE_MOD, RM_RSTST);

commit 3a07ae30a0bfa93ff2b242acf670c6d8e2de35de
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Mon Apr 27 16:14:54 2009 -0700

    OMAP3: PM: Clear pending PRCM reset flags on init
    
    Any pending reset flags can prevent retention.  Ensure they are all
    cleared during boot.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index cc83dfc39a8b..1422e931f57f 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -613,6 +613,15 @@ static void __init prcm_setup_regs(void)
 	/* Clear any pending PRCM interrupts */
 	prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
 
+	/* Clear any pending 'reset' flags */
+	prm_write_mod_reg(0xffffffff, MPU_MOD, RM_RSTST);
+	prm_write_mod_reg(0xffffffff, CORE_MOD, RM_RSTST);
+	prm_write_mod_reg(0xffffffff, OMAP3430_PER_MOD, RM_RSTST);
+	prm_write_mod_reg(0xffffffff, OMAP3430_EMU_MOD, RM_RSTST);
+	prm_write_mod_reg(0xffffffff, OMAP3430_NEON_MOD, RM_RSTST);
+	prm_write_mod_reg(0xffffffff, OMAP3430_DSS_MOD, RM_RSTST);
+	prm_write_mod_reg(0xffffffff, OMAP3430ES2_USBHOST_MOD, RM_RSTST);
+
 	/* Clear any pending PRCM interrupts */
 	prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
 

commit 3a6667acf916b3e32be4682196882fc2ed0ec23e
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Mon Apr 27 07:50:23 2009 -0700

    OMAP3: PM: Ensure PRCM interrupts are cleared at boot
    
    Any pending PRCM interrupts can prevent retention.  Ensure
    they are cleared during boot.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 765cdc0cd7a8..cc83dfc39a8b 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -613,6 +613,9 @@ static void __init prcm_setup_regs(void)
 	/* Clear any pending PRCM interrupts */
 	prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
 
+	/* Clear any pending PRCM interrupts */
+	prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
+
 	omap3_iva_idle();
 	omap3_d2d_idle();
 }

commit 7cc515f74d2871daff106a17714bfd16bcb045ca
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Wed Jun 10 09:02:25 2009 -0700

    OMAP2/3: PM: make PM __init calls static
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 841d4c5ed8be..765cdc0cd7a8 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -652,7 +652,7 @@ static int __init clkdms_setup(struct clockdomain *clkdm)
 	return 0;
 }
 
-int __init omap3_pm_init(void)
+static int __init omap3_pm_init(void)
 {
 	struct power_state *pwrst, *tmp;
 	int ret;

commit d3fd3290c4d9f0e40d06fa3a1a8cf164d8cde801
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Tue May 5 16:34:25 2009 -0700

    OMAP3: PM: prevent module wakeups from waking IVA2
    
    By default, prevent functional wakeups from inside a module from
    waking up the IVA2.  Let DSP Bridge code handle this when loaded.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 8b8a2dd49471..841d4c5ed8be 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -595,6 +595,12 @@ static void __init prcm_setup_regs(void)
 	prm_write_mod_reg(OMAP3430_IO_EN | OMAP3430_WKUP_EN,
 			  OCP_MOD, OMAP3_PRM_IRQENABLE_MPU_OFFSET);
 
+	/* Don't attach IVA interrupts */
+	prm_write_mod_reg(0, WKUP_MOD, OMAP3430_PM_IVAGRPSEL);
+	prm_write_mod_reg(0, CORE_MOD, OMAP3430_PM_IVAGRPSEL1);
+	prm_write_mod_reg(0, CORE_MOD, OMAP3430ES2_PM_IVAGRPSEL3);
+	prm_write_mod_reg(0, OMAP3430_PER_MOD, OMAP3430_PM_IVAGRPSEL);
+
 	/* Clear any pending 'reset' flags */
 	prm_write_mod_reg(0xffffffff, MPU_MOD, RM_RSTST);
 	prm_write_mod_reg(0xffffffff, CORE_MOD, RM_RSTST);

commit b1340d17d25f9a51acf003ba4742e77aefb32071
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Mon Apr 27 16:14:54 2009 -0700

    OMAP3: PM: Clear pending PRCM reset flags on init
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 6bbb047a2757..8b8a2dd49471 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -595,6 +595,15 @@ static void __init prcm_setup_regs(void)
 	prm_write_mod_reg(OMAP3430_IO_EN | OMAP3430_WKUP_EN,
 			  OCP_MOD, OMAP3_PRM_IRQENABLE_MPU_OFFSET);
 
+	/* Clear any pending 'reset' flags */
+	prm_write_mod_reg(0xffffffff, MPU_MOD, RM_RSTST);
+	prm_write_mod_reg(0xffffffff, CORE_MOD, RM_RSTST);
+	prm_write_mod_reg(0xffffffff, OMAP3430_PER_MOD, RM_RSTST);
+	prm_write_mod_reg(0xffffffff, OMAP3430_EMU_MOD, RM_RSTST);
+	prm_write_mod_reg(0xffffffff, OMAP3430_NEON_MOD, RM_RSTST);
+	prm_write_mod_reg(0xffffffff, OMAP3430_DSS_MOD, RM_RSTST);
+	prm_write_mod_reg(0xffffffff, OMAP3430ES2_USBHOST_MOD, RM_RSTST);
+
 	/* Clear any pending PRCM interrupts */
 	prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
 

commit 014c46db1c596299fc2c1d231cee30bb211035dc
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Mon Apr 27 07:50:23 2009 -0700

    OMAP3: PM: Ensure PRCM interrupts are cleared at boot
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index f72e25465429..6bbb047a2757 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -595,6 +595,9 @@ static void __init prcm_setup_regs(void)
 	prm_write_mod_reg(OMAP3430_IO_EN | OMAP3430_WKUP_EN,
 			  OCP_MOD, OMAP3_PRM_IRQENABLE_MPU_OFFSET);
 
+	/* Clear any pending PRCM interrupts */
+	prm_write_mod_reg(0, OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
+
 	omap3_iva_idle();
 	omap3_d2d_idle();
 }

commit 8111b221a275cbc974eba26059dc764680ded9a9
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Tue Apr 28 15:27:44 2009 -0700

    OMAP3: PM: Add D2D clocks and auto-idle setup to PRCM init
    
    Add D2D clocks (modem_fck, sad2d_ick, mad2d_ick) to clock framework
    and ensure that auto-idle bits are set for these clocks during PRCM
    init.
    
    Also add omap3_d2d_idle() function called durint PRCM setup which
    ensures D2D pins are MUX'd correctly to enable retention for
    standalone (no-modem) devices.
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 54876aca2d45..f72e25465429 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -415,14 +415,32 @@ static void __init omap3_iva_idle(void)
 			  OMAP3430_IVA2_MOD, RM_RSTCTRL);
 }
 
-static void __init prcm_setup_regs(void)
+static void __init omap3_d2d_idle(void)
 {
+	u16 mask, padconf;
+
+	/* In a stand alone OMAP3430 where there is not a stacked
+	 * modem for the D2D Idle Ack and D2D MStandby must be pulled
+	 * high. S CONTROL_PADCONF_SAD2D_IDLEACK and
+	 * CONTROL_PADCONF_SAD2D_MSTDBY to have a pull up. */
+	mask = (1 << 4) | (1 << 3); /* pull-up, enabled */
+	padconf = omap_ctrl_readw(OMAP3_PADCONF_SAD2D_MSTANDBY);
+	padconf |= mask;
+	omap_ctrl_writew(padconf, OMAP3_PADCONF_SAD2D_MSTANDBY);
+
+	padconf = omap_ctrl_readw(OMAP3_PADCONF_SAD2D_IDLEACK);
+	padconf |= mask;
+	omap_ctrl_writew(padconf, OMAP3_PADCONF_SAD2D_IDLEACK);
+
 	/* reset modem */
 	prm_write_mod_reg(OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RSTPWRON |
 			  OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RST,
 			  CORE_MOD, RM_RSTCTRL);
 	prm_write_mod_reg(0, CORE_MOD, RM_RSTCTRL);
+}
 
+static void __init prcm_setup_regs(void)
+{
 	/* XXX Reset all wkdeps. This should be done when initializing
 	 * powerdomains */
 	prm_write_mod_reg(0, OMAP3430_IVA2_MOD, PM_WKDEP);
@@ -442,6 +460,7 @@ static void __init prcm_setup_regs(void)
 	 * Note that in the long run this should be done by clockfw
 	 */
 	cm_write_mod_reg(
+		OMAP3430_AUTO_MODEM |
 		OMAP3430ES2_AUTO_MMC3 |
 		OMAP3430ES2_AUTO_ICR |
 		OMAP3430_AUTO_AES2 |
@@ -469,7 +488,7 @@ static void __init prcm_setup_regs(void)
 		OMAP3430_AUTO_OMAPCTRL |
 		OMAP3430ES1_AUTO_FSHOSTUSB |
 		OMAP3430_AUTO_HSOTGUSB |
-		OMAP3430ES1_AUTO_D2D | /* This is es1 only */
+		OMAP3430_AUTO_SAD2D |
 		OMAP3430_AUTO_SSI,
 		CORE_MOD, CM_AUTOIDLE1);
 
@@ -483,6 +502,7 @@ static void __init prcm_setup_regs(void)
 
 	if (omap_rev() > OMAP3430_REV_ES1_0) {
 		cm_write_mod_reg(
+			OMAP3430_AUTO_MAD2D |
 			OMAP3430ES2_AUTO_USBTLL,
 			CORE_MOD, CM_AUTOIDLE3);
 	}
@@ -576,6 +596,7 @@ static void __init prcm_setup_regs(void)
 			  OCP_MOD, OMAP3_PRM_IRQENABLE_MPU_OFFSET);
 
 	omap3_iva_idle();
+	omap3_d2d_idle();
 }
 
 static int __init pwrdms_setup(struct powerdomain *pwrdm)

commit 4af4016c53f52b26461b8030211f8427a58fa5ed
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Wed Feb 4 10:51:40 2009 -0800

    OMAP3: PM: UART: disable clocks when idle and off-mode support
    
    This patch allows the UART clocks to be disabled when the OMAP UARTs
    are inactive, thus permitting the chip to hit retention in idle.
    After the expiration of an activity timer, each UART is allowed to
    disable its clocks so the system can enter retention.  The activity
    timer is (re)activated on any UART interrupt, UART wake event or any
    IO pad wakeup.  The actual disable of the UART clocks is done in the
    'prepare_idle' hook called from the OMAP idle loop.
    
    While the activity timer is active, the smart-idle mode of the UART is
    also disabled.  This is due to a "feature" of the UART module that
    after a UART wakeup, the smart-idle mode may be entered before the
    UART has communicated the interrupt, or upon TX, an idle mode may be
    entered before the TX FIFOs are emptied.
    
    Upon suspend, the 'prepare_suspend' hook cancels any pending activity
    timers and allows the clocks to be disabled immediately.
    
    In addition, upon disabling clocks the UART state is saved in case
    of an off-mode transition while clocks are off.
    
    Special thanks to Tero Kristo for the initial ideas and first versions
    of UART idle support, and to Jouni Hogander for extra testing and
    bugfixes.
    
    Tested on OMAP3 (Beagle, RX51, SDP, EVM) and OMAP2 (n810)
    
    Cc: Tero Kristo <tero.kristo@nokia.com>
    Cc: Jouni Hogander <jouni.hogander@nokia.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index b2a8730771e9..54876aca2d45 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -27,6 +27,7 @@
 #include <mach/clockdomain.h>
 #include <mach/powerdomain.h>
 #include <mach/control.h>
+#include <mach/serial.h>
 
 #include "cm.h"
 #include "cm-regbits-34xx.h"
@@ -168,10 +169,16 @@ static void omap_sram_idle(void)
 		return;
 	}
 	omap2_gpio_prepare_for_retention();
+	omap_uart_prepare_idle(0);
+	omap_uart_prepare_idle(1);
+	omap_uart_prepare_idle(2);
 
 	_omap_sram_idle(NULL, save_state);
 	cpu_init();
 
+	omap_uart_resume_idle(2);
+	omap_uart_resume_idle(1);
+	omap_uart_resume_idle(0);
 	omap2_gpio_resume_after_retention();
 }
 
@@ -204,6 +211,11 @@ static int omap3_fclks_active(void)
 				  CM_FCLKEN);
 	fck_per = cm_read_mod_reg(OMAP3430_PER_MOD,
 				  CM_FCLKEN);
+
+	/* Ignore UART clocks.  These are handled by UART core (serial.c) */
+	fck_core1 &= ~(OMAP3430_EN_UART1 | OMAP3430_EN_UART2);
+	fck_per &= ~OMAP3430_EN_UART3;
+
 	if (fck_core1 | fck_core3 | fck_sgx | fck_dss |
 	    fck_cam | fck_per | fck_usbhost)
 		return 1;
@@ -212,6 +224,8 @@ static int omap3_fclks_active(void)
 
 static int omap3_can_sleep(void)
 {
+	if (!omap_uart_can_sleep())
+		return 0;
 	if (omap3_fclks_active())
 		return 0;
 	return 1;
@@ -301,6 +315,7 @@ static int omap3_pm_suspend(void)
 			goto restore;
 	}
 
+	omap_uart_prepare_suspend();
 	omap_sram_idle();
 
 restore:

commit 1155e426b7365f7909f5a32612feff7361aa0f4c
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Tue Nov 25 11:48:24 2008 -0800

    OMAP3: PM: Force IVA2 into idle during bootup
    
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 4474947ddd64..b2a8730771e9 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -352,6 +352,54 @@ static struct platform_suspend_ops omap_pm_ops = {
 	.valid		= suspend_valid_only_mem,
 };
 
+
+/**
+ * omap3_iva_idle(): ensure IVA is in idle so it can be put into
+ *                   retention
+ *
+ * In cases where IVA2 is activated by bootcode, it may prevent
+ * full-chip retention or off-mode because it is not idle.  This
+ * function forces the IVA2 into idle state so it can go
+ * into retention/off and thus allow full-chip retention/off.
+ *
+ **/
+static void __init omap3_iva_idle(void)
+{
+	/* ensure IVA2 clock is disabled */
+	cm_write_mod_reg(0, OMAP3430_IVA2_MOD, CM_FCLKEN);
+
+	/* if no clock activity, nothing else to do */
+	if (!(cm_read_mod_reg(OMAP3430_IVA2_MOD, OMAP3430_CM_CLKSTST) &
+	      OMAP3430_CLKACTIVITY_IVA2_MASK))
+		return;
+
+	/* Reset IVA2 */
+	prm_write_mod_reg(OMAP3430_RST1_IVA2 |
+			  OMAP3430_RST2_IVA2 |
+			  OMAP3430_RST3_IVA2,
+			  OMAP3430_IVA2_MOD, RM_RSTCTRL);
+
+	/* Enable IVA2 clock */
+	cm_write_mod_reg(OMAP3430_CM_FCLKEN_IVA2_EN_IVA2,
+			 OMAP3430_IVA2_MOD, CM_FCLKEN);
+
+	/* Set IVA2 boot mode to 'idle' */
+	omap_ctrl_writel(OMAP3_IVA2_BOOTMOD_IDLE,
+			 OMAP343X_CONTROL_IVA2_BOOTMOD);
+
+	/* Un-reset IVA2 */
+	prm_write_mod_reg(0, OMAP3430_IVA2_MOD, RM_RSTCTRL);
+
+	/* Disable IVA2 clock */
+	cm_write_mod_reg(0, OMAP3430_IVA2_MOD, CM_FCLKEN);
+
+	/* Reset IVA2 */
+	prm_write_mod_reg(OMAP3430_RST1_IVA2 |
+			  OMAP3430_RST2_IVA2 |
+			  OMAP3430_RST3_IVA2,
+			  OMAP3430_IVA2_MOD, RM_RSTCTRL);
+}
+
 static void __init prcm_setup_regs(void)
 {
 	/* reset modem */
@@ -511,6 +559,8 @@ static void __init prcm_setup_regs(void)
 	 * it is selected to mpu wakeup goup */
 	prm_write_mod_reg(OMAP3430_IO_EN | OMAP3430_WKUP_EN,
 			  OCP_MOD, OMAP3_PRM_IRQENABLE_MPU_OFFSET);
+
+	omap3_iva_idle();
 }
 
 static int __init pwrdms_setup(struct powerdomain *pwrdm)

commit 8bd229492209c0c7d050e2f9a600c12f035d72f7
Author: Kevin Hilman <khilman@deeprootsystems.com>
Date:   Thu May 28 10:56:16 2009 -0700

    OMAP2/3: PM: push core PM code from linux-omap
    
    This patch is to sync the core linux-omap PM code with mainline.  This
    code has evolved and been used for a while the linux-omap tree, but
    the attempt here is to finally get this into mainline.
    
    Following this will be a series of patches from the 'PM branch' of the
    linux-omap tree to add full PM hardware support from the linux-omap
    tree.
    
    Much of this PM core code was written by Jouni Hogander with
    significant contributions from Paul Walmsley as well as many others
    from Nokia, Texas Instruments and linux-omap community.
    
    Signed-off-by: Jouni Hogander <jouni.hogander@nokia.com>
    Cc: Paul Walmsley <paul@pwsan.com>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
new file mode 100644
index 000000000000..4474947ddd64
--- /dev/null
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -0,0 +1,606 @@
+/*
+ * OMAP3 Power Management Routines
+ *
+ * Copyright (C) 2006-2008 Nokia Corporation
+ * Tony Lindgren <tony@atomide.com>
+ * Jouni Hogander
+ *
+ * Copyright (C) 2005 Texas Instruments, Inc.
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * Based on pm.c for omap1
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/pm.h>
+#include <linux/suspend.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+
+#include <mach/sram.h>
+#include <mach/clockdomain.h>
+#include <mach/powerdomain.h>
+#include <mach/control.h>
+
+#include "cm.h"
+#include "cm-regbits-34xx.h"
+#include "prm-regbits-34xx.h"
+
+#include "prm.h"
+#include "pm.h"
+
+struct power_state {
+	struct powerdomain *pwrdm;
+	u32 next_state;
+	u32 saved_state;
+	struct list_head node;
+};
+
+static LIST_HEAD(pwrst_list);
+
+static void (*_omap_sram_idle)(u32 *addr, int save_state);
+
+static struct powerdomain *mpu_pwrdm;
+
+/* PRCM Interrupt Handler for wakeups */
+static irqreturn_t prcm_interrupt_handler (int irq, void *dev_id)
+{
+	u32 wkst, irqstatus_mpu;
+	u32 fclk, iclk;
+
+	/* WKUP */
+	wkst = prm_read_mod_reg(WKUP_MOD, PM_WKST);
+	if (wkst) {
+		iclk = cm_read_mod_reg(WKUP_MOD, CM_ICLKEN);
+		fclk = cm_read_mod_reg(WKUP_MOD, CM_FCLKEN);
+		cm_set_mod_reg_bits(wkst, WKUP_MOD, CM_ICLKEN);
+		cm_set_mod_reg_bits(wkst, WKUP_MOD, CM_FCLKEN);
+		prm_write_mod_reg(wkst, WKUP_MOD, PM_WKST);
+		while (prm_read_mod_reg(WKUP_MOD, PM_WKST))
+			cpu_relax();
+		cm_write_mod_reg(iclk, WKUP_MOD, CM_ICLKEN);
+		cm_write_mod_reg(fclk, WKUP_MOD, CM_FCLKEN);
+	}
+
+	/* CORE */
+	wkst = prm_read_mod_reg(CORE_MOD, PM_WKST1);
+	if (wkst) {
+		iclk = cm_read_mod_reg(CORE_MOD, CM_ICLKEN1);
+		fclk = cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
+		cm_set_mod_reg_bits(wkst, CORE_MOD, CM_ICLKEN1);
+		cm_set_mod_reg_bits(wkst, CORE_MOD, CM_FCLKEN1);
+		prm_write_mod_reg(wkst, CORE_MOD, PM_WKST1);
+		while (prm_read_mod_reg(CORE_MOD, PM_WKST1))
+			cpu_relax();
+		cm_write_mod_reg(iclk, CORE_MOD, CM_ICLKEN1);
+		cm_write_mod_reg(fclk, CORE_MOD, CM_FCLKEN1);
+	}
+	wkst = prm_read_mod_reg(CORE_MOD, OMAP3430ES2_PM_WKST3);
+	if (wkst) {
+		iclk = cm_read_mod_reg(CORE_MOD, CM_ICLKEN3);
+		fclk = cm_read_mod_reg(CORE_MOD, OMAP3430ES2_CM_FCLKEN3);
+		cm_set_mod_reg_bits(wkst, CORE_MOD, CM_ICLKEN3);
+		cm_set_mod_reg_bits(wkst, CORE_MOD, OMAP3430ES2_CM_FCLKEN3);
+		prm_write_mod_reg(wkst, CORE_MOD, OMAP3430ES2_PM_WKST3);
+		while (prm_read_mod_reg(CORE_MOD, OMAP3430ES2_PM_WKST3))
+			cpu_relax();
+		cm_write_mod_reg(iclk, CORE_MOD, CM_ICLKEN3);
+		cm_write_mod_reg(fclk, CORE_MOD, OMAP3430ES2_CM_FCLKEN3);
+	}
+
+	/* PER */
+	wkst = prm_read_mod_reg(OMAP3430_PER_MOD, PM_WKST);
+	if (wkst) {
+		iclk = cm_read_mod_reg(OMAP3430_PER_MOD, CM_ICLKEN);
+		fclk = cm_read_mod_reg(OMAP3430_PER_MOD, CM_FCLKEN);
+		cm_set_mod_reg_bits(wkst, OMAP3430_PER_MOD, CM_ICLKEN);
+		cm_set_mod_reg_bits(wkst, OMAP3430_PER_MOD, CM_FCLKEN);
+		prm_write_mod_reg(wkst, OMAP3430_PER_MOD, PM_WKST);
+		while (prm_read_mod_reg(OMAP3430_PER_MOD, PM_WKST))
+			cpu_relax();
+		cm_write_mod_reg(iclk, OMAP3430_PER_MOD, CM_ICLKEN);
+		cm_write_mod_reg(fclk, OMAP3430_PER_MOD, CM_FCLKEN);
+	}
+
+	if (omap_rev() > OMAP3430_REV_ES1_0) {
+		/* USBHOST */
+		wkst = prm_read_mod_reg(OMAP3430ES2_USBHOST_MOD, PM_WKST);
+		if (wkst) {
+			iclk = cm_read_mod_reg(OMAP3430ES2_USBHOST_MOD,
+					       CM_ICLKEN);
+			fclk = cm_read_mod_reg(OMAP3430ES2_USBHOST_MOD,
+					       CM_FCLKEN);
+			cm_set_mod_reg_bits(wkst, OMAP3430ES2_USBHOST_MOD,
+					    CM_ICLKEN);
+			cm_set_mod_reg_bits(wkst, OMAP3430ES2_USBHOST_MOD,
+					    CM_FCLKEN);
+			prm_write_mod_reg(wkst, OMAP3430ES2_USBHOST_MOD,
+					  PM_WKST);
+			while (prm_read_mod_reg(OMAP3430ES2_USBHOST_MOD,
+						PM_WKST))
+				cpu_relax();
+			cm_write_mod_reg(iclk, OMAP3430ES2_USBHOST_MOD,
+					 CM_ICLKEN);
+			cm_write_mod_reg(fclk, OMAP3430ES2_USBHOST_MOD,
+					 CM_FCLKEN);
+		}
+	}
+
+	irqstatus_mpu = prm_read_mod_reg(OCP_MOD,
+					 OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
+	prm_write_mod_reg(irqstatus_mpu, OCP_MOD,
+			  OMAP3_PRM_IRQSTATUS_MPU_OFFSET);
+
+	while (prm_read_mod_reg(OCP_MOD, OMAP3_PRM_IRQSTATUS_MPU_OFFSET))
+		cpu_relax();
+
+	return IRQ_HANDLED;
+}
+
+static void omap_sram_idle(void)
+{
+	/* Variable to tell what needs to be saved and restored
+	 * in omap_sram_idle*/
+	/* save_state = 0 => Nothing to save and restored */
+	/* save_state = 1 => Only L1 and logic lost */
+	/* save_state = 2 => Only L2 lost */
+	/* save_state = 3 => L1, L2 and logic lost */
+	int save_state = 0, mpu_next_state;
+
+	if (!_omap_sram_idle)
+		return;
+
+	mpu_next_state = pwrdm_read_next_pwrst(mpu_pwrdm);
+	switch (mpu_next_state) {
+	case PWRDM_POWER_RET:
+		/* No need to save context */
+		save_state = 0;
+		break;
+	default:
+		/* Invalid state */
+		printk(KERN_ERR "Invalid mpu state in sram_idle\n");
+		return;
+	}
+	omap2_gpio_prepare_for_retention();
+
+	_omap_sram_idle(NULL, save_state);
+	cpu_init();
+
+	omap2_gpio_resume_after_retention();
+}
+
+/*
+ * Check if functional clocks are enabled before entering
+ * sleep. This function could be behind CONFIG_PM_DEBUG
+ * when all drivers are configuring their sysconfig registers
+ * properly and using their clocks properly.
+ */
+static int omap3_fclks_active(void)
+{
+	u32 fck_core1 = 0, fck_core3 = 0, fck_sgx = 0, fck_dss = 0,
+		fck_cam = 0, fck_per = 0, fck_usbhost = 0;
+
+	fck_core1 = cm_read_mod_reg(CORE_MOD,
+				    CM_FCLKEN1);
+	if (omap_rev() > OMAP3430_REV_ES1_0) {
+		fck_core3 = cm_read_mod_reg(CORE_MOD,
+					    OMAP3430ES2_CM_FCLKEN3);
+		fck_sgx = cm_read_mod_reg(OMAP3430ES2_SGX_MOD,
+					  CM_FCLKEN);
+		fck_usbhost = cm_read_mod_reg(OMAP3430ES2_USBHOST_MOD,
+					      CM_FCLKEN);
+	} else
+		fck_sgx = cm_read_mod_reg(GFX_MOD,
+					  OMAP3430ES2_CM_FCLKEN3);
+	fck_dss = cm_read_mod_reg(OMAP3430_DSS_MOD,
+				  CM_FCLKEN);
+	fck_cam = cm_read_mod_reg(OMAP3430_CAM_MOD,
+				  CM_FCLKEN);
+	fck_per = cm_read_mod_reg(OMAP3430_PER_MOD,
+				  CM_FCLKEN);
+	if (fck_core1 | fck_core3 | fck_sgx | fck_dss |
+	    fck_cam | fck_per | fck_usbhost)
+		return 1;
+	return 0;
+}
+
+static int omap3_can_sleep(void)
+{
+	if (omap3_fclks_active())
+		return 0;
+	return 1;
+}
+
+/* This sets pwrdm state (other than mpu & core. Currently only ON &
+ * RET are supported. Function is assuming that clkdm doesn't have
+ * hw_sup mode enabled. */
+static int set_pwrdm_state(struct powerdomain *pwrdm, u32 state)
+{
+	u32 cur_state;
+	int sleep_switch = 0;
+	int ret = 0;
+
+	if (pwrdm == NULL || IS_ERR(pwrdm))
+		return -EINVAL;
+
+	while (!(pwrdm->pwrsts & (1 << state))) {
+		if (state == PWRDM_POWER_OFF)
+			return ret;
+		state--;
+	}
+
+	cur_state = pwrdm_read_next_pwrst(pwrdm);
+	if (cur_state == state)
+		return ret;
+
+	if (pwrdm_read_pwrst(pwrdm) < PWRDM_POWER_ON) {
+		omap2_clkdm_wakeup(pwrdm->pwrdm_clkdms[0]);
+		sleep_switch = 1;
+		pwrdm_wait_transition(pwrdm);
+	}
+
+	ret = pwrdm_set_next_pwrst(pwrdm, state);
+	if (ret) {
+		printk(KERN_ERR "Unable to set state of powerdomain: %s\n",
+		       pwrdm->name);
+		goto err;
+	}
+
+	if (sleep_switch) {
+		omap2_clkdm_allow_idle(pwrdm->pwrdm_clkdms[0]);
+		pwrdm_wait_transition(pwrdm);
+	}
+
+err:
+	return ret;
+}
+
+static void omap3_pm_idle(void)
+{
+	local_irq_disable();
+	local_fiq_disable();
+
+	if (!omap3_can_sleep())
+		goto out;
+
+	if (omap_irq_pending())
+		goto out;
+
+	omap_sram_idle();
+
+out:
+	local_fiq_enable();
+	local_irq_enable();
+}
+
+static int omap3_pm_prepare(void)
+{
+	disable_hlt();
+	return 0;
+}
+
+static int omap3_pm_suspend(void)
+{
+	struct power_state *pwrst;
+	int state, ret = 0;
+
+	/* Read current next_pwrsts */
+	list_for_each_entry(pwrst, &pwrst_list, node)
+		pwrst->saved_state = pwrdm_read_next_pwrst(pwrst->pwrdm);
+	/* Set ones wanted by suspend */
+	list_for_each_entry(pwrst, &pwrst_list, node) {
+		if (set_pwrdm_state(pwrst->pwrdm, pwrst->next_state))
+			goto restore;
+		if (pwrdm_clear_all_prev_pwrst(pwrst->pwrdm))
+			goto restore;
+	}
+
+	omap_sram_idle();
+
+restore:
+	/* Restore next_pwrsts */
+	list_for_each_entry(pwrst, &pwrst_list, node) {
+		set_pwrdm_state(pwrst->pwrdm, pwrst->saved_state);
+		state = pwrdm_read_prev_pwrst(pwrst->pwrdm);
+		if (state > pwrst->next_state) {
+			printk(KERN_INFO "Powerdomain (%s) didn't enter "
+			       "target state %d\n",
+			       pwrst->pwrdm->name, pwrst->next_state);
+			ret = -1;
+		}
+	}
+	if (ret)
+		printk(KERN_ERR "Could not enter target state in pm_suspend\n");
+	else
+		printk(KERN_INFO "Successfully put all powerdomains "
+		       "to target state\n");
+
+	return ret;
+}
+
+static int omap3_pm_enter(suspend_state_t state)
+{
+	int ret = 0;
+
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+	case PM_SUSPEND_MEM:
+		ret = omap3_pm_suspend();
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static void omap3_pm_finish(void)
+{
+	enable_hlt();
+}
+
+static struct platform_suspend_ops omap_pm_ops = {
+	.prepare	= omap3_pm_prepare,
+	.enter		= omap3_pm_enter,
+	.finish		= omap3_pm_finish,
+	.valid		= suspend_valid_only_mem,
+};
+
+static void __init prcm_setup_regs(void)
+{
+	/* reset modem */
+	prm_write_mod_reg(OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RSTPWRON |
+			  OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RST,
+			  CORE_MOD, RM_RSTCTRL);
+	prm_write_mod_reg(0, CORE_MOD, RM_RSTCTRL);
+
+	/* XXX Reset all wkdeps. This should be done when initializing
+	 * powerdomains */
+	prm_write_mod_reg(0, OMAP3430_IVA2_MOD, PM_WKDEP);
+	prm_write_mod_reg(0, MPU_MOD, PM_WKDEP);
+	prm_write_mod_reg(0, OMAP3430_DSS_MOD, PM_WKDEP);
+	prm_write_mod_reg(0, OMAP3430_NEON_MOD, PM_WKDEP);
+	prm_write_mod_reg(0, OMAP3430_CAM_MOD, PM_WKDEP);
+	prm_write_mod_reg(0, OMAP3430_PER_MOD, PM_WKDEP);
+	if (omap_rev() > OMAP3430_REV_ES1_0) {
+		prm_write_mod_reg(0, OMAP3430ES2_SGX_MOD, PM_WKDEP);
+		prm_write_mod_reg(0, OMAP3430ES2_USBHOST_MOD, PM_WKDEP);
+	} else
+		prm_write_mod_reg(0, GFX_MOD, PM_WKDEP);
+
+	/*
+	 * Enable interface clock autoidle for all modules.
+	 * Note that in the long run this should be done by clockfw
+	 */
+	cm_write_mod_reg(
+		OMAP3430ES2_AUTO_MMC3 |
+		OMAP3430ES2_AUTO_ICR |
+		OMAP3430_AUTO_AES2 |
+		OMAP3430_AUTO_SHA12 |
+		OMAP3430_AUTO_DES2 |
+		OMAP3430_AUTO_MMC2 |
+		OMAP3430_AUTO_MMC1 |
+		OMAP3430_AUTO_MSPRO |
+		OMAP3430_AUTO_HDQ |
+		OMAP3430_AUTO_MCSPI4 |
+		OMAP3430_AUTO_MCSPI3 |
+		OMAP3430_AUTO_MCSPI2 |
+		OMAP3430_AUTO_MCSPI1 |
+		OMAP3430_AUTO_I2C3 |
+		OMAP3430_AUTO_I2C2 |
+		OMAP3430_AUTO_I2C1 |
+		OMAP3430_AUTO_UART2 |
+		OMAP3430_AUTO_UART1 |
+		OMAP3430_AUTO_GPT11 |
+		OMAP3430_AUTO_GPT10 |
+		OMAP3430_AUTO_MCBSP5 |
+		OMAP3430_AUTO_MCBSP1 |
+		OMAP3430ES1_AUTO_FAC | /* This is es1 only */
+		OMAP3430_AUTO_MAILBOXES |
+		OMAP3430_AUTO_OMAPCTRL |
+		OMAP3430ES1_AUTO_FSHOSTUSB |
+		OMAP3430_AUTO_HSOTGUSB |
+		OMAP3430ES1_AUTO_D2D | /* This is es1 only */
+		OMAP3430_AUTO_SSI,
+		CORE_MOD, CM_AUTOIDLE1);
+
+	cm_write_mod_reg(
+		OMAP3430_AUTO_PKA |
+		OMAP3430_AUTO_AES1 |
+		OMAP3430_AUTO_RNG |
+		OMAP3430_AUTO_SHA11 |
+		OMAP3430_AUTO_DES1,
+		CORE_MOD, CM_AUTOIDLE2);
+
+	if (omap_rev() > OMAP3430_REV_ES1_0) {
+		cm_write_mod_reg(
+			OMAP3430ES2_AUTO_USBTLL,
+			CORE_MOD, CM_AUTOIDLE3);
+	}
+
+	cm_write_mod_reg(
+		OMAP3430_AUTO_WDT2 |
+		OMAP3430_AUTO_WDT1 |
+		OMAP3430_AUTO_GPIO1 |
+		OMAP3430_AUTO_32KSYNC |
+		OMAP3430_AUTO_GPT12 |
+		OMAP3430_AUTO_GPT1 ,
+		WKUP_MOD, CM_AUTOIDLE);
+
+	cm_write_mod_reg(
+		OMAP3430_AUTO_DSS,
+		OMAP3430_DSS_MOD,
+		CM_AUTOIDLE);
+
+	cm_write_mod_reg(
+		OMAP3430_AUTO_CAM,
+		OMAP3430_CAM_MOD,
+		CM_AUTOIDLE);
+
+	cm_write_mod_reg(
+		OMAP3430_AUTO_GPIO6 |
+		OMAP3430_AUTO_GPIO5 |
+		OMAP3430_AUTO_GPIO4 |
+		OMAP3430_AUTO_GPIO3 |
+		OMAP3430_AUTO_GPIO2 |
+		OMAP3430_AUTO_WDT3 |
+		OMAP3430_AUTO_UART3 |
+		OMAP3430_AUTO_GPT9 |
+		OMAP3430_AUTO_GPT8 |
+		OMAP3430_AUTO_GPT7 |
+		OMAP3430_AUTO_GPT6 |
+		OMAP3430_AUTO_GPT5 |
+		OMAP3430_AUTO_GPT4 |
+		OMAP3430_AUTO_GPT3 |
+		OMAP3430_AUTO_GPT2 |
+		OMAP3430_AUTO_MCBSP4 |
+		OMAP3430_AUTO_MCBSP3 |
+		OMAP3430_AUTO_MCBSP2,
+		OMAP3430_PER_MOD,
+		CM_AUTOIDLE);
+
+	if (omap_rev() > OMAP3430_REV_ES1_0) {
+		cm_write_mod_reg(
+			OMAP3430ES2_AUTO_USBHOST,
+			OMAP3430ES2_USBHOST_MOD,
+			CM_AUTOIDLE);
+	}
+
+	/*
+	 * Set all plls to autoidle. This is needed until autoidle is
+	 * enabled by clockfw
+	 */
+	cm_write_mod_reg(1 << OMAP3430_AUTO_IVA2_DPLL_SHIFT,
+			 OMAP3430_IVA2_MOD, CM_AUTOIDLE2);
+	cm_write_mod_reg(1 << OMAP3430_AUTO_MPU_DPLL_SHIFT,
+			 MPU_MOD,
+			 CM_AUTOIDLE2);
+	cm_write_mod_reg((1 << OMAP3430_AUTO_PERIPH_DPLL_SHIFT) |
+			 (1 << OMAP3430_AUTO_CORE_DPLL_SHIFT),
+			 PLL_MOD,
+			 CM_AUTOIDLE);
+	cm_write_mod_reg(1 << OMAP3430ES2_AUTO_PERIPH2_DPLL_SHIFT,
+			 PLL_MOD,
+			 CM_AUTOIDLE2);
+
+	/*
+	 * Enable control of expternal oscillator through
+	 * sys_clkreq. In the long run clock framework should
+	 * take care of this.
+	 */
+	prm_rmw_mod_reg_bits(OMAP_AUTOEXTCLKMODE_MASK,
+			     1 << OMAP_AUTOEXTCLKMODE_SHIFT,
+			     OMAP3430_GR_MOD,
+			     OMAP3_PRM_CLKSRC_CTRL_OFFSET);
+
+	/* setup wakup source */
+	prm_write_mod_reg(OMAP3430_EN_IO | OMAP3430_EN_GPIO1 |
+			  OMAP3430_EN_GPT1 | OMAP3430_EN_GPT12,
+			  WKUP_MOD, PM_WKEN);
+	/* No need to write EN_IO, that is always enabled */
+	prm_write_mod_reg(OMAP3430_EN_GPIO1 | OMAP3430_EN_GPT1 |
+			  OMAP3430_EN_GPT12,
+			  WKUP_MOD, OMAP3430_PM_MPUGRPSEL);
+	/* For some reason IO doesn't generate wakeup event even if
+	 * it is selected to mpu wakeup goup */
+	prm_write_mod_reg(OMAP3430_IO_EN | OMAP3430_WKUP_EN,
+			  OCP_MOD, OMAP3_PRM_IRQENABLE_MPU_OFFSET);
+}
+
+static int __init pwrdms_setup(struct powerdomain *pwrdm)
+{
+	struct power_state *pwrst;
+
+	if (!pwrdm->pwrsts)
+		return 0;
+
+	pwrst = kmalloc(sizeof(struct power_state), GFP_KERNEL);
+	if (!pwrst)
+		return -ENOMEM;
+	pwrst->pwrdm = pwrdm;
+	pwrst->next_state = PWRDM_POWER_RET;
+	list_add(&pwrst->node, &pwrst_list);
+
+	if (pwrdm_has_hdwr_sar(pwrdm))
+		pwrdm_enable_hdwr_sar(pwrdm);
+
+	return set_pwrdm_state(pwrst->pwrdm, pwrst->next_state);
+}
+
+/*
+ * Enable hw supervised mode for all clockdomains if it's
+ * supported. Initiate sleep transition for other clockdomains, if
+ * they are not used
+ */
+static int __init clkdms_setup(struct clockdomain *clkdm)
+{
+	if (clkdm->flags & CLKDM_CAN_ENABLE_AUTO)
+		omap2_clkdm_allow_idle(clkdm);
+	else if (clkdm->flags & CLKDM_CAN_FORCE_SLEEP &&
+		 atomic_read(&clkdm->usecount) == 0)
+		omap2_clkdm_sleep(clkdm);
+	return 0;
+}
+
+int __init omap3_pm_init(void)
+{
+	struct power_state *pwrst, *tmp;
+	int ret;
+
+	if (!cpu_is_omap34xx())
+		return -ENODEV;
+
+	printk(KERN_ERR "Power Management for TI OMAP3.\n");
+
+	/* XXX prcm_setup_regs needs to be before enabling hw
+	 * supervised mode for powerdomains */
+	prcm_setup_regs();
+
+	ret = request_irq(INT_34XX_PRCM_MPU_IRQ,
+			  (irq_handler_t)prcm_interrupt_handler,
+			  IRQF_DISABLED, "prcm", NULL);
+	if (ret) {
+		printk(KERN_ERR "request_irq failed to register for 0x%x\n",
+		       INT_34XX_PRCM_MPU_IRQ);
+		goto err1;
+	}
+
+	ret = pwrdm_for_each(pwrdms_setup);
+	if (ret) {
+		printk(KERN_ERR "Failed to setup powerdomains\n");
+		goto err2;
+	}
+
+	(void) clkdm_for_each(clkdms_setup);
+
+	mpu_pwrdm = pwrdm_lookup("mpu_pwrdm");
+	if (mpu_pwrdm == NULL) {
+		printk(KERN_ERR "Failed to get mpu_pwrdm\n");
+		goto err2;
+	}
+
+	_omap_sram_idle = omap_sram_push(omap34xx_cpu_suspend,
+					 omap34xx_cpu_suspend_sz);
+
+	suspend_set_ops(&omap_pm_ops);
+
+	pm_idle = omap3_pm_idle;
+
+err1:
+	return ret;
+err2:
+	free_irq(INT_34XX_PRCM_MPU_IRQ, NULL);
+	list_for_each_entry_safe(pwrst, tmp, &pwrst_list, node) {
+		list_del(&pwrst->node);
+		kfree(pwrst);
+	}
+	return ret;
+}
+
+late_initcall(omap3_pm_init);
