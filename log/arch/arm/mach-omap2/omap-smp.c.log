commit 90d0ce39f8b088a3f227acd79d79b5ccf5a091b3
Author: Ma Feng <mafeng.ma@huawei.com>
Date:   Mon May 11 20:21:44 2020 +0800

    ARM: omap2: make omap5_erratum_workaround_801819 static
    
    Fix sparse warning:
    
    arch/arm/mach-omap2/omap-smp.c:75:6: warning: symbol
    'omap5_erratum_workaround_801819' was not declared. Should it be static?
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Ma Feng <mafeng.ma@huawei.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 6a82fce3f822..570a987e6d1a 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -72,7 +72,7 @@ void __iomem *omap4_get_scu_base(void)
 }
 
 #ifdef CONFIG_OMAP5_ERRATA_801819
-void omap5_erratum_workaround_801819(void)
+static void omap5_erratum_workaround_801819(void)
 {
 	u32 acr, revidr;
 	u32 acr_mask;

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 10e070368f64..6a82fce3f822 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * OMAP4 SMP source file. It contains platform specific functions
  * needed for the linux smp kernel.
@@ -10,10 +11,6 @@
  * Platform file needed for the OMAP4 SMP. This file is based on arm
  * realview smp platform.
  * * Copyright (c) 2002 ARM Limited.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 #include <linux/init.h>
 #include <linux/device.h>

commit 07a496de4c7eb0b1e80ab53f9d6465ea55ac1bd7
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Thu Dec 13 12:54:26 2018 +0000

    ARM: omap2: remove unnecessary boot_lock
    
    The boot_lock is something that was required for ARM development
    platforms to ensure that the delay calibration worked properly.  This
    is not necessary for modern platforms that have better bus bandwidth
    and do not need to calibrate the delay loop for secondary cores.
    Remove the boot_lock entirely.
    
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 1c73694c871a..10e070368f64 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -69,8 +69,6 @@ static const struct omap_smp_config omap5_cfg __initconst = {
 	.startup_addr = omap5_secondary_startup,
 };
 
-static DEFINE_SPINLOCK(boot_lock);
-
 void __iomem *omap4_get_scu_base(void)
 {
 	return cfg.scu_base;
@@ -173,12 +171,6 @@ static void omap4_secondary_init(unsigned int cpu)
 		/* Enable ACR to allow for ICUALLU workaround */
 		omap5_secondary_harden_predictor();
 	}
-
-	/*
-	 * Synchronise with the boot thread.
-	 */
-	spin_lock(&boot_lock);
-	spin_unlock(&boot_lock);
 }
 
 static int omap4_boot_secondary(unsigned int cpu, struct task_struct *idle)
@@ -187,12 +179,6 @@ static int omap4_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	static bool booted;
 	static struct powerdomain *cpu1_pwrdm;
 
-	/*
-	 * Set synchronisation state between this boot processor
-	 * and the secondary one
-	 */
-	spin_lock(&boot_lock);
-
 	/*
 	 * Update the AuxCoreBoot0 with boot state for secondary core.
 	 * omap4_secondary_startup() routine will hold the secondary core till
@@ -266,12 +252,6 @@ static int omap4_boot_secondary(unsigned int cpu, struct task_struct *idle)
 
 	arch_send_wakeup_ipi_mask(cpumask_of(cpu));
 
-	/*
-	 * Now the secondary core is starting up let it run its
-	 * calibrations, then wait for it to finish
-	 */
-	spin_unlock(&boot_lock);
-
 	return 0;
 }
 

commit 2f8b5b21830aea95989a6e67d8a971297272a086
Author: Nishanth Menon <nm@ti.com>
Date:   Tue Jul 10 14:47:25 2018 -0500

    ARM: DRA7/OMAP5: Enable ACTLR[0] (Enable invalidates of BTB) for secondary cores
    
    Call secure services to enable ACTLR[0] (Enable invalidates of BTB with
    ICIALLU) when branch hardening is enabled for kernel.
    
    On GP devices OMAP5/DRA7, there is no possibility to update secure
    side since "secure world" is ROM and there are no override mechanisms
    possible. On HS devices, appropriate PPA should do the workarounds as
    well.
    
    However, the configuration is only done for secondary core, since it is
    expected that firmware/bootloader will have enabled the required
    configuration for the primary boot core (note: bootloaders typically
    will NOT enable secondary processors, since it has no need to do so).
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 69df3620eca5..1c73694c871a 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -109,6 +109,45 @@ void omap5_erratum_workaround_801819(void)
 static inline void omap5_erratum_workaround_801819(void) { }
 #endif
 
+#ifdef CONFIG_HARDEN_BRANCH_PREDICTOR
+/*
+ * Configure ACR and enable ACTLR[0] (Enable invalidates of BTB with
+ * ICIALLU) to activate the workaround for secondary Core.
+ * NOTE: it is assumed that the primary core's configuration is done
+ * by the boot loader (kernel will detect a misconfiguration and complain
+ * if this is not done).
+ *
+ * In General Purpose(GP) devices, ACR bit settings can only be done
+ * by ROM code in "secure world" using the smc call and there is no
+ * option to update the "firmware" on such devices. This also works for
+ * High security(HS) devices, as a backup option in case the
+ * "update" is not done in the "security firmware".
+ */
+static void omap5_secondary_harden_predictor(void)
+{
+	u32 acr, acr_mask;
+
+	asm volatile ("mrc p15, 0, %0, c1, c0, 1" : "=r" (acr));
+
+	/*
+	 * ACTLR[0] (Enable invalidates of BTB with ICIALLU)
+	 */
+	acr_mask = BIT(0);
+
+	/* Do we already have it done.. if yes, skip expensive smc */
+	if ((acr & acr_mask) == acr_mask)
+		return;
+
+	acr |= acr_mask;
+	omap_smc1(OMAP5_DRA7_MON_SET_ACR_INDEX, acr);
+
+	pr_debug("%s: ARM ACR setup for CVE_2017_5715 applied on CPU%d\n",
+		 __func__, smp_processor_id());
+}
+#else
+static inline void omap5_secondary_harden_predictor(void) { }
+#endif
+
 static void omap4_secondary_init(unsigned int cpu)
 {
 	/*
@@ -131,6 +170,8 @@ static void omap4_secondary_init(unsigned int cpu)
 		set_cntfreq();
 		/* Configure ACR to disable streaming WA for 801819 */
 		omap5_erratum_workaround_801819();
+		/* Enable ACR to allow for ICUALLU workaround */
+		omap5_secondary_harden_predictor();
 	}
 
 	/*

commit 59895a7b411c39f05ec8950df6aec0624e6614a3
Author: Lokesh Vutla <lokeshvutla@ti.com>
Date:   Sat Aug 12 09:36:01 2017 +0530

    ARM: dra762: Enable SMP for dra762
    
    smp specific routines are called based on soc_is_*() api in omap-smc.c.
    Add soc_is_dra76x() to the condition so that smp specific routines are
    called for dra76 SoC.
    
    Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 33e4953c61a8..69df3620eca5 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -342,7 +342,7 @@ static void __init omap4_smp_prepare_cpus(unsigned int max_cpus)
 		c = &omap443x_cfg;
 	else if (soc_is_omap446x())
 		c = &omap446x_cfg;
-	else if (soc_is_dra74x() || soc_is_omap54xx())
+	else if (soc_is_dra74x() || soc_is_omap54xx() || soc_is_dra76x())
 		c = &omap5_cfg;
 
 	if (!c) {
@@ -355,7 +355,7 @@ static void __init omap4_smp_prepare_cpus(unsigned int max_cpus)
 	cfg.startup_addr = c->startup_addr;
 	cfg.wakeupgen_base = omap_get_wakeupgen_base();
 
-	if (soc_is_dra74x() || soc_is_omap54xx()) {
+	if (soc_is_dra74x() || soc_is_omap54xx() || soc_is_dra76x()) {
 		if ((__boot_cpu_mode & MODE_MASK) == HYP_MODE)
 			cfg.startup_addr = omap5_secondary_hyp_startup;
 		omap5_erratum_workaround_801819();

commit 6f92120892d94ef6c551da5aa2cf7bc9401c9903
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Apr 21 23:55:28 2017 +0200

    ARM: omap2+: make omap4_get_cpu1_ns_pa_addr declaration usable
    
    When CONFIG_PM is disabled, we get a build error:
    
    arch/arm/mach-omap2/omap-smp.c: In function 'omap4_smp_maybe_reset_cpu1':
    arch/arm/mach-omap2/omap-smp.c:309:20: error: implicit declaration of function 'omap4_get_cpu1_ns_pa_addr'; did you mean 'omap4_get_scu_base'? [-Werror=implicit-function-declaration]
    
    We need to fix this in multiple files, to ensure the declaration is visible,
    to actually build the function without CONFIG_PM, and to only call it
    when OMAP4 and/or OMAP5 are enabled.
    
    Fixes: 351b7c490700 ("ARM: omap2+: Revert omap-smp.c changes resetting CPU1 during boot")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 3faf454ba487..33e4953c61a8 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -306,7 +306,6 @@ static void __init omap4_smp_maybe_reset_cpu1(struct omap_smp_config *c)
 
 	cpu1_startup_pa = readl_relaxed(cfg.wakeupgen_base +
 					OMAP_AUX_CORE_BOOT_1);
-	cpu1_ns_pa_addr = omap4_get_cpu1_ns_pa_addr();
 
 	/* Did the configured secondary_startup() get overwritten? */
 	if (!omap4_smp_cpu1_startup_valid(cpu1_startup_pa))
@@ -316,9 +315,13 @@ static void __init omap4_smp_maybe_reset_cpu1(struct omap_smp_config *c)
 	 * If omap4 or 5 has NS_PA_ADDR configured, CPU1 may be in a
 	 * deeper idle state in WFI and will wake to an invalid address.
 	 */
-	if ((soc_is_omap44xx() || soc_is_omap54xx()) &&
-	    !omap4_smp_cpu1_startup_valid(cpu1_ns_pa_addr))
-		needs_reset = true;
+	if ((soc_is_omap44xx() || soc_is_omap54xx())) {
+		cpu1_ns_pa_addr = omap4_get_cpu1_ns_pa_addr();
+		if (!omap4_smp_cpu1_startup_valid(cpu1_ns_pa_addr))
+			needs_reset = true;
+	} else {
+		cpu1_ns_pa_addr = 0;
+	}
 
 	if (!needs_reset || !c->cpu1_rstctrl_va)
 		return;

commit 351b7c490700747d1dba1b0a10fbfe3448d11c35
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Mar 22 11:01:48 2017 -0700

    ARM: omap2+: Revert omap-smp.c changes resetting CPU1 during boot
    
    Commit 3251885285e1 ("ARM: OMAP4+: Reset CPU1 properly for kexec") started
    unconditionally resetting CPU1 because of a kexec boot issue I was seeing
    earlier on omap4 when doing kexec boot between two different kernel
    versions.
    
    This caused issues on some systems. We should only reset CPU1 as a last
    resort option, and try to avoid it where possible. Doing an unconditional
    CPU1 reset causes issues for example when booting a bootloader configured
    secure OS running on CPU1 as reported by Andrew F. Davis <afd@ti.com>.
    
    We can't completely remove the reset of CPU1 as it would break kexec
    booting from older kernels. But we can limit the CPU1 reset to cases
    where CPU1 is wrongly parked within the memory area used by the booting
    kernel. Then later on we can add support for parking CPU1 for kexec out
    of the SDRAM back to bootrom.
    
    So let's first fix the regression reported by Andrew by making CPU1 reset
    conditional. To do this, we need to:
    
    1. Save configured AUX_CORE_BOOT_1 for later
    
    2. Modify AUX_CORE_BOOT_0 reading code to for HS SoCs to return
       the whole register instead of the CPU mask
    
    3. Check if CPU1 is wrongly parked into the booting kernel by the
       previous kernel and reset if needed
    
    Fixes: 3251885285e1 ("ARM: OMAP4+: Reset CPU1 properly for kexec")
    Reported-by: Andrew F. Davis <afd@ti.com>
    Cc: Andrew F. Davis <afd@ti.com>
    Cc: Keerthy <j-keerthy@ti.com>
    Cc: Russell King <rmk+kernel@armlinux.org.uk>
    Cc: Santosh Shilimkar <ssantosh@kernel.org>
    Cc: Tero Kristo <t-kristo@ti.com>
    Tested-by: Keerthy <j-keerthy@ti.com>
    Tested-by: Andrew F. Davis <afd@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 003353b0b794..3faf454ba487 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -21,6 +21,7 @@
 #include <linux/io.h>
 #include <linux/irqchip/arm-gic.h>
 
+#include <asm/sections.h>
 #include <asm/smp_scu.h>
 #include <asm/virt.h>
 
@@ -40,10 +41,14 @@
 
 #define OMAP5_CORE_COUNT	0x2
 
+#define AUX_CORE_BOOT0_GP_RELEASE	0x020
+#define AUX_CORE_BOOT0_HS_RELEASE	0x200
+
 struct omap_smp_config {
 	unsigned long cpu1_rstctrl_pa;
 	void __iomem *cpu1_rstctrl_va;
 	void __iomem *scu_base;
+	void __iomem *wakeupgen_base;
 	void *startup_addr;
 };
 
@@ -140,7 +145,6 @@ static int omap4_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	static struct clockdomain *cpu1_clkdm;
 	static bool booted;
 	static struct powerdomain *cpu1_pwrdm;
-	void __iomem *base = omap_get_wakeupgen_base();
 
 	/*
 	 * Set synchronisation state between this boot processor
@@ -155,9 +159,11 @@ static int omap4_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	 * A barrier is added to ensure that write buffer is drained
 	 */
 	if (omap_secure_apis_support())
-		omap_modify_auxcoreboot0(0x200, 0xfffffdff);
+		omap_modify_auxcoreboot0(AUX_CORE_BOOT0_HS_RELEASE,
+					 0xfffffdff);
 	else
-		writel_relaxed(0x20, base + OMAP_AUX_CORE_BOOT_0);
+		writel_relaxed(AUX_CORE_BOOT0_GP_RELEASE,
+			       cfg.wakeupgen_base + OMAP_AUX_CORE_BOOT_0);
 
 	if (!cpu1_clkdm && !cpu1_pwrdm) {
 		cpu1_clkdm = clkdm_lookup("mpu1_clkdm");
@@ -261,9 +267,72 @@ static void __init omap4_smp_init_cpus(void)
 		set_cpu_possible(i, true);
 }
 
+/*
+ * For now, just make sure the start-up address is not within the booting
+ * kernel space as that means we just overwrote whatever secondary_startup()
+ * code there was.
+ */
+static bool __init omap4_smp_cpu1_startup_valid(unsigned long addr)
+{
+	if ((addr >= __pa(PAGE_OFFSET)) && (addr <= __pa(__bss_start)))
+		return false;
+
+	return true;
+}
+
+/*
+ * We may need to reset CPU1 before configuring, otherwise kexec boot can end
+ * up trying to use old kernel startup address or suspend-resume will
+ * occasionally fail to bring up CPU1 on 4430 if CPU1 fails to enter deeper
+ * idle states.
+ */
+static void __init omap4_smp_maybe_reset_cpu1(struct omap_smp_config *c)
+{
+	unsigned long cpu1_startup_pa, cpu1_ns_pa_addr;
+	bool needs_reset = false;
+	u32 released;
+
+	if (omap_secure_apis_support())
+		released = omap_read_auxcoreboot0() & AUX_CORE_BOOT0_HS_RELEASE;
+	else
+		released = readl_relaxed(cfg.wakeupgen_base +
+					 OMAP_AUX_CORE_BOOT_0) &
+						AUX_CORE_BOOT0_GP_RELEASE;
+	if (released) {
+		pr_warn("smp: CPU1 not parked?\n");
+
+		return;
+	}
+
+	cpu1_startup_pa = readl_relaxed(cfg.wakeupgen_base +
+					OMAP_AUX_CORE_BOOT_1);
+	cpu1_ns_pa_addr = omap4_get_cpu1_ns_pa_addr();
+
+	/* Did the configured secondary_startup() get overwritten? */
+	if (!omap4_smp_cpu1_startup_valid(cpu1_startup_pa))
+		needs_reset = true;
+
+	/*
+	 * If omap4 or 5 has NS_PA_ADDR configured, CPU1 may be in a
+	 * deeper idle state in WFI and will wake to an invalid address.
+	 */
+	if ((soc_is_omap44xx() || soc_is_omap54xx()) &&
+	    !omap4_smp_cpu1_startup_valid(cpu1_ns_pa_addr))
+		needs_reset = true;
+
+	if (!needs_reset || !c->cpu1_rstctrl_va)
+		return;
+
+	pr_info("smp: CPU1 parked within kernel, needs reset (0x%lx 0x%lx)\n",
+		cpu1_startup_pa, cpu1_ns_pa_addr);
+
+	writel_relaxed(1, c->cpu1_rstctrl_va);
+	readl_relaxed(c->cpu1_rstctrl_va);
+	writel_relaxed(0, c->cpu1_rstctrl_va);
+}
+
 static void __init omap4_smp_prepare_cpus(unsigned int max_cpus)
 {
-	void __iomem *base = omap_get_wakeupgen_base();
 	const struct omap_smp_config *c = NULL;
 
 	if (soc_is_omap443x())
@@ -281,6 +350,7 @@ static void __init omap4_smp_prepare_cpus(unsigned int max_cpus)
 	/* Must preserve cfg.scu_base set earlier */
 	cfg.cpu1_rstctrl_pa = c->cpu1_rstctrl_pa;
 	cfg.startup_addr = c->startup_addr;
+	cfg.wakeupgen_base = omap_get_wakeupgen_base();
 
 	if (soc_is_dra74x() || soc_is_omap54xx()) {
 		if ((__boot_cpu_mode & MODE_MASK) == HYP_MODE)
@@ -299,15 +369,7 @@ static void __init omap4_smp_prepare_cpus(unsigned int max_cpus)
 	if (cfg.scu_base)
 		scu_enable(cfg.scu_base);
 
-	/*
-	 * Reset CPU1 before configuring, otherwise kexec will
-	 * end up trying to use old kernel startup address.
-	 */
-	if (cfg.cpu1_rstctrl_va) {
-		writel_relaxed(1, cfg.cpu1_rstctrl_va);
-		readl_relaxed(cfg.cpu1_rstctrl_va);
-		writel_relaxed(0, cfg.cpu1_rstctrl_va);
-	}
+	omap4_smp_maybe_reset_cpu1(&cfg);
 
 	/*
 	 * Write the address of secondary startup routine into the
@@ -319,7 +381,7 @@ static void __init omap4_smp_prepare_cpus(unsigned int max_cpus)
 		omap_auxcoreboot_addr(__pa_symbol(cfg.startup_addr));
 	else
 		writel_relaxed(__pa_symbol(cfg.startup_addr),
-			       base + OMAP_AUX_CORE_BOOT_1);
+			       cfg.wakeupgen_base + OMAP_AUX_CORE_BOOT_1);
 }
 
 const struct smp_operations omap4_smp_ops __initconst = {

commit 64fc2a947a9873700929ec0ef02b4654a04e0476
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sun Jan 15 03:59:29 2017 +0100

    ARM: 8641/1: treewide: Replace uses of virt_to_phys with __pa_symbol
    
    All low-level PM/SMP code using virt_to_phys() should actually use
    __pa_symbol() against kernel symbols. Update code where relevant to move
    away from virt_to_phys().
    
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Reviewed-by: Laura Abbott <labbott@redhat.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index b4de3da6dffa..003353b0b794 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -316,9 +316,9 @@ static void __init omap4_smp_prepare_cpus(unsigned int max_cpus)
 	 * A barrier is added to ensure that write buffer is drained
 	 */
 	if (omap_secure_apis_support())
-		omap_auxcoreboot_addr(virt_to_phys(cfg.startup_addr));
+		omap_auxcoreboot_addr(__pa_symbol(cfg.startup_addr));
 	else
-		writel_relaxed(virt_to_phys(cfg.startup_addr),
+		writel_relaxed(__pa_symbol(cfg.startup_addr),
 			       base + OMAP_AUX_CORE_BOOT_1);
 }
 

commit 1d9a5425654de6bb141c7ca1d5dde120ee8c5430
Author: Tero Kristo <t-kristo@ti.com>
Date:   Thu Jun 30 16:15:02 2016 +0300

    ARM: OMAP2+: clockdomain: add usecounting support to autoidle APIs
    
    The previous implementation was racy in many locations, where the current
    status of the clockdomain was read out, some operations were executed,
    and the previous status info was used afterwards to decide next state
    for the clockdomain. Instead, fix the implementation of the allow_idle /
    deny_idle APIs to properly have usecounting support. This allows clean
    handling internally within the clockdomain core, and simplifies the
    usage also within hwmod.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index d53a0def2d6c..b4de3da6dffa 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -200,7 +200,7 @@ static int omap4_boot_secondary(unsigned int cpu, struct task_struct *idle)
 		 * Ensure that CPU power state is set to ON to avoid CPU
 		 * powerdomain transition on wfi
 		 */
-		clkdm_wakeup_nolock(cpu1_clkdm);
+		clkdm_deny_idle_nolock(cpu1_clkdm);
 		pwrdm_set_next_pwrst(cpu1_pwrdm, PWRDM_POWER_ON);
 		clkdm_allow_idle_nolock(cpu1_clkdm);
 

commit 3251885285e15e4b0ff1b0501a49380b24204f35
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Jun 22 01:59:40 2016 -0700

    ARM: OMAP4+: Reset CPU1 properly for kexec
    
    We need to reset CPU1 properly for kexec when booting different
    kernel versions. Otherwise CPU1 will attempt to boot the the
    previous kernel's start_secondary(). Note that the restctrl
    register is different from the low-power mode wakeup register
    CPU1_WAKEUP_NS_PA_ADDR. We need to configure both.
    
    Let's fix the issue by defining SoC specific data to initialize
    things in a more generic way. And let's also standardize omap-smp.c
    to use soc_is instead of cpu_is while at it.
    
    Acked-by: Santosh Shilimkar <ssantosh@kernel.org>
    Tested-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 8cd1de914ee4..d53a0def2d6c 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -40,14 +40,35 @@
 
 #define OMAP5_CORE_COUNT	0x2
 
-/* SCU base address */
-static void __iomem *scu_base;
+struct omap_smp_config {
+	unsigned long cpu1_rstctrl_pa;
+	void __iomem *cpu1_rstctrl_va;
+	void __iomem *scu_base;
+	void *startup_addr;
+};
+
+static struct omap_smp_config cfg;
+
+static const struct omap_smp_config omap443x_cfg __initconst = {
+	.cpu1_rstctrl_pa = 0x4824380c,
+	.startup_addr = omap4_secondary_startup,
+};
+
+static const struct omap_smp_config omap446x_cfg __initconst = {
+	.cpu1_rstctrl_pa = 0x4824380c,
+	.startup_addr = omap4460_secondary_startup,
+};
+
+static const struct omap_smp_config omap5_cfg __initconst = {
+	.cpu1_rstctrl_pa = 0x48243810,
+	.startup_addr = omap5_secondary_startup,
+};
 
 static DEFINE_SPINLOCK(boot_lock);
 
 void __iomem *omap4_get_scu_base(void)
 {
-	return scu_base;
+	return cfg.scu_base;
 }
 
 #ifdef CONFIG_OMAP5_ERRATA_801819
@@ -93,7 +114,7 @@ static void omap4_secondary_init(unsigned int cpu)
 	 * OMAP443X GP devices- SMP bit isn't accessible.
 	 * OMAP446X GP devices - SMP bit access is enabled on both CPUs.
 	 */
-	if (cpu_is_omap443x() && (omap_type() != OMAP2_DEVICE_TYPE_GP))
+	if (soc_is_omap443x() && (omap_type() != OMAP2_DEVICE_TYPE_GP))
 		omap_secure_dispatcher(OMAP4_PPA_CPU_ACTRL_SMP_INDEX,
 							4, 0, 0, 0, 0, 0);
 
@@ -222,9 +243,9 @@ static void __init omap4_smp_init_cpus(void)
 		 * Currently we can't call ioremap here because
 		 * SoC detection won't work until after init_early.
 		 */
-		scu_base =  OMAP2_L4_IO_ADDRESS(scu_a9_get_base());
-		BUG_ON(!scu_base);
-		ncores = scu_get_core_count(scu_base);
+		cfg.scu_base =  OMAP2_L4_IO_ADDRESS(scu_a9_get_base());
+		BUG_ON(!cfg.scu_base);
+		ncores = scu_get_core_count(cfg.scu_base);
 	} else if (cpu_id == CPU_CORTEX_A15) {
 		ncores = OMAP5_CORE_COUNT;
 	}
@@ -242,20 +263,51 @@ static void __init omap4_smp_init_cpus(void)
 
 static void __init omap4_smp_prepare_cpus(unsigned int max_cpus)
 {
-	void *startup_addr = omap4_secondary_startup;
 	void __iomem *base = omap_get_wakeupgen_base();
+	const struct omap_smp_config *c = NULL;
+
+	if (soc_is_omap443x())
+		c = &omap443x_cfg;
+	else if (soc_is_omap446x())
+		c = &omap446x_cfg;
+	else if (soc_is_dra74x() || soc_is_omap54xx())
+		c = &omap5_cfg;
+
+	if (!c) {
+		pr_err("%s Unknown SMP SoC?\n", __func__);
+		return;
+	}
+
+	/* Must preserve cfg.scu_base set earlier */
+	cfg.cpu1_rstctrl_pa = c->cpu1_rstctrl_pa;
+	cfg.startup_addr = c->startup_addr;
+
+	if (soc_is_dra74x() || soc_is_omap54xx()) {
+		if ((__boot_cpu_mode & MODE_MASK) == HYP_MODE)
+			cfg.startup_addr = omap5_secondary_hyp_startup;
+		omap5_erratum_workaround_801819();
+	}
+
+	cfg.cpu1_rstctrl_va = ioremap(cfg.cpu1_rstctrl_pa, 4);
+	if (!cfg.cpu1_rstctrl_va)
+		return;
 
 	/*
 	 * Initialise the SCU and wake up the secondary core using
 	 * wakeup_secondary().
 	 */
-	if (scu_base)
-		scu_enable(scu_base);
+	if (cfg.scu_base)
+		scu_enable(cfg.scu_base);
 
-	if (cpu_is_omap446x())
-		startup_addr = omap4460_secondary_startup;
-	if (soc_is_dra74x() || soc_is_omap54xx())
-		omap5_erratum_workaround_801819();
+	/*
+	 * Reset CPU1 before configuring, otherwise kexec will
+	 * end up trying to use old kernel startup address.
+	 */
+	if (cfg.cpu1_rstctrl_va) {
+		writel_relaxed(1, cfg.cpu1_rstctrl_va);
+		readl_relaxed(cfg.cpu1_rstctrl_va);
+		writel_relaxed(0, cfg.cpu1_rstctrl_va);
+	}
 
 	/*
 	 * Write the address of secondary startup routine into the
@@ -264,19 +316,10 @@ static void __init omap4_smp_prepare_cpus(unsigned int max_cpus)
 	 * A barrier is added to ensure that write buffer is drained
 	 */
 	if (omap_secure_apis_support())
-		omap_auxcoreboot_addr(virt_to_phys(startup_addr));
+		omap_auxcoreboot_addr(virt_to_phys(cfg.startup_addr));
 	else
-		/*
-		 * If the boot CPU is in HYP mode then start secondary
-		 * CPU in HYP mode as well.
-		 */
-		if ((__boot_cpu_mode & MODE_MASK) == HYP_MODE)
-			writel_relaxed(virt_to_phys(omap5_secondary_hyp_startup),
-				       base + OMAP_AUX_CORE_BOOT_1);
-		else
-			writel_relaxed(virt_to_phys(omap5_secondary_startup),
-				       base + OMAP_AUX_CORE_BOOT_1);
-
+		writel_relaxed(virt_to_phys(cfg.startup_addr),
+			       base + OMAP_AUX_CORE_BOOT_1);
 }
 
 const struct smp_operations omap4_smp_ops __initconst = {
@@ -286,5 +329,6 @@ const struct smp_operations omap4_smp_ops __initconst = {
 	.smp_boot_secondary	= omap4_boot_secondary,
 #ifdef CONFIG_HOTPLUG_CPU
 	.cpu_die		= omap4_cpu_die,
+	.cpu_kill		= omap4_cpu_kill,
 #endif
 };

commit c0053bd50af57c4ebf032a9de1b07ca78c982452
Author: Nishanth Menon <nm@ti.com>
Date:   Thu Aug 6 10:54:24 2015 -0500

    ARM: OMAP5 / DRA7: Introduce workaround for 801819
    
    Add workaround for Cortex-A15 ARM erratum 801819 which says in summary
    that "A livelock can occur in the L2 cache arbitration that might
    prevent a snoop from completing. Under certain conditions this can
    cause the system to deadlock. "
    
    Recommended workaround is as follows:
    Do both of the following:
    
    1) Do not use the write-back no-allocate memory type.
    2) Do not issue write-back cacheable stores at any time when the cache
    is disabled (SCTLR.C=0) and the MMU is enabled (SCTLR.M=1). Because it
    is implementation defined whether cacheable stores update the cache when
    the cache is disabled it is not expected that any portable code will
    execute cacheable stores when the cache is disabled.
    
    For implementations of Cortex-A15 configured without the “L2 arbitration
    register slice” option (typically one or two core systems), you must
    also do the following:
    
    3) Disable write-streaming in each CPU by setting ACTLR[28:25] = 0b1111
    
    So, we provide an option to disable write streaming on OMAP5 and DRA7.
    It is a rare condition to occur and may be enabled selectively based
    on platform acceptance of risk.
    
    Applies to: A15 revisions r2p0, r2p1, r2p2, r2p3 or r2p4 and REVIDR[3]
    is set to 0.
    
    Based on ARM errata Document revision 18.0 (22 Nov 2013)
    
    Note: the configuration for the workaround needs to be done with
    each CPU bringup, since CPU0 bringup is done by bootloader, it is
    recommended to have the workaround in the bootloader, kernel also does
    ensure that CPU0 has the workaround and makes the workaround active
    when CPU1 gets active.
    
    With CONFIG_SMP disabled, it is expected to be done by the bootloader.
    
    This does show significant degradation in synthetic tests such as
    mbw (https://packages.qa.debian.org/m/mbw.html)
    mbw -n 100 100|grep AVG (on a test platform)
    Without enabling the erratum:
    AVG Method: MEMCPY  Elapsed: 0.13406  MiB: 100.00000  Copy: 745.913 MiB/s
    AVG Method: DUMB    Elapsed: 0.06746  MiB: 100.00000  Copy: 1482.357 MiB/s
    AVG Method: MCBLOCK Elapsed: 0.03058  MiB: 100.00000  Copy: 3270.569 MiB/s
    After enabling the erratum:
    AVG Method: MEMCPY  Elapsed: 0.13757  MiB: 100.00000  Copy: 726.913 MiB/s
    AVG Method: DUMB    Elapsed: 0.12024  MiB: 100.00000  Copy: 831.668 MiB/s
    AVG Method: MCBLOCK Elapsed: 0.09243  MiB: 100.00000  Copy: 1081.942 MiB/s
    
    Most benchmarks are designed for specific performance analysis, so
    overall usecase must be considered before making a decision to
    enable/disable the erratum workaround.
    
    Pending internal investigation, the erratum is kept disabled by default.
    
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Suggested-by: Richard Woodruff <r-woodruff2@ti.com>
    Suggested-by: Brad Griffis <bgriffis@ti.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index c625cc10d9f9..8cd1de914ee4 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -50,6 +50,39 @@ void __iomem *omap4_get_scu_base(void)
 	return scu_base;
 }
 
+#ifdef CONFIG_OMAP5_ERRATA_801819
+void omap5_erratum_workaround_801819(void)
+{
+	u32 acr, revidr;
+	u32 acr_mask;
+
+	/* REVIDR[3] indicates erratum fix available on silicon */
+	asm volatile ("mrc p15, 0, %0, c0, c0, 6" : "=r" (revidr));
+	if (revidr & (0x1 << 3))
+		return;
+
+	asm volatile ("mrc p15, 0, %0, c1, c0, 1" : "=r" (acr));
+	/*
+	 * BIT(27) - Disables streaming. All write-allocate lines allocate in
+	 * the L1 or L2 cache.
+	 * BIT(25) - Disables streaming. All write-allocate lines allocate in
+	 * the L1 cache.
+	 */
+	acr_mask = (0x3 << 25) | (0x3 << 27);
+	/* do we already have it done.. if yes, skip expensive smc */
+	if ((acr & acr_mask) == acr_mask)
+		return;
+
+	acr |= acr_mask;
+	omap_smc1(OMAP5_DRA7_MON_SET_ACR_INDEX, acr);
+
+	pr_debug("%s: ARM erratum workaround 801819 applied on CPU%d\n",
+		 __func__, smp_processor_id());
+}
+#else
+static inline void omap5_erratum_workaround_801819(void) { }
+#endif
+
 static void omap4_secondary_init(unsigned int cpu)
 {
 	/*
@@ -64,12 +97,15 @@ static void omap4_secondary_init(unsigned int cpu)
 		omap_secure_dispatcher(OMAP4_PPA_CPU_ACTRL_SMP_INDEX,
 							4, 0, 0, 0, 0, 0);
 
-	/*
-	 * Configure the CNTFRQ register for the secondary cpu's which
-	 * indicates the frequency of the cpu local timers.
-	 */
-	if (soc_is_omap54xx() || soc_is_dra7xx())
+	if (soc_is_omap54xx() || soc_is_dra7xx()) {
+		/*
+		 * Configure the CNTFRQ register for the secondary cpu's which
+		 * indicates the frequency of the cpu local timers.
+		 */
 		set_cntfreq();
+		/* Configure ACR to disable streaming WA for 801819 */
+		omap5_erratum_workaround_801819();
+	}
 
 	/*
 	 * Synchronise with the boot thread.
@@ -218,6 +254,8 @@ static void __init omap4_smp_prepare_cpus(unsigned int max_cpus)
 
 	if (cpu_is_omap446x())
 		startup_addr = omap4460_secondary_startup;
+	if (soc_is_dra74x() || soc_is_omap54xx())
+		omap5_erratum_workaround_801819();
 
 	/*
 	 * Write the address of secondary startup routine into the

commit 75305275a721d33ae9abfaeed2817cec8b2fee9a
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Nov 15 10:39:53 2015 +0900

    ARM: use const and __initconst for smp_operations
    
    These smp_operations structures are not over-written, so add "const"
    qualifier and replace __initdata with __initconst.
    
    Also, add "static" where it is possible.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Moritz Fischer <moritz.fischer@ettus.com>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org> # qcom part
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: Wei Xu <xuwei5@hisilicon.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Acked-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Acked-by: Shawn Guo <shawnguo@kernel.org>
    Acked-by: Matthias Brugger <matthias.bgg@gmail.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 79e1f876d1c9..c625cc10d9f9 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -241,7 +241,7 @@ static void __init omap4_smp_prepare_cpus(unsigned int max_cpus)
 
 }
 
-struct smp_operations omap4_smp_ops __initdata = {
+const struct smp_operations omap4_smp_ops __initconst = {
 	.smp_init_cpus		= omap4_smp_init_cpus,
 	.smp_prepare_cpus	= omap4_smp_prepare_cpus,
 	.smp_secondary_init	= omap4_secondary_init,

commit 918af9f941af9995fcaa7ef1eb67c433a492e2b3
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Mon Nov 16 19:38:53 2015 +0200

    ARM: OMAP4+: SMP: use lockless clkdm/pwrdm api in omap4_boot_secondary
    
    OMAP CPU hotplug uses cpu1's clocks and power domains for CPU1 wake up
    from low power states (or turn on CPU1). This part of code is also
    part of system suspend (disable_nonboot_cpus()).
    >From other side, cpu1's clocks and power domains are used by CPUIdle. All above
    functionality is mutually exclusive and, therefore, lockless clkdm/pwrdm api
    can be used in omap4_boot_secondary().
    
    This fixes below back-trace on -RT which is triggered by
    pwrdm_lock/unlock():
    
    BUG: sleeping function called from invalid context at kernel/locking/rtmutex.c:917
     in_atomic(): 1, irqs_disabled(): 0, pid: 118, name: sh
     9 locks held by sh/118:
      #0:  (sb_writers#4){.+.+.+}, at: [<c0144a6c>] vfs_write+0x13c/0x164
      #1:  (&of->mutex){+.+.+.}, at: [<c01b4c70>] kernfs_fop_write+0x48/0x19c
      #2:  (s_active#24){.+.+.+}, at: [<c01b4c78>] kernfs_fop_write+0x50/0x19c
      #3:  (device_hotplug_lock){+.+.+.}, at: [<c03cbff0>] lock_device_hotplug_sysfs+0xc/0x4c
      #4:  (&dev->mutex){......}, at: [<c03cd284>] device_online+0x14/0x88
      #5:  (cpu_add_remove_lock){+.+.+.}, at: [<c003af90>] cpu_up+0x50/0x1a0
      #6:  (cpu_hotplug.lock){++++++}, at: [<c003ae48>] cpu_hotplug_begin+0x0/0xc4
      #7:  (cpu_hotplug.lock#2){+.+.+.}, at: [<c003aec0>] cpu_hotplug_begin+0x78/0xc4
      #8:  (boot_lock){+.+...}, at: [<c002b254>] omap4_boot_secondary+0x1c/0x178
     Preemption disabled at:[<  (null)>]   (null)
    
     CPU: 0 PID: 118 Comm: sh Not tainted 4.1.12-rt11-01998-gb4a62c3-dirty #137
     Hardware name: Generic DRA74X (Flattened Device Tree)
     [<c0017574>] (unwind_backtrace) from [<c0013be8>] (show_stack+0x10/0x14)
     [<c0013be8>] (show_stack) from [<c05a8670>] (dump_stack+0x80/0x94)
     [<c05a8670>] (dump_stack) from [<c05ad158>] (rt_spin_lock+0x24/0x54)
     [<c05ad158>] (rt_spin_lock) from [<c0030dac>] (clkdm_wakeup+0x10/0x2c)
     [<c0030dac>] (clkdm_wakeup) from [<c002b2c0>] (omap4_boot_secondary+0x88/0x178)
     [<c002b2c0>] (omap4_boot_secondary) from [<c0015d00>] (__cpu_up+0xc4/0x164)
     [<c0015d00>] (__cpu_up) from [<c003b09c>] (cpu_up+0x15c/0x1a0)
     [<c003b09c>] (cpu_up) from [<c03cd2d4>] (device_online+0x64/0x88)
     [<c03cd2d4>] (device_online) from [<c03cd360>] (online_store+0x68/0x74)
     [<c03cd360>] (online_store) from [<c01b4ce0>] (kernfs_fop_write+0xb8/0x19c)
     [<c01b4ce0>] (kernfs_fop_write) from [<c0144124>] (__vfs_write+0x20/0xd8)
     [<c0144124>] (__vfs_write) from [<c01449c0>] (vfs_write+0x90/0x164)
     [<c01449c0>] (vfs_write) from [<c01451e4>] (SyS_write+0x44/0x9c)
     [<c01451e4>] (SyS_write) from [<c0010240>] (ret_fast_syscall+0x0/0x54)
     CPU1: smp_ops.cpu_die() returned, trying to resuscitate
    
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 5305ec7341ec..79e1f876d1c9 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -143,9 +143,9 @@ static int omap4_boot_secondary(unsigned int cpu, struct task_struct *idle)
 		 * Ensure that CPU power state is set to ON to avoid CPU
 		 * powerdomain transition on wfi
 		 */
-		clkdm_wakeup(cpu1_clkdm);
-		omap_set_pwrdm_state(cpu1_pwrdm, PWRDM_POWER_ON);
-		clkdm_allow_idle(cpu1_clkdm);
+		clkdm_wakeup_nolock(cpu1_clkdm);
+		pwrdm_set_next_pwrst(cpu1_pwrdm, PWRDM_POWER_ON);
+		clkdm_allow_idle_nolock(cpu1_clkdm);
 
 		if (IS_PM44XX_ERRATUM(PM_OMAP4_ROM_SMP_BOOT_ERRATUM_GICD)) {
 			while (gic_dist_disabled()) {

commit 999f934de195a1506089b52c77429fdba25da688
Author: Lennart Sorensen <lsorense@csclub.uwaterloo.ca>
Date:   Mon Jan 5 15:45:45 2015 -0800

    ARM: omap5/dra7xx: Enable booting secondary CPU in HYP mode
    
    If the boot loader enables HYP mode on the boot CPU, the secondary CPU
    also needs to call into the ROM to switch to HYP mode before booting.
    The firmwares on the omap5 and dra7xx unfortunately do not take care
    of this, so it has to be handled by the kernel.
    
    This patch is based on "[PATCH 2/2] ARM: OMAP5: Add HYP mode entry support
    for secondary CPUs" by Santosh Shilimkar <santosh.shilimkar@ti.com>,
    except this version does not require a compile time CONFIG to control
    if it should enable HYP mode or not, it simply does it based on the mode
    of the boot CPU, so it works whether the CPU boots in SVC or HYP mode,
    and should even work as a guest kernel inside kvm if qemu decides to
    support emulating the omap5 or dra7xx.
    
    Cc: stable@vger.kernel.org #v3.16+
    Signed-off-by: Len Sorensen <lsorense@csclub.uwaterloo.ca>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 256e84ef0f67..5305ec7341ec 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -22,6 +22,7 @@
 #include <linux/irqchip/arm-gic.h>
 
 #include <asm/smp_scu.h>
+#include <asm/virt.h>
 
 #include "omap-secure.h"
 #include "omap-wakeupgen.h"
@@ -227,8 +228,16 @@ static void __init omap4_smp_prepare_cpus(unsigned int max_cpus)
 	if (omap_secure_apis_support())
 		omap_auxcoreboot_addr(virt_to_phys(startup_addr));
 	else
-		writel_relaxed(virt_to_phys(omap5_secondary_startup),
-			       base + OMAP_AUX_CORE_BOOT_1);
+		/*
+		 * If the boot CPU is in HYP mode then start secondary
+		 * CPU in HYP mode as well.
+		 */
+		if ((__boot_cpu_mode & MODE_MASK) == HYP_MODE)
+			writel_relaxed(virt_to_phys(omap5_secondary_hyp_startup),
+				       base + OMAP_AUX_CORE_BOOT_1);
+		else
+			writel_relaxed(virt_to_phys(omap5_secondary_startup),
+				       base + OMAP_AUX_CORE_BOOT_1);
 
 }
 

commit edfaf05c2fcb853fcf35f12aeb9c340f5913337f
Author: Victor Kamensky <victor.kamensky@linaro.org>
Date:   Tue Apr 15 20:37:46 2014 +0300

    ARM: OMAP2+: raw read and write endian fix
    
    All OMAP IP blocks expect LE data, but CPU may operate in BE mode.
    Need to use endian neutral functions to read/write h/w registers.
    I.e instead of __raw_read[lw] and __raw_write[lw] functions code
    need to use read[lw]_relaxed and write[lw]_relaxed functions.
    If the first simply reads/writes register, the second will byteswap
    it if host operates in BE mode.
    
    Changes are trivial sed like replacement of __raw_xxx functions
    with xxx_relaxed variant.
    
    Signed-off-by: Victor Kamensky <victor.kamensky@linaro.org>
    Signed-off-by: Taras Kondratiuk <taras.kondratiuk@linaro.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 17550aa39d0f..256e84ef0f67 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -99,7 +99,7 @@ static int omap4_boot_secondary(unsigned int cpu, struct task_struct *idle)
 	if (omap_secure_apis_support())
 		omap_modify_auxcoreboot0(0x200, 0xfffffdff);
 	else
-		__raw_writel(0x20, base + OMAP_AUX_CORE_BOOT_0);
+		writel_relaxed(0x20, base + OMAP_AUX_CORE_BOOT_0);
 
 	if (!cpu1_clkdm && !cpu1_pwrdm) {
 		cpu1_clkdm = clkdm_lookup("mpu1_clkdm");
@@ -227,8 +227,8 @@ static void __init omap4_smp_prepare_cpus(unsigned int max_cpus)
 	if (omap_secure_apis_support())
 		omap_auxcoreboot_addr(virt_to_phys(startup_addr));
 	else
-		__raw_writel(virt_to_phys(omap5_secondary_startup),
-						base + OMAP_AUX_CORE_BOOT_1);
+		writel_relaxed(virt_to_phys(omap5_secondary_startup),
+			       base + OMAP_AUX_CORE_BOOT_1);
 
 }
 

commit de70af494c468c107eedf90090eb74d6ccf30c4c
Author: Nishanth Menon <nm@ti.com>
Date:   Mon Jan 20 14:06:37 2014 -0600

    ARM: OMAP4+: move errata initialization to omap4_pm_init_early
    
    Move all OMAP4 PM errata initializations to centralized location in
    omap4_pm_init_early. This allows for users to utilize the erratas
    in various submodules as needed.
    
    Reported-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 75e95d4fb448..17550aa39d0f 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -39,8 +39,6 @@
 
 #define OMAP5_CORE_COUNT	0x2
 
-u16 pm44xx_errata;
-
 /* SCU base address */
 static void __iomem *scu_base;
 
@@ -217,10 +215,8 @@ static void __init omap4_smp_prepare_cpus(unsigned int max_cpus)
 	if (scu_base)
 		scu_enable(scu_base);
 
-	if (cpu_is_omap446x()) {
+	if (cpu_is_omap446x())
 		startup_addr = omap4460_secondary_startup;
-		pm44xx_errata |= PM_OMAP4_ROM_SMP_BOOT_ERRATUM_GICD;
-	}
 
 	/*
 	 * Write the address of secondary startup routine into the

commit 5523e4092ee4f2ef58d00c78365c8bddf730c900
Author: R Sricharan <r.sricharan@ti.com>
Date:   Thu Oct 10 13:13:48 2013 +0530

    ARM: OMAP5/DRA7: realtime_counter: Configure CNTFRQ register
    
    The realtime counter called master counter, produces the count
    used by the private timer peripherals in the MPU_CLUSTER. The
    CNTFRQ per cpu register is used to denote the frequency of the counter.
    Currently the frequency value is passed from the
    DT file, but this is not scalable when we have other non-DT guest
    OS. This register must be set to the right value by the
    secure rom code. Setting this register helps in propagating the right
    frequency value across OSes.
    
    More discussions and the reason for adding this in a non-DT
    way can be seen from below.
    http://www.mail-archive.com/linux-omap@vger.kernel.org/msg93832.html
    
    So configuring this secure register for all the cpus here.
    
    Cc: Nishanth Menon <nm@ti.com>
    Cc: Rajendra Nayak <rnayak@ti.com>
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Tested-by: Nishanth Menon <nm@ti.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Sricharan R <r.sricharan@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 891211093295..75e95d4fb448 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -65,6 +65,13 @@ static void omap4_secondary_init(unsigned int cpu)
 		omap_secure_dispatcher(OMAP4_PPA_CPU_ACTRL_SMP_INDEX,
 							4, 0, 0, 0, 0, 0);
 
+	/*
+	 * Configure the CNTFRQ register for the secondary cpu's which
+	 * indicates the frequency of the cpu local timers.
+	 */
+	if (soc_is_omap54xx() || soc_is_dra7xx())
+		set_cntfreq();
+
 	/*
 	 * Synchronise with the boot thread.
 	 */

commit b6b2485214d2b6af534ae433b588c0bb76fe78af
Author: Anoop Thomas Mathew <atm@profoundis.com>
Date:   Wed Sep 18 12:02:00 2013 -0700

    ARM: OMAP4 SMP: Corrected a typo fucntions to functions
    
    Corrected the functions spelling mistake in the OMAP4 SMP source file.
    
    Signed-off-by: Anoop Thomas Mathew <atm@profoundis.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 8708b2a9da45..891211093295 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -1,5 +1,5 @@
 /*
- * OMAP4 SMP source file. It contains platform specific fucntions
+ * OMAP4 SMP source file. It contains platform specific functions
  * needed for the linux smp kernel.
  *
  * Copyright (C) 2009 Texas Instruments, Inc.

commit 8bd26e3a7e49af2697449bbcb7187a39dc85d672
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jun 17 15:43:14 2013 -0400

    arm: delete __cpuinit/__CPUINIT usage from all ARM users
    
    The __cpuinit type of throwaway sections might have made sense
    some time ago when RAM was more constrained, but now the savings
    do not offset the cost and complications.  For example, the fix in
    commit 5e427ec2d0 ("x86: Fix bit corruption at CPU resume time")
    is a good example of the nasty type of bugs that can be created
    with improper use of the various __init prefixes.
    
    After a discussion on LKML[1] it was decided that cpuinit should go
    the way of devinit and be phased out.  Once all the users are gone,
    we can then finally remove the macros themselves from linux/init.h.
    
    Note that some harmless section mismatch warnings may result, since
    notify_cpu_starting() and cpu_up() are arch independent (kernel/cpu.c)
    and are flagged as __cpuinit  -- so if we remove the __cpuinit from
    the arch specific callers, we will also get section mismatch warnings.
    As an intermediate step, we intend to turn the linux/init.h cpuinit
    related content into no-ops as early as possible, since that will get
    rid of these warnings.  In any case, they are temporary and harmless.
    
    This removes all the ARM uses of the __cpuinit macros from C code,
    and all __CPUINIT from assembly code.  It also had two ".previous"
    section statements that were paired off against __CPUINIT
    (aka .section ".cpuinit.text") that also get removed here.
    
    [1] https://lkml.org/lkml/2013/5/20/589
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 98a11463a843..8708b2a9da45 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -51,7 +51,7 @@ void __iomem *omap4_get_scu_base(void)
 	return scu_base;
 }
 
-static void __cpuinit omap4_secondary_init(unsigned int cpu)
+static void omap4_secondary_init(unsigned int cpu)
 {
 	/*
 	 * Configure ACTRL and enable NS SMP bit access on CPU1 on HS device.
@@ -72,7 +72,7 @@ static void __cpuinit omap4_secondary_init(unsigned int cpu)
 	spin_unlock(&boot_lock);
 }
 
-static int __cpuinit omap4_boot_secondary(unsigned int cpu, struct task_struct *idle)
+static int omap4_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	static struct clockdomain *cpu1_clkdm;
 	static bool booted;

commit 49a34fd5380d249ae8a2173399c62fc5a1fddd70
Merge: f722406faae2 705814b5ea6f
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu May 16 08:27:49 2013 -0700

    Merge tag 'omap-pm-v3.10/cleanup/pm' of git://git.kernel.org/pub/scm/linux/kernel/git/khilman/linux-omap-pm into omap-for-v3.11/pm
    
    OMAP PM cleanups for v3.10

commit 8546dc1d4b671480961c3eaf4c0c102ae6848340
Merge: 9992ba72327f 33b9f582c5c1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 3 09:13:19 2013 -0700

    Merge branch 'for-linus' of git://git.linaro.org/people/rmk/linux-arm
    
    Pull ARM updates from Russell King:
     "The major items included in here are:
    
       - MCPM, multi-cluster power management, part of the infrastructure
         required for ARMs big.LITTLE support.
    
       - A rework of the ARM KVM code to allow re-use by ARM64.
    
       - Error handling cleanups of the IS_ERR_OR_NULL() madness and fixes
         of that stuff for arch/arm
    
       - Preparatory patches for Cortex-M3 support from Uwe Kleine-König.
    
      There is also a set of three patches in here from Hugh/Catalin to
      address freeing of inappropriate page tables on LPAE.  You already
      have these from akpm, but they were already part of my tree at the
      time he sent them, so unfortunately they'll end up with duplicate
      commits"
    
    * 'for-linus' of git://git.linaro.org/people/rmk/linux-arm: (77 commits)
      ARM: EXYNOS: remove unnecessary use of IS_ERR_VALUE()
      ARM: IMX: remove unnecessary use of IS_ERR_VALUE()
      ARM: OMAP: use consistent error checking
      ARM: cleanup: OMAP hwmod error checking
      ARM: 7709/1: mcpm: Add explicit AFLAGS to support v6/v7 multiplatform kernels
      ARM: 7700/2: Make cpu_init() notrace
      ARM: 7702/1: Set the page table freeing ceiling to TASK_SIZE
      ARM: 7701/1: mm: Allow arch code to control the user page table ceiling
      ARM: 7703/1: Disable preemption in broadcast_tlb*_a15_erratum()
      ARM: mcpm: provide an interface to set the SMP ops at run time
      ARM: mcpm: generic SMP secondary bringup and hotplug support
      ARM: mcpm_head.S: vlock-based first man election
      ARM: mcpm: Add baremetal voting mutexes
      ARM: mcpm: introduce helpers for platform coherency exit/setup
      ARM: mcpm: introduce the CPU/cluster power API
      ARM: multi-cluster PM: secondary kernel entry code
      ARM: cacheflush: add synchronization helpers for mixed cache state accesses
      ARM: cpu hotplug: remove majority of cache flushing from platforms
      ARM: smp: flush L1 cache in cpu_die()
      ARM: tegra: remove tegra specific cpu_disable()
      ...

commit baf4b7d3436be7e8c8ff5bd58acc51a9b07e1871
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Fri Apr 5 18:29:02 2013 +0530

    ARM: OMAP4+: Make secondary_startup function name more consistent
    
    Current code has rather inconsistent function names for 'secondary_startup'
    routines. Update it to make it more consistent.
    
    Suggested by Kevin Hilman as part of OMAP5 PM patch review.
    
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@linaro.org>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 0cbb677c4df4..5b201653ca32 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -93,7 +93,7 @@ static int __cpuinit omap4_boot_secondary(unsigned int cpu, struct task_struct *
 
 	/*
 	 * Update the AuxCoreBoot0 with boot state for secondary core.
-	 * omap_secondary_startup() routine will hold the secondary core till
+	 * omap4_secondary_startup() routine will hold the secondary core till
 	 * the AuxCoreBoot1 register is updated with cpu state
 	 * A barrier is added to ensure that write buffer is drained
 	 */
@@ -199,7 +199,7 @@ static void __init omap4_smp_init_cpus(void)
 
 static void __init omap4_smp_prepare_cpus(unsigned int max_cpus)
 {
-	void *startup_addr = omap_secondary_startup;
+	void *startup_addr = omap4_secondary_startup;
 	void __iomem *base = omap_get_wakeupgen_base();
 
 	/*
@@ -210,7 +210,7 @@ static void __init omap4_smp_prepare_cpus(unsigned int max_cpus)
 		scu_enable(scu_base);
 
 	if (cpu_is_omap446x()) {
-		startup_addr = omap_secondary_startup_4460;
+		startup_addr = omap4460_secondary_startup;
 		pm44xx_errata |= PM_OMAP4_ROM_SMP_BOOT_ERRATUM_GICD;
 	}
 

commit f199ab1aab9d790bee6c84bdb476f1e4911b8011
Merge: 6fa6183aefcd 5e7deed71290
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Apr 9 15:14:19 2013 +0200

    Merge tag 'omap-for-v3.10/fixes-pm-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into next/cleanup
    
    From Tony Lindgren <tony@atomide.com>:
    
    Non-critical PM fix via Kevin Hilman <khilman@linaro.org>:
    
    OMAP PM fixes for v3.10
    
    Note that this has a dependency to omap-for-v3.10/cleanup-v2-signed.
    
    * tag 'omap-for-v3.10/fixes-pm-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap:
      ARM: OMAP4+: PM: Restore CPU power state to ON with clockdomain force wakeup method
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de<

commit 6fa6183aefcdefe0db26a0ceeaaf11c149acd449
Merge: 321ae6fa0368 c309f7f46167
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Apr 8 18:03:08 2013 +0200

    Merge tag 'omap-for-v3.10/cleanup-v2-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap into next/cleanup
    
    From Tony Lindgren <tony@atomide.com>:
    
    Clean up related changes for v3.10 merge window.
    Mostly clock and PM related with removal of now unused
    DMA channel definitions. The clock change to use SoC
    specific lists will make it a little bit easier to
    add support for new SoCs variants without having to patch
    all over the place.
    
    * tag 'omap-for-v3.10/cleanup-v2-signed' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap:
      ARM: OMAP4: Fix the init code to have OMAP4460 errata available in DT build
      ARM: OMAP4: PM: Now remove L4 per clockdomain static depedency with MPU
      ARM: OMAP4: PM: Remove L4 wakeup depedency with MPU since errata fix exist now
      ARM: OMAP4+: Move the CPU wakeup prepare code under smp_prepare_cpus()
      ARM: OMAP4+: Remove out of placed smp_wmb() in secondary wakeup code
      ARM: OMAP4+: Remove un-necessary cacheflush in secondary CPU boot path
      ARM: OMAP4+: Remove the un-necessary cache flush from hotplug code
      ARM: OMAP2+: PM: Remove bogus fiq_[enable/disable] tuple
      ARM: OMAP4+: Use common scratchpad SAR RAM offsets for all architectures
      ARM: OMAP2+: Remove unused DMA channel definitions
      ARM: OMAP1: Remove unused DMA channel definitions
      ARM: OMAP2+: clock data: Remove CK_* flags
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

commit b7806dc7cba840ea538706621486475d93a53c55
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Fri Feb 8 22:50:58 2013 +0530

    ARM: OMAP4+: PM: Restore CPU power state to ON with clockdomain force wakeup method
    
    While waking up CPU from off state using clock domain force wakeup, restore
    the CPU power state to ON state before putting CPU clock domain under
    hardware control. Otherwise CPU wakeup might fail. The change is recommended
    for all OMAP4+ devices though the PRCM weakness was observed on OMAP5
    devices first.
    
    As a result of weakness, lock-up is observed inside the hardware state
    machine of local CPU PRCM and results are UN-predictable as per designers.
    In software testing, we have seen hard-locks most of the time where system
    gets frozen. With power domain state restored, system behaves correctly.
    
    So update the code accordingly.
    
    Acked-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Kevin Hilman <khilman@linaro.org>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 0cbb677c4df4..e4441cc7aca2 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -83,6 +83,7 @@ static int __cpuinit omap4_boot_secondary(unsigned int cpu, struct task_struct *
 {
 	static struct clockdomain *cpu1_clkdm;
 	static bool booted;
+	static struct powerdomain *cpu1_pwrdm;
 	void __iomem *base = omap_get_wakeupgen_base();
 
 	/*
@@ -102,8 +103,10 @@ static int __cpuinit omap4_boot_secondary(unsigned int cpu, struct task_struct *
 	else
 		__raw_writel(0x20, base + OMAP_AUX_CORE_BOOT_0);
 
-	if (!cpu1_clkdm)
+	if (!cpu1_clkdm && !cpu1_pwrdm) {
 		cpu1_clkdm = clkdm_lookup("mpu1_clkdm");
+		cpu1_pwrdm = pwrdm_lookup("cpu1_pwrdm");
+	}
 
 	/*
 	 * The SGI(Software Generated Interrupts) are not wakeup capable
@@ -116,7 +119,7 @@ static int __cpuinit omap4_boot_secondary(unsigned int cpu, struct task_struct *
 	 * Section :
 	 *	4.3.4.2 Power States of CPU0 and CPU1
 	 */
-	if (booted) {
+	if (booted && cpu1_pwrdm && cpu1_clkdm) {
 		/*
 		 * GIC distributor control register has changed between
 		 * CortexA9 r1pX and r2pX. The Control Register secure
@@ -137,7 +140,12 @@ static int __cpuinit omap4_boot_secondary(unsigned int cpu, struct task_struct *
 			gic_dist_disable();
 		}
 
+		/*
+		 * Ensure that CPU power state is set to ON to avoid CPU
+		 * powerdomain transition on wfi
+		 */
 		clkdm_wakeup(cpu1_clkdm);
+		omap_set_pwrdm_state(cpu1_pwrdm, PWRDM_POWER_ON);
 		clkdm_allow_idle(cpu1_clkdm);
 
 		if (IS_PM44XX_ERRATUM(PM_OMAP4_ROM_SMP_BOOT_ERRATUM_GICD)) {

commit b699ddd19bf3542d43ffe293c6148161e160b1bc
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Sun Feb 10 13:54:00 2013 +0530

    ARM: OMAP4+: Move the CPU wakeup prepare code under smp_prepare_cpus()
    
    Move the secondary CPU wakeup prepare code under smp_prepare_cpus() where it
    belongs. It was remainder of the pen release code which was borrowed from
    ARM code initially.
    
    While at it drop the un-necessary sev() and barrier which was under
    prepare code.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 1e14899dbbf5..0cbb677c4df4 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -164,36 +164,6 @@ static int __cpuinit omap4_boot_secondary(unsigned int cpu, struct task_struct *
 	return 0;
 }
 
-static void __init wakeup_secondary(void)
-{
-	void *startup_addr = omap_secondary_startup;
-	void __iomem *base = omap_get_wakeupgen_base();
-
-	if (cpu_is_omap446x()) {
-		startup_addr = omap_secondary_startup_4460;
-		pm44xx_errata |= PM_OMAP4_ROM_SMP_BOOT_ERRATUM_GICD;
-	}
-
-	/*
-	 * Write the address of secondary startup routine into the
-	 * AuxCoreBoot1 where ROM code will jump and start executing
-	 * on secondary core once out of WFE
-	 * A barrier is added to ensure that write buffer is drained
-	 */
-	if (omap_secure_apis_support())
-		omap_auxcoreboot_addr(virt_to_phys(startup_addr));
-	else
-		__raw_writel(virt_to_phys(omap5_secondary_startup),
-						base + OMAP_AUX_CORE_BOOT_1);
-
-	/*
-	 * Send a 'sev' to wake the secondary core from WFE.
-	 * Drain the outstanding writes to memory
-	 */
-	dsb_sev();
-	mb();
-}
-
 /*
  * Initialise the CPU possible map early - this describes the CPUs
  * which may be present or become present in the system.
@@ -229,6 +199,8 @@ static void __init omap4_smp_init_cpus(void)
 
 static void __init omap4_smp_prepare_cpus(unsigned int max_cpus)
 {
+	void *startup_addr = omap_secondary_startup;
+	void __iomem *base = omap_get_wakeupgen_base();
 
 	/*
 	 * Initialise the SCU and wake up the secondary core using
@@ -236,7 +208,24 @@ static void __init omap4_smp_prepare_cpus(unsigned int max_cpus)
 	 */
 	if (scu_base)
 		scu_enable(scu_base);
-	wakeup_secondary();
+
+	if (cpu_is_omap446x()) {
+		startup_addr = omap_secondary_startup_4460;
+		pm44xx_errata |= PM_OMAP4_ROM_SMP_BOOT_ERRATUM_GICD;
+	}
+
+	/*
+	 * Write the address of secondary startup routine into the
+	 * AuxCoreBoot1 where ROM code will jump and start executing
+	 * on secondary core once out of WFE
+	 * A barrier is added to ensure that write buffer is drained
+	 */
+	if (omap_secure_apis_support())
+		omap_auxcoreboot_addr(virt_to_phys(startup_addr));
+	else
+		__raw_writel(virt_to_phys(omap5_secondary_startup),
+						base + OMAP_AUX_CORE_BOOT_1);
+
 }
 
 struct smp_operations omap4_smp_ops __initdata = {

commit 2f82bd7814eeb553aaf63c202ba655e82350000a
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Sun Feb 10 13:37:04 2013 +0530

    ARM: OMAP4+: Remove out of placed smp_wmb() in secondary wakeup code
    
    The smp_wmb() here is out of placed and redundant. So remove it. It is
    a left over of the pen_release cleanup mostly.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 5d8f2497017e..1e14899dbbf5 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -186,8 +186,6 @@ static void __init wakeup_secondary(void)
 		__raw_writel(virt_to_phys(omap5_secondary_startup),
 						base + OMAP_AUX_CORE_BOOT_1);
 
-	smp_wmb();
-
 	/*
 	 * Send a 'sev' to wake the secondary core from WFE.
 	 * Drain the outstanding writes to memory

commit 466caec026e38df1a3dda117ac90ccc82b8d3f14
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Sun Feb 10 13:18:42 2013 +0530

    ARM: OMAP4+: Remove un-necessary cacheflush in secondary CPU boot path
    
    This was borrowed from ARM versatile code with pen_release mechanism but since
    OMAP uses hardware register based synchronisation, pen_release stuff was
    dropped. Unfortunately the cacheflush wasn't dropped along with it.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index d9727218dd0a..5d8f2497017e 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -21,7 +21,6 @@
 #include <linux/io.h>
 #include <linux/irqchip/arm-gic.h>
 
-#include <asm/cacheflush.h>
 #include <asm/smp_scu.h>
 
 #include "omap-secure.h"
@@ -103,9 +102,6 @@ static int __cpuinit omap4_boot_secondary(unsigned int cpu, struct task_struct *
 	else
 		__raw_writel(0x20, base + OMAP_AUX_CORE_BOOT_0);
 
-	flush_cache_all();
-	smp_wmb();
-
 	if (!cpu1_clkdm)
 		cpu1_clkdm = clkdm_lookup("mpu1_clkdm");
 

commit c0114709ed85a5693eb74acdfa03d94f7f12e5b8
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Mon Jan 14 18:05:37 2013 +0000

    irqchip: gic: Perform the gic_secondary_init() call via CPU notifier
    
    All the calls to gic_secondary_init() pass 0 as the first argument.
    Since this function is called on each CPU when starting, it can be done
    in a platform-independent way via a CPU notifier registered by the GIC
    code.
    
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Tested-by: Simon Horman <horms+renesas@verge.net.au>
    Acked-by: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Tested-by: Dinh Nguyen <dinguyen@altera.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Tested-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: David Brown <davidb@codeaurora.org>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Shiraz Hashim <shiraz.hashim@st.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Barry Song <baohua.song@csr.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index d9727218dd0a..e7a449758ab5 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -66,13 +66,6 @@ static void __cpuinit omap4_secondary_init(unsigned int cpu)
 		omap_secure_dispatcher(OMAP4_PPA_CPU_ACTRL_SMP_INDEX,
 							4, 0, 0, 0, 0, 0);
 
-	/*
-	 * If any interrupts are already enabled for the primary
-	 * core (e.g. timer irq), then they will not have been enabled
-	 * for us: do so
-	 */
-	gic_secondary_init(0);
-
 	/*
 	 * Synchronise with the boot thread.
 	 */

commit 73a09d212ec65b7068a283e6034fa05649d3d075
Merge: 6dbe51c251a3 6ebd4d038dbb
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Mar 9 15:49:32 2013 +0000

    Merge branch 'for-next' of git://git.pengutronix.de/git/ukl/linux into devel-stable
    
    Conflicts:
            arch/arm/include/asm/cputype.h
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit e9daa0ead197d39f024ceeb668b2407b8b1ca8b7
Merge: c8bfea363621 031b77afc374
Author: Olof Johansson <olof@lixom.net>
Date:   Tue Feb 5 13:10:39 2013 -0800

    Merge tag 'tegra-for-3.9-soc-t114' of git://git.kernel.org/pub/scm/linux/kernel/git/swarren/linux-tegra into next/soc
    
    From Stepen Warren:
    ARM: tegra: add Tegra114 SoC support
    
    This pull request adds initial support for the Tegra114 SoC, which
    integrates a quad-core ARM Cortex-A15 CPU. I'm proud to observe that we
    posted the initial versions of these patches before the final official
    announcement of this chip.
    
    These patches are enough to boot with a UART-based console, support the
    Dalmore and Pluto reference/evaluation boards, instantiate the GPIO and
    pinctrl drivers, and enable a cpuidle state. As yet, no clocks or
    storage devices are supported, but patches for those will follow shortly.
    
    This pull request is based on (most of) the previous pull request with
    tag tegra-for-3.9-soc-cpuidle, followed by a merge of the previous pull
    request with tag tegra-for-3.9-scu-base-rework.
    
    * tag 'tegra-for-3.9-soc-t114' of git://git.kernel.org/pub/scm/linux/kernel/git/swarren/linux-tegra: (24 commits)
      ARM: DT: tegra114: add pinmux DT entry
      ARM: DT: tegra114: add GPIO DT entry
      ARM: tegra114: select PINCTRL for Tegra114 SoC
      ARM: tegra: add Tegra114 ARM_CPUIDLE_WFI_STATE support
      ARM: tegra: Add SMMU entry to Tegra114 DT
      ARM: tegra: add AHB entry to Tegra114 DT
      ARM: tegra: Add initial support for Tegra114 SoC.
      ARM: dt: tegra114: Add new board, Pluto
      ARM: dt: tegra114: Add new board, Dalmore
      ARM: dt: tegra114: Add new SoC base, Tegra114 SoC
      ARM: tegra: fuse: Add chip ID Tegra114 0x35
      ARM: OMAP: Make use of available scu_a9_get_base() interface
      ARM: tegra: Skip scu_enable(scu_base) if not Cortex A9
      ARM: Add API to detect SCU base address from CP15
      ARM: tegra: Use DT /cpu node to detect number of CPU core
      ARM: tegra: Add CPU nodes to Tegra30 device tree
      ARM: tegra: Add CPU nodes to Tegra20 device tree
      ARM: perf: simplify __hw_perf_event_init err handling
      ARM: perf: remove unnecessary checks for idx < 0
      ARM: perf: handle armpmu_register failing
      ...
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    
    Remove/add conflict in arch/arm/mach-tegra/common.c resolved.
    Remove/remove conflict in arch/arm/mach-tegra/platsmp.c. Leave the empty
    stub function for now since removing it in the merge commit is confusing;
    will be cleaned up in a separate commit.  # # It looks like you may be
    committing a merge.  # If this is not correct, please remove the file #
    .git/MERGE_HEAD # and try again.

commit ac52e83f4c76992925e13d0f4e901ffd4c207261
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Jan 30 17:38:21 2013 +0100

    ARM: use read_cpuid_id() instead of read_cpuid(CPUID_ID)
    
    Both calls are identical currently. This patch prepares to deprecate
    read_cpuid on machines without cp15.
    
    Also move an unconditional usage of read_cpuid_cachetype to a more local
    scope as read_cpuid_cachetype uses read_cpuid, too.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Message-Id: 1359646587-1788-1-git-send-email-u.kleine-koenig@pengutronix.de

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index cd42d921940d..707098ecf8d3 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -209,7 +209,7 @@ static void __init omap4_smp_init_cpus(void)
 	unsigned int i = 0, ncores = 1, cpu_id;
 
 	/* Use ARM cpuid check here, as SoC detection will not work so early */
-	cpu_id = read_cpuid(CPUID_ID) & CPU_MASK;
+	cpu_id = read_cpuid_id() & CPU_MASK;
 	if (cpu_id == CPU_CORTEX_A9) {
 		/*
 		 * Currently we can't call ioremap here because

commit 80d9375617f7544f7475e7f07003a08930559d43
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Wed Jan 23 13:56:19 2013 +0530

    ARM: OMAP: Make use of available scu_a9_get_base() interface
    
    Drop the define and make use of scu_a9_get_base() which reads
    the physical address of SCU from CP15 register.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index cd42d921940d..e683d0dcef6b 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -215,7 +215,7 @@ static void __init omap4_smp_init_cpus(void)
 		 * Currently we can't call ioremap here because
 		 * SoC detection won't work until after init_early.
 		 */
-		scu_base =  OMAP2_L4_IO_ADDRESS(OMAP44XX_SCU_BASE);
+		scu_base =  OMAP2_L4_IO_ADDRESS(scu_a9_get_base());
 		BUG_ON(!scu_base);
 		ncores = scu_get_core_count(scu_base);
 	} else if (cpu_id == CPU_CORTEX_A15) {

commit 520f7bd73354f003a9a59937b28e4903d985c420
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Thu Dec 27 13:10:24 2012 -0600

    irqchip: Move ARM gic.h to include/linux/irqchip/arm-gic.h
    
    Now that we have GIC moved to drivers/irqchip and all GIC DT init for
    platforms using irqchip_init, move gic.h and update the remaining
    includes.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Anton Vorontsov <avorontsov@mvista.com>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: David Brown <davidb@codeaurora.org>
    Cc: Daniel Walker <dwalker@fifo99.com>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Viresh Kumar <viresh.linux@gmail.com>
    Cc: Shiraz Hashim <shiraz.hashim@st.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 668172a5f9ea..361677983af0 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -19,9 +19,9 @@
 #include <linux/device.h>
 #include <linux/smp.h>
 #include <linux/io.h>
+#include <linux/irqchip/arm-gic.h>
 
 #include <asm/cacheflush.h>
-#include <asm/hardware/gic.h>
 #include <asm/smp_scu.h>
 
 #include "omap-secure.h"

commit b1cffebf1029c87e1f1984d48463ee21093a6bc7
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Mon Nov 26 15:05:48 2012 -0600

    ARM: GIC: remove direct use of gic_raise_softirq
    
    In preparation of moving gic code to drivers/irqchip, remove the direct
    platform dependencies on gic_raise_softirq. Move the setup of
    smp_cross_call into the gic code and use arch_send_wakeup_ipi_mask
    function to trigger wake-up IPIs.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: David Brown <davidb@codeaurora.org>
    Cc: Daniel Walker <dwalker@fifo99.com>
    Cc: Bryan Huntsman <bryanh@codeaurora.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Shiraz Hashim <shiraz.hashim@st.com>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index cd42d921940d..668172a5f9ea 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -157,7 +157,7 @@ static int __cpuinit omap4_boot_secondary(unsigned int cpu, struct task_struct *
 		booted = true;
 	}
 
-	gic_raise_softirq(cpumask_of(cpu), 0);
+	arch_send_wakeup_ipi_mask(cpumask_of(cpu));
 
 	/*
 	 * Now the secondary core is starting up let it run its
@@ -231,8 +231,6 @@ static void __init omap4_smp_init_cpus(void)
 
 	for (i = 0; i < ncores; i++)
 		set_cpu_possible(i, true);
-
-	set_smp_cross_call(gic_raise_softirq);
 }
 
 static void __init omap4_smp_prepare_cpus(unsigned int max_cpus)

commit 936407358759adb302df93ab61fa68141897270c
Author: Kevin Hilman <khilman@ti.com>
Date:   Wed Nov 14 16:54:27 2012 -0800

    ARM: OMAP4: PM: fix errata handling when CONFIG_PM=n
    
    commit c9621844 (ARM: OMAP4: PM: add errata support) introduced errata
    handling for OMAP4, but was broken when CONFIG_PM=n.
    
    When CONFIG_PM=n, pm44xx.c is not compiled, yet that is where pm44xx_errata
    is defined.  However, these errata are needed for the SMP boot/hotplug case
    also, and are primarily used in omap-smp.c.
    
    Move the definition of pm44xx_errata to omap-smp.c so that it's available
    even in the CONFIG_PM=n case.
    
    Cc: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 49a08dfe8d88..cd42d921940d 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -40,6 +40,8 @@
 
 #define OMAP5_CORE_COUNT	0x2
 
+u16 pm44xx_errata;
+
 /* SCU base address */
 static void __iomem *scu_base;
 

commit cd8ce159031813eb870a5f3d5b27c3be36cd6e3a
Author: Colin Cross <ccross@android.com>
Date:   Thu Oct 18 12:20:08 2012 +0300

    ARM: OMAP4: retrigger localtimers after re-enabling gic
    
    'Workaround for ROM bug because of CA9 r2pX gic control'
    register change disables the gic distributor while the secondary
    cpu is being booted.  If a localtimer interrupt on the primary cpu
    occurs when the distributor is turned off, the interrupt is lost,
    and the localtimer never fires again.
    
    Make the primary cpu wait for the secondary cpu to reenable the
    gic distributor (with interrupts off for safety), and then
    check if the pending bit is set in the localtimer but not the
    gic.  If so, ack it in the localtimer, and reset the timer with
    the minimum timeout to trigger a new timer interrupt.
    
    Signed-off-by: Colin Cross <ccross@android.com>
    [s-jan@ti.com: adapted to k3.4 + validated functionality]
    Signed-off-by: Sebastien Jan <s-jan@ti.com>
    [t-kristo@ti.com: dropped generic ARM kernel exports from the code, rebased
     to mainline]
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 7d9c0e3fedc4..49a08dfe8d88 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -134,11 +134,22 @@ static int __cpuinit omap4_boot_secondary(unsigned int cpu, struct task_struct *
 		 * 2) CPU1 must re-enable the GIC distributor on
 		 * it's wakeup path.
 		 */
-		if (IS_PM44XX_ERRATUM(PM_OMAP4_ROM_SMP_BOOT_ERRATUM_GICD))
+		if (IS_PM44XX_ERRATUM(PM_OMAP4_ROM_SMP_BOOT_ERRATUM_GICD)) {
+			local_irq_disable();
 			gic_dist_disable();
+		}
 
 		clkdm_wakeup(cpu1_clkdm);
 		clkdm_allow_idle(cpu1_clkdm);
+
+		if (IS_PM44XX_ERRATUM(PM_OMAP4_ROM_SMP_BOOT_ERRATUM_GICD)) {
+			while (gic_dist_disabled()) {
+				udelay(1);
+				cpu_relax();
+			}
+			gic_timer_retrigger();
+			local_irq_enable();
+		}
 	} else {
 		dsb_sev();
 		booted = true;

commit ff999b8a0983ee15668394ed49e38d3568fc6859
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Thu Oct 18 12:20:05 2012 +0300

    ARM: OMAP4460: Workaround for ROM bug because of CA9 r2pX GIC control register change.
    
    On OMAP4+ devices, GIC register context is lost when MPUSS hits
    the OSWR(Open Switch Retention). On the CPU wakeup path, ROM code
    gets executed and one of the steps in it is to restore the
    saved context of the GIC. The ROM Code GIC distributor restoration
    is split in two parts: CPU specific register done by each CPU and
    common register done by only one CPU.
    
    Below is the abstract flow.
    
    ...............................................................
    - MPUSS in OSWR state.
    - CPU0 wakes up on the event(interrupt) and start executing ROM code.
    
    [..]
    
    - CPU0 executes "GIC Restoration:"
    
    [...]
    
    - CPU0 swicthes to non-secure mode and jumps to OS resume code.
    
    [...]
    
    - CPU0 is online in OS
    - CPU0 enables the GIC distributor. GICD.Enable Non-secure = 1
    - CPU0 wakes up CPU1 with clock-domain force wakeup method.
    - CPU0 continues it's execution.
    [..]
    
    - CPU1 wakes up and start executing ROM code.
    
    [..]
    
    - CPU1 executes "GIC Restoration:"
    
    [..]
    
    - CPU1 swicthes to non-secure mode and jumps to OS resume code.
    
    [...]
    
    - CPU1 is online in OS and start executing.
    [...]   -
    
    GIC Restoration: /* Common routine for HS and GP devices */
    {
           if (GICD != 1)  { /* This will be true in OSWR state */
                   if (GIC_SAR_BACKUP_STATE == SAVED)
                           - CPU restores GIC distributor
                   else
                           - reconfigure GIC distributor to boot values.
    
                   GICD.Enable secure = 1
           }
    
           if (GIC_SAR_BACKUP_STATE == SAVED)
                   - CPU restore its GIC CPU interface registers if saved.
           else
                   - reconfigure its GIC CPU interface registers to boot
                           values.
    }
    ...............................................................
    
    So as mentioned in the flow, GICD != 1 condition decides how
    the GIC registers are handled in ROM code wakeup path from
    OSWR. As evident from the flow, ROM code relies on the entire
    GICD register value and not specific register bits.
    
    The assumption was valid till CortexA9 r1pX version since there
    was only one banked bit to control secure and non-secure GICD.
    Secure view which ROM code sees:
           bit 0 == Enable Non-secure
    Non-secure view which HLOS sees:
           bit 0 == Enable secure
    
    But GICD register has changed between CortexA9 r1pX and r2pX.
    On r2pX GICD register is composed of 2 bits.
    Secure view which ROM code sees:
           bit 1 == Enable Non-secure
           bit 0 == Enable secure
    Non-secure view which HLOS sees:
           bit 0 == Enable Non-secure
    
    Hence on OMAP4460(r2pX) devices, if you go through the
    above flow again during CPU1 wakeup, GICD == 3 and hence
    ROM code fails to understand the real wakeup power state
    and reconfigures GIC distributor to boot values. This is
    nasty since you loose the entire interrupt controller
    context in a live system.
    
    The ROM code fix done on next OMAP4 device (OMAP4470 - r2px) is to
    check "GICD.Enable secure != 1" for GIC restoration in OSWR wakeup path.
    
    Since ROM code can't be fixed on OMAP4460 devices, a work around
    needs to be implemented. As evident from the flow, as long as
    CPU1 sees GICD == 1 in it's wakeup path from OSWR, the issue
    won't happen. Below is the flow with the work-around.
    
    ...............................................................
    - MPUSS in OSWR state.
    - CPU0 wakes up on the event(interrupt) and start executing ROM code.
    
    [..]
    
    - CPU0 executes "GIC Restoration:"
    
    [..]
    
    - CPU0 swicthes to non-secure mode and jumps to OS resume code.
    
    [..]
    
    - CPU0 is online in OS.
    - CPU0 does GICD.Enable Non-secure = 0
    - CPU0 wakes up CPU1 with clock domain force wakeup method.
    - CPU0 waits for GICD.Enable Non-secure = 1
    - CPU0 coninues it's execution.
    [..]
    
    - CPU1 wakes up and start executing ROM code.
    
    [..]
    
    - CPU1 executes "GIC Restoration:"
    
    [..]
    
    - CPU1 swicthes to non-secure mode and jumps to OS resume code.
    
    [..]
    
    - CPU1 is online in OS
    - CPU1 does GICD.Enable Non-secure = 1
    - CPU1 start executing
    [...]
    ...............................................................
    
    With this procedure, the GIC configuration done between the
    CPU0 wakeup and CPU1 wakeup will not be lost but during this
    short windows, the CPU0 will not receive interrupts.
    
    The BUG is applicable to only OMAP4460(r2pX) devices.
    OMAP4470 (also r2pX) is not affected by this bug because
    ROM code has been fixed.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 4d05fa8a4e48..7d9c0e3fedc4 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -32,6 +32,7 @@
 #include "iomap.h"
 #include "common.h"
 #include "clockdomain.h"
+#include "pm.h"
 
 #define CPU_MASK		0xff0ffff0
 #define CPU_CORTEX_A9		0x410FC090
@@ -118,6 +119,24 @@ static int __cpuinit omap4_boot_secondary(unsigned int cpu, struct task_struct *
 	 *	4.3.4.2 Power States of CPU0 and CPU1
 	 */
 	if (booted) {
+		/*
+		 * GIC distributor control register has changed between
+		 * CortexA9 r1pX and r2pX. The Control Register secure
+		 * banked version is now composed of 2 bits:
+		 * bit 0 == Secure Enable
+		 * bit 1 == Non-Secure Enable
+		 * The Non-Secure banked register has not changed
+		 * Because the ROM Code is based on the r1pX GIC, the CPU1
+		 * GIC restoration will cause a problem to CPU0 Non-Secure SW.
+		 * The workaround must be:
+		 * 1) Before doing the CPU1 wakeup, CPU0 must disable
+		 * the GIC distributor
+		 * 2) CPU1 must re-enable the GIC distributor on
+		 * it's wakeup path.
+		 */
+		if (IS_PM44XX_ERRATUM(PM_OMAP4_ROM_SMP_BOOT_ERRATUM_GICD))
+			gic_dist_disable();
+
 		clkdm_wakeup(cpu1_clkdm);
 		clkdm_allow_idle(cpu1_clkdm);
 	} else {
@@ -138,7 +157,14 @@ static int __cpuinit omap4_boot_secondary(unsigned int cpu, struct task_struct *
 
 static void __init wakeup_secondary(void)
 {
+	void *startup_addr = omap_secondary_startup;
 	void __iomem *base = omap_get_wakeupgen_base();
+
+	if (cpu_is_omap446x()) {
+		startup_addr = omap_secondary_startup_4460;
+		pm44xx_errata |= PM_OMAP4_ROM_SMP_BOOT_ERRATUM_GICD;
+	}
+
 	/*
 	 * Write the address of secondary startup routine into the
 	 * AuxCoreBoot1 where ROM code will jump and start executing
@@ -146,7 +172,7 @@ static void __init wakeup_secondary(void)
 	 * A barrier is added to ensure that write buffer is drained
 	 */
 	if (omap_secure_apis_support())
-		omap_auxcoreboot_addr(virt_to_phys(omap_secondary_startup));
+		omap_auxcoreboot_addr(virt_to_phys(startup_addr));
 	else
 		__raw_writel(virt_to_phys(omap5_secondary_startup),
 						base + OMAP_AUX_CORE_BOOT_1);

commit 25468fe89f88c4ceeef94526e94ae0db176f6999
Merge: a283580c52d3 28e8e29c616f
Author: Olof Johansson <olof@lixom.net>
Date:   Sat Sep 22 00:06:21 2012 -0700

    Merge branch 'multiplatform/smp_ops' into next/multiplatform
    
    * multiplatform/smp_ops:
      ARM: consolidate pen_release instead of having per platform definitions
      ARM: smp: Make SMP operations mandatory
      ARM: SoC: convert spear13xx to SMP operations
      ARM: SoC: convert imx6q to SMP operations
      ARM: SoC: convert highbank to SMP operations
      ARM: SoC: convert shmobile SMP to SMP operations
      ARM: SoC: convert ux500 to SMP operations
      ARM: SoC: convert MSM to SMP operations
      ARM: SoC: convert Exynos4 to SMP operations
      ARM: SoC: convert Tegra to SMP operations
      ARM: SoC: convert OMAP4 to SMP operations
      ARM: SoC: convert VExpress/RealView to SMP operations
      ARM: SoC: add per-platform SMP operations
    
    Conflicts due to file moves or removals in:
            arch/arm/mach-msm/board-msm8960.c
            arch/arm/mach-msm/board-msm8x60.c
            arch/arm/mach-tegra/board-harmony.c
            arch/arm/mach-tegra/board-trimslice.c
    
    Conflicts due to board file cleanup:
            arch/arm/mach-tegra/board-paz00.c
    
    Conflicts due to cpu hotplug addition:
            arch/arm/mach-tegra/hotplug.c
    
    Signed-off-by: Olof Johansson <olof@lixom.net>

commit 732231a7c04f334e69af89454073f7a23405468b
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Sep 20 11:41:16 2012 -0700

    ARM: OMAP2+: Make omap-wakeupgen.h local
    
    This can be local to mach-omap2.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index cf2b32e99cb7..06d8bc3a8886 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -25,7 +25,7 @@
 #include <asm/smp_scu.h>
 
 #include "omap-secure.h"
-#include <mach/omap-wakeupgen.h>
+#include "omap-wakeupgen.h"
 #include <asm/cputype.h>
 
 #include "soc.h"

commit c1db9d735c4d8de331611b7cc62926ffb7a7512d
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Sep 20 11:41:14 2012 -0700

    ARM: OMAP2+: Make omap-secure.h local
    
    This can be local to mach-omap2.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 19cc5f504f7e..cf2b32e99cb7 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -24,7 +24,7 @@
 #include <asm/hardware/gic.h>
 #include <asm/smp_scu.h>
 
-#include <mach/omap-secure.h>
+#include "omap-secure.h"
 #include <mach/omap-wakeupgen.h>
 #include <asm/cputype.h>
 

commit 06915321e7935d2eb778f0a7f333b2603c1404df
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Thu Sep 8 13:15:22 2011 +0100

    ARM: SoC: convert OMAP4 to SMP operations
    
    Convert OMAP4 to use struct smp_operations to provide its SMP
    and CPU hotplug operations.
    
    Tested on both Panda and IGEPv2 (MULTI_OMAP kernel)
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 9a35adf91232..046fa0d6969f 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -49,7 +49,7 @@ void __iomem *omap4_get_scu_base(void)
 	return scu_base;
 }
 
-void __cpuinit platform_secondary_init(unsigned int cpu)
+static void __cpuinit omap4_secondary_init(unsigned int cpu)
 {
 	/*
 	 * Configure ACTRL and enable NS SMP bit access on CPU1 on HS device.
@@ -77,7 +77,7 @@ void __cpuinit platform_secondary_init(unsigned int cpu)
 	spin_unlock(&boot_lock);
 }
 
-int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
+static int __cpuinit omap4_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	static struct clockdomain *cpu1_clkdm;
 	static bool booted;
@@ -165,7 +165,7 @@ static void __init wakeup_secondary(void)
  * Initialise the CPU possible map early - this describes the CPUs
  * which may be present or become present in the system.
  */
-void __init smp_init_cpus(void)
+static void __init omap4_smp_init_cpus(void)
 {
 	unsigned int i = 0, ncores = 1, cpu_id;
 
@@ -196,7 +196,7 @@ void __init smp_init_cpus(void)
 	set_smp_cross_call(gic_raise_softirq);
 }
 
-void __init platform_smp_prepare_cpus(unsigned int max_cpus)
+static void __init omap4_smp_prepare_cpus(unsigned int max_cpus)
 {
 
 	/*
@@ -207,3 +207,13 @@ void __init platform_smp_prepare_cpus(unsigned int max_cpus)
 		scu_enable(scu_base);
 	wakeup_secondary();
 }
+
+struct smp_operations omap4_smp_ops __initdata = {
+	.smp_init_cpus		= omap4_smp_init_cpus,
+	.smp_prepare_cpus	= omap4_smp_prepare_cpus,
+	.smp_secondary_init	= omap4_secondary_init,
+	.smp_boot_secondary	= omap4_boot_secondary,
+#ifdef CONFIG_HOTPLUG_CPU
+	.cpu_die		= omap4_cpu_die,
+#endif
+};

commit dbc04161048dd5e5c3c58546688a0cc0854051e9
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Aug 31 10:59:07 2012 -0700

    ARM: OMAP: Split plat/hardware.h, use local soc.h for omap2+
    
    As the plat and mach includes need to disappear for single zImage work,
    we need to remove plat/hardware.h.
    
    Do this by splitting plat/hardware.h into omap1 and omap2+ specific files.
    
    The old plat/hardware.h already has omap1 only defines, so it gets moved
    to mach/hardware.h for omap1. For omap2+, we use the local soc.h
    that for now just includes the related SoC headers to keep this patch more
    readable.
    
    Note that the local soc.h still includes plat/cpu.h that can be dealt
    with in later patches. Let's also include plat/serial.h from common.h for
    all the board-*.c files. This allows making the include files local later
    on without patching these files again.
    
    Note that only minimal changes are done in this patch for the
    drivers/watchdog/omap_wdt.c driver to keep things compiling. Further
    patches are needed to eventually remove cpu_is_omap usage in the drivers.
    
    Also only minimal changes are done to sound/soc/omap/* to remove the
    unneeded includes and to define OMAP44XX_MCPDM_L3_BASE locally so there's
    no need to include omap44xx.h.
    
    While at it, also sort some of the includes in the standard way.
    
    Cc: linux-watchdog@vger.kernel.org
    Cc: alsa-devel@alsa-project.org
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Jarkko Nikula <jarkko.nikula@bitmer.com>
    Cc: Liam Girdwood <lrg@ti.com>
    Acked-by: Wim Van Sebroeck <wim@iguana.be>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 9a35adf91232..19cc5f504f7e 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -24,11 +24,11 @@
 #include <asm/hardware/gic.h>
 #include <asm/smp_scu.h>
 
-#include <mach/hardware.h>
 #include <mach/omap-secure.h>
 #include <mach/omap-wakeupgen.h>
 #include <asm/cputype.h>
 
+#include "soc.h"
 #include "iomap.h"
 #include "common.h"
 #include "clockdomain.h"

commit cea8f46c36c3f82860b038aa23a46e16757666ba
Merge: c1e7179a3891 91b006def384
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 27 15:14:26 2012 -0700

    Merge branch 'for-linus' of git://git.linaro.org/people/rmk/linux-arm
    
    Pull ARM updates from Russell King:
     "First ARM push of this merge window, post me coming back from holiday.
      This is what has been in linux-next for the last few weeks.  Not much
      to say which isn't described by the commit summaries."
    
    * 'for-linus' of git://git.linaro.org/people/rmk/linux-arm: (32 commits)
      ARM: 7463/1: topology: Update cpu_power according to DT information
      ARM: 7462/1: topology: factorize the update of sibling masks
      ARM: 7461/1: topology: Add arch_scale_freq_power function
      ARM: 7456/1: ptrace: provide separate functions for tracing syscall {entry,exit}
      ARM: 7455/1: audit: move syscall auditing until after ptrace SIGTRAP handling
      ARM: 7454/1: entry: don't bother with syscall tracing on ret_from_fork path
      ARM: 7453/1: audit: only allow syscall auditing for pure EABI userspace
      ARM: 7452/1: delay: allow timer-based delay implementation to be selected
      ARM: 7451/1: arch timer: implement read_current_timer and get_cycles
      ARM: 7450/1: dcache: select DCACHE_WORD_ACCESS for little-endian ARMv6+ CPUs
      ARM: 7449/1: use generic strnlen_user and strncpy_from_user functions
      ARM: 7448/1: perf: remove arm_perf_pmu_ids global enumeration
      ARM: 7447/1: rwlocks: remove unused branch labels from trylock routines
      ARM: 7446/1: spinlock: use ticket algorithm for ARMv6+ locking implementation
      ARM: 7445/1: mm: update CONTEXTIDR register to contain PID of current process
      ARM: 7444/1: kernel: add arch-timer C3STOP feature
      ARM: 7460/1: remove asm/locks.h
      ARM: 7439/1: head.S: simplify initial page table mapping
      ARM: 7437/1: zImage: Allow DTB command line concatenation with ATAG_CMDLINE
      ARM: 7436/1: Do not map the vectors page as write-through on UP systems
      ...

commit 79d15ce999e7ae3e4b6cd71a720915e5d1c6c9c6
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Jun 11 20:24:07 2012 +0100

    ARM: OMAP: use SGI0 to wake secondary CPUs
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index deffbf1c9627..596eb70d37be 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -111,7 +111,7 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 		booted = true;
 	}
 
-	gic_raise_softirq(cpumask_of(cpu), 1);
+	gic_raise_softirq(cpumask_of(cpu), 0);
 
 	/*
 	 * Now the secondary core is starting up let it run its

commit 283f708ca846903ee045e9f9374d627f7b47a711
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Mon Mar 19 19:29:41 2012 +0530

    ARM: OMAP5: Add SMP support
    
    Add OMAP5 SMP boot support using OMAP4 SMP code. The relevant code paths
    are runtime checked using cpu id
    
    Signed-off-by: R Sricharan <r.sricharan@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index badfe398038e..7d118b9bdd5f 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -33,6 +33,12 @@
 #include "common.h"
 #include "clockdomain.h"
 
+#define CPU_MASK		0xff0ffff0
+#define CPU_CORTEX_A9		0x410FC090
+#define CPU_CORTEX_A15		0x410FC0F0
+
+#define OMAP5_CORE_COUNT	0x2
+
 /* SCU base address */
 static void __iomem *scu_base;
 
@@ -133,7 +139,6 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 static void __init wakeup_secondary(void)
 {
 	void __iomem *base = omap_get_wakeupgen_base();
-
 	/*
 	 * Write the address of secondary startup routine into the
 	 * AuxCoreBoot1 where ROM code will jump and start executing
@@ -162,16 +167,21 @@ static void __init wakeup_secondary(void)
  */
 void __init smp_init_cpus(void)
 {
-	unsigned int i, ncores;
-
-	/*
-	 * Currently we can't call ioremap here because
-	 * SoC detection won't work until after init_early.
-	 */
-	scu_base =  OMAP2_L4_IO_ADDRESS(OMAP44XX_SCU_BASE);
-	BUG_ON(!scu_base);
-
-	ncores = scu_get_core_count(scu_base);
+	unsigned int i = 0, ncores = 1, cpu_id;
+
+	/* Use ARM cpuid check here, as SoC detection will not work so early */
+	cpu_id = read_cpuid(CPUID_ID) & CPU_MASK;
+	if (cpu_id == CPU_CORTEX_A9) {
+		/*
+		 * Currently we can't call ioremap here because
+		 * SoC detection won't work until after init_early.
+		 */
+		scu_base =  OMAP2_L4_IO_ADDRESS(OMAP44XX_SCU_BASE);
+		BUG_ON(!scu_base);
+		ncores = scu_get_core_count(scu_base);
+	} else if (cpu_id == CPU_CORTEX_A15) {
+		ncores = OMAP5_CORE_COUNT;
+	}
 
 	/* sanity check */
 	if (ncores > nr_cpu_ids) {
@@ -193,6 +203,7 @@ void __init platform_smp_prepare_cpus(unsigned int max_cpus)
 	 * Initialise the SCU and wake up the secondary core using
 	 * wakeup_secondary().
 	 */
-	scu_enable(scu_base);
+	if (scu_base)
+		scu_enable(scu_base);
 	wakeup_secondary();
 }

commit 247c445c0fbd52c77e497ff5bfcf0dceb8afea8d
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Wed May 9 20:38:35 2012 +0530

    ARM: OMAP5: Add the WakeupGen IP updates
    
    OMAP4 and OMAP5 share same WakeupGen IP with below few udpates on OMAP5.
    - Additional 32 interrupt support is added w.r.t OMAP4 design.
    - The AUX CORE boot registers are now made accessible from non-secure SW.
    - SAR offset are changed and PTMSYNC* registers are removed from SAR.
    
    Patch updates the WakeupGen code accordingly.
    
    Signed-off-by: R Sricharan <r.sricharan@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index deffbf1c9627..badfe398038e 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -26,6 +26,8 @@
 
 #include <mach/hardware.h>
 #include <mach/omap-secure.h>
+#include <mach/omap-wakeupgen.h>
+#include <asm/cputype.h>
 
 #include "iomap.h"
 #include "common.h"
@@ -73,6 +75,8 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	static struct clockdomain *cpu1_clkdm;
 	static bool booted;
+	void __iomem *base = omap_get_wakeupgen_base();
+
 	/*
 	 * Set synchronisation state between this boot processor
 	 * and the secondary one
@@ -85,7 +89,11 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	 * the AuxCoreBoot1 register is updated with cpu state
 	 * A barrier is added to ensure that write buffer is drained
 	 */
-	omap_modify_auxcoreboot0(0x200, 0xfffffdff);
+	if (omap_secure_apis_support())
+		omap_modify_auxcoreboot0(0x200, 0xfffffdff);
+	else
+		__raw_writel(0x20, base + OMAP_AUX_CORE_BOOT_0);
+
 	flush_cache_all();
 	smp_wmb();
 
@@ -124,13 +132,20 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 
 static void __init wakeup_secondary(void)
 {
+	void __iomem *base = omap_get_wakeupgen_base();
+
 	/*
 	 * Write the address of secondary startup routine into the
 	 * AuxCoreBoot1 where ROM code will jump and start executing
 	 * on secondary core once out of WFE
 	 * A barrier is added to ensure that write buffer is drained
 	 */
-	omap_auxcoreboot_addr(virt_to_phys(omap_secondary_startup));
+	if (omap_secure_apis_support())
+		omap_auxcoreboot_addr(virt_to_phys(omap_secondary_startup));
+	else
+		__raw_writel(virt_to_phys(omap5_secondary_startup),
+						base + OMAP_AUX_CORE_BOOT_1);
+
 	smp_wmb();
 
 	/*

commit ee0839c22cdda7f2e5f06e2d0351e2b49e0975ff
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Feb 24 10:34:35 2012 -0800

    ARM: OMAP2+: Move most of plat/io.h into local iomap.h
    
    There's no need to have these defines in plat/io.h.
    
    Note that we now need to ifdef omap_read/write calls
    as they will be available for omap1 only.
    
    While at it, clean up the includes to group them like
    they typically are grouped.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index c1bf3ef0ba02..deffbf1c9627 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -23,11 +23,12 @@
 #include <asm/cacheflush.h>
 #include <asm/hardware/gic.h>
 #include <asm/smp_scu.h>
+
 #include <mach/hardware.h>
 #include <mach/omap-secure.h>
 
+#include "iomap.h"
 #include "common.h"
-
 #include "clockdomain.h"
 
 /* SCU base address */

commit e97ca477e993da87769f967bd6f2602a7eab9715
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Wed Jun 16 22:19:49 2010 +0530

    ARM: OMAP4: PM: CPU1 wakeup workaround from Low power modes
    
    The SGI(Software Generated Interrupts) are not wakeup capable from
    low power states. This is known limitation on OMAP4 and needs to be
    worked around by using software forced clockdomain wake-up. CPU0 forces
    the CPU1 clockdomain to software force wakeup.
    
    More details can be found in OMAP4430 TRM - Version J
    Section :
            4.3.4.2 Power States of CPU0 and CPU1
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Tested-by: Vishwanath BS <vishwanath.bs@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index ee83808de0ff..c1bf3ef0ba02 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -28,6 +28,8 @@
 
 #include "common.h"
 
+#include "clockdomain.h"
+
 /* SCU base address */
 static void __iomem *scu_base;
 
@@ -68,6 +70,8 @@ void __cpuinit platform_secondary_init(unsigned int cpu)
 
 int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
+	static struct clockdomain *cpu1_clkdm;
+	static bool booted;
 	/*
 	 * Set synchronisation state between this boot processor
 	 * and the secondary one
@@ -83,6 +87,29 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	omap_modify_auxcoreboot0(0x200, 0xfffffdff);
 	flush_cache_all();
 	smp_wmb();
+
+	if (!cpu1_clkdm)
+		cpu1_clkdm = clkdm_lookup("mpu1_clkdm");
+
+	/*
+	 * The SGI(Software Generated Interrupts) are not wakeup capable
+	 * from low power states. This is known limitation on OMAP4 and
+	 * needs to be worked around by using software forced clockdomain
+	 * wake-up. To wakeup CPU1, CPU0 forces the CPU1 clockdomain to
+	 * software force wakeup. The clockdomain is then put back to
+	 * hardware supervised mode.
+	 * More details can be found in OMAP4430 TRM - Version J
+	 * Section :
+	 *	4.3.4.2 Power States of CPU0 and CPU1
+	 */
+	if (booted) {
+		clkdm_wakeup(cpu1_clkdm);
+		clkdm_allow_idle(cpu1_clkdm);
+	} else {
+		dsb_sev();
+		booted = true;
+	}
+
 	gic_raise_softirq(cpumask_of(cpu), 1);
 
 	/*

commit b2b9762f76981c16a8768255284efeae7f27e4f1
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Wed Jun 16 22:19:48 2010 +0530

    ARM: OMAP4: PM: Add CPUX OFF mode support
    
    This patch adds the CPU0 and CPU1 off mode support. CPUX close switch
    retention (CSWR) is not supported by hardware design.
    
    The CPUx OFF mode isn't supported on OMAP4430 ES1.0
    
    CPUx sleep code is common for hotplug, suspend and CPUilde.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Tested-by: Vishwanath BS <vishwanath.bs@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 74e90b40a0c7..ee83808de0ff 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -24,6 +24,7 @@
 #include <asm/hardware/gic.h>
 #include <asm/smp_scu.h>
 #include <mach/hardware.h>
+#include <mach/omap-secure.h>
 
 #include "common.h"
 
@@ -39,6 +40,18 @@ void __iomem *omap4_get_scu_base(void)
 
 void __cpuinit platform_secondary_init(unsigned int cpu)
 {
+	/*
+	 * Configure ACTRL and enable NS SMP bit access on CPU1 on HS device.
+	 * OMAP44XX EMU/HS devices - CPU0 SMP bit access is enabled in PPA
+	 * init and for CPU1, a secure PPA API provided. CPU0 must be ON
+	 * while executing NS_SMP API on CPU1 and PPA version must be 1.4.0+.
+	 * OMAP443X GP devices- SMP bit isn't accessible.
+	 * OMAP446X GP devices - SMP bit access is enabled on both CPUs.
+	 */
+	if (cpu_is_omap443x() && (omap_type() != OMAP2_DEVICE_TYPE_GP))
+		omap_secure_dispatcher(OMAP4_PPA_CPU_ACTRL_SMP_INDEX,
+							4, 0, 0, 0, 0, 0);
+
 	/*
 	 * If any interrupts are already enabled for the primary
 	 * core (e.g. timer irq), then they will not have been enabled

commit 02afe8a7f23d562cec76743ae34c4735d2819345
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Thu Mar 3 18:03:25 2011 +0530

    ARM: OMAP4: Export omap4_get_base*() rather than global address pointers
    
    This patch exports APIs to get base address for GIC
    distributor, CPU interface, SCU and PL310 L2 Cache which
    are used in OMAP4 PM code.
    
    This was suggested by Kevin Hilman <khilman@ti.com> during
    OMAP4 PM code review.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Jean Pihet <j-pihet@ti.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Tested-by: Vishwanath BS <vishwanath.bs@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index e99bc6cd4714..74e90b40a0c7 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -32,6 +32,11 @@ static void __iomem *scu_base;
 
 static DEFINE_SPINLOCK(boot_lock);
 
+void __iomem *omap4_get_scu_base(void)
+{
+	return scu_base;
+}
+
 void __cpuinit platform_secondary_init(unsigned int cpu)
 {
 	/*

commit 4e65331c6bb4a777bd61a4dac0daa9fc47777b63
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu Nov 10 22:45:17 2011 +0100

    ARM: 7159/1: OMAP: Introduce local common.h files
    
    As suggested by Russell King - ARM Linux <linux@arm.linux.org.uk>,
    there's no need to keep local prototypes in non-local headers.
    
    Add mach-omap1/common.h and mach-omap2/common.h and move the
    local prototypes there from plat/common.h and mach/omap4-common.h.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 4412ddb7b3f6..e99bc6cd4714 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -24,7 +24,8 @@
 #include <asm/hardware/gic.h>
 #include <asm/smp_scu.h>
 #include <mach/hardware.h>
-#include <mach/omap4-common.h>
+
+#include "common.h"
 
 /* SCU base address */
 static void __iomem *scu_base;

commit 81a3c10ce8a7fd5bf9a06bfc38bd417512911831
Merge: 6585dea1f99c df80442d1ee2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 1 20:58:25 2011 -0700

    Merge branch 'next/cleanup2' of git://git.linaro.org/people/arnd/arm-soc
    
    * 'next/cleanup2' of git://git.linaro.org/people/arnd/arm-soc: (31 commits)
      ARM: OMAP: Warn if omap_ioremap is called before SoC detection
      ARM: OMAP: Move set_globals initialization to happen in init_early
      ARM: OMAP: Map SRAM later on with ioremap_exec()
      ARM: OMAP: Remove calls to SRAM allocations for framebuffer
      ARM: OMAP: Avoid cpu_is_omapxxxx usage until map_io is done
      ARM: OMAP1: Use generic map_io, init_early and init_irq
      arm/dts: OMAP3+: Add mpu, dsp and iva nodes
      arm/dts: OMAP4: Add a main ocp entry bound to l3-noc driver
      ARM: OMAP2+: l3-noc: Add support for device-tree
      ARM: OMAP2+: board-generic: Add i2c static init
      ARM: OMAP2+: board-generic: Add DT support to generic board
      arm/dts: Add support for OMAP3 Beagle board
      arm/dts: Add initial device tree support for OMAP3 SoC
      arm/dts: Add support for OMAP4 SDP board
      arm/dts: Add support for OMAP4 PandaBoard
      arm/dts: Add initial device tree support for OMAP4 SoC
      ARM: OMAP: omap_device: Add a method to build an omap_device from a DT node
      ARM: OMAP: omap_device: Add omap_device_[alloc|delete] for DT integration
      of: Add helpers to get one string in multiple strings property
      ARM: OMAP2+: devices: Remove all omap_device_pm_latency structures
      ...
    
    Fix up trivial header file conflicts in arch/arm/mach-omap2/board-generic.c

commit a06f916b7a9b57447ceb875eb0a89f1a66b31bca
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Oct 20 22:04:18 2011 +0100

    ARM: smp: fix clipping of number of CPUs
    
    Rather than clipping the number of CPUs using the compile-time NR_CPUS
    constant, use the runtime nr_cpu_ids value instead.  This allows the
    nr_cpus command line option to work as expected.
    
    Cc: <stable@kernel.org>
    Reported-by: Mark Salter <msalter@redhat.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index ce65e9329c7b..889464dc7b2d 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -109,12 +109,10 @@ void __init smp_init_cpus(void)
 	ncores = scu_get_core_count(scu_base);
 
 	/* sanity check */
-	if (ncores > NR_CPUS) {
-		printk(KERN_WARNING
-		       "OMAP4: no. of cores (%d) greater than configured "
-		       "maximum of %d - clipping\n",
-		       ncores, NR_CPUS);
-		ncores = NR_CPUS;
+	if (ncores > nr_cpu_ids) {
+		pr_warn("SMP: %u cores greater than maximum (%u), clipping\n",
+			ncores, nr_cpu_ids);
+		ncores = nr_cpu_ids;
 	}
 
 	for (i = 0; i < ncores; i++)

commit 4c3cf90117f1f4906d5975aeccc5ffd414807fd2
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 4 18:17:41 2011 -0700

    ARM: OMAP: Move set_globals initialization to happen in init_early
    
    Otherwise we can't do generic map_io as we currently rely on
    static mappings that work only because of arch_ioremap.
    
    Acked-by: Nicolas Pitre <nicolas.pitre@linaro.org>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Tested-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index ce65e9329c7b..11e25a4c4bd5 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -102,8 +102,11 @@ void __init smp_init_cpus(void)
 {
 	unsigned int i, ncores;
 
-	/* Never released */
-	scu_base = ioremap(OMAP44XX_SCU_BASE, SZ_256);
+	/*
+	 * Currently we can't call ioremap here because
+	 * SoC detection won't work until after init_early.
+	 */
+	scu_base =  OMAP2_L4_IO_ADDRESS(OMAP44XX_SCU_BASE);
 	BUG_ON(!scu_base);
 
 	ncores = scu_get_core_count(scu_base);

commit 7fa22bd5460bb2021729fa5a1012c60b9b3a56e2
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jul 7 01:56:51 2011 +0100

    ARM: 6993/1: platsmp: Allow secondary cpu hotplug with maxcpus=1
    
    If an ARM system has multiple cpus in the same socket and the
    kernel is booted with maxcpus=1, secondary cpus are possible but
    not present due to how platform_smp_prepare_cpus() is called.
    Since most typical ARM processors don't actually support physical
    hotplug, initialize the present map to be equal to the possible
    map in generic ARM SMP code. Also, always call
    platform_smp_prepare_cpus() as long as max_cpus is non-zero (0
    means no SMP) to allow platform code to do any SMP setup.
    
    After applying this patch it's possible to boot an ARM system
    with maxcpus=1 on the command line and then hotplug in secondary
    cpus via sysfs. This is more in line with how x86 does things.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: David Brown <davidb@codeaurora.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Srinidhi Kasagar <srinidhi.kasagar@stericsson.com>
    Cc: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index ecfe93c4b585..ce65e9329c7b 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -125,14 +125,6 @@ void __init smp_init_cpus(void)
 
 void __init platform_smp_prepare_cpus(unsigned int max_cpus)
 {
-	int i;
-
-	/*
-	 * Initialise the present map, which describes the set of CPUs
-	 * actually populated at the present time.
-	 */
-	for (i = 0; i < max_cpus; i++)
-		set_cpu_present(i, true);
 
 	/*
 	 * Initialise the SCU and wake up the secondary core using

commit 0f7b332f9777819a39a3b325690379a7efef89d1
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Apr 3 13:01:30 2011 +0100

    ARM: consolidate SMP cross call implementation
    
    Rather than having each platform class provide a mach/smp.h header for
    smp_cross_call(), arrange for them to register the function with the
    core ARM SMP code instead.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index b66cfe8bc464..ecfe93c4b585 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -21,6 +21,7 @@
 #include <linux/io.h>
 
 #include <asm/cacheflush.h>
+#include <asm/hardware/gic.h>
 #include <asm/smp_scu.h>
 #include <mach/hardware.h>
 #include <mach/omap4-common.h>
@@ -63,7 +64,7 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	omap_modify_auxcoreboot0(0x200, 0xfffffdff);
 	flush_cache_all();
 	smp_wmb();
-	smp_cross_call(cpumask_of(cpu), 1);
+	gic_raise_softirq(cpumask_of(cpu), 1);
 
 	/*
 	 * Now the secondary core is starting up let it run its
@@ -118,6 +119,8 @@ void __init smp_init_cpus(void)
 
 	for (i = 0; i < ncores; i++)
 		set_cpu_possible(i, true);
+
+	set_smp_cross_call(gic_raise_softirq);
 }
 
 void __init platform_smp_prepare_cpus(unsigned int max_cpus)

commit 4073723acb9cdcdbe4df9c0e0c376c65d1697e43
Merge: 58daf18cdcab 4ec3eb136345
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jan 6 22:32:52 2011 +0000

    Merge branch 'misc' into devel
    
    Conflicts:
            arch/arm/Kconfig
            arch/arm/common/Makefile
            arch/arm/kernel/Makefile
            arch/arm/kernel/smp.c

commit 2c0136dba4e43b0916ccc9ecc7f11e6d6b73f046
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Dec 3 15:00:49 2010 +0000

    ARM: SMP: consolidate trace_hardirqs_off() into common SMP code
    
    All platforms call trace_hardirqs_off() in their secondary startup code,
    so move this into the core SMP code - it doesn't need to be in the
    per-platform code.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 3c3d6796c97c..9fed631ba046 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -32,8 +32,6 @@ static DEFINE_SPINLOCK(boot_lock);
 
 void __cpuinit platform_secondary_init(unsigned int cpu)
 {
-	trace_hardirqs_off();
-
 	/*
 	 * If any interrupts are already enabled for the primary
 	 * core (e.g. timer irq), then they will not have been enabled

commit 05c74a6cbcfb416286a947668ba32f63d99fe74a
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Dec 3 11:09:48 2010 +0000

    ARM: SMP: consolidate the common parts of smp_prepare_cpus()
    
    There is a certain amount of smp_prepare_cpus() which doesn't belong
    in the platform support code - that is, code which is invariant to the
    SMP implementation.  Move this code into arch/arm/kernel/smp.c, and
    add a platform_ prefix to the original function.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 405a8fc53308..3c3d6796c97c 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -21,7 +21,6 @@
 #include <linux/io.h>
 
 #include <asm/cacheflush.h>
-#include <asm/localtimer.h>
 #include <asm/smp_scu.h>
 #include <mach/hardware.h>
 #include <mach/omap4-common.h>
@@ -123,20 +122,10 @@ void __init smp_init_cpus(void)
 		set_cpu_possible(i, true);
 }
 
-void __init smp_prepare_cpus(unsigned int max_cpus)
+void __init platform_smp_prepare_cpus(unsigned int max_cpus)
 {
-	unsigned int ncores = num_possible_cpus();
-	unsigned int cpu = smp_processor_id();
 	int i;
 
-	smp_store_cpu_info(cpu);
-
-	/*
-	 * are we trying to boot more cores than exist?
-	 */
-	if (max_cpus > ncores)
-		max_cpus = ncores;
-
 	/*
 	 * Initialise the present map, which describes the set of CPUs
 	 * actually populated at the present time.
@@ -144,18 +133,10 @@ void __init smp_prepare_cpus(unsigned int max_cpus)
 	for (i = 0; i < max_cpus; i++)
 		set_cpu_present(i, true);
 
-	if (max_cpus > 1) {
-		/*
-		 * Enable the local timer or broadcast device for the
-		 * boot CPU, but only if we have more than one CPU.
-		 */
-		percpu_timer_setup();
-
-		/*
-		 * Initialise the SCU and wake up the secondary core using
-		 * wakeup_secondary().
-		 */
-		scu_enable(scu_base);
-		wakeup_secondary();
-	}
+	/*
+	 * Initialise the SCU and wake up the secondary core using
+	 * wakeup_secondary().
+	 */
+	scu_enable(scu_base);
+	wakeup_secondary();
 }

commit fd778f0ad7dda1108281410ddca0d07936256d3c
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Dec 2 18:09:37 2010 +0000

    ARM: SMP: get rid of get_core_count()
    
    We don't need this small function as well as scu_get_core_count()
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 5f10f38354ae..405a8fc53308 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -29,16 +29,6 @@
 /* SCU base address */
 static void __iomem *scu_base;
 
-/*
- * Use SCU config register to count number of cores
- */
-static inline unsigned int get_core_count(void)
-{
-	if (scu_base)
-		return scu_get_core_count(scu_base);
-	return 1;
-}
-
 static DEFINE_SPINLOCK(boot_lock);
 
 void __cpuinit platform_secondary_init(unsigned int cpu)
@@ -118,7 +108,7 @@ void __init smp_init_cpus(void)
 	scu_base = ioremap(OMAP44XX_SCU_BASE, SZ_256);
 	BUG_ON(!scu_base);
 
-	ncores = get_core_count();
+	ncores = scu_get_core_count(scu_base);
 
 	/* sanity check */
 	if (ncores > NR_CPUS) {

commit 8975b6c0fdd57e061f4d1040163778ceaf340ad8
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Dec 3 19:29:53 2010 +0000

    ARM: SMP: Clean up ncores sanity checks
    
    scu_get_core_count() never returns zero cores, so we don't need to
    check and correct if ncores is zero.
    
    Tegra was missing the check against NR_CPUS, leading to a potential
    bitfield overflow if this becomes the case.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 3c87468ce9cb..5f10f38354ae 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -121,12 +121,6 @@ void __init smp_init_cpus(void)
 	ncores = get_core_count();
 
 	/* sanity check */
-	if (ncores == 0) {
-		printk(KERN_ERR
-		       "OMAP4: strange core count of 0? Default to 1\n");
-		ncores = 1;
-	}
-
 	if (ncores > NR_CPUS) {
 		printk(KERN_WARNING
 		       "OMAP4: no. of cores (%d) greater than configured "

commit bbc3d14e9aca023bb98e580aa1c9350af8effdb1
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Dec 3 10:42:58 2010 +0000

    ARM: SMP: move CPU number sanity checks to smp_init_cpus()
    
    Ensure that the number of CPUs is sanity checked before setting
    the number of possible CPUs.  This avoids any chance of overflowing
    the cpu_possible bitmap.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 56a8bce247c8..3c87468ce9cb 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -120,16 +120,6 @@ void __init smp_init_cpus(void)
 
 	ncores = get_core_count();
 
-	for (i = 0; i < ncores; i++)
-		set_cpu_possible(i, true);
-}
-
-void __init smp_prepare_cpus(unsigned int max_cpus)
-{
-	unsigned int ncores = get_core_count();
-	unsigned int cpu = smp_processor_id();
-	int i;
-
 	/* sanity check */
 	if (ncores == 0) {
 		printk(KERN_ERR
@@ -144,6 +134,17 @@ void __init smp_prepare_cpus(unsigned int max_cpus)
 		       ncores, NR_CPUS);
 		ncores = NR_CPUS;
 	}
+
+	for (i = 0; i < ncores; i++)
+		set_cpu_possible(i, true);
+}
+
+void __init smp_prepare_cpus(unsigned int max_cpus)
+{
+	unsigned int ncores = num_possible_cpus();
+	unsigned int cpu = smp_processor_id();
+	int i;
+
 	smp_store_cpu_info(cpu);
 
 	/*

commit 384895330e0f3954d9478fd0853145f9c169df12
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Dec 4 16:01:03 2010 +0000

    ARM: GIC: Remove MMIO address from gic_cpu_init, rename to gic_secondary_init
    
    We don't need to re-pass the base address for the CPU interfaces to the
    GIC for secondary CPUs, as it will never be different from the boot CPU
    - and even if it was, we'd overwrite the boot CPU's base address.
    
    Get rid of this argument, and rename to gic_secondary_init().
    
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Tested-by: Abhijeet Dharmapurikar <adharmap@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 9e9f70e18e3c..9fbac2c39104 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -50,7 +50,7 @@ void __cpuinit platform_secondary_init(unsigned int cpu)
 	 * core (e.g. timer irq), then they will not have been enabled
 	 * for us: do so
 	 */
-	gic_cpu_init(0, gic_cpu_base_addr);
+	gic_secondary_init(0);
 
 	/*
 	 * Synchronise with the boot thread.

commit ad3b6993b9c5482e8a2ec5aed181538c921fdcbd
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Mon Nov 15 09:42:08 2010 +0000

    ARM: SMP: pass an ipi number to smp_cross_call()
    
    This allows us to use smp_cross_call() to trigger a number of different
    software generated interrupts, rather than combining them all on one
    SGI.  Recover the SGI number via do_IPI.
    
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 9e9f70e18e3c..56a8bce247c8 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -76,7 +76,7 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	omap_modify_auxcoreboot0(0x200, 0xfffffdff);
 	flush_cache_all();
 	smp_wmb();
-	smp_cross_call(cpumask_of(cpu));
+	smp_cross_call(cpumask_of(cpu), 1);
 
 	/*
 	 * Now the secondary core is starting up let it run its

commit a4192d32ae6788dc607e96fa85f9c9c8274e2212
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Aug 16 09:21:20 2010 +0300

    omap: Fix sev instruction usage for multi-omap
    
    Otherwise we get the following error with omap3_defconfig and CONFIG_SMP:
    
    Error: selected processor does not support `sev'
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index af3c20c8d3f9..9e9f70e18e3c 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -102,8 +102,7 @@ static void __init wakeup_secondary(void)
 	 * Send a 'sev' to wake the secondary core from WFE.
 	 * Drain the outstanding writes to memory
 	 */
-	dsb();
-	set_event();
+	dsb_sev();
 	mb();
 }
 

commit 7d35b8d09fb0cb0a89c8c265a5bfb52c2867b1d5
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Mon Aug 2 13:18:19 2010 +0300

    omap4: hotplug: Add basic CPU hotplug support
    
    This patch adds cpu hotplug support for OMAP4430. Only CPU inactive
    state is supported as a low power state in the basic hot-plug support
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 1cf52313759e..af3c20c8d3f9 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -73,9 +73,10 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	 * the AuxCoreBoot1 register is updated with cpu state
 	 * A barrier is added to ensure that write buffer is drained
 	 */
-	omap_modify_auxcoreboot0(0x200, 0x0);
+	omap_modify_auxcoreboot0(0x200, 0xfffffdff);
 	flush_cache_all();
 	smp_wmb();
+	smp_cross_call(cpumask_of(cpu));
 
 	/*
 	 * Now the secondary core is starting up let it run its

commit fbc9be106e9f27450ea999da74bc24fad04cf41d
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Fri May 14 12:05:26 2010 -0700

    omap4: Move SOC specific code from board file
    
    This patch moves OMAP4 soc specific code from 4430sdp board file.
    The change is necessary so that newer board support can be added
    with minimal changes. This will be also problematic for
    multi-board, multi-omap builds.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 38153e5fbca0..1cf52313759e 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -24,7 +24,7 @@
 #include <asm/localtimer.h>
 #include <asm/smp_scu.h>
 #include <mach/hardware.h>
-#include <plat/common.h>
+#include <mach/omap4-common.h>
 
 /* SCU base address */
 static void __iomem *scu_base;

commit b2f5c9413cc54000706959fa710c21b2d90a647c
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Fri Dec 11 16:16:35 2009 -0800

    OMAP4: Remove the secondary wait loop
    
    The secondary cores wakes up in time so the wait loop is not
    necessary anymore.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 59e847843af5..38153e5fbca0 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -17,7 +17,6 @@
  */
 #include <linux/init.h>
 #include <linux/device.h>
-#include <linux/jiffies.h>
 #include <linux/smp.h>
 #include <linux/io.h>
 
@@ -62,8 +61,6 @@ void __cpuinit platform_secondary_init(unsigned int cpu)
 
 int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
-	unsigned long timeout;
-
 	/*
 	 * Set synchronisation state between this boot processor
 	 * and the secondary one
@@ -80,10 +77,6 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	flush_cache_all();
 	smp_wmb();
 
-	timeout = jiffies + (1 * HZ);
-	while (time_before(jiffies, timeout))
-		;
-
 	/*
 	 * Now the secondary core is starting up let it run its
 	 * calibrations, then wait for it to finish

commit 942e2c9e529a57ce2bb1cf984d58f88d9b6e77e5
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Fri Dec 11 16:16:35 2009 -0800

    OMAP4: AuxCoreBoot registers only accessible in secure mode
    
    The AuxCoreBoot0 and AuxCoreBoot1 can be only accessed in secure
    mode. Replace the current code with secure monitor API's to access/modify
    these registers.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 4890bcf4dadd..59e847843af5 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -21,15 +21,12 @@
 #include <linux/smp.h>
 #include <linux/io.h>
 
+#include <asm/cacheflush.h>
 #include <asm/localtimer.h>
 #include <asm/smp_scu.h>
 #include <mach/hardware.h>
 #include <plat/common.h>
 
-/* Registers used for communicating startup information */
-static void __iomem *omap4_auxcoreboot_reg0;
-static void __iomem *omap4_auxcoreboot_reg1;
-
 /* SCU base address */
 static void __iomem *scu_base;
 
@@ -74,12 +71,13 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	spin_lock(&boot_lock);
 
 	/*
-	 * Update the AuxCoreBoot1 with boot state for secondary core.
+	 * Update the AuxCoreBoot0 with boot state for secondary core.
 	 * omap_secondary_startup() routine will hold the secondary core till
 	 * the AuxCoreBoot1 register is updated with cpu state
 	 * A barrier is added to ensure that write buffer is drained
 	 */
-	__raw_writel(cpu, omap4_auxcoreboot_reg1);
+	omap_modify_auxcoreboot0(0x200, 0x0);
+	flush_cache_all();
 	smp_wmb();
 
 	timeout = jiffies + (1 * HZ);
@@ -99,17 +97,18 @@ static void __init wakeup_secondary(void)
 {
 	/*
 	 * Write the address of secondary startup routine into the
-	 * AuxCoreBoot0 where ROM code will jump and start executing
+	 * AuxCoreBoot1 where ROM code will jump and start executing
 	 * on secondary core once out of WFE
 	 * A barrier is added to ensure that write buffer is drained
 	 */
-	__raw_writel(virt_to_phys(omap_secondary_startup),	   \
-					omap4_auxcoreboot_reg0);
+	omap_auxcoreboot_addr(virt_to_phys(omap_secondary_startup));
 	smp_wmb();
 
 	/*
 	 * Send a 'sev' to wake the secondary core from WFE.
+	 * Drain the outstanding writes to memory
 	 */
+	dsb();
 	set_event();
 	mb();
 }
@@ -136,7 +135,6 @@ void __init smp_prepare_cpus(unsigned int max_cpus)
 {
 	unsigned int ncores = get_core_count();
 	unsigned int cpu = smp_processor_id();
-	void __iomem *omap4_wkupgen_base;
 	int i;
 
 	/* sanity check */
@@ -168,12 +166,6 @@ void __init smp_prepare_cpus(unsigned int max_cpus)
 	for (i = 0; i < max_cpus; i++)
 		set_cpu_present(i, true);
 
-	/* Never released */
-	omap4_wkupgen_base = ioremap(OMAP44XX_WKUPGEN_BASE, SZ_4K);
-	BUG_ON(!omap4_wkupgen_base);
-	omap4_auxcoreboot_reg0 = omap4_wkupgen_base + 0x800;
-	omap4_auxcoreboot_reg1 = omap4_wkupgen_base + 0x804;
-
 	if (max_cpus > 1) {
 		/*
 		 * Enable the local timer or broadcast device for the

commit ce491cf85466c3377228c5a852ea627ec5136956
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Oct 20 09:40:47 2009 -0700

    omap: headers: Move remaining headers from include/mach to include/plat
    
    Move the remaining headers under plat-omap/include/mach
    to plat-omap/include/plat. Also search and replace the
    files using these headers to include using the right path.
    
    This was done with:
    
    #!/bin/bash
    mach_dir_old="arch/arm/plat-omap/include/mach"
    plat_dir_new="arch/arm/plat-omap/include/plat"
    headers=$(cd $mach_dir_old && ls *.h)
    omap_dirs="arch/arm/*omap*/ \
    drivers/video/omap \
    sound/soc/omap"
    other_files="drivers/leds/leds-ams-delta.c \
    drivers/mfd/menelaus.c \
    drivers/mfd/twl4030-core.c \
    drivers/mtd/nand/ams-delta.c"
    
    for header in $headers; do
            old="#include <mach\/$header"
            new="#include <plat\/$header"
            for dir in $omap_dirs; do
                    find $dir -type f -name \*.[chS] | \
                            xargs sed -i "s/$old/$new/"
            done
            find drivers/ -type f -name \*omap*.[chS] | \
                    xargs sed -i "s/$old/$new/"
            for file in $other_files; do
                    sed -i "s/$old/$new/" $file
            done
    done
    
    for header in $(ls $mach_dir_old/*.h); do
            git mv $header $plat_dir_new/
    done
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 8813ac25c5ed..4890bcf4dadd 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -24,7 +24,7 @@
 #include <asm/localtimer.h>
 #include <asm/smp_scu.h>
 #include <mach/hardware.h>
-#include <mach/common.h>
+#include <plat/common.h>
 
 /* Registers used for communicating startup information */
 static void __iomem *omap4_auxcoreboot_reg0;

commit e4e7a13af2007edf215ad1164fc8d94c366cb72c
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Oct 19 15:25:26 2009 -0700

    omap: Use ioremap for omap4 L4 code
    
    Use ioremap for omap4 L4 code
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 48ee295db275..8813ac25c5ed 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -24,13 +24,14 @@
 #include <asm/localtimer.h>
 #include <asm/smp_scu.h>
 #include <mach/hardware.h>
+#include <mach/common.h>
 
 /* Registers used for communicating startup information */
-#define OMAP4_AUXCOREBOOT_REG0		(OMAP44XX_VA_WKUPGEN_BASE + 0x800)
-#define OMAP4_AUXCOREBOOT_REG1		(OMAP44XX_VA_WKUPGEN_BASE + 0x804)
+static void __iomem *omap4_auxcoreboot_reg0;
+static void __iomem *omap4_auxcoreboot_reg1;
 
 /* SCU base address */
-static void __iomem *scu_base = OMAP44XX_VA_SCU_BASE;
+static void __iomem *scu_base;
 
 /*
  * Use SCU config register to count number of cores
@@ -53,8 +54,7 @@ void __cpuinit platform_secondary_init(unsigned int cpu)
 	 * core (e.g. timer irq), then they will not have been enabled
 	 * for us: do so
 	 */
-
-	gic_cpu_init(0, OMAP2_IO_ADDRESS(OMAP44XX_GIC_CPU_BASE));
+	gic_cpu_init(0, gic_cpu_base_addr);
 
 	/*
 	 * Synchronise with the boot thread.
@@ -79,7 +79,7 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	 * the AuxCoreBoot1 register is updated with cpu state
 	 * A barrier is added to ensure that write buffer is drained
 	 */
-	__raw_writel(cpu, OMAP4_AUXCOREBOOT_REG1);
+	__raw_writel(cpu, omap4_auxcoreboot_reg1);
 	smp_wmb();
 
 	timeout = jiffies + (1 * HZ);
@@ -104,7 +104,7 @@ static void __init wakeup_secondary(void)
 	 * A barrier is added to ensure that write buffer is drained
 	 */
 	__raw_writel(virt_to_phys(omap_secondary_startup),	   \
-					OMAP4_AUXCOREBOOT_REG0);
+					omap4_auxcoreboot_reg0);
 	smp_wmb();
 
 	/*
@@ -120,7 +120,13 @@ static void __init wakeup_secondary(void)
  */
 void __init smp_init_cpus(void)
 {
-	unsigned int i, ncores = get_core_count();
+	unsigned int i, ncores;
+
+	/* Never released */
+	scu_base = ioremap(OMAP44XX_SCU_BASE, SZ_256);
+	BUG_ON(!scu_base);
+
+	ncores = get_core_count();
 
 	for (i = 0; i < ncores; i++)
 		set_cpu_possible(i, true);
@@ -130,6 +136,7 @@ void __init smp_prepare_cpus(unsigned int max_cpus)
 {
 	unsigned int ncores = get_core_count();
 	unsigned int cpu = smp_processor_id();
+	void __iomem *omap4_wkupgen_base;
 	int i;
 
 	/* sanity check */
@@ -161,6 +168,12 @@ void __init smp_prepare_cpus(unsigned int max_cpus)
 	for (i = 0; i < max_cpus; i++)
 		set_cpu_present(i, true);
 
+	/* Never released */
+	omap4_wkupgen_base = ioremap(OMAP44XX_WKUPGEN_BASE, SZ_4K);
+	BUG_ON(!omap4_wkupgen_base);
+	omap4_auxcoreboot_reg0 = omap4_wkupgen_base + 0x800;
+	omap4_auxcoreboot_reg1 = omap4_wkupgen_base + 0x804;
+
 	if (max_cpus > 1) {
 		/*
 		 * Enable the local timer or broadcast device for the

commit 941132606c7611246d2034cb7b01f9270c2d1ede
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Aug 28 10:50:33 2009 -0700

    OMAP: Remove OMAP_IO_ADDRESS, use OMAP1_IO_ADDRESS and OMAP2_IO_ADDRESS instead
    
    Search and replace OMAP_IO_ADDRESS with OMAP1_IO_ADDRESS and OMAP2_IO_ADDRESS,
    and convert omap_read/write into a functions instead of a macros.
    
    Also rename OMAP_MPUIO_VBASE to OMAP1_MPUIO_VBASE.
    
    In the long run, most code should use ioremap + __raw_read/write instead.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 8fe8d230f21b..48ee295db275 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -54,7 +54,7 @@ void __cpuinit platform_secondary_init(unsigned int cpu)
 	 * for us: do so
 	 */
 
-	gic_cpu_init(0, IO_ADDRESS(OMAP44XX_GIC_CPU_BASE));
+	gic_cpu_init(0, OMAP2_IO_ADDRESS(OMAP44XX_GIC_CPU_BASE));
 
 	/*
 	 * Synchronise with the boot thread.

commit 367cd31ee0cbc948fe3b83960b1dbf931e2eaa90
Author: Santosh Shilimkar <santosh.shilimkar@ti.com>
Date:   Tue Apr 28 20:51:52 2009 +0530

    ARM: OMAP4: SMP: Add OMAP4430 SMP board files
    
    This patch adds SMP platform files support for OMAP4430SDP. TI's OMAP4430
    SOC is based on ARM Cortex-A9 SMP architecture. It's a dual core SOC
    with GIC used for interrupt handling and SCU for cache coherency.
    
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>

diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
new file mode 100644
index 000000000000..8fe8d230f21b
--- /dev/null
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -0,0 +1,178 @@
+/*
+ * OMAP4 SMP source file. It contains platform specific fucntions
+ * needed for the linux smp kernel.
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * Author:
+ *      Santosh Shilimkar <santosh.shilimkar@ti.com>
+ *
+ * Platform file needed for the OMAP4 SMP. This file is based on arm
+ * realview smp platform.
+ * * Copyright (c) 2002 ARM Limited.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/jiffies.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+
+#include <asm/localtimer.h>
+#include <asm/smp_scu.h>
+#include <mach/hardware.h>
+
+/* Registers used for communicating startup information */
+#define OMAP4_AUXCOREBOOT_REG0		(OMAP44XX_VA_WKUPGEN_BASE + 0x800)
+#define OMAP4_AUXCOREBOOT_REG1		(OMAP44XX_VA_WKUPGEN_BASE + 0x804)
+
+/* SCU base address */
+static void __iomem *scu_base = OMAP44XX_VA_SCU_BASE;
+
+/*
+ * Use SCU config register to count number of cores
+ */
+static inline unsigned int get_core_count(void)
+{
+	if (scu_base)
+		return scu_get_core_count(scu_base);
+	return 1;
+}
+
+static DEFINE_SPINLOCK(boot_lock);
+
+void __cpuinit platform_secondary_init(unsigned int cpu)
+{
+	trace_hardirqs_off();
+
+	/*
+	 * If any interrupts are already enabled for the primary
+	 * core (e.g. timer irq), then they will not have been enabled
+	 * for us: do so
+	 */
+
+	gic_cpu_init(0, IO_ADDRESS(OMAP44XX_GIC_CPU_BASE));
+
+	/*
+	 * Synchronise with the boot thread.
+	 */
+	spin_lock(&boot_lock);
+	spin_unlock(&boot_lock);
+}
+
+int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	unsigned long timeout;
+
+	/*
+	 * Set synchronisation state between this boot processor
+	 * and the secondary one
+	 */
+	spin_lock(&boot_lock);
+
+	/*
+	 * Update the AuxCoreBoot1 with boot state for secondary core.
+	 * omap_secondary_startup() routine will hold the secondary core till
+	 * the AuxCoreBoot1 register is updated with cpu state
+	 * A barrier is added to ensure that write buffer is drained
+	 */
+	__raw_writel(cpu, OMAP4_AUXCOREBOOT_REG1);
+	smp_wmb();
+
+	timeout = jiffies + (1 * HZ);
+	while (time_before(jiffies, timeout))
+		;
+
+	/*
+	 * Now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	spin_unlock(&boot_lock);
+
+	return 0;
+}
+
+static void __init wakeup_secondary(void)
+{
+	/*
+	 * Write the address of secondary startup routine into the
+	 * AuxCoreBoot0 where ROM code will jump and start executing
+	 * on secondary core once out of WFE
+	 * A barrier is added to ensure that write buffer is drained
+	 */
+	__raw_writel(virt_to_phys(omap_secondary_startup),	   \
+					OMAP4_AUXCOREBOOT_REG0);
+	smp_wmb();
+
+	/*
+	 * Send a 'sev' to wake the secondary core from WFE.
+	 */
+	set_event();
+	mb();
+}
+
+/*
+ * Initialise the CPU possible map early - this describes the CPUs
+ * which may be present or become present in the system.
+ */
+void __init smp_init_cpus(void)
+{
+	unsigned int i, ncores = get_core_count();
+
+	for (i = 0; i < ncores; i++)
+		set_cpu_possible(i, true);
+}
+
+void __init smp_prepare_cpus(unsigned int max_cpus)
+{
+	unsigned int ncores = get_core_count();
+	unsigned int cpu = smp_processor_id();
+	int i;
+
+	/* sanity check */
+	if (ncores == 0) {
+		printk(KERN_ERR
+		       "OMAP4: strange core count of 0? Default to 1\n");
+		ncores = 1;
+	}
+
+	if (ncores > NR_CPUS) {
+		printk(KERN_WARNING
+		       "OMAP4: no. of cores (%d) greater than configured "
+		       "maximum of %d - clipping\n",
+		       ncores, NR_CPUS);
+		ncores = NR_CPUS;
+	}
+	smp_store_cpu_info(cpu);
+
+	/*
+	 * are we trying to boot more cores than exist?
+	 */
+	if (max_cpus > ncores)
+		max_cpus = ncores;
+
+	/*
+	 * Initialise the present map, which describes the set of CPUs
+	 * actually populated at the present time.
+	 */
+	for (i = 0; i < max_cpus; i++)
+		set_cpu_present(i, true);
+
+	if (max_cpus > 1) {
+		/*
+		 * Enable the local timer or broadcast device for the
+		 * boot CPU, but only if we have more than one CPU.
+		 */
+		percpu_timer_setup();
+
+		/*
+		 * Initialise the SCU and wake up the secondary core using
+		 * wakeup_secondary().
+		 */
+		scu_enable(scu_base);
+		wakeup_secondary();
+	}
+}
